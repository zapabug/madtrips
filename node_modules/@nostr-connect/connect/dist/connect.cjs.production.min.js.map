{"version":3,"file":"connect.cjs.production.min.js","sources":["../src/connect.ts","../src/rpc.ts","../src/nostr.ts"],"sourcesContent":["import EventEmitter from 'events';\nimport { Event, getPublicKey, nip04, Kind } from 'nostr-tools';\nimport { nip26 } from 'nostr-tools';\n\nimport { isValidRequest, NostrRPC } from './rpc';\n\nexport interface Metadata {\n  name: string;\n  url?: string;\n  description?: string;\n  icons?: string[];\n}\n\nexport enum TimeRanges {\n  FIVE_MINS = '5mins',\n  ONE_HR = '1hour',\n  ONE_DAY = '1day',\n  ONE_WEEK = '1week',\n  ONE_MONTH = '1month',\n  ONE_YEAR = '1year',\n}\nexport const TimeRangeToUnix: Record<TimeRanges, number> = {\n  [TimeRanges.FIVE_MINS]: Math.round(Date.now() / 1000) + 60 * 5,\n  [TimeRanges.ONE_HR]: Math.round(Date.now() / 1000) + 60 * 60,\n  [TimeRanges.ONE_DAY]: Math.round(Date.now() / 1000) + 60 * 60 * 24,\n  [TimeRanges.ONE_WEEK]: Math.round(Date.now() / 1000) + 60 * 60 * 24 * 7,\n  [TimeRanges.ONE_MONTH]: Math.round(Date.now() / 1000) + 60 * 60 * 24 * 30,\n  [TimeRanges.ONE_YEAR]: Math.round(Date.now() / 1000) + 60 * 60 * 24 * 365,\n};\n\nexport class ConnectURI {\n  target: string;\n  metadata: Metadata;\n  relay: string;\n\n  static fromURI(uri: string): ConnectURI {\n    const url = new URL(uri);\n    const target = url.hostname || url.pathname.substring(2);\n    if (!target) throw new Error('Invalid connect URI: missing target');\n    const relay = url.searchParams.get('relay');\n    if (!relay) {\n      throw new Error('Invalid connect URI: missing relay');\n    }\n    const metadata = url.searchParams.get('metadata');\n    if (!metadata) {\n      throw new Error('Invalid connect URI: missing metadata');\n    }\n\n    /* eslint-disable @typescript-eslint/no-unused-vars */\n    try {\n      const md = JSON.parse(metadata);\n      return new ConnectURI({ target, metadata: md, relay });\n    } catch (ignore) {\n      throw new Error('Invalid connect URI: metadata is not valid JSON');\n    }\n  }\n\n  constructor({\n    target,\n    metadata,\n    relay,\n  }: {\n    target: string;\n    metadata: Metadata;\n    relay: string;\n  }) {\n    this.target = target;\n    this.metadata = metadata;\n    this.relay = relay;\n  }\n\n  toString() {\n    return `nostrconnect://${this.target}?metadata=${encodeURIComponent(\n      JSON.stringify(this.metadata)\n    )}&relay=${encodeURIComponent(this.relay)}`;\n  }\n\n  async approve(secretKey: string): Promise<void> {\n    const rpc = new NostrRPC({\n      relay: this.relay,\n      secretKey,\n    });\n    await rpc.call(\n      {\n        target: this.target,\n        request: {\n          method: 'connect',\n          params: [getPublicKey(secretKey)],\n        },\n      },\n      { skipResponse: true }\n    );\n  }\n\n  async reject(secretKey: string): Promise<void> {\n    const rpc = new NostrRPC({\n      relay: this.relay,\n      secretKey,\n    });\n    await rpc.call(\n      {\n        target: this.target,\n        request: {\n          method: 'disconnect',\n          params: [],\n        },\n      },\n      { skipResponse: true }\n    );\n  }\n}\n\nexport class Connect {\n  rpc: NostrRPC;\n  target?: string;\n  events = new EventEmitter();\n\n  constructor({\n    target,\n    relay,\n    secretKey,\n  }: {\n    secretKey: string;\n    target?: string;\n    relay?: string;\n  }) {\n    this.rpc = new NostrRPC({ relay, secretKey });\n    if (target) {\n      this.target = target;\n    }\n  }\n\n  async init() {\n    const sub = await this.rpc.listen();\n    sub.on('event', async (event: Event) => {\n      let payload;\n      /* eslint-disable @typescript-eslint/no-unused-vars */\n      try {\n        const plaintext = await nip04.decrypt(\n          this.rpc.self.secret,\n          event.pubkey,\n          event.content\n        );\n        if (!plaintext) throw new Error('failed to decrypt event');\n        payload = JSON.parse(plaintext);\n      } catch (ignore) {\n        return;\n      }\n\n      // ignore all the events that are not NostrRPCRequest events\n      if (!isValidRequest(payload)) return;\n\n      switch (payload.method) {\n        case 'connect': {\n          if (!payload.params || payload.params.length !== 1)\n            throw new Error('connect: missing pubkey');\n          const [pubkey] = payload.params;\n          this.target = pubkey;\n          this.events.emit('connect', pubkey);\n          break;\n        }\n        case 'disconnect': {\n          this.target = undefined;\n          this.events.emit('disconnect');\n          break;\n        }\n        default:\n      }\n    });\n  }\n\n  on(evt: 'connect' | 'disconnect', cb: (...args: any[]) => void) {\n    this.events.on(evt, cb);\n  }\n  off(evt: 'connect' | 'disconnect', cb: (...args: any[]) => void) {\n    this.events.off(evt, cb);\n  }\n\n  async disconnect(): Promise<void> {\n    if (!this.target) throw new Error('Not connected');\n\n    // notify the UI that we are disconnecting\n    this.events.emit('disconnect');\n\n    try {\n      await this.rpc.call(\n        {\n          target: this.target,\n          request: {\n            method: 'disconnect',\n            params: [],\n          },\n        },\n        { skipResponse: true }\n      );\n    } catch (error) {\n      throw new Error('Failed to disconnect');\n    }\n\n    this.target = undefined;\n  }\n\n  async getPublicKey(): Promise<string> {\n    if (!this.target) throw new Error('Not connected');\n\n    const response = await this.rpc.call({\n      target: this.target,\n      request: {\n        method: 'get_public_key',\n        params: [],\n      },\n    });\n    return response as string;\n  }\n\n  async signEvent(event: {\n    kind: Kind;\n    tags: string[][];\n    pubkey: string;\n    content: string;\n    created_at: number;\n  }): Promise<Event> {\n    if (!this.target) throw new Error('Not connected');\n\n    const eventWithSig = await this.rpc.call({\n      target: this.target,\n      request: {\n        method: 'sign_event',\n        params: [event],\n      },\n    });\n\n    return eventWithSig as Event;\n  }\n\n  async describe(): Promise<string[]> {\n    if (!this.target) throw new Error('Not connected');\n\n    const response = await this.rpc.call({\n      target: this.target,\n      request: {\n        method: 'describe',\n        params: [],\n      },\n    });\n    return response as string[];\n  }\n\n  async delegate(\n    delegatee: string = this.rpc.self.pubkey,\n    conditions: {\n      kind?: number;\n      until?: number | TimeRanges;\n      since?: number | TimeRanges;\n    }\n  ): Promise<nip26.Delegation> {\n    if (!this.target) throw new Error('Not connected');\n\n    if (conditions.until && typeof conditions.until !== 'number') {\n      if (!Object.keys(TimeRangeToUnix).includes(conditions.until))\n        throw new Error(\n          'conditions.until must be either a number or a valid TimeRange'\n        );\n      conditions.until = TimeRangeToUnix[conditions.until];\n    }\n    if (conditions.since && typeof conditions.since !== 'number') {\n      if (!Object.keys(TimeRangeToUnix).includes(conditions.since))\n        throw new Error(\n          'conditions.since must be either a number or a valid TimeRange'\n        );\n      conditions.since = TimeRangeToUnix[conditions.since];\n    }\n\n    const delegation = await this.rpc.call({\n      target: this.target,\n      request: {\n        method: 'delegate',\n        params: [delegatee, conditions],\n      },\n    });\n    return delegation as nip26.Delegation;\n  }\n\n  async getRelays(): Promise<{\n    [url: string]: { read: boolean; write: boolean };\n  }> {\n    throw new Error('Not implemented');\n  }\n\n  nip04 = {\n    encrypt: async (_pubkey: string, _plaintext: string): Promise<string> => {\n      throw new Error('Not implemented');\n    },\n    decrypt: async (_pubkey: string, _ciphertext: string): Promise<string> => {\n      throw new Error('Not implemented');\n    },\n  };\n}\n","import EventEmitter from 'events';\nimport {\n  Event,\n  Filter,\n  getEventHash,\n  getPublicKey,\n  nip04,\n  Relay,\n  relayInit,\n  signEvent,\n  Sub,\n  validateEvent,\n  verifySignature,\n} from 'nostr-tools';\n\nexport interface NostrRPCRequest {\n  id: string;\n  method: string;\n  params: any[];\n}\nexport interface NostrRPCResponse {\n  id: string;\n  result: any;\n  error: any;\n}\n\nexport class NostrRPC {\n  relay: string;\n  self: { pubkey: string; secret: string };\n  event: Event | undefined;\n  // this is for implementing the response handlers for each method\n  [key: string]: any;\n  // events\n  events = new EventEmitter();\n\n  constructor(opts: { relay?: string; secretKey: string }) {\n    this.relay = opts.relay || 'wss://nostr.vulpem.com';\n    this.self = {\n      pubkey: getPublicKey(opts.secretKey),\n      secret: opts.secretKey,\n    };\n  }\n\n  async call(\n    {\n      target,\n      request: { id = randomID(), method, params = [] },\n    }: {\n      target: string;\n      request: {\n        id?: string;\n        method: string;\n        params?: any[];\n      };\n    },\n    opts?: { skipResponse?: boolean; timeout?: number }\n  ): Promise<any> {\n    // connect to relay\n    const relay = await connectToRelay(this.relay);\n\n    // prepare request to be sent\n    const request = prepareRequest(id, method, params);\n    const event = await prepareEvent(this.self.secret, target, request);\n\n    return new Promise<void>(async (resolve, reject) => {\n      const sub = relay.sub([\n        {\n          kinds: [24133],\n          authors: [target],\n          '#p': [this.self.pubkey],\n          limit: 1,\n        } as Filter,\n      ]);\n\n      await broadcastToRelay(relay, event, true);\n\n      // skip waiting for response from remote\n      if (opts && opts.skipResponse === true) resolve();\n\n      sub.on('event', async (event: Event) => {\n        let payload;\n        /* eslint-disable @typescript-eslint/no-unused-vars */\n        try {\n          const plaintext = await nip04.decrypt(\n            this.self.secret,\n            event.pubkey,\n            event.content\n          );\n          if (!plaintext) throw new Error('failed to decrypt event');\n          payload = JSON.parse(plaintext);\n        } catch (ignore) {\n          return;\n        }\n\n        // ignore all the events that are not NostrRPCResponse events\n        if (!isValidResponse(payload)) return;\n\n        // ignore all the events that are not for this request\n        if (payload.id !== id) return;\n\n        // if the response is an error, reject the promise\n        if (payload.error) {\n          reject(payload.error);\n        }\n\n        // if the response is a result, resolve the promise\n        if (payload.result) {\n          resolve(payload.result);\n        }\n      });\n    });\n  }\n\n  async listen(): Promise<Sub> {\n    const relay = await connectToRelay(this.relay);\n\n    const sub = relay.sub([\n      {\n        kinds: [24133],\n        '#p': [this.self.pubkey],\n        since: now(),\n      } as Filter,\n    ]);\n\n    sub.on('event', async (event: Event) => {\n      let payload: NostrRPCRequest;\n      /* eslint-disable @typescript-eslint/no-unused-vars */\n      try {\n        const plaintext = await nip04.decrypt(\n          this.self.secret,\n          event.pubkey,\n          event.content\n        );\n        if (!plaintext) throw new Error('failed to decrypt event');\n        payload = JSON.parse(plaintext);\n      } catch (ignore) {\n        return;\n      }\n\n      // ignore all the events that are not NostrRPCRequest events\n      if (!isValidRequest(payload)) return;\n\n      // handle request\n      if (typeof this[payload.method] !== 'function') Promise.resolve();\n      const response = await this.handleRequest(payload, event);\n\n      const body = prepareResponse(\n        response.id,\n        response.result,\n        response.error\n      );\n\n      const responseEvent = await prepareEvent(\n        this.self.secret,\n        event.pubkey,\n        body\n      );\n\n      // send response via relay\n      relay.publish(responseEvent);\n    });\n\n    return sub;\n  }\n\n  private async handleRequest(\n    request: NostrRPCRequest,\n    event: Event\n  ): Promise<NostrRPCResponse> {\n    const { id, method, params } = request;\n    let result = null;\n    let error = null;\n    try {\n      this.event = event;\n      result = await this[method](...params);\n      this.event = undefined;\n    } catch (e) {\n      if (e instanceof Error) {\n        error = e.message;\n      } else {\n        error = 'unknown error';\n      }\n    }\n    return {\n      id,\n      result,\n      error,\n    };\n  }\n}\n\nexport function now(): number {\n  return Math.floor(Date.now() / 1000);\n}\nexport function randomID(): string {\n  return Math.random()\n    .toString()\n    .slice(2);\n}\nexport function prepareRequest(\n  id: string,\n  method: string,\n  params: any[]\n): string {\n  return JSON.stringify({\n    id,\n    method,\n    params,\n  });\n}\nexport function prepareResponse(id: string, result: any, error: any): string {\n  return JSON.stringify({\n    id,\n    result,\n    error,\n  });\n}\nexport async function prepareEvent(\n  secretKey: string,\n  pubkey: string,\n  content: string\n): Promise<Event> {\n  const cipherText = await nip04.encrypt(secretKey, pubkey, content);\n\n  const event: Event = {\n    kind: 24133,\n    created_at: now(),\n    pubkey: getPublicKey(secretKey),\n    tags: [['p', pubkey]],\n    content: cipherText,\n    id: '',\n    sig: '',\n  };\n\n  const id = getEventHash(event);\n  const sig = signEvent(event, secretKey);\n\n  const signedEvent = { ...event, id, sig };\n  const ok = validateEvent(signedEvent);\n  const veryOk = verifySignature(signedEvent);\n  if (!ok || !veryOk) {\n    throw new Error('Event is not valid');\n  }\n\n  return signedEvent;\n}\n\nexport function isValidRequest(payload: any): boolean {\n  if (!payload) return false;\n\n  const keys = Object.keys(payload);\n  if (\n    !keys.includes('id') ||\n    !keys.includes('method') ||\n    !keys.includes('params')\n  )\n    return false;\n\n  return true;\n}\n\nexport function isValidResponse(payload: any): boolean {\n  if (!payload) return false;\n\n  const keys = Object.keys(payload);\n  if (\n    !keys.includes('id') ||\n    !keys.includes('result') ||\n    !keys.includes('error')\n  )\n    return false;\n\n  return true;\n}\n\nexport async function connectToRelay(realayURL: string) {\n  const relay = relayInit(realayURL);\n  await relay.connect();\n  await new Promise<void>((resolve, reject) => {\n    relay.on('connect', () => {\n      resolve();\n    });\n    relay.on('error', () => {\n      reject(new Error(`not possible to connect to ${relay.url}`));\n    });\n  });\n  return relay;\n}\nexport async function broadcastToRelay(\n  relay: Relay,\n  event: Event,\n  skipSeen: boolean = false\n) {\n  // send request via relay\n  return await new Promise<void>((resolve, reject) => {\n    relay.on('error', () => {\n      reject(new Error(`failed to connect to ${relay.url}`));\n    });\n    const pub = relay.publish(event);\n    if (skipSeen) resolve();\n    pub.on('failed', (reason: any) => {\n      reject(reason);\n    });\n    pub.on('ok', () => {\n      resolve();\n    });\n  });\n}\n","import { NostrRPC } from './rpc';\n\nexport class NostrSigner extends NostrRPC {\n  async disconnect(): Promise<null> {\n    this.events.emit('disconnect');\n    return null;\n  }\n  isConnected(): boolean {\n    throw new Error('Method not implemented yet.');\n  }\n}\n"],"names":["TimeRanges","NostrRPC","opts","this","EventEmitter","relay","self","pubkey","getPublicKey","secretKey","secret","_proto","call","target","id","request","randomID","method","params","_context3","connectToRelay","prepareRequest","prepareEvent","event","Promise","resolve","reject","sub","kinds","authors","#p","_this","limit","_context2","broadcastToRelay","skipResponse","on","_context","nip04","decrypt","content","plaintext","Error","payload","JSON","parse","isValidResponse","error","result","listen","_context5","since","now","_context4","_this2","isValidRequest","handleRequest","body","prepareResponse","response","publish","_context6","undefined","message","Math","floor","Date","random","toString","slice","stringify","_prepareEvent","_context7","encrypt","cipherText","kind","created_at","tags","sig","getEventHash","signEvent","signedEvent","ok","validateEvent","veryOk","verifySignature","keys","Object","includes","_connectToRelay","realayURL","relayInit","_context8","connect","url","_broadcastToRelay","skipSeen","_context9","pub","reason","TimeRangeToUnix","FIVE_MINS","round","ONE_HR","ONE_DAY","ONE_WEEK","ONE_MONTH","ONE_YEAR","ConnectURI","metadata","fromURI","uri","URL","hostname","pathname","substring","searchParams","get","ignore","encodeURIComponent","approve","rpc","Connect","_pubkey","_plaintext","_ciphertext","_proto2","init","length","events","emit","evt","cb","off","disconnect","describe","_context10","delegate","delegatee","conditions","_context11","until","getRelays","NostrSigner","isConnected"],"mappings":"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"}