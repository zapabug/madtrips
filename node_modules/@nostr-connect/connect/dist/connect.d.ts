/// <reference types="node" />
import EventEmitter from 'events';
import { Event, Kind } from 'nostr-tools';
import { nip26 } from 'nostr-tools';
import { NostrRPC } from './rpc';
export interface Metadata {
    name: string;
    url?: string;
    description?: string;
    icons?: string[];
}
export declare enum TimeRanges {
    FIVE_MINS = "5mins",
    ONE_HR = "1hour",
    ONE_DAY = "1day",
    ONE_WEEK = "1week",
    ONE_MONTH = "1month",
    ONE_YEAR = "1year"
}
export declare const TimeRangeToUnix: Record<TimeRanges, number>;
export declare class ConnectURI {
    target: string;
    metadata: Metadata;
    relay: string;
    static fromURI(uri: string): ConnectURI;
    constructor({ target, metadata, relay, }: {
        target: string;
        metadata: Metadata;
        relay: string;
    });
    toString(): string;
    approve(secretKey: string): Promise<void>;
    reject(secretKey: string): Promise<void>;
}
export declare class Connect {
    rpc: NostrRPC;
    target?: string;
    events: EventEmitter;
    constructor({ target, relay, secretKey, }: {
        secretKey: string;
        target?: string;
        relay?: string;
    });
    init(): Promise<void>;
    on(evt: 'connect' | 'disconnect', cb: (...args: any[]) => void): void;
    off(evt: 'connect' | 'disconnect', cb: (...args: any[]) => void): void;
    disconnect(): Promise<void>;
    getPublicKey(): Promise<string>;
    signEvent(event: {
        kind: Kind;
        tags: string[][];
        pubkey: string;
        content: string;
        created_at: number;
    }): Promise<Event>;
    describe(): Promise<string[]>;
    delegate(delegatee: string | undefined, conditions: {
        kind?: number;
        until?: number | TimeRanges;
        since?: number | TimeRanges;
    }): Promise<nip26.Delegation>;
    getRelays(): Promise<{
        [url: string]: {
            read: boolean;
            write: boolean;
        };
    }>;
    nip04: {
        encrypt: (_pubkey: string, _plaintext: string) => Promise<string>;
        decrypt: (_pubkey: string, _ciphertext: string) => Promise<string>;
    };
}
