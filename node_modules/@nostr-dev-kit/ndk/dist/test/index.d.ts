import { EventEmitter } from 'tseep';
import debug$1 from 'debug';
import { LRUCache } from 'typescript-lru-cache';

declare enum NDKKind {
    Metadata = 0,
    Text = 1,
    RecommendRelay = 2,
    Contacts = 3,
    EncryptedDirectMessage = 4,
    EventDeletion = 5,
    Repost = 6,
    Reaction = 7,
    BadgeAward = 8,
    GroupChat = 9,
    GroupNote = 11,
    GroupReply = 12,
    GiftWrapSeal = 13,
    PrivateDirectMessage = 14,
    Image = 20,
    Vanish = 62,
    GiftWrap = 1059,
    GenericRepost = 16,
    ChannelCreation = 40,
    ChannelMetadata = 41,
    ChannelMessage = 42,
    ChannelHideMessage = 43,
    ChannelMuteUser = 44,
    GenericReply = 1111,
    Media = 1063,
    Report = 1984,
    Label = 1985,
    DVMReqTextExtraction = 5000,
    DVMReqTextSummarization = 5001,
    DVMReqTextTranslation = 5002,
    DVMReqTextGeneration = 5050,
    DVMReqImageGeneration = 5100,
    DVMReqTextToSpeech = 5250,
    DVMReqDiscoveryNostrContent = 5300,
    DVMReqDiscoveryNostrPeople = 5301,
    DVMReqTimestamping = 5900,
    DVMEventSchedule = 5905,
    DVMJobFeedback = 7000,
    Subscribe = 7001,
    Unsubscribe = 7002,
    SubscriptionReceipt = 7003,
    CashuReserve = 7373,
    CashuQuote = 7374,
    CashuToken = 7375,
    CashuWalletTx = 7376,
    GroupAdminAddUser = 9000,
    GroupAdminRemoveUser = 9001,
    GroupAdminEditMetadata = 9002,
    GroupAdminEditStatus = 9006,
    GroupAdminCreateGroup = 9007,
    GroupAdminRequestJoin = 9021,
    MuteList = 10000,
    PinList = 10001,
    RelayList = 10002,
    BookmarkList = 10003,
    CommunityList = 10004,
    PublicChatList = 10005,
    BlockRelayList = 10006,
    SearchRelayList = 10007,
    SimpleGroupList = 10009,
    InterestList = 10015,
    CashuMintList = 10019,
    EmojiList = 10030,
    DirectMessageReceiveRelayList = 10050,
    BlossomList = 10063,
    NostrWaletConnectInfo = 13194,
    TierList = 17000,
    CashuWallet = 17375,
    FollowSet = 30000,
    CategorizedPeopleList = 30000,// Deprecated but left for backwards compatibility
    CategorizedBookmarkList = 30001,// Deprecated but left for backwards compatibility
    RelaySet = 30002,
    CategorizedRelayList = 30002,// Deprecated but left for backwards compatibility
    BookmarkSet = 30003,
    /**
     * @deprecated Use ArticleCurationSet instead
     */
    CurationSet = 30004,// Deprecated but left for backwards compatibility
    ArticleCurationSet = 30004,
    VideoCurationSet = 30005,
    ImageCurationSet = 30006,
    InterestSet = 30015,
    InterestsList = 30015,// Deprecated but left for backwards compatibility
    EmojiSet = 30030,
    ModularArticle = 30040,
    ModularArticleItem = 30041,
    Wiki = 30818,
    Draft = 31234,
    SubscriptionTier = 37001,
    EcashMintRecommendation = 38000,
    HighlightSet = 39802,
    CategorizedHighlightList = 39802,// Deprecated but left for backwards compatibility
    Nutzap = 9321,
    ZapRequest = 9734,
    Zap = 9735,
    Highlight = 9802,
    ClientAuth = 22242,
    NostrWalletConnectReq = 23194,
    NostrWalletConnectRes = 23195,
    NostrConnect = 24133,
    BlossomUpload = 24242,
    HttpAuth = 27235,
    ProfileBadge = 30008,
    BadgeDefinition = 30009,
    MarketStall = 30017,
    MarketProduct = 30018,
    Article = 30023,
    AppSpecificData = 30078,
    Classified = 30402,
    HorizontalVideo = 34235,
    VerticalVideo = 34236,
    LegacyCashuWallet = 37375,
    GroupMetadata = 39000,// NIP-29
    GroupAdmins = 39001,// NIP-29
    GroupMembers = 39002,// NIP-29
    AppRecommendation = 31989,
    AppHandler = 31990
}

/**
 * NDKUserProfile represents a user's kind 0 profile metadata
 */
interface NDKUserProfile {
    [key: string]: string | number | undefined;
    created_at?: number;
    name?: string;
    displayName?: string;
    /**
     * @deprecated Use picture instead
     */
    image?: string;
    picture?: string;
    banner?: string;
    bio?: string;
    nip05?: string;
    lud06?: string;
    lud16?: string;
    about?: string;
    website?: string;
    profileEvent?: string;
}

type NDKPoolStats = {
    total: number;
    connected: number;
    disconnected: number;
    connecting: number;
};
/**
 * Handles connections to all relays. A single pool should be used per NDK instance.
 *
 * @emit connecting - Emitted when a relay in the pool is connecting.
 * @emit connect - Emitted when all relays in the pool are connected, or when the specified timeout has elapsed, and some relays are connected.
 * @emit notice - Emitted when a relay in the pool sends a notice.
 * @emit flapping - Emitted when a relay in the pool is flapping.
 * @emit relay:connect - Emitted when a relay in the pool connects.
 * @emit relay:ready - Emitted when a relay in the pool is ready to serve requests.
 * @emit relay:disconnect - Emitted when a relay in the pool disconnects.
 */
declare class NDKPool extends EventEmitter<{
    notice: (relay: NDKRelay, notice: string) => void;
    flapping: (relay: NDKRelay) => void;
    connect: () => void;
    "relay:connecting": (relay: NDKRelay) => void;
    /**
     * Emitted when a relay in the pool connects.
     * @param relay - The relay that connected.
     */
    "relay:connect": (relay: NDKRelay) => void;
    "relay:ready": (relay: NDKRelay) => void;
    "relay:disconnect": (relay: NDKRelay) => void;
    "relay:auth": (relay: NDKRelay, challenge: string) => void;
    "relay:authed": (relay: NDKRelay) => void;
}> {
    private _relays;
    private status;
    autoConnectRelays: Set<string>;
    poolBlacklistRelayUrls: Set<string>;
    private debug;
    private temporaryRelayTimers;
    private flappingRelays;
    private backoffTimes;
    private ndk;
    get blacklistRelayUrls(): Set<string>;
    /**
     * @param relayUrls - The URLs of the relays to connect to.
     * @param blacklistedRelayUrls - URLs to blacklist for this pool IN ADDITION to those blacklisted at the ndk-level
     * @param ndk - The NDK instance.
     * @param opts - Options for the pool.
     */
    constructor(relayUrls: WebSocket["url"][] | undefined, blacklistedRelayUrls: WebSocket["url"][] | undefined, ndk: NDK, { debug, name }?: {
        debug?: debug$1.Debugger;
        name?: string;
    });
    get relays(): Map<string, NDKRelay>;
    set relayUrls(urls: WebSocket["url"][]);
    private _name;
    get name(): string;
    set name(name: string);
    /**
     * Adds a relay to the pool, and sets a timer to remove it if it is not used within the specified time.
     * @param relay - The relay to add to the pool.
     * @param removeIfUnusedAfter - The time in milliseconds to wait before removing the relay from the pool after it is no longer used.
     */
    useTemporaryRelay(relay: NDKRelay, removeIfUnusedAfter?: number, filters?: NDKFilter[] | string): void;
    /**
     * Adds a relay to the pool.
     *
     * @param relay - The relay to add to the pool.
     * @param connect - Whether or not to connect to the relay.
     */
    addRelay(relay: NDKRelay, connect?: boolean): void;
    /**
     * Removes a relay from the pool.
     * @param relayUrl - The URL of the relay to remove.
     * @returns {boolean} True if the relay was removed, false if it was not found.
     */
    removeRelay(relayUrl: string): boolean;
    /**
     * Checks whether a relay is already connected in the pool.
     */
    isRelayConnected(url: WebSocket["url"]): boolean;
    /**
     * Fetches a relay from the pool, or creates a new one if it does not exist.
     *
     * New relays will be attempted to be connected.
     */
    getRelay(url: WebSocket["url"], connect?: boolean, temporary?: boolean, filters?: NDKFilter[]): NDKRelay;
    private handleRelayConnect;
    private handleRelayReady;
    /**
     * Attempts to establish a connection to each relay in the pool.
     *
     * @async
     * @param {number} [timeoutMs] - Optional timeout in milliseconds for each connection attempt.
     * @returns {Promise<void>} A promise that resolves when all connection attempts have completed.
     * @throws {Error} If any of the connection attempts result in an error or timeout.
     */
    connect(timeoutMs?: number): Promise<void>;
    private checkOnFlappingRelays;
    private handleFlapping;
    size(): number;
    /**
     * Returns the status of each relay in the pool.
     * @returns {NDKPoolStats} An object containing the number of relays in each status.
     */
    stats(): NDKPoolStats;
    connectedRelays(): NDKRelay[];
    permanentAndConnectedRelays(): NDKRelay[];
    /**
     * Get a list of all relay urls in the pool.
     */
    urls(): string[];
}

type NDKPaymentConfirmationLN = {
    preimage: string;
};
type LNPaymentRequest = string;
type LnPaymentInfo = {
    pr: LNPaymentRequest;
};
type NDKLUD18ServicePayerData = Partial<{
    name: {
        mandatory: boolean;
    };
    pubkey: {
        mandatory: boolean;
    };
    identifier: {
        mandatory: boolean;
    };
    email: {
        mandatory: boolean;
    };
    auth: {
        mandatory: boolean;
        k1: string;
    };
}> & Record<string, unknown>;
type NDKLnUrlData = {
    tag: string;
    callback: string;
    minSendable: number;
    maxSendable: number;
    metadata: string;
    payerData?: NDKLUD18ServicePayerData;
    commentAllowed?: number;
    /**
     * Pubkey of the zapper that should publish zap receipts for this user
     */
    nostrPubkey?: Hexpubkey;
    allowsNostr?: boolean;
};

type NDKCacheEntry<T> = T & {
    cachedAt?: number;
};
interface NDKCacheAdapter {
    /**
     * Whether this cache adapter is expected to be fast.
     * If this is true, the cache will be queried before the relays.
     * When this is false, the cache will be queried in addition to the relays.
     */
    locking: boolean;
    /**
     * Weather the cache is ready.
     */
    ready?: boolean;
    /**
     * Either synchronously or asynchronously queries the cache.
     *
     * Cache adapters that return values synchronously should return an array of events.
     * Asynchronous cache adapters should call the subscription.eventReceived method for each event.
     */
    query(subscription: NDKSubscription): NDKEvent[] | Promise<NDKEvent[]>;
    setEvent(event: NDKEvent, filters: NDKFilter[], relay?: NDKRelay): Promise<void>;
    /**
     * Called when an event is deleted by the client.
     * Cache adapters should remove the event from their cache.
     * @param eventIds - The ids of the events that were deleted.
     */
    deleteEventIds?(eventIds: NDKEventId[]): Promise<void>;
    /**
     * Fetches a profile from the cache synchronously.
     * @param pubkey - The pubkey of the profile to fetch.
     * @returns The profile, or null if it is not in the cache.
     */
    fetchProfileSync?(pubkey: Hexpubkey): NDKCacheEntry<NDKUserProfile> | null;
    /**
     * Special purpose
     */
    fetchProfile?(pubkey: Hexpubkey): Promise<NDKCacheEntry<NDKUserProfile> | null>;
    saveProfile?(pubkey: Hexpubkey, profile: NDKUserProfile): void;
    /**
     * Fetches profiles that match the given filter.
     * @param filter
     * @returns NDKUserProfiles that match the filter.
     * @example
     * const searchFunc = (pubkey, profile) => profile.name.toLowerCase().includes("alice");
     * const allAliceProfiles = await cache.getProfiles(searchFunc);
     */
    getProfiles?: (filter: (pubkey: Hexpubkey, profile: NDKUserProfile) => boolean) => Promise<Map<Hexpubkey, NDKUserProfile> | undefined>;
    loadNip05?(nip05: string, maxAgeForMissing?: number): Promise<ProfilePointer | null | "missing">;
    saveNip05?(nip05: string, profile: ProfilePointer | null): void;
    /**
     * Fetches a user's LNURL data from the cache.
     * @param pubkey The pubkey of the user to fetch the LNURL data for.
     * @param maxAgeInSecs The maximum age of the data in seconds.
     * @param maxAgeForMissing The maximum age of the data in seconds if it is missing before it returns that it should be refetched.
     * @returns The LNURL data, null if it is not in the cache and under the maxAgeForMissing, or "missing" if it should be refetched.
     */
    loadUsersLNURLDoc?(pubkey: Hexpubkey, maxAgeInSecs?: number, maxAgeForMissing?: number): Promise<NDKLnUrlData | null | "missing">;
    saveUsersLNURLDoc?(pubkey: Hexpubkey, doc: NDKLnUrlData | null): void;
    /**
     * Updates information about the relay.
     */
    updateRelayStatus?(relayUrl: WebSocket["url"], info: NDKCacheRelayInfo): void;
    /**
     * Fetches information about the relay.
     */
    getRelayStatus?(relayUrl: WebSocket["url"]): NDKCacheRelayInfo | undefined;
    /**
     * Tracks a publishing event.
     * @param event
     * @param relayUrls List of relays that the event will be published to.
     */
    addUnpublishedEvent?(event: NDKEvent, relayUrls: WebSocket["url"][]): void;
    /**
     * Fetches all unpublished events.
     */
    getUnpublishedEvents?(): Promise<{
        event: NDKEvent;
        relays?: WebSocket["url"][];
        lastTryAt?: number;
    }[]>;
    /**
     * Removes an unpublished event.
     */
    discardUnpublishedEvent?(eventId: NDKEventId): void;
    /**
     * Called when the cache is ready.
     */
    onReady?(callback: () => void): void;
}
type NDKCacheRelayInfo = {
    lastConnectedAt?: number;
    dontConnectBefore?: number;
};

type ContentTag = {
    tags: NDKTag[];
    content: string;
};

type NDKEncryptionScheme = 'nip04' | 'nip44';

/**
 * Interface for NDK signers.
 */
interface NDKSigner {
    /**
     * Blocks until the signer is ready and returns the associated NDKUser.
     * @returns A promise that resolves to the NDKUser instance.
     */
    blockUntilReady(): Promise<NDKUser>;
    /**
     * Getter for the user property.
     * @returns A promise that resolves to the NDKUser instance.
     */
    user(): Promise<NDKUser>;
    /**
     * Signs the given Nostr event.
     * @param event - The Nostr event to be signed.
     * @returns A promise that resolves to the signature of the signed event.
     */
    sign(event: NostrEvent): Promise<string>;
    /**
     * Getter for the preferred relays.
     * @returns A promise containing a simple map of preferred relays and their read/write policies.
     */
    relays?(ndk?: NDK): Promise<NDKRelay[]>;
    /**
     * Determine the types of encryption (by nip) that this signer can perform.
     * Implementing classes SHOULD return a value even for legacy (only nip04) third party signers.
     * @nip Optionally returns an array with single supported nip or empty, to check for truthy or falsy.
     * @return A promised list of any (or none) of these strings  ['nip04', 'nip44']
     */
    encryptionEnabled?(scheme?: NDKEncryptionScheme): Promise<NDKEncryptionScheme[]>;
    /**
     * Encrypts the given Nostr event for the given recipient.
     * Implementing classes SHOULD equate legacy (only nip04) to nip == `nip04` || undefined
     * @param recipient - The recipient (pubkey or conversationKey) of the encrypted value.
     * @param value - The value to be encrypted.
     * @param nip - which NIP is being implemented ('nip04', 'nip44')
     */
    encrypt(recipient: NDKUser, value: string, scheme?: NDKEncryptionScheme): Promise<string>;
    /**
     * Decrypts the given value.
     * Implementing classes SHOULD equate legacy (only nip04) to nip == `nip04` || undefined
     * @param sender - The sender (pubkey or conversationKey) of the encrypted value
     * @param value - The value to be decrypted
     * @param scheme - which NIP is being implemented ('nip04', 'nip44', 'nip49')
     */
    decrypt(sender: NDKUser, value: string, scheme?: NDKEncryptionScheme): Promise<string>;
}

type Proof$1 = {
    /**
     * Keyset id, used to link proofs to a mint an its MintKeys.
     */
    id: string;
    /**
     * Amount denominated in Satoshis. Has to match the amount of the mints signing key.
     */
    amount: number;
    /**
     * The initial secret that was (randomly) chosen for the creation of this proof.
     */
    secret: string;
    /**
     * The unblinded signature for this secret, signed by the mints private key.
     */
    C: string;
};

/**
 * Represents a NIP-61 nutzap
 */
declare class NDKNutzap extends NDKEvent {
    private debug;
    private _proofs;
    static kind: NDKKind;
    static kinds: NDKKind[];
    constructor(ndk?: NDK, event?: NostrEvent | NDKEvent);
    static from(event: NDKEvent): NDKNutzap | undefined;
    set comment(comment: string | undefined);
    get comment(): string;
    set proofs(proofs: Proof$1[]);
    get proofs(): Proof$1[];
    /**
     * Gets the p2pk pubkey that is embedded in the first proof
     */
    get p2pk(): string | undefined;
    /**
     * Get the mint where this nutzap proofs exist
     */
    get mint(): string;
    set mint(value: string);
    get unit(): string;
    set unit(value: string | undefined);
    get amount(): number;
    sender: NDKUser;
    /**
     * Set the target of the nutzap
     * @param target The target of the nutzap (a user or an event)
     */
    set target(target: NDKEvent | NDKUser);
    set recipientPubkey(pubkey: Hexpubkey);
    get recipientPubkey(): Hexpubkey;
    get recipient(): NDKUser;
    toNostrEvent(): Promise<NostrEvent>;
    /**
     * Validates that the nutzap conforms to NIP-61
     */
    get isValid(): boolean;
}

/**
 * NDKAuthPolicies are functions that are called when a relay requests authentication
 * so that you can define a behavior for your application.
 *
 * @param relay The relay that requested authentication.
 * @param challenge The challenge that the relay sent.
 */
type NDKAuthPolicy = (relay: NDKRelay, challenge: string) => Promise<boolean | void | NDKEvent>;

type Nip07RelayMap = {
    [key: string]: {
        read: boolean;
        write: boolean;
    };
};
type Nip44 = {
    encrypt: (recipient: Hexpubkey, value: string) => Promise<string>;
    decrypt: (sender: Hexpubkey, value: string) => Promise<string>;
};
declare global {
    interface Window {
        nostr?: {
            getPublicKey(): Promise<string>;
            signEvent(event: NostrEvent): Promise<{
                sig: string;
            }>;
            getRelays?: () => Promise<Nip07RelayMap>;
            nip04?: {
                encrypt(recipientHexPubKey: string, value: string): Promise<string>;
                decrypt(senderHexPubKey: string, value: string): Promise<string>;
            };
            nip44?: Nip44;
        };
    }
}

type NDKFilterFingerprint = string;

type NDKEventSerialized = string;

/**
 * Provides information that should be used to send a NIP-61 nutzap.
 * mints: URLs of the mints that can be used.
 * relays: URLs of the relays where nutzap must be published
 * p2pk: Optional pubkey to use for P2PK lock
 */
type CashuPaymentInfo = {
    /**
     * Mints that must be used for the payment
     */
    mints?: string[];
    /**
     * Relays where nutzap must be published
     */
    relays?: string[];
    /**
     * Optional pubkey to use for P2PK lock
     */
    p2pk?: string;
    /**
     * Intramint fallback allowed:
     *
     * When set to true, if cross-mint payments fail, we will
     * fallback to sending an intra-mint payment.
     */
    allowIntramintFallback?: boolean;
};
/**
 * This is what a wallet implementing Cashu payments should provide back
 * when a payment has been requested.
 */
type NDKPaymentConfirmationCashu = {
    /**
     * Proof of the payment
     */
    proofs: Proof$1[];
    /**
     * Mint
     */
    mint: string;
};

type NDKZapDetails<T> = T & {
    /**
     * Target of the zap
     */
    target: NDKEvent | NDKUser;
    /**
     * Comment for the zap
     */
    comment?: string;
    /**
     * Tags to add to the zap
     */
    tags?: NDKTag[];
    /**
     * Pubkey of the user to zap to
     */
    recipientPubkey: string;
    /**
     * Amount of the payment
     */
    amount: number;
    /**
     * Unit of the payment (e.g. msat)
     */
    unit: string;
    /**
     * Description of the payment for the sender's record
     */
    paymentDescription?: string;
    /**
     * If this payment is for a nip57 zap, this will contain the zap request.
     */
    nip57ZapRequest?: NDKEvent;
    /**
     * When set to true, when a pubkey is not zappable, we will
     * automatically fallback to using NIP-61.
     *
     * Every pubkey must be able to receive money.
     *
     * @default false
     */
    nutzapAsFallback?: boolean;
};
type NDKPaymentConfirmation = NDKPaymentConfirmationLN | NDKNutzap;
type NDKZapSplit = {
    pubkey: string;
    amount: number;
};
type NDKZapMethod = "nip57" | "nip61";
type NDKLnLudData = {
    lud06?: string;
    lud16?: string;
};
type NDKZapMethodInfo = NDKLnLudData | CashuPaymentInfo;
type LnPayCb = (payment: NDKZapDetails<LnPaymentInfo>) => Promise<NDKPaymentConfirmationLN | undefined>;
type CashuPayCb = (payment: NDKZapDetails<CashuPaymentInfo>, onLnInvoice?: (pr: string) => void) => Promise<NDKPaymentConfirmationCashu | undefined>;

type Hexpubkey = string;
type Npub = string;
type ProfilePointer = {
    pubkey: string;
    relays?: string[];
    nip46?: string[];
};
interface NDKUserParams {
    npub?: Npub;
    hexpubkey?: Hexpubkey;
    pubkey?: Hexpubkey;
    nip05?: string;
    relayUrls?: string[];
    nip46Urls?: string[];
}
/**
 * Represents a pubkey.
 */
declare class NDKUser {
    ndk: NDK | undefined;
    profile?: NDKUserProfile;
    profileEvent?: NDKEvent;
    private _npub?;
    private _pubkey?;
    readonly relayUrls: string[];
    readonly nip46Urls: string[];
    constructor(opts: NDKUserParams);
    get npub(): string;
    get nprofile(): string;
    set npub(npub: Npub);
    /**
     * Get the user's pubkey
     * @returns {string} The user's pubkey
     */
    get pubkey(): string;
    /**
     * Set the user's pubkey
     * @param pubkey {string} The user's pubkey
     */
    set pubkey(pubkey: string);
    /**
     * Equivalent to NDKEvent.filters().
     * @returns {NDKFilter}
     */
    filter(): NDKFilter;
    /**
     * Gets NIP-57 and NIP-61 information that this user has signaled
     *
     * @param getAll {boolean} Whether to get all zap info or just the first one
     */
    getZapInfo(timeoutMs?: number): Promise<Map<NDKZapMethod, NDKZapMethodInfo>>;
    /**
     * Instantiate an NDKUser from a NIP-05 string
     * @param nip05Id {string} The user's NIP-05
     * @param ndk {NDK} An NDK instance
     * @param skipCache {boolean} Whether to skip the cache or not
     * @returns {NDKUser | undefined} An NDKUser if one is found for the given NIP-05, undefined otherwise.
     */
    static fromNip05(nip05Id: string, ndk: NDK, skipCache?: boolean): Promise<NDKUser | undefined>;
    /**
     * Fetch a user's profile
     * @param opts {NDKSubscriptionOptions} A set of NDKSubscriptionOptions
     * @param storeProfileEvent {boolean} Whether to store the profile event or not
     * @returns User Profile
     */
    fetchProfile(opts?: NDKSubscriptionOptions, storeProfileEvent?: boolean): Promise<NDKUserProfile | null>;
    /**
     * Returns a set of users that this user follows.
     *
     * @deprecated Use followSet instead
     */
    follows: (opts?: NDKSubscriptionOptions | undefined, outbox?: boolean | undefined, kind?: number | undefined) => Promise<Set<NDKUser>>;
    /**
     * Returns a set of pubkeys that this user follows.
     *
     * @param opts - NDKSubscriptionOptions
     * @param outbox - boolean
     * @param kind - number
     */
    followSet(opts?: NDKSubscriptionOptions, outbox?: boolean, kind?: number): Promise<Set<Hexpubkey>>;
    /** @deprecated Use referenceTags instead. */
    /**
     * Get the tag that can be used to reference this user in an event
     * @returns {NDKTag} an NDKTag
     */
    tagReference(): NDKTag;
    /**
     * Get the tags that can be used to reference this user in an event
     * @returns {NDKTag[]} an array of NDKTag
     */
    referenceTags(marker?: string): NDKTag[];
    /**
     * Publishes the current profile.
     */
    publish(): Promise<void>;
    /**
     * Add a follow to this user's contact list
     *
     * @param newFollow {NDKUser} The user to follow
     * @param currentFollowList {Set<NDKUser>} The current follow list
     * @param kind {NDKKind} The kind to use for this contact list (defaults to `3`)
     * @returns {Promise<boolean>} True if the follow was added, false if the follow already exists
     */
    follow(newFollow: NDKUser, currentFollowList?: Set<NDKUser>, kind?: NDKKind): Promise<boolean>;
    /**
     * Remove a follow from this user's contact list
     *
     * @param user {NDKUser} The user to unfollow
     * @param currentFollowList {Set<NDKUser>} The current follow list
     * @param kind {NDKKind} The kind to use for this contact list (defaults to `3`)
     * @returns The relays were the follow list was published or false if the user wasn't found
     */
    unfollow(user: NDKUser, currentFollowList?: Set<NDKUser>, kind?: NDKKind): Promise<Set<NDKRelay> | boolean>;
    /**
     * Validate a user's NIP-05 identifier (usually fetched from their kind:0 profile data)
     *
     * @param nip05Id The NIP-05 string to validate
     * @returns {Promise<boolean | null>} True if the NIP-05 is found and matches this user's pubkey,
     * False if the NIP-05 is found but doesn't match this user's pubkey,
     * null if the NIP-05 isn't found on the domain or we're unable to verify (because of network issues, etc.)
     */
    validateNip05(nip05Id: string): Promise<boolean | null>;
}

type NDKSubscriptionId = string;
/**
 * This class monitors active subscriptions.
 */
declare class NDKSubscriptionManager {
    subscriptions: Map<NDKSubscriptionId, NDKSubscription>;
    seenEvents: Map<string, NDKRelay[]>;
    constructor();
    add(sub: NDKSubscription): void;
    seenEvent(eventId: NDKEventId, relay: NDKRelay): void;
    /**
     * Whenever an event comes in, this function is called.
     * This function matches the received event against all the
     * known (i.e. active) NDKSubscriptions, and if it matches,
     * it sends the event to the subscription.
     *
     * This is the single place in the codebase that matches
     * incoming events with parties interested in the event.
     *
     * This is also what allows for reactivity in NDK apps, such that
     * whenever an active subscription receives an event that some
     * other active subscription would want to receive, both receive it.
     *
     * TODO This also allows for subscriptions that overlap in meaning
     * to be collapsed into one.
     *
     * I.e. if a subscription with filter: kinds: [1], authors: [alice]
     * is created and EOSEs, and then a subsequent subscription with
     * kinds: [1], authors: [alice] is created, once the second subscription
     * EOSEs we can safely close it, increment its refCount and close it,
     * and when the first subscription receives a new event from Alice this
     * code will make the second subscription receive the event even though
     * it has no active subscription on a relay.
     * @param event Raw event received from a relay
     * @param relay Relay that sent the event
     * @param optimisticPublish Whether the event is coming from an optimistic publish
     */
    dispatchEvent(event: NostrEvent, relay?: NDKRelay, optimisticPublish?: boolean): void;
}

type Item = {
    subscription: NDKSubscription;
    filters: NDKFilter[];
};
declare enum NDKRelaySubscriptionStatus {
    INITIAL = 0,
    /**
     * The subscription is pending execution.
     */
    PENDING = 1,
    /**
     * The subscription is waiting for the relay to be ready.
     */
    WAITING = 2,
    /**
     * The subscription is currently running.
     */
    RUNNING = 3,
    CLOSED = 4
}
/**
 * Groups together a number of NDKSubscriptions (as created by the user),
 * filters (as computed internally), executed, or to be executed, within
 * a single specific relay.
 */
declare class NDKRelaySubscription {
    fingerprint: NDKFilterFingerprint;
    items: Map<NDKSubscriptionInternalId, Item>;
    topSubManager: NDKSubscriptionManager;
    debug: debug.Debugger;
    /**
     * Tracks the status of this REQ.
     */
    status: NDKRelaySubscriptionStatus;
    onClose?: (sub: NDKRelaySubscription) => void;
    private relay;
    /**
     * Whether this subscription has reached EOSE.
     */
    private eosed;
    /**
     * Timeout at which this subscription will
     * start executing.
     */
    private executionTimer?;
    /**
     * Track the time at which this subscription will fire.
     */
    private fireTime?;
    /**
     * The delay type that the current fireTime was calculated with.
     */
    private delayType?;
    /**
     * The filters that have been executed.
     */
    executeFilters?: NDKFilter[];
    readonly id: string;
    /**
     *
     * @param fingerprint The fingerprint of this subscription.
     */
    constructor(relay: NDKRelay, fingerprint: NDKFilterFingerprint | null, topSubManager: NDKSubscriptionManager);
    private _subId?;
    get subId(): string;
    private subIdParts;
    private addSubIdPart;
    addItem(subscription: NDKSubscription, filters: NDKFilter[]): void;
    /**
     * A subscription has been closed, remove it from the list of items.
     * @param subscription
     */
    removeItem(subscription: NDKSubscription): void;
    private close;
    cleanup(): void;
    private evaluateExecutionPlan;
    private schedule;
    private executeOnRelayReady;
    private finalizeSubId;
    private reExecuteAfterAuth;
    private execute;
    onstart(): void;
    onevent(event: NostrEvent): void;
    oneose(subId: string): void;
    onclose(reason?: string): void;
    onclosed(reason?: string): void;
    /**
     * Grabs the filters from all the subscriptions
     * and merges them into a single filter.
     */
    private compileFilters;
}

declare class NDKRelayConnectivity {
    private ndkRelay;
    private ws?;
    private _status;
    private timeoutMs?;
    private connectedAt?;
    private _connectionStats;
    private debug;
    netDebug?: NDKNetDebug;
    private connectTimeout;
    private reconnectTimeout;
    private ndk?;
    openSubs: Map<string, NDKRelaySubscription>;
    private openCountRequests;
    private openEventPublishes;
    private serial;
    baseEoseTimeout: number;
    constructor(ndkRelay: NDKRelay, ndk?: NDK);
    /**
     * Connects to the NDK relay and handles the connection lifecycle.
     *
     * This method attempts to establish a WebSocket connection to the NDK relay specified in the `ndkRelay` object.
     * If the connection is successful, it updates the connection statistics, sets the connection status to `CONNECTED`,
     * and emits `connect` and `ready` events on the `ndkRelay` object.
     *
     * If the connection attempt fails, it handles the error by either initiating a reconnection attempt or emitting a
     * `delayed-connect` event on the `ndkRelay` object, depending on the `reconnect` parameter.
     *
     * @param timeoutMs - The timeout in milliseconds for the connection attempt. If not provided, the default timeout from the `ndkRelay` object is used.
     * @param reconnect - Indicates whether a reconnection should be attempted if the connection fails. Defaults to `true`.
     * @returns A Promise that resolves when the connection is established, or rejects if the connection fails.
     */
    connect(timeoutMs?: number, reconnect?: boolean): Promise<void>;
    /**
     * Disconnects the WebSocket connection to the NDK relay.
     * This method sets the connection status to `NDKRelayStatus.DISCONNECTING`,
     * attempts to close the WebSocket connection, and sets the status to
     * `NDKRelayStatus.DISCONNECTED` if the disconnect operation fails.
     */
    disconnect(): void;
    /**
     * Handles the error that occurred when attempting to connect to the NDK relay.
     * If `reconnect` is `true`, this method will initiate a reconnection attempt.
     * Otherwise, it will emit a `delayed-connect` event on the `ndkRelay` object,
     * indicating that a reconnection should be attempted after a delay.
     *
     * @param reconnect - Indicates whether a reconnection should be attempted.
     */
    onConnectionError(reconnect: boolean): void;
    /**
     * Handles the connection event when the WebSocket connection is established.
     * This method is called when the WebSocket connection is successfully opened.
     * It clears any existing connection and reconnection timeouts, updates the connection statistics,
     * sets the connection status to `CONNECTED`, and emits `connect` and `ready` events on the `ndkRelay` object.
     */
    private onConnect;
    /**
     * Handles the disconnection event when the WebSocket connection is closed.
     * This method is called when the WebSocket connection is successfully closed.
     * It updates the connection statistics, sets the connection status to `DISCONNECTED`,
     * initiates a reconnection attempt if we didn't disconnect ourselves,
     * and emits a `disconnect` event on the `ndkRelay` object.
     */
    private onDisconnect;
    /**
     * Handles incoming messages from the NDK relay WebSocket connection.
     * This method is called whenever a message is received from the relay.
     * It parses the message data and dispatches the appropriate handling logic based on the message type.
     *
     * @param event - The MessageEvent containing the received message data.
     */
    private onMessage;
    /**
     * Handles an authentication request from the NDK relay.
     *
     * If an authentication policy is configured, it will be used to authenticate the connection.
     * Otherwise, the `auth` event will be emitted to allow the application to handle the authentication.
     *
     * @param challenge - The authentication challenge provided by the NDK relay.
     */
    private onAuthRequested;
    /**
     * Handles errors that occur on the WebSocket connection to the relay.
     * @param error - The error or event that occurred.
     */
    private onError;
    /**
     * Gets the current status of the NDK relay connection.
     * @returns {NDKRelayStatus} The current status of the NDK relay connection.
     */
    get status(): NDKRelayStatus;
    /**
     * Checks if the NDK relay connection is currently available.
     * @returns {boolean} `true` if the relay connection is in the `CONNECTED` status, `false` otherwise.
     */
    isAvailable(): boolean;
    /**
     * Checks if the NDK relay connection is flapping, which means the connection is rapidly
     * disconnecting and reconnecting. This is determined by analyzing the durations of the
     * last three connection attempts. If the standard deviation of the durations is less
     * than 1000 milliseconds, the connection is considered to be flapping.
     *
     * @returns {boolean} `true` if the connection is flapping, `false` otherwise.
     */
    private isFlapping;
    /**
     * Handles a notice received from the NDK relay.
     * If the notice indicates the relay is complaining (e.g. "too many" or "maximum"),
     * the method disconnects from the relay and attempts to reconnect after a 2-second delay.
     * A debug message is logged with the relay URL and the notice text.
     * The "notice" event is emitted on the ndkRelay instance with the notice text.
     *
     * @param notice - The notice text received from the NDK relay.
     */
    private onNotice;
    /**
     * Attempts to reconnect to the NDK relay after a connection is lost.
     * This function is called recursively to handle multiple reconnection attempts.
     * It checks if the relay is flapping and emits a "flapping" event if so.
     * It then calculates a delay before the next reconnection attempt based on the number of previous attempts.
     * The function sets a timeout to execute the next reconnection attempt after the calculated delay.
     * If the maximum number of reconnection attempts is reached, a debug message is logged.
     *
     * @param attempt - The current attempt number (default is 0).
     */
    private handleReconnection;
    /**
     * Sends a message to the NDK relay if the connection is in the CONNECTED state and the WebSocket is open.
     * If the connection is not in the CONNECTED state or the WebSocket is not open, logs a debug message and throws an error.
     *
     * @param message - The message to send to the NDK relay.
     * @throws {Error} If attempting to send on a closed relay connection.
     */
    send(message: string): Promise<void>;
    /**
     * Authenticates the NDK event by sending it to the NDK relay and returning a promise that resolves with the result.
     *
     * @param event - The NDK event to authenticate.
     * @returns A promise that resolves with the authentication result.
     */
    private auth;
    /**
     * Publishes an NDK event to the relay and returns a promise that resolves with the result.
     *
     * @param event - The NDK event to publish.
     * @returns A promise that resolves with the result of the event publication.
     * @throws {Error} If attempting to publish on a closed relay connection.
     */
    publish(event: NostrEvent): Promise<string>;
    /**
     * Counts the number of events that match the provided filters.
     *
     * @param filters - The filters to apply to the count request.
     * @param params - An optional object containing a custom id for the count request.
     * @returns A promise that resolves with the number of matching events.
     * @throws {Error} If attempting to send the count request on a closed relay connection.
     */
    count(filters: NDKFilter[], params: {
        id?: string | null;
    }): Promise<number>;
    close(subId: string, reason?: string): void;
    /**
     * Subscribes to the NDK relay with the provided filters and parameters.
     *
     * @param filters - The filters to apply to the subscription.
     * @param params - The subscription parameters, including an optional custom id.
     * @returns A new NDKRelaySubscription instance.
     */
    req(relaySub: NDKRelaySubscription): void;
    /**
     * Utility functions to update the connection stats.
     */
    private updateConnectionStats;
    /** Returns the connection stats. */
    get connectionStats(): NDKRelayConnectionStats;
    /** Returns the relay URL */
    get url(): WebSocket["url"];
    get connected(): boolean;
}

type NDKRelayScore = number;

/**
 * The subscription manager of an NDKRelay is in charge of orchestrating the subscriptions
 * that are created and closed in a given relay.
 *
 * The manager is responsible for:
 * * restarting subscriptions when they are unexpectedly closed
 * * scheduling subscriptions that are received before the relay is connected
 * * grouping similar subscriptions to be compiled into individual REQs
 */
declare class NDKRelaySubscriptionManager {
    private relay;
    subscriptions: Map<NDKFilterFingerprint, NDKRelaySubscription[]>;
    private generalSubManager;
    /**
     * @param relay - The relay instance.
     * @param generalSubManager - The subscription manager instance.
     */
    constructor(relay: NDKRelay, generalSubManager: NDKSubscriptionManager);
    /**
     * Adds a subscription to the manager.
     */
    addSubscription(sub: NDKSubscription, filters: NDKFilter[]): void;
    createSubscription(sub: NDKSubscription, filters: NDKFilter[], fingerprint?: NDKFilterFingerprint): NDKRelaySubscription;
    private onRelaySubscriptionClose;
}

declare enum NDKRelayStatus {
    DISCONNECTING = 0,// 0
    DISCONNECTED = 1,// 1
    RECONNECTING = 2,// 2
    FLAPPING = 3,// 3
    CONNECTING = 4,// 4
    CONNECTED = 5,// 5
    AUTH_REQUESTED = 6,// 6
    AUTHENTICATING = 7,// 7
    AUTHENTICATED = 8
}
interface NDKRelayConnectionStats {
    /**
     * The number of times a connection has been attempted.
     */
    attempts: number;
    /**
     * The number of times a connection has been successfully established.
     */
    success: number;
    /**
     * The durations of the last 100 connections in milliseconds.
     */
    durations: number[];
    /**
     * The time the current connection was established in milliseconds.
     */
    connectedAt?: number;
    /**
     * Timestamp of the next reconnection attempt.
     */
    nextReconnectAt?: number;
    /**
     * Signature validation ratio for this relay.
     * @see NDKRelayOptions.validationRatio
     */
    validationRatio?: number;
}
/**
 * The NDKRelay class represents a connection to a relay.
 *
 * @emits NDKRelay#connect
 * @emits NDKRelay#ready
 * @emits NDKRelay#disconnect
 * @emits NDKRelay#notice
 * @emits NDKRelay#event
 * @emits NDKRelay#published when an event is published to the relay
 * @emits NDKRelay#publish:failed when an event fails to publish to the relay
 * @emits NDKRelay#eose when the relay has reached the end of stored events
 * @emits NDKRelay#auth when the relay requires authentication
 * @emits NDKRelay#authed when the relay has authenticated
 * @emits NDKRelay#delayed-connect when the relay will wait before reconnecting
 */
declare class NDKRelay extends EventEmitter<{
    connect: () => void;
    ready: () => void;
    /**
     * Emitted when the relay has reached the end of stored events.
     */
    disconnect: () => void;
    flapping: (stats: NDKRelayConnectionStats) => void;
    notice: (notice: string) => void;
    auth: (challenge: string) => void;
    authed: () => void;
    "auth:failed": (error: Error) => void;
    published: (event: NDKEvent) => void;
    "publish:failed": (event: NDKEvent, error: Error) => void;
    "delayed-connect": (delayInMs: number) => void;
}> {
    readonly url: WebSocket["url"];
    readonly scores: Map<NDKUser, NDKRelayScore>;
    connectivity: NDKRelayConnectivity;
    subs: NDKRelaySubscriptionManager;
    private publisher;
    authPolicy?: NDKAuthPolicy;
    /**
     * The lowest validation ratio this relay can reach.
     */
    lowestValidationRatio?: number;
    /**
     * Current validation ratio this relay is targeting.
     */
    targetValidationRatio?: number;
    validationRatioFn?: (relay: NDKRelay, validatedCount: number, nonValidatedCount: number) => number;
    /**
     * This tracks events that have been seen by this relay
     * with a valid signature.
     */
    private validatedEventCount;
    /**
     * This tracks events that have been seen by this relay
     * but have not been validated.
     */
    private nonValidatedEventCount;
    /**
     * Whether this relay is trusted.
     *
     * Trusted relay's events do not get their signature verified.
     */
    trusted: boolean;
    complaining: boolean;
    readonly debug: debug$1.Debugger;
    static defaultValidationRatioUpdateFn: (relay: NDKRelay, validatedCount: number, nonValidatedCount: number) => number;
    constructor(url: WebSocket["url"], authPolicy: NDKAuthPolicy | undefined, ndk: NDK);
    private updateValidationRatio;
    get status(): NDKRelayStatus;
    get connectionStats(): NDKRelayConnectionStats;
    /**
     * Connects to the relay.
     */
    connect(timeoutMs?: number, reconnect?: boolean): Promise<void>;
    /**
     * Disconnects from the relay.
     */
    disconnect(): void;
    /**
     * Queues or executes the subscription of a specific set of filters
     * within this relay.
     *
     * @param subscription NDKSubscription this filters belong to.
     * @param filters Filters to execute
     */
    subscribe(subscription: NDKSubscription, filters: NDKFilter[]): void;
    /**
     * Publishes an event to the relay with an optional timeout.
     *
     * If the relay is not connected, the event will be published when the relay connects,
     * unless the timeout is reached before the relay connects.
     *
     * @param event The event to publish
     * @param timeoutMs The timeout for the publish operation in milliseconds
     * @returns A promise that resolves when the event has been published or rejects if the operation times out
     */
    publish(event: NDKEvent, timeoutMs?: number): Promise<boolean>;
    referenceTags(): NDKTag[];
    addValidatedEvent(): void;
    addNonValidatedEvent(): void;
    /**
     * The current validation ratio this relay has achieved.
     */
    get validationRatio(): number;
    shouldValidateEvent(): boolean;
    get connected(): boolean;
    req: (relaySub: NDKRelaySubscription) => void;
    close: (subId: string) => void;
}

declare class NDKPublishError extends Error {
    errors: Map<NDKRelay, Error>;
    publishedToRelays: Set<NDKRelay>;
    /**
     * Intended relay set where the publishing was intended to happen.
     */
    intendedRelaySet?: NDKRelaySet;
    constructor(message: string, errors: Map<NDKRelay, Error>, publishedToRelays: Set<NDKRelay>, intendedRelaySet?: NDKRelaySet);
    get relayErrors(): string;
}
/**
 * A relay set is a group of relays. This grouping can be short-living, for a single
 * REQ or can be long-lasting, for example for the explicit relay list the user
 * has specified.
 *
 * Requests to relays should be sent through this interface.
 */
declare class NDKRelaySet {
    readonly relays: Set<NDKRelay>;
    private debug;
    private ndk;
    private pool;
    constructor(relays: Set<NDKRelay>, ndk: NDK, pool?: NDKPool);
    /**
     * Adds a relay to this set.
     */
    addRelay(relay: NDKRelay): void;
    get relayUrls(): WebSocket["url"][];
    /**
     * Creates a relay set from a list of relay URLs.
     *
     * If no connection to the relay is found in the pool it will temporarily
     * connect to it.
     *
     * @param relayUrls - list of relay URLs to include in this set
     * @param ndk
     * @param connect - whether to connect to the relay immediately if it was already in the pool but not connected
     * @returns NDKRelaySet
     */
    static fromRelayUrls(relayUrls: readonly string[], ndk: NDK, connect?: boolean, pool?: NDKPool): NDKRelaySet;
    /**
     * Publish an event to all relays in this set. Returns the number of relays that have received the event.
     * @param event
     * @param timeoutMs - timeout in milliseconds for each publish operation and connection operation
     * @returns A set where the event was successfully published to
     * @throws NDKPublishError if no relay was able to receive the event
     * @example
     * ```typescript
     * const event = new NDKEvent(ndk, {kinds: [NDKKind.Message], "#d": ["123"]});
     * try {
     *    const publishedToRelays = await relaySet.publish(event);
     *    console.log(`published to ${publishedToRelays.size} relays`)
     * } catch (error) {
     *   console.error("error publishing to relays", error);
     *
     *   if (error instanceof NDKPublishError) {
     *      for (const [relay, err] of error.errors) {
     *         console.error(`error publishing to relay ${relay.url}`, err);
     *       }
     *   }
     * }
     * ```
     */
    publish(event: NDKEvent, timeoutMs?: number, requiredRelayCount?: number): Promise<Set<NDKRelay>>;
    get size(): number;
}

/**
 * Options on how to handle when a relay hint doesn't respond
 * with the requested event.
 *
 * When a tag includes a relay hint, and the relay hint doesn't come back
 * with the event, the fallback options are used to try to fetch the event
 * from somewhere else.
 */
type NDKFetchFallbackOptions = {
    /**
     * Relay set to use as a fallback when the hint relay doesn't respond.
     * If not provided, the normal NDK calculation is used (whether explicit relays or outbox calculation)
     * Default is `undefined`.
     */
    relaySet?: NDKRelaySet;
    /**
     * Type of fallback to use when the hint relay doesn't respond.
     * - "timeout" will wait for a timeout before falling back
     * - "eose" will wait for the EOSE before falling back
     * - "none" will not fall back
     * Default is "timeout".
     */
    type: "timeout" | "eose" | "none";
    /**
     * Timeout in milliseconds for the fallback relay.
     * Default is 1500ms.
     */
    timeout?: number;
};

type OutboxItemType = "user" | "kind";
/**
 * Tracks outbox scoring of an item. An item can be any of:
 *
 *  -  A user
 *  -  A tag
 */
declare class OutboxItem {
    /**
     * Type of item
     */
    type: OutboxItemType;
    /**
     * The relay URLs that are of interest to this item
     */
    relayUrlScores: Map<WebSocket["url"], number>;
    readRelays: Set<WebSocket["url"]>;
    writeRelays: Set<WebSocket["url"]>;
    constructor(type: OutboxItemType);
}
/**
 * The responsibility of this class is to track relay:outbox-item associations
 * so that we can intelligently choose which relays to query for which items.
 *
 * A single instance of this class should be shared across all subscriptions within
 * an NDK instance.
 *
 * TODO: The state of this tracker needs to be added to cache adapters so that we
 * can rehydrate-it when a cache is present.
 */
declare class OutboxTracker extends EventEmitter {
    data: LRUCache<Hexpubkey, OutboxItem>;
    private ndk;
    private debug;
    constructor(ndk: NDK);
    /**
     * Adds a list of users to the tracker.
     * @param items
     * @param skipCache
     */
    trackUsers(items: NDKUser[] | Hexpubkey[], skipCache?: boolean): Promise<void[]>;
    /**
     *
     * @param key
     * @param score
     */
    track(item: NDKUser | Hexpubkey, type?: OutboxItemType, skipCache?: boolean): OutboxItem;
}

type PrepareUploadResult = {
    url: string;
    headers: {
        [key: string]: string;
    };
};
/**
 * Provides utility methods for interacting with NIP-96 upload services
 */
declare class Nip96 {
    private ndk;
    spec: Nip96Spec | undefined;
    private url;
    nip98Required: boolean;
    /**
     * @param domain domain of the NIP96 service
     */
    constructor(domain: string, ndk: NDK);
    prepareUpload(blob: Blob, httpVerb?: string): Promise<PrepareUploadResult>;
    /**
     * Provides an XMLHttpRequest-based upload method for browsers.
     * @example
     * const xhr = new XMLHttpRequest();
     * xhr.upload.addEventListener("progress", function(e) {
     *    const percentComplete = e.loaded / e.total;
     *    console.log(percentComplete);
     * });
     * const nip96 = ndk.getNip96("nostrcheck.me");
     * const blob = new Blob(["Hello, world!"], { type: "text/plain" });
     * const response = await nip96.xhrUpload(xhr, blob);
     * console.log(response);
     * @returns Promise that resolves to the upload response
     */
    xhrUpload(xhr: XMLHttpRequest, blob: Blob): Promise<Nip96UploadResponse>;
    /**
     * Fetch-based upload method. Note that this will use NDK's httpFetch
     * @param blob
     * @returns Promise that resolves to the upload response
     *
     * @example
     * const nip96 = ndk.getNip96("nostrcheck.me");
     * const blob = new Blob(["Hello, world!"], { type: "text/plain" });
     * const response = await nip96.upload(blob);
     * console.log(response);
     */
    upload(blob: Blob): Promise<Nip96UploadResponse>;
    private validateHttpFetch;
    fetchSpec(): Promise<void>;
    generateNip98Header(requestUrl: string, httpMethod: string, blob: Blob): Promise<string>;
    private calculateSha256;
}
type Nip96Spec = {
    api_url: string;
    download_url?: string;
    delegated_to_url?: string;
    supported_nips?: number[];
    tos_url?: string;
    content_types?: string[];
    plans: {
        [key: string]: {
            name: string;
            is_nip98_required: boolean;
            url?: string;
            max_byte_size?: number;
            file_expiration?: [number, number];
            media_transformations?: {
                image?: string[];
            };
        };
    };
};
type Nip96UploadResponse = {
    status: "success" | "error";
    message: string;
    processing_url?: string;
    nip94_event?: {
        tags: NDKTag[];
        content: string;
    };
};

type QueueItem<T> = {
    /**
     * Deterministic id of the item
     */
    id: string;
    /**
     * A function to process the item
     * @returns
     */
    func: () => Promise<T>;
};
declare class Queue<T> {
    private queue;
    private maxConcurrency;
    private processing;
    private promises;
    constructor(name: string, maxConcurrency: number);
    add(item: QueueItem<T>): Promise<T>;
    private process;
    clear(): void;
    clearProcessing(): void;
    clearAll(): void;
    length(): number;
}

type NDKValidationRatioFn = (relay: NDKRelay, validatedCount: number, nonValidatedCount: number) => number;
type NDKNetDebug = (msg: string, relay: NDKRelay, direction?: "send" | "recv") => void;
/**
 * An interface compatible with ndk-wallet that allows setting multiple handlers and callbacks.
 */
interface NDKWalletInterface {
    lnPay?: LnPayCb;
    cashuPay?: CashuPayCb;
    onPaymentComplete?: (results: Map<NDKZapSplit, NDKPaymentConfirmation | Error | undefined>) => void;
}
interface NDKConstructorParams {
    /**
     * Relays we should explicitly connect to
     */
    explicitRelayUrls?: string[];
    /**
     * Relays we should never connect to
     */
    blacklistRelayUrls?: string[];
    /**
     * When this is set, we always write only to this relays.
     */
    devWriteRelayUrls?: string[];
    /**
     * Outbox relay URLs.
     */
    outboxRelayUrls?: string[];
    /**
     * Enable outbox model (defaults to false)
     */
    enableOutboxModel?: boolean;
    /**
     * Auto-connect to main user's relays. The "main" user is determined
     * by the presence of a signer. Upon connection to the explicit relays,
     * the user's relays will be fetched and connected to if this is set to true.
     * @default true
     */
    autoConnectUserRelays?: boolean;
    /**
     * Automatically fetch user's mutelist
     * @default true
     */
    autoFetchUserMutelist?: boolean;
    /**
     * Signer to use for signing events by default
     */
    signer?: NDKSigner;
    /**
     * Cache adapter to use for caching events
     */
    cacheAdapter?: NDKCacheAdapter;
    /**
     * Debug instance to use
     */
    debug?: debug$1.Debugger;
    /**
     * Provide a caller function to receive all networking traffic from relays
     */
    netDebug?: NDKNetDebug;
    /**
     * Muted pubkeys and eventIds
     */
    mutedIds?: Map<Hexpubkey | NDKEventId, string>;
    /**
     * Client name to add to events' tag
     */
    clientName?: string;
    /**
     * Client nip89 to add to events' tag
     */
    clientNip89?: string;
    /**
     * Default relay-auth policy
     */
    relayAuthDefaultPolicy?: NDKAuthPolicy;
    /**
     * Whether to verify signatures on events synchronously or asynchronously.
     *
     * @default undefined
     *
     * When set to true, the signature verification will processed in a web worker.
     * You should listen for the `event:invalid-sig` event to handle invalid signatures.
     *
     * @example
     * ```typescript
     * const worker = new Worker("path/to/signature-verification.js");
     * ndk.delayedSigVerification = worker;
     * ndk.on("event:invalid-sig", (event) => {
     *    console.error("Invalid signature", event);
     * });
     */
    signatureVerificationWorker?: Worker | undefined;
    /**
     * The signature verification validation ratio for new relays.
     */
    initialValidationRatio?: number;
    /**
     * The lowest validation ratio any single relay can have.
     * Relays will have a sample of events verified based on this ratio.
     * When using this, you MUST listen for event:invalid-sig events
     * to handle invalid signatures and disconnect from evil relays.
     *
     * @default 0.1
     */
    lowestValidationRatio?: number;
    /**
     * A function that is invoked to calculate the validation ratio for a relay.
     */
    validationRatioFn?: NDKValidationRatioFn;
}
interface GetUserParams extends NDKUserParams {
    npub?: string;
    pubkey?: string;
    /**
     * @deprecated Use `pubkey` instead
     */
    hexpubkey?: string;
}
interface NDKSubscriptionEventHandlers {
    onEvent?: (event: NDKEvent, relay?: NDKRelay) => void;
    /**
     * Called with the events that synchronously loaded from the cache.
     */
    onEvents?: (events: NDKEvent[]) => void;
    onEose?: (sub: NDKSubscription) => void;
}
/**
 * The NDK class is the main entry point to the library.
 *
 * @emits signer:ready when a signer is ready
 * @emits invalid-signature when an event with an invalid signature is received
 */
declare class NDK extends EventEmitter<{
    "signer:ready": (signer: NDKSigner) => void;
    "signer:required": () => void;
    /**
     * Emitted when an event with an invalid signature is received and the signature
     * was processed asynchronously.
     */
    "event:invalid-sig": (event: NDKEvent) => void;
    /**
     * Emitted when an event fails to publish.
     * @param event The event that failed to publish
     * @param error The error that caused the event to fail to publish
     * @param relays The relays that the event was attempted to be published to
     */
    "event:publish-failed": (event: NDKEvent, error: NDKPublishError, relays: WebSocket["url"][]) => void;
}> {
    private _explicitRelayUrls?;
    blacklistRelayUrls?: WebSocket["url"][];
    pool: NDKPool;
    outboxPool?: NDKPool;
    private _signer?;
    private _activeUser?;
    cacheAdapter?: NDKCacheAdapter;
    debug: debug$1.Debugger;
    devWriteRelaySet?: NDKRelaySet;
    outboxTracker?: OutboxTracker;
    mutedIds: Map<Hexpubkey | NDKEventId, string>;
    clientName?: string;
    clientNip89?: string;
    queuesZapConfig: Queue<NDKLnUrlData | undefined>;
    queuesNip05: Queue<ProfilePointer | null>;
    asyncSigVerification: boolean;
    initialValidationRatio: number;
    lowestValidationRatio: number;
    validationRatioFn?: NDKValidationRatioFn;
    subManager: NDKSubscriptionManager;
    publishingFailureHandled: boolean;
    pools: NDKPool[];
    /**
     * Default relay-auth policy that will be used when a relay requests authentication,
     * if no other policy is specified for that relay.
     *
     * @example Disconnect from relays that request authentication:
     * ```typescript
     * ndk.relayAuthDefaultPolicy = NDKAuthPolicies.disconnect(ndk.pool);
     * ```
     *
     * @example Sign in to relays that request authentication:
     * ```typescript
     * ndk.relayAuthDefaultPolicy = NDKAuthPolicies.signIn({ndk})
     * ```
     *
     * @example Sign in to relays that request authentication, asking the user for confirmation:
     * ```typescript
     * ndk.relayAuthDefaultPolicy = (relay: NDKRelay) => {
     *     const signIn = NDKAuthPolicies.signIn({ndk});
     *     if (confirm(`Relay ${relay.url} is requesting authentication, do you want to sign in?`)) {
     *        signIn(relay);
     *     }
     * }
     * ```
     */
    relayAuthDefaultPolicy?: NDKAuthPolicy;
    /**
     * Fetch function to use for HTTP requests.
     *
     * @example
     * ```typescript
     * import fetch from "node-fetch";
     *
     * ndk.httpFetch = fetch;
     * ```
     */
    httpFetch: typeof fetch | undefined;
    /**
     * Provide a caller function to receive all networking traffic from relays
     */
    readonly netDebug?: NDKNetDebug;
    autoConnectUserRelays: boolean;
    autoFetchUserMutelist: boolean;
    walletConfig?: NDKWalletInterface;
    constructor(opts?: NDKConstructorParams);
    set explicitRelayUrls(urls: WebSocket["url"][]);
    get explicitRelayUrls(): WebSocket["url"][];
    set signatureVerificationWorker(worker: Worker | undefined);
    /**
     * Adds an explicit relay to the pool.
     * @param url
     * @param relayAuthPolicy Authentication policy to use if different from the default
     * @param connect Whether to connect to the relay automatically
     * @returns
     */
    addExplicitRelay(urlOrRelay: string | NDKRelay, relayAuthPolicy?: NDKAuthPolicy, connect?: boolean): NDKRelay;
    toJSON(): string;
    get activeUser(): NDKUser | undefined;
    /**
     * Sets the active user for this NDK instance, typically this will be
     * called when assigning a signer to the NDK instance.
     *
     * This function will automatically connect to the user's relays if
     * `autoConnectUserRelays` is set to true.
     *
     * It will also fetch the user's mutelist if `autoFetchUserMutelist` is set to true.
     */
    set activeUser(user: NDKUser | undefined);
    get signer(): NDKSigner | undefined;
    set signer(newSigner: NDKSigner | undefined);
    /**
     * Connect to relays with optional timeout.
     * If the timeout is reached, the connection will be continued to be established in the background.
     */
    connect(timeoutMs?: number): Promise<void>;
    /**
     * Get a NDKUser object
     *
     * @param opts
     * @returns
     */
    getUser(opts: GetUserParams): NDKUser;
    /**
     * Get a NDKUser from a NIP05
     * @param nip05 NIP-05 ID
     * @param skipCache Skip cache
     * @returns
     */
    getUserFromNip05(nip05: string, skipCache?: boolean): Promise<NDKUser | undefined>;
    /**
     * Create a new subscription. Subscriptions automatically start, you can make them automatically close when all relays send back an EOSE by setting `opts.closeOnEose` to `true`)
     *
     * @param filters
     * @param opts
     * @param relaySet explicit relay set to use
     * @param autoStart automatically start the subscription -- this can be a boolean or an object with `onEvent` and `onEose` handlers
     * @returns NDKSubscription
     */
    subscribe(filters: NDKFilter | NDKFilter[], opts?: NDKSubscriptionOptions, relaySet?: NDKRelaySet, autoStart?: boolean | NDKSubscriptionEventHandlers): NDKSubscription;
    /**
     * Publish an event to a relay
     * @param event event to publish
     * @param relaySet explicit relay set to use
     * @param timeoutMs timeout in milliseconds to wait for the event to be published
     * @returns The relays the event was published to
     *
     * @deprecated Use `event.publish()` instead
     */
    publish(event: NDKEvent, relaySet?: NDKRelaySet, timeoutMs?: number): Promise<Set<NDKRelay>>;
    /**
     * Attempts to fetch an event from a tag, following relay hints and
     * other best practices.
     * @param tag Tag to fetch the event from
     * @param originalEvent Event where the tag came from
     * @param subOpts Subscription options to use when fetching the event
     * @param fallback Fallback options to use when the hint relay doesn't respond
     * @returns
     */
    fetchEventFromTag: (tag: NDKTag, originalEvent: NDKEvent, subOpts?: NDKSubscriptionOptions | undefined, fallback?: NDKFetchFallbackOptions | undefined) => Promise<NDKEvent | null>;
    /**
     * Fetch an event from the cache synchronously.
     * @param idOrFilter event id in bech32 format or filter
     * @returns events from the cache or null if the cache is empty
     */
    fetchEventSync(idOrFilter: string | NDKFilter[]): NDKEvent[] | null;
    /**
     * Fetch a single event.
     *
     * @param idOrFilter event id in bech32 format or filter
     * @param opts subscription options
     * @param relaySetOrRelay explicit relay set to use
     */
    fetchEvent(idOrFilter: string | NDKFilter | NDKFilter[], opts?: NDKSubscriptionOptions, relaySetOrRelay?: NDKRelaySet | NDKRelay): Promise<NDKEvent | null>;
    /**
     * Fetch events
     */
    fetchEvents(filters: NDKFilter | NDKFilter[], opts?: NDKSubscriptionOptions, relaySet?: NDKRelaySet): Promise<Set<NDKEvent>>;
    /**
     * Ensures that a signer is available to sign an event.
     */
    assertSigner(): void;
    /**
     * Creates a new Nip96 instance for the given domain.
     * @param domain Domain to use for nip96 uploads
     * @example Upload a file to a NIP-96 enabled domain:
     *
     * ```typescript
     * const blob = new Blob(["Hello, world!"], { type: "text/plain" });
     * const nip96 = ndk.getNip96("nostrcheck.me");
     * await nip96.upload(blob);
     * ```
     */
    getNip96(domain: string): Nip96;
    set wallet(wallet: NDKWalletInterface | undefined);
}

type NDKSubscriptionInternalId = string;
type NDKSubscriptionDelayedType = "at-least" | "at-most";
type NDKFilter<K extends number = NDKKind> = {
    ids?: string[];
    kinds?: K[];
    authors?: string[];
    since?: number;
    until?: number;
    limit?: number;
    search?: string;
    [key: `#${string}`]: string[] | undefined;
};
declare enum NDKSubscriptionCacheUsage {
    ONLY_CACHE = "ONLY_CACHE",
    CACHE_FIRST = "CACHE_FIRST",
    PARALLEL = "PARALLEL",
    ONLY_RELAY = "ONLY_RELAY"
}
interface NDKSubscriptionOptions {
    /**
     * Whether to close the subscription when all relays have reached the end of the event stream.
     * @default false
     */
    closeOnEose?: boolean;
    cacheUsage?: NDKSubscriptionCacheUsage;
    /**
     * Whether to skip caching events coming from this subscription
     **/
    dontSaveToCache?: boolean;
    /**
     * Groupable subscriptions are created with a slight time
     * delayed to allow similar filters to be grouped together.
     */
    groupable?: boolean;
    /**
     * The delay to use when grouping subscriptions, specified in milliseconds.
     * @default 100
     * @example
     * const sub1 = ndk.subscribe({ kinds: [1], authors: ["alice"] }, { groupableDelay: 100 });
     * const sub2 = ndk.subscribe({ kinds: [0], authors: ["alice"] }, { groupableDelay: 1000 });
     * // sub1 and sub2 will be grouped together and executed 100ms after sub1 was created
     */
    groupableDelay?: number;
    /**
     * Specifies how this delay should be interpreted.
     * "at-least" means "wait at least this long before sending the subscription"
     * "at-most" means "wait at most this long before sending the subscription"
     * @default "at-most"
     * @example
     * const sub1 = ndk.subscribe({ kinds: [1], authors: ["alice"] }, { groupableDelay: 100, groupableDelayType: "at-least" });
     * const sub2 = ndk.subscribe({ kinds: [0], authors: ["alice"] }, { groupableDelay: 1000, groupableDelayType: "at-most" });
     * // sub1 and sub2 will be grouped together and executed 1000ms after sub1 was created
     */
    groupableDelayType?: NDKSubscriptionDelayedType;
    /**
     * The subscription ID to use for the subscription.
     */
    subId?: string;
    /**
     * Pool to use
     */
    pool?: NDKPool;
    /**
     * Skip signature verification
     * @default false
     */
    skipVerification?: boolean;
    /**
     * Skip event validation. Event validation, checks whether received
     * kinds conform to what the expected schema of that kind should look like.rtwle
     * @default false
     */
    skipValidation?: boolean;
    /**
     * Skip emitting on events before they are received from a relay. (skip optimistic publish)
     * @default false
     */
    skipOptimisticPublishEvent?: boolean;
    /**
     * Remove filter constraints when querying the cache.
     *
     * This allows setting more aggressive filters that will be removed when hitting the cache.
     *
     * Useful uses of this include removing `since` or `until` constraints or `limit` filters.
     *
     * @example
     * ndk.subscribe({ kinds: [1], since: 1710000000, limit: 10 }, { cacheUnconstrainFilter: ['since', 'limit'] });
     *
     * This will hit relays with the since and limit constraints, while loading from the cache without them.
     */
    cacheUnconstrainFilter?: (keyof NDKFilter)[];
    /**
     * Whether to wrap events in kind-specific classes when possible.
     * @default false
     */
    wrap?: boolean;
}
/**
 * Represents a subscription to an NDK event stream.
 *
 * @emits event
 * Emitted when an event is received by the subscription.
 * * ({NDKEvent} event - The event received by the subscription,
 * * {NDKRelay} relay - The relay that received the event,
 * * {NDKSubscription} subscription - The subscription that received the event.)
 *
 * @emits event:dup
 * Emitted when a duplicate event is received by the subscription.
 * * {NDKEvent} event - The duplicate event received by the subscription.
 * * {NDKRelay} relay - The relay that received the event.
 * * {number} timeSinceFirstSeen - The time elapsed since the first time the event was seen.
 * * {NDKSubscription} subscription - The subscription that received the event.
 *
 * @emits cacheEose - Emitted when the cache adapter has reached the end of the events it had.
 *
 * @emits eose - Emitted when all relays have reached the end of the event stream.
 * * {NDKSubscription} subscription - The subscription that received EOSE.
 *
 * @emits close - Emitted when the subscription is closed.
 * * {NDKSubscription} subscription - The subscription that was closed.
 *
 * @example
 * const sub = ndk.subscribe({ kinds: [1] }); // Get all kind:1s
 * sub.on("event", (event) => console.log(event.content); // Show the content
 * sub.on("eose", () => console.log("All relays have reached the end of the event stream"));
 * sub.on("close", () => console.log("Subscription closed"));
 * setTimeout(() => sub.stop(), 10000); // Stop the subscription after 10 seconds
 *
 * @description
 * Subscriptions are created using {@link NDK.subscribe}.
 *
 * # Event validation
 * By defaults, subscriptions will validate events to comply with the minimal requirement
 * of each known NIP.
 * This can be disabled by setting the `skipValidation` option to `true`.
 *
 * @example
 * const sub = ndk.subscribe({ kinds: [1] }, { skipValidation: false });
 * sub.on("event", (event) => console.log(event.content); // Only valid events will be received
 */
declare class NDKSubscription extends EventEmitter<{
    cacheEose: () => void;
    eose: (sub: NDKSubscription) => void;
    close: (sub: NDKSubscription) => void;
    /**
     * Emitted when a duplicate event is received by the subscription.
     * @param event - The duplicate event received by the subscription.
     * @param relay - The relay that received the event.
     * @param timeSinceFirstSeen - The time elapsed since the first time the event was seen.
     * @param sub - The subscription that received the event.
     */
    "event:dup": (event: NDKEvent | NostrEvent, relay: NDKRelay | undefined, timeSinceFirstSeen: number, sub: NDKSubscription, fromCache: boolean, optimisticPublish: boolean) => void;
    /**
     * Emitted when an event is received by the subscription.
     * @param event - The event received by the subscription.
     * @param relay - The relay that received the event.
     * @param sub - The subscription that received the event.
     * @param fromCache - Whether the event was received from the cache.
     * @param optimisticPublish - Whether the event was received from an optimistic publish.
     */
    event: (event: NDKEvent, relay: NDKRelay | undefined, sub: NDKSubscription, fromCache: boolean, optimisticPublish: boolean) => void;
    /**
     * Emitted when a relay unilaterally closes the subscription.
     * @param relay
     * @param reason
     * @returns
     */
    closed: (relay: NDKRelay, reason: string) => void;
}> {
    readonly subId?: string;
    readonly filters: NDKFilter[];
    readonly opts: NDKSubscriptionOptions;
    readonly pool: NDKPool;
    readonly skipVerification: boolean;
    readonly skipValidation: boolean;
    /**
     * Tracks the filters as they are executed on each relay
     */
    relayFilters?: Map<WebSocket["url"], NDKFilter[]>;
    relaySet?: NDKRelaySet;
    ndk: NDK;
    debug: debug.Debugger;
    /**
     * Events that have been seen by the subscription, with the time they were first seen.
     */
    eventFirstSeen: Map<string, number>;
    /**
     * Relays that have sent an EOSE.
     */
    eosesSeen: Set<NDKRelay>;
    /**
     * The time the last event was received by the subscription.
     * This is used to calculate when EOSE should be emitted.
     */
    private lastEventReceivedAt;
    internalId: NDKSubscriptionInternalId;
    /**
     * Whether the subscription should close when all relays have reached the end of the event stream.
     */
    closeOnEose: boolean;
    /**
     * Pool monitor callback
     */
    private poolMonitor;
    skipOptimisticPublishEvent: boolean;
    /**
     * Filters to remove when querying the cache.
     */
    cacheUnconstrainFilter?: Array<(keyof NDKFilter)>;
    constructor(ndk: NDK, filters: NDKFilter | NDKFilter[], opts?: NDKSubscriptionOptions, relaySet?: NDKRelaySet, subId?: string);
    /**
     * Returns the relays that have not yet sent an EOSE.
     */
    relaysMissingEose(): WebSocket["url"][];
    /**
     * Provides access to the first filter of the subscription for
     * backwards compatibility.
     */
    get filter(): NDKFilter;
    get groupableDelay(): number | undefined;
    get groupableDelayType(): NDKSubscriptionDelayedType;
    isGroupable(): boolean;
    private shouldQueryCache;
    private shouldQueryRelays;
    private shouldWaitForCache;
    /**
     * Start the subscription. This is the main method that should be called
     * after creating a subscription.
     *
     * @param emitCachedEvents - Whether to emit events coming from a synchronous cache
     *
     * When using a synchronous cache, the events will be returned immediately
     * by this function. If you will use those returned events, you should
     * set emitCachedEvents to false to prevent seeing them as duplicate events.
     */
    start(emitCachedEvents?: boolean): NDKEvent[] | null;
    /**
     * We want to monitor for new relays that are coming online, in case
     * they should be part of this subscription.
     */
    private startPoolMonitor;
    onStopped?: () => void;
    stop(): void;
    /**
     * @returns Whether the subscription has an authors filter.
     */
    hasAuthorsFilter(): boolean;
    private startWithCache;
    /**
     * Send REQ to relays
     */
    private startWithRelays;
    /**
     * Called when an event is received from a relay or the cache
     * @param event
     * @param relay
     * @param fromCache Whether the event was received from the cache
     * @param optimisticPublish Whether this event is coming from an optimistic publish
     */
    eventReceived(event: NDKEvent | NostrEvent, relay: NDKRelay | undefined, fromCache?: boolean, optimisticPublish?: boolean): void;
    /**
     * Optionally wraps, sync or async, and emits the event (if one comes back from the wrapper)
     */
    private emitEvent;
    closedReceived(relay: NDKRelay, reason: string): void;
    private eoseTimeout;
    private eosed;
    eoseReceived(relay: NDKRelay): void;
}

/**
 * NIP-73 entity types
 */
type NIP73EntityType = "url" | "hashtag" | "geohash" | "isbn" | "podcast:guid" | "podcast:item:guid" | "podcast:publisher:guid" | "isan" | "doi";

type NDKEventId = string;
type NDKTag = string[];
type NostrEvent = {
    created_at: number;
    content: string;
    tags: NDKTag[];
    kind?: NDKKind | number;
    pubkey: string;
    id?: string;
    sig?: string;
};
/**
 * NDKEvent is the basic building block of NDK; most things
 * you do with NDK will revolve around writing or consuming NDKEvents.
 */
declare class NDKEvent extends EventEmitter {
    ndk?: NDK;
    created_at?: number;
    content: string;
    tags: NDKTag[];
    kind?: NDKKind | number;
    id: string;
    sig?: string;
    pubkey: string;
    signatureVerified?: boolean;
    private _author;
    /**
     * The relay that this event was first received from.
     */
    relay: NDKRelay | undefined;
    /**
     * The relays that this event was received from and/or successfully published to.
     */
    get onRelays(): NDKRelay[];
    /**
     * The status of the publish operation.
     */
    publishStatus?: "pending" | "success" | "error";
    publishError?: Error;
    constructor(ndk?: NDK, event?: NostrEvent | NDKEvent);
    /**
     * Deserialize an NDKEvent from a serialized payload.
     * @param ndk
     * @param event
     * @returns
     */
    static deserialize(ndk: NDK | undefined, event: NDKEventSerialized): NDKEvent;
    /**
     * Returns the event as is.
     */
    rawEvent(): NostrEvent;
    set author(user: NDKUser);
    /**
     * Returns an NDKUser for the author of the event.
     */
    get author(): NDKUser;
    /**
     * NIP-73 tagging of external entities
     * @param entity to be tagged
     * @param type of the entity
     * @param markerUrl to be used as the marker URL
     *
     * @example
     * ```typescript
     * event.tagExternal("https://example.com/article/123#nostr", "url");
     * event.tags => [["i", "https://example.com/123"], ["k", "https://example.com"]]
     * ```
     *
     * @example tag a podcast:item:guid
     * ```typescript
     * event.tagExternal("e32b4890-b9ea-4aef-a0bf-54b787833dc5", "podcast:item:guid");
     * event.tags => [["i", "podcast:item:guid:e32b4890-b9ea-4aef-a0bf-54b787833dc5"], ["k", "podcast:item:guid"]]
     * ```
     *
     * @see https://github.com/nostr-protocol/nips/blob/master/73.md
     */
    tagExternal(entity: string, type: NIP73EntityType, markerUrl?: string): void;
    /**
     * Tag a user with an optional marker.
     * @param target What is to be tagged. Can be an NDKUser, NDKEvent, or an NDKTag.
     * @param marker The marker to use in the tag.
     * @param skipAuthorTag Whether to explicitly skip adding the author tag of the event.
     * @param forceTag Force a specific tag to be used instead of the default "e" or "a" tag.
     * @example
     * ```typescript
     * reply.tag(opEvent, "reply");
     * // reply.tags => [["e", <id>, <relay>, "reply"]]
     * ```
     */
    tag(target: NDKTag | NDKUser | NDKEvent, marker?: string, skipAuthorTag?: boolean, forceTag?: string): void;
    /**
     * Return a NostrEvent object, trying to fill in missing fields
     * when possible, adding tags when necessary.
     * @param pubkey {string} The pubkey of the user who the event belongs to.
     * @returns {Promise<NostrEvent>} A promise that resolves to a NostrEvent.
     */
    toNostrEvent(pubkey?: string): Promise<NostrEvent>;
    serialize: (includeSig?: boolean | undefined, includeId?: boolean | undefined) => string;
    getEventHash: () => string;
    validate: () => boolean;
    verifySignature: (persist: boolean) => boolean | undefined;
    /**
     * Is this event replaceable (whether parameterized or not)?
     *
     * This will return true for kind 0, 3, 10k-20k and 30k-40k
     */
    isReplaceable: () => boolean;
    isEphemeral: () => boolean;
    isDvm: () => boolean | 0 | undefined;
    /**
     * Is this event parameterized replaceable?
     *
     * This will return true for kind 30k-40k
     */
    isParamReplaceable: () => boolean;
    /**
     * Encodes a bech32 id.
     *
     * @param relays {string[]} The relays to encode in the id
     * @returns {string} - Encoded naddr, note or nevent.
     */
    encode: (maxRelayCount?: number | undefined) => string;
    encrypt: (recipient?: NDKUser | undefined, signer?: NDKSigner | undefined, scheme?: NDKEncryptionScheme | undefined) => Promise<void>;
    decrypt: (sender?: NDKUser | undefined, signer?: NDKSigner | undefined, scheme?: NDKEncryptionScheme | undefined) => Promise<void>;
    /**
     * Get all tags with the given name
     * @param tagName {string} The name of the tag to search for
     * @returns {NDKTag[]} An array of the matching tags
     */
    getMatchingTags(tagName: string, marker?: string): NDKTag[];
    /**
     * Check if the event has a tag with the given name
     * @param tagName
     * @param marker
     * @returns
     */
    hasTag(tagName: string, marker?: string): boolean;
    /**
     * Get the first tag with the given name
     * @param tagName Tag name to search for
     * @returns The value of the first tag with the given name, or undefined if no such tag exists
     */
    tagValue(tagName: string): string | undefined;
    /**
     * Gets the NIP-31 "alt" tag of the event.
     */
    get alt(): string | undefined;
    /**
     * Sets the NIP-31 "alt" tag of the event. Use this to set an alt tag so
     * clients that don't handle a particular event kind can display something
     * useful for users.
     */
    set alt(alt: string | undefined);
    /**
     * Gets the NIP-33 "d" tag of the event.
     */
    get dTag(): string | undefined;
    /**
     * Sets the NIP-33 "d" tag of the event.
     */
    set dTag(value: string | undefined);
    /**
     * Remove all tags with the given name (e.g. "d", "a", "p")
     * @param tagName Tag name(s) to search for and remove
     * @returns {void}
     */
    removeTag(tagName: string | string[]): void;
    /**
     * Sign the event if a signer is present.
     *
     * It will generate tags.
     * Repleacable events will have their created_at field set to the current time.
     * @param signer {NDKSigner} The NDKSigner to use to sign the event
     * @returns {Promise<string>} A Promise that resolves to the signature of the signed event.
     */
    sign(signer?: NDKSigner): Promise<string>;
    /**
     *
     * @param relaySet
     * @param timeoutMs
     * @param requiredRelayCount
     * @returns
     */
    publishReplaceable(relaySet?: NDKRelaySet, timeoutMs?: number, requiredRelayCount?: number): Promise<Set<NDKRelay>>;
    /**
     * Attempt to sign and then publish an NDKEvent to a given relaySet.
     * If no relaySet is provided, the relaySet will be calculated by NDK.
     * @param relaySet {NDKRelaySet} The relaySet to publish the even to.
     * @param timeoutM {number} The timeout for the publish operation in milliseconds.
     * @param requiredRelayCount The number of relays that must receive the event for the publish to be considered successful.
     * @returns A promise that resolves to the relays the event was published to.
     */
    publish(relaySet?: NDKRelaySet, timeoutMs?: number, requiredRelayCount?: number): Promise<Set<NDKRelay>>;
    /**
     * Generates tags for users, notes, and other events tagged in content.
     * Will also generate random "d" tag for parameterized replaceable events where needed.
     * @returns {ContentTag} The tags and content of the event.
     */
    generateTags(): Promise<ContentTag>;
    get shouldAddClientTag(): boolean;
    get shouldStripClientTag(): boolean;
    muted(): string | null;
    /**
     * Returns the "d" tag of a parameterized replaceable event or throws an error if the event isn't
     * a parameterized replaceable event.
     * @returns {string} the "d" tag of the event.
     *
     * @deprecated Use `dTag` instead.
     */
    replaceableDTag(): string;
    /**
     * Provides a deduplication key for the event.
     *
     * For kinds 0, 3, 10k-20k this will be the event <kind>:<pubkey>
     * For kinds 30k-40k this will be the event <kind>:<pubkey>:<d-tag>
     * For all other kinds this will be the event id
     */
    deduplicationKey(): string;
    /**
     * Returns the id of the event or, if it's a parameterized event, the generated id of the event using "d" tag, pubkey, and kind.
     * @returns {string} The id
     */
    tagId(): string;
    /**
     * Returns a stable reference value for a replaceable event.
     *
     * Param replaceable events are returned in the expected format of `<kind>:<pubkey>:<d-tag>`.
     * Kind-replaceable events are returned in the format of `<kind>:<pubkey>:`.
     *
     * @returns {string} A stable reference value for replaceable events
     */
    tagAddress(): string;
    /**
     * Determines the type of tag that can be used to reference this event from another event.
     * @returns {string} The tag type
     * @example
     * event = new NDKEvent(ndk, { kind: 30000, pubkey: 'pubkey', tags: [ ["d", "d-code"] ] });
     * event.tagType(); // "a"
     */
    tagType(): "e" | "a";
    /**
     * Get the tag that can be used to reference this event from another event.
     *
     * Consider using referenceTags() instead (unless you have a good reason to use this)
     *
     * @example
     *     event = new NDKEvent(ndk, { kind: 30000, pubkey: 'pubkey', tags: [ ["d", "d-code"] ] });
     *     event.tagReference(); // ["a", "30000:pubkey:d-code"]
     *
     *     event = new NDKEvent(ndk, { kind: 1, pubkey: 'pubkey', id: "eventid" });
     *     event.tagReference(); // ["e", "eventid"]
     * @returns {NDKTag} The NDKTag object referencing this event
     */
    tagReference(marker?: string): NDKTag;
    /**
     * Get the tags that can be used to reference this event from another event
     * @param marker The marker to use in the tag
     * @param skipAuthorTag Whether to explicitly skip adding the author tag of the event
     * @param forceTag Force a specific tag to be used instead of the default "e" or "a" tag
     * @example
     *     event = new NDKEvent(ndk, { kind: 30000, pubkey: 'pubkey', tags: [ ["d", "d-code"] ] });
     *     event.referenceTags(); // [["a", "30000:pubkey:d-code"], ["e", "parent-id"]]
     *
     *     event = new NDKEvent(ndk, { kind: 1, pubkey: 'pubkey', id: "eventid" });
     *     event.referenceTags(); // [["e", "parent-id"]]
     * @returns {NDKTag} The NDKTag object referencing this event
     */
    referenceTags(marker?: string, skipAuthorTag?: boolean, forceTag?: string): NDKTag[];
    /**
     * Provides the filter that will return matching events for this event.
     *
     * @example
     *    event = new NDKEvent(ndk, { kind: 30000, pubkey: 'pubkey', tags: [ ["d", "d-code"] ] });
     *    event.filter(); // { "#a": ["30000:pubkey:d-code"] }
     * @example
     *    event = new NDKEvent(ndk, { kind: 1, pubkey: 'pubkey', id: "eventid" });
     *    event.filter(); // { "#e": ["eventid"] }
     *
     * @returns The filter that will return matching events for this event
     */
    filter(): NDKFilter;
    nip22Filter(): NDKFilter;
    /**
     * Generates a deletion event of the current event
     *
     * @param reason The reason for the deletion
     * @param publish Whether to publish the deletion event automatically
     * @returns The deletion event
     */
    delete(reason?: string, publish?: boolean): Promise<NDKEvent>;
    /**
     * Establishes whether this is a NIP-70-protectede event.
     * @@satisfies NIP-70
     */
    set isProtected(val: boolean);
    /**
     * Whether this is a NIP-70-protectede event.
     * @@satisfies NIP-70
     */
    get isProtected(): boolean;
    /**
     * Fetch an event tagged with the given tag following relay hints if provided.
     * @param tag The tag to search for
     * @param marker The marker to use in the tag (e.g. "root")
     * @returns The fetched event or null if no event was found, undefined if no matching tag was found in the event
     * * @example
     * const replyEvent = await ndk.fetchEvent("nevent1qqs8x8vnycyha73grv380gmvlury4wtmx0nr9a5ds2dngqwgu87wn6gpzemhxue69uhhyetvv9ujuurjd9kkzmpwdejhgq3ql2vyh47mk2p0qlsku7hg0vn29faehy9hy34ygaclpn66ukqp3afqz4cwjd")
     * const originalEvent = await replyEvent.fetchTaggedEvent("e", "reply");
     * console.log(replyEvent.encode() + " is a reply to event " + originalEvent?.encode());
     */
    fetchTaggedEvent: (tag: string, marker?: string | undefined) => Promise<NDKEvent | null | undefined>;
    /**
     * Fetch the root event of the current event.
     * @returns The fetched root event or null if no event was found
     * @example
     * const replyEvent = await ndk.fetchEvent("nevent1qqs8x8vnycyha73grv380gmvlury4wtmx0nr9a5ds2dngqwgu87wn6gpzemhxue69uhhyetvv9ujuurjd9kkzmpwdejhgq3ql2vyh47mk2p0qlsku7hg0vn29faehy9hy34ygaclpn66ukqp3afqz4cwjd")
     * const rootEvent = await replyEvent.fetchRootEvent();
     * console.log(replyEvent.encode() + " is a reply in the thread " + rootEvent?.encode());
     */
    fetchRootEvent: (subOpts?: NDKSubscriptionOptions | undefined) => Promise<NDKEvent | null | undefined>;
    /**
     * Fetch the event the current event is replying to.
     * @returns The fetched reply event or null if no event was found
     */
    fetchReplyEvent: (subOpts?: NDKSubscriptionOptions | undefined) => Promise<NDKEvent | null | undefined>;
    /**
     * NIP-18 reposting event.
     *
     * @param publish Whether to publish the reposted event automatically @default true
     * @param signer The signer to use for signing the reposted event
     * @returns The reposted event
     *
     * @function
     */
    repost: (publish?: boolean | undefined, signer?: NDKSigner | undefined) => Promise<NDKEvent>;
    /**
     * React to an existing event
     *
     * @param content The content of the reaction
     */
    react(content: string, publish?: boolean): Promise<NDKEvent>;
    /**
     * Checks whether the event is valid per underlying NIPs.
     *
     * This method is meant to be overridden by subclasses that implement specific NIPs
     * to allow the enforcement of NIP-specific validation rules.
     *
     * Otherwise, it will only check for basic event properties.
     *
     */
    get isValid(): boolean;
    /**
     * Creates a reply event for the current event.
     *
     * This function will use NIP-22 when appropriate (i.e. replies to non-kind:1 events).
     * This function does not have side-effects; it will just return an event with the appropriate tags
     * to generate the reply event; the caller is responsible for publishing the event.
     */
    reply(): NDKEvent;
}

declare class NDKPrivateKeySigner implements NDKSigner {
    private _user;
    _privateKey?: Uint8Array;
    constructor(privateKey?: Uint8Array | string);
    get privateKey(): string | undefined;
    static generate(): NDKPrivateKeySigner;
    blockUntilReady(): Promise<NDKUser>;
    user(): Promise<NDKUser>;
    sign(event: NostrEvent): Promise<string>;
    encryptionEnabled(scheme?: NDKEncryptionScheme): Promise<NDKEncryptionScheme[]>;
    encrypt(recipient: NDKUser, value: string, scheme?: NDKEncryptionScheme): Promise<string>;
    decrypt(sender: NDKUser, value: string, scheme?: NDKEncryptionScheme): Promise<string>;
}

type Proof = {
    id: string;
    amount: number;
    secret: string;
    C: string;
};
/**
 * Creates a nutzap for a given amount, optionally locking to a p2pk.
 * @param mint
 * @param amount
 * @param ndk
 * @param opts
 * @param opts.senderPk - The private key of the sender
 * @param opts.recipientPubkey - The nostr pubkey of the recipient
 * @param opts.content - The content of the nutzap
 */
declare function mockNutzap(mint: string, amount: number, ndk: any, { senderPk, recipientPubkey, content }?: {
    senderPk?: NDKPrivateKeySigner;
    recipientPubkey?: string;
    content?: string;
}): Promise<NDKNutzap>;
/**
 * Creates a proof for a given amount, optionally locking to a p2pk.
 * @param C
 * @param amount
 * @param p2pk
 * @returns
 */
declare function mockProof(C: string, amount: number, p2pk?: string): Proof;

export { type Proof, mockNutzap, mockProof };
