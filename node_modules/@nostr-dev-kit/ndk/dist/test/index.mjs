// src/signers/private-key/index.ts
import { generateSecretKey, getPublicKey, finalizeEvent, nip04, nip44 } from "nostr-tools";

// src/user/index.ts
import { nip19 as nip195 } from "nostr-tools";

// src/events/index.ts
import { EventEmitter as EventEmitter2 } from "tseep";

// src/outbox/write.ts
function getRelaysForSync(ndk, author, type = "write") {
  if (!ndk.outboxTracker) return void 0;
  const item = ndk.outboxTracker.data.get(author);
  if (!item) return void 0;
  if (type === "write") {
    return item.writeRelays;
  } else {
    return item.readRelays;
  }
}
async function getWriteRelaysFor(ndk, author, type = "write") {
  if (!ndk.outboxTracker) return void 0;
  if (!ndk.outboxTracker.data.has(author)) {
    await ndk.outboxTracker.trackUsers([author]);
  }
  return getRelaysForSync(ndk, author, type);
}

// src/outbox/relay-ranking.ts
function getTopRelaysForAuthors(ndk, authors) {
  const relaysWithCount = /* @__PURE__ */ new Map();
  authors.forEach((author) => {
    const writeRelays = getRelaysForSync(ndk, author);
    if (writeRelays) {
      writeRelays.forEach((relay) => {
        const count = relaysWithCount.get(relay) || 0;
        relaysWithCount.set(relay, count + 1);
      });
    }
  });
  const sortedRelays = Array.from(relaysWithCount.entries()).sort((a, b) => b[1] - a[1]);
  return sortedRelays.map((entry) => entry[0]);
}

// src/outbox/index.ts
function getAllRelaysForAllPubkeys(ndk, pubkeys, type = "read") {
  const pubkeysToRelays = /* @__PURE__ */ new Map();
  const authorsMissingRelays = /* @__PURE__ */ new Set();
  pubkeys.forEach((pubkey) => {
    const relays = getRelaysForSync(ndk, pubkey, type);
    if (relays && relays.size > 0) {
      relays.forEach((relay) => {
        const pubkeysInRelay = pubkeysToRelays.get(relay) || /* @__PURE__ */ new Set();
        pubkeysInRelay.add(pubkey);
      });
      pubkeysToRelays.set(pubkey, relays);
    } else {
      authorsMissingRelays.add(pubkey);
    }
  });
  return { pubkeysToRelays, authorsMissingRelays };
}
function chooseRelayCombinationForPubkeys(ndk, pubkeys, type, { count, preferredRelays } = {}) {
  count ??= 2;
  preferredRelays ??= /* @__PURE__ */ new Set();
  const pool = ndk.pool;
  const connectedRelays = pool.connectedRelays();
  connectedRelays.forEach((relay) => {
    preferredRelays.add(relay.url);
  });
  const relayToAuthorsMap = /* @__PURE__ */ new Map();
  const { pubkeysToRelays, authorsMissingRelays } = getAllRelaysForAllPubkeys(ndk, pubkeys, type);
  const sortedRelays = getTopRelaysForAuthors(ndk, pubkeys);
  const addAuthorToRelay = (author, relay) => {
    const authorsInRelay = relayToAuthorsMap.get(relay) || [];
    authorsInRelay.push(author);
    relayToAuthorsMap.set(relay, authorsInRelay);
  };
  for (const [author, authorRelays] of pubkeysToRelays.entries()) {
    let missingRelayCount = count;
    for (const relay of connectedRelays) {
      if (authorRelays.has(relay.url)) {
        addAuthorToRelay(author, relay.url);
        missingRelayCount--;
      }
    }
    for (const authorRelay of authorRelays) {
      if (relayToAuthorsMap.has(authorRelay)) {
        addAuthorToRelay(author, authorRelay);
        missingRelayCount--;
      }
    }
    if (missingRelayCount <= 0) continue;
    for (const relay of sortedRelays) {
      if (missingRelayCount <= 0) break;
      if (authorRelays.has(relay)) {
        addAuthorToRelay(author, relay);
        missingRelayCount--;
      }
    }
  }
  for (const author of authorsMissingRelays) {
    pool.permanentAndConnectedRelays().forEach((relay) => {
      const authorsInRelay = relayToAuthorsMap.get(relay.url) || [];
      authorsInRelay.push(author);
      relayToAuthorsMap.set(relay.url, authorsInRelay);
    });
  }
  return relayToAuthorsMap;
}

// src/utils/normalize-url.ts
function normalizeRelayUrl(url) {
  let r = normalizeUrl(url, {
    stripAuthentication: false,
    stripWWW: false,
    stripHash: true
  });
  if (!r.endsWith("/")) {
    r += "/";
  }
  return r;
}
var DATA_URL_DEFAULT_MIME_TYPE = "text/plain";
var DATA_URL_DEFAULT_CHARSET = "us-ascii";
var testParameter = (name, filters) => filters.some((filter) => filter instanceof RegExp ? filter.test(name) : filter === name);
var supportedProtocols = /* @__PURE__ */ new Set(["https:", "http:", "file:"]);
var hasCustomProtocol = (urlString) => {
  try {
    const { protocol } = new URL(urlString);
    return protocol.endsWith(":") && !protocol.includes(".") && !supportedProtocols.has(protocol);
  } catch {
    return false;
  }
};
var normalizeDataURL = (urlString, { stripHash }) => {
  const match = /^data:(?<type>[^,]*?),(?<data>[^#]*?)(?:#(?<hash>.*))?$/.exec(urlString);
  if (!match) {
    throw new Error(`Invalid URL: ${urlString}`);
  }
  let type = match.groups?.type ?? "";
  let data = match.groups?.data ?? "";
  let hash = match.groups?.hash ?? "";
  const mediaType = type.split(";");
  hash = stripHash ? "" : hash;
  let isBase64 = false;
  if (mediaType[mediaType.length - 1] === "base64") {
    mediaType.pop();
    isBase64 = true;
  }
  const mimeType = mediaType.shift()?.toLowerCase() ?? "";
  const attributes = mediaType.map((attribute) => {
    let [key, value = ""] = attribute.split("=").map((string) => string.trim());
    if (key === "charset") {
      value = value.toLowerCase();
      if (value === DATA_URL_DEFAULT_CHARSET) {
        return "";
      }
    }
    return `${key}${value ? `=${value}` : ""}`;
  }).filter(Boolean);
  const normalizedMediaType = [...attributes];
  if (isBase64) {
    normalizedMediaType.push("base64");
  }
  if (normalizedMediaType.length > 0 || mimeType && mimeType !== DATA_URL_DEFAULT_MIME_TYPE) {
    normalizedMediaType.unshift(mimeType);
  }
  return `data:${normalizedMediaType.join(";")},${isBase64 ? data.trim() : data}${hash ? `#${hash}` : ""}`;
};
function normalizeUrl(urlString, options = {}) {
  options = {
    defaultProtocol: "http",
    normalizeProtocol: true,
    forceHttp: false,
    forceHttps: false,
    stripAuthentication: true,
    stripHash: false,
    stripTextFragment: true,
    stripWWW: true,
    removeQueryParameters: [/^utm_\w+/i],
    removeTrailingSlash: true,
    removeSingleSlash: true,
    removeDirectoryIndex: false,
    removeExplicitPort: false,
    sortQueryParameters: true,
    ...options
  };
  if (typeof options.defaultProtocol === "string" && !options.defaultProtocol.endsWith(":")) {
    options.defaultProtocol = `${options.defaultProtocol}:`;
  }
  urlString = urlString.trim();
  if (/^data:/i.test(urlString)) {
    return normalizeDataURL(urlString, options);
  }
  if (hasCustomProtocol(urlString)) {
    return urlString;
  }
  const hasRelativeProtocol = urlString.startsWith("//");
  const isRelativeUrl = !hasRelativeProtocol && /^\.*\//.test(urlString);
  if (!isRelativeUrl) {
    urlString = urlString.replace(/^(?!(?:\w+:)?\/\/)|^\/\//, options.defaultProtocol);
  }
  const urlObject = new URL(urlString);
  urlObject.hostname = urlObject.hostname.toLowerCase();
  if (options.forceHttp && options.forceHttps) {
    throw new Error("The `forceHttp` and `forceHttps` options cannot be used together");
  }
  if (options.forceHttp && urlObject.protocol === "https:") {
    urlObject.protocol = "http:";
  }
  if (options.forceHttps && urlObject.protocol === "http:") {
    urlObject.protocol = "https:";
  }
  if (options.stripAuthentication) {
    urlObject.username = "";
    urlObject.password = "";
  }
  if (options.stripHash) {
    urlObject.hash = "";
  } else if (options.stripTextFragment) {
    urlObject.hash = urlObject.hash.replace(/#?:~:text.*?$/i, "");
  }
  if (urlObject.pathname) {
    const protocolRegex = /\b[a-z][a-z\d+\-.]{1,50}:\/\//g;
    let lastIndex = 0;
    let result = "";
    for (; ; ) {
      const match = protocolRegex.exec(urlObject.pathname);
      if (!match) {
        break;
      }
      const protocol = match[0];
      const protocolAtIndex = match.index;
      const intermediate = urlObject.pathname.slice(lastIndex, protocolAtIndex);
      result += intermediate.replace(/\/{2,}/g, "/");
      result += protocol;
      lastIndex = protocolAtIndex + protocol.length;
    }
    const remnant = urlObject.pathname.slice(lastIndex, urlObject.pathname.length);
    result += remnant.replace(/\/{2,}/g, "/");
    urlObject.pathname = result;
  }
  if (urlObject.pathname) {
    try {
      urlObject.pathname = decodeURI(urlObject.pathname);
    } catch {
    }
  }
  if (options.removeDirectoryIndex === true) {
    options.removeDirectoryIndex = [/^index\.[a-z]+$/];
  }
  if (Array.isArray(options.removeDirectoryIndex) && options.removeDirectoryIndex.length > 0) {
    let pathComponents = urlObject.pathname.split("/");
    const lastComponent = pathComponents[pathComponents.length - 1];
    if (testParameter(lastComponent, options.removeDirectoryIndex)) {
      pathComponents = pathComponents.slice(0, -1);
      urlObject.pathname = pathComponents.slice(1).join("/") + "/";
    }
  }
  if (urlObject.hostname) {
    urlObject.hostname = urlObject.hostname.replace(/\.$/, "");
    if (options.stripWWW && /^www\.(?!www\.)[a-z\-\d]{1,63}\.[a-z.\-\d]{2,63}$/.test(urlObject.hostname)) {
      urlObject.hostname = urlObject.hostname.replace(/^www\./, "");
    }
  }
  if (Array.isArray(options.removeQueryParameters)) {
    for (const key of [...urlObject.searchParams.keys()]) {
      if (testParameter(key, options.removeQueryParameters)) {
        urlObject.searchParams.delete(key);
      }
    }
  }
  if (!Array.isArray(options.keepQueryParameters) && options.removeQueryParameters === true) {
    urlObject.search = "";
  }
  if (Array.isArray(options.keepQueryParameters) && options.keepQueryParameters.length > 0) {
    for (const key of [...urlObject.searchParams.keys()]) {
      if (!testParameter(key, options.keepQueryParameters)) {
        urlObject.searchParams.delete(key);
      }
    }
  }
  if (options.sortQueryParameters) {
    urlObject.searchParams.sort();
    try {
      urlObject.search = decodeURIComponent(urlObject.search);
    } catch {
    }
  }
  if (options.removeTrailingSlash) {
    urlObject.pathname = urlObject.pathname.replace(/\/$/, "");
  }
  if (options.removeExplicitPort && urlObject.port) {
    urlObject.port = "";
  }
  const oldUrlString = urlString;
  urlString = urlObject.toString();
  if (!options.removeSingleSlash && urlObject.pathname === "/" && !oldUrlString.endsWith("/") && urlObject.hash === "") {
    urlString = urlString.replace(/\/$/, "");
  }
  if ((options.removeTrailingSlash || urlObject.pathname === "/") && urlObject.hash === "" && options.removeSingleSlash) {
    urlString = urlString.replace(/\/$/, "");
  }
  if (hasRelativeProtocol && !options.normalizeProtocol) {
    urlString = urlString.replace(/^http:\/\//, "//");
  }
  if (options.stripProtocol) {
    urlString = urlString.replace(/^(?:https?:)?\/\//, "");
  }
  return urlString;
}

// src/relay/index.ts
import debug from "debug";
import { EventEmitter } from "tseep";

// src/relay/connectivity.ts
var MAX_RECONNECT_ATTEMPTS = 5;
var FLAPPING_THRESHOLD_MS = 1e3;
var NDKRelayConnectivity = class {
  ndkRelay;
  ws;
  _status;
  timeoutMs;
  connectedAt;
  _connectionStats = {
    attempts: 0,
    success: 0,
    durations: []
  };
  debug;
  netDebug;
  connectTimeout;
  reconnectTimeout;
  ndk;
  openSubs = /* @__PURE__ */ new Map();
  openCountRequests = /* @__PURE__ */ new Map();
  openEventPublishes = /* @__PURE__ */ new Map();
  serial = 0;
  baseEoseTimeout = 4400;
  constructor(ndkRelay, ndk) {
    this.ndkRelay = ndkRelay;
    this._status = 1 /* DISCONNECTED */;
    const rand = Math.floor(Math.random() * 1e3);
    this.debug = this.ndkRelay.debug.extend("connectivity" + rand);
    this.ndk = ndk;
  }
  /**
   * Connects to the NDK relay and handles the connection lifecycle.
   *
   * This method attempts to establish a WebSocket connection to the NDK relay specified in the `ndkRelay` object.
   * If the connection is successful, it updates the connection statistics, sets the connection status to `CONNECTED`,
   * and emits `connect` and `ready` events on the `ndkRelay` object.
   *
   * If the connection attempt fails, it handles the error by either initiating a reconnection attempt or emitting a
   * `delayed-connect` event on the `ndkRelay` object, depending on the `reconnect` parameter.
   *
   * @param timeoutMs - The timeout in milliseconds for the connection attempt. If not provided, the default timeout from the `ndkRelay` object is used.
   * @param reconnect - Indicates whether a reconnection should be attempted if the connection fails. Defaults to `true`.
   * @returns A Promise that resolves when the connection is established, or rejects if the connection fails.
   */
  async connect(timeoutMs, reconnect = true) {
    if (this._status !== 2 /* RECONNECTING */ && this._status !== 1 /* DISCONNECTED */ || this.reconnectTimeout) {
      this.debug(
        "Relay requested to be connected but was in state %s or it had a reconnect timeout",
        this._status
      );
      return;
    }
    if (this.reconnectTimeout) {
      clearTimeout(this.reconnectTimeout);
      this.reconnectTimeout = void 0;
    }
    if (this.connectTimeout) {
      clearTimeout(this.connectTimeout);
      this.connectTimeout = void 0;
    }
    timeoutMs ??= this.timeoutMs;
    if (!this.timeoutMs && timeoutMs) this.timeoutMs = timeoutMs;
    if (this.timeoutMs)
      this.connectTimeout = setTimeout(
        () => this.onConnectionError(reconnect),
        this.timeoutMs
      );
    try {
      this.updateConnectionStats.attempt();
      if (this._status === 1 /* DISCONNECTED */)
        this._status = 4 /* CONNECTING */;
      else this._status = 2 /* RECONNECTING */;
      this.ws = new WebSocket(this.ndkRelay.url);
      this.ws.onopen = this.onConnect.bind(this);
      this.ws.onclose = this.onDisconnect.bind(this);
      this.ws.onmessage = this.onMessage.bind(this);
      this.ws.onerror = this.onError.bind(this);
    } catch (e) {
      this.debug(`Failed to connect to ${this.ndkRelay.url}`, e);
      this._status = 1 /* DISCONNECTED */;
      if (reconnect) this.handleReconnection();
      else this.ndkRelay.emit("delayed-connect", 2 * 24 * 60 * 60 * 1e3);
      throw e;
    }
  }
  /**
   * Disconnects the WebSocket connection to the NDK relay.
   * This method sets the connection status to `NDKRelayStatus.DISCONNECTING`,
   * attempts to close the WebSocket connection, and sets the status to
   * `NDKRelayStatus.DISCONNECTED` if the disconnect operation fails.
   */
  disconnect() {
    this._status = 0 /* DISCONNECTING */;
    try {
      this.ws?.close();
    } catch (e) {
      this.debug("Failed to disconnect", e);
      this._status = 1 /* DISCONNECTED */;
    }
  }
  /**
   * Handles the error that occurred when attempting to connect to the NDK relay.
   * If `reconnect` is `true`, this method will initiate a reconnection attempt.
   * Otherwise, it will emit a `delayed-connect` event on the `ndkRelay` object,
   * indicating that a reconnection should be attempted after a delay.
   *
   * @param reconnect - Indicates whether a reconnection should be attempted.
   */
  onConnectionError(reconnect) {
    this.debug(`Error connecting to ${this.ndkRelay.url}`, this.timeoutMs);
    if (reconnect && !this.reconnectTimeout) {
      this.handleReconnection();
    }
  }
  /**
   * Handles the connection event when the WebSocket connection is established.
   * This method is called when the WebSocket connection is successfully opened.
   * It clears any existing connection and reconnection timeouts, updates the connection statistics,
   * sets the connection status to `CONNECTED`, and emits `connect` and `ready` events on the `ndkRelay` object.
   */
  onConnect() {
    this.netDebug?.("connected", this.ndkRelay);
    if (this.reconnectTimeout) {
      clearTimeout(this.reconnectTimeout);
      this.reconnectTimeout = void 0;
    }
    if (this.connectTimeout) {
      clearTimeout(this.connectTimeout);
      this.connectTimeout = void 0;
    }
    this.updateConnectionStats.connected();
    this._status = 5 /* CONNECTED */;
    this.ndkRelay.emit("connect");
    this.ndkRelay.emit("ready");
  }
  /**
   * Handles the disconnection event when the WebSocket connection is closed.
   * This method is called when the WebSocket connection is successfully closed.
   * It updates the connection statistics, sets the connection status to `DISCONNECTED`,
   * initiates a reconnection attempt if we didn't disconnect ourselves,
   * and emits a `disconnect` event on the `ndkRelay` object.
   */
  onDisconnect() {
    this.netDebug?.("disconnected", this.ndkRelay);
    this.updateConnectionStats.disconnected();
    if (this._status === 5 /* CONNECTED */) {
      this.handleReconnection();
    }
    this._status = 1 /* DISCONNECTED */;
    this.ndkRelay.emit("disconnect");
  }
  /**
   * Handles incoming messages from the NDK relay WebSocket connection.
   * This method is called whenever a message is received from the relay.
   * It parses the message data and dispatches the appropriate handling logic based on the message type.
   *
   * @param event - The MessageEvent containing the received message data.
   */
  onMessage(event) {
    this.netDebug?.(event.data, this.ndkRelay, "recv");
    try {
      const data = JSON.parse(event.data);
      const [cmd, id, ...rest] = data;
      switch (cmd) {
        case "EVENT": {
          const so = this.openSubs.get(id);
          const event2 = data[2];
          if (!so) {
            this.debug(`Received event for unknown subscription ${id}`);
            return;
          }
          so.onevent(event2);
          return;
        }
        case "COUNT": {
          const payload = data[2];
          const cr = this.openCountRequests.get(id);
          if (cr) {
            cr.resolve(payload.count);
            this.openCountRequests.delete(id);
          }
          return;
        }
        case "EOSE": {
          const so = this.openSubs.get(id);
          if (!so) return;
          so.oneose(id);
          return;
        }
        case "OK": {
          const ok = data[2];
          const reason = data[3];
          const ep = this.openEventPublishes.get(id);
          const firstEp = ep?.pop();
          if (!ep || !firstEp) {
            this.debug("Received OK for unknown event publish", id);
            return;
          }
          if (ok) firstEp.resolve(reason);
          else firstEp.reject(new Error(reason));
          if (ep.length === 0) {
            this.openEventPublishes.delete(id);
          } else {
            this.openEventPublishes.set(id, ep);
          }
          return;
        }
        case "CLOSED": {
          const so = this.openSubs.get(id);
          if (!so) return;
          so.onclosed(data[2]);
          return;
        }
        case "NOTICE":
          this.onNotice(data[1]);
          return;
        case "AUTH": {
          this.onAuthRequested(data[1]);
          return;
        }
      }
    } catch (error) {
      this.debug(
        `Error parsing message from ${this.ndkRelay.url}: ${error.message}`,
        error?.stack
      );
      return;
    }
  }
  /**
   * Handles an authentication request from the NDK relay.
   *
   * If an authentication policy is configured, it will be used to authenticate the connection.
   * Otherwise, the `auth` event will be emitted to allow the application to handle the authentication.
   *
   * @param challenge - The authentication challenge provided by the NDK relay.
   */
  async onAuthRequested(challenge) {
    const authPolicy = this.ndkRelay.authPolicy ?? this.ndk?.relayAuthDefaultPolicy;
    this.debug("Relay requested authentication", {
      havePolicy: !!authPolicy
    });
    if (this._status === 7 /* AUTHENTICATING */) {
      this.debug("Already authenticating, ignoring");
      return;
    }
    this._status = 6 /* AUTH_REQUESTED */;
    if (authPolicy) {
      if (this._status >= 5 /* CONNECTED */) {
        this._status = 7 /* AUTHENTICATING */;
        let res;
        try {
          res = await authPolicy(this.ndkRelay, challenge);
        } catch (e) {
          this.debug("Authentication policy threw an error", e);
          res = false;
        }
        this.debug("Authentication policy returned", !!res);
        if (res instanceof NDKEvent || res === true) {
          if (res instanceof NDKEvent) {
            await this.auth(res);
          }
          const authenticate = async () => {
            if (this._status >= 5 /* CONNECTED */ && this._status < 8 /* AUTHENTICATED */) {
              const event = new NDKEvent(this.ndk);
              event.kind = 22242 /* ClientAuth */;
              event.tags = [
                ["relay", this.ndkRelay.url],
                ["challenge", challenge]
              ];
              await event.sign();
              this.auth(event).then(() => {
                this._status = 8 /* AUTHENTICATED */;
                this.ndkRelay.emit("authed");
                this.debug("Authentication successful");
              }).catch((e) => {
                this._status = 6 /* AUTH_REQUESTED */;
                this.ndkRelay.emit("auth:failed", e);
                this.debug("Authentication failed", e);
              });
            } else {
              this.debug(
                "Authentication failed, it changed status, status is %d",
                this._status
              );
            }
          };
          if (res === true) {
            if (!this.ndk?.signer) {
              this.debug("No signer available for authentication localhost");
              this.ndk?.once("signer:ready", authenticate);
            } else {
              authenticate().catch((e) => {
                console.error("Error authenticating", e);
              });
            }
          }
          this._status = 5 /* CONNECTED */;
          this.ndkRelay.emit("authed");
        }
      }
    } else {
      this.ndkRelay.emit("auth", challenge);
    }
  }
  /**
   * Handles errors that occur on the WebSocket connection to the relay.
   * @param error - The error or event that occurred.
   */
  onError(error) {
    this.debug(`WebSocket error on ${this.ndkRelay.url}:`, error);
  }
  /**
   * Gets the current status of the NDK relay connection.
   * @returns {NDKRelayStatus} The current status of the NDK relay connection.
   */
  get status() {
    return this._status;
  }
  /**
   * Checks if the NDK relay connection is currently available.
   * @returns {boolean} `true` if the relay connection is in the `CONNECTED` status, `false` otherwise.
   */
  isAvailable() {
    return this._status === 5 /* CONNECTED */;
  }
  /**
   * Checks if the NDK relay connection is flapping, which means the connection is rapidly
   * disconnecting and reconnecting. This is determined by analyzing the durations of the
   * last three connection attempts. If the standard deviation of the durations is less
   * than 1000 milliseconds, the connection is considered to be flapping.
   *
   * @returns {boolean} `true` if the connection is flapping, `false` otherwise.
   */
  isFlapping() {
    const durations = this._connectionStats.durations;
    if (durations.length % 3 !== 0) return false;
    const sum = durations.reduce((a, b) => a + b, 0);
    const avg = sum / durations.length;
    const variance = durations.map((x) => Math.pow(x - avg, 2)).reduce((a, b) => a + b, 0) / durations.length;
    const stdDev = Math.sqrt(variance);
    const isFlapping = stdDev < FLAPPING_THRESHOLD_MS;
    return isFlapping;
  }
  /**
   * Handles a notice received from the NDK relay.
   * If the notice indicates the relay is complaining (e.g. "too many" or "maximum"),
   * the method disconnects from the relay and attempts to reconnect after a 2-second delay.
   * A debug message is logged with the relay URL and the notice text.
   * The "notice" event is emitted on the ndkRelay instance with the notice text.
   *
   * @param notice - The notice text received from the NDK relay.
   */
  async onNotice(notice) {
    this.ndkRelay.emit("notice", notice);
  }
  /**
   * Attempts to reconnect to the NDK relay after a connection is lost.
   * This function is called recursively to handle multiple reconnection attempts.
   * It checks if the relay is flapping and emits a "flapping" event if so.
   * It then calculates a delay before the next reconnection attempt based on the number of previous attempts.
   * The function sets a timeout to execute the next reconnection attempt after the calculated delay.
   * If the maximum number of reconnection attempts is reached, a debug message is logged.
   *
   * @param attempt - The current attempt number (default is 0).
   */
  handleReconnection(attempt = 0) {
    if (this.reconnectTimeout) return;
    if (this.isFlapping()) {
      this.ndkRelay.emit("flapping", this._connectionStats);
      this._status = 3 /* FLAPPING */;
      return;
    }
    const reconnectDelay = this.connectedAt ? Math.max(0, 6e4 - (Date.now() - this.connectedAt)) : 5e3 * (this._connectionStats.attempts + 1);
    this.reconnectTimeout = setTimeout(() => {
      this.reconnectTimeout = void 0;
      this._status = 2 /* RECONNECTING */;
      this.connect().catch((err) => {
        if (attempt < MAX_RECONNECT_ATTEMPTS) {
          setTimeout(
            () => {
              this.handleReconnection(attempt + 1);
            },
            1e3 * (attempt + 1) ^ 4
          );
        } else {
          this.debug("Reconnect failed");
        }
      });
    }, reconnectDelay);
    this.ndkRelay.emit("delayed-connect", reconnectDelay);
    this.debug("Reconnecting in", reconnectDelay);
    this._connectionStats.nextReconnectAt = Date.now() + reconnectDelay;
  }
  /**
   * Sends a message to the NDK relay if the connection is in the CONNECTED state and the WebSocket is open.
   * If the connection is not in the CONNECTED state or the WebSocket is not open, logs a debug message and throws an error.
   *
   * @param message - The message to send to the NDK relay.
   * @throws {Error} If attempting to send on a closed relay connection.
   */
  async send(message) {
    if (this._status >= 5 /* CONNECTED */ && this.ws?.readyState === WebSocket.OPEN) {
      this.ws?.send(message);
      this.netDebug?.(message, this.ndkRelay, "send");
    } else {
      this.debug(
        `Not connected to ${this.ndkRelay.url} (%d), not sending message ${message}`,
        this._status
      );
    }
  }
  /**
   * Authenticates the NDK event by sending it to the NDK relay and returning a promise that resolves with the result.
   *
   * @param event - The NDK event to authenticate.
   * @returns A promise that resolves with the authentication result.
   */
  async auth(event) {
    const ret = new Promise((resolve, reject) => {
      const val = this.openEventPublishes.get(event.id) ?? [];
      val.push({ resolve, reject });
      this.openEventPublishes.set(event.id, val);
    });
    this.send('["AUTH",' + JSON.stringify(event.rawEvent()) + "]");
    return ret;
  }
  /**
   * Publishes an NDK event to the relay and returns a promise that resolves with the result.
   *
   * @param event - The NDK event to publish.
   * @returns A promise that resolves with the result of the event publication.
   * @throws {Error} If attempting to publish on a closed relay connection.
   */
  async publish(event) {
    const ret = new Promise((resolve, reject) => {
      const val = this.openEventPublishes.get(event.id) ?? [];
      if (val.length > 0) {
        console.warn(
          "Duplicate event publishing detected, you are publishing event " + event.id + " twice"
        );
      }
      val.push({ resolve, reject });
      this.openEventPublishes.set(event.id, val);
    });
    this.send('["EVENT",' + JSON.stringify(event) + "]");
    return ret;
  }
  /**
   * Counts the number of events that match the provided filters.
   *
   * @param filters - The filters to apply to the count request.
   * @param params - An optional object containing a custom id for the count request.
   * @returns A promise that resolves with the number of matching events.
   * @throws {Error} If attempting to send the count request on a closed relay connection.
   */
  async count(filters, params) {
    this.serial++;
    const id = params?.id || "count:" + this.serial;
    const ret = new Promise((resolve, reject) => {
      this.openCountRequests.set(id, { resolve, reject });
    });
    this.send('["COUNT","' + id + '",' + JSON.stringify(filters).substring(1));
    return ret;
  }
  close(subId, reason) {
    this.send('["CLOSE","' + subId + '"]');
    const sub = this.openSubs.get(subId);
    this.openSubs.delete(subId);
    if (sub) sub.onclose(reason);
  }
  /**
   * Subscribes to the NDK relay with the provided filters and parameters.
   *
   * @param filters - The filters to apply to the subscription.
   * @param params - The subscription parameters, including an optional custom id.
   * @returns A new NDKRelaySubscription instance.
   */
  req(relaySub) {
    this.send(
      '["REQ","' + relaySub.subId + '",' + JSON.stringify(relaySub.executeFilters).substring(1)
    ) + "]";
    this.openSubs.set(relaySub.subId, relaySub);
  }
  /**
   * Utility functions to update the connection stats.
   */
  updateConnectionStats = {
    connected: () => {
      this._connectionStats.success++;
      this._connectionStats.connectedAt = Date.now();
    },
    disconnected: () => {
      if (this._connectionStats.connectedAt) {
        this._connectionStats.durations.push(
          Date.now() - this._connectionStats.connectedAt
        );
        if (this._connectionStats.durations.length > 100) {
          this._connectionStats.durations.shift();
        }
      }
      this._connectionStats.connectedAt = void 0;
    },
    attempt: () => {
      this._connectionStats.attempts++;
      this._connectionStats.connectedAt = Date.now();
    }
  };
  /** Returns the connection stats. */
  get connectionStats() {
    return this._connectionStats;
  }
  /** Returns the relay URL */
  get url() {
    return this.ndkRelay.url;
  }
  get connected() {
    return this._status >= 5 /* CONNECTED */ && this.ws?.readyState === WebSocket.OPEN;
  }
};

// src/relay/publisher.ts
var NDKRelayPublisher = class {
  ndkRelay;
  debug;
  constructor(ndkRelay) {
    this.ndkRelay = ndkRelay;
    this.debug = ndkRelay.debug.extend("publisher");
  }
  /**
   * Published an event to the relay; if the relay is not connected, it will
   * wait for the relay to connect before publishing the event.
   *
   * If the relay does not connect within the timeout, the publish operation
   * will fail.
   * @param event  The event to publish
   * @param timeoutMs  The timeout for the publish operation in milliseconds
   * @returns A promise that resolves when the event has been published or rejects if the operation times out
   */
  async publish(event, timeoutMs = 2500) {
    let timeout;
    const publishConnected = () => {
      return new Promise((resolve, reject) => {
        try {
          this.publishEvent(event).then((result) => {
            this.ndkRelay.emit("published", event);
            event.emit("relay:published", this.ndkRelay);
            resolve(true);
          }).catch(reject);
        } catch (err) {
          reject(err);
        }
      });
    };
    const timeoutPromise = new Promise((_, reject) => {
      timeout = setTimeout(() => {
        timeout = void 0;
        reject(new Error("Timeout: " + timeoutMs + "ms"));
      }, timeoutMs);
    });
    const onConnectHandler = () => {
      publishConnected().then((result) => connectResolve(result)).catch((err) => connectReject(err));
    };
    let connectResolve;
    let connectReject;
    const onError = (err) => {
      this.ndkRelay.debug("Publish failed", err, event.id);
      this.ndkRelay.emit("publish:failed", event, err);
      event.emit("relay:publish:failed", this.ndkRelay, err);
      throw err;
    };
    const onFinally = () => {
      if (timeout) clearTimeout(timeout);
      this.ndkRelay.removeListener("connect", onConnectHandler);
    };
    if (this.ndkRelay.status >= 5 /* CONNECTED */) {
      return Promise.race([publishConnected(), timeoutPromise]).catch(onError).finally(onFinally);
    } else {
      if (this.ndkRelay.status <= 1 /* DISCONNECTED */) {
        console.warn(
          "Relay is disconnected, trying to connect to publish an event",
          this.ndkRelay.url
        );
        this.ndkRelay.connect();
      } else {
        console.warn(
          "Relay not connected, waiting for connection to publish an event",
          this.ndkRelay.url
        );
      }
      return Promise.race([
        new Promise((resolve, reject) => {
          connectResolve = resolve;
          connectReject = reject;
          this.ndkRelay.once("connect", onConnectHandler);
        }),
        timeoutPromise
      ]).catch(onError).finally(onFinally);
    }
  }
  async publishEvent(event) {
    return this.ndkRelay.connectivity.publish(event.rawEvent());
  }
};

// src/subscription/grouping.ts
function filterFingerprint(filters, closeOnEose) {
  const elements = [];
  for (const filter of filters) {
    const keys = Object.entries(filter || {}).map(([key, values]) => {
      if (["since", "until"].includes(key)) {
        return key + ":" + values;
      } else {
        return key;
      }
    }).sort().join("-");
    elements.push(keys);
  }
  let id = closeOnEose ? "+" : "";
  id += elements.join("|");
  return id;
}
function mergeFilters(filters) {
  const result = [];
  const lastResult = {};
  filters.filter((f) => !!f.limit).forEach((filterWithLimit) => result.push(filterWithLimit));
  filters = filters.filter((f) => !f.limit);
  if (filters.length === 0) return result;
  filters.forEach((filter) => {
    Object.entries(filter).forEach(([key, value]) => {
      if (Array.isArray(value)) {
        if (lastResult[key] === void 0) {
          lastResult[key] = [...value];
        } else {
          lastResult[key] = Array.from(/* @__PURE__ */ new Set([...lastResult[key], ...value]));
        }
      } else {
        lastResult[key] = value;
      }
    });
  });
  return [...result, lastResult];
}

// src/relay/subscription.ts
var NDKRelaySubscription = class {
  fingerprint;
  items = /* @__PURE__ */ new Map();
  topSubManager;
  debug;
  /**
   * Tracks the status of this REQ.
   */
  status = 0 /* INITIAL */;
  onClose;
  relay;
  /**
   * Whether this subscription has reached EOSE.
   */
  eosed = false;
  /**
   * Timeout at which this subscription will
   * start executing.
   */
  executionTimer;
  /**
   * Track the time at which this subscription will fire.
   */
  fireTime;
  /**
   * The delay type that the current fireTime was calculated with.
   */
  delayType;
  /**
   * The filters that have been executed.
   */
  executeFilters;
  id = Math.random().toString(36).substring(7);
  /**
   *
   * @param fingerprint The fingerprint of this subscription.
   */
  constructor(relay, fingerprint, topSubManager) {
    this.relay = relay;
    this.topSubManager = topSubManager;
    this.debug = relay.debug.extend("subscription-" + this.id);
    this.fingerprint = fingerprint || Math.random().toString(36).substring(7);
  }
  _subId;
  get subId() {
    if (this._subId) return this._subId;
    this._subId = this.fingerprint.slice(0, 15);
    return this._subId;
  }
  subIdParts = /* @__PURE__ */ new Set();
  addSubIdPart(part) {
    this.subIdParts.add(part);
  }
  addItem(subscription, filters) {
    this.debug("Adding item", { filters, internalId: subscription.internalId, status: this.status, fingerprint: this.fingerprint, id: this.subId, items: this.items, itemsSize: this.items.size });
    if (this.items.has(subscription.internalId)) return;
    subscription.on("close", this.removeItem.bind(this, subscription));
    this.items.set(subscription.internalId, { subscription, filters });
    if (this.status !== 3 /* RUNNING */) {
      if (subscription.subId && (!this._subId || this._subId.length < 48)) {
        if (this.status === 0 /* INITIAL */ || this.status === 1 /* PENDING */) {
          this.addSubIdPart(subscription.subId);
        }
      }
    }
    switch (this.status) {
      case 0 /* INITIAL */:
        this.evaluateExecutionPlan(subscription);
        break;
      case 3 /* RUNNING */:
        console.log(
          "BUG: This should not happen: This subscription needs to catch up with a subscription that was already running",
          filters
        );
        break;
      case 1 /* PENDING */:
        this.evaluateExecutionPlan(subscription);
        break;
      case 4 /* CLOSED */:
        this.debug(
          "Subscription is closed, cannot add new items %o (%o)",
          subscription,
          filters
        );
        throw new Error("Cannot add new items to a closed subscription");
    }
  }
  /**
   * A subscription has been closed, remove it from the list of items.
   * @param subscription
   */
  removeItem(subscription) {
    this.items.delete(subscription.internalId);
    if (this.items.size === 0) {
      if (!this.eosed) return;
      this.close();
      this.cleanup();
    }
  }
  close() {
    if (this.status === 4 /* CLOSED */) return;
    const prevStatus = this.status;
    this.status = 4 /* CLOSED */;
    if (prevStatus === 3 /* RUNNING */) {
      try {
        this.relay.close(this.subId);
      } catch (e) {
        this.debug("Error closing subscription", e, this);
      }
    } else {
      this.debug("Subscription wanted to close but it wasn't running, this is probably ok", {
        subId: this.subId,
        prevStatus,
        sub: this
      });
    }
    this.cleanup();
  }
  cleanup() {
    if (this.executionTimer) clearTimeout(this.executionTimer);
    this.relay.off("ready", this.executeOnRelayReady);
    this.relay.off("authed", this.reExecuteAfterAuth);
    if (this.onClose) this.onClose(this);
  }
  evaluateExecutionPlan(subscription) {
    if (!subscription.isGroupable()) {
      this.status = 1 /* PENDING */;
      this.execute();
      return;
    }
    if (subscription.filters.find((filter) => !!filter.limit)) {
      this.executeFilters = this.compileFilters();
      if (this.executeFilters.length >= 10) {
        this.status = 1 /* PENDING */;
        this.execute();
        return;
      }
    }
    const delay = subscription.groupableDelay;
    const delayType = subscription.groupableDelayType;
    if (!delay) throw new Error("Cannot group a subscription without a delay");
    if (this.status === 0 /* INITIAL */) {
      this.schedule(delay, delayType);
    } else {
      const existingDelayType = this.delayType;
      const timeUntilFire = this.fireTime - Date.now();
      if (existingDelayType === "at-least" && delayType === "at-least") {
        if (timeUntilFire < delay) {
          if (this.executionTimer) clearTimeout(this.executionTimer);
          this.schedule(delay, delayType);
        }
      } else if (existingDelayType === "at-least" && delayType === "at-most") {
        if (timeUntilFire > delay) {
          if (this.executionTimer) clearTimeout(this.executionTimer);
          this.schedule(delay, delayType);
        }
      } else if (existingDelayType === "at-most" && delayType === "at-most") {
        if (timeUntilFire > delay) {
          if (this.executionTimer) clearTimeout(this.executionTimer);
          this.schedule(delay, delayType);
        }
      } else if (existingDelayType === "at-most" && delayType === "at-least") {
        if (timeUntilFire > delay) {
          if (this.executionTimer) clearTimeout(this.executionTimer);
          this.schedule(delay, delayType);
        }
      } else {
        throw new Error(
          "Unknown delay type combination " + existingDelayType + " " + delayType
        );
      }
    }
  }
  schedule(delay, delayType) {
    this.status = 1 /* PENDING */;
    const currentTime = Date.now();
    this.fireTime = currentTime + delay;
    this.delayType = delayType;
    const timer = setTimeout(this.execute.bind(this), delay);
    if (delayType === "at-least") {
      this.executionTimer = timer;
    }
  }
  executeOnRelayReady = () => {
    if (this.status !== 2 /* WAITING */) return;
    if (this.items.size === 0) {
      this.debug("No items to execute; this relay was probably too slow to respond and the caller gave up", { status: this.status, fingerprint: this.fingerprint, items: this.items, itemsSize: this.items.size, id: this.id, subId: this.subId });
      this.cleanup();
      return;
    }
    this.debug("Executing on relay ready", { status: this.status, fingerprint: this.fingerprint, items: this.items, itemsSize: this.items.size });
    this.status = 1 /* PENDING */;
    this.execute();
  };
  finalizeSubId() {
    if (this.subIdParts.size > 0) {
      this._subId = Array.from(this.subIdParts).join("-");
    } else {
      this._subId = this.fingerprint.slice(0, 15);
    }
    this._subId += "-" + Math.random().toString(36).substring(2, 7);
  }
  // we do it this way so that we can remove the listener
  reExecuteAfterAuth = (() => {
    const oldSubId = this.subId;
    this.debug("Re-executing after auth", this.items.size);
    if (this.eosed) {
      this.relay.close(this.subId);
    } else {
      this.debug(
        "We are abandoning an opened subscription, once it EOSE's, the handler will close it",
        { oldSubId }
      );
    }
    this._subId = void 0;
    this.status = 1 /* PENDING */;
    this.execute();
    this.debug("Re-executed after auth %s \u{1F449} %s", oldSubId, this.subId);
  }).bind(this);
  execute() {
    if (this.status !== 1 /* PENDING */) {
      return;
    }
    if (!this.relay.connected) {
      this.status = 2 /* WAITING */;
      this.debug("Waiting for relay to be ready", { status: this.status, id: this.subId, fingerprint: this.fingerprint, items: this.items, itemsSize: this.items.size });
      this.relay.once("ready", this.executeOnRelayReady);
      return;
    } else if (this.relay.status < 8 /* AUTHENTICATED */) {
      this.relay.once("authed", this.reExecuteAfterAuth);
    }
    this.status = 3 /* RUNNING */;
    this.finalizeSubId();
    this.executeFilters = this.compileFilters();
    this.relay.req(this);
  }
  onstart() {
  }
  onevent(event) {
    this.topSubManager.dispatchEvent(event, this.relay);
  }
  oneose(subId) {
    this.eosed = true;
    if (subId !== this.subId) {
      this.debug("Received EOSE for an abandoned subscription", subId, this.subId);
      this.relay.close(subId);
      return;
    }
    if (this.items.size === 0) {
      this.close();
    }
    for (const { subscription } of this.items.values()) {
      subscription.eoseReceived(this.relay);
      if (subscription.closeOnEose) {
        this.debug("Removing item because of EOSE", { filters: subscription.filters, internalId: subscription.internalId, status: this.status, fingerprint: this.fingerprint, items: this.items, itemsSize: this.items.size });
        this.removeItem(subscription);
      }
    }
  }
  onclose(reason) {
    this.status = 4 /* CLOSED */;
  }
  onclosed(reason) {
    if (!reason) return;
    for (const { subscription } of this.items.values()) {
      subscription.closedReceived(this.relay, reason);
    }
  }
  /**
   * Grabs the filters from all the subscriptions
   * and merges them into a single filter.
   */
  compileFilters() {
    const mergedFilters = [];
    const filters = Array.from(this.items.values()).map((item) => item.filters);
    if (!filters[0]) {
      this.debug("\u{1F440} No filters to merge", this.items);
      console.error("BUG: No filters to merge!", this.items);
      return [];
    }
    const filterCount = filters[0].length;
    for (let i = 0; i < filterCount; i++) {
      const allFiltersAtIndex = filters.map((filter) => filter[i]);
      mergedFilters.push(...mergeFilters(allFiltersAtIndex));
    }
    return mergedFilters;
  }
};

// src/relay/sub-manager.ts
var NDKRelaySubscriptionManager = class {
  relay;
  subscriptions;
  generalSubManager;
  /**
   * @param relay - The relay instance.
   * @param generalSubManager - The subscription manager instance.
   */
  constructor(relay, generalSubManager) {
    this.relay = relay;
    this.subscriptions = /* @__PURE__ */ new Map();
    this.generalSubManager = generalSubManager;
  }
  /**
   * Adds a subscription to the manager.
   */
  addSubscription(sub, filters) {
    let relaySub;
    if (!sub.isGroupable()) {
      relaySub = this.createSubscription(sub, filters);
    } else {
      const filterFp = filterFingerprint(filters, sub.closeOnEose);
      if (filterFp) {
        const existingSubs = this.subscriptions.get(filterFp);
        relaySub = (existingSubs || []).find(
          (sub2) => sub2.status < 3 /* RUNNING */
        );
      }
      relaySub ??= this.createSubscription(sub, filters, filterFp);
    }
    relaySub.addItem(sub, filters);
  }
  createSubscription(sub, filters, fingerprint) {
    const relaySub = new NDKRelaySubscription(this.relay, fingerprint || null, this.generalSubManager);
    relaySub.onClose = this.onRelaySubscriptionClose.bind(this);
    const currentVal = this.subscriptions.get(relaySub.fingerprint) ?? [];
    this.subscriptions.set(relaySub.fingerprint, [...currentVal, relaySub]);
    return relaySub;
  }
  onRelaySubscriptionClose(sub) {
    let currentVal = this.subscriptions.get(sub.fingerprint) ?? [];
    if (!currentVal) {
      console.warn(
        "Unexpectedly did not find a subscription with fingerprint",
        sub.fingerprint
      );
    } else if (currentVal.length === 1) {
      this.subscriptions.delete(sub.fingerprint);
    } else {
      currentVal = currentVal.filter((s) => s.id !== sub.id);
      this.subscriptions.set(sub.fingerprint, currentVal);
    }
  }
};

// src/relay/index.ts
var NDKRelay = class _NDKRelay extends EventEmitter {
  url;
  scores;
  connectivity;
  subs;
  publisher;
  authPolicy;
  /**
   * The lowest validation ratio this relay can reach.
   */
  lowestValidationRatio;
  /**
   * Current validation ratio this relay is targeting.
   */
  targetValidationRatio;
  validationRatioFn;
  /**
   * This tracks events that have been seen by this relay
   * with a valid signature.
   */
  validatedEventCount = 0;
  /**
   * This tracks events that have been seen by this relay
   * but have not been validated.
   */
  nonValidatedEventCount = 0;
  /**
   * Whether this relay is trusted.
   *
   * Trusted relay's events do not get their signature verified.
   */
  trusted = false;
  complaining = false;
  debug;
  static defaultValidationRatioUpdateFn = (relay, validatedCount, nonValidatedCount) => {
    if (relay.lowestValidationRatio === void 0 || relay.targetValidationRatio === void 0)
      return 1;
    let newRatio = relay.validationRatio;
    if (relay.validationRatio > relay.targetValidationRatio) {
      const factor = validatedCount / 100;
      newRatio = Math.max(relay.lowestValidationRatio, relay.validationRatio - factor);
    }
    if (newRatio < relay.validationRatio) {
      return newRatio;
    }
    return relay.validationRatio;
  };
  constructor(url, authPolicy, ndk) {
    super();
    this.url = normalizeRelayUrl(url);
    this.scores = /* @__PURE__ */ new Map();
    this.debug = debug(`ndk:relay:${url}`);
    this.connectivity = new NDKRelayConnectivity(this, ndk);
    this.connectivity.netDebug = ndk?.netDebug;
    this.req = this.connectivity.req.bind(this.connectivity);
    this.close = this.connectivity.close.bind(this.connectivity);
    this.subs = new NDKRelaySubscriptionManager(this, ndk.subManager);
    this.publisher = new NDKRelayPublisher(this);
    this.authPolicy = authPolicy;
    this.targetValidationRatio = ndk?.initialValidationRatio;
    this.lowestValidationRatio = ndk?.lowestValidationRatio;
    this.validationRatioFn = (ndk?.validationRatioFn ?? _NDKRelay.defaultValidationRatioUpdateFn).bind(this);
    this.updateValidationRatio();
    if (!ndk) {
      console.trace("relay created without ndk");
    }
  }
  updateValidationRatio() {
    setTimeout(() => {
      this.updateValidationRatio();
    }, 3e4);
  }
  get status() {
    return this.connectivity.status;
  }
  get connectionStats() {
    return this.connectivity.connectionStats;
  }
  /**
   * Connects to the relay.
   */
  async connect(timeoutMs, reconnect = true) {
    return this.connectivity.connect(timeoutMs, reconnect);
  }
  /**
   * Disconnects from the relay.
   */
  disconnect() {
    if (this.status === 1 /* DISCONNECTED */) {
      return;
    }
    this.connectivity.disconnect();
  }
  /**
   * Queues or executes the subscription of a specific set of filters
   * within this relay.
   *
   * @param subscription NDKSubscription this filters belong to.
   * @param filters Filters to execute
   */
  subscribe(subscription, filters) {
    this.subs.addSubscription(subscription, filters);
  }
  /**
   * Publishes an event to the relay with an optional timeout.
   *
   * If the relay is not connected, the event will be published when the relay connects,
   * unless the timeout is reached before the relay connects.
   *
   * @param event The event to publish
   * @param timeoutMs The timeout for the publish operation in milliseconds
   * @returns A promise that resolves when the event has been published or rejects if the operation times out
   */
  async publish(event, timeoutMs = 2500) {
    return this.publisher.publish(event, timeoutMs);
  }
  referenceTags() {
    return [["r", this.url]];
  }
  addValidatedEvent() {
    this.validatedEventCount++;
  }
  addNonValidatedEvent() {
    this.nonValidatedEventCount++;
  }
  /**
   * The current validation ratio this relay has achieved.
   */
  get validationRatio() {
    if (this.nonValidatedEventCount === 0) {
      return 1;
    }
    return this.validatedEventCount / (this.validatedEventCount + this.nonValidatedEventCount);
  }
  shouldValidateEvent() {
    if (this.trusted) {
      return false;
    }
    if (this.targetValidationRatio === void 0) {
      return true;
    }
    return this.validationRatio < this.targetValidationRatio;
  }
  get connected() {
    return this.connectivity.connected;
  }
  req;
  close;
};

// src/relay/sets/index.ts
var NDKPublishError = class extends Error {
  errors;
  publishedToRelays;
  /**
   * Intended relay set where the publishing was intended to happen.
   */
  intendedRelaySet;
  constructor(message, errors, publishedToRelays, intendedRelaySet) {
    super(message);
    this.errors = errors;
    this.publishedToRelays = publishedToRelays;
    this.intendedRelaySet = intendedRelaySet;
  }
  get relayErrors() {
    const errors = [];
    for (const [relay, err] of this.errors) {
      errors.push(`${relay.url}: ${err}`);
    }
    return errors.join("\n");
  }
};
var NDKRelaySet = class _NDKRelaySet {
  relays;
  debug;
  ndk;
  pool;
  constructor(relays, ndk, pool) {
    this.relays = relays;
    this.ndk = ndk;
    this.pool = pool ?? ndk.pool;
    this.debug = ndk.debug.extend("relayset");
  }
  /**
   * Adds a relay to this set.
   */
  addRelay(relay) {
    this.relays.add(relay);
  }
  get relayUrls() {
    return Array.from(this.relays).map((r) => r.url);
  }
  /**
   * Creates a relay set from a list of relay URLs.
   *
   * If no connection to the relay is found in the pool it will temporarily
   * connect to it.
   *
   * @param relayUrls - list of relay URLs to include in this set
   * @param ndk
   * @param connect - whether to connect to the relay immediately if it was already in the pool but not connected
   * @returns NDKRelaySet
   */
  static fromRelayUrls(relayUrls, ndk, connect = true, pool) {
    pool = pool ?? ndk.pool;
    if (!pool) throw new Error("No pool provided");
    const relays = /* @__PURE__ */ new Set();
    for (const url of relayUrls) {
      const relay = pool.relays.get(normalizeRelayUrl(url));
      if (relay) {
        if (relay.status < 5 /* CONNECTED */ && connect) {
          relay.connect();
        }
        relays.add(relay);
      } else {
        const temporaryRelay = new NDKRelay(
          normalizeRelayUrl(url),
          ndk?.relayAuthDefaultPolicy,
          ndk
        );
        pool.useTemporaryRelay(
          temporaryRelay,
          void 0,
          "requested from fromRelayUrls " + relayUrls
        );
        relays.add(temporaryRelay);
      }
    }
    return new _NDKRelaySet(new Set(relays), ndk, pool);
  }
  /**
   * Publish an event to all relays in this set. Returns the number of relays that have received the event.
   * @param event
   * @param timeoutMs - timeout in milliseconds for each publish operation and connection operation
   * @returns A set where the event was successfully published to
   * @throws NDKPublishError if no relay was able to receive the event
   * @example
   * ```typescript
   * const event = new NDKEvent(ndk, {kinds: [NDKKind.Message], "#d": ["123"]});
   * try {
   *    const publishedToRelays = await relaySet.publish(event);
   *    console.log(`published to ${publishedToRelays.size} relays`)
   * } catch (error) {
   *   console.error("error publishing to relays", error);
   *
   *   if (error instanceof NDKPublishError) {
   *      for (const [relay, err] of error.errors) {
   *         console.error(`error publishing to relay ${relay.url}`, err);
   *       }
   *   }
   * }
   * ```
   */
  async publish(event, timeoutMs, requiredRelayCount = 1) {
    const publishedToRelays = /* @__PURE__ */ new Set();
    const errors = /* @__PURE__ */ new Map();
    const isEphemeral2 = event.isEphemeral();
    event.publishStatus = "pending";
    const promises = Array.from(this.relays).map((relay) => {
      return new Promise((resolve) => {
        relay.publish(event, timeoutMs).then((e) => {
          publishedToRelays.add(relay);
          resolve();
        }).catch((err) => {
          if (!isEphemeral2) {
            errors.set(relay, err);
          }
          resolve();
        });
      });
    });
    await Promise.all(promises);
    if (publishedToRelays.size < requiredRelayCount) {
      if (!isEphemeral2) {
        const error = new NDKPublishError(
          "Not enough relays received the event",
          errors,
          publishedToRelays,
          this
        );
        event.publishStatus = "error";
        event.publishError = error;
        this.ndk.emit("event:publish-failed", event, error, this.relayUrls);
        throw error;
      }
    } else {
      event.emit("published", { relaySet: this, publishedToRelays });
    }
    return publishedToRelays;
  }
  get size() {
    return this.relays.size;
  }
};

// src/relay/sets/calculate.ts
import createDebug from "debug";
var d = createDebug("ndk:outbox:calculate");
async function calculateRelaySetFromEvent(ndk, event) {
  const relays = /* @__PURE__ */ new Set();
  const authorWriteRelays = await getWriteRelaysFor(ndk, event.pubkey);
  if (authorWriteRelays) {
    authorWriteRelays.forEach((relayUrl) => {
      const relay = ndk.pool?.getRelay(relayUrl);
      if (relay) relays.add(relay);
    });
  }
  let relayHints = event.tags.filter((tag) => ["a", "e"].includes(tag[0])).map((tag) => tag[2]).filter((url) => url && url.startsWith("wss://")).filter((url) => {
    try {
      new URL(url);
      return true;
    } catch {
      return false;
    }
  }).map((url) => normalizeRelayUrl(url));
  relayHints = Array.from(new Set(relayHints)).slice(0, 5);
  relayHints.forEach((relayUrl) => {
    const relay = ndk.pool?.getRelay(relayUrl, true, true);
    if (relay) {
      d("Adding relay hint %s", relayUrl);
      relays.add(relay);
    }
  });
  const pTags = event.getMatchingTags("p").map((tag) => tag[1]);
  if (pTags.length < 5) {
    const pTaggedRelays = Array.from(
      chooseRelayCombinationForPubkeys(ndk, pTags, "read", {
        preferredRelays: new Set(authorWriteRelays)
      }).keys()
    );
    pTaggedRelays.forEach((relayUrl) => {
      const relay = ndk.pool?.getRelay(relayUrl, false, true);
      if (relay) {
        d("Adding p-tagged relay %s", relayUrl);
        relays.add(relay);
      }
    });
  } else {
    d("Too many p-tags to consider %d", pTags.length);
  }
  ndk.pool?.permanentAndConnectedRelays().forEach((relay) => relays.add(relay));
  return new NDKRelaySet(relays, ndk);
}

// src/events/content-tagger.ts
import { nip19 } from "nostr-tools";
function mergeTags(tags1, tags2) {
  const tagMap = /* @__PURE__ */ new Map();
  const generateKey = (tag) => tag.join(",");
  const isContained = (smaller, larger) => {
    return smaller.every((value, index) => value === larger[index]);
  };
  const processTag = (tag) => {
    for (const [key, existingTag] of tagMap) {
      if (isContained(existingTag, tag) || isContained(tag, existingTag)) {
        if (tag.length >= existingTag.length) {
          tagMap.set(key, tag);
        }
        return;
      }
    }
    tagMap.set(generateKey(tag), tag);
  };
  tags1.concat(tags2).forEach(processTag);
  return Array.from(tagMap.values());
}
var hashtagRegex = /(?<=\s|^)(#[^\s!@#$%^&*()=+./,[{\]};:'"?><]+)/g;
function generateHashtags(content) {
  const hashtags = content.match(hashtagRegex);
  const tagIds = /* @__PURE__ */ new Set();
  const tag = /* @__PURE__ */ new Set();
  if (hashtags) {
    for (const hashtag of hashtags) {
      if (tagIds.has(hashtag.slice(1))) continue;
      tag.add(hashtag.slice(1));
      tagIds.add(hashtag.slice(1));
    }
  }
  return Array.from(tag);
}
async function generateContentTags(content, tags = []) {
  const tagRegex = /(@|nostr:)(npub|nprofile|note|nevent|naddr)[a-zA-Z0-9]+/g;
  const promises = [];
  const addTagIfNew = (t) => {
    if (!tags.find((t2) => ["q", t[0]].includes(t2[0]) && t2[1] === t[1])) {
      tags.push(t);
    }
  };
  content = content.replace(tagRegex, (tag) => {
    try {
      const entity = tag.split(/(@|nostr:)/)[2];
      const { type, data } = nip19.decode(entity);
      let t;
      switch (type) {
        case "npub":
          t = ["p", data];
          break;
        case "nprofile":
          t = ["p", data.pubkey];
          break;
        case "note":
          promises.push(
            new Promise(async (resolve) => {
              addTagIfNew([
                "q",
                data,
                await maybeGetEventRelayUrl(entity)
              ]);
              resolve();
            })
          );
          break;
        case "nevent":
          promises.push(
            new Promise(async (resolve) => {
              const { id, author } = data;
              let { relays } = data;
              if (!relays || relays.length === 0) {
                relays = [await maybeGetEventRelayUrl(entity)];
              }
              addTagIfNew(["q", id, relays[0]]);
              if (author) addTagIfNew(["p", author]);
              resolve();
            })
          );
          break;
        case "naddr":
          promises.push(
            new Promise(async (resolve) => {
              const id = [data.kind, data.pubkey, data.identifier].join(":");
              let relays = data.relays ?? [];
              if (relays.length === 0) {
                relays = [await maybeGetEventRelayUrl(entity)];
              }
              addTagIfNew(["q", id, relays[0]]);
              addTagIfNew(["p", data.pubkey]);
              resolve();
            })
          );
          break;
        default:
          return tag;
      }
      if (t) addTagIfNew(t);
      return `nostr:${entity}`;
    } catch (error) {
      return tag;
    }
  });
  await Promise.all(promises);
  const newTags = generateHashtags(content).map((hashtag) => ["t", hashtag]);
  tags = mergeTags(tags, newTags);
  return { content, tags };
}
async function maybeGetEventRelayUrl(nip19Id) {
  return "";
}

// src/events/kind.ts
function isReplaceable() {
  if (this.kind === void 0) throw new Error("Kind not set");
  return [0, 3].includes(this.kind) || this.kind >= 1e4 && this.kind < 2e4 || this.kind >= 3e4 && this.kind < 4e4;
}
function isEphemeral() {
  if (this.kind === void 0) throw new Error("Kind not set");
  return this.kind >= 2e4 && this.kind < 3e4;
}
function isParamReplaceable() {
  if (this.kind === void 0) throw new Error("Kind not set");
  return this.kind >= 3e4 && this.kind < 4e4;
}

// src/events/encryption.ts
async function encrypt(recipient, signer, scheme = "nip44") {
  let encrypted;
  if (!this.ndk) throw new Error("No NDK instance found!");
  if (!signer) {
    this.ndk.assertSigner();
    signer = this.ndk.signer;
  }
  if (!recipient) {
    const pTags = this.getMatchingTags("p");
    if (pTags.length !== 1) {
      throw new Error(
        "No recipient could be determined and no explicit recipient was provided"
      );
    }
    recipient = this.ndk.getUser({ pubkey: pTags[0][1] });
  }
  if (scheme === "nip44" && await isEncryptionEnabled(signer, "nip44")) {
    encrypted = await signer?.encrypt(recipient, this.content, "nip44");
  }
  if ((!encrypted || scheme === "nip04") && await isEncryptionEnabled(signer, "nip04")) {
    encrypted = await signer.encrypt(recipient, this.content, "nip04");
  }
  if (!encrypted) throw new Error("Failed to encrypt event.");
  this.content = encrypted;
}
async function decrypt(sender, signer, scheme) {
  let decrypted;
  if (!this.ndk) throw new Error("No NDK instance found!");
  if (!signer) {
    this.ndk.assertSigner();
    signer = this.ndk.signer;
  }
  if (!signer) throw new Error("no NDK signer");
  if (!sender) {
    sender = this.author;
  }
  if (!scheme) scheme = this.content.match(/\\?iv=/) ? "nip04" : "nip44";
  if ((scheme === "nip04" || this.kind === 4) && await isEncryptionEnabled(signer, "nip04") && this.content.search("\\?iv=")) {
    decrypted = await signer.decrypt(sender, this.content, "nip04");
  }
  if (!decrypted && scheme === "nip44" && await isEncryptionEnabled(signer, "nip44")) {
    decrypted = await signer.decrypt(sender, this.content, "nip44");
  }
  if (!decrypted) throw new Error("Failed to decrypt event.");
  this.content = decrypted;
}
async function isEncryptionEnabled(signer, scheme) {
  if (!signer.encryptionEnabled) return false;
  if (!scheme) return true;
  return Boolean(await signer.encryptionEnabled(scheme));
}

// src/events/nip19.ts
import { nip19 as nip192 } from "nostr-tools";
var DEFAULT_RELAY_COUNT = 2;
function encode(maxRelayCount = DEFAULT_RELAY_COUNT) {
  let relays = [];
  if (this.onRelays.length > 0) {
    relays = this.onRelays.map((relay) => relay.url);
  } else if (this.relay) {
    relays = [this.relay.url];
  }
  if (relays.length > maxRelayCount) {
    relays = relays.slice(0, maxRelayCount);
  }
  if (this.isParamReplaceable()) {
    return nip192.naddrEncode({
      kind: this.kind,
      pubkey: this.pubkey,
      identifier: this.replaceableDTag(),
      relays
    });
  } else if (relays.length > 0) {
    return nip192.neventEncode({
      id: this.tagId(),
      relays,
      author: this.pubkey
    });
  } else {
    return nip192.noteEncode(this.tagId());
  }
}

// src/events/repost.ts
async function repost(publish = true, signer) {
  if (!signer && publish) {
    if (!this.ndk) throw new Error("No NDK instance found");
    this.ndk.assertSigner();
    signer = this.ndk.signer;
  }
  const e = new NDKEvent(this.ndk, {
    kind: getKind(this)
  });
  if (!this.isProtected)
    e.content = JSON.stringify(this.rawEvent());
  e.tag(this);
  if (this.kind !== 1 /* Text */) {
    e.tags.push(["k", `${this.kind}`]);
  }
  if (signer) await e.sign(signer);
  if (publish) await e.publish();
  return e;
}
function getKind(event) {
  if (event.kind === 1) {
    return 6 /* Repost */;
  }
  return 16 /* GenericRepost */;
}

// src/thread/index.ts
function eventHasETagMarkers(event) {
  for (const tag of event.tags) {
    if (tag[0] === "e" && (tag[3] ?? "").length > 0) return true;
  }
  return false;
}
function getRootTag(event, searchTag) {
  searchTag ??= event.tagType();
  const rootEventTag = event.tags.find(isTagRootTag);
  if (!rootEventTag) {
    if (eventHasETagMarkers(event)) return;
    const matchingTags = event.getMatchingTags(searchTag);
    if (matchingTags.length < 3) return matchingTags[0];
  }
  return rootEventTag;
}
var nip22RootTags = /* @__PURE__ */ new Set(["A", "E", "I"]);
var nip22ReplyTags = /* @__PURE__ */ new Set(["a", "e", "i"]);
function getReplyTag(event, searchTag) {
  if (event.kind === 1111 /* GenericReply */) {
    let replyTag2;
    for (const tag of event.tags) {
      if (nip22RootTags.has(tag[0])) replyTag2 = tag;
      else if (nip22ReplyTags.has(tag[0])) {
        replyTag2 = tag;
        break;
      }
    }
    return replyTag2;
  }
  searchTag ??= event.tagType();
  let hasMarkers = false;
  let replyTag;
  for (const tag of event.tags) {
    if (tag[0] !== searchTag) continue;
    if ((tag[3] ?? "").length > 0) hasMarkers = true;
    if (hasMarkers && tag[3] === "reply") return tag;
    if (hasMarkers && tag[3] === "root") replyTag = tag;
    if (!hasMarkers) replyTag = tag;
  }
  return replyTag;
}
function isTagRootTag(tag) {
  return tag[0] === "E" || tag[3] === "root";
}

// src/events/fetch-tagged-event.ts
async function fetchTaggedEvent(tag, marker) {
  if (!this.ndk) throw new Error("NDK instance not found");
  const t = this.getMatchingTags(tag, marker);
  if (t.length === 0) return void 0;
  const [_, id, hint] = t[0];
  let relay;
  const event = await this.ndk.fetchEvent(id, {}, relay);
  return event;
}
async function fetchRootEvent(subOpts) {
  if (!this.ndk) throw new Error("NDK instance not found");
  const rootTag = getRootTag(this);
  if (!rootTag) return void 0;
  return this.ndk.fetchEventFromTag(rootTag, this, subOpts);
}
async function fetchReplyEvent(subOpts) {
  if (!this.ndk) throw new Error("NDK instance not found");
  const replyTag = getReplyTag(this);
  if (!replyTag) return void 0;
  return this.ndk.fetchEventFromTag(replyTag, this, subOpts);
}

// src/events/serializer.ts
function serialize(includeSig = false, includeId = false) {
  const payload = [0, this.pubkey, this.created_at, this.kind, this.tags, this.content];
  if (includeSig) payload.push(this.sig);
  if (includeId) payload.push(this.id);
  return JSON.stringify(payload);
}
function deserialize(serializedEvent) {
  const eventArray = JSON.parse(serializedEvent);
  const ret = {
    pubkey: eventArray[1],
    created_at: eventArray[2],
    kind: eventArray[3],
    tags: eventArray[4],
    content: eventArray[5]
  };
  if (eventArray.length >= 7) ret.sig = eventArray[6];
  if (eventArray.length >= 8) ret.id = eventArray[7];
  return ret;
}

// src/events/validation.ts
import { sha256 } from "@noble/hashes/sha256";
import { bytesToHex } from "@noble/hashes/utils";
import { schnorr } from "@noble/curves/secp256k1";

// src/events/signature.ts
var worker;
var processingQueue = {};
async function verifySignatureAsync(event, persist) {
  const promise = new Promise((resolve) => {
    const serialized = event.serialize();
    let enqueue = false;
    if (!processingQueue[event.id]) {
      processingQueue[event.id] = { event, resolves: [] };
      enqueue = true;
    }
    processingQueue[event.id].resolves.push(resolve);
    if (!enqueue) return;
    worker.postMessage({
      serialized,
      id: event.id,
      sig: event.sig,
      pubkey: event.pubkey
    });
  });
  return promise;
}

// src/events/validation.ts
import { LRUCache } from "typescript-lru-cache";
var PUBKEY_REGEX = /^[a-f0-9]{64}$/;
function validate() {
  if (typeof this.kind !== "number") return false;
  if (typeof this.content !== "string") return false;
  if (typeof this.created_at !== "number") return false;
  if (typeof this.pubkey !== "string") return false;
  if (!this.pubkey.match(PUBKEY_REGEX)) return false;
  if (!Array.isArray(this.tags)) return false;
  for (let i = 0; i < this.tags.length; i++) {
    const tag = this.tags[i];
    if (!Array.isArray(tag)) return false;
    for (let j = 0; j < tag.length; j++) {
      if (typeof tag[j] === "object") return false;
    }
  }
  return true;
}
var verifiedSignatures = new LRUCache({
  maxSize: 1e3,
  entryExpirationTimeInMS: 6e4
});
function verifySignature(persist) {
  if (typeof this.signatureVerified === "boolean") return this.signatureVerified;
  const prevVerification = verifiedSignatures.get(this.id);
  if (prevVerification !== null) {
    return this.signatureVerified = !!prevVerification;
  }
  try {
    if (this.ndk?.asyncSigVerification) {
      verifySignatureAsync(this, persist).then((result) => {
        if (persist) {
          this.signatureVerified = result;
          if (result) verifiedSignatures.set(this.id, this.sig);
        }
        if (!result) {
          this.ndk.emit("event:invalid-sig", this);
          verifiedSignatures.set(this.id, false);
        }
      });
    } else {
      const hash = sha256(new TextEncoder().encode(this.serialize()));
      const res = schnorr.verify(this.sig, hash, this.pubkey);
      if (res) verifiedSignatures.set(this.id, this.sig);
      else verifiedSignatures.set(this.id, false);
      return this.signatureVerified = res;
    }
  } catch (err) {
    return this.signatureVerified = false;
  }
}
function getEventHash() {
  return getEventHashFromSerializedEvent(this.serialize());
}
function getEventHashFromSerializedEvent(serializedEvent) {
  const eventHash = sha256(new TextEncoder().encode(serializedEvent));
  return bytesToHex(eventHash);
}

// src/events/index.ts
var skipClientTagOnKinds = /* @__PURE__ */ new Set([
  0 /* Metadata */,
  4 /* EncryptedDirectMessage */,
  1059 /* GiftWrap */,
  13 /* GiftWrapSeal */,
  3 /* Contacts */,
  9734 /* ZapRequest */,
  5 /* EventDeletion */
]);
var NDKEvent = class _NDKEvent extends EventEmitter2 {
  ndk;
  created_at;
  content = "";
  tags = [];
  kind;
  id = "";
  sig;
  pubkey = "";
  signatureVerified;
  _author = void 0;
  /**
   * The relay that this event was first received from.
   */
  relay;
  /**
   * The relays that this event was received from and/or successfully published to.
   */
  get onRelays() {
    let res = [];
    if (!this.ndk) {
      if (this.relay) res.push(this.relay);
    } else {
      res = this.ndk.subManager.seenEvents.get(this.id) || [];
    }
    return res;
  }
  /**
   * The status of the publish operation.
   */
  publishStatus = "success";
  publishError;
  constructor(ndk, event) {
    super();
    this.ndk = ndk;
    this.created_at = event?.created_at;
    this.content = event?.content || "";
    this.tags = event?.tags || [];
    this.id = event?.id || "";
    this.sig = event?.sig;
    this.pubkey = event?.pubkey || "";
    this.kind = event?.kind;
    if (event instanceof _NDKEvent) {
      if (this.relay) {
        this.relay = event.relay;
        this.ndk?.subManager.seenEvent(event.id, this.relay);
      }
      this.publishStatus = event.publishStatus;
      this.publishError = event.publishError;
    }
  }
  /**
   * Deserialize an NDKEvent from a serialized payload.
   * @param ndk
   * @param event
   * @returns
   */
  static deserialize(ndk, event) {
    return new _NDKEvent(ndk, deserialize(event));
  }
  /**
   * Returns the event as is.
   */
  rawEvent() {
    return {
      created_at: this.created_at,
      content: this.content,
      tags: this.tags,
      kind: this.kind,
      pubkey: this.pubkey,
      id: this.id,
      sig: this.sig
    };
  }
  set author(user) {
    this.pubkey = user.pubkey;
    this._author = user;
    this._author.ndk ??= this.ndk;
  }
  /**
   * Returns an NDKUser for the author of the event.
   */
  get author() {
    if (this._author) return this._author;
    if (!this.ndk) throw new Error("No NDK instance found");
    const user = this.ndk.getUser({ pubkey: this.pubkey });
    this._author = user;
    return user;
  }
  /**
   * NIP-73 tagging of external entities
   * @param entity to be tagged
   * @param type of the entity
   * @param markerUrl to be used as the marker URL
   *
   * @example
   * ```typescript
   * event.tagExternal("https://example.com/article/123#nostr", "url");
   * event.tags => [["i", "https://example.com/123"], ["k", "https://example.com"]]
   * ```
   *
   * @example tag a podcast:item:guid
   * ```typescript
   * event.tagExternal("e32b4890-b9ea-4aef-a0bf-54b787833dc5", "podcast:item:guid");
   * event.tags => [["i", "podcast:item:guid:e32b4890-b9ea-4aef-a0bf-54b787833dc5"], ["k", "podcast:item:guid"]]
   * ```
   *
   * @see https://github.com/nostr-protocol/nips/blob/master/73.md
   */
  tagExternal(entity, type, markerUrl) {
    let iTag = ["i"];
    let kTag = ["k"];
    switch (type) {
      case "url":
        const url = new URL(entity);
        url.hash = "";
        iTag.push(url.toString());
        kTag.push(`${url.protocol}//${url.host}`);
        break;
      case "hashtag":
        iTag.push(`#${entity.toLowerCase()}`);
        kTag.push("#");
        break;
      case "geohash":
        iTag.push(`geo:${entity.toLowerCase()}`);
        kTag.push("geo");
        break;
      case "isbn":
        iTag.push(`isbn:${entity.replace(/-/g, "")}`);
        kTag.push("isbn");
        break;
      case "podcast:guid":
        iTag.push(`podcast:guid:${entity}`);
        kTag.push("podcast:guid");
        break;
      case "podcast:item:guid":
        iTag.push(`podcast:item:guid:${entity}`);
        kTag.push("podcast:item:guid");
        break;
      case "podcast:publisher:guid":
        iTag.push(`podcast:publisher:guid:${entity}`);
        kTag.push("podcast:publisher:guid");
        break;
      case "isan":
        iTag.push(`isan:${entity.split("-").slice(0, 4).join("-")}`);
        kTag.push("isan");
        break;
      case "doi":
        iTag.push(`doi:${entity.toLowerCase()}`);
        kTag.push("doi");
        break;
      default:
        throw new Error(`Unsupported NIP-73 entity type: ${type}`);
    }
    if (markerUrl) {
      iTag.push(markerUrl);
    }
    this.tags.push(iTag);
    this.tags.push(kTag);
  }
  /**
   * Tag a user with an optional marker.
   * @param target What is to be tagged. Can be an NDKUser, NDKEvent, or an NDKTag.
   * @param marker The marker to use in the tag.
   * @param skipAuthorTag Whether to explicitly skip adding the author tag of the event.
   * @param forceTag Force a specific tag to be used instead of the default "e" or "a" tag.
   * @example
   * ```typescript
   * reply.tag(opEvent, "reply");
   * // reply.tags => [["e", <id>, <relay>, "reply"]]
   * ```
   */
  tag(target, marker, skipAuthorTag, forceTag) {
    let tags = [];
    const isNDKUser = target.fetchProfile !== void 0;
    if (isNDKUser) {
      forceTag ??= "p";
      const tag = [forceTag, target.pubkey];
      if (marker) tag.push(...["", marker]);
      tags.push(tag);
    } else if (target instanceof _NDKEvent) {
      const event = target;
      skipAuthorTag ??= event?.pubkey === this.pubkey;
      tags = event.referenceTags(marker, skipAuthorTag, forceTag);
      for (const pTag of event.getMatchingTags("p")) {
        if (pTag[1] === this.pubkey) continue;
        if (this.tags.find((t) => t[0] === "p" && t[1] === pTag[1])) continue;
        this.tags.push(["p", pTag[1]]);
      }
    } else if (Array.isArray(target)) {
      tags = [target];
    } else {
      throw new Error("Invalid argument", target);
    }
    this.tags = mergeTags(this.tags, tags);
  }
  /**
   * Return a NostrEvent object, trying to fill in missing fields
   * when possible, adding tags when necessary.
   * @param pubkey {string} The pubkey of the user who the event belongs to.
   * @returns {Promise<NostrEvent>} A promise that resolves to a NostrEvent.
   */
  async toNostrEvent(pubkey) {
    if (!pubkey && this.pubkey === "") {
      const user = await this.ndk?.signer?.user();
      this.pubkey = user?.pubkey || "";
    }
    if (!this.created_at) {
      this.created_at = Math.floor(Date.now() / 1e3);
    }
    const { content, tags } = await this.generateTags();
    this.content = content || "";
    this.tags = tags;
    try {
      this.id = this.getEventHash();
    } catch (e) {
    }
    return this.rawEvent();
  }
  serialize = serialize.bind(this);
  getEventHash = getEventHash.bind(this);
  validate = validate.bind(this);
  verifySignature = verifySignature.bind(this);
  /**
   * Is this event replaceable (whether parameterized or not)?
   *
   * This will return true for kind 0, 3, 10k-20k and 30k-40k
   */
  isReplaceable = isReplaceable.bind(this);
  isEphemeral = isEphemeral.bind(this);
  isDvm = () => this.kind && this.kind >= 5e3 && this.kind <= 7e3;
  /**
   * Is this event parameterized replaceable?
   *
   * This will return true for kind 30k-40k
   */
  isParamReplaceable = isParamReplaceable.bind(this);
  /**
   * Encodes a bech32 id.
   *
   * @param relays {string[]} The relays to encode in the id
   * @returns {string} - Encoded naddr, note or nevent.
   */
  encode = encode.bind(this);
  encrypt = encrypt.bind(this);
  decrypt = decrypt.bind(this);
  /**
   * Get all tags with the given name
   * @param tagName {string} The name of the tag to search for
   * @returns {NDKTag[]} An array of the matching tags
   */
  getMatchingTags(tagName, marker) {
    const t = this.tags.filter((tag) => tag[0] === tagName);
    if (marker === void 0) return t;
    return t.filter((tag) => tag[3] === marker);
  }
  /**
   * Check if the event has a tag with the given name
   * @param tagName
   * @param marker
   * @returns
   */
  hasTag(tagName, marker) {
    return this.tags.some((tag) => tag[0] === tagName && (!marker || tag[3] === marker));
  }
  /**
   * Get the first tag with the given name
   * @param tagName Tag name to search for
   * @returns The value of the first tag with the given name, or undefined if no such tag exists
   */
  tagValue(tagName) {
    const tags = this.getMatchingTags(tagName);
    if (tags.length === 0) return void 0;
    return tags[0][1];
  }
  /**
   * Gets the NIP-31 "alt" tag of the event.
   */
  get alt() {
    return this.tagValue("alt");
  }
  /**
   * Sets the NIP-31 "alt" tag of the event. Use this to set an alt tag so
   * clients that don't handle a particular event kind can display something
   * useful for users.
   */
  set alt(alt) {
    this.removeTag("alt");
    if (alt) this.tags.push(["alt", alt]);
  }
  /**
   * Gets the NIP-33 "d" tag of the event.
   */
  get dTag() {
    return this.tagValue("d");
  }
  /**
   * Sets the NIP-33 "d" tag of the event.
   */
  set dTag(value) {
    this.removeTag("d");
    if (value) this.tags.push(["d", value]);
  }
  /**
   * Remove all tags with the given name (e.g. "d", "a", "p")
   * @param tagName Tag name(s) to search for and remove
   * @returns {void}
   */
  removeTag(tagName) {
    const tagNames = Array.isArray(tagName) ? tagName : [tagName];
    this.tags = this.tags.filter((tag) => !tagNames.includes(tag[0]));
  }
  /**
   * Sign the event if a signer is present.
   *
   * It will generate tags.
   * Repleacable events will have their created_at field set to the current time.
   * @param signer {NDKSigner} The NDKSigner to use to sign the event
   * @returns {Promise<string>} A Promise that resolves to the signature of the signed event.
   */
  async sign(signer) {
    if (!signer) {
      this.ndk?.assertSigner();
      signer = this.ndk.signer;
    } else {
      this.author = await signer.user();
    }
    const nostrEvent = await this.toNostrEvent();
    this.sig = await signer.sign(nostrEvent);
    return this.sig;
  }
  /**
   *
   * @param relaySet
   * @param timeoutMs
   * @param requiredRelayCount
   * @returns
   */
  async publishReplaceable(relaySet, timeoutMs, requiredRelayCount) {
    this.id = "";
    this.created_at = Math.floor(Date.now() / 1e3);
    this.sig = "";
    return this.publish(relaySet, timeoutMs, requiredRelayCount);
  }
  /**
   * Attempt to sign and then publish an NDKEvent to a given relaySet.
   * If no relaySet is provided, the relaySet will be calculated by NDK.
   * @param relaySet {NDKRelaySet} The relaySet to publish the even to.
   * @param timeoutM {number} The timeout for the publish operation in milliseconds.
   * @param requiredRelayCount The number of relays that must receive the event for the publish to be considered successful.
   * @returns A promise that resolves to the relays the event was published to.
   */
  async publish(relaySet, timeoutMs, requiredRelayCount) {
    if (!this.sig) await this.sign();
    if (!this.ndk)
      throw new Error("NDKEvent must be associated with an NDK instance to publish");
    if (!relaySet) {
      relaySet = this.ndk.devWriteRelaySet || await calculateRelaySetFromEvent(this.ndk, this);
    }
    if (this.kind === 5 /* EventDeletion */ && this.ndk.cacheAdapter?.deleteEventIds) {
      const eTags = this.getMatchingTags("e").map((tag) => tag[1]);
      this.ndk.cacheAdapter.deleteEventIds(eTags);
    }
    const rawEvent = this.rawEvent();
    if (this.ndk.cacheAdapter?.addUnpublishedEvent && shouldTrackUnpublishedEvent(this)) {
      try {
        this.ndk.cacheAdapter.addUnpublishedEvent(this, relaySet.relayUrls);
      } catch (e) {
        console.error("Error adding unpublished event to cache", e);
      }
    }
    if (this.kind === 5 /* EventDeletion */ && this.ndk.cacheAdapter?.deleteEventIds) {
      this.ndk.cacheAdapter.deleteEventIds(this.getMatchingTags("e").map((tag) => tag[1]));
    }
    this.ndk.subManager.dispatchEvent(rawEvent, void 0, true);
    const relays = await relaySet.publish(this, timeoutMs, requiredRelayCount);
    relays.forEach((relay) => this.ndk?.subManager.seenEvent(this.id, relay));
    return relays;
  }
  /**
   * Generates tags for users, notes, and other events tagged in content.
   * Will also generate random "d" tag for parameterized replaceable events where needed.
   * @returns {ContentTag} The tags and content of the event.
   */
  async generateTags() {
    let tags = [];
    const g = await generateContentTags(this.content, this.tags);
    const content = g.content;
    tags = g.tags;
    if (this.kind && this.isParamReplaceable()) {
      const dTag = this.getMatchingTags("d")[0];
      if (!dTag) {
        const title = this.tagValue("title");
        const randLength = title ? 6 : 16;
        let str = [...Array(randLength)].map(() => Math.random().toString(36)[2]).join("");
        if (title && title.length > 0) {
          str = title.replace(/[^a-z0-9]+/gi, "-").replace(/^-|-$/g, "") + "-" + str;
        }
        tags.push(["d", str]);
      }
    }
    if (this.shouldAddClientTag) {
      const clientTag = ["client", this.ndk.clientName ?? ""];
      if (this.ndk.clientNip89) clientTag.push(this.ndk.clientNip89);
      tags.push(clientTag);
    } else if (this.shouldStripClientTag) {
      tags = tags.filter((tag) => tag[0] !== "client");
    }
    return { content: content || "", tags };
  }
  get shouldAddClientTag() {
    if (!this.ndk?.clientName && !this.ndk?.clientNip89) return false;
    if (skipClientTagOnKinds.has(this.kind)) return false;
    if (this.isEphemeral() || this.isReplaceable()) return false;
    if (this.isDvm()) return false;
    if (this.hasTag("client")) return false;
    return true;
  }
  get shouldStripClientTag() {
    return skipClientTagOnKinds.has(this.kind);
  }
  muted() {
    const authorMutedEntry = this.ndk?.mutedIds.get(this.pubkey);
    if (authorMutedEntry && authorMutedEntry === "p") return "author";
    const eventTagReference = this.tagReference();
    const eventMutedEntry = this.ndk?.mutedIds.get(eventTagReference[1]);
    if (eventMutedEntry && eventMutedEntry === eventTagReference[0]) return "event";
    return null;
  }
  /**
   * Returns the "d" tag of a parameterized replaceable event or throws an error if the event isn't
   * a parameterized replaceable event.
   * @returns {string} the "d" tag of the event.
   * 
   * @deprecated Use `dTag` instead.
   */
  replaceableDTag() {
    if (this.kind && this.kind >= 3e4 && this.kind <= 4e4) {
      const dTag = this.getMatchingTags("d")[0];
      const dTagId = dTag ? dTag[1] : "";
      return dTagId;
    }
    throw new Error("Event is not a parameterized replaceable event");
  }
  /**
   * Provides a deduplication key for the event.
   *
   * For kinds 0, 3, 10k-20k this will be the event <kind>:<pubkey>
   * For kinds 30k-40k this will be the event <kind>:<pubkey>:<d-tag>
   * For all other kinds this will be the event id
   */
  deduplicationKey() {
    if (this.kind === 0 || this.kind === 3 || this.kind && this.kind >= 1e4 && this.kind < 2e4) {
      return `${this.kind}:${this.pubkey}`;
    } else {
      return this.tagId();
    }
  }
  /**
   * Returns the id of the event or, if it's a parameterized event, the generated id of the event using "d" tag, pubkey, and kind.
   * @returns {string} The id
   */
  tagId() {
    if (this.isParamReplaceable()) {
      return this.tagAddress();
    }
    return this.id;
  }
  /**
   * Returns a stable reference value for a replaceable event.
   * 
   * Param replaceable events are returned in the expected format of `<kind>:<pubkey>:<d-tag>`.
   * Kind-replaceable events are returned in the format of `<kind>:<pubkey>:`.
   * 
   * @returns {string} A stable reference value for replaceable events
   */
  tagAddress() {
    if (this.isParamReplaceable()) {
      const dTagId = this.dTag ?? "";
      return `${this.kind}:${this.pubkey}:${dTagId}`;
    } else if (this.isReplaceable()) {
      return `${this.kind}:${this.pubkey}:`;
    }
    throw new Error("Event is not a replaceable event");
  }
  /**
   * Determines the type of tag that can be used to reference this event from another event.
   * @returns {string} The tag type
   * @example
   * event = new NDKEvent(ndk, { kind: 30000, pubkey: 'pubkey', tags: [ ["d", "d-code"] ] });
   * event.tagType(); // "a"
   */
  tagType() {
    return this.isParamReplaceable() ? "a" : "e";
  }
  /**
   * Get the tag that can be used to reference this event from another event.
   *
   * Consider using referenceTags() instead (unless you have a good reason to use this)
   *
   * @example
   *     event = new NDKEvent(ndk, { kind: 30000, pubkey: 'pubkey', tags: [ ["d", "d-code"] ] });
   *     event.tagReference(); // ["a", "30000:pubkey:d-code"]
   *
   *     event = new NDKEvent(ndk, { kind: 1, pubkey: 'pubkey', id: "eventid" });
   *     event.tagReference(); // ["e", "eventid"]
   * @returns {NDKTag} The NDKTag object referencing this event
   */
  tagReference(marker) {
    let tag;
    if (this.isParamReplaceable()) {
      tag = ["a", this.tagAddress()];
    } else {
      tag = ["e", this.tagId()];
    }
    if (this.relay) {
      tag.push(this.relay.url);
    } else {
      tag.push("");
    }
    tag.push(marker ?? "");
    if (!this.isParamReplaceable()) {
      tag.push(this.pubkey);
    }
    return tag;
  }
  /**
   * Get the tags that can be used to reference this event from another event
   * @param marker The marker to use in the tag
   * @param skipAuthorTag Whether to explicitly skip adding the author tag of the event
   * @param forceTag Force a specific tag to be used instead of the default "e" or "a" tag
   * @example
   *     event = new NDKEvent(ndk, { kind: 30000, pubkey: 'pubkey', tags: [ ["d", "d-code"] ] });
   *     event.referenceTags(); // [["a", "30000:pubkey:d-code"], ["e", "parent-id"]]
   *
   *     event = new NDKEvent(ndk, { kind: 1, pubkey: 'pubkey', id: "eventid" });
   *     event.referenceTags(); // [["e", "parent-id"]]
   * @returns {NDKTag} The NDKTag object referencing this event
   */
  referenceTags(marker, skipAuthorTag, forceTag) {
    let tags = [];
    if (this.isParamReplaceable()) {
      tags = [
        [forceTag ?? "a", this.tagAddress()],
        [forceTag ?? "e", this.id]
      ];
    } else {
      tags = [[forceTag ?? "e", this.id]];
    }
    tags = tags.map((tag) => {
      if (tag[0] === "e" || marker) {
        tag.push(this.relay?.url ?? "");
      } else if (this.relay?.url) {
        tag.push(this.relay?.url);
      }
      return tag;
    });
    tags.forEach((tag) => {
      if (tag[0] === "e") {
        tag.push(marker ?? "");
        tag.push(this.pubkey);
      } else if (marker) {
        tag.push(marker);
      }
    });
    tags = [...tags, ...this.getMatchingTags("h")];
    if (!skipAuthorTag) tags.push(...this.author.referenceTags());
    return tags;
  }
  /**
   * Provides the filter that will return matching events for this event.
   *
   * @example
   *    event = new NDKEvent(ndk, { kind: 30000, pubkey: 'pubkey', tags: [ ["d", "d-code"] ] });
   *    event.filter(); // { "#a": ["30000:pubkey:d-code"] }
   * @example
   *    event = new NDKEvent(ndk, { kind: 1, pubkey: 'pubkey', id: "eventid" });
   *    event.filter(); // { "#e": ["eventid"] }
   *
   * @returns The filter that will return matching events for this event
   */
  filter() {
    if (this.isParamReplaceable()) {
      return { "#a": [this.tagId()] };
    } else {
      return { "#e": [this.tagId()] };
    }
  }
  nip22Filter() {
    if (this.isParamReplaceable()) {
      return { "#A": [this.tagId()] };
    } else {
      return { "#E": [this.tagId()] };
    }
  }
  /**
   * Generates a deletion event of the current event
   *
   * @param reason The reason for the deletion
   * @param publish Whether to publish the deletion event automatically
   * @returns The deletion event
   */
  async delete(reason, publish = true) {
    if (!this.ndk) throw new Error("No NDK instance found");
    this.ndk.assertSigner();
    const e = new _NDKEvent(this.ndk, {
      kind: 5 /* EventDeletion */,
      content: reason || ""
    });
    e.tag(this, void 0, true);
    e.tags.push(["k", this.kind.toString()]);
    if (publish) {
      this.emit("deleted");
      await e.publish();
    }
    return e;
  }
  /**
   * Establishes whether this is a NIP-70-protectede event.
   * @@satisfies NIP-70
   */
  set isProtected(val) {
    this.removeTag("-");
    if (val) this.tags.push(["-"]);
  }
  /**
   * Whether this is a NIP-70-protectede event.
   * @@satisfies NIP-70
   */
  get isProtected() {
    return this.hasTag("-");
  }
  /**
   * Fetch an event tagged with the given tag following relay hints if provided.
   * @param tag The tag to search for
   * @param marker The marker to use in the tag (e.g. "root")
   * @returns The fetched event or null if no event was found, undefined if no matching tag was found in the event
   * * @example
   * const replyEvent = await ndk.fetchEvent("nevent1qqs8x8vnycyha73grv380gmvlury4wtmx0nr9a5ds2dngqwgu87wn6gpzemhxue69uhhyetvv9ujuurjd9kkzmpwdejhgq3ql2vyh47mk2p0qlsku7hg0vn29faehy9hy34ygaclpn66ukqp3afqz4cwjd")
   * const originalEvent = await replyEvent.fetchTaggedEvent("e", "reply");
   * console.log(replyEvent.encode() + " is a reply to event " + originalEvent?.encode());
   */
  fetchTaggedEvent = fetchTaggedEvent.bind(this);
  /**
   * Fetch the root event of the current event.
   * @returns The fetched root event or null if no event was found
   * @example
   * const replyEvent = await ndk.fetchEvent("nevent1qqs8x8vnycyha73grv380gmvlury4wtmx0nr9a5ds2dngqwgu87wn6gpzemhxue69uhhyetvv9ujuurjd9kkzmpwdejhgq3ql2vyh47mk2p0qlsku7hg0vn29faehy9hy34ygaclpn66ukqp3afqz4cwjd")
   * const rootEvent = await replyEvent.fetchRootEvent();
   * console.log(replyEvent.encode() + " is a reply in the thread " + rootEvent?.encode());
   */
  fetchRootEvent = fetchRootEvent.bind(this);
  /**
   * Fetch the event the current event is replying to.
   * @returns The fetched reply event or null if no event was found
   */
  fetchReplyEvent = fetchReplyEvent.bind(this);
  /**
   * NIP-18 reposting event.
   *
   * @param publish Whether to publish the reposted event automatically @default true
   * @param signer The signer to use for signing the reposted event
   * @returns The reposted event
   *
   * @function
   */
  repost = repost.bind(this);
  /**
   * React to an existing event
   *
   * @param content The content of the reaction
   */
  async react(content, publish = true) {
    if (!this.ndk) throw new Error("No NDK instance found");
    this.ndk.assertSigner();
    const e = new _NDKEvent(this.ndk, {
      kind: 7 /* Reaction */,
      content
    });
    e.tag(this);
    if (publish) await e.publish();
    return e;
  }
  /**
   * Checks whether the event is valid per underlying NIPs.
   *
   * This method is meant to be overridden by subclasses that implement specific NIPs
   * to allow the enforcement of NIP-specific validation rules.
   *
   * Otherwise, it will only check for basic event properties.
   *
   */
  get isValid() {
    return this.validate();
  }
  /**
   * Creates a reply event for the current event.
   * 
   * This function will use NIP-22 when appropriate (i.e. replies to non-kind:1 events).
   * This function does not have side-effects; it will just return an event with the appropriate tags
   * to generate the reply event; the caller is responsible for publishing the event.
   */
  reply() {
    const reply = new _NDKEvent(this.ndk);
    if (this.kind === 1) {
      reply.kind = 1;
      const opHasETag = this.hasTag("e");
      if (opHasETag) {
        reply.tags = [
          ...reply.tags,
          ...this.getMatchingTags("e"),
          ...this.getMatchingTags("p"),
          ...this.getMatchingTags("a"),
          ...this.referenceTags("reply")
        ];
      } else {
        reply.tag(this, "root");
      }
    } else {
      reply.kind = 1111 /* GenericReply */;
      const carryOverTags = ["A", "E", "I", "P"];
      const rootTags = this.tags.filter((tag) => carryOverTags.includes(tag[0]));
      if (rootTags.length > 0) {
        const rootKind = this.tagValue("K");
        reply.tags.push(...rootTags);
        if (rootKind) reply.tags.push(["K", rootKind]);
        const [type, id, _, ...extra] = this.tagReference();
        const tag = [type, id, ...extra];
        reply.tags.push(tag);
      } else {
        const [type, id, _, relayHint] = this.tagReference();
        const tag = [type, id, relayHint ?? ""];
        if (type === "e") tag.push(this.pubkey);
        reply.tags.push(tag);
        const uppercaseTag = [...tag];
        uppercaseTag[0] = uppercaseTag[0].toUpperCase();
        reply.tags.push(uppercaseTag);
        reply.tags.push(["K", this.kind.toString()]);
        reply.tags.push(["P", this.pubkey]);
      }
      reply.tags.push(["k", this.kind.toString()]);
      reply.tags.push(...this.getMatchingTags("p"));
      reply.tags.push(["p", this.pubkey]);
    }
    return reply;
  }
};
var untrackedUnpublishedEvents = /* @__PURE__ */ new Set([
  24133 /* NostrConnect */,
  13194 /* NostrWaletConnectInfo */,
  23194 /* NostrWalletConnectReq */,
  23195 /* NostrWalletConnectRes */
]);
function shouldTrackUnpublishedEvent(event) {
  return !untrackedUnpublishedEvents.has(event.kind);
}

// src/subscription/index.ts
import { EventEmitter as EventEmitter9 } from "tseep";

// src/subscription/utils.ts
import { nip19 as nip193 } from "nostr-tools";

// src/events/kinds/article.ts
var NDKArticle = class _NDKArticle extends NDKEvent {
  static kind = 30023 /* Article */;
  static kinds = [30023 /* Article */];
  constructor(ndk, rawEvent) {
    super(ndk, rawEvent);
    this.kind ??= 30023 /* Article */;
  }
  /**
   * Creates a NDKArticle from an existing NDKEvent.
   *
   * @param event NDKEvent to create the NDKArticle from.
   * @returns NDKArticle
   */
  static from(event) {
    return new _NDKArticle(event.ndk, event);
  }
  /**
   * Getter for the article title.
   *
   * @returns {string | undefined} - The article title if available, otherwise undefined.
   */
  get title() {
    return this.tagValue("title");
  }
  /**
   * Setter for the article title.
   *
   * @param {string | undefined} title - The title to set for the article.
   */
  set title(title) {
    this.removeTag("title");
    if (title) this.tags.push(["title", title]);
  }
  /**
   * Getter for the article image.
   *
   * @returns {string | undefined} - The article image if available, otherwise undefined.
   */
  get image() {
    return this.tagValue("image");
  }
  /**
   * Setter for the article image.
   *
   * @param {string | undefined} image - The image to set for the article.
   */
  set image(image) {
    this.removeTag("image");
    if (image) this.tags.push(["image", image]);
  }
  get summary() {
    return this.tagValue("summary");
  }
  set summary(summary) {
    this.removeTag("summary");
    if (summary) this.tags.push(["summary", summary]);
  }
  /**
   * Getter for the article's publication timestamp.
   *
   * @returns {number | undefined} - The Unix timestamp of when the article was published or undefined.
   */
  get published_at() {
    const tag = this.tagValue("published_at");
    if (tag) {
      let val = parseInt(tag);
      if (val > 1e12) {
        val = Math.floor(val / 1e3);
      }
      return val;
    }
    return void 0;
  }
  /**
   * Setter for the article's publication timestamp.
   *
   * @param {number | undefined} timestamp - The Unix timestamp to set for the article's publication date.
   */
  set published_at(timestamp) {
    this.removeTag("published_at");
    if (timestamp !== void 0) {
      this.tags.push(["published_at", timestamp.toString()]);
    }
  }
  /**
   * Generates content tags for the article.
   *
   * This method first checks and sets the publication date if not available,
   * and then generates content tags based on the base NDKEvent class.
   *
   * @returns {ContentTag} - The generated content tags.
   */
  async generateTags() {
    super.generateTags();
    if (!this.published_at) {
      this.published_at = this.created_at;
    }
    return super.generateTags();
  }
  /**
   * Getter for the article's URL.
   *
   * @returns {string | undefined} - The article's URL if available, otherwise undefined.
   */
  get url() {
    return this.tagValue("url");
  }
  /**
   * Setter for the article's URL.
   *
   * @param {string | undefined} url - The URL to set for the article.
   */
  set url(url) {
    if (url) {
      this.tags.push(["url", url]);
    } else {
      this.removeTag("url");
    }
  }
};

// src/relay/pool/index.ts
import { EventEmitter as EventEmitter3 } from "tseep";

// src/events/kinds/lists/index.ts
var NDKList = class _NDKList extends NDKEvent {
  _encryptedTags;
  static kinds = [
    10063 /* BlossomList */,
    30001 /* CategorizedBookmarkList */,
    10004 /* CommunityList */,
    10050 /* DirectMessageReceiveRelayList */,
    10030 /* EmojiList */,
    10015 /* InterestList */,
    10001 /* PinList */,
    10002 /* RelayList */,
    10007 /* SearchRelayList */,
    10006 /* BlockRelayList */,
    10003 /* BookmarkList */
  ];
  /**
   * Stores the number of bytes the content was before decryption
   * to expire the cache when the content changes.
   */
  encryptedTagsLength;
  constructor(ndk, rawEvent) {
    super(ndk, rawEvent);
    this.kind ??= 30001 /* CategorizedBookmarkList */;
  }
  /**
   * Wrap a NDKEvent into a NDKList
   */
  static from(ndkEvent) {
    return new _NDKList(ndkEvent.ndk, ndkEvent);
  }
  /**
   * Returns the title of the list. Falls back on fetching the name tag value.
   */
  get title() {
    const titleTag = this.tagValue("title") || this.tagValue("name");
    if (titleTag) return titleTag;
    if (this.kind === 3 /* Contacts */) {
      return "Contacts";
    } else if (this.kind === 1e4 /* MuteList */) {
      return "Mute";
    } else if (this.kind === 10001 /* PinList */) {
      return "Pinned Notes";
    } else if (this.kind === 10002 /* RelayList */) {
      return "Relay Metadata";
    } else if (this.kind === 10003 /* BookmarkList */) {
      return "Bookmarks";
    } else if (this.kind === 10004 /* CommunityList */) {
      return "Communities";
    } else if (this.kind === 10005 /* PublicChatList */) {
      return "Public Chats";
    } else if (this.kind === 10006 /* BlockRelayList */) {
      return "Blocked Relays";
    } else if (this.kind === 10007 /* SearchRelayList */) {
      return "Search Relays";
    } else if (this.kind === 10050 /* DirectMessageReceiveRelayList */) {
      return "Direct Message Receive Relays";
    } else if (this.kind === 10015 /* InterestList */) {
      return "Interests";
    } else if (this.kind === 10030 /* EmojiList */) {
      return "Emojis";
    } else {
      return this.tagValue("d");
    }
  }
  /**
   * Sets the title of the list.
   */
  set title(title) {
    this.removeTag(["title", "name"]);
    if (title) this.tags.push(["title", title]);
  }
  /**
   * Returns the name of the list.
   * @deprecated Please use "title" instead.
   */
  get name() {
    return this.title;
  }
  /**
   * Sets the name of the list.
   * @deprecated Please use "title" instead. This method will use the `title` tag instead.
   */
  set name(name) {
    this.title = name;
  }
  /**
   * Returns the description of the list.
   */
  get description() {
    return this.tagValue("description");
  }
  /**
   * Sets the description of the list.
   */
  set description(name) {
    this.removeTag("description");
    if (name) this.tags.push(["description", name]);
  }
  /**
   * Returns the image of the list.
   */
  get image() {
    return this.tagValue("image");
  }
  /**
   * Sets the image of the list.
   */
  set image(name) {
    this.removeTag("image");
    if (name) this.tags.push(["image", name]);
  }
  isEncryptedTagsCacheValid() {
    return !!(this._encryptedTags && this.encryptedTagsLength === this.content.length);
  }
  /**
   * Returns the decrypted content of the list.
   */
  async encryptedTags(useCache = true) {
    if (useCache && this.isEncryptedTagsCacheValid()) return this._encryptedTags;
    if (!this.ndk) throw new Error("NDK instance not set");
    if (!this.ndk.signer) throw new Error("NDK signer not set");
    const user = await this.ndk.signer.user();
    try {
      if (this.content.length > 0) {
        try {
          const decryptedContent = await this.ndk.signer.decrypt(user, this.content);
          const a = JSON.parse(decryptedContent);
          if (a && a[0]) {
            this.encryptedTagsLength = this.content.length;
            return this._encryptedTags = a;
          }
          this.encryptedTagsLength = this.content.length;
          return this._encryptedTags = [];
        } catch (e) {
          console.log(`error decrypting ${this.content}`);
        }
      }
    } catch (e) {
    }
    return [];
  }
  /**
   * This method can be overriden to validate that a tag is valid for this list.
   *
   * (i.e. the NDKPersonList can validate that items are NDKUser instances)
   */
  validateTag(tagValue) {
    return true;
  }
  getItems(type) {
    return this.tags.filter((tag) => tag[0] === type);
  }
  /**
   * Returns the unecrypted items in this list.
   */
  get items() {
    return this.tags.filter((t) => {
      return ![
        "d",
        "L",
        "l",
        "title",
        "name",
        "description",
        "published_at",
        "summary",
        "image",
        "thumb",
        "alt",
        "expiration",
        "subject",
        "client"
      ].includes(t[0]);
    });
  }
  /**
   * Adds a new item to the list.
   * @param relay Relay to add
   * @param mark Optional mark to add to the item
   * @param encrypted Whether to encrypt the item
   * @param position Where to add the item in the list (top or bottom)
   */
  async addItem(item, mark = void 0, encrypted = false, position = "bottom") {
    if (!this.ndk) throw new Error("NDK instance not set");
    if (!this.ndk.signer) throw new Error("NDK signer not set");
    let tags;
    if (item instanceof NDKEvent) {
      tags = [item.tagReference(mark)];
    } else if (item instanceof NDKUser) {
      tags = item.referenceTags();
    } else if (item instanceof NDKRelay) {
      tags = item.referenceTags();
    } else if (Array.isArray(item)) {
      tags = [item];
    } else {
      throw new Error("Invalid object type");
    }
    if (mark) tags[0].push(mark);
    if (encrypted) {
      const user = await this.ndk.signer.user();
      const currentList = await this.encryptedTags();
      if (position === "top") currentList.unshift(...tags);
      else currentList.push(...tags);
      this._encryptedTags = currentList;
      this.encryptedTagsLength = this.content.length;
      this.content = JSON.stringify(currentList);
      await this.encrypt(user);
    } else {
      if (position === "top") this.tags.unshift(...tags);
      else this.tags.push(...tags);
    }
    this.created_at = Math.floor(Date.now() / 1e3);
    this.emit("change");
  }
  /**
   * Removes an item from the list from both the encrypted and unencrypted lists.
   * @param value value of item to remove from the list
   * @param publish whether to publish the change
   * @returns
   */
  async removeItemByValue(value, publish = true) {
    if (!this.ndk) throw new Error("NDK instance not set");
    if (!this.ndk.signer) throw new Error("NDK signer not set");
    const index = this.tags.findIndex((tag) => tag[1] === value);
    if (index >= 0) {
      this.tags.splice(index, 1);
    }
    const user = await this.ndk.signer.user();
    const encryptedTags = await this.encryptedTags();
    const encryptedIndex = encryptedTags.findIndex((tag) => tag[1] === value);
    if (encryptedIndex >= 0) {
      encryptedTags.splice(encryptedIndex, 1);
      this._encryptedTags = encryptedTags;
      this.encryptedTagsLength = this.content.length;
      this.content = JSON.stringify(encryptedTags);
      await this.encrypt(user);
    }
    if (publish) {
      return this.publishReplaceable();
    } else {
      this.created_at = Math.floor(Date.now() / 1e3);
    }
    this.emit("change");
  }
  /**
   * Removes an item from the list.
   *
   * @param index The index of the item to remove.
   * @param encrypted Whether to remove from the encrypted list or not.
   */
  async removeItem(index, encrypted) {
    if (!this.ndk) throw new Error("NDK instance not set");
    if (!this.ndk.signer) throw new Error("NDK signer not set");
    if (encrypted) {
      const user = await this.ndk.signer.user();
      const currentList = await this.encryptedTags();
      currentList.splice(index, 1);
      this._encryptedTags = currentList;
      this.encryptedTagsLength = this.content.length;
      this.content = JSON.stringify(currentList);
      await this.encrypt(user);
    } else {
      this.tags.splice(index, 1);
    }
    this.created_at = Math.floor(Date.now() / 1e3);
    this.emit("change");
    return this;
  }
  has(item) {
    return this.items.some((tag) => tag[1] === item);
  }
  /**
   * Creates a filter that will result in fetching
   * the items of this list
   * @example
   * const list = new NDKList(...);
   * const filters = list.filterForItems();
   * const events = await ndk.fetchEvents(filters);
   */
  filterForItems() {
    const ids = /* @__PURE__ */ new Set();
    const nip33Queries = /* @__PURE__ */ new Map();
    const filters = [];
    for (const tag of this.items) {
      if (tag[0] === "e" && tag[1]) {
        ids.add(tag[1]);
      } else if (tag[0] === "a" && tag[1]) {
        const [kind, pubkey, dTag] = tag[1].split(":");
        if (!kind || !pubkey) continue;
        const key = `${kind}:${pubkey}`;
        const item = nip33Queries.get(key) || [];
        item.push(dTag || "");
        nip33Queries.set(key, item);
      }
    }
    if (ids.size > 0) {
      filters.push({ ids: Array.from(ids) });
    }
    if (nip33Queries.size > 0) {
      for (const [key, values] of nip33Queries.entries()) {
        const [kind, pubkey] = key.split(":");
        filters.push({
          kinds: [parseInt(kind)],
          authors: [pubkey],
          "#d": values
        });
      }
    }
    return filters;
  }
};

// src/events/kinds/highlight.ts
import { nip19 as nip194 } from "nostr-tools";
var NDKHighlight = class _NDKHighlight extends NDKEvent {
  _article;
  static kind = 9802 /* Highlight */;
  static kinds = [9802 /* Highlight */];
  constructor(ndk, rawEvent) {
    super(ndk, rawEvent);
    this.kind ??= 9802 /* Highlight */;
  }
  static from(event) {
    return new _NDKHighlight(event.ndk, event);
  }
  get url() {
    return this.tagValue("r");
  }
  /**
   * Context tag.
   */
  set context(context) {
    if (context === void 0) {
      this.tags = this.tags.filter(([tag, value]) => tag !== "context");
    } else {
      this.tags = this.tags.filter(([tag, value]) => tag !== "context");
      this.tags.push(["context", context]);
    }
  }
  get context() {
    return this.tags.find(([tag, value]) => tag === "context")?.[1] ?? void 0;
  }
  /**
   * Will return the article URL or NDKEvent if they have already been
   * set (it won't attempt to load remote events)
   */
  get article() {
    return this._article;
  }
  /**
   * Article the highlight is coming from.
   *
   * @param article Article URL or NDKEvent.
   */
  set article(article) {
    this._article = article;
    if (typeof article === "string") {
      this.tags.push(["r", article]);
    } else {
      this.tag(article);
    }
  }
  getArticleTag() {
    return this.getMatchingTags("a")[0] || this.getMatchingTags("e")[0] || this.getMatchingTags("r")[0];
  }
  async getArticle() {
    if (this._article !== void 0) return this._article;
    let taggedBech32;
    const articleTag = this.getArticleTag();
    if (!articleTag) return void 0;
    switch (articleTag[0]) {
      case "a":
        const [kind, pubkey, identifier] = articleTag[1].split(":");
        taggedBech32 = nip194.naddrEncode({ kind: parseInt(kind), pubkey, identifier });
        break;
      case "e":
        taggedBech32 = nip194.noteEncode(articleTag[1]);
        break;
      case "r":
        this._article = articleTag[1];
        break;
    }
    if (taggedBech32) {
      let a = await this.ndk?.fetchEvent(taggedBech32);
      if (a) {
        if (a.kind === 30023 /* Article */) {
          a = NDKArticle.from(a);
        }
        this._article = a;
      }
    }
    return this._article;
  }
};

// src/events/kinds/cashu/tx.ts
var MARKERS = {
  REDEEMED: "redeemed",
  CREATED: "created",
  DESTROYED: "destroyed",
  RESERVED: "reserved"
};
var NDKCashuWalletTx = class _NDKCashuWalletTx extends NDKEvent {
  static MARKERS = MARKERS;
  static kind = 7376 /* CashuWalletTx */;
  static kinds = [7376 /* CashuWalletTx */];
  constructor(ndk, event) {
    super(ndk, event);
    this.kind ??= 7376 /* CashuWalletTx */;
  }
  static async from(event) {
    const walletChange = new _NDKCashuWalletTx(event.ndk, event);
    const prevContent = walletChange.content;
    try {
      await walletChange.decrypt();
    } catch (e) {
      walletChange.content ??= prevContent;
    }
    try {
      const contentTags = JSON.parse(walletChange.content);
      walletChange.tags = [...contentTags, ...walletChange.tags];
    } catch (e) {
      return;
    }
    return walletChange;
  }
  set direction(direction) {
    this.removeTag("direction");
    if (direction) this.tags.push(["direction", direction]);
  }
  get direction() {
    return this.tagValue("direction");
  }
  set amount(amount) {
    this.removeTag("amount");
    this.tags.push(["amount", amount.toString()]);
  }
  get amount() {
    return this.tagValue("amount");
  }
  set fee(fee) {
    this.removeTag("fee");
    this.tags.push(["fee", fee.toString()]);
  }
  get fee() {
    return this.tagValue("fee");
  }
  set unit(unit) {
    this.removeTag("unit");
    if (unit) this.tags.push(["unit", unit.toString()]);
  }
  get unit() {
    return this.tagValue("unit");
  }
  set description(description) {
    this.removeTag("description");
    if (description) this.tags.push(["description", description.toString()]);
  }
  get description() {
    return this.tagValue("description");
  }
  set mint(mint) {
    this.removeTag("mint");
    if (mint) this.tags.push(["mint", mint.toString()]);
  }
  get mint() {
    return this.tagValue("mint");
  }
  /**
   * Tags tokens that were created in this history event
   */
  set destroyedTokens(events) {
    for (const event of events) {
      this.tags.push(event.tagReference(MARKERS.DESTROYED));
    }
  }
  set destroyedTokenIds(ids) {
    for (const id of ids) {
      this.tags.push(["e", id, "", MARKERS.DESTROYED]);
    }
  }
  /**
   * Tags tokens that were created in this history event
   */
  set createdTokens(events) {
    for (const event of events) {
      this.tags.push(event.tagReference(MARKERS.CREATED));
    }
  }
  set reservedTokens(events) {
    for (const event of events) {
      this.tags.push(event.tagReference(MARKERS.RESERVED));
    }
  }
  addRedeemedNutzap(event) {
    this.tag(event, MARKERS.REDEEMED);
  }
  async toNostrEvent(pubkey) {
    const encryptedTags = [];
    const unencryptedTags = [];
    for (const tag of this.tags) {
      if (!this.shouldEncryptTag(tag)) {
        unencryptedTags.push(tag);
      } else {
        encryptedTags.push(tag);
      }
    }
    this.tags = unencryptedTags.filter((t) => t[0] !== "client");
    this.content = JSON.stringify(encryptedTags);
    const user = await this.ndk.signer.user();
    await this.encrypt(user, void 0, "nip44");
    return super.toNostrEvent(pubkey);
  }
  /**
   * Whether this entry includes a redemption of a Nutzap
   */
  get hasNutzapRedemption() {
    return this.getMatchingTags("e", MARKERS.REDEEMED).length > 0;
  }
  shouldEncryptTag(tag) {
    const unencryptedTagNames = ["client"];
    if (unencryptedTagNames.includes(tag[0])) {
      return false;
    }
    if (tag[0] === "e" && tag[3] === MARKERS.REDEEMED) {
      return false;
    }
    if (tag[0] === "p") return false;
    return true;
  }
};

// src/utils/imeta.ts
function mapImetaTag(tag) {
  const data = {};
  if (tag.length === 2) {
    const parts = tag[1].split(" ");
    for (let i = 0; i < parts.length; i += 2) {
      const key = parts[i];
      const value = parts[i + 1];
      if (key === "fallback") {
        if (!data.fallback) data.fallback = [];
        data.fallback.push(value);
      } else {
        data[key] = value;
      }
    }
  }
  for (const val of tag) {
    const parts = val.split(" ");
    const key = parts[0];
    const value = parts.slice(1).join(" ");
    if (key === "fallback") {
      if (!data.fallback) data.fallback = [];
      data.fallback.push(value);
    } else {
      data[key] = value;
    }
  }
  return data;
}
function imetaTagToTag(imeta) {
  const tag = ["imeta"];
  for (const [key, value] of Object.entries(imeta)) {
    if (Array.isArray(value)) {
      for (const v of value) {
        tag.push(key, v);
      }
    } else if (value) {
      tag.push(key, value);
    }
  }
  return tag;
}

// src/events/kinds/image.ts
var NDKImage = class _NDKImage extends NDKEvent {
  static kind = 20 /* Image */;
  static kinds = [20 /* Image */];
  _imetas;
  constructor(ndk, rawEvent) {
    super(ndk, rawEvent);
    this.kind ??= 20 /* Image */;
  }
  /**
   * Creates a NDKImage from an existing NDKEvent.
   *
   * @param event NDKEvent to create the NDKImage from.
   * @returns NDKImage
   */
  static from(event) {
    return new _NDKImage(event.ndk, event.rawEvent());
  }
  get isValid() {
    return this.imetas.length > 0;
  }
  get imetas() {
    if (this._imetas) return this._imetas;
    this._imetas = this.tags.filter((tag) => tag[0] === "imeta").map(mapImetaTag).filter((imeta) => !!imeta.url);
    return this._imetas;
  }
  set imetas(tags) {
    this._imetas = tags;
    this.tags = this.tags.filter((tag) => tag[0] !== "imeta");
    this.tags.push(...tags.map(imetaTagToTag));
  }
};

// src/events/kinds/nutzap/index.ts
import debug2 from "debug";
var NDKNutzap = class _NDKNutzap extends NDKEvent {
  debug;
  _proofs = [];
  static kind = 9321 /* Nutzap */;
  static kinds = [_NDKNutzap.kind];
  constructor(ndk, event) {
    super(ndk, event);
    this.kind ??= 9321 /* Nutzap */;
    this.debug = ndk?.debug.extend("nutzap") ?? debug2("ndk:nutzap");
    if (!this.alt) this.alt = "This is a nutzap";
  }
  static from(event) {
    const e = new this(event.ndk, event);
    try {
      const proofTags = e.getMatchingTags("proof");
      if (proofTags.length) {
        e._proofs = proofTags.map((tag) => JSON.parse(tag[1]));
      } else {
        e._proofs = JSON.parse(e.content);
      }
    } catch {
      return;
    }
    if (!e._proofs || !e._proofs.length) return;
    return e;
  }
  set comment(comment) {
    this.content = comment ?? "";
  }
  get comment() {
    const c = this.tagValue("comment");
    if (c) return c;
    return this.content;
  }
  set proofs(proofs) {
    this._proofs = proofs;
    this.tags = this.tags.filter((tag) => tag[0] !== "proof");
    for (const proof of proofs) {
      this.tags.push(["proof", JSON.stringify(proof)]);
    }
  }
  get proofs() {
    return this._proofs;
  }
  /**
   * Gets the p2pk pubkey that is embedded in the first proof
   */
  get p2pk() {
    const firstProof = this.proofs[0];
    try {
      const secret = JSON.parse(firstProof.secret);
      let payload = {};
      if (typeof secret === "string") {
        payload = JSON.parse(secret);
        this.debug("stringified payload", firstProof.secret);
      } else if (typeof secret === "object") {
        payload = secret;
      }
      const isP2PKLocked = payload[0] === "P2PK" && payload[1]?.data;
      if (isP2PKLocked) {
        const paddedp2pk = payload[1].data;
        const p2pk = paddedp2pk.slice(2);
        if (p2pk) return p2pk;
      }
    } catch (e) {
      this.debug("error parsing p2pk pubkey", e, this.proofs[0]);
    }
  }
  /**
   * Get the mint where this nutzap proofs exist
   */
  get mint() {
    return this.tagValue("u");
  }
  set mint(value) {
    this.removeTag("u");
    this.tag(["u", value]);
  }
  get unit() {
    return this.tagValue("unit") ?? "sat";
  }
  set unit(value) {
    this.removeTag("unit");
    if (value) this.tag(["unit", value]);
  }
  get amount() {
    const amount = this.proofs.reduce((total, proof) => total + proof.amount, 0);
    if (this.unit === "msat") return amount * 1e3;
    return amount;
  }
  sender = this.author;
  /**
   * Set the target of the nutzap
   * @param target The target of the nutzap (a user or an event)
   */
  set target(target) {
    this.tags = this.tags.filter((t) => t[0] !== "p");
    if (target instanceof NDKEvent) {
      this.tags.push(target.tagReference());
    }
  }
  set recipientPubkey(pubkey) {
    this.removeTag("p");
    this.tag(["p", pubkey]);
  }
  get recipientPubkey() {
    return this.tagValue("p");
  }
  get recipient() {
    const pubkey = this.recipientPubkey;
    if (this.ndk) return this.ndk.getUser({ pubkey });
    return new NDKUser({ pubkey });
  }
  async toNostrEvent() {
    if (this.unit === "msat") {
      this.unit = "sat";
    }
    this.removeTag("amount");
    this.tags.push(["amount", this.amount.toString()]);
    const event = await super.toNostrEvent();
    event.content = this.comment;
    return event;
  }
  /**
   * Validates that the nutzap conforms to NIP-61
   */
  get isValid() {
    let eTagCount = 0;
    let pTagCount = 0;
    let mintTagCount = 0;
    for (const tag of this.tags) {
      if (tag[0] === "e") eTagCount++;
      if (tag[0] === "p") pTagCount++;
      if (tag[0] === "u") mintTagCount++;
    }
    return (
      // exactly one recipient and mint
      pTagCount === 1 && mintTagCount === 1 && // must have at most one e tag
      eTagCount <= 1 && // must have at least one proof
      this.proofs.length > 0
    );
  }
};

// src/events/kinds/nutzap/mint-list.ts
var NDKCashuMintList = class _NDKCashuMintList extends NDKEvent {
  static kind = 10019 /* CashuMintList */;
  static kinds = [10019 /* CashuMintList */];
  _p2pk;
  constructor(ndk, event) {
    super(ndk, event);
    this.kind ??= 10019 /* CashuMintList */;
  }
  static from(event) {
    return new _NDKCashuMintList(event.ndk, event);
  }
  set relays(urls) {
    this.tags = this.tags.filter((t) => t[0] !== "relay");
    for (const url of urls) {
      this.tags.push(["relay", url]);
    }
  }
  get relays() {
    const r = [];
    for (const tag of this.tags) {
      if (tag[0] === "relay") {
        r.push(tag[1]);
      }
    }
    return r;
  }
  set mints(urls) {
    this.tags = this.tags.filter((t) => t[0] !== "mint");
    for (const url of urls) {
      this.tags.push(["mint", url]);
    }
  }
  get mints() {
    const r = [];
    for (const tag of this.tags) {
      if (tag[0] === "mint") {
        r.push(tag[1]);
      }
    }
    return Array.from(new Set(r));
  }
  get p2pk() {
    if (this._p2pk) {
      return this._p2pk;
    }
    this._p2pk = this.tagValue("pubkey") ?? this.pubkey;
    return this._p2pk;
  }
  set p2pk(pubkey) {
    this._p2pk = pubkey;
    this.removeTag("pubkey");
    if (pubkey) {
      this.tags.push(["pubkey", pubkey]);
    }
  }
  get relaySet() {
    return NDKRelaySet.fromRelayUrls(this.relays, this.ndk);
  }
};

// src/events/kinds/subscriptions/amount.ts
var possibleIntervalFrequencies = [
  "daily",
  "weekly",
  "monthly",
  "quarterly",
  "yearly"
];
function newAmount(amount, currency, term) {
  return ["amount", amount.toString(), currency, term];
}
function parseTagToSubscriptionAmount(tag) {
  const amount = parseInt(tag[1]);
  if (isNaN(amount) || amount === void 0 || amount === null || amount <= 0) return void 0;
  const currency = tag[2];
  if (currency === void 0 || currency === "") return void 0;
  const term = tag[3];
  if (term === void 0) return void 0;
  if (!possibleIntervalFrequencies.includes(term)) return void 0;
  return {
    amount,
    currency,
    term
  };
}

// src/events/kinds/subscriptions/receipt.ts
import debug3 from "debug";

// src/events/kinds/subscriptions/subscription-start.ts
import debug4 from "debug";

// src/events/kinds/subscriptions/tier.ts
var NDKSubscriptionTier = class _NDKSubscriptionTier extends NDKArticle {
  static kind = 37001 /* SubscriptionTier */;
  static kinds = [37001 /* SubscriptionTier */];
  constructor(ndk, rawEvent) {
    const k = rawEvent?.kind ?? 37001 /* SubscriptionTier */;
    super(ndk, rawEvent);
    this.kind = k;
  }
  /**
   * Creates a new NDKSubscriptionTier from an event
   * @param event
   * @returns NDKSubscriptionTier
   */
  static from(event) {
    return new _NDKSubscriptionTier(event.ndk, event);
  }
  /**
   * Returns perks for this tier
   */
  get perks() {
    return this.getMatchingTags("perk").map((tag) => tag[1]).filter((perk) => perk !== void 0);
  }
  /**
   * Adds a perk to this tier
   */
  addPerk(perk) {
    this.tags.push(["perk", perk]);
  }
  /**
   * Returns the amount for this tier
   */
  get amounts() {
    return this.getMatchingTags("amount").map((tag) => parseTagToSubscriptionAmount(tag)).filter((a) => a !== void 0);
  }
  /**
   * Adds an amount to this tier
   * @param amount Amount in the smallest unit of the currency (e.g. cents, msats)
   * @param currency Currency code. Use msat for millisatoshis
   * @param term One of daily, weekly, monthly, quarterly, yearly
   */
  addAmount(amount, currency, term) {
    this.tags.push(newAmount(amount, currency, term));
  }
  /**
   * Sets a relay where content related to this tier can be found
   * @param relayUrl URL of the relay
   */
  set relayUrl(relayUrl) {
    this.tags.push(["r", relayUrl]);
  }
  /**
   * Returns the relay URLs for this tier
   */
  get relayUrls() {
    return this.getMatchingTags("r").map((tag) => tag[1]).filter((relay) => relay !== void 0);
  }
  /**
   * Gets the verifier pubkey for this tier. This is the pubkey that will generate
   * subscription payment receipts
   */
  get verifierPubkey() {
    return this.tagValue("p");
  }
  /**
   * Sets the verifier pubkey for this tier.
   */
  set verifierPubkey(pubkey) {
    this.removeTag("p");
    if (pubkey) this.tags.push(["p", pubkey]);
  }
  /**
   * Checks if this tier is valid
   */
  get isValid() {
    return this.title !== void 0 && // Must have a title
    this.amounts.length > 0;
  }
};

// src/events/kinds/video.ts
var NDKVideo = class _NDKVideo extends NDKEvent {
  static kind = 34235 /* HorizontalVideo */;
  static kinds = [34235 /* HorizontalVideo */, 34236 /* VerticalVideo */];
  _imetas;
  constructor(ndk, rawEvent) {
    super(ndk, rawEvent);
    this.kind ??= 34235 /* HorizontalVideo */;
  }
  /**
   * Creates a NDKArticle from an existing NDKEvent.
   *
   * @param event NDKEvent to create the NDKArticle from.
   * @returns NDKArticle
   */
  static from(event) {
    return new _NDKVideo(event.ndk, event.rawEvent());
  }
  /**
   * Getter for the article title.
   *
   * @returns {string | undefined} - The article title if available, otherwise undefined.
   */
  get title() {
    return this.tagValue("title");
  }
  /**
   * Setter for the article title.
   *
   * @param {string | undefined} title - The title to set for the article.
   */
  set title(title) {
    this.removeTag("title");
    if (title) this.tags.push(["title", title]);
  }
  /**
   * Getter for the article thumbnail.
   *
   * @returns {string | undefined} - The article thumbnail if available, otherwise undefined.
   */
  get thumbnail() {
    let thumbnail;
    if (this.imetas && this.imetas.length > 0) {
      thumbnail = this.imetas[0].image?.[0];
    }
    return thumbnail ?? this.tagValue("thumb");
  }
  get imetas() {
    if (this._imetas) return this._imetas;
    this._imetas = this.tags.filter((tag) => tag[0] === "imeta").map(mapImetaTag);
    return this._imetas;
  }
  set imetas(tags) {
    this._imetas = tags;
    this.tags = this.tags.filter((tag) => tag[0] !== "imeta");
    this.tags.push(...tags.map(imetaTagToTag));
  }
  get url() {
    if (this.imetas && this.imetas.length > 0) {
      return this.imetas[0].url;
    }
    return this.tagValue("url");
  }
  /**
   * Getter for the article's publication timestamp.
   *
   * @returns {number | undefined} - The Unix timestamp of when the article was published or undefined.
   */
  get published_at() {
    const tag = this.tagValue("published_at");
    if (tag) {
      return parseInt(tag);
    }
    return void 0;
  }
  /**
   * Setter for the article's publication timestamp.
   *
   * @param {number | undefined} timestamp - The Unix timestamp to set for the article's publication date.
   */
  set published_at(timestamp) {
    this.removeTag("published_at");
    if (timestamp !== void 0) {
      this.tags.push(["published_at", timestamp.toString()]);
    }
  }
  /**
   * Generates content tags for the article.
   *
   * This method first checks and sets the publication date if not available,
   * and then generates content tags based on the base NDKEvent class.
   *
   * @returns {ContentTag} - The generated content tags.
   */
  async generateTags() {
    super.generateTags();
    if (!this.published_at) {
      this.published_at = this.created_at;
    }
    return super.generateTags();
  }
  get duration() {
    const tag = this.tagValue("duration");
    if (tag) {
      return parseInt(tag);
    }
    return void 0;
  }
  /**
   * Setter for the video's duration
   *
   * @param {number | undefined} duration - The duration to set for the video (in seconds)
   */
  set duration(dur) {
    this.removeTag("duration");
    if (dur !== void 0) {
      this.tags.push(["duration", Math.floor(dur).toString()]);
    }
  }
};

// src/events/kinds/wiki.ts
var NDKWiki = class extends NDKArticle {
  static kind = 30818 /* Wiki */;
  static kinds = [30818 /* Wiki */];
};

// src/events/kinds/simple-group/member-list.ts
var NDKSimpleGroupMemberList = class _NDKSimpleGroupMemberList extends NDKEvent {
  relaySet;
  memberSet = /* @__PURE__ */ new Set();
  static kind = 39002 /* GroupMembers */;
  static kinds = [39002 /* GroupMembers */];
  constructor(ndk, rawEvent) {
    super(ndk, rawEvent);
    this.kind ??= 39002 /* GroupMembers */;
    this.memberSet = new Set(this.members);
  }
  static from(event) {
    return new _NDKSimpleGroupMemberList(event.ndk, event);
  }
  get members() {
    return this.getMatchingTags("p").map((tag) => tag[1]);
  }
  hasMember(member) {
    return this.memberSet.has(member);
  }
  async publish(relaySet, timeoutMs, requiredRelayCount) {
    relaySet ??= this.relaySet;
    return super.publishReplaceable(relaySet, timeoutMs, requiredRelayCount);
  }
};

// src/events/kinds/simple-group/metadata.ts
var NDKSimpleGroupMetadata = class _NDKSimpleGroupMetadata extends NDKEvent {
  static kind = 39e3 /* GroupMetadata */;
  static kinds = [39e3 /* GroupMetadata */];
  constructor(ndk, rawEvent) {
    super(ndk, rawEvent);
    this.kind ??= 39e3 /* GroupMetadata */;
  }
  static from(event) {
    return new _NDKSimpleGroupMetadata(event.ndk, event);
  }
  get name() {
    return this.tagValue("name");
  }
  get picture() {
    return this.tagValue("picture");
  }
  get about() {
    return this.tagValue("about");
  }
  get scope() {
    if (this.getMatchingTags("public").length > 0) return "public";
    if (this.getMatchingTags("public").length > 0) return "private";
  }
  set scope(scope) {
    this.removeTag("public");
    this.removeTag("private");
    if (scope === "public") {
      this.tags.push(["public", ""]);
    } else if (scope === "private") {
      this.tags.push(["private", ""]);
    }
  }
  get access() {
    if (this.getMatchingTags("open").length > 0) return "open";
    if (this.getMatchingTags("closed").length > 0) return "closed";
  }
  set access(access) {
    this.removeTag("open");
    this.removeTag("closed");
    if (access === "open") {
      this.tags.push(["open", ""]);
    } else if (access === "closed") {
      this.tags.push(["closed", ""]);
    }
  }
};

// src/relay/auth-policies.ts
import createDebug2 from "debug";

// src/signers/nip07/index.ts
import debug5 from "debug";

// src/signers/nip46/rpc.ts
import { EventEmitter as EventEmitter4 } from "tseep";

// src/signers/nip46/backend/index.ts
import { hexToBytes } from "@noble/hashes/utils";

// src/signers/nip46/index.ts
import { EventEmitter as EventEmitter5 } from "tseep";

// src/user/profile.ts
function profileFromEvent(event) {
  const profile = {};
  let payload;
  try {
    payload = JSON.parse(event.content);
  } catch (error) {
    throw new Error(`Failed to parse profile event: ${error}`);
  }
  profile.created_at = event.created_at;
  profile.profileEvent = JSON.stringify(event.rawEvent());
  Object.keys(payload).forEach((key) => {
    switch (key) {
      case "name":
        profile.name = payload.name;
        break;
      case "display_name":
        profile.displayName = payload.display_name;
        break;
      case "image":
      case "picture":
        profile.picture = payload.picture || payload.image;
        profile.image = profile.picture;
        break;
      case "banner":
        profile.banner = payload.banner;
        break;
      case "bio":
        profile.bio = payload.bio;
        break;
      case "nip05":
        profile.nip05 = payload.nip05;
        break;
      case "lud06":
        profile.lud06 = payload.lud06;
        break;
      case "lud16":
        profile.lud16 = payload.lud16;
        break;
      case "about":
        profile.about = payload.about;
        break;
      case "website":
        profile.website = payload.website;
        break;
      default:
        profile[key] = payload[key];
        break;
    }
  });
  return profile;
}
function serializeProfile(profile) {
  const payload = {};
  for (const [key, val] of Object.entries(profile)) {
    switch (key) {
      case "username":
      case "name":
        payload.name = val;
        break;
      case "displayName":
        payload.display_name = val;
        break;
      case "image":
      case "picture":
        payload.picture = val;
        break;
      case "bio":
      case "about":
        payload.about = val;
        break;
      default:
        payload[key] = val;
        break;
    }
  }
  return JSON.stringify(payload);
}

// src/ndk/index.ts
import debug7 from "debug";
import { EventEmitter as EventEmitter7 } from "tseep";

// src/outbox/tracker.ts
import { EventEmitter as EventEmitter6 } from "tseep";
import { LRUCache as LRUCache2 } from "typescript-lru-cache";

// src/subscription/manager.ts
import { matchFilters } from "nostr-tools";

// src/ndk/active-user.ts
import createDebug3 from "debug";
var debug6 = createDebug3("ndk:active-user");

// src/zap/invoice.ts
import { decode } from "light-bolt11-decoder";

// src/zapper/index.ts
import createDebug5 from "debug";
import { EventEmitter as EventEmitter8 } from "tseep";

// src/zapper/nip57.ts
import { nip57 } from "nostr-tools";

// src/zapper/ln.ts
import { bech32 } from "@scure/base";
import createDebug4 from "debug";
var d2 = createDebug4("ndk:zapper:ln");

// src/zapper/index.ts
var d3 = createDebug5("ndk:zapper");

// src/events/kinds/cashu/token.ts
function proofsTotalBalance(proofs) {
  return proofs.reduce((acc, proof) => {
    if (proof.amount < 0) {
      throw new Error("proof amount is negative");
    }
    return acc + proof.amount;
  }, 0);
}
var NDKCashuToken = class _NDKCashuToken extends NDKEvent {
  _proofs = [];
  _mint;
  static kind = 7375 /* CashuToken */;
  static kinds = [7375 /* CashuToken */];
  /**
   * Tokens that this token superseeds
   */
  _deletes = [];
  original;
  constructor(ndk, event) {
    super(ndk, event);
    this.kind ??= 7375 /* CashuToken */;
  }
  static async from(event) {
    const token = new _NDKCashuToken(event.ndk, event);
    token.original = event;
    try {
      await token.decrypt();
    } catch {
      token.content = token.original.content;
    }
    try {
      const content = JSON.parse(token.content);
      token.proofs = content.proofs;
      token.mint = content.mint ?? token.tagValue("mint");
      token.deletedTokens = content.del ?? [];
      if (!Array.isArray(token.proofs)) return;
    } catch (e) {
      return;
    }
    return token;
  }
  get proofs() {
    return this._proofs;
  }
  set proofs(proofs) {
    const cs = /* @__PURE__ */ new Set();
    this._proofs = proofs.filter((proof) => {
      if (cs.has(proof.C)) {
        console.warn("Passed in proofs had duplicates, ignoring", proof.C);
        return false;
      }
      if (proof.amount < 0) {
        console.warn("Invalid proof with negative amount", proof);
        return false;
      }
      cs.add(proof.C);
      return true;
    }).map(this.cleanProof);
  }
  /**
   * Returns a minimal proof object with only essential properties
   */
  cleanProof(proof) {
    return {
      id: proof.id,
      amount: proof.amount,
      C: proof.C,
      secret: proof.secret
    };
  }
  async toNostrEvent(pubkey) {
    const payload = {
      proofs: this.proofs.map(this.cleanProof),
      mint: this.mint,
      del: this.deletedTokens ?? []
    };
    this.content = JSON.stringify(payload);
    const user = await this.ndk.signer.user();
    await this.encrypt(user, void 0, "nip44");
    return super.toNostrEvent(pubkey);
  }
  set mint(mint) {
    this._mint = mint;
  }
  get mint() {
    return this._mint;
  }
  /**
   * Tokens that were deleted by the creation of this token.
   */
  get deletedTokens() {
    return this._deletes;
  }
  /**
   * Marks tokens that were deleted by the creation of this token.
   */
  set deletedTokens(tokenIds) {
    this._deletes = tokenIds;
  }
  get amount() {
    return proofsTotalBalance(this.proofs);
  }
  async publish(relaySet, timeoutMs, requiredRelayCount) {
    if (this.original) {
      return this.original.publish(relaySet, timeoutMs, requiredRelayCount);
    } else {
      return super.publish(relaySet, timeoutMs, requiredRelayCount);
    }
  }
};

// src/user/follows.ts
async function follows(opts, outbox, kind = 3 /* Contacts */) {
  if (!this.ndk) throw new Error("NDK not set");
  const contactListEvent = await this.ndk.fetchEvent(
    { kinds: [kind], authors: [this.pubkey] },
    opts || { groupable: false }
  );
  if (contactListEvent) {
    const pubkeys = /* @__PURE__ */ new Set();
    contactListEvent.tags.forEach((tag) => {
      if (tag[0] === "p") pubkeys.add(tag[1]);
    });
    if (outbox) {
      this.ndk?.outboxTracker?.trackUsers(Array.from(pubkeys));
    }
    return [...pubkeys].reduce((acc, pubkey) => {
      const user = new NDKUser({ pubkey });
      user.ndk = this.ndk;
      acc.add(user);
      return acc;
    }, /* @__PURE__ */ new Set());
  }
  return /* @__PURE__ */ new Set();
}

// src/user/nip05.ts
var NIP05_REGEX = /^(?:([\w.+-]+)@)?([\w.-]+)$/;
async function getNip05For(ndk, fullname, _fetch = fetch, fetchOpts = {}) {
  return await ndk.queuesNip05.add({
    id: fullname,
    func: async () => {
      if (ndk.cacheAdapter && ndk.cacheAdapter.loadNip05) {
        const profile = await ndk.cacheAdapter.loadNip05(fullname);
        if (profile !== "missing") {
          if (profile) {
            const user = new NDKUser({
              pubkey: profile.pubkey,
              relayUrls: profile.relays,
              nip46Urls: profile.nip46
            });
            user.ndk = ndk;
            return user;
          } else if (fetchOpts.cache !== "no-cache") {
            return null;
          }
        }
      }
      const match = fullname.match(NIP05_REGEX);
      if (!match) return null;
      const [_, name = "_", domain] = match;
      try {
        const res = await _fetch(
          `https://${domain}/.well-known/nostr.json?name=${name}`,
          fetchOpts
        );
        const { names, relays, nip46 } = parseNIP05Result(await res.json());
        const pubkey = names[name.toLowerCase()];
        let profile = null;
        if (pubkey) {
          profile = { pubkey, relays: relays?.[pubkey], nip46: nip46?.[pubkey] };
        }
        if (ndk?.cacheAdapter && ndk.cacheAdapter.saveNip05) {
          ndk.cacheAdapter.saveNip05(fullname, profile);
        }
        return profile;
      } catch (_e) {
        if (ndk?.cacheAdapter && ndk.cacheAdapter.saveNip05) {
          ndk?.cacheAdapter.saveNip05(fullname, null);
        }
        console.error("Failed to fetch NIP05 for", fullname, _e);
        return null;
      }
    }
  });
}
function parseNIP05Result(json) {
  const result = {
    names: {}
  };
  for (const [name, pubkey] of Object.entries(json.names)) {
    if (typeof name === "string" && typeof pubkey === "string") {
      result.names[name.toLowerCase()] = pubkey;
    }
  }
  if (json.relays) {
    result.relays = {};
    for (const [pubkey, relays] of Object.entries(json.relays)) {
      if (typeof pubkey === "string" && Array.isArray(relays)) {
        result.relays[pubkey] = relays.filter(
          (relay) => typeof relay === "string"
        );
      }
    }
  }
  if (json.nip46) {
    result.nip46 = {};
    for (const [pubkey, nip46] of Object.entries(json.nip46)) {
      if (typeof pubkey === "string" && Array.isArray(nip46)) {
        result.nip46[pubkey] = nip46.filter((relay) => typeof relay === "string");
      }
    }
  }
  return result;
}

// src/user/index.ts
var NDKUser = class _NDKUser {
  ndk;
  profile;
  profileEvent;
  _npub;
  _pubkey;
  relayUrls = [];
  nip46Urls = [];
  constructor(opts) {
    if (opts.npub) this._npub = opts.npub;
    if (opts.hexpubkey) this._pubkey = opts.hexpubkey;
    if (opts.pubkey) this._pubkey = opts.pubkey;
    if (opts.relayUrls) this.relayUrls = opts.relayUrls;
    if (opts.nip46Urls) this.nip46Urls = opts.nip46Urls;
  }
  get npub() {
    if (!this._npub) {
      if (!this._pubkey) throw new Error("pubkey not set");
      this._npub = nip195.npubEncode(this.pubkey);
    }
    return this._npub;
  }
  get nprofile() {
    const relays = this.profileEvent?.onRelays?.map((r) => r.url);
    return nip195.nprofileEncode({
      pubkey: this.pubkey,
      relays
    });
  }
  set npub(npub) {
    this._npub = npub;
  }
  /**
   * Get the user's pubkey
   * @returns {string} The user's pubkey
   */
  get pubkey() {
    if (!this._pubkey) {
      if (!this._npub) throw new Error("npub not set");
      this._pubkey = nip195.decode(this.npub).data;
    }
    return this._pubkey;
  }
  /**
   * Set the user's pubkey
   * @param pubkey {string} The user's pubkey
   */
  set pubkey(pubkey) {
    this._pubkey = pubkey;
  }
  /**
   * Equivalent to NDKEvent.filters().
   * @returns {NDKFilter}
   */
  filter() {
    return { "#p": [this.pubkey] };
  }
  /**
   * Gets NIP-57 and NIP-61 information that this user has signaled
   *
   * @param getAll {boolean} Whether to get all zap info or just the first one
   */
  async getZapInfo(timeoutMs) {
    if (!this.ndk) throw new Error("No NDK instance found");
    const promiseWithTimeout = async (promise) => {
      if (!timeoutMs) return promise;
      try {
        return await Promise.race([
          promise,
          new Promise((_, reject) => setTimeout(() => reject(), timeoutMs))
        ]);
      } catch {
        return void 0;
      }
    };
    const [userProfile, mintListEvent] = await Promise.all([
      promiseWithTimeout(this.fetchProfile()),
      promiseWithTimeout(this.ndk.fetchEvent({ kinds: [10019 /* CashuMintList */], authors: [this.pubkey] }))
    ]);
    const res = /* @__PURE__ */ new Map();
    if (mintListEvent) {
      const mintList = NDKCashuMintList.from(mintListEvent);
      if (mintList.mints.length > 0) {
        res.set("nip61", {
          mints: mintList.mints,
          relays: mintList.relays,
          p2pk: mintList.p2pk
        });
      }
    }
    if (userProfile) {
      const { lud06, lud16 } = userProfile;
      res.set("nip57", { lud06, lud16 });
    }
    return res;
  }
  /**
   * Instantiate an NDKUser from a NIP-05 string
   * @param nip05Id {string} The user's NIP-05
   * @param ndk {NDK} An NDK instance
   * @param skipCache {boolean} Whether to skip the cache or not
   * @returns {NDKUser | undefined} An NDKUser if one is found for the given NIP-05, undefined otherwise.
   */
  static async fromNip05(nip05Id, ndk, skipCache = false) {
    if (!ndk) throw new Error("No NDK instance found");
    const opts = {};
    if (skipCache) opts.cache = "no-cache";
    const profile = await getNip05For(ndk, nip05Id, ndk?.httpFetch, opts);
    if (profile) {
      const user = new _NDKUser({
        pubkey: profile.pubkey,
        relayUrls: profile.relays,
        nip46Urls: profile.nip46
      });
      user.ndk = ndk;
      return user;
    }
  }
  /**
   * Fetch a user's profile
   * @param opts {NDKSubscriptionOptions} A set of NDKSubscriptionOptions
   * @param storeProfileEvent {boolean} Whether to store the profile event or not
   * @returns User Profile
   */
  async fetchProfile(opts, storeProfileEvent = false) {
    if (!this.ndk) throw new Error("NDK not set");
    if (!this.profile) this.profile = {};
    let setMetadataEvent = null;
    if (this.ndk.cacheAdapter && this.ndk.cacheAdapter.fetchProfile && opts?.cacheUsage !== "ONLY_RELAY" /* ONLY_RELAY */) {
      const profile = await this.ndk.cacheAdapter.fetchProfile(this.pubkey);
      if (profile) {
        this.profile = profile;
        return profile;
      }
    }
    if (!opts && // if no options have been set
    this.ndk.cacheAdapter && // and we have a cache
    this.ndk.cacheAdapter.locking) {
      setMetadataEvent = await this.ndk.fetchEvent(
        {
          kinds: [0],
          authors: [this.pubkey]
        },
        {
          cacheUsage: "ONLY_CACHE" /* ONLY_CACHE */,
          closeOnEose: true,
          groupable: false
        }
      );
      opts = {
        cacheUsage: "ONLY_RELAY" /* ONLY_RELAY */,
        closeOnEose: true,
        groupable: true,
        groupableDelay: 250
      };
    }
    if (!setMetadataEvent) {
      setMetadataEvent = await this.ndk.fetchEvent(
        {
          kinds: [0],
          authors: [this.pubkey]
        },
        opts
      );
    }
    if (!setMetadataEvent) return null;
    this.profile = profileFromEvent(setMetadataEvent);
    if (storeProfileEvent) {
      this.profile.profileEvent = JSON.stringify(setMetadataEvent);
    }
    if (this.profile && this.ndk.cacheAdapter && this.ndk.cacheAdapter.saveProfile) {
      this.ndk.cacheAdapter.saveProfile(this.pubkey, this.profile);
    }
    return this.profile;
  }
  /**
   * Returns a set of users that this user follows.
   * 
   * @deprecated Use followSet instead
   */
  follows = follows.bind(this);
  /**
   * Returns a set of pubkeys that this user follows.
   * 
   * @param opts - NDKSubscriptionOptions
   * @param outbox - boolean
   * @param kind - number
   */
  async followSet(opts, outbox, kind = 3 /* Contacts */) {
    const follows2 = await this.follows(opts, outbox, kind);
    return new Set(Array.from(follows2).map((f) => f.pubkey));
  }
  /** @deprecated Use referenceTags instead. */
  /**
   * Get the tag that can be used to reference this user in an event
   * @returns {NDKTag} an NDKTag
   */
  tagReference() {
    return ["p", this.pubkey];
  }
  /**
   * Get the tags that can be used to reference this user in an event
   * @returns {NDKTag[]} an array of NDKTag
   */
  referenceTags(marker) {
    const tag = [["p", this.pubkey]];
    if (!marker) return tag;
    tag[0].push("", marker);
    return tag;
  }
  /**
   * Publishes the current profile.
   */
  async publish() {
    if (!this.ndk) throw new Error("No NDK instance found");
    if (!this.profile) throw new Error("No profile available");
    this.ndk.assertSigner();
    const event = new NDKEvent(this.ndk, {
      kind: 0,
      content: serializeProfile(this.profile)
    });
    await event.publish();
  }
  /**
   * Add a follow to this user's contact list
   *
   * @param newFollow {NDKUser} The user to follow
   * @param currentFollowList {Set<NDKUser>} The current follow list
   * @param kind {NDKKind} The kind to use for this contact list (defaults to `3`)
   * @returns {Promise<boolean>} True if the follow was added, false if the follow already exists
   */
  async follow(newFollow, currentFollowList, kind = 3 /* Contacts */) {
    if (!this.ndk) throw new Error("No NDK instance found");
    this.ndk.assertSigner();
    if (!currentFollowList) {
      currentFollowList = await this.follows(void 0, void 0, kind);
    }
    if (currentFollowList.has(newFollow)) {
      return false;
    }
    currentFollowList.add(newFollow);
    const event = new NDKEvent(this.ndk, { kind });
    for (const follow of currentFollowList) {
      event.tag(follow);
    }
    await event.publish();
    return true;
  }
  /**
   * Remove a follow from this user's contact list
   *
   * @param user {NDKUser} The user to unfollow
   * @param currentFollowList {Set<NDKUser>} The current follow list
   * @param kind {NDKKind} The kind to use for this contact list (defaults to `3`)
   * @returns The relays were the follow list was published or false if the user wasn't found
   */
  async unfollow(user, currentFollowList, kind = 3 /* Contacts */) {
    if (!this.ndk) throw new Error("No NDK instance found");
    this.ndk.assertSigner();
    if (!currentFollowList) {
      currentFollowList = await this.follows(void 0, void 0, kind);
    }
    const newUserFollowList = /* @__PURE__ */ new Set();
    let foundUser = false;
    for (const follow of currentFollowList) {
      if (follow.pubkey !== user.pubkey) {
        newUserFollowList.add(follow);
      } else {
        foundUser = true;
      }
    }
    if (!foundUser) return false;
    const event = new NDKEvent(this.ndk, { kind });
    for (const follow of newUserFollowList) {
      event.tag(follow);
    }
    return await event.publish();
  }
  /**
   * Validate a user's NIP-05 identifier (usually fetched from their kind:0 profile data)
   *
   * @param nip05Id The NIP-05 string to validate
   * @returns {Promise<boolean | null>} True if the NIP-05 is found and matches this user's pubkey,
   * False if the NIP-05 is found but doesn't match this user's pubkey,
   * null if the NIP-05 isn't found on the domain or we're unable to verify (because of network issues, etc.)
   */
  async validateNip05(nip05Id) {
    if (!this.ndk) throw new Error("No NDK instance found");
    const profilePointer = await getNip05For(this.ndk, nip05Id);
    if (profilePointer === null) return null;
    return profilePointer.pubkey === this.pubkey;
  }
};

// src/signers/private-key/index.ts
import { bytesToHex as bytesToHex2, hexToBytes as hexToBytes2 } from "@noble/hashes/utils";
import { nip19 as nip196 } from "nostr-tools";
var NDKPrivateKeySigner = class _NDKPrivateKeySigner {
  _user;
  _privateKey;
  constructor(privateKey) {
    if (privateKey) {
      if (typeof privateKey === "string") {
        if (privateKey.startsWith("nsec1")) {
          const { type, data } = nip196.decode(privateKey);
          if (type === "nsec") this._privateKey = data;
        } else if (privateKey.length === 64) {
          this._privateKey = hexToBytes2(privateKey);
        } else {
          throw new Error("Invalid private key provided.");
        }
      } else {
        this._privateKey = privateKey;
      }
      if (this._privateKey) {
        this._user = new NDKUser({
          pubkey: getPublicKey(this._privateKey)
        });
      }
    }
  }
  get privateKey() {
    if (!this._privateKey) return void 0;
    return bytesToHex2(this._privateKey);
  }
  static generate() {
    const privateKey = generateSecretKey();
    return new _NDKPrivateKeySigner(privateKey);
  }
  async blockUntilReady() {
    if (!this._user) {
      throw new Error("NDKUser not initialized");
    }
    return this._user;
  }
  async user() {
    await this.blockUntilReady();
    return this._user;
  }
  async sign(event) {
    if (!this._privateKey) {
      throw Error("Attempted to sign without a private key");
    }
    return finalizeEvent(event, this._privateKey).sig;
  }
  async encryptionEnabled(scheme) {
    let enabled = [];
    if (!scheme || scheme == "nip04") enabled.push("nip04");
    if (!scheme || scheme == "nip44") enabled.push("nip44");
    return enabled;
  }
  async encrypt(recipient, value, scheme) {
    if (!this._privateKey || !this.privateKey) {
      throw Error("Attempted to encrypt without a private key");
    }
    const recipientHexPubKey = recipient.pubkey;
    if (scheme == "nip44") {
      let conversationKey = nip44.v2.utils.getConversationKey(this._privateKey, recipientHexPubKey);
      return await nip44.v2.encrypt(value, conversationKey);
    }
    return await nip04.encrypt(this._privateKey, recipientHexPubKey, value);
  }
  async decrypt(sender, value, scheme) {
    if (!this._privateKey || !this.privateKey) {
      throw Error("Attempted to decrypt without a private key");
    }
    const senderHexPubKey = sender.pubkey;
    if (scheme == "nip44") {
      let conversationKey = nip44.v2.utils.getConversationKey(this._privateKey, senderHexPubKey);
      return await nip44.v2.decrypt(value, conversationKey);
    }
    return await nip04.decrypt(this._privateKey, senderHexPubKey, value);
  }
};

// test/utils/nutzaps/index.ts
async function mockNutzap(mint, amount, ndk, {
  senderPk = NDKPrivateKeySigner.generate(),
  recipientPubkey,
  content = ""
} = {}) {
  if (!recipientPubkey) {
    ndk.assertSigner();
    recipientPubkey = (await ndk.signer.user()).pubkey;
  }
  const nutzap = new NDKNutzap(ndk);
  nutzap.mint = mint;
  nutzap.proofs = [
    mockProof(mint, amount, recipientPubkey)
  ];
  nutzap.content = content;
  await nutzap.sign(senderPk);
  return nutzap;
}
function mockProof(C, amount, p2pk) {
  const proof = {
    C,
    amount,
    id: "mint",
    secret: Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15)
  };
  if (p2pk) {
    proof.secret = JSON.stringify([
      "P2PK",
      {
        nonce: "4eb3d1430af5e2663634af4ff80a394cfe1d377d41ab34d6d92e03cb3f2cdc8c",
        data: "02" + p2pk
      }
    ]);
  }
  return proof;
}
export {
  mockNutzap,
  mockProof
};
