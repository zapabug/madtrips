{"version":3,"file":"static/chunks/298-cc139b66c32143f7.js","mappings":"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","sources":["webpack://_N_E/./src/lib/nostr/nip47.ts","webpack://_N_E/./src/lib/nostr/nip47-payments.ts","webpack://_N_E/./src/lib/contexts/NostrContext.tsx"],"sourcesContent":["/**\n * NIP-47 Remote Signer Client Implementation\n * This provides a working implementation for connecting to Nostr Connect (NIP-47) signers\n */\n\nimport { finalizeEvent, nip04, nip19, generateSecretKey, getPublicKey, type Event } from 'nostr-tools';\nimport { v4 as uuidv4 } from 'uuid';\n\n// Interface for NIP-47 request\nexport interface NIP47Request {\n  id: string;\n  method: string;\n  params: any;\n}\n\n// Interface for NIP-47 response\nexport interface NIP47Response {\n  id: string;\n  result?: any;\n  error?: {\n    code: number;\n    message: string;\n  };\n}\n\n// Payment-specific interfaces\ninterface PaymentRequest {\n  method: 'pay_invoice';\n  params: {\n    invoice: string;\n  };\n}\n\ninterface PaymentResponse {\n  result?: {\n    preimage: string;\n    paymentHash: string;\n  };\n  error?: {\n    code: number;\n    message: string;\n  };\n}\n\nexport class NIP47Client {\n  private remoteUrl: string;\n  private relayUrl?: string;\n  private clientPrivkey: Uint8Array;\n  private clientPubkey: string;\n  private remotePubkey: string;\n  private connectionEstablished: boolean = false;\n  private pendingRequests: Map<string, { resolve: (value: any) => void, reject: (reason: any) => void }> = new Map();\n  private timeout: number = 30000; // 30 seconds timeout for requests\n\n  /**\n   * Create a new NIP-47 client\n   * @param remoteUrl - The remote signer URL (nostrconnect:// URL or similar)\n   * @param relayUrl - Optional relay URL for communication\n   */\n  constructor(remoteUrl: string, relayUrl?: string) {\n    // Parse the remote URL\n    if (remoteUrl.startsWith('nostrconnect://')) {\n      try {\n        const url = new URL(remoteUrl);\n        this.remotePubkey = url.pathname.substring(1); // Remove leading slash\n        \n        // Get relay URL from params if not provided\n        if (!relayUrl && url.searchParams.has('relay')) {\n          this.relayUrl = url.searchParams.get('relay') || undefined;\n        } else {\n          this.relayUrl = relayUrl;\n        }\n      } catch (e) {\n        throw new Error('Invalid NIP-47 remote URL format');\n      }\n    } else if (remoteUrl.startsWith('npub1')) {\n      // Assume it's a direct npub\n      try {\n        const decoded = nip19.decode(remoteUrl);\n        if (decoded.type !== 'npub') {\n          throw new Error('Invalid NIP-47 remote pubkey format');\n        }\n        this.remotePubkey = decoded.data;\n        this.relayUrl = relayUrl;\n      } catch (e) {\n        throw new Error('Invalid NIP-47 remote pubkey format');\n      }\n    } else {\n      // Assume it's a hex pubkey\n      this.remotePubkey = remoteUrl;\n      this.relayUrl = relayUrl;\n    }\n\n    // Generate a keypair for this client if needed\n    this.clientPrivkey = generateSecretKey();\n    this.clientPubkey = getPublicKey(this.clientPrivkey);\n    this.remoteUrl = remoteUrl;\n  }\n\n  /**\n   * Get the client's public key\n   */\n  getClientPubkey(): string {\n    return this.clientPubkey;\n  }\n\n  /**\n   * Get the remote signer's public key\n   */\n  getRemotePubkey(): string {\n    return this.remotePubkey;\n  }\n\n  /**\n   * Check if connected to the remote signer\n   */\n  isConnected(): boolean {\n    return this.connectionEstablished;\n  }\n\n  /**\n   * Generate a unique request ID\n   */\n  private generateRequestId(): string {\n    return uuidv4();\n  }\n\n  /**\n   * Encrypt a message for the remote signer\n   */\n  async encryptForRemote(content: string): Promise<string> {\n    try {\n      return await nip04.encrypt(this.clientPrivkey, this.remotePubkey, content);\n    } catch (error) {\n      console.error('Failed to encrypt message:', error);\n      throw new Error('Encryption failed');\n    }\n  }\n\n  /**\n   * Decrypt a message from the remote signer\n   */\n  async decryptFromRemote(ciphertext: string): Promise<string> {\n    try {\n      return await nip04.decrypt(this.clientPrivkey, this.remotePubkey, ciphertext);\n    } catch (error) {\n      console.error('Failed to decrypt message:', error);\n      throw new Error('Decryption failed');\n    }\n  }\n\n  /**\n   * Send a request to the remote signer\n   */\n  async sendRequest(method: string, params: any = {}): Promise<any> {\n    if (!this.connectionEstablished) {\n      throw new Error('Not connected to remote signer');\n    }\n\n    const requestId = this.generateRequestId();\n    const request: NIP47Request = {\n      id: requestId,\n      method,\n      params\n    };\n\n    // Create a promise that will be resolved/rejected when the response is received\n    const responsePromise = new Promise((resolve, reject) => {\n      this.pendingRequests.set(requestId, { resolve, reject });\n\n      // Set a timeout for the request\n      setTimeout(() => {\n        if (this.pendingRequests.has(requestId)) {\n          this.pendingRequests.delete(requestId);\n          reject(new Error(`Request timeout after ${this.timeout}ms`));\n        }\n      }, this.timeout);\n    });\n\n    try {\n      // Encrypt the request\n      const encryptedContent = await this.encryptForRemote(JSON.stringify(request));\n\n      // In a real implementation, you would:\n      // 1. Create a Nostr event with the encrypted content\n      // 2. Publish it to the relays\n      console.log(`Sending NIP-47 request: ${method}`);\n      \n      // For development/testing, we'll simulate a response\n      this.simulateResponseFromRemote(requestId, method, params);\n\n      // Wait for the response\n      return await responsePromise;\n    } catch (error) {\n      if (this.pendingRequests.has(requestId)) {\n        this.pendingRequests.delete(requestId);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Process a response from the remote signer (for real implementation)\n   */\n  async processResponse(event: Event): Promise<void> {\n    try {\n      // Decrypt the content\n      const decryptedContent = await this.decryptFromRemote(event.content);\n      \n      // Parse the response\n      const response: NIP47Response = JSON.parse(decryptedContent);\n      \n      // Find the pending request\n      const pendingRequest = this.pendingRequests.get(response.id);\n      if (!pendingRequest) {\n        console.warn(`Received response for unknown request ID: ${response.id}`);\n        return;\n      }\n      \n      // Remove from pending requests\n      this.pendingRequests.delete(response.id);\n      \n      // Resolve or reject the promise\n      if (response.error) {\n        pendingRequest.reject(new Error(`Remote error (${response.error.code}): ${response.error.message}`));\n      } else {\n        pendingRequest.resolve(response.result);\n      }\n    } catch (error) {\n      console.error('Failed to process response:', error);\n    }\n  }\n\n  /**\n   * Simulate a response from the remote signer (for development/testing)\n   * This is only used for testing and demonstration purposes\n   */\n  private simulateResponseFromRemote(requestId: string, method: string, params: any): void {\n    // In a real implementation, this would be removed and the actual response\n    // would come from the remote signer via relays\n    setTimeout(async () => {\n      const pendingRequest = this.pendingRequests.get(requestId);\n      if (!pendingRequest) return;\n      \n      try {\n        let result: any;\n        \n        switch (method) {\n          case 'get_public_key':\n            result = this.remotePubkey;\n            break;\n          case 'sign_event':\n            // Simulate signing by returning the event with a valid-looking signature\n            // In a real implementation, this would be signed by the remote signer\n            result = { ...params.event, sig: '00'.repeat(32) };\n            break;\n          case 'connect':\n            result = { approved: true };\n            break;\n          case 'pay_invoice':\n            // Simulate payment by returning a fake preimage\n            result = { preimage: '00'.repeat(16) };\n            break;\n          default:\n            throw new Error(`Unsupported method: ${method}`);\n        }\n        \n        pendingRequest.resolve(result);\n      } catch (error) {\n        pendingRequest.reject(error);\n      } finally {\n        this.pendingRequests.delete(requestId);\n      }\n    }, 1000); // Simulate a 1-second delay\n  }\n\n  /**\n   * Connect to the remote signer\n   */\n  async connect(): Promise<void> {\n    // For the basic implementation, we just validate the inputs\n    if (!this.remotePubkey) {\n      throw new Error('Remote pubkey is required');\n    }\n    \n    // In a real implementation, we'd establish a connection via relays\n    console.log(`Connecting to remote signer: ${this.remotePubkey} via ${this.relayUrl || 'default relays'}`);\n    \n    try {\n      // Send a connect request (in a real implementation)\n      // await this.sendRequest('connect', {\n      //   name: 'MadTrips App',\n      //   url: 'https://madtrips.com'\n      // });\n      \n      // For now, we'll just simulate a successful connection\n      await new Promise(resolve => setTimeout(resolve, 500));\n      \n      this.connectionEstablished = true;\n      console.log('Connected to remote signer successfully');\n    } catch (error) {\n      console.error('Failed to connect to remote signer:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get the public key from the remote signer\n   */\n  async getPublicKey(): Promise<string> {\n    if (!this.connectionEstablished) {\n      throw new Error('Not connected to remote signer');\n    }\n    \n    try {\n      // Send a get_public_key request\n      const result = await this.sendRequest('get_public_key');\n      return result;\n    } catch (error) {\n      console.error('Failed to get public key from remote signer:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Sign an event using the remote signer\n   */\n  async signEvent(event: any): Promise<any> {\n    if (!this.connectionEstablished) {\n      throw new Error('Not connected to remote signer');\n    }\n    \n    try {\n      // Send a sign_event request\n      const result = await this.sendRequest('sign_event', { event });\n      return result;\n    } catch (error) {\n      console.error('Failed to sign event with remote signer:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Encrypt a message using NIP-04\n   */\n  async encrypt(pubkey: string, plaintext: string): Promise<string> {\n    if (!this.connectionEstablished) {\n      throw new Error('Not connected to remote signer');\n    }\n    \n    try {\n      // Send an encrypt request\n      const result = await this.sendRequest('nip04_encrypt', { \n        pubkey, \n        plaintext \n      });\n      return result;\n    } catch (error) {\n      console.error('Failed to encrypt with remote signer:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Decrypt a message using NIP-04\n   */\n  async decrypt(pubkey: string, ciphertext: string): Promise<string> {\n    if (!this.connectionEstablished) {\n      throw new Error('Not connected to remote signer');\n    }\n    \n    try {\n      // Send a decrypt request\n      const result = await this.sendRequest('nip04_decrypt', { \n        pubkey, \n        ciphertext \n      });\n      return result;\n    } catch (error) {\n      console.error('Failed to decrypt with remote signer:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get information about the signer wallet\n   */\n  async getInfo(): Promise<any> {\n    if (!this.connectionEstablished) {\n      throw new Error('Not connected to remote signer');\n    }\n    \n    try {\n      // Send a get_info request\n      const result = await this.sendRequest('get_info');\n      return result;\n    } catch (error) {\n      console.error('Failed to get wallet info from remote signer:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get the wallet balance\n   */\n  async getBalance(): Promise<{ balance: number, currency: string }> {\n    if (!this.connectionEstablished) {\n      throw new Error('Not connected to remote signer');\n    }\n    \n    try {\n      // Send a get_balance request\n      const result = await this.sendRequest('get_balance');\n      return result;\n    } catch (error) {\n      console.error('Failed to get balance from remote signer:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Pay a Lightning invoice\n   * @param invoice BOLT11 Lightning invoice to pay\n   * @returns Payment result with preimage and payment hash\n   */\n  async payInvoice(invoice: string): Promise<{ preimage: string, paymentHash: string }> {\n    if (!this.connectionEstablished) {\n      throw new Error('Not connected to remote signer');\n    }\n    \n    try {\n      console.log('Sending payment request for invoice:', invoice.substring(0, 30) + '...');\n      \n      // Send a pay_invoice request\n      const result = await this.sendRequest('pay_invoice', { invoice });\n      \n      console.log('Payment successful:', result);\n      return result;\n    } catch (error) {\n      console.error('Payment failed:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Create a payment request event\n   * This method helps create a properly formatted payment request\n   * following the NIP-47 specification\n   */\n  async createPaymentRequestEvent(invoice: string): Promise<Event> {\n    if (!this.connectionEstablished) {\n      throw new Error('Not connected to remote signer');\n    }\n    \n    // Create the payment request\n    const requestId = this.generateRequestId();\n    const request: NIP47Request & PaymentRequest = {\n      id: requestId,\n      method: 'pay_invoice',\n      params: {\n        invoice\n      }\n    };\n    \n    // Encrypt the request content\n    const encryptedContent = await this.encryptForRemote(JSON.stringify(request));\n    \n    // Create the Nostr event\n    const event: any = {\n      kind: 24133, // NIP-47 request event kind\n      created_at: Math.floor(Date.now() / 1000),\n      tags: [\n        ['p', this.remotePubkey]\n      ],\n      content: encryptedContent,\n      pubkey: this.clientPubkey\n    };\n    \n    // The event should be signed, but in this case we'll return it unsigned\n    // as it would typically be signed by the application\n    return event;\n  }\n\n  /**\n   * Process a payment response event\n   * This method decrypts and processes a payment response from the remote signer\n   */\n  async processPaymentResponse(event: Event): Promise<PaymentResponse> {\n    try {\n      // Decrypt the content\n      const decryptedContent = await this.decryptFromRemote(event.content);\n      \n      // Parse the response\n      const response: PaymentResponse = JSON.parse(decryptedContent);\n      return response;\n    } catch (error) {\n      console.error('Failed to process payment response:', error);\n      throw new Error('Invalid payment response');\n    }\n  }\n\n  /**\n   * Get additional capabilities from the remote signer\n   */\n  async getCapabilities(): Promise<string[]> {\n    if (!this.connectionEstablished) {\n      throw new Error('Not connected to remote signer');\n    }\n    \n    try {\n      // Send a get_capabilities request\n      const result = await this.sendRequest('get_capabilities');\n      return result || [];\n    } catch (error) {\n      console.error('Failed to get capabilities from remote signer:', error);\n      // Not fatal, just return an empty array\n      return [];\n    }\n  }\n\n  /**\n   * Disconnect from the remote signer\n   */\n  disconnect(): void {\n    this.connectionEstablished = false;\n    \n    // Clear any pending requests\n    for (const [id, { reject }] of this.pendingRequests) {\n      reject(new Error('Disconnected from remote signer'));\n      this.pendingRequests.delete(id);\n    }\n    \n    console.log('Disconnected from remote signer');\n  }\n} ","import { NIP47Client } from './nip47';\nimport { Event, type Filter } from 'nostr-tools';\nimport { v4 as uuidv4 } from 'uuid';\n\n/**\n * NIP-47 Payment Request and Response handling\n * Based on https://github.com/gudnuf/nip47\n */\n\n// Payment request types\nexport interface PaymentRequest {\n  method: 'pay_invoice';\n  params: {\n    invoice: string;\n  };\n}\n\n// Payment response types\nexport interface PaymentResponse {\n  result?: {\n    preimage: string;\n  };\n  error?: {\n    code: number;\n    message: string;\n  };\n}\n\nexport class NIP47PaymentClient {\n  private client: NIP47Client;\n  \n  constructor(client: NIP47Client) {\n    this.client = client;\n  }\n\n  /**\n   * Create and send a payment request for a Lightning invoice\n   * @param invoice - The Lightning invoice to pay\n   * @returns The payment response\n   */\n  async payInvoice(invoice: string): Promise<PaymentResponse> {\n    try {\n      if (!invoice || !invoice.startsWith('ln')) {\n        throw new Error('Invalid Lightning invoice format');\n      }\n\n      console.log('Creating payment request for invoice:', invoice.substring(0, 15) + '...');\n      \n      // Create the payment request\n      const request: PaymentRequest = {\n        method: 'pay_invoice',\n        params: {\n          invoice\n        }\n      };\n\n      // Use the underlying NIP47Client to send the request\n      const response = await this.client.sendRequest(request.method, request.params);\n      \n      // Return the formatted response\n      return {\n        result: response as { preimage: string }\n      };\n    } catch (error) {\n      console.error('Payment request failed:', error);\n      \n      // Format error response\n      return {\n        error: {\n          code: error instanceof Error && 'code' in error ? (error as any).code : -1,\n          message: error instanceof Error ? error.message : String(error)\n        }\n      };\n    }\n  }\n\n  /**\n   * Get a filter to listen for payment responses\n   * This generates a filter that can be used with NDK subscriptions\n   * @param requestId - Optional specific request ID to filter for\n   * @returns A Nostr filter object\n   */\n  getPaymentResponseFilter(requestId?: string): Filter {\n    const filter: Filter = {\n      kinds: [24133], // NIP-47 response kind\n      '#p': [this.client.getClientPubkey()],\n    };\n    \n    if (requestId) {\n      filter['#e'] = [requestId];\n    }\n    \n    return filter;\n  }\n\n  /**\n   * Process a payment response event\n   * @param event - The Nostr event containing the payment response\n   * @returns The decoded payment response\n   */\n  async processPaymentResponse(event: Event): Promise<PaymentResponse> {\n    try {\n      // Decrypt the content\n      const decryptedContent = await this.client.decryptFromRemote(event.content);\n      \n      // Parse the response\n      const response = JSON.parse(decryptedContent);\n      \n      return response;\n    } catch (error) {\n      console.error('Failed to process payment response:', error);\n      \n      return {\n        error: {\n          code: -1,\n          message: 'Failed to process payment response'\n        }\n      };\n    }\n  }\n\n  /**\n   * Check payment status for the user\n   * This is a utility method to check if the user can make payments\n   * @returns A status object indicating payment capability\n   */\n  async checkPaymentCapability(): Promise<{ canPay: boolean, reason?: string }> {\n    try {\n      // Check if the client is connected\n      if (!this.client.isConnected()) {\n        return { canPay: false, reason: 'Not connected to remote signer' };\n      }\n      \n      // Check capabilities to see if pay_invoice is supported\n      const capabilities = await this.client.getCapabilities();\n      \n      if (!capabilities.includes('pay_invoice')) {\n        return { canPay: false, reason: 'Remote signer does not support payments' };\n      }\n      \n      return { canPay: true };\n    } catch (error) {\n      console.error('Failed to check payment capability:', error);\n      return { \n        canPay: false, \n        reason: error instanceof Error ? error.message : 'Unknown error checking payment capability'\n      };\n    }\n  }\n} ","'use client';\n\nimport React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';\nimport NDK, { NDKEvent, NDKUser, NDKFilter, NDKSubscription, NostrEvent } from '@nostr-dev-kit/ndk';\nimport { NDKNip07Signer } from '@nostr-dev-kit/ndk';\nimport { nip19 } from 'nostr-tools';\nimport { NIP47Client } from '@/lib/nostr/nip47';\nimport { NIP47PaymentClient } from '@/lib/nostr/nip47-payments';\nimport { NDKNip46Signer } from '@nostr-dev-kit/ndk';\n\n// Utility function to shorten npub for display\nexport const shortenNpub = (npub: string): string => {\n  if (!npub) return '';\n  return `${npub.substring(0, 8)}...${npub.substring(npub.length - 4)}`;\n};\n\n// List of predefined profiles for view only mode\nexport const PREDEFINED_PROFILES: ViewOnlyProfile[] = [\n  {\n    // MadTrips official profile\n    pubkey: '9a0a16254ff0dd29bbe45aeea9b8d80c0b9537d879a93f2589bbacedc4db166e', \n    npub: 'npub14jrvanj69ulfxc92pqsunvv220xhwtn6pukpmgpqzg6xl6wmaflqnx6nvs',\n    name: 'MadTrips_Official',\n    displayName: 'MadTrips (View Only)',\n    picture: '/assets/nostr-icon-purple-transparent-256x256.png'\n  }\n];\n\n// Define types for our context\ninterface ViewOnlyProfile {\n  pubkey: string;\n  npub: string;\n  name?: string;\n  displayName?: string;\n  picture?: string;\n}\n\ntype LoginMethod = 'nip07' | 'nip47' | 'viewonly';\n\ninterface NostrContextType {\n  ndk: NDK | null;\n  user: NDKUser | null;\n  loading: boolean;\n  error: Error | null;\n  loginMethod: LoginMethod | null;\n  viewOnlyProfile: ViewOnlyProfile | null;\n  availableProfiles: ViewOnlyProfile[];\n  login: (method: LoginMethod, options?: any) => Promise<void>;\n  logout: () => void;\n  getUserProfile: (npub: string) => Promise<NDKUser | null>;\n  getFollows: (npub: string) => Promise<string[]>;\n  shortenNpub: (npub: string) => string;\n  payInvoice?: (invoice: string) => Promise<any>;\n  canMakePayments: boolean;\n  getSocialGraph: (npubs: string[], maxConnections?: number) => Promise<{nodes: any[], links: any[]}>;\n}\n\n// Create the context\nconst NostrContext = createContext<NostrContextType | undefined>(undefined);\n\n// Provider component\nexport const NostrProvider: React.FC<{children: ReactNode}> = ({ children }) => {\n  const [ndk, setNdk] = useState<NDK | null>(null);\n  const [user, setUser] = useState<NDKUser | null>(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<Error | null>(null);\n  const [loginMethod, setLoginMethod] = useState<LoginMethod | null>(null);\n  const [viewOnlyProfile, setViewOnlyProfile] = useState<ViewOnlyProfile | null>(null);\n  const [nip47Client, setNip47Client] = useState<NIP47Client | null>(null);\n  const [paymentClient, setPaymentClient] = useState<NIP47PaymentClient | null>(null);\n  const [canMakePayments, setCanMakePayments] = useState(false);\n\n  // Initialize NDK on component mount\n  useEffect(() => {\n    const initializeNDK = async () => {\n      try {\n        // Check if window is defined (only in browser)\n        if (typeof window !== 'undefined') {\n          // Create a new NDK instance without a signer initially\n          const ndk = new NDK({\n            explicitRelayUrls: [\n              'wss://relay.damus.io',\n              'wss://relay.nostr.band',\n              'wss://nos.lol',\n              'wss://relay.current.fyi',\n              'wss://relay.snort.social',\n            ]\n          });\n\n          // Connect to relays\n          await ndk.connect();\n          setNdk(ndk);\n          console.log('NDK initialized without signer');\n          setLoading(false);\n        }\n      } catch (e) {\n        console.error('Failed to initialize NDK:', e);\n        setError(e as Error);\n        setLoading(false);\n      }\n    };\n\n    initializeNDK();\n  }, []);\n\n  // Login function that handles different methods\n  const login = async (method: LoginMethod, options?: any) => {\n    if (!ndk) {\n      throw new Error('NDK not initialized');\n    }\n\n    setLoading(true);\n    setError(null);\n    \n    try {\n      switch (method) {\n        case 'nip07': {\n          // Browser extension login (NIP-07)\n          if (typeof window === 'undefined' || !window.nostr) {\n            throw new Error('No NIP-07 compatible browser extension found');\n          }\n          \n          // Create a signer that uses the window.nostr API (extension)\n          ndk.signer = new NDKNip07Signer();\n          \n          // Get the user's public key\n          const publicKey = await ndk.signer.user();\n          \n          if (!publicKey) {\n            throw new Error('Failed to get public key from extension');\n          }\n          \n          // Create an NDKUser from the public key\n          const user = ndk.getUser({ npub: publicKey.npub });\n          \n          // Fetch the user's profile\n          await user.fetchProfile();\n          \n          setUser(user);\n          setLoginMethod('nip07');\n          setViewOnlyProfile(null);\n          console.log('NIP-07 login successful:', user.npub);\n          setCanMakePayments(false); // NIP-07 can't make payments by default\n          break;\n        }\n        \n        case 'nip47': {\n          // Remote signer login (NIP-47)\n          if (!options || !options.target) {\n            throw new Error('NIP-47 connection requires a target URL');\n          }\n\n          console.log('NIP-47 login requested to:', options.target);\n          \n          // For future implementation, we've created a NIP-47 client in @/lib/nostr/nip47.ts\n          // but are providing a simplified implementation here for now\n          \n          try {\n            // For demo purposes, we'll create a read-only profile from the target\n            let npub = options.target;\n            \n            // If the target is a nostrconnect:// URL, extract the npub\n            if (npub.startsWith('nostrconnect://')) {\n              const url = new URL(npub);\n              npub = url.pathname.substring(1); // Remove leading slash\n              if (npub.startsWith('npub1')) {\n                // Use as is\n              } else {\n                // Convert hex to npub if needed\n                npub = nip19.npubEncode(npub);\n              }\n            } else if (!npub.startsWith('npub1')) {\n              // If it's a hex key, convert to npub\n              npub = nip19.npubEncode(npub);\n            }\n            \n            // Create an NDKUser from the pubkey\n            const user = ndk.getUser({ npub });\n            \n            // Create NIP-47 client\n            const client = new NIP47Client(options.target);\n            \n            // Connect to the remote signer\n            await client.connect();\n            \n            // Get the public key\n            const remotePubkey = await client.getPublicKey();\n            \n            // Create the payment client\n            const payments = new NIP47PaymentClient(client);\n            \n            // Check if payments are supported\n            const paymentStatus = await payments.checkPaymentCapability();\n            \n            // Store the clients for later use\n            setNip47Client(client);\n            setPaymentClient(payments);\n            setCanMakePayments(paymentStatus.canPay);\n            \n            // Attempt to fetch profile data\n            try {\n              await user.fetchProfile();\n            } catch (e) {\n              console.warn('Could not fetch profile for remote signer:', e);\n            }\n            \n            setUser(user);\n            setLoginMethod('nip47');\n            setViewOnlyProfile(null);\n            \n            console.log('NIP-47 login successful:', user.npub);\n            console.log('Payment capability:', paymentStatus.canPay ? 'Enabled' : 'Disabled');\n            \n            if (!paymentStatus.canPay) {\n              console.warn('Payment not available:', paymentStatus.reason);\n            }\n          } catch (error) {\n            console.error('NIP-47 login error:', error);\n            throw new Error(`NIP-47 login failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n          }\n          break;\n        }\n        \n        case 'viewonly': {\n          // View-only login with a predefined profile\n          if (!options || !options.profile) {\n            throw new Error('View-only login requires a profile');\n          }\n          \n          const profile = options.profile as ViewOnlyProfile;\n          \n          // Create an NDKUser from the public key\n          const user = ndk.getUser({ npub: profile.npub });\n          \n          // For view-only, we can still fetch their profile data\n          try {\n            await user.fetchProfile();\n          } catch (e) {\n            console.warn('Could not fetch profile for view-only user, using predefined data');\n            // Use the predefined profile data\n            user.profile = {\n              name: profile.name,\n              displayName: profile.displayName,\n              image: profile.picture\n            };\n          }\n          \n          setUser(user);\n          setLoginMethod('viewonly');\n          setViewOnlyProfile(profile);\n          console.log('View-only login successful:', profile.npub);\n          setNip47Client(null);\n          setPaymentClient(null);\n          setCanMakePayments(false);\n          break;\n        }\n        \n        default:\n          throw new Error(`Unsupported login method: ${method}`);\n      }\n    } catch (e) {\n      console.error(`Login error (${method}):`, e);\n      setError(e as Error);\n      throw e;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Enhanced logout function\n  const logout = () => {\n    console.log('NostrContext: Logout initiated');\n    \n    // Clean up any active subscriptions or resources if needed\n    if (ndk) {\n      try {\n        // If we have a signer, we should reset it\n        if (ndk.signer) {\n          console.log('Resetting NDK signer');\n          ndk.signer = undefined;\n        }\n        \n        console.log('User resources cleaned up');\n      } catch (error) {\n        console.error('Error during logout cleanup:', error);\n      }\n    }\n    \n    // Clean up NIP-47 client if it exists\n    if (nip47Client) {\n      try {\n        nip47Client.disconnect();\n      } catch (e) {\n        console.error('Error disconnecting NIP-47 client:', e);\n      }\n      setNip47Client(null);\n    }\n    \n    // Clean up payment client\n    setPaymentClient(null);\n    setCanMakePayments(false);\n    \n    // Reset all state\n    setLoginMethod(null);\n    setViewOnlyProfile(null);\n    setUser(null);\n    setError(null);\n    setLoading(false);\n    \n    console.log('NostrContext: Logout completed');\n  };\n\n  // Get a user's profile\n  const getUserProfile = async (npub: string): Promise<NDKUser | null> => {\n    if (!ndk) {\n      throw new Error('NDK not initialized');\n    }\n\n    const user = ndk.getUser({ npub });\n    await user.fetchProfile();\n    return user;\n  };\n\n  // Get users that a user follows\n  const getFollows = async (npub: string): Promise<string[]> => {\n    if (!ndk) {\n      throw new Error('NDK not initialized');\n    }\n\n    const user = ndk.getUser({ npub });\n    const follows = await user.follows();\n    return Array.from(follows).map(follow => follow.npub);\n  };\n\n  // Pay a Lightning invoice\n  const payInvoice = async (invoice: string): Promise<any> => {\n    if (!paymentClient) {\n      throw new Error('Payment client not initialized');\n    }\n    \n    if (!canMakePayments) {\n      throw new Error('Payments not supported with current login method');\n    }\n    \n    try {\n      const response = await paymentClient.payInvoice(invoice);\n      \n      if (response.error) {\n        throw new Error(`Payment failed: ${response.error.message}`);\n      }\n      \n      return response.result;\n    } catch (error) {\n      console.error('Payment failed:', error);\n      throw error;\n    }\n  };\n\n  // Generate social graph data for the provided NPUBs\n  const getSocialGraph = async (npubs: string[], maxConnections: number = 25) => {\n    if (!ndk) {\n      throw new Error('NDK not initialized');\n    }\n    \n    // Check relay connections\n    try {\n      // Try to connect if not already connected\n      await ndk.connect();\n      \n      // Log connected relays (if any)\n      if (ndk.pool?.relays) {\n        const relayCount = Object.keys(ndk.pool.relays).length;\n        console.log(`Connected to ${relayCount} relays`);\n        if (relayCount === 0) {\n          console.warn('No relays connected. Results may be limited.');\n        }\n      } else {\n        console.warn('No relay pool available');\n      }\n    } catch (error) {\n      console.error('Relay connection error:', error);\n      // Continue anyway, but log the error\n    }\n    \n    console.log(`Fetching social graph for ${npubs.length} NPUBs with max ${maxConnections} connections`);\n    \n    // Real implementation using actual Nostr data\n    const nodes: any[] = [];\n    const links: any[] = [];\n    const nodeMap = new Map<string, boolean>();\n    \n    // Create a timeout promise\n    const timeout = (ms: number) => new Promise((_, reject) => \n      setTimeout(() => reject(new Error(`Operation timed out after ${ms}ms`)), ms)\n    );\n    \n    // Add the core NPUBs as nodes\n    for (const npub of npubs) {\n      if (nodeMap.has(npub)) continue;\n      \n      try {\n        // Get the actual user profile from Nostr with timeout\n        const user = ndk.getUser({ npub });\n        \n        // Set timeout for profile fetching to avoid hanging\n        const profilePromise = user.fetchProfile();\n        await Promise.race([\n          profilePromise,\n          timeout(10000) // 10 second timeout\n        ]);\n        \n        console.log(`Fetched profile for ${npub}: ${user.profile?.name || 'unnamed'}`);\n        \n        nodes.push({\n          id: npub,\n          npub,\n          name: user.profile?.displayName || user.profile?.name || shortenNpub(npub),\n          type: 'profile',\n          picture: user.profile?.picture || '',\n          isCoreNode: true,\n          val: 10,\n          group: 1\n        });\n        \n        nodeMap.set(npub, true);\n      } catch (e) {\n        console.error(`Failed to fetch profile for ${npub}`, e);\n        // Still add the node even if profile fetch fails\n        nodes.push({\n          id: npub,\n          npub,\n          name: shortenNpub(npub),\n          type: 'profile',\n          isCoreNode: true,\n          val: 10,\n          group: 1\n        });\n        \n        nodeMap.set(npub, true);\n      }\n    }\n    \n    // Fetch real follows for each core NPUB\n    for (const npub of npubs) {\n      try {\n        // Get the actual follows from Nostr with timeout\n        const user = ndk.getUser({ npub });\n        \n        // Set timeout for follows fetching to avoid hanging\n        const followsPromise = user.follows();\n        const follows = await Promise.race([\n          followsPromise,\n          timeout(15000) // 15 second timeout\n        ]) as Set<NDKUser>;\n        \n        console.log(`Fetched ${follows.size} follows for ${npub}`);\n        \n        // Limit to maxConnections if needed\n        const followsList = Array.from(follows).slice(0, maxConnections);\n        \n        // Process each follow\n        for (const followedUser of followsList) {\n          if (!followedUser || typeof followedUser !== 'object') {\n            console.warn('Invalid followed user:', followedUser);\n            continue;\n          }\n          \n          const followedNpub = (followedUser as NDKUser).npub;\n          if (!followedNpub) {\n            console.warn('User missing npub:', followedUser);\n            continue;\n          }\n          \n          // Skip if already processed\n          if (nodeMap.has(followedNpub)) {\n            // Still add connection if not already added\n            links.push({\n              source: npub,\n              target: followedNpub,\n              type: 'follows',\n              value: 1\n            });\n            continue;\n          }\n          \n          // Try to get profile information for the followed user\n          try {\n            // Set timeout for profile fetching\n            const profilePromise = (followedUser as NDKUser).fetchProfile();\n            await Promise.race([\n              profilePromise,\n              timeout(5000) // 5 second timeout for follows' profiles\n            ]);\n            \n            nodes.push({\n              id: followedNpub,\n              npub: followedNpub,\n              name: (followedUser as NDKUser).profile?.displayName || (followedUser as NDKUser).profile?.name || shortenNpub(followedNpub),\n              type: 'connection',\n              picture: (followedUser as NDKUser).profile?.picture || '',\n              isCoreNode: false,\n              val: 3,\n              group: 2\n            });\n          } catch (e) {\n            console.warn(`Failed to fetch profile for follow ${followedNpub}`, e);\n            nodes.push({\n              id: followedNpub,\n              npub: followedNpub,\n              name: shortenNpub(followedNpub),\n              type: 'connection',\n              isCoreNode: false,\n              val: 3,\n              group: 2\n            });\n          }\n          \n          nodeMap.set(followedNpub, true);\n          \n          // Add connection\n          links.push({\n            source: npub,\n            target: followedNpub,\n            type: 'follows',\n            value: 1\n          });\n        }\n        \n        // Check for mutual follows between core NPUBs (real connections)\n        const followedPubkeys = new Set(followsList.map(f => (f as NDKUser).npub));\n        \n        // For each other core NPUB, check if this NPUB follows it\n        for (const otherNpub of npubs) {\n          if (otherNpub !== npub && followedPubkeys.has(otherNpub)) {\n            links.push({\n              source: npub,\n              target: otherNpub,\n              type: 'mutual',\n              value: 2\n            });\n          }\n        }\n      } catch (e) {\n        console.error(`Failed to fetch follows for ${npub}`, e);\n      }\n    }\n    \n    console.log(`Completed social graph with ${nodes.length} nodes and ${links.length} links`);\n    \n    return { nodes, links };\n  };\n\n  // Provide the context value\n  const contextValue: NostrContextType = {\n    ndk,\n    user,\n    loading,\n    error,\n    loginMethod,\n    viewOnlyProfile,\n    availableProfiles: PREDEFINED_PROFILES,\n    login,\n    logout,\n    getUserProfile,\n    getFollows,\n    shortenNpub,\n    payInvoice: canMakePayments ? payInvoice : undefined,\n    canMakePayments,\n    getSocialGraph,\n  };\n\n  return (\n    <NostrContext.Provider value={contextValue}>\n      {children}\n    </NostrContext.Provider>\n  );\n};\n\n// Hook to use the Nostr context\nexport const useNostr = () => {\n  const context = useContext(NostrContext);\n  if (context === undefined) {\n    throw new Error('useNostr must be used within a NostrProvider');\n  }\n  return context;\n}; "],"names":["NIP47Client","getClientPubkey","clientPubkey","getRemotePubkey","remotePubkey","isConnected","connectionEstablished","uuidv4","encryptForRemote","content","nip04","encrypt","clientPrivkey","error","console","decryptFromRemote","ciphertext","decrypt","sendRequest","method","params","requestId","generateRequestId","responsePromise","Promise","resolve","reject","pendingRequests","set","setTimeout","has","delete","timeout","JSON","stringify","request","id","log","simulateResponseFromRemote","processResponse","event","decryptedContent","response","parse","pendingRequest","get","warn","code","message","result","sig","repeat","approved","preimage","connect","relayUrl","getPublicKey","signEvent","pubkey","plaintext","getInfo","getBalance","payInvoice","invoice","Error","substring","createPaymentRequestEvent","encryptedContent","kind","created_at","Math","floor","Date","now","tags","processPaymentResponse","getCapabilities","disconnect","constructor","remoteUrl","Map","startsWith","url","URL","pathname","searchParams","undefined","e","decoded","nip19","decode","type","data","generateSecretKey","NIP47PaymentClient","client","String","getPaymentResponseFilter","filter","kinds","checkPaymentCapability","canPay","reason","capabilities","includes","shortenNpub","npub","length","PREDEFINED_PROFILES","name","displayName","picture","createContext","NostrProvider","children","ndk","setNdk","useState","user","setUser","loading","setLoading","setError","loginMethod","setLoginMethod","viewOnlyProfile","setViewOnlyProfile","nip47Client","setNip47Client","paymentClient","setPaymentClient","canMakePayments","setCanMakePayments","useEffect","NDK","explicitRelayUrls","login","options","nostr","signer","NDKNip07Signer","publicKey","getUser","fetchProfile","target","npubEncode","payments","paymentStatus","profile","image","getUserProfile","getFollows","Array","from","follows","map","follow","getSocialGraph","npubs","maxConnections","pool","relays","relayCount","Object","keys","nodes","links","nodeMap","_","ms","profilePromise","race","push","isCoreNode","val","group","followsPromise","size","followsList","slice","followedUser","followedNpub","source","value","followedPubkeys","Set","f","otherNpub","NostrContext","Provider","contextValue","availableProfiles","logout","useNostr","context","useContext"],"sourceRoot":"","ignoreList":[]}