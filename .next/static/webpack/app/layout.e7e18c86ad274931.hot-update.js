"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./src/app/globals.css":
/*!*****************************!*\
  !*** ./src/app/globals.css ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"b491aff03a95\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvZ2xvYmFscy5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxJQUFVLElBQUksaUJBQWlCIiwic291cmNlcyI6WyIvaG9tZS9sZmcvR2l0L01hZHRyaXBzL3NyYy9hcHAvZ2xvYmFscy5jc3MiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCJiNDkxYWZmMDNhOTVcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/globals.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/lib/contexts/NostrContext.tsx":
/*!*******************************************!*\
  !*** ./src/lib/contexts/NostrContext.tsx ***!
  \*******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NostrProvider: () => (/* binding */ NostrProvider),\n/* harmony export */   PREDEFINED_PROFILES: () => (/* binding */ PREDEFINED_PROFILES),\n/* harmony export */   shortenNpub: () => (/* binding */ shortenNpub),\n/* harmony export */   useNostr: () => (/* binding */ useNostr)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @nostr-dev-kit/ndk */ \"(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/dist/index.mjs\");\n/* harmony import */ var nostr_tools__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! nostr-tools */ \"(app-pages-browser)/./node_modules/nostr-tools/lib/esm/index.js\");\n/* harmony import */ var _lib_nostr_nip47__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/lib/nostr/nip47 */ \"(app-pages-browser)/./src/lib/nostr/nip47.ts\");\n/* harmony import */ var _lib_nostr_nip47_payments__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/lib/nostr/nip47-payments */ \"(app-pages-browser)/./src/lib/nostr/nip47-payments.ts\");\n/* __next_internal_client_entry_do_not_use__ shortenNpub,PREDEFINED_PROFILES,NostrProvider,useNostr auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\n\n\n\n// Utility function to shorten npub for display\nconst shortenNpub = (npub)=>{\n    if (!npub) return '';\n    return \"\".concat(npub.substring(0, 8), \"...\").concat(npub.substring(npub.length - 4));\n};\n// List of predefined profiles for view only mode\nconst PREDEFINED_PROFILES = [\n    {\n        // MadTrips official profile\n        pubkey: '9a0a16254ff0dd29bbe45aeea9b8d80c0b9537d879a93f2589bbacedc4db166e',\n        npub: 'npub14jrvanj69ulfxc92pqsunvv220xhwtn6pukpmgpqzg6xl6wmaflqnx6nvs',\n        name: 'MadTrips_Official',\n        displayName: 'MadTrips (View Only)',\n        picture: '/assets/nostr-icon-purple-transparent-256x256.png'\n    }\n];\n// Create the context\nconst NostrContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\n// Provider component\nconst NostrProvider = (param)=>{\n    let { children } = param;\n    _s();\n    const [ndk, setNdk] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [user, setUser] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [loginMethod, setLoginMethod] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [viewOnlyProfile, setViewOnlyProfile] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [nip47Client, setNip47Client] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [paymentClient, setPaymentClient] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [canMakePayments, setCanMakePayments] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Initialize NDK on component mount\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"NostrProvider.useEffect\": ()=>{\n            const initializeNDK = {\n                \"NostrProvider.useEffect.initializeNDK\": async ()=>{\n                    try {\n                        // Check if window is defined (only in browser)\n                        if (true) {\n                            // Create a new NDK instance without a signer initially\n                            const ndk = new _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__[\"default\"]({\n                                explicitRelayUrls: [\n                                    'wss://relay.damus.io',\n                                    'wss://relay.nostr.band',\n                                    'wss://nos.lol',\n                                    'wss://relay.current.fyi',\n                                    'wss://relay.snort.social'\n                                ]\n                            });\n                            // Connect to relays\n                            await ndk.connect();\n                            setNdk(ndk);\n                            console.log('NDK initialized without signer');\n                            setLoading(false);\n                        }\n                    } catch (e) {\n                        console.error('Failed to initialize NDK:', e);\n                        setError(e);\n                        setLoading(false);\n                    }\n                }\n            }[\"NostrProvider.useEffect.initializeNDK\"];\n            initializeNDK();\n        }\n    }[\"NostrProvider.useEffect\"], []);\n    // Login function that handles different methods\n    const login = async (method, options)=>{\n        if (!ndk) {\n            throw new Error('NDK not initialized');\n        }\n        setLoading(true);\n        setError(null);\n        try {\n            switch(method){\n                case 'nip07':\n                    {\n                        // Browser extension login (NIP-07)\n                        if ( false || !window.nostr) {\n                            throw new Error('No NIP-07 compatible browser extension found');\n                        }\n                        // Create a signer that uses the window.nostr API (extension)\n                        ndk.signer = new _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKNip07Signer();\n                        // Get the user's public key\n                        const publicKey = await ndk.signer.user();\n                        if (!publicKey) {\n                            throw new Error('Failed to get public key from extension');\n                        }\n                        // Create an NDKUser from the public key\n                        const user = ndk.getUser({\n                            npub: publicKey.npub\n                        });\n                        // Fetch the user's profile\n                        await user.fetchProfile();\n                        setUser(user);\n                        setLoginMethod('nip07');\n                        setViewOnlyProfile(null);\n                        console.log('NIP-07 login successful:', user.npub);\n                        setCanMakePayments(false); // NIP-07 can't make payments by default\n                        break;\n                    }\n                case 'nip47':\n                    {\n                        // Remote signer login (NIP-47)\n                        if (!options || !options.target) {\n                            throw new Error('NIP-47 connection requires a target URL');\n                        }\n                        console.log('NIP-47 login requested to:', options.target);\n                        // For future implementation, we've created a NIP-47 client in @/lib/nostr/nip47.ts\n                        // but are providing a simplified implementation here for now\n                        try {\n                            // For demo purposes, we'll create a read-only profile from the target\n                            let npub = options.target;\n                            // If the target is a nostrconnect:// URL, extract the npub\n                            if (npub.startsWith('nostrconnect://')) {\n                                const url = new URL(npub);\n                                npub = url.pathname.substring(1); // Remove leading slash\n                                if (npub.startsWith('npub1')) {\n                                // Use as is\n                                } else {\n                                    // Convert hex to npub if needed\n                                    npub = nostr_tools__WEBPACK_IMPORTED_MODULE_5__.nip19.npubEncode(npub);\n                                }\n                            } else if (!npub.startsWith('npub1')) {\n                                // If it's a hex key, convert to npub\n                                npub = nostr_tools__WEBPACK_IMPORTED_MODULE_5__.nip19.npubEncode(npub);\n                            }\n                            // Create an NDKUser from the pubkey\n                            const user = ndk.getUser({\n                                npub\n                            });\n                            // Create NIP-47 client\n                            const client = new _lib_nostr_nip47__WEBPACK_IMPORTED_MODULE_3__.NIP47Client(options.target);\n                            // Connect to the remote signer\n                            await client.connect();\n                            // Get the public key\n                            const remotePubkey = await client.getPublicKey();\n                            // Create the payment client\n                            const payments = new _lib_nostr_nip47_payments__WEBPACK_IMPORTED_MODULE_4__.NIP47PaymentClient(client);\n                            // Check if payments are supported\n                            const paymentStatus = await payments.checkPaymentCapability();\n                            // Store the clients for later use\n                            setNip47Client(client);\n                            setPaymentClient(payments);\n                            setCanMakePayments(paymentStatus.canPay);\n                            // Attempt to fetch profile data\n                            try {\n                                await user.fetchProfile();\n                            } catch (e) {\n                                console.warn('Could not fetch profile for remote signer:', e);\n                            }\n                            setUser(user);\n                            setLoginMethod('nip47');\n                            setViewOnlyProfile(null);\n                            console.log('NIP-47 login successful:', user.npub);\n                            console.log('Payment capability:', paymentStatus.canPay ? 'Enabled' : 'Disabled');\n                            if (!paymentStatus.canPay) {\n                                console.warn('Payment not available:', paymentStatus.reason);\n                            }\n                        } catch (error) {\n                            console.error('NIP-47 login error:', error);\n                            throw new Error(\"NIP-47 login failed: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n                        }\n                        break;\n                    }\n                case 'viewonly':\n                    {\n                        // View-only login with a predefined profile\n                        if (!options || !options.profile) {\n                            throw new Error('View-only login requires a profile');\n                        }\n                        const profile = options.profile;\n                        // Create an NDKUser from the public key\n                        const user = ndk.getUser({\n                            npub: profile.npub\n                        });\n                        // For view-only, we can still fetch their profile data\n                        try {\n                            await user.fetchProfile();\n                        } catch (e) {\n                            console.warn('Could not fetch profile for view-only user, using predefined data');\n                            // Use the predefined profile data\n                            user.profile = {\n                                name: profile.name,\n                                displayName: profile.displayName,\n                                image: profile.picture\n                            };\n                        }\n                        setUser(user);\n                        setLoginMethod('viewonly');\n                        setViewOnlyProfile(profile);\n                        console.log('View-only login successful:', profile.npub);\n                        setNip47Client(null);\n                        setPaymentClient(null);\n                        setCanMakePayments(false);\n                        break;\n                    }\n                default:\n                    throw new Error(\"Unsupported login method: \".concat(method));\n            }\n        } catch (e) {\n            console.error(\"Login error (\".concat(method, \"):\"), e);\n            setError(e);\n            throw e;\n        } finally{\n            setLoading(false);\n        }\n    };\n    // Enhanced logout function\n    const logout = ()=>{\n        console.log('NostrContext: Logout initiated');\n        // Clean up any active subscriptions or resources if needed\n        if (ndk) {\n            try {\n                // If we have a signer, we should reset it\n                if (ndk.signer) {\n                    console.log('Resetting NDK signer');\n                    ndk.signer = undefined;\n                }\n                console.log('User resources cleaned up');\n            } catch (error) {\n                console.error('Error during logout cleanup:', error);\n            }\n        }\n        // Clean up NIP-47 client if it exists\n        if (nip47Client) {\n            try {\n                nip47Client.disconnect();\n            } catch (e) {\n                console.error('Error disconnecting NIP-47 client:', e);\n            }\n            setNip47Client(null);\n        }\n        // Clean up payment client\n        setPaymentClient(null);\n        setCanMakePayments(false);\n        // Reset all state\n        setLoginMethod(null);\n        setViewOnlyProfile(null);\n        setUser(null);\n        setError(null);\n        setLoading(false);\n        console.log('NostrContext: Logout completed');\n    };\n    // Get a user's profile\n    const getUserProfile = async (npub)=>{\n        if (!ndk) {\n            throw new Error('NDK not initialized');\n        }\n        const user = ndk.getUser({\n            npub\n        });\n        await user.fetchProfile();\n        return user;\n    };\n    // Get users that a user follows\n    const getFollows = async (npub)=>{\n        if (!ndk) {\n            throw new Error('NDK not initialized');\n        }\n        const user = ndk.getUser({\n            npub\n        });\n        const follows = await user.follows();\n        return Array.from(follows).map((follow)=>follow.npub);\n    };\n    // Pay a Lightning invoice\n    const payInvoice = async (invoice)=>{\n        if (!paymentClient) {\n            throw new Error('Payment client not initialized');\n        }\n        if (!canMakePayments) {\n            throw new Error('Payments not supported with current login method');\n        }\n        try {\n            const response = await paymentClient.payInvoice(invoice);\n            if (response.error) {\n                throw new Error(\"Payment failed: \".concat(response.error.message));\n            }\n            return response.result;\n        } catch (error) {\n            console.error('Payment failed:', error);\n            throw error;\n        }\n    };\n    // Generate social graph data for the provided NPUBs\n    const getSocialGraph = async function(npubs) {\n        let maxConnections = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 25;\n        if (!ndk) {\n            throw new Error('NDK not initialized');\n        }\n        console.log(\"Generating social graph for \".concat(npubs.length, \" NPUBs with max \").concat(maxConnections, \" connections\"));\n        // This is a front-end implementation that creates mock data\n        const nodes = [];\n        const links = [];\n        const nodeMap = new Map();\n        // Add the core NPUBs as nodes\n        for (const npub of npubs){\n            if (nodeMap.has(npub)) continue;\n            // Try to get user profile if possible\n            let name = '';\n            let picture = '';\n            try {\n                var _user_profile, _user_profile1, _user_profile2;\n                const user = ndk.getUser({\n                    npub\n                });\n                await user.fetchProfile();\n                name = ((_user_profile = user.profile) === null || _user_profile === void 0 ? void 0 : _user_profile.displayName) || ((_user_profile1 = user.profile) === null || _user_profile1 === void 0 ? void 0 : _user_profile1.name) || '';\n                picture = ((_user_profile2 = user.profile) === null || _user_profile2 === void 0 ? void 0 : _user_profile2.picture) || '';\n            } catch (e) {\n                console.warn(\"Failed to fetch profile for \".concat(npub), e);\n            }\n            nodes.push({\n                id: npub,\n                npub,\n                name: name || \"User \".concat(npub.substring(0, 8)),\n                type: 'profile',\n                picture,\n                isCoreNode: true,\n                val: 10,\n                group: 1\n            });\n            nodeMap.set(npub, true);\n        }\n        // For each core NPUB, create some mock connections\n        for (const npub of npubs){\n            // For realistic data, we'd fetch follows here\n            // For this mock version, we'll create random connections\n            const connectionCount = Math.floor(Math.random() * maxConnections) + 3;\n            for(let i = 0; i < connectionCount; i++){\n                const followNpub = \"npub\".concat(Math.random().toString(36).substring(2, 15));\n                // Skip if we already have this node\n                if (nodeMap.has(followNpub)) continue;\n                // Add node\n                nodes.push({\n                    id: followNpub,\n                    npub: followNpub,\n                    name: \"Connection \".concat(i, \" of \").concat(npub.substring(0, 8)),\n                    type: 'connection',\n                    isCoreNode: false,\n                    val: 3,\n                    group: 2\n                });\n                nodeMap.set(followNpub, true);\n                // Add connection\n                links.push({\n                    source: npub,\n                    target: followNpub,\n                    type: 'follows',\n                    value: 1\n                });\n            }\n        }\n        // Add some connections between core NPUBs for a more realistic graph\n        for(let i = 0; i < npubs.length; i++){\n            for(let j = i + 1; j < npubs.length; j++){\n                if (Math.random() > 0.3) {\n                    links.push({\n                        source: npubs[i],\n                        target: npubs[j],\n                        type: 'mutual',\n                        value: 2\n                    });\n                }\n            }\n        }\n        return {\n            nodes,\n            links\n        };\n    };\n    // Provide the context value\n    const contextValue = {\n        ndk,\n        user,\n        loading,\n        error,\n        loginMethod,\n        viewOnlyProfile,\n        availableProfiles: PREDEFINED_PROFILES,\n        login,\n        logout,\n        getUserProfile,\n        getFollows,\n        shortenNpub,\n        payInvoice: canMakePayments ? payInvoice : undefined,\n        canMakePayments,\n        getSocialGraph\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(NostrContext.Provider, {\n        value: contextValue,\n        children: children\n    }, void 0, false, {\n        fileName: \"/home/lfg/Git/Madtrips/src/lib/contexts/NostrContext.tsx\",\n        lineNumber: 474,\n        columnNumber: 5\n    }, undefined);\n};\n_s(NostrProvider, \"XXmHTZ3akXfpNIfxEerd+v4DDso=\");\n_c = NostrProvider;\n// Hook to use the Nostr context\nconst useNostr = ()=>{\n    _s1();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(NostrContext);\n    if (context === undefined) {\n        throw new Error('useNostr must be used within a NostrProvider');\n    }\n    return context;\n};\n_s1(useNostr, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"NostrProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvY29udGV4dHMvTm9zdHJDb250ZXh0LnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBRXlGO0FBQ1c7QUFDaEQ7QUFDaEI7QUFDWTtBQUNnQjtBQUdoRSwrQ0FBK0M7QUFDeEMsTUFBTVUsY0FBYyxDQUFDQztJQUMxQixJQUFJLENBQUNBLE1BQU0sT0FBTztJQUNsQixPQUFPLEdBQTZCQSxPQUExQkEsS0FBS0MsU0FBUyxDQUFDLEdBQUcsSUFBRyxPQUFxQyxPQUFoQ0QsS0FBS0MsU0FBUyxDQUFDRCxLQUFLRSxNQUFNLEdBQUc7QUFDbkUsRUFBRTtBQUVGLGlEQUFpRDtBQUMxQyxNQUFNQyxzQkFBeUM7SUFDcEQ7UUFDRSw0QkFBNEI7UUFDNUJDLFFBQVE7UUFDUkosTUFBTTtRQUNOSyxNQUFNO1FBQ05DLGFBQWE7UUFDYkMsU0FBUztJQUNYO0NBQ0QsQ0FBQztBQStCRixxQkFBcUI7QUFDckIsTUFBTUMsNkJBQWVsQixvREFBYUEsQ0FBK0JtQjtBQUVqRSxxQkFBcUI7QUFDZCxNQUFNQyxnQkFBaUQ7UUFBQyxFQUFFQyxRQUFRLEVBQUU7O0lBQ3pFLE1BQU0sQ0FBQ0MsS0FBS0MsT0FBTyxHQUFHckIsK0NBQVFBLENBQWE7SUFDM0MsTUFBTSxDQUFDc0IsTUFBTUMsUUFBUSxHQUFHdkIsK0NBQVFBLENBQWlCO0lBQ2pELE1BQU0sQ0FBQ3dCLFNBQVNDLFdBQVcsR0FBR3pCLCtDQUFRQSxDQUFDO0lBQ3ZDLE1BQU0sQ0FBQzBCLE9BQU9DLFNBQVMsR0FBRzNCLCtDQUFRQSxDQUFlO0lBQ2pELE1BQU0sQ0FBQzRCLGFBQWFDLGVBQWUsR0FBRzdCLCtDQUFRQSxDQUFxQjtJQUNuRSxNQUFNLENBQUM4QixpQkFBaUJDLG1CQUFtQixHQUFHL0IsK0NBQVFBLENBQXlCO0lBQy9FLE1BQU0sQ0FBQ2dDLGFBQWFDLGVBQWUsR0FBR2pDLCtDQUFRQSxDQUFxQjtJQUNuRSxNQUFNLENBQUNrQyxlQUFlQyxp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bkc7b0JBQ1I4QyxRQUFRbUQ7b0JBQ1JWLE1BQU07b0JBQ05hLE9BQU87Z0JBQ1Q7WUFDRjtRQUNGO1FBRUEscUVBQXFFO1FBQ3JFLElBQUssSUFBSUosSUFBSSxHQUFHQSxJQUFJbEIsTUFBTTVFLE1BQU0sRUFBRThGLElBQUs7WUFDckMsSUFBSyxJQUFJSyxJQUFJTCxJQUFJLEdBQUdLLElBQUl2QixNQUFNNUUsTUFBTSxFQUFFbUcsSUFBSztnQkFDekMsSUFBSVIsS0FBS0UsTUFBTSxLQUFLLEtBQUs7b0JBQ3ZCZCxNQUFNSSxJQUFJLENBQUM7d0JBQ1RjLFFBQVFyQixLQUFLLENBQUNrQixFQUFFO3dCQUNoQmxELFFBQVFnQyxLQUFLLENBQUN1QixFQUFFO3dCQUNoQmQsTUFBTTt3QkFDTmEsT0FBTztvQkFDVDtnQkFDRjtZQUNGO1FBQ0Y7UUFFQSxPQUFPO1lBQUVwQjtZQUFPQztRQUFNO0lBQ3hCO0lBRUEsNEJBQTRCO0lBQzVCLE1BQU1xQixlQUFpQztRQUNyQzFGO1FBQ0FFO1FBQ0FFO1FBQ0FFO1FBQ0FFO1FBQ0FFO1FBQ0FpRixtQkFBbUJwRztRQUNuQmlDO1FBQ0E0QjtRQUNBRTtRQUNBQztRQUNBcEU7UUFDQTBFLFlBQVk3QyxrQkFBa0I2QyxhQUFhaEU7UUFDM0NtQjtRQUNBaUQ7SUFDRjtJQUVBLHFCQUNFLDhEQUFDckUsYUFBYWdHLFFBQVE7UUFBQ0osT0FBT0U7a0JBQzNCM0Y7Ozs7OztBQUdQLEVBQUU7R0FoYVdEO0tBQUFBO0FBa2FiLGdDQUFnQztBQUN6QixNQUFNK0YsV0FBVzs7SUFDdEIsTUFBTUMsVUFBVW5ILGlEQUFVQSxDQUFDaUI7SUFDM0IsSUFBSWtHLFlBQVlqRyxXQUFXO1FBQ3pCLE1BQU0sSUFBSThCLE1BQU07SUFDbEI7SUFDQSxPQUFPbUU7QUFDVCxFQUFFO0lBTldEIiwic291cmNlcyI6WyIvaG9tZS9sZmcvR2l0L01hZHRyaXBzL3NyYy9saWIvY29udGV4dHMvTm9zdHJDb250ZXh0LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5cbmltcG9ydCBSZWFjdCwgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VTdGF0ZSwgdXNlRWZmZWN0LCBSZWFjdE5vZGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgTkRLLCB7IE5ES0V2ZW50LCBOREtVc2VyLCBOREtGaWx0ZXIsIE5ES1N1YnNjcmlwdGlvbiwgTm9zdHJFdmVudCB9IGZyb20gJ0Bub3N0ci1kZXYta2l0L25kayc7XG5pbXBvcnQgeyBOREtOaXAwN1NpZ25lciB9IGZyb20gJ0Bub3N0ci1kZXYta2l0L25kayc7XG5pbXBvcnQgeyBuaXAxOSB9IGZyb20gJ25vc3RyLXRvb2xzJztcbmltcG9ydCB7IE5JUDQ3Q2xpZW50IH0gZnJvbSAnQC9saWIvbm9zdHIvbmlwNDcnO1xuaW1wb3J0IHsgTklQNDdQYXltZW50Q2xpZW50IH0gZnJvbSAnQC9saWIvbm9zdHIvbmlwNDctcGF5bWVudHMnO1xuaW1wb3J0IHsgTkRLTmlwNDZTaWduZXIgfSBmcm9tICdAbm9zdHItZGV2LWtpdC9uZGsnO1xuXG4vLyBVdGlsaXR5IGZ1bmN0aW9uIHRvIHNob3J0ZW4gbnB1YiBmb3IgZGlzcGxheVxuZXhwb3J0IGNvbnN0IHNob3J0ZW5OcHViID0gKG5wdWI6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gIGlmICghbnB1YikgcmV0dXJuICcnO1xuICByZXR1cm4gYCR7bnB1Yi5zdWJzdHJpbmcoMCwgOCl9Li4uJHtucHViLnN1YnN0cmluZyhucHViLmxlbmd0aCAtIDQpfWA7XG59O1xuXG4vLyBMaXN0IG9mIHByZWRlZmluZWQgcHJvZmlsZXMgZm9yIHZpZXcgb25seSBtb2RlXG5leHBvcnQgY29uc3QgUFJFREVGSU5FRF9QUk9GSUxFUzogVmlld09ubHlQcm9maWxlW10gPSBbXG4gIHtcbiAgICAvLyBNYWRUcmlwcyBvZmZpY2lhbCBwcm9maWxlXG4gICAgcHVia2V5OiAnOWEwYTE2MjU0ZmYwZGQyOWJiZTQ1YWVlYTliOGQ4MGMwYjk1MzdkODc5YTkzZjI1ODliYmFjZWRjNGRiMTY2ZScsIFxuICAgIG5wdWI6ICducHViMTRqcnZhbmo2OXVsZnhjOTJwcXN1bnZ2MjIweGh3dG42cHVrcG1ncHF6ZzZ4bDZ3bWFmbHFueDZudnMnLFxuICAgIG5hbWU6ICdNYWRUcmlwc19PZmZpY2lhbCcsXG4gICAgZGlzcGxheU5hbWU6ICdNYWRUcmlwcyAoVmlldyBPbmx5KScsXG4gICAgcGljdHVyZTogJy9hc3NldHMvbm9zdHItaWNvbi1wdXJwbGUtdHJhbnNwYXJlbnQtMjU2eDI1Ni5wbmcnXG4gIH1cbl07XG5cbi8vIERlZmluZSB0eXBlcyBmb3Igb3VyIGNvbnRleHRcbmludGVyZmFjZSBWaWV3T25seVByb2ZpbGUge1xuICBwdWJrZXk6IHN0cmluZztcbiAgbnB1Yjogc3RyaW5nO1xuICBuYW1lPzogc3RyaW5nO1xuICBkaXNwbGF5TmFtZT86IHN0cmluZztcbiAgcGljdHVyZT86IHN0cmluZztcbn1cblxudHlwZSBMb2dpbk1ldGhvZCA9ICduaXAwNycgfCAnbmlwNDcnIHwgJ3ZpZXdvbmx5JztcblxuaW50ZXJmYWNlIE5vc3RyQ29udGV4dFR5cGUge1xuICBuZGs6IE5ESyB8IG51bGw7XG4gIHVzZXI6IE5ES1VzZXIgfCBudWxsO1xuICBsb2FkaW5nOiBib29sZWFuO1xuICBlcnJvcjogRXJyb3IgfCBudWxsO1xuICBsb2dpbk1ldGhvZDogTG9naW5NZXRob2QgfCBudWxsO1xuICB2aWV3T25seVByb2ZpbGU6IFZpZXdPbmx5UHJvZmlsZSB8IG51bGw7XG4gIGF2YWlsYWJsZVByb2ZpbGVzOiBWaWV3T25seVByb2ZpbGVbXTtcbiAgbG9naW46IChtZXRob2Q6IExvZ2luTWV0aG9kLCBvcHRpb25zPzogYW55KSA9PiBQcm9taXNlPHZvaWQ+O1xuICBsb2dvdXQ6ICgpID0+IHZvaWQ7XG4gIGdldFVzZXJQcm9maWxlOiAobnB1Yjogc3RyaW5nKSA9PiBQcm9taXNlPE5ES1VzZXIgfCBudWxsPjtcbiAgZ2V0Rm9sbG93czogKG5wdWI6IHN0cmluZykgPT4gUHJvbWlzZTxzdHJpbmdbXT47XG4gIHNob3J0ZW5OcHViOiAobnB1Yjogc3RyaW5nKSA9PiBzdHJpbmc7XG4gIHBheUludm9pY2U/OiAoaW52b2ljZTogc3RyaW5nKSA9PiBQcm9taXNlPGFueT47XG4gIGNhbk1ha2VQYXltZW50czogYm9vbGVhbjtcbiAgZ2V0U29jaWFsR3JhcGg6IChucHViczogc3RyaW5nW10sIG1heENvbm5lY3Rpb25zPzogbnVtYmVyKSA9PiBQcm9taXNlPHtub2RlczogYW55W10sIGxpbmtzOiBhbnlbXX0+O1xufVxuXG4vLyBDcmVhdGUgdGhlIGNvbnRleHRcbmNvbnN0IE5vc3RyQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8Tm9zdHJDb250ZXh0VHlwZSB8IHVuZGVmaW5lZD4odW5kZWZpbmVkKTtcblxuLy8gUHJvdmlkZXIgY29tcG9uZW50XG5leHBvcnQgY29uc3QgTm9zdHJQcm92aWRlcjogUmVhY3QuRkM8e2NoaWxkcmVuOiBSZWFjdE5vZGV9PiA9ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgY29uc3QgW25kaywgc2V0TmRrXSA9IHVzZVN0YXRlPE5ESyB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbdXNlciwgc2V0VXNlcl0gPSB1c2VTdGF0ZTxOREtVc2VyIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtsb2FkaW5nLCBzZXRMb2FkaW5nXSA9IHVzZVN0YXRlKHRydWUpO1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPEVycm9yIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtsb2dpbk1ldGhvZCwgc2V0TG9naW5NZXRob2RdID0gdXNlU3RhdGU8TG9naW5NZXRob2QgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW3ZpZXdPbmx5UHJvZmlsZSwgc2V0Vmlld09ubHlQcm9maWxlXSA9IHVzZVN0YXRlPFZpZXdPbmx5UHJvZmlsZSB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbbmlwNDdDbGllbnQsIHNldE5pcDQ3Q2xpZW50XSA9IHVzZVN0YXRlPE5JUDQ3Q2xpZW50IHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtwYXltZW50Q2xpZW50LCBzZXRQYXltZW50Q2xpZW50XSA9IHVzZVN0YXRlPE5JUDQ3UGF5bWVudENsaWVudCB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbY2FuTWFrZVBheW1lbnRzLCBzZXRDYW5NYWtlUGF5bWVudHNdID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gIC8vIEluaXRpYWxpemUgTkRLIG9uIGNvbXBvbmVudCBtb3VudFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGluaXRpYWxpemVOREsgPSBhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBDaGVjayBpZiB3aW5kb3cgaXMgZGVmaW5lZCAob25seSBpbiBicm93c2VyKVxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAvLyBDcmVhdGUgYSBuZXcgTkRLIGluc3RhbmNlIHdpdGhvdXQgYSBzaWduZXIgaW5pdGlhbGx5XG4gICAgICAgICAgY29uc3QgbmRrID0gbmV3IE5ESyh7XG4gICAgICAgICAgICBleHBsaWNpdFJlbGF5VXJsczogW1xuICAgICAgICAgICAgICAnd3NzOi8vcmVsYXkuZGFtdXMuaW8nLFxuICAgICAgICAgICAgICAnd3NzOi8vcmVsYXkubm9zdHIuYmFuZCcsXG4gICAgICAgICAgICAgICd3c3M6Ly9ub3MubG9sJyxcbiAgICAgICAgICAgICAgJ3dzczovL3JlbGF5LmN1cnJlbnQuZnlpJyxcbiAgICAgICAgICAgICAgJ3dzczovL3JlbGF5LnNub3J0LnNvY2lhbCcsXG4gICAgICAgICAgICBdXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBDb25uZWN0IHRvIHJlbGF5c1xuICAgICAgICAgIGF3YWl0IG5kay5jb25uZWN0KCk7XG4gICAgICAgICAgc2V0TmRrKG5kayk7XG4gICAgICAgICAgY29uc29sZS5sb2coJ05ESyBpbml0aWFsaXplZCB3aXRob3V0IHNpZ25lcicpO1xuICAgICAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBpbml0aWFsaXplIE5ESzonLCBlKTtcbiAgICAgICAgc2V0RXJyb3IoZSBhcyBFcnJvcik7XG4gICAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpbml0aWFsaXplTkRLKCk7XG4gIH0sIFtdKTtcblxuICAvLyBMb2dpbiBmdW5jdGlvbiB0aGF0IGhhbmRsZXMgZGlmZmVyZW50IG1ldGhvZHNcbiAgY29uc3QgbG9naW4gPSBhc3luYyAobWV0aG9kOiBMb2dpbk1ldGhvZCwgb3B0aW9ucz86IGFueSkgPT4ge1xuICAgIGlmICghbmRrKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05ESyBub3QgaW5pdGlhbGl6ZWQnKTtcbiAgICB9XG5cbiAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgIHNldEVycm9yKG51bGwpO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgICBjYXNlICduaXAwNyc6IHtcbiAgICAgICAgICAvLyBCcm93c2VyIGV4dGVuc2lvbiBsb2dpbiAoTklQLTA3KVxuICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCAhd2luZG93Lm5vc3RyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIE5JUC0wNyBjb21wYXRpYmxlIGJyb3dzZXIgZXh0ZW5zaW9uIGZvdW5kJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIENyZWF0ZSBhIHNpZ25lciB0aGF0IHVzZXMgdGhlIHdpbmRvdy5ub3N0ciBBUEkgKGV4dGVuc2lvbilcbiAgICAgICAgICBuZGsuc2lnbmVyID0gbmV3IE5ES05pcDA3U2lnbmVyKCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gR2V0IHRoZSB1c2VyJ3MgcHVibGljIGtleVxuICAgICAgICAgIGNvbnN0IHB1YmxpY0tleSA9IGF3YWl0IG5kay5zaWduZXIudXNlcigpO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmICghcHVibGljS2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBnZXQgcHVibGljIGtleSBmcm9tIGV4dGVuc2lvbicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDcmVhdGUgYW4gTkRLVXNlciBmcm9tIHRoZSBwdWJsaWMga2V5XG4gICAgICAgICAgY29uc3QgdXNlciA9IG5kay5nZXRVc2VyKHsgbnB1YjogcHVibGljS2V5Lm5wdWIgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRmV0Y2ggdGhlIHVzZXIncyBwcm9maWxlXG4gICAgICAgICAgYXdhaXQgdXNlci5mZXRjaFByb2ZpbGUoKTtcbiAgICAgICAgICBcbiAgICAgICAgICBzZXRVc2VyKHVzZXIpO1xuICAgICAgICAgIHNldExvZ2luTWV0aG9kKCduaXAwNycpO1xuICAgICAgICAgIHNldFZpZXdPbmx5UHJvZmlsZShudWxsKTtcbiAgICAgICAgICBjb25zb2xlLmxvZygnTklQLTA3IGxvZ2luIHN1Y2Nlc3NmdWw6JywgdXNlci5ucHViKTtcbiAgICAgICAgICBzZXRDYW5NYWtlUGF5bWVudHMoZmFsc2UpOyAvLyBOSVAtMDcgY2FuJ3QgbWFrZSBwYXltZW50cyBieSBkZWZhdWx0XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNhc2UgJ25pcDQ3Jzoge1xuICAgICAgICAgIC8vIFJlbW90ZSBzaWduZXIgbG9naW4gKE5JUC00NylcbiAgICAgICAgICBpZiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMudGFyZ2V0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05JUC00NyBjb25uZWN0aW9uIHJlcXVpcmVzIGEgdGFyZ2V0IFVSTCcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnNvbGUubG9nKCdOSVAtNDcgbG9naW4gcmVxdWVzdGVkIHRvOicsIG9wdGlvbnMudGFyZ2V0KTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBGb3IgZnV0dXJlIGltcGxlbWVudGF0aW9uLCB3ZSd2ZSBjcmVhdGVkIGEgTklQLTQ3IGNsaWVudCBpbiBAL2xpYi9ub3N0ci9uaXA0Ny50c1xuICAgICAgICAgIC8vIGJ1dCBhcmUgcHJvdmlkaW5nIGEgc2ltcGxpZmllZCBpbXBsZW1lbnRhdGlvbiBoZXJlIGZvciBub3dcbiAgICAgICAgICBcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gRm9yIGRlbW8gcHVycG9zZXMsIHdlJ2xsIGNyZWF0ZSBhIHJlYWQtb25seSBwcm9maWxlIGZyb20gdGhlIHRhcmdldFxuICAgICAgICAgICAgbGV0IG5wdWIgPSBvcHRpb25zLnRhcmdldDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gSWYgdGhlIHRhcmdldCBpcyBhIG5vc3RyY29ubmVjdDovLyBVUkwsIGV4dHJhY3QgdGhlIG5wdWJcbiAgICAgICAgICAgIGlmIChucHViLnN0YXJ0c1dpdGgoJ25vc3RyY29ubmVjdDovLycpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwobnB1Yik7XG4gICAgICAgICAgICAgIG5wdWIgPSB1cmwucGF0aG5hbWUuc3Vic3RyaW5nKDEpOyAvLyBSZW1vdmUgbGVhZGluZyBzbGFzaFxuICAgICAgICAgICAgICBpZiAobnB1Yi5zdGFydHNXaXRoKCducHViMScpKSB7XG4gICAgICAgICAgICAgICAgLy8gVXNlIGFzIGlzXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQ29udmVydCBoZXggdG8gbnB1YiBpZiBuZWVkZWRcbiAgICAgICAgICAgICAgICBucHViID0gbmlwMTkubnB1YkVuY29kZShucHViKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICghbnB1Yi5zdGFydHNXaXRoKCducHViMScpKSB7XG4gICAgICAgICAgICAgIC8vIElmIGl0J3MgYSBoZXgga2V5LCBjb252ZXJ0IHRvIG5wdWJcbiAgICAgICAgICAgICAgbnB1YiA9IG5pcDE5Lm5wdWJFbmNvZGUobnB1Yik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhbiBOREtVc2VyIGZyb20gdGhlIHB1YmtleVxuICAgICAgICAgICAgY29uc3QgdXNlciA9IG5kay5nZXRVc2VyKHsgbnB1YiB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQ3JlYXRlIE5JUC00NyBjbGllbnRcbiAgICAgICAgICAgIGNvbnN0IGNsaWVudCA9IG5ldyBOSVA0N0NsaWVudChvcHRpb25zLnRhcmdldCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIENvbm5lY3QgdG8gdGhlIHJlbW90ZSBzaWduZXJcbiAgICAgICAgICAgIGF3YWl0IGNsaWVudC5jb25uZWN0KCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEdldCB0aGUgcHVibGljIGtleVxuICAgICAgICAgICAgY29uc3QgcmVtb3RlUHVia2V5ID0gYXdhaXQgY2xpZW50LmdldFB1YmxpY0tleSgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBDcmVhdGUgdGhlIHBheW1lbnQgY2xpZW50XG4gICAgICAgICAgICBjb25zdCBwYXltZW50cyA9IG5ldyBOSVA0N1BheW1lbnRDbGllbnQoY2xpZW50KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgcGF5bWVudHMgYXJlIHN1cHBvcnRlZFxuICAgICAgICAgICAgY29uc3QgcGF5bWVudFN0YXR1cyA9IGF3YWl0IHBheW1lbnRzLmNoZWNrUGF5bWVudENhcGFiaWxpdHkoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gU3RvcmUgdGhlIGNsaWVudHMgZm9yIGxhdGVyIHVzZVxuICAgICAgICAgICAgc2V0TmlwNDdDbGllbnQoY2xpZW50KTtcbiAgICAgICAgICAgIHNldFBheW1lbnRDbGllbnQocGF5bWVudHMpO1xuICAgICAgICAgICAgc2V0Q2FuTWFrZVBheW1lbnRzKHBheW1lbnRTdGF0dXMuY2FuUGF5KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQXR0ZW1wdCB0byBmZXRjaCBwcm9maWxlIGRhdGFcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGF3YWl0IHVzZXIuZmV0Y2hQcm9maWxlKCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybignQ291bGQgbm90IGZldGNoIHByb2ZpbGUgZm9yIHJlbW90ZSBzaWduZXI6JywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHNldFVzZXIodXNlcik7XG4gICAgICAgICAgICBzZXRMb2dpbk1ldGhvZCgnbmlwNDcnKTtcbiAgICAgICAgICAgIHNldFZpZXdPbmx5UHJvZmlsZShudWxsKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc29sZS5sb2coJ05JUC00NyBsb2dpbiBzdWNjZXNzZnVsOicsIHVzZXIubnB1Yik7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnUGF5bWVudCBjYXBhYmlsaXR5OicsIHBheW1lbnRTdGF0dXMuY2FuUGF5ID8gJ0VuYWJsZWQnIDogJ0Rpc2FibGVkJyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICghcGF5bWVudFN0YXR1cy5jYW5QYXkpIHtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdQYXltZW50IG5vdCBhdmFpbGFibGU6JywgcGF5bWVudFN0YXR1cy5yZWFzb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdOSVAtNDcgbG9naW4gZXJyb3I6JywgZXJyb3IpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOSVAtNDcgbG9naW4gZmFpbGVkOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY2FzZSAndmlld29ubHknOiB7XG4gICAgICAgICAgLy8gVmlldy1vbmx5IGxvZ2luIHdpdGggYSBwcmVkZWZpbmVkIHByb2ZpbGVcbiAgICAgICAgICBpZiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMucHJvZmlsZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdWaWV3LW9ubHkgbG9naW4gcmVxdWlyZXMgYSBwcm9maWxlJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IHByb2ZpbGUgPSBvcHRpb25zLnByb2ZpbGUgYXMgVmlld09ubHlQcm9maWxlO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENyZWF0ZSBhbiBOREtVc2VyIGZyb20gdGhlIHB1YmxpYyBrZXlcbiAgICAgICAgICBjb25zdCB1c2VyID0gbmRrLmdldFVzZXIoeyBucHViOiBwcm9maWxlLm5wdWIgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRm9yIHZpZXctb25seSwgd2UgY2FuIHN0aWxsIGZldGNoIHRoZWlyIHByb2ZpbGUgZGF0YVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB1c2VyLmZldGNoUHJvZmlsZSgpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignQ291bGQgbm90IGZldGNoIHByb2ZpbGUgZm9yIHZpZXctb25seSB1c2VyLCB1c2luZyBwcmVkZWZpbmVkIGRhdGEnKTtcbiAgICAgICAgICAgIC8vIFVzZSB0aGUgcHJlZGVmaW5lZCBwcm9maWxlIGRhdGFcbiAgICAgICAgICAgIHVzZXIucHJvZmlsZSA9IHtcbiAgICAgICAgICAgICAgbmFtZTogcHJvZmlsZS5uYW1lLFxuICAgICAgICAgICAgICBkaXNwbGF5TmFtZTogcHJvZmlsZS5kaXNwbGF5TmFtZSxcbiAgICAgICAgICAgICAgaW1hZ2U6IHByb2ZpbGUucGljdHVyZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgc2V0VXNlcih1c2VyKTtcbiAgICAgICAgICBzZXRMb2dpbk1ldGhvZCgndmlld29ubHknKTtcbiAgICAgICAgICBzZXRWaWV3T25seVByb2ZpbGUocHJvZmlsZSk7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1ZpZXctb25seSBsb2dpbiBzdWNjZXNzZnVsOicsIHByb2ZpbGUubnB1Yik7XG4gICAgICAgICAgc2V0TmlwNDdDbGllbnQobnVsbCk7XG4gICAgICAgICAgc2V0UGF5bWVudENsaWVudChudWxsKTtcbiAgICAgICAgICBzZXRDYW5NYWtlUGF5bWVudHMoZmFsc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgbG9naW4gbWV0aG9kOiAke21ldGhvZH1gKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBMb2dpbiBlcnJvciAoJHttZXRob2R9KTpgLCBlKTtcbiAgICAgIHNldEVycm9yKGUgYXMgRXJyb3IpO1xuICAgICAgdGhyb3cgZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIEVuaGFuY2VkIGxvZ291dCBmdW5jdGlvblxuICBjb25zdCBsb2dvdXQgPSAoKSA9PiB7XG4gICAgY29uc29sZS5sb2coJ05vc3RyQ29udGV4dDogTG9nb3V0IGluaXRpYXRlZCcpO1xuICAgIFxuICAgIC8vIENsZWFuIHVwIGFueSBhY3RpdmUgc3Vic2NyaXB0aW9ucyBvciByZXNvdXJjZXMgaWYgbmVlZGVkXG4gICAgaWYgKG5kaykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIHNpZ25lciwgd2Ugc2hvdWxkIHJlc2V0IGl0XG4gICAgICAgIGlmIChuZGsuc2lnbmVyKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1Jlc2V0dGluZyBOREsgc2lnbmVyJyk7XG4gICAgICAgICAgbmRrLnNpZ25lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc29sZS5sb2coJ1VzZXIgcmVzb3VyY2VzIGNsZWFuZWQgdXAnKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGR1cmluZyBsb2dvdXQgY2xlYW51cDonLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIENsZWFuIHVwIE5JUC00NyBjbGllbnQgaWYgaXQgZXhpc3RzXG4gICAgaWYgKG5pcDQ3Q2xpZW50KSB7XG4gICAgICB0cnkge1xuICAgICAgICBuaXA0N0NsaWVudC5kaXNjb25uZWN0KCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRpc2Nvbm5lY3RpbmcgTklQLTQ3IGNsaWVudDonLCBlKTtcbiAgICAgIH1cbiAgICAgIHNldE5pcDQ3Q2xpZW50KG51bGwpO1xuICAgIH1cbiAgICBcbiAgICAvLyBDbGVhbiB1cCBwYXltZW50IGNsaWVudFxuICAgIHNldFBheW1lbnRDbGllbnQobnVsbCk7XG4gICAgc2V0Q2FuTWFrZVBheW1lbnRzKGZhbHNlKTtcbiAgICBcbiAgICAvLyBSZXNldCBhbGwgc3RhdGVcbiAgICBzZXRMb2dpbk1ldGhvZChudWxsKTtcbiAgICBzZXRWaWV3T25seVByb2ZpbGUobnVsbCk7XG4gICAgc2V0VXNlcihudWxsKTtcbiAgICBzZXRFcnJvcihudWxsKTtcbiAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICBcbiAgICBjb25zb2xlLmxvZygnTm9zdHJDb250ZXh0OiBMb2dvdXQgY29tcGxldGVkJyk7XG4gIH07XG5cbiAgLy8gR2V0IGEgdXNlcidzIHByb2ZpbGVcbiAgY29uc3QgZ2V0VXNlclByb2ZpbGUgPSBhc3luYyAobnB1Yjogc3RyaW5nKTogUHJvbWlzZTxOREtVc2VyIHwgbnVsbD4gPT4ge1xuICAgIGlmICghbmRrKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05ESyBub3QgaW5pdGlhbGl6ZWQnKTtcbiAgICB9XG5cbiAgICBjb25zdCB1c2VyID0gbmRrLmdldFVzZXIoeyBucHViIH0pO1xuICAgIGF3YWl0IHVzZXIuZmV0Y2hQcm9maWxlKCk7XG4gICAgcmV0dXJuIHVzZXI7XG4gIH07XG5cbiAgLy8gR2V0IHVzZXJzIHRoYXQgYSB1c2VyIGZvbGxvd3NcbiAgY29uc3QgZ2V0Rm9sbG93cyA9IGFzeW5jIChucHViOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZ1tdPiA9PiB7XG4gICAgaWYgKCFuZGspIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTkRLIG5vdCBpbml0aWFsaXplZCcpO1xuICAgIH1cblxuICAgIGNvbnN0IHVzZXIgPSBuZGsuZ2V0VXNlcih7IG5wdWIgfSk7XG4gICAgY29uc3QgZm9sbG93cyA9IGF3YWl0IHVzZXIuZm9sbG93cygpO1xuICAgIHJldHVybiBBcnJheS5mcm9tKGZvbGxvd3MpLm1hcChmb2xsb3cgPT4gZm9sbG93Lm5wdWIpO1xuICB9O1xuXG4gIC8vIFBheSBhIExpZ2h0bmluZyBpbnZvaWNlXG4gIGNvbnN0IHBheUludm9pY2UgPSBhc3luYyAoaW52b2ljZTogc3RyaW5nKTogUHJvbWlzZTxhbnk+ID0+IHtcbiAgICBpZiAoIXBheW1lbnRDbGllbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGF5bWVudCBjbGllbnQgbm90IGluaXRpYWxpemVkJyk7XG4gICAgfVxuICAgIFxuICAgIGlmICghY2FuTWFrZVBheW1lbnRzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BheW1lbnRzIG5vdCBzdXBwb3J0ZWQgd2l0aCBjdXJyZW50IGxvZ2luIG1ldGhvZCcpO1xuICAgIH1cbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBwYXltZW50Q2xpZW50LnBheUludm9pY2UoaW52b2ljZSk7XG4gICAgICBcbiAgICAgIGlmIChyZXNwb25zZS5lcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBheW1lbnQgZmFpbGVkOiAke3Jlc3BvbnNlLmVycm9yLm1lc3NhZ2V9YCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiByZXNwb25zZS5yZXN1bHQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1BheW1lbnQgZmFpbGVkOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfTtcblxuICAvLyBHZW5lcmF0ZSBzb2NpYWwgZ3JhcGggZGF0YSBmb3IgdGhlIHByb3ZpZGVkIE5QVUJzXG4gIGNvbnN0IGdldFNvY2lhbEdyYXBoID0gYXN5bmMgKG5wdWJzOiBzdHJpbmdbXSwgbWF4Q29ubmVjdGlvbnM6IG51bWJlciA9IDI1KSA9PiB7XG4gICAgaWYgKCFuZGspIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTkRLIG5vdCBpbml0aWFsaXplZCcpO1xuICAgIH1cbiAgICBcbiAgICBjb25zb2xlLmxvZyhgR2VuZXJhdGluZyBzb2NpYWwgZ3JhcGggZm9yICR7bnB1YnMubGVuZ3RofSBOUFVCcyB3aXRoIG1heCAke21heENvbm5lY3Rpb25zfSBjb25uZWN0aW9uc2ApO1xuICAgIFxuICAgIC8vIFRoaXMgaXMgYSBmcm9udC1lbmQgaW1wbGVtZW50YXRpb24gdGhhdCBjcmVhdGVzIG1vY2sgZGF0YVxuICAgIGNvbnN0IG5vZGVzOiBhbnlbXSA9IFtdO1xuICAgIGNvbnN0IGxpbmtzOiBhbnlbXSA9IFtdO1xuICAgIGNvbnN0IG5vZGVNYXAgPSBuZXcgTWFwPHN0cmluZywgYm9vbGVhbj4oKTtcbiAgICBcbiAgICAvLyBBZGQgdGhlIGNvcmUgTlBVQnMgYXMgbm9kZXNcbiAgICBmb3IgKGNvbnN0IG5wdWIgb2YgbnB1YnMpIHtcbiAgICAgIGlmIChub2RlTWFwLmhhcyhucHViKSkgY29udGludWU7XG4gICAgICBcbiAgICAgIC8vIFRyeSB0byBnZXQgdXNlciBwcm9maWxlIGlmIHBvc3NpYmxlXG4gICAgICBsZXQgbmFtZSA9ICcnO1xuICAgICAgbGV0IHBpY3R1cmUgPSAnJztcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHVzZXIgPSBuZGsuZ2V0VXNlcih7IG5wdWIgfSk7XG4gICAgICAgIGF3YWl0IHVzZXIuZmV0Y2hQcm9maWxlKCk7XG4gICAgICAgIG5hbWUgPSB1c2VyLnByb2ZpbGU/LmRpc3BsYXlOYW1lIHx8IHVzZXIucHJvZmlsZT8ubmFtZSB8fCAnJztcbiAgICAgICAgcGljdHVyZSA9IHVzZXIucHJvZmlsZT8ucGljdHVyZSB8fCAnJztcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBGYWlsZWQgdG8gZmV0Y2ggcHJvZmlsZSBmb3IgJHtucHVifWAsIGUpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBub2Rlcy5wdXNoKHtcbiAgICAgICAgaWQ6IG5wdWIsXG4gICAgICAgIG5wdWIsXG4gICAgICAgIG5hbWU6IG5hbWUgfHwgYFVzZXIgJHtucHViLnN1YnN0cmluZygwLCA4KX1gLFxuICAgICAgICB0eXBlOiAncHJvZmlsZScsXG4gICAgICAgIHBpY3R1cmUsXG4gICAgICAgIGlzQ29yZU5vZGU6IHRydWUsXG4gICAgICAgIHZhbDogMTAsXG4gICAgICAgIGdyb3VwOiAxXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgbm9kZU1hcC5zZXQobnB1YiwgdHJ1ZSk7XG4gICAgfVxuICAgIFxuICAgIC8vIEZvciBlYWNoIGNvcmUgTlBVQiwgY3JlYXRlIHNvbWUgbW9jayBjb25uZWN0aW9uc1xuICAgIGZvciAoY29uc3QgbnB1YiBvZiBucHVicykge1xuICAgICAgLy8gRm9yIHJlYWxpc3RpYyBkYXRhLCB3ZSdkIGZldGNoIGZvbGxvd3MgaGVyZVxuICAgICAgLy8gRm9yIHRoaXMgbW9jayB2ZXJzaW9uLCB3ZSdsbCBjcmVhdGUgcmFuZG9tIGNvbm5lY3Rpb25zXG4gICAgICBjb25zdCBjb25uZWN0aW9uQ291bnQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBtYXhDb25uZWN0aW9ucykgKyAzO1xuICAgICAgXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbm5lY3Rpb25Db3VudDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGZvbGxvd05wdWIgPSBgbnB1YiR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDE1KX1gO1xuICAgICAgICBcbiAgICAgICAgLy8gU2tpcCBpZiB3ZSBhbHJlYWR5IGhhdmUgdGhpcyBub2RlXG4gICAgICAgIGlmIChub2RlTWFwLmhhcyhmb2xsb3dOcHViKSkgY29udGludWU7XG4gICAgICAgIFxuICAgICAgICAvLyBBZGQgbm9kZVxuICAgICAgICBub2Rlcy5wdXNoKHtcbiAgICAgICAgICBpZDogZm9sbG93TnB1YixcbiAgICAgICAgICBucHViOiBmb2xsb3dOcHViLFxuICAgICAgICAgIG5hbWU6IGBDb25uZWN0aW9uICR7aX0gb2YgJHtucHViLnN1YnN0cmluZygwLCA4KX1gLFxuICAgICAgICAgIHR5cGU6ICdjb25uZWN0aW9uJyxcbiAgICAgICAgICBpc0NvcmVOb2RlOiBmYWxzZSxcbiAgICAgICAgICB2YWw6IDMsXG4gICAgICAgICAgZ3JvdXA6IDJcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBub2RlTWFwLnNldChmb2xsb3dOcHViLCB0cnVlKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEFkZCBjb25uZWN0aW9uXG4gICAgICAgIGxpbmtzLnB1c2goe1xuICAgICAgICAgIHNvdXJjZTogbnB1YixcbiAgICAgICAgICB0YXJnZXQ6IGZvbGxvd05wdWIsXG4gICAgICAgICAgdHlwZTogJ2ZvbGxvd3MnLFxuICAgICAgICAgIHZhbHVlOiAxXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBBZGQgc29tZSBjb25uZWN0aW9ucyBiZXR3ZWVuIGNvcmUgTlBVQnMgZm9yIGEgbW9yZSByZWFsaXN0aWMgZ3JhcGhcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5wdWJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBucHVicy5sZW5ndGg7IGorKykge1xuICAgICAgICBpZiAoTWF0aC5yYW5kb20oKSA+IDAuMykge1xuICAgICAgICAgIGxpbmtzLnB1c2goe1xuICAgICAgICAgICAgc291cmNlOiBucHVic1tpXSxcbiAgICAgICAgICAgIHRhcmdldDogbnB1YnNbal0sXG4gICAgICAgICAgICB0eXBlOiAnbXV0dWFsJyxcbiAgICAgICAgICAgIHZhbHVlOiAyXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHsgbm9kZXMsIGxpbmtzIH07XG4gIH07XG5cbiAgLy8gUHJvdmlkZSB0aGUgY29udGV4dCB2YWx1ZVxuICBjb25zdCBjb250ZXh0VmFsdWU6IE5vc3RyQ29udGV4dFR5cGUgPSB7XG4gICAgbmRrLFxuICAgIHVzZXIsXG4gICAgbG9hZGluZyxcbiAgICBlcnJvcixcbiAgICBsb2dpbk1ldGhvZCxcbiAgICB2aWV3T25seVByb2ZpbGUsXG4gICAgYXZhaWxhYmxlUHJvZmlsZXM6IFBSRURFRklORURfUFJPRklMRVMsXG4gICAgbG9naW4sXG4gICAgbG9nb3V0LFxuICAgIGdldFVzZXJQcm9maWxlLFxuICAgIGdldEZvbGxvd3MsXG4gICAgc2hvcnRlbk5wdWIsXG4gICAgcGF5SW52b2ljZTogY2FuTWFrZVBheW1lbnRzID8gcGF5SW52b2ljZSA6IHVuZGVmaW5lZCxcbiAgICBjYW5NYWtlUGF5bWVudHMsXG4gICAgZ2V0U29jaWFsR3JhcGgsXG4gIH07XG5cbiAgcmV0dXJuIChcbiAgICA8Tm9zdHJDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtjb250ZXh0VmFsdWV9PlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvTm9zdHJDb250ZXh0LlByb3ZpZGVyPlxuICApO1xufTtcblxuLy8gSG9vayB0byB1c2UgdGhlIE5vc3RyIGNvbnRleHRcbmV4cG9ydCBjb25zdCB1c2VOb3N0ciA9ICgpID0+IHtcbiAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQoTm9zdHJDb250ZXh0KTtcbiAgaWYgKGNvbnRleHQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcigndXNlTm9zdHIgbXVzdCBiZSB1c2VkIHdpdGhpbiBhIE5vc3RyUHJvdmlkZXInKTtcbiAgfVxuICByZXR1cm4gY29udGV4dDtcbn07ICJdLCJuYW1lcyI6WyJSZWFjdCIsImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJOREsiLCJOREtOaXAwN1NpZ25lciIsIm5pcDE5IiwiTklQNDdDbGllbnQiLCJOSVA0N1BheW1lbnRDbGllbnQiLCJzaG9ydGVuTnB1YiIsIm5wdWIiLCJzdWJzdHJpbmciLCJsZW5ndGgiLCJQUkVERUZJTkVEX1BST0ZJTEVTIiwicHVia2V5IiwibmFtZSIsImRpc3BsYXlOYW1lIiwicGljdHVyZSIsIk5vc3RyQ29udGV4dCIsInVuZGVmaW5lZCIsIk5vc3RyUHJvdmlkZXIiLCJjaGlsZHJlbiIsIm5kayIsInNldE5kayIsInVzZXIiLCJzZXRVc2VyIiwibG9hZGluZyIsInNldExvYWRpbmciLCJlcnJvciIsInNldEVycm9yIiwibG9naW5NZXRob2QiLCJzZXRMb2dpbk1ldGhvZCIsInZpZXdPbmx5UHJvZmlsZSIsInNldFZpZXdPbmx5UHJvZmlsZSIsIm5pcDQ3Q2xpZW50Iiwic2V0TmlwNDdDbGllbnQiLCJwYXltZW50Q2xpZW50Iiwic2V0UGF5bWVudENsaWVudCIsImNhbk1ha2VQYXltZW50cyIsInNldENhbk1ha2VQYXltZW50cyIsImluaXRpYWxpemVOREsiLCJleHBsaWNpdFJlbGF5VXJscyIsImNvbm5lY3QiLCJjb25zb2xlIiwibG9nIiwiZSIsImxvZ2luIiwibWV0aG9kIiwib3B0aW9ucyIsIkVycm9yIiwid2luZG93Iiwibm9zdHIiLCJzaWduZXIiLCJwdWJsaWNLZXkiLCJnZXRVc2VyIiwiZmV0Y2hQcm9maWxlIiwidGFyZ2V0Iiwic3RhcnRzV2l0aCIsInVybCIsIlVSTCIsInBhdGhuYW1lIiwibnB1YkVuY29kZSIsImNsaWVudCIsInJlbW90ZVB1YmtleSIsImdldFB1YmxpY0tleSIsInBheW1lbnRzIiwicGF5bWVudFN0YXR1cyIsImNoZWNrUGF5bWVudENhcGFiaWxpdHkiLCJjYW5QYXkiLCJ3YXJuIiwicmVhc29uIiwibWVzc2FnZSIsInByb2ZpbGUiLCJpbWFnZSIsImxvZ291dCIsImRpc2Nvbm5lY3QiLCJnZXRVc2VyUHJvZmlsZSIsImdldEZvbGxvd3MiLCJmb2xsb3dzIiwiQXJyYXkiLCJmcm9tIiwibWFwIiwiZm9sbG93IiwicGF5SW52b2ljZSIsImludm9pY2UiLCJyZXNwb25zZSIsInJlc3VsdCIsImdldFNvY2lhbEdyYXBoIiwibnB1YnMiLCJtYXhDb25uZWN0aW9ucyIsIm5vZGVzIiwibGlua3MiLCJub2RlTWFwIiwiTWFwIiwiaGFzIiwicHVzaCIsImlkIiwidHlwZSIsImlzQ29yZU5vZGUiLCJ2YWwiLCJncm91cCIsInNldCIsImNvbm5lY3Rpb25Db3VudCIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsImkiLCJmb2xsb3dOcHViIiwidG9TdHJpbmciLCJzb3VyY2UiLCJ2YWx1ZSIsImoiLCJjb250ZXh0VmFsdWUiLCJhdmFpbGFibGVQcm9maWxlcyIsIlByb3ZpZGVyIiwidXNlTm9zdHIiLCJjb250ZXh0Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/contexts/NostrContext.tsx\n"));

/***/ })

});