"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/community/page",{

/***/ "(app-pages-browser)/./src/lib/contexts/NostrContext.tsx":
/*!*******************************************!*\
  !*** ./src/lib/contexts/NostrContext.tsx ***!
  \*******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NostrProvider: () => (/* binding */ NostrProvider),\n/* harmony export */   PREDEFINED_PROFILES: () => (/* binding */ PREDEFINED_PROFILES),\n/* harmony export */   shortenNpub: () => (/* binding */ shortenNpub),\n/* harmony export */   useNostr: () => (/* binding */ useNostr)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @nostr-dev-kit/ndk */ \"(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/dist/index.mjs\");\n/* harmony import */ var nostr_tools__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! nostr-tools */ \"(app-pages-browser)/./node_modules/nostr-tools/lib/esm/index.js\");\n/* harmony import */ var _lib_nostr_nip47__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/lib/nostr/nip47 */ \"(app-pages-browser)/./src/lib/nostr/nip47.ts\");\n/* harmony import */ var _lib_nostr_nip47_payments__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/lib/nostr/nip47-payments */ \"(app-pages-browser)/./src/lib/nostr/nip47-payments.ts\");\n/* __next_internal_client_entry_do_not_use__ shortenNpub,PREDEFINED_PROFILES,NostrProvider,useNostr auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\n\n\n\n// Utility function to shorten npub for display\nconst shortenNpub = (npub)=>{\n    if (!npub) return '';\n    return \"\".concat(npub.substring(0, 8), \"...\").concat(npub.substring(npub.length - 4));\n};\n// List of predefined profiles for view only mode\nconst PREDEFINED_PROFILES = [\n    {\n        // MadTrips official profile\n        pubkey: '9a0a16254ff0dd29bbe45aeea9b8d80c0b9537d879a93f2589bbacedc4db166e',\n        npub: 'npub14jrvanj69ulfxc92pqsunvv220xhwtn6pukpmgpqzg6xl6wmaflqnx6nvs',\n        name: 'MadTrips_Official',\n        displayName: 'MadTrips (View Only)',\n        picture: '/assets/nostr-icon-purple-transparent-256x256.png'\n    }\n];\n// Create the context\nconst NostrContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\n// Provider component\nconst NostrProvider = (param)=>{\n    let { children } = param;\n    _s();\n    const [ndk, setNdk] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [user, setUser] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [loginMethod, setLoginMethod] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [viewOnlyProfile, setViewOnlyProfile] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [nip47Client, setNip47Client] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [paymentClient, setPaymentClient] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [canMakePayments, setCanMakePayments] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Initialize NDK on component mount\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"NostrProvider.useEffect\": ()=>{\n            const initializeNDK = {\n                \"NostrProvider.useEffect.initializeNDK\": async ()=>{\n                    try {\n                        // Check if window is defined (only in browser)\n                        if (true) {\n                            // Create a new NDK instance without a signer initially\n                            const ndk = new _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__[\"default\"]({\n                                explicitRelayUrls: [\n                                    'wss://relay.damus.io',\n                                    'wss://relay.nostr.band',\n                                    'wss://nos.lol',\n                                    'wss://relay.current.fyi',\n                                    'wss://relay.snort.social'\n                                ]\n                            });\n                            // Connect to relays\n                            await ndk.connect();\n                            setNdk(ndk);\n                            console.log('NDK initialized without signer');\n                            setLoading(false);\n                        }\n                    } catch (e) {\n                        console.error('Failed to initialize NDK:', e);\n                        setError(e);\n                        setLoading(false);\n                    }\n                }\n            }[\"NostrProvider.useEffect.initializeNDK\"];\n            initializeNDK();\n        }\n    }[\"NostrProvider.useEffect\"], []);\n    // Login function that handles different methods\n    const login = async (method, options)=>{\n        if (!ndk) {\n            throw new Error('NDK not initialized');\n        }\n        setLoading(true);\n        setError(null);\n        try {\n            switch(method){\n                case 'nip07':\n                    {\n                        // Browser extension login (NIP-07)\n                        if ( false || !window.nostr) {\n                            throw new Error('No NIP-07 compatible browser extension found');\n                        }\n                        // Create a signer that uses the window.nostr API (extension)\n                        ndk.signer = new _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKNip07Signer();\n                        // Get the user's public key\n                        const publicKey = await ndk.signer.user();\n                        if (!publicKey) {\n                            throw new Error('Failed to get public key from extension');\n                        }\n                        // Create an NDKUser from the public key\n                        const user = ndk.getUser({\n                            npub: publicKey.npub\n                        });\n                        // Fetch the user's profile\n                        await user.fetchProfile();\n                        setUser(user);\n                        setLoginMethod('nip07');\n                        setViewOnlyProfile(null);\n                        console.log('NIP-07 login successful:', user.npub);\n                        setCanMakePayments(false); // NIP-07 can't make payments by default\n                        break;\n                    }\n                case 'nip47':\n                    {\n                        // Remote signer login (NIP-47)\n                        if (!options || !options.target) {\n                            throw new Error('NIP-47 connection requires a target URL');\n                        }\n                        console.log('NIP-47 login requested to:', options.target);\n                        // For future implementation, we've created a NIP-47 client in @/lib/nostr/nip47.ts\n                        // but are providing a simplified implementation here for now\n                        try {\n                            // For demo purposes, we'll create a read-only profile from the target\n                            let npub = options.target;\n                            // If the target is a nostrconnect:// URL, extract the npub\n                            if (npub.startsWith('nostrconnect://')) {\n                                const url = new URL(npub);\n                                npub = url.pathname.substring(1); // Remove leading slash\n                                if (npub.startsWith('npub1')) {\n                                // Use as is\n                                } else {\n                                    // Convert hex to npub if needed\n                                    npub = nostr_tools__WEBPACK_IMPORTED_MODULE_5__.nip19.npubEncode(npub);\n                                }\n                            } else if (!npub.startsWith('npub1')) {\n                                // If it's a hex key, convert to npub\n                                npub = nostr_tools__WEBPACK_IMPORTED_MODULE_5__.nip19.npubEncode(npub);\n                            }\n                            // Create an NDKUser from the pubkey\n                            const user = ndk.getUser({\n                                npub\n                            });\n                            // Create NIP-47 client\n                            const client = new _lib_nostr_nip47__WEBPACK_IMPORTED_MODULE_3__.NIP47Client(options.target);\n                            // Connect to the remote signer\n                            await client.connect();\n                            // Get the public key\n                            const remotePubkey = await client.getPublicKey();\n                            // Create the payment client\n                            const payments = new _lib_nostr_nip47_payments__WEBPACK_IMPORTED_MODULE_4__.NIP47PaymentClient(client);\n                            // Check if payments are supported\n                            const paymentStatus = await payments.checkPaymentCapability();\n                            // Store the clients for later use\n                            setNip47Client(client);\n                            setPaymentClient(payments);\n                            setCanMakePayments(paymentStatus.canPay);\n                            // Attempt to fetch profile data\n                            try {\n                                await user.fetchProfile();\n                            } catch (e) {\n                                console.warn('Could not fetch profile for remote signer:', e);\n                            }\n                            setUser(user);\n                            setLoginMethod('nip47');\n                            setViewOnlyProfile(null);\n                            console.log('NIP-47 login successful:', user.npub);\n                            console.log('Payment capability:', paymentStatus.canPay ? 'Enabled' : 'Disabled');\n                            if (!paymentStatus.canPay) {\n                                console.warn('Payment not available:', paymentStatus.reason);\n                            }\n                        } catch (error) {\n                            console.error('NIP-47 login error:', error);\n                            throw new Error(\"NIP-47 login failed: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n                        }\n                        break;\n                    }\n                case 'viewonly':\n                    {\n                        // View-only login with a predefined profile\n                        if (!options || !options.profile) {\n                            throw new Error('View-only login requires a profile');\n                        }\n                        const profile = options.profile;\n                        // Create an NDKUser from the public key\n                        const user = ndk.getUser({\n                            npub: profile.npub\n                        });\n                        // For view-only, we can still fetch their profile data\n                        try {\n                            await user.fetchProfile();\n                        } catch (e) {\n                            console.warn('Could not fetch profile for view-only user, using predefined data');\n                            // Use the predefined profile data\n                            user.profile = {\n                                name: profile.name,\n                                displayName: profile.displayName,\n                                image: profile.picture\n                            };\n                        }\n                        setUser(user);\n                        setLoginMethod('viewonly');\n                        setViewOnlyProfile(profile);\n                        console.log('View-only login successful:', profile.npub);\n                        setNip47Client(null);\n                        setPaymentClient(null);\n                        setCanMakePayments(false);\n                        break;\n                    }\n                default:\n                    throw new Error(\"Unsupported login method: \".concat(method));\n            }\n        } catch (e) {\n            console.error(\"Login error (\".concat(method, \"):\"), e);\n            setError(e);\n            throw e;\n        } finally{\n            setLoading(false);\n        }\n    };\n    // Enhanced logout function\n    const logout = ()=>{\n        console.log('NostrContext: Logout initiated');\n        // Clean up any active subscriptions or resources if needed\n        if (ndk) {\n            try {\n                // If we have a signer, we should reset it\n                if (ndk.signer) {\n                    console.log('Resetting NDK signer');\n                    ndk.signer = undefined;\n                }\n                console.log('User resources cleaned up');\n            } catch (error) {\n                console.error('Error during logout cleanup:', error);\n            }\n        }\n        // Clean up NIP-47 client if it exists\n        if (nip47Client) {\n            try {\n                nip47Client.disconnect();\n            } catch (e) {\n                console.error('Error disconnecting NIP-47 client:', e);\n            }\n            setNip47Client(null);\n        }\n        // Clean up payment client\n        setPaymentClient(null);\n        setCanMakePayments(false);\n        // Reset all state\n        setLoginMethod(null);\n        setViewOnlyProfile(null);\n        setUser(null);\n        setError(null);\n        setLoading(false);\n        console.log('NostrContext: Logout completed');\n    };\n    // Get a user's profile\n    const getUserProfile = async (npub)=>{\n        if (!ndk) {\n            throw new Error('NDK not initialized');\n        }\n        const user = ndk.getUser({\n            npub\n        });\n        await user.fetchProfile();\n        return user;\n    };\n    // Get users that a user follows\n    const getFollows = async (npub)=>{\n        if (!ndk) {\n            throw new Error('NDK not initialized');\n        }\n        const user = ndk.getUser({\n            npub\n        });\n        const follows = await user.follows();\n        return Array.from(follows).map((follow)=>follow.npub);\n    };\n    // Pay a Lightning invoice\n    const payInvoice = async (invoice)=>{\n        if (!paymentClient) {\n            throw new Error('Payment client not initialized');\n        }\n        if (!canMakePayments) {\n            throw new Error('Payments not supported with current login method');\n        }\n        try {\n            const response = await paymentClient.payInvoice(invoice);\n            if (response.error) {\n                throw new Error(\"Payment failed: \".concat(response.error.message));\n            }\n            return response.result;\n        } catch (error) {\n            console.error('Payment failed:', error);\n            throw error;\n        }\n    };\n    // Generate social graph data for the provided NPUBs\n    const getSocialGraph = async function(npubs) {\n        let maxConnections = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 25;\n        var _ndk_pool;\n        if (!ndk) {\n            throw new Error('NDK not initialized');\n        }\n        // Check relay connections\n        const connectedRelays = ((_ndk_pool = ndk.pool) === null || _ndk_pool === void 0 ? void 0 : _ndk_pool.getConnectedRelays()) || [];\n        if (connectedRelays.length === 0) {\n            console.warn('No connected relays. Attempting to connect...');\n            try {\n                var _ndk_pool1;\n                // Attempt to reconnect\n                await ndk.connect();\n                // Check again\n                const reconnectedRelays = ((_ndk_pool1 = ndk.pool) === null || _ndk_pool1 === void 0 ? void 0 : _ndk_pool1.getConnectedRelays()) || [];\n                if (reconnectedRelays.length === 0) {\n                    throw new Error('Failed to connect to any relays');\n                }\n                console.log(\"Successfully connected to \".concat(reconnectedRelays.length, \" relays\"));\n            } catch (error) {\n                console.error('Relay connection error:', error);\n                throw new Error('Failed to connect to Nostr relays. Please check your internet connection.');\n            }\n        }\n        console.log(\"Fetching social graph for \".concat(npubs.length, \" NPUBs with max \").concat(maxConnections, \" connections from \").concat(connectedRelays.length, \" relays\"));\n        // Real implementation using actual Nostr data\n        const nodes = [];\n        const links = [];\n        const nodeMap = new Map();\n        // Create a timeout promise\n        const timeout = (ms)=>new Promise((_, reject)=>setTimeout(()=>reject(new Error(\"Operation timed out after \".concat(ms, \"ms\"))), ms));\n        // Add the core NPUBs as nodes\n        for (const npub of npubs){\n            if (nodeMap.has(npub)) continue;\n            try {\n                var _user_profile, _user_profile1, _user_profile2, _user_profile3;\n                // Get the actual user profile from Nostr with timeout\n                const user = ndk.getUser({\n                    npub\n                });\n                // Set timeout for profile fetching to avoid hanging\n                const profilePromise = user.fetchProfile();\n                await Promise.race([\n                    profilePromise,\n                    timeout(10000) // 10 second timeout\n                ]);\n                console.log(\"Fetched profile for \".concat(npub, \": \").concat(((_user_profile = user.profile) === null || _user_profile === void 0 ? void 0 : _user_profile.name) || 'unnamed'));\n                nodes.push({\n                    id: npub,\n                    npub,\n                    name: ((_user_profile1 = user.profile) === null || _user_profile1 === void 0 ? void 0 : _user_profile1.displayName) || ((_user_profile2 = user.profile) === null || _user_profile2 === void 0 ? void 0 : _user_profile2.name) || shortenNpub(npub),\n                    type: 'profile',\n                    picture: ((_user_profile3 = user.profile) === null || _user_profile3 === void 0 ? void 0 : _user_profile3.picture) || '',\n                    isCoreNode: true,\n                    val: 10,\n                    group: 1\n                });\n                nodeMap.set(npub, true);\n            } catch (e) {\n                console.error(\"Failed to fetch profile for \".concat(npub), e);\n                // Still add the node even if profile fetch fails\n                nodes.push({\n                    id: npub,\n                    npub,\n                    name: shortenNpub(npub),\n                    type: 'profile',\n                    isCoreNode: true,\n                    val: 10,\n                    group: 1\n                });\n                nodeMap.set(npub, true);\n            }\n        }\n        // Fetch real follows for each core NPUB\n        for (const npub of npubs){\n            try {\n                // Get the actual follows from Nostr with timeout\n                const user = ndk.getUser({\n                    npub\n                });\n                // Set timeout for follows fetching to avoid hanging\n                const followsPromise = user.follows();\n                const follows = await Promise.race([\n                    followsPromise,\n                    timeout(15000) // 15 second timeout\n                ]);\n                console.log(\"Fetched \".concat(follows.size, \" follows for \").concat(npub));\n                // Limit to maxConnections if needed\n                const followsList = Array.from(follows).slice(0, maxConnections);\n                // Process each follow\n                for (const followedUser of followsList){\n                    const followedNpub = followedUser.npub;\n                    // Skip if already processed\n                    if (nodeMap.has(followedNpub)) {\n                        // Still add connection if not already added\n                        links.push({\n                            source: npub,\n                            target: followedNpub,\n                            type: 'follows',\n                            value: 1\n                        });\n                        continue;\n                    }\n                    // Try to get profile information for the followed user\n                    try {\n                        var _followedUser_profile, _followedUser_profile1, _followedUser_profile2;\n                        // Set timeout for profile fetching\n                        const profilePromise = followedUser.fetchProfile();\n                        await Promise.race([\n                            profilePromise,\n                            timeout(5000) // 5 second timeout for follows' profiles\n                        ]);\n                        nodes.push({\n                            id: followedNpub,\n                            npub: followedNpub,\n                            name: ((_followedUser_profile = followedUser.profile) === null || _followedUser_profile === void 0 ? void 0 : _followedUser_profile.displayName) || ((_followedUser_profile1 = followedUser.profile) === null || _followedUser_profile1 === void 0 ? void 0 : _followedUser_profile1.name) || shortenNpub(followedNpub),\n                            type: 'connection',\n                            picture: ((_followedUser_profile2 = followedUser.profile) === null || _followedUser_profile2 === void 0 ? void 0 : _followedUser_profile2.picture) || '',\n                            isCoreNode: false,\n                            val: 3,\n                            group: 2\n                        });\n                    } catch (e) {\n                        console.warn(\"Failed to fetch profile for follow \".concat(followedNpub), e);\n                        nodes.push({\n                            id: followedNpub,\n                            npub: followedNpub,\n                            name: shortenNpub(followedNpub),\n                            type: 'connection',\n                            isCoreNode: false,\n                            val: 3,\n                            group: 2\n                        });\n                    }\n                    nodeMap.set(followedNpub, true);\n                    // Add connection\n                    links.push({\n                        source: npub,\n                        target: followedNpub,\n                        type: 'follows',\n                        value: 1\n                    });\n                }\n                // Check for mutual follows between core NPUBs (real connections)\n                const followedPubkeys = new Set(followsList.map((f)=>f.npub));\n                // For each other core NPUB, check if this NPUB follows it\n                for (const otherNpub of npubs){\n                    if (otherNpub !== npub && followedPubkeys.has(otherNpub)) {\n                        links.push({\n                            source: npub,\n                            target: otherNpub,\n                            type: 'mutual',\n                            value: 2\n                        });\n                    }\n                }\n            } catch (e) {\n                console.error(\"Failed to fetch follows for \".concat(npub), e);\n            }\n        }\n        console.log(\"Completed social graph with \".concat(nodes.length, \" nodes and \").concat(links.length, \" links\"));\n        return {\n            nodes,\n            links\n        };\n    };\n    // Provide the context value\n    const contextValue = {\n        ndk,\n        user,\n        loading,\n        error,\n        loginMethod,\n        viewOnlyProfile,\n        availableProfiles: PREDEFINED_PROFILES,\n        login,\n        logout,\n        getUserProfile,\n        getFollows,\n        shortenNpub,\n        payInvoice: canMakePayments ? payInvoice : undefined,\n        canMakePayments,\n        getSocialGraph\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(NostrContext.Provider, {\n        value: contextValue,\n        children: children\n    }, void 0, false, {\n        fileName: \"/home/lfg/Git/Madtrips/src/lib/contexts/NostrContext.tsx\",\n        lineNumber: 563,\n        columnNumber: 5\n    }, undefined);\n};\n_s(NostrProvider, \"XXmHTZ3akXfpNIfxEerd+v4DDso=\");\n_c = NostrProvider;\n// Hook to use the Nostr context\nconst useNostr = ()=>{\n    _s1();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(NostrContext);\n    if (context === undefined) {\n        throw new Error('useNostr must be used within a NostrProvider');\n    }\n    return context;\n};\n_s1(useNostr, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"NostrProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvY29udGV4dHMvTm9zdHJDb250ZXh0LnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBRXlGO0FBQ1c7QUFDaEQ7QUFDaEI7QUFDWTtBQUNnQjtBQUdoRSwrQ0FBK0M7QUFDeEMsTUFBTVUsY0FBYyxDQUFDQztJQUMxQixJQUFJLENBQUNBLE1BQU0sT0FBTztJQUNsQixPQUFPLEdBQTZCQSxPQUExQkEsS0FBS0MsU0FBUyxDQUFDLEdBQUcsSUFBRyxPQUFxQyxPQUFoQ0QsS0FBS0MsU0FBUyxDQUFDRCxLQUFLRSxNQUFNLEdBQUc7QUFDbkUsRUFBRTtBQUVGLGlEQUFpRDtBQUMxQyxNQUFNQyxzQkFBeUM7SUFDcEQ7UUFDRSw0QkFBNEI7UUFDNUJDLFFBQVE7UUFDUkosTUFBTTtRQUNOSyxNQUFNO1FBQ05DLGFBQWE7UUFDYkMsU0FBUztJQUNYO0NBQ0QsQ0FBQztBQStCRixxQkFBcUI7QUFDckIsTUFBTUMsNkJBQWVsQixvREFBYUEsQ0FBK0JtQjtBQUVqRSxxQkFBcUI7QUFDZCxNQUFNQyxnQkFBaUQ7UUFBQyxFQUFFQyxRQUFRLEVBQUU7O0lBQ3pFLE1BQU0sQ0FBQ0MsS0FBS0MsT0FBTyxHQUFHckIsK0NBQVFBLENBQWE7SUFDM0MsTUFBTSxDQUFDc0IsTUFBTUMsUUFBUSxHQUFHdkIsK0NBQVFBLENBQWlCO0lBQ2pELE1BQU0sQ0FBQ3dCLFNBQVNDLFdBQVcsR0FBR3pCLCtDQUFRQSxDQUFDO0lBQ3ZDLE1BQU0sQ0FBQzBCLE9BQU9DLFNBQVMsR0FBRzNCLCtDQUFRQSxDQUFlO0lBQ2pELE1BQU0sQ0FBQzRCLGFBQWFDLGVBQWUsR0FBRzdCLCtDQUFRQSxDQUFxQjtJQUNuRSxNQUFNLENBQUM4QixpQkFBaUJDLG1CQUFtQixHQUFHL0IsK0NBQVFBLENBQXlCO0lBQy9FLE1BQU0sQ0FBQ2dDLGFBQWFDLGVBQWUsR0FBR2pDLCtDQUFRQSxDQUFxQjtJQUNuRSxNQUFNLENBQUNrQyxlQUFlQyxp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TSxJQUFJOEIsTUFBTTtJQUNsQjtJQUNBLE9BQU9pRjtBQUNULEVBQUU7SUFOV0QiLCJzb3VyY2VzIjpbIi9ob21lL2xmZy9HaXQvTWFkdHJpcHMvc3JjL2xpYi9jb250ZXh0cy9Ob3N0ckNvbnRleHQudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcblxuaW1wb3J0IFJlYWN0LCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZVN0YXRlLCB1c2VFZmZlY3QsIFJlYWN0Tm9kZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBOREssIHsgTkRLRXZlbnQsIE5ES1VzZXIsIE5ES0ZpbHRlciwgTkRLU3Vic2NyaXB0aW9uLCBOb3N0ckV2ZW50IH0gZnJvbSAnQG5vc3RyLWRldi1raXQvbmRrJztcbmltcG9ydCB7IE5ES05pcDA3U2lnbmVyIH0gZnJvbSAnQG5vc3RyLWRldi1raXQvbmRrJztcbmltcG9ydCB7IG5pcDE5IH0gZnJvbSAnbm9zdHItdG9vbHMnO1xuaW1wb3J0IHsgTklQNDdDbGllbnQgfSBmcm9tICdAL2xpYi9ub3N0ci9uaXA0Nyc7XG5pbXBvcnQgeyBOSVA0N1BheW1lbnRDbGllbnQgfSBmcm9tICdAL2xpYi9ub3N0ci9uaXA0Ny1wYXltZW50cyc7XG5pbXBvcnQgeyBOREtOaXA0NlNpZ25lciB9IGZyb20gJ0Bub3N0ci1kZXYta2l0L25kayc7XG5cbi8vIFV0aWxpdHkgZnVuY3Rpb24gdG8gc2hvcnRlbiBucHViIGZvciBkaXNwbGF5XG5leHBvcnQgY29uc3Qgc2hvcnRlbk5wdWIgPSAobnB1Yjogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAgaWYgKCFucHViKSByZXR1cm4gJyc7XG4gIHJldHVybiBgJHtucHViLnN1YnN0cmluZygwLCA4KX0uLi4ke25wdWIuc3Vic3RyaW5nKG5wdWIubGVuZ3RoIC0gNCl9YDtcbn07XG5cbi8vIExpc3Qgb2YgcHJlZGVmaW5lZCBwcm9maWxlcyBmb3IgdmlldyBvbmx5IG1vZGVcbmV4cG9ydCBjb25zdCBQUkVERUZJTkVEX1BST0ZJTEVTOiBWaWV3T25seVByb2ZpbGVbXSA9IFtcbiAge1xuICAgIC8vIE1hZFRyaXBzIG9mZmljaWFsIHByb2ZpbGVcbiAgICBwdWJrZXk6ICc5YTBhMTYyNTRmZjBkZDI5YmJlNDVhZWVhOWI4ZDgwYzBiOTUzN2Q4NzlhOTNmMjU4OWJiYWNlZGM0ZGIxNjZlJywgXG4gICAgbnB1YjogJ25wdWIxNGpydmFuajY5dWxmeGM5MnBxc3VudnYyMjB4aHd0bjZwdWtwbWdwcXpnNnhsNndtYWZscW54Nm52cycsXG4gICAgbmFtZTogJ01hZFRyaXBzX09mZmljaWFsJyxcbiAgICBkaXNwbGF5TmFtZTogJ01hZFRyaXBzIChWaWV3IE9ubHkpJyxcbiAgICBwaWN0dXJlOiAnL2Fzc2V0cy9ub3N0ci1pY29uLXB1cnBsZS10cmFuc3BhcmVudC0yNTZ4MjU2LnBuZydcbiAgfVxuXTtcblxuLy8gRGVmaW5lIHR5cGVzIGZvciBvdXIgY29udGV4dFxuaW50ZXJmYWNlIFZpZXdPbmx5UHJvZmlsZSB7XG4gIHB1YmtleTogc3RyaW5nO1xuICBucHViOiBzdHJpbmc7XG4gIG5hbWU/OiBzdHJpbmc7XG4gIGRpc3BsYXlOYW1lPzogc3RyaW5nO1xuICBwaWN0dXJlPzogc3RyaW5nO1xufVxuXG50eXBlIExvZ2luTWV0aG9kID0gJ25pcDA3JyB8ICduaXA0NycgfCAndmlld29ubHknO1xuXG5pbnRlcmZhY2UgTm9zdHJDb250ZXh0VHlwZSB7XG4gIG5kazogTkRLIHwgbnVsbDtcbiAgdXNlcjogTkRLVXNlciB8IG51bGw7XG4gIGxvYWRpbmc6IGJvb2xlYW47XG4gIGVycm9yOiBFcnJvciB8IG51bGw7XG4gIGxvZ2luTWV0aG9kOiBMb2dpbk1ldGhvZCB8IG51bGw7XG4gIHZpZXdPbmx5UHJvZmlsZTogVmlld09ubHlQcm9maWxlIHwgbnVsbDtcbiAgYXZhaWxhYmxlUHJvZmlsZXM6IFZpZXdPbmx5UHJvZmlsZVtdO1xuICBsb2dpbjogKG1ldGhvZDogTG9naW5NZXRob2QsIG9wdGlvbnM/OiBhbnkpID0+IFByb21pc2U8dm9pZD47XG4gIGxvZ291dDogKCkgPT4gdm9pZDtcbiAgZ2V0VXNlclByb2ZpbGU6IChucHViOiBzdHJpbmcpID0+IFByb21pc2U8TkRLVXNlciB8IG51bGw+O1xuICBnZXRGb2xsb3dzOiAobnB1Yjogc3RyaW5nKSA9PiBQcm9taXNlPHN0cmluZ1tdPjtcbiAgc2hvcnRlbk5wdWI6IChucHViOiBzdHJpbmcpID0+IHN0cmluZztcbiAgcGF5SW52b2ljZT86IChpbnZvaWNlOiBzdHJpbmcpID0+IFByb21pc2U8YW55PjtcbiAgY2FuTWFrZVBheW1lbnRzOiBib29sZWFuO1xuICBnZXRTb2NpYWxHcmFwaDogKG5wdWJzOiBzdHJpbmdbXSwgbWF4Q29ubmVjdGlvbnM/OiBudW1iZXIpID0+IFByb21pc2U8e25vZGVzOiBhbnlbXSwgbGlua3M6IGFueVtdfT47XG59XG5cbi8vIENyZWF0ZSB0aGUgY29udGV4dFxuY29uc3QgTm9zdHJDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxOb3N0ckNvbnRleHRUeXBlIHwgdW5kZWZpbmVkPih1bmRlZmluZWQpO1xuXG4vLyBQcm92aWRlciBjb21wb25lbnRcbmV4cG9ydCBjb25zdCBOb3N0clByb3ZpZGVyOiBSZWFjdC5GQzx7Y2hpbGRyZW46IFJlYWN0Tm9kZX0+ID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICBjb25zdCBbbmRrLCBzZXROZGtdID0gdXNlU3RhdGU8TkRLIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFt1c2VyLCBzZXRVc2VyXSA9IHVzZVN0YXRlPE5ES1VzZXIgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2xvYWRpbmcsIHNldExvYWRpbmddID0gdXNlU3RhdGUodHJ1ZSk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8RXJyb3IgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2xvZ2luTWV0aG9kLCBzZXRMb2dpbk1ldGhvZF0gPSB1c2VTdGF0ZTxMb2dpbk1ldGhvZCB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbdmlld09ubHlQcm9maWxlLCBzZXRWaWV3T25seVByb2ZpbGVdID0gdXNlU3RhdGU8Vmlld09ubHlQcm9maWxlIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtuaXA0N0NsaWVudCwgc2V0TmlwNDdDbGllbnRdID0gdXNlU3RhdGU8TklQNDdDbGllbnQgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW3BheW1lbnRDbGllbnQsIHNldFBheW1lbnRDbGllbnRdID0gdXNlU3RhdGU8TklQNDdQYXltZW50Q2xpZW50IHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtjYW5NYWtlUGF5bWVudHMsIHNldENhbk1ha2VQYXltZW50c10gPSB1c2VTdGF0ZShmYWxzZSk7XG5cbiAgLy8gSW5pdGlhbGl6ZSBOREsgb24gY29tcG9uZW50IG1vdW50XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgaW5pdGlhbGl6ZU5ESyA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIENoZWNrIGlmIHdpbmRvdyBpcyBkZWZpbmVkIChvbmx5IGluIGJyb3dzZXIpXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyBOREsgaW5zdGFuY2Ugd2l0aG91dCBhIHNpZ25lciBpbml0aWFsbHlcbiAgICAgICAgICBjb25zdCBuZGsgPSBuZXcgTkRLKHtcbiAgICAgICAgICAgIGV4cGxpY2l0UmVsYXlVcmxzOiBbXG4gICAgICAgICAgICAgICd3c3M6Ly9yZWxheS5kYW11cy5pbycsXG4gICAgICAgICAgICAgICd3c3M6Ly9yZWxheS5ub3N0ci5iYW5kJyxcbiAgICAgICAgICAgICAgJ3dzczovL25vcy5sb2wnLFxuICAgICAgICAgICAgICAnd3NzOi8vcmVsYXkuY3VycmVudC5meWknLFxuICAgICAgICAgICAgICAnd3NzOi8vcmVsYXkuc25vcnQuc29jaWFsJyxcbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIENvbm5lY3QgdG8gcmVsYXlzXG4gICAgICAgICAgYXdhaXQgbmRrLmNvbm5lY3QoKTtcbiAgICAgICAgICBzZXROZGsobmRrKTtcbiAgICAgICAgICBjb25zb2xlLmxvZygnTkRLIGluaXRpYWxpemVkIHdpdGhvdXQgc2lnbmVyJyk7XG4gICAgICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGluaXRpYWxpemUgTkRLOicsIGUpO1xuICAgICAgICBzZXRFcnJvcihlIGFzIEVycm9yKTtcbiAgICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGluaXRpYWxpemVOREsoKTtcbiAgfSwgW10pO1xuXG4gIC8vIExvZ2luIGZ1bmN0aW9uIHRoYXQgaGFuZGxlcyBkaWZmZXJlbnQgbWV0aG9kc1xuICBjb25zdCBsb2dpbiA9IGFzeW5jIChtZXRob2Q6IExvZ2luTWV0aG9kLCBvcHRpb25zPzogYW55KSA9PiB7XG4gICAgaWYgKCFuZGspIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTkRLIG5vdCBpbml0aWFsaXplZCcpO1xuICAgIH1cblxuICAgIHNldExvYWRpbmcodHJ1ZSk7XG4gICAgc2V0RXJyb3IobnVsbCk7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICAgIGNhc2UgJ25pcDA3Jzoge1xuICAgICAgICAgIC8vIEJyb3dzZXIgZXh0ZW5zaW9uIGxvZ2luIChOSVAtMDcpXG4gICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICF3aW5kb3cubm9zdHIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gTklQLTA3IGNvbXBhdGlibGUgYnJvd3NlciBleHRlbnNpb24gZm91bmQnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ3JlYXRlIGEgc2lnbmVyIHRoYXQgdXNlcyB0aGUgd2luZG93Lm5vc3RyIEFQSSAoZXh0ZW5zaW9uKVxuICAgICAgICAgIG5kay5zaWduZXIgPSBuZXcgTkRLTmlwMDdTaWduZXIoKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBHZXQgdGhlIHVzZXIncyBwdWJsaWMga2V5XG4gICAgICAgICAgY29uc3QgcHVibGljS2V5ID0gYXdhaXQgbmRrLnNpZ25lci51c2VyKCk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKCFwdWJsaWNLZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGdldCBwdWJsaWMga2V5IGZyb20gZXh0ZW5zaW9uJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIENyZWF0ZSBhbiBOREtVc2VyIGZyb20gdGhlIHB1YmxpYyBrZXlcbiAgICAgICAgICBjb25zdCB1c2VyID0gbmRrLmdldFVzZXIoeyBucHViOiBwdWJsaWNLZXkubnB1YiB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBGZXRjaCB0aGUgdXNlcidzIHByb2ZpbGVcbiAgICAgICAgICBhd2FpdCB1c2VyLmZldGNoUHJvZmlsZSgpO1xuICAgICAgICAgIFxuICAgICAgICAgIHNldFVzZXIodXNlcik7XG4gICAgICAgICAgc2V0TG9naW5NZXRob2QoJ25pcDA3Jyk7XG4gICAgICAgICAgc2V0Vmlld09ubHlQcm9maWxlKG51bGwpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdOSVAtMDcgbG9naW4gc3VjY2Vzc2Z1bDonLCB1c2VyLm5wdWIpO1xuICAgICAgICAgIHNldENhbk1ha2VQYXltZW50cyhmYWxzZSk7IC8vIE5JUC0wNyBjYW4ndCBtYWtlIHBheW1lbnRzIGJ5IGRlZmF1bHRcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY2FzZSAnbmlwNDcnOiB7XG4gICAgICAgICAgLy8gUmVtb3RlIHNpZ25lciBsb2dpbiAoTklQLTQ3KVxuICAgICAgICAgIGlmICghb3B0aW9ucyB8fCAhb3B0aW9ucy50YXJnZXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTklQLTQ3IGNvbm5lY3Rpb24gcmVxdWlyZXMgYSB0YXJnZXQgVVJMJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc29sZS5sb2coJ05JUC00NyBsb2dpbiByZXF1ZXN0ZWQgdG86Jywgb3B0aW9ucy50YXJnZXQpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEZvciBmdXR1cmUgaW1wbGVtZW50YXRpb24sIHdlJ3ZlIGNyZWF0ZWQgYSBOSVAtNDcgY2xpZW50IGluIEAvbGliL25vc3RyL25pcDQ3LnRzXG4gICAgICAgICAgLy8gYnV0IGFyZSBwcm92aWRpbmcgYSBzaW1wbGlmaWVkIGltcGxlbWVudGF0aW9uIGhlcmUgZm9yIG5vd1xuICAgICAgICAgIFxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBGb3IgZGVtbyBwdXJwb3Nlcywgd2UnbGwgY3JlYXRlIGEgcmVhZC1vbmx5IHByb2ZpbGUgZnJvbSB0aGUgdGFyZ2V0XG4gICAgICAgICAgICBsZXQgbnB1YiA9IG9wdGlvbnMudGFyZ2V0O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBJZiB0aGUgdGFyZ2V0IGlzIGEgbm9zdHJjb25uZWN0Oi8vIFVSTCwgZXh0cmFjdCB0aGUgbnB1YlxuICAgICAgICAgICAgaWYgKG5wdWIuc3RhcnRzV2l0aCgnbm9zdHJjb25uZWN0Oi8vJykpIHtcbiAgICAgICAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChucHViKTtcbiAgICAgICAgICAgICAgbnB1YiA9IHVybC5wYXRobmFtZS5zdWJzdHJpbmcoMSk7IC8vIFJlbW92ZSBsZWFkaW5nIHNsYXNoXG4gICAgICAgICAgICAgIGlmIChucHViLnN0YXJ0c1dpdGgoJ25wdWIxJykpIHtcbiAgICAgICAgICAgICAgICAvLyBVc2UgYXMgaXNcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IGhleCB0byBucHViIGlmIG5lZWRlZFxuICAgICAgICAgICAgICAgIG5wdWIgPSBuaXAxOS5ucHViRW5jb2RlKG5wdWIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFucHViLnN0YXJ0c1dpdGgoJ25wdWIxJykpIHtcbiAgICAgICAgICAgICAgLy8gSWYgaXQncyBhIGhleCBrZXksIGNvbnZlcnQgdG8gbnB1YlxuICAgICAgICAgICAgICBucHViID0gbmlwMTkubnB1YkVuY29kZShucHViKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQ3JlYXRlIGFuIE5ES1VzZXIgZnJvbSB0aGUgcHVia2V5XG4gICAgICAgICAgICBjb25zdCB1c2VyID0gbmRrLmdldFVzZXIoeyBucHViIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBDcmVhdGUgTklQLTQ3IGNsaWVudFxuICAgICAgICAgICAgY29uc3QgY2xpZW50ID0gbmV3IE5JUDQ3Q2xpZW50KG9wdGlvbnMudGFyZ2V0KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQ29ubmVjdCB0byB0aGUgcmVtb3RlIHNpZ25lclxuICAgICAgICAgICAgYXdhaXQgY2xpZW50LmNvbm5lY3QoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gR2V0IHRoZSBwdWJsaWMga2V5XG4gICAgICAgICAgICBjb25zdCByZW1vdGVQdWJrZXkgPSBhd2FpdCBjbGllbnQuZ2V0UHVibGljS2V5KCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgcGF5bWVudCBjbGllbnRcbiAgICAgICAgICAgIGNvbnN0IHBheW1lbnRzID0gbmV3IE5JUDQ3UGF5bWVudENsaWVudChjbGllbnQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBDaGVjayBpZiBwYXltZW50cyBhcmUgc3VwcG9ydGVkXG4gICAgICAgICAgICBjb25zdCBwYXltZW50U3RhdHVzID0gYXdhaXQgcGF5bWVudHMuY2hlY2tQYXltZW50Q2FwYWJpbGl0eSgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBTdG9yZSB0aGUgY2xpZW50cyBmb3IgbGF0ZXIgdXNlXG4gICAgICAgICAgICBzZXROaXA0N0NsaWVudChjbGllbnQpO1xuICAgICAgICAgICAgc2V0UGF5bWVudENsaWVudChwYXltZW50cyk7XG4gICAgICAgICAgICBzZXRDYW5NYWtlUGF5bWVudHMocGF5bWVudFN0YXR1cy5jYW5QYXkpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBBdHRlbXB0IHRvIGZldGNoIHByb2ZpbGUgZGF0YVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgYXdhaXQgdXNlci5mZXRjaFByb2ZpbGUoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdDb3VsZCBub3QgZmV0Y2ggcHJvZmlsZSBmb3IgcmVtb3RlIHNpZ25lcjonLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgc2V0VXNlcih1c2VyKTtcbiAgICAgICAgICAgIHNldExvZ2luTWV0aG9kKCduaXA0NycpO1xuICAgICAgICAgICAgc2V0Vmlld09ubHlQcm9maWxlKG51bGwpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnTklQLTQ3IGxvZ2luIHN1Y2Nlc3NmdWw6JywgdXNlci5ucHViKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQYXltZW50IGNhcGFiaWxpdHk6JywgcGF5bWVudFN0YXR1cy5jYW5QYXkgPyAnRW5hYmxlZCcgOiAnRGlzYWJsZWQnKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKCFwYXltZW50U3RhdHVzLmNhblBheSkge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BheW1lbnQgbm90IGF2YWlsYWJsZTonLCBwYXltZW50U3RhdHVzLnJlYXNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ05JUC00NyBsb2dpbiBlcnJvcjonLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5JUC00NyBsb2dpbiBmYWlsZWQ6ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjYXNlICd2aWV3b25seSc6IHtcbiAgICAgICAgICAvLyBWaWV3LW9ubHkgbG9naW4gd2l0aCBhIHByZWRlZmluZWQgcHJvZmlsZVxuICAgICAgICAgIGlmICghb3B0aW9ucyB8fCAhb3B0aW9ucy5wcm9maWxlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZpZXctb25seSBsb2dpbiByZXF1aXJlcyBhIHByb2ZpbGUnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3QgcHJvZmlsZSA9IG9wdGlvbnMucHJvZmlsZSBhcyBWaWV3T25seVByb2ZpbGU7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ3JlYXRlIGFuIE5ES1VzZXIgZnJvbSB0aGUgcHVibGljIGtleVxuICAgICAgICAgIGNvbnN0IHVzZXIgPSBuZGsuZ2V0VXNlcih7IG5wdWI6IHByb2ZpbGUubnB1YiB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBGb3Igdmlldy1vbmx5LCB3ZSBjYW4gc3RpbGwgZmV0Y2ggdGhlaXIgcHJvZmlsZSBkYXRhXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHVzZXIuZmV0Y2hQcm9maWxlKCk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdDb3VsZCBub3QgZmV0Y2ggcHJvZmlsZSBmb3Igdmlldy1vbmx5IHVzZXIsIHVzaW5nIHByZWRlZmluZWQgZGF0YScpO1xuICAgICAgICAgICAgLy8gVXNlIHRoZSBwcmVkZWZpbmVkIHByb2ZpbGUgZGF0YVxuICAgICAgICAgICAgdXNlci5wcm9maWxlID0ge1xuICAgICAgICAgICAgICBuYW1lOiBwcm9maWxlLm5hbWUsXG4gICAgICAgICAgICAgIGRpc3BsYXlOYW1lOiBwcm9maWxlLmRpc3BsYXlOYW1lLFxuICAgICAgICAgICAgICBpbWFnZTogcHJvZmlsZS5waWN0dXJlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBzZXRVc2VyKHVzZXIpO1xuICAgICAgICAgIHNldExvZ2luTWV0aG9kKCd2aWV3b25seScpO1xuICAgICAgICAgIHNldFZpZXdPbmx5UHJvZmlsZShwcm9maWxlKTtcbiAgICAgICAgICBjb25zb2xlLmxvZygnVmlldy1vbmx5IGxvZ2luIHN1Y2Nlc3NmdWw6JywgcHJvZmlsZS5ucHViKTtcbiAgICAgICAgICBzZXROaXA0N0NsaWVudChudWxsKTtcbiAgICAgICAgICBzZXRQYXltZW50Q2xpZW50KG51bGwpO1xuICAgICAgICAgIHNldENhbk1ha2VQYXltZW50cyhmYWxzZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBsb2dpbiBtZXRob2Q6ICR7bWV0aG9kfWApO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYExvZ2luIGVycm9yICgke21ldGhvZH0pOmAsIGUpO1xuICAgICAgc2V0RXJyb3IoZSBhcyBFcnJvcik7XG4gICAgICB0aHJvdyBlO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gRW5oYW5jZWQgbG9nb3V0IGZ1bmN0aW9uXG4gIGNvbnN0IGxvZ291dCA9ICgpID0+IHtcbiAgICBjb25zb2xlLmxvZygnTm9zdHJDb250ZXh0OiBMb2dvdXQgaW5pdGlhdGVkJyk7XG4gICAgXG4gICAgLy8gQ2xlYW4gdXAgYW55IGFjdGl2ZSBzdWJzY3JpcHRpb25zIG9yIHJlc291cmNlcyBpZiBuZWVkZWRcbiAgICBpZiAobmRrKSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgc2lnbmVyLCB3ZSBzaG91bGQgcmVzZXQgaXRcbiAgICAgICAgaWYgKG5kay5zaWduZXIpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnUmVzZXR0aW5nIE5ESyBzaWduZXInKTtcbiAgICAgICAgICBuZGsuc2lnbmVyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZygnVXNlciByZXNvdXJjZXMgY2xlYW5lZCB1cCcpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZHVyaW5nIGxvZ291dCBjbGVhbnVwOicsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gQ2xlYW4gdXAgTklQLTQ3IGNsaWVudCBpZiBpdCBleGlzdHNcbiAgICBpZiAobmlwNDdDbGllbnQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG5pcDQ3Q2xpZW50LmRpc2Nvbm5lY3QoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZGlzY29ubmVjdGluZyBOSVAtNDcgY2xpZW50OicsIGUpO1xuICAgICAgfVxuICAgICAgc2V0TmlwNDdDbGllbnQobnVsbCk7XG4gICAgfVxuICAgIFxuICAgIC8vIENsZWFuIHVwIHBheW1lbnQgY2xpZW50XG4gICAgc2V0UGF5bWVudENsaWVudChudWxsKTtcbiAgICBzZXRDYW5NYWtlUGF5bWVudHMoZmFsc2UpO1xuICAgIFxuICAgIC8vIFJlc2V0IGFsbCBzdGF0ZVxuICAgIHNldExvZ2luTWV0aG9kKG51bGwpO1xuICAgIHNldFZpZXdPbmx5UHJvZmlsZShudWxsKTtcbiAgICBzZXRVc2VyKG51bGwpO1xuICAgIHNldEVycm9yKG51bGwpO1xuICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKCdOb3N0ckNvbnRleHQ6IExvZ291dCBjb21wbGV0ZWQnKTtcbiAgfTtcblxuICAvLyBHZXQgYSB1c2VyJ3MgcHJvZmlsZVxuICBjb25zdCBnZXRVc2VyUHJvZmlsZSA9IGFzeW5jIChucHViOiBzdHJpbmcpOiBQcm9taXNlPE5ES1VzZXIgfCBudWxsPiA9PiB7XG4gICAgaWYgKCFuZGspIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTkRLIG5vdCBpbml0aWFsaXplZCcpO1xuICAgIH1cblxuICAgIGNvbnN0IHVzZXIgPSBuZGsuZ2V0VXNlcih7IG5wdWIgfSk7XG4gICAgYXdhaXQgdXNlci5mZXRjaFByb2ZpbGUoKTtcbiAgICByZXR1cm4gdXNlcjtcbiAgfTtcblxuICAvLyBHZXQgdXNlcnMgdGhhdCBhIHVzZXIgZm9sbG93c1xuICBjb25zdCBnZXRGb2xsb3dzID0gYXN5bmMgKG5wdWI6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nW10+ID0+IHtcbiAgICBpZiAoIW5kaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOREsgbm90IGluaXRpYWxpemVkJyk7XG4gICAgfVxuXG4gICAgY29uc3QgdXNlciA9IG5kay5nZXRVc2VyKHsgbnB1YiB9KTtcbiAgICBjb25zdCBmb2xsb3dzID0gYXdhaXQgdXNlci5mb2xsb3dzKCk7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oZm9sbG93cykubWFwKGZvbGxvdyA9PiBmb2xsb3cubnB1Yik7XG4gIH07XG5cbiAgLy8gUGF5IGEgTGlnaHRuaW5nIGludm9pY2VcbiAgY29uc3QgcGF5SW52b2ljZSA9IGFzeW5jIChpbnZvaWNlOiBzdHJpbmcpOiBQcm9taXNlPGFueT4gPT4ge1xuICAgIGlmICghcGF5bWVudENsaWVudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXltZW50IGNsaWVudCBub3QgaW5pdGlhbGl6ZWQnKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKCFjYW5NYWtlUGF5bWVudHMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGF5bWVudHMgbm90IHN1cHBvcnRlZCB3aXRoIGN1cnJlbnQgbG9naW4gbWV0aG9kJyk7XG4gICAgfVxuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHBheW1lbnRDbGllbnQucGF5SW52b2ljZShpbnZvaWNlKTtcbiAgICAgIFxuICAgICAgaWYgKHJlc3BvbnNlLmVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUGF5bWVudCBmYWlsZWQ6ICR7cmVzcG9uc2UuZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIHJlc3BvbnNlLnJlc3VsdDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignUGF5bWVudCBmYWlsZWQ6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9O1xuXG4gIC8vIEdlbmVyYXRlIHNvY2lhbCBncmFwaCBkYXRhIGZvciB0aGUgcHJvdmlkZWQgTlBVQnNcbiAgY29uc3QgZ2V0U29jaWFsR3JhcGggPSBhc3luYyAobnB1YnM6IHN0cmluZ1tdLCBtYXhDb25uZWN0aW9uczogbnVtYmVyID0gMjUpID0+IHtcbiAgICBpZiAoIW5kaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOREsgbm90IGluaXRpYWxpemVkJyk7XG4gICAgfVxuICAgIFxuICAgIC8vIENoZWNrIHJlbGF5IGNvbm5lY3Rpb25zXG4gICAgY29uc3QgY29ubmVjdGVkUmVsYXlzID0gbmRrLnBvb2w/LmdldENvbm5lY3RlZFJlbGF5cygpIHx8IFtdO1xuICAgIGlmIChjb25uZWN0ZWRSZWxheXMubGVuZ3RoID09PSAwKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ05vIGNvbm5lY3RlZCByZWxheXMuIEF0dGVtcHRpbmcgdG8gY29ubmVjdC4uLicpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gQXR0ZW1wdCB0byByZWNvbm5lY3RcbiAgICAgICAgYXdhaXQgbmRrLmNvbm5lY3QoKTtcbiAgICAgICAgLy8gQ2hlY2sgYWdhaW5cbiAgICAgICAgY29uc3QgcmVjb25uZWN0ZWRSZWxheXMgPSBuZGsucG9vbD8uZ2V0Q29ubmVjdGVkUmVsYXlzKCkgfHwgW107XG4gICAgICAgIGlmIChyZWNvbm5lY3RlZFJlbGF5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBjb25uZWN0IHRvIGFueSByZWxheXMnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmxvZyhgU3VjY2Vzc2Z1bGx5IGNvbm5lY3RlZCB0byAke3JlY29ubmVjdGVkUmVsYXlzLmxlbmd0aH0gcmVsYXlzYCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdSZWxheSBjb25uZWN0aW9uIGVycm9yOicsIGVycm9yKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gY29ubmVjdCB0byBOb3N0ciByZWxheXMuIFBsZWFzZSBjaGVjayB5b3VyIGludGVybmV0IGNvbm5lY3Rpb24uJyk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKGBGZXRjaGluZyBzb2NpYWwgZ3JhcGggZm9yICR7bnB1YnMubGVuZ3RofSBOUFVCcyB3aXRoIG1heCAke21heENvbm5lY3Rpb25zfSBjb25uZWN0aW9ucyBmcm9tICR7Y29ubmVjdGVkUmVsYXlzLmxlbmd0aH0gcmVsYXlzYCk7XG4gICAgXG4gICAgLy8gUmVhbCBpbXBsZW1lbnRhdGlvbiB1c2luZyBhY3R1YWwgTm9zdHIgZGF0YVxuICAgIGNvbnN0IG5vZGVzOiBhbnlbXSA9IFtdO1xuICAgIGNvbnN0IGxpbmtzOiBhbnlbXSA9IFtdO1xuICAgIGNvbnN0IG5vZGVNYXAgPSBuZXcgTWFwPHN0cmluZywgYm9vbGVhbj4oKTtcbiAgICBcbiAgICAvLyBDcmVhdGUgYSB0aW1lb3V0IHByb21pc2VcbiAgICBjb25zdCB0aW1lb3V0ID0gKG1zOiBudW1iZXIpID0+IG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IFxuICAgICAgc2V0VGltZW91dCgoKSA9PiByZWplY3QobmV3IEVycm9yKGBPcGVyYXRpb24gdGltZWQgb3V0IGFmdGVyICR7bXN9bXNgKSksIG1zKVxuICAgICk7XG4gICAgXG4gICAgLy8gQWRkIHRoZSBjb3JlIE5QVUJzIGFzIG5vZGVzXG4gICAgZm9yIChjb25zdCBucHViIG9mIG5wdWJzKSB7XG4gICAgICBpZiAobm9kZU1hcC5oYXMobnB1YikpIGNvbnRpbnVlO1xuICAgICAgXG4gICAgICB0cnkge1xuICAgICAgICAvLyBHZXQgdGhlIGFjdHVhbCB1c2VyIHByb2ZpbGUgZnJvbSBOb3N0ciB3aXRoIHRpbWVvdXRcbiAgICAgICAgY29uc3QgdXNlciA9IG5kay5nZXRVc2VyKHsgbnB1YiB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNldCB0aW1lb3V0IGZvciBwcm9maWxlIGZldGNoaW5nIHRvIGF2b2lkIGhhbmdpbmdcbiAgICAgICAgY29uc3QgcHJvZmlsZVByb21pc2UgPSB1c2VyLmZldGNoUHJvZmlsZSgpO1xuICAgICAgICBhd2FpdCBQcm9taXNlLnJhY2UoW1xuICAgICAgICAgIHByb2ZpbGVQcm9taXNlLFxuICAgICAgICAgIHRpbWVvdXQoMTAwMDApIC8vIDEwIHNlY29uZCB0aW1lb3V0XG4gICAgICAgIF0pO1xuICAgICAgICBcbiAgICAgICAgY29uc29sZS5sb2coYEZldGNoZWQgcHJvZmlsZSBmb3IgJHtucHVifTogJHt1c2VyLnByb2ZpbGU/Lm5hbWUgfHwgJ3VubmFtZWQnfWApO1xuICAgICAgICBcbiAgICAgICAgbm9kZXMucHVzaCh7XG4gICAgICAgICAgaWQ6IG5wdWIsXG4gICAgICAgICAgbnB1YixcbiAgICAgICAgICBuYW1lOiB1c2VyLnByb2ZpbGU/LmRpc3BsYXlOYW1lIHx8IHVzZXIucHJvZmlsZT8ubmFtZSB8fCBzaG9ydGVuTnB1YihucHViKSxcbiAgICAgICAgICB0eXBlOiAncHJvZmlsZScsXG4gICAgICAgICAgcGljdHVyZTogdXNlci5wcm9maWxlPy5waWN0dXJlIHx8ICcnLFxuICAgICAgICAgIGlzQ29yZU5vZGU6IHRydWUsXG4gICAgICAgICAgdmFsOiAxMCxcbiAgICAgICAgICBncm91cDogMVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIG5vZGVNYXAuc2V0KG5wdWIsIHRydWUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggcHJvZmlsZSBmb3IgJHtucHVifWAsIGUpO1xuICAgICAgICAvLyBTdGlsbCBhZGQgdGhlIG5vZGUgZXZlbiBpZiBwcm9maWxlIGZldGNoIGZhaWxzXG4gICAgICAgIG5vZGVzLnB1c2goe1xuICAgICAgICAgIGlkOiBucHViLFxuICAgICAgICAgIG5wdWIsXG4gICAgICAgICAgbmFtZTogc2hvcnRlbk5wdWIobnB1YiksXG4gICAgICAgICAgdHlwZTogJ3Byb2ZpbGUnLFxuICAgICAgICAgIGlzQ29yZU5vZGU6IHRydWUsXG4gICAgICAgICAgdmFsOiAxMCxcbiAgICAgICAgICBncm91cDogMVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIG5vZGVNYXAuc2V0KG5wdWIsIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBGZXRjaCByZWFsIGZvbGxvd3MgZm9yIGVhY2ggY29yZSBOUFVCXG4gICAgZm9yIChjb25zdCBucHViIG9mIG5wdWJzKSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBHZXQgdGhlIGFjdHVhbCBmb2xsb3dzIGZyb20gTm9zdHIgd2l0aCB0aW1lb3V0XG4gICAgICAgIGNvbnN0IHVzZXIgPSBuZGsuZ2V0VXNlcih7IG5wdWIgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyBTZXQgdGltZW91dCBmb3IgZm9sbG93cyBmZXRjaGluZyB0byBhdm9pZCBoYW5naW5nXG4gICAgICAgIGNvbnN0IGZvbGxvd3NQcm9taXNlID0gdXNlci5mb2xsb3dzKCk7XG4gICAgICAgIGNvbnN0IGZvbGxvd3MgPSBhd2FpdCBQcm9taXNlLnJhY2UoW1xuICAgICAgICAgIGZvbGxvd3NQcm9taXNlLFxuICAgICAgICAgIHRpbWVvdXQoMTUwMDApIC8vIDE1IHNlY29uZCB0aW1lb3V0XG4gICAgICAgIF0pO1xuICAgICAgICBcbiAgICAgICAgY29uc29sZS5sb2coYEZldGNoZWQgJHtmb2xsb3dzLnNpemV9IGZvbGxvd3MgZm9yICR7bnB1Yn1gKTtcbiAgICAgICAgXG4gICAgICAgIC8vIExpbWl0IHRvIG1heENvbm5lY3Rpb25zIGlmIG5lZWRlZFxuICAgICAgICBjb25zdCBmb2xsb3dzTGlzdCA9IEFycmF5LmZyb20oZm9sbG93cykuc2xpY2UoMCwgbWF4Q29ubmVjdGlvbnMpO1xuICAgICAgICBcbiAgICAgICAgLy8gUHJvY2VzcyBlYWNoIGZvbGxvd1xuICAgICAgICBmb3IgKGNvbnN0IGZvbGxvd2VkVXNlciBvZiBmb2xsb3dzTGlzdCkge1xuICAgICAgICAgIGNvbnN0IGZvbGxvd2VkTnB1YiA9IGZvbGxvd2VkVXNlci5ucHViO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFNraXAgaWYgYWxyZWFkeSBwcm9jZXNzZWRcbiAgICAgICAgICBpZiAobm9kZU1hcC5oYXMoZm9sbG93ZWROcHViKSkge1xuICAgICAgICAgICAgLy8gU3RpbGwgYWRkIGNvbm5lY3Rpb24gaWYgbm90IGFscmVhZHkgYWRkZWRcbiAgICAgICAgICAgIGxpbmtzLnB1c2goe1xuICAgICAgICAgICAgICBzb3VyY2U6IG5wdWIsXG4gICAgICAgICAgICAgIHRhcmdldDogZm9sbG93ZWROcHViLFxuICAgICAgICAgICAgICB0eXBlOiAnZm9sbG93cycsXG4gICAgICAgICAgICAgIHZhbHVlOiAxXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBUcnkgdG8gZ2V0IHByb2ZpbGUgaW5mb3JtYXRpb24gZm9yIHRoZSBmb2xsb3dlZCB1c2VyXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFNldCB0aW1lb3V0IGZvciBwcm9maWxlIGZldGNoaW5nXG4gICAgICAgICAgICBjb25zdCBwcm9maWxlUHJvbWlzZSA9IGZvbGxvd2VkVXNlci5mZXRjaFByb2ZpbGUoKTtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UucmFjZShbXG4gICAgICAgICAgICAgIHByb2ZpbGVQcm9taXNlLFxuICAgICAgICAgICAgICB0aW1lb3V0KDUwMDApIC8vIDUgc2Vjb25kIHRpbWVvdXQgZm9yIGZvbGxvd3MnIHByb2ZpbGVzXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgbm9kZXMucHVzaCh7XG4gICAgICAgICAgICAgIGlkOiBmb2xsb3dlZE5wdWIsXG4gICAgICAgICAgICAgIG5wdWI6IGZvbGxvd2VkTnB1YixcbiAgICAgICAgICAgICAgbmFtZTogZm9sbG93ZWRVc2VyLnByb2ZpbGU/LmRpc3BsYXlOYW1lIHx8IGZvbGxvd2VkVXNlci5wcm9maWxlPy5uYW1lIHx8IHNob3J0ZW5OcHViKGZvbGxvd2VkTnB1YiksXG4gICAgICAgICAgICAgIHR5cGU6ICdjb25uZWN0aW9uJyxcbiAgICAgICAgICAgICAgcGljdHVyZTogZm9sbG93ZWRVc2VyLnByb2ZpbGU/LnBpY3R1cmUgfHwgJycsXG4gICAgICAgICAgICAgIGlzQ29yZU5vZGU6IGZhbHNlLFxuICAgICAgICAgICAgICB2YWw6IDMsXG4gICAgICAgICAgICAgIGdyb3VwOiAyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYEZhaWxlZCB0byBmZXRjaCBwcm9maWxlIGZvciBmb2xsb3cgJHtmb2xsb3dlZE5wdWJ9YCwgZSk7XG4gICAgICAgICAgICBub2Rlcy5wdXNoKHtcbiAgICAgICAgICAgICAgaWQ6IGZvbGxvd2VkTnB1YixcbiAgICAgICAgICAgICAgbnB1YjogZm9sbG93ZWROcHViLFxuICAgICAgICAgICAgICBuYW1lOiBzaG9ydGVuTnB1Yihmb2xsb3dlZE5wdWIpLFxuICAgICAgICAgICAgICB0eXBlOiAnY29ubmVjdGlvbicsXG4gICAgICAgICAgICAgIGlzQ29yZU5vZGU6IGZhbHNlLFxuICAgICAgICAgICAgICB2YWw6IDMsXG4gICAgICAgICAgICAgIGdyb3VwOiAyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgbm9kZU1hcC5zZXQoZm9sbG93ZWROcHViLCB0cnVlKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBBZGQgY29ubmVjdGlvblxuICAgICAgICAgIGxpbmtzLnB1c2goe1xuICAgICAgICAgICAgc291cmNlOiBucHViLFxuICAgICAgICAgICAgdGFyZ2V0OiBmb2xsb3dlZE5wdWIsXG4gICAgICAgICAgICB0eXBlOiAnZm9sbG93cycsXG4gICAgICAgICAgICB2YWx1ZTogMVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBDaGVjayBmb3IgbXV0dWFsIGZvbGxvd3MgYmV0d2VlbiBjb3JlIE5QVUJzIChyZWFsIGNvbm5lY3Rpb25zKVxuICAgICAgICBjb25zdCBmb2xsb3dlZFB1YmtleXMgPSBuZXcgU2V0KGZvbGxvd3NMaXN0Lm1hcChmID0+IGYubnB1YikpO1xuICAgICAgICBcbiAgICAgICAgLy8gRm9yIGVhY2ggb3RoZXIgY29yZSBOUFVCLCBjaGVjayBpZiB0aGlzIE5QVUIgZm9sbG93cyBpdFxuICAgICAgICBmb3IgKGNvbnN0IG90aGVyTnB1YiBvZiBucHVicykge1xuICAgICAgICAgIGlmIChvdGhlck5wdWIgIT09IG5wdWIgJiYgZm9sbG93ZWRQdWJrZXlzLmhhcyhvdGhlck5wdWIpKSB7XG4gICAgICAgICAgICBsaW5rcy5wdXNoKHtcbiAgICAgICAgICAgICAgc291cmNlOiBucHViLFxuICAgICAgICAgICAgICB0YXJnZXQ6IG90aGVyTnB1YixcbiAgICAgICAgICAgICAgdHlwZTogJ211dHVhbCcsXG4gICAgICAgICAgICAgIHZhbHVlOiAyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIGZldGNoIGZvbGxvd3MgZm9yICR7bnB1Yn1gLCBlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgY29uc29sZS5sb2coYENvbXBsZXRlZCBzb2NpYWwgZ3JhcGggd2l0aCAke25vZGVzLmxlbmd0aH0gbm9kZXMgYW5kICR7bGlua3MubGVuZ3RofSBsaW5rc2ApO1xuICAgIFxuICAgIHJldHVybiB7IG5vZGVzLCBsaW5rcyB9O1xuICB9O1xuXG4gIC8vIFByb3ZpZGUgdGhlIGNvbnRleHQgdmFsdWVcbiAgY29uc3QgY29udGV4dFZhbHVlOiBOb3N0ckNvbnRleHRUeXBlID0ge1xuICAgIG5kayxcbiAgICB1c2VyLFxuICAgIGxvYWRpbmcsXG4gICAgZXJyb3IsXG4gICAgbG9naW5NZXRob2QsXG4gICAgdmlld09ubHlQcm9maWxlLFxuICAgIGF2YWlsYWJsZVByb2ZpbGVzOiBQUkVERUZJTkVEX1BST0ZJTEVTLFxuICAgIGxvZ2luLFxuICAgIGxvZ291dCxcbiAgICBnZXRVc2VyUHJvZmlsZSxcbiAgICBnZXRGb2xsb3dzLFxuICAgIHNob3J0ZW5OcHViLFxuICAgIHBheUludm9pY2U6IGNhbk1ha2VQYXltZW50cyA/IHBheUludm9pY2UgOiB1bmRlZmluZWQsXG4gICAgY2FuTWFrZVBheW1lbnRzLFxuICAgIGdldFNvY2lhbEdyYXBoLFxuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPE5vc3RyQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17Y29udGV4dFZhbHVlfT5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L05vc3RyQ29udGV4dC5Qcm92aWRlcj5cbiAgKTtcbn07XG5cbi8vIEhvb2sgdG8gdXNlIHRoZSBOb3N0ciBjb250ZXh0XG5leHBvcnQgY29uc3QgdXNlTm9zdHIgPSAoKSA9PiB7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KE5vc3RyQ29udGV4dCk7XG4gIGlmIChjb250ZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzZU5vc3RyIG11c3QgYmUgdXNlZCB3aXRoaW4gYSBOb3N0clByb3ZpZGVyJyk7XG4gIH1cbiAgcmV0dXJuIGNvbnRleHQ7XG59OyAiXSwibmFtZXMiOlsiUmVhY3QiLCJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwiTkRLIiwiTkRLTmlwMDdTaWduZXIiLCJuaXAxOSIsIk5JUDQ3Q2xpZW50IiwiTklQNDdQYXltZW50Q2xpZW50Iiwic2hvcnRlbk5wdWIiLCJucHViIiwic3Vic3RyaW5nIiwibGVuZ3RoIiwiUFJFREVGSU5FRF9QUk9GSUxFUyIsInB1YmtleSIsIm5hbWUiLCJkaXNwbGF5TmFtZSIsInBpY3R1cmUiLCJOb3N0ckNvbnRleHQiLCJ1bmRlZmluZWQiLCJOb3N0clByb3ZpZGVyIiwiY2hpbGRyZW4iLCJuZGsiLCJzZXROZGsiLCJ1c2VyIiwic2V0VXNlciIsImxvYWRpbmciLCJzZXRMb2FkaW5nIiwiZXJyb3IiLCJzZXRFcnJvciIsImxvZ2luTWV0aG9kIiwic2V0TG9naW5NZXRob2QiLCJ2aWV3T25seVByb2ZpbGUiLCJzZXRWaWV3T25seVByb2ZpbGUiLCJuaXA0N0NsaWVudCIsInNldE5pcDQ3Q2xpZW50IiwicGF5bWVudENsaWVudCIsInNldFBheW1lbnRDbGllbnQiLCJjYW5NYWtlUGF5bWVudHMiLCJzZXRDYW5NYWtlUGF5bWVudHMiLCJpbml0aWFsaXplTkRLIiwiZXhwbGljaXRSZWxheVVybHMiLCJjb25uZWN0IiwiY29uc29sZSIsImxvZyIsImUiLCJsb2dpbiIsIm1ldGhvZCIsIm9wdGlvbnMiLCJFcnJvciIsIndpbmRvdyIsIm5vc3RyIiwic2lnbmVyIiwicHVibGljS2V5IiwiZ2V0VXNlciIsImZldGNoUHJvZmlsZSIsInRhcmdldCIsInN0YXJ0c1dpdGgiLCJ1cmwiLCJVUkwiLCJwYXRobmFtZSIsIm5wdWJFbmNvZGUiLCJjbGllbnQiLCJyZW1vdGVQdWJrZXkiLCJnZXRQdWJsaWNLZXkiLCJwYXltZW50cyIsInBheW1lbnRTdGF0dXMiLCJjaGVja1BheW1lbnRDYXBhYmlsaXR5IiwiY2FuUGF5Iiwid2FybiIsInJlYXNvbiIsIm1lc3NhZ2UiLCJwcm9maWxlIiwiaW1hZ2UiLCJsb2dvdXQiLCJkaXNjb25uZWN0IiwiZ2V0VXNlclByb2ZpbGUiLCJnZXRGb2xsb3dzIiwiZm9sbG93cyIsIkFycmF5IiwiZnJvbSIsIm1hcCIsImZvbGxvdyIsInBheUludm9pY2UiLCJpbnZvaWNlIiwicmVzcG9uc2UiLCJyZXN1bHQiLCJnZXRTb2NpYWxHcmFwaCIsIm5wdWJzIiwibWF4Q29ubmVjdGlvbnMiLCJjb25uZWN0ZWRSZWxheXMiLCJwb29sIiwiZ2V0Q29ubmVjdGVkUmVsYXlzIiwicmVjb25uZWN0ZWRSZWxheXMiLCJub2RlcyIsImxpbmtzIiwibm9kZU1hcCIsIk1hcCIsInRpbWVvdXQiLCJtcyIsIlByb21pc2UiLCJfIiwicmVqZWN0Iiwic2V0VGltZW91dCIsImhhcyIsInByb2ZpbGVQcm9taXNlIiwicmFjZSIsInB1c2giLCJpZCIsInR5cGUiLCJpc0NvcmVOb2RlIiwidmFsIiwiZ3JvdXAiLCJzZXQiLCJmb2xsb3dzUHJvbWlzZSIsInNpemUiLCJmb2xsb3dzTGlzdCIsInNsaWNlIiwiZm9sbG93ZWRVc2VyIiwiZm9sbG93ZWROcHViIiwic291cmNlIiwidmFsdWUiLCJmb2xsb3dlZFB1YmtleXMiLCJTZXQiLCJmIiwib3RoZXJOcHViIiwiY29udGV4dFZhbHVlIiwiYXZhaWxhYmxlUHJvZmlsZXMiLCJQcm92aWRlciIsInVzZU5vc3RyIiwiY29udGV4dCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/contexts/NostrContext.tsx\n"));

/***/ })

});