"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/community/page",{

/***/ "(app-pages-browser)/./src/lib/nostr/NostrAuthProvider.tsx":
/*!*********************************************!*\
  !*** ./src/lib/nostr/NostrAuthProvider.tsx ***!
  \*********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NostrAuthProvider: () => (/* binding */ NostrAuthProvider),\n/* harmony export */   TrustLevel: () => (/* binding */ TrustLevel),\n/* harmony export */   useNostrAuth: () => (/* binding */ useNostrAuth)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @nostr-dev-kit/ndk */ \"(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/dist/index.mjs\");\n/* harmony import */ var _nostr_dev_kit_ndk_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @nostr-dev-kit/ndk-react */ \"(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk-react/dist/ndk-react.es.js\");\n/* harmony import */ var nostr_tools__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! nostr-tools */ \"(app-pages-browser)/./node_modules/nostr-tools/lib/esm/index.js\");\n/* __next_internal_client_entry_do_not_use__ TrustLevel,useNostrAuth,NostrAuthProvider auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\n\n// Define the trust level enum\nvar TrustLevel = /*#__PURE__*/ function(TrustLevel) {\n    TrustLevel[TrustLevel[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n    TrustLevel[TrustLevel[\"LOW\"] = 1] = \"LOW\";\n    TrustLevel[TrustLevel[\"MEDIUM\"] = 2] = \"MEDIUM\";\n    TrustLevel[TrustLevel[\"HIGH\"] = 3] = \"HIGH\";\n    TrustLevel[TrustLevel[\"VERIFIED\"] = 4] = \"VERIFIED\";\n    return TrustLevel;\n}({});\n// Define core NPUBs to check for trust\nconst CORE_NPUBS = [\n    \"npub1etgqcj9gc6yaxttuwu9eqgs3ynt2dzaudvwnrssrn2zdt2useaasfj8n6e\",\n    \"npub1s0veng2gvfwr62acrxhnqexq76sj6ldg3a5t935jy8e6w3shr5vsnwrmq5\",\n    \"npub1dxd02kcjhgpkyrx60qnkd6j42kmc72u5lum0rp2ud8x5zfhnk4zscjj6hh\",\n    \"npub1funchalx8v747rsee6ahsuyrcd2s3rnxlyrtumfex9lecpmgwars6hq8kc\"\n];\n// Define a list of community relays\nconst COMMUNITY_RELAYS = [\n    \"wss://relay.damus.io\",\n    \"wss://relay.nostr.band\",\n    \"wss://nos.lol\",\n    \"wss://nostr.mutinywallet.com\"\n];\n// Create the context\nconst NostrAuthContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\n// Custom hook for accessing the context\nconst useNostrAuth = ()=>{\n    _s();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(NostrAuthContext);\n    if (!context) {\n        throw new Error('useNostrAuth must be used within a NostrAuthProvider');\n    }\n    return context;\n};\n_s(useNostrAuth, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\n// The provider component\nconst NostrAuthProvider = (param)=>{\n    let { children } = param;\n    _s1();\n    // NDK instance from the NDK provider\n    const { ndk } = (0,_nostr_dev_kit_ndk_react__WEBPACK_IMPORTED_MODULE_3__.useNDK)();\n    // State for authentication status\n    const [user, setUser] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [npub, setNpub] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [pubkey, setPubkey] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [isConnected, setIsConnected] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    // Reference to the connect manager - we'll create our own minimal implementation\n    const [connectManager, setConnectManager] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    // Initialize NostrConnect - simplified for this implementation\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"NostrAuthProvider.useEffect\": ()=>{\n            if (!ndk) return;\n            try {\n                // Instead of using the Connect class which has compatibility issues,\n                // we'll create a minimal manager object for testing purposes\n                const minimalManager = {\n                    connect: {\n                        \"NostrAuthProvider.useEffect\": async ()=>{\n                            // Simulate connection by returning a random core NPUB\n                            const mockPubkey = CORE_NPUBS[Math.floor(Math.random() * CORE_NPUBS.length)];\n                            const { data: hexPubkey } = nostr_tools__WEBPACK_IMPORTED_MODULE_4__.nip19.decode(mockPubkey);\n                            return {\n                                pubkey: hexPubkey,\n                                secretKey: 'mock_secret'\n                            };\n                        }\n                    }[\"NostrAuthProvider.useEffect\"]\n                };\n                setConnectManager(minimalManager);\n                // Try to restore session\n                const restoreSession = {\n                    \"NostrAuthProvider.useEffect.restoreSession\": async ()=>{\n                        try {\n                            const session = localStorage.getItem('nostrSession');\n                            if (session) {\n                                const sessionData = JSON.parse(session);\n                                if (sessionData && sessionData.pubkey && sessionData.npub) {\n                                    setPubkey(sessionData.pubkey);\n                                    setNpub(sessionData.npub);\n                                    setIsConnected(true);\n                                    // Create user object\n                                    const userObj = {\n                                        pubkey: sessionData.pubkey,\n                                        npub: sessionData.npub,\n                                        name: sessionData.name || '',\n                                        profileImage: sessionData.profileImage || ''\n                                    };\n                                    setUser(userObj);\n                                    // Load the user profile\n                                    await loadUserProfile(sessionData.npub);\n                                }\n                            }\n                        } catch (err) {\n                            console.error('Error restoring session:', err);\n                            localStorage.removeItem('nostrSession');\n                        }\n                    }\n                }[\"NostrAuthProvider.useEffect.restoreSession\"];\n                restoreSession();\n            } catch (err) {\n                console.error('Error initializing Nostr:', err);\n                setError('Failed to initialize Nostr connection');\n            }\n        }\n    }[\"NostrAuthProvider.useEffect\"], [\n        ndk\n    ]);\n    // Function to load user profile data\n    const loadUserProfile = async (userNpub)=>{\n        if (!ndk) return;\n        try {\n            var _user_profile, _user_profile1, _user_profile2, _user_profile3;\n            // Create an NDK user from the npub\n            const { type, data: hexPubkey } = nostr_tools__WEBPACK_IMPORTED_MODULE_4__.nip19.decode(userNpub);\n            if (type !== 'npub') {\n                throw new Error('Invalid npub');\n            }\n            // Fetch user profile\n            const user = ndk.getUser({\n                pubkey: hexPubkey\n            });\n            await user.fetchProfile();\n            // Update user data\n            setUser({\n                pubkey: hexPubkey,\n                npub: userNpub,\n                name: ((_user_profile = user.profile) === null || _user_profile === void 0 ? void 0 : _user_profile.name) || '',\n                profileImage: ((_user_profile1 = user.profile) === null || _user_profile1 === void 0 ? void 0 : _user_profile1.image) || ''\n            });\n            // Save to local storage\n            const sessionData = {\n                pubkey: hexPubkey,\n                npub: userNpub,\n                name: ((_user_profile2 = user.profile) === null || _user_profile2 === void 0 ? void 0 : _user_profile2.name) || '',\n                profileImage: ((_user_profile3 = user.profile) === null || _user_profile3 === void 0 ? void 0 : _user_profile3.image) || ''\n            };\n            localStorage.setItem('nostrSession', JSON.stringify(sessionData));\n        } catch (err) {\n            console.error('Error loading user profile:', err);\n        }\n    };\n    // Login function\n    const login = async ()=>{\n        if (!ndk || !connectManager) {\n            setError('Nostr connection not initialized');\n            return;\n        }\n        setIsLoading(true);\n        setError(null);\n        try {\n            // First try NIP-07 login if available\n            try {\n                // Check if the browser has a NIP-07 extension\n                const hasNip07 = window && 'nostr' in window;\n                if (hasNip07) {\n                    // Use the NIP-07 signer\n                    const signer = new _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKNip07Signer();\n                    ndk.signer = signer;\n                    // Get the user's public key\n                    const userPubkey = await signer.user();\n                    if (userPubkey) {\n                        const userNpub = nostr_tools__WEBPACK_IMPORTED_MODULE_4__.nip19.npubEncode(userPubkey.pubkey);\n                        setPubkey(userPubkey.pubkey);\n                        setNpub(userNpub);\n                        setIsConnected(true);\n                        await loadUserProfile(userNpub);\n                        return;\n                    }\n                }\n            } catch (err) {\n                console.log('NIP-07 login failed, falling back to our minimal connect implementation:', err);\n            }\n            // Fall back to our minimal connect implementation\n            const { pubkey: hexPubkey } = await connectManager.connect();\n            // Convert to npub\n            const mockPubkey = nostr_tools__WEBPACK_IMPORTED_MODULE_4__.nip19.npubEncode(hexPubkey);\n            setPubkey(hexPubkey);\n            setNpub(mockPubkey);\n            setIsConnected(true);\n            // Create a basic user object\n            const userObj = {\n                pubkey: hexPubkey,\n                npub: mockPubkey,\n                name: 'Test User',\n                profileImage: ''\n            };\n            setUser(userObj);\n            // Save to local storage\n            localStorage.setItem('nostrSession', JSON.stringify(userObj));\n        } catch (err) {\n            console.error('Login error:', err);\n            setError('Failed to login with Nostr');\n        } finally{\n            setIsLoading(false);\n        }\n    };\n    // Logout function\n    const logout = ()=>{\n        setUser(null);\n        setNpub(null);\n        setPubkey(null);\n        setIsConnected(false);\n        // Clear local storage\n        localStorage.removeItem('nostrSession');\n    };\n    // Check trust level of a npub\n    const checkTrustLevel = async (targetNpub)=>{\n        if (!ndk || !isConnected) return 0;\n        try {\n            // Check if it's a core npub\n            if (CORE_NPUBS.includes(targetNpub)) {\n                return 4;\n            }\n            // Check if it's directly connected to us\n            const { directConnections } = await getWebOfTrust();\n            if (directConnections.includes(targetNpub)) {\n                return 3;\n            }\n            // Check if it's indirectly connected\n            const { secondDegreeConnections } = await getWebOfTrust();\n            if (secondDegreeConnections.includes(targetNpub)) {\n                return 2;\n            }\n            // Otherwise, it's a low trust connection\n            return 1;\n        } catch (err) {\n            console.error('Error checking trust level:', err);\n            return 0;\n        }\n    };\n    // Publish an event\n    const publishEvent = async (event)=>{\n        if (!ndk || !isConnected) return null;\n        try {\n            const ndkEvent = new _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKEvent(ndk);\n            ndkEvent.kind = event.kind;\n            ndkEvent.content = event.content;\n            ndkEvent.tags = event.tags || [];\n            // Publish the event\n            await ndkEvent.publish();\n            return ndkEvent;\n        } catch (err) {\n            console.error('Error publishing event:', err);\n            return null;\n        }\n    };\n    // Get web of trust\n    const getWebOfTrust = async ()=>{\n        if (!ndk || !isConnected || !pubkey) {\n            return {\n                directConnections: [],\n                secondDegreeConnections: [],\n                coreFollowers: []\n            };\n        }\n        try {\n            // For simplicity, we'll use a mock implementation\n            // In a real implementation, this would query the relays for follows\n            // Mock direct connections\n            const directConnections = CORE_NPUBS.filter(()=>Math.random() > 0.5);\n            // Mock second-degree connections\n            const secondDegreeConnections = CORE_NPUBS.filter(()=>Math.random() > 0.7);\n            // Mock core followers\n            const coreFollowers = CORE_NPUBS.filter(()=>Math.random() > 0.8);\n            return {\n                directConnections,\n                secondDegreeConnections,\n                coreFollowers\n            };\n        } catch (err) {\n            console.error('Error getting web of trust:', err);\n            return {\n                directConnections: [],\n                secondDegreeConnections: [],\n                coreFollowers: []\n            };\n        }\n    };\n    // Context value\n    const value = {\n        user,\n        npub,\n        pubkey,\n        isConnected,\n        isLoading,\n        error,\n        login,\n        logout,\n        checkTrustLevel,\n        publishEvent,\n        getWebOfTrust\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(NostrAuthContext.Provider, {\n        value: value,\n        children: children\n    }, void 0, false, {\n        fileName: \"/home/lfg/Git/Madtrips/src/lib/nostr/NostrAuthProvider.tsx\",\n        lineNumber: 372,\n        columnNumber: 5\n    }, undefined);\n};\n_s1(NostrAuthProvider, \"JC1CBGG50mdECnkG6AfQzMMmKxg=\", false, function() {\n    return [\n        _nostr_dev_kit_ndk_react__WEBPACK_IMPORTED_MODULE_3__.useNDK\n    ];\n});\n_c = NostrAuthProvider;\nvar _c;\n$RefreshReg$(_c, \"NostrAuthProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvbm9zdHIvTm9zdHJBdXRoUHJvdmlkZXIudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBRXlGO0FBQ1U7QUFDakQ7QUFDZDtBQUVwQyw4QkFBOEI7QUFDdkIsd0NBQUtTOzs7Ozs7V0FBQUE7TUFNWDtBQXlCRCx1Q0FBdUM7QUFDdkMsTUFBTUMsYUFBYTtJQUNqQjtJQUNBO0lBQ0E7SUFDQTtDQUNEO0FBRUQsb0NBQW9DO0FBQ3BDLE1BQU1DLG1CQUFtQjtJQUN2QjtJQUNBO0lBQ0E7SUFDQTtDQUNEO0FBRUQscUJBQXFCO0FBQ3JCLE1BQU1DLGlDQUFtQlgsb0RBQWFBLENBQW1CO0FBT3pELHdDQUF3QztBQUNqQyxNQUFNWSxlQUFlOztJQUMxQixNQUFNQyxVQUFVWixpREFBVUEsQ0FBQ1U7SUFDM0IsSUFBSSxDQUFDRSxTQUFTO1FBQ1osTUFBTSxJQUFJQyxNQUFNO0lBQ2xCO0lBQ0EsT0FBT0Q7QUFDVCxFQUFFO0dBTldEO0FBUWIseUJBQXlCO0FBQ2xCLE1BQU1HLG9CQUFzRDtRQUFDLEVBQUVDLFFBQVEsRUFBRTs7SUFDOUUscUNBQXFDO0lBQ3JDLE1BQU0sRUFBRUMsR0FBRyxFQUFFLEdBQUdYLGdFQUFNQTtJQUV0QixrQ0FBa0M7SUFDbEMsTUFBTSxDQUFDWSxNQUFNQyxRQUFRLEdBQUdqQiwrQ0FBUUEsQ0FBaUY7SUFDakgsTUFBTSxDQUFDa0IsTUFBTUMsUUFBUSxHQUFHbkIsK0NBQVFBLENBQWdCO0lBQ2hELE1BQU0sQ0FBQ29CLFFBQVFDLFVBQVUsR0FBR3JCLCtDQUFRQSxDQUFnQjtJQUNwRCxNQUFNLENBQUNzQixhQUFhQyxlQUFlLEdBQUd2QiwrQ0FBUUEsQ0FBQztJQUMvQyxNQUFNLENBQUN3QixXQUFXQyxhQUFhLEdBQUd6QiwrQ0FBUUEsQ0FBQztJQUMzQyxNQUFNLENBQUMwQixPQUFPQyxTQUFTLEdBQUczQiwrQ0FBUUEsQ0FBZ0I7SUFFbEQsaUZBQWlGO0lBQ2pGLE1BQU0s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O1FBQ0FxQztRQUNBTztRQUNBQztRQUNBTTtRQUNBRjtJQUNGO0lBRUEscUJBQ0UsOERBQUNsRSxpQkFBaUI4RSxRQUFRO1FBQUNELE9BQU9BO2tCQUMvQnhFOzs7Ozs7QUFHUCxFQUFFO0lBOVNXRDs7UUFFS1QsNERBQU1BOzs7S0FGWFMiLCJzb3VyY2VzIjpbIi9ob21lL2xmZy9HaXQvTWFkdHJpcHMvc3JjL2xpYi9ub3N0ci9Ob3N0ckF1dGhQcm92aWRlci50c3giXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgUmVhY3QsIHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlU3RhdGUsIHVzZUVmZmVjdCwgUmVhY3ROb2RlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IE5ESywgeyBOREtOaXAwN1NpZ25lciwgTkRLVXNlciwgTkRLRXZlbnQsIE5ES0ZpbHRlciwgTm9zdHJFdmVudCB9IGZyb20gJ0Bub3N0ci1kZXYta2l0L25kayc7XG5pbXBvcnQgeyB1c2VOREsgfSBmcm9tICdAbm9zdHItZGV2LWtpdC9uZGstcmVhY3QnO1xuaW1wb3J0IHsgbmlwMTkgfSBmcm9tICdub3N0ci10b29scyc7XG5cbi8vIERlZmluZSB0aGUgdHJ1c3QgbGV2ZWwgZW51bVxuZXhwb3J0IGVudW0gVHJ1c3RMZXZlbCB7XG4gIFVOS05PV04gPSAwLFxuICBMT1cgPSAxLFxuICBNRURJVU0gPSAyLFxuICBISUdIID0gMyxcbiAgVkVSSUZJRUQgPSA0XG59XG5cbmludGVyZmFjZSBOb3N0ckF1dGgge1xuICB1c2VyOiB7XG4gICAgcHVia2V5OiBzdHJpbmc7XG4gICAgbnB1Yjogc3RyaW5nO1xuICAgIG5hbWU/OiBzdHJpbmc7XG4gICAgcHJvZmlsZUltYWdlPzogc3RyaW5nO1xuICB9IHwgbnVsbDtcbiAgbnB1Yjogc3RyaW5nIHwgbnVsbDtcbiAgcHVia2V5OiBzdHJpbmcgfCBudWxsO1xuICBpc0Nvbm5lY3RlZDogYm9vbGVhbjtcbiAgaXNMb2FkaW5nOiBib29sZWFuO1xuICBlcnJvcjogc3RyaW5nIHwgbnVsbDtcbiAgbG9naW46ICgpID0+IFByb21pc2U8dm9pZD47XG4gIGxvZ291dDogKCkgPT4gdm9pZDtcbiAgY2hlY2tUcnVzdExldmVsOiAodGFyZ2V0TnB1Yjogc3RyaW5nKSA9PiBQcm9taXNlPFRydXN0TGV2ZWw+O1xuICBwdWJsaXNoRXZlbnQ6IChldmVudDogTm9zdHJFdmVudCkgPT4gUHJvbWlzZTxOREtFdmVudCB8IG51bGw+O1xuICBnZXRXZWJPZlRydXN0OiAoKSA9PiBQcm9taXNlPHtcbiAgICBkaXJlY3RDb25uZWN0aW9uczogc3RyaW5nW107XG4gICAgc2Vjb25kRGVncmVlQ29ubmVjdGlvbnM6IHN0cmluZ1tdO1xuICAgIGNvcmVGb2xsb3dlcnM6IHN0cmluZ1tdO1xuICB9Pjtcbn1cblxuLy8gRGVmaW5lIGNvcmUgTlBVQnMgdG8gY2hlY2sgZm9yIHRydXN0XG5jb25zdCBDT1JFX05QVUJTID0gW1xuICBcIm5wdWIxZXRncWNqOWdjNnlheHR0dXd1OWVxZ3MzeW50MmR6YXVkdnducnNzcm4yemR0MnVzZWFhc2ZqOG42ZVwiLCAvLyBGcmVlIE1hZGVpcmFcbiAgXCJucHViMXMwdmVuZzJndmZ3cjYyYWNyeGhucWV4cTc2c2o2bGRnM2E1dDkzNWp5OGU2dzNzaHI1dnNud3JtcTVcIiwgLy8gQml0Y29pbiBNYWRlaXJhXG4gIFwibnB1YjFkeGQwMmtjamhncGt5cng2MHFua2Q2ajQya21jNzJ1NWx1bTBycDJ1ZDh4NXpmaG5rNHpzY2pqNmhoXCIsIC8vIE1hZHRyaXBzXG4gIFwibnB1YjFmdW5jaGFseDh2NzQ3cnNlZTZhaHN1eXJjZDJzM3JueGx5cnR1bWZleDlsZWNwbWd3YXJzNmhxOGtjXCIsIC8vIEZ1bmNoYWxcbl07XG5cbi8vIERlZmluZSBhIGxpc3Qgb2YgY29tbXVuaXR5IHJlbGF5c1xuY29uc3QgQ09NTVVOSVRZX1JFTEFZUyA9IFtcbiAgXCJ3c3M6Ly9yZWxheS5kYW11cy5pb1wiLFxuICBcIndzczovL3JlbGF5Lm5vc3RyLmJhbmRcIiwgXG4gIFwid3NzOi8vbm9zLmxvbFwiLFxuICBcIndzczovL25vc3RyLm11dGlueXdhbGxldC5jb21cIlxuXTtcblxuLy8gQ3JlYXRlIHRoZSBjb250ZXh0XG5jb25zdCBOb3N0ckF1dGhDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxOb3N0ckF1dGggfCBudWxsPihudWxsKTtcblxuLy8gUHJvdmlkZXIgcHJvcHMgaW50ZXJmYWNlXG5pbnRlcmZhY2UgTm9zdHJBdXRoUHJvdmlkZXJQcm9wcyB7XG4gIGNoaWxkcmVuOiBSZWFjdE5vZGU7XG59XG5cbi8vIEN1c3RvbSBob29rIGZvciBhY2Nlc3NpbmcgdGhlIGNvbnRleHRcbmV4cG9ydCBjb25zdCB1c2VOb3N0ckF1dGggPSAoKSA9PiB7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KE5vc3RyQXV0aENvbnRleHQpO1xuICBpZiAoIWNvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzZU5vc3RyQXV0aCBtdXN0IGJlIHVzZWQgd2l0aGluIGEgTm9zdHJBdXRoUHJvdmlkZXInKTtcbiAgfVxuICByZXR1cm4gY29udGV4dDtcbn07XG5cbi8vIFRoZSBwcm92aWRlciBjb21wb25lbnRcbmV4cG9ydCBjb25zdCBOb3N0ckF1dGhQcm92aWRlcjogUmVhY3QuRkM8Tm9zdHJBdXRoUHJvdmlkZXJQcm9wcz4gPSAoeyBjaGlsZHJlbiB9KSA9PiB7XG4gIC8vIE5ESyBpbnN0YW5jZSBmcm9tIHRoZSBOREsgcHJvdmlkZXJcbiAgY29uc3QgeyBuZGsgfSA9IHVzZU5ESygpO1xuICBcbiAgLy8gU3RhdGUgZm9yIGF1dGhlbnRpY2F0aW9uIHN0YXR1c1xuICBjb25zdCBbdXNlciwgc2V0VXNlcl0gPSB1c2VTdGF0ZTx7IHB1YmtleTogc3RyaW5nOyBucHViOiBzdHJpbmc7IG5hbWU/OiBzdHJpbmc7IHByb2ZpbGVJbWFnZT86IHN0cmluZzsgfSB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbbnB1Yiwgc2V0TnB1Yl0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW3B1YmtleSwgc2V0UHVia2V5XSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbaXNDb25uZWN0ZWQsIHNldElzQ29ubmVjdGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2lzTG9hZGluZywgc2V0SXNMb2FkaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgXG4gIC8vIFJlZmVyZW5jZSB0byB0aGUgY29ubmVjdCBtYW5hZ2VyIC0gd2UnbGwgY3JlYXRlIG91ciBvd24gbWluaW1hbCBpbXBsZW1lbnRhdGlvblxuICBjb25zdCBbY29ubmVjdE1hbmFnZXIsIHNldENvbm5lY3RNYW5hZ2VyXSA9IHVzZVN0YXRlPGFueT4obnVsbCk7XG5cbiAgLy8gSW5pdGlhbGl6ZSBOb3N0ckNvbm5lY3QgLSBzaW1wbGlmaWVkIGZvciB0aGlzIGltcGxlbWVudGF0aW9uXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFuZGspIHJldHVybjtcbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gSW5zdGVhZCBvZiB1c2luZyB0aGUgQ29ubmVjdCBjbGFzcyB3aGljaCBoYXMgY29tcGF0aWJpbGl0eSBpc3N1ZXMsXG4gICAgICAvLyB3ZSdsbCBjcmVhdGUgYSBtaW5pbWFsIG1hbmFnZXIgb2JqZWN0IGZvciB0ZXN0aW5nIHB1cnBvc2VzXG4gICAgICBjb25zdCBtaW5pbWFsTWFuYWdlciA9IHtcbiAgICAgICAgY29ubmVjdDogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIC8vIFNpbXVsYXRlIGNvbm5lY3Rpb24gYnkgcmV0dXJuaW5nIGEgcmFuZG9tIGNvcmUgTlBVQlxuICAgICAgICAgIGNvbnN0IG1vY2tQdWJrZXkgPSBDT1JFX05QVUJTW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIENPUkVfTlBVQlMubGVuZ3RoKV07XG4gICAgICAgICAgY29uc3QgeyBkYXRhOiBoZXhQdWJrZXkgfSA9IG5pcDE5LmRlY29kZShtb2NrUHVia2V5KTtcbiAgICAgICAgICByZXR1cm4geyBwdWJrZXk6IGhleFB1YmtleSwgc2VjcmV0S2V5OiAnbW9ja19zZWNyZXQnIH07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBcbiAgICAgIHNldENvbm5lY3RNYW5hZ2VyKG1pbmltYWxNYW5hZ2VyKTtcbiAgICAgIFxuICAgICAgLy8gVHJ5IHRvIHJlc3RvcmUgc2Vzc2lvblxuICAgICAgY29uc3QgcmVzdG9yZVNlc3Npb24gPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdub3N0clNlc3Npb24nKTtcbiAgICAgICAgICBpZiAoc2Vzc2lvbikge1xuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbkRhdGEgPSBKU09OLnBhcnNlKHNlc3Npb24pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoc2Vzc2lvbkRhdGEgJiYgc2Vzc2lvbkRhdGEucHVia2V5ICYmIHNlc3Npb25EYXRhLm5wdWIpIHtcbiAgICAgICAgICAgICAgc2V0UHVia2V5KHNlc3Npb25EYXRhLnB1YmtleSk7XG4gICAgICAgICAgICAgIHNldE5wdWIoc2Vzc2lvbkRhdGEubnB1Yik7XG4gICAgICAgICAgICAgIHNldElzQ29ubmVjdGVkKHRydWUpO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gQ3JlYXRlIHVzZXIgb2JqZWN0XG4gICAgICAgICAgICAgIGNvbnN0IHVzZXJPYmogPSB7XG4gICAgICAgICAgICAgICAgcHVia2V5OiBzZXNzaW9uRGF0YS5wdWJrZXksXG4gICAgICAgICAgICAgICAgbnB1Yjogc2Vzc2lvbkRhdGEubnB1YixcbiAgICAgICAgICAgICAgICBuYW1lOiBzZXNzaW9uRGF0YS5uYW1lIHx8ICcnLFxuICAgICAgICAgICAgICAgIHByb2ZpbGVJbWFnZTogc2Vzc2lvbkRhdGEucHJvZmlsZUltYWdlIHx8ICcnLFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgc2V0VXNlcih1c2VyT2JqKTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIExvYWQgdGhlIHVzZXIgcHJvZmlsZVxuICAgICAgICAgICAgICBhd2FpdCBsb2FkVXNlclByb2ZpbGUoc2Vzc2lvbkRhdGEubnB1Yik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZXN0b3Jpbmcgc2Vzc2lvbjonLCBlcnIpO1xuICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdub3N0clNlc3Npb24nKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgcmVzdG9yZVNlc3Npb24oKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluaXRpYWxpemluZyBOb3N0cjonLCBlcnIpO1xuICAgICAgc2V0RXJyb3IoJ0ZhaWxlZCB0byBpbml0aWFsaXplIE5vc3RyIGNvbm5lY3Rpb24nKTtcbiAgICB9XG4gIH0sIFtuZGtdKTtcblxuICAvLyBGdW5jdGlvbiB0byBsb2FkIHVzZXIgcHJvZmlsZSBkYXRhXG4gIGNvbnN0IGxvYWRVc2VyUHJvZmlsZSA9IGFzeW5jICh1c2VyTnB1Yjogc3RyaW5nKSA9PiB7XG4gICAgaWYgKCFuZGspIHJldHVybjtcbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gQ3JlYXRlIGFuIE5ESyB1c2VyIGZyb20gdGhlIG5wdWJcbiAgICAgIGNvbnN0IHsgdHlwZSwgZGF0YTogaGV4UHVia2V5IH0gPSBuaXAxOS5kZWNvZGUodXNlck5wdWIpO1xuICAgICAgXG4gICAgICBpZiAodHlwZSAhPT0gJ25wdWInKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBucHViJyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEZldGNoIHVzZXIgcHJvZmlsZVxuICAgICAgY29uc3QgdXNlciA9IG5kay5nZXRVc2VyKHsgcHVia2V5OiBoZXhQdWJrZXkgYXMgc3RyaW5nIH0pO1xuICAgICAgYXdhaXQgdXNlci5mZXRjaFByb2ZpbGUoKTtcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIHVzZXIgZGF0YVxuICAgICAgc2V0VXNlcih7XG4gICAgICAgIHB1YmtleTogaGV4UHVia2V5IGFzIHN0cmluZyxcbiAgICAgICAgbnB1YjogdXNlck5wdWIsXG4gICAgICAgIG5hbWU6IHVzZXIucHJvZmlsZT8ubmFtZSB8fCAnJyxcbiAgICAgICAgcHJvZmlsZUltYWdlOiB1c2VyLnByb2ZpbGU/LmltYWdlIHx8ICcnLFxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIFNhdmUgdG8gbG9jYWwgc3RvcmFnZVxuICAgICAgY29uc3Qgc2Vzc2lvbkRhdGEgPSB7XG4gICAgICAgIHB1YmtleTogaGV4UHVia2V5LFxuICAgICAgICBucHViOiB1c2VyTnB1YixcbiAgICAgICAgbmFtZTogdXNlci5wcm9maWxlPy5uYW1lIHx8ICcnLFxuICAgICAgICBwcm9maWxlSW1hZ2U6IHVzZXIucHJvZmlsZT8uaW1hZ2UgfHwgJycsXG4gICAgICB9O1xuICAgICAgXG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnbm9zdHJTZXNzaW9uJywgSlNPTi5zdHJpbmdpZnkoc2Vzc2lvbkRhdGEpKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgdXNlciBwcm9maWxlOicsIGVycik7XG4gICAgfVxuICB9O1xuXG4gIC8vIExvZ2luIGZ1bmN0aW9uXG4gIGNvbnN0IGxvZ2luID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmICghbmRrIHx8ICFjb25uZWN0TWFuYWdlcikge1xuICAgICAgc2V0RXJyb3IoJ05vc3RyIGNvbm5lY3Rpb24gbm90IGluaXRpYWxpemVkJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIHNldElzTG9hZGluZyh0cnVlKTtcbiAgICBzZXRFcnJvcihudWxsKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gRmlyc3QgdHJ5IE5JUC0wNyBsb2dpbiBpZiBhdmFpbGFibGVcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBicm93c2VyIGhhcyBhIE5JUC0wNyBleHRlbnNpb25cbiAgICAgICAgY29uc3QgaGFzTmlwMDcgPSB3aW5kb3cgJiYgJ25vc3RyJyBpbiB3aW5kb3c7XG4gICAgICAgIFxuICAgICAgICBpZiAoaGFzTmlwMDcpIHtcbiAgICAgICAgICAvLyBVc2UgdGhlIE5JUC0wNyBzaWduZXJcbiAgICAgICAgICBjb25zdCBzaWduZXIgPSBuZXcgTkRLTmlwMDdTaWduZXIoKTtcbiAgICAgICAgICBuZGsuc2lnbmVyID0gc2lnbmVyO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEdldCB0aGUgdXNlcidzIHB1YmxpYyBrZXlcbiAgICAgICAgICBjb25zdCB1c2VyUHVia2V5ID0gYXdhaXQgc2lnbmVyLnVzZXIoKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAodXNlclB1YmtleSkge1xuICAgICAgICAgICAgY29uc3QgdXNlck5wdWIgPSBuaXAxOS5ucHViRW5jb2RlKHVzZXJQdWJrZXkucHVia2V5KTtcbiAgICAgICAgICAgIHNldFB1YmtleSh1c2VyUHVia2V5LnB1YmtleSk7XG4gICAgICAgICAgICBzZXROcHViKHVzZXJOcHViKTtcbiAgICAgICAgICAgIHNldElzQ29ubmVjdGVkKHRydWUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBhd2FpdCBsb2FkVXNlclByb2ZpbGUodXNlck5wdWIpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ05JUC0wNyBsb2dpbiBmYWlsZWQsIGZhbGxpbmcgYmFjayB0byBvdXIgbWluaW1hbCBjb25uZWN0IGltcGxlbWVudGF0aW9uOicsIGVycik7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEZhbGwgYmFjayB0byBvdXIgbWluaW1hbCBjb25uZWN0IGltcGxlbWVudGF0aW9uXG4gICAgICBjb25zdCB7IHB1YmtleTogaGV4UHVia2V5IH0gPSBhd2FpdCBjb25uZWN0TWFuYWdlci5jb25uZWN0KCk7XG4gICAgICBcbiAgICAgIC8vIENvbnZlcnQgdG8gbnB1YlxuICAgICAgY29uc3QgbW9ja1B1YmtleSA9IG5pcDE5Lm5wdWJFbmNvZGUoaGV4UHVia2V5IGFzIHN0cmluZyk7XG4gICAgICBcbiAgICAgIHNldFB1YmtleShoZXhQdWJrZXkgYXMgc3RyaW5nKTtcbiAgICAgIHNldE5wdWIobW9ja1B1YmtleSk7XG4gICAgICBzZXRJc0Nvbm5lY3RlZCh0cnVlKTtcbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIGEgYmFzaWMgdXNlciBvYmplY3RcbiAgICAgIGNvbnN0IHVzZXJPYmogPSB7XG4gICAgICAgIHB1YmtleTogaGV4UHVia2V5IGFzIHN0cmluZyxcbiAgICAgICAgbnB1YjogbW9ja1B1YmtleSxcbiAgICAgICAgbmFtZTogJ1Rlc3QgVXNlcicsXG4gICAgICAgIHByb2ZpbGVJbWFnZTogJycsXG4gICAgICB9O1xuICAgICAgXG4gICAgICBzZXRVc2VyKHVzZXJPYmopO1xuICAgICAgXG4gICAgICAvLyBTYXZlIHRvIGxvY2FsIHN0b3JhZ2VcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdub3N0clNlc3Npb24nLCBKU09OLnN0cmluZ2lmeSh1c2VyT2JqKSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdMb2dpbiBlcnJvcjonLCBlcnIpO1xuICAgICAgc2V0RXJyb3IoJ0ZhaWxlZCB0byBsb2dpbiB3aXRoIE5vc3RyJyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIExvZ291dCBmdW5jdGlvblxuICBjb25zdCBsb2dvdXQgPSAoKSA9PiB7XG4gICAgc2V0VXNlcihudWxsKTtcbiAgICBzZXROcHViKG51bGwpO1xuICAgIHNldFB1YmtleShudWxsKTtcbiAgICBzZXRJc0Nvbm5lY3RlZChmYWxzZSk7XG4gICAgXG4gICAgLy8gQ2xlYXIgbG9jYWwgc3RvcmFnZVxuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdub3N0clNlc3Npb24nKTtcbiAgfTtcblxuICAvLyBDaGVjayB0cnVzdCBsZXZlbCBvZiBhIG5wdWJcbiAgY29uc3QgY2hlY2tUcnVzdExldmVsID0gYXN5bmMgKHRhcmdldE5wdWI6IHN0cmluZyk6IFByb21pc2U8VHJ1c3RMZXZlbD4gPT4ge1xuICAgIGlmICghbmRrIHx8ICFpc0Nvbm5lY3RlZCkgcmV0dXJuIFRydXN0TGV2ZWwuVU5LTk9XTjtcbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gQ2hlY2sgaWYgaXQncyBhIGNvcmUgbnB1YlxuICAgICAgaWYgKENPUkVfTlBVQlMuaW5jbHVkZXModGFyZ2V0TnB1YikpIHtcbiAgICAgICAgcmV0dXJuIFRydXN0TGV2ZWwuVkVSSUZJRUQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIGl0J3MgZGlyZWN0bHkgY29ubmVjdGVkIHRvIHVzXG4gICAgICBjb25zdCB7IGRpcmVjdENvbm5lY3Rpb25zIH0gPSBhd2FpdCBnZXRXZWJPZlRydXN0KCk7XG4gICAgICBpZiAoZGlyZWN0Q29ubmVjdGlvbnMuaW5jbHVkZXModGFyZ2V0TnB1YikpIHtcbiAgICAgICAgcmV0dXJuIFRydXN0TGV2ZWwuSElHSDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgaXQncyBpbmRpcmVjdGx5IGNvbm5lY3RlZFxuICAgICAgY29uc3QgeyBzZWNvbmREZWdyZWVDb25uZWN0aW9ucyB9ID0gYXdhaXQgZ2V0V2ViT2ZUcnVzdCgpO1xuICAgICAgaWYgKHNlY29uZERlZ3JlZUNvbm5lY3Rpb25zLmluY2x1ZGVzKHRhcmdldE5wdWIpKSB7XG4gICAgICAgIHJldHVybiBUcnVzdExldmVsLk1FRElVTTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gT3RoZXJ3aXNlLCBpdCdzIGEgbG93IHRydXN0IGNvbm5lY3Rpb25cbiAgICAgIHJldHVybiBUcnVzdExldmVsLkxPVztcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNoZWNraW5nIHRydXN0IGxldmVsOicsIGVycik7XG4gICAgICByZXR1cm4gVHJ1c3RMZXZlbC5VTktOT1dOO1xuICAgIH1cbiAgfTtcblxuICAvLyBQdWJsaXNoIGFuIGV2ZW50XG4gIGNvbnN0IHB1Ymxpc2hFdmVudCA9IGFzeW5jIChldmVudDogTm9zdHJFdmVudCk6IFByb21pc2U8TkRLRXZlbnQgfCBudWxsPiA9PiB7XG4gICAgaWYgKCFuZGsgfHwgIWlzQ29ubmVjdGVkKSByZXR1cm4gbnVsbDtcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgbmRrRXZlbnQgPSBuZXcgTkRLRXZlbnQobmRrKTtcbiAgICAgIG5ka0V2ZW50LmtpbmQgPSBldmVudC5raW5kO1xuICAgICAgbmRrRXZlbnQuY29udGVudCA9IGV2ZW50LmNvbnRlbnQ7XG4gICAgICBuZGtFdmVudC50YWdzID0gZXZlbnQudGFncyB8fCBbXTtcbiAgICAgIFxuICAgICAgLy8gUHVibGlzaCB0aGUgZXZlbnRcbiAgICAgIGF3YWl0IG5ka0V2ZW50LnB1Ymxpc2goKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIG5ka0V2ZW50O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcHVibGlzaGluZyBldmVudDonLCBlcnIpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9O1xuXG4gIC8vIEdldCB3ZWIgb2YgdHJ1c3RcbiAgY29uc3QgZ2V0V2ViT2ZUcnVzdCA9IGFzeW5jICgpOiBQcm9taXNlPHtcbiAgICBkaXJlY3RDb25uZWN0aW9uczogc3RyaW5nW107XG4gICAgc2Vjb25kRGVncmVlQ29ubmVjdGlvbnM6IHN0cmluZ1tdO1xuICAgIGNvcmVGb2xsb3dlcnM6IHN0cmluZ1tdO1xuICB9PiA9PiB7XG4gICAgaWYgKCFuZGsgfHwgIWlzQ29ubmVjdGVkIHx8ICFwdWJrZXkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpcmVjdENvbm5lY3Rpb25zOiBbXSxcbiAgICAgICAgc2Vjb25kRGVncmVlQ29ubmVjdGlvbnM6IFtdLFxuICAgICAgICBjb3JlRm9sbG93ZXJzOiBbXSxcbiAgICAgIH07XG4gICAgfVxuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBGb3Igc2ltcGxpY2l0eSwgd2UnbGwgdXNlIGEgbW9jayBpbXBsZW1lbnRhdGlvblxuICAgICAgLy8gSW4gYSByZWFsIGltcGxlbWVudGF0aW9uLCB0aGlzIHdvdWxkIHF1ZXJ5IHRoZSByZWxheXMgZm9yIGZvbGxvd3NcbiAgICAgIFxuICAgICAgLy8gTW9jayBkaXJlY3QgY29ubmVjdGlvbnNcbiAgICAgIGNvbnN0IGRpcmVjdENvbm5lY3Rpb25zID0gQ09SRV9OUFVCUy5maWx0ZXIoKCkgPT4gTWF0aC5yYW5kb20oKSA+IDAuNSk7XG4gICAgICBcbiAgICAgIC8vIE1vY2sgc2Vjb25kLWRlZ3JlZSBjb25uZWN0aW9uc1xuICAgICAgY29uc3Qgc2Vjb25kRGVncmVlQ29ubmVjdGlvbnMgPSBDT1JFX05QVUJTLmZpbHRlcigoKSA9PiBNYXRoLnJhbmRvbSgpID4gMC43KTtcbiAgICAgIFxuICAgICAgLy8gTW9jayBjb3JlIGZvbGxvd2Vyc1xuICAgICAgY29uc3QgY29yZUZvbGxvd2VycyA9IENPUkVfTlBVQlMuZmlsdGVyKCgpID0+IE1hdGgucmFuZG9tKCkgPiAwLjgpO1xuICAgICAgXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXJlY3RDb25uZWN0aW9ucyxcbiAgICAgICAgc2Vjb25kRGVncmVlQ29ubmVjdGlvbnMsXG4gICAgICAgIGNvcmVGb2xsb3dlcnMsXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyB3ZWIgb2YgdHJ1c3Q6JywgZXJyKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpcmVjdENvbm5lY3Rpb25zOiBbXSxcbiAgICAgICAgc2Vjb25kRGVncmVlQ29ubmVjdGlvbnM6IFtdLFxuICAgICAgICBjb3JlRm9sbG93ZXJzOiBbXSxcbiAgICAgIH07XG4gICAgfVxuICB9O1xuXG4gIC8vIENvbnRleHQgdmFsdWVcbiAgY29uc3QgdmFsdWU6IE5vc3RyQXV0aCA9IHtcbiAgICB1c2VyLFxuICAgIG5wdWIsXG4gICAgcHVia2V5LFxuICAgIGlzQ29ubmVjdGVkLFxuICAgIGlzTG9hZGluZyxcbiAgICBlcnJvcixcbiAgICBsb2dpbixcbiAgICBsb2dvdXQsXG4gICAgY2hlY2tUcnVzdExldmVsLFxuICAgIHB1Ymxpc2hFdmVudCxcbiAgICBnZXRXZWJPZlRydXN0LFxuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPE5vc3RyQXV0aENvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3ZhbHVlfT5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L05vc3RyQXV0aENvbnRleHQuUHJvdmlkZXI+XG4gICk7XG59OyAiXSwibmFtZXMiOlsiUmVhY3QiLCJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwiTkRLTmlwMDdTaWduZXIiLCJOREtFdmVudCIsInVzZU5ESyIsIm5pcDE5IiwiVHJ1c3RMZXZlbCIsIkNPUkVfTlBVQlMiLCJDT01NVU5JVFlfUkVMQVlTIiwiTm9zdHJBdXRoQ29udGV4dCIsInVzZU5vc3RyQXV0aCIsImNvbnRleHQiLCJFcnJvciIsIk5vc3RyQXV0aFByb3ZpZGVyIiwiY2hpbGRyZW4iLCJuZGsiLCJ1c2VyIiwic2V0VXNlciIsIm5wdWIiLCJzZXROcHViIiwicHVia2V5Iiwic2V0UHVia2V5IiwiaXNDb25uZWN0ZWQiLCJzZXRJc0Nvbm5lY3RlZCIsImlzTG9hZGluZyIsInNldElzTG9hZGluZyIsImVycm9yIiwic2V0RXJyb3IiLCJjb25uZWN0TWFuYWdlciIsInNldENvbm5lY3RNYW5hZ2VyIiwibWluaW1hbE1hbmFnZXIiLCJjb25uZWN0IiwibW9ja1B1YmtleSIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsImxlbmd0aCIsImRhdGEiLCJoZXhQdWJrZXkiLCJkZWNvZGUiLCJzZWNyZXRLZXkiLCJyZXN0b3JlU2Vzc2lvbiIsInNlc3Npb24iLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwic2Vzc2lvbkRhdGEiLCJKU09OIiwicGFyc2UiLCJ1c2VyT2JqIiwibmFtZSIsInByb2ZpbGVJbWFnZSIsImxvYWRVc2VyUHJvZmlsZSIsImVyciIsImNvbnNvbGUiLCJyZW1vdmVJdGVtIiwidXNlck5wdWIiLCJ0eXBlIiwiZ2V0VXNlciIsImZldGNoUHJvZmlsZSIsInByb2ZpbGUiLCJpbWFnZSIsInNldEl0ZW0iLCJzdHJpbmdpZnkiLCJsb2dpbiIsImhhc05pcDA3Iiwid2luZG93Iiwic2lnbmVyIiwidXNlclB1YmtleSIsIm5wdWJFbmNvZGUiLCJsb2ciLCJsb2dvdXQiLCJjaGVja1RydXN0TGV2ZWwiLCJ0YXJnZXROcHViIiwiaW5jbHVkZXMiLCJkaXJlY3RDb25uZWN0aW9ucyIsImdldFdlYk9mVHJ1c3QiLCJzZWNvbmREZWdyZWVDb25uZWN0aW9ucyIsInB1Ymxpc2hFdmVudCIsImV2ZW50IiwibmRrRXZlbnQiLCJraW5kIiwiY29udGVudCIsInRhZ3MiLCJwdWJsaXNoIiwiY29yZUZvbGxvd2VycyIsImZpbHRlciIsInZhbHVlIiwiUHJvdmlkZXIiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/nostr/NostrAuthProvider.tsx\n"));

/***/ })

});