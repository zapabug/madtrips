/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./node_modules/@noble/curves/esm/_shortw_utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/@noble/curves/esm/_shortw_utils.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createCurve: () => (/* binding */ createCurve),\n/* harmony export */   getHash: () => (/* binding */ getHash)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/hmac */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/hmac.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/utils */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/**\n * Utilities for short weierstrass curves, combined with noble-hashes.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\n\n/** connects noble-curves to noble-hashes */\nfunction getHash(hash) {\n    return {\n        hash,\n        hmac: (key, ...msgs) => (0,_noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__.hmac)(hash, key, (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(...msgs)),\n        randomBytes: _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.randomBytes,\n    };\n}\nfunction createCurve(curveDef, defHash) {\n    const create = (hash) => (0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__.weierstrass)({ ...curveDef, ...getHash(hash) });\n    return { ...create(defHash), create };\n}\n//# sourceMappingURL=_shortw_utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9fc2hvcnR3X3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUMwQztBQUNxQjtBQUNQO0FBQ3hEO0FBQ087QUFDUDtBQUNBO0FBQ0EsZ0NBQWdDLHdEQUFJLFlBQVksZ0VBQVc7QUFDM0QsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDTztBQUNQLDZCQUE2QixxRUFBVyxHQUFHLCtCQUErQjtBQUMxRSxhQUFhO0FBQ2I7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbGZnL0dpdC9NYWR0cmlwcy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vX3Nob3J0d191dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFV0aWxpdGllcyBmb3Igc2hvcnQgd2VpZXJzdHJhc3MgY3VydmVzLCBjb21iaW5lZCB3aXRoIG5vYmxlLWhhc2hlcy5cbiAqIEBtb2R1bGVcbiAqL1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0IHsgaG1hYyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvaG1hYyc7XG5pbXBvcnQgeyBjb25jYXRCeXRlcywgcmFuZG9tQnl0ZXMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3V0aWxzJztcbmltcG9ydCB7IHdlaWVyc3RyYXNzIH0gZnJvbSAnLi9hYnN0cmFjdC93ZWllcnN0cmFzcy5qcyc7XG4vKiogY29ubmVjdHMgbm9ibGUtY3VydmVzIHRvIG5vYmxlLWhhc2hlcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEhhc2goaGFzaCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGhhc2gsXG4gICAgICAgIGhtYWM6IChrZXksIC4uLm1zZ3MpID0+IGhtYWMoaGFzaCwga2V5LCBjb25jYXRCeXRlcyguLi5tc2dzKSksXG4gICAgICAgIHJhbmRvbUJ5dGVzLFxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ3VydmUoY3VydmVEZWYsIGRlZkhhc2gpIHtcbiAgICBjb25zdCBjcmVhdGUgPSAoaGFzaCkgPT4gd2VpZXJzdHJhc3MoeyAuLi5jdXJ2ZURlZiwgLi4uZ2V0SGFzaChoYXNoKSB9KTtcbiAgICByZXR1cm4geyAuLi5jcmVhdGUoZGVmSGFzaCksIGNyZWF0ZSB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3Nob3J0d191dGlscy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/esm/_shortw_utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/curve.js":
/*!**********************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/curve.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   pippenger: () => (/* binding */ pippenger),\n/* harmony export */   precomputeMSMUnsafe: () => (/* binding */ precomputeMSMUnsafe),\n/* harmony export */   validateBasic: () => (/* binding */ validateBasic),\n/* harmony export */   wNAF: () => (/* binding */ wNAF)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modular.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/**\n * Methods for elliptic curve multiplication by scalars.\n * Contains wNAF, pippenger\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nfunction constTimeNegate(condition, item) {\n    const neg = item.negate();\n    return condition ? neg : item;\n}\nfunction validateW(W, bits) {\n    if (!Number.isSafeInteger(W) || W <= 0 || W > bits)\n        throw new Error('invalid window size, expected [1..' + bits + '], got W=' + W);\n}\nfunction calcWOpts(W, bits) {\n    validateW(W, bits);\n    const windows = Math.ceil(bits / W) + 1; // +1, because\n    const windowSize = 2 ** (W - 1); // -1 because we skip zero\n    return { windows, windowSize };\n}\nfunction validateMSMPoints(points, c) {\n    if (!Array.isArray(points))\n        throw new Error('array expected');\n    points.forEach((p, i) => {\n        if (!(p instanceof c))\n            throw new Error('invalid point at index ' + i);\n    });\n}\nfunction validateMSMScalars(scalars, field) {\n    if (!Array.isArray(scalars))\n        throw new Error('array of scalars expected');\n    scalars.forEach((s, i) => {\n        if (!field.isValid(s))\n            throw new Error('invalid scalar at index ' + i);\n    });\n}\n// Since points in different groups cannot be equal (different object constructor),\n// we can have single place to store precomputes\nconst pointPrecomputes = new WeakMap();\nconst pointWindowSizes = new WeakMap(); // This allows use make points immutable (nothing changes inside)\nfunction getW(P) {\n    return pointWindowSizes.get(P) || 1;\n}\n/**\n * Elliptic curve multiplication of Point by scalar. Fragile.\n * Scalars should always be less than curve order: this should be checked inside of a curve itself.\n * Creates precomputation tables for fast multiplication:\n * - private scalar is split by fixed size windows of W bits\n * - every window point is collected from window's table & added to accumulator\n * - since windows are different, same point inside tables won't be accessed more than once per calc\n * - each multiplication is 'Math.ceil(CURVE_ORDER / ùëä) + 1' point additions (fixed for any scalar)\n * - +1 window is neccessary for wNAF\n * - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n *\n * @todo Research returning 2d JS array of windows, instead of a single window.\n * This would allow windows to be in different memory locations\n */\nfunction wNAF(c, bits) {\n    return {\n        constTimeNegate,\n        hasPrecomputes(elm) {\n            return getW(elm) !== 1;\n        },\n        // non-const time multiplication ladder\n        unsafeLadder(elm, n, p = c.ZERO) {\n            let d = elm;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(ùëä‚àí1) * (Math.ceil(ùëõ / ùëä) + 1), where:\n         * - ùëä is the window size\n         * - ùëõ is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @param elm Point instance\n         * @param W window size\n         * @returns precomputed point tables flattened to a single array\n         */\n        precomputeWindow(elm, W) {\n            const { windows, windowSize } = calcWOpts(W, bits);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for (let window = 0; window < windows; window++) {\n                base = p;\n                points.push(base);\n                // =1, because we skip zero\n                for (let i = 1; i < windowSize; i++) {\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */\n        wNAF(W, precomputes, n) {\n            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n            // But need to carefully remove other checks before wNAF. ORDER == bits here\n            const { windows, windowSize } = calcWOpts(W, bits);\n            let p = c.ZERO;\n            let f = c.BASE;\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for (let window = 0; window < windows; window++) {\n                const offset = window * windowSize;\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n                // there is negate now: it is possible that negated element from low value\n                // would be the same as high element, which will create carry into next window.\n                // It's not obvious how this can fail, but still worth investigating later.\n                // Check if we're onto Zero point.\n                // Add random point inside current window to f.\n                const offset1 = offset;\n                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n                const cond1 = window % 2 !== 0;\n                const cond2 = wbits < 0;\n                if (wbits === 0) {\n                    // The most important part for const-time getPublicKey\n                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n                }\n                else {\n                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n                }\n            }\n            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n            // Even if the variable is still unused, there are some checks which will\n            // throw an exception, so compiler needs to prove they won't happen, which is hard.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return { p, f };\n        },\n        /**\n         * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @param acc accumulator point to add result of multiplication\n         * @returns point\n         */\n        wNAFUnsafe(W, precomputes, n, acc = c.ZERO) {\n            const { windows, windowSize } = calcWOpts(W, bits);\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for (let window = 0; window < windows; window++) {\n                const offset = window * windowSize;\n                if (n === _0n)\n                    break; // No need to go over empty scalar\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                if (wbits === 0)\n                    continue;\n                let curr = precomputes[offset + Math.abs(wbits) - 1]; // -1 because we skip zero\n                if (wbits < 0)\n                    curr = curr.negate();\n                // NOTE: by re-using acc, we can save a lot of additions in case of MSM\n                acc = acc.add(curr);\n            }\n            return acc;\n        },\n        getPrecomputes(W, P, transform) {\n            // Calculate precomputes on a first run, reuse them after\n            let comp = pointPrecomputes.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1)\n                    pointPrecomputes.set(P, transform(comp));\n            }\n            return comp;\n        },\n        wNAFCached(P, n, transform) {\n            const W = getW(P);\n            return this.wNAF(W, this.getPrecomputes(W, P, transform), n);\n        },\n        wNAFCachedUnsafe(P, n, transform, prev) {\n            const W = getW(P);\n            if (W === 1)\n                return this.unsafeLadder(P, n, prev); // For W=1 ladder is ~x2 faster\n            return this.wNAFUnsafe(W, this.getPrecomputes(W, P, transform), n, prev);\n        },\n        // We calculate precomputes for elliptic curve point multiplication\n        // using windowed method. This specifies window size and\n        // stores precomputed values. Usually only base point would be precomputed.\n        setWindowSize(P, W) {\n            validateW(W, bits);\n            pointWindowSizes.set(P, W);\n            pointPrecomputes.delete(P);\n        },\n    };\n}\n/**\n * Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * 30x faster vs naive addition on L=4096, 10x faster with precomputes.\n * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.\n * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @param scalars array of L scalars (aka private keys / bigints)\n */\nfunction pippenger(c, fieldN, points, scalars) {\n    // If we split scalars by some window (let's say 8 bits), every chunk will only\n    // take 256 buckets even if there are 4096 scalars, also re-uses double.\n    // TODO:\n    // - https://eprint.iacr.org/2024/750.pdf\n    // - https://tches.iacr.org/index.php/TCHES/article/view/10287\n    // 0 is accepted in scalars\n    validateMSMPoints(points, c);\n    validateMSMScalars(scalars, fieldN);\n    if (points.length !== scalars.length)\n        throw new Error('arrays of points and scalars must have equal length');\n    const zero = c.ZERO;\n    const wbits = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitLen)(BigInt(points.length));\n    const windowSize = wbits > 12 ? wbits - 3 : wbits > 4 ? wbits - 2 : wbits ? 2 : 1; // in bits\n    const MASK = (1 << windowSize) - 1;\n    const buckets = new Array(MASK + 1).fill(zero); // +1 for zero array\n    const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;\n    let sum = zero;\n    for (let i = lastBits; i >= 0; i -= windowSize) {\n        buckets.fill(zero);\n        for (let j = 0; j < scalars.length; j++) {\n            const scalar = scalars[j];\n            const wbits = Number((scalar >> BigInt(i)) & BigInt(MASK));\n            buckets[wbits] = buckets[wbits].add(points[j]);\n        }\n        let resI = zero; // not using this will do small speed-up, but will lose ct\n        // Skip first bucket, because it is zero\n        for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {\n            sumI = sumI.add(buckets[j]);\n            resI = resI.add(sumI);\n        }\n        sum = sum.add(resI);\n        if (i !== 0)\n            for (let j = 0; j < windowSize; j++)\n                sum = sum.double();\n    }\n    return sum;\n}\n/**\n * Precomputed multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @returns function which multiplies points with scaars\n */\nfunction precomputeMSMUnsafe(c, fieldN, points, windowSize) {\n    /**\n     * Performance Analysis of Window-based Precomputation\n     *\n     * Base Case (256-bit scalar, 8-bit window):\n     * - Standard precomputation requires:\n     *   - 31 additions per scalar √ó 256 scalars = 7,936 ops\n     *   - Plus 255 summary additions = 8,191 total ops\n     *   Note: Summary additions can be optimized via accumulator\n     *\n     * Chunked Precomputation Analysis:\n     * - Using 32 chunks requires:\n     *   - 255 additions per chunk\n     *   - 256 doublings\n     *   - Total: (255 √ó 32) + 256 = 8,416 ops\n     *\n     * Memory Usage Comparison:\n     * Window Size | Standard Points | Chunked Points\n     * ------------|-----------------|---------------\n     *     4-bit   |     520         |      15\n     *     8-bit   |    4,224        |     255\n     *    10-bit   |   13,824        |   1,023\n     *    16-bit   |  557,056        |  65,535\n     *\n     * Key Advantages:\n     * 1. Enables larger window sizes due to reduced memory overhead\n     * 2. More efficient for smaller scalar counts:\n     *    - 16 chunks: (16 √ó 255) + 256 = 4,336 ops\n     *    - ~2x faster than standard 8,191 ops\n     *\n     * Limitations:\n     * - Not suitable for plain precomputes (requires 256 constant doublings)\n     * - Performance degrades with larger scalar counts:\n     *   - Optimal for ~256 scalars\n     *   - Less efficient for 4096+ scalars (Pippenger preferred)\n     */\n    validateW(windowSize, fieldN.BITS);\n    validateMSMPoints(points, c);\n    const zero = c.ZERO;\n    const tableSize = 2 ** windowSize - 1; // table size (without zero)\n    const chunks = Math.ceil(fieldN.BITS / windowSize); // chunks of item\n    const MASK = BigInt((1 << windowSize) - 1);\n    const tables = points.map((p) => {\n        const res = [];\n        for (let i = 0, acc = p; i < tableSize; i++) {\n            res.push(acc);\n            acc = acc.add(p);\n        }\n        return res;\n    });\n    return (scalars) => {\n        validateMSMScalars(scalars, fieldN);\n        if (scalars.length > points.length)\n            throw new Error('array of scalars must be smaller than array of points');\n        let res = zero;\n        for (let i = 0; i < chunks; i++) {\n            // No need to double if accumulator is still zero.\n            if (res !== zero)\n                for (let j = 0; j < windowSize; j++)\n                    res = res.double();\n            const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);\n            for (let j = 0; j < scalars.length; j++) {\n                const n = scalars[j];\n                const curr = Number((n >> shiftBy) & MASK);\n                if (!curr)\n                    continue; // skip zero scalars chunks\n                res = res.add(tables[j][curr - 1]);\n            }\n        }\n        return res;\n    };\n}\nfunction validateBasic(curve) {\n    (0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.validateField)(curve.Fp);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(curve, {\n        n: 'bigint',\n        h: 'bigint',\n        Gx: 'field',\n        Gy: 'field',\n    }, {\n        nBitLength: 'isSafeInteger',\n        nByteLength: 'isSafeInteger',\n    });\n    // Set defaults\n    return Object.freeze({\n        ...(0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.nLength)(curve.n, curve.nBitLength),\n        ...curve,\n        ...{ p: curve.Fp.ORDER },\n    });\n}\n//# sourceMappingURL=curve.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9jdXJ2ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDc0Q7QUFDRjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0MscUNBQXFDO0FBQ3JDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtCQUFrQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0JBQWdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0EsaUNBQWlDLGtCQUFrQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUMsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQSxpQ0FBaUMsa0JBQWtCO0FBQ25EO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaURBQU07QUFDeEIsdUZBQXVGO0FBQ3ZGO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQSwyQkFBMkIsUUFBUTtBQUNuQztBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxzREFBc0QsT0FBTztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGdCQUFnQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBLGdDQUFnQyxnQkFBZ0I7QUFDaEQ7QUFDQTtBQUNBLDRCQUE0QixvQkFBb0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsSUFBSSwwREFBYTtBQUNqQixJQUFJLHlEQUFjO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFdBQVcsb0RBQU87QUFDbEI7QUFDQSxhQUFhLG1CQUFtQjtBQUNoQyxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbGZnL0dpdC9NYWR0cmlwcy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvY3VydmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBNZXRob2RzIGZvciBlbGxpcHRpYyBjdXJ2ZSBtdWx0aXBsaWNhdGlvbiBieSBzY2FsYXJzLlxuICogQ29udGFpbnMgd05BRiwgcGlwcGVuZ2VyXG4gKiBAbW9kdWxlXG4gKi9cbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmltcG9ydCB7IG5MZW5ndGgsIHZhbGlkYXRlRmllbGQgfSBmcm9tICcuL21vZHVsYXIuanMnO1xuaW1wb3J0IHsgYml0TGVuLCB2YWxpZGF0ZU9iamVjdCB9IGZyb20gJy4vdXRpbHMuanMnO1xuY29uc3QgXzBuID0gQmlnSW50KDApO1xuY29uc3QgXzFuID0gQmlnSW50KDEpO1xuZnVuY3Rpb24gY29uc3RUaW1lTmVnYXRlKGNvbmRpdGlvbiwgaXRlbSkge1xuICAgIGNvbnN0IG5lZyA9IGl0ZW0ubmVnYXRlKCk7XG4gICAgcmV0dXJuIGNvbmRpdGlvbiA/IG5lZyA6IGl0ZW07XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVcoVywgYml0cykge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoVykgfHwgVyA8PSAwIHx8IFcgPiBiaXRzKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgd2luZG93IHNpemUsIGV4cGVjdGVkIFsxLi4nICsgYml0cyArICddLCBnb3QgVz0nICsgVyk7XG59XG5mdW5jdGlvbiBjYWxjV09wdHMoVywgYml0cykge1xuICAgIHZhbGlkYXRlVyhXLCBiaXRzKTtcbiAgICBjb25zdCB3aW5kb3dzID0gTWF0aC5jZWlsKGJpdHMgLyBXKSArIDE7IC8vICsxLCBiZWNhdXNlXG4gICAgY29uc3Qgd2luZG93U2l6ZSA9IDIgKiogKFcgLSAxKTsgLy8gLTEgYmVjYXVzZSB3ZSBza2lwIHplcm9cbiAgICByZXR1cm4geyB3aW5kb3dzLCB3aW5kb3dTaXplIH07XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU1TTVBvaW50cyhwb2ludHMsIGMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocG9pbnRzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhcnJheSBleHBlY3RlZCcpO1xuICAgIHBvaW50cy5mb3JFYWNoKChwLCBpKSA9PiB7XG4gICAgICAgIGlmICghKHAgaW5zdGFuY2VvZiBjKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwb2ludCBhdCBpbmRleCAnICsgaSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU1TTVNjYWxhcnMoc2NhbGFycywgZmllbGQpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NhbGFycykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYXJyYXkgb2Ygc2NhbGFycyBleHBlY3RlZCcpO1xuICAgIHNjYWxhcnMuZm9yRWFjaCgocywgaSkgPT4ge1xuICAgICAgICBpZiAoIWZpZWxkLmlzVmFsaWQocykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2NhbGFyIGF0IGluZGV4ICcgKyBpKTtcbiAgICB9KTtcbn1cbi8vIFNpbmNlIHBvaW50cyBpbiBkaWZmZXJlbnQgZ3JvdXBzIGNhbm5vdCBiZSBlcXVhbCAoZGlmZmVyZW50IG9iamVjdCBjb25zdHJ1Y3RvciksXG4vLyB3ZSBjYW4gaGF2ZSBzaW5nbGUgcGxhY2UgdG8gc3RvcmUgcHJlY29tcHV0ZXNcbmNvbnN0IHBvaW50UHJlY29tcHV0ZXMgPSBuZXcgV2Vha01hcCgpO1xuY29uc3QgcG9pbnRXaW5kb3dTaXplcyA9IG5ldyBXZWFrTWFwKCk7IC8vIFRoaXMgYWxsb3dzIHVzZSBtYWtlIHBvaW50cyBpbW11dGFibGUgKG5vdGhpbmcgY2hhbmdlcyBpbnNpZGUpXG5mdW5jdGlvbiBnZXRXKFApIHtcbiAgICByZXR1cm4gcG9pbnRXaW5kb3dTaXplcy5nZXQoUCkgfHwgMTtcbn1cbi8qKlxuICogRWxsaXB0aWMgY3VydmUgbXVsdGlwbGljYXRpb24gb2YgUG9pbnQgYnkgc2NhbGFyLiBGcmFnaWxlLlxuICogU2NhbGFycyBzaG91bGQgYWx3YXlzIGJlIGxlc3MgdGhhbiBjdXJ2ZSBvcmRlcjogdGhpcyBzaG91bGQgYmUgY2hlY2tlZCBpbnNpZGUgb2YgYSBjdXJ2ZSBpdHNlbGYuXG4gKiBDcmVhdGVzIHByZWNvbXB1dGF0aW9uIHRhYmxlcyBmb3IgZmFzdCBtdWx0aXBsaWNhdGlvbjpcbiAqIC0gcHJpdmF0ZSBzY2FsYXIgaXMgc3BsaXQgYnkgZml4ZWQgc2l6ZSB3aW5kb3dzIG9mIFcgYml0c1xuICogLSBldmVyeSB3aW5kb3cgcG9pbnQgaXMgY29sbGVjdGVkIGZyb20gd2luZG93J3MgdGFibGUgJiBhZGRlZCB0byBhY2N1bXVsYXRvclxuICogLSBzaW5jZSB3aW5kb3dzIGFyZSBkaWZmZXJlbnQsIHNhbWUgcG9pbnQgaW5zaWRlIHRhYmxlcyB3b24ndCBiZSBhY2Nlc3NlZCBtb3JlIHRoYW4gb25jZSBwZXIgY2FsY1xuICogLSBlYWNoIG11bHRpcGxpY2F0aW9uIGlzICdNYXRoLmNlaWwoQ1VSVkVfT1JERVIgLyDwnZGKKSArIDEnIHBvaW50IGFkZGl0aW9ucyAoZml4ZWQgZm9yIGFueSBzY2FsYXIpXG4gKiAtICsxIHdpbmRvdyBpcyBuZWNjZXNzYXJ5IGZvciB3TkFGXG4gKiAtIHdOQUYgcmVkdWNlcyB0YWJsZSBzaXplOiAyeCBsZXNzIG1lbW9yeSArIDJ4IGZhc3RlciBnZW5lcmF0aW9uLCBidXQgMTAlIHNsb3dlciBtdWx0aXBsaWNhdGlvblxuICpcbiAqIEB0b2RvIFJlc2VhcmNoIHJldHVybmluZyAyZCBKUyBhcnJheSBvZiB3aW5kb3dzLCBpbnN0ZWFkIG9mIGEgc2luZ2xlIHdpbmRvdy5cbiAqIFRoaXMgd291bGQgYWxsb3cgd2luZG93cyB0byBiZSBpbiBkaWZmZXJlbnQgbWVtb3J5IGxvY2F0aW9uc1xuICovXG5leHBvcnQgZnVuY3Rpb24gd05BRihjLCBiaXRzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29uc3RUaW1lTmVnYXRlLFxuICAgICAgICBoYXNQcmVjb21wdXRlcyhlbG0pIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRXKGVsbSkgIT09IDE7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIG5vbi1jb25zdCB0aW1lIG11bHRpcGxpY2F0aW9uIGxhZGRlclxuICAgICAgICB1bnNhZmVMYWRkZXIoZWxtLCBuLCBwID0gYy5aRVJPKSB7XG4gICAgICAgICAgICBsZXQgZCA9IGVsbTtcbiAgICAgICAgICAgIHdoaWxlIChuID4gXzBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKG4gJiBfMW4pXG4gICAgICAgICAgICAgICAgICAgIHAgPSBwLmFkZChkKTtcbiAgICAgICAgICAgICAgICBkID0gZC5kb3VibGUoKTtcbiAgICAgICAgICAgICAgICBuID4+PSBfMW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSB3TkFGIHByZWNvbXB1dGF0aW9uIHdpbmRvdy4gVXNlZCBmb3IgY2FjaGluZy5cbiAgICAgICAgICogRGVmYXVsdCB3aW5kb3cgc2l6ZSBpcyBzZXQgYnkgYHV0aWxzLnByZWNvbXB1dGUoKWAgYW5kIGlzIGVxdWFsIHRvIDguXG4gICAgICAgICAqIE51bWJlciBvZiBwcmVjb21wdXRlZCBwb2ludHMgZGVwZW5kcyBvbiB0aGUgY3VydmUgc2l6ZTpcbiAgICAgICAgICogMl4o8J2RiuKIkjEpICogKE1hdGguY2VpbCjwnZGbIC8g8J2RiikgKyAxKSwgd2hlcmU6XG4gICAgICAgICAqIC0g8J2RiiBpcyB0aGUgd2luZG93IHNpemVcbiAgICAgICAgICogLSDwnZGbIGlzIHRoZSBiaXRsZW5ndGggb2YgdGhlIGN1cnZlIG9yZGVyLlxuICAgICAgICAgKiBGb3IgYSAyNTYtYml0IGN1cnZlIGFuZCB3aW5kb3cgc2l6ZSA4LCB0aGUgbnVtYmVyIG9mIHByZWNvbXB1dGVkIHBvaW50cyBpcyAxMjggKiAzMyA9IDQyMjQuXG4gICAgICAgICAqIEBwYXJhbSBlbG0gUG9pbnQgaW5zdGFuY2VcbiAgICAgICAgICogQHBhcmFtIFcgd2luZG93IHNpemVcbiAgICAgICAgICogQHJldHVybnMgcHJlY29tcHV0ZWQgcG9pbnQgdGFibGVzIGZsYXR0ZW5lZCB0byBhIHNpbmdsZSBhcnJheVxuICAgICAgICAgKi9cbiAgICAgICAgcHJlY29tcHV0ZVdpbmRvdyhlbG0sIFcpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgd2luZG93cywgd2luZG93U2l6ZSB9ID0gY2FsY1dPcHRzKFcsIGJpdHMpO1xuICAgICAgICAgICAgY29uc3QgcG9pbnRzID0gW107XG4gICAgICAgICAgICBsZXQgcCA9IGVsbTtcbiAgICAgICAgICAgIGxldCBiYXNlID0gcDtcbiAgICAgICAgICAgIGZvciAobGV0IHdpbmRvdyA9IDA7IHdpbmRvdyA8IHdpbmRvd3M7IHdpbmRvdysrKSB7XG4gICAgICAgICAgICAgICAgYmFzZSA9IHA7XG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goYmFzZSk7XG4gICAgICAgICAgICAgICAgLy8gPTEsIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB3aW5kb3dTaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYmFzZSA9IGJhc2UuYWRkKHApO1xuICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChiYXNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcCA9IGJhc2UuZG91YmxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcG9pbnRzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogSW1wbGVtZW50cyBlYyBtdWx0aXBsaWNhdGlvbiB1c2luZyBwcmVjb21wdXRlZCB0YWJsZXMgYW5kIHctYXJ5IG5vbi1hZGphY2VudCBmb3JtLlxuICAgICAgICAgKiBAcGFyYW0gVyB3aW5kb3cgc2l6ZVxuICAgICAgICAgKiBAcGFyYW0gcHJlY29tcHV0ZXMgcHJlY29tcHV0ZWQgdGFibGVzXG4gICAgICAgICAqIEBwYXJhbSBuIHNjYWxhciAod2UgZG9uJ3QgY2hlY2sgaGVyZSwgYnV0IHNob3VsZCBiZSBsZXNzIHRoYW4gY3VydmUgb3JkZXIpXG4gICAgICAgICAqIEByZXR1cm5zIHJlYWwgYW5kIGZha2UgKGZvciBjb25zdC10aW1lKSBwb2ludHNcbiAgICAgICAgICovXG4gICAgICAgIHdOQUYoVywgcHJlY29tcHV0ZXMsIG4pIHtcbiAgICAgICAgICAgIC8vIFRPRE86IG1heWJlIGNoZWNrIHRoYXQgc2NhbGFyIGlzIGxlc3MgdGhhbiBncm91cCBvcmRlcj8gd05BRiBiZWhhdmlvdXMgaXMgdW5kZWZpbmVkIG90aGVyd2lzZVxuICAgICAgICAgICAgLy8gQnV0IG5lZWQgdG8gY2FyZWZ1bGx5IHJlbW92ZSBvdGhlciBjaGVja3MgYmVmb3JlIHdOQUYuIE9SREVSID09IGJpdHMgaGVyZVxuICAgICAgICAgICAgY29uc3QgeyB3aW5kb3dzLCB3aW5kb3dTaXplIH0gPSBjYWxjV09wdHMoVywgYml0cyk7XG4gICAgICAgICAgICBsZXQgcCA9IGMuWkVSTztcbiAgICAgICAgICAgIGxldCBmID0gYy5CQVNFO1xuICAgICAgICAgICAgY29uc3QgbWFzayA9IEJpZ0ludCgyICoqIFcgLSAxKTsgLy8gQ3JlYXRlIG1hc2sgd2l0aCBXIG9uZXM6IDBiMTExMSBmb3IgVz00IGV0Yy5cbiAgICAgICAgICAgIGNvbnN0IG1heE51bWJlciA9IDIgKiogVztcbiAgICAgICAgICAgIGNvbnN0IHNoaWZ0QnkgPSBCaWdJbnQoVyk7XG4gICAgICAgICAgICBmb3IgKGxldCB3aW5kb3cgPSAwOyB3aW5kb3cgPCB3aW5kb3dzOyB3aW5kb3crKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHdpbmRvdyAqIHdpbmRvd1NpemU7XG4gICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBXIGJpdHMuXG4gICAgICAgICAgICAgICAgbGV0IHdiaXRzID0gTnVtYmVyKG4gJiBtYXNrKTtcbiAgICAgICAgICAgICAgICAvLyBTaGlmdCBudW1iZXIgYnkgVyBiaXRzLlxuICAgICAgICAgICAgICAgIG4gPj49IHNoaWZ0Qnk7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGJpdHMgYXJlIGJpZ2dlciB0aGFuIG1heCBzaXplLCB3ZSdsbCBzcGxpdCB0aG9zZS5cbiAgICAgICAgICAgICAgICAvLyArMjI0ID0+IDI1NiAtIDMyXG4gICAgICAgICAgICAgICAgaWYgKHdiaXRzID4gd2luZG93U2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICB3Yml0cyAtPSBtYXhOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgIG4gKz0gXzFuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGNvZGUgd2FzIGZpcnN0IHdyaXR0ZW4gd2l0aCBhc3N1bXB0aW9uIHRoYXQgJ2YnIGFuZCAncCcgd2lsbCBuZXZlciBiZSBpbmZpbml0eSBwb2ludDpcbiAgICAgICAgICAgICAgICAvLyBzaW5jZSBlYWNoIGFkZGl0aW9uIGlzIG11bHRpcGxpZWQgYnkgMiAqKiBXLCBpdCBjYW5ub3QgY2FuY2VsIGVhY2ggb3RoZXIuIEhvd2V2ZXIsXG4gICAgICAgICAgICAgICAgLy8gdGhlcmUgaXMgbmVnYXRlIG5vdzogaXQgaXMgcG9zc2libGUgdGhhdCBuZWdhdGVkIGVsZW1lbnQgZnJvbSBsb3cgdmFsdWVcbiAgICAgICAgICAgICAgICAvLyB3b3VsZCBiZSB0aGUgc2FtZSBhcyBoaWdoIGVsZW1lbnQsIHdoaWNoIHdpbGwgY3JlYXRlIGNhcnJ5IGludG8gbmV4dCB3aW5kb3cuXG4gICAgICAgICAgICAgICAgLy8gSXQncyBub3Qgb2J2aW91cyBob3cgdGhpcyBjYW4gZmFpbCwgYnV0IHN0aWxsIHdvcnRoIGludmVzdGlnYXRpbmcgbGF0ZXIuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2UncmUgb250byBaZXJvIHBvaW50LlxuICAgICAgICAgICAgICAgIC8vIEFkZCByYW5kb20gcG9pbnQgaW5zaWRlIGN1cnJlbnQgd2luZG93IHRvIGYuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0MSA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQyID0gb2Zmc2V0ICsgTWF0aC5hYnMod2JpdHMpIC0gMTsgLy8gLTEgYmVjYXVzZSB3ZSBza2lwIHplcm9cbiAgICAgICAgICAgICAgICBjb25zdCBjb25kMSA9IHdpbmRvdyAlIDIgIT09IDA7XG4gICAgICAgICAgICAgICAgY29uc3QgY29uZDIgPSB3Yml0cyA8IDA7XG4gICAgICAgICAgICAgICAgaWYgKHdiaXRzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBtb3N0IGltcG9ydGFudCBwYXJ0IGZvciBjb25zdC10aW1lIGdldFB1YmxpY0tleVxuICAgICAgICAgICAgICAgICAgICBmID0gZi5hZGQoY29uc3RUaW1lTmVnYXRlKGNvbmQxLCBwcmVjb21wdXRlc1tvZmZzZXQxXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAuYWRkKGNvbnN0VGltZU5lZ2F0ZShjb25kMiwgcHJlY29tcHV0ZXNbb2Zmc2V0Ml0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBKSVQtY29tcGlsZXIgc2hvdWxkIG5vdCBlbGltaW5hdGUgZiBoZXJlLCBzaW5jZSBpdCB3aWxsIGxhdGVyIGJlIHVzZWQgaW4gbm9ybWFsaXplWigpXG4gICAgICAgICAgICAvLyBFdmVuIGlmIHRoZSB2YXJpYWJsZSBpcyBzdGlsbCB1bnVzZWQsIHRoZXJlIGFyZSBzb21lIGNoZWNrcyB3aGljaCB3aWxsXG4gICAgICAgICAgICAvLyB0aHJvdyBhbiBleGNlcHRpb24sIHNvIGNvbXBpbGVyIG5lZWRzIHRvIHByb3ZlIHRoZXkgd29uJ3QgaGFwcGVuLCB3aGljaCBpcyBoYXJkLlxuICAgICAgICAgICAgLy8gQXQgdGhpcyBwb2ludCB0aGVyZSBpcyBhIHdheSB0byBGIGJlIGluZmluaXR5LXBvaW50IGV2ZW4gaWYgcCBpcyBub3QsXG4gICAgICAgICAgICAvLyB3aGljaCBtYWtlcyBpdCBsZXNzIGNvbnN0LXRpbWU6IGFyb3VuZCAxIGJpZ2ludCBtdWx0aXBseS5cbiAgICAgICAgICAgIHJldHVybiB7IHAsIGYgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEltcGxlbWVudHMgZWMgdW5zYWZlIChub24gY29uc3QtdGltZSkgbXVsdGlwbGljYXRpb24gdXNpbmcgcHJlY29tcHV0ZWQgdGFibGVzIGFuZCB3LWFyeSBub24tYWRqYWNlbnQgZm9ybS5cbiAgICAgICAgICogQHBhcmFtIFcgd2luZG93IHNpemVcbiAgICAgICAgICogQHBhcmFtIHByZWNvbXB1dGVzIHByZWNvbXB1dGVkIHRhYmxlc1xuICAgICAgICAgKiBAcGFyYW0gbiBzY2FsYXIgKHdlIGRvbid0IGNoZWNrIGhlcmUsIGJ1dCBzaG91bGQgYmUgbGVzcyB0aGFuIGN1cnZlIG9yZGVyKVxuICAgICAgICAgKiBAcGFyYW0gYWNjIGFjY3VtdWxhdG9yIHBvaW50IHRvIGFkZCByZXN1bHQgb2YgbXVsdGlwbGljYXRpb25cbiAgICAgICAgICogQHJldHVybnMgcG9pbnRcbiAgICAgICAgICovXG4gICAgICAgIHdOQUZVbnNhZmUoVywgcHJlY29tcHV0ZXMsIG4sIGFjYyA9IGMuWkVSTykge1xuICAgICAgICAgICAgY29uc3QgeyB3aW5kb3dzLCB3aW5kb3dTaXplIH0gPSBjYWxjV09wdHMoVywgYml0cyk7XG4gICAgICAgICAgICBjb25zdCBtYXNrID0gQmlnSW50KDIgKiogVyAtIDEpOyAvLyBDcmVhdGUgbWFzayB3aXRoIFcgb25lczogMGIxMTExIGZvciBXPTQgZXRjLlxuICAgICAgICAgICAgY29uc3QgbWF4TnVtYmVyID0gMiAqKiBXO1xuICAgICAgICAgICAgY29uc3Qgc2hpZnRCeSA9IEJpZ0ludChXKTtcbiAgICAgICAgICAgIGZvciAobGV0IHdpbmRvdyA9IDA7IHdpbmRvdyA8IHdpbmRvd3M7IHdpbmRvdysrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gd2luZG93ICogd2luZG93U2l6ZTtcbiAgICAgICAgICAgICAgICBpZiAobiA9PT0gXzBuKVxuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gTm8gbmVlZCB0byBnbyBvdmVyIGVtcHR5IHNjYWxhclxuICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgVyBiaXRzLlxuICAgICAgICAgICAgICAgIGxldCB3Yml0cyA9IE51bWJlcihuICYgbWFzayk7XG4gICAgICAgICAgICAgICAgLy8gU2hpZnQgbnVtYmVyIGJ5IFcgYml0cy5cbiAgICAgICAgICAgICAgICBuID4+PSBzaGlmdEJ5O1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBiaXRzIGFyZSBiaWdnZXIgdGhhbiBtYXggc2l6ZSwgd2UnbGwgc3BsaXQgdGhvc2UuXG4gICAgICAgICAgICAgICAgLy8gKzIyNCA9PiAyNTYgLSAzMlxuICAgICAgICAgICAgICAgIGlmICh3Yml0cyA+IHdpbmRvd1NpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgd2JpdHMgLT0gbWF4TnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICBuICs9IF8xbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHdiaXRzID09PSAwKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBsZXQgY3VyciA9IHByZWNvbXB1dGVzW29mZnNldCArIE1hdGguYWJzKHdiaXRzKSAtIDFdOyAvLyAtMSBiZWNhdXNlIHdlIHNraXAgemVyb1xuICAgICAgICAgICAgICAgIGlmICh3Yml0cyA8IDApXG4gICAgICAgICAgICAgICAgICAgIGN1cnIgPSBjdXJyLm5lZ2F0ZSgpO1xuICAgICAgICAgICAgICAgIC8vIE5PVEU6IGJ5IHJlLXVzaW5nIGFjYywgd2UgY2FuIHNhdmUgYSBsb3Qgb2YgYWRkaXRpb25zIGluIGNhc2Ugb2YgTVNNXG4gICAgICAgICAgICAgICAgYWNjID0gYWNjLmFkZChjdXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFByZWNvbXB1dGVzKFcsIFAsIHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHByZWNvbXB1dGVzIG9uIGEgZmlyc3QgcnVuLCByZXVzZSB0aGVtIGFmdGVyXG4gICAgICAgICAgICBsZXQgY29tcCA9IHBvaW50UHJlY29tcHV0ZXMuZ2V0KFApO1xuICAgICAgICAgICAgaWYgKCFjb21wKSB7XG4gICAgICAgICAgICAgICAgY29tcCA9IHRoaXMucHJlY29tcHV0ZVdpbmRvdyhQLCBXKTtcbiAgICAgICAgICAgICAgICBpZiAoVyAhPT0gMSlcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRQcmVjb21wdXRlcy5zZXQoUCwgdHJhbnNmb3JtKGNvbXApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb21wO1xuICAgICAgICB9LFxuICAgICAgICB3TkFGQ2FjaGVkKFAsIG4sIHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgY29uc3QgVyA9IGdldFcoUCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53TkFGKFcsIHRoaXMuZ2V0UHJlY29tcHV0ZXMoVywgUCwgdHJhbnNmb3JtKSwgbik7XG4gICAgICAgIH0sXG4gICAgICAgIHdOQUZDYWNoZWRVbnNhZmUoUCwgbiwgdHJhbnNmb3JtLCBwcmV2KSB7XG4gICAgICAgICAgICBjb25zdCBXID0gZ2V0VyhQKTtcbiAgICAgICAgICAgIGlmIChXID09PSAxKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnVuc2FmZUxhZGRlcihQLCBuLCBwcmV2KTsgLy8gRm9yIFc9MSBsYWRkZXIgaXMgfngyIGZhc3RlclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMud05BRlVuc2FmZShXLCB0aGlzLmdldFByZWNvbXB1dGVzKFcsIFAsIHRyYW5zZm9ybSksIG4sIHByZXYpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBXZSBjYWxjdWxhdGUgcHJlY29tcHV0ZXMgZm9yIGVsbGlwdGljIGN1cnZlIHBvaW50IG11bHRpcGxpY2F0aW9uXG4gICAgICAgIC8vIHVzaW5nIHdpbmRvd2VkIG1ldGhvZC4gVGhpcyBzcGVjaWZpZXMgd2luZG93IHNpemUgYW5kXG4gICAgICAgIC8vIHN0b3JlcyBwcmVjb21wdXRlZCB2YWx1ZXMuIFVzdWFsbHkgb25seSBiYXNlIHBvaW50IHdvdWxkIGJlIHByZWNvbXB1dGVkLlxuICAgICAgICBzZXRXaW5kb3dTaXplKFAsIFcpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlVyhXLCBiaXRzKTtcbiAgICAgICAgICAgIHBvaW50V2luZG93U2l6ZXMuc2V0KFAsIFcpO1xuICAgICAgICAgICAgcG9pbnRQcmVjb21wdXRlcy5kZWxldGUoUCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogUGlwcGVuZ2VyIGFsZ29yaXRobSBmb3IgbXVsdGktc2NhbGFyIG11bHRpcGxpY2F0aW9uIChNU00sIFBhICsgUWIgKyBSYyArIC4uLikuXG4gKiAzMHggZmFzdGVyIHZzIG5haXZlIGFkZGl0aW9uIG9uIEw9NDA5NiwgMTB4IGZhc3RlciB3aXRoIHByZWNvbXB1dGVzLlxuICogRm9yIE49MjU0Yml0LCBMPTEsIGl0IGRvZXM6IDEwMjQgQUREICsgMjU0IERCTC4gRm9yIEw9NTogMTUzNiBBREQgKyAyNTQgREJMLlxuICogQWxnb3JpdGhtaWNhbGx5IGNvbnN0YW50LXRpbWUgKGZvciBzYW1lIEwpLCBldmVuIHdoZW4gMSBwb2ludCArIHNjYWxhciwgb3Igd2hlbiBzY2FsYXIgPSAwLlxuICogQHBhcmFtIGMgQ3VydmUgUG9pbnQgY29uc3RydWN0b3JcbiAqIEBwYXJhbSBmaWVsZE4gZmllbGQgb3ZlciBDVVJWRS5OIC0gaW1wb3J0YW50IHRoYXQgaXQncyBub3Qgb3ZlciBDVVJWRS5QXG4gKiBAcGFyYW0gcG9pbnRzIGFycmF5IG9mIEwgY3VydmUgcG9pbnRzXG4gKiBAcGFyYW0gc2NhbGFycyBhcnJheSBvZiBMIHNjYWxhcnMgKGFrYSBwcml2YXRlIGtleXMgLyBiaWdpbnRzKVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGlwcGVuZ2VyKGMsIGZpZWxkTiwgcG9pbnRzLCBzY2FsYXJzKSB7XG4gICAgLy8gSWYgd2Ugc3BsaXQgc2NhbGFycyBieSBzb21lIHdpbmRvdyAobGV0J3Mgc2F5IDggYml0cyksIGV2ZXJ5IGNodW5rIHdpbGwgb25seVxuICAgIC8vIHRha2UgMjU2IGJ1Y2tldHMgZXZlbiBpZiB0aGVyZSBhcmUgNDA5NiBzY2FsYXJzLCBhbHNvIHJlLXVzZXMgZG91YmxlLlxuICAgIC8vIFRPRE86XG4gICAgLy8gLSBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDI0Lzc1MC5wZGZcbiAgICAvLyAtIGh0dHBzOi8vdGNoZXMuaWFjci5vcmcvaW5kZXgucGhwL1RDSEVTL2FydGljbGUvdmlldy8xMDI4N1xuICAgIC8vIDAgaXMgYWNjZXB0ZWQgaW4gc2NhbGFyc1xuICAgIHZhbGlkYXRlTVNNUG9pbnRzKHBvaW50cywgYyk7XG4gICAgdmFsaWRhdGVNU01TY2FsYXJzKHNjYWxhcnMsIGZpZWxkTik7XG4gICAgaWYgKHBvaW50cy5sZW5ndGggIT09IHNjYWxhcnMubGVuZ3RoKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FycmF5cyBvZiBwb2ludHMgYW5kIHNjYWxhcnMgbXVzdCBoYXZlIGVxdWFsIGxlbmd0aCcpO1xuICAgIGNvbnN0IHplcm8gPSBjLlpFUk87XG4gICAgY29uc3Qgd2JpdHMgPSBiaXRMZW4oQmlnSW50KHBvaW50cy5sZW5ndGgpKTtcbiAgICBjb25zdCB3aW5kb3dTaXplID0gd2JpdHMgPiAxMiA/IHdiaXRzIC0gMyA6IHdiaXRzID4gNCA/IHdiaXRzIC0gMiA6IHdiaXRzID8gMiA6IDE7IC8vIGluIGJpdHNcbiAgICBjb25zdCBNQVNLID0gKDEgPDwgd2luZG93U2l6ZSkgLSAxO1xuICAgIGNvbnN0IGJ1Y2tldHMgPSBuZXcgQXJyYXkoTUFTSyArIDEpLmZpbGwoemVybyk7IC8vICsxIGZvciB6ZXJvIGFycmF5XG4gICAgY29uc3QgbGFzdEJpdHMgPSBNYXRoLmZsb29yKChmaWVsZE4uQklUUyAtIDEpIC8gd2luZG93U2l6ZSkgKiB3aW5kb3dTaXplO1xuICAgIGxldCBzdW0gPSB6ZXJvO1xuICAgIGZvciAobGV0IGkgPSBsYXN0Qml0czsgaSA+PSAwOyBpIC09IHdpbmRvd1NpemUpIHtcbiAgICAgICAgYnVja2V0cy5maWxsKHplcm8pO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNjYWxhcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNjYWxhciA9IHNjYWxhcnNbal07XG4gICAgICAgICAgICBjb25zdCB3Yml0cyA9IE51bWJlcigoc2NhbGFyID4+IEJpZ0ludChpKSkgJiBCaWdJbnQoTUFTSykpO1xuICAgICAgICAgICAgYnVja2V0c1t3Yml0c10gPSBidWNrZXRzW3diaXRzXS5hZGQocG9pbnRzW2pdKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzSSA9IHplcm87IC8vIG5vdCB1c2luZyB0aGlzIHdpbGwgZG8gc21hbGwgc3BlZWQtdXAsIGJ1dCB3aWxsIGxvc2UgY3RcbiAgICAgICAgLy8gU2tpcCBmaXJzdCBidWNrZXQsIGJlY2F1c2UgaXQgaXMgemVyb1xuICAgICAgICBmb3IgKGxldCBqID0gYnVja2V0cy5sZW5ndGggLSAxLCBzdW1JID0gemVybzsgaiA+IDA7IGotLSkge1xuICAgICAgICAgICAgc3VtSSA9IHN1bUkuYWRkKGJ1Y2tldHNbal0pO1xuICAgICAgICAgICAgcmVzSSA9IHJlc0kuYWRkKHN1bUkpO1xuICAgICAgICB9XG4gICAgICAgIHN1bSA9IHN1bS5hZGQocmVzSSk7XG4gICAgICAgIGlmIChpICE9PSAwKVxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB3aW5kb3dTaXplOyBqKyspXG4gICAgICAgICAgICAgICAgc3VtID0gc3VtLmRvdWJsZSgpO1xuICAgIH1cbiAgICByZXR1cm4gc3VtO1xufVxuLyoqXG4gKiBQcmVjb21wdXRlZCBtdWx0aS1zY2FsYXIgbXVsdGlwbGljYXRpb24gKE1TTSwgUGEgKyBRYiArIFJjICsgLi4uKS5cbiAqIEBwYXJhbSBjIEN1cnZlIFBvaW50IGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0gZmllbGROIGZpZWxkIG92ZXIgQ1VSVkUuTiAtIGltcG9ydGFudCB0aGF0IGl0J3Mgbm90IG92ZXIgQ1VSVkUuUFxuICogQHBhcmFtIHBvaW50cyBhcnJheSBvZiBMIGN1cnZlIHBvaW50c1xuICogQHJldHVybnMgZnVuY3Rpb24gd2hpY2ggbXVsdGlwbGllcyBwb2ludHMgd2l0aCBzY2FhcnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByZWNvbXB1dGVNU01VbnNhZmUoYywgZmllbGROLCBwb2ludHMsIHdpbmRvd1NpemUpIHtcbiAgICAvKipcbiAgICAgKiBQZXJmb3JtYW5jZSBBbmFseXNpcyBvZiBXaW5kb3ctYmFzZWQgUHJlY29tcHV0YXRpb25cbiAgICAgKlxuICAgICAqIEJhc2UgQ2FzZSAoMjU2LWJpdCBzY2FsYXIsIDgtYml0IHdpbmRvdyk6XG4gICAgICogLSBTdGFuZGFyZCBwcmVjb21wdXRhdGlvbiByZXF1aXJlczpcbiAgICAgKiAgIC0gMzEgYWRkaXRpb25zIHBlciBzY2FsYXIgw5cgMjU2IHNjYWxhcnMgPSA3LDkzNiBvcHNcbiAgICAgKiAgIC0gUGx1cyAyNTUgc3VtbWFyeSBhZGRpdGlvbnMgPSA4LDE5MSB0b3RhbCBvcHNcbiAgICAgKiAgIE5vdGU6IFN1bW1hcnkgYWRkaXRpb25zIGNhbiBiZSBvcHRpbWl6ZWQgdmlhIGFjY3VtdWxhdG9yXG4gICAgICpcbiAgICAgKiBDaHVua2VkIFByZWNvbXB1dGF0aW9uIEFuYWx5c2lzOlxuICAgICAqIC0gVXNpbmcgMzIgY2h1bmtzIHJlcXVpcmVzOlxuICAgICAqICAgLSAyNTUgYWRkaXRpb25zIHBlciBjaHVua1xuICAgICAqICAgLSAyNTYgZG91YmxpbmdzXG4gICAgICogICAtIFRvdGFsOiAoMjU1IMOXIDMyKSArIDI1NiA9IDgsNDE2IG9wc1xuICAgICAqXG4gICAgICogTWVtb3J5IFVzYWdlIENvbXBhcmlzb246XG4gICAgICogV2luZG93IFNpemUgfCBTdGFuZGFyZCBQb2ludHMgfCBDaHVua2VkIFBvaW50c1xuICAgICAqIC0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS1cbiAgICAgKiAgICAgNC1iaXQgICB8ICAgICA1MjAgICAgICAgICB8ICAgICAgMTVcbiAgICAgKiAgICAgOC1iaXQgICB8ICAgIDQsMjI0ICAgICAgICB8ICAgICAyNTVcbiAgICAgKiAgICAxMC1iaXQgICB8ICAgMTMsODI0ICAgICAgICB8ICAgMSwwMjNcbiAgICAgKiAgICAxNi1iaXQgICB8ICA1NTcsMDU2ICAgICAgICB8ICA2NSw1MzVcbiAgICAgKlxuICAgICAqIEtleSBBZHZhbnRhZ2VzOlxuICAgICAqIDEuIEVuYWJsZXMgbGFyZ2VyIHdpbmRvdyBzaXplcyBkdWUgdG8gcmVkdWNlZCBtZW1vcnkgb3ZlcmhlYWRcbiAgICAgKiAyLiBNb3JlIGVmZmljaWVudCBmb3Igc21hbGxlciBzY2FsYXIgY291bnRzOlxuICAgICAqICAgIC0gMTYgY2h1bmtzOiAoMTYgw5cgMjU1KSArIDI1NiA9IDQsMzM2IG9wc1xuICAgICAqICAgIC0gfjJ4IGZhc3RlciB0aGFuIHN0YW5kYXJkIDgsMTkxIG9wc1xuICAgICAqXG4gICAgICogTGltaXRhdGlvbnM6XG4gICAgICogLSBOb3Qgc3VpdGFibGUgZm9yIHBsYWluIHByZWNvbXB1dGVzIChyZXF1aXJlcyAyNTYgY29uc3RhbnQgZG91YmxpbmdzKVxuICAgICAqIC0gUGVyZm9ybWFuY2UgZGVncmFkZXMgd2l0aCBsYXJnZXIgc2NhbGFyIGNvdW50czpcbiAgICAgKiAgIC0gT3B0aW1hbCBmb3IgfjI1NiBzY2FsYXJzXG4gICAgICogICAtIExlc3MgZWZmaWNpZW50IGZvciA0MDk2KyBzY2FsYXJzIChQaXBwZW5nZXIgcHJlZmVycmVkKVxuICAgICAqL1xuICAgIHZhbGlkYXRlVyh3aW5kb3dTaXplLCBmaWVsZE4uQklUUyk7XG4gICAgdmFsaWRhdGVNU01Qb2ludHMocG9pbnRzLCBjKTtcbiAgICBjb25zdCB6ZXJvID0gYy5aRVJPO1xuICAgIGNvbnN0IHRhYmxlU2l6ZSA9IDIgKiogd2luZG93U2l6ZSAtIDE7IC8vIHRhYmxlIHNpemUgKHdpdGhvdXQgemVybylcbiAgICBjb25zdCBjaHVua3MgPSBNYXRoLmNlaWwoZmllbGROLkJJVFMgLyB3aW5kb3dTaXplKTsgLy8gY2h1bmtzIG9mIGl0ZW1cbiAgICBjb25zdCBNQVNLID0gQmlnSW50KCgxIDw8IHdpbmRvd1NpemUpIC0gMSk7XG4gICAgY29uc3QgdGFibGVzID0gcG9pbnRzLm1hcCgocCkgPT4ge1xuICAgICAgICBjb25zdCByZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGFjYyA9IHA7IGkgPCB0YWJsZVNpemU7IGkrKykge1xuICAgICAgICAgICAgcmVzLnB1c2goYWNjKTtcbiAgICAgICAgICAgIGFjYyA9IGFjYy5hZGQocCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9KTtcbiAgICByZXR1cm4gKHNjYWxhcnMpID0+IHtcbiAgICAgICAgdmFsaWRhdGVNU01TY2FsYXJzKHNjYWxhcnMsIGZpZWxkTik7XG4gICAgICAgIGlmIChzY2FsYXJzLmxlbmd0aCA+IHBvaW50cy5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FycmF5IG9mIHNjYWxhcnMgbXVzdCBiZSBzbWFsbGVyIHRoYW4gYXJyYXkgb2YgcG9pbnRzJyk7XG4gICAgICAgIGxldCByZXMgPSB6ZXJvO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNodW5rczsgaSsrKSB7XG4gICAgICAgICAgICAvLyBObyBuZWVkIHRvIGRvdWJsZSBpZiBhY2N1bXVsYXRvciBpcyBzdGlsbCB6ZXJvLlxuICAgICAgICAgICAgaWYgKHJlcyAhPT0gemVybylcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHdpbmRvd1NpemU7IGorKylcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gcmVzLmRvdWJsZSgpO1xuICAgICAgICAgICAgY29uc3Qgc2hpZnRCeSA9IEJpZ0ludChjaHVua3MgKiB3aW5kb3dTaXplIC0gKGkgKyAxKSAqIHdpbmRvd1NpemUpO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzY2FsYXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbiA9IHNjYWxhcnNbal07XG4gICAgICAgICAgICAgICAgY29uc3QgY3VyciA9IE51bWJlcigobiA+PiBzaGlmdEJ5KSAmIE1BU0spO1xuICAgICAgICAgICAgICAgIGlmICghY3VycilcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7IC8vIHNraXAgemVybyBzY2FsYXJzIGNodW5rc1xuICAgICAgICAgICAgICAgIHJlcyA9IHJlcy5hZGQodGFibGVzW2pdW2N1cnIgLSAxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlQmFzaWMoY3VydmUpIHtcbiAgICB2YWxpZGF0ZUZpZWxkKGN1cnZlLkZwKTtcbiAgICB2YWxpZGF0ZU9iamVjdChjdXJ2ZSwge1xuICAgICAgICBuOiAnYmlnaW50JyxcbiAgICAgICAgaDogJ2JpZ2ludCcsXG4gICAgICAgIEd4OiAnZmllbGQnLFxuICAgICAgICBHeTogJ2ZpZWxkJyxcbiAgICB9LCB7XG4gICAgICAgIG5CaXRMZW5ndGg6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgbkJ5dGVMZW5ndGg6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICB9KTtcbiAgICAvLyBTZXQgZGVmYXVsdHNcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIC4uLm5MZW5ndGgoY3VydmUubiwgY3VydmUubkJpdExlbmd0aCksXG4gICAgICAgIC4uLmN1cnZlLFxuICAgICAgICAuLi57IHA6IGN1cnZlLkZwLk9SREVSIH0sXG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jdXJ2ZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/curve.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/hash-to-curve.js":
/*!******************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/hash-to-curve.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createHasher: () => (/* binding */ createHasher),\n/* harmony export */   expand_message_xmd: () => (/* binding */ expand_message_xmd),\n/* harmony export */   expand_message_xof: () => (/* binding */ expand_message_xof),\n/* harmony export */   hash_to_field: () => (/* binding */ hash_to_field),\n/* harmony export */   isogenyMap: () => (/* binding */ isogenyMap)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modular.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n\n\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE;\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value, length) {\n    anum(value);\n    anum(length);\n    if (value < 0 || value >= 1 << (8 * length))\n        throw new Error('invalid I2OSP input: ' + value);\n    const res = Array.from({ length }).fill(0);\n    for (let i = length - 1; i >= 0; i--) {\n        res[i] = value & 0xff;\n        value >>>= 8;\n    }\n    return new Uint8Array(res);\n}\nfunction strxor(a, b) {\n    const arr = new Uint8Array(a.length);\n    for (let i = 0; i < a.length; i++) {\n        arr[i] = a[i] ^ b[i];\n    }\n    return arr;\n}\nfunction anum(item) {\n    if (!Number.isSafeInteger(item))\n        throw new Error('number expected');\n}\n/**\n * Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits.\n * [RFC 9380 5.3.1](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1).\n */\nfunction expand_message_xmd(msg, DST, lenInBytes, H) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(DST);\n    anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    if (DST.length > 255)\n        DST = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)('H2C-OVERSIZE-DST-'), DST));\n    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n    const ell = Math.ceil(lenInBytes / b_in_bytes);\n    if (lenInBytes > 65535 || ell > 255)\n        throw new Error('expand_message_xmd: invalid lenInBytes');\n    const DST_prime = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(DST, i2osp(DST.length, 1));\n    const Z_pad = i2osp(0, r_in_bytes);\n    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n    const b = new Array(ell);\n    const b_0 = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n    b[0] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(b_0, i2osp(1, 1), DST_prime));\n    for (let i = 1; i <= ell; i++) {\n        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];\n        b[i] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...args));\n    }\n    const pseudo_random_bytes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...b);\n    return pseudo_random_bytes.slice(0, lenInBytes);\n}\n/**\n * Produces a uniformly random byte string using an extendable-output function (XOF) H.\n * 1. The collision resistance of H MUST be at least k bits.\n * 2. H MUST be an XOF that has been proved indifferentiable from\n *    a random oracle under a reasonable cryptographic assumption.\n * [RFC 9380 5.3.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2).\n */\nfunction expand_message_xof(msg, DST, lenInBytes, k, H) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(DST);\n    anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n    if (DST.length > 255) {\n        const dkLen = Math.ceil((2 * k) / 8);\n        DST = H.create({ dkLen }).update((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)('H2C-OVERSIZE-DST-')).update(DST).digest();\n    }\n    if (lenInBytes > 65535 || DST.length > 255)\n        throw new Error('expand_message_xof: invalid lenInBytes');\n    return (H.create({ dkLen: lenInBytes })\n        .update(msg)\n        .update(i2osp(lenInBytes, 2))\n        // 2. DST_prime = DST || I2OSP(len(DST), 1)\n        .update(DST)\n        .update(i2osp(DST.length, 1))\n        .digest());\n}\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F.\n * [RFC 9380 5.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.2).\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */\nfunction hash_to_field(msg, count, options) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(options, {\n        DST: 'stringOrUint8Array',\n        p: 'bigint',\n        m: 'isSafeInteger',\n        k: 'isSafeInteger',\n        hash: 'hash',\n    });\n    const { p, k, m, hash, expand, DST: _DST } = options;\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    anum(count);\n    const DST = typeof _DST === 'string' ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)(_DST) : _DST;\n    const log2p = p.toString(2).length;\n    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n    const len_in_bytes = count * m * L;\n    let prb; // pseudo_random_bytes\n    if (expand === 'xmd') {\n        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n    }\n    else if (expand === 'xof') {\n        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n    }\n    else if (expand === '_internal_pass') {\n        // for internal tests only\n        prb = msg;\n    }\n    else {\n        throw new Error('expand must be \"xmd\" or \"xof\"');\n    }\n    const u = new Array(count);\n    for (let i = 0; i < count; i++) {\n        const e = new Array(m);\n        for (let j = 0; j < m; j++) {\n            const elm_offset = L * (j + i * m);\n            const tv = prb.subarray(elm_offset, elm_offset + L);\n            e[j] = (0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.mod)(os2ip(tv), p);\n        }\n        u[i] = e;\n    }\n    return u;\n}\nfunction isogenyMap(field, map) {\n    // Make same order as in spec\n    const COEFF = map.map((i) => Array.from(i).reverse());\n    return (x, y) => {\n        const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));\n        x = field.div(xNum, xDen); // xNum / xDen\n        y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)\n        return { x: x, y: y };\n    };\n}\n/** Creates hash-to-curve methods from EC Point and mapToCurve function. */\nfunction createHasher(Point, mapToCurve, def) {\n    if (typeof mapToCurve !== 'function')\n        throw new Error('mapToCurve() must be defined');\n    return {\n        // Encodes byte string to elliptic curve.\n        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        hashToCurve(msg, options) {\n            const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });\n            const u0 = Point.fromAffine(mapToCurve(u[0]));\n            const u1 = Point.fromAffine(mapToCurve(u[1]));\n            const P = u0.add(u1).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n        // Encodes byte string to elliptic curve.\n        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        encodeToCurve(msg, options) {\n            const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });\n            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n        // Same as encodeToCurve, but without hash\n        mapToCurve(scalars) {\n            if (!Array.isArray(scalars))\n                throw new Error('mapToCurve: expected array of bigints');\n            for (const i of scalars)\n                if (typeof i !== 'bigint')\n                    throw new Error('mapToCurve: expected array of bigints');\n            const P = Point.fromAffine(mapToCurve(scalars)).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n    };\n}\n//# sourceMappingURL=hash-to-curve.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBbUM7QUFDNEQ7QUFDL0Y7QUFDQSxjQUFjLHNEQUFlO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixRQUFRO0FBQ3JDLDZCQUE2QixRQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxJQUFJLGlEQUFNO0FBQ1YsSUFBSSxpREFBTTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzREFBVyxDQUFDLHNEQUFXO0FBQ3ZDLFlBQVksOENBQThDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzREFBVztBQUNqQztBQUNBLDRDQUE0QztBQUM1QztBQUNBLGtCQUFrQixzREFBVztBQUM3QixhQUFhLHNEQUFXO0FBQ3hCLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0EsaUJBQWlCLHNEQUFXO0FBQzVCO0FBQ0EsZ0NBQWdDLHNEQUFXO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsSUFBSSxpREFBTTtBQUNWLElBQUksaURBQU07QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE9BQU8sU0FBUyxzREFBVztBQUNwRDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw2RUFBNkU7QUFDakc7QUFDQTtBQUNPO0FBQ1AsSUFBSSx5REFBYztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFlBQVksbUNBQW1DO0FBQy9DLElBQUksaURBQU07QUFDVjtBQUNBLDJDQUEyQyxzREFBVztBQUN0RDtBQUNBLDBDQUEwQztBQUMxQztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0EsbUJBQW1CLGdEQUFHO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLGlEQUFpRDtBQUNqRCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsa0NBQWtDO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHdDQUF3QztBQUN0RjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9sZmcvR2l0L01hZHRyaXBzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IG1vZCB9IGZyb20gJy4vbW9kdWxhci5qcyc7XG5pbXBvcnQgeyBhYnl0ZXMsIGJ5dGVzVG9OdW1iZXJCRSwgY29uY2F0Qnl0ZXMsIHV0ZjhUb0J5dGVzLCB2YWxpZGF0ZU9iamVjdCB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gT2N0ZXQgU3RyZWFtIHRvIEludGVnZXIuIFwic3BlY1wiIGltcGxlbWVudGF0aW9uIG9mIG9zMmlwIGlzIDIuNXggc2xvd2VyIHZzIGJ5dGVzVG9OdW1iZXJCRS5cbmNvbnN0IG9zMmlwID0gYnl0ZXNUb051bWJlckJFO1xuLy8gSW50ZWdlciB0byBPY3RldCBTdHJlYW0gKG51bWJlclRvQnl0ZXNCRSlcbmZ1bmN0aW9uIGkyb3NwKHZhbHVlLCBsZW5ndGgpIHtcbiAgICBhbnVtKHZhbHVlKTtcbiAgICBhbnVtKGxlbmd0aCk7XG4gICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+PSAxIDw8ICg4ICogbGVuZ3RoKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIEkyT1NQIGlucHV0OiAnICsgdmFsdWUpO1xuICAgIGNvbnN0IHJlcyA9IEFycmF5LmZyb20oeyBsZW5ndGggfSkuZmlsbCgwKTtcbiAgICBmb3IgKGxldCBpID0gbGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgcmVzW2ldID0gdmFsdWUgJiAweGZmO1xuICAgICAgICB2YWx1ZSA+Pj49IDg7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShyZXMpO1xufVxuZnVuY3Rpb24gc3RyeG9yKGEsIGIpIHtcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheShhLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycltpXSA9IGFbaV0gXiBiW2ldO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufVxuZnVuY3Rpb24gYW51bShpdGVtKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihpdGVtKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdudW1iZXIgZXhwZWN0ZWQnKTtcbn1cbi8qKlxuICogUHJvZHVjZXMgYSB1bmlmb3JtbHkgcmFuZG9tIGJ5dGUgc3RyaW5nIHVzaW5nIGEgY3J5cHRvZ3JhcGhpYyBoYXNoIGZ1bmN0aW9uIEggdGhhdCBvdXRwdXRzIGIgYml0cy5cbiAqIFtSRkMgOTM4MCA1LjMuMV0oaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjMuMSkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHBhbmRfbWVzc2FnZV94bWQobXNnLCBEU1QsIGxlbkluQnl0ZXMsIEgpIHtcbiAgICBhYnl0ZXMobXNnKTtcbiAgICBhYnl0ZXMoRFNUKTtcbiAgICBhbnVtKGxlbkluQnl0ZXMpO1xuICAgIC8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4zLjNcbiAgICBpZiAoRFNULmxlbmd0aCA+IDI1NSlcbiAgICAgICAgRFNUID0gSChjb25jYXRCeXRlcyh1dGY4VG9CeXRlcygnSDJDLU9WRVJTSVpFLURTVC0nKSwgRFNUKSk7XG4gICAgY29uc3QgeyBvdXRwdXRMZW46IGJfaW5fYnl0ZXMsIGJsb2NrTGVuOiByX2luX2J5dGVzIH0gPSBIO1xuICAgIGNvbnN0IGVsbCA9IE1hdGguY2VpbChsZW5JbkJ5dGVzIC8gYl9pbl9ieXRlcyk7XG4gICAgaWYgKGxlbkluQnl0ZXMgPiA2NTUzNSB8fCBlbGwgPiAyNTUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwYW5kX21lc3NhZ2VfeG1kOiBpbnZhbGlkIGxlbkluQnl0ZXMnKTtcbiAgICBjb25zdCBEU1RfcHJpbWUgPSBjb25jYXRCeXRlcyhEU1QsIGkyb3NwKERTVC5sZW5ndGgsIDEpKTtcbiAgICBjb25zdCBaX3BhZCA9IGkyb3NwKDAsIHJfaW5fYnl0ZXMpO1xuICAgIGNvbnN0IGxfaV9iX3N0ciA9IGkyb3NwKGxlbkluQnl0ZXMsIDIpOyAvLyBsZW5faW5fYnl0ZXNfc3RyXG4gICAgY29uc3QgYiA9IG5ldyBBcnJheShlbGwpO1xuICAgIGNvbnN0IGJfMCA9IEgoY29uY2F0Qnl0ZXMoWl9wYWQsIG1zZywgbF9pX2Jfc3RyLCBpMm9zcCgwLCAxKSwgRFNUX3ByaW1lKSk7XG4gICAgYlswXSA9IEgoY29uY2F0Qnl0ZXMoYl8wLCBpMm9zcCgxLCAxKSwgRFNUX3ByaW1lKSk7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gZWxsOyBpKyspIHtcbiAgICAgICAgY29uc3QgYXJncyA9IFtzdHJ4b3IoYl8wLCBiW2kgLSAxXSksIGkyb3NwKGkgKyAxLCAxKSwgRFNUX3ByaW1lXTtcbiAgICAgICAgYltpXSA9IEgoY29uY2F0Qnl0ZXMoLi4uYXJncykpO1xuICAgIH1cbiAgICBjb25zdCBwc2V1ZG9fcmFuZG9tX2J5dGVzID0gY29uY2F0Qnl0ZXMoLi4uYik7XG4gICAgcmV0dXJuIHBzZXVkb19yYW5kb21fYnl0ZXMuc2xpY2UoMCwgbGVuSW5CeXRlcyk7XG59XG4vKipcbiAqIFByb2R1Y2VzIGEgdW5pZm9ybWx5IHJhbmRvbSBieXRlIHN0cmluZyB1c2luZyBhbiBleHRlbmRhYmxlLW91dHB1dCBmdW5jdGlvbiAoWE9GKSBILlxuICogMS4gVGhlIGNvbGxpc2lvbiByZXNpc3RhbmNlIG9mIEggTVVTVCBiZSBhdCBsZWFzdCBrIGJpdHMuXG4gKiAyLiBIIE1VU1QgYmUgYW4gWE9GIHRoYXQgaGFzIGJlZW4gcHJvdmVkIGluZGlmZmVyZW50aWFibGUgZnJvbVxuICogICAgYSByYW5kb20gb3JhY2xlIHVuZGVyIGEgcmVhc29uYWJsZSBjcnlwdG9ncmFwaGljIGFzc3VtcHRpb24uXG4gKiBbUkZDIDkzODAgNS4zLjJdKGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4zLjIpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXhwYW5kX21lc3NhZ2VfeG9mKG1zZywgRFNULCBsZW5JbkJ5dGVzLCBrLCBIKSB7XG4gICAgYWJ5dGVzKG1zZyk7XG4gICAgYWJ5dGVzKERTVCk7XG4gICAgYW51bShsZW5JbkJ5dGVzKTtcbiAgICAvLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMy4zXG4gICAgLy8gRFNUID0gSCgnSDJDLU9WRVJTSVpFLURTVC0nIHx8IGFfdmVyeV9sb25nX0RTVCwgTWF0aC5jZWlsKChsZW5JbkJ5dGVzICogaykgLyA4KSk7XG4gICAgaWYgKERTVC5sZW5ndGggPiAyNTUpIHtcbiAgICAgICAgY29uc3QgZGtMZW4gPSBNYXRoLmNlaWwoKDIgKiBrKSAvIDgpO1xuICAgICAgICBEU1QgPSBILmNyZWF0ZSh7IGRrTGVuIH0pLnVwZGF0ZSh1dGY4VG9CeXRlcygnSDJDLU9WRVJTSVpFLURTVC0nKSkudXBkYXRlKERTVCkuZGlnZXN0KCk7XG4gICAgfVxuICAgIGlmIChsZW5JbkJ5dGVzID4gNjU1MzUgfHwgRFNULmxlbmd0aCA+IDI1NSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBhbmRfbWVzc2FnZV94b2Y6IGludmFsaWQgbGVuSW5CeXRlcycpO1xuICAgIHJldHVybiAoSC5jcmVhdGUoeyBka0xlbjogbGVuSW5CeXRlcyB9KVxuICAgICAgICAudXBkYXRlKG1zZylcbiAgICAgICAgLnVwZGF0ZShpMm9zcChsZW5JbkJ5dGVzLCAyKSlcbiAgICAgICAgLy8gMi4gRFNUX3ByaW1lID0gRFNUIHx8IEkyT1NQKGxlbihEU1QpLCAxKVxuICAgICAgICAudXBkYXRlKERTVClcbiAgICAgICAgLnVwZGF0ZShpMm9zcChEU1QubGVuZ3RoLCAxKSlcbiAgICAgICAgLmRpZ2VzdCgpKTtcbn1cbi8qKlxuICogSGFzaGVzIGFyYml0cmFyeS1sZW5ndGggYnl0ZSBzdHJpbmdzIHRvIGEgbGlzdCBvZiBvbmUgb3IgbW9yZSBlbGVtZW50cyBvZiBhIGZpbml0ZSBmaWVsZCBGLlxuICogW1JGQyA5MzgwIDUuMl0oaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjIpLlxuICogQHBhcmFtIG1zZyBhIGJ5dGUgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIG1lc3NhZ2UgdG8gaGFzaFxuICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgZWxlbWVudHMgb2YgRiB0byBvdXRwdXRcbiAqIEBwYXJhbSBvcHRpb25zIGB7RFNUOiBzdHJpbmcsIHA6IGJpZ2ludCwgbTogbnVtYmVyLCBrOiBudW1iZXIsIGV4cGFuZDogJ3htZCcgfCAneG9mJywgaGFzaDogSH1gLCBzZWUgYWJvdmVcbiAqIEByZXR1cm5zIFt1XzAsIC4uLiwgdV8oY291bnQgLSAxKV0sIGEgbGlzdCBvZiBmaWVsZCBlbGVtZW50cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc2hfdG9fZmllbGQobXNnLCBjb3VudCwgb3B0aW9ucykge1xuICAgIHZhbGlkYXRlT2JqZWN0KG9wdGlvbnMsIHtcbiAgICAgICAgRFNUOiAnc3RyaW5nT3JVaW50OEFycmF5JyxcbiAgICAgICAgcDogJ2JpZ2ludCcsXG4gICAgICAgIG06ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgazogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBoYXNoOiAnaGFzaCcsXG4gICAgfSk7XG4gICAgY29uc3QgeyBwLCBrLCBtLCBoYXNoLCBleHBhbmQsIERTVDogX0RTVCB9ID0gb3B0aW9ucztcbiAgICBhYnl0ZXMobXNnKTtcbiAgICBhbnVtKGNvdW50KTtcbiAgICBjb25zdCBEU1QgPSB0eXBlb2YgX0RTVCA9PT0gJ3N0cmluZycgPyB1dGY4VG9CeXRlcyhfRFNUKSA6IF9EU1Q7XG4gICAgY29uc3QgbG9nMnAgPSBwLnRvU3RyaW5nKDIpLmxlbmd0aDtcbiAgICBjb25zdCBMID0gTWF0aC5jZWlsKChsb2cycCArIGspIC8gOCk7IC8vIHNlY3Rpb24gNS4xIG9mIGlldGYgZHJhZnQgbGluayBhYm92ZVxuICAgIGNvbnN0IGxlbl9pbl9ieXRlcyA9IGNvdW50ICogbSAqIEw7XG4gICAgbGV0IHByYjsgLy8gcHNldWRvX3JhbmRvbV9ieXRlc1xuICAgIGlmIChleHBhbmQgPT09ICd4bWQnKSB7XG4gICAgICAgIHByYiA9IGV4cGFuZF9tZXNzYWdlX3htZChtc2csIERTVCwgbGVuX2luX2J5dGVzLCBoYXNoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXhwYW5kID09PSAneG9mJykge1xuICAgICAgICBwcmIgPSBleHBhbmRfbWVzc2FnZV94b2YobXNnLCBEU1QsIGxlbl9pbl9ieXRlcywgaywgaGFzaCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV4cGFuZCA9PT0gJ19pbnRlcm5hbF9wYXNzJykge1xuICAgICAgICAvLyBmb3IgaW50ZXJuYWwgdGVzdHMgb25seVxuICAgICAgICBwcmIgPSBtc2c7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGFuZCBtdXN0IGJlIFwieG1kXCIgb3IgXCJ4b2ZcIicpO1xuICAgIH1cbiAgICBjb25zdCB1ID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgY29uc3QgZSA9IG5ldyBBcnJheShtKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGVsbV9vZmZzZXQgPSBMICogKGogKyBpICogbSk7XG4gICAgICAgICAgICBjb25zdCB0diA9IHByYi5zdWJhcnJheShlbG1fb2Zmc2V0LCBlbG1fb2Zmc2V0ICsgTCk7XG4gICAgICAgICAgICBlW2pdID0gbW9kKG9zMmlwKHR2KSwgcCk7XG4gICAgICAgIH1cbiAgICAgICAgdVtpXSA9IGU7XG4gICAgfVxuICAgIHJldHVybiB1O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzb2dlbnlNYXAoZmllbGQsIG1hcCkge1xuICAgIC8vIE1ha2Ugc2FtZSBvcmRlciBhcyBpbiBzcGVjXG4gICAgY29uc3QgQ09FRkYgPSBtYXAubWFwKChpKSA9PiBBcnJheS5mcm9tKGkpLnJldmVyc2UoKSk7XG4gICAgcmV0dXJuICh4LCB5KSA9PiB7XG4gICAgICAgIGNvbnN0IFt4TnVtLCB4RGVuLCB5TnVtLCB5RGVuXSA9IENPRUZGLm1hcCgodmFsKSA9PiB2YWwucmVkdWNlKChhY2MsIGkpID0+IGZpZWxkLmFkZChmaWVsZC5tdWwoYWNjLCB4KSwgaSkpKTtcbiAgICAgICAgeCA9IGZpZWxkLmRpdih4TnVtLCB4RGVuKTsgLy8geE51bSAvIHhEZW5cbiAgICAgICAgeSA9IGZpZWxkLm11bCh5LCBmaWVsZC5kaXYoeU51bSwgeURlbikpOyAvLyB5ICogKHlOdW0gLyB5RGV2KVxuICAgICAgICByZXR1cm4geyB4OiB4LCB5OiB5IH07XG4gICAgfTtcbn1cbi8qKiBDcmVhdGVzIGhhc2gtdG8tY3VydmUgbWV0aG9kcyBmcm9tIEVDIFBvaW50IGFuZCBtYXBUb0N1cnZlIGZ1bmN0aW9uLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUhhc2hlcihQb2ludCwgbWFwVG9DdXJ2ZSwgZGVmKSB7XG4gICAgaWYgKHR5cGVvZiBtYXBUb0N1cnZlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcFRvQ3VydmUoKSBtdXN0IGJlIGRlZmluZWQnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvLyBFbmNvZGVzIGJ5dGUgc3RyaW5nIHRvIGVsbGlwdGljIGN1cnZlLlxuICAgICAgICAvLyBoYXNoX3RvX2N1cnZlIGZyb20gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi0zXG4gICAgICAgIGhhc2hUb0N1cnZlKG1zZywgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgdSA9IGhhc2hfdG9fZmllbGQobXNnLCAyLCB7IC4uLmRlZiwgRFNUOiBkZWYuRFNULCAuLi5vcHRpb25zIH0pO1xuICAgICAgICAgICAgY29uc3QgdTAgPSBQb2ludC5mcm9tQWZmaW5lKG1hcFRvQ3VydmUodVswXSkpO1xuICAgICAgICAgICAgY29uc3QgdTEgPSBQb2ludC5mcm9tQWZmaW5lKG1hcFRvQ3VydmUodVsxXSkpO1xuICAgICAgICAgICAgY29uc3QgUCA9IHUwLmFkZCh1MSkuY2xlYXJDb2ZhY3RvcigpO1xuICAgICAgICAgICAgUC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFA7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEVuY29kZXMgYnl0ZSBzdHJpbmcgdG8gZWxsaXB0aWMgY3VydmUuXG4gICAgICAgIC8vIGVuY29kZV90b19jdXJ2ZSBmcm9tIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tM1xuICAgICAgICBlbmNvZGVUb0N1cnZlKG1zZywgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgdSA9IGhhc2hfdG9fZmllbGQobXNnLCAxLCB7IC4uLmRlZiwgRFNUOiBkZWYuZW5jb2RlRFNULCAuLi5vcHRpb25zIH0pO1xuICAgICAgICAgICAgY29uc3QgUCA9IFBvaW50LmZyb21BZmZpbmUobWFwVG9DdXJ2ZSh1WzBdKSkuY2xlYXJDb2ZhY3RvcigpO1xuICAgICAgICAgICAgUC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFA7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFNhbWUgYXMgZW5jb2RlVG9DdXJ2ZSwgYnV0IHdpdGhvdXQgaGFzaFxuICAgICAgICBtYXBUb0N1cnZlKHNjYWxhcnMpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzY2FsYXJzKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcFRvQ3VydmU6IGV4cGVjdGVkIGFycmF5IG9mIGJpZ2ludHMnKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaSBvZiBzY2FsYXJzKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaSAhPT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWFwVG9DdXJ2ZTogZXhwZWN0ZWQgYXJyYXkgb2YgYmlnaW50cycpO1xuICAgICAgICAgICAgY29uc3QgUCA9IFBvaW50LmZyb21BZmZpbmUobWFwVG9DdXJ2ZShzY2FsYXJzKSkuY2xlYXJDb2ZhY3RvcigpO1xuICAgICAgICAgICAgUC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFA7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhc2gtdG8tY3VydmUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/hash-to-curve.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/modular.js":
/*!************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/modular.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Field: () => (/* binding */ Field),\n/* harmony export */   FpDiv: () => (/* binding */ FpDiv),\n/* harmony export */   FpInvertBatch: () => (/* binding */ FpInvertBatch),\n/* harmony export */   FpIsSquare: () => (/* binding */ FpIsSquare),\n/* harmony export */   FpLegendre: () => (/* binding */ FpLegendre),\n/* harmony export */   FpPow: () => (/* binding */ FpPow),\n/* harmony export */   FpSqrt: () => (/* binding */ FpSqrt),\n/* harmony export */   FpSqrtEven: () => (/* binding */ FpSqrtEven),\n/* harmony export */   FpSqrtOdd: () => (/* binding */ FpSqrtOdd),\n/* harmony export */   getFieldBytesLength: () => (/* binding */ getFieldBytesLength),\n/* harmony export */   getMinHashLength: () => (/* binding */ getMinHashLength),\n/* harmony export */   hashToPrivateScalar: () => (/* binding */ hashToPrivateScalar),\n/* harmony export */   invert: () => (/* binding */ invert),\n/* harmony export */   isNegativeLE: () => (/* binding */ isNegativeLE),\n/* harmony export */   mapHashToField: () => (/* binding */ mapHashToField),\n/* harmony export */   mod: () => (/* binding */ mod),\n/* harmony export */   nLength: () => (/* binding */ nLength),\n/* harmony export */   pow: () => (/* binding */ pow),\n/* harmony export */   pow2: () => (/* binding */ pow2),\n/* harmony export */   tonelliShanks: () => (/* binding */ tonelliShanks),\n/* harmony export */   validateField: () => (/* binding */ validateField)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/**\n * Utils for modular division and finite fields.\n * A finite field over 11 is integer number operations `mod 11`.\n * There is no division: it is replaced by modular multiplicative inverse.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = /* @__PURE__ */ BigInt(2), _3n = /* @__PURE__ */ BigInt(3);\n// prettier-ignore\nconst _4n = /* @__PURE__ */ BigInt(4), _5n = /* @__PURE__ */ BigInt(5), _8n = /* @__PURE__ */ BigInt(8);\n// prettier-ignore\nconst _9n = /* @__PURE__ */ BigInt(9), _16n = /* @__PURE__ */ BigInt(16);\n// Calculates a modulo b\nfunction mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @todo use field version && remove\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\nfunction pow(num, power, modulo) {\n    if (power < _0n)\n        throw new Error('invalid exponent, negatives unsupported');\n    if (modulo <= _0n)\n        throw new Error('invalid modulus');\n    if (modulo === _1n)\n        return _0n;\n    let res = _1n;\n    while (power > _0n) {\n        if (power & _1n)\n            res = (res * num) % modulo;\n        num = (num * num) % modulo;\n        power >>= _1n;\n    }\n    return res;\n}\n/** Does `x^(2^power)` mod p. `pow2(30, 4)` == `30^(2^4)` */\nfunction pow2(x, power, modulo) {\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n/**\n * Inverses number over modulo.\n * Implemented using [Euclidean GCD](https://brilliant.org/wiki/extended-euclidean-algorithm/).\n */\nfunction invert(number, modulo) {\n    if (number === _0n)\n        throw new Error('invert: expected non-zero number');\n    if (modulo <= _0n)\n        throw new Error('invert: expected positive modulus, got ' + modulo);\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * Will start an infinite loop if field order P is not prime.\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nfunction tonelliShanks(P) {\n    // Legendre constant: used to calculate Legendre symbol (a | p),\n    // which denotes the value of a^((p-1)/2) (mod p).\n    // (a | p) ‚â° 1    if a is a square (mod p)\n    // (a | p) ‚â° -1   if a is not a square (mod p)\n    // (a | p) ‚â° 0    if a ‚â° 0 (mod p)\n    const legendreC = (P - _1n) / _2n;\n    let Q, S, Z;\n    // Step 1: By factoring out powers of 2 from p - 1,\n    // find q and s such that p - 1 = q*(2^s) with q odd\n    for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)\n        ;\n    // Step 2: Select a non-square z such that (z | p) ‚â° -1 and set c ‚â° zq\n    for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++) {\n        // Crash instead of infinity loop, we cannot reasonable count until P.\n        if (Z > 1000)\n            throw new Error('Cannot find square root: likely non-prime P');\n    }\n    // Fast-path\n    if (S === 1) {\n        const p1div4 = (P + _1n) / _4n;\n        return function tonelliFast(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Slow-path\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        // Step 0: Check that n is indeed a square: (n | p) should not be ‚â° -1\n        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))\n            throw new Error('Cannot find square root');\n        let r = S;\n        // TODO: will fail at Fp2/etc\n        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n        let x = Fp.pow(n, Q1div2); // first guess at the square root\n        let b = Fp.pow(n, Q); // first guess at the fudge factor\n        while (!Fp.eql(b, Fp.ONE)) {\n            if (Fp.eql(b, Fp.ZERO))\n                return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n            // Find m such b^(2^m)==1\n            let m = 1;\n            for (let t2 = Fp.sqr(b); m < r; m++) {\n                if (Fp.eql(t2, Fp.ONE))\n                    break;\n                t2 = Fp.sqr(t2); // t2 *= t2\n            }\n            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n            g = Fp.sqr(ge); // g = ge * ge\n            x = Fp.mul(x, ge); // x *= ge\n            b = Fp.mul(b, g); // b *= g\n            r = m;\n        }\n        return x;\n    };\n}\n/**\n * Square root for a finite field. It will try to check if optimizations are applicable and fall back to 4:\n *\n * 1. P ‚â° 3 (mod 4)\n * 2. P ‚â° 5 (mod 8)\n * 3. P ‚â° 9 (mod 16)\n * 4. Tonelli-Shanks algorithm\n *\n * Different algorithms can give different roots, it is up to user to decide which one they want.\n * For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n */\nfunction FpSqrt(P) {\n    // P ‚â° 3 (mod 4)\n    // ‚àön = n^((P+1)/4)\n    if (P % _4n === _3n) {\n        // Not all roots possible!\n        // const ORDER =\n        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n        // const NUM = 72057594037927816n;\n        const p1div4 = (P + _1n) / _4n;\n        return function sqrt3mod4(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            // Throw if root**2 != n\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Atkin algorithm for q ‚â° 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n    if (P % _8n === _5n) {\n        const c1 = (P - _5n) / _8n;\n        return function sqrt5mod8(Fp, n) {\n            const n2 = Fp.mul(n, _2n);\n            const v = Fp.pow(n2, c1);\n            const nv = Fp.mul(n, v);\n            const i = Fp.mul(Fp.mul(nv, _2n), v);\n            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // P ‚â° 9 (mod 16)\n    if (P % _16n === _9n) {\n        // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n        // Means we cannot use sqrt for constants at all!\n        //\n        // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n        // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n        // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n        // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n        // sqrt = (x) => {\n        //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n        //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n        //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n        //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n        //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n        //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n        //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n        //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n        //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n        //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n        // }\n    }\n    // Other cases: Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nconst isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n    'eql', 'add', 'sub', 'mul', 'pow', 'div',\n    'addN', 'subN', 'mulN', 'sqrN'\n];\nfunction validateField(field) {\n    const initial = {\n        ORDER: 'bigint',\n        MASK: 'bigint',\n        BYTES: 'isSafeInteger',\n        BITS: 'isSafeInteger',\n    };\n    const opts = FIELD_FIELDS.reduce((map, val) => {\n        map[val] = 'function';\n        return map;\n    }, initial);\n    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(field, opts);\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nfunction FpPow(f, num, power) {\n    // Should have same speed as pow for bigints\n    // TODO: benchmark!\n    if (power < _0n)\n        throw new Error('invalid exponent, negatives unsupported');\n    if (power === _0n)\n        return f.ONE;\n    if (power === _1n)\n        return num;\n    let p = f.ONE;\n    let d = num;\n    while (power > _0n) {\n        if (power & _1n)\n            p = f.mul(p, d);\n        d = f.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * `inv(0)` will return `undefined` here: make sure to throw an error.\n */\nfunction FpInvertBatch(f, nums) {\n    const tmp = new Array(nums.length);\n    // Walk from first to last, multiply them by each other MOD p\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = acc;\n        return f.mul(acc, num);\n    }, f.ONE);\n    // Invert last element\n    const inverted = f.inv(lastMultiplied);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = f.mul(acc, tmp[i]);\n        return f.mul(acc, num);\n    }, inverted);\n    return tmp;\n}\nfunction FpDiv(f, lhs, rhs) {\n    return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\n/**\n * Legendre symbol.\n * * (a | p) ‚â° 1    if a is a square (mod p), quadratic residue\n * * (a | p) ‚â° -1   if a is not a square (mod p), quadratic non residue\n * * (a | p) ‚â° 0    if a ‚â° 0 (mod p)\n */\nfunction FpLegendre(order) {\n    const legendreConst = (order - _1n) / _2n; // Integer arithmetic\n    return (f, x) => f.pow(x, legendreConst);\n}\n// This function returns True whenever the value x is a square in the field F.\nfunction FpIsSquare(f) {\n    const legendre = FpLegendre(f.ORDER);\n    return (x) => {\n        const p = legendre(f, x);\n        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n    };\n}\n// CURVE.n lengths\nfunction nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return { nBitLength: _nBitLength, nByteLength };\n}\n/**\n * Initializes a finite field over prime.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * Fragile: always run a benchmark on a change.\n * Security note: operations don't check 'isValid' for all elements for performance reasons,\n * it is caller responsibility to check this.\n * This is low-level code, please make sure you know what you're doing.\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nfunction Field(ORDER, bitLen, isLE = false, redef = {}) {\n    if (ORDER <= _0n)\n        throw new Error('invalid field: expected ORDER > 0, got ' + ORDER);\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n    if (BYTES > 2048)\n        throw new Error('invalid field: expected ORDER of <= 2048 bytes');\n    let sqrtP; // cached sqrtP\n    const f = Object.freeze({\n        ORDER,\n        isLE,\n        BITS,\n        BYTES,\n        MASK: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        create: (num) => mod(num, ORDER),\n        isValid: (num) => {\n            if (typeof num !== 'bigint')\n                throw new Error('invalid field element: expected bigint, got ' + typeof num);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num) => num === _0n,\n        isOdd: (num) => (num & _1n) === _1n,\n        neg: (num) => mod(-num, ORDER),\n        eql: (lhs, rhs) => lhs === rhs,\n        sqr: (num) => mod(num * num, ORDER),\n        add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n        pow: (num, power) => FpPow(f, num, power),\n        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num) => num * num,\n        addN: (lhs, rhs) => lhs + rhs,\n        subN: (lhs, rhs) => lhs - rhs,\n        mulN: (lhs, rhs) => lhs * rhs,\n        inv: (num) => invert(num, ORDER),\n        sqrt: redef.sqrt ||\n            ((n) => {\n                if (!sqrtP)\n                    sqrtP = FpSqrt(ORDER);\n                return sqrtP(f, n);\n            }),\n        invertBatch: (lst) => FpInvertBatch(f, lst),\n        // TODO: do we really need constant cmov?\n        // We don't have const-time bigints anyway, so probably will be not very useful\n        cmov: (a, b, c) => (c ? b : a),\n        toBytes: (num) => (isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(num, BYTES) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(num, BYTES)),\n        fromBytes: (bytes) => {\n            if (bytes.length !== BYTES)\n                throw new Error('Field.fromBytes: expected ' + BYTES + ' bytes, got ' + bytes.length);\n            return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(bytes) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(bytes);\n        },\n    });\n    return Object.freeze(f);\n}\nfunction FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nfunction FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use `mapKeyToField` instead\n */\nfunction hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('privateHash', hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n        throw new Error('hashToPrivateScalar: expected ' + minLen + '-1024 bytes of input, got ' + hashLen);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(hash) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nfunction getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== 'bigint')\n        throw new Error('field order must be bigint');\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nfunction getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nfunction mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024)\n        throw new Error('expected ' + minLen + '-1024 bytes of input, got ' + len);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(key) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(reduced, fieldLen) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(reduced, fieldLen);\n}\n//# sourceMappingURL=modular.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9tb2R1bGFyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUN1STtBQUN2STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsaUJBQWlCO0FBQzlDO0FBQ0E7QUFDQSxrQkFBa0IsMkNBQTJDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDLG1DQUFtQztBQUNuQyw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBLGlDQUFpQztB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TztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMERBQWUsUUFBUSwwREFBZTtBQUM3RDtBQUNBO0FBQ0Esa0JBQWtCLDBEQUFlLHNCQUFzQiwwREFBZTtBQUN0RTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9sZmcvR2l0L01hZHRyaXBzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9tb2R1bGFyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVXRpbHMgZm9yIG1vZHVsYXIgZGl2aXNpb24gYW5kIGZpbml0ZSBmaWVsZHMuXG4gKiBBIGZpbml0ZSBmaWVsZCBvdmVyIDExIGlzIGludGVnZXIgbnVtYmVyIG9wZXJhdGlvbnMgYG1vZCAxMWAuXG4gKiBUaGVyZSBpcyBubyBkaXZpc2lvbjogaXQgaXMgcmVwbGFjZWQgYnkgbW9kdWxhciBtdWx0aXBsaWNhdGl2ZSBpbnZlcnNlLlxuICogQG1vZHVsZVxuICovXG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5pbXBvcnQgeyBiaXRNYXNrLCBieXRlc1RvTnVtYmVyQkUsIGJ5dGVzVG9OdW1iZXJMRSwgZW5zdXJlQnl0ZXMsIG51bWJlclRvQnl0ZXNCRSwgbnVtYmVyVG9CeXRlc0xFLCB2YWxpZGF0ZU9iamVjdCwgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzBuID0gQmlnSW50KDApLCBfMW4gPSBCaWdJbnQoMSksIF8ybiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMiksIF8zbiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMyk7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF80biA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoNCksIF81biA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoNSksIF84biA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoOCk7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF85biA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoOSksIF8xNm4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDE2KTtcbi8vIENhbGN1bGF0ZXMgYSBtb2R1bG8gYlxuZXhwb3J0IGZ1bmN0aW9uIG1vZChhLCBiKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYSAlIGI7XG4gICAgcmV0dXJuIHJlc3VsdCA+PSBfMG4gPyByZXN1bHQgOiBiICsgcmVzdWx0O1xufVxuLyoqXG4gKiBFZmZpY2llbnRseSByYWlzZSBudW0gdG8gcG93ZXIgYW5kIGRvIG1vZHVsYXIgZGl2aXNpb24uXG4gKiBVbnNhZmUgaW4gc29tZSBjb250ZXh0czogdXNlcyBsYWRkZXIsIHNvIGNhbiBleHBvc2UgYmlnaW50IGJpdHMuXG4gKiBAdG9kbyB1c2UgZmllbGQgdmVyc2lvbiAmJiByZW1vdmVcbiAqIEBleGFtcGxlXG4gKiBwb3coMm4sIDZuLCAxMW4pIC8vIDY0biAlIDExbiA9PSA5blxuICovXG5leHBvcnQgZnVuY3Rpb24gcG93KG51bSwgcG93ZXIsIG1vZHVsbykge1xuICAgIGlmIChwb3dlciA8IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGV4cG9uZW50LCBuZWdhdGl2ZXMgdW5zdXBwb3J0ZWQnKTtcbiAgICBpZiAobW9kdWxvIDw9IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIG1vZHVsdXMnKTtcbiAgICBpZiAobW9kdWxvID09PSBfMW4pXG4gICAgICAgIHJldHVybiBfMG47XG4gICAgbGV0IHJlcyA9IF8xbjtcbiAgICB3aGlsZSAocG93ZXIgPiBfMG4pIHtcbiAgICAgICAgaWYgKHBvd2VyICYgXzFuKVxuICAgICAgICAgICAgcmVzID0gKHJlcyAqIG51bSkgJSBtb2R1bG87XG4gICAgICAgIG51bSA9IChudW0gKiBudW0pICUgbW9kdWxvO1xuICAgICAgICBwb3dlciA+Pj0gXzFuO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLyoqIERvZXMgYHheKDJecG93ZXIpYCBtb2QgcC4gYHBvdzIoMzAsIDQpYCA9PSBgMzBeKDJeNClgICovXG5leHBvcnQgZnVuY3Rpb24gcG93Mih4LCBwb3dlciwgbW9kdWxvKSB7XG4gICAgbGV0IHJlcyA9IHg7XG4gICAgd2hpbGUgKHBvd2VyLS0gPiBfMG4pIHtcbiAgICAgICAgcmVzICo9IHJlcztcbiAgICAgICAgcmVzICU9IG1vZHVsbztcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbi8qKlxuICogSW52ZXJzZXMgbnVtYmVyIG92ZXIgbW9kdWxvLlxuICogSW1wbGVtZW50ZWQgdXNpbmcgW0V1Y2xpZGVhbiBHQ0RdKGh0dHBzOi8vYnJpbGxpYW50Lm9yZy93aWtpL2V4dGVuZGVkLWV1Y2xpZGVhbi1hbGdvcml0aG0vKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludmVydChudW1iZXIsIG1vZHVsbykge1xuICAgIGlmIChudW1iZXIgPT09IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZlcnQ6IGV4cGVjdGVkIG5vbi16ZXJvIG51bWJlcicpO1xuICAgIGlmIChtb2R1bG8gPD0gXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmVydDogZXhwZWN0ZWQgcG9zaXRpdmUgbW9kdWx1cywgZ290ICcgKyBtb2R1bG8pO1xuICAgIC8vIEZlcm1hdCdzIGxpdHRsZSB0aGVvcmVtIFwiQ1QtbGlrZVwiIHZlcnNpb24gaW52KG4pID0gbl4obS0yKSBtb2QgbSBpcyAzMHggc2xvd2VyLlxuICAgIGxldCBhID0gbW9kKG51bWJlciwgbW9kdWxvKTtcbiAgICBsZXQgYiA9IG1vZHVsbztcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBsZXQgeCA9IF8wbiwgeSA9IF8xbiwgdSA9IF8xbiwgdiA9IF8wbjtcbiAgICB3aGlsZSAoYSAhPT0gXzBuKSB7XG4gICAgICAgIC8vIEpJVCBhcHBsaWVzIG9wdGltaXphdGlvbiBpZiB0aG9zZSB0d28gbGluZXMgZm9sbG93IGVhY2ggb3RoZXJcbiAgICAgICAgY29uc3QgcSA9IGIgLyBhO1xuICAgICAgICBjb25zdCByID0gYiAlIGE7XG4gICAgICAgIGNvbnN0IG0gPSB4IC0gdSAqIHE7XG4gICAgICAgIGNvbnN0IG4gPSB5IC0gdiAqIHE7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBiID0gYSwgYSA9IHIsIHggPSB1LCB5ID0gdiwgdSA9IG0sIHYgPSBuO1xuICAgIH1cbiAgICBjb25zdCBnY2QgPSBiO1xuICAgIGlmIChnY2QgIT09IF8xbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZlcnQ6IGRvZXMgbm90IGV4aXN0Jyk7XG4gICAgcmV0dXJuIG1vZCh4LCBtb2R1bG8pO1xufVxuLyoqXG4gKiBUb25lbGxpLVNoYW5rcyBzcXVhcmUgcm9vdCBzZWFyY2ggYWxnb3JpdGhtLlxuICogMS4gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxMi82ODUucGRmIChwYWdlIDEyKVxuICogMi4gU3F1YXJlIFJvb3RzIGZyb20gMTsgMjQsIDUxLCAxMCB0byBEYW4gU2hhbmtzXG4gKiBXaWxsIHN0YXJ0IGFuIGluZmluaXRlIGxvb3AgaWYgZmllbGQgb3JkZXIgUCBpcyBub3QgcHJpbWUuXG4gKiBAcGFyYW0gUCBmaWVsZCBvcmRlclxuICogQHJldHVybnMgZnVuY3Rpb24gdGhhdCB0YWtlcyBmaWVsZCBGcCAoY3JlYXRlZCBmcm9tIFApIGFuZCBudW1iZXIgblxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9uZWxsaVNoYW5rcyhQKSB7XG4gICAgLy8gTGVnZW5kcmUgY29uc3RhbnQ6IHVzZWQgdG8gY2FsY3VsYXRlIExlZ2VuZHJlIHN5bWJvbCAoYSB8IHApLFxuICAgIC8vIHdoaWNoIGRlbm90ZXMgdGhlIHZhbHVlIG9mIGFeKChwLTEpLzIpIChtb2QgcCkuXG4gICAgLy8gKGEgfCBwKSDiiaEgMSAgICBpZiBhIGlzIGEgc3F1YXJlIChtb2QgcClcbiAgICAvLyAoYSB8IHApIOKJoSAtMSAgIGlmIGEgaXMgbm90IGEgc3F1YXJlIChtb2QgcClcbiAgICAvLyAoYSB8IHApIOKJoSAwICAgIGlmIGEg4omhIDAgKG1vZCBwKVxuICAgIGNvbnN0IGxlZ2VuZHJlQyA9IChQIC0gXzFuKSAvIF8ybjtcbiAgICBsZXQgUSwgUywgWjtcbiAgICAvLyBTdGVwIDE6IEJ5IGZhY3RvcmluZyBvdXQgcG93ZXJzIG9mIDIgZnJvbSBwIC0gMSxcbiAgICAvLyBmaW5kIHEgYW5kIHMgc3VjaCB0aGF0IHAgLSAxID0gcSooMl5zKSB3aXRoIHEgb2RkXG4gICAgZm9yIChRID0gUCAtIF8xbiwgUyA9IDA7IFEgJSBfMm4gPT09IF8wbjsgUSAvPSBfMm4sIFMrKylcbiAgICAgICAgO1xuICAgIC8vIFN0ZXAgMjogU2VsZWN0IGEgbm9uLXNxdWFyZSB6IHN1Y2ggdGhhdCAoeiB8IHApIOKJoSAtMSBhbmQgc2V0IGMg4omhIHpxXG4gICAgZm9yIChaID0gXzJuOyBaIDwgUCAmJiBwb3coWiwgbGVnZW5kcmVDLCBQKSAhPT0gUCAtIF8xbjsgWisrKSB7XG4gICAgICAgIC8vIENyYXNoIGluc3RlYWQgb2YgaW5maW5pdHkgbG9vcCwgd2UgY2Fubm90IHJlYXNvbmFibGUgY291bnQgdW50aWwgUC5cbiAgICAgICAgaWYgKFogPiAxMDAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdDogbGlrZWx5IG5vbi1wcmltZSBQJyk7XG4gICAgfVxuICAgIC8vIEZhc3QtcGF0aFxuICAgIGlmIChTID09PSAxKSB7XG4gICAgICAgIGNvbnN0IHAxZGl2NCA9IChQICsgXzFuKSAvIF80bjtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHRvbmVsbGlGYXN0KEZwLCBuKSB7XG4gICAgICAgICAgICBjb25zdCByb290ID0gRnAucG93KG4sIHAxZGl2NCk7XG4gICAgICAgICAgICBpZiAoIUZwLmVxbChGcC5zcXIocm9vdCksIG4pKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICAgICAgICAgIHJldHVybiByb290O1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBTbG93LXBhdGhcbiAgICBjb25zdCBRMWRpdjIgPSAoUSArIF8xbikgLyBfMm47XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHRvbmVsbGlTbG93KEZwLCBuKSB7XG4gICAgICAgIC8vIFN0ZXAgMDogQ2hlY2sgdGhhdCBuIGlzIGluZGVlZCBhIHNxdWFyZTogKG4gfCBwKSBzaG91bGQgbm90IGJlIOKJoSAtMVxuICAgICAgICBpZiAoRnAucG93KG4sIGxlZ2VuZHJlQykgPT09IEZwLm5lZyhGcC5PTkUpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICBsZXQgciA9IFM7XG4gICAgICAgIC8vIFRPRE86IHdpbGwgZmFpbCBhdCBGcDIvZXRjXG4gICAgICAgIGxldCBnID0gRnAucG93KEZwLm11bChGcC5PTkUsIFopLCBRKTsgLy8gd2lsbCB1cGRhdGUgYm90aCB4IGFuZCBiXG4gICAgICAgIGxldCB4ID0gRnAucG93KG4sIFExZGl2Mik7IC8vIGZpcnN0IGd1ZXNzIGF0IHRoZSBzcXVhcmUgcm9vdFxuICAgICAgICBsZXQgYiA9IEZwLnBvdyhuLCBRKTsgLy8gZmlyc3QgZ3Vlc3MgYXQgdGhlIGZ1ZGdlIGZhY3RvclxuICAgICAgICB3aGlsZSAoIUZwLmVxbChiLCBGcC5PTkUpKSB7XG4gICAgICAgICAgICBpZiAoRnAuZXFsKGIsIEZwLlpFUk8pKVxuICAgICAgICAgICAgICAgIHJldHVybiBGcC5aRVJPOyAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Ub25lbGxpJUUyJTgwJTkzU2hhbmtzX2FsZ29yaXRobSAoNC4gSWYgdCA9IDAsIHJldHVybiByID0gMClcbiAgICAgICAgICAgIC8vIEZpbmQgbSBzdWNoIGJeKDJebSk9PTFcbiAgICAgICAgICAgIGxldCBtID0gMTtcbiAgICAgICAgICAgIGZvciAobGV0IHQyID0gRnAuc3FyKGIpOyBtIDwgcjsgbSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKEZwLmVxbCh0MiwgRnAuT05FKSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgdDIgPSBGcC5zcXIodDIpOyAvLyB0MiAqPSB0MlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTk9URTogci1tLTEgY2FuIGJlIGJpZ2dlciB0aGFuIDMyLCBuZWVkIHRvIGNvbnZlcnQgdG8gYmlnaW50IGJlZm9yZSBzaGlmdCwgb3RoZXJ3aXNlIHRoZXJlIHdpbGwgYmUgb3ZlcmZsb3dcbiAgICAgICAgICAgIGNvbnN0IGdlID0gRnAucG93KGcsIF8xbiA8PCBCaWdJbnQociAtIG0gLSAxKSk7IC8vIGdlID0gMl4oci1tLTEpXG4gICAgICAgICAgICBnID0gRnAuc3FyKGdlKTsgLy8gZyA9IGdlICogZ2VcbiAgICAgICAgICAgIHggPSBGcC5tdWwoeCwgZ2UpOyAvLyB4ICo9IGdlXG4gICAgICAgICAgICBiID0gRnAubXVsKGIsIGcpOyAvLyBiICo9IGdcbiAgICAgICAgICAgIHIgPSBtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4O1xuICAgIH07XG59XG4vKipcbiAqIFNxdWFyZSByb290IGZvciBhIGZpbml0ZSBmaWVsZC4gSXQgd2lsbCB0cnkgdG8gY2hlY2sgaWYgb3B0aW1pemF0aW9ucyBhcmUgYXBwbGljYWJsZSBhbmQgZmFsbCBiYWNrIHRvIDQ6XG4gKlxuICogMS4gUCDiiaEgMyAobW9kIDQpXG4gKiAyLiBQIOKJoSA1IChtb2QgOClcbiAqIDMuIFAg4omhIDkgKG1vZCAxNilcbiAqIDQuIFRvbmVsbGktU2hhbmtzIGFsZ29yaXRobVxuICpcbiAqIERpZmZlcmVudCBhbGdvcml0aG1zIGNhbiBnaXZlIGRpZmZlcmVudCByb290cywgaXQgaXMgdXAgdG8gdXNlciB0byBkZWNpZGUgd2hpY2ggb25lIHRoZXkgd2FudC5cbiAqIEZvciBleGFtcGxlIHRoZXJlIGlzIEZwU3FydE9kZC9GcFNxcnRFdmVuIHRvIGNob2ljZSByb290IGJhc2VkIG9uIG9kZG5lc3MgKHVzZWQgZm9yIGhhc2gtdG8tY3VydmUpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gRnBTcXJ0KFApIHtcbiAgICAvLyBQIOKJoSAzIChtb2QgNClcbiAgICAvLyDiiJpuID0gbl4oKFArMSkvNClcbiAgICBpZiAoUCAlIF80biA9PT0gXzNuKSB7XG4gICAgICAgIC8vIE5vdCBhbGwgcm9vdHMgcG9zc2libGUhXG4gICAgICAgIC8vIGNvbnN0IE9SREVSID1cbiAgICAgICAgLy8gICAweDFhMDExMWVhMzk3ZmU2OWE0YjFiYTdiNjQzNGJhY2Q3NjQ3NzRiODRmMzg1MTJiZjY3MzBkMmEwZjZiMGY2MjQxZWFiZmZmZWIxNTNmZmZmYjlmZWZmZmZmZmZmYWFhYm47XG4gICAgICAgIC8vIGNvbnN0IE5VTSA9IDcyMDU3NTk0MDM3OTI3ODE2bjtcbiAgICAgICAgY29uc3QgcDFkaXY0ID0gKFAgKyBfMW4pIC8gXzRuO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gc3FydDNtb2Q0KEZwLCBuKSB7XG4gICAgICAgICAgICBjb25zdCByb290ID0gRnAucG93KG4sIHAxZGl2NCk7XG4gICAgICAgICAgICAvLyBUaHJvdyBpZiByb290KioyICE9IG5cbiAgICAgICAgICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgbikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIEF0a2luIGFsZ29yaXRobSBmb3IgcSDiiaEgNSAobW9kIDgpLCBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDEyLzY4NS5wZGYgKHBhZ2UgMTApXG4gICAgaWYgKFAgJSBfOG4gPT09IF81bikge1xuICAgICAgICBjb25zdCBjMSA9IChQIC0gXzVuKSAvIF84bjtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNxcnQ1bW9kOChGcCwgbikge1xuICAgICAgICAgICAgY29uc3QgbjIgPSBGcC5tdWwobiwgXzJuKTtcbiAgICAgICAgICAgIGNvbnN0IHYgPSBGcC5wb3cobjIsIGMxKTtcbiAgICAgICAgICAgIGNvbnN0IG52ID0gRnAubXVsKG4sIHYpO1xuICAgICAgICAgICAgY29uc3QgaSA9IEZwLm11bChGcC5tdWwobnYsIF8ybiksIHYpO1xuICAgICAgICAgICAgY29uc3Qgcm9vdCA9IEZwLm11bChudiwgRnAuc3ViKGksIEZwLk9ORSkpO1xuICAgICAgICAgICAgaWYgKCFGcC5lcWwoRnAuc3FyKHJvb3QpLCBuKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gUCDiiaEgOSAobW9kIDE2KVxuICAgIGlmIChQICUgXzE2biA9PT0gXzluKSB7XG4gICAgICAgIC8vIE5PVEU6IHRvbmVsbGkgaXMgdG9vIHNsb3cgZm9yIGJscy1GcDIgY2FsY3VsYXRpb25zIGV2ZW4gb24gc3RhcnRcbiAgICAgICAgLy8gTWVhbnMgd2UgY2Fubm90IHVzZSBzcXJ0IGZvciBjb25zdGFudHMgYXQgYWxsIVxuICAgICAgICAvL1xuICAgICAgICAvLyBjb25zdCBjMSA9IEZwLnNxcnQoRnAubmVnYXRlKEZwLk9ORSkpOyAvLyAgMS4gYzEgPSBzcXJ0KC0xKSBpbiBGLCBpLmUuLCAoYzFeMikgPT0gLTEgaW4gRlxuICAgICAgICAvLyBjb25zdCBjMiA9IEZwLnNxcnQoYzEpOyAgICAgICAgICAgICAgICAvLyAgMi4gYzIgPSBzcXJ0KGMxKSBpbiBGLCBpLmUuLCAoYzJeMikgPT0gYzEgaW4gRlxuICAgICAgICAvLyBjb25zdCBjMyA9IEZwLnNxcnQoRnAubmVnYXRlKGMxKSk7ICAgICAvLyAgMy4gYzMgPSBzcXJ0KC1jMSkgaW4gRiwgaS5lLiwgKGMzXjIpID09IC1jMSBpbiBGXG4gICAgICAgIC8vIGNvbnN0IGM0ID0gKFAgKyBfN24pIC8gXzE2bjsgICAgICAgICAgIC8vICA0LiBjNCA9IChxICsgNykgLyAxNiAgICAgICAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcbiAgICAgICAgLy8gc3FydCA9ICh4KSA9PiB7XG4gICAgICAgIC8vICAgbGV0IHR2MSA9IEZwLnBvdyh4LCBjNCk7ICAgICAgICAgICAgIC8vICAxLiB0djEgPSB4XmM0XG4gICAgICAgIC8vICAgbGV0IHR2MiA9IEZwLm11bChjMSwgdHYxKTsgICAgICAgICAgIC8vICAyLiB0djIgPSBjMSAqIHR2MVxuICAgICAgICAvLyAgIGNvbnN0IHR2MyA9IEZwLm11bChjMiwgdHYxKTsgICAgICAgICAvLyAgMy4gdHYzID0gYzIgKiB0djFcbiAgICAgICAgLy8gICBsZXQgdHY0ID0gRnAubXVsKGMzLCB0djEpOyAgICAgICAgICAgLy8gIDQuIHR2NCA9IGMzICogdHYxXG4gICAgICAgIC8vICAgY29uc3QgZTEgPSBGcC5lcXVhbHMoRnAuc3F1YXJlKHR2MiksIHgpOyAvLyAgNS4gIGUxID0gKHR2Ml4yKSA9PSB4XG4gICAgICAgIC8vICAgY29uc3QgZTIgPSBGcC5lcXVhbHMoRnAuc3F1YXJlKHR2MyksIHgpOyAvLyAgNi4gIGUyID0gKHR2M14yKSA9PSB4XG4gICAgICAgIC8vICAgdHYxID0gRnAuY21vdih0djEsIHR2MiwgZTEpOyAvLyAgNy4gdHYxID0gQ01PVih0djEsIHR2MiwgZTEpICAjIFNlbGVjdCB0djIgaWYgKHR2Ml4yKSA9PSB4XG4gICAgICAgIC8vICAgdHYyID0gRnAuY21vdih0djQsIHR2MywgZTIpOyAvLyAgOC4gdHYyID0gQ01PVih0djQsIHR2MywgZTIpICAjIFNlbGVjdCB0djMgaWYgKHR2M14yKSA9PSB4XG4gICAgICAgIC8vICAgY29uc3QgZTMgPSBGcC5lcXVhbHMoRnAuc3F1YXJlKHR2MiksIHgpOyAvLyAgOS4gIGUzID0gKHR2Ml4yKSA9PSB4XG4gICAgICAgIC8vICAgcmV0dXJuIEZwLmNtb3YodHYxLCB0djIsIGUzKTsgLy8gIDEwLiAgeiA9IENNT1YodHYxLCB0djIsIGUzKSAgIyBTZWxlY3QgdGhlIHNxcnQgZnJvbSB0djEgYW5kIHR2MlxuICAgICAgICAvLyB9XG4gICAgfVxuICAgIC8vIE90aGVyIGNhc2VzOiBUb25lbGxpLVNoYW5rcyBhbGdvcml0aG1cbiAgICByZXR1cm4gdG9uZWxsaVNoYW5rcyhQKTtcbn1cbi8vIExpdHRsZS1lbmRpYW4gY2hlY2sgZm9yIGZpcnN0IExFIGJpdCAobGFzdCBCRSBiaXQpO1xuZXhwb3J0IGNvbnN0IGlzTmVnYXRpdmVMRSA9IChudW0sIG1vZHVsbykgPT4gKG1vZChudW0sIG1vZHVsbykgJiBfMW4pID09PSBfMW47XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IEZJRUxEX0ZJRUxEUyA9IFtcbiAgICAnY3JlYXRlJywgJ2lzVmFsaWQnLCAnaXMwJywgJ25lZycsICdpbnYnLCAnc3FydCcsICdzcXInLFxuICAgICdlcWwnLCAnYWRkJywgJ3N1YicsICdtdWwnLCAncG93JywgJ2RpdicsXG4gICAgJ2FkZE4nLCAnc3ViTicsICdtdWxOJywgJ3Nxck4nXG5dO1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlRmllbGQoZmllbGQpIHtcbiAgICBjb25zdCBpbml0aWFsID0ge1xuICAgICAgICBPUkRFUjogJ2JpZ2ludCcsXG4gICAgICAgIE1BU0s6ICdiaWdpbnQnLFxuICAgICAgICBCWVRFUzogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBCSVRTOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgfTtcbiAgICBjb25zdCBvcHRzID0gRklFTERfRklFTERTLnJlZHVjZSgobWFwLCB2YWwpID0+IHtcbiAgICAgICAgbWFwW3ZhbF0gPSAnZnVuY3Rpb24nO1xuICAgICAgICByZXR1cm4gbWFwO1xuICAgIH0sIGluaXRpYWwpO1xuICAgIHJldHVybiB2YWxpZGF0ZU9iamVjdChmaWVsZCwgb3B0cyk7XG59XG4vLyBHZW5lcmljIGZpZWxkIGZ1bmN0aW9uc1xuLyoqXG4gKiBTYW1lIGFzIGBwb3dgIGJ1dCBmb3IgRnA6IG5vbi1jb25zdGFudC10aW1lLlxuICogVW5zYWZlIGluIHNvbWUgY29udGV4dHM6IHVzZXMgbGFkZGVyLCBzbyBjYW4gZXhwb3NlIGJpZ2ludCBiaXRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gRnBQb3coZiwgbnVtLCBwb3dlcikge1xuICAgIC8vIFNob3VsZCBoYXZlIHNhbWUgc3BlZWQgYXMgcG93IGZvciBiaWdpbnRzXG4gICAgLy8gVE9ETzogYmVuY2htYXJrIVxuICAgIGlmIChwb3dlciA8IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGV4cG9uZW50LCBuZWdhdGl2ZXMgdW5zdXBwb3J0ZWQnKTtcbiAgICBpZiAocG93ZXIgPT09IF8wbilcbiAgICAgICAgcmV0dXJuIGYuT05FO1xuICAgIGlmIChwb3dlciA9PT0gXzFuKVxuICAgICAgICByZXR1cm4gbnVtO1xuICAgIGxldCBwID0gZi5PTkU7XG4gICAgbGV0IGQgPSBudW07XG4gICAgd2hpbGUgKHBvd2VyID4gXzBuKSB7XG4gICAgICAgIGlmIChwb3dlciAmIF8xbilcbiAgICAgICAgICAgIHAgPSBmLm11bChwLCBkKTtcbiAgICAgICAgZCA9IGYuc3FyKGQpO1xuICAgICAgICBwb3dlciA+Pj0gXzFuO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbn1cbi8qKlxuICogRWZmaWNpZW50bHkgaW52ZXJ0IGFuIGFycmF5IG9mIEZpZWxkIGVsZW1lbnRzLlxuICogYGludigwKWAgd2lsbCByZXR1cm4gYHVuZGVmaW5lZGAgaGVyZTogbWFrZSBzdXJlIHRvIHRocm93IGFuIGVycm9yLlxuICovXG5leHBvcnQgZnVuY3Rpb24gRnBJbnZlcnRCYXRjaChmLCBudW1zKSB7XG4gICAgY29uc3QgdG1wID0gbmV3IEFycmF5KG51bXMubGVuZ3RoKTtcbiAgICAvLyBXYWxrIGZyb20gZmlyc3QgdG8gbGFzdCwgbXVsdGlwbHkgdGhlbSBieSBlYWNoIG90aGVyIE1PRCBwXG4gICAgY29uc3QgbGFzdE11bHRpcGxpZWQgPSBudW1zLnJlZHVjZSgoYWNjLCBudW0sIGkpID0+IHtcbiAgICAgICAgaWYgKGYuaXMwKG51bSkpXG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB0bXBbaV0gPSBhY2M7XG4gICAgICAgIHJldHVybiBmLm11bChhY2MsIG51bSk7XG4gICAgfSwgZi5PTkUpO1xuICAgIC8vIEludmVydCBsYXN0IGVsZW1lbnRcbiAgICBjb25zdCBpbnZlcnRlZCA9IGYuaW52KGxhc3RNdWx0aXBsaWVkKTtcbiAgICAvLyBXYWxrIGZyb20gbGFzdCB0byBmaXJzdCwgbXVsdGlwbHkgdGhlbSBieSBpbnZlcnRlZCBlYWNoIG90aGVyIE1PRCBwXG4gICAgbnVtcy5yZWR1Y2VSaWdodCgoYWNjLCBudW0sIGkpID0+IHtcbiAgICAgICAgaWYgKGYuaXMwKG51bSkpXG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB0bXBbaV0gPSBmLm11bChhY2MsIHRtcFtpXSk7XG4gICAgICAgIHJldHVybiBmLm11bChhY2MsIG51bSk7XG4gICAgfSwgaW52ZXJ0ZWQpO1xuICAgIHJldHVybiB0bXA7XG59XG5leHBvcnQgZnVuY3Rpb24gRnBEaXYoZiwgbGhzLCByaHMpIHtcbiAgICByZXR1cm4gZi5tdWwobGhzLCB0eXBlb2YgcmhzID09PSAnYmlnaW50JyA/IGludmVydChyaHMsIGYuT1JERVIpIDogZi5pbnYocmhzKSk7XG59XG4vKipcbiAqIExlZ2VuZHJlIHN5bWJvbC5cbiAqICogKGEgfCBwKSDiiaEgMSAgICBpZiBhIGlzIGEgc3F1YXJlIChtb2QgcCksIHF1YWRyYXRpYyByZXNpZHVlXG4gKiAqIChhIHwgcCkg4omhIC0xICAgaWYgYSBpcyBub3QgYSBzcXVhcmUgKG1vZCBwKSwgcXVhZHJhdGljIG5vbiByZXNpZHVlXG4gKiAqIChhIHwgcCkg4omhIDAgICAgaWYgYSDiiaEgMCAobW9kIHApXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBGcExlZ2VuZHJlKG9yZGVyKSB7XG4gICAgY29uc3QgbGVnZW5kcmVDb25zdCA9IChvcmRlciAtIF8xbikgLyBfMm47IC8vIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIHJldHVybiAoZiwgeCkgPT4gZi5wb3coeCwgbGVnZW5kcmVDb25zdCk7XG59XG4vLyBUaGlzIGZ1bmN0aW9uIHJldHVybnMgVHJ1ZSB3aGVuZXZlciB0aGUgdmFsdWUgeCBpcyBhIHNxdWFyZSBpbiB0aGUgZmllbGQgRi5cbmV4cG9ydCBmdW5jdGlvbiBGcElzU3F1YXJlKGYpIHtcbiAgICBjb25zdCBsZWdlbmRyZSA9IEZwTGVnZW5kcmUoZi5PUkRFUik7XG4gICAgcmV0dXJuICh4KSA9PiB7XG4gICAgICAgIGNvbnN0IHAgPSBsZWdlbmRyZShmLCB4KTtcbiAgICAgICAgcmV0dXJuIGYuZXFsKHAsIGYuWkVSTykgfHwgZi5lcWwocCwgZi5PTkUpO1xuICAgIH07XG59XG4vLyBDVVJWRS5uIGxlbmd0aHNcbmV4cG9ydCBmdW5jdGlvbiBuTGVuZ3RoKG4sIG5CaXRMZW5ndGgpIHtcbiAgICAvLyBCaXQgc2l6ZSwgYnl0ZSBzaXplIG9mIENVUlZFLm5cbiAgICBjb25zdCBfbkJpdExlbmd0aCA9IG5CaXRMZW5ndGggIT09IHVuZGVmaW5lZCA/IG5CaXRMZW5ndGggOiBuLnRvU3RyaW5nKDIpLmxlbmd0aDtcbiAgICBjb25zdCBuQnl0ZUxlbmd0aCA9IE1hdGguY2VpbChfbkJpdExlbmd0aCAvIDgpO1xuICAgIHJldHVybiB7IG5CaXRMZW5ndGg6IF9uQml0TGVuZ3RoLCBuQnl0ZUxlbmd0aCB9O1xufVxuLyoqXG4gKiBJbml0aWFsaXplcyBhIGZpbml0ZSBmaWVsZCBvdmVyIHByaW1lLlxuICogTWFqb3IgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uczpcbiAqICogYSkgZGVub3JtYWxpemVkIG9wZXJhdGlvbnMgbGlrZSBtdWxOIGluc3RlYWQgb2YgbXVsXG4gKiAqIGIpIHNhbWUgb2JqZWN0IHNoYXBlOiBuZXZlciBhZGQgb3IgcmVtb3ZlIGtleXNcbiAqICogYykgT2JqZWN0LmZyZWV6ZVxuICogRnJhZ2lsZTogYWx3YXlzIHJ1biBhIGJlbmNobWFyayBvbiBhIGNoYW5nZS5cbiAqIFNlY3VyaXR5IG5vdGU6IG9wZXJhdGlvbnMgZG9uJ3QgY2hlY2sgJ2lzVmFsaWQnIGZvciBhbGwgZWxlbWVudHMgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsXG4gKiBpdCBpcyBjYWxsZXIgcmVzcG9uc2liaWxpdHkgdG8gY2hlY2sgdGhpcy5cbiAqIFRoaXMgaXMgbG93LWxldmVsIGNvZGUsIHBsZWFzZSBtYWtlIHN1cmUgeW91IGtub3cgd2hhdCB5b3UncmUgZG9pbmcuXG4gKiBAcGFyYW0gT1JERVIgcHJpbWUgcG9zaXRpdmUgYmlnaW50XG4gKiBAcGFyYW0gYml0TGVuIGhvdyBtYW55IGJpdHMgdGhlIGZpZWxkIGNvbnN1bWVzXG4gKiBAcGFyYW0gaXNMRSAoZGVmOiBmYWxzZSkgaWYgZW5jb2RpbmcgLyBkZWNvZGluZyBzaG91bGQgYmUgaW4gbGl0dGxlLWVuZGlhblxuICogQHBhcmFtIHJlZGVmIG9wdGlvbmFsIGZhc3RlciByZWRlZmluaXRpb25zIG9mIHNxcnQgYW5kIG90aGVyIG1ldGhvZHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEZpZWxkKE9SREVSLCBiaXRMZW4sIGlzTEUgPSBmYWxzZSwgcmVkZWYgPSB7fSkge1xuICAgIGlmIChPUkRFUiA8PSBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBmaWVsZDogZXhwZWN0ZWQgT1JERVIgPiAwLCBnb3QgJyArIE9SREVSKTtcbiAgICBjb25zdCB7IG5CaXRMZW5ndGg6IEJJVFMsIG5CeXRlTGVuZ3RoOiBCWVRFUyB9ID0gbkxlbmd0aChPUkRFUiwgYml0TGVuKTtcbiAgICBpZiAoQllURVMgPiAyMDQ4KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZmllbGQ6IGV4cGVjdGVkIE9SREVSIG9mIDw9IDIwNDggYnl0ZXMnKTtcbiAgICBsZXQgc3FydFA7IC8vIGNhY2hlZCBzcXJ0UFxuICAgIGNvbnN0IGYgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgT1JERVIsXG4gICAgICAgIGlzTEUsXG4gICAgICAgIEJJVFMsXG4gICAgICAgIEJZVEVTLFxuICAgICAgICBNQVNLOiBiaXRNYXNrKEJJVFMpLFxuICAgICAgICBaRVJPOiBfMG4sXG4gICAgICAgIE9ORTogXzFuLFxuICAgICAgICBjcmVhdGU6IChudW0pID0+IG1vZChudW0sIE9SREVSKSxcbiAgICAgICAgaXNWYWxpZDogKG51bSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBudW0gIT09ICdiaWdpbnQnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBmaWVsZCBlbGVtZW50OiBleHBlY3RlZCBiaWdpbnQsIGdvdCAnICsgdHlwZW9mIG51bSk7XG4gICAgICAgICAgICByZXR1cm4gXzBuIDw9IG51bSAmJiBudW0gPCBPUkRFUjsgLy8gMCBpcyB2YWxpZCBlbGVtZW50LCBidXQgaXQncyBub3QgaW52ZXJ0aWJsZVxuICAgICAgICB9LFxuICAgICAgICBpczA6IChudW0pID0+IG51bSA9PT0gXzBuLFxuICAgICAgICBpc09kZDogKG51bSkgPT4gKG51bSAmIF8xbikgPT09IF8xbixcbiAgICAgICAgbmVnOiAobnVtKSA9PiBtb2QoLW51bSwgT1JERVIpLFxuICAgICAgICBlcWw6IChsaHMsIHJocykgPT4gbGhzID09PSByaHMsXG4gICAgICAgIHNxcjogKG51bSkgPT4gbW9kKG51bSAqIG51bSwgT1JERVIpLFxuICAgICAgICBhZGQ6IChsaHMsIHJocykgPT4gbW9kKGxocyArIHJocywgT1JERVIpLFxuICAgICAgICBzdWI6IChsaHMsIHJocykgPT4gbW9kKGxocyAtIHJocywgT1JERVIpLFxuICAgICAgICBtdWw6IChsaHMsIHJocykgPT4gbW9kKGxocyAqIHJocywgT1JERVIpLFxuICAgICAgICBwb3c6IChudW0sIHBvd2VyKSA9PiBGcFBvdyhmLCBudW0sIHBvd2VyKSxcbiAgICAgICAgZGl2OiAobGhzLCByaHMpID0+IG1vZChsaHMgKiBpbnZlcnQocmhzLCBPUkRFUiksIE9SREVSKSxcbiAgICAgICAgLy8gU2FtZSBhcyBhYm92ZSwgYnV0IGRvZXNuJ3Qgbm9ybWFsaXplXG4gICAgICAgIHNxck46IChudW0pID0+IG51bSAqIG51bSxcbiAgICAgICAgYWRkTjogKGxocywgcmhzKSA9PiBsaHMgKyByaHMsXG4gICAgICAgIHN1Yk46IChsaHMsIHJocykgPT4gbGhzIC0gcmhzLFxuICAgICAgICBtdWxOOiAobGhzLCByaHMpID0+IGxocyAqIHJocyxcbiAgICAgICAgaW52OiAobnVtKSA9PiBpbnZlcnQobnVtLCBPUkRFUiksXG4gICAgICAgIHNxcnQ6IHJlZGVmLnNxcnQgfHxcbiAgICAgICAgICAgICgobikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghc3FydFApXG4gICAgICAgICAgICAgICAgICAgIHNxcnRQID0gRnBTcXJ0KE9SREVSKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3FydFAoZiwgbik7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgaW52ZXJ0QmF0Y2g6IChsc3QpID0+IEZwSW52ZXJ0QmF0Y2goZiwgbHN0KSxcbiAgICAgICAgLy8gVE9ETzogZG8gd2UgcmVhbGx5IG5lZWQgY29uc3RhbnQgY21vdj9cbiAgICAgICAgLy8gV2UgZG9uJ3QgaGF2ZSBjb25zdC10aW1lIGJpZ2ludHMgYW55d2F5LCBzbyBwcm9iYWJseSB3aWxsIGJlIG5vdCB2ZXJ5IHVzZWZ1bFxuICAgICAgICBjbW92OiAoYSwgYiwgYykgPT4gKGMgPyBiIDogYSksXG4gICAgICAgIHRvQnl0ZXM6IChudW0pID0+IChpc0xFID8gbnVtYmVyVG9CeXRlc0xFKG51bSwgQllURVMpIDogbnVtYmVyVG9CeXRlc0JFKG51bSwgQllURVMpKSxcbiAgICAgICAgZnJvbUJ5dGVzOiAoYnl0ZXMpID0+IHtcbiAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggIT09IEJZVEVTKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmllbGQuZnJvbUJ5dGVzOiBleHBlY3RlZCAnICsgQllURVMgKyAnIGJ5dGVzLCBnb3QgJyArIGJ5dGVzLmxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4gaXNMRSA/IGJ5dGVzVG9OdW1iZXJMRShieXRlcykgOiBieXRlc1RvTnVtYmVyQkUoYnl0ZXMpO1xuICAgICAgICB9LFxuICAgIH0pO1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKGYpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIEZwU3FydE9kZChGcCwgZWxtKSB7XG4gICAgaWYgKCFGcC5pc09kZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmllbGQgZG9lc24ndCBoYXZlIGlzT2RkXCIpO1xuICAgIGNvbnN0IHJvb3QgPSBGcC5zcXJ0KGVsbSk7XG4gICAgcmV0dXJuIEZwLmlzT2RkKHJvb3QpID8gcm9vdCA6IEZwLm5lZyhyb290KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBGcFNxcnRFdmVuKEZwLCBlbG0pIHtcbiAgICBpZiAoIUZwLmlzT2RkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaWVsZCBkb2Vzbid0IGhhdmUgaXNPZGRcIik7XG4gICAgY29uc3Qgcm9vdCA9IEZwLnNxcnQoZWxtKTtcbiAgICByZXR1cm4gRnAuaXNPZGQocm9vdCkgPyBGcC5uZWcocm9vdCkgOiByb290O1xufVxuLyoqXG4gKiBcIkNvbnN0YW50LXRpbWVcIiBwcml2YXRlIGtleSBnZW5lcmF0aW9uIHV0aWxpdHkuXG4gKiBTYW1lIGFzIG1hcEtleVRvRmllbGQsIGJ1dCBhY2NlcHRzIGxlc3MgYnl0ZXMgKDQwIGluc3RlYWQgb2YgNDggZm9yIDMyLWJ5dGUgZmllbGQpLlxuICogV2hpY2ggbWFrZXMgaXQgc2xpZ2h0bHkgbW9yZSBiaWFzZWQsIGxlc3Mgc2VjdXJlLlxuICogQGRlcHJlY2F0ZWQgdXNlIGBtYXBLZXlUb0ZpZWxkYCBpbnN0ZWFkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNoVG9Qcml2YXRlU2NhbGFyKGhhc2gsIGdyb3VwT3JkZXIsIGlzTEUgPSBmYWxzZSkge1xuICAgIGhhc2ggPSBlbnN1cmVCeXRlcygncHJpdmF0ZUhhc2gnLCBoYXNoKTtcbiAgICBjb25zdCBoYXNoTGVuID0gaGFzaC5sZW5ndGg7XG4gICAgY29uc3QgbWluTGVuID0gbkxlbmd0aChncm91cE9yZGVyKS5uQnl0ZUxlbmd0aCArIDg7XG4gICAgaWYgKG1pbkxlbiA8IDI0IHx8IGhhc2hMZW4gPCBtaW5MZW4gfHwgaGFzaExlbiA+IDEwMjQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGFzaFRvUHJpdmF0ZVNjYWxhcjogZXhwZWN0ZWQgJyArIG1pbkxlbiArICctMTAyNCBieXRlcyBvZiBpbnB1dCwgZ290ICcgKyBoYXNoTGVuKTtcbiAgICBjb25zdCBudW0gPSBpc0xFID8gYnl0ZXNUb051bWJlckxFKGhhc2gpIDogYnl0ZXNUb051bWJlckJFKGhhc2gpO1xuICAgIHJldHVybiBtb2QobnVtLCBncm91cE9yZGVyIC0gXzFuKSArIF8xbjtcbn1cbi8qKlxuICogUmV0dXJucyB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgY29uc3VtZWQgYnkgdGhlIGZpZWxkIGVsZW1lbnQuXG4gKiBGb3IgZXhhbXBsZSwgMzIgYnl0ZXMgZm9yIHVzdWFsIDI1Ni1iaXQgd2VpZXJzdHJhc3MgY3VydmUuXG4gKiBAcGFyYW0gZmllbGRPcmRlciBudW1iZXIgb2YgZmllbGQgZWxlbWVudHMsIHVzdWFsbHkgQ1VSVkUublxuICogQHJldHVybnMgYnl0ZSBsZW5ndGggb2YgZmllbGRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEZpZWxkQnl0ZXNMZW5ndGgoZmllbGRPcmRlcikge1xuICAgIGlmICh0eXBlb2YgZmllbGRPcmRlciAhPT0gJ2JpZ2ludCcpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZmllbGQgb3JkZXIgbXVzdCBiZSBiaWdpbnQnKTtcbiAgICBjb25zdCBiaXRMZW5ndGggPSBmaWVsZE9yZGVyLnRvU3RyaW5nKDIpLmxlbmd0aDtcbiAgICByZXR1cm4gTWF0aC5jZWlsKGJpdExlbmd0aCAvIDgpO1xufVxuLyoqXG4gKiBSZXR1cm5zIG1pbmltYWwgYW1vdW50IG9mIGJ5dGVzIHRoYXQgY2FuIGJlIHNhZmVseSByZWR1Y2VkXG4gKiBieSBmaWVsZCBvcmRlci5cbiAqIFNob3VsZCBiZSAyXi0xMjggZm9yIDEyOC1iaXQgY3VydmUgc3VjaCBhcyBQMjU2LlxuICogQHBhcmFtIGZpZWxkT3JkZXIgbnVtYmVyIG9mIGZpZWxkIGVsZW1lbnRzLCB1c3VhbGx5IENVUlZFLm5cbiAqIEByZXR1cm5zIGJ5dGUgbGVuZ3RoIG9mIHRhcmdldCBoYXNoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRNaW5IYXNoTGVuZ3RoKGZpZWxkT3JkZXIpIHtcbiAgICBjb25zdCBsZW5ndGggPSBnZXRGaWVsZEJ5dGVzTGVuZ3RoKGZpZWxkT3JkZXIpO1xuICAgIHJldHVybiBsZW5ndGggKyBNYXRoLmNlaWwobGVuZ3RoIC8gMik7XG59XG4vKipcbiAqIFwiQ29uc3RhbnQtdGltZVwiIHByaXZhdGUga2V5IGdlbmVyYXRpb24gdXRpbGl0eS5cbiAqIENhbiB0YWtlIChuICsgbi8yKSBvciBtb3JlIGJ5dGVzIG9mIHVuaWZvcm0gaW5wdXQgZS5nLiBmcm9tIENTUFJORyBvciBLREZcbiAqIGFuZCBjb252ZXJ0IHRoZW0gaW50byBwcml2YXRlIHNjYWxhciwgd2l0aCB0aGUgbW9kdWxvIGJpYXMgYmVpbmcgbmVnbGlnaWJsZS5cbiAqIE5lZWRzIGF0IGxlYXN0IDQ4IGJ5dGVzIG9mIGlucHV0IGZvciAzMi1ieXRlIHByaXZhdGUga2V5LlxuICogaHR0cHM6Ly9yZXNlYXJjaC5rdWRlbHNraXNlY3VyaXR5LmNvbS8yMDIwLzA3LzI4L3RoZS1kZWZpbml0aXZlLWd1aWRlLXRvLW1vZHVsby1iaWFzLWFuZC1ob3ctdG8tYXZvaWQtaXQvXG4gKiBGSVBTIDE4Ni01LCBBLjIgaHR0cHM6Ly9jc3JjLm5pc3QuZ292L3B1YmxpY2F0aW9ucy9kZXRhaWwvZmlwcy8xODYvNS9maW5hbFxuICogUkZDIDkzODAsIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNVxuICogQHBhcmFtIGhhc2ggaGFzaCBvdXRwdXQgZnJvbSBTSEEzIG9yIGEgc2ltaWxhciBmdW5jdGlvblxuICogQHBhcmFtIGdyb3VwT3JkZXIgc2l6ZSBvZiBzdWJncm91cCAtIChlLmcuIHNlY3AyNTZrMS5DVVJWRS5uKVxuICogQHBhcmFtIGlzTEUgaW50ZXJwcmV0IGhhc2ggYnl0ZXMgYXMgTEUgbnVtXG4gKiBAcmV0dXJucyB2YWxpZCBwcml2YXRlIHNjYWxhclxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFwSGFzaFRvRmllbGQoa2V5LCBmaWVsZE9yZGVyLCBpc0xFID0gZmFsc2UpIHtcbiAgICBjb25zdCBsZW4gPSBrZXkubGVuZ3RoO1xuICAgIGNvbnN0IGZpZWxkTGVuID0gZ2V0RmllbGRCeXRlc0xlbmd0aChmaWVsZE9yZGVyKTtcbiAgICBjb25zdCBtaW5MZW4gPSBnZXRNaW5IYXNoTGVuZ3RoKGZpZWxkT3JkZXIpO1xuICAgIC8vIE5vIHNtYWxsIG51bWJlcnM6IG5lZWQgdG8gdW5kZXJzdGFuZCBiaWFzIHN0b3J5LiBObyBodWdlIG51bWJlcnM6IGVhc2llciB0byBkZXRlY3QgSlMgdGltaW5ncy5cbiAgICBpZiAobGVuIDwgMTYgfHwgbGVuIDwgbWluTGVuIHx8IGxlbiA+IDEwMjQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0ZWQgJyArIG1pbkxlbiArICctMTAyNCBieXRlcyBvZiBpbnB1dCwgZ290ICcgKyBsZW4pO1xuICAgIGNvbnN0IG51bSA9IGlzTEUgPyBieXRlc1RvTnVtYmVyTEUoa2V5KSA6IGJ5dGVzVG9OdW1iZXJCRShrZXkpO1xuICAgIC8vIGBtb2QoeCwgMTEpYCBjYW4gc29tZXRpbWVzIHByb2R1Y2UgMC4gYG1vZCh4LCAxMCkgKyAxYCBpcyB0aGUgc2FtZSwgYnV0IG5vIDBcbiAgICBjb25zdCByZWR1Y2VkID0gbW9kKG51bSwgZmllbGRPcmRlciAtIF8xbikgKyBfMW47XG4gICAgcmV0dXJuIGlzTEUgPyBudW1iZXJUb0J5dGVzTEUocmVkdWNlZCwgZmllbGRMZW4pIDogbnVtYmVyVG9CeXRlc0JFKHJlZHVjZWQsIGZpZWxkTGVuKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsYXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/modular.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/utils.js":
/*!**********************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/utils.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   aInRange: () => (/* binding */ aInRange),\n/* harmony export */   abool: () => (/* binding */ abool),\n/* harmony export */   abytes: () => (/* binding */ abytes),\n/* harmony export */   bitGet: () => (/* binding */ bitGet),\n/* harmony export */   bitLen: () => (/* binding */ bitLen),\n/* harmony export */   bitMask: () => (/* binding */ bitMask),\n/* harmony export */   bitSet: () => (/* binding */ bitSet),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   bytesToNumberBE: () => (/* binding */ bytesToNumberBE),\n/* harmony export */   bytesToNumberLE: () => (/* binding */ bytesToNumberLE),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createHmacDrbg: () => (/* binding */ createHmacDrbg),\n/* harmony export */   ensureBytes: () => (/* binding */ ensureBytes),\n/* harmony export */   equalBytes: () => (/* binding */ equalBytes),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   hexToNumber: () => (/* binding */ hexToNumber),\n/* harmony export */   inRange: () => (/* binding */ inRange),\n/* harmony export */   isBytes: () => (/* binding */ isBytes),\n/* harmony export */   memoized: () => (/* binding */ memoized),\n/* harmony export */   notImplemented: () => (/* binding */ notImplemented),\n/* harmony export */   numberToBytesBE: () => (/* binding */ numberToBytesBE),\n/* harmony export */   numberToBytesLE: () => (/* binding */ numberToBytesLE),\n/* harmony export */   numberToHexUnpadded: () => (/* binding */ numberToHexUnpadded),\n/* harmony export */   numberToVarBytesBE: () => (/* binding */ numberToVarBytesBE),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   validateObject: () => (/* binding */ validateObject)\n/* harmony export */ });\n/**\n * Hex, bytes and number utilities.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\nfunction isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\nfunction abytes(item) {\n    if (!isBytes(item))\n        throw new Error('Uint8Array expected');\n}\nfunction abool(title, value) {\n    if (typeof value !== 'boolean')\n        throw new Error(title + ' boolean expected, got ' + value);\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    abytes(bytes);\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? '0' + hex : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    return hex === '' ? _0n : BigInt('0x' + hex); // Big Endian\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9)\n        return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F)\n        return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f)\n        return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction bytesToNumberLE(bytes) {\n    abytes(bytes);\n    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nfunction numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nfunction numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nfunction numberToVarBytesBE(n) {\n    return hexToBytes(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nfunction ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === 'string') {\n        try {\n            res = hexToBytes(hex);\n        }\n        catch (e) {\n            throw new Error(title + ' must be hex string or Uint8Array, cause: ' + e);\n        }\n    }\n    else if (isBytes(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    }\n    else {\n        throw new Error(title + ' must be hex string or Uint8Array');\n    }\n    const len = res.length;\n    if (typeof expectedLength === 'number' && len !== expectedLength)\n        throw new Error(title + ' of length ' + expectedLength + ' expected, got ' + len);\n    return res;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// Compares 2 u8a-s in kinda constant time\nfunction equalBytes(a, b) {\n    if (a.length !== b.length)\n        return false;\n    let diff = 0;\n    for (let i = 0; i < a.length; i++)\n        diff |= a[i] ^ b[i];\n    return diff === 0;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error('string expected');\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n// Is positive bigint\nconst isPosBig = (n) => typeof n === 'bigint' && _0n <= n;\nfunction inRange(n, min, max) {\n    return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;\n}\n/**\n * Asserts min <= n < max. NOTE: It's < max and not <= max.\n * @example\n * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)\n */\nfunction aInRange(title, n, min, max) {\n    // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?\n    // consider P=256n, min=0n, max=P\n    // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`\n    // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`\n    // - our way is the cleanest:               `inRange('x', x, 0n, P)\n    if (!inRange(n, min, max))\n        throw new Error('expected valid ' + title + ': ' + min + ' <= n < ' + max + ', got ' + n);\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */\nfunction bitLen(n) {\n    let len;\n    for (len = 0; n > _0n; n >>= _1n, len += 1)\n        ;\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nfunction bitGet(n, pos) {\n    return (n >> BigInt(pos)) & _1n;\n}\n/**\n * Sets single bit at position.\n */\nfunction bitSet(n, pos, value) {\n    return n | ((value ? _1n : _0n) << BigInt(pos));\n}\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nconst bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;\n// DRBG\nconst u8n = (data) => new Uint8Array(data); // creates Uint8Array\nconst u8fr = (arr) => Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nfunction createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== 'number' || hashLen < 2)\n        throw new Error('hashLen must be a number');\n    if (typeof qByteLen !== 'number' || qByteLen < 2)\n        throw new Error('qByteLen must be a number');\n    if (typeof hmacFn !== 'function')\n        throw new Error('hmacFn must be a function');\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = () => {\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n()) => {\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0)\n            return;\n        k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = () => {\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000)\n            throw new Error('drbg: tried 1000 values');\n        let len = 0;\n        const out = [];\n        while (len < qByteLen) {\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes(...out);\n    };\n    const genUntil = (seed, pred) => {\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while (!(res = pred(gen())))\n            reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val) => typeof val === 'bigint',\n    function: (val) => typeof val === 'function',\n    boolean: (val) => typeof val === 'boolean',\n    string: (val) => typeof val === 'string',\n    stringOrUint8Array: (val) => typeof val === 'string' || isBytes(val),\n    isSafeInteger: (val) => Number.isSafeInteger(val),\n    array: (val) => Array.isArray(val),\n    field: (val, object) => object.Fp.isValid(val),\n    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nfunction validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional) => {\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== 'function')\n            throw new Error('invalid validator function');\n        const val = object[fieldName];\n        if (isOptional && val === undefined)\n            return;\n        if (!checkVal(val, object)) {\n            throw new Error('param ' + String(fieldName) + ' is invalid. Expected ' + type + ', got ' + val);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))\n        checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))\n        checkField(fieldName, type, true);\n    return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n/**\n * throws not implemented error\n */\nconst notImplemented = () => {\n    throw new Error('not implemented');\n};\n/**\n * Memoizes (caches) computation result.\n * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.\n */\nfunction memoized(fn) {\n    const map = new WeakMap();\n    return (arg, ...args) => {\n        const val = map.get(arg);\n        if (val !== undefined)\n            return val;\n        const computed = fn(arg, ...args);\n        map.set(arg, computed);\n        return computed;\n    };\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxhQUFhO0FBQ3hEO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLHFDQUFxQztBQUNyQztBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixTQUFTO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixtQkFBbUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDRCQUE0QjtBQUNuRDtBQUNPO0FBQ1A7QUFDQSw0Q0FBNEM7QUFDNUMsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUNuRCw4REFBOEQ7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxXQUFXLFdBQVcsWUFBWSxJQUFJO0FBQ3BELGtDQUFrQyxvQkFBb0IsSUFBSSxhQUFhLEdBQUc7QUFDMUU7QUFDQSxrQ0FBa0MsVUFBVSxJQUFJLFNBQVM7QUFDekQsa0NBQWtDLG9CQUFvQixJQUFJLFNBQVM7QUFDbkUsa0NBQWtDLDJCQUEyQjtBQUM3RCxrQ0FBa0Msd0JBQXdCO0FBQzFEO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9sZmcvR2l0L01hZHRyaXBzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC91dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEhleCwgYnl0ZXMgYW5kIG51bWJlciB1dGlsaXRpZXMuXG4gKiBAbW9kdWxlXG4gKi9cbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIDEwMCBsaW5lcyBvZiBjb2RlIGluIHRoZSBmaWxlIGFyZSBkdXBsaWNhdGVkIGZyb20gbm9ibGUtaGFzaGVzICh1dGlscykuXG4vLyBUaGlzIGlzIE9LOiBgYWJzdHJhY3RgIGRpcmVjdG9yeSBkb2VzIG5vdCB1c2Ugbm9ibGUtaGFzaGVzLlxuLy8gVXNlciBtYXkgb3B0LWluIGludG8gdXNpbmcgZGlmZmVyZW50IGhhc2hpbmcgbGlicmFyeS4gVGhpcyB3YXksIG5vYmxlLWhhc2hlc1xuLy8gd29uJ3QgYmUgaW5jbHVkZWQgaW50byB0aGVpciBidW5kbGUuXG5jb25zdCBfMG4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDApO1xuY29uc3QgXzFuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgxKTtcbmNvbnN0IF8ybiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMik7XG5leHBvcnQgZnVuY3Rpb24gaXNCeXRlcyhhKSB7XG4gICAgcmV0dXJuIGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IChBcnJheUJ1ZmZlci5pc1ZpZXcoYSkgJiYgYS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFieXRlcyhpdGVtKSB7XG4gICAgaWYgKCFpc0J5dGVzKGl0ZW0pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhYm9vbCh0aXRsZSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnYm9vbGVhbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcih0aXRsZSArICcgYm9vbGVhbiBleHBlY3RlZCwgZ290ICcgKyB2YWx1ZSk7XG59XG4vLyBBcnJheSB3aGVyZSBpbmRleCAweGYwICgyNDApIGlzIG1hcHBlZCB0byBzdHJpbmcgJ2YwJ1xuY29uc3QgaGV4ZXMgPSAvKiBAX19QVVJFX18gKi8gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sIChfLCBpKSA9PiBpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbi8qKlxuICogQGV4YW1wbGUgYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKSkgLy8gJ2NhZmUwMTIzJ1xuICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuICAgIGFieXRlcyhieXRlcyk7XG4gICAgLy8gcHJlLWNhY2hpbmcgaW1wcm92ZXMgdGhlIHNwZWVkIDZ4XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IGhleGVzW2J5dGVzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb0hleFVucGFkZGVkKG51bSkge1xuICAgIGNvbnN0IGhleCA9IG51bS50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIGhleC5sZW5ndGggJiAxID8gJzAnICsgaGV4IDogaGV4O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhleFRvTnVtYmVyKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIHJldHVybiBoZXggPT09ICcnID8gXzBuIDogQmlnSW50KCcweCcgKyBoZXgpOyAvLyBCaWcgRW5kaWFuXG59XG4vLyBXZSB1c2Ugb3B0aW1pemVkIHRlY2huaXF1ZSB0byBjb252ZXJ0IGhleCBzdHJpbmcgdG8gYnl0ZSBhcnJheVxuY29uc3QgYXNjaWlzID0geyBfMDogNDgsIF85OiA1NywgQTogNjUsIEY6IDcwLCBhOiA5NywgZjogMTAyIH07XG5mdW5jdGlvbiBhc2NpaVRvQmFzZTE2KGNoKSB7XG4gICAgaWYgKGNoID49IGFzY2lpcy5fMCAmJiBjaCA8PSBhc2NpaXMuXzkpXG4gICAgICAgIHJldHVybiBjaCAtIGFzY2lpcy5fMDsgLy8gJzInID0+IDUwLTQ4XG4gICAgaWYgKGNoID49IGFzY2lpcy5BICYmIGNoIDw9IGFzY2lpcy5GKVxuICAgICAgICByZXR1cm4gY2ggLSAoYXNjaWlzLkEgLSAxMCk7IC8vICdCJyA9PiA2Ni0oNjUtMTApXG4gICAgaWYgKGNoID49IGFzY2lpcy5hICYmIGNoIDw9IGFzY2lpcy5mKVxuICAgICAgICByZXR1cm4gY2ggLSAoYXNjaWlzLmEgLSAxMCk7IC8vICdiJyA9PiA5OC0oOTctMTApXG4gICAgcmV0dXJuO1xufVxuLyoqXG4gKiBAZXhhbXBsZSBoZXhUb0J5dGVzKCdjYWZlMDEyMycpIC8vIFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb0J5dGVzKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIGNvbnN0IGhsID0gaGV4Lmxlbmd0aDtcbiAgICBjb25zdCBhbCA9IGhsIC8gMjtcbiAgICBpZiAoaGwgJSAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCB1bnBhZGRlZCBoZXggb2YgbGVuZ3RoICcgKyBobCk7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShhbCk7XG4gICAgZm9yIChsZXQgYWkgPSAwLCBoaSA9IDA7IGFpIDwgYWw7IGFpKyssIGhpICs9IDIpIHtcbiAgICAgICAgY29uc3QgbjEgPSBhc2NpaVRvQmFzZTE2KGhleC5jaGFyQ29kZUF0KGhpKSk7XG4gICAgICAgIGNvbnN0IG4yID0gYXNjaWlUb0Jhc2UxNihoZXguY2hhckNvZGVBdChoaSArIDEpKTtcbiAgICAgICAgaWYgKG4xID09PSB1bmRlZmluZWQgfHwgbjIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgY2hhciA9IGhleFtoaV0gKyBoZXhbaGkgKyAxXTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IG5vbi1oZXggY2hhcmFjdGVyIFwiJyArIGNoYXIgKyAnXCIgYXQgaW5kZXggJyArIGhpKTtcbiAgICAgICAgfVxuICAgICAgICBhcnJheVthaV0gPSBuMSAqIDE2ICsgbjI7IC8vIG11bHRpcGx5IGZpcnN0IG9jdGV0LCBlLmcuICdhMycgPT4gMTAqMTYrMyA9PiAxNjAgKyAzID0+IDE2M1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG4vLyBCRTogQmlnIEVuZGlhbiwgTEU6IExpdHRsZSBFbmRpYW5cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvTnVtYmVyQkUoYnl0ZXMpIHtcbiAgICByZXR1cm4gaGV4VG9OdW1iZXIoYnl0ZXNUb0hleChieXRlcykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9OdW1iZXJMRShieXRlcykge1xuICAgIGFieXRlcyhieXRlcyk7XG4gICAgcmV0dXJuIGhleFRvTnVtYmVyKGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKGJ5dGVzKS5yZXZlcnNlKCkpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb0J5dGVzQkUobiwgbGVuKSB7XG4gICAgcmV0dXJuIGhleFRvQnl0ZXMobi50b1N0cmluZygxNikucGFkU3RhcnQobGVuICogMiwgJzAnKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9CeXRlc0xFKG4sIGxlbikge1xuICAgIHJldHVybiBudW1iZXJUb0J5dGVzQkUobiwgbGVuKS5yZXZlcnNlKCk7XG59XG4vLyBVbnBhZGRlZCwgcmFyZWx5IHVzZWRcbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb1ZhckJ5dGVzQkUobikge1xuICAgIHJldHVybiBoZXhUb0J5dGVzKG51bWJlclRvSGV4VW5wYWRkZWQobikpO1xufVxuLyoqXG4gKiBUYWtlcyBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXksIGNvbnZlcnRzIHRvIFVpbnQ4QXJyYXkuXG4gKiBWYWxpZGF0ZXMgb3V0cHV0IGxlbmd0aC5cbiAqIFdpbGwgdGhyb3cgZXJyb3IgZm9yIG90aGVyIHR5cGVzLlxuICogQHBhcmFtIHRpdGxlIGRlc2NyaXB0aXZlIHRpdGxlIGZvciBhbiBlcnJvciBlLmcuICdwcml2YXRlIGtleSdcbiAqIEBwYXJhbSBoZXggaGV4IHN0cmluZyBvciBVaW50OEFycmF5XG4gKiBAcGFyYW0gZXhwZWN0ZWRMZW5ndGggb3B0aW9uYWwsIHdpbGwgY29tcGFyZSB0byByZXN1bHQgYXJyYXkncyBsZW5ndGhcbiAqIEByZXR1cm5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVCeXRlcyh0aXRsZSwgaGV4LCBleHBlY3RlZExlbmd0aCkge1xuICAgIGxldCByZXM7XG4gICAgaWYgKHR5cGVvZiBoZXggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXMgPSBoZXhUb0J5dGVzKGhleCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0aXRsZSArICcgbXVzdCBiZSBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXksIGNhdXNlOiAnICsgZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNCeXRlcyhoZXgpKSB7XG4gICAgICAgIC8vIFVpbnQ4QXJyYXkuZnJvbSgpIGluc3RlYWQgb2YgaGFzaC5zbGljZSgpIGJlY2F1c2Ugbm9kZS5qcyBCdWZmZXJcbiAgICAgICAgLy8gaXMgaW5zdGFuY2Ugb2YgVWludDhBcnJheSwgYW5kIGl0cyBzbGljZSgpIGNyZWF0ZXMgKiptdXRhYmxlKiogY29weVxuICAgICAgICByZXMgPSBVaW50OEFycmF5LmZyb20oaGV4KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih0aXRsZSArICcgbXVzdCBiZSBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXknKTtcbiAgICB9XG4gICAgY29uc3QgbGVuID0gcmVzLmxlbmd0aDtcbiAgICBpZiAodHlwZW9mIGV4cGVjdGVkTGVuZ3RoID09PSAnbnVtYmVyJyAmJiBsZW4gIT09IGV4cGVjdGVkTGVuZ3RoKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGl0bGUgKyAnIG9mIGxlbmd0aCAnICsgZXhwZWN0ZWRMZW5ndGggKyAnIGV4cGVjdGVkLCBnb3QgJyArIGxlbik7XG4gICAgcmV0dXJuIHJlcztcbn1cbi8qKlxuICogQ29waWVzIHNldmVyYWwgVWludDhBcnJheXMgaW50byBvbmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25jYXRCeXRlcyguLi5hcnJheXMpIHtcbiAgICBsZXQgc3VtID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhID0gYXJyYXlzW2ldO1xuICAgICAgICBhYnl0ZXMoYSk7XG4gICAgICAgIHN1bSArPSBhLmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoc3VtKTtcbiAgICBmb3IgKGxldCBpID0gMCwgcGFkID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhID0gYXJyYXlzW2ldO1xuICAgICAgICByZXMuc2V0KGEsIHBhZCk7XG4gICAgICAgIHBhZCArPSBhLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbi8vIENvbXBhcmVzIDIgdThhLXMgaW4ga2luZGEgY29uc3RhbnQgdGltZVxuZXhwb3J0IGZ1bmN0aW9uIGVxdWFsQnl0ZXMoYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgZGlmZiA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKVxuICAgICAgICBkaWZmIHw9IGFbaV0gXiBiW2ldO1xuICAgIHJldHVybiBkaWZmID09PSAwO1xufVxuLyoqXG4gKiBAZXhhbXBsZSB1dGY4VG9CeXRlcygnYWJjJykgLy8gbmV3IFVpbnQ4QXJyYXkoWzk3LCA5OCwgOTldKVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0cmluZyBleHBlY3RlZCcpO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSk7IC8vIGh0dHBzOi8vYnVnemlsLmxhLzE2ODE4MDlcbn1cbi8vIElzIHBvc2l0aXZlIGJpZ2ludFxuY29uc3QgaXNQb3NCaWcgPSAobikgPT4gdHlwZW9mIG4gPT09ICdiaWdpbnQnICYmIF8wbiA8PSBuO1xuZXhwb3J0IGZ1bmN0aW9uIGluUmFuZ2UobiwgbWluLCBtYXgpIHtcbiAgICByZXR1cm4gaXNQb3NCaWcobikgJiYgaXNQb3NCaWcobWluKSAmJiBpc1Bvc0JpZyhtYXgpICYmIG1pbiA8PSBuICYmIG4gPCBtYXg7XG59XG4vKipcbiAqIEFzc2VydHMgbWluIDw9IG4gPCBtYXguIE5PVEU6IEl0J3MgPCBtYXggYW5kIG5vdCA8PSBtYXguXG4gKiBAZXhhbXBsZVxuICogYUluUmFuZ2UoJ3gnLCB4LCAxbiwgMjU2bik7IC8vIHdvdWxkIGFzc3VtZSB4IGlzIGluICgxbi4uMjU1bilcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFJblJhbmdlKHRpdGxlLCBuLCBtaW4sIG1heCkge1xuICAgIC8vIFdoeSBtaW4gPD0gbiA8IG1heCBhbmQgbm90IGEgKG1pbiA8IG4gPCBtYXgpIE9SIGIgKG1pbiA8PSBuIDw9IG1heCk/XG4gICAgLy8gY29uc2lkZXIgUD0yNTZuLCBtaW49MG4sIG1heD1QXG4gICAgLy8gLSBhIGZvciBtaW49MCB3b3VsZCByZXF1aXJlIC0xOiAgICAgICAgICBgaW5SYW5nZSgneCcsIHgsIC0xbiwgUClgXG4gICAgLy8gLSBiIHdvdWxkIGNvbW1vbmx5IHJlcXVpcmUgc3VidHJhY3Rpb246ICBgaW5SYW5nZSgneCcsIHgsIDBuLCBQIC0gMW4pYFxuICAgIC8vIC0gb3VyIHdheSBpcyB0aGUgY2xlYW5lc3Q6ICAgICAgICAgICAgICAgYGluUmFuZ2UoJ3gnLCB4LCAwbiwgUClcbiAgICBpZiAoIWluUmFuZ2UobiwgbWluLCBtYXgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIHZhbGlkICcgKyB0aXRsZSArICc6ICcgKyBtaW4gKyAnIDw9IG4gPCAnICsgbWF4ICsgJywgZ290ICcgKyBuKTtcbn1cbi8vIEJpdCBvcGVyYXRpb25zXG4vKipcbiAqIENhbGN1bGF0ZXMgYW1vdW50IG9mIGJpdHMgaW4gYSBiaWdpbnQuXG4gKiBTYW1lIGFzIGBuLnRvU3RyaW5nKDIpLmxlbmd0aGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpdExlbihuKSB7XG4gICAgbGV0IGxlbjtcbiAgICBmb3IgKGxlbiA9IDA7IG4gPiBfMG47IG4gPj49IF8xbiwgbGVuICs9IDEpXG4gICAgICAgIDtcbiAgICByZXR1cm4gbGVuO1xufVxuLyoqXG4gKiBHZXRzIHNpbmdsZSBiaXQgYXQgcG9zaXRpb24uXG4gKiBOT1RFOiBmaXJzdCBiaXQgcG9zaXRpb24gaXMgMCAoc2FtZSBhcyBhcnJheXMpXG4gKiBTYW1lIGFzIGAhIStBcnJheS5mcm9tKG4udG9TdHJpbmcoMikpLnJldmVyc2UoKVtwb3NdYFxuICovXG5leHBvcnQgZnVuY3Rpb24gYml0R2V0KG4sIHBvcykge1xuICAgIHJldHVybiAobiA+PiBCaWdJbnQocG9zKSkgJiBfMW47XG59XG4vKipcbiAqIFNldHMgc2luZ2xlIGJpdCBhdCBwb3NpdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpdFNldChuLCBwb3MsIHZhbHVlKSB7XG4gICAgcmV0dXJuIG4gfCAoKHZhbHVlID8gXzFuIDogXzBuKSA8PCBCaWdJbnQocG9zKSk7XG59XG4vKipcbiAqIENhbGN1bGF0ZSBtYXNrIGZvciBOIGJpdHMuIE5vdCB1c2luZyAqKiBvcGVyYXRvciB3aXRoIGJpZ2ludHMgYmVjYXVzZSBvZiBvbGQgZW5naW5lcy5cbiAqIFNhbWUgYXMgQmlnSW50KGAwYiR7QXJyYXkoaSkuZmlsbCgnMScpLmpvaW4oJycpfWApXG4gKi9cbmV4cG9ydCBjb25zdCBiaXRNYXNrID0gKG4pID0+IChfMm4gPDwgQmlnSW50KG4gLSAxKSkgLSBfMW47XG4vLyBEUkJHXG5jb25zdCB1OG4gPSAoZGF0YSkgPT4gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7IC8vIGNyZWF0ZXMgVWludDhBcnJheVxuY29uc3QgdThmciA9IChhcnIpID0+IFVpbnQ4QXJyYXkuZnJvbShhcnIpOyAvLyBhbm90aGVyIHNob3J0Y3V0XG4vKipcbiAqIE1pbmltYWwgSE1BQy1EUkJHIGZyb20gTklTVCA4MDAtOTAgZm9yIFJGQzY5Nzkgc2lncy5cbiAqIEByZXR1cm5zIGZ1bmN0aW9uIHRoYXQgd2lsbCBjYWxsIERSQkcgdW50aWwgMm5kIGFyZyByZXR1cm5zIHNvbWV0aGluZyBtZWFuaW5nZnVsXG4gKiBAZXhhbXBsZVxuICogICBjb25zdCBkcmJnID0gY3JlYXRlSG1hY0RSQkc8S2V5PigzMiwgMzIsIGhtYWMpO1xuICogICBkcmJnKHNlZWQsIGJ5dGVzVG9LZXkpOyAvLyBieXRlc1RvS2V5IG11c3QgcmV0dXJuIEtleSBvciB1bmRlZmluZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUhtYWNEcmJnKGhhc2hMZW4sIHFCeXRlTGVuLCBobWFjRm4pIHtcbiAgICBpZiAodHlwZW9mIGhhc2hMZW4gIT09ICdudW1iZXInIHx8IGhhc2hMZW4gPCAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hhc2hMZW4gbXVzdCBiZSBhIG51bWJlcicpO1xuICAgIGlmICh0eXBlb2YgcUJ5dGVMZW4gIT09ICdudW1iZXInIHx8IHFCeXRlTGVuIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdxQnl0ZUxlbiBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgaWYgKHR5cGVvZiBobWFjRm4gIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaG1hY0ZuIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIC8vIFN0ZXAgQiwgU3RlcCBDOiBzZXQgaGFzaExlbiB0byA4KmNlaWwoaGxlbi84KVxuICAgIGxldCB2ID0gdThuKGhhc2hMZW4pOyAvLyBNaW5pbWFsIG5vbi1mdWxsLXNwZWMgSE1BQy1EUkJHIGZyb20gTklTVCA4MDAtOTAgZm9yIFJGQzY5Nzkgc2lncy5cbiAgICBsZXQgayA9IHU4bihoYXNoTGVuKTsgLy8gU3RlcHMgQiBhbmQgQyBvZiBSRkM2OTc5IDMuMjogc2V0IGhhc2hMZW4sIGluIG91ciBjYXNlIGFsd2F5cyBzYW1lXG4gICAgbGV0IGkgPSAwOyAvLyBJdGVyYXRpb25zIGNvdW50ZXIsIHdpbGwgdGhyb3cgd2hlbiBvdmVyIDEwMDBcbiAgICBjb25zdCByZXNldCA9ICgpID0+IHtcbiAgICAgICAgdi5maWxsKDEpO1xuICAgICAgICBrLmZpbGwoMCk7XG4gICAgICAgIGkgPSAwO1xuICAgIH07XG4gICAgY29uc3QgaCA9ICguLi5iKSA9PiBobWFjRm4oaywgdiwgLi4uYik7IC8vIGhtYWMoaykodiwgLi4udmFsdWVzKVxuICAgIGNvbnN0IHJlc2VlZCA9IChzZWVkID0gdThuKCkpID0+IHtcbiAgICAgICAgLy8gSE1BQy1EUkJHIHJlc2VlZCgpIGZ1bmN0aW9uLiBTdGVwcyBELUdcbiAgICAgICAgayA9IGgodThmcihbMHgwMF0pLCBzZWVkKTsgLy8gayA9IGhtYWMoayB8fCB2IHx8IDB4MDAgfHwgc2VlZClcbiAgICAgICAgdiA9IGgoKTsgLy8gdiA9IGhtYWMoayB8fCB2KVxuICAgICAgICBpZiAoc2VlZC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGsgPSBoKHU4ZnIoWzB4MDFdKSwgc2VlZCk7IC8vIGsgPSBobWFjKGsgfHwgdiB8fCAweDAxIHx8IHNlZWQpXG4gICAgICAgIHYgPSBoKCk7IC8vIHYgPSBobWFjKGsgfHwgdilcbiAgICB9O1xuICAgIGNvbnN0IGdlbiA9ICgpID0+IHtcbiAgICAgICAgLy8gSE1BQy1EUkJHIGdlbmVyYXRlKCkgZnVuY3Rpb25cbiAgICAgICAgaWYgKGkrKyA+PSAxMDAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkcmJnOiB0cmllZCAxMDAwIHZhbHVlcycpO1xuICAgICAgICBsZXQgbGVuID0gMDtcbiAgICAgICAgY29uc3Qgb3V0ID0gW107XG4gICAgICAgIHdoaWxlIChsZW4gPCBxQnl0ZUxlbikge1xuICAgICAgICAgICAgdiA9IGgoKTtcbiAgICAgICAgICAgIGNvbnN0IHNsID0gdi5zbGljZSgpO1xuICAgICAgICAgICAgb3V0LnB1c2goc2wpO1xuICAgICAgICAgICAgbGVuICs9IHYubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25jYXRCeXRlcyguLi5vdXQpO1xuICAgIH07XG4gICAgY29uc3QgZ2VuVW50aWwgPSAoc2VlZCwgcHJlZCkgPT4ge1xuICAgICAgICByZXNldCgpO1xuICAgICAgICByZXNlZWQoc2VlZCk7IC8vIFN0ZXBzIEQtR1xuICAgICAgICBsZXQgcmVzID0gdW5kZWZpbmVkOyAvLyBTdGVwIEg6IGdyaW5kIHVudGlsIGsgaXMgaW4gWzEuLm4tMV1cbiAgICAgICAgd2hpbGUgKCEocmVzID0gcHJlZChnZW4oKSkpKVxuICAgICAgICAgICAgcmVzZWVkKCk7XG4gICAgICAgIHJlc2V0KCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICByZXR1cm4gZ2VuVW50aWw7XG59XG4vLyBWYWxpZGF0aW5nIGN1cnZlcyBhbmQgZmllbGRzXG5jb25zdCB2YWxpZGF0b3JGbnMgPSB7XG4gICAgYmlnaW50OiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnYmlnaW50JyxcbiAgICBmdW5jdGlvbjogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyxcbiAgICBib29sZWFuOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnYm9vbGVhbicsXG4gICAgc3RyaW5nOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyxcbiAgICBzdHJpbmdPclVpbnQ4QXJyYXk6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnIHx8IGlzQnl0ZXModmFsKSxcbiAgICBpc1NhZmVJbnRlZ2VyOiAodmFsKSA9PiBOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWwpLFxuICAgIGFycmF5OiAodmFsKSA9PiBBcnJheS5pc0FycmF5KHZhbCksXG4gICAgZmllbGQ6ICh2YWwsIG9iamVjdCkgPT4gb2JqZWN0LkZwLmlzVmFsaWQodmFsKSxcbiAgICBoYXNoOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nICYmIE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbC5vdXRwdXRMZW4pLFxufTtcbi8vIHR5cGUgUmVjb3JkPEsgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXIgfCBzeW1ib2wsIFQ+ID0geyBbUCBpbiBLXTogVDsgfVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlT2JqZWN0KG9iamVjdCwgdmFsaWRhdG9ycywgb3B0VmFsaWRhdG9ycyA9IHt9KSB7XG4gICAgY29uc3QgY2hlY2tGaWVsZCA9IChmaWVsZE5hbWUsIHR5cGUsIGlzT3B0aW9uYWwpID0+IHtcbiAgICAgICAgY29uc3QgY2hlY2tWYWwgPSB2YWxpZGF0b3JGbnNbdHlwZV07XG4gICAgICAgIGlmICh0eXBlb2YgY2hlY2tWYWwgIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgdmFsaWRhdG9yIGZ1bmN0aW9uJyk7XG4gICAgICAgIGNvbnN0IHZhbCA9IG9iamVjdFtmaWVsZE5hbWVdO1xuICAgICAgICBpZiAoaXNPcHRpb25hbCAmJiB2YWwgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCFjaGVja1ZhbCh2YWwsIG9iamVjdCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGFyYW0gJyArIFN0cmluZyhmaWVsZE5hbWUpICsgJyBpcyBpbnZhbGlkLiBFeHBlY3RlZCAnICsgdHlwZSArICcsIGdvdCAnICsgdmFsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZm9yIChjb25zdCBbZmllbGROYW1lLCB0eXBlXSBvZiBPYmplY3QuZW50cmllcyh2YWxpZGF0b3JzKSlcbiAgICAgICAgY2hlY2tGaWVsZChmaWVsZE5hbWUsIHR5cGUsIGZhbHNlKTtcbiAgICBmb3IgKGNvbnN0IFtmaWVsZE5hbWUsIHR5cGVdIG9mIE9iamVjdC5lbnRyaWVzKG9wdFZhbGlkYXRvcnMpKVxuICAgICAgICBjaGVja0ZpZWxkKGZpZWxkTmFtZSwgdHlwZSwgdHJ1ZSk7XG4gICAgcmV0dXJuIG9iamVjdDtcbn1cbi8vIHZhbGlkYXRlIHR5cGUgdGVzdHNcbi8vIGNvbnN0IG86IHsgYTogbnVtYmVyOyBiOiBudW1iZXI7IGM6IG51bWJlciB9ID0geyBhOiAxLCBiOiA1LCBjOiA2IH07XG4vLyBjb25zdCB6MCA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ2lzU2FmZUludGVnZXInIH0sIHsgYzogJ2JpZ2ludCcgfSk7IC8vIE9rIVxuLy8gLy8gU2hvdWxkIGZhaWwgdHlwZS1jaGVja1xuLy8gY29uc3QgejEgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICd0bXAnIH0sIHsgYzogJ3p6JyB9KTtcbi8vIGNvbnN0IHoyID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAnaXNTYWZlSW50ZWdlcicgfSwgeyBjOiAnenonIH0pO1xuLy8gY29uc3QgejMgPSB2YWxpZGF0ZU9iamVjdChvLCB7IHRlc3Q6ICdib29sZWFuJywgejogJ2J1ZycgfSk7XG4vLyBjb25zdCB6NCA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ2Jvb2xlYW4nLCB6OiAnYnVnJyB9KTtcbi8qKlxuICogdGhyb3dzIG5vdCBpbXBsZW1lbnRlZCBlcnJvclxuICovXG5leHBvcnQgY29uc3Qgbm90SW1wbGVtZW50ZWQgPSAoKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbn07XG4vKipcbiAqIE1lbW9pemVzIChjYWNoZXMpIGNvbXB1dGF0aW9uIHJlc3VsdC5cbiAqIFVzZXMgV2Vha01hcDogdGhlIHZhbHVlIGlzIGdvaW5nIGF1dG8tY2xlYW5lZCBieSBHQyBhZnRlciBsYXN0IHJlZmVyZW5jZSBpcyByZW1vdmVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVtb2l6ZWQoZm4pIHtcbiAgICBjb25zdCBtYXAgPSBuZXcgV2Vha01hcCgpO1xuICAgIHJldHVybiAoYXJnLCAuLi5hcmdzKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbCA9IG1hcC5nZXQoYXJnKTtcbiAgICAgICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgY29uc3QgY29tcHV0ZWQgPSBmbihhcmcsIC4uLmFyZ3MpO1xuICAgICAgICBtYXAuc2V0KGFyZywgY29tcHV0ZWQpO1xuICAgICAgICByZXR1cm4gY29tcHV0ZWQ7XG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/weierstrass.js":
/*!****************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/weierstrass.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DER: () => (/* binding */ DER),\n/* harmony export */   DERErr: () => (/* binding */ DERErr),\n/* harmony export */   SWUFpSqrtRatio: () => (/* binding */ SWUFpSqrtRatio),\n/* harmony export */   mapToCurveSimpleSWU: () => (/* binding */ mapToCurveSimpleSWU),\n/* harmony export */   weierstrass: () => (/* binding */ weierstrass),\n/* harmony export */   weierstrassPoints: () => (/* binding */ weierstrassPoints)\n/* harmony export */ });\n/* harmony import */ var _curve_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curve.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/curve.js\");\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modular.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/**\n * Short Weierstrass curve methods. The formula is: y¬≤ = x¬≥ + ax + b.\n *\n * ### Design rationale for types\n *\n * * Interaction between classes from different curves should fail:\n *   `k256.Point.BASE.add(p256.Point.BASE)`\n * * For this purpose we want to use `instanceof` operator, which is fast and works during runtime\n * * Different calls of `curve()` would return different classes -\n *   `curve(params) !== curve(params)`: if somebody decided to monkey-patch their curve,\n *   it won't affect others\n *\n * TypeScript can't infer types for classes created inside a function. Classes is one instance\n * of nominative types in TypeScript and interfaces only check for shape, so it's hard to create\n * unique type for every function call.\n *\n * We can use generic types via some param, like curve opts, but that would:\n *     1. Enable interaction between `curve(params)` and `curve(params)` (curves of same params)\n *     which is hard to debug.\n *     2. Params can be generic and we can't enforce them to be constant value:\n *     if somebody creates curve from non-constant params,\n *     it would be allowed to interact with other curves with non-constant params\n *\n * @todo https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#unique-symbol\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\n\n\nfunction validateSigVerOpts(opts) {\n    if (opts.lowS !== undefined)\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abool)('lowS', opts.lowS);\n    if (opts.prehash !== undefined)\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abool)('prehash', opts.prehash);\n}\nfunction validatePointOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_1__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject(opts, {\n        a: 'field',\n        b: 'field',\n    }, {\n        allowedPrivateKeyLengths: 'array',\n        wrapPrivateKey: 'boolean',\n        isTorsionFree: 'function',\n        clearCofactor: 'function',\n        allowInfinityPoint: 'boolean',\n        fromBytes: 'function',\n        toBytes: 'function',\n    });\n    const { endo, Fp, a } = opts;\n    if (endo) {\n        if (!Fp.eql(a, Fp.ZERO)) {\n            throw new Error('invalid endomorphism, can only be defined for Koblitz curves that have a=0');\n        }\n        if (typeof endo !== 'object' ||\n            typeof endo.beta !== 'bigint' ||\n            typeof endo.splitScalar !== 'function') {\n            throw new Error('invalid endomorphism, expected beta: bigint and splitScalar: function');\n        }\n    }\n    return Object.freeze({ ...opts });\n}\nconst { bytesToNumberBE: b2n, hexToBytes: h2b } = _utils_js__WEBPACK_IMPORTED_MODULE_0__;\nclass DERErr extends Error {\n    constructor(m = '') {\n        super(m);\n    }\n}\n/**\n * ASN.1 DER encoding utilities. ASN is very complex & fragile. Format:\n *\n *     [0x30 (SEQUENCE), bytelength, 0x02 (INTEGER), intLength, R, 0x02 (INTEGER), intLength, S]\n *\n * Docs: https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/, https://luca.ntop.org/Teaching/Appunti/asn1.html\n */\nconst DER = {\n    // asn.1 DER encoding utils\n    Err: DERErr,\n    // Basic building block is TLV (Tag-Length-Value)\n    _tlv: {\n        encode: (tag, data) => {\n            const { Err: E } = DER;\n            if (tag < 0 || tag > 256)\n                throw new E('tlv.encode: wrong tag');\n            if (data.length & 1)\n                throw new E('tlv.encode: unpadded data');\n            const dataLen = data.length / 2;\n            const len = _utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToHexUnpadded(dataLen);\n            if ((len.length / 2) & 128)\n                throw new E('tlv.encode: long form length too big');\n            // length of length with long form flag\n            const lenLen = dataLen > 127 ? _utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToHexUnpadded((len.length / 2) | 128) : '';\n            const t = _utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToHexUnpadded(tag);\n            return t + lenLen + len + data;\n        },\n        // v - value, l - left bytes (unparsed)\n        decode(tag, data) {\n            const { Err: E } = DER;\n            let pos = 0;\n            if (tag < 0 || tag > 256)\n                throw new E('tlv.encode: wrong tag');\n            if (data.length < 2 || data[pos++] !== tag)\n                throw new E('tlv.decode: wrong tlv');\n            const first = data[pos++];\n            const isLong = !!(first & 128); // First bit of first length byte is flag for short/long form\n            let length = 0;\n            if (!isLong)\n                length = first;\n            else {\n                // Long form: [longFlag(1bit), lengthLength(7bit), length (BE)]\n                const lenLen = first & 127;\n                if (!lenLen)\n                    throw new E('tlv.decode(long): indefinite length not supported');\n                if (lenLen > 4)\n                    throw new E('tlv.decode(long): byte length is too big'); // this will overflow u32 in js\n                const lengthBytes = data.subarray(pos, pos + lenLen);\n                if (lengthBytes.length !== lenLen)\n                    throw new E('tlv.decode: length bytes not complete');\n                if (lengthBytes[0] === 0)\n                    throw new E('tlv.decode(long): zero leftmost byte');\n                for (const b of lengthBytes)\n                    length = (length << 8) | b;\n                pos += lenLen;\n                if (length < 128)\n                    throw new E('tlv.decode(long): not minimal encoding');\n            }\n            const v = data.subarray(pos, pos + length);\n            if (v.length !== length)\n                throw new E('tlv.decode: wrong value length');\n            return { v, l: data.subarray(pos + length) };\n        },\n    },\n    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n    // since we always use positive integers here. It must always be empty:\n    // - add zero byte if exists\n    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n    _int: {\n        encode(num) {\n            const { Err: E } = DER;\n            if (num < _0n)\n                throw new E('integer: negative integers are not allowed');\n            let hex = _utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToHexUnpadded(num);\n            // Pad with zero byte if negative flag is present\n            if (Number.parseInt(hex[0], 16) & 0b1000)\n                hex = '00' + hex;\n            if (hex.length & 1)\n                throw new E('unexpected DER parsing assertion: unpadded hex');\n            return hex;\n        },\n        decode(data) {\n            const { Err: E } = DER;\n            if (data[0] & 128)\n                throw new E('invalid signature integer: negative');\n            if (data[0] === 0x00 && !(data[1] & 128))\n                throw new E('invalid signature integer: unnecessary leading zero');\n            return b2n(data);\n        },\n    },\n    toSig(hex) {\n        // parse DER signature\n        const { Err: E, _int: int, _tlv: tlv } = DER;\n        const data = typeof hex === 'string' ? h2b(hex) : hex;\n        _utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes(data);\n        const { v: seqBytes, l: seqLeftBytes } = tlv.decode(0x30, data);\n        if (seqLeftBytes.length)\n            throw new E('invalid signature: left bytes after parsing');\n        const { v: rBytes, l: rLeftBytes } = tlv.decode(0x02, seqBytes);\n        const { v: sBytes, l: sLeftBytes } = tlv.decode(0x02, rLeftBytes);\n        if (sLeftBytes.length)\n            throw new E('invalid signature: left bytes after parsing');\n        return { r: int.decode(rBytes), s: int.decode(sBytes) };\n    },\n    hexFromSig(sig) {\n        const { _tlv: tlv, _int: int } = DER;\n        const rs = tlv.encode(0x02, int.encode(sig.r));\n        const ss = tlv.encode(0x02, int.encode(sig.s));\n        const seq = rs + ss;\n        return tlv.encode(0x30, seq);\n    },\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nfunction weierstrassPoints(opts) {\n    const CURVE = validatePointOpts(opts);\n    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n    const Fn = (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.Field)(CURVE.n, CURVE.nBitLength);\n    const toBytes = CURVE.toBytes ||\n        ((_c, point, _isCompressed) => {\n            const a = point.toAffine();\n            return _utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n        });\n    const fromBytes = CURVE.fromBytes ||\n        ((bytes) => {\n            // const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n            return { x, y };\n        });\n    /**\n     * y¬≤ = x¬≥ + ax + b: Short weierstrass curve formula\n     * @returns y¬≤\n     */\n    function weierstrassEquation(x) {\n        const { a, b } = CURVE;\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x2 * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n    }\n    // Validate whether the passed curve params are valid.\n    // We check if curve equation works for generator point.\n    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\n    // ProjectivePoint class has not been initialized yet.\n    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))\n        throw new Error('bad generator point: equation left != right');\n    // Valid group elements reside in range 1..n-1\n    function isWithinCurveOrder(num) {\n        return _utils_js__WEBPACK_IMPORTED_MODULE_0__.inRange(num, _1n, CURVE.n);\n    }\n    // Validates if priv key is valid and converts it to bigint.\n    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n    function normPrivateKeyToScalar(key) {\n        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: N } = CURVE;\n        if (lengths && typeof key !== 'bigint') {\n            if (_utils_js__WEBPACK_IMPORTED_MODULE_0__.isBytes(key))\n                key = _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToHex(key);\n            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n            if (typeof key !== 'string' || !lengths.includes(key.length))\n                throw new Error('invalid private key');\n            key = key.padStart(nByteLength * 2, '0');\n        }\n        let num;\n        try {\n            num =\n                typeof key === 'bigint'\n                    ? key\n                    : _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('private key', key, nByteLength));\n        }\n        catch (error) {\n            throw new Error('invalid private key, expected hex or ' + nByteLength + ' bytes, got ' + typeof key);\n        }\n        if (wrapPrivateKey)\n            num = (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.mod)(num, N); // disabled by default, enabled for BLS\n        _utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange('private key', num, _1n, N); // num in range [1..N-1]\n        return num;\n    }\n    function assertPrjPoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('ProjectivePoint expected');\n    }\n    // Memoized toAffine / validity check. They are heavy. Points are immutable.\n    // Converts Projective point to affine (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    // (x, y, z) ‚àã (x=x/z, y=y/z)\n    const toAffineMemo = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memoized)((p, iz) => {\n        const { px: x, py: y, pz: z } = p;\n        // Fast-path for normalized points\n        if (Fp.eql(z, Fp.ONE))\n            return { x, y };\n        const is0 = p.is0();\n        // If invZ was 0, we return zero point. However we still want to execute\n        // all operations, so we replace invZ with a random number, 1.\n        if (iz == null)\n            iz = is0 ? Fp.ONE : Fp.inv(z);\n        const ax = Fp.mul(x, iz);\n        const ay = Fp.mul(y, iz);\n        const zz = Fp.mul(z, iz);\n        if (is0)\n            return { x: Fp.ZERO, y: Fp.ZERO };\n        if (!Fp.eql(zz, Fp.ONE))\n            throw new Error('invZ was invalid');\n        return { x: ax, y: ay };\n    });\n    // NOTE: on exception this will crash 'cached' and no value will be set.\n    // Otherwise true will be return\n    const assertValidMemo = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memoized)((p) => {\n        if (p.is0()) {\n            // (0, 1, 0) aka ZERO is invalid in most contexts.\n            // In BLS, ZERO can be serialized, so we allow it.\n            // (0, 0, 0) is invalid representation of ZERO.\n            if (CURVE.allowInfinityPoint && !Fp.is0(p.py))\n                return;\n            throw new Error('bad point: ZERO');\n        }\n        // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n        const { x, y } = p.toAffine();\n        // Check if x, y are valid field elements\n        if (!Fp.isValid(x) || !Fp.isValid(y))\n            throw new Error('bad point: x or y not FE');\n        const left = Fp.sqr(y); // y¬≤\n        const right = weierstrassEquation(x); // x¬≥ + ax + b\n        if (!Fp.eql(left, right))\n            throw new Error('bad point: equation left != right');\n        if (!p.isTorsionFree())\n            throw new Error('bad point: not in prime-order subgroup');\n        return true;\n    });\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z) ‚àã (x=x/z, y=y/z)\n     * Default Point works in 2d / affine coordinates: (x, y)\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */\n    class Point {\n        constructor(px, py, pz) {\n            this.px = px;\n            this.py = py;\n            this.pz = pz;\n            if (px == null || !Fp.isValid(px))\n                throw new Error('x required');\n            if (py == null || !Fp.isValid(py))\n                throw new Error('y required');\n            if (pz == null || !Fp.isValid(pz))\n                throw new Error('z required');\n            Object.freeze(this);\n        }\n        // Does not validate if the point is on-curve.\n        // Use fromHex instead, or call assertValidity() later.\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('invalid affine point');\n            if (p instanceof Point)\n                throw new Error('projective point not allowed');\n            const is0 = (i) => Fp.eql(i, Fp.ZERO);\n            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n            if (is0(x) && is0(y))\n                return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         * Takes a bunch of Projective Points but executes only one\n         * inversion on all of them. Inversion is very slow operation,\n         * so this improves performance massively.\n         * Optimization: converts a list of projective points to a list of identical points with Z=1.\n         */\n        static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p) => p.pz));\n            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        /**\n         * Converts hash string or Uint8Array to Point.\n         * @param hex short/long ECDSA hex\n         */\n        static fromHex(hex) {\n            const P = Point.fromAffine(fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('pointHex', hex)));\n            P.assertValidity();\n            return P;\n        }\n        // Multiplies generator point by privateKey.\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n        }\n        // Multiscalar Multiplication\n        static msm(points, scalars) {\n            return (0,_curve_js__WEBPACK_IMPORTED_MODULE_1__.pippenger)(Point, Fn, points, scalars);\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            wnaf.setWindowSize(this, windowSize);\n        }\n        // A point on curve is valid if it conforms to equation.\n        assertValidity() {\n            assertValidMemo(this);\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (Fp.isOdd)\n                return !Fp.isOdd(y);\n            throw new Error(\"Field doesn't support isOdd\");\n        }\n        /**\n         * Compare one point to another.\n         */\n        equals(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /**\n         * Flips point to one corresponding to (x, -y) in Affine coordinates.\n         */\n        negate() {\n            return new Point(this.px, Fp.neg(this.py), this.pz);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, n, Point.normalizeZ);\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed private key e.g. sig verification, which works over *public* keys.\n         */\n        multiplyUnsafe(sc) {\n            const { endo, n: N } = CURVE;\n            _utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange('scalar', sc, _0n, N);\n            const I = Point.ZERO;\n            if (sc === _0n)\n                return I;\n            if (this.is0() || sc === _1n)\n                return this;\n            // Case a: no endomorphism. Case b: has precomputes.\n            if (!endo || wnaf.hasPrecomputes(this))\n                return wnaf.wNAFCachedUnsafe(this, sc, Point.normalizeZ);\n            // Case c: endomorphism\n            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(sc);\n            let k1p = I;\n            let k2p = I;\n            let d = this;\n            while (k1 > _0n || k2 > _0n) {\n                if (k1 & _1n)\n                    k1p = k1p.add(d);\n                if (k2 & _1n)\n                    k2p = k2p.add(d);\n                d = d.double();\n                k1 >>= _1n;\n                k2 >>= _1n;\n            }\n            if (k1neg)\n                k1p = k1p.negate();\n            if (k2neg)\n                k2p = k2p.negate();\n            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n            return k1p.add(k2p);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */\n        multiply(scalar) {\n            const { endo, n: N } = CURVE;\n            _utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange('scalar', scalar, _1n, N);\n            let point, fake; // Fake point is used to const-time mult\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(scalar);\n                let { p: k1p, f: f1p } = this.wNAF(k1);\n                let { p: k2p, f: f2p } = this.wNAF(k2);\n                k1p = wnaf.constTimeNegate(k1neg, k1p);\n                k2p = wnaf.constTimeNegate(k2neg, k2p);\n                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n                point = k1p.add(k2p);\n                fake = f1p.add(f2p);\n            }\n            else {\n                const { p, f } = this.wNAF(scalar);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return Point.normalizeZ([point, fake])[0];\n        }\n        /**\n         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n         * Not using Strauss-Shamir trick: precomputation tables are faster.\n         * The trick could be useful if both P and Q are not G (not in our case).\n         * @returns non-zero affine point\n         */\n        multiplyAndAddUnsafe(Q, a, b) {\n            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n            const mul = (P, a // Select faster multiply() method\n            ) => (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));\n            const sum = mul(this, a).add(mul(Q, b));\n            return sum.is0() ? undefined : sum;\n        }\n        // Converts Projective point to affine (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        // (x, y, z) ‚àã (x=x/z, y=y/z)\n        toAffine(iz) {\n            return toAffineMemo(this, iz);\n        }\n        isTorsionFree() {\n            const { h: cofactor, isTorsionFree } = CURVE;\n            if (cofactor === _1n)\n                return true; // No subgroups, always torsion-free\n            if (isTorsionFree)\n                return isTorsionFree(Point, this);\n            throw new Error('isTorsionFree() has not been declared for the elliptic curve');\n        }\n        clearCofactor() {\n            const { h: cofactor, clearCofactor } = CURVE;\n            if (cofactor === _1n)\n                return this; // Fast-path\n            if (clearCofactor)\n                return clearCofactor(Point, this);\n            return this.multiplyUnsafe(CURVE.h);\n        }\n        toRawBytes(isCompressed = true) {\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abool)('isCompressed', isCompressed);\n            this.assertValidity();\n            return toBytes(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abool)('isCompressed', isCompressed);\n            return _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToHex(this.toRawBytes(isCompressed));\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n    const _bits = CURVE.nBitLength;\n    const wnaf = (0,_curve_js__WEBPACK_IMPORTED_MODULE_1__.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n    // Validate if generator point is on curve\n    return {\n        CURVE,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar,\n        weierstrassEquation,\n        isWithinCurveOrder,\n    };\n}\nfunction validateOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_1__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject(opts, {\n        hash: 'hash',\n        hmac: 'function',\n        randomBytes: 'function',\n    }, {\n        bits2int: 'function',\n        bits2int_modN: 'function',\n        lowS: 'boolean',\n    });\n    return Object.freeze({ lowS: true, ...opts });\n}\n/**\n * Creates short weierstrass curve and ECDSA signature methods for it.\n * @example\n * import { Field } from '@noble/curves/abstract/modular';\n * // Before that, define BigInt-s: a, b, p, n, Gx, Gy\n * const curve = weierstrass({ a, b, Fp: Field(p), n, Gx, Gy, h: 1n })\n */\nfunction weierstrass(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER } = CURVE;\n    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n    function modN(a) {\n        return (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.mod)(a, CURVE_ORDER);\n    }\n    function invN(a) {\n        return (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.invert)(a, CURVE_ORDER);\n    }\n    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder, } = weierstrassPoints({\n        ...CURVE,\n        toBytes(_c, point, isCompressed) {\n            const a = point.toAffine();\n            const x = Fp.toBytes(a.x);\n            const cat = _utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes;\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abool)('isCompressed', isCompressed);\n            if (isCompressed) {\n                return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);\n            }\n            else {\n                return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));\n            }\n        },\n        fromBytes(bytes) {\n            const len = bytes.length;\n            const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // this.assertValidity() is done inside of fromHex\n            if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n                const x = _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE(tail);\n                if (!_utils_js__WEBPACK_IMPORTED_MODULE_0__.inRange(x, _1n, Fp.ORDER))\n                    throw new Error('Point is not on curve');\n                const y2 = weierstrassEquation(x); // y¬≤ = x¬≥ + ax + b\n                let y;\n                try {\n                    y = Fp.sqrt(y2); // y = y¬≤ ^ (p+1)/4\n                }\n                catch (sqrtError) {\n                    const suffix = sqrtError instanceof Error ? ': ' + sqrtError.message : '';\n                    throw new Error('Point is not on curve' + suffix);\n                }\n                const isYOdd = (y & _1n) === _1n;\n                // ECDSA\n                const isHeadOdd = (head & 1) === 1;\n                if (isHeadOdd !== isYOdd)\n                    y = Fp.neg(y);\n                return { x, y };\n            }\n            else if (len === uncompressedLen && head === 0x04) {\n                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n                return { x, y };\n            }\n            else {\n                const cl = compressedLen;\n                const ul = uncompressedLen;\n                throw new Error('invalid Point, expected length of ' + cl + ', or uncompressed ' + ul + ', got ' + len);\n            }\n        },\n    });\n    const numToNByteStr = (num) => _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToHex(_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE(num, CURVE.nByteLength));\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function normalizeS(s) {\n        return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n    }\n    // slice bytes num\n    const slcNum = (b, from, to) => _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE(b.slice(from, to));\n    /**\n     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n     */\n    class Signature {\n        constructor(r, s, recovery) {\n            this.r = r;\n            this.s = s;\n            this.recovery = recovery;\n            this.assertValidity();\n        }\n        // pair (bytes of r, bytes of s)\n        static fromCompact(hex) {\n            const l = CURVE.nByteLength;\n            hex = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('compactSignature', hex, l * 2);\n            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n        }\n        // DER encoded ECDSA signature\n        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n        static fromDER(hex) {\n            const { r, s } = DER.toSig((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('DER', hex));\n            return new Signature(r, s);\n        }\n        assertValidity() {\n            _utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange('r', this.r, _1n, CURVE_ORDER); // r in [1..N]\n            _utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange('s', this.s, _1n, CURVE_ORDER); // s in [1..N]\n        }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(msgHash) {\n            const { r, s, recovery: rec } = this;\n            const h = bits2int_modN((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('msgHash', msgHash)); // Truncate hash\n            if (rec == null || ![0, 1, 2, 3].includes(rec))\n                throw new Error('recovery id invalid');\n            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n            if (radj >= Fp.ORDER)\n                throw new Error('recovery id 2 or 3 invalid');\n            const prefix = (rec & 1) === 0 ? '02' : '03';\n            const R = Point.fromHex(prefix + numToNByteStr(radj));\n            const ir = invN(radj); // r^-1\n            const u1 = modN(-h * ir); // -hr^-1\n            const u2 = modN(s * ir); // sr^-1\n            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n            if (!Q)\n                throw new Error('point at infinify'); // unsafe is fine: no priv data leaked\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n        }\n        // DER-encoded\n        toDERRawBytes() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_0__.hexToBytes(this.toDERHex());\n        }\n        toDERHex() {\n            return DER.hexFromSig({ r: this.r, s: this.s });\n        }\n        // padded bytes of r, then padded bytes of s\n        toCompactRawBytes() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_0__.hexToBytes(this.toCompactHex());\n        }\n        toCompactHex() {\n            return numToNByteStr(this.r) + numToNByteStr(this.s);\n        }\n    }\n    const utils = {\n        isValidPrivateKey(privateKey) {\n            try {\n                normPrivateKeyToScalar(privateKey);\n                return true;\n            }\n            catch (error) {\n                return false;\n            }\n        },\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\n        /**\n         * Produces cryptographically secure private key from random of size\n         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n         */\n        randomPrivateKey: () => {\n            const length = (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.getMinHashLength)(CURVE.n);\n            return (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.mapHashToField)(CURVE.randomBytes(length), CURVE.n);\n        },\n        /**\n         * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n         * Allows to massively speed-up `point.multiply(scalar)`.\n         * @returns cached point\n         * @example\n         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n         * fast.multiply(privKey); // much faster ECDH now\n         */\n        precompute(windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n            return point;\n        },\n    };\n    /**\n     * Computes public key for a private key. Checks for validity of the private key.\n     * @param privateKey private key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */\n    function getPublicKey(privateKey, isCompressed = true) {\n        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */\n    function isProbPub(item) {\n        const arr = _utils_js__WEBPACK_IMPORTED_MODULE_0__.isBytes(item);\n        const str = typeof item === 'string';\n        const len = (arr || str) && item.length;\n        if (arr)\n            return len === compressedLen || len === uncompressedLen;\n        if (str)\n            return len === 2 * compressedLen || len === 2 * uncompressedLen;\n        if (item instanceof Point)\n            return true;\n        return false;\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from private key and public key.\n     * Checks: 1) private key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param privateA private key\n     * @param publicB different public key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */\n    function getSharedSecret(privateA, publicB, isCompressed = true) {\n        if (isProbPub(privateA))\n            throw new Error('first arg must be private key');\n        if (!isProbPub(publicB))\n            throw new Error('second arg must be public key');\n        const b = Point.fromHex(publicB); // check for being on-curve\n        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = CURVE.bits2int ||\n        function (bytes) {\n            // Our custom check \"just in case\"\n            if (bytes.length > 8192)\n                throw new Error('input is too large');\n            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n            // for some cases, since bytes.length * 8 is not actual bitLength.\n            const num = _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE(bytes); // check for == u8 done here\n            const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n            return delta > 0 ? num >> BigInt(delta) : num;\n        };\n    const bits2int_modN = CURVE.bits2int_modN ||\n        function (bytes) {\n            return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n        };\n    // NOTE: pads output with zero as per spec\n    const ORDER_MASK = _utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask(CURVE.nBitLength);\n    /**\n     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n     */\n    function int2octets(num) {\n        _utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange('num < 2^' + CURVE.nBitLength, num, _0n, ORDER_MASK);\n        // works with order, can have different size than numToField!\n        return _utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE(num, CURVE.nByteLength);\n    }\n    // Steps A, D of RFC6979 3.2\n    // Creates RFC6979 seed; converts msg/privKey to numbers.\n    // Used only in sign, not in verify.\n    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order,\n    // this will be invalid at least for P521. Also it can be bigger for P224 + SHA256\n    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n        if (['recovered', 'canonical'].some((k) => k in opts))\n            throw new Error('sign() legacy options not supported');\n        const { hash, randomBytes } = CURVE;\n        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n        if (lowS == null)\n            lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('msgHash', msgHash);\n        validateSigVerOpts(opts);\n        if (prehash)\n            msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('prehashed msgHash', hash(msgHash));\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(msgHash);\n        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n        const seedArgs = [int2octets(d), int2octets(h1int)];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (ent != null && ent !== false) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n            seedArgs.push((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('extraEntropy', e)); // check for being bytes\n        }\n        const seed = _utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n            if (!isWithinCurveOrder(k))\n                return; // Important: all mod() calls here must be done over N\n            const ik = invN(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n            const r = modN(q.x); // r = q.x mod n\n            if (r === _0n)\n                return;\n            // Can use scalar blinding b^-1(bm + bdr) where b ‚àà [1,q‚àí1] according to\n            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n            const s = modN(ik * modN(m + r * d)); // Not using blinding here\n            if (s === _0n)\n                return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = normalizeS(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return { seed, k2sig };\n    }\n    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };\n    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };\n    /**\n     * Signs message hash with a private key.\n     * ```\n     * sign(m, d, k) where\n     *   (x, y) = G √ó k\n     *   r = x mod n\n     *   s = (m + dr)/k mod n\n     * ```\n     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n     * @param privKey private key\n     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n     * @returns signature with recovery param\n     */\n    function sign(msgHash, privKey, opts = defaultSigOpts) {\n        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n        const C = CURVE;\n        const drbg = _utils_js__WEBPACK_IMPORTED_MODULE_0__.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);\n        return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    }\n    // Enable precomputes. Slows down first publicKey computation by 20ms.\n    Point.BASE._setWindowSize(8);\n    // utils.precompute(8, ProjectivePoint.BASE)\n    /**\n     * Verifies a signature against message hash and public key.\n     * Rejects lowS signatures by default: to override,\n     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   U1 = hs^-1 mod n\n     *   U2 = rs^-1 mod n\n     *   R = U1‚ãÖG - U2‚ãÖP\n     *   mod(R.x, n) == r\n     * ```\n     */\n    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n        const sg = signature;\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('msgHash', msgHash);\n        publicKey = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('publicKey', publicKey);\n        const { lowS, prehash, format } = opts;\n        // Verify opts, deduce signature format\n        validateSigVerOpts(opts);\n        if ('strict' in opts)\n            throw new Error('options.strict was renamed to lowS');\n        if (format !== undefined && format !== 'compact' && format !== 'der')\n            throw new Error('format must be compact or der');\n        const isHex = typeof sg === 'string' || _utils_js__WEBPACK_IMPORTED_MODULE_0__.isBytes(sg);\n        const isObj = !isHex &&\n            !format &&\n            typeof sg === 'object' &&\n            sg !== null &&\n            typeof sg.r === 'bigint' &&\n            typeof sg.s === 'bigint';\n        if (!isHex && !isObj)\n            throw new Error('invalid signature, expected Uint8Array, hex string or Signature instance');\n        let _sig = undefined;\n        let P;\n        try {\n            if (isObj)\n                _sig = new Signature(sg.r, sg.s);\n            if (isHex) {\n                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n                // Since DER can also be 2*nByteLength bytes, we check for it first.\n                try {\n                    if (format !== 'compact')\n                        _sig = Signature.fromDER(sg);\n                }\n                catch (derError) {\n                    if (!(derError instanceof DER.Err))\n                        throw derError;\n                }\n                if (!_sig && format !== 'der')\n                    _sig = Signature.fromCompact(sg);\n            }\n            P = Point.fromHex(publicKey);\n        }\n        catch (error) {\n            return false;\n        }\n        if (!_sig)\n            return false;\n        if (lowS && _sig.hasHighS())\n            return false;\n        if (prehash)\n            msgHash = CURVE.hash(msgHash);\n        const { r, s } = _sig;\n        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n        const is = invN(s); // s^-1\n        const u1 = modN(h * is); // u1 = hs^-1 mod n\n        const u2 = modN(r * is); // u2 = rs^-1 mod n\n        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1‚ãÖG + u2‚ãÖP\n        if (!R)\n            return false;\n        const v = modN(R.x);\n        return v === r;\n    }\n    return {\n        CURVE,\n        getPublicKey,\n        getSharedSecret,\n        sign,\n        verify,\n        ProjectivePoint: Point,\n        Signature,\n        utils,\n    };\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nfunction SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for (let o = q - _1n; o % _2n === _0n; o /= _2n)\n        l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v) => {\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for (let i = c1; i > _1n; i--) {\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return { isValid: isQR, value: tv3 };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v) => {\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */\nfunction mapToCurveSimpleSWU(Fp, opts) {\n    (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.validateField)(Fp);\n    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))\n        throw new Error('mapToCurveSimpleSWU: invalid opts');\n    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n    if (!Fp.isOdd)\n        throw new Error('Fp.isOdd is not implemented!');\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u) => {\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        x = Fp.div(x, tv4); // 25.   x = x / tv4\n        return { x, y };\n    };\n}\n//# sourceMappingURL=weierstrass.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC93ZWllcnN0cmFzcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDNkQ7QUFDdUM7QUFDbkU7QUFDeUI7QUFDMUQ7QUFDQTtBQUNBLFFBQVEsZ0RBQUs7QUFDYjtBQUNBLFFBQVEsZ0RBQUs7QUFDYjtBQUNBO0FBQ0EsaUJBQWlCLHdEQUFhO0FBQzlCLElBQUkscURBQWlCO0FBQ3JCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQSxRQUFRLHdDQUF3QyxFQUFFLHNDQUFFO0FBQzdDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMERBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQywwREFBc0I7QUFDakUsc0JBQXNCLDBEQUFzQjtBQUM1QztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Zy9HaXQvTWFkdHJpcHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L3dlaWVyc3RyYXNzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogU2hvcnQgV2VpZXJzdHJhc3MgY3VydmUgbWV0aG9kcy4gVGhlIGZvcm11bGEgaXM6IHnCsiA9IHjCsyArIGF4ICsgYi5cbiAqXG4gKiAjIyMgRGVzaWduIHJhdGlvbmFsZSBmb3IgdHlwZXNcbiAqXG4gKiAqIEludGVyYWN0aW9uIGJldHdlZW4gY2xhc3NlcyBmcm9tIGRpZmZlcmVudCBjdXJ2ZXMgc2hvdWxkIGZhaWw6XG4gKiAgIGBrMjU2LlBvaW50LkJBU0UuYWRkKHAyNTYuUG9pbnQuQkFTRSlgXG4gKiAqIEZvciB0aGlzIHB1cnBvc2Ugd2Ugd2FudCB0byB1c2UgYGluc3RhbmNlb2ZgIG9wZXJhdG9yLCB3aGljaCBpcyBmYXN0IGFuZCB3b3JrcyBkdXJpbmcgcnVudGltZVxuICogKiBEaWZmZXJlbnQgY2FsbHMgb2YgYGN1cnZlKClgIHdvdWxkIHJldHVybiBkaWZmZXJlbnQgY2xhc3NlcyAtXG4gKiAgIGBjdXJ2ZShwYXJhbXMpICE9PSBjdXJ2ZShwYXJhbXMpYDogaWYgc29tZWJvZHkgZGVjaWRlZCB0byBtb25rZXktcGF0Y2ggdGhlaXIgY3VydmUsXG4gKiAgIGl0IHdvbid0IGFmZmVjdCBvdGhlcnNcbiAqXG4gKiBUeXBlU2NyaXB0IGNhbid0IGluZmVyIHR5cGVzIGZvciBjbGFzc2VzIGNyZWF0ZWQgaW5zaWRlIGEgZnVuY3Rpb24uIENsYXNzZXMgaXMgb25lIGluc3RhbmNlXG4gKiBvZiBub21pbmF0aXZlIHR5cGVzIGluIFR5cGVTY3JpcHQgYW5kIGludGVyZmFjZXMgb25seSBjaGVjayBmb3Igc2hhcGUsIHNvIGl0J3MgaGFyZCB0byBjcmVhdGVcbiAqIHVuaXF1ZSB0eXBlIGZvciBldmVyeSBmdW5jdGlvbiBjYWxsLlxuICpcbiAqIFdlIGNhbiB1c2UgZ2VuZXJpYyB0eXBlcyB2aWEgc29tZSBwYXJhbSwgbGlrZSBjdXJ2ZSBvcHRzLCBidXQgdGhhdCB3b3VsZDpcbiAqICAgICAxLiBFbmFibGUgaW50ZXJhY3Rpb24gYmV0d2VlbiBgY3VydmUocGFyYW1zKWAgYW5kIGBjdXJ2ZShwYXJhbXMpYCAoY3VydmVzIG9mIHNhbWUgcGFyYW1zKVxuICogICAgIHdoaWNoIGlzIGhhcmQgdG8gZGVidWcuXG4gKiAgICAgMi4gUGFyYW1zIGNhbiBiZSBnZW5lcmljIGFuZCB3ZSBjYW4ndCBlbmZvcmNlIHRoZW0gdG8gYmUgY29uc3RhbnQgdmFsdWU6XG4gKiAgICAgaWYgc29tZWJvZHkgY3JlYXRlcyBjdXJ2ZSBmcm9tIG5vbi1jb25zdGFudCBwYXJhbXMsXG4gKiAgICAgaXQgd291bGQgYmUgYWxsb3dlZCB0byBpbnRlcmFjdCB3aXRoIG90aGVyIGN1cnZlcyB3aXRoIG5vbi1jb25zdGFudCBwYXJhbXNcbiAqXG4gKiBAdG9kbyBodHRwczovL3d3dy50eXBlc2NyaXB0bGFuZy5vcmcvZG9jcy9oYW5kYm9vay9yZWxlYXNlLW5vdGVzL3R5cGVzY3JpcHQtMi03Lmh0bWwjdW5pcXVlLXN5bWJvbFxuICogQG1vZHVsZVxuICovXG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5pbXBvcnQgeyBwaXBwZW5nZXIsIHZhbGlkYXRlQmFzaWMsIHdOQUYsIH0gZnJvbSAnLi9jdXJ2ZS5qcyc7XG5pbXBvcnQgeyBGaWVsZCwgZ2V0TWluSGFzaExlbmd0aCwgaW52ZXJ0LCBtYXBIYXNoVG9GaWVsZCwgbW9kLCB2YWxpZGF0ZUZpZWxkLCB9IGZyb20gJy4vbW9kdWxhci5qcyc7XG5pbXBvcnQgKiBhcyB1dCBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7IGFib29sLCBlbnN1cmVCeXRlcywgbWVtb2l6ZWQgfSBmcm9tICcuL3V0aWxzLmpzJztcbmZ1bmN0aW9uIHZhbGlkYXRlU2lnVmVyT3B0cyhvcHRzKSB7XG4gICAgaWYgKG9wdHMubG93UyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICBhYm9vbCgnbG93UycsIG9wdHMubG93Uyk7XG4gICAgaWYgKG9wdHMucHJlaGFzaCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICBhYm9vbCgncHJlaGFzaCcsIG9wdHMucHJlaGFzaCk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVBvaW50T3B0cyhjdXJ2ZSkge1xuICAgIGNvbnN0IG9wdHMgPSB2YWxpZGF0ZUJhc2ljKGN1cnZlKTtcbiAgICB1dC52YWxpZGF0ZU9iamVjdChvcHRzLCB7XG4gICAgICAgIGE6ICdmaWVsZCcsXG4gICAgICAgIGI6ICdmaWVsZCcsXG4gICAgfSwge1xuICAgICAgICBhbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHM6ICdhcnJheScsXG4gICAgICAgIHdyYXBQcml2YXRlS2V5OiAnYm9vbGVhbicsXG4gICAgICAgIGlzVG9yc2lvbkZyZWU6ICdmdW5jdGlvbicsXG4gICAgICAgIGNsZWFyQ29mYWN0b3I6ICdmdW5jdGlvbicsXG4gICAgICAgIGFsbG93SW5maW5pdHlQb2ludDogJ2Jvb2xlYW4nLFxuICAgICAgICBmcm9tQnl0ZXM6ICdmdW5jdGlvbicsXG4gICAgICAgIHRvQnl0ZXM6ICdmdW5jdGlvbicsXG4gICAgfSk7XG4gICAgY29uc3QgeyBlbmRvLCBGcCwgYSB9ID0gb3B0cztcbiAgICBpZiAoZW5kbykge1xuICAgICAgICBpZiAoIUZwLmVxbChhLCBGcC5aRVJPKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGVuZG9tb3JwaGlzbSwgY2FuIG9ubHkgYmUgZGVmaW5lZCBmb3IgS29ibGl0eiBjdXJ2ZXMgdGhhdCBoYXZlIGE9MCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZW5kbyAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgICAgIHR5cGVvZiBlbmRvLmJldGEgIT09ICdiaWdpbnQnIHx8XG4gICAgICAgICAgICB0eXBlb2YgZW5kby5zcGxpdFNjYWxhciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGVuZG9tb3JwaGlzbSwgZXhwZWN0ZWQgYmV0YTogYmlnaW50IGFuZCBzcGxpdFNjYWxhcjogZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IC4uLm9wdHMgfSk7XG59XG5jb25zdCB7IGJ5dGVzVG9OdW1iZXJCRTogYjJuLCBoZXhUb0J5dGVzOiBoMmIgfSA9IHV0O1xuZXhwb3J0IGNsYXNzIERFUkVyciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtID0gJycpIHtcbiAgICAgICAgc3VwZXIobSk7XG4gICAgfVxufVxuLyoqXG4gKiBBU04uMSBERVIgZW5jb2RpbmcgdXRpbGl0aWVzLiBBU04gaXMgdmVyeSBjb21wbGV4ICYgZnJhZ2lsZS4gRm9ybWF0OlxuICpcbiAqICAgICBbMHgzMCAoU0VRVUVOQ0UpLCBieXRlbGVuZ3RoLCAweDAyIChJTlRFR0VSKSwgaW50TGVuZ3RoLCBSLCAweDAyIChJTlRFR0VSKSwgaW50TGVuZ3RoLCBTXVxuICpcbiAqIERvY3M6IGh0dHBzOi8vbGV0c2VuY3J5cHQub3JnL2RvY3MvYS13YXJtLXdlbGNvbWUtdG8tYXNuMS1hbmQtZGVyLywgaHR0cHM6Ly9sdWNhLm50b3Aub3JnL1RlYWNoaW5nL0FwcHVudGkvYXNuMS5odG1sXG4gKi9cbmV4cG9ydCBjb25zdCBERVIgPSB7XG4gICAgLy8gYXNuLjEgREVSIGVuY29kaW5nIHV0aWxzXG4gICAgRXJyOiBERVJFcnIsXG4gICAgLy8gQmFzaWMgYnVpbGRpbmcgYmxvY2sgaXMgVExWIChUYWctTGVuZ3RoLVZhbHVlKVxuICAgIF90bHY6IHtcbiAgICAgICAgZW5jb2RlOiAodGFnLCBkYXRhKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IEVycjogRSB9ID0gREVSO1xuICAgICAgICAgICAgaWYgKHRhZyA8IDAgfHwgdGFnID4gMjU2KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd0bHYuZW5jb2RlOiB3cm9uZyB0YWcnKTtcbiAgICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCAmIDEpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5lbmNvZGU6IHVucGFkZGVkIGRhdGEnKTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFMZW4gPSBkYXRhLmxlbmd0aCAvIDI7XG4gICAgICAgICAgICBjb25zdCBsZW4gPSB1dC5udW1iZXJUb0hleFVucGFkZGVkKGRhdGFMZW4pO1xuICAgICAgICAgICAgaWYgKChsZW4ubGVuZ3RoIC8gMikgJiAxMjgpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5lbmNvZGU6IGxvbmcgZm9ybSBsZW5ndGggdG9vIGJpZycpO1xuICAgICAgICAgICAgLy8gbGVuZ3RoIG9mIGxlbmd0aCB3aXRoIGxvbmcgZm9ybSBmbGFnXG4gICAgICAgICAgICBjb25zdCBsZW5MZW4gPSBkYXRhTGVuID4gMTI3ID8gdXQubnVtYmVyVG9IZXhVbnBhZGRlZCgobGVuLmxlbmd0aCAvIDIpIHwgMTI4KSA6ICcnO1xuICAgICAgICAgICAgY29uc3QgdCA9IHV0Lm51bWJlclRvSGV4VW5wYWRkZWQodGFnKTtcbiAgICAgICAgICAgIHJldHVybiB0ICsgbGVuTGVuICsgbGVuICsgZGF0YTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gdiAtIHZhbHVlLCBsIC0gbGVmdCBieXRlcyAodW5wYXJzZWQpXG4gICAgICAgIGRlY29kZSh0YWcsIGRhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgRXJyOiBFIH0gPSBERVI7XG4gICAgICAgICAgICBsZXQgcG9zID0gMDtcbiAgICAgICAgICAgIGlmICh0YWcgPCAwIHx8IHRhZyA+IDI1NilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmVuY29kZTogd3JvbmcgdGFnJyk7XG4gICAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggPCAyIHx8IGRhdGFbcG9zKytdICE9PSB0YWcpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5kZWNvZGU6IHdyb25nIHRsdicpO1xuICAgICAgICAgICAgY29uc3QgZmlyc3QgPSBkYXRhW3BvcysrXTtcbiAgICAgICAgICAgIGNvbnN0IGlzTG9uZyA9ICEhKGZpcnN0ICYgMTI4KTsgLy8gRmlyc3QgYml0IG9mIGZpcnN0IGxlbmd0aCBieXRlIGlzIGZsYWcgZm9yIHNob3J0L2xvbmcgZm9ybVxuICAgICAgICAgICAgbGV0IGxlbmd0aCA9IDA7XG4gICAgICAgICAgICBpZiAoIWlzTG9uZylcbiAgICAgICAgICAgICAgICBsZW5ndGggPSBmaXJzdDtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIExvbmcgZm9ybTogW2xvbmdGbGFnKDFiaXQpLCBsZW5ndGhMZW5ndGgoN2JpdCksIGxlbmd0aCAoQkUpXVxuICAgICAgICAgICAgICAgIGNvbnN0IGxlbkxlbiA9IGZpcnN0ICYgMTI3O1xuICAgICAgICAgICAgICAgIGlmICghbGVuTGVuKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmRlY29kZShsb25nKTogaW5kZWZpbml0ZSBsZW5ndGggbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgICAgIGlmIChsZW5MZW4gPiA0KVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmRlY29kZShsb25nKTogYnl0ZSBsZW5ndGggaXMgdG9vIGJpZycpOyAvLyB0aGlzIHdpbGwgb3ZlcmZsb3cgdTMyIGluIGpzXG4gICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoQnl0ZXMgPSBkYXRhLnN1YmFycmF5KHBvcywgcG9zICsgbGVuTGVuKTtcbiAgICAgICAgICAgICAgICBpZiAobGVuZ3RoQnl0ZXMubGVuZ3RoICE9PSBsZW5MZW4pXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd0bHYuZGVjb2RlOiBsZW5ndGggYnl0ZXMgbm90IGNvbXBsZXRlJyk7XG4gICAgICAgICAgICAgICAgaWYgKGxlbmd0aEJ5dGVzWzBdID09PSAwKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmRlY29kZShsb25nKTogemVybyBsZWZ0bW9zdCBieXRlJyk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBiIG9mIGxlbmd0aEJ5dGVzKVxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSAobGVuZ3RoIDw8IDgpIHwgYjtcbiAgICAgICAgICAgICAgICBwb3MgKz0gbGVuTGVuO1xuICAgICAgICAgICAgICAgIGlmIChsZW5ndGggPCAxMjgpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd0bHYuZGVjb2RlKGxvbmcpOiBub3QgbWluaW1hbCBlbmNvZGluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdiA9IGRhdGEuc3ViYXJyYXkocG9zLCBwb3MgKyBsZW5ndGgpO1xuICAgICAgICAgICAgaWYgKHYubGVuZ3RoICE9PSBsZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5kZWNvZGU6IHdyb25nIHZhbHVlIGxlbmd0aCcpO1xuICAgICAgICAgICAgcmV0dXJuIHsgdiwgbDogZGF0YS5zdWJhcnJheShwb3MgKyBsZW5ndGgpIH07XG4gICAgICAgIH0sXG4gICAgfSxcbiAgICAvLyBodHRwczovL2NyeXB0by5zdGFja2V4Y2hhbmdlLmNvbS9hLzU3NzM0IExlZnRtb3N0IGJpdCBvZiBmaXJzdCBieXRlIGlzICduZWdhdGl2ZScgZmxhZyxcbiAgICAvLyBzaW5jZSB3ZSBhbHdheXMgdXNlIHBvc2l0aXZlIGludGVnZXJzIGhlcmUuIEl0IG11c3QgYWx3YXlzIGJlIGVtcHR5OlxuICAgIC8vIC0gYWRkIHplcm8gYnl0ZSBpZiBleGlzdHNcbiAgICAvLyAtIGlmIG5leHQgYnl0ZSBkb2Vzbid0IGhhdmUgYSBmbGFnLCBsZWFkaW5nIHplcm8gaXMgbm90IGFsbG93ZWQgKG1pbmltYWwgZW5jb2RpbmcpXG4gICAgX2ludDoge1xuICAgICAgICBlbmNvZGUobnVtKSB7XG4gICAgICAgICAgICBjb25zdCB7IEVycjogRSB9ID0gREVSO1xuICAgICAgICAgICAgaWYgKG51bSA8IF8wbilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgnaW50ZWdlcjogbmVnYXRpdmUgaW50ZWdlcnMgYXJlIG5vdCBhbGxvd2VkJyk7XG4gICAgICAgICAgICBsZXQgaGV4ID0gdXQubnVtYmVyVG9IZXhVbnBhZGRlZChudW0pO1xuICAgICAgICAgICAgLy8gUGFkIHdpdGggemVybyBieXRlIGlmIG5lZ2F0aXZlIGZsYWcgaXMgcHJlc2VudFxuICAgICAgICAgICAgaWYgKE51bWJlci5wYXJzZUludChoZXhbMF0sIDE2KSAmIDBiMTAwMClcbiAgICAgICAgICAgICAgICBoZXggPSAnMDAnICsgaGV4O1xuICAgICAgICAgICAgaWYgKGhleC5sZW5ndGggJiAxKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd1bmV4cGVjdGVkIERFUiBwYXJzaW5nIGFzc2VydGlvbjogdW5wYWRkZWQgaGV4Jyk7XG4gICAgICAgICAgICByZXR1cm4gaGV4O1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGUoZGF0YSkge1xuICAgICAgICAgICAgY29uc3QgeyBFcnI6IEUgfSA9IERFUjtcbiAgICAgICAgICAgIGlmIChkYXRhWzBdICYgMTI4KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCdpbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiBuZWdhdGl2ZScpO1xuICAgICAgICAgICAgaWYgKGRhdGFbMF0gPT09IDB4MDAgJiYgIShkYXRhWzFdICYgMTI4KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgnaW52YWxpZCBzaWduYXR1cmUgaW50ZWdlcjogdW5uZWNlc3NhcnkgbGVhZGluZyB6ZXJvJyk7XG4gICAgICAgICAgICByZXR1cm4gYjJuKGRhdGEpO1xuICAgICAgICB9LFxuICAgIH0sXG4gICAgdG9TaWcoaGV4KSB7XG4gICAgICAgIC8vIHBhcnNlIERFUiBzaWduYXR1cmVcbiAgICAgICAgY29uc3QgeyBFcnI6IEUsIF9pbnQ6IGludCwgX3RsdjogdGx2IH0gPSBERVI7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0eXBlb2YgaGV4ID09PSAnc3RyaW5nJyA/IGgyYihoZXgpIDogaGV4O1xuICAgICAgICB1dC5hYnl0ZXMoZGF0YSk7XG4gICAgICAgIGNvbnN0IHsgdjogc2VxQnl0ZXMsIGw6IHNlcUxlZnRCeXRlcyB9ID0gdGx2LmRlY29kZSgweDMwLCBkYXRhKTtcbiAgICAgICAgaWYgKHNlcUxlZnRCeXRlcy5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnaW52YWxpZCBzaWduYXR1cmU6IGxlZnQgYnl0ZXMgYWZ0ZXIgcGFyc2luZycpO1xuICAgICAgICBjb25zdCB7IHY6IHJCeXRlcywgbDogckxlZnRCeXRlcyB9ID0gdGx2LmRlY29kZSgweDAyLCBzZXFCeXRlcyk7XG4gICAgICAgIGNvbnN0IHsgdjogc0J5dGVzLCBsOiBzTGVmdEJ5dGVzIH0gPSB0bHYuZGVjb2RlKDB4MDIsIHJMZWZ0Qnl0ZXMpO1xuICAgICAgICBpZiAoc0xlZnRCeXRlcy5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnaW52YWxpZCBzaWduYXR1cmU6IGxlZnQgYnl0ZXMgYWZ0ZXIgcGFyc2luZycpO1xuICAgICAgICByZXR1cm4geyByOiBpbnQuZGVjb2RlKHJCeXRlcyksIHM6IGludC5kZWNvZGUoc0J5dGVzKSB9O1xuICAgIH0sXG4gICAgaGV4RnJvbVNpZyhzaWcpIHtcbiAgICAgICAgY29uc3QgeyBfdGx2OiB0bHYsIF9pbnQ6IGludCB9ID0gREVSO1xuICAgICAgICBjb25zdCBycyA9IHRsdi5lbmNvZGUoMHgwMiwgaW50LmVuY29kZShzaWcucikpO1xuICAgICAgICBjb25zdCBzcyA9IHRsdi5lbmNvZGUoMHgwMiwgaW50LmVuY29kZShzaWcucykpO1xuICAgICAgICBjb25zdCBzZXEgPSBycyArIHNzO1xuICAgICAgICByZXR1cm4gdGx2LmVuY29kZSgweDMwLCBzZXEpO1xuICAgIH0sXG59O1xuLy8gQmUgZnJpZW5kbHkgdG8gYmFkIEVDTUFTY3JpcHQgcGFyc2VycyBieSBub3QgdXNpbmcgYmlnaW50IGxpdGVyYWxzXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKSwgXzFuID0gQmlnSW50KDEpLCBfMm4gPSBCaWdJbnQoMiksIF8zbiA9IEJpZ0ludCgzKSwgXzRuID0gQmlnSW50KDQpO1xuZXhwb3J0IGZ1bmN0aW9uIHdlaWVyc3RyYXNzUG9pbnRzKG9wdHMpIHtcbiAgICBjb25zdCBDVVJWRSA9IHZhbGlkYXRlUG9pbnRPcHRzKG9wdHMpO1xuICAgIGNvbnN0IHsgRnAgfSA9IENVUlZFOyAvLyBBbGwgY3VydmVzIGhhcyBzYW1lIGZpZWxkIC8gZ3JvdXAgbGVuZ3RoIGFzIGZvciBub3csIGJ1dCB0aGV5IGNhbiBkaWZmZXJcbiAgICBjb25zdCBGbiA9IEZpZWxkKENVUlZFLm4sIENVUlZFLm5CaXRMZW5ndGgpO1xuICAgIGNvbnN0IHRvQnl0ZXMgPSBDVVJWRS50b0J5dGVzIHx8XG4gICAgICAgICgoX2MsIHBvaW50LCBfaXNDb21wcmVzc2VkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhID0gcG9pbnQudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIHJldHVybiB1dC5jb25jYXRCeXRlcyhVaW50OEFycmF5LmZyb20oWzB4MDRdKSwgRnAudG9CeXRlcyhhLngpLCBGcC50b0J5dGVzKGEueSkpO1xuICAgICAgICB9KTtcbiAgICBjb25zdCBmcm9tQnl0ZXMgPSBDVVJWRS5mcm9tQnl0ZXMgfHxcbiAgICAgICAgKChieXRlcykgPT4ge1xuICAgICAgICAgICAgLy8gY29uc3QgaGVhZCA9IGJ5dGVzWzBdO1xuICAgICAgICAgICAgY29uc3QgdGFpbCA9IGJ5dGVzLnN1YmFycmF5KDEpO1xuICAgICAgICAgICAgLy8gaWYgKGhlYWQgIT09IDB4MDQpIHRocm93IG5ldyBFcnJvcignT25seSBub24tY29tcHJlc3NlZCBlbmNvZGluZyBpcyBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgIGNvbnN0IHggPSBGcC5mcm9tQnl0ZXModGFpbC5zdWJhcnJheSgwLCBGcC5CWVRFUykpO1xuICAgICAgICAgICAgY29uc3QgeSA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KEZwLkJZVEVTLCAyICogRnAuQllURVMpKTtcbiAgICAgICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICAgICAgfSk7XG4gICAgLyoqXG4gICAgICogecKyID0geMKzICsgYXggKyBiOiBTaG9ydCB3ZWllcnN0cmFzcyBjdXJ2ZSBmb3JtdWxhXG4gICAgICogQHJldHVybnMgecKyXG4gICAgICovXG4gICAgZnVuY3Rpb24gd2VpZXJzdHJhc3NFcXVhdGlvbih4KSB7XG4gICAgICAgIGNvbnN0IHsgYSwgYiB9ID0gQ1VSVkU7XG4gICAgICAgIGNvbnN0IHgyID0gRnAuc3FyKHgpOyAvLyB4ICogeFxuICAgICAgICBjb25zdCB4MyA9IEZwLm11bCh4MiwgeCk7IC8vIHgyICogeFxuICAgICAgICByZXR1cm4gRnAuYWRkKEZwLmFkZCh4MywgRnAubXVsKHgsIGEpKSwgYik7IC8vIHgzICsgYSAqIHggKyBiXG4gICAgfVxuICAgIC8vIFZhbGlkYXRlIHdoZXRoZXIgdGhlIHBhc3NlZCBjdXJ2ZSBwYXJhbXMgYXJlIHZhbGlkLlxuICAgIC8vIFdlIGNoZWNrIGlmIGN1cnZlIGVxdWF0aW9uIHdvcmtzIGZvciBnZW5lcmF0b3IgcG9pbnQuXG4gICAgLy8gYGFzc2VydFZhbGlkaXR5KClgIHdvbid0IHdvcms6IGBpc1RvcnNpb25GcmVlKClgIGlzIG5vdCBhdmFpbGFibGUgYXQgdGhpcyBwb2ludCBpbiBibHMxMi0zODEuXG4gICAgLy8gUHJvamVjdGl2ZVBvaW50IGNsYXNzIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXQuXG4gICAgaWYgKCFGcC5lcWwoRnAuc3FyKENVUlZFLkd5KSwgd2VpZXJzdHJhc3NFcXVhdGlvbihDVVJWRS5HeCkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBnZW5lcmF0b3IgcG9pbnQ6IGVxdWF0aW9uIGxlZnQgIT0gcmlnaHQnKTtcbiAgICAvLyBWYWxpZCBncm91cCBlbGVtZW50cyByZXNpZGUgaW4gcmFuZ2UgMS4ubi0xXG4gICAgZnVuY3Rpb24gaXNXaXRoaW5DdXJ2ZU9yZGVyKG51bSkge1xuICAgICAgICByZXR1cm4gdXQuaW5SYW5nZShudW0sIF8xbiwgQ1VSVkUubik7XG4gICAgfVxuICAgIC8vIFZhbGlkYXRlcyBpZiBwcml2IGtleSBpcyB2YWxpZCBhbmQgY29udmVydHMgaXQgdG8gYmlnaW50LlxuICAgIC8vIFN1cHBvcnRzIG9wdGlvbnMgYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzIGFuZCB3cmFwUHJpdmF0ZUtleS5cbiAgICBmdW5jdGlvbiBub3JtUHJpdmF0ZUtleVRvU2NhbGFyKGtleSkge1xuICAgICAgICBjb25zdCB7IGFsbG93ZWRQcml2YXRlS2V5TGVuZ3RoczogbGVuZ3RocywgbkJ5dGVMZW5ndGgsIHdyYXBQcml2YXRlS2V5LCBuOiBOIH0gPSBDVVJWRTtcbiAgICAgICAgaWYgKGxlbmd0aHMgJiYgdHlwZW9mIGtleSAhPT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgIGlmICh1dC5pc0J5dGVzKGtleSkpXG4gICAgICAgICAgICAgICAga2V5ID0gdXQuYnl0ZXNUb0hleChrZXkpO1xuICAgICAgICAgICAgLy8gTm9ybWFsaXplIHRvIGhleCBzdHJpbmcsIHBhZC4gRS5nLiBQNTIxIHdvdWxkIG5vcm0gMTMwLTEzMiBjaGFyIGhleCB0byAxMzItY2hhciBieXRlc1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnIHx8ICFsZW5ndGhzLmluY2x1ZGVzKGtleS5sZW5ndGgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwcml2YXRlIGtleScpO1xuICAgICAgICAgICAga2V5ID0ga2V5LnBhZFN0YXJ0KG5CeXRlTGVuZ3RoICogMiwgJzAnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbnVtO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbnVtID1cbiAgICAgICAgICAgICAgICB0eXBlb2Yga2V5ID09PSAnYmlnaW50J1xuICAgICAgICAgICAgICAgICAgICA/IGtleVxuICAgICAgICAgICAgICAgICAgICA6IHV0LmJ5dGVzVG9OdW1iZXJCRShlbnN1cmVCeXRlcygncHJpdmF0ZSBrZXknLCBrZXksIG5CeXRlTGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcHJpdmF0ZSBrZXksIGV4cGVjdGVkIGhleCBvciAnICsgbkJ5dGVMZW5ndGggKyAnIGJ5dGVzLCBnb3QgJyArIHR5cGVvZiBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3cmFwUHJpdmF0ZUtleSlcbiAgICAgICAgICAgIG51bSA9IG1vZChudW0sIE4pOyAvLyBkaXNhYmxlZCBieSBkZWZhdWx0LCBlbmFibGVkIGZvciBCTFNcbiAgICAgICAgdXQuYUluUmFuZ2UoJ3ByaXZhdGUga2V5JywgbnVtLCBfMW4sIE4pOyAvLyBudW0gaW4gcmFuZ2UgWzEuLk4tMV1cbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXNzZXJ0UHJqUG9pbnQob3RoZXIpIHtcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBQb2ludCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb2plY3RpdmVQb2ludCBleHBlY3RlZCcpO1xuICAgIH1cbiAgICAvLyBNZW1vaXplZCB0b0FmZmluZSAvIHZhbGlkaXR5IGNoZWNrLiBUaGV5IGFyZSBoZWF2eS4gUG9pbnRzIGFyZSBpbW11dGFibGUuXG4gICAgLy8gQ29udmVydHMgUHJvamVjdGl2ZSBwb2ludCB0byBhZmZpbmUgKHgsIHkpIGNvb3JkaW5hdGVzLlxuICAgIC8vIENhbiBhY2NlcHQgcHJlY29tcHV0ZWQgWl4tMSAtIGZvciBleGFtcGxlLCBmcm9tIGludmVydEJhdGNoLlxuICAgIC8vICh4LCB5LCB6KSDiiIsgKHg9eC96LCB5PXkveilcbiAgICBjb25zdCB0b0FmZmluZU1lbW8gPSBtZW1vaXplZCgocCwgaXopID0+IHtcbiAgICAgICAgY29uc3QgeyBweDogeCwgcHk6IHksIHB6OiB6IH0gPSBwO1xuICAgICAgICAvLyBGYXN0LXBhdGggZm9yIG5vcm1hbGl6ZWQgcG9pbnRzXG4gICAgICAgIGlmIChGcC5lcWwoeiwgRnAuT05FKSlcbiAgICAgICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICAgICAgY29uc3QgaXMwID0gcC5pczAoKTtcbiAgICAgICAgLy8gSWYgaW52WiB3YXMgMCwgd2UgcmV0dXJuIHplcm8gcG9pbnQuIEhvd2V2ZXIgd2Ugc3RpbGwgd2FudCB0byBleGVjdXRlXG4gICAgICAgIC8vIGFsbCBvcGVyYXRpb25zLCBzbyB3ZSByZXBsYWNlIGludlogd2l0aCBhIHJhbmRvbSBudW1iZXIsIDEuXG4gICAgICAgIGlmIChpeiA9PSBudWxsKVxuICAgICAgICAgICAgaXogPSBpczAgPyBGcC5PTkUgOiBGcC5pbnYoeik7XG4gICAgICAgIGNvbnN0IGF4ID0gRnAubXVsKHgsIGl6KTtcbiAgICAgICAgY29uc3QgYXkgPSBGcC5tdWwoeSwgaXopO1xuICAgICAgICBjb25zdCB6eiA9IEZwLm11bCh6LCBpeik7XG4gICAgICAgIGlmIChpczApXG4gICAgICAgICAgICByZXR1cm4geyB4OiBGcC5aRVJPLCB5OiBGcC5aRVJPIH07XG4gICAgICAgIGlmICghRnAuZXFsKHp6LCBGcC5PTkUpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZaIHdhcyBpbnZhbGlkJyk7XG4gICAgICAgIHJldHVybiB7IHg6IGF4LCB5OiBheSB9O1xuICAgIH0pO1xuICAgIC8vIE5PVEU6IG9uIGV4Y2VwdGlvbiB0aGlzIHdpbGwgY3Jhc2ggJ2NhY2hlZCcgYW5kIG5vIHZhbHVlIHdpbGwgYmUgc2V0LlxuICAgIC8vIE90aGVyd2lzZSB0cnVlIHdpbGwgYmUgcmV0dXJuXG4gICAgY29uc3QgYXNzZXJ0VmFsaWRNZW1vID0gbWVtb2l6ZWQoKHApID0+IHtcbiAgICAgICAgaWYgKHAuaXMwKCkpIHtcbiAgICAgICAgICAgIC8vICgwLCAxLCAwKSBha2EgWkVSTyBpcyBpbnZhbGlkIGluIG1vc3QgY29udGV4dHMuXG4gICAgICAgICAgICAvLyBJbiBCTFMsIFpFUk8gY2FuIGJlIHNlcmlhbGl6ZWQsIHNvIHdlIGFsbG93IGl0LlxuICAgICAgICAgICAgLy8gKDAsIDAsIDApIGlzIGludmFsaWQgcmVwcmVzZW50YXRpb24gb2YgWkVSTy5cbiAgICAgICAgICAgIGlmIChDVVJWRS5hbGxvd0luZmluaXR5UG9pbnQgJiYgIUZwLmlzMChwLnB5KSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogWkVSTycpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNvbWUgM3JkLXBhcnR5IHRlc3QgdmVjdG9ycyByZXF1aXJlIGRpZmZlcmVudCB3b3JkaW5nIGJldHdlZW4gaGVyZSAmIGBmcm9tQ29tcHJlc3NlZEhleGBcbiAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBwLnRvQWZmaW5lKCk7XG4gICAgICAgIC8vIENoZWNrIGlmIHgsIHkgYXJlIHZhbGlkIGZpZWxkIGVsZW1lbnRzXG4gICAgICAgIGlmICghRnAuaXNWYWxpZCh4KSB8fCAhRnAuaXNWYWxpZCh5KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiB4IG9yIHkgbm90IEZFJyk7XG4gICAgICAgIGNvbnN0IGxlZnQgPSBGcC5zcXIoeSk7IC8vIHnCslxuICAgICAgICBjb25zdCByaWdodCA9IHdlaWVyc3RyYXNzRXF1YXRpb24oeCk7IC8vIHjCsyArIGF4ICsgYlxuICAgICAgICBpZiAoIUZwLmVxbChsZWZ0LCByaWdodCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogZXF1YXRpb24gbGVmdCAhPSByaWdodCcpO1xuICAgICAgICBpZiAoIXAuaXNUb3JzaW9uRnJlZSgpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IG5vdCBpbiBwcmltZS1vcmRlciBzdWJncm91cCcpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBQcm9qZWN0aXZlIFBvaW50IHdvcmtzIGluIDNkIC8gcHJvamVjdGl2ZSAoaG9tb2dlbmVvdXMpIGNvb3JkaW5hdGVzOiAoeCwgeSwgeikg4oiLICh4PXgveiwgeT15L3opXG4gICAgICogRGVmYXVsdCBQb2ludCB3b3JrcyBpbiAyZCAvIGFmZmluZSBjb29yZGluYXRlczogKHgsIHkpXG4gICAgICogV2UncmUgZG9pbmcgY2FsY3VsYXRpb25zIGluIHByb2plY3RpdmUsIGJlY2F1c2UgaXRzIG9wZXJhdGlvbnMgZG9uJ3QgcmVxdWlyZSBjb3N0bHkgaW52ZXJzaW9uLlxuICAgICAqL1xuICAgIGNsYXNzIFBvaW50IHtcbiAgICAgICAgY29uc3RydWN0b3IocHgsIHB5LCBweikge1xuICAgICAgICAgICAgdGhpcy5weCA9IHB4O1xuICAgICAgICAgICAgdGhpcy5weSA9IHB5O1xuICAgICAgICAgICAgdGhpcy5weiA9IHB6O1xuICAgICAgICAgICAgaWYgKHB4ID09IG51bGwgfHwgIUZwLmlzVmFsaWQocHgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneCByZXF1aXJlZCcpO1xuICAgICAgICAgICAgaWYgKHB5ID09IG51bGwgfHwgIUZwLmlzVmFsaWQocHkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneSByZXF1aXJlZCcpO1xuICAgICAgICAgICAgaWYgKHB6ID09IG51bGwgfHwgIUZwLmlzVmFsaWQocHopKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneiByZXF1aXJlZCcpO1xuICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEb2VzIG5vdCB2YWxpZGF0ZSBpZiB0aGUgcG9pbnQgaXMgb24tY3VydmUuXG4gICAgICAgIC8vIFVzZSBmcm9tSGV4IGluc3RlYWQsIG9yIGNhbGwgYXNzZXJ0VmFsaWRpdHkoKSBsYXRlci5cbiAgICAgICAgc3RhdGljIGZyb21BZmZpbmUocCkge1xuICAgICAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBwIHx8IHt9O1xuICAgICAgICAgICAgaWYgKCFwIHx8ICFGcC5pc1ZhbGlkKHgpIHx8ICFGcC5pc1ZhbGlkKHkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhZmZpbmUgcG9pbnQnKTtcbiAgICAgICAgICAgIGlmIChwIGluc3RhbmNlb2YgUG9pbnQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcm9qZWN0aXZlIHBvaW50IG5vdCBhbGxvd2VkJyk7XG4gICAgICAgICAgICBjb25zdCBpczAgPSAoaSkgPT4gRnAuZXFsKGksIEZwLlpFUk8pO1xuICAgICAgICAgICAgLy8gZnJvbUFmZmluZSh4OjAsIHk6MCkgd291bGQgcHJvZHVjZSAoeDowLCB5OjAsIHo6MSksIGJ1dCB3ZSBuZWVkICh4OjAsIHk6MSwgejowKVxuICAgICAgICAgICAgaWYgKGlzMCh4KSAmJiBpczAoeSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBvaW50LlpFUk87XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHgsIHksIEZwLk9ORSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IHgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0FmZmluZSgpLng7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IHkoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0FmZmluZSgpLnk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRha2VzIGEgYnVuY2ggb2YgUHJvamVjdGl2ZSBQb2ludHMgYnV0IGV4ZWN1dGVzIG9ubHkgb25lXG4gICAgICAgICAqIGludmVyc2lvbiBvbiBhbGwgb2YgdGhlbS4gSW52ZXJzaW9uIGlzIHZlcnkgc2xvdyBvcGVyYXRpb24sXG4gICAgICAgICAqIHNvIHRoaXMgaW1wcm92ZXMgcGVyZm9ybWFuY2UgbWFzc2l2ZWx5LlxuICAgICAgICAgKiBPcHRpbWl6YXRpb246IGNvbnZlcnRzIGEgbGlzdCBvZiBwcm9qZWN0aXZlIHBvaW50cyB0byBhIGxpc3Qgb2YgaWRlbnRpY2FsIHBvaW50cyB3aXRoIFo9MS5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBub3JtYWxpemVaKHBvaW50cykge1xuICAgICAgICAgICAgY29uc3QgdG9JbnYgPSBGcC5pbnZlcnRCYXRjaChwb2ludHMubWFwKChwKSA9PiBwLnB6KSk7XG4gICAgICAgICAgICByZXR1cm4gcG9pbnRzLm1hcCgocCwgaSkgPT4gcC50b0FmZmluZSh0b0ludltpXSkpLm1hcChQb2ludC5mcm9tQWZmaW5lKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgaGFzaCBzdHJpbmcgb3IgVWludDhBcnJheSB0byBQb2ludC5cbiAgICAgICAgICogQHBhcmFtIGhleCBzaG9ydC9sb25nIEVDRFNBIGhleFxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGZyb21IZXgoaGV4KSB7XG4gICAgICAgICAgICBjb25zdCBQID0gUG9pbnQuZnJvbUFmZmluZShmcm9tQnl0ZXMoZW5zdXJlQnl0ZXMoJ3BvaW50SGV4JywgaGV4KSkpO1xuICAgICAgICAgICAgUC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTXVsdGlwbGllcyBnZW5lcmF0b3IgcG9pbnQgYnkgcHJpdmF0ZUtleS5cbiAgICAgICAgc3RhdGljIGZyb21Qcml2YXRlS2V5KHByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBQb2ludC5CQVNFLm11bHRpcGx5KG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUtleSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE11bHRpc2NhbGFyIE11bHRpcGxpY2F0aW9uXG4gICAgICAgIHN0YXRpYyBtc20ocG9pbnRzLCBzY2FsYXJzKSB7XG4gICAgICAgICAgICByZXR1cm4gcGlwcGVuZ2VyKFBvaW50LCBGbiwgcG9pbnRzLCBzY2FsYXJzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBcIlByaXZhdGUgbWV0aG9kXCIsIGRvbid0IHVzZSBpdCBkaXJlY3RseVxuICAgICAgICBfc2V0V2luZG93U2l6ZSh3aW5kb3dTaXplKSB7XG4gICAgICAgICAgICB3bmFmLnNldFdpbmRvd1NpemUodGhpcywgd2luZG93U2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQSBwb2ludCBvbiBjdXJ2ZSBpcyB2YWxpZCBpZiBpdCBjb25mb3JtcyB0byBlcXVhdGlvbi5cbiAgICAgICAgYXNzZXJ0VmFsaWRpdHkoKSB7XG4gICAgICAgICAgICBhc3NlcnRWYWxpZE1lbW8odGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaGFzRXZlblkoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHkgfSA9IHRoaXMudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIGlmIChGcC5pc09kZClcbiAgICAgICAgICAgICAgICByZXR1cm4gIUZwLmlzT2RkKHkpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmllbGQgZG9lc24ndCBzdXBwb3J0IGlzT2RkXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21wYXJlIG9uZSBwb2ludCB0byBhbm90aGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgICAgICBhc3NlcnRQcmpQb2ludChvdGhlcik7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMSwgcHk6IFkxLCBwejogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMiwgcHk6IFkyLCBwejogWjIgfSA9IG90aGVyO1xuICAgICAgICAgICAgY29uc3QgVTEgPSBGcC5lcWwoRnAubXVsKFgxLCBaMiksIEZwLm11bChYMiwgWjEpKTtcbiAgICAgICAgICAgIGNvbnN0IFUyID0gRnAuZXFsKEZwLm11bChZMSwgWjIpLCBGcC5tdWwoWTIsIFoxKSk7XG4gICAgICAgICAgICByZXR1cm4gVTEgJiYgVTI7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZsaXBzIHBvaW50IHRvIG9uZSBjb3JyZXNwb25kaW5nIHRvICh4LCAteSkgaW4gQWZmaW5lIGNvb3JkaW5hdGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgbmVnYXRlKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnB4LCBGcC5uZWcodGhpcy5weSksIHRoaXMucHopO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbmVzLUNvc3RlbGxvLUJhdGluYSBleGNlcHRpb24tZnJlZSBkb3VibGluZyBmb3JtdWxhLlxuICAgICAgICAvLyBUaGVyZSBpcyAzMCUgZmFzdGVyIEphY29iaWFuIGZvcm11bGEsIGJ1dCBpdCBpcyBub3QgY29tcGxldGUuXG4gICAgICAgIC8vIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTUvMTA2MCwgYWxnb3JpdGhtIDNcbiAgICAgICAgLy8gQ29zdDogOE0gKyAzUyArIDMqYSArIDIqYjMgKyAxNWFkZC5cbiAgICAgICAgZG91YmxlKCkge1xuICAgICAgICAgICAgY29uc3QgeyBhLCBiIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGNvbnN0IGIzID0gRnAubXVsKGIsIF8zbik7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMSwgcHk6IFkxLCBwejogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBsZXQgWDMgPSBGcC5aRVJPLCBZMyA9IEZwLlpFUk8sIFozID0gRnAuWkVSTzsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBsZXQgdDAgPSBGcC5tdWwoWDEsIFgxKTsgLy8gc3RlcCAxXG4gICAgICAgICAgICBsZXQgdDEgPSBGcC5tdWwoWTEsIFkxKTtcbiAgICAgICAgICAgIGxldCB0MiA9IEZwLm11bChaMSwgWjEpO1xuICAgICAgICAgICAgbGV0IHQzID0gRnAubXVsKFgxLCBZMSk7XG4gICAgICAgICAgICB0MyA9IEZwLmFkZCh0MywgdDMpOyAvLyBzdGVwIDVcbiAgICAgICAgICAgIFozID0gRnAubXVsKFgxLCBaMSk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpO1xuICAgICAgICAgICAgWDMgPSBGcC5tdWwoYSwgWjMpO1xuICAgICAgICAgICAgWTMgPSBGcC5tdWwoYjMsIHQyKTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKFgzLCBZMyk7IC8vIHN0ZXAgMTBcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKHQxLCBZMyk7XG4gICAgICAgICAgICBZMyA9IEZwLmFkZCh0MSwgWTMpO1xuICAgICAgICAgICAgWTMgPSBGcC5tdWwoWDMsIFkzKTtcbiAgICAgICAgICAgIFgzID0gRnAubXVsKHQzLCBYMyk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bChiMywgWjMpOyAvLyBzdGVwIDE1XG4gICAgICAgICAgICB0MiA9IEZwLm11bChhLCB0Mik7XG4gICAgICAgICAgICB0MyA9IEZwLnN1Yih0MCwgdDIpO1xuICAgICAgICAgICAgdDMgPSBGcC5tdWwoYSwgdDMpO1xuICAgICAgICAgICAgdDMgPSBGcC5hZGQodDMsIFozKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKHQwLCB0MCk7IC8vIHN0ZXAgMjBcbiAgICAgICAgICAgIHQwID0gRnAuYWRkKFozLCB0MCk7XG4gICAgICAgICAgICB0MCA9IEZwLmFkZCh0MCwgdDIpO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDAsIHQzKTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKFkzLCB0MCk7XG4gICAgICAgICAgICB0MiA9IEZwLm11bChZMSwgWjEpOyAvLyBzdGVwIDI1XG4gICAgICAgICAgICB0MiA9IEZwLmFkZCh0MiwgdDIpO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDIsIHQzKTtcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKFgzLCB0MCk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bCh0MiwgdDEpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWjMsIFozKTsgLy8gc3RlcCAzMFxuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWjMsIFozKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoWDMsIFkzLCBaMyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVuZXMtQ29zdGVsbG8tQmF0aW5hIGV4Y2VwdGlvbi1mcmVlIGFkZGl0aW9uIGZvcm11bGEuXG4gICAgICAgIC8vIFRoZXJlIGlzIDMwJSBmYXN0ZXIgSmFjb2JpYW4gZm9ybXVsYSwgYnV0IGl0IGlzIG5vdCBjb21wbGV0ZS5cbiAgICAgICAgLy8gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxNS8xMDYwLCBhbGdvcml0aG0gMVxuICAgICAgICAvLyBDb3N0OiAxMk0gKyAwUyArIDMqYSArIDMqYjMgKyAyM2FkZC5cbiAgICAgICAgYWRkKG90aGVyKSB7XG4gICAgICAgICAgICBhc3NlcnRQcmpQb2ludChvdGhlcik7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMSwgcHk6IFkxLCBwejogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMiwgcHk6IFkyLCBwejogWjIgfSA9IG90aGVyO1xuICAgICAgICAgICAgbGV0IFgzID0gRnAuWkVSTywgWTMgPSBGcC5aRVJPLCBaMyA9IEZwLlpFUk87IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgYSA9IENVUlZFLmE7XG4gICAgICAgICAgICBjb25zdCBiMyA9IEZwLm11bChDVVJWRS5iLCBfM24pO1xuICAgICAgICAgICAgbGV0IHQwID0gRnAubXVsKFgxLCBYMik7IC8vIHN0ZXAgMVxuICAgICAgICAgICAgbGV0IHQxID0gRnAubXVsKFkxLCBZMik7XG4gICAgICAgICAgICBsZXQgdDIgPSBGcC5tdWwoWjEsIFoyKTtcbiAgICAgICAgICAgIGxldCB0MyA9IEZwLmFkZChYMSwgWTEpO1xuICAgICAgICAgICAgbGV0IHQ0ID0gRnAuYWRkKFgyLCBZMik7IC8vIHN0ZXAgNVxuICAgICAgICAgICAgdDMgPSBGcC5tdWwodDMsIHQ0KTtcbiAgICAgICAgICAgIHQ0ID0gRnAuYWRkKHQwLCB0MSk7XG4gICAgICAgICAgICB0MyA9IEZwLnN1Yih0MywgdDQpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQoWDEsIFoxKTtcbiAgICAgICAgICAgIGxldCB0NSA9IEZwLmFkZChYMiwgWjIpOyAvLyBzdGVwIDEwXG4gICAgICAgICAgICB0NCA9IEZwLm11bCh0NCwgdDUpO1xuICAgICAgICAgICAgdDUgPSBGcC5hZGQodDAsIHQyKTtcbiAgICAgICAgICAgIHQ0ID0gRnAuc3ViKHQ0LCB0NSk7XG4gICAgICAgICAgICB0NSA9IEZwLmFkZChZMSwgWjEpO1xuICAgICAgICAgICAgWDMgPSBGcC5hZGQoWTIsIFoyKTsgLy8gc3RlcCAxNVxuICAgICAgICAgICAgdDUgPSBGcC5tdWwodDUsIFgzKTtcbiAgICAgICAgICAgIFgzID0gRnAuYWRkKHQxLCB0Mik7XG4gICAgICAgICAgICB0NSA9IEZwLnN1Yih0NSwgWDMpO1xuICAgICAgICAgICAgWjMgPSBGcC5tdWwoYSwgdDQpO1xuICAgICAgICAgICAgWDMgPSBGcC5tdWwoYjMsIHQyKTsgLy8gc3RlcCAyMFxuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWDMsIFozKTtcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKHQxLCBaMyk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZCh0MSwgWjMpO1xuICAgICAgICAgICAgWTMgPSBGcC5tdWwoWDMsIFozKTtcbiAgICAgICAgICAgIHQxID0gRnAuYWRkKHQwLCB0MCk7IC8vIHN0ZXAgMjVcbiAgICAgICAgICAgIHQxID0gRnAuYWRkKHQxLCB0MCk7XG4gICAgICAgICAgICB0MiA9IEZwLm11bChhLCB0Mik7XG4gICAgICAgICAgICB0NCA9IEZwLm11bChiMywgdDQpO1xuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDEsIHQyKTtcbiAgICAgICAgICAgIHQyID0gRnAuc3ViKHQwLCB0Mik7IC8vIHN0ZXAgMzBcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQ0ID0gRnAuYWRkKHQ0LCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MSwgdDQpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWTMsIHQwKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQ1LCB0NCk7IC8vIHN0ZXAgMzVcbiAgICAgICAgICAgIFgzID0gRnAubXVsKHQzLCBYMyk7XG4gICAgICAgICAgICBYMyA9IEZwLnN1YihYMywgdDApO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDMsIHQxKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKHQ1LCBaMyk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgdDApOyAvLyBzdGVwIDQwXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KFgzLCBZMywgWjMpO1xuICAgICAgICB9XG4gICAgICAgIHN1YnRyYWN0KG90aGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQob3RoZXIubmVnYXRlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlzMCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVxdWFscyhQb2ludC5aRVJPKTtcbiAgICAgICAgfVxuICAgICAgICB3TkFGKG4pIHtcbiAgICAgICAgICAgIHJldHVybiB3bmFmLndOQUZDYWNoZWQodGhpcywgbiwgUG9pbnQubm9ybWFsaXplWik7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vbi1jb25zdGFudC10aW1lIG11bHRpcGxpY2F0aW9uLiBVc2VzIGRvdWJsZS1hbmQtYWRkIGFsZ29yaXRobS5cbiAgICAgICAgICogSXQncyBmYXN0ZXIsIGJ1dCBzaG91bGQgb25seSBiZSB1c2VkIHdoZW4geW91IGRvbid0IGNhcmUgYWJvdXRcbiAgICAgICAgICogYW4gZXhwb3NlZCBwcml2YXRlIGtleSBlLmcuIHNpZyB2ZXJpZmljYXRpb24sIHdoaWNoIHdvcmtzIG92ZXIgKnB1YmxpYyoga2V5cy5cbiAgICAgICAgICovXG4gICAgICAgIG11bHRpcGx5VW5zYWZlKHNjKSB7XG4gICAgICAgICAgICBjb25zdCB7IGVuZG8sIG46IE4gfSA9IENVUlZFO1xuICAgICAgICAgICAgdXQuYUluUmFuZ2UoJ3NjYWxhcicsIHNjLCBfMG4sIE4pO1xuICAgICAgICAgICAgY29uc3QgSSA9IFBvaW50LlpFUk87XG4gICAgICAgICAgICBpZiAoc2MgPT09IF8wbilcbiAgICAgICAgICAgICAgICByZXR1cm4gSTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzMCgpIHx8IHNjID09PSBfMW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAvLyBDYXNlIGE6IG5vIGVuZG9tb3JwaGlzbS4gQ2FzZSBiOiBoYXMgcHJlY29tcHV0ZXMuXG4gICAgICAgICAgICBpZiAoIWVuZG8gfHwgd25hZi5oYXNQcmVjb21wdXRlcyh0aGlzKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gd25hZi53TkFGQ2FjaGVkVW5zYWZlKHRoaXMsIHNjLCBQb2ludC5ub3JtYWxpemVaKTtcbiAgICAgICAgICAgIC8vIENhc2UgYzogZW5kb21vcnBoaXNtXG4gICAgICAgICAgICBsZXQgeyBrMW5lZywgazEsIGsybmVnLCBrMiB9ID0gZW5kby5zcGxpdFNjYWxhcihzYyk7XG4gICAgICAgICAgICBsZXQgazFwID0gSTtcbiAgICAgICAgICAgIGxldCBrMnAgPSBJO1xuICAgICAgICAgICAgbGV0IGQgPSB0aGlzO1xuICAgICAgICAgICAgd2hpbGUgKGsxID4gXzBuIHx8IGsyID4gXzBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGsxICYgXzFuKVxuICAgICAgICAgICAgICAgICAgICBrMXAgPSBrMXAuYWRkKGQpO1xuICAgICAgICAgICAgICAgIGlmIChrMiAmIF8xbilcbiAgICAgICAgICAgICAgICAgICAgazJwID0gazJwLmFkZChkKTtcbiAgICAgICAgICAgICAgICBkID0gZC5kb3VibGUoKTtcbiAgICAgICAgICAgICAgICBrMSA+Pj0gXzFuO1xuICAgICAgICAgICAgICAgIGsyID4+PSBfMW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoazFuZWcpXG4gICAgICAgICAgICAgICAgazFwID0gazFwLm5lZ2F0ZSgpO1xuICAgICAgICAgICAgaWYgKGsybmVnKVxuICAgICAgICAgICAgICAgIGsycCA9IGsycC5uZWdhdGUoKTtcbiAgICAgICAgICAgIGsycCA9IG5ldyBQb2ludChGcC5tdWwoazJwLnB4LCBlbmRvLmJldGEpLCBrMnAucHksIGsycC5weik7XG4gICAgICAgICAgICByZXR1cm4gazFwLmFkZChrMnApO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdGFudCB0aW1lIG11bHRpcGxpY2F0aW9uLlxuICAgICAgICAgKiBVc2VzIHdOQUYgbWV0aG9kLiBXaW5kb3dlZCBtZXRob2QgbWF5IGJlIDEwJSBmYXN0ZXIsXG4gICAgICAgICAqIGJ1dCB0YWtlcyAyeCBsb25nZXIgdG8gZ2VuZXJhdGUgYW5kIGNvbnN1bWVzIDJ4IG1lbW9yeS5cbiAgICAgICAgICogVXNlcyBwcmVjb21wdXRlcyB3aGVuIGF2YWlsYWJsZS5cbiAgICAgICAgICogVXNlcyBlbmRvbW9ycGhpc20gZm9yIEtvYmxpdHogY3VydmVzLlxuICAgICAgICAgKiBAcGFyYW0gc2NhbGFyIGJ5IHdoaWNoIHRoZSBwb2ludCB3b3VsZCBiZSBtdWx0aXBsaWVkXG4gICAgICAgICAqIEByZXR1cm5zIE5ldyBwb2ludFxuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGlwbHkoc2NhbGFyKSB7XG4gICAgICAgICAgICBjb25zdCB7IGVuZG8sIG46IE4gfSA9IENVUlZFO1xuICAgICAgICAgICAgdXQuYUluUmFuZ2UoJ3NjYWxhcicsIHNjYWxhciwgXzFuLCBOKTtcbiAgICAgICAgICAgIGxldCBwb2ludCwgZmFrZTsgLy8gRmFrZSBwb2ludCBpcyB1c2VkIHRvIGNvbnN0LXRpbWUgbXVsdFxuICAgICAgICAgICAgaWYgKGVuZG8pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGsxbmVnLCBrMSwgazJuZWcsIGsyIH0gPSBlbmRvLnNwbGl0U2NhbGFyKHNjYWxhcik7XG4gICAgICAgICAgICAgICAgbGV0IHsgcDogazFwLCBmOiBmMXAgfSA9IHRoaXMud05BRihrMSk7XG4gICAgICAgICAgICAgICAgbGV0IHsgcDogazJwLCBmOiBmMnAgfSA9IHRoaXMud05BRihrMik7XG4gICAgICAgICAgICAgICAgazFwID0gd25hZi5jb25zdFRpbWVOZWdhdGUoazFuZWcsIGsxcCk7XG4gICAgICAgICAgICAgICAgazJwID0gd25hZi5jb25zdFRpbWVOZWdhdGUoazJuZWcsIGsycCk7XG4gICAgICAgICAgICAgICAgazJwID0gbmV3IFBvaW50KEZwLm11bChrMnAucHgsIGVuZG8uYmV0YSksIGsycC5weSwgazJwLnB6KTtcbiAgICAgICAgICAgICAgICBwb2ludCA9IGsxcC5hZGQoazJwKTtcbiAgICAgICAgICAgICAgICBmYWtlID0gZjFwLmFkZChmMnApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwLCBmIH0gPSB0aGlzLndOQUYoc2NhbGFyKTtcbiAgICAgICAgICAgICAgICBwb2ludCA9IHA7XG4gICAgICAgICAgICAgICAgZmFrZSA9IGY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgYHpgIGZvciBib3RoIHBvaW50cywgYnV0IHJldHVybiBvbmx5IHJlYWwgb25lXG4gICAgICAgICAgICByZXR1cm4gUG9pbnQubm9ybWFsaXplWihbcG9pbnQsIGZha2VdKVswXTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRWZmaWNpZW50bHkgY2FsY3VsYXRlIGBhUCArIGJRYC4gVW5zYWZlLCBjYW4gZXhwb3NlIHByaXZhdGUga2V5LCBpZiB1c2VkIGluY29ycmVjdGx5LlxuICAgICAgICAgKiBOb3QgdXNpbmcgU3RyYXVzcy1TaGFtaXIgdHJpY2s6IHByZWNvbXB1dGF0aW9uIHRhYmxlcyBhcmUgZmFzdGVyLlxuICAgICAgICAgKiBUaGUgdHJpY2sgY291bGQgYmUgdXNlZnVsIGlmIGJvdGggUCBhbmQgUSBhcmUgbm90IEcgKG5vdCBpbiBvdXIgY2FzZSkuXG4gICAgICAgICAqIEByZXR1cm5zIG5vbi16ZXJvIGFmZmluZSBwb2ludFxuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGlwbHlBbmRBZGRVbnNhZmUoUSwgYSwgYikge1xuICAgICAgICAgICAgY29uc3QgRyA9IFBvaW50LkJBU0U7IC8vIE5vIFN0cmF1c3MtU2hhbWlyIHRyaWNrOiB3ZSBoYXZlIDEwJSBmYXN0ZXIgRyBwcmVjb21wdXRlc1xuICAgICAgICAgICAgY29uc3QgbXVsID0gKFAsIGEgLy8gU2VsZWN0IGZhc3RlciBtdWx0aXBseSgpIG1ldGhvZFxuICAgICAgICAgICAgKSA9PiAoYSA9PT0gXzBuIHx8IGEgPT09IF8xbiB8fCAhUC5lcXVhbHMoRykgPyBQLm11bHRpcGx5VW5zYWZlKGEpIDogUC5tdWx0aXBseShhKSk7XG4gICAgICAgICAgICBjb25zdCBzdW0gPSBtdWwodGhpcywgYSkuYWRkKG11bChRLCBiKSk7XG4gICAgICAgICAgICByZXR1cm4gc3VtLmlzMCgpID8gdW5kZWZpbmVkIDogc3VtO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbnZlcnRzIFByb2plY3RpdmUgcG9pbnQgdG8gYWZmaW5lICh4LCB5KSBjb29yZGluYXRlcy5cbiAgICAgICAgLy8gQ2FuIGFjY2VwdCBwcmVjb21wdXRlZCBaXi0xIC0gZm9yIGV4YW1wbGUsIGZyb20gaW52ZXJ0QmF0Y2guXG4gICAgICAgIC8vICh4LCB5LCB6KSDiiIsgKHg9eC96LCB5PXkveilcbiAgICAgICAgdG9BZmZpbmUoaXopIHtcbiAgICAgICAgICAgIHJldHVybiB0b0FmZmluZU1lbW8odGhpcywgaXopO1xuICAgICAgICB9XG4gICAgICAgIGlzVG9yc2lvbkZyZWUoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGg6IGNvZmFjdG9yLCBpc1RvcnNpb25GcmVlIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGlmIChjb2ZhY3RvciA9PT0gXzFuKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBObyBzdWJncm91cHMsIGFsd2F5cyB0b3JzaW9uLWZyZWVcbiAgICAgICAgICAgIGlmIChpc1RvcnNpb25GcmVlKVxuICAgICAgICAgICAgICAgIHJldHVybiBpc1RvcnNpb25GcmVlKFBvaW50LCB0aGlzKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaXNUb3JzaW9uRnJlZSgpIGhhcyBub3QgYmVlbiBkZWNsYXJlZCBmb3IgdGhlIGVsbGlwdGljIGN1cnZlJyk7XG4gICAgICAgIH1cbiAgICAgICAgY2xlYXJDb2ZhY3RvcigpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaDogY29mYWN0b3IsIGNsZWFyQ29mYWN0b3IgfSA9IENVUlZFO1xuICAgICAgICAgICAgaWYgKGNvZmFjdG9yID09PSBfMW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7IC8vIEZhc3QtcGF0aFxuICAgICAgICAgICAgaWYgKGNsZWFyQ29mYWN0b3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsZWFyQ29mYWN0b3IoUG9pbnQsIHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHlVbnNhZmUoQ1VSVkUuaCk7XG4gICAgICAgIH1cbiAgICAgICAgdG9SYXdCeXRlcyhpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgICAgICBhYm9vbCgnaXNDb21wcmVzc2VkJywgaXNDb21wcmVzc2VkKTtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiB0b0J5dGVzKFBvaW50LCB0aGlzLCBpc0NvbXByZXNzZWQpO1xuICAgICAgICB9XG4gICAgICAgIHRvSGV4KGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgICAgIGFib29sKCdpc0NvbXByZXNzZWQnLCBpc0NvbXByZXNzZWQpO1xuICAgICAgICAgICAgcmV0dXJuIHV0LmJ5dGVzVG9IZXgodGhpcy50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFBvaW50LkJBU0UgPSBuZXcgUG9pbnQoQ1VSVkUuR3gsIENVUlZFLkd5LCBGcC5PTkUpO1xuICAgIFBvaW50LlpFUk8gPSBuZXcgUG9pbnQoRnAuWkVSTywgRnAuT05FLCBGcC5aRVJPKTtcbiAgICBjb25zdCBfYml0cyA9IENVUlZFLm5CaXRMZW5ndGg7XG4gICAgY29uc3Qgd25hZiA9IHdOQUYoUG9pbnQsIENVUlZFLmVuZG8gPyBNYXRoLmNlaWwoX2JpdHMgLyAyKSA6IF9iaXRzKTtcbiAgICAvLyBWYWxpZGF0ZSBpZiBnZW5lcmF0b3IgcG9pbnQgaXMgb24gY3VydmVcbiAgICByZXR1cm4ge1xuICAgICAgICBDVVJWRSxcbiAgICAgICAgUHJvamVjdGl2ZVBvaW50OiBQb2ludCxcbiAgICAgICAgbm9ybVByaXZhdGVLZXlUb1NjYWxhcixcbiAgICAgICAgd2VpZXJzdHJhc3NFcXVhdGlvbixcbiAgICAgICAgaXNXaXRoaW5DdXJ2ZU9yZGVyLFxuICAgIH07XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU9wdHMoY3VydmUpIHtcbiAgICBjb25zdCBvcHRzID0gdmFsaWRhdGVCYXNpYyhjdXJ2ZSk7XG4gICAgdXQudmFsaWRhdGVPYmplY3Qob3B0cywge1xuICAgICAgICBoYXNoOiAnaGFzaCcsXG4gICAgICAgIGhtYWM6ICdmdW5jdGlvbicsXG4gICAgICAgIHJhbmRvbUJ5dGVzOiAnZnVuY3Rpb24nLFxuICAgIH0sIHtcbiAgICAgICAgYml0czJpbnQ6ICdmdW5jdGlvbicsXG4gICAgICAgIGJpdHMyaW50X21vZE46ICdmdW5jdGlvbicsXG4gICAgICAgIGxvd1M6ICdib29sZWFuJyxcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IGxvd1M6IHRydWUsIC4uLm9wdHMgfSk7XG59XG4vKipcbiAqIENyZWF0ZXMgc2hvcnQgd2VpZXJzdHJhc3MgY3VydmUgYW5kIEVDRFNBIHNpZ25hdHVyZSBtZXRob2RzIGZvciBpdC5cbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBGaWVsZCB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvYWJzdHJhY3QvbW9kdWxhcic7XG4gKiAvLyBCZWZvcmUgdGhhdCwgZGVmaW5lIEJpZ0ludC1zOiBhLCBiLCBwLCBuLCBHeCwgR3lcbiAqIGNvbnN0IGN1cnZlID0gd2VpZXJzdHJhc3MoeyBhLCBiLCBGcDogRmllbGQocCksIG4sIEd4LCBHeSwgaDogMW4gfSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdlaWVyc3RyYXNzKGN1cnZlRGVmKSB7XG4gICAgY29uc3QgQ1VSVkUgPSB2YWxpZGF0ZU9wdHMoY3VydmVEZWYpO1xuICAgIGNvbnN0IHsgRnAsIG46IENVUlZFX09SREVSIH0gPSBDVVJWRTtcbiAgICBjb25zdCBjb21wcmVzc2VkTGVuID0gRnAuQllURVMgKyAxOyAvLyBlLmcuIDMzIGZvciAzMlxuICAgIGNvbnN0IHVuY29tcHJlc3NlZExlbiA9IDIgKiBGcC5CWVRFUyArIDE7IC8vIGUuZy4gNjUgZm9yIDMyXG4gICAgZnVuY3Rpb24gbW9kTihhKSB7XG4gICAgICAgIHJldHVybiBtb2QoYSwgQ1VSVkVfT1JERVIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnZOKGEpIHtcbiAgICAgICAgcmV0dXJuIGludmVydChhLCBDVVJWRV9PUkRFUik7XG4gICAgfVxuICAgIGNvbnN0IHsgUHJvamVjdGl2ZVBvaW50OiBQb2ludCwgbm9ybVByaXZhdGVLZXlUb1NjYWxhciwgd2VpZXJzdHJhc3NFcXVhdGlvbiwgaXNXaXRoaW5DdXJ2ZU9yZGVyLCB9ID0gd2VpZXJzdHJhc3NQb2ludHMoe1xuICAgICAgICAuLi5DVVJWRSxcbiAgICAgICAgdG9CeXRlcyhfYywgcG9pbnQsIGlzQ29tcHJlc3NlZCkge1xuICAgICAgICAgICAgY29uc3QgYSA9IHBvaW50LnRvQWZmaW5lKCk7XG4gICAgICAgICAgICBjb25zdCB4ID0gRnAudG9CeXRlcyhhLngpO1xuICAgICAgICAgICAgY29uc3QgY2F0ID0gdXQuY29uY2F0Qnl0ZXM7XG4gICAgICAgICAgICBhYm9vbCgnaXNDb21wcmVzc2VkJywgaXNDb21wcmVzc2VkKTtcbiAgICAgICAgICAgIGlmIChpc0NvbXByZXNzZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2F0KFVpbnQ4QXJyYXkuZnJvbShbcG9pbnQuaGFzRXZlblkoKSA/IDB4MDIgOiAweDAzXSksIHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhdChVaW50OEFycmF5LmZyb20oWzB4MDRdKSwgeCwgRnAudG9CeXRlcyhhLnkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZnJvbUJ5dGVzKGJ5dGVzKSB7XG4gICAgICAgICAgICBjb25zdCBsZW4gPSBieXRlcy5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBoZWFkID0gYnl0ZXNbMF07XG4gICAgICAgICAgICBjb25zdCB0YWlsID0gYnl0ZXMuc3ViYXJyYXkoMSk7XG4gICAgICAgICAgICAvLyB0aGlzLmFzc2VydFZhbGlkaXR5KCkgaXMgZG9uZSBpbnNpZGUgb2YgZnJvbUhleFxuICAgICAgICAgICAgaWYgKGxlbiA9PT0gY29tcHJlc3NlZExlbiAmJiAoaGVhZCA9PT0gMHgwMiB8fCBoZWFkID09PSAweDAzKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSB1dC5ieXRlc1RvTnVtYmVyQkUodGFpbCk7XG4gICAgICAgICAgICAgICAgaWYgKCF1dC5pblJhbmdlKHgsIF8xbiwgRnAuT1JERVIpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvaW50IGlzIG5vdCBvbiBjdXJ2ZScpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkyID0gd2VpZXJzdHJhc3NFcXVhdGlvbih4KTsgLy8gecKyID0geMKzICsgYXggKyBiXG4gICAgICAgICAgICAgICAgbGV0IHk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgeSA9IEZwLnNxcnQoeTIpOyAvLyB5ID0gecKyIF4gKHArMSkvNFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoc3FydEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1ZmZpeCA9IHNxcnRFcnJvciBpbnN0YW5jZW9mIEVycm9yID8gJzogJyArIHNxcnRFcnJvci5tZXNzYWdlIDogJyc7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUG9pbnQgaXMgbm90IG9uIGN1cnZlJyArIHN1ZmZpeCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGlzWU9kZCA9ICh5ICYgXzFuKSA9PT0gXzFuO1xuICAgICAgICAgICAgICAgIC8vIEVDRFNBXG4gICAgICAgICAgICAgICAgY29uc3QgaXNIZWFkT2RkID0gKGhlYWQgJiAxKSA9PT0gMTtcbiAgICAgICAgICAgICAgICBpZiAoaXNIZWFkT2RkICE9PSBpc1lPZGQpXG4gICAgICAgICAgICAgICAgICAgIHkgPSBGcC5uZWcoeSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobGVuID09PSB1bmNvbXByZXNzZWRMZW4gJiYgaGVhZCA9PT0gMHgwNCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSBGcC5mcm9tQnl0ZXModGFpbC5zdWJhcnJheSgwLCBGcC5CWVRFUykpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBGcC5mcm9tQnl0ZXModGFpbC5zdWJhcnJheShGcC5CWVRFUywgMiAqIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2wgPSBjb21wcmVzc2VkTGVuO1xuICAgICAgICAgICAgICAgIGNvbnN0IHVsID0gdW5jb21wcmVzc2VkTGVuO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBQb2ludCwgZXhwZWN0ZWQgbGVuZ3RoIG9mICcgKyBjbCArICcsIG9yIHVuY29tcHJlc3NlZCAnICsgdWwgKyAnLCBnb3QgJyArIGxlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgY29uc3QgbnVtVG9OQnl0ZVN0ciA9IChudW0pID0+IHV0LmJ5dGVzVG9IZXgodXQubnVtYmVyVG9CeXRlc0JFKG51bSwgQ1VSVkUubkJ5dGVMZW5ndGgpKTtcbiAgICBmdW5jdGlvbiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIobnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IEhBTEYgPSBDVVJWRV9PUkRFUiA+PiBfMW47XG4gICAgICAgIHJldHVybiBudW1iZXIgPiBIQUxGO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub3JtYWxpemVTKHMpIHtcbiAgICAgICAgcmV0dXJuIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihzKSA/IG1vZE4oLXMpIDogcztcbiAgICB9XG4gICAgLy8gc2xpY2UgYnl0ZXMgbnVtXG4gICAgY29uc3Qgc2xjTnVtID0gKGIsIGZyb20sIHRvKSA9PiB1dC5ieXRlc1RvTnVtYmVyQkUoYi5zbGljZShmcm9tLCB0bykpO1xuICAgIC8qKlxuICAgICAqIEVDRFNBIHNpZ25hdHVyZSB3aXRoIGl0cyAociwgcykgcHJvcGVydGllcy4gU3VwcG9ydHMgREVSICYgY29tcGFjdCByZXByZXNlbnRhdGlvbnMuXG4gICAgICovXG4gICAgY2xhc3MgU2lnbmF0dXJlIHtcbiAgICAgICAgY29uc3RydWN0b3IociwgcywgcmVjb3ZlcnkpIHtcbiAgICAgICAgICAgIHRoaXMuciA9IHI7XG4gICAgICAgICAgICB0aGlzLnMgPSBzO1xuICAgICAgICAgICAgdGhpcy5yZWNvdmVyeSA9IHJlY292ZXJ5O1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhaXIgKGJ5dGVzIG9mIHIsIGJ5dGVzIG9mIHMpXG4gICAgICAgIHN0YXRpYyBmcm9tQ29tcGFjdChoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IGwgPSBDVVJWRS5uQnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIGhleCA9IGVuc3VyZUJ5dGVzKCdjb21wYWN0U2lnbmF0dXJlJywgaGV4LCBsICogMik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShzbGNOdW0oaGV4LCAwLCBsKSwgc2xjTnVtKGhleCwgbCwgMiAqIGwpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBERVIgZW5jb2RlZCBFQ0RTQSBzaWduYXR1cmVcbiAgICAgICAgLy8gaHR0cHM6Ly9iaXRjb2luLnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy81NzY0NC93aGF0LWFyZS10aGUtcGFydHMtb2YtYS1iaXRjb2luLXRyYW5zYWN0aW9uLWlucHV0LXNjcmlwdFxuICAgICAgICBzdGF0aWMgZnJvbURFUihoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgciwgcyB9ID0gREVSLnRvU2lnKGVuc3VyZUJ5dGVzKCdERVInLCBoZXgpKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHIsIHMpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydFZhbGlkaXR5KCkge1xuICAgICAgICAgICAgdXQuYUluUmFuZ2UoJ3InLCB0aGlzLnIsIF8xbiwgQ1VSVkVfT1JERVIpOyAvLyByIGluIFsxLi5OXVxuICAgICAgICAgICAgdXQuYUluUmFuZ2UoJ3MnLCB0aGlzLnMsIF8xbiwgQ1VSVkVfT1JERVIpOyAvLyBzIGluIFsxLi5OXVxuICAgICAgICB9XG4gICAgICAgIGFkZFJlY292ZXJ5Qml0KHJlY292ZXJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZSh0aGlzLnIsIHRoaXMucywgcmVjb3ZlcnkpO1xuICAgICAgICB9XG4gICAgICAgIHJlY292ZXJQdWJsaWNLZXkobXNnSGFzaCkge1xuICAgICAgICAgICAgY29uc3QgeyByLCBzLCByZWNvdmVyeTogcmVjIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgaCA9IGJpdHMyaW50X21vZE4oZW5zdXJlQnl0ZXMoJ21zZ0hhc2gnLCBtc2dIYXNoKSk7IC8vIFRydW5jYXRlIGhhc2hcbiAgICAgICAgICAgIGlmIChyZWMgPT0gbnVsbCB8fCAhWzAsIDEsIDIsIDNdLmluY2x1ZGVzKHJlYykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWNvdmVyeSBpZCBpbnZhbGlkJyk7XG4gICAgICAgICAgICBjb25zdCByYWRqID0gcmVjID09PSAyIHx8IHJlYyA9PT0gMyA/IHIgKyBDVVJWRS5uIDogcjtcbiAgICAgICAgICAgIGlmIChyYWRqID49IEZwLk9SREVSKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVjb3ZlcnkgaWQgMiBvciAzIGludmFsaWQnKTtcbiAgICAgICAgICAgIGNvbnN0IHByZWZpeCA9IChyZWMgJiAxKSA9PT0gMCA/ICcwMicgOiAnMDMnO1xuICAgICAgICAgICAgY29uc3QgUiA9IFBvaW50LmZyb21IZXgocHJlZml4ICsgbnVtVG9OQnl0ZVN0cihyYWRqKSk7XG4gICAgICAgICAgICBjb25zdCBpciA9IGludk4ocmFkaik7IC8vIHJeLTFcbiAgICAgICAgICAgIGNvbnN0IHUxID0gbW9kTigtaCAqIGlyKTsgLy8gLWhyXi0xXG4gICAgICAgICAgICBjb25zdCB1MiA9IG1vZE4ocyAqIGlyKTsgLy8gc3JeLTFcbiAgICAgICAgICAgIGNvbnN0IFEgPSBQb2ludC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKFIsIHUxLCB1Mik7IC8vIChzcl4tMSlSLShocl4tMSlHID0gLShocl4tMSlHICsgKHNyXi0xKVxuICAgICAgICAgICAgaWYgKCFRKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncG9pbnQgYXQgaW5maW5pZnknKTsgLy8gdW5zYWZlIGlzIGZpbmU6IG5vIHByaXYgZGF0YSBsZWFrZWRcbiAgICAgICAgICAgIFEuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiBRO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNpZ25hdHVyZXMgc2hvdWxkIGJlIGxvdy1zLCB0byBwcmV2ZW50IG1hbGxlYWJpbGl0eS5cbiAgICAgICAgaGFzSGlnaFMoKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNCaWdnZXJUaGFuSGFsZk9yZGVyKHRoaXMucyk7XG4gICAgICAgIH1cbiAgICAgICAgbm9ybWFsaXplUygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhc0hpZ2hTKCkgPyBuZXcgU2lnbmF0dXJlKHRoaXMuciwgbW9kTigtdGhpcy5zKSwgdGhpcy5yZWNvdmVyeSkgOiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIERFUi1lbmNvZGVkXG4gICAgICAgIHRvREVSUmF3Qnl0ZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdXQuaGV4VG9CeXRlcyh0aGlzLnRvREVSSGV4KCkpO1xuICAgICAgICB9XG4gICAgICAgIHRvREVSSGV4KCkge1xuICAgICAgICAgICAgcmV0dXJuIERFUi5oZXhGcm9tU2lnKHsgcjogdGhpcy5yLCBzOiB0aGlzLnMgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcGFkZGVkIGJ5dGVzIG9mIHIsIHRoZW4gcGFkZGVkIGJ5dGVzIG9mIHNcbiAgICAgICAgdG9Db21wYWN0UmF3Qnl0ZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdXQuaGV4VG9CeXRlcyh0aGlzLnRvQ29tcGFjdEhleCgpKTtcbiAgICAgICAgfVxuICAgICAgICB0b0NvbXBhY3RIZXgoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtVG9OQnl0ZVN0cih0aGlzLnIpICsgbnVtVG9OQnl0ZVN0cih0aGlzLnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHV0aWxzID0ge1xuICAgICAgICBpc1ZhbGlkUHJpdmF0ZUtleShwcml2YXRlS2V5KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUtleSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXI6IG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9kdWNlcyBjcnlwdG9ncmFwaGljYWxseSBzZWN1cmUgcHJpdmF0ZSBrZXkgZnJvbSByYW5kb20gb2Ygc2l6ZVxuICAgICAgICAgKiAoZ3JvdXBMZW4gKyBjZWlsKGdyb3VwTGVuIC8gMikpIHdpdGggbW9kdWxvIGJpYXMgYmVpbmcgbmVnbGlnaWJsZS5cbiAgICAgICAgICovXG4gICAgICAgIHJhbmRvbVByaXZhdGVLZXk6ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IGdldE1pbkhhc2hMZW5ndGgoQ1VSVkUubik7XG4gICAgICAgICAgICByZXR1cm4gbWFwSGFzaFRvRmllbGQoQ1VSVkUucmFuZG9tQnl0ZXMobGVuZ3RoKSwgQ1VSVkUubik7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIHByZWNvbXB1dGUgdGFibGUgZm9yIGFuIGFyYml0cmFyeSBFQyBwb2ludC4gTWFrZXMgcG9pbnQgXCJjYWNoZWRcIi5cbiAgICAgICAgICogQWxsb3dzIHRvIG1hc3NpdmVseSBzcGVlZC11cCBgcG9pbnQubXVsdGlwbHkoc2NhbGFyKWAuXG4gICAgICAgICAqIEByZXR1cm5zIGNhY2hlZCBwb2ludFxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBjb25zdCBmYXN0ID0gdXRpbHMucHJlY29tcHV0ZSg4LCBQcm9qZWN0aXZlUG9pbnQuZnJvbUhleChzb21lb25lc1B1YktleSkpO1xuICAgICAgICAgKiBmYXN0Lm11bHRpcGx5KHByaXZLZXkpOyAvLyBtdWNoIGZhc3RlciBFQ0RIIG5vd1xuICAgICAgICAgKi9cbiAgICAgICAgcHJlY29tcHV0ZSh3aW5kb3dTaXplID0gOCwgcG9pbnQgPSBQb2ludC5CQVNFKSB7XG4gICAgICAgICAgICBwb2ludC5fc2V0V2luZG93U2l6ZSh3aW5kb3dTaXplKTtcbiAgICAgICAgICAgIHBvaW50Lm11bHRpcGx5KEJpZ0ludCgzKSk7IC8vIDMgaXMgYXJiaXRyYXJ5LCBqdXN0IG5lZWQgYW55IG51bWJlciBoZXJlXG4gICAgICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBwdWJsaWMga2V5IGZvciBhIHByaXZhdGUga2V5LiBDaGVja3MgZm9yIHZhbGlkaXR5IG9mIHRoZSBwcml2YXRlIGtleS5cbiAgICAgKiBAcGFyYW0gcHJpdmF0ZUtleSBwcml2YXRlIGtleVxuICAgICAqIEBwYXJhbSBpc0NvbXByZXNzZWQgd2hldGhlciB0byByZXR1cm4gY29tcGFjdCAoZGVmYXVsdCksIG9yIGZ1bGwga2V5XG4gICAgICogQHJldHVybnMgUHVibGljIGtleSwgZnVsbCB3aGVuIGlzQ29tcHJlc3NlZD1mYWxzZTsgc2hvcnQgd2hlbiBpc0NvbXByZXNzZWQ9dHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFB1YmxpY0tleShwcml2YXRlS2V5LCBpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBQb2ludC5mcm9tUHJpdmF0ZUtleShwcml2YXRlS2V5KS50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1aWNrIGFuZCBkaXJ0eSBjaGVjayBmb3IgaXRlbSBiZWluZyBwdWJsaWMga2V5LiBEb2VzIG5vdCB2YWxpZGF0ZSBoZXgsIG9yIGJlaW5nIG9uLWN1cnZlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUHJvYlB1YihpdGVtKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IHV0LmlzQnl0ZXMoaXRlbSk7XG4gICAgICAgIGNvbnN0IHN0ciA9IHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJztcbiAgICAgICAgY29uc3QgbGVuID0gKGFyciB8fCBzdHIpICYmIGl0ZW0ubGVuZ3RoO1xuICAgICAgICBpZiAoYXJyKVxuICAgICAgICAgICAgcmV0dXJuIGxlbiA9PT0gY29tcHJlc3NlZExlbiB8fCBsZW4gPT09IHVuY29tcHJlc3NlZExlbjtcbiAgICAgICAgaWYgKHN0cilcbiAgICAgICAgICAgIHJldHVybiBsZW4gPT09IDIgKiBjb21wcmVzc2VkTGVuIHx8IGxlbiA9PT0gMiAqIHVuY29tcHJlc3NlZExlbjtcbiAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBQb2ludClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVDREggKEVsbGlwdGljIEN1cnZlIERpZmZpZSBIZWxsbWFuKS5cbiAgICAgKiBDb21wdXRlcyBzaGFyZWQgcHVibGljIGtleSBmcm9tIHByaXZhdGUga2V5IGFuZCBwdWJsaWMga2V5LlxuICAgICAqIENoZWNrczogMSkgcHJpdmF0ZSBrZXkgdmFsaWRpdHkgMikgc2hhcmVkIGtleSBpcyBvbi1jdXJ2ZS5cbiAgICAgKiBEb2VzIE5PVCBoYXNoIHRoZSByZXN1bHQuXG4gICAgICogQHBhcmFtIHByaXZhdGVBIHByaXZhdGUga2V5XG4gICAgICogQHBhcmFtIHB1YmxpY0IgZGlmZmVyZW50IHB1YmxpYyBrZXlcbiAgICAgKiBAcGFyYW0gaXNDb21wcmVzc2VkIHdoZXRoZXIgdG8gcmV0dXJuIGNvbXBhY3QgKGRlZmF1bHQpLCBvciBmdWxsIGtleVxuICAgICAqIEByZXR1cm5zIHNoYXJlZCBwdWJsaWMga2V5XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0U2hhcmVkU2VjcmV0KHByaXZhdGVBLCBwdWJsaWNCLCBpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgIGlmIChpc1Byb2JQdWIocHJpdmF0ZUEpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaXJzdCBhcmcgbXVzdCBiZSBwcml2YXRlIGtleScpO1xuICAgICAgICBpZiAoIWlzUHJvYlB1YihwdWJsaWNCKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2Vjb25kIGFyZyBtdXN0IGJlIHB1YmxpYyBrZXknKTtcbiAgICAgICAgY29uc3QgYiA9IFBvaW50LmZyb21IZXgocHVibGljQik7IC8vIGNoZWNrIGZvciBiZWluZyBvbi1jdXJ2ZVxuICAgICAgICByZXR1cm4gYi5tdWx0aXBseShub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVBKSkudG9SYXdCeXRlcyhpc0NvbXByZXNzZWQpO1xuICAgIH1cbiAgICAvLyBSRkM2OTc5OiBlbnN1cmUgRUNEU0EgbXNnIGlzIFggYnl0ZXMgYW5kIDwgTi4gUkZDIHN1Z2dlc3RzIG9wdGlvbmFsIHRydW5jYXRpbmcgdmlhIGJpdHMyb2N0ZXRzLlxuICAgIC8vIEZJUFMgMTg2LTQgNC42IHN1Z2dlc3RzIHRoZSBsZWZ0bW9zdCBtaW4obkJpdExlbiwgb3V0TGVuKSBiaXRzLCB3aGljaCBtYXRjaGVzIGJpdHMyaW50LlxuICAgIC8vIGJpdHMyaW50IGNhbiBwcm9kdWNlIHJlcz5OLCB3ZSBjYW4gZG8gbW9kKHJlcywgTikgc2luY2UgdGhlIGJpdExlbiBpcyB0aGUgc2FtZS5cbiAgICAvLyBpbnQyb2N0ZXRzIGNhbid0IGJlIHVzZWQ7IHBhZHMgc21hbGwgbXNncyB3aXRoIDA6IHVuYWNjZXB0YXRibGUgZm9yIHRydW5jIGFzIHBlciBSRkMgdmVjdG9yc1xuICAgIGNvbnN0IGJpdHMyaW50ID0gQ1VSVkUuYml0czJpbnQgfHxcbiAgICAgICAgZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgICAgICAgICAvLyBPdXIgY3VzdG9tIGNoZWNrIFwianVzdCBpbiBjYXNlXCJcbiAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggPiA4MTkyKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW5wdXQgaXMgdG9vIGxhcmdlJyk7XG4gICAgICAgICAgICAvLyBGb3IgY3VydmVzIHdpdGggbkJpdExlbmd0aCAlIDggIT09IDA6IGJpdHMyb2N0ZXRzKGJpdHMyb2N0ZXRzKG0pKSAhPT0gYml0czJvY3RldHMobSlcbiAgICAgICAgICAgIC8vIGZvciBzb21lIGNhc2VzLCBzaW5jZSBieXRlcy5sZW5ndGggKiA4IGlzIG5vdCBhY3R1YWwgYml0TGVuZ3RoLlxuICAgICAgICAgICAgY29uc3QgbnVtID0gdXQuYnl0ZXNUb051bWJlckJFKGJ5dGVzKTsgLy8gY2hlY2sgZm9yID09IHU4IGRvbmUgaGVyZVxuICAgICAgICAgICAgY29uc3QgZGVsdGEgPSBieXRlcy5sZW5ndGggKiA4IC0gQ1VSVkUubkJpdExlbmd0aDsgLy8gdHJ1bmNhdGUgdG8gbkJpdExlbmd0aCBsZWZ0bW9zdCBiaXRzXG4gICAgICAgICAgICByZXR1cm4gZGVsdGEgPiAwID8gbnVtID4+IEJpZ0ludChkZWx0YSkgOiBudW07XG4gICAgICAgIH07XG4gICAgY29uc3QgYml0czJpbnRfbW9kTiA9IENVUlZFLmJpdHMyaW50X21vZE4gfHxcbiAgICAgICAgZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9kTihiaXRzMmludChieXRlcykpOyAvLyBjYW4ndCB1c2UgYnl0ZXNUb051bWJlckJFIGhlcmVcbiAgICAgICAgfTtcbiAgICAvLyBOT1RFOiBwYWRzIG91dHB1dCB3aXRoIHplcm8gYXMgcGVyIHNwZWNcbiAgICBjb25zdCBPUkRFUl9NQVNLID0gdXQuYml0TWFzayhDVVJWRS5uQml0TGVuZ3RoKTtcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0byBieXRlcy4gQ2hlY2tzIGlmIG51bSBpbiBgWzAuLk9SREVSX01BU0stMV1gIGUuZy46IGBbMC4uMl4yNTYtMV1gLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludDJvY3RldHMobnVtKSB7XG4gICAgICAgIHV0LmFJblJhbmdlKCdudW0gPCAyXicgKyBDVVJWRS5uQml0TGVuZ3RoLCBudW0sIF8wbiwgT1JERVJfTUFTSyk7XG4gICAgICAgIC8vIHdvcmtzIHdpdGggb3JkZXIsIGNhbiBoYXZlIGRpZmZlcmVudCBzaXplIHRoYW4gbnVtVG9GaWVsZCFcbiAgICAgICAgcmV0dXJuIHV0Lm51bWJlclRvQnl0ZXNCRShudW0sIENVUlZFLm5CeXRlTGVuZ3RoKTtcbiAgICB9XG4gICAgLy8gU3RlcHMgQSwgRCBvZiBSRkM2OTc5IDMuMlxuICAgIC8vIENyZWF0ZXMgUkZDNjk3OSBzZWVkOyBjb252ZXJ0cyBtc2cvcHJpdktleSB0byBudW1iZXJzLlxuICAgIC8vIFVzZWQgb25seSBpbiBzaWduLCBub3QgaW4gdmVyaWZ5LlxuICAgIC8vIE5PVEU6IHdlIGNhbm5vdCBhc3N1bWUgaGVyZSB0aGF0IG1zZ0hhc2ggaGFzIHNhbWUgYW1vdW50IG9mIGJ5dGVzIGFzIGN1cnZlIG9yZGVyLFxuICAgIC8vIHRoaXMgd2lsbCBiZSBpbnZhbGlkIGF0IGxlYXN0IGZvciBQNTIxLiBBbHNvIGl0IGNhbiBiZSBiaWdnZXIgZm9yIFAyMjQgKyBTSEEyNTZcbiAgICBmdW5jdGlvbiBwcmVwU2lnKG1zZ0hhc2gsIHByaXZhdGVLZXksIG9wdHMgPSBkZWZhdWx0U2lnT3B0cykge1xuICAgICAgICBpZiAoWydyZWNvdmVyZWQnLCAnY2Fub25pY2FsJ10uc29tZSgoaykgPT4gayBpbiBvcHRzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbigpIGxlZ2FjeSBvcHRpb25zIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgY29uc3QgeyBoYXNoLCByYW5kb21CeXRlcyB9ID0gQ1VSVkU7XG4gICAgICAgIGxldCB7IGxvd1MsIHByZWhhc2gsIGV4dHJhRW50cm9weTogZW50IH0gPSBvcHRzOyAvLyBnZW5lcmF0ZXMgbG93LXMgc2lncyBieSBkZWZhdWx0XG4gICAgICAgIGlmIChsb3dTID09IG51bGwpXG4gICAgICAgICAgICBsb3dTID0gdHJ1ZTsgLy8gUkZDNjk3OSAzLjI6IHdlIHNraXAgc3RlcCBBLCBiZWNhdXNlIHdlIGFscmVhZHkgcHJvdmlkZSBoYXNoXG4gICAgICAgIG1zZ0hhc2ggPSBlbnN1cmVCeXRlcygnbXNnSGFzaCcsIG1zZ0hhc2gpO1xuICAgICAgICB2YWxpZGF0ZVNpZ1Zlck9wdHMob3B0cyk7XG4gICAgICAgIGlmIChwcmVoYXNoKVxuICAgICAgICAgICAgbXNnSGFzaCA9IGVuc3VyZUJ5dGVzKCdwcmVoYXNoZWQgbXNnSGFzaCcsIGhhc2gobXNnSGFzaCkpO1xuICAgICAgICAvLyBXZSBjYW4ndCBsYXRlciBjYWxsIGJpdHMyb2N0ZXRzLCBzaW5jZSBuZXN0ZWQgYml0czJpbnQgaXMgYnJva2VuIGZvciBjdXJ2ZXNcbiAgICAgICAgLy8gd2l0aCBuQml0TGVuZ3RoICUgOCAhPT0gMC4gQmVjYXVzZSBvZiB0aGF0LCB3ZSB1bndyYXAgaXQgaGVyZSBhcyBpbnQyb2N0ZXRzIGNhbGwuXG4gICAgICAgIC8vIGNvbnN0IGJpdHMyb2N0ZXRzID0gKGJpdHMpID0+IGludDJvY3RldHMoYml0czJpbnRfbW9kTihiaXRzKSlcbiAgICAgICAgY29uc3QgaDFpbnQgPSBiaXRzMmludF9tb2ROKG1zZ0hhc2gpO1xuICAgICAgICBjb25zdCBkID0gbm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlS2V5KTsgLy8gdmFsaWRhdGUgcHJpdmF0ZSBrZXksIGNvbnZlcnQgdG8gYmlnaW50XG4gICAgICAgIGNvbnN0IHNlZWRBcmdzID0gW2ludDJvY3RldHMoZCksIGludDJvY3RldHMoaDFpbnQpXTtcbiAgICAgICAgLy8gZXh0cmFFbnRyb3B5LiBSRkM2OTc5IDMuNjogYWRkaXRpb25hbCBrJyAob3B0aW9uYWwpLlxuICAgICAgICBpZiAoZW50ICE9IG51bGwgJiYgZW50ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgLy8gSyA9IEhNQUNfSyhWIHx8IDB4MDAgfHwgaW50Mm9jdGV0cyh4KSB8fCBiaXRzMm9jdGV0cyhoMSkgfHwgaycpXG4gICAgICAgICAgICBjb25zdCBlID0gZW50ID09PSB0cnVlID8gcmFuZG9tQnl0ZXMoRnAuQllURVMpIDogZW50OyAvLyBnZW5lcmF0ZSByYW5kb20gYnl0ZXMgT1IgcGFzcyBhcy1pc1xuICAgICAgICAgICAgc2VlZEFyZ3MucHVzaChlbnN1cmVCeXRlcygnZXh0cmFFbnRyb3B5JywgZSkpOyAvLyBjaGVjayBmb3IgYmVpbmcgYnl0ZXNcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWVkID0gdXQuY29uY2F0Qnl0ZXMoLi4uc2VlZEFyZ3MpOyAvLyBTdGVwIEQgb2YgUkZDNjk3OSAzLjJcbiAgICAgICAgY29uc3QgbSA9IGgxaW50OyAvLyBOT1RFOiBubyBuZWVkIHRvIGNhbGwgYml0czJpbnQgc2Vjb25kIHRpbWUgaGVyZSwgaXQgaXMgaW5zaWRlIHRydW5jYXRlSGFzaCFcbiAgICAgICAgLy8gQ29udmVydHMgc2lnbmF0dXJlIHBhcmFtcyBpbnRvIHBvaW50IHcgci9zLCBjaGVja3MgcmVzdWx0IGZvciB2YWxpZGl0eS5cbiAgICAgICAgZnVuY3Rpb24gazJzaWcoa0J5dGVzKSB7XG4gICAgICAgICAgICAvLyBSRkMgNjk3OSBTZWN0aW9uIDMuMiwgc3RlcCAzOiBrID0gYml0czJpbnQoVClcbiAgICAgICAgICAgIGNvbnN0IGsgPSBiaXRzMmludChrQnl0ZXMpOyAvLyBDYW5ub3QgdXNlIGZpZWxkcyBtZXRob2RzLCBzaW5jZSBpdCBpcyBncm91cCBlbGVtZW50XG4gICAgICAgICAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcihrKSlcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIEltcG9ydGFudDogYWxsIG1vZCgpIGNhbGxzIGhlcmUgbXVzdCBiZSBkb25lIG92ZXIgTlxuICAgICAgICAgICAgY29uc3QgaWsgPSBpbnZOKGspOyAvLyBrXi0xIG1vZCBuXG4gICAgICAgICAgICBjb25zdCBxID0gUG9pbnQuQkFTRS5tdWx0aXBseShrKS50b0FmZmluZSgpOyAvLyBxID0gR2tcbiAgICAgICAgICAgIGNvbnN0IHIgPSBtb2ROKHEueCk7IC8vIHIgPSBxLnggbW9kIG5cbiAgICAgICAgICAgIGlmIChyID09PSBfMG4pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgLy8gQ2FuIHVzZSBzY2FsYXIgYmxpbmRpbmcgYl4tMShibSArIGJkcikgd2hlcmUgYiDiiIggWzEsceKIkjFdIGFjY29yZGluZyB0b1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly90Y2hlcy5pYWNyLm9yZy9pbmRleC5waHAvVENIRVMvYXJ0aWNsZS92aWV3LzczMzcvNjUwOS4gV2UndmUgZGVjaWRlZCBhZ2FpbnN0IGl0OlxuICAgICAgICAgICAgLy8gYSkgZGVwZW5kZW5jeSBvbiBDU1BSTkcgYikgMTUlIHNsb3dkb3duIGMpIGRvZXNuJ3QgcmVhbGx5IGhlbHAgc2luY2UgYmlnaW50cyBhcmUgbm90IENUXG4gICAgICAgICAgICBjb25zdCBzID0gbW9kTihpayAqIG1vZE4obSArIHIgKiBkKSk7IC8vIE5vdCB1c2luZyBibGluZGluZyBoZXJlXG4gICAgICAgICAgICBpZiAocyA9PT0gXzBuKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxldCByZWNvdmVyeSA9IChxLnggPT09IHIgPyAwIDogMikgfCBOdW1iZXIocS55ICYgXzFuKTsgLy8gcmVjb3ZlcnkgYml0ICgyIG9yIDMsIHdoZW4gcS54ID4gbilcbiAgICAgICAgICAgIGxldCBub3JtUyA9IHM7XG4gICAgICAgICAgICBpZiAobG93UyAmJiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIocykpIHtcbiAgICAgICAgICAgICAgICBub3JtUyA9IG5vcm1hbGl6ZVMocyk7IC8vIGlmIGxvd1Mgd2FzIHBhc3NlZCwgZW5zdXJlIHMgaXMgYWx3YXlzXG4gICAgICAgICAgICAgICAgcmVjb3ZlcnkgXj0gMTsgLy8gLy8gaW4gdGhlIGJvdHRvbSBoYWxmIG9mIE5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHIsIG5vcm1TLCByZWNvdmVyeSk7IC8vIHVzZSBub3JtUywgbm90IHNcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzZWVkLCBrMnNpZyB9O1xuICAgIH1cbiAgICBjb25zdCBkZWZhdWx0U2lnT3B0cyA9IHsgbG93UzogQ1VSVkUubG93UywgcHJlaGFzaDogZmFsc2UgfTtcbiAgICBjb25zdCBkZWZhdWx0VmVyT3B0cyA9IHsgbG93UzogQ1VSVkUubG93UywgcHJlaGFzaDogZmFsc2UgfTtcbiAgICAvKipcbiAgICAgKiBTaWducyBtZXNzYWdlIGhhc2ggd2l0aCBhIHByaXZhdGUga2V5LlxuICAgICAqIGBgYFxuICAgICAqIHNpZ24obSwgZCwgaykgd2hlcmVcbiAgICAgKiAgICh4LCB5KSA9IEcgw5cga1xuICAgICAqICAgciA9IHggbW9kIG5cbiAgICAgKiAgIHMgPSAobSArIGRyKS9rIG1vZCBuXG4gICAgICogYGBgXG4gICAgICogQHBhcmFtIG1zZ0hhc2ggTk9UIG1lc3NhZ2UuIG1zZyBuZWVkcyB0byBiZSBoYXNoZWQgdG8gYG1zZ0hhc2hgLCBvciB1c2UgYHByZWhhc2hgLlxuICAgICAqIEBwYXJhbSBwcml2S2V5IHByaXZhdGUga2V5XG4gICAgICogQHBhcmFtIG9wdHMgbG93UyBmb3Igbm9uLW1hbGxlYWJsZSBzaWdzLiBleHRyYUVudHJvcHkgZm9yIG1peGluZyByYW5kb21uZXNzIGludG8gay4gcHJlaGFzaCB3aWxsIGhhc2ggZmlyc3QgYXJnLlxuICAgICAqIEByZXR1cm5zIHNpZ25hdHVyZSB3aXRoIHJlY292ZXJ5IHBhcmFtXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2lnbihtc2dIYXNoLCBwcml2S2V5LCBvcHRzID0gZGVmYXVsdFNpZ09wdHMpIHtcbiAgICAgICAgY29uc3QgeyBzZWVkLCBrMnNpZyB9ID0gcHJlcFNpZyhtc2dIYXNoLCBwcml2S2V5LCBvcHRzKTsgLy8gU3RlcHMgQSwgRCBvZiBSRkM2OTc5IDMuMi5cbiAgICAgICAgY29uc3QgQyA9IENVUlZFO1xuICAgICAgICBjb25zdCBkcmJnID0gdXQuY3JlYXRlSG1hY0RyYmcoQy5oYXNoLm91dHB1dExlbiwgQy5uQnl0ZUxlbmd0aCwgQy5obWFjKTtcbiAgICAgICAgcmV0dXJuIGRyYmcoc2VlZCwgazJzaWcpOyAvLyBTdGVwcyBCLCBDLCBELCBFLCBGLCBHXG4gICAgfVxuICAgIC8vIEVuYWJsZSBwcmVjb21wdXRlcy4gU2xvd3MgZG93biBmaXJzdCBwdWJsaWNLZXkgY29tcHV0YXRpb24gYnkgMjBtcy5cbiAgICBQb2ludC5CQVNFLl9zZXRXaW5kb3dTaXplKDgpO1xuICAgIC8vIHV0aWxzLnByZWNvbXB1dGUoOCwgUHJvamVjdGl2ZVBvaW50LkJBU0UpXG4gICAgLyoqXG4gICAgICogVmVyaWZpZXMgYSBzaWduYXR1cmUgYWdhaW5zdCBtZXNzYWdlIGhhc2ggYW5kIHB1YmxpYyBrZXkuXG4gICAgICogUmVqZWN0cyBsb3dTIHNpZ25hdHVyZXMgYnkgZGVmYXVsdDogdG8gb3ZlcnJpZGUsXG4gICAgICogc3BlY2lmeSBvcHRpb24gYHtsb3dTOiBmYWxzZX1gLiBJbXBsZW1lbnRzIHNlY3Rpb24gNC4xLjQgZnJvbSBodHRwczovL3d3dy5zZWNnLm9yZy9zZWMxLXYyLnBkZjpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIHZlcmlmeShyLCBzLCBoLCBQKSB3aGVyZVxuICAgICAqICAgVTEgPSBoc14tMSBtb2QgblxuICAgICAqICAgVTIgPSByc14tMSBtb2QgblxuICAgICAqICAgUiA9IFUx4ouFRyAtIFUy4ouFUFxuICAgICAqICAgbW9kKFIueCwgbikgPT0gclxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHZlcmlmeShzaWduYXR1cmUsIG1zZ0hhc2gsIHB1YmxpY0tleSwgb3B0cyA9IGRlZmF1bHRWZXJPcHRzKSB7XG4gICAgICAgIGNvbnN0IHNnID0gc2lnbmF0dXJlO1xuICAgICAgICBtc2dIYXNoID0gZW5zdXJlQnl0ZXMoJ21zZ0hhc2gnLCBtc2dIYXNoKTtcbiAgICAgICAgcHVibGljS2V5ID0gZW5zdXJlQnl0ZXMoJ3B1YmxpY0tleScsIHB1YmxpY0tleSk7XG4gICAgICAgIGNvbnN0IHsgbG93UywgcHJlaGFzaCwgZm9ybWF0IH0gPSBvcHRzO1xuICAgICAgICAvLyBWZXJpZnkgb3B0cywgZGVkdWNlIHNpZ25hdHVyZSBmb3JtYXRcbiAgICAgICAgdmFsaWRhdGVTaWdWZXJPcHRzKG9wdHMpO1xuICAgICAgICBpZiAoJ3N0cmljdCcgaW4gb3B0cylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9ucy5zdHJpY3Qgd2FzIHJlbmFtZWQgdG8gbG93UycpO1xuICAgICAgICBpZiAoZm9ybWF0ICE9PSB1bmRlZmluZWQgJiYgZm9ybWF0ICE9PSAnY29tcGFjdCcgJiYgZm9ybWF0ICE9PSAnZGVyJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZm9ybWF0IG11c3QgYmUgY29tcGFjdCBvciBkZXInKTtcbiAgICAgICAgY29uc3QgaXNIZXggPSB0eXBlb2Ygc2cgPT09ICdzdHJpbmcnIHx8IHV0LmlzQnl0ZXMoc2cpO1xuICAgICAgICBjb25zdCBpc09iaiA9ICFpc0hleCAmJlxuICAgICAgICAgICAgIWZvcm1hdCAmJlxuICAgICAgICAgICAgdHlwZW9mIHNnID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgc2cgIT09IG51bGwgJiZcbiAgICAgICAgICAgIHR5cGVvZiBzZy5yID09PSAnYmlnaW50JyAmJlxuICAgICAgICAgICAgdHlwZW9mIHNnLnMgPT09ICdiaWdpbnQnO1xuICAgICAgICBpZiAoIWlzSGV4ICYmICFpc09iailcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzaWduYXR1cmUsIGV4cGVjdGVkIFVpbnQ4QXJyYXksIGhleCBzdHJpbmcgb3IgU2lnbmF0dXJlIGluc3RhbmNlJyk7XG4gICAgICAgIGxldCBfc2lnID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgUDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChpc09iailcbiAgICAgICAgICAgICAgICBfc2lnID0gbmV3IFNpZ25hdHVyZShzZy5yLCBzZy5zKTtcbiAgICAgICAgICAgIGlmIChpc0hleCkge1xuICAgICAgICAgICAgICAgIC8vIFNpZ25hdHVyZSBjYW4gYmUgcmVwcmVzZW50ZWQgaW4gMiB3YXlzOiBjb21wYWN0ICgyKm5CeXRlTGVuZ3RoKSAmIERFUiAodmFyaWFibGUtbGVuZ3RoKS5cbiAgICAgICAgICAgICAgICAvLyBTaW5jZSBERVIgY2FuIGFsc28gYmUgMipuQnl0ZUxlbmd0aCBieXRlcywgd2UgY2hlY2sgZm9yIGl0IGZpcnN0LlxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3JtYXQgIT09ICdjb21wYWN0JylcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zaWcgPSBTaWduYXR1cmUuZnJvbURFUihzZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChkZXJFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShkZXJFcnJvciBpbnN0YW5jZW9mIERFUi5FcnIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZGVyRXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghX3NpZyAmJiBmb3JtYXQgIT09ICdkZXInKVxuICAgICAgICAgICAgICAgICAgICBfc2lnID0gU2lnbmF0dXJlLmZyb21Db21wYWN0KHNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFAgPSBQb2ludC5mcm9tSGV4KHB1YmxpY0tleSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFfc2lnKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAobG93UyAmJiBfc2lnLmhhc0hpZ2hTKCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChwcmVoYXNoKVxuICAgICAgICAgICAgbXNnSGFzaCA9IENVUlZFLmhhc2gobXNnSGFzaCk7XG4gICAgICAgIGNvbnN0IHsgciwgcyB9ID0gX3NpZztcbiAgICAgICAgY29uc3QgaCA9IGJpdHMyaW50X21vZE4obXNnSGFzaCk7IC8vIENhbm5vdCB1c2UgZmllbGRzIG1ldGhvZHMsIHNpbmNlIGl0IGlzIGdyb3VwIGVsZW1lbnRcbiAgICAgICAgY29uc3QgaXMgPSBpbnZOKHMpOyAvLyBzXi0xXG4gICAgICAgIGNvbnN0IHUxID0gbW9kTihoICogaXMpOyAvLyB1MSA9IGhzXi0xIG1vZCBuXG4gICAgICAgIGNvbnN0IHUyID0gbW9kTihyICogaXMpOyAvLyB1MiA9IHJzXi0xIG1vZCBuXG4gICAgICAgIGNvbnN0IFIgPSBQb2ludC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKFAsIHUxLCB1Mik/LnRvQWZmaW5lKCk7IC8vIFIgPSB1MeKLhUcgKyB1MuKLhVBcbiAgICAgICAgaWYgKCFSKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCB2ID0gbW9kTihSLngpO1xuICAgICAgICByZXR1cm4gdiA9PT0gcjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgQ1VSVkUsXG4gICAgICAgIGdldFB1YmxpY0tleSxcbiAgICAgICAgZ2V0U2hhcmVkU2VjcmV0LFxuICAgICAgICBzaWduLFxuICAgICAgICB2ZXJpZnksXG4gICAgICAgIFByb2plY3RpdmVQb2ludDogUG9pbnQsXG4gICAgICAgIFNpZ25hdHVyZSxcbiAgICAgICAgdXRpbHMsXG4gICAgfTtcbn1cbi8qKlxuICogSW1wbGVtZW50YXRpb24gb2YgdGhlIFNoYWxsdWUgYW5kIHZhbiBkZSBXb2VzdGlqbmUgbWV0aG9kIGZvciBhbnkgd2VpZXJzdHJhc3MgY3VydmUuXG4gKiBUT0RPOiBjaGVjayBpZiB0aGVyZSBpcyBhIHdheSB0byBtZXJnZSB0aGlzIHdpdGggdXZSYXRpbyBpbiBFZHdhcmRzOyBtb3ZlIHRvIG1vZHVsYXIuXG4gKiBiID0gVHJ1ZSBhbmQgeSA9IHNxcnQodSAvIHYpIGlmICh1IC8gdikgaXMgc3F1YXJlIGluIEYsIGFuZFxuICogYiA9IEZhbHNlIGFuZCB5ID0gc3FydChaICogKHUgLyB2KSkgb3RoZXJ3aXNlLlxuICogQHBhcmFtIEZwXG4gKiBAcGFyYW0gWlxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFNXVUZwU3FydFJhdGlvKEZwLCBaKSB7XG4gICAgLy8gR2VuZXJpYyBpbXBsZW1lbnRhdGlvblxuICAgIGNvbnN0IHEgPSBGcC5PUkRFUjtcbiAgICBsZXQgbCA9IF8wbjtcbiAgICBmb3IgKGxldCBvID0gcSAtIF8xbjsgbyAlIF8ybiA9PT0gXzBuOyBvIC89IF8ybilcbiAgICAgICAgbCArPSBfMW47XG4gICAgY29uc3QgYzEgPSBsOyAvLyAxLiBjMSwgdGhlIGxhcmdlc3QgaW50ZWdlciBzdWNoIHRoYXQgMl5jMSBkaXZpZGVzIHEgLSAxLlxuICAgIC8vIFdlIG5lZWQgMm4gKiogYzEgYW5kIDJuICoqIChjMS0xKS4gV2UgY2FuJ3QgdXNlICoqOyBidXQgd2UgY2FuIHVzZSA8PC5cbiAgICAvLyAybiAqKiBjMSA9PSAybiA8PCAoYzEtMSlcbiAgICBjb25zdCBfMm5fcG93X2MxXzEgPSBfMm4gPDwgKGMxIC0gXzFuIC0gXzFuKTtcbiAgICBjb25zdCBfMm5fcG93X2MxID0gXzJuX3Bvd19jMV8xICogXzJuO1xuICAgIGNvbnN0IGMyID0gKHEgLSBfMW4pIC8gXzJuX3Bvd19jMTsgLy8gMi4gYzIgPSAocSAtIDEpIC8gKDJeYzEpICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGMzID0gKGMyIC0gXzFuKSAvIF8ybjsgLy8gMy4gYzMgPSAoYzIgLSAxKSAvIDIgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM0ID0gXzJuX3Bvd19jMSAtIF8xbjsgLy8gNC4gYzQgPSAyXmMxIC0gMSAgICAgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM1ID0gXzJuX3Bvd19jMV8xOyAvLyA1LiBjNSA9IDJeKGMxIC0gMSkgICAgICAgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM2ID0gRnAucG93KFosIGMyKTsgLy8gNi4gYzYgPSBaXmMyXG4gICAgY29uc3QgYzcgPSBGcC5wb3coWiwgKGMyICsgXzFuKSAvIF8ybik7IC8vIDcuIGM3ID0gWl4oKGMyICsgMSkgLyAyKVxuICAgIGxldCBzcXJ0UmF0aW8gPSAodSwgdikgPT4ge1xuICAgICAgICBsZXQgdHYxID0gYzY7IC8vIDEuIHR2MSA9IGM2XG4gICAgICAgIGxldCB0djIgPSBGcC5wb3codiwgYzQpOyAvLyAyLiB0djIgPSB2XmM0XG4gICAgICAgIGxldCB0djMgPSBGcC5zcXIodHYyKTsgLy8gMy4gdHYzID0gdHYyXjJcbiAgICAgICAgdHYzID0gRnAubXVsKHR2Mywgdik7IC8vIDQuIHR2MyA9IHR2MyAqIHZcbiAgICAgICAgbGV0IHR2NSA9IEZwLm11bCh1LCB0djMpOyAvLyA1LiB0djUgPSB1ICogdHYzXG4gICAgICAgIHR2NSA9IEZwLnBvdyh0djUsIGMzKTsgLy8gNi4gdHY1ID0gdHY1XmMzXG4gICAgICAgIHR2NSA9IEZwLm11bCh0djUsIHR2Mik7IC8vIDcuIHR2NSA9IHR2NSAqIHR2MlxuICAgICAgICB0djIgPSBGcC5tdWwodHY1LCB2KTsgLy8gOC4gdHYyID0gdHY1ICogdlxuICAgICAgICB0djMgPSBGcC5tdWwodHY1LCB1KTsgLy8gOS4gdHYzID0gdHY1ICogdVxuICAgICAgICBsZXQgdHY0ID0gRnAubXVsKHR2MywgdHYyKTsgLy8gMTAuIHR2NCA9IHR2MyAqIHR2MlxuICAgICAgICB0djUgPSBGcC5wb3codHY0LCBjNSk7IC8vIDExLiB0djUgPSB0djReYzVcbiAgICAgICAgbGV0IGlzUVIgPSBGcC5lcWwodHY1LCBGcC5PTkUpOyAvLyAxMi4gaXNRUiA9IHR2NSA9PSAxXG4gICAgICAgIHR2MiA9IEZwLm11bCh0djMsIGM3KTsgLy8gMTMuIHR2MiA9IHR2MyAqIGM3XG4gICAgICAgIHR2NSA9IEZwLm11bCh0djQsIHR2MSk7IC8vIDE0LiB0djUgPSB0djQgKiB0djFcbiAgICAgICAgdHYzID0gRnAuY21vdih0djIsIHR2MywgaXNRUik7IC8vIDE1LiB0djMgPSBDTU9WKHR2MiwgdHYzLCBpc1FSKVxuICAgICAgICB0djQgPSBGcC5jbW92KHR2NSwgdHY0LCBpc1FSKTsgLy8gMTYuIHR2NCA9IENNT1YodHY1LCB0djQsIGlzUVIpXG4gICAgICAgIC8vIDE3LiBmb3IgaSBpbiAoYzEsIGMxIC0gMSwgLi4uLCAyKTpcbiAgICAgICAgZm9yIChsZXQgaSA9IGMxOyBpID4gXzFuOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCB0djUgPSBpIC0gXzJuOyAvLyAxOC4gICAgdHY1ID0gaSAtIDJcbiAgICAgICAgICAgIHR2NSA9IF8ybiA8PCAodHY1IC0gXzFuKTsgLy8gMTkuICAgIHR2NSA9IDJedHY1XG4gICAgICAgICAgICBsZXQgdHZ2NSA9IEZwLnBvdyh0djQsIHR2NSk7IC8vIDIwLiAgICB0djUgPSB0djRedHY1XG4gICAgICAgICAgICBjb25zdCBlMSA9IEZwLmVxbCh0dnY1LCBGcC5PTkUpOyAvLyAyMS4gICAgZTEgPSB0djUgPT0gMVxuICAgICAgICAgICAgdHYyID0gRnAubXVsKHR2MywgdHYxKTsgLy8gMjIuICAgIHR2MiA9IHR2MyAqIHR2MVxuICAgICAgICAgICAgdHYxID0gRnAubXVsKHR2MSwgdHYxKTsgLy8gMjMuICAgIHR2MSA9IHR2MSAqIHR2MVxuICAgICAgICAgICAgdHZ2NSA9IEZwLm11bCh0djQsIHR2MSk7IC8vIDI0LiAgICB0djUgPSB0djQgKiB0djFcbiAgICAgICAgICAgIHR2MyA9IEZwLmNtb3YodHYyLCB0djMsIGUxKTsgLy8gMjUuICAgIHR2MyA9IENNT1YodHYyLCB0djMsIGUxKVxuICAgICAgICAgICAgdHY0ID0gRnAuY21vdih0dnY1LCB0djQsIGUxKTsgLy8gMjYuICAgIHR2NCA9IENNT1YodHY1LCB0djQsIGUxKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGlzUVIsIHZhbHVlOiB0djMgfTtcbiAgICB9O1xuICAgIGlmIChGcC5PUkRFUiAlIF80biA9PT0gXzNuKSB7XG4gICAgICAgIC8vIHNxcnRfcmF0aW9fM21vZDQodSwgdilcbiAgICAgICAgY29uc3QgYzEgPSAoRnAuT1JERVIgLSBfM24pIC8gXzRuOyAvLyAxLiBjMSA9IChxIC0gMykgLyA0ICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgICAgICBjb25zdCBjMiA9IEZwLnNxcnQoRnAubmVnKFopKTsgLy8gMi4gYzIgPSBzcXJ0KC1aKVxuICAgICAgICBzcXJ0UmF0aW8gPSAodSwgdikgPT4ge1xuICAgICAgICAgICAgbGV0IHR2MSA9IEZwLnNxcih2KTsgLy8gMS4gdHYxID0gdl4yXG4gICAgICAgICAgICBjb25zdCB0djIgPSBGcC5tdWwodSwgdik7IC8vIDIuIHR2MiA9IHUgKiB2XG4gICAgICAgICAgICB0djEgPSBGcC5tdWwodHYxLCB0djIpOyAvLyAzLiB0djEgPSB0djEgKiB0djJcbiAgICAgICAgICAgIGxldCB5MSA9IEZwLnBvdyh0djEsIGMxKTsgLy8gNC4geTEgPSB0djFeYzFcbiAgICAgICAgICAgIHkxID0gRnAubXVsKHkxLCB0djIpOyAvLyA1LiB5MSA9IHkxICogdHYyXG4gICAgICAgICAgICBjb25zdCB5MiA9IEZwLm11bCh5MSwgYzIpOyAvLyA2LiB5MiA9IHkxICogYzJcbiAgICAgICAgICAgIGNvbnN0IHR2MyA9IEZwLm11bChGcC5zcXIoeTEpLCB2KTsgLy8gNy4gdHYzID0geTFeMjsgOC4gdHYzID0gdHYzICogdlxuICAgICAgICAgICAgY29uc3QgaXNRUiA9IEZwLmVxbCh0djMsIHUpOyAvLyA5LiBpc1FSID0gdHYzID09IHVcbiAgICAgICAgICAgIGxldCB5ID0gRnAuY21vdih5MiwgeTEsIGlzUVIpOyAvLyAxMC4geSA9IENNT1YoeTIsIHkxLCBpc1FSKVxuICAgICAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogaXNRUiwgdmFsdWU6IHkgfTsgLy8gMTEuIHJldHVybiAoaXNRUiwgeSkgaXNRUiA/IHkgOiB5KmMyXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIE5vIGN1cnZlcyB1c2VzIHRoYXRcbiAgICAvLyBpZiAoRnAuT1JERVIgJSBfOG4gPT09IF81bikgLy8gc3FydF9yYXRpb181bW9kOFxuICAgIHJldHVybiBzcXJ0UmF0aW87XG59XG4vKipcbiAqIFNpbXBsaWZpZWQgU2hhbGx1ZS12YW4gZGUgV29lc3Rpam5lLVVsYXMgTWV0aG9kXG4gKiBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTYuNi4yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBUb0N1cnZlU2ltcGxlU1dVKEZwLCBvcHRzKSB7XG4gICAgdmFsaWRhdGVGaWVsZChGcCk7XG4gICAgaWYgKCFGcC5pc1ZhbGlkKG9wdHMuQSkgfHwgIUZwLmlzVmFsaWQob3B0cy5CKSB8fCAhRnAuaXNWYWxpZChvcHRzLlopKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcFRvQ3VydmVTaW1wbGVTV1U6IGludmFsaWQgb3B0cycpO1xuICAgIGNvbnN0IHNxcnRSYXRpbyA9IFNXVUZwU3FydFJhdGlvKEZwLCBvcHRzLlopO1xuICAgIGlmICghRnAuaXNPZGQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRnAuaXNPZGQgaXMgbm90IGltcGxlbWVudGVkIScpO1xuICAgIC8vIElucHV0OiB1LCBhbiBlbGVtZW50IG9mIEYuXG4gICAgLy8gT3V0cHV0OiAoeCwgeSksIGEgcG9pbnQgb24gRS5cbiAgICByZXR1cm4gKHUpID0+IHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGxldCB0djEsIHR2MiwgdHYzLCB0djQsIHR2NSwgdHY2LCB4LCB5O1xuICAgICAgICB0djEgPSBGcC5zcXIodSk7IC8vIDEuICB0djEgPSB1XjJcbiAgICAgICAgdHYxID0gRnAubXVsKHR2MSwgb3B0cy5aKTsgLy8gMi4gIHR2MSA9IFogKiB0djFcbiAgICAgICAgdHYyID0gRnAuc3FyKHR2MSk7IC8vIDMuICB0djIgPSB0djFeMlxuICAgICAgICB0djIgPSBGcC5hZGQodHYyLCB0djEpOyAvLyA0LiAgdHYyID0gdHYyICsgdHYxXG4gICAgICAgIHR2MyA9IEZwLmFkZCh0djIsIEZwLk9ORSk7IC8vIDUuICB0djMgPSB0djIgKyAxXG4gICAgICAgIHR2MyA9IEZwLm11bCh0djMsIG9wdHMuQik7IC8vIDYuICB0djMgPSBCICogdHYzXG4gICAgICAgIHR2NCA9IEZwLmNtb3Yob3B0cy5aLCBGcC5uZWcodHYyKSwgIUZwLmVxbCh0djIsIEZwLlpFUk8pKTsgLy8gNy4gIHR2NCA9IENNT1YoWiwgLXR2MiwgdHYyICE9IDApXG4gICAgICAgIHR2NCA9IEZwLm11bCh0djQsIG9wdHMuQSk7IC8vIDguICB0djQgPSBBICogdHY0XG4gICAgICAgIHR2MiA9IEZwLnNxcih0djMpOyAvLyA5LiAgdHYyID0gdHYzXjJcbiAgICAgICAgdHY2ID0gRnAuc3FyKHR2NCk7IC8vIDEwLiB0djYgPSB0djReMlxuICAgICAgICB0djUgPSBGcC5tdWwodHY2LCBvcHRzLkEpOyAvLyAxMS4gdHY1ID0gQSAqIHR2NlxuICAgICAgICB0djIgPSBGcC5hZGQodHYyLCB0djUpOyAvLyAxMi4gdHYyID0gdHYyICsgdHY1XG4gICAgICAgIHR2MiA9IEZwLm11bCh0djIsIHR2Myk7IC8vIDEzLiB0djIgPSB0djIgKiB0djNcbiAgICAgICAgdHY2ID0gRnAubXVsKHR2NiwgdHY0KTsgLy8gMTQuIHR2NiA9IHR2NiAqIHR2NFxuICAgICAgICB0djUgPSBGcC5tdWwodHY2LCBvcHRzLkIpOyAvLyAxNS4gdHY1ID0gQiAqIHR2NlxuICAgICAgICB0djIgPSBGcC5hZGQodHYyLCB0djUpOyAvLyAxNi4gdHYyID0gdHYyICsgdHY1XG4gICAgICAgIHggPSBGcC5tdWwodHYxLCB0djMpOyAvLyAxNy4gICB4ID0gdHYxICogdHYzXG4gICAgICAgIGNvbnN0IHsgaXNWYWxpZCwgdmFsdWUgfSA9IHNxcnRSYXRpbyh0djIsIHR2Nik7IC8vIDE4LiAoaXNfZ3gxX3NxdWFyZSwgeTEpID0gc3FydF9yYXRpbyh0djIsIHR2NilcbiAgICAgICAgeSA9IEZwLm11bCh0djEsIHUpOyAvLyAxOS4gICB5ID0gdHYxICogdSAgLT4gWiAqIHVeMyAqIHkxXG4gICAgICAgIHkgPSBGcC5tdWwoeSwgdmFsdWUpOyAvLyAyMC4gICB5ID0geSAqIHkxXG4gICAgICAgIHggPSBGcC5jbW92KHgsIHR2MywgaXNWYWxpZCk7IC8vIDIxLiAgIHggPSBDTU9WKHgsIHR2MywgaXNfZ3gxX3NxdWFyZSlcbiAgICAgICAgeSA9IEZwLmNtb3YoeSwgdmFsdWUsIGlzVmFsaWQpOyAvLyAyMi4gICB5ID0gQ01PVih5LCB5MSwgaXNfZ3gxX3NxdWFyZSlcbiAgICAgICAgY29uc3QgZTEgPSBGcC5pc09kZCh1KSA9PT0gRnAuaXNPZGQoeSk7IC8vIDIzLiAgZTEgPSBzZ24wKHUpID09IHNnbjAoeSlcbiAgICAgICAgeSA9IEZwLmNtb3YoRnAubmVnKHkpLCB5LCBlMSk7IC8vIDI0LiAgIHkgPSBDTU9WKC15LCB5LCBlMSlcbiAgICAgICAgeCA9IEZwLmRpdih4LCB0djQpOyAvLyAyNS4gICB4ID0geCAvIHR2NFxuICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdlaWVyc3RyYXNzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/weierstrass.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/esm/secp256k1.js":
/*!*****************************************************!*\
  !*** ./node_modules/@noble/curves/esm/secp256k1.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encodeToCurve: () => (/* binding */ encodeToCurve),\n/* harmony export */   hashToCurve: () => (/* binding */ hashToCurve),\n/* harmony export */   schnorr: () => (/* binding */ schnorr),\n/* harmony export */   secp256k1: () => (/* binding */ secp256k1)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/utils */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_shortw_utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/_shortw_utils.js\");\n/* harmony import */ var _abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./abstract/hash-to-curve.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/hash-to-curve.js\");\n/* harmony import */ var _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract/modular.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./abstract/utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/**\n * NIST secp256k1. See [pdf](https://www.secg.org/sec2-v2.pdf).\n *\n * Seems to be rigid (not backdoored)\n * [as per discussion](https://bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975).\n *\n * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n * [See explanation](https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066).\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\n\n\n\n\n\nconst secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');\nconst secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst divNearest = (a, b) => (a + b / _2n) / b;\n/**\n * ‚àön = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */\nfunction sqrtMod(y) {\n    const P = secp256k1P;\n    // prettier-ignore\n    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n    // prettier-ignore\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n    const b2 = (y * y * y) % P; // x^3, 11\n    const b3 = (b2 * b2 * y) % P; // x^7\n    const b6 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b3, _3n, P) * b3) % P;\n    const b9 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b6, _3n, P) * b3) % P;\n    const b11 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b9, _2n, P) * b2) % P;\n    const b22 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b11, _11n, P) * b11) % P;\n    const b44 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b22, _22n, P) * b22) % P;\n    const b88 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b44, _44n, P) * b44) % P;\n    const b176 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b88, _88n, P) * b88) % P;\n    const b220 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b176, _44n, P) * b44) % P;\n    const b223 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b220, _3n, P) * b3) % P;\n    const t1 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b223, _23n, P) * b22) % P;\n    const t2 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(t1, _6n, P) * b2) % P;\n    const root = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(t2, _2n, P);\n    if (!Fpk1.eql(Fpk1.sqr(root), y))\n        throw new Error('Cannot find square root');\n    return root;\n}\nconst Fpk1 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field)(secp256k1P, undefined, undefined, { sqrt: sqrtMod });\n/**\n * secp256k1 short weierstrass curve and ECDSA signatures over it.\n *\n * @example\n * import { secp256k1 } from '@noble/curves/secp256k1';\n *\n * const priv = secp256k1.utils.randomPrivateKey();\n * const pub = secp256k1.getPublicKey(priv);\n * const msg = new Uint8Array(32).fill(1); // message hash (not message) in ecdsa\n * const sig = secp256k1.sign(msg, priv); // `{prehash: true}` option is available\n * const isValid = secp256k1.verify(sig, msg, pub) === true;\n */\nconst secp256k1 = (0,_shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__.createCurve)({\n    a: BigInt(0), // equation params: a, b\n    b: BigInt(7),\n    Fp: Fpk1, // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n\n    n: secp256k1N, // Curve order, total count of valid points in the field\n    // Base point (x, y) aka generator point\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    h: BigInt(1), // Cofactor\n    lowS: true, // Allow only low-S signatures by default in sign() and verify()\n    endo: {\n        // Endomorphism, see above\n        beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n        splitScalar: (k) => {\n            const n = secp256k1N;\n            const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n            const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n            const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n            const b2 = a1;\n            const POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)\n            const c1 = divNearest(b2 * k, n);\n            const c2 = divNearest(-b1 * k, n);\n            let k1 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(k - c1 * a1 - c2 * a2, n);\n            let k2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(-c1 * b1 - c2 * b2, n);\n            const k1neg = k1 > POW_2_128;\n            const k2neg = k2 > POW_2_128;\n            if (k1neg)\n                k1 = n - k1;\n            if (k2neg)\n                k2 = n - k2;\n            if (k1 > POW_2_128 || k2 > POW_2_128) {\n                throw new Error('splitScalar: Endomorphism failed, k=' + k);\n            }\n            return { k1neg, k1, k2neg, k2 };\n        },\n    },\n}, _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256);\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\nconst _0n = BigInt(0);\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\nconst TAGGED_HASH_PREFIXES = {};\nfunction taggedHash(tag, ...messages) {\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n        const tagH = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256)(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n        tagP = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(tagH, tagH);\n        TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    return (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256)((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(tagP, ...messages));\n}\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point) => point.toRawBytes(true).slice(1);\nconst numTo32b = (n) => (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.numberToBytesBE)(n, 32);\nconst modP = (x) => (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x, secp256k1P);\nconst modN = (x) => (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x, secp256k1N);\nconst Point = secp256k1.ProjectivePoint;\nconst GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv) {\n    let d_ = secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\n    let p = Point.fromPrivateKey(d_); // P = d'‚ãÖG; 0 < d' < n check is done inside\n    const scalar = p.hasEvenY() ? d_ : modN(-d_);\n    return { scalar: scalar, bytes: pointToBytes(p) };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */\nfunction lift_x(x) {\n    (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.aInRange)('x', x, _1n, secp256k1P); // Fail if x ‚â• p.\n    const xx = modP(x * x);\n    const c = modP(xx * x + BigInt(7)); // Let c = x¬≥ + 7 mod p.\n    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n    if (y % _2n !== _0n)\n        y = modP(-y); // Return the unique point P such that x(P) = x and\n    const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n    p.assertValidity();\n    return p;\n}\nconst num = _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE;\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */\nfunction challenge(...args) {\n    return modN(num(taggedHash('BIP0340/challenge', ...args)));\n}\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */\nfunction schnorrGetPublicKey(privateKey) {\n    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'‚â•n. Ret bytes(d'‚ãÖG)\n}\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */\nfunction schnorrSign(message, privateKey, auxRand = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__.randomBytes)(32)) {\n    const m = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('message', message);\n    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\n    const a = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array\n    const t = numTo32b(d ^ num(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n    const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n    const k_ = modN(num(rand)); // Let k' = int(rand) mod n\n    if (k_ === _0n)\n        throw new Error('sign failed: k is zero'); // Fail if k' = 0.\n    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'‚ãÖG.\n    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n    sig.set(rx, 0);\n    sig.set(numTo32b(modN(k + e * d)), 32);\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n    if (!schnorrVerify(sig, m, px))\n        throw new Error('sign: Invalid signature produced');\n    return sig;\n}\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */\nfunction schnorrVerify(signature, message, publicKey) {\n    const sig = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('signature', signature, 64);\n    const m = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('message', message);\n    const pub = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('publicKey', publicKey, 32);\n    try {\n        const P = lift_x(num(pub)); // P = lift_x(int(pk)); fail if that fails\n        const r = num(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r ‚â• p.\n        if (!(0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.inRange)(r, _1n, secp256k1P))\n            return false;\n        const s = num(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s ‚â• n.\n        if (!(0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.inRange)(s, _1n, secp256k1N))\n            return false;\n        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n        const R = GmulAdd(P, s, modN(-e)); // R = s‚ãÖG - e‚ãÖP\n        if (!R || !R.hasEvenY() || R.toAffine().x !== r)\n            return false; // -eP == (n-e)P\n        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R) ‚â† r.\n    }\n    catch (error) {\n        return false;\n    }\n}\n/**\n * Schnorr signatures over secp256k1.\n * https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n * @example\n * import { schnorr } from '@noble/curves/secp256k1';\n * const priv = schnorr.utils.randomPrivateKey();\n * const pub = schnorr.getPublicKey(priv);\n * const msg = new TextEncoder().encode('hello');\n * const sig = schnorr.sign(msg, priv);\n * const isValid = schnorr.verify(sig, msg, pub);\n */\nconst schnorr = /* @__PURE__ */ (() => ({\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n    utils: {\n        randomPrivateKey: secp256k1.utils.randomPrivateKey,\n        lift_x,\n        pointToBytes,\n        numberToBytesBE: _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.numberToBytesBE,\n        bytesToNumberBE: _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE,\n        taggedHash,\n        mod: _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod,\n    },\n}))();\nconst isoMap = /* @__PURE__ */ (() => (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.isogenyMap)(Fpk1, [\n    // xNum\n    [\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',\n        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',\n        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',\n    ],\n    // xDen\n    [\n        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',\n        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n    // yNum\n    [\n        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',\n        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',\n        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',\n        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',\n    ],\n    // yDen\n    [\n        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',\n        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',\n        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n].map((i) => i.map((j) => BigInt(j)))))();\nconst mapSWU = /* @__PURE__ */ (() => (0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_6__.mapToCurveSimpleSWU)(Fpk1, {\n    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),\n    B: BigInt('1771'),\n    Z: Fpk1.create(BigInt('-11')),\n}))();\nconst htf = /* @__PURE__ */ (() => (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.createHasher)(secp256k1.ProjectivePoint, (scalars) => {\n    const { x, y } = mapSWU(Fpk1.create(scalars[0]));\n    return isoMap(x, y);\n}, {\n    DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',\n    encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',\n    p: Fpk1.ORDER,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256,\n}))();\n/** secp256k1 hash-to-curve from [RFC 9380](https://www.rfc-editor.org/rfc/rfc9380). */\nconst hashToCurve = /* @__PURE__ */ (() => htf.hashToCurve)();\n/** secp256k1 encode-to-curve from [RFC 9380](https://www.rfc-editor.org/rfc/rfc9380). */\nconst encodeToCurve = /* @__PURE__ */ (() => htf.encodeToCurve)();\n//# sourceMappingURL=secp256k1.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9zZWNwMjU2azEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM4QztBQUNJO0FBQ0Q7QUFDc0I7QUFDZDtBQUM0RDtBQUNyRDtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsa0NBQWtDO0FBQ2xDLGdCQUFnQiwwREFBSTtBQUNwQixnQkFBZ0IsMERBQUk7QUFDcEIsaUJBQWlCLDBEQUFJO0FBQ3JCLGlCQUFpQiwwREFBSTtBQUNyQixpQkFBaUIsMERBQUk7QUFDckIsaUJBQWlCLDBEQUFJO0FBQ3JCLGtCQUFrQiwwREFBSTtBQUN0QixrQkFBa0IsMERBQUk7QUFDdEIsa0JBQWtCLDBEQUFJO0FBQ3RCLGdCQUFnQiwwREFBSTtBQUNwQixnQkFBZ0IsMERBQUk7QUFDcEIsaUJBQWlCLDBEQUFJO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSwyREFBSyxxQ0FBcUMsZUFBZTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0MsMENBQTBDLEtBQUssY0FBYztBQUM3RDtBQUNBO0FBQ08sa0JBQWtCLDZEQUFXO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RTtBQUM3RTtBQUNBO0FBQ0EscUJBQXFCLHlEQUFHO0FBQ3hCLHFCQUFxQix5REFBRztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsU0FBUztBQUNULEtBQUs7QUFDTCxDQUFDLEVBQUUsd0RBQU07QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDREQUFNO0FBQzNCLGVBQWUsK0RBQVc7QUFDMUI7QUFDQTtBQUNBLFdBQVcsNERBQU0sQ0FBQywrREFBVztBQUM3QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUVBQWU7QUFDdkMsb0JBQW9CLHlEQUFHO0FBQ3ZCLG9CQUFvQix5REFBRztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCxzQ0FBc0MsYUFBYTtBQUNuRDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDREQUFRLDJCQUEyQjtBQUN2QztBQUNBLHdDQUF3QztBQUN4Qyx3QkFBd0I7QUFDeEI7QUFDQSxzQkFBc0I7QUFDdEIsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0RBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxnRUFBVztBQUMvRCxjQUFjLCtEQUFXO0FBQ3pCLFlBQVksdUJBQXVCLG1DQUFtQztBQUN0RSxjQUFjLCtEQUFXLDBCQUEwQjtBQUNuRCwrREFBK0Q7QUFDL0Qsd0RBQXdEO0FBQ3hELGdDQUFnQztBQUNoQztBQUNBLG1EQUFtRDtBQUNuRCxZQUFZLHVCQUF1QiwyQkFBMkI7QUFDOUQsb0NBQW9DO0FBQ3BDLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0RBQVc7QUFDM0IsY0FBYywrREFBVztBQUN6QixnQkFBZ0IsK0RBQVc7QUFDM0I7QUFDQSxvQ0FBb0Msd0JBQXdCO0FBQzVELDRDQUE0QywyQkFBMkI7QUFDdkUsYUFBYSwyREFBTztBQUNwQjtBQUNBLDZDQUE2Qyw0QkFBNEI7QUFDekUsYUFBYSwyREFBTztBQUNwQjtBQUNBLDhEQUE4RDtBQUM5RCwyQ0FBMkM7QUFDM0M7QUFDQSwwQkFBMEI7QUFDMUIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLHVCQUF1QjtBQUN2QjtBQUNBLFdBQVc7QUFDWCxLQUFLO0FBQ0wsQ0FBQztBQUNELHNDQUFzQyxzRUFBVTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyw2RUFBbUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG1DQUFtQyx3RUFBWTtBQUMvQyxZQUFZLE9BQU87QUFDbkI7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx3REFBTTtBQUNoQixDQUFDO0FBQ0Q7QUFDTztBQUNQO0FBQ087QUFDUCIsInNvdXJjZXMiOlsiL2hvbWUvbGZnL0dpdC9NYWR0cmlwcy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vc2VjcDI1NmsxLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTklTVCBzZWNwMjU2azEuIFNlZSBbcGRmXShodHRwczovL3d3dy5zZWNnLm9yZy9zZWMyLXYyLnBkZikuXG4gKlxuICogU2VlbXMgdG8gYmUgcmlnaWQgKG5vdCBiYWNrZG9vcmVkKVxuICogW2FzIHBlciBkaXNjdXNzaW9uXShodHRwczovL2JpdGNvaW50YWxrLm9yZy9pbmRleC5waHA/dG9waWM9Mjg5Nzk1Lm1zZzMxODM5NzUjbXNnMzE4Mzk3NSkuXG4gKlxuICogc2VjcDI1NmsxIGJlbG9uZ3MgdG8gS29ibGl0eiBjdXJ2ZXM6IGl0IGhhcyBlZmZpY2llbnRseSBjb21wdXRhYmxlIGVuZG9tb3JwaGlzbS5cbiAqIEVuZG9tb3JwaGlzbSB1c2VzIDJ4IGxlc3MgUkFNLCBzcGVlZHMgdXAgcHJlY29tcHV0YXRpb24gYnkgMnggYW5kIEVDREggLyBrZXkgcmVjb3ZlcnkgYnkgMjAlLlxuICogRm9yIHByZWNvbXB1dGVkIHdOQUYgaXQgdHJhZGVzIG9mZiAxLzIgaW5pdCB0aW1lICYgMS8zIHJhbSBmb3IgMjAlIHBlcmYgaGl0LlxuICogW1NlZSBleHBsYW5hdGlvbl0oaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vcGF1bG1pbGxyL2ViNjcwODA2NzkzZTg0ZGY2MjhhN2M0MzRhODczMDY2KS5cbiAqIEBtb2R1bGVcbiAqL1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9zaGEyNTYnO1xuaW1wb3J0IHsgcmFuZG9tQnl0ZXMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3V0aWxzJztcbmltcG9ydCB7IGNyZWF0ZUN1cnZlIH0gZnJvbSAnLi9fc2hvcnR3X3V0aWxzLmpzJztcbmltcG9ydCB7IGNyZWF0ZUhhc2hlciwgaXNvZ2VueU1hcCB9IGZyb20gJy4vYWJzdHJhY3QvaGFzaC10by1jdXJ2ZS5qcyc7XG5pbXBvcnQgeyBGaWVsZCwgbW9kLCBwb3cyIH0gZnJvbSAnLi9hYnN0cmFjdC9tb2R1bGFyLmpzJztcbmltcG9ydCB7IGFJblJhbmdlLCBieXRlc1RvTnVtYmVyQkUsIGNvbmNhdEJ5dGVzLCBlbnN1cmVCeXRlcywgaW5SYW5nZSwgbnVtYmVyVG9CeXRlc0JFLCB9IGZyb20gJy4vYWJzdHJhY3QvdXRpbHMuanMnO1xuaW1wb3J0IHsgbWFwVG9DdXJ2ZVNpbXBsZVNXVSB9IGZyb20gJy4vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanMnO1xuY29uc3Qgc2VjcDI1NmsxUCA9IEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWZmZmZmYzJmJyk7XG5jb25zdCBzZWNwMjU2azFOID0gQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlYmFhZWRjZTZhZjQ4YTAzYmJmZDI1ZThjZDAzNjQxNDEnKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbmNvbnN0IF8ybiA9IEJpZ0ludCgyKTtcbmNvbnN0IGRpdk5lYXJlc3QgPSAoYSwgYikgPT4gKGEgKyBiIC8gXzJuKSAvIGI7XG4vKipcbiAqIOKImm4gPSBuXigocCsxKS80KSBmb3IgZmllbGRzIHAgPSAzIG1vZCA0LiBXZSB1bndyYXAgdGhlIGxvb3AgYW5kIG11bHRpcGx5IGJpdC1ieS1iaXQuXG4gKiAoUCsxbi80bikudG9TdHJpbmcoMikgd291bGQgcHJvZHVjZSBiaXRzIFsyMjN4IDEsIDAsIDIyeCAxLCA0eCAwLCAxMSwgMDBdXG4gKi9cbmZ1bmN0aW9uIHNxcnRNb2QoeSkge1xuICAgIGNvbnN0IFAgPSBzZWNwMjU2azFQO1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGNvbnN0IF8zbiA9IEJpZ0ludCgzKSwgXzZuID0gQmlnSW50KDYpLCBfMTFuID0gQmlnSW50KDExKSwgXzIybiA9IEJpZ0ludCgyMik7XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgY29uc3QgXzIzbiA9IEJpZ0ludCgyMyksIF80NG4gPSBCaWdJbnQoNDQpLCBfODhuID0gQmlnSW50KDg4KTtcbiAgICBjb25zdCBiMiA9ICh5ICogeSAqIHkpICUgUDsgLy8geF4zLCAxMVxuICAgIGNvbnN0IGIzID0gKGIyICogYjIgKiB5KSAlIFA7IC8vIHheN1xuICAgIGNvbnN0IGI2ID0gKHBvdzIoYjMsIF8zbiwgUCkgKiBiMykgJSBQO1xuICAgIGNvbnN0IGI5ID0gKHBvdzIoYjYsIF8zbiwgUCkgKiBiMykgJSBQO1xuICAgIGNvbnN0IGIxMSA9IChwb3cyKGI5LCBfMm4sIFApICogYjIpICUgUDtcbiAgICBjb25zdCBiMjIgPSAocG93MihiMTEsIF8xMW4sIFApICogYjExKSAlIFA7XG4gICAgY29uc3QgYjQ0ID0gKHBvdzIoYjIyLCBfMjJuLCBQKSAqIGIyMikgJSBQO1xuICAgIGNvbnN0IGI4OCA9IChwb3cyKGI0NCwgXzQ0biwgUCkgKiBiNDQpICUgUDtcbiAgICBjb25zdCBiMTc2ID0gKHBvdzIoYjg4LCBfODhuLCBQKSAqIGI4OCkgJSBQO1xuICAgIGNvbnN0IGIyMjAgPSAocG93MihiMTc2LCBfNDRuLCBQKSAqIGI0NCkgJSBQO1xuICAgIGNvbnN0IGIyMjMgPSAocG93MihiMjIwLCBfM24sIFApICogYjMpICUgUDtcbiAgICBjb25zdCB0MSA9IChwb3cyKGIyMjMsIF8yM24sIFApICogYjIyKSAlIFA7XG4gICAgY29uc3QgdDIgPSAocG93Mih0MSwgXzZuLCBQKSAqIGIyKSAlIFA7XG4gICAgY29uc3Qgcm9vdCA9IHBvdzIodDIsIF8ybiwgUCk7XG4gICAgaWYgKCFGcGsxLmVxbChGcGsxLnNxcihyb290KSwgeSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICByZXR1cm4gcm9vdDtcbn1cbmNvbnN0IEZwazEgPSBGaWVsZChzZWNwMjU2azFQLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgeyBzcXJ0OiBzcXJ0TW9kIH0pO1xuLyoqXG4gKiBzZWNwMjU2azEgc2hvcnQgd2VpZXJzdHJhc3MgY3VydmUgYW5kIEVDRFNBIHNpZ25hdHVyZXMgb3ZlciBpdC5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgc2VjcDI1NmsxIH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9zZWNwMjU2azEnO1xuICpcbiAqIGNvbnN0IHByaXYgPSBzZWNwMjU2azEudXRpbHMucmFuZG9tUHJpdmF0ZUtleSgpO1xuICogY29uc3QgcHViID0gc2VjcDI1NmsxLmdldFB1YmxpY0tleShwcml2KTtcbiAqIGNvbnN0IG1zZyA9IG5ldyBVaW50OEFycmF5KDMyKS5maWxsKDEpOyAvLyBtZXNzYWdlIGhhc2ggKG5vdCBtZXNzYWdlKSBpbiBlY2RzYVxuICogY29uc3Qgc2lnID0gc2VjcDI1NmsxLnNpZ24obXNnLCBwcml2KTsgLy8gYHtwcmVoYXNoOiB0cnVlfWAgb3B0aW9uIGlzIGF2YWlsYWJsZVxuICogY29uc3QgaXNWYWxpZCA9IHNlY3AyNTZrMS52ZXJpZnkoc2lnLCBtc2csIHB1YikgPT09IHRydWU7XG4gKi9cbmV4cG9ydCBjb25zdCBzZWNwMjU2azEgPSBjcmVhdGVDdXJ2ZSh7XG4gICAgYTogQmlnSW50KDApLCAvLyBlcXVhdGlvbiBwYXJhbXM6IGEsIGJcbiAgICBiOiBCaWdJbnQoNyksXG4gICAgRnA6IEZwazEsIC8vIEZpZWxkJ3MgcHJpbWU6IDJuKioyNTZuIC0gMm4qKjMybiAtIDJuKio5biAtIDJuKio4biAtIDJuKio3biAtIDJuKio2biAtIDJuKio0biAtIDFuXG4gICAgbjogc2VjcDI1NmsxTiwgLy8gQ3VydmUgb3JkZXIsIHRvdGFsIGNvdW50IG9mIHZhbGlkIHBvaW50cyBpbiB0aGUgZmllbGRcbiAgICAvLyBCYXNlIHBvaW50ICh4LCB5KSBha2EgZ2VuZXJhdG9yIHBvaW50XG4gICAgR3g6IEJpZ0ludCgnNTUwNjYyNjMwMjIyNzczNDM2Njk1Nzg3MTg4OTUxNjg1MzQzMjYyNTA2MDM0NTM3Nzc1OTQxNzU1MDAxODczNjAzODkxMTY3MjkyNDAnKSxcbiAgICBHeTogQmlnSW50KCczMjY3MDUxMDAyMDc1ODgxNjk3ODA4MzA4NTEzMDUwNzA0MzE4NDQ3MTI3MzM4MDY1OTI0MzI3NTkzODkwNDMzNTc1NzMzNzQ4MjQyNCcpLFxuICAgIGg6IEJpZ0ludCgxKSwgLy8gQ29mYWN0b3JcbiAgICBsb3dTOiB0cnVlLCAvLyBBbGxvdyBvbmx5IGxvdy1TIHNpZ25hdHVyZXMgYnkgZGVmYXVsdCBpbiBzaWduKCkgYW5kIHZlcmlmeSgpXG4gICAgZW5kbzoge1xuICAgICAgICAvLyBFbmRvbW9ycGhpc20sIHNlZSBhYm92ZVxuICAgICAgICBiZXRhOiBCaWdJbnQoJzB4N2FlOTZhMmI2NTdjMDcxMDZlNjQ0NzllYWMzNDM0ZTk5Y2YwNDk3NTEyZjU4OTk1YzEzOTZjMjg3MTk1MDFlZScpLFxuICAgICAgICBzcGxpdFNjYWxhcjogKGspID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBzZWNwMjU2azFOO1xuICAgICAgICAgICAgY29uc3QgYTEgPSBCaWdJbnQoJzB4MzA4NmQyMjFhN2Q0NmJjZGU4NmM5MGU0OTI4NGViMTUnKTtcbiAgICAgICAgICAgIGNvbnN0IGIxID0gLV8xbiAqIEJpZ0ludCgnMHhlNDQzN2VkNjAxMGU4ODI4NmY1NDdmYTkwYWJmZTRjMycpO1xuICAgICAgICAgICAgY29uc3QgYTIgPSBCaWdJbnQoJzB4MTE0Y2E1MGY3YThlMmYzZjY1N2MxMTA4ZDlkNDRjZmQ4Jyk7XG4gICAgICAgICAgICBjb25zdCBiMiA9IGExO1xuICAgICAgICAgICAgY29uc3QgUE9XXzJfMTI4ID0gQmlnSW50KCcweDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcpOyAvLyAoMm4qKjEyOG4pLnRvU3RyaW5nKDE2KVxuICAgICAgICAgICAgY29uc3QgYzEgPSBkaXZOZWFyZXN0KGIyICogaywgbik7XG4gICAgICAgICAgICBjb25zdCBjMiA9IGRpdk5lYXJlc3QoLWIxICogaywgbik7XG4gICAgICAgICAgICBsZXQgazEgPSBtb2QoayAtIGMxICogYTEgLSBjMiAqIGEyLCBuKTtcbiAgICAgICAgICAgIGxldCBrMiA9IG1vZCgtYzEgKiBiMSAtIGMyICogYjIsIG4pO1xuICAgICAgICAgICAgY29uc3QgazFuZWcgPSBrMSA+IFBPV18yXzEyODtcbiAgICAgICAgICAgIGNvbnN0IGsybmVnID0gazIgPiBQT1dfMl8xMjg7XG4gICAgICAgICAgICBpZiAoazFuZWcpXG4gICAgICAgICAgICAgICAgazEgPSBuIC0gazE7XG4gICAgICAgICAgICBpZiAoazJuZWcpXG4gICAgICAgICAgICAgICAgazIgPSBuIC0gazI7XG4gICAgICAgICAgICBpZiAoazEgPiBQT1dfMl8xMjggfHwgazIgPiBQT1dfMl8xMjgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NwbGl0U2NhbGFyOiBFbmRvbW9ycGhpc20gZmFpbGVkLCBrPScgKyBrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGsxbmVnLCBrMSwgazJuZWcsIGsyIH07XG4gICAgICAgIH0sXG4gICAgfSxcbn0sIHNoYTI1Nik7XG4vLyBTY2hub3JyIHNpZ25hdHVyZXMgYXJlIHN1cGVyaW9yIHRvIEVDRFNBIGZyb20gYWJvdmUuIEJlbG93IGlzIFNjaG5vcnItc3BlY2lmaWMgQklQMDM0MCBjb2RlLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDM0MC5tZWRpYXdpa2lcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbi8qKiBBbiBvYmplY3QgbWFwcGluZyB0YWdzIHRvIHRoZWlyIHRhZ2dlZCBoYXNoIHByZWZpeCBvZiBbU0hBMjU2KHRhZykgfCBTSEEyNTYodGFnKV0gKi9cbmNvbnN0IFRBR0dFRF9IQVNIX1BSRUZJWEVTID0ge307XG5mdW5jdGlvbiB0YWdnZWRIYXNoKHRhZywgLi4ubWVzc2FnZXMpIHtcbiAgICBsZXQgdGFnUCA9IFRBR0dFRF9IQVNIX1BSRUZJWEVTW3RhZ107XG4gICAgaWYgKHRhZ1AgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCB0YWdIID0gc2hhMjU2KFVpbnQ4QXJyYXkuZnJvbSh0YWcsIChjKSA9PiBjLmNoYXJDb2RlQXQoMCkpKTtcbiAgICAgICAgdGFnUCA9IGNvbmNhdEJ5dGVzKHRhZ0gsIHRhZ0gpO1xuICAgICAgICBUQUdHRURfSEFTSF9QUkVGSVhFU1t0YWddID0gdGFnUDtcbiAgICB9XG4gICAgcmV0dXJuIHNoYTI1Nihjb25jYXRCeXRlcyh0YWdQLCAuLi5tZXNzYWdlcykpO1xufVxuLy8gRUNEU0EgY29tcGFjdCBwb2ludHMgYXJlIDMzLWJ5dGUuIFNjaG5vcnIgaXMgMzI6IHdlIHN0cmlwIGZpcnN0IGJ5dGUgMHgwMiBvciAweDAzXG5jb25zdCBwb2ludFRvQnl0ZXMgPSAocG9pbnQpID0+IHBvaW50LnRvUmF3Qnl0ZXModHJ1ZSkuc2xpY2UoMSk7XG5jb25zdCBudW1UbzMyYiA9IChuKSA9PiBudW1iZXJUb0J5dGVzQkUobiwgMzIpO1xuY29uc3QgbW9kUCA9ICh4KSA9PiBtb2QoeCwgc2VjcDI1NmsxUCk7XG5jb25zdCBtb2ROID0gKHgpID0+IG1vZCh4LCBzZWNwMjU2azFOKTtcbmNvbnN0IFBvaW50ID0gc2VjcDI1NmsxLlByb2plY3RpdmVQb2ludDtcbmNvbnN0IEdtdWxBZGQgPSAoUSwgYSwgYikgPT4gUG9pbnQuQkFTRS5tdWx0aXBseUFuZEFkZFVuc2FmZShRLCBhLCBiKTtcbi8vIENhbGN1bGF0ZSBwb2ludCwgc2NhbGFyIGFuZCBieXRlc1xuZnVuY3Rpb24gc2Nobm9yckdldEV4dFB1YktleShwcml2KSB7XG4gICAgbGV0IGRfID0gc2VjcDI1NmsxLnV0aWxzLm5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdik7IC8vIHNhbWUgbWV0aG9kIGV4ZWN1dGVkIGluIGZyb21Qcml2YXRlS2V5XG4gICAgbGV0IHAgPSBQb2ludC5mcm9tUHJpdmF0ZUtleShkXyk7IC8vIFAgPSBkJ+KLhUc7IDAgPCBkJyA8IG4gY2hlY2sgaXMgZG9uZSBpbnNpZGVcbiAgICBjb25zdCBzY2FsYXIgPSBwLmhhc0V2ZW5ZKCkgPyBkXyA6IG1vZE4oLWRfKTtcbiAgICByZXR1cm4geyBzY2FsYXI6IHNjYWxhciwgYnl0ZXM6IHBvaW50VG9CeXRlcyhwKSB9O1xufVxuLyoqXG4gKiBsaWZ0X3ggZnJvbSBCSVAzNDAuIENvbnZlcnQgMzItYnl0ZSB4IGNvb3JkaW5hdGUgdG8gZWxsaXB0aWMgY3VydmUgcG9pbnQuXG4gKiBAcmV0dXJucyB2YWxpZCBwb2ludCBjaGVja2VkIGZvciBiZWluZyBvbi1jdXJ2ZVxuICovXG5mdW5jdGlvbiBsaWZ0X3goeCkge1xuICAgIGFJblJhbmdlKCd4JywgeCwgXzFuLCBzZWNwMjU2azFQKTsgLy8gRmFpbCBpZiB4IOKJpSBwLlxuICAgIGNvbnN0IHh4ID0gbW9kUCh4ICogeCk7XG4gICAgY29uc3QgYyA9IG1vZFAoeHggKiB4ICsgQmlnSW50KDcpKTsgLy8gTGV0IGMgPSB4wrMgKyA3IG1vZCBwLlxuICAgIGxldCB5ID0gc3FydE1vZChjKTsgLy8gTGV0IHkgPSBjXihwKzEpLzQgbW9kIHAuXG4gICAgaWYgKHkgJSBfMm4gIT09IF8wbilcbiAgICAgICAgeSA9IG1vZFAoLXkpOyAvLyBSZXR1cm4gdGhlIHVuaXF1ZSBwb2ludCBQIHN1Y2ggdGhhdCB4KFApID0geCBhbmRcbiAgICBjb25zdCBwID0gbmV3IFBvaW50KHgsIHksIF8xbik7IC8vIHkoUCkgPSB5IGlmIHkgbW9kIDIgPSAwIG9yIHkoUCkgPSBwLXkgb3RoZXJ3aXNlLlxuICAgIHAuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICByZXR1cm4gcDtcbn1cbmNvbnN0IG51bSA9IGJ5dGVzVG9OdW1iZXJCRTtcbi8qKlxuICogQ3JlYXRlIHRhZ2dlZCBoYXNoLCBjb252ZXJ0IGl0IHRvIGJpZ2ludCwgcmVkdWNlIG1vZHVsby1uLlxuICovXG5mdW5jdGlvbiBjaGFsbGVuZ2UoLi4uYXJncykge1xuICAgIHJldHVybiBtb2ROKG51bSh0YWdnZWRIYXNoKCdCSVAwMzQwL2NoYWxsZW5nZScsIC4uLmFyZ3MpKSk7XG59XG4vKipcbiAqIFNjaG5vcnIgcHVibGljIGtleSBpcyBqdXN0IGB4YCBjb29yZGluYXRlIG9mIFBvaW50IGFzIHBlciBCSVAzNDAuXG4gKi9cbmZ1bmN0aW9uIHNjaG5vcnJHZXRQdWJsaWNLZXkocHJpdmF0ZUtleSkge1xuICAgIHJldHVybiBzY2hub3JyR2V0RXh0UHViS2V5KHByaXZhdGVLZXkpLmJ5dGVzOyAvLyBkJz1pbnQoc2spLiBGYWlsIGlmIGQnPTAgb3IgZCfiiaVuLiBSZXQgYnl0ZXMoZCfii4VHKVxufVxuLyoqXG4gKiBDcmVhdGVzIFNjaG5vcnIgc2lnbmF0dXJlIGFzIHBlciBCSVAzNDAuIFZlcmlmaWVzIGl0c2VsZiBiZWZvcmUgcmV0dXJuaW5nIGFueXRoaW5nLlxuICogYXV4UmFuZCBpcyBvcHRpb25hbCBhbmQgaXMgbm90IHRoZSBzb2xlIHNvdXJjZSBvZiBrIGdlbmVyYXRpb246IGJhZCBDU1BSTkcgd29uJ3QgYmUgZGFuZ2Vyb3VzLlxuICovXG5mdW5jdGlvbiBzY2hub3JyU2lnbihtZXNzYWdlLCBwcml2YXRlS2V5LCBhdXhSYW5kID0gcmFuZG9tQnl0ZXMoMzIpKSB7XG4gICAgY29uc3QgbSA9IGVuc3VyZUJ5dGVzKCdtZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgY29uc3QgeyBieXRlczogcHgsIHNjYWxhcjogZCB9ID0gc2Nobm9yckdldEV4dFB1YktleShwcml2YXRlS2V5KTsgLy8gY2hlY2tzIGZvciBpc1dpdGhpbkN1cnZlT3JkZXJcbiAgICBjb25zdCBhID0gZW5zdXJlQnl0ZXMoJ2F1eFJhbmQnLCBhdXhSYW5kLCAzMik7IC8vIEF1eGlsaWFyeSByYW5kb20gZGF0YSBhOiBhIDMyLWJ5dGUgYXJyYXlcbiAgICBjb25zdCB0ID0gbnVtVG8zMmIoZCBeIG51bSh0YWdnZWRIYXNoKCdCSVAwMzQwL2F1eCcsIGEpKSk7IC8vIExldCB0IGJlIHRoZSBieXRlLXdpc2UgeG9yIG9mIGJ5dGVzKGQpIGFuZCBoYXNoL2F1eChhKVxuICAgIGNvbnN0IHJhbmQgPSB0YWdnZWRIYXNoKCdCSVAwMzQwL25vbmNlJywgdCwgcHgsIG0pOyAvLyBMZXQgcmFuZCA9IGhhc2gvbm9uY2UodCB8fCBieXRlcyhQKSB8fCBtKVxuICAgIGNvbnN0IGtfID0gbW9kTihudW0ocmFuZCkpOyAvLyBMZXQgaycgPSBpbnQocmFuZCkgbW9kIG5cbiAgICBpZiAoa18gPT09IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduIGZhaWxlZDogayBpcyB6ZXJvJyk7IC8vIEZhaWwgaWYgaycgPSAwLlxuICAgIGNvbnN0IHsgYnl0ZXM6IHJ4LCBzY2FsYXI6IGsgfSA9IHNjaG5vcnJHZXRFeHRQdWJLZXkoa18pOyAvLyBMZXQgUiA9IGsn4ouFRy5cbiAgICBjb25zdCBlID0gY2hhbGxlbmdlKHJ4LCBweCwgbSk7IC8vIExldCBlID0gaW50KGhhc2gvY2hhbGxlbmdlKGJ5dGVzKFIpIHx8IGJ5dGVzKFApIHx8IG0pKSBtb2Qgbi5cbiAgICBjb25zdCBzaWcgPSBuZXcgVWludDhBcnJheSg2NCk7IC8vIExldCBzaWcgPSBieXRlcyhSKSB8fCBieXRlcygoayArIGVkKSBtb2QgbikuXG4gICAgc2lnLnNldChyeCwgMCk7XG4gICAgc2lnLnNldChudW1UbzMyYihtb2ROKGsgKyBlICogZCkpLCAzMik7XG4gICAgLy8gSWYgVmVyaWZ5KGJ5dGVzKFApLCBtLCBzaWcpIChzZWUgYmVsb3cpIHJldHVybnMgZmFpbHVyZSwgYWJvcnRcbiAgICBpZiAoIXNjaG5vcnJWZXJpZnkoc2lnLCBtLCBweCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbjogSW52YWxpZCBzaWduYXR1cmUgcHJvZHVjZWQnKTtcbiAgICByZXR1cm4gc2lnO1xufVxuLyoqXG4gKiBWZXJpZmllcyBTY2hub3JyIHNpZ25hdHVyZS5cbiAqIFdpbGwgc3dhbGxvdyBlcnJvcnMgJiByZXR1cm4gZmFsc2UgZXhjZXB0IGZvciBpbml0aWFsIHR5cGUgdmFsaWRhdGlvbiBvZiBhcmd1bWVudHMuXG4gKi9cbmZ1bmN0aW9uIHNjaG5vcnJWZXJpZnkoc2lnbmF0dXJlLCBtZXNzYWdlLCBwdWJsaWNLZXkpIHtcbiAgICBjb25zdCBzaWcgPSBlbnN1cmVCeXRlcygnc2lnbmF0dXJlJywgc2lnbmF0dXJlLCA2NCk7XG4gICAgY29uc3QgbSA9IGVuc3VyZUJ5dGVzKCdtZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgY29uc3QgcHViID0gZW5zdXJlQnl0ZXMoJ3B1YmxpY0tleScsIHB1YmxpY0tleSwgMzIpO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IFAgPSBsaWZ0X3gobnVtKHB1YikpOyAvLyBQID0gbGlmdF94KGludChwaykpOyBmYWlsIGlmIHRoYXQgZmFpbHNcbiAgICAgICAgY29uc3QgciA9IG51bShzaWcuc3ViYXJyYXkoMCwgMzIpKTsgLy8gTGV0IHIgPSBpbnQoc2lnWzA6MzJdKTsgZmFpbCBpZiByIOKJpSBwLlxuICAgICAgICBpZiAoIWluUmFuZ2UociwgXzFuLCBzZWNwMjU2azFQKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgcyA9IG51bShzaWcuc3ViYXJyYXkoMzIsIDY0KSk7IC8vIExldCBzID0gaW50KHNpZ1szMjo2NF0pOyBmYWlsIGlmIHMg4omlIG4uXG4gICAgICAgIGlmICghaW5SYW5nZShzLCBfMW4sIHNlY3AyNTZrMU4pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBlID0gY2hhbGxlbmdlKG51bVRvMzJiKHIpLCBwb2ludFRvQnl0ZXMoUCksIG0pOyAvLyBpbnQoY2hhbGxlbmdlKGJ5dGVzKHIpfHxieXRlcyhQKXx8bSkpJW5cbiAgICAgICAgY29uc3QgUiA9IEdtdWxBZGQoUCwgcywgbW9kTigtZSkpOyAvLyBSID0gc+KLhUcgLSBl4ouFUFxuICAgICAgICBpZiAoIVIgfHwgIVIuaGFzRXZlblkoKSB8fCBSLnRvQWZmaW5lKCkueCAhPT0gcilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gLWVQID09IChuLWUpUFxuICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gRmFpbCBpZiBpc19pbmZpbml0ZShSKSAvIG5vdCBoYXNfZXZlbl95KFIpIC8geChSKSDiiaAgci5cbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vKipcbiAqIFNjaG5vcnIgc2lnbmF0dXJlcyBvdmVyIHNlY3AyNTZrMS5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpcHMvYmxvYi9tYXN0ZXIvYmlwLTAzNDAubWVkaWF3aWtpXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgc2Nobm9yciB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxJztcbiAqIGNvbnN0IHByaXYgPSBzY2hub3JyLnV0aWxzLnJhbmRvbVByaXZhdGVLZXkoKTtcbiAqIGNvbnN0IHB1YiA9IHNjaG5vcnIuZ2V0UHVibGljS2V5KHByaXYpO1xuICogY29uc3QgbXNnID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKCdoZWxsbycpO1xuICogY29uc3Qgc2lnID0gc2Nobm9yci5zaWduKG1zZywgcHJpdik7XG4gKiBjb25zdCBpc1ZhbGlkID0gc2Nobm9yci52ZXJpZnkoc2lnLCBtc2csIHB1Yik7XG4gKi9cbmV4cG9ydCBjb25zdCBzY2hub3JyID0gLyogQF9fUFVSRV9fICovICgoKSA9PiAoe1xuICAgIGdldFB1YmxpY0tleTogc2Nobm9yckdldFB1YmxpY0tleSxcbiAgICBzaWduOiBzY2hub3JyU2lnbixcbiAgICB2ZXJpZnk6IHNjaG5vcnJWZXJpZnksXG4gICAgdXRpbHM6IHtcbiAgICAgICAgcmFuZG9tUHJpdmF0ZUtleTogc2VjcDI1NmsxLnV0aWxzLnJhbmRvbVByaXZhdGVLZXksXG4gICAgICAgIGxpZnRfeCxcbiAgICAgICAgcG9pbnRUb0J5dGVzLFxuICAgICAgICBudW1iZXJUb0J5dGVzQkUsXG4gICAgICAgIGJ5dGVzVG9OdW1iZXJCRSxcbiAgICAgICAgdGFnZ2VkSGFzaCxcbiAgICAgICAgbW9kLFxuICAgIH0sXG59KSkoKTtcbmNvbnN0IGlzb01hcCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gaXNvZ2VueU1hcChGcGsxLCBbXG4gICAgLy8geE51bVxuICAgIFtcbiAgICAgICAgJzB4OGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGRhYWFhYThjNycsXG4gICAgICAgICcweDdkM2Q0YzgwYmMzMjFkNWI5ZjMxNWNlYTdmZDQ0YzVkNTk1ZDJmYzBiZjYzYjkyZGZmZjEwNDRmMTdjNjU4MScsXG4gICAgICAgICcweDUzNGMzMjhkMjNmMjM0ZTZlMmE0MTNkZWNhMjVjYWVjZTQ1MDYxNDQwMzdjNDAzMTRlY2JkMGI1M2Q5ZGQyNjInLFxuICAgICAgICAnMHg4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZGFhYWFhODhjJyxcbiAgICBdLFxuICAgIC8vIHhEZW5cbiAgICBbXG4gICAgICAgICcweGQzNTc3MTE5M2Q5NDkxOGE5Y2EzNGNjYmI3YjY0MGRkODZjZDQwOTU0MmY4NDg3ZDlmZTZiNzQ1NzgxZWI0OWInLFxuICAgICAgICAnMHhlZGFkYzZmNjQzODNkYzFkZjdjNGIyZDUxYjU0MjI1NDA2ZDM2YjY0MWY1ZTQxYmJjNTJhNTY2MTJhOGM2ZDE0JyxcbiAgICAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsIC8vIExBU1QgMVxuICAgIF0sXG4gICAgLy8geU51bVxuICAgIFtcbiAgICAgICAgJzB4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGI4ZTM4ZTIzYycsXG4gICAgICAgICcweGM3NWUwYzMyZDVjYjdjMGZhOWQwYTU0YjEyYTBhNmQ1NjQ3YWIwNDZkNjg2ZGE2ZmRmZmM5MGZjMjAxZDcxYTMnLFxuICAgICAgICAnMHgyOWE2MTk0NjkxZjkxYTczNzE1MjA5ZWY2NTEyZTU3NjcyMjgzMGEyMDFiZTIwMThhNzY1ZTg1YTllY2VlOTMxJyxcbiAgICAgICAgJzB4MmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmYzOGUzOGQ4NCcsXG4gICAgXSxcbiAgICAvLyB5RGVuXG4gICAgW1xuICAgICAgICAnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWZmZmZmOTNiJyxcbiAgICAgICAgJzB4N2EwNjUzNGJiOGJkYjQ5ZmQ1ZTllNjYzMjcyMmMyOTg5NDY3YzFiZmM4ZThkOTc4ZGZiNDI1ZDI2ODVjMjU3MycsXG4gICAgICAgICcweDY0ODRhYTcxNjU0NWNhMmNmM2E3MGMzZmE4ZmUzMzdlMGEzZDIxMTYyZjBkNjI5OWE3YmY4MTkyYmZkMmE3NmYnLFxuICAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJywgLy8gTEFTVCAxXG4gICAgXSxcbl0ubWFwKChpKSA9PiBpLm1hcCgoaikgPT4gQmlnSW50KGopKSkpKSgpO1xuY29uc3QgbWFwU1dVID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBtYXBUb0N1cnZlU2ltcGxlU1dVKEZwazEsIHtcbiAgICBBOiBCaWdJbnQoJzB4M2Y4NzMxYWJkZDY2MWFkY2EwOGE1NTU4ZjBmNWQyNzJlOTUzZDM2M2NiNmYwZTVkNDA1NDQ3YzAxYTQ0NDUzMycpLFxuICAgIEI6IEJpZ0ludCgnMTc3MScpLFxuICAgIFo6IEZwazEuY3JlYXRlKEJpZ0ludCgnLTExJykpLFxufSkpKCk7XG5jb25zdCBodGYgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGNyZWF0ZUhhc2hlcihzZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50LCAoc2NhbGFycykgPT4ge1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gbWFwU1dVKEZwazEuY3JlYXRlKHNjYWxhcnNbMF0pKTtcbiAgICByZXR1cm4gaXNvTWFwKHgsIHkpO1xufSwge1xuICAgIERTVDogJ3NlY3AyNTZrMV9YTUQ6U0hBLTI1Nl9TU1dVX1JPXycsXG4gICAgZW5jb2RlRFNUOiAnc2VjcDI1NmsxX1hNRDpTSEEtMjU2X1NTV1VfTlVfJyxcbiAgICBwOiBGcGsxLk9SREVSLFxuICAgIG06IDEsXG4gICAgazogMTI4LFxuICAgIGV4cGFuZDogJ3htZCcsXG4gICAgaGFzaDogc2hhMjU2LFxufSkpKCk7XG4vKiogc2VjcDI1NmsxIGhhc2gtdG8tY3VydmUgZnJvbSBbUkZDIDkzODBdKGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwKS4gKi9cbmV4cG9ydCBjb25zdCBoYXNoVG9DdXJ2ZSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gaHRmLmhhc2hUb0N1cnZlKSgpO1xuLyoqIHNlY3AyNTZrMSBlbmNvZGUtdG8tY3VydmUgZnJvbSBbUkZDIDkzODBdKGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwKS4gKi9cbmV4cG9ydCBjb25zdCBlbmNvZGVUb0N1cnZlID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBodGYuZW5jb2RlVG9DdXJ2ZSkoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlY3AyNTZrMS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/esm/secp256k1.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/hashes/esm/_assert.js":
/*!***************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/_assert.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   abytes: () => (/* binding */ abytes),\n/* harmony export */   aexists: () => (/* binding */ aexists),\n/* harmony export */   ahash: () => (/* binding */ ahash),\n/* harmony export */   anumber: () => (/* binding */ anumber),\n/* harmony export */   aoutput: () => (/* binding */ aoutput)\n/* harmony export */ });\n/**\n * Internal assertion helpers.\n * @module\n */\n/** Asserts something is positive integer. */\nfunction anumber(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error('positive integer expected, got ' + n);\n}\n/** Is number an Uint8Array? Copied from utils for perf. */\nfunction isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n/** Asserts something is Uint8Array. */\nfunction abytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n/** Asserts something is hash */\nfunction ahash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    anumber(h.outputLen);\n    anumber(h.blockLen);\n}\n/** Asserts a hash instance has not been destroyed / finished */\nfunction aexists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\n/** Asserts output is properly-sized byte array */\nfunction aoutput(out, instance) {\n    abytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error('digestInto() expects output buffer of length at least ' + min);\n    }\n}\n\n//# sourceMappingURL=_assert.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fYXNzZXJ0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ29EO0FBQ3BEIiwic291cmNlcyI6WyIvaG9tZS9sZmcvR2l0L01hZHRyaXBzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fYXNzZXJ0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSW50ZXJuYWwgYXNzZXJ0aW9uIGhlbHBlcnMuXG4gKiBAbW9kdWxlXG4gKi9cbi8qKiBBc3NlcnRzIHNvbWV0aGluZyBpcyBwb3NpdGl2ZSBpbnRlZ2VyLiAqL1xuZnVuY3Rpb24gYW51bWJlcihuKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSB8fCBuIDwgMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwb3NpdGl2ZSBpbnRlZ2VyIGV4cGVjdGVkLCBnb3QgJyArIG4pO1xufVxuLyoqIElzIG51bWJlciBhbiBVaW50OEFycmF5PyBDb3BpZWQgZnJvbSB1dGlscyBmb3IgcGVyZi4gKi9cbmZ1bmN0aW9uIGlzQnl0ZXMoYSkge1xuICAgIHJldHVybiBhIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCAoQXJyYXlCdWZmZXIuaXNWaWV3KGEpICYmIGEuY29uc3RydWN0b3IubmFtZSA9PT0gJ1VpbnQ4QXJyYXknKTtcbn1cbi8qKiBBc3NlcnRzIHNvbWV0aGluZyBpcyBVaW50OEFycmF5LiAqL1xuZnVuY3Rpb24gYWJ5dGVzKGIsIC4uLmxlbmd0aHMpIHtcbiAgICBpZiAoIWlzQnl0ZXMoYikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgIGlmIChsZW5ndGhzLmxlbmd0aCA+IDAgJiYgIWxlbmd0aHMuaW5jbHVkZXMoYi5sZW5ndGgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQgb2YgbGVuZ3RoICcgKyBsZW5ndGhzICsgJywgZ290IGxlbmd0aD0nICsgYi5sZW5ndGgpO1xufVxuLyoqIEFzc2VydHMgc29tZXRoaW5nIGlzIGhhc2ggKi9cbmZ1bmN0aW9uIGFoYXNoKGgpIHtcbiAgICBpZiAodHlwZW9mIGggIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGguY3JlYXRlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggc2hvdWxkIGJlIHdyYXBwZWQgYnkgdXRpbHMud3JhcENvbnN0cnVjdG9yJyk7XG4gICAgYW51bWJlcihoLm91dHB1dExlbik7XG4gICAgYW51bWJlcihoLmJsb2NrTGVuKTtcbn1cbi8qKiBBc3NlcnRzIGEgaGFzaCBpbnN0YW5jZSBoYXMgbm90IGJlZW4gZGVzdHJveWVkIC8gZmluaXNoZWQgKi9cbmZ1bmN0aW9uIGFleGlzdHMoaW5zdGFuY2UsIGNoZWNrRmluaXNoZWQgPSB0cnVlKSB7XG4gICAgaWYgKGluc3RhbmNlLmRlc3Ryb3llZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIGluc3RhbmNlIGhhcyBiZWVuIGRlc3Ryb3llZCcpO1xuICAgIGlmIChjaGVja0ZpbmlzaGVkICYmIGluc3RhbmNlLmZpbmlzaGVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2gjZGlnZXN0KCkgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWQnKTtcbn1cbi8qKiBBc3NlcnRzIG91dHB1dCBpcyBwcm9wZXJseS1zaXplZCBieXRlIGFycmF5ICovXG5mdW5jdGlvbiBhb3V0cHV0KG91dCwgaW5zdGFuY2UpIHtcbiAgICBhYnl0ZXMob3V0KTtcbiAgICBjb25zdCBtaW4gPSBpbnN0YW5jZS5vdXRwdXRMZW47XG4gICAgaWYgKG91dC5sZW5ndGggPCBtaW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaWdlc3RJbnRvKCkgZXhwZWN0cyBvdXRwdXQgYnVmZmVyIG9mIGxlbmd0aCBhdCBsZWFzdCAnICsgbWluKTtcbiAgICB9XG59XG5leHBvcnQgeyBhbnVtYmVyLCBhYnl0ZXMsIGFoYXNoLCBhZXhpc3RzLCBhb3V0cHV0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fYXNzZXJ0LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/hashes/esm/_assert.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/hashes/esm/_md.js":
/*!***********************************************!*\
  !*** ./node_modules/@noble/hashes/esm/_md.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Chi: () => (/* binding */ Chi),\n/* harmony export */   HashMD: () => (/* binding */ HashMD),\n/* harmony export */   Maj: () => (/* binding */ Maj),\n/* harmony export */   setBigUint64: () => (/* binding */ setBigUint64)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/utils.js\");\n/**\n * Internal Merkle-Damgard hash utils.\n * @module\n */\n\n\n/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n/** Choice: a ? b : c */\nfunction Chi(a, b, c) {\n    return (a & b) ^ (~a & c);\n}\n/** Majority function, true if any two inputs is true. */\nfunction Maj(a, b, c) {\n    return (a & b) ^ (a & c) ^ (b & c);\n}\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nclass HashMD extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(this.buffer);\n    }\n    update(data) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.aexists)(this);\n        const { view, buffer, blockLen } = this;\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.aexists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.aoutput)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n//# sourceMappingURL=_md.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fbWQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDZ0Q7QUFDTztBQUN2RDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHFCQUFxQiwyQ0FBSTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFEQUFVO0FBQzlCO0FBQ0E7QUFDQSxRQUFRLG1EQUFPO0FBQ2YsZ0JBQWdCLHlCQUF5QjtBQUN6QyxlQUFlLGtEQUFPO0FBQ3RCO0FBQ0EsMEJBQTBCLFVBQVU7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHFEQUFVO0FBQzNDLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG1EQUFPO0FBQ2YsUUFBUSxtREFBTztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtCQUErQjtBQUMvQyxjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsY0FBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscURBQVU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxREFBcUQ7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2xmZy9HaXQvTWFkdHJpcHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19tZC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEludGVybmFsIE1lcmtsZS1EYW1nYXJkIGhhc2ggdXRpbHMuXG4gKiBAbW9kdWxlXG4gKi9cbmltcG9ydCB7IGFleGlzdHMsIGFvdXRwdXQgfSBmcm9tICcuL19hc3NlcnQuanMnO1xuaW1wb3J0IHsgSGFzaCwgY3JlYXRlVmlldywgdG9CeXRlcyB9IGZyb20gJy4vdXRpbHMuanMnO1xuLyoqIFBvbHlmaWxsIGZvciBTYWZhcmkgMTQuIGh0dHBzOi8vY2FuaXVzZS5jb20vbWRuLWphdmFzY3JpcHRfYnVpbHRpbnNfZGF0YXZpZXdfc2V0YmlndWludDY0ICovXG5leHBvcnQgZnVuY3Rpb24gc2V0QmlnVWludDY0KHZpZXcsIGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKSB7XG4gICAgaWYgKHR5cGVvZiB2aWV3LnNldEJpZ1VpbnQ2NCA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgcmV0dXJuIHZpZXcuc2V0QmlnVWludDY0KGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKTtcbiAgICBjb25zdCBfMzJuID0gQmlnSW50KDMyKTtcbiAgICBjb25zdCBfdTMyX21heCA9IEJpZ0ludCgweGZmZmZmZmZmKTtcbiAgICBjb25zdCB3aCA9IE51bWJlcigodmFsdWUgPj4gXzMybikgJiBfdTMyX21heCk7XG4gICAgY29uc3Qgd2wgPSBOdW1iZXIodmFsdWUgJiBfdTMyX21heCk7XG4gICAgY29uc3QgaCA9IGlzTEUgPyA0IDogMDtcbiAgICBjb25zdCBsID0gaXNMRSA/IDAgOiA0O1xuICAgIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBoLCB3aCwgaXNMRSk7XG4gICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGwsIHdsLCBpc0xFKTtcbn1cbi8qKiBDaG9pY2U6IGEgPyBiIDogYyAqL1xuZXhwb3J0IGZ1bmN0aW9uIENoaShhLCBiLCBjKSB7XG4gICAgcmV0dXJuIChhICYgYikgXiAofmEgJiBjKTtcbn1cbi8qKiBNYWpvcml0eSBmdW5jdGlvbiwgdHJ1ZSBpZiBhbnkgdHdvIGlucHV0cyBpcyB0cnVlLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIE1haihhLCBiLCBjKSB7XG4gICAgcmV0dXJuIChhICYgYikgXiAoYSAmIGMpIF4gKGIgJiBjKTtcbn1cbi8qKlxuICogTWVya2xlLURhbWdhcmQgaGFzaCBjb25zdHJ1Y3Rpb24gYmFzZSBjbGFzcy5cbiAqIENvdWxkIGJlIHVzZWQgdG8gY3JlYXRlIE1ENSwgUklQRU1ELCBTSEExLCBTSEEyLlxuICovXG5leHBvcnQgY2xhc3MgSGFzaE1EIGV4dGVuZHMgSGFzaCB7XG4gICAgY29uc3RydWN0b3IoYmxvY2tMZW4sIG91dHB1dExlbiwgcGFkT2Zmc2V0LCBpc0xFKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRoaXMucGFkT2Zmc2V0ID0gcGFkT2Zmc2V0O1xuICAgICAgICB0aGlzLmlzTEUgPSBpc0xFO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGJsb2NrTGVuKTtcbiAgICAgICAgdGhpcy52aWV3ID0gY3JlYXRlVmlldyh0aGlzLmJ1ZmZlcik7XG4gICAgfVxuICAgIHVwZGF0ZShkYXRhKSB7XG4gICAgICAgIGFleGlzdHModGhpcyk7XG4gICAgICAgIGNvbnN0IHsgdmlldywgYnVmZmVyLCBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgICAgZGF0YSA9IHRvQnl0ZXMoZGF0YSk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW47KSB7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvcywgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIC8vIEZhc3QgcGF0aDogd2UgaGF2ZSBhdCBsZWFzdCBvbmUgYmxvY2sgaW4gaW5wdXQsIGNhc3QgaXQgdG8gdmlldyBhbmQgcHJvY2Vzc1xuICAgICAgICAgICAgaWYgKHRha2UgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YVZpZXcgPSBjcmVhdGVWaWV3KGRhdGEpO1xuICAgICAgICAgICAgICAgIGZvciAoOyBibG9ja0xlbiA8PSBsZW4gLSBwb3M7IHBvcyArPSBibG9ja0xlbilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzKGRhdGFWaWV3LCBwb3MpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmZmVyLnNldChkYXRhLnN1YmFycmF5KHBvcywgcG9zICsgdGFrZSksIHRoaXMucG9zKTtcbiAgICAgICAgICAgIHRoaXMucG9zICs9IHRha2U7XG4gICAgICAgICAgICBwb3MgKz0gdGFrZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA9PT0gYmxvY2tMZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubGVuZ3RoICs9IGRhdGEubGVuZ3RoO1xuICAgICAgICB0aGlzLnJvdW5kQ2xlYW4oKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgIGFleGlzdHModGhpcyk7XG4gICAgICAgIGFvdXRwdXQob3V0LCB0aGlzKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIC8vIFBhZGRpbmdcbiAgICAgICAgLy8gV2UgY2FuIGF2b2lkIGFsbG9jYXRpb24gb2YgYnVmZmVyIGZvciBwYWRkaW5nIGNvbXBsZXRlbHkgaWYgaXRcbiAgICAgICAgLy8gd2FzIHByZXZpb3VzbHkgbm90IGFsbG9jYXRlZCBoZXJlLiBCdXQgaXQgd29uJ3QgY2hhbmdlIHBlcmZvcm1hbmNlLlxuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgdmlldywgYmxvY2tMZW4sIGlzTEUgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IHBvcyB9ID0gdGhpcztcbiAgICAgICAgLy8gYXBwZW5kIHRoZSBiaXQgJzEnIHRvIHRoZSBtZXNzYWdlXG4gICAgICAgIGJ1ZmZlcltwb3MrK10gPSAwYjEwMDAwMDAwO1xuICAgICAgICB0aGlzLmJ1ZmZlci5zdWJhcnJheShwb3MpLmZpbGwoMCk7XG4gICAgICAgIC8vIHdlIGhhdmUgbGVzcyB0aGFuIHBhZE9mZnNldCBsZWZ0IGluIGJ1ZmZlciwgc28gd2UgY2Fubm90IHB1dCBsZW5ndGggaW5cbiAgICAgICAgLy8gY3VycmVudCBibG9jaywgbmVlZCBwcm9jZXNzIGl0IGFuZCBwYWQgYWdhaW5cbiAgICAgICAgaWYgKHRoaXMucGFkT2Zmc2V0ID4gYmxvY2tMZW4gLSBwb3MpIHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgICAgIHBvcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUGFkIHVudGlsIGZ1bGwgYmxvY2sgYnl0ZSB3aXRoIHplcm9zXG4gICAgICAgIGZvciAobGV0IGkgPSBwb3M7IGkgPCBibG9ja0xlbjsgaSsrKVxuICAgICAgICAgICAgYnVmZmVyW2ldID0gMDtcbiAgICAgICAgLy8gTm90ZTogc2hhNTEyIHJlcXVpcmVzIGxlbmd0aCB0byBiZSAxMjhiaXQgaW50ZWdlciwgYnV0IGxlbmd0aCBpbiBKUyB3aWxsIG92ZXJmbG93IGJlZm9yZSB0aGF0XG4gICAgICAgIC8vIFlvdSBuZWVkIHRvIHdyaXRlIGFyb3VuZCAyIGV4YWJ5dGVzICh1NjRfbWF4IC8gOCAvICgxMDI0Kio2KSkgZm9yIHRoaXMgdG8gaGFwcGVuLlxuICAgICAgICAvLyBTbyB3ZSBqdXN0IHdyaXRlIGxvd2VzdCA2NCBiaXRzIG9mIHRoYXQgdmFsdWUuXG4gICAgICAgIHNldEJpZ1VpbnQ2NCh2aWV3LCBibG9ja0xlbiAtIDgsIEJpZ0ludCh0aGlzLmxlbmd0aCAqIDgpLCBpc0xFKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICBjb25zdCBvdmlldyA9IGNyZWF0ZVZpZXcob3V0KTtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5vdXRwdXRMZW47XG4gICAgICAgIC8vIE5PVEU6IHdlIGRvIGRpdmlzaW9uIGJ5IDQgbGF0ZXIsIHdoaWNoIHNob3VsZCBiZSBmdXNlZCBpbiBzaW5nbGUgb3Agd2l0aCBtb2R1bG8gYnkgSklUXG4gICAgICAgIGlmIChsZW4gJSA0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfc2hhMjogb3V0cHV0TGVuIHNob3VsZCBiZSBhbGlnbmVkIHRvIDMyYml0Jyk7XG4gICAgICAgIGNvbnN0IG91dExlbiA9IGxlbiAvIDQ7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXQoKTtcbiAgICAgICAgaWYgKG91dExlbiA+IHN0YXRlLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX3NoYTI6IG91dHB1dExlbiBiaWdnZXIgdGhhbiBzdGF0ZScpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dExlbjsgaSsrKVxuICAgICAgICAgICAgb3ZpZXcuc2V0VWludDMyKDQgKiBpLCBzdGF0ZVtpXSwgaXNMRSk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3QgeyBidWZmZXIsIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5kaWdlc3RJbnRvKGJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IHJlcyA9IGJ1ZmZlci5zbGljZSgwLCBvdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICB0byB8fCAodG8gPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpKTtcbiAgICAgICAgdG8uc2V0KC4uLnRoaXMuZ2V0KCkpO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBidWZmZXIsIGxlbmd0aCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgcG9zIH0gPSB0aGlzO1xuICAgICAgICB0by5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRvLnBvcyA9IHBvcztcbiAgICAgICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gZGVzdHJveWVkO1xuICAgICAgICBpZiAobGVuZ3RoICUgYmxvY2tMZW4pXG4gICAgICAgICAgICB0by5idWZmZXIuc2V0KGJ1ZmZlcik7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fbWQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/hashes/esm/_md.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/hashes/esm/crypto.js":
/*!**************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/crypto.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   crypto: () => (/* binding */ crypto)\n/* harmony export */ });\nconst crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n//# sourceMappingURL=crypto.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9jcnlwdG8uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPO0FBQ1AiLCJzb3VyY2VzIjpbIi9ob21lL2xmZy9HaXQvTWFkdHJpcHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2NyeXB0by5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgY3J5cHRvID0gdHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnICYmICdjcnlwdG8nIGluIGdsb2JhbFRoaXMgPyBnbG9iYWxUaGlzLmNyeXB0byA6IHVuZGVmaW5lZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyeXB0by5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/hashes/esm/crypto.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/hashes/esm/hmac.js":
/*!************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/hmac.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HMAC: () => (/* binding */ HMAC),\n/* harmony export */   hmac: () => (/* binding */ hmac)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/utils.js\");\n/**\n * HMAC: RFC2104 message authentication code.\n * @module\n */\n\n\nclass HMAC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.ahash)(hash);\n        const key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.aexists)(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.aexists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.abytes)(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n * @example\n * import { hmac } from '@noble/hashes/hmac';\n * import { sha256 } from '@noble/hashes/sha2';\n * const mac1 = hmac(sha256, 'key', 'message');\n */\nconst hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key) => new HMAC(hash, key);\n//# sourceMappingURL=hmac.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9obWFjLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNzRDtBQUNYO0FBQ3BDLG1CQUFtQiwyQ0FBSTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaURBQUs7QUFDYixvQkFBb0Isa0RBQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxtREFBTztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxtREFBTztBQUNmLFFBQVEsa0RBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRSxnQkFBZ0IseURBQXlEO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNPO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbGZnL0dpdC9NYWR0cmlwcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vaG1hYy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEhNQUM6IFJGQzIxMDQgbWVzc2FnZSBhdXRoZW50aWNhdGlvbiBjb2RlLlxuICogQG1vZHVsZVxuICovXG5pbXBvcnQgeyBhYnl0ZXMsIGFleGlzdHMsIGFoYXNoIH0gZnJvbSAnLi9fYXNzZXJ0LmpzJztcbmltcG9ydCB7IEhhc2gsIHRvQnl0ZXMgfSBmcm9tICcuL3V0aWxzLmpzJztcbmV4cG9ydCBjbGFzcyBITUFDIGV4dGVuZHMgSGFzaCB7XG4gICAgY29uc3RydWN0b3IoaGFzaCwgX2tleSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIGFoYXNoKGhhc2gpO1xuICAgICAgICBjb25zdCBrZXkgPSB0b0J5dGVzKF9rZXkpO1xuICAgICAgICB0aGlzLmlIYXNoID0gaGFzaC5jcmVhdGUoKTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmlIYXNoLnVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgaW5zdGFuY2Ugb2YgY2xhc3Mgd2hpY2ggZXh0ZW5kcyB1dGlscy5IYXNoJyk7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSB0aGlzLmlIYXNoLmJsb2NrTGVuO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IHRoaXMuaUhhc2gub3V0cHV0TGVuO1xuICAgICAgICBjb25zdCBibG9ja0xlbiA9IHRoaXMuYmxvY2tMZW47XG4gICAgICAgIGNvbnN0IHBhZCA9IG5ldyBVaW50OEFycmF5KGJsb2NrTGVuKTtcbiAgICAgICAgLy8gYmxvY2tMZW4gY2FuIGJlIGJpZ2dlciB0aGFuIG91dHB1dExlblxuICAgICAgICBwYWQuc2V0KGtleS5sZW5ndGggPiBibG9ja0xlbiA/IGhhc2guY3JlYXRlKCkudXBkYXRlKGtleSkuZGlnZXN0KCkgOiBrZXkpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHBhZFtpXSBePSAweDM2O1xuICAgICAgICB0aGlzLmlIYXNoLnVwZGF0ZShwYWQpO1xuICAgICAgICAvLyBCeSBkb2luZyB1cGRhdGUgKHByb2Nlc3Npbmcgb2YgZmlyc3QgYmxvY2spIG9mIG91dGVyIGhhc2ggaGVyZSB3ZSBjYW4gcmUtdXNlIGl0IGJldHdlZW4gbXVsdGlwbGUgY2FsbHMgdmlhIGNsb25lXG4gICAgICAgIHRoaXMub0hhc2ggPSBoYXNoLmNyZWF0ZSgpO1xuICAgICAgICAvLyBVbmRvIGludGVybmFsIFhPUiAmJiBhcHBseSBvdXRlciBYT1JcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBwYWRbaV0gXj0gMHgzNiBeIDB4NWM7XG4gICAgICAgIHRoaXMub0hhc2gudXBkYXRlKHBhZCk7XG4gICAgICAgIHBhZC5maWxsKDApO1xuICAgIH1cbiAgICB1cGRhdGUoYnVmKSB7XG4gICAgICAgIGFleGlzdHModGhpcyk7XG4gICAgICAgIHRoaXMuaUhhc2gudXBkYXRlKGJ1Zik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBhZXhpc3RzKHRoaXMpO1xuICAgICAgICBhYnl0ZXMob3V0LCB0aGlzLm91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmlIYXNoLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgdGhpcy5vSGFzaC51cGRhdGUob3V0KTtcbiAgICAgICAgdGhpcy5vSGFzaC5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgIH1cbiAgICBkaWdlc3QoKSB7XG4gICAgICAgIGNvbnN0IG91dCA9IG5ldyBVaW50OEFycmF5KHRoaXMub0hhc2gub3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIF9jbG9uZUludG8odG8pIHtcbiAgICAgICAgLy8gQ3JlYXRlIG5ldyBpbnN0YW5jZSB3aXRob3V0IGNhbGxpbmcgY29uc3RydWN0b3Igc2luY2Uga2V5IGFscmVhZHkgaW4gc3RhdGUgYW5kIHdlIGRvbid0IGtub3cgaXQuXG4gICAgICAgIHRvIHx8ICh0byA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLCB7fSkpO1xuICAgICAgICBjb25zdCB7IG9IYXNoLCBpSGFzaCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgYmxvY2tMZW4sIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICAgICAgdG8gPSB0bztcbiAgICAgICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gZGVzdHJveWVkO1xuICAgICAgICB0by5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgICB0by5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRvLm9IYXNoID0gb0hhc2guX2Nsb25lSW50byh0by5vSGFzaCk7XG4gICAgICAgIHRvLmlIYXNoID0gaUhhc2guX2Nsb25lSW50byh0by5pSGFzaCk7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLm9IYXNoLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5pSGFzaC5kZXN0cm95KCk7XG4gICAgfVxufVxuLyoqXG4gKiBITUFDOiBSRkMyMTA0IG1lc3NhZ2UgYXV0aGVudGljYXRpb24gY29kZS5cbiAqIEBwYXJhbSBoYXNoIC0gZnVuY3Rpb24gdGhhdCB3b3VsZCBiZSB1c2VkIGUuZy4gc2hhMjU2XG4gKiBAcGFyYW0ga2V5IC0gbWVzc2FnZSBrZXlcbiAqIEBwYXJhbSBtZXNzYWdlIC0gbWVzc2FnZSBkYXRhXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgaG1hYyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvaG1hYyc7XG4gKiBpbXBvcnQgeyBzaGEyNTYgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3NoYTInO1xuICogY29uc3QgbWFjMSA9IGhtYWMoc2hhMjU2LCAna2V5JywgJ21lc3NhZ2UnKTtcbiAqL1xuZXhwb3J0IGNvbnN0IGhtYWMgPSAoaGFzaCwga2V5LCBtZXNzYWdlKSA9PiBuZXcgSE1BQyhoYXNoLCBrZXkpLnVwZGF0ZShtZXNzYWdlKS5kaWdlc3QoKTtcbmhtYWMuY3JlYXRlID0gKGhhc2gsIGtleSkgPT4gbmV3IEhNQUMoaGFzaCwga2V5KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhtYWMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/hashes/esm/hmac.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/hashes/esm/sha256.js":
/*!**************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/sha256.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHA256: () => (/* binding */ SHA256),\n/* harmony export */   sha224: () => (/* binding */ sha224),\n/* harmony export */   sha256: () => (/* binding */ sha256)\n/* harmony export */ });\n/* harmony import */ var _md_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_md.js */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/_md.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/utils.js\");\n/**\n * SHA2-256 a.k.a. sha256. In JS, it is the fastest hash, even faster than Blake3.\n *\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n *\n * Check out [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n */\n\n\n/** Round constants: first 32 bits of fractional parts of the cube roots of the first 64 primes 2..311). */\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n/** Initial state: first 32 bits of fractional parts of the square roots of the first 8 primes 2..19. */\n// prettier-ignore\nconst SHA256_IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n/**\n * Temporary buffer, not used to store anything between runs.\n * Named this way because it matches specification.\n */\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends _md_js__WEBPACK_IMPORTED_MODULE_0__.HashMD {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = SHA256_IV[0] | 0;\n        this.B = SHA256_IV[1] | 0;\n        this.C = SHA256_IV[2] | 0;\n        this.D = SHA256_IV[3] | 0;\n        this.E = SHA256_IV[4] | 0;\n        this.F = SHA256_IV[5] | 0;\n        this.G = SHA256_IV[6] | 0;\n        this.H = SHA256_IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 7) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 18) ^ (W15 >>> 3);\n            const s1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 17) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 6) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 11) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 25);\n            const T1 = (H + sigma1 + (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 2) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 13) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 22);\n            const T2 = (sigma0 + (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Maj)(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n/**\n * Constants taken from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf.\n */\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/** SHA2-256 hash function */\nconst sha256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA256());\n/** SHA2-224 hash function */\nconst sha224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA224());\n//# sourceMappingURL=sha256.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGEyNTYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDNEM7QUFDTztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHFCQUFxQiwwQ0FBTTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlCQUF5QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQSx1QkFBdUIsK0NBQUksV0FBVywrQ0FBSTtBQUMxQyx1QkFBdUIsK0NBQUksV0FBVywrQ0FBSTtBQUMxQztBQUNBO0FBQ0E7QUFDQSxjQUFjLHlCQUF5QjtBQUN2Qyx3QkFBd0IsUUFBUTtBQUNoQywyQkFBMkIsK0NBQUksU0FBUywrQ0FBSSxVQUFVLCtDQUFJO0FBQzFELHFDQUFxQywyQ0FBRztBQUN4QywyQkFBMkIsK0NBQUksU0FBUywrQ0FBSSxVQUFVLCtDQUFJO0FBQzFELGlDQUFpQywyQ0FBRztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLCtCQUErQiwwREFBZTtBQUNyRDtBQUNPLCtCQUErQiwwREFBZTtBQUNyRCIsInNvdXJjZXMiOlsiL2hvbWUvbGZnL0dpdC9NYWR0cmlwcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vc2hhMjU2LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogU0hBMi0yNTYgYS5rLmEuIHNoYTI1Ni4gSW4gSlMsIGl0IGlzIHRoZSBmYXN0ZXN0IGhhc2gsIGV2ZW4gZmFzdGVyIHRoYW4gQmxha2UzLlxuICpcbiAqIFRvIGJyZWFrIHNoYTI1NiB1c2luZyBiaXJ0aGRheSBhdHRhY2ssIGF0dGFja2VycyBuZWVkIHRvIHRyeSAyXjEyOCBoYXNoZXMuXG4gKiBCVEMgbmV0d29yayBpcyBkb2luZyAyXjcwIGhhc2hlcy9zZWMgKDJeOTUgaGFzaGVzL3llYXIpIGFzIHBlciAyMDI1LlxuICpcbiAqIENoZWNrIG91dCBbRklQUyAxODAtNF0oaHR0cHM6Ly9udmxwdWJzLm5pc3QuZ292L25pc3RwdWJzL0ZJUFMvTklTVC5GSVBTLjE4MC00LnBkZikuXG4gKiBAbW9kdWxlXG4gKi9cbmltcG9ydCB7IENoaSwgSGFzaE1ELCBNYWogfSBmcm9tICcuL19tZC5qcyc7XG5pbXBvcnQgeyByb3RyLCB3cmFwQ29uc3RydWN0b3IgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8qKiBSb3VuZCBjb25zdGFudHM6IGZpcnN0IDMyIGJpdHMgb2YgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgY3ViZSByb290cyBvZiB0aGUgZmlyc3QgNjQgcHJpbWVzIDIuLjMxMSkuICovXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IFNIQTI1Nl9LID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheShbXG4gICAgMHg0MjhhMmY5OCwgMHg3MTM3NDQ5MSwgMHhiNWMwZmJjZiwgMHhlOWI1ZGJhNSwgMHgzOTU2YzI1YiwgMHg1OWYxMTFmMSwgMHg5MjNmODJhNCwgMHhhYjFjNWVkNSxcbiAgICAweGQ4MDdhYTk4LCAweDEyODM1YjAxLCAweDI0MzE4NWJlLCAweDU1MGM3ZGMzLCAweDcyYmU1ZDc0LCAweDgwZGViMWZlLCAweDliZGMwNmE3LCAweGMxOWJmMTc0LFxuICAgIDB4ZTQ5YjY5YzEsIDB4ZWZiZTQ3ODYsIDB4MGZjMTlkYzYsIDB4MjQwY2ExY2MsIDB4MmRlOTJjNmYsIDB4NGE3NDg0YWEsIDB4NWNiMGE5ZGMsIDB4NzZmOTg4ZGEsXG4gICAgMHg5ODNlNTE1MiwgMHhhODMxYzY2ZCwgMHhiMDAzMjdjOCwgMHhiZjU5N2ZjNywgMHhjNmUwMGJmMywgMHhkNWE3OTE0NywgMHgwNmNhNjM1MSwgMHgxNDI5Mjk2NyxcbiAgICAweDI3YjcwYTg1LCAweDJlMWIyMTM4LCAweDRkMmM2ZGZjLCAweDUzMzgwZDEzLCAweDY1MGE3MzU0LCAweDc2NmEwYWJiLCAweDgxYzJjOTJlLCAweDkyNzIyYzg1LFxuICAgIDB4YTJiZmU4YTEsIDB4YTgxYTY2NGIsIDB4YzI0YjhiNzAsIDB4Yzc2YzUxYTMsIDB4ZDE5MmU4MTksIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsXG4gICAgMHgxOWE0YzExNiwgMHgxZTM3NmMwOCwgMHgyNzQ4Nzc0YywgMHgzNGIwYmNiNSwgMHgzOTFjMGNiMywgMHg0ZWQ4YWE0YSwgMHg1YjljY2E0ZiwgMHg2ODJlNmZmMyxcbiAgICAweDc0OGY4MmVlLCAweDc4YTU2MzZmLCAweDg0Yzg3ODE0LCAweDhjYzcwMjA4LCAweDkwYmVmZmZhLCAweGE0NTA2Y2ViLCAweGJlZjlhM2Y3LCAweGM2NzE3OGYyXG5dKTtcbi8qKiBJbml0aWFsIHN0YXRlOiBmaXJzdCAzMiBiaXRzIG9mIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIHNxdWFyZSByb290cyBvZiB0aGUgZmlyc3QgOCBwcmltZXMgMi4uMTkuICovXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IFNIQTI1Nl9JViA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoW1xuICAgIDB4NmEwOWU2NjcsIDB4YmI2N2FlODUsIDB4M2M2ZWYzNzIsIDB4YTU0ZmY1M2EsIDB4NTEwZTUyN2YsIDB4OWIwNTY4OGMsIDB4MWY4M2Q5YWIsIDB4NWJlMGNkMTlcbl0pO1xuLyoqXG4gKiBUZW1wb3JhcnkgYnVmZmVyLCBub3QgdXNlZCB0byBzdG9yZSBhbnl0aGluZyBiZXR3ZWVuIHJ1bnMuXG4gKiBOYW1lZCB0aGlzIHdheSBiZWNhdXNlIGl0IG1hdGNoZXMgc3BlY2lmaWNhdGlvbi5cbiAqL1xuY29uc3QgU0hBMjU2X1cgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDY0KTtcbmV4cG9ydCBjbGFzcyBTSEEyNTYgZXh0ZW5kcyBIYXNoTUQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcig2NCwgMzIsIDgsIGZhbHNlKTtcbiAgICAgICAgLy8gV2UgY2Fubm90IHVzZSBhcnJheSBoZXJlIHNpbmNlIGFycmF5IGFsbG93cyBpbmRleGluZyBieSB2YXJpYWJsZVxuICAgICAgICAvLyB3aGljaCBtZWFucyBvcHRpbWl6ZXIvY29tcGlsZXIgY2Fubm90IHVzZSByZWdpc3RlcnMuXG4gICAgICAgIHRoaXMuQSA9IFNIQTI1Nl9JVlswXSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IFNIQTI1Nl9JVlsxXSB8IDA7XG4gICAgICAgIHRoaXMuQyA9IFNIQTI1Nl9JVlsyXSB8IDA7XG4gICAgICAgIHRoaXMuRCA9IFNIQTI1Nl9JVlszXSB8IDA7XG4gICAgICAgIHRoaXMuRSA9IFNIQTI1Nl9JVls0XSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IFNIQTI1Nl9JVls1XSB8IDA7XG4gICAgICAgIHRoaXMuRyA9IFNIQTI1Nl9JVls2XSB8IDA7XG4gICAgICAgIHRoaXMuSCA9IFNIQTI1Nl9JVls3XSB8IDA7XG4gICAgfVxuICAgIGdldCgpIHtcbiAgICAgICAgY29uc3QgeyBBLCBCLCBDLCBELCBFLCBGLCBHLCBIIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW0EsIEIsIEMsIEQsIEUsIEYsIEcsIEhdO1xuICAgIH1cbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBzZXQoQSwgQiwgQywgRCwgRSwgRiwgRywgSCkge1xuICAgICAgICB0aGlzLkEgPSBBIHwgMDtcbiAgICAgICAgdGhpcy5CID0gQiB8IDA7XG4gICAgICAgIHRoaXMuQyA9IEMgfCAwO1xuICAgICAgICB0aGlzLkQgPSBEIHwgMDtcbiAgICAgICAgdGhpcy5FID0gRSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IEYgfCAwO1xuICAgICAgICB0aGlzLkcgPSBHIHwgMDtcbiAgICAgICAgdGhpcy5IID0gSCB8IDA7XG4gICAgfVxuICAgIHByb2Nlc3Modmlldywgb2Zmc2V0KSB7XG4gICAgICAgIC8vIEV4dGVuZCB0aGUgZmlyc3QgMTYgd29yZHMgaW50byB0aGUgcmVtYWluaW5nIDQ4IHdvcmRzIHdbMTYuLjYzXSBvZiB0aGUgbWVzc2FnZSBzY2hlZHVsZSBhcnJheVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyssIG9mZnNldCArPSA0KVxuICAgICAgICAgICAgU0hBMjU2X1dbaV0gPSB2aWV3LmdldFVpbnQzMihvZmZzZXQsIGZhbHNlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE2OyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgVzE1ID0gU0hBMjU2X1dbaSAtIDE1XTtcbiAgICAgICAgICAgIGNvbnN0IFcyID0gU0hBMjU2X1dbaSAtIDJdO1xuICAgICAgICAgICAgY29uc3QgczAgPSByb3RyKFcxNSwgNykgXiByb3RyKFcxNSwgMTgpIF4gKFcxNSA+Pj4gMyk7XG4gICAgICAgICAgICBjb25zdCBzMSA9IHJvdHIoVzIsIDE3KSBeIHJvdHIoVzIsIDE5KSBeIChXMiA+Pj4gMTApO1xuICAgICAgICAgICAgU0hBMjU2X1dbaV0gPSAoczEgKyBTSEEyNTZfV1tpIC0gN10gKyBzMCArIFNIQTI1Nl9XW2kgLSAxNl0pIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wcmVzc2lvbiBmdW5jdGlvbiBtYWluIGxvb3AsIDY0IHJvdW5kc1xuICAgICAgICBsZXQgeyBBLCBCLCBDLCBELCBFLCBGLCBHLCBIIH0gPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY0OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMSA9IHJvdHIoRSwgNikgXiByb3RyKEUsIDExKSBeIHJvdHIoRSwgMjUpO1xuICAgICAgICAgICAgY29uc3QgVDEgPSAoSCArIHNpZ21hMSArIENoaShFLCBGLCBHKSArIFNIQTI1Nl9LW2ldICsgU0hBMjU2X1dbaV0pIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMCA9IHJvdHIoQSwgMikgXiByb3RyKEEsIDEzKSBeIHJvdHIoQSwgMjIpO1xuICAgICAgICAgICAgY29uc3QgVDIgPSAoc2lnbWEwICsgTWFqKEEsIEIsIEMpKSB8IDA7XG4gICAgICAgICAgICBIID0gRztcbiAgICAgICAgICAgIEcgPSBGO1xuICAgICAgICAgICAgRiA9IEU7XG4gICAgICAgICAgICBFID0gKEQgKyBUMSkgfCAwO1xuICAgICAgICAgICAgRCA9IEM7XG4gICAgICAgICAgICBDID0gQjtcbiAgICAgICAgICAgIEIgPSBBO1xuICAgICAgICAgICAgQSA9IChUMSArIFQyKSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBjb21wcmVzc2VkIGNodW5rIHRvIHRoZSBjdXJyZW50IGhhc2ggdmFsdWVcbiAgICAgICAgQSA9IChBICsgdGhpcy5BKSB8IDA7XG4gICAgICAgIEIgPSAoQiArIHRoaXMuQikgfCAwO1xuICAgICAgICBDID0gKEMgKyB0aGlzLkMpIHwgMDtcbiAgICAgICAgRCA9IChEICsgdGhpcy5EKSB8IDA7XG4gICAgICAgIEUgPSAoRSArIHRoaXMuRSkgfCAwO1xuICAgICAgICBGID0gKEYgKyB0aGlzLkYpIHwgMDtcbiAgICAgICAgRyA9IChHICsgdGhpcy5HKSB8IDA7XG4gICAgICAgIEggPSAoSCArIHRoaXMuSCkgfCAwO1xuICAgICAgICB0aGlzLnNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKTtcbiAgICB9XG4gICAgcm91bmRDbGVhbigpIHtcbiAgICAgICAgU0hBMjU2X1cuZmlsbCgwKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgICAgIHRoaXMuYnVmZmVyLmZpbGwoMCk7XG4gICAgfVxufVxuLyoqXG4gKiBDb25zdGFudHMgdGFrZW4gZnJvbSBodHRwczovL252bHB1YnMubmlzdC5nb3YvbmlzdHB1YnMvRklQUy9OSVNULkZJUFMuMTgwLTQucGRmLlxuICovXG5jbGFzcyBTSEEyMjQgZXh0ZW5kcyBTSEEyNTYge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLkEgPSAweGMxMDU5ZWQ4IHwgMDtcbiAgICAgICAgdGhpcy5CID0gMHgzNjdjZDUwNyB8IDA7XG4gICAgICAgIHRoaXMuQyA9IDB4MzA3MGRkMTcgfCAwO1xuICAgICAgICB0aGlzLkQgPSAweGY3MGU1OTM5IHwgMDtcbiAgICAgICAgdGhpcy5FID0gMHhmZmMwMGIzMSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IDB4Njg1ODE1MTEgfCAwO1xuICAgICAgICB0aGlzLkcgPSAweDY0Zjk4ZmE3IHwgMDtcbiAgICAgICAgdGhpcy5IID0gMHhiZWZhNGZhNCB8IDA7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gMjg7XG4gICAgfVxufVxuLyoqIFNIQTItMjU2IGhhc2ggZnVuY3Rpb24gKi9cbmV4cG9ydCBjb25zdCBzaGEyNTYgPSAvKiBAX19QVVJFX18gKi8gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBTSEEyNTYoKSk7XG4vKiogU0hBMi0yMjQgaGFzaCBmdW5jdGlvbiAqL1xuZXhwb3J0IGNvbnN0IHNoYTIyNCA9IC8qIEBfX1BVUkVfXyAqLyB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTIyNCgpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYTI1Ni5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/hashes/esm/sha256.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/hashes/esm/utils.js":
/*!*************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/utils.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hash: () => (/* binding */ Hash),\n/* harmony export */   asyncLoop: () => (/* binding */ asyncLoop),\n/* harmony export */   byteSwap: () => (/* binding */ byteSwap),\n/* harmony export */   byteSwap32: () => (/* binding */ byteSwap32),\n/* harmony export */   byteSwapIfBE: () => (/* binding */ byteSwapIfBE),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   checkOpts: () => (/* binding */ checkOpts),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createView: () => (/* binding */ createView),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   isBytes: () => (/* binding */ isBytes),\n/* harmony export */   isLE: () => (/* binding */ isLE),\n/* harmony export */   nextTick: () => (/* binding */ nextTick),\n/* harmony export */   randomBytes: () => (/* binding */ randomBytes),\n/* harmony export */   rotl: () => (/* binding */ rotl),\n/* harmony export */   rotr: () => (/* binding */ rotr),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   u32: () => (/* binding */ u32),\n/* harmony export */   u8: () => (/* binding */ u8),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   wrapConstructor: () => (/* binding */ wrapConstructor),\n/* harmony export */   wrapConstructorWithOpts: () => (/* binding */ wrapConstructorWithOpts),\n/* harmony export */   wrapXOFConstructorWithOpts: () => (/* binding */ wrapXOFConstructorWithOpts)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/crypto */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/crypto.js\");\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/_assert.js\");\n/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\n\n\n// export { isBytes } from './_assert.js';\n// We can't reuse isBytes from _assert, because somehow this causes huge perf issues\nfunction isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n// Cast array to different type\nfunction u8(arr) {\n    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\nfunction u32(arr) {\n    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n// Cast array to view\nfunction createView(arr) {\n    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** The rotate right (circular right shift) operation for uint32 */\nfunction rotr(word, shift) {\n    return (word << (32 - shift)) | (word >>> shift);\n}\n/** The rotate left (circular left shift) operation for uint32 */\nfunction rotl(word, shift) {\n    return (word << shift) | ((word >>> (32 - shift)) >>> 0);\n}\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nconst isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n// The byte swap operation for uint32\nfunction byteSwap(word) {\n    return (((word << 24) & 0xff000000) |\n        ((word << 8) & 0xff0000) |\n        ((word >>> 8) & 0xff00) |\n        ((word >>> 24) & 0xff));\n}\n/** Conditionally byte swap if on a big-endian platform */\nconst byteSwapIfBE = isLE\n    ? (n) => n\n    : (n) => byteSwap(n);\n/** In place byte swap for Uint32Array */\nfunction byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = byteSwap(arr[i]);\n    }\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * Convert byte array to hex string.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(bytes);\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9)\n        return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F)\n        return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f)\n        return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * Convert hex string to byte array.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */\nconst nextTick = async () => { };\n/** Returns control to thread each 'tick' ms to avoid blocking. */\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * Convert JS string to byte array.\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error('utf8ToBytes expected string, got ' + typeof str);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(data);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n/** For runtime check if class implements interface */\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\n/** Wraps hash function, creating an interface on top of it */\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nfunction wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nfunction randomBytes(bytesLength = 32) {\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto.getRandomValues === 'function') {\n        return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    // Legacy Node.js compatibility\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto.randomBytes === 'function') {\n        return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto.randomBytes(bytesLength);\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM4QztBQUNSO0FBQ3RDLFlBQVksVUFBVTtBQUN0QjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1Asb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxhQUFhO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxJQUFJLGtEQUFNO0FBQ1Y7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsU0FBUztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsSUFBSSxrREFBTTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBLFFBQVEsa0RBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsbUJBQW1CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsUUFBUSx3REFBTSxXQUFXLHdEQUFNO0FBQy9CLGVBQWUsd0RBQU07QUFDckI7QUFDQTtBQUNBLFFBQVEsd0RBQU0sV0FBVyx3REFBTTtBQUMvQixlQUFlLHdEQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9sZmcvR2l0L01hZHRyaXBzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS91dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFV0aWxpdGllcyBmb3IgaGV4LCBieXRlcywgQ1NQUk5HLlxuICogQG1vZHVsZVxuICovXG4vKiEgbm9ibGUtaGFzaGVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBXZSB1c2UgV2ViQ3J5cHRvIGFrYSBnbG9iYWxUaGlzLmNyeXB0bywgd2hpY2ggZXhpc3RzIGluIGJyb3dzZXJzIGFuZCBub2RlLmpzIDE2Ky5cbi8vIG5vZGUuanMgdmVyc2lvbnMgZWFybGllciB0aGFuIHYxOSBkb24ndCBkZWNsYXJlIGl0IGluIGdsb2JhbCBzY29wZS5cbi8vIEZvciBub2RlLmpzLCBwYWNrYWdlLmpzb24jZXhwb3J0cyBmaWVsZCBtYXBwaW5nIHJld3JpdGVzIGltcG9ydFxuLy8gZnJvbSBgY3J5cHRvYCB0byBgY3J5cHRvTm9kZWAsIHdoaWNoIGltcG9ydHMgbmF0aXZlIG1vZHVsZS5cbi8vIE1ha2VzIHRoZSB1dGlscyB1bi1pbXBvcnRhYmxlIGluIGJyb3dzZXJzIHdpdGhvdXQgYSBidW5kbGVyLlxuLy8gT25jZSBub2RlLmpzIDE4IGlzIGRlcHJlY2F0ZWQgKDIwMjUtMDQtMzApLCB3ZSBjYW4ganVzdCBkcm9wIHRoZSBpbXBvcnQuXG5pbXBvcnQgeyBjcnlwdG8gfSBmcm9tICdAbm9ibGUvaGFzaGVzL2NyeXB0byc7XG5pbXBvcnQgeyBhYnl0ZXMgfSBmcm9tICcuL19hc3NlcnQuanMnO1xuLy8gZXhwb3J0IHsgaXNCeXRlcyB9IGZyb20gJy4vX2Fzc2VydC5qcyc7XG4vLyBXZSBjYW4ndCByZXVzZSBpc0J5dGVzIGZyb20gX2Fzc2VydCwgYmVjYXVzZSBzb21laG93IHRoaXMgY2F1c2VzIGh1Z2UgcGVyZiBpc3N1ZXNcbmV4cG9ydCBmdW5jdGlvbiBpc0J5dGVzKGEpIHtcbiAgICByZXR1cm4gYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgKEFycmF5QnVmZmVyLmlzVmlldyhhKSAmJiBhLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdVaW50OEFycmF5Jyk7XG59XG4vLyBDYXN0IGFycmF5IHRvIGRpZmZlcmVudCB0eXBlXG5leHBvcnQgZnVuY3Rpb24gdTgoYXJyKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG59XG5leHBvcnQgZnVuY3Rpb24gdTMyKGFycikge1xuICAgIHJldHVybiBuZXcgVWludDMyQXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIE1hdGguZmxvb3IoYXJyLmJ5dGVMZW5ndGggLyA0KSk7XG59XG4vLyBDYXN0IGFycmF5IHRvIHZpZXdcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVWaWV3KGFycikge1xuICAgIHJldHVybiBuZXcgRGF0YVZpZXcoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbn1cbi8qKiBUaGUgcm90YXRlIHJpZ2h0IChjaXJjdWxhciByaWdodCBzaGlmdCkgb3BlcmF0aW9uIGZvciB1aW50MzIgKi9cbmV4cG9ydCBmdW5jdGlvbiByb3RyKHdvcmQsIHNoaWZ0KSB7XG4gICAgcmV0dXJuICh3b3JkIDw8ICgzMiAtIHNoaWZ0KSkgfCAod29yZCA+Pj4gc2hpZnQpO1xufVxuLyoqIFRoZSByb3RhdGUgbGVmdCAoY2lyY3VsYXIgbGVmdCBzaGlmdCkgb3BlcmF0aW9uIGZvciB1aW50MzIgKi9cbmV4cG9ydCBmdW5jdGlvbiByb3RsKHdvcmQsIHNoaWZ0KSB7XG4gICAgcmV0dXJuICh3b3JkIDw8IHNoaWZ0KSB8ICgod29yZCA+Pj4gKDMyIC0gc2hpZnQpKSA+Pj4gMCk7XG59XG4vKiogSXMgY3VycmVudCBwbGF0Zm9ybSBsaXR0bGUtZW5kaWFuPyBNb3N0IGFyZS4gQmlnLUVuZGlhbiBwbGF0Zm9ybTogSUJNICovXG5leHBvcnQgY29uc3QgaXNMRSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQzMkFycmF5KFsweDExMjIzMzQ0XSkuYnVmZmVyKVswXSA9PT0gMHg0NCkoKTtcbi8vIFRoZSBieXRlIHN3YXAgb3BlcmF0aW9uIGZvciB1aW50MzJcbmV4cG9ydCBmdW5jdGlvbiBieXRlU3dhcCh3b3JkKSB7XG4gICAgcmV0dXJuICgoKHdvcmQgPDwgMjQpICYgMHhmZjAwMDAwMCkgfFxuICAgICAgICAoKHdvcmQgPDwgOCkgJiAweGZmMDAwMCkgfFxuICAgICAgICAoKHdvcmQgPj4+IDgpICYgMHhmZjAwKSB8XG4gICAgICAgICgod29yZCA+Pj4gMjQpICYgMHhmZikpO1xufVxuLyoqIENvbmRpdGlvbmFsbHkgYnl0ZSBzd2FwIGlmIG9uIGEgYmlnLWVuZGlhbiBwbGF0Zm9ybSAqL1xuZXhwb3J0IGNvbnN0IGJ5dGVTd2FwSWZCRSA9IGlzTEVcbiAgICA/IChuKSA9PiBuXG4gICAgOiAobikgPT4gYnl0ZVN3YXAobik7XG4vKiogSW4gcGxhY2UgYnl0ZSBzd2FwIGZvciBVaW50MzJBcnJheSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVTd2FwMzIoYXJyKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyW2ldID0gYnl0ZVN3YXAoYXJyW2ldKTtcbiAgICB9XG59XG4vLyBBcnJheSB3aGVyZSBpbmRleCAweGYwICgyNDApIGlzIG1hcHBlZCB0byBzdHJpbmcgJ2YwJ1xuY29uc3QgaGV4ZXMgPSAvKiBAX19QVVJFX18gKi8gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sIChfLCBpKSA9PiBpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbi8qKlxuICogQ29udmVydCBieXRlIGFycmF5IHRvIGhleCBzdHJpbmcuXG4gKiBAZXhhbXBsZSBieXRlc1RvSGV4KFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pKSAvLyAnY2FmZTAxMjMnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvSGV4KGJ5dGVzKSB7XG4gICAgYWJ5dGVzKGJ5dGVzKTtcbiAgICAvLyBwcmUtY2FjaGluZyBpbXByb3ZlcyB0aGUgc3BlZWQgNnhcbiAgICBsZXQgaGV4ID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBoZXggKz0gaGV4ZXNbYnl0ZXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufVxuLy8gV2UgdXNlIG9wdGltaXplZCB0ZWNobmlxdWUgdG8gY29udmVydCBoZXggc3RyaW5nIHRvIGJ5dGUgYXJyYXlcbmNvbnN0IGFzY2lpcyA9IHsgXzA6IDQ4LCBfOTogNTcsIEE6IDY1LCBGOiA3MCwgYTogOTcsIGY6IDEwMiB9O1xuZnVuY3Rpb24gYXNjaWlUb0Jhc2UxNihjaCkge1xuICAgIGlmIChjaCA+PSBhc2NpaXMuXzAgJiYgY2ggPD0gYXNjaWlzLl85KVxuICAgICAgICByZXR1cm4gY2ggLSBhc2NpaXMuXzA7IC8vICcyJyA9PiA1MC00OFxuICAgIGlmIChjaCA+PSBhc2NpaXMuQSAmJiBjaCA8PSBhc2NpaXMuRilcbiAgICAgICAgcmV0dXJuIGNoIC0gKGFzY2lpcy5BIC0gMTApOyAvLyAnQicgPT4gNjYtKDY1LTEwKVxuICAgIGlmIChjaCA+PSBhc2NpaXMuYSAmJiBjaCA8PSBhc2NpaXMuZilcbiAgICAgICAgcmV0dXJuIGNoIC0gKGFzY2lpcy5hIC0gMTApOyAvLyAnYicgPT4gOTgtKDk3LTEwKVxuICAgIHJldHVybjtcbn1cbi8qKlxuICogQ29udmVydCBoZXggc3RyaW5nIHRvIGJ5dGUgYXJyYXkuXG4gKiBAZXhhbXBsZSBoZXhUb0J5dGVzKCdjYWZlMDEyMycpIC8vIFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb0J5dGVzKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIGNvbnN0IGhsID0gaGV4Lmxlbmd0aDtcbiAgICBjb25zdCBhbCA9IGhsIC8gMjtcbiAgICBpZiAoaGwgJSAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCB1bnBhZGRlZCBoZXggb2YgbGVuZ3RoICcgKyBobCk7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShhbCk7XG4gICAgZm9yIChsZXQgYWkgPSAwLCBoaSA9IDA7IGFpIDwgYWw7IGFpKyssIGhpICs9IDIpIHtcbiAgICAgICAgY29uc3QgbjEgPSBhc2NpaVRvQmFzZTE2KGhleC5jaGFyQ29kZUF0KGhpKSk7XG4gICAgICAgIGNvbnN0IG4yID0gYXNjaWlUb0Jhc2UxNihoZXguY2hhckNvZGVBdChoaSArIDEpKTtcbiAgICAgICAgaWYgKG4xID09PSB1bmRlZmluZWQgfHwgbjIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgY2hhciA9IGhleFtoaV0gKyBoZXhbaGkgKyAxXTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IG5vbi1oZXggY2hhcmFjdGVyIFwiJyArIGNoYXIgKyAnXCIgYXQgaW5kZXggJyArIGhpKTtcbiAgICAgICAgfVxuICAgICAgICBhcnJheVthaV0gPSBuMSAqIDE2ICsgbjI7IC8vIG11bHRpcGx5IGZpcnN0IG9jdGV0LCBlLmcuICdhMycgPT4gMTAqMTYrMyA9PiAxNjAgKyAzID0+IDE2M1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG4vKipcbiAqIFRoZXJlIGlzIG5vIHNldEltbWVkaWF0ZSBpbiBicm93c2VyIGFuZCBzZXRUaW1lb3V0IGlzIHNsb3cuXG4gKiBDYWxsIG9mIGFzeW5jIGZuIHdpbGwgcmV0dXJuIFByb21pc2UsIHdoaWNoIHdpbGwgYmUgZnVsbGZpbGVkIG9ubHkgb25cbiAqIG5leHQgc2NoZWR1bGVyIHF1ZXVlIHByb2Nlc3Npbmcgc3RlcCBhbmQgdGhpcyBpcyBleGFjdGx5IHdoYXQgd2UgbmVlZC5cbiAqL1xuZXhwb3J0IGNvbnN0IG5leHRUaWNrID0gYXN5bmMgKCkgPT4geyB9O1xuLyoqIFJldHVybnMgY29udHJvbCB0byB0aHJlYWQgZWFjaCAndGljaycgbXMgdG8gYXZvaWQgYmxvY2tpbmcuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXN5bmNMb29wKGl0ZXJzLCB0aWNrLCBjYikge1xuICAgIGxldCB0cyA9IERhdGUubm93KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyczsgaSsrKSB7XG4gICAgICAgIGNiKGkpO1xuICAgICAgICAvLyBEYXRlLm5vdygpIGlzIG5vdCBtb25vdG9uaWMsIHNvIGluIGNhc2UgaWYgY2xvY2sgZ29lcyBiYWNrd2FyZHMgd2UgcmV0dXJuIHJldHVybiBjb250cm9sIHRvb1xuICAgICAgICBjb25zdCBkaWZmID0gRGF0ZS5ub3coKSAtIHRzO1xuICAgICAgICBpZiAoZGlmZiA+PSAwICYmIGRpZmYgPCB0aWNrKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGF3YWl0IG5leHRUaWNrKCk7XG4gICAgICAgIHRzICs9IGRpZmY7XG4gICAgfVxufVxuLyoqXG4gKiBDb252ZXJ0IEpTIHN0cmluZyB0byBieXRlIGFycmF5LlxuICogQGV4YW1wbGUgdXRmOFRvQnl0ZXMoJ2FiYycpIC8vIG5ldyBVaW50OEFycmF5KFs5NywgOTgsIDk5XSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1dGY4VG9CeXRlcyBleHBlY3RlZCBzdHJpbmcsIGdvdCAnICsgdHlwZW9mIHN0cik7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpKTsgLy8gaHR0cHM6Ly9idWd6aWwubGEvMTY4MTgwOVxufVxuLyoqXG4gKiBOb3JtYWxpemVzIChub24taGV4KSBzdHJpbmcgb3IgVWludDhBcnJheSB0byBVaW50OEFycmF5LlxuICogV2FybmluZzogd2hlbiBVaW50OEFycmF5IGlzIHBhc3NlZCwgaXQgd291bGQgTk9UIGdldCBjb3BpZWQuXG4gKiBLZWVwIGluIG1pbmQgZm9yIGZ1dHVyZSBtdXRhYmxlIG9wZXJhdGlvbnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0J5dGVzKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKVxuICAgICAgICBkYXRhID0gdXRmOFRvQnl0ZXMoZGF0YSk7XG4gICAgYWJ5dGVzKGRhdGEpO1xuICAgIHJldHVybiBkYXRhO1xufVxuLyoqXG4gKiBDb3BpZXMgc2V2ZXJhbCBVaW50OEFycmF5cyBpbnRvIG9uZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5cykge1xuICAgIGxldCBzdW0gPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBhcnJheXNbaV07XG4gICAgICAgIGFieXRlcyhhKTtcbiAgICAgICAgc3VtICs9IGEubGVuZ3RoO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheShzdW0pO1xuICAgIGZvciAobGV0IGkgPSAwLCBwYWQgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBhcnJheXNbaV07XG4gICAgICAgIHJlcy5zZXQoYSwgcGFkKTtcbiAgICAgICAgcGFkICs9IGEubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLyoqIEZvciBydW50aW1lIGNoZWNrIGlmIGNsYXNzIGltcGxlbWVudHMgaW50ZXJmYWNlICovXG5leHBvcnQgY2xhc3MgSGFzaCB7XG4gICAgLy8gU2FmZSB2ZXJzaW9uIHRoYXQgY2xvbmVzIGludGVybmFsIHN0YXRlXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbG9uZUludG8oKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gY2hlY2tPcHRzKGRlZmF1bHRzLCBvcHRzKSB7XG4gICAgaWYgKG9wdHMgIT09IHVuZGVmaW5lZCAmJiB7fS50b1N0cmluZy5jYWxsKG9wdHMpICE9PSAnW29iamVjdCBPYmplY3RdJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcHRpb25zIHNob3VsZCBiZSBvYmplY3Qgb3IgdW5kZWZpbmVkJyk7XG4gICAgY29uc3QgbWVyZ2VkID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0cywgb3B0cyk7XG4gICAgcmV0dXJuIG1lcmdlZDtcbn1cbi8qKiBXcmFwcyBoYXNoIGZ1bmN0aW9uLCBjcmVhdGluZyBhbiBpbnRlcmZhY2Ugb24gdG9wIG9mIGl0ICovXG5leHBvcnQgZnVuY3Rpb24gd3JhcENvbnN0cnVjdG9yKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnKSA9PiBoYXNoQ29ucygpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKCk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAoKSA9PiBoYXNoQ29ucygpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbmV4cG9ydCBmdW5jdGlvbiB3cmFwQ29uc3RydWN0b3JXaXRoT3B0cyhoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZywgb3B0cykgPT4gaGFzaENvbnMob3B0cykudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoe30pO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKG9wdHMpID0+IGhhc2hDb25zKG9wdHMpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbmV4cG9ydCBmdW5jdGlvbiB3cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cyhoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZywgb3B0cykgPT4gaGFzaENvbnMob3B0cykudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoe30pO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKG9wdHMpID0+IGhhc2hDb25zKG9wdHMpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbi8qKiBDcnlwdG9ncmFwaGljYWxseSBzZWN1cmUgUFJORy4gVXNlcyBpbnRlcm5hbCBPUy1sZXZlbCBgY3J5cHRvLmdldFJhbmRvbVZhbHVlc2AuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tQnl0ZXMoYnl0ZXNMZW5ndGggPSAzMikge1xuICAgIGlmIChjcnlwdG8gJiYgdHlwZW9mIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoYnl0ZXNMZW5ndGgpKTtcbiAgICB9XG4gICAgLy8gTGVnYWN5IE5vZGUuanMgY29tcGF0aWJpbGl0eVxuICAgIGlmIChjcnlwdG8gJiYgdHlwZW9mIGNyeXB0by5yYW5kb21CeXRlcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gY3J5cHRvLnJhbmRvbUJ5dGVzKGJ5dGVzTGVuZ3RoKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIG11c3QgYmUgZGVmaW5lZCcpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/hashes/esm/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk-react/dist/ndk-react.es.js":
/*!********************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk-react/dist/ndk-react.es.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   INVOICE: () => (/* binding */ Ha),\n/* harmony export */   LINK: () => (/* binding */ xi),\n/* harmony export */   NDKProvider: () => (/* binding */ Pp),\n/* harmony export */   NEWLINE: () => (/* binding */ Op),\n/* harmony export */   NOSTR_NADDR: () => (/* binding */ Up),\n/* harmony export */   NOSTR_NEVENT: () => (/* binding */ $p),\n/* harmony export */   NOSTR_NOTE: () => (/* binding */ Lp),\n/* harmony export */   NOSTR_NPROFILE: () => (/* binding */ Np),\n/* harmony export */   NOSTR_NPUB: () => (/* binding */ qp),\n/* harmony export */   TEXT: () => (/* binding */ Hn),\n/* harmony export */   TOPIC: () => (/* binding */ ja),\n/* harmony export */   fromNostrURI: () => (/* binding */ Ap),\n/* harmony export */   getLinks: () => (/* binding */ Mp),\n/* harmony export */   parseContent: () => (/* binding */ jp),\n/* harmony export */   truncateContent: () => (/* binding */ Hp),\n/* harmony export */   urlIsMedia: () => (/* binding */ Cp),\n/* harmony export */   useNDK: () => (/* binding */ Bp)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\nvar ac = Object.defineProperty;\nvar cc = (t, e, r) => e in t ? ac(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r;\nvar I = (t, e, r) => (cc(t, typeof e != \"symbol\" ? e + \"\" : e, r), r);\n\nvar S = typeof globalThis < \"u\" ? globalThis : typeof window < \"u\" ? window : typeof global < \"u\" ? global : typeof self < \"u\" ? self : {};\nfunction Et(t) {\n  var e = t.default;\n  if (typeof e == \"function\") {\n    var r = function() {\n      return e.apply(this, arguments);\n    };\n    r.prototype = e.prototype;\n  } else\n    r = {};\n  return Object.defineProperty(r, \"__esModule\", { value: !0 }), Object.keys(t).forEach(function(n) {\n    var i = Object.getOwnPropertyDescriptor(t, n);\n    Object.defineProperty(r, n, i.get ? i : {\n      enumerable: !0,\n      get: function() {\n        return t[n];\n      }\n    });\n  }), r;\n}\nvar On = { exports: {} }, en, qi;\nfunction hc() {\n  if (qi)\n    return en;\n  qi = 1;\n  var t = 1e3, e = t * 60, r = e * 60, n = r * 24, i = n * 7, s = n * 365.25;\n  en = function(f, u) {\n    u = u || {};\n    var h = typeof f;\n    if (h === \"string\" && f.length > 0)\n      return o(f);\n    if (h === \"number\" && isFinite(f))\n      return u.long ? c(f) : a(f);\n    throw new Error(\n      \"val is not a non-empty string or a valid number. val=\" + JSON.stringify(f)\n    );\n  };\n  function o(f) {\n    if (f = String(f), !(f.length > 100)) {\n      var u = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n        f\n      );\n      if (!!u) {\n        var h = parseFloat(u[1]), d = (u[2] || \"ms\").toLowerCase();\n        switch (d) {\n          case \"years\":\n          case \"year\":\n          case \"yrs\":\n          case \"yr\":\n          case \"y\":\n            return h * s;\n          case \"weeks\":\n          case \"week\":\n          case \"w\":\n            return h * i;\n          case \"days\":\n          case \"day\":\n          case \"d\":\n            return h * n;\n          case \"hours\":\n          case \"hour\":\n          case \"hrs\":\n          case \"hr\":\n          case \"h\":\n            return h * r;\n          case \"minutes\":\n          case \"minute\":\n          case \"mins\":\n          case \"min\":\n          case \"m\":\n            return h * e;\n          case \"seconds\":\n          case \"second\":\n          case \"secs\":\n          case \"sec\":\n          case \"s\":\n            return h * t;\n          case \"milliseconds\":\n          case \"millisecond\":\n          case \"msecs\":\n          case \"msec\":\n          case \"ms\":\n            return h;\n          default:\n            return;\n        }\n      }\n    }\n  }\n  function a(f) {\n    var u = Math.abs(f);\n    return u >= n ? Math.round(f / n) + \"d\" : u >= r ? Math.round(f / r) + \"h\" : u >= e ? Math.round(f / e) + \"m\" : u >= t ? Math.round(f / t) + \"s\" : f + \"ms\";\n  }\n  function c(f) {\n    var u = Math.abs(f);\n    return u >= n ? l(f, u, n, \"day\") : u >= r ? l(f, u, r, \"hour\") : u >= e ? l(f, u, e, \"minute\") : u >= t ? l(f, u, t, \"second\") : f + \" ms\";\n  }\n  function l(f, u, h, d) {\n    var p = u >= h * 1.5;\n    return Math.round(f / h) + \" \" + d + (p ? \"s\" : \"\");\n  }\n  return en;\n}\nfunction dc(t) {\n  r.debug = r, r.default = r, r.coerce = c, r.disable = s, r.enable = i, r.enabled = o, r.humanize = hc(), r.destroy = l, Object.keys(t).forEach((f) => {\n    r[f] = t[f];\n  }), r.names = [], r.skips = [], r.formatters = {};\n  function e(f) {\n    let u = 0;\n    for (let h = 0; h < f.length; h++)\n      u = (u << 5) - u + f.charCodeAt(h), u |= 0;\n    return r.colors[Math.abs(u) % r.colors.length];\n  }\n  r.selectColor = e;\n  function r(f) {\n    let u, h = null, d, p;\n    function y(...g) {\n      if (!y.enabled)\n        return;\n      const v = y, _ = Number(new Date()), m = _ - (u || _);\n      v.diff = m, v.prev = u, v.curr = _, u = _, g[0] = r.coerce(g[0]), typeof g[0] != \"string\" && g.unshift(\"%O\");\n      let C = 0;\n      g[0] = g[0].replace(/%([a-zA-Z%])/g, (w, x) => {\n        if (w === \"%%\")\n          return \"%\";\n        C++;\n        const A = r.formatters[x];\n        if (typeof A == \"function\") {\n          const B = g[C];\n          w = A.call(v, B), g.splice(C, 1), C--;\n        }\n        return w;\n      }), r.formatArgs.call(v, g), (v.log || r.log).apply(v, g);\n    }\n    return y.namespace = f, y.useColors = r.useColors(), y.color = r.selectColor(f), y.extend = n, y.destroy = r.destroy, Object.defineProperty(y, \"enabled\", {\n      enumerable: !0,\n      configurable: !1,\n      get: () => h !== null ? h : (d !== r.namespaces && (d = r.namespaces, p = r.enabled(f)), p),\n      set: (g) => {\n        h = g;\n      }\n    }), typeof r.init == \"function\" && r.init(y), y;\n  }\n  function n(f, u) {\n    const h = r(this.namespace + (typeof u > \"u\" ? \":\" : u) + f);\n    return h.log = this.log, h;\n  }\n  function i(f) {\n    r.save(f), r.namespaces = f, r.names = [], r.skips = [];\n    let u;\n    const h = (typeof f == \"string\" ? f : \"\").split(/[\\s,]+/), d = h.length;\n    for (u = 0; u < d; u++)\n      !h[u] || (f = h[u].replace(/\\*/g, \".*?\"), f[0] === \"-\" ? r.skips.push(new RegExp(\"^\" + f.slice(1) + \"$\")) : r.names.push(new RegExp(\"^\" + f + \"$\")));\n  }\n  function s() {\n    const f = [\n      ...r.names.map(a),\n      ...r.skips.map(a).map((u) => \"-\" + u)\n    ].join(\",\");\n    return r.enable(\"\"), f;\n  }\n  function o(f) {\n    if (f[f.length - 1] === \"*\")\n      return !0;\n    let u, h;\n    for (u = 0, h = r.skips.length; u < h; u++)\n      if (r.skips[u].test(f))\n        return !1;\n    for (u = 0, h = r.names.length; u < h; u++)\n      if (r.names[u].test(f))\n        return !0;\n    return !1;\n  }\n  function a(f) {\n    return f.toString().substring(2, f.toString().length - 2).replace(/\\.\\*\\?$/, \"*\");\n  }\n  function c(f) {\n    return f instanceof Error ? f.stack || f.message : f;\n  }\n  function l() {\n    console.warn(\"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\");\n  }\n  return r.enable(r.load()), r;\n}\nvar pc = dc;\n(function(t, e) {\n  e.formatArgs = n, e.save = i, e.load = s, e.useColors = r, e.storage = o(), e.destroy = (() => {\n    let c = !1;\n    return () => {\n      c || (c = !0, console.warn(\"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\"));\n    };\n  })(), e.colors = [\n    \"#0000CC\",\n    \"#0000FF\",\n    \"#0033CC\",\n    \"#0033FF\",\n    \"#0066CC\",\n    \"#0066FF\",\n    \"#0099CC\",\n    \"#0099FF\",\n    \"#00CC00\",\n    \"#00CC33\",\n    \"#00CC66\",\n    \"#00CC99\",\n    \"#00CCCC\",\n    \"#00CCFF\",\n    \"#3300CC\",\n    \"#3300FF\",\n    \"#3333CC\",\n    \"#3333FF\",\n    \"#3366CC\",\n    \"#3366FF\",\n    \"#3399CC\",\n    \"#3399FF\",\n    \"#33CC00\",\n    \"#33CC33\",\n    \"#33CC66\",\n    \"#33CC99\",\n    \"#33CCCC\",\n    \"#33CCFF\",\n    \"#6600CC\",\n    \"#6600FF\",\n    \"#6633CC\",\n    \"#6633FF\",\n    \"#66CC00\",\n    \"#66CC33\",\n    \"#9900CC\",\n    \"#9900FF\",\n    \"#9933CC\",\n    \"#9933FF\",\n    \"#99CC00\",\n    \"#99CC33\",\n    \"#CC0000\",\n    \"#CC0033\",\n    \"#CC0066\",\n    \"#CC0099\",\n    \"#CC00CC\",\n    \"#CC00FF\",\n    \"#CC3300\",\n    \"#CC3333\",\n    \"#CC3366\",\n    \"#CC3399\",\n    \"#CC33CC\",\n    \"#CC33FF\",\n    \"#CC6600\",\n    \"#CC6633\",\n    \"#CC9900\",\n    \"#CC9933\",\n    \"#CCCC00\",\n    \"#CCCC33\",\n    \"#FF0000\",\n    \"#FF0033\",\n    \"#FF0066\",\n    \"#FF0099\",\n    \"#FF00CC\",\n    \"#FF00FF\",\n    \"#FF3300\",\n    \"#FF3333\",\n    \"#FF3366\",\n    \"#FF3399\",\n    \"#FF33CC\",\n    \"#FF33FF\",\n    \"#FF6600\",\n    \"#FF6633\",\n    \"#FF9900\",\n    \"#FF9933\",\n    \"#FFCC00\",\n    \"#FFCC33\"\n  ];\n  function r() {\n    return typeof window < \"u\" && window.process && (window.process.type === \"renderer\" || window.process.__nwjs) ? !0 : typeof navigator < \"u\" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/) ? !1 : typeof document < \"u\" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window < \"u\" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator < \"u\" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator < \"u\" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/);\n  }\n  function n(c) {\n    if (c[0] = (this.useColors ? \"%c\" : \"\") + this.namespace + (this.useColors ? \" %c\" : \" \") + c[0] + (this.useColors ? \"%c \" : \" \") + \"+\" + t.exports.humanize(this.diff), !this.useColors)\n      return;\n    const l = \"color: \" + this.color;\n    c.splice(1, 0, l, \"color: inherit\");\n    let f = 0, u = 0;\n    c[0].replace(/%[a-zA-Z%]/g, (h) => {\n      h !== \"%%\" && (f++, h === \"%c\" && (u = f));\n    }), c.splice(u, 0, l);\n  }\n  e.log = console.debug || console.log || (() => {\n  });\n  function i(c) {\n    try {\n      c ? e.storage.setItem(\"debug\", c) : e.storage.removeItem(\"debug\");\n    } catch {\n    }\n  }\n  function s() {\n    let c;\n    try {\n      c = e.storage.getItem(\"debug\");\n    } catch {\n    }\n    return !c && typeof process < \"u\" && \"env\" in process && (c = process.env.DEBUG), c;\n  }\n  function o() {\n    try {\n      return localStorage;\n    } catch {\n    }\n  }\n  t.exports = pc(e);\n  const { formatters: a } = t.exports;\n  a.j = function(c) {\n    try {\n      return JSON.stringify(c);\n    } catch (l) {\n      return \"[UnexpectedJSONParseError]: \" + l.message;\n    }\n  };\n})(On, On.exports);\nconst Mn = On.exports;\nvar Zo = { exports: {} };\n(function(t) {\n  var e = Object.prototype.hasOwnProperty, r = \"~\";\n  function n() {\n  }\n  Object.create && (n.prototype = /* @__PURE__ */ Object.create(null), new n().__proto__ || (r = !1));\n  function i(c, l, f) {\n    this.fn = c, this.context = l, this.once = f || !1;\n  }\n  function s(c, l, f, u, h) {\n    if (typeof f != \"function\")\n      throw new TypeError(\"The listener must be a function\");\n    var d = new i(f, u || c, h), p = r ? r + l : l;\n    return c._events[p] ? c._events[p].fn ? c._events[p] = [c._events[p], d] : c._events[p].push(d) : (c._events[p] = d, c._eventsCount++), c;\n  }\n  function o(c, l) {\n    --c._eventsCount === 0 ? c._events = new n() : delete c._events[l];\n  }\n  function a() {\n    this._events = new n(), this._eventsCount = 0;\n  }\n  a.prototype.eventNames = function() {\n    var l = [], f, u;\n    if (this._eventsCount === 0)\n      return l;\n    for (u in f = this._events)\n      e.call(f, u) && l.push(r ? u.slice(1) : u);\n    return Object.getOwnPropertySymbols ? l.concat(Object.getOwnPropertySymbols(f)) : l;\n  }, a.prototype.listeners = function(l) {\n    var f = r ? r + l : l, u = this._events[f];\n    if (!u)\n      return [];\n    if (u.fn)\n      return [u.fn];\n    for (var h = 0, d = u.length, p = new Array(d); h < d; h++)\n      p[h] = u[h].fn;\n    return p;\n  }, a.prototype.listenerCount = function(l) {\n    var f = r ? r + l : l, u = this._events[f];\n    return u ? u.fn ? 1 : u.length : 0;\n  }, a.prototype.emit = function(l, f, u, h, d, p) {\n    var y = r ? r + l : l;\n    if (!this._events[y])\n      return !1;\n    var g = this._events[y], v = arguments.length, _, m;\n    if (g.fn) {\n      switch (g.once && this.removeListener(l, g.fn, void 0, !0), v) {\n        case 1:\n          return g.fn.call(g.context), !0;\n        case 2:\n          return g.fn.call(g.context, f), !0;\n        case 3:\n          return g.fn.call(g.context, f, u), !0;\n        case 4:\n          return g.fn.call(g.context, f, u, h), !0;\n        case 5:\n          return g.fn.call(g.context, f, u, h, d), !0;\n        case 6:\n          return g.fn.call(g.context, f, u, h, d, p), !0;\n      }\n      for (m = 1, _ = new Array(v - 1); m < v; m++)\n        _[m - 1] = arguments[m];\n      g.fn.apply(g.context, _);\n    } else {\n      var C = g.length, O;\n      for (m = 0; m < C; m++)\n        switch (g[m].once && this.removeListener(l, g[m].fn, void 0, !0), v) {\n          case 1:\n            g[m].fn.call(g[m].context);\n            break;\n          case 2:\n            g[m].fn.call(g[m].context, f);\n            break;\n          case 3:\n            g[m].fn.call(g[m].context, f, u);\n            break;\n          case 4:\n            g[m].fn.call(g[m].context, f, u, h);\n            break;\n          default:\n            if (!_)\n              for (O = 1, _ = new Array(v - 1); O < v; O++)\n                _[O - 1] = arguments[O];\n            g[m].fn.apply(g[m].context, _);\n        }\n    }\n    return !0;\n  }, a.prototype.on = function(l, f, u) {\n    return s(this, l, f, u, !1);\n  }, a.prototype.once = function(l, f, u) {\n    return s(this, l, f, u, !0);\n  }, a.prototype.removeListener = function(l, f, u, h) {\n    var d = r ? r + l : l;\n    if (!this._events[d])\n      return this;\n    if (!f)\n      return o(this, d), this;\n    var p = this._events[d];\n    if (p.fn)\n      p.fn === f && (!h || p.once) && (!u || p.context === u) && o(this, d);\n    else {\n      for (var y = 0, g = [], v = p.length; y < v; y++)\n        (p[y].fn !== f || h && !p[y].once || u && p[y].context !== u) && g.push(p[y]);\n      g.length ? this._events[d] = g.length === 1 ? g[0] : g : o(this, d);\n    }\n    return this;\n  }, a.prototype.removeAllListeners = function(l) {\n    var f;\n    return l ? (f = r ? r + l : l, this._events[f] && o(this, f)) : (this._events = new n(), this._eventsCount = 0), this;\n  }, a.prototype.off = a.prototype.removeListener, a.prototype.addListener = a.prototype.on, a.prefixed = r, a.EventEmitter = a, t.exports = a;\n})(Zo);\nconst dt = Zo.exports;\nfunction An(t) {\n  if (!Number.isSafeInteger(t) || t < 0)\n    throw new Error(`Wrong positive integer: ${t}`);\n}\nfunction yc(t) {\n  if (typeof t != \"boolean\")\n    throw new Error(`Expected boolean, not ${t}`);\n}\nfunction Yo(t, ...e) {\n  if (!(t instanceof Uint8Array))\n    throw new TypeError(\"Expected Uint8Array\");\n  if (e.length > 0 && !e.includes(t.length))\n    throw new TypeError(`Expected Uint8Array of length ${e}, not of length=${t.length}`);\n}\nfunction gc(t) {\n  if (typeof t != \"function\" || typeof t.create != \"function\")\n    throw new Error(\"Hash should be wrapped by utils.wrapConstructor\");\n  An(t.outputLen), An(t.blockLen);\n}\nfunction bc(t, e = !0) {\n  if (t.destroyed)\n    throw new Error(\"Hash instance has been destroyed\");\n  if (e && t.finished)\n    throw new Error(\"Hash#digest() has already been called\");\n}\nfunction vc(t, e) {\n  Yo(t);\n  const r = e.outputLen;\n  if (t.length < r)\n    throw new Error(`digestInto() expects output buffer of length at least ${r}`);\n}\nconst ut = {\n  number: An,\n  bool: yc,\n  bytes: Yo,\n  hash: gc,\n  exists: bc,\n  output: vc\n}, tn = typeof globalThis == \"object\" && \"crypto\" in globalThis ? globalThis.crypto : void 0;\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst rn = (t) => new DataView(t.buffer, t.byteOffset, t.byteLength), Ae = (t, e) => t << 32 - e | t >>> e, wc = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;\nif (!wc)\n  throw new Error(\"Non little-endian hardware is not supported\");\nArray.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, \"0\"));\nfunction _c(t) {\n  if (typeof t != \"string\")\n    throw new TypeError(`utf8ToBytes expected string, got ${typeof t}`);\n  return new TextEncoder().encode(t);\n}\nfunction Dn(t) {\n  if (typeof t == \"string\" && (t = _c(t)), !(t instanceof Uint8Array))\n    throw new TypeError(`Expected input type is Uint8Array (got ${typeof t})`);\n  return t;\n}\nfunction mc(...t) {\n  if (!t.every((n) => n instanceof Uint8Array))\n    throw new Error(\"Uint8Array list expected\");\n  if (t.length === 1)\n    return t[0];\n  const e = t.reduce((n, i) => n + i.length, 0), r = new Uint8Array(e);\n  for (let n = 0, i = 0; n < t.length; n++) {\n    const s = t[n];\n    r.set(s, i), i += s.length;\n  }\n  return r;\n}\nclass Jo {\n  clone() {\n    return this._cloneInto();\n  }\n}\nfunction Xo(t) {\n  const e = (n) => t().update(Dn(n)).digest(), r = t();\n  return e.outputLen = r.outputLen, e.blockLen = r.blockLen, e.create = () => t(), e;\n}\nfunction Qo(t = 32) {\n  if (tn && typeof tn.getRandomValues == \"function\")\n    return tn.getRandomValues(new Uint8Array(t));\n  throw new Error(\"crypto.getRandomValues must be defined\");\n}\nfunction xc(t, e, r, n) {\n  if (typeof t.setBigUint64 == \"function\")\n    return t.setBigUint64(e, r, n);\n  const i = BigInt(32), s = BigInt(4294967295), o = Number(r >> i & s), a = Number(r & s), c = n ? 4 : 0, l = n ? 0 : 4;\n  t.setUint32(e + c, o, n), t.setUint32(e + l, a, n);\n}\nclass Ec extends Jo {\n  constructor(e, r, n, i) {\n    super(), this.blockLen = e, this.outputLen = r, this.padOffset = n, this.isLE = i, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = rn(this.buffer);\n  }\n  update(e) {\n    ut.exists(this);\n    const { view: r, buffer: n, blockLen: i } = this;\n    e = Dn(e);\n    const s = e.length;\n    for (let o = 0; o < s; ) {\n      const a = Math.min(i - this.pos, s - o);\n      if (a === i) {\n        const c = rn(e);\n        for (; i <= s - o; o += i)\n          this.process(c, o);\n        continue;\n      }\n      n.set(e.subarray(o, o + a), this.pos), this.pos += a, o += a, this.pos === i && (this.process(r, 0), this.pos = 0);\n    }\n    return this.length += e.length, this.roundClean(), this;\n  }\n  digestInto(e) {\n    ut.exists(this), ut.output(e, this), this.finished = !0;\n    const { buffer: r, view: n, blockLen: i, isLE: s } = this;\n    let { pos: o } = this;\n    r[o++] = 128, this.buffer.subarray(o).fill(0), this.padOffset > i - o && (this.process(n, 0), o = 0);\n    for (let u = o; u < i; u++)\n      r[u] = 0;\n    xc(n, i - 8, BigInt(this.length * 8), s), this.process(n, 0);\n    const a = rn(e), c = this.outputLen;\n    if (c % 4)\n      throw new Error(\"_sha2: outputLen should be aligned to 32bit\");\n    const l = c / 4, f = this.get();\n    if (l > f.length)\n      throw new Error(\"_sha2: outputLen bigger than state\");\n    for (let u = 0; u < l; u++)\n      a.setUint32(4 * u, f[u], s);\n  }\n  digest() {\n    const { buffer: e, outputLen: r } = this;\n    this.digestInto(e);\n    const n = e.slice(0, r);\n    return this.destroy(), n;\n  }\n  _cloneInto(e) {\n    e || (e = new this.constructor()), e.set(...this.get());\n    const { blockLen: r, buffer: n, length: i, finished: s, destroyed: o, pos: a } = this;\n    return e.length = i, e.pos = a, e.finished = s, e.destroyed = o, i % r && e.buffer.set(n), e;\n  }\n}\nconst kc = (t, e, r) => t & e ^ ~t & r, Sc = (t, e, r) => t & e ^ t & r ^ e & r, Oc = new Uint32Array([\n  1116352408,\n  1899447441,\n  3049323471,\n  3921009573,\n  961987163,\n  1508970993,\n  2453635748,\n  2870763221,\n  3624381080,\n  310598401,\n  607225278,\n  1426881987,\n  1925078388,\n  2162078206,\n  2614888103,\n  3248222580,\n  3835390401,\n  4022224774,\n  264347078,\n  604807628,\n  770255983,\n  1249150122,\n  1555081692,\n  1996064986,\n  2554220882,\n  2821834349,\n  2952996808,\n  3210313671,\n  3336571891,\n  3584528711,\n  113926993,\n  338241895,\n  666307205,\n  773529912,\n  1294757372,\n  1396182291,\n  1695183700,\n  1986661051,\n  2177026350,\n  2456956037,\n  2730485921,\n  2820302411,\n  3259730800,\n  3345764771,\n  3516065817,\n  3600352804,\n  4094571909,\n  275423344,\n  430227734,\n  506948616,\n  659060556,\n  883997877,\n  958139571,\n  1322822218,\n  1537002063,\n  1747873779,\n  1955562222,\n  2024104815,\n  2227730452,\n  2361852424,\n  2428436474,\n  2756734187,\n  3204031479,\n  3329325298\n]), Me = new Uint32Array([\n  1779033703,\n  3144134277,\n  1013904242,\n  2773480762,\n  1359893119,\n  2600822924,\n  528734635,\n  1541459225\n]), De = new Uint32Array(64);\nclass es extends Ec {\n  constructor() {\n    super(64, 32, 8, !1), this.A = Me[0] | 0, this.B = Me[1] | 0, this.C = Me[2] | 0, this.D = Me[3] | 0, this.E = Me[4] | 0, this.F = Me[5] | 0, this.G = Me[6] | 0, this.H = Me[7] | 0;\n  }\n  get() {\n    const { A: e, B: r, C: n, D: i, E: s, F: o, G: a, H: c } = this;\n    return [e, r, n, i, s, o, a, c];\n  }\n  set(e, r, n, i, s, o, a, c) {\n    this.A = e | 0, this.B = r | 0, this.C = n | 0, this.D = i | 0, this.E = s | 0, this.F = o | 0, this.G = a | 0, this.H = c | 0;\n  }\n  process(e, r) {\n    for (let u = 0; u < 16; u++, r += 4)\n      De[u] = e.getUint32(r, !1);\n    for (let u = 16; u < 64; u++) {\n      const h = De[u - 15], d = De[u - 2], p = Ae(h, 7) ^ Ae(h, 18) ^ h >>> 3, y = Ae(d, 17) ^ Ae(d, 19) ^ d >>> 10;\n      De[u] = y + De[u - 7] + p + De[u - 16] | 0;\n    }\n    let { A: n, B: i, C: s, D: o, E: a, F: c, G: l, H: f } = this;\n    for (let u = 0; u < 64; u++) {\n      const h = Ae(a, 6) ^ Ae(a, 11) ^ Ae(a, 25), d = f + h + kc(a, c, l) + Oc[u] + De[u] | 0, y = (Ae(n, 2) ^ Ae(n, 13) ^ Ae(n, 22)) + Sc(n, i, s) | 0;\n      f = l, l = c, c = a, a = o + d | 0, o = s, s = i, i = n, n = d + y | 0;\n    }\n    n = n + this.A | 0, i = i + this.B | 0, s = s + this.C | 0, o = o + this.D | 0, a = a + this.E | 0, c = c + this.F | 0, l = l + this.G | 0, f = f + this.H | 0, this.set(n, i, s, o, a, c, l, f);\n  }\n  roundClean() {\n    De.fill(0);\n  }\n  destroy() {\n    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);\n  }\n}\nclass Ac extends es {\n  constructor() {\n    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;\n  }\n}\nconst Or = Xo(() => new es());\nXo(() => new Ac());\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst ts = BigInt(0), Lr = BigInt(1), Cc = BigInt(2), $r = (t) => t instanceof Uint8Array, Ic = Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, \"0\"));\nfunction vt(t) {\n  if (!$r(t))\n    throw new Error(\"Uint8Array expected\");\n  let e = \"\";\n  for (let r = 0; r < t.length; r++)\n    e += Ic[t[r]];\n  return e;\n}\nfunction rs(t) {\n  const e = t.toString(16);\n  return e.length & 1 ? `0${e}` : e;\n}\nfunction zn(t) {\n  if (typeof t != \"string\")\n    throw new Error(\"hex string expected, got \" + typeof t);\n  return BigInt(t === \"\" ? \"0\" : `0x${t}`);\n}\nfunction wt(t) {\n  if (typeof t != \"string\")\n    throw new Error(\"hex string expected, got \" + typeof t);\n  if (t.length % 2)\n    throw new Error(\"hex string is invalid: unpadded \" + t.length);\n  const e = new Uint8Array(t.length / 2);\n  for (let r = 0; r < e.length; r++) {\n    const n = r * 2, i = t.slice(n, n + 2), s = Number.parseInt(i, 16);\n    if (Number.isNaN(s) || s < 0)\n      throw new Error(\"invalid byte sequence\");\n    e[r] = s;\n  }\n  return e;\n}\nfunction le(t) {\n  return zn(vt(t));\n}\nfunction Fn(t) {\n  if (!$r(t))\n    throw new Error(\"Uint8Array expected\");\n  return zn(vt(Uint8Array.from(t).reverse()));\n}\nconst et = (t, e) => wt(t.toString(16).padStart(e * 2, \"0\")), ns = (t, e) => et(t, e).reverse(), Rc = (t) => wt(rs(t));\nfunction ee(t, e, r) {\n  let n;\n  if (typeof e == \"string\")\n    try {\n      n = wt(e);\n    } catch (s) {\n      throw new Error(`${t} must be valid hex string, got \"${e}\". Cause: ${s}`);\n    }\n  else if ($r(e))\n    n = Uint8Array.from(e);\n  else\n    throw new Error(`${t} must be hex string or Uint8Array`);\n  const i = n.length;\n  if (typeof r == \"number\" && i !== r)\n    throw new Error(`${t} expected ${r} bytes, got ${i}`);\n  return n;\n}\nfunction he(...t) {\n  const e = new Uint8Array(t.reduce((n, i) => n + i.length, 0));\n  let r = 0;\n  return t.forEach((n) => {\n    if (!$r(n))\n      throw new Error(\"Uint8Array expected\");\n    e.set(n, r), r += n.length;\n  }), e;\n}\nfunction Tc(t, e) {\n  if (t.length !== e.length)\n    return !1;\n  for (let r = 0; r < t.length; r++)\n    if (t[r] !== e[r])\n      return !1;\n  return !0;\n}\nfunction qr(t) {\n  if (typeof t != \"string\")\n    throw new Error(`utf8ToBytes expected string, got ${typeof t}`);\n  return new TextEncoder().encode(t);\n}\nfunction Pc(t) {\n  let e;\n  for (e = 0; t > ts; t >>= Lr, e += 1)\n    ;\n  return e;\n}\nconst Bc = (t, e) => t >> BigInt(e) & Lr, Lc = (t, e, r) => t | (r ? Lr : ts) << BigInt(e), Kn = (t) => (Cc << BigInt(t - 1)) - Lr, nn = (t) => new Uint8Array(t), Ni = (t) => Uint8Array.from(t);\nfunction is(t, e, r) {\n  if (typeof t != \"number\" || t < 2)\n    throw new Error(\"hashLen must be a number\");\n  if (typeof e != \"number\" || e < 2)\n    throw new Error(\"qByteLen must be a number\");\n  if (typeof r != \"function\")\n    throw new Error(\"hmacFn must be a function\");\n  let n = nn(t), i = nn(t), s = 0;\n  const o = () => {\n    n.fill(1), i.fill(0), s = 0;\n  }, a = (...u) => r(i, n, ...u), c = (u = nn()) => {\n    i = a(Ni([0]), u), n = a(), u.length !== 0 && (i = a(Ni([1]), u), n = a());\n  }, l = () => {\n    if (s++ >= 1e3)\n      throw new Error(\"drbg: tried 1000 values\");\n    let u = 0;\n    const h = [];\n    for (; u < e; ) {\n      n = a();\n      const d = n.slice();\n      h.push(d), u += n.length;\n    }\n    return he(...h);\n  };\n  return (u, h) => {\n    o(), c(u);\n    let d;\n    for (; !(d = h(l())); )\n      c();\n    return o(), d;\n  };\n}\nconst $c = {\n  bigint: (t) => typeof t == \"bigint\",\n  function: (t) => typeof t == \"function\",\n  boolean: (t) => typeof t == \"boolean\",\n  string: (t) => typeof t == \"string\",\n  isSafeInteger: (t) => Number.isSafeInteger(t),\n  array: (t) => Array.isArray(t),\n  field: (t, e) => e.Fp.isValid(t),\n  hash: (t) => typeof t == \"function\" && Number.isSafeInteger(t.outputLen)\n};\nfunction kt(t, e, r = {}) {\n  const n = (i, s, o) => {\n    const a = $c[s];\n    if (typeof a != \"function\")\n      throw new Error(`Invalid validator \"${s}\", expected function`);\n    const c = t[i];\n    if (!(o && c === void 0) && !a(c, t))\n      throw new Error(`Invalid param ${String(i)}=${c} (${typeof c}), expected ${s}`);\n  };\n  for (const [i, s] of Object.entries(e))\n    n(i, s, !1);\n  for (const [i, s] of Object.entries(r))\n    n(i, s, !0);\n  return t;\n}\nconst qc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  bytesToHex: vt,\n  numberToHexUnpadded: rs,\n  hexToNumber: zn,\n  hexToBytes: wt,\n  bytesToNumberBE: le,\n  bytesToNumberLE: Fn,\n  numberToBytesBE: et,\n  numberToBytesLE: ns,\n  numberToVarBytesBE: Rc,\n  ensureBytes: ee,\n  concatBytes: he,\n  equalBytes: Tc,\n  utf8ToBytes: qr,\n  bitLen: Pc,\n  bitGet: Bc,\n  bitSet: Lc,\n  bitMask: Kn,\n  createHmacDrbg: is,\n  validateObject: kt\n}, Symbol.toStringTag, { value: \"Module\" }));\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst Q = BigInt(0), V = BigInt(1), at = BigInt(2), Nc = BigInt(3), Cn = BigInt(4), Ui = BigInt(5), ji = BigInt(8);\nBigInt(9);\nBigInt(16);\nfunction J(t, e) {\n  const r = t % e;\n  return r >= Q ? r : e + r;\n}\nfunction Uc(t, e, r) {\n  if (r <= Q || e < Q)\n    throw new Error(\"Expected power/modulo > 0\");\n  if (r === V)\n    return Q;\n  let n = V;\n  for (; e > Q; )\n    e & V && (n = n * t % r), t = t * t % r, e >>= V;\n  return n;\n}\nfunction be(t, e, r) {\n  let n = t;\n  for (; e-- > Q; )\n    n *= n, n %= r;\n  return n;\n}\nfunction In(t, e) {\n  if (t === Q || e <= Q)\n    throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);\n  let r = J(t, e), n = e, i = Q, s = V;\n  for (; r !== Q; ) {\n    const a = n / r, c = n % r, l = i - s * a;\n    n = r, r = c, i = s, s = l;\n  }\n  if (n !== V)\n    throw new Error(\"invert: does not exist\");\n  return J(i, e);\n}\nfunction jc(t) {\n  const e = (t - V) / at;\n  let r, n, i;\n  for (r = t - V, n = 0; r % at === Q; r /= at, n++)\n    ;\n  for (i = at; i < t && Uc(i, e, t) !== t - V; i++)\n    ;\n  if (n === 1) {\n    const o = (t + V) / Cn;\n    return function(c, l) {\n      const f = c.pow(l, o);\n      if (!c.eql(c.sqr(f), l))\n        throw new Error(\"Cannot find square root\");\n      return f;\n    };\n  }\n  const s = (r + V) / at;\n  return function(a, c) {\n    if (a.pow(c, e) === a.neg(a.ONE))\n      throw new Error(\"Cannot find square root\");\n    let l = n, f = a.pow(a.mul(a.ONE, i), r), u = a.pow(c, s), h = a.pow(c, r);\n    for (; !a.eql(h, a.ONE); ) {\n      if (a.eql(h, a.ZERO))\n        return a.ZERO;\n      let d = 1;\n      for (let y = a.sqr(h); d < l && !a.eql(y, a.ONE); d++)\n        y = a.sqr(y);\n      const p = a.pow(f, V << BigInt(l - d - 1));\n      f = a.sqr(p), u = a.mul(u, p), h = a.mul(h, f), l = d;\n    }\n    return u;\n  };\n}\nfunction Hc(t) {\n  if (t % Cn === Nc) {\n    const e = (t + V) / Cn;\n    return function(n, i) {\n      const s = n.pow(i, e);\n      if (!n.eql(n.sqr(s), i))\n        throw new Error(\"Cannot find square root\");\n      return s;\n    };\n  }\n  if (t % ji === Ui) {\n    const e = (t - Ui) / ji;\n    return function(n, i) {\n      const s = n.mul(i, at), o = n.pow(s, e), a = n.mul(i, o), c = n.mul(n.mul(a, at), o), l = n.mul(a, n.sub(c, n.ONE));\n      if (!n.eql(n.sqr(l), i))\n        throw new Error(\"Cannot find square root\");\n      return l;\n    };\n  }\n  return jc(t);\n}\nconst Mc = [\n  \"create\",\n  \"isValid\",\n  \"is0\",\n  \"neg\",\n  \"inv\",\n  \"sqrt\",\n  \"sqr\",\n  \"eql\",\n  \"add\",\n  \"sub\",\n  \"mul\",\n  \"pow\",\n  \"div\",\n  \"addN\",\n  \"subN\",\n  \"mulN\",\n  \"sqrN\"\n];\nfunction os(t) {\n  const e = {\n    ORDER: \"bigint\",\n    MASK: \"bigint\",\n    BYTES: \"isSafeInteger\",\n    BITS: \"isSafeInteger\"\n  }, r = Mc.reduce((n, i) => (n[i] = \"function\", n), e);\n  return kt(t, r);\n}\nfunction Dc(t, e, r) {\n  if (r < Q)\n    throw new Error(\"Expected power > 0\");\n  if (r === Q)\n    return t.ONE;\n  if (r === V)\n    return e;\n  let n = t.ONE, i = e;\n  for (; r > Q; )\n    r & V && (n = t.mul(n, i)), i = t.sqr(i), r >>= V;\n  return n;\n}\nfunction zc(t, e) {\n  const r = new Array(e.length), n = e.reduce((s, o, a) => t.is0(o) ? s : (r[a] = s, t.mul(s, o)), t.ONE), i = t.inv(n);\n  return e.reduceRight((s, o, a) => t.is0(o) ? s : (r[a] = t.mul(s, r[a]), t.mul(s, o)), i), r;\n}\nfunction Wn(t, e) {\n  const r = e !== void 0 ? e : t.toString(2).length, n = Math.ceil(r / 8);\n  return { nBitLength: r, nByteLength: n };\n}\nfunction Fc(t, e, r = !1, n = {}) {\n  if (t <= Q)\n    throw new Error(`Expected Fp ORDER > 0, got ${t}`);\n  const { nBitLength: i, nByteLength: s } = Wn(t, e);\n  if (s > 2048)\n    throw new Error(\"Field lengths over 2048 bytes are not supported\");\n  const o = Hc(t), a = Object.freeze({\n    ORDER: t,\n    BITS: i,\n    BYTES: s,\n    MASK: Kn(i),\n    ZERO: Q,\n    ONE: V,\n    create: (c) => J(c, t),\n    isValid: (c) => {\n      if (typeof c != \"bigint\")\n        throw new Error(`Invalid field element: expected bigint, got ${typeof c}`);\n      return Q <= c && c < t;\n    },\n    is0: (c) => c === Q,\n    isOdd: (c) => (c & V) === V,\n    neg: (c) => J(-c, t),\n    eql: (c, l) => c === l,\n    sqr: (c) => J(c * c, t),\n    add: (c, l) => J(c + l, t),\n    sub: (c, l) => J(c - l, t),\n    mul: (c, l) => J(c * l, t),\n    pow: (c, l) => Dc(a, c, l),\n    div: (c, l) => J(c * In(l, t), t),\n    sqrN: (c) => c * c,\n    addN: (c, l) => c + l,\n    subN: (c, l) => c - l,\n    mulN: (c, l) => c * l,\n    inv: (c) => In(c, t),\n    sqrt: n.sqrt || ((c) => o(a, c)),\n    invertBatch: (c) => zc(a, c),\n    cmov: (c, l, f) => f ? l : c,\n    toBytes: (c) => r ? ns(c, s) : et(c, s),\n    fromBytes: (c) => {\n      if (c.length !== s)\n        throw new Error(`Fp.fromBytes: expected ${s}, got ${c.length}`);\n      return r ? Fn(c) : le(c);\n    }\n  });\n  return Object.freeze(a);\n}\nfunction Kc(t, e, r = !1) {\n  t = ee(\"privateHash\", t);\n  const n = t.length, i = Wn(e).nByteLength + 8;\n  if (i < 24 || n < i || n > 1024)\n    throw new Error(`hashToPrivateScalar: expected ${i}-1024 bytes of input, got ${n}`);\n  const s = r ? Fn(t) : le(t);\n  return J(s, e - V) + V;\n}\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst Wc = BigInt(0), on = BigInt(1);\nfunction Vc(t, e) {\n  const r = (i, s) => {\n    const o = s.negate();\n    return i ? o : s;\n  }, n = (i) => {\n    const s = Math.ceil(e / i) + 1, o = 2 ** (i - 1);\n    return { windows: s, windowSize: o };\n  };\n  return {\n    constTimeNegate: r,\n    unsafeLadder(i, s) {\n      let o = t.ZERO, a = i;\n      for (; s > Wc; )\n        s & on && (o = o.add(a)), a = a.double(), s >>= on;\n      return o;\n    },\n    precomputeWindow(i, s) {\n      const { windows: o, windowSize: a } = n(s), c = [];\n      let l = i, f = l;\n      for (let u = 0; u < o; u++) {\n        f = l, c.push(f);\n        for (let h = 1; h < a; h++)\n          f = f.add(l), c.push(f);\n        l = f.double();\n      }\n      return c;\n    },\n    wNAF(i, s, o) {\n      const { windows: a, windowSize: c } = n(i);\n      let l = t.ZERO, f = t.BASE;\n      const u = BigInt(2 ** i - 1), h = 2 ** i, d = BigInt(i);\n      for (let p = 0; p < a; p++) {\n        const y = p * c;\n        let g = Number(o & u);\n        o >>= d, g > c && (g -= h, o += on);\n        const v = y, _ = y + Math.abs(g) - 1, m = p % 2 !== 0, C = g < 0;\n        g === 0 ? f = f.add(r(m, s[v])) : l = l.add(r(C, s[_]));\n      }\n      return { p: l, f };\n    },\n    wNAFCached(i, s, o, a) {\n      const c = i._WINDOW_SIZE || 1;\n      let l = s.get(i);\n      return l || (l = this.precomputeWindow(i, c), c !== 1 && s.set(i, a(l))), this.wNAF(c, l, o);\n    }\n  };\n}\nfunction ss(t) {\n  return os(t.Fp), kt(t, {\n    n: \"bigint\",\n    h: \"bigint\",\n    Gx: \"field\",\n    Gy: \"field\"\n  }, {\n    nBitLength: \"isSafeInteger\",\n    nByteLength: \"isSafeInteger\"\n  }), Object.freeze({\n    ...Wn(t.n, t.nBitLength),\n    ...t,\n    p: t.Fp.ORDER\n  });\n}\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nfunction Gc(t) {\n  const e = ss(t);\n  kt(e, {\n    a: \"field\",\n    b: \"field\"\n  }, {\n    allowedPrivateKeyLengths: \"array\",\n    wrapPrivateKey: \"boolean\",\n    isTorsionFree: \"function\",\n    clearCofactor: \"function\",\n    allowInfinityPoint: \"boolean\",\n    fromBytes: \"function\",\n    toBytes: \"function\"\n  });\n  const { endo: r, Fp: n, a: i } = e;\n  if (r) {\n    if (!n.eql(i, n.ZERO))\n      throw new Error(\"Endomorphism can only be defined for Koblitz curves that have a=0\");\n    if (typeof r != \"object\" || typeof r.beta != \"bigint\" || typeof r.splitScalar != \"function\")\n      throw new Error(\"Expected endomorphism with beta: bigint and splitScalar: function\");\n  }\n  return Object.freeze({ ...e });\n}\nconst { bytesToNumberBE: Zc, hexToBytes: Yc } = qc, lt = {\n  Err: class extends Error {\n    constructor(e = \"\") {\n      super(e);\n    }\n  },\n  _parseInt(t) {\n    const { Err: e } = lt;\n    if (t.length < 2 || t[0] !== 2)\n      throw new e(\"Invalid signature integer tag\");\n    const r = t[1], n = t.subarray(2, r + 2);\n    if (!r || n.length !== r)\n      throw new e(\"Invalid signature integer: wrong length\");\n    if (n[0] & 128)\n      throw new e(\"Invalid signature integer: negative\");\n    if (n[0] === 0 && !(n[1] & 128))\n      throw new e(\"Invalid signature integer: unnecessary leading zero\");\n    return { d: Zc(n), l: t.subarray(r + 2) };\n  },\n  toSig(t) {\n    const { Err: e } = lt, r = typeof t == \"string\" ? Yc(t) : t;\n    if (!(r instanceof Uint8Array))\n      throw new Error(\"ui8a expected\");\n    let n = r.length;\n    if (n < 2 || r[0] != 48)\n      throw new e(\"Invalid signature tag\");\n    if (r[1] !== n - 2)\n      throw new e(\"Invalid signature: incorrect length\");\n    const { d: i, l: s } = lt._parseInt(r.subarray(2)), { d: o, l: a } = lt._parseInt(s);\n    if (a.length)\n      throw new e(\"Invalid signature: left bytes after parsing\");\n    return { r: i, s: o };\n  },\n  hexFromSig(t) {\n    const e = (l) => Number.parseInt(l[0], 16) & 8 ? \"00\" + l : l, r = (l) => {\n      const f = l.toString(16);\n      return f.length & 1 ? `0${f}` : f;\n    }, n = e(r(t.s)), i = e(r(t.r)), s = n.length / 2, o = i.length / 2, a = r(s), c = r(o);\n    return `30${r(o + s + 4)}02${c}${i}02${a}${n}`;\n  }\n}, ke = BigInt(0), Y = BigInt(1), $e = BigInt(2), Ar = BigInt(3), Hi = BigInt(4);\nfunction Jc(t) {\n  const e = Gc(t), { Fp: r } = e, n = e.toBytes || ((p, y, g) => {\n    const v = y.toAffine();\n    return he(Uint8Array.from([4]), r.toBytes(v.x), r.toBytes(v.y));\n  }), i = e.fromBytes || ((p) => {\n    const y = p.subarray(1), g = r.fromBytes(y.subarray(0, r.BYTES)), v = r.fromBytes(y.subarray(r.BYTES, 2 * r.BYTES));\n    return { x: g, y: v };\n  });\n  function s(p) {\n    const { a: y, b: g } = e, v = r.sqr(p), _ = r.mul(v, p);\n    return r.add(r.add(_, r.mul(p, y)), g);\n  }\n  if (!r.eql(r.sqr(e.Gy), s(e.Gx)))\n    throw new Error(\"bad generator point: equation left != right\");\n  function o(p) {\n    return typeof p == \"bigint\" && ke < p && p < e.n;\n  }\n  function a(p) {\n    if (!o(p))\n      throw new Error(\"Expected valid bigint: 0 < bigint < curve.n\");\n  }\n  function c(p) {\n    const { allowedPrivateKeyLengths: y, nByteLength: g, wrapPrivateKey: v, n: _ } = e;\n    if (y && typeof p != \"bigint\") {\n      if (p instanceof Uint8Array && (p = vt(p)), typeof p != \"string\" || !y.includes(p.length))\n        throw new Error(\"Invalid key\");\n      p = p.padStart(g * 2, \"0\");\n    }\n    let m;\n    try {\n      m = typeof p == \"bigint\" ? p : le(ee(\"private key\", p, g));\n    } catch {\n      throw new Error(`private key must be ${g} bytes, hex or bigint, not ${typeof p}`);\n    }\n    return v && (m = J(m, _)), a(m), m;\n  }\n  const l = /* @__PURE__ */ new Map();\n  function f(p) {\n    if (!(p instanceof u))\n      throw new Error(\"ProjectivePoint expected\");\n  }\n  class u {\n    constructor(y, g, v) {\n      if (this.px = y, this.py = g, this.pz = v, y == null || !r.isValid(y))\n        throw new Error(\"x required\");\n      if (g == null || !r.isValid(g))\n        throw new Error(\"y required\");\n      if (v == null || !r.isValid(v))\n        throw new Error(\"z required\");\n    }\n    static fromAffine(y) {\n      const { x: g, y: v } = y || {};\n      if (!y || !r.isValid(g) || !r.isValid(v))\n        throw new Error(\"invalid affine point\");\n      if (y instanceof u)\n        throw new Error(\"projective point not allowed\");\n      const _ = (m) => r.eql(m, r.ZERO);\n      return _(g) && _(v) ? u.ZERO : new u(g, v, r.ONE);\n    }\n    get x() {\n      return this.toAffine().x;\n    }\n    get y() {\n      return this.toAffine().y;\n    }\n    static normalizeZ(y) {\n      const g = r.invertBatch(y.map((v) => v.pz));\n      return y.map((v, _) => v.toAffine(g[_])).map(u.fromAffine);\n    }\n    static fromHex(y) {\n      const g = u.fromAffine(i(ee(\"pointHex\", y)));\n      return g.assertValidity(), g;\n    }\n    static fromPrivateKey(y) {\n      return u.BASE.multiply(c(y));\n    }\n    _setWindowSize(y) {\n      this._WINDOW_SIZE = y, l.delete(this);\n    }\n    assertValidity() {\n      if (this.is0()) {\n        if (e.allowInfinityPoint)\n          return;\n        throw new Error(\"bad point: ZERO\");\n      }\n      const { x: y, y: g } = this.toAffine();\n      if (!r.isValid(y) || !r.isValid(g))\n        throw new Error(\"bad point: x or y not FE\");\n      const v = r.sqr(g), _ = s(y);\n      if (!r.eql(v, _))\n        throw new Error(\"bad point: equation left != right\");\n      if (!this.isTorsionFree())\n        throw new Error(\"bad point: not in prime-order subgroup\");\n    }\n    hasEvenY() {\n      const { y } = this.toAffine();\n      if (r.isOdd)\n        return !r.isOdd(y);\n      throw new Error(\"Field doesn't support isOdd\");\n    }\n    equals(y) {\n      f(y);\n      const { px: g, py: v, pz: _ } = this, { px: m, py: C, pz: O } = y, w = r.eql(r.mul(g, O), r.mul(m, _)), x = r.eql(r.mul(v, O), r.mul(C, _));\n      return w && x;\n    }\n    negate() {\n      return new u(this.px, r.neg(this.py), this.pz);\n    }\n    double() {\n      const { a: y, b: g } = e, v = r.mul(g, Ar), { px: _, py: m, pz: C } = this;\n      let O = r.ZERO, w = r.ZERO, x = r.ZERO, A = r.mul(_, _), B = r.mul(m, m), L = r.mul(C, C), P = r.mul(_, m);\n      return P = r.add(P, P), x = r.mul(_, C), x = r.add(x, x), O = r.mul(y, x), w = r.mul(v, L), w = r.add(O, w), O = r.sub(B, w), w = r.add(B, w), w = r.mul(O, w), O = r.mul(P, O), x = r.mul(v, x), L = r.mul(y, L), P = r.sub(A, L), P = r.mul(y, P), P = r.add(P, x), x = r.add(A, A), A = r.add(x, A), A = r.add(A, L), A = r.mul(A, P), w = r.add(w, A), L = r.mul(m, C), L = r.add(L, L), A = r.mul(L, P), O = r.sub(O, A), x = r.mul(L, B), x = r.add(x, x), x = r.add(x, x), new u(O, w, x);\n    }\n    add(y) {\n      f(y);\n      const { px: g, py: v, pz: _ } = this, { px: m, py: C, pz: O } = y;\n      let w = r.ZERO, x = r.ZERO, A = r.ZERO;\n      const B = e.a, L = r.mul(e.b, Ar);\n      let P = r.mul(g, m), F = r.mul(v, C), z = r.mul(_, O), G = r.add(g, v), E = r.add(m, C);\n      G = r.mul(G, E), E = r.add(P, F), G = r.sub(G, E), E = r.add(g, _);\n      let R = r.add(m, O);\n      return E = r.mul(E, R), R = r.add(P, z), E = r.sub(E, R), R = r.add(v, _), w = r.add(C, O), R = r.mul(R, w), w = r.add(F, z), R = r.sub(R, w), A = r.mul(B, E), w = r.mul(L, z), A = r.add(w, A), w = r.sub(F, A), A = r.add(F, A), x = r.mul(w, A), F = r.add(P, P), F = r.add(F, P), z = r.mul(B, z), E = r.mul(L, E), F = r.add(F, z), z = r.sub(P, z), z = r.mul(B, z), E = r.add(E, z), P = r.mul(F, E), x = r.add(x, P), P = r.mul(R, E), w = r.mul(G, w), w = r.sub(w, P), P = r.mul(G, F), A = r.mul(R, A), A = r.add(A, P), new u(w, x, A);\n    }\n    subtract(y) {\n      return this.add(y.negate());\n    }\n    is0() {\n      return this.equals(u.ZERO);\n    }\n    wNAF(y) {\n      return d.wNAFCached(this, l, y, (g) => {\n        const v = r.invertBatch(g.map((_) => _.pz));\n        return g.map((_, m) => _.toAffine(v[m])).map(u.fromAffine);\n      });\n    }\n    multiplyUnsafe(y) {\n      const g = u.ZERO;\n      if (y === ke)\n        return g;\n      if (a(y), y === Y)\n        return this;\n      const { endo: v } = e;\n      if (!v)\n        return d.unsafeLadder(this, y);\n      let { k1neg: _, k1: m, k2neg: C, k2: O } = v.splitScalar(y), w = g, x = g, A = this;\n      for (; m > ke || O > ke; )\n        m & Y && (w = w.add(A)), O & Y && (x = x.add(A)), A = A.double(), m >>= Y, O >>= Y;\n      return _ && (w = w.negate()), C && (x = x.negate()), x = new u(r.mul(x.px, v.beta), x.py, x.pz), w.add(x);\n    }\n    multiply(y) {\n      a(y);\n      let g = y, v, _;\n      const { endo: m } = e;\n      if (m) {\n        const { k1neg: C, k1: O, k2neg: w, k2: x } = m.splitScalar(g);\n        let { p: A, f: B } = this.wNAF(O), { p: L, f: P } = this.wNAF(x);\n        A = d.constTimeNegate(C, A), L = d.constTimeNegate(w, L), L = new u(r.mul(L.px, m.beta), L.py, L.pz), v = A.add(L), _ = B.add(P);\n      } else {\n        const { p: C, f: O } = this.wNAF(g);\n        v = C, _ = O;\n      }\n      return u.normalizeZ([v, _])[0];\n    }\n    multiplyAndAddUnsafe(y, g, v) {\n      const _ = u.BASE, m = (O, w) => w === ke || w === Y || !O.equals(_) ? O.multiplyUnsafe(w) : O.multiply(w), C = m(this, g).add(m(y, v));\n      return C.is0() ? void 0 : C;\n    }\n    toAffine(y) {\n      const { px: g, py: v, pz: _ } = this, m = this.is0();\n      y == null && (y = m ? r.ONE : r.inv(_));\n      const C = r.mul(g, y), O = r.mul(v, y), w = r.mul(_, y);\n      if (m)\n        return { x: r.ZERO, y: r.ZERO };\n      if (!r.eql(w, r.ONE))\n        throw new Error(\"invZ was invalid\");\n      return { x: C, y: O };\n    }\n    isTorsionFree() {\n      const { h: y, isTorsionFree: g } = e;\n      if (y === Y)\n        return !0;\n      if (g)\n        return g(u, this);\n      throw new Error(\"isTorsionFree() has not been declared for the elliptic curve\");\n    }\n    clearCofactor() {\n      const { h: y, clearCofactor: g } = e;\n      return y === Y ? this : g ? g(u, this) : this.multiplyUnsafe(e.h);\n    }\n    toRawBytes(y = !0) {\n      return this.assertValidity(), n(u, this, y);\n    }\n    toHex(y = !0) {\n      return vt(this.toRawBytes(y));\n    }\n  }\n  u.BASE = new u(e.Gx, e.Gy, r.ONE), u.ZERO = new u(r.ZERO, r.ONE, r.ZERO);\n  const h = e.nBitLength, d = Vc(u, e.endo ? Math.ceil(h / 2) : h);\n  return {\n    CURVE: e,\n    ProjectivePoint: u,\n    normPrivateKeyToScalar: c,\n    weierstrassEquation: s,\n    isWithinCurveOrder: o\n  };\n}\nfunction Xc(t) {\n  const e = ss(t);\n  return kt(e, {\n    hash: \"hash\",\n    hmac: \"function\",\n    randomBytes: \"function\"\n  }, {\n    bits2int: \"function\",\n    bits2int_modN: \"function\",\n    lowS: \"boolean\"\n  }), Object.freeze({ lowS: !0, ...e });\n}\nfunction Qc(t) {\n  const e = Xc(t), { Fp: r, n } = e, i = r.BYTES + 1, s = 2 * r.BYTES + 1;\n  function o(E) {\n    return ke < E && E < r.ORDER;\n  }\n  function a(E) {\n    return J(E, n);\n  }\n  function c(E) {\n    return In(E, n);\n  }\n  const { ProjectivePoint: l, normPrivateKeyToScalar: f, weierstrassEquation: u, isWithinCurveOrder: h } = Jc({\n    ...e,\n    toBytes(E, R, q) {\n      const H = R.toAffine(), D = r.toBytes(H.x), X = he;\n      return q ? X(Uint8Array.from([R.hasEvenY() ? 2 : 3]), D) : X(Uint8Array.from([4]), D, r.toBytes(H.y));\n    },\n    fromBytes(E) {\n      const R = E.length, q = E[0], H = E.subarray(1);\n      if (R === i && (q === 2 || q === 3)) {\n        const D = le(H);\n        if (!o(D))\n          throw new Error(\"Point is not on curve\");\n        const X = u(D);\n        let oe = r.sqrt(X);\n        const re = (oe & Y) === Y;\n        return (q & 1) === 1 !== re && (oe = r.neg(oe)), { x: D, y: oe };\n      } else if (R === s && q === 4) {\n        const D = r.fromBytes(H.subarray(0, r.BYTES)), X = r.fromBytes(H.subarray(r.BYTES, 2 * r.BYTES));\n        return { x: D, y: X };\n      } else\n        throw new Error(`Point of length ${R} was invalid. Expected ${i} compressed bytes or ${s} uncompressed bytes`);\n    }\n  }), d = (E) => vt(et(E, e.nByteLength));\n  function p(E) {\n    const R = n >> Y;\n    return E > R;\n  }\n  function y(E) {\n    return p(E) ? a(-E) : E;\n  }\n  const g = (E, R, q) => le(E.slice(R, q));\n  class v {\n    constructor(R, q, H) {\n      this.r = R, this.s = q, this.recovery = H, this.assertValidity();\n    }\n    static fromCompact(R) {\n      const q = e.nByteLength;\n      return R = ee(\"compactSignature\", R, q * 2), new v(g(R, 0, q), g(R, q, 2 * q));\n    }\n    static fromDER(R) {\n      const { r: q, s: H } = lt.toSig(ee(\"DER\", R));\n      return new v(q, H);\n    }\n    assertValidity() {\n      if (!h(this.r))\n        throw new Error(\"r must be 0 < r < CURVE.n\");\n      if (!h(this.s))\n        throw new Error(\"s must be 0 < s < CURVE.n\");\n    }\n    addRecoveryBit(R) {\n      return new v(this.r, this.s, R);\n    }\n    recoverPublicKey(R) {\n      const { r: q, s: H, recovery: D } = this, X = x(ee(\"msgHash\", R));\n      if (D == null || ![0, 1, 2, 3].includes(D))\n        throw new Error(\"recovery id invalid\");\n      const oe = D === 2 || D === 3 ? q + e.n : q;\n      if (oe >= r.ORDER)\n        throw new Error(\"recovery id 2 or 3 invalid\");\n      const re = (D & 1) === 0 ? \"02\" : \"03\", _e = l.fromHex(re + d(oe)), Oe = c(oe), Ue = a(-X * Oe), Pe = a(H * Oe), ye = l.BASE.multiplyAndAddUnsafe(_e, Ue, Pe);\n      if (!ye)\n        throw new Error(\"point at infinify\");\n      return ye.assertValidity(), ye;\n    }\n    hasHighS() {\n      return p(this.s);\n    }\n    normalizeS() {\n      return this.hasHighS() ? new v(this.r, a(-this.s), this.recovery) : this;\n    }\n    toDERRawBytes() {\n      return wt(this.toDERHex());\n    }\n    toDERHex() {\n      return lt.hexFromSig({ r: this.r, s: this.s });\n    }\n    toCompactRawBytes() {\n      return wt(this.toCompactHex());\n    }\n    toCompactHex() {\n      return d(this.r) + d(this.s);\n    }\n  }\n  const _ = {\n    isValidPrivateKey(E) {\n      try {\n        return f(E), !0;\n      } catch {\n        return !1;\n      }\n    },\n    normPrivateKeyToScalar: f,\n    randomPrivateKey: () => {\n      const E = e.randomBytes(r.BYTES + 8), R = Kc(E, n);\n      return et(R, e.nByteLength);\n    },\n    precompute(E = 8, R = l.BASE) {\n      return R._setWindowSize(E), R.multiply(BigInt(3)), R;\n    }\n  };\n  function m(E, R = !0) {\n    return l.fromPrivateKey(E).toRawBytes(R);\n  }\n  function C(E) {\n    const R = E instanceof Uint8Array, q = typeof E == \"string\", H = (R || q) && E.length;\n    return R ? H === i || H === s : q ? H === 2 * i || H === 2 * s : E instanceof l;\n  }\n  function O(E, R, q = !0) {\n    if (C(E))\n      throw new Error(\"first arg must be private key\");\n    if (!C(R))\n      throw new Error(\"second arg must be public key\");\n    return l.fromHex(R).multiply(f(E)).toRawBytes(q);\n  }\n  const w = e.bits2int || function(E) {\n    const R = le(E), q = E.length * 8 - e.nBitLength;\n    return q > 0 ? R >> BigInt(q) : R;\n  }, x = e.bits2int_modN || function(E) {\n    return a(w(E));\n  }, A = Kn(e.nBitLength);\n  function B(E) {\n    if (typeof E != \"bigint\")\n      throw new Error(\"bigint expected\");\n    if (!(ke <= E && E < A))\n      throw new Error(`bigint expected < 2^${e.nBitLength}`);\n    return et(E, e.nByteLength);\n  }\n  function L(E, R, q = P) {\n    if ([\"recovered\", \"canonical\"].some((me) => me in q))\n      throw new Error(\"sign() legacy options not supported\");\n    const { hash: H, randomBytes: D } = e;\n    let { lowS: X, prehash: oe, extraEntropy: re } = q;\n    X == null && (X = !0), E = ee(\"msgHash\", E), oe && (E = ee(\"prehashed msgHash\", H(E)));\n    const _e = x(E), Oe = f(R), Ue = [B(Oe), B(_e)];\n    if (re != null) {\n      const me = re === !0 ? D(r.BYTES) : re;\n      Ue.push(ee(\"extraEntropy\", me, r.BYTES));\n    }\n    const Pe = he(...Ue), ye = _e;\n    function je(me) {\n      const xe = w(me);\n      if (!h(xe))\n        return;\n      const lr = c(xe), Be = l.BASE.multiply(xe).toAffine(), fe = a(Be.x);\n      if (fe === ke)\n        return;\n      const He = a(lr * a(ye + fe * Oe));\n      if (He === ke)\n        return;\n      let it = (Be.x === fe ? 0 : 2) | Number(Be.y & Y), ot = He;\n      return X && p(He) && (ot = y(He), it ^= 1), new v(fe, ot, it);\n    }\n    return { seed: Pe, k2sig: je };\n  }\n  const P = { lowS: e.lowS, prehash: !1 }, F = { lowS: e.lowS, prehash: !1 };\n  function z(E, R, q = P) {\n    const { seed: H, k2sig: D } = L(E, R, q);\n    return is(e.hash.outputLen, e.nByteLength, e.hmac)(H, D);\n  }\n  l.BASE._setWindowSize(8);\n  function G(E, R, q, H = F) {\n    var Be;\n    const D = E;\n    if (R = ee(\"msgHash\", R), q = ee(\"publicKey\", q), \"strict\" in H)\n      throw new Error(\"options.strict was renamed to lowS\");\n    const { lowS: X, prehash: oe } = H;\n    let re, _e;\n    try {\n      if (typeof D == \"string\" || D instanceof Uint8Array)\n        try {\n          re = v.fromDER(D);\n        } catch (fe) {\n          if (!(fe instanceof lt.Err))\n            throw fe;\n          re = v.fromCompact(D);\n        }\n      else if (typeof D == \"object\" && typeof D.r == \"bigint\" && typeof D.s == \"bigint\") {\n        const { r: fe, s: He } = D;\n        re = new v(fe, He);\n      } else\n        throw new Error(\"PARSE\");\n      _e = l.fromHex(q);\n    } catch (fe) {\n      if (fe.message === \"PARSE\")\n        throw new Error(\"signature must be Signature instance, Uint8Array or hex string\");\n      return !1;\n    }\n    if (X && re.hasHighS())\n      return !1;\n    oe && (R = e.hash(R));\n    const { r: Oe, s: Ue } = re, Pe = x(R), ye = c(Ue), je = a(Pe * ye), me = a(Oe * ye), xe = (Be = l.BASE.multiplyAndAddUnsafe(_e, je, me)) == null ? void 0 : Be.toAffine();\n    return xe ? a(xe.x) === Oe : !1;\n  }\n  return {\n    CURVE: e,\n    getPublicKey: m,\n    getSharedSecret: O,\n    sign: z,\n    verify: G,\n    ProjectivePoint: l,\n    Signature: v,\n    utils: _\n  };\n}\nfunction eu(t, e) {\n  const r = t.ORDER;\n  let n = ke;\n  for (let h = r - Y; h % $e === ke; h /= $e)\n    n += Y;\n  const i = n, s = (r - Y) / $e ** i, o = (s - Y) / $e, a = $e ** i - Y, c = $e ** (i - Y), l = t.pow(e, s), f = t.pow(e, (s + Y) / $e);\n  let u = (h, d) => {\n    let p = l, y = t.pow(d, a), g = t.sqr(y);\n    g = t.mul(g, d);\n    let v = t.mul(h, g);\n    v = t.pow(v, o), v = t.mul(v, y), y = t.mul(v, d), g = t.mul(v, h);\n    let _ = t.mul(g, y);\n    v = t.pow(_, c);\n    let m = t.eql(v, t.ONE);\n    y = t.mul(g, f), v = t.mul(_, p), g = t.cmov(y, g, m), _ = t.cmov(v, _, m);\n    for (let C = i; C > Y; C--) {\n      let O = $e ** (C - $e), w = t.pow(_, O);\n      const x = t.eql(w, t.ONE);\n      y = t.mul(g, p), p = t.mul(p, p), w = t.mul(_, p), g = t.cmov(y, g, x), _ = t.cmov(w, _, x);\n    }\n    return { isValid: m, value: g };\n  };\n  if (t.ORDER % Hi === Ar) {\n    const h = (t.ORDER - Ar) / Hi, d = t.sqrt(t.neg(e));\n    u = (p, y) => {\n      let g = t.sqr(y);\n      const v = t.mul(p, y);\n      g = t.mul(g, v);\n      let _ = t.pow(g, h);\n      _ = t.mul(_, v);\n      const m = t.mul(_, d), C = t.mul(t.sqr(_), y), O = t.eql(C, p);\n      let w = t.cmov(m, _, O);\n      return { isValid: O, value: w };\n    };\n  }\n  return u;\n}\nfunction tu(t, e) {\n  if (os(t), !t.isValid(e.A) || !t.isValid(e.B) || !t.isValid(e.Z))\n    throw new Error(\"mapToCurveSimpleSWU: invalid opts\");\n  const r = eu(t, e.Z);\n  if (!t.isOdd)\n    throw new Error(\"Fp.isOdd is not implemented!\");\n  return (n) => {\n    let i, s, o, a, c, l, f, u;\n    i = t.sqr(n), i = t.mul(i, e.Z), s = t.sqr(i), s = t.add(s, i), o = t.add(s, t.ONE), o = t.mul(o, e.B), a = t.cmov(e.Z, t.neg(s), !t.eql(s, t.ZERO)), a = t.mul(a, e.A), s = t.sqr(o), l = t.sqr(a), c = t.mul(l, e.A), s = t.add(s, c), s = t.mul(s, o), l = t.mul(l, a), c = t.mul(l, e.B), s = t.add(s, c), f = t.mul(i, o);\n    const { isValid: h, value: d } = r(s, l);\n    u = t.mul(i, n), u = t.mul(u, d), f = t.cmov(f, o, h), u = t.cmov(u, d, h);\n    const p = t.isOdd(n) === t.isOdd(u);\n    return u = t.cmov(t.neg(u), u, p), f = t.div(f, a), { x: f, y: u };\n  };\n}\nfunction ru(t) {\n  if (t instanceof Uint8Array)\n    return t;\n  if (typeof t == \"string\")\n    return qr(t);\n  throw new Error(\"DST must be Uint8Array or string\");\n}\nconst nu = le;\nfunction Ze(t, e) {\n  if (t < 0 || t >= 1 << 8 * e)\n    throw new Error(`bad I2OSP call: value=${t} length=${e}`);\n  const r = Array.from({ length: e }).fill(0);\n  for (let n = e - 1; n >= 0; n--)\n    r[n] = t & 255, t >>>= 8;\n  return new Uint8Array(r);\n}\nfunction iu(t, e) {\n  const r = new Uint8Array(t.length);\n  for (let n = 0; n < t.length; n++)\n    r[n] = t[n] ^ e[n];\n  return r;\n}\nfunction tr(t) {\n  if (!(t instanceof Uint8Array))\n    throw new Error(\"Uint8Array expected\");\n}\nfunction Vn(t) {\n  if (!Number.isSafeInteger(t))\n    throw new Error(\"number expected\");\n}\nfunction ou(t, e, r, n) {\n  tr(t), tr(e), Vn(r), e.length > 255 && (e = n(he(qr(\"H2C-OVERSIZE-DST-\"), e)));\n  const { outputLen: i, blockLen: s } = n, o = Math.ceil(r / i);\n  if (o > 255)\n    throw new Error(\"Invalid xmd length\");\n  const a = he(e, Ze(e.length, 1)), c = Ze(0, s), l = Ze(r, 2), f = new Array(o), u = n(he(c, t, l, Ze(0, 1), a));\n  f[0] = n(he(u, Ze(1, 1), a));\n  for (let d = 1; d <= o; d++) {\n    const p = [iu(u, f[d - 1]), Ze(d + 1, 1), a];\n    f[d] = n(he(...p));\n  }\n  return he(...f).slice(0, r);\n}\nfunction su(t, e, r, n, i) {\n  if (tr(t), tr(e), Vn(r), e.length > 255) {\n    const s = Math.ceil(2 * n / 8);\n    e = i.create({ dkLen: s }).update(qr(\"H2C-OVERSIZE-DST-\")).update(e).digest();\n  }\n  if (r > 65535 || e.length > 255)\n    throw new Error(\"expand_message_xof: invalid lenInBytes\");\n  return i.create({ dkLen: r }).update(t).update(Ze(r, 2)).update(e).update(Ze(e.length, 1)).digest();\n}\nfunction Mi(t, e, r) {\n  kt(r, {\n    DST: \"string\",\n    p: \"bigint\",\n    m: \"isSafeInteger\",\n    k: \"isSafeInteger\",\n    hash: \"hash\"\n  });\n  const { p: n, k: i, m: s, hash: o, expand: a, DST: c } = r;\n  tr(t), Vn(e);\n  const l = ru(c), f = n.toString(2).length, u = Math.ceil((f + i) / 8), h = e * s * u;\n  let d;\n  if (a === \"xmd\")\n    d = ou(t, l, h, o);\n  else if (a === \"xof\")\n    d = su(t, l, h, i, o);\n  else if (a === \"_internal_pass\")\n    d = t;\n  else\n    throw new Error('expand must be \"xmd\" or \"xof\"');\n  const p = new Array(e);\n  for (let y = 0; y < e; y++) {\n    const g = new Array(s);\n    for (let v = 0; v < s; v++) {\n      const _ = u * (v + y * s), m = d.subarray(_, _ + u);\n      g[v] = J(nu(m), n);\n    }\n    p[y] = g;\n  }\n  return p;\n}\nfunction au(t, e) {\n  const r = e.map((n) => Array.from(n).reverse());\n  return (n, i) => {\n    const [s, o, a, c] = r.map((l) => l.reduce((f, u) => t.add(t.mul(f, n), u)));\n    return n = t.div(s, o), i = t.mul(i, t.div(a, c)), { x: n, y: i };\n  };\n}\nfunction cu(t, e, r) {\n  if (typeof e != \"function\")\n    throw new Error(\"mapToCurve() must be defined\");\n  return {\n    hashToCurve(n, i) {\n      const s = Mi(n, 2, { ...r, DST: r.DST, ...i }), o = t.fromAffine(e(s[0])), a = t.fromAffine(e(s[1])), c = o.add(a).clearCofactor();\n      return c.assertValidity(), c;\n    },\n    encodeToCurve(n, i) {\n      const s = Mi(n, 1, { ...r, DST: r.encodeDST, ...i }), o = t.fromAffine(e(s[0])).clearCofactor();\n      return o.assertValidity(), o;\n    }\n  };\n}\nclass as extends Jo {\n  constructor(e, r) {\n    super(), this.finished = !1, this.destroyed = !1, ut.hash(e);\n    const n = Dn(r);\n    if (this.iHash = e.create(), typeof this.iHash.update != \"function\")\n      throw new TypeError(\"Expected instance of class which extends utils.Hash\");\n    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;\n    const i = this.blockLen, s = new Uint8Array(i);\n    s.set(n.length > i ? e.create().update(n).digest() : n);\n    for (let o = 0; o < s.length; o++)\n      s[o] ^= 54;\n    this.iHash.update(s), this.oHash = e.create();\n    for (let o = 0; o < s.length; o++)\n      s[o] ^= 106;\n    this.oHash.update(s), s.fill(0);\n  }\n  update(e) {\n    return ut.exists(this), this.iHash.update(e), this;\n  }\n  digestInto(e) {\n    ut.exists(this), ut.bytes(e, this.outputLen), this.finished = !0, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy();\n  }\n  digest() {\n    const e = new Uint8Array(this.oHash.outputLen);\n    return this.digestInto(e), e;\n  }\n  _cloneInto(e) {\n    e || (e = Object.create(Object.getPrototypeOf(this), {}));\n    const { oHash: r, iHash: n, finished: i, destroyed: s, blockLen: o, outputLen: a } = this;\n    return e = e, e.finished = i, e.destroyed = s, e.blockLen = o, e.outputLen = a, e.oHash = r._cloneInto(e.oHash), e.iHash = n._cloneInto(e.iHash), e;\n  }\n  destroy() {\n    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();\n  }\n}\nconst cs = (t, e, r) => new as(t, e).update(r).digest();\ncs.create = (t, e) => new as(t, e);\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nfunction uu(t) {\n  return {\n    hash: t,\n    hmac: (e, ...r) => cs(t, e, mc(...r)),\n    randomBytes: Qo\n  };\n}\nfunction lu(t, e) {\n  const r = (n) => Qc({ ...t, ...uu(n) });\n  return Object.freeze({ ...r(e), create: r });\n}\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst Nr = BigInt(\"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f\"), Cr = BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\"), us = BigInt(1), Ir = BigInt(2), Di = (t, e) => (t + e / Ir) / e;\nfunction ls(t) {\n  const e = Nr, r = BigInt(3), n = BigInt(6), i = BigInt(11), s = BigInt(22), o = BigInt(23), a = BigInt(44), c = BigInt(88), l = t * t * t % e, f = l * l * t % e, u = be(f, r, e) * f % e, h = be(u, r, e) * f % e, d = be(h, Ir, e) * l % e, p = be(d, i, e) * d % e, y = be(p, s, e) * p % e, g = be(y, a, e) * y % e, v = be(g, c, e) * g % e, _ = be(v, a, e) * y % e, m = be(_, r, e) * f % e, C = be(m, o, e) * p % e, O = be(C, n, e) * l % e, w = be(O, Ir, e);\n  if (!tt.eql(tt.sqr(w), t))\n    throw new Error(\"Cannot find square root\");\n  return w;\n}\nconst tt = Fc(Nr, void 0, void 0, { sqrt: ls }), ue = lu({\n  a: BigInt(0),\n  b: BigInt(7),\n  Fp: tt,\n  n: Cr,\n  Gx: BigInt(\"55066263022277343669578718895168534326250603453777594175500187360389116729240\"),\n  Gy: BigInt(\"32670510020758816978083085130507043184471273380659243275938904335757337482424\"),\n  h: BigInt(1),\n  lowS: !0,\n  endo: {\n    beta: BigInt(\"0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\"),\n    splitScalar: (t) => {\n      const e = Cr, r = BigInt(\"0x3086d221a7d46bcde86c90e49284eb15\"), n = -us * BigInt(\"0xe4437ed6010e88286f547fa90abfe4c3\"), i = BigInt(\"0x114ca50f7a8e2f3f657c1108d9d44cfd8\"), s = r, o = BigInt(\"0x100000000000000000000000000000000\"), a = Di(s * t, e), c = Di(-n * t, e);\n      let l = J(t - a * r - c * i, e), f = J(-a * n - c * s, e);\n      const u = l > o, h = f > o;\n      if (u && (l = e - l), h && (f = e - f), l > o || f > o)\n        throw new Error(\"splitScalar: Endomorphism failed, k=\" + t);\n      return { k1neg: u, k1: l, k2neg: h, k2: f };\n    }\n  }\n}, Or), Ur = BigInt(0), fs = (t) => typeof t == \"bigint\" && Ur < t && t < Nr, fu = (t) => typeof t == \"bigint\" && Ur < t && t < Cr, zi = {};\nfunction Rr(t, ...e) {\n  let r = zi[t];\n  if (r === void 0) {\n    const n = Or(Uint8Array.from(t, (i) => i.charCodeAt(0)));\n    r = he(n, n), zi[t] = r;\n  }\n  return Or(he(r, ...e));\n}\nconst Gn = (t) => t.toRawBytes(!0).slice(1), Rn = (t) => et(t, 32), sn = (t) => J(t, Nr), rr = (t) => J(t, Cr), Zn = ue.ProjectivePoint, hu = (t, e, r) => Zn.BASE.multiplyAndAddUnsafe(t, e, r);\nfunction Tn(t) {\n  let e = ue.utils.normPrivateKeyToScalar(t), r = Zn.fromPrivateKey(e);\n  return { scalar: r.hasEvenY() ? e : rr(-e), bytes: Gn(r) };\n}\nfunction hs(t) {\n  if (!fs(t))\n    throw new Error(\"bad x: need 0 < x < p\");\n  const e = sn(t * t), r = sn(e * t + BigInt(7));\n  let n = ls(r);\n  n % Ir !== Ur && (n = sn(-n));\n  const i = new Zn(t, n, us);\n  return i.assertValidity(), i;\n}\nfunction ds(...t) {\n  return rr(le(Rr(\"BIP0340/challenge\", ...t)));\n}\nfunction du(t) {\n  return Tn(t).bytes;\n}\nfunction pu(t, e, r = Qo(32)) {\n  const n = ee(\"message\", t), { bytes: i, scalar: s } = Tn(e), o = ee(\"auxRand\", r, 32), a = Rn(s ^ le(Rr(\"BIP0340/aux\", o))), c = Rr(\"BIP0340/nonce\", a, i, n), l = rr(le(c));\n  if (l === Ur)\n    throw new Error(\"sign failed: k is zero\");\n  const { bytes: f, scalar: u } = Tn(l), h = ds(f, i, n), d = new Uint8Array(64);\n  if (d.set(f, 0), d.set(Rn(rr(u + h * s)), 32), !ps(d, n, i))\n    throw new Error(\"sign: Invalid signature produced\");\n  return d;\n}\nfunction ps(t, e, r) {\n  const n = ee(\"signature\", t, 64), i = ee(\"message\", e), s = ee(\"publicKey\", r, 32);\n  try {\n    const o = hs(le(s)), a = le(n.subarray(0, 32));\n    if (!fs(a))\n      return !1;\n    const c = le(n.subarray(32, 64));\n    if (!fu(c))\n      return !1;\n    const l = ds(Rn(a), Gn(o), i), f = hu(o, c, rr(-l));\n    return !(!f || !f.hasEvenY() || f.toAffine().x !== a);\n  } catch {\n    return !1;\n  }\n}\nconst St = {\n  getPublicKey: du,\n  sign: pu,\n  verify: ps,\n  utils: {\n    randomPrivateKey: ue.utils.randomPrivateKey,\n    lift_x: hs,\n    pointToBytes: Gn,\n    numberToBytesBE: et,\n    bytesToNumberBE: le,\n    taggedHash: Rr,\n    mod: J\n  }\n}, yu = au(tt, [\n  [\n    \"0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7\",\n    \"0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581\",\n    \"0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262\",\n    \"0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c\"\n  ],\n  [\n    \"0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b\",\n    \"0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14\",\n    \"0x0000000000000000000000000000000000000000000000000000000000000001\"\n  ],\n  [\n    \"0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c\",\n    \"0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3\",\n    \"0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931\",\n    \"0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84\"\n  ],\n  [\n    \"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b\",\n    \"0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573\",\n    \"0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f\",\n    \"0x0000000000000000000000000000000000000000000000000000000000000001\"\n  ]\n].map((t) => t.map((e) => BigInt(e)))), gu = tu(tt, {\n  A: BigInt(\"0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533\"),\n  B: BigInt(\"1771\"),\n  Z: tt.create(BigInt(\"-11\"))\n});\ncu(ue.ProjectivePoint, (t) => {\n  const { x: e, y: r } = gu(tt.create(t[0]));\n  return yu(e, r);\n}, {\n  DST: \"secp256k1_XMD:SHA-256_SSWU_RO_\",\n  encodeDST: \"secp256k1_XMD:SHA-256_SSWU_NU_\",\n  p: tt.ORDER,\n  m: 1,\n  k: 128,\n  expand: \"xmd\",\n  hash: Or\n});\nconst an = typeof globalThis == \"object\" && \"crypto\" in globalThis ? globalThis.crypto : void 0;\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst cn = (t) => new DataView(t.buffer, t.byteOffset, t.byteLength), Ce = (t, e) => t << 32 - e | t >>> e, bu = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;\nif (!bu)\n  throw new Error(\"Non little-endian hardware is not supported\");\nconst vu = Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, \"0\"));\nfunction ve(t) {\n  if (!(t instanceof Uint8Array))\n    throw new Error(\"Uint8Array expected\");\n  let e = \"\";\n  for (let r = 0; r < t.length; r++)\n    e += vu[t[r]];\n  return e;\n}\nfunction _t(t) {\n  if (typeof t != \"string\")\n    throw new TypeError(\"hexToBytes: expected string, got \" + typeof t);\n  if (t.length % 2)\n    throw new Error(\"hexToBytes: received invalid unpadded hex\");\n  const e = new Uint8Array(t.length / 2);\n  for (let r = 0; r < e.length; r++) {\n    const n = r * 2, i = t.slice(n, n + 2), s = Number.parseInt(i, 16);\n    if (Number.isNaN(s) || s < 0)\n      throw new Error(\"Invalid byte sequence\");\n    e[r] = s;\n  }\n  return e;\n}\nfunction wu(t) {\n  if (typeof t != \"string\")\n    throw new TypeError(`utf8ToBytes expected string, got ${typeof t}`);\n  return new TextEncoder().encode(t);\n}\nfunction ys(t) {\n  if (typeof t == \"string\" && (t = wu(t)), !(t instanceof Uint8Array))\n    throw new TypeError(`Expected input type is Uint8Array (got ${typeof t})`);\n  return t;\n}\nfunction _u(...t) {\n  if (!t.every((n) => n instanceof Uint8Array))\n    throw new Error(\"Uint8Array list expected\");\n  if (t.length === 1)\n    return t[0];\n  const e = t.reduce((n, i) => n + i.length, 0), r = new Uint8Array(e);\n  for (let n = 0, i = 0; n < t.length; n++) {\n    const s = t[n];\n    r.set(s, i), i += s.length;\n  }\n  return r;\n}\nclass mu {\n  clone() {\n    return this._cloneInto();\n  }\n}\nfunction gs(t) {\n  const e = (n) => t().update(ys(n)).digest(), r = t();\n  return e.outputLen = r.outputLen, e.blockLen = r.blockLen, e.create = () => t(), e;\n}\nfunction xu(t = 32) {\n  if (an && typeof an.getRandomValues == \"function\")\n    return an.getRandomValues(new Uint8Array(t));\n  throw new Error(\"crypto.getRandomValues must be defined\");\n}\nfunction Pn(t) {\n  if (!Number.isSafeInteger(t) || t < 0)\n    throw new Error(`Wrong positive integer: ${t}`);\n}\nfunction Eu(t) {\n  if (typeof t != \"boolean\")\n    throw new Error(`Expected boolean, not ${t}`);\n}\nfunction bs(t, ...e) {\n  if (!(t instanceof Uint8Array))\n    throw new TypeError(\"Expected Uint8Array\");\n  if (e.length > 0 && !e.includes(t.length))\n    throw new TypeError(`Expected Uint8Array of length ${e}, not of length=${t.length}`);\n}\nfunction ku(t) {\n  if (typeof t != \"function\" || typeof t.create != \"function\")\n    throw new Error(\"Hash should be wrapped by utils.wrapConstructor\");\n  Pn(t.outputLen), Pn(t.blockLen);\n}\nfunction Su(t, e = !0) {\n  if (t.destroyed)\n    throw new Error(\"Hash instance has been destroyed\");\n  if (e && t.finished)\n    throw new Error(\"Hash#digest() has already been called\");\n}\nfunction Ou(t, e) {\n  bs(t);\n  const r = e.outputLen;\n  if (t.length < r)\n    throw new Error(`digestInto() expects output buffer of length at least ${r}`);\n}\nconst un = {\n  number: Pn,\n  bool: Eu,\n  bytes: bs,\n  hash: ku,\n  exists: Su,\n  output: Ou\n};\nfunction Au(t, e, r, n) {\n  if (typeof t.setBigUint64 == \"function\")\n    return t.setBigUint64(e, r, n);\n  const i = BigInt(32), s = BigInt(4294967295), o = Number(r >> i & s), a = Number(r & s), c = n ? 4 : 0, l = n ? 0 : 4;\n  t.setUint32(e + c, o, n), t.setUint32(e + l, a, n);\n}\nclass Cu extends mu {\n  constructor(e, r, n, i) {\n    super(), this.blockLen = e, this.outputLen = r, this.padOffset = n, this.isLE = i, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = cn(this.buffer);\n  }\n  update(e) {\n    un.exists(this);\n    const { view: r, buffer: n, blockLen: i } = this;\n    e = ys(e);\n    const s = e.length;\n    for (let o = 0; o < s; ) {\n      const a = Math.min(i - this.pos, s - o);\n      if (a === i) {\n        const c = cn(e);\n        for (; i <= s - o; o += i)\n          this.process(c, o);\n        continue;\n      }\n      n.set(e.subarray(o, o + a), this.pos), this.pos += a, o += a, this.pos === i && (this.process(r, 0), this.pos = 0);\n    }\n    return this.length += e.length, this.roundClean(), this;\n  }\n  digestInto(e) {\n    un.exists(this), un.output(e, this), this.finished = !0;\n    const { buffer: r, view: n, blockLen: i, isLE: s } = this;\n    let { pos: o } = this;\n    r[o++] = 128, this.buffer.subarray(o).fill(0), this.padOffset > i - o && (this.process(n, 0), o = 0);\n    for (let u = o; u < i; u++)\n      r[u] = 0;\n    Au(n, i - 8, BigInt(this.length * 8), s), this.process(n, 0);\n    const a = cn(e), c = this.outputLen;\n    if (c % 4)\n      throw new Error(\"_sha2: outputLen should be aligned to 32bit\");\n    const l = c / 4, f = this.get();\n    if (l > f.length)\n      throw new Error(\"_sha2: outputLen bigger than state\");\n    for (let u = 0; u < l; u++)\n      a.setUint32(4 * u, f[u], s);\n  }\n  digest() {\n    const { buffer: e, outputLen: r } = this;\n    this.digestInto(e);\n    const n = e.slice(0, r);\n    return this.destroy(), n;\n  }\n  _cloneInto(e) {\n    e || (e = new this.constructor()), e.set(...this.get());\n    const { blockLen: r, buffer: n, length: i, finished: s, destroyed: o, pos: a } = this;\n    return e.length = i, e.pos = a, e.finished = s, e.destroyed = o, i % r && e.buffer.set(n), e;\n  }\n}\nconst Iu = (t, e, r) => t & e ^ ~t & r, Ru = (t, e, r) => t & e ^ t & r ^ e & r, Tu = new Uint32Array([\n  1116352408,\n  1899447441,\n  3049323471,\n  3921009573,\n  961987163,\n  1508970993,\n  2453635748,\n  2870763221,\n  3624381080,\n  310598401,\n  607225278,\n  1426881987,\n  1925078388,\n  2162078206,\n  2614888103,\n  3248222580,\n  3835390401,\n  4022224774,\n  264347078,\n  604807628,\n  770255983,\n  1249150122,\n  1555081692,\n  1996064986,\n  2554220882,\n  2821834349,\n  2952996808,\n  3210313671,\n  3336571891,\n  3584528711,\n  113926993,\n  338241895,\n  666307205,\n  773529912,\n  1294757372,\n  1396182291,\n  1695183700,\n  1986661051,\n  2177026350,\n  2456956037,\n  2730485921,\n  2820302411,\n  3259730800,\n  3345764771,\n  3516065817,\n  3600352804,\n  4094571909,\n  275423344,\n  430227734,\n  506948616,\n  659060556,\n  883997877,\n  958139571,\n  1322822218,\n  1537002063,\n  1747873779,\n  1955562222,\n  2024104815,\n  2227730452,\n  2361852424,\n  2428436474,\n  2756734187,\n  3204031479,\n  3329325298\n]), ze = new Uint32Array([\n  1779033703,\n  3144134277,\n  1013904242,\n  2773480762,\n  1359893119,\n  2600822924,\n  528734635,\n  1541459225\n]), Fe = new Uint32Array(64);\nclass vs extends Cu {\n  constructor() {\n    super(64, 32, 8, !1), this.A = ze[0] | 0, this.B = ze[1] | 0, this.C = ze[2] | 0, this.D = ze[3] | 0, this.E = ze[4] | 0, this.F = ze[5] | 0, this.G = ze[6] | 0, this.H = ze[7] | 0;\n  }\n  get() {\n    const { A: e, B: r, C: n, D: i, E: s, F: o, G: a, H: c } = this;\n    return [e, r, n, i, s, o, a, c];\n  }\n  set(e, r, n, i, s, o, a, c) {\n    this.A = e | 0, this.B = r | 0, this.C = n | 0, this.D = i | 0, this.E = s | 0, this.F = o | 0, this.G = a | 0, this.H = c | 0;\n  }\n  process(e, r) {\n    for (let u = 0; u < 16; u++, r += 4)\n      Fe[u] = e.getUint32(r, !1);\n    for (let u = 16; u < 64; u++) {\n      const h = Fe[u - 15], d = Fe[u - 2], p = Ce(h, 7) ^ Ce(h, 18) ^ h >>> 3, y = Ce(d, 17) ^ Ce(d, 19) ^ d >>> 10;\n      Fe[u] = y + Fe[u - 7] + p + Fe[u - 16] | 0;\n    }\n    let { A: n, B: i, C: s, D: o, E: a, F: c, G: l, H: f } = this;\n    for (let u = 0; u < 64; u++) {\n      const h = Ce(a, 6) ^ Ce(a, 11) ^ Ce(a, 25), d = f + h + Iu(a, c, l) + Tu[u] + Fe[u] | 0, y = (Ce(n, 2) ^ Ce(n, 13) ^ Ce(n, 22)) + Ru(n, i, s) | 0;\n      f = l, l = c, c = a, a = o + d | 0, o = s, s = i, i = n, n = d + y | 0;\n    }\n    n = n + this.A | 0, i = i + this.B | 0, s = s + this.C | 0, o = o + this.D | 0, a = a + this.E | 0, c = c + this.F | 0, l = l + this.G | 0, f = f + this.H | 0, this.set(n, i, s, o, a, c, l, f);\n  }\n  roundClean() {\n    Fe.fill(0);\n  }\n  destroy() {\n    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);\n  }\n}\nclass Pu extends vs {\n  constructor() {\n    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;\n  }\n}\nconst Yn = gs(() => new vs());\ngs(() => new Pu());\n/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nfunction rt(t) {\n  if (!Number.isSafeInteger(t))\n    throw new Error(`Wrong integer: ${t}`);\n}\nfunction Se(...t) {\n  const e = (i, s) => (o) => i(s(o)), r = Array.from(t).reverse().reduce((i, s) => i ? e(i, s.encode) : s.encode, void 0), n = t.reduce((i, s) => i ? e(i, s.decode) : s.decode, void 0);\n  return { encode: r, decode: n };\n}\nfunction Re(t) {\n  return {\n    encode: (e) => {\n      if (!Array.isArray(e) || e.length && typeof e[0] != \"number\")\n        throw new Error(\"alphabet.encode input should be an array of numbers\");\n      return e.map((r) => {\n        if (rt(r), r < 0 || r >= t.length)\n          throw new Error(`Digit index outside alphabet: ${r} (alphabet: ${t.length})`);\n        return t[r];\n      });\n    },\n    decode: (e) => {\n      if (!Array.isArray(e) || e.length && typeof e[0] != \"string\")\n        throw new Error(\"alphabet.decode input should be array of strings\");\n      return e.map((r) => {\n        if (typeof r != \"string\")\n          throw new Error(`alphabet.decode: not string element=${r}`);\n        const n = t.indexOf(r);\n        if (n === -1)\n          throw new Error(`Unknown letter: \"${r}\". Allowed: ${t}`);\n        return n;\n      });\n    }\n  };\n}\nfunction Te(t = \"\") {\n  if (typeof t != \"string\")\n    throw new Error(\"join separator should be string\");\n  return {\n    encode: (e) => {\n      if (!Array.isArray(e) || e.length && typeof e[0] != \"string\")\n        throw new Error(\"join.encode input should be array of strings\");\n      for (let r of e)\n        if (typeof r != \"string\")\n          throw new Error(`join.encode: non-string input=${r}`);\n      return e.join(t);\n    },\n    decode: (e) => {\n      if (typeof e != \"string\")\n        throw new Error(\"join.decode input should be string\");\n      return e.split(t);\n    }\n  };\n}\nfunction sr(t, e = \"=\") {\n  if (rt(t), typeof e != \"string\")\n    throw new Error(\"padding chr should be string\");\n  return {\n    encode(r) {\n      if (!Array.isArray(r) || r.length && typeof r[0] != \"string\")\n        throw new Error(\"padding.encode input should be array of strings\");\n      for (let n of r)\n        if (typeof n != \"string\")\n          throw new Error(`padding.encode: non-string input=${n}`);\n      for (; r.length * t % 8; )\n        r.push(e);\n      return r;\n    },\n    decode(r) {\n      if (!Array.isArray(r) || r.length && typeof r[0] != \"string\")\n        throw new Error(\"padding.encode input should be array of strings\");\n      for (let i of r)\n        if (typeof i != \"string\")\n          throw new Error(`padding.decode: non-string input=${i}`);\n      let n = r.length;\n      if (n * t % 8)\n        throw new Error(\"Invalid padding: string should have whole number of bytes\");\n      for (; n > 0 && r[n - 1] === e; n--)\n        if (!((n - 1) * t % 8))\n          throw new Error(\"Invalid padding: string has too much padding\");\n      return r.slice(0, n);\n    }\n  };\n}\nfunction ws(t) {\n  if (typeof t != \"function\")\n    throw new Error(\"normalize fn should be function\");\n  return { encode: (e) => e, decode: (e) => t(e) };\n}\nfunction Fi(t, e, r) {\n  if (e < 2)\n    throw new Error(`convertRadix: wrong from=${e}, base cannot be less than 2`);\n  if (r < 2)\n    throw new Error(`convertRadix: wrong to=${r}, base cannot be less than 2`);\n  if (!Array.isArray(t))\n    throw new Error(\"convertRadix: data should be array\");\n  if (!t.length)\n    return [];\n  let n = 0;\n  const i = [], s = Array.from(t);\n  for (s.forEach((o) => {\n    if (rt(o), o < 0 || o >= e)\n      throw new Error(`Wrong integer: ${o}`);\n  }); ; ) {\n    let o = 0, a = !0;\n    for (let c = n; c < s.length; c++) {\n      const l = s[c], f = e * o + l;\n      if (!Number.isSafeInteger(f) || e * o / e !== o || f - l !== e * o)\n        throw new Error(\"convertRadix: carry overflow\");\n      if (o = f % r, s[c] = Math.floor(f / r), !Number.isSafeInteger(s[c]) || s[c] * r + o !== f)\n        throw new Error(\"convertRadix: carry overflow\");\n      if (a)\n        s[c] ? a = !1 : n = c;\n      else\n        continue;\n    }\n    if (i.push(o), a)\n      break;\n  }\n  for (let o = 0; o < t.length - 1 && t[o] === 0; o++)\n    i.push(0);\n  return i.reverse();\n}\nconst _s = (t, e) => e ? _s(e, t % e) : t, Tr = (t, e) => t + (e - _s(t, e));\nfunction Bn(t, e, r, n) {\n  if (!Array.isArray(t))\n    throw new Error(\"convertRadix2: data should be array\");\n  if (e <= 0 || e > 32)\n    throw new Error(`convertRadix2: wrong from=${e}`);\n  if (r <= 0 || r > 32)\n    throw new Error(`convertRadix2: wrong to=${r}`);\n  if (Tr(e, r) > 32)\n    throw new Error(`convertRadix2: carry overflow from=${e} to=${r} carryBits=${Tr(e, r)}`);\n  let i = 0, s = 0;\n  const o = 2 ** r - 1, a = [];\n  for (const c of t) {\n    if (rt(c), c >= 2 ** e)\n      throw new Error(`convertRadix2: invalid data word=${c} from=${e}`);\n    if (i = i << e | c, s + e > 32)\n      throw new Error(`convertRadix2: carry overflow pos=${s} from=${e}`);\n    for (s += e; s >= r; s -= r)\n      a.push((i >> s - r & o) >>> 0);\n    i &= 2 ** s - 1;\n  }\n  if (i = i << r - s & o, !n && s >= e)\n    throw new Error(\"Excess padding\");\n  if (!n && i)\n    throw new Error(`Non-zero padding: ${i}`);\n  return n && s > 0 && a.push(i >>> 0), a;\n}\nfunction ms(t) {\n  return rt(t), {\n    encode: (e) => {\n      if (!(e instanceof Uint8Array))\n        throw new Error(\"radix.encode input should be Uint8Array\");\n      return Fi(Array.from(e), 2 ** 8, t);\n    },\n    decode: (e) => {\n      if (!Array.isArray(e) || e.length && typeof e[0] != \"number\")\n        throw new Error(\"radix.decode input should be array of strings\");\n      return Uint8Array.from(Fi(e, t, 2 ** 8));\n    }\n  };\n}\nfunction Ne(t, e = !1) {\n  if (rt(t), t <= 0 || t > 32)\n    throw new Error(\"radix2: bits should be in (0..32]\");\n  if (Tr(8, t) > 32 || Tr(t, 8) > 32)\n    throw new Error(\"radix2: carry overflow\");\n  return {\n    encode: (r) => {\n      if (!(r instanceof Uint8Array))\n        throw new Error(\"radix2.encode input should be Uint8Array\");\n      return Bn(Array.from(r), 8, t, !e);\n    },\n    decode: (r) => {\n      if (!Array.isArray(r) || r.length && typeof r[0] != \"number\")\n        throw new Error(\"radix2.decode input should be array of strings\");\n      return Uint8Array.from(Bn(r, t, 8, e));\n    }\n  };\n}\nfunction Ki(t) {\n  if (typeof t != \"function\")\n    throw new Error(\"unsafeWrapper fn should be function\");\n  return function(...e) {\n    try {\n      return t.apply(null, e);\n    } catch {\n    }\n  };\n}\nfunction xs(t, e) {\n  if (rt(t), typeof e != \"function\")\n    throw new Error(\"checksum fn should be function\");\n  return {\n    encode(r) {\n      if (!(r instanceof Uint8Array))\n        throw new Error(\"checksum.encode: input should be Uint8Array\");\n      const n = e(r).slice(0, t), i = new Uint8Array(r.length + t);\n      return i.set(r), i.set(n, r.length), i;\n    },\n    decode(r) {\n      if (!(r instanceof Uint8Array))\n        throw new Error(\"checksum.decode: input should be Uint8Array\");\n      const n = r.slice(0, -t), i = e(n).slice(0, t), s = r.slice(-t);\n      for (let o = 0; o < t; o++)\n        if (i[o] !== s[o])\n          throw new Error(\"Invalid checksum\");\n      return n;\n    }\n  };\n}\nconst Bu = { alphabet: Re, chain: Se, checksum: xs, radix: ms, radix2: Ne, join: Te, padding: sr }, Es = Se(Ne(4), Re(\"0123456789ABCDEF\"), Te(\"\")), ks = Se(Ne(5), Re(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\"), sr(5), Te(\"\")), Lu = Se(Ne(5), Re(\"0123456789ABCDEFGHIJKLMNOPQRSTUV\"), sr(5), Te(\"\")), $u = Se(Ne(5), Re(\"0123456789ABCDEFGHJKMNPQRSTVWXYZ\"), Te(\"\"), ws((t) => t.toUpperCase().replace(/O/g, \"0\").replace(/[IL]/g, \"1\"))), mt = Se(Ne(6), Re(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"), sr(6), Te(\"\")), Ss = Se(Ne(6), Re(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\"), sr(6), Te(\"\")), Jn = (t) => Se(ms(58), Re(t), Te(\"\")), nr = Jn(\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"), qu = Jn(\"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ\"), Nu = Jn(\"rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz\"), Wi = [0, 2, 3, 5, 6, 7, 9, 10, 11], Os = {\n  encode(t) {\n    let e = \"\";\n    for (let r = 0; r < t.length; r += 8) {\n      const n = t.subarray(r, r + 8);\n      e += nr.encode(n).padStart(Wi[n.length], \"1\");\n    }\n    return e;\n  },\n  decode(t) {\n    let e = [];\n    for (let r = 0; r < t.length; r += 11) {\n      const n = t.slice(r, r + 11), i = Wi.indexOf(n.length), s = nr.decode(n);\n      for (let o = 0; o < s.length - i; o++)\n        if (s[o] !== 0)\n          throw new Error(\"base58xmr: wrong padding\");\n      e = e.concat(Array.from(s.slice(s.length - i)));\n    }\n    return Uint8Array.from(e);\n  }\n}, As = (t) => Se(xs(4, (e) => t(t(e))), nr), Ln = Se(Re(\"qpzry9x8gf2tvdw0s3jn54khce6mua7l\"), Te(\"\")), Vi = [996825010, 642813549, 513874426, 1027748829, 705979059];\nfunction It(t) {\n  const e = t >> 25;\n  let r = (t & 33554431) << 5;\n  for (let n = 0; n < Vi.length; n++)\n    (e >> n & 1) === 1 && (r ^= Vi[n]);\n  return r;\n}\nfunction Gi(t, e, r = 1) {\n  const n = t.length;\n  let i = 1;\n  for (let s = 0; s < n; s++) {\n    const o = t.charCodeAt(s);\n    if (o < 33 || o > 126)\n      throw new Error(`Invalid prefix (${t})`);\n    i = It(i) ^ o >> 5;\n  }\n  i = It(i);\n  for (let s = 0; s < n; s++)\n    i = It(i) ^ t.charCodeAt(s) & 31;\n  for (let s of e)\n    i = It(i) ^ s;\n  for (let s = 0; s < 6; s++)\n    i = It(i);\n  return i ^= r, Ln.encode(Bn([i % 2 ** 30], 30, 5, !1));\n}\nfunction Cs(t) {\n  const e = t === \"bech32\" ? 1 : 734539939, r = Ne(5), n = r.decode, i = r.encode, s = Ki(n);\n  function o(f, u, h = 90) {\n    if (typeof f != \"string\")\n      throw new Error(`bech32.encode prefix should be string, not ${typeof f}`);\n    if (!Array.isArray(u) || u.length && typeof u[0] != \"number\")\n      throw new Error(`bech32.encode words should be array of numbers, not ${typeof u}`);\n    const d = f.length + 7 + u.length;\n    if (h !== !1 && d > h)\n      throw new TypeError(`Length ${d} exceeds limit ${h}`);\n    return f = f.toLowerCase(), `${f}1${Ln.encode(u)}${Gi(f, u, e)}`;\n  }\n  function a(f, u = 90) {\n    if (typeof f != \"string\")\n      throw new Error(`bech32.decode input should be string, not ${typeof f}`);\n    if (f.length < 8 || u !== !1 && f.length > u)\n      throw new TypeError(`Wrong string length: ${f.length} (${f}). Expected (8..${u})`);\n    const h = f.toLowerCase();\n    if (f !== h && f !== f.toUpperCase())\n      throw new Error(\"String must be lowercase or uppercase\");\n    f = h;\n    const d = f.lastIndexOf(\"1\");\n    if (d === 0 || d === -1)\n      throw new Error('Letter \"1\" must be present between prefix and data only');\n    const p = f.slice(0, d), y = f.slice(d + 1);\n    if (y.length < 6)\n      throw new Error(\"Data must be at least 6 characters long\");\n    const g = Ln.decode(y).slice(0, -6), v = Gi(p, g, e);\n    if (!y.endsWith(v))\n      throw new Error(`Invalid checksum in ${f}: expected \"${v}\"`);\n    return { prefix: p, words: g };\n  }\n  const c = Ki(a);\n  function l(f) {\n    const { prefix: u, words: h } = a(f, !1);\n    return { prefix: u, words: h, bytes: n(h) };\n  }\n  return { encode: o, decode: a, decodeToBytes: l, decodeUnsafe: c, fromWords: n, fromWordsUnsafe: s, toWords: i };\n}\nconst te = Cs(\"bech32\"), Uu = Cs(\"bech32m\"), Is = {\n  encode: (t) => new TextDecoder().decode(t),\n  decode: (t) => new TextEncoder().encode(t)\n}, Rs = Se(Ne(4), Re(\"0123456789abcdef\"), Te(\"\"), ws((t) => {\n  if (typeof t != \"string\" || t.length % 2)\n    throw new TypeError(`hex.decode: expected string, got ${typeof t} with length ${t.length}`);\n  return t.toLowerCase();\n})), ir = {\n  utf8: Is,\n  hex: Rs,\n  base16: Es,\n  base32: ks,\n  base64: mt,\n  base64url: Ss,\n  base58: nr,\n  base58xmr: Os\n}, Ts = `Invalid encoding type. Available types: ${Object.keys(ir).join(\", \")}`, Ps = (t, e) => {\n  if (typeof t != \"string\" || !ir.hasOwnProperty(t))\n    throw new TypeError(Ts);\n  if (!(e instanceof Uint8Array))\n    throw new TypeError(\"bytesToString() expects Uint8Array\");\n  return ir[t].encode(e);\n}, ju = Ps, Bs = (t, e) => {\n  if (!ir.hasOwnProperty(t))\n    throw new TypeError(Ts);\n  if (typeof e != \"string\")\n    throw new TypeError(\"stringToBytes() expects string\");\n  return ir[t].decode(e);\n}, Hu = Bs, Mu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  assertNumber: rt,\n  utils: Bu,\n  base16: Es,\n  base32: ks,\n  base32hex: Lu,\n  base32crockford: $u,\n  base64: mt,\n  base64url: Ss,\n  base58: nr,\n  base58flickr: qu,\n  base58xrp: Nu,\n  base58xmr: Os,\n  base58check: As,\n  bech32: te,\n  bech32m: Uu,\n  utf8: Is,\n  hex: Rs,\n  bytesToString: Ps,\n  str: ju,\n  stringToBytes: Bs,\n  bytes: Hu\n}, Symbol.toStringTag, { value: \"Module\" }));\nvar Xn = {};\nObject.defineProperty(Xn, \"__esModule\", { value: !0 });\nvar Qn = Xn.wordlist = void 0;\nQn = Xn.wordlist = `abandon\nability\nable\nabout\nabove\nabsent\nabsorb\nabstract\nabsurd\nabuse\naccess\naccident\naccount\naccuse\nachieve\nacid\nacoustic\nacquire\nacross\nact\naction\nactor\nactress\nactual\nadapt\nadd\naddict\naddress\nadjust\nadmit\nadult\nadvance\nadvice\naerobic\naffair\nafford\nafraid\nagain\nage\nagent\nagree\nahead\naim\nair\nairport\naisle\nalarm\nalbum\nalcohol\nalert\nalien\nall\nalley\nallow\nalmost\nalone\nalpha\nalready\nalso\nalter\nalways\namateur\namazing\namong\namount\namused\nanalyst\nanchor\nancient\nanger\nangle\nangry\nanimal\nankle\nannounce\nannual\nanother\nanswer\nantenna\nantique\nanxiety\nany\napart\napology\nappear\napple\napprove\napril\narch\narctic\narea\narena\nargue\narm\narmed\narmor\narmy\naround\narrange\narrest\narrive\narrow\nart\nartefact\nartist\nartwork\nask\naspect\nassault\nasset\nassist\nassume\nasthma\nathlete\natom\nattack\nattend\nattitude\nattract\nauction\naudit\naugust\naunt\nauthor\nauto\nautumn\naverage\navocado\navoid\nawake\naware\naway\nawesome\nawful\nawkward\naxis\nbaby\nbachelor\nbacon\nbadge\nbag\nbalance\nbalcony\nball\nbamboo\nbanana\nbanner\nbar\nbarely\nbargain\nbarrel\nbase\nbasic\nbasket\nbattle\nbeach\nbean\nbeauty\nbecause\nbecome\nbeef\nbefore\nbegin\nbehave\nbehind\nbelieve\nbelow\nbelt\nbench\nbenefit\nbest\nbetray\nbetter\nbetween\nbeyond\nbicycle\nbid\nbike\nbind\nbiology\nbird\nbirth\nbitter\nblack\nblade\nblame\nblanket\nblast\nbleak\nbless\nblind\nblood\nblossom\nblouse\nblue\nblur\nblush\nboard\nboat\nbody\nboil\nbomb\nbone\nbonus\nbook\nboost\nborder\nboring\nborrow\nboss\nbottom\nbounce\nbox\nboy\nbracket\nbrain\nbrand\nbrass\nbrave\nbread\nbreeze\nbrick\nbridge\nbrief\nbright\nbring\nbrisk\nbroccoli\nbroken\nbronze\nbroom\nbrother\nbrown\nbrush\nbubble\nbuddy\nbudget\nbuffalo\nbuild\nbulb\nbulk\nbullet\nbundle\nbunker\nburden\nburger\nburst\nbus\nbusiness\nbusy\nbutter\nbuyer\nbuzz\ncabbage\ncabin\ncable\ncactus\ncage\ncake\ncall\ncalm\ncamera\ncamp\ncan\ncanal\ncancel\ncandy\ncannon\ncanoe\ncanvas\ncanyon\ncapable\ncapital\ncaptain\ncar\ncarbon\ncard\ncargo\ncarpet\ncarry\ncart\ncase\ncash\ncasino\ncastle\ncasual\ncat\ncatalog\ncatch\ncategory\ncattle\ncaught\ncause\ncaution\ncave\nceiling\ncelery\ncement\ncensus\ncentury\ncereal\ncertain\nchair\nchalk\nchampion\nchange\nchaos\nchapter\ncharge\nchase\nchat\ncheap\ncheck\ncheese\nchef\ncherry\nchest\nchicken\nchief\nchild\nchimney\nchoice\nchoose\nchronic\nchuckle\nchunk\nchurn\ncigar\ncinnamon\ncircle\ncitizen\ncity\ncivil\nclaim\nclap\nclarify\nclaw\nclay\nclean\nclerk\nclever\nclick\nclient\ncliff\nclimb\nclinic\nclip\nclock\nclog\nclose\ncloth\ncloud\nclown\nclub\nclump\ncluster\nclutch\ncoach\ncoast\ncoconut\ncode\ncoffee\ncoil\ncoin\ncollect\ncolor\ncolumn\ncombine\ncome\ncomfort\ncomic\ncommon\ncompany\nconcert\nconduct\nconfirm\ncongress\nconnect\nconsider\ncontrol\nconvince\ncook\ncool\ncopper\ncopy\ncoral\ncore\ncorn\ncorrect\ncost\ncotton\ncouch\ncountry\ncouple\ncourse\ncousin\ncover\ncoyote\ncrack\ncradle\ncraft\ncram\ncrane\ncrash\ncrater\ncrawl\ncrazy\ncream\ncredit\ncreek\ncrew\ncricket\ncrime\ncrisp\ncritic\ncrop\ncross\ncrouch\ncrowd\ncrucial\ncruel\ncruise\ncrumble\ncrunch\ncrush\ncry\ncrystal\ncube\nculture\ncup\ncupboard\ncurious\ncurrent\ncurtain\ncurve\ncushion\ncustom\ncute\ncycle\ndad\ndamage\ndamp\ndance\ndanger\ndaring\ndash\ndaughter\ndawn\nday\ndeal\ndebate\ndebris\ndecade\ndecember\ndecide\ndecline\ndecorate\ndecrease\ndeer\ndefense\ndefine\ndefy\ndegree\ndelay\ndeliver\ndemand\ndemise\ndenial\ndentist\ndeny\ndepart\ndepend\ndeposit\ndepth\ndeputy\nderive\ndescribe\ndesert\ndesign\ndesk\ndespair\ndestroy\ndetail\ndetect\ndevelop\ndevice\ndevote\ndiagram\ndial\ndiamond\ndiary\ndice\ndiesel\ndiet\ndiffer\ndigital\ndignity\ndilemma\ndinner\ndinosaur\ndirect\ndirt\ndisagree\ndiscover\ndisease\ndish\ndismiss\ndisorder\ndisplay\ndistance\ndivert\ndivide\ndivorce\ndizzy\ndoctor\ndocument\ndog\ndoll\ndolphin\ndomain\ndonate\ndonkey\ndonor\ndoor\ndose\ndouble\ndove\ndraft\ndragon\ndrama\ndrastic\ndraw\ndream\ndress\ndrift\ndrill\ndrink\ndrip\ndrive\ndrop\ndrum\ndry\nduck\ndumb\ndune\nduring\ndust\ndutch\nduty\ndwarf\ndynamic\neager\neagle\nearly\nearn\nearth\neasily\neast\neasy\necho\necology\neconomy\nedge\nedit\neducate\neffort\negg\neight\neither\nelbow\nelder\nelectric\nelegant\nelement\nelephant\nelevator\nelite\nelse\nembark\nembody\nembrace\nemerge\nemotion\nemploy\nempower\nempty\nenable\nenact\nend\nendless\nendorse\nenemy\nenergy\nenforce\nengage\nengine\nenhance\nenjoy\nenlist\nenough\nenrich\nenroll\nensure\nenter\nentire\nentry\nenvelope\nepisode\nequal\nequip\nera\nerase\nerode\nerosion\nerror\nerupt\nescape\nessay\nessence\nestate\neternal\nethics\nevidence\nevil\nevoke\nevolve\nexact\nexample\nexcess\nexchange\nexcite\nexclude\nexcuse\nexecute\nexercise\nexhaust\nexhibit\nexile\nexist\nexit\nexotic\nexpand\nexpect\nexpire\nexplain\nexpose\nexpress\nextend\nextra\neye\neyebrow\nfabric\nface\nfaculty\nfade\nfaint\nfaith\nfall\nfalse\nfame\nfamily\nfamous\nfan\nfancy\nfantasy\nfarm\nfashion\nfat\nfatal\nfather\nfatigue\nfault\nfavorite\nfeature\nfebruary\nfederal\nfee\nfeed\nfeel\nfemale\nfence\nfestival\nfetch\nfever\nfew\nfiber\nfiction\nfield\nfigure\nfile\nfilm\nfilter\nfinal\nfind\nfine\nfinger\nfinish\nfire\nfirm\nfirst\nfiscal\nfish\nfit\nfitness\nfix\nflag\nflame\nflash\nflat\nflavor\nflee\nflight\nflip\nfloat\nflock\nfloor\nflower\nfluid\nflush\nfly\nfoam\nfocus\nfog\nfoil\nfold\nfollow\nfood\nfoot\nforce\nforest\nforget\nfork\nfortune\nforum\nforward\nfossil\nfoster\nfound\nfox\nfragile\nframe\nfrequent\nfresh\nfriend\nfringe\nfrog\nfront\nfrost\nfrown\nfrozen\nfruit\nfuel\nfun\nfunny\nfurnace\nfury\nfuture\ngadget\ngain\ngalaxy\ngallery\ngame\ngap\ngarage\ngarbage\ngarden\ngarlic\ngarment\ngas\ngasp\ngate\ngather\ngauge\ngaze\ngeneral\ngenius\ngenre\ngentle\ngenuine\ngesture\nghost\ngiant\ngift\ngiggle\nginger\ngiraffe\ngirl\ngive\nglad\nglance\nglare\nglass\nglide\nglimpse\nglobe\ngloom\nglory\nglove\nglow\nglue\ngoat\ngoddess\ngold\ngood\ngoose\ngorilla\ngospel\ngossip\ngovern\ngown\ngrab\ngrace\ngrain\ngrant\ngrape\ngrass\ngravity\ngreat\ngreen\ngrid\ngrief\ngrit\ngrocery\ngroup\ngrow\ngrunt\nguard\nguess\nguide\nguilt\nguitar\ngun\ngym\nhabit\nhair\nhalf\nhammer\nhamster\nhand\nhappy\nharbor\nhard\nharsh\nharvest\nhat\nhave\nhawk\nhazard\nhead\nhealth\nheart\nheavy\nhedgehog\nheight\nhello\nhelmet\nhelp\nhen\nhero\nhidden\nhigh\nhill\nhint\nhip\nhire\nhistory\nhobby\nhockey\nhold\nhole\nholiday\nhollow\nhome\nhoney\nhood\nhope\nhorn\nhorror\nhorse\nhospital\nhost\nhotel\nhour\nhover\nhub\nhuge\nhuman\nhumble\nhumor\nhundred\nhungry\nhunt\nhurdle\nhurry\nhurt\nhusband\nhybrid\nice\nicon\nidea\nidentify\nidle\nignore\nill\nillegal\nillness\nimage\nimitate\nimmense\nimmune\nimpact\nimpose\nimprove\nimpulse\ninch\ninclude\nincome\nincrease\nindex\nindicate\nindoor\nindustry\ninfant\ninflict\ninform\ninhale\ninherit\ninitial\ninject\ninjury\ninmate\ninner\ninnocent\ninput\ninquiry\ninsane\ninsect\ninside\ninspire\ninstall\nintact\ninterest\ninto\ninvest\ninvite\ninvolve\niron\nisland\nisolate\nissue\nitem\nivory\njacket\njaguar\njar\njazz\njealous\njeans\njelly\njewel\njob\njoin\njoke\njourney\njoy\njudge\njuice\njump\njungle\njunior\njunk\njust\nkangaroo\nkeen\nkeep\nketchup\nkey\nkick\nkid\nkidney\nkind\nkingdom\nkiss\nkit\nkitchen\nkite\nkitten\nkiwi\nknee\nknife\nknock\nknow\nlab\nlabel\nlabor\nladder\nlady\nlake\nlamp\nlanguage\nlaptop\nlarge\nlater\nlatin\nlaugh\nlaundry\nlava\nlaw\nlawn\nlawsuit\nlayer\nlazy\nleader\nleaf\nlearn\nleave\nlecture\nleft\nleg\nlegal\nlegend\nleisure\nlemon\nlend\nlength\nlens\nleopard\nlesson\nletter\nlevel\nliar\nliberty\nlibrary\nlicense\nlife\nlift\nlight\nlike\nlimb\nlimit\nlink\nlion\nliquid\nlist\nlittle\nlive\nlizard\nload\nloan\nlobster\nlocal\nlock\nlogic\nlonely\nlong\nloop\nlottery\nloud\nlounge\nlove\nloyal\nlucky\nluggage\nlumber\nlunar\nlunch\nluxury\nlyrics\nmachine\nmad\nmagic\nmagnet\nmaid\nmail\nmain\nmajor\nmake\nmammal\nman\nmanage\nmandate\nmango\nmansion\nmanual\nmaple\nmarble\nmarch\nmargin\nmarine\nmarket\nmarriage\nmask\nmass\nmaster\nmatch\nmaterial\nmath\nmatrix\nmatter\nmaximum\nmaze\nmeadow\nmean\nmeasure\nmeat\nmechanic\nmedal\nmedia\nmelody\nmelt\nmember\nmemory\nmention\nmenu\nmercy\nmerge\nmerit\nmerry\nmesh\nmessage\nmetal\nmethod\nmiddle\nmidnight\nmilk\nmillion\nmimic\nmind\nminimum\nminor\nminute\nmiracle\nmirror\nmisery\nmiss\nmistake\nmix\nmixed\nmixture\nmobile\nmodel\nmodify\nmom\nmoment\nmonitor\nmonkey\nmonster\nmonth\nmoon\nmoral\nmore\nmorning\nmosquito\nmother\nmotion\nmotor\nmountain\nmouse\nmove\nmovie\nmuch\nmuffin\nmule\nmultiply\nmuscle\nmuseum\nmushroom\nmusic\nmust\nmutual\nmyself\nmystery\nmyth\nnaive\nname\nnapkin\nnarrow\nnasty\nnation\nnature\nnear\nneck\nneed\nnegative\nneglect\nneither\nnephew\nnerve\nnest\nnet\nnetwork\nneutral\nnever\nnews\nnext\nnice\nnight\nnoble\nnoise\nnominee\nnoodle\nnormal\nnorth\nnose\nnotable\nnote\nnothing\nnotice\nnovel\nnow\nnuclear\nnumber\nnurse\nnut\noak\nobey\nobject\noblige\nobscure\nobserve\nobtain\nobvious\noccur\nocean\noctober\nodor\noff\noffer\noffice\noften\noil\nokay\nold\nolive\nolympic\nomit\nonce\none\nonion\nonline\nonly\nopen\nopera\nopinion\noppose\noption\norange\norbit\norchard\norder\nordinary\norgan\norient\noriginal\norphan\nostrich\nother\noutdoor\nouter\noutput\noutside\noval\noven\nover\nown\nowner\noxygen\noyster\nozone\npact\npaddle\npage\npair\npalace\npalm\npanda\npanel\npanic\npanther\npaper\nparade\nparent\npark\nparrot\nparty\npass\npatch\npath\npatient\npatrol\npattern\npause\npave\npayment\npeace\npeanut\npear\npeasant\npelican\npen\npenalty\npencil\npeople\npepper\nperfect\npermit\nperson\npet\nphone\nphoto\nphrase\nphysical\npiano\npicnic\npicture\npiece\npig\npigeon\npill\npilot\npink\npioneer\npipe\npistol\npitch\npizza\nplace\nplanet\nplastic\nplate\nplay\nplease\npledge\npluck\nplug\nplunge\npoem\npoet\npoint\npolar\npole\npolice\npond\npony\npool\npopular\nportion\nposition\npossible\npost\npotato\npottery\npoverty\npowder\npower\npractice\npraise\npredict\nprefer\nprepare\npresent\npretty\nprevent\nprice\npride\nprimary\nprint\npriority\nprison\nprivate\nprize\nproblem\nprocess\nproduce\nprofit\nprogram\nproject\npromote\nproof\nproperty\nprosper\nprotect\nproud\nprovide\npublic\npudding\npull\npulp\npulse\npumpkin\npunch\npupil\npuppy\npurchase\npurity\npurpose\npurse\npush\nput\npuzzle\npyramid\nquality\nquantum\nquarter\nquestion\nquick\nquit\nquiz\nquote\nrabbit\nraccoon\nrace\nrack\nradar\nradio\nrail\nrain\nraise\nrally\nramp\nranch\nrandom\nrange\nrapid\nrare\nrate\nrather\nraven\nraw\nrazor\nready\nreal\nreason\nrebel\nrebuild\nrecall\nreceive\nrecipe\nrecord\nrecycle\nreduce\nreflect\nreform\nrefuse\nregion\nregret\nregular\nreject\nrelax\nrelease\nrelief\nrely\nremain\nremember\nremind\nremove\nrender\nrenew\nrent\nreopen\nrepair\nrepeat\nreplace\nreport\nrequire\nrescue\nresemble\nresist\nresource\nresponse\nresult\nretire\nretreat\nreturn\nreunion\nreveal\nreview\nreward\nrhythm\nrib\nribbon\nrice\nrich\nride\nridge\nrifle\nright\nrigid\nring\nriot\nripple\nrisk\nritual\nrival\nriver\nroad\nroast\nrobot\nrobust\nrocket\nromance\nroof\nrookie\nroom\nrose\nrotate\nrough\nround\nroute\nroyal\nrubber\nrude\nrug\nrule\nrun\nrunway\nrural\nsad\nsaddle\nsadness\nsafe\nsail\nsalad\nsalmon\nsalon\nsalt\nsalute\nsame\nsample\nsand\nsatisfy\nsatoshi\nsauce\nsausage\nsave\nsay\nscale\nscan\nscare\nscatter\nscene\nscheme\nschool\nscience\nscissors\nscorpion\nscout\nscrap\nscreen\nscript\nscrub\nsea\nsearch\nseason\nseat\nsecond\nsecret\nsection\nsecurity\nseed\nseek\nsegment\nselect\nsell\nseminar\nsenior\nsense\nsentence\nseries\nservice\nsession\nsettle\nsetup\nseven\nshadow\nshaft\nshallow\nshare\nshed\nshell\nsheriff\nshield\nshift\nshine\nship\nshiver\nshock\nshoe\nshoot\nshop\nshort\nshoulder\nshove\nshrimp\nshrug\nshuffle\nshy\nsibling\nsick\nside\nsiege\nsight\nsign\nsilent\nsilk\nsilly\nsilver\nsimilar\nsimple\nsince\nsing\nsiren\nsister\nsituate\nsix\nsize\nskate\nsketch\nski\nskill\nskin\nskirt\nskull\nslab\nslam\nsleep\nslender\nslice\nslide\nslight\nslim\nslogan\nslot\nslow\nslush\nsmall\nsmart\nsmile\nsmoke\nsmooth\nsnack\nsnake\nsnap\nsniff\nsnow\nsoap\nsoccer\nsocial\nsock\nsoda\nsoft\nsolar\nsoldier\nsolid\nsolution\nsolve\nsomeone\nsong\nsoon\nsorry\nsort\nsoul\nsound\nsoup\nsource\nsouth\nspace\nspare\nspatial\nspawn\nspeak\nspecial\nspeed\nspell\nspend\nsphere\nspice\nspider\nspike\nspin\nspirit\nsplit\nspoil\nsponsor\nspoon\nsport\nspot\nspray\nspread\nspring\nspy\nsquare\nsqueeze\nsquirrel\nstable\nstadium\nstaff\nstage\nstairs\nstamp\nstand\nstart\nstate\nstay\nsteak\nsteel\nstem\nstep\nstereo\nstick\nstill\nsting\nstock\nstomach\nstone\nstool\nstory\nstove\nstrategy\nstreet\nstrike\nstrong\nstruggle\nstudent\nstuff\nstumble\nstyle\nsubject\nsubmit\nsubway\nsuccess\nsuch\nsudden\nsuffer\nsugar\nsuggest\nsuit\nsummer\nsun\nsunny\nsunset\nsuper\nsupply\nsupreme\nsure\nsurface\nsurge\nsurprise\nsurround\nsurvey\nsuspect\nsustain\nswallow\nswamp\nswap\nswarm\nswear\nsweet\nswift\nswim\nswing\nswitch\nsword\nsymbol\nsymptom\nsyrup\nsystem\ntable\ntackle\ntag\ntail\ntalent\ntalk\ntank\ntape\ntarget\ntask\ntaste\ntattoo\ntaxi\nteach\nteam\ntell\nten\ntenant\ntennis\ntent\nterm\ntest\ntext\nthank\nthat\ntheme\nthen\ntheory\nthere\nthey\nthing\nthis\nthought\nthree\nthrive\nthrow\nthumb\nthunder\nticket\ntide\ntiger\ntilt\ntimber\ntime\ntiny\ntip\ntired\ntissue\ntitle\ntoast\ntobacco\ntoday\ntoddler\ntoe\ntogether\ntoilet\ntoken\ntomato\ntomorrow\ntone\ntongue\ntonight\ntool\ntooth\ntop\ntopic\ntopple\ntorch\ntornado\ntortoise\ntoss\ntotal\ntourist\ntoward\ntower\ntown\ntoy\ntrack\ntrade\ntraffic\ntragic\ntrain\ntransfer\ntrap\ntrash\ntravel\ntray\ntreat\ntree\ntrend\ntrial\ntribe\ntrick\ntrigger\ntrim\ntrip\ntrophy\ntrouble\ntruck\ntrue\ntruly\ntrumpet\ntrust\ntruth\ntry\ntube\ntuition\ntumble\ntuna\ntunnel\nturkey\nturn\nturtle\ntwelve\ntwenty\ntwice\ntwin\ntwist\ntwo\ntype\ntypical\nugly\numbrella\nunable\nunaware\nuncle\nuncover\nunder\nundo\nunfair\nunfold\nunhappy\nuniform\nunique\nunit\nuniverse\nunknown\nunlock\nuntil\nunusual\nunveil\nupdate\nupgrade\nuphold\nupon\nupper\nupset\nurban\nurge\nusage\nuse\nused\nuseful\nuseless\nusual\nutility\nvacant\nvacuum\nvague\nvalid\nvalley\nvalve\nvan\nvanish\nvapor\nvarious\nvast\nvault\nvehicle\nvelvet\nvendor\nventure\nvenue\nverb\nverify\nversion\nvery\nvessel\nveteran\nviable\nvibrant\nvicious\nvictory\nvideo\nview\nvillage\nvintage\nviolin\nvirtual\nvirus\nvisa\nvisit\nvisual\nvital\nvivid\nvocal\nvoice\nvoid\nvolcano\nvolume\nvote\nvoyage\nwage\nwagon\nwait\nwalk\nwall\nwalnut\nwant\nwarfare\nwarm\nwarrior\nwash\nwasp\nwaste\nwater\nwave\nway\nwealth\nweapon\nwear\nweasel\nweather\nweb\nwedding\nweekend\nweird\nwelcome\nwest\nwet\nwhale\nwhat\nwheat\nwheel\nwhen\nwhere\nwhip\nwhisper\nwide\nwidth\nwife\nwild\nwill\nwin\nwindow\nwine\nwing\nwink\nwinner\nwinter\nwire\nwisdom\nwise\nwish\nwitness\nwolf\nwoman\nwonder\nwood\nwool\nword\nwork\nworld\nworry\nworth\nwrap\nwreck\nwrestle\nwrist\nwrite\nwrong\nyard\nyear\nyellow\nyou\nyoung\nyouth\nzebra\nzero\nzone\nzoo`.split(`\n`);\nvar de = {};\nfunction Pr(t) {\n  if (!Number.isSafeInteger(t) || t < 0)\n    throw new Error(`Wrong positive integer: ${t}`);\n}\nfunction Ls(t) {\n  if (typeof t != \"boolean\")\n    throw new Error(`Expected boolean, not ${t}`);\n}\nfunction Ye(t, ...e) {\n  if (!(t instanceof Uint8Array))\n    throw new Error(\"Expected Uint8Array\");\n  if (e.length > 0 && !e.includes(t.length))\n    throw new Error(`Expected Uint8Array of length ${e}, not of length=${t.length}`);\n}\nfunction $s(t) {\n  if (typeof t != \"function\" || typeof t.create != \"function\")\n    throw new Error(\"Hash should be wrapped by utils.wrapConstructor\");\n  Pr(t.outputLen), Pr(t.blockLen);\n}\nfunction qs(t, e = !0) {\n  if (t.destroyed)\n    throw new Error(\"Hash instance has been destroyed\");\n  if (e && t.finished)\n    throw new Error(\"Hash#digest() has already been called\");\n}\nfunction Ns(t, e) {\n  Ye(t);\n  const r = e.outputLen;\n  if (t.length < r)\n    throw new Error(`digestInto() expects output buffer of length at least ${r}`);\n}\nconst Qe = {\n  number: Pr,\n  bool: Ls,\n  bytes: Ye,\n  hash: $s,\n  exists: qs,\n  output: Ns\n}, Du = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  number: Pr,\n  bool: Ls,\n  bytes: Ye,\n  hash: $s,\n  exists: qs,\n  output: Ns,\n  default: Qe\n}, Symbol.toStringTag, { value: \"Module\" })), zu = /* @__PURE__ */ Et(Du);\nvar xt = {}, ne = {};\nObject.defineProperty(ne, \"__esModule\", { value: !0 });\nne.output = ne.exists = ne.hash = ne.bytes = ne.bool = ne.number = void 0;\nfunction Br(t) {\n  if (!Number.isSafeInteger(t) || t < 0)\n    throw new Error(`Wrong positive integer: ${t}`);\n}\nne.number = Br;\nfunction Us(t) {\n  if (typeof t != \"boolean\")\n    throw new Error(`Expected boolean, not ${t}`);\n}\nne.bool = Us;\nfunction ei(t, ...e) {\n  if (!(t instanceof Uint8Array))\n    throw new Error(\"Expected Uint8Array\");\n  if (e.length > 0 && !e.includes(t.length))\n    throw new Error(`Expected Uint8Array of length ${e}, not of length=${t.length}`);\n}\nne.bytes = ei;\nfunction js(t) {\n  if (typeof t != \"function\" || typeof t.create != \"function\")\n    throw new Error(\"Hash should be wrapped by utils.wrapConstructor\");\n  Br(t.outputLen), Br(t.blockLen);\n}\nne.hash = js;\nfunction Hs(t, e = !0) {\n  if (t.destroyed)\n    throw new Error(\"Hash instance has been destroyed\");\n  if (e && t.finished)\n    throw new Error(\"Hash#digest() has already been called\");\n}\nne.exists = Hs;\nfunction Ms(t, e) {\n  ei(t);\n  const r = e.outputLen;\n  if (t.length < r)\n    throw new Error(`digestInto() expects output buffer of length at least ${r}`);\n}\nne.output = Ms;\nconst Fu = {\n  number: Br,\n  bool: Us,\n  bytes: ei,\n  hash: js,\n  exists: Hs,\n  output: Ms\n};\nne.default = Fu;\nvar Ds = {}, ti = {};\nconst Sr = typeof globalThis == \"object\" && \"crypto\" in globalThis ? globalThis.crypto : void 0, Ku = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  crypto: Sr\n}, Symbol.toStringTag, { value: \"Module\" })), Wu = /* @__PURE__ */ Et(Ku);\n(function(t) {\n  /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n  Object.defineProperty(t, \"__esModule\", { value: !0 }), t.randomBytes = t.wrapXOFConstructorWithOpts = t.wrapConstructorWithOpts = t.wrapConstructor = t.checkOpts = t.Hash = t.concatBytes = t.toBytes = t.utf8ToBytes = t.asyncLoop = t.nextTick = t.hexToBytes = t.bytesToHex = t.isLE = t.rotr = t.createView = t.u32 = t.u8 = void 0;\n  const e = Wu, r = (w) => w instanceof Uint8Array, n = (w) => new Uint8Array(w.buffer, w.byteOffset, w.byteLength);\n  t.u8 = n;\n  const i = (w) => new Uint32Array(w.buffer, w.byteOffset, Math.floor(w.byteLength / 4));\n  t.u32 = i;\n  const s = (w) => new DataView(w.buffer, w.byteOffset, w.byteLength);\n  t.createView = s;\n  const o = (w, x) => w << 32 - x | w >>> x;\n  if (t.rotr = o, t.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68, !t.isLE)\n    throw new Error(\"Non little-endian hardware is not supported\");\n  const a = Array.from({ length: 256 }, (w, x) => x.toString(16).padStart(2, \"0\"));\n  function c(w) {\n    if (!r(w))\n      throw new Error(\"Uint8Array expected\");\n    let x = \"\";\n    for (let A = 0; A < w.length; A++)\n      x += a[w[A]];\n    return x;\n  }\n  t.bytesToHex = c;\n  function l(w) {\n    if (typeof w != \"string\")\n      throw new Error(\"hex string expected, got \" + typeof w);\n    const x = w.length;\n    if (x % 2)\n      throw new Error(\"padded hex string expected, got unpadded hex of length \" + x);\n    const A = new Uint8Array(x / 2);\n    for (let B = 0; B < A.length; B++) {\n      const L = B * 2, P = w.slice(L, L + 2), F = Number.parseInt(P, 16);\n      if (Number.isNaN(F) || F < 0)\n        throw new Error(\"Invalid byte sequence\");\n      A[B] = F;\n    }\n    return A;\n  }\n  t.hexToBytes = l;\n  const f = async () => {\n  };\n  t.nextTick = f;\n  async function u(w, x, A) {\n    let B = Date.now();\n    for (let L = 0; L < w; L++) {\n      A(L);\n      const P = Date.now() - B;\n      P >= 0 && P < x || (await (0, t.nextTick)(), B += P);\n    }\n  }\n  t.asyncLoop = u;\n  function h(w) {\n    if (typeof w != \"string\")\n      throw new Error(`utf8ToBytes expected string, got ${typeof w}`);\n    return new Uint8Array(new TextEncoder().encode(w));\n  }\n  t.utf8ToBytes = h;\n  function d(w) {\n    if (typeof w == \"string\" && (w = h(w)), !r(w))\n      throw new Error(`expected Uint8Array, got ${typeof w}`);\n    return w;\n  }\n  t.toBytes = d;\n  function p(...w) {\n    const x = new Uint8Array(w.reduce((B, L) => B + L.length, 0));\n    let A = 0;\n    return w.forEach((B) => {\n      if (!r(B))\n        throw new Error(\"Uint8Array expected\");\n      x.set(B, A), A += B.length;\n    }), x;\n  }\n  t.concatBytes = p;\n  class y {\n    clone() {\n      return this._cloneInto();\n    }\n  }\n  t.Hash = y;\n  const g = (w) => Object.prototype.toString.call(w) === \"[object Object]\" && w.constructor === Object;\n  function v(w, x) {\n    if (x !== void 0 && (typeof x != \"object\" || !g(x)))\n      throw new Error(\"Options should be object or undefined\");\n    return Object.assign(w, x);\n  }\n  t.checkOpts = v;\n  function _(w) {\n    const x = (B) => w().update(d(B)).digest(), A = w();\n    return x.outputLen = A.outputLen, x.blockLen = A.blockLen, x.create = () => w(), x;\n  }\n  t.wrapConstructor = _;\n  function m(w) {\n    const x = (B, L) => w(L).update(d(B)).digest(), A = w({});\n    return x.outputLen = A.outputLen, x.blockLen = A.blockLen, x.create = (B) => w(B), x;\n  }\n  t.wrapConstructorWithOpts = m;\n  function C(w) {\n    const x = (B, L) => w(L).update(d(B)).digest(), A = w({});\n    return x.outputLen = A.outputLen, x.blockLen = A.blockLen, x.create = (B) => w(B), x;\n  }\n  t.wrapXOFConstructorWithOpts = C;\n  function O(w = 32) {\n    if (e.crypto && typeof e.crypto.getRandomValues == \"function\")\n      return e.crypto.getRandomValues(new Uint8Array(w));\n    throw new Error(\"crypto.getRandomValues must be defined\");\n  }\n  t.randomBytes = O;\n})(ti);\n(function(t) {\n  Object.defineProperty(t, \"__esModule\", { value: !0 }), t.hmac = t.HMAC = void 0;\n  const e = ne, r = ti;\n  class n extends r.Hash {\n    constructor(o, a) {\n      super(), this.finished = !1, this.destroyed = !1, e.default.hash(o);\n      const c = (0, r.toBytes)(a);\n      if (this.iHash = o.create(), typeof this.iHash.update != \"function\")\n        throw new Error(\"Expected instance of class which extends utils.Hash\");\n      this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;\n      const l = this.blockLen, f = new Uint8Array(l);\n      f.set(c.length > l ? o.create().update(c).digest() : c);\n      for (let u = 0; u < f.length; u++)\n        f[u] ^= 54;\n      this.iHash.update(f), this.oHash = o.create();\n      for (let u = 0; u < f.length; u++)\n        f[u] ^= 106;\n      this.oHash.update(f), f.fill(0);\n    }\n    update(o) {\n      return e.default.exists(this), this.iHash.update(o), this;\n    }\n    digestInto(o) {\n      e.default.exists(this), e.default.bytes(o, this.outputLen), this.finished = !0, this.iHash.digestInto(o), this.oHash.update(o), this.oHash.digestInto(o), this.destroy();\n    }\n    digest() {\n      const o = new Uint8Array(this.oHash.outputLen);\n      return this.digestInto(o), o;\n    }\n    _cloneInto(o) {\n      o || (o = Object.create(Object.getPrototypeOf(this), {}));\n      const { oHash: a, iHash: c, finished: l, destroyed: f, blockLen: u, outputLen: h } = this;\n      return o = o, o.finished = l, o.destroyed = f, o.blockLen = u, o.outputLen = h, o.oHash = a._cloneInto(o.oHash), o.iHash = c._cloneInto(o.iHash), o;\n    }\n    destroy() {\n      this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();\n    }\n  }\n  t.HMAC = n;\n  const i = (s, o, a) => new n(s, o).update(a).digest();\n  t.hmac = i, t.hmac.create = (s, o) => new n(s, o);\n})(Ds);\nObject.defineProperty(xt, \"__esModule\", { value: !0 });\nxt.pbkdf2Async = xt.pbkdf2 = void 0;\nconst hr = ne, Vu = Ds, bt = ti;\nfunction zs(t, e, r, n) {\n  hr.default.hash(t);\n  const i = (0, bt.checkOpts)({ dkLen: 32, asyncTick: 10 }, n), { c: s, dkLen: o, asyncTick: a } = i;\n  if (hr.default.number(s), hr.default.number(o), hr.default.number(a), s < 1)\n    throw new Error(\"PBKDF2: iterations (c) should be >= 1\");\n  const c = (0, bt.toBytes)(e), l = (0, bt.toBytes)(r), f = new Uint8Array(o), u = Vu.hmac.create(t, c), h = u._cloneInto().update(l);\n  return { c: s, dkLen: o, asyncTick: a, DK: f, PRF: u, PRFSalt: h };\n}\nfunction Fs(t, e, r, n, i) {\n  return t.destroy(), e.destroy(), n && n.destroy(), i.fill(0), r;\n}\nfunction Gu(t, e, r, n) {\n  const { c: i, dkLen: s, DK: o, PRF: a, PRFSalt: c } = zs(t, e, r, n);\n  let l;\n  const f = new Uint8Array(4), u = (0, bt.createView)(f), h = new Uint8Array(a.outputLen);\n  for (let d = 1, p = 0; p < s; d++, p += a.outputLen) {\n    const y = o.subarray(p, p + a.outputLen);\n    u.setInt32(0, d, !1), (l = c._cloneInto(l)).update(f).digestInto(h), y.set(h.subarray(0, y.length));\n    for (let g = 1; g < i; g++) {\n      a._cloneInto(l).update(h).digestInto(h);\n      for (let v = 0; v < y.length; v++)\n        y[v] ^= h[v];\n    }\n  }\n  return Fs(a, c, o, l, h);\n}\nxt.pbkdf2 = Gu;\nasync function Zu(t, e, r, n) {\n  const { c: i, dkLen: s, asyncTick: o, DK: a, PRF: c, PRFSalt: l } = zs(t, e, r, n);\n  let f;\n  const u = new Uint8Array(4), h = (0, bt.createView)(u), d = new Uint8Array(c.outputLen);\n  for (let p = 1, y = 0; y < s; p++, y += c.outputLen) {\n    const g = a.subarray(y, y + c.outputLen);\n    h.setInt32(0, p, !1), (f = l._cloneInto(f)).update(u).digestInto(d), g.set(d.subarray(0, g.length)), await (0, bt.asyncLoop)(i - 1, o, (v) => {\n      c._cloneInto(f).update(d).digestInto(d);\n      for (let _ = 0; _ < g.length; _++)\n        g[_] ^= d[_];\n    });\n  }\n  return Fs(c, l, a, f, d);\n}\nxt.pbkdf2Async = Zu;\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst ri = (t) => t instanceof Uint8Array, Yu = (t) => new Uint8Array(t.buffer, t.byteOffset, t.byteLength), Ju = (t) => new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4)), ft = (t) => new DataView(t.buffer, t.byteOffset, t.byteLength), Ee = (t, e) => t << 32 - e | t >>> e, Ks = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;\nif (!Ks)\n  throw new Error(\"Non little-endian hardware is not supported\");\nconst Xu = Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, \"0\"));\nfunction ni(t) {\n  if (!ri(t))\n    throw new Error(\"Uint8Array expected\");\n  let e = \"\";\n  for (let r = 0; r < t.length; r++)\n    e += Xu[t[r]];\n  return e;\n}\nfunction Ws(t) {\n  if (typeof t != \"string\")\n    throw new Error(\"hex string expected, got \" + typeof t);\n  const e = t.length;\n  if (e % 2)\n    throw new Error(\"padded hex string expected, got unpadded hex of length \" + e);\n  const r = new Uint8Array(e / 2);\n  for (let n = 0; n < r.length; n++) {\n    const i = n * 2, s = t.slice(i, i + 2), o = Number.parseInt(s, 16);\n    if (Number.isNaN(o) || o < 0)\n      throw new Error(\"Invalid byte sequence\");\n    r[n] = o;\n  }\n  return r;\n}\nconst Vs = async () => {\n};\nasync function Qu(t, e, r) {\n  let n = Date.now();\n  for (let i = 0; i < t; i++) {\n    r(i);\n    const s = Date.now() - n;\n    s >= 0 && s < e || (await Vs(), n += s);\n  }\n}\nfunction ii(t) {\n  if (typeof t != \"string\")\n    throw new Error(`utf8ToBytes expected string, got ${typeof t}`);\n  return new Uint8Array(new TextEncoder().encode(t));\n}\nfunction Ot(t) {\n  if (typeof t == \"string\" && (t = ii(t)), !ri(t))\n    throw new Error(`expected Uint8Array, got ${typeof t}`);\n  return t;\n}\nfunction er(...t) {\n  const e = new Uint8Array(t.reduce((n, i) => n + i.length, 0));\n  let r = 0;\n  return t.forEach((n) => {\n    if (!ri(n))\n      throw new Error(\"Uint8Array expected\");\n    e.set(n, r), r += n.length;\n  }), e;\n}\nclass oi {\n  clone() {\n    return this._cloneInto();\n  }\n}\nconst el = (t) => Object.prototype.toString.call(t) === \"[object Object]\" && t.constructor === Object;\nfunction tl(t, e) {\n  if (e !== void 0 && (typeof e != \"object\" || !el(e)))\n    throw new Error(\"Options should be object or undefined\");\n  return Object.assign(t, e);\n}\nfunction nt(t) {\n  const e = (n) => t().update(Ot(n)).digest(), r = t();\n  return e.outputLen = r.outputLen, e.blockLen = r.blockLen, e.create = () => t(), e;\n}\nfunction rl(t) {\n  const e = (n, i) => t(i).update(Ot(n)).digest(), r = t({});\n  return e.outputLen = r.outputLen, e.blockLen = r.blockLen, e.create = (n) => t(n), e;\n}\nfunction nl(t) {\n  const e = (n, i) => t(i).update(Ot(n)).digest(), r = t({});\n  return e.outputLen = r.outputLen, e.blockLen = r.blockLen, e.create = (n) => t(n), e;\n}\nfunction il(t = 32) {\n  if (Sr && typeof Sr.getRandomValues == \"function\")\n    return Sr.getRandomValues(new Uint8Array(t));\n  throw new Error(\"crypto.getRandomValues must be defined\");\n}\nconst ol = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  u8: Yu,\n  u32: Ju,\n  createView: ft,\n  rotr: Ee,\n  isLE: Ks,\n  bytesToHex: ni,\n  hexToBytes: Ws,\n  nextTick: Vs,\n  asyncLoop: Qu,\n  utf8ToBytes: ii,\n  toBytes: Ot,\n  concatBytes: er,\n  Hash: oi,\n  checkOpts: tl,\n  wrapConstructor: nt,\n  wrapConstructorWithOpts: rl,\n  wrapXOFConstructorWithOpts: nl,\n  randomBytes: il\n}, Symbol.toStringTag, { value: \"Module\" }));\nfunction sl(t, e, r, n) {\n  if (typeof t.setBigUint64 == \"function\")\n    return t.setBigUint64(e, r, n);\n  const i = BigInt(32), s = BigInt(4294967295), o = Number(r >> i & s), a = Number(r & s), c = n ? 4 : 0, l = n ? 0 : 4;\n  t.setUint32(e + c, o, n), t.setUint32(e + l, a, n);\n}\nclass si extends oi {\n  constructor(e, r, n, i) {\n    super(), this.blockLen = e, this.outputLen = r, this.padOffset = n, this.isLE = i, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = ft(this.buffer);\n  }\n  update(e) {\n    Qe.exists(this);\n    const { view: r, buffer: n, blockLen: i } = this;\n    e = Ot(e);\n    const s = e.length;\n    for (let o = 0; o < s; ) {\n      const a = Math.min(i - this.pos, s - o);\n      if (a === i) {\n        const c = ft(e);\n        for (; i <= s - o; o += i)\n          this.process(c, o);\n        continue;\n      }\n      n.set(e.subarray(o, o + a), this.pos), this.pos += a, o += a, this.pos === i && (this.process(r, 0), this.pos = 0);\n    }\n    return this.length += e.length, this.roundClean(), this;\n  }\n  digestInto(e) {\n    Qe.exists(this), Qe.output(e, this), this.finished = !0;\n    const { buffer: r, view: n, blockLen: i, isLE: s } = this;\n    let { pos: o } = this;\n    r[o++] = 128, this.buffer.subarray(o).fill(0), this.padOffset > i - o && (this.process(n, 0), o = 0);\n    for (let u = o; u < i; u++)\n      r[u] = 0;\n    sl(n, i - 8, BigInt(this.length * 8), s), this.process(n, 0);\n    const a = ft(e), c = this.outputLen;\n    if (c % 4)\n      throw new Error(\"_sha2: outputLen should be aligned to 32bit\");\n    const l = c / 4, f = this.get();\n    if (l > f.length)\n      throw new Error(\"_sha2: outputLen bigger than state\");\n    for (let u = 0; u < l; u++)\n      a.setUint32(4 * u, f[u], s);\n  }\n  digest() {\n    const { buffer: e, outputLen: r } = this;\n    this.digestInto(e);\n    const n = e.slice(0, r);\n    return this.destroy(), n;\n  }\n  _cloneInto(e) {\n    e || (e = new this.constructor()), e.set(...this.get());\n    const { blockLen: r, buffer: n, length: i, finished: s, destroyed: o, pos: a } = this;\n    return e.length = i, e.pos = a, e.finished = s, e.destroyed = o, i % r && e.buffer.set(n), e;\n  }\n}\nconst al = (t, e, r) => t & e ^ ~t & r, cl = (t, e, r) => t & e ^ t & r ^ e & r, ul = new Uint32Array([\n  1116352408,\n  1899447441,\n  3049323471,\n  3921009573,\n  961987163,\n  1508970993,\n  2453635748,\n  2870763221,\n  3624381080,\n  310598401,\n  607225278,\n  1426881987,\n  1925078388,\n  2162078206,\n  2614888103,\n  3248222580,\n  3835390401,\n  4022224774,\n  264347078,\n  604807628,\n  770255983,\n  1249150122,\n  1555081692,\n  1996064986,\n  2554220882,\n  2821834349,\n  2952996808,\n  3210313671,\n  3336571891,\n  3584528711,\n  113926993,\n  338241895,\n  666307205,\n  773529912,\n  1294757372,\n  1396182291,\n  1695183700,\n  1986661051,\n  2177026350,\n  2456956037,\n  2730485921,\n  2820302411,\n  3259730800,\n  3345764771,\n  3516065817,\n  3600352804,\n  4094571909,\n  275423344,\n  430227734,\n  506948616,\n  659060556,\n  883997877,\n  958139571,\n  1322822218,\n  1537002063,\n  1747873779,\n  1955562222,\n  2024104815,\n  2227730452,\n  2361852424,\n  2428436474,\n  2756734187,\n  3204031479,\n  3329325298\n]), Ke = new Uint32Array([\n  1779033703,\n  3144134277,\n  1013904242,\n  2773480762,\n  1359893119,\n  2600822924,\n  528734635,\n  1541459225\n]), We = new Uint32Array(64);\nclass Gs extends si {\n  constructor() {\n    super(64, 32, 8, !1), this.A = Ke[0] | 0, this.B = Ke[1] | 0, this.C = Ke[2] | 0, this.D = Ke[3] | 0, this.E = Ke[4] | 0, this.F = Ke[5] | 0, this.G = Ke[6] | 0, this.H = Ke[7] | 0;\n  }\n  get() {\n    const { A: e, B: r, C: n, D: i, E: s, F: o, G: a, H: c } = this;\n    return [e, r, n, i, s, o, a, c];\n  }\n  set(e, r, n, i, s, o, a, c) {\n    this.A = e | 0, this.B = r | 0, this.C = n | 0, this.D = i | 0, this.E = s | 0, this.F = o | 0, this.G = a | 0, this.H = c | 0;\n  }\n  process(e, r) {\n    for (let u = 0; u < 16; u++, r += 4)\n      We[u] = e.getUint32(r, !1);\n    for (let u = 16; u < 64; u++) {\n      const h = We[u - 15], d = We[u - 2], p = Ee(h, 7) ^ Ee(h, 18) ^ h >>> 3, y = Ee(d, 17) ^ Ee(d, 19) ^ d >>> 10;\n      We[u] = y + We[u - 7] + p + We[u - 16] | 0;\n    }\n    let { A: n, B: i, C: s, D: o, E: a, F: c, G: l, H: f } = this;\n    for (let u = 0; u < 64; u++) {\n      const h = Ee(a, 6) ^ Ee(a, 11) ^ Ee(a, 25), d = f + h + al(a, c, l) + ul[u] + We[u] | 0, y = (Ee(n, 2) ^ Ee(n, 13) ^ Ee(n, 22)) + cl(n, i, s) | 0;\n      f = l, l = c, c = a, a = o + d | 0, o = s, s = i, i = n, n = d + y | 0;\n    }\n    n = n + this.A | 0, i = i + this.B | 0, s = s + this.C | 0, o = o + this.D | 0, a = a + this.E | 0, c = c + this.F | 0, l = l + this.G | 0, f = f + this.H | 0, this.set(n, i, s, o, a, c, l, f);\n  }\n  roundClean() {\n    We.fill(0);\n  }\n  destroy() {\n    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);\n  }\n}\nclass ll extends Gs {\n  constructor() {\n    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;\n  }\n}\nconst jr = nt(() => new Gs()), fl = nt(() => new ll()), hl = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  sha256: jr,\n  sha224: fl\n}, Symbol.toStringTag, { value: \"Module\" })), dl = /* @__PURE__ */ Et(hl), dr = BigInt(2 ** 32 - 1), $n = BigInt(32);\nfunction Zs(t, e = !1) {\n  return e ? { h: Number(t & dr), l: Number(t >> $n & dr) } : { h: Number(t >> $n & dr) | 0, l: Number(t & dr) | 0 };\n}\nfunction pl(t, e = !1) {\n  let r = new Uint32Array(t.length), n = new Uint32Array(t.length);\n  for (let i = 0; i < t.length; i++) {\n    const { h: s, l: o } = Zs(t[i], e);\n    [r[i], n[i]] = [s, o];\n  }\n  return [r, n];\n}\nconst yl = (t, e) => BigInt(t >>> 0) << $n | BigInt(e >>> 0), gl = (t, e, r) => t >>> r, bl = (t, e, r) => t << 32 - r | e >>> r, vl = (t, e, r) => t >>> r | e << 32 - r, wl = (t, e, r) => t << 32 - r | e >>> r, _l = (t, e, r) => t << 64 - r | e >>> r - 32, ml = (t, e, r) => t >>> r - 32 | e << 64 - r, xl = (t, e) => e, El = (t, e) => t, kl = (t, e, r) => t << r | e >>> 32 - r, Sl = (t, e, r) => e << r | t >>> 32 - r, Ol = (t, e, r) => e << r - 32 | t >>> 64 - r, Al = (t, e, r) => t << r - 32 | e >>> 64 - r;\nfunction Cl(t, e, r, n) {\n  const i = (e >>> 0) + (n >>> 0);\n  return { h: t + r + (i / 2 ** 32 | 0) | 0, l: i | 0 };\n}\nconst Il = (t, e, r) => (t >>> 0) + (e >>> 0) + (r >>> 0), Rl = (t, e, r, n) => e + r + n + (t / 2 ** 32 | 0) | 0, Tl = (t, e, r, n) => (t >>> 0) + (e >>> 0) + (r >>> 0) + (n >>> 0), Pl = (t, e, r, n, i) => e + r + n + i + (t / 2 ** 32 | 0) | 0, Bl = (t, e, r, n, i) => (t >>> 0) + (e >>> 0) + (r >>> 0) + (n >>> 0) + (i >>> 0), Ll = (t, e, r, n, i, s) => e + r + n + i + s + (t / 2 ** 32 | 0) | 0, N = {\n  fromBig: Zs,\n  split: pl,\n  toBig: yl,\n  shrSH: gl,\n  shrSL: bl,\n  rotrSH: vl,\n  rotrSL: wl,\n  rotrBH: _l,\n  rotrBL: ml,\n  rotr32H: xl,\n  rotr32L: El,\n  rotlSH: kl,\n  rotlSL: Sl,\n  rotlBH: Ol,\n  rotlBL: Al,\n  add: Cl,\n  add3L: Il,\n  add3H: Rl,\n  add4L: Tl,\n  add4H: Pl,\n  add5H: Ll,\n  add5L: Bl\n}, [$l, ql] = N.split([\n  \"0x428a2f98d728ae22\",\n  \"0x7137449123ef65cd\",\n  \"0xb5c0fbcfec4d3b2f\",\n  \"0xe9b5dba58189dbbc\",\n  \"0x3956c25bf348b538\",\n  \"0x59f111f1b605d019\",\n  \"0x923f82a4af194f9b\",\n  \"0xab1c5ed5da6d8118\",\n  \"0xd807aa98a3030242\",\n  \"0x12835b0145706fbe\",\n  \"0x243185be4ee4b28c\",\n  \"0x550c7dc3d5ffb4e2\",\n  \"0x72be5d74f27b896f\",\n  \"0x80deb1fe3b1696b1\",\n  \"0x9bdc06a725c71235\",\n  \"0xc19bf174cf692694\",\n  \"0xe49b69c19ef14ad2\",\n  \"0xefbe4786384f25e3\",\n  \"0x0fc19dc68b8cd5b5\",\n  \"0x240ca1cc77ac9c65\",\n  \"0x2de92c6f592b0275\",\n  \"0x4a7484aa6ea6e483\",\n  \"0x5cb0a9dcbd41fbd4\",\n  \"0x76f988da831153b5\",\n  \"0x983e5152ee66dfab\",\n  \"0xa831c66d2db43210\",\n  \"0xb00327c898fb213f\",\n  \"0xbf597fc7beef0ee4\",\n  \"0xc6e00bf33da88fc2\",\n  \"0xd5a79147930aa725\",\n  \"0x06ca6351e003826f\",\n  \"0x142929670a0e6e70\",\n  \"0x27b70a8546d22ffc\",\n  \"0x2e1b21385c26c926\",\n  \"0x4d2c6dfc5ac42aed\",\n  \"0x53380d139d95b3df\",\n  \"0x650a73548baf63de\",\n  \"0x766a0abb3c77b2a8\",\n  \"0x81c2c92e47edaee6\",\n  \"0x92722c851482353b\",\n  \"0xa2bfe8a14cf10364\",\n  \"0xa81a664bbc423001\",\n  \"0xc24b8b70d0f89791\",\n  \"0xc76c51a30654be30\",\n  \"0xd192e819d6ef5218\",\n  \"0xd69906245565a910\",\n  \"0xf40e35855771202a\",\n  \"0x106aa07032bbd1b8\",\n  \"0x19a4c116b8d2d0c8\",\n  \"0x1e376c085141ab53\",\n  \"0x2748774cdf8eeb99\",\n  \"0x34b0bcb5e19b48a8\",\n  \"0x391c0cb3c5c95a63\",\n  \"0x4ed8aa4ae3418acb\",\n  \"0x5b9cca4f7763e373\",\n  \"0x682e6ff3d6b2b8a3\",\n  \"0x748f82ee5defb2fc\",\n  \"0x78a5636f43172f60\",\n  \"0x84c87814a1f0ab72\",\n  \"0x8cc702081a6439ec\",\n  \"0x90befffa23631e28\",\n  \"0xa4506cebde82bde9\",\n  \"0xbef9a3f7b2c67915\",\n  \"0xc67178f2e372532b\",\n  \"0xca273eceea26619c\",\n  \"0xd186b8c721c0c207\",\n  \"0xeada7dd6cde0eb1e\",\n  \"0xf57d4f7fee6ed178\",\n  \"0x06f067aa72176fba\",\n  \"0x0a637dc5a2c898a6\",\n  \"0x113f9804bef90dae\",\n  \"0x1b710b35131c471b\",\n  \"0x28db77f523047d84\",\n  \"0x32caab7b40c72493\",\n  \"0x3c9ebe0a15c9bebc\",\n  \"0x431d67c49c100d4c\",\n  \"0x4cc5d4becb3e42b6\",\n  \"0x597f299cfc657e2a\",\n  \"0x5fcb6fab3ad6faec\",\n  \"0x6c44198c4a475817\"\n].map((t) => BigInt(t))), Ve = new Uint32Array(80), Ge = new Uint32Array(80);\nclass ar extends si {\n  constructor() {\n    super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;\n  }\n  get() {\n    const { Ah: e, Al: r, Bh: n, Bl: i, Ch: s, Cl: o, Dh: a, Dl: c, Eh: l, El: f, Fh: u, Fl: h, Gh: d, Gl: p, Hh: y, Hl: g } = this;\n    return [e, r, n, i, s, o, a, c, l, f, u, h, d, p, y, g];\n  }\n  set(e, r, n, i, s, o, a, c, l, f, u, h, d, p, y, g) {\n    this.Ah = e | 0, this.Al = r | 0, this.Bh = n | 0, this.Bl = i | 0, this.Ch = s | 0, this.Cl = o | 0, this.Dh = a | 0, this.Dl = c | 0, this.Eh = l | 0, this.El = f | 0, this.Fh = u | 0, this.Fl = h | 0, this.Gh = d | 0, this.Gl = p | 0, this.Hh = y | 0, this.Hl = g | 0;\n  }\n  process(e, r) {\n    for (let m = 0; m < 16; m++, r += 4)\n      Ve[m] = e.getUint32(r), Ge[m] = e.getUint32(r += 4);\n    for (let m = 16; m < 80; m++) {\n      const C = Ve[m - 15] | 0, O = Ge[m - 15] | 0, w = N.rotrSH(C, O, 1) ^ N.rotrSH(C, O, 8) ^ N.shrSH(C, O, 7), x = N.rotrSL(C, O, 1) ^ N.rotrSL(C, O, 8) ^ N.shrSL(C, O, 7), A = Ve[m - 2] | 0, B = Ge[m - 2] | 0, L = N.rotrSH(A, B, 19) ^ N.rotrBH(A, B, 61) ^ N.shrSH(A, B, 6), P = N.rotrSL(A, B, 19) ^ N.rotrBL(A, B, 61) ^ N.shrSL(A, B, 6), F = N.add4L(x, P, Ge[m - 7], Ge[m - 16]), z = N.add4H(F, w, L, Ve[m - 7], Ve[m - 16]);\n      Ve[m] = z | 0, Ge[m] = F | 0;\n    }\n    let { Ah: n, Al: i, Bh: s, Bl: o, Ch: a, Cl: c, Dh: l, Dl: f, Eh: u, El: h, Fh: d, Fl: p, Gh: y, Gl: g, Hh: v, Hl: _ } = this;\n    for (let m = 0; m < 80; m++) {\n      const C = N.rotrSH(u, h, 14) ^ N.rotrSH(u, h, 18) ^ N.rotrBH(u, h, 41), O = N.rotrSL(u, h, 14) ^ N.rotrSL(u, h, 18) ^ N.rotrBL(u, h, 41), w = u & d ^ ~u & y, x = h & p ^ ~h & g, A = N.add5L(_, O, x, ql[m], Ge[m]), B = N.add5H(A, v, C, w, $l[m], Ve[m]), L = A | 0, P = N.rotrSH(n, i, 28) ^ N.rotrBH(n, i, 34) ^ N.rotrBH(n, i, 39), F = N.rotrSL(n, i, 28) ^ N.rotrBL(n, i, 34) ^ N.rotrBL(n, i, 39), z = n & s ^ n & a ^ s & a, G = i & o ^ i & c ^ o & c;\n      v = y | 0, _ = g | 0, y = d | 0, g = p | 0, d = u | 0, p = h | 0, { h: u, l: h } = N.add(l | 0, f | 0, B | 0, L | 0), l = a | 0, f = c | 0, a = s | 0, c = o | 0, s = n | 0, o = i | 0;\n      const E = N.add3L(L, F, G);\n      n = N.add3H(E, B, P, z), i = E | 0;\n    }\n    ({ h: n, l: i } = N.add(this.Ah | 0, this.Al | 0, n | 0, i | 0)), { h: s, l: o } = N.add(this.Bh | 0, this.Bl | 0, s | 0, o | 0), { h: a, l: c } = N.add(this.Ch | 0, this.Cl | 0, a | 0, c | 0), { h: l, l: f } = N.add(this.Dh | 0, this.Dl | 0, l | 0, f | 0), { h: u, l: h } = N.add(this.Eh | 0, this.El | 0, u | 0, h | 0), { h: d, l: p } = N.add(this.Fh | 0, this.Fl | 0, d | 0, p | 0), { h: y, l: g } = N.add(this.Gh | 0, this.Gl | 0, y | 0, g | 0), { h: v, l: _ } = N.add(this.Hh | 0, this.Hl | 0, v | 0, _ | 0), this.set(n, i, s, o, a, c, l, f, u, h, d, p, y, g, v, _);\n  }\n  roundClean() {\n    Ve.fill(0), Ge.fill(0);\n  }\n  destroy() {\n    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n  }\n}\nclass Nl extends ar {\n  constructor() {\n    super(), this.Ah = -1942145080, this.Al = 424955298, this.Bh = 1944164710, this.Bl = -1982016298, this.Ch = 502970286, this.Cl = 855612546, this.Dh = 1738396948, this.Dl = 1479516111, this.Eh = 258812777, this.El = 2077511080, this.Fh = 2011393907, this.Fl = 79989058, this.Gh = 1067287976, this.Gl = 1780299464, this.Hh = 286451373, this.Hl = -1848208735, this.outputLen = 28;\n  }\n}\nclass Ul extends ar {\n  constructor() {\n    super(), this.Ah = 573645204, this.Al = -64227540, this.Bh = -1621794909, this.Bl = -934517566, this.Ch = 596883563, this.Cl = 1867755857, this.Dh = -1774684391, this.Dl = 1497426621, this.Eh = -1775747358, this.El = -1467023389, this.Fh = -1101128155, this.Fl = 1401305490, this.Gh = 721525244, this.Gl = 746961066, this.Hh = 246885852, this.Hl = -2117784414, this.outputLen = 32;\n  }\n}\nclass jl extends ar {\n  constructor() {\n    super(), this.Ah = -876896931, this.Al = -1056596264, this.Bh = 1654270250, this.Bl = 914150663, this.Ch = -1856437926, this.Cl = 812702999, this.Dh = 355462360, this.Dl = -150054599, this.Eh = 1731405415, this.El = -4191439, this.Fh = -1900787065, this.Fl = 1750603025, this.Gh = -619958771, this.Gl = 1694076839, this.Hh = 1203062813, this.Hl = -1090891868, this.outputLen = 48;\n  }\n}\nconst qn = nt(() => new ar()), Hl = nt(() => new Nl()), Ml = nt(() => new Ul()), Dl = nt(() => new jl()), zl = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  SHA512: ar,\n  sha512: qn,\n  sha512_224: Hl,\n  sha512_256: Ml,\n  sha384: Dl\n}, Symbol.toStringTag, { value: \"Module\" })), Fl = /* @__PURE__ */ Et(zl), Kl = /* @__PURE__ */ Et(ol), Wl = /* @__PURE__ */ Et(Mu);\nObject.defineProperty(de, \"__esModule\", { value: !0 });\nvar Ys = de.mnemonicToSeedSync = de.mnemonicToSeed = sa = de.validateMnemonic = de.entropyToMnemonic = de.mnemonicToEntropy = ra = de.generateMnemonic = void 0;\n/*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */\nconst Js = zu, Xs = xt, Vl = dl, Qs = Fl, Gl = Kl, pr = Wl, Zl = (t) => t[0] === \"\\u3042\\u3044\\u3053\\u304F\\u3057\\u3093\";\nfunction ea(t) {\n  if (typeof t != \"string\")\n    throw new TypeError(`Invalid mnemonic type: ${typeof t}`);\n  return t.normalize(\"NFKD\");\n}\nfunction ai(t) {\n  const e = ea(t), r = e.split(\" \");\n  if (![12, 15, 18, 21, 24].includes(r.length))\n    throw new Error(\"Invalid mnemonic\");\n  return { nfkd: e, words: r };\n}\nfunction ta(t) {\n  Js.default.bytes(t, 16, 20, 24, 28, 32);\n}\nfunction Yl(t, e = 128) {\n  if (Js.default.number(e), e % 32 !== 0 || e > 256)\n    throw new TypeError(\"Invalid entropy\");\n  return oa((0, Gl.randomBytes)(e / 8), t);\n}\nvar ra = de.generateMnemonic = Yl;\nconst Jl = (t) => {\n  const e = 8 - t.length / 4;\n  return new Uint8Array([(0, Vl.sha256)(t)[0] >> e << e]);\n};\nfunction na(t) {\n  if (!Array.isArray(t) || t.length !== 2048 || typeof t[0] != \"string\")\n    throw new Error(\"Worlist: expected array of 2048 strings\");\n  return t.forEach((e) => {\n    if (typeof e != \"string\")\n      throw new Error(`Wordlist: non-string element: ${e}`);\n  }), pr.utils.chain(pr.utils.checksum(1, Jl), pr.utils.radix2(11, !0), pr.utils.alphabet(t));\n}\nfunction ia(t, e) {\n  const { words: r } = ai(t), n = na(e).decode(r);\n  return ta(n), n;\n}\nde.mnemonicToEntropy = ia;\nfunction oa(t, e) {\n  return ta(t), na(e).encode(t).join(Zl(e) ? \"\\u3000\" : \" \");\n}\nde.entropyToMnemonic = oa;\nfunction Xl(t, e) {\n  try {\n    ia(t, e);\n  } catch {\n    return !1;\n  }\n  return !0;\n}\nvar sa = de.validateMnemonic = Xl;\nconst aa = (t) => ea(`mnemonic${t}`);\nfunction Ql(t, e = \"\") {\n  return (0, Xs.pbkdf2Async)(Qs.sha512, ai(t).nfkd, aa(e), { c: 2048, dkLen: 64 });\n}\nde.mnemonicToSeed = Ql;\nfunction ef(t, e = \"\") {\n  return (0, Xs.pbkdf2)(Qs.sha512, ai(t).nfkd, aa(e), { c: 2048, dkLen: 64 });\n}\nYs = de.mnemonicToSeedSync = ef;\nclass ca extends oi {\n  constructor(e, r) {\n    super(), this.finished = !1, this.destroyed = !1, Qe.hash(e);\n    const n = Ot(r);\n    if (this.iHash = e.create(), typeof this.iHash.update != \"function\")\n      throw new Error(\"Expected instance of class which extends utils.Hash\");\n    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;\n    const i = this.blockLen, s = new Uint8Array(i);\n    s.set(n.length > i ? e.create().update(n).digest() : n);\n    for (let o = 0; o < s.length; o++)\n      s[o] ^= 54;\n    this.iHash.update(s), this.oHash = e.create();\n    for (let o = 0; o < s.length; o++)\n      s[o] ^= 106;\n    this.oHash.update(s), s.fill(0);\n  }\n  update(e) {\n    return Qe.exists(this), this.iHash.update(e), this;\n  }\n  digestInto(e) {\n    Qe.exists(this), Qe.bytes(e, this.outputLen), this.finished = !0, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy();\n  }\n  digest() {\n    const e = new Uint8Array(this.oHash.outputLen);\n    return this.digestInto(e), e;\n  }\n  _cloneInto(e) {\n    e || (e = Object.create(Object.getPrototypeOf(this), {}));\n    const { oHash: r, iHash: n, finished: i, destroyed: s, blockLen: o, outputLen: a } = this;\n    return e = e, e.finished = i, e.destroyed = s, e.blockLen = o, e.outputLen = a, e.oHash = r._cloneInto(e.oHash), e.iHash = n._cloneInto(e.iHash), e;\n  }\n  destroy() {\n    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();\n  }\n}\nconst Nn = (t, e, r) => new ca(t, e).update(r).digest();\nNn.create = (t, e) => new ca(t, e);\nconst tf = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]), ua = Uint8Array.from({ length: 16 }, (t, e) => e), rf = ua.map((t) => (9 * t + 5) % 16);\nlet ci = [ua], ui = [rf];\nfor (let t = 0; t < 4; t++)\n  for (let e of [ci, ui])\n    e.push(e[t].map((r) => tf[r]));\nconst la = [\n  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],\n  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],\n  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],\n  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],\n  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]\n].map((t) => new Uint8Array(t)), nf = ci.map((t, e) => t.map((r) => la[e][r])), of = ui.map((t, e) => t.map((r) => la[e][r])), sf = new Uint32Array([0, 1518500249, 1859775393, 2400959708, 2840853838]), af = new Uint32Array([1352829926, 1548603684, 1836072691, 2053994217, 0]), yr = (t, e) => t << e | t >>> 32 - e;\nfunction Zi(t, e, r, n) {\n  return t === 0 ? e ^ r ^ n : t === 1 ? e & r | ~e & n : t === 2 ? (e | ~r) ^ n : t === 3 ? e & n | r & ~n : e ^ (r | ~n);\n}\nconst gr = new Uint32Array(16);\nclass cf extends si {\n  constructor() {\n    super(64, 20, 8, !0), this.h0 = 1732584193, this.h1 = -271733879, this.h2 = -1732584194, this.h3 = 271733878, this.h4 = -1009589776;\n  }\n  get() {\n    const { h0: e, h1: r, h2: n, h3: i, h4: s } = this;\n    return [e, r, n, i, s];\n  }\n  set(e, r, n, i, s) {\n    this.h0 = e | 0, this.h1 = r | 0, this.h2 = n | 0, this.h3 = i | 0, this.h4 = s | 0;\n  }\n  process(e, r) {\n    for (let d = 0; d < 16; d++, r += 4)\n      gr[d] = e.getUint32(r, !0);\n    let n = this.h0 | 0, i = n, s = this.h1 | 0, o = s, a = this.h2 | 0, c = a, l = this.h3 | 0, f = l, u = this.h4 | 0, h = u;\n    for (let d = 0; d < 5; d++) {\n      const p = 4 - d, y = sf[d], g = af[d], v = ci[d], _ = ui[d], m = nf[d], C = of[d];\n      for (let O = 0; O < 16; O++) {\n        const w = yr(n + Zi(d, s, a, l) + gr[v[O]] + y, m[O]) + u | 0;\n        n = u, u = l, l = yr(a, 10) | 0, a = s, s = w;\n      }\n      for (let O = 0; O < 16; O++) {\n        const w = yr(i + Zi(p, o, c, f) + gr[_[O]] + g, C[O]) + h | 0;\n        i = h, h = f, f = yr(c, 10) | 0, c = o, o = w;\n      }\n    }\n    this.set(this.h1 + a + f | 0, this.h2 + l + h | 0, this.h3 + u + i | 0, this.h4 + n + o | 0, this.h0 + s + c | 0);\n  }\n  roundClean() {\n    gr.fill(0);\n  }\n  destroy() {\n    this.destroyed = !0, this.buffer.fill(0), this.set(0, 0, 0, 0, 0);\n  }\n}\nconst uf = nt(() => new cf()), br = ue.ProjectivePoint, ln = As(jr);\nfunction Yi(t) {\n  return BigInt(`0x${ni(t)}`);\n}\nfunction lf(t) {\n  return Ws(t.toString(16).padStart(64, \"0\"));\n}\nconst ff = ii(\"Bitcoin seed\"), fn = { private: 76066276, public: 76067358 }, hn = 2147483648, hf = (t) => uf(jr(t)), df = (t) => ft(t).getUint32(0, !1), vr = (t) => {\n  if (!Number.isSafeInteger(t) || t < 0 || t > 2 ** 32 - 1)\n    throw new Error(`Invalid number=${t}. Should be from 0 to 2 ** 32 - 1`);\n  const e = new Uint8Array(4);\n  return ft(e).setUint32(0, t, !1), e;\n};\nclass ct {\n  get fingerprint() {\n    if (!this.pubHash)\n      throw new Error(\"No publicKey set!\");\n    return df(this.pubHash);\n  }\n  get identifier() {\n    return this.pubHash;\n  }\n  get pubKeyHash() {\n    return this.pubHash;\n  }\n  get privateKey() {\n    return this.privKeyBytes || null;\n  }\n  get publicKey() {\n    return this.pubKey || null;\n  }\n  get privateExtendedKey() {\n    const e = this.privateKey;\n    if (!e)\n      throw new Error(\"No private key\");\n    return ln.encode(this.serialize(this.versions.private, er(new Uint8Array([0]), e)));\n  }\n  get publicExtendedKey() {\n    if (!this.pubKey)\n      throw new Error(\"No public key\");\n    return ln.encode(this.serialize(this.versions.public, this.pubKey));\n  }\n  static fromMasterSeed(e, r = fn) {\n    if (Ye(e), 8 * e.length < 128 || 8 * e.length > 512)\n      throw new Error(`HDKey: wrong seed length=${e.length}. Should be between 128 and 512 bits; 256 bits is advised)`);\n    const n = Nn(qn, ff, e);\n    return new ct({\n      versions: r,\n      chainCode: n.slice(32),\n      privateKey: n.slice(0, 32)\n    });\n  }\n  static fromExtendedKey(e, r = fn) {\n    const n = ln.decode(e), i = ft(n), s = i.getUint32(0, !1), o = {\n      versions: r,\n      depth: n[4],\n      parentFingerprint: i.getUint32(5, !1),\n      index: i.getUint32(9, !1),\n      chainCode: n.slice(13, 45)\n    }, a = n.slice(45), c = a[0] === 0;\n    if (s !== r[c ? \"private\" : \"public\"])\n      throw new Error(\"Version mismatch\");\n    return c ? new ct({ ...o, privateKey: a.slice(1) }) : new ct({ ...o, publicKey: a });\n  }\n  static fromJSON(e) {\n    return ct.fromExtendedKey(e.xpriv);\n  }\n  constructor(e) {\n    if (this.depth = 0, this.index = 0, this.chainCode = null, this.parentFingerprint = 0, !e || typeof e != \"object\")\n      throw new Error(\"HDKey.constructor must not be called directly\");\n    if (this.versions = e.versions || fn, this.depth = e.depth || 0, this.chainCode = e.chainCode, this.index = e.index || 0, this.parentFingerprint = e.parentFingerprint || 0, !this.depth && (this.parentFingerprint || this.index))\n      throw new Error(\"HDKey: zero depth with non-zero index/parent fingerprint\");\n    if (e.publicKey && e.privateKey)\n      throw new Error(\"HDKey: publicKey and privateKey at same time.\");\n    if (e.privateKey) {\n      if (!ue.utils.isValidPrivateKey(e.privateKey))\n        throw new Error(\"Invalid private key\");\n      this.privKey = typeof e.privateKey == \"bigint\" ? e.privateKey : Yi(e.privateKey), this.privKeyBytes = lf(this.privKey), this.pubKey = ue.getPublicKey(e.privateKey, !0);\n    } else if (e.publicKey)\n      this.pubKey = br.fromHex(e.publicKey).toRawBytes(!0);\n    else\n      throw new Error(\"HDKey: no public or private key provided\");\n    this.pubHash = hf(this.pubKey);\n  }\n  derive(e) {\n    if (!/^[mM]'?/.test(e))\n      throw new Error('Path must start with \"m\" or \"M\"');\n    if (/^[mM]'?$/.test(e))\n      return this;\n    const r = e.replace(/^[mM]'?\\//, \"\").split(\"/\");\n    let n = this;\n    for (const i of r) {\n      const s = /^(\\d+)('?)$/.exec(i);\n      if (!s || s.length !== 3)\n        throw new Error(`Invalid child index: ${i}`);\n      let o = +s[1];\n      if (!Number.isSafeInteger(o) || o >= hn)\n        throw new Error(\"Invalid index\");\n      s[2] === \"'\" && (o += hn), n = n.deriveChild(o);\n    }\n    return n;\n  }\n  deriveChild(e) {\n    if (!this.pubKey || !this.chainCode)\n      throw new Error(\"No publicKey or chainCode set\");\n    let r = vr(e);\n    if (e >= hn) {\n      const a = this.privateKey;\n      if (!a)\n        throw new Error(\"Could not derive hardened child key\");\n      r = er(new Uint8Array([0]), a, r);\n    } else\n      r = er(this.pubKey, r);\n    const n = Nn(qn, this.chainCode, r), i = Yi(n.slice(0, 32)), s = n.slice(32);\n    if (!ue.utils.isValidPrivateKey(i))\n      throw new Error(\"Tweak bigger than curve order\");\n    const o = {\n      versions: this.versions,\n      chainCode: s,\n      depth: this.depth + 1,\n      parentFingerprint: this.fingerprint,\n      index: e\n    };\n    try {\n      if (this.privateKey) {\n        const a = J(this.privKey + i, ue.CURVE.n);\n        if (!ue.utils.isValidPrivateKey(a))\n          throw new Error(\"The tweak was out of range or the resulted private key is invalid\");\n        o.privateKey = a;\n      } else {\n        const a = br.fromHex(this.pubKey).add(br.fromPrivateKey(i));\n        if (a.equals(br.ZERO))\n          throw new Error(\"The tweak was equal to negative P, which made the result key invalid\");\n        o.publicKey = a.toRawBytes(!0);\n      }\n      return new ct(o);\n    } catch {\n      return this.deriveChild(e + 1);\n    }\n  }\n  sign(e) {\n    if (!this.privateKey)\n      throw new Error(\"No privateKey set!\");\n    return Ye(e, 32), ue.sign(e, this.privKey).toCompactRawBytes();\n  }\n  verify(e, r) {\n    if (Ye(e, 32), Ye(r, 64), !this.publicKey)\n      throw new Error(\"No publicKey set!\");\n    let n;\n    try {\n      n = ue.Signature.fromCompact(r);\n    } catch {\n      return !1;\n    }\n    return ue.verify(n, e, this.publicKey);\n  }\n  wipePrivateData() {\n    return this.privKey = void 0, this.privKeyBytes && (this.privKeyBytes.fill(0), this.privKeyBytes = void 0), this;\n  }\n  toJSON() {\n    return {\n      xpriv: this.privateExtendedKey,\n      xpub: this.publicExtendedKey\n    };\n  }\n  serialize(e, r) {\n    if (!this.chainCode)\n      throw new Error(\"No chainCode set\");\n    return Ye(r, 33), er(vr(e), new Uint8Array([this.depth]), vr(this.parentFingerprint), vr(this.index), this.chainCode, r);\n  }\n}\nvar pf = Object.defineProperty, ie = (t, e) => {\n  for (var r in e)\n    pf(t, r, { get: e[r], enumerable: !0 });\n};\nfunction yf() {\n  return ve(St.utils.randomPrivateKey());\n}\nfunction li(t) {\n  return ve(St.getPublicKey(t));\n}\nvar gf = {};\nie(gf, {\n  MessageNode: () => fa,\n  MessageQueue: () => ha,\n  insertEventIntoAscendingList: () => wf,\n  insertEventIntoDescendingList: () => vf,\n  normalizeURL: () => bf,\n  utf8Decoder: () => Je,\n  utf8Encoder: () => Ie\n});\nvar Je = new TextDecoder(\"utf-8\"), Ie = new TextEncoder();\nfunction bf(t) {\n  let e = new URL(t);\n  return e.pathname = e.pathname.replace(/\\/+/g, \"/\"), e.pathname.endsWith(\"/\") && (e.pathname = e.pathname.slice(0, -1)), (e.port === \"80\" && e.protocol === \"ws:\" || e.port === \"443\" && e.protocol === \"wss:\") && (e.port = \"\"), e.searchParams.sort(), e.hash = \"\", e.toString();\n}\nfunction vf(t, e) {\n  var o;\n  let r = 0, n = t.length - 1, i, s = r;\n  if (n < 0)\n    s = 0;\n  else if (e.created_at < t[n].created_at)\n    s = n + 1;\n  else if (e.created_at >= t[r].created_at)\n    s = r;\n  else\n    for (; ; ) {\n      if (n <= r + 1) {\n        s = n;\n        break;\n      }\n      if (i = Math.floor(r + (n - r) / 2), t[i].created_at > e.created_at)\n        r = i;\n      else if (t[i].created_at < e.created_at)\n        n = i;\n      else {\n        s = i;\n        break;\n      }\n    }\n  return ((o = t[s]) == null ? void 0 : o.id) !== e.id ? [\n    ...t.slice(0, s),\n    e,\n    ...t.slice(s)\n  ] : t;\n}\nfunction wf(t, e) {\n  var o;\n  let r = 0, n = t.length - 1, i, s = r;\n  if (n < 0)\n    s = 0;\n  else if (e.created_at > t[n].created_at)\n    s = n + 1;\n  else if (e.created_at <= t[r].created_at)\n    s = r;\n  else\n    for (; ; ) {\n      if (n <= r + 1) {\n        s = n;\n        break;\n      }\n      if (i = Math.floor(r + (n - r) / 2), t[i].created_at < e.created_at)\n        r = i;\n      else if (t[i].created_at > e.created_at)\n        n = i;\n      else {\n        s = i;\n        break;\n      }\n    }\n  return ((o = t[s]) == null ? void 0 : o.id) !== e.id ? [\n    ...t.slice(0, s),\n    e,\n    ...t.slice(s)\n  ] : t;\n}\nvar fa = class {\n  constructor(t) {\n    I(this, \"_value\");\n    I(this, \"_next\");\n    this._value = t, this._next = null;\n  }\n  get value() {\n    return this._value;\n  }\n  set value(t) {\n    this._value = t;\n  }\n  get next() {\n    return this._next;\n  }\n  set next(t) {\n    this._next = t;\n  }\n}, ha = class {\n  constructor() {\n    I(this, \"_first\");\n    I(this, \"_last\");\n    I(this, \"_size\");\n    this._first = null, this._last = null, this._size = 0;\n  }\n  get first() {\n    return this._first;\n  }\n  set first(t) {\n    this._first = t;\n  }\n  get last() {\n    return this._last;\n  }\n  set last(t) {\n    this._last = t;\n  }\n  get size() {\n    return this._size;\n  }\n  set size(t) {\n    this._size = t;\n  }\n  enqueue(t) {\n    const e = new fa(t);\n    return this._size === 0 || !this._last ? (this._first = e, this._last = e) : (this._last.next = e, this._last = e), this._size++, !0;\n  }\n  dequeue() {\n    if (this._size === 0 || !this._first)\n      return null;\n    let t = this._first;\n    return this._first = t.next, t.next = null, this._size--, t.value;\n  }\n};\nfunction da(t, e) {\n  let r = t;\n  return r.pubkey = li(e), r.id = Hr(r), r.sig = pa(r, e), r;\n}\nfunction _f(t) {\n  if (!fi(t))\n    throw new Error(\"can't serialize event with wrong or missing properties\");\n  return JSON.stringify([\n    0,\n    t.pubkey,\n    t.created_at,\n    t.kind,\n    t.tags,\n    t.content\n  ]);\n}\nfunction Hr(t) {\n  let e = Yn(Ie.encode(_f(t)));\n  return ve(e);\n}\nvar mf = (t) => t instanceof Object;\nfunction fi(t) {\n  if (!mf(t) || typeof t.kind != \"number\" || typeof t.content != \"string\" || typeof t.created_at != \"number\" || typeof t.pubkey != \"string\" || !t.pubkey.match(/^[a-f0-9]{64}$/) || !Array.isArray(t.tags))\n    return !1;\n  for (let e = 0; e < t.tags.length; e++) {\n    let r = t.tags[e];\n    if (!Array.isArray(r))\n      return !1;\n    for (let n = 0; n < r.length; n++)\n      if (typeof r[n] == \"object\")\n        return !1;\n  }\n  return !0;\n}\nfunction hi(t) {\n  try {\n    return St.verify(t.sig, Hr(t), t.pubkey);\n  } catch {\n    return !1;\n  }\n}\nfunction pa(t, e) {\n  return ve(St.sign(Hr(t), e));\n}\nfunction ya(t, e) {\n  if (t.ids && t.ids.indexOf(e.id) === -1 && !t.ids.some((r) => e.id.startsWith(r)) || t.kinds && t.kinds.indexOf(e.kind) === -1 || t.authors && t.authors.indexOf(e.pubkey) === -1 && !t.authors.some((r) => e.pubkey.startsWith(r)))\n    return !1;\n  for (let r in t)\n    if (r[0] === \"#\") {\n      let n = r.slice(1), i = t[`#${n}`];\n      if (i && !e.tags.find(\n        ([s, o]) => s === r.slice(1) && i.indexOf(o) !== -1\n      ))\n        return !1;\n    }\n  return !(t.since && e.created_at < t.since || t.until && e.created_at >= t.until);\n}\nfunction xf(t, e) {\n  for (let r = 0; r < t.length; r++)\n    if (ya(t[r], e))\n      return !0;\n  return !1;\n}\nvar Ef = {};\nie(Ef, {\n  getHex64: () => Mr,\n  getInt: () => ga,\n  getSubscriptionId: () => ba,\n  matchEventId: () => kf,\n  matchEventKind: () => Of,\n  matchEventPubkey: () => Sf\n});\nfunction Mr(t, e) {\n  let r = e.length + 3, n = t.indexOf(`\"${e}\":`) + r, i = t.slice(n).indexOf('\"') + n + 1;\n  return t.slice(i, i + 64);\n}\nfunction ga(t, e) {\n  let r = e.length, n = t.indexOf(`\"${e}\":`) + r + 3, i = t.slice(n), s = Math.min(i.indexOf(\",\"), i.indexOf(\"}\"));\n  return parseInt(i.slice(0, s), 10);\n}\nfunction ba(t) {\n  let e = t.slice(0, 22).indexOf('\"EVENT\"');\n  if (e === -1)\n    return null;\n  let r = t.slice(e + 7 + 1).indexOf('\"');\n  if (r === -1)\n    return null;\n  let n = e + 7 + 1 + r, i = t.slice(n + 1, 80).indexOf('\"');\n  if (i === -1)\n    return null;\n  let s = n + 1 + i;\n  return t.slice(n + 1, s);\n}\nfunction kf(t, e) {\n  return e === Mr(t, \"id\");\n}\nfunction Sf(t, e) {\n  return e === Mr(t, \"pubkey\");\n}\nfunction Of(t, e) {\n  return e === ga(t, \"kind\");\n}\nvar Ji = () => ({\n  connect: [],\n  disconnect: [],\n  error: [],\n  notice: [],\n  auth: []\n});\nfunction Af(t, e = {}) {\n  let { listTimeout: r = 3e3, getTimeout: n = 3e3, countTimeout: i = 3e3 } = e;\n  var s, o = {}, a = Ji(), c = {}, l = {}, f;\n  async function u() {\n    return f || (f = new Promise((v, _) => {\n      try {\n        s = new WebSocket(t);\n      } catch (w) {\n        _(w);\n      }\n      s.onopen = () => {\n        a.connect.forEach((w) => w()), v();\n      }, s.onerror = () => {\n        f = void 0, a.error.forEach((w) => w()), _();\n      }, s.onclose = async () => {\n        f = void 0, a.disconnect.forEach((w) => w());\n      };\n      let m = new ha(), C;\n      s.onmessage = (w) => {\n        m.enqueue(w.data), C || (C = setInterval(O, 0));\n      };\n      function O() {\n        var A, B, L;\n        if (m.size === 0) {\n          clearInterval(C), C = null;\n          return;\n        }\n        var w = m.dequeue();\n        if (!w)\n          return;\n        let x = ba(w);\n        if (x) {\n          let P = o[x];\n          if (P && P.alreadyHaveEvent && P.alreadyHaveEvent(Mr(w, \"id\"), t))\n            return;\n        }\n        try {\n          let P = JSON.parse(w);\n          switch (P[0]) {\n            case \"EVENT\": {\n              let E = P[1], R = P[2];\n              fi(R) && o[E] && (o[E].skipVerification || hi(R)) && xf(o[E].filters, R) && (o[E], (((A = c[E]) == null ? void 0 : A.event) || []).forEach((q) => q(R)));\n              return;\n            }\n            case \"COUNT\":\n              let F = P[1], z = P[2];\n              o[F] && (((B = c[F]) == null ? void 0 : B.count) || []).forEach((E) => E(z));\n              return;\n            case \"EOSE\": {\n              let E = P[1];\n              E in c && (c[E].eose.forEach((R) => R()), c[E].eose = []);\n              return;\n            }\n            case \"OK\": {\n              let E = P[1], R = P[2], q = P[3] || \"\";\n              E in l && (R ? l[E].ok.forEach((H) => H()) : l[E].failed.forEach((H) => H(q)), l[E].ok = [], l[E].failed = []);\n              return;\n            }\n            case \"NOTICE\":\n              let G = P[1];\n              a.notice.forEach((E) => E(G));\n              return;\n            case \"AUTH\": {\n              let E = P[1];\n              (L = a.auth) == null || L.forEach((R) => R(E));\n              return;\n            }\n          }\n        } catch {\n          return;\n        }\n      }\n    }), f);\n  }\n  function h() {\n    return (s == null ? void 0 : s.readyState) === 1;\n  }\n  async function d() {\n    h() || await u();\n  }\n  async function p(v) {\n    let _ = JSON.stringify(v);\n    if (!(!h() && (await new Promise((m) => setTimeout(m, 1e3)), !h())))\n      try {\n        s.send(_);\n      } catch (m) {\n        console.log(m);\n      }\n  }\n  const y = (v, {\n    verb: _ = \"REQ\",\n    skipVerification: m = !1,\n    alreadyHaveEvent: C = null,\n    id: O = Math.random().toString().slice(2)\n  } = {}) => {\n    let w = O;\n    return o[w] = {\n      id: w,\n      filters: v,\n      skipVerification: m,\n      alreadyHaveEvent: C\n    }, p([_, w, ...v]), {\n      sub: (x, A = {}) => y(x || v, {\n        skipVerification: A.skipVerification || m,\n        alreadyHaveEvent: A.alreadyHaveEvent || C,\n        id: w\n      }),\n      unsub: () => {\n        delete o[w], delete c[w], p([\"CLOSE\", w]);\n      },\n      on: (x, A) => {\n        c[w] = c[w] || {\n          event: [],\n          count: [],\n          eose: []\n        }, c[w][x].push(A);\n      },\n      off: (x, A) => {\n        let B = c[w], L = B[x].indexOf(A);\n        L >= 0 && B[x].splice(L, 1);\n      }\n    };\n  };\n  function g(v, _) {\n    if (!v.id)\n      throw new Error(`event ${v} has no id`);\n    let m = v.id;\n    return p([_, v]), {\n      on: (C, O) => {\n        l[m] = l[m] || {\n          ok: [],\n          failed: []\n        }, l[m][C].push(O);\n      },\n      off: (C, O) => {\n        let w = l[m];\n        if (!w)\n          return;\n        let x = w[C].indexOf(O);\n        x >= 0 && w[C].splice(x, 1);\n      }\n    };\n  }\n  return {\n    url: t,\n    sub: y,\n    on: (v, _) => {\n      a[v].push(_), v === \"connect\" && (s == null ? void 0 : s.readyState) === 1 && _();\n    },\n    off: (v, _) => {\n      let m = a[v].indexOf(_);\n      m !== -1 && a[v].splice(m, 1);\n    },\n    list: (v, _) => new Promise((m) => {\n      let C = y(v, _), O = [], w = setTimeout(() => {\n        C.unsub(), m(O);\n      }, r);\n      C.on(\"eose\", () => {\n        C.unsub(), clearTimeout(w), m(O);\n      }), C.on(\"event\", (x) => {\n        O.push(x);\n      });\n    }),\n    get: (v, _) => new Promise((m) => {\n      let C = y([v], _), O = setTimeout(() => {\n        C.unsub(), m(null);\n      }, n);\n      C.on(\"event\", (w) => {\n        C.unsub(), clearTimeout(O), m(w);\n      });\n    }),\n    count: (v) => new Promise((_) => {\n      let m = y(v, { ...y, verb: \"COUNT\" }), C = setTimeout(() => {\n        m.unsub(), _(null);\n      }, i);\n      m.on(\"count\", (O) => {\n        m.unsub(), clearTimeout(C), _(O);\n      });\n    }),\n    publish(v) {\n      return g(v, \"EVENT\");\n    },\n    auth(v) {\n      return g(v, \"AUTH\");\n    },\n    connect: d,\n    close() {\n      a = Ji(), c = {}, l = {}, s.readyState === WebSocket.OPEN && (s == null || s.close());\n    },\n    get status() {\n      var v;\n      return (v = s == null ? void 0 : s.readyState) != null ? v : 3;\n    }\n  };\n}\nvar we = {};\nie(we, {\n  BECH32_REGEX: () => va,\n  decode: () => Dr,\n  naddrEncode: () => Bf,\n  neventEncode: () => Pf,\n  noteEncode: () => Rf,\n  nprofileEncode: () => Tf,\n  npubEncode: () => If,\n  nrelayEncode: () => Lf,\n  nsecEncode: () => Cf\n});\nvar At = 5e3, va = /[\\x21-\\x7E]{1,83}1[023456789acdefghjklmnpqrstuvwxyz]{6,}/;\nfunction Dr(t) {\n  var i, s, o, a, c, l, f;\n  let { prefix: e, words: r } = te.decode(t, At), n = new Uint8Array(te.fromWords(r));\n  switch (e) {\n    case \"nprofile\": {\n      let u = wr(n);\n      if (!((i = u[0]) != null && i[0]))\n        throw new Error(\"missing TLV 0 for nprofile\");\n      if (u[0][0].length !== 32)\n        throw new Error(\"TLV 0 should be 32 bytes\");\n      return {\n        type: \"nprofile\",\n        data: {\n          pubkey: ve(u[0][0]),\n          relays: u[1] ? u[1].map((h) => Je.decode(h)) : []\n        }\n      };\n    }\n    case \"nevent\": {\n      let u = wr(n);\n      if (!((s = u[0]) != null && s[0]))\n        throw new Error(\"missing TLV 0 for nevent\");\n      if (u[0][0].length !== 32)\n        throw new Error(\"TLV 0 should be 32 bytes\");\n      if (u[2] && u[2][0].length !== 32)\n        throw new Error(\"TLV 2 should be 32 bytes\");\n      return {\n        type: \"nevent\",\n        data: {\n          id: ve(u[0][0]),\n          relays: u[1] ? u[1].map((h) => Je.decode(h)) : [],\n          author: (o = u[2]) != null && o[0] ? ve(u[2][0]) : void 0\n        }\n      };\n    }\n    case \"naddr\": {\n      let u = wr(n);\n      if (!((a = u[0]) != null && a[0]))\n        throw new Error(\"missing TLV 0 for naddr\");\n      if (!((c = u[2]) != null && c[0]))\n        throw new Error(\"missing TLV 2 for naddr\");\n      if (u[2][0].length !== 32)\n        throw new Error(\"TLV 2 should be 32 bytes\");\n      if (!((l = u[3]) != null && l[0]))\n        throw new Error(\"missing TLV 3 for naddr\");\n      if (u[3][0].length !== 4)\n        throw new Error(\"TLV 3 should be 4 bytes\");\n      return {\n        type: \"naddr\",\n        data: {\n          identifier: Je.decode(u[0][0]),\n          pubkey: ve(u[2][0]),\n          kind: parseInt(ve(u[3][0]), 16),\n          relays: u[1] ? u[1].map((h) => Je.decode(h)) : []\n        }\n      };\n    }\n    case \"nrelay\": {\n      let u = wr(n);\n      if (!((f = u[0]) != null && f[0]))\n        throw new Error(\"missing TLV 0 for nrelay\");\n      return {\n        type: \"nrelay\",\n        data: Je.decode(u[0][0])\n      };\n    }\n    case \"nsec\":\n    case \"npub\":\n    case \"note\":\n      return { type: e, data: ve(n) };\n    default:\n      throw new Error(`unknown prefix ${e}`);\n  }\n}\nfunction wr(t) {\n  let e = {}, r = t;\n  for (; r.length > 0; ) {\n    let n = r[0], i = r[1];\n    if (!i)\n      throw new Error(`malformed TLV ${n}`);\n    let s = r.slice(2, 2 + i);\n    if (r = r.slice(2 + i), s.length < i)\n      throw new Error(`not enough data to read on TLV ${n}`);\n    e[n] = e[n] || [], e[n].push(s);\n  }\n  return e;\n}\nfunction Cf(t) {\n  return di(\"nsec\", t);\n}\nfunction If(t) {\n  return di(\"npub\", t);\n}\nfunction Rf(t) {\n  return di(\"note\", t);\n}\nfunction di(t, e) {\n  let r = _t(e), n = te.toWords(r);\n  return te.encode(t, n, At);\n}\nfunction Tf(t) {\n  let e = zr({\n    0: [_t(t.pubkey)],\n    1: (t.relays || []).map((n) => Ie.encode(n))\n  }), r = te.toWords(e);\n  return te.encode(\"nprofile\", r, At);\n}\nfunction Pf(t) {\n  let e = zr({\n    0: [_t(t.id)],\n    1: (t.relays || []).map((n) => Ie.encode(n)),\n    2: t.author ? [_t(t.author)] : []\n  }), r = te.toWords(e);\n  return te.encode(\"nevent\", r, At);\n}\nfunction Bf(t) {\n  let e = new ArrayBuffer(4);\n  new DataView(e).setUint32(0, t.kind, !1);\n  let r = zr({\n    0: [Ie.encode(t.identifier)],\n    1: (t.relays || []).map((i) => Ie.encode(i)),\n    2: [_t(t.pubkey)],\n    3: [new Uint8Array(e)]\n  }), n = te.toWords(r);\n  return te.encode(\"naddr\", n, At);\n}\nfunction Lf(t) {\n  let e = zr({\n    0: [Ie.encode(t)]\n  }), r = te.toWords(e);\n  return te.encode(\"nrelay\", r, At);\n}\nfunction zr(t) {\n  let e = [];\n  return Object.entries(t).forEach(([r, n]) => {\n    n.forEach((i) => {\n      let s = new Uint8Array(i.length + 2);\n      s.set([parseInt(r)], 0), s.set([i.length], 1), s.set(i, 2), e.push(s);\n    });\n  }), _u(...e);\n}\nvar Un = {};\nie(Un, {\n  decrypt: () => qf,\n  encrypt: () => $f\n});\ntypeof crypto < \"u\" && !crypto.subtle && crypto.webcrypto && (crypto.subtle = crypto.webcrypto.subtle);\nasync function $f(t, e, r) {\n  const n = ue.getSharedSecret(t, \"02\" + e), i = wa(n);\n  let s = Uint8Array.from(xu(16)), o = Ie.encode(r), a = await crypto.subtle.importKey(\n    \"raw\",\n    i,\n    { name: \"AES-CBC\" },\n    !1,\n    [\"encrypt\"]\n  ), c = await crypto.subtle.encrypt(\n    { name: \"AES-CBC\", iv: s },\n    a,\n    o\n  ), l = mt.encode(new Uint8Array(c)), f = mt.encode(new Uint8Array(s.buffer));\n  return `${l}?iv=${f}`;\n}\nasync function qf(t, e, r) {\n  let [n, i] = r.split(\"?iv=\"), s = ue.getSharedSecret(t, \"02\" + e), o = wa(s), a = await crypto.subtle.importKey(\n    \"raw\",\n    o,\n    { name: \"AES-CBC\" },\n    !1,\n    [\"decrypt\"]\n  ), c = mt.decode(n), l = mt.decode(i), f = await crypto.subtle.decrypt(\n    { name: \"AES-CBC\", iv: l },\n    a,\n    c\n  );\n  return Je.decode(f);\n}\nfunction wa(t) {\n  return t.slice(1, 33);\n}\nvar _a = {};\nie(_a, {\n  NIP05_REGEX: () => ma,\n  queryProfile: () => jf,\n  searchDomain: () => Uf,\n  useFetchImplementation: () => Nf\n});\nvar ma = /^(?:([\\w.+-]+)@)?([\\w.-]+)$/, Fr;\ntry {\n  Fr = fetch;\n} catch {\n}\nfunction Nf(t) {\n  Fr = t;\n}\nasync function Uf(t, e = \"\") {\n  try {\n    return (await (await Fr(`https://${t}/.well-known/nostr.json?name=${e}`)).json()).names;\n  } catch {\n    return {};\n  }\n}\nasync function jf(t) {\n  const e = t.match(ma);\n  if (!e)\n    return null;\n  const [r, n = \"_\", i] = e;\n  try {\n    const s = await Fr(`https://${i}/.well-known/nostr.json?name=${n}`), { names: o, relays: a } = Hf(await s.json()), c = o[n];\n    return c ? { pubkey: c, relays: a == null ? void 0 : a[c] } : null;\n  } catch {\n    return null;\n  }\n}\nfunction Hf(t) {\n  const e = {\n    names: {}\n  };\n  for (const [r, n] of Object.entries(t.names))\n    typeof r == \"string\" && typeof n == \"string\" && (e.names[r] = n);\n  if (t.relays) {\n    e.relays = {};\n    for (const [r, n] of Object.entries(t.relays))\n      typeof r == \"string\" && Array.isArray(n) && (e.relays[r] = n.filter((i) => typeof i == \"string\"));\n  }\n  return e;\n}\nvar Mf = {};\nie(Mf, {\n  generateSeedWords: () => zf,\n  privateKeyFromSeedWords: () => Df,\n  validateWords: () => Ff\n});\nfunction Df(t, e) {\n  let n = ct.fromMasterSeed(Ys(t, e)).derive(\"m/44'/1237'/0'/0/0\").privateKey;\n  if (!n)\n    throw new Error(\"could not derive private key\");\n  return ve(n);\n}\nfunction zf() {\n  return ra(Qn);\n}\nfunction Ff(t) {\n  return sa(t, Qn);\n}\nvar Kf = {};\nie(Kf, {\n  parse: () => Wf\n});\nfunction Wf(t) {\n  const e = {\n    reply: void 0,\n    root: void 0,\n    mentions: [],\n    profiles: []\n  }, r = [];\n  for (const n of t.tags)\n    n[0] === \"e\" && n[1] && r.push(n), n[0] === \"p\" && n[1] && e.profiles.push({\n      pubkey: n[1],\n      relays: n[2] ? [n[2]] : []\n    });\n  for (let n = 0; n < r.length; n++) {\n    const i = r[n], [s, o, a, c] = i, l = {\n      id: o,\n      relays: a ? [a] : []\n    }, f = n === 0, u = n === r.length - 1;\n    if (c === \"root\") {\n      e.root = l;\n      continue;\n    }\n    if (c === \"reply\") {\n      e.reply = l;\n      continue;\n    }\n    if (c === \"mention\") {\n      e.mentions.push(l);\n      continue;\n    }\n    if (f) {\n      e.root = l;\n      continue;\n    }\n    if (u) {\n      e.reply = l;\n      continue;\n    }\n    e.mentions.push(l);\n  }\n  return e;\n}\nvar Vf = {};\nie(Vf, {\n  getPow: () => Gf\n});\nfunction Gf(t) {\n  return Zf(_t(t));\n}\nfunction Zf(t) {\n  let e, r, n;\n  for (r = 0, e = 0; r < t.length && (n = Yf(t[r]), e += n, n === 8); r++)\n    ;\n  return e;\n}\nfunction Yf(t) {\n  let e = 0;\n  if (t === 0)\n    return 8;\n  for (; t >>= 1; )\n    e++;\n  return 7 - e;\n}\nvar Jf = {};\nie(Jf, {\n  finishRepostEvent: () => Xf,\n  getRepostedEvent: () => Qf,\n  getRepostedEventPointer: () => xa\n});\nfunction Xf(t, e, r, n) {\n  var i;\n  return da({\n    kind: 6,\n    tags: [\n      ...(i = t.tags) != null ? i : [],\n      [\"e\", e.id, r],\n      [\"p\", e.pubkey]\n    ],\n    content: t.content === \"\" ? \"\" : JSON.stringify(e),\n    created_at: t.created_at\n  }, n);\n}\nfunction xa(t) {\n  if (t.kind !== 6)\n    return;\n  let e, r;\n  for (let n = t.tags.length - 1; n >= 0 && (e === void 0 || r === void 0); n--) {\n    const i = t.tags[n];\n    i.length >= 2 && (i[0] === \"e\" && e === void 0 ? e = i : i[0] === \"p\" && r === void 0 && (r = i));\n  }\n  if (e !== void 0)\n    return {\n      id: e[1],\n      relays: [e[2], r == null ? void 0 : r[2]].filter((n) => typeof n == \"string\"),\n      author: r == null ? void 0 : r[1]\n    };\n}\nfunction Qf(t, { skipVerification: e } = {}) {\n  const r = xa(t);\n  if (r === void 0 || t.content === \"\")\n    return;\n  let n;\n  try {\n    n = JSON.parse(t.content);\n  } catch {\n    return;\n  }\n  if (n.id === r.id && !(!e && !hi(n)))\n    return n;\n}\nvar eh = {};\nie(eh, {\n  NOSTR_URI_REGEX: () => Kr,\n  parse: () => rh,\n  test: () => th\n});\nvar Kr = new RegExp(`nostr:(${va.source})`);\nfunction th(t) {\n  return typeof t == \"string\" && new RegExp(`^${Kr.source}$`).test(t);\n}\nfunction rh(t) {\n  const e = t.match(new RegExp(`^${Kr.source}$`));\n  if (!e)\n    throw new Error(`Invalid Nostr URI: ${t}`);\n  return {\n    uri: e[0],\n    value: e[1],\n    decoded: Dr(e[1])\n  };\n}\nvar nh = {};\nie(nh, {\n  finishReactionEvent: () => ih,\n  getReactedEventPointer: () => oh\n});\nfunction ih(t, e, r) {\n  var i, s;\n  const n = e.tags.filter(\n    (o) => o.length >= 2 && (o[0] === \"e\" || o[0] === \"p\")\n  );\n  return da({\n    ...t,\n    kind: 7,\n    tags: [\n      ...(i = t.tags) != null ? i : [],\n      ...n,\n      [\"e\", e.id],\n      [\"p\", e.pubkey]\n    ],\n    content: (s = t.content) != null ? s : \"+\"\n  }, r);\n}\nfunction oh(t) {\n  if (t.kind !== 7)\n    return;\n  let e, r;\n  for (let n = t.tags.length - 1; n >= 0 && (e === void 0 || r === void 0); n--) {\n    const i = t.tags[n];\n    i.length >= 2 && (i[0] === \"e\" && e === void 0 ? e = i : i[0] === \"p\" && r === void 0 && (r = i));\n  }\n  if (!(e === void 0 || r === void 0))\n    return {\n      id: e[1],\n      relays: [e[2], r[2]].filter((n) => n !== void 0),\n      author: r[1]\n    };\n}\nvar sh = {};\nie(sh, {\n  createDelegation: () => ah,\n  getDelegator: () => ch\n});\nfunction ah(t, e) {\n  let r = [];\n  (e.kind || -1) >= 0 && r.push(`kind=${e.kind}`), e.until && r.push(`created_at<${e.until}`), e.since && r.push(`created_at>${e.since}`);\n  let n = r.join(\"&\");\n  if (n === \"\")\n    throw new Error(\"refusing to create a delegation without any conditions\");\n  let i = Yn(\n    Ie.encode(`nostr:delegation:${e.pubkey}:${n}`)\n  ), s = ve(\n    St.sign(i, t)\n  );\n  return {\n    from: li(t),\n    to: e.pubkey,\n    cond: n,\n    sig: s\n  };\n}\nfunction ch(t) {\n  let e = t.tags.find((a) => a[0] === \"delegation\" && a.length >= 4);\n  if (!e)\n    return null;\n  let r = e[1], n = e[2], i = e[3], s = n.split(\"&\");\n  for (let a = 0; a < s.length; a++) {\n    let [c, l, f] = s[a].split(/\\b/);\n    if (!(c === \"kind\" && l === \"=\" && t.kind === parseInt(f))) {\n      if (c === \"created_at\" && l === \"<\" && t.created_at < parseInt(f))\n        continue;\n      if (c === \"created_at\" && l === \">\" && t.created_at > parseInt(f))\n        continue;\n      return null;\n    }\n  }\n  let o = Yn(\n    Ie.encode(`nostr:delegation:${t.pubkey}:${n}`)\n  );\n  return St.verify(i, o, r) ? r : null;\n}\nvar uh = {};\nie(uh, {\n  matchAll: () => lh,\n  regex: () => pi,\n  replaceAll: () => fh\n});\nvar pi = () => new RegExp(`\\\\b${Kr.source}\\\\b`, \"g\");\nfunction* lh(t) {\n  const e = t.matchAll(pi());\n  for (const r of e) {\n    const [n, i] = r;\n    yield {\n      uri: n,\n      value: i,\n      decoded: Dr(i),\n      start: r.index,\n      end: r.index + n.length\n    };\n  }\n}\nfunction fh(t, e) {\n  return t.replaceAll(pi(), (r, n) => e({\n    uri: r,\n    value: n,\n    decoded: Dr(n)\n  }));\n}\nvar hh = {};\nie(hh, {\n  useFetchImplementation: () => dh,\n  validateGithub: () => ph\n});\nvar yi;\ntry {\n  yi = fetch;\n} catch {\n}\nfunction dh(t) {\n  yi = t;\n}\nasync function ph(t, e, r) {\n  try {\n    return await (await yi(`https://gist.github.com/${e}/${r}/raw`)).text() === `Verifying that I control the following Nostr public key: ${t}`;\n  } catch {\n    return !1;\n  }\n}\nvar yh = {};\nie(yh, {\n  authenticate: () => gh\n});\nvar gh = async ({\n  challenge: t,\n  relay: e,\n  sign: r\n}) => {\n  const n = {\n    kind: 22242,\n    created_at: Math.floor(Date.now() / 1e3),\n    tags: [\n      [\"relay\", e.url],\n      [\"challenge\", t]\n    ],\n    content: \"\"\n  }, i = e.auth(await r(n));\n  return new Promise((s, o) => {\n    i.on(\"ok\", function a() {\n      i.off(\"ok\", a), s();\n    }), i.on(\"failed\", function a(c) {\n      i.off(\"failed\", a), o(c);\n    });\n  });\n}, Ea = {};\nie(Ea, {\n  getZapEndpoint: () => vh,\n  makeZapReceipt: () => mh,\n  makeZapRequest: () => wh,\n  useFetchImplementation: () => bh,\n  validateZapRequest: () => _h\n});\nvar gi;\ntry {\n  gi = fetch;\n} catch {\n}\nfunction bh(t) {\n  gi = t;\n}\nasync function vh(t) {\n  try {\n    let e = \"\", { lud06: r, lud16: n } = JSON.parse(t.content);\n    if (r) {\n      let { words: o } = te.decode(r, 1e3), a = te.fromWords(o);\n      e = Je.decode(a);\n    } else if (n) {\n      let [o, a] = n.split(\"@\");\n      e = `https://${a}/.well-known/lnurlp/${o}`;\n    } else\n      return null;\n    let s = await (await gi(e)).json();\n    if (s.allowsNostr && s.nostrPubkey)\n      return s.callback;\n  } catch {\n  }\n  return null;\n}\nfunction wh({\n  profile: t,\n  event: e,\n  amount: r,\n  relays: n,\n  comment: i = \"\"\n}) {\n  if (!r)\n    throw new Error(\"amount not given\");\n  if (!t)\n    throw new Error(\"profile not given\");\n  let s = {\n    kind: 9734,\n    created_at: Math.round(Date.now() / 1e3),\n    content: i,\n    tags: [\n      [\"p\", t],\n      [\"amount\", r.toString()],\n      [\"relays\", ...n]\n    ]\n  };\n  return e && s.tags.push([\"e\", e]), s;\n}\nfunction _h(t) {\n  let e;\n  try {\n    e = JSON.parse(t);\n  } catch {\n    return \"Invalid zap request JSON.\";\n  }\n  if (!fi(e))\n    return \"Zap request is not a valid Nostr event.\";\n  if (!hi(e))\n    return \"Invalid signature on zap request.\";\n  let r = e.tags.find(([s, o]) => s === \"p\" && o);\n  if (!r)\n    return \"Zap request doesn't have a 'p' tag.\";\n  if (!r[1].match(/^[a-f0-9]{64}$/))\n    return \"Zap request 'p' tag is not valid hex.\";\n  let n = e.tags.find(([s, o]) => s === \"e\" && o);\n  return n && !n[1].match(/^[a-f0-9]{64}$/) ? \"Zap request 'e' tag is not valid hex.\" : e.tags.find(([s, o]) => s === \"relays\" && o) ? null : \"Zap request doesn't have a 'relays' tag.\";\n}\nfunction mh({\n  zapRequest: t,\n  preimage: e,\n  bolt11: r,\n  paidAt: n\n}) {\n  let s = JSON.parse(t).tags.filter(\n    ([a]) => a === \"e\" || a === \"p\" || a === \"a\"\n  ), o = {\n    kind: 9735,\n    created_at: Math.round(n.getTime() / 1e3),\n    content: \"\",\n    tags: [\n      ...s,\n      [\"bolt11\", r],\n      [\"description\", t]\n    ]\n  };\n  return e && o.tags.push([\"preimage\", e]), o;\n}\nvar cr = {};\nObject.defineProperty(cr, \"__esModule\", { value: !0 });\ncr.is_node = void 0;\nvar dn = null;\nfunction xh() {\n  return dn === null && (dn = typeof S == \"object\" && typeof S.process == \"object\" && typeof S.process.versions == \"object\" && typeof S.process.versions.node < \"u\"), dn;\n}\ncr.is_node = xh;\nvar pn = {}, yn, Xi;\nfunction Eh() {\n  if (Xi)\n    return yn;\n  Xi = 1;\n  var t = function() {\n    if (typeof self == \"object\" && self)\n      return self;\n    if (typeof window == \"object\" && window)\n      return window;\n    throw new Error(\"Unable to resolve global `this`\");\n  };\n  return yn = function() {\n    if (this)\n      return this;\n    if (typeof globalThis == \"object\" && globalThis)\n      return globalThis;\n    try {\n      Object.defineProperty(Object.prototype, \"__global__\", {\n        get: function() {\n          return this;\n        },\n        configurable: !0\n      });\n    } catch {\n      return t();\n    }\n    try {\n      return __global__ || t();\n    } finally {\n      delete Object.prototype.__global__;\n    }\n  }(), yn;\n}\nconst kh = \"websocket\", Sh = \"Websocket Client & Server Library implementing the WebSocket protocol as specified in RFC 6455.\", Oh = [\n  \"websocket\",\n  \"websockets\",\n  \"socket\",\n  \"networking\",\n  \"comet\",\n  \"push\",\n  \"RFC-6455\",\n  \"realtime\",\n  \"server\",\n  \"client\"\n], Ah = \"Brian McKelvey <theturtle32@gmail.com> (https://github.com/theturtle32)\", Ch = [\n  \"I\\xF1aki Baz Castillo <ibc@aliax.net> (http://dev.sipdoc.net)\"\n], Ih = \"1.0.34\", Rh = {\n  type: \"git\",\n  url: \"https://github.com/theturtle32/WebSocket-Node.git\"\n}, Th = \"https://github.com/theturtle32/WebSocket-Node\", Ph = {\n  node: \">=4.0.0\"\n}, Bh = {\n  bufferutil: \"^4.0.1\",\n  debug: \"^2.2.0\",\n  \"es5-ext\": \"^0.10.50\",\n  \"typedarray-to-buffer\": \"^3.1.5\",\n  \"utf-8-validate\": \"^5.0.2\",\n  yaeti: \"^0.0.6\"\n}, Lh = {\n  \"buffer-equal\": \"^1.0.0\",\n  gulp: \"^4.0.2\",\n  \"gulp-jshint\": \"^2.0.4\",\n  \"jshint-stylish\": \"^2.2.1\",\n  jshint: \"^2.0.0\",\n  tape: \"^4.9.1\"\n}, $h = {\n  verbose: !1\n}, qh = {\n  test: \"tape test/unit/*.js\",\n  gulp: \"gulp\"\n}, Nh = \"index\", Uh = {\n  lib: \"./lib\"\n}, jh = \"lib/browser.js\", Hh = \"Apache-2.0\", Mh = {\n  name: kh,\n  description: Sh,\n  keywords: Oh,\n  author: Ah,\n  contributors: Ch,\n  version: Ih,\n  repository: Rh,\n  homepage: Th,\n  engines: Ph,\n  dependencies: Bh,\n  devDependencies: Lh,\n  config: $h,\n  scripts: qh,\n  main: Nh,\n  directories: Uh,\n  browser: jh,\n  license: Hh\n};\nvar gn, Qi;\nfunction Dh() {\n  return Qi || (Qi = 1, gn = Mh.version), gn;\n}\nvar bn, eo;\nfunction zh() {\n  if (eo)\n    return bn;\n  eo = 1;\n  var t;\n  if (typeof globalThis == \"object\")\n    t = globalThis;\n  else\n    try {\n      t = Eh();\n    } catch {\n    } finally {\n      if (!t && typeof window < \"u\" && (t = window), !t)\n        throw new Error(\"Could not determine global this\");\n    }\n  var e = t.WebSocket || t.MozWebSocket, r = Dh();\n  function n(i, s) {\n    var o;\n    return s ? o = new e(i, s) : o = new e(i), o;\n  }\n  return e && [\"CONNECTING\", \"OPEN\", \"CLOSING\", \"CLOSED\"].forEach(function(i) {\n    Object.defineProperty(n, i, {\n      get: function() {\n        return e[i];\n      }\n    });\n  }), bn = {\n    w3cwebsocket: e ? n : null,\n    version: r\n  }, bn;\n}\nvar _r = {}, vn = {}, Rt = {}, Tt = {}, Pt = {}, Bt = {}, to;\nfunction Fh() {\n  if (to)\n    return Bt;\n  to = 1, Object.defineProperty(Bt, \"__esModule\", { value: !0 }), Bt.ForOfAdaptor = void 0;\n  var t = function() {\n    function e(r, n) {\n      this.it_ = r, this.last_ = n;\n    }\n    return e.prototype.next = function() {\n      if (this.it_.equals(this.last_))\n        return {\n          done: !0,\n          value: void 0\n        };\n      var r = this.it_;\n      return this.it_ = this.it_.next(), {\n        done: !1,\n        value: r.value\n      };\n    }, e.prototype[Symbol.iterator] = function() {\n      return this;\n    }, e;\n  }();\n  return Bt.ForOfAdaptor = t, Bt;\n}\nvar ro;\nfunction bi() {\n  if (ro)\n    return Pt;\n  ro = 1;\n  var t = S && S.__values || function(n) {\n    var i = typeof Symbol == \"function\" && Symbol.iterator, s = i && n[i], o = 0;\n    if (s)\n      return s.call(n);\n    if (n && typeof n.length == \"number\")\n      return {\n        next: function() {\n          return n && o >= n.length && (n = void 0), { value: n && n[o++], done: !n };\n        }\n      };\n    throw new TypeError(i ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n  };\n  Object.defineProperty(Pt, \"__esModule\", { value: !0 }), Pt.Container = void 0;\n  var e = Fh(), r = function() {\n    function n() {\n    }\n    return n.prototype.empty = function() {\n      return this.size() === 0;\n    }, n.prototype.rbegin = function() {\n      return this.end().reverse();\n    }, n.prototype.rend = function() {\n      return this.begin().reverse();\n    }, n.prototype[Symbol.iterator] = function() {\n      return new e.ForOfAdaptor(this.begin(), this.end());\n    }, n.prototype.toJSON = function() {\n      var i, s, o = [];\n      try {\n        for (var a = t(this), c = a.next(); !c.done; c = a.next()) {\n          var l = c.value;\n          o.push(l);\n        }\n      } catch (f) {\n        i = { error: f };\n      } finally {\n        try {\n          c && !c.done && (s = a.return) && s.call(a);\n        } finally {\n          if (i)\n            throw i.error;\n        }\n      }\n      return o;\n    }, n;\n  }();\n  return Pt.Container = r, Pt;\n}\nvar Lt = {}, no;\nfunction vi() {\n  if (no)\n    return Lt;\n  no = 1;\n  var t = S && S.__read || function(r, n) {\n    var i = typeof Symbol == \"function\" && r[Symbol.iterator];\n    if (!i)\n      return r;\n    var s = i.call(r), o, a = [], c;\n    try {\n      for (; (n === void 0 || n-- > 0) && !(o = s.next()).done; )\n        a.push(o.value);\n    } catch (l) {\n      c = { error: l };\n    } finally {\n      try {\n        o && !o.done && (i = s.return) && i.call(s);\n      } finally {\n        if (c)\n          throw c.error;\n      }\n    }\n    return a;\n  };\n  Object.defineProperty(Lt, \"__esModule\", { value: !0 }), Lt.NativeArrayIterator = void 0;\n  var e = function() {\n    function r(n, i) {\n      this.data_ = n, this.index_ = i;\n    }\n    return r.prototype.index = function() {\n      return this.index_;\n    }, Object.defineProperty(r.prototype, \"value\", {\n      get: function() {\n        return this.data_[this.index_];\n      },\n      enumerable: !1,\n      configurable: !0\n    }), r.prototype.prev = function() {\n      return --this.index_, this;\n    }, r.prototype.next = function() {\n      return ++this.index_, this;\n    }, r.prototype.advance = function(n) {\n      return this.index_ += n, this;\n    }, r.prototype.equals = function(n) {\n      return this.data_ === n.data_ && this.index_ === n.index_;\n    }, r.prototype.swap = function(n) {\n      var i, s;\n      i = t([n.data_, this.data_], 2), this.data_ = i[0], n.data_ = i[1], s = t([n.index_, this.index_], 2), this.index_ = s[0], n.index_ = s[1];\n    }, r;\n  }();\n  return Lt.NativeArrayIterator = e, Lt;\n}\nvar io;\nfunction Kh() {\n  if (io)\n    return Tt;\n  io = 1;\n  var t = S && S.__extends || function() {\n    var i = function(s, o) {\n      return i = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(a, c) {\n        a.__proto__ = c;\n      } || function(a, c) {\n        for (var l in c)\n          Object.prototype.hasOwnProperty.call(c, l) && (a[l] = c[l]);\n      }, i(s, o);\n    };\n    return function(s, o) {\n      if (typeof o != \"function\" && o !== null)\n        throw new TypeError(\"Class extends value \" + String(o) + \" is not a constructor or null\");\n      i(s, o);\n      function a() {\n        this.constructor = s;\n      }\n      s.prototype = o === null ? Object.create(o) : (a.prototype = o.prototype, new a());\n    };\n  }();\n  Object.defineProperty(Tt, \"__esModule\", { value: !0 }), Tt.SetContainer = void 0;\n  var e = bi(), r = vi(), n = function(i) {\n    t(s, i);\n    function s(o) {\n      var a = i.call(this) || this;\n      return a.data_ = o(a), a;\n    }\n    return s.prototype.assign = function(o, a) {\n      this.clear(), this.insert(o, a);\n    }, s.prototype.clear = function() {\n      this.data_.clear();\n    }, s.prototype.begin = function() {\n      return this.data_.begin();\n    }, s.prototype.end = function() {\n      return this.data_.end();\n    }, s.prototype.has = function(o) {\n      return !this.find(o).equals(this.end());\n    }, s.prototype.size = function() {\n      return this.data_.size();\n    }, s.prototype.push = function() {\n      for (var o = [], a = 0; a < arguments.length; a++)\n        o[a] = arguments[a];\n      if (o.length === 0)\n        return this.size();\n      var c = new r.NativeArrayIterator(o, 0), l = new r.NativeArrayIterator(o, o.length);\n      return this._Insert_by_range(c, l), this.size();\n    }, s.prototype.insert = function() {\n      for (var o = [], a = 0; a < arguments.length; a++)\n        o[a] = arguments[a];\n      return o.length === 1 ? this._Insert_by_key(o[0]) : o[0].next instanceof Function && o[1].next instanceof Function ? this._Insert_by_range(o[0], o[1]) : this._Insert_by_hint(o[0], o[1]);\n    }, s.prototype.erase = function() {\n      for (var o = [], a = 0; a < arguments.length; a++)\n        o[a] = arguments[a];\n      return o.length === 1 && !(o[0] instanceof this.end().constructor && o[0].source() === this) ? this._Erase_by_val(o[0]) : o.length === 1 ? this._Erase_by_range(o[0]) : this._Erase_by_range(o[0], o[1]);\n    }, s.prototype._Erase_by_range = function(o, a) {\n      a === void 0 && (a = o.next());\n      var c = this.data_.erase(o, a);\n      return this._Handle_erase(o, a), c;\n    }, s;\n  }(e.Container);\n  return Tt.SetContainer = n, Tt;\n}\nvar wn = {}, $t = {}, qt = {}, Nt = {}, oo;\nfunction Wh() {\n  if (oo)\n    return Nt;\n  oo = 1;\n  var t = S && S.__extends || function() {\n    var r = function(n, i) {\n      return r = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(s, o) {\n        s.__proto__ = o;\n      } || function(s, o) {\n        for (var a in o)\n          Object.prototype.hasOwnProperty.call(o, a) && (s[a] = o[a]);\n      }, r(n, i);\n    };\n    return function(n, i) {\n      if (typeof i != \"function\" && i !== null)\n        throw new TypeError(\"Class extends value \" + String(i) + \" is not a constructor or null\");\n      r(n, i);\n      function s() {\n        this.constructor = n;\n      }\n      n.prototype = i === null ? Object.create(i) : (s.prototype = i.prototype, new s());\n    };\n  }();\n  Object.defineProperty(Nt, \"__esModule\", { value: !0 }), Nt.Exception = void 0;\n  var e = function(r) {\n    t(n, r);\n    function n(i) {\n      var s = this.constructor, o = r.call(this, i) || this, a = s.prototype;\n      return Object.setPrototypeOf ? Object.setPrototypeOf(o, a) : o.__proto__ = a, o;\n    }\n    return Object.defineProperty(n.prototype, \"name\", {\n      get: function() {\n        return this.constructor.name;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), n.prototype.what = function() {\n      return this.message;\n    }, n.prototype.toJSON = function() {\n      return {\n        name: this.name,\n        message: this.message,\n        stack: this.stack\n      };\n    }, n;\n  }(Error);\n  return Nt.Exception = e, Nt;\n}\nvar so;\nfunction ka() {\n  if (so)\n    return qt;\n  so = 1;\n  var t = S && S.__extends || function() {\n    var n = function(i, s) {\n      return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(o, a) {\n        o.__proto__ = a;\n      } || function(o, a) {\n        for (var c in a)\n          Object.prototype.hasOwnProperty.call(a, c) && (o[c] = a[c]);\n      }, n(i, s);\n    };\n    return function(i, s) {\n      if (typeof s != \"function\" && s !== null)\n        throw new TypeError(\"Class extends value \" + String(s) + \" is not a constructor or null\");\n      n(i, s);\n      function o() {\n        this.constructor = i;\n      }\n      i.prototype = s === null ? Object.create(s) : (o.prototype = s.prototype, new o());\n    };\n  }();\n  Object.defineProperty(qt, \"__esModule\", { value: !0 }), qt.LogicError = void 0;\n  var e = Wh(), r = function(n) {\n    t(i, n);\n    function i(s) {\n      return n.call(this, s) || this;\n    }\n    return i;\n  }(e.Exception);\n  return qt.LogicError = r, qt;\n}\nvar ao;\nfunction Sa() {\n  if (ao)\n    return $t;\n  ao = 1;\n  var t = S && S.__extends || function() {\n    var n = function(i, s) {\n      return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(o, a) {\n        o.__proto__ = a;\n      } || function(o, a) {\n        for (var c in a)\n          Object.prototype.hasOwnProperty.call(a, c) && (o[c] = a[c]);\n      }, n(i, s);\n    };\n    return function(i, s) {\n      if (typeof s != \"function\" && s !== null)\n        throw new TypeError(\"Class extends value \" + String(s) + \" is not a constructor or null\");\n      n(i, s);\n      function o() {\n        this.constructor = i;\n      }\n      i.prototype = s === null ? Object.create(s) : (o.prototype = s.prototype, new o());\n    };\n  }();\n  Object.defineProperty($t, \"__esModule\", { value: !0 }), $t.InvalidArgument = void 0;\n  var e = ka(), r = function(n) {\n    t(i, n);\n    function i(s) {\n      return n.call(this, s) || this;\n    }\n    return i;\n  }(e.LogicError);\n  return $t.InvalidArgument = r, $t;\n}\nvar Ut = {}, co;\nfunction Vh() {\n  if (co)\n    return Ut;\n  co = 1;\n  var t = S && S.__extends || function() {\n    var n = function(i, s) {\n      return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(o, a) {\n        o.__proto__ = a;\n      } || function(o, a) {\n        for (var c in a)\n          Object.prototype.hasOwnProperty.call(a, c) && (o[c] = a[c]);\n      }, n(i, s);\n    };\n    return function(i, s) {\n      if (typeof s != \"function\" && s !== null)\n        throw new TypeError(\"Class extends value \" + String(s) + \" is not a constructor or null\");\n      n(i, s);\n      function o() {\n        this.constructor = i;\n      }\n      i.prototype = s === null ? Object.create(s) : (o.prototype = s.prototype, new o());\n    };\n  }();\n  Object.defineProperty(Ut, \"__esModule\", { value: !0 }), Ut.OutOfRange = void 0;\n  var e = ka(), r = function(n) {\n    t(i, n);\n    function i(s) {\n      return n.call(this, s) || this;\n    }\n    return i;\n  }(e.LogicError);\n  return Ut.OutOfRange = r, Ut;\n}\nvar uo;\nfunction Wr() {\n  return uo || (uo = 1, function(t) {\n    Object.defineProperty(t, \"__esModule\", { value: !0 }), t.ErrorGenerator = void 0;\n    var e = Sa(), r = Vh();\n    (function(n) {\n      function i(d) {\n        if (typeof d == \"string\")\n          return d;\n        var p = d.constructor.name;\n        return d.constructor.__MODULE && (p = \"\".concat(d.constructor.__MODULE, \".\").concat(p)), \"std.\".concat(p);\n      }\n      n.get_class_name = i;\n      function s(d, p) {\n        return new r.OutOfRange(\"Error on \".concat(i(d), \".\").concat(p, \"(): it's empty container.\"));\n      }\n      n.empty = s;\n      function o(d, p, y) {\n        return new r.OutOfRange(\"Error on \".concat(i(d), \".\").concat(p, \"(): parametric index is negative -> (index = \").concat(y, \").\"));\n      }\n      n.negative_index = o;\n      function a(d, p, y, g) {\n        return new r.OutOfRange(\"Error on \".concat(i(d), \".\").concat(p, \"(): parametric index is equal or greater than size -> (index = \").concat(y, \", size: \").concat(g, \").\"));\n      }\n      n.excessive_index = a;\n      function c(d, p) {\n        return new e.InvalidArgument(\"Error on \".concat(i(d), \".\").concat(p, \"(): parametric iterator is not this container's own.\"));\n      }\n      n.not_my_iterator = c;\n      function l(d, p) {\n        return new e.InvalidArgument(\"Error on \".concat(i(d), \".\").concat(p, \"(): parametric iterator, it already has been erased.\"));\n      }\n      n.erased_iterator = l;\n      function f(d, p, y) {\n        return new r.OutOfRange(\"Error on \".concat(i(d), \".\").concat(p, \"(): parametric iterator is directing negative position -> (index = \").concat(y, \").\"));\n      }\n      n.negative_iterator = f;\n      function u(d, p) {\n        p === void 0 && (p = \"end\");\n        var y = i(d);\n        return new r.OutOfRange(\"Error on \".concat(y, \".Iterator.value: cannot access to the \").concat(y, \".\").concat(p, \"().value.\"));\n      }\n      n.iterator_end_value = u;\n      function h(d, p, y) {\n        throw new r.OutOfRange(\"Error on \".concat(i(d), \".\").concat(p, \"(): unable to find the matched key -> \").concat(y));\n      }\n      n.key_nout_found = h;\n    })(t.ErrorGenerator || (t.ErrorGenerator = {}));\n  }(wn)), wn;\n}\nvar lo;\nfunction Gh() {\n  if (lo)\n    return Rt;\n  lo = 1;\n  var t = S && S.__extends || function() {\n    var o = function(a, c) {\n      return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(l, f) {\n        l.__proto__ = f;\n      } || function(l, f) {\n        for (var u in f)\n          Object.prototype.hasOwnProperty.call(f, u) && (l[u] = f[u]);\n      }, o(a, c);\n    };\n    return function(a, c) {\n      if (typeof c != \"function\" && c !== null)\n        throw new TypeError(\"Class extends value \" + String(c) + \" is not a constructor or null\");\n      o(a, c);\n      function l() {\n        this.constructor = a;\n      }\n      a.prototype = c === null ? Object.create(c) : (l.prototype = c.prototype, new l());\n    };\n  }(), e = S && S.__read || function(o, a) {\n    var c = typeof Symbol == \"function\" && o[Symbol.iterator];\n    if (!c)\n      return o;\n    var l = c.call(o), f, u = [], h;\n    try {\n      for (; (a === void 0 || a-- > 0) && !(f = l.next()).done; )\n        u.push(f.value);\n    } catch (d) {\n      h = { error: d };\n    } finally {\n      try {\n        f && !f.done && (c = l.return) && c.call(l);\n      } finally {\n        if (h)\n          throw h.error;\n      }\n    }\n    return u;\n  }, r = S && S.__spreadArray || function(o, a, c) {\n    if (c || arguments.length === 2)\n      for (var l = 0, f = a.length, u; l < f; l++)\n        (u || !(l in a)) && (u || (u = Array.prototype.slice.call(a, 0, l)), u[l] = a[l]);\n    return o.concat(u || Array.prototype.slice.call(a));\n  };\n  Object.defineProperty(Rt, \"__esModule\", { value: !0 }), Rt.UniqueSet = void 0;\n  var n = Kh(), i = Wr(), s = function(o) {\n    t(a, o);\n    function a() {\n      return o !== null && o.apply(this, arguments) || this;\n    }\n    return a.prototype.count = function(c) {\n      return this.find(c).equals(this.end()) ? 0 : 1;\n    }, a.prototype.insert = function() {\n      for (var c = [], l = 0; l < arguments.length; l++)\n        c[l] = arguments[l];\n      return o.prototype.insert.apply(this, r([], e(c), !1));\n    }, a.prototype._Insert_by_range = function(c, l) {\n      for (; !c.equals(l); c = c.next())\n        this._Insert_by_key(c.value);\n    }, a.prototype.extract = function(c) {\n      return c instanceof this.end().constructor ? this._Extract_by_iterator(c) : this._Extract_by_val(c);\n    }, a.prototype._Extract_by_val = function(c) {\n      var l = this.find(c);\n      if (l.equals(this.end()) === !0)\n        throw i.ErrorGenerator.key_nout_found(this, \"extract\", c);\n      return this._Erase_by_range(l), c;\n    }, a.prototype._Extract_by_iterator = function(c) {\n      return c.equals(this.end()) === !0 || this.has(c.value) === !1 ? this.end() : (this._Erase_by_range(c), c);\n    }, a.prototype._Erase_by_val = function(c) {\n      var l = this.find(c);\n      return l.equals(this.end()) === !0 ? 0 : (this._Erase_by_range(l), 1);\n    }, a.prototype.merge = function(c) {\n      for (var l = c.begin(); !l.equals(c.end()); )\n        this.has(l.value) === !1 ? (this.insert(l.value), l = c.erase(l)) : l = l.next();\n    }, a;\n  }(n.SetContainer);\n  return Rt.UniqueSet = s, Rt;\n}\nvar _n = {}, mn = {}, fo;\nfunction Zh() {\n  return fo || (fo = 1, function(t) {\n    var e = S && S.__read || function(n, i) {\n      var s = typeof Symbol == \"function\" && n[Symbol.iterator];\n      if (!s)\n        return n;\n      var o = s.call(n), a, c = [], l;\n      try {\n        for (; (i === void 0 || i-- > 0) && !(a = o.next()).done; )\n          c.push(a.value);\n      } catch (f) {\n        l = { error: f };\n      } finally {\n        try {\n          a && !a.done && (s = o.return) && s.call(o);\n        } finally {\n          if (l)\n            throw l.error;\n        }\n      }\n      return c;\n    }, r = S && S.__spreadArray || function(n, i, s) {\n      if (s || arguments.length === 2)\n        for (var o = 0, a = i.length, c; o < a; o++)\n          (c || !(o in i)) && (c || (c = Array.prototype.slice.call(i, 0, o)), c[o] = i[o]);\n      return n.concat(c || Array.prototype.slice.call(i));\n    };\n    Object.defineProperty(t, \"__esModule\", { value: !0 }), t.IAssociativeContainer = void 0, function(n) {\n      function i(s) {\n        for (var o = [], a = 1; a < arguments.length; a++)\n          o[a - 1] = arguments[a];\n        var c, l;\n        return o.length >= 1 && o[0] instanceof Array ? (c = function() {\n          var f = o[0];\n          s.push.apply(s, r([], e(f), !1));\n        }, l = o.slice(1)) : o.length >= 2 && o[0].next instanceof Function && o[1].next instanceof Function ? (c = function() {\n          var f = o[0], u = o[1];\n          s.assign(f, u);\n        }, l = o.slice(2)) : (c = null, l = o), { ramda: c, tail: l };\n      }\n      n.construct = i;\n    }(t.IAssociativeContainer || (t.IAssociativeContainer = {}));\n  }(mn)), mn;\n}\nvar jt = {}, Ht = {}, Mt = {}, ho;\nfunction Yh() {\n  if (ho)\n    return Mt;\n  ho = 1, Object.defineProperty(Mt, \"__esModule\", { value: !0 }), Mt._Get_root = void 0;\n  var t = cr;\n  function e() {\n    return r === null && (r = (0, t.is_node)() ? S : self, r.__s_iUID === void 0 && (r.__s_iUID = 0)), r;\n  }\n  Mt._Get_root = e;\n  var r = null;\n  return Mt;\n}\nvar po;\nfunction Oa() {\n  if (po)\n    return Ht;\n  po = 1, Object.defineProperty(Ht, \"__esModule\", { value: !0 }), Ht.get_uid = void 0;\n  var t = Yh();\n  function e(r) {\n    if (r instanceof Object) {\n      if (r.hasOwnProperty(\"__get_m_iUID\") === !1) {\n        var n = ++(0, t._Get_root)().__s_iUID;\n        Object.defineProperty(r, \"__get_m_iUID\", {\n          value: function() {\n            return n;\n          }\n        });\n      }\n      return r.__get_m_iUID();\n    } else\n      return r === void 0 ? -1 : 0;\n  }\n  return Ht.get_uid = e, Ht;\n}\nvar yo;\nfunction wi() {\n  if (yo)\n    return jt;\n  yo = 1;\n  var t = S && S.__values || function(c) {\n    var l = typeof Symbol == \"function\" && Symbol.iterator, f = l && c[l], u = 0;\n    if (f)\n      return f.call(c);\n    if (c && typeof c.length == \"number\")\n      return {\n        next: function() {\n          return c && u >= c.length && (c = void 0), { value: c && c[u++], done: !c };\n        }\n      };\n    throw new TypeError(l ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n  };\n  Object.defineProperty(jt, \"__esModule\", { value: !0 }), jt.hash = void 0;\n  var e = Oa();\n  function r() {\n    for (var c, l, f = [], u = 0; u < arguments.length; u++)\n      f[u] = arguments[u];\n    var h = o;\n    try {\n      for (var d = t(f), p = d.next(); !p.done; p = d.next()) {\n        var y = p.value;\n        y = y && y.valueOf();\n        var g = typeof y;\n        if (g === \"boolean\")\n          h = n(y, h);\n        else if (g === \"number\" || g === \"bigint\")\n          h = i(y, h);\n        else if (g === \"string\")\n          h = s(y, h);\n        else if (y instanceof Object && y.hashCode instanceof Function) {\n          var v = y.hashCode();\n          if (f.length === 1)\n            return v;\n          h = h ^ v, h *= a;\n        } else\n          h = i((0, e.get_uid)(y), h);\n      }\n    } catch (_) {\n      c = { error: _ };\n    } finally {\n      try {\n        p && !p.done && (l = d.return) && l.call(d);\n      } finally {\n        if (c)\n          throw c.error;\n      }\n    }\n    return Math.abs(h);\n  }\n  jt.hash = r;\n  function n(c, l) {\n    return l ^= c ? 1 : 0, l *= a, l;\n  }\n  function i(c, l) {\n    return s(c.toString(), l);\n  }\n  function s(c, l) {\n    for (var f = 0; f < c.length; ++f)\n      l ^= c.charCodeAt(f), l *= a;\n    return Math.abs(l);\n  }\n  var o = 2166136261, a = 16777619;\n  return jt;\n}\nvar ae = {}, go;\nfunction _i() {\n  if (go)\n    return ae;\n  go = 1, Object.defineProperty(ae, \"__esModule\", { value: !0 }), ae.greater_equal = ae.greater = ae.less_equal = ae.less = ae.not_equal_to = ae.equal_to = void 0;\n  var t = Oa();\n  function e(a, c) {\n    return a = a && a.valueOf(), c = c && c.valueOf(), a instanceof Object && a.equals instanceof Function ? a.equals(c) : a === c;\n  }\n  ae.equal_to = e;\n  function r(a, c) {\n    return !e(a, c);\n  }\n  ae.not_equal_to = r;\n  function n(a, c) {\n    return a = a.valueOf(), c = c.valueOf(), a instanceof Object ? a.less instanceof Function ? a.less(c) : (0, t.get_uid)(a) < (0, t.get_uid)(c) : a < c;\n  }\n  ae.less = n;\n  function i(a, c) {\n    return n(a, c) || e(a, c);\n  }\n  ae.less_equal = i;\n  function s(a, c) {\n    return !i(a, c);\n  }\n  ae.greater = s;\n  function o(a, c) {\n    return !n(a, c);\n  }\n  return ae.greater_equal = o, ae;\n}\nvar bo;\nfunction Aa() {\n  return bo || (bo = 1, function(t) {\n    var e = S && S.__read || function(o, a) {\n      var c = typeof Symbol == \"function\" && o[Symbol.iterator];\n      if (!c)\n        return o;\n      var l = c.call(o), f, u = [], h;\n      try {\n        for (; (a === void 0 || a-- > 0) && !(f = l.next()).done; )\n          u.push(f.value);\n      } catch (d) {\n        h = { error: d };\n      } finally {\n        try {\n          f && !f.done && (c = l.return) && c.call(l);\n        } finally {\n          if (h)\n            throw h.error;\n        }\n      }\n      return u;\n    }, r = S && S.__spreadArray || function(o, a, c) {\n      if (c || arguments.length === 2)\n        for (var l = 0, f = a.length, u; l < f; l++)\n          (u || !(l in a)) && (u || (u = Array.prototype.slice.call(a, 0, l)), u[l] = a[l]);\n      return o.concat(u || Array.prototype.slice.call(a));\n    };\n    Object.defineProperty(t, \"__esModule\", { value: !0 }), t.IHashContainer = void 0;\n    var n = Zh(), i = wi(), s = _i();\n    (function(o) {\n      function a(c, l, f) {\n        for (var u = [], h = 3; h < arguments.length; h++)\n          u[h - 3] = arguments[h];\n        var d = null, p = i.hash, y = s.equal_to;\n        if (u.length === 1 && u[0] instanceof l) {\n          var g = u[0];\n          p = g.hash_function(), y = g.key_eq(), d = function() {\n            var _ = g.begin(), m = g.end();\n            c.assign(_, m);\n          };\n        } else {\n          var v = n.IAssociativeContainer.construct.apply(n.IAssociativeContainer, r([c], e(u), !1));\n          d = v.ramda, v.tail.length >= 1 && (p = v.tail[0]), v.tail.length >= 2 && (y = v.tail[1]);\n        }\n        f(p, y), d !== null && d();\n      }\n      o.construct = a;\n    })(t.IHashContainer || (t.IHashContainer = {}));\n  }(_n)), _n;\n}\nvar xn = {}, Dt = {}, zt = {}, vo;\nfunction mi() {\n  if (vo)\n    return zt;\n  vo = 1, Object.defineProperty(zt, \"__esModule\", { value: !0 }), zt.ListIterator = void 0;\n  var t = Wr(), e = function() {\n    function r(n, i, s) {\n      this.prev_ = n, this.next_ = i, this.value_ = s;\n    }\n    return r._Set_prev = function(n, i) {\n      n.prev_ = i;\n    }, r._Set_next = function(n, i) {\n      n.next_ = i;\n    }, r.prototype.prev = function() {\n      return this.prev_;\n    }, r.prototype.next = function() {\n      return this.next_;\n    }, Object.defineProperty(r.prototype, \"value\", {\n      get: function() {\n        return this._Try_value(), this.value_;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), r.prototype._Try_value = function() {\n      if (this.value_ === void 0 && this.equals(this.source().end()) === !0)\n        throw t.ErrorGenerator.iterator_end_value(this.source());\n    }, r.prototype.equals = function(n) {\n      return this === n;\n    }, r;\n  }();\n  return zt.ListIterator = e, zt;\n}\nvar Ft = {}, wo;\nfunction Jh() {\n  if (wo)\n    return Ft;\n  wo = 1, Object.defineProperty(Ft, \"__esModule\", { value: !0 }), Ft.Repeater = void 0;\n  var t = function() {\n    function e(r, n) {\n      this.index_ = r, this.value_ = n;\n    }\n    return e.prototype.index = function() {\n      return this.index_;\n    }, Object.defineProperty(e.prototype, \"value\", {\n      get: function() {\n        return this.value_;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), e.prototype.next = function() {\n      return ++this.index_, this;\n    }, e.prototype.equals = function(r) {\n      return this.index_ === r.index_;\n    }, e;\n  }();\n  return Ft.Repeater = t, Ft;\n}\nvar ce = {}, _o;\nfunction Xh() {\n  if (_o)\n    return ce;\n  _o = 1, Object.defineProperty(ce, \"__esModule\", { value: !0 }), ce.next = ce.prev = ce.advance = ce.distance = ce.size = ce.empty = void 0;\n  var t = Sa();\n  function e(c) {\n    return c instanceof Array ? c.length !== 0 : c.empty();\n  }\n  ce.empty = e;\n  function r(c) {\n    return c instanceof Array ? c.length : c.size();\n  }\n  ce.size = r;\n  function n(c, l) {\n    if (c.index instanceof Function)\n      return i(c, l);\n    for (var f = 0; !c.equals(l); c = c.next())\n      ++f;\n    return f;\n  }\n  ce.distance = n;\n  function i(c, l) {\n    var f = c.index(), u = l.index();\n    return c.base instanceof Function ? f - u : u - f;\n  }\n  function s(c, l) {\n    if (l === 0)\n      return c;\n    if (c.advance instanceof Function)\n      return c.advance(l);\n    var f;\n    if (l < 0) {\n      if (!(c.prev instanceof Function))\n        throw new t.InvalidArgument(\"Error on std.advance(): parametric iterator is not a bi-directional iterator, thus advancing to negative direction is not possible.\");\n      f = function(u) {\n        return u.prev();\n      }, l = -l;\n    } else\n      f = function(u) {\n        return u.next();\n      };\n    for (; l-- > 0; )\n      c = f(c);\n    return c;\n  }\n  ce.advance = s;\n  function o(c, l) {\n    return l === void 0 && (l = 1), l === 1 ? c.prev() : s(c, -l);\n  }\n  ce.prev = o;\n  function a(c, l) {\n    return l === void 0 && (l = 1), l === 1 ? c.next() : s(c, l);\n  }\n  return ce.next = a, ce;\n}\nvar mo;\nfunction Ca() {\n  if (mo)\n    return Dt;\n  mo = 1;\n  var t = S && S.__extends || function() {\n    var l = function(f, u) {\n      return l = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(h, d) {\n        h.__proto__ = d;\n      } || function(h, d) {\n        for (var p in d)\n          Object.prototype.hasOwnProperty.call(d, p) && (h[p] = d[p]);\n      }, l(f, u);\n    };\n    return function(f, u) {\n      if (typeof u != \"function\" && u !== null)\n        throw new TypeError(\"Class extends value \" + String(u) + \" is not a constructor or null\");\n      l(f, u);\n      function h() {\n        this.constructor = f;\n      }\n      f.prototype = u === null ? Object.create(u) : (h.prototype = u.prototype, new h());\n    };\n  }(), e = S && S.__read || function(l, f) {\n    var u = typeof Symbol == \"function\" && l[Symbol.iterator];\n    if (!u)\n      return l;\n    var h = u.call(l), d, p = [], y;\n    try {\n      for (; (f === void 0 || f-- > 0) && !(d = h.next()).done; )\n        p.push(d.value);\n    } catch (g) {\n      y = { error: g };\n    } finally {\n      try {\n        d && !d.done && (u = h.return) && u.call(h);\n      } finally {\n        if (y)\n          throw y.error;\n      }\n    }\n    return p;\n  };\n  Object.defineProperty(Dt, \"__esModule\", { value: !0 }), Dt.ListContainer = void 0;\n  var r = bi(), n = mi(), i = Jh(), s = vi(), o = Xh(), a = Wr(), c = function(l) {\n    t(f, l);\n    function f() {\n      var u = l.call(this) || this;\n      return u.end_ = u._Create_iterator(null, null), u.clear(), u;\n    }\n    return f.prototype.assign = function(u, h) {\n      this.clear(), this.insert(this.end(), u, h);\n    }, f.prototype.clear = function() {\n      n.ListIterator._Set_prev(this.end_, this.end_), n.ListIterator._Set_next(this.end_, this.end_), this.begin_ = this.end_, this.size_ = 0;\n    }, f.prototype.resize = function(u) {\n      var h = u - this.size();\n      h > 0 ? this.insert(this.end(), h, void 0) : h < 0 && this.erase((0, o.advance)(this.end(), -h), this.end());\n    }, f.prototype.begin = function() {\n      return this.begin_;\n    }, f.prototype.end = function() {\n      return this.end_;\n    }, f.prototype.size = function() {\n      return this.size_;\n    }, f.prototype.push_front = function(u) {\n      this.insert(this.begin_, u);\n    }, f.prototype.push_back = function(u) {\n      this.insert(this.end_, u);\n    }, f.prototype.pop_front = function() {\n      if (this.empty() === !0)\n        throw a.ErrorGenerator.empty(this.end_.source().constructor.name, \"pop_front\");\n      this.erase(this.begin_);\n    }, f.prototype.pop_back = function() {\n      if (this.empty() === !0)\n        throw a.ErrorGenerator.empty(this.end_.source().constructor.name, \"pop_back\");\n      this.erase(this.end_.prev());\n    }, f.prototype.push = function() {\n      for (var u = [], h = 0; h < arguments.length; h++)\n        u[h] = arguments[h];\n      if (u.length === 0)\n        return this.size();\n      var d = new s.NativeArrayIterator(u, 0), p = new s.NativeArrayIterator(u, u.length);\n      return this._Insert_by_range(this.end(), d, p), this.size();\n    }, f.prototype.insert = function(u) {\n      for (var h = [], d = 1; d < arguments.length; d++)\n        h[d - 1] = arguments[d];\n      if (u.source() !== this.end_.source())\n        throw a.ErrorGenerator.not_my_iterator(this.end_.source(), \"insert\");\n      if (u.erased_ === !0)\n        throw a.ErrorGenerator.erased_iterator(this.end_.source(), \"insert\");\n      return h.length === 1 ? this._Insert_by_repeating_val(u, 1, h[0]) : h.length === 2 && typeof h[0] == \"number\" ? this._Insert_by_repeating_val(u, h[0], h[1]) : this._Insert_by_range(u, h[0], h[1]);\n    }, f.prototype._Insert_by_repeating_val = function(u, h, d) {\n      var p = new i.Repeater(0, d), y = new i.Repeater(h);\n      return this._Insert_by_range(u, p, y);\n    }, f.prototype._Insert_by_range = function(u, h, d) {\n      for (var p = u.prev(), y = null, g = 0, v = h; v.equals(d) === !1; v = v.next()) {\n        var _ = this._Create_iterator(p, null, v.value);\n        g === 0 && (y = _), n.ListIterator._Set_next(p, _), p = _, ++g;\n      }\n      return u.equals(this.begin()) === !0 && (this.begin_ = y), n.ListIterator._Set_next(p, u), n.ListIterator._Set_prev(u, p), this.size_ += g, y;\n    }, f.prototype.erase = function(u, h) {\n      return h === void 0 && (h = u.next()), this._Erase_by_range(u, h);\n    }, f.prototype._Erase_by_range = function(u, h) {\n      if (u.source() !== this.end_.source())\n        throw a.ErrorGenerator.not_my_iterator(this.end_.source(), \"insert\");\n      if (u.erased_ === !0)\n        throw a.ErrorGenerator.erased_iterator(this.end_.source(), \"insert\");\n      if (u.equals(this.end_))\n        return this.end_;\n      var d = u.prev();\n      n.ListIterator._Set_next(d, h), n.ListIterator._Set_prev(h, d);\n      for (var p = u; !p.equals(h); p = p.next())\n        p.erased_ = !0, --this.size_;\n      return u.equals(this.begin_) && (this.begin_ = h), h;\n    }, f.prototype.swap = function(u) {\n      var h, d, p;\n      h = e([u.begin_, this.begin_], 2), this.begin_ = h[0], u.begin_ = h[1], d = e([u.end_, this.end_], 2), this.end_ = d[0], u.end_ = d[1], p = e([u.size_, this.size_], 2), this.size_ = p[0], u.size_ = p[1];\n    }, f;\n  }(r.Container);\n  return Dt.ListContainer = c, Dt;\n}\nvar Kt = {}, xo;\nfunction Ia() {\n  if (xo)\n    return Kt;\n  xo = 1, Object.defineProperty(Kt, \"__esModule\", { value: !0 }), Kt.ReverseIterator = void 0;\n  var t = function() {\n    function e(r) {\n      this.base_ = r.prev();\n    }\n    return e.prototype.source = function() {\n      return this.base_.source();\n    }, e.prototype.base = function() {\n      return this.base_.next();\n    }, Object.defineProperty(e.prototype, \"value\", {\n      get: function() {\n        return this.base_.value;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), e.prototype.prev = function() {\n      return this._Create_neighbor(this.base().next());\n    }, e.prototype.next = function() {\n      return this._Create_neighbor(this.base_);\n    }, e.prototype.equals = function(r) {\n      return this.base_.equals(r.base_);\n    }, e;\n  }();\n  return Kt.ReverseIterator = t, Kt;\n}\nvar Eo;\nfunction Qh() {\n  return Eo || (Eo = 1, function(t) {\n    var e = S && S.__extends || function() {\n      var a = function(c, l) {\n        return a = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(f, u) {\n          f.__proto__ = u;\n        } || function(f, u) {\n          for (var h in u)\n            Object.prototype.hasOwnProperty.call(u, h) && (f[h] = u[h]);\n        }, a(c, l);\n      };\n      return function(c, l) {\n        if (typeof l != \"function\" && l !== null)\n          throw new TypeError(\"Class extends value \" + String(l) + \" is not a constructor or null\");\n        a(c, l);\n        function f() {\n          this.constructor = c;\n        }\n        c.prototype = l === null ? Object.create(l) : (f.prototype = l.prototype, new f());\n      };\n    }(), r = S && S.__read || function(a, c) {\n      var l = typeof Symbol == \"function\" && a[Symbol.iterator];\n      if (!l)\n        return a;\n      var f = l.call(a), u, h = [], d;\n      try {\n        for (; (c === void 0 || c-- > 0) && !(u = f.next()).done; )\n          h.push(u.value);\n      } catch (p) {\n        d = { error: p };\n      } finally {\n        try {\n          u && !u.done && (l = f.return) && l.call(f);\n        } finally {\n          if (d)\n            throw d.error;\n        }\n      }\n      return h;\n    };\n    Object.defineProperty(t, \"__esModule\", { value: !0 }), t.SetElementList = void 0;\n    var n = Ca(), i = mi(), s = Ia(), o = function(a) {\n      e(c, a);\n      function c(l) {\n        var f = a.call(this) || this;\n        return f.associative_ = l, f;\n      }\n      return c.prototype._Create_iterator = function(l, f, u) {\n        return c.Iterator.create(this, l, f, u);\n      }, c._Swap_associative = function(l, f) {\n        var u;\n        u = r([f.associative_, l.associative_], 2), l.associative_ = u[0], f.associative_ = u[1];\n      }, c.prototype.associative = function() {\n        return this.associative_;\n      }, c;\n    }(n.ListContainer);\n    t.SetElementList = o, function(a) {\n      var c = function(f) {\n        e(u, f);\n        function u(h, d, p, y) {\n          var g = f.call(this, d, p, y) || this;\n          return g.source_ = h, g;\n        }\n        return u.create = function(h, d, p, y) {\n          return new u(h, d, p, y);\n        }, u.prototype.reverse = function() {\n          return new l(this);\n        }, u.prototype.source = function() {\n          return this.source_.associative();\n        }, u;\n      }(i.ListIterator);\n      a.Iterator = c;\n      var l = function(f) {\n        e(u, f);\n        function u() {\n          return f !== null && f.apply(this, arguments) || this;\n        }\n        return u.prototype._Create_neighbor = function(h) {\n          return new u(h);\n        }, u;\n      }(s.ReverseIterator);\n      a.ReverseIterator = l;\n    }(o = t.SetElementList || (t.SetElementList = {})), t.SetElementList = o;\n  }(xn)), xn;\n}\nvar Wt = {}, Vt = {}, ko;\nfunction Ra() {\n  if (ko)\n    return Vt;\n  ko = 1;\n  var t = S && S.__values || function(i) {\n    var s = typeof Symbol == \"function\" && Symbol.iterator, o = s && i[s], a = 0;\n    if (o)\n      return o.call(i);\n    if (i && typeof i.length == \"number\")\n      return {\n        next: function() {\n          return i && a >= i.length && (i = void 0), { value: i && i[a++], done: !i };\n        }\n      };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n  };\n  Object.defineProperty(Vt, \"__esModule\", { value: !0 }), Vt.HashBuckets = void 0;\n  var e = function() {\n    function i(s, o) {\n      this.fetcher_ = s, this.hasher_ = o, this.max_load_factor_ = n, this.data_ = [], this.size_ = 0, this.initialize();\n    }\n    return i.prototype.clear = function() {\n      this.data_ = [], this.size_ = 0, this.initialize();\n    }, i.prototype.rehash = function(s) {\n      var o, a, c, l;\n      s = Math.max(s, r);\n      for (var f = [], u = 0; u < s; ++u)\n        f.push([]);\n      try {\n        for (var h = t(this.data_), d = h.next(); !d.done; d = h.next()) {\n          var p = d.value;\n          try {\n            for (var y = (c = void 0, t(p)), g = y.next(); !g.done; g = y.next()) {\n              var v = g.value, _ = this.hasher_(this.fetcher_(v)) % f.length;\n              f[_].push(v);\n            }\n          } catch (m) {\n            c = { error: m };\n          } finally {\n            try {\n              g && !g.done && (l = y.return) && l.call(y);\n            } finally {\n              if (c)\n                throw c.error;\n            }\n          }\n        }\n      } catch (m) {\n        o = { error: m };\n      } finally {\n        try {\n          d && !d.done && (a = h.return) && a.call(h);\n        } finally {\n          if (o)\n            throw o.error;\n        }\n      }\n      this.data_ = f;\n    }, i.prototype.reserve = function(s) {\n      s > this.capacity() && (s = Math.floor(s / this.max_load_factor_), this.rehash(s));\n    }, i.prototype.initialize = function() {\n      for (var s = 0; s < r; ++s)\n        this.data_.push([]);\n    }, i.prototype.length = function() {\n      return this.data_.length;\n    }, i.prototype.capacity = function() {\n      return this.data_.length * this.max_load_factor_;\n    }, i.prototype.at = function(s) {\n      return this.data_[s];\n    }, i.prototype.load_factor = function() {\n      return this.size_ / this.length();\n    }, i.prototype.max_load_factor = function(s) {\n      if (s === void 0 && (s = null), s === null)\n        return this.max_load_factor_;\n      this.max_load_factor_ = s;\n    }, i.prototype.hash_function = function() {\n      return this.hasher_;\n    }, i.prototype.index = function(s) {\n      return this.hasher_(this.fetcher_(s)) % this.length();\n    }, i.prototype.insert = function(s) {\n      var o = this.capacity();\n      ++this.size_ > o && this.reserve(o * 2);\n      var a = this.index(s);\n      this.data_[a].push(s);\n    }, i.prototype.erase = function(s) {\n      for (var o = this.index(s), a = this.data_[o], c = 0; c < a.length; ++c)\n        if (a[c] === s) {\n          a.splice(c, 1), --this.size_;\n          break;\n        }\n    }, i;\n  }();\n  Vt.HashBuckets = e;\n  var r = 10, n = 1;\n  return Vt;\n}\nvar So;\nfunction ed() {\n  if (So)\n    return Wt;\n  So = 1;\n  var t = S && S.__extends || function() {\n    var o = function(a, c) {\n      return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(l, f) {\n        l.__proto__ = f;\n      } || function(l, f) {\n        for (var u in f)\n          Object.prototype.hasOwnProperty.call(f, u) && (l[u] = f[u]);\n      }, o(a, c);\n    };\n    return function(a, c) {\n      if (typeof c != \"function\" && c !== null)\n        throw new TypeError(\"Class extends value \" + String(c) + \" is not a constructor or null\");\n      o(a, c);\n      function l() {\n        this.constructor = a;\n      }\n      a.prototype = c === null ? Object.create(c) : (l.prototype = c.prototype, new l());\n    };\n  }(), e = S && S.__read || function(o, a) {\n    var c = typeof Symbol == \"function\" && o[Symbol.iterator];\n    if (!c)\n      return o;\n    var l = c.call(o), f, u = [], h;\n    try {\n      for (; (a === void 0 || a-- > 0) && !(f = l.next()).done; )\n        u.push(f.value);\n    } catch (d) {\n      h = { error: d };\n    } finally {\n      try {\n        f && !f.done && (c = l.return) && c.call(l);\n      } finally {\n        if (h)\n          throw h.error;\n      }\n    }\n    return u;\n  }, r = S && S.__values || function(o) {\n    var a = typeof Symbol == \"function\" && Symbol.iterator, c = a && o[a], l = 0;\n    if (c)\n      return c.call(o);\n    if (o && typeof o.length == \"number\")\n      return {\n        next: function() {\n          return o && l >= o.length && (o = void 0), { value: o && o[l++], done: !o };\n        }\n      };\n    throw new TypeError(a ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n  };\n  Object.defineProperty(Wt, \"__esModule\", { value: !0 }), Wt.SetHashBuckets = void 0;\n  var n = Ra(), i = function(o) {\n    t(a, o);\n    function a(c, l, f) {\n      var u = o.call(this, s, l) || this;\n      return u.source_ = c, u.key_eq_ = f, u;\n    }\n    return a._Swap_source = function(c, l) {\n      var f;\n      f = e([l.source_, c.source_], 2), c.source_ = f[0], l.source_ = f[1];\n    }, a.prototype.key_eq = function() {\n      return this.key_eq_;\n    }, a.prototype.find = function(c) {\n      var l, f, u = this.hash_function()(c) % this.length(), h = this.at(u);\n      try {\n        for (var d = r(h), p = d.next(); !p.done; p = d.next()) {\n          var y = p.value;\n          if (this.key_eq_(y.value, c))\n            return y;\n        }\n      } catch (g) {\n        l = { error: g };\n      } finally {\n        try {\n          p && !p.done && (f = d.return) && f.call(d);\n        } finally {\n          if (l)\n            throw l.error;\n        }\n      }\n      return this.source_.end();\n    }, a;\n  }(n.HashBuckets);\n  Wt.SetHashBuckets = i;\n  function s(o) {\n    return o.value;\n  }\n  return Wt;\n}\nvar st = {}, Oo;\nfunction Ta() {\n  if (Oo)\n    return st;\n  Oo = 1, Object.defineProperty(st, \"__esModule\", { value: !0 }), st.make_pair = st.Pair = void 0;\n  var t = wi(), e = _i(), r = function() {\n    function i(s, o) {\n      this.first = s, this.second = o;\n    }\n    return i.prototype.equals = function(s) {\n      return (0, e.equal_to)(this.first, s.first) && (0, e.equal_to)(this.second, s.second);\n    }, i.prototype.less = function(s) {\n      return (0, e.equal_to)(this.first, s.first) === !1 ? (0, e.less)(this.first, s.first) : (0, e.less)(this.second, s.second);\n    }, i.prototype.hashCode = function() {\n      return (0, t.hash)(this.first, this.second);\n    }, i;\n  }();\n  st.Pair = r;\n  function n(i, s) {\n    return new r(i, s);\n  }\n  return st.make_pair = n, st;\n}\nvar Ao;\nfunction td() {\n  return Ao || (Ao = 1, function(t) {\n    var e = S && S.__extends || function() {\n      var f = function(u, h) {\n        return f = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, p) {\n          d.__proto__ = p;\n        } || function(d, p) {\n          for (var y in p)\n            Object.prototype.hasOwnProperty.call(p, y) && (d[y] = p[y]);\n        }, f(u, h);\n      };\n      return function(u, h) {\n        if (typeof h != \"function\" && h !== null)\n          throw new TypeError(\"Class extends value \" + String(h) + \" is not a constructor or null\");\n        f(u, h);\n        function d() {\n          this.constructor = u;\n        }\n        u.prototype = h === null ? Object.create(h) : (d.prototype = h.prototype, new d());\n      };\n    }(), r = S && S.__read || function(f, u) {\n      var h = typeof Symbol == \"function\" && f[Symbol.iterator];\n      if (!h)\n        return f;\n      var d = h.call(f), p, y = [], g;\n      try {\n        for (; (u === void 0 || u-- > 0) && !(p = d.next()).done; )\n          y.push(p.value);\n      } catch (v) {\n        g = { error: v };\n      } finally {\n        try {\n          p && !p.done && (h = d.return) && h.call(d);\n        } finally {\n          if (g)\n            throw g.error;\n        }\n      }\n      return y;\n    }, n = S && S.__spreadArray || function(f, u, h) {\n      if (h || arguments.length === 2)\n        for (var d = 0, p = u.length, y; d < p; d++)\n          (y || !(d in u)) && (y || (y = Array.prototype.slice.call(u, 0, d)), y[d] = u[d]);\n      return f.concat(y || Array.prototype.slice.call(u));\n    };\n    Object.defineProperty(t, \"__esModule\", { value: !0 }), t.HashSet = void 0;\n    var i = Gh(), s = Aa(), o = Qh(), a = ed(), c = Ta(), l = function(f) {\n      e(u, f);\n      function u() {\n        for (var h = [], d = 0; d < arguments.length; d++)\n          h[d] = arguments[d];\n        var p = f.call(this, function(y) {\n          return new o.SetElementList(y);\n        }) || this;\n        return s.IHashContainer.construct.apply(s.IHashContainer, n([\n          p,\n          u,\n          function(y, g) {\n            p.buckets_ = new a.SetHashBuckets(p, y, g);\n          }\n        ], r(h), !1)), p;\n      }\n      return u.prototype.clear = function() {\n        this.buckets_.clear(), f.prototype.clear.call(this);\n      }, u.prototype.swap = function(h) {\n        var d, p;\n        d = r([h.data_, this.data_], 2), this.data_ = d[0], h.data_ = d[1], o.SetElementList._Swap_associative(this.data_, h.data_), a.SetHashBuckets._Swap_source(this.buckets_, h.buckets_), p = r([h.buckets_, this.buckets_], 2), this.buckets_ = p[0], h.buckets_ = p[1];\n      }, u.prototype.find = function(h) {\n        return this.buckets_.find(h);\n      }, u.prototype.begin = function(h) {\n        return h === void 0 && (h = null), h === null ? f.prototype.begin.call(this) : this.buckets_.at(h)[0];\n      }, u.prototype.end = function(h) {\n        if (h === void 0 && (h = null), h === null)\n          return f.prototype.end.call(this);\n        var d = this.buckets_.at(h);\n        return d[d.length - 1].next();\n      }, u.prototype.rbegin = function(h) {\n        return h === void 0 && (h = null), this.end(h).reverse();\n      }, u.prototype.rend = function(h) {\n        return h === void 0 && (h = null), this.begin(h).reverse();\n      }, u.prototype.bucket_count = function() {\n        return this.buckets_.length();\n      }, u.prototype.bucket_size = function(h) {\n        return this.buckets_.at(h).length;\n      }, u.prototype.load_factor = function() {\n        return this.buckets_.load_factor();\n      }, u.prototype.hash_function = function() {\n        return this.buckets_.hash_function();\n      }, u.prototype.key_eq = function() {\n        return this.buckets_.key_eq();\n      }, u.prototype.bucket = function(h) {\n        return this.hash_function()(h) % this.buckets_.length();\n      }, u.prototype.max_load_factor = function(h) {\n        return h === void 0 && (h = null), this.buckets_.max_load_factor(h);\n      }, u.prototype.reserve = function(h) {\n        this.buckets_.reserve(h);\n      }, u.prototype.rehash = function(h) {\n        this.buckets_.rehash(h);\n      }, u.prototype._Insert_by_key = function(h) {\n        var d = this.find(h);\n        return d.equals(this.end()) === !1 ? new c.Pair(d, !1) : (this.data_.push(h), d = d.prev(), this._Handle_insert(d, d.next()), new c.Pair(d, !0));\n      }, u.prototype._Insert_by_hint = function(h, d) {\n        var p = this.find(d);\n        return p.equals(this.end()) === !0 && (p = this.data_.insert(h, d), this._Handle_insert(p, p.next())), p;\n      }, u.prototype._Handle_insert = function(h, d) {\n        for (; !h.equals(d); h = h.next())\n          this.buckets_.insert(h);\n      }, u.prototype._Handle_erase = function(h, d) {\n        for (; !h.equals(d); h = h.next())\n          this.buckets_.erase(h);\n      }, u;\n    }(i.UniqueSet);\n    t.HashSet = l, function(f) {\n      f.Iterator = o.SetElementList.Iterator, f.ReverseIterator = o.SetElementList.ReverseIterator;\n    }(l = t.HashSet || (t.HashSet = {})), t.HashSet = l;\n  }(vn)), vn;\n}\nvar En = {}, Gt = {}, Zt = {}, Co;\nfunction rd() {\n  if (Co)\n    return Zt;\n  Co = 1;\n  var t = S && S.__extends || function() {\n    var i = function(s, o) {\n      return i = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(a, c) {\n        a.__proto__ = c;\n      } || function(a, c) {\n        for (var l in c)\n          Object.prototype.hasOwnProperty.call(c, l) && (a[l] = c[l]);\n      }, i(s, o);\n    };\n    return function(s, o) {\n      if (typeof o != \"function\" && o !== null)\n        throw new TypeError(\"Class extends value \" + String(o) + \" is not a constructor or null\");\n      i(s, o);\n      function a() {\n        this.constructor = s;\n      }\n      s.prototype = o === null ? Object.create(o) : (a.prototype = o.prototype, new a());\n    };\n  }();\n  Object.defineProperty(Zt, \"__esModule\", { value: !0 }), Zt.MapContainer = void 0;\n  var e = bi(), r = vi(), n = function(i) {\n    t(s, i);\n    function s(o) {\n      var a = i.call(this) || this;\n      return a.data_ = o(a), a;\n    }\n    return s.prototype.assign = function(o, a) {\n      this.clear(), this.insert(o, a);\n    }, s.prototype.clear = function() {\n      this.data_.clear();\n    }, s.prototype.begin = function() {\n      return this.data_.begin();\n    }, s.prototype.end = function() {\n      return this.data_.end();\n    }, s.prototype.has = function(o) {\n      return !this.find(o).equals(this.end());\n    }, s.prototype.size = function() {\n      return this.data_.size();\n    }, s.prototype.push = function() {\n      for (var o = [], a = 0; a < arguments.length; a++)\n        o[a] = arguments[a];\n      var c = new r.NativeArrayIterator(o, 0), l = new r.NativeArrayIterator(o, o.length);\n      return this.insert(c, l), this.size();\n    }, s.prototype.insert = function() {\n      for (var o = [], a = 0; a < arguments.length; a++)\n        o[a] = arguments[a];\n      return o.length === 1 ? this.emplace(o[0].first, o[0].second) : o[0].next instanceof Function && o[1].next instanceof Function ? this._Insert_by_range(o[0], o[1]) : this.emplace_hint(o[0], o[1].first, o[1].second);\n    }, s.prototype.erase = function() {\n      for (var o = [], a = 0; a < arguments.length; a++)\n        o[a] = arguments[a];\n      return o.length === 1 && (!(o[0] instanceof this.end().constructor) || o[0].source() !== this) ? this._Erase_by_key(o[0]) : o.length === 1 ? this._Erase_by_range(o[0]) : this._Erase_by_range(o[0], o[1]);\n    }, s.prototype._Erase_by_range = function(o, a) {\n      a === void 0 && (a = o.next());\n      var c = this.data_.erase(o, a);\n      return this._Handle_erase(o, a), c;\n    }, s;\n  }(e.Container);\n  return Zt.MapContainer = n, Zt;\n}\nvar Io;\nfunction nd() {\n  if (Io)\n    return Gt;\n  Io = 1;\n  var t = S && S.__extends || function() {\n    var o = function(a, c) {\n      return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(l, f) {\n        l.__proto__ = f;\n      } || function(l, f) {\n        for (var u in f)\n          Object.prototype.hasOwnProperty.call(f, u) && (l[u] = f[u]);\n      }, o(a, c);\n    };\n    return function(a, c) {\n      if (typeof c != \"function\" && c !== null)\n        throw new TypeError(\"Class extends value \" + String(c) + \" is not a constructor or null\");\n      o(a, c);\n      function l() {\n        this.constructor = a;\n      }\n      a.prototype = c === null ? Object.create(c) : (l.prototype = c.prototype, new l());\n    };\n  }(), e = S && S.__read || function(o, a) {\n    var c = typeof Symbol == \"function\" && o[Symbol.iterator];\n    if (!c)\n      return o;\n    var l = c.call(o), f, u = [], h;\n    try {\n      for (; (a === void 0 || a-- > 0) && !(f = l.next()).done; )\n        u.push(f.value);\n    } catch (d) {\n      h = { error: d };\n    } finally {\n      try {\n        f && !f.done && (c = l.return) && c.call(l);\n      } finally {\n        if (h)\n          throw h.error;\n      }\n    }\n    return u;\n  }, r = S && S.__spreadArray || function(o, a, c) {\n    if (c || arguments.length === 2)\n      for (var l = 0, f = a.length, u; l < f; l++)\n        (u || !(l in a)) && (u || (u = Array.prototype.slice.call(a, 0, l)), u[l] = a[l]);\n    return o.concat(u || Array.prototype.slice.call(a));\n  };\n  Object.defineProperty(Gt, \"__esModule\", { value: !0 }), Gt.UniqueMap = void 0;\n  var n = rd(), i = Wr(), s = function(o) {\n    t(a, o);\n    function a() {\n      return o !== null && o.apply(this, arguments) || this;\n    }\n    return a.prototype.count = function(c) {\n      return this.find(c).equals(this.end()) ? 0 : 1;\n    }, a.prototype.get = function(c) {\n      var l = this.find(c);\n      if (l.equals(this.end()) === !0)\n        throw i.ErrorGenerator.key_nout_found(this, \"get\", c);\n      return l.second;\n    }, a.prototype.take = function(c, l) {\n      var f = this.find(c);\n      return f.equals(this.end()) ? this.emplace(c, l()).first.second : f.second;\n    }, a.prototype.set = function(c, l) {\n      this.insert_or_assign(c, l);\n    }, a.prototype.insert = function() {\n      for (var c = [], l = 0; l < arguments.length; l++)\n        c[l] = arguments[l];\n      return o.prototype.insert.apply(this, r([], e(c), !1));\n    }, a.prototype._Insert_by_range = function(c, l) {\n      for (var f = c; !f.equals(l); f = f.next())\n        this.emplace(f.value.first, f.value.second);\n    }, a.prototype.insert_or_assign = function() {\n      for (var c = [], l = 0; l < arguments.length; l++)\n        c[l] = arguments[l];\n      if (c.length === 2)\n        return this._Insert_or_assign_with_key_value(c[0], c[1]);\n      if (c.length === 3)\n        return this._Insert_or_assign_with_hint(c[0], c[1], c[2]);\n    }, a.prototype._Insert_or_assign_with_key_value = function(c, l) {\n      var f = this.emplace(c, l);\n      return f.second === !1 && (f.first.second = l), f;\n    }, a.prototype._Insert_or_assign_with_hint = function(c, l, f) {\n      var u = this.emplace_hint(c, l, f);\n      return u.second !== f && (u.second = f), u;\n    }, a.prototype.extract = function(c) {\n      return c instanceof this.end().constructor ? this._Extract_by_iterator(c) : this._Extract_by_key(c);\n    }, a.prototype._Extract_by_key = function(c) {\n      var l = this.find(c);\n      if (l.equals(this.end()) === !0)\n        throw i.ErrorGenerator.key_nout_found(this, \"extract\", c);\n      var f = l.value;\n      return this._Erase_by_range(l), f;\n    }, a.prototype._Extract_by_iterator = function(c) {\n      return c.equals(this.end()) === !0 ? this.end() : (this._Erase_by_range(c), c);\n    }, a.prototype._Erase_by_key = function(c) {\n      var l = this.find(c);\n      return l.equals(this.end()) === !0 ? 0 : (this._Erase_by_range(l), 1);\n    }, a.prototype.merge = function(c) {\n      for (var l = c.begin(); !l.equals(c.end()); )\n        this.has(l.first) === !1 ? (this.insert(l.value), l = c.erase(l)) : l = l.next();\n    }, a;\n  }(n.MapContainer);\n  return Gt.UniqueMap = s, Gt;\n}\nvar kn = {}, Ro;\nfunction id() {\n  return Ro || (Ro = 1, function(t) {\n    var e = S && S.__extends || function() {\n      var a = function(c, l) {\n        return a = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(f, u) {\n          f.__proto__ = u;\n        } || function(f, u) {\n          for (var h in u)\n            Object.prototype.hasOwnProperty.call(u, h) && (f[h] = u[h]);\n        }, a(c, l);\n      };\n      return function(c, l) {\n        if (typeof l != \"function\" && l !== null)\n          throw new TypeError(\"Class extends value \" + String(l) + \" is not a constructor or null\");\n        a(c, l);\n        function f() {\n          this.constructor = c;\n        }\n        c.prototype = l === null ? Object.create(l) : (f.prototype = l.prototype, new f());\n      };\n    }(), r = S && S.__read || function(a, c) {\n      var l = typeof Symbol == \"function\" && a[Symbol.iterator];\n      if (!l)\n        return a;\n      var f = l.call(a), u, h = [], d;\n      try {\n        for (; (c === void 0 || c-- > 0) && !(u = f.next()).done; )\n          h.push(u.value);\n      } catch (p) {\n        d = { error: p };\n      } finally {\n        try {\n          u && !u.done && (l = f.return) && l.call(f);\n        } finally {\n          if (d)\n            throw d.error;\n        }\n      }\n      return h;\n    };\n    Object.defineProperty(t, \"__esModule\", { value: !0 }), t.MapElementList = void 0;\n    var n = Ca(), i = mi(), s = Ia(), o = function(a) {\n      e(c, a);\n      function c(l) {\n        var f = a.call(this) || this;\n        return f.associative_ = l, f;\n      }\n      return c.prototype._Create_iterator = function(l, f, u) {\n        return c.Iterator.create(this, l, f, u);\n      }, c._Swap_associative = function(l, f) {\n        var u;\n        u = r([f.associative_, l.associative_], 2), l.associative_ = u[0], f.associative_ = u[1];\n      }, c.prototype.associative = function() {\n        return this.associative_;\n      }, c;\n    }(n.ListContainer);\n    t.MapElementList = o, function(a) {\n      var c = function(f) {\n        e(u, f);\n        function u(h, d, p, y) {\n          var g = f.call(this, d, p, y) || this;\n          return g.list_ = h, g;\n        }\n        return u.create = function(h, d, p, y) {\n          return new u(h, d, p, y);\n        }, u.prototype.reverse = function() {\n          return new l(this);\n        }, u.prototype.source = function() {\n          return this.list_.associative();\n        }, Object.defineProperty(u.prototype, \"first\", {\n          get: function() {\n            return this.value.first;\n          },\n          enumerable: !1,\n          configurable: !0\n        }), Object.defineProperty(u.prototype, \"second\", {\n          get: function() {\n            return this.value.second;\n          },\n          set: function(h) {\n            this.value.second = h;\n          },\n          enumerable: !1,\n          configurable: !0\n        }), u;\n      }(i.ListIterator);\n      a.Iterator = c;\n      var l = function(f) {\n        e(u, f);\n        function u() {\n          return f !== null && f.apply(this, arguments) || this;\n        }\n        return u.prototype._Create_neighbor = function(h) {\n          return new u(h);\n        }, Object.defineProperty(u.prototype, \"first\", {\n          get: function() {\n            return this.base_.first;\n          },\n          enumerable: !1,\n          configurable: !0\n        }), Object.defineProperty(u.prototype, \"second\", {\n          get: function() {\n            return this.base_.second;\n          },\n          set: function(h) {\n            this.base_.second = h;\n          },\n          enumerable: !1,\n          configurable: !0\n        }), u;\n      }(s.ReverseIterator);\n      a.ReverseIterator = l;\n    }(o = t.MapElementList || (t.MapElementList = {})), t.MapElementList = o;\n  }(kn)), kn;\n}\nvar Yt = {}, To;\nfunction od() {\n  if (To)\n    return Yt;\n  To = 1;\n  var t = S && S.__extends || function() {\n    var o = function(a, c) {\n      return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(l, f) {\n        l.__proto__ = f;\n      } || function(l, f) {\n        for (var u in f)\n          Object.prototype.hasOwnProperty.call(f, u) && (l[u] = f[u]);\n      }, o(a, c);\n    };\n    return function(a, c) {\n      if (typeof c != \"function\" && c !== null)\n        throw new TypeError(\"Class extends value \" + String(c) + \" is not a constructor or null\");\n      o(a, c);\n      function l() {\n        this.constructor = a;\n      }\n      a.prototype = c === null ? Object.create(c) : (l.prototype = c.prototype, new l());\n    };\n  }(), e = S && S.__read || function(o, a) {\n    var c = typeof Symbol == \"function\" && o[Symbol.iterator];\n    if (!c)\n      return o;\n    var l = c.call(o), f, u = [], h;\n    try {\n      for (; (a === void 0 || a-- > 0) && !(f = l.next()).done; )\n        u.push(f.value);\n    } catch (d) {\n      h = { error: d };\n    } finally {\n      try {\n        f && !f.done && (c = l.return) && c.call(l);\n      } finally {\n        if (h)\n          throw h.error;\n      }\n    }\n    return u;\n  }, r = S && S.__values || function(o) {\n    var a = typeof Symbol == \"function\" && Symbol.iterator, c = a && o[a], l = 0;\n    if (c)\n      return c.call(o);\n    if (o && typeof o.length == \"number\")\n      return {\n        next: function() {\n          return o && l >= o.length && (o = void 0), { value: o && o[l++], done: !o };\n        }\n      };\n    throw new TypeError(a ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n  };\n  Object.defineProperty(Yt, \"__esModule\", { value: !0 }), Yt.MapHashBuckets = void 0;\n  var n = Ra(), i = function(o) {\n    t(a, o);\n    function a(c, l, f) {\n      var u = o.call(this, s, l) || this;\n      return u.source_ = c, u.key_eq_ = f, u;\n    }\n    return a._Swap_source = function(c, l) {\n      var f;\n      f = e([l.source_, c.source_], 2), c.source_ = f[0], l.source_ = f[1];\n    }, a.prototype.key_eq = function() {\n      return this.key_eq_;\n    }, a.prototype.find = function(c) {\n      var l, f, u = this.hash_function()(c) % this.length(), h = this.at(u);\n      try {\n        for (var d = r(h), p = d.next(); !p.done; p = d.next()) {\n          var y = p.value;\n          if (this.key_eq_(y.first, c))\n            return y;\n        }\n      } catch (g) {\n        l = { error: g };\n      } finally {\n        try {\n          p && !p.done && (f = d.return) && f.call(d);\n        } finally {\n          if (l)\n            throw l.error;\n        }\n      }\n      return this.source_.end();\n    }, a;\n  }(n.HashBuckets);\n  Yt.MapHashBuckets = i;\n  function s(o) {\n    return o.first;\n  }\n  return Yt;\n}\nvar Jt = {}, Po;\nfunction sd() {\n  if (Po)\n    return Jt;\n  Po = 1, Object.defineProperty(Jt, \"__esModule\", { value: !0 }), Jt.Entry = void 0;\n  var t = wi(), e = _i(), r = function() {\n    function n(i, s) {\n      this.first = i, this.second = s;\n    }\n    return n.prototype.equals = function(i) {\n      return (0, e.equal_to)(this.first, i.first);\n    }, n.prototype.less = function(i) {\n      return (0, e.less)(this.first, i.first);\n    }, n.prototype.hashCode = function() {\n      return (0, t.hash)(this.first);\n    }, n;\n  }();\n  return Jt.Entry = r, Jt;\n}\nvar Bo;\nfunction ad() {\n  return Bo || (Bo = 1, function(t) {\n    var e = S && S.__extends || function() {\n      var u = function(h, d) {\n        return u = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(p, y) {\n          p.__proto__ = y;\n        } || function(p, y) {\n          for (var g in y)\n            Object.prototype.hasOwnProperty.call(y, g) && (p[g] = y[g]);\n        }, u(h, d);\n      };\n      return function(h, d) {\n        if (typeof d != \"function\" && d !== null)\n          throw new TypeError(\"Class extends value \" + String(d) + \" is not a constructor or null\");\n        u(h, d);\n        function p() {\n          this.constructor = h;\n        }\n        h.prototype = d === null ? Object.create(d) : (p.prototype = d.prototype, new p());\n      };\n    }(), r = S && S.__read || function(u, h) {\n      var d = typeof Symbol == \"function\" && u[Symbol.iterator];\n      if (!d)\n        return u;\n      var p = d.call(u), y, g = [], v;\n      try {\n        for (; (h === void 0 || h-- > 0) && !(y = p.next()).done; )\n          g.push(y.value);\n      } catch (_) {\n        v = { error: _ };\n      } finally {\n        try {\n          y && !y.done && (d = p.return) && d.call(p);\n        } finally {\n          if (v)\n            throw v.error;\n        }\n      }\n      return g;\n    }, n = S && S.__spreadArray || function(u, h, d) {\n      if (d || arguments.length === 2)\n        for (var p = 0, y = h.length, g; p < y; p++)\n          (g || !(p in h)) && (g || (g = Array.prototype.slice.call(h, 0, p)), g[p] = h[p]);\n      return u.concat(g || Array.prototype.slice.call(h));\n    };\n    Object.defineProperty(t, \"__esModule\", { value: !0 }), t.HashMap = void 0;\n    var i = nd(), s = Aa(), o = id(), a = od(), c = sd(), l = Ta(), f = function(u) {\n      e(h, u);\n      function h() {\n        for (var d = [], p = 0; p < arguments.length; p++)\n          d[p] = arguments[p];\n        var y = u.call(this, function(g) {\n          return new o.MapElementList(g);\n        }) || this;\n        return s.IHashContainer.construct.apply(s.IHashContainer, n([\n          y,\n          h,\n          function(g, v) {\n            y.buckets_ = new a.MapHashBuckets(y, g, v);\n          }\n        ], r(d), !1)), y;\n      }\n      return h.prototype.clear = function() {\n        this.buckets_.clear(), u.prototype.clear.call(this);\n      }, h.prototype.swap = function(d) {\n        var p, y;\n        p = r([d.data_, this.data_], 2), this.data_ = p[0], d.data_ = p[1], o.MapElementList._Swap_associative(this.data_, d.data_), a.MapHashBuckets._Swap_source(this.buckets_, d.buckets_), y = r([d.buckets_, this.buckets_], 2), this.buckets_ = y[0], d.buckets_ = y[1];\n      }, h.prototype.find = function(d) {\n        return this.buckets_.find(d);\n      }, h.prototype.begin = function(d) {\n        return d === void 0 && (d = null), d === null ? u.prototype.begin.call(this) : this.buckets_.at(d)[0];\n      }, h.prototype.end = function(d) {\n        if (d === void 0 && (d = null), d === null)\n          return u.prototype.end.call(this);\n        var p = this.buckets_.at(d);\n        return p[p.length - 1].next();\n      }, h.prototype.rbegin = function(d) {\n        return d === void 0 && (d = null), this.end(d).reverse();\n      }, h.prototype.rend = function(d) {\n        return d === void 0 && (d = null), this.begin(d).reverse();\n      }, h.prototype.bucket_count = function() {\n        return this.buckets_.length();\n      }, h.prototype.bucket_size = function(d) {\n        return this.buckets_.at(d).length;\n      }, h.prototype.load_factor = function() {\n        return this.buckets_.load_factor();\n      }, h.prototype.hash_function = function() {\n        return this.buckets_.hash_function();\n      }, h.prototype.key_eq = function() {\n        return this.buckets_.key_eq();\n      }, h.prototype.bucket = function(d) {\n        return this.hash_function()(d) % this.buckets_.length();\n      }, h.prototype.max_load_factor = function(d) {\n        return d === void 0 && (d = null), this.buckets_.max_load_factor(d);\n      }, h.prototype.reserve = function(d) {\n        this.buckets_.reserve(d);\n      }, h.prototype.rehash = function(d) {\n        this.buckets_.rehash(d);\n      }, h.prototype.emplace = function(d, p) {\n        var y = this.find(d);\n        return y.equals(this.end()) === !1 ? new l.Pair(y, !1) : (this.data_.push(new c.Entry(d, p)), y = y.prev(), this._Handle_insert(y, y.next()), new l.Pair(y, !0));\n      }, h.prototype.emplace_hint = function(d, p, y) {\n        var g = this.find(p);\n        return g.equals(this.end()) === !0 && (g = this.data_.insert(d, new c.Entry(p, y)), this._Handle_insert(g, g.next())), g;\n      }, h.prototype._Handle_insert = function(d, p) {\n        for (; !d.equals(p); d = d.next())\n          this.buckets_.insert(d);\n      }, h.prototype._Handle_erase = function(d, p) {\n        for (; !d.equals(p); d = d.next())\n          this.buckets_.erase(d);\n      }, h;\n    }(i.UniqueMap);\n    t.HashMap = f, function(u) {\n      u.Iterator = o.MapElementList.Iterator, u.ReverseIterator = o.MapElementList.ReverseIterator;\n    }(f = t.HashMap || (t.HashMap = {})), t.HashMap = f;\n  }(En)), En;\n}\nvar Lo;\nfunction cd() {\n  if (Lo)\n    return _r;\n  Lo = 1;\n  var t = S && S.__values || function(i) {\n    var s = typeof Symbol == \"function\" && i[Symbol.iterator], o = 0;\n    return s ? s.call(i) : {\n      next: function() {\n        return i && o >= i.length && (i = void 0), { value: i && i[o++], done: !i };\n      }\n    };\n  };\n  Object.defineProperty(_r, \"__esModule\", { value: !0 });\n  var e = td(), r = ad(), n = function() {\n    function i() {\n      this.listeners_ = new r.HashMap(), this.created_at_ = new Date();\n    }\n    return i.prototype.dispatchEvent = function(s) {\n      var o, a, c = this.listeners_.find(s.type);\n      if (!c.equals(this.listeners_.end())) {\n        s.target = this, s.timeStamp = new Date().getTime() - this.created_at_.getTime();\n        try {\n          for (var l = t(c.second), f = l.next(); !f.done; f = l.next()) {\n            var u = f.value;\n            u(s);\n          }\n        } catch (h) {\n          o = { error: h };\n        } finally {\n          try {\n            f && !f.done && (a = l.return) && a.call(l);\n          } finally {\n            if (o)\n              throw o.error;\n          }\n        }\n      }\n    }, i.prototype.addEventListener = function(s, o) {\n      var a = this.listeners_.find(s);\n      a.equals(this.listeners_.end()) && (a = this.listeners_.emplace(s, new e.HashSet()).first), a.second.insert(o);\n    }, i.prototype.removeEventListener = function(s, o) {\n      var a = this.listeners_.find(s);\n      a.equals(this.listeners_.end()) || (a.second.erase(o), a.second.empty() && this.listeners_.erase(a));\n    }, i;\n  }();\n  return _r.EventTarget = n, _r;\n}\nvar mr = {}, $o;\nfunction Vr() {\n  if ($o)\n    return mr;\n  $o = 1, Object.defineProperty(mr, \"__esModule\", { value: !0 });\n  var t = function() {\n    function e(r, n) {\n      this.type = r, n && Object.assign(this, n);\n    }\n    return e;\n  }();\n  return mr.Event = t, mr;\n}\nvar xr = {}, qo;\nfunction ud() {\n  if (qo)\n    return xr;\n  qo = 1;\n  var t = S && S.__extends || function() {\n    var n = function(i, s) {\n      return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(o, a) {\n        o.__proto__ = a;\n      } || function(o, a) {\n        for (var c in a)\n          a.hasOwnProperty(c) && (o[c] = a[c]);\n      }, n(i, s);\n    };\n    return function(i, s) {\n      n(i, s);\n      function o() {\n        this.constructor = i;\n      }\n      i.prototype = s === null ? Object.create(s) : (o.prototype = s.prototype, new o());\n    };\n  }();\n  Object.defineProperty(xr, \"__esModule\", { value: !0 });\n  var e = Vr(), r = function(n) {\n    t(i, n);\n    function i(s, o) {\n      return n.call(this, s, o) || this;\n    }\n    return i;\n  }(e.Event);\n  return xr.CloseEvent = r, xr;\n}\nvar Er = {}, No;\nfunction ld() {\n  if (No)\n    return Er;\n  No = 1;\n  var t = S && S.__extends || function() {\n    var n = function(i, s) {\n      return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(o, a) {\n        o.__proto__ = a;\n      } || function(o, a) {\n        for (var c in a)\n          a.hasOwnProperty(c) && (o[c] = a[c]);\n      }, n(i, s);\n    };\n    return function(i, s) {\n      n(i, s);\n      function o() {\n        this.constructor = i;\n      }\n      i.prototype = s === null ? Object.create(s) : (o.prototype = s.prototype, new o());\n    };\n  }();\n  Object.defineProperty(Er, \"__esModule\", { value: !0 });\n  var e = Vr(), r = function(n) {\n    t(i, n);\n    function i(s, o) {\n      return n.call(this, s, o) || this;\n    }\n    return i;\n  }(e.Event);\n  return Er.MessageEvent = r, Er;\n}\nvar kr = {}, Uo;\nfunction fd() {\n  if (Uo)\n    return kr;\n  Uo = 1;\n  var t = S && S.__extends || function() {\n    var n = function(i, s) {\n      return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(o, a) {\n        o.__proto__ = a;\n      } || function(o, a) {\n        for (var c in a)\n          a.hasOwnProperty(c) && (o[c] = a[c]);\n      }, n(i, s);\n    };\n    return function(i, s) {\n      n(i, s);\n      function o() {\n        this.constructor = i;\n      }\n      i.prototype = s === null ? Object.create(s) : (o.prototype = s.prototype, new o());\n    };\n  }();\n  Object.defineProperty(kr, \"__esModule\", { value: !0 });\n  var e = Vr(), r = function(n) {\n    t(i, n);\n    function i(s, o) {\n      return n.call(this, s, o) || this;\n    }\n    return i;\n  }(e.Event);\n  return kr.ErrorEvent = r, kr;\n}\nvar jo;\nfunction hd() {\n  return jo || (jo = 1, function(t) {\n    var e = S && S.__extends || function() {\n      var u = function(h, d) {\n        return u = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(p, y) {\n          p.__proto__ = y;\n        } || function(p, y) {\n          for (var g in y)\n            y.hasOwnProperty(g) && (p[g] = y[g]);\n        }, u(h, d);\n      };\n      return function(h, d) {\n        u(h, d);\n        function p() {\n          this.constructor = h;\n        }\n        h.prototype = d === null ? Object.create(d) : (p.prototype = d.prototype, new p());\n      };\n    }(), r = S && S.__assign || function() {\n      return r = Object.assign || function(u) {\n        for (var h, d = 1, p = arguments.length; d < p; d++) {\n          h = arguments[d];\n          for (var y in h)\n            Object.prototype.hasOwnProperty.call(h, y) && (u[y] = h[y]);\n        }\n        return u;\n      }, r.apply(this, arguments);\n    };\n    Object.defineProperty(t, \"__esModule\", { value: !0 });\n    var n = zh(), i = cd(), s = Vr(), o = ud(), a = ld(), c = fd(), l = function(u) {\n      e(h, u);\n      function h(d, p) {\n        var y = u.call(this) || this;\n        return y.on_ = {}, y.state_ = h.CONNECTING, y.client_ = new n.client(), y.client_.on(\"connect\", y._Handle_connect.bind(y)), y.client_.on(\"connectFailed\", y._Handle_error.bind(y)), typeof p == \"string\" && (p = [p]), y.client_.connect(d, p), y;\n      }\n      return h.prototype.close = function(d, p) {\n        this.state_ = h.CLOSING, d === void 0 ? this.connection_.sendCloseFrame() : this.connection_.sendCloseFrame(d, p, !0);\n      }, h.prototype.send = function(d) {\n        if (typeof d.valueOf() == \"string\")\n          this.connection_.sendUTF(d);\n        else {\n          var p = void 0;\n          d instanceof Buffer ? p = d : d instanceof Blob ? p = new Buffer(d, \"blob\") : d.buffer ? p = new Buffer(d.buffer) : p = new Buffer(d), this.connection_.sendBytes(p);\n        }\n      }, Object.defineProperty(h.prototype, \"url\", {\n        get: function() {\n          return this.client_.url.href;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(h.prototype, \"protocol\", {\n        get: function() {\n          return this.client_.protocols ? this.client_.protocols[0] : \"\";\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(h.prototype, \"extensions\", {\n        get: function() {\n          return this.connection_ && this.connection_.extensions ? this.connection_.extensions[0].name : \"\";\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(h.prototype, \"readyState\", {\n        get: function() {\n          return this.state_;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(h.prototype, \"bufferedAmount\", {\n        get: function() {\n          return this.connection_.bytesWaitingToFlush;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(h.prototype, \"binaryType\", {\n        get: function() {\n          return \"arraybuffer\";\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(h.prototype, \"onopen\", {\n        get: function() {\n          return this.on_.open;\n        },\n        set: function(d) {\n          this._Set_on(\"open\", d);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(h.prototype, \"onclose\", {\n        get: function() {\n          return this.on_.close;\n        },\n        set: function(d) {\n          this._Set_on(\"close\", d);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(h.prototype, \"onmessage\", {\n        get: function() {\n          return this.on_.message;\n        },\n        set: function(d) {\n          this._Set_on(\"message\", d);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(h.prototype, \"onerror\", {\n        get: function() {\n          return this.on_.error;\n        },\n        set: function(d) {\n          this._Set_on(\"error\", d);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), h.prototype._Set_on = function(d, p) {\n        this.on_[d] && this.removeEventListener(d, this.on_[d]), this.addEventListener(d, p), this.on_[d] = p;\n      }, h.prototype._Handle_connect = function(d) {\n        this.connection_ = d, this.state_ = h.OPEN, this.connection_.on(\"message\", this._Handle_message.bind(this)), this.connection_.on(\"error\", this._Handle_error.bind(this)), this.connection_.on(\"close\", this._Handle_close.bind(this));\n        var p = new s.Event(\"open\", f);\n        this.dispatchEvent(p);\n      }, h.prototype._Handle_close = function(d, p) {\n        var y = new o.CloseEvent(\"close\", r({}, f, { code: d, reason: p }));\n        this.state_ = h.CLOSED, this.dispatchEvent(y);\n      }, h.prototype._Handle_message = function(d) {\n        var p = new a.MessageEvent(\"message\", r({}, f, { data: d.binaryData ? d.binaryData : d.utf8Data }));\n        this.dispatchEvent(p);\n      }, h.prototype._Handle_error = function(d) {\n        var p = new c.ErrorEvent(\"error\", r({}, f, { error: d, message: d.message }));\n        this.state_ === h.CONNECTING && (this.state_ = h.CLOSED), this.dispatchEvent(p);\n      }, h;\n    }(i.EventTarget);\n    t.WebSocket = l, function(u) {\n      u.CONNECTING = 0, u.OPEN = 1, u.CLOSING = 2, u.CLOSED = 3;\n    }(l = t.WebSocket || (t.WebSocket = {})), t.WebSocket = l;\n    var f = {\n      bubbles: !1,\n      cancelable: !1\n    };\n  }(pn)), pn;\n}\nvar dd = cr;\ndd.is_node() && (S.WebSocket = hd().WebSocket);\nBigInt(1e3), BigInt(1e6), BigInt(1e9), BigInt(1e12);\nBigInt(\"2100000000000000000\");\nBigInt(1e11);\nconst Ho = {\n  payment_hash: 1,\n  payment_secret: 16,\n  description: 13,\n  payee: 19,\n  description_hash: 23,\n  expiry: 6,\n  min_final_cltv_expiry: 24,\n  fallback_address: 9,\n  route_hint: 3,\n  feature_bits: 5,\n  metadata: 27\n};\nfor (let t = 0, e = Object.keys(Ho); t < e.length; t++)\n  e[t], Ho[e[t]].toString();\nfunction pd(t, e) {\n  return t.created_at > e.created_at ? t : e;\n}\nvar yd = [\n  \"wss://nos.lol\",\n  \"wss://relay.nostr.band\",\n  \"wss://relay.f7z.io\",\n  \"wss://relay.damus.io\",\n  \"wss://nostr.mom\",\n  \"wss://no.str.cr\"\n], gd = class extends dt {\n  constructor(e) {\n    super();\n    I(this, \"ndk\");\n    I(this, \"zappedEvent\");\n    I(this, \"zappedUser\");\n    this.ndk = e.ndk, this.zappedEvent = e.zappedEvent, this.zappedUser = e.zappedUser || this.ndk.getUser({ hexpubkey: this.zappedEvent.pubkey });\n  }\n  async getZapEndpoint() {\n    let e, r, n, i;\n    if (this.zappedEvent) {\n      const a = (await this.zappedEvent.getMatchingTags(\"zap\"))[0];\n      if (a)\n        switch (a[2]) {\n          case \"lud06\":\n            e = a[1];\n            break;\n          case \"lud16\":\n            r = a[1];\n            break;\n          default:\n            throw new Error(`Unknown zap tag ${a}`);\n        }\n    }\n    if (this.zappedUser && !e && !r && (this.zappedUser.profile || await this.zappedUser.fetchProfile(), e = (this.zappedUser.profile || {}).lud06, r = (this.zappedUser.profile || {}).lud16), r) {\n      const [a, c] = r.split(\"@\");\n      n = `https://${c}/.well-known/lnurlp/${a}`;\n    } else if (e) {\n      const { words: a } = te.decode(e, 1e3), c = te.fromWords(a);\n      n = new TextDecoder(\"utf-8\").decode(c);\n    }\n    if (!n)\n      throw new Error(\"No zap endpoint found\");\n    const o = await (await fetch(n)).json();\n    return (o == null ? void 0 : o.allowsNostr) && ((o == null ? void 0 : o.nostrPubkey) || (o == null ? void 0 : o.nostrPubKey)) && (i = o.callback), i;\n  }\n  async createZapRequest(e, r, n, i) {\n    const s = await this.getZapEndpoint();\n    if (!s)\n      throw new Error(\"No zap endpoint found\");\n    if (!this.zappedEvent)\n      throw new Error(\"No zapped event found\");\n    const o = Ea.makeZapRequest({\n      profile: this.zappedUser.hexpubkey(),\n      event: null,\n      amount: e,\n      comment: r || \"\",\n      relays: i != null ? i : this.relays()\n    });\n    if (this.zappedEvent) {\n      const u = this.zappedEvent.tagReference();\n      u && o.tags.push(u);\n    }\n    o.tags.push([\"lnurl\", s]);\n    const a = new qe(this.ndk, o);\n    n && (a.tags = a.tags.concat(n)), await a.sign();\n    const c = await a.toNostrEvent();\n    return (await (await fetch(\n      `${s}?` + new URLSearchParams({\n        amount: e.toString(),\n        nostr: JSON.stringify(c)\n      })\n    )).json()).pr;\n  }\n  relays() {\n    var r, n;\n    let e = [];\n    return (n = (r = this.ndk) == null ? void 0 : r.pool) != null && n.relays && (e = this.ndk.pool.urls()), e.length || (e = yd), e;\n  }\n};\nfunction bd(t, e = []) {\n  const r = /(@|nostr:)(npub|nprofile|note|nevent)[a-zA-Z0-9]+/g;\n  return t = t.replace(r, (n) => {\n    try {\n      const i = n.split(/(@|nostr:)/)[2], { type: s, data: o } = we.decode(i);\n      let a;\n      switch (s) {\n        case \"npub\":\n          a = [\"p\", o];\n          break;\n        case \"nprofile\":\n          a = [\"p\", o.pubkey];\n          break;\n        case \"nevent\":\n          a = [\"e\", o.id];\n          break;\n        case \"note\":\n          a = [\"e\", o];\n          break;\n        default:\n          return n;\n      }\n      return e.find((c) => c[0] === a[0] && c[1] === a[1]) || e.push(a), `nostr:${i}`;\n    } catch {\n      return n;\n    }\n  }), { content: t, tags: e };\n}\nfunction vd() {\n  if (this.kind === void 0)\n    throw new Error(\"Kind not set\");\n  return this.kind >= 1e4 && this.kind < 2e4;\n}\nfunction wd() {\n  if (this.kind === void 0)\n    throw new Error(\"Kind not set\");\n  return this.kind >= 3e4 && this.kind < 4e4;\n}\nasync function _d() {\n  if (!this.ndk)\n    throw new Error(\"NDK not set\");\n  const t = await this.ndk.fetchEvents({\n    kinds: [3],\n    authors: [this.hexpubkey()]\n  });\n  if (t) {\n    const e = /* @__PURE__ */ new Set();\n    return t.forEach((r) => {\n      r.tags.forEach((n) => {\n        if (n[0] === \"p\")\n          try {\n            const i = we.npubEncode(n[1]);\n            e.add(i);\n          } catch {\n          }\n      });\n    }), [...e].reduce((r, n) => {\n      const i = new pe({ npub: n });\n      return i.ndk = this.ndk, r.add(i), r;\n    }, /* @__PURE__ */ new Set());\n  }\n  return /* @__PURE__ */ new Set();\n}\nfunction md(t, e) {\n  const r = JSON.parse(t.content);\n  return Object.keys(r).forEach((n) => {\n    switch (n) {\n      case \"name\":\n        e.name = r.name;\n        break;\n      case \"display_name\":\n      case \"displayName\":\n        e.displayName = r.displayName || r.display_name;\n        break;\n      case \"image\":\n      case \"picture\":\n        e.image = r.image || r.picture;\n        break;\n      case \"banner\":\n        e.banner = r.banner;\n        break;\n      case \"bio\":\n        e.bio = r.bio;\n        break;\n      case \"nip05\":\n        e.nip05 = r.nip05;\n        break;\n      case \"lud06\":\n        e.lud06 = r.lud06;\n        break;\n      case \"lud16\":\n        e.lud16 = r.lud16;\n        break;\n      case \"about\":\n        e.about = r.about;\n        break;\n      case \"zapService\":\n        e.zapService = r.zapService;\n        break;\n      case \"website\":\n        e.website = r.website;\n        break;\n      default:\n        e[n] = r[n];\n        break;\n    }\n  }), e;\n}\nvar pe = class {\n  constructor(t) {\n    I(this, \"ndk\");\n    I(this, \"profile\");\n    I(this, \"npub\", \"\");\n    I(this, \"relayUrls\", []);\n    I(this, \"follows\", _d.bind(this));\n    t.npub && (this.npub = t.npub), t.hexpubkey && (this.npub = we.npubEncode(t.hexpubkey)), t.relayUrls && (this.relayUrls = t.relayUrls);\n  }\n  static async fromNip05(t) {\n    const e = await _a.queryProfile(t);\n    if (e)\n      return new pe({\n        hexpubkey: e.pubkey,\n        relayUrls: e.relays\n      });\n  }\n  hexpubkey() {\n    return we.decode(this.npub).data;\n  }\n  async fetchProfile(t) {\n    if (!this.ndk)\n      throw new Error(\"NDK not set\");\n    this.profile || (this.profile = {});\n    const e = await this.ndk.fetchEvents(\n      {\n        kinds: [0],\n        authors: [this.hexpubkey()]\n      },\n      t\n    );\n    return e && Array.from(e).sort(\n      (n, i) => n.created_at - i.created_at\n    ).forEach((n) => {\n      try {\n        this.profile = md(n, this.profile);\n      } catch {\n      }\n    }), e;\n  }\n  async relayList() {\n    if (!this.ndk)\n      throw new Error(\"NDK not set\");\n    const t = await this.ndk.fetchEvents({\n      kinds: [10002],\n      authors: [this.hexpubkey()]\n    });\n    return t || /* @__PURE__ */ new Set();\n  }\n  tagReference() {\n    return [\"p\", this.hexpubkey()];\n  }\n  async publish() {\n    if (!this.ndk)\n      throw new Error(\"No NDK instance found\");\n    this.ndk.assertSigner(), await new qe(this.ndk, {\n      kind: 0,\n      content: JSON.stringify(this.profile)\n    }).publish();\n  }\n  async follow(t, e) {\n    if (!this.ndk)\n      throw new Error(\"No NDK instance found\");\n    if (this.ndk.assertSigner(), e || (e = await this.follows()), e.has(t))\n      return !1;\n    e.add(t);\n    const r = new qe(this.ndk, { kind: 3 });\n    for (const n of e)\n      r.tag(n);\n    return await r.publish(), !0;\n  }\n};\nasync function xd(t, e) {\n  if (!e) {\n    if (!this.ndk)\n      throw new Error(\"No signer available\");\n    await this.ndk.assertSigner(), e = this.ndk.signer;\n  }\n  if (!t) {\n    const r = this.getMatchingTags(\"p\");\n    if (r.length !== 1)\n      throw new Error(\"No recipient could be determined and no explicit recipient was provided\");\n    t = new pe({ hexpubkey: r[0][1] }), t.ndk = this.ndk;\n  }\n  this.content = await e.encrypt(t, this.content);\n}\nasync function Ed(t, e) {\n  if (!e) {\n    if (!this.ndk)\n      throw new Error(\"No signer available\");\n    await this.ndk.assertSigner(), e = this.ndk.signer;\n  }\n  t || (t = this.author), this.content = await e.decrypt(t, this.content);\n}\nfunction kd() {\n  return this.isParamReplaceable() ? we.naddrEncode({\n    kind: this.kind,\n    pubkey: this.pubkey,\n    identifier: this.replaceableDTag()\n  }) : we.noteEncode(this.tagId());\n}\nasync function Sd(t = !0, e) {\n  if (!e) {\n    if (!this.ndk)\n      throw new Error(\"No NDK instance found\");\n    this.ndk.assertSigner(), e = this.ndk.signer;\n  }\n  if (!e)\n    throw new Error(\"No signer available\");\n  const r = await e.user(), n = new qe(this.ndk, {\n    kind: Od(this),\n    content: \"\",\n    pubkey: r.hexpubkey()\n  });\n  return n.tag(this), n.kind === 16 && n.tags.push([\"k\", `${this.kind}`]), await n.sign(e), t && await n.publish(), n;\n}\nfunction Od(t) {\n  return t.kind === 1 ? 6 : 16;\n}\nvar qe = class extends dt {\n  constructor(e, r) {\n    super();\n    I(this, \"ndk\");\n    I(this, \"created_at\");\n    I(this, \"content\", \"\");\n    I(this, \"tags\", []);\n    I(this, \"kind\");\n    I(this, \"id\", \"\");\n    I(this, \"sig\");\n    I(this, \"pubkey\", \"\");\n    I(this, \"relay\");\n    I(this, \"isReplaceable\", vd.bind(this));\n    I(this, \"isParamReplaceable\", wd.bind(this));\n    I(this, \"encode\", kd.bind(this));\n    I(this, \"encrypt\", xd.bind(this));\n    I(this, \"decrypt\", Ed.bind(this));\n    I(this, \"repost\", Sd.bind(this));\n    this.ndk = e, this.created_at = r == null ? void 0 : r.created_at, this.content = (r == null ? void 0 : r.content) || \"\", this.tags = (r == null ? void 0 : r.tags) || [], this.id = (r == null ? void 0 : r.id) || \"\", this.sig = r == null ? void 0 : r.sig, this.pubkey = (r == null ? void 0 : r.pubkey) || \"\", this.kind = r == null ? void 0 : r.kind;\n  }\n  rawEvent() {\n    return {\n      created_at: this.created_at,\n      content: this.content,\n      tags: this.tags,\n      kind: this.kind,\n      pubkey: this.pubkey,\n      id: this.id,\n      sig: this.sig\n    };\n  }\n  set author(e) {\n    this.pubkey = e.hexpubkey();\n  }\n  get author() {\n    const e = new pe({ hexpubkey: this.pubkey });\n    return e.ndk = this.ndk, e;\n  }\n  tag(e, r) {\n    const n = e.tagReference();\n    if (r && n.push(r), this.tags.push(n), e instanceof qe) {\n      const i = e.author;\n      i && this.pubkey !== i.hexpubkey() && this.tag(i);\n      for (const s of e.getMatchingTags(\"p\"))\n        s[1] !== this.pubkey && (this.tags.find((o) => o[0] === \"p\" && o[1] === s[1]) || this.tags.push([\"p\", s[1]]));\n    }\n  }\n  async toNostrEvent(e) {\n    var s, o;\n    if (!e && this.pubkey === \"\") {\n      const a = await ((o = (s = this.ndk) == null ? void 0 : s.signer) == null ? void 0 : o.user());\n      this.pubkey = (a == null ? void 0 : a.hexpubkey()) || \"\";\n    }\n    this.created_at || (this.created_at = Math.floor(Date.now() / 1e3));\n    const r = this.rawEvent(), { content: n, tags: i } = this.generateTags();\n    r.content = n || \"\", r.tags = i;\n    try {\n      this.id = Hr(r);\n    } catch {\n    }\n    return this.id && (r.id = this.id), this.sig && (r.sig = this.sig), r;\n  }\n  getMatchingTags(e) {\n    return this.tags.filter((r) => r[0] === e);\n  }\n  tagValue(e) {\n    const r = this.getMatchingTags(e);\n    if (r.length !== 0)\n      return r[0][1];\n  }\n  removeTag(e) {\n    this.tags = this.tags.filter((r) => r[0] !== e);\n  }\n  async sign(e) {\n    var n;\n    e || ((n = this.ndk) == null || n.assertSigner(), e = this.ndk.signer), await this.generateTags(), this.isReplaceable() && (this.created_at = Math.floor(Date.now() / 1e3));\n    const r = await this.toNostrEvent();\n    return this.sig = await e.sign(r), this.sig;\n  }\n  async publish(e, r) {\n    if (this.sig || await this.sign(), !this.ndk)\n      throw new Error(\"NDKEvent must be associated with an NDK instance to publish\");\n    return this.ndk.publish(this, e, r);\n  }\n  generateTags() {\n    let e = [];\n    const r = bd(this.content, this.tags), n = r.content;\n    if (e = r.tags, this.kind && this.kind >= 3e4 && this.kind <= 4e4 && !this.getMatchingTags(\"d\")[0]) {\n      const s = [...Array(16)].map(() => Math.random().toString(36)[2]).join(\"\");\n      e.push([\"d\", s]);\n    }\n    return { content: n || \"\", tags: e };\n  }\n  replaceableDTag() {\n    if (this.kind && this.kind >= 3e4 && this.kind <= 4e4) {\n      const e = this.getMatchingTags(\"d\")[0];\n      return e ? e[1] : \"\";\n    }\n    throw new Error(\"Event is not a parameterized replaceable event\");\n  }\n  tagId() {\n    if (this.kind && this.kind >= 3e4 && this.kind <= 4e4) {\n      const e = this.replaceableDTag();\n      return `${this.kind}:${this.pubkey}:${e}`;\n    }\n    return this.id;\n  }\n  tagReference() {\n    return this.isParamReplaceable() ? [\"a\", this.tagId()] : [\"e\", this.tagId()];\n  }\n  filter() {\n    return this.isParamReplaceable() ? { \"#a\": [this.tagId()] } : { \"#e\": [this.tagId()] };\n  }\n  async zap(e, r, n) {\n    if (!this.ndk)\n      throw new Error(\"No NDK instance found\");\n    return this.ndk.assertSigner(), await new gd({\n      ndk: this.ndk,\n      zappedEvent: this\n    }).createZapRequest(e, r, n);\n  }\n  async delete(e) {\n    if (!this.ndk)\n      throw new Error(\"No NDK instance found\");\n    this.ndk.assertSigner();\n    const r = new qe(this.ndk, {\n      kind: 5,\n      content: e || \"\"\n    });\n    return r.tag(this), await r.publish(), r;\n  }\n}, Ad = class extends dt {\n  constructor(e) {\n    super();\n    I(this, \"url\");\n    I(this, \"scores\");\n    I(this, \"relay\");\n    I(this, \"_status\");\n    I(this, \"connectedAt\");\n    I(this, \"_connectionStats\", { attempts: 0, success: 0, durations: [] });\n    I(this, \"complaining\", !1);\n    I(this, \"debug\");\n    I(this, \"activeSubscriptions\", /* @__PURE__ */ new Set());\n    I(this, \"updateConnectionStats\", {\n      connected: () => {\n        this._connectionStats.success++, this._connectionStats.connectedAt = Date.now();\n      },\n      disconnected: () => {\n        this._connectionStats.connectedAt && (this._connectionStats.durations.push(\n          Date.now() - this._connectionStats.connectedAt\n        ), this._connectionStats.durations.length > 100 && this._connectionStats.durations.shift()), this._connectionStats.connectedAt = void 0;\n      },\n      attempt: () => {\n        this._connectionStats.attempts++;\n      }\n    });\n    this.url = e, this.relay = Af(e), this.scores = /* @__PURE__ */ new Map(), this._status = 3, this.debug = Mn(`ndk:relay:${e}`), this.relay.on(\"connect\", () => {\n      this.updateConnectionStats.connected(), this._status = 1, this.emit(\"connect\");\n    }), this.relay.on(\"disconnect\", () => {\n      this.updateConnectionStats.disconnected(), this._status === 1 && (this._status = 3, this.handleReconnection()), this.emit(\"disconnect\");\n    }), this.relay.on(\"notice\", (r) => this.handleNotice(r));\n  }\n  isFlapping() {\n    const e = this._connectionStats.durations;\n    if (e.length < 10)\n      return !1;\n    const n = e.reduce((a, c) => a + c, 0) / e.length, i = e.map((a) => Math.pow(a - n, 2)).reduce((a, c) => a + c, 0) / e.length;\n    return Math.sqrt(i) < 1e3;\n  }\n  handleReconnection() {\n    this.isFlapping() && (this.emit(\"flapping\", this, this._connectionStats), this._status = 5), this.connectedAt && Date.now() - this.connectedAt < 5e3 ? setTimeout(() => this.connect(), 6e4) : this.connect();\n  }\n  get status() {\n    return this._status;\n  }\n  async connect() {\n    try {\n      this.updateConnectionStats.attempt(), this._status = 0, await this.relay.connect();\n    } catch (e) {\n      throw this.debug(\"Failed to connect\", e), this._status = 3, e;\n    }\n  }\n  disconnect() {\n    this._status = 2, this.relay.close();\n  }\n  async handleNotice(e) {\n    (e.includes(\"oo many\") || e.includes(\"aximum\")) && (this.disconnect(), setTimeout(() => this.connect(), 2e3), this.debug(this.relay.url, \"Relay complaining?\", e)), this.emit(\"notice\", this, e);\n  }\n  subscribe(e) {\n    const { filter: r } = e, n = this.relay.sub([r], {\n      id: e.subId\n    });\n    this.debug(`Subscribed to ${JSON.stringify(r)}`), n.on(\"event\", (s) => {\n      const o = new qe(void 0, s);\n      o.relay = this, e.eventReceived(o, this);\n    }), n.on(\"eose\", () => {\n      e.eoseReceived(this);\n    });\n    const i = n.unsub;\n    return n.unsub = () => {\n      this.debug(`Unsubscribing from ${JSON.stringify(r)}`), this.activeSubscriptions.delete(e), i();\n    }, this.activeSubscriptions.add(e), e.on(\"close\", () => {\n      this.activeSubscriptions.delete(e);\n    }), n;\n  }\n  async publish(e, r = 2500) {\n    return this.status === 1 ? this.publishEvent(e, r) : (this.once(\"connect\", () => {\n      this.publishEvent(e, r);\n    }), !0);\n  }\n  async publishEvent(e, r) {\n    const n = await e.toNostrEvent(), i = this.relay.publish(n);\n    let s;\n    const o = new Promise((c, l) => {\n      i.on(\"failed\", (f) => {\n        clearTimeout(s), this.debug(\"Publish failed\", f, e.id), this.emit(\"publish:failed\", e, f), l(f);\n      }), i.on(\"ok\", () => {\n        clearTimeout(s), this.emit(\"published\", e), c(!0);\n      });\n    });\n    if (!r)\n      return o;\n    const a = new Promise((c, l) => {\n      s = setTimeout(() => {\n        this.debug(\"Publish timed out\", e.rawEvent()), this.emit(\"publish:failed\", e, \"Timeout\"), l(new Error(\"Publish operation timed out\"));\n      }, r);\n    });\n    return Promise.race([o, a]);\n  }\n  scoreSlowerEvent(e) {\n  }\n  get connectionStats() {\n    return this._connectionStats;\n  }\n  tagReference(e) {\n    const r = [\"r\", this.relay.url];\n    return e && r.push(e), r;\n  }\n}, Cd = class extends dt {\n  constructor(e = [], r) {\n    super();\n    I(this, \"relays\", /* @__PURE__ */ new Map());\n    I(this, \"debug\");\n    this.debug = r.debug.extend(\"pool\");\n    for (const n of e) {\n      const i = new Ad(n);\n      i.on(\"notice\", (s, o) => this.emit(\"notice\", s, o)), i.on(\"connect\", () => this.handleRelayConnect(n)), i.on(\"disconnect\", () => this.emit(\"relay:disconnect\", i)), i.on(\"flapping\", () => this.handleFlapping(i)), this.relays.set(n, i);\n    }\n  }\n  handleRelayConnect(e) {\n    this.debug(`Relay ${e} connected`), this.emit(\"relay:connect\", this.relays.get(e)), this.stats().connected === this.relays.size && this.emit(\"connect\");\n  }\n  async connect(e) {\n    const r = [];\n    this.debug(\n      `Connecting to ${this.relays.size} relays${e ? `, timeout ${e}...` : \"\"}`\n    );\n    for (const n of this.relays.values())\n      if (e) {\n        const i = new Promise((s, o) => {\n          setTimeout(() => o(`Timed out after ${e}ms`), e);\n        });\n        r.push(\n          Promise.race([n.connect(), i]).catch((s) => {\n            this.debug(`Failed to connect to relay ${n.url}: ${s}`);\n          })\n        );\n      } else\n        r.push(n.connect());\n    e && setTimeout(() => {\n      const n = this.stats().connected === this.relays.size, i = this.stats().connected > 0;\n      !n && i && this.emit(\"connect\");\n    }, e), await Promise.all(r);\n  }\n  handleFlapping(e) {\n    this.debug(`Relay ${e.url} is flapping`), this.relays.delete(e.url), this.emit(\"flapping\", e);\n  }\n  size() {\n    return this.relays.size;\n  }\n  stats() {\n    const e = {\n      total: 0,\n      connected: 0,\n      disconnected: 0,\n      connecting: 0\n    };\n    for (const r of this.relays.values())\n      e.total++, r.status === 1 ? e.connected++ : r.status === 3 ? e.disconnected++ : r.status === 0 && e.connecting++;\n    return e;\n  }\n  urls() {\n    return Array.from(this.relays.keys());\n  }\n};\nfunction Id(t) {\n  return !!(Rd(t.filter) && Td(t));\n}\nfunction Rd(t) {\n  return !!t.ids;\n}\nfunction Td(t) {\n  const e = t.filter.ids;\n  return !!e && e.length === t.eventFirstSeen.size;\n}\nvar Pd = {\n  closeOnEose: !0,\n  cacheUsage: \"CACHE_FIRST\",\n  groupable: !0,\n  groupableDelay: 100\n}, Pa = class extends dt {\n  constructor(e, r, n, i, s) {\n    super();\n    I(this, \"subId\");\n    I(this, \"filter\");\n    I(this, \"opts\");\n    I(this, \"relaySet\");\n    I(this, \"ndk\");\n    I(this, \"relaySubscriptions\");\n    I(this, \"debug\");\n    I(this, \"eventFirstSeen\", /* @__PURE__ */ new Map());\n    I(this, \"eosesSeen\", /* @__PURE__ */ new Set());\n    I(this, \"eventsPerRelay\", /* @__PURE__ */ new Map());\n    I(this, \"eoseTimeout\");\n    if (this.ndk = e, this.opts = { ...Pd, ...n || {} }, this.subId = s || (n == null ? void 0 : n.subId) || qd(r), this.filter = r, this.relaySet = i, this.relaySubscriptions = /* @__PURE__ */ new Map(), this.debug = e.debug.extend(`subscription:${this.subId}`), this.opts.cacheUsage === \"ONLY_CACHE\" && !this.opts.closeOnEose)\n      throw new Error(\"Cannot use cache-only options with a persistent subscription\");\n  }\n  groupableId() {\n    var i, s;\n    if (!((i = this.opts) != null && i.groupable))\n      return null;\n    const e = (((s = this.filter.kinds) == null ? void 0 : s.length) || 0) > 0, r = !this.filter.since && !this.filter.until, n = !this.filter.limit;\n    if (e && r && n) {\n      let o = this.filter.kinds.join(\",\");\n      const a = Object.keys(this.filter || {}).sort().join(\"-\");\n      return o += `-${a}`, o;\n    }\n    return null;\n  }\n  shouldQueryCache() {\n    var e;\n    return ((e = this.opts) == null ? void 0 : e.cacheUsage) !== \"ONLY_RELAY\";\n  }\n  shouldQueryRelays() {\n    var e;\n    return ((e = this.opts) == null ? void 0 : e.cacheUsage) !== \"ONLY_CACHE\";\n  }\n  shouldWaitForCache() {\n    var e;\n    return this.opts.closeOnEose && !!((e = this.ndk.cacheAdapter) != null && e.locking) && this.shouldQueryRelays() && this.opts.cacheUsage !== \"PARALLEL\";\n  }\n  async start() {\n    let e;\n    if (this.shouldQueryCache() && (e = this.startWithCache(), this.shouldWaitForCache() && (await e, Id(this)))) {\n      this.debug(\"cache hit, fully filled: skipping relay query\"), this.emit(\"eose\", this);\n      return;\n    }\n    this.shouldQueryRelays() && this.startWithRelaySet();\n  }\n  stop() {\n    this.relaySubscriptions.forEach((e) => e.unsub()), this.relaySubscriptions.clear(), this.emit(\"close\", this);\n  }\n  async startWithCache() {\n    var e;\n    if ((e = this.ndk.cacheAdapter) != null && e.query) {\n      const r = this.ndk.cacheAdapter.query(this);\n      this.ndk.cacheAdapter.locking && await r;\n    }\n  }\n  startWithRelaySet() {\n    this.relaySet || (this.relaySet = Ud(this.ndk, this.filter)), this.relaySet && this.relaySet.subscribe(this);\n  }\n  eventReceived(e, r, n = !1) {\n    if (!n && r) {\n      let i = this.eventsPerRelay.get(r);\n      if (i || (i = /* @__PURE__ */ new Set(), this.eventsPerRelay.set(r, i)), i.add(e.id), this.eventFirstSeen.has(e.id)) {\n        const o = Date.now() - (this.eventFirstSeen.get(e.id) || 0);\n        r.scoreSlowerEvent(o), this.emit(\"event:dup\", e, r, o, this);\n        return;\n      }\n      this.ndk.cacheAdapter && this.ndk.cacheAdapter.setEvent(e, this.filter), this.eventFirstSeen.set(`${e.id}`, Date.now());\n    } else\n      this.eventFirstSeen.set(`${e.id}`, 0);\n    this.emit(\"event\", e, r, this);\n  }\n  eoseReceived(e) {\n    var n, i, s;\n    (n = this.opts) != null && n.closeOnEose && ((i = this.relaySubscriptions.get(e)) == null || i.unsub(), this.relaySubscriptions.delete(e), this.relaySubscriptions.size === 0 && this.emit(\"close\", this)), this.eosesSeen.add(e), this.eosesSeen.size === ((s = this.relaySet) == null ? void 0 : s.size()) ? this.emit(\"eose\") : (this.eoseTimeout && clearTimeout(this.eoseTimeout), this.eoseTimeout = setTimeout(() => {\n      this.emit(\"eose\");\n    }, 500));\n  }\n}, Bd = class extends Pa {\n  constructor(e, r) {\n    const n = e.debug.extend(\"subscription-group\"), i = Ld(r.map((s) => s.filter));\n    super(\n      e,\n      i,\n      r[0].opts,\n      r[0].relaySet\n    );\n    I(this, \"subscriptions\");\n    this.subscriptions = r, n(\"merged filters\", {\n      count: r.length,\n      mergedFilters: this.filter\n    }), this.on(\"event\", this.forwardEvent), this.on(\"event:dup\", this.forwardEventDup), this.on(\"eose\", this.forwardEose), this.on(\"close\", this.forwardClose);\n  }\n  isEventForSubscription(e, r) {\n    const { filter: n } = r;\n    return n ? ya(n, e.rawEvent()) : !1;\n  }\n  forwardEvent(e, r) {\n    for (const n of this.subscriptions)\n      !this.isEventForSubscription(e, n) || n.emit(\"event\", e, r, n);\n  }\n  forwardEventDup(e, r, n) {\n    for (const i of this.subscriptions)\n      !this.isEventForSubscription(e, i) || i.emit(\"event:dup\", e, r, n, i);\n  }\n  forwardEose() {\n    for (const e of this.subscriptions)\n      e.emit(\"eose\", e);\n  }\n  forwardClose() {\n    for (const e of this.subscriptions)\n      e.emit(\"close\", e);\n  }\n};\nfunction Ld(t) {\n  const e = {};\n  return t.forEach((r) => {\n    Object.entries(r).forEach(([n, i]) => {\n      Array.isArray(i) ? e[n] === void 0 ? e[n] = [...i] : e[n] = Array.from(/* @__PURE__ */ new Set([...e[n], ...i])) : e[n] = i;\n    });\n  }), e;\n}\nfunction $d(t) {\n  let e;\n  try {\n    switch (e = we.decode(t), e.type) {\n      case \"nevent\":\n        return { ids: [e.data.id] };\n      case \"note\":\n        return { ids: [e.data] };\n      case \"naddr\":\n        return {\n          authors: [e.data.pubkey],\n          \"#d\": [e.data.identifier],\n          kinds: [e.data.kind]\n        };\n    }\n  } catch {\n  }\n  return { ids: [t] };\n}\nfunction qd(t) {\n  const e = Object.keys(t) || [], r = [];\n  for (const n of e)\n    if (n === \"kinds\") {\n      const i = [n, t.kinds.join(\",\")];\n      r.push(i.join(\":\"));\n    } else\n      r.push(n);\n  return r.push(Math.floor(Math.random() * 999999999).toString()), r.join(\"-\");\n}\nvar Gr = class {\n  constructor(t, e) {\n    I(this, \"relays\");\n    I(this, \"debug\");\n    I(this, \"ndk\");\n    this.relays = t, this.ndk = e, this.debug = e.debug.extend(\"relayset\");\n  }\n  static fromRelayUrls(t, e) {\n    const r = /* @__PURE__ */ new Set();\n    for (const n of t) {\n      const i = e.pool.relays.get(n);\n      i && r.add(i);\n    }\n    return new Gr(new Set(r), e);\n  }\n  subscribeOnRelay(t, e) {\n    const r = t.subscribe(e);\n    e.relaySubscriptions.set(t, r);\n  }\n  getId() {\n    const e = Array.from(this.relays).map((r) => r.url).sort().join(\",\");\n    return ni(jr(e));\n  }\n  subscribe(t) {\n    const e = t.groupableId(), r = `${this.getId()}:${e}`;\n    if (!e)\n      return this.executeSubscription(t), t;\n    const n = this.ndk.delayedSubscriptions.get(r);\n    return n ? n.push(t) : (setTimeout(() => {\n      this.executeDelayedSubscription(r);\n    }, t.opts.groupableDelay), this.ndk.delayedSubscriptions.set(r, [t])), t;\n  }\n  executeDelayedSubscription(t) {\n    const e = this.ndk.delayedSubscriptions.get(t);\n    this.ndk.delayedSubscriptions.delete(t), e && (e.length > 1 ? this.executeSubscriptions(e) : this.executeSubscription(e[0]));\n  }\n  executeSubscriptions(t) {\n    const e = t[0].ndk, r = new Bd(e, t);\n    this.executeSubscription(r);\n  }\n  executeSubscription(t) {\n    this.debug(\"subscribing\", { filter: t.filter });\n    for (const e of this.relays)\n      if (e.status === 1)\n        this.subscribeOnRelay(e, t);\n      else {\n        const r = () => {\n          this.debug(\"new relay coming online for active subscription\", {\n            relay: e.url,\n            filter: t.filter\n          }), this.subscribeOnRelay(e, t);\n        };\n        e.once(\"connect\", r), t.once(\"close\", () => {\n          e.removeListener(\"connect\", r);\n        });\n      }\n    return t;\n  }\n  async publish(t, e) {\n    const r = /* @__PURE__ */ new Set(), n = Array.from(this.relays).map((i) => new Promise((s) => {\n      i.publish(t, e).then(() => {\n        r.add(i), s();\n      }).catch((o) => {\n        this.debug(\"error publishing to relay\", { relay: i.url, err: o }), s();\n      });\n    }));\n    if (await Promise.all(n), r.size === 0)\n      throw new Error(\"No relay was able to receive the event\");\n    return r;\n  }\n  size() {\n    return this.relays.size;\n  }\n};\nfunction Nd(t, e) {\n  var n;\n  const r = /* @__PURE__ */ new Set();\n  return (n = t.pool) == null || n.relays.forEach((i) => r.add(i)), new Gr(r, t);\n}\nfunction Ud(t, e) {\n  var n;\n  const r = /* @__PURE__ */ new Set();\n  return (n = t.pool) == null || n.relays.forEach((i) => {\n    i.complaining ? t.debug(`Relay ${i.url} is complaining, not adding to set`) : r.add(i);\n  }), new Gr(r, t);\n}\nvar jd = class {\n  constructor() {\n    I(this, \"_userPromise\");\n    I(this, \"nip04Queue\", []);\n    I(this, \"nip04Processing\", !1);\n    I(this, \"debug\");\n    if (!window.nostr)\n      throw new Error(\"NIP-07 extension not available\");\n    this.debug = Mn(\"ndk:nip07\");\n  }\n  async blockUntilReady() {\n    var e;\n    const t = await ((e = window.nostr) == null ? void 0 : e.getPublicKey());\n    if (!t)\n      throw new Error(\"User rejected access\");\n    return new pe({ hexpubkey: t });\n  }\n  async user() {\n    return this._userPromise || (this._userPromise = this.blockUntilReady()), this._userPromise;\n  }\n  async sign(t) {\n    if (!window.nostr)\n      throw new Error(\"NIP-07 extension not available\");\n    return (await window.nostr.signEvent(t)).sig;\n  }\n  async encrypt(t, e) {\n    if (!window.nostr)\n      throw new Error(\"NIP-07 extension not available\");\n    const r = t.hexpubkey();\n    return this.queueNip04(\"encrypt\", r, e);\n  }\n  async decrypt(t, e) {\n    if (!window.nostr)\n      throw new Error(\"NIP-07 extension not available\");\n    const r = t.hexpubkey();\n    return this.queueNip04(\"decrypt\", r, e);\n  }\n  async queueNip04(t, e, r) {\n    return new Promise((n, i) => {\n      this.nip04Queue.push({ type: t, counterpartyHexpubkey: e, value: r, resolve: n, reject: i }), this.nip04Processing || this.processNip04Queue();\n    });\n  }\n  async processNip04Queue(t, e = 0) {\n    if (!t && this.nip04Queue.length === 0) {\n      this.nip04Processing = !1;\n      return;\n    }\n    this.nip04Processing = !0;\n    const { type: r, counterpartyHexpubkey: n, value: i, resolve: s, reject: o } = t || this.nip04Queue.shift();\n    this.debug(\"Processing encryption queue item\", { type: r, counterpartyHexpubkey: n, value: i });\n    try {\n      let a;\n      r === \"encrypt\" ? a = await window.nostr.nip04.encrypt(n, i) : a = await window.nostr.nip04.decrypt(n, i), s(a);\n    } catch (a) {\n      if (a.message && a.message.includes(\"call already executing\") && e < 5) {\n        this.debug(\"Retrying encryption queue item\", { type: r, counterpartyHexpubkey: n, value: i, retries: e }), setTimeout(() => {\n          this.processNip04Queue(t, e + 1);\n        }, 50 * e);\n        return;\n      }\n      o(a);\n    }\n    this.processNip04Queue();\n  }\n}, Hd = class extends dt {\n  constructor(e, r, n) {\n    super();\n    I(this, \"ndk\");\n    I(this, \"signer\");\n    I(this, \"debug\");\n    this.ndk = e, this.signer = r, this.debug = n.extend(\"rpc\");\n  }\n  async subscribe(e) {\n    const r = this.ndk.subscribe(e, { closeOnEose: !1 });\n    return r.on(\"event\", async (n) => {\n      try {\n        const i = await this.parseEvent(n);\n        i.method ? this.emit(\"request\", i) : this.emit(`response-${i.id}`, i);\n      } catch (i) {\n        this.debug(\"error parsing event\", i, n);\n      }\n    }), new Promise((n, i) => {\n      r.on(\"eose\", () => n(r));\n    });\n  }\n  async parseEvent(e) {\n    const r = this.ndk.getUser({ hexpubkey: e.pubkey });\n    r.ndk = this.ndk;\n    const n = await this.signer.decrypt(r, e.content), i = JSON.parse(n), { id: s, method: o, params: a, result: c, error: l } = i;\n    return o ? { id: s, pubkey: e.pubkey, method: o, params: a, event: e } : { id: s, result: c, error: l, event: e };\n  }\n  async sendResponse(e, r, n, i = 24133, s) {\n    const o = { id: e, result: n };\n    s && (o.error = s);\n    const a = await this.signer.user(), c = this.ndk.getUser({ hexpubkey: r }), l = new qe(this.ndk, {\n      kind: i,\n      content: JSON.stringify(o),\n      tags: [[\"p\", r]],\n      pubkey: a.hexpubkey()\n    });\n    l.content = await this.signer.encrypt(c, l.content), await l.sign(this.signer), await this.ndk.publish(l);\n  }\n  async sendRequest(e, r, n = [], i = 24133, s) {\n    const o = Math.random().toString(36).substring(7), a = await this.signer.user(), c = this.ndk.getUser({ hexpubkey: e }), l = { id: o, method: r, params: n }, f = new Promise((h) => {\n      s && this.once(`response-${o}`, s);\n    }), u = new qe(this.ndk, {\n      kind: i,\n      content: JSON.stringify(l),\n      tags: [[\"p\", e]],\n      pubkey: a.hexpubkey()\n    });\n    return u.content = await this.signer.encrypt(c, u.content), await u.sign(this.signer), this.debug(\"sending request to\", e), await this.ndk.publish(u), f;\n  }\n}, Md = class {\n  constructor(t, e, r) {\n    I(this, \"ndk\");\n    I(this, \"remoteUser\");\n    I(this, \"remotePubkey\");\n    I(this, \"token\");\n    I(this, \"localSigner\");\n    I(this, \"rpc\");\n    I(this, \"debug\");\n    let n, i;\n    if (e.includes(\"#\")) {\n      const s = e.split(\"#\");\n      n = new pe({ npub: s[0] }).hexpubkey(), i = s[1];\n    } else\n      e.startsWith(\"npub\") ? n = new pe({ npub: e }).hexpubkey() : n = e;\n    this.ndk = t, this.remotePubkey = n, this.token = i, this.debug = t.debug.extend(\"nip46:signer\"), this.remoteUser = new pe({ hexpubkey: n }), r ? this.localSigner = r : this.localSigner = or.generate(), this.rpc = new Hd(t, this.localSigner, this.debug);\n  }\n  async user() {\n    return this.remoteUser;\n  }\n  async blockUntilReady() {\n    const t = await this.localSigner.user(), e = this.ndk.getUser({ npub: t.npub });\n    return await this.rpc.subscribe({\n      kinds: [24133],\n      \"#p\": [t.hexpubkey()]\n    }), new Promise((r, n) => {\n      setTimeout(() => {\n        const i = [t.hexpubkey()];\n        this.token && i.push(this.token), this.rpc.sendRequest(\n          this.remotePubkey,\n          \"connect\",\n          i,\n          24133,\n          (s) => {\n            s.result === \"ack\" ? r(e) : n(s.error);\n          }\n        );\n      }, 100);\n    });\n  }\n  async encrypt(t, e) {\n    return this.debug(\"asking for encryption\"), new Promise((n, i) => {\n      this.rpc.sendRequest(\n        this.remotePubkey,\n        \"nip04_encrypt\",\n        [t.hexpubkey(), e],\n        24133,\n        (s) => {\n          s.error ? i(s.error) : n(s.result);\n        }\n      );\n    });\n  }\n  async decrypt(t, e) {\n    return this.debug(\"asking for decryption\"), new Promise((n, i) => {\n      this.rpc.sendRequest(\n        this.remotePubkey,\n        \"nip04_decrypt\",\n        [t.hexpubkey(), e],\n        24133,\n        (s) => {\n          if (s.error)\n            i(s.error);\n          else {\n            const o = JSON.parse(s.result);\n            n(o[0]);\n          }\n        }\n      );\n    });\n  }\n  async sign(t) {\n    return this.debug(\"asking for a signature\"), new Promise((r, n) => {\n      this.rpc.sendRequest(\n        this.remotePubkey,\n        \"sign_event\",\n        [JSON.stringify(t)],\n        24133,\n        (i) => {\n          if (this.debug(\"got a response\", i), i.error)\n            n(i.error);\n          else {\n            const s = JSON.parse(i.result);\n            r(s.sig);\n          }\n        }\n      );\n    });\n  }\n}, or = class {\n  constructor(t) {\n    I(this, \"_user\");\n    I(this, \"privateKey\");\n    t && (this.privateKey = t, this._user = new pe({ hexpubkey: li(this.privateKey) }));\n  }\n  static generate() {\n    const t = yf();\n    return new or(t);\n  }\n  async blockUntilReady() {\n    if (!this._user)\n      throw new Error(\"NDKUser not initialized\");\n    return this._user;\n  }\n  async user() {\n    return await this.blockUntilReady(), this._user;\n  }\n  async sign(t) {\n    if (!this.privateKey)\n      throw Error(\"Attempted to sign without a private key\");\n    return pa(t, this.privateKey);\n  }\n  async encrypt(t, e) {\n    if (!this.privateKey)\n      throw Error(\"Attempted to encrypt without a private key\");\n    const r = t.hexpubkey();\n    return await Un.encrypt(this.privateKey, r, e);\n  }\n  async decrypt(t, e) {\n    if (!this.privateKey)\n      throw Error(\"Attempted to decrypt without a private key\");\n    const r = t.hexpubkey();\n    return await Un.decrypt(this.privateKey, r, e);\n  }\n}, Dd = class extends dt {\n  constructor(e = {}) {\n    super();\n    I(this, \"pool\");\n    I(this, \"signer\");\n    I(this, \"cacheAdapter\");\n    I(this, \"debug\");\n    I(this, \"devWriteRelaySet\");\n    I(this, \"delayedSubscriptions\");\n    this.debug = e.debug || Mn(\"ndk\"), this.pool = new Cd(e.explicitRelayUrls || [], this), this.signer = e.signer, this.cacheAdapter = e.cacheAdapter, this.delayedSubscriptions = /* @__PURE__ */ new Map(), e.devWriteRelayUrls && (this.devWriteRelaySet = Gr.fromRelayUrls(e.devWriteRelayUrls, this));\n  }\n  toJSON() {\n    return { relayCount: this.pool.relays.size }.toString();\n  }\n  async connect(e) {\n    return this.debug(\"Connecting to relays\", { timeoutMs: e }), this.pool.connect(e);\n  }\n  getUser(e) {\n    const r = new pe(e);\n    return r.ndk = this, r;\n  }\n  subscribe(e, r, n, i = !0) {\n    const s = new Pa(this, e, r, n);\n    return i && s.start(), s;\n  }\n  async publish(e, r, n) {\n    return r || (r = this.devWriteRelaySet || Nd(this)), r.publish(e, n);\n  }\n  async fetchEvent(e, r = {}, n) {\n    let i;\n    if (typeof e == \"string\" ? i = $d(e) : i = e, !i)\n      throw new Error(`Invalid filter: ${JSON.stringify(e)}`);\n    return new Promise((s) => {\n      const o = this.subscribe(i, { ...r, closeOnEose: !0 }, n, !1);\n      o.on(\"event\", (a) => {\n        a.ndk = this, s(a);\n      }), o.on(\"eose\", () => {\n        s(null);\n      }), o.start();\n    });\n  }\n  async fetchEvents(e, r = {}, n) {\n    return new Promise((i) => {\n      const s = /* @__PURE__ */ new Map(), o = this.subscribe(e, { ...r, closeOnEose: !0 }, n, !1);\n      o.on(\"event\", (a) => {\n        const c = s.get(a.tagId());\n        c && (a = pd(c, a)), a.ndk = this, s.set(a.tagId(), a);\n      }), o.on(\"eose\", () => {\n        i(new Set(s.values()));\n      }), o.start();\n    });\n  }\n  async assertSigner() {\n    if (!this.signer)\n      throw this.emit(\"signerRequired\"), new Error(\"Signer required\");\n  }\n};\nfunction zd(t) {\n  const e = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(!1), [r, n] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0), [i, s] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    async function f() {\n      r === void 0 && e.current === !1 && (e.current = !0, await o(t));\n    }\n    f();\n  }, []);\n  async function o(f, u) {\n    const h = new Dd({ explicitRelayUrls: f, signer: u });\n    u && s(u);\n    try {\n      await h.connect(), n(h);\n    } catch (d) {\n      console.error(\"ERROR loading NDK NDKInstance\", d);\n    }\n  }\n  async function a(f) {\n    o(t, f);\n  }\n  async function c(f) {\n    return r === void 0 ? [] : new Promise((u) => {\n      const h = /* @__PURE__ */ new Map(), d = r.subscribe(f, {\n        closeOnEose: !0\n      });\n      d.on(\"event\", (p) => {\n        p.ndk = r, h.set(p.tagId(), p);\n      }), d.on(\"eose\", () => {\n        setTimeout(() => u(Array.from(new Set(h.values()))), 3e3);\n      });\n    });\n  }\n  async function l(f, u = {\n    repost: !1,\n    publish: !0\n  }) {\n    if (r !== void 0)\n      return f.ndk = r, u.repost ? await f.repost() : await f.sign(), u.publish && await f.publish(), f;\n  }\n  return {\n    ndk: r,\n    signer: i,\n    loadNdk: o,\n    setSigner: a,\n    fetchEvents: c,\n    signPublishEvent: l\n  };\n}\nasync function Fd(t) {\n  try {\n    let e = t;\n    e.substring(0, 4) === \"nsec\" && (e = we.decode(e).data);\n    const r = new or(e);\n    return r.user().then(async (n) => {\n      if (n.npub)\n        return {\n          user: n,\n          npub: n.npub,\n          sk: e,\n          signer: r\n        };\n    });\n  } catch (e) {\n    throw e;\n  }\n}\nasync function Kd(t, e, r) {\n  try {\n    let n = or.generate();\n    r && (n = new or(r));\n    const i = new Md(t, e, n);\n    return i.user().then(async (s) => {\n      if (s.npub)\n        return await i.blockUntilReady(), {\n          user: s,\n          npub: (await i.user()).npub,\n          sk: n.privateKey,\n          token: e,\n          remoteSigner: i,\n          localSigner: n\n        };\n    });\n  } catch (n) {\n    throw n;\n  }\n}\nasync function Wd() {\n  try {\n    const t = new jd();\n    return t.user().then(async (e) => {\n      if (e.npub)\n        return { user: e, npub: e.npub, signer: t };\n    });\n  } catch (t) {\n    throw t;\n  }\n}\nconst Vd = (t) => {\n  const [e, r] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({}), n = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({});\n  async function i(a) {\n    if (t == null || n.current[a])\n      return;\n    n.current = {\n      ...n.current,\n      [a]: pe.prototype\n    };\n    let c;\n    a.startsWith(\"npub\") ? c = t.getUser({\n      npub: a\n    }) : c = t.getUser({\n      hexpubkey: a\n    }), await c.fetchProfile(), c.profile && (n.current = {\n      ...n.current,\n      [a]: c\n    }, r(n.current));\n  }\n  function s(a) {\n    return e[a] ? e[a] : (i(a), pe.prototype);\n  }\n  function o(a) {\n    return e[a] ? e[a].profile : (i(a), {});\n  }\n  return {\n    getUser: s,\n    getProfile: o\n  };\n};\nvar Ba = { exports: {} }, Xt = {};\n/**\n * @license React\n * react-jsx-runtime.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar Mo;\nfunction Gd() {\n  if (Mo)\n    return Xt;\n  Mo = 1;\n  var t = react__WEBPACK_IMPORTED_MODULE_0__, e = Symbol.for(\"react.element\"), r = Symbol.for(\"react.fragment\"), n = Object.prototype.hasOwnProperty, i = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, s = { key: !0, ref: !0, __self: !0, __source: !0 };\n  function o(a, c, l) {\n    var f, u = {}, h = null, d = null;\n    l !== void 0 && (h = \"\" + l), c.key !== void 0 && (h = \"\" + c.key), c.ref !== void 0 && (d = c.ref);\n    for (f in c)\n      n.call(c, f) && !s.hasOwnProperty(f) && (u[f] = c[f]);\n    if (a && a.defaultProps)\n      for (f in c = a.defaultProps, c)\n        u[f] === void 0 && (u[f] = c[f]);\n    return { $$typeof: e, type: a, key: h, ref: d, props: u, _owner: i.current };\n  }\n  return Xt.Fragment = r, Xt.jsx = o, Xt.jsxs = o, Xt;\n}\nvar Qt = {};\n/**\n * @license React\n * react-jsx-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar Do;\nfunction Zd() {\n  return Do || (Do = 1,  true && function() {\n    var t = react__WEBPACK_IMPORTED_MODULE_0__, e = Symbol.for(\"react.element\"), r = Symbol.for(\"react.portal\"), n = Symbol.for(\"react.fragment\"), i = Symbol.for(\"react.strict_mode\"), s = Symbol.for(\"react.profiler\"), o = Symbol.for(\"react.provider\"), a = Symbol.for(\"react.context\"), c = Symbol.for(\"react.forward_ref\"), l = Symbol.for(\"react.suspense\"), f = Symbol.for(\"react.suspense_list\"), u = Symbol.for(\"react.memo\"), h = Symbol.for(\"react.lazy\"), d = Symbol.for(\"react.offscreen\"), p = Symbol.iterator, y = \"@@iterator\";\n    function g(b) {\n      if (b === null || typeof b != \"object\")\n        return null;\n      var k = p && b[p] || b[y];\n      return typeof k == \"function\" ? k : null;\n    }\n    var v = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n    function _(b) {\n      {\n        for (var k = arguments.length, T = new Array(k > 1 ? k - 1 : 0), $ = 1; $ < k; $++)\n          T[$ - 1] = arguments[$];\n        m(\"error\", b, T);\n      }\n    }\n    function m(b, k, T) {\n      {\n        var $ = v.ReactDebugCurrentFrame, M = $.getStackAddendum();\n        M !== \"\" && (k += \"%s\", T = T.concat([M]));\n        var K = T.map(function(j) {\n          return String(j);\n        });\n        K.unshift(\"Warning: \" + k), Function.prototype.apply.call(console[b], console, K);\n      }\n    }\n    var C = !1, O = !1, w = !1, x = !1, A = !1, B;\n    B = Symbol.for(\"react.module.reference\");\n    function L(b) {\n      return !!(typeof b == \"string\" || typeof b == \"function\" || b === n || b === s || A || b === i || b === l || b === f || x || b === d || C || O || w || typeof b == \"object\" && b !== null && (b.$$typeof === h || b.$$typeof === u || b.$$typeof === o || b.$$typeof === a || b.$$typeof === c || b.$$typeof === B || b.getModuleId !== void 0));\n    }\n    function P(b, k, T) {\n      var $ = b.displayName;\n      if ($)\n        return $;\n      var M = k.displayName || k.name || \"\";\n      return M !== \"\" ? T + \"(\" + M + \")\" : T;\n    }\n    function F(b) {\n      return b.displayName || \"Context\";\n    }\n    function z(b) {\n      if (b == null)\n        return null;\n      if (typeof b.tag == \"number\" && _(\"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"), typeof b == \"function\")\n        return b.displayName || b.name || null;\n      if (typeof b == \"string\")\n        return b;\n      switch (b) {\n        case n:\n          return \"Fragment\";\n        case r:\n          return \"Portal\";\n        case s:\n          return \"Profiler\";\n        case i:\n          return \"StrictMode\";\n        case l:\n          return \"Suspense\";\n        case f:\n          return \"SuspenseList\";\n      }\n      if (typeof b == \"object\")\n        switch (b.$$typeof) {\n          case a:\n            var k = b;\n            return F(k) + \".Consumer\";\n          case o:\n            var T = b;\n            return F(T._context) + \".Provider\";\n          case c:\n            return P(b, b.render, \"ForwardRef\");\n          case u:\n            var $ = b.displayName || null;\n            return $ !== null ? $ : z(b.type) || \"Memo\";\n          case h: {\n            var M = b, K = M._payload, j = M._init;\n            try {\n              return z(j(K));\n            } catch {\n              return null;\n            }\n          }\n        }\n      return null;\n    }\n    var G = Object.assign, E = 0, R, q, H, D, X, oe, re;\n    function _e() {\n    }\n    _e.__reactDisabledLog = !0;\n    function Oe() {\n      {\n        if (E === 0) {\n          R = console.log, q = console.info, H = console.warn, D = console.error, X = console.group, oe = console.groupCollapsed, re = console.groupEnd;\n          var b = {\n            configurable: !0,\n            enumerable: !0,\n            value: _e,\n            writable: !0\n          };\n          Object.defineProperties(console, {\n            info: b,\n            log: b,\n            warn: b,\n            error: b,\n            group: b,\n            groupCollapsed: b,\n            groupEnd: b\n          });\n        }\n        E++;\n      }\n    }\n    function Ue() {\n      {\n        if (E--, E === 0) {\n          var b = {\n            configurable: !0,\n            enumerable: !0,\n            writable: !0\n          };\n          Object.defineProperties(console, {\n            log: G({}, b, {\n              value: R\n            }),\n            info: G({}, b, {\n              value: q\n            }),\n            warn: G({}, b, {\n              value: H\n            }),\n            error: G({}, b, {\n              value: D\n            }),\n            group: G({}, b, {\n              value: X\n            }),\n            groupCollapsed: G({}, b, {\n              value: oe\n            }),\n            groupEnd: G({}, b, {\n              value: re\n            })\n          });\n        }\n        E < 0 && _(\"disabledDepth fell below zero. This is a bug in React. Please file an issue.\");\n      }\n    }\n    var Pe = v.ReactCurrentDispatcher, ye;\n    function je(b, k, T) {\n      {\n        if (ye === void 0)\n          try {\n            throw Error();\n          } catch (M) {\n            var $ = M.stack.trim().match(/\\n( *(at )?)/);\n            ye = $ && $[1] || \"\";\n          }\n        return `\n` + ye + b;\n      }\n    }\n    var me = !1, xe;\n    {\n      var lr = typeof WeakMap == \"function\" ? WeakMap : Map;\n      xe = new lr();\n    }\n    function Be(b, k) {\n      if (!b || me)\n        return \"\";\n      {\n        var T = xe.get(b);\n        if (T !== void 0)\n          return T;\n      }\n      var $;\n      me = !0;\n      var M = Error.prepareStackTrace;\n      Error.prepareStackTrace = void 0;\n      var K;\n      K = Pe.current, Pe.current = null, Oe();\n      try {\n        if (k) {\n          var j = function() {\n            throw Error();\n          };\n          if (Object.defineProperty(j.prototype, \"props\", {\n            set: function() {\n              throw Error();\n            }\n          }), typeof Reflect == \"object\" && Reflect.construct) {\n            try {\n              Reflect.construct(j, []);\n            } catch (Le) {\n              $ = Le;\n            }\n            Reflect.construct(b, [], j);\n          } else {\n            try {\n              j.call();\n            } catch (Le) {\n              $ = Le;\n            }\n            b.call(j.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (Le) {\n            $ = Le;\n          }\n          b();\n        }\n      } catch (Le) {\n        if (Le && $ && typeof Le.stack == \"string\") {\n          for (var U = Le.stack.split(`\n`), se = $.stack.split(`\n`), W = U.length - 1, Z = se.length - 1; W >= 1 && Z >= 0 && U[W] !== se[Z]; )\n            Z--;\n          for (; W >= 1 && Z >= 0; W--, Z--)\n            if (U[W] !== se[Z]) {\n              if (W !== 1 || Z !== 1)\n                do\n                  if (W--, Z--, Z < 0 || U[W] !== se[Z]) {\n                    var ge = `\n` + U[W].replace(\" at new \", \" at \");\n                    return b.displayName && ge.includes(\"<anonymous>\") && (ge = ge.replace(\"<anonymous>\", b.displayName)), typeof b == \"function\" && xe.set(b, ge), ge;\n                  }\n                while (W >= 1 && Z >= 0);\n              break;\n            }\n        }\n      } finally {\n        me = !1, Pe.current = K, Ue(), Error.prepareStackTrace = M;\n      }\n      var yt = b ? b.displayName || b.name : \"\", $i = yt ? je(yt) : \"\";\n      return typeof b == \"function\" && xe.set(b, $i), $i;\n    }\n    function fe(b, k, T) {\n      return Be(b, !1);\n    }\n    function He(b) {\n      var k = b.prototype;\n      return !!(k && k.isReactComponent);\n    }\n    function it(b, k, T) {\n      if (b == null)\n        return \"\";\n      if (typeof b == \"function\")\n        return Be(b, He(b));\n      if (typeof b == \"string\")\n        return je(b);\n      switch (b) {\n        case l:\n          return je(\"Suspense\");\n        case f:\n          return je(\"SuspenseList\");\n      }\n      if (typeof b == \"object\")\n        switch (b.$$typeof) {\n          case c:\n            return fe(b.render);\n          case u:\n            return it(b.type, k, T);\n          case h: {\n            var $ = b, M = $._payload, K = $._init;\n            try {\n              return it(K(M), k, T);\n            } catch {\n            }\n          }\n        }\n      return \"\";\n    }\n    var ot = Object.prototype.hasOwnProperty, Ei = {}, ki = v.ReactDebugCurrentFrame;\n    function fr(b) {\n      if (b) {\n        var k = b._owner, T = it(b.type, b._source, k ? k.type : null);\n        ki.setExtraStackFrame(T);\n      } else\n        ki.setExtraStackFrame(null);\n    }\n    function Ma(b, k, T, $, M) {\n      {\n        var K = Function.call.bind(ot);\n        for (var j in b)\n          if (K(b, j)) {\n            var U = void 0;\n            try {\n              if (typeof b[j] != \"function\") {\n                var se = Error(($ || \"React class\") + \": \" + T + \" type `\" + j + \"` is invalid; it must be a function, usually from the `prop-types` package, but received `\" + typeof b[j] + \"`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                throw se.name = \"Invariant Violation\", se;\n              }\n              U = b[j](k, j, $, T, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n            } catch (W) {\n              U = W;\n            }\n            U && !(U instanceof Error) && (fr(M), _(\"%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).\", $ || \"React class\", T, j, typeof U), fr(null)), U instanceof Error && !(U.message in Ei) && (Ei[U.message] = !0, fr(M), _(\"Failed %s type: %s\", T, U.message), fr(null));\n          }\n      }\n    }\n    var Da = Array.isArray;\n    function Zr(b) {\n      return Da(b);\n    }\n    function za(b) {\n      {\n        var k = typeof Symbol == \"function\" && Symbol.toStringTag, T = k && b[Symbol.toStringTag] || b.constructor.name || \"Object\";\n        return T;\n      }\n    }\n    function Fa(b) {\n      try {\n        return Si(b), !1;\n      } catch {\n        return !0;\n      }\n    }\n    function Si(b) {\n      return \"\" + b;\n    }\n    function Oi(b) {\n      if (Fa(b))\n        return _(\"The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.\", za(b)), Si(b);\n    }\n    var Ct = v.ReactCurrentOwner, Ka = {\n      key: !0,\n      ref: !0,\n      __self: !0,\n      __source: !0\n    }, Ai, Ci, Yr;\n    Yr = {};\n    function Wa(b) {\n      if (ot.call(b, \"ref\")) {\n        var k = Object.getOwnPropertyDescriptor(b, \"ref\").get;\n        if (k && k.isReactWarning)\n          return !1;\n      }\n      return b.ref !== void 0;\n    }\n    function Va(b) {\n      if (ot.call(b, \"key\")) {\n        var k = Object.getOwnPropertyDescriptor(b, \"key\").get;\n        if (k && k.isReactWarning)\n          return !1;\n      }\n      return b.key !== void 0;\n    }\n    function Ga(b, k) {\n      if (typeof b.ref == \"string\" && Ct.current && k && Ct.current.stateNode !== k) {\n        var T = z(Ct.current.type);\n        Yr[T] || (_('Component \"%s\" contains the string ref \"%s\". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', z(Ct.current.type), b.ref), Yr[T] = !0);\n      }\n    }\n    function Za(b, k) {\n      {\n        var T = function() {\n          Ai || (Ai = !0, _(\"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", k));\n        };\n        T.isReactWarning = !0, Object.defineProperty(b, \"key\", {\n          get: T,\n          configurable: !0\n        });\n      }\n    }\n    function Ya(b, k) {\n      {\n        var T = function() {\n          Ci || (Ci = !0, _(\"%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", k));\n        };\n        T.isReactWarning = !0, Object.defineProperty(b, \"ref\", {\n          get: T,\n          configurable: !0\n        });\n      }\n    }\n    var Ja = function(b, k, T, $, M, K, j) {\n      var U = {\n        $$typeof: e,\n        type: b,\n        key: k,\n        ref: T,\n        props: j,\n        _owner: K\n      };\n      return U._store = {}, Object.defineProperty(U._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: !1\n      }), Object.defineProperty(U, \"_self\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !1,\n        value: $\n      }), Object.defineProperty(U, \"_source\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !1,\n        value: M\n      }), Object.freeze && (Object.freeze(U.props), Object.freeze(U)), U;\n    };\n    function Xa(b, k, T, $, M) {\n      {\n        var K, j = {}, U = null, se = null;\n        T !== void 0 && (Oi(T), U = \"\" + T), Va(k) && (Oi(k.key), U = \"\" + k.key), Wa(k) && (se = k.ref, Ga(k, M));\n        for (K in k)\n          ot.call(k, K) && !Ka.hasOwnProperty(K) && (j[K] = k[K]);\n        if (b && b.defaultProps) {\n          var W = b.defaultProps;\n          for (K in W)\n            j[K] === void 0 && (j[K] = W[K]);\n        }\n        if (U || se) {\n          var Z = typeof b == \"function\" ? b.displayName || b.name || \"Unknown\" : b;\n          U && Za(j, Z), se && Ya(j, Z);\n        }\n        return Ja(b, U, se, M, $, Ct.current, j);\n      }\n    }\n    var Jr = v.ReactCurrentOwner, Ii = v.ReactDebugCurrentFrame;\n    function pt(b) {\n      if (b) {\n        var k = b._owner, T = it(b.type, b._source, k ? k.type : null);\n        Ii.setExtraStackFrame(T);\n      } else\n        Ii.setExtraStackFrame(null);\n    }\n    var Xr;\n    Xr = !1;\n    function Qr(b) {\n      return typeof b == \"object\" && b !== null && b.$$typeof === e;\n    }\n    function Ri() {\n      {\n        if (Jr.current) {\n          var b = z(Jr.current.type);\n          if (b)\n            return `\n\nCheck the render method of \\`` + b + \"`.\";\n        }\n        return \"\";\n      }\n    }\n    function Qa(b) {\n      {\n        if (b !== void 0) {\n          var k = b.fileName.replace(/^.*[\\\\\\/]/, \"\"), T = b.lineNumber;\n          return `\n\nCheck your code at ` + k + \":\" + T + \".\";\n        }\n        return \"\";\n      }\n    }\n    var Ti = {};\n    function ec(b) {\n      {\n        var k = Ri();\n        if (!k) {\n          var T = typeof b == \"string\" ? b : b.displayName || b.name;\n          T && (k = `\n\nCheck the top-level render call using <` + T + \">.\");\n        }\n        return k;\n      }\n    }\n    function Pi(b, k) {\n      {\n        if (!b._store || b._store.validated || b.key != null)\n          return;\n        b._store.validated = !0;\n        var T = ec(k);\n        if (Ti[T])\n          return;\n        Ti[T] = !0;\n        var $ = \"\";\n        b && b._owner && b._owner !== Jr.current && ($ = \" It was passed a child from \" + z(b._owner.type) + \".\"), pt(b), _('Each child in a list should have a unique \"key\" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', T, $), pt(null);\n      }\n    }\n    function Bi(b, k) {\n      {\n        if (typeof b != \"object\")\n          return;\n        if (Zr(b))\n          for (var T = 0; T < b.length; T++) {\n            var $ = b[T];\n            Qr($) && Pi($, k);\n          }\n        else if (Qr(b))\n          b._store && (b._store.validated = !0);\n        else if (b) {\n          var M = g(b);\n          if (typeof M == \"function\" && M !== b.entries)\n            for (var K = M.call(b), j; !(j = K.next()).done; )\n              Qr(j.value) && Pi(j.value, k);\n        }\n      }\n    }\n    function tc(b) {\n      {\n        var k = b.type;\n        if (k == null || typeof k == \"string\")\n          return;\n        var T;\n        if (typeof k == \"function\")\n          T = k.propTypes;\n        else if (typeof k == \"object\" && (k.$$typeof === c || k.$$typeof === u))\n          T = k.propTypes;\n        else\n          return;\n        if (T) {\n          var $ = z(k);\n          Ma(T, b.props, \"prop\", $, b);\n        } else if (k.PropTypes !== void 0 && !Xr) {\n          Xr = !0;\n          var M = z(k);\n          _(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", M || \"Unknown\");\n        }\n        typeof k.getDefaultProps == \"function\" && !k.getDefaultProps.isReactClassApproved && _(\"getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.\");\n      }\n    }\n    function rc(b) {\n      {\n        for (var k = Object.keys(b.props), T = 0; T < k.length; T++) {\n          var $ = k[T];\n          if ($ !== \"children\" && $ !== \"key\") {\n            pt(b), _(\"Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.\", $), pt(null);\n            break;\n          }\n        }\n        b.ref !== null && (pt(b), _(\"Invalid attribute `ref` supplied to `React.Fragment`.\"), pt(null));\n      }\n    }\n    function Li(b, k, T, $, M, K) {\n      {\n        var j = L(b);\n        if (!j) {\n          var U = \"\";\n          (b === void 0 || typeof b == \"object\" && b !== null && Object.keys(b).length === 0) && (U += \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\");\n          var se = Qa(M);\n          se ? U += se : U += Ri();\n          var W;\n          b === null ? W = \"null\" : Zr(b) ? W = \"array\" : b !== void 0 && b.$$typeof === e ? (W = \"<\" + (z(b.type) || \"Unknown\") + \" />\", U = \" Did you accidentally export a JSX literal instead of a component?\") : W = typeof b, _(\"React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s\", W, U);\n        }\n        var Z = Xa(b, k, T, M, K);\n        if (Z == null)\n          return Z;\n        if (j) {\n          var ge = k.children;\n          if (ge !== void 0)\n            if ($)\n              if (Zr(ge)) {\n                for (var yt = 0; yt < ge.length; yt++)\n                  Bi(ge[yt], b);\n                Object.freeze && Object.freeze(ge);\n              } else\n                _(\"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\");\n            else\n              Bi(ge, b);\n        }\n        return b === n ? rc(Z) : tc(Z), Z;\n      }\n    }\n    function nc(b, k, T) {\n      return Li(b, k, T, !0);\n    }\n    function ic(b, k, T) {\n      return Li(b, k, T, !1);\n    }\n    var oc = ic, sc = nc;\n    Qt.Fragment = n, Qt.jsx = oc, Qt.jsxs = sc;\n  }()), Qt;\n}\n(function(t) {\n   false ? 0 : t.exports = Zd();\n})(Ba);\nconst Yd = Ba.exports.jsx, La = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n  ndk: void 0,\n  signer: void 0,\n  fetchEvents: (t) => Promise.resolve([]),\n  loginWithNip46: (t, e) => Promise.resolve(void 0),\n  loginWithSecret: (t) => Promise.resolve(void 0),\n  loginWithNip07: () => Promise.resolve(void 0),\n  signPublishEvent: (t, e) => Promise.resolve(void 0),\n  getUser: (t) => pe.prototype,\n  getProfile: (t) => ({})\n}), Pp = ({\n  children: t,\n  relayUrls: e\n}) => {\n  const {\n    ndk: r,\n    signer: n,\n    setSigner: i,\n    fetchEvents: s,\n    signPublishEvent: o\n  } = zd(e), {\n    getUser: a,\n    getProfile: c\n  } = Vd(r);\n  async function l(h, d) {\n    if (r === void 0)\n      return;\n    const p = await Kd(r, h, d);\n    if (p)\n      return await i(p.remoteSigner), p;\n  }\n  async function f(h) {\n    const d = await Fd(h);\n    if (d) {\n      const {\n        signer: p\n      } = d;\n      return await i(p), d;\n    }\n  }\n  async function u() {\n    const h = await Wd();\n    if (h) {\n      const {\n        signer: d\n      } = h;\n      return await i(d), h;\n    }\n  }\n  return /* @__PURE__ */ Yd(La.Provider, {\n    value: {\n      ndk: r,\n      signer: n,\n      fetchEvents: s,\n      loginWithNip07: u,\n      loginWithNip46: l,\n      loginWithSecret: f,\n      signPublishEvent: o,\n      getUser: a,\n      getProfile: c\n    },\n    children: t\n  });\n}, Bp = () => {\n  const t = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(La);\n  if (t === void 0)\n    throw new Error(\"import NDKProvider to use useNDK\");\n  return t;\n};\nfunction Xe(t) {\n  return t != null && typeof t == \"object\" && t[\"@@functional/placeholder\"] === !0;\n}\nfunction ht(t) {\n  return function e(r) {\n    return arguments.length === 0 || Xe(r) ? e : t.apply(this, arguments);\n  };\n}\nfunction ur(t) {\n  return function e(r, n) {\n    switch (arguments.length) {\n      case 0:\n        return e;\n      case 1:\n        return Xe(r) ? e : ht(function(i) {\n          return t(r, i);\n        });\n      default:\n        return Xe(r) && Xe(n) ? e : Xe(r) ? ht(function(i) {\n          return t(i, n);\n        }) : Xe(n) ? ht(function(i) {\n          return t(r, i);\n        }) : t(r, n);\n    }\n  };\n}\nfunction $a(t, e) {\n  switch (t) {\n    case 0:\n      return function() {\n        return e.apply(this, arguments);\n      };\n    case 1:\n      return function(r) {\n        return e.apply(this, arguments);\n      };\n    case 2:\n      return function(r, n) {\n        return e.apply(this, arguments);\n      };\n    case 3:\n      return function(r, n, i) {\n        return e.apply(this, arguments);\n      };\n    case 4:\n      return function(r, n, i, s) {\n        return e.apply(this, arguments);\n      };\n    case 5:\n      return function(r, n, i, s, o) {\n        return e.apply(this, arguments);\n      };\n    case 6:\n      return function(r, n, i, s, o, a) {\n        return e.apply(this, arguments);\n      };\n    case 7:\n      return function(r, n, i, s, o, a, c) {\n        return e.apply(this, arguments);\n      };\n    case 8:\n      return function(r, n, i, s, o, a, c, l) {\n        return e.apply(this, arguments);\n      };\n    case 9:\n      return function(r, n, i, s, o, a, c, l, f) {\n        return e.apply(this, arguments);\n      };\n    case 10:\n      return function(r, n, i, s, o, a, c, l, f, u) {\n        return e.apply(this, arguments);\n      };\n    default:\n      throw new Error(\"First argument to _arity must be a non-negative integer no greater than ten\");\n  }\n}\nfunction qa(t, e, r) {\n  return function() {\n    for (var n = [], i = 0, s = t, o = 0; o < e.length || i < arguments.length; ) {\n      var a;\n      o < e.length && (!Xe(e[o]) || i >= arguments.length) ? a = e[o] : (a = arguments[i], i += 1), n[o] = a, Xe(a) || (s -= 1), o += 1;\n    }\n    return s <= 0 ? r.apply(this, n) : $a(s, qa(t, n, r));\n  };\n}\nvar Jd = /* @__PURE__ */ ur(function(e, r) {\n  return e === 1 ? ht(r) : $a(e, qa(e, [], r));\n});\nconst Xd = Jd, Qd = Array.isArray || function(e) {\n  return e != null && e.length >= 0 && Object.prototype.toString.call(e) === \"[object Array]\";\n};\nfunction ep(t) {\n  return t != null && typeof t[\"@@transducer/step\"] == \"function\";\n}\nfunction tp(t, e, r) {\n  return function() {\n    if (arguments.length === 0)\n      return r();\n    var n = arguments[arguments.length - 1];\n    if (!Qd(n)) {\n      for (var i = 0; i < t.length; ) {\n        if (typeof n[t[i]] == \"function\")\n          return n[t[i]].apply(n, Array.prototype.slice.call(arguments, 0, -1));\n        i += 1;\n      }\n      if (ep(n)) {\n        var s = e.apply(null, Array.prototype.slice.call(arguments, 0, -1));\n        return s(n);\n      }\n    }\n    return r.apply(this, arguments);\n  };\n}\nconst zo = {\n  init: function() {\n    return this.xf[\"@@transducer/init\"]();\n  },\n  result: function(t) {\n    return this.xf[\"@@transducer/result\"](t);\n  }\n};\nfunction jn(t, e) {\n  return Object.prototype.hasOwnProperty.call(e, t);\n}\nvar Fo = Object.prototype.toString, rp = /* @__PURE__ */ function() {\n  return Fo.call(arguments) === \"[object Arguments]\" ? function(e) {\n    return Fo.call(e) === \"[object Arguments]\";\n  } : function(e) {\n    return jn(\"callee\", e);\n  };\n}();\nconst np = rp;\nvar ip = !/* @__PURE__ */ {\n  toString: null\n}.propertyIsEnumerable(\"toString\"), Ko = [\"constructor\", \"valueOf\", \"isPrototypeOf\", \"toString\", \"propertyIsEnumerable\", \"hasOwnProperty\", \"toLocaleString\"], Wo = /* @__PURE__ */ function() {\n  return arguments.propertyIsEnumerable(\"length\");\n}(), op = function(e, r) {\n  for (var n = 0; n < e.length; ) {\n    if (e[n] === r)\n      return !0;\n    n += 1;\n  }\n  return !1;\n}, sp = /* @__PURE__ */ ht(typeof Object.keys == \"function\" && !Wo ? function(e) {\n  return Object(e) !== e ? [] : Object.keys(e);\n} : function(e) {\n  if (Object(e) !== e)\n    return [];\n  var r, n, i = [], s = Wo && np(e);\n  for (r in e)\n    jn(r, e) && (!s || r !== \"length\") && (i[i.length] = r);\n  if (ip)\n    for (n = Ko.length - 1; n >= 0; )\n      r = Ko[n], jn(r, e) && !op(i, r) && (i[i.length] = r), n -= 1;\n  return i;\n});\nconst ap = sp;\nfunction cp(t, e) {\n  for (var r = 0, n = e.length, i = Array(n); r < n; )\n    i[r] = t(e[r]), r += 1;\n  return i;\n}\nfunction up(t, e, r) {\n  for (var n = 0, i = r.length; n < i; )\n    e = t(e, r[n]), n += 1;\n  return e;\n}\nvar lp = /* @__PURE__ */ function() {\n  function t(e, r) {\n    this.xf = r, this.f = e;\n  }\n  return t.prototype[\"@@transducer/init\"] = zo.init, t.prototype[\"@@transducer/result\"] = zo.result, t.prototype[\"@@transducer/step\"] = function(e, r) {\n    return this.xf[\"@@transducer/step\"](e, this.f(r));\n  }, t;\n}(), fp = function(e) {\n  return function(r) {\n    return new lp(e, r);\n  };\n};\nconst hp = fp;\nvar dp = /* @__PURE__ */ ur(\n  /* @__PURE__ */ tp([\"fantasy-land/map\", \"map\"], hp, function(e, r) {\n    switch (Object.prototype.toString.call(r)) {\n      case \"[object Function]\":\n        return Xd(r.length, function() {\n          return e.call(this, r.apply(this, arguments));\n        });\n      case \"[object Object]\":\n        return up(function(n, i) {\n          return n[i] = e(r[i]), n;\n        }, {}, ap(r));\n      default:\n        return cp(e, r);\n    }\n  })\n);\nconst pp = dp, yp = Number.isInteger || function(e) {\n  return e << 0 === e;\n};\nfunction gp(t) {\n  return Object.prototype.toString.call(t) === \"[object String]\";\n}\nvar bp = /* @__PURE__ */ ur(function(e, r) {\n  var n = e < 0 ? r.length + e : e;\n  return gp(r) ? r.charAt(n) : r[n];\n});\nconst Na = bp;\nvar vp = /* @__PURE__ */ ur(function(e, r) {\n  if (r != null)\n    return yp(e) ? Na(e, r) : r[e];\n});\nconst wp = vp;\nvar _p = /* @__PURE__ */ ur(function(e, r) {\n  return pp(wp(e), r);\n});\nconst mp = _p;\nfunction xp(t) {\n  return t;\n}\nvar Ep = /* @__PURE__ */ ht(xp);\nconst kp = Ep;\nvar Sp = /* @__PURE__ */ Na(-1);\nconst Ua = Sp, Op = \"newline\", Hn = \"text\", ja = \"topic\", xi = \"link\", Ha = \"invoice\", Lp = \"nostr:note\", $p = \"nostr:nevent\", qp = \"nostr:npub\", Np = \"nostr:nprofile\", Up = \"nostr:naddr\";\nfunction gt(t) {\n  return t ? t[0] : void 0;\n}\nconst Ap = (t) => t.replace(/^[\\w\\+]+:\\/?\\/?/, \"\"), Cp = (t) => !t.match(/\\.(apk|docx|xlsx|csv|dmg)/) && Ua(t.split(\"://\")).includes(\"/\"), jp = ({\n  content: t,\n  tags: e = []\n}) => {\n  const r = [];\n  let n = t.trim(), i = \"\";\n  const s = () => {\n    const u = gt(n.match(/^\\n+/));\n    if (u)\n      return [Op, u, u];\n  }, o = () => {\n    const u = n.match(/^#\\[(\\d+)\\]/i);\n    if (u) {\n      const h = parseInt(u[1]);\n      if (e[h]) {\n        const [d, p, y] = e[h], g = [y].filter(kp);\n        let v, _, m;\n        return d === \"p\" ? (v = \"nprofile\", _ = { pubkey: p, relays: g }, m = we.nprofileEncode(_)) : (v = \"nevent\", _ = { id: p, relays: g, pubkey: null }, m = we.neventEncode(_)), [`nostr:${v}`, u[0], { ..._, entity: m }];\n      }\n    }\n  }, a = () => {\n    const u = gt(n.match(/^#\\w+/i));\n    if (u && !u.match(/^#\\d+$/))\n      return [ja, u, u.slice(1)];\n  }, c = () => {\n    const u = gt(\n      n.match(\n        /^(web\\+)?(nostr:)?\\/?\\/?n(event|ote|profile|pub|addr)1[\\d\\w]+/i\n      )\n    );\n    if (u)\n      try {\n        const h = Ap(u), { type: d, data: p } = we.decode(h);\n        let y = p;\n        return d === \"note\" ? y = { id: p } : d === \"npub\" && (y = { pubkey: p }), [`nostr:${d}`, u, { ...y, entity: h }];\n      } catch (h) {\n        console.log(h);\n      }\n  }, l = () => {\n    const u = gt(n.match(/^ln(bc|url)[\\d\\w]{50,1000}/i));\n    if (u)\n      return [Ha, u, u];\n  }, f = () => {\n    const u = gt(\n      n.match(/^([a-z\\+:]{2,30}:\\/\\/)?[^\\s]+\\.[a-z]{2,6}[^\\s]*[^\\.!?,:\\s]/gi)\n    );\n    if (u) {\n      const h = Ua(r);\n      if ((h == null ? void 0 : h.type) === \"text\" && h.value.endsWith(\"/\"))\n        return;\n      let d = u;\n      return d.match(/\\.\\./) ? void 0 : (d.match(\"://\") || (d = \"https://\" + d), [xi, u, { url: d, isMedia: Cp(d) }]);\n    }\n  };\n  for (; n; ) {\n    const u = s() || o() || a() || c() || f() || l();\n    if (u) {\n      i && (r.push({ type: \"text\", value: i }), i = \"\");\n      const [h, d, p] = u;\n      r.push({ type: h, value: p }), n = n.slice(d.length);\n    } else {\n      const h = gt(n.match(/^[\\w\\d]+ ?/i)) || n[0];\n      i += h, n = n.slice(h.length);\n    }\n  }\n  return i && r.push({ type: Hn, value: i }), r;\n}, Hp = (t, { showEntire: e, maxLength: r, showMedia: n = !1 }) => {\n  if (e)\n    return t;\n  let i = 0;\n  const s = [], o = r * 0.6;\n  return t.every((a, c) => {\n    const l = [ja, Hn].includes(a.type) || a.type === xi && !a.value.isMedia, f = a.type === Ha || a.type.startsWith(\"nostr:\") || a.value.isMedia;\n    return l && (i += a.value.length), f && (i += n ? r / 3 : a.value.length), s.push(a), i > o && c < t.length - 1 ? ((l || f && !n) && s.push({ type: Hn, value: \"...\" }), !1) : !0;\n  }), s;\n}, Mp = (t) => mp(\n  \"value\",\n  t.filter((e) => e.type === xi && e.isMedia)\n);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9zdHItZGV2LWtpdC9uZGstcmVhY3QvZGlzdC9uZGstcmVhY3QuZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBLDBDQUEwQywwREFBMEQ7QUFDcEc7QUFDaUg7QUFDakg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLGtEQUFrRCxXQUFXO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQSxXQUFXLGFBQWE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0Esd0JBQXdCLE9B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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsRUFBRSxjQUFjLEVBQUU7QUFDL0QsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0JBQXNCO0FBQ2xDLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDREQUE0RCxVQUFVLGNBQWMsU0FBUztBQUM3RjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrREFBa0QsMkJBQTJCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCLGlCQUFpQjtBQUMxQztBQUNBLDBDQUEwQyxXQUFXO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLEVBQUU7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsNkNBQTZD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsRUFBRTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMkJBQTJCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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aEUsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpREFBaUQ7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLFNBQVM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsMENBQTBDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHNCQUFzQixJQUFJO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxXQUFXLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUztBQUN4RDtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsV0FBVztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsY0FBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHNCQUFzQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQkFBZ0I7QUFDakQ7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEVBQUUsTUFBcUMsR0FBRyxDQUFnQjtBQUMxRCxDQUFDO0FBQ0QsZ0NBQWdDLG9EQUFFO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0QsWUFBWSxpREFBRTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHNDQUFzQztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRCxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLDhDQUE4QyxPQUFPO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELHNCQUFzQixtREFBbUQsZ0NBQWdDLHFDQUFxQyxFQUFFLFdBQVcsaUJBQWlCO0FBQzlOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG1CQUFtQjtBQUM5QztBQUNBLG9DQUFvQyxRQUFRLHlCQUF5QixXQUFXLGFBQWEsRUFBRSxRQUFRLGlCQUFpQjtBQUN4SCxRQUFRO0FBQ1I7QUFDQTtBQUNBLEdBQUc7QUFDSCw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsMEJBQTBCLEtBQUsscUJBQXFCLElBQUk7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGLHdCQUF3QjtBQUNuSDtBQUNBO0FBQ0EsU0FBUyxHQUFHO0FBQ1o7QUFDQTtBQUNBLHFCQUFxQix3QkFBd0I7QUFDN0M7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQyxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsb0JBQW9CO0FBQzNDLENBQUMsYUFBYSxnREFBZ0Q7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0pBQWtKLHdCQUF3QjtBQUMxSyxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQW1CRSIsInNvdXJjZXMiOlsiL2hvbWUvbGZnL0dpdC9NYWR0cmlwcy9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrLXJlYWN0L2Rpc3QvbmRrLXJlYWN0LmVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBhYyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBjYyA9ICh0LCBlLCByKSA9PiBlIGluIHQgPyBhYyh0LCBlLCB7IGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAsIHZhbHVlOiByIH0pIDogdFtlXSA9IHI7XG52YXIgSSA9ICh0LCBlLCByKSA9PiAoY2ModCwgdHlwZW9mIGUgIT0gXCJzeW1ib2xcIiA/IGUgKyBcIlwiIDogZSwgciksIHIpO1xuaW1wb3J0IFZvLCB7IHVzZVJlZiBhcyBHbywgdXNlU3RhdGUgYXMgU24sIHVzZUVmZmVjdCBhcyB1YywgY3JlYXRlQ29udGV4dCBhcyBsYywgdXNlQ29udGV4dCBhcyBmYyB9IGZyb20gXCJyZWFjdFwiO1xudmFyIFMgPSB0eXBlb2YgZ2xvYmFsVGhpcyA8IFwidVwiID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgPCBcInVcIiA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgPCBcInVcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmIDwgXCJ1XCIgPyBzZWxmIDoge307XG5mdW5jdGlvbiBFdCh0KSB7XG4gIHZhciBlID0gdC5kZWZhdWx0O1xuICBpZiAodHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdmFyIHIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICByLnByb3RvdHlwZSA9IGUucHJvdG90eXBlO1xuICB9IGVsc2VcbiAgICByID0ge307XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkociwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBPYmplY3Qua2V5cyh0KS5mb3JFYWNoKGZ1bmN0aW9uKG4pIHtcbiAgICB2YXIgaSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgbik7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHIsIG4sIGkuZ2V0ID8gaSA6IHtcbiAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRbbl07XG4gICAgICB9XG4gICAgfSk7XG4gIH0pLCByO1xufVxudmFyIE9uID0geyBleHBvcnRzOiB7fSB9LCBlbiwgcWk7XG5mdW5jdGlvbiBoYygpIHtcbiAgaWYgKHFpKVxuICAgIHJldHVybiBlbjtcbiAgcWkgPSAxO1xuICB2YXIgdCA9IDFlMywgZSA9IHQgKiA2MCwgciA9IGUgKiA2MCwgbiA9IHIgKiAyNCwgaSA9IG4gKiA3LCBzID0gbiAqIDM2NS4yNTtcbiAgZW4gPSBmdW5jdGlvbihmLCB1KSB7XG4gICAgdSA9IHUgfHwge307XG4gICAgdmFyIGggPSB0eXBlb2YgZjtcbiAgICBpZiAoaCA9PT0gXCJzdHJpbmdcIiAmJiBmLmxlbmd0aCA+IDApXG4gICAgICByZXR1cm4gbyhmKTtcbiAgICBpZiAoaCA9PT0gXCJudW1iZXJcIiAmJiBpc0Zpbml0ZShmKSlcbiAgICAgIHJldHVybiB1LmxvbmcgPyBjKGYpIDogYShmKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcInZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9XCIgKyBKU09OLnN0cmluZ2lmeShmKVxuICAgICk7XG4gIH07XG4gIGZ1bmN0aW9uIG8oZikge1xuICAgIGlmIChmID0gU3RyaW5nKGYpLCAhKGYubGVuZ3RoID4gMTAwKSkge1xuICAgICAgdmFyIHUgPSAvXigtPyg/OlxcZCspP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8d2Vla3M/fHd8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoXG4gICAgICAgIGZcbiAgICAgICk7XG4gICAgICBpZiAoISF1KSB7XG4gICAgICAgIHZhciBoID0gcGFyc2VGbG9hdCh1WzFdKSwgZCA9ICh1WzJdIHx8IFwibXNcIikudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgc3dpdGNoIChkKSB7XG4gICAgICAgICAgY2FzZSBcInllYXJzXCI6XG4gICAgICAgICAgY2FzZSBcInllYXJcIjpcbiAgICAgICAgICBjYXNlIFwieXJzXCI6XG4gICAgICAgICAgY2FzZSBcInlyXCI6XG4gICAgICAgICAgY2FzZSBcInlcIjpcbiAgICAgICAgICAgIHJldHVybiBoICogcztcbiAgICAgICAgICBjYXNlIFwid2Vla3NcIjpcbiAgICAgICAgICBjYXNlIFwid2Vla1wiOlxuICAgICAgICAgIGNhc2UgXCJ3XCI6XG4gICAgICAgICAgICByZXR1cm4gaCAqIGk7XG4gICAgICAgICAgY2FzZSBcImRheXNcIjpcbiAgICAgICAgICBjYXNlIFwiZGF5XCI6XG4gICAgICAgICAgY2FzZSBcImRcIjpcbiAgICAgICAgICAgIHJldHVybiBoICogbjtcbiAgICAgICAgICBjYXNlIFwiaG91cnNcIjpcbiAgICAgICAgICBjYXNlIFwiaG91clwiOlxuICAgICAgICAgIGNhc2UgXCJocnNcIjpcbiAgICAgICAgICBjYXNlIFwiaHJcIjpcbiAgICAgICAgICBjYXNlIFwiaFwiOlxuICAgICAgICAgICAgcmV0dXJuIGggKiByO1xuICAgICAgICAgIGNhc2UgXCJtaW51dGVzXCI6XG4gICAgICAgICAgY2FzZSBcIm1pbnV0ZVwiOlxuICAgICAgICAgIGNhc2UgXCJtaW5zXCI6XG4gICAgICAgICAgY2FzZSBcIm1pblwiOlxuICAgICAgICAgIGNhc2UgXCJtXCI6XG4gICAgICAgICAgICByZXR1cm4gaCAqIGU7XG4gICAgICAgICAgY2FzZSBcInNlY29uZHNcIjpcbiAgICAgICAgICBjYXNlIFwic2Vjb25kXCI6XG4gICAgICAgICAgY2FzZSBcInNlY3NcIjpcbiAgICAgICAgICBjYXNlIFwic2VjXCI6XG4gICAgICAgICAgY2FzZSBcInNcIjpcbiAgICAgICAgICAgIHJldHVybiBoICogdDtcbiAgICAgICAgICBjYXNlIFwibWlsbGlzZWNvbmRzXCI6XG4gICAgICAgICAgY2FzZSBcIm1pbGxpc2Vjb25kXCI6XG4gICAgICAgICAgY2FzZSBcIm1zZWNzXCI6XG4gICAgICAgICAgY2FzZSBcIm1zZWNcIjpcbiAgICAgICAgICBjYXNlIFwibXNcIjpcbiAgICAgICAgICAgIHJldHVybiBoO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gYShmKSB7XG4gICAgdmFyIHUgPSBNYXRoLmFicyhmKTtcbiAgICByZXR1cm4gdSA+PSBuID8gTWF0aC5yb3VuZChmIC8gbikgKyBcImRcIiA6IHUgPj0gciA/IE1hdGgucm91bmQoZiAvIHIpICsgXCJoXCIgOiB1ID49IGUgPyBNYXRoLnJvdW5kKGYgLyBlKSArIFwibVwiIDogdSA+PSB0ID8gTWF0aC5yb3VuZChmIC8gdCkgKyBcInNcIiA6IGYgKyBcIm1zXCI7XG4gIH1cbiAgZnVuY3Rpb24gYyhmKSB7XG4gICAgdmFyIHUgPSBNYXRoLmFicyhmKTtcbiAgICByZXR1cm4gdSA+PSBuID8gbChmLCB1LCBuLCBcImRheVwiKSA6IHUgPj0gciA/IGwoZiwgdSwgciwgXCJob3VyXCIpIDogdSA+PSBlID8gbChmLCB1LCBlLCBcIm1pbnV0ZVwiKSA6IHUgPj0gdCA/IGwoZiwgdSwgdCwgXCJzZWNvbmRcIikgOiBmICsgXCIgbXNcIjtcbiAgfVxuICBmdW5jdGlvbiBsKGYsIHUsIGgsIGQpIHtcbiAgICB2YXIgcCA9IHUgPj0gaCAqIDEuNTtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChmIC8gaCkgKyBcIiBcIiArIGQgKyAocCA/IFwic1wiIDogXCJcIik7XG4gIH1cbiAgcmV0dXJuIGVuO1xufVxuZnVuY3Rpb24gZGModCkge1xuICByLmRlYnVnID0gciwgci5kZWZhdWx0ID0gciwgci5jb2VyY2UgPSBjLCByLmRpc2FibGUgPSBzLCByLmVuYWJsZSA9IGksIHIuZW5hYmxlZCA9IG8sIHIuaHVtYW5pemUgPSBoYygpLCByLmRlc3Ryb3kgPSBsLCBPYmplY3Qua2V5cyh0KS5mb3JFYWNoKChmKSA9PiB7XG4gICAgcltmXSA9IHRbZl07XG4gIH0pLCByLm5hbWVzID0gW10sIHIuc2tpcHMgPSBbXSwgci5mb3JtYXR0ZXJzID0ge307XG4gIGZ1bmN0aW9uIGUoZikge1xuICAgIGxldCB1ID0gMDtcbiAgICBmb3IgKGxldCBoID0gMDsgaCA8IGYubGVuZ3RoOyBoKyspXG4gICAgICB1ID0gKHUgPDwgNSkgLSB1ICsgZi5jaGFyQ29kZUF0KGgpLCB1IHw9IDA7XG4gICAgcmV0dXJuIHIuY29sb3JzW01hdGguYWJzKHUpICUgci5jb2xvcnMubGVuZ3RoXTtcbiAgfVxuICByLnNlbGVjdENvbG9yID0gZTtcbiAgZnVuY3Rpb24gcihmKSB7XG4gICAgbGV0IHUsIGggPSBudWxsLCBkLCBwO1xuICAgIGZ1bmN0aW9uIHkoLi4uZykge1xuICAgICAgaWYgKCF5LmVuYWJsZWQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IHYgPSB5LCBfID0gTnVtYmVyKG5ldyBEYXRlKCkpLCBtID0gXyAtICh1IHx8IF8pO1xuICAgICAgdi5kaWZmID0gbSwgdi5wcmV2ID0gdSwgdi5jdXJyID0gXywgdSA9IF8sIGdbMF0gPSByLmNvZXJjZShnWzBdKSwgdHlwZW9mIGdbMF0gIT0gXCJzdHJpbmdcIiAmJiBnLnVuc2hpZnQoXCIlT1wiKTtcbiAgICAgIGxldCBDID0gMDtcbiAgICAgIGdbMF0gPSBnWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCAodywgeCkgPT4ge1xuICAgICAgICBpZiAodyA9PT0gXCIlJVwiKVxuICAgICAgICAgIHJldHVybiBcIiVcIjtcbiAgICAgICAgQysrO1xuICAgICAgICBjb25zdCBBID0gci5mb3JtYXR0ZXJzW3hdO1xuICAgICAgICBpZiAodHlwZW9mIEEgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgY29uc3QgQiA9IGdbQ107XG4gICAgICAgICAgdyA9IEEuY2FsbCh2LCBCKSwgZy5zcGxpY2UoQywgMSksIEMtLTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdztcbiAgICAgIH0pLCByLmZvcm1hdEFyZ3MuY2FsbCh2LCBnKSwgKHYubG9nIHx8IHIubG9nKS5hcHBseSh2LCBnKTtcbiAgICB9XG4gICAgcmV0dXJuIHkubmFtZXNwYWNlID0gZiwgeS51c2VDb2xvcnMgPSByLnVzZUNvbG9ycygpLCB5LmNvbG9yID0gci5zZWxlY3RDb2xvcihmKSwgeS5leHRlbmQgPSBuLCB5LmRlc3Ryb3kgPSByLmRlc3Ryb3ksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh5LCBcImVuYWJsZWRcIiwge1xuICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgZ2V0OiAoKSA9PiBoICE9PSBudWxsID8gaCA6IChkICE9PSByLm5hbWVzcGFjZXMgJiYgKGQgPSByLm5hbWVzcGFjZXMsIHAgPSByLmVuYWJsZWQoZikpLCBwKSxcbiAgICAgIHNldDogKGcpID0+IHtcbiAgICAgICAgaCA9IGc7XG4gICAgICB9XG4gICAgfSksIHR5cGVvZiByLmluaXQgPT0gXCJmdW5jdGlvblwiICYmIHIuaW5pdCh5KSwgeTtcbiAgfVxuICBmdW5jdGlvbiBuKGYsIHUpIHtcbiAgICBjb25zdCBoID0gcih0aGlzLm5hbWVzcGFjZSArICh0eXBlb2YgdSA+IFwidVwiID8gXCI6XCIgOiB1KSArIGYpO1xuICAgIHJldHVybiBoLmxvZyA9IHRoaXMubG9nLCBoO1xuICB9XG4gIGZ1bmN0aW9uIGkoZikge1xuICAgIHIuc2F2ZShmKSwgci5uYW1lc3BhY2VzID0gZiwgci5uYW1lcyA9IFtdLCByLnNraXBzID0gW107XG4gICAgbGV0IHU7XG4gICAgY29uc3QgaCA9ICh0eXBlb2YgZiA9PSBcInN0cmluZ1wiID8gZiA6IFwiXCIpLnNwbGl0KC9bXFxzLF0rLyksIGQgPSBoLmxlbmd0aDtcbiAgICBmb3IgKHUgPSAwOyB1IDwgZDsgdSsrKVxuICAgICAgIWhbdV0gfHwgKGYgPSBoW3VdLnJlcGxhY2UoL1xcKi9nLCBcIi4qP1wiKSwgZlswXSA9PT0gXCItXCIgPyByLnNraXBzLnB1c2gobmV3IFJlZ0V4cChcIl5cIiArIGYuc2xpY2UoMSkgKyBcIiRcIikpIDogci5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoXCJeXCIgKyBmICsgXCIkXCIpKSk7XG4gIH1cbiAgZnVuY3Rpb24gcygpIHtcbiAgICBjb25zdCBmID0gW1xuICAgICAgLi4uci5uYW1lcy5tYXAoYSksXG4gICAgICAuLi5yLnNraXBzLm1hcChhKS5tYXAoKHUpID0+IFwiLVwiICsgdSlcbiAgICBdLmpvaW4oXCIsXCIpO1xuICAgIHJldHVybiByLmVuYWJsZShcIlwiKSwgZjtcbiAgfVxuICBmdW5jdGlvbiBvKGYpIHtcbiAgICBpZiAoZltmLmxlbmd0aCAtIDFdID09PSBcIipcIilcbiAgICAgIHJldHVybiAhMDtcbiAgICBsZXQgdSwgaDtcbiAgICBmb3IgKHUgPSAwLCBoID0gci5za2lwcy5sZW5ndGg7IHUgPCBoOyB1KyspXG4gICAgICBpZiAoci5za2lwc1t1XS50ZXN0KGYpKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgZm9yICh1ID0gMCwgaCA9IHIubmFtZXMubGVuZ3RoOyB1IDwgaDsgdSsrKVxuICAgICAgaWYgKHIubmFtZXNbdV0udGVzdChmKSlcbiAgICAgICAgcmV0dXJuICEwO1xuICAgIHJldHVybiAhMTtcbiAgfVxuICBmdW5jdGlvbiBhKGYpIHtcbiAgICByZXR1cm4gZi50b1N0cmluZygpLnN1YnN0cmluZygyLCBmLnRvU3RyaW5nKCkubGVuZ3RoIC0gMikucmVwbGFjZSgvXFwuXFwqXFw/JC8sIFwiKlwiKTtcbiAgfVxuICBmdW5jdGlvbiBjKGYpIHtcbiAgICByZXR1cm4gZiBpbnN0YW5jZW9mIEVycm9yID8gZi5zdGFjayB8fCBmLm1lc3NhZ2UgOiBmO1xuICB9XG4gIGZ1bmN0aW9uIGwoKSB7XG4gICAgY29uc29sZS53YXJuKFwiSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLlwiKTtcbiAgfVxuICByZXR1cm4gci5lbmFibGUoci5sb2FkKCkpLCByO1xufVxudmFyIHBjID0gZGM7XG4oZnVuY3Rpb24odCwgZSkge1xuICBlLmZvcm1hdEFyZ3MgPSBuLCBlLnNhdmUgPSBpLCBlLmxvYWQgPSBzLCBlLnVzZUNvbG9ycyA9IHIsIGUuc3RvcmFnZSA9IG8oKSwgZS5kZXN0cm95ID0gKCgpID0+IHtcbiAgICBsZXQgYyA9ICExO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjIHx8IChjID0gITAsIGNvbnNvbGUud2FybihcIkluc3RhbmNlIG1ldGhvZCBgZGVidWcuZGVzdHJveSgpYCBpcyBkZXByZWNhdGVkIGFuZCBubyBsb25nZXIgZG9lcyBhbnl0aGluZy4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgYGRlYnVnYC5cIikpO1xuICAgIH07XG4gIH0pKCksIGUuY29sb3JzID0gW1xuICAgIFwiIzAwMDBDQ1wiLFxuICAgIFwiIzAwMDBGRlwiLFxuICAgIFwiIzAwMzNDQ1wiLFxuICAgIFwiIzAwMzNGRlwiLFxuICAgIFwiIzAwNjZDQ1wiLFxuICAgIFwiIzAwNjZGRlwiLFxuICAgIFwiIzAwOTlDQ1wiLFxuICAgIFwiIzAwOTlGRlwiLFxuICAgIFwiIzAwQ0MwMFwiLFxuICAgIFwiIzAwQ0MzM1wiLFxuICAgIFwiIzAwQ0M2NlwiLFxuICAgIFwiIzAwQ0M5OVwiLFxuICAgIFwiIzAwQ0NDQ1wiLFxuICAgIFwiIzAwQ0NGRlwiLFxuICAgIFwiIzMzMDBDQ1wiLFxuICAgIFwiIzMzMDBGRlwiLFxuICAgIFwiIzMzMzNDQ1wiLFxuICAgIFwiIzMzMzNGRlwiLFxuICAgIFwiIzMzNjZDQ1wiLFxuICAgIFwiIzMzNjZGRlwiLFxuICAgIFwiIzMzOTlDQ1wiLFxuICAgIFwiIzMzOTlGRlwiLFxuICAgIFwiIzMzQ0MwMFwiLFxuICAgIFwiIzMzQ0MzM1wiLFxuICAgIFwiIzMzQ0M2NlwiLFxuICAgIFwiIzMzQ0M5OVwiLFxuICAgIFwiIzMzQ0NDQ1wiLFxuICAgIFwiIzMzQ0NGRlwiLFxuICAgIFwiIzY2MDBDQ1wiLFxuICAgIFwiIzY2MDBGRlwiLFxuICAgIFwiIzY2MzNDQ1wiLFxuICAgIFwiIzY2MzNGRlwiLFxuICAgIFwiIzY2Q0MwMFwiLFxuICAgIFwiIzY2Q0MzM1wiLFxuICAgIFwiIzk5MDBDQ1wiLFxuICAgIFwiIzk5MDBGRlwiLFxuICAgIFwiIzk5MzNDQ1wiLFxuICAgIFwiIzk5MzNGRlwiLFxuICAgIFwiIzk5Q0MwMFwiLFxuICAgIFwiIzk5Q0MzM1wiLFxuICAgIFwiI0NDMDAwMFwiLFxuICAgIFwiI0NDMDAzM1wiLFxuICAgIFwiI0NDMDA2NlwiLFxuICAgIFwiI0NDMDA5OVwiLFxuICAgIFwiI0NDMDBDQ1wiLFxuICAgIFwiI0NDMDBGRlwiLFxuICAgIFwiI0NDMzMwMFwiLFxuICAgIFwiI0NDMzMzM1wiLFxuICAgIFwiI0NDMzM2NlwiLFxuICAgIFwiI0NDMzM5OVwiLFxuICAgIFwiI0NDMzNDQ1wiLFxuICAgIFwiI0NDMzNGRlwiLFxuICAgIFwiI0NDNjYwMFwiLFxuICAgIFwiI0NDNjYzM1wiLFxuICAgIFwiI0NDOTkwMFwiLFxuICAgIFwiI0NDOTkzM1wiLFxuICAgIFwiI0NDQ0MwMFwiLFxuICAgIFwiI0NDQ0MzM1wiLFxuICAgIFwiI0ZGMDAwMFwiLFxuICAgIFwiI0ZGMDAzM1wiLFxuICAgIFwiI0ZGMDA2NlwiLFxuICAgIFwiI0ZGMDA5OVwiLFxuICAgIFwiI0ZGMDBDQ1wiLFxuICAgIFwiI0ZGMDBGRlwiLFxuICAgIFwiI0ZGMzMwMFwiLFxuICAgIFwiI0ZGMzMzM1wiLFxuICAgIFwiI0ZGMzM2NlwiLFxuICAgIFwiI0ZGMzM5OVwiLFxuICAgIFwiI0ZGMzNDQ1wiLFxuICAgIFwiI0ZGMzNGRlwiLFxuICAgIFwiI0ZGNjYwMFwiLFxuICAgIFwiI0ZGNjYzM1wiLFxuICAgIFwiI0ZGOTkwMFwiLFxuICAgIFwiI0ZGOTkzM1wiLFxuICAgIFwiI0ZGQ0MwMFwiLFxuICAgIFwiI0ZGQ0MzM1wiXG4gIF07XG4gIGZ1bmN0aW9uIHIoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgPCBcInVcIiAmJiB3aW5kb3cucHJvY2VzcyAmJiAod2luZG93LnByb2Nlc3MudHlwZSA9PT0gXCJyZW5kZXJlclwiIHx8IHdpbmRvdy5wcm9jZXNzLl9fbndqcykgPyAhMCA6IHR5cGVvZiBuYXZpZ2F0b3IgPCBcInVcIiAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvKGVkZ2V8dHJpZGVudClcXC8oXFxkKykvKSA/ICExIDogdHlwZW9mIGRvY3VtZW50IDwgXCJ1XCIgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuV2Via2l0QXBwZWFyYW5jZSB8fCB0eXBlb2Ygd2luZG93IDwgXCJ1XCIgJiYgd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLmZpcmVidWcgfHwgd2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSB8fCB0eXBlb2YgbmF2aWdhdG9yIDwgXCJ1XCIgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSB8fCB0eXBlb2YgbmF2aWdhdG9yIDwgXCJ1XCIgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2FwcGxld2Via2l0XFwvKFxcZCspLyk7XG4gIH1cbiAgZnVuY3Rpb24gbihjKSB7XG4gICAgaWYgKGNbMF0gPSAodGhpcy51c2VDb2xvcnMgPyBcIiVjXCIgOiBcIlwiKSArIHRoaXMubmFtZXNwYWNlICsgKHRoaXMudXNlQ29sb3JzID8gXCIgJWNcIiA6IFwiIFwiKSArIGNbMF0gKyAodGhpcy51c2VDb2xvcnMgPyBcIiVjIFwiIDogXCIgXCIpICsgXCIrXCIgKyB0LmV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKSwgIXRoaXMudXNlQ29sb3JzKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGwgPSBcImNvbG9yOiBcIiArIHRoaXMuY29sb3I7XG4gICAgYy5zcGxpY2UoMSwgMCwgbCwgXCJjb2xvcjogaW5oZXJpdFwiKTtcbiAgICBsZXQgZiA9IDAsIHUgPSAwO1xuICAgIGNbMF0ucmVwbGFjZSgvJVthLXpBLVolXS9nLCAoaCkgPT4ge1xuICAgICAgaCAhPT0gXCIlJVwiICYmIChmKyssIGggPT09IFwiJWNcIiAmJiAodSA9IGYpKTtcbiAgICB9KSwgYy5zcGxpY2UodSwgMCwgbCk7XG4gIH1cbiAgZS5sb2cgPSBjb25zb2xlLmRlYnVnIHx8IGNvbnNvbGUubG9nIHx8ICgoKSA9PiB7XG4gIH0pO1xuICBmdW5jdGlvbiBpKGMpIHtcbiAgICB0cnkge1xuICAgICAgYyA/IGUuc3RvcmFnZS5zZXRJdGVtKFwiZGVidWdcIiwgYykgOiBlLnN0b3JhZ2UucmVtb3ZlSXRlbShcImRlYnVnXCIpO1xuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzKCkge1xuICAgIGxldCBjO1xuICAgIHRyeSB7XG4gICAgICBjID0gZS5zdG9yYWdlLmdldEl0ZW0oXCJkZWJ1Z1wiKTtcbiAgICB9IGNhdGNoIHtcbiAgICB9XG4gICAgcmV0dXJuICFjICYmIHR5cGVvZiBwcm9jZXNzIDwgXCJ1XCIgJiYgXCJlbnZcIiBpbiBwcm9jZXNzICYmIChjID0gcHJvY2Vzcy5lbnYuREVCVUcpLCBjO1xuICB9XG4gIGZ1bmN0aW9uIG8oKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBsb2NhbFN0b3JhZ2U7XG4gICAgfSBjYXRjaCB7XG4gICAgfVxuICB9XG4gIHQuZXhwb3J0cyA9IHBjKGUpO1xuICBjb25zdCB7IGZvcm1hdHRlcnM6IGEgfSA9IHQuZXhwb3J0cztcbiAgYS5qID0gZnVuY3Rpb24oYykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYyk7XG4gICAgfSBjYXRjaCAobCkge1xuICAgICAgcmV0dXJuIFwiW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06IFwiICsgbC5tZXNzYWdlO1xuICAgIH1cbiAgfTtcbn0pKE9uLCBPbi5leHBvcnRzKTtcbmNvbnN0IE1uID0gT24uZXhwb3J0cztcbnZhciBabyA9IHsgZXhwb3J0czoge30gfTtcbihmdW5jdGlvbih0KSB7XG4gIHZhciBlID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSwgciA9IFwiflwiO1xuICBmdW5jdGlvbiBuKCkge1xuICB9XG4gIE9iamVjdC5jcmVhdGUgJiYgKG4ucHJvdG90eXBlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksIG5ldyBuKCkuX19wcm90b19fIHx8IChyID0gITEpKTtcbiAgZnVuY3Rpb24gaShjLCBsLCBmKSB7XG4gICAgdGhpcy5mbiA9IGMsIHRoaXMuY29udGV4dCA9IGwsIHRoaXMub25jZSA9IGYgfHwgITE7XG4gIH1cbiAgZnVuY3Rpb24gcyhjLCBsLCBmLCB1LCBoKSB7XG4gICAgaWYgKHR5cGVvZiBmICE9IFwiZnVuY3Rpb25cIilcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgIHZhciBkID0gbmV3IGkoZiwgdSB8fCBjLCBoKSwgcCA9IHIgPyByICsgbCA6IGw7XG4gICAgcmV0dXJuIGMuX2V2ZW50c1twXSA/IGMuX2V2ZW50c1twXS5mbiA/IGMuX2V2ZW50c1twXSA9IFtjLl9ldmVudHNbcF0sIGRdIDogYy5fZXZlbnRzW3BdLnB1c2goZCkgOiAoYy5fZXZlbnRzW3BdID0gZCwgYy5fZXZlbnRzQ291bnQrKyksIGM7XG4gIH1cbiAgZnVuY3Rpb24gbyhjLCBsKSB7XG4gICAgLS1jLl9ldmVudHNDb3VudCA9PT0gMCA/IGMuX2V2ZW50cyA9IG5ldyBuKCkgOiBkZWxldGUgYy5fZXZlbnRzW2xdO1xuICB9XG4gIGZ1bmN0aW9uIGEoKSB7XG4gICAgdGhpcy5fZXZlbnRzID0gbmV3IG4oKSwgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG4gIGEucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbCA9IFtdLCBmLCB1O1xuICAgIGlmICh0aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgIHJldHVybiBsO1xuICAgIGZvciAodSBpbiBmID0gdGhpcy5fZXZlbnRzKVxuICAgICAgZS5jYWxsKGYsIHUpICYmIGwucHVzaChyID8gdS5zbGljZSgxKSA6IHUpO1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID8gbC5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhmKSkgOiBsO1xuICB9LCBhLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbihsKSB7XG4gICAgdmFyIGYgPSByID8gciArIGwgOiBsLCB1ID0gdGhpcy5fZXZlbnRzW2ZdO1xuICAgIGlmICghdSlcbiAgICAgIHJldHVybiBbXTtcbiAgICBpZiAodS5mbilcbiAgICAgIHJldHVybiBbdS5mbl07XG4gICAgZm9yICh2YXIgaCA9IDAsIGQgPSB1Lmxlbmd0aCwgcCA9IG5ldyBBcnJheShkKTsgaCA8IGQ7IGgrKylcbiAgICAgIHBbaF0gPSB1W2hdLmZuO1xuICAgIHJldHVybiBwO1xuICB9LCBhLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24obCkge1xuICAgIHZhciBmID0gciA/IHIgKyBsIDogbCwgdSA9IHRoaXMuX2V2ZW50c1tmXTtcbiAgICByZXR1cm4gdSA/IHUuZm4gPyAxIDogdS5sZW5ndGggOiAwO1xuICB9LCBhLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24obCwgZiwgdSwgaCwgZCwgcCkge1xuICAgIHZhciB5ID0gciA/IHIgKyBsIDogbDtcbiAgICBpZiAoIXRoaXMuX2V2ZW50c1t5XSlcbiAgICAgIHJldHVybiAhMTtcbiAgICB2YXIgZyA9IHRoaXMuX2V2ZW50c1t5XSwgdiA9IGFyZ3VtZW50cy5sZW5ndGgsIF8sIG07XG4gICAgaWYgKGcuZm4pIHtcbiAgICAgIHN3aXRjaCAoZy5vbmNlICYmIHRoaXMucmVtb3ZlTGlzdGVuZXIobCwgZy5mbiwgdm9pZCAwLCAhMCksIHYpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHJldHVybiBnLmZuLmNhbGwoZy5jb250ZXh0KSwgITA7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICByZXR1cm4gZy5mbi5jYWxsKGcuY29udGV4dCwgZiksICEwO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgcmV0dXJuIGcuZm4uY2FsbChnLmNvbnRleHQsIGYsIHUpLCAhMDtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHJldHVybiBnLmZuLmNhbGwoZy5jb250ZXh0LCBmLCB1LCBoKSwgITA7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICByZXR1cm4gZy5mbi5jYWxsKGcuY29udGV4dCwgZiwgdSwgaCwgZCksICEwO1xuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgcmV0dXJuIGcuZm4uY2FsbChnLmNvbnRleHQsIGYsIHUsIGgsIGQsIHApLCAhMDtcbiAgICAgIH1cbiAgICAgIGZvciAobSA9IDEsIF8gPSBuZXcgQXJyYXkodiAtIDEpOyBtIDwgdjsgbSsrKVxuICAgICAgICBfW20gLSAxXSA9IGFyZ3VtZW50c1ttXTtcbiAgICAgIGcuZm4uYXBwbHkoZy5jb250ZXh0LCBfKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIEMgPSBnLmxlbmd0aCwgTztcbiAgICAgIGZvciAobSA9IDA7IG0gPCBDOyBtKyspXG4gICAgICAgIHN3aXRjaCAoZ1ttXS5vbmNlICYmIHRoaXMucmVtb3ZlTGlzdGVuZXIobCwgZ1ttXS5mbiwgdm9pZCAwLCAhMCksIHYpIHtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBnW21dLmZuLmNhbGwoZ1ttXS5jb250ZXh0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGdbbV0uZm4uY2FsbChnW21dLmNvbnRleHQsIGYpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgZ1ttXS5mbi5jYWxsKGdbbV0uY29udGV4dCwgZiwgdSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBnW21dLmZuLmNhbGwoZ1ttXS5jb250ZXh0LCBmLCB1LCBoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAoIV8pXG4gICAgICAgICAgICAgIGZvciAoTyA9IDEsIF8gPSBuZXcgQXJyYXkodiAtIDEpOyBPIDwgdjsgTysrKVxuICAgICAgICAgICAgICAgIF9bTyAtIDFdID0gYXJndW1lbnRzW09dO1xuICAgICAgICAgICAgZ1ttXS5mbi5hcHBseShnW21dLmNvbnRleHQsIF8pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAhMDtcbiAgfSwgYS5wcm90b3R5cGUub24gPSBmdW5jdGlvbihsLCBmLCB1KSB7XG4gICAgcmV0dXJuIHModGhpcywgbCwgZiwgdSwgITEpO1xuICB9LCBhLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24obCwgZiwgdSkge1xuICAgIHJldHVybiBzKHRoaXMsIGwsIGYsIHUsICEwKTtcbiAgfSwgYS5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbihsLCBmLCB1LCBoKSB7XG4gICAgdmFyIGQgPSByID8gciArIGwgOiBsO1xuICAgIGlmICghdGhpcy5fZXZlbnRzW2RdKVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgaWYgKCFmKVxuICAgICAgcmV0dXJuIG8odGhpcywgZCksIHRoaXM7XG4gICAgdmFyIHAgPSB0aGlzLl9ldmVudHNbZF07XG4gICAgaWYgKHAuZm4pXG4gICAgICBwLmZuID09PSBmICYmICghaCB8fCBwLm9uY2UpICYmICghdSB8fCBwLmNvbnRleHQgPT09IHUpICYmIG8odGhpcywgZCk7XG4gICAgZWxzZSB7XG4gICAgICBmb3IgKHZhciB5ID0gMCwgZyA9IFtdLCB2ID0gcC5sZW5ndGg7IHkgPCB2OyB5KyspXG4gICAgICAgIChwW3ldLmZuICE9PSBmIHx8IGggJiYgIXBbeV0ub25jZSB8fCB1ICYmIHBbeV0uY29udGV4dCAhPT0gdSkgJiYgZy5wdXNoKHBbeV0pO1xuICAgICAgZy5sZW5ndGggPyB0aGlzLl9ldmVudHNbZF0gPSBnLmxlbmd0aCA9PT0gMSA/IGdbMF0gOiBnIDogbyh0aGlzLCBkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sIGEucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKGwpIHtcbiAgICB2YXIgZjtcbiAgICByZXR1cm4gbCA/IChmID0gciA/IHIgKyBsIDogbCwgdGhpcy5fZXZlbnRzW2ZdICYmIG8odGhpcywgZikpIDogKHRoaXMuX2V2ZW50cyA9IG5ldyBuKCksIHRoaXMuX2V2ZW50c0NvdW50ID0gMCksIHRoaXM7XG4gIH0sIGEucHJvdG90eXBlLm9mZiA9IGEucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyLCBhLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGEucHJvdG90eXBlLm9uLCBhLnByZWZpeGVkID0gciwgYS5FdmVudEVtaXR0ZXIgPSBhLCB0LmV4cG9ydHMgPSBhO1xufSkoWm8pO1xuY29uc3QgZHQgPSBaby5leHBvcnRzO1xuZnVuY3Rpb24gQW4odCkge1xuICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKHQpIHx8IHQgPCAwKVxuICAgIHRocm93IG5ldyBFcnJvcihgV3JvbmcgcG9zaXRpdmUgaW50ZWdlcjogJHt0fWApO1xufVxuZnVuY3Rpb24geWModCkge1xuICBpZiAodHlwZW9mIHQgIT0gXCJib29sZWFuXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBib29sZWFuLCBub3QgJHt0fWApO1xufVxuZnVuY3Rpb24gWW8odCwgLi4uZSkge1xuICBpZiAoISh0IGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIFVpbnQ4QXJyYXlcIik7XG4gIGlmIChlLmxlbmd0aCA+IDAgJiYgIWUuaW5jbHVkZXModC5sZW5ndGgpKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIFVpbnQ4QXJyYXkgb2YgbGVuZ3RoICR7ZX0sIG5vdCBvZiBsZW5ndGg9JHt0Lmxlbmd0aH1gKTtcbn1cbmZ1bmN0aW9uIGdjKHQpIHtcbiAgaWYgKHR5cGVvZiB0ICE9IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgdC5jcmVhdGUgIT0gXCJmdW5jdGlvblwiKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkhhc2ggc2hvdWxkIGJlIHdyYXBwZWQgYnkgdXRpbHMud3JhcENvbnN0cnVjdG9yXCIpO1xuICBBbih0Lm91dHB1dExlbiksIEFuKHQuYmxvY2tMZW4pO1xufVxuZnVuY3Rpb24gYmModCwgZSA9ICEwKSB7XG4gIGlmICh0LmRlc3Ryb3llZClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJIYXNoIGluc3RhbmNlIGhhcyBiZWVuIGRlc3Ryb3llZFwiKTtcbiAgaWYgKGUgJiYgdC5maW5pc2hlZClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJIYXNoI2RpZ2VzdCgpIGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkXCIpO1xufVxuZnVuY3Rpb24gdmModCwgZSkge1xuICBZbyh0KTtcbiAgY29uc3QgciA9IGUub3V0cHV0TGVuO1xuICBpZiAodC5sZW5ndGggPCByKVxuICAgIHRocm93IG5ldyBFcnJvcihgZGlnZXN0SW50bygpIGV4cGVjdHMgb3V0cHV0IGJ1ZmZlciBvZiBsZW5ndGggYXQgbGVhc3QgJHtyfWApO1xufVxuY29uc3QgdXQgPSB7XG4gIG51bWJlcjogQW4sXG4gIGJvb2w6IHljLFxuICBieXRlczogWW8sXG4gIGhhc2g6IGdjLFxuICBleGlzdHM6IGJjLFxuICBvdXRwdXQ6IHZjXG59LCB0biA9IHR5cGVvZiBnbG9iYWxUaGlzID09IFwib2JqZWN0XCIgJiYgXCJjcnlwdG9cIiBpbiBnbG9iYWxUaGlzID8gZ2xvYmFsVGhpcy5jcnlwdG8gOiB2b2lkIDA7XG4vKiEgbm9ibGUtaGFzaGVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5jb25zdCBybiA9ICh0KSA9PiBuZXcgRGF0YVZpZXcodC5idWZmZXIsIHQuYnl0ZU9mZnNldCwgdC5ieXRlTGVuZ3RoKSwgQWUgPSAodCwgZSkgPT4gdCA8PCAzMiAtIGUgfCB0ID4+PiBlLCB3YyA9IG5ldyBVaW50OEFycmF5KG5ldyBVaW50MzJBcnJheShbMjg3NDU0MDIwXSkuYnVmZmVyKVswXSA9PT0gNjg7XG5pZiAoIXdjKVxuICB0aHJvdyBuZXcgRXJyb3IoXCJOb24gbGl0dGxlLWVuZGlhbiBoYXJkd2FyZSBpcyBub3Qgc3VwcG9ydGVkXCIpO1xuQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sICh0LCBlKSA9PiBlLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIikpO1xuZnVuY3Rpb24gX2ModCkge1xuICBpZiAodHlwZW9mIHQgIT0gXCJzdHJpbmdcIilcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB1dGY4VG9CeXRlcyBleHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiB0fWApO1xuICByZXR1cm4gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHQpO1xufVxuZnVuY3Rpb24gRG4odCkge1xuICBpZiAodHlwZW9mIHQgPT0gXCJzdHJpbmdcIiAmJiAodCA9IF9jKHQpKSwgISh0IGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgaW5wdXQgdHlwZSBpcyBVaW50OEFycmF5IChnb3QgJHt0eXBlb2YgdH0pYCk7XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gbWMoLi4udCkge1xuICBpZiAoIXQuZXZlcnkoKG4pID0+IG4gaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVaW50OEFycmF5IGxpc3QgZXhwZWN0ZWRcIik7XG4gIGlmICh0Lmxlbmd0aCA9PT0gMSlcbiAgICByZXR1cm4gdFswXTtcbiAgY29uc3QgZSA9IHQucmVkdWNlKChuLCBpKSA9PiBuICsgaS5sZW5ndGgsIDApLCByID0gbmV3IFVpbnQ4QXJyYXkoZSk7XG4gIGZvciAobGV0IG4gPSAwLCBpID0gMDsgbiA8IHQubGVuZ3RoOyBuKyspIHtcbiAgICBjb25zdCBzID0gdFtuXTtcbiAgICByLnNldChzLCBpKSwgaSArPSBzLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gcjtcbn1cbmNsYXNzIEpvIHtcbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nsb25lSW50bygpO1xuICB9XG59XG5mdW5jdGlvbiBYbyh0KSB7XG4gIGNvbnN0IGUgPSAobikgPT4gdCgpLnVwZGF0ZShEbihuKSkuZGlnZXN0KCksIHIgPSB0KCk7XG4gIHJldHVybiBlLm91dHB1dExlbiA9IHIub3V0cHV0TGVuLCBlLmJsb2NrTGVuID0gci5ibG9ja0xlbiwgZS5jcmVhdGUgPSAoKSA9PiB0KCksIGU7XG59XG5mdW5jdGlvbiBRbyh0ID0gMzIpIHtcbiAgaWYgKHRuICYmIHR5cGVvZiB0bi5nZXRSYW5kb21WYWx1ZXMgPT0gXCJmdW5jdGlvblwiKVxuICAgIHJldHVybiB0bi5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkodCkpO1xuICB0aHJvdyBuZXcgRXJyb3IoXCJjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIG11c3QgYmUgZGVmaW5lZFwiKTtcbn1cbmZ1bmN0aW9uIHhjKHQsIGUsIHIsIG4pIHtcbiAgaWYgKHR5cGVvZiB0LnNldEJpZ1VpbnQ2NCA9PSBcImZ1bmN0aW9uXCIpXG4gICAgcmV0dXJuIHQuc2V0QmlnVWludDY0KGUsIHIsIG4pO1xuICBjb25zdCBpID0gQmlnSW50KDMyKSwgcyA9IEJpZ0ludCg0Mjk0OTY3Mjk1KSwgbyA9IE51bWJlcihyID4+IGkgJiBzKSwgYSA9IE51bWJlcihyICYgcyksIGMgPSBuID8gNCA6IDAsIGwgPSBuID8gMCA6IDQ7XG4gIHQuc2V0VWludDMyKGUgKyBjLCBvLCBuKSwgdC5zZXRVaW50MzIoZSArIGwsIGEsIG4pO1xufVxuY2xhc3MgRWMgZXh0ZW5kcyBKbyB7XG4gIGNvbnN0cnVjdG9yKGUsIHIsIG4sIGkpIHtcbiAgICBzdXBlcigpLCB0aGlzLmJsb2NrTGVuID0gZSwgdGhpcy5vdXRwdXRMZW4gPSByLCB0aGlzLnBhZE9mZnNldCA9IG4sIHRoaXMuaXNMRSA9IGksIHRoaXMuZmluaXNoZWQgPSAhMSwgdGhpcy5sZW5ndGggPSAwLCB0aGlzLnBvcyA9IDAsIHRoaXMuZGVzdHJveWVkID0gITEsIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoZSksIHRoaXMudmlldyA9IHJuKHRoaXMuYnVmZmVyKTtcbiAgfVxuICB1cGRhdGUoZSkge1xuICAgIHV0LmV4aXN0cyh0aGlzKTtcbiAgICBjb25zdCB7IHZpZXc6IHIsIGJ1ZmZlcjogbiwgYmxvY2tMZW46IGkgfSA9IHRoaXM7XG4gICAgZSA9IERuKGUpO1xuICAgIGNvbnN0IHMgPSBlLmxlbmd0aDtcbiAgICBmb3IgKGxldCBvID0gMDsgbyA8IHM7ICkge1xuICAgICAgY29uc3QgYSA9IE1hdGgubWluKGkgLSB0aGlzLnBvcywgcyAtIG8pO1xuICAgICAgaWYgKGEgPT09IGkpIHtcbiAgICAgICAgY29uc3QgYyA9IHJuKGUpO1xuICAgICAgICBmb3IgKDsgaSA8PSBzIC0gbzsgbyArPSBpKVxuICAgICAgICAgIHRoaXMucHJvY2VzcyhjLCBvKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBuLnNldChlLnN1YmFycmF5KG8sIG8gKyBhKSwgdGhpcy5wb3MpLCB0aGlzLnBvcyArPSBhLCBvICs9IGEsIHRoaXMucG9zID09PSBpICYmICh0aGlzLnByb2Nlc3MociwgMCksIHRoaXMucG9zID0gMCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxlbmd0aCArPSBlLmxlbmd0aCwgdGhpcy5yb3VuZENsZWFuKCksIHRoaXM7XG4gIH1cbiAgZGlnZXN0SW50byhlKSB7XG4gICAgdXQuZXhpc3RzKHRoaXMpLCB1dC5vdXRwdXQoZSwgdGhpcyksIHRoaXMuZmluaXNoZWQgPSAhMDtcbiAgICBjb25zdCB7IGJ1ZmZlcjogciwgdmlldzogbiwgYmxvY2tMZW46IGksIGlzTEU6IHMgfSA9IHRoaXM7XG4gICAgbGV0IHsgcG9zOiBvIH0gPSB0aGlzO1xuICAgIHJbbysrXSA9IDEyOCwgdGhpcy5idWZmZXIuc3ViYXJyYXkobykuZmlsbCgwKSwgdGhpcy5wYWRPZmZzZXQgPiBpIC0gbyAmJiAodGhpcy5wcm9jZXNzKG4sIDApLCBvID0gMCk7XG4gICAgZm9yIChsZXQgdSA9IG87IHUgPCBpOyB1KyspXG4gICAgICByW3VdID0gMDtcbiAgICB4YyhuLCBpIC0gOCwgQmlnSW50KHRoaXMubGVuZ3RoICogOCksIHMpLCB0aGlzLnByb2Nlc3MobiwgMCk7XG4gICAgY29uc3QgYSA9IHJuKGUpLCBjID0gdGhpcy5vdXRwdXRMZW47XG4gICAgaWYgKGMgJSA0KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiX3NoYTI6IG91dHB1dExlbiBzaG91bGQgYmUgYWxpZ25lZCB0byAzMmJpdFwiKTtcbiAgICBjb25zdCBsID0gYyAvIDQsIGYgPSB0aGlzLmdldCgpO1xuICAgIGlmIChsID4gZi5sZW5ndGgpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJfc2hhMjogb3V0cHV0TGVuIGJpZ2dlciB0aGFuIHN0YXRlXCIpO1xuICAgIGZvciAobGV0IHUgPSAwOyB1IDwgbDsgdSsrKVxuICAgICAgYS5zZXRVaW50MzIoNCAqIHUsIGZbdV0sIHMpO1xuICB9XG4gIGRpZ2VzdCgpIHtcbiAgICBjb25zdCB7IGJ1ZmZlcjogZSwgb3V0cHV0TGVuOiByIH0gPSB0aGlzO1xuICAgIHRoaXMuZGlnZXN0SW50byhlKTtcbiAgICBjb25zdCBuID0gZS5zbGljZSgwLCByKTtcbiAgICByZXR1cm4gdGhpcy5kZXN0cm95KCksIG47XG4gIH1cbiAgX2Nsb25lSW50byhlKSB7XG4gICAgZSB8fCAoZSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkpLCBlLnNldCguLi50aGlzLmdldCgpKTtcbiAgICBjb25zdCB7IGJsb2NrTGVuOiByLCBidWZmZXI6IG4sIGxlbmd0aDogaSwgZmluaXNoZWQ6IHMsIGRlc3Ryb3llZDogbywgcG9zOiBhIH0gPSB0aGlzO1xuICAgIHJldHVybiBlLmxlbmd0aCA9IGksIGUucG9zID0gYSwgZS5maW5pc2hlZCA9IHMsIGUuZGVzdHJveWVkID0gbywgaSAlIHIgJiYgZS5idWZmZXIuc2V0KG4pLCBlO1xuICB9XG59XG5jb25zdCBrYyA9ICh0LCBlLCByKSA9PiB0ICYgZSBeIH50ICYgciwgU2MgPSAodCwgZSwgcikgPT4gdCAmIGUgXiB0ICYgciBeIGUgJiByLCBPYyA9IG5ldyBVaW50MzJBcnJheShbXG4gIDExMTYzNTI0MDgsXG4gIDE4OTk0NDc0NDEsXG4gIDMwNDkzMjM0NzEsXG4gIDM5MjEwMDk1NzMsXG4gIDk2MTk4NzE2MyxcbiAgMTUwODk3MDk5MyxcbiAgMjQ1MzYzNTc0OCxcbiAgMjg3MDc2MzIyMSxcbiAgMzYyNDM4MTA4MCxcbiAgMzEwNTk4NDAxLFxuICA2MDcyMjUyNzgsXG4gIDE0MjY4ODE5ODcsXG4gIDE5MjUwNzgzODgsXG4gIDIxNjIwNzgyMDYsXG4gIDI2MTQ4ODgxMDMsXG4gIDMyNDgyMjI1ODAsXG4gIDM4MzUzOTA0MDEsXG4gIDQwMjIyMjQ3NzQsXG4gIDI2NDM0NzA3OCxcbiAgNjA0ODA3NjI4LFxuICA3NzAyNTU5ODMsXG4gIDEyNDkxNTAxMjIsXG4gIDE1NTUwODE2OTIsXG4gIDE5OTYwNjQ5ODYsXG4gIDI1NTQyMjA4ODIsXG4gIDI4MjE4MzQzNDksXG4gIDI5NTI5OTY4MDgsXG4gIDMyMTAzMTM2NzEsXG4gIDMzMzY1NzE4OTEsXG4gIDM1ODQ1Mjg3MTEsXG4gIDExMzkyNjk5MyxcbiAgMzM4MjQxODk1LFxuICA2NjYzMDcyMDUsXG4gIDc3MzUyOTkxMixcbiAgMTI5NDc1NzM3MixcbiAgMTM5NjE4MjI5MSxcbiAgMTY5NTE4MzcwMCxcbiAgMTk4NjY2MTA1MSxcbiAgMjE3NzAyNjM1MCxcbiAgMjQ1Njk1NjAzNyxcbiAgMjczMDQ4NTkyMSxcbiAgMjgyMDMwMjQxMSxcbiAgMzI1OTczMDgwMCxcbiAgMzM0NTc2NDc3MSxcbiAgMzUxNjA2NTgxNyxcbiAgMzYwMDM1MjgwNCxcbiAgNDA5NDU3MTkwOSxcbiAgMjc1NDIzMzQ0LFxuICA0MzAyMjc3MzQsXG4gIDUwNjk0ODYxNixcbiAgNjU5MDYwNTU2LFxuICA4ODM5OTc4NzcsXG4gIDk1ODEzOTU3MSxcbiAgMTMyMjgyMjIxOCxcbiAgMTUzNzAwMjA2MyxcbiAgMTc0Nzg3Mzc3OSxcbiAgMTk1NTU2MjIyMixcbiAgMjAyNDEwNDgxNSxcbiAgMjIyNzczMDQ1MixcbiAgMjM2MTg1MjQyNCxcbiAgMjQyODQzNjQ3NCxcbiAgMjc1NjczNDE4NyxcbiAgMzIwNDAzMTQ3OSxcbiAgMzMyOTMyNTI5OFxuXSksIE1lID0gbmV3IFVpbnQzMkFycmF5KFtcbiAgMTc3OTAzMzcwMyxcbiAgMzE0NDEzNDI3NyxcbiAgMTAxMzkwNDI0MixcbiAgMjc3MzQ4MDc2MixcbiAgMTM1OTg5MzExOSxcbiAgMjYwMDgyMjkyNCxcbiAgNTI4NzM0NjM1LFxuICAxNTQxNDU5MjI1XG5dKSwgRGUgPSBuZXcgVWludDMyQXJyYXkoNjQpO1xuY2xhc3MgZXMgZXh0ZW5kcyBFYyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKDY0LCAzMiwgOCwgITEpLCB0aGlzLkEgPSBNZVswXSB8IDAsIHRoaXMuQiA9IE1lWzFdIHwgMCwgdGhpcy5DID0gTWVbMl0gfCAwLCB0aGlzLkQgPSBNZVszXSB8IDAsIHRoaXMuRSA9IE1lWzRdIHwgMCwgdGhpcy5GID0gTWVbNV0gfCAwLCB0aGlzLkcgPSBNZVs2XSB8IDAsIHRoaXMuSCA9IE1lWzddIHwgMDtcbiAgfVxuICBnZXQoKSB7XG4gICAgY29uc3QgeyBBOiBlLCBCOiByLCBDOiBuLCBEOiBpLCBFOiBzLCBGOiBvLCBHOiBhLCBIOiBjIH0gPSB0aGlzO1xuICAgIHJldHVybiBbZSwgciwgbiwgaSwgcywgbywgYSwgY107XG4gIH1cbiAgc2V0KGUsIHIsIG4sIGksIHMsIG8sIGEsIGMpIHtcbiAgICB0aGlzLkEgPSBlIHwgMCwgdGhpcy5CID0gciB8IDAsIHRoaXMuQyA9IG4gfCAwLCB0aGlzLkQgPSBpIHwgMCwgdGhpcy5FID0gcyB8IDAsIHRoaXMuRiA9IG8gfCAwLCB0aGlzLkcgPSBhIHwgMCwgdGhpcy5IID0gYyB8IDA7XG4gIH1cbiAgcHJvY2VzcyhlLCByKSB7XG4gICAgZm9yIChsZXQgdSA9IDA7IHUgPCAxNjsgdSsrLCByICs9IDQpXG4gICAgICBEZVt1XSA9IGUuZ2V0VWludDMyKHIsICExKTtcbiAgICBmb3IgKGxldCB1ID0gMTY7IHUgPCA2NDsgdSsrKSB7XG4gICAgICBjb25zdCBoID0gRGVbdSAtIDE1XSwgZCA9IERlW3UgLSAyXSwgcCA9IEFlKGgsIDcpIF4gQWUoaCwgMTgpIF4gaCA+Pj4gMywgeSA9IEFlKGQsIDE3KSBeIEFlKGQsIDE5KSBeIGQgPj4+IDEwO1xuICAgICAgRGVbdV0gPSB5ICsgRGVbdSAtIDddICsgcCArIERlW3UgLSAxNl0gfCAwO1xuICAgIH1cbiAgICBsZXQgeyBBOiBuLCBCOiBpLCBDOiBzLCBEOiBvLCBFOiBhLCBGOiBjLCBHOiBsLCBIOiBmIH0gPSB0aGlzO1xuICAgIGZvciAobGV0IHUgPSAwOyB1IDwgNjQ7IHUrKykge1xuICAgICAgY29uc3QgaCA9IEFlKGEsIDYpIF4gQWUoYSwgMTEpIF4gQWUoYSwgMjUpLCBkID0gZiArIGggKyBrYyhhLCBjLCBsKSArIE9jW3VdICsgRGVbdV0gfCAwLCB5ID0gKEFlKG4sIDIpIF4gQWUobiwgMTMpIF4gQWUobiwgMjIpKSArIFNjKG4sIGksIHMpIHwgMDtcbiAgICAgIGYgPSBsLCBsID0gYywgYyA9IGEsIGEgPSBvICsgZCB8IDAsIG8gPSBzLCBzID0gaSwgaSA9IG4sIG4gPSBkICsgeSB8IDA7XG4gICAgfVxuICAgIG4gPSBuICsgdGhpcy5BIHwgMCwgaSA9IGkgKyB0aGlzLkIgfCAwLCBzID0gcyArIHRoaXMuQyB8IDAsIG8gPSBvICsgdGhpcy5EIHwgMCwgYSA9IGEgKyB0aGlzLkUgfCAwLCBjID0gYyArIHRoaXMuRiB8IDAsIGwgPSBsICsgdGhpcy5HIHwgMCwgZiA9IGYgKyB0aGlzLkggfCAwLCB0aGlzLnNldChuLCBpLCBzLCBvLCBhLCBjLCBsLCBmKTtcbiAgfVxuICByb3VuZENsZWFuKCkge1xuICAgIERlLmZpbGwoMCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKSwgdGhpcy5idWZmZXIuZmlsbCgwKTtcbiAgfVxufVxuY2xhc3MgQWMgZXh0ZW5kcyBlcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCksIHRoaXMuQSA9IC0xMDU2NTk2MjY0LCB0aGlzLkIgPSA5MTQxNTA2NjMsIHRoaXMuQyA9IDgxMjcwMjk5OSwgdGhpcy5EID0gLTE1MDA1NDU5OSwgdGhpcy5FID0gLTQxOTE0MzksIHRoaXMuRiA9IDE3NTA2MDMwMjUsIHRoaXMuRyA9IDE2OTQwNzY4MzksIHRoaXMuSCA9IC0xMDkwODkxODY4LCB0aGlzLm91dHB1dExlbiA9IDI4O1xuICB9XG59XG5jb25zdCBPciA9IFhvKCgpID0+IG5ldyBlcygpKTtcblhvKCgpID0+IG5ldyBBYygpKTtcbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmNvbnN0IHRzID0gQmlnSW50KDApLCBMciA9IEJpZ0ludCgxKSwgQ2MgPSBCaWdJbnQoMiksICRyID0gKHQpID0+IHQgaW5zdGFuY2VvZiBVaW50OEFycmF5LCBJYyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAodCwgZSkgPT4gZS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpKTtcbmZ1bmN0aW9uIHZ0KHQpIHtcbiAgaWYgKCEkcih0KSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVaW50OEFycmF5IGV4cGVjdGVkXCIpO1xuICBsZXQgZSA9IFwiXCI7XG4gIGZvciAobGV0IHIgPSAwOyByIDwgdC5sZW5ndGg7IHIrKylcbiAgICBlICs9IEljW3Rbcl1dO1xuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIHJzKHQpIHtcbiAgY29uc3QgZSA9IHQudG9TdHJpbmcoMTYpO1xuICByZXR1cm4gZS5sZW5ndGggJiAxID8gYDAke2V9YCA6IGU7XG59XG5mdW5jdGlvbiB6bih0KSB7XG4gIGlmICh0eXBlb2YgdCAhPSBcInN0cmluZ1wiKVxuICAgIHRocm93IG5ldyBFcnJvcihcImhleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCBcIiArIHR5cGVvZiB0KTtcbiAgcmV0dXJuIEJpZ0ludCh0ID09PSBcIlwiID8gXCIwXCIgOiBgMHgke3R9YCk7XG59XG5mdW5jdGlvbiB3dCh0KSB7XG4gIGlmICh0eXBlb2YgdCAhPSBcInN0cmluZ1wiKVxuICAgIHRocm93IG5ldyBFcnJvcihcImhleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCBcIiArIHR5cGVvZiB0KTtcbiAgaWYgKHQubGVuZ3RoICUgMilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJoZXggc3RyaW5nIGlzIGludmFsaWQ6IHVucGFkZGVkIFwiICsgdC5sZW5ndGgpO1xuICBjb25zdCBlID0gbmV3IFVpbnQ4QXJyYXkodC5sZW5ndGggLyAyKTtcbiAgZm9yIChsZXQgciA9IDA7IHIgPCBlLmxlbmd0aDsgcisrKSB7XG4gICAgY29uc3QgbiA9IHIgKiAyLCBpID0gdC5zbGljZShuLCBuICsgMiksIHMgPSBOdW1iZXIucGFyc2VJbnQoaSwgMTYpO1xuICAgIGlmIChOdW1iZXIuaXNOYU4ocykgfHwgcyA8IDApXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGJ5dGUgc2VxdWVuY2VcIik7XG4gICAgZVtyXSA9IHM7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBsZSh0KSB7XG4gIHJldHVybiB6bih2dCh0KSk7XG59XG5mdW5jdGlvbiBGbih0KSB7XG4gIGlmICghJHIodCkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVWludDhBcnJheSBleHBlY3RlZFwiKTtcbiAgcmV0dXJuIHpuKHZ0KFVpbnQ4QXJyYXkuZnJvbSh0KS5yZXZlcnNlKCkpKTtcbn1cbmNvbnN0IGV0ID0gKHQsIGUpID0+IHd0KHQudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KGUgKiAyLCBcIjBcIikpLCBucyA9ICh0LCBlKSA9PiBldCh0LCBlKS5yZXZlcnNlKCksIFJjID0gKHQpID0+IHd0KHJzKHQpKTtcbmZ1bmN0aW9uIGVlKHQsIGUsIHIpIHtcbiAgbGV0IG47XG4gIGlmICh0eXBlb2YgZSA9PSBcInN0cmluZ1wiKVxuICAgIHRyeSB7XG4gICAgICBuID0gd3QoZSk7XG4gICAgfSBjYXRjaCAocykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3R9IG11c3QgYmUgdmFsaWQgaGV4IHN0cmluZywgZ290IFwiJHtlfVwiLiBDYXVzZTogJHtzfWApO1xuICAgIH1cbiAgZWxzZSBpZiAoJHIoZSkpXG4gICAgbiA9IFVpbnQ4QXJyYXkuZnJvbShlKTtcbiAgZWxzZVxuICAgIHRocm93IG5ldyBFcnJvcihgJHt0fSBtdXN0IGJlIGhleCBzdHJpbmcgb3IgVWludDhBcnJheWApO1xuICBjb25zdCBpID0gbi5sZW5ndGg7XG4gIGlmICh0eXBlb2YgciA9PSBcIm51bWJlclwiICYmIGkgIT09IHIpXG4gICAgdGhyb3cgbmV3IEVycm9yKGAke3R9IGV4cGVjdGVkICR7cn0gYnl0ZXMsIGdvdCAke2l9YCk7XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gaGUoLi4udCkge1xuICBjb25zdCBlID0gbmV3IFVpbnQ4QXJyYXkodC5yZWR1Y2UoKG4sIGkpID0+IG4gKyBpLmxlbmd0aCwgMCkpO1xuICBsZXQgciA9IDA7XG4gIHJldHVybiB0LmZvckVhY2goKG4pID0+IHtcbiAgICBpZiAoISRyKG4pKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVWludDhBcnJheSBleHBlY3RlZFwiKTtcbiAgICBlLnNldChuLCByKSwgciArPSBuLmxlbmd0aDtcbiAgfSksIGU7XG59XG5mdW5jdGlvbiBUYyh0LCBlKSB7XG4gIGlmICh0Lmxlbmd0aCAhPT0gZS5sZW5ndGgpXG4gICAgcmV0dXJuICExO1xuICBmb3IgKGxldCByID0gMDsgciA8IHQubGVuZ3RoOyByKyspXG4gICAgaWYgKHRbcl0gIT09IGVbcl0pXG4gICAgICByZXR1cm4gITE7XG4gIHJldHVybiAhMDtcbn1cbmZ1bmN0aW9uIHFyKHQpIHtcbiAgaWYgKHR5cGVvZiB0ICE9IFwic3RyaW5nXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKGB1dGY4VG9CeXRlcyBleHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiB0fWApO1xuICByZXR1cm4gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHQpO1xufVxuZnVuY3Rpb24gUGModCkge1xuICBsZXQgZTtcbiAgZm9yIChlID0gMDsgdCA+IHRzOyB0ID4+PSBMciwgZSArPSAxKVxuICAgIDtcbiAgcmV0dXJuIGU7XG59XG5jb25zdCBCYyA9ICh0LCBlKSA9PiB0ID4+IEJpZ0ludChlKSAmIExyLCBMYyA9ICh0LCBlLCByKSA9PiB0IHwgKHIgPyBMciA6IHRzKSA8PCBCaWdJbnQoZSksIEtuID0gKHQpID0+IChDYyA8PCBCaWdJbnQodCAtIDEpKSAtIExyLCBubiA9ICh0KSA9PiBuZXcgVWludDhBcnJheSh0KSwgTmkgPSAodCkgPT4gVWludDhBcnJheS5mcm9tKHQpO1xuZnVuY3Rpb24gaXModCwgZSwgcikge1xuICBpZiAodHlwZW9mIHQgIT0gXCJudW1iZXJcIiB8fCB0IDwgMilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJoYXNoTGVuIG11c3QgYmUgYSBudW1iZXJcIik7XG4gIGlmICh0eXBlb2YgZSAhPSBcIm51bWJlclwiIHx8IGUgPCAyKVxuICAgIHRocm93IG5ldyBFcnJvcihcInFCeXRlTGVuIG11c3QgYmUgYSBudW1iZXJcIik7XG4gIGlmICh0eXBlb2YgciAhPSBcImZ1bmN0aW9uXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaG1hY0ZuIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgbGV0IG4gPSBubih0KSwgaSA9IG5uKHQpLCBzID0gMDtcbiAgY29uc3QgbyA9ICgpID0+IHtcbiAgICBuLmZpbGwoMSksIGkuZmlsbCgwKSwgcyA9IDA7XG4gIH0sIGEgPSAoLi4udSkgPT4gcihpLCBuLCAuLi51KSwgYyA9ICh1ID0gbm4oKSkgPT4ge1xuICAgIGkgPSBhKE5pKFswXSksIHUpLCBuID0gYSgpLCB1Lmxlbmd0aCAhPT0gMCAmJiAoaSA9IGEoTmkoWzFdKSwgdSksIG4gPSBhKCkpO1xuICB9LCBsID0gKCkgPT4ge1xuICAgIGlmIChzKysgPj0gMWUzKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZHJiZzogdHJpZWQgMTAwMCB2YWx1ZXNcIik7XG4gICAgbGV0IHUgPSAwO1xuICAgIGNvbnN0IGggPSBbXTtcbiAgICBmb3IgKDsgdSA8IGU7ICkge1xuICAgICAgbiA9IGEoKTtcbiAgICAgIGNvbnN0IGQgPSBuLnNsaWNlKCk7XG4gICAgICBoLnB1c2goZCksIHUgKz0gbi5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBoZSguLi5oKTtcbiAgfTtcbiAgcmV0dXJuICh1LCBoKSA9PiB7XG4gICAgbygpLCBjKHUpO1xuICAgIGxldCBkO1xuICAgIGZvciAoOyAhKGQgPSBoKGwoKSkpOyApXG4gICAgICBjKCk7XG4gICAgcmV0dXJuIG8oKSwgZDtcbiAgfTtcbn1cbmNvbnN0ICRjID0ge1xuICBiaWdpbnQ6ICh0KSA9PiB0eXBlb2YgdCA9PSBcImJpZ2ludFwiLFxuICBmdW5jdGlvbjogKHQpID0+IHR5cGVvZiB0ID09IFwiZnVuY3Rpb25cIixcbiAgYm9vbGVhbjogKHQpID0+IHR5cGVvZiB0ID09IFwiYm9vbGVhblwiLFxuICBzdHJpbmc6ICh0KSA9PiB0eXBlb2YgdCA9PSBcInN0cmluZ1wiLFxuICBpc1NhZmVJbnRlZ2VyOiAodCkgPT4gTnVtYmVyLmlzU2FmZUludGVnZXIodCksXG4gIGFycmF5OiAodCkgPT4gQXJyYXkuaXNBcnJheSh0KSxcbiAgZmllbGQ6ICh0LCBlKSA9PiBlLkZwLmlzVmFsaWQodCksXG4gIGhhc2g6ICh0KSA9PiB0eXBlb2YgdCA9PSBcImZ1bmN0aW9uXCIgJiYgTnVtYmVyLmlzU2FmZUludGVnZXIodC5vdXRwdXRMZW4pXG59O1xuZnVuY3Rpb24ga3QodCwgZSwgciA9IHt9KSB7XG4gIGNvbnN0IG4gPSAoaSwgcywgbykgPT4ge1xuICAgIGNvbnN0IGEgPSAkY1tzXTtcbiAgICBpZiAodHlwZW9mIGEgIT0gXCJmdW5jdGlvblwiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHZhbGlkYXRvciBcIiR7c31cIiwgZXhwZWN0ZWQgZnVuY3Rpb25gKTtcbiAgICBjb25zdCBjID0gdFtpXTtcbiAgICBpZiAoIShvICYmIGMgPT09IHZvaWQgMCkgJiYgIWEoYywgdCkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcGFyYW0gJHtTdHJpbmcoaSl9PSR7Y30gKCR7dHlwZW9mIGN9KSwgZXhwZWN0ZWQgJHtzfWApO1xuICB9O1xuICBmb3IgKGNvbnN0IFtpLCBzXSBvZiBPYmplY3QuZW50cmllcyhlKSlcbiAgICBuKGksIHMsICExKTtcbiAgZm9yIChjb25zdCBbaSwgc10gb2YgT2JqZWN0LmVudHJpZXMocikpXG4gICAgbihpLCBzLCAhMCk7XG4gIHJldHVybiB0O1xufVxuY29uc3QgcWMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgX19wcm90b19fOiBudWxsLFxuICBieXRlc1RvSGV4OiB2dCxcbiAgbnVtYmVyVG9IZXhVbnBhZGRlZDogcnMsXG4gIGhleFRvTnVtYmVyOiB6bixcbiAgaGV4VG9CeXRlczogd3QsXG4gIGJ5dGVzVG9OdW1iZXJCRTogbGUsXG4gIGJ5dGVzVG9OdW1iZXJMRTogRm4sXG4gIG51bWJlclRvQnl0ZXNCRTogZXQsXG4gIG51bWJlclRvQnl0ZXNMRTogbnMsXG4gIG51bWJlclRvVmFyQnl0ZXNCRTogUmMsXG4gIGVuc3VyZUJ5dGVzOiBlZSxcbiAgY29uY2F0Qnl0ZXM6IGhlLFxuICBlcXVhbEJ5dGVzOiBUYyxcbiAgdXRmOFRvQnl0ZXM6IHFyLFxuICBiaXRMZW46IFBjLFxuICBiaXRHZXQ6IEJjLFxuICBiaXRTZXQ6IExjLFxuICBiaXRNYXNrOiBLbixcbiAgY3JlYXRlSG1hY0RyYmc6IGlzLFxuICB2YWxpZGF0ZU9iamVjdDoga3Rcbn0sIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KSk7XG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5jb25zdCBRID0gQmlnSW50KDApLCBWID0gQmlnSW50KDEpLCBhdCA9IEJpZ0ludCgyKSwgTmMgPSBCaWdJbnQoMyksIENuID0gQmlnSW50KDQpLCBVaSA9IEJpZ0ludCg1KSwgamkgPSBCaWdJbnQoOCk7XG5CaWdJbnQoOSk7XG5CaWdJbnQoMTYpO1xuZnVuY3Rpb24gSih0LCBlKSB7XG4gIGNvbnN0IHIgPSB0ICUgZTtcbiAgcmV0dXJuIHIgPj0gUSA/IHIgOiBlICsgcjtcbn1cbmZ1bmN0aW9uIFVjKHQsIGUsIHIpIHtcbiAgaWYgKHIgPD0gUSB8fCBlIDwgUSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBwb3dlci9tb2R1bG8gPiAwXCIpO1xuICBpZiAociA9PT0gVilcbiAgICByZXR1cm4gUTtcbiAgbGV0IG4gPSBWO1xuICBmb3IgKDsgZSA+IFE7IClcbiAgICBlICYgViAmJiAobiA9IG4gKiB0ICUgciksIHQgPSB0ICogdCAlIHIsIGUgPj49IFY7XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gYmUodCwgZSwgcikge1xuICBsZXQgbiA9IHQ7XG4gIGZvciAoOyBlLS0gPiBROyApXG4gICAgbiAqPSBuLCBuICU9IHI7XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gSW4odCwgZSkge1xuICBpZiAodCA9PT0gUSB8fCBlIDw9IFEpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBpbnZlcnQ6IGV4cGVjdGVkIHBvc2l0aXZlIGludGVnZXJzLCBnb3Qgbj0ke3R9IG1vZD0ke2V9YCk7XG4gIGxldCByID0gSih0LCBlKSwgbiA9IGUsIGkgPSBRLCBzID0gVjtcbiAgZm9yICg7IHIgIT09IFE7ICkge1xuICAgIGNvbnN0IGEgPSBuIC8gciwgYyA9IG4gJSByLCBsID0gaSAtIHMgKiBhO1xuICAgIG4gPSByLCByID0gYywgaSA9IHMsIHMgPSBsO1xuICB9XG4gIGlmIChuICE9PSBWKVxuICAgIHRocm93IG5ldyBFcnJvcihcImludmVydDogZG9lcyBub3QgZXhpc3RcIik7XG4gIHJldHVybiBKKGksIGUpO1xufVxuZnVuY3Rpb24gamModCkge1xuICBjb25zdCBlID0gKHQgLSBWKSAvIGF0O1xuICBsZXQgciwgbiwgaTtcbiAgZm9yIChyID0gdCAtIFYsIG4gPSAwOyByICUgYXQgPT09IFE7IHIgLz0gYXQsIG4rKylcbiAgICA7XG4gIGZvciAoaSA9IGF0OyBpIDwgdCAmJiBVYyhpLCBlLCB0KSAhPT0gdCAtIFY7IGkrKylcbiAgICA7XG4gIGlmIChuID09PSAxKSB7XG4gICAgY29uc3QgbyA9ICh0ICsgVikgLyBDbjtcbiAgICByZXR1cm4gZnVuY3Rpb24oYywgbCkge1xuICAgICAgY29uc3QgZiA9IGMucG93KGwsIG8pO1xuICAgICAgaWYgKCFjLmVxbChjLnNxcihmKSwgbCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIHNxdWFyZSByb290XCIpO1xuICAgICAgcmV0dXJuIGY7XG4gICAgfTtcbiAgfVxuICBjb25zdCBzID0gKHIgKyBWKSAvIGF0O1xuICByZXR1cm4gZnVuY3Rpb24oYSwgYykge1xuICAgIGlmIChhLnBvdyhjLCBlKSA9PT0gYS5uZWcoYS5PTkUpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3RcIik7XG4gICAgbGV0IGwgPSBuLCBmID0gYS5wb3coYS5tdWwoYS5PTkUsIGkpLCByKSwgdSA9IGEucG93KGMsIHMpLCBoID0gYS5wb3coYywgcik7XG4gICAgZm9yICg7ICFhLmVxbChoLCBhLk9ORSk7ICkge1xuICAgICAgaWYgKGEuZXFsKGgsIGEuWkVSTykpXG4gICAgICAgIHJldHVybiBhLlpFUk87XG4gICAgICBsZXQgZCA9IDE7XG4gICAgICBmb3IgKGxldCB5ID0gYS5zcXIoaCk7IGQgPCBsICYmICFhLmVxbCh5LCBhLk9ORSk7IGQrKylcbiAgICAgICAgeSA9IGEuc3FyKHkpO1xuICAgICAgY29uc3QgcCA9IGEucG93KGYsIFYgPDwgQmlnSW50KGwgLSBkIC0gMSkpO1xuICAgICAgZiA9IGEuc3FyKHApLCB1ID0gYS5tdWwodSwgcCksIGggPSBhLm11bChoLCBmKSwgbCA9IGQ7XG4gICAgfVxuICAgIHJldHVybiB1O1xuICB9O1xufVxuZnVuY3Rpb24gSGModCkge1xuICBpZiAodCAlIENuID09PSBOYykge1xuICAgIGNvbnN0IGUgPSAodCArIFYpIC8gQ247XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG4sIGkpIHtcbiAgICAgIGNvbnN0IHMgPSBuLnBvdyhpLCBlKTtcbiAgICAgIGlmICghbi5lcWwobi5zcXIocyksIGkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBzcXVhcmUgcm9vdFwiKTtcbiAgICAgIHJldHVybiBzO1xuICAgIH07XG4gIH1cbiAgaWYgKHQgJSBqaSA9PT0gVWkpIHtcbiAgICBjb25zdCBlID0gKHQgLSBVaSkgLyBqaTtcbiAgICByZXR1cm4gZnVuY3Rpb24obiwgaSkge1xuICAgICAgY29uc3QgcyA9IG4ubXVsKGksIGF0KSwgbyA9IG4ucG93KHMsIGUpLCBhID0gbi5tdWwoaSwgbyksIGMgPSBuLm11bChuLm11bChhLCBhdCksIG8pLCBsID0gbi5tdWwoYSwgbi5zdWIoYywgbi5PTkUpKTtcbiAgICAgIGlmICghbi5lcWwobi5zcXIobCksIGkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBzcXVhcmUgcm9vdFwiKTtcbiAgICAgIHJldHVybiBsO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGpjKHQpO1xufVxuY29uc3QgTWMgPSBbXG4gIFwiY3JlYXRlXCIsXG4gIFwiaXNWYWxpZFwiLFxuICBcImlzMFwiLFxuICBcIm5lZ1wiLFxuICBcImludlwiLFxuICBcInNxcnRcIixcbiAgXCJzcXJcIixcbiAgXCJlcWxcIixcbiAgXCJhZGRcIixcbiAgXCJzdWJcIixcbiAgXCJtdWxcIixcbiAgXCJwb3dcIixcbiAgXCJkaXZcIixcbiAgXCJhZGROXCIsXG4gIFwic3ViTlwiLFxuICBcIm11bE5cIixcbiAgXCJzcXJOXCJcbl07XG5mdW5jdGlvbiBvcyh0KSB7XG4gIGNvbnN0IGUgPSB7XG4gICAgT1JERVI6IFwiYmlnaW50XCIsXG4gICAgTUFTSzogXCJiaWdpbnRcIixcbiAgICBCWVRFUzogXCJpc1NhZmVJbnRlZ2VyXCIsXG4gICAgQklUUzogXCJpc1NhZmVJbnRlZ2VyXCJcbiAgfSwgciA9IE1jLnJlZHVjZSgobiwgaSkgPT4gKG5baV0gPSBcImZ1bmN0aW9uXCIsIG4pLCBlKTtcbiAgcmV0dXJuIGt0KHQsIHIpO1xufVxuZnVuY3Rpb24gRGModCwgZSwgcikge1xuICBpZiAociA8IFEpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgcG93ZXIgPiAwXCIpO1xuICBpZiAociA9PT0gUSlcbiAgICByZXR1cm4gdC5PTkU7XG4gIGlmIChyID09PSBWKVxuICAgIHJldHVybiBlO1xuICBsZXQgbiA9IHQuT05FLCBpID0gZTtcbiAgZm9yICg7IHIgPiBROyApXG4gICAgciAmIFYgJiYgKG4gPSB0Lm11bChuLCBpKSksIGkgPSB0LnNxcihpKSwgciA+Pj0gVjtcbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiB6Yyh0LCBlKSB7XG4gIGNvbnN0IHIgPSBuZXcgQXJyYXkoZS5sZW5ndGgpLCBuID0gZS5yZWR1Y2UoKHMsIG8sIGEpID0+IHQuaXMwKG8pID8gcyA6IChyW2FdID0gcywgdC5tdWwocywgbykpLCB0Lk9ORSksIGkgPSB0LmludihuKTtcbiAgcmV0dXJuIGUucmVkdWNlUmlnaHQoKHMsIG8sIGEpID0+IHQuaXMwKG8pID8gcyA6IChyW2FdID0gdC5tdWwocywgclthXSksIHQubXVsKHMsIG8pKSwgaSksIHI7XG59XG5mdW5jdGlvbiBXbih0LCBlKSB7XG4gIGNvbnN0IHIgPSBlICE9PSB2b2lkIDAgPyBlIDogdC50b1N0cmluZygyKS5sZW5ndGgsIG4gPSBNYXRoLmNlaWwociAvIDgpO1xuICByZXR1cm4geyBuQml0TGVuZ3RoOiByLCBuQnl0ZUxlbmd0aDogbiB9O1xufVxuZnVuY3Rpb24gRmModCwgZSwgciA9ICExLCBuID0ge30pIHtcbiAgaWYgKHQgPD0gUSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIEZwIE9SREVSID4gMCwgZ290ICR7dH1gKTtcbiAgY29uc3QgeyBuQml0TGVuZ3RoOiBpLCBuQnl0ZUxlbmd0aDogcyB9ID0gV24odCwgZSk7XG4gIGlmIChzID4gMjA0OClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaWVsZCBsZW5ndGhzIG92ZXIgMjA0OCBieXRlcyBhcmUgbm90IHN1cHBvcnRlZFwiKTtcbiAgY29uc3QgbyA9IEhjKHQpLCBhID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgT1JERVI6IHQsXG4gICAgQklUUzogaSxcbiAgICBCWVRFUzogcyxcbiAgICBNQVNLOiBLbihpKSxcbiAgICBaRVJPOiBRLFxuICAgIE9ORTogVixcbiAgICBjcmVhdGU6IChjKSA9PiBKKGMsIHQpLFxuICAgIGlzVmFsaWQ6IChjKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGMgIT0gXCJiaWdpbnRcIilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGZpZWxkIGVsZW1lbnQ6IGV4cGVjdGVkIGJpZ2ludCwgZ290ICR7dHlwZW9mIGN9YCk7XG4gICAgICByZXR1cm4gUSA8PSBjICYmIGMgPCB0O1xuICAgIH0sXG4gICAgaXMwOiAoYykgPT4gYyA9PT0gUSxcbiAgICBpc09kZDogKGMpID0+IChjICYgVikgPT09IFYsXG4gICAgbmVnOiAoYykgPT4gSigtYywgdCksXG4gICAgZXFsOiAoYywgbCkgPT4gYyA9PT0gbCxcbiAgICBzcXI6IChjKSA9PiBKKGMgKiBjLCB0KSxcbiAgICBhZGQ6IChjLCBsKSA9PiBKKGMgKyBsLCB0KSxcbiAgICBzdWI6IChjLCBsKSA9PiBKKGMgLSBsLCB0KSxcbiAgICBtdWw6IChjLCBsKSA9PiBKKGMgKiBsLCB0KSxcbiAgICBwb3c6IChjLCBsKSA9PiBEYyhhLCBjLCBsKSxcbiAgICBkaXY6IChjLCBsKSA9PiBKKGMgKiBJbihsLCB0KSwgdCksXG4gICAgc3FyTjogKGMpID0+IGMgKiBjLFxuICAgIGFkZE46IChjLCBsKSA9PiBjICsgbCxcbiAgICBzdWJOOiAoYywgbCkgPT4gYyAtIGwsXG4gICAgbXVsTjogKGMsIGwpID0+IGMgKiBsLFxuICAgIGludjogKGMpID0+IEluKGMsIHQpLFxuICAgIHNxcnQ6IG4uc3FydCB8fCAoKGMpID0+IG8oYSwgYykpLFxuICAgIGludmVydEJhdGNoOiAoYykgPT4gemMoYSwgYyksXG4gICAgY21vdjogKGMsIGwsIGYpID0+IGYgPyBsIDogYyxcbiAgICB0b0J5dGVzOiAoYykgPT4gciA/IG5zKGMsIHMpIDogZXQoYywgcyksXG4gICAgZnJvbUJ5dGVzOiAoYykgPT4ge1xuICAgICAgaWYgKGMubGVuZ3RoICE9PSBzKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZwLmZyb21CeXRlczogZXhwZWN0ZWQgJHtzfSwgZ290ICR7Yy5sZW5ndGh9YCk7XG4gICAgICByZXR1cm4gciA/IEZuKGMpIDogbGUoYyk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoYSk7XG59XG5mdW5jdGlvbiBLYyh0LCBlLCByID0gITEpIHtcbiAgdCA9IGVlKFwicHJpdmF0ZUhhc2hcIiwgdCk7XG4gIGNvbnN0IG4gPSB0Lmxlbmd0aCwgaSA9IFduKGUpLm5CeXRlTGVuZ3RoICsgODtcbiAgaWYgKGkgPCAyNCB8fCBuIDwgaSB8fCBuID4gMTAyNClcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGhhc2hUb1ByaXZhdGVTY2FsYXI6IGV4cGVjdGVkICR7aX0tMTAyNCBieXRlcyBvZiBpbnB1dCwgZ290ICR7bn1gKTtcbiAgY29uc3QgcyA9IHIgPyBGbih0KSA6IGxlKHQpO1xuICByZXR1cm4gSihzLCBlIC0gVikgKyBWO1xufVxuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuY29uc3QgV2MgPSBCaWdJbnQoMCksIG9uID0gQmlnSW50KDEpO1xuZnVuY3Rpb24gVmModCwgZSkge1xuICBjb25zdCByID0gKGksIHMpID0+IHtcbiAgICBjb25zdCBvID0gcy5uZWdhdGUoKTtcbiAgICByZXR1cm4gaSA/IG8gOiBzO1xuICB9LCBuID0gKGkpID0+IHtcbiAgICBjb25zdCBzID0gTWF0aC5jZWlsKGUgLyBpKSArIDEsIG8gPSAyICoqIChpIC0gMSk7XG4gICAgcmV0dXJuIHsgd2luZG93czogcywgd2luZG93U2l6ZTogbyB9O1xuICB9O1xuICByZXR1cm4ge1xuICAgIGNvbnN0VGltZU5lZ2F0ZTogcixcbiAgICB1bnNhZmVMYWRkZXIoaSwgcykge1xuICAgICAgbGV0IG8gPSB0LlpFUk8sIGEgPSBpO1xuICAgICAgZm9yICg7IHMgPiBXYzsgKVxuICAgICAgICBzICYgb24gJiYgKG8gPSBvLmFkZChhKSksIGEgPSBhLmRvdWJsZSgpLCBzID4+PSBvbjtcbiAgICAgIHJldHVybiBvO1xuICAgIH0sXG4gICAgcHJlY29tcHV0ZVdpbmRvdyhpLCBzKSB7XG4gICAgICBjb25zdCB7IHdpbmRvd3M6IG8sIHdpbmRvd1NpemU6IGEgfSA9IG4ocyksIGMgPSBbXTtcbiAgICAgIGxldCBsID0gaSwgZiA9IGw7XG4gICAgICBmb3IgKGxldCB1ID0gMDsgdSA8IG87IHUrKykge1xuICAgICAgICBmID0gbCwgYy5wdXNoKGYpO1xuICAgICAgICBmb3IgKGxldCBoID0gMTsgaCA8IGE7IGgrKylcbiAgICAgICAgICBmID0gZi5hZGQobCksIGMucHVzaChmKTtcbiAgICAgICAgbCA9IGYuZG91YmxlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYztcbiAgICB9LFxuICAgIHdOQUYoaSwgcywgbykge1xuICAgICAgY29uc3QgeyB3aW5kb3dzOiBhLCB3aW5kb3dTaXplOiBjIH0gPSBuKGkpO1xuICAgICAgbGV0IGwgPSB0LlpFUk8sIGYgPSB0LkJBU0U7XG4gICAgICBjb25zdCB1ID0gQmlnSW50KDIgKiogaSAtIDEpLCBoID0gMiAqKiBpLCBkID0gQmlnSW50KGkpO1xuICAgICAgZm9yIChsZXQgcCA9IDA7IHAgPCBhOyBwKyspIHtcbiAgICAgICAgY29uc3QgeSA9IHAgKiBjO1xuICAgICAgICBsZXQgZyA9IE51bWJlcihvICYgdSk7XG4gICAgICAgIG8gPj49IGQsIGcgPiBjICYmIChnIC09IGgsIG8gKz0gb24pO1xuICAgICAgICBjb25zdCB2ID0geSwgXyA9IHkgKyBNYXRoLmFicyhnKSAtIDEsIG0gPSBwICUgMiAhPT0gMCwgQyA9IGcgPCAwO1xuICAgICAgICBnID09PSAwID8gZiA9IGYuYWRkKHIobSwgc1t2XSkpIDogbCA9IGwuYWRkKHIoQywgc1tfXSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgcDogbCwgZiB9O1xuICAgIH0sXG4gICAgd05BRkNhY2hlZChpLCBzLCBvLCBhKSB7XG4gICAgICBjb25zdCBjID0gaS5fV0lORE9XX1NJWkUgfHwgMTtcbiAgICAgIGxldCBsID0gcy5nZXQoaSk7XG4gICAgICByZXR1cm4gbCB8fCAobCA9IHRoaXMucHJlY29tcHV0ZVdpbmRvdyhpLCBjKSwgYyAhPT0gMSAmJiBzLnNldChpLCBhKGwpKSksIHRoaXMud05BRihjLCBsLCBvKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBzcyh0KSB7XG4gIHJldHVybiBvcyh0LkZwKSwga3QodCwge1xuICAgIG46IFwiYmlnaW50XCIsXG4gICAgaDogXCJiaWdpbnRcIixcbiAgICBHeDogXCJmaWVsZFwiLFxuICAgIEd5OiBcImZpZWxkXCJcbiAgfSwge1xuICAgIG5CaXRMZW5ndGg6IFwiaXNTYWZlSW50ZWdlclwiLFxuICAgIG5CeXRlTGVuZ3RoOiBcImlzU2FmZUludGVnZXJcIlxuICB9KSwgT2JqZWN0LmZyZWV6ZSh7XG4gICAgLi4uV24odC5uLCB0Lm5CaXRMZW5ndGgpLFxuICAgIC4uLnQsXG4gICAgcDogdC5GcC5PUkRFUlxuICB9KTtcbn1cbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmZ1bmN0aW9uIEdjKHQpIHtcbiAgY29uc3QgZSA9IHNzKHQpO1xuICBrdChlLCB7XG4gICAgYTogXCJmaWVsZFwiLFxuICAgIGI6IFwiZmllbGRcIlxuICB9LCB7XG4gICAgYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzOiBcImFycmF5XCIsXG4gICAgd3JhcFByaXZhdGVLZXk6IFwiYm9vbGVhblwiLFxuICAgIGlzVG9yc2lvbkZyZWU6IFwiZnVuY3Rpb25cIixcbiAgICBjbGVhckNvZmFjdG9yOiBcImZ1bmN0aW9uXCIsXG4gICAgYWxsb3dJbmZpbml0eVBvaW50OiBcImJvb2xlYW5cIixcbiAgICBmcm9tQnl0ZXM6IFwiZnVuY3Rpb25cIixcbiAgICB0b0J5dGVzOiBcImZ1bmN0aW9uXCJcbiAgfSk7XG4gIGNvbnN0IHsgZW5kbzogciwgRnA6IG4sIGE6IGkgfSA9IGU7XG4gIGlmIChyKSB7XG4gICAgaWYgKCFuLmVxbChpLCBuLlpFUk8pKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRW5kb21vcnBoaXNtIGNhbiBvbmx5IGJlIGRlZmluZWQgZm9yIEtvYmxpdHogY3VydmVzIHRoYXQgaGF2ZSBhPTBcIik7XG4gICAgaWYgKHR5cGVvZiByICE9IFwib2JqZWN0XCIgfHwgdHlwZW9mIHIuYmV0YSAhPSBcImJpZ2ludFwiIHx8IHR5cGVvZiByLnNwbGl0U2NhbGFyICE9IFwiZnVuY3Rpb25cIilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIGVuZG9tb3JwaGlzbSB3aXRoIGJldGE6IGJpZ2ludCBhbmQgc3BsaXRTY2FsYXI6IGZ1bmN0aW9uXCIpO1xuICB9XG4gIHJldHVybiBPYmplY3QuZnJlZXplKHsgLi4uZSB9KTtcbn1cbmNvbnN0IHsgYnl0ZXNUb051bWJlckJFOiBaYywgaGV4VG9CeXRlczogWWMgfSA9IHFjLCBsdCA9IHtcbiAgRXJyOiBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihlID0gXCJcIikge1xuICAgICAgc3VwZXIoZSk7XG4gICAgfVxuICB9LFxuICBfcGFyc2VJbnQodCkge1xuICAgIGNvbnN0IHsgRXJyOiBlIH0gPSBsdDtcbiAgICBpZiAodC5sZW5ndGggPCAyIHx8IHRbMF0gIT09IDIpXG4gICAgICB0aHJvdyBuZXcgZShcIkludmFsaWQgc2lnbmF0dXJlIGludGVnZXIgdGFnXCIpO1xuICAgIGNvbnN0IHIgPSB0WzFdLCBuID0gdC5zdWJhcnJheSgyLCByICsgMik7XG4gICAgaWYgKCFyIHx8IG4ubGVuZ3RoICE9PSByKVxuICAgICAgdGhyb3cgbmV3IGUoXCJJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiB3cm9uZyBsZW5ndGhcIik7XG4gICAgaWYgKG5bMF0gJiAxMjgpXG4gICAgICB0aHJvdyBuZXcgZShcIkludmFsaWQgc2lnbmF0dXJlIGludGVnZXI6IG5lZ2F0aXZlXCIpO1xuICAgIGlmIChuWzBdID09PSAwICYmICEoblsxXSAmIDEyOCkpXG4gICAgICB0aHJvdyBuZXcgZShcIkludmFsaWQgc2lnbmF0dXJlIGludGVnZXI6IHVubmVjZXNzYXJ5IGxlYWRpbmcgemVyb1wiKTtcbiAgICByZXR1cm4geyBkOiBaYyhuKSwgbDogdC5zdWJhcnJheShyICsgMikgfTtcbiAgfSxcbiAgdG9TaWcodCkge1xuICAgIGNvbnN0IHsgRXJyOiBlIH0gPSBsdCwgciA9IHR5cGVvZiB0ID09IFwic3RyaW5nXCIgPyBZYyh0KSA6IHQ7XG4gICAgaWYgKCEociBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidWk4YSBleHBlY3RlZFwiKTtcbiAgICBsZXQgbiA9IHIubGVuZ3RoO1xuICAgIGlmIChuIDwgMiB8fCByWzBdICE9IDQ4KVxuICAgICAgdGhyb3cgbmV3IGUoXCJJbnZhbGlkIHNpZ25hdHVyZSB0YWdcIik7XG4gICAgaWYgKHJbMV0gIT09IG4gLSAyKVxuICAgICAgdGhyb3cgbmV3IGUoXCJJbnZhbGlkIHNpZ25hdHVyZTogaW5jb3JyZWN0IGxlbmd0aFwiKTtcbiAgICBjb25zdCB7IGQ6IGksIGw6IHMgfSA9IGx0Ll9wYXJzZUludChyLnN1YmFycmF5KDIpKSwgeyBkOiBvLCBsOiBhIH0gPSBsdC5fcGFyc2VJbnQocyk7XG4gICAgaWYgKGEubGVuZ3RoKVxuICAgICAgdGhyb3cgbmV3IGUoXCJJbnZhbGlkIHNpZ25hdHVyZTogbGVmdCBieXRlcyBhZnRlciBwYXJzaW5nXCIpO1xuICAgIHJldHVybiB7IHI6IGksIHM6IG8gfTtcbiAgfSxcbiAgaGV4RnJvbVNpZyh0KSB7XG4gICAgY29uc3QgZSA9IChsKSA9PiBOdW1iZXIucGFyc2VJbnQobFswXSwgMTYpICYgOCA/IFwiMDBcIiArIGwgOiBsLCByID0gKGwpID0+IHtcbiAgICAgIGNvbnN0IGYgPSBsLnRvU3RyaW5nKDE2KTtcbiAgICAgIHJldHVybiBmLmxlbmd0aCAmIDEgPyBgMCR7Zn1gIDogZjtcbiAgICB9LCBuID0gZShyKHQucykpLCBpID0gZShyKHQucikpLCBzID0gbi5sZW5ndGggLyAyLCBvID0gaS5sZW5ndGggLyAyLCBhID0gcihzKSwgYyA9IHIobyk7XG4gICAgcmV0dXJuIGAzMCR7cihvICsgcyArIDQpfTAyJHtjfSR7aX0wMiR7YX0ke259YDtcbiAgfVxufSwga2UgPSBCaWdJbnQoMCksIFkgPSBCaWdJbnQoMSksICRlID0gQmlnSW50KDIpLCBBciA9IEJpZ0ludCgzKSwgSGkgPSBCaWdJbnQoNCk7XG5mdW5jdGlvbiBKYyh0KSB7XG4gIGNvbnN0IGUgPSBHYyh0KSwgeyBGcDogciB9ID0gZSwgbiA9IGUudG9CeXRlcyB8fCAoKHAsIHksIGcpID0+IHtcbiAgICBjb25zdCB2ID0geS50b0FmZmluZSgpO1xuICAgIHJldHVybiBoZShVaW50OEFycmF5LmZyb20oWzRdKSwgci50b0J5dGVzKHYueCksIHIudG9CeXRlcyh2LnkpKTtcbiAgfSksIGkgPSBlLmZyb21CeXRlcyB8fCAoKHApID0+IHtcbiAgICBjb25zdCB5ID0gcC5zdWJhcnJheSgxKSwgZyA9IHIuZnJvbUJ5dGVzKHkuc3ViYXJyYXkoMCwgci5CWVRFUykpLCB2ID0gci5mcm9tQnl0ZXMoeS5zdWJhcnJheShyLkJZVEVTLCAyICogci5CWVRFUykpO1xuICAgIHJldHVybiB7IHg6IGcsIHk6IHYgfTtcbiAgfSk7XG4gIGZ1bmN0aW9uIHMocCkge1xuICAgIGNvbnN0IHsgYTogeSwgYjogZyB9ID0gZSwgdiA9IHIuc3FyKHApLCBfID0gci5tdWwodiwgcCk7XG4gICAgcmV0dXJuIHIuYWRkKHIuYWRkKF8sIHIubXVsKHAsIHkpKSwgZyk7XG4gIH1cbiAgaWYgKCFyLmVxbChyLnNxcihlLkd5KSwgcyhlLkd4KSkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYmFkIGdlbmVyYXRvciBwb2ludDogZXF1YXRpb24gbGVmdCAhPSByaWdodFwiKTtcbiAgZnVuY3Rpb24gbyhwKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBwID09IFwiYmlnaW50XCIgJiYga2UgPCBwICYmIHAgPCBlLm47XG4gIH1cbiAgZnVuY3Rpb24gYShwKSB7XG4gICAgaWYgKCFvKHApKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgdmFsaWQgYmlnaW50OiAwIDwgYmlnaW50IDwgY3VydmUublwiKTtcbiAgfVxuICBmdW5jdGlvbiBjKHApIHtcbiAgICBjb25zdCB7IGFsbG93ZWRQcml2YXRlS2V5TGVuZ3RoczogeSwgbkJ5dGVMZW5ndGg6IGcsIHdyYXBQcml2YXRlS2V5OiB2LCBuOiBfIH0gPSBlO1xuICAgIGlmICh5ICYmIHR5cGVvZiBwICE9IFwiYmlnaW50XCIpIHtcbiAgICAgIGlmIChwIGluc3RhbmNlb2YgVWludDhBcnJheSAmJiAocCA9IHZ0KHApKSwgdHlwZW9mIHAgIT0gXCJzdHJpbmdcIiB8fCAheS5pbmNsdWRlcyhwLmxlbmd0aCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQga2V5XCIpO1xuICAgICAgcCA9IHAucGFkU3RhcnQoZyAqIDIsIFwiMFwiKTtcbiAgICB9XG4gICAgbGV0IG07XG4gICAgdHJ5IHtcbiAgICAgIG0gPSB0eXBlb2YgcCA9PSBcImJpZ2ludFwiID8gcCA6IGxlKGVlKFwicHJpdmF0ZSBrZXlcIiwgcCwgZykpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBwcml2YXRlIGtleSBtdXN0IGJlICR7Z30gYnl0ZXMsIGhleCBvciBiaWdpbnQsIG5vdCAke3R5cGVvZiBwfWApO1xuICAgIH1cbiAgICByZXR1cm4gdiAmJiAobSA9IEoobSwgXykpLCBhKG0pLCBtO1xuICB9XG4gIGNvbnN0IGwgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBmdW5jdGlvbiBmKHApIHtcbiAgICBpZiAoIShwIGluc3RhbmNlb2YgdSkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm9qZWN0aXZlUG9pbnQgZXhwZWN0ZWRcIik7XG4gIH1cbiAgY2xhc3MgdSB7XG4gICAgY29uc3RydWN0b3IoeSwgZywgdikge1xuICAgICAgaWYgKHRoaXMucHggPSB5LCB0aGlzLnB5ID0gZywgdGhpcy5weiA9IHYsIHkgPT0gbnVsbCB8fCAhci5pc1ZhbGlkKHkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ4IHJlcXVpcmVkXCIpO1xuICAgICAgaWYgKGcgPT0gbnVsbCB8fCAhci5pc1ZhbGlkKGcpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ5IHJlcXVpcmVkXCIpO1xuICAgICAgaWYgKHYgPT0gbnVsbCB8fCAhci5pc1ZhbGlkKHYpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ6IHJlcXVpcmVkXCIpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUFmZmluZSh5KSB7XG4gICAgICBjb25zdCB7IHg6IGcsIHk6IHYgfSA9IHkgfHwge307XG4gICAgICBpZiAoIXkgfHwgIXIuaXNWYWxpZChnKSB8fCAhci5pc1ZhbGlkKHYpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGFmZmluZSBwb2ludFwiKTtcbiAgICAgIGlmICh5IGluc3RhbmNlb2YgdSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicHJvamVjdGl2ZSBwb2ludCBub3QgYWxsb3dlZFwiKTtcbiAgICAgIGNvbnN0IF8gPSAobSkgPT4gci5lcWwobSwgci5aRVJPKTtcbiAgICAgIHJldHVybiBfKGcpICYmIF8odikgPyB1LlpFUk8gOiBuZXcgdShnLCB2LCByLk9ORSk7XG4gICAgfVxuICAgIGdldCB4KCkge1xuICAgICAgcmV0dXJuIHRoaXMudG9BZmZpbmUoKS54O1xuICAgIH1cbiAgICBnZXQgeSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueTtcbiAgICB9XG4gICAgc3RhdGljIG5vcm1hbGl6ZVooeSkge1xuICAgICAgY29uc3QgZyA9IHIuaW52ZXJ0QmF0Y2goeS5tYXAoKHYpID0+IHYucHopKTtcbiAgICAgIHJldHVybiB5Lm1hcCgodiwgXykgPT4gdi50b0FmZmluZShnW19dKSkubWFwKHUuZnJvbUFmZmluZSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSGV4KHkpIHtcbiAgICAgIGNvbnN0IGcgPSB1LmZyb21BZmZpbmUoaShlZShcInBvaW50SGV4XCIsIHkpKSk7XG4gICAgICByZXR1cm4gZy5hc3NlcnRWYWxpZGl0eSgpLCBnO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVByaXZhdGVLZXkoeSkge1xuICAgICAgcmV0dXJuIHUuQkFTRS5tdWx0aXBseShjKHkpKTtcbiAgICB9XG4gICAgX3NldFdpbmRvd1NpemUoeSkge1xuICAgICAgdGhpcy5fV0lORE9XX1NJWkUgPSB5LCBsLmRlbGV0ZSh0aGlzKTtcbiAgICB9XG4gICAgYXNzZXJ0VmFsaWRpdHkoKSB7XG4gICAgICBpZiAodGhpcy5pczAoKSkge1xuICAgICAgICBpZiAoZS5hbGxvd0luZmluaXR5UG9pbnQpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgcG9pbnQ6IFpFUk9cIik7XG4gICAgICB9XG4gICAgICBjb25zdCB7IHg6IHksIHk6IGcgfSA9IHRoaXMudG9BZmZpbmUoKTtcbiAgICAgIGlmICghci5pc1ZhbGlkKHkpIHx8ICFyLmlzVmFsaWQoZykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImJhZCBwb2ludDogeCBvciB5IG5vdCBGRVwiKTtcbiAgICAgIGNvbnN0IHYgPSByLnNxcihnKSwgXyA9IHMoeSk7XG4gICAgICBpZiAoIXIuZXFsKHYsIF8pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgcG9pbnQ6IGVxdWF0aW9uIGxlZnQgIT0gcmlnaHRcIik7XG4gICAgICBpZiAoIXRoaXMuaXNUb3JzaW9uRnJlZSgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgcG9pbnQ6IG5vdCBpbiBwcmltZS1vcmRlciBzdWJncm91cFwiKTtcbiAgICB9XG4gICAgaGFzRXZlblkoKSB7XG4gICAgICBjb25zdCB7IHkgfSA9IHRoaXMudG9BZmZpbmUoKTtcbiAgICAgIGlmIChyLmlzT2RkKVxuICAgICAgICByZXR1cm4gIXIuaXNPZGQoeSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaWVsZCBkb2Vzbid0IHN1cHBvcnQgaXNPZGRcIik7XG4gICAgfVxuICAgIGVxdWFscyh5KSB7XG4gICAgICBmKHkpO1xuICAgICAgY29uc3QgeyBweDogZywgcHk6IHYsIHB6OiBfIH0gPSB0aGlzLCB7IHB4OiBtLCBweTogQywgcHo6IE8gfSA9IHksIHcgPSByLmVxbChyLm11bChnLCBPKSwgci5tdWwobSwgXykpLCB4ID0gci5lcWwoci5tdWwodiwgTyksIHIubXVsKEMsIF8pKTtcbiAgICAgIHJldHVybiB3ICYmIHg7XG4gICAgfVxuICAgIG5lZ2F0ZSgpIHtcbiAgICAgIHJldHVybiBuZXcgdSh0aGlzLnB4LCByLm5lZyh0aGlzLnB5KSwgdGhpcy5weik7XG4gICAgfVxuICAgIGRvdWJsZSgpIHtcbiAgICAgIGNvbnN0IHsgYTogeSwgYjogZyB9ID0gZSwgdiA9IHIubXVsKGcsIEFyKSwgeyBweDogXywgcHk6IG0sIHB6OiBDIH0gPSB0aGlzO1xuICAgICAgbGV0IE8gPSByLlpFUk8sIHcgPSByLlpFUk8sIHggPSByLlpFUk8sIEEgPSByLm11bChfLCBfKSwgQiA9IHIubXVsKG0sIG0pLCBMID0gci5tdWwoQywgQyksIFAgPSByLm11bChfLCBtKTtcbiAgICAgIHJldHVybiBQID0gci5hZGQoUCwgUCksIHggPSByLm11bChfLCBDKSwgeCA9IHIuYWRkKHgsIHgpLCBPID0gci5tdWwoeSwgeCksIHcgPSByLm11bCh2LCBMKSwgdyA9IHIuYWRkKE8sIHcpLCBPID0gci5zdWIoQiwgdyksIHcgPSByLmFkZChCLCB3KSwgdyA9IHIubXVsKE8sIHcpLCBPID0gci5tdWwoUCwgTyksIHggPSByLm11bCh2LCB4KSwgTCA9IHIubXVsKHksIEwpLCBQID0gci5zdWIoQSwgTCksIFAgPSByLm11bCh5LCBQKSwgUCA9IHIuYWRkKFAsIHgpLCB4ID0gci5hZGQoQSwgQSksIEEgPSByLmFkZCh4LCBBKSwgQSA9IHIuYWRkKEEsIEwpLCBBID0gci5tdWwoQSwgUCksIHcgPSByLmFkZCh3LCBBKSwgTCA9IHIubXVsKG0sIEMpLCBMID0gci5hZGQoTCwgTCksIEEgPSByLm11bChMLCBQKSwgTyA9IHIuc3ViKE8sIEEpLCB4ID0gci5tdWwoTCwgQiksIHggPSByLmFkZCh4LCB4KSwgeCA9IHIuYWRkKHgsIHgpLCBuZXcgdShPLCB3LCB4KTtcbiAgICB9XG4gICAgYWRkKHkpIHtcbiAgICAgIGYoeSk7XG4gICAgICBjb25zdCB7IHB4OiBnLCBweTogdiwgcHo6IF8gfSA9IHRoaXMsIHsgcHg6IG0sIHB5OiBDLCBwejogTyB9ID0geTtcbiAgICAgIGxldCB3ID0gci5aRVJPLCB4ID0gci5aRVJPLCBBID0gci5aRVJPO1xuICAgICAgY29uc3QgQiA9IGUuYSwgTCA9IHIubXVsKGUuYiwgQXIpO1xuICAgICAgbGV0IFAgPSByLm11bChnLCBtKSwgRiA9IHIubXVsKHYsIEMpLCB6ID0gci5tdWwoXywgTyksIEcgPSByLmFkZChnLCB2KSwgRSA9IHIuYWRkKG0sIEMpO1xuICAgICAgRyA9IHIubXVsKEcsIEUpLCBFID0gci5hZGQoUCwgRiksIEcgPSByLnN1YihHLCBFKSwgRSA9IHIuYWRkKGcsIF8pO1xuICAgICAgbGV0IFIgPSByLmFkZChtLCBPKTtcbiAgICAgIHJldHVybiBFID0gci5tdWwoRSwgUiksIFIgPSByLmFkZChQLCB6KSwgRSA9IHIuc3ViKEUsIFIpLCBSID0gci5hZGQodiwgXyksIHcgPSByLmFkZChDLCBPKSwgUiA9IHIubXVsKFIsIHcpLCB3ID0gci5hZGQoRiwgeiksIFIgPSByLnN1YihSLCB3KSwgQSA9IHIubXVsKEIsIEUpLCB3ID0gci5tdWwoTCwgeiksIEEgPSByLmFkZCh3LCBBKSwgdyA9IHIuc3ViKEYsIEEpLCBBID0gci5hZGQoRiwgQSksIHggPSByLm11bCh3LCBBKSwgRiA9IHIuYWRkKFAsIFApLCBGID0gci5hZGQoRiwgUCksIHogPSByLm11bChCLCB6KSwgRSA9IHIubXVsKEwsIEUpLCBGID0gci5hZGQoRiwgeiksIHogPSByLnN1YihQLCB6KSwgeiA9IHIubXVsKEIsIHopLCBFID0gci5hZGQoRSwgeiksIFAgPSByLm11bChGLCBFKSwgeCA9IHIuYWRkKHgsIFApLCBQID0gci5tdWwoUiwgRSksIHcgPSByLm11bChHLCB3KSwgdyA9IHIuc3ViKHcsIFApLCBQID0gci5tdWwoRywgRiksIEEgPSByLm11bChSLCBBKSwgQSA9IHIuYWRkKEEsIFApLCBuZXcgdSh3LCB4LCBBKTtcbiAgICB9XG4gICAgc3VidHJhY3QoeSkge1xuICAgICAgcmV0dXJuIHRoaXMuYWRkKHkubmVnYXRlKCkpO1xuICAgIH1cbiAgICBpczAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5lcXVhbHModS5aRVJPKTtcbiAgICB9XG4gICAgd05BRih5KSB7XG4gICAgICByZXR1cm4gZC53TkFGQ2FjaGVkKHRoaXMsIGwsIHksIChnKSA9PiB7XG4gICAgICAgIGNvbnN0IHYgPSByLmludmVydEJhdGNoKGcubWFwKChfKSA9PiBfLnB6KSk7XG4gICAgICAgIHJldHVybiBnLm1hcCgoXywgbSkgPT4gXy50b0FmZmluZSh2W21dKSkubWFwKHUuZnJvbUFmZmluZSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgbXVsdGlwbHlVbnNhZmUoeSkge1xuICAgICAgY29uc3QgZyA9IHUuWkVSTztcbiAgICAgIGlmICh5ID09PSBrZSlcbiAgICAgICAgcmV0dXJuIGc7XG4gICAgICBpZiAoYSh5KSwgeSA9PT0gWSlcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICBjb25zdCB7IGVuZG86IHYgfSA9IGU7XG4gICAgICBpZiAoIXYpXG4gICAgICAgIHJldHVybiBkLnVuc2FmZUxhZGRlcih0aGlzLCB5KTtcbiAgICAgIGxldCB7IGsxbmVnOiBfLCBrMTogbSwgazJuZWc6IEMsIGsyOiBPIH0gPSB2LnNwbGl0U2NhbGFyKHkpLCB3ID0gZywgeCA9IGcsIEEgPSB0aGlzO1xuICAgICAgZm9yICg7IG0gPiBrZSB8fCBPID4ga2U7IClcbiAgICAgICAgbSAmIFkgJiYgKHcgPSB3LmFkZChBKSksIE8gJiBZICYmICh4ID0geC5hZGQoQSkpLCBBID0gQS5kb3VibGUoKSwgbSA+Pj0gWSwgTyA+Pj0gWTtcbiAgICAgIHJldHVybiBfICYmICh3ID0gdy5uZWdhdGUoKSksIEMgJiYgKHggPSB4Lm5lZ2F0ZSgpKSwgeCA9IG5ldyB1KHIubXVsKHgucHgsIHYuYmV0YSksIHgucHksIHgucHopLCB3LmFkZCh4KTtcbiAgICB9XG4gICAgbXVsdGlwbHkoeSkge1xuICAgICAgYSh5KTtcbiAgICAgIGxldCBnID0geSwgdiwgXztcbiAgICAgIGNvbnN0IHsgZW5kbzogbSB9ID0gZTtcbiAgICAgIGlmIChtKSB7XG4gICAgICAgIGNvbnN0IHsgazFuZWc6IEMsIGsxOiBPLCBrMm5lZzogdywgazI6IHggfSA9IG0uc3BsaXRTY2FsYXIoZyk7XG4gICAgICAgIGxldCB7IHA6IEEsIGY6IEIgfSA9IHRoaXMud05BRihPKSwgeyBwOiBMLCBmOiBQIH0gPSB0aGlzLndOQUYoeCk7XG4gICAgICAgIEEgPSBkLmNvbnN0VGltZU5lZ2F0ZShDLCBBKSwgTCA9IGQuY29uc3RUaW1lTmVnYXRlKHcsIEwpLCBMID0gbmV3IHUoci5tdWwoTC5weCwgbS5iZXRhKSwgTC5weSwgTC5weiksIHYgPSBBLmFkZChMKSwgXyA9IEIuYWRkKFApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgeyBwOiBDLCBmOiBPIH0gPSB0aGlzLndOQUYoZyk7XG4gICAgICAgIHYgPSBDLCBfID0gTztcbiAgICAgIH1cbiAgICAgIHJldHVybiB1Lm5vcm1hbGl6ZVooW3YsIF9dKVswXTtcbiAgICB9XG4gICAgbXVsdGlwbHlBbmRBZGRVbnNhZmUoeSwgZywgdikge1xuICAgICAgY29uc3QgXyA9IHUuQkFTRSwgbSA9IChPLCB3KSA9PiB3ID09PSBrZSB8fCB3ID09PSBZIHx8ICFPLmVxdWFscyhfKSA/IE8ubXVsdGlwbHlVbnNhZmUodykgOiBPLm11bHRpcGx5KHcpLCBDID0gbSh0aGlzLCBnKS5hZGQobSh5LCB2KSk7XG4gICAgICByZXR1cm4gQy5pczAoKSA/IHZvaWQgMCA6IEM7XG4gICAgfVxuICAgIHRvQWZmaW5lKHkpIHtcbiAgICAgIGNvbnN0IHsgcHg6IGcsIHB5OiB2LCBwejogXyB9ID0gdGhpcywgbSA9IHRoaXMuaXMwKCk7XG4gICAgICB5ID09IG51bGwgJiYgKHkgPSBtID8gci5PTkUgOiByLmludihfKSk7XG4gICAgICBjb25zdCBDID0gci5tdWwoZywgeSksIE8gPSByLm11bCh2LCB5KSwgdyA9IHIubXVsKF8sIHkpO1xuICAgICAgaWYgKG0pXG4gICAgICAgIHJldHVybiB7IHg6IHIuWkVSTywgeTogci5aRVJPIH07XG4gICAgICBpZiAoIXIuZXFsKHcsIHIuT05FKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52WiB3YXMgaW52YWxpZFwiKTtcbiAgICAgIHJldHVybiB7IHg6IEMsIHk6IE8gfTtcbiAgICB9XG4gICAgaXNUb3JzaW9uRnJlZSgpIHtcbiAgICAgIGNvbnN0IHsgaDogeSwgaXNUb3JzaW9uRnJlZTogZyB9ID0gZTtcbiAgICAgIGlmICh5ID09PSBZKVxuICAgICAgICByZXR1cm4gITA7XG4gICAgICBpZiAoZylcbiAgICAgICAgcmV0dXJuIGcodSwgdGhpcyk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpc1RvcnNpb25GcmVlKCkgaGFzIG5vdCBiZWVuIGRlY2xhcmVkIGZvciB0aGUgZWxsaXB0aWMgY3VydmVcIik7XG4gICAgfVxuICAgIGNsZWFyQ29mYWN0b3IoKSB7XG4gICAgICBjb25zdCB7IGg6IHksIGNsZWFyQ29mYWN0b3I6IGcgfSA9IGU7XG4gICAgICByZXR1cm4geSA9PT0gWSA/IHRoaXMgOiBnID8gZyh1LCB0aGlzKSA6IHRoaXMubXVsdGlwbHlVbnNhZmUoZS5oKTtcbiAgICB9XG4gICAgdG9SYXdCeXRlcyh5ID0gITApIHtcbiAgICAgIHJldHVybiB0aGlzLmFzc2VydFZhbGlkaXR5KCksIG4odSwgdGhpcywgeSk7XG4gICAgfVxuICAgIHRvSGV4KHkgPSAhMCkge1xuICAgICAgcmV0dXJuIHZ0KHRoaXMudG9SYXdCeXRlcyh5KSk7XG4gICAgfVxuICB9XG4gIHUuQkFTRSA9IG5ldyB1KGUuR3gsIGUuR3ksIHIuT05FKSwgdS5aRVJPID0gbmV3IHUoci5aRVJPLCByLk9ORSwgci5aRVJPKTtcbiAgY29uc3QgaCA9IGUubkJpdExlbmd0aCwgZCA9IFZjKHUsIGUuZW5kbyA/IE1hdGguY2VpbChoIC8gMikgOiBoKTtcbiAgcmV0dXJuIHtcbiAgICBDVVJWRTogZSxcbiAgICBQcm9qZWN0aXZlUG9pbnQ6IHUsXG4gICAgbm9ybVByaXZhdGVLZXlUb1NjYWxhcjogYyxcbiAgICB3ZWllcnN0cmFzc0VxdWF0aW9uOiBzLFxuICAgIGlzV2l0aGluQ3VydmVPcmRlcjogb1xuICB9O1xufVxuZnVuY3Rpb24gWGModCkge1xuICBjb25zdCBlID0gc3ModCk7XG4gIHJldHVybiBrdChlLCB7XG4gICAgaGFzaDogXCJoYXNoXCIsXG4gICAgaG1hYzogXCJmdW5jdGlvblwiLFxuICAgIHJhbmRvbUJ5dGVzOiBcImZ1bmN0aW9uXCJcbiAgfSwge1xuICAgIGJpdHMyaW50OiBcImZ1bmN0aW9uXCIsXG4gICAgYml0czJpbnRfbW9kTjogXCJmdW5jdGlvblwiLFxuICAgIGxvd1M6IFwiYm9vbGVhblwiXG4gIH0pLCBPYmplY3QuZnJlZXplKHsgbG93UzogITAsIC4uLmUgfSk7XG59XG5mdW5jdGlvbiBRYyh0KSB7XG4gIGNvbnN0IGUgPSBYYyh0KSwgeyBGcDogciwgbiB9ID0gZSwgaSA9IHIuQllURVMgKyAxLCBzID0gMiAqIHIuQllURVMgKyAxO1xuICBmdW5jdGlvbiBvKEUpIHtcbiAgICByZXR1cm4ga2UgPCBFICYmIEUgPCByLk9SREVSO1xuICB9XG4gIGZ1bmN0aW9uIGEoRSkge1xuICAgIHJldHVybiBKKEUsIG4pO1xuICB9XG4gIGZ1bmN0aW9uIGMoRSkge1xuICAgIHJldHVybiBJbihFLCBuKTtcbiAgfVxuICBjb25zdCB7IFByb2plY3RpdmVQb2ludDogbCwgbm9ybVByaXZhdGVLZXlUb1NjYWxhcjogZiwgd2VpZXJzdHJhc3NFcXVhdGlvbjogdSwgaXNXaXRoaW5DdXJ2ZU9yZGVyOiBoIH0gPSBKYyh7XG4gICAgLi4uZSxcbiAgICB0b0J5dGVzKEUsIFIsIHEpIHtcbiAgICAgIGNvbnN0IEggPSBSLnRvQWZmaW5lKCksIEQgPSByLnRvQnl0ZXMoSC54KSwgWCA9IGhlO1xuICAgICAgcmV0dXJuIHEgPyBYKFVpbnQ4QXJyYXkuZnJvbShbUi5oYXNFdmVuWSgpID8gMiA6IDNdKSwgRCkgOiBYKFVpbnQ4QXJyYXkuZnJvbShbNF0pLCBELCByLnRvQnl0ZXMoSC55KSk7XG4gICAgfSxcbiAgICBmcm9tQnl0ZXMoRSkge1xuICAgICAgY29uc3QgUiA9IEUubGVuZ3RoLCBxID0gRVswXSwgSCA9IEUuc3ViYXJyYXkoMSk7XG4gICAgICBpZiAoUiA9PT0gaSAmJiAocSA9PT0gMiB8fCBxID09PSAzKSkge1xuICAgICAgICBjb25zdCBEID0gbGUoSCk7XG4gICAgICAgIGlmICghbyhEKSlcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQb2ludCBpcyBub3Qgb24gY3VydmVcIik7XG4gICAgICAgIGNvbnN0IFggPSB1KEQpO1xuICAgICAgICBsZXQgb2UgPSByLnNxcnQoWCk7XG4gICAgICAgIGNvbnN0IHJlID0gKG9lICYgWSkgPT09IFk7XG4gICAgICAgIHJldHVybiAocSAmIDEpID09PSAxICE9PSByZSAmJiAob2UgPSByLm5lZyhvZSkpLCB7IHg6IEQsIHk6IG9lIH07XG4gICAgICB9IGVsc2UgaWYgKFIgPT09IHMgJiYgcSA9PT0gNCkge1xuICAgICAgICBjb25zdCBEID0gci5mcm9tQnl0ZXMoSC5zdWJhcnJheSgwLCByLkJZVEVTKSksIFggPSByLmZyb21CeXRlcyhILnN1YmFycmF5KHIuQllURVMsIDIgKiByLkJZVEVTKSk7XG4gICAgICAgIHJldHVybiB7IHg6IEQsIHk6IFggfTtcbiAgICAgIH0gZWxzZVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvaW50IG9mIGxlbmd0aCAke1J9IHdhcyBpbnZhbGlkLiBFeHBlY3RlZCAke2l9IGNvbXByZXNzZWQgYnl0ZXMgb3IgJHtzfSB1bmNvbXByZXNzZWQgYnl0ZXNgKTtcbiAgICB9XG4gIH0pLCBkID0gKEUpID0+IHZ0KGV0KEUsIGUubkJ5dGVMZW5ndGgpKTtcbiAgZnVuY3Rpb24gcChFKSB7XG4gICAgY29uc3QgUiA9IG4gPj4gWTtcbiAgICByZXR1cm4gRSA+IFI7XG4gIH1cbiAgZnVuY3Rpb24geShFKSB7XG4gICAgcmV0dXJuIHAoRSkgPyBhKC1FKSA6IEU7XG4gIH1cbiAgY29uc3QgZyA9IChFLCBSLCBxKSA9PiBsZShFLnNsaWNlKFIsIHEpKTtcbiAgY2xhc3MgdiB7XG4gICAgY29uc3RydWN0b3IoUiwgcSwgSCkge1xuICAgICAgdGhpcy5yID0gUiwgdGhpcy5zID0gcSwgdGhpcy5yZWNvdmVyeSA9IEgsIHRoaXMuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Db21wYWN0KFIpIHtcbiAgICAgIGNvbnN0IHEgPSBlLm5CeXRlTGVuZ3RoO1xuICAgICAgcmV0dXJuIFIgPSBlZShcImNvbXBhY3RTaWduYXR1cmVcIiwgUiwgcSAqIDIpLCBuZXcgdihnKFIsIDAsIHEpLCBnKFIsIHEsIDIgKiBxKSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tREVSKFIpIHtcbiAgICAgIGNvbnN0IHsgcjogcSwgczogSCB9ID0gbHQudG9TaWcoZWUoXCJERVJcIiwgUikpO1xuICAgICAgcmV0dXJuIG5ldyB2KHEsIEgpO1xuICAgIH1cbiAgICBhc3NlcnRWYWxpZGl0eSgpIHtcbiAgICAgIGlmICghaCh0aGlzLnIpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyIG11c3QgYmUgMCA8IHIgPCBDVVJWRS5uXCIpO1xuICAgICAgaWYgKCFoKHRoaXMucykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInMgbXVzdCBiZSAwIDwgcyA8IENVUlZFLm5cIik7XG4gICAgfVxuICAgIGFkZFJlY292ZXJ5Qml0KFIpIHtcbiAgICAgIHJldHVybiBuZXcgdih0aGlzLnIsIHRoaXMucywgUik7XG4gICAgfVxuICAgIHJlY292ZXJQdWJsaWNLZXkoUikge1xuICAgICAgY29uc3QgeyByOiBxLCBzOiBILCByZWNvdmVyeTogRCB9ID0gdGhpcywgWCA9IHgoZWUoXCJtc2dIYXNoXCIsIFIpKTtcbiAgICAgIGlmIChEID09IG51bGwgfHwgIVswLCAxLCAyLCAzXS5pbmNsdWRlcyhEKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicmVjb3ZlcnkgaWQgaW52YWxpZFwiKTtcbiAgICAgIGNvbnN0IG9lID0gRCA9PT0gMiB8fCBEID09PSAzID8gcSArIGUubiA6IHE7XG4gICAgICBpZiAob2UgPj0gci5PUkRFUilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicmVjb3ZlcnkgaWQgMiBvciAzIGludmFsaWRcIik7XG4gICAgICBjb25zdCByZSA9IChEICYgMSkgPT09IDAgPyBcIjAyXCIgOiBcIjAzXCIsIF9lID0gbC5mcm9tSGV4KHJlICsgZChvZSkpLCBPZSA9IGMob2UpLCBVZSA9IGEoLVggKiBPZSksIFBlID0gYShIICogT2UpLCB5ZSA9IGwuQkFTRS5tdWx0aXBseUFuZEFkZFVuc2FmZShfZSwgVWUsIFBlKTtcbiAgICAgIGlmICgheWUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInBvaW50IGF0IGluZmluaWZ5XCIpO1xuICAgICAgcmV0dXJuIHllLmFzc2VydFZhbGlkaXR5KCksIHllO1xuICAgIH1cbiAgICBoYXNIaWdoUygpIHtcbiAgICAgIHJldHVybiBwKHRoaXMucyk7XG4gICAgfVxuICAgIG5vcm1hbGl6ZVMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYXNIaWdoUygpID8gbmV3IHYodGhpcy5yLCBhKC10aGlzLnMpLCB0aGlzLnJlY292ZXJ5KSA6IHRoaXM7XG4gICAgfVxuICAgIHRvREVSUmF3Qnl0ZXMoKSB7XG4gICAgICByZXR1cm4gd3QodGhpcy50b0RFUkhleCgpKTtcbiAgICB9XG4gICAgdG9ERVJIZXgoKSB7XG4gICAgICByZXR1cm4gbHQuaGV4RnJvbVNpZyh7IHI6IHRoaXMuciwgczogdGhpcy5zIH0pO1xuICAgIH1cbiAgICB0b0NvbXBhY3RSYXdCeXRlcygpIHtcbiAgICAgIHJldHVybiB3dCh0aGlzLnRvQ29tcGFjdEhleCgpKTtcbiAgICB9XG4gICAgdG9Db21wYWN0SGV4KCkge1xuICAgICAgcmV0dXJuIGQodGhpcy5yKSArIGQodGhpcy5zKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgXyA9IHtcbiAgICBpc1ZhbGlkUHJpdmF0ZUtleShFKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZihFKSwgITA7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgfVxuICAgIH0sXG4gICAgbm9ybVByaXZhdGVLZXlUb1NjYWxhcjogZixcbiAgICByYW5kb21Qcml2YXRlS2V5OiAoKSA9PiB7XG4gICAgICBjb25zdCBFID0gZS5yYW5kb21CeXRlcyhyLkJZVEVTICsgOCksIFIgPSBLYyhFLCBuKTtcbiAgICAgIHJldHVybiBldChSLCBlLm5CeXRlTGVuZ3RoKTtcbiAgICB9LFxuICAgIHByZWNvbXB1dGUoRSA9IDgsIFIgPSBsLkJBU0UpIHtcbiAgICAgIHJldHVybiBSLl9zZXRXaW5kb3dTaXplKEUpLCBSLm11bHRpcGx5KEJpZ0ludCgzKSksIFI7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBtKEUsIFIgPSAhMCkge1xuICAgIHJldHVybiBsLmZyb21Qcml2YXRlS2V5KEUpLnRvUmF3Qnl0ZXMoUik7XG4gIH1cbiAgZnVuY3Rpb24gQyhFKSB7XG4gICAgY29uc3QgUiA9IEUgaW5zdGFuY2VvZiBVaW50OEFycmF5LCBxID0gdHlwZW9mIEUgPT0gXCJzdHJpbmdcIiwgSCA9IChSIHx8IHEpICYmIEUubGVuZ3RoO1xuICAgIHJldHVybiBSID8gSCA9PT0gaSB8fCBIID09PSBzIDogcSA/IEggPT09IDIgKiBpIHx8IEggPT09IDIgKiBzIDogRSBpbnN0YW5jZW9mIGw7XG4gIH1cbiAgZnVuY3Rpb24gTyhFLCBSLCBxID0gITApIHtcbiAgICBpZiAoQyhFKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImZpcnN0IGFyZyBtdXN0IGJlIHByaXZhdGUga2V5XCIpO1xuICAgIGlmICghQyhSKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInNlY29uZCBhcmcgbXVzdCBiZSBwdWJsaWMga2V5XCIpO1xuICAgIHJldHVybiBsLmZyb21IZXgoUikubXVsdGlwbHkoZihFKSkudG9SYXdCeXRlcyhxKTtcbiAgfVxuICBjb25zdCB3ID0gZS5iaXRzMmludCB8fCBmdW5jdGlvbihFKSB7XG4gICAgY29uc3QgUiA9IGxlKEUpLCBxID0gRS5sZW5ndGggKiA4IC0gZS5uQml0TGVuZ3RoO1xuICAgIHJldHVybiBxID4gMCA/IFIgPj4gQmlnSW50KHEpIDogUjtcbiAgfSwgeCA9IGUuYml0czJpbnRfbW9kTiB8fCBmdW5jdGlvbihFKSB7XG4gICAgcmV0dXJuIGEodyhFKSk7XG4gIH0sIEEgPSBLbihlLm5CaXRMZW5ndGgpO1xuICBmdW5jdGlvbiBCKEUpIHtcbiAgICBpZiAodHlwZW9mIEUgIT0gXCJiaWdpbnRcIilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImJpZ2ludCBleHBlY3RlZFwiKTtcbiAgICBpZiAoIShrZSA8PSBFICYmIEUgPCBBKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgYmlnaW50IGV4cGVjdGVkIDwgMl4ke2UubkJpdExlbmd0aH1gKTtcbiAgICByZXR1cm4gZXQoRSwgZS5uQnl0ZUxlbmd0aCk7XG4gIH1cbiAgZnVuY3Rpb24gTChFLCBSLCBxID0gUCkge1xuICAgIGlmIChbXCJyZWNvdmVyZWRcIiwgXCJjYW5vbmljYWxcIl0uc29tZSgobWUpID0+IG1lIGluIHEpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2lnbigpIGxlZ2FjeSBvcHRpb25zIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgY29uc3QgeyBoYXNoOiBILCByYW5kb21CeXRlczogRCB9ID0gZTtcbiAgICBsZXQgeyBsb3dTOiBYLCBwcmVoYXNoOiBvZSwgZXh0cmFFbnRyb3B5OiByZSB9ID0gcTtcbiAgICBYID09IG51bGwgJiYgKFggPSAhMCksIEUgPSBlZShcIm1zZ0hhc2hcIiwgRSksIG9lICYmIChFID0gZWUoXCJwcmVoYXNoZWQgbXNnSGFzaFwiLCBIKEUpKSk7XG4gICAgY29uc3QgX2UgPSB4KEUpLCBPZSA9IGYoUiksIFVlID0gW0IoT2UpLCBCKF9lKV07XG4gICAgaWYgKHJlICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IG1lID0gcmUgPT09ICEwID8gRChyLkJZVEVTKSA6IHJlO1xuICAgICAgVWUucHVzaChlZShcImV4dHJhRW50cm9weVwiLCBtZSwgci5CWVRFUykpO1xuICAgIH1cbiAgICBjb25zdCBQZSA9IGhlKC4uLlVlKSwgeWUgPSBfZTtcbiAgICBmdW5jdGlvbiBqZShtZSkge1xuICAgICAgY29uc3QgeGUgPSB3KG1lKTtcbiAgICAgIGlmICghaCh4ZSkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IGxyID0gYyh4ZSksIEJlID0gbC5CQVNFLm11bHRpcGx5KHhlKS50b0FmZmluZSgpLCBmZSA9IGEoQmUueCk7XG4gICAgICBpZiAoZmUgPT09IGtlKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBIZSA9IGEobHIgKiBhKHllICsgZmUgKiBPZSkpO1xuICAgICAgaWYgKEhlID09PSBrZSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgbGV0IGl0ID0gKEJlLnggPT09IGZlID8gMCA6IDIpIHwgTnVtYmVyKEJlLnkgJiBZKSwgb3QgPSBIZTtcbiAgICAgIHJldHVybiBYICYmIHAoSGUpICYmIChvdCA9IHkoSGUpLCBpdCBePSAxKSwgbmV3IHYoZmUsIG90LCBpdCk7XG4gICAgfVxuICAgIHJldHVybiB7IHNlZWQ6IFBlLCBrMnNpZzogamUgfTtcbiAgfVxuICBjb25zdCBQID0geyBsb3dTOiBlLmxvd1MsIHByZWhhc2g6ICExIH0sIEYgPSB7IGxvd1M6IGUubG93UywgcHJlaGFzaDogITEgfTtcbiAgZnVuY3Rpb24geihFLCBSLCBxID0gUCkge1xuICAgIGNvbnN0IHsgc2VlZDogSCwgazJzaWc6IEQgfSA9IEwoRSwgUiwgcSk7XG4gICAgcmV0dXJuIGlzKGUuaGFzaC5vdXRwdXRMZW4sIGUubkJ5dGVMZW5ndGgsIGUuaG1hYykoSCwgRCk7XG4gIH1cbiAgbC5CQVNFLl9zZXRXaW5kb3dTaXplKDgpO1xuICBmdW5jdGlvbiBHKEUsIFIsIHEsIEggPSBGKSB7XG4gICAgdmFyIEJlO1xuICAgIGNvbnN0IEQgPSBFO1xuICAgIGlmIChSID0gZWUoXCJtc2dIYXNoXCIsIFIpLCBxID0gZWUoXCJwdWJsaWNLZXlcIiwgcSksIFwic3RyaWN0XCIgaW4gSClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm9wdGlvbnMuc3RyaWN0IHdhcyByZW5hbWVkIHRvIGxvd1NcIik7XG4gICAgY29uc3QgeyBsb3dTOiBYLCBwcmVoYXNoOiBvZSB9ID0gSDtcbiAgICBsZXQgcmUsIF9lO1xuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIEQgPT0gXCJzdHJpbmdcIiB8fCBEIGluc3RhbmNlb2YgVWludDhBcnJheSlcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZSA9IHYuZnJvbURFUihEKTtcbiAgICAgICAgfSBjYXRjaCAoZmUpIHtcbiAgICAgICAgICBpZiAoIShmZSBpbnN0YW5jZW9mIGx0LkVycikpXG4gICAgICAgICAgICB0aHJvdyBmZTtcbiAgICAgICAgICByZSA9IHYuZnJvbUNvbXBhY3QoRCk7XG4gICAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBEID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIEQuciA9PSBcImJpZ2ludFwiICYmIHR5cGVvZiBELnMgPT0gXCJiaWdpbnRcIikge1xuICAgICAgICBjb25zdCB7IHI6IGZlLCBzOiBIZSB9ID0gRDtcbiAgICAgICAgcmUgPSBuZXcgdihmZSwgSGUpO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBBUlNFXCIpO1xuICAgICAgX2UgPSBsLmZyb21IZXgocSk7XG4gICAgfSBjYXRjaCAoZmUpIHtcbiAgICAgIGlmIChmZS5tZXNzYWdlID09PSBcIlBBUlNFXCIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInNpZ25hdHVyZSBtdXN0IGJlIFNpZ25hdHVyZSBpbnN0YW5jZSwgVWludDhBcnJheSBvciBoZXggc3RyaW5nXCIpO1xuICAgICAgcmV0dXJuICExO1xuICAgIH1cbiAgICBpZiAoWCAmJiByZS5oYXNIaWdoUygpKVxuICAgICAgcmV0dXJuICExO1xuICAgIG9lICYmIChSID0gZS5oYXNoKFIpKTtcbiAgICBjb25zdCB7IHI6IE9lLCBzOiBVZSB9ID0gcmUsIFBlID0geChSKSwgeWUgPSBjKFVlKSwgamUgPSBhKFBlICogeWUpLCBtZSA9IGEoT2UgKiB5ZSksIHhlID0gKEJlID0gbC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKF9lLCBqZSwgbWUpKSA9PSBudWxsID8gdm9pZCAwIDogQmUudG9BZmZpbmUoKTtcbiAgICByZXR1cm4geGUgPyBhKHhlLngpID09PSBPZSA6ICExO1xuICB9XG4gIHJldHVybiB7XG4gICAgQ1VSVkU6IGUsXG4gICAgZ2V0UHVibGljS2V5OiBtLFxuICAgIGdldFNoYXJlZFNlY3JldDogTyxcbiAgICBzaWduOiB6LFxuICAgIHZlcmlmeTogRyxcbiAgICBQcm9qZWN0aXZlUG9pbnQ6IGwsXG4gICAgU2lnbmF0dXJlOiB2LFxuICAgIHV0aWxzOiBfXG4gIH07XG59XG5mdW5jdGlvbiBldSh0LCBlKSB7XG4gIGNvbnN0IHIgPSB0Lk9SREVSO1xuICBsZXQgbiA9IGtlO1xuICBmb3IgKGxldCBoID0gciAtIFk7IGggJSAkZSA9PT0ga2U7IGggLz0gJGUpXG4gICAgbiArPSBZO1xuICBjb25zdCBpID0gbiwgcyA9IChyIC0gWSkgLyAkZSAqKiBpLCBvID0gKHMgLSBZKSAvICRlLCBhID0gJGUgKiogaSAtIFksIGMgPSAkZSAqKiAoaSAtIFkpLCBsID0gdC5wb3coZSwgcyksIGYgPSB0LnBvdyhlLCAocyArIFkpIC8gJGUpO1xuICBsZXQgdSA9IChoLCBkKSA9PiB7XG4gICAgbGV0IHAgPSBsLCB5ID0gdC5wb3coZCwgYSksIGcgPSB0LnNxcih5KTtcbiAgICBnID0gdC5tdWwoZywgZCk7XG4gICAgbGV0IHYgPSB0Lm11bChoLCBnKTtcbiAgICB2ID0gdC5wb3codiwgbyksIHYgPSB0Lm11bCh2LCB5KSwgeSA9IHQubXVsKHYsIGQpLCBnID0gdC5tdWwodiwgaCk7XG4gICAgbGV0IF8gPSB0Lm11bChnLCB5KTtcbiAgICB2ID0gdC5wb3coXywgYyk7XG4gICAgbGV0IG0gPSB0LmVxbCh2LCB0Lk9ORSk7XG4gICAgeSA9IHQubXVsKGcsIGYpLCB2ID0gdC5tdWwoXywgcCksIGcgPSB0LmNtb3YoeSwgZywgbSksIF8gPSB0LmNtb3YodiwgXywgbSk7XG4gICAgZm9yIChsZXQgQyA9IGk7IEMgPiBZOyBDLS0pIHtcbiAgICAgIGxldCBPID0gJGUgKiogKEMgLSAkZSksIHcgPSB0LnBvdyhfLCBPKTtcbiAgICAgIGNvbnN0IHggPSB0LmVxbCh3LCB0Lk9ORSk7XG4gICAgICB5ID0gdC5tdWwoZywgcCksIHAgPSB0Lm11bChwLCBwKSwgdyA9IHQubXVsKF8sIHApLCBnID0gdC5jbW92KHksIGcsIHgpLCBfID0gdC5jbW92KHcsIF8sIHgpO1xuICAgIH1cbiAgICByZXR1cm4geyBpc1ZhbGlkOiBtLCB2YWx1ZTogZyB9O1xuICB9O1xuICBpZiAodC5PUkRFUiAlIEhpID09PSBBcikge1xuICAgIGNvbnN0IGggPSAodC5PUkRFUiAtIEFyKSAvIEhpLCBkID0gdC5zcXJ0KHQubmVnKGUpKTtcbiAgICB1ID0gKHAsIHkpID0+IHtcbiAgICAgIGxldCBnID0gdC5zcXIoeSk7XG4gICAgICBjb25zdCB2ID0gdC5tdWwocCwgeSk7XG4gICAgICBnID0gdC5tdWwoZywgdik7XG4gICAgICBsZXQgXyA9IHQucG93KGcsIGgpO1xuICAgICAgXyA9IHQubXVsKF8sIHYpO1xuICAgICAgY29uc3QgbSA9IHQubXVsKF8sIGQpLCBDID0gdC5tdWwodC5zcXIoXyksIHkpLCBPID0gdC5lcWwoQywgcCk7XG4gICAgICBsZXQgdyA9IHQuY21vdihtLCBfLCBPKTtcbiAgICAgIHJldHVybiB7IGlzVmFsaWQ6IE8sIHZhbHVlOiB3IH07XG4gICAgfTtcbiAgfVxuICByZXR1cm4gdTtcbn1cbmZ1bmN0aW9uIHR1KHQsIGUpIHtcbiAgaWYgKG9zKHQpLCAhdC5pc1ZhbGlkKGUuQSkgfHwgIXQuaXNWYWxpZChlLkIpIHx8ICF0LmlzVmFsaWQoZS5aKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJtYXBUb0N1cnZlU2ltcGxlU1dVOiBpbnZhbGlkIG9wdHNcIik7XG4gIGNvbnN0IHIgPSBldSh0LCBlLlopO1xuICBpZiAoIXQuaXNPZGQpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRnAuaXNPZGQgaXMgbm90IGltcGxlbWVudGVkIVwiKTtcbiAgcmV0dXJuIChuKSA9PiB7XG4gICAgbGV0IGksIHMsIG8sIGEsIGMsIGwsIGYsIHU7XG4gICAgaSA9IHQuc3FyKG4pLCBpID0gdC5tdWwoaSwgZS5aKSwgcyA9IHQuc3FyKGkpLCBzID0gdC5hZGQocywgaSksIG8gPSB0LmFkZChzLCB0Lk9ORSksIG8gPSB0Lm11bChvLCBlLkIpLCBhID0gdC5jbW92KGUuWiwgdC5uZWcocyksICF0LmVxbChzLCB0LlpFUk8pKSwgYSA9IHQubXVsKGEsIGUuQSksIHMgPSB0LnNxcihvKSwgbCA9IHQuc3FyKGEpLCBjID0gdC5tdWwobCwgZS5BKSwgcyA9IHQuYWRkKHMsIGMpLCBzID0gdC5tdWwocywgbyksIGwgPSB0Lm11bChsLCBhKSwgYyA9IHQubXVsKGwsIGUuQiksIHMgPSB0LmFkZChzLCBjKSwgZiA9IHQubXVsKGksIG8pO1xuICAgIGNvbnN0IHsgaXNWYWxpZDogaCwgdmFsdWU6IGQgfSA9IHIocywgbCk7XG4gICAgdSA9IHQubXVsKGksIG4pLCB1ID0gdC5tdWwodSwgZCksIGYgPSB0LmNtb3YoZiwgbywgaCksIHUgPSB0LmNtb3YodSwgZCwgaCk7XG4gICAgY29uc3QgcCA9IHQuaXNPZGQobikgPT09IHQuaXNPZGQodSk7XG4gICAgcmV0dXJuIHUgPSB0LmNtb3YodC5uZWcodSksIHUsIHApLCBmID0gdC5kaXYoZiwgYSksIHsgeDogZiwgeTogdSB9O1xuICB9O1xufVxuZnVuY3Rpb24gcnUodCkge1xuICBpZiAodCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpXG4gICAgcmV0dXJuIHQ7XG4gIGlmICh0eXBlb2YgdCA9PSBcInN0cmluZ1wiKVxuICAgIHJldHVybiBxcih0KTtcbiAgdGhyb3cgbmV3IEVycm9yKFwiRFNUIG11c3QgYmUgVWludDhBcnJheSBvciBzdHJpbmdcIik7XG59XG5jb25zdCBudSA9IGxlO1xuZnVuY3Rpb24gWmUodCwgZSkge1xuICBpZiAodCA8IDAgfHwgdCA+PSAxIDw8IDggKiBlKVxuICAgIHRocm93IG5ldyBFcnJvcihgYmFkIEkyT1NQIGNhbGw6IHZhbHVlPSR7dH0gbGVuZ3RoPSR7ZX1gKTtcbiAgY29uc3QgciA9IEFycmF5LmZyb20oeyBsZW5ndGg6IGUgfSkuZmlsbCgwKTtcbiAgZm9yIChsZXQgbiA9IGUgLSAxOyBuID49IDA7IG4tLSlcbiAgICByW25dID0gdCAmIDI1NSwgdCA+Pj49IDg7XG4gIHJldHVybiBuZXcgVWludDhBcnJheShyKTtcbn1cbmZ1bmN0aW9uIGl1KHQsIGUpIHtcbiAgY29uc3QgciA9IG5ldyBVaW50OEFycmF5KHQubGVuZ3RoKTtcbiAgZm9yIChsZXQgbiA9IDA7IG4gPCB0Lmxlbmd0aDsgbisrKVxuICAgIHJbbl0gPSB0W25dIF4gZVtuXTtcbiAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiB0cih0KSB7XG4gIGlmICghKHQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVaW50OEFycmF5IGV4cGVjdGVkXCIpO1xufVxuZnVuY3Rpb24gVm4odCkge1xuICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKHQpKVxuICAgIHRocm93IG5ldyBFcnJvcihcIm51bWJlciBleHBlY3RlZFwiKTtcbn1cbmZ1bmN0aW9uIG91KHQsIGUsIHIsIG4pIHtcbiAgdHIodCksIHRyKGUpLCBWbihyKSwgZS5sZW5ndGggPiAyNTUgJiYgKGUgPSBuKGhlKHFyKFwiSDJDLU9WRVJTSVpFLURTVC1cIiksIGUpKSk7XG4gIGNvbnN0IHsgb3V0cHV0TGVuOiBpLCBibG9ja0xlbjogcyB9ID0gbiwgbyA9IE1hdGguY2VpbChyIC8gaSk7XG4gIGlmIChvID4gMjU1KVxuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgeG1kIGxlbmd0aFwiKTtcbiAgY29uc3QgYSA9IGhlKGUsIFplKGUubGVuZ3RoLCAxKSksIGMgPSBaZSgwLCBzKSwgbCA9IFplKHIsIDIpLCBmID0gbmV3IEFycmF5KG8pLCB1ID0gbihoZShjLCB0LCBsLCBaZSgwLCAxKSwgYSkpO1xuICBmWzBdID0gbihoZSh1LCBaZSgxLCAxKSwgYSkpO1xuICBmb3IgKGxldCBkID0gMTsgZCA8PSBvOyBkKyspIHtcbiAgICBjb25zdCBwID0gW2l1KHUsIGZbZCAtIDFdKSwgWmUoZCArIDEsIDEpLCBhXTtcbiAgICBmW2RdID0gbihoZSguLi5wKSk7XG4gIH1cbiAgcmV0dXJuIGhlKC4uLmYpLnNsaWNlKDAsIHIpO1xufVxuZnVuY3Rpb24gc3UodCwgZSwgciwgbiwgaSkge1xuICBpZiAodHIodCksIHRyKGUpLCBWbihyKSwgZS5sZW5ndGggPiAyNTUpIHtcbiAgICBjb25zdCBzID0gTWF0aC5jZWlsKDIgKiBuIC8gOCk7XG4gICAgZSA9IGkuY3JlYXRlKHsgZGtMZW46IHMgfSkudXBkYXRlKHFyKFwiSDJDLU9WRVJTSVpFLURTVC1cIikpLnVwZGF0ZShlKS5kaWdlc3QoKTtcbiAgfVxuICBpZiAociA+IDY1NTM1IHx8IGUubGVuZ3RoID4gMjU1KVxuICAgIHRocm93IG5ldyBFcnJvcihcImV4cGFuZF9tZXNzYWdlX3hvZjogaW52YWxpZCBsZW5JbkJ5dGVzXCIpO1xuICByZXR1cm4gaS5jcmVhdGUoeyBka0xlbjogciB9KS51cGRhdGUodCkudXBkYXRlKFplKHIsIDIpKS51cGRhdGUoZSkudXBkYXRlKFplKGUubGVuZ3RoLCAxKSkuZGlnZXN0KCk7XG59XG5mdW5jdGlvbiBNaSh0LCBlLCByKSB7XG4gIGt0KHIsIHtcbiAgICBEU1Q6IFwic3RyaW5nXCIsXG4gICAgcDogXCJiaWdpbnRcIixcbiAgICBtOiBcImlzU2FmZUludGVnZXJcIixcbiAgICBrOiBcImlzU2FmZUludGVnZXJcIixcbiAgICBoYXNoOiBcImhhc2hcIlxuICB9KTtcbiAgY29uc3QgeyBwOiBuLCBrOiBpLCBtOiBzLCBoYXNoOiBvLCBleHBhbmQ6IGEsIERTVDogYyB9ID0gcjtcbiAgdHIodCksIFZuKGUpO1xuICBjb25zdCBsID0gcnUoYyksIGYgPSBuLnRvU3RyaW5nKDIpLmxlbmd0aCwgdSA9IE1hdGguY2VpbCgoZiArIGkpIC8gOCksIGggPSBlICogcyAqIHU7XG4gIGxldCBkO1xuICBpZiAoYSA9PT0gXCJ4bWRcIilcbiAgICBkID0gb3UodCwgbCwgaCwgbyk7XG4gIGVsc2UgaWYgKGEgPT09IFwieG9mXCIpXG4gICAgZCA9IHN1KHQsIGwsIGgsIGksIG8pO1xuICBlbHNlIGlmIChhID09PSBcIl9pbnRlcm5hbF9wYXNzXCIpXG4gICAgZCA9IHQ7XG4gIGVsc2VcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGFuZCBtdXN0IGJlIFwieG1kXCIgb3IgXCJ4b2ZcIicpO1xuICBjb25zdCBwID0gbmV3IEFycmF5KGUpO1xuICBmb3IgKGxldCB5ID0gMDsgeSA8IGU7IHkrKykge1xuICAgIGNvbnN0IGcgPSBuZXcgQXJyYXkocyk7XG4gICAgZm9yIChsZXQgdiA9IDA7IHYgPCBzOyB2KyspIHtcbiAgICAgIGNvbnN0IF8gPSB1ICogKHYgKyB5ICogcyksIG0gPSBkLnN1YmFycmF5KF8sIF8gKyB1KTtcbiAgICAgIGdbdl0gPSBKKG51KG0pLCBuKTtcbiAgICB9XG4gICAgcFt5XSA9IGc7XG4gIH1cbiAgcmV0dXJuIHA7XG59XG5mdW5jdGlvbiBhdSh0LCBlKSB7XG4gIGNvbnN0IHIgPSBlLm1hcCgobikgPT4gQXJyYXkuZnJvbShuKS5yZXZlcnNlKCkpO1xuICByZXR1cm4gKG4sIGkpID0+IHtcbiAgICBjb25zdCBbcywgbywgYSwgY10gPSByLm1hcCgobCkgPT4gbC5yZWR1Y2UoKGYsIHUpID0+IHQuYWRkKHQubXVsKGYsIG4pLCB1KSkpO1xuICAgIHJldHVybiBuID0gdC5kaXYocywgbyksIGkgPSB0Lm11bChpLCB0LmRpdihhLCBjKSksIHsgeDogbiwgeTogaSB9O1xuICB9O1xufVxuZnVuY3Rpb24gY3UodCwgZSwgcikge1xuICBpZiAodHlwZW9mIGUgIT0gXCJmdW5jdGlvblwiKVxuICAgIHRocm93IG5ldyBFcnJvcihcIm1hcFRvQ3VydmUoKSBtdXN0IGJlIGRlZmluZWRcIik7XG4gIHJldHVybiB7XG4gICAgaGFzaFRvQ3VydmUobiwgaSkge1xuICAgICAgY29uc3QgcyA9IE1pKG4sIDIsIHsgLi4uciwgRFNUOiByLkRTVCwgLi4uaSB9KSwgbyA9IHQuZnJvbUFmZmluZShlKHNbMF0pKSwgYSA9IHQuZnJvbUFmZmluZShlKHNbMV0pKSwgYyA9IG8uYWRkKGEpLmNsZWFyQ29mYWN0b3IoKTtcbiAgICAgIHJldHVybiBjLmFzc2VydFZhbGlkaXR5KCksIGM7XG4gICAgfSxcbiAgICBlbmNvZGVUb0N1cnZlKG4sIGkpIHtcbiAgICAgIGNvbnN0IHMgPSBNaShuLCAxLCB7IC4uLnIsIERTVDogci5lbmNvZGVEU1QsIC4uLmkgfSksIG8gPSB0LmZyb21BZmZpbmUoZShzWzBdKSkuY2xlYXJDb2ZhY3RvcigpO1xuICAgICAgcmV0dXJuIG8uYXNzZXJ0VmFsaWRpdHkoKSwgbztcbiAgICB9XG4gIH07XG59XG5jbGFzcyBhcyBleHRlbmRzIEpvIHtcbiAgY29uc3RydWN0b3IoZSwgcikge1xuICAgIHN1cGVyKCksIHRoaXMuZmluaXNoZWQgPSAhMSwgdGhpcy5kZXN0cm95ZWQgPSAhMSwgdXQuaGFzaChlKTtcbiAgICBjb25zdCBuID0gRG4ocik7XG4gICAgaWYgKHRoaXMuaUhhc2ggPSBlLmNyZWF0ZSgpLCB0eXBlb2YgdGhpcy5pSGFzaC51cGRhdGUgIT0gXCJmdW5jdGlvblwiKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGluc3RhbmNlIG9mIGNsYXNzIHdoaWNoIGV4dGVuZHMgdXRpbHMuSGFzaFwiKTtcbiAgICB0aGlzLmJsb2NrTGVuID0gdGhpcy5pSGFzaC5ibG9ja0xlbiwgdGhpcy5vdXRwdXRMZW4gPSB0aGlzLmlIYXNoLm91dHB1dExlbjtcbiAgICBjb25zdCBpID0gdGhpcy5ibG9ja0xlbiwgcyA9IG5ldyBVaW50OEFycmF5KGkpO1xuICAgIHMuc2V0KG4ubGVuZ3RoID4gaSA/IGUuY3JlYXRlKCkudXBkYXRlKG4pLmRpZ2VzdCgpIDogbik7XG4gICAgZm9yIChsZXQgbyA9IDA7IG8gPCBzLmxlbmd0aDsgbysrKVxuICAgICAgc1tvXSBePSA1NDtcbiAgICB0aGlzLmlIYXNoLnVwZGF0ZShzKSwgdGhpcy5vSGFzaCA9IGUuY3JlYXRlKCk7XG4gICAgZm9yIChsZXQgbyA9IDA7IG8gPCBzLmxlbmd0aDsgbysrKVxuICAgICAgc1tvXSBePSAxMDY7XG4gICAgdGhpcy5vSGFzaC51cGRhdGUocyksIHMuZmlsbCgwKTtcbiAgfVxuICB1cGRhdGUoZSkge1xuICAgIHJldHVybiB1dC5leGlzdHModGhpcyksIHRoaXMuaUhhc2gudXBkYXRlKGUpLCB0aGlzO1xuICB9XG4gIGRpZ2VzdEludG8oZSkge1xuICAgIHV0LmV4aXN0cyh0aGlzKSwgdXQuYnl0ZXMoZSwgdGhpcy5vdXRwdXRMZW4pLCB0aGlzLmZpbmlzaGVkID0gITAsIHRoaXMuaUhhc2guZGlnZXN0SW50byhlKSwgdGhpcy5vSGFzaC51cGRhdGUoZSksIHRoaXMub0hhc2guZGlnZXN0SW50byhlKSwgdGhpcy5kZXN0cm95KCk7XG4gIH1cbiAgZGlnZXN0KCkge1xuICAgIGNvbnN0IGUgPSBuZXcgVWludDhBcnJheSh0aGlzLm9IYXNoLm91dHB1dExlbik7XG4gICAgcmV0dXJuIHRoaXMuZGlnZXN0SW50byhlKSwgZTtcbiAgfVxuICBfY2xvbmVJbnRvKGUpIHtcbiAgICBlIHx8IChlID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyksIHt9KSk7XG4gICAgY29uc3QgeyBvSGFzaDogciwgaUhhc2g6IG4sIGZpbmlzaGVkOiBpLCBkZXN0cm95ZWQ6IHMsIGJsb2NrTGVuOiBvLCBvdXRwdXRMZW46IGEgfSA9IHRoaXM7XG4gICAgcmV0dXJuIGUgPSBlLCBlLmZpbmlzaGVkID0gaSwgZS5kZXN0cm95ZWQgPSBzLCBlLmJsb2NrTGVuID0gbywgZS5vdXRwdXRMZW4gPSBhLCBlLm9IYXNoID0gci5fY2xvbmVJbnRvKGUub0hhc2gpLCBlLmlIYXNoID0gbi5fY2xvbmVJbnRvKGUuaUhhc2gpLCBlO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSAhMCwgdGhpcy5vSGFzaC5kZXN0cm95KCksIHRoaXMuaUhhc2guZGVzdHJveSgpO1xuICB9XG59XG5jb25zdCBjcyA9ICh0LCBlLCByKSA9PiBuZXcgYXModCwgZSkudXBkYXRlKHIpLmRpZ2VzdCgpO1xuY3MuY3JlYXRlID0gKHQsIGUpID0+IG5ldyBhcyh0LCBlKTtcbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmZ1bmN0aW9uIHV1KHQpIHtcbiAgcmV0dXJuIHtcbiAgICBoYXNoOiB0LFxuICAgIGhtYWM6IChlLCAuLi5yKSA9PiBjcyh0LCBlLCBtYyguLi5yKSksXG4gICAgcmFuZG9tQnl0ZXM6IFFvXG4gIH07XG59XG5mdW5jdGlvbiBsdSh0LCBlKSB7XG4gIGNvbnN0IHIgPSAobikgPT4gUWMoeyAuLi50LCAuLi51dShuKSB9KTtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyAuLi5yKGUpLCBjcmVhdGU6IHIgfSk7XG59XG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5jb25zdCBOciA9IEJpZ0ludChcIjB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmVmZmZmZmMyZlwiKSwgQ3IgPSBCaWdJbnQoXCIweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlYmFhZWRjZTZhZjQ4YTAzYmJmZDI1ZThjZDAzNjQxNDFcIiksIHVzID0gQmlnSW50KDEpLCBJciA9IEJpZ0ludCgyKSwgRGkgPSAodCwgZSkgPT4gKHQgKyBlIC8gSXIpIC8gZTtcbmZ1bmN0aW9uIGxzKHQpIHtcbiAgY29uc3QgZSA9IE5yLCByID0gQmlnSW50KDMpLCBuID0gQmlnSW50KDYpLCBpID0gQmlnSW50KDExKSwgcyA9IEJpZ0ludCgyMiksIG8gPSBCaWdJbnQoMjMpLCBhID0gQmlnSW50KDQ0KSwgYyA9IEJpZ0ludCg4OCksIGwgPSB0ICogdCAqIHQgJSBlLCBmID0gbCAqIGwgKiB0ICUgZSwgdSA9IGJlKGYsIHIsIGUpICogZiAlIGUsIGggPSBiZSh1LCByLCBlKSAqIGYgJSBlLCBkID0gYmUoaCwgSXIsIGUpICogbCAlIGUsIHAgPSBiZShkLCBpLCBlKSAqIGQgJSBlLCB5ID0gYmUocCwgcywgZSkgKiBwICUgZSwgZyA9IGJlKHksIGEsIGUpICogeSAlIGUsIHYgPSBiZShnLCBjLCBlKSAqIGcgJSBlLCBfID0gYmUodiwgYSwgZSkgKiB5ICUgZSwgbSA9IGJlKF8sIHIsIGUpICogZiAlIGUsIEMgPSBiZShtLCBvLCBlKSAqIHAgJSBlLCBPID0gYmUoQywgbiwgZSkgKiBsICUgZSwgdyA9IGJlKE8sIElyLCBlKTtcbiAgaWYgKCF0dC5lcWwodHQuc3FyKHcpLCB0KSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBzcXVhcmUgcm9vdFwiKTtcbiAgcmV0dXJuIHc7XG59XG5jb25zdCB0dCA9IEZjKE5yLCB2b2lkIDAsIHZvaWQgMCwgeyBzcXJ0OiBscyB9KSwgdWUgPSBsdSh7XG4gIGE6IEJpZ0ludCgwKSxcbiAgYjogQmlnSW50KDcpLFxuICBGcDogdHQsXG4gIG46IENyLFxuICBHeDogQmlnSW50KFwiNTUwNjYyNjMwMjIyNzczNDM2Njk1Nzg3MTg4OTUxNjg1MzQzMjYyNTA2MDM0NTM3Nzc1OTQxNzU1MDAxODczNjAzODkxMTY3MjkyNDBcIiksXG4gIEd5OiBCaWdJbnQoXCIzMjY3MDUxMDAyMDc1ODgxNjk3ODA4MzA4NTEzMDUwNzA0MzE4NDQ3MTI3MzM4MDY1OTI0MzI3NTkzODkwNDMzNTc1NzMzNzQ4MjQyNFwiKSxcbiAgaDogQmlnSW50KDEpLFxuICBsb3dTOiAhMCxcbiAgZW5kbzoge1xuICAgIGJldGE6IEJpZ0ludChcIjB4N2FlOTZhMmI2NTdjMDcxMDZlNjQ0NzllYWMzNDM0ZTk5Y2YwNDk3NTEyZjU4OTk1YzEzOTZjMjg3MTk1MDFlZVwiKSxcbiAgICBzcGxpdFNjYWxhcjogKHQpID0+IHtcbiAgICAgIGNvbnN0IGUgPSBDciwgciA9IEJpZ0ludChcIjB4MzA4NmQyMjFhN2Q0NmJjZGU4NmM5MGU0OTI4NGViMTVcIiksIG4gPSAtdXMgKiBCaWdJbnQoXCIweGU0NDM3ZWQ2MDEwZTg4Mjg2ZjU0N2ZhOTBhYmZlNGMzXCIpLCBpID0gQmlnSW50KFwiMHgxMTRjYTUwZjdhOGUyZjNmNjU3YzExMDhkOWQ0NGNmZDhcIiksIHMgPSByLCBvID0gQmlnSW50KFwiMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIiksIGEgPSBEaShzICogdCwgZSksIGMgPSBEaSgtbiAqIHQsIGUpO1xuICAgICAgbGV0IGwgPSBKKHQgLSBhICogciAtIGMgKiBpLCBlKSwgZiA9IEooLWEgKiBuIC0gYyAqIHMsIGUpO1xuICAgICAgY29uc3QgdSA9IGwgPiBvLCBoID0gZiA+IG87XG4gICAgICBpZiAodSAmJiAobCA9IGUgLSBsKSwgaCAmJiAoZiA9IGUgLSBmKSwgbCA+IG8gfHwgZiA+IG8pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInNwbGl0U2NhbGFyOiBFbmRvbW9ycGhpc20gZmFpbGVkLCBrPVwiICsgdCk7XG4gICAgICByZXR1cm4geyBrMW5lZzogdSwgazE6IGwsIGsybmVnOiBoLCBrMjogZiB9O1xuICAgIH1cbiAgfVxufSwgT3IpLCBVciA9IEJpZ0ludCgwKSwgZnMgPSAodCkgPT4gdHlwZW9mIHQgPT0gXCJiaWdpbnRcIiAmJiBVciA8IHQgJiYgdCA8IE5yLCBmdSA9ICh0KSA9PiB0eXBlb2YgdCA9PSBcImJpZ2ludFwiICYmIFVyIDwgdCAmJiB0IDwgQ3IsIHppID0ge307XG5mdW5jdGlvbiBScih0LCAuLi5lKSB7XG4gIGxldCByID0gemlbdF07XG4gIGlmIChyID09PSB2b2lkIDApIHtcbiAgICBjb25zdCBuID0gT3IoVWludDhBcnJheS5mcm9tKHQsIChpKSA9PiBpLmNoYXJDb2RlQXQoMCkpKTtcbiAgICByID0gaGUobiwgbiksIHppW3RdID0gcjtcbiAgfVxuICByZXR1cm4gT3IoaGUociwgLi4uZSkpO1xufVxuY29uc3QgR24gPSAodCkgPT4gdC50b1Jhd0J5dGVzKCEwKS5zbGljZSgxKSwgUm4gPSAodCkgPT4gZXQodCwgMzIpLCBzbiA9ICh0KSA9PiBKKHQsIE5yKSwgcnIgPSAodCkgPT4gSih0LCBDciksIFpuID0gdWUuUHJvamVjdGl2ZVBvaW50LCBodSA9ICh0LCBlLCByKSA9PiBabi5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKHQsIGUsIHIpO1xuZnVuY3Rpb24gVG4odCkge1xuICBsZXQgZSA9IHVlLnV0aWxzLm5vcm1Qcml2YXRlS2V5VG9TY2FsYXIodCksIHIgPSBabi5mcm9tUHJpdmF0ZUtleShlKTtcbiAgcmV0dXJuIHsgc2NhbGFyOiByLmhhc0V2ZW5ZKCkgPyBlIDogcnIoLWUpLCBieXRlczogR24ocikgfTtcbn1cbmZ1bmN0aW9uIGhzKHQpIHtcbiAgaWYgKCFmcyh0KSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgeDogbmVlZCAwIDwgeCA8IHBcIik7XG4gIGNvbnN0IGUgPSBzbih0ICogdCksIHIgPSBzbihlICogdCArIEJpZ0ludCg3KSk7XG4gIGxldCBuID0gbHMocik7XG4gIG4gJSBJciAhPT0gVXIgJiYgKG4gPSBzbigtbikpO1xuICBjb25zdCBpID0gbmV3IFpuKHQsIG4sIHVzKTtcbiAgcmV0dXJuIGkuYXNzZXJ0VmFsaWRpdHkoKSwgaTtcbn1cbmZ1bmN0aW9uIGRzKC4uLnQpIHtcbiAgcmV0dXJuIHJyKGxlKFJyKFwiQklQMDM0MC9jaGFsbGVuZ2VcIiwgLi4udCkpKTtcbn1cbmZ1bmN0aW9uIGR1KHQpIHtcbiAgcmV0dXJuIFRuKHQpLmJ5dGVzO1xufVxuZnVuY3Rpb24gcHUodCwgZSwgciA9IFFvKDMyKSkge1xuICBjb25zdCBuID0gZWUoXCJtZXNzYWdlXCIsIHQpLCB7IGJ5dGVzOiBpLCBzY2FsYXI6IHMgfSA9IFRuKGUpLCBvID0gZWUoXCJhdXhSYW5kXCIsIHIsIDMyKSwgYSA9IFJuKHMgXiBsZShScihcIkJJUDAzNDAvYXV4XCIsIG8pKSksIGMgPSBScihcIkJJUDAzNDAvbm9uY2VcIiwgYSwgaSwgbiksIGwgPSBycihsZShjKSk7XG4gIGlmIChsID09PSBVcilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJzaWduIGZhaWxlZDogayBpcyB6ZXJvXCIpO1xuICBjb25zdCB7IGJ5dGVzOiBmLCBzY2FsYXI6IHUgfSA9IFRuKGwpLCBoID0gZHMoZiwgaSwgbiksIGQgPSBuZXcgVWludDhBcnJheSg2NCk7XG4gIGlmIChkLnNldChmLCAwKSwgZC5zZXQoUm4ocnIodSArIGggKiBzKSksIDMyKSwgIXBzKGQsIG4sIGkpKVxuICAgIHRocm93IG5ldyBFcnJvcihcInNpZ246IEludmFsaWQgc2lnbmF0dXJlIHByb2R1Y2VkXCIpO1xuICByZXR1cm4gZDtcbn1cbmZ1bmN0aW9uIHBzKHQsIGUsIHIpIHtcbiAgY29uc3QgbiA9IGVlKFwic2lnbmF0dXJlXCIsIHQsIDY0KSwgaSA9IGVlKFwibWVzc2FnZVwiLCBlKSwgcyA9IGVlKFwicHVibGljS2V5XCIsIHIsIDMyKTtcbiAgdHJ5IHtcbiAgICBjb25zdCBvID0gaHMobGUocykpLCBhID0gbGUobi5zdWJhcnJheSgwLCAzMikpO1xuICAgIGlmICghZnMoYSkpXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3QgYyA9IGxlKG4uc3ViYXJyYXkoMzIsIDY0KSk7XG4gICAgaWYgKCFmdShjKSlcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCBsID0gZHMoUm4oYSksIEduKG8pLCBpKSwgZiA9IGh1KG8sIGMsIHJyKC1sKSk7XG4gICAgcmV0dXJuICEoIWYgfHwgIWYuaGFzRXZlblkoKSB8fCBmLnRvQWZmaW5lKCkueCAhPT0gYSk7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiAhMTtcbiAgfVxufVxuY29uc3QgU3QgPSB7XG4gIGdldFB1YmxpY0tleTogZHUsXG4gIHNpZ246IHB1LFxuICB2ZXJpZnk6IHBzLFxuICB1dGlsczoge1xuICAgIHJhbmRvbVByaXZhdGVLZXk6IHVlLnV0aWxzLnJhbmRvbVByaXZhdGVLZXksXG4gICAgbGlmdF94OiBocyxcbiAgICBwb2ludFRvQnl0ZXM6IEduLFxuICAgIG51bWJlclRvQnl0ZXNCRTogZXQsXG4gICAgYnl0ZXNUb051bWJlckJFOiBsZSxcbiAgICB0YWdnZWRIYXNoOiBScixcbiAgICBtb2Q6IEpcbiAgfVxufSwgeXUgPSBhdSh0dCwgW1xuICBbXG4gICAgXCIweDhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhkYWFhYWE4YzdcIixcbiAgICBcIjB4N2QzZDRjODBiYzMyMWQ1YjlmMzE1Y2VhN2ZkNDRjNWQ1OTVkMmZjMGJmNjNiOTJkZmZmMTA0NGYxN2M2NTgxXCIsXG4gICAgXCIweDUzNGMzMjhkMjNmMjM0ZTZlMmE0MTNkZWNhMjVjYWVjZTQ1MDYxNDQwMzdjNDAzMTRlY2JkMGI1M2Q5ZGQyNjJcIixcbiAgICBcIjB4OGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGRhYWFhYTg4Y1wiXG4gIF0sXG4gIFtcbiAgICBcIjB4ZDM1NzcxMTkzZDk0OTE4YTljYTM0Y2NiYjdiNjQwZGQ4NmNkNDA5NTQyZjg0ODdkOWZlNmI3NDU3ODFlYjQ5YlwiLFxuICAgIFwiMHhlZGFkYzZmNjQzODNkYzFkZjdjNGIyZDUxYjU0MjI1NDA2ZDM2YjY0MWY1ZTQxYmJjNTJhNTY2MTJhOGM2ZDE0XCIsXG4gICAgXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDFcIlxuICBdLFxuICBbXG4gICAgXCIweDRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiOGUzOGUyM2NcIixcbiAgICBcIjB4Yzc1ZTBjMzJkNWNiN2MwZmE5ZDBhNTRiMTJhMGE2ZDU2NDdhYjA0NmQ2ODZkYTZmZGZmYzkwZmMyMDFkNzFhM1wiLFxuICAgIFwiMHgyOWE2MTk0NjkxZjkxYTczNzE1MjA5ZWY2NTEyZTU3NjcyMjgzMGEyMDFiZTIwMThhNzY1ZTg1YTllY2VlOTMxXCIsXG4gICAgXCIweDJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmMzhlMzhkODRcIlxuICBdLFxuICBbXG4gICAgXCIweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZmZmZmY5M2JcIixcbiAgICBcIjB4N2EwNjUzNGJiOGJkYjQ5ZmQ1ZTllNjYzMjcyMmMyOTg5NDY3YzFiZmM4ZThkOTc4ZGZiNDI1ZDI2ODVjMjU3M1wiLFxuICAgIFwiMHg2NDg0YWE3MTY1NDVjYTJjZjNhNzBjM2ZhOGZlMzM3ZTBhM2QyMTE2MmYwZDYyOTlhN2JmODE5MmJmZDJhNzZmXCIsXG4gICAgXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDFcIlxuICBdXG5dLm1hcCgodCkgPT4gdC5tYXAoKGUpID0+IEJpZ0ludChlKSkpKSwgZ3UgPSB0dSh0dCwge1xuICBBOiBCaWdJbnQoXCIweDNmODczMWFiZGQ2NjFhZGNhMDhhNTU1OGYwZjVkMjcyZTk1M2QzNjNjYjZmMGU1ZDQwNTQ0N2MwMWE0NDQ1MzNcIiksXG4gIEI6IEJpZ0ludChcIjE3NzFcIiksXG4gIFo6IHR0LmNyZWF0ZShCaWdJbnQoXCItMTFcIikpXG59KTtcbmN1KHVlLlByb2plY3RpdmVQb2ludCwgKHQpID0+IHtcbiAgY29uc3QgeyB4OiBlLCB5OiByIH0gPSBndSh0dC5jcmVhdGUodFswXSkpO1xuICByZXR1cm4geXUoZSwgcik7XG59LCB7XG4gIERTVDogXCJzZWNwMjU2azFfWE1EOlNIQS0yNTZfU1NXVV9ST19cIixcbiAgZW5jb2RlRFNUOiBcInNlY3AyNTZrMV9YTUQ6U0hBLTI1Nl9TU1dVX05VX1wiLFxuICBwOiB0dC5PUkRFUixcbiAgbTogMSxcbiAgazogMTI4LFxuICBleHBhbmQ6IFwieG1kXCIsXG4gIGhhc2g6IE9yXG59KTtcbmNvbnN0IGFuID0gdHlwZW9mIGdsb2JhbFRoaXMgPT0gXCJvYmplY3RcIiAmJiBcImNyeXB0b1wiIGluIGdsb2JhbFRoaXMgPyBnbG9iYWxUaGlzLmNyeXB0byA6IHZvaWQgMDtcbi8qISBub2JsZS1oYXNoZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmNvbnN0IGNuID0gKHQpID0+IG5ldyBEYXRhVmlldyh0LmJ1ZmZlciwgdC5ieXRlT2Zmc2V0LCB0LmJ5dGVMZW5ndGgpLCBDZSA9ICh0LCBlKSA9PiB0IDw8IDMyIC0gZSB8IHQgPj4+IGUsIGJ1ID0gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQzMkFycmF5KFsyODc0NTQwMjBdKS5idWZmZXIpWzBdID09PSA2ODtcbmlmICghYnUpXG4gIHRocm93IG5ldyBFcnJvcihcIk5vbiBsaXR0bGUtZW5kaWFuIGhhcmR3YXJlIGlzIG5vdCBzdXBwb3J0ZWRcIik7XG5jb25zdCB2dSA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAodCwgZSkgPT4gZS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpKTtcbmZ1bmN0aW9uIHZlKHQpIHtcbiAgaWYgKCEodCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgIHRocm93IG5ldyBFcnJvcihcIlVpbnQ4QXJyYXkgZXhwZWN0ZWRcIik7XG4gIGxldCBlID0gXCJcIjtcbiAgZm9yIChsZXQgciA9IDA7IHIgPCB0Lmxlbmd0aDsgcisrKVxuICAgIGUgKz0gdnVbdFtyXV07XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gX3QodCkge1xuICBpZiAodHlwZW9mIHQgIT0gXCJzdHJpbmdcIilcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaGV4VG9CeXRlczogZXhwZWN0ZWQgc3RyaW5nLCBnb3QgXCIgKyB0eXBlb2YgdCk7XG4gIGlmICh0Lmxlbmd0aCAlIDIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaGV4VG9CeXRlczogcmVjZWl2ZWQgaW52YWxpZCB1bnBhZGRlZCBoZXhcIik7XG4gIGNvbnN0IGUgPSBuZXcgVWludDhBcnJheSh0Lmxlbmd0aCAvIDIpO1xuICBmb3IgKGxldCByID0gMDsgciA8IGUubGVuZ3RoOyByKyspIHtcbiAgICBjb25zdCBuID0gciAqIDIsIGkgPSB0LnNsaWNlKG4sIG4gKyAyKSwgcyA9IE51bWJlci5wYXJzZUludChpLCAxNik7XG4gICAgaWYgKE51bWJlci5pc05hTihzKSB8fCBzIDwgMClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYnl0ZSBzZXF1ZW5jZVwiKTtcbiAgICBlW3JdID0gcztcbiAgfVxuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIHd1KHQpIHtcbiAgaWYgKHR5cGVvZiB0ICE9IFwic3RyaW5nXCIpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgdXRmOFRvQnl0ZXMgZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2YgdH1gKTtcbiAgcmV0dXJuIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh0KTtcbn1cbmZ1bmN0aW9uIHlzKHQpIHtcbiAgaWYgKHR5cGVvZiB0ID09IFwic3RyaW5nXCIgJiYgKHQgPSB3dSh0KSksICEodCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIGlucHV0IHR5cGUgaXMgVWludDhBcnJheSAoZ290ICR7dHlwZW9mIHR9KWApO1xuICByZXR1cm4gdDtcbn1cbmZ1bmN0aW9uIF91KC4uLnQpIHtcbiAgaWYgKCF0LmV2ZXJ5KChuKSA9PiBuIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVWludDhBcnJheSBsaXN0IGV4cGVjdGVkXCIpO1xuICBpZiAodC5sZW5ndGggPT09IDEpXG4gICAgcmV0dXJuIHRbMF07XG4gIGNvbnN0IGUgPSB0LnJlZHVjZSgobiwgaSkgPT4gbiArIGkubGVuZ3RoLCAwKSwgciA9IG5ldyBVaW50OEFycmF5KGUpO1xuICBmb3IgKGxldCBuID0gMCwgaSA9IDA7IG4gPCB0Lmxlbmd0aDsgbisrKSB7XG4gICAgY29uc3QgcyA9IHRbbl07XG4gICAgci5zZXQocywgaSksIGkgKz0gcy5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5jbGFzcyBtdSB7XG4gIGNsb25lKCkge1xuICAgIHJldHVybiB0aGlzLl9jbG9uZUludG8oKTtcbiAgfVxufVxuZnVuY3Rpb24gZ3ModCkge1xuICBjb25zdCBlID0gKG4pID0+IHQoKS51cGRhdGUoeXMobikpLmRpZ2VzdCgpLCByID0gdCgpO1xuICByZXR1cm4gZS5vdXRwdXRMZW4gPSByLm91dHB1dExlbiwgZS5ibG9ja0xlbiA9IHIuYmxvY2tMZW4sIGUuY3JlYXRlID0gKCkgPT4gdCgpLCBlO1xufVxuZnVuY3Rpb24geHUodCA9IDMyKSB7XG4gIGlmIChhbiAmJiB0eXBlb2YgYW4uZ2V0UmFuZG9tVmFsdWVzID09IFwiZnVuY3Rpb25cIilcbiAgICByZXR1cm4gYW4uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KHQpKTtcbiAgdGhyb3cgbmV3IEVycm9yKFwiY3J5cHRvLmdldFJhbmRvbVZhbHVlcyBtdXN0IGJlIGRlZmluZWRcIik7XG59XG5mdW5jdGlvbiBQbih0KSB7XG4gIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIodCkgfHwgdCA8IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKGBXcm9uZyBwb3NpdGl2ZSBpbnRlZ2VyOiAke3R9YCk7XG59XG5mdW5jdGlvbiBFdSh0KSB7XG4gIGlmICh0eXBlb2YgdCAhPSBcImJvb2xlYW5cIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGJvb2xlYW4sIG5vdCAke3R9YCk7XG59XG5mdW5jdGlvbiBicyh0LCAuLi5lKSB7XG4gIGlmICghKHQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgVWludDhBcnJheVwiKTtcbiAgaWYgKGUubGVuZ3RoID4gMCAmJiAhZS5pbmNsdWRlcyh0Lmxlbmd0aCkpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgVWludDhBcnJheSBvZiBsZW5ndGggJHtlfSwgbm90IG9mIGxlbmd0aD0ke3QubGVuZ3RofWApO1xufVxuZnVuY3Rpb24ga3UodCkge1xuICBpZiAodHlwZW9mIHQgIT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiB0LmNyZWF0ZSAhPSBcImZ1bmN0aW9uXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSGFzaCBzaG91bGQgYmUgd3JhcHBlZCBieSB1dGlscy53cmFwQ29uc3RydWN0b3JcIik7XG4gIFBuKHQub3V0cHV0TGVuKSwgUG4odC5ibG9ja0xlbik7XG59XG5mdW5jdGlvbiBTdSh0LCBlID0gITApIHtcbiAgaWYgKHQuZGVzdHJveWVkKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkhhc2ggaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkXCIpO1xuICBpZiAoZSAmJiB0LmZpbmlzaGVkKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkhhc2gjZGlnZXN0KCkgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWRcIik7XG59XG5mdW5jdGlvbiBPdSh0LCBlKSB7XG4gIGJzKHQpO1xuICBjb25zdCByID0gZS5vdXRwdXRMZW47XG4gIGlmICh0Lmxlbmd0aCA8IHIpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBkaWdlc3RJbnRvKCkgZXhwZWN0cyBvdXRwdXQgYnVmZmVyIG9mIGxlbmd0aCBhdCBsZWFzdCAke3J9YCk7XG59XG5jb25zdCB1biA9IHtcbiAgbnVtYmVyOiBQbixcbiAgYm9vbDogRXUsXG4gIGJ5dGVzOiBicyxcbiAgaGFzaDoga3UsXG4gIGV4aXN0czogU3UsXG4gIG91dHB1dDogT3Vcbn07XG5mdW5jdGlvbiBBdSh0LCBlLCByLCBuKSB7XG4gIGlmICh0eXBlb2YgdC5zZXRCaWdVaW50NjQgPT0gXCJmdW5jdGlvblwiKVxuICAgIHJldHVybiB0LnNldEJpZ1VpbnQ2NChlLCByLCBuKTtcbiAgY29uc3QgaSA9IEJpZ0ludCgzMiksIHMgPSBCaWdJbnQoNDI5NDk2NzI5NSksIG8gPSBOdW1iZXIociA+PiBpICYgcyksIGEgPSBOdW1iZXIociAmIHMpLCBjID0gbiA/IDQgOiAwLCBsID0gbiA/IDAgOiA0O1xuICB0LnNldFVpbnQzMihlICsgYywgbywgbiksIHQuc2V0VWludDMyKGUgKyBsLCBhLCBuKTtcbn1cbmNsYXNzIEN1IGV4dGVuZHMgbXUge1xuICBjb25zdHJ1Y3RvcihlLCByLCBuLCBpKSB7XG4gICAgc3VwZXIoKSwgdGhpcy5ibG9ja0xlbiA9IGUsIHRoaXMub3V0cHV0TGVuID0gciwgdGhpcy5wYWRPZmZzZXQgPSBuLCB0aGlzLmlzTEUgPSBpLCB0aGlzLmZpbmlzaGVkID0gITEsIHRoaXMubGVuZ3RoID0gMCwgdGhpcy5wb3MgPSAwLCB0aGlzLmRlc3Ryb3llZCA9ICExLCB0aGlzLmJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGUpLCB0aGlzLnZpZXcgPSBjbih0aGlzLmJ1ZmZlcik7XG4gIH1cbiAgdXBkYXRlKGUpIHtcbiAgICB1bi5leGlzdHModGhpcyk7XG4gICAgY29uc3QgeyB2aWV3OiByLCBidWZmZXI6IG4sIGJsb2NrTGVuOiBpIH0gPSB0aGlzO1xuICAgIGUgPSB5cyhlKTtcbiAgICBjb25zdCBzID0gZS5sZW5ndGg7XG4gICAgZm9yIChsZXQgbyA9IDA7IG8gPCBzOyApIHtcbiAgICAgIGNvbnN0IGEgPSBNYXRoLm1pbihpIC0gdGhpcy5wb3MsIHMgLSBvKTtcbiAgICAgIGlmIChhID09PSBpKSB7XG4gICAgICAgIGNvbnN0IGMgPSBjbihlKTtcbiAgICAgICAgZm9yICg7IGkgPD0gcyAtIG87IG8gKz0gaSlcbiAgICAgICAgICB0aGlzLnByb2Nlc3MoYywgbyk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbi5zZXQoZS5zdWJhcnJheShvLCBvICsgYSksIHRoaXMucG9zKSwgdGhpcy5wb3MgKz0gYSwgbyArPSBhLCB0aGlzLnBvcyA9PT0gaSAmJiAodGhpcy5wcm9jZXNzKHIsIDApLCB0aGlzLnBvcyA9IDApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5sZW5ndGggKz0gZS5sZW5ndGgsIHRoaXMucm91bmRDbGVhbigpLCB0aGlzO1xuICB9XG4gIGRpZ2VzdEludG8oZSkge1xuICAgIHVuLmV4aXN0cyh0aGlzKSwgdW4ub3V0cHV0KGUsIHRoaXMpLCB0aGlzLmZpbmlzaGVkID0gITA7XG4gICAgY29uc3QgeyBidWZmZXI6IHIsIHZpZXc6IG4sIGJsb2NrTGVuOiBpLCBpc0xFOiBzIH0gPSB0aGlzO1xuICAgIGxldCB7IHBvczogbyB9ID0gdGhpcztcbiAgICByW28rK10gPSAxMjgsIHRoaXMuYnVmZmVyLnN1YmFycmF5KG8pLmZpbGwoMCksIHRoaXMucGFkT2Zmc2V0ID4gaSAtIG8gJiYgKHRoaXMucHJvY2VzcyhuLCAwKSwgbyA9IDApO1xuICAgIGZvciAobGV0IHUgPSBvOyB1IDwgaTsgdSsrKVxuICAgICAgclt1XSA9IDA7XG4gICAgQXUobiwgaSAtIDgsIEJpZ0ludCh0aGlzLmxlbmd0aCAqIDgpLCBzKSwgdGhpcy5wcm9jZXNzKG4sIDApO1xuICAgIGNvbnN0IGEgPSBjbihlKSwgYyA9IHRoaXMub3V0cHV0TGVuO1xuICAgIGlmIChjICUgNClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIl9zaGEyOiBvdXRwdXRMZW4gc2hvdWxkIGJlIGFsaWduZWQgdG8gMzJiaXRcIik7XG4gICAgY29uc3QgbCA9IGMgLyA0LCBmID0gdGhpcy5nZXQoKTtcbiAgICBpZiAobCA+IGYubGVuZ3RoKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiX3NoYTI6IG91dHB1dExlbiBiaWdnZXIgdGhhbiBzdGF0ZVwiKTtcbiAgICBmb3IgKGxldCB1ID0gMDsgdSA8IGw7IHUrKylcbiAgICAgIGEuc2V0VWludDMyKDQgKiB1LCBmW3VdLCBzKTtcbiAgfVxuICBkaWdlc3QoKSB7XG4gICAgY29uc3QgeyBidWZmZXI6IGUsIG91dHB1dExlbjogciB9ID0gdGhpcztcbiAgICB0aGlzLmRpZ2VzdEludG8oZSk7XG4gICAgY29uc3QgbiA9IGUuc2xpY2UoMCwgcik7XG4gICAgcmV0dXJuIHRoaXMuZGVzdHJveSgpLCBuO1xuICB9XG4gIF9jbG9uZUludG8oZSkge1xuICAgIGUgfHwgKGUgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpKSwgZS5zZXQoLi4udGhpcy5nZXQoKSk7XG4gICAgY29uc3QgeyBibG9ja0xlbjogciwgYnVmZmVyOiBuLCBsZW5ndGg6IGksIGZpbmlzaGVkOiBzLCBkZXN0cm95ZWQ6IG8sIHBvczogYSB9ID0gdGhpcztcbiAgICByZXR1cm4gZS5sZW5ndGggPSBpLCBlLnBvcyA9IGEsIGUuZmluaXNoZWQgPSBzLCBlLmRlc3Ryb3llZCA9IG8sIGkgJSByICYmIGUuYnVmZmVyLnNldChuKSwgZTtcbiAgfVxufVxuY29uc3QgSXUgPSAodCwgZSwgcikgPT4gdCAmIGUgXiB+dCAmIHIsIFJ1ID0gKHQsIGUsIHIpID0+IHQgJiBlIF4gdCAmIHIgXiBlICYgciwgVHUgPSBuZXcgVWludDMyQXJyYXkoW1xuICAxMTE2MzUyNDA4LFxuICAxODk5NDQ3NDQxLFxuICAzMDQ5MzIzNDcxLFxuICAzOTIxMDA5NTczLFxuICA5NjE5ODcxNjMsXG4gIDE1MDg5NzA5OTMsXG4gIDI0NTM2MzU3NDgsXG4gIDI4NzA3NjMyMjEsXG4gIDM2MjQzODEwODAsXG4gIDMxMDU5ODQwMSxcbiAgNjA3MjI1Mjc4LFxuICAxNDI2ODgxOTg3LFxuICAxOTI1MDc4Mzg4LFxuICAyMTYyMDc4MjA2LFxuICAyNjE0ODg4MTAzLFxuICAzMjQ4MjIyNTgwLFxuICAzODM1MzkwNDAxLFxuICA0MDIyMjI0Nzc0LFxuICAyNjQzNDcwNzgsXG4gIDYwNDgwNzYyOCxcbiAgNzcwMjU1OTgzLFxuICAxMjQ5MTUwMTIyLFxuICAxNTU1MDgxNjkyLFxuICAxOTk2MDY0OTg2LFxuICAyNTU0MjIwODgyLFxuICAyODIxODM0MzQ5LFxuICAyOTUyOTk2ODA4LFxuICAzMjEwMzEzNjcxLFxuICAzMzM2NTcxODkxLFxuICAzNTg0NTI4NzExLFxuICAxMTM5MjY5OTMsXG4gIDMzODI0MTg5NSxcbiAgNjY2MzA3MjA1LFxuICA3NzM1Mjk5MTIsXG4gIDEyOTQ3NTczNzIsXG4gIDEzOTYxODIyOTEsXG4gIDE2OTUxODM3MDAsXG4gIDE5ODY2NjEwNTEsXG4gIDIxNzcwMjYzNTAsXG4gIDI0NTY5NTYwMzcsXG4gIDI3MzA0ODU5MjEsXG4gIDI4MjAzMDI0MTEsXG4gIDMyNTk3MzA4MDAsXG4gIDMzNDU3NjQ3NzEsXG4gIDM1MTYwNjU4MTcsXG4gIDM2MDAzNTI4MDQsXG4gIDQwOTQ1NzE5MDksXG4gIDI3NTQyMzM0NCxcbiAgNDMwMjI3NzM0LFxuICA1MDY5NDg2MTYsXG4gIDY1OTA2MDU1NixcbiAgODgzOTk3ODc3LFxuICA5NTgxMzk1NzEsXG4gIDEzMjI4MjIyMTgsXG4gIDE1MzcwMDIwNjMsXG4gIDE3NDc4NzM3NzksXG4gIDE5NTU1NjIyMjIsXG4gIDIwMjQxMDQ4MTUsXG4gIDIyMjc3MzA0NTIsXG4gIDIzNjE4NTI0MjQsXG4gIDI0Mjg0MzY0NzQsXG4gIDI3NTY3MzQxODcsXG4gIDMyMDQwMzE0NzksXG4gIDMzMjkzMjUyOThcbl0pLCB6ZSA9IG5ldyBVaW50MzJBcnJheShbXG4gIDE3NzkwMzM3MDMsXG4gIDMxNDQxMzQyNzcsXG4gIDEwMTM5MDQyNDIsXG4gIDI3NzM0ODA3NjIsXG4gIDEzNTk4OTMxMTksXG4gIDI2MDA4MjI5MjQsXG4gIDUyODczNDYzNSxcbiAgMTU0MTQ1OTIyNVxuXSksIEZlID0gbmV3IFVpbnQzMkFycmF5KDY0KTtcbmNsYXNzIHZzIGV4dGVuZHMgQ3Uge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcig2NCwgMzIsIDgsICExKSwgdGhpcy5BID0gemVbMF0gfCAwLCB0aGlzLkIgPSB6ZVsxXSB8IDAsIHRoaXMuQyA9IHplWzJdIHwgMCwgdGhpcy5EID0gemVbM10gfCAwLCB0aGlzLkUgPSB6ZVs0XSB8IDAsIHRoaXMuRiA9IHplWzVdIHwgMCwgdGhpcy5HID0gemVbNl0gfCAwLCB0aGlzLkggPSB6ZVs3XSB8IDA7XG4gIH1cbiAgZ2V0KCkge1xuICAgIGNvbnN0IHsgQTogZSwgQjogciwgQzogbiwgRDogaSwgRTogcywgRjogbywgRzogYSwgSDogYyB9ID0gdGhpcztcbiAgICByZXR1cm4gW2UsIHIsIG4sIGksIHMsIG8sIGEsIGNdO1xuICB9XG4gIHNldChlLCByLCBuLCBpLCBzLCBvLCBhLCBjKSB7XG4gICAgdGhpcy5BID0gZSB8IDAsIHRoaXMuQiA9IHIgfCAwLCB0aGlzLkMgPSBuIHwgMCwgdGhpcy5EID0gaSB8IDAsIHRoaXMuRSA9IHMgfCAwLCB0aGlzLkYgPSBvIHwgMCwgdGhpcy5HID0gYSB8IDAsIHRoaXMuSCA9IGMgfCAwO1xuICB9XG4gIHByb2Nlc3MoZSwgcikge1xuICAgIGZvciAobGV0IHUgPSAwOyB1IDwgMTY7IHUrKywgciArPSA0KVxuICAgICAgRmVbdV0gPSBlLmdldFVpbnQzMihyLCAhMSk7XG4gICAgZm9yIChsZXQgdSA9IDE2OyB1IDwgNjQ7IHUrKykge1xuICAgICAgY29uc3QgaCA9IEZlW3UgLSAxNV0sIGQgPSBGZVt1IC0gMl0sIHAgPSBDZShoLCA3KSBeIENlKGgsIDE4KSBeIGggPj4+IDMsIHkgPSBDZShkLCAxNykgXiBDZShkLCAxOSkgXiBkID4+PiAxMDtcbiAgICAgIEZlW3VdID0geSArIEZlW3UgLSA3XSArIHAgKyBGZVt1IC0gMTZdIHwgMDtcbiAgICB9XG4gICAgbGV0IHsgQTogbiwgQjogaSwgQzogcywgRDogbywgRTogYSwgRjogYywgRzogbCwgSDogZiB9ID0gdGhpcztcbiAgICBmb3IgKGxldCB1ID0gMDsgdSA8IDY0OyB1KyspIHtcbiAgICAgIGNvbnN0IGggPSBDZShhLCA2KSBeIENlKGEsIDExKSBeIENlKGEsIDI1KSwgZCA9IGYgKyBoICsgSXUoYSwgYywgbCkgKyBUdVt1XSArIEZlW3VdIHwgMCwgeSA9IChDZShuLCAyKSBeIENlKG4sIDEzKSBeIENlKG4sIDIyKSkgKyBSdShuLCBpLCBzKSB8IDA7XG4gICAgICBmID0gbCwgbCA9IGMsIGMgPSBhLCBhID0gbyArIGQgfCAwLCBvID0gcywgcyA9IGksIGkgPSBuLCBuID0gZCArIHkgfCAwO1xuICAgIH1cbiAgICBuID0gbiArIHRoaXMuQSB8IDAsIGkgPSBpICsgdGhpcy5CIHwgMCwgcyA9IHMgKyB0aGlzLkMgfCAwLCBvID0gbyArIHRoaXMuRCB8IDAsIGEgPSBhICsgdGhpcy5FIHwgMCwgYyA9IGMgKyB0aGlzLkYgfCAwLCBsID0gbCArIHRoaXMuRyB8IDAsIGYgPSBmICsgdGhpcy5IIHwgMCwgdGhpcy5zZXQobiwgaSwgcywgbywgYSwgYywgbCwgZik7XG4gIH1cbiAgcm91bmRDbGVhbigpIHtcbiAgICBGZS5maWxsKDApO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCksIHRoaXMuYnVmZmVyLmZpbGwoMCk7XG4gIH1cbn1cbmNsYXNzIFB1IGV4dGVuZHMgdnMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpLCB0aGlzLkEgPSAtMTA1NjU5NjI2NCwgdGhpcy5CID0gOTE0MTUwNjYzLCB0aGlzLkMgPSA4MTI3MDI5OTksIHRoaXMuRCA9IC0xNTAwNTQ1OTksIHRoaXMuRSA9IC00MTkxNDM5LCB0aGlzLkYgPSAxNzUwNjAzMDI1LCB0aGlzLkcgPSAxNjk0MDc2ODM5LCB0aGlzLkggPSAtMTA5MDg5MTg2OCwgdGhpcy5vdXRwdXRMZW4gPSAyODtcbiAgfVxufVxuY29uc3QgWW4gPSBncygoKSA9PiBuZXcgdnMoKSk7XG5ncygoKSA9PiBuZXcgUHUoKSk7XG4vKiEgc2N1cmUtYmFzZSAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuZnVuY3Rpb24gcnQodCkge1xuICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKHQpKVxuICAgIHRocm93IG5ldyBFcnJvcihgV3JvbmcgaW50ZWdlcjogJHt0fWApO1xufVxuZnVuY3Rpb24gU2UoLi4udCkge1xuICBjb25zdCBlID0gKGksIHMpID0+IChvKSA9PiBpKHMobykpLCByID0gQXJyYXkuZnJvbSh0KS5yZXZlcnNlKCkucmVkdWNlKChpLCBzKSA9PiBpID8gZShpLCBzLmVuY29kZSkgOiBzLmVuY29kZSwgdm9pZCAwKSwgbiA9IHQucmVkdWNlKChpLCBzKSA9PiBpID8gZShpLCBzLmRlY29kZSkgOiBzLmRlY29kZSwgdm9pZCAwKTtcbiAgcmV0dXJuIHsgZW5jb2RlOiByLCBkZWNvZGU6IG4gfTtcbn1cbmZ1bmN0aW9uIFJlKHQpIHtcbiAgcmV0dXJuIHtcbiAgICBlbmNvZGU6IChlKSA9PiB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZSkgfHwgZS5sZW5ndGggJiYgdHlwZW9mIGVbMF0gIT0gXCJudW1iZXJcIilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWxwaGFiZXQuZW5jb2RlIGlucHV0IHNob3VsZCBiZSBhbiBhcnJheSBvZiBudW1iZXJzXCIpO1xuICAgICAgcmV0dXJuIGUubWFwKChyKSA9PiB7XG4gICAgICAgIGlmIChydChyKSwgciA8IDAgfHwgciA+PSB0Lmxlbmd0aClcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERpZ2l0IGluZGV4IG91dHNpZGUgYWxwaGFiZXQ6ICR7cn0gKGFscGhhYmV0OiAke3QubGVuZ3RofSlgKTtcbiAgICAgICAgcmV0dXJuIHRbcl07XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGRlY29kZTogKGUpID0+IHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShlKSB8fCBlLmxlbmd0aCAmJiB0eXBlb2YgZVswXSAhPSBcInN0cmluZ1wiKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhbHBoYWJldC5kZWNvZGUgaW5wdXQgc2hvdWxkIGJlIGFycmF5IG9mIHN0cmluZ3NcIik7XG4gICAgICByZXR1cm4gZS5tYXAoKHIpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiByICE9IFwic3RyaW5nXCIpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBhbHBoYWJldC5kZWNvZGU6IG5vdCBzdHJpbmcgZWxlbWVudD0ke3J9YCk7XG4gICAgICAgIGNvbnN0IG4gPSB0LmluZGV4T2Yocik7XG4gICAgICAgIGlmIChuID09PSAtMSlcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gbGV0dGVyOiBcIiR7cn1cIi4gQWxsb3dlZDogJHt0fWApO1xuICAgICAgICByZXR1cm4gbjtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIFRlKHQgPSBcIlwiKSB7XG4gIGlmICh0eXBlb2YgdCAhPSBcInN0cmluZ1wiKVxuICAgIHRocm93IG5ldyBFcnJvcihcImpvaW4gc2VwYXJhdG9yIHNob3VsZCBiZSBzdHJpbmdcIik7XG4gIHJldHVybiB7XG4gICAgZW5jb2RlOiAoZSkgPT4ge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGUpIHx8IGUubGVuZ3RoICYmIHR5cGVvZiBlWzBdICE9IFwic3RyaW5nXCIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImpvaW4uZW5jb2RlIGlucHV0IHNob3VsZCBiZSBhcnJheSBvZiBzdHJpbmdzXCIpO1xuICAgICAgZm9yIChsZXQgciBvZiBlKVxuICAgICAgICBpZiAodHlwZW9mIHIgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGpvaW4uZW5jb2RlOiBub24tc3RyaW5nIGlucHV0PSR7cn1gKTtcbiAgICAgIHJldHVybiBlLmpvaW4odCk7XG4gICAgfSxcbiAgICBkZWNvZGU6IChlKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGUgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiam9pbi5kZWNvZGUgaW5wdXQgc2hvdWxkIGJlIHN0cmluZ1wiKTtcbiAgICAgIHJldHVybiBlLnNwbGl0KHQpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHNyKHQsIGUgPSBcIj1cIikge1xuICBpZiAocnQodCksIHR5cGVvZiBlICE9IFwic3RyaW5nXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwicGFkZGluZyBjaHIgc2hvdWxkIGJlIHN0cmluZ1wiKTtcbiAgcmV0dXJuIHtcbiAgICBlbmNvZGUocikge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHIpIHx8IHIubGVuZ3RoICYmIHR5cGVvZiByWzBdICE9IFwic3RyaW5nXCIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInBhZGRpbmcuZW5jb2RlIGlucHV0IHNob3VsZCBiZSBhcnJheSBvZiBzdHJpbmdzXCIpO1xuICAgICAgZm9yIChsZXQgbiBvZiByKVxuICAgICAgICBpZiAodHlwZW9mIG4gIT0gXCJzdHJpbmdcIilcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHBhZGRpbmcuZW5jb2RlOiBub24tc3RyaW5nIGlucHV0PSR7bn1gKTtcbiAgICAgIGZvciAoOyByLmxlbmd0aCAqIHQgJSA4OyApXG4gICAgICAgIHIucHVzaChlKTtcbiAgICAgIHJldHVybiByO1xuICAgIH0sXG4gICAgZGVjb2RlKHIpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShyKSB8fCByLmxlbmd0aCAmJiB0eXBlb2YgclswXSAhPSBcInN0cmluZ1wiKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwYWRkaW5nLmVuY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2Ygc3RyaW5nc1wiKTtcbiAgICAgIGZvciAobGV0IGkgb2YgcilcbiAgICAgICAgaWYgKHR5cGVvZiBpICE9IFwic3RyaW5nXCIpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwYWRkaW5nLmRlY29kZTogbm9uLXN0cmluZyBpbnB1dD0ke2l9YCk7XG4gICAgICBsZXQgbiA9IHIubGVuZ3RoO1xuICAgICAgaWYgKG4gKiB0ICUgOClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwYWRkaW5nOiBzdHJpbmcgc2hvdWxkIGhhdmUgd2hvbGUgbnVtYmVyIG9mIGJ5dGVzXCIpO1xuICAgICAgZm9yICg7IG4gPiAwICYmIHJbbiAtIDFdID09PSBlOyBuLS0pXG4gICAgICAgIGlmICghKChuIC0gMSkgKiB0ICUgOCkpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwYWRkaW5nOiBzdHJpbmcgaGFzIHRvbyBtdWNoIHBhZGRpbmdcIik7XG4gICAgICByZXR1cm4gci5zbGljZSgwLCBuKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiB3cyh0KSB7XG4gIGlmICh0eXBlb2YgdCAhPSBcImZ1bmN0aW9uXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwibm9ybWFsaXplIGZuIHNob3VsZCBiZSBmdW5jdGlvblwiKTtcbiAgcmV0dXJuIHsgZW5jb2RlOiAoZSkgPT4gZSwgZGVjb2RlOiAoZSkgPT4gdChlKSB9O1xufVxuZnVuY3Rpb24gRmkodCwgZSwgcikge1xuICBpZiAoZSA8IDIpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXg6IHdyb25nIGZyb209JHtlfSwgYmFzZSBjYW5ub3QgYmUgbGVzcyB0aGFuIDJgKTtcbiAgaWYgKHIgPCAyKVxuICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4OiB3cm9uZyB0bz0ke3J9LCBiYXNlIGNhbm5vdCBiZSBsZXNzIHRoYW4gMmApO1xuICBpZiAoIUFycmF5LmlzQXJyYXkodCkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY29udmVydFJhZGl4OiBkYXRhIHNob3VsZCBiZSBhcnJheVwiKTtcbiAgaWYgKCF0Lmxlbmd0aClcbiAgICByZXR1cm4gW107XG4gIGxldCBuID0gMDtcbiAgY29uc3QgaSA9IFtdLCBzID0gQXJyYXkuZnJvbSh0KTtcbiAgZm9yIChzLmZvckVhY2goKG8pID0+IHtcbiAgICBpZiAocnQobyksIG8gPCAwIHx8IG8gPj0gZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgV3JvbmcgaW50ZWdlcjogJHtvfWApO1xuICB9KTsgOyApIHtcbiAgICBsZXQgbyA9IDAsIGEgPSAhMDtcbiAgICBmb3IgKGxldCBjID0gbjsgYyA8IHMubGVuZ3RoOyBjKyspIHtcbiAgICAgIGNvbnN0IGwgPSBzW2NdLCBmID0gZSAqIG8gKyBsO1xuICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihmKSB8fCBlICogbyAvIGUgIT09IG8gfHwgZiAtIGwgIT09IGUgKiBvKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb252ZXJ0UmFkaXg6IGNhcnJ5IG92ZXJmbG93XCIpO1xuICAgICAgaWYgKG8gPSBmICUgciwgc1tjXSA9IE1hdGguZmxvb3IoZiAvIHIpLCAhTnVtYmVyLmlzU2FmZUludGVnZXIoc1tjXSkgfHwgc1tjXSAqIHIgKyBvICE9PSBmKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb252ZXJ0UmFkaXg6IGNhcnJ5IG92ZXJmbG93XCIpO1xuICAgICAgaWYgKGEpXG4gICAgICAgIHNbY10gPyBhID0gITEgOiBuID0gYztcbiAgICAgIGVsc2VcbiAgICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChpLnB1c2gobyksIGEpXG4gICAgICBicmVhaztcbiAgfVxuICBmb3IgKGxldCBvID0gMDsgbyA8IHQubGVuZ3RoIC0gMSAmJiB0W29dID09PSAwOyBvKyspXG4gICAgaS5wdXNoKDApO1xuICByZXR1cm4gaS5yZXZlcnNlKCk7XG59XG5jb25zdCBfcyA9ICh0LCBlKSA9PiBlID8gX3MoZSwgdCAlIGUpIDogdCwgVHIgPSAodCwgZSkgPT4gdCArIChlIC0gX3ModCwgZSkpO1xuZnVuY3Rpb24gQm4odCwgZSwgciwgbikge1xuICBpZiAoIUFycmF5LmlzQXJyYXkodCkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY29udmVydFJhZGl4MjogZGF0YSBzaG91bGQgYmUgYXJyYXlcIik7XG4gIGlmIChlIDw9IDAgfHwgZSA+IDMyKVxuICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4Mjogd3JvbmcgZnJvbT0ke2V9YCk7XG4gIGlmIChyIDw9IDAgfHwgciA+IDMyKVxuICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4Mjogd3JvbmcgdG89JHtyfWApO1xuICBpZiAoVHIoZSwgcikgPiAzMilcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDI6IGNhcnJ5IG92ZXJmbG93IGZyb209JHtlfSB0bz0ke3J9IGNhcnJ5Qml0cz0ke1RyKGUsIHIpfWApO1xuICBsZXQgaSA9IDAsIHMgPSAwO1xuICBjb25zdCBvID0gMiAqKiByIC0gMSwgYSA9IFtdO1xuICBmb3IgKGNvbnN0IGMgb2YgdCkge1xuICAgIGlmIChydChjKSwgYyA+PSAyICoqIGUpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDI6IGludmFsaWQgZGF0YSB3b3JkPSR7Y30gZnJvbT0ke2V9YCk7XG4gICAgaWYgKGkgPSBpIDw8IGUgfCBjLCBzICsgZSA+IDMyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXgyOiBjYXJyeSBvdmVyZmxvdyBwb3M9JHtzfSBmcm9tPSR7ZX1gKTtcbiAgICBmb3IgKHMgKz0gZTsgcyA+PSByOyBzIC09IHIpXG4gICAgICBhLnB1c2goKGkgPj4gcyAtIHIgJiBvKSA+Pj4gMCk7XG4gICAgaSAmPSAyICoqIHMgLSAxO1xuICB9XG4gIGlmIChpID0gaSA8PCByIC0gcyAmIG8sICFuICYmIHMgPj0gZSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeGNlc3MgcGFkZGluZ1wiKTtcbiAgaWYgKCFuICYmIGkpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBOb24temVybyBwYWRkaW5nOiAke2l9YCk7XG4gIHJldHVybiBuICYmIHMgPiAwICYmIGEucHVzaChpID4+PiAwKSwgYTtcbn1cbmZ1bmN0aW9uIG1zKHQpIHtcbiAgcmV0dXJuIHJ0KHQpLCB7XG4gICAgZW5jb2RlOiAoZSkgPT4ge1xuICAgICAgaWYgKCEoZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyYWRpeC5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIFVpbnQ4QXJyYXlcIik7XG4gICAgICByZXR1cm4gRmkoQXJyYXkuZnJvbShlKSwgMiAqKiA4LCB0KTtcbiAgICB9LFxuICAgIGRlY29kZTogKGUpID0+IHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShlKSB8fCBlLmxlbmd0aCAmJiB0eXBlb2YgZVswXSAhPSBcIm51bWJlclwiKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyYWRpeC5kZWNvZGUgaW5wdXQgc2hvdWxkIGJlIGFycmF5IG9mIHN0cmluZ3NcIik7XG4gICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKEZpKGUsIHQsIDIgKiogOCkpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIE5lKHQsIGUgPSAhMSkge1xuICBpZiAocnQodCksIHQgPD0gMCB8fCB0ID4gMzIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwicmFkaXgyOiBiaXRzIHNob3VsZCBiZSBpbiAoMC4uMzJdXCIpO1xuICBpZiAoVHIoOCwgdCkgPiAzMiB8fCBUcih0LCA4KSA+IDMyKVxuICAgIHRocm93IG5ldyBFcnJvcihcInJhZGl4MjogY2Fycnkgb3ZlcmZsb3dcIik7XG4gIHJldHVybiB7XG4gICAgZW5jb2RlOiAocikgPT4ge1xuICAgICAgaWYgKCEociBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyYWRpeDIuZW5jb2RlIGlucHV0IHNob3VsZCBiZSBVaW50OEFycmF5XCIpO1xuICAgICAgcmV0dXJuIEJuKEFycmF5LmZyb20ociksIDgsIHQsICFlKTtcbiAgICB9LFxuICAgIGRlY29kZTogKHIpID0+IHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShyKSB8fCByLmxlbmd0aCAmJiB0eXBlb2YgclswXSAhPSBcIm51bWJlclwiKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyYWRpeDIuZGVjb2RlIGlucHV0IHNob3VsZCBiZSBhcnJheSBvZiBzdHJpbmdzXCIpO1xuICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShCbihyLCB0LCA4LCBlKSk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gS2kodCkge1xuICBpZiAodHlwZW9mIHQgIT0gXCJmdW5jdGlvblwiKVxuICAgIHRocm93IG5ldyBFcnJvcihcInVuc2FmZVdyYXBwZXIgZm4gc2hvdWxkIGJlIGZ1bmN0aW9uXCIpO1xuICByZXR1cm4gZnVuY3Rpb24oLi4uZSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdC5hcHBseShudWxsLCBlKTtcbiAgICB9IGNhdGNoIHtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiB4cyh0LCBlKSB7XG4gIGlmIChydCh0KSwgdHlwZW9mIGUgIT0gXCJmdW5jdGlvblwiKVxuICAgIHRocm93IG5ldyBFcnJvcihcImNoZWNrc3VtIGZuIHNob3VsZCBiZSBmdW5jdGlvblwiKTtcbiAgcmV0dXJuIHtcbiAgICBlbmNvZGUocikge1xuICAgICAgaWYgKCEociBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjaGVja3N1bS5lbmNvZGU6IGlucHV0IHNob3VsZCBiZSBVaW50OEFycmF5XCIpO1xuICAgICAgY29uc3QgbiA9IGUocikuc2xpY2UoMCwgdCksIGkgPSBuZXcgVWludDhBcnJheShyLmxlbmd0aCArIHQpO1xuICAgICAgcmV0dXJuIGkuc2V0KHIpLCBpLnNldChuLCByLmxlbmd0aCksIGk7XG4gICAgfSxcbiAgICBkZWNvZGUocikge1xuICAgICAgaWYgKCEociBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjaGVja3N1bS5kZWNvZGU6IGlucHV0IHNob3VsZCBiZSBVaW50OEFycmF5XCIpO1xuICAgICAgY29uc3QgbiA9IHIuc2xpY2UoMCwgLXQpLCBpID0gZShuKS5zbGljZSgwLCB0KSwgcyA9IHIuc2xpY2UoLXQpO1xuICAgICAgZm9yIChsZXQgbyA9IDA7IG8gPCB0OyBvKyspXG4gICAgICAgIGlmIChpW29dICE9PSBzW29dKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY2hlY2tzdW1cIik7XG4gICAgICByZXR1cm4gbjtcbiAgICB9XG4gIH07XG59XG5jb25zdCBCdSA9IHsgYWxwaGFiZXQ6IFJlLCBjaGFpbjogU2UsIGNoZWNrc3VtOiB4cywgcmFkaXg6IG1zLCByYWRpeDI6IE5lLCBqb2luOiBUZSwgcGFkZGluZzogc3IgfSwgRXMgPSBTZShOZSg0KSwgUmUoXCIwMTIzNDU2Nzg5QUJDREVGXCIpLCBUZShcIlwiKSksIGtzID0gU2UoTmUoNSksIFJlKFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVoyMzQ1NjdcIiksIHNyKDUpLCBUZShcIlwiKSksIEx1ID0gU2UoTmUoNSksIFJlKFwiMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZcIiksIHNyKDUpLCBUZShcIlwiKSksICR1ID0gU2UoTmUoNSksIFJlKFwiMDEyMzQ1Njc4OUFCQ0RFRkdISktNTlBRUlNUVldYWVpcIiksIFRlKFwiXCIpLCB3cygodCkgPT4gdC50b1VwcGVyQ2FzZSgpLnJlcGxhY2UoL08vZywgXCIwXCIpLnJlcGxhY2UoL1tJTF0vZywgXCIxXCIpKSksIG10ID0gU2UoTmUoNiksIFJlKFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiKSwgc3IoNiksIFRlKFwiXCIpKSwgU3MgPSBTZShOZSg2KSwgUmUoXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1fXCIpLCBzcig2KSwgVGUoXCJcIikpLCBKbiA9ICh0KSA9PiBTZShtcyg1OCksIFJlKHQpLCBUZShcIlwiKSksIG5yID0gSm4oXCIxMjM0NTY3ODlBQkNERUZHSEpLTE1OUFFSU1RVVldYWVphYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6XCIpLCBxdSA9IEpuKFwiMTIzNDU2Nzg5YWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5ekFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWlwiKSwgTnUgPSBKbihcInJwc2huYWYzOXdCVURORUdISktMTTRQUVJTVDdWV1hZWjJiY2RlQ2c2NWprbThvRnFpMXR1dkF4eXpcIiksIFdpID0gWzAsIDIsIDMsIDUsIDYsIDcsIDksIDEwLCAxMV0sIE9zID0ge1xuICBlbmNvZGUodCkge1xuICAgIGxldCBlID0gXCJcIjtcbiAgICBmb3IgKGxldCByID0gMDsgciA8IHQubGVuZ3RoOyByICs9IDgpIHtcbiAgICAgIGNvbnN0IG4gPSB0LnN1YmFycmF5KHIsIHIgKyA4KTtcbiAgICAgIGUgKz0gbnIuZW5jb2RlKG4pLnBhZFN0YXJ0KFdpW24ubGVuZ3RoXSwgXCIxXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZTtcbiAgfSxcbiAgZGVjb2RlKHQpIHtcbiAgICBsZXQgZSA9IFtdO1xuICAgIGZvciAobGV0IHIgPSAwOyByIDwgdC5sZW5ndGg7IHIgKz0gMTEpIHtcbiAgICAgIGNvbnN0IG4gPSB0LnNsaWNlKHIsIHIgKyAxMSksIGkgPSBXaS5pbmRleE9mKG4ubGVuZ3RoKSwgcyA9IG5yLmRlY29kZShuKTtcbiAgICAgIGZvciAobGV0IG8gPSAwOyBvIDwgcy5sZW5ndGggLSBpOyBvKyspXG4gICAgICAgIGlmIChzW29dICE9PSAwKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJhc2U1OHhtcjogd3JvbmcgcGFkZGluZ1wiKTtcbiAgICAgIGUgPSBlLmNvbmNhdChBcnJheS5mcm9tKHMuc2xpY2Uocy5sZW5ndGggLSBpKSkpO1xuICAgIH1cbiAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGUpO1xuICB9XG59LCBBcyA9ICh0KSA9PiBTZSh4cyg0LCAoZSkgPT4gdCh0KGUpKSksIG5yKSwgTG4gPSBTZShSZShcInFwenJ5OXg4Z2YydHZkdzBzM2puNTRraGNlNm11YTdsXCIpLCBUZShcIlwiKSksIFZpID0gWzk5NjgyNTAxMCwgNjQyODEzNTQ5LCA1MTM4NzQ0MjYsIDEwMjc3NDg4MjksIDcwNTk3OTA1OV07XG5mdW5jdGlvbiBJdCh0KSB7XG4gIGNvbnN0IGUgPSB0ID4+IDI1O1xuICBsZXQgciA9ICh0ICYgMzM1NTQ0MzEpIDw8IDU7XG4gIGZvciAobGV0IG4gPSAwOyBuIDwgVmkubGVuZ3RoOyBuKyspXG4gICAgKGUgPj4gbiAmIDEpID09PSAxICYmIChyIF49IFZpW25dKTtcbiAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiBHaSh0LCBlLCByID0gMSkge1xuICBjb25zdCBuID0gdC5sZW5ndGg7XG4gIGxldCBpID0gMTtcbiAgZm9yIChsZXQgcyA9IDA7IHMgPCBuOyBzKyspIHtcbiAgICBjb25zdCBvID0gdC5jaGFyQ29kZUF0KHMpO1xuICAgIGlmIChvIDwgMzMgfHwgbyA+IDEyNilcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwcmVmaXggKCR7dH0pYCk7XG4gICAgaSA9IEl0KGkpIF4gbyA+PiA1O1xuICB9XG4gIGkgPSBJdChpKTtcbiAgZm9yIChsZXQgcyA9IDA7IHMgPCBuOyBzKyspXG4gICAgaSA9IEl0KGkpIF4gdC5jaGFyQ29kZUF0KHMpICYgMzE7XG4gIGZvciAobGV0IHMgb2YgZSlcbiAgICBpID0gSXQoaSkgXiBzO1xuICBmb3IgKGxldCBzID0gMDsgcyA8IDY7IHMrKylcbiAgICBpID0gSXQoaSk7XG4gIHJldHVybiBpIF49IHIsIExuLmVuY29kZShCbihbaSAlIDIgKiogMzBdLCAzMCwgNSwgITEpKTtcbn1cbmZ1bmN0aW9uIENzKHQpIHtcbiAgY29uc3QgZSA9IHQgPT09IFwiYmVjaDMyXCIgPyAxIDogNzM0NTM5OTM5LCByID0gTmUoNSksIG4gPSByLmRlY29kZSwgaSA9IHIuZW5jb2RlLCBzID0gS2kobik7XG4gIGZ1bmN0aW9uIG8oZiwgdSwgaCA9IDkwKSB7XG4gICAgaWYgKHR5cGVvZiBmICE9IFwic3RyaW5nXCIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGJlY2gzMi5lbmNvZGUgcHJlZml4IHNob3VsZCBiZSBzdHJpbmcsIG5vdCAke3R5cGVvZiBmfWApO1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh1KSB8fCB1Lmxlbmd0aCAmJiB0eXBlb2YgdVswXSAhPSBcIm51bWJlclwiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBiZWNoMzIuZW5jb2RlIHdvcmRzIHNob3VsZCBiZSBhcnJheSBvZiBudW1iZXJzLCBub3QgJHt0eXBlb2YgdX1gKTtcbiAgICBjb25zdCBkID0gZi5sZW5ndGggKyA3ICsgdS5sZW5ndGg7XG4gICAgaWYgKGggIT09ICExICYmIGQgPiBoKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTGVuZ3RoICR7ZH0gZXhjZWVkcyBsaW1pdCAke2h9YCk7XG4gICAgcmV0dXJuIGYgPSBmLnRvTG93ZXJDYXNlKCksIGAke2Z9MSR7TG4uZW5jb2RlKHUpfSR7R2koZiwgdSwgZSl9YDtcbiAgfVxuICBmdW5jdGlvbiBhKGYsIHUgPSA5MCkge1xuICAgIGlmICh0eXBlb2YgZiAhPSBcInN0cmluZ1wiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBiZWNoMzIuZGVjb2RlIGlucHV0IHNob3VsZCBiZSBzdHJpbmcsIG5vdCAke3R5cGVvZiBmfWApO1xuICAgIGlmIChmLmxlbmd0aCA8IDggfHwgdSAhPT0gITEgJiYgZi5sZW5ndGggPiB1KVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgV3Jvbmcgc3RyaW5nIGxlbmd0aDogJHtmLmxlbmd0aH0gKCR7Zn0pLiBFeHBlY3RlZCAoOC4uJHt1fSlgKTtcbiAgICBjb25zdCBoID0gZi50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChmICE9PSBoICYmIGYgIT09IGYudG9VcHBlckNhc2UoKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0cmluZyBtdXN0IGJlIGxvd2VyY2FzZSBvciB1cHBlcmNhc2VcIik7XG4gICAgZiA9IGg7XG4gICAgY29uc3QgZCA9IGYubGFzdEluZGV4T2YoXCIxXCIpO1xuICAgIGlmIChkID09PSAwIHx8IGQgPT09IC0xKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdMZXR0ZXIgXCIxXCIgbXVzdCBiZSBwcmVzZW50IGJldHdlZW4gcHJlZml4IGFuZCBkYXRhIG9ubHknKTtcbiAgICBjb25zdCBwID0gZi5zbGljZSgwLCBkKSwgeSA9IGYuc2xpY2UoZCArIDEpO1xuICAgIGlmICh5Lmxlbmd0aCA8IDYpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhIG11c3QgYmUgYXQgbGVhc3QgNiBjaGFyYWN0ZXJzIGxvbmdcIik7XG4gICAgY29uc3QgZyA9IExuLmRlY29kZSh5KS5zbGljZSgwLCAtNiksIHYgPSBHaShwLCBnLCBlKTtcbiAgICBpZiAoIXkuZW5kc1dpdGgodikpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY2hlY2tzdW0gaW4gJHtmfTogZXhwZWN0ZWQgXCIke3Z9XCJgKTtcbiAgICByZXR1cm4geyBwcmVmaXg6IHAsIHdvcmRzOiBnIH07XG4gIH1cbiAgY29uc3QgYyA9IEtpKGEpO1xuICBmdW5jdGlvbiBsKGYpIHtcbiAgICBjb25zdCB7IHByZWZpeDogdSwgd29yZHM6IGggfSA9IGEoZiwgITEpO1xuICAgIHJldHVybiB7IHByZWZpeDogdSwgd29yZHM6IGgsIGJ5dGVzOiBuKGgpIH07XG4gIH1cbiAgcmV0dXJuIHsgZW5jb2RlOiBvLCBkZWNvZGU6IGEsIGRlY29kZVRvQnl0ZXM6IGwsIGRlY29kZVVuc2FmZTogYywgZnJvbVdvcmRzOiBuLCBmcm9tV29yZHNVbnNhZmU6IHMsIHRvV29yZHM6IGkgfTtcbn1cbmNvbnN0IHRlID0gQ3MoXCJiZWNoMzJcIiksIFV1ID0gQ3MoXCJiZWNoMzJtXCIpLCBJcyA9IHtcbiAgZW5jb2RlOiAodCkgPT4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKHQpLFxuICBkZWNvZGU6ICh0KSA9PiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUodClcbn0sIFJzID0gU2UoTmUoNCksIFJlKFwiMDEyMzQ1Njc4OWFiY2RlZlwiKSwgVGUoXCJcIiksIHdzKCh0KSA9PiB7XG4gIGlmICh0eXBlb2YgdCAhPSBcInN0cmluZ1wiIHx8IHQubGVuZ3RoICUgMilcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBoZXguZGVjb2RlOiBleHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiB0fSB3aXRoIGxlbmd0aCAke3QubGVuZ3RofWApO1xuICByZXR1cm4gdC50b0xvd2VyQ2FzZSgpO1xufSkpLCBpciA9IHtcbiAgdXRmODogSXMsXG4gIGhleDogUnMsXG4gIGJhc2UxNjogRXMsXG4gIGJhc2UzMjoga3MsXG4gIGJhc2U2NDogbXQsXG4gIGJhc2U2NHVybDogU3MsXG4gIGJhc2U1ODogbnIsXG4gIGJhc2U1OHhtcjogT3Ncbn0sIFRzID0gYEludmFsaWQgZW5jb2RpbmcgdHlwZS4gQXZhaWxhYmxlIHR5cGVzOiAke09iamVjdC5rZXlzKGlyKS5qb2luKFwiLCBcIil9YCwgUHMgPSAodCwgZSkgPT4ge1xuICBpZiAodHlwZW9mIHQgIT0gXCJzdHJpbmdcIiB8fCAhaXIuaGFzT3duUHJvcGVydHkodCkpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihUcyk7XG4gIGlmICghKGUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYnl0ZXNUb1N0cmluZygpIGV4cGVjdHMgVWludDhBcnJheVwiKTtcbiAgcmV0dXJuIGlyW3RdLmVuY29kZShlKTtcbn0sIGp1ID0gUHMsIEJzID0gKHQsIGUpID0+IHtcbiAgaWYgKCFpci5oYXNPd25Qcm9wZXJ0eSh0KSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFRzKTtcbiAgaWYgKHR5cGVvZiBlICE9IFwic3RyaW5nXCIpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInN0cmluZ1RvQnl0ZXMoKSBleHBlY3RzIHN0cmluZ1wiKTtcbiAgcmV0dXJuIGlyW3RdLmRlY29kZShlKTtcbn0sIEh1ID0gQnMsIE11ID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoLyogQF9fUFVSRV9fICovIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgYXNzZXJ0TnVtYmVyOiBydCxcbiAgdXRpbHM6IEJ1LFxuICBiYXNlMTY6IEVzLFxuICBiYXNlMzI6IGtzLFxuICBiYXNlMzJoZXg6IEx1LFxuICBiYXNlMzJjcm9ja2ZvcmQ6ICR1LFxuICBiYXNlNjQ6IG10LFxuICBiYXNlNjR1cmw6IFNzLFxuICBiYXNlNTg6IG5yLFxuICBiYXNlNThmbGlja3I6IHF1LFxuICBiYXNlNTh4cnA6IE51LFxuICBiYXNlNTh4bXI6IE9zLFxuICBiYXNlNThjaGVjazogQXMsXG4gIGJlY2gzMjogdGUsXG4gIGJlY2gzMm06IFV1LFxuICB1dGY4OiBJcyxcbiAgaGV4OiBScyxcbiAgYnl0ZXNUb1N0cmluZzogUHMsXG4gIHN0cjoganUsXG4gIHN0cmluZ1RvQnl0ZXM6IEJzLFxuICBieXRlczogSHVcbn0sIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KSk7XG52YXIgWG4gPSB7fTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShYbiwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xudmFyIFFuID0gWG4ud29yZGxpc3QgPSB2b2lkIDA7XG5RbiA9IFhuLndvcmRsaXN0ID0gYGFiYW5kb25cbmFiaWxpdHlcbmFibGVcbmFib3V0XG5hYm92ZVxuYWJzZW50XG5hYnNvcmJcbmFic3RyYWN0XG5hYnN1cmRcbmFidXNlXG5hY2Nlc3NcbmFjY2lkZW50XG5hY2NvdW50XG5hY2N1c2VcbmFjaGlldmVcbmFjaWRcbmFjb3VzdGljXG5hY3F1aXJlXG5hY3Jvc3NcbmFjdFxuYWN0aW9uXG5hY3RvclxuYWN0cmVzc1xuYWN0dWFsXG5hZGFwdFxuYWRkXG5hZGRpY3RcbmFkZHJlc3NcbmFkanVzdFxuYWRtaXRcbmFkdWx0XG5hZHZhbmNlXG5hZHZpY2VcbmFlcm9iaWNcbmFmZmFpclxuYWZmb3JkXG5hZnJhaWRcbmFnYWluXG5hZ2VcbmFnZW50XG5hZ3JlZVxuYWhlYWRcbmFpbVxuYWlyXG5haXJwb3J0XG5haXNsZVxuYWxhcm1cbmFsYnVtXG5hbGNvaG9sXG5hbGVydFxuYWxpZW5cbmFsbFxuYWxsZXlcbmFsbG93XG5hbG1vc3RcbmFsb25lXG5hbHBoYVxuYWxyZWFkeVxuYWxzb1xuYWx0ZXJcbmFsd2F5c1xuYW1hdGV1clxuYW1hemluZ1xuYW1vbmdcbmFtb3VudFxuYW11c2VkXG5hbmFseXN0XG5hbmNob3JcbmFuY2llbnRcbmFuZ2VyXG5hbmdsZVxuYW5ncnlcbmFuaW1hbFxuYW5rbGVcbmFubm91bmNlXG5hbm51YWxcbmFub3RoZXJcbmFuc3dlclxuYW50ZW5uYVxuYW50aXF1ZVxuYW54aWV0eVxuYW55XG5hcGFydFxuYXBvbG9neVxuYXBwZWFyXG5hcHBsZVxuYXBwcm92ZVxuYXByaWxcbmFyY2hcbmFyY3RpY1xuYXJlYVxuYXJlbmFcbmFyZ3VlXG5hcm1cbmFybWVkXG5hcm1vclxuYXJteVxuYXJvdW5kXG5hcnJhbmdlXG5hcnJlc3RcbmFycml2ZVxuYXJyb3dcbmFydFxuYXJ0ZWZhY3RcbmFydGlzdFxuYXJ0d29ya1xuYXNrXG5hc3BlY3RcbmFzc2F1bHRcbmFzc2V0XG5hc3Npc3RcbmFzc3VtZVxuYXN0aG1hXG5hdGhsZXRlXG5hdG9tXG5hdHRhY2tcbmF0dGVuZFxuYXR0aXR1ZGVcbmF0dHJhY3RcbmF1Y3Rpb25cbmF1ZGl0XG5hdWd1c3RcbmF1bnRcbmF1dGhvclxuYXV0b1xuYXV0dW1uXG5hdmVyYWdlXG5hdm9jYWRvXG5hdm9pZFxuYXdha2VcbmF3YXJlXG5hd2F5XG5hd2Vzb21lXG5hd2Z1bFxuYXdrd2FyZFxuYXhpc1xuYmFieVxuYmFjaGVsb3JcbmJhY29uXG5iYWRnZVxuYmFnXG5iYWxhbmNlXG5iYWxjb255XG5iYWxsXG5iYW1ib29cbmJhbmFuYVxuYmFubmVyXG5iYXJcbmJhcmVseVxuYmFyZ2FpblxuYmFycmVsXG5iYXNlXG5iYXNpY1xuYmFza2V0XG5iYXR0bGVcbmJlYWNoXG5iZWFuXG5iZWF1dHlcbmJlY2F1c2VcbmJlY29tZVxuYmVlZlxuYmVmb3JlXG5iZWdpblxuYmVoYXZlXG5iZWhpbmRcbmJlbGlldmVcbmJlbG93XG5iZWx0XG5iZW5jaFxuYmVuZWZpdFxuYmVzdFxuYmV0cmF5XG5iZXR0ZXJcbmJldHdlZW5cbmJleW9uZFxuYmljeWNsZVxuYmlkXG5iaWtlXG5iaW5kXG5iaW9sb2d5XG5iaXJkXG5iaXJ0aFxuYml0dGVyXG5ibGFja1xuYmxhZGVcbmJsYW1lXG5ibGFua2V0XG5ibGFzdFxuYmxlYWtcbmJsZXNzXG5ibGluZFxuYmxvb2RcbmJsb3Nzb21cbmJsb3VzZVxuYmx1ZVxuYmx1clxuYmx1c2hcbmJvYXJkXG5ib2F0XG5ib2R5XG5ib2lsXG5ib21iXG5ib25lXG5ib251c1xuYm9va1xuYm9vc3RcbmJvcmRlclxuYm9yaW5nXG5ib3Jyb3dcbmJvc3NcbmJvdHRvbVxuYm91bmNlXG5ib3hcbmJveVxuYnJhY2tldFxuYnJhaW5cbmJyYW5kXG5icmFzc1xuYnJhdmVcbmJyZWFkXG5icmVlemVcbmJyaWNrXG5icmlkZ2VcbmJyaWVmXG5icmlnaHRcbmJyaW5nXG5icmlza1xuYnJvY2NvbGlcbmJyb2tlblxuYnJvbnplXG5icm9vbVxuYnJvdGhlclxuYnJvd25cbmJydXNoXG5idWJibGVcbmJ1ZGR5XG5idWRnZXRcbmJ1ZmZhbG9cbmJ1aWxkXG5idWxiXG5idWxrXG5idWxsZXRcbmJ1bmRsZVxuYnVua2VyXG5idXJkZW5cbmJ1cmdlclxuYnVyc3RcbmJ1c1xuYnVzaW5lc3NcbmJ1c3lcbmJ1dHRlclxuYnV5ZXJcbmJ1enpcbmNhYmJhZ2VcbmNhYmluXG5jYWJsZVxuY2FjdHVzXG5jYWdlXG5jYWtlXG5jYWxsXG5jYWxtXG5jYW1lcmFcbmNhbXBcbmNhblxuY2FuYWxcbmNhbmNlbFxuY2FuZHlcbmNhbm5vblxuY2Fub2VcbmNhbnZhc1xuY2FueW9uXG5jYXBhYmxlXG5jYXBpdGFsXG5jYXB0YWluXG5jYXJcbmNhcmJvblxuY2FyZFxuY2FyZ29cbmNhcnBldFxuY2FycnlcbmNhcnRcbmNhc2VcbmNhc2hcbmNhc2lub1xuY2FzdGxlXG5jYXN1YWxcbmNhdFxuY2F0YWxvZ1xuY2F0Y2hcbmNhdGVnb3J5XG5jYXR0bGVcbmNhdWdodFxuY2F1c2VcbmNhdXRpb25cbmNhdmVcbmNlaWxpbmdcbmNlbGVyeVxuY2VtZW50XG5jZW5zdXNcbmNlbnR1cnlcbmNlcmVhbFxuY2VydGFpblxuY2hhaXJcbmNoYWxrXG5jaGFtcGlvblxuY2hhbmdlXG5jaGFvc1xuY2hhcHRlclxuY2hhcmdlXG5jaGFzZVxuY2hhdFxuY2hlYXBcbmNoZWNrXG5jaGVlc2VcbmNoZWZcbmNoZXJyeVxuY2hlc3RcbmNoaWNrZW5cbmNoaWVmXG5jaGlsZFxuY2hpbW5leVxuY2hvaWNlXG5jaG9vc2VcbmNocm9uaWNcbmNodWNrbGVcbmNodW5rXG5jaHVyblxuY2lnYXJcbmNpbm5hbW9uXG5jaXJjbGVcbmNpdGl6ZW5cbmNpdHlcbmNpdmlsXG5jbGFpbVxuY2xhcFxuY2xhcmlmeVxuY2xhd1xuY2xheVxuY2xlYW5cbmNsZXJrXG5jbGV2ZXJcbmNsaWNrXG5jbGllbnRcbmNsaWZmXG5jbGltYlxuY2xpbmljXG5jbGlwXG5jbG9ja1xuY2xvZ1xuY2xvc2VcbmNsb3RoXG5jbG91ZFxuY2xvd25cbmNsdWJcbmNsdW1wXG5jbHVzdGVyXG5jbHV0Y2hcbmNvYWNoXG5jb2FzdFxuY29jb251dFxuY29kZVxuY29mZmVlXG5jb2lsXG5jb2luXG5jb2xsZWN0XG5jb2xvclxuY29sdW1uXG5jb21iaW5lXG5jb21lXG5jb21mb3J0XG5jb21pY1xuY29tbW9uXG5jb21wYW55XG5jb25jZXJ0XG5jb25kdWN0XG5jb25maXJtXG5jb25ncmVzc1xuY29ubmVjdFxuY29uc2lkZXJcbmNvbnRyb2xcbmNvbnZpbmNlXG5jb29rXG5jb29sXG5jb3BwZXJcbmNvcHlcbmNvcmFsXG5jb3JlXG5jb3JuXG5jb3JyZWN0XG5jb3N0XG5jb3R0b25cbmNvdWNoXG5jb3VudHJ5XG5jb3VwbGVcbmNvdXJzZVxuY291c2luXG5jb3ZlclxuY295b3RlXG5jcmFja1xuY3JhZGxlXG5jcmFmdFxuY3JhbVxuY3JhbmVcbmNyYXNoXG5jcmF0ZXJcbmNyYXdsXG5jcmF6eVxuY3JlYW1cbmNyZWRpdFxuY3JlZWtcbmNyZXdcbmNyaWNrZXRcbmNyaW1lXG5jcmlzcFxuY3JpdGljXG5jcm9wXG5jcm9zc1xuY3JvdWNoXG5jcm93ZFxuY3J1Y2lhbFxuY3J1ZWxcbmNydWlzZVxuY3J1bWJsZVxuY3J1bmNoXG5jcnVzaFxuY3J5XG5jcnlzdGFsXG5jdWJlXG5jdWx0dXJlXG5jdXBcbmN1cGJvYXJkXG5jdXJpb3VzXG5jdXJyZW50XG5jdXJ0YWluXG5jdXJ2ZVxuY3VzaGlvblxuY3VzdG9tXG5jdXRlXG5jeWNsZVxuZGFkXG5kYW1hZ2VcbmRhbXBcbmRhbmNlXG5kYW5nZXJcbmRhcmluZ1xuZGFzaFxuZGF1Z2h0ZXJcbmRhd25cbmRheVxuZGVhbFxuZGViYXRlXG5kZWJyaXNcbmRlY2FkZVxuZGVjZW1iZXJcbmRlY2lkZVxuZGVjbGluZVxuZGVjb3JhdGVcbmRlY3JlYXNlXG5kZWVyXG5kZWZlbnNlXG5kZWZpbmVcbmRlZnlcbmRlZ3JlZVxuZGVsYXlcbmRlbGl2ZXJcbmRlbWFuZFxuZGVtaXNlXG5kZW5pYWxcbmRlbnRpc3RcbmRlbnlcbmRlcGFydFxuZGVwZW5kXG5kZXBvc2l0XG5kZXB0aFxuZGVwdXR5XG5kZXJpdmVcbmRlc2NyaWJlXG5kZXNlcnRcbmRlc2lnblxuZGVza1xuZGVzcGFpclxuZGVzdHJveVxuZGV0YWlsXG5kZXRlY3RcbmRldmVsb3BcbmRldmljZVxuZGV2b3RlXG5kaWFncmFtXG5kaWFsXG5kaWFtb25kXG5kaWFyeVxuZGljZVxuZGllc2VsXG5kaWV0XG5kaWZmZXJcbmRpZ2l0YWxcbmRpZ25pdHlcbmRpbGVtbWFcbmRpbm5lclxuZGlub3NhdXJcbmRpcmVjdFxuZGlydFxuZGlzYWdyZWVcbmRpc2NvdmVyXG5kaXNlYXNlXG5kaXNoXG5kaXNtaXNzXG5kaXNvcmRlclxuZGlzcGxheVxuZGlzdGFuY2VcbmRpdmVydFxuZGl2aWRlXG5kaXZvcmNlXG5kaXp6eVxuZG9jdG9yXG5kb2N1bWVudFxuZG9nXG5kb2xsXG5kb2xwaGluXG5kb21haW5cbmRvbmF0ZVxuZG9ua2V5XG5kb25vclxuZG9vclxuZG9zZVxuZG91YmxlXG5kb3ZlXG5kcmFmdFxuZHJhZ29uXG5kcmFtYVxuZHJhc3RpY1xuZHJhd1xuZHJlYW1cbmRyZXNzXG5kcmlmdFxuZHJpbGxcbmRyaW5rXG5kcmlwXG5kcml2ZVxuZHJvcFxuZHJ1bVxuZHJ5XG5kdWNrXG5kdW1iXG5kdW5lXG5kdXJpbmdcbmR1c3RcbmR1dGNoXG5kdXR5XG5kd2FyZlxuZHluYW1pY1xuZWFnZXJcbmVhZ2xlXG5lYXJseVxuZWFyblxuZWFydGhcbmVhc2lseVxuZWFzdFxuZWFzeVxuZWNob1xuZWNvbG9neVxuZWNvbm9teVxuZWRnZVxuZWRpdFxuZWR1Y2F0ZVxuZWZmb3J0XG5lZ2dcbmVpZ2h0XG5laXRoZXJcbmVsYm93XG5lbGRlclxuZWxlY3RyaWNcbmVsZWdhbnRcbmVsZW1lbnRcbmVsZXBoYW50XG5lbGV2YXRvclxuZWxpdGVcbmVsc2VcbmVtYmFya1xuZW1ib2R5XG5lbWJyYWNlXG5lbWVyZ2VcbmVtb3Rpb25cbmVtcGxveVxuZW1wb3dlclxuZW1wdHlcbmVuYWJsZVxuZW5hY3RcbmVuZFxuZW5kbGVzc1xuZW5kb3JzZVxuZW5lbXlcbmVuZXJneVxuZW5mb3JjZVxuZW5nYWdlXG5lbmdpbmVcbmVuaGFuY2VcbmVuam95XG5lbmxpc3RcbmVub3VnaFxuZW5yaWNoXG5lbnJvbGxcbmVuc3VyZVxuZW50ZXJcbmVudGlyZVxuZW50cnlcbmVudmVsb3BlXG5lcGlzb2RlXG5lcXVhbFxuZXF1aXBcbmVyYVxuZXJhc2VcbmVyb2RlXG5lcm9zaW9uXG5lcnJvclxuZXJ1cHRcbmVzY2FwZVxuZXNzYXlcbmVzc2VuY2VcbmVzdGF0ZVxuZXRlcm5hbFxuZXRoaWNzXG5ldmlkZW5jZVxuZXZpbFxuZXZva2VcbmV2b2x2ZVxuZXhhY3RcbmV4YW1wbGVcbmV4Y2Vzc1xuZXhjaGFuZ2VcbmV4Y2l0ZVxuZXhjbHVkZVxuZXhjdXNlXG5leGVjdXRlXG5leGVyY2lzZVxuZXhoYXVzdFxuZXhoaWJpdFxuZXhpbGVcbmV4aXN0XG5leGl0XG5leG90aWNcbmV4cGFuZFxuZXhwZWN0XG5leHBpcmVcbmV4cGxhaW5cbmV4cG9zZVxuZXhwcmVzc1xuZXh0ZW5kXG5leHRyYVxuZXllXG5leWVicm93XG5mYWJyaWNcbmZhY2VcbmZhY3VsdHlcbmZhZGVcbmZhaW50XG5mYWl0aFxuZmFsbFxuZmFsc2VcbmZhbWVcbmZhbWlseVxuZmFtb3VzXG5mYW5cbmZhbmN5XG5mYW50YXN5XG5mYXJtXG5mYXNoaW9uXG5mYXRcbmZhdGFsXG5mYXRoZXJcbmZhdGlndWVcbmZhdWx0XG5mYXZvcml0ZVxuZmVhdHVyZVxuZmVicnVhcnlcbmZlZGVyYWxcbmZlZVxuZmVlZFxuZmVlbFxuZmVtYWxlXG5mZW5jZVxuZmVzdGl2YWxcbmZldGNoXG5mZXZlclxuZmV3XG5maWJlclxuZmljdGlvblxuZmllbGRcbmZpZ3VyZVxuZmlsZVxuZmlsbVxuZmlsdGVyXG5maW5hbFxuZmluZFxuZmluZVxuZmluZ2VyXG5maW5pc2hcbmZpcmVcbmZpcm1cbmZpcnN0XG5maXNjYWxcbmZpc2hcbmZpdFxuZml0bmVzc1xuZml4XG5mbGFnXG5mbGFtZVxuZmxhc2hcbmZsYXRcbmZsYXZvclxuZmxlZVxuZmxpZ2h0XG5mbGlwXG5mbG9hdFxuZmxvY2tcbmZsb29yXG5mbG93ZXJcbmZsdWlkXG5mbHVzaFxuZmx5XG5mb2FtXG5mb2N1c1xuZm9nXG5mb2lsXG5mb2xkXG5mb2xsb3dcbmZvb2RcbmZvb3RcbmZvcmNlXG5mb3Jlc3RcbmZvcmdldFxuZm9ya1xuZm9ydHVuZVxuZm9ydW1cbmZvcndhcmRcbmZvc3NpbFxuZm9zdGVyXG5mb3VuZFxuZm94XG5mcmFnaWxlXG5mcmFtZVxuZnJlcXVlbnRcbmZyZXNoXG5mcmllbmRcbmZyaW5nZVxuZnJvZ1xuZnJvbnRcbmZyb3N0XG5mcm93blxuZnJvemVuXG5mcnVpdFxuZnVlbFxuZnVuXG5mdW5ueVxuZnVybmFjZVxuZnVyeVxuZnV0dXJlXG5nYWRnZXRcbmdhaW5cbmdhbGF4eVxuZ2FsbGVyeVxuZ2FtZVxuZ2FwXG5nYXJhZ2VcbmdhcmJhZ2VcbmdhcmRlblxuZ2FybGljXG5nYXJtZW50XG5nYXNcbmdhc3BcbmdhdGVcbmdhdGhlclxuZ2F1Z2VcbmdhemVcbmdlbmVyYWxcbmdlbml1c1xuZ2VucmVcbmdlbnRsZVxuZ2VudWluZVxuZ2VzdHVyZVxuZ2hvc3RcbmdpYW50XG5naWZ0XG5naWdnbGVcbmdpbmdlclxuZ2lyYWZmZVxuZ2lybFxuZ2l2ZVxuZ2xhZFxuZ2xhbmNlXG5nbGFyZVxuZ2xhc3NcbmdsaWRlXG5nbGltcHNlXG5nbG9iZVxuZ2xvb21cbmdsb3J5XG5nbG92ZVxuZ2xvd1xuZ2x1ZVxuZ29hdFxuZ29kZGVzc1xuZ29sZFxuZ29vZFxuZ29vc2VcbmdvcmlsbGFcbmdvc3BlbFxuZ29zc2lwXG5nb3Zlcm5cbmdvd25cbmdyYWJcbmdyYWNlXG5ncmFpblxuZ3JhbnRcbmdyYXBlXG5ncmFzc1xuZ3Jhdml0eVxuZ3JlYXRcbmdyZWVuXG5ncmlkXG5ncmllZlxuZ3JpdFxuZ3JvY2VyeVxuZ3JvdXBcbmdyb3dcbmdydW50XG5ndWFyZFxuZ3Vlc3Ncbmd1aWRlXG5ndWlsdFxuZ3VpdGFyXG5ndW5cbmd5bVxuaGFiaXRcbmhhaXJcbmhhbGZcbmhhbW1lclxuaGFtc3RlclxuaGFuZFxuaGFwcHlcbmhhcmJvclxuaGFyZFxuaGFyc2hcbmhhcnZlc3RcbmhhdFxuaGF2ZVxuaGF3a1xuaGF6YXJkXG5oZWFkXG5oZWFsdGhcbmhlYXJ0XG5oZWF2eVxuaGVkZ2Vob2dcbmhlaWdodFxuaGVsbG9cbmhlbG1ldFxuaGVscFxuaGVuXG5oZXJvXG5oaWRkZW5cbmhpZ2hcbmhpbGxcbmhpbnRcbmhpcFxuaGlyZVxuaGlzdG9yeVxuaG9iYnlcbmhvY2tleVxuaG9sZFxuaG9sZVxuaG9saWRheVxuaG9sbG93XG5ob21lXG5ob25leVxuaG9vZFxuaG9wZVxuaG9yblxuaG9ycm9yXG5ob3JzZVxuaG9zcGl0YWxcbmhvc3RcbmhvdGVsXG5ob3VyXG5ob3ZlclxuaHViXG5odWdlXG5odW1hblxuaHVtYmxlXG5odW1vclxuaHVuZHJlZFxuaHVuZ3J5XG5odW50XG5odXJkbGVcbmh1cnJ5XG5odXJ0XG5odXNiYW5kXG5oeWJyaWRcbmljZVxuaWNvblxuaWRlYVxuaWRlbnRpZnlcbmlkbGVcbmlnbm9yZVxuaWxsXG5pbGxlZ2FsXG5pbGxuZXNzXG5pbWFnZVxuaW1pdGF0ZVxuaW1tZW5zZVxuaW1tdW5lXG5pbXBhY3RcbmltcG9zZVxuaW1wcm92ZVxuaW1wdWxzZVxuaW5jaFxuaW5jbHVkZVxuaW5jb21lXG5pbmNyZWFzZVxuaW5kZXhcbmluZGljYXRlXG5pbmRvb3JcbmluZHVzdHJ5XG5pbmZhbnRcbmluZmxpY3RcbmluZm9ybVxuaW5oYWxlXG5pbmhlcml0XG5pbml0aWFsXG5pbmplY3RcbmluanVyeVxuaW5tYXRlXG5pbm5lclxuaW5ub2NlbnRcbmlucHV0XG5pbnF1aXJ5XG5pbnNhbmVcbmluc2VjdFxuaW5zaWRlXG5pbnNwaXJlXG5pbnN0YWxsXG5pbnRhY3RcbmludGVyZXN0XG5pbnRvXG5pbnZlc3Rcbmludml0ZVxuaW52b2x2ZVxuaXJvblxuaXNsYW5kXG5pc29sYXRlXG5pc3N1ZVxuaXRlbVxuaXZvcnlcbmphY2tldFxuamFndWFyXG5qYXJcbmphenpcbmplYWxvdXNcbmplYW5zXG5qZWxseVxuamV3ZWxcbmpvYlxuam9pblxuam9rZVxuam91cm5leVxuam95XG5qdWRnZVxuanVpY2Vcbmp1bXBcbmp1bmdsZVxuanVuaW9yXG5qdW5rXG5qdXN0XG5rYW5nYXJvb1xua2Vlblxua2VlcFxua2V0Y2h1cFxua2V5XG5raWNrXG5raWRcbmtpZG5leVxua2luZFxua2luZ2RvbVxua2lzc1xua2l0XG5raXRjaGVuXG5raXRlXG5raXR0ZW5cbmtpd2lcbmtuZWVcbmtuaWZlXG5rbm9ja1xua25vd1xubGFiXG5sYWJlbFxubGFib3JcbmxhZGRlclxubGFkeVxubGFrZVxubGFtcFxubGFuZ3VhZ2VcbmxhcHRvcFxubGFyZ2VcbmxhdGVyXG5sYXRpblxubGF1Z2hcbmxhdW5kcnlcbmxhdmFcbmxhd1xubGF3blxubGF3c3VpdFxubGF5ZXJcbmxhenlcbmxlYWRlclxubGVhZlxubGVhcm5cbmxlYXZlXG5sZWN0dXJlXG5sZWZ0XG5sZWdcbmxlZ2FsXG5sZWdlbmRcbmxlaXN1cmVcbmxlbW9uXG5sZW5kXG5sZW5ndGhcbmxlbnNcbmxlb3BhcmRcbmxlc3NvblxubGV0dGVyXG5sZXZlbFxubGlhclxubGliZXJ0eVxubGlicmFyeVxubGljZW5zZVxubGlmZVxubGlmdFxubGlnaHRcbmxpa2VcbmxpbWJcbmxpbWl0XG5saW5rXG5saW9uXG5saXF1aWRcbmxpc3RcbmxpdHRsZVxubGl2ZVxubGl6YXJkXG5sb2FkXG5sb2FuXG5sb2JzdGVyXG5sb2NhbFxubG9ja1xubG9naWNcbmxvbmVseVxubG9uZ1xubG9vcFxubG90dGVyeVxubG91ZFxubG91bmdlXG5sb3ZlXG5sb3lhbFxubHVja3lcbmx1Z2dhZ2Vcbmx1bWJlclxubHVuYXJcbmx1bmNoXG5sdXh1cnlcbmx5cmljc1xubWFjaGluZVxubWFkXG5tYWdpY1xubWFnbmV0XG5tYWlkXG5tYWlsXG5tYWluXG5tYWpvclxubWFrZVxubWFtbWFsXG5tYW5cbm1hbmFnZVxubWFuZGF0ZVxubWFuZ29cbm1hbnNpb25cbm1hbnVhbFxubWFwbGVcbm1hcmJsZVxubWFyY2hcbm1hcmdpblxubWFyaW5lXG5tYXJrZXRcbm1hcnJpYWdlXG5tYXNrXG5tYXNzXG5tYXN0ZXJcbm1hdGNoXG5tYXRlcmlhbFxubWF0aFxubWF0cml4XG5tYXR0ZXJcbm1heGltdW1cbm1hemVcbm1lYWRvd1xubWVhblxubWVhc3VyZVxubWVhdFxubWVjaGFuaWNcbm1lZGFsXG5tZWRpYVxubWVsb2R5XG5tZWx0XG5tZW1iZXJcbm1lbW9yeVxubWVudGlvblxubWVudVxubWVyY3lcbm1lcmdlXG5tZXJpdFxubWVycnlcbm1lc2hcbm1lc3NhZ2Vcbm1ldGFsXG5tZXRob2Rcbm1pZGRsZVxubWlkbmlnaHRcbm1pbGtcbm1pbGxpb25cbm1pbWljXG5taW5kXG5taW5pbXVtXG5taW5vclxubWludXRlXG5taXJhY2xlXG5taXJyb3Jcbm1pc2VyeVxubWlzc1xubWlzdGFrZVxubWl4XG5taXhlZFxubWl4dHVyZVxubW9iaWxlXG5tb2RlbFxubW9kaWZ5XG5tb21cbm1vbWVudFxubW9uaXRvclxubW9ua2V5XG5tb25zdGVyXG5tb250aFxubW9vblxubW9yYWxcbm1vcmVcbm1vcm5pbmdcbm1vc3F1aXRvXG5tb3RoZXJcbm1vdGlvblxubW90b3Jcbm1vdW50YWluXG5tb3VzZVxubW92ZVxubW92aWVcbm11Y2hcbm11ZmZpblxubXVsZVxubXVsdGlwbHlcbm11c2NsZVxubXVzZXVtXG5tdXNocm9vbVxubXVzaWNcbm11c3Rcbm11dHVhbFxubXlzZWxmXG5teXN0ZXJ5XG5teXRoXG5uYWl2ZVxubmFtZVxubmFwa2luXG5uYXJyb3dcbm5hc3R5XG5uYXRpb25cbm5hdHVyZVxubmVhclxubmVja1xubmVlZFxubmVnYXRpdmVcbm5lZ2xlY3Rcbm5laXRoZXJcbm5lcGhld1xubmVydmVcbm5lc3Rcbm5ldFxubmV0d29ya1xubmV1dHJhbFxubmV2ZXJcbm5ld3Ncbm5leHRcbm5pY2Vcbm5pZ2h0XG5ub2JsZVxubm9pc2Vcbm5vbWluZWVcbm5vb2RsZVxubm9ybWFsXG5ub3J0aFxubm9zZVxubm90YWJsZVxubm90ZVxubm90aGluZ1xubm90aWNlXG5ub3ZlbFxubm93XG5udWNsZWFyXG5udW1iZXJcbm51cnNlXG5udXRcbm9ha1xub2JleVxub2JqZWN0XG5vYmxpZ2Vcbm9ic2N1cmVcbm9ic2VydmVcbm9idGFpblxub2J2aW91c1xub2NjdXJcbm9jZWFuXG5vY3RvYmVyXG5vZG9yXG5vZmZcbm9mZmVyXG5vZmZpY2Vcbm9mdGVuXG5vaWxcbm9rYXlcbm9sZFxub2xpdmVcbm9seW1waWNcbm9taXRcbm9uY2Vcbm9uZVxub25pb25cbm9ubGluZVxub25seVxub3Blblxub3BlcmFcbm9waW5pb25cbm9wcG9zZVxub3B0aW9uXG5vcmFuZ2Vcbm9yYml0XG5vcmNoYXJkXG5vcmRlclxub3JkaW5hcnlcbm9yZ2FuXG5vcmllbnRcbm9yaWdpbmFsXG5vcnBoYW5cbm9zdHJpY2hcbm90aGVyXG5vdXRkb29yXG5vdXRlclxub3V0cHV0XG5vdXRzaWRlXG5vdmFsXG5vdmVuXG5vdmVyXG5vd25cbm93bmVyXG5veHlnZW5cbm95c3Rlclxub3pvbmVcbnBhY3RcbnBhZGRsZVxucGFnZVxucGFpclxucGFsYWNlXG5wYWxtXG5wYW5kYVxucGFuZWxcbnBhbmljXG5wYW50aGVyXG5wYXBlclxucGFyYWRlXG5wYXJlbnRcbnBhcmtcbnBhcnJvdFxucGFydHlcbnBhc3NcbnBhdGNoXG5wYXRoXG5wYXRpZW50XG5wYXRyb2xcbnBhdHRlcm5cbnBhdXNlXG5wYXZlXG5wYXltZW50XG5wZWFjZVxucGVhbnV0XG5wZWFyXG5wZWFzYW50XG5wZWxpY2FuXG5wZW5cbnBlbmFsdHlcbnBlbmNpbFxucGVvcGxlXG5wZXBwZXJcbnBlcmZlY3RcbnBlcm1pdFxucGVyc29uXG5wZXRcbnBob25lXG5waG90b1xucGhyYXNlXG5waHlzaWNhbFxucGlhbm9cbnBpY25pY1xucGljdHVyZVxucGllY2VcbnBpZ1xucGlnZW9uXG5waWxsXG5waWxvdFxucGlua1xucGlvbmVlclxucGlwZVxucGlzdG9sXG5waXRjaFxucGl6emFcbnBsYWNlXG5wbGFuZXRcbnBsYXN0aWNcbnBsYXRlXG5wbGF5XG5wbGVhc2VcbnBsZWRnZVxucGx1Y2tcbnBsdWdcbnBsdW5nZVxucG9lbVxucG9ldFxucG9pbnRcbnBvbGFyXG5wb2xlXG5wb2xpY2VcbnBvbmRcbnBvbnlcbnBvb2xcbnBvcHVsYXJcbnBvcnRpb25cbnBvc2l0aW9uXG5wb3NzaWJsZVxucG9zdFxucG90YXRvXG5wb3R0ZXJ5XG5wb3ZlcnR5XG5wb3dkZXJcbnBvd2VyXG5wcmFjdGljZVxucHJhaXNlXG5wcmVkaWN0XG5wcmVmZXJcbnByZXBhcmVcbnByZXNlbnRcbnByZXR0eVxucHJldmVudFxucHJpY2VcbnByaWRlXG5wcmltYXJ5XG5wcmludFxucHJpb3JpdHlcbnByaXNvblxucHJpdmF0ZVxucHJpemVcbnByb2JsZW1cbnByb2Nlc3NcbnByb2R1Y2VcbnByb2ZpdFxucHJvZ3JhbVxucHJvamVjdFxucHJvbW90ZVxucHJvb2ZcbnByb3BlcnR5XG5wcm9zcGVyXG5wcm90ZWN0XG5wcm91ZFxucHJvdmlkZVxucHVibGljXG5wdWRkaW5nXG5wdWxsXG5wdWxwXG5wdWxzZVxucHVtcGtpblxucHVuY2hcbnB1cGlsXG5wdXBweVxucHVyY2hhc2VcbnB1cml0eVxucHVycG9zZVxucHVyc2VcbnB1c2hcbnB1dFxucHV6emxlXG5weXJhbWlkXG5xdWFsaXR5XG5xdWFudHVtXG5xdWFydGVyXG5xdWVzdGlvblxucXVpY2tcbnF1aXRcbnF1aXpcbnF1b3RlXG5yYWJiaXRcbnJhY2Nvb25cbnJhY2VcbnJhY2tcbnJhZGFyXG5yYWRpb1xucmFpbFxucmFpblxucmFpc2VcbnJhbGx5XG5yYW1wXG5yYW5jaFxucmFuZG9tXG5yYW5nZVxucmFwaWRcbnJhcmVcbnJhdGVcbnJhdGhlclxucmF2ZW5cbnJhd1xucmF6b3JcbnJlYWR5XG5yZWFsXG5yZWFzb25cbnJlYmVsXG5yZWJ1aWxkXG5yZWNhbGxcbnJlY2VpdmVcbnJlY2lwZVxucmVjb3JkXG5yZWN5Y2xlXG5yZWR1Y2VcbnJlZmxlY3RcbnJlZm9ybVxucmVmdXNlXG5yZWdpb25cbnJlZ3JldFxucmVndWxhclxucmVqZWN0XG5yZWxheFxucmVsZWFzZVxucmVsaWVmXG5yZWx5XG5yZW1haW5cbnJlbWVtYmVyXG5yZW1pbmRcbnJlbW92ZVxucmVuZGVyXG5yZW5ld1xucmVudFxucmVvcGVuXG5yZXBhaXJcbnJlcGVhdFxucmVwbGFjZVxucmVwb3J0XG5yZXF1aXJlXG5yZXNjdWVcbnJlc2VtYmxlXG5yZXNpc3RcbnJlc291cmNlXG5yZXNwb25zZVxucmVzdWx0XG5yZXRpcmVcbnJldHJlYXRcbnJldHVyblxucmV1bmlvblxucmV2ZWFsXG5yZXZpZXdcbnJld2FyZFxucmh5dGhtXG5yaWJcbnJpYmJvblxucmljZVxucmljaFxucmlkZVxucmlkZ2VcbnJpZmxlXG5yaWdodFxucmlnaWRcbnJpbmdcbnJpb3RcbnJpcHBsZVxucmlza1xucml0dWFsXG5yaXZhbFxucml2ZXJcbnJvYWRcbnJvYXN0XG5yb2JvdFxucm9idXN0XG5yb2NrZXRcbnJvbWFuY2VcbnJvb2ZcbnJvb2tpZVxucm9vbVxucm9zZVxucm90YXRlXG5yb3VnaFxucm91bmRcbnJvdXRlXG5yb3lhbFxucnViYmVyXG5ydWRlXG5ydWdcbnJ1bGVcbnJ1blxucnVud2F5XG5ydXJhbFxuc2FkXG5zYWRkbGVcbnNhZG5lc3NcbnNhZmVcbnNhaWxcbnNhbGFkXG5zYWxtb25cbnNhbG9uXG5zYWx0XG5zYWx1dGVcbnNhbWVcbnNhbXBsZVxuc2FuZFxuc2F0aXNmeVxuc2F0b3NoaVxuc2F1Y2VcbnNhdXNhZ2VcbnNhdmVcbnNheVxuc2NhbGVcbnNjYW5cbnNjYXJlXG5zY2F0dGVyXG5zY2VuZVxuc2NoZW1lXG5zY2hvb2xcbnNjaWVuY2VcbnNjaXNzb3JzXG5zY29ycGlvblxuc2NvdXRcbnNjcmFwXG5zY3JlZW5cbnNjcmlwdFxuc2NydWJcbnNlYVxuc2VhcmNoXG5zZWFzb25cbnNlYXRcbnNlY29uZFxuc2VjcmV0XG5zZWN0aW9uXG5zZWN1cml0eVxuc2VlZFxuc2Vla1xuc2VnbWVudFxuc2VsZWN0XG5zZWxsXG5zZW1pbmFyXG5zZW5pb3JcbnNlbnNlXG5zZW50ZW5jZVxuc2VyaWVzXG5zZXJ2aWNlXG5zZXNzaW9uXG5zZXR0bGVcbnNldHVwXG5zZXZlblxuc2hhZG93XG5zaGFmdFxuc2hhbGxvd1xuc2hhcmVcbnNoZWRcbnNoZWxsXG5zaGVyaWZmXG5zaGllbGRcbnNoaWZ0XG5zaGluZVxuc2hpcFxuc2hpdmVyXG5zaG9ja1xuc2hvZVxuc2hvb3RcbnNob3BcbnNob3J0XG5zaG91bGRlclxuc2hvdmVcbnNocmltcFxuc2hydWdcbnNodWZmbGVcbnNoeVxuc2libGluZ1xuc2lja1xuc2lkZVxuc2llZ2VcbnNpZ2h0XG5zaWduXG5zaWxlbnRcbnNpbGtcbnNpbGx5XG5zaWx2ZXJcbnNpbWlsYXJcbnNpbXBsZVxuc2luY2VcbnNpbmdcbnNpcmVuXG5zaXN0ZXJcbnNpdHVhdGVcbnNpeFxuc2l6ZVxuc2thdGVcbnNrZXRjaFxuc2tpXG5za2lsbFxuc2tpblxuc2tpcnRcbnNrdWxsXG5zbGFiXG5zbGFtXG5zbGVlcFxuc2xlbmRlclxuc2xpY2VcbnNsaWRlXG5zbGlnaHRcbnNsaW1cbnNsb2dhblxuc2xvdFxuc2xvd1xuc2x1c2hcbnNtYWxsXG5zbWFydFxuc21pbGVcbnNtb2tlXG5zbW9vdGhcbnNuYWNrXG5zbmFrZVxuc25hcFxuc25pZmZcbnNub3dcbnNvYXBcbnNvY2Nlclxuc29jaWFsXG5zb2NrXG5zb2RhXG5zb2Z0XG5zb2xhclxuc29sZGllclxuc29saWRcbnNvbHV0aW9uXG5zb2x2ZVxuc29tZW9uZVxuc29uZ1xuc29vblxuc29ycnlcbnNvcnRcbnNvdWxcbnNvdW5kXG5zb3VwXG5zb3VyY2VcbnNvdXRoXG5zcGFjZVxuc3BhcmVcbnNwYXRpYWxcbnNwYXduXG5zcGVha1xuc3BlY2lhbFxuc3BlZWRcbnNwZWxsXG5zcGVuZFxuc3BoZXJlXG5zcGljZVxuc3BpZGVyXG5zcGlrZVxuc3Bpblxuc3Bpcml0XG5zcGxpdFxuc3BvaWxcbnNwb25zb3JcbnNwb29uXG5zcG9ydFxuc3BvdFxuc3ByYXlcbnNwcmVhZFxuc3ByaW5nXG5zcHlcbnNxdWFyZVxuc3F1ZWV6ZVxuc3F1aXJyZWxcbnN0YWJsZVxuc3RhZGl1bVxuc3RhZmZcbnN0YWdlXG5zdGFpcnNcbnN0YW1wXG5zdGFuZFxuc3RhcnRcbnN0YXRlXG5zdGF5XG5zdGVha1xuc3RlZWxcbnN0ZW1cbnN0ZXBcbnN0ZXJlb1xuc3RpY2tcbnN0aWxsXG5zdGluZ1xuc3RvY2tcbnN0b21hY2hcbnN0b25lXG5zdG9vbFxuc3RvcnlcbnN0b3ZlXG5zdHJhdGVneVxuc3RyZWV0XG5zdHJpa2VcbnN0cm9uZ1xuc3RydWdnbGVcbnN0dWRlbnRcbnN0dWZmXG5zdHVtYmxlXG5zdHlsZVxuc3ViamVjdFxuc3VibWl0XG5zdWJ3YXlcbnN1Y2Nlc3NcbnN1Y2hcbnN1ZGRlblxuc3VmZmVyXG5zdWdhclxuc3VnZ2VzdFxuc3VpdFxuc3VtbWVyXG5zdW5cbnN1bm55XG5zdW5zZXRcbnN1cGVyXG5zdXBwbHlcbnN1cHJlbWVcbnN1cmVcbnN1cmZhY2VcbnN1cmdlXG5zdXJwcmlzZVxuc3Vycm91bmRcbnN1cnZleVxuc3VzcGVjdFxuc3VzdGFpblxuc3dhbGxvd1xuc3dhbXBcbnN3YXBcbnN3YXJtXG5zd2Vhclxuc3dlZXRcbnN3aWZ0XG5zd2ltXG5zd2luZ1xuc3dpdGNoXG5zd29yZFxuc3ltYm9sXG5zeW1wdG9tXG5zeXJ1cFxuc3lzdGVtXG50YWJsZVxudGFja2xlXG50YWdcbnRhaWxcbnRhbGVudFxudGFsa1xudGFua1xudGFwZVxudGFyZ2V0XG50YXNrXG50YXN0ZVxudGF0dG9vXG50YXhpXG50ZWFjaFxudGVhbVxudGVsbFxudGVuXG50ZW5hbnRcbnRlbm5pc1xudGVudFxudGVybVxudGVzdFxudGV4dFxudGhhbmtcbnRoYXRcbnRoZW1lXG50aGVuXG50aGVvcnlcbnRoZXJlXG50aGV5XG50aGluZ1xudGhpc1xudGhvdWdodFxudGhyZWVcbnRocml2ZVxudGhyb3dcbnRodW1iXG50aHVuZGVyXG50aWNrZXRcbnRpZGVcbnRpZ2VyXG50aWx0XG50aW1iZXJcbnRpbWVcbnRpbnlcbnRpcFxudGlyZWRcbnRpc3N1ZVxudGl0bGVcbnRvYXN0XG50b2JhY2NvXG50b2RheVxudG9kZGxlclxudG9lXG50b2dldGhlclxudG9pbGV0XG50b2tlblxudG9tYXRvXG50b21vcnJvd1xudG9uZVxudG9uZ3VlXG50b25pZ2h0XG50b29sXG50b290aFxudG9wXG50b3BpY1xudG9wcGxlXG50b3JjaFxudG9ybmFkb1xudG9ydG9pc2VcbnRvc3NcbnRvdGFsXG50b3VyaXN0XG50b3dhcmRcbnRvd2VyXG50b3duXG50b3lcbnRyYWNrXG50cmFkZVxudHJhZmZpY1xudHJhZ2ljXG50cmFpblxudHJhbnNmZXJcbnRyYXBcbnRyYXNoXG50cmF2ZWxcbnRyYXlcbnRyZWF0XG50cmVlXG50cmVuZFxudHJpYWxcbnRyaWJlXG50cmlja1xudHJpZ2dlclxudHJpbVxudHJpcFxudHJvcGh5XG50cm91YmxlXG50cnVja1xudHJ1ZVxudHJ1bHlcbnRydW1wZXRcbnRydXN0XG50cnV0aFxudHJ5XG50dWJlXG50dWl0aW9uXG50dW1ibGVcbnR1bmFcbnR1bm5lbFxudHVya2V5XG50dXJuXG50dXJ0bGVcbnR3ZWx2ZVxudHdlbnR5XG50d2ljZVxudHdpblxudHdpc3RcbnR3b1xudHlwZVxudHlwaWNhbFxudWdseVxudW1icmVsbGFcbnVuYWJsZVxudW5hd2FyZVxudW5jbGVcbnVuY292ZXJcbnVuZGVyXG51bmRvXG51bmZhaXJcbnVuZm9sZFxudW5oYXBweVxudW5pZm9ybVxudW5pcXVlXG51bml0XG51bml2ZXJzZVxudW5rbm93blxudW5sb2NrXG51bnRpbFxudW51c3VhbFxudW52ZWlsXG51cGRhdGVcbnVwZ3JhZGVcbnVwaG9sZFxudXBvblxudXBwZXJcbnVwc2V0XG51cmJhblxudXJnZVxudXNhZ2VcbnVzZVxudXNlZFxudXNlZnVsXG51c2VsZXNzXG51c3VhbFxudXRpbGl0eVxudmFjYW50XG52YWN1dW1cbnZhZ3VlXG52YWxpZFxudmFsbGV5XG52YWx2ZVxudmFuXG52YW5pc2hcbnZhcG9yXG52YXJpb3VzXG52YXN0XG52YXVsdFxudmVoaWNsZVxudmVsdmV0XG52ZW5kb3JcbnZlbnR1cmVcbnZlbnVlXG52ZXJiXG52ZXJpZnlcbnZlcnNpb25cbnZlcnlcbnZlc3NlbFxudmV0ZXJhblxudmlhYmxlXG52aWJyYW50XG52aWNpb3VzXG52aWN0b3J5XG52aWRlb1xudmlld1xudmlsbGFnZVxudmludGFnZVxudmlvbGluXG52aXJ0dWFsXG52aXJ1c1xudmlzYVxudmlzaXRcbnZpc3VhbFxudml0YWxcbnZpdmlkXG52b2NhbFxudm9pY2VcbnZvaWRcbnZvbGNhbm9cbnZvbHVtZVxudm90ZVxudm95YWdlXG53YWdlXG53YWdvblxud2FpdFxud2Fsa1xud2FsbFxud2FsbnV0XG53YW50XG53YXJmYXJlXG53YXJtXG53YXJyaW9yXG53YXNoXG53YXNwXG53YXN0ZVxud2F0ZXJcbndhdmVcbndheVxud2VhbHRoXG53ZWFwb25cbndlYXJcbndlYXNlbFxud2VhdGhlclxud2ViXG53ZWRkaW5nXG53ZWVrZW5kXG53ZWlyZFxud2VsY29tZVxud2VzdFxud2V0XG53aGFsZVxud2hhdFxud2hlYXRcbndoZWVsXG53aGVuXG53aGVyZVxud2hpcFxud2hpc3Blclxud2lkZVxud2lkdGhcbndpZmVcbndpbGRcbndpbGxcbndpblxud2luZG93XG53aW5lXG53aW5nXG53aW5rXG53aW5uZXJcbndpbnRlclxud2lyZVxud2lzZG9tXG53aXNlXG53aXNoXG53aXRuZXNzXG53b2xmXG53b21hblxud29uZGVyXG53b29kXG53b29sXG53b3JkXG53b3JrXG53b3JsZFxud29ycnlcbndvcnRoXG53cmFwXG53cmVja1xud3Jlc3RsZVxud3Jpc3RcbndyaXRlXG53cm9uZ1xueWFyZFxueWVhclxueWVsbG93XG55b3VcbnlvdW5nXG55b3V0aFxuemVicmFcbnplcm9cbnpvbmVcbnpvb2Auc3BsaXQoYFxuYCk7XG52YXIgZGUgPSB7fTtcbmZ1bmN0aW9uIFByKHQpIHtcbiAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcih0KSB8fCB0IDwgMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFdyb25nIHBvc2l0aXZlIGludGVnZXI6ICR7dH1gKTtcbn1cbmZ1bmN0aW9uIExzKHQpIHtcbiAgaWYgKHR5cGVvZiB0ICE9IFwiYm9vbGVhblwiKVxuICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYm9vbGVhbiwgbm90ICR7dH1gKTtcbn1cbmZ1bmN0aW9uIFllKHQsIC4uLmUpIHtcbiAgaWYgKCEodCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIFVpbnQ4QXJyYXlcIik7XG4gIGlmIChlLmxlbmd0aCA+IDAgJiYgIWUuaW5jbHVkZXModC5sZW5ndGgpKVxuICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgVWludDhBcnJheSBvZiBsZW5ndGggJHtlfSwgbm90IG9mIGxlbmd0aD0ke3QubGVuZ3RofWApO1xufVxuZnVuY3Rpb24gJHModCkge1xuICBpZiAodHlwZW9mIHQgIT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiB0LmNyZWF0ZSAhPSBcImZ1bmN0aW9uXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSGFzaCBzaG91bGQgYmUgd3JhcHBlZCBieSB1dGlscy53cmFwQ29uc3RydWN0b3JcIik7XG4gIFByKHQub3V0cHV0TGVuKSwgUHIodC5ibG9ja0xlbik7XG59XG5mdW5jdGlvbiBxcyh0LCBlID0gITApIHtcbiAgaWYgKHQuZGVzdHJveWVkKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkhhc2ggaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkXCIpO1xuICBpZiAoZSAmJiB0LmZpbmlzaGVkKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkhhc2gjZGlnZXN0KCkgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWRcIik7XG59XG5mdW5jdGlvbiBOcyh0LCBlKSB7XG4gIFllKHQpO1xuICBjb25zdCByID0gZS5vdXRwdXRMZW47XG4gIGlmICh0Lmxlbmd0aCA8IHIpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBkaWdlc3RJbnRvKCkgZXhwZWN0cyBvdXRwdXQgYnVmZmVyIG9mIGxlbmd0aCBhdCBsZWFzdCAke3J9YCk7XG59XG5jb25zdCBRZSA9IHtcbiAgbnVtYmVyOiBQcixcbiAgYm9vbDogTHMsXG4gIGJ5dGVzOiBZZSxcbiAgaGFzaDogJHMsXG4gIGV4aXN0czogcXMsXG4gIG91dHB1dDogTnNcbn0sIER1ID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoLyogQF9fUFVSRV9fICovIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgbnVtYmVyOiBQcixcbiAgYm9vbDogTHMsXG4gIGJ5dGVzOiBZZSxcbiAgaGFzaDogJHMsXG4gIGV4aXN0czogcXMsXG4gIG91dHB1dDogTnMsXG4gIGRlZmF1bHQ6IFFlXG59LCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSkpLCB6dSA9IC8qIEBfX1BVUkVfXyAqLyBFdChEdSk7XG52YXIgeHQgPSB7fSwgbmUgPSB7fTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xubmUub3V0cHV0ID0gbmUuZXhpc3RzID0gbmUuaGFzaCA9IG5lLmJ5dGVzID0gbmUuYm9vbCA9IG5lLm51bWJlciA9IHZvaWQgMDtcbmZ1bmN0aW9uIEJyKHQpIHtcbiAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcih0KSB8fCB0IDwgMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFdyb25nIHBvc2l0aXZlIGludGVnZXI6ICR7dH1gKTtcbn1cbm5lLm51bWJlciA9IEJyO1xuZnVuY3Rpb24gVXModCkge1xuICBpZiAodHlwZW9mIHQgIT0gXCJib29sZWFuXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBib29sZWFuLCBub3QgJHt0fWApO1xufVxubmUuYm9vbCA9IFVzO1xuZnVuY3Rpb24gZWkodCwgLi4uZSkge1xuICBpZiAoISh0IGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgVWludDhBcnJheVwiKTtcbiAgaWYgKGUubGVuZ3RoID4gMCAmJiAhZS5pbmNsdWRlcyh0Lmxlbmd0aCkpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBVaW50OEFycmF5IG9mIGxlbmd0aCAke2V9LCBub3Qgb2YgbGVuZ3RoPSR7dC5sZW5ndGh9YCk7XG59XG5uZS5ieXRlcyA9IGVpO1xuZnVuY3Rpb24ganModCkge1xuICBpZiAodHlwZW9mIHQgIT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiB0LmNyZWF0ZSAhPSBcImZ1bmN0aW9uXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSGFzaCBzaG91bGQgYmUgd3JhcHBlZCBieSB1dGlscy53cmFwQ29uc3RydWN0b3JcIik7XG4gIEJyKHQub3V0cHV0TGVuKSwgQnIodC5ibG9ja0xlbik7XG59XG5uZS5oYXNoID0ganM7XG5mdW5jdGlvbiBIcyh0LCBlID0gITApIHtcbiAgaWYgKHQuZGVzdHJveWVkKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkhhc2ggaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkXCIpO1xuICBpZiAoZSAmJiB0LmZpbmlzaGVkKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkhhc2gjZGlnZXN0KCkgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWRcIik7XG59XG5uZS5leGlzdHMgPSBIcztcbmZ1bmN0aW9uIE1zKHQsIGUpIHtcbiAgZWkodCk7XG4gIGNvbnN0IHIgPSBlLm91dHB1dExlbjtcbiAgaWYgKHQubGVuZ3RoIDwgcilcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGRpZ2VzdEludG8oKSBleHBlY3RzIG91dHB1dCBidWZmZXIgb2YgbGVuZ3RoIGF0IGxlYXN0ICR7cn1gKTtcbn1cbm5lLm91dHB1dCA9IE1zO1xuY29uc3QgRnUgPSB7XG4gIG51bWJlcjogQnIsXG4gIGJvb2w6IFVzLFxuICBieXRlczogZWksXG4gIGhhc2g6IGpzLFxuICBleGlzdHM6IEhzLFxuICBvdXRwdXQ6IE1zXG59O1xubmUuZGVmYXVsdCA9IEZ1O1xudmFyIERzID0ge30sIHRpID0ge307XG5jb25zdCBTciA9IHR5cGVvZiBnbG9iYWxUaGlzID09IFwib2JqZWN0XCIgJiYgXCJjcnlwdG9cIiBpbiBnbG9iYWxUaGlzID8gZ2xvYmFsVGhpcy5jcnlwdG8gOiB2b2lkIDAsIEt1ID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoLyogQF9fUFVSRV9fICovIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgY3J5cHRvOiBTclxufSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pKSwgV3UgPSAvKiBAX19QVVJFX18gKi8gRXQoS3UpO1xuKGZ1bmN0aW9uKHQpIHtcbiAgLyohIG5vYmxlLWhhc2hlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCB0LnJhbmRvbUJ5dGVzID0gdC53cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cyA9IHQud3JhcENvbnN0cnVjdG9yV2l0aE9wdHMgPSB0LndyYXBDb25zdHJ1Y3RvciA9IHQuY2hlY2tPcHRzID0gdC5IYXNoID0gdC5jb25jYXRCeXRlcyA9IHQudG9CeXRlcyA9IHQudXRmOFRvQnl0ZXMgPSB0LmFzeW5jTG9vcCA9IHQubmV4dFRpY2sgPSB0LmhleFRvQnl0ZXMgPSB0LmJ5dGVzVG9IZXggPSB0LmlzTEUgPSB0LnJvdHIgPSB0LmNyZWF0ZVZpZXcgPSB0LnUzMiA9IHQudTggPSB2b2lkIDA7XG4gIGNvbnN0IGUgPSBXdSwgciA9ICh3KSA9PiB3IGluc3RhbmNlb2YgVWludDhBcnJheSwgbiA9ICh3KSA9PiBuZXcgVWludDhBcnJheSh3LmJ1ZmZlciwgdy5ieXRlT2Zmc2V0LCB3LmJ5dGVMZW5ndGgpO1xuICB0LnU4ID0gbjtcbiAgY29uc3QgaSA9ICh3KSA9PiBuZXcgVWludDMyQXJyYXkody5idWZmZXIsIHcuYnl0ZU9mZnNldCwgTWF0aC5mbG9vcih3LmJ5dGVMZW5ndGggLyA0KSk7XG4gIHQudTMyID0gaTtcbiAgY29uc3QgcyA9ICh3KSA9PiBuZXcgRGF0YVZpZXcody5idWZmZXIsIHcuYnl0ZU9mZnNldCwgdy5ieXRlTGVuZ3RoKTtcbiAgdC5jcmVhdGVWaWV3ID0gcztcbiAgY29uc3QgbyA9ICh3LCB4KSA9PiB3IDw8IDMyIC0geCB8IHcgPj4+IHg7XG4gIGlmICh0LnJvdHIgPSBvLCB0LmlzTEUgPSBuZXcgVWludDhBcnJheShuZXcgVWludDMyQXJyYXkoWzI4NzQ1NDAyMF0pLmJ1ZmZlcilbMF0gPT09IDY4LCAhdC5pc0xFKVxuICAgIHRocm93IG5ldyBFcnJvcihcIk5vbiBsaXR0bGUtZW5kaWFuIGhhcmR3YXJlIGlzIG5vdCBzdXBwb3J0ZWRcIik7XG4gIGNvbnN0IGEgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAyNTYgfSwgKHcsIHgpID0+IHgudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKSk7XG4gIGZ1bmN0aW9uIGModykge1xuICAgIGlmICghcih3KSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVpbnQ4QXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgbGV0IHggPSBcIlwiO1xuICAgIGZvciAobGV0IEEgPSAwOyBBIDwgdy5sZW5ndGg7IEErKylcbiAgICAgIHggKz0gYVt3W0FdXTtcbiAgICByZXR1cm4geDtcbiAgfVxuICB0LmJ5dGVzVG9IZXggPSBjO1xuICBmdW5jdGlvbiBsKHcpIHtcbiAgICBpZiAodHlwZW9mIHcgIT0gXCJzdHJpbmdcIilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImhleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCBcIiArIHR5cGVvZiB3KTtcbiAgICBjb25zdCB4ID0gdy5sZW5ndGg7XG4gICAgaWYgKHggJSAyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwicGFkZGVkIGhleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCB1bnBhZGRlZCBoZXggb2YgbGVuZ3RoIFwiICsgeCk7XG4gICAgY29uc3QgQSA9IG5ldyBVaW50OEFycmF5KHggLyAyKTtcbiAgICBmb3IgKGxldCBCID0gMDsgQiA8IEEubGVuZ3RoOyBCKyspIHtcbiAgICAgIGNvbnN0IEwgPSBCICogMiwgUCA9IHcuc2xpY2UoTCwgTCArIDIpLCBGID0gTnVtYmVyLnBhcnNlSW50KFAsIDE2KTtcbiAgICAgIGlmIChOdW1iZXIuaXNOYU4oRikgfHwgRiA8IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYnl0ZSBzZXF1ZW5jZVwiKTtcbiAgICAgIEFbQl0gPSBGO1xuICAgIH1cbiAgICByZXR1cm4gQTtcbiAgfVxuICB0LmhleFRvQnl0ZXMgPSBsO1xuICBjb25zdCBmID0gYXN5bmMgKCkgPT4ge1xuICB9O1xuICB0Lm5leHRUaWNrID0gZjtcbiAgYXN5bmMgZnVuY3Rpb24gdSh3LCB4LCBBKSB7XG4gICAgbGV0IEIgPSBEYXRlLm5vdygpO1xuICAgIGZvciAobGV0IEwgPSAwOyBMIDwgdzsgTCsrKSB7XG4gICAgICBBKEwpO1xuICAgICAgY29uc3QgUCA9IERhdGUubm93KCkgLSBCO1xuICAgICAgUCA+PSAwICYmIFAgPCB4IHx8IChhd2FpdCAoMCwgdC5uZXh0VGljaykoKSwgQiArPSBQKTtcbiAgICB9XG4gIH1cbiAgdC5hc3luY0xvb3AgPSB1O1xuICBmdW5jdGlvbiBoKHcpIHtcbiAgICBpZiAodHlwZW9mIHcgIT0gXCJzdHJpbmdcIilcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdXRmOFRvQnl0ZXMgZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygd31gKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHcpKTtcbiAgfVxuICB0LnV0ZjhUb0J5dGVzID0gaDtcbiAgZnVuY3Rpb24gZCh3KSB7XG4gICAgaWYgKHR5cGVvZiB3ID09IFwic3RyaW5nXCIgJiYgKHcgPSBoKHcpKSwgIXIodykpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkIFVpbnQ4QXJyYXksIGdvdCAke3R5cGVvZiB3fWApO1xuICAgIHJldHVybiB3O1xuICB9XG4gIHQudG9CeXRlcyA9IGQ7XG4gIGZ1bmN0aW9uIHAoLi4udykge1xuICAgIGNvbnN0IHggPSBuZXcgVWludDhBcnJheSh3LnJlZHVjZSgoQiwgTCkgPT4gQiArIEwubGVuZ3RoLCAwKSk7XG4gICAgbGV0IEEgPSAwO1xuICAgIHJldHVybiB3LmZvckVhY2goKEIpID0+IHtcbiAgICAgIGlmICghcihCKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVWludDhBcnJheSBleHBlY3RlZFwiKTtcbiAgICAgIHguc2V0KEIsIEEpLCBBICs9IEIubGVuZ3RoO1xuICAgIH0pLCB4O1xuICB9XG4gIHQuY29uY2F0Qnl0ZXMgPSBwO1xuICBjbGFzcyB5IHtcbiAgICBjbG9uZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jbG9uZUludG8oKTtcbiAgICB9XG4gIH1cbiAgdC5IYXNoID0geTtcbiAgY29uc3QgZyA9ICh3KSA9PiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodykgPT09IFwiW29iamVjdCBPYmplY3RdXCIgJiYgdy5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xuICBmdW5jdGlvbiB2KHcsIHgpIHtcbiAgICBpZiAoeCAhPT0gdm9pZCAwICYmICh0eXBlb2YgeCAhPSBcIm9iamVjdFwiIHx8ICFnKHgpKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk9wdGlvbnMgc2hvdWxkIGJlIG9iamVjdCBvciB1bmRlZmluZWRcIik7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24odywgeCk7XG4gIH1cbiAgdC5jaGVja09wdHMgPSB2O1xuICBmdW5jdGlvbiBfKHcpIHtcbiAgICBjb25zdCB4ID0gKEIpID0+IHcoKS51cGRhdGUoZChCKSkuZGlnZXN0KCksIEEgPSB3KCk7XG4gICAgcmV0dXJuIHgub3V0cHV0TGVuID0gQS5vdXRwdXRMZW4sIHguYmxvY2tMZW4gPSBBLmJsb2NrTGVuLCB4LmNyZWF0ZSA9ICgpID0+IHcoKSwgeDtcbiAgfVxuICB0LndyYXBDb25zdHJ1Y3RvciA9IF87XG4gIGZ1bmN0aW9uIG0odykge1xuICAgIGNvbnN0IHggPSAoQiwgTCkgPT4gdyhMKS51cGRhdGUoZChCKSkuZGlnZXN0KCksIEEgPSB3KHt9KTtcbiAgICByZXR1cm4geC5vdXRwdXRMZW4gPSBBLm91dHB1dExlbiwgeC5ibG9ja0xlbiA9IEEuYmxvY2tMZW4sIHguY3JlYXRlID0gKEIpID0+IHcoQiksIHg7XG4gIH1cbiAgdC53cmFwQ29uc3RydWN0b3JXaXRoT3B0cyA9IG07XG4gIGZ1bmN0aW9uIEModykge1xuICAgIGNvbnN0IHggPSAoQiwgTCkgPT4gdyhMKS51cGRhdGUoZChCKSkuZGlnZXN0KCksIEEgPSB3KHt9KTtcbiAgICByZXR1cm4geC5vdXRwdXRMZW4gPSBBLm91dHB1dExlbiwgeC5ibG9ja0xlbiA9IEEuYmxvY2tMZW4sIHguY3JlYXRlID0gKEIpID0+IHcoQiksIHg7XG4gIH1cbiAgdC53cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cyA9IEM7XG4gIGZ1bmN0aW9uIE8odyA9IDMyKSB7XG4gICAgaWYgKGUuY3J5cHRvICYmIHR5cGVvZiBlLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgcmV0dXJuIGUuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheSh3KSk7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY3J5cHRvLmdldFJhbmRvbVZhbHVlcyBtdXN0IGJlIGRlZmluZWRcIik7XG4gIH1cbiAgdC5yYW5kb21CeXRlcyA9IE87XG59KSh0aSk7XG4oZnVuY3Rpb24odCkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCB0LmhtYWMgPSB0LkhNQUMgPSB2b2lkIDA7XG4gIGNvbnN0IGUgPSBuZSwgciA9IHRpO1xuICBjbGFzcyBuIGV4dGVuZHMgci5IYXNoIHtcbiAgICBjb25zdHJ1Y3RvcihvLCBhKSB7XG4gICAgICBzdXBlcigpLCB0aGlzLmZpbmlzaGVkID0gITEsIHRoaXMuZGVzdHJveWVkID0gITEsIGUuZGVmYXVsdC5oYXNoKG8pO1xuICAgICAgY29uc3QgYyA9ICgwLCByLnRvQnl0ZXMpKGEpO1xuICAgICAgaWYgKHRoaXMuaUhhc2ggPSBvLmNyZWF0ZSgpLCB0eXBlb2YgdGhpcy5pSGFzaC51cGRhdGUgIT0gXCJmdW5jdGlvblwiKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBpbnN0YW5jZSBvZiBjbGFzcyB3aGljaCBleHRlbmRzIHV0aWxzLkhhc2hcIik7XG4gICAgICB0aGlzLmJsb2NrTGVuID0gdGhpcy5pSGFzaC5ibG9ja0xlbiwgdGhpcy5vdXRwdXRMZW4gPSB0aGlzLmlIYXNoLm91dHB1dExlbjtcbiAgICAgIGNvbnN0IGwgPSB0aGlzLmJsb2NrTGVuLCBmID0gbmV3IFVpbnQ4QXJyYXkobCk7XG4gICAgICBmLnNldChjLmxlbmd0aCA+IGwgPyBvLmNyZWF0ZSgpLnVwZGF0ZShjKS5kaWdlc3QoKSA6IGMpO1xuICAgICAgZm9yIChsZXQgdSA9IDA7IHUgPCBmLmxlbmd0aDsgdSsrKVxuICAgICAgICBmW3VdIF49IDU0O1xuICAgICAgdGhpcy5pSGFzaC51cGRhdGUoZiksIHRoaXMub0hhc2ggPSBvLmNyZWF0ZSgpO1xuICAgICAgZm9yIChsZXQgdSA9IDA7IHUgPCBmLmxlbmd0aDsgdSsrKVxuICAgICAgICBmW3VdIF49IDEwNjtcbiAgICAgIHRoaXMub0hhc2gudXBkYXRlKGYpLCBmLmZpbGwoMCk7XG4gICAgfVxuICAgIHVwZGF0ZShvKSB7XG4gICAgICByZXR1cm4gZS5kZWZhdWx0LmV4aXN0cyh0aGlzKSwgdGhpcy5pSGFzaC51cGRhdGUobyksIHRoaXM7XG4gICAgfVxuICAgIGRpZ2VzdEludG8obykge1xuICAgICAgZS5kZWZhdWx0LmV4aXN0cyh0aGlzKSwgZS5kZWZhdWx0LmJ5dGVzKG8sIHRoaXMub3V0cHV0TGVuKSwgdGhpcy5maW5pc2hlZCA9ICEwLCB0aGlzLmlIYXNoLmRpZ2VzdEludG8obyksIHRoaXMub0hhc2gudXBkYXRlKG8pLCB0aGlzLm9IYXNoLmRpZ2VzdEludG8obyksIHRoaXMuZGVzdHJveSgpO1xuICAgIH1cbiAgICBkaWdlc3QoKSB7XG4gICAgICBjb25zdCBvID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5vSGFzaC5vdXRwdXRMZW4pO1xuICAgICAgcmV0dXJuIHRoaXMuZGlnZXN0SW50byhvKSwgbztcbiAgICB9XG4gICAgX2Nsb25lSW50byhvKSB7XG4gICAgICBvIHx8IChvID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyksIHt9KSk7XG4gICAgICBjb25zdCB7IG9IYXNoOiBhLCBpSGFzaDogYywgZmluaXNoZWQ6IGwsIGRlc3Ryb3llZDogZiwgYmxvY2tMZW46IHUsIG91dHB1dExlbjogaCB9ID0gdGhpcztcbiAgICAgIHJldHVybiBvID0gbywgby5maW5pc2hlZCA9IGwsIG8uZGVzdHJveWVkID0gZiwgby5ibG9ja0xlbiA9IHUsIG8ub3V0cHV0TGVuID0gaCwgby5vSGFzaCA9IGEuX2Nsb25lSW50byhvLm9IYXNoKSwgby5pSGFzaCA9IGMuX2Nsb25lSW50byhvLmlIYXNoKSwgbztcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgIHRoaXMuZGVzdHJveWVkID0gITAsIHRoaXMub0hhc2guZGVzdHJveSgpLCB0aGlzLmlIYXNoLmRlc3Ryb3koKTtcbiAgICB9XG4gIH1cbiAgdC5ITUFDID0gbjtcbiAgY29uc3QgaSA9IChzLCBvLCBhKSA9PiBuZXcgbihzLCBvKS51cGRhdGUoYSkuZGlnZXN0KCk7XG4gIHQuaG1hYyA9IGksIHQuaG1hYy5jcmVhdGUgPSAocywgbykgPT4gbmV3IG4ocywgbyk7XG59KShEcyk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoeHQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbnh0LnBia2RmMkFzeW5jID0geHQucGJrZGYyID0gdm9pZCAwO1xuY29uc3QgaHIgPSBuZSwgVnUgPSBEcywgYnQgPSB0aTtcbmZ1bmN0aW9uIHpzKHQsIGUsIHIsIG4pIHtcbiAgaHIuZGVmYXVsdC5oYXNoKHQpO1xuICBjb25zdCBpID0gKDAsIGJ0LmNoZWNrT3B0cykoeyBka0xlbjogMzIsIGFzeW5jVGljazogMTAgfSwgbiksIHsgYzogcywgZGtMZW46IG8sIGFzeW5jVGljazogYSB9ID0gaTtcbiAgaWYgKGhyLmRlZmF1bHQubnVtYmVyKHMpLCBoci5kZWZhdWx0Lm51bWJlcihvKSwgaHIuZGVmYXVsdC5udW1iZXIoYSksIHMgPCAxKVxuICAgIHRocm93IG5ldyBFcnJvcihcIlBCS0RGMjogaXRlcmF0aW9ucyAoYykgc2hvdWxkIGJlID49IDFcIik7XG4gIGNvbnN0IGMgPSAoMCwgYnQudG9CeXRlcykoZSksIGwgPSAoMCwgYnQudG9CeXRlcykociksIGYgPSBuZXcgVWludDhBcnJheShvKSwgdSA9IFZ1LmhtYWMuY3JlYXRlKHQsIGMpLCBoID0gdS5fY2xvbmVJbnRvKCkudXBkYXRlKGwpO1xuICByZXR1cm4geyBjOiBzLCBka0xlbjogbywgYXN5bmNUaWNrOiBhLCBESzogZiwgUFJGOiB1LCBQUkZTYWx0OiBoIH07XG59XG5mdW5jdGlvbiBGcyh0LCBlLCByLCBuLCBpKSB7XG4gIHJldHVybiB0LmRlc3Ryb3koKSwgZS5kZXN0cm95KCksIG4gJiYgbi5kZXN0cm95KCksIGkuZmlsbCgwKSwgcjtcbn1cbmZ1bmN0aW9uIEd1KHQsIGUsIHIsIG4pIHtcbiAgY29uc3QgeyBjOiBpLCBka0xlbjogcywgREs6IG8sIFBSRjogYSwgUFJGU2FsdDogYyB9ID0genModCwgZSwgciwgbik7XG4gIGxldCBsO1xuICBjb25zdCBmID0gbmV3IFVpbnQ4QXJyYXkoNCksIHUgPSAoMCwgYnQuY3JlYXRlVmlldykoZiksIGggPSBuZXcgVWludDhBcnJheShhLm91dHB1dExlbik7XG4gIGZvciAobGV0IGQgPSAxLCBwID0gMDsgcCA8IHM7IGQrKywgcCArPSBhLm91dHB1dExlbikge1xuICAgIGNvbnN0IHkgPSBvLnN1YmFycmF5KHAsIHAgKyBhLm91dHB1dExlbik7XG4gICAgdS5zZXRJbnQzMigwLCBkLCAhMSksIChsID0gYy5fY2xvbmVJbnRvKGwpKS51cGRhdGUoZikuZGlnZXN0SW50byhoKSwgeS5zZXQoaC5zdWJhcnJheSgwLCB5Lmxlbmd0aCkpO1xuICAgIGZvciAobGV0IGcgPSAxOyBnIDwgaTsgZysrKSB7XG4gICAgICBhLl9jbG9uZUludG8obCkudXBkYXRlKGgpLmRpZ2VzdEludG8oaCk7XG4gICAgICBmb3IgKGxldCB2ID0gMDsgdiA8IHkubGVuZ3RoOyB2KyspXG4gICAgICAgIHlbdl0gXj0gaFt2XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIEZzKGEsIGMsIG8sIGwsIGgpO1xufVxueHQucGJrZGYyID0gR3U7XG5hc3luYyBmdW5jdGlvbiBadSh0LCBlLCByLCBuKSB7XG4gIGNvbnN0IHsgYzogaSwgZGtMZW46IHMsIGFzeW5jVGljazogbywgREs6IGEsIFBSRjogYywgUFJGU2FsdDogbCB9ID0genModCwgZSwgciwgbik7XG4gIGxldCBmO1xuICBjb25zdCB1ID0gbmV3IFVpbnQ4QXJyYXkoNCksIGggPSAoMCwgYnQuY3JlYXRlVmlldykodSksIGQgPSBuZXcgVWludDhBcnJheShjLm91dHB1dExlbik7XG4gIGZvciAobGV0IHAgPSAxLCB5ID0gMDsgeSA8IHM7IHArKywgeSArPSBjLm91dHB1dExlbikge1xuICAgIGNvbnN0IGcgPSBhLnN1YmFycmF5KHksIHkgKyBjLm91dHB1dExlbik7XG4gICAgaC5zZXRJbnQzMigwLCBwLCAhMSksIChmID0gbC5fY2xvbmVJbnRvKGYpKS51cGRhdGUodSkuZGlnZXN0SW50byhkKSwgZy5zZXQoZC5zdWJhcnJheSgwLCBnLmxlbmd0aCkpLCBhd2FpdCAoMCwgYnQuYXN5bmNMb29wKShpIC0gMSwgbywgKHYpID0+IHtcbiAgICAgIGMuX2Nsb25lSW50byhmKS51cGRhdGUoZCkuZGlnZXN0SW50byhkKTtcbiAgICAgIGZvciAobGV0IF8gPSAwOyBfIDwgZy5sZW5ndGg7IF8rKylcbiAgICAgICAgZ1tfXSBePSBkW19dO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBGcyhjLCBsLCBhLCBmLCBkKTtcbn1cbnh0LnBia2RmMkFzeW5jID0gWnU7XG4vKiEgbm9ibGUtaGFzaGVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5jb25zdCByaSA9ICh0KSA9PiB0IGluc3RhbmNlb2YgVWludDhBcnJheSwgWXUgPSAodCkgPT4gbmV3IFVpbnQ4QXJyYXkodC5idWZmZXIsIHQuYnl0ZU9mZnNldCwgdC5ieXRlTGVuZ3RoKSwgSnUgPSAodCkgPT4gbmV3IFVpbnQzMkFycmF5KHQuYnVmZmVyLCB0LmJ5dGVPZmZzZXQsIE1hdGguZmxvb3IodC5ieXRlTGVuZ3RoIC8gNCkpLCBmdCA9ICh0KSA9PiBuZXcgRGF0YVZpZXcodC5idWZmZXIsIHQuYnl0ZU9mZnNldCwgdC5ieXRlTGVuZ3RoKSwgRWUgPSAodCwgZSkgPT4gdCA8PCAzMiAtIGUgfCB0ID4+PiBlLCBLcyA9IG5ldyBVaW50OEFycmF5KG5ldyBVaW50MzJBcnJheShbMjg3NDU0MDIwXSkuYnVmZmVyKVswXSA9PT0gNjg7XG5pZiAoIUtzKVxuICB0aHJvdyBuZXcgRXJyb3IoXCJOb24gbGl0dGxlLWVuZGlhbiBoYXJkd2FyZSBpcyBub3Qgc3VwcG9ydGVkXCIpO1xuY29uc3QgWHUgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAyNTYgfSwgKHQsIGUpID0+IGUudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKSk7XG5mdW5jdGlvbiBuaSh0KSB7XG4gIGlmICghcmkodCkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVWludDhBcnJheSBleHBlY3RlZFwiKTtcbiAgbGV0IGUgPSBcIlwiO1xuICBmb3IgKGxldCByID0gMDsgciA8IHQubGVuZ3RoOyByKyspXG4gICAgZSArPSBYdVt0W3JdXTtcbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBXcyh0KSB7XG4gIGlmICh0eXBlb2YgdCAhPSBcInN0cmluZ1wiKVxuICAgIHRocm93IG5ldyBFcnJvcihcImhleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCBcIiArIHR5cGVvZiB0KTtcbiAgY29uc3QgZSA9IHQubGVuZ3RoO1xuICBpZiAoZSAlIDIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwicGFkZGVkIGhleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCB1bnBhZGRlZCBoZXggb2YgbGVuZ3RoIFwiICsgZSk7XG4gIGNvbnN0IHIgPSBuZXcgVWludDhBcnJheShlIC8gMik7XG4gIGZvciAobGV0IG4gPSAwOyBuIDwgci5sZW5ndGg7IG4rKykge1xuICAgIGNvbnN0IGkgPSBuICogMiwgcyA9IHQuc2xpY2UoaSwgaSArIDIpLCBvID0gTnVtYmVyLnBhcnNlSW50KHMsIDE2KTtcbiAgICBpZiAoTnVtYmVyLmlzTmFOKG8pIHx8IG8gPCAwKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBieXRlIHNlcXVlbmNlXCIpO1xuICAgIHJbbl0gPSBvO1xuICB9XG4gIHJldHVybiByO1xufVxuY29uc3QgVnMgPSBhc3luYyAoKSA9PiB7XG59O1xuYXN5bmMgZnVuY3Rpb24gUXUodCwgZSwgcikge1xuICBsZXQgbiA9IERhdGUubm93KCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdDsgaSsrKSB7XG4gICAgcihpKTtcbiAgICBjb25zdCBzID0gRGF0ZS5ub3coKSAtIG47XG4gICAgcyA+PSAwICYmIHMgPCBlIHx8IChhd2FpdCBWcygpLCBuICs9IHMpO1xuICB9XG59XG5mdW5jdGlvbiBpaSh0KSB7XG4gIGlmICh0eXBlb2YgdCAhPSBcInN0cmluZ1wiKVxuICAgIHRocm93IG5ldyBFcnJvcihgdXRmOFRvQnl0ZXMgZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2YgdH1gKTtcbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh0KSk7XG59XG5mdW5jdGlvbiBPdCh0KSB7XG4gIGlmICh0eXBlb2YgdCA9PSBcInN0cmluZ1wiICYmICh0ID0gaWkodCkpLCAhcmkodCkpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCBVaW50OEFycmF5LCBnb3QgJHt0eXBlb2YgdH1gKTtcbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBlciguLi50KSB7XG4gIGNvbnN0IGUgPSBuZXcgVWludDhBcnJheSh0LnJlZHVjZSgobiwgaSkgPT4gbiArIGkubGVuZ3RoLCAwKSk7XG4gIGxldCByID0gMDtcbiAgcmV0dXJuIHQuZm9yRWFjaCgobikgPT4ge1xuICAgIGlmICghcmkobikpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVaW50OEFycmF5IGV4cGVjdGVkXCIpO1xuICAgIGUuc2V0KG4sIHIpLCByICs9IG4ubGVuZ3RoO1xuICB9KSwgZTtcbn1cbmNsYXNzIG9pIHtcbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nsb25lSW50bygpO1xuICB9XG59XG5jb25zdCBlbCA9ICh0KSA9PiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCkgPT09IFwiW29iamVjdCBPYmplY3RdXCIgJiYgdC5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xuZnVuY3Rpb24gdGwodCwgZSkge1xuICBpZiAoZSAhPT0gdm9pZCAwICYmICh0eXBlb2YgZSAhPSBcIm9iamVjdFwiIHx8ICFlbChlKSkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiT3B0aW9ucyBzaG91bGQgYmUgb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24odCwgZSk7XG59XG5mdW5jdGlvbiBudCh0KSB7XG4gIGNvbnN0IGUgPSAobikgPT4gdCgpLnVwZGF0ZShPdChuKSkuZGlnZXN0KCksIHIgPSB0KCk7XG4gIHJldHVybiBlLm91dHB1dExlbiA9IHIub3V0cHV0TGVuLCBlLmJsb2NrTGVuID0gci5ibG9ja0xlbiwgZS5jcmVhdGUgPSAoKSA9PiB0KCksIGU7XG59XG5mdW5jdGlvbiBybCh0KSB7XG4gIGNvbnN0IGUgPSAobiwgaSkgPT4gdChpKS51cGRhdGUoT3QobikpLmRpZ2VzdCgpLCByID0gdCh7fSk7XG4gIHJldHVybiBlLm91dHB1dExlbiA9IHIub3V0cHV0TGVuLCBlLmJsb2NrTGVuID0gci5ibG9ja0xlbiwgZS5jcmVhdGUgPSAobikgPT4gdChuKSwgZTtcbn1cbmZ1bmN0aW9uIG5sKHQpIHtcbiAgY29uc3QgZSA9IChuLCBpKSA9PiB0KGkpLnVwZGF0ZShPdChuKSkuZGlnZXN0KCksIHIgPSB0KHt9KTtcbiAgcmV0dXJuIGUub3V0cHV0TGVuID0gci5vdXRwdXRMZW4sIGUuYmxvY2tMZW4gPSByLmJsb2NrTGVuLCBlLmNyZWF0ZSA9IChuKSA9PiB0KG4pLCBlO1xufVxuZnVuY3Rpb24gaWwodCA9IDMyKSB7XG4gIGlmIChTciAmJiB0eXBlb2YgU3IuZ2V0UmFuZG9tVmFsdWVzID09IFwiZnVuY3Rpb25cIilcbiAgICByZXR1cm4gU3IuZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KHQpKTtcbiAgdGhyb3cgbmV3IEVycm9yKFwiY3J5cHRvLmdldFJhbmRvbVZhbHVlcyBtdXN0IGJlIGRlZmluZWRcIik7XG59XG5jb25zdCBvbCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIHU4OiBZdSxcbiAgdTMyOiBKdSxcbiAgY3JlYXRlVmlldzogZnQsXG4gIHJvdHI6IEVlLFxuICBpc0xFOiBLcyxcbiAgYnl0ZXNUb0hleDogbmksXG4gIGhleFRvQnl0ZXM6IFdzLFxuICBuZXh0VGljazogVnMsXG4gIGFzeW5jTG9vcDogUXUsXG4gIHV0ZjhUb0J5dGVzOiBpaSxcbiAgdG9CeXRlczogT3QsXG4gIGNvbmNhdEJ5dGVzOiBlcixcbiAgSGFzaDogb2ksXG4gIGNoZWNrT3B0czogdGwsXG4gIHdyYXBDb25zdHJ1Y3RvcjogbnQsXG4gIHdyYXBDb25zdHJ1Y3RvcldpdGhPcHRzOiBybCxcbiAgd3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHM6IG5sLFxuICByYW5kb21CeXRlczogaWxcbn0sIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KSk7XG5mdW5jdGlvbiBzbCh0LCBlLCByLCBuKSB7XG4gIGlmICh0eXBlb2YgdC5zZXRCaWdVaW50NjQgPT0gXCJmdW5jdGlvblwiKVxuICAgIHJldHVybiB0LnNldEJpZ1VpbnQ2NChlLCByLCBuKTtcbiAgY29uc3QgaSA9IEJpZ0ludCgzMiksIHMgPSBCaWdJbnQoNDI5NDk2NzI5NSksIG8gPSBOdW1iZXIociA+PiBpICYgcyksIGEgPSBOdW1iZXIociAmIHMpLCBjID0gbiA/IDQgOiAwLCBsID0gbiA/IDAgOiA0O1xuICB0LnNldFVpbnQzMihlICsgYywgbywgbiksIHQuc2V0VWludDMyKGUgKyBsLCBhLCBuKTtcbn1cbmNsYXNzIHNpIGV4dGVuZHMgb2kge1xuICBjb25zdHJ1Y3RvcihlLCByLCBuLCBpKSB7XG4gICAgc3VwZXIoKSwgdGhpcy5ibG9ja0xlbiA9IGUsIHRoaXMub3V0cHV0TGVuID0gciwgdGhpcy5wYWRPZmZzZXQgPSBuLCB0aGlzLmlzTEUgPSBpLCB0aGlzLmZpbmlzaGVkID0gITEsIHRoaXMubGVuZ3RoID0gMCwgdGhpcy5wb3MgPSAwLCB0aGlzLmRlc3Ryb3llZCA9ICExLCB0aGlzLmJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGUpLCB0aGlzLnZpZXcgPSBmdCh0aGlzLmJ1ZmZlcik7XG4gIH1cbiAgdXBkYXRlKGUpIHtcbiAgICBRZS5leGlzdHModGhpcyk7XG4gICAgY29uc3QgeyB2aWV3OiByLCBidWZmZXI6IG4sIGJsb2NrTGVuOiBpIH0gPSB0aGlzO1xuICAgIGUgPSBPdChlKTtcbiAgICBjb25zdCBzID0gZS5sZW5ndGg7XG4gICAgZm9yIChsZXQgbyA9IDA7IG8gPCBzOyApIHtcbiAgICAgIGNvbnN0IGEgPSBNYXRoLm1pbihpIC0gdGhpcy5wb3MsIHMgLSBvKTtcbiAgICAgIGlmIChhID09PSBpKSB7XG4gICAgICAgIGNvbnN0IGMgPSBmdChlKTtcbiAgICAgICAgZm9yICg7IGkgPD0gcyAtIG87IG8gKz0gaSlcbiAgICAgICAgICB0aGlzLnByb2Nlc3MoYywgbyk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbi5zZXQoZS5zdWJhcnJheShvLCBvICsgYSksIHRoaXMucG9zKSwgdGhpcy5wb3MgKz0gYSwgbyArPSBhLCB0aGlzLnBvcyA9PT0gaSAmJiAodGhpcy5wcm9jZXNzKHIsIDApLCB0aGlzLnBvcyA9IDApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5sZW5ndGggKz0gZS5sZW5ndGgsIHRoaXMucm91bmRDbGVhbigpLCB0aGlzO1xuICB9XG4gIGRpZ2VzdEludG8oZSkge1xuICAgIFFlLmV4aXN0cyh0aGlzKSwgUWUub3V0cHV0KGUsIHRoaXMpLCB0aGlzLmZpbmlzaGVkID0gITA7XG4gICAgY29uc3QgeyBidWZmZXI6IHIsIHZpZXc6IG4sIGJsb2NrTGVuOiBpLCBpc0xFOiBzIH0gPSB0aGlzO1xuICAgIGxldCB7IHBvczogbyB9ID0gdGhpcztcbiAgICByW28rK10gPSAxMjgsIHRoaXMuYnVmZmVyLnN1YmFycmF5KG8pLmZpbGwoMCksIHRoaXMucGFkT2Zmc2V0ID4gaSAtIG8gJiYgKHRoaXMucHJvY2VzcyhuLCAwKSwgbyA9IDApO1xuICAgIGZvciAobGV0IHUgPSBvOyB1IDwgaTsgdSsrKVxuICAgICAgclt1XSA9IDA7XG4gICAgc2wobiwgaSAtIDgsIEJpZ0ludCh0aGlzLmxlbmd0aCAqIDgpLCBzKSwgdGhpcy5wcm9jZXNzKG4sIDApO1xuICAgIGNvbnN0IGEgPSBmdChlKSwgYyA9IHRoaXMub3V0cHV0TGVuO1xuICAgIGlmIChjICUgNClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIl9zaGEyOiBvdXRwdXRMZW4gc2hvdWxkIGJlIGFsaWduZWQgdG8gMzJiaXRcIik7XG4gICAgY29uc3QgbCA9IGMgLyA0LCBmID0gdGhpcy5nZXQoKTtcbiAgICBpZiAobCA+IGYubGVuZ3RoKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiX3NoYTI6IG91dHB1dExlbiBiaWdnZXIgdGhhbiBzdGF0ZVwiKTtcbiAgICBmb3IgKGxldCB1ID0gMDsgdSA8IGw7IHUrKylcbiAgICAgIGEuc2V0VWludDMyKDQgKiB1LCBmW3VdLCBzKTtcbiAgfVxuICBkaWdlc3QoKSB7XG4gICAgY29uc3QgeyBidWZmZXI6IGUsIG91dHB1dExlbjogciB9ID0gdGhpcztcbiAgICB0aGlzLmRpZ2VzdEludG8oZSk7XG4gICAgY29uc3QgbiA9IGUuc2xpY2UoMCwgcik7XG4gICAgcmV0dXJuIHRoaXMuZGVzdHJveSgpLCBuO1xuICB9XG4gIF9jbG9uZUludG8oZSkge1xuICAgIGUgfHwgKGUgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpKSwgZS5zZXQoLi4udGhpcy5nZXQoKSk7XG4gICAgY29uc3QgeyBibG9ja0xlbjogciwgYnVmZmVyOiBuLCBsZW5ndGg6IGksIGZpbmlzaGVkOiBzLCBkZXN0cm95ZWQ6IG8sIHBvczogYSB9ID0gdGhpcztcbiAgICByZXR1cm4gZS5sZW5ndGggPSBpLCBlLnBvcyA9IGEsIGUuZmluaXNoZWQgPSBzLCBlLmRlc3Ryb3llZCA9IG8sIGkgJSByICYmIGUuYnVmZmVyLnNldChuKSwgZTtcbiAgfVxufVxuY29uc3QgYWwgPSAodCwgZSwgcikgPT4gdCAmIGUgXiB+dCAmIHIsIGNsID0gKHQsIGUsIHIpID0+IHQgJiBlIF4gdCAmIHIgXiBlICYgciwgdWwgPSBuZXcgVWludDMyQXJyYXkoW1xuICAxMTE2MzUyNDA4LFxuICAxODk5NDQ3NDQxLFxuICAzMDQ5MzIzNDcxLFxuICAzOTIxMDA5NTczLFxuICA5NjE5ODcxNjMsXG4gIDE1MDg5NzA5OTMsXG4gIDI0NTM2MzU3NDgsXG4gIDI4NzA3NjMyMjEsXG4gIDM2MjQzODEwODAsXG4gIDMxMDU5ODQwMSxcbiAgNjA3MjI1Mjc4LFxuICAxNDI2ODgxOTg3LFxuICAxOTI1MDc4Mzg4LFxuICAyMTYyMDc4MjA2LFxuICAyNjE0ODg4MTAzLFxuICAzMjQ4MjIyNTgwLFxuICAzODM1MzkwNDAxLFxuICA0MDIyMjI0Nzc0LFxuICAyNjQzNDcwNzgsXG4gIDYwNDgwNzYyOCxcbiAgNzcwMjU1OTgzLFxuICAxMjQ5MTUwMTIyLFxuICAxNTU1MDgxNjkyLFxuICAxOTk2MDY0OTg2LFxuICAyNTU0MjIwODgyLFxuICAyODIxODM0MzQ5LFxuICAyOTUyOTk2ODA4LFxuICAzMjEwMzEzNjcxLFxuICAzMzM2NTcxODkxLFxuICAzNTg0NTI4NzExLFxuICAxMTM5MjY5OTMsXG4gIDMzODI0MTg5NSxcbiAgNjY2MzA3MjA1LFxuICA3NzM1Mjk5MTIsXG4gIDEyOTQ3NTczNzIsXG4gIDEzOTYxODIyOTEsXG4gIDE2OTUxODM3MDAsXG4gIDE5ODY2NjEwNTEsXG4gIDIxNzcwMjYzNTAsXG4gIDI0NTY5NTYwMzcsXG4gIDI3MzA0ODU5MjEsXG4gIDI4MjAzMDI0MTEsXG4gIDMyNTk3MzA4MDAsXG4gIDMzNDU3NjQ3NzEsXG4gIDM1MTYwNjU4MTcsXG4gIDM2MDAzNTI4MDQsXG4gIDQwOTQ1NzE5MDksXG4gIDI3NTQyMzM0NCxcbiAgNDMwMjI3NzM0LFxuICA1MDY5NDg2MTYsXG4gIDY1OTA2MDU1NixcbiAgODgzOTk3ODc3LFxuICA5NTgxMzk1NzEsXG4gIDEzMjI4MjIyMTgsXG4gIDE1MzcwMDIwNjMsXG4gIDE3NDc4NzM3NzksXG4gIDE5NTU1NjIyMjIsXG4gIDIwMjQxMDQ4MTUsXG4gIDIyMjc3MzA0NTIsXG4gIDIzNjE4NTI0MjQsXG4gIDI0Mjg0MzY0NzQsXG4gIDI3NTY3MzQxODcsXG4gIDMyMDQwMzE0NzksXG4gIDMzMjkzMjUyOThcbl0pLCBLZSA9IG5ldyBVaW50MzJBcnJheShbXG4gIDE3NzkwMzM3MDMsXG4gIDMxNDQxMzQyNzcsXG4gIDEwMTM5MDQyNDIsXG4gIDI3NzM0ODA3NjIsXG4gIDEzNTk4OTMxMTksXG4gIDI2MDA4MjI5MjQsXG4gIDUyODczNDYzNSxcbiAgMTU0MTQ1OTIyNVxuXSksIFdlID0gbmV3IFVpbnQzMkFycmF5KDY0KTtcbmNsYXNzIEdzIGV4dGVuZHMgc2kge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcig2NCwgMzIsIDgsICExKSwgdGhpcy5BID0gS2VbMF0gfCAwLCB0aGlzLkIgPSBLZVsxXSB8IDAsIHRoaXMuQyA9IEtlWzJdIHwgMCwgdGhpcy5EID0gS2VbM10gfCAwLCB0aGlzLkUgPSBLZVs0XSB8IDAsIHRoaXMuRiA9IEtlWzVdIHwgMCwgdGhpcy5HID0gS2VbNl0gfCAwLCB0aGlzLkggPSBLZVs3XSB8IDA7XG4gIH1cbiAgZ2V0KCkge1xuICAgIGNvbnN0IHsgQTogZSwgQjogciwgQzogbiwgRDogaSwgRTogcywgRjogbywgRzogYSwgSDogYyB9ID0gdGhpcztcbiAgICByZXR1cm4gW2UsIHIsIG4sIGksIHMsIG8sIGEsIGNdO1xuICB9XG4gIHNldChlLCByLCBuLCBpLCBzLCBvLCBhLCBjKSB7XG4gICAgdGhpcy5BID0gZSB8IDAsIHRoaXMuQiA9IHIgfCAwLCB0aGlzLkMgPSBuIHwgMCwgdGhpcy5EID0gaSB8IDAsIHRoaXMuRSA9IHMgfCAwLCB0aGlzLkYgPSBvIHwgMCwgdGhpcy5HID0gYSB8IDAsIHRoaXMuSCA9IGMgfCAwO1xuICB9XG4gIHByb2Nlc3MoZSwgcikge1xuICAgIGZvciAobGV0IHUgPSAwOyB1IDwgMTY7IHUrKywgciArPSA0KVxuICAgICAgV2VbdV0gPSBlLmdldFVpbnQzMihyLCAhMSk7XG4gICAgZm9yIChsZXQgdSA9IDE2OyB1IDwgNjQ7IHUrKykge1xuICAgICAgY29uc3QgaCA9IFdlW3UgLSAxNV0sIGQgPSBXZVt1IC0gMl0sIHAgPSBFZShoLCA3KSBeIEVlKGgsIDE4KSBeIGggPj4+IDMsIHkgPSBFZShkLCAxNykgXiBFZShkLCAxOSkgXiBkID4+PiAxMDtcbiAgICAgIFdlW3VdID0geSArIFdlW3UgLSA3XSArIHAgKyBXZVt1IC0gMTZdIHwgMDtcbiAgICB9XG4gICAgbGV0IHsgQTogbiwgQjogaSwgQzogcywgRDogbywgRTogYSwgRjogYywgRzogbCwgSDogZiB9ID0gdGhpcztcbiAgICBmb3IgKGxldCB1ID0gMDsgdSA8IDY0OyB1KyspIHtcbiAgICAgIGNvbnN0IGggPSBFZShhLCA2KSBeIEVlKGEsIDExKSBeIEVlKGEsIDI1KSwgZCA9IGYgKyBoICsgYWwoYSwgYywgbCkgKyB1bFt1XSArIFdlW3VdIHwgMCwgeSA9IChFZShuLCAyKSBeIEVlKG4sIDEzKSBeIEVlKG4sIDIyKSkgKyBjbChuLCBpLCBzKSB8IDA7XG4gICAgICBmID0gbCwgbCA9IGMsIGMgPSBhLCBhID0gbyArIGQgfCAwLCBvID0gcywgcyA9IGksIGkgPSBuLCBuID0gZCArIHkgfCAwO1xuICAgIH1cbiAgICBuID0gbiArIHRoaXMuQSB8IDAsIGkgPSBpICsgdGhpcy5CIHwgMCwgcyA9IHMgKyB0aGlzLkMgfCAwLCBvID0gbyArIHRoaXMuRCB8IDAsIGEgPSBhICsgdGhpcy5FIHwgMCwgYyA9IGMgKyB0aGlzLkYgfCAwLCBsID0gbCArIHRoaXMuRyB8IDAsIGYgPSBmICsgdGhpcy5IIHwgMCwgdGhpcy5zZXQobiwgaSwgcywgbywgYSwgYywgbCwgZik7XG4gIH1cbiAgcm91bmRDbGVhbigpIHtcbiAgICBXZS5maWxsKDApO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCksIHRoaXMuYnVmZmVyLmZpbGwoMCk7XG4gIH1cbn1cbmNsYXNzIGxsIGV4dGVuZHMgR3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpLCB0aGlzLkEgPSAtMTA1NjU5NjI2NCwgdGhpcy5CID0gOTE0MTUwNjYzLCB0aGlzLkMgPSA4MTI3MDI5OTksIHRoaXMuRCA9IC0xNTAwNTQ1OTksIHRoaXMuRSA9IC00MTkxNDM5LCB0aGlzLkYgPSAxNzUwNjAzMDI1LCB0aGlzLkcgPSAxNjk0MDc2ODM5LCB0aGlzLkggPSAtMTA5MDg5MTg2OCwgdGhpcy5vdXRwdXRMZW4gPSAyODtcbiAgfVxufVxuY29uc3QganIgPSBudCgoKSA9PiBuZXcgR3MoKSksIGZsID0gbnQoKCkgPT4gbmV3IGxsKCkpLCBobCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIHNoYTI1NjoganIsXG4gIHNoYTIyNDogZmxcbn0sIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KSksIGRsID0gLyogQF9fUFVSRV9fICovIEV0KGhsKSwgZHIgPSBCaWdJbnQoMiAqKiAzMiAtIDEpLCAkbiA9IEJpZ0ludCgzMik7XG5mdW5jdGlvbiBacyh0LCBlID0gITEpIHtcbiAgcmV0dXJuIGUgPyB7IGg6IE51bWJlcih0ICYgZHIpLCBsOiBOdW1iZXIodCA+PiAkbiAmIGRyKSB9IDogeyBoOiBOdW1iZXIodCA+PiAkbiAmIGRyKSB8IDAsIGw6IE51bWJlcih0ICYgZHIpIHwgMCB9O1xufVxuZnVuY3Rpb24gcGwodCwgZSA9ICExKSB7XG4gIGxldCByID0gbmV3IFVpbnQzMkFycmF5KHQubGVuZ3RoKSwgbiA9IG5ldyBVaW50MzJBcnJheSh0Lmxlbmd0aCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHsgaDogcywgbDogbyB9ID0gWnModFtpXSwgZSk7XG4gICAgW3JbaV0sIG5baV1dID0gW3MsIG9dO1xuICB9XG4gIHJldHVybiBbciwgbl07XG59XG5jb25zdCB5bCA9ICh0LCBlKSA9PiBCaWdJbnQodCA+Pj4gMCkgPDwgJG4gfCBCaWdJbnQoZSA+Pj4gMCksIGdsID0gKHQsIGUsIHIpID0+IHQgPj4+IHIsIGJsID0gKHQsIGUsIHIpID0+IHQgPDwgMzIgLSByIHwgZSA+Pj4gciwgdmwgPSAodCwgZSwgcikgPT4gdCA+Pj4gciB8IGUgPDwgMzIgLSByLCB3bCA9ICh0LCBlLCByKSA9PiB0IDw8IDMyIC0gciB8IGUgPj4+IHIsIF9sID0gKHQsIGUsIHIpID0+IHQgPDwgNjQgLSByIHwgZSA+Pj4gciAtIDMyLCBtbCA9ICh0LCBlLCByKSA9PiB0ID4+PiByIC0gMzIgfCBlIDw8IDY0IC0gciwgeGwgPSAodCwgZSkgPT4gZSwgRWwgPSAodCwgZSkgPT4gdCwga2wgPSAodCwgZSwgcikgPT4gdCA8PCByIHwgZSA+Pj4gMzIgLSByLCBTbCA9ICh0LCBlLCByKSA9PiBlIDw8IHIgfCB0ID4+PiAzMiAtIHIsIE9sID0gKHQsIGUsIHIpID0+IGUgPDwgciAtIDMyIHwgdCA+Pj4gNjQgLSByLCBBbCA9ICh0LCBlLCByKSA9PiB0IDw8IHIgLSAzMiB8IGUgPj4+IDY0IC0gcjtcbmZ1bmN0aW9uIENsKHQsIGUsIHIsIG4pIHtcbiAgY29uc3QgaSA9IChlID4+PiAwKSArIChuID4+PiAwKTtcbiAgcmV0dXJuIHsgaDogdCArIHIgKyAoaSAvIDIgKiogMzIgfCAwKSB8IDAsIGw6IGkgfCAwIH07XG59XG5jb25zdCBJbCA9ICh0LCBlLCByKSA9PiAodCA+Pj4gMCkgKyAoZSA+Pj4gMCkgKyAociA+Pj4gMCksIFJsID0gKHQsIGUsIHIsIG4pID0+IGUgKyByICsgbiArICh0IC8gMiAqKiAzMiB8IDApIHwgMCwgVGwgPSAodCwgZSwgciwgbikgPT4gKHQgPj4+IDApICsgKGUgPj4+IDApICsgKHIgPj4+IDApICsgKG4gPj4+IDApLCBQbCA9ICh0LCBlLCByLCBuLCBpKSA9PiBlICsgciArIG4gKyBpICsgKHQgLyAyICoqIDMyIHwgMCkgfCAwLCBCbCA9ICh0LCBlLCByLCBuLCBpKSA9PiAodCA+Pj4gMCkgKyAoZSA+Pj4gMCkgKyAociA+Pj4gMCkgKyAobiA+Pj4gMCkgKyAoaSA+Pj4gMCksIExsID0gKHQsIGUsIHIsIG4sIGksIHMpID0+IGUgKyByICsgbiArIGkgKyBzICsgKHQgLyAyICoqIDMyIHwgMCkgfCAwLCBOID0ge1xuICBmcm9tQmlnOiBacyxcbiAgc3BsaXQ6IHBsLFxuICB0b0JpZzogeWwsXG4gIHNoclNIOiBnbCxcbiAgc2hyU0w6IGJsLFxuICByb3RyU0g6IHZsLFxuICByb3RyU0w6IHdsLFxuICByb3RyQkg6IF9sLFxuICByb3RyQkw6IG1sLFxuICByb3RyMzJIOiB4bCxcbiAgcm90cjMyTDogRWwsXG4gIHJvdGxTSDoga2wsXG4gIHJvdGxTTDogU2wsXG4gIHJvdGxCSDogT2wsXG4gIHJvdGxCTDogQWwsXG4gIGFkZDogQ2wsXG4gIGFkZDNMOiBJbCxcbiAgYWRkM0g6IFJsLFxuICBhZGQ0TDogVGwsXG4gIGFkZDRIOiBQbCxcbiAgYWRkNUg6IExsLFxuICBhZGQ1TDogQmxcbn0sIFskbCwgcWxdID0gTi5zcGxpdChbXG4gIFwiMHg0MjhhMmY5OGQ3MjhhZTIyXCIsXG4gIFwiMHg3MTM3NDQ5MTIzZWY2NWNkXCIsXG4gIFwiMHhiNWMwZmJjZmVjNGQzYjJmXCIsXG4gIFwiMHhlOWI1ZGJhNTgxODlkYmJjXCIsXG4gIFwiMHgzOTU2YzI1YmYzNDhiNTM4XCIsXG4gIFwiMHg1OWYxMTFmMWI2MDVkMDE5XCIsXG4gIFwiMHg5MjNmODJhNGFmMTk0ZjliXCIsXG4gIFwiMHhhYjFjNWVkNWRhNmQ4MTE4XCIsXG4gIFwiMHhkODA3YWE5OGEzMDMwMjQyXCIsXG4gIFwiMHgxMjgzNWIwMTQ1NzA2ZmJlXCIsXG4gIFwiMHgyNDMxODViZTRlZTRiMjhjXCIsXG4gIFwiMHg1NTBjN2RjM2Q1ZmZiNGUyXCIsXG4gIFwiMHg3MmJlNWQ3NGYyN2I4OTZmXCIsXG4gIFwiMHg4MGRlYjFmZTNiMTY5NmIxXCIsXG4gIFwiMHg5YmRjMDZhNzI1YzcxMjM1XCIsXG4gIFwiMHhjMTliZjE3NGNmNjkyNjk0XCIsXG4gIFwiMHhlNDliNjljMTllZjE0YWQyXCIsXG4gIFwiMHhlZmJlNDc4NjM4NGYyNWUzXCIsXG4gIFwiMHgwZmMxOWRjNjhiOGNkNWI1XCIsXG4gIFwiMHgyNDBjYTFjYzc3YWM5YzY1XCIsXG4gIFwiMHgyZGU5MmM2ZjU5MmIwMjc1XCIsXG4gIFwiMHg0YTc0ODRhYTZlYTZlNDgzXCIsXG4gIFwiMHg1Y2IwYTlkY2JkNDFmYmQ0XCIsXG4gIFwiMHg3NmY5ODhkYTgzMTE1M2I1XCIsXG4gIFwiMHg5ODNlNTE1MmVlNjZkZmFiXCIsXG4gIFwiMHhhODMxYzY2ZDJkYjQzMjEwXCIsXG4gIFwiMHhiMDAzMjdjODk4ZmIyMTNmXCIsXG4gIFwiMHhiZjU5N2ZjN2JlZWYwZWU0XCIsXG4gIFwiMHhjNmUwMGJmMzNkYTg4ZmMyXCIsXG4gIFwiMHhkNWE3OTE0NzkzMGFhNzI1XCIsXG4gIFwiMHgwNmNhNjM1MWUwMDM4MjZmXCIsXG4gIFwiMHgxNDI5Mjk2NzBhMGU2ZTcwXCIsXG4gIFwiMHgyN2I3MGE4NTQ2ZDIyZmZjXCIsXG4gIFwiMHgyZTFiMjEzODVjMjZjOTI2XCIsXG4gIFwiMHg0ZDJjNmRmYzVhYzQyYWVkXCIsXG4gIFwiMHg1MzM4MGQxMzlkOTViM2RmXCIsXG4gIFwiMHg2NTBhNzM1NDhiYWY2M2RlXCIsXG4gIFwiMHg3NjZhMGFiYjNjNzdiMmE4XCIsXG4gIFwiMHg4MWMyYzkyZTQ3ZWRhZWU2XCIsXG4gIFwiMHg5MjcyMmM4NTE0ODIzNTNiXCIsXG4gIFwiMHhhMmJmZThhMTRjZjEwMzY0XCIsXG4gIFwiMHhhODFhNjY0YmJjNDIzMDAxXCIsXG4gIFwiMHhjMjRiOGI3MGQwZjg5NzkxXCIsXG4gIFwiMHhjNzZjNTFhMzA2NTRiZTMwXCIsXG4gIFwiMHhkMTkyZTgxOWQ2ZWY1MjE4XCIsXG4gIFwiMHhkNjk5MDYyNDU1NjVhOTEwXCIsXG4gIFwiMHhmNDBlMzU4NTU3NzEyMDJhXCIsXG4gIFwiMHgxMDZhYTA3MDMyYmJkMWI4XCIsXG4gIFwiMHgxOWE0YzExNmI4ZDJkMGM4XCIsXG4gIFwiMHgxZTM3NmMwODUxNDFhYjUzXCIsXG4gIFwiMHgyNzQ4Nzc0Y2RmOGVlYjk5XCIsXG4gIFwiMHgzNGIwYmNiNWUxOWI0OGE4XCIsXG4gIFwiMHgzOTFjMGNiM2M1Yzk1YTYzXCIsXG4gIFwiMHg0ZWQ4YWE0YWUzNDE4YWNiXCIsXG4gIFwiMHg1YjljY2E0Zjc3NjNlMzczXCIsXG4gIFwiMHg2ODJlNmZmM2Q2YjJiOGEzXCIsXG4gIFwiMHg3NDhmODJlZTVkZWZiMmZjXCIsXG4gIFwiMHg3OGE1NjM2ZjQzMTcyZjYwXCIsXG4gIFwiMHg4NGM4NzgxNGExZjBhYjcyXCIsXG4gIFwiMHg4Y2M3MDIwODFhNjQzOWVjXCIsXG4gIFwiMHg5MGJlZmZmYTIzNjMxZTI4XCIsXG4gIFwiMHhhNDUwNmNlYmRlODJiZGU5XCIsXG4gIFwiMHhiZWY5YTNmN2IyYzY3OTE1XCIsXG4gIFwiMHhjNjcxNzhmMmUzNzI1MzJiXCIsXG4gIFwiMHhjYTI3M2VjZWVhMjY2MTljXCIsXG4gIFwiMHhkMTg2YjhjNzIxYzBjMjA3XCIsXG4gIFwiMHhlYWRhN2RkNmNkZTBlYjFlXCIsXG4gIFwiMHhmNTdkNGY3ZmVlNmVkMTc4XCIsXG4gIFwiMHgwNmYwNjdhYTcyMTc2ZmJhXCIsXG4gIFwiMHgwYTYzN2RjNWEyYzg5OGE2XCIsXG4gIFwiMHgxMTNmOTgwNGJlZjkwZGFlXCIsXG4gIFwiMHgxYjcxMGIzNTEzMWM0NzFiXCIsXG4gIFwiMHgyOGRiNzdmNTIzMDQ3ZDg0XCIsXG4gIFwiMHgzMmNhYWI3YjQwYzcyNDkzXCIsXG4gIFwiMHgzYzllYmUwYTE1YzliZWJjXCIsXG4gIFwiMHg0MzFkNjdjNDljMTAwZDRjXCIsXG4gIFwiMHg0Y2M1ZDRiZWNiM2U0MmI2XCIsXG4gIFwiMHg1OTdmMjk5Y2ZjNjU3ZTJhXCIsXG4gIFwiMHg1ZmNiNmZhYjNhZDZmYWVjXCIsXG4gIFwiMHg2YzQ0MTk4YzRhNDc1ODE3XCJcbl0ubWFwKCh0KSA9PiBCaWdJbnQodCkpKSwgVmUgPSBuZXcgVWludDMyQXJyYXkoODApLCBHZSA9IG5ldyBVaW50MzJBcnJheSg4MCk7XG5jbGFzcyBhciBleHRlbmRzIHNpIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoMTI4LCA2NCwgMTYsICExKSwgdGhpcy5BaCA9IDE3NzkwMzM3MDMsIHRoaXMuQWwgPSAtMjA1NzMxNTc2LCB0aGlzLkJoID0gLTExNTA4MzMwMTksIHRoaXMuQmwgPSAtMjA2NzA5MzcwMSwgdGhpcy5DaCA9IDEwMTM5MDQyNDIsIHRoaXMuQ2wgPSAtMjM3OTE1NzMsIHRoaXMuRGggPSAtMTUyMTQ4NjUzNCwgdGhpcy5EbCA9IDE1OTU3NTAxMjksIHRoaXMuRWggPSAxMzU5ODkzMTE5LCB0aGlzLkVsID0gLTEzNzc0MDIxNTksIHRoaXMuRmggPSAtMTY5NDE0NDM3MiwgdGhpcy5GbCA9IDcyNTUxMTE5OSwgdGhpcy5HaCA9IDUyODczNDYzNSwgdGhpcy5HbCA9IC03OTU3Nzc0OSwgdGhpcy5IaCA9IDE1NDE0NTkyMjUsIHRoaXMuSGwgPSAzMjcwMzMyMDk7XG4gIH1cbiAgZ2V0KCkge1xuICAgIGNvbnN0IHsgQWg6IGUsIEFsOiByLCBCaDogbiwgQmw6IGksIENoOiBzLCBDbDogbywgRGg6IGEsIERsOiBjLCBFaDogbCwgRWw6IGYsIEZoOiB1LCBGbDogaCwgR2g6IGQsIEdsOiBwLCBIaDogeSwgSGw6IGcgfSA9IHRoaXM7XG4gICAgcmV0dXJuIFtlLCByLCBuLCBpLCBzLCBvLCBhLCBjLCBsLCBmLCB1LCBoLCBkLCBwLCB5LCBnXTtcbiAgfVxuICBzZXQoZSwgciwgbiwgaSwgcywgbywgYSwgYywgbCwgZiwgdSwgaCwgZCwgcCwgeSwgZykge1xuICAgIHRoaXMuQWggPSBlIHwgMCwgdGhpcy5BbCA9IHIgfCAwLCB0aGlzLkJoID0gbiB8IDAsIHRoaXMuQmwgPSBpIHwgMCwgdGhpcy5DaCA9IHMgfCAwLCB0aGlzLkNsID0gbyB8IDAsIHRoaXMuRGggPSBhIHwgMCwgdGhpcy5EbCA9IGMgfCAwLCB0aGlzLkVoID0gbCB8IDAsIHRoaXMuRWwgPSBmIHwgMCwgdGhpcy5GaCA9IHUgfCAwLCB0aGlzLkZsID0gaCB8IDAsIHRoaXMuR2ggPSBkIHwgMCwgdGhpcy5HbCA9IHAgfCAwLCB0aGlzLkhoID0geSB8IDAsIHRoaXMuSGwgPSBnIHwgMDtcbiAgfVxuICBwcm9jZXNzKGUsIHIpIHtcbiAgICBmb3IgKGxldCBtID0gMDsgbSA8IDE2OyBtKyssIHIgKz0gNClcbiAgICAgIFZlW21dID0gZS5nZXRVaW50MzIociksIEdlW21dID0gZS5nZXRVaW50MzIociArPSA0KTtcbiAgICBmb3IgKGxldCBtID0gMTY7IG0gPCA4MDsgbSsrKSB7XG4gICAgICBjb25zdCBDID0gVmVbbSAtIDE1XSB8IDAsIE8gPSBHZVttIC0gMTVdIHwgMCwgdyA9IE4ucm90clNIKEMsIE8sIDEpIF4gTi5yb3RyU0goQywgTywgOCkgXiBOLnNoclNIKEMsIE8sIDcpLCB4ID0gTi5yb3RyU0woQywgTywgMSkgXiBOLnJvdHJTTChDLCBPLCA4KSBeIE4uc2hyU0woQywgTywgNyksIEEgPSBWZVttIC0gMl0gfCAwLCBCID0gR2VbbSAtIDJdIHwgMCwgTCA9IE4ucm90clNIKEEsIEIsIDE5KSBeIE4ucm90ckJIKEEsIEIsIDYxKSBeIE4uc2hyU0goQSwgQiwgNiksIFAgPSBOLnJvdHJTTChBLCBCLCAxOSkgXiBOLnJvdHJCTChBLCBCLCA2MSkgXiBOLnNoclNMKEEsIEIsIDYpLCBGID0gTi5hZGQ0TCh4LCBQLCBHZVttIC0gN10sIEdlW20gLSAxNl0pLCB6ID0gTi5hZGQ0SChGLCB3LCBMLCBWZVttIC0gN10sIFZlW20gLSAxNl0pO1xuICAgICAgVmVbbV0gPSB6IHwgMCwgR2VbbV0gPSBGIHwgMDtcbiAgICB9XG4gICAgbGV0IHsgQWg6IG4sIEFsOiBpLCBCaDogcywgQmw6IG8sIENoOiBhLCBDbDogYywgRGg6IGwsIERsOiBmLCBFaDogdSwgRWw6IGgsIEZoOiBkLCBGbDogcCwgR2g6IHksIEdsOiBnLCBIaDogdiwgSGw6IF8gfSA9IHRoaXM7XG4gICAgZm9yIChsZXQgbSA9IDA7IG0gPCA4MDsgbSsrKSB7XG4gICAgICBjb25zdCBDID0gTi5yb3RyU0godSwgaCwgMTQpIF4gTi5yb3RyU0godSwgaCwgMTgpIF4gTi5yb3RyQkgodSwgaCwgNDEpLCBPID0gTi5yb3RyU0wodSwgaCwgMTQpIF4gTi5yb3RyU0wodSwgaCwgMTgpIF4gTi5yb3RyQkwodSwgaCwgNDEpLCB3ID0gdSAmIGQgXiB+dSAmIHksIHggPSBoICYgcCBeIH5oICYgZywgQSA9IE4uYWRkNUwoXywgTywgeCwgcWxbbV0sIEdlW21dKSwgQiA9IE4uYWRkNUgoQSwgdiwgQywgdywgJGxbbV0sIFZlW21dKSwgTCA9IEEgfCAwLCBQID0gTi5yb3RyU0gobiwgaSwgMjgpIF4gTi5yb3RyQkgobiwgaSwgMzQpIF4gTi5yb3RyQkgobiwgaSwgMzkpLCBGID0gTi5yb3RyU0wobiwgaSwgMjgpIF4gTi5yb3RyQkwobiwgaSwgMzQpIF4gTi5yb3RyQkwobiwgaSwgMzkpLCB6ID0gbiAmIHMgXiBuICYgYSBeIHMgJiBhLCBHID0gaSAmIG8gXiBpICYgYyBeIG8gJiBjO1xuICAgICAgdiA9IHkgfCAwLCBfID0gZyB8IDAsIHkgPSBkIHwgMCwgZyA9IHAgfCAwLCBkID0gdSB8IDAsIHAgPSBoIHwgMCwgeyBoOiB1LCBsOiBoIH0gPSBOLmFkZChsIHwgMCwgZiB8IDAsIEIgfCAwLCBMIHwgMCksIGwgPSBhIHwgMCwgZiA9IGMgfCAwLCBhID0gcyB8IDAsIGMgPSBvIHwgMCwgcyA9IG4gfCAwLCBvID0gaSB8IDA7XG4gICAgICBjb25zdCBFID0gTi5hZGQzTChMLCBGLCBHKTtcbiAgICAgIG4gPSBOLmFkZDNIKEUsIEIsIFAsIHopLCBpID0gRSB8IDA7XG4gICAgfVxuICAgICh7IGg6IG4sIGw6IGkgfSA9IE4uYWRkKHRoaXMuQWggfCAwLCB0aGlzLkFsIHwgMCwgbiB8IDAsIGkgfCAwKSksIHsgaDogcywgbDogbyB9ID0gTi5hZGQodGhpcy5CaCB8IDAsIHRoaXMuQmwgfCAwLCBzIHwgMCwgbyB8IDApLCB7IGg6IGEsIGw6IGMgfSA9IE4uYWRkKHRoaXMuQ2ggfCAwLCB0aGlzLkNsIHwgMCwgYSB8IDAsIGMgfCAwKSwgeyBoOiBsLCBsOiBmIH0gPSBOLmFkZCh0aGlzLkRoIHwgMCwgdGhpcy5EbCB8IDAsIGwgfCAwLCBmIHwgMCksIHsgaDogdSwgbDogaCB9ID0gTi5hZGQodGhpcy5FaCB8IDAsIHRoaXMuRWwgfCAwLCB1IHwgMCwgaCB8IDApLCB7IGg6IGQsIGw6IHAgfSA9IE4uYWRkKHRoaXMuRmggfCAwLCB0aGlzLkZsIHwgMCwgZCB8IDAsIHAgfCAwKSwgeyBoOiB5LCBsOiBnIH0gPSBOLmFkZCh0aGlzLkdoIHwgMCwgdGhpcy5HbCB8IDAsIHkgfCAwLCBnIHwgMCksIHsgaDogdiwgbDogXyB9ID0gTi5hZGQodGhpcy5IaCB8IDAsIHRoaXMuSGwgfCAwLCB2IHwgMCwgXyB8IDApLCB0aGlzLnNldChuLCBpLCBzLCBvLCBhLCBjLCBsLCBmLCB1LCBoLCBkLCBwLCB5LCBnLCB2LCBfKTtcbiAgfVxuICByb3VuZENsZWFuKCkge1xuICAgIFZlLmZpbGwoMCksIEdlLmZpbGwoMCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmJ1ZmZlci5maWxsKDApLCB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgfVxufVxuY2xhc3MgTmwgZXh0ZW5kcyBhciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCksIHRoaXMuQWggPSAtMTk0MjE0NTA4MCwgdGhpcy5BbCA9IDQyNDk1NTI5OCwgdGhpcy5CaCA9IDE5NDQxNjQ3MTAsIHRoaXMuQmwgPSAtMTk4MjAxNjI5OCwgdGhpcy5DaCA9IDUwMjk3MDI4NiwgdGhpcy5DbCA9IDg1NTYxMjU0NiwgdGhpcy5EaCA9IDE3MzgzOTY5NDgsIHRoaXMuRGwgPSAxNDc5NTE2MTExLCB0aGlzLkVoID0gMjU4ODEyNzc3LCB0aGlzLkVsID0gMjA3NzUxMTA4MCwgdGhpcy5GaCA9IDIwMTEzOTM5MDcsIHRoaXMuRmwgPSA3OTk4OTA1OCwgdGhpcy5HaCA9IDEwNjcyODc5NzYsIHRoaXMuR2wgPSAxNzgwMjk5NDY0LCB0aGlzLkhoID0gMjg2NDUxMzczLCB0aGlzLkhsID0gLTE4NDgyMDg3MzUsIHRoaXMub3V0cHV0TGVuID0gMjg7XG4gIH1cbn1cbmNsYXNzIFVsIGV4dGVuZHMgYXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpLCB0aGlzLkFoID0gNTczNjQ1MjA0LCB0aGlzLkFsID0gLTY0MjI3NTQwLCB0aGlzLkJoID0gLTE2MjE3OTQ5MDksIHRoaXMuQmwgPSAtOTM0NTE3NTY2LCB0aGlzLkNoID0gNTk2ODgzNTYzLCB0aGlzLkNsID0gMTg2Nzc1NTg1NywgdGhpcy5EaCA9IC0xNzc0Njg0MzkxLCB0aGlzLkRsID0gMTQ5NzQyNjYyMSwgdGhpcy5FaCA9IC0xNzc1NzQ3MzU4LCB0aGlzLkVsID0gLTE0NjcwMjMzODksIHRoaXMuRmggPSAtMTEwMTEyODE1NSwgdGhpcy5GbCA9IDE0MDEzMDU0OTAsIHRoaXMuR2ggPSA3MjE1MjUyNDQsIHRoaXMuR2wgPSA3NDY5NjEwNjYsIHRoaXMuSGggPSAyNDY4ODU4NTIsIHRoaXMuSGwgPSAtMjExNzc4NDQxNCwgdGhpcy5vdXRwdXRMZW4gPSAzMjtcbiAgfVxufVxuY2xhc3MgamwgZXh0ZW5kcyBhciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCksIHRoaXMuQWggPSAtODc2ODk2OTMxLCB0aGlzLkFsID0gLTEwNTY1OTYyNjQsIHRoaXMuQmggPSAxNjU0MjcwMjUwLCB0aGlzLkJsID0gOTE0MTUwNjYzLCB0aGlzLkNoID0gLTE4NTY0Mzc5MjYsIHRoaXMuQ2wgPSA4MTI3MDI5OTksIHRoaXMuRGggPSAzNTU0NjIzNjAsIHRoaXMuRGwgPSAtMTUwMDU0NTk5LCB0aGlzLkVoID0gMTczMTQwNTQxNSwgdGhpcy5FbCA9IC00MTkxNDM5LCB0aGlzLkZoID0gLTE5MDA3ODcwNjUsIHRoaXMuRmwgPSAxNzUwNjAzMDI1LCB0aGlzLkdoID0gLTYxOTk1ODc3MSwgdGhpcy5HbCA9IDE2OTQwNzY4MzksIHRoaXMuSGggPSAxMjAzMDYyODEzLCB0aGlzLkhsID0gLTEwOTA4OTE4NjgsIHRoaXMub3V0cHV0TGVuID0gNDg7XG4gIH1cbn1cbmNvbnN0IHFuID0gbnQoKCkgPT4gbmV3IGFyKCkpLCBIbCA9IG50KCgpID0+IG5ldyBObCgpKSwgTWwgPSBudCgoKSA9PiBuZXcgVWwoKSksIERsID0gbnQoKCkgPT4gbmV3IGpsKCkpLCB6bCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIFNIQTUxMjogYXIsXG4gIHNoYTUxMjogcW4sXG4gIHNoYTUxMl8yMjQ6IEhsLFxuICBzaGE1MTJfMjU2OiBNbCxcbiAgc2hhMzg0OiBEbFxufSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pKSwgRmwgPSAvKiBAX19QVVJFX18gKi8gRXQoemwpLCBLbCA9IC8qIEBfX1BVUkVfXyAqLyBFdChvbCksIFdsID0gLyogQF9fUFVSRV9fICovIEV0KE11KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xudmFyIFlzID0gZGUubW5lbW9uaWNUb1NlZWRTeW5jID0gZGUubW5lbW9uaWNUb1NlZWQgPSBzYSA9IGRlLnZhbGlkYXRlTW5lbW9uaWMgPSBkZS5lbnRyb3B5VG9NbmVtb25pYyA9IGRlLm1uZW1vbmljVG9FbnRyb3B5ID0gcmEgPSBkZS5nZW5lcmF0ZU1uZW1vbmljID0gdm9pZCAwO1xuLyohIHNjdXJlLWJpcDM5IC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF0cmljaW8gUGFsbGFkaW5vLCBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmNvbnN0IEpzID0genUsIFhzID0geHQsIFZsID0gZGwsIFFzID0gRmwsIEdsID0gS2wsIHByID0gV2wsIFpsID0gKHQpID0+IHRbMF0gPT09IFwiXFx1MzA0MlxcdTMwNDRcXHUzMDUzXFx1MzA0RlxcdTMwNTdcXHUzMDkzXCI7XG5mdW5jdGlvbiBlYSh0KSB7XG4gIGlmICh0eXBlb2YgdCAhPSBcInN0cmluZ1wiKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgbW5lbW9uaWMgdHlwZTogJHt0eXBlb2YgdH1gKTtcbiAgcmV0dXJuIHQubm9ybWFsaXplKFwiTkZLRFwiKTtcbn1cbmZ1bmN0aW9uIGFpKHQpIHtcbiAgY29uc3QgZSA9IGVhKHQpLCByID0gZS5zcGxpdChcIiBcIik7XG4gIGlmICghWzEyLCAxNSwgMTgsIDIxLCAyNF0uaW5jbHVkZXMoci5sZW5ndGgpKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbW5lbW9uaWNcIik7XG4gIHJldHVybiB7IG5ma2Q6IGUsIHdvcmRzOiByIH07XG59XG5mdW5jdGlvbiB0YSh0KSB7XG4gIEpzLmRlZmF1bHQuYnl0ZXModCwgMTYsIDIwLCAyNCwgMjgsIDMyKTtcbn1cbmZ1bmN0aW9uIFlsKHQsIGUgPSAxMjgpIHtcbiAgaWYgKEpzLmRlZmF1bHQubnVtYmVyKGUpLCBlICUgMzIgIT09IDAgfHwgZSA+IDI1NilcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBlbnRyb3B5XCIpO1xuICByZXR1cm4gb2EoKDAsIEdsLnJhbmRvbUJ5dGVzKShlIC8gOCksIHQpO1xufVxudmFyIHJhID0gZGUuZ2VuZXJhdGVNbmVtb25pYyA9IFlsO1xuY29uc3QgSmwgPSAodCkgPT4ge1xuICBjb25zdCBlID0gOCAtIHQubGVuZ3RoIC8gNDtcbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsoMCwgVmwuc2hhMjU2KSh0KVswXSA+PiBlIDw8IGVdKTtcbn07XG5mdW5jdGlvbiBuYSh0KSB7XG4gIGlmICghQXJyYXkuaXNBcnJheSh0KSB8fCB0Lmxlbmd0aCAhPT0gMjA0OCB8fCB0eXBlb2YgdFswXSAhPSBcInN0cmluZ1wiKVxuICAgIHRocm93IG5ldyBFcnJvcihcIldvcmxpc3Q6IGV4cGVjdGVkIGFycmF5IG9mIDIwNDggc3RyaW5nc1wiKTtcbiAgcmV0dXJuIHQuZm9yRWFjaCgoZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgZSAhPSBcInN0cmluZ1wiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBXb3JkbGlzdDogbm9uLXN0cmluZyBlbGVtZW50OiAke2V9YCk7XG4gIH0pLCBwci51dGlscy5jaGFpbihwci51dGlscy5jaGVja3N1bSgxLCBKbCksIHByLnV0aWxzLnJhZGl4MigxMSwgITApLCBwci51dGlscy5hbHBoYWJldCh0KSk7XG59XG5mdW5jdGlvbiBpYSh0LCBlKSB7XG4gIGNvbnN0IHsgd29yZHM6IHIgfSA9IGFpKHQpLCBuID0gbmEoZSkuZGVjb2RlKHIpO1xuICByZXR1cm4gdGEobiksIG47XG59XG5kZS5tbmVtb25pY1RvRW50cm9weSA9IGlhO1xuZnVuY3Rpb24gb2EodCwgZSkge1xuICByZXR1cm4gdGEodCksIG5hKGUpLmVuY29kZSh0KS5qb2luKFpsKGUpID8gXCJcXHUzMDAwXCIgOiBcIiBcIik7XG59XG5kZS5lbnRyb3B5VG9NbmVtb25pYyA9IG9hO1xuZnVuY3Rpb24gWGwodCwgZSkge1xuICB0cnkge1xuICAgIGlhKHQsIGUpO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gITE7XG4gIH1cbiAgcmV0dXJuICEwO1xufVxudmFyIHNhID0gZGUudmFsaWRhdGVNbmVtb25pYyA9IFhsO1xuY29uc3QgYWEgPSAodCkgPT4gZWEoYG1uZW1vbmljJHt0fWApO1xuZnVuY3Rpb24gUWwodCwgZSA9IFwiXCIpIHtcbiAgcmV0dXJuICgwLCBYcy5wYmtkZjJBc3luYykoUXMuc2hhNTEyLCBhaSh0KS5uZmtkLCBhYShlKSwgeyBjOiAyMDQ4LCBka0xlbjogNjQgfSk7XG59XG5kZS5tbmVtb25pY1RvU2VlZCA9IFFsO1xuZnVuY3Rpb24gZWYodCwgZSA9IFwiXCIpIHtcbiAgcmV0dXJuICgwLCBYcy5wYmtkZjIpKFFzLnNoYTUxMiwgYWkodCkubmZrZCwgYWEoZSksIHsgYzogMjA0OCwgZGtMZW46IDY0IH0pO1xufVxuWXMgPSBkZS5tbmVtb25pY1RvU2VlZFN5bmMgPSBlZjtcbmNsYXNzIGNhIGV4dGVuZHMgb2kge1xuICBjb25zdHJ1Y3RvcihlLCByKSB7XG4gICAgc3VwZXIoKSwgdGhpcy5maW5pc2hlZCA9ICExLCB0aGlzLmRlc3Ryb3llZCA9ICExLCBRZS5oYXNoKGUpO1xuICAgIGNvbnN0IG4gPSBPdChyKTtcbiAgICBpZiAodGhpcy5pSGFzaCA9IGUuY3JlYXRlKCksIHR5cGVvZiB0aGlzLmlIYXNoLnVwZGF0ZSAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBpbnN0YW5jZSBvZiBjbGFzcyB3aGljaCBleHRlbmRzIHV0aWxzLkhhc2hcIik7XG4gICAgdGhpcy5ibG9ja0xlbiA9IHRoaXMuaUhhc2guYmxvY2tMZW4sIHRoaXMub3V0cHV0TGVuID0gdGhpcy5pSGFzaC5vdXRwdXRMZW47XG4gICAgY29uc3QgaSA9IHRoaXMuYmxvY2tMZW4sIHMgPSBuZXcgVWludDhBcnJheShpKTtcbiAgICBzLnNldChuLmxlbmd0aCA+IGkgPyBlLmNyZWF0ZSgpLnVwZGF0ZShuKS5kaWdlc3QoKSA6IG4pO1xuICAgIGZvciAobGV0IG8gPSAwOyBvIDwgcy5sZW5ndGg7IG8rKylcbiAgICAgIHNbb10gXj0gNTQ7XG4gICAgdGhpcy5pSGFzaC51cGRhdGUocyksIHRoaXMub0hhc2ggPSBlLmNyZWF0ZSgpO1xuICAgIGZvciAobGV0IG8gPSAwOyBvIDwgcy5sZW5ndGg7IG8rKylcbiAgICAgIHNbb10gXj0gMTA2O1xuICAgIHRoaXMub0hhc2gudXBkYXRlKHMpLCBzLmZpbGwoMCk7XG4gIH1cbiAgdXBkYXRlKGUpIHtcbiAgICByZXR1cm4gUWUuZXhpc3RzKHRoaXMpLCB0aGlzLmlIYXNoLnVwZGF0ZShlKSwgdGhpcztcbiAgfVxuICBkaWdlc3RJbnRvKGUpIHtcbiAgICBRZS5leGlzdHModGhpcyksIFFlLmJ5dGVzKGUsIHRoaXMub3V0cHV0TGVuKSwgdGhpcy5maW5pc2hlZCA9ICEwLCB0aGlzLmlIYXNoLmRpZ2VzdEludG8oZSksIHRoaXMub0hhc2gudXBkYXRlKGUpLCB0aGlzLm9IYXNoLmRpZ2VzdEludG8oZSksIHRoaXMuZGVzdHJveSgpO1xuICB9XG4gIGRpZ2VzdCgpIHtcbiAgICBjb25zdCBlID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5vSGFzaC5vdXRwdXRMZW4pO1xuICAgIHJldHVybiB0aGlzLmRpZ2VzdEludG8oZSksIGU7XG4gIH1cbiAgX2Nsb25lSW50byhlKSB7XG4gICAgZSB8fCAoZSA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLCB7fSkpO1xuICAgIGNvbnN0IHsgb0hhc2g6IHIsIGlIYXNoOiBuLCBmaW5pc2hlZDogaSwgZGVzdHJveWVkOiBzLCBibG9ja0xlbjogbywgb3V0cHV0TGVuOiBhIH0gPSB0aGlzO1xuICAgIHJldHVybiBlID0gZSwgZS5maW5pc2hlZCA9IGksIGUuZGVzdHJveWVkID0gcywgZS5ibG9ja0xlbiA9IG8sIGUub3V0cHV0TGVuID0gYSwgZS5vSGFzaCA9IHIuX2Nsb25lSW50byhlLm9IYXNoKSwgZS5pSGFzaCA9IG4uX2Nsb25lSW50byhlLmlIYXNoKSwgZTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZGVzdHJveWVkID0gITAsIHRoaXMub0hhc2guZGVzdHJveSgpLCB0aGlzLmlIYXNoLmRlc3Ryb3koKTtcbiAgfVxufVxuY29uc3QgTm4gPSAodCwgZSwgcikgPT4gbmV3IGNhKHQsIGUpLnVwZGF0ZShyKS5kaWdlc3QoKTtcbk5uLmNyZWF0ZSA9ICh0LCBlKSA9PiBuZXcgY2EodCwgZSk7XG5jb25zdCB0ZiA9IG5ldyBVaW50OEFycmF5KFs3LCA0LCAxMywgMSwgMTAsIDYsIDE1LCAzLCAxMiwgMCwgOSwgNSwgMiwgMTQsIDExLCA4XSksIHVhID0gVWludDhBcnJheS5mcm9tKHsgbGVuZ3RoOiAxNiB9LCAodCwgZSkgPT4gZSksIHJmID0gdWEubWFwKCh0KSA9PiAoOSAqIHQgKyA1KSAlIDE2KTtcbmxldCBjaSA9IFt1YV0sIHVpID0gW3JmXTtcbmZvciAobGV0IHQgPSAwOyB0IDwgNDsgdCsrKVxuICBmb3IgKGxldCBlIG9mIFtjaSwgdWldKVxuICAgIGUucHVzaChlW3RdLm1hcCgocikgPT4gdGZbcl0pKTtcbmNvbnN0IGxhID0gW1xuICBbMTEsIDE0LCAxNSwgMTIsIDUsIDgsIDcsIDksIDExLCAxMywgMTQsIDE1LCA2LCA3LCA5LCA4XSxcbiAgWzEyLCAxMywgMTEsIDE1LCA2LCA5LCA5LCA3LCAxMiwgMTUsIDExLCAxMywgNywgOCwgNywgN10sXG4gIFsxMywgMTUsIDE0LCAxMSwgNywgNywgNiwgOCwgMTMsIDE0LCAxMywgMTIsIDUsIDUsIDYsIDldLFxuICBbMTQsIDExLCAxMiwgMTQsIDgsIDYsIDUsIDUsIDE1LCAxMiwgMTUsIDE0LCA5LCA5LCA4LCA2XSxcbiAgWzE1LCAxMiwgMTMsIDEzLCA5LCA1LCA4LCA2LCAxNCwgMTEsIDEyLCAxMSwgOCwgNiwgNSwgNV1cbl0ubWFwKCh0KSA9PiBuZXcgVWludDhBcnJheSh0KSksIG5mID0gY2kubWFwKCh0LCBlKSA9PiB0Lm1hcCgocikgPT4gbGFbZV1bcl0pKSwgb2YgPSB1aS5tYXAoKHQsIGUpID0+IHQubWFwKChyKSA9PiBsYVtlXVtyXSkpLCBzZiA9IG5ldyBVaW50MzJBcnJheShbMCwgMTUxODUwMDI0OSwgMTg1OTc3NTM5MywgMjQwMDk1OTcwOCwgMjg0MDg1MzgzOF0pLCBhZiA9IG5ldyBVaW50MzJBcnJheShbMTM1MjgyOTkyNiwgMTU0ODYwMzY4NCwgMTgzNjA3MjY5MSwgMjA1Mzk5NDIxNywgMF0pLCB5ciA9ICh0LCBlKSA9PiB0IDw8IGUgfCB0ID4+PiAzMiAtIGU7XG5mdW5jdGlvbiBaaSh0LCBlLCByLCBuKSB7XG4gIHJldHVybiB0ID09PSAwID8gZSBeIHIgXiBuIDogdCA9PT0gMSA/IGUgJiByIHwgfmUgJiBuIDogdCA9PT0gMiA/IChlIHwgfnIpIF4gbiA6IHQgPT09IDMgPyBlICYgbiB8IHIgJiB+biA6IGUgXiAociB8IH5uKTtcbn1cbmNvbnN0IGdyID0gbmV3IFVpbnQzMkFycmF5KDE2KTtcbmNsYXNzIGNmIGV4dGVuZHMgc2kge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcig2NCwgMjAsIDgsICEwKSwgdGhpcy5oMCA9IDE3MzI1ODQxOTMsIHRoaXMuaDEgPSAtMjcxNzMzODc5LCB0aGlzLmgyID0gLTE3MzI1ODQxOTQsIHRoaXMuaDMgPSAyNzE3MzM4NzgsIHRoaXMuaDQgPSAtMTAwOTU4OTc3NjtcbiAgfVxuICBnZXQoKSB7XG4gICAgY29uc3QgeyBoMDogZSwgaDE6IHIsIGgyOiBuLCBoMzogaSwgaDQ6IHMgfSA9IHRoaXM7XG4gICAgcmV0dXJuIFtlLCByLCBuLCBpLCBzXTtcbiAgfVxuICBzZXQoZSwgciwgbiwgaSwgcykge1xuICAgIHRoaXMuaDAgPSBlIHwgMCwgdGhpcy5oMSA9IHIgfCAwLCB0aGlzLmgyID0gbiB8IDAsIHRoaXMuaDMgPSBpIHwgMCwgdGhpcy5oNCA9IHMgfCAwO1xuICB9XG4gIHByb2Nlc3MoZSwgcikge1xuICAgIGZvciAobGV0IGQgPSAwOyBkIDwgMTY7IGQrKywgciArPSA0KVxuICAgICAgZ3JbZF0gPSBlLmdldFVpbnQzMihyLCAhMCk7XG4gICAgbGV0IG4gPSB0aGlzLmgwIHwgMCwgaSA9IG4sIHMgPSB0aGlzLmgxIHwgMCwgbyA9IHMsIGEgPSB0aGlzLmgyIHwgMCwgYyA9IGEsIGwgPSB0aGlzLmgzIHwgMCwgZiA9IGwsIHUgPSB0aGlzLmg0IHwgMCwgaCA9IHU7XG4gICAgZm9yIChsZXQgZCA9IDA7IGQgPCA1OyBkKyspIHtcbiAgICAgIGNvbnN0IHAgPSA0IC0gZCwgeSA9IHNmW2RdLCBnID0gYWZbZF0sIHYgPSBjaVtkXSwgXyA9IHVpW2RdLCBtID0gbmZbZF0sIEMgPSBvZltkXTtcbiAgICAgIGZvciAobGV0IE8gPSAwOyBPIDwgMTY7IE8rKykge1xuICAgICAgICBjb25zdCB3ID0geXIobiArIFppKGQsIHMsIGEsIGwpICsgZ3JbdltPXV0gKyB5LCBtW09dKSArIHUgfCAwO1xuICAgICAgICBuID0gdSwgdSA9IGwsIGwgPSB5cihhLCAxMCkgfCAwLCBhID0gcywgcyA9IHc7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBPID0gMDsgTyA8IDE2OyBPKyspIHtcbiAgICAgICAgY29uc3QgdyA9IHlyKGkgKyBaaShwLCBvLCBjLCBmKSArIGdyW19bT11dICsgZywgQ1tPXSkgKyBoIHwgMDtcbiAgICAgICAgaSA9IGgsIGggPSBmLCBmID0geXIoYywgMTApIHwgMCwgYyA9IG8sIG8gPSB3O1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnNldCh0aGlzLmgxICsgYSArIGYgfCAwLCB0aGlzLmgyICsgbCArIGggfCAwLCB0aGlzLmgzICsgdSArIGkgfCAwLCB0aGlzLmg0ICsgbiArIG8gfCAwLCB0aGlzLmgwICsgcyArIGMgfCAwKTtcbiAgfVxuICByb3VuZENsZWFuKCkge1xuICAgIGdyLmZpbGwoMCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRlc3Ryb3llZCA9ICEwLCB0aGlzLmJ1ZmZlci5maWxsKDApLCB0aGlzLnNldCgwLCAwLCAwLCAwLCAwKTtcbiAgfVxufVxuY29uc3QgdWYgPSBudCgoKSA9PiBuZXcgY2YoKSksIGJyID0gdWUuUHJvamVjdGl2ZVBvaW50LCBsbiA9IEFzKGpyKTtcbmZ1bmN0aW9uIFlpKHQpIHtcbiAgcmV0dXJuIEJpZ0ludChgMHgke25pKHQpfWApO1xufVxuZnVuY3Rpb24gbGYodCkge1xuICByZXR1cm4gV3ModC50b1N0cmluZygxNikucGFkU3RhcnQoNjQsIFwiMFwiKSk7XG59XG5jb25zdCBmZiA9IGlpKFwiQml0Y29pbiBzZWVkXCIpLCBmbiA9IHsgcHJpdmF0ZTogNzYwNjYyNzYsIHB1YmxpYzogNzYwNjczNTggfSwgaG4gPSAyMTQ3NDgzNjQ4LCBoZiA9ICh0KSA9PiB1Zihqcih0KSksIGRmID0gKHQpID0+IGZ0KHQpLmdldFVpbnQzMigwLCAhMSksIHZyID0gKHQpID0+IHtcbiAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcih0KSB8fCB0IDwgMCB8fCB0ID4gMiAqKiAzMiAtIDEpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG51bWJlcj0ke3R9LiBTaG91bGQgYmUgZnJvbSAwIHRvIDIgKiogMzIgLSAxYCk7XG4gIGNvbnN0IGUgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgcmV0dXJuIGZ0KGUpLnNldFVpbnQzMigwLCB0LCAhMSksIGU7XG59O1xuY2xhc3MgY3Qge1xuICBnZXQgZmluZ2VycHJpbnQoKSB7XG4gICAgaWYgKCF0aGlzLnB1Ykhhc2gpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBwdWJsaWNLZXkgc2V0IVwiKTtcbiAgICByZXR1cm4gZGYodGhpcy5wdWJIYXNoKTtcbiAgfVxuICBnZXQgaWRlbnRpZmllcigpIHtcbiAgICByZXR1cm4gdGhpcy5wdWJIYXNoO1xuICB9XG4gIGdldCBwdWJLZXlIYXNoKCkge1xuICAgIHJldHVybiB0aGlzLnB1Ykhhc2g7XG4gIH1cbiAgZ2V0IHByaXZhdGVLZXkoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJpdktleUJ5dGVzIHx8IG51bGw7XG4gIH1cbiAgZ2V0IHB1YmxpY0tleSgpIHtcbiAgICByZXR1cm4gdGhpcy5wdWJLZXkgfHwgbnVsbDtcbiAgfVxuICBnZXQgcHJpdmF0ZUV4dGVuZGVkS2V5KCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLnByaXZhdGVLZXk7XG4gICAgaWYgKCFlKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gcHJpdmF0ZSBrZXlcIik7XG4gICAgcmV0dXJuIGxuLmVuY29kZSh0aGlzLnNlcmlhbGl6ZSh0aGlzLnZlcnNpb25zLnByaXZhdGUsIGVyKG5ldyBVaW50OEFycmF5KFswXSksIGUpKSk7XG4gIH1cbiAgZ2V0IHB1YmxpY0V4dGVuZGVkS2V5KCkge1xuICAgIGlmICghdGhpcy5wdWJLZXkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBwdWJsaWMga2V5XCIpO1xuICAgIHJldHVybiBsbi5lbmNvZGUodGhpcy5zZXJpYWxpemUodGhpcy52ZXJzaW9ucy5wdWJsaWMsIHRoaXMucHViS2V5KSk7XG4gIH1cbiAgc3RhdGljIGZyb21NYXN0ZXJTZWVkKGUsIHIgPSBmbikge1xuICAgIGlmIChZZShlKSwgOCAqIGUubGVuZ3RoIDwgMTI4IHx8IDggKiBlLmxlbmd0aCA+IDUxMilcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSERLZXk6IHdyb25nIHNlZWQgbGVuZ3RoPSR7ZS5sZW5ndGh9LiBTaG91bGQgYmUgYmV0d2VlbiAxMjggYW5kIDUxMiBiaXRzOyAyNTYgYml0cyBpcyBhZHZpc2VkKWApO1xuICAgIGNvbnN0IG4gPSBObihxbiwgZmYsIGUpO1xuICAgIHJldHVybiBuZXcgY3Qoe1xuICAgICAgdmVyc2lvbnM6IHIsXG4gICAgICBjaGFpbkNvZGU6IG4uc2xpY2UoMzIpLFxuICAgICAgcHJpdmF0ZUtleTogbi5zbGljZSgwLCAzMilcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZnJvbUV4dGVuZGVkS2V5KGUsIHIgPSBmbikge1xuICAgIGNvbnN0IG4gPSBsbi5kZWNvZGUoZSksIGkgPSBmdChuKSwgcyA9IGkuZ2V0VWludDMyKDAsICExKSwgbyA9IHtcbiAgICAgIHZlcnNpb25zOiByLFxuICAgICAgZGVwdGg6IG5bNF0sXG4gICAgICBwYXJlbnRGaW5nZXJwcmludDogaS5nZXRVaW50MzIoNSwgITEpLFxuICAgICAgaW5kZXg6IGkuZ2V0VWludDMyKDksICExKSxcbiAgICAgIGNoYWluQ29kZTogbi5zbGljZSgxMywgNDUpXG4gICAgfSwgYSA9IG4uc2xpY2UoNDUpLCBjID0gYVswXSA9PT0gMDtcbiAgICBpZiAocyAhPT0gcltjID8gXCJwcml2YXRlXCIgOiBcInB1YmxpY1wiXSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlZlcnNpb24gbWlzbWF0Y2hcIik7XG4gICAgcmV0dXJuIGMgPyBuZXcgY3QoeyAuLi5vLCBwcml2YXRlS2V5OiBhLnNsaWNlKDEpIH0pIDogbmV3IGN0KHsgLi4ubywgcHVibGljS2V5OiBhIH0pO1xuICB9XG4gIHN0YXRpYyBmcm9tSlNPTihlKSB7XG4gICAgcmV0dXJuIGN0LmZyb21FeHRlbmRlZEtleShlLnhwcml2KTtcbiAgfVxuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgaWYgKHRoaXMuZGVwdGggPSAwLCB0aGlzLmluZGV4ID0gMCwgdGhpcy5jaGFpbkNvZGUgPSBudWxsLCB0aGlzLnBhcmVudEZpbmdlcnByaW50ID0gMCwgIWUgfHwgdHlwZW9mIGUgIT0gXCJvYmplY3RcIilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkhES2V5LmNvbnN0cnVjdG9yIG11c3Qgbm90IGJlIGNhbGxlZCBkaXJlY3RseVwiKTtcbiAgICBpZiAodGhpcy52ZXJzaW9ucyA9IGUudmVyc2lvbnMgfHwgZm4sIHRoaXMuZGVwdGggPSBlLmRlcHRoIHx8IDAsIHRoaXMuY2hhaW5Db2RlID0gZS5jaGFpbkNvZGUsIHRoaXMuaW5kZXggPSBlLmluZGV4IHx8IDAsIHRoaXMucGFyZW50RmluZ2VycHJpbnQgPSBlLnBhcmVudEZpbmdlcnByaW50IHx8IDAsICF0aGlzLmRlcHRoICYmICh0aGlzLnBhcmVudEZpbmdlcnByaW50IHx8IHRoaXMuaW5kZXgpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSERLZXk6IHplcm8gZGVwdGggd2l0aCBub24temVybyBpbmRleC9wYXJlbnQgZmluZ2VycHJpbnRcIik7XG4gICAgaWYgKGUucHVibGljS2V5ICYmIGUucHJpdmF0ZUtleSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkhES2V5OiBwdWJsaWNLZXkgYW5kIHByaXZhdGVLZXkgYXQgc2FtZSB0aW1lLlwiKTtcbiAgICBpZiAoZS5wcml2YXRlS2V5KSB7XG4gICAgICBpZiAoIXVlLnV0aWxzLmlzVmFsaWRQcml2YXRlS2V5KGUucHJpdmF0ZUtleSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcHJpdmF0ZSBrZXlcIik7XG4gICAgICB0aGlzLnByaXZLZXkgPSB0eXBlb2YgZS5wcml2YXRlS2V5ID09IFwiYmlnaW50XCIgPyBlLnByaXZhdGVLZXkgOiBZaShlLnByaXZhdGVLZXkpLCB0aGlzLnByaXZLZXlCeXRlcyA9IGxmKHRoaXMucHJpdktleSksIHRoaXMucHViS2V5ID0gdWUuZ2V0UHVibGljS2V5KGUucHJpdmF0ZUtleSwgITApO1xuICAgIH0gZWxzZSBpZiAoZS5wdWJsaWNLZXkpXG4gICAgICB0aGlzLnB1YktleSA9IGJyLmZyb21IZXgoZS5wdWJsaWNLZXkpLnRvUmF3Qnl0ZXMoITApO1xuICAgIGVsc2VcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkhES2V5OiBubyBwdWJsaWMgb3IgcHJpdmF0ZSBrZXkgcHJvdmlkZWRcIik7XG4gICAgdGhpcy5wdWJIYXNoID0gaGYodGhpcy5wdWJLZXkpO1xuICB9XG4gIGRlcml2ZShlKSB7XG4gICAgaWYgKCEvXlttTV0nPy8udGVzdChlKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGF0aCBtdXN0IHN0YXJ0IHdpdGggXCJtXCIgb3IgXCJNXCInKTtcbiAgICBpZiAoL15bbU1dJz8kLy50ZXN0KGUpKVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgciA9IGUucmVwbGFjZSgvXlttTV0nP1xcLy8sIFwiXCIpLnNwbGl0KFwiL1wiKTtcbiAgICBsZXQgbiA9IHRoaXM7XG4gICAgZm9yIChjb25zdCBpIG9mIHIpIHtcbiAgICAgIGNvbnN0IHMgPSAvXihcXGQrKSgnPykkLy5leGVjKGkpO1xuICAgICAgaWYgKCFzIHx8IHMubGVuZ3RoICE9PSAzKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY2hpbGQgaW5kZXg6ICR7aX1gKTtcbiAgICAgIGxldCBvID0gK3NbMV07XG4gICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG8pIHx8IG8gPj0gaG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5kZXhcIik7XG4gICAgICBzWzJdID09PSBcIidcIiAmJiAobyArPSBobiksIG4gPSBuLmRlcml2ZUNoaWxkKG8pO1xuICAgIH1cbiAgICByZXR1cm4gbjtcbiAgfVxuICBkZXJpdmVDaGlsZChlKSB7XG4gICAgaWYgKCF0aGlzLnB1YktleSB8fCAhdGhpcy5jaGFpbkNvZGUpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBwdWJsaWNLZXkgb3IgY2hhaW5Db2RlIHNldFwiKTtcbiAgICBsZXQgciA9IHZyKGUpO1xuICAgIGlmIChlID49IGhuKSB7XG4gICAgICBjb25zdCBhID0gdGhpcy5wcml2YXRlS2V5O1xuICAgICAgaWYgKCFhKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZGVyaXZlIGhhcmRlbmVkIGNoaWxkIGtleVwiKTtcbiAgICAgIHIgPSBlcihuZXcgVWludDhBcnJheShbMF0pLCBhLCByKTtcbiAgICB9IGVsc2VcbiAgICAgIHIgPSBlcih0aGlzLnB1YktleSwgcik7XG4gICAgY29uc3QgbiA9IE5uKHFuLCB0aGlzLmNoYWluQ29kZSwgciksIGkgPSBZaShuLnNsaWNlKDAsIDMyKSksIHMgPSBuLnNsaWNlKDMyKTtcbiAgICBpZiAoIXVlLnV0aWxzLmlzVmFsaWRQcml2YXRlS2V5KGkpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHdlYWsgYmlnZ2VyIHRoYW4gY3VydmUgb3JkZXJcIik7XG4gICAgY29uc3QgbyA9IHtcbiAgICAgIHZlcnNpb25zOiB0aGlzLnZlcnNpb25zLFxuICAgICAgY2hhaW5Db2RlOiBzLFxuICAgICAgZGVwdGg6IHRoaXMuZGVwdGggKyAxLFxuICAgICAgcGFyZW50RmluZ2VycHJpbnQ6IHRoaXMuZmluZ2VycHJpbnQsXG4gICAgICBpbmRleDogZVxuICAgIH07XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0aGlzLnByaXZhdGVLZXkpIHtcbiAgICAgICAgY29uc3QgYSA9IEoodGhpcy5wcml2S2V5ICsgaSwgdWUuQ1VSVkUubik7XG4gICAgICAgIGlmICghdWUudXRpbHMuaXNWYWxpZFByaXZhdGVLZXkoYSkpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHR3ZWFrIHdhcyBvdXQgb2YgcmFuZ2Ugb3IgdGhlIHJlc3VsdGVkIHByaXZhdGUga2V5IGlzIGludmFsaWRcIik7XG4gICAgICAgIG8ucHJpdmF0ZUtleSA9IGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBhID0gYnIuZnJvbUhleCh0aGlzLnB1YktleSkuYWRkKGJyLmZyb21Qcml2YXRlS2V5KGkpKTtcbiAgICAgICAgaWYgKGEuZXF1YWxzKGJyLlpFUk8pKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSB0d2VhayB3YXMgZXF1YWwgdG8gbmVnYXRpdmUgUCwgd2hpY2ggbWFkZSB0aGUgcmVzdWx0IGtleSBpbnZhbGlkXCIpO1xuICAgICAgICBvLnB1YmxpY0tleSA9IGEudG9SYXdCeXRlcyghMCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IGN0KG8pO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIHRoaXMuZGVyaXZlQ2hpbGQoZSArIDEpO1xuICAgIH1cbiAgfVxuICBzaWduKGUpIHtcbiAgICBpZiAoIXRoaXMucHJpdmF0ZUtleSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHByaXZhdGVLZXkgc2V0IVwiKTtcbiAgICByZXR1cm4gWWUoZSwgMzIpLCB1ZS5zaWduKGUsIHRoaXMucHJpdktleSkudG9Db21wYWN0UmF3Qnl0ZXMoKTtcbiAgfVxuICB2ZXJpZnkoZSwgcikge1xuICAgIGlmIChZZShlLCAzMiksIFllKHIsIDY0KSwgIXRoaXMucHVibGljS2V5KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gcHVibGljS2V5IHNldCFcIik7XG4gICAgbGV0IG47XG4gICAgdHJ5IHtcbiAgICAgIG4gPSB1ZS5TaWduYXR1cmUuZnJvbUNvbXBhY3Qocik7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gITE7XG4gICAgfVxuICAgIHJldHVybiB1ZS52ZXJpZnkobiwgZSwgdGhpcy5wdWJsaWNLZXkpO1xuICB9XG4gIHdpcGVQcml2YXRlRGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5wcml2S2V5ID0gdm9pZCAwLCB0aGlzLnByaXZLZXlCeXRlcyAmJiAodGhpcy5wcml2S2V5Qnl0ZXMuZmlsbCgwKSwgdGhpcy5wcml2S2V5Qnl0ZXMgPSB2b2lkIDApLCB0aGlzO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeHByaXY6IHRoaXMucHJpdmF0ZUV4dGVuZGVkS2V5LFxuICAgICAgeHB1YjogdGhpcy5wdWJsaWNFeHRlbmRlZEtleVxuICAgIH07XG4gIH1cbiAgc2VyaWFsaXplKGUsIHIpIHtcbiAgICBpZiAoIXRoaXMuY2hhaW5Db2RlKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gY2hhaW5Db2RlIHNldFwiKTtcbiAgICByZXR1cm4gWWUociwgMzMpLCBlcih2cihlKSwgbmV3IFVpbnQ4QXJyYXkoW3RoaXMuZGVwdGhdKSwgdnIodGhpcy5wYXJlbnRGaW5nZXJwcmludCksIHZyKHRoaXMuaW5kZXgpLCB0aGlzLmNoYWluQ29kZSwgcik7XG4gIH1cbn1cbnZhciBwZiA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgaWUgPSAodCwgZSkgPT4ge1xuICBmb3IgKHZhciByIGluIGUpXG4gICAgcGYodCwgciwgeyBnZXQ6IGVbcl0sIGVudW1lcmFibGU6ICEwIH0pO1xufTtcbmZ1bmN0aW9uIHlmKCkge1xuICByZXR1cm4gdmUoU3QudXRpbHMucmFuZG9tUHJpdmF0ZUtleSgpKTtcbn1cbmZ1bmN0aW9uIGxpKHQpIHtcbiAgcmV0dXJuIHZlKFN0LmdldFB1YmxpY0tleSh0KSk7XG59XG52YXIgZ2YgPSB7fTtcbmllKGdmLCB7XG4gIE1lc3NhZ2VOb2RlOiAoKSA9PiBmYSxcbiAgTWVzc2FnZVF1ZXVlOiAoKSA9PiBoYSxcbiAgaW5zZXJ0RXZlbnRJbnRvQXNjZW5kaW5nTGlzdDogKCkgPT4gd2YsXG4gIGluc2VydEV2ZW50SW50b0Rlc2NlbmRpbmdMaXN0OiAoKSA9PiB2ZixcbiAgbm9ybWFsaXplVVJMOiAoKSA9PiBiZixcbiAgdXRmOERlY29kZXI6ICgpID0+IEplLFxuICB1dGY4RW5jb2RlcjogKCkgPT4gSWVcbn0pO1xudmFyIEplID0gbmV3IFRleHREZWNvZGVyKFwidXRmLThcIiksIEllID0gbmV3IFRleHRFbmNvZGVyKCk7XG5mdW5jdGlvbiBiZih0KSB7XG4gIGxldCBlID0gbmV3IFVSTCh0KTtcbiAgcmV0dXJuIGUucGF0aG5hbWUgPSBlLnBhdGhuYW1lLnJlcGxhY2UoL1xcLysvZywgXCIvXCIpLCBlLnBhdGhuYW1lLmVuZHNXaXRoKFwiL1wiKSAmJiAoZS5wYXRobmFtZSA9IGUucGF0aG5hbWUuc2xpY2UoMCwgLTEpKSwgKGUucG9ydCA9PT0gXCI4MFwiICYmIGUucHJvdG9jb2wgPT09IFwid3M6XCIgfHwgZS5wb3J0ID09PSBcIjQ0M1wiICYmIGUucHJvdG9jb2wgPT09IFwid3NzOlwiKSAmJiAoZS5wb3J0ID0gXCJcIiksIGUuc2VhcmNoUGFyYW1zLnNvcnQoKSwgZS5oYXNoID0gXCJcIiwgZS50b1N0cmluZygpO1xufVxuZnVuY3Rpb24gdmYodCwgZSkge1xuICB2YXIgbztcbiAgbGV0IHIgPSAwLCBuID0gdC5sZW5ndGggLSAxLCBpLCBzID0gcjtcbiAgaWYgKG4gPCAwKVxuICAgIHMgPSAwO1xuICBlbHNlIGlmIChlLmNyZWF0ZWRfYXQgPCB0W25dLmNyZWF0ZWRfYXQpXG4gICAgcyA9IG4gKyAxO1xuICBlbHNlIGlmIChlLmNyZWF0ZWRfYXQgPj0gdFtyXS5jcmVhdGVkX2F0KVxuICAgIHMgPSByO1xuICBlbHNlXG4gICAgZm9yICg7IDsgKSB7XG4gICAgICBpZiAobiA8PSByICsgMSkge1xuICAgICAgICBzID0gbjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoaSA9IE1hdGguZmxvb3IociArIChuIC0gcikgLyAyKSwgdFtpXS5jcmVhdGVkX2F0ID4gZS5jcmVhdGVkX2F0KVxuICAgICAgICByID0gaTtcbiAgICAgIGVsc2UgaWYgKHRbaV0uY3JlYXRlZF9hdCA8IGUuY3JlYXRlZF9hdClcbiAgICAgICAgbiA9IGk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgcyA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgcmV0dXJuICgobyA9IHRbc10pID09IG51bGwgPyB2b2lkIDAgOiBvLmlkKSAhPT0gZS5pZCA/IFtcbiAgICAuLi50LnNsaWNlKDAsIHMpLFxuICAgIGUsXG4gICAgLi4udC5zbGljZShzKVxuICBdIDogdDtcbn1cbmZ1bmN0aW9uIHdmKHQsIGUpIHtcbiAgdmFyIG87XG4gIGxldCByID0gMCwgbiA9IHQubGVuZ3RoIC0gMSwgaSwgcyA9IHI7XG4gIGlmIChuIDwgMClcbiAgICBzID0gMDtcbiAgZWxzZSBpZiAoZS5jcmVhdGVkX2F0ID4gdFtuXS5jcmVhdGVkX2F0KVxuICAgIHMgPSBuICsgMTtcbiAgZWxzZSBpZiAoZS5jcmVhdGVkX2F0IDw9IHRbcl0uY3JlYXRlZF9hdClcbiAgICBzID0gcjtcbiAgZWxzZVxuICAgIGZvciAoOyA7ICkge1xuICAgICAgaWYgKG4gPD0gciArIDEpIHtcbiAgICAgICAgcyA9IG47XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGkgPSBNYXRoLmZsb29yKHIgKyAobiAtIHIpIC8gMiksIHRbaV0uY3JlYXRlZF9hdCA8IGUuY3JlYXRlZF9hdClcbiAgICAgICAgciA9IGk7XG4gICAgICBlbHNlIGlmICh0W2ldLmNyZWF0ZWRfYXQgPiBlLmNyZWF0ZWRfYXQpXG4gICAgICAgIG4gPSBpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHMgPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIHJldHVybiAoKG8gPSB0W3NdKSA9PSBudWxsID8gdm9pZCAwIDogby5pZCkgIT09IGUuaWQgPyBbXG4gICAgLi4udC5zbGljZSgwLCBzKSxcbiAgICBlLFxuICAgIC4uLnQuc2xpY2UocylcbiAgXSA6IHQ7XG59XG52YXIgZmEgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHQpIHtcbiAgICBJKHRoaXMsIFwiX3ZhbHVlXCIpO1xuICAgIEkodGhpcywgXCJfbmV4dFwiKTtcbiAgICB0aGlzLl92YWx1ZSA9IHQsIHRoaXMuX25leHQgPSBudWxsO1xuICB9XG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gIH1cbiAgc2V0IHZhbHVlKHQpIHtcbiAgICB0aGlzLl92YWx1ZSA9IHQ7XG4gIH1cbiAgZ2V0IG5leHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX25leHQ7XG4gIH1cbiAgc2V0IG5leHQodCkge1xuICAgIHRoaXMuX25leHQgPSB0O1xuICB9XG59LCBoYSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgSSh0aGlzLCBcIl9maXJzdFwiKTtcbiAgICBJKHRoaXMsIFwiX2xhc3RcIik7XG4gICAgSSh0aGlzLCBcIl9zaXplXCIpO1xuICAgIHRoaXMuX2ZpcnN0ID0gbnVsbCwgdGhpcy5fbGFzdCA9IG51bGwsIHRoaXMuX3NpemUgPSAwO1xuICB9XG4gIGdldCBmaXJzdCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlyc3Q7XG4gIH1cbiAgc2V0IGZpcnN0KHQpIHtcbiAgICB0aGlzLl9maXJzdCA9IHQ7XG4gIH1cbiAgZ2V0IGxhc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xhc3Q7XG4gIH1cbiAgc2V0IGxhc3QodCkge1xuICAgIHRoaXMuX2xhc3QgPSB0O1xuICB9XG4gIGdldCBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLl9zaXplO1xuICB9XG4gIHNldCBzaXplKHQpIHtcbiAgICB0aGlzLl9zaXplID0gdDtcbiAgfVxuICBlbnF1ZXVlKHQpIHtcbiAgICBjb25zdCBlID0gbmV3IGZhKHQpO1xuICAgIHJldHVybiB0aGlzLl9zaXplID09PSAwIHx8ICF0aGlzLl9sYXN0ID8gKHRoaXMuX2ZpcnN0ID0gZSwgdGhpcy5fbGFzdCA9IGUpIDogKHRoaXMuX2xhc3QubmV4dCA9IGUsIHRoaXMuX2xhc3QgPSBlKSwgdGhpcy5fc2l6ZSsrLCAhMDtcbiAgfVxuICBkZXF1ZXVlKCkge1xuICAgIGlmICh0aGlzLl9zaXplID09PSAwIHx8ICF0aGlzLl9maXJzdClcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCB0ID0gdGhpcy5fZmlyc3Q7XG4gICAgcmV0dXJuIHRoaXMuX2ZpcnN0ID0gdC5uZXh0LCB0Lm5leHQgPSBudWxsLCB0aGlzLl9zaXplLS0sIHQudmFsdWU7XG4gIH1cbn07XG5mdW5jdGlvbiBkYSh0LCBlKSB7XG4gIGxldCByID0gdDtcbiAgcmV0dXJuIHIucHVia2V5ID0gbGkoZSksIHIuaWQgPSBIcihyKSwgci5zaWcgPSBwYShyLCBlKSwgcjtcbn1cbmZ1bmN0aW9uIF9mKHQpIHtcbiAgaWYgKCFmaSh0KSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW4ndCBzZXJpYWxpemUgZXZlbnQgd2l0aCB3cm9uZyBvciBtaXNzaW5nIHByb3BlcnRpZXNcIik7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShbXG4gICAgMCxcbiAgICB0LnB1YmtleSxcbiAgICB0LmNyZWF0ZWRfYXQsXG4gICAgdC5raW5kLFxuICAgIHQudGFncyxcbiAgICB0LmNvbnRlbnRcbiAgXSk7XG59XG5mdW5jdGlvbiBIcih0KSB7XG4gIGxldCBlID0gWW4oSWUuZW5jb2RlKF9mKHQpKSk7XG4gIHJldHVybiB2ZShlKTtcbn1cbnZhciBtZiA9ICh0KSA9PiB0IGluc3RhbmNlb2YgT2JqZWN0O1xuZnVuY3Rpb24gZmkodCkge1xuICBpZiAoIW1mKHQpIHx8IHR5cGVvZiB0LmtpbmQgIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgdC5jb250ZW50ICE9IFwic3RyaW5nXCIgfHwgdHlwZW9mIHQuY3JlYXRlZF9hdCAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiB0LnB1YmtleSAhPSBcInN0cmluZ1wiIHx8ICF0LnB1YmtleS5tYXRjaCgvXlthLWYwLTldezY0fSQvKSB8fCAhQXJyYXkuaXNBcnJheSh0LnRhZ3MpKVxuICAgIHJldHVybiAhMTtcbiAgZm9yIChsZXQgZSA9IDA7IGUgPCB0LnRhZ3MubGVuZ3RoOyBlKyspIHtcbiAgICBsZXQgciA9IHQudGFnc1tlXTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocikpXG4gICAgICByZXR1cm4gITE7XG4gICAgZm9yIChsZXQgbiA9IDA7IG4gPCByLmxlbmd0aDsgbisrKVxuICAgICAgaWYgKHR5cGVvZiByW25dID09IFwib2JqZWN0XCIpXG4gICAgICAgIHJldHVybiAhMTtcbiAgfVxuICByZXR1cm4gITA7XG59XG5mdW5jdGlvbiBoaSh0KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIFN0LnZlcmlmeSh0LnNpZywgSHIodCksIHQucHVia2V5KTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuICExO1xuICB9XG59XG5mdW5jdGlvbiBwYSh0LCBlKSB7XG4gIHJldHVybiB2ZShTdC5zaWduKEhyKHQpLCBlKSk7XG59XG5mdW5jdGlvbiB5YSh0LCBlKSB7XG4gIGlmICh0LmlkcyAmJiB0Lmlkcy5pbmRleE9mKGUuaWQpID09PSAtMSAmJiAhdC5pZHMuc29tZSgocikgPT4gZS5pZC5zdGFydHNXaXRoKHIpKSB8fCB0LmtpbmRzICYmIHQua2luZHMuaW5kZXhPZihlLmtpbmQpID09PSAtMSB8fCB0LmF1dGhvcnMgJiYgdC5hdXRob3JzLmluZGV4T2YoZS5wdWJrZXkpID09PSAtMSAmJiAhdC5hdXRob3JzLnNvbWUoKHIpID0+IGUucHVia2V5LnN0YXJ0c1dpdGgocikpKVxuICAgIHJldHVybiAhMTtcbiAgZm9yIChsZXQgciBpbiB0KVxuICAgIGlmIChyWzBdID09PSBcIiNcIikge1xuICAgICAgbGV0IG4gPSByLnNsaWNlKDEpLCBpID0gdFtgIyR7bn1gXTtcbiAgICAgIGlmIChpICYmICFlLnRhZ3MuZmluZChcbiAgICAgICAgKFtzLCBvXSkgPT4gcyA9PT0gci5zbGljZSgxKSAmJiBpLmluZGV4T2YobykgIT09IC0xXG4gICAgICApKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgfVxuICByZXR1cm4gISh0LnNpbmNlICYmIGUuY3JlYXRlZF9hdCA8IHQuc2luY2UgfHwgdC51bnRpbCAmJiBlLmNyZWF0ZWRfYXQgPj0gdC51bnRpbCk7XG59XG5mdW5jdGlvbiB4Zih0LCBlKSB7XG4gIGZvciAobGV0IHIgPSAwOyByIDwgdC5sZW5ndGg7IHIrKylcbiAgICBpZiAoeWEodFtyXSwgZSkpXG4gICAgICByZXR1cm4gITA7XG4gIHJldHVybiAhMTtcbn1cbnZhciBFZiA9IHt9O1xuaWUoRWYsIHtcbiAgZ2V0SGV4NjQ6ICgpID0+IE1yLFxuICBnZXRJbnQ6ICgpID0+IGdhLFxuICBnZXRTdWJzY3JpcHRpb25JZDogKCkgPT4gYmEsXG4gIG1hdGNoRXZlbnRJZDogKCkgPT4ga2YsXG4gIG1hdGNoRXZlbnRLaW5kOiAoKSA9PiBPZixcbiAgbWF0Y2hFdmVudFB1YmtleTogKCkgPT4gU2Zcbn0pO1xuZnVuY3Rpb24gTXIodCwgZSkge1xuICBsZXQgciA9IGUubGVuZ3RoICsgMywgbiA9IHQuaW5kZXhPZihgXCIke2V9XCI6YCkgKyByLCBpID0gdC5zbGljZShuKS5pbmRleE9mKCdcIicpICsgbiArIDE7XG4gIHJldHVybiB0LnNsaWNlKGksIGkgKyA2NCk7XG59XG5mdW5jdGlvbiBnYSh0LCBlKSB7XG4gIGxldCByID0gZS5sZW5ndGgsIG4gPSB0LmluZGV4T2YoYFwiJHtlfVwiOmApICsgciArIDMsIGkgPSB0LnNsaWNlKG4pLCBzID0gTWF0aC5taW4oaS5pbmRleE9mKFwiLFwiKSwgaS5pbmRleE9mKFwifVwiKSk7XG4gIHJldHVybiBwYXJzZUludChpLnNsaWNlKDAsIHMpLCAxMCk7XG59XG5mdW5jdGlvbiBiYSh0KSB7XG4gIGxldCBlID0gdC5zbGljZSgwLCAyMikuaW5kZXhPZignXCJFVkVOVFwiJyk7XG4gIGlmIChlID09PSAtMSlcbiAgICByZXR1cm4gbnVsbDtcbiAgbGV0IHIgPSB0LnNsaWNlKGUgKyA3ICsgMSkuaW5kZXhPZignXCInKTtcbiAgaWYgKHIgPT09IC0xKVxuICAgIHJldHVybiBudWxsO1xuICBsZXQgbiA9IGUgKyA3ICsgMSArIHIsIGkgPSB0LnNsaWNlKG4gKyAxLCA4MCkuaW5kZXhPZignXCInKTtcbiAgaWYgKGkgPT09IC0xKVxuICAgIHJldHVybiBudWxsO1xuICBsZXQgcyA9IG4gKyAxICsgaTtcbiAgcmV0dXJuIHQuc2xpY2UobiArIDEsIHMpO1xufVxuZnVuY3Rpb24ga2YodCwgZSkge1xuICByZXR1cm4gZSA9PT0gTXIodCwgXCJpZFwiKTtcbn1cbmZ1bmN0aW9uIFNmKHQsIGUpIHtcbiAgcmV0dXJuIGUgPT09IE1yKHQsIFwicHVia2V5XCIpO1xufVxuZnVuY3Rpb24gT2YodCwgZSkge1xuICByZXR1cm4gZSA9PT0gZ2EodCwgXCJraW5kXCIpO1xufVxudmFyIEppID0gKCkgPT4gKHtcbiAgY29ubmVjdDogW10sXG4gIGRpc2Nvbm5lY3Q6IFtdLFxuICBlcnJvcjogW10sXG4gIG5vdGljZTogW10sXG4gIGF1dGg6IFtdXG59KTtcbmZ1bmN0aW9uIEFmKHQsIGUgPSB7fSkge1xuICBsZXQgeyBsaXN0VGltZW91dDogciA9IDNlMywgZ2V0VGltZW91dDogbiA9IDNlMywgY291bnRUaW1lb3V0OiBpID0gM2UzIH0gPSBlO1xuICB2YXIgcywgbyA9IHt9LCBhID0gSmkoKSwgYyA9IHt9LCBsID0ge30sIGY7XG4gIGFzeW5jIGZ1bmN0aW9uIHUoKSB7XG4gICAgcmV0dXJuIGYgfHwgKGYgPSBuZXcgUHJvbWlzZSgodiwgXykgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcyA9IG5ldyBXZWJTb2NrZXQodCk7XG4gICAgICB9IGNhdGNoICh3KSB7XG4gICAgICAgIF8odyk7XG4gICAgICB9XG4gICAgICBzLm9ub3BlbiA9ICgpID0+IHtcbiAgICAgICAgYS5jb25uZWN0LmZvckVhY2goKHcpID0+IHcoKSksIHYoKTtcbiAgICAgIH0sIHMub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgZiA9IHZvaWQgMCwgYS5lcnJvci5mb3JFYWNoKCh3KSA9PiB3KCkpLCBfKCk7XG4gICAgICB9LCBzLm9uY2xvc2UgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIGYgPSB2b2lkIDAsIGEuZGlzY29ubmVjdC5mb3JFYWNoKCh3KSA9PiB3KCkpO1xuICAgICAgfTtcbiAgICAgIGxldCBtID0gbmV3IGhhKCksIEM7XG4gICAgICBzLm9ubWVzc2FnZSA9ICh3KSA9PiB7XG4gICAgICAgIG0uZW5xdWV1ZSh3LmRhdGEpLCBDIHx8IChDID0gc2V0SW50ZXJ2YWwoTywgMCkpO1xuICAgICAgfTtcbiAgICAgIGZ1bmN0aW9uIE8oKSB7XG4gICAgICAgIHZhciBBLCBCLCBMO1xuICAgICAgICBpZiAobS5zaXplID09PSAwKSB7XG4gICAgICAgICAgY2xlYXJJbnRlcnZhbChDKSwgQyA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3ID0gbS5kZXF1ZXVlKCk7XG4gICAgICAgIGlmICghdylcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCB4ID0gYmEodyk7XG4gICAgICAgIGlmICh4KSB7XG4gICAgICAgICAgbGV0IFAgPSBvW3hdO1xuICAgICAgICAgIGlmIChQICYmIFAuYWxyZWFkeUhhdmVFdmVudCAmJiBQLmFscmVhZHlIYXZlRXZlbnQoTXIodywgXCJpZFwiKSwgdCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBsZXQgUCA9IEpTT04ucGFyc2Uodyk7XG4gICAgICAgICAgc3dpdGNoIChQWzBdKSB7XG4gICAgICAgICAgICBjYXNlIFwiRVZFTlRcIjoge1xuICAgICAgICAgICAgICBsZXQgRSA9IFBbMV0sIFIgPSBQWzJdO1xuICAgICAgICAgICAgICBmaShSKSAmJiBvW0VdICYmIChvW0VdLnNraXBWZXJpZmljYXRpb24gfHwgaGkoUikpICYmIHhmKG9bRV0uZmlsdGVycywgUikgJiYgKG9bRV0sICgoKEEgPSBjW0VdKSA9PSBudWxsID8gdm9pZCAwIDogQS5ldmVudCkgfHwgW10pLmZvckVhY2goKHEpID0+IHEoUikpKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcIkNPVU5UXCI6XG4gICAgICAgICAgICAgIGxldCBGID0gUFsxXSwgeiA9IFBbMl07XG4gICAgICAgICAgICAgIG9bRl0gJiYgKCgoQiA9IGNbRl0pID09IG51bGwgPyB2b2lkIDAgOiBCLmNvdW50KSB8fCBbXSkuZm9yRWFjaCgoRSkgPT4gRSh6KSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgXCJFT1NFXCI6IHtcbiAgICAgICAgICAgICAgbGV0IEUgPSBQWzFdO1xuICAgICAgICAgICAgICBFIGluIGMgJiYgKGNbRV0uZW9zZS5mb3JFYWNoKChSKSA9PiBSKCkpLCBjW0VdLmVvc2UgPSBbXSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJPS1wiOiB7XG4gICAgICAgICAgICAgIGxldCBFID0gUFsxXSwgUiA9IFBbMl0sIHEgPSBQWzNdIHx8IFwiXCI7XG4gICAgICAgICAgICAgIEUgaW4gbCAmJiAoUiA/IGxbRV0ub2suZm9yRWFjaCgoSCkgPT4gSCgpKSA6IGxbRV0uZmFpbGVkLmZvckVhY2goKEgpID0+IEgocSkpLCBsW0VdLm9rID0gW10sIGxbRV0uZmFpbGVkID0gW10pO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiTk9USUNFXCI6XG4gICAgICAgICAgICAgIGxldCBHID0gUFsxXTtcbiAgICAgICAgICAgICAgYS5ub3RpY2UuZm9yRWFjaCgoRSkgPT4gRShHKSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgXCJBVVRIXCI6IHtcbiAgICAgICAgICAgICAgbGV0IEUgPSBQWzFdO1xuICAgICAgICAgICAgICAoTCA9IGEuYXV0aCkgPT0gbnVsbCB8fCBMLmZvckVhY2goKFIpID0+IFIoRSkpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KSwgZik7XG4gIH1cbiAgZnVuY3Rpb24gaCgpIHtcbiAgICByZXR1cm4gKHMgPT0gbnVsbCA/IHZvaWQgMCA6IHMucmVhZHlTdGF0ZSkgPT09IDE7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gZCgpIHtcbiAgICBoKCkgfHwgYXdhaXQgdSgpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHAodikge1xuICAgIGxldCBfID0gSlNPTi5zdHJpbmdpZnkodik7XG4gICAgaWYgKCEoIWgoKSAmJiAoYXdhaXQgbmV3IFByb21pc2UoKG0pID0+IHNldFRpbWVvdXQobSwgMWUzKSksICFoKCkpKSlcbiAgICAgIHRyeSB7XG4gICAgICAgIHMuc2VuZChfKTtcbiAgICAgIH0gY2F0Y2ggKG0pIHtcbiAgICAgICAgY29uc29sZS5sb2cobSk7XG4gICAgICB9XG4gIH1cbiAgY29uc3QgeSA9ICh2LCB7XG4gICAgdmVyYjogXyA9IFwiUkVRXCIsXG4gICAgc2tpcFZlcmlmaWNhdGlvbjogbSA9ICExLFxuICAgIGFscmVhZHlIYXZlRXZlbnQ6IEMgPSBudWxsLFxuICAgIGlkOiBPID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygpLnNsaWNlKDIpXG4gIH0gPSB7fSkgPT4ge1xuICAgIGxldCB3ID0gTztcbiAgICByZXR1cm4gb1t3XSA9IHtcbiAgICAgIGlkOiB3LFxuICAgICAgZmlsdGVyczogdixcbiAgICAgIHNraXBWZXJpZmljYXRpb246IG0sXG4gICAgICBhbHJlYWR5SGF2ZUV2ZW50OiBDXG4gICAgfSwgcChbXywgdywgLi4udl0pLCB7XG4gICAgICBzdWI6ICh4LCBBID0ge30pID0+IHkoeCB8fCB2LCB7XG4gICAgICAgIHNraXBWZXJpZmljYXRpb246IEEuc2tpcFZlcmlmaWNhdGlvbiB8fCBtLFxuICAgICAgICBhbHJlYWR5SGF2ZUV2ZW50OiBBLmFscmVhZHlIYXZlRXZlbnQgfHwgQyxcbiAgICAgICAgaWQ6IHdcbiAgICAgIH0pLFxuICAgICAgdW5zdWI6ICgpID0+IHtcbiAgICAgICAgZGVsZXRlIG9bd10sIGRlbGV0ZSBjW3ddLCBwKFtcIkNMT1NFXCIsIHddKTtcbiAgICAgIH0sXG4gICAgICBvbjogKHgsIEEpID0+IHtcbiAgICAgICAgY1t3XSA9IGNbd10gfHwge1xuICAgICAgICAgIGV2ZW50OiBbXSxcbiAgICAgICAgICBjb3VudDogW10sXG4gICAgICAgICAgZW9zZTogW11cbiAgICAgICAgfSwgY1t3XVt4XS5wdXNoKEEpO1xuICAgICAgfSxcbiAgICAgIG9mZjogKHgsIEEpID0+IHtcbiAgICAgICAgbGV0IEIgPSBjW3ddLCBMID0gQlt4XS5pbmRleE9mKEEpO1xuICAgICAgICBMID49IDAgJiYgQlt4XS5zcGxpY2UoTCwgMSk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbiAgZnVuY3Rpb24gZyh2LCBfKSB7XG4gICAgaWYgKCF2LmlkKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBldmVudCAke3Z9IGhhcyBubyBpZGApO1xuICAgIGxldCBtID0gdi5pZDtcbiAgICByZXR1cm4gcChbXywgdl0pLCB7XG4gICAgICBvbjogKEMsIE8pID0+IHtcbiAgICAgICAgbFttXSA9IGxbbV0gfHwge1xuICAgICAgICAgIG9rOiBbXSxcbiAgICAgICAgICBmYWlsZWQ6IFtdXG4gICAgICAgIH0sIGxbbV1bQ10ucHVzaChPKTtcbiAgICAgIH0sXG4gICAgICBvZmY6IChDLCBPKSA9PiB7XG4gICAgICAgIGxldCB3ID0gbFttXTtcbiAgICAgICAgaWYgKCF3KVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IHggPSB3W0NdLmluZGV4T2YoTyk7XG4gICAgICAgIHggPj0gMCAmJiB3W0NdLnNwbGljZSh4LCAxKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgdXJsOiB0LFxuICAgIHN1YjogeSxcbiAgICBvbjogKHYsIF8pID0+IHtcbiAgICAgIGFbdl0ucHVzaChfKSwgdiA9PT0gXCJjb25uZWN0XCIgJiYgKHMgPT0gbnVsbCA/IHZvaWQgMCA6IHMucmVhZHlTdGF0ZSkgPT09IDEgJiYgXygpO1xuICAgIH0sXG4gICAgb2ZmOiAodiwgXykgPT4ge1xuICAgICAgbGV0IG0gPSBhW3ZdLmluZGV4T2YoXyk7XG4gICAgICBtICE9PSAtMSAmJiBhW3ZdLnNwbGljZShtLCAxKTtcbiAgICB9LFxuICAgIGxpc3Q6ICh2LCBfKSA9PiBuZXcgUHJvbWlzZSgobSkgPT4ge1xuICAgICAgbGV0IEMgPSB5KHYsIF8pLCBPID0gW10sIHcgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgQy51bnN1YigpLCBtKE8pO1xuICAgICAgfSwgcik7XG4gICAgICBDLm9uKFwiZW9zZVwiLCAoKSA9PiB7XG4gICAgICAgIEMudW5zdWIoKSwgY2xlYXJUaW1lb3V0KHcpLCBtKE8pO1xuICAgICAgfSksIEMub24oXCJldmVudFwiLCAoeCkgPT4ge1xuICAgICAgICBPLnB1c2goeCk7XG4gICAgICB9KTtcbiAgICB9KSxcbiAgICBnZXQ6ICh2LCBfKSA9PiBuZXcgUHJvbWlzZSgobSkgPT4ge1xuICAgICAgbGV0IEMgPSB5KFt2XSwgXyksIE8gPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgQy51bnN1YigpLCBtKG51bGwpO1xuICAgICAgfSwgbik7XG4gICAgICBDLm9uKFwiZXZlbnRcIiwgKHcpID0+IHtcbiAgICAgICAgQy51bnN1YigpLCBjbGVhclRpbWVvdXQoTyksIG0odyk7XG4gICAgICB9KTtcbiAgICB9KSxcbiAgICBjb3VudDogKHYpID0+IG5ldyBQcm9taXNlKChfKSA9PiB7XG4gICAgICBsZXQgbSA9IHkodiwgeyAuLi55LCB2ZXJiOiBcIkNPVU5UXCIgfSksIEMgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgbS51bnN1YigpLCBfKG51bGwpO1xuICAgICAgfSwgaSk7XG4gICAgICBtLm9uKFwiY291bnRcIiwgKE8pID0+IHtcbiAgICAgICAgbS51bnN1YigpLCBjbGVhclRpbWVvdXQoQyksIF8oTyk7XG4gICAgICB9KTtcbiAgICB9KSxcbiAgICBwdWJsaXNoKHYpIHtcbiAgICAgIHJldHVybiBnKHYsIFwiRVZFTlRcIik7XG4gICAgfSxcbiAgICBhdXRoKHYpIHtcbiAgICAgIHJldHVybiBnKHYsIFwiQVVUSFwiKTtcbiAgICB9LFxuICAgIGNvbm5lY3Q6IGQsXG4gICAgY2xvc2UoKSB7XG4gICAgICBhID0gSmkoKSwgYyA9IHt9LCBsID0ge30sIHMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0Lk9QRU4gJiYgKHMgPT0gbnVsbCB8fCBzLmNsb3NlKCkpO1xuICAgIH0sXG4gICAgZ2V0IHN0YXR1cygpIHtcbiAgICAgIHZhciB2O1xuICAgICAgcmV0dXJuICh2ID0gcyA9PSBudWxsID8gdm9pZCAwIDogcy5yZWFkeVN0YXRlKSAhPSBudWxsID8gdiA6IDM7XG4gICAgfVxuICB9O1xufVxudmFyIHdlID0ge307XG5pZSh3ZSwge1xuICBCRUNIMzJfUkVHRVg6ICgpID0+IHZhLFxuICBkZWNvZGU6ICgpID0+IERyLFxuICBuYWRkckVuY29kZTogKCkgPT4gQmYsXG4gIG5ldmVudEVuY29kZTogKCkgPT4gUGYsXG4gIG5vdGVFbmNvZGU6ICgpID0+IFJmLFxuICBucHJvZmlsZUVuY29kZTogKCkgPT4gVGYsXG4gIG5wdWJFbmNvZGU6ICgpID0+IElmLFxuICBucmVsYXlFbmNvZGU6ICgpID0+IExmLFxuICBuc2VjRW5jb2RlOiAoKSA9PiBDZlxufSk7XG52YXIgQXQgPSA1ZTMsIHZhID0gL1tcXHgyMS1cXHg3RV17MSw4M30xWzAyMzQ1Njc4OWFjZGVmZ2hqa2xtbnBxcnN0dXZ3eHl6XXs2LH0vO1xuZnVuY3Rpb24gRHIodCkge1xuICB2YXIgaSwgcywgbywgYSwgYywgbCwgZjtcbiAgbGV0IHsgcHJlZml4OiBlLCB3b3JkczogciB9ID0gdGUuZGVjb2RlKHQsIEF0KSwgbiA9IG5ldyBVaW50OEFycmF5KHRlLmZyb21Xb3JkcyhyKSk7XG4gIHN3aXRjaCAoZSkge1xuICAgIGNhc2UgXCJucHJvZmlsZVwiOiB7XG4gICAgICBsZXQgdSA9IHdyKG4pO1xuICAgICAgaWYgKCEoKGkgPSB1WzBdKSAhPSBudWxsICYmIGlbMF0pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIFRMViAwIGZvciBucHJvZmlsZVwiKTtcbiAgICAgIGlmICh1WzBdWzBdLmxlbmd0aCAhPT0gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRMViAwIHNob3VsZCBiZSAzMiBieXRlc1wiKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwibnByb2ZpbGVcIixcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHB1YmtleTogdmUodVswXVswXSksXG4gICAgICAgICAgcmVsYXlzOiB1WzFdID8gdVsxXS5tYXAoKGgpID0+IEplLmRlY29kZShoKSkgOiBbXVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFwibmV2ZW50XCI6IHtcbiAgICAgIGxldCB1ID0gd3Iobik7XG4gICAgICBpZiAoISgocyA9IHVbMF0pICE9IG51bGwgJiYgc1swXSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgVExWIDAgZm9yIG5ldmVudFwiKTtcbiAgICAgIGlmICh1WzBdWzBdLmxlbmd0aCAhPT0gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRMViAwIHNob3VsZCBiZSAzMiBieXRlc1wiKTtcbiAgICAgIGlmICh1WzJdICYmIHVbMl1bMF0ubGVuZ3RoICE9PSAzMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVExWIDIgc2hvdWxkIGJlIDMyIGJ5dGVzXCIpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJuZXZlbnRcIixcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGlkOiB2ZSh1WzBdWzBdKSxcbiAgICAgICAgICByZWxheXM6IHVbMV0gPyB1WzFdLm1hcCgoaCkgPT4gSmUuZGVjb2RlKGgpKSA6IFtdLFxuICAgICAgICAgIGF1dGhvcjogKG8gPSB1WzJdKSAhPSBudWxsICYmIG9bMF0gPyB2ZSh1WzJdWzBdKSA6IHZvaWQgMFxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFwibmFkZHJcIjoge1xuICAgICAgbGV0IHUgPSB3cihuKTtcbiAgICAgIGlmICghKChhID0gdVswXSkgIT0gbnVsbCAmJiBhWzBdKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBUTFYgMCBmb3IgbmFkZHJcIik7XG4gICAgICBpZiAoISgoYyA9IHVbMl0pICE9IG51bGwgJiYgY1swXSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgVExWIDIgZm9yIG5hZGRyXCIpO1xuICAgICAgaWYgKHVbMl1bMF0ubGVuZ3RoICE9PSAzMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVExWIDIgc2hvdWxkIGJlIDMyIGJ5dGVzXCIpO1xuICAgICAgaWYgKCEoKGwgPSB1WzNdKSAhPSBudWxsICYmIGxbMF0pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIFRMViAzIGZvciBuYWRkclwiKTtcbiAgICAgIGlmICh1WzNdWzBdLmxlbmd0aCAhPT0gNClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVExWIDMgc2hvdWxkIGJlIDQgYnl0ZXNcIik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIm5hZGRyXCIsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBpZGVudGlmaWVyOiBKZS5kZWNvZGUodVswXVswXSksXG4gICAgICAgICAgcHVia2V5OiB2ZSh1WzJdWzBdKSxcbiAgICAgICAgICBraW5kOiBwYXJzZUludCh2ZSh1WzNdWzBdKSwgMTYpLFxuICAgICAgICAgIHJlbGF5czogdVsxXSA/IHVbMV0ubWFwKChoKSA9PiBKZS5kZWNvZGUoaCkpIDogW11cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBcIm5yZWxheVwiOiB7XG4gICAgICBsZXQgdSA9IHdyKG4pO1xuICAgICAgaWYgKCEoKGYgPSB1WzBdKSAhPSBudWxsICYmIGZbMF0pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIFRMViAwIGZvciBucmVsYXlcIik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIm5yZWxheVwiLFxuICAgICAgICBkYXRhOiBKZS5kZWNvZGUodVswXVswXSlcbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgXCJuc2VjXCI6XG4gICAgY2FzZSBcIm5wdWJcIjpcbiAgICBjYXNlIFwibm90ZVwiOlxuICAgICAgcmV0dXJuIHsgdHlwZTogZSwgZGF0YTogdmUobikgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIHByZWZpeCAke2V9YCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHdyKHQpIHtcbiAgbGV0IGUgPSB7fSwgciA9IHQ7XG4gIGZvciAoOyByLmxlbmd0aCA+IDA7ICkge1xuICAgIGxldCBuID0gclswXSwgaSA9IHJbMV07XG4gICAgaWYgKCFpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBtYWxmb3JtZWQgVExWICR7bn1gKTtcbiAgICBsZXQgcyA9IHIuc2xpY2UoMiwgMiArIGkpO1xuICAgIGlmIChyID0gci5zbGljZSgyICsgaSksIHMubGVuZ3RoIDwgaSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgbm90IGVub3VnaCBkYXRhIHRvIHJlYWQgb24gVExWICR7bn1gKTtcbiAgICBlW25dID0gZVtuXSB8fCBbXSwgZVtuXS5wdXNoKHMpO1xuICB9XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gQ2YodCkge1xuICByZXR1cm4gZGkoXCJuc2VjXCIsIHQpO1xufVxuZnVuY3Rpb24gSWYodCkge1xuICByZXR1cm4gZGkoXCJucHViXCIsIHQpO1xufVxuZnVuY3Rpb24gUmYodCkge1xuICByZXR1cm4gZGkoXCJub3RlXCIsIHQpO1xufVxuZnVuY3Rpb24gZGkodCwgZSkge1xuICBsZXQgciA9IF90KGUpLCBuID0gdGUudG9Xb3JkcyhyKTtcbiAgcmV0dXJuIHRlLmVuY29kZSh0LCBuLCBBdCk7XG59XG5mdW5jdGlvbiBUZih0KSB7XG4gIGxldCBlID0genIoe1xuICAgIDA6IFtfdCh0LnB1YmtleSldLFxuICAgIDE6ICh0LnJlbGF5cyB8fCBbXSkubWFwKChuKSA9PiBJZS5lbmNvZGUobikpXG4gIH0pLCByID0gdGUudG9Xb3JkcyhlKTtcbiAgcmV0dXJuIHRlLmVuY29kZShcIm5wcm9maWxlXCIsIHIsIEF0KTtcbn1cbmZ1bmN0aW9uIFBmKHQpIHtcbiAgbGV0IGUgPSB6cih7XG4gICAgMDogW190KHQuaWQpXSxcbiAgICAxOiAodC5yZWxheXMgfHwgW10pLm1hcCgobikgPT4gSWUuZW5jb2RlKG4pKSxcbiAgICAyOiB0LmF1dGhvciA/IFtfdCh0LmF1dGhvcildIDogW11cbiAgfSksIHIgPSB0ZS50b1dvcmRzKGUpO1xuICByZXR1cm4gdGUuZW5jb2RlKFwibmV2ZW50XCIsIHIsIEF0KTtcbn1cbmZ1bmN0aW9uIEJmKHQpIHtcbiAgbGV0IGUgPSBuZXcgQXJyYXlCdWZmZXIoNCk7XG4gIG5ldyBEYXRhVmlldyhlKS5zZXRVaW50MzIoMCwgdC5raW5kLCAhMSk7XG4gIGxldCByID0genIoe1xuICAgIDA6IFtJZS5lbmNvZGUodC5pZGVudGlmaWVyKV0sXG4gICAgMTogKHQucmVsYXlzIHx8IFtdKS5tYXAoKGkpID0+IEllLmVuY29kZShpKSksXG4gICAgMjogW190KHQucHVia2V5KV0sXG4gICAgMzogW25ldyBVaW50OEFycmF5KGUpXVxuICB9KSwgbiA9IHRlLnRvV29yZHMocik7XG4gIHJldHVybiB0ZS5lbmNvZGUoXCJuYWRkclwiLCBuLCBBdCk7XG59XG5mdW5jdGlvbiBMZih0KSB7XG4gIGxldCBlID0genIoe1xuICAgIDA6IFtJZS5lbmNvZGUodCldXG4gIH0pLCByID0gdGUudG9Xb3JkcyhlKTtcbiAgcmV0dXJuIHRlLmVuY29kZShcIm5yZWxheVwiLCByLCBBdCk7XG59XG5mdW5jdGlvbiB6cih0KSB7XG4gIGxldCBlID0gW107XG4gIHJldHVybiBPYmplY3QuZW50cmllcyh0KS5mb3JFYWNoKChbciwgbl0pID0+IHtcbiAgICBuLmZvckVhY2goKGkpID0+IHtcbiAgICAgIGxldCBzID0gbmV3IFVpbnQ4QXJyYXkoaS5sZW5ndGggKyAyKTtcbiAgICAgIHMuc2V0KFtwYXJzZUludChyKV0sIDApLCBzLnNldChbaS5sZW5ndGhdLCAxKSwgcy5zZXQoaSwgMiksIGUucHVzaChzKTtcbiAgICB9KTtcbiAgfSksIF91KC4uLmUpO1xufVxudmFyIFVuID0ge307XG5pZShVbiwge1xuICBkZWNyeXB0OiAoKSA9PiBxZixcbiAgZW5jcnlwdDogKCkgPT4gJGZcbn0pO1xudHlwZW9mIGNyeXB0byA8IFwidVwiICYmICFjcnlwdG8uc3VidGxlICYmIGNyeXB0by53ZWJjcnlwdG8gJiYgKGNyeXB0by5zdWJ0bGUgPSBjcnlwdG8ud2ViY3J5cHRvLnN1YnRsZSk7XG5hc3luYyBmdW5jdGlvbiAkZih0LCBlLCByKSB7XG4gIGNvbnN0IG4gPSB1ZS5nZXRTaGFyZWRTZWNyZXQodCwgXCIwMlwiICsgZSksIGkgPSB3YShuKTtcbiAgbGV0IHMgPSBVaW50OEFycmF5LmZyb20oeHUoMTYpKSwgbyA9IEllLmVuY29kZShyKSwgYSA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KFxuICAgIFwicmF3XCIsXG4gICAgaSxcbiAgICB7IG5hbWU6IFwiQUVTLUNCQ1wiIH0sXG4gICAgITEsXG4gICAgW1wiZW5jcnlwdFwiXVxuICApLCBjID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5lbmNyeXB0KFxuICAgIHsgbmFtZTogXCJBRVMtQ0JDXCIsIGl2OiBzIH0sXG4gICAgYSxcbiAgICBvXG4gICksIGwgPSBtdC5lbmNvZGUobmV3IFVpbnQ4QXJyYXkoYykpLCBmID0gbXQuZW5jb2RlKG5ldyBVaW50OEFycmF5KHMuYnVmZmVyKSk7XG4gIHJldHVybiBgJHtsfT9pdj0ke2Z9YDtcbn1cbmFzeW5jIGZ1bmN0aW9uIHFmKHQsIGUsIHIpIHtcbiAgbGV0IFtuLCBpXSA9IHIuc3BsaXQoXCI/aXY9XCIpLCBzID0gdWUuZ2V0U2hhcmVkU2VjcmV0KHQsIFwiMDJcIiArIGUpLCBvID0gd2EocyksIGEgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmltcG9ydEtleShcbiAgICBcInJhd1wiLFxuICAgIG8sXG4gICAgeyBuYW1lOiBcIkFFUy1DQkNcIiB9LFxuICAgICExLFxuICAgIFtcImRlY3J5cHRcIl1cbiAgKSwgYyA9IG10LmRlY29kZShuKSwgbCA9IG10LmRlY29kZShpKSwgZiA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuZGVjcnlwdChcbiAgICB7IG5hbWU6IFwiQUVTLUNCQ1wiLCBpdjogbCB9LFxuICAgIGEsXG4gICAgY1xuICApO1xuICByZXR1cm4gSmUuZGVjb2RlKGYpO1xufVxuZnVuY3Rpb24gd2EodCkge1xuICByZXR1cm4gdC5zbGljZSgxLCAzMyk7XG59XG52YXIgX2EgPSB7fTtcbmllKF9hLCB7XG4gIE5JUDA1X1JFR0VYOiAoKSA9PiBtYSxcbiAgcXVlcnlQcm9maWxlOiAoKSA9PiBqZixcbiAgc2VhcmNoRG9tYWluOiAoKSA9PiBVZixcbiAgdXNlRmV0Y2hJbXBsZW1lbnRhdGlvbjogKCkgPT4gTmZcbn0pO1xudmFyIG1hID0gL14oPzooW1xcdy4rLV0rKUApPyhbXFx3Li1dKykkLywgRnI7XG50cnkge1xuICBGciA9IGZldGNoO1xufSBjYXRjaCB7XG59XG5mdW5jdGlvbiBOZih0KSB7XG4gIEZyID0gdDtcbn1cbmFzeW5jIGZ1bmN0aW9uIFVmKHQsIGUgPSBcIlwiKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIChhd2FpdCAoYXdhaXQgRnIoYGh0dHBzOi8vJHt0fS8ud2VsbC1rbm93bi9ub3N0ci5qc29uP25hbWU9JHtlfWApKS5qc29uKCkpLm5hbWVzO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4ge307XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGpmKHQpIHtcbiAgY29uc3QgZSA9IHQubWF0Y2gobWEpO1xuICBpZiAoIWUpXG4gICAgcmV0dXJuIG51bGw7XG4gIGNvbnN0IFtyLCBuID0gXCJfXCIsIGldID0gZTtcbiAgdHJ5IHtcbiAgICBjb25zdCBzID0gYXdhaXQgRnIoYGh0dHBzOi8vJHtpfS8ud2VsbC1rbm93bi9ub3N0ci5qc29uP25hbWU9JHtufWApLCB7IG5hbWVzOiBvLCByZWxheXM6IGEgfSA9IEhmKGF3YWl0IHMuanNvbigpKSwgYyA9IG9bbl07XG4gICAgcmV0dXJuIGMgPyB7IHB1YmtleTogYywgcmVsYXlzOiBhID09IG51bGwgPyB2b2lkIDAgOiBhW2NdIH0gOiBudWxsO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gSGYodCkge1xuICBjb25zdCBlID0ge1xuICAgIG5hbWVzOiB7fVxuICB9O1xuICBmb3IgKGNvbnN0IFtyLCBuXSBvZiBPYmplY3QuZW50cmllcyh0Lm5hbWVzKSlcbiAgICB0eXBlb2YgciA9PSBcInN0cmluZ1wiICYmIHR5cGVvZiBuID09IFwic3RyaW5nXCIgJiYgKGUubmFtZXNbcl0gPSBuKTtcbiAgaWYgKHQucmVsYXlzKSB7XG4gICAgZS5yZWxheXMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtyLCBuXSBvZiBPYmplY3QuZW50cmllcyh0LnJlbGF5cykpXG4gICAgICB0eXBlb2YgciA9PSBcInN0cmluZ1wiICYmIEFycmF5LmlzQXJyYXkobikgJiYgKGUucmVsYXlzW3JdID0gbi5maWx0ZXIoKGkpID0+IHR5cGVvZiBpID09IFwic3RyaW5nXCIpKTtcbiAgfVxuICByZXR1cm4gZTtcbn1cbnZhciBNZiA9IHt9O1xuaWUoTWYsIHtcbiAgZ2VuZXJhdGVTZWVkV29yZHM6ICgpID0+IHpmLFxuICBwcml2YXRlS2V5RnJvbVNlZWRXb3JkczogKCkgPT4gRGYsXG4gIHZhbGlkYXRlV29yZHM6ICgpID0+IEZmXG59KTtcbmZ1bmN0aW9uIERmKHQsIGUpIHtcbiAgbGV0IG4gPSBjdC5mcm9tTWFzdGVyU2VlZChZcyh0LCBlKSkuZGVyaXZlKFwibS80NCcvMTIzNycvMCcvMC8wXCIpLnByaXZhdGVLZXk7XG4gIGlmICghbilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb3VsZCBub3QgZGVyaXZlIHByaXZhdGUga2V5XCIpO1xuICByZXR1cm4gdmUobik7XG59XG5mdW5jdGlvbiB6ZigpIHtcbiAgcmV0dXJuIHJhKFFuKTtcbn1cbmZ1bmN0aW9uIEZmKHQpIHtcbiAgcmV0dXJuIHNhKHQsIFFuKTtcbn1cbnZhciBLZiA9IHt9O1xuaWUoS2YsIHtcbiAgcGFyc2U6ICgpID0+IFdmXG59KTtcbmZ1bmN0aW9uIFdmKHQpIHtcbiAgY29uc3QgZSA9IHtcbiAgICByZXBseTogdm9pZCAwLFxuICAgIHJvb3Q6IHZvaWQgMCxcbiAgICBtZW50aW9uczogW10sXG4gICAgcHJvZmlsZXM6IFtdXG4gIH0sIHIgPSBbXTtcbiAgZm9yIChjb25zdCBuIG9mIHQudGFncylcbiAgICBuWzBdID09PSBcImVcIiAmJiBuWzFdICYmIHIucHVzaChuKSwgblswXSA9PT0gXCJwXCIgJiYgblsxXSAmJiBlLnByb2ZpbGVzLnB1c2goe1xuICAgICAgcHVia2V5OiBuWzFdLFxuICAgICAgcmVsYXlzOiBuWzJdID8gW25bMl1dIDogW11cbiAgICB9KTtcbiAgZm9yIChsZXQgbiA9IDA7IG4gPCByLmxlbmd0aDsgbisrKSB7XG4gICAgY29uc3QgaSA9IHJbbl0sIFtzLCBvLCBhLCBjXSA9IGksIGwgPSB7XG4gICAgICBpZDogbyxcbiAgICAgIHJlbGF5czogYSA/IFthXSA6IFtdXG4gICAgfSwgZiA9IG4gPT09IDAsIHUgPSBuID09PSByLmxlbmd0aCAtIDE7XG4gICAgaWYgKGMgPT09IFwicm9vdFwiKSB7XG4gICAgICBlLnJvb3QgPSBsO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChjID09PSBcInJlcGx5XCIpIHtcbiAgICAgIGUucmVwbHkgPSBsO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChjID09PSBcIm1lbnRpb25cIikge1xuICAgICAgZS5tZW50aW9ucy5wdXNoKGwpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChmKSB7XG4gICAgICBlLnJvb3QgPSBsO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICh1KSB7XG4gICAgICBlLnJlcGx5ID0gbDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBlLm1lbnRpb25zLnB1c2gobCk7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG52YXIgVmYgPSB7fTtcbmllKFZmLCB7XG4gIGdldFBvdzogKCkgPT4gR2Zcbn0pO1xuZnVuY3Rpb24gR2YodCkge1xuICByZXR1cm4gWmYoX3QodCkpO1xufVxuZnVuY3Rpb24gWmYodCkge1xuICBsZXQgZSwgciwgbjtcbiAgZm9yIChyID0gMCwgZSA9IDA7IHIgPCB0Lmxlbmd0aCAmJiAobiA9IFlmKHRbcl0pLCBlICs9IG4sIG4gPT09IDgpOyByKyspXG4gICAgO1xuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIFlmKHQpIHtcbiAgbGV0IGUgPSAwO1xuICBpZiAodCA9PT0gMClcbiAgICByZXR1cm4gODtcbiAgZm9yICg7IHQgPj49IDE7IClcbiAgICBlKys7XG4gIHJldHVybiA3IC0gZTtcbn1cbnZhciBKZiA9IHt9O1xuaWUoSmYsIHtcbiAgZmluaXNoUmVwb3N0RXZlbnQ6ICgpID0+IFhmLFxuICBnZXRSZXBvc3RlZEV2ZW50OiAoKSA9PiBRZixcbiAgZ2V0UmVwb3N0ZWRFdmVudFBvaW50ZXI6ICgpID0+IHhhXG59KTtcbmZ1bmN0aW9uIFhmKHQsIGUsIHIsIG4pIHtcbiAgdmFyIGk7XG4gIHJldHVybiBkYSh7XG4gICAga2luZDogNixcbiAgICB0YWdzOiBbXG4gICAgICAuLi4oaSA9IHQudGFncykgIT0gbnVsbCA/IGkgOiBbXSxcbiAgICAgIFtcImVcIiwgZS5pZCwgcl0sXG4gICAgICBbXCJwXCIsIGUucHVia2V5XVxuICAgIF0sXG4gICAgY29udGVudDogdC5jb250ZW50ID09PSBcIlwiID8gXCJcIiA6IEpTT04uc3RyaW5naWZ5KGUpLFxuICAgIGNyZWF0ZWRfYXQ6IHQuY3JlYXRlZF9hdFxuICB9LCBuKTtcbn1cbmZ1bmN0aW9uIHhhKHQpIHtcbiAgaWYgKHQua2luZCAhPT0gNilcbiAgICByZXR1cm47XG4gIGxldCBlLCByO1xuICBmb3IgKGxldCBuID0gdC50YWdzLmxlbmd0aCAtIDE7IG4gPj0gMCAmJiAoZSA9PT0gdm9pZCAwIHx8IHIgPT09IHZvaWQgMCk7IG4tLSkge1xuICAgIGNvbnN0IGkgPSB0LnRhZ3Nbbl07XG4gICAgaS5sZW5ndGggPj0gMiAmJiAoaVswXSA9PT0gXCJlXCIgJiYgZSA9PT0gdm9pZCAwID8gZSA9IGkgOiBpWzBdID09PSBcInBcIiAmJiByID09PSB2b2lkIDAgJiYgKHIgPSBpKSk7XG4gIH1cbiAgaWYgKGUgIT09IHZvaWQgMClcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IGVbMV0sXG4gICAgICByZWxheXM6IFtlWzJdLCByID09IG51bGwgPyB2b2lkIDAgOiByWzJdXS5maWx0ZXIoKG4pID0+IHR5cGVvZiBuID09IFwic3RyaW5nXCIpLFxuICAgICAgYXV0aG9yOiByID09IG51bGwgPyB2b2lkIDAgOiByWzFdXG4gICAgfTtcbn1cbmZ1bmN0aW9uIFFmKHQsIHsgc2tpcFZlcmlmaWNhdGlvbjogZSB9ID0ge30pIHtcbiAgY29uc3QgciA9IHhhKHQpO1xuICBpZiAociA9PT0gdm9pZCAwIHx8IHQuY29udGVudCA9PT0gXCJcIilcbiAgICByZXR1cm47XG4gIGxldCBuO1xuICB0cnkge1xuICAgIG4gPSBKU09OLnBhcnNlKHQuY29udGVudCk7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAobi5pZCA9PT0gci5pZCAmJiAhKCFlICYmICFoaShuKSkpXG4gICAgcmV0dXJuIG47XG59XG52YXIgZWggPSB7fTtcbmllKGVoLCB7XG4gIE5PU1RSX1VSSV9SRUdFWDogKCkgPT4gS3IsXG4gIHBhcnNlOiAoKSA9PiByaCxcbiAgdGVzdDogKCkgPT4gdGhcbn0pO1xudmFyIEtyID0gbmV3IFJlZ0V4cChgbm9zdHI6KCR7dmEuc291cmNlfSlgKTtcbmZ1bmN0aW9uIHRoKHQpIHtcbiAgcmV0dXJuIHR5cGVvZiB0ID09IFwic3RyaW5nXCIgJiYgbmV3IFJlZ0V4cChgXiR7S3Iuc291cmNlfSRgKS50ZXN0KHQpO1xufVxuZnVuY3Rpb24gcmgodCkge1xuICBjb25zdCBlID0gdC5tYXRjaChuZXcgUmVnRXhwKGBeJHtLci5zb3VyY2V9JGApKTtcbiAgaWYgKCFlKVxuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBOb3N0ciBVUkk6ICR7dH1gKTtcbiAgcmV0dXJuIHtcbiAgICB1cmk6IGVbMF0sXG4gICAgdmFsdWU6IGVbMV0sXG4gICAgZGVjb2RlZDogRHIoZVsxXSlcbiAgfTtcbn1cbnZhciBuaCA9IHt9O1xuaWUobmgsIHtcbiAgZmluaXNoUmVhY3Rpb25FdmVudDogKCkgPT4gaWgsXG4gIGdldFJlYWN0ZWRFdmVudFBvaW50ZXI6ICgpID0+IG9oXG59KTtcbmZ1bmN0aW9uIGloKHQsIGUsIHIpIHtcbiAgdmFyIGksIHM7XG4gIGNvbnN0IG4gPSBlLnRhZ3MuZmlsdGVyKFxuICAgIChvKSA9PiBvLmxlbmd0aCA+PSAyICYmIChvWzBdID09PSBcImVcIiB8fCBvWzBdID09PSBcInBcIilcbiAgKTtcbiAgcmV0dXJuIGRhKHtcbiAgICAuLi50LFxuICAgIGtpbmQ6IDcsXG4gICAgdGFnczogW1xuICAgICAgLi4uKGkgPSB0LnRhZ3MpICE9IG51bGwgPyBpIDogW10sXG4gICAgICAuLi5uLFxuICAgICAgW1wiZVwiLCBlLmlkXSxcbiAgICAgIFtcInBcIiwgZS5wdWJrZXldXG4gICAgXSxcbiAgICBjb250ZW50OiAocyA9IHQuY29udGVudCkgIT0gbnVsbCA/IHMgOiBcIitcIlxuICB9LCByKTtcbn1cbmZ1bmN0aW9uIG9oKHQpIHtcbiAgaWYgKHQua2luZCAhPT0gNylcbiAgICByZXR1cm47XG4gIGxldCBlLCByO1xuICBmb3IgKGxldCBuID0gdC50YWdzLmxlbmd0aCAtIDE7IG4gPj0gMCAmJiAoZSA9PT0gdm9pZCAwIHx8IHIgPT09IHZvaWQgMCk7IG4tLSkge1xuICAgIGNvbnN0IGkgPSB0LnRhZ3Nbbl07XG4gICAgaS5sZW5ndGggPj0gMiAmJiAoaVswXSA9PT0gXCJlXCIgJiYgZSA9PT0gdm9pZCAwID8gZSA9IGkgOiBpWzBdID09PSBcInBcIiAmJiByID09PSB2b2lkIDAgJiYgKHIgPSBpKSk7XG4gIH1cbiAgaWYgKCEoZSA9PT0gdm9pZCAwIHx8IHIgPT09IHZvaWQgMCkpXG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiBlWzFdLFxuICAgICAgcmVsYXlzOiBbZVsyXSwgclsyXV0uZmlsdGVyKChuKSA9PiBuICE9PSB2b2lkIDApLFxuICAgICAgYXV0aG9yOiByWzFdXG4gICAgfTtcbn1cbnZhciBzaCA9IHt9O1xuaWUoc2gsIHtcbiAgY3JlYXRlRGVsZWdhdGlvbjogKCkgPT4gYWgsXG4gIGdldERlbGVnYXRvcjogKCkgPT4gY2hcbn0pO1xuZnVuY3Rpb24gYWgodCwgZSkge1xuICBsZXQgciA9IFtdO1xuICAoZS5raW5kIHx8IC0xKSA+PSAwICYmIHIucHVzaChga2luZD0ke2Uua2luZH1gKSwgZS51bnRpbCAmJiByLnB1c2goYGNyZWF0ZWRfYXQ8JHtlLnVudGlsfWApLCBlLnNpbmNlICYmIHIucHVzaChgY3JlYXRlZF9hdD4ke2Uuc2luY2V9YCk7XG4gIGxldCBuID0gci5qb2luKFwiJlwiKTtcbiAgaWYgKG4gPT09IFwiXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwicmVmdXNpbmcgdG8gY3JlYXRlIGEgZGVsZWdhdGlvbiB3aXRob3V0IGFueSBjb25kaXRpb25zXCIpO1xuICBsZXQgaSA9IFluKFxuICAgIEllLmVuY29kZShgbm9zdHI6ZGVsZWdhdGlvbjoke2UucHVia2V5fToke259YClcbiAgKSwgcyA9IHZlKFxuICAgIFN0LnNpZ24oaSwgdClcbiAgKTtcbiAgcmV0dXJuIHtcbiAgICBmcm9tOiBsaSh0KSxcbiAgICB0bzogZS5wdWJrZXksXG4gICAgY29uZDogbixcbiAgICBzaWc6IHNcbiAgfTtcbn1cbmZ1bmN0aW9uIGNoKHQpIHtcbiAgbGV0IGUgPSB0LnRhZ3MuZmluZCgoYSkgPT4gYVswXSA9PT0gXCJkZWxlZ2F0aW9uXCIgJiYgYS5sZW5ndGggPj0gNCk7XG4gIGlmICghZSlcbiAgICByZXR1cm4gbnVsbDtcbiAgbGV0IHIgPSBlWzFdLCBuID0gZVsyXSwgaSA9IGVbM10sIHMgPSBuLnNwbGl0KFwiJlwiKTtcbiAgZm9yIChsZXQgYSA9IDA7IGEgPCBzLmxlbmd0aDsgYSsrKSB7XG4gICAgbGV0IFtjLCBsLCBmXSA9IHNbYV0uc3BsaXQoL1xcYi8pO1xuICAgIGlmICghKGMgPT09IFwia2luZFwiICYmIGwgPT09IFwiPVwiICYmIHQua2luZCA9PT0gcGFyc2VJbnQoZikpKSB7XG4gICAgICBpZiAoYyA9PT0gXCJjcmVhdGVkX2F0XCIgJiYgbCA9PT0gXCI8XCIgJiYgdC5jcmVhdGVkX2F0IDwgcGFyc2VJbnQoZikpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgaWYgKGMgPT09IFwiY3JlYXRlZF9hdFwiICYmIGwgPT09IFwiPlwiICYmIHQuY3JlYXRlZF9hdCA+IHBhcnNlSW50KGYpKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBsZXQgbyA9IFluKFxuICAgIEllLmVuY29kZShgbm9zdHI6ZGVsZWdhdGlvbjoke3QucHVia2V5fToke259YClcbiAgKTtcbiAgcmV0dXJuIFN0LnZlcmlmeShpLCBvLCByKSA/IHIgOiBudWxsO1xufVxudmFyIHVoID0ge307XG5pZSh1aCwge1xuICBtYXRjaEFsbDogKCkgPT4gbGgsXG4gIHJlZ2V4OiAoKSA9PiBwaSxcbiAgcmVwbGFjZUFsbDogKCkgPT4gZmhcbn0pO1xudmFyIHBpID0gKCkgPT4gbmV3IFJlZ0V4cChgXFxcXGIke0tyLnNvdXJjZX1cXFxcYmAsIFwiZ1wiKTtcbmZ1bmN0aW9uKiBsaCh0KSB7XG4gIGNvbnN0IGUgPSB0Lm1hdGNoQWxsKHBpKCkpO1xuICBmb3IgKGNvbnN0IHIgb2YgZSkge1xuICAgIGNvbnN0IFtuLCBpXSA9IHI7XG4gICAgeWllbGQge1xuICAgICAgdXJpOiBuLFxuICAgICAgdmFsdWU6IGksXG4gICAgICBkZWNvZGVkOiBEcihpKSxcbiAgICAgIHN0YXJ0OiByLmluZGV4LFxuICAgICAgZW5kOiByLmluZGV4ICsgbi5sZW5ndGhcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBmaCh0LCBlKSB7XG4gIHJldHVybiB0LnJlcGxhY2VBbGwocGkoKSwgKHIsIG4pID0+IGUoe1xuICAgIHVyaTogcixcbiAgICB2YWx1ZTogbixcbiAgICBkZWNvZGVkOiBEcihuKVxuICB9KSk7XG59XG52YXIgaGggPSB7fTtcbmllKGhoLCB7XG4gIHVzZUZldGNoSW1wbGVtZW50YXRpb246ICgpID0+IGRoLFxuICB2YWxpZGF0ZUdpdGh1YjogKCkgPT4gcGhcbn0pO1xudmFyIHlpO1xudHJ5IHtcbiAgeWkgPSBmZXRjaDtcbn0gY2F0Y2gge1xufVxuZnVuY3Rpb24gZGgodCkge1xuICB5aSA9IHQ7XG59XG5hc3luYyBmdW5jdGlvbiBwaCh0LCBlLCByKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGF3YWl0IChhd2FpdCB5aShgaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vJHtlfS8ke3J9L3Jhd2ApKS50ZXh0KCkgPT09IGBWZXJpZnlpbmcgdGhhdCBJIGNvbnRyb2wgdGhlIGZvbGxvd2luZyBOb3N0ciBwdWJsaWMga2V5OiAke3R9YDtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuICExO1xuICB9XG59XG52YXIgeWggPSB7fTtcbmllKHloLCB7XG4gIGF1dGhlbnRpY2F0ZTogKCkgPT4gZ2hcbn0pO1xudmFyIGdoID0gYXN5bmMgKHtcbiAgY2hhbGxlbmdlOiB0LFxuICByZWxheTogZSxcbiAgc2lnbjogclxufSkgPT4ge1xuICBjb25zdCBuID0ge1xuICAgIGtpbmQ6IDIyMjQyLFxuICAgIGNyZWF0ZWRfYXQ6IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDFlMyksXG4gICAgdGFnczogW1xuICAgICAgW1wicmVsYXlcIiwgZS51cmxdLFxuICAgICAgW1wiY2hhbGxlbmdlXCIsIHRdXG4gICAgXSxcbiAgICBjb250ZW50OiBcIlwiXG4gIH0sIGkgPSBlLmF1dGgoYXdhaXQgcihuKSk7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocywgbykgPT4ge1xuICAgIGkub24oXCJva1wiLCBmdW5jdGlvbiBhKCkge1xuICAgICAgaS5vZmYoXCJva1wiLCBhKSwgcygpO1xuICAgIH0pLCBpLm9uKFwiZmFpbGVkXCIsIGZ1bmN0aW9uIGEoYykge1xuICAgICAgaS5vZmYoXCJmYWlsZWRcIiwgYSksIG8oYyk7XG4gICAgfSk7XG4gIH0pO1xufSwgRWEgPSB7fTtcbmllKEVhLCB7XG4gIGdldFphcEVuZHBvaW50OiAoKSA9PiB2aCxcbiAgbWFrZVphcFJlY2VpcHQ6ICgpID0+IG1oLFxuICBtYWtlWmFwUmVxdWVzdDogKCkgPT4gd2gsXG4gIHVzZUZldGNoSW1wbGVtZW50YXRpb246ICgpID0+IGJoLFxuICB2YWxpZGF0ZVphcFJlcXVlc3Q6ICgpID0+IF9oXG59KTtcbnZhciBnaTtcbnRyeSB7XG4gIGdpID0gZmV0Y2g7XG59IGNhdGNoIHtcbn1cbmZ1bmN0aW9uIGJoKHQpIHtcbiAgZ2kgPSB0O1xufVxuYXN5bmMgZnVuY3Rpb24gdmgodCkge1xuICB0cnkge1xuICAgIGxldCBlID0gXCJcIiwgeyBsdWQwNjogciwgbHVkMTY6IG4gfSA9IEpTT04ucGFyc2UodC5jb250ZW50KTtcbiAgICBpZiAocikge1xuICAgICAgbGV0IHsgd29yZHM6IG8gfSA9IHRlLmRlY29kZShyLCAxZTMpLCBhID0gdGUuZnJvbVdvcmRzKG8pO1xuICAgICAgZSA9IEplLmRlY29kZShhKTtcbiAgICB9IGVsc2UgaWYgKG4pIHtcbiAgICAgIGxldCBbbywgYV0gPSBuLnNwbGl0KFwiQFwiKTtcbiAgICAgIGUgPSBgaHR0cHM6Ly8ke2F9Ly53ZWxsLWtub3duL2xudXJscC8ke299YDtcbiAgICB9IGVsc2VcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBzID0gYXdhaXQgKGF3YWl0IGdpKGUpKS5qc29uKCk7XG4gICAgaWYgKHMuYWxsb3dzTm9zdHIgJiYgcy5ub3N0clB1YmtleSlcbiAgICAgIHJldHVybiBzLmNhbGxiYWNrO1xuICB9IGNhdGNoIHtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHdoKHtcbiAgcHJvZmlsZTogdCxcbiAgZXZlbnQ6IGUsXG4gIGFtb3VudDogcixcbiAgcmVsYXlzOiBuLFxuICBjb21tZW50OiBpID0gXCJcIlxufSkge1xuICBpZiAoIXIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYW1vdW50IG5vdCBnaXZlblwiKTtcbiAgaWYgKCF0KVxuICAgIHRocm93IG5ldyBFcnJvcihcInByb2ZpbGUgbm90IGdpdmVuXCIpO1xuICBsZXQgcyA9IHtcbiAgICBraW5kOiA5NzM0LFxuICAgIGNyZWF0ZWRfYXQ6IE1hdGgucm91bmQoRGF0ZS5ub3coKSAvIDFlMyksXG4gICAgY29udGVudDogaSxcbiAgICB0YWdzOiBbXG4gICAgICBbXCJwXCIsIHRdLFxuICAgICAgW1wiYW1vdW50XCIsIHIudG9TdHJpbmcoKV0sXG4gICAgICBbXCJyZWxheXNcIiwgLi4ubl1cbiAgICBdXG4gIH07XG4gIHJldHVybiBlICYmIHMudGFncy5wdXNoKFtcImVcIiwgZV0pLCBzO1xufVxuZnVuY3Rpb24gX2godCkge1xuICBsZXQgZTtcbiAgdHJ5IHtcbiAgICBlID0gSlNPTi5wYXJzZSh0KTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIFwiSW52YWxpZCB6YXAgcmVxdWVzdCBKU09OLlwiO1xuICB9XG4gIGlmICghZmkoZSkpXG4gICAgcmV0dXJuIFwiWmFwIHJlcXVlc3QgaXMgbm90IGEgdmFsaWQgTm9zdHIgZXZlbnQuXCI7XG4gIGlmICghaGkoZSkpXG4gICAgcmV0dXJuIFwiSW52YWxpZCBzaWduYXR1cmUgb24gemFwIHJlcXVlc3QuXCI7XG4gIGxldCByID0gZS50YWdzLmZpbmQoKFtzLCBvXSkgPT4gcyA9PT0gXCJwXCIgJiYgbyk7XG4gIGlmICghcilcbiAgICByZXR1cm4gXCJaYXAgcmVxdWVzdCBkb2Vzbid0IGhhdmUgYSAncCcgdGFnLlwiO1xuICBpZiAoIXJbMV0ubWF0Y2goL15bYS1mMC05XXs2NH0kLykpXG4gICAgcmV0dXJuIFwiWmFwIHJlcXVlc3QgJ3AnIHRhZyBpcyBub3QgdmFsaWQgaGV4LlwiO1xuICBsZXQgbiA9IGUudGFncy5maW5kKChbcywgb10pID0+IHMgPT09IFwiZVwiICYmIG8pO1xuICByZXR1cm4gbiAmJiAhblsxXS5tYXRjaCgvXlthLWYwLTldezY0fSQvKSA/IFwiWmFwIHJlcXVlc3QgJ2UnIHRhZyBpcyBub3QgdmFsaWQgaGV4LlwiIDogZS50YWdzLmZpbmQoKFtzLCBvXSkgPT4gcyA9PT0gXCJyZWxheXNcIiAmJiBvKSA/IG51bGwgOiBcIlphcCByZXF1ZXN0IGRvZXNuJ3QgaGF2ZSBhICdyZWxheXMnIHRhZy5cIjtcbn1cbmZ1bmN0aW9uIG1oKHtcbiAgemFwUmVxdWVzdDogdCxcbiAgcHJlaW1hZ2U6IGUsXG4gIGJvbHQxMTogcixcbiAgcGFpZEF0OiBuXG59KSB7XG4gIGxldCBzID0gSlNPTi5wYXJzZSh0KS50YWdzLmZpbHRlcihcbiAgICAoW2FdKSA9PiBhID09PSBcImVcIiB8fCBhID09PSBcInBcIiB8fCBhID09PSBcImFcIlxuICApLCBvID0ge1xuICAgIGtpbmQ6IDk3MzUsXG4gICAgY3JlYXRlZF9hdDogTWF0aC5yb3VuZChuLmdldFRpbWUoKSAvIDFlMyksXG4gICAgY29udGVudDogXCJcIixcbiAgICB0YWdzOiBbXG4gICAgICAuLi5zLFxuICAgICAgW1wiYm9sdDExXCIsIHJdLFxuICAgICAgW1wiZGVzY3JpcHRpb25cIiwgdF1cbiAgICBdXG4gIH07XG4gIHJldHVybiBlICYmIG8udGFncy5wdXNoKFtcInByZWltYWdlXCIsIGVdKSwgbztcbn1cbnZhciBjciA9IHt9O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGNyLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG5jci5pc19ub2RlID0gdm9pZCAwO1xudmFyIGRuID0gbnVsbDtcbmZ1bmN0aW9uIHhoKCkge1xuICByZXR1cm4gZG4gPT09IG51bGwgJiYgKGRuID0gdHlwZW9mIFMgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUy5wcm9jZXNzID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFMucHJvY2Vzcy52ZXJzaW9ucyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBTLnByb2Nlc3MudmVyc2lvbnMubm9kZSA8IFwidVwiKSwgZG47XG59XG5jci5pc19ub2RlID0geGg7XG52YXIgcG4gPSB7fSwgeW4sIFhpO1xuZnVuY3Rpb24gRWgoKSB7XG4gIGlmIChYaSlcbiAgICByZXR1cm4geW47XG4gIFhpID0gMTtcbiAgdmFyIHQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodHlwZW9mIHNlbGYgPT0gXCJvYmplY3RcIiAmJiBzZWxmKVxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT0gXCJvYmplY3RcIiAmJiB3aW5kb3cpXG4gICAgICByZXR1cm4gd2luZG93O1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byByZXNvbHZlIGdsb2JhbCBgdGhpc2BcIik7XG4gIH07XG4gIHJldHVybiB5biA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzKVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzID09IFwib2JqZWN0XCIgJiYgZ2xvYmFsVGhpcylcbiAgICAgIHJldHVybiBnbG9iYWxUaGlzO1xuICAgIHRyeSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0LnByb3RvdHlwZSwgXCJfX2dsb2JhbF9fXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gdCgpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIF9fZ2xvYmFsX18gfHwgdCgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBkZWxldGUgT2JqZWN0LnByb3RvdHlwZS5fX2dsb2JhbF9fO1xuICAgIH1cbiAgfSgpLCB5bjtcbn1cbmNvbnN0IGtoID0gXCJ3ZWJzb2NrZXRcIiwgU2ggPSBcIldlYnNvY2tldCBDbGllbnQgJiBTZXJ2ZXIgTGlicmFyeSBpbXBsZW1lbnRpbmcgdGhlIFdlYlNvY2tldCBwcm90b2NvbCBhcyBzcGVjaWZpZWQgaW4gUkZDIDY0NTUuXCIsIE9oID0gW1xuICBcIndlYnNvY2tldFwiLFxuICBcIndlYnNvY2tldHNcIixcbiAgXCJzb2NrZXRcIixcbiAgXCJuZXR3b3JraW5nXCIsXG4gIFwiY29tZXRcIixcbiAgXCJwdXNoXCIsXG4gIFwiUkZDLTY0NTVcIixcbiAgXCJyZWFsdGltZVwiLFxuICBcInNlcnZlclwiLFxuICBcImNsaWVudFwiXG5dLCBBaCA9IFwiQnJpYW4gTWNLZWx2ZXkgPHRoZXR1cnRsZTMyQGdtYWlsLmNvbT4gKGh0dHBzOi8vZ2l0aHViLmNvbS90aGV0dXJ0bGUzMilcIiwgQ2ggPSBbXG4gIFwiSVxceEYxYWtpIEJheiBDYXN0aWxsbyA8aWJjQGFsaWF4Lm5ldD4gKGh0dHA6Ly9kZXYuc2lwZG9jLm5ldClcIlxuXSwgSWggPSBcIjEuMC4zNFwiLCBSaCA9IHtcbiAgdHlwZTogXCJnaXRcIixcbiAgdXJsOiBcImh0dHBzOi8vZ2l0aHViLmNvbS90aGV0dXJ0bGUzMi9XZWJTb2NrZXQtTm9kZS5naXRcIlxufSwgVGggPSBcImh0dHBzOi8vZ2l0aHViLmNvbS90aGV0dXJ0bGUzMi9XZWJTb2NrZXQtTm9kZVwiLCBQaCA9IHtcbiAgbm9kZTogXCI+PTQuMC4wXCJcbn0sIEJoID0ge1xuICBidWZmZXJ1dGlsOiBcIl40LjAuMVwiLFxuICBkZWJ1ZzogXCJeMi4yLjBcIixcbiAgXCJlczUtZXh0XCI6IFwiXjAuMTAuNTBcIixcbiAgXCJ0eXBlZGFycmF5LXRvLWJ1ZmZlclwiOiBcIl4zLjEuNVwiLFxuICBcInV0Zi04LXZhbGlkYXRlXCI6IFwiXjUuMC4yXCIsXG4gIHlhZXRpOiBcIl4wLjAuNlwiXG59LCBMaCA9IHtcbiAgXCJidWZmZXItZXF1YWxcIjogXCJeMS4wLjBcIixcbiAgZ3VscDogXCJeNC4wLjJcIixcbiAgXCJndWxwLWpzaGludFwiOiBcIl4yLjAuNFwiLFxuICBcImpzaGludC1zdHlsaXNoXCI6IFwiXjIuMi4xXCIsXG4gIGpzaGludDogXCJeMi4wLjBcIixcbiAgdGFwZTogXCJeNC45LjFcIlxufSwgJGggPSB7XG4gIHZlcmJvc2U6ICExXG59LCBxaCA9IHtcbiAgdGVzdDogXCJ0YXBlIHRlc3QvdW5pdC8qLmpzXCIsXG4gIGd1bHA6IFwiZ3VscFwiXG59LCBOaCA9IFwiaW5kZXhcIiwgVWggPSB7XG4gIGxpYjogXCIuL2xpYlwiXG59LCBqaCA9IFwibGliL2Jyb3dzZXIuanNcIiwgSGggPSBcIkFwYWNoZS0yLjBcIiwgTWggPSB7XG4gIG5hbWU6IGtoLFxuICBkZXNjcmlwdGlvbjogU2gsXG4gIGtleXdvcmRzOiBPaCxcbiAgYXV0aG9yOiBBaCxcbiAgY29udHJpYnV0b3JzOiBDaCxcbiAgdmVyc2lvbjogSWgsXG4gIHJlcG9zaXRvcnk6IFJoLFxuICBob21lcGFnZTogVGgsXG4gIGVuZ2luZXM6IFBoLFxuICBkZXBlbmRlbmNpZXM6IEJoLFxuICBkZXZEZXBlbmRlbmNpZXM6IExoLFxuICBjb25maWc6ICRoLFxuICBzY3JpcHRzOiBxaCxcbiAgbWFpbjogTmgsXG4gIGRpcmVjdG9yaWVzOiBVaCxcbiAgYnJvd3NlcjogamgsXG4gIGxpY2Vuc2U6IEhoXG59O1xudmFyIGduLCBRaTtcbmZ1bmN0aW9uIERoKCkge1xuICByZXR1cm4gUWkgfHwgKFFpID0gMSwgZ24gPSBNaC52ZXJzaW9uKSwgZ247XG59XG52YXIgYm4sIGVvO1xuZnVuY3Rpb24gemgoKSB7XG4gIGlmIChlbylcbiAgICByZXR1cm4gYm47XG4gIGVvID0gMTtcbiAgdmFyIHQ7XG4gIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PSBcIm9iamVjdFwiKVxuICAgIHQgPSBnbG9iYWxUaGlzO1xuICBlbHNlXG4gICAgdHJ5IHtcbiAgICAgIHQgPSBFaCgpO1xuICAgIH0gY2F0Y2gge1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoIXQgJiYgdHlwZW9mIHdpbmRvdyA8IFwidVwiICYmICh0ID0gd2luZG93KSwgIXQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBkZXRlcm1pbmUgZ2xvYmFsIHRoaXNcIik7XG4gICAgfVxuICB2YXIgZSA9IHQuV2ViU29ja2V0IHx8IHQuTW96V2ViU29ja2V0LCByID0gRGgoKTtcbiAgZnVuY3Rpb24gbihpLCBzKSB7XG4gICAgdmFyIG87XG4gICAgcmV0dXJuIHMgPyBvID0gbmV3IGUoaSwgcykgOiBvID0gbmV3IGUoaSksIG87XG4gIH1cbiAgcmV0dXJuIGUgJiYgW1wiQ09OTkVDVElOR1wiLCBcIk9QRU5cIiwgXCJDTE9TSU5HXCIsIFwiQ0xPU0VEXCJdLmZvckVhY2goZnVuY3Rpb24oaSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBpLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZVtpXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSksIGJuID0ge1xuICAgIHczY3dlYnNvY2tldDogZSA/IG4gOiBudWxsLFxuICAgIHZlcnNpb246IHJcbiAgfSwgYm47XG59XG52YXIgX3IgPSB7fSwgdm4gPSB7fSwgUnQgPSB7fSwgVHQgPSB7fSwgUHQgPSB7fSwgQnQgPSB7fSwgdG87XG5mdW5jdGlvbiBGaCgpIHtcbiAgaWYgKHRvKVxuICAgIHJldHVybiBCdDtcbiAgdG8gPSAxLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgQnQuRm9yT2ZBZGFwdG9yID0gdm9pZCAwO1xuICB2YXIgdCA9IGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIGUociwgbikge1xuICAgICAgdGhpcy5pdF8gPSByLCB0aGlzLmxhc3RfID0gbjtcbiAgICB9XG4gICAgcmV0dXJuIGUucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLml0Xy5lcXVhbHModGhpcy5sYXN0XykpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZG9uZTogITAsXG4gICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9O1xuICAgICAgdmFyIHIgPSB0aGlzLml0XztcbiAgICAgIHJldHVybiB0aGlzLml0XyA9IHRoaXMuaXRfLm5leHQoKSwge1xuICAgICAgICBkb25lOiAhMSxcbiAgICAgICAgdmFsdWU6IHIudmFsdWVcbiAgICAgIH07XG4gICAgfSwgZS5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSwgZTtcbiAgfSgpO1xuICByZXR1cm4gQnQuRm9yT2ZBZGFwdG9yID0gdCwgQnQ7XG59XG52YXIgcm87XG5mdW5jdGlvbiBiaSgpIHtcbiAgaWYgKHJvKVxuICAgIHJldHVybiBQdDtcbiAgcm8gPSAxO1xuICB2YXIgdCA9IFMgJiYgUy5fX3ZhbHVlcyB8fCBmdW5jdGlvbihuKSB7XG4gICAgdmFyIGkgPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIHMgPSBpICYmIG5baV0sIG8gPSAwO1xuICAgIGlmIChzKVxuICAgICAgcmV0dXJuIHMuY2FsbChuKTtcbiAgICBpZiAobiAmJiB0eXBlb2Ygbi5sZW5ndGggPT0gXCJudW1iZXJcIilcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBuICYmIG8gPj0gbi5sZW5ndGggJiYgKG4gPSB2b2lkIDApLCB7IHZhbHVlOiBuICYmIG5bbysrXSwgZG9uZTogIW4gfTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGkgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQdCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBQdC5Db250YWluZXIgPSB2b2lkIDA7XG4gIHZhciBlID0gRmgoKSwgciA9IGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIG4oKSB7XG4gICAgfVxuICAgIHJldHVybiBuLnByb3RvdHlwZS5lbXB0eSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2l6ZSgpID09PSAwO1xuICAgIH0sIG4ucHJvdG90eXBlLnJiZWdpbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZW5kKCkucmV2ZXJzZSgpO1xuICAgIH0sIG4ucHJvdG90eXBlLnJlbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmJlZ2luKCkucmV2ZXJzZSgpO1xuICAgIH0sIG4ucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgZS5Gb3JPZkFkYXB0b3IodGhpcy5iZWdpbigpLCB0aGlzLmVuZCgpKTtcbiAgICB9LCBuLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpLCBzLCBvID0gW107XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBhID0gdCh0aGlzKSwgYyA9IGEubmV4dCgpOyAhYy5kb25lOyBjID0gYS5uZXh0KCkpIHtcbiAgICAgICAgICB2YXIgbCA9IGMudmFsdWU7XG4gICAgICAgICAgby5wdXNoKGwpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChmKSB7XG4gICAgICAgIGkgPSB7IGVycm9yOiBmIH07XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGMgJiYgIWMuZG9uZSAmJiAocyA9IGEucmV0dXJuKSAmJiBzLmNhbGwoYSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKGkpXG4gICAgICAgICAgICB0aHJvdyBpLmVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbztcbiAgICB9LCBuO1xuICB9KCk7XG4gIHJldHVybiBQdC5Db250YWluZXIgPSByLCBQdDtcbn1cbnZhciBMdCA9IHt9LCBubztcbmZ1bmN0aW9uIHZpKCkge1xuICBpZiAobm8pXG4gICAgcmV0dXJuIEx0O1xuICBubyA9IDE7XG4gIHZhciB0ID0gUyAmJiBTLl9fcmVhZCB8fCBmdW5jdGlvbihyLCBuKSB7XG4gICAgdmFyIGkgPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiByW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFpKVxuICAgICAgcmV0dXJuIHI7XG4gICAgdmFyIHMgPSBpLmNhbGwociksIG8sIGEgPSBbXSwgYztcbiAgICB0cnkge1xuICAgICAgZm9yICg7IChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShvID0gcy5uZXh0KCkpLmRvbmU7IClcbiAgICAgICAgYS5wdXNoKG8udmFsdWUpO1xuICAgIH0gY2F0Y2ggKGwpIHtcbiAgICAgIGMgPSB7IGVycm9yOiBsIH07XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG8gJiYgIW8uZG9uZSAmJiAoaSA9IHMucmV0dXJuKSAmJiBpLmNhbGwocyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoYylcbiAgICAgICAgICB0aHJvdyBjLmVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYTtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEx0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIEx0Lk5hdGl2ZUFycmF5SXRlcmF0b3IgPSB2b2lkIDA7XG4gIHZhciBlID0gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gcihuLCBpKSB7XG4gICAgICB0aGlzLmRhdGFfID0gbiwgdGhpcy5pbmRleF8gPSBpO1xuICAgIH1cbiAgICByZXR1cm4gci5wcm90b3R5cGUuaW5kZXggPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmluZGV4XztcbiAgICB9LCBPYmplY3QuZGVmaW5lUHJvcGVydHkoci5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YV9bdGhpcy5pbmRleF9dO1xuICAgICAgfSxcbiAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgIH0pLCByLnByb3RvdHlwZS5wcmV2ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gLS10aGlzLmluZGV4XywgdGhpcztcbiAgICB9LCByLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gKyt0aGlzLmluZGV4XywgdGhpcztcbiAgICB9LCByLnByb3RvdHlwZS5hZHZhbmNlID0gZnVuY3Rpb24obikge1xuICAgICAgcmV0dXJuIHRoaXMuaW5kZXhfICs9IG4sIHRoaXM7XG4gICAgfSwgci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24obikge1xuICAgICAgcmV0dXJuIHRoaXMuZGF0YV8gPT09IG4uZGF0YV8gJiYgdGhpcy5pbmRleF8gPT09IG4uaW5kZXhfO1xuICAgIH0sIHIucHJvdG90eXBlLnN3YXAgPSBmdW5jdGlvbihuKSB7XG4gICAgICB2YXIgaSwgcztcbiAgICAgIGkgPSB0KFtuLmRhdGFfLCB0aGlzLmRhdGFfXSwgMiksIHRoaXMuZGF0YV8gPSBpWzBdLCBuLmRhdGFfID0gaVsxXSwgcyA9IHQoW24uaW5kZXhfLCB0aGlzLmluZGV4X10sIDIpLCB0aGlzLmluZGV4XyA9IHNbMF0sIG4uaW5kZXhfID0gc1sxXTtcbiAgICB9LCByO1xuICB9KCk7XG4gIHJldHVybiBMdC5OYXRpdmVBcnJheUl0ZXJhdG9yID0gZSwgTHQ7XG59XG52YXIgaW87XG5mdW5jdGlvbiBLaCgpIHtcbiAgaWYgKGlvKVxuICAgIHJldHVybiBUdDtcbiAgaW8gPSAxO1xuICB2YXIgdCA9IFMgJiYgUy5fX2V4dGVuZHMgfHwgZnVuY3Rpb24oKSB7XG4gICAgdmFyIGkgPSBmdW5jdGlvbihzLCBvKSB7XG4gICAgICByZXR1cm4gaSA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uKGEsIGMpIHtcbiAgICAgICAgYS5fX3Byb3RvX18gPSBjO1xuICAgICAgfSB8fCBmdW5jdGlvbihhLCBjKSB7XG4gICAgICAgIGZvciAodmFyIGwgaW4gYylcbiAgICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYywgbCkgJiYgKGFbbF0gPSBjW2xdKTtcbiAgICAgIH0sIGkocywgbyk7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24ocywgbykge1xuICAgICAgaWYgKHR5cGVvZiBvICE9IFwiZnVuY3Rpb25cIiAmJiBvICE9PSBudWxsKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhvKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICBpKHMsIG8pO1xuICAgICAgZnVuY3Rpb24gYSgpIHtcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IHM7XG4gICAgICB9XG4gICAgICBzLnByb3RvdHlwZSA9IG8gPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKG8pIDogKGEucHJvdG90eXBlID0gby5wcm90b3R5cGUsIG5ldyBhKCkpO1xuICAgIH07XG4gIH0oKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFR0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIFR0LlNldENvbnRhaW5lciA9IHZvaWQgMDtcbiAgdmFyIGUgPSBiaSgpLCByID0gdmkoKSwgbiA9IGZ1bmN0aW9uKGkpIHtcbiAgICB0KHMsIGkpO1xuICAgIGZ1bmN0aW9uIHMobykge1xuICAgICAgdmFyIGEgPSBpLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgIHJldHVybiBhLmRhdGFfID0gbyhhKSwgYTtcbiAgICB9XG4gICAgcmV0dXJuIHMucHJvdG90eXBlLmFzc2lnbiA9IGZ1bmN0aW9uKG8sIGEpIHtcbiAgICAgIHRoaXMuY2xlYXIoKSwgdGhpcy5pbnNlcnQobywgYSk7XG4gICAgfSwgcy5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZGF0YV8uY2xlYXIoKTtcbiAgICB9LCBzLnByb3RvdHlwZS5iZWdpbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGF0YV8uYmVnaW4oKTtcbiAgICB9LCBzLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmRhdGFfLmVuZCgpO1xuICAgIH0sIHMucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgIHJldHVybiAhdGhpcy5maW5kKG8pLmVxdWFscyh0aGlzLmVuZCgpKTtcbiAgICB9LCBzLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5kYXRhXy5zaXplKCk7XG4gICAgfSwgcy5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgZm9yICh2YXIgbyA9IFtdLCBhID0gMDsgYSA8IGFyZ3VtZW50cy5sZW5ndGg7IGErKylcbiAgICAgICAgb1thXSA9IGFyZ3VtZW50c1thXTtcbiAgICAgIGlmIChvLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZSgpO1xuICAgICAgdmFyIGMgPSBuZXcgci5OYXRpdmVBcnJheUl0ZXJhdG9yKG8sIDApLCBsID0gbmV3IHIuTmF0aXZlQXJyYXlJdGVyYXRvcihvLCBvLmxlbmd0aCk7XG4gICAgICByZXR1cm4gdGhpcy5fSW5zZXJ0X2J5X3JhbmdlKGMsIGwpLCB0aGlzLnNpemUoKTtcbiAgICB9LCBzLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGZvciAodmFyIG8gPSBbXSwgYSA9IDA7IGEgPCBhcmd1bWVudHMubGVuZ3RoOyBhKyspXG4gICAgICAgIG9bYV0gPSBhcmd1bWVudHNbYV07XG4gICAgICByZXR1cm4gby5sZW5ndGggPT09IDEgPyB0aGlzLl9JbnNlcnRfYnlfa2V5KG9bMF0pIDogb1swXS5uZXh0IGluc3RhbmNlb2YgRnVuY3Rpb24gJiYgb1sxXS5uZXh0IGluc3RhbmNlb2YgRnVuY3Rpb24gPyB0aGlzLl9JbnNlcnRfYnlfcmFuZ2Uob1swXSwgb1sxXSkgOiB0aGlzLl9JbnNlcnRfYnlfaGludChvWzBdLCBvWzFdKTtcbiAgICB9LCBzLnByb3RvdHlwZS5lcmFzZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgZm9yICh2YXIgbyA9IFtdLCBhID0gMDsgYSA8IGFyZ3VtZW50cy5sZW5ndGg7IGErKylcbiAgICAgICAgb1thXSA9IGFyZ3VtZW50c1thXTtcbiAgICAgIHJldHVybiBvLmxlbmd0aCA9PT0gMSAmJiAhKG9bMF0gaW5zdGFuY2VvZiB0aGlzLmVuZCgpLmNvbnN0cnVjdG9yICYmIG9bMF0uc291cmNlKCkgPT09IHRoaXMpID8gdGhpcy5fRXJhc2VfYnlfdmFsKG9bMF0pIDogby5sZW5ndGggPT09IDEgPyB0aGlzLl9FcmFzZV9ieV9yYW5nZShvWzBdKSA6IHRoaXMuX0VyYXNlX2J5X3JhbmdlKG9bMF0sIG9bMV0pO1xuICAgIH0sIHMucHJvdG90eXBlLl9FcmFzZV9ieV9yYW5nZSA9IGZ1bmN0aW9uKG8sIGEpIHtcbiAgICAgIGEgPT09IHZvaWQgMCAmJiAoYSA9IG8ubmV4dCgpKTtcbiAgICAgIHZhciBjID0gdGhpcy5kYXRhXy5lcmFzZShvLCBhKTtcbiAgICAgIHJldHVybiB0aGlzLl9IYW5kbGVfZXJhc2UobywgYSksIGM7XG4gICAgfSwgcztcbiAgfShlLkNvbnRhaW5lcik7XG4gIHJldHVybiBUdC5TZXRDb250YWluZXIgPSBuLCBUdDtcbn1cbnZhciB3biA9IHt9LCAkdCA9IHt9LCBxdCA9IHt9LCBOdCA9IHt9LCBvbztcbmZ1bmN0aW9uIFdoKCkge1xuICBpZiAob28pXG4gICAgcmV0dXJuIE50O1xuICBvbyA9IDE7XG4gIHZhciB0ID0gUyAmJiBTLl9fZXh0ZW5kcyB8fCBmdW5jdGlvbigpIHtcbiAgICB2YXIgciA9IGZ1bmN0aW9uKG4sIGkpIHtcbiAgICAgIHJldHVybiByID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24ocywgbykge1xuICAgICAgICBzLl9fcHJvdG9fXyA9IG87XG4gICAgICB9IHx8IGZ1bmN0aW9uKHMsIG8pIHtcbiAgICAgICAgZm9yICh2YXIgYSBpbiBvKVxuICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBhKSAmJiAoc1thXSA9IG9bYV0pO1xuICAgICAgfSwgcihuLCBpKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbihuLCBpKSB7XG4gICAgICBpZiAodHlwZW9mIGkgIT0gXCJmdW5jdGlvblwiICYmIGkgIT09IG51bGwpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGkpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgIHIobiwgaSk7XG4gICAgICBmdW5jdGlvbiBzKCkge1xuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yID0gbjtcbiAgICAgIH1cbiAgICAgIG4ucHJvdG90eXBlID0gaSA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoaSkgOiAocy5wcm90b3R5cGUgPSBpLnByb3RvdHlwZSwgbmV3IHMoKSk7XG4gICAgfTtcbiAgfSgpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTnQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgTnQuRXhjZXB0aW9uID0gdm9pZCAwO1xuICB2YXIgZSA9IGZ1bmN0aW9uKHIpIHtcbiAgICB0KG4sIHIpO1xuICAgIGZ1bmN0aW9uIG4oaSkge1xuICAgICAgdmFyIHMgPSB0aGlzLmNvbnN0cnVjdG9yLCBvID0gci5jYWxsKHRoaXMsIGkpIHx8IHRoaXMsIGEgPSBzLnByb3RvdHlwZTtcbiAgICAgIHJldHVybiBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YobywgYSkgOiBvLl9fcHJvdG9fXyA9IGEsIG87XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkobi5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgfSxcbiAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgIH0pLCBuLnByb3RvdHlwZS53aGF0ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5tZXNzYWdlO1xuICAgIH0sIG4ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICAgIHN0YWNrOiB0aGlzLnN0YWNrXG4gICAgICB9O1xuICAgIH0sIG47XG4gIH0oRXJyb3IpO1xuICByZXR1cm4gTnQuRXhjZXB0aW9uID0gZSwgTnQ7XG59XG52YXIgc287XG5mdW5jdGlvbiBrYSgpIHtcbiAgaWYgKHNvKVxuICAgIHJldHVybiBxdDtcbiAgc28gPSAxO1xuICB2YXIgdCA9IFMgJiYgUy5fX2V4dGVuZHMgfHwgZnVuY3Rpb24oKSB7XG4gICAgdmFyIG4gPSBmdW5jdGlvbihpLCBzKSB7XG4gICAgICByZXR1cm4gbiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uKG8sIGEpIHtcbiAgICAgICAgby5fX3Byb3RvX18gPSBhO1xuICAgICAgfSB8fCBmdW5jdGlvbihvLCBhKSB7XG4gICAgICAgIGZvciAodmFyIGMgaW4gYSlcbiAgICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYSwgYykgJiYgKG9bY10gPSBhW2NdKTtcbiAgICAgIH0sIG4oaSwgcyk7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24oaSwgcykge1xuICAgICAgaWYgKHR5cGVvZiBzICE9IFwiZnVuY3Rpb25cIiAmJiBzICE9PSBudWxsKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhzKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICBuKGksIHMpO1xuICAgICAgZnVuY3Rpb24gbygpIHtcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IGk7XG4gICAgICB9XG4gICAgICBpLnByb3RvdHlwZSA9IHMgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKHMpIDogKG8ucHJvdG90eXBlID0gcy5wcm90b3R5cGUsIG5ldyBvKCkpO1xuICAgIH07XG4gIH0oKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHF0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIHF0LkxvZ2ljRXJyb3IgPSB2b2lkIDA7XG4gIHZhciBlID0gV2goKSwgciA9IGZ1bmN0aW9uKG4pIHtcbiAgICB0KGksIG4pO1xuICAgIGZ1bmN0aW9uIGkocykge1xuICAgICAgcmV0dXJuIG4uY2FsbCh0aGlzLCBzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gaTtcbiAgfShlLkV4Y2VwdGlvbik7XG4gIHJldHVybiBxdC5Mb2dpY0Vycm9yID0gciwgcXQ7XG59XG52YXIgYW87XG5mdW5jdGlvbiBTYSgpIHtcbiAgaWYgKGFvKVxuICAgIHJldHVybiAkdDtcbiAgYW8gPSAxO1xuICB2YXIgdCA9IFMgJiYgUy5fX2V4dGVuZHMgfHwgZnVuY3Rpb24oKSB7XG4gICAgdmFyIG4gPSBmdW5jdGlvbihpLCBzKSB7XG4gICAgICByZXR1cm4gbiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uKG8sIGEpIHtcbiAgICAgICAgby5fX3Byb3RvX18gPSBhO1xuICAgICAgfSB8fCBmdW5jdGlvbihvLCBhKSB7XG4gICAgICAgIGZvciAodmFyIGMgaW4gYSlcbiAgICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYSwgYykgJiYgKG9bY10gPSBhW2NdKTtcbiAgICAgIH0sIG4oaSwgcyk7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24oaSwgcykge1xuICAgICAgaWYgKHR5cGVvZiBzICE9IFwiZnVuY3Rpb25cIiAmJiBzICE9PSBudWxsKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhzKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICBuKGksIHMpO1xuICAgICAgZnVuY3Rpb24gbygpIHtcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IGk7XG4gICAgICB9XG4gICAgICBpLnByb3RvdHlwZSA9IHMgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKHMpIDogKG8ucHJvdG90eXBlID0gcy5wcm90b3R5cGUsIG5ldyBvKCkpO1xuICAgIH07XG4gIH0oKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCR0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksICR0LkludmFsaWRBcmd1bWVudCA9IHZvaWQgMDtcbiAgdmFyIGUgPSBrYSgpLCByID0gZnVuY3Rpb24obikge1xuICAgIHQoaSwgbik7XG4gICAgZnVuY3Rpb24gaShzKSB7XG4gICAgICByZXR1cm4gbi5jYWxsKHRoaXMsIHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBpO1xuICB9KGUuTG9naWNFcnJvcik7XG4gIHJldHVybiAkdC5JbnZhbGlkQXJndW1lbnQgPSByLCAkdDtcbn1cbnZhciBVdCA9IHt9LCBjbztcbmZ1bmN0aW9uIFZoKCkge1xuICBpZiAoY28pXG4gICAgcmV0dXJuIFV0O1xuICBjbyA9IDE7XG4gIHZhciB0ID0gUyAmJiBTLl9fZXh0ZW5kcyB8fCBmdW5jdGlvbigpIHtcbiAgICB2YXIgbiA9IGZ1bmN0aW9uKGksIHMpIHtcbiAgICAgIHJldHVybiBuID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24obywgYSkge1xuICAgICAgICBvLl9fcHJvdG9fXyA9IGE7XG4gICAgICB9IHx8IGZ1bmN0aW9uKG8sIGEpIHtcbiAgICAgICAgZm9yICh2YXIgYyBpbiBhKVxuICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhLCBjKSAmJiAob1tjXSA9IGFbY10pO1xuICAgICAgfSwgbihpLCBzKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbihpLCBzKSB7XG4gICAgICBpZiAodHlwZW9mIHMgIT0gXCJmdW5jdGlvblwiICYmIHMgIT09IG51bGwpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKHMpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgIG4oaSwgcyk7XG4gICAgICBmdW5jdGlvbiBvKCkge1xuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yID0gaTtcbiAgICAgIH1cbiAgICAgIGkucHJvdG90eXBlID0gcyA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUocykgOiAoby5wcm90b3R5cGUgPSBzLnByb3RvdHlwZSwgbmV3IG8oKSk7XG4gICAgfTtcbiAgfSgpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVXQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgVXQuT3V0T2ZSYW5nZSA9IHZvaWQgMDtcbiAgdmFyIGUgPSBrYSgpLCByID0gZnVuY3Rpb24obikge1xuICAgIHQoaSwgbik7XG4gICAgZnVuY3Rpb24gaShzKSB7XG4gICAgICByZXR1cm4gbi5jYWxsKHRoaXMsIHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBpO1xuICB9KGUuTG9naWNFcnJvcik7XG4gIHJldHVybiBVdC5PdXRPZlJhbmdlID0gciwgVXQ7XG59XG52YXIgdW87XG5mdW5jdGlvbiBXcigpIHtcbiAgcmV0dXJuIHVvIHx8ICh1byA9IDEsIGZ1bmN0aW9uKHQpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCB0LkVycm9yR2VuZXJhdG9yID0gdm9pZCAwO1xuICAgIHZhciBlID0gU2EoKSwgciA9IFZoKCk7XG4gICAgKGZ1bmN0aW9uKG4pIHtcbiAgICAgIGZ1bmN0aW9uIGkoZCkge1xuICAgICAgICBpZiAodHlwZW9mIGQgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgdmFyIHAgPSBkLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICAgIHJldHVybiBkLmNvbnN0cnVjdG9yLl9fTU9EVUxFICYmIChwID0gXCJcIi5jb25jYXQoZC5jb25zdHJ1Y3Rvci5fX01PRFVMRSwgXCIuXCIpLmNvbmNhdChwKSksIFwic3RkLlwiLmNvbmNhdChwKTtcbiAgICAgIH1cbiAgICAgIG4uZ2V0X2NsYXNzX25hbWUgPSBpO1xuICAgICAgZnVuY3Rpb24gcyhkLCBwKSB7XG4gICAgICAgIHJldHVybiBuZXcgci5PdXRPZlJhbmdlKFwiRXJyb3Igb24gXCIuY29uY2F0KGkoZCksIFwiLlwiKS5jb25jYXQocCwgXCIoKTogaXQncyBlbXB0eSBjb250YWluZXIuXCIpKTtcbiAgICAgIH1cbiAgICAgIG4uZW1wdHkgPSBzO1xuICAgICAgZnVuY3Rpb24gbyhkLCBwLCB5KSB7XG4gICAgICAgIHJldHVybiBuZXcgci5PdXRPZlJhbmdlKFwiRXJyb3Igb24gXCIuY29uY2F0KGkoZCksIFwiLlwiKS5jb25jYXQocCwgXCIoKTogcGFyYW1ldHJpYyBpbmRleCBpcyBuZWdhdGl2ZSAtPiAoaW5kZXggPSBcIikuY29uY2F0KHksIFwiKS5cIikpO1xuICAgICAgfVxuICAgICAgbi5uZWdhdGl2ZV9pbmRleCA9IG87XG4gICAgICBmdW5jdGlvbiBhKGQsIHAsIHksIGcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyByLk91dE9mUmFuZ2UoXCJFcnJvciBvbiBcIi5jb25jYXQoaShkKSwgXCIuXCIpLmNvbmNhdChwLCBcIigpOiBwYXJhbWV0cmljIGluZGV4IGlzIGVxdWFsIG9yIGdyZWF0ZXIgdGhhbiBzaXplIC0+IChpbmRleCA9IFwiKS5jb25jYXQoeSwgXCIsIHNpemU6IFwiKS5jb25jYXQoZywgXCIpLlwiKSk7XG4gICAgICB9XG4gICAgICBuLmV4Y2Vzc2l2ZV9pbmRleCA9IGE7XG4gICAgICBmdW5jdGlvbiBjKGQsIHApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBlLkludmFsaWRBcmd1bWVudChcIkVycm9yIG9uIFwiLmNvbmNhdChpKGQpLCBcIi5cIikuY29uY2F0KHAsIFwiKCk6IHBhcmFtZXRyaWMgaXRlcmF0b3IgaXMgbm90IHRoaXMgY29udGFpbmVyJ3Mgb3duLlwiKSk7XG4gICAgICB9XG4gICAgICBuLm5vdF9teV9pdGVyYXRvciA9IGM7XG4gICAgICBmdW5jdGlvbiBsKGQsIHApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBlLkludmFsaWRBcmd1bWVudChcIkVycm9yIG9uIFwiLmNvbmNhdChpKGQpLCBcIi5cIikuY29uY2F0KHAsIFwiKCk6IHBhcmFtZXRyaWMgaXRlcmF0b3IsIGl0IGFscmVhZHkgaGFzIGJlZW4gZXJhc2VkLlwiKSk7XG4gICAgICB9XG4gICAgICBuLmVyYXNlZF9pdGVyYXRvciA9IGw7XG4gICAgICBmdW5jdGlvbiBmKGQsIHAsIHkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyByLk91dE9mUmFuZ2UoXCJFcnJvciBvbiBcIi5jb25jYXQoaShkKSwgXCIuXCIpLmNvbmNhdChwLCBcIigpOiBwYXJhbWV0cmljIGl0ZXJhdG9yIGlzIGRpcmVjdGluZyBuZWdhdGl2ZSBwb3NpdGlvbiAtPiAoaW5kZXggPSBcIikuY29uY2F0KHksIFwiKS5cIikpO1xuICAgICAgfVxuICAgICAgbi5uZWdhdGl2ZV9pdGVyYXRvciA9IGY7XG4gICAgICBmdW5jdGlvbiB1KGQsIHApIHtcbiAgICAgICAgcCA9PT0gdm9pZCAwICYmIChwID0gXCJlbmRcIik7XG4gICAgICAgIHZhciB5ID0gaShkKTtcbiAgICAgICAgcmV0dXJuIG5ldyByLk91dE9mUmFuZ2UoXCJFcnJvciBvbiBcIi5jb25jYXQoeSwgXCIuSXRlcmF0b3IudmFsdWU6IGNhbm5vdCBhY2Nlc3MgdG8gdGhlIFwiKS5jb25jYXQoeSwgXCIuXCIpLmNvbmNhdChwLCBcIigpLnZhbHVlLlwiKSk7XG4gICAgICB9XG4gICAgICBuLml0ZXJhdG9yX2VuZF92YWx1ZSA9IHU7XG4gICAgICBmdW5jdGlvbiBoKGQsIHAsIHkpIHtcbiAgICAgICAgdGhyb3cgbmV3IHIuT3V0T2ZSYW5nZShcIkVycm9yIG9uIFwiLmNvbmNhdChpKGQpLCBcIi5cIikuY29uY2F0KHAsIFwiKCk6IHVuYWJsZSB0byBmaW5kIHRoZSBtYXRjaGVkIGtleSAtPiBcIikuY29uY2F0KHkpKTtcbiAgICAgIH1cbiAgICAgIG4ua2V5X25vdXRfZm91bmQgPSBoO1xuICAgIH0pKHQuRXJyb3JHZW5lcmF0b3IgfHwgKHQuRXJyb3JHZW5lcmF0b3IgPSB7fSkpO1xuICB9KHduKSksIHduO1xufVxudmFyIGxvO1xuZnVuY3Rpb24gR2goKSB7XG4gIGlmIChsbylcbiAgICByZXR1cm4gUnQ7XG4gIGxvID0gMTtcbiAgdmFyIHQgPSBTICYmIFMuX19leHRlbmRzIHx8IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvID0gZnVuY3Rpb24oYSwgYykge1xuICAgICAgcmV0dXJuIG8gPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbihsLCBmKSB7XG4gICAgICAgIGwuX19wcm90b19fID0gZjtcbiAgICAgIH0gfHwgZnVuY3Rpb24obCwgZikge1xuICAgICAgICBmb3IgKHZhciB1IGluIGYpXG4gICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGYsIHUpICYmIChsW3VdID0gZlt1XSk7XG4gICAgICB9LCBvKGEsIGMpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGEsIGMpIHtcbiAgICAgIGlmICh0eXBlb2YgYyAhPSBcImZ1bmN0aW9uXCIgJiYgYyAhPT0gbnVsbClcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYykgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgbyhhLCBjKTtcbiAgICAgIGZ1bmN0aW9uIGwoKSB7XG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IgPSBhO1xuICAgICAgfVxuICAgICAgYS5wcm90b3R5cGUgPSBjID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShjKSA6IChsLnByb3RvdHlwZSA9IGMucHJvdG90eXBlLCBuZXcgbCgpKTtcbiAgICB9O1xuICB9KCksIGUgPSBTICYmIFMuX19yZWFkIHx8IGZ1bmN0aW9uKG8sIGEpIHtcbiAgICB2YXIgYyA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIWMpXG4gICAgICByZXR1cm4gbztcbiAgICB2YXIgbCA9IGMuY2FsbChvKSwgZiwgdSA9IFtdLCBoO1xuICAgIHRyeSB7XG4gICAgICBmb3IgKDsgKGEgPT09IHZvaWQgMCB8fCBhLS0gPiAwKSAmJiAhKGYgPSBsLm5leHQoKSkuZG9uZTsgKVxuICAgICAgICB1LnB1c2goZi52YWx1ZSk7XG4gICAgfSBjYXRjaCAoZCkge1xuICAgICAgaCA9IHsgZXJyb3I6IGQgfTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZiAmJiAhZi5kb25lICYmIChjID0gbC5yZXR1cm4pICYmIGMuY2FsbChsKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChoKVxuICAgICAgICAgIHRocm93IGguZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1O1xuICB9LCByID0gUyAmJiBTLl9fc3ByZWFkQXJyYXkgfHwgZnVuY3Rpb24obywgYSwgYykge1xuICAgIGlmIChjIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpXG4gICAgICBmb3IgKHZhciBsID0gMCwgZiA9IGEubGVuZ3RoLCB1OyBsIDwgZjsgbCsrKVxuICAgICAgICAodSB8fCAhKGwgaW4gYSkpICYmICh1IHx8ICh1ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYSwgMCwgbCkpLCB1W2xdID0gYVtsXSk7XG4gICAgcmV0dXJuIG8uY29uY2F0KHUgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYSkpO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUnQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgUnQuVW5pcXVlU2V0ID0gdm9pZCAwO1xuICB2YXIgbiA9IEtoKCksIGkgPSBXcigpLCBzID0gZnVuY3Rpb24obykge1xuICAgIHQoYSwgbyk7XG4gICAgZnVuY3Rpb24gYSgpIHtcbiAgICAgIHJldHVybiBvICE9PSBudWxsICYmIG8uYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gYS5wcm90b3R5cGUuY291bnQgPSBmdW5jdGlvbihjKSB7XG4gICAgICByZXR1cm4gdGhpcy5maW5kKGMpLmVxdWFscyh0aGlzLmVuZCgpKSA/IDAgOiAxO1xuICAgIH0sIGEucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgZm9yICh2YXIgYyA9IFtdLCBsID0gMDsgbCA8IGFyZ3VtZW50cy5sZW5ndGg7IGwrKylcbiAgICAgICAgY1tsXSA9IGFyZ3VtZW50c1tsXTtcbiAgICAgIHJldHVybiBvLnByb3RvdHlwZS5pbnNlcnQuYXBwbHkodGhpcywgcihbXSwgZShjKSwgITEpKTtcbiAgICB9LCBhLnByb3RvdHlwZS5fSW5zZXJ0X2J5X3JhbmdlID0gZnVuY3Rpb24oYywgbCkge1xuICAgICAgZm9yICg7ICFjLmVxdWFscyhsKTsgYyA9IGMubmV4dCgpKVxuICAgICAgICB0aGlzLl9JbnNlcnRfYnlfa2V5KGMudmFsdWUpO1xuICAgIH0sIGEucHJvdG90eXBlLmV4dHJhY3QgPSBmdW5jdGlvbihjKSB7XG4gICAgICByZXR1cm4gYyBpbnN0YW5jZW9mIHRoaXMuZW5kKCkuY29uc3RydWN0b3IgPyB0aGlzLl9FeHRyYWN0X2J5X2l0ZXJhdG9yKGMpIDogdGhpcy5fRXh0cmFjdF9ieV92YWwoYyk7XG4gICAgfSwgYS5wcm90b3R5cGUuX0V4dHJhY3RfYnlfdmFsID0gZnVuY3Rpb24oYykge1xuICAgICAgdmFyIGwgPSB0aGlzLmZpbmQoYyk7XG4gICAgICBpZiAobC5lcXVhbHModGhpcy5lbmQoKSkgPT09ICEwKVxuICAgICAgICB0aHJvdyBpLkVycm9yR2VuZXJhdG9yLmtleV9ub3V0X2ZvdW5kKHRoaXMsIFwiZXh0cmFjdFwiLCBjKTtcbiAgICAgIHJldHVybiB0aGlzLl9FcmFzZV9ieV9yYW5nZShsKSwgYztcbiAgICB9LCBhLnByb3RvdHlwZS5fRXh0cmFjdF9ieV9pdGVyYXRvciA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgIHJldHVybiBjLmVxdWFscyh0aGlzLmVuZCgpKSA9PT0gITAgfHwgdGhpcy5oYXMoYy52YWx1ZSkgPT09ICExID8gdGhpcy5lbmQoKSA6ICh0aGlzLl9FcmFzZV9ieV9yYW5nZShjKSwgYyk7XG4gICAgfSwgYS5wcm90b3R5cGUuX0VyYXNlX2J5X3ZhbCA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgIHZhciBsID0gdGhpcy5maW5kKGMpO1xuICAgICAgcmV0dXJuIGwuZXF1YWxzKHRoaXMuZW5kKCkpID09PSAhMCA/IDAgOiAodGhpcy5fRXJhc2VfYnlfcmFuZ2UobCksIDEpO1xuICAgIH0sIGEucHJvdG90eXBlLm1lcmdlID0gZnVuY3Rpb24oYykge1xuICAgICAgZm9yICh2YXIgbCA9IGMuYmVnaW4oKTsgIWwuZXF1YWxzKGMuZW5kKCkpOyApXG4gICAgICAgIHRoaXMuaGFzKGwudmFsdWUpID09PSAhMSA/ICh0aGlzLmluc2VydChsLnZhbHVlKSwgbCA9IGMuZXJhc2UobCkpIDogbCA9IGwubmV4dCgpO1xuICAgIH0sIGE7XG4gIH0obi5TZXRDb250YWluZXIpO1xuICByZXR1cm4gUnQuVW5pcXVlU2V0ID0gcywgUnQ7XG59XG52YXIgX24gPSB7fSwgbW4gPSB7fSwgZm87XG5mdW5jdGlvbiBaaCgpIHtcbiAgcmV0dXJuIGZvIHx8IChmbyA9IDEsIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSA9IFMgJiYgUy5fX3JlYWQgfHwgZnVuY3Rpb24obiwgaSkge1xuICAgICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBuW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgICBpZiAoIXMpXG4gICAgICAgIHJldHVybiBuO1xuICAgICAgdmFyIG8gPSBzLmNhbGwobiksIGEsIGMgPSBbXSwgbDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoOyAoaSA9PT0gdm9pZCAwIHx8IGktLSA+IDApICYmICEoYSA9IG8ubmV4dCgpKS5kb25lOyApXG4gICAgICAgICAgYy5wdXNoKGEudmFsdWUpO1xuICAgICAgfSBjYXRjaCAoZikge1xuICAgICAgICBsID0geyBlcnJvcjogZiB9O1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhICYmICFhLmRvbmUgJiYgKHMgPSBvLnJldHVybikgJiYgcy5jYWxsKG8pO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChsKVxuICAgICAgICAgICAgdGhyb3cgbC5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGM7XG4gICAgfSwgciA9IFMgJiYgUy5fX3NwcmVhZEFycmF5IHx8IGZ1bmN0aW9uKG4sIGksIHMpIHtcbiAgICAgIGlmIChzIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpXG4gICAgICAgIGZvciAodmFyIG8gPSAwLCBhID0gaS5sZW5ndGgsIGM7IG8gPCBhOyBvKyspXG4gICAgICAgICAgKGMgfHwgIShvIGluIGkpKSAmJiAoYyB8fCAoYyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGksIDAsIG8pKSwgY1tvXSA9IGlbb10pO1xuICAgICAgcmV0dXJuIG4uY29uY2F0KGMgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoaSkpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgdC5JQXNzb2NpYXRpdmVDb250YWluZXIgPSB2b2lkIDAsIGZ1bmN0aW9uKG4pIHtcbiAgICAgIGZ1bmN0aW9uIGkocykge1xuICAgICAgICBmb3IgKHZhciBvID0gW10sIGEgPSAxOyBhIDwgYXJndW1lbnRzLmxlbmd0aDsgYSsrKVxuICAgICAgICAgIG9bYSAtIDFdID0gYXJndW1lbnRzW2FdO1xuICAgICAgICB2YXIgYywgbDtcbiAgICAgICAgcmV0dXJuIG8ubGVuZ3RoID49IDEgJiYgb1swXSBpbnN0YW5jZW9mIEFycmF5ID8gKGMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgZiA9IG9bMF07XG4gICAgICAgICAgcy5wdXNoLmFwcGx5KHMsIHIoW10sIGUoZiksICExKSk7XG4gICAgICAgIH0sIGwgPSBvLnNsaWNlKDEpKSA6IG8ubGVuZ3RoID49IDIgJiYgb1swXS5uZXh0IGluc3RhbmNlb2YgRnVuY3Rpb24gJiYgb1sxXS5uZXh0IGluc3RhbmNlb2YgRnVuY3Rpb24gPyAoYyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBmID0gb1swXSwgdSA9IG9bMV07XG4gICAgICAgICAgcy5hc3NpZ24oZiwgdSk7XG4gICAgICAgIH0sIGwgPSBvLnNsaWNlKDIpKSA6IChjID0gbnVsbCwgbCA9IG8pLCB7IHJhbWRhOiBjLCB0YWlsOiBsIH07XG4gICAgICB9XG4gICAgICBuLmNvbnN0cnVjdCA9IGk7XG4gICAgfSh0LklBc3NvY2lhdGl2ZUNvbnRhaW5lciB8fCAodC5JQXNzb2NpYXRpdmVDb250YWluZXIgPSB7fSkpO1xuICB9KG1uKSksIG1uO1xufVxudmFyIGp0ID0ge30sIEh0ID0ge30sIE10ID0ge30sIGhvO1xuZnVuY3Rpb24gWWgoKSB7XG4gIGlmIChobylcbiAgICByZXR1cm4gTXQ7XG4gIGhvID0gMSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KE10LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIE10Ll9HZXRfcm9vdCA9IHZvaWQgMDtcbiAgdmFyIHQgPSBjcjtcbiAgZnVuY3Rpb24gZSgpIHtcbiAgICByZXR1cm4gciA9PT0gbnVsbCAmJiAociA9ICgwLCB0LmlzX25vZGUpKCkgPyBTIDogc2VsZiwgci5fX3NfaVVJRCA9PT0gdm9pZCAwICYmIChyLl9fc19pVUlEID0gMCkpLCByO1xuICB9XG4gIE10Ll9HZXRfcm9vdCA9IGU7XG4gIHZhciByID0gbnVsbDtcbiAgcmV0dXJuIE10O1xufVxudmFyIHBvO1xuZnVuY3Rpb24gT2EoKSB7XG4gIGlmIChwbylcbiAgICByZXR1cm4gSHQ7XG4gIHBvID0gMSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KEh0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIEh0LmdldF91aWQgPSB2b2lkIDA7XG4gIHZhciB0ID0gWWgoKTtcbiAgZnVuY3Rpb24gZShyKSB7XG4gICAgaWYgKHIgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgIGlmIChyLmhhc093blByb3BlcnR5KFwiX19nZXRfbV9pVUlEXCIpID09PSAhMSkge1xuICAgICAgICB2YXIgbiA9ICsrKDAsIHQuX0dldF9yb290KSgpLl9fc19pVUlEO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkociwgXCJfX2dldF9tX2lVSURcIiwge1xuICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gci5fX2dldF9tX2lVSUQoKTtcbiAgICB9IGVsc2VcbiAgICAgIHJldHVybiByID09PSB2b2lkIDAgPyAtMSA6IDA7XG4gIH1cbiAgcmV0dXJuIEh0LmdldF91aWQgPSBlLCBIdDtcbn1cbnZhciB5bztcbmZ1bmN0aW9uIHdpKCkge1xuICBpZiAoeW8pXG4gICAgcmV0dXJuIGp0O1xuICB5byA9IDE7XG4gIHZhciB0ID0gUyAmJiBTLl9fdmFsdWVzIHx8IGZ1bmN0aW9uKGMpIHtcbiAgICB2YXIgbCA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgZiA9IGwgJiYgY1tsXSwgdSA9IDA7XG4gICAgaWYgKGYpXG4gICAgICByZXR1cm4gZi5jYWxsKGMpO1xuICAgIGlmIChjICYmIHR5cGVvZiBjLmxlbmd0aCA9PSBcIm51bWJlclwiKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGMgJiYgdSA+PSBjLmxlbmd0aCAmJiAoYyA9IHZvaWQgMCksIHsgdmFsdWU6IGMgJiYgY1t1KytdLCBkb25lOiAhYyB9O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IobCA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGp0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIGp0Lmhhc2ggPSB2b2lkIDA7XG4gIHZhciBlID0gT2EoKTtcbiAgZnVuY3Rpb24gcigpIHtcbiAgICBmb3IgKHZhciBjLCBsLCBmID0gW10sIHUgPSAwOyB1IDwgYXJndW1lbnRzLmxlbmd0aDsgdSsrKVxuICAgICAgZlt1XSA9IGFyZ3VtZW50c1t1XTtcbiAgICB2YXIgaCA9IG87XG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIGQgPSB0KGYpLCBwID0gZC5uZXh0KCk7ICFwLmRvbmU7IHAgPSBkLm5leHQoKSkge1xuICAgICAgICB2YXIgeSA9IHAudmFsdWU7XG4gICAgICAgIHkgPSB5ICYmIHkudmFsdWVPZigpO1xuICAgICAgICB2YXIgZyA9IHR5cGVvZiB5O1xuICAgICAgICBpZiAoZyA9PT0gXCJib29sZWFuXCIpXG4gICAgICAgICAgaCA9IG4oeSwgaCk7XG4gICAgICAgIGVsc2UgaWYgKGcgPT09IFwibnVtYmVyXCIgfHwgZyA9PT0gXCJiaWdpbnRcIilcbiAgICAgICAgICBoID0gaSh5LCBoKTtcbiAgICAgICAgZWxzZSBpZiAoZyA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICBoID0gcyh5LCBoKTtcbiAgICAgICAgZWxzZSBpZiAoeSBpbnN0YW5jZW9mIE9iamVjdCAmJiB5Lmhhc2hDb2RlIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgICB2YXIgdiA9IHkuaGFzaENvZGUoKTtcbiAgICAgICAgICBpZiAoZi5sZW5ndGggPT09IDEpXG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICBoID0gaCBeIHYsIGggKj0gYTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgaCA9IGkoKDAsIGUuZ2V0X3VpZCkoeSksIGgpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgIGMgPSB7IGVycm9yOiBfIH07XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHAgJiYgIXAuZG9uZSAmJiAobCA9IGQucmV0dXJuKSAmJiBsLmNhbGwoZCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoYylcbiAgICAgICAgICB0aHJvdyBjLmVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gTWF0aC5hYnMoaCk7XG4gIH1cbiAganQuaGFzaCA9IHI7XG4gIGZ1bmN0aW9uIG4oYywgbCkge1xuICAgIHJldHVybiBsIF49IGMgPyAxIDogMCwgbCAqPSBhLCBsO1xuICB9XG4gIGZ1bmN0aW9uIGkoYywgbCkge1xuICAgIHJldHVybiBzKGMudG9TdHJpbmcoKSwgbCk7XG4gIH1cbiAgZnVuY3Rpb24gcyhjLCBsKSB7XG4gICAgZm9yICh2YXIgZiA9IDA7IGYgPCBjLmxlbmd0aDsgKytmKVxuICAgICAgbCBePSBjLmNoYXJDb2RlQXQoZiksIGwgKj0gYTtcbiAgICByZXR1cm4gTWF0aC5hYnMobCk7XG4gIH1cbiAgdmFyIG8gPSAyMTY2MTM2MjYxLCBhID0gMTY3Nzc2MTk7XG4gIHJldHVybiBqdDtcbn1cbnZhciBhZSA9IHt9LCBnbztcbmZ1bmN0aW9uIF9pKCkge1xuICBpZiAoZ28pXG4gICAgcmV0dXJuIGFlO1xuICBnbyA9IDEsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhZSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBhZS5ncmVhdGVyX2VxdWFsID0gYWUuZ3JlYXRlciA9IGFlLmxlc3NfZXF1YWwgPSBhZS5sZXNzID0gYWUubm90X2VxdWFsX3RvID0gYWUuZXF1YWxfdG8gPSB2b2lkIDA7XG4gIHZhciB0ID0gT2EoKTtcbiAgZnVuY3Rpb24gZShhLCBjKSB7XG4gICAgcmV0dXJuIGEgPSBhICYmIGEudmFsdWVPZigpLCBjID0gYyAmJiBjLnZhbHVlT2YoKSwgYSBpbnN0YW5jZW9mIE9iamVjdCAmJiBhLmVxdWFscyBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gYS5lcXVhbHMoYykgOiBhID09PSBjO1xuICB9XG4gIGFlLmVxdWFsX3RvID0gZTtcbiAgZnVuY3Rpb24gcihhLCBjKSB7XG4gICAgcmV0dXJuICFlKGEsIGMpO1xuICB9XG4gIGFlLm5vdF9lcXVhbF90byA9IHI7XG4gIGZ1bmN0aW9uIG4oYSwgYykge1xuICAgIHJldHVybiBhID0gYS52YWx1ZU9mKCksIGMgPSBjLnZhbHVlT2YoKSwgYSBpbnN0YW5jZW9mIE9iamVjdCA/IGEubGVzcyBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gYS5sZXNzKGMpIDogKDAsIHQuZ2V0X3VpZCkoYSkgPCAoMCwgdC5nZXRfdWlkKShjKSA6IGEgPCBjO1xuICB9XG4gIGFlLmxlc3MgPSBuO1xuICBmdW5jdGlvbiBpKGEsIGMpIHtcbiAgICByZXR1cm4gbihhLCBjKSB8fCBlKGEsIGMpO1xuICB9XG4gIGFlLmxlc3NfZXF1YWwgPSBpO1xuICBmdW5jdGlvbiBzKGEsIGMpIHtcbiAgICByZXR1cm4gIWkoYSwgYyk7XG4gIH1cbiAgYWUuZ3JlYXRlciA9IHM7XG4gIGZ1bmN0aW9uIG8oYSwgYykge1xuICAgIHJldHVybiAhbihhLCBjKTtcbiAgfVxuICByZXR1cm4gYWUuZ3JlYXRlcl9lcXVhbCA9IG8sIGFlO1xufVxudmFyIGJvO1xuZnVuY3Rpb24gQWEoKSB7XG4gIHJldHVybiBibyB8fCAoYm8gPSAxLCBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGUgPSBTICYmIFMuX19yZWFkIHx8IGZ1bmN0aW9uKG8sIGEpIHtcbiAgICAgIHZhciBjID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgICAgaWYgKCFjKVxuICAgICAgICByZXR1cm4gbztcbiAgICAgIHZhciBsID0gYy5jYWxsKG8pLCBmLCB1ID0gW10sIGg7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKDsgKGEgPT09IHZvaWQgMCB8fCBhLS0gPiAwKSAmJiAhKGYgPSBsLm5leHQoKSkuZG9uZTsgKVxuICAgICAgICAgIHUucHVzaChmLnZhbHVlKTtcbiAgICAgIH0gY2F0Y2ggKGQpIHtcbiAgICAgICAgaCA9IHsgZXJyb3I6IGQgfTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZiAmJiAhZi5kb25lICYmIChjID0gbC5yZXR1cm4pICYmIGMuY2FsbChsKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoaClcbiAgICAgICAgICAgIHRocm93IGguZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB1O1xuICAgIH0sIHIgPSBTICYmIFMuX19zcHJlYWRBcnJheSB8fCBmdW5jdGlvbihvLCBhLCBjKSB7XG4gICAgICBpZiAoYyB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKVxuICAgICAgICBmb3IgKHZhciBsID0gMCwgZiA9IGEubGVuZ3RoLCB1OyBsIDwgZjsgbCsrKVxuICAgICAgICAgICh1IHx8ICEobCBpbiBhKSkgJiYgKHUgfHwgKHUgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhLCAwLCBsKSksIHVbbF0gPSBhW2xdKTtcbiAgICAgIHJldHVybiBvLmNvbmNhdCh1IHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGEpKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIHQuSUhhc2hDb250YWluZXIgPSB2b2lkIDA7XG4gICAgdmFyIG4gPSBaaCgpLCBpID0gd2koKSwgcyA9IF9pKCk7XG4gICAgKGZ1bmN0aW9uKG8pIHtcbiAgICAgIGZ1bmN0aW9uIGEoYywgbCwgZikge1xuICAgICAgICBmb3IgKHZhciB1ID0gW10sIGggPSAzOyBoIDwgYXJndW1lbnRzLmxlbmd0aDsgaCsrKVxuICAgICAgICAgIHVbaCAtIDNdID0gYXJndW1lbnRzW2hdO1xuICAgICAgICB2YXIgZCA9IG51bGwsIHAgPSBpLmhhc2gsIHkgPSBzLmVxdWFsX3RvO1xuICAgICAgICBpZiAodS5sZW5ndGggPT09IDEgJiYgdVswXSBpbnN0YW5jZW9mIGwpIHtcbiAgICAgICAgICB2YXIgZyA9IHVbMF07XG4gICAgICAgICAgcCA9IGcuaGFzaF9mdW5jdGlvbigpLCB5ID0gZy5rZXlfZXEoKSwgZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIF8gPSBnLmJlZ2luKCksIG0gPSBnLmVuZCgpO1xuICAgICAgICAgICAgYy5hc3NpZ24oXywgbSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdiA9IG4uSUFzc29jaWF0aXZlQ29udGFpbmVyLmNvbnN0cnVjdC5hcHBseShuLklBc3NvY2lhdGl2ZUNvbnRhaW5lciwgcihbY10sIGUodSksICExKSk7XG4gICAgICAgICAgZCA9IHYucmFtZGEsIHYudGFpbC5sZW5ndGggPj0gMSAmJiAocCA9IHYudGFpbFswXSksIHYudGFpbC5sZW5ndGggPj0gMiAmJiAoeSA9IHYudGFpbFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgZihwLCB5KSwgZCAhPT0gbnVsbCAmJiBkKCk7XG4gICAgICB9XG4gICAgICBvLmNvbnN0cnVjdCA9IGE7XG4gICAgfSkodC5JSGFzaENvbnRhaW5lciB8fCAodC5JSGFzaENvbnRhaW5lciA9IHt9KSk7XG4gIH0oX24pKSwgX247XG59XG52YXIgeG4gPSB7fSwgRHQgPSB7fSwgenQgPSB7fSwgdm87XG5mdW5jdGlvbiBtaSgpIHtcbiAgaWYgKHZvKVxuICAgIHJldHVybiB6dDtcbiAgdm8gPSAxLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoenQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgenQuTGlzdEl0ZXJhdG9yID0gdm9pZCAwO1xuICB2YXIgdCA9IFdyKCksIGUgPSBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiByKG4sIGksIHMpIHtcbiAgICAgIHRoaXMucHJldl8gPSBuLCB0aGlzLm5leHRfID0gaSwgdGhpcy52YWx1ZV8gPSBzO1xuICAgIH1cbiAgICByZXR1cm4gci5fU2V0X3ByZXYgPSBmdW5jdGlvbihuLCBpKSB7XG4gICAgICBuLnByZXZfID0gaTtcbiAgICB9LCByLl9TZXRfbmV4dCA9IGZ1bmN0aW9uKG4sIGkpIHtcbiAgICAgIG4ubmV4dF8gPSBpO1xuICAgIH0sIHIucHJvdG90eXBlLnByZXYgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnByZXZfO1xuICAgIH0sIHIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm5leHRfO1xuICAgIH0sIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fVHJ5X3ZhbHVlKCksIHRoaXMudmFsdWVfO1xuICAgICAgfSxcbiAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgIH0pLCByLnByb3RvdHlwZS5fVHJ5X3ZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy52YWx1ZV8gPT09IHZvaWQgMCAmJiB0aGlzLmVxdWFscyh0aGlzLnNvdXJjZSgpLmVuZCgpKSA9PT0gITApXG4gICAgICAgIHRocm93IHQuRXJyb3JHZW5lcmF0b3IuaXRlcmF0b3JfZW5kX3ZhbHVlKHRoaXMuc291cmNlKCkpO1xuICAgIH0sIHIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgIHJldHVybiB0aGlzID09PSBuO1xuICAgIH0sIHI7XG4gIH0oKTtcbiAgcmV0dXJuIHp0Lkxpc3RJdGVyYXRvciA9IGUsIHp0O1xufVxudmFyIEZ0ID0ge30sIHdvO1xuZnVuY3Rpb24gSmgoKSB7XG4gIGlmICh3bylcbiAgICByZXR1cm4gRnQ7XG4gIHdvID0gMSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZ0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIEZ0LlJlcGVhdGVyID0gdm9pZCAwO1xuICB2YXIgdCA9IGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIGUociwgbikge1xuICAgICAgdGhpcy5pbmRleF8gPSByLCB0aGlzLnZhbHVlXyA9IG47XG4gICAgfVxuICAgIHJldHVybiBlLnByb3RvdHlwZS5pbmRleCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW5kZXhfO1xuICAgIH0sIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZV87XG4gICAgICB9LFxuICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgfSksIGUucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiArK3RoaXMuaW5kZXhfLCB0aGlzO1xuICAgIH0sIGUucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKHIpIHtcbiAgICAgIHJldHVybiB0aGlzLmluZGV4XyA9PT0gci5pbmRleF87XG4gICAgfSwgZTtcbiAgfSgpO1xuICByZXR1cm4gRnQuUmVwZWF0ZXIgPSB0LCBGdDtcbn1cbnZhciBjZSA9IHt9LCBfbztcbmZ1bmN0aW9uIFhoKCkge1xuICBpZiAoX28pXG4gICAgcmV0dXJuIGNlO1xuICBfbyA9IDEsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjZSwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBjZS5uZXh0ID0gY2UucHJldiA9IGNlLmFkdmFuY2UgPSBjZS5kaXN0YW5jZSA9IGNlLnNpemUgPSBjZS5lbXB0eSA9IHZvaWQgMDtcbiAgdmFyIHQgPSBTYSgpO1xuICBmdW5jdGlvbiBlKGMpIHtcbiAgICByZXR1cm4gYyBpbnN0YW5jZW9mIEFycmF5ID8gYy5sZW5ndGggIT09IDAgOiBjLmVtcHR5KCk7XG4gIH1cbiAgY2UuZW1wdHkgPSBlO1xuICBmdW5jdGlvbiByKGMpIHtcbiAgICByZXR1cm4gYyBpbnN0YW5jZW9mIEFycmF5ID8gYy5sZW5ndGggOiBjLnNpemUoKTtcbiAgfVxuICBjZS5zaXplID0gcjtcbiAgZnVuY3Rpb24gbihjLCBsKSB7XG4gICAgaWYgKGMuaW5kZXggaW5zdGFuY2VvZiBGdW5jdGlvbilcbiAgICAgIHJldHVybiBpKGMsIGwpO1xuICAgIGZvciAodmFyIGYgPSAwOyAhYy5lcXVhbHMobCk7IGMgPSBjLm5leHQoKSlcbiAgICAgICsrZjtcbiAgICByZXR1cm4gZjtcbiAgfVxuICBjZS5kaXN0YW5jZSA9IG47XG4gIGZ1bmN0aW9uIGkoYywgbCkge1xuICAgIHZhciBmID0gYy5pbmRleCgpLCB1ID0gbC5pbmRleCgpO1xuICAgIHJldHVybiBjLmJhc2UgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IGYgLSB1IDogdSAtIGY7XG4gIH1cbiAgZnVuY3Rpb24gcyhjLCBsKSB7XG4gICAgaWYgKGwgPT09IDApXG4gICAgICByZXR1cm4gYztcbiAgICBpZiAoYy5hZHZhbmNlIGluc3RhbmNlb2YgRnVuY3Rpb24pXG4gICAgICByZXR1cm4gYy5hZHZhbmNlKGwpO1xuICAgIHZhciBmO1xuICAgIGlmIChsIDwgMCkge1xuICAgICAgaWYgKCEoYy5wcmV2IGluc3RhbmNlb2YgRnVuY3Rpb24pKVxuICAgICAgICB0aHJvdyBuZXcgdC5JbnZhbGlkQXJndW1lbnQoXCJFcnJvciBvbiBzdGQuYWR2YW5jZSgpOiBwYXJhbWV0cmljIGl0ZXJhdG9yIGlzIG5vdCBhIGJpLWRpcmVjdGlvbmFsIGl0ZXJhdG9yLCB0aHVzIGFkdmFuY2luZyB0byBuZWdhdGl2ZSBkaXJlY3Rpb24gaXMgbm90IHBvc3NpYmxlLlwiKTtcbiAgICAgIGYgPSBmdW5jdGlvbih1KSB7XG4gICAgICAgIHJldHVybiB1LnByZXYoKTtcbiAgICAgIH0sIGwgPSAtbDtcbiAgICB9IGVsc2VcbiAgICAgIGYgPSBmdW5jdGlvbih1KSB7XG4gICAgICAgIHJldHVybiB1Lm5leHQoKTtcbiAgICAgIH07XG4gICAgZm9yICg7IGwtLSA+IDA7IClcbiAgICAgIGMgPSBmKGMpO1xuICAgIHJldHVybiBjO1xuICB9XG4gIGNlLmFkdmFuY2UgPSBzO1xuICBmdW5jdGlvbiBvKGMsIGwpIHtcbiAgICByZXR1cm4gbCA9PT0gdm9pZCAwICYmIChsID0gMSksIGwgPT09IDEgPyBjLnByZXYoKSA6IHMoYywgLWwpO1xuICB9XG4gIGNlLnByZXYgPSBvO1xuICBmdW5jdGlvbiBhKGMsIGwpIHtcbiAgICByZXR1cm4gbCA9PT0gdm9pZCAwICYmIChsID0gMSksIGwgPT09IDEgPyBjLm5leHQoKSA6IHMoYywgbCk7XG4gIH1cbiAgcmV0dXJuIGNlLm5leHQgPSBhLCBjZTtcbn1cbnZhciBtbztcbmZ1bmN0aW9uIENhKCkge1xuICBpZiAobW8pXG4gICAgcmV0dXJuIER0O1xuICBtbyA9IDE7XG4gIHZhciB0ID0gUyAmJiBTLl9fZXh0ZW5kcyB8fCBmdW5jdGlvbigpIHtcbiAgICB2YXIgbCA9IGZ1bmN0aW9uKGYsIHUpIHtcbiAgICAgIHJldHVybiBsID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24oaCwgZCkge1xuICAgICAgICBoLl9fcHJvdG9fXyA9IGQ7XG4gICAgICB9IHx8IGZ1bmN0aW9uKGgsIGQpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBkKVxuICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkLCBwKSAmJiAoaFtwXSA9IGRbcF0pO1xuICAgICAgfSwgbChmLCB1KTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbihmLCB1KSB7XG4gICAgICBpZiAodHlwZW9mIHUgIT0gXCJmdW5jdGlvblwiICYmIHUgIT09IG51bGwpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKHUpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgIGwoZiwgdSk7XG4gICAgICBmdW5jdGlvbiBoKCkge1xuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yID0gZjtcbiAgICAgIH1cbiAgICAgIGYucHJvdG90eXBlID0gdSA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUodSkgOiAoaC5wcm90b3R5cGUgPSB1LnByb3RvdHlwZSwgbmV3IGgoKSk7XG4gICAgfTtcbiAgfSgpLCBlID0gUyAmJiBTLl9fcmVhZCB8fCBmdW5jdGlvbihsLCBmKSB7XG4gICAgdmFyIHUgPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBsW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCF1KVxuICAgICAgcmV0dXJuIGw7XG4gICAgdmFyIGggPSB1LmNhbGwobCksIGQsIHAgPSBbXSwgeTtcbiAgICB0cnkge1xuICAgICAgZm9yICg7IChmID09PSB2b2lkIDAgfHwgZi0tID4gMCkgJiYgIShkID0gaC5uZXh0KCkpLmRvbmU7IClcbiAgICAgICAgcC5wdXNoKGQudmFsdWUpO1xuICAgIH0gY2F0Y2ggKGcpIHtcbiAgICAgIHkgPSB7IGVycm9yOiBnIH07XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGQgJiYgIWQuZG9uZSAmJiAodSA9IGgucmV0dXJuKSAmJiB1LmNhbGwoaCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoeSlcbiAgICAgICAgICB0aHJvdyB5LmVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcDtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KER0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIER0Lkxpc3RDb250YWluZXIgPSB2b2lkIDA7XG4gIHZhciByID0gYmkoKSwgbiA9IG1pKCksIGkgPSBKaCgpLCBzID0gdmkoKSwgbyA9IFhoKCksIGEgPSBXcigpLCBjID0gZnVuY3Rpb24obCkge1xuICAgIHQoZiwgbCk7XG4gICAgZnVuY3Rpb24gZigpIHtcbiAgICAgIHZhciB1ID0gbC5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICByZXR1cm4gdS5lbmRfID0gdS5fQ3JlYXRlX2l0ZXJhdG9yKG51bGwsIG51bGwpLCB1LmNsZWFyKCksIHU7XG4gICAgfVxuICAgIHJldHVybiBmLnByb3RvdHlwZS5hc3NpZ24gPSBmdW5jdGlvbih1LCBoKSB7XG4gICAgICB0aGlzLmNsZWFyKCksIHRoaXMuaW5zZXJ0KHRoaXMuZW5kKCksIHUsIGgpO1xuICAgIH0sIGYucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgICBuLkxpc3RJdGVyYXRvci5fU2V0X3ByZXYodGhpcy5lbmRfLCB0aGlzLmVuZF8pLCBuLkxpc3RJdGVyYXRvci5fU2V0X25leHQodGhpcy5lbmRfLCB0aGlzLmVuZF8pLCB0aGlzLmJlZ2luXyA9IHRoaXMuZW5kXywgdGhpcy5zaXplXyA9IDA7XG4gICAgfSwgZi5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24odSkge1xuICAgICAgdmFyIGggPSB1IC0gdGhpcy5zaXplKCk7XG4gICAgICBoID4gMCA/IHRoaXMuaW5zZXJ0KHRoaXMuZW5kKCksIGgsIHZvaWQgMCkgOiBoIDwgMCAmJiB0aGlzLmVyYXNlKCgwLCBvLmFkdmFuY2UpKHRoaXMuZW5kKCksIC1oKSwgdGhpcy5lbmQoKSk7XG4gICAgfSwgZi5wcm90b3R5cGUuYmVnaW4gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmJlZ2luXztcbiAgICB9LCBmLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuZF87XG4gICAgfSwgZi5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2l6ZV87XG4gICAgfSwgZi5wcm90b3R5cGUucHVzaF9mcm9udCA9IGZ1bmN0aW9uKHUpIHtcbiAgICAgIHRoaXMuaW5zZXJ0KHRoaXMuYmVnaW5fLCB1KTtcbiAgICB9LCBmLnByb3RvdHlwZS5wdXNoX2JhY2sgPSBmdW5jdGlvbih1KSB7XG4gICAgICB0aGlzLmluc2VydCh0aGlzLmVuZF8sIHUpO1xuICAgIH0sIGYucHJvdG90eXBlLnBvcF9mcm9udCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuZW1wdHkoKSA9PT0gITApXG4gICAgICAgIHRocm93IGEuRXJyb3JHZW5lcmF0b3IuZW1wdHkodGhpcy5lbmRfLnNvdXJjZSgpLmNvbnN0cnVjdG9yLm5hbWUsIFwicG9wX2Zyb250XCIpO1xuICAgICAgdGhpcy5lcmFzZSh0aGlzLmJlZ2luXyk7XG4gICAgfSwgZi5wcm90b3R5cGUucG9wX2JhY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmVtcHR5KCkgPT09ICEwKVxuICAgICAgICB0aHJvdyBhLkVycm9yR2VuZXJhdG9yLmVtcHR5KHRoaXMuZW5kXy5zb3VyY2UoKS5jb25zdHJ1Y3Rvci5uYW1lLCBcInBvcF9iYWNrXCIpO1xuICAgICAgdGhpcy5lcmFzZSh0aGlzLmVuZF8ucHJldigpKTtcbiAgICB9LCBmLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oKSB7XG4gICAgICBmb3IgKHZhciB1ID0gW10sIGggPSAwOyBoIDwgYXJndW1lbnRzLmxlbmd0aDsgaCsrKVxuICAgICAgICB1W2hdID0gYXJndW1lbnRzW2hdO1xuICAgICAgaWYgKHUubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gdGhpcy5zaXplKCk7XG4gICAgICB2YXIgZCA9IG5ldyBzLk5hdGl2ZUFycmF5SXRlcmF0b3IodSwgMCksIHAgPSBuZXcgcy5OYXRpdmVBcnJheUl0ZXJhdG9yKHUsIHUubGVuZ3RoKTtcbiAgICAgIHJldHVybiB0aGlzLl9JbnNlcnRfYnlfcmFuZ2UodGhpcy5lbmQoKSwgZCwgcCksIHRoaXMuc2l6ZSgpO1xuICAgIH0sIGYucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uKHUpIHtcbiAgICAgIGZvciAodmFyIGggPSBbXSwgZCA9IDE7IGQgPCBhcmd1bWVudHMubGVuZ3RoOyBkKyspXG4gICAgICAgIGhbZCAtIDFdID0gYXJndW1lbnRzW2RdO1xuICAgICAgaWYgKHUuc291cmNlKCkgIT09IHRoaXMuZW5kXy5zb3VyY2UoKSlcbiAgICAgICAgdGhyb3cgYS5FcnJvckdlbmVyYXRvci5ub3RfbXlfaXRlcmF0b3IodGhpcy5lbmRfLnNvdXJjZSgpLCBcImluc2VydFwiKTtcbiAgICAgIGlmICh1LmVyYXNlZF8gPT09ICEwKVxuICAgICAgICB0aHJvdyBhLkVycm9yR2VuZXJhdG9yLmVyYXNlZF9pdGVyYXRvcih0aGlzLmVuZF8uc291cmNlKCksIFwiaW5zZXJ0XCIpO1xuICAgICAgcmV0dXJuIGgubGVuZ3RoID09PSAxID8gdGhpcy5fSW5zZXJ0X2J5X3JlcGVhdGluZ192YWwodSwgMSwgaFswXSkgOiBoLmxlbmd0aCA9PT0gMiAmJiB0eXBlb2YgaFswXSA9PSBcIm51bWJlclwiID8gdGhpcy5fSW5zZXJ0X2J5X3JlcGVhdGluZ192YWwodSwgaFswXSwgaFsxXSkgOiB0aGlzLl9JbnNlcnRfYnlfcmFuZ2UodSwgaFswXSwgaFsxXSk7XG4gICAgfSwgZi5wcm90b3R5cGUuX0luc2VydF9ieV9yZXBlYXRpbmdfdmFsID0gZnVuY3Rpb24odSwgaCwgZCkge1xuICAgICAgdmFyIHAgPSBuZXcgaS5SZXBlYXRlcigwLCBkKSwgeSA9IG5ldyBpLlJlcGVhdGVyKGgpO1xuICAgICAgcmV0dXJuIHRoaXMuX0luc2VydF9ieV9yYW5nZSh1LCBwLCB5KTtcbiAgICB9LCBmLnByb3RvdHlwZS5fSW5zZXJ0X2J5X3JhbmdlID0gZnVuY3Rpb24odSwgaCwgZCkge1xuICAgICAgZm9yICh2YXIgcCA9IHUucHJldigpLCB5ID0gbnVsbCwgZyA9IDAsIHYgPSBoOyB2LmVxdWFscyhkKSA9PT0gITE7IHYgPSB2Lm5leHQoKSkge1xuICAgICAgICB2YXIgXyA9IHRoaXMuX0NyZWF0ZV9pdGVyYXRvcihwLCBudWxsLCB2LnZhbHVlKTtcbiAgICAgICAgZyA9PT0gMCAmJiAoeSA9IF8pLCBuLkxpc3RJdGVyYXRvci5fU2V0X25leHQocCwgXyksIHAgPSBfLCArK2c7XG4gICAgICB9XG4gICAgICByZXR1cm4gdS5lcXVhbHModGhpcy5iZWdpbigpKSA9PT0gITAgJiYgKHRoaXMuYmVnaW5fID0geSksIG4uTGlzdEl0ZXJhdG9yLl9TZXRfbmV4dChwLCB1KSwgbi5MaXN0SXRlcmF0b3IuX1NldF9wcmV2KHUsIHApLCB0aGlzLnNpemVfICs9IGcsIHk7XG4gICAgfSwgZi5wcm90b3R5cGUuZXJhc2UgPSBmdW5jdGlvbih1LCBoKSB7XG4gICAgICByZXR1cm4gaCA9PT0gdm9pZCAwICYmIChoID0gdS5uZXh0KCkpLCB0aGlzLl9FcmFzZV9ieV9yYW5nZSh1LCBoKTtcbiAgICB9LCBmLnByb3RvdHlwZS5fRXJhc2VfYnlfcmFuZ2UgPSBmdW5jdGlvbih1LCBoKSB7XG4gICAgICBpZiAodS5zb3VyY2UoKSAhPT0gdGhpcy5lbmRfLnNvdXJjZSgpKVxuICAgICAgICB0aHJvdyBhLkVycm9yR2VuZXJhdG9yLm5vdF9teV9pdGVyYXRvcih0aGlzLmVuZF8uc291cmNlKCksIFwiaW5zZXJ0XCIpO1xuICAgICAgaWYgKHUuZXJhc2VkXyA9PT0gITApXG4gICAgICAgIHRocm93IGEuRXJyb3JHZW5lcmF0b3IuZXJhc2VkX2l0ZXJhdG9yKHRoaXMuZW5kXy5zb3VyY2UoKSwgXCJpbnNlcnRcIik7XG4gICAgICBpZiAodS5lcXVhbHModGhpcy5lbmRfKSlcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kXztcbiAgICAgIHZhciBkID0gdS5wcmV2KCk7XG4gICAgICBuLkxpc3RJdGVyYXRvci5fU2V0X25leHQoZCwgaCksIG4uTGlzdEl0ZXJhdG9yLl9TZXRfcHJldihoLCBkKTtcbiAgICAgIGZvciAodmFyIHAgPSB1OyAhcC5lcXVhbHMoaCk7IHAgPSBwLm5leHQoKSlcbiAgICAgICAgcC5lcmFzZWRfID0gITAsIC0tdGhpcy5zaXplXztcbiAgICAgIHJldHVybiB1LmVxdWFscyh0aGlzLmJlZ2luXykgJiYgKHRoaXMuYmVnaW5fID0gaCksIGg7XG4gICAgfSwgZi5wcm90b3R5cGUuc3dhcCA9IGZ1bmN0aW9uKHUpIHtcbiAgICAgIHZhciBoLCBkLCBwO1xuICAgICAgaCA9IGUoW3UuYmVnaW5fLCB0aGlzLmJlZ2luX10sIDIpLCB0aGlzLmJlZ2luXyA9IGhbMF0sIHUuYmVnaW5fID0gaFsxXSwgZCA9IGUoW3UuZW5kXywgdGhpcy5lbmRfXSwgMiksIHRoaXMuZW5kXyA9IGRbMF0sIHUuZW5kXyA9IGRbMV0sIHAgPSBlKFt1LnNpemVfLCB0aGlzLnNpemVfXSwgMiksIHRoaXMuc2l6ZV8gPSBwWzBdLCB1LnNpemVfID0gcFsxXTtcbiAgICB9LCBmO1xuICB9KHIuQ29udGFpbmVyKTtcbiAgcmV0dXJuIER0Lkxpc3RDb250YWluZXIgPSBjLCBEdDtcbn1cbnZhciBLdCA9IHt9LCB4bztcbmZ1bmN0aW9uIElhKCkge1xuICBpZiAoeG8pXG4gICAgcmV0dXJuIEt0O1xuICB4byA9IDEsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShLdCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBLdC5SZXZlcnNlSXRlcmF0b3IgPSB2b2lkIDA7XG4gIHZhciB0ID0gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gZShyKSB7XG4gICAgICB0aGlzLmJhc2VfID0gci5wcmV2KCk7XG4gICAgfVxuICAgIHJldHVybiBlLnByb3RvdHlwZS5zb3VyY2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmJhc2VfLnNvdXJjZSgpO1xuICAgIH0sIGUucHJvdG90eXBlLmJhc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmJhc2VfLm5leHQoKTtcbiAgICB9LCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZS5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFzZV8udmFsdWU7XG4gICAgICB9LFxuICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgfSksIGUucHJvdG90eXBlLnByZXYgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9DcmVhdGVfbmVpZ2hib3IodGhpcy5iYXNlKCkubmV4dCgpKTtcbiAgICB9LCBlLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fQ3JlYXRlX25laWdoYm9yKHRoaXMuYmFzZV8pO1xuICAgIH0sIGUucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKHIpIHtcbiAgICAgIHJldHVybiB0aGlzLmJhc2VfLmVxdWFscyhyLmJhc2VfKTtcbiAgICB9LCBlO1xuICB9KCk7XG4gIHJldHVybiBLdC5SZXZlcnNlSXRlcmF0b3IgPSB0LCBLdDtcbn1cbnZhciBFbztcbmZ1bmN0aW9uIFFoKCkge1xuICByZXR1cm4gRW8gfHwgKEVvID0gMSwgZnVuY3Rpb24odCkge1xuICAgIHZhciBlID0gUyAmJiBTLl9fZXh0ZW5kcyB8fCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhID0gZnVuY3Rpb24oYywgbCkge1xuICAgICAgICByZXR1cm4gYSA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uKGYsIHUpIHtcbiAgICAgICAgICBmLl9fcHJvdG9fXyA9IHU7XG4gICAgICAgIH0gfHwgZnVuY3Rpb24oZiwgdSkge1xuICAgICAgICAgIGZvciAodmFyIGggaW4gdSlcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh1LCBoKSAmJiAoZltoXSA9IHVbaF0pO1xuICAgICAgICB9LCBhKGMsIGwpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBmdW5jdGlvbihjLCBsKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbCAhPSBcImZ1bmN0aW9uXCIgJiYgbCAhPT0gbnVsbClcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhsKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGEoYywgbCk7XG4gICAgICAgIGZ1bmN0aW9uIGYoKSB7XG4gICAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IGM7XG4gICAgICAgIH1cbiAgICAgICAgYy5wcm90b3R5cGUgPSBsID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShsKSA6IChmLnByb3RvdHlwZSA9IGwucHJvdG90eXBlLCBuZXcgZigpKTtcbiAgICAgIH07XG4gICAgfSgpLCByID0gUyAmJiBTLl9fcmVhZCB8fCBmdW5jdGlvbihhLCBjKSB7XG4gICAgICB2YXIgbCA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIGFbU3ltYm9sLml0ZXJhdG9yXTtcbiAgICAgIGlmICghbClcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB2YXIgZiA9IGwuY2FsbChhKSwgdSwgaCA9IFtdLCBkO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICg7IChjID09PSB2b2lkIDAgfHwgYy0tID4gMCkgJiYgISh1ID0gZi5uZXh0KCkpLmRvbmU7IClcbiAgICAgICAgICBoLnB1c2godS52YWx1ZSk7XG4gICAgICB9IGNhdGNoIChwKSB7XG4gICAgICAgIGQgPSB7IGVycm9yOiBwIH07XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHUgJiYgIXUuZG9uZSAmJiAobCA9IGYucmV0dXJuKSAmJiBsLmNhbGwoZik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKGQpXG4gICAgICAgICAgICB0aHJvdyBkLmVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaDtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIHQuU2V0RWxlbWVudExpc3QgPSB2b2lkIDA7XG4gICAgdmFyIG4gPSBDYSgpLCBpID0gbWkoKSwgcyA9IElhKCksIG8gPSBmdW5jdGlvbihhKSB7XG4gICAgICBlKGMsIGEpO1xuICAgICAgZnVuY3Rpb24gYyhsKSB7XG4gICAgICAgIHZhciBmID0gYS5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIHJldHVybiBmLmFzc29jaWF0aXZlXyA9IGwsIGY7XG4gICAgICB9XG4gICAgICByZXR1cm4gYy5wcm90b3R5cGUuX0NyZWF0ZV9pdGVyYXRvciA9IGZ1bmN0aW9uKGwsIGYsIHUpIHtcbiAgICAgICAgcmV0dXJuIGMuSXRlcmF0b3IuY3JlYXRlKHRoaXMsIGwsIGYsIHUpO1xuICAgICAgfSwgYy5fU3dhcF9hc3NvY2lhdGl2ZSA9IGZ1bmN0aW9uKGwsIGYpIHtcbiAgICAgICAgdmFyIHU7XG4gICAgICAgIHUgPSByKFtmLmFzc29jaWF0aXZlXywgbC5hc3NvY2lhdGl2ZV9dLCAyKSwgbC5hc3NvY2lhdGl2ZV8gPSB1WzBdLCBmLmFzc29jaWF0aXZlXyA9IHVbMV07XG4gICAgICB9LCBjLnByb3RvdHlwZS5hc3NvY2lhdGl2ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hc3NvY2lhdGl2ZV87XG4gICAgICB9LCBjO1xuICAgIH0obi5MaXN0Q29udGFpbmVyKTtcbiAgICB0LlNldEVsZW1lbnRMaXN0ID0gbywgZnVuY3Rpb24oYSkge1xuICAgICAgdmFyIGMgPSBmdW5jdGlvbihmKSB7XG4gICAgICAgIGUodSwgZik7XG4gICAgICAgIGZ1bmN0aW9uIHUoaCwgZCwgcCwgeSkge1xuICAgICAgICAgIHZhciBnID0gZi5jYWxsKHRoaXMsIGQsIHAsIHkpIHx8IHRoaXM7XG4gICAgICAgICAgcmV0dXJuIGcuc291cmNlXyA9IGgsIGc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHUuY3JlYXRlID0gZnVuY3Rpb24oaCwgZCwgcCwgeSkge1xuICAgICAgICAgIHJldHVybiBuZXcgdShoLCBkLCBwLCB5KTtcbiAgICAgICAgfSwgdS5wcm90b3R5cGUucmV2ZXJzZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBuZXcgbCh0aGlzKTtcbiAgICAgICAgfSwgdS5wcm90b3R5cGUuc291cmNlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlXy5hc3NvY2lhdGl2ZSgpO1xuICAgICAgICB9LCB1O1xuICAgICAgfShpLkxpc3RJdGVyYXRvcik7XG4gICAgICBhLkl0ZXJhdG9yID0gYztcbiAgICAgIHZhciBsID0gZnVuY3Rpb24oZikge1xuICAgICAgICBlKHUsIGYpO1xuICAgICAgICBmdW5jdGlvbiB1KCkge1xuICAgICAgICAgIHJldHVybiBmICE9PSBudWxsICYmIGYuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1LnByb3RvdHlwZS5fQ3JlYXRlX25laWdoYm9yID0gZnVuY3Rpb24oaCkge1xuICAgICAgICAgIHJldHVybiBuZXcgdShoKTtcbiAgICAgICAgfSwgdTtcbiAgICAgIH0ocy5SZXZlcnNlSXRlcmF0b3IpO1xuICAgICAgYS5SZXZlcnNlSXRlcmF0b3IgPSBsO1xuICAgIH0obyA9IHQuU2V0RWxlbWVudExpc3QgfHwgKHQuU2V0RWxlbWVudExpc3QgPSB7fSkpLCB0LlNldEVsZW1lbnRMaXN0ID0gbztcbiAgfSh4bikpLCB4bjtcbn1cbnZhciBXdCA9IHt9LCBWdCA9IHt9LCBrbztcbmZ1bmN0aW9uIFJhKCkge1xuICBpZiAoa28pXG4gICAgcmV0dXJuIFZ0O1xuICBrbyA9IDE7XG4gIHZhciB0ID0gUyAmJiBTLl9fdmFsdWVzIHx8IGZ1bmN0aW9uKGkpIHtcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbyA9IHMgJiYgaVtzXSwgYSA9IDA7XG4gICAgaWYgKG8pXG4gICAgICByZXR1cm4gby5jYWxsKGkpO1xuICAgIGlmIChpICYmIHR5cGVvZiBpLmxlbmd0aCA9PSBcIm51bWJlclwiKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGkgJiYgYSA+PSBpLmxlbmd0aCAmJiAoaSA9IHZvaWQgMCksIHsgdmFsdWU6IGkgJiYgaVthKytdLCBkb25lOiAhaSB9O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIFZ0Lkhhc2hCdWNrZXRzID0gdm9pZCAwO1xuICB2YXIgZSA9IGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIGkocywgbykge1xuICAgICAgdGhpcy5mZXRjaGVyXyA9IHMsIHRoaXMuaGFzaGVyXyA9IG8sIHRoaXMubWF4X2xvYWRfZmFjdG9yXyA9IG4sIHRoaXMuZGF0YV8gPSBbXSwgdGhpcy5zaXplXyA9IDAsIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gaS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZGF0YV8gPSBbXSwgdGhpcy5zaXplXyA9IDAsIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgIH0sIGkucHJvdG90eXBlLnJlaGFzaCA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgIHZhciBvLCBhLCBjLCBsO1xuICAgICAgcyA9IE1hdGgubWF4KHMsIHIpO1xuICAgICAgZm9yICh2YXIgZiA9IFtdLCB1ID0gMDsgdSA8IHM7ICsrdSlcbiAgICAgICAgZi5wdXNoKFtdKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIGggPSB0KHRoaXMuZGF0YV8pLCBkID0gaC5uZXh0KCk7ICFkLmRvbmU7IGQgPSBoLm5leHQoKSkge1xuICAgICAgICAgIHZhciBwID0gZC52YWx1ZTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgeSA9IChjID0gdm9pZCAwLCB0KHApKSwgZyA9IHkubmV4dCgpOyAhZy5kb25lOyBnID0geS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgdmFyIHYgPSBnLnZhbHVlLCBfID0gdGhpcy5oYXNoZXJfKHRoaXMuZmV0Y2hlcl8odikpICUgZi5sZW5ndGg7XG4gICAgICAgICAgICAgIGZbX10ucHVzaCh2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChtKSB7XG4gICAgICAgICAgICBjID0geyBlcnJvcjogbSB9O1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBnICYmICFnLmRvbmUgJiYgKGwgPSB5LnJldHVybikgJiYgbC5jYWxsKHkpO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgaWYgKGMpXG4gICAgICAgICAgICAgICAgdGhyb3cgYy5lcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKG0pIHtcbiAgICAgICAgbyA9IHsgZXJyb3I6IG0gfTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZCAmJiAhZC5kb25lICYmIChhID0gaC5yZXR1cm4pICYmIGEuY2FsbChoKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAobylcbiAgICAgICAgICAgIHRocm93IG8uZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuZGF0YV8gPSBmO1xuICAgIH0sIGkucHJvdG90eXBlLnJlc2VydmUgPSBmdW5jdGlvbihzKSB7XG4gICAgICBzID4gdGhpcy5jYXBhY2l0eSgpICYmIChzID0gTWF0aC5mbG9vcihzIC8gdGhpcy5tYXhfbG9hZF9mYWN0b3JfKSwgdGhpcy5yZWhhc2gocykpO1xuICAgIH0sIGkucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHtcbiAgICAgIGZvciAodmFyIHMgPSAwOyBzIDwgcjsgKytzKVxuICAgICAgICB0aGlzLmRhdGFfLnB1c2goW10pO1xuICAgIH0sIGkucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGF0YV8ubGVuZ3RoO1xuICAgIH0sIGkucHJvdG90eXBlLmNhcGFjaXR5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5kYXRhXy5sZW5ndGggKiB0aGlzLm1heF9sb2FkX2ZhY3Rvcl87XG4gICAgfSwgaS5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbihzKSB7XG4gICAgICByZXR1cm4gdGhpcy5kYXRhX1tzXTtcbiAgICB9LCBpLnByb3RvdHlwZS5sb2FkX2ZhY3RvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2l6ZV8gLyB0aGlzLmxlbmd0aCgpO1xuICAgIH0sIGkucHJvdG90eXBlLm1heF9sb2FkX2ZhY3RvciA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgIGlmIChzID09PSB2b2lkIDAgJiYgKHMgPSBudWxsKSwgcyA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuIHRoaXMubWF4X2xvYWRfZmFjdG9yXztcbiAgICAgIHRoaXMubWF4X2xvYWRfZmFjdG9yXyA9IHM7XG4gICAgfSwgaS5wcm90b3R5cGUuaGFzaF9mdW5jdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFzaGVyXztcbiAgICB9LCBpLnByb3RvdHlwZS5pbmRleCA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhc2hlcl8odGhpcy5mZXRjaGVyXyhzKSkgJSB0aGlzLmxlbmd0aCgpO1xuICAgIH0sIGkucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgIHZhciBvID0gdGhpcy5jYXBhY2l0eSgpO1xuICAgICAgKyt0aGlzLnNpemVfID4gbyAmJiB0aGlzLnJlc2VydmUobyAqIDIpO1xuICAgICAgdmFyIGEgPSB0aGlzLmluZGV4KHMpO1xuICAgICAgdGhpcy5kYXRhX1thXS5wdXNoKHMpO1xuICAgIH0sIGkucHJvdG90eXBlLmVyYXNlID0gZnVuY3Rpb24ocykge1xuICAgICAgZm9yICh2YXIgbyA9IHRoaXMuaW5kZXgocyksIGEgPSB0aGlzLmRhdGFfW29dLCBjID0gMDsgYyA8IGEubGVuZ3RoOyArK2MpXG4gICAgICAgIGlmIChhW2NdID09PSBzKSB7XG4gICAgICAgICAgYS5zcGxpY2UoYywgMSksIC0tdGhpcy5zaXplXztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH0sIGk7XG4gIH0oKTtcbiAgVnQuSGFzaEJ1Y2tldHMgPSBlO1xuICB2YXIgciA9IDEwLCBuID0gMTtcbiAgcmV0dXJuIFZ0O1xufVxudmFyIFNvO1xuZnVuY3Rpb24gZWQoKSB7XG4gIGlmIChTbylcbiAgICByZXR1cm4gV3Q7XG4gIFNvID0gMTtcbiAgdmFyIHQgPSBTICYmIFMuX19leHRlbmRzIHx8IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvID0gZnVuY3Rpb24oYSwgYykge1xuICAgICAgcmV0dXJuIG8gPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbihsLCBmKSB7XG4gICAgICAgIGwuX19wcm90b19fID0gZjtcbiAgICAgIH0gfHwgZnVuY3Rpb24obCwgZikge1xuICAgICAgICBmb3IgKHZhciB1IGluIGYpXG4gICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGYsIHUpICYmIChsW3VdID0gZlt1XSk7XG4gICAgICB9LCBvKGEsIGMpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGEsIGMpIHtcbiAgICAgIGlmICh0eXBlb2YgYyAhPSBcImZ1bmN0aW9uXCIgJiYgYyAhPT0gbnVsbClcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYykgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgbyhhLCBjKTtcbiAgICAgIGZ1bmN0aW9uIGwoKSB7XG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IgPSBhO1xuICAgICAgfVxuICAgICAgYS5wcm90b3R5cGUgPSBjID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShjKSA6IChsLnByb3RvdHlwZSA9IGMucHJvdG90eXBlLCBuZXcgbCgpKTtcbiAgICB9O1xuICB9KCksIGUgPSBTICYmIFMuX19yZWFkIHx8IGZ1bmN0aW9uKG8sIGEpIHtcbiAgICB2YXIgYyA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIWMpXG4gICAgICByZXR1cm4gbztcbiAgICB2YXIgbCA9IGMuY2FsbChvKSwgZiwgdSA9IFtdLCBoO1xuICAgIHRyeSB7XG4gICAgICBmb3IgKDsgKGEgPT09IHZvaWQgMCB8fCBhLS0gPiAwKSAmJiAhKGYgPSBsLm5leHQoKSkuZG9uZTsgKVxuICAgICAgICB1LnB1c2goZi52YWx1ZSk7XG4gICAgfSBjYXRjaCAoZCkge1xuICAgICAgaCA9IHsgZXJyb3I6IGQgfTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZiAmJiAhZi5kb25lICYmIChjID0gbC5yZXR1cm4pICYmIGMuY2FsbChsKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChoKVxuICAgICAgICAgIHRocm93IGguZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1O1xuICB9LCByID0gUyAmJiBTLl9fdmFsdWVzIHx8IGZ1bmN0aW9uKG8pIHtcbiAgICB2YXIgYSA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgYyA9IGEgJiYgb1thXSwgbCA9IDA7XG4gICAgaWYgKGMpXG4gICAgICByZXR1cm4gYy5jYWxsKG8pO1xuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PSBcIm51bWJlclwiKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIG8gJiYgbCA+PSBvLmxlbmd0aCAmJiAobyA9IHZvaWQgMCksIHsgdmFsdWU6IG8gJiYgb1tsKytdLCBkb25lOiAhbyB9O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYSA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFd0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIFd0LlNldEhhc2hCdWNrZXRzID0gdm9pZCAwO1xuICB2YXIgbiA9IFJhKCksIGkgPSBmdW5jdGlvbihvKSB7XG4gICAgdChhLCBvKTtcbiAgICBmdW5jdGlvbiBhKGMsIGwsIGYpIHtcbiAgICAgIHZhciB1ID0gby5jYWxsKHRoaXMsIHMsIGwpIHx8IHRoaXM7XG4gICAgICByZXR1cm4gdS5zb3VyY2VfID0gYywgdS5rZXlfZXFfID0gZiwgdTtcbiAgICB9XG4gICAgcmV0dXJuIGEuX1N3YXBfc291cmNlID0gZnVuY3Rpb24oYywgbCkge1xuICAgICAgdmFyIGY7XG4gICAgICBmID0gZShbbC5zb3VyY2VfLCBjLnNvdXJjZV9dLCAyKSwgYy5zb3VyY2VfID0gZlswXSwgbC5zb3VyY2VfID0gZlsxXTtcbiAgICB9LCBhLnByb3RvdHlwZS5rZXlfZXEgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmtleV9lcV87XG4gICAgfSwgYS5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgIHZhciBsLCBmLCB1ID0gdGhpcy5oYXNoX2Z1bmN0aW9uKCkoYykgJSB0aGlzLmxlbmd0aCgpLCBoID0gdGhpcy5hdCh1KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIGQgPSByKGgpLCBwID0gZC5uZXh0KCk7ICFwLmRvbmU7IHAgPSBkLm5leHQoKSkge1xuICAgICAgICAgIHZhciB5ID0gcC52YWx1ZTtcbiAgICAgICAgICBpZiAodGhpcy5rZXlfZXFfKHkudmFsdWUsIGMpKVxuICAgICAgICAgICAgcmV0dXJuIHk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGcpIHtcbiAgICAgICAgbCA9IHsgZXJyb3I6IGcgfTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcCAmJiAhcC5kb25lICYmIChmID0gZC5yZXR1cm4pICYmIGYuY2FsbChkKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAobClcbiAgICAgICAgICAgIHRocm93IGwuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZV8uZW5kKCk7XG4gICAgfSwgYTtcbiAgfShuLkhhc2hCdWNrZXRzKTtcbiAgV3QuU2V0SGFzaEJ1Y2tldHMgPSBpO1xuICBmdW5jdGlvbiBzKG8pIHtcbiAgICByZXR1cm4gby52YWx1ZTtcbiAgfVxuICByZXR1cm4gV3Q7XG59XG52YXIgc3QgPSB7fSwgT287XG5mdW5jdGlvbiBUYSgpIHtcbiAgaWYgKE9vKVxuICAgIHJldHVybiBzdDtcbiAgT28gPSAxLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3QsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgc3QubWFrZV9wYWlyID0gc3QuUGFpciA9IHZvaWQgMDtcbiAgdmFyIHQgPSB3aSgpLCBlID0gX2koKSwgciA9IGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIGkocywgbykge1xuICAgICAgdGhpcy5maXJzdCA9IHMsIHRoaXMuc2Vjb25kID0gbztcbiAgICB9XG4gICAgcmV0dXJuIGkucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgIHJldHVybiAoMCwgZS5lcXVhbF90bykodGhpcy5maXJzdCwgcy5maXJzdCkgJiYgKDAsIGUuZXF1YWxfdG8pKHRoaXMuc2Vjb25kLCBzLnNlY29uZCk7XG4gICAgfSwgaS5wcm90b3R5cGUubGVzcyA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgIHJldHVybiAoMCwgZS5lcXVhbF90bykodGhpcy5maXJzdCwgcy5maXJzdCkgPT09ICExID8gKDAsIGUubGVzcykodGhpcy5maXJzdCwgcy5maXJzdCkgOiAoMCwgZS5sZXNzKSh0aGlzLnNlY29uZCwgcy5zZWNvbmQpO1xuICAgIH0sIGkucHJvdG90eXBlLmhhc2hDb2RlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gKDAsIHQuaGFzaCkodGhpcy5maXJzdCwgdGhpcy5zZWNvbmQpO1xuICAgIH0sIGk7XG4gIH0oKTtcbiAgc3QuUGFpciA9IHI7XG4gIGZ1bmN0aW9uIG4oaSwgcykge1xuICAgIHJldHVybiBuZXcgcihpLCBzKTtcbiAgfVxuICByZXR1cm4gc3QubWFrZV9wYWlyID0gbiwgc3Q7XG59XG52YXIgQW87XG5mdW5jdGlvbiB0ZCgpIHtcbiAgcmV0dXJuIEFvIHx8IChBbyA9IDEsIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSA9IFMgJiYgUy5fX2V4dGVuZHMgfHwgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZiA9IGZ1bmN0aW9uKHUsIGgpIHtcbiAgICAgICAgcmV0dXJuIGYgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbihkLCBwKSB7XG4gICAgICAgICAgZC5fX3Byb3RvX18gPSBwO1xuICAgICAgICB9IHx8IGZ1bmN0aW9uKGQsIHApIHtcbiAgICAgICAgICBmb3IgKHZhciB5IGluIHApXG4gICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocCwgeSkgJiYgKGRbeV0gPSBwW3ldKTtcbiAgICAgICAgfSwgZih1LCBoKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gZnVuY3Rpb24odSwgaCkge1xuICAgICAgICBpZiAodHlwZW9mIGggIT0gXCJmdW5jdGlvblwiICYmIGggIT09IG51bGwpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoaCkgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBmKHUsIGgpO1xuICAgICAgICBmdW5jdGlvbiBkKCkge1xuICAgICAgICAgIHRoaXMuY29uc3RydWN0b3IgPSB1O1xuICAgICAgICB9XG4gICAgICAgIHUucHJvdG90eXBlID0gaCA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoaCkgOiAoZC5wcm90b3R5cGUgPSBoLnByb3RvdHlwZSwgbmV3IGQoKSk7XG4gICAgICB9O1xuICAgIH0oKSwgciA9IFMgJiYgUy5fX3JlYWQgfHwgZnVuY3Rpb24oZiwgdSkge1xuICAgICAgdmFyIGggPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBmW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgICBpZiAoIWgpXG4gICAgICAgIHJldHVybiBmO1xuICAgICAgdmFyIGQgPSBoLmNhbGwoZiksIHAsIHkgPSBbXSwgZztcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoOyAodSA9PT0gdm9pZCAwIHx8IHUtLSA+IDApICYmICEocCA9IGQubmV4dCgpKS5kb25lOyApXG4gICAgICAgICAgeS5wdXNoKHAudmFsdWUpO1xuICAgICAgfSBjYXRjaCAodikge1xuICAgICAgICBnID0geyBlcnJvcjogdiB9O1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBwICYmICFwLmRvbmUgJiYgKGggPSBkLnJldHVybikgJiYgaC5jYWxsKGQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChnKVxuICAgICAgICAgICAgdGhyb3cgZy5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHk7XG4gICAgfSwgbiA9IFMgJiYgUy5fX3NwcmVhZEFycmF5IHx8IGZ1bmN0aW9uKGYsIHUsIGgpIHtcbiAgICAgIGlmIChoIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpXG4gICAgICAgIGZvciAodmFyIGQgPSAwLCBwID0gdS5sZW5ndGgsIHk7IGQgPCBwOyBkKyspXG4gICAgICAgICAgKHkgfHwgIShkIGluIHUpKSAmJiAoeSB8fCAoeSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHUsIDAsIGQpKSwgeVtkXSA9IHVbZF0pO1xuICAgICAgcmV0dXJuIGYuY29uY2F0KHkgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodSkpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgdC5IYXNoU2V0ID0gdm9pZCAwO1xuICAgIHZhciBpID0gR2goKSwgcyA9IEFhKCksIG8gPSBRaCgpLCBhID0gZWQoKSwgYyA9IFRhKCksIGwgPSBmdW5jdGlvbihmKSB7XG4gICAgICBlKHUsIGYpO1xuICAgICAgZnVuY3Rpb24gdSgpIHtcbiAgICAgICAgZm9yICh2YXIgaCA9IFtdLCBkID0gMDsgZCA8IGFyZ3VtZW50cy5sZW5ndGg7IGQrKylcbiAgICAgICAgICBoW2RdID0gYXJndW1lbnRzW2RdO1xuICAgICAgICB2YXIgcCA9IGYuY2FsbCh0aGlzLCBmdW5jdGlvbih5KSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBvLlNldEVsZW1lbnRMaXN0KHkpO1xuICAgICAgICB9KSB8fCB0aGlzO1xuICAgICAgICByZXR1cm4gcy5JSGFzaENvbnRhaW5lci5jb25zdHJ1Y3QuYXBwbHkocy5JSGFzaENvbnRhaW5lciwgbihbXG4gICAgICAgICAgcCxcbiAgICAgICAgICB1LFxuICAgICAgICAgIGZ1bmN0aW9uKHksIGcpIHtcbiAgICAgICAgICAgIHAuYnVja2V0c18gPSBuZXcgYS5TZXRIYXNoQnVja2V0cyhwLCB5LCBnKTtcbiAgICAgICAgICB9XG4gICAgICAgIF0sIHIoaCksICExKSksIHA7XG4gICAgICB9XG4gICAgICByZXR1cm4gdS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5idWNrZXRzXy5jbGVhcigpLCBmLnByb3RvdHlwZS5jbGVhci5jYWxsKHRoaXMpO1xuICAgICAgfSwgdS5wcm90b3R5cGUuc3dhcCA9IGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgdmFyIGQsIHA7XG4gICAgICAgIGQgPSByKFtoLmRhdGFfLCB0aGlzLmRhdGFfXSwgMiksIHRoaXMuZGF0YV8gPSBkWzBdLCBoLmRhdGFfID0gZFsxXSwgby5TZXRFbGVtZW50TGlzdC5fU3dhcF9hc3NvY2lhdGl2ZSh0aGlzLmRhdGFfLCBoLmRhdGFfKSwgYS5TZXRIYXNoQnVja2V0cy5fU3dhcF9zb3VyY2UodGhpcy5idWNrZXRzXywgaC5idWNrZXRzXyksIHAgPSByKFtoLmJ1Y2tldHNfLCB0aGlzLmJ1Y2tldHNfXSwgMiksIHRoaXMuYnVja2V0c18gPSBwWzBdLCBoLmJ1Y2tldHNfID0gcFsxXTtcbiAgICAgIH0sIHUucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbihoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1Y2tldHNfLmZpbmQoaCk7XG4gICAgICB9LCB1LnByb3RvdHlwZS5iZWdpbiA9IGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgcmV0dXJuIGggPT09IHZvaWQgMCAmJiAoaCA9IG51bGwpLCBoID09PSBudWxsID8gZi5wcm90b3R5cGUuYmVnaW4uY2FsbCh0aGlzKSA6IHRoaXMuYnVja2V0c18uYXQoaClbMF07XG4gICAgICB9LCB1LnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihoKSB7XG4gICAgICAgIGlmIChoID09PSB2b2lkIDAgJiYgKGggPSBudWxsKSwgaCA9PT0gbnVsbClcbiAgICAgICAgICByZXR1cm4gZi5wcm90b3R5cGUuZW5kLmNhbGwodGhpcyk7XG4gICAgICAgIHZhciBkID0gdGhpcy5idWNrZXRzXy5hdChoKTtcbiAgICAgICAgcmV0dXJuIGRbZC5sZW5ndGggLSAxXS5uZXh0KCk7XG4gICAgICB9LCB1LnByb3RvdHlwZS5yYmVnaW4gPSBmdW5jdGlvbihoKSB7XG4gICAgICAgIHJldHVybiBoID09PSB2b2lkIDAgJiYgKGggPSBudWxsKSwgdGhpcy5lbmQoaCkucmV2ZXJzZSgpO1xuICAgICAgfSwgdS5wcm90b3R5cGUucmVuZCA9IGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgcmV0dXJuIGggPT09IHZvaWQgMCAmJiAoaCA9IG51bGwpLCB0aGlzLmJlZ2luKGgpLnJldmVyc2UoKTtcbiAgICAgIH0sIHUucHJvdG90eXBlLmJ1Y2tldF9jb3VudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWNrZXRzXy5sZW5ndGgoKTtcbiAgICAgIH0sIHUucHJvdG90eXBlLmJ1Y2tldF9zaXplID0gZnVuY3Rpb24oaCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWNrZXRzXy5hdChoKS5sZW5ndGg7XG4gICAgICB9LCB1LnByb3RvdHlwZS5sb2FkX2ZhY3RvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWNrZXRzXy5sb2FkX2ZhY3RvcigpO1xuICAgICAgfSwgdS5wcm90b3R5cGUuaGFzaF9mdW5jdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWNrZXRzXy5oYXNoX2Z1bmN0aW9uKCk7XG4gICAgICB9LCB1LnByb3RvdHlwZS5rZXlfZXEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVja2V0c18ua2V5X2VxKCk7XG4gICAgICB9LCB1LnByb3RvdHlwZS5idWNrZXQgPSBmdW5jdGlvbihoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc2hfZnVuY3Rpb24oKShoKSAlIHRoaXMuYnVja2V0c18ubGVuZ3RoKCk7XG4gICAgICB9LCB1LnByb3RvdHlwZS5tYXhfbG9hZF9mYWN0b3IgPSBmdW5jdGlvbihoKSB7XG4gICAgICAgIHJldHVybiBoID09PSB2b2lkIDAgJiYgKGggPSBudWxsKSwgdGhpcy5idWNrZXRzXy5tYXhfbG9hZF9mYWN0b3IoaCk7XG4gICAgICB9LCB1LnByb3RvdHlwZS5yZXNlcnZlID0gZnVuY3Rpb24oaCkge1xuICAgICAgICB0aGlzLmJ1Y2tldHNfLnJlc2VydmUoaCk7XG4gICAgICB9LCB1LnByb3RvdHlwZS5yZWhhc2ggPSBmdW5jdGlvbihoKSB7XG4gICAgICAgIHRoaXMuYnVja2V0c18ucmVoYXNoKGgpO1xuICAgICAgfSwgdS5wcm90b3R5cGUuX0luc2VydF9ieV9rZXkgPSBmdW5jdGlvbihoKSB7XG4gICAgICAgIHZhciBkID0gdGhpcy5maW5kKGgpO1xuICAgICAgICByZXR1cm4gZC5lcXVhbHModGhpcy5lbmQoKSkgPT09ICExID8gbmV3IGMuUGFpcihkLCAhMSkgOiAodGhpcy5kYXRhXy5wdXNoKGgpLCBkID0gZC5wcmV2KCksIHRoaXMuX0hhbmRsZV9pbnNlcnQoZCwgZC5uZXh0KCkpLCBuZXcgYy5QYWlyKGQsICEwKSk7XG4gICAgICB9LCB1LnByb3RvdHlwZS5fSW5zZXJ0X2J5X2hpbnQgPSBmdW5jdGlvbihoLCBkKSB7XG4gICAgICAgIHZhciBwID0gdGhpcy5maW5kKGQpO1xuICAgICAgICByZXR1cm4gcC5lcXVhbHModGhpcy5lbmQoKSkgPT09ICEwICYmIChwID0gdGhpcy5kYXRhXy5pbnNlcnQoaCwgZCksIHRoaXMuX0hhbmRsZV9pbnNlcnQocCwgcC5uZXh0KCkpKSwgcDtcbiAgICAgIH0sIHUucHJvdG90eXBlLl9IYW5kbGVfaW5zZXJ0ID0gZnVuY3Rpb24oaCwgZCkge1xuICAgICAgICBmb3IgKDsgIWguZXF1YWxzKGQpOyBoID0gaC5uZXh0KCkpXG4gICAgICAgICAgdGhpcy5idWNrZXRzXy5pbnNlcnQoaCk7XG4gICAgICB9LCB1LnByb3RvdHlwZS5fSGFuZGxlX2VyYXNlID0gZnVuY3Rpb24oaCwgZCkge1xuICAgICAgICBmb3IgKDsgIWguZXF1YWxzKGQpOyBoID0gaC5uZXh0KCkpXG4gICAgICAgICAgdGhpcy5idWNrZXRzXy5lcmFzZShoKTtcbiAgICAgIH0sIHU7XG4gICAgfShpLlVuaXF1ZVNldCk7XG4gICAgdC5IYXNoU2V0ID0gbCwgZnVuY3Rpb24oZikge1xuICAgICAgZi5JdGVyYXRvciA9IG8uU2V0RWxlbWVudExpc3QuSXRlcmF0b3IsIGYuUmV2ZXJzZUl0ZXJhdG9yID0gby5TZXRFbGVtZW50TGlzdC5SZXZlcnNlSXRlcmF0b3I7XG4gICAgfShsID0gdC5IYXNoU2V0IHx8ICh0Lkhhc2hTZXQgPSB7fSkpLCB0Lkhhc2hTZXQgPSBsO1xuICB9KHZuKSksIHZuO1xufVxudmFyIEVuID0ge30sIEd0ID0ge30sIFp0ID0ge30sIENvO1xuZnVuY3Rpb24gcmQoKSB7XG4gIGlmIChDbylcbiAgICByZXR1cm4gWnQ7XG4gIENvID0gMTtcbiAgdmFyIHQgPSBTICYmIFMuX19leHRlbmRzIHx8IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpID0gZnVuY3Rpb24ocywgbykge1xuICAgICAgcmV0dXJuIGkgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbihhLCBjKSB7XG4gICAgICAgIGEuX19wcm90b19fID0gYztcbiAgICAgIH0gfHwgZnVuY3Rpb24oYSwgYykge1xuICAgICAgICBmb3IgKHZhciBsIGluIGMpXG4gICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGMsIGwpICYmIChhW2xdID0gY1tsXSk7XG4gICAgICB9LCBpKHMsIG8pO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHMsIG8pIHtcbiAgICAgIGlmICh0eXBlb2YgbyAhPSBcImZ1bmN0aW9uXCIgJiYgbyAhPT0gbnVsbClcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcobykgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgaShzLCBvKTtcbiAgICAgIGZ1bmN0aW9uIGEoKSB7XG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IgPSBzO1xuICAgICAgfVxuICAgICAgcy5wcm90b3R5cGUgPSBvID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShvKSA6IChhLnByb3RvdHlwZSA9IG8ucHJvdG90eXBlLCBuZXcgYSgpKTtcbiAgICB9O1xuICB9KCk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShadCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBadC5NYXBDb250YWluZXIgPSB2b2lkIDA7XG4gIHZhciBlID0gYmkoKSwgciA9IHZpKCksIG4gPSBmdW5jdGlvbihpKSB7XG4gICAgdChzLCBpKTtcbiAgICBmdW5jdGlvbiBzKG8pIHtcbiAgICAgIHZhciBhID0gaS5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICByZXR1cm4gYS5kYXRhXyA9IG8oYSksIGE7XG4gICAgfVxuICAgIHJldHVybiBzLnByb3RvdHlwZS5hc3NpZ24gPSBmdW5jdGlvbihvLCBhKSB7XG4gICAgICB0aGlzLmNsZWFyKCksIHRoaXMuaW5zZXJ0KG8sIGEpO1xuICAgIH0sIHMucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRhdGFfLmNsZWFyKCk7XG4gICAgfSwgcy5wcm90b3R5cGUuYmVnaW4gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmRhdGFfLmJlZ2luKCk7XG4gICAgfSwgcy5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5kYXRhXy5lbmQoKTtcbiAgICB9LCBzLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihvKSB7XG4gICAgICByZXR1cm4gIXRoaXMuZmluZChvKS5lcXVhbHModGhpcy5lbmQoKSk7XG4gICAgfSwgcy5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGF0YV8uc2l6ZSgpO1xuICAgIH0sIHMucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbigpIHtcbiAgICAgIGZvciAodmFyIG8gPSBbXSwgYSA9IDA7IGEgPCBhcmd1bWVudHMubGVuZ3RoOyBhKyspXG4gICAgICAgIG9bYV0gPSBhcmd1bWVudHNbYV07XG4gICAgICB2YXIgYyA9IG5ldyByLk5hdGl2ZUFycmF5SXRlcmF0b3IobywgMCksIGwgPSBuZXcgci5OYXRpdmVBcnJheUl0ZXJhdG9yKG8sIG8ubGVuZ3RoKTtcbiAgICAgIHJldHVybiB0aGlzLmluc2VydChjLCBsKSwgdGhpcy5zaXplKCk7XG4gICAgfSwgcy5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICBmb3IgKHZhciBvID0gW10sIGEgPSAwOyBhIDwgYXJndW1lbnRzLmxlbmd0aDsgYSsrKVxuICAgICAgICBvW2FdID0gYXJndW1lbnRzW2FdO1xuICAgICAgcmV0dXJuIG8ubGVuZ3RoID09PSAxID8gdGhpcy5lbXBsYWNlKG9bMF0uZmlyc3QsIG9bMF0uc2Vjb25kKSA6IG9bMF0ubmV4dCBpbnN0YW5jZW9mIEZ1bmN0aW9uICYmIG9bMV0ubmV4dCBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gdGhpcy5fSW5zZXJ0X2J5X3JhbmdlKG9bMF0sIG9bMV0pIDogdGhpcy5lbXBsYWNlX2hpbnQob1swXSwgb1sxXS5maXJzdCwgb1sxXS5zZWNvbmQpO1xuICAgIH0sIHMucHJvdG90eXBlLmVyYXNlID0gZnVuY3Rpb24oKSB7XG4gICAgICBmb3IgKHZhciBvID0gW10sIGEgPSAwOyBhIDwgYXJndW1lbnRzLmxlbmd0aDsgYSsrKVxuICAgICAgICBvW2FdID0gYXJndW1lbnRzW2FdO1xuICAgICAgcmV0dXJuIG8ubGVuZ3RoID09PSAxICYmICghKG9bMF0gaW5zdGFuY2VvZiB0aGlzLmVuZCgpLmNvbnN0cnVjdG9yKSB8fCBvWzBdLnNvdXJjZSgpICE9PSB0aGlzKSA/IHRoaXMuX0VyYXNlX2J5X2tleShvWzBdKSA6IG8ubGVuZ3RoID09PSAxID8gdGhpcy5fRXJhc2VfYnlfcmFuZ2Uob1swXSkgOiB0aGlzLl9FcmFzZV9ieV9yYW5nZShvWzBdLCBvWzFdKTtcbiAgICB9LCBzLnByb3RvdHlwZS5fRXJhc2VfYnlfcmFuZ2UgPSBmdW5jdGlvbihvLCBhKSB7XG4gICAgICBhID09PSB2b2lkIDAgJiYgKGEgPSBvLm5leHQoKSk7XG4gICAgICB2YXIgYyA9IHRoaXMuZGF0YV8uZXJhc2UobywgYSk7XG4gICAgICByZXR1cm4gdGhpcy5fSGFuZGxlX2VyYXNlKG8sIGEpLCBjO1xuICAgIH0sIHM7XG4gIH0oZS5Db250YWluZXIpO1xuICByZXR1cm4gWnQuTWFwQ29udGFpbmVyID0gbiwgWnQ7XG59XG52YXIgSW87XG5mdW5jdGlvbiBuZCgpIHtcbiAgaWYgKElvKVxuICAgIHJldHVybiBHdDtcbiAgSW8gPSAxO1xuICB2YXIgdCA9IFMgJiYgUy5fX2V4dGVuZHMgfHwgZnVuY3Rpb24oKSB7XG4gICAgdmFyIG8gPSBmdW5jdGlvbihhLCBjKSB7XG4gICAgICByZXR1cm4gbyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uKGwsIGYpIHtcbiAgICAgICAgbC5fX3Byb3RvX18gPSBmO1xuICAgICAgfSB8fCBmdW5jdGlvbihsLCBmKSB7XG4gICAgICAgIGZvciAodmFyIHUgaW4gZilcbiAgICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZiwgdSkgJiYgKGxbdV0gPSBmW3VdKTtcbiAgICAgIH0sIG8oYSwgYyk7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24oYSwgYykge1xuICAgICAgaWYgKHR5cGVvZiBjICE9IFwiZnVuY3Rpb25cIiAmJiBjICE9PSBudWxsKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhjKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICBvKGEsIGMpO1xuICAgICAgZnVuY3Rpb24gbCgpIHtcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IGE7XG4gICAgICB9XG4gICAgICBhLnByb3RvdHlwZSA9IGMgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGMpIDogKGwucHJvdG90eXBlID0gYy5wcm90b3R5cGUsIG5ldyBsKCkpO1xuICAgIH07XG4gIH0oKSwgZSA9IFMgJiYgUy5fX3JlYWQgfHwgZnVuY3Rpb24obywgYSkge1xuICAgIHZhciBjID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghYylcbiAgICAgIHJldHVybiBvO1xuICAgIHZhciBsID0gYy5jYWxsKG8pLCBmLCB1ID0gW10sIGg7XG4gICAgdHJ5IHtcbiAgICAgIGZvciAoOyAoYSA9PT0gdm9pZCAwIHx8IGEtLSA+IDApICYmICEoZiA9IGwubmV4dCgpKS5kb25lOyApXG4gICAgICAgIHUucHVzaChmLnZhbHVlKTtcbiAgICB9IGNhdGNoIChkKSB7XG4gICAgICBoID0geyBlcnJvcjogZCB9O1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBmICYmICFmLmRvbmUgJiYgKGMgPSBsLnJldHVybikgJiYgYy5jYWxsKGwpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGgpXG4gICAgICAgICAgdGhyb3cgaC5lcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHU7XG4gIH0sIHIgPSBTICYmIFMuX19zcHJlYWRBcnJheSB8fCBmdW5jdGlvbihvLCBhLCBjKSB7XG4gICAgaWYgKGMgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMilcbiAgICAgIGZvciAodmFyIGwgPSAwLCBmID0gYS5sZW5ndGgsIHU7IGwgPCBmOyBsKyspXG4gICAgICAgICh1IHx8ICEobCBpbiBhKSkgJiYgKHUgfHwgKHUgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhLCAwLCBsKSksIHVbbF0gPSBhW2xdKTtcbiAgICByZXR1cm4gby5jb25jYXQodSB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhKSk7XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShHdCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBHdC5VbmlxdWVNYXAgPSB2b2lkIDA7XG4gIHZhciBuID0gcmQoKSwgaSA9IFdyKCksIHMgPSBmdW5jdGlvbihvKSB7XG4gICAgdChhLCBvKTtcbiAgICBmdW5jdGlvbiBhKCkge1xuICAgICAgcmV0dXJuIG8gIT09IG51bGwgJiYgby5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBhLnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbmQoYykuZXF1YWxzKHRoaXMuZW5kKCkpID8gMCA6IDE7XG4gICAgfSwgYS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oYykge1xuICAgICAgdmFyIGwgPSB0aGlzLmZpbmQoYyk7XG4gICAgICBpZiAobC5lcXVhbHModGhpcy5lbmQoKSkgPT09ICEwKVxuICAgICAgICB0aHJvdyBpLkVycm9yR2VuZXJhdG9yLmtleV9ub3V0X2ZvdW5kKHRoaXMsIFwiZ2V0XCIsIGMpO1xuICAgICAgcmV0dXJuIGwuc2Vjb25kO1xuICAgIH0sIGEucHJvdG90eXBlLnRha2UgPSBmdW5jdGlvbihjLCBsKSB7XG4gICAgICB2YXIgZiA9IHRoaXMuZmluZChjKTtcbiAgICAgIHJldHVybiBmLmVxdWFscyh0aGlzLmVuZCgpKSA/IHRoaXMuZW1wbGFjZShjLCBsKCkpLmZpcnN0LnNlY29uZCA6IGYuc2Vjb25kO1xuICAgIH0sIGEucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGMsIGwpIHtcbiAgICAgIHRoaXMuaW5zZXJ0X29yX2Fzc2lnbihjLCBsKTtcbiAgICB9LCBhLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGZvciAodmFyIGMgPSBbXSwgbCA9IDA7IGwgPCBhcmd1bWVudHMubGVuZ3RoOyBsKyspXG4gICAgICAgIGNbbF0gPSBhcmd1bWVudHNbbF07XG4gICAgICByZXR1cm4gby5wcm90b3R5cGUuaW5zZXJ0LmFwcGx5KHRoaXMsIHIoW10sIGUoYyksICExKSk7XG4gICAgfSwgYS5wcm90b3R5cGUuX0luc2VydF9ieV9yYW5nZSA9IGZ1bmN0aW9uKGMsIGwpIHtcbiAgICAgIGZvciAodmFyIGYgPSBjOyAhZi5lcXVhbHMobCk7IGYgPSBmLm5leHQoKSlcbiAgICAgICAgdGhpcy5lbXBsYWNlKGYudmFsdWUuZmlyc3QsIGYudmFsdWUuc2Vjb25kKTtcbiAgICB9LCBhLnByb3RvdHlwZS5pbnNlcnRfb3JfYXNzaWduID0gZnVuY3Rpb24oKSB7XG4gICAgICBmb3IgKHZhciBjID0gW10sIGwgPSAwOyBsIDwgYXJndW1lbnRzLmxlbmd0aDsgbCsrKVxuICAgICAgICBjW2xdID0gYXJndW1lbnRzW2xdO1xuICAgICAgaWYgKGMubGVuZ3RoID09PSAyKVxuICAgICAgICByZXR1cm4gdGhpcy5fSW5zZXJ0X29yX2Fzc2lnbl93aXRoX2tleV92YWx1ZShjWzBdLCBjWzFdKTtcbiAgICAgIGlmIChjLmxlbmd0aCA9PT0gMylcbiAgICAgICAgcmV0dXJuIHRoaXMuX0luc2VydF9vcl9hc3NpZ25fd2l0aF9oaW50KGNbMF0sIGNbMV0sIGNbMl0pO1xuICAgIH0sIGEucHJvdG90eXBlLl9JbnNlcnRfb3JfYXNzaWduX3dpdGhfa2V5X3ZhbHVlID0gZnVuY3Rpb24oYywgbCkge1xuICAgICAgdmFyIGYgPSB0aGlzLmVtcGxhY2UoYywgbCk7XG4gICAgICByZXR1cm4gZi5zZWNvbmQgPT09ICExICYmIChmLmZpcnN0LnNlY29uZCA9IGwpLCBmO1xuICAgIH0sIGEucHJvdG90eXBlLl9JbnNlcnRfb3JfYXNzaWduX3dpdGhfaGludCA9IGZ1bmN0aW9uKGMsIGwsIGYpIHtcbiAgICAgIHZhciB1ID0gdGhpcy5lbXBsYWNlX2hpbnQoYywgbCwgZik7XG4gICAgICByZXR1cm4gdS5zZWNvbmQgIT09IGYgJiYgKHUuc2Vjb25kID0gZiksIHU7XG4gICAgfSwgYS5wcm90b3R5cGUuZXh0cmFjdCA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgIHJldHVybiBjIGluc3RhbmNlb2YgdGhpcy5lbmQoKS5jb25zdHJ1Y3RvciA/IHRoaXMuX0V4dHJhY3RfYnlfaXRlcmF0b3IoYykgOiB0aGlzLl9FeHRyYWN0X2J5X2tleShjKTtcbiAgICB9LCBhLnByb3RvdHlwZS5fRXh0cmFjdF9ieV9rZXkgPSBmdW5jdGlvbihjKSB7XG4gICAgICB2YXIgbCA9IHRoaXMuZmluZChjKTtcbiAgICAgIGlmIChsLmVxdWFscyh0aGlzLmVuZCgpKSA9PT0gITApXG4gICAgICAgIHRocm93IGkuRXJyb3JHZW5lcmF0b3Iua2V5X25vdXRfZm91bmQodGhpcywgXCJleHRyYWN0XCIsIGMpO1xuICAgICAgdmFyIGYgPSBsLnZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXMuX0VyYXNlX2J5X3JhbmdlKGwpLCBmO1xuICAgIH0sIGEucHJvdG90eXBlLl9FeHRyYWN0X2J5X2l0ZXJhdG9yID0gZnVuY3Rpb24oYykge1xuICAgICAgcmV0dXJuIGMuZXF1YWxzKHRoaXMuZW5kKCkpID09PSAhMCA/IHRoaXMuZW5kKCkgOiAodGhpcy5fRXJhc2VfYnlfcmFuZ2UoYyksIGMpO1xuICAgIH0sIGEucHJvdG90eXBlLl9FcmFzZV9ieV9rZXkgPSBmdW5jdGlvbihjKSB7XG4gICAgICB2YXIgbCA9IHRoaXMuZmluZChjKTtcbiAgICAgIHJldHVybiBsLmVxdWFscyh0aGlzLmVuZCgpKSA9PT0gITAgPyAwIDogKHRoaXMuX0VyYXNlX2J5X3JhbmdlKGwpLCAxKTtcbiAgICB9LCBhLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgIGZvciAodmFyIGwgPSBjLmJlZ2luKCk7ICFsLmVxdWFscyhjLmVuZCgpKTsgKVxuICAgICAgICB0aGlzLmhhcyhsLmZpcnN0KSA9PT0gITEgPyAodGhpcy5pbnNlcnQobC52YWx1ZSksIGwgPSBjLmVyYXNlKGwpKSA6IGwgPSBsLm5leHQoKTtcbiAgICB9LCBhO1xuICB9KG4uTWFwQ29udGFpbmVyKTtcbiAgcmV0dXJuIEd0LlVuaXF1ZU1hcCA9IHMsIEd0O1xufVxudmFyIGtuID0ge30sIFJvO1xuZnVuY3Rpb24gaWQoKSB7XG4gIHJldHVybiBSbyB8fCAoUm8gPSAxLCBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGUgPSBTICYmIFMuX19leHRlbmRzIHx8IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGEgPSBmdW5jdGlvbihjLCBsKSB7XG4gICAgICAgIHJldHVybiBhID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24oZiwgdSkge1xuICAgICAgICAgIGYuX19wcm90b19fID0gdTtcbiAgICAgICAgfSB8fCBmdW5jdGlvbihmLCB1KSB7XG4gICAgICAgICAgZm9yICh2YXIgaCBpbiB1KVxuICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHUsIGgpICYmIChmW2hdID0gdVtoXSk7XG4gICAgICAgIH0sIGEoYywgbCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGMsIGwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBsICE9IFwiZnVuY3Rpb25cIiAmJiBsICE9PSBudWxsKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGwpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgYShjLCBsKTtcbiAgICAgICAgZnVuY3Rpb24gZigpIHtcbiAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yID0gYztcbiAgICAgICAgfVxuICAgICAgICBjLnByb3RvdHlwZSA9IGwgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGwpIDogKGYucHJvdG90eXBlID0gbC5wcm90b3R5cGUsIG5ldyBmKCkpO1xuICAgICAgfTtcbiAgICB9KCksIHIgPSBTICYmIFMuX19yZWFkIHx8IGZ1bmN0aW9uKGEsIGMpIHtcbiAgICAgIHZhciBsID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgYVtTeW1ib2wuaXRlcmF0b3JdO1xuICAgICAgaWYgKCFsKVxuICAgICAgICByZXR1cm4gYTtcbiAgICAgIHZhciBmID0gbC5jYWxsKGEpLCB1LCBoID0gW10sIGQ7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKDsgKGMgPT09IHZvaWQgMCB8fCBjLS0gPiAwKSAmJiAhKHUgPSBmLm5leHQoKSkuZG9uZTsgKVxuICAgICAgICAgIGgucHVzaCh1LnZhbHVlKTtcbiAgICAgIH0gY2F0Y2ggKHApIHtcbiAgICAgICAgZCA9IHsgZXJyb3I6IHAgfTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdSAmJiAhdS5kb25lICYmIChsID0gZi5yZXR1cm4pICYmIGwuY2FsbChmKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoZClcbiAgICAgICAgICAgIHRocm93IGQuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBoO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgdC5NYXBFbGVtZW50TGlzdCA9IHZvaWQgMDtcbiAgICB2YXIgbiA9IENhKCksIGkgPSBtaSgpLCBzID0gSWEoKSwgbyA9IGZ1bmN0aW9uKGEpIHtcbiAgICAgIGUoYywgYSk7XG4gICAgICBmdW5jdGlvbiBjKGwpIHtcbiAgICAgICAgdmFyIGYgPSBhLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgcmV0dXJuIGYuYXNzb2NpYXRpdmVfID0gbCwgZjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjLnByb3RvdHlwZS5fQ3JlYXRlX2l0ZXJhdG9yID0gZnVuY3Rpb24obCwgZiwgdSkge1xuICAgICAgICByZXR1cm4gYy5JdGVyYXRvci5jcmVhdGUodGhpcywgbCwgZiwgdSk7XG4gICAgICB9LCBjLl9Td2FwX2Fzc29jaWF0aXZlID0gZnVuY3Rpb24obCwgZikge1xuICAgICAgICB2YXIgdTtcbiAgICAgICAgdSA9IHIoW2YuYXNzb2NpYXRpdmVfLCBsLmFzc29jaWF0aXZlX10sIDIpLCBsLmFzc29jaWF0aXZlXyA9IHVbMF0sIGYuYXNzb2NpYXRpdmVfID0gdVsxXTtcbiAgICAgIH0sIGMucHJvdG90eXBlLmFzc29jaWF0aXZlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFzc29jaWF0aXZlXztcbiAgICAgIH0sIGM7XG4gICAgfShuLkxpc3RDb250YWluZXIpO1xuICAgIHQuTWFwRWxlbWVudExpc3QgPSBvLCBmdW5jdGlvbihhKSB7XG4gICAgICB2YXIgYyA9IGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgZSh1LCBmKTtcbiAgICAgICAgZnVuY3Rpb24gdShoLCBkLCBwLCB5KSB7XG4gICAgICAgICAgdmFyIGcgPSBmLmNhbGwodGhpcywgZCwgcCwgeSkgfHwgdGhpcztcbiAgICAgICAgICByZXR1cm4gZy5saXN0XyA9IGgsIGc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHUuY3JlYXRlID0gZnVuY3Rpb24oaCwgZCwgcCwgeSkge1xuICAgICAgICAgIHJldHVybiBuZXcgdShoLCBkLCBwLCB5KTtcbiAgICAgICAgfSwgdS5wcm90b3R5cGUucmV2ZXJzZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBuZXcgbCh0aGlzKTtcbiAgICAgICAgfSwgdS5wcm90b3R5cGUuc291cmNlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubGlzdF8uYXNzb2NpYXRpdmUoKTtcbiAgICAgICAgfSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHUucHJvdG90eXBlLCBcImZpcnN0XCIsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUuZmlyc3Q7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodS5wcm90b3R5cGUsIFwic2Vjb25kXCIsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUuc2Vjb25kO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiBmdW5jdGlvbihoKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlLnNlY29uZCA9IGg7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0pLCB1O1xuICAgICAgfShpLkxpc3RJdGVyYXRvcik7XG4gICAgICBhLkl0ZXJhdG9yID0gYztcbiAgICAgIHZhciBsID0gZnVuY3Rpb24oZikge1xuICAgICAgICBlKHUsIGYpO1xuICAgICAgICBmdW5jdGlvbiB1KCkge1xuICAgICAgICAgIHJldHVybiBmICE9PSBudWxsICYmIGYuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1LnByb3RvdHlwZS5fQ3JlYXRlX25laWdoYm9yID0gZnVuY3Rpb24oaCkge1xuICAgICAgICAgIHJldHVybiBuZXcgdShoKTtcbiAgICAgICAgfSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHUucHJvdG90eXBlLCBcImZpcnN0XCIsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmFzZV8uZmlyc3Q7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodS5wcm90b3R5cGUsIFwic2Vjb25kXCIsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmFzZV8uc2Vjb25kO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiBmdW5jdGlvbihoKSB7XG4gICAgICAgICAgICB0aGlzLmJhc2VfLnNlY29uZCA9IGg7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0pLCB1O1xuICAgICAgfShzLlJldmVyc2VJdGVyYXRvcik7XG4gICAgICBhLlJldmVyc2VJdGVyYXRvciA9IGw7XG4gICAgfShvID0gdC5NYXBFbGVtZW50TGlzdCB8fCAodC5NYXBFbGVtZW50TGlzdCA9IHt9KSksIHQuTWFwRWxlbWVudExpc3QgPSBvO1xuICB9KGtuKSksIGtuO1xufVxudmFyIFl0ID0ge30sIFRvO1xuZnVuY3Rpb24gb2QoKSB7XG4gIGlmIChUbylcbiAgICByZXR1cm4gWXQ7XG4gIFRvID0gMTtcbiAgdmFyIHQgPSBTICYmIFMuX19leHRlbmRzIHx8IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvID0gZnVuY3Rpb24oYSwgYykge1xuICAgICAgcmV0dXJuIG8gPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbihsLCBmKSB7XG4gICAgICAgIGwuX19wcm90b19fID0gZjtcbiAgICAgIH0gfHwgZnVuY3Rpb24obCwgZikge1xuICAgICAgICBmb3IgKHZhciB1IGluIGYpXG4gICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGYsIHUpICYmIChsW3VdID0gZlt1XSk7XG4gICAgICB9LCBvKGEsIGMpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGEsIGMpIHtcbiAgICAgIGlmICh0eXBlb2YgYyAhPSBcImZ1bmN0aW9uXCIgJiYgYyAhPT0gbnVsbClcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYykgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgbyhhLCBjKTtcbiAgICAgIGZ1bmN0aW9uIGwoKSB7XG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IgPSBhO1xuICAgICAgfVxuICAgICAgYS5wcm90b3R5cGUgPSBjID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShjKSA6IChsLnByb3RvdHlwZSA9IGMucHJvdG90eXBlLCBuZXcgbCgpKTtcbiAgICB9O1xuICB9KCksIGUgPSBTICYmIFMuX19yZWFkIHx8IGZ1bmN0aW9uKG8sIGEpIHtcbiAgICB2YXIgYyA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIWMpXG4gICAgICByZXR1cm4gbztcbiAgICB2YXIgbCA9IGMuY2FsbChvKSwgZiwgdSA9IFtdLCBoO1xuICAgIHRyeSB7XG4gICAgICBmb3IgKDsgKGEgPT09IHZvaWQgMCB8fCBhLS0gPiAwKSAmJiAhKGYgPSBsLm5leHQoKSkuZG9uZTsgKVxuICAgICAgICB1LnB1c2goZi52YWx1ZSk7XG4gICAgfSBjYXRjaCAoZCkge1xuICAgICAgaCA9IHsgZXJyb3I6IGQgfTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZiAmJiAhZi5kb25lICYmIChjID0gbC5yZXR1cm4pICYmIGMuY2FsbChsKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChoKVxuICAgICAgICAgIHRocm93IGguZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1O1xuICB9LCByID0gUyAmJiBTLl9fdmFsdWVzIHx8IGZ1bmN0aW9uKG8pIHtcbiAgICB2YXIgYSA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgYyA9IGEgJiYgb1thXSwgbCA9IDA7XG4gICAgaWYgKGMpXG4gICAgICByZXR1cm4gYy5jYWxsKG8pO1xuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PSBcIm51bWJlclwiKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIG8gJiYgbCA+PSBvLmxlbmd0aCAmJiAobyA9IHZvaWQgMCksIHsgdmFsdWU6IG8gJiYgb1tsKytdLCBkb25lOiAhbyB9O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYSA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFl0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIFl0Lk1hcEhhc2hCdWNrZXRzID0gdm9pZCAwO1xuICB2YXIgbiA9IFJhKCksIGkgPSBmdW5jdGlvbihvKSB7XG4gICAgdChhLCBvKTtcbiAgICBmdW5jdGlvbiBhKGMsIGwsIGYpIHtcbiAgICAgIHZhciB1ID0gby5jYWxsKHRoaXMsIHMsIGwpIHx8IHRoaXM7XG4gICAgICByZXR1cm4gdS5zb3VyY2VfID0gYywgdS5rZXlfZXFfID0gZiwgdTtcbiAgICB9XG4gICAgcmV0dXJuIGEuX1N3YXBfc291cmNlID0gZnVuY3Rpb24oYywgbCkge1xuICAgICAgdmFyIGY7XG4gICAgICBmID0gZShbbC5zb3VyY2VfLCBjLnNvdXJjZV9dLCAyKSwgYy5zb3VyY2VfID0gZlswXSwgbC5zb3VyY2VfID0gZlsxXTtcbiAgICB9LCBhLnByb3RvdHlwZS5rZXlfZXEgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmtleV9lcV87XG4gICAgfSwgYS5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgIHZhciBsLCBmLCB1ID0gdGhpcy5oYXNoX2Z1bmN0aW9uKCkoYykgJSB0aGlzLmxlbmd0aCgpLCBoID0gdGhpcy5hdCh1KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIGQgPSByKGgpLCBwID0gZC5uZXh0KCk7ICFwLmRvbmU7IHAgPSBkLm5leHQoKSkge1xuICAgICAgICAgIHZhciB5ID0gcC52YWx1ZTtcbiAgICAgICAgICBpZiAodGhpcy5rZXlfZXFfKHkuZmlyc3QsIGMpKVxuICAgICAgICAgICAgcmV0dXJuIHk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGcpIHtcbiAgICAgICAgbCA9IHsgZXJyb3I6IGcgfTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcCAmJiAhcC5kb25lICYmIChmID0gZC5yZXR1cm4pICYmIGYuY2FsbChkKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAobClcbiAgICAgICAgICAgIHRocm93IGwuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnNvdXJjZV8uZW5kKCk7XG4gICAgfSwgYTtcbiAgfShuLkhhc2hCdWNrZXRzKTtcbiAgWXQuTWFwSGFzaEJ1Y2tldHMgPSBpO1xuICBmdW5jdGlvbiBzKG8pIHtcbiAgICByZXR1cm4gby5maXJzdDtcbiAgfVxuICByZXR1cm4gWXQ7XG59XG52YXIgSnQgPSB7fSwgUG87XG5mdW5jdGlvbiBzZCgpIHtcbiAgaWYgKFBvKVxuICAgIHJldHVybiBKdDtcbiAgUG8gPSAxLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoSnQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgSnQuRW50cnkgPSB2b2lkIDA7XG4gIHZhciB0ID0gd2koKSwgZSA9IF9pKCksIHIgPSBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBuKGksIHMpIHtcbiAgICAgIHRoaXMuZmlyc3QgPSBpLCB0aGlzLnNlY29uZCA9IHM7XG4gICAgfVxuICAgIHJldHVybiBuLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gKDAsIGUuZXF1YWxfdG8pKHRoaXMuZmlyc3QsIGkuZmlyc3QpO1xuICAgIH0sIG4ucHJvdG90eXBlLmxlc3MgPSBmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gKDAsIGUubGVzcykodGhpcy5maXJzdCwgaS5maXJzdCk7XG4gICAgfSwgbi5wcm90b3R5cGUuaGFzaENvZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAoMCwgdC5oYXNoKSh0aGlzLmZpcnN0KTtcbiAgICB9LCBuO1xuICB9KCk7XG4gIHJldHVybiBKdC5FbnRyeSA9IHIsIEp0O1xufVxudmFyIEJvO1xuZnVuY3Rpb24gYWQoKSB7XG4gIHJldHVybiBCbyB8fCAoQm8gPSAxLCBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGUgPSBTICYmIFMuX19leHRlbmRzIHx8IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHUgPSBmdW5jdGlvbihoLCBkKSB7XG4gICAgICAgIHJldHVybiB1ID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24ocCwgeSkge1xuICAgICAgICAgIHAuX19wcm90b19fID0geTtcbiAgICAgICAgfSB8fCBmdW5jdGlvbihwLCB5KSB7XG4gICAgICAgICAgZm9yICh2YXIgZyBpbiB5KVxuICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHksIGcpICYmIChwW2ddID0geVtnXSk7XG4gICAgICAgIH0sIHUoaCwgZCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGgsIGQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkICE9IFwiZnVuY3Rpb25cIiAmJiBkICE9PSBudWxsKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGQpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgdShoLCBkKTtcbiAgICAgICAgZnVuY3Rpb24gcCgpIHtcbiAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yID0gaDtcbiAgICAgICAgfVxuICAgICAgICBoLnByb3RvdHlwZSA9IGQgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGQpIDogKHAucHJvdG90eXBlID0gZC5wcm90b3R5cGUsIG5ldyBwKCkpO1xuICAgICAgfTtcbiAgICB9KCksIHIgPSBTICYmIFMuX19yZWFkIHx8IGZ1bmN0aW9uKHUsIGgpIHtcbiAgICAgIHZhciBkID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgdVtTeW1ib2wuaXRlcmF0b3JdO1xuICAgICAgaWYgKCFkKVxuICAgICAgICByZXR1cm4gdTtcbiAgICAgIHZhciBwID0gZC5jYWxsKHUpLCB5LCBnID0gW10sIHY7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKDsgKGggPT09IHZvaWQgMCB8fCBoLS0gPiAwKSAmJiAhKHkgPSBwLm5leHQoKSkuZG9uZTsgKVxuICAgICAgICAgIGcucHVzaCh5LnZhbHVlKTtcbiAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgdiA9IHsgZXJyb3I6IF8gfTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgeSAmJiAheS5kb25lICYmIChkID0gcC5yZXR1cm4pICYmIGQuY2FsbChwKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAodilcbiAgICAgICAgICAgIHRocm93IHYuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBnO1xuICAgIH0sIG4gPSBTICYmIFMuX19zcHJlYWRBcnJheSB8fCBmdW5jdGlvbih1LCBoLCBkKSB7XG4gICAgICBpZiAoZCB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKVxuICAgICAgICBmb3IgKHZhciBwID0gMCwgeSA9IGgubGVuZ3RoLCBnOyBwIDwgeTsgcCsrKVxuICAgICAgICAgIChnIHx8ICEocCBpbiBoKSkgJiYgKGcgfHwgKGcgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChoLCAwLCBwKSksIGdbcF0gPSBoW3BdKTtcbiAgICAgIHJldHVybiB1LmNvbmNhdChnIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGgpKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIHQuSGFzaE1hcCA9IHZvaWQgMDtcbiAgICB2YXIgaSA9IG5kKCksIHMgPSBBYSgpLCBvID0gaWQoKSwgYSA9IG9kKCksIGMgPSBzZCgpLCBsID0gVGEoKSwgZiA9IGZ1bmN0aW9uKHUpIHtcbiAgICAgIGUoaCwgdSk7XG4gICAgICBmdW5jdGlvbiBoKCkge1xuICAgICAgICBmb3IgKHZhciBkID0gW10sIHAgPSAwOyBwIDwgYXJndW1lbnRzLmxlbmd0aDsgcCsrKVxuICAgICAgICAgIGRbcF0gPSBhcmd1bWVudHNbcF07XG4gICAgICAgIHZhciB5ID0gdS5jYWxsKHRoaXMsIGZ1bmN0aW9uKGcpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IG8uTWFwRWxlbWVudExpc3QoZyk7XG4gICAgICAgIH0pIHx8IHRoaXM7XG4gICAgICAgIHJldHVybiBzLklIYXNoQ29udGFpbmVyLmNvbnN0cnVjdC5hcHBseShzLklIYXNoQ29udGFpbmVyLCBuKFtcbiAgICAgICAgICB5LFxuICAgICAgICAgIGgsXG4gICAgICAgICAgZnVuY3Rpb24oZywgdikge1xuICAgICAgICAgICAgeS5idWNrZXRzXyA9IG5ldyBhLk1hcEhhc2hCdWNrZXRzKHksIGcsIHYpO1xuICAgICAgICAgIH1cbiAgICAgICAgXSwgcihkKSwgITEpKSwgeTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmJ1Y2tldHNfLmNsZWFyKCksIHUucHJvdG90eXBlLmNsZWFyLmNhbGwodGhpcyk7XG4gICAgICB9LCBoLnByb3RvdHlwZS5zd2FwID0gZnVuY3Rpb24oZCkge1xuICAgICAgICB2YXIgcCwgeTtcbiAgICAgICAgcCA9IHIoW2QuZGF0YV8sIHRoaXMuZGF0YV9dLCAyKSwgdGhpcy5kYXRhXyA9IHBbMF0sIGQuZGF0YV8gPSBwWzFdLCBvLk1hcEVsZW1lbnRMaXN0Ll9Td2FwX2Fzc29jaWF0aXZlKHRoaXMuZGF0YV8sIGQuZGF0YV8pLCBhLk1hcEhhc2hCdWNrZXRzLl9Td2FwX3NvdXJjZSh0aGlzLmJ1Y2tldHNfLCBkLmJ1Y2tldHNfKSwgeSA9IHIoW2QuYnVja2V0c18sIHRoaXMuYnVja2V0c19dLCAyKSwgdGhpcy5idWNrZXRzXyA9IHlbMF0sIGQuYnVja2V0c18gPSB5WzFdO1xuICAgICAgfSwgaC5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVja2V0c18uZmluZChkKTtcbiAgICAgIH0sIGgucHJvdG90eXBlLmJlZ2luID0gZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4gZCA9PT0gdm9pZCAwICYmIChkID0gbnVsbCksIGQgPT09IG51bGwgPyB1LnByb3RvdHlwZS5iZWdpbi5jYWxsKHRoaXMpIDogdGhpcy5idWNrZXRzXy5hdChkKVswXTtcbiAgICAgIH0sIGgucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgaWYgKGQgPT09IHZvaWQgMCAmJiAoZCA9IG51bGwpLCBkID09PSBudWxsKVxuICAgICAgICAgIHJldHVybiB1LnByb3RvdHlwZS5lbmQuY2FsbCh0aGlzKTtcbiAgICAgICAgdmFyIHAgPSB0aGlzLmJ1Y2tldHNfLmF0KGQpO1xuICAgICAgICByZXR1cm4gcFtwLmxlbmd0aCAtIDFdLm5leHQoKTtcbiAgICAgIH0sIGgucHJvdG90eXBlLnJiZWdpbiA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgcmV0dXJuIGQgPT09IHZvaWQgMCAmJiAoZCA9IG51bGwpLCB0aGlzLmVuZChkKS5yZXZlcnNlKCk7XG4gICAgICB9LCBoLnByb3RvdHlwZS5yZW5kID0gZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4gZCA9PT0gdm9pZCAwICYmIChkID0gbnVsbCksIHRoaXMuYmVnaW4oZCkucmV2ZXJzZSgpO1xuICAgICAgfSwgaC5wcm90b3R5cGUuYnVja2V0X2NvdW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1Y2tldHNfLmxlbmd0aCgpO1xuICAgICAgfSwgaC5wcm90b3R5cGUuYnVja2V0X3NpemUgPSBmdW5jdGlvbihkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1Y2tldHNfLmF0KGQpLmxlbmd0aDtcbiAgICAgIH0sIGgucHJvdG90eXBlLmxvYWRfZmFjdG9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1Y2tldHNfLmxvYWRfZmFjdG9yKCk7XG4gICAgICB9LCBoLnByb3RvdHlwZS5oYXNoX2Z1bmN0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1Y2tldHNfLmhhc2hfZnVuY3Rpb24oKTtcbiAgICAgIH0sIGgucHJvdG90eXBlLmtleV9lcSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWNrZXRzXy5rZXlfZXEoKTtcbiAgICAgIH0sIGgucHJvdG90eXBlLmJ1Y2tldCA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzaF9mdW5jdGlvbigpKGQpICUgdGhpcy5idWNrZXRzXy5sZW5ndGgoKTtcbiAgICAgIH0sIGgucHJvdG90eXBlLm1heF9sb2FkX2ZhY3RvciA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgcmV0dXJuIGQgPT09IHZvaWQgMCAmJiAoZCA9IG51bGwpLCB0aGlzLmJ1Y2tldHNfLm1heF9sb2FkX2ZhY3RvcihkKTtcbiAgICAgIH0sIGgucHJvdG90eXBlLnJlc2VydmUgPSBmdW5jdGlvbihkKSB7XG4gICAgICAgIHRoaXMuYnVja2V0c18ucmVzZXJ2ZShkKTtcbiAgICAgIH0sIGgucHJvdG90eXBlLnJlaGFzaCA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgdGhpcy5idWNrZXRzXy5yZWhhc2goZCk7XG4gICAgICB9LCBoLnByb3RvdHlwZS5lbXBsYWNlID0gZnVuY3Rpb24oZCwgcCkge1xuICAgICAgICB2YXIgeSA9IHRoaXMuZmluZChkKTtcbiAgICAgICAgcmV0dXJuIHkuZXF1YWxzKHRoaXMuZW5kKCkpID09PSAhMSA/IG5ldyBsLlBhaXIoeSwgITEpIDogKHRoaXMuZGF0YV8ucHVzaChuZXcgYy5FbnRyeShkLCBwKSksIHkgPSB5LnByZXYoKSwgdGhpcy5fSGFuZGxlX2luc2VydCh5LCB5Lm5leHQoKSksIG5ldyBsLlBhaXIoeSwgITApKTtcbiAgICAgIH0sIGgucHJvdG90eXBlLmVtcGxhY2VfaGludCA9IGZ1bmN0aW9uKGQsIHAsIHkpIHtcbiAgICAgICAgdmFyIGcgPSB0aGlzLmZpbmQocCk7XG4gICAgICAgIHJldHVybiBnLmVxdWFscyh0aGlzLmVuZCgpKSA9PT0gITAgJiYgKGcgPSB0aGlzLmRhdGFfLmluc2VydChkLCBuZXcgYy5FbnRyeShwLCB5KSksIHRoaXMuX0hhbmRsZV9pbnNlcnQoZywgZy5uZXh0KCkpKSwgZztcbiAgICAgIH0sIGgucHJvdG90eXBlLl9IYW5kbGVfaW5zZXJ0ID0gZnVuY3Rpb24oZCwgcCkge1xuICAgICAgICBmb3IgKDsgIWQuZXF1YWxzKHApOyBkID0gZC5uZXh0KCkpXG4gICAgICAgICAgdGhpcy5idWNrZXRzXy5pbnNlcnQoZCk7XG4gICAgICB9LCBoLnByb3RvdHlwZS5fSGFuZGxlX2VyYXNlID0gZnVuY3Rpb24oZCwgcCkge1xuICAgICAgICBmb3IgKDsgIWQuZXF1YWxzKHApOyBkID0gZC5uZXh0KCkpXG4gICAgICAgICAgdGhpcy5idWNrZXRzXy5lcmFzZShkKTtcbiAgICAgIH0sIGg7XG4gICAgfShpLlVuaXF1ZU1hcCk7XG4gICAgdC5IYXNoTWFwID0gZiwgZnVuY3Rpb24odSkge1xuICAgICAgdS5JdGVyYXRvciA9IG8uTWFwRWxlbWVudExpc3QuSXRlcmF0b3IsIHUuUmV2ZXJzZUl0ZXJhdG9yID0gby5NYXBFbGVtZW50TGlzdC5SZXZlcnNlSXRlcmF0b3I7XG4gICAgfShmID0gdC5IYXNoTWFwIHx8ICh0Lkhhc2hNYXAgPSB7fSkpLCB0Lkhhc2hNYXAgPSBmO1xuICB9KEVuKSksIEVuO1xufVxudmFyIExvO1xuZnVuY3Rpb24gY2QoKSB7XG4gIGlmIChMbylcbiAgICByZXR1cm4gX3I7XG4gIExvID0gMTtcbiAgdmFyIHQgPSBTICYmIFMuX192YWx1ZXMgfHwgZnVuY3Rpb24oaSkge1xuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgaVtTeW1ib2wuaXRlcmF0b3JdLCBvID0gMDtcbiAgICByZXR1cm4gcyA/IHMuY2FsbChpKSA6IHtcbiAgICAgIG5leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaSAmJiBvID49IGkubGVuZ3RoICYmIChpID0gdm9pZCAwKSwgeyB2YWx1ZTogaSAmJiBpW28rK10sIGRvbmU6ICFpIH07XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9yLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG4gIHZhciBlID0gdGQoKSwgciA9IGFkKCksIG4gPSBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBpKCkge1xuICAgICAgdGhpcy5saXN0ZW5lcnNfID0gbmV3IHIuSGFzaE1hcCgpLCB0aGlzLmNyZWF0ZWRfYXRfID0gbmV3IERhdGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIGkucHJvdG90eXBlLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbihzKSB7XG4gICAgICB2YXIgbywgYSwgYyA9IHRoaXMubGlzdGVuZXJzXy5maW5kKHMudHlwZSk7XG4gICAgICBpZiAoIWMuZXF1YWxzKHRoaXMubGlzdGVuZXJzXy5lbmQoKSkpIHtcbiAgICAgICAgcy50YXJnZXQgPSB0aGlzLCBzLnRpbWVTdGFtcCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gdGhpcy5jcmVhdGVkX2F0Xy5nZXRUaW1lKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yICh2YXIgbCA9IHQoYy5zZWNvbmQpLCBmID0gbC5uZXh0KCk7ICFmLmRvbmU7IGYgPSBsLm5leHQoKSkge1xuICAgICAgICAgICAgdmFyIHUgPSBmLnZhbHVlO1xuICAgICAgICAgICAgdShzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGgpIHtcbiAgICAgICAgICBvID0geyBlcnJvcjogaCB9O1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmICYmICFmLmRvbmUgJiYgKGEgPSBsLnJldHVybikgJiYgYS5jYWxsKGwpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpZiAobylcbiAgICAgICAgICAgICAgdGhyb3cgby5lcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBpLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24ocywgbykge1xuICAgICAgdmFyIGEgPSB0aGlzLmxpc3RlbmVyc18uZmluZChzKTtcbiAgICAgIGEuZXF1YWxzKHRoaXMubGlzdGVuZXJzXy5lbmQoKSkgJiYgKGEgPSB0aGlzLmxpc3RlbmVyc18uZW1wbGFjZShzLCBuZXcgZS5IYXNoU2V0KCkpLmZpcnN0KSwgYS5zZWNvbmQuaW5zZXJ0KG8pO1xuICAgIH0sIGkucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihzLCBvKSB7XG4gICAgICB2YXIgYSA9IHRoaXMubGlzdGVuZXJzXy5maW5kKHMpO1xuICAgICAgYS5lcXVhbHModGhpcy5saXN0ZW5lcnNfLmVuZCgpKSB8fCAoYS5zZWNvbmQuZXJhc2UobyksIGEuc2Vjb25kLmVtcHR5KCkgJiYgdGhpcy5saXN0ZW5lcnNfLmVyYXNlKGEpKTtcbiAgICB9LCBpO1xuICB9KCk7XG4gIHJldHVybiBfci5FdmVudFRhcmdldCA9IG4sIF9yO1xufVxudmFyIG1yID0ge30sICRvO1xuZnVuY3Rpb24gVnIoKSB7XG4gIGlmICgkbylcbiAgICByZXR1cm4gbXI7XG4gICRvID0gMSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1yLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG4gIHZhciB0ID0gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gZShyLCBuKSB7XG4gICAgICB0aGlzLnR5cGUgPSByLCBuICYmIE9iamVjdC5hc3NpZ24odGhpcywgbik7XG4gICAgfVxuICAgIHJldHVybiBlO1xuICB9KCk7XG4gIHJldHVybiBtci5FdmVudCA9IHQsIG1yO1xufVxudmFyIHhyID0ge30sIHFvO1xuZnVuY3Rpb24gdWQoKSB7XG4gIGlmIChxbylcbiAgICByZXR1cm4geHI7XG4gIHFvID0gMTtcbiAgdmFyIHQgPSBTICYmIFMuX19leHRlbmRzIHx8IGZ1bmN0aW9uKCkge1xuICAgIHZhciBuID0gZnVuY3Rpb24oaSwgcykge1xuICAgICAgcmV0dXJuIG4gPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbihvLCBhKSB7XG4gICAgICAgIG8uX19wcm90b19fID0gYTtcbiAgICAgIH0gfHwgZnVuY3Rpb24obywgYSkge1xuICAgICAgICBmb3IgKHZhciBjIGluIGEpXG4gICAgICAgICAgYS5oYXNPd25Qcm9wZXJ0eShjKSAmJiAob1tjXSA9IGFbY10pO1xuICAgICAgfSwgbihpLCBzKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbihpLCBzKSB7XG4gICAgICBuKGksIHMpO1xuICAgICAgZnVuY3Rpb24gbygpIHtcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IGk7XG4gICAgICB9XG4gICAgICBpLnByb3RvdHlwZSA9IHMgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKHMpIDogKG8ucHJvdG90eXBlID0gcy5wcm90b3R5cGUsIG5ldyBvKCkpO1xuICAgIH07XG4gIH0oKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHhyLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG4gIHZhciBlID0gVnIoKSwgciA9IGZ1bmN0aW9uKG4pIHtcbiAgICB0KGksIG4pO1xuICAgIGZ1bmN0aW9uIGkocywgbykge1xuICAgICAgcmV0dXJuIG4uY2FsbCh0aGlzLCBzLCBvKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gaTtcbiAgfShlLkV2ZW50KTtcbiAgcmV0dXJuIHhyLkNsb3NlRXZlbnQgPSByLCB4cjtcbn1cbnZhciBFciA9IHt9LCBObztcbmZ1bmN0aW9uIGxkKCkge1xuICBpZiAoTm8pXG4gICAgcmV0dXJuIEVyO1xuICBObyA9IDE7XG4gIHZhciB0ID0gUyAmJiBTLl9fZXh0ZW5kcyB8fCBmdW5jdGlvbigpIHtcbiAgICB2YXIgbiA9IGZ1bmN0aW9uKGksIHMpIHtcbiAgICAgIHJldHVybiBuID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24obywgYSkge1xuICAgICAgICBvLl9fcHJvdG9fXyA9IGE7XG4gICAgICB9IHx8IGZ1bmN0aW9uKG8sIGEpIHtcbiAgICAgICAgZm9yICh2YXIgYyBpbiBhKVxuICAgICAgICAgIGEuaGFzT3duUHJvcGVydHkoYykgJiYgKG9bY10gPSBhW2NdKTtcbiAgICAgIH0sIG4oaSwgcyk7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24oaSwgcykge1xuICAgICAgbihpLCBzKTtcbiAgICAgIGZ1bmN0aW9uIG8oKSB7XG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IgPSBpO1xuICAgICAgfVxuICAgICAgaS5wcm90b3R5cGUgPSBzID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShzKSA6IChvLnByb3RvdHlwZSA9IHMucHJvdG90eXBlLCBuZXcgbygpKTtcbiAgICB9O1xuICB9KCk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFciwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuICB2YXIgZSA9IFZyKCksIHIgPSBmdW5jdGlvbihuKSB7XG4gICAgdChpLCBuKTtcbiAgICBmdW5jdGlvbiBpKHMsIG8pIHtcbiAgICAgIHJldHVybiBuLmNhbGwodGhpcywgcywgbykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIGk7XG4gIH0oZS5FdmVudCk7XG4gIHJldHVybiBFci5NZXNzYWdlRXZlbnQgPSByLCBFcjtcbn1cbnZhciBrciA9IHt9LCBVbztcbmZ1bmN0aW9uIGZkKCkge1xuICBpZiAoVW8pXG4gICAgcmV0dXJuIGtyO1xuICBVbyA9IDE7XG4gIHZhciB0ID0gUyAmJiBTLl9fZXh0ZW5kcyB8fCBmdW5jdGlvbigpIHtcbiAgICB2YXIgbiA9IGZ1bmN0aW9uKGksIHMpIHtcbiAgICAgIHJldHVybiBuID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24obywgYSkge1xuICAgICAgICBvLl9fcHJvdG9fXyA9IGE7XG4gICAgICB9IHx8IGZ1bmN0aW9uKG8sIGEpIHtcbiAgICAgICAgZm9yICh2YXIgYyBpbiBhKVxuICAgICAgICAgIGEuaGFzT3duUHJvcGVydHkoYykgJiYgKG9bY10gPSBhW2NdKTtcbiAgICAgIH0sIG4oaSwgcyk7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24oaSwgcykge1xuICAgICAgbihpLCBzKTtcbiAgICAgIGZ1bmN0aW9uIG8oKSB7XG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IgPSBpO1xuICAgICAgfVxuICAgICAgaS5wcm90b3R5cGUgPSBzID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShzKSA6IChvLnByb3RvdHlwZSA9IHMucHJvdG90eXBlLCBuZXcgbygpKTtcbiAgICB9O1xuICB9KCk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShrciwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuICB2YXIgZSA9IFZyKCksIHIgPSBmdW5jdGlvbihuKSB7XG4gICAgdChpLCBuKTtcbiAgICBmdW5jdGlvbiBpKHMsIG8pIHtcbiAgICAgIHJldHVybiBuLmNhbGwodGhpcywgcywgbykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIGk7XG4gIH0oZS5FdmVudCk7XG4gIHJldHVybiBrci5FcnJvckV2ZW50ID0gciwga3I7XG59XG52YXIgam87XG5mdW5jdGlvbiBoZCgpIHtcbiAgcmV0dXJuIGpvIHx8IChqbyA9IDEsIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSA9IFMgJiYgUy5fX2V4dGVuZHMgfHwgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdSA9IGZ1bmN0aW9uKGgsIGQpIHtcbiAgICAgICAgcmV0dXJuIHUgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbihwLCB5KSB7XG4gICAgICAgICAgcC5fX3Byb3RvX18gPSB5O1xuICAgICAgICB9IHx8IGZ1bmN0aW9uKHAsIHkpIHtcbiAgICAgICAgICBmb3IgKHZhciBnIGluIHkpXG4gICAgICAgICAgICB5Lmhhc093blByb3BlcnR5KGcpICYmIChwW2ddID0geVtnXSk7XG4gICAgICAgIH0sIHUoaCwgZCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGgsIGQpIHtcbiAgICAgICAgdShoLCBkKTtcbiAgICAgICAgZnVuY3Rpb24gcCgpIHtcbiAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yID0gaDtcbiAgICAgICAgfVxuICAgICAgICBoLnByb3RvdHlwZSA9IGQgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGQpIDogKHAucHJvdG90eXBlID0gZC5wcm90b3R5cGUsIG5ldyBwKCkpO1xuICAgICAgfTtcbiAgICB9KCksIHIgPSBTICYmIFMuX19hc3NpZ24gfHwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gciA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odSkge1xuICAgICAgICBmb3IgKHZhciBoLCBkID0gMSwgcCA9IGFyZ3VtZW50cy5sZW5ndGg7IGQgPCBwOyBkKyspIHtcbiAgICAgICAgICBoID0gYXJndW1lbnRzW2RdO1xuICAgICAgICAgIGZvciAodmFyIHkgaW4gaClcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChoLCB5KSAmJiAodVt5XSA9IGhbeV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1O1xuICAgICAgfSwgci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbiAgICB2YXIgbiA9IHpoKCksIGkgPSBjZCgpLCBzID0gVnIoKSwgbyA9IHVkKCksIGEgPSBsZCgpLCBjID0gZmQoKSwgbCA9IGZ1bmN0aW9uKHUpIHtcbiAgICAgIGUoaCwgdSk7XG4gICAgICBmdW5jdGlvbiBoKGQsIHApIHtcbiAgICAgICAgdmFyIHkgPSB1LmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgcmV0dXJuIHkub25fID0ge30sIHkuc3RhdGVfID0gaC5DT05ORUNUSU5HLCB5LmNsaWVudF8gPSBuZXcgbi5jbGllbnQoKSwgeS5jbGllbnRfLm9uKFwiY29ubmVjdFwiLCB5Ll9IYW5kbGVfY29ubmVjdC5iaW5kKHkpKSwgeS5jbGllbnRfLm9uKFwiY29ubmVjdEZhaWxlZFwiLCB5Ll9IYW5kbGVfZXJyb3IuYmluZCh5KSksIHR5cGVvZiBwID09IFwic3RyaW5nXCIgJiYgKHAgPSBbcF0pLCB5LmNsaWVudF8uY29ubmVjdChkLCBwKSwgeTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKGQsIHApIHtcbiAgICAgICAgdGhpcy5zdGF0ZV8gPSBoLkNMT1NJTkcsIGQgPT09IHZvaWQgMCA/IHRoaXMuY29ubmVjdGlvbl8uc2VuZENsb3NlRnJhbWUoKSA6IHRoaXMuY29ubmVjdGlvbl8uc2VuZENsb3NlRnJhbWUoZCwgcCwgITApO1xuICAgICAgfSwgaC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkLnZhbHVlT2YoKSA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgIHRoaXMuY29ubmVjdGlvbl8uc2VuZFVURihkKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIHAgPSB2b2lkIDA7XG4gICAgICAgICAgZCBpbnN0YW5jZW9mIEJ1ZmZlciA/IHAgPSBkIDogZCBpbnN0YW5jZW9mIEJsb2IgPyBwID0gbmV3IEJ1ZmZlcihkLCBcImJsb2JcIikgOiBkLmJ1ZmZlciA/IHAgPSBuZXcgQnVmZmVyKGQuYnVmZmVyKSA6IHAgPSBuZXcgQnVmZmVyKGQpLCB0aGlzLmNvbm5lY3Rpb25fLnNlbmRCeXRlcyhwKTtcbiAgICAgICAgfVxuICAgICAgfSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGgucHJvdG90eXBlLCBcInVybFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50Xy51cmwuaHJlZjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoaC5wcm90b3R5cGUsIFwicHJvdG9jb2xcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNsaWVudF8ucHJvdG9jb2xzID8gdGhpcy5jbGllbnRfLnByb3RvY29sc1swXSA6IFwiXCI7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGgucHJvdG90eXBlLCBcImV4dGVuc2lvbnNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb25fICYmIHRoaXMuY29ubmVjdGlvbl8uZXh0ZW5zaW9ucyA/IHRoaXMuY29ubmVjdGlvbl8uZXh0ZW5zaW9uc1swXS5uYW1lIDogXCJcIjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoaC5wcm90b3R5cGUsIFwicmVhZHlTdGF0ZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVfO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShoLnByb3RvdHlwZSwgXCJidWZmZXJlZEFtb3VudFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbl8uYnl0ZXNXYWl0aW5nVG9GbHVzaDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoaC5wcm90b3R5cGUsIFwiYmluYXJ5VHlwZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIFwiYXJyYXlidWZmZXJcIjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoaC5wcm90b3R5cGUsIFwib25vcGVuXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5vbl8ub3BlbjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgdGhpcy5fU2V0X29uKFwib3BlblwiLCBkKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoaC5wcm90b3R5cGUsIFwib25jbG9zZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMub25fLmNsb3NlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICB0aGlzLl9TZXRfb24oXCJjbG9zZVwiLCBkKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoaC5wcm90b3R5cGUsIFwib25tZXNzYWdlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5vbl8ubWVzc2FnZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgdGhpcy5fU2V0X29uKFwibWVzc2FnZVwiLCBkKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoaC5wcm90b3R5cGUsIFwib25lcnJvclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMub25fLmVycm9yO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICB0aGlzLl9TZXRfb24oXCJlcnJvclwiLCBkKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgIH0pLCBoLnByb3RvdHlwZS5fU2V0X29uID0gZnVuY3Rpb24oZCwgcCkge1xuICAgICAgICB0aGlzLm9uX1tkXSAmJiB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoZCwgdGhpcy5vbl9bZF0pLCB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoZCwgcCksIHRoaXMub25fW2RdID0gcDtcbiAgICAgIH0sIGgucHJvdG90eXBlLl9IYW5kbGVfY29ubmVjdCA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uXyA9IGQsIHRoaXMuc3RhdGVfID0gaC5PUEVOLCB0aGlzLmNvbm5lY3Rpb25fLm9uKFwibWVzc2FnZVwiLCB0aGlzLl9IYW5kbGVfbWVzc2FnZS5iaW5kKHRoaXMpKSwgdGhpcy5jb25uZWN0aW9uXy5vbihcImVycm9yXCIsIHRoaXMuX0hhbmRsZV9lcnJvci5iaW5kKHRoaXMpKSwgdGhpcy5jb25uZWN0aW9uXy5vbihcImNsb3NlXCIsIHRoaXMuX0hhbmRsZV9jbG9zZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgdmFyIHAgPSBuZXcgcy5FdmVudChcIm9wZW5cIiwgZik7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChwKTtcbiAgICAgIH0sIGgucHJvdG90eXBlLl9IYW5kbGVfY2xvc2UgPSBmdW5jdGlvbihkLCBwKSB7XG4gICAgICAgIHZhciB5ID0gbmV3IG8uQ2xvc2VFdmVudChcImNsb3NlXCIsIHIoe30sIGYsIHsgY29kZTogZCwgcmVhc29uOiBwIH0pKTtcbiAgICAgICAgdGhpcy5zdGF0ZV8gPSBoLkNMT1NFRCwgdGhpcy5kaXNwYXRjaEV2ZW50KHkpO1xuICAgICAgfSwgaC5wcm90b3R5cGUuX0hhbmRsZV9tZXNzYWdlID0gZnVuY3Rpb24oZCkge1xuICAgICAgICB2YXIgcCA9IG5ldyBhLk1lc3NhZ2VFdmVudChcIm1lc3NhZ2VcIiwgcih7fSwgZiwgeyBkYXRhOiBkLmJpbmFyeURhdGEgPyBkLmJpbmFyeURhdGEgOiBkLnV0ZjhEYXRhIH0pKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHApO1xuICAgICAgfSwgaC5wcm90b3R5cGUuX0hhbmRsZV9lcnJvciA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgdmFyIHAgPSBuZXcgYy5FcnJvckV2ZW50KFwiZXJyb3JcIiwgcih7fSwgZiwgeyBlcnJvcjogZCwgbWVzc2FnZTogZC5tZXNzYWdlIH0pKTtcbiAgICAgICAgdGhpcy5zdGF0ZV8gPT09IGguQ09OTkVDVElORyAmJiAodGhpcy5zdGF0ZV8gPSBoLkNMT1NFRCksIHRoaXMuZGlzcGF0Y2hFdmVudChwKTtcbiAgICAgIH0sIGg7XG4gICAgfShpLkV2ZW50VGFyZ2V0KTtcbiAgICB0LldlYlNvY2tldCA9IGwsIGZ1bmN0aW9uKHUpIHtcbiAgICAgIHUuQ09OTkVDVElORyA9IDAsIHUuT1BFTiA9IDEsIHUuQ0xPU0lORyA9IDIsIHUuQ0xPU0VEID0gMztcbiAgICB9KGwgPSB0LldlYlNvY2tldCB8fCAodC5XZWJTb2NrZXQgPSB7fSkpLCB0LldlYlNvY2tldCA9IGw7XG4gICAgdmFyIGYgPSB7XG4gICAgICBidWJibGVzOiAhMSxcbiAgICAgIGNhbmNlbGFibGU6ICExXG4gICAgfTtcbiAgfShwbikpLCBwbjtcbn1cbnZhciBkZCA9IGNyO1xuZGQuaXNfbm9kZSgpICYmIChTLldlYlNvY2tldCA9IGhkKCkuV2ViU29ja2V0KTtcbkJpZ0ludCgxZTMpLCBCaWdJbnQoMWU2KSwgQmlnSW50KDFlOSksIEJpZ0ludCgxZTEyKTtcbkJpZ0ludChcIjIxMDAwMDAwMDAwMDAwMDAwMDBcIik7XG5CaWdJbnQoMWUxMSk7XG5jb25zdCBIbyA9IHtcbiAgcGF5bWVudF9oYXNoOiAxLFxuICBwYXltZW50X3NlY3JldDogMTYsXG4gIGRlc2NyaXB0aW9uOiAxMyxcbiAgcGF5ZWU6IDE5LFxuICBkZXNjcmlwdGlvbl9oYXNoOiAyMyxcbiAgZXhwaXJ5OiA2LFxuICBtaW5fZmluYWxfY2x0dl9leHBpcnk6IDI0LFxuICBmYWxsYmFja19hZGRyZXNzOiA5LFxuICByb3V0ZV9oaW50OiAzLFxuICBmZWF0dXJlX2JpdHM6IDUsXG4gIG1ldGFkYXRhOiAyN1xufTtcbmZvciAobGV0IHQgPSAwLCBlID0gT2JqZWN0LmtleXMoSG8pOyB0IDwgZS5sZW5ndGg7IHQrKylcbiAgZVt0XSwgSG9bZVt0XV0udG9TdHJpbmcoKTtcbmZ1bmN0aW9uIHBkKHQsIGUpIHtcbiAgcmV0dXJuIHQuY3JlYXRlZF9hdCA+IGUuY3JlYXRlZF9hdCA/IHQgOiBlO1xufVxudmFyIHlkID0gW1xuICBcIndzczovL25vcy5sb2xcIixcbiAgXCJ3c3M6Ly9yZWxheS5ub3N0ci5iYW5kXCIsXG4gIFwid3NzOi8vcmVsYXkuZjd6LmlvXCIsXG4gIFwid3NzOi8vcmVsYXkuZGFtdXMuaW9cIixcbiAgXCJ3c3M6Ly9ub3N0ci5tb21cIixcbiAgXCJ3c3M6Ly9uby5zdHIuY3JcIlxuXSwgZ2QgPSBjbGFzcyBleHRlbmRzIGR0IHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHN1cGVyKCk7XG4gICAgSSh0aGlzLCBcIm5ka1wiKTtcbiAgICBJKHRoaXMsIFwiemFwcGVkRXZlbnRcIik7XG4gICAgSSh0aGlzLCBcInphcHBlZFVzZXJcIik7XG4gICAgdGhpcy5uZGsgPSBlLm5kaywgdGhpcy56YXBwZWRFdmVudCA9IGUuemFwcGVkRXZlbnQsIHRoaXMuemFwcGVkVXNlciA9IGUuemFwcGVkVXNlciB8fCB0aGlzLm5kay5nZXRVc2VyKHsgaGV4cHVia2V5OiB0aGlzLnphcHBlZEV2ZW50LnB1YmtleSB9KTtcbiAgfVxuICBhc3luYyBnZXRaYXBFbmRwb2ludCgpIHtcbiAgICBsZXQgZSwgciwgbiwgaTtcbiAgICBpZiAodGhpcy56YXBwZWRFdmVudCkge1xuICAgICAgY29uc3QgYSA9IChhd2FpdCB0aGlzLnphcHBlZEV2ZW50LmdldE1hdGNoaW5nVGFncyhcInphcFwiKSlbMF07XG4gICAgICBpZiAoYSlcbiAgICAgICAgc3dpdGNoIChhWzJdKSB7XG4gICAgICAgICAgY2FzZSBcImx1ZDA2XCI6XG4gICAgICAgICAgICBlID0gYVsxXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJsdWQxNlwiOlxuICAgICAgICAgICAgciA9IGFbMV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHphcCB0YWcgJHthfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLnphcHBlZFVzZXIgJiYgIWUgJiYgIXIgJiYgKHRoaXMuemFwcGVkVXNlci5wcm9maWxlIHx8IGF3YWl0IHRoaXMuemFwcGVkVXNlci5mZXRjaFByb2ZpbGUoKSwgZSA9ICh0aGlzLnphcHBlZFVzZXIucHJvZmlsZSB8fCB7fSkubHVkMDYsIHIgPSAodGhpcy56YXBwZWRVc2VyLnByb2ZpbGUgfHwge30pLmx1ZDE2KSwgcikge1xuICAgICAgY29uc3QgW2EsIGNdID0gci5zcGxpdChcIkBcIik7XG4gICAgICBuID0gYGh0dHBzOi8vJHtjfS8ud2VsbC1rbm93bi9sbnVybHAvJHthfWA7XG4gICAgfSBlbHNlIGlmIChlKSB7XG4gICAgICBjb25zdCB7IHdvcmRzOiBhIH0gPSB0ZS5kZWNvZGUoZSwgMWUzKSwgYyA9IHRlLmZyb21Xb3JkcyhhKTtcbiAgICAgIG4gPSBuZXcgVGV4dERlY29kZXIoXCJ1dGYtOFwiKS5kZWNvZGUoYyk7XG4gICAgfVxuICAgIGlmICghbilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHphcCBlbmRwb2ludCBmb3VuZFwiKTtcbiAgICBjb25zdCBvID0gYXdhaXQgKGF3YWl0IGZldGNoKG4pKS5qc29uKCk7XG4gICAgcmV0dXJuIChvID09IG51bGwgPyB2b2lkIDAgOiBvLmFsbG93c05vc3RyKSAmJiAoKG8gPT0gbnVsbCA/IHZvaWQgMCA6IG8ubm9zdHJQdWJrZXkpIHx8IChvID09IG51bGwgPyB2b2lkIDAgOiBvLm5vc3RyUHViS2V5KSkgJiYgKGkgPSBvLmNhbGxiYWNrKSwgaTtcbiAgfVxuICBhc3luYyBjcmVhdGVaYXBSZXF1ZXN0KGUsIHIsIG4sIGkpIHtcbiAgICBjb25zdCBzID0gYXdhaXQgdGhpcy5nZXRaYXBFbmRwb2ludCgpO1xuICAgIGlmICghcylcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHphcCBlbmRwb2ludCBmb3VuZFwiKTtcbiAgICBpZiAoIXRoaXMuemFwcGVkRXZlbnQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyB6YXBwZWQgZXZlbnQgZm91bmRcIik7XG4gICAgY29uc3QgbyA9IEVhLm1ha2VaYXBSZXF1ZXN0KHtcbiAgICAgIHByb2ZpbGU6IHRoaXMuemFwcGVkVXNlci5oZXhwdWJrZXkoKSxcbiAgICAgIGV2ZW50OiBudWxsLFxuICAgICAgYW1vdW50OiBlLFxuICAgICAgY29tbWVudDogciB8fCBcIlwiLFxuICAgICAgcmVsYXlzOiBpICE9IG51bGwgPyBpIDogdGhpcy5yZWxheXMoKVxuICAgIH0pO1xuICAgIGlmICh0aGlzLnphcHBlZEV2ZW50KSB7XG4gICAgICBjb25zdCB1ID0gdGhpcy56YXBwZWRFdmVudC50YWdSZWZlcmVuY2UoKTtcbiAgICAgIHUgJiYgby50YWdzLnB1c2godSk7XG4gICAgfVxuICAgIG8udGFncy5wdXNoKFtcImxudXJsXCIsIHNdKTtcbiAgICBjb25zdCBhID0gbmV3IHFlKHRoaXMubmRrLCBvKTtcbiAgICBuICYmIChhLnRhZ3MgPSBhLnRhZ3MuY29uY2F0KG4pKSwgYXdhaXQgYS5zaWduKCk7XG4gICAgY29uc3QgYyA9IGF3YWl0IGEudG9Ob3N0ckV2ZW50KCk7XG4gICAgcmV0dXJuIChhd2FpdCAoYXdhaXQgZmV0Y2goXG4gICAgICBgJHtzfT9gICsgbmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgICAgIGFtb3VudDogZS50b1N0cmluZygpLFxuICAgICAgICBub3N0cjogSlNPTi5zdHJpbmdpZnkoYylcbiAgICAgIH0pXG4gICAgKSkuanNvbigpKS5wcjtcbiAgfVxuICByZWxheXMoKSB7XG4gICAgdmFyIHIsIG47XG4gICAgbGV0IGUgPSBbXTtcbiAgICByZXR1cm4gKG4gPSAociA9IHRoaXMubmRrKSA9PSBudWxsID8gdm9pZCAwIDogci5wb29sKSAhPSBudWxsICYmIG4ucmVsYXlzICYmIChlID0gdGhpcy5uZGsucG9vbC51cmxzKCkpLCBlLmxlbmd0aCB8fCAoZSA9IHlkKSwgZTtcbiAgfVxufTtcbmZ1bmN0aW9uIGJkKHQsIGUgPSBbXSkge1xuICBjb25zdCByID0gLyhAfG5vc3RyOikobnB1YnxucHJvZmlsZXxub3RlfG5ldmVudClbYS16QS1aMC05XSsvZztcbiAgcmV0dXJuIHQgPSB0LnJlcGxhY2UociwgKG4pID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgaSA9IG4uc3BsaXQoLyhAfG5vc3RyOikvKVsyXSwgeyB0eXBlOiBzLCBkYXRhOiBvIH0gPSB3ZS5kZWNvZGUoaSk7XG4gICAgICBsZXQgYTtcbiAgICAgIHN3aXRjaCAocykge1xuICAgICAgICBjYXNlIFwibnB1YlwiOlxuICAgICAgICAgIGEgPSBbXCJwXCIsIG9dO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibnByb2ZpbGVcIjpcbiAgICAgICAgICBhID0gW1wicFwiLCBvLnB1YmtleV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJuZXZlbnRcIjpcbiAgICAgICAgICBhID0gW1wiZVwiLCBvLmlkXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm5vdGVcIjpcbiAgICAgICAgICBhID0gW1wiZVwiLCBvXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlLmZpbmQoKGMpID0+IGNbMF0gPT09IGFbMF0gJiYgY1sxXSA9PT0gYVsxXSkgfHwgZS5wdXNoKGEpLCBgbm9zdHI6JHtpfWA7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gbjtcbiAgICB9XG4gIH0pLCB7IGNvbnRlbnQ6IHQsIHRhZ3M6IGUgfTtcbn1cbmZ1bmN0aW9uIHZkKCkge1xuICBpZiAodGhpcy5raW5kID09PSB2b2lkIDApXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiS2luZCBub3Qgc2V0XCIpO1xuICByZXR1cm4gdGhpcy5raW5kID49IDFlNCAmJiB0aGlzLmtpbmQgPCAyZTQ7XG59XG5mdW5jdGlvbiB3ZCgpIHtcbiAgaWYgKHRoaXMua2luZCA9PT0gdm9pZCAwKVxuICAgIHRocm93IG5ldyBFcnJvcihcIktpbmQgbm90IHNldFwiKTtcbiAgcmV0dXJuIHRoaXMua2luZCA+PSAzZTQgJiYgdGhpcy5raW5kIDwgNGU0O1xufVxuYXN5bmMgZnVuY3Rpb24gX2QoKSB7XG4gIGlmICghdGhpcy5uZGspXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTkRLIG5vdCBzZXRcIik7XG4gIGNvbnN0IHQgPSBhd2FpdCB0aGlzLm5kay5mZXRjaEV2ZW50cyh7XG4gICAga2luZHM6IFszXSxcbiAgICBhdXRob3JzOiBbdGhpcy5oZXhwdWJrZXkoKV1cbiAgfSk7XG4gIGlmICh0KSB7XG4gICAgY29uc3QgZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgcmV0dXJuIHQuZm9yRWFjaCgocikgPT4ge1xuICAgICAgci50YWdzLmZvckVhY2goKG4pID0+IHtcbiAgICAgICAgaWYgKG5bMF0gPT09IFwicFwiKVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBpID0gd2UubnB1YkVuY29kZShuWzFdKTtcbiAgICAgICAgICAgIGUuYWRkKGkpO1xuICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pLCBbLi4uZV0ucmVkdWNlKChyLCBuKSA9PiB7XG4gICAgICBjb25zdCBpID0gbmV3IHBlKHsgbnB1YjogbiB9KTtcbiAgICAgIHJldHVybiBpLm5kayA9IHRoaXMubmRrLCByLmFkZChpKSwgcjtcbiAgICB9LCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKTtcbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbn1cbmZ1bmN0aW9uIG1kKHQsIGUpIHtcbiAgY29uc3QgciA9IEpTT04ucGFyc2UodC5jb250ZW50KTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHIpLmZvckVhY2goKG4pID0+IHtcbiAgICBzd2l0Y2ggKG4pIHtcbiAgICAgIGNhc2UgXCJuYW1lXCI6XG4gICAgICAgIGUubmFtZSA9IHIubmFtZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZGlzcGxheV9uYW1lXCI6XG4gICAgICBjYXNlIFwiZGlzcGxheU5hbWVcIjpcbiAgICAgICAgZS5kaXNwbGF5TmFtZSA9IHIuZGlzcGxheU5hbWUgfHwgci5kaXNwbGF5X25hbWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImltYWdlXCI6XG4gICAgICBjYXNlIFwicGljdHVyZVwiOlxuICAgICAgICBlLmltYWdlID0gci5pbWFnZSB8fCByLnBpY3R1cmU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImJhbm5lclwiOlxuICAgICAgICBlLmJhbm5lciA9IHIuYmFubmVyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJiaW9cIjpcbiAgICAgICAgZS5iaW8gPSByLmJpbztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibmlwMDVcIjpcbiAgICAgICAgZS5uaXAwNSA9IHIubmlwMDU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImx1ZDA2XCI6XG4gICAgICAgIGUubHVkMDYgPSByLmx1ZDA2O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJsdWQxNlwiOlxuICAgICAgICBlLmx1ZDE2ID0gci5sdWQxNjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYWJvdXRcIjpcbiAgICAgICAgZS5hYm91dCA9IHIuYWJvdXQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInphcFNlcnZpY2VcIjpcbiAgICAgICAgZS56YXBTZXJ2aWNlID0gci56YXBTZXJ2aWNlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJ3ZWJzaXRlXCI6XG4gICAgICAgIGUud2Vic2l0ZSA9IHIud2Vic2l0ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBlW25dID0gcltuXTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9KSwgZTtcbn1cbnZhciBwZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IodCkge1xuICAgIEkodGhpcywgXCJuZGtcIik7XG4gICAgSSh0aGlzLCBcInByb2ZpbGVcIik7XG4gICAgSSh0aGlzLCBcIm5wdWJcIiwgXCJcIik7XG4gICAgSSh0aGlzLCBcInJlbGF5VXJsc1wiLCBbXSk7XG4gICAgSSh0aGlzLCBcImZvbGxvd3NcIiwgX2QuYmluZCh0aGlzKSk7XG4gICAgdC5ucHViICYmICh0aGlzLm5wdWIgPSB0Lm5wdWIpLCB0LmhleHB1YmtleSAmJiAodGhpcy5ucHViID0gd2UubnB1YkVuY29kZSh0LmhleHB1YmtleSkpLCB0LnJlbGF5VXJscyAmJiAodGhpcy5yZWxheVVybHMgPSB0LnJlbGF5VXJscyk7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGZyb21OaXAwNSh0KSB7XG4gICAgY29uc3QgZSA9IGF3YWl0IF9hLnF1ZXJ5UHJvZmlsZSh0KTtcbiAgICBpZiAoZSlcbiAgICAgIHJldHVybiBuZXcgcGUoe1xuICAgICAgICBoZXhwdWJrZXk6IGUucHVia2V5LFxuICAgICAgICByZWxheVVybHM6IGUucmVsYXlzXG4gICAgICB9KTtcbiAgfVxuICBoZXhwdWJrZXkoKSB7XG4gICAgcmV0dXJuIHdlLmRlY29kZSh0aGlzLm5wdWIpLmRhdGE7XG4gIH1cbiAgYXN5bmMgZmV0Y2hQcm9maWxlKHQpIHtcbiAgICBpZiAoIXRoaXMubmRrKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTkRLIG5vdCBzZXRcIik7XG4gICAgdGhpcy5wcm9maWxlIHx8ICh0aGlzLnByb2ZpbGUgPSB7fSk7XG4gICAgY29uc3QgZSA9IGF3YWl0IHRoaXMubmRrLmZldGNoRXZlbnRzKFxuICAgICAge1xuICAgICAgICBraW5kczogWzBdLFxuICAgICAgICBhdXRob3JzOiBbdGhpcy5oZXhwdWJrZXkoKV1cbiAgICAgIH0sXG4gICAgICB0XG4gICAgKTtcbiAgICByZXR1cm4gZSAmJiBBcnJheS5mcm9tKGUpLnNvcnQoXG4gICAgICAobiwgaSkgPT4gbi5jcmVhdGVkX2F0IC0gaS5jcmVhdGVkX2F0XG4gICAgKS5mb3JFYWNoKChuKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLnByb2ZpbGUgPSBtZChuLCB0aGlzLnByb2ZpbGUpO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICB9XG4gICAgfSksIGU7XG4gIH1cbiAgYXN5bmMgcmVsYXlMaXN0KCkge1xuICAgIGlmICghdGhpcy5uZGspXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOREsgbm90IHNldFwiKTtcbiAgICBjb25zdCB0ID0gYXdhaXQgdGhpcy5uZGsuZmV0Y2hFdmVudHMoe1xuICAgICAga2luZHM6IFsxMDAwMl0sXG4gICAgICBhdXRob3JzOiBbdGhpcy5oZXhwdWJrZXkoKV1cbiAgICB9KTtcbiAgICByZXR1cm4gdCB8fCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICB9XG4gIHRhZ1JlZmVyZW5jZSgpIHtcbiAgICByZXR1cm4gW1wicFwiLCB0aGlzLmhleHB1YmtleSgpXTtcbiAgfVxuICBhc3luYyBwdWJsaXNoKCkge1xuICAgIGlmICghdGhpcy5uZGspXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBOREsgaW5zdGFuY2UgZm91bmRcIik7XG4gICAgdGhpcy5uZGsuYXNzZXJ0U2lnbmVyKCksIGF3YWl0IG5ldyBxZSh0aGlzLm5kaywge1xuICAgICAga2luZDogMCxcbiAgICAgIGNvbnRlbnQ6IEpTT04uc3RyaW5naWZ5KHRoaXMucHJvZmlsZSlcbiAgICB9KS5wdWJsaXNoKCk7XG4gIH1cbiAgYXN5bmMgZm9sbG93KHQsIGUpIHtcbiAgICBpZiAoIXRoaXMubmRrKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gTkRLIGluc3RhbmNlIGZvdW5kXCIpO1xuICAgIGlmICh0aGlzLm5kay5hc3NlcnRTaWduZXIoKSwgZSB8fCAoZSA9IGF3YWl0IHRoaXMuZm9sbG93cygpKSwgZS5oYXModCkpXG4gICAgICByZXR1cm4gITE7XG4gICAgZS5hZGQodCk7XG4gICAgY29uc3QgciA9IG5ldyBxZSh0aGlzLm5kaywgeyBraW5kOiAzIH0pO1xuICAgIGZvciAoY29uc3QgbiBvZiBlKVxuICAgICAgci50YWcobik7XG4gICAgcmV0dXJuIGF3YWl0IHIucHVibGlzaCgpLCAhMDtcbiAgfVxufTtcbmFzeW5jIGZ1bmN0aW9uIHhkKHQsIGUpIHtcbiAgaWYgKCFlKSB7XG4gICAgaWYgKCF0aGlzLm5kaylcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHNpZ25lciBhdmFpbGFibGVcIik7XG4gICAgYXdhaXQgdGhpcy5uZGsuYXNzZXJ0U2lnbmVyKCksIGUgPSB0aGlzLm5kay5zaWduZXI7XG4gIH1cbiAgaWYgKCF0KSB7XG4gICAgY29uc3QgciA9IHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwicFwiKTtcbiAgICBpZiAoci5sZW5ndGggIT09IDEpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyByZWNpcGllbnQgY291bGQgYmUgZGV0ZXJtaW5lZCBhbmQgbm8gZXhwbGljaXQgcmVjaXBpZW50IHdhcyBwcm92aWRlZFwiKTtcbiAgICB0ID0gbmV3IHBlKHsgaGV4cHVia2V5OiByWzBdWzFdIH0pLCB0Lm5kayA9IHRoaXMubmRrO1xuICB9XG4gIHRoaXMuY29udGVudCA9IGF3YWl0IGUuZW5jcnlwdCh0LCB0aGlzLmNvbnRlbnQpO1xufVxuYXN5bmMgZnVuY3Rpb24gRWQodCwgZSkge1xuICBpZiAoIWUpIHtcbiAgICBpZiAoIXRoaXMubmRrKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc2lnbmVyIGF2YWlsYWJsZVwiKTtcbiAgICBhd2FpdCB0aGlzLm5kay5hc3NlcnRTaWduZXIoKSwgZSA9IHRoaXMubmRrLnNpZ25lcjtcbiAgfVxuICB0IHx8ICh0ID0gdGhpcy5hdXRob3IpLCB0aGlzLmNvbnRlbnQgPSBhd2FpdCBlLmRlY3J5cHQodCwgdGhpcy5jb250ZW50KTtcbn1cbmZ1bmN0aW9uIGtkKCkge1xuICByZXR1cm4gdGhpcy5pc1BhcmFtUmVwbGFjZWFibGUoKSA/IHdlLm5hZGRyRW5jb2RlKHtcbiAgICBraW5kOiB0aGlzLmtpbmQsXG4gICAgcHVia2V5OiB0aGlzLnB1YmtleSxcbiAgICBpZGVudGlmaWVyOiB0aGlzLnJlcGxhY2VhYmxlRFRhZygpXG4gIH0pIDogd2Uubm90ZUVuY29kZSh0aGlzLnRhZ0lkKCkpO1xufVxuYXN5bmMgZnVuY3Rpb24gU2QodCA9ICEwLCBlKSB7XG4gIGlmICghZSkge1xuICAgIGlmICghdGhpcy5uZGspXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBOREsgaW5zdGFuY2UgZm91bmRcIik7XG4gICAgdGhpcy5uZGsuYXNzZXJ0U2lnbmVyKCksIGUgPSB0aGlzLm5kay5zaWduZXI7XG4gIH1cbiAgaWYgKCFlKVxuICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHNpZ25lciBhdmFpbGFibGVcIik7XG4gIGNvbnN0IHIgPSBhd2FpdCBlLnVzZXIoKSwgbiA9IG5ldyBxZSh0aGlzLm5kaywge1xuICAgIGtpbmQ6IE9kKHRoaXMpLFxuICAgIGNvbnRlbnQ6IFwiXCIsXG4gICAgcHVia2V5OiByLmhleHB1YmtleSgpXG4gIH0pO1xuICByZXR1cm4gbi50YWcodGhpcyksIG4ua2luZCA9PT0gMTYgJiYgbi50YWdzLnB1c2goW1wia1wiLCBgJHt0aGlzLmtpbmR9YF0pLCBhd2FpdCBuLnNpZ24oZSksIHQgJiYgYXdhaXQgbi5wdWJsaXNoKCksIG47XG59XG5mdW5jdGlvbiBPZCh0KSB7XG4gIHJldHVybiB0LmtpbmQgPT09IDEgPyA2IDogMTY7XG59XG52YXIgcWUgPSBjbGFzcyBleHRlbmRzIGR0IHtcbiAgY29uc3RydWN0b3IoZSwgcikge1xuICAgIHN1cGVyKCk7XG4gICAgSSh0aGlzLCBcIm5ka1wiKTtcbiAgICBJKHRoaXMsIFwiY3JlYXRlZF9hdFwiKTtcbiAgICBJKHRoaXMsIFwiY29udGVudFwiLCBcIlwiKTtcbiAgICBJKHRoaXMsIFwidGFnc1wiLCBbXSk7XG4gICAgSSh0aGlzLCBcImtpbmRcIik7XG4gICAgSSh0aGlzLCBcImlkXCIsIFwiXCIpO1xuICAgIEkodGhpcywgXCJzaWdcIik7XG4gICAgSSh0aGlzLCBcInB1YmtleVwiLCBcIlwiKTtcbiAgICBJKHRoaXMsIFwicmVsYXlcIik7XG4gICAgSSh0aGlzLCBcImlzUmVwbGFjZWFibGVcIiwgdmQuYmluZCh0aGlzKSk7XG4gICAgSSh0aGlzLCBcImlzUGFyYW1SZXBsYWNlYWJsZVwiLCB3ZC5iaW5kKHRoaXMpKTtcbiAgICBJKHRoaXMsIFwiZW5jb2RlXCIsIGtkLmJpbmQodGhpcykpO1xuICAgIEkodGhpcywgXCJlbmNyeXB0XCIsIHhkLmJpbmQodGhpcykpO1xuICAgIEkodGhpcywgXCJkZWNyeXB0XCIsIEVkLmJpbmQodGhpcykpO1xuICAgIEkodGhpcywgXCJyZXBvc3RcIiwgU2QuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5uZGsgPSBlLCB0aGlzLmNyZWF0ZWRfYXQgPSByID09IG51bGwgPyB2b2lkIDAgOiByLmNyZWF0ZWRfYXQsIHRoaXMuY29udGVudCA9IChyID09IG51bGwgPyB2b2lkIDAgOiByLmNvbnRlbnQpIHx8IFwiXCIsIHRoaXMudGFncyA9IChyID09IG51bGwgPyB2b2lkIDAgOiByLnRhZ3MpIHx8IFtdLCB0aGlzLmlkID0gKHIgPT0gbnVsbCA/IHZvaWQgMCA6IHIuaWQpIHx8IFwiXCIsIHRoaXMuc2lnID0gciA9PSBudWxsID8gdm9pZCAwIDogci5zaWcsIHRoaXMucHVia2V5ID0gKHIgPT0gbnVsbCA/IHZvaWQgMCA6IHIucHVia2V5KSB8fCBcIlwiLCB0aGlzLmtpbmQgPSByID09IG51bGwgPyB2b2lkIDAgOiByLmtpbmQ7XG4gIH1cbiAgcmF3RXZlbnQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNyZWF0ZWRfYXQ6IHRoaXMuY3JlYXRlZF9hdCxcbiAgICAgIGNvbnRlbnQ6IHRoaXMuY29udGVudCxcbiAgICAgIHRhZ3M6IHRoaXMudGFncyxcbiAgICAgIGtpbmQ6IHRoaXMua2luZCxcbiAgICAgIHB1YmtleTogdGhpcy5wdWJrZXksXG4gICAgICBpZDogdGhpcy5pZCxcbiAgICAgIHNpZzogdGhpcy5zaWdcbiAgICB9O1xuICB9XG4gIHNldCBhdXRob3IoZSkge1xuICAgIHRoaXMucHVia2V5ID0gZS5oZXhwdWJrZXkoKTtcbiAgfVxuICBnZXQgYXV0aG9yKCkge1xuICAgIGNvbnN0IGUgPSBuZXcgcGUoeyBoZXhwdWJrZXk6IHRoaXMucHVia2V5IH0pO1xuICAgIHJldHVybiBlLm5kayA9IHRoaXMubmRrLCBlO1xuICB9XG4gIHRhZyhlLCByKSB7XG4gICAgY29uc3QgbiA9IGUudGFnUmVmZXJlbmNlKCk7XG4gICAgaWYgKHIgJiYgbi5wdXNoKHIpLCB0aGlzLnRhZ3MucHVzaChuKSwgZSBpbnN0YW5jZW9mIHFlKSB7XG4gICAgICBjb25zdCBpID0gZS5hdXRob3I7XG4gICAgICBpICYmIHRoaXMucHVia2V5ICE9PSBpLmhleHB1YmtleSgpICYmIHRoaXMudGFnKGkpO1xuICAgICAgZm9yIChjb25zdCBzIG9mIGUuZ2V0TWF0Y2hpbmdUYWdzKFwicFwiKSlcbiAgICAgICAgc1sxXSAhPT0gdGhpcy5wdWJrZXkgJiYgKHRoaXMudGFncy5maW5kKChvKSA9PiBvWzBdID09PSBcInBcIiAmJiBvWzFdID09PSBzWzFdKSB8fCB0aGlzLnRhZ3MucHVzaChbXCJwXCIsIHNbMV1dKSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIHRvTm9zdHJFdmVudChlKSB7XG4gICAgdmFyIHMsIG87XG4gICAgaWYgKCFlICYmIHRoaXMucHVia2V5ID09PSBcIlwiKSB7XG4gICAgICBjb25zdCBhID0gYXdhaXQgKChvID0gKHMgPSB0aGlzLm5kaykgPT0gbnVsbCA/IHZvaWQgMCA6IHMuc2lnbmVyKSA9PSBudWxsID8gdm9pZCAwIDogby51c2VyKCkpO1xuICAgICAgdGhpcy5wdWJrZXkgPSAoYSA9PSBudWxsID8gdm9pZCAwIDogYS5oZXhwdWJrZXkoKSkgfHwgXCJcIjtcbiAgICB9XG4gICAgdGhpcy5jcmVhdGVkX2F0IHx8ICh0aGlzLmNyZWF0ZWRfYXQgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxZTMpKTtcbiAgICBjb25zdCByID0gdGhpcy5yYXdFdmVudCgpLCB7IGNvbnRlbnQ6IG4sIHRhZ3M6IGkgfSA9IHRoaXMuZ2VuZXJhdGVUYWdzKCk7XG4gICAgci5jb250ZW50ID0gbiB8fCBcIlwiLCByLnRhZ3MgPSBpO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmlkID0gSHIocik7XG4gICAgfSBjYXRjaCB7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmlkICYmIChyLmlkID0gdGhpcy5pZCksIHRoaXMuc2lnICYmIChyLnNpZyA9IHRoaXMuc2lnKSwgcjtcbiAgfVxuICBnZXRNYXRjaGluZ1RhZ3MoZSkge1xuICAgIHJldHVybiB0aGlzLnRhZ3MuZmlsdGVyKChyKSA9PiByWzBdID09PSBlKTtcbiAgfVxuICB0YWdWYWx1ZShlKSB7XG4gICAgY29uc3QgciA9IHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKGUpO1xuICAgIGlmIChyLmxlbmd0aCAhPT0gMClcbiAgICAgIHJldHVybiByWzBdWzFdO1xuICB9XG4gIHJlbW92ZVRhZyhlKSB7XG4gICAgdGhpcy50YWdzID0gdGhpcy50YWdzLmZpbHRlcigocikgPT4gclswXSAhPT0gZSk7XG4gIH1cbiAgYXN5bmMgc2lnbihlKSB7XG4gICAgdmFyIG47XG4gICAgZSB8fCAoKG4gPSB0aGlzLm5kaykgPT0gbnVsbCB8fCBuLmFzc2VydFNpZ25lcigpLCBlID0gdGhpcy5uZGsuc2lnbmVyKSwgYXdhaXQgdGhpcy5nZW5lcmF0ZVRhZ3MoKSwgdGhpcy5pc1JlcGxhY2VhYmxlKCkgJiYgKHRoaXMuY3JlYXRlZF9hdCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDFlMykpO1xuICAgIGNvbnN0IHIgPSBhd2FpdCB0aGlzLnRvTm9zdHJFdmVudCgpO1xuICAgIHJldHVybiB0aGlzLnNpZyA9IGF3YWl0IGUuc2lnbihyKSwgdGhpcy5zaWc7XG4gIH1cbiAgYXN5bmMgcHVibGlzaChlLCByKSB7XG4gICAgaWYgKHRoaXMuc2lnIHx8IGF3YWl0IHRoaXMuc2lnbigpLCAhdGhpcy5uZGspXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOREtFdmVudCBtdXN0IGJlIGFzc29jaWF0ZWQgd2l0aCBhbiBOREsgaW5zdGFuY2UgdG8gcHVibGlzaFwiKTtcbiAgICByZXR1cm4gdGhpcy5uZGsucHVibGlzaCh0aGlzLCBlLCByKTtcbiAgfVxuICBnZW5lcmF0ZVRhZ3MoKSB7XG4gICAgbGV0IGUgPSBbXTtcbiAgICBjb25zdCByID0gYmQodGhpcy5jb250ZW50LCB0aGlzLnRhZ3MpLCBuID0gci5jb250ZW50O1xuICAgIGlmIChlID0gci50YWdzLCB0aGlzLmtpbmQgJiYgdGhpcy5raW5kID49IDNlNCAmJiB0aGlzLmtpbmQgPD0gNGU0ICYmICF0aGlzLmdldE1hdGNoaW5nVGFncyhcImRcIilbMF0pIHtcbiAgICAgIGNvbnN0IHMgPSBbLi4uQXJyYXkoMTYpXS5tYXAoKCkgPT4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNilbMl0pLmpvaW4oXCJcIik7XG4gICAgICBlLnB1c2goW1wiZFwiLCBzXSk7XG4gICAgfVxuICAgIHJldHVybiB7IGNvbnRlbnQ6IG4gfHwgXCJcIiwgdGFnczogZSB9O1xuICB9XG4gIHJlcGxhY2VhYmxlRFRhZygpIHtcbiAgICBpZiAodGhpcy5raW5kICYmIHRoaXMua2luZCA+PSAzZTQgJiYgdGhpcy5raW5kIDw9IDRlNCkge1xuICAgICAgY29uc3QgZSA9IHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwiZFwiKVswXTtcbiAgICAgIHJldHVybiBlID8gZVsxXSA6IFwiXCI7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIkV2ZW50IGlzIG5vdCBhIHBhcmFtZXRlcml6ZWQgcmVwbGFjZWFibGUgZXZlbnRcIik7XG4gIH1cbiAgdGFnSWQoKSB7XG4gICAgaWYgKHRoaXMua2luZCAmJiB0aGlzLmtpbmQgPj0gM2U0ICYmIHRoaXMua2luZCA8PSA0ZTQpIHtcbiAgICAgIGNvbnN0IGUgPSB0aGlzLnJlcGxhY2VhYmxlRFRhZygpO1xuICAgICAgcmV0dXJuIGAke3RoaXMua2luZH06JHt0aGlzLnB1YmtleX06JHtlfWA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmlkO1xuICB9XG4gIHRhZ1JlZmVyZW5jZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1BhcmFtUmVwbGFjZWFibGUoKSA/IFtcImFcIiwgdGhpcy50YWdJZCgpXSA6IFtcImVcIiwgdGhpcy50YWdJZCgpXTtcbiAgfVxuICBmaWx0ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNQYXJhbVJlcGxhY2VhYmxlKCkgPyB7IFwiI2FcIjogW3RoaXMudGFnSWQoKV0gfSA6IHsgXCIjZVwiOiBbdGhpcy50YWdJZCgpXSB9O1xuICB9XG4gIGFzeW5jIHphcChlLCByLCBuKSB7XG4gICAgaWYgKCF0aGlzLm5kaylcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIE5ESyBpbnN0YW5jZSBmb3VuZFwiKTtcbiAgICByZXR1cm4gdGhpcy5uZGsuYXNzZXJ0U2lnbmVyKCksIGF3YWl0IG5ldyBnZCh7XG4gICAgICBuZGs6IHRoaXMubmRrLFxuICAgICAgemFwcGVkRXZlbnQ6IHRoaXNcbiAgICB9KS5jcmVhdGVaYXBSZXF1ZXN0KGUsIHIsIG4pO1xuICB9XG4gIGFzeW5jIGRlbGV0ZShlKSB7XG4gICAgaWYgKCF0aGlzLm5kaylcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIE5ESyBpbnN0YW5jZSBmb3VuZFwiKTtcbiAgICB0aGlzLm5kay5hc3NlcnRTaWduZXIoKTtcbiAgICBjb25zdCByID0gbmV3IHFlKHRoaXMubmRrLCB7XG4gICAgICBraW5kOiA1LFxuICAgICAgY29udGVudDogZSB8fCBcIlwiXG4gICAgfSk7XG4gICAgcmV0dXJuIHIudGFnKHRoaXMpLCBhd2FpdCByLnB1Ymxpc2goKSwgcjtcbiAgfVxufSwgQWQgPSBjbGFzcyBleHRlbmRzIGR0IHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHN1cGVyKCk7XG4gICAgSSh0aGlzLCBcInVybFwiKTtcbiAgICBJKHRoaXMsIFwic2NvcmVzXCIpO1xuICAgIEkodGhpcywgXCJyZWxheVwiKTtcbiAgICBJKHRoaXMsIFwiX3N0YXR1c1wiKTtcbiAgICBJKHRoaXMsIFwiY29ubmVjdGVkQXRcIik7XG4gICAgSSh0aGlzLCBcIl9jb25uZWN0aW9uU3RhdHNcIiwgeyBhdHRlbXB0czogMCwgc3VjY2VzczogMCwgZHVyYXRpb25zOiBbXSB9KTtcbiAgICBJKHRoaXMsIFwiY29tcGxhaW5pbmdcIiwgITEpO1xuICAgIEkodGhpcywgXCJkZWJ1Z1wiKTtcbiAgICBJKHRoaXMsIFwiYWN0aXZlU3Vic2NyaXB0aW9uc1wiLCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKTtcbiAgICBJKHRoaXMsIFwidXBkYXRlQ29ubmVjdGlvblN0YXRzXCIsIHtcbiAgICAgIGNvbm5lY3RlZDogKCkgPT4ge1xuICAgICAgICB0aGlzLl9jb25uZWN0aW9uU3RhdHMuc3VjY2VzcysrLCB0aGlzLl9jb25uZWN0aW9uU3RhdHMuY29ubmVjdGVkQXQgPSBEYXRlLm5vdygpO1xuICAgICAgfSxcbiAgICAgIGRpc2Nvbm5lY3RlZDogKCkgPT4ge1xuICAgICAgICB0aGlzLl9jb25uZWN0aW9uU3RhdHMuY29ubmVjdGVkQXQgJiYgKHRoaXMuX2Nvbm5lY3Rpb25TdGF0cy5kdXJhdGlvbnMucHVzaChcbiAgICAgICAgICBEYXRlLm5vdygpIC0gdGhpcy5fY29ubmVjdGlvblN0YXRzLmNvbm5lY3RlZEF0XG4gICAgICAgICksIHRoaXMuX2Nvbm5lY3Rpb25TdGF0cy5kdXJhdGlvbnMubGVuZ3RoID4gMTAwICYmIHRoaXMuX2Nvbm5lY3Rpb25TdGF0cy5kdXJhdGlvbnMuc2hpZnQoKSksIHRoaXMuX2Nvbm5lY3Rpb25TdGF0cy5jb25uZWN0ZWRBdCA9IHZvaWQgMDtcbiAgICAgIH0sXG4gICAgICBhdHRlbXB0OiAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3Rpb25TdGF0cy5hdHRlbXB0cysrO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMudXJsID0gZSwgdGhpcy5yZWxheSA9IEFmKGUpLCB0aGlzLnNjb3JlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIHRoaXMuX3N0YXR1cyA9IDMsIHRoaXMuZGVidWcgPSBNbihgbmRrOnJlbGF5OiR7ZX1gKSwgdGhpcy5yZWxheS5vbihcImNvbm5lY3RcIiwgKCkgPT4ge1xuICAgICAgdGhpcy51cGRhdGVDb25uZWN0aW9uU3RhdHMuY29ubmVjdGVkKCksIHRoaXMuX3N0YXR1cyA9IDEsIHRoaXMuZW1pdChcImNvbm5lY3RcIik7XG4gICAgfSksIHRoaXMucmVsYXkub24oXCJkaXNjb25uZWN0XCIsICgpID0+IHtcbiAgICAgIHRoaXMudXBkYXRlQ29ubmVjdGlvblN0YXRzLmRpc2Nvbm5lY3RlZCgpLCB0aGlzLl9zdGF0dXMgPT09IDEgJiYgKHRoaXMuX3N0YXR1cyA9IDMsIHRoaXMuaGFuZGxlUmVjb25uZWN0aW9uKCkpLCB0aGlzLmVtaXQoXCJkaXNjb25uZWN0XCIpO1xuICAgIH0pLCB0aGlzLnJlbGF5Lm9uKFwibm90aWNlXCIsIChyKSA9PiB0aGlzLmhhbmRsZU5vdGljZShyKSk7XG4gIH1cbiAgaXNGbGFwcGluZygpIHtcbiAgICBjb25zdCBlID0gdGhpcy5fY29ubmVjdGlvblN0YXRzLmR1cmF0aW9ucztcbiAgICBpZiAoZS5sZW5ndGggPCAxMClcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCBuID0gZS5yZWR1Y2UoKGEsIGMpID0+IGEgKyBjLCAwKSAvIGUubGVuZ3RoLCBpID0gZS5tYXAoKGEpID0+IE1hdGgucG93KGEgLSBuLCAyKSkucmVkdWNlKChhLCBjKSA9PiBhICsgYywgMCkgLyBlLmxlbmd0aDtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KGkpIDwgMWUzO1xuICB9XG4gIGhhbmRsZVJlY29ubmVjdGlvbigpIHtcbiAgICB0aGlzLmlzRmxhcHBpbmcoKSAmJiAodGhpcy5lbWl0KFwiZmxhcHBpbmdcIiwgdGhpcywgdGhpcy5fY29ubmVjdGlvblN0YXRzKSwgdGhpcy5fc3RhdHVzID0gNSksIHRoaXMuY29ubmVjdGVkQXQgJiYgRGF0ZS5ub3coKSAtIHRoaXMuY29ubmVjdGVkQXQgPCA1ZTMgPyBzZXRUaW1lb3V0KCgpID0+IHRoaXMuY29ubmVjdCgpLCA2ZTQpIDogdGhpcy5jb25uZWN0KCk7XG4gIH1cbiAgZ2V0IHN0YXR1cygpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdHVzO1xuICB9XG4gIGFzeW5jIGNvbm5lY3QoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMudXBkYXRlQ29ubmVjdGlvblN0YXRzLmF0dGVtcHQoKSwgdGhpcy5fc3RhdHVzID0gMCwgYXdhaXQgdGhpcy5yZWxheS5jb25uZWN0KCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgdGhpcy5kZWJ1ZyhcIkZhaWxlZCB0byBjb25uZWN0XCIsIGUpLCB0aGlzLl9zdGF0dXMgPSAzLCBlO1xuICAgIH1cbiAgfVxuICBkaXNjb25uZWN0KCkge1xuICAgIHRoaXMuX3N0YXR1cyA9IDIsIHRoaXMucmVsYXkuY2xvc2UoKTtcbiAgfVxuICBhc3luYyBoYW5kbGVOb3RpY2UoZSkge1xuICAgIChlLmluY2x1ZGVzKFwib28gbWFueVwiKSB8fCBlLmluY2x1ZGVzKFwiYXhpbXVtXCIpKSAmJiAodGhpcy5kaXNjb25uZWN0KCksIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5jb25uZWN0KCksIDJlMyksIHRoaXMuZGVidWcodGhpcy5yZWxheS51cmwsIFwiUmVsYXkgY29tcGxhaW5pbmc/XCIsIGUpKSwgdGhpcy5lbWl0KFwibm90aWNlXCIsIHRoaXMsIGUpO1xuICB9XG4gIHN1YnNjcmliZShlKSB7XG4gICAgY29uc3QgeyBmaWx0ZXI6IHIgfSA9IGUsIG4gPSB0aGlzLnJlbGF5LnN1Yihbcl0sIHtcbiAgICAgIGlkOiBlLnN1YklkXG4gICAgfSk7XG4gICAgdGhpcy5kZWJ1ZyhgU3Vic2NyaWJlZCB0byAke0pTT04uc3RyaW5naWZ5KHIpfWApLCBuLm9uKFwiZXZlbnRcIiwgKHMpID0+IHtcbiAgICAgIGNvbnN0IG8gPSBuZXcgcWUodm9pZCAwLCBzKTtcbiAgICAgIG8ucmVsYXkgPSB0aGlzLCBlLmV2ZW50UmVjZWl2ZWQobywgdGhpcyk7XG4gICAgfSksIG4ub24oXCJlb3NlXCIsICgpID0+IHtcbiAgICAgIGUuZW9zZVJlY2VpdmVkKHRoaXMpO1xuICAgIH0pO1xuICAgIGNvbnN0IGkgPSBuLnVuc3ViO1xuICAgIHJldHVybiBuLnVuc3ViID0gKCkgPT4ge1xuICAgICAgdGhpcy5kZWJ1ZyhgVW5zdWJzY3JpYmluZyBmcm9tICR7SlNPTi5zdHJpbmdpZnkocil9YCksIHRoaXMuYWN0aXZlU3Vic2NyaXB0aW9ucy5kZWxldGUoZSksIGkoKTtcbiAgICB9LCB0aGlzLmFjdGl2ZVN1YnNjcmlwdGlvbnMuYWRkKGUpLCBlLm9uKFwiY2xvc2VcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5hY3RpdmVTdWJzY3JpcHRpb25zLmRlbGV0ZShlKTtcbiAgICB9KSwgbjtcbiAgfVxuICBhc3luYyBwdWJsaXNoKGUsIHIgPSAyNTAwKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAxID8gdGhpcy5wdWJsaXNoRXZlbnQoZSwgcikgOiAodGhpcy5vbmNlKFwiY29ubmVjdFwiLCAoKSA9PiB7XG4gICAgICB0aGlzLnB1Ymxpc2hFdmVudChlLCByKTtcbiAgICB9KSwgITApO1xuICB9XG4gIGFzeW5jIHB1Ymxpc2hFdmVudChlLCByKSB7XG4gICAgY29uc3QgbiA9IGF3YWl0IGUudG9Ob3N0ckV2ZW50KCksIGkgPSB0aGlzLnJlbGF5LnB1Ymxpc2gobik7XG4gICAgbGV0IHM7XG4gICAgY29uc3QgbyA9IG5ldyBQcm9taXNlKChjLCBsKSA9PiB7XG4gICAgICBpLm9uKFwiZmFpbGVkXCIsIChmKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dChzKSwgdGhpcy5kZWJ1ZyhcIlB1Ymxpc2ggZmFpbGVkXCIsIGYsIGUuaWQpLCB0aGlzLmVtaXQoXCJwdWJsaXNoOmZhaWxlZFwiLCBlLCBmKSwgbChmKTtcbiAgICAgIH0pLCBpLm9uKFwib2tcIiwgKCkgPT4ge1xuICAgICAgICBjbGVhclRpbWVvdXQocyksIHRoaXMuZW1pdChcInB1Ymxpc2hlZFwiLCBlKSwgYyghMCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBpZiAoIXIpXG4gICAgICByZXR1cm4gbztcbiAgICBjb25zdCBhID0gbmV3IFByb21pc2UoKGMsIGwpID0+IHtcbiAgICAgIHMgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5kZWJ1ZyhcIlB1Ymxpc2ggdGltZWQgb3V0XCIsIGUucmF3RXZlbnQoKSksIHRoaXMuZW1pdChcInB1Ymxpc2g6ZmFpbGVkXCIsIGUsIFwiVGltZW91dFwiKSwgbChuZXcgRXJyb3IoXCJQdWJsaXNoIG9wZXJhdGlvbiB0aW1lZCBvdXRcIikpO1xuICAgICAgfSwgcik7XG4gICAgfSk7XG4gICAgcmV0dXJuIFByb21pc2UucmFjZShbbywgYV0pO1xuICB9XG4gIHNjb3JlU2xvd2VyRXZlbnQoZSkge1xuICB9XG4gIGdldCBjb25uZWN0aW9uU3RhdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3Rpb25TdGF0cztcbiAgfVxuICB0YWdSZWZlcmVuY2UoZSkge1xuICAgIGNvbnN0IHIgPSBbXCJyXCIsIHRoaXMucmVsYXkudXJsXTtcbiAgICByZXR1cm4gZSAmJiByLnB1c2goZSksIHI7XG4gIH1cbn0sIENkID0gY2xhc3MgZXh0ZW5kcyBkdCB7XG4gIGNvbnN0cnVjdG9yKGUgPSBbXSwgcikge1xuICAgIHN1cGVyKCk7XG4gICAgSSh0aGlzLCBcInJlbGF5c1wiLCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgICBJKHRoaXMsIFwiZGVidWdcIik7XG4gICAgdGhpcy5kZWJ1ZyA9IHIuZGVidWcuZXh0ZW5kKFwicG9vbFwiKTtcbiAgICBmb3IgKGNvbnN0IG4gb2YgZSkge1xuICAgICAgY29uc3QgaSA9IG5ldyBBZChuKTtcbiAgICAgIGkub24oXCJub3RpY2VcIiwgKHMsIG8pID0+IHRoaXMuZW1pdChcIm5vdGljZVwiLCBzLCBvKSksIGkub24oXCJjb25uZWN0XCIsICgpID0+IHRoaXMuaGFuZGxlUmVsYXlDb25uZWN0KG4pKSwgaS5vbihcImRpc2Nvbm5lY3RcIiwgKCkgPT4gdGhpcy5lbWl0KFwicmVsYXk6ZGlzY29ubmVjdFwiLCBpKSksIGkub24oXCJmbGFwcGluZ1wiLCAoKSA9PiB0aGlzLmhhbmRsZUZsYXBwaW5nKGkpKSwgdGhpcy5yZWxheXMuc2V0KG4sIGkpO1xuICAgIH1cbiAgfVxuICBoYW5kbGVSZWxheUNvbm5lY3QoZSkge1xuICAgIHRoaXMuZGVidWcoYFJlbGF5ICR7ZX0gY29ubmVjdGVkYCksIHRoaXMuZW1pdChcInJlbGF5OmNvbm5lY3RcIiwgdGhpcy5yZWxheXMuZ2V0KGUpKSwgdGhpcy5zdGF0cygpLmNvbm5lY3RlZCA9PT0gdGhpcy5yZWxheXMuc2l6ZSAmJiB0aGlzLmVtaXQoXCJjb25uZWN0XCIpO1xuICB9XG4gIGFzeW5jIGNvbm5lY3QoZSkge1xuICAgIGNvbnN0IHIgPSBbXTtcbiAgICB0aGlzLmRlYnVnKFxuICAgICAgYENvbm5lY3RpbmcgdG8gJHt0aGlzLnJlbGF5cy5zaXplfSByZWxheXMke2UgPyBgLCB0aW1lb3V0ICR7ZX0uLi5gIDogXCJcIn1gXG4gICAgKTtcbiAgICBmb3IgKGNvbnN0IG4gb2YgdGhpcy5yZWxheXMudmFsdWVzKCkpXG4gICAgICBpZiAoZSkge1xuICAgICAgICBjb25zdCBpID0gbmV3IFByb21pc2UoKHMsIG8pID0+IHtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IG8oYFRpbWVkIG91dCBhZnRlciAke2V9bXNgKSwgZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByLnB1c2goXG4gICAgICAgICAgUHJvbWlzZS5yYWNlKFtuLmNvbm5lY3QoKSwgaV0pLmNhdGNoKChzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRlYnVnKGBGYWlsZWQgdG8gY29ubmVjdCB0byByZWxheSAke24udXJsfTogJHtzfWApO1xuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgci5wdXNoKG4uY29ubmVjdCgpKTtcbiAgICBlICYmIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgY29uc3QgbiA9IHRoaXMuc3RhdHMoKS5jb25uZWN0ZWQgPT09IHRoaXMucmVsYXlzLnNpemUsIGkgPSB0aGlzLnN0YXRzKCkuY29ubmVjdGVkID4gMDtcbiAgICAgICFuICYmIGkgJiYgdGhpcy5lbWl0KFwiY29ubmVjdFwiKTtcbiAgICB9LCBlKSwgYXdhaXQgUHJvbWlzZS5hbGwocik7XG4gIH1cbiAgaGFuZGxlRmxhcHBpbmcoZSkge1xuICAgIHRoaXMuZGVidWcoYFJlbGF5ICR7ZS51cmx9IGlzIGZsYXBwaW5nYCksIHRoaXMucmVsYXlzLmRlbGV0ZShlLnVybCksIHRoaXMuZW1pdChcImZsYXBwaW5nXCIsIGUpO1xuICB9XG4gIHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVsYXlzLnNpemU7XG4gIH1cbiAgc3RhdHMoKSB7XG4gICAgY29uc3QgZSA9IHtcbiAgICAgIHRvdGFsOiAwLFxuICAgICAgY29ubmVjdGVkOiAwLFxuICAgICAgZGlzY29ubmVjdGVkOiAwLFxuICAgICAgY29ubmVjdGluZzogMFxuICAgIH07XG4gICAgZm9yIChjb25zdCByIG9mIHRoaXMucmVsYXlzLnZhbHVlcygpKVxuICAgICAgZS50b3RhbCsrLCByLnN0YXR1cyA9PT0gMSA/IGUuY29ubmVjdGVkKysgOiByLnN0YXR1cyA9PT0gMyA/IGUuZGlzY29ubmVjdGVkKysgOiByLnN0YXR1cyA9PT0gMCAmJiBlLmNvbm5lY3RpbmcrKztcbiAgICByZXR1cm4gZTtcbiAgfVxuICB1cmxzKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMucmVsYXlzLmtleXMoKSk7XG4gIH1cbn07XG5mdW5jdGlvbiBJZCh0KSB7XG4gIHJldHVybiAhIShSZCh0LmZpbHRlcikgJiYgVGQodCkpO1xufVxuZnVuY3Rpb24gUmQodCkge1xuICByZXR1cm4gISF0Lmlkcztcbn1cbmZ1bmN0aW9uIFRkKHQpIHtcbiAgY29uc3QgZSA9IHQuZmlsdGVyLmlkcztcbiAgcmV0dXJuICEhZSAmJiBlLmxlbmd0aCA9PT0gdC5ldmVudEZpcnN0U2Vlbi5zaXplO1xufVxudmFyIFBkID0ge1xuICBjbG9zZU9uRW9zZTogITAsXG4gIGNhY2hlVXNhZ2U6IFwiQ0FDSEVfRklSU1RcIixcbiAgZ3JvdXBhYmxlOiAhMCxcbiAgZ3JvdXBhYmxlRGVsYXk6IDEwMFxufSwgUGEgPSBjbGFzcyBleHRlbmRzIGR0IHtcbiAgY29uc3RydWN0b3IoZSwgciwgbiwgaSwgcykge1xuICAgIHN1cGVyKCk7XG4gICAgSSh0aGlzLCBcInN1YklkXCIpO1xuICAgIEkodGhpcywgXCJmaWx0ZXJcIik7XG4gICAgSSh0aGlzLCBcIm9wdHNcIik7XG4gICAgSSh0aGlzLCBcInJlbGF5U2V0XCIpO1xuICAgIEkodGhpcywgXCJuZGtcIik7XG4gICAgSSh0aGlzLCBcInJlbGF5U3Vic2NyaXB0aW9uc1wiKTtcbiAgICBJKHRoaXMsIFwiZGVidWdcIik7XG4gICAgSSh0aGlzLCBcImV2ZW50Rmlyc3RTZWVuXCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICAgIEkodGhpcywgXCJlb3Nlc1NlZW5cIiwgLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSk7XG4gICAgSSh0aGlzLCBcImV2ZW50c1BlclJlbGF5XCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICAgIEkodGhpcywgXCJlb3NlVGltZW91dFwiKTtcbiAgICBpZiAodGhpcy5uZGsgPSBlLCB0aGlzLm9wdHMgPSB7IC4uLlBkLCAuLi5uIHx8IHt9IH0sIHRoaXMuc3ViSWQgPSBzIHx8IChuID09IG51bGwgPyB2b2lkIDAgOiBuLnN1YklkKSB8fCBxZChyKSwgdGhpcy5maWx0ZXIgPSByLCB0aGlzLnJlbGF5U2V0ID0gaSwgdGhpcy5yZWxheVN1YnNjcmlwdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCB0aGlzLmRlYnVnID0gZS5kZWJ1Zy5leHRlbmQoYHN1YnNjcmlwdGlvbjoke3RoaXMuc3ViSWR9YCksIHRoaXMub3B0cy5jYWNoZVVzYWdlID09PSBcIk9OTFlfQ0FDSEVcIiAmJiAhdGhpcy5vcHRzLmNsb3NlT25Fb3NlKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHVzZSBjYWNoZS1vbmx5IG9wdGlvbnMgd2l0aCBhIHBlcnNpc3RlbnQgc3Vic2NyaXB0aW9uXCIpO1xuICB9XG4gIGdyb3VwYWJsZUlkKCkge1xuICAgIHZhciBpLCBzO1xuICAgIGlmICghKChpID0gdGhpcy5vcHRzKSAhPSBudWxsICYmIGkuZ3JvdXBhYmxlKSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNvbnN0IGUgPSAoKChzID0gdGhpcy5maWx0ZXIua2luZHMpID09IG51bGwgPyB2b2lkIDAgOiBzLmxlbmd0aCkgfHwgMCkgPiAwLCByID0gIXRoaXMuZmlsdGVyLnNpbmNlICYmICF0aGlzLmZpbHRlci51bnRpbCwgbiA9ICF0aGlzLmZpbHRlci5saW1pdDtcbiAgICBpZiAoZSAmJiByICYmIG4pIHtcbiAgICAgIGxldCBvID0gdGhpcy5maWx0ZXIua2luZHMuam9pbihcIixcIik7XG4gICAgICBjb25zdCBhID0gT2JqZWN0LmtleXModGhpcy5maWx0ZXIgfHwge30pLnNvcnQoKS5qb2luKFwiLVwiKTtcbiAgICAgIHJldHVybiBvICs9IGAtJHthfWAsIG87XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHNob3VsZFF1ZXJ5Q2FjaGUoKSB7XG4gICAgdmFyIGU7XG4gICAgcmV0dXJuICgoZSA9IHRoaXMub3B0cykgPT0gbnVsbCA/IHZvaWQgMCA6IGUuY2FjaGVVc2FnZSkgIT09IFwiT05MWV9SRUxBWVwiO1xuICB9XG4gIHNob3VsZFF1ZXJ5UmVsYXlzKCkge1xuICAgIHZhciBlO1xuICAgIHJldHVybiAoKGUgPSB0aGlzLm9wdHMpID09IG51bGwgPyB2b2lkIDAgOiBlLmNhY2hlVXNhZ2UpICE9PSBcIk9OTFlfQ0FDSEVcIjtcbiAgfVxuICBzaG91bGRXYWl0Rm9yQ2FjaGUoKSB7XG4gICAgdmFyIGU7XG4gICAgcmV0dXJuIHRoaXMub3B0cy5jbG9zZU9uRW9zZSAmJiAhISgoZSA9IHRoaXMubmRrLmNhY2hlQWRhcHRlcikgIT0gbnVsbCAmJiBlLmxvY2tpbmcpICYmIHRoaXMuc2hvdWxkUXVlcnlSZWxheXMoKSAmJiB0aGlzLm9wdHMuY2FjaGVVc2FnZSAhPT0gXCJQQVJBTExFTFwiO1xuICB9XG4gIGFzeW5jIHN0YXJ0KCkge1xuICAgIGxldCBlO1xuICAgIGlmICh0aGlzLnNob3VsZFF1ZXJ5Q2FjaGUoKSAmJiAoZSA9IHRoaXMuc3RhcnRXaXRoQ2FjaGUoKSwgdGhpcy5zaG91bGRXYWl0Rm9yQ2FjaGUoKSAmJiAoYXdhaXQgZSwgSWQodGhpcykpKSkge1xuICAgICAgdGhpcy5kZWJ1ZyhcImNhY2hlIGhpdCwgZnVsbHkgZmlsbGVkOiBza2lwcGluZyByZWxheSBxdWVyeVwiKSwgdGhpcy5lbWl0KFwiZW9zZVwiLCB0aGlzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zaG91bGRRdWVyeVJlbGF5cygpICYmIHRoaXMuc3RhcnRXaXRoUmVsYXlTZXQoKTtcbiAgfVxuICBzdG9wKCkge1xuICAgIHRoaXMucmVsYXlTdWJzY3JpcHRpb25zLmZvckVhY2goKGUpID0+IGUudW5zdWIoKSksIHRoaXMucmVsYXlTdWJzY3JpcHRpb25zLmNsZWFyKCksIHRoaXMuZW1pdChcImNsb3NlXCIsIHRoaXMpO1xuICB9XG4gIGFzeW5jIHN0YXJ0V2l0aENhY2hlKCkge1xuICAgIHZhciBlO1xuICAgIGlmICgoZSA9IHRoaXMubmRrLmNhY2hlQWRhcHRlcikgIT0gbnVsbCAmJiBlLnF1ZXJ5KSB7XG4gICAgICBjb25zdCByID0gdGhpcy5uZGsuY2FjaGVBZGFwdGVyLnF1ZXJ5KHRoaXMpO1xuICAgICAgdGhpcy5uZGsuY2FjaGVBZGFwdGVyLmxvY2tpbmcgJiYgYXdhaXQgcjtcbiAgICB9XG4gIH1cbiAgc3RhcnRXaXRoUmVsYXlTZXQoKSB7XG4gICAgdGhpcy5yZWxheVNldCB8fCAodGhpcy5yZWxheVNldCA9IFVkKHRoaXMubmRrLCB0aGlzLmZpbHRlcikpLCB0aGlzLnJlbGF5U2V0ICYmIHRoaXMucmVsYXlTZXQuc3Vic2NyaWJlKHRoaXMpO1xuICB9XG4gIGV2ZW50UmVjZWl2ZWQoZSwgciwgbiA9ICExKSB7XG4gICAgaWYgKCFuICYmIHIpIHtcbiAgICAgIGxldCBpID0gdGhpcy5ldmVudHNQZXJSZWxheS5nZXQocik7XG4gICAgICBpZiAoaSB8fCAoaSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksIHRoaXMuZXZlbnRzUGVyUmVsYXkuc2V0KHIsIGkpKSwgaS5hZGQoZS5pZCksIHRoaXMuZXZlbnRGaXJzdFNlZW4uaGFzKGUuaWQpKSB7XG4gICAgICAgIGNvbnN0IG8gPSBEYXRlLm5vdygpIC0gKHRoaXMuZXZlbnRGaXJzdFNlZW4uZ2V0KGUuaWQpIHx8IDApO1xuICAgICAgICByLnNjb3JlU2xvd2VyRXZlbnQobyksIHRoaXMuZW1pdChcImV2ZW50OmR1cFwiLCBlLCByLCBvLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5uZGsuY2FjaGVBZGFwdGVyICYmIHRoaXMubmRrLmNhY2hlQWRhcHRlci5zZXRFdmVudChlLCB0aGlzLmZpbHRlciksIHRoaXMuZXZlbnRGaXJzdFNlZW4uc2V0KGAke2UuaWR9YCwgRGF0ZS5ub3coKSk7XG4gICAgfSBlbHNlXG4gICAgICB0aGlzLmV2ZW50Rmlyc3RTZWVuLnNldChgJHtlLmlkfWAsIDApO1xuICAgIHRoaXMuZW1pdChcImV2ZW50XCIsIGUsIHIsIHRoaXMpO1xuICB9XG4gIGVvc2VSZWNlaXZlZChlKSB7XG4gICAgdmFyIG4sIGksIHM7XG4gICAgKG4gPSB0aGlzLm9wdHMpICE9IG51bGwgJiYgbi5jbG9zZU9uRW9zZSAmJiAoKGkgPSB0aGlzLnJlbGF5U3Vic2NyaXB0aW9ucy5nZXQoZSkpID09IG51bGwgfHwgaS51bnN1YigpLCB0aGlzLnJlbGF5U3Vic2NyaXB0aW9ucy5kZWxldGUoZSksIHRoaXMucmVsYXlTdWJzY3JpcHRpb25zLnNpemUgPT09IDAgJiYgdGhpcy5lbWl0KFwiY2xvc2VcIiwgdGhpcykpLCB0aGlzLmVvc2VzU2Vlbi5hZGQoZSksIHRoaXMuZW9zZXNTZWVuLnNpemUgPT09ICgocyA9IHRoaXMucmVsYXlTZXQpID09IG51bGwgPyB2b2lkIDAgOiBzLnNpemUoKSkgPyB0aGlzLmVtaXQoXCJlb3NlXCIpIDogKHRoaXMuZW9zZVRpbWVvdXQgJiYgY2xlYXJUaW1lb3V0KHRoaXMuZW9zZVRpbWVvdXQpLCB0aGlzLmVvc2VUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoXCJlb3NlXCIpO1xuICAgIH0sIDUwMCkpO1xuICB9XG59LCBCZCA9IGNsYXNzIGV4dGVuZHMgUGEge1xuICBjb25zdHJ1Y3RvcihlLCByKSB7XG4gICAgY29uc3QgbiA9IGUuZGVidWcuZXh0ZW5kKFwic3Vic2NyaXB0aW9uLWdyb3VwXCIpLCBpID0gTGQoci5tYXAoKHMpID0+IHMuZmlsdGVyKSk7XG4gICAgc3VwZXIoXG4gICAgICBlLFxuICAgICAgaSxcbiAgICAgIHJbMF0ub3B0cyxcbiAgICAgIHJbMF0ucmVsYXlTZXRcbiAgICApO1xuICAgIEkodGhpcywgXCJzdWJzY3JpcHRpb25zXCIpO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IHIsIG4oXCJtZXJnZWQgZmlsdGVyc1wiLCB7XG4gICAgICBjb3VudDogci5sZW5ndGgsXG4gICAgICBtZXJnZWRGaWx0ZXJzOiB0aGlzLmZpbHRlclxuICAgIH0pLCB0aGlzLm9uKFwiZXZlbnRcIiwgdGhpcy5mb3J3YXJkRXZlbnQpLCB0aGlzLm9uKFwiZXZlbnQ6ZHVwXCIsIHRoaXMuZm9yd2FyZEV2ZW50RHVwKSwgdGhpcy5vbihcImVvc2VcIiwgdGhpcy5mb3J3YXJkRW9zZSksIHRoaXMub24oXCJjbG9zZVwiLCB0aGlzLmZvcndhcmRDbG9zZSk7XG4gIH1cbiAgaXNFdmVudEZvclN1YnNjcmlwdGlvbihlLCByKSB7XG4gICAgY29uc3QgeyBmaWx0ZXI6IG4gfSA9IHI7XG4gICAgcmV0dXJuIG4gPyB5YShuLCBlLnJhd0V2ZW50KCkpIDogITE7XG4gIH1cbiAgZm9yd2FyZEV2ZW50KGUsIHIpIHtcbiAgICBmb3IgKGNvbnN0IG4gb2YgdGhpcy5zdWJzY3JpcHRpb25zKVxuICAgICAgIXRoaXMuaXNFdmVudEZvclN1YnNjcmlwdGlvbihlLCBuKSB8fCBuLmVtaXQoXCJldmVudFwiLCBlLCByLCBuKTtcbiAgfVxuICBmb3J3YXJkRXZlbnREdXAoZSwgciwgbikge1xuICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLnN1YnNjcmlwdGlvbnMpXG4gICAgICAhdGhpcy5pc0V2ZW50Rm9yU3Vic2NyaXB0aW9uKGUsIGkpIHx8IGkuZW1pdChcImV2ZW50OmR1cFwiLCBlLCByLCBuLCBpKTtcbiAgfVxuICBmb3J3YXJkRW9zZSgpIHtcbiAgICBmb3IgKGNvbnN0IGUgb2YgdGhpcy5zdWJzY3JpcHRpb25zKVxuICAgICAgZS5lbWl0KFwiZW9zZVwiLCBlKTtcbiAgfVxuICBmb3J3YXJkQ2xvc2UoKSB7XG4gICAgZm9yIChjb25zdCBlIG9mIHRoaXMuc3Vic2NyaXB0aW9ucylcbiAgICAgIGUuZW1pdChcImNsb3NlXCIsIGUpO1xuICB9XG59O1xuZnVuY3Rpb24gTGQodCkge1xuICBjb25zdCBlID0ge307XG4gIHJldHVybiB0LmZvckVhY2goKHIpID0+IHtcbiAgICBPYmplY3QuZW50cmllcyhyKS5mb3JFYWNoKChbbiwgaV0pID0+IHtcbiAgICAgIEFycmF5LmlzQXJyYXkoaSkgPyBlW25dID09PSB2b2lkIDAgPyBlW25dID0gWy4uLmldIDogZVtuXSA9IEFycmF5LmZyb20oLyogQF9fUFVSRV9fICovIG5ldyBTZXQoWy4uLmVbbl0sIC4uLmldKSkgOiBlW25dID0gaTtcbiAgICB9KTtcbiAgfSksIGU7XG59XG5mdW5jdGlvbiAkZCh0KSB7XG4gIGxldCBlO1xuICB0cnkge1xuICAgIHN3aXRjaCAoZSA9IHdlLmRlY29kZSh0KSwgZS50eXBlKSB7XG4gICAgICBjYXNlIFwibmV2ZW50XCI6XG4gICAgICAgIHJldHVybiB7IGlkczogW2UuZGF0YS5pZF0gfTtcbiAgICAgIGNhc2UgXCJub3RlXCI6XG4gICAgICAgIHJldHVybiB7IGlkczogW2UuZGF0YV0gfTtcbiAgICAgIGNhc2UgXCJuYWRkclwiOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGF1dGhvcnM6IFtlLmRhdGEucHVia2V5XSxcbiAgICAgICAgICBcIiNkXCI6IFtlLmRhdGEuaWRlbnRpZmllcl0sXG4gICAgICAgICAga2luZHM6IFtlLmRhdGEua2luZF1cbiAgICAgICAgfTtcbiAgICB9XG4gIH0gY2F0Y2gge1xuICB9XG4gIHJldHVybiB7IGlkczogW3RdIH07XG59XG5mdW5jdGlvbiBxZCh0KSB7XG4gIGNvbnN0IGUgPSBPYmplY3Qua2V5cyh0KSB8fCBbXSwgciA9IFtdO1xuICBmb3IgKGNvbnN0IG4gb2YgZSlcbiAgICBpZiAobiA9PT0gXCJraW5kc1wiKSB7XG4gICAgICBjb25zdCBpID0gW24sIHQua2luZHMuam9pbihcIixcIildO1xuICAgICAgci5wdXNoKGkuam9pbihcIjpcIikpO1xuICAgIH0gZWxzZVxuICAgICAgci5wdXNoKG4pO1xuICByZXR1cm4gci5wdXNoKE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDk5OTk5OTk5OSkudG9TdHJpbmcoKSksIHIuam9pbihcIi1cIik7XG59XG52YXIgR3IgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHQsIGUpIHtcbiAgICBJKHRoaXMsIFwicmVsYXlzXCIpO1xuICAgIEkodGhpcywgXCJkZWJ1Z1wiKTtcbiAgICBJKHRoaXMsIFwibmRrXCIpO1xuICAgIHRoaXMucmVsYXlzID0gdCwgdGhpcy5uZGsgPSBlLCB0aGlzLmRlYnVnID0gZS5kZWJ1Zy5leHRlbmQoXCJyZWxheXNldFwiKTtcbiAgfVxuICBzdGF0aWMgZnJvbVJlbGF5VXJscyh0LCBlKSB7XG4gICAgY29uc3QgciA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgZm9yIChjb25zdCBuIG9mIHQpIHtcbiAgICAgIGNvbnN0IGkgPSBlLnBvb2wucmVsYXlzLmdldChuKTtcbiAgICAgIGkgJiYgci5hZGQoaSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgR3IobmV3IFNldChyKSwgZSk7XG4gIH1cbiAgc3Vic2NyaWJlT25SZWxheSh0LCBlKSB7XG4gICAgY29uc3QgciA9IHQuc3Vic2NyaWJlKGUpO1xuICAgIGUucmVsYXlTdWJzY3JpcHRpb25zLnNldCh0LCByKTtcbiAgfVxuICBnZXRJZCgpIHtcbiAgICBjb25zdCBlID0gQXJyYXkuZnJvbSh0aGlzLnJlbGF5cykubWFwKChyKSA9PiByLnVybCkuc29ydCgpLmpvaW4oXCIsXCIpO1xuICAgIHJldHVybiBuaShqcihlKSk7XG4gIH1cbiAgc3Vic2NyaWJlKHQpIHtcbiAgICBjb25zdCBlID0gdC5ncm91cGFibGVJZCgpLCByID0gYCR7dGhpcy5nZXRJZCgpfToke2V9YDtcbiAgICBpZiAoIWUpXG4gICAgICByZXR1cm4gdGhpcy5leGVjdXRlU3Vic2NyaXB0aW9uKHQpLCB0O1xuICAgIGNvbnN0IG4gPSB0aGlzLm5kay5kZWxheWVkU3Vic2NyaXB0aW9ucy5nZXQocik7XG4gICAgcmV0dXJuIG4gPyBuLnB1c2godCkgOiAoc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmV4ZWN1dGVEZWxheWVkU3Vic2NyaXB0aW9uKHIpO1xuICAgIH0sIHQub3B0cy5ncm91cGFibGVEZWxheSksIHRoaXMubmRrLmRlbGF5ZWRTdWJzY3JpcHRpb25zLnNldChyLCBbdF0pKSwgdDtcbiAgfVxuICBleGVjdXRlRGVsYXllZFN1YnNjcmlwdGlvbih0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMubmRrLmRlbGF5ZWRTdWJzY3JpcHRpb25zLmdldCh0KTtcbiAgICB0aGlzLm5kay5kZWxheWVkU3Vic2NyaXB0aW9ucy5kZWxldGUodCksIGUgJiYgKGUubGVuZ3RoID4gMSA/IHRoaXMuZXhlY3V0ZVN1YnNjcmlwdGlvbnMoZSkgOiB0aGlzLmV4ZWN1dGVTdWJzY3JpcHRpb24oZVswXSkpO1xuICB9XG4gIGV4ZWN1dGVTdWJzY3JpcHRpb25zKHQpIHtcbiAgICBjb25zdCBlID0gdFswXS5uZGssIHIgPSBuZXcgQmQoZSwgdCk7XG4gICAgdGhpcy5leGVjdXRlU3Vic2NyaXB0aW9uKHIpO1xuICB9XG4gIGV4ZWN1dGVTdWJzY3JpcHRpb24odCkge1xuICAgIHRoaXMuZGVidWcoXCJzdWJzY3JpYmluZ1wiLCB7IGZpbHRlcjogdC5maWx0ZXIgfSk7XG4gICAgZm9yIChjb25zdCBlIG9mIHRoaXMucmVsYXlzKVxuICAgICAgaWYgKGUuc3RhdHVzID09PSAxKVxuICAgICAgICB0aGlzLnN1YnNjcmliZU9uUmVsYXkoZSwgdCk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgciA9ICgpID0+IHtcbiAgICAgICAgICB0aGlzLmRlYnVnKFwibmV3IHJlbGF5IGNvbWluZyBvbmxpbmUgZm9yIGFjdGl2ZSBzdWJzY3JpcHRpb25cIiwge1xuICAgICAgICAgICAgcmVsYXk6IGUudXJsLFxuICAgICAgICAgICAgZmlsdGVyOiB0LmZpbHRlclxuICAgICAgICAgIH0pLCB0aGlzLnN1YnNjcmliZU9uUmVsYXkoZSwgdCk7XG4gICAgICAgIH07XG4gICAgICAgIGUub25jZShcImNvbm5lY3RcIiwgciksIHQub25jZShcImNsb3NlXCIsICgpID0+IHtcbiAgICAgICAgICBlLnJlbW92ZUxpc3RlbmVyKFwiY29ubmVjdFwiLCByKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgcmV0dXJuIHQ7XG4gIH1cbiAgYXN5bmMgcHVibGlzaCh0LCBlKSB7XG4gICAgY29uc3QgciA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksIG4gPSBBcnJheS5mcm9tKHRoaXMucmVsYXlzKS5tYXAoKGkpID0+IG5ldyBQcm9taXNlKChzKSA9PiB7XG4gICAgICBpLnB1Ymxpc2godCwgZSkudGhlbigoKSA9PiB7XG4gICAgICAgIHIuYWRkKGkpLCBzKCk7XG4gICAgICB9KS5jYXRjaCgobykgPT4ge1xuICAgICAgICB0aGlzLmRlYnVnKFwiZXJyb3IgcHVibGlzaGluZyB0byByZWxheVwiLCB7IHJlbGF5OiBpLnVybCwgZXJyOiBvIH0pLCBzKCk7XG4gICAgICB9KTtcbiAgICB9KSk7XG4gICAgaWYgKGF3YWl0IFByb21pc2UuYWxsKG4pLCByLnNpemUgPT09IDApXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyByZWxheSB3YXMgYWJsZSB0byByZWNlaXZlIHRoZSBldmVudFwiKTtcbiAgICByZXR1cm4gcjtcbiAgfVxuICBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLnJlbGF5cy5zaXplO1xuICB9XG59O1xuZnVuY3Rpb24gTmQodCwgZSkge1xuICB2YXIgbjtcbiAgY29uc3QgciA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIHJldHVybiAobiA9IHQucG9vbCkgPT0gbnVsbCB8fCBuLnJlbGF5cy5mb3JFYWNoKChpKSA9PiByLmFkZChpKSksIG5ldyBHcihyLCB0KTtcbn1cbmZ1bmN0aW9uIFVkKHQsIGUpIHtcbiAgdmFyIG47XG4gIGNvbnN0IHIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICByZXR1cm4gKG4gPSB0LnBvb2wpID09IG51bGwgfHwgbi5yZWxheXMuZm9yRWFjaCgoaSkgPT4ge1xuICAgIGkuY29tcGxhaW5pbmcgPyB0LmRlYnVnKGBSZWxheSAke2kudXJsfSBpcyBjb21wbGFpbmluZywgbm90IGFkZGluZyB0byBzZXRgKSA6IHIuYWRkKGkpO1xuICB9KSwgbmV3IEdyKHIsIHQpO1xufVxudmFyIGpkID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBJKHRoaXMsIFwiX3VzZXJQcm9taXNlXCIpO1xuICAgIEkodGhpcywgXCJuaXAwNFF1ZXVlXCIsIFtdKTtcbiAgICBJKHRoaXMsIFwibmlwMDRQcm9jZXNzaW5nXCIsICExKTtcbiAgICBJKHRoaXMsIFwiZGVidWdcIik7XG4gICAgaWYgKCF3aW5kb3cubm9zdHIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOSVAtMDcgZXh0ZW5zaW9uIG5vdCBhdmFpbGFibGVcIik7XG4gICAgdGhpcy5kZWJ1ZyA9IE1uKFwibmRrOm5pcDA3XCIpO1xuICB9XG4gIGFzeW5jIGJsb2NrVW50aWxSZWFkeSgpIHtcbiAgICB2YXIgZTtcbiAgICBjb25zdCB0ID0gYXdhaXQgKChlID0gd2luZG93Lm5vc3RyKSA9PSBudWxsID8gdm9pZCAwIDogZS5nZXRQdWJsaWNLZXkoKSk7XG4gICAgaWYgKCF0KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVXNlciByZWplY3RlZCBhY2Nlc3NcIik7XG4gICAgcmV0dXJuIG5ldyBwZSh7IGhleHB1YmtleTogdCB9KTtcbiAgfVxuICBhc3luYyB1c2VyKCkge1xuICAgIHJldHVybiB0aGlzLl91c2VyUHJvbWlzZSB8fCAodGhpcy5fdXNlclByb21pc2UgPSB0aGlzLmJsb2NrVW50aWxSZWFkeSgpKSwgdGhpcy5fdXNlclByb21pc2U7XG4gIH1cbiAgYXN5bmMgc2lnbih0KSB7XG4gICAgaWYgKCF3aW5kb3cubm9zdHIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOSVAtMDcgZXh0ZW5zaW9uIG5vdCBhdmFpbGFibGVcIik7XG4gICAgcmV0dXJuIChhd2FpdCB3aW5kb3cubm9zdHIuc2lnbkV2ZW50KHQpKS5zaWc7XG4gIH1cbiAgYXN5bmMgZW5jcnlwdCh0LCBlKSB7XG4gICAgaWYgKCF3aW5kb3cubm9zdHIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOSVAtMDcgZXh0ZW5zaW9uIG5vdCBhdmFpbGFibGVcIik7XG4gICAgY29uc3QgciA9IHQuaGV4cHVia2V5KCk7XG4gICAgcmV0dXJuIHRoaXMucXVldWVOaXAwNChcImVuY3J5cHRcIiwgciwgZSk7XG4gIH1cbiAgYXN5bmMgZGVjcnlwdCh0LCBlKSB7XG4gICAgaWYgKCF3aW5kb3cubm9zdHIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOSVAtMDcgZXh0ZW5zaW9uIG5vdCBhdmFpbGFibGVcIik7XG4gICAgY29uc3QgciA9IHQuaGV4cHVia2V5KCk7XG4gICAgcmV0dXJuIHRoaXMucXVldWVOaXAwNChcImRlY3J5cHRcIiwgciwgZSk7XG4gIH1cbiAgYXN5bmMgcXVldWVOaXAwNCh0LCBlLCByKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChuLCBpKSA9PiB7XG4gICAgICB0aGlzLm5pcDA0UXVldWUucHVzaCh7IHR5cGU6IHQsIGNvdW50ZXJwYXJ0eUhleHB1YmtleTogZSwgdmFsdWU6IHIsIHJlc29sdmU6IG4sIHJlamVjdDogaSB9KSwgdGhpcy5uaXAwNFByb2Nlc3NpbmcgfHwgdGhpcy5wcm9jZXNzTmlwMDRRdWV1ZSgpO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIHByb2Nlc3NOaXAwNFF1ZXVlKHQsIGUgPSAwKSB7XG4gICAgaWYgKCF0ICYmIHRoaXMubmlwMDRRdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMubmlwMDRQcm9jZXNzaW5nID0gITE7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubmlwMDRQcm9jZXNzaW5nID0gITA7XG4gICAgY29uc3QgeyB0eXBlOiByLCBjb3VudGVycGFydHlIZXhwdWJrZXk6IG4sIHZhbHVlOiBpLCByZXNvbHZlOiBzLCByZWplY3Q6IG8gfSA9IHQgfHwgdGhpcy5uaXAwNFF1ZXVlLnNoaWZ0KCk7XG4gICAgdGhpcy5kZWJ1ZyhcIlByb2Nlc3NpbmcgZW5jcnlwdGlvbiBxdWV1ZSBpdGVtXCIsIHsgdHlwZTogciwgY291bnRlcnBhcnR5SGV4cHVia2V5OiBuLCB2YWx1ZTogaSB9KTtcbiAgICB0cnkge1xuICAgICAgbGV0IGE7XG4gICAgICByID09PSBcImVuY3J5cHRcIiA/IGEgPSBhd2FpdCB3aW5kb3cubm9zdHIubmlwMDQuZW5jcnlwdChuLCBpKSA6IGEgPSBhd2FpdCB3aW5kb3cubm9zdHIubmlwMDQuZGVjcnlwdChuLCBpKSwgcyhhKTtcbiAgICB9IGNhdGNoIChhKSB7XG4gICAgICBpZiAoYS5tZXNzYWdlICYmIGEubWVzc2FnZS5pbmNsdWRlcyhcImNhbGwgYWxyZWFkeSBleGVjdXRpbmdcIikgJiYgZSA8IDUpIHtcbiAgICAgICAgdGhpcy5kZWJ1ZyhcIlJldHJ5aW5nIGVuY3J5cHRpb24gcXVldWUgaXRlbVwiLCB7IHR5cGU6IHIsIGNvdW50ZXJwYXJ0eUhleHB1YmtleTogbiwgdmFsdWU6IGksIHJldHJpZXM6IGUgfSksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMucHJvY2Vzc05pcDA0UXVldWUodCwgZSArIDEpO1xuICAgICAgICB9LCA1MCAqIGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBvKGEpO1xuICAgIH1cbiAgICB0aGlzLnByb2Nlc3NOaXAwNFF1ZXVlKCk7XG4gIH1cbn0sIEhkID0gY2xhc3MgZXh0ZW5kcyBkdCB7XG4gIGNvbnN0cnVjdG9yKGUsIHIsIG4pIHtcbiAgICBzdXBlcigpO1xuICAgIEkodGhpcywgXCJuZGtcIik7XG4gICAgSSh0aGlzLCBcInNpZ25lclwiKTtcbiAgICBJKHRoaXMsIFwiZGVidWdcIik7XG4gICAgdGhpcy5uZGsgPSBlLCB0aGlzLnNpZ25lciA9IHIsIHRoaXMuZGVidWcgPSBuLmV4dGVuZChcInJwY1wiKTtcbiAgfVxuICBhc3luYyBzdWJzY3JpYmUoZSkge1xuICAgIGNvbnN0IHIgPSB0aGlzLm5kay5zdWJzY3JpYmUoZSwgeyBjbG9zZU9uRW9zZTogITEgfSk7XG4gICAgcmV0dXJuIHIub24oXCJldmVudFwiLCBhc3luYyAobikgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgaSA9IGF3YWl0IHRoaXMucGFyc2VFdmVudChuKTtcbiAgICAgICAgaS5tZXRob2QgPyB0aGlzLmVtaXQoXCJyZXF1ZXN0XCIsIGkpIDogdGhpcy5lbWl0KGByZXNwb25zZS0ke2kuaWR9YCwgaSk7XG4gICAgICB9IGNhdGNoIChpKSB7XG4gICAgICAgIHRoaXMuZGVidWcoXCJlcnJvciBwYXJzaW5nIGV2ZW50XCIsIGksIG4pO1xuICAgICAgfVxuICAgIH0pLCBuZXcgUHJvbWlzZSgobiwgaSkgPT4ge1xuICAgICAgci5vbihcImVvc2VcIiwgKCkgPT4gbihyKSk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgcGFyc2VFdmVudChlKSB7XG4gICAgY29uc3QgciA9IHRoaXMubmRrLmdldFVzZXIoeyBoZXhwdWJrZXk6IGUucHVia2V5IH0pO1xuICAgIHIubmRrID0gdGhpcy5uZGs7XG4gICAgY29uc3QgbiA9IGF3YWl0IHRoaXMuc2lnbmVyLmRlY3J5cHQociwgZS5jb250ZW50KSwgaSA9IEpTT04ucGFyc2UobiksIHsgaWQ6IHMsIG1ldGhvZDogbywgcGFyYW1zOiBhLCByZXN1bHQ6IGMsIGVycm9yOiBsIH0gPSBpO1xuICAgIHJldHVybiBvID8geyBpZDogcywgcHVia2V5OiBlLnB1YmtleSwgbWV0aG9kOiBvLCBwYXJhbXM6IGEsIGV2ZW50OiBlIH0gOiB7IGlkOiBzLCByZXN1bHQ6IGMsIGVycm9yOiBsLCBldmVudDogZSB9O1xuICB9XG4gIGFzeW5jIHNlbmRSZXNwb25zZShlLCByLCBuLCBpID0gMjQxMzMsIHMpIHtcbiAgICBjb25zdCBvID0geyBpZDogZSwgcmVzdWx0OiBuIH07XG4gICAgcyAmJiAoby5lcnJvciA9IHMpO1xuICAgIGNvbnN0IGEgPSBhd2FpdCB0aGlzLnNpZ25lci51c2VyKCksIGMgPSB0aGlzLm5kay5nZXRVc2VyKHsgaGV4cHVia2V5OiByIH0pLCBsID0gbmV3IHFlKHRoaXMubmRrLCB7XG4gICAgICBraW5kOiBpLFxuICAgICAgY29udGVudDogSlNPTi5zdHJpbmdpZnkobyksXG4gICAgICB0YWdzOiBbW1wicFwiLCByXV0sXG4gICAgICBwdWJrZXk6IGEuaGV4cHVia2V5KClcbiAgICB9KTtcbiAgICBsLmNvbnRlbnQgPSBhd2FpdCB0aGlzLnNpZ25lci5lbmNyeXB0KGMsIGwuY29udGVudCksIGF3YWl0IGwuc2lnbih0aGlzLnNpZ25lciksIGF3YWl0IHRoaXMubmRrLnB1Ymxpc2gobCk7XG4gIH1cbiAgYXN5bmMgc2VuZFJlcXVlc3QoZSwgciwgbiA9IFtdLCBpID0gMjQxMzMsIHMpIHtcbiAgICBjb25zdCBvID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDcpLCBhID0gYXdhaXQgdGhpcy5zaWduZXIudXNlcigpLCBjID0gdGhpcy5uZGsuZ2V0VXNlcih7IGhleHB1YmtleTogZSB9KSwgbCA9IHsgaWQ6IG8sIG1ldGhvZDogciwgcGFyYW1zOiBuIH0sIGYgPSBuZXcgUHJvbWlzZSgoaCkgPT4ge1xuICAgICAgcyAmJiB0aGlzLm9uY2UoYHJlc3BvbnNlLSR7b31gLCBzKTtcbiAgICB9KSwgdSA9IG5ldyBxZSh0aGlzLm5kaywge1xuICAgICAga2luZDogaSxcbiAgICAgIGNvbnRlbnQ6IEpTT04uc3RyaW5naWZ5KGwpLFxuICAgICAgdGFnczogW1tcInBcIiwgZV1dLFxuICAgICAgcHVia2V5OiBhLmhleHB1YmtleSgpXG4gICAgfSk7XG4gICAgcmV0dXJuIHUuY29udGVudCA9IGF3YWl0IHRoaXMuc2lnbmVyLmVuY3J5cHQoYywgdS5jb250ZW50KSwgYXdhaXQgdS5zaWduKHRoaXMuc2lnbmVyKSwgdGhpcy5kZWJ1ZyhcInNlbmRpbmcgcmVxdWVzdCB0b1wiLCBlKSwgYXdhaXQgdGhpcy5uZGsucHVibGlzaCh1KSwgZjtcbiAgfVxufSwgTWQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHQsIGUsIHIpIHtcbiAgICBJKHRoaXMsIFwibmRrXCIpO1xuICAgIEkodGhpcywgXCJyZW1vdGVVc2VyXCIpO1xuICAgIEkodGhpcywgXCJyZW1vdGVQdWJrZXlcIik7XG4gICAgSSh0aGlzLCBcInRva2VuXCIpO1xuICAgIEkodGhpcywgXCJsb2NhbFNpZ25lclwiKTtcbiAgICBJKHRoaXMsIFwicnBjXCIpO1xuICAgIEkodGhpcywgXCJkZWJ1Z1wiKTtcbiAgICBsZXQgbiwgaTtcbiAgICBpZiAoZS5pbmNsdWRlcyhcIiNcIikpIHtcbiAgICAgIGNvbnN0IHMgPSBlLnNwbGl0KFwiI1wiKTtcbiAgICAgIG4gPSBuZXcgcGUoeyBucHViOiBzWzBdIH0pLmhleHB1YmtleSgpLCBpID0gc1sxXTtcbiAgICB9IGVsc2VcbiAgICAgIGUuc3RhcnRzV2l0aChcIm5wdWJcIikgPyBuID0gbmV3IHBlKHsgbnB1YjogZSB9KS5oZXhwdWJrZXkoKSA6IG4gPSBlO1xuICAgIHRoaXMubmRrID0gdCwgdGhpcy5yZW1vdGVQdWJrZXkgPSBuLCB0aGlzLnRva2VuID0gaSwgdGhpcy5kZWJ1ZyA9IHQuZGVidWcuZXh0ZW5kKFwibmlwNDY6c2lnbmVyXCIpLCB0aGlzLnJlbW90ZVVzZXIgPSBuZXcgcGUoeyBoZXhwdWJrZXk6IG4gfSksIHIgPyB0aGlzLmxvY2FsU2lnbmVyID0gciA6IHRoaXMubG9jYWxTaWduZXIgPSBvci5nZW5lcmF0ZSgpLCB0aGlzLnJwYyA9IG5ldyBIZCh0LCB0aGlzLmxvY2FsU2lnbmVyLCB0aGlzLmRlYnVnKTtcbiAgfVxuICBhc3luYyB1c2VyKCkge1xuICAgIHJldHVybiB0aGlzLnJlbW90ZVVzZXI7XG4gIH1cbiAgYXN5bmMgYmxvY2tVbnRpbFJlYWR5KCkge1xuICAgIGNvbnN0IHQgPSBhd2FpdCB0aGlzLmxvY2FsU2lnbmVyLnVzZXIoKSwgZSA9IHRoaXMubmRrLmdldFVzZXIoeyBucHViOiB0Lm5wdWIgfSk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMucnBjLnN1YnNjcmliZSh7XG4gICAgICBraW5kczogWzI0MTMzXSxcbiAgICAgIFwiI3BcIjogW3QuaGV4cHVia2V5KCldXG4gICAgfSksIG5ldyBQcm9taXNlKChyLCBuKSA9PiB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY29uc3QgaSA9IFt0LmhleHB1YmtleSgpXTtcbiAgICAgICAgdGhpcy50b2tlbiAmJiBpLnB1c2godGhpcy50b2tlbiksIHRoaXMucnBjLnNlbmRSZXF1ZXN0KFxuICAgICAgICAgIHRoaXMucmVtb3RlUHVia2V5LFxuICAgICAgICAgIFwiY29ubmVjdFwiLFxuICAgICAgICAgIGksXG4gICAgICAgICAgMjQxMzMsXG4gICAgICAgICAgKHMpID0+IHtcbiAgICAgICAgICAgIHMucmVzdWx0ID09PSBcImFja1wiID8gcihlKSA6IG4ocy5lcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfSwgMTAwKTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBlbmNyeXB0KHQsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5kZWJ1ZyhcImFza2luZyBmb3IgZW5jcnlwdGlvblwiKSwgbmV3IFByb21pc2UoKG4sIGkpID0+IHtcbiAgICAgIHRoaXMucnBjLnNlbmRSZXF1ZXN0KFxuICAgICAgICB0aGlzLnJlbW90ZVB1YmtleSxcbiAgICAgICAgXCJuaXAwNF9lbmNyeXB0XCIsXG4gICAgICAgIFt0LmhleHB1YmtleSgpLCBlXSxcbiAgICAgICAgMjQxMzMsXG4gICAgICAgIChzKSA9PiB7XG4gICAgICAgICAgcy5lcnJvciA/IGkocy5lcnJvcikgOiBuKHMucmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBkZWNyeXB0KHQsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5kZWJ1ZyhcImFza2luZyBmb3IgZGVjcnlwdGlvblwiKSwgbmV3IFByb21pc2UoKG4sIGkpID0+IHtcbiAgICAgIHRoaXMucnBjLnNlbmRSZXF1ZXN0KFxuICAgICAgICB0aGlzLnJlbW90ZVB1YmtleSxcbiAgICAgICAgXCJuaXAwNF9kZWNyeXB0XCIsXG4gICAgICAgIFt0LmhleHB1YmtleSgpLCBlXSxcbiAgICAgICAgMjQxMzMsXG4gICAgICAgIChzKSA9PiB7XG4gICAgICAgICAgaWYgKHMuZXJyb3IpXG4gICAgICAgICAgICBpKHMuZXJyb3IpO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbyA9IEpTT04ucGFyc2Uocy5yZXN1bHQpO1xuICAgICAgICAgICAgbihvWzBdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgc2lnbih0KSB7XG4gICAgcmV0dXJuIHRoaXMuZGVidWcoXCJhc2tpbmcgZm9yIGEgc2lnbmF0dXJlXCIpLCBuZXcgUHJvbWlzZSgociwgbikgPT4ge1xuICAgICAgdGhpcy5ycGMuc2VuZFJlcXVlc3QoXG4gICAgICAgIHRoaXMucmVtb3RlUHVia2V5LFxuICAgICAgICBcInNpZ25fZXZlbnRcIixcbiAgICAgICAgW0pTT04uc3RyaW5naWZ5KHQpXSxcbiAgICAgICAgMjQxMzMsXG4gICAgICAgIChpKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuZGVidWcoXCJnb3QgYSByZXNwb25zZVwiLCBpKSwgaS5lcnJvcilcbiAgICAgICAgICAgIG4oaS5lcnJvcik7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzID0gSlNPTi5wYXJzZShpLnJlc3VsdCk7XG4gICAgICAgICAgICByKHMuc2lnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSk7XG4gIH1cbn0sIG9yID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgSSh0aGlzLCBcIl91c2VyXCIpO1xuICAgIEkodGhpcywgXCJwcml2YXRlS2V5XCIpO1xuICAgIHQgJiYgKHRoaXMucHJpdmF0ZUtleSA9IHQsIHRoaXMuX3VzZXIgPSBuZXcgcGUoeyBoZXhwdWJrZXk6IGxpKHRoaXMucHJpdmF0ZUtleSkgfSkpO1xuICB9XG4gIHN0YXRpYyBnZW5lcmF0ZSgpIHtcbiAgICBjb25zdCB0ID0geWYoKTtcbiAgICByZXR1cm4gbmV3IG9yKHQpO1xuICB9XG4gIGFzeW5jIGJsb2NrVW50aWxSZWFkeSgpIHtcbiAgICBpZiAoIXRoaXMuX3VzZXIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOREtVc2VyIG5vdCBpbml0aWFsaXplZFwiKTtcbiAgICByZXR1cm4gdGhpcy5fdXNlcjtcbiAgfVxuICBhc3luYyB1c2VyKCkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmJsb2NrVW50aWxSZWFkeSgpLCB0aGlzLl91c2VyO1xuICB9XG4gIGFzeW5jIHNpZ24odCkge1xuICAgIGlmICghdGhpcy5wcml2YXRlS2V5KVxuICAgICAgdGhyb3cgRXJyb3IoXCJBdHRlbXB0ZWQgdG8gc2lnbiB3aXRob3V0IGEgcHJpdmF0ZSBrZXlcIik7XG4gICAgcmV0dXJuIHBhKHQsIHRoaXMucHJpdmF0ZUtleSk7XG4gIH1cbiAgYXN5bmMgZW5jcnlwdCh0LCBlKSB7XG4gICAgaWYgKCF0aGlzLnByaXZhdGVLZXkpXG4gICAgICB0aHJvdyBFcnJvcihcIkF0dGVtcHRlZCB0byBlbmNyeXB0IHdpdGhvdXQgYSBwcml2YXRlIGtleVwiKTtcbiAgICBjb25zdCByID0gdC5oZXhwdWJrZXkoKTtcbiAgICByZXR1cm4gYXdhaXQgVW4uZW5jcnlwdCh0aGlzLnByaXZhdGVLZXksIHIsIGUpO1xuICB9XG4gIGFzeW5jIGRlY3J5cHQodCwgZSkge1xuICAgIGlmICghdGhpcy5wcml2YXRlS2V5KVxuICAgICAgdGhyb3cgRXJyb3IoXCJBdHRlbXB0ZWQgdG8gZGVjcnlwdCB3aXRob3V0IGEgcHJpdmF0ZSBrZXlcIik7XG4gICAgY29uc3QgciA9IHQuaGV4cHVia2V5KCk7XG4gICAgcmV0dXJuIGF3YWl0IFVuLmRlY3J5cHQodGhpcy5wcml2YXRlS2V5LCByLCBlKTtcbiAgfVxufSwgRGQgPSBjbGFzcyBleHRlbmRzIGR0IHtcbiAgY29uc3RydWN0b3IoZSA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICBJKHRoaXMsIFwicG9vbFwiKTtcbiAgICBJKHRoaXMsIFwic2lnbmVyXCIpO1xuICAgIEkodGhpcywgXCJjYWNoZUFkYXB0ZXJcIik7XG4gICAgSSh0aGlzLCBcImRlYnVnXCIpO1xuICAgIEkodGhpcywgXCJkZXZXcml0ZVJlbGF5U2V0XCIpO1xuICAgIEkodGhpcywgXCJkZWxheWVkU3Vic2NyaXB0aW9uc1wiKTtcbiAgICB0aGlzLmRlYnVnID0gZS5kZWJ1ZyB8fCBNbihcIm5ka1wiKSwgdGhpcy5wb29sID0gbmV3IENkKGUuZXhwbGljaXRSZWxheVVybHMgfHwgW10sIHRoaXMpLCB0aGlzLnNpZ25lciA9IGUuc2lnbmVyLCB0aGlzLmNhY2hlQWRhcHRlciA9IGUuY2FjaGVBZGFwdGVyLCB0aGlzLmRlbGF5ZWRTdWJzY3JpcHRpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgZS5kZXZXcml0ZVJlbGF5VXJscyAmJiAodGhpcy5kZXZXcml0ZVJlbGF5U2V0ID0gR3IuZnJvbVJlbGF5VXJscyhlLmRldldyaXRlUmVsYXlVcmxzLCB0aGlzKSk7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7IHJlbGF5Q291bnQ6IHRoaXMucG9vbC5yZWxheXMuc2l6ZSB9LnRvU3RyaW5nKCk7XG4gIH1cbiAgYXN5bmMgY29ubmVjdChlKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVidWcoXCJDb25uZWN0aW5nIHRvIHJlbGF5c1wiLCB7IHRpbWVvdXRNczogZSB9KSwgdGhpcy5wb29sLmNvbm5lY3QoZSk7XG4gIH1cbiAgZ2V0VXNlcihlKSB7XG4gICAgY29uc3QgciA9IG5ldyBwZShlKTtcbiAgICByZXR1cm4gci5uZGsgPSB0aGlzLCByO1xuICB9XG4gIHN1YnNjcmliZShlLCByLCBuLCBpID0gITApIHtcbiAgICBjb25zdCBzID0gbmV3IFBhKHRoaXMsIGUsIHIsIG4pO1xuICAgIHJldHVybiBpICYmIHMuc3RhcnQoKSwgcztcbiAgfVxuICBhc3luYyBwdWJsaXNoKGUsIHIsIG4pIHtcbiAgICByZXR1cm4gciB8fCAociA9IHRoaXMuZGV2V3JpdGVSZWxheVNldCB8fCBOZCh0aGlzKSksIHIucHVibGlzaChlLCBuKTtcbiAgfVxuICBhc3luYyBmZXRjaEV2ZW50KGUsIHIgPSB7fSwgbikge1xuICAgIGxldCBpO1xuICAgIGlmICh0eXBlb2YgZSA9PSBcInN0cmluZ1wiID8gaSA9ICRkKGUpIDogaSA9IGUsICFpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGZpbHRlcjogJHtKU09OLnN0cmluZ2lmeShlKX1gKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHMpID0+IHtcbiAgICAgIGNvbnN0IG8gPSB0aGlzLnN1YnNjcmliZShpLCB7IC4uLnIsIGNsb3NlT25Fb3NlOiAhMCB9LCBuLCAhMSk7XG4gICAgICBvLm9uKFwiZXZlbnRcIiwgKGEpID0+IHtcbiAgICAgICAgYS5uZGsgPSB0aGlzLCBzKGEpO1xuICAgICAgfSksIG8ub24oXCJlb3NlXCIsICgpID0+IHtcbiAgICAgICAgcyhudWxsKTtcbiAgICAgIH0pLCBvLnN0YXJ0KCk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZmV0Y2hFdmVudHMoZSwgciA9IHt9LCBuKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChpKSA9PiB7XG4gICAgICBjb25zdCBzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgbyA9IHRoaXMuc3Vic2NyaWJlKGUsIHsgLi4uciwgY2xvc2VPbkVvc2U6ICEwIH0sIG4sICExKTtcbiAgICAgIG8ub24oXCJldmVudFwiLCAoYSkgPT4ge1xuICAgICAgICBjb25zdCBjID0gcy5nZXQoYS50YWdJZCgpKTtcbiAgICAgICAgYyAmJiAoYSA9IHBkKGMsIGEpKSwgYS5uZGsgPSB0aGlzLCBzLnNldChhLnRhZ0lkKCksIGEpO1xuICAgICAgfSksIG8ub24oXCJlb3NlXCIsICgpID0+IHtcbiAgICAgICAgaShuZXcgU2V0KHMudmFsdWVzKCkpKTtcbiAgICAgIH0pLCBvLnN0YXJ0KCk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgYXNzZXJ0U2lnbmVyKCkge1xuICAgIGlmICghdGhpcy5zaWduZXIpXG4gICAgICB0aHJvdyB0aGlzLmVtaXQoXCJzaWduZXJSZXF1aXJlZFwiKSwgbmV3IEVycm9yKFwiU2lnbmVyIHJlcXVpcmVkXCIpO1xuICB9XG59O1xuZnVuY3Rpb24gemQodCkge1xuICBjb25zdCBlID0gR28oITEpLCBbciwgbl0gPSBTbih2b2lkIDApLCBbaSwgc10gPSBTbih2b2lkIDApO1xuICB1YygoKSA9PiB7XG4gICAgYXN5bmMgZnVuY3Rpb24gZigpIHtcbiAgICAgIHIgPT09IHZvaWQgMCAmJiBlLmN1cnJlbnQgPT09ICExICYmIChlLmN1cnJlbnQgPSAhMCwgYXdhaXQgbyh0KSk7XG4gICAgfVxuICAgIGYoKTtcbiAgfSwgW10pO1xuICBhc3luYyBmdW5jdGlvbiBvKGYsIHUpIHtcbiAgICBjb25zdCBoID0gbmV3IERkKHsgZXhwbGljaXRSZWxheVVybHM6IGYsIHNpZ25lcjogdSB9KTtcbiAgICB1ICYmIHModSk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGguY29ubmVjdCgpLCBuKGgpO1xuICAgIH0gY2F0Y2ggKGQpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFUlJPUiBsb2FkaW5nIE5ESyBOREtJbnN0YW5jZVwiLCBkKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gYShmKSB7XG4gICAgbyh0LCBmKTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBjKGYpIHtcbiAgICByZXR1cm4gciA9PT0gdm9pZCAwID8gW10gOiBuZXcgUHJvbWlzZSgodSkgPT4ge1xuICAgICAgY29uc3QgaCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIGQgPSByLnN1YnNjcmliZShmLCB7XG4gICAgICAgIGNsb3NlT25Fb3NlOiAhMFxuICAgICAgfSk7XG4gICAgICBkLm9uKFwiZXZlbnRcIiwgKHApID0+IHtcbiAgICAgICAgcC5uZGsgPSByLCBoLnNldChwLnRhZ0lkKCksIHApO1xuICAgICAgfSksIGQub24oXCJlb3NlXCIsICgpID0+IHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB1KEFycmF5LmZyb20obmV3IFNldChoLnZhbHVlcygpKSkpLCAzZTMpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gbChmLCB1ID0ge1xuICAgIHJlcG9zdDogITEsXG4gICAgcHVibGlzaDogITBcbiAgfSkge1xuICAgIGlmIChyICE9PSB2b2lkIDApXG4gICAgICByZXR1cm4gZi5uZGsgPSByLCB1LnJlcG9zdCA/IGF3YWl0IGYucmVwb3N0KCkgOiBhd2FpdCBmLnNpZ24oKSwgdS5wdWJsaXNoICYmIGF3YWl0IGYucHVibGlzaCgpLCBmO1xuICB9XG4gIHJldHVybiB7XG4gICAgbmRrOiByLFxuICAgIHNpZ25lcjogaSxcbiAgICBsb2FkTmRrOiBvLFxuICAgIHNldFNpZ25lcjogYSxcbiAgICBmZXRjaEV2ZW50czogYyxcbiAgICBzaWduUHVibGlzaEV2ZW50OiBsXG4gIH07XG59XG5hc3luYyBmdW5jdGlvbiBGZCh0KSB7XG4gIHRyeSB7XG4gICAgbGV0IGUgPSB0O1xuICAgIGUuc3Vic3RyaW5nKDAsIDQpID09PSBcIm5zZWNcIiAmJiAoZSA9IHdlLmRlY29kZShlKS5kYXRhKTtcbiAgICBjb25zdCByID0gbmV3IG9yKGUpO1xuICAgIHJldHVybiByLnVzZXIoKS50aGVuKGFzeW5jIChuKSA9PiB7XG4gICAgICBpZiAobi5ucHViKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHVzZXI6IG4sXG4gICAgICAgICAgbnB1Yjogbi5ucHViLFxuICAgICAgICAgIHNrOiBlLFxuICAgICAgICAgIHNpZ25lcjogclxuICAgICAgICB9O1xuICAgIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgZTtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gS2QodCwgZSwgcikge1xuICB0cnkge1xuICAgIGxldCBuID0gb3IuZ2VuZXJhdGUoKTtcbiAgICByICYmIChuID0gbmV3IG9yKHIpKTtcbiAgICBjb25zdCBpID0gbmV3IE1kKHQsIGUsIG4pO1xuICAgIHJldHVybiBpLnVzZXIoKS50aGVuKGFzeW5jIChzKSA9PiB7XG4gICAgICBpZiAocy5ucHViKVxuICAgICAgICByZXR1cm4gYXdhaXQgaS5ibG9ja1VudGlsUmVhZHkoKSwge1xuICAgICAgICAgIHVzZXI6IHMsXG4gICAgICAgICAgbnB1YjogKGF3YWl0IGkudXNlcigpKS5ucHViLFxuICAgICAgICAgIHNrOiBuLnByaXZhdGVLZXksXG4gICAgICAgICAgdG9rZW46IGUsXG4gICAgICAgICAgcmVtb3RlU2lnbmVyOiBpLFxuICAgICAgICAgIGxvY2FsU2lnbmVyOiBuXG4gICAgICAgIH07XG4gICAgfSk7XG4gIH0gY2F0Y2ggKG4pIHtcbiAgICB0aHJvdyBuO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBXZCgpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCB0ID0gbmV3IGpkKCk7XG4gICAgcmV0dXJuIHQudXNlcigpLnRoZW4oYXN5bmMgKGUpID0+IHtcbiAgICAgIGlmIChlLm5wdWIpXG4gICAgICAgIHJldHVybiB7IHVzZXI6IGUsIG5wdWI6IGUubnB1Yiwgc2lnbmVyOiB0IH07XG4gICAgfSk7XG4gIH0gY2F0Y2ggKHQpIHtcbiAgICB0aHJvdyB0O1xuICB9XG59XG5jb25zdCBWZCA9ICh0KSA9PiB7XG4gIGNvbnN0IFtlLCByXSA9IFNuKHt9KSwgbiA9IEdvKHt9KTtcbiAgYXN5bmMgZnVuY3Rpb24gaShhKSB7XG4gICAgaWYgKHQgPT0gbnVsbCB8fCBuLmN1cnJlbnRbYV0pXG4gICAgICByZXR1cm47XG4gICAgbi5jdXJyZW50ID0ge1xuICAgICAgLi4ubi5jdXJyZW50LFxuICAgICAgW2FdOiBwZS5wcm90b3R5cGVcbiAgICB9O1xuICAgIGxldCBjO1xuICAgIGEuc3RhcnRzV2l0aChcIm5wdWJcIikgPyBjID0gdC5nZXRVc2VyKHtcbiAgICAgIG5wdWI6IGFcbiAgICB9KSA6IGMgPSB0LmdldFVzZXIoe1xuICAgICAgaGV4cHVia2V5OiBhXG4gICAgfSksIGF3YWl0IGMuZmV0Y2hQcm9maWxlKCksIGMucHJvZmlsZSAmJiAobi5jdXJyZW50ID0ge1xuICAgICAgLi4ubi5jdXJyZW50LFxuICAgICAgW2FdOiBjXG4gICAgfSwgcihuLmN1cnJlbnQpKTtcbiAgfVxuICBmdW5jdGlvbiBzKGEpIHtcbiAgICByZXR1cm4gZVthXSA/IGVbYV0gOiAoaShhKSwgcGUucHJvdG90eXBlKTtcbiAgfVxuICBmdW5jdGlvbiBvKGEpIHtcbiAgICByZXR1cm4gZVthXSA/IGVbYV0ucHJvZmlsZSA6IChpKGEpLCB7fSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBnZXRVc2VyOiBzLFxuICAgIGdldFByb2ZpbGU6IG9cbiAgfTtcbn07XG52YXIgQmEgPSB7IGV4cG9ydHM6IHt9IH0sIFh0ID0ge307XG4vKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtcnVudGltZS5wcm9kdWN0aW9uLm1pbi5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG52YXIgTW87XG5mdW5jdGlvbiBHZCgpIHtcbiAgaWYgKE1vKVxuICAgIHJldHVybiBYdDtcbiAgTW8gPSAxO1xuICB2YXIgdCA9IFZvLCBlID0gU3ltYm9sLmZvcihcInJlYWN0LmVsZW1lbnRcIiksIHIgPSBTeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIiksIG4gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LCBpID0gdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRC5SZWFjdEN1cnJlbnRPd25lciwgcyA9IHsga2V5OiAhMCwgcmVmOiAhMCwgX19zZWxmOiAhMCwgX19zb3VyY2U6ICEwIH07XG4gIGZ1bmN0aW9uIG8oYSwgYywgbCkge1xuICAgIHZhciBmLCB1ID0ge30sIGggPSBudWxsLCBkID0gbnVsbDtcbiAgICBsICE9PSB2b2lkIDAgJiYgKGggPSBcIlwiICsgbCksIGMua2V5ICE9PSB2b2lkIDAgJiYgKGggPSBcIlwiICsgYy5rZXkpLCBjLnJlZiAhPT0gdm9pZCAwICYmIChkID0gYy5yZWYpO1xuICAgIGZvciAoZiBpbiBjKVxuICAgICAgbi5jYWxsKGMsIGYpICYmICFzLmhhc093blByb3BlcnR5KGYpICYmICh1W2ZdID0gY1tmXSk7XG4gICAgaWYgKGEgJiYgYS5kZWZhdWx0UHJvcHMpXG4gICAgICBmb3IgKGYgaW4gYyA9IGEuZGVmYXVsdFByb3BzLCBjKVxuICAgICAgICB1W2ZdID09PSB2b2lkIDAgJiYgKHVbZl0gPSBjW2ZdKTtcbiAgICByZXR1cm4geyAkJHR5cGVvZjogZSwgdHlwZTogYSwga2V5OiBoLCByZWY6IGQsIHByb3BzOiB1LCBfb3duZXI6IGkuY3VycmVudCB9O1xuICB9XG4gIHJldHVybiBYdC5GcmFnbWVudCA9IHIsIFh0LmpzeCA9IG8sIFh0LmpzeHMgPSBvLCBYdDtcbn1cbnZhciBRdCA9IHt9O1xuLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtanN4LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xudmFyIERvO1xuZnVuY3Rpb24gWmQoKSB7XG4gIHJldHVybiBEbyB8fCAoRG8gPSAxLCBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZnVuY3Rpb24oKSB7XG4gICAgdmFyIHQgPSBWbywgZSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5lbGVtZW50XCIpLCByID0gU3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKSwgbiA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSwgaSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKSwgcyA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKSwgbyA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm92aWRlclwiKSwgYSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpLCBjID0gU3ltYm9sLmZvcihcInJlYWN0LmZvcndhcmRfcmVmXCIpLCBsID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpLCBmID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlX2xpc3RcIiksIHUgPSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb1wiKSwgaCA9IFN5bWJvbC5mb3IoXCJyZWFjdC5sYXp5XCIpLCBkID0gU3ltYm9sLmZvcihcInJlYWN0Lm9mZnNjcmVlblwiKSwgcCA9IFN5bWJvbC5pdGVyYXRvciwgeSA9IFwiQEBpdGVyYXRvclwiO1xuICAgIGZ1bmN0aW9uIGcoYikge1xuICAgICAgaWYgKGIgPT09IG51bGwgfHwgdHlwZW9mIGIgIT0gXCJvYmplY3RcIilcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgayA9IHAgJiYgYltwXSB8fCBiW3ldO1xuICAgICAgcmV0dXJuIHR5cGVvZiBrID09IFwiZnVuY3Rpb25cIiA/IGsgOiBudWxsO1xuICAgIH1cbiAgICB2YXIgdiA9IHQuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG4gICAgZnVuY3Rpb24gXyhiKSB7XG4gICAgICB7XG4gICAgICAgIGZvciAodmFyIGsgPSBhcmd1bWVudHMubGVuZ3RoLCBUID0gbmV3IEFycmF5KGsgPiAxID8gayAtIDEgOiAwKSwgJCA9IDE7ICQgPCBrOyAkKyspXG4gICAgICAgICAgVFskIC0gMV0gPSBhcmd1bWVudHNbJF07XG4gICAgICAgIG0oXCJlcnJvclwiLCBiLCBUKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbShiLCBrLCBUKSB7XG4gICAgICB7XG4gICAgICAgIHZhciAkID0gdi5SZWFjdERlYnVnQ3VycmVudEZyYW1lLCBNID0gJC5nZXRTdGFja0FkZGVuZHVtKCk7XG4gICAgICAgIE0gIT09IFwiXCIgJiYgKGsgKz0gXCIlc1wiLCBUID0gVC5jb25jYXQoW01dKSk7XG4gICAgICAgIHZhciBLID0gVC5tYXAoZnVuY3Rpb24oaikge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcoaik7XG4gICAgICAgIH0pO1xuICAgICAgICBLLnVuc2hpZnQoXCJXYXJuaW5nOiBcIiArIGspLCBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2JdLCBjb25zb2xlLCBLKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIEMgPSAhMSwgTyA9ICExLCB3ID0gITEsIHggPSAhMSwgQSA9ICExLCBCO1xuICAgIEIgPSBTeW1ib2wuZm9yKFwicmVhY3QubW9kdWxlLnJlZmVyZW5jZVwiKTtcbiAgICBmdW5jdGlvbiBMKGIpIHtcbiAgICAgIHJldHVybiAhISh0eXBlb2YgYiA9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBiID09IFwiZnVuY3Rpb25cIiB8fCBiID09PSBuIHx8IGIgPT09IHMgfHwgQSB8fCBiID09PSBpIHx8IGIgPT09IGwgfHwgYiA9PT0gZiB8fCB4IHx8IGIgPT09IGQgfHwgQyB8fCBPIHx8IHcgfHwgdHlwZW9mIGIgPT0gXCJvYmplY3RcIiAmJiBiICE9PSBudWxsICYmIChiLiQkdHlwZW9mID09PSBoIHx8IGIuJCR0eXBlb2YgPT09IHUgfHwgYi4kJHR5cGVvZiA9PT0gbyB8fCBiLiQkdHlwZW9mID09PSBhIHx8IGIuJCR0eXBlb2YgPT09IGMgfHwgYi4kJHR5cGVvZiA9PT0gQiB8fCBiLmdldE1vZHVsZUlkICE9PSB2b2lkIDApKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUChiLCBrLCBUKSB7XG4gICAgICB2YXIgJCA9IGIuZGlzcGxheU5hbWU7XG4gICAgICBpZiAoJClcbiAgICAgICAgcmV0dXJuICQ7XG4gICAgICB2YXIgTSA9IGsuZGlzcGxheU5hbWUgfHwgay5uYW1lIHx8IFwiXCI7XG4gICAgICByZXR1cm4gTSAhPT0gXCJcIiA/IFQgKyBcIihcIiArIE0gKyBcIilcIiA6IFQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEYoYikge1xuICAgICAgcmV0dXJuIGIuZGlzcGxheU5hbWUgfHwgXCJDb250ZXh0XCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHooYikge1xuICAgICAgaWYgKGIgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBpZiAodHlwZW9mIGIudGFnID09IFwibnVtYmVyXCIgJiYgXyhcIlJlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIpLCB0eXBlb2YgYiA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHJldHVybiBiLmRpc3BsYXlOYW1lIHx8IGIubmFtZSB8fCBudWxsO1xuICAgICAgaWYgKHR5cGVvZiBiID09IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiBiO1xuICAgICAgc3dpdGNoIChiKSB7XG4gICAgICAgIGNhc2UgbjpcbiAgICAgICAgICByZXR1cm4gXCJGcmFnbWVudFwiO1xuICAgICAgICBjYXNlIHI6XG4gICAgICAgICAgcmV0dXJuIFwiUG9ydGFsXCI7XG4gICAgICAgIGNhc2UgczpcbiAgICAgICAgICByZXR1cm4gXCJQcm9maWxlclwiO1xuICAgICAgICBjYXNlIGk6XG4gICAgICAgICAgcmV0dXJuIFwiU3RyaWN0TW9kZVwiO1xuICAgICAgICBjYXNlIGw6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VcIjtcbiAgICAgICAgY2FzZSBmOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlTGlzdFwiO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBiID09IFwib2JqZWN0XCIpXG4gICAgICAgIHN3aXRjaCAoYi4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgYTpcbiAgICAgICAgICAgIHZhciBrID0gYjtcbiAgICAgICAgICAgIHJldHVybiBGKGspICsgXCIuQ29uc3VtZXJcIjtcbiAgICAgICAgICBjYXNlIG86XG4gICAgICAgICAgICB2YXIgVCA9IGI7XG4gICAgICAgICAgICByZXR1cm4gRihULl9jb250ZXh0KSArIFwiLlByb3ZpZGVyXCI7XG4gICAgICAgICAgY2FzZSBjOlxuICAgICAgICAgICAgcmV0dXJuIFAoYiwgYi5yZW5kZXIsIFwiRm9yd2FyZFJlZlwiKTtcbiAgICAgICAgICBjYXNlIHU6XG4gICAgICAgICAgICB2YXIgJCA9IGIuZGlzcGxheU5hbWUgfHwgbnVsbDtcbiAgICAgICAgICAgIHJldHVybiAkICE9PSBudWxsID8gJCA6IHooYi50eXBlKSB8fCBcIk1lbW9cIjtcbiAgICAgICAgICBjYXNlIGg6IHtcbiAgICAgICAgICAgIHZhciBNID0gYiwgSyA9IE0uX3BheWxvYWQsIGogPSBNLl9pbml0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHooaihLKSk7XG4gICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIEcgPSBPYmplY3QuYXNzaWduLCBFID0gMCwgUiwgcSwgSCwgRCwgWCwgb2UsIHJlO1xuICAgIGZ1bmN0aW9uIF9lKCkge1xuICAgIH1cbiAgICBfZS5fX3JlYWN0RGlzYWJsZWRMb2cgPSAhMDtcbiAgICBmdW5jdGlvbiBPZSgpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKEUgPT09IDApIHtcbiAgICAgICAgICBSID0gY29uc29sZS5sb2csIHEgPSBjb25zb2xlLmluZm8sIEggPSBjb25zb2xlLndhcm4sIEQgPSBjb25zb2xlLmVycm9yLCBYID0gY29uc29sZS5ncm91cCwgb2UgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkLCByZSA9IGNvbnNvbGUuZ3JvdXBFbmQ7XG4gICAgICAgICAgdmFyIGIgPSB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICB2YWx1ZTogX2UsXG4gICAgICAgICAgICB3cml0YWJsZTogITBcbiAgICAgICAgICB9O1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgICAgIGluZm86IGIsXG4gICAgICAgICAgICBsb2c6IGIsXG4gICAgICAgICAgICB3YXJuOiBiLFxuICAgICAgICAgICAgZXJyb3I6IGIsXG4gICAgICAgICAgICBncm91cDogYixcbiAgICAgICAgICAgIGdyb3VwQ29sbGFwc2VkOiBiLFxuICAgICAgICAgICAgZ3JvdXBFbmQ6IGJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBFKys7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFVlKCkge1xuICAgICAge1xuICAgICAgICBpZiAoRS0tLCBFID09PSAwKSB7XG4gICAgICAgICAgdmFyIGIgPSB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICB3cml0YWJsZTogITBcbiAgICAgICAgICB9O1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgICAgIGxvZzogRyh7fSwgYiwge1xuICAgICAgICAgICAgICB2YWx1ZTogUlxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBpbmZvOiBHKHt9LCBiLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBxXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHdhcm46IEcoe30sIGIsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IEhcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZXJyb3I6IEcoe30sIGIsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IERcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZ3JvdXA6IEcoe30sIGIsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IFhcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IEcoe30sIGIsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IG9lXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGdyb3VwRW5kOiBHKHt9LCBiLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiByZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBFIDwgMCAmJiBfKFwiZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIFBlID0gdi5SZWFjdEN1cnJlbnREaXNwYXRjaGVyLCB5ZTtcbiAgICBmdW5jdGlvbiBqZShiLCBrLCBUKSB7XG4gICAgICB7XG4gICAgICAgIGlmICh5ZSA9PT0gdm9pZCAwKVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH0gY2F0Y2ggKE0pIHtcbiAgICAgICAgICAgIHZhciAkID0gTS5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgICAgIHllID0gJCAmJiAkWzFdIHx8IFwiXCI7XG4gICAgICAgICAgfVxuICAgICAgICByZXR1cm4gYFxuYCArIHllICsgYjtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIG1lID0gITEsIHhlO1xuICAgIHtcbiAgICAgIHZhciBsciA9IHR5cGVvZiBXZWFrTWFwID09IFwiZnVuY3Rpb25cIiA/IFdlYWtNYXAgOiBNYXA7XG4gICAgICB4ZSA9IG5ldyBscigpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBCZShiLCBrKSB7XG4gICAgICBpZiAoIWIgfHwgbWUpXG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAge1xuICAgICAgICB2YXIgVCA9IHhlLmdldChiKTtcbiAgICAgICAgaWYgKFQgIT09IHZvaWQgMClcbiAgICAgICAgICByZXR1cm4gVDtcbiAgICAgIH1cbiAgICAgIHZhciAkO1xuICAgICAgbWUgPSAhMDtcbiAgICAgIHZhciBNID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7XG4gICAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHZvaWQgMDtcbiAgICAgIHZhciBLO1xuICAgICAgSyA9IFBlLmN1cnJlbnQsIFBlLmN1cnJlbnQgPSBudWxsLCBPZSgpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGspIHtcbiAgICAgICAgICB2YXIgaiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkoai5wcm90b3R5cGUsIFwicHJvcHNcIiwge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSwgdHlwZW9mIFJlZmxlY3QgPT0gXCJvYmplY3RcIiAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoaiwgW10pO1xuICAgICAgICAgICAgfSBjYXRjaCAoTGUpIHtcbiAgICAgICAgICAgICAgJCA9IExlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoYiwgW10sIGopO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBqLmNhbGwoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKExlKSB7XG4gICAgICAgICAgICAgICQgPSBMZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGIuY2FsbChqLnByb3RvdHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH0gY2F0Y2ggKExlKSB7XG4gICAgICAgICAgICAkID0gTGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGIoKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoTGUpIHtcbiAgICAgICAgaWYgKExlICYmICQgJiYgdHlwZW9mIExlLnN0YWNrID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBmb3IgKHZhciBVID0gTGUuc3RhY2suc3BsaXQoYFxuYCksIHNlID0gJC5zdGFjay5zcGxpdChgXG5gKSwgVyA9IFUubGVuZ3RoIC0gMSwgWiA9IHNlLmxlbmd0aCAtIDE7IFcgPj0gMSAmJiBaID49IDAgJiYgVVtXXSAhPT0gc2VbWl07IClcbiAgICAgICAgICAgIFotLTtcbiAgICAgICAgICBmb3IgKDsgVyA+PSAxICYmIFogPj0gMDsgVy0tLCBaLS0pXG4gICAgICAgICAgICBpZiAoVVtXXSAhPT0gc2VbWl0pIHtcbiAgICAgICAgICAgICAgaWYgKFcgIT09IDEgfHwgWiAhPT0gMSlcbiAgICAgICAgICAgICAgICBkb1xuICAgICAgICAgICAgICAgICAgaWYgKFctLSwgWi0tLCBaIDwgMCB8fCBVW1ddICE9PSBzZVtaXSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZ2UgPSBgXG5gICsgVVtXXS5yZXBsYWNlKFwiIGF0IG5ldyBcIiwgXCIgYXQgXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYi5kaXNwbGF5TmFtZSAmJiBnZS5pbmNsdWRlcyhcIjxhbm9ueW1vdXM+XCIpICYmIChnZSA9IGdlLnJlcGxhY2UoXCI8YW5vbnltb3VzPlwiLCBiLmRpc3BsYXlOYW1lKSksIHR5cGVvZiBiID09IFwiZnVuY3Rpb25cIiAmJiB4ZS5zZXQoYiwgZ2UpLCBnZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoVyA+PSAxICYmIFogPj0gMCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBtZSA9ICExLCBQZS5jdXJyZW50ID0gSywgVWUoKSwgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBNO1xuICAgICAgfVxuICAgICAgdmFyIHl0ID0gYiA/IGIuZGlzcGxheU5hbWUgfHwgYi5uYW1lIDogXCJcIiwgJGkgPSB5dCA/IGplKHl0KSA6IFwiXCI7XG4gICAgICByZXR1cm4gdHlwZW9mIGIgPT0gXCJmdW5jdGlvblwiICYmIHhlLnNldChiLCAkaSksICRpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmZShiLCBrLCBUKSB7XG4gICAgICByZXR1cm4gQmUoYiwgITEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBIZShiKSB7XG4gICAgICB2YXIgayA9IGIucHJvdG90eXBlO1xuICAgICAgcmV0dXJuICEhKGsgJiYgay5pc1JlYWN0Q29tcG9uZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXQoYiwgaywgVCkge1xuICAgICAgaWYgKGIgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICBpZiAodHlwZW9mIGIgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICByZXR1cm4gQmUoYiwgSGUoYikpO1xuICAgICAgaWYgKHR5cGVvZiBiID09IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiBqZShiKTtcbiAgICAgIHN3aXRjaCAoYikge1xuICAgICAgICBjYXNlIGw6XG4gICAgICAgICAgcmV0dXJuIGplKFwiU3VzcGVuc2VcIik7XG4gICAgICAgIGNhc2UgZjpcbiAgICAgICAgICByZXR1cm4gamUoXCJTdXNwZW5zZUxpc3RcIik7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGIgPT0gXCJvYmplY3RcIilcbiAgICAgICAgc3dpdGNoIChiLiQkdHlwZW9mKSB7XG4gICAgICAgICAgY2FzZSBjOlxuICAgICAgICAgICAgcmV0dXJuIGZlKGIucmVuZGVyKTtcbiAgICAgICAgICBjYXNlIHU6XG4gICAgICAgICAgICByZXR1cm4gaXQoYi50eXBlLCBrLCBUKTtcbiAgICAgICAgICBjYXNlIGg6IHtcbiAgICAgICAgICAgIHZhciAkID0gYiwgTSA9ICQuX3BheWxvYWQsIEsgPSAkLl9pbml0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmV0dXJuIGl0KEsoTSksIGssIFQpO1xuICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgdmFyIG90ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSwgRWkgPSB7fSwga2kgPSB2LlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgZnVuY3Rpb24gZnIoYikge1xuICAgICAgaWYgKGIpIHtcbiAgICAgICAgdmFyIGsgPSBiLl9vd25lciwgVCA9IGl0KGIudHlwZSwgYi5fc291cmNlLCBrID8gay50eXBlIDogbnVsbCk7XG4gICAgICAgIGtpLnNldEV4dHJhU3RhY2tGcmFtZShUKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBraS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIE1hKGIsIGssIFQsICQsIE0pIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIEsgPSBGdW5jdGlvbi5jYWxsLmJpbmQob3QpO1xuICAgICAgICBmb3IgKHZhciBqIGluIGIpXG4gICAgICAgICAgaWYgKEsoYiwgaikpIHtcbiAgICAgICAgICAgIHZhciBVID0gdm9pZCAwO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBiW2pdICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHZhciBzZSA9IEVycm9yKCgkIHx8IFwiUmVhY3QgY2xhc3NcIikgKyBcIjogXCIgKyBUICsgXCIgdHlwZSBgXCIgKyBqICsgXCJgIGlzIGludmFsaWQ7IGl0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGBcIiArIHR5cGVvZiBiW2pdICsgXCJgLlRoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLlwiKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBzZS5uYW1lID0gXCJJbnZhcmlhbnQgVmlvbGF0aW9uXCIsIHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFUgPSBiW2pdKGssIGosICQsIFQsIG51bGwsIFwiU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRURcIik7XG4gICAgICAgICAgICB9IGNhdGNoIChXKSB7XG4gICAgICAgICAgICAgIFUgPSBXO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgVSAmJiAhKFUgaW5zdGFuY2VvZiBFcnJvcikgJiYgKGZyKE0pLCBfKFwiJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuIFlvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyIGNyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLlwiLCAkIHx8IFwiUmVhY3QgY2xhc3NcIiwgVCwgaiwgdHlwZW9mIFUpLCBmcihudWxsKSksIFUgaW5zdGFuY2VvZiBFcnJvciAmJiAhKFUubWVzc2FnZSBpbiBFaSkgJiYgKEVpW1UubWVzc2FnZV0gPSAhMCwgZnIoTSksIF8oXCJGYWlsZWQgJXMgdHlwZTogJXNcIiwgVCwgVS5tZXNzYWdlKSwgZnIobnVsbCkpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIERhID0gQXJyYXkuaXNBcnJheTtcbiAgICBmdW5jdGlvbiBacihiKSB7XG4gICAgICByZXR1cm4gRGEoYik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHphKGIpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIGsgPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wudG9TdHJpbmdUYWcsIFQgPSBrICYmIGJbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCBiLmNvbnN0cnVjdG9yLm5hbWUgfHwgXCJPYmplY3RcIjtcbiAgICAgICAgcmV0dXJuIFQ7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIEZhKGIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBTaShiKSwgITE7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBTaShiKSB7XG4gICAgICByZXR1cm4gXCJcIiArIGI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIE9pKGIpIHtcbiAgICAgIGlmIChGYShiKSlcbiAgICAgICAgcmV0dXJuIF8oXCJUaGUgcHJvdmlkZWQga2V5IGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSBiZWZvcmUgdXNpbmcgaXQgaGVyZS5cIiwgemEoYikpLCBTaShiKTtcbiAgICB9XG4gICAgdmFyIEN0ID0gdi5SZWFjdEN1cnJlbnRPd25lciwgS2EgPSB7XG4gICAgICBrZXk6ICEwLFxuICAgICAgcmVmOiAhMCxcbiAgICAgIF9fc2VsZjogITAsXG4gICAgICBfX3NvdXJjZTogITBcbiAgICB9LCBBaSwgQ2ksIFlyO1xuICAgIFlyID0ge307XG4gICAgZnVuY3Rpb24gV2EoYikge1xuICAgICAgaWYgKG90LmNhbGwoYiwgXCJyZWZcIikpIHtcbiAgICAgICAgdmFyIGsgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGIsIFwicmVmXCIpLmdldDtcbiAgICAgICAgaWYgKGsgJiYgay5pc1JlYWN0V2FybmluZylcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICByZXR1cm4gYi5yZWYgIT09IHZvaWQgMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gVmEoYikge1xuICAgICAgaWYgKG90LmNhbGwoYiwgXCJrZXlcIikpIHtcbiAgICAgICAgdmFyIGsgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGIsIFwia2V5XCIpLmdldDtcbiAgICAgICAgaWYgKGsgJiYgay5pc1JlYWN0V2FybmluZylcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICByZXR1cm4gYi5rZXkgIT09IHZvaWQgMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gR2EoYiwgaykge1xuICAgICAgaWYgKHR5cGVvZiBiLnJlZiA9PSBcInN0cmluZ1wiICYmIEN0LmN1cnJlbnQgJiYgayAmJiBDdC5jdXJyZW50LnN0YXRlTm9kZSAhPT0gaykge1xuICAgICAgICB2YXIgVCA9IHooQ3QuY3VycmVudC50eXBlKTtcbiAgICAgICAgWXJbVF0gfHwgKF8oJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiBTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gVGhpcyBjYXNlIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBhbiBhcnJvdyBmdW5jdGlvbi4gV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuIExlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLXN0cmluZy1yZWYnLCB6KEN0LmN1cnJlbnQudHlwZSksIGIucmVmKSwgWXJbVF0gPSAhMCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFphKGIsIGspIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIFQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBBaSB8fCAoQWkgPSAhMCwgXyhcIiVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgdmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCBwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpXCIsIGspKTtcbiAgICAgICAgfTtcbiAgICAgICAgVC5pc1JlYWN0V2FybmluZyA9ICEwLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoYiwgXCJrZXlcIiwge1xuICAgICAgICAgIGdldDogVCxcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBZYShiLCBrKSB7XG4gICAgICB7XG4gICAgICAgIHZhciBUID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgQ2kgfHwgKENpID0gITAsIF8oXCIlczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lIHZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgcHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKVwiLCBrKSk7XG4gICAgICAgIH07XG4gICAgICAgIFQuaXNSZWFjdFdhcm5pbmcgPSAhMCwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGIsIFwicmVmXCIsIHtcbiAgICAgICAgICBnZXQ6IFQsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIEphID0gZnVuY3Rpb24oYiwgaywgVCwgJCwgTSwgSywgaikge1xuICAgICAgdmFyIFUgPSB7XG4gICAgICAgICQkdHlwZW9mOiBlLFxuICAgICAgICB0eXBlOiBiLFxuICAgICAgICBrZXk6IGssXG4gICAgICAgIHJlZjogVCxcbiAgICAgICAgcHJvcHM6IGosXG4gICAgICAgIF9vd25lcjogS1xuICAgICAgfTtcbiAgICAgIHJldHVybiBVLl9zdG9yZSA9IHt9LCBPYmplY3QuZGVmaW5lUHJvcGVydHkoVS5fc3RvcmUsIFwidmFsaWRhdGVkXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6ICExXG4gICAgICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KFUsIFwiX3NlbGZcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICExLFxuICAgICAgICB2YWx1ZTogJFxuICAgICAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVLCBcIl9zb3VyY2VcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICExLFxuICAgICAgICB2YWx1ZTogTVxuICAgICAgfSksIE9iamVjdC5mcmVlemUgJiYgKE9iamVjdC5mcmVlemUoVS5wcm9wcyksIE9iamVjdC5mcmVlemUoVSkpLCBVO1xuICAgIH07XG4gICAgZnVuY3Rpb24gWGEoYiwgaywgVCwgJCwgTSkge1xuICAgICAge1xuICAgICAgICB2YXIgSywgaiA9IHt9LCBVID0gbnVsbCwgc2UgPSBudWxsO1xuICAgICAgICBUICE9PSB2b2lkIDAgJiYgKE9pKFQpLCBVID0gXCJcIiArIFQpLCBWYShrKSAmJiAoT2koay5rZXkpLCBVID0gXCJcIiArIGsua2V5KSwgV2EoaykgJiYgKHNlID0gay5yZWYsIEdhKGssIE0pKTtcbiAgICAgICAgZm9yIChLIGluIGspXG4gICAgICAgICAgb3QuY2FsbChrLCBLKSAmJiAhS2EuaGFzT3duUHJvcGVydHkoSykgJiYgKGpbS10gPSBrW0tdKTtcbiAgICAgICAgaWYgKGIgJiYgYi5kZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgICB2YXIgVyA9IGIuZGVmYXVsdFByb3BzO1xuICAgICAgICAgIGZvciAoSyBpbiBXKVxuICAgICAgICAgICAgaltLXSA9PT0gdm9pZCAwICYmIChqW0tdID0gV1tLXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFUgfHwgc2UpIHtcbiAgICAgICAgICB2YXIgWiA9IHR5cGVvZiBiID09IFwiZnVuY3Rpb25cIiA/IGIuZGlzcGxheU5hbWUgfHwgYi5uYW1lIHx8IFwiVW5rbm93blwiIDogYjtcbiAgICAgICAgICBVICYmIFphKGosIFopLCBzZSAmJiBZYShqLCBaKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSmEoYiwgVSwgc2UsIE0sICQsIEN0LmN1cnJlbnQsIGopO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgSnIgPSB2LlJlYWN0Q3VycmVudE93bmVyLCBJaSA9IHYuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICBmdW5jdGlvbiBwdChiKSB7XG4gICAgICBpZiAoYikge1xuICAgICAgICB2YXIgayA9IGIuX293bmVyLCBUID0gaXQoYi50eXBlLCBiLl9zb3VyY2UsIGsgPyBrLnR5cGUgOiBudWxsKTtcbiAgICAgICAgSWkuc2V0RXh0cmFTdGFja0ZyYW1lKFQpO1xuICAgICAgfSBlbHNlXG4gICAgICAgIElpLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gICAgdmFyIFhyO1xuICAgIFhyID0gITE7XG4gICAgZnVuY3Rpb24gUXIoYikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBiID09IFwib2JqZWN0XCIgJiYgYiAhPT0gbnVsbCAmJiBiLiQkdHlwZW9mID09PSBlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSaSgpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKEpyLmN1cnJlbnQpIHtcbiAgICAgICAgICB2YXIgYiA9IHooSnIuY3VycmVudC50eXBlKTtcbiAgICAgICAgICBpZiAoYilcbiAgICAgICAgICAgIHJldHVybiBgXG5cbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIFxcYGAgKyBiICsgXCJgLlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBRYShiKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChiICE9PSB2b2lkIDApIHtcbiAgICAgICAgICB2YXIgayA9IGIuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgXCJcIiksIFQgPSBiLmxpbmVOdW1iZXI7XG4gICAgICAgICAgcmV0dXJuIGBcblxuQ2hlY2sgeW91ciBjb2RlIGF0IGAgKyBrICsgXCI6XCIgKyBUICsgXCIuXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBUaSA9IHt9O1xuICAgIGZ1bmN0aW9uIGVjKGIpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIGsgPSBSaSgpO1xuICAgICAgICBpZiAoIWspIHtcbiAgICAgICAgICB2YXIgVCA9IHR5cGVvZiBiID09IFwic3RyaW5nXCIgPyBiIDogYi5kaXNwbGF5TmFtZSB8fCBiLm5hbWU7XG4gICAgICAgICAgVCAmJiAoayA9IGBcblxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8YCArIFQgKyBcIj4uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBQaShiLCBrKSB7XG4gICAgICB7XG4gICAgICAgIGlmICghYi5fc3RvcmUgfHwgYi5fc3RvcmUudmFsaWRhdGVkIHx8IGIua2V5ICE9IG51bGwpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBiLl9zdG9yZS52YWxpZGF0ZWQgPSAhMDtcbiAgICAgICAgdmFyIFQgPSBlYyhrKTtcbiAgICAgICAgaWYgKFRpW1RdKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgVGlbVF0gPSAhMDtcbiAgICAgICAgdmFyICQgPSBcIlwiO1xuICAgICAgICBiICYmIGIuX293bmVyICYmIGIuX293bmVyICE9PSBKci5jdXJyZW50ICYmICgkID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyB6KGIuX293bmVyLnR5cGUpICsgXCIuXCIpLCBwdChiKSwgXygnRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLiVzJXMgU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgVCwgJCksIHB0KG51bGwpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBCaShiLCBrKSB7XG4gICAgICB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPSBcIm9iamVjdFwiKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKFpyKGIpKVxuICAgICAgICAgIGZvciAodmFyIFQgPSAwOyBUIDwgYi5sZW5ndGg7IFQrKykge1xuICAgICAgICAgICAgdmFyICQgPSBiW1RdO1xuICAgICAgICAgICAgUXIoJCkgJiYgUGkoJCwgayk7XG4gICAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChRcihiKSlcbiAgICAgICAgICBiLl9zdG9yZSAmJiAoYi5fc3RvcmUudmFsaWRhdGVkID0gITApO1xuICAgICAgICBlbHNlIGlmIChiKSB7XG4gICAgICAgICAgdmFyIE0gPSBnKGIpO1xuICAgICAgICAgIGlmICh0eXBlb2YgTSA9PSBcImZ1bmN0aW9uXCIgJiYgTSAhPT0gYi5lbnRyaWVzKVxuICAgICAgICAgICAgZm9yICh2YXIgSyA9IE0uY2FsbChiKSwgajsgIShqID0gSy5uZXh0KCkpLmRvbmU7IClcbiAgICAgICAgICAgICAgUXIoai52YWx1ZSkgJiYgUGkoai52YWx1ZSwgayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdGMoYikge1xuICAgICAge1xuICAgICAgICB2YXIgayA9IGIudHlwZTtcbiAgICAgICAgaWYgKGsgPT0gbnVsbCB8fCB0eXBlb2YgayA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIFQ7XG4gICAgICAgIGlmICh0eXBlb2YgayA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgVCA9IGsucHJvcFR5cGVzO1xuICAgICAgICBlbHNlIGlmICh0eXBlb2YgayA9PSBcIm9iamVjdFwiICYmIChrLiQkdHlwZW9mID09PSBjIHx8IGsuJCR0eXBlb2YgPT09IHUpKVxuICAgICAgICAgIFQgPSBrLnByb3BUeXBlcztcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKFQpIHtcbiAgICAgICAgICB2YXIgJCA9IHooayk7XG4gICAgICAgICAgTWEoVCwgYi5wcm9wcywgXCJwcm9wXCIsICQsIGIpO1xuICAgICAgICB9IGVsc2UgaWYgKGsuUHJvcFR5cGVzICE9PSB2b2lkIDAgJiYgIVhyKSB7XG4gICAgICAgICAgWHIgPSAhMDtcbiAgICAgICAgICB2YXIgTSA9IHooayk7XG4gICAgICAgICAgXyhcIkNvbXBvbmVudCAlcyBkZWNsYXJlZCBgUHJvcFR5cGVzYCBpbnN0ZWFkIG9mIGBwcm9wVHlwZXNgLiBEaWQgeW91IG1pc3NwZWxsIHRoZSBwcm9wZXJ0eSBhc3NpZ25tZW50P1wiLCBNIHx8IFwiVW5rbm93blwiKTtcbiAgICAgICAgfVxuICAgICAgICB0eXBlb2Ygay5nZXREZWZhdWx0UHJvcHMgPT0gXCJmdW5jdGlvblwiICYmICFrLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCAmJiBfKFwiZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzIGRlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC5cIik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJjKGIpIHtcbiAgICAgIHtcbiAgICAgICAgZm9yICh2YXIgayA9IE9iamVjdC5rZXlzKGIucHJvcHMpLCBUID0gMDsgVCA8IGsubGVuZ3RoOyBUKyspIHtcbiAgICAgICAgICB2YXIgJCA9IGtbVF07XG4gICAgICAgICAgaWYgKCQgIT09IFwiY2hpbGRyZW5cIiAmJiAkICE9PSBcImtleVwiKSB7XG4gICAgICAgICAgICBwdChiKSwgXyhcIkludmFsaWQgcHJvcCBgJXNgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuIFJlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuXCIsICQpLCBwdChudWxsKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBiLnJlZiAhPT0gbnVsbCAmJiAocHQoYiksIF8oXCJJbnZhbGlkIGF0dHJpYnV0ZSBgcmVmYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLlwiKSwgcHQobnVsbCkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBMaShiLCBrLCBULCAkLCBNLCBLKSB7XG4gICAgICB7XG4gICAgICAgIHZhciBqID0gTChiKTtcbiAgICAgICAgaWYgKCFqKSB7XG4gICAgICAgICAgdmFyIFUgPSBcIlwiO1xuICAgICAgICAgIChiID09PSB2b2lkIDAgfHwgdHlwZW9mIGIgPT0gXCJvYmplY3RcIiAmJiBiICE9PSBudWxsICYmIE9iamVjdC5rZXlzKGIpLmxlbmd0aCA9PT0gMCkgJiYgKFUgKz0gXCIgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiKTtcbiAgICAgICAgICB2YXIgc2UgPSBRYShNKTtcbiAgICAgICAgICBzZSA/IFUgKz0gc2UgOiBVICs9IFJpKCk7XG4gICAgICAgICAgdmFyIFc7XG4gICAgICAgICAgYiA9PT0gbnVsbCA/IFcgPSBcIm51bGxcIiA6IFpyKGIpID8gVyA9IFwiYXJyYXlcIiA6IGIgIT09IHZvaWQgMCAmJiBiLiQkdHlwZW9mID09PSBlID8gKFcgPSBcIjxcIiArICh6KGIudHlwZSkgfHwgXCJVbmtub3duXCIpICsgXCIgLz5cIiwgVSA9IFwiIERpZCB5b3UgYWNjaWRlbnRhbGx5IGV4cG9ydCBhIEpTWCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjb21wb25lbnQ/XCIpIDogVyA9IHR5cGVvZiBiLCBfKFwiUmVhY3QuanN4OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciBidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlIGNvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzXCIsIFcsIFUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBaID0gWGEoYiwgaywgVCwgTSwgSyk7XG4gICAgICAgIGlmIChaID09IG51bGwpXG4gICAgICAgICAgcmV0dXJuIFo7XG4gICAgICAgIGlmIChqKSB7XG4gICAgICAgICAgdmFyIGdlID0gay5jaGlsZHJlbjtcbiAgICAgICAgICBpZiAoZ2UgIT09IHZvaWQgMClcbiAgICAgICAgICAgIGlmICgkKVxuICAgICAgICAgICAgICBpZiAoWnIoZ2UpKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgeXQgPSAwOyB5dCA8IGdlLmxlbmd0aDsgeXQrKylcbiAgICAgICAgICAgICAgICAgIEJpKGdlW3l0XSwgYik7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSAmJiBPYmplY3QuZnJlZXplKGdlKTtcbiAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgXyhcIlJlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuIFlvdSBhcmUgbGlrZWx5IGV4cGxpY2l0bHkgY2FsbGluZyBSZWFjdC5qc3hzIG9yIFJlYWN0LmpzeERFVi4gVXNlIHRoZSBCYWJlbCB0cmFuc2Zvcm0gaW5zdGVhZC5cIik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIEJpKGdlLCBiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYiA9PT0gbiA/IHJjKFopIDogdGMoWiksIFo7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5jKGIsIGssIFQpIHtcbiAgICAgIHJldHVybiBMaShiLCBrLCBULCAhMCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGljKGIsIGssIFQpIHtcbiAgICAgIHJldHVybiBMaShiLCBrLCBULCAhMSk7XG4gICAgfVxuICAgIHZhciBvYyA9IGljLCBzYyA9IG5jO1xuICAgIFF0LkZyYWdtZW50ID0gbiwgUXQuanN4ID0gb2MsIFF0LmpzeHMgPSBzYztcbiAgfSgpKSwgUXQ7XG59XG4oZnVuY3Rpb24odCkge1xuICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyB0LmV4cG9ydHMgPSBHZCgpIDogdC5leHBvcnRzID0gWmQoKTtcbn0pKEJhKTtcbmNvbnN0IFlkID0gQmEuZXhwb3J0cy5qc3gsIExhID0gbGMoe1xuICBuZGs6IHZvaWQgMCxcbiAgc2lnbmVyOiB2b2lkIDAsXG4gIGZldGNoRXZlbnRzOiAodCkgPT4gUHJvbWlzZS5yZXNvbHZlKFtdKSxcbiAgbG9naW5XaXRoTmlwNDY6ICh0LCBlKSA9PiBQcm9taXNlLnJlc29sdmUodm9pZCAwKSxcbiAgbG9naW5XaXRoU2VjcmV0OiAodCkgPT4gUHJvbWlzZS5yZXNvbHZlKHZvaWQgMCksXG4gIGxvZ2luV2l0aE5pcDA3OiAoKSA9PiBQcm9taXNlLnJlc29sdmUodm9pZCAwKSxcbiAgc2lnblB1Ymxpc2hFdmVudDogKHQsIGUpID0+IFByb21pc2UucmVzb2x2ZSh2b2lkIDApLFxuICBnZXRVc2VyOiAodCkgPT4gcGUucHJvdG90eXBlLFxuICBnZXRQcm9maWxlOiAodCkgPT4gKHt9KVxufSksIFBwID0gKHtcbiAgY2hpbGRyZW46IHQsXG4gIHJlbGF5VXJsczogZVxufSkgPT4ge1xuICBjb25zdCB7XG4gICAgbmRrOiByLFxuICAgIHNpZ25lcjogbixcbiAgICBzZXRTaWduZXI6IGksXG4gICAgZmV0Y2hFdmVudHM6IHMsXG4gICAgc2lnblB1Ymxpc2hFdmVudDogb1xuICB9ID0gemQoZSksIHtcbiAgICBnZXRVc2VyOiBhLFxuICAgIGdldFByb2ZpbGU6IGNcbiAgfSA9IFZkKHIpO1xuICBhc3luYyBmdW5jdGlvbiBsKGgsIGQpIHtcbiAgICBpZiAociA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHAgPSBhd2FpdCBLZChyLCBoLCBkKTtcbiAgICBpZiAocClcbiAgICAgIHJldHVybiBhd2FpdCBpKHAucmVtb3RlU2lnbmVyKSwgcDtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBmKGgpIHtcbiAgICBjb25zdCBkID0gYXdhaXQgRmQoaCk7XG4gICAgaWYgKGQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc2lnbmVyOiBwXG4gICAgICB9ID0gZDtcbiAgICAgIHJldHVybiBhd2FpdCBpKHApLCBkO1xuICAgIH1cbiAgfVxuICBhc3luYyBmdW5jdGlvbiB1KCkge1xuICAgIGNvbnN0IGggPSBhd2FpdCBXZCgpO1xuICAgIGlmIChoKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNpZ25lcjogZFxuICAgICAgfSA9IGg7XG4gICAgICByZXR1cm4gYXdhaXQgaShkKSwgaDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBZZChMYS5Qcm92aWRlciwge1xuICAgIHZhbHVlOiB7XG4gICAgICBuZGs6IHIsXG4gICAgICBzaWduZXI6IG4sXG4gICAgICBmZXRjaEV2ZW50czogcyxcbiAgICAgIGxvZ2luV2l0aE5pcDA3OiB1LFxuICAgICAgbG9naW5XaXRoTmlwNDY6IGwsXG4gICAgICBsb2dpbldpdGhTZWNyZXQ6IGYsXG4gICAgICBzaWduUHVibGlzaEV2ZW50OiBvLFxuICAgICAgZ2V0VXNlcjogYSxcbiAgICAgIGdldFByb2ZpbGU6IGNcbiAgICB9LFxuICAgIGNoaWxkcmVuOiB0XG4gIH0pO1xufSwgQnAgPSAoKSA9PiB7XG4gIGNvbnN0IHQgPSBmYyhMYSk7XG4gIGlmICh0ID09PSB2b2lkIDApXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW1wb3J0IE5ES1Byb3ZpZGVyIHRvIHVzZSB1c2VOREtcIik7XG4gIHJldHVybiB0O1xufTtcbmZ1bmN0aW9uIFhlKHQpIHtcbiAgcmV0dXJuIHQgIT0gbnVsbCAmJiB0eXBlb2YgdCA9PSBcIm9iamVjdFwiICYmIHRbXCJAQGZ1bmN0aW9uYWwvcGxhY2Vob2xkZXJcIl0gPT09ICEwO1xufVxuZnVuY3Rpb24gaHQodCkge1xuICByZXR1cm4gZnVuY3Rpb24gZShyKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDAgfHwgWGUocikgPyBlIDogdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuZnVuY3Rpb24gdXIodCkge1xuICByZXR1cm4gZnVuY3Rpb24gZShyLCBuKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiBlO1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gWGUocikgPyBlIDogaHQoZnVuY3Rpb24oaSkge1xuICAgICAgICAgIHJldHVybiB0KHIsIGkpO1xuICAgICAgICB9KTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBYZShyKSAmJiBYZShuKSA/IGUgOiBYZShyKSA/IGh0KGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgICByZXR1cm4gdChpLCBuKTtcbiAgICAgICAgfSkgOiBYZShuKSA/IGh0KGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgICByZXR1cm4gdChyLCBpKTtcbiAgICAgICAgfSkgOiB0KHIsIG4pO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uICRhKHQsIGUpIHtcbiAgc3dpdGNoICh0KSB7XG4gICAgY2FzZSAwOlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gZnVuY3Rpb24ocikge1xuICAgICAgICByZXR1cm4gZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gZnVuY3Rpb24ociwgbikge1xuICAgICAgICByZXR1cm4gZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICBjYXNlIDM6XG4gICAgICByZXR1cm4gZnVuY3Rpb24ociwgbiwgaSkge1xuICAgICAgICByZXR1cm4gZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICBjYXNlIDQ6XG4gICAgICByZXR1cm4gZnVuY3Rpb24ociwgbiwgaSwgcykge1xuICAgICAgICByZXR1cm4gZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICBjYXNlIDU6XG4gICAgICByZXR1cm4gZnVuY3Rpb24ociwgbiwgaSwgcywgbykge1xuICAgICAgICByZXR1cm4gZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICBjYXNlIDY6XG4gICAgICByZXR1cm4gZnVuY3Rpb24ociwgbiwgaSwgcywgbywgYSkge1xuICAgICAgICByZXR1cm4gZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICBjYXNlIDc6XG4gICAgICByZXR1cm4gZnVuY3Rpb24ociwgbiwgaSwgcywgbywgYSwgYykge1xuICAgICAgICByZXR1cm4gZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICBjYXNlIDg6XG4gICAgICByZXR1cm4gZnVuY3Rpb24ociwgbiwgaSwgcywgbywgYSwgYywgbCkge1xuICAgICAgICByZXR1cm4gZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICBjYXNlIDk6XG4gICAgICByZXR1cm4gZnVuY3Rpb24ociwgbiwgaSwgcywgbywgYSwgYywgbCwgZikge1xuICAgICAgICByZXR1cm4gZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICBjYXNlIDEwOlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHIsIG4sIGksIHMsIG8sIGEsIGMsIGwsIGYsIHUpIHtcbiAgICAgICAgcmV0dXJuIGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkZpcnN0IGFyZ3VtZW50IHRvIF9hcml0eSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXIgbm8gZ3JlYXRlciB0aGFuIHRlblwiKTtcbiAgfVxufVxuZnVuY3Rpb24gcWEodCwgZSwgcikge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgbiA9IFtdLCBpID0gMCwgcyA9IHQsIG8gPSAwOyBvIDwgZS5sZW5ndGggfHwgaSA8IGFyZ3VtZW50cy5sZW5ndGg7ICkge1xuICAgICAgdmFyIGE7XG4gICAgICBvIDwgZS5sZW5ndGggJiYgKCFYZShlW29dKSB8fCBpID49IGFyZ3VtZW50cy5sZW5ndGgpID8gYSA9IGVbb10gOiAoYSA9IGFyZ3VtZW50c1tpXSwgaSArPSAxKSwgbltvXSA9IGEsIFhlKGEpIHx8IChzIC09IDEpLCBvICs9IDE7XG4gICAgfVxuICAgIHJldHVybiBzIDw9IDAgPyByLmFwcGx5KHRoaXMsIG4pIDogJGEocywgcWEodCwgbiwgcikpO1xuICB9O1xufVxudmFyIEpkID0gLyogQF9fUFVSRV9fICovIHVyKGZ1bmN0aW9uKGUsIHIpIHtcbiAgcmV0dXJuIGUgPT09IDEgPyBodChyKSA6ICRhKGUsIHFhKGUsIFtdLCByKSk7XG59KTtcbmNvbnN0IFhkID0gSmQsIFFkID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbihlKSB7XG4gIHJldHVybiBlICE9IG51bGwgJiYgZS5sZW5ndGggPj0gMCAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSkgPT09IFwiW29iamVjdCBBcnJheV1cIjtcbn07XG5mdW5jdGlvbiBlcCh0KSB7XG4gIHJldHVybiB0ICE9IG51bGwgJiYgdHlwZW9mIHRbXCJAQHRyYW5zZHVjZXIvc3RlcFwiXSA9PSBcImZ1bmN0aW9uXCI7XG59XG5mdW5jdGlvbiB0cCh0LCBlLCByKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiByKCk7XG4gICAgdmFyIG4gPSBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdO1xuICAgIGlmICghUWQobikpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdC5sZW5ndGg7ICkge1xuICAgICAgICBpZiAodHlwZW9mIG5bdFtpXV0gPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgIHJldHVybiBuW3RbaV1dLmFwcGx5KG4sIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCwgLTEpKTtcbiAgICAgICAgaSArPSAxO1xuICAgICAgfVxuICAgICAgaWYgKGVwKG4pKSB7XG4gICAgICAgIHZhciBzID0gZS5hcHBseShudWxsLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDAsIC0xKSk7XG4gICAgICAgIHJldHVybiBzKG4pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuY29uc3Qgem8gPSB7XG4gIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnhmW1wiQEB0cmFuc2R1Y2VyL2luaXRcIl0oKTtcbiAgfSxcbiAgcmVzdWx0OiBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIHRoaXMueGZbXCJAQHRyYW5zZHVjZXIvcmVzdWx0XCJdKHQpO1xuICB9XG59O1xuZnVuY3Rpb24gam4odCwgZSkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsIHQpO1xufVxudmFyIEZvID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZywgcnAgPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBGby5jYWxsKGFyZ3VtZW50cykgPT09IFwiW29iamVjdCBBcmd1bWVudHNdXCIgPyBmdW5jdGlvbihlKSB7XG4gICAgcmV0dXJuIEZvLmNhbGwoZSkgPT09IFwiW29iamVjdCBBcmd1bWVudHNdXCI7XG4gIH0gOiBmdW5jdGlvbihlKSB7XG4gICAgcmV0dXJuIGpuKFwiY2FsbGVlXCIsIGUpO1xuICB9O1xufSgpO1xuY29uc3QgbnAgPSBycDtcbnZhciBpcCA9ICEvKiBAX19QVVJFX18gKi8ge1xuICB0b1N0cmluZzogbnVsbFxufS5wcm9wZXJ0eUlzRW51bWVyYWJsZShcInRvU3RyaW5nXCIpLCBLbyA9IFtcImNvbnN0cnVjdG9yXCIsIFwidmFsdWVPZlwiLCBcImlzUHJvdG90eXBlT2ZcIiwgXCJ0b1N0cmluZ1wiLCBcInByb3BlcnR5SXNFbnVtZXJhYmxlXCIsIFwiaGFzT3duUHJvcGVydHlcIiwgXCJ0b0xvY2FsZVN0cmluZ1wiXSwgV28gPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBhcmd1bWVudHMucHJvcGVydHlJc0VudW1lcmFibGUoXCJsZW5ndGhcIik7XG59KCksIG9wID0gZnVuY3Rpb24oZSwgcikge1xuICBmb3IgKHZhciBuID0gMDsgbiA8IGUubGVuZ3RoOyApIHtcbiAgICBpZiAoZVtuXSA9PT0gcilcbiAgICAgIHJldHVybiAhMDtcbiAgICBuICs9IDE7XG4gIH1cbiAgcmV0dXJuICExO1xufSwgc3AgPSAvKiBAX19QVVJFX18gKi8gaHQodHlwZW9mIE9iamVjdC5rZXlzID09IFwiZnVuY3Rpb25cIiAmJiAhV28gPyBmdW5jdGlvbihlKSB7XG4gIHJldHVybiBPYmplY3QoZSkgIT09IGUgPyBbXSA6IE9iamVjdC5rZXlzKGUpO1xufSA6IGZ1bmN0aW9uKGUpIHtcbiAgaWYgKE9iamVjdChlKSAhPT0gZSlcbiAgICByZXR1cm4gW107XG4gIHZhciByLCBuLCBpID0gW10sIHMgPSBXbyAmJiBucChlKTtcbiAgZm9yIChyIGluIGUpXG4gICAgam4ociwgZSkgJiYgKCFzIHx8IHIgIT09IFwibGVuZ3RoXCIpICYmIChpW2kubGVuZ3RoXSA9IHIpO1xuICBpZiAoaXApXG4gICAgZm9yIChuID0gS28ubGVuZ3RoIC0gMTsgbiA+PSAwOyApXG4gICAgICByID0gS29bbl0sIGpuKHIsIGUpICYmICFvcChpLCByKSAmJiAoaVtpLmxlbmd0aF0gPSByKSwgbiAtPSAxO1xuICByZXR1cm4gaTtcbn0pO1xuY29uc3QgYXAgPSBzcDtcbmZ1bmN0aW9uIGNwKHQsIGUpIHtcbiAgZm9yICh2YXIgciA9IDAsIG4gPSBlLmxlbmd0aCwgaSA9IEFycmF5KG4pOyByIDwgbjsgKVxuICAgIGlbcl0gPSB0KGVbcl0pLCByICs9IDE7XG4gIHJldHVybiBpO1xufVxuZnVuY3Rpb24gdXAodCwgZSwgcikge1xuICBmb3IgKHZhciBuID0gMCwgaSA9IHIubGVuZ3RoOyBuIDwgaTsgKVxuICAgIGUgPSB0KGUsIHJbbl0pLCBuICs9IDE7XG4gIHJldHVybiBlO1xufVxudmFyIGxwID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiB0KGUsIHIpIHtcbiAgICB0aGlzLnhmID0gciwgdGhpcy5mID0gZTtcbiAgfVxuICByZXR1cm4gdC5wcm90b3R5cGVbXCJAQHRyYW5zZHVjZXIvaW5pdFwiXSA9IHpvLmluaXQsIHQucHJvdG90eXBlW1wiQEB0cmFuc2R1Y2VyL3Jlc3VsdFwiXSA9IHpvLnJlc3VsdCwgdC5wcm90b3R5cGVbXCJAQHRyYW5zZHVjZXIvc3RlcFwiXSA9IGZ1bmN0aW9uKGUsIHIpIHtcbiAgICByZXR1cm4gdGhpcy54ZltcIkBAdHJhbnNkdWNlci9zdGVwXCJdKGUsIHRoaXMuZihyKSk7XG4gIH0sIHQ7XG59KCksIGZwID0gZnVuY3Rpb24oZSkge1xuICByZXR1cm4gZnVuY3Rpb24ocikge1xuICAgIHJldHVybiBuZXcgbHAoZSwgcik7XG4gIH07XG59O1xuY29uc3QgaHAgPSBmcDtcbnZhciBkcCA9IC8qIEBfX1BVUkVfXyAqLyB1cihcbiAgLyogQF9fUFVSRV9fICovIHRwKFtcImZhbnRhc3ktbGFuZC9tYXBcIiwgXCJtYXBcIl0sIGhwLCBmdW5jdGlvbihlLCByKSB7XG4gICAgc3dpdGNoIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocikpIHtcbiAgICAgIGNhc2UgXCJbb2JqZWN0IEZ1bmN0aW9uXVwiOlxuICAgICAgICByZXR1cm4gWGQoci5sZW5ndGgsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBlLmNhbGwodGhpcywgci5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICAgICAgfSk7XG4gICAgICBjYXNlIFwiW29iamVjdCBPYmplY3RdXCI6XG4gICAgICAgIHJldHVybiB1cChmdW5jdGlvbihuLCBpKSB7XG4gICAgICAgICAgcmV0dXJuIG5baV0gPSBlKHJbaV0pLCBuO1xuICAgICAgICB9LCB7fSwgYXAocikpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGNwKGUsIHIpO1xuICAgIH1cbiAgfSlcbik7XG5jb25zdCBwcCA9IGRwLCB5cCA9IE51bWJlci5pc0ludGVnZXIgfHwgZnVuY3Rpb24oZSkge1xuICByZXR1cm4gZSA8PCAwID09PSBlO1xufTtcbmZ1bmN0aW9uIGdwKHQpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KSA9PT0gXCJbb2JqZWN0IFN0cmluZ11cIjtcbn1cbnZhciBicCA9IC8qIEBfX1BVUkVfXyAqLyB1cihmdW5jdGlvbihlLCByKSB7XG4gIHZhciBuID0gZSA8IDAgPyByLmxlbmd0aCArIGUgOiBlO1xuICByZXR1cm4gZ3AocikgPyByLmNoYXJBdChuKSA6IHJbbl07XG59KTtcbmNvbnN0IE5hID0gYnA7XG52YXIgdnAgPSAvKiBAX19QVVJFX18gKi8gdXIoZnVuY3Rpb24oZSwgcikge1xuICBpZiAociAhPSBudWxsKVxuICAgIHJldHVybiB5cChlKSA/IE5hKGUsIHIpIDogcltlXTtcbn0pO1xuY29uc3Qgd3AgPSB2cDtcbnZhciBfcCA9IC8qIEBfX1BVUkVfXyAqLyB1cihmdW5jdGlvbihlLCByKSB7XG4gIHJldHVybiBwcCh3cChlKSwgcik7XG59KTtcbmNvbnN0IG1wID0gX3A7XG5mdW5jdGlvbiB4cCh0KSB7XG4gIHJldHVybiB0O1xufVxudmFyIEVwID0gLyogQF9fUFVSRV9fICovIGh0KHhwKTtcbmNvbnN0IGtwID0gRXA7XG52YXIgU3AgPSAvKiBAX19QVVJFX18gKi8gTmEoLTEpO1xuY29uc3QgVWEgPSBTcCwgT3AgPSBcIm5ld2xpbmVcIiwgSG4gPSBcInRleHRcIiwgamEgPSBcInRvcGljXCIsIHhpID0gXCJsaW5rXCIsIEhhID0gXCJpbnZvaWNlXCIsIExwID0gXCJub3N0cjpub3RlXCIsICRwID0gXCJub3N0cjpuZXZlbnRcIiwgcXAgPSBcIm5vc3RyOm5wdWJcIiwgTnAgPSBcIm5vc3RyOm5wcm9maWxlXCIsIFVwID0gXCJub3N0cjpuYWRkclwiO1xuZnVuY3Rpb24gZ3QodCkge1xuICByZXR1cm4gdCA/IHRbMF0gOiB2b2lkIDA7XG59XG5jb25zdCBBcCA9ICh0KSA9PiB0LnJlcGxhY2UoL15bXFx3XFwrXSs6XFwvP1xcLz8vLCBcIlwiKSwgQ3AgPSAodCkgPT4gIXQubWF0Y2goL1xcLihhcGt8ZG9jeHx4bHN4fGNzdnxkbWcpLykgJiYgVWEodC5zcGxpdChcIjovL1wiKSkuaW5jbHVkZXMoXCIvXCIpLCBqcCA9ICh7XG4gIGNvbnRlbnQ6IHQsXG4gIHRhZ3M6IGUgPSBbXVxufSkgPT4ge1xuICBjb25zdCByID0gW107XG4gIGxldCBuID0gdC50cmltKCksIGkgPSBcIlwiO1xuICBjb25zdCBzID0gKCkgPT4ge1xuICAgIGNvbnN0IHUgPSBndChuLm1hdGNoKC9eXFxuKy8pKTtcbiAgICBpZiAodSlcbiAgICAgIHJldHVybiBbT3AsIHUsIHVdO1xuICB9LCBvID0gKCkgPT4ge1xuICAgIGNvbnN0IHUgPSBuLm1hdGNoKC9eI1xcWyhcXGQrKVxcXS9pKTtcbiAgICBpZiAodSkge1xuICAgICAgY29uc3QgaCA9IHBhcnNlSW50KHVbMV0pO1xuICAgICAgaWYgKGVbaF0pIHtcbiAgICAgICAgY29uc3QgW2QsIHAsIHldID0gZVtoXSwgZyA9IFt5XS5maWx0ZXIoa3ApO1xuICAgICAgICBsZXQgdiwgXywgbTtcbiAgICAgICAgcmV0dXJuIGQgPT09IFwicFwiID8gKHYgPSBcIm5wcm9maWxlXCIsIF8gPSB7IHB1YmtleTogcCwgcmVsYXlzOiBnIH0sIG0gPSB3ZS5ucHJvZmlsZUVuY29kZShfKSkgOiAodiA9IFwibmV2ZW50XCIsIF8gPSB7IGlkOiBwLCByZWxheXM6IGcsIHB1YmtleTogbnVsbCB9LCBtID0gd2UubmV2ZW50RW5jb2RlKF8pKSwgW2Bub3N0cjoke3Z9YCwgdVswXSwgeyAuLi5fLCBlbnRpdHk6IG0gfV07XG4gICAgICB9XG4gICAgfVxuICB9LCBhID0gKCkgPT4ge1xuICAgIGNvbnN0IHUgPSBndChuLm1hdGNoKC9eI1xcdysvaSkpO1xuICAgIGlmICh1ICYmICF1Lm1hdGNoKC9eI1xcZCskLykpXG4gICAgICByZXR1cm4gW2phLCB1LCB1LnNsaWNlKDEpXTtcbiAgfSwgYyA9ICgpID0+IHtcbiAgICBjb25zdCB1ID0gZ3QoXG4gICAgICBuLm1hdGNoKFxuICAgICAgICAvXih3ZWJcXCspPyhub3N0cjopP1xcLz9cXC8/bihldmVudHxvdGV8cHJvZmlsZXxwdWJ8YWRkcikxW1xcZFxcd10rL2lcbiAgICAgIClcbiAgICApO1xuICAgIGlmICh1KVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgaCA9IEFwKHUpLCB7IHR5cGU6IGQsIGRhdGE6IHAgfSA9IHdlLmRlY29kZShoKTtcbiAgICAgICAgbGV0IHkgPSBwO1xuICAgICAgICByZXR1cm4gZCA9PT0gXCJub3RlXCIgPyB5ID0geyBpZDogcCB9IDogZCA9PT0gXCJucHViXCIgJiYgKHkgPSB7IHB1YmtleTogcCB9KSwgW2Bub3N0cjoke2R9YCwgdSwgeyAuLi55LCBlbnRpdHk6IGggfV07XG4gICAgICB9IGNhdGNoIChoKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGgpO1xuICAgICAgfVxuICB9LCBsID0gKCkgPT4ge1xuICAgIGNvbnN0IHUgPSBndChuLm1hdGNoKC9ebG4oYmN8dXJsKVtcXGRcXHddezUwLDEwMDB9L2kpKTtcbiAgICBpZiAodSlcbiAgICAgIHJldHVybiBbSGEsIHUsIHVdO1xuICB9LCBmID0gKCkgPT4ge1xuICAgIGNvbnN0IHUgPSBndChcbiAgICAgIG4ubWF0Y2goL14oW2EtelxcKzpdezIsMzB9OlxcL1xcLyk/W15cXHNdK1xcLlthLXpdezIsNn1bXlxcc10qW15cXC4hPyw6XFxzXS9naSlcbiAgICApO1xuICAgIGlmICh1KSB7XG4gICAgICBjb25zdCBoID0gVWEocik7XG4gICAgICBpZiAoKGggPT0gbnVsbCA/IHZvaWQgMCA6IGgudHlwZSkgPT09IFwidGV4dFwiICYmIGgudmFsdWUuZW5kc1dpdGgoXCIvXCIpKVxuICAgICAgICByZXR1cm47XG4gICAgICBsZXQgZCA9IHU7XG4gICAgICByZXR1cm4gZC5tYXRjaCgvXFwuXFwuLykgPyB2b2lkIDAgOiAoZC5tYXRjaChcIjovL1wiKSB8fCAoZCA9IFwiaHR0cHM6Ly9cIiArIGQpLCBbeGksIHUsIHsgdXJsOiBkLCBpc01lZGlhOiBDcChkKSB9XSk7XG4gICAgfVxuICB9O1xuICBmb3IgKDsgbjsgKSB7XG4gICAgY29uc3QgdSA9IHMoKSB8fCBvKCkgfHwgYSgpIHx8IGMoKSB8fCBmKCkgfHwgbCgpO1xuICAgIGlmICh1KSB7XG4gICAgICBpICYmIChyLnB1c2goeyB0eXBlOiBcInRleHRcIiwgdmFsdWU6IGkgfSksIGkgPSBcIlwiKTtcbiAgICAgIGNvbnN0IFtoLCBkLCBwXSA9IHU7XG4gICAgICByLnB1c2goeyB0eXBlOiBoLCB2YWx1ZTogcCB9KSwgbiA9IG4uc2xpY2UoZC5sZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBoID0gZ3Qobi5tYXRjaCgvXltcXHdcXGRdKyA/L2kpKSB8fCBuWzBdO1xuICAgICAgaSArPSBoLCBuID0gbi5zbGljZShoLmxlbmd0aCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBpICYmIHIucHVzaCh7IHR5cGU6IEhuLCB2YWx1ZTogaSB9KSwgcjtcbn0sIEhwID0gKHQsIHsgc2hvd0VudGlyZTogZSwgbWF4TGVuZ3RoOiByLCBzaG93TWVkaWE6IG4gPSAhMSB9KSA9PiB7XG4gIGlmIChlKVxuICAgIHJldHVybiB0O1xuICBsZXQgaSA9IDA7XG4gIGNvbnN0IHMgPSBbXSwgbyA9IHIgKiAwLjY7XG4gIHJldHVybiB0LmV2ZXJ5KChhLCBjKSA9PiB7XG4gICAgY29uc3QgbCA9IFtqYSwgSG5dLmluY2x1ZGVzKGEudHlwZSkgfHwgYS50eXBlID09PSB4aSAmJiAhYS52YWx1ZS5pc01lZGlhLCBmID0gYS50eXBlID09PSBIYSB8fCBhLnR5cGUuc3RhcnRzV2l0aChcIm5vc3RyOlwiKSB8fCBhLnZhbHVlLmlzTWVkaWE7XG4gICAgcmV0dXJuIGwgJiYgKGkgKz0gYS52YWx1ZS5sZW5ndGgpLCBmICYmIChpICs9IG4gPyByIC8gMyA6IGEudmFsdWUubGVuZ3RoKSwgcy5wdXNoKGEpLCBpID4gbyAmJiBjIDwgdC5sZW5ndGggLSAxID8gKChsIHx8IGYgJiYgIW4pICYmIHMucHVzaCh7IHR5cGU6IEhuLCB2YWx1ZTogXCIuLi5cIiB9KSwgITEpIDogITA7XG4gIH0pLCBzO1xufSwgTXAgPSAodCkgPT4gbXAoXG4gIFwidmFsdWVcIixcbiAgdC5maWx0ZXIoKGUpID0+IGUudHlwZSA9PT0geGkgJiYgZS5pc01lZGlhKVxuKTtcbmV4cG9ydCB7XG4gIEhhIGFzIElOVk9JQ0UsXG4gIHhpIGFzIExJTkssXG4gIFBwIGFzIE5ES1Byb3ZpZGVyLFxuICBPcCBhcyBORVdMSU5FLFxuICBVcCBhcyBOT1NUUl9OQUREUixcbiAgJHAgYXMgTk9TVFJfTkVWRU5ULFxuICBMcCBhcyBOT1NUUl9OT1RFLFxuICBOcCBhcyBOT1NUUl9OUFJPRklMRSxcbiAgcXAgYXMgTk9TVFJfTlBVQixcbiAgSG4gYXMgVEVYVCxcbiAgamEgYXMgVE9QSUMsXG4gIEFwIGFzIGZyb21Ob3N0clVSSSxcbiAgTXAgYXMgZ2V0TGlua3MsXG4gIGpwIGFzIHBhcnNlQ29udGVudCxcbiAgSHAgYXMgdHJ1bmNhdGVDb250ZW50LFxuICBDcCBhcyB1cmxJc01lZGlhLFxuICBCcCBhcyB1c2VOREtcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk-react/dist/ndk-react.es.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/dist/index.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/dist/index.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BECH32_REGEX: () => (/* binding */ BECH32_REGEX),\n/* harmony export */   NDKAppHandlerEvent: () => (/* binding */ NDKAppHandlerEvent),\n/* harmony export */   NDKAppSettings: () => (/* binding */ NDKAppSettings),\n/* harmony export */   NDKArticle: () => (/* binding */ NDKArticle),\n/* harmony export */   NDKCashuMintList: () => (/* binding */ NDKCashuMintList),\n/* harmony export */   NDKCashuToken: () => (/* binding */ NDKCashuToken),\n/* harmony export */   NDKCashuWalletTx: () => (/* binding */ NDKCashuWalletTx),\n/* harmony export */   NDKClassified: () => (/* binding */ NDKClassified),\n/* harmony export */   NDKDVMJobFeedback: () => (/* binding */ NDKDVMJobFeedback),\n/* harmony export */   NDKDVMJobResult: () => (/* binding */ NDKDVMJobResult),\n/* harmony export */   NDKDVMRequest: () => (/* binding */ NDKDVMRequest),\n/* harmony export */   NDKDraft: () => (/* binding */ NDKDraft),\n/* harmony export */   NDKDvmJobFeedbackStatus: () => (/* binding */ NDKDvmJobFeedbackStatus),\n/* harmony export */   NDKEvent: () => (/* binding */ NDKEvent),\n/* harmony export */   NDKHighlight: () => (/* binding */ NDKHighlight),\n/* harmony export */   NDKImage: () => (/* binding */ NDKImage),\n/* harmony export */   NDKKind: () => (/* binding */ NDKKind),\n/* harmony export */   NDKList: () => (/* binding */ NDKList),\n/* harmony export */   NDKListKinds: () => (/* binding */ NDKListKinds),\n/* harmony export */   NDKNip07Signer: () => (/* binding */ NDKNip07Signer),\n/* harmony export */   NDKNip46Backend: () => (/* binding */ NDKNip46Backend),\n/* harmony export */   NDKNip46Signer: () => (/* binding */ NDKNip46Signer),\n/* harmony export */   NDKNostrRpc: () => (/* binding */ NDKNostrRpc),\n/* harmony export */   NDKNutzap: () => (/* binding */ NDKNutzap),\n/* harmony export */   NDKPool: () => (/* binding */ NDKPool),\n/* harmony export */   NDKPrivateKeySigner: () => (/* binding */ NDKPrivateKeySigner),\n/* harmony export */   NDKPublishError: () => (/* binding */ NDKPublishError),\n/* harmony export */   NDKRelay: () => (/* binding */ NDKRelay),\n/* harmony export */   NDKRelayAuthPolicies: () => (/* binding */ NDKRelayAuthPolicies),\n/* harmony export */   NDKRelayList: () => (/* binding */ NDKRelayList),\n/* harmony export */   NDKRelaySet: () => (/* binding */ NDKRelaySet),\n/* harmony export */   NDKRelayStatus: () => (/* binding */ NDKRelayStatus),\n/* harmony export */   NDKRepost: () => (/* binding */ NDKRepost),\n/* harmony export */   NDKSimpleGroup: () => (/* binding */ NDKSimpleGroup),\n/* harmony export */   NDKSimpleGroupMemberList: () => (/* binding */ NDKSimpleGroupMemberList),\n/* harmony export */   NDKSimpleGroupMetadata: () => (/* binding */ NDKSimpleGroupMetadata),\n/* harmony export */   NDKSubscription: () => (/* binding */ NDKSubscription),\n/* harmony export */   NDKSubscriptionCacheUsage: () => (/* binding */ NDKSubscriptionCacheUsage),\n/* harmony export */   NDKSubscriptionReceipt: () => (/* binding */ NDKSubscriptionReceipt),\n/* harmony export */   NDKSubscriptionStart: () => (/* binding */ NDKSubscriptionStart),\n/* harmony export */   NDKSubscriptionTier: () => (/* binding */ NDKSubscriptionTier),\n/* harmony export */   NDKTranscriptionDVM: () => (/* binding */ NDKTranscriptionDVM),\n/* harmony export */   NDKUser: () => (/* binding */ NDKUser),\n/* harmony export */   NDKVideo: () => (/* binding */ NDKVideo),\n/* harmony export */   NDKWiki: () => (/* binding */ NDKWiki),\n/* harmony export */   NDKZapper: () => (/* binding */ NDKZapper),\n/* harmony export */   NIP33_A_REGEX: () => (/* binding */ NIP33_A_REGEX),\n/* harmony export */   calculateRelaySetFromEvent: () => (/* binding */ calculateRelaySetFromEvent),\n/* harmony export */   calculateTermDurationInSeconds: () => (/* binding */ calculateTermDurationInSeconds),\n/* harmony export */   compareFilter: () => (/* binding */ compareFilter),\n/* harmony export */   \"default\": () => (/* binding */ NDK),\n/* harmony export */   defaultOpts: () => (/* binding */ defaultOpts),\n/* harmony export */   deserialize: () => (/* binding */ deserialize),\n/* harmony export */   dvmSchedule: () => (/* binding */ dvmSchedule),\n/* harmony export */   eventHasETagMarkers: () => (/* binding */ eventHasETagMarkers),\n/* harmony export */   eventIsPartOfThread: () => (/* binding */ eventIsPartOfThread),\n/* harmony export */   eventIsReply: () => (/* binding */ eventIsReply),\n/* harmony export */   eventReplies: () => (/* binding */ eventReplies),\n/* harmony export */   eventThreadIds: () => (/* binding */ eventThreadIds),\n/* harmony export */   eventThreads: () => (/* binding */ eventThreads),\n/* harmony export */   eventsBySameAuthor: () => (/* binding */ eventsBySameAuthor),\n/* harmony export */   filterAndRelaySetFromBech32: () => (/* binding */ filterAndRelaySetFromBech32),\n/* harmony export */   filterFingerprint: () => (/* binding */ filterFingerprint),\n/* harmony export */   filterForEventsTaggingId: () => (/* binding */ filterForEventsTaggingId),\n/* harmony export */   filterFromId: () => (/* binding */ filterFromId),\n/* harmony export */   generateContentTags: () => (/* binding */ generateContentTags),\n/* harmony export */   generateHashtags: () => (/* binding */ generateHashtags),\n/* harmony export */   generateSubId: () => (/* binding */ generateSubId),\n/* harmony export */   generateZapRequest: () => (/* binding */ generateZapRequest),\n/* harmony export */   getEventReplyId: () => (/* binding */ getEventReplyId),\n/* harmony export */   getNip57ZapSpecFromLud: () => (/* binding */ getNip57ZapSpecFromLud),\n/* harmony export */   getRelayListForUser: () => (/* binding */ getRelayListForUser),\n/* harmony export */   getRelayListForUsers: () => (/* binding */ getRelayListForUsers),\n/* harmony export */   getReplyTag: () => (/* binding */ getReplyTag),\n/* harmony export */   getRootEventId: () => (/* binding */ getRootEventId),\n/* harmony export */   getRootTag: () => (/* binding */ getRootTag),\n/* harmony export */   imetaTagToTag: () => (/* binding */ imetaTagToTag),\n/* harmony export */   isEventOriginalPost: () => (/* binding */ isEventOriginalPost),\n/* harmony export */   isNip33AValue: () => (/* binding */ isNip33AValue),\n/* harmony export */   mapImetaTag: () => (/* binding */ mapImetaTag),\n/* harmony export */   matchFilter: () => (/* binding */ matchFilter),\n/* harmony export */   mergeFilters: () => (/* binding */ mergeFilters),\n/* harmony export */   mergeTags: () => (/* binding */ mergeTags),\n/* harmony export */   newAmount: () => (/* binding */ newAmount),\n/* harmony export */   normalize: () => (/* binding */ normalize),\n/* harmony export */   normalizeRelayUrl: () => (/* binding */ normalizeRelayUrl),\n/* harmony export */   normalizeUrl: () => (/* binding */ normalizeUrl),\n/* harmony export */   parseTagToSubscriptionAmount: () => (/* binding */ parseTagToSubscriptionAmount),\n/* harmony export */   pinEvent: () => (/* binding */ pinEvent),\n/* harmony export */   possibleIntervalFrequencies: () => (/* binding */ possibleIntervalFrequencies),\n/* harmony export */   profileFromEvent: () => (/* binding */ profileFromEvent),\n/* harmony export */   proofP2pk: () => (/* binding */ proofP2pk),\n/* harmony export */   proofP2pkNostr: () => (/* binding */ proofP2pkNostr),\n/* harmony export */   proofsTotalBalance: () => (/* binding */ proofsTotalBalance),\n/* harmony export */   queryFullyFilled: () => (/* binding */ queryFullyFilled),\n/* harmony export */   relayListFromKind3: () => (/* binding */ relayListFromKind3),\n/* harmony export */   relaysFromBech32: () => (/* binding */ relaysFromBech32),\n/* harmony export */   serialize: () => (/* binding */ serialize),\n/* harmony export */   serializeProfile: () => (/* binding */ serializeProfile),\n/* harmony export */   tryNormalizeRelayUrl: () => (/* binding */ tryNormalizeRelayUrl),\n/* harmony export */   uniqueTag: () => (/* binding */ uniqueTag),\n/* harmony export */   wrapEvent: () => (/* binding */ wrapEvent),\n/* harmony export */   zapInvoiceFromEvent: () => (/* binding */ zapInvoiceFromEvent)\n/* harmony export */ });\n/* harmony import */ var tseep__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tseep */ \"(app-pages-browser)/./node_modules/tseep/lib/index.js\");\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! debug */ \"(app-pages-browser)/./node_modules/debug/src/browser.js\");\n/* harmony import */ var nostr_tools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! nostr-tools */ \"(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/lib/esm/index.js\");\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @noble/hashes/utils */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/secp256k1.js\");\n/* harmony import */ var typescript_lru_cache__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! typescript-lru-cache */ \"(app-pages-browser)/./node_modules/typescript-lru-cache/dist/index.js\");\n/* harmony import */ var light_bolt11_decoder__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! light-bolt11-decoder */ \"(app-pages-browser)/./node_modules/light-bolt11-decoder/bolt11.js\");\n/* harmony import */ var _scure_base__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @scure/base */ \"(app-pages-browser)/./node_modules/@scure/base/lib/esm/index.js\");\n// src/events/kinds/index.ts\nvar NDKKind = /* @__PURE__ */ ((NDKKind2) => {\n  NDKKind2[NDKKind2[\"Metadata\"] = 0] = \"Metadata\";\n  NDKKind2[NDKKind2[\"Text\"] = 1] = \"Text\";\n  NDKKind2[NDKKind2[\"RecommendRelay\"] = 2] = \"RecommendRelay\";\n  NDKKind2[NDKKind2[\"Contacts\"] = 3] = \"Contacts\";\n  NDKKind2[NDKKind2[\"EncryptedDirectMessage\"] = 4] = \"EncryptedDirectMessage\";\n  NDKKind2[NDKKind2[\"EventDeletion\"] = 5] = \"EventDeletion\";\n  NDKKind2[NDKKind2[\"Repost\"] = 6] = \"Repost\";\n  NDKKind2[NDKKind2[\"Reaction\"] = 7] = \"Reaction\";\n  NDKKind2[NDKKind2[\"BadgeAward\"] = 8] = \"BadgeAward\";\n  NDKKind2[NDKKind2[\"GroupChat\"] = 9] = \"GroupChat\";\n  NDKKind2[NDKKind2[\"GroupNote\"] = 11] = \"GroupNote\";\n  NDKKind2[NDKKind2[\"GroupReply\"] = 12] = \"GroupReply\";\n  NDKKind2[NDKKind2[\"GiftWrapSeal\"] = 13] = \"GiftWrapSeal\";\n  NDKKind2[NDKKind2[\"PrivateDirectMessage\"] = 14] = \"PrivateDirectMessage\";\n  NDKKind2[NDKKind2[\"Image\"] = 20] = \"Image\";\n  NDKKind2[NDKKind2[\"Vanish\"] = 62] = \"Vanish\";\n  NDKKind2[NDKKind2[\"GiftWrap\"] = 1059] = \"GiftWrap\";\n  NDKKind2[NDKKind2[\"GenericRepost\"] = 16] = \"GenericRepost\";\n  NDKKind2[NDKKind2[\"ChannelCreation\"] = 40] = \"ChannelCreation\";\n  NDKKind2[NDKKind2[\"ChannelMetadata\"] = 41] = \"ChannelMetadata\";\n  NDKKind2[NDKKind2[\"ChannelMessage\"] = 42] = \"ChannelMessage\";\n  NDKKind2[NDKKind2[\"ChannelHideMessage\"] = 43] = \"ChannelHideMessage\";\n  NDKKind2[NDKKind2[\"ChannelMuteUser\"] = 44] = \"ChannelMuteUser\";\n  NDKKind2[NDKKind2[\"GenericReply\"] = 1111] = \"GenericReply\";\n  NDKKind2[NDKKind2[\"Media\"] = 1063] = \"Media\";\n  NDKKind2[NDKKind2[\"Report\"] = 1984] = \"Report\";\n  NDKKind2[NDKKind2[\"Label\"] = 1985] = \"Label\";\n  NDKKind2[NDKKind2[\"DVMReqTextExtraction\"] = 5e3] = \"DVMReqTextExtraction\";\n  NDKKind2[NDKKind2[\"DVMReqTextSummarization\"] = 5001] = \"DVMReqTextSummarization\";\n  NDKKind2[NDKKind2[\"DVMReqTextTranslation\"] = 5002] = \"DVMReqTextTranslation\";\n  NDKKind2[NDKKind2[\"DVMReqTextGeneration\"] = 5050] = \"DVMReqTextGeneration\";\n  NDKKind2[NDKKind2[\"DVMReqImageGeneration\"] = 5100] = \"DVMReqImageGeneration\";\n  NDKKind2[NDKKind2[\"DVMReqTextToSpeech\"] = 5250] = \"DVMReqTextToSpeech\";\n  NDKKind2[NDKKind2[\"DVMReqDiscoveryNostrContent\"] = 5300] = \"DVMReqDiscoveryNostrContent\";\n  NDKKind2[NDKKind2[\"DVMReqDiscoveryNostrPeople\"] = 5301] = \"DVMReqDiscoveryNostrPeople\";\n  NDKKind2[NDKKind2[\"DVMReqTimestamping\"] = 5900] = \"DVMReqTimestamping\";\n  NDKKind2[NDKKind2[\"DVMEventSchedule\"] = 5905] = \"DVMEventSchedule\";\n  NDKKind2[NDKKind2[\"DVMJobFeedback\"] = 7e3] = \"DVMJobFeedback\";\n  NDKKind2[NDKKind2[\"Subscribe\"] = 7001] = \"Subscribe\";\n  NDKKind2[NDKKind2[\"Unsubscribe\"] = 7002] = \"Unsubscribe\";\n  NDKKind2[NDKKind2[\"SubscriptionReceipt\"] = 7003] = \"SubscriptionReceipt\";\n  NDKKind2[NDKKind2[\"CashuReserve\"] = 7373] = \"CashuReserve\";\n  NDKKind2[NDKKind2[\"CashuQuote\"] = 7374] = \"CashuQuote\";\n  NDKKind2[NDKKind2[\"CashuToken\"] = 7375] = \"CashuToken\";\n  NDKKind2[NDKKind2[\"CashuWalletTx\"] = 7376] = \"CashuWalletTx\";\n  NDKKind2[NDKKind2[\"GroupAdminAddUser\"] = 9e3] = \"GroupAdminAddUser\";\n  NDKKind2[NDKKind2[\"GroupAdminRemoveUser\"] = 9001] = \"GroupAdminRemoveUser\";\n  NDKKind2[NDKKind2[\"GroupAdminEditMetadata\"] = 9002] = \"GroupAdminEditMetadata\";\n  NDKKind2[NDKKind2[\"GroupAdminEditStatus\"] = 9006] = \"GroupAdminEditStatus\";\n  NDKKind2[NDKKind2[\"GroupAdminCreateGroup\"] = 9007] = \"GroupAdminCreateGroup\";\n  NDKKind2[NDKKind2[\"GroupAdminRequestJoin\"] = 9021] = \"GroupAdminRequestJoin\";\n  NDKKind2[NDKKind2[\"MuteList\"] = 1e4] = \"MuteList\";\n  NDKKind2[NDKKind2[\"PinList\"] = 10001] = \"PinList\";\n  NDKKind2[NDKKind2[\"RelayList\"] = 10002] = \"RelayList\";\n  NDKKind2[NDKKind2[\"BookmarkList\"] = 10003] = \"BookmarkList\";\n  NDKKind2[NDKKind2[\"CommunityList\"] = 10004] = \"CommunityList\";\n  NDKKind2[NDKKind2[\"PublicChatList\"] = 10005] = \"PublicChatList\";\n  NDKKind2[NDKKind2[\"BlockRelayList\"] = 10006] = \"BlockRelayList\";\n  NDKKind2[NDKKind2[\"SearchRelayList\"] = 10007] = \"SearchRelayList\";\n  NDKKind2[NDKKind2[\"SimpleGroupList\"] = 10009] = \"SimpleGroupList\";\n  NDKKind2[NDKKind2[\"InterestList\"] = 10015] = \"InterestList\";\n  NDKKind2[NDKKind2[\"CashuMintList\"] = 10019] = \"CashuMintList\";\n  NDKKind2[NDKKind2[\"EmojiList\"] = 10030] = \"EmojiList\";\n  NDKKind2[NDKKind2[\"DirectMessageReceiveRelayList\"] = 10050] = \"DirectMessageReceiveRelayList\";\n  NDKKind2[NDKKind2[\"BlossomList\"] = 10063] = \"BlossomList\";\n  NDKKind2[NDKKind2[\"NostrWaletConnectInfo\"] = 13194] = \"NostrWaletConnectInfo\";\n  NDKKind2[NDKKind2[\"TierList\"] = 17e3] = \"TierList\";\n  NDKKind2[NDKKind2[\"CashuWallet\"] = 17375] = \"CashuWallet\";\n  NDKKind2[NDKKind2[\"FollowSet\"] = 3e4] = \"FollowSet\";\n  NDKKind2[NDKKind2[\"CategorizedPeopleList\"] = 3e4 /* FollowSet */] = \"CategorizedPeopleList\";\n  NDKKind2[NDKKind2[\"CategorizedBookmarkList\"] = 30001] = \"CategorizedBookmarkList\";\n  NDKKind2[NDKKind2[\"RelaySet\"] = 30002] = \"RelaySet\";\n  NDKKind2[NDKKind2[\"CategorizedRelayList\"] = 30002 /* RelaySet */] = \"CategorizedRelayList\";\n  NDKKind2[NDKKind2[\"BookmarkSet\"] = 30003] = \"BookmarkSet\";\n  NDKKind2[NDKKind2[\"CurationSet\"] = 30004] = \"CurationSet\";\n  NDKKind2[NDKKind2[\"ArticleCurationSet\"] = 30004] = \"ArticleCurationSet\";\n  NDKKind2[NDKKind2[\"VideoCurationSet\"] = 30005] = \"VideoCurationSet\";\n  NDKKind2[NDKKind2[\"ImageCurationSet\"] = 30006] = \"ImageCurationSet\";\n  NDKKind2[NDKKind2[\"InterestSet\"] = 30015] = \"InterestSet\";\n  NDKKind2[NDKKind2[\"InterestsList\"] = 30015 /* InterestSet */] = \"InterestsList\";\n  NDKKind2[NDKKind2[\"EmojiSet\"] = 30030] = \"EmojiSet\";\n  NDKKind2[NDKKind2[\"ModularArticle\"] = 30040] = \"ModularArticle\";\n  NDKKind2[NDKKind2[\"ModularArticleItem\"] = 30041] = \"ModularArticleItem\";\n  NDKKind2[NDKKind2[\"Wiki\"] = 30818] = \"Wiki\";\n  NDKKind2[NDKKind2[\"Draft\"] = 31234] = \"Draft\";\n  NDKKind2[NDKKind2[\"SubscriptionTier\"] = 37001] = \"SubscriptionTier\";\n  NDKKind2[NDKKind2[\"EcashMintRecommendation\"] = 38e3] = \"EcashMintRecommendation\";\n  NDKKind2[NDKKind2[\"HighlightSet\"] = 39802] = \"HighlightSet\";\n  NDKKind2[NDKKind2[\"CategorizedHighlightList\"] = 39802 /* HighlightSet */] = \"CategorizedHighlightList\";\n  NDKKind2[NDKKind2[\"Nutzap\"] = 9321] = \"Nutzap\";\n  NDKKind2[NDKKind2[\"ZapRequest\"] = 9734] = \"ZapRequest\";\n  NDKKind2[NDKKind2[\"Zap\"] = 9735] = \"Zap\";\n  NDKKind2[NDKKind2[\"Highlight\"] = 9802] = \"Highlight\";\n  NDKKind2[NDKKind2[\"ClientAuth\"] = 22242] = \"ClientAuth\";\n  NDKKind2[NDKKind2[\"NostrWalletConnectReq\"] = 23194] = \"NostrWalletConnectReq\";\n  NDKKind2[NDKKind2[\"NostrWalletConnectRes\"] = 23195] = \"NostrWalletConnectRes\";\n  NDKKind2[NDKKind2[\"NostrConnect\"] = 24133] = \"NostrConnect\";\n  NDKKind2[NDKKind2[\"BlossomUpload\"] = 24242] = \"BlossomUpload\";\n  NDKKind2[NDKKind2[\"HttpAuth\"] = 27235] = \"HttpAuth\";\n  NDKKind2[NDKKind2[\"ProfileBadge\"] = 30008] = \"ProfileBadge\";\n  NDKKind2[NDKKind2[\"BadgeDefinition\"] = 30009] = \"BadgeDefinition\";\n  NDKKind2[NDKKind2[\"MarketStall\"] = 30017] = \"MarketStall\";\n  NDKKind2[NDKKind2[\"MarketProduct\"] = 30018] = \"MarketProduct\";\n  NDKKind2[NDKKind2[\"Article\"] = 30023] = \"Article\";\n  NDKKind2[NDKKind2[\"AppSpecificData\"] = 30078] = \"AppSpecificData\";\n  NDKKind2[NDKKind2[\"Classified\"] = 30402] = \"Classified\";\n  NDKKind2[NDKKind2[\"HorizontalVideo\"] = 34235] = \"HorizontalVideo\";\n  NDKKind2[NDKKind2[\"VerticalVideo\"] = 34236] = \"VerticalVideo\";\n  NDKKind2[NDKKind2[\"LegacyCashuWallet\"] = 37375] = \"LegacyCashuWallet\";\n  NDKKind2[NDKKind2[\"GroupMetadata\"] = 39e3] = \"GroupMetadata\";\n  NDKKind2[NDKKind2[\"GroupAdmins\"] = 39001] = \"GroupAdmins\";\n  NDKKind2[NDKKind2[\"GroupMembers\"] = 39002] = \"GroupMembers\";\n  NDKKind2[NDKKind2[\"AppRecommendation\"] = 31989] = \"AppRecommendation\";\n  NDKKind2[NDKKind2[\"AppHandler\"] = 31990] = \"AppHandler\";\n  return NDKKind2;\n})(NDKKind || {});\nvar NDKListKinds = [\n  1e4 /* MuteList */,\n  10001 /* PinList */,\n  10002 /* RelayList */,\n  10003 /* BookmarkList */,\n  10004 /* CommunityList */,\n  10005 /* PublicChatList */,\n  10006 /* BlockRelayList */,\n  10007 /* SearchRelayList */,\n  10015 /* InterestList */,\n  10030 /* EmojiList */,\n  10050 /* DirectMessageReceiveRelayList */,\n  3e4 /* FollowSet */,\n  30003 /* BookmarkSet */,\n  30001 /* CategorizedBookmarkList */,\n  // Backwards compatibility\n  30002 /* RelaySet */,\n  30004 /* ArticleCurationSet */,\n  30005 /* VideoCurationSet */,\n  30015 /* InterestSet */,\n  30030 /* EmojiSet */,\n  39802 /* HighlightSet */\n];\n\n// src/events/index.ts\n\n\n// src/outbox/write.ts\nfunction getRelaysForSync(ndk, author, type = \"write\") {\n  if (!ndk.outboxTracker) return void 0;\n  const item = ndk.outboxTracker.data.get(author);\n  if (!item) return void 0;\n  if (type === \"write\") {\n    return item.writeRelays;\n  } else {\n    return item.readRelays;\n  }\n}\nasync function getWriteRelaysFor(ndk, author, type = \"write\") {\n  if (!ndk.outboxTracker) return void 0;\n  if (!ndk.outboxTracker.data.has(author)) {\n    await ndk.outboxTracker.trackUsers([author]);\n  }\n  return getRelaysForSync(ndk, author, type);\n}\n\n// src/outbox/relay-ranking.ts\nfunction getTopRelaysForAuthors(ndk, authors) {\n  const relaysWithCount = /* @__PURE__ */ new Map();\n  authors.forEach((author) => {\n    const writeRelays = getRelaysForSync(ndk, author);\n    if (writeRelays) {\n      writeRelays.forEach((relay) => {\n        const count = relaysWithCount.get(relay) || 0;\n        relaysWithCount.set(relay, count + 1);\n      });\n    }\n  });\n  const sortedRelays = Array.from(relaysWithCount.entries()).sort((a, b) => b[1] - a[1]);\n  return sortedRelays.map((entry) => entry[0]);\n}\n\n// src/outbox/index.ts\nfunction getAllRelaysForAllPubkeys(ndk, pubkeys, type = \"read\") {\n  const pubkeysToRelays = /* @__PURE__ */ new Map();\n  const authorsMissingRelays = /* @__PURE__ */ new Set();\n  pubkeys.forEach((pubkey) => {\n    const relays = getRelaysForSync(ndk, pubkey, type);\n    if (relays && relays.size > 0) {\n      relays.forEach((relay) => {\n        const pubkeysInRelay = pubkeysToRelays.get(relay) || /* @__PURE__ */ new Set();\n        pubkeysInRelay.add(pubkey);\n      });\n      pubkeysToRelays.set(pubkey, relays);\n    } else {\n      authorsMissingRelays.add(pubkey);\n    }\n  });\n  return { pubkeysToRelays, authorsMissingRelays };\n}\nfunction chooseRelayCombinationForPubkeys(ndk, pubkeys, type, { count, preferredRelays } = {}) {\n  count ??= 2;\n  preferredRelays ??= /* @__PURE__ */ new Set();\n  const pool = ndk.pool;\n  const connectedRelays = pool.connectedRelays();\n  connectedRelays.forEach((relay) => {\n    preferredRelays.add(relay.url);\n  });\n  const relayToAuthorsMap = /* @__PURE__ */ new Map();\n  const { pubkeysToRelays, authorsMissingRelays } = getAllRelaysForAllPubkeys(ndk, pubkeys, type);\n  const sortedRelays = getTopRelaysForAuthors(ndk, pubkeys);\n  const addAuthorToRelay = (author, relay) => {\n    const authorsInRelay = relayToAuthorsMap.get(relay) || [];\n    authorsInRelay.push(author);\n    relayToAuthorsMap.set(relay, authorsInRelay);\n  };\n  for (const [author, authorRelays] of pubkeysToRelays.entries()) {\n    let missingRelayCount = count;\n    for (const relay of connectedRelays) {\n      if (authorRelays.has(relay.url)) {\n        addAuthorToRelay(author, relay.url);\n        missingRelayCount--;\n      }\n    }\n    for (const authorRelay of authorRelays) {\n      if (relayToAuthorsMap.has(authorRelay)) {\n        addAuthorToRelay(author, authorRelay);\n        missingRelayCount--;\n      }\n    }\n    if (missingRelayCount <= 0) continue;\n    for (const relay of sortedRelays) {\n      if (missingRelayCount <= 0) break;\n      if (authorRelays.has(relay)) {\n        addAuthorToRelay(author, relay);\n        missingRelayCount--;\n      }\n    }\n  }\n  for (const author of authorsMissingRelays) {\n    pool.permanentAndConnectedRelays().forEach((relay) => {\n      const authorsInRelay = relayToAuthorsMap.get(relay.url) || [];\n      authorsInRelay.push(author);\n      relayToAuthorsMap.set(relay.url, authorsInRelay);\n    });\n  }\n  return relayToAuthorsMap;\n}\n\n// src/outbox/read/with-authors.ts\nfunction getRelaysForFilterWithAuthors(ndk, authors, relayGoalPerAuthor = 2) {\n  return chooseRelayCombinationForPubkeys(ndk, authors, \"write\", { count: relayGoalPerAuthor });\n}\n\n// src/utils/normalize-url.ts\nfunction tryNormalizeRelayUrl(url) {\n  try {\n    return normalizeRelayUrl(url);\n  } catch {\n    return void 0;\n  }\n}\nfunction normalizeRelayUrl(url) {\n  let r = normalizeUrl(url, {\n    stripAuthentication: false,\n    stripWWW: false,\n    stripHash: true\n  });\n  if (!r.endsWith(\"/\")) {\n    r += \"/\";\n  }\n  return r;\n}\nfunction normalize(urls) {\n  const normalized = /* @__PURE__ */ new Set();\n  for (const url of urls) {\n    try {\n      normalized.add(normalizeRelayUrl(url));\n    } catch {\n    }\n  }\n  return Array.from(normalized);\n}\nvar DATA_URL_DEFAULT_MIME_TYPE = \"text/plain\";\nvar DATA_URL_DEFAULT_CHARSET = \"us-ascii\";\nvar testParameter = (name, filters) => filters.some((filter) => filter instanceof RegExp ? filter.test(name) : filter === name);\nvar supportedProtocols = /* @__PURE__ */ new Set([\"https:\", \"http:\", \"file:\"]);\nvar hasCustomProtocol = (urlString) => {\n  try {\n    const { protocol } = new URL(urlString);\n    return protocol.endsWith(\":\") && !protocol.includes(\".\") && !supportedProtocols.has(protocol);\n  } catch {\n    return false;\n  }\n};\nvar normalizeDataURL = (urlString, { stripHash }) => {\n  const match = /^data:(?<type>[^,]*?),(?<data>[^#]*?)(?:#(?<hash>.*))?$/.exec(urlString);\n  if (!match) {\n    throw new Error(`Invalid URL: ${urlString}`);\n  }\n  let type = match.groups?.type ?? \"\";\n  let data = match.groups?.data ?? \"\";\n  let hash = match.groups?.hash ?? \"\";\n  const mediaType = type.split(\";\");\n  hash = stripHash ? \"\" : hash;\n  let isBase64 = false;\n  if (mediaType[mediaType.length - 1] === \"base64\") {\n    mediaType.pop();\n    isBase64 = true;\n  }\n  const mimeType = mediaType.shift()?.toLowerCase() ?? \"\";\n  const attributes = mediaType.map((attribute) => {\n    let [key, value = \"\"] = attribute.split(\"=\").map((string) => string.trim());\n    if (key === \"charset\") {\n      value = value.toLowerCase();\n      if (value === DATA_URL_DEFAULT_CHARSET) {\n        return \"\";\n      }\n    }\n    return `${key}${value ? `=${value}` : \"\"}`;\n  }).filter(Boolean);\n  const normalizedMediaType = [...attributes];\n  if (isBase64) {\n    normalizedMediaType.push(\"base64\");\n  }\n  if (normalizedMediaType.length > 0 || mimeType && mimeType !== DATA_URL_DEFAULT_MIME_TYPE) {\n    normalizedMediaType.unshift(mimeType);\n  }\n  return `data:${normalizedMediaType.join(\";\")},${isBase64 ? data.trim() : data}${hash ? `#${hash}` : \"\"}`;\n};\nfunction normalizeUrl(urlString, options = {}) {\n  options = {\n    defaultProtocol: \"http\",\n    normalizeProtocol: true,\n    forceHttp: false,\n    forceHttps: false,\n    stripAuthentication: true,\n    stripHash: false,\n    stripTextFragment: true,\n    stripWWW: true,\n    removeQueryParameters: [/^utm_\\w+/i],\n    removeTrailingSlash: true,\n    removeSingleSlash: true,\n    removeDirectoryIndex: false,\n    removeExplicitPort: false,\n    sortQueryParameters: true,\n    ...options\n  };\n  if (typeof options.defaultProtocol === \"string\" && !options.defaultProtocol.endsWith(\":\")) {\n    options.defaultProtocol = `${options.defaultProtocol}:`;\n  }\n  urlString = urlString.trim();\n  if (/^data:/i.test(urlString)) {\n    return normalizeDataURL(urlString, options);\n  }\n  if (hasCustomProtocol(urlString)) {\n    return urlString;\n  }\n  const hasRelativeProtocol = urlString.startsWith(\"//\");\n  const isRelativeUrl = !hasRelativeProtocol && /^\\.*\\//.test(urlString);\n  if (!isRelativeUrl) {\n    urlString = urlString.replace(/^(?!(?:\\w+:)?\\/\\/)|^\\/\\//, options.defaultProtocol);\n  }\n  const urlObject = new URL(urlString);\n  urlObject.hostname = urlObject.hostname.toLowerCase();\n  if (options.forceHttp && options.forceHttps) {\n    throw new Error(\"The `forceHttp` and `forceHttps` options cannot be used together\");\n  }\n  if (options.forceHttp && urlObject.protocol === \"https:\") {\n    urlObject.protocol = \"http:\";\n  }\n  if (options.forceHttps && urlObject.protocol === \"http:\") {\n    urlObject.protocol = \"https:\";\n  }\n  if (options.stripAuthentication) {\n    urlObject.username = \"\";\n    urlObject.password = \"\";\n  }\n  if (options.stripHash) {\n    urlObject.hash = \"\";\n  } else if (options.stripTextFragment) {\n    urlObject.hash = urlObject.hash.replace(/#?:~:text.*?$/i, \"\");\n  }\n  if (urlObject.pathname) {\n    const protocolRegex = /\\b[a-z][a-z\\d+\\-.]{1,50}:\\/\\//g;\n    let lastIndex = 0;\n    let result = \"\";\n    for (; ; ) {\n      const match = protocolRegex.exec(urlObject.pathname);\n      if (!match) {\n        break;\n      }\n      const protocol = match[0];\n      const protocolAtIndex = match.index;\n      const intermediate = urlObject.pathname.slice(lastIndex, protocolAtIndex);\n      result += intermediate.replace(/\\/{2,}/g, \"/\");\n      result += protocol;\n      lastIndex = protocolAtIndex + protocol.length;\n    }\n    const remnant = urlObject.pathname.slice(lastIndex, urlObject.pathname.length);\n    result += remnant.replace(/\\/{2,}/g, \"/\");\n    urlObject.pathname = result;\n  }\n  if (urlObject.pathname) {\n    try {\n      urlObject.pathname = decodeURI(urlObject.pathname);\n    } catch {\n    }\n  }\n  if (options.removeDirectoryIndex === true) {\n    options.removeDirectoryIndex = [/^index\\.[a-z]+$/];\n  }\n  if (Array.isArray(options.removeDirectoryIndex) && options.removeDirectoryIndex.length > 0) {\n    let pathComponents = urlObject.pathname.split(\"/\");\n    const lastComponent = pathComponents[pathComponents.length - 1];\n    if (testParameter(lastComponent, options.removeDirectoryIndex)) {\n      pathComponents = pathComponents.slice(0, -1);\n      urlObject.pathname = pathComponents.slice(1).join(\"/\") + \"/\";\n    }\n  }\n  if (urlObject.hostname) {\n    urlObject.hostname = urlObject.hostname.replace(/\\.$/, \"\");\n    if (options.stripWWW && /^www\\.(?!www\\.)[a-z\\-\\d]{1,63}\\.[a-z.\\-\\d]{2,63}$/.test(urlObject.hostname)) {\n      urlObject.hostname = urlObject.hostname.replace(/^www\\./, \"\");\n    }\n  }\n  if (Array.isArray(options.removeQueryParameters)) {\n    for (const key of [...urlObject.searchParams.keys()]) {\n      if (testParameter(key, options.removeQueryParameters)) {\n        urlObject.searchParams.delete(key);\n      }\n    }\n  }\n  if (!Array.isArray(options.keepQueryParameters) && options.removeQueryParameters === true) {\n    urlObject.search = \"\";\n  }\n  if (Array.isArray(options.keepQueryParameters) && options.keepQueryParameters.length > 0) {\n    for (const key of [...urlObject.searchParams.keys()]) {\n      if (!testParameter(key, options.keepQueryParameters)) {\n        urlObject.searchParams.delete(key);\n      }\n    }\n  }\n  if (options.sortQueryParameters) {\n    urlObject.searchParams.sort();\n    try {\n      urlObject.search = decodeURIComponent(urlObject.search);\n    } catch {\n    }\n  }\n  if (options.removeTrailingSlash) {\n    urlObject.pathname = urlObject.pathname.replace(/\\/$/, \"\");\n  }\n  if (options.removeExplicitPort && urlObject.port) {\n    urlObject.port = \"\";\n  }\n  const oldUrlString = urlString;\n  urlString = urlObject.toString();\n  if (!options.removeSingleSlash && urlObject.pathname === \"/\" && !oldUrlString.endsWith(\"/\") && urlObject.hash === \"\") {\n    urlString = urlString.replace(/\\/$/, \"\");\n  }\n  if ((options.removeTrailingSlash || urlObject.pathname === \"/\") && urlObject.hash === \"\" && options.removeSingleSlash) {\n    urlString = urlString.replace(/\\/$/, \"\");\n  }\n  if (hasRelativeProtocol && !options.normalizeProtocol) {\n    urlString = urlString.replace(/^http:\\/\\//, \"//\");\n  }\n  if (options.stripProtocol) {\n    urlString = urlString.replace(/^(?:https?:)?\\/\\//, \"\");\n  }\n  return urlString;\n}\n\n// src/relay/index.ts\n\n\n\n// src/relay/connectivity.ts\nvar MAX_RECONNECT_ATTEMPTS = 5;\nvar FLAPPING_THRESHOLD_MS = 1e3;\nvar NDKRelayConnectivity = class {\n  ndkRelay;\n  ws;\n  _status;\n  timeoutMs;\n  connectedAt;\n  _connectionStats = {\n    attempts: 0,\n    success: 0,\n    durations: []\n  };\n  debug;\n  netDebug;\n  connectTimeout;\n  reconnectTimeout;\n  ndk;\n  openSubs = /* @__PURE__ */ new Map();\n  openCountRequests = /* @__PURE__ */ new Map();\n  openEventPublishes = /* @__PURE__ */ new Map();\n  serial = 0;\n  baseEoseTimeout = 4400;\n  constructor(ndkRelay, ndk) {\n    this.ndkRelay = ndkRelay;\n    this._status = 1 /* DISCONNECTED */;\n    const rand = Math.floor(Math.random() * 1e3);\n    this.debug = this.ndkRelay.debug.extend(\"connectivity\" + rand);\n    this.ndk = ndk;\n  }\n  /**\n   * Connects to the NDK relay and handles the connection lifecycle.\n   *\n   * This method attempts to establish a WebSocket connection to the NDK relay specified in the `ndkRelay` object.\n   * If the connection is successful, it updates the connection statistics, sets the connection status to `CONNECTED`,\n   * and emits `connect` and `ready` events on the `ndkRelay` object.\n   *\n   * If the connection attempt fails, it handles the error by either initiating a reconnection attempt or emitting a\n   * `delayed-connect` event on the `ndkRelay` object, depending on the `reconnect` parameter.\n   *\n   * @param timeoutMs - The timeout in milliseconds for the connection attempt. If not provided, the default timeout from the `ndkRelay` object is used.\n   * @param reconnect - Indicates whether a reconnection should be attempted if the connection fails. Defaults to `true`.\n   * @returns A Promise that resolves when the connection is established, or rejects if the connection fails.\n   */\n  async connect(timeoutMs, reconnect = true) {\n    if (this._status !== 2 /* RECONNECTING */ && this._status !== 1 /* DISCONNECTED */ || this.reconnectTimeout) {\n      this.debug(\n        \"Relay requested to be connected but was in state %s or it had a reconnect timeout\",\n        this._status\n      );\n      return;\n    }\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = void 0;\n    }\n    if (this.connectTimeout) {\n      clearTimeout(this.connectTimeout);\n      this.connectTimeout = void 0;\n    }\n    timeoutMs ??= this.timeoutMs;\n    if (!this.timeoutMs && timeoutMs) this.timeoutMs = timeoutMs;\n    if (this.timeoutMs)\n      this.connectTimeout = setTimeout(\n        () => this.onConnectionError(reconnect),\n        this.timeoutMs\n      );\n    try {\n      this.updateConnectionStats.attempt();\n      if (this._status === 1 /* DISCONNECTED */)\n        this._status = 4 /* CONNECTING */;\n      else this._status = 2 /* RECONNECTING */;\n      this.ws = new WebSocket(this.ndkRelay.url);\n      this.ws.onopen = this.onConnect.bind(this);\n      this.ws.onclose = this.onDisconnect.bind(this);\n      this.ws.onmessage = this.onMessage.bind(this);\n      this.ws.onerror = this.onError.bind(this);\n    } catch (e) {\n      this.debug(`Failed to connect to ${this.ndkRelay.url}`, e);\n      this._status = 1 /* DISCONNECTED */;\n      if (reconnect) this.handleReconnection();\n      else this.ndkRelay.emit(\"delayed-connect\", 2 * 24 * 60 * 60 * 1e3);\n      throw e;\n    }\n  }\n  /**\n   * Disconnects the WebSocket connection to the NDK relay.\n   * This method sets the connection status to `NDKRelayStatus.DISCONNECTING`,\n   * attempts to close the WebSocket connection, and sets the status to\n   * `NDKRelayStatus.DISCONNECTED` if the disconnect operation fails.\n   */\n  disconnect() {\n    this._status = 0 /* DISCONNECTING */;\n    try {\n      this.ws?.close();\n    } catch (e) {\n      this.debug(\"Failed to disconnect\", e);\n      this._status = 1 /* DISCONNECTED */;\n    }\n  }\n  /**\n   * Handles the error that occurred when attempting to connect to the NDK relay.\n   * If `reconnect` is `true`, this method will initiate a reconnection attempt.\n   * Otherwise, it will emit a `delayed-connect` event on the `ndkRelay` object,\n   * indicating that a reconnection should be attempted after a delay.\n   *\n   * @param reconnect - Indicates whether a reconnection should be attempted.\n   */\n  onConnectionError(reconnect) {\n    this.debug(`Error connecting to ${this.ndkRelay.url}`, this.timeoutMs);\n    if (reconnect && !this.reconnectTimeout) {\n      this.handleReconnection();\n    }\n  }\n  /**\n   * Handles the connection event when the WebSocket connection is established.\n   * This method is called when the WebSocket connection is successfully opened.\n   * It clears any existing connection and reconnection timeouts, updates the connection statistics,\n   * sets the connection status to `CONNECTED`, and emits `connect` and `ready` events on the `ndkRelay` object.\n   */\n  onConnect() {\n    this.netDebug?.(\"connected\", this.ndkRelay);\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = void 0;\n    }\n    if (this.connectTimeout) {\n      clearTimeout(this.connectTimeout);\n      this.connectTimeout = void 0;\n    }\n    this.updateConnectionStats.connected();\n    this._status = 5 /* CONNECTED */;\n    this.ndkRelay.emit(\"connect\");\n    this.ndkRelay.emit(\"ready\");\n  }\n  /**\n   * Handles the disconnection event when the WebSocket connection is closed.\n   * This method is called when the WebSocket connection is successfully closed.\n   * It updates the connection statistics, sets the connection status to `DISCONNECTED`,\n   * initiates a reconnection attempt if we didn't disconnect ourselves,\n   * and emits a `disconnect` event on the `ndkRelay` object.\n   */\n  onDisconnect() {\n    this.netDebug?.(\"disconnected\", this.ndkRelay);\n    this.updateConnectionStats.disconnected();\n    if (this._status === 5 /* CONNECTED */) {\n      this.handleReconnection();\n    }\n    this._status = 1 /* DISCONNECTED */;\n    this.ndkRelay.emit(\"disconnect\");\n  }\n  /**\n   * Handles incoming messages from the NDK relay WebSocket connection.\n   * This method is called whenever a message is received from the relay.\n   * It parses the message data and dispatches the appropriate handling logic based on the message type.\n   *\n   * @param event - The MessageEvent containing the received message data.\n   */\n  onMessage(event) {\n    this.netDebug?.(event.data, this.ndkRelay, \"recv\");\n    try {\n      const data = JSON.parse(event.data);\n      const [cmd, id, ...rest] = data;\n      switch (cmd) {\n        case \"EVENT\": {\n          const so = this.openSubs.get(id);\n          const event2 = data[2];\n          if (!so) {\n            this.debug(`Received event for unknown subscription ${id}`);\n            return;\n          }\n          so.onevent(event2);\n          return;\n        }\n        case \"COUNT\": {\n          const payload = data[2];\n          const cr = this.openCountRequests.get(id);\n          if (cr) {\n            cr.resolve(payload.count);\n            this.openCountRequests.delete(id);\n          }\n          return;\n        }\n        case \"EOSE\": {\n          const so = this.openSubs.get(id);\n          if (!so) return;\n          so.oneose(id);\n          return;\n        }\n        case \"OK\": {\n          const ok = data[2];\n          const reason = data[3];\n          const ep = this.openEventPublishes.get(id);\n          const firstEp = ep?.pop();\n          if (!ep || !firstEp) {\n            this.debug(\"Received OK for unknown event publish\", id);\n            return;\n          }\n          if (ok) firstEp.resolve(reason);\n          else firstEp.reject(new Error(reason));\n          if (ep.length === 0) {\n            this.openEventPublishes.delete(id);\n          } else {\n            this.openEventPublishes.set(id, ep);\n          }\n          return;\n        }\n        case \"CLOSED\": {\n          const so = this.openSubs.get(id);\n          if (!so) return;\n          so.onclosed(data[2]);\n          return;\n        }\n        case \"NOTICE\":\n          this.onNotice(data[1]);\n          return;\n        case \"AUTH\": {\n          this.onAuthRequested(data[1]);\n          return;\n        }\n      }\n    } catch (error) {\n      this.debug(\n        `Error parsing message from ${this.ndkRelay.url}: ${error.message}`,\n        error?.stack\n      );\n      return;\n    }\n  }\n  /**\n   * Handles an authentication request from the NDK relay.\n   *\n   * If an authentication policy is configured, it will be used to authenticate the connection.\n   * Otherwise, the `auth` event will be emitted to allow the application to handle the authentication.\n   *\n   * @param challenge - The authentication challenge provided by the NDK relay.\n   */\n  async onAuthRequested(challenge) {\n    const authPolicy = this.ndkRelay.authPolicy ?? this.ndk?.relayAuthDefaultPolicy;\n    this.debug(\"Relay requested authentication\", {\n      havePolicy: !!authPolicy\n    });\n    if (this._status === 7 /* AUTHENTICATING */) {\n      this.debug(\"Already authenticating, ignoring\");\n      return;\n    }\n    this._status = 6 /* AUTH_REQUESTED */;\n    if (authPolicy) {\n      if (this._status >= 5 /* CONNECTED */) {\n        this._status = 7 /* AUTHENTICATING */;\n        let res;\n        try {\n          res = await authPolicy(this.ndkRelay, challenge);\n        } catch (e) {\n          this.debug(\"Authentication policy threw an error\", e);\n          res = false;\n        }\n        this.debug(\"Authentication policy returned\", !!res);\n        if (res instanceof NDKEvent || res === true) {\n          if (res instanceof NDKEvent) {\n            await this.auth(res);\n          }\n          const authenticate = async () => {\n            if (this._status >= 5 /* CONNECTED */ && this._status < 8 /* AUTHENTICATED */) {\n              const event = new NDKEvent(this.ndk);\n              event.kind = 22242 /* ClientAuth */;\n              event.tags = [\n                [\"relay\", this.ndkRelay.url],\n                [\"challenge\", challenge]\n              ];\n              await event.sign();\n              this.auth(event).then(() => {\n                this._status = 8 /* AUTHENTICATED */;\n                this.ndkRelay.emit(\"authed\");\n                this.debug(\"Authentication successful\");\n              }).catch((e) => {\n                this._status = 6 /* AUTH_REQUESTED */;\n                this.ndkRelay.emit(\"auth:failed\", e);\n                this.debug(\"Authentication failed\", e);\n              });\n            } else {\n              this.debug(\n                \"Authentication failed, it changed status, status is %d\",\n                this._status\n              );\n            }\n          };\n          if (res === true) {\n            if (!this.ndk?.signer) {\n              this.debug(\"No signer available for authentication localhost\");\n              this.ndk?.once(\"signer:ready\", authenticate);\n            } else {\n              authenticate().catch((e) => {\n                console.error(\"Error authenticating\", e);\n              });\n            }\n          }\n          this._status = 5 /* CONNECTED */;\n          this.ndkRelay.emit(\"authed\");\n        }\n      }\n    } else {\n      this.ndkRelay.emit(\"auth\", challenge);\n    }\n  }\n  /**\n   * Handles errors that occur on the WebSocket connection to the relay.\n   * @param error - The error or event that occurred.\n   */\n  onError(error) {\n    this.debug(`WebSocket error on ${this.ndkRelay.url}:`, error);\n  }\n  /**\n   * Gets the current status of the NDK relay connection.\n   * @returns {NDKRelayStatus} The current status of the NDK relay connection.\n   */\n  get status() {\n    return this._status;\n  }\n  /**\n   * Checks if the NDK relay connection is currently available.\n   * @returns {boolean} `true` if the relay connection is in the `CONNECTED` status, `false` otherwise.\n   */\n  isAvailable() {\n    return this._status === 5 /* CONNECTED */;\n  }\n  /**\n   * Checks if the NDK relay connection is flapping, which means the connection is rapidly\n   * disconnecting and reconnecting. This is determined by analyzing the durations of the\n   * last three connection attempts. If the standard deviation of the durations is less\n   * than 1000 milliseconds, the connection is considered to be flapping.\n   *\n   * @returns {boolean} `true` if the connection is flapping, `false` otherwise.\n   */\n  isFlapping() {\n    const durations = this._connectionStats.durations;\n    if (durations.length % 3 !== 0) return false;\n    const sum = durations.reduce((a, b) => a + b, 0);\n    const avg = sum / durations.length;\n    const variance = durations.map((x) => Math.pow(x - avg, 2)).reduce((a, b) => a + b, 0) / durations.length;\n    const stdDev = Math.sqrt(variance);\n    const isFlapping = stdDev < FLAPPING_THRESHOLD_MS;\n    return isFlapping;\n  }\n  /**\n   * Handles a notice received from the NDK relay.\n   * If the notice indicates the relay is complaining (e.g. \"too many\" or \"maximum\"),\n   * the method disconnects from the relay and attempts to reconnect after a 2-second delay.\n   * A debug message is logged with the relay URL and the notice text.\n   * The \"notice\" event is emitted on the ndkRelay instance with the notice text.\n   *\n   * @param notice - The notice text received from the NDK relay.\n   */\n  async onNotice(notice) {\n    this.ndkRelay.emit(\"notice\", notice);\n  }\n  /**\n   * Attempts to reconnect to the NDK relay after a connection is lost.\n   * This function is called recursively to handle multiple reconnection attempts.\n   * It checks if the relay is flapping and emits a \"flapping\" event if so.\n   * It then calculates a delay before the next reconnection attempt based on the number of previous attempts.\n   * The function sets a timeout to execute the next reconnection attempt after the calculated delay.\n   * If the maximum number of reconnection attempts is reached, a debug message is logged.\n   *\n   * @param attempt - The current attempt number (default is 0).\n   */\n  handleReconnection(attempt = 0) {\n    if (this.reconnectTimeout) return;\n    if (this.isFlapping()) {\n      this.ndkRelay.emit(\"flapping\", this._connectionStats);\n      this._status = 3 /* FLAPPING */;\n      return;\n    }\n    const reconnectDelay = this.connectedAt ? Math.max(0, 6e4 - (Date.now() - this.connectedAt)) : 5e3 * (this._connectionStats.attempts + 1);\n    this.reconnectTimeout = setTimeout(() => {\n      this.reconnectTimeout = void 0;\n      this._status = 2 /* RECONNECTING */;\n      this.connect().catch((err) => {\n        if (attempt < MAX_RECONNECT_ATTEMPTS) {\n          setTimeout(\n            () => {\n              this.handleReconnection(attempt + 1);\n            },\n            1e3 * (attempt + 1) ^ 4\n          );\n        } else {\n          this.debug(\"Reconnect failed\");\n        }\n      });\n    }, reconnectDelay);\n    this.ndkRelay.emit(\"delayed-connect\", reconnectDelay);\n    this.debug(\"Reconnecting in\", reconnectDelay);\n    this._connectionStats.nextReconnectAt = Date.now() + reconnectDelay;\n  }\n  /**\n   * Sends a message to the NDK relay if the connection is in the CONNECTED state and the WebSocket is open.\n   * If the connection is not in the CONNECTED state or the WebSocket is not open, logs a debug message and throws an error.\n   *\n   * @param message - The message to send to the NDK relay.\n   * @throws {Error} If attempting to send on a closed relay connection.\n   */\n  async send(message) {\n    if (this._status >= 5 /* CONNECTED */ && this.ws?.readyState === WebSocket.OPEN) {\n      this.ws?.send(message);\n      this.netDebug?.(message, this.ndkRelay, \"send\");\n    } else {\n      this.debug(\n        `Not connected to ${this.ndkRelay.url} (%d), not sending message ${message}`,\n        this._status\n      );\n    }\n  }\n  /**\n   * Authenticates the NDK event by sending it to the NDK relay and returning a promise that resolves with the result.\n   *\n   * @param event - The NDK event to authenticate.\n   * @returns A promise that resolves with the authentication result.\n   */\n  async auth(event) {\n    const ret = new Promise((resolve, reject) => {\n      const val = this.openEventPublishes.get(event.id) ?? [];\n      val.push({ resolve, reject });\n      this.openEventPublishes.set(event.id, val);\n    });\n    this.send('[\"AUTH\",' + JSON.stringify(event.rawEvent()) + \"]\");\n    return ret;\n  }\n  /**\n   * Publishes an NDK event to the relay and returns a promise that resolves with the result.\n   *\n   * @param event - The NDK event to publish.\n   * @returns A promise that resolves with the result of the event publication.\n   * @throws {Error} If attempting to publish on a closed relay connection.\n   */\n  async publish(event) {\n    const ret = new Promise((resolve, reject) => {\n      const val = this.openEventPublishes.get(event.id) ?? [];\n      if (val.length > 0) {\n        console.warn(\n          \"Duplicate event publishing detected, you are publishing event \" + event.id + \" twice\"\n        );\n      }\n      val.push({ resolve, reject });\n      this.openEventPublishes.set(event.id, val);\n    });\n    this.send('[\"EVENT\",' + JSON.stringify(event) + \"]\");\n    return ret;\n  }\n  /**\n   * Counts the number of events that match the provided filters.\n   *\n   * @param filters - The filters to apply to the count request.\n   * @param params - An optional object containing a custom id for the count request.\n   * @returns A promise that resolves with the number of matching events.\n   * @throws {Error} If attempting to send the count request on a closed relay connection.\n   */\n  async count(filters, params) {\n    this.serial++;\n    const id = params?.id || \"count:\" + this.serial;\n    const ret = new Promise((resolve, reject) => {\n      this.openCountRequests.set(id, { resolve, reject });\n    });\n    this.send('[\"COUNT\",\"' + id + '\",' + JSON.stringify(filters).substring(1));\n    return ret;\n  }\n  close(subId, reason) {\n    this.send('[\"CLOSE\",\"' + subId + '\"]');\n    const sub = this.openSubs.get(subId);\n    this.openSubs.delete(subId);\n    if (sub) sub.onclose(reason);\n  }\n  /**\n   * Subscribes to the NDK relay with the provided filters and parameters.\n   *\n   * @param filters - The filters to apply to the subscription.\n   * @param params - The subscription parameters, including an optional custom id.\n   * @returns A new NDKRelaySubscription instance.\n   */\n  req(relaySub) {\n    this.send(\n      '[\"REQ\",\"' + relaySub.subId + '\",' + JSON.stringify(relaySub.executeFilters).substring(1)\n    ) + \"]\";\n    this.openSubs.set(relaySub.subId, relaySub);\n  }\n  /**\n   * Utility functions to update the connection stats.\n   */\n  updateConnectionStats = {\n    connected: () => {\n      this._connectionStats.success++;\n      this._connectionStats.connectedAt = Date.now();\n    },\n    disconnected: () => {\n      if (this._connectionStats.connectedAt) {\n        this._connectionStats.durations.push(\n          Date.now() - this._connectionStats.connectedAt\n        );\n        if (this._connectionStats.durations.length > 100) {\n          this._connectionStats.durations.shift();\n        }\n      }\n      this._connectionStats.connectedAt = void 0;\n    },\n    attempt: () => {\n      this._connectionStats.attempts++;\n      this._connectionStats.connectedAt = Date.now();\n    }\n  };\n  /** Returns the connection stats. */\n  get connectionStats() {\n    return this._connectionStats;\n  }\n  /** Returns the relay URL */\n  get url() {\n    return this.ndkRelay.url;\n  }\n  get connected() {\n    return this._status >= 5 /* CONNECTED */ && this.ws?.readyState === WebSocket.OPEN;\n  }\n};\n\n// src/relay/publisher.ts\nvar NDKRelayPublisher = class {\n  ndkRelay;\n  debug;\n  constructor(ndkRelay) {\n    this.ndkRelay = ndkRelay;\n    this.debug = ndkRelay.debug.extend(\"publisher\");\n  }\n  /**\n   * Published an event to the relay; if the relay is not connected, it will\n   * wait for the relay to connect before publishing the event.\n   *\n   * If the relay does not connect within the timeout, the publish operation\n   * will fail.\n   * @param event  The event to publish\n   * @param timeoutMs  The timeout for the publish operation in milliseconds\n   * @returns A promise that resolves when the event has been published or rejects if the operation times out\n   */\n  async publish(event, timeoutMs = 2500) {\n    let timeout;\n    const publishConnected = () => {\n      return new Promise((resolve, reject) => {\n        try {\n          this.publishEvent(event).then((result) => {\n            this.ndkRelay.emit(\"published\", event);\n            event.emit(\"relay:published\", this.ndkRelay);\n            resolve(true);\n          }).catch(reject);\n        } catch (err) {\n          reject(err);\n        }\n      });\n    };\n    const timeoutPromise = new Promise((_, reject) => {\n      timeout = setTimeout(() => {\n        timeout = void 0;\n        reject(new Error(\"Timeout: \" + timeoutMs + \"ms\"));\n      }, timeoutMs);\n    });\n    const onConnectHandler = () => {\n      publishConnected().then((result) => connectResolve(result)).catch((err) => connectReject(err));\n    };\n    let connectResolve;\n    let connectReject;\n    const onError = (err) => {\n      this.ndkRelay.debug(\"Publish failed\", err, event.id);\n      this.ndkRelay.emit(\"publish:failed\", event, err);\n      event.emit(\"relay:publish:failed\", this.ndkRelay, err);\n      throw err;\n    };\n    const onFinally = () => {\n      if (timeout) clearTimeout(timeout);\n      this.ndkRelay.removeListener(\"connect\", onConnectHandler);\n    };\n    if (this.ndkRelay.status >= 5 /* CONNECTED */) {\n      return Promise.race([publishConnected(), timeoutPromise]).catch(onError).finally(onFinally);\n    } else {\n      if (this.ndkRelay.status <= 1 /* DISCONNECTED */) {\n        console.warn(\n          \"Relay is disconnected, trying to connect to publish an event\",\n          this.ndkRelay.url\n        );\n        this.ndkRelay.connect();\n      } else {\n        console.warn(\n          \"Relay not connected, waiting for connection to publish an event\",\n          this.ndkRelay.url\n        );\n      }\n      return Promise.race([\n        new Promise((resolve, reject) => {\n          connectResolve = resolve;\n          connectReject = reject;\n          this.ndkRelay.once(\"connect\", onConnectHandler);\n        }),\n        timeoutPromise\n      ]).catch(onError).finally(onFinally);\n    }\n  }\n  async publishEvent(event) {\n    return this.ndkRelay.connectivity.publish(event.rawEvent());\n  }\n};\n\n// src/subscription/grouping.ts\nfunction filterFingerprint(filters, closeOnEose) {\n  const elements = [];\n  for (const filter of filters) {\n    const keys = Object.entries(filter || {}).map(([key, values]) => {\n      if ([\"since\", \"until\"].includes(key)) {\n        return key + \":\" + values;\n      } else {\n        return key;\n      }\n    }).sort().join(\"-\");\n    elements.push(keys);\n  }\n  let id = closeOnEose ? \"+\" : \"\";\n  id += elements.join(\"|\");\n  return id;\n}\nfunction mergeFilters(filters) {\n  const result = [];\n  const lastResult = {};\n  filters.filter((f) => !!f.limit).forEach((filterWithLimit) => result.push(filterWithLimit));\n  filters = filters.filter((f) => !f.limit);\n  if (filters.length === 0) return result;\n  filters.forEach((filter) => {\n    Object.entries(filter).forEach(([key, value]) => {\n      if (Array.isArray(value)) {\n        if (lastResult[key] === void 0) {\n          lastResult[key] = [...value];\n        } else {\n          lastResult[key] = Array.from(/* @__PURE__ */ new Set([...lastResult[key], ...value]));\n        }\n      } else {\n        lastResult[key] = value;\n      }\n    });\n  });\n  return [...result, lastResult];\n}\n\n// src/relay/subscription.ts\nvar NDKRelaySubscription = class {\n  fingerprint;\n  items = /* @__PURE__ */ new Map();\n  topSubManager;\n  debug;\n  /**\n   * Tracks the status of this REQ.\n   */\n  status = 0 /* INITIAL */;\n  onClose;\n  relay;\n  /**\n   * Whether this subscription has reached EOSE.\n   */\n  eosed = false;\n  /**\n   * Timeout at which this subscription will\n   * start executing.\n   */\n  executionTimer;\n  /**\n   * Track the time at which this subscription will fire.\n   */\n  fireTime;\n  /**\n   * The delay type that the current fireTime was calculated with.\n   */\n  delayType;\n  /**\n   * The filters that have been executed.\n   */\n  executeFilters;\n  id = Math.random().toString(36).substring(7);\n  /**\n   *\n   * @param fingerprint The fingerprint of this subscription.\n   */\n  constructor(relay, fingerprint, topSubManager) {\n    this.relay = relay;\n    this.topSubManager = topSubManager;\n    this.debug = relay.debug.extend(\"subscription-\" + this.id);\n    this.fingerprint = fingerprint || Math.random().toString(36).substring(7);\n  }\n  _subId;\n  get subId() {\n    if (this._subId) return this._subId;\n    this._subId = this.fingerprint.slice(0, 15);\n    return this._subId;\n  }\n  subIdParts = /* @__PURE__ */ new Set();\n  addSubIdPart(part) {\n    this.subIdParts.add(part);\n  }\n  addItem(subscription, filters) {\n    this.debug(\"Adding item\", { filters, internalId: subscription.internalId, status: this.status, fingerprint: this.fingerprint, id: this.subId, items: this.items, itemsSize: this.items.size });\n    if (this.items.has(subscription.internalId)) return;\n    subscription.on(\"close\", this.removeItem.bind(this, subscription));\n    this.items.set(subscription.internalId, { subscription, filters });\n    if (this.status !== 3 /* RUNNING */) {\n      if (subscription.subId && (!this._subId || this._subId.length < 48)) {\n        if (this.status === 0 /* INITIAL */ || this.status === 1 /* PENDING */) {\n          this.addSubIdPart(subscription.subId);\n        }\n      }\n    }\n    switch (this.status) {\n      case 0 /* INITIAL */:\n        this.evaluateExecutionPlan(subscription);\n        break;\n      case 3 /* RUNNING */:\n        console.log(\n          \"BUG: This should not happen: This subscription needs to catch up with a subscription that was already running\",\n          filters\n        );\n        break;\n      case 1 /* PENDING */:\n        this.evaluateExecutionPlan(subscription);\n        break;\n      case 4 /* CLOSED */:\n        this.debug(\n          \"Subscription is closed, cannot add new items %o (%o)\",\n          subscription,\n          filters\n        );\n        throw new Error(\"Cannot add new items to a closed subscription\");\n    }\n  }\n  /**\n   * A subscription has been closed, remove it from the list of items.\n   * @param subscription\n   */\n  removeItem(subscription) {\n    this.items.delete(subscription.internalId);\n    if (this.items.size === 0) {\n      if (!this.eosed) return;\n      this.close();\n      this.cleanup();\n    }\n  }\n  close() {\n    if (this.status === 4 /* CLOSED */) return;\n    const prevStatus = this.status;\n    this.status = 4 /* CLOSED */;\n    if (prevStatus === 3 /* RUNNING */) {\n      try {\n        this.relay.close(this.subId);\n      } catch (e) {\n        this.debug(\"Error closing subscription\", e, this);\n      }\n    } else {\n      this.debug(\"Subscription wanted to close but it wasn't running, this is probably ok\", {\n        subId: this.subId,\n        prevStatus,\n        sub: this\n      });\n    }\n    this.cleanup();\n  }\n  cleanup() {\n    if (this.executionTimer) clearTimeout(this.executionTimer);\n    this.relay.off(\"ready\", this.executeOnRelayReady);\n    this.relay.off(\"authed\", this.reExecuteAfterAuth);\n    if (this.onClose) this.onClose(this);\n  }\n  evaluateExecutionPlan(subscription) {\n    if (!subscription.isGroupable()) {\n      this.status = 1 /* PENDING */;\n      this.execute();\n      return;\n    }\n    if (subscription.filters.find((filter) => !!filter.limit)) {\n      this.executeFilters = this.compileFilters();\n      if (this.executeFilters.length >= 10) {\n        this.status = 1 /* PENDING */;\n        this.execute();\n        return;\n      }\n    }\n    const delay = subscription.groupableDelay;\n    const delayType = subscription.groupableDelayType;\n    if (!delay) throw new Error(\"Cannot group a subscription without a delay\");\n    if (this.status === 0 /* INITIAL */) {\n      this.schedule(delay, delayType);\n    } else {\n      const existingDelayType = this.delayType;\n      const timeUntilFire = this.fireTime - Date.now();\n      if (existingDelayType === \"at-least\" && delayType === \"at-least\") {\n        if (timeUntilFire < delay) {\n          if (this.executionTimer) clearTimeout(this.executionTimer);\n          this.schedule(delay, delayType);\n        }\n      } else if (existingDelayType === \"at-least\" && delayType === \"at-most\") {\n        if (timeUntilFire > delay) {\n          if (this.executionTimer) clearTimeout(this.executionTimer);\n          this.schedule(delay, delayType);\n        }\n      } else if (existingDelayType === \"at-most\" && delayType === \"at-most\") {\n        if (timeUntilFire > delay) {\n          if (this.executionTimer) clearTimeout(this.executionTimer);\n          this.schedule(delay, delayType);\n        }\n      } else if (existingDelayType === \"at-most\" && delayType === \"at-least\") {\n        if (timeUntilFire > delay) {\n          if (this.executionTimer) clearTimeout(this.executionTimer);\n          this.schedule(delay, delayType);\n        }\n      } else {\n        throw new Error(\n          \"Unknown delay type combination \" + existingDelayType + \" \" + delayType\n        );\n      }\n    }\n  }\n  schedule(delay, delayType) {\n    this.status = 1 /* PENDING */;\n    const currentTime = Date.now();\n    this.fireTime = currentTime + delay;\n    this.delayType = delayType;\n    const timer = setTimeout(this.execute.bind(this), delay);\n    if (delayType === \"at-least\") {\n      this.executionTimer = timer;\n    }\n  }\n  executeOnRelayReady = () => {\n    if (this.status !== 2 /* WAITING */) return;\n    if (this.items.size === 0) {\n      this.debug(\"No items to execute; this relay was probably too slow to respond and the caller gave up\", { status: this.status, fingerprint: this.fingerprint, items: this.items, itemsSize: this.items.size, id: this.id, subId: this.subId });\n      this.cleanup();\n      return;\n    }\n    this.debug(\"Executing on relay ready\", { status: this.status, fingerprint: this.fingerprint, items: this.items, itemsSize: this.items.size });\n    this.status = 1 /* PENDING */;\n    this.execute();\n  };\n  finalizeSubId() {\n    if (this.subIdParts.size > 0) {\n      this._subId = Array.from(this.subIdParts).join(\"-\");\n    } else {\n      this._subId = this.fingerprint.slice(0, 15);\n    }\n    this._subId += \"-\" + Math.random().toString(36).substring(2, 7);\n  }\n  // we do it this way so that we can remove the listener\n  reExecuteAfterAuth = (() => {\n    const oldSubId = this.subId;\n    this.debug(\"Re-executing after auth\", this.items.size);\n    if (this.eosed) {\n      this.relay.close(this.subId);\n    } else {\n      this.debug(\n        \"We are abandoning an opened subscription, once it EOSE's, the handler will close it\",\n        { oldSubId }\n      );\n    }\n    this._subId = void 0;\n    this.status = 1 /* PENDING */;\n    this.execute();\n    this.debug(\"Re-executed after auth %s \\u{1F449} %s\", oldSubId, this.subId);\n  }).bind(this);\n  execute() {\n    if (this.status !== 1 /* PENDING */) {\n      return;\n    }\n    if (!this.relay.connected) {\n      this.status = 2 /* WAITING */;\n      this.debug(\"Waiting for relay to be ready\", { status: this.status, id: this.subId, fingerprint: this.fingerprint, items: this.items, itemsSize: this.items.size });\n      this.relay.once(\"ready\", this.executeOnRelayReady);\n      return;\n    } else if (this.relay.status < 8 /* AUTHENTICATED */) {\n      this.relay.once(\"authed\", this.reExecuteAfterAuth);\n    }\n    this.status = 3 /* RUNNING */;\n    this.finalizeSubId();\n    this.executeFilters = this.compileFilters();\n    this.relay.req(this);\n  }\n  onstart() {\n  }\n  onevent(event) {\n    this.topSubManager.dispatchEvent(event, this.relay);\n  }\n  oneose(subId) {\n    this.eosed = true;\n    if (subId !== this.subId) {\n      this.debug(\"Received EOSE for an abandoned subscription\", subId, this.subId);\n      this.relay.close(subId);\n      return;\n    }\n    if (this.items.size === 0) {\n      this.close();\n    }\n    for (const { subscription } of this.items.values()) {\n      subscription.eoseReceived(this.relay);\n      if (subscription.closeOnEose) {\n        this.debug(\"Removing item because of EOSE\", { filters: subscription.filters, internalId: subscription.internalId, status: this.status, fingerprint: this.fingerprint, items: this.items, itemsSize: this.items.size });\n        this.removeItem(subscription);\n      }\n    }\n  }\n  onclose(reason) {\n    this.status = 4 /* CLOSED */;\n  }\n  onclosed(reason) {\n    if (!reason) return;\n    for (const { subscription } of this.items.values()) {\n      subscription.closedReceived(this.relay, reason);\n    }\n  }\n  /**\n   * Grabs the filters from all the subscriptions\n   * and merges them into a single filter.\n   */\n  compileFilters() {\n    const mergedFilters = [];\n    const filters = Array.from(this.items.values()).map((item) => item.filters);\n    if (!filters[0]) {\n      this.debug(\"\\u{1F440} No filters to merge\", this.items);\n      console.error(\"BUG: No filters to merge!\", this.items);\n      return [];\n    }\n    const filterCount = filters[0].length;\n    for (let i = 0; i < filterCount; i++) {\n      const allFiltersAtIndex = filters.map((filter) => filter[i]);\n      mergedFilters.push(...mergeFilters(allFiltersAtIndex));\n    }\n    return mergedFilters;\n  }\n};\n\n// src/relay/sub-manager.ts\nvar NDKRelaySubscriptionManager = class {\n  relay;\n  subscriptions;\n  generalSubManager;\n  /**\n   * @param relay - The relay instance.\n   * @param generalSubManager - The subscription manager instance.\n   */\n  constructor(relay, generalSubManager) {\n    this.relay = relay;\n    this.subscriptions = /* @__PURE__ */ new Map();\n    this.generalSubManager = generalSubManager;\n  }\n  /**\n   * Adds a subscription to the manager.\n   */\n  addSubscription(sub, filters) {\n    let relaySub;\n    if (!sub.isGroupable()) {\n      relaySub = this.createSubscription(sub, filters);\n    } else {\n      const filterFp = filterFingerprint(filters, sub.closeOnEose);\n      if (filterFp) {\n        const existingSubs = this.subscriptions.get(filterFp);\n        relaySub = (existingSubs || []).find(\n          (sub2) => sub2.status < 3 /* RUNNING */\n        );\n      }\n      relaySub ??= this.createSubscription(sub, filters, filterFp);\n    }\n    relaySub.addItem(sub, filters);\n  }\n  createSubscription(sub, filters, fingerprint) {\n    const relaySub = new NDKRelaySubscription(this.relay, fingerprint || null, this.generalSubManager);\n    relaySub.onClose = this.onRelaySubscriptionClose.bind(this);\n    const currentVal = this.subscriptions.get(relaySub.fingerprint) ?? [];\n    this.subscriptions.set(relaySub.fingerprint, [...currentVal, relaySub]);\n    return relaySub;\n  }\n  onRelaySubscriptionClose(sub) {\n    let currentVal = this.subscriptions.get(sub.fingerprint) ?? [];\n    if (!currentVal) {\n      console.warn(\n        \"Unexpectedly did not find a subscription with fingerprint\",\n        sub.fingerprint\n      );\n    } else if (currentVal.length === 1) {\n      this.subscriptions.delete(sub.fingerprint);\n    } else {\n      currentVal = currentVal.filter((s) => s.id !== sub.id);\n      this.subscriptions.set(sub.fingerprint, currentVal);\n    }\n  }\n};\n\n// src/relay/index.ts\nvar NDKRelayStatus = /* @__PURE__ */ ((NDKRelayStatus2) => {\n  NDKRelayStatus2[NDKRelayStatus2[\"DISCONNECTING\"] = 0] = \"DISCONNECTING\";\n  NDKRelayStatus2[NDKRelayStatus2[\"DISCONNECTED\"] = 1] = \"DISCONNECTED\";\n  NDKRelayStatus2[NDKRelayStatus2[\"RECONNECTING\"] = 2] = \"RECONNECTING\";\n  NDKRelayStatus2[NDKRelayStatus2[\"FLAPPING\"] = 3] = \"FLAPPING\";\n  NDKRelayStatus2[NDKRelayStatus2[\"CONNECTING\"] = 4] = \"CONNECTING\";\n  NDKRelayStatus2[NDKRelayStatus2[\"CONNECTED\"] = 5] = \"CONNECTED\";\n  NDKRelayStatus2[NDKRelayStatus2[\"AUTH_REQUESTED\"] = 6] = \"AUTH_REQUESTED\";\n  NDKRelayStatus2[NDKRelayStatus2[\"AUTHENTICATING\"] = 7] = \"AUTHENTICATING\";\n  NDKRelayStatus2[NDKRelayStatus2[\"AUTHENTICATED\"] = 8] = \"AUTHENTICATED\";\n  return NDKRelayStatus2;\n})(NDKRelayStatus || {});\nvar NDKRelay = class _NDKRelay extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  url;\n  scores;\n  connectivity;\n  subs;\n  publisher;\n  authPolicy;\n  /**\n   * The lowest validation ratio this relay can reach.\n   */\n  lowestValidationRatio;\n  /**\n   * Current validation ratio this relay is targeting.\n   */\n  targetValidationRatio;\n  validationRatioFn;\n  /**\n   * This tracks events that have been seen by this relay\n   * with a valid signature.\n   */\n  validatedEventCount = 0;\n  /**\n   * This tracks events that have been seen by this relay\n   * but have not been validated.\n   */\n  nonValidatedEventCount = 0;\n  /**\n   * Whether this relay is trusted.\n   *\n   * Trusted relay's events do not get their signature verified.\n   */\n  trusted = false;\n  complaining = false;\n  debug;\n  static defaultValidationRatioUpdateFn = (relay, validatedCount, nonValidatedCount) => {\n    if (relay.lowestValidationRatio === void 0 || relay.targetValidationRatio === void 0)\n      return 1;\n    let newRatio = relay.validationRatio;\n    if (relay.validationRatio > relay.targetValidationRatio) {\n      const factor = validatedCount / 100;\n      newRatio = Math.max(relay.lowestValidationRatio, relay.validationRatio - factor);\n    }\n    if (newRatio < relay.validationRatio) {\n      return newRatio;\n    }\n    return relay.validationRatio;\n  };\n  constructor(url, authPolicy, ndk) {\n    super();\n    this.url = normalizeRelayUrl(url);\n    this.scores = /* @__PURE__ */ new Map();\n    this.debug = debug__WEBPACK_IMPORTED_MODULE_1__(`ndk:relay:${url}`);\n    this.connectivity = new NDKRelayConnectivity(this, ndk);\n    this.connectivity.netDebug = ndk?.netDebug;\n    this.req = this.connectivity.req.bind(this.connectivity);\n    this.close = this.connectivity.close.bind(this.connectivity);\n    this.subs = new NDKRelaySubscriptionManager(this, ndk.subManager);\n    this.publisher = new NDKRelayPublisher(this);\n    this.authPolicy = authPolicy;\n    this.targetValidationRatio = ndk?.initialValidationRatio;\n    this.lowestValidationRatio = ndk?.lowestValidationRatio;\n    this.validationRatioFn = (ndk?.validationRatioFn ?? _NDKRelay.defaultValidationRatioUpdateFn).bind(this);\n    this.updateValidationRatio();\n    if (!ndk) {\n      console.trace(\"relay created without ndk\");\n    }\n  }\n  updateValidationRatio() {\n    setTimeout(() => {\n      this.updateValidationRatio();\n    }, 3e4);\n  }\n  get status() {\n    return this.connectivity.status;\n  }\n  get connectionStats() {\n    return this.connectivity.connectionStats;\n  }\n  /**\n   * Connects to the relay.\n   */\n  async connect(timeoutMs, reconnect = true) {\n    return this.connectivity.connect(timeoutMs, reconnect);\n  }\n  /**\n   * Disconnects from the relay.\n   */\n  disconnect() {\n    if (this.status === 1 /* DISCONNECTED */) {\n      return;\n    }\n    this.connectivity.disconnect();\n  }\n  /**\n   * Queues or executes the subscription of a specific set of filters\n   * within this relay.\n   *\n   * @param subscription NDKSubscription this filters belong to.\n   * @param filters Filters to execute\n   */\n  subscribe(subscription, filters) {\n    this.subs.addSubscription(subscription, filters);\n  }\n  /**\n   * Publishes an event to the relay with an optional timeout.\n   *\n   * If the relay is not connected, the event will be published when the relay connects,\n   * unless the timeout is reached before the relay connects.\n   *\n   * @param event The event to publish\n   * @param timeoutMs The timeout for the publish operation in milliseconds\n   * @returns A promise that resolves when the event has been published or rejects if the operation times out\n   */\n  async publish(event, timeoutMs = 2500) {\n    return this.publisher.publish(event, timeoutMs);\n  }\n  referenceTags() {\n    return [[\"r\", this.url]];\n  }\n  addValidatedEvent() {\n    this.validatedEventCount++;\n  }\n  addNonValidatedEvent() {\n    this.nonValidatedEventCount++;\n  }\n  /**\n   * The current validation ratio this relay has achieved.\n   */\n  get validationRatio() {\n    if (this.nonValidatedEventCount === 0) {\n      return 1;\n    }\n    return this.validatedEventCount / (this.validatedEventCount + this.nonValidatedEventCount);\n  }\n  shouldValidateEvent() {\n    if (this.trusted) {\n      return false;\n    }\n    if (this.targetValidationRatio === void 0) {\n      return true;\n    }\n    return this.validationRatio < this.targetValidationRatio;\n  }\n  get connected() {\n    return this.connectivity.connected;\n  }\n  req;\n  close;\n};\n\n// src/relay/sets/index.ts\nvar NDKPublishError = class extends Error {\n  errors;\n  publishedToRelays;\n  /**\n   * Intended relay set where the publishing was intended to happen.\n   */\n  intendedRelaySet;\n  constructor(message, errors, publishedToRelays, intendedRelaySet) {\n    super(message);\n    this.errors = errors;\n    this.publishedToRelays = publishedToRelays;\n    this.intendedRelaySet = intendedRelaySet;\n  }\n  get relayErrors() {\n    const errors = [];\n    for (const [relay, err] of this.errors) {\n      errors.push(`${relay.url}: ${err}`);\n    }\n    return errors.join(\"\\n\");\n  }\n};\nvar NDKRelaySet = class _NDKRelaySet {\n  relays;\n  debug;\n  ndk;\n  pool;\n  constructor(relays, ndk, pool) {\n    this.relays = relays;\n    this.ndk = ndk;\n    this.pool = pool ?? ndk.pool;\n    this.debug = ndk.debug.extend(\"relayset\");\n  }\n  /**\n   * Adds a relay to this set.\n   */\n  addRelay(relay) {\n    this.relays.add(relay);\n  }\n  get relayUrls() {\n    return Array.from(this.relays).map((r) => r.url);\n  }\n  /**\n   * Creates a relay set from a list of relay URLs.\n   *\n   * If no connection to the relay is found in the pool it will temporarily\n   * connect to it.\n   *\n   * @param relayUrls - list of relay URLs to include in this set\n   * @param ndk\n   * @param connect - whether to connect to the relay immediately if it was already in the pool but not connected\n   * @returns NDKRelaySet\n   */\n  static fromRelayUrls(relayUrls, ndk, connect = true, pool) {\n    pool = pool ?? ndk.pool;\n    if (!pool) throw new Error(\"No pool provided\");\n    const relays = /* @__PURE__ */ new Set();\n    for (const url of relayUrls) {\n      const relay = pool.relays.get(normalizeRelayUrl(url));\n      if (relay) {\n        if (relay.status < 5 /* CONNECTED */ && connect) {\n          relay.connect();\n        }\n        relays.add(relay);\n      } else {\n        const temporaryRelay = new NDKRelay(\n          normalizeRelayUrl(url),\n          ndk?.relayAuthDefaultPolicy,\n          ndk\n        );\n        pool.useTemporaryRelay(\n          temporaryRelay,\n          void 0,\n          \"requested from fromRelayUrls \" + relayUrls\n        );\n        relays.add(temporaryRelay);\n      }\n    }\n    return new _NDKRelaySet(new Set(relays), ndk, pool);\n  }\n  /**\n   * Publish an event to all relays in this set. Returns the number of relays that have received the event.\n   * @param event\n   * @param timeoutMs - timeout in milliseconds for each publish operation and connection operation\n   * @returns A set where the event was successfully published to\n   * @throws NDKPublishError if no relay was able to receive the event\n   * @example\n   * ```typescript\n   * const event = new NDKEvent(ndk, {kinds: [NDKKind.Message], \"#d\": [\"123\"]});\n   * try {\n   *    const publishedToRelays = await relaySet.publish(event);\n   *    console.log(`published to ${publishedToRelays.size} relays`)\n   * } catch (error) {\n   *   console.error(\"error publishing to relays\", error);\n   *\n   *   if (error instanceof NDKPublishError) {\n   *      for (const [relay, err] of error.errors) {\n   *         console.error(`error publishing to relay ${relay.url}`, err);\n   *       }\n   *   }\n   * }\n   * ```\n   */\n  async publish(event, timeoutMs, requiredRelayCount = 1) {\n    const publishedToRelays = /* @__PURE__ */ new Set();\n    const errors = /* @__PURE__ */ new Map();\n    const isEphemeral2 = event.isEphemeral();\n    event.publishStatus = \"pending\";\n    const promises = Array.from(this.relays).map((relay) => {\n      return new Promise((resolve) => {\n        relay.publish(event, timeoutMs).then((e) => {\n          publishedToRelays.add(relay);\n          resolve();\n        }).catch((err) => {\n          if (!isEphemeral2) {\n            errors.set(relay, err);\n          }\n          resolve();\n        });\n      });\n    });\n    await Promise.all(promises);\n    if (publishedToRelays.size < requiredRelayCount) {\n      if (!isEphemeral2) {\n        const error = new NDKPublishError(\n          \"Not enough relays received the event\",\n          errors,\n          publishedToRelays,\n          this\n        );\n        event.publishStatus = \"error\";\n        event.publishError = error;\n        this.ndk.emit(\"event:publish-failed\", event, error, this.relayUrls);\n        throw error;\n      }\n    } else {\n      event.emit(\"published\", { relaySet: this, publishedToRelays });\n    }\n    return publishedToRelays;\n  }\n  get size() {\n    return this.relays.size;\n  }\n};\n\n// src/relay/sets/calculate.ts\n\nvar d = debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:outbox:calculate\");\nasync function calculateRelaySetFromEvent(ndk, event) {\n  const relays = /* @__PURE__ */ new Set();\n  const authorWriteRelays = await getWriteRelaysFor(ndk, event.pubkey);\n  if (authorWriteRelays) {\n    authorWriteRelays.forEach((relayUrl) => {\n      const relay = ndk.pool?.getRelay(relayUrl);\n      if (relay) relays.add(relay);\n    });\n  }\n  let relayHints = event.tags.filter((tag) => [\"a\", \"e\"].includes(tag[0])).map((tag) => tag[2]).filter((url) => url && url.startsWith(\"wss://\")).filter((url) => {\n    try {\n      new URL(url);\n      return true;\n    } catch {\n      return false;\n    }\n  }).map((url) => normalizeRelayUrl(url));\n  relayHints = Array.from(new Set(relayHints)).slice(0, 5);\n  relayHints.forEach((relayUrl) => {\n    const relay = ndk.pool?.getRelay(relayUrl, true, true);\n    if (relay) {\n      d(\"Adding relay hint %s\", relayUrl);\n      relays.add(relay);\n    }\n  });\n  const pTags = event.getMatchingTags(\"p\").map((tag) => tag[1]);\n  if (pTags.length < 5) {\n    const pTaggedRelays = Array.from(\n      chooseRelayCombinationForPubkeys(ndk, pTags, \"read\", {\n        preferredRelays: new Set(authorWriteRelays)\n      }).keys()\n    );\n    pTaggedRelays.forEach((relayUrl) => {\n      const relay = ndk.pool?.getRelay(relayUrl, false, true);\n      if (relay) {\n        d(\"Adding p-tagged relay %s\", relayUrl);\n        relays.add(relay);\n      }\n    });\n  } else {\n    d(\"Too many p-tags to consider %d\", pTags.length);\n  }\n  ndk.pool?.permanentAndConnectedRelays().forEach((relay) => relays.add(relay));\n  return new NDKRelaySet(relays, ndk);\n}\nfunction calculateRelaySetsFromFilter(ndk, filters, pool) {\n  const result = /* @__PURE__ */ new Map();\n  const authors = /* @__PURE__ */ new Set();\n  filters.forEach((filter) => {\n    if (filter.authors) {\n      filter.authors.forEach((author) => authors.add(author));\n    }\n  });\n  if (authors.size > 0) {\n    const authorToRelaysMap = getRelaysForFilterWithAuthors(ndk, Array.from(authors));\n    for (const relayUrl of authorToRelaysMap.keys()) {\n      result.set(relayUrl, []);\n    }\n    for (const filter of filters) {\n      if (filter.authors) {\n        for (const [relayUrl, authors2] of authorToRelaysMap.entries()) {\n          const authorFilterAndRelayPubkeyIntersection = filter.authors.filter(\n            (author) => authors2.includes(author)\n          );\n          result.set(relayUrl, [\n            ...result.get(relayUrl),\n            {\n              ...filter,\n              // Overwrite authors sent to this relay with the authors that were\n              // present in the filter and are also present in the relay\n              authors: authorFilterAndRelayPubkeyIntersection\n            }\n          ]);\n        }\n      } else {\n        for (const relayUrl of authorToRelaysMap.keys()) {\n          result.set(relayUrl, [...result.get(relayUrl), filter]);\n        }\n      }\n    }\n  } else {\n    if (ndk.explicitRelayUrls) {\n      ndk.explicitRelayUrls.forEach((relayUrl) => {\n        result.set(relayUrl, filters);\n      });\n    }\n  }\n  if (result.size === 0) {\n    pool.permanentAndConnectedRelays().slice(0, 5).forEach((relay) => {\n      result.set(relay.url, filters);\n    });\n  }\n  return result;\n}\nfunction calculateRelaySetsFromFilters(ndk, filters, pool) {\n  const a = calculateRelaySetsFromFilter(ndk, filters, pool);\n  return a;\n}\n\n// src/events/content-tagger.ts\n\nfunction mergeTags(tags1, tags2) {\n  const tagMap = /* @__PURE__ */ new Map();\n  const generateKey = (tag) => tag.join(\",\");\n  const isContained = (smaller, larger) => {\n    return smaller.every((value, index) => value === larger[index]);\n  };\n  const processTag = (tag) => {\n    for (const [key, existingTag] of tagMap) {\n      if (isContained(existingTag, tag) || isContained(tag, existingTag)) {\n        if (tag.length >= existingTag.length) {\n          tagMap.set(key, tag);\n        }\n        return;\n      }\n    }\n    tagMap.set(generateKey(tag), tag);\n  };\n  tags1.concat(tags2).forEach(processTag);\n  return Array.from(tagMap.values());\n}\nfunction uniqueTag(a, b) {\n  const aLength = a.length;\n  const bLength = b.length;\n  const sameLength = aLength === bLength;\n  if (sameLength) {\n    if (a.every((v, i) => v === b[i])) {\n      return [a];\n    } else {\n      return [a, b];\n    }\n  } else if (aLength > bLength && a.every((v, i) => v === b[i])) {\n    return [a];\n  } else if (bLength > aLength && b.every((v, i) => v === a[i])) {\n    return [b];\n  }\n  return [a, b];\n}\nvar hashtagRegex = /(?<=\\s|^)(#[^\\s!@#$%^&*()=+./,[{\\]};:'\"?><]+)/g;\nfunction generateHashtags(content) {\n  const hashtags = content.match(hashtagRegex);\n  const tagIds = /* @__PURE__ */ new Set();\n  const tag = /* @__PURE__ */ new Set();\n  if (hashtags) {\n    for (const hashtag of hashtags) {\n      if (tagIds.has(hashtag.slice(1))) continue;\n      tag.add(hashtag.slice(1));\n      tagIds.add(hashtag.slice(1));\n    }\n  }\n  return Array.from(tag);\n}\nasync function generateContentTags(content, tags = []) {\n  const tagRegex = /(@|nostr:)(npub|nprofile|note|nevent|naddr)[a-zA-Z0-9]+/g;\n  const promises = [];\n  const addTagIfNew = (t) => {\n    if (!tags.find((t2) => [\"q\", t[0]].includes(t2[0]) && t2[1] === t[1])) {\n      tags.push(t);\n    }\n  };\n  content = content.replace(tagRegex, (tag) => {\n    try {\n      const entity = tag.split(/(@|nostr:)/)[2];\n      const { type, data } = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.decode(entity);\n      let t;\n      switch (type) {\n        case \"npub\":\n          t = [\"p\", data];\n          break;\n        case \"nprofile\":\n          t = [\"p\", data.pubkey];\n          break;\n        case \"note\":\n          promises.push(\n            new Promise(async (resolve) => {\n              addTagIfNew([\n                \"q\",\n                data,\n                await maybeGetEventRelayUrl(entity)\n              ]);\n              resolve();\n            })\n          );\n          break;\n        case \"nevent\":\n          promises.push(\n            new Promise(async (resolve) => {\n              const { id, author } = data;\n              let { relays } = data;\n              if (!relays || relays.length === 0) {\n                relays = [await maybeGetEventRelayUrl(entity)];\n              }\n              addTagIfNew([\"q\", id, relays[0]]);\n              if (author) addTagIfNew([\"p\", author]);\n              resolve();\n            })\n          );\n          break;\n        case \"naddr\":\n          promises.push(\n            new Promise(async (resolve) => {\n              const id = [data.kind, data.pubkey, data.identifier].join(\":\");\n              let relays = data.relays ?? [];\n              if (relays.length === 0) {\n                relays = [await maybeGetEventRelayUrl(entity)];\n              }\n              addTagIfNew([\"q\", id, relays[0]]);\n              addTagIfNew([\"p\", data.pubkey]);\n              resolve();\n            })\n          );\n          break;\n        default:\n          return tag;\n      }\n      if (t) addTagIfNew(t);\n      return `nostr:${entity}`;\n    } catch (error) {\n      return tag;\n    }\n  });\n  await Promise.all(promises);\n  const newTags = generateHashtags(content).map((hashtag) => [\"t\", hashtag]);\n  tags = mergeTags(tags, newTags);\n  return { content, tags };\n}\nasync function maybeGetEventRelayUrl(nip19Id) {\n  return \"\";\n}\n\n// src/events/kind.ts\nfunction isReplaceable() {\n  if (this.kind === void 0) throw new Error(\"Kind not set\");\n  return [0, 3].includes(this.kind) || this.kind >= 1e4 && this.kind < 2e4 || this.kind >= 3e4 && this.kind < 4e4;\n}\nfunction isEphemeral() {\n  if (this.kind === void 0) throw new Error(\"Kind not set\");\n  return this.kind >= 2e4 && this.kind < 3e4;\n}\nfunction isParamReplaceable() {\n  if (this.kind === void 0) throw new Error(\"Kind not set\");\n  return this.kind >= 3e4 && this.kind < 4e4;\n}\n\n// src/events/encryption.ts\nasync function encrypt(recipient, signer, scheme = \"nip44\") {\n  let encrypted;\n  if (!this.ndk) throw new Error(\"No NDK instance found!\");\n  if (!signer) {\n    this.ndk.assertSigner();\n    signer = this.ndk.signer;\n  }\n  if (!recipient) {\n    const pTags = this.getMatchingTags(\"p\");\n    if (pTags.length !== 1) {\n      throw new Error(\n        \"No recipient could be determined and no explicit recipient was provided\"\n      );\n    }\n    recipient = this.ndk.getUser({ pubkey: pTags[0][1] });\n  }\n  if (scheme === \"nip44\" && await isEncryptionEnabled(signer, \"nip44\")) {\n    encrypted = await signer?.encrypt(recipient, this.content, \"nip44\");\n  }\n  if ((!encrypted || scheme === \"nip04\") && await isEncryptionEnabled(signer, \"nip04\")) {\n    encrypted = await signer.encrypt(recipient, this.content, \"nip04\");\n  }\n  if (!encrypted) throw new Error(\"Failed to encrypt event.\");\n  this.content = encrypted;\n}\nasync function decrypt(sender, signer, scheme) {\n  let decrypted;\n  if (!this.ndk) throw new Error(\"No NDK instance found!\");\n  if (!signer) {\n    this.ndk.assertSigner();\n    signer = this.ndk.signer;\n  }\n  if (!signer) throw new Error(\"no NDK signer\");\n  if (!sender) {\n    sender = this.author;\n  }\n  if (!scheme) scheme = this.content.match(/\\\\?iv=/) ? \"nip04\" : \"nip44\";\n  if ((scheme === \"nip04\" || this.kind === 4) && await isEncryptionEnabled(signer, \"nip04\") && this.content.search(\"\\\\?iv=\")) {\n    decrypted = await signer.decrypt(sender, this.content, \"nip04\");\n  }\n  if (!decrypted && scheme === \"nip44\" && await isEncryptionEnabled(signer, \"nip44\")) {\n    decrypted = await signer.decrypt(sender, this.content, \"nip44\");\n  }\n  if (!decrypted) throw new Error(\"Failed to decrypt event.\");\n  this.content = decrypted;\n}\nasync function isEncryptionEnabled(signer, scheme) {\n  if (!signer.encryptionEnabled) return false;\n  if (!scheme) return true;\n  return Boolean(await signer.encryptionEnabled(scheme));\n}\n\n// src/events/nip19.ts\n\nvar DEFAULT_RELAY_COUNT = 2;\nfunction encode(maxRelayCount = DEFAULT_RELAY_COUNT) {\n  let relays = [];\n  if (this.onRelays.length > 0) {\n    relays = this.onRelays.map((relay) => relay.url);\n  } else if (this.relay) {\n    relays = [this.relay.url];\n  }\n  if (relays.length > maxRelayCount) {\n    relays = relays.slice(0, maxRelayCount);\n  }\n  if (this.isParamReplaceable()) {\n    return nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.naddrEncode({\n      kind: this.kind,\n      pubkey: this.pubkey,\n      identifier: this.replaceableDTag(),\n      relays\n    });\n  } else if (relays.length > 0) {\n    return nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.neventEncode({\n      id: this.tagId(),\n      relays,\n      author: this.pubkey\n    });\n  } else {\n    return nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.noteEncode(this.tagId());\n  }\n}\n\n// src/events/repost.ts\nasync function repost(publish = true, signer) {\n  if (!signer && publish) {\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    this.ndk.assertSigner();\n    signer = this.ndk.signer;\n  }\n  const e = new NDKEvent(this.ndk, {\n    kind: getKind(this)\n  });\n  if (!this.isProtected)\n    e.content = JSON.stringify(this.rawEvent());\n  e.tag(this);\n  if (this.kind !== 1 /* Text */) {\n    e.tags.push([\"k\", `${this.kind}`]);\n  }\n  if (signer) await e.sign(signer);\n  if (publish) await e.publish();\n  return e;\n}\nfunction getKind(event) {\n  if (event.kind === 1) {\n    return 6 /* Repost */;\n  }\n  return 16 /* GenericRepost */;\n}\n\n// src/thread/index.ts\nfunction eventsBySameAuthor(op, events) {\n  const eventsByAuthor = /* @__PURE__ */ new Map();\n  eventsByAuthor.set(op.id, op);\n  events.forEach((event) => {\n    if (event.pubkey === op.pubkey) {\n      eventsByAuthor.set(event.id, event);\n    }\n  });\n  return eventsByAuthor;\n}\nvar hasMarkers = (event, tagType) => {\n  return event.getMatchingTags(tagType).some((tag) => tag[3] && tag[3] !== \"\");\n};\nfunction eventIsReply(op, event, threadIds = /* @__PURE__ */ new Set(), tagType) {\n  tagType ??= op.tagType();\n  const tags = event.getMatchingTags(tagType);\n  threadIds.add(op.tagId());\n  if (threadIds.has(event.tagId())) return false;\n  const heedExplicitReplyMarker = () => {\n    let eventIsTagged = false;\n    for (const tag of tags) {\n      if (tag[3] === \"reply\") return threadIds.has(tag[1]);\n      const markerIsEmpty = tag[3] === \"\" || tag[3] === void 0;\n      const markerIsRoot = tag[3] === \"root\";\n      if (tag[1] === op.tagId() && (markerIsEmpty || markerIsRoot)) {\n        eventIsTagged = markerIsRoot ? \"root\" : true;\n      }\n    }\n    if (!eventIsTagged) return false;\n    if (eventIsTagged === \"root\") return true;\n  };\n  const explicitReplyMarker = heedExplicitReplyMarker();\n  if (explicitReplyMarker !== void 0) return explicitReplyMarker;\n  if (hasMarkers(event, tagType)) return false;\n  const expectedTags = op.getMatchingTags(\"e\").map((tag) => tag[1]);\n  expectedTags.push(op.id);\n  return event.getMatchingTags(\"e\").every((tag) => expectedTags.includes(tag[1]));\n}\nfunction eventThreads(op, events) {\n  const eventsByAuthor = eventsBySameAuthor(op, events);\n  const threadEvents = events.filter((event) => eventIsPartOfThread(op, event, eventsByAuthor));\n  return threadEvents.sort((a, b) => a.created_at - b.created_at);\n}\nfunction getEventReplyId(event) {\n  const replyTag = getReplyTag(event);\n  if (replyTag) return replyTag[1];\n  const rootTag = getRootTag(event);\n  if (rootTag) return rootTag[1];\n}\nfunction isEventOriginalPost(event) {\n  return getEventReplyId(event) === void 0;\n}\nfunction eventThreadIds(op, events) {\n  const threadIds = /* @__PURE__ */ new Map();\n  const threadEvents = eventThreads(op, events);\n  threadEvents.forEach((event) => threadIds.set(event.id, event));\n  return threadIds;\n}\nfunction eventReplies(op, events, threadEventIds) {\n  threadEventIds ??= new Set(eventThreadIds(op, events).keys());\n  return events.filter((event) => eventIsReply(op, event, threadEventIds));\n}\nfunction eventIsPartOfThread(op, event, eventsByAuthor) {\n  if (op.pubkey !== event.pubkey) return false;\n  const taggedEventIds = event.getMatchingTags(\"e\").map((tag) => tag[1]);\n  const allTaggedEventsAreByOriginalAuthor = taggedEventIds.every((id) => eventsByAuthor.has(id));\n  return allTaggedEventsAreByOriginalAuthor;\n}\nfunction eventHasETagMarkers(event) {\n  for (const tag of event.tags) {\n    if (tag[0] === \"e\" && (tag[3] ?? \"\").length > 0) return true;\n  }\n  return false;\n}\nfunction getRootEventId(event, searchTag) {\n  searchTag ??= event.tagType();\n  const rootEventTag = getRootTag(event, searchTag);\n  if (rootEventTag) return rootEventTag[1];\n  const replyTag = getReplyTag(event, searchTag);\n  return replyTag?.[1];\n}\nfunction getRootTag(event, searchTag) {\n  searchTag ??= event.tagType();\n  const rootEventTag = event.tags.find(isTagRootTag);\n  if (!rootEventTag) {\n    if (eventHasETagMarkers(event)) return;\n    const matchingTags = event.getMatchingTags(searchTag);\n    if (matchingTags.length < 3) return matchingTags[0];\n  }\n  return rootEventTag;\n}\nvar nip22RootTags = /* @__PURE__ */ new Set([\"A\", \"E\", \"I\"]);\nvar nip22ReplyTags = /* @__PURE__ */ new Set([\"a\", \"e\", \"i\"]);\nfunction getReplyTag(event, searchTag) {\n  if (event.kind === 1111 /* GenericReply */) {\n    let replyTag2;\n    for (const tag of event.tags) {\n      if (nip22RootTags.has(tag[0])) replyTag2 = tag;\n      else if (nip22ReplyTags.has(tag[0])) {\n        replyTag2 = tag;\n        break;\n      }\n    }\n    return replyTag2;\n  }\n  searchTag ??= event.tagType();\n  let hasMarkers2 = false;\n  let replyTag;\n  for (const tag of event.tags) {\n    if (tag[0] !== searchTag) continue;\n    if ((tag[3] ?? \"\").length > 0) hasMarkers2 = true;\n    if (hasMarkers2 && tag[3] === \"reply\") return tag;\n    if (hasMarkers2 && tag[3] === \"root\") replyTag = tag;\n    if (!hasMarkers2) replyTag = tag;\n  }\n  return replyTag;\n}\nfunction isTagRootTag(tag) {\n  return tag[0] === \"E\" || tag[3] === \"root\";\n}\n\n// src/events/fetch-tagged-event.ts\nasync function fetchTaggedEvent(tag, marker) {\n  if (!this.ndk) throw new Error(\"NDK instance not found\");\n  const t = this.getMatchingTags(tag, marker);\n  if (t.length === 0) return void 0;\n  const [_, id, hint] = t[0];\n  let relay;\n  const event = await this.ndk.fetchEvent(id, {}, relay);\n  return event;\n}\nasync function fetchRootEvent(subOpts) {\n  if (!this.ndk) throw new Error(\"NDK instance not found\");\n  const rootTag = getRootTag(this);\n  if (!rootTag) return void 0;\n  return this.ndk.fetchEventFromTag(rootTag, this, subOpts);\n}\nasync function fetchReplyEvent(subOpts) {\n  if (!this.ndk) throw new Error(\"NDK instance not found\");\n  const replyTag = getReplyTag(this);\n  if (!replyTag) return void 0;\n  return this.ndk.fetchEventFromTag(replyTag, this, subOpts);\n}\n\n// src/events/serializer.ts\nfunction serialize(includeSig = false, includeId = false) {\n  const payload = [0, this.pubkey, this.created_at, this.kind, this.tags, this.content];\n  if (includeSig) payload.push(this.sig);\n  if (includeId) payload.push(this.id);\n  return JSON.stringify(payload);\n}\nfunction deserialize(serializedEvent) {\n  const eventArray = JSON.parse(serializedEvent);\n  const ret = {\n    pubkey: eventArray[1],\n    created_at: eventArray[2],\n    kind: eventArray[3],\n    tags: eventArray[4],\n    content: eventArray[5]\n  };\n  if (eventArray.length >= 7) ret.sig = eventArray[6];\n  if (eventArray.length >= 8) ret.id = eventArray[7];\n  return ret;\n}\n\n// src/events/validation.ts\n\n\n\n\n// src/events/signature.ts\nvar worker;\nvar processingQueue = {};\nfunction signatureVerificationInit(w) {\n  worker = w;\n  worker.onmessage = (msg) => {\n    const [eventId, result] = msg.data;\n    const record = processingQueue[eventId];\n    if (!record) {\n      console.error(\"No record found for event\", eventId);\n      return;\n    }\n    delete processingQueue[eventId];\n    for (const resolve of record.resolves) {\n      resolve(result);\n    }\n  };\n}\nasync function verifySignatureAsync(event, persist) {\n  const promise = new Promise((resolve) => {\n    const serialized = event.serialize();\n    let enqueue = false;\n    if (!processingQueue[event.id]) {\n      processingQueue[event.id] = { event, resolves: [] };\n      enqueue = true;\n    }\n    processingQueue[event.id].resolves.push(resolve);\n    if (!enqueue) return;\n    worker.postMessage({\n      serialized,\n      id: event.id,\n      sig: event.sig,\n      pubkey: event.pubkey\n    });\n  });\n  return promise;\n}\n\n// src/events/validation.ts\n\nvar PUBKEY_REGEX = /^[a-f0-9]{64}$/;\nfunction validate() {\n  if (typeof this.kind !== \"number\") return false;\n  if (typeof this.content !== \"string\") return false;\n  if (typeof this.created_at !== \"number\") return false;\n  if (typeof this.pubkey !== \"string\") return false;\n  if (!this.pubkey.match(PUBKEY_REGEX)) return false;\n  if (!Array.isArray(this.tags)) return false;\n  for (let i = 0; i < this.tags.length; i++) {\n    const tag = this.tags[i];\n    if (!Array.isArray(tag)) return false;\n    for (let j = 0; j < tag.length; j++) {\n      if (typeof tag[j] === \"object\") return false;\n    }\n  }\n  return true;\n}\nvar verifiedSignatures = new typescript_lru_cache__WEBPACK_IMPORTED_MODULE_3__.LRUCache({\n  maxSize: 1e3,\n  entryExpirationTimeInMS: 6e4\n});\nfunction verifySignature(persist) {\n  if (typeof this.signatureVerified === \"boolean\") return this.signatureVerified;\n  const prevVerification = verifiedSignatures.get(this.id);\n  if (prevVerification !== null) {\n    return this.signatureVerified = !!prevVerification;\n  }\n  try {\n    if (this.ndk?.asyncSigVerification) {\n      verifySignatureAsync(this, persist).then((result) => {\n        if (persist) {\n          this.signatureVerified = result;\n          if (result) verifiedSignatures.set(this.id, this.sig);\n        }\n        if (!result) {\n          this.ndk.emit(\"event:invalid-sig\", this);\n          verifiedSignatures.set(this.id, false);\n        }\n      });\n    } else {\n      const hash = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__.sha256)(new TextEncoder().encode(this.serialize()));\n      const res = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_5__.schnorr.verify(this.sig, hash, this.pubkey);\n      if (res) verifiedSignatures.set(this.id, this.sig);\n      else verifiedSignatures.set(this.id, false);\n      return this.signatureVerified = res;\n    }\n  } catch (err) {\n    return this.signatureVerified = false;\n  }\n}\nfunction getEventHash() {\n  return getEventHashFromSerializedEvent(this.serialize());\n}\nfunction getEventHashFromSerializedEvent(serializedEvent) {\n  const eventHash = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__.sha256)(new TextEncoder().encode(serializedEvent));\n  return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_6__.bytesToHex)(eventHash);\n}\n\n// src/events/index.ts\nvar skipClientTagOnKinds = /* @__PURE__ */ new Set([\n  0 /* Metadata */,\n  4 /* EncryptedDirectMessage */,\n  1059 /* GiftWrap */,\n  13 /* GiftWrapSeal */,\n  3 /* Contacts */,\n  9734 /* ZapRequest */,\n  5 /* EventDeletion */\n]);\nvar NDKEvent = class _NDKEvent extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  ndk;\n  created_at;\n  content = \"\";\n  tags = [];\n  kind;\n  id = \"\";\n  sig;\n  pubkey = \"\";\n  signatureVerified;\n  _author = void 0;\n  /**\n   * The relay that this event was first received from.\n   */\n  relay;\n  /**\n   * The relays that this event was received from and/or successfully published to.\n   */\n  get onRelays() {\n    let res = [];\n    if (!this.ndk) {\n      if (this.relay) res.push(this.relay);\n    } else {\n      res = this.ndk.subManager.seenEvents.get(this.id) || [];\n    }\n    return res;\n  }\n  /**\n   * The status of the publish operation.\n   */\n  publishStatus = \"success\";\n  publishError;\n  constructor(ndk, event) {\n    super();\n    this.ndk = ndk;\n    this.created_at = event?.created_at;\n    this.content = event?.content || \"\";\n    this.tags = event?.tags || [];\n    this.id = event?.id || \"\";\n    this.sig = event?.sig;\n    this.pubkey = event?.pubkey || \"\";\n    this.kind = event?.kind;\n    if (event instanceof _NDKEvent) {\n      if (this.relay) {\n        this.relay = event.relay;\n        this.ndk?.subManager.seenEvent(event.id, this.relay);\n      }\n      this.publishStatus = event.publishStatus;\n      this.publishError = event.publishError;\n    }\n  }\n  /**\n   * Deserialize an NDKEvent from a serialized payload.\n   * @param ndk\n   * @param event\n   * @returns\n   */\n  static deserialize(ndk, event) {\n    return new _NDKEvent(ndk, deserialize(event));\n  }\n  /**\n   * Returns the event as is.\n   */\n  rawEvent() {\n    return {\n      created_at: this.created_at,\n      content: this.content,\n      tags: this.tags,\n      kind: this.kind,\n      pubkey: this.pubkey,\n      id: this.id,\n      sig: this.sig\n    };\n  }\n  set author(user) {\n    this.pubkey = user.pubkey;\n    this._author = user;\n    this._author.ndk ??= this.ndk;\n  }\n  /**\n   * Returns an NDKUser for the author of the event.\n   */\n  get author() {\n    if (this._author) return this._author;\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    const user = this.ndk.getUser({ pubkey: this.pubkey });\n    this._author = user;\n    return user;\n  }\n  /**\n   * NIP-73 tagging of external entities\n   * @param entity to be tagged\n   * @param type of the entity\n   * @param markerUrl to be used as the marker URL\n   *\n   * @example\n   * ```typescript\n   * event.tagExternal(\"https://example.com/article/123#nostr\", \"url\");\n   * event.tags => [[\"i\", \"https://example.com/123\"], [\"k\", \"https://example.com\"]]\n   * ```\n   *\n   * @example tag a podcast:item:guid\n   * ```typescript\n   * event.tagExternal(\"e32b4890-b9ea-4aef-a0bf-54b787833dc5\", \"podcast:item:guid\");\n   * event.tags => [[\"i\", \"podcast:item:guid:e32b4890-b9ea-4aef-a0bf-54b787833dc5\"], [\"k\", \"podcast:item:guid\"]]\n   * ```\n   *\n   * @see https://github.com/nostr-protocol/nips/blob/master/73.md\n   */\n  tagExternal(entity, type, markerUrl) {\n    let iTag = [\"i\"];\n    let kTag = [\"k\"];\n    switch (type) {\n      case \"url\":\n        const url = new URL(entity);\n        url.hash = \"\";\n        iTag.push(url.toString());\n        kTag.push(`${url.protocol}//${url.host}`);\n        break;\n      case \"hashtag\":\n        iTag.push(`#${entity.toLowerCase()}`);\n        kTag.push(\"#\");\n        break;\n      case \"geohash\":\n        iTag.push(`geo:${entity.toLowerCase()}`);\n        kTag.push(\"geo\");\n        break;\n      case \"isbn\":\n        iTag.push(`isbn:${entity.replace(/-/g, \"\")}`);\n        kTag.push(\"isbn\");\n        break;\n      case \"podcast:guid\":\n        iTag.push(`podcast:guid:${entity}`);\n        kTag.push(\"podcast:guid\");\n        break;\n      case \"podcast:item:guid\":\n        iTag.push(`podcast:item:guid:${entity}`);\n        kTag.push(\"podcast:item:guid\");\n        break;\n      case \"podcast:publisher:guid\":\n        iTag.push(`podcast:publisher:guid:${entity}`);\n        kTag.push(\"podcast:publisher:guid\");\n        break;\n      case \"isan\":\n        iTag.push(`isan:${entity.split(\"-\").slice(0, 4).join(\"-\")}`);\n        kTag.push(\"isan\");\n        break;\n      case \"doi\":\n        iTag.push(`doi:${entity.toLowerCase()}`);\n        kTag.push(\"doi\");\n        break;\n      default:\n        throw new Error(`Unsupported NIP-73 entity type: ${type}`);\n    }\n    if (markerUrl) {\n      iTag.push(markerUrl);\n    }\n    this.tags.push(iTag);\n    this.tags.push(kTag);\n  }\n  /**\n   * Tag a user with an optional marker.\n   * @param target What is to be tagged. Can be an NDKUser, NDKEvent, or an NDKTag.\n   * @param marker The marker to use in the tag.\n   * @param skipAuthorTag Whether to explicitly skip adding the author tag of the event.\n   * @param forceTag Force a specific tag to be used instead of the default \"e\" or \"a\" tag.\n   * @example\n   * ```typescript\n   * reply.tag(opEvent, \"reply\");\n   * // reply.tags => [[\"e\", <id>, <relay>, \"reply\"]]\n   * ```\n   */\n  tag(target, marker, skipAuthorTag, forceTag) {\n    let tags = [];\n    const isNDKUser = target.fetchProfile !== void 0;\n    if (isNDKUser) {\n      forceTag ??= \"p\";\n      const tag = [forceTag, target.pubkey];\n      if (marker) tag.push(...[\"\", marker]);\n      tags.push(tag);\n    } else if (target instanceof _NDKEvent) {\n      const event = target;\n      skipAuthorTag ??= event?.pubkey === this.pubkey;\n      tags = event.referenceTags(marker, skipAuthorTag, forceTag);\n      for (const pTag of event.getMatchingTags(\"p\")) {\n        if (pTag[1] === this.pubkey) continue;\n        if (this.tags.find((t) => t[0] === \"p\" && t[1] === pTag[1])) continue;\n        this.tags.push([\"p\", pTag[1]]);\n      }\n    } else if (Array.isArray(target)) {\n      tags = [target];\n    } else {\n      throw new Error(\"Invalid argument\", target);\n    }\n    this.tags = mergeTags(this.tags, tags);\n  }\n  /**\n   * Return a NostrEvent object, trying to fill in missing fields\n   * when possible, adding tags when necessary.\n   * @param pubkey {string} The pubkey of the user who the event belongs to.\n   * @returns {Promise<NostrEvent>} A promise that resolves to a NostrEvent.\n   */\n  async toNostrEvent(pubkey) {\n    if (!pubkey && this.pubkey === \"\") {\n      const user = await this.ndk?.signer?.user();\n      this.pubkey = user?.pubkey || \"\";\n    }\n    if (!this.created_at) {\n      this.created_at = Math.floor(Date.now() / 1e3);\n    }\n    const { content, tags } = await this.generateTags();\n    this.content = content || \"\";\n    this.tags = tags;\n    try {\n      this.id = this.getEventHash();\n    } catch (e) {\n    }\n    return this.rawEvent();\n  }\n  serialize = serialize.bind(this);\n  getEventHash = getEventHash.bind(this);\n  validate = validate.bind(this);\n  verifySignature = verifySignature.bind(this);\n  /**\n   * Is this event replaceable (whether parameterized or not)?\n   *\n   * This will return true for kind 0, 3, 10k-20k and 30k-40k\n   */\n  isReplaceable = isReplaceable.bind(this);\n  isEphemeral = isEphemeral.bind(this);\n  isDvm = () => this.kind && this.kind >= 5e3 && this.kind <= 7e3;\n  /**\n   * Is this event parameterized replaceable?\n   *\n   * This will return true for kind 30k-40k\n   */\n  isParamReplaceable = isParamReplaceable.bind(this);\n  /**\n   * Encodes a bech32 id.\n   *\n   * @param relays {string[]} The relays to encode in the id\n   * @returns {string} - Encoded naddr, note or nevent.\n   */\n  encode = encode.bind(this);\n  encrypt = encrypt.bind(this);\n  decrypt = decrypt.bind(this);\n  /**\n   * Get all tags with the given name\n   * @param tagName {string} The name of the tag to search for\n   * @returns {NDKTag[]} An array of the matching tags\n   */\n  getMatchingTags(tagName, marker) {\n    const t = this.tags.filter((tag) => tag[0] === tagName);\n    if (marker === void 0) return t;\n    return t.filter((tag) => tag[3] === marker);\n  }\n  /**\n   * Check if the event has a tag with the given name\n   * @param tagName\n   * @param marker\n   * @returns\n   */\n  hasTag(tagName, marker) {\n    return this.tags.some((tag) => tag[0] === tagName && (!marker || tag[3] === marker));\n  }\n  /**\n   * Get the first tag with the given name\n   * @param tagName Tag name to search for\n   * @returns The value of the first tag with the given name, or undefined if no such tag exists\n   */\n  tagValue(tagName) {\n    const tags = this.getMatchingTags(tagName);\n    if (tags.length === 0) return void 0;\n    return tags[0][1];\n  }\n  /**\n   * Gets the NIP-31 \"alt\" tag of the event.\n   */\n  get alt() {\n    return this.tagValue(\"alt\");\n  }\n  /**\n   * Sets the NIP-31 \"alt\" tag of the event. Use this to set an alt tag so\n   * clients that don't handle a particular event kind can display something\n   * useful for users.\n   */\n  set alt(alt) {\n    this.removeTag(\"alt\");\n    if (alt) this.tags.push([\"alt\", alt]);\n  }\n  /**\n   * Gets the NIP-33 \"d\" tag of the event.\n   */\n  get dTag() {\n    return this.tagValue(\"d\");\n  }\n  /**\n   * Sets the NIP-33 \"d\" tag of the event.\n   */\n  set dTag(value) {\n    this.removeTag(\"d\");\n    if (value) this.tags.push([\"d\", value]);\n  }\n  /**\n   * Remove all tags with the given name (e.g. \"d\", \"a\", \"p\")\n   * @param tagName Tag name(s) to search for and remove\n   * @returns {void}\n   */\n  removeTag(tagName) {\n    const tagNames = Array.isArray(tagName) ? tagName : [tagName];\n    this.tags = this.tags.filter((tag) => !tagNames.includes(tag[0]));\n  }\n  /**\n   * Sign the event if a signer is present.\n   *\n   * It will generate tags.\n   * Repleacable events will have their created_at field set to the current time.\n   * @param signer {NDKSigner} The NDKSigner to use to sign the event\n   * @returns {Promise<string>} A Promise that resolves to the signature of the signed event.\n   */\n  async sign(signer) {\n    if (!signer) {\n      this.ndk?.assertSigner();\n      signer = this.ndk.signer;\n    } else {\n      this.author = await signer.user();\n    }\n    const nostrEvent = await this.toNostrEvent();\n    this.sig = await signer.sign(nostrEvent);\n    return this.sig;\n  }\n  /**\n   *\n   * @param relaySet\n   * @param timeoutMs\n   * @param requiredRelayCount\n   * @returns\n   */\n  async publishReplaceable(relaySet, timeoutMs, requiredRelayCount) {\n    this.id = \"\";\n    this.created_at = Math.floor(Date.now() / 1e3);\n    this.sig = \"\";\n    return this.publish(relaySet, timeoutMs, requiredRelayCount);\n  }\n  /**\n   * Attempt to sign and then publish an NDKEvent to a given relaySet.\n   * If no relaySet is provided, the relaySet will be calculated by NDK.\n   * @param relaySet {NDKRelaySet} The relaySet to publish the even to.\n   * @param timeoutM {number} The timeout for the publish operation in milliseconds.\n   * @param requiredRelayCount The number of relays that must receive the event for the publish to be considered successful.\n   * @returns A promise that resolves to the relays the event was published to.\n   */\n  async publish(relaySet, timeoutMs, requiredRelayCount) {\n    if (!this.sig) await this.sign();\n    if (!this.ndk)\n      throw new Error(\"NDKEvent must be associated with an NDK instance to publish\");\n    if (!relaySet) {\n      relaySet = this.ndk.devWriteRelaySet || await calculateRelaySetFromEvent(this.ndk, this);\n    }\n    if (this.kind === 5 /* EventDeletion */ && this.ndk.cacheAdapter?.deleteEventIds) {\n      const eTags = this.getMatchingTags(\"e\").map((tag) => tag[1]);\n      this.ndk.cacheAdapter.deleteEventIds(eTags);\n    }\n    const rawEvent = this.rawEvent();\n    if (this.ndk.cacheAdapter?.addUnpublishedEvent && shouldTrackUnpublishedEvent(this)) {\n      try {\n        this.ndk.cacheAdapter.addUnpublishedEvent(this, relaySet.relayUrls);\n      } catch (e) {\n        console.error(\"Error adding unpublished event to cache\", e);\n      }\n    }\n    if (this.kind === 5 /* EventDeletion */ && this.ndk.cacheAdapter?.deleteEventIds) {\n      this.ndk.cacheAdapter.deleteEventIds(this.getMatchingTags(\"e\").map((tag) => tag[1]));\n    }\n    this.ndk.subManager.dispatchEvent(rawEvent, void 0, true);\n    const relays = await relaySet.publish(this, timeoutMs, requiredRelayCount);\n    relays.forEach((relay) => this.ndk?.subManager.seenEvent(this.id, relay));\n    return relays;\n  }\n  /**\n   * Generates tags for users, notes, and other events tagged in content.\n   * Will also generate random \"d\" tag for parameterized replaceable events where needed.\n   * @returns {ContentTag} The tags and content of the event.\n   */\n  async generateTags() {\n    let tags = [];\n    const g = await generateContentTags(this.content, this.tags);\n    const content = g.content;\n    tags = g.tags;\n    if (this.kind && this.isParamReplaceable()) {\n      const dTag = this.getMatchingTags(\"d\")[0];\n      if (!dTag) {\n        const title = this.tagValue(\"title\");\n        const randLength = title ? 6 : 16;\n        let str = [...Array(randLength)].map(() => Math.random().toString(36)[2]).join(\"\");\n        if (title && title.length > 0) {\n          str = title.replace(/[^a-z0-9]+/gi, \"-\").replace(/^-|-$/g, \"\") + \"-\" + str;\n        }\n        tags.push([\"d\", str]);\n      }\n    }\n    if (this.shouldAddClientTag) {\n      const clientTag = [\"client\", this.ndk.clientName ?? \"\"];\n      if (this.ndk.clientNip89) clientTag.push(this.ndk.clientNip89);\n      tags.push(clientTag);\n    } else if (this.shouldStripClientTag) {\n      tags = tags.filter((tag) => tag[0] !== \"client\");\n    }\n    return { content: content || \"\", tags };\n  }\n  get shouldAddClientTag() {\n    if (!this.ndk?.clientName && !this.ndk?.clientNip89) return false;\n    if (skipClientTagOnKinds.has(this.kind)) return false;\n    if (this.isEphemeral() || this.isReplaceable()) return false;\n    if (this.isDvm()) return false;\n    if (this.hasTag(\"client\")) return false;\n    return true;\n  }\n  get shouldStripClientTag() {\n    return skipClientTagOnKinds.has(this.kind);\n  }\n  muted() {\n    const authorMutedEntry = this.ndk?.mutedIds.get(this.pubkey);\n    if (authorMutedEntry && authorMutedEntry === \"p\") return \"author\";\n    const eventTagReference = this.tagReference();\n    const eventMutedEntry = this.ndk?.mutedIds.get(eventTagReference[1]);\n    if (eventMutedEntry && eventMutedEntry === eventTagReference[0]) return \"event\";\n    return null;\n  }\n  /**\n   * Returns the \"d\" tag of a parameterized replaceable event or throws an error if the event isn't\n   * a parameterized replaceable event.\n   * @returns {string} the \"d\" tag of the event.\n   * \n   * @deprecated Use `dTag` instead.\n   */\n  replaceableDTag() {\n    if (this.kind && this.kind >= 3e4 && this.kind <= 4e4) {\n      const dTag = this.getMatchingTags(\"d\")[0];\n      const dTagId = dTag ? dTag[1] : \"\";\n      return dTagId;\n    }\n    throw new Error(\"Event is not a parameterized replaceable event\");\n  }\n  /**\n   * Provides a deduplication key for the event.\n   *\n   * For kinds 0, 3, 10k-20k this will be the event <kind>:<pubkey>\n   * For kinds 30k-40k this will be the event <kind>:<pubkey>:<d-tag>\n   * For all other kinds this will be the event id\n   */\n  deduplicationKey() {\n    if (this.kind === 0 || this.kind === 3 || this.kind && this.kind >= 1e4 && this.kind < 2e4) {\n      return `${this.kind}:${this.pubkey}`;\n    } else {\n      return this.tagId();\n    }\n  }\n  /**\n   * Returns the id of the event or, if it's a parameterized event, the generated id of the event using \"d\" tag, pubkey, and kind.\n   * @returns {string} The id\n   */\n  tagId() {\n    if (this.isParamReplaceable()) {\n      return this.tagAddress();\n    }\n    return this.id;\n  }\n  /**\n   * Returns a stable reference value for a replaceable event.\n   * \n   * Param replaceable events are returned in the expected format of `<kind>:<pubkey>:<d-tag>`.\n   * Kind-replaceable events are returned in the format of `<kind>:<pubkey>:`.\n   * \n   * @returns {string} A stable reference value for replaceable events\n   */\n  tagAddress() {\n    if (this.isParamReplaceable()) {\n      const dTagId = this.dTag ?? \"\";\n      return `${this.kind}:${this.pubkey}:${dTagId}`;\n    } else if (this.isReplaceable()) {\n      return `${this.kind}:${this.pubkey}:`;\n    }\n    throw new Error(\"Event is not a replaceable event\");\n  }\n  /**\n   * Determines the type of tag that can be used to reference this event from another event.\n   * @returns {string} The tag type\n   * @example\n   * event = new NDKEvent(ndk, { kind: 30000, pubkey: 'pubkey', tags: [ [\"d\", \"d-code\"] ] });\n   * event.tagType(); // \"a\"\n   */\n  tagType() {\n    return this.isParamReplaceable() ? \"a\" : \"e\";\n  }\n  /**\n   * Get the tag that can be used to reference this event from another event.\n   *\n   * Consider using referenceTags() instead (unless you have a good reason to use this)\n   *\n   * @example\n   *     event = new NDKEvent(ndk, { kind: 30000, pubkey: 'pubkey', tags: [ [\"d\", \"d-code\"] ] });\n   *     event.tagReference(); // [\"a\", \"30000:pubkey:d-code\"]\n   *\n   *     event = new NDKEvent(ndk, { kind: 1, pubkey: 'pubkey', id: \"eventid\" });\n   *     event.tagReference(); // [\"e\", \"eventid\"]\n   * @returns {NDKTag} The NDKTag object referencing this event\n   */\n  tagReference(marker) {\n    let tag;\n    if (this.isParamReplaceable()) {\n      tag = [\"a\", this.tagAddress()];\n    } else {\n      tag = [\"e\", this.tagId()];\n    }\n    if (this.relay) {\n      tag.push(this.relay.url);\n    } else {\n      tag.push(\"\");\n    }\n    tag.push(marker ?? \"\");\n    if (!this.isParamReplaceable()) {\n      tag.push(this.pubkey);\n    }\n    return tag;\n  }\n  /**\n   * Get the tags that can be used to reference this event from another event\n   * @param marker The marker to use in the tag\n   * @param skipAuthorTag Whether to explicitly skip adding the author tag of the event\n   * @param forceTag Force a specific tag to be used instead of the default \"e\" or \"a\" tag\n   * @example\n   *     event = new NDKEvent(ndk, { kind: 30000, pubkey: 'pubkey', tags: [ [\"d\", \"d-code\"] ] });\n   *     event.referenceTags(); // [[\"a\", \"30000:pubkey:d-code\"], [\"e\", \"parent-id\"]]\n   *\n   *     event = new NDKEvent(ndk, { kind: 1, pubkey: 'pubkey', id: \"eventid\" });\n   *     event.referenceTags(); // [[\"e\", \"parent-id\"]]\n   * @returns {NDKTag} The NDKTag object referencing this event\n   */\n  referenceTags(marker, skipAuthorTag, forceTag) {\n    let tags = [];\n    if (this.isParamReplaceable()) {\n      tags = [\n        [forceTag ?? \"a\", this.tagAddress()],\n        [forceTag ?? \"e\", this.id]\n      ];\n    } else {\n      tags = [[forceTag ?? \"e\", this.id]];\n    }\n    tags = tags.map((tag) => {\n      if (tag[0] === \"e\" || marker) {\n        tag.push(this.relay?.url ?? \"\");\n      } else if (this.relay?.url) {\n        tag.push(this.relay?.url);\n      }\n      return tag;\n    });\n    tags.forEach((tag) => {\n      if (tag[0] === \"e\") {\n        tag.push(marker ?? \"\");\n        tag.push(this.pubkey);\n      } else if (marker) {\n        tag.push(marker);\n      }\n    });\n    tags = [...tags, ...this.getMatchingTags(\"h\")];\n    if (!skipAuthorTag) tags.push(...this.author.referenceTags());\n    return tags;\n  }\n  /**\n   * Provides the filter that will return matching events for this event.\n   *\n   * @example\n   *    event = new NDKEvent(ndk, { kind: 30000, pubkey: 'pubkey', tags: [ [\"d\", \"d-code\"] ] });\n   *    event.filter(); // { \"#a\": [\"30000:pubkey:d-code\"] }\n   * @example\n   *    event = new NDKEvent(ndk, { kind: 1, pubkey: 'pubkey', id: \"eventid\" });\n   *    event.filter(); // { \"#e\": [\"eventid\"] }\n   *\n   * @returns The filter that will return matching events for this event\n   */\n  filter() {\n    if (this.isParamReplaceable()) {\n      return { \"#a\": [this.tagId()] };\n    } else {\n      return { \"#e\": [this.tagId()] };\n    }\n  }\n  nip22Filter() {\n    if (this.isParamReplaceable()) {\n      return { \"#A\": [this.tagId()] };\n    } else {\n      return { \"#E\": [this.tagId()] };\n    }\n  }\n  /**\n   * Generates a deletion event of the current event\n   *\n   * @param reason The reason for the deletion\n   * @param publish Whether to publish the deletion event automatically\n   * @returns The deletion event\n   */\n  async delete(reason, publish = true) {\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    this.ndk.assertSigner();\n    const e = new _NDKEvent(this.ndk, {\n      kind: 5 /* EventDeletion */,\n      content: reason || \"\"\n    });\n    e.tag(this, void 0, true);\n    e.tags.push([\"k\", this.kind.toString()]);\n    if (publish) {\n      this.emit(\"deleted\");\n      await e.publish();\n    }\n    return e;\n  }\n  /**\n   * Establishes whether this is a NIP-70-protectede event.\n   * @@satisfies NIP-70\n   */\n  set isProtected(val) {\n    this.removeTag(\"-\");\n    if (val) this.tags.push([\"-\"]);\n  }\n  /**\n   * Whether this is a NIP-70-protectede event.\n   * @@satisfies NIP-70\n   */\n  get isProtected() {\n    return this.hasTag(\"-\");\n  }\n  /**\n   * Fetch an event tagged with the given tag following relay hints if provided.\n   * @param tag The tag to search for\n   * @param marker The marker to use in the tag (e.g. \"root\")\n   * @returns The fetched event or null if no event was found, undefined if no matching tag was found in the event\n   * * @example\n   * const replyEvent = await ndk.fetchEvent(\"nevent1qqs8x8vnycyha73grv380gmvlury4wtmx0nr9a5ds2dngqwgu87wn6gpzemhxue69uhhyetvv9ujuurjd9kkzmpwdejhgq3ql2vyh47mk2p0qlsku7hg0vn29faehy9hy34ygaclpn66ukqp3afqz4cwjd\")\n   * const originalEvent = await replyEvent.fetchTaggedEvent(\"e\", \"reply\");\n   * console.log(replyEvent.encode() + \" is a reply to event \" + originalEvent?.encode());\n   */\n  fetchTaggedEvent = fetchTaggedEvent.bind(this);\n  /**\n   * Fetch the root event of the current event.\n   * @returns The fetched root event or null if no event was found\n   * @example\n   * const replyEvent = await ndk.fetchEvent(\"nevent1qqs8x8vnycyha73grv380gmvlury4wtmx0nr9a5ds2dngqwgu87wn6gpzemhxue69uhhyetvv9ujuurjd9kkzmpwdejhgq3ql2vyh47mk2p0qlsku7hg0vn29faehy9hy34ygaclpn66ukqp3afqz4cwjd\")\n   * const rootEvent = await replyEvent.fetchRootEvent();\n   * console.log(replyEvent.encode() + \" is a reply in the thread \" + rootEvent?.encode());\n   */\n  fetchRootEvent = fetchRootEvent.bind(this);\n  /**\n   * Fetch the event the current event is replying to.\n   * @returns The fetched reply event or null if no event was found\n   */\n  fetchReplyEvent = fetchReplyEvent.bind(this);\n  /**\n   * NIP-18 reposting event.\n   *\n   * @param publish Whether to publish the reposted event automatically @default true\n   * @param signer The signer to use for signing the reposted event\n   * @returns The reposted event\n   *\n   * @function\n   */\n  repost = repost.bind(this);\n  /**\n   * React to an existing event\n   *\n   * @param content The content of the reaction\n   */\n  async react(content, publish = true) {\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    this.ndk.assertSigner();\n    const e = new _NDKEvent(this.ndk, {\n      kind: 7 /* Reaction */,\n      content\n    });\n    e.tag(this);\n    if (publish) await e.publish();\n    return e;\n  }\n  /**\n   * Checks whether the event is valid per underlying NIPs.\n   *\n   * This method is meant to be overridden by subclasses that implement specific NIPs\n   * to allow the enforcement of NIP-specific validation rules.\n   *\n   * Otherwise, it will only check for basic event properties.\n   *\n   */\n  get isValid() {\n    return this.validate();\n  }\n  /**\n   * Creates a reply event for the current event.\n   * \n   * This function will use NIP-22 when appropriate (i.e. replies to non-kind:1 events).\n   * This function does not have side-effects; it will just return an event with the appropriate tags\n   * to generate the reply event; the caller is responsible for publishing the event.\n   */\n  reply() {\n    const reply = new _NDKEvent(this.ndk);\n    if (this.kind === 1) {\n      reply.kind = 1;\n      const opHasETag = this.hasTag(\"e\");\n      if (opHasETag) {\n        reply.tags = [\n          ...reply.tags,\n          ...this.getMatchingTags(\"e\"),\n          ...this.getMatchingTags(\"p\"),\n          ...this.getMatchingTags(\"a\"),\n          ...this.referenceTags(\"reply\")\n        ];\n      } else {\n        reply.tag(this, \"root\");\n      }\n    } else {\n      reply.kind = 1111 /* GenericReply */;\n      const carryOverTags = [\"A\", \"E\", \"I\", \"P\"];\n      const rootTags = this.tags.filter((tag) => carryOverTags.includes(tag[0]));\n      if (rootTags.length > 0) {\n        const rootKind = this.tagValue(\"K\");\n        reply.tags.push(...rootTags);\n        if (rootKind) reply.tags.push([\"K\", rootKind]);\n        const [type, id, _, ...extra] = this.tagReference();\n        const tag = [type, id, ...extra];\n        reply.tags.push(tag);\n      } else {\n        const [type, id, _, relayHint] = this.tagReference();\n        const tag = [type, id, relayHint ?? \"\"];\n        if (type === \"e\") tag.push(this.pubkey);\n        reply.tags.push(tag);\n        const uppercaseTag = [...tag];\n        uppercaseTag[0] = uppercaseTag[0].toUpperCase();\n        reply.tags.push(uppercaseTag);\n        reply.tags.push([\"K\", this.kind.toString()]);\n        reply.tags.push([\"P\", this.pubkey]);\n      }\n      reply.tags.push([\"k\", this.kind.toString()]);\n      reply.tags.push(...this.getMatchingTags(\"p\"));\n      reply.tags.push([\"p\", this.pubkey]);\n    }\n    return reply;\n  }\n};\nvar untrackedUnpublishedEvents = /* @__PURE__ */ new Set([\n  24133 /* NostrConnect */,\n  13194 /* NostrWaletConnectInfo */,\n  23194 /* NostrWalletConnectReq */,\n  23195 /* NostrWalletConnectRes */\n]);\nfunction shouldTrackUnpublishedEvent(event) {\n  return !untrackedUnpublishedEvents.has(event.kind);\n}\n\n// src/relay/pool/index.ts\n\nvar NDKPool = class extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  // TODO: This should probably be an LRU cache\n  _relays = /* @__PURE__ */ new Map();\n  status = \"idle\";\n  autoConnectRelays = /* @__PURE__ */ new Set();\n  poolBlacklistRelayUrls = /* @__PURE__ */ new Set();\n  debug;\n  temporaryRelayTimers = /* @__PURE__ */ new Map();\n  flappingRelays = /* @__PURE__ */ new Set();\n  // A map to store timeouts for each flapping relay.\n  backoffTimes = /* @__PURE__ */ new Map();\n  ndk;\n  get blacklistRelayUrls() {\n    const val = new Set(this.ndk.blacklistRelayUrls);\n    this.poolBlacklistRelayUrls.forEach((url) => val.add(url));\n    return val;\n  }\n  /**\n   * @param relayUrls - The URLs of the relays to connect to.\n   * @param blacklistedRelayUrls - URLs to blacklist for this pool IN ADDITION to those blacklisted at the ndk-level\n   * @param ndk - The NDK instance.\n   * @param opts - Options for the pool.\n   */\n  constructor(relayUrls = [], blacklistedRelayUrls = [], ndk, { debug: debug8, name } = {}) {\n    super();\n    this.debug = debug8 ?? ndk.debug.extend(\"pool\");\n    if (name) this._name = name;\n    this.ndk = ndk;\n    this.relayUrls = relayUrls;\n    this.poolBlacklistRelayUrls = new Set(blacklistedRelayUrls);\n    this.ndk.pools.push(this);\n  }\n  get relays() {\n    return this._relays;\n  }\n  set relayUrls(urls) {\n    this._relays.clear();\n    for (const relayUrl of urls) {\n      const relay = new NDKRelay(relayUrl, void 0, this.ndk);\n      relay.connectivity.netDebug = this.ndk.netDebug;\n      this.addRelay(relay);\n    }\n  }\n  _name = \"unnamed\";\n  get name() {\n    return this._name;\n  }\n  set name(name) {\n    this._name = name;\n    this.debug = this.debug.extend(name);\n  }\n  /**\n   * Adds a relay to the pool, and sets a timer to remove it if it is not used within the specified time.\n   * @param relay - The relay to add to the pool.\n   * @param removeIfUnusedAfter - The time in milliseconds to wait before removing the relay from the pool after it is no longer used.\n   */\n  useTemporaryRelay(relay, removeIfUnusedAfter = 3e4, filters) {\n    const relayAlreadyInPool = this.relays.has(relay.url);\n    if (!relayAlreadyInPool) {\n      this.addRelay(relay);\n      this.debug(\"Adding temporary relay %s for filters %o\", relay.url, filters);\n    }\n    const existingTimer = this.temporaryRelayTimers.get(relay.url);\n    if (existingTimer) {\n      clearTimeout(existingTimer);\n    }\n    if (!relayAlreadyInPool || existingTimer) {\n      const timer = setTimeout(() => {\n        if (this.ndk.explicitRelayUrls?.includes(relay.url)) return;\n        this.removeRelay(relay.url);\n      }, removeIfUnusedAfter);\n      this.temporaryRelayTimers.set(relay.url, timer);\n    }\n  }\n  /**\n   * Adds a relay to the pool.\n   *\n   * @param relay - The relay to add to the pool.\n   * @param connect - Whether or not to connect to the relay.\n   */\n  addRelay(relay, connect = true) {\n    const isAlreadyInPool = this.relays.has(relay.url);\n    const isBlacklisted = this.blacklistRelayUrls?.has(relay.url);\n    const isCustomRelayUrl = relay.url.includes(\"/npub1\");\n    let reconnect = true;\n    const relayUrl = relay.url;\n    if (isAlreadyInPool) return;\n    if (isBlacklisted) {\n      this.debug(`Refusing to add relay ${relayUrl}: blacklisted`);\n      return;\n    }\n    if (isCustomRelayUrl) {\n      this.debug(`Refusing to add relay ${relayUrl}: is a filter relay`);\n      return;\n    }\n    if (this.ndk.cacheAdapter?.getRelayStatus) {\n      const info = this.ndk.cacheAdapter.getRelayStatus(relayUrl);\n      if (info && info.dontConnectBefore) {\n        if (info.dontConnectBefore > Date.now()) {\n          const delay = info.dontConnectBefore - Date.now();\n          this.debug(`Refusing to add relay ${relayUrl}: delayed connect for ${delay}ms`);\n          setTimeout(() => {\n            this.addRelay(relay, connect);\n          }, delay);\n          return;\n        } else {\n          reconnect = false;\n        }\n      }\n    }\n    const noticeHandler = (notice) => this.emit(\"notice\", relay, notice);\n    const connectHandler = () => this.handleRelayConnect(relayUrl);\n    const readyHandler = () => this.handleRelayReady(relay);\n    const disconnectHandler = () => this.emit(\"relay:disconnect\", relay);\n    const flappingHandler = () => this.handleFlapping(relay);\n    const authHandler = (challenge) => this.emit(\"relay:auth\", relay, challenge);\n    const authedHandler = () => this.emit(\"relay:authed\", relay);\n    relay.off(\"notice\", noticeHandler);\n    relay.off(\"connect\", connectHandler);\n    relay.off(\"ready\", readyHandler);\n    relay.off(\"disconnect\", disconnectHandler);\n    relay.off(\"flapping\", flappingHandler);\n    relay.off(\"auth\", authHandler);\n    relay.off(\"authed\", authedHandler);\n    relay.on(\"notice\", noticeHandler);\n    relay.on(\"connect\", connectHandler);\n    relay.on(\"ready\", readyHandler);\n    relay.on(\"disconnect\", disconnectHandler);\n    relay.on(\"flapping\", flappingHandler);\n    relay.on(\"auth\", authHandler);\n    relay.on(\"authed\", authedHandler);\n    relay.on(\"delayed-connect\", (delay) => {\n      if (this.ndk.cacheAdapter?.updateRelayStatus) {\n        this.ndk.cacheAdapter.updateRelayStatus(relay.url, {\n          dontConnectBefore: Date.now() + delay\n        });\n      }\n    });\n    this._relays.set(relayUrl, relay);\n    if (connect) this.autoConnectRelays.add(relayUrl);\n    if (connect && this.status === \"active\") {\n      this.emit(\"relay:connecting\", relay);\n      relay.connect(void 0, reconnect).catch((e) => {\n        this.debug(`Failed to connect to relay ${relayUrl}`, e);\n      });\n    }\n  }\n  /**\n   * Removes a relay from the pool.\n   * @param relayUrl - The URL of the relay to remove.\n   * @returns {boolean} True if the relay was removed, false if it was not found.\n   */\n  removeRelay(relayUrl) {\n    const relay = this.relays.get(relayUrl);\n    if (relay) {\n      relay.disconnect();\n      this.relays.delete(relayUrl);\n      this.autoConnectRelays.delete(relayUrl);\n      this.emit(\"relay:disconnect\", relay);\n      return true;\n    }\n    const existingTimer = this.temporaryRelayTimers.get(relayUrl);\n    if (existingTimer) {\n      clearTimeout(existingTimer);\n      this.temporaryRelayTimers.delete(relayUrl);\n    }\n    return false;\n  }\n  /**\n   * Checks whether a relay is already connected in the pool.\n   */\n  isRelayConnected(url) {\n    const normalizedUrl = normalizeRelayUrl(url);\n    const relay = this.relays.get(normalizedUrl);\n    if (!relay) return false;\n    return relay.status === 5 /* CONNECTED */;\n  }\n  /**\n   * Fetches a relay from the pool, or creates a new one if it does not exist.\n   *\n   * New relays will be attempted to be connected.\n   */\n  getRelay(url, connect = true, temporary = false, filters) {\n    let relay = this.relays.get(normalizeRelayUrl(url));\n    if (!relay) {\n      relay = new NDKRelay(url, void 0, this.ndk);\n      relay.connectivity.netDebug = this.ndk.netDebug;\n      if (temporary) {\n        this.useTemporaryRelay(relay, 3e4, filters);\n      } else {\n        this.addRelay(relay, connect);\n      }\n    }\n    return relay;\n  }\n  handleRelayConnect(relayUrl) {\n    const relay = this.relays.get(relayUrl);\n    if (!relay) {\n      console.error(\"NDK BUG: relay not found in pool\", { relayUrl });\n      return;\n    }\n    this.emit(\"relay:connect\", relay);\n    if (this.stats().connected === this.relays.size) {\n      this.emit(\"connect\");\n    }\n  }\n  handleRelayReady(relay) {\n    this.emit(\"relay:ready\", relay);\n  }\n  /**\n   * Attempts to establish a connection to each relay in the pool.\n   *\n   * @async\n   * @param {number} [timeoutMs] - Optional timeout in milliseconds for each connection attempt.\n   * @returns {Promise<void>} A promise that resolves when all connection attempts have completed.\n   * @throws {Error} If any of the connection attempts result in an error or timeout.\n   */\n  async connect(timeoutMs) {\n    const promises = [];\n    this.status = \"active\";\n    this.debug(\n      `Connecting to ${this.relays.size} relays${timeoutMs ? `, timeout ${timeoutMs}...` : \"\"}`\n    );\n    const relaysToConnect = new Set(this.autoConnectRelays.keys());\n    for (const relayUrl of relaysToConnect) {\n      const relay = this.relays.get(relayUrl);\n      if (!relay) {\n        console.log(`Relay ${relayUrl} not found in pool ${this.name}`);\n        continue;\n      }\n      const connectPromise = new Promise((resolve, reject) => {\n        this.emit(\"relay:connecting\", relay);\n        return relay.connect(timeoutMs).then(resolve).catch(reject);\n      });\n      if (timeoutMs) {\n        const timeoutPromise = new Promise((_, reject) => {\n          setTimeout(() => reject(`Timed out after ${timeoutMs}ms`), timeoutMs);\n        });\n        promises.push(\n          Promise.race([connectPromise, timeoutPromise]).catch((e) => {\n            this.debug(\n              `Failed to connect to relay ${relay.url}: ${e ?? \"No reason specified\"}`\n            );\n          })\n        );\n      } else {\n        promises.push(connectPromise);\n      }\n    }\n    const maybeEmitConnect = () => {\n      const allConnected = this.stats().connected === this.relays.size;\n      const someConnected = this.stats().connected > 0;\n      if (!allConnected && someConnected) {\n        this.emit(\"connect\");\n      }\n    };\n    if (timeoutMs)\n      setTimeout(maybeEmitConnect, timeoutMs);\n    await Promise.all(promises);\n    maybeEmitConnect();\n  }\n  checkOnFlappingRelays() {\n    const flappingRelaysCount = this.flappingRelays.size;\n    const totalRelays = this.relays.size;\n    if (flappingRelaysCount / totalRelays >= 0.8) {\n      for (const relayUrl of this.flappingRelays) {\n        this.backoffTimes.set(relayUrl, 0);\n      }\n    }\n  }\n  handleFlapping(relay) {\n    this.debug(`Relay ${relay.url} is flapping`);\n    let currentBackoff = this.backoffTimes.get(relay.url) || 5e3;\n    currentBackoff = currentBackoff * 2;\n    this.backoffTimes.set(relay.url, currentBackoff);\n    this.debug(`Backoff time for ${relay.url} is ${currentBackoff}ms`);\n    setTimeout(() => {\n      this.debug(`Attempting to reconnect to ${relay.url}`);\n      this.emit(\"relay:connecting\", relay);\n      relay.connect();\n      this.checkOnFlappingRelays();\n    }, currentBackoff);\n    relay.disconnect();\n    this.emit(\"flapping\", relay);\n  }\n  size() {\n    return this.relays.size;\n  }\n  /**\n   * Returns the status of each relay in the pool.\n   * @returns {NDKPoolStats} An object containing the number of relays in each status.\n   */\n  stats() {\n    const stats = {\n      total: 0,\n      connected: 0,\n      disconnected: 0,\n      connecting: 0\n    };\n    for (const relay of this.relays.values()) {\n      stats.total++;\n      if (relay.status === 5 /* CONNECTED */) {\n        stats.connected++;\n      } else if (relay.status === 1 /* DISCONNECTED */) {\n        stats.disconnected++;\n      } else if (relay.status === 4 /* CONNECTING */) {\n        stats.connecting++;\n      }\n    }\n    return stats;\n  }\n  connectedRelays() {\n    return Array.from(this.relays.values()).filter(\n      (relay) => relay.status >= 5 /* CONNECTED */\n    );\n  }\n  permanentAndConnectedRelays() {\n    return Array.from(this.relays.values()).filter(\n      (relay) => relay.status >= 5 /* CONNECTED */ && !this.temporaryRelayTimers.has(relay.url)\n    );\n  }\n  /**\n   * Get a list of all relay urls in the pool.\n   */\n  urls() {\n    return Array.from(this.relays.keys());\n  }\n};\n\n// src/user/index.ts\n\n\n// src/subscription/index.ts\n\n\n// src/subscription/utils.ts\n\nvar MAX_SUBID_LENGTH = 20;\nfunction queryFullyFilled(subscription) {\n  if (filterIncludesIds(subscription.filter)) {\n    if (resultHasAllRequestedIds(subscription)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction compareFilter(filter1, filter2) {\n  if (Object.keys(filter1).length !== Object.keys(filter2).length) return false;\n  for (const [key, value] of Object.entries(filter1)) {\n    const valuesInFilter2 = filter2[key];\n    if (!valuesInFilter2) return false;\n    if (Array.isArray(value) && Array.isArray(valuesInFilter2)) {\n      const v = value;\n      for (const valueInFilter2 of valuesInFilter2) {\n        const val = valueInFilter2;\n        if (!v.includes(val)) {\n          return false;\n        }\n      }\n    } else {\n      if (valuesInFilter2 !== value) return false;\n    }\n  }\n  return true;\n}\nfunction filterIncludesIds(filter) {\n  return !!filter[\"ids\"];\n}\nfunction resultHasAllRequestedIds(subscription) {\n  const ids = subscription.filter[\"ids\"];\n  return !!ids && ids.length === subscription.eventFirstSeen.size;\n}\nfunction generateSubId(subscriptions, filters) {\n  const subIds = subscriptions.map((sub) => sub.subId).filter(Boolean);\n  const subIdParts = [];\n  const filterNonKindKeys = /* @__PURE__ */ new Set();\n  const filterKinds = /* @__PURE__ */ new Set();\n  if (subIds.length > 0) {\n    subIdParts.push(Array.from(new Set(subIds)).join(\",\"));\n  } else {\n    for (const filter of filters) {\n      for (const key of Object.keys(filter)) {\n        if (key === \"kinds\") {\n          filter.kinds?.forEach((k) => filterKinds.add(k));\n        } else {\n          filterNonKindKeys.add(key);\n        }\n      }\n    }\n    if (filterKinds.size > 0) {\n      subIdParts.push(\"kinds:\" + Array.from(filterKinds).join(\",\"));\n    }\n    if (filterNonKindKeys.size > 0) {\n      subIdParts.push(Array.from(filterNonKindKeys).join(\",\"));\n    }\n  }\n  let subId = subIdParts.join(\"-\");\n  if (subId.length > MAX_SUBID_LENGTH) subId = subId.substring(0, MAX_SUBID_LENGTH);\n  subId += \"-\" + Math.floor(Math.random() * 999).toString();\n  return subId;\n}\nfunction filterForEventsTaggingId(id) {\n  try {\n    const decoded = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.decode(id);\n    switch (decoded.type) {\n      case \"naddr\":\n        return {\n          \"#a\": [\n            `${decoded.data.kind}:${decoded.data.pubkey}:${decoded.data.identifier}`\n          ]\n        };\n      case \"nevent\":\n        return { \"#e\": [decoded.data.id] };\n      case \"note\":\n        return { \"#e\": [decoded.data] };\n      case \"nprofile\":\n        return { \"#p\": [decoded.data.pubkey] };\n      case \"npub\":\n        return { \"#p\": [decoded.data] };\n    }\n  } catch {\n  }\n}\nfunction filterAndRelaySetFromBech32(beche2, ndk) {\n  const filter = filterFromId(beche2);\n  const relays = relaysFromBech32(beche2, ndk);\n  if (relays.length === 0) return { filter };\n  return {\n    filter,\n    relaySet: new NDKRelaySet(new Set(relays), ndk)\n  };\n}\nfunction filterFromId(id) {\n  let decoded;\n  if (id.match(NIP33_A_REGEX)) {\n    const [kind, pubkey, identifier] = id.split(\":\");\n    const filter = {\n      authors: [pubkey],\n      kinds: [parseInt(kind)]\n    };\n    if (identifier) {\n      filter[\"#d\"] = [identifier];\n    }\n    return filter;\n  }\n  if (id.match(BECH32_REGEX)) {\n    try {\n      decoded = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.decode(id);\n      switch (decoded.type) {\n        case \"nevent\": {\n          const filter2 = { ids: [decoded.data.id] };\n          if (decoded.data.author) filter2.authors = [decoded.data.author];\n          if (decoded.data.kind) filter2.kinds = [decoded.data.kind];\n          return filter2;\n        }\n        case \"note\":\n          return { ids: [decoded.data] };\n        case \"naddr\":\n          const filter = {\n            authors: [decoded.data.pubkey],\n            kinds: [decoded.data.kind]\n          };\n          if (decoded.data.identifier) filter[\"#d\"] = [decoded.data.identifier];\n          return filter;\n      }\n    } catch (e) {\n      console.error(\"Error decoding\", id, e);\n    }\n  }\n  return { ids: [id] };\n}\nfunction isNip33AValue(value) {\n  return value.match(NIP33_A_REGEX) !== null;\n}\nvar NIP33_A_REGEX = /^(\\d+):([0-9A-Fa-f]+)(?::(.*))?$/;\nvar BECH32_REGEX = /^n(event|ote|profile|pub|addr)1[\\d\\w]+$/;\nfunction relaysFromBech32(bech322, ndk) {\n  try {\n    const decoded = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.decode(bech322);\n    if ([\"naddr\", \"nevent\"].includes(decoded?.type)) {\n      const data = decoded.data;\n      if (data?.relays) {\n        return data.relays.map(\n          (r) => new NDKRelay(r, ndk.relayAuthDefaultPolicy, ndk)\n        );\n      }\n    }\n  } catch (e) {\n  }\n  return [];\n}\n\n// src/events/kinds/article.ts\nvar NDKArticle = class _NDKArticle extends NDKEvent {\n  static kind = 30023 /* Article */;\n  static kinds = [30023 /* Article */];\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 30023 /* Article */;\n  }\n  /**\n   * Creates a NDKArticle from an existing NDKEvent.\n   *\n   * @param event NDKEvent to create the NDKArticle from.\n   * @returns NDKArticle\n   */\n  static from(event) {\n    return new _NDKArticle(event.ndk, event);\n  }\n  /**\n   * Getter for the article title.\n   *\n   * @returns {string | undefined} - The article title if available, otherwise undefined.\n   */\n  get title() {\n    return this.tagValue(\"title\");\n  }\n  /**\n   * Setter for the article title.\n   *\n   * @param {string | undefined} title - The title to set for the article.\n   */\n  set title(title) {\n    this.removeTag(\"title\");\n    if (title) this.tags.push([\"title\", title]);\n  }\n  /**\n   * Getter for the article image.\n   *\n   * @returns {string | undefined} - The article image if available, otherwise undefined.\n   */\n  get image() {\n    return this.tagValue(\"image\");\n  }\n  /**\n   * Setter for the article image.\n   *\n   * @param {string | undefined} image - The image to set for the article.\n   */\n  set image(image) {\n    this.removeTag(\"image\");\n    if (image) this.tags.push([\"image\", image]);\n  }\n  get summary() {\n    return this.tagValue(\"summary\");\n  }\n  set summary(summary) {\n    this.removeTag(\"summary\");\n    if (summary) this.tags.push([\"summary\", summary]);\n  }\n  /**\n   * Getter for the article's publication timestamp.\n   *\n   * @returns {number | undefined} - The Unix timestamp of when the article was published or undefined.\n   */\n  get published_at() {\n    const tag = this.tagValue(\"published_at\");\n    if (tag) {\n      let val = parseInt(tag);\n      if (val > 1e12) {\n        val = Math.floor(val / 1e3);\n      }\n      return val;\n    }\n    return void 0;\n  }\n  /**\n   * Setter for the article's publication timestamp.\n   *\n   * @param {number | undefined} timestamp - The Unix timestamp to set for the article's publication date.\n   */\n  set published_at(timestamp) {\n    this.removeTag(\"published_at\");\n    if (timestamp !== void 0) {\n      this.tags.push([\"published_at\", timestamp.toString()]);\n    }\n  }\n  /**\n   * Generates content tags for the article.\n   *\n   * This method first checks and sets the publication date if not available,\n   * and then generates content tags based on the base NDKEvent class.\n   *\n   * @returns {ContentTag} - The generated content tags.\n   */\n  async generateTags() {\n    super.generateTags();\n    if (!this.published_at) {\n      this.published_at = this.created_at;\n    }\n    return super.generateTags();\n  }\n  /**\n   * Getter for the article's URL.\n   *\n   * @returns {string | undefined} - The article's URL if available, otherwise undefined.\n   */\n  get url() {\n    return this.tagValue(\"url\");\n  }\n  /**\n   * Setter for the article's URL.\n   *\n   * @param {string | undefined} url - The URL to set for the article.\n   */\n  set url(url) {\n    if (url) {\n      this.tags.push([\"url\", url]);\n    } else {\n      this.removeTag(\"url\");\n    }\n  }\n};\n\n// src/events/kinds/cashu/token.ts\nfunction proofsTotalBalance(proofs) {\n  return proofs.reduce((acc, proof) => {\n    if (proof.amount < 0) {\n      throw new Error(\"proof amount is negative\");\n    }\n    return acc + proof.amount;\n  }, 0);\n}\nvar NDKCashuToken = class _NDKCashuToken extends NDKEvent {\n  _proofs = [];\n  _mint;\n  static kind = 7375 /* CashuToken */;\n  static kinds = [7375 /* CashuToken */];\n  /**\n   * Tokens that this token superseeds\n   */\n  _deletes = [];\n  original;\n  constructor(ndk, event) {\n    super(ndk, event);\n    this.kind ??= 7375 /* CashuToken */;\n  }\n  static async from(event) {\n    const token = new _NDKCashuToken(event.ndk, event);\n    token.original = event;\n    try {\n      await token.decrypt();\n    } catch {\n      token.content = token.original.content;\n    }\n    try {\n      const content = JSON.parse(token.content);\n      token.proofs = content.proofs;\n      token.mint = content.mint ?? token.tagValue(\"mint\");\n      token.deletedTokens = content.del ?? [];\n      if (!Array.isArray(token.proofs)) return;\n    } catch (e) {\n      return;\n    }\n    return token;\n  }\n  get proofs() {\n    return this._proofs;\n  }\n  set proofs(proofs) {\n    const cs = /* @__PURE__ */ new Set();\n    this._proofs = proofs.filter((proof) => {\n      if (cs.has(proof.C)) {\n        console.warn(\"Passed in proofs had duplicates, ignoring\", proof.C);\n        return false;\n      }\n      if (proof.amount < 0) {\n        console.warn(\"Invalid proof with negative amount\", proof);\n        return false;\n      }\n      cs.add(proof.C);\n      return true;\n    }).map(this.cleanProof);\n  }\n  /**\n   * Returns a minimal proof object with only essential properties\n   */\n  cleanProof(proof) {\n    return {\n      id: proof.id,\n      amount: proof.amount,\n      C: proof.C,\n      secret: proof.secret\n    };\n  }\n  async toNostrEvent(pubkey) {\n    const payload = {\n      proofs: this.proofs.map(this.cleanProof),\n      mint: this.mint,\n      del: this.deletedTokens ?? []\n    };\n    this.content = JSON.stringify(payload);\n    const user = await this.ndk.signer.user();\n    await this.encrypt(user, void 0, \"nip44\");\n    return super.toNostrEvent(pubkey);\n  }\n  set mint(mint) {\n    this._mint = mint;\n  }\n  get mint() {\n    return this._mint;\n  }\n  /**\n   * Tokens that were deleted by the creation of this token.\n   */\n  get deletedTokens() {\n    return this._deletes;\n  }\n  /**\n   * Marks tokens that were deleted by the creation of this token.\n   */\n  set deletedTokens(tokenIds) {\n    this._deletes = tokenIds;\n  }\n  get amount() {\n    return proofsTotalBalance(this.proofs);\n  }\n  async publish(relaySet, timeoutMs, requiredRelayCount) {\n    if (this.original) {\n      return this.original.publish(relaySet, timeoutMs, requiredRelayCount);\n    } else {\n      return super.publish(relaySet, timeoutMs, requiredRelayCount);\n    }\n  }\n};\n\n// src/events/kinds/highlight.ts\n\nvar NDKHighlight = class _NDKHighlight extends NDKEvent {\n  _article;\n  static kind = 9802 /* Highlight */;\n  static kinds = [9802 /* Highlight */];\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 9802 /* Highlight */;\n  }\n  static from(event) {\n    return new _NDKHighlight(event.ndk, event);\n  }\n  get url() {\n    return this.tagValue(\"r\");\n  }\n  /**\n   * Context tag.\n   */\n  set context(context) {\n    if (context === void 0) {\n      this.tags = this.tags.filter(([tag, value]) => tag !== \"context\");\n    } else {\n      this.tags = this.tags.filter(([tag, value]) => tag !== \"context\");\n      this.tags.push([\"context\", context]);\n    }\n  }\n  get context() {\n    return this.tags.find(([tag, value]) => tag === \"context\")?.[1] ?? void 0;\n  }\n  /**\n   * Will return the article URL or NDKEvent if they have already been\n   * set (it won't attempt to load remote events)\n   */\n  get article() {\n    return this._article;\n  }\n  /**\n   * Article the highlight is coming from.\n   *\n   * @param article Article URL or NDKEvent.\n   */\n  set article(article) {\n    this._article = article;\n    if (typeof article === \"string\") {\n      this.tags.push([\"r\", article]);\n    } else {\n      this.tag(article);\n    }\n  }\n  getArticleTag() {\n    return this.getMatchingTags(\"a\")[0] || this.getMatchingTags(\"e\")[0] || this.getMatchingTags(\"r\")[0];\n  }\n  async getArticle() {\n    if (this._article !== void 0) return this._article;\n    let taggedBech32;\n    const articleTag = this.getArticleTag();\n    if (!articleTag) return void 0;\n    switch (articleTag[0]) {\n      case \"a\":\n        const [kind, pubkey, identifier] = articleTag[1].split(\":\");\n        taggedBech32 = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.naddrEncode({ kind: parseInt(kind), pubkey, identifier });\n        break;\n      case \"e\":\n        taggedBech32 = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.noteEncode(articleTag[1]);\n        break;\n      case \"r\":\n        this._article = articleTag[1];\n        break;\n    }\n    if (taggedBech32) {\n      let a = await this.ndk?.fetchEvent(taggedBech32);\n      if (a) {\n        if (a.kind === 30023 /* Article */) {\n          a = NDKArticle.from(a);\n        }\n        this._article = a;\n      }\n    }\n    return this._article;\n  }\n};\n\n// src/utils/imeta.ts\nfunction mapImetaTag(tag) {\n  const data = {};\n  if (tag.length === 2) {\n    const parts = tag[1].split(\" \");\n    for (let i = 0; i < parts.length; i += 2) {\n      const key = parts[i];\n      const value = parts[i + 1];\n      if (key === \"fallback\") {\n        if (!data.fallback) data.fallback = [];\n        data.fallback.push(value);\n      } else {\n        data[key] = value;\n      }\n    }\n  }\n  for (const val of tag) {\n    const parts = val.split(\" \");\n    const key = parts[0];\n    const value = parts.slice(1).join(\" \");\n    if (key === \"fallback\") {\n      if (!data.fallback) data.fallback = [];\n      data.fallback.push(value);\n    } else {\n      data[key] = value;\n    }\n  }\n  return data;\n}\nfunction imetaTagToTag(imeta) {\n  const tag = [\"imeta\"];\n  for (const [key, value] of Object.entries(imeta)) {\n    if (Array.isArray(value)) {\n      for (const v of value) {\n        tag.push(key, v);\n      }\n    } else if (value) {\n      tag.push(key, value);\n    }\n  }\n  return tag;\n}\n\n// src/events/kinds/image.ts\nvar NDKImage = class _NDKImage extends NDKEvent {\n  static kind = 20 /* Image */;\n  static kinds = [20 /* Image */];\n  _imetas;\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 20 /* Image */;\n  }\n  /**\n   * Creates a NDKImage from an existing NDKEvent.\n   *\n   * @param event NDKEvent to create the NDKImage from.\n   * @returns NDKImage\n   */\n  static from(event) {\n    return new _NDKImage(event.ndk, event.rawEvent());\n  }\n  get isValid() {\n    return this.imetas.length > 0;\n  }\n  get imetas() {\n    if (this._imetas) return this._imetas;\n    this._imetas = this.tags.filter((tag) => tag[0] === \"imeta\").map(mapImetaTag).filter((imeta) => !!imeta.url);\n    return this._imetas;\n  }\n  set imetas(tags) {\n    this._imetas = tags;\n    this.tags = this.tags.filter((tag) => tag[0] !== \"imeta\");\n    this.tags.push(...tags.map(imetaTagToTag));\n  }\n};\n\n// src/events/kinds/lists/index.ts\nvar NDKList = class _NDKList extends NDKEvent {\n  _encryptedTags;\n  static kinds = [\n    10063 /* BlossomList */,\n    30001 /* CategorizedBookmarkList */,\n    10004 /* CommunityList */,\n    10050 /* DirectMessageReceiveRelayList */,\n    10030 /* EmojiList */,\n    10015 /* InterestList */,\n    10001 /* PinList */,\n    10002 /* RelayList */,\n    10007 /* SearchRelayList */,\n    10006 /* BlockRelayList */,\n    10003 /* BookmarkList */\n  ];\n  /**\n   * Stores the number of bytes the content was before decryption\n   * to expire the cache when the content changes.\n   */\n  encryptedTagsLength;\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 30001 /* CategorizedBookmarkList */;\n  }\n  /**\n   * Wrap a NDKEvent into a NDKList\n   */\n  static from(ndkEvent) {\n    return new _NDKList(ndkEvent.ndk, ndkEvent);\n  }\n  /**\n   * Returns the title of the list. Falls back on fetching the name tag value.\n   */\n  get title() {\n    const titleTag = this.tagValue(\"title\") || this.tagValue(\"name\");\n    if (titleTag) return titleTag;\n    if (this.kind === 3 /* Contacts */) {\n      return \"Contacts\";\n    } else if (this.kind === 1e4 /* MuteList */) {\n      return \"Mute\";\n    } else if (this.kind === 10001 /* PinList */) {\n      return \"Pinned Notes\";\n    } else if (this.kind === 10002 /* RelayList */) {\n      return \"Relay Metadata\";\n    } else if (this.kind === 10003 /* BookmarkList */) {\n      return \"Bookmarks\";\n    } else if (this.kind === 10004 /* CommunityList */) {\n      return \"Communities\";\n    } else if (this.kind === 10005 /* PublicChatList */) {\n      return \"Public Chats\";\n    } else if (this.kind === 10006 /* BlockRelayList */) {\n      return \"Blocked Relays\";\n    } else if (this.kind === 10007 /* SearchRelayList */) {\n      return \"Search Relays\";\n    } else if (this.kind === 10050 /* DirectMessageReceiveRelayList */) {\n      return \"Direct Message Receive Relays\";\n    } else if (this.kind === 10015 /* InterestList */) {\n      return \"Interests\";\n    } else if (this.kind === 10030 /* EmojiList */) {\n      return \"Emojis\";\n    } else {\n      return this.tagValue(\"d\");\n    }\n  }\n  /**\n   * Sets the title of the list.\n   */\n  set title(title) {\n    this.removeTag([\"title\", \"name\"]);\n    if (title) this.tags.push([\"title\", title]);\n  }\n  /**\n   * Returns the name of the list.\n   * @deprecated Please use \"title\" instead.\n   */\n  get name() {\n    return this.title;\n  }\n  /**\n   * Sets the name of the list.\n   * @deprecated Please use \"title\" instead. This method will use the `title` tag instead.\n   */\n  set name(name) {\n    this.title = name;\n  }\n  /**\n   * Returns the description of the list.\n   */\n  get description() {\n    return this.tagValue(\"description\");\n  }\n  /**\n   * Sets the description of the list.\n   */\n  set description(name) {\n    this.removeTag(\"description\");\n    if (name) this.tags.push([\"description\", name]);\n  }\n  /**\n   * Returns the image of the list.\n   */\n  get image() {\n    return this.tagValue(\"image\");\n  }\n  /**\n   * Sets the image of the list.\n   */\n  set image(name) {\n    this.removeTag(\"image\");\n    if (name) this.tags.push([\"image\", name]);\n  }\n  isEncryptedTagsCacheValid() {\n    return !!(this._encryptedTags && this.encryptedTagsLength === this.content.length);\n  }\n  /**\n   * Returns the decrypted content of the list.\n   */\n  async encryptedTags(useCache = true) {\n    if (useCache && this.isEncryptedTagsCacheValid()) return this._encryptedTags;\n    if (!this.ndk) throw new Error(\"NDK instance not set\");\n    if (!this.ndk.signer) throw new Error(\"NDK signer not set\");\n    const user = await this.ndk.signer.user();\n    try {\n      if (this.content.length > 0) {\n        try {\n          const decryptedContent = await this.ndk.signer.decrypt(user, this.content);\n          const a = JSON.parse(decryptedContent);\n          if (a && a[0]) {\n            this.encryptedTagsLength = this.content.length;\n            return this._encryptedTags = a;\n          }\n          this.encryptedTagsLength = this.content.length;\n          return this._encryptedTags = [];\n        } catch (e) {\n          console.log(`error decrypting ${this.content}`);\n        }\n      }\n    } catch (e) {\n    }\n    return [];\n  }\n  /**\n   * This method can be overriden to validate that a tag is valid for this list.\n   *\n   * (i.e. the NDKPersonList can validate that items are NDKUser instances)\n   */\n  validateTag(tagValue) {\n    return true;\n  }\n  getItems(type) {\n    return this.tags.filter((tag) => tag[0] === type);\n  }\n  /**\n   * Returns the unecrypted items in this list.\n   */\n  get items() {\n    return this.tags.filter((t) => {\n      return ![\n        \"d\",\n        \"L\",\n        \"l\",\n        \"title\",\n        \"name\",\n        \"description\",\n        \"published_at\",\n        \"summary\",\n        \"image\",\n        \"thumb\",\n        \"alt\",\n        \"expiration\",\n        \"subject\",\n        \"client\"\n      ].includes(t[0]);\n    });\n  }\n  /**\n   * Adds a new item to the list.\n   * @param relay Relay to add\n   * @param mark Optional mark to add to the item\n   * @param encrypted Whether to encrypt the item\n   * @param position Where to add the item in the list (top or bottom)\n   */\n  async addItem(item, mark = void 0, encrypted = false, position = \"bottom\") {\n    if (!this.ndk) throw new Error(\"NDK instance not set\");\n    if (!this.ndk.signer) throw new Error(\"NDK signer not set\");\n    let tags;\n    if (item instanceof NDKEvent) {\n      tags = [item.tagReference(mark)];\n    } else if (item instanceof NDKUser) {\n      tags = item.referenceTags();\n    } else if (item instanceof NDKRelay) {\n      tags = item.referenceTags();\n    } else if (Array.isArray(item)) {\n      tags = [item];\n    } else {\n      throw new Error(\"Invalid object type\");\n    }\n    if (mark) tags[0].push(mark);\n    if (encrypted) {\n      const user = await this.ndk.signer.user();\n      const currentList = await this.encryptedTags();\n      if (position === \"top\") currentList.unshift(...tags);\n      else currentList.push(...tags);\n      this._encryptedTags = currentList;\n      this.encryptedTagsLength = this.content.length;\n      this.content = JSON.stringify(currentList);\n      await this.encrypt(user);\n    } else {\n      if (position === \"top\") this.tags.unshift(...tags);\n      else this.tags.push(...tags);\n    }\n    this.created_at = Math.floor(Date.now() / 1e3);\n    this.emit(\"change\");\n  }\n  /**\n   * Removes an item from the list from both the encrypted and unencrypted lists.\n   * @param value value of item to remove from the list\n   * @param publish whether to publish the change\n   * @returns\n   */\n  async removeItemByValue(value, publish = true) {\n    if (!this.ndk) throw new Error(\"NDK instance not set\");\n    if (!this.ndk.signer) throw new Error(\"NDK signer not set\");\n    const index = this.tags.findIndex((tag) => tag[1] === value);\n    if (index >= 0) {\n      this.tags.splice(index, 1);\n    }\n    const user = await this.ndk.signer.user();\n    const encryptedTags = await this.encryptedTags();\n    const encryptedIndex = encryptedTags.findIndex((tag) => tag[1] === value);\n    if (encryptedIndex >= 0) {\n      encryptedTags.splice(encryptedIndex, 1);\n      this._encryptedTags = encryptedTags;\n      this.encryptedTagsLength = this.content.length;\n      this.content = JSON.stringify(encryptedTags);\n      await this.encrypt(user);\n    }\n    if (publish) {\n      return this.publishReplaceable();\n    } else {\n      this.created_at = Math.floor(Date.now() / 1e3);\n    }\n    this.emit(\"change\");\n  }\n  /**\n   * Removes an item from the list.\n   *\n   * @param index The index of the item to remove.\n   * @param encrypted Whether to remove from the encrypted list or not.\n   */\n  async removeItem(index, encrypted) {\n    if (!this.ndk) throw new Error(\"NDK instance not set\");\n    if (!this.ndk.signer) throw new Error(\"NDK signer not set\");\n    if (encrypted) {\n      const user = await this.ndk.signer.user();\n      const currentList = await this.encryptedTags();\n      currentList.splice(index, 1);\n      this._encryptedTags = currentList;\n      this.encryptedTagsLength = this.content.length;\n      this.content = JSON.stringify(currentList);\n      await this.encrypt(user);\n    } else {\n      this.tags.splice(index, 1);\n    }\n    this.created_at = Math.floor(Date.now() / 1e3);\n    this.emit(\"change\");\n    return this;\n  }\n  has(item) {\n    return this.items.some((tag) => tag[1] === item);\n  }\n  /**\n   * Creates a filter that will result in fetching\n   * the items of this list\n   * @example\n   * const list = new NDKList(...);\n   * const filters = list.filterForItems();\n   * const events = await ndk.fetchEvents(filters);\n   */\n  filterForItems() {\n    const ids = /* @__PURE__ */ new Set();\n    const nip33Queries = /* @__PURE__ */ new Map();\n    const filters = [];\n    for (const tag of this.items) {\n      if (tag[0] === \"e\" && tag[1]) {\n        ids.add(tag[1]);\n      } else if (tag[0] === \"a\" && tag[1]) {\n        const [kind, pubkey, dTag] = tag[1].split(\":\");\n        if (!kind || !pubkey) continue;\n        const key = `${kind}:${pubkey}`;\n        const item = nip33Queries.get(key) || [];\n        item.push(dTag || \"\");\n        nip33Queries.set(key, item);\n      }\n    }\n    if (ids.size > 0) {\n      filters.push({ ids: Array.from(ids) });\n    }\n    if (nip33Queries.size > 0) {\n      for (const [key, values] of nip33Queries.entries()) {\n        const [kind, pubkey] = key.split(\":\");\n        filters.push({\n          kinds: [parseInt(kind)],\n          authors: [pubkey],\n          \"#d\": values\n        });\n      }\n    }\n    return filters;\n  }\n};\nvar lists_default = NDKList;\n\n// src/events/kinds/nutzap/index.ts\n\nvar NDKNutzap = class _NDKNutzap extends NDKEvent {\n  debug;\n  _proofs = [];\n  static kind = 9321 /* Nutzap */;\n  static kinds = [_NDKNutzap.kind];\n  constructor(ndk, event) {\n    super(ndk, event);\n    this.kind ??= 9321 /* Nutzap */;\n    this.debug = ndk?.debug.extend(\"nutzap\") ?? debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:nutzap\");\n    if (!this.alt) this.alt = \"This is a nutzap\";\n  }\n  static from(event) {\n    const e = new this(event.ndk, event);\n    try {\n      const proofTags = e.getMatchingTags(\"proof\");\n      if (proofTags.length) {\n        e._proofs = proofTags.map((tag) => JSON.parse(tag[1]));\n      } else {\n        e._proofs = JSON.parse(e.content);\n      }\n    } catch {\n      return;\n    }\n    if (!e._proofs || !e._proofs.length) return;\n    return e;\n  }\n  set comment(comment) {\n    this.content = comment ?? \"\";\n  }\n  get comment() {\n    const c = this.tagValue(\"comment\");\n    if (c) return c;\n    return this.content;\n  }\n  set proofs(proofs) {\n    this._proofs = proofs;\n    this.tags = this.tags.filter((tag) => tag[0] !== \"proof\");\n    for (const proof of proofs) {\n      this.tags.push([\"proof\", JSON.stringify(proof)]);\n    }\n  }\n  get proofs() {\n    return this._proofs;\n  }\n  /**\n   * Gets the p2pk pubkey that is embedded in the first proof\n   */\n  get p2pk() {\n    const firstProof = this.proofs[0];\n    try {\n      const secret = JSON.parse(firstProof.secret);\n      let payload = {};\n      if (typeof secret === \"string\") {\n        payload = JSON.parse(secret);\n        this.debug(\"stringified payload\", firstProof.secret);\n      } else if (typeof secret === \"object\") {\n        payload = secret;\n      }\n      const isP2PKLocked = payload[0] === \"P2PK\" && payload[1]?.data;\n      if (isP2PKLocked) {\n        const paddedp2pk = payload[1].data;\n        const p2pk = paddedp2pk.slice(2);\n        if (p2pk) return p2pk;\n      }\n    } catch (e) {\n      this.debug(\"error parsing p2pk pubkey\", e, this.proofs[0]);\n    }\n  }\n  /**\n   * Get the mint where this nutzap proofs exist\n   */\n  get mint() {\n    return this.tagValue(\"u\");\n  }\n  set mint(value) {\n    this.removeTag(\"u\");\n    this.tag([\"u\", value]);\n  }\n  get unit() {\n    return this.tagValue(\"unit\") ?? \"sat\";\n  }\n  set unit(value) {\n    this.removeTag(\"unit\");\n    if (value) this.tag([\"unit\", value]);\n  }\n  get amount() {\n    const amount = this.proofs.reduce((total, proof) => total + proof.amount, 0);\n    if (this.unit === \"msat\") return amount * 1e3;\n    return amount;\n  }\n  sender = this.author;\n  /**\n   * Set the target of the nutzap\n   * @param target The target of the nutzap (a user or an event)\n   */\n  set target(target) {\n    this.tags = this.tags.filter((t) => t[0] !== \"p\");\n    if (target instanceof NDKEvent) {\n      this.tags.push(target.tagReference());\n    }\n  }\n  set recipientPubkey(pubkey) {\n    this.removeTag(\"p\");\n    this.tag([\"p\", pubkey]);\n  }\n  get recipientPubkey() {\n    return this.tagValue(\"p\");\n  }\n  get recipient() {\n    const pubkey = this.recipientPubkey;\n    if (this.ndk) return this.ndk.getUser({ pubkey });\n    return new NDKUser({ pubkey });\n  }\n  async toNostrEvent() {\n    if (this.unit === \"msat\") {\n      this.unit = \"sat\";\n    }\n    this.removeTag(\"amount\");\n    this.tags.push([\"amount\", this.amount.toString()]);\n    const event = await super.toNostrEvent();\n    event.content = this.comment;\n    return event;\n  }\n  /**\n   * Validates that the nutzap conforms to NIP-61\n   */\n  get isValid() {\n    let eTagCount = 0;\n    let pTagCount = 0;\n    let mintTagCount = 0;\n    for (const tag of this.tags) {\n      if (tag[0] === \"e\") eTagCount++;\n      if (tag[0] === \"p\") pTagCount++;\n      if (tag[0] === \"u\") mintTagCount++;\n    }\n    return (\n      // exactly one recipient and mint\n      pTagCount === 1 && mintTagCount === 1 && // must have at most one e tag\n      eTagCount <= 1 && // must have at least one proof\n      this.proofs.length > 0\n    );\n  }\n};\nfunction proofP2pk(proof) {\n  try {\n    const secret = JSON.parse(proof.secret);\n    let payload = {};\n    if (typeof secret === \"string\") {\n      payload = JSON.parse(secret);\n    } else if (typeof secret === \"object\") {\n      payload = secret;\n    }\n    const isP2PKLocked = payload[0] === \"P2PK\" && payload[1]?.data;\n    if (isP2PKLocked) {\n      return payload[1].data;\n    }\n  } catch (e) {\n    console.error(\"error parsing p2pk pubkey\", e, proof);\n  }\n}\nfunction proofP2pkNostr(proof) {\n  const p2pk = proofP2pk(proof);\n  if (!p2pk) return;\n  if (p2pk.startsWith(\"02\") && p2pk.length === 66) return p2pk.slice(2);\n  return p2pk;\n}\n\n// src/events/kinds/nutzap/mint-list.ts\nvar NDKCashuMintList = class _NDKCashuMintList extends NDKEvent {\n  static kind = 10019 /* CashuMintList */;\n  static kinds = [10019 /* CashuMintList */];\n  _p2pk;\n  constructor(ndk, event) {\n    super(ndk, event);\n    this.kind ??= 10019 /* CashuMintList */;\n  }\n  static from(event) {\n    return new _NDKCashuMintList(event.ndk, event);\n  }\n  set relays(urls) {\n    this.tags = this.tags.filter((t) => t[0] !== \"relay\");\n    for (const url of urls) {\n      this.tags.push([\"relay\", url]);\n    }\n  }\n  get relays() {\n    const r = [];\n    for (const tag of this.tags) {\n      if (tag[0] === \"relay\") {\n        r.push(tag[1]);\n      }\n    }\n    return r;\n  }\n  set mints(urls) {\n    this.tags = this.tags.filter((t) => t[0] !== \"mint\");\n    for (const url of urls) {\n      this.tags.push([\"mint\", url]);\n    }\n  }\n  get mints() {\n    const r = [];\n    for (const tag of this.tags) {\n      if (tag[0] === \"mint\") {\n        r.push(tag[1]);\n      }\n    }\n    return Array.from(new Set(r));\n  }\n  get p2pk() {\n    if (this._p2pk) {\n      return this._p2pk;\n    }\n    this._p2pk = this.tagValue(\"pubkey\") ?? this.pubkey;\n    return this._p2pk;\n  }\n  set p2pk(pubkey) {\n    this._p2pk = pubkey;\n    this.removeTag(\"pubkey\");\n    if (pubkey) {\n      this.tags.push([\"pubkey\", pubkey]);\n    }\n  }\n  get relaySet() {\n    return NDKRelaySet.fromRelayUrls(this.relays, this.ndk);\n  }\n};\n\n// src/events/kinds/simple-group/member-list.ts\nvar NDKSimpleGroupMemberList = class _NDKSimpleGroupMemberList extends NDKEvent {\n  relaySet;\n  memberSet = /* @__PURE__ */ new Set();\n  static kind = 39002 /* GroupMembers */;\n  static kinds = [39002 /* GroupMembers */];\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 39002 /* GroupMembers */;\n    this.memberSet = new Set(this.members);\n  }\n  static from(event) {\n    return new _NDKSimpleGroupMemberList(event.ndk, event);\n  }\n  get members() {\n    return this.getMatchingTags(\"p\").map((tag) => tag[1]);\n  }\n  hasMember(member) {\n    return this.memberSet.has(member);\n  }\n  async publish(relaySet, timeoutMs, requiredRelayCount) {\n    relaySet ??= this.relaySet;\n    return super.publishReplaceable(relaySet, timeoutMs, requiredRelayCount);\n  }\n};\n\n// src/events/kinds/simple-group/metadata.ts\nvar NDKSimpleGroupMetadata = class _NDKSimpleGroupMetadata extends NDKEvent {\n  static kind = 39e3 /* GroupMetadata */;\n  static kinds = [39e3 /* GroupMetadata */];\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 39e3 /* GroupMetadata */;\n  }\n  static from(event) {\n    return new _NDKSimpleGroupMetadata(event.ndk, event);\n  }\n  get name() {\n    return this.tagValue(\"name\");\n  }\n  get picture() {\n    return this.tagValue(\"picture\");\n  }\n  get about() {\n    return this.tagValue(\"about\");\n  }\n  get scope() {\n    if (this.getMatchingTags(\"public\").length > 0) return \"public\";\n    if (this.getMatchingTags(\"public\").length > 0) return \"private\";\n  }\n  set scope(scope) {\n    this.removeTag(\"public\");\n    this.removeTag(\"private\");\n    if (scope === \"public\") {\n      this.tags.push([\"public\", \"\"]);\n    } else if (scope === \"private\") {\n      this.tags.push([\"private\", \"\"]);\n    }\n  }\n  get access() {\n    if (this.getMatchingTags(\"open\").length > 0) return \"open\";\n    if (this.getMatchingTags(\"closed\").length > 0) return \"closed\";\n  }\n  set access(access) {\n    this.removeTag(\"open\");\n    this.removeTag(\"closed\");\n    if (access === \"open\") {\n      this.tags.push([\"open\", \"\"]);\n    } else if (access === \"closed\") {\n      this.tags.push([\"closed\", \"\"]);\n    }\n  }\n};\n\n// src/events/kinds/subscriptions/amount.ts\nvar possibleIntervalFrequencies = [\n  \"daily\",\n  \"weekly\",\n  \"monthly\",\n  \"quarterly\",\n  \"yearly\"\n];\nfunction calculateTermDurationInSeconds(term) {\n  switch (term) {\n    case \"daily\":\n      return 24 * 60 * 60;\n    case \"weekly\":\n      return 7 * 24 * 60 * 60;\n    case \"monthly\":\n      return 30 * 24 * 60 * 60;\n    case \"quarterly\":\n      return 3 * 30 * 24 * 60 * 60;\n    case \"yearly\":\n      return 365 * 24 * 60 * 60;\n  }\n}\nfunction newAmount(amount, currency, term) {\n  return [\"amount\", amount.toString(), currency, term];\n}\nfunction parseTagToSubscriptionAmount(tag) {\n  const amount = parseInt(tag[1]);\n  if (isNaN(amount) || amount === void 0 || amount === null || amount <= 0) return void 0;\n  const currency = tag[2];\n  if (currency === void 0 || currency === \"\") return void 0;\n  const term = tag[3];\n  if (term === void 0) return void 0;\n  if (!possibleIntervalFrequencies.includes(term)) return void 0;\n  return {\n    amount,\n    currency,\n    term\n  };\n}\n\n// src/events/kinds/subscriptions/tier.ts\nvar NDKSubscriptionTier = class _NDKSubscriptionTier extends NDKArticle {\n  static kind = 37001 /* SubscriptionTier */;\n  static kinds = [37001 /* SubscriptionTier */];\n  constructor(ndk, rawEvent) {\n    const k = rawEvent?.kind ?? 37001 /* SubscriptionTier */;\n    super(ndk, rawEvent);\n    this.kind = k;\n  }\n  /**\n   * Creates a new NDKSubscriptionTier from an event\n   * @param event\n   * @returns NDKSubscriptionTier\n   */\n  static from(event) {\n    return new _NDKSubscriptionTier(event.ndk, event);\n  }\n  /**\n   * Returns perks for this tier\n   */\n  get perks() {\n    return this.getMatchingTags(\"perk\").map((tag) => tag[1]).filter((perk) => perk !== void 0);\n  }\n  /**\n   * Adds a perk to this tier\n   */\n  addPerk(perk) {\n    this.tags.push([\"perk\", perk]);\n  }\n  /**\n   * Returns the amount for this tier\n   */\n  get amounts() {\n    return this.getMatchingTags(\"amount\").map((tag) => parseTagToSubscriptionAmount(tag)).filter((a) => a !== void 0);\n  }\n  /**\n   * Adds an amount to this tier\n   * @param amount Amount in the smallest unit of the currency (e.g. cents, msats)\n   * @param currency Currency code. Use msat for millisatoshis\n   * @param term One of daily, weekly, monthly, quarterly, yearly\n   */\n  addAmount(amount, currency, term) {\n    this.tags.push(newAmount(amount, currency, term));\n  }\n  /**\n   * Sets a relay where content related to this tier can be found\n   * @param relayUrl URL of the relay\n   */\n  set relayUrl(relayUrl) {\n    this.tags.push([\"r\", relayUrl]);\n  }\n  /**\n   * Returns the relay URLs for this tier\n   */\n  get relayUrls() {\n    return this.getMatchingTags(\"r\").map((tag) => tag[1]).filter((relay) => relay !== void 0);\n  }\n  /**\n   * Gets the verifier pubkey for this tier. This is the pubkey that will generate\n   * subscription payment receipts\n   */\n  get verifierPubkey() {\n    return this.tagValue(\"p\");\n  }\n  /**\n   * Sets the verifier pubkey for this tier.\n   */\n  set verifierPubkey(pubkey) {\n    this.removeTag(\"p\");\n    if (pubkey) this.tags.push([\"p\", pubkey]);\n  }\n  /**\n   * Checks if this tier is valid\n   */\n  get isValid() {\n    return this.title !== void 0 && // Must have a title\n    this.amounts.length > 0;\n  }\n};\n\n// src/events/kinds/video.ts\nvar NDKVideo = class _NDKVideo extends NDKEvent {\n  static kind = 34235 /* HorizontalVideo */;\n  static kinds = [34235 /* HorizontalVideo */, 34236 /* VerticalVideo */];\n  _imetas;\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 34235 /* HorizontalVideo */;\n  }\n  /**\n   * Creates a NDKArticle from an existing NDKEvent.\n   *\n   * @param event NDKEvent to create the NDKArticle from.\n   * @returns NDKArticle\n   */\n  static from(event) {\n    return new _NDKVideo(event.ndk, event.rawEvent());\n  }\n  /**\n   * Getter for the article title.\n   *\n   * @returns {string | undefined} - The article title if available, otherwise undefined.\n   */\n  get title() {\n    return this.tagValue(\"title\");\n  }\n  /**\n   * Setter for the article title.\n   *\n   * @param {string | undefined} title - The title to set for the article.\n   */\n  set title(title) {\n    this.removeTag(\"title\");\n    if (title) this.tags.push([\"title\", title]);\n  }\n  /**\n   * Getter for the article thumbnail.\n   *\n   * @returns {string | undefined} - The article thumbnail if available, otherwise undefined.\n   */\n  get thumbnail() {\n    let thumbnail;\n    if (this.imetas && this.imetas.length > 0) {\n      thumbnail = this.imetas[0].image?.[0];\n    }\n    return thumbnail ?? this.tagValue(\"thumb\");\n  }\n  get imetas() {\n    if (this._imetas) return this._imetas;\n    this._imetas = this.tags.filter((tag) => tag[0] === \"imeta\").map(mapImetaTag);\n    return this._imetas;\n  }\n  set imetas(tags) {\n    this._imetas = tags;\n    this.tags = this.tags.filter((tag) => tag[0] !== \"imeta\");\n    this.tags.push(...tags.map(imetaTagToTag));\n  }\n  get url() {\n    if (this.imetas && this.imetas.length > 0) {\n      return this.imetas[0].url;\n    }\n    return this.tagValue(\"url\");\n  }\n  /**\n   * Getter for the article's publication timestamp.\n   *\n   * @returns {number | undefined} - The Unix timestamp of when the article was published or undefined.\n   */\n  get published_at() {\n    const tag = this.tagValue(\"published_at\");\n    if (tag) {\n      return parseInt(tag);\n    }\n    return void 0;\n  }\n  /**\n   * Setter for the article's publication timestamp.\n   *\n   * @param {number | undefined} timestamp - The Unix timestamp to set for the article's publication date.\n   */\n  set published_at(timestamp) {\n    this.removeTag(\"published_at\");\n    if (timestamp !== void 0) {\n      this.tags.push([\"published_at\", timestamp.toString()]);\n    }\n  }\n  /**\n   * Generates content tags for the article.\n   *\n   * This method first checks and sets the publication date if not available,\n   * and then generates content tags based on the base NDKEvent class.\n   *\n   * @returns {ContentTag} - The generated content tags.\n   */\n  async generateTags() {\n    super.generateTags();\n    if (!this.published_at) {\n      this.published_at = this.created_at;\n    }\n    return super.generateTags();\n  }\n  get duration() {\n    const tag = this.tagValue(\"duration\");\n    if (tag) {\n      return parseInt(tag);\n    }\n    return void 0;\n  }\n  /**\n   * Setter for the video's duration\n   *\n   * @param {number | undefined} duration - The duration to set for the video (in seconds)\n   */\n  set duration(dur) {\n    this.removeTag(\"duration\");\n    if (dur !== void 0) {\n      this.tags.push([\"duration\", Math.floor(dur).toString()]);\n    }\n  }\n};\n\n// src/events/kinds/wiki.ts\nvar NDKWiki = class extends NDKArticle {\n  static kind = 30818 /* Wiki */;\n  static kinds = [30818 /* Wiki */];\n};\n\n// src/events/wrap.ts\nfunction wrapEvent(event) {\n  const eventWrappingMap = /* @__PURE__ */ new Map();\n  [\n    NDKImage,\n    NDKVideo,\n    NDKCashuMintList,\n    NDKArticle,\n    NDKHighlight,\n    NDKWiki,\n    NDKNutzap,\n    NDKSimpleGroupMemberList,\n    NDKSimpleGroupMetadata,\n    NDKSubscriptionTier,\n    NDKCashuToken,\n    NDKList\n  ].forEach((klass2) => {\n    klass2.kinds.forEach((kind) => {\n      eventWrappingMap.set(kind, klass2);\n    });\n  });\n  const klass = eventWrappingMap.get(event.kind);\n  if (klass) return klass.from(event);\n  return event;\n}\n\n// src/subscription/index.ts\nvar NDKSubscriptionCacheUsage = /* @__PURE__ */ ((NDKSubscriptionCacheUsage2) => {\n  NDKSubscriptionCacheUsage2[\"ONLY_CACHE\"] = \"ONLY_CACHE\";\n  NDKSubscriptionCacheUsage2[\"CACHE_FIRST\"] = \"CACHE_FIRST\";\n  NDKSubscriptionCacheUsage2[\"PARALLEL\"] = \"PARALLEL\";\n  NDKSubscriptionCacheUsage2[\"ONLY_RELAY\"] = \"ONLY_RELAY\";\n  return NDKSubscriptionCacheUsage2;\n})(NDKSubscriptionCacheUsage || {});\nvar defaultOpts = {\n  closeOnEose: false,\n  cacheUsage: \"CACHE_FIRST\" /* CACHE_FIRST */,\n  dontSaveToCache: false,\n  groupable: true,\n  groupableDelay: 100,\n  groupableDelayType: \"at-most\",\n  cacheUnconstrainFilter: [\"limit\", \"since\", \"until\"]\n};\nvar NDKSubscription = class extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  subId;\n  filters;\n  opts;\n  pool;\n  skipVerification = false;\n  skipValidation = false;\n  /**\n   * Tracks the filters as they are executed on each relay\n   */\n  relayFilters;\n  relaySet;\n  ndk;\n  debug;\n  /**\n   * Events that have been seen by the subscription, with the time they were first seen.\n   */\n  eventFirstSeen = /* @__PURE__ */ new Map();\n  /**\n   * Relays that have sent an EOSE.\n   */\n  eosesSeen = /* @__PURE__ */ new Set();\n  /**\n   * The time the last event was received by the subscription.\n   * This is used to calculate when EOSE should be emitted.\n   */\n  lastEventReceivedAt;\n  internalId;\n  /**\n   * Whether the subscription should close when all relays have reached the end of the event stream.\n   */\n  closeOnEose;\n  /**\n   * Pool monitor callback\n   */\n  poolMonitor;\n  skipOptimisticPublishEvent = false;\n  /**\n   * Filters to remove when querying the cache.\n   */\n  cacheUnconstrainFilter;\n  constructor(ndk, filters, opts, relaySet, subId) {\n    super();\n    this.ndk = ndk;\n    this.pool = opts?.pool || ndk.pool;\n    this.opts = { ...defaultOpts, ...opts || {} };\n    this.filters = filters instanceof Array ? filters : [filters];\n    this.subId = subId || this.opts.subId;\n    this.internalId = Math.random().toString(36).substring(7);\n    this.relaySet = relaySet;\n    this.debug = ndk.debug.extend(`subscription[${this.opts.subId ?? this.internalId}]`);\n    this.skipVerification = this.opts.skipVerification || false;\n    this.skipValidation = this.opts.skipValidation || false;\n    this.closeOnEose = this.opts.closeOnEose || false;\n    this.skipOptimisticPublishEvent = this.opts.skipOptimisticPublishEvent || false;\n    this.cacheUnconstrainFilter = this.opts.cacheUnconstrainFilter;\n  }\n  /**\n   * Returns the relays that have not yet sent an EOSE.\n   */\n  relaysMissingEose() {\n    if (!this.relayFilters) return [];\n    const relaysMissingEose = Array.from(this.relayFilters.keys()).filter(\n      (url) => !this.eosesSeen.has(this.pool.getRelay(url, false, false))\n    );\n    return relaysMissingEose;\n  }\n  /**\n   * Provides access to the first filter of the subscription for\n   * backwards compatibility.\n   */\n  get filter() {\n    return this.filters[0];\n  }\n  get groupableDelay() {\n    if (!this.isGroupable()) return void 0;\n    return this.opts?.groupableDelay;\n  }\n  get groupableDelayType() {\n    return this.opts?.groupableDelayType || \"at-most\";\n  }\n  isGroupable() {\n    return this.opts?.groupable || false;\n  }\n  shouldQueryCache() {\n    if (this.opts?.cacheUsage === \"ONLY_RELAY\" /* ONLY_RELAY */) return false;\n    const hasNonEphemeralKind = this.filters.some((f) => f.kinds?.some((k) => kindIsEphemeral(k)));\n    if (hasNonEphemeralKind) return true;\n    return true;\n  }\n  shouldQueryRelays() {\n    return this.opts?.cacheUsage !== \"ONLY_CACHE\" /* ONLY_CACHE */;\n  }\n  shouldWaitForCache() {\n    return (\n      // Must want to close on EOSE; subscriptions\n      // that want to receive further updates must\n      // always hit the relay\n      this.opts.closeOnEose && // Cache adapter must claim to be fast\n      !!this.ndk.cacheAdapter?.locking && // If explicitly told to run in parallel, then\n      // we should not wait for the cache\n      this.opts.cacheUsage !== \"PARALLEL\" /* PARALLEL */\n    );\n  }\n  /**\n   * Start the subscription. This is the main method that should be called\n   * after creating a subscription.\n   * \n   * @param emitCachedEvents - Whether to emit events coming from a synchronous cache\n   * \n   * When using a synchronous cache, the events will be returned immediately\n   * by this function. If you will use those returned events, you should\n   * set emitCachedEvents to false to prevent seeing them as duplicate events.\n   */\n  start(emitCachedEvents = true) {\n    let cacheResult;\n    const updateStateFromCacheResults = (events) => {\n      if (emitCachedEvents) {\n        for (const event of events) {\n          this.eventReceived(event, void 0, true, false);\n        }\n      } else {\n        cacheResult = [];\n        events.forEach((event) => {\n          event.ndk = this.ndk;\n          const e = this.opts.wrap ? wrapEvent(event) : event;\n          if (!e) return;\n          if (e instanceof Promise) {\n            e.then((wrappedEvent) => {\n              this.emitEvent(false, wrappedEvent, void 0, true, false);\n            });\n            return;\n          }\n          this.eventFirstSeen.set(e.id, Date.now());\n          cacheResult.push(e);\n        });\n      }\n    };\n    const loadFromRelays = () => {\n      if (this.shouldQueryRelays()) {\n        this.startWithRelays();\n        this.startPoolMonitor();\n      } else {\n        this.emit(\"eose\", this);\n      }\n    };\n    if (this.shouldQueryCache()) {\n      cacheResult = this.startWithCache();\n      if (cacheResult instanceof Promise) {\n        if (this.shouldWaitForCache()) {\n          cacheResult.then((events) => {\n            updateStateFromCacheResults(events);\n            if (queryFullyFilled(this)) {\n              this.emit(\"eose\", this);\n              return;\n            } else {\n              loadFromRelays();\n            }\n          });\n          return null;\n        } else {\n          cacheResult.then((events) => {\n            updateStateFromCacheResults(events);\n          });\n        }\n        return null;\n      } else {\n        updateStateFromCacheResults(cacheResult);\n        if (queryFullyFilled(this)) {\n          this.emit(\"eose\", this);\n        } else {\n          loadFromRelays();\n        }\n        return cacheResult;\n      }\n    } else {\n      loadFromRelays();\n      return null;\n    }\n  }\n  /**\n   * We want to monitor for new relays that are coming online, in case\n   * they should be part of this subscription.\n   */\n  startPoolMonitor() {\n    const d4 = this.debug.extend(\"pool-monitor\");\n    this.poolMonitor = (relay) => {\n      if (this.relayFilters?.has(relay.url)) return;\n      const calc = calculateRelaySetsFromFilters(this.ndk, this.filters, this.pool);\n      if (calc.get(relay.url)) {\n        this.relayFilters?.set(relay.url, this.filters);\n        relay.subscribe(this, this.filters);\n      }\n    };\n    this.pool.on(\"relay:connect\", this.poolMonitor);\n  }\n  onStopped;\n  stop() {\n    this.emit(\"close\", this);\n    this.poolMonitor && this.pool.off(\"relay:connect\", this.poolMonitor);\n    this.removeAllListeners();\n    this.onStopped?.();\n  }\n  /**\n   * @returns Whether the subscription has an authors filter.\n   */\n  hasAuthorsFilter() {\n    return this.filters.some((f) => f.authors?.length);\n  }\n  startWithCache() {\n    if (this.ndk.cacheAdapter?.query) {\n      return this.ndk.cacheAdapter.query(this);\n    } else {\n      return [];\n    }\n  }\n  /**\n   * Send REQ to relays\n   */\n  startWithRelays() {\n    if (!this.relaySet || this.relaySet.relays.size === 0) {\n      this.relayFilters = calculateRelaySetsFromFilters(this.ndk, this.filters, this.pool);\n    } else {\n      this.relayFilters = /* @__PURE__ */ new Map();\n      for (const relay of this.relaySet.relays) {\n        this.relayFilters.set(relay.url, this.filters);\n      }\n    }\n    if (!this.relayFilters || this.relayFilters.size === 0) return;\n    for (const [relayUrl, filters] of this.relayFilters) {\n      const relay = this.pool.getRelay(relayUrl, true, true, filters);\n      relay.subscribe(this, filters);\n    }\n  }\n  // EVENT handling\n  /**\n   * Called when an event is received from a relay or the cache\n   * @param event\n   * @param relay\n   * @param fromCache Whether the event was received from the cache\n   * @param optimisticPublish Whether this event is coming from an optimistic publish\n   */\n  eventReceived(event, relay, fromCache = false, optimisticPublish = false) {\n    const eventId = event.id;\n    const eventAlreadySeen = this.eventFirstSeen.has(eventId);\n    let ndkEvent;\n    if (event instanceof NDKEvent) ndkEvent = event;\n    if (!eventAlreadySeen) {\n      ndkEvent ??= new NDKEvent(this.ndk, event);\n      ndkEvent.ndk = this.ndk;\n      ndkEvent.relay = relay;\n      if (!fromCache && !optimisticPublish) {\n        if (!this.skipValidation) {\n          if (!ndkEvent.isValid) {\n            this.debug(`Event failed validation %s from relay %s`, eventId, relay?.url);\n            return;\n          }\n        }\n        if (relay) {\n          if (relay?.shouldValidateEvent() !== false) {\n            if (!this.skipVerification) {\n              if (!ndkEvent.verifySignature(true) && !this.ndk.asyncSigVerification) {\n                this.debug(`Event failed signature validation`, event);\n                return;\n              } else if (relay) {\n                relay.addValidatedEvent();\n              }\n            }\n          } else {\n            relay.addNonValidatedEvent();\n          }\n        }\n        if (this.ndk.cacheAdapter && !this.opts.dontSaveToCache) {\n          this.ndk.cacheAdapter.setEvent(ndkEvent, this.filters, relay);\n        }\n      }\n      if (!optimisticPublish || this.skipOptimisticPublishEvent !== true) {\n        this.emitEvent(this.opts?.wrap, ndkEvent, relay, fromCache, optimisticPublish);\n        this.eventFirstSeen.set(eventId, Date.now());\n      }\n    } else {\n      const timeSinceFirstSeen = Date.now() - (this.eventFirstSeen.get(eventId) || 0);\n      this.emit(\"event:dup\", event, relay, timeSinceFirstSeen, this, fromCache, optimisticPublish);\n      if (relay) {\n        const signature = verifiedSignatures.get(eventId);\n        if (signature && typeof signature === \"string\") {\n          if (event.sig === signature) {\n            relay.addValidatedEvent();\n          }\n        }\n      }\n    }\n    this.lastEventReceivedAt = Date.now();\n  }\n  /**\n   * Optionally wraps, sync or async, and emits the event (if one comes back from the wrapper)\n   */\n  emitEvent(wrap = false, evt, relay, fromCache, optimisticPublish) {\n    const wrapped = wrap ? wrapEvent(evt) : evt;\n    if (wrapped instanceof Promise) {\n      wrapped.then((e) => this.emitEvent(false, e, relay, fromCache, optimisticPublish));\n    } else if (wrapped) {\n      this.emit(\"event\", wrapped, relay, this, fromCache, optimisticPublish);\n    }\n  }\n  closedReceived(relay, reason) {\n    this.emit(\"closed\", relay, reason);\n  }\n  // EOSE handling\n  eoseTimeout;\n  eosed = false;\n  eoseReceived(relay) {\n    this.debug(\"EOSE received from %s\", relay.url);\n    this.eosesSeen.add(relay);\n    let lastEventSeen = this.lastEventReceivedAt ? Date.now() - this.lastEventReceivedAt : void 0;\n    const hasSeenAllEoses = this.eosesSeen.size === this.relayFilters?.size;\n    const queryFilled = queryFullyFilled(this);\n    const performEose = (reason) => {\n      this.debug(\"Performing EOSE: %s %d\", reason, this.eosed);\n      if (this.eosed) return;\n      if (this.eoseTimeout) clearTimeout(this.eoseTimeout);\n      this.emit(\"eose\", this);\n      this.eosed = true;\n    };\n    if (queryFilled || hasSeenAllEoses) {\n      performEose(\"query filled or seen all\");\n    } else if (this.relayFilters) {\n      let timeToWaitForNextEose = 1e3;\n      const connectedRelays = new Set(this.pool.connectedRelays().map((r) => r.url));\n      const connectedRelaysWithFilters = Array.from(this.relayFilters.keys()).filter(\n        (url) => connectedRelays.has(url)\n      );\n      if (connectedRelaysWithFilters.length === 0) {\n        return;\n      }\n      const percentageOfRelaysThatHaveSentEose = this.eosesSeen.size / connectedRelaysWithFilters.length;\n      this.debug(\"Percentage of relays that have sent EOSE\", { subId: this.subId, percentageOfRelaysThatHaveSentEose, seen: this.eosesSeen.size, total: connectedRelaysWithFilters.length });\n      if (this.eosesSeen.size >= 2 && percentageOfRelaysThatHaveSentEose >= 0.5) {\n        timeToWaitForNextEose = timeToWaitForNextEose * (1 - percentageOfRelaysThatHaveSentEose);\n        if (timeToWaitForNextEose === 0) {\n          performEose(\"time to wait was 0\");\n          return;\n        }\n        if (this.eoseTimeout) clearTimeout(this.eoseTimeout);\n        const sendEoseTimeout = () => {\n          lastEventSeen = this.lastEventReceivedAt ? Date.now() - this.lastEventReceivedAt : void 0;\n          if (lastEventSeen !== void 0 && lastEventSeen < 20) {\n            this.eoseTimeout = setTimeout(sendEoseTimeout, timeToWaitForNextEose);\n          } else {\n            performEose(\"send eose timeout: \" + timeToWaitForNextEose);\n          }\n        };\n        this.eoseTimeout = setTimeout(sendEoseTimeout, timeToWaitForNextEose);\n      }\n    }\n  }\n};\nvar kindIsEphemeral = (kind) => kind >= 2e4 && kind < 3e4;\n\n// src/user/follows.ts\nasync function follows(opts, outbox, kind = 3 /* Contacts */) {\n  if (!this.ndk) throw new Error(\"NDK not set\");\n  const contactListEvent = await this.ndk.fetchEvent(\n    { kinds: [kind], authors: [this.pubkey] },\n    opts || { groupable: false }\n  );\n  if (contactListEvent) {\n    const pubkeys = /* @__PURE__ */ new Set();\n    contactListEvent.tags.forEach((tag) => {\n      if (tag[0] === \"p\") pubkeys.add(tag[1]);\n    });\n    if (outbox) {\n      this.ndk?.outboxTracker?.trackUsers(Array.from(pubkeys));\n    }\n    return [...pubkeys].reduce((acc, pubkey) => {\n      const user = new NDKUser({ pubkey });\n      user.ndk = this.ndk;\n      acc.add(user);\n      return acc;\n    }, /* @__PURE__ */ new Set());\n  }\n  return /* @__PURE__ */ new Set();\n}\n\n// src/user/profile.ts\nfunction profileFromEvent(event) {\n  const profile = {};\n  let payload;\n  try {\n    payload = JSON.parse(event.content);\n  } catch (error) {\n    throw new Error(`Failed to parse profile event: ${error}`);\n  }\n  profile.created_at = event.created_at;\n  profile.profileEvent = JSON.stringify(event.rawEvent());\n  Object.keys(payload).forEach((key) => {\n    switch (key) {\n      case \"name\":\n        profile.name = payload.name;\n        break;\n      case \"display_name\":\n        profile.displayName = payload.display_name;\n        break;\n      case \"image\":\n      case \"picture\":\n        profile.picture = payload.picture || payload.image;\n        profile.image = profile.picture;\n        break;\n      case \"banner\":\n        profile.banner = payload.banner;\n        break;\n      case \"bio\":\n        profile.bio = payload.bio;\n        break;\n      case \"nip05\":\n        profile.nip05 = payload.nip05;\n        break;\n      case \"lud06\":\n        profile.lud06 = payload.lud06;\n        break;\n      case \"lud16\":\n        profile.lud16 = payload.lud16;\n        break;\n      case \"about\":\n        profile.about = payload.about;\n        break;\n      case \"website\":\n        profile.website = payload.website;\n        break;\n      default:\n        profile[key] = payload[key];\n        break;\n    }\n  });\n  return profile;\n}\nfunction serializeProfile(profile) {\n  const payload = {};\n  for (const [key, val] of Object.entries(profile)) {\n    switch (key) {\n      case \"username\":\n      case \"name\":\n        payload.name = val;\n        break;\n      case \"displayName\":\n        payload.display_name = val;\n        break;\n      case \"image\":\n      case \"picture\":\n        payload.picture = val;\n        break;\n      case \"bio\":\n      case \"about\":\n        payload.about = val;\n        break;\n      default:\n        payload[key] = val;\n        break;\n    }\n  }\n  return JSON.stringify(payload);\n}\n\n// src/user/nip05.ts\nvar NIP05_REGEX = /^(?:([\\w.+-]+)@)?([\\w.-]+)$/;\nasync function getNip05For(ndk, fullname, _fetch = fetch, fetchOpts = {}) {\n  return await ndk.queuesNip05.add({\n    id: fullname,\n    func: async () => {\n      if (ndk.cacheAdapter && ndk.cacheAdapter.loadNip05) {\n        const profile = await ndk.cacheAdapter.loadNip05(fullname);\n        if (profile !== \"missing\") {\n          if (profile) {\n            const user = new NDKUser({\n              pubkey: profile.pubkey,\n              relayUrls: profile.relays,\n              nip46Urls: profile.nip46\n            });\n            user.ndk = ndk;\n            return user;\n          } else if (fetchOpts.cache !== \"no-cache\") {\n            return null;\n          }\n        }\n      }\n      const match = fullname.match(NIP05_REGEX);\n      if (!match) return null;\n      const [_, name = \"_\", domain] = match;\n      try {\n        const res = await _fetch(\n          `https://${domain}/.well-known/nostr.json?name=${name}`,\n          fetchOpts\n        );\n        const { names, relays, nip46 } = parseNIP05Result(await res.json());\n        const pubkey = names[name.toLowerCase()];\n        let profile = null;\n        if (pubkey) {\n          profile = { pubkey, relays: relays?.[pubkey], nip46: nip46?.[pubkey] };\n        }\n        if (ndk?.cacheAdapter && ndk.cacheAdapter.saveNip05) {\n          ndk.cacheAdapter.saveNip05(fullname, profile);\n        }\n        return profile;\n      } catch (_e) {\n        if (ndk?.cacheAdapter && ndk.cacheAdapter.saveNip05) {\n          ndk?.cacheAdapter.saveNip05(fullname, null);\n        }\n        console.error(\"Failed to fetch NIP05 for\", fullname, _e);\n        return null;\n      }\n    }\n  });\n}\nfunction parseNIP05Result(json) {\n  const result = {\n    names: {}\n  };\n  for (const [name, pubkey] of Object.entries(json.names)) {\n    if (typeof name === \"string\" && typeof pubkey === \"string\") {\n      result.names[name.toLowerCase()] = pubkey;\n    }\n  }\n  if (json.relays) {\n    result.relays = {};\n    for (const [pubkey, relays] of Object.entries(json.relays)) {\n      if (typeof pubkey === \"string\" && Array.isArray(relays)) {\n        result.relays[pubkey] = relays.filter(\n          (relay) => typeof relay === \"string\"\n        );\n      }\n    }\n  }\n  if (json.nip46) {\n    result.nip46 = {};\n    for (const [pubkey, nip46] of Object.entries(json.nip46)) {\n      if (typeof pubkey === \"string\" && Array.isArray(nip46)) {\n        result.nip46[pubkey] = nip46.filter((relay) => typeof relay === \"string\");\n      }\n    }\n  }\n  return result;\n}\n\n// src/user/index.ts\nvar NDKUser = class _NDKUser {\n  ndk;\n  profile;\n  profileEvent;\n  _npub;\n  _pubkey;\n  relayUrls = [];\n  nip46Urls = [];\n  constructor(opts) {\n    if (opts.npub) this._npub = opts.npub;\n    if (opts.hexpubkey) this._pubkey = opts.hexpubkey;\n    if (opts.pubkey) this._pubkey = opts.pubkey;\n    if (opts.relayUrls) this.relayUrls = opts.relayUrls;\n    if (opts.nip46Urls) this.nip46Urls = opts.nip46Urls;\n  }\n  get npub() {\n    if (!this._npub) {\n      if (!this._pubkey) throw new Error(\"pubkey not set\");\n      this._npub = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.npubEncode(this.pubkey);\n    }\n    return this._npub;\n  }\n  get nprofile() {\n    const relays = this.profileEvent?.onRelays?.map((r) => r.url);\n    return nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.nprofileEncode({\n      pubkey: this.pubkey,\n      relays\n    });\n  }\n  set npub(npub) {\n    this._npub = npub;\n  }\n  /**\n   * Get the user's pubkey\n   * @returns {string} The user's pubkey\n   */\n  get pubkey() {\n    if (!this._pubkey) {\n      if (!this._npub) throw new Error(\"npub not set\");\n      this._pubkey = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.decode(this.npub).data;\n    }\n    return this._pubkey;\n  }\n  /**\n   * Set the user's pubkey\n   * @param pubkey {string} The user's pubkey\n   */\n  set pubkey(pubkey) {\n    this._pubkey = pubkey;\n  }\n  /**\n   * Equivalent to NDKEvent.filters().\n   * @returns {NDKFilter}\n   */\n  filter() {\n    return { \"#p\": [this.pubkey] };\n  }\n  /**\n   * Gets NIP-57 and NIP-61 information that this user has signaled\n   *\n   * @param getAll {boolean} Whether to get all zap info or just the first one\n   */\n  async getZapInfo(timeoutMs) {\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    const promiseWithTimeout = async (promise) => {\n      if (!timeoutMs) return promise;\n      try {\n        return await Promise.race([\n          promise,\n          new Promise((_, reject) => setTimeout(() => reject(), timeoutMs))\n        ]);\n      } catch {\n        return void 0;\n      }\n    };\n    const [userProfile, mintListEvent] = await Promise.all([\n      promiseWithTimeout(this.fetchProfile()),\n      promiseWithTimeout(this.ndk.fetchEvent({ kinds: [10019 /* CashuMintList */], authors: [this.pubkey] }))\n    ]);\n    const res = /* @__PURE__ */ new Map();\n    if (mintListEvent) {\n      const mintList = NDKCashuMintList.from(mintListEvent);\n      if (mintList.mints.length > 0) {\n        res.set(\"nip61\", {\n          mints: mintList.mints,\n          relays: mintList.relays,\n          p2pk: mintList.p2pk\n        });\n      }\n    }\n    if (userProfile) {\n      const { lud06, lud16 } = userProfile;\n      res.set(\"nip57\", { lud06, lud16 });\n    }\n    return res;\n  }\n  /**\n   * Instantiate an NDKUser from a NIP-05 string\n   * @param nip05Id {string} The user's NIP-05\n   * @param ndk {NDK} An NDK instance\n   * @param skipCache {boolean} Whether to skip the cache or not\n   * @returns {NDKUser | undefined} An NDKUser if one is found for the given NIP-05, undefined otherwise.\n   */\n  static async fromNip05(nip05Id, ndk, skipCache = false) {\n    if (!ndk) throw new Error(\"No NDK instance found\");\n    const opts = {};\n    if (skipCache) opts.cache = \"no-cache\";\n    const profile = await getNip05For(ndk, nip05Id, ndk?.httpFetch, opts);\n    if (profile) {\n      const user = new _NDKUser({\n        pubkey: profile.pubkey,\n        relayUrls: profile.relays,\n        nip46Urls: profile.nip46\n      });\n      user.ndk = ndk;\n      return user;\n    }\n  }\n  /**\n   * Fetch a user's profile\n   * @param opts {NDKSubscriptionOptions} A set of NDKSubscriptionOptions\n   * @param storeProfileEvent {boolean} Whether to store the profile event or not\n   * @returns User Profile\n   */\n  async fetchProfile(opts, storeProfileEvent = false) {\n    if (!this.ndk) throw new Error(\"NDK not set\");\n    if (!this.profile) this.profile = {};\n    let setMetadataEvent = null;\n    if (this.ndk.cacheAdapter && this.ndk.cacheAdapter.fetchProfile && opts?.cacheUsage !== \"ONLY_RELAY\" /* ONLY_RELAY */) {\n      const profile = await this.ndk.cacheAdapter.fetchProfile(this.pubkey);\n      if (profile) {\n        this.profile = profile;\n        return profile;\n      }\n    }\n    if (!opts && // if no options have been set\n    this.ndk.cacheAdapter && // and we have a cache\n    this.ndk.cacheAdapter.locking) {\n      setMetadataEvent = await this.ndk.fetchEvent(\n        {\n          kinds: [0],\n          authors: [this.pubkey]\n        },\n        {\n          cacheUsage: \"ONLY_CACHE\" /* ONLY_CACHE */,\n          closeOnEose: true,\n          groupable: false\n        }\n      );\n      opts = {\n        cacheUsage: \"ONLY_RELAY\" /* ONLY_RELAY */,\n        closeOnEose: true,\n        groupable: true,\n        groupableDelay: 250\n      };\n    }\n    if (!setMetadataEvent) {\n      setMetadataEvent = await this.ndk.fetchEvent(\n        {\n          kinds: [0],\n          authors: [this.pubkey]\n        },\n        opts\n      );\n    }\n    if (!setMetadataEvent) return null;\n    this.profile = profileFromEvent(setMetadataEvent);\n    if (storeProfileEvent) {\n      this.profile.profileEvent = JSON.stringify(setMetadataEvent);\n    }\n    if (this.profile && this.ndk.cacheAdapter && this.ndk.cacheAdapter.saveProfile) {\n      this.ndk.cacheAdapter.saveProfile(this.pubkey, this.profile);\n    }\n    return this.profile;\n  }\n  /**\n   * Returns a set of users that this user follows.\n   * \n   * @deprecated Use followSet instead\n   */\n  follows = follows.bind(this);\n  /**\n   * Returns a set of pubkeys that this user follows.\n   * \n   * @param opts - NDKSubscriptionOptions\n   * @param outbox - boolean\n   * @param kind - number\n   */\n  async followSet(opts, outbox, kind = 3 /* Contacts */) {\n    const follows2 = await this.follows(opts, outbox, kind);\n    return new Set(Array.from(follows2).map((f) => f.pubkey));\n  }\n  /** @deprecated Use referenceTags instead. */\n  /**\n   * Get the tag that can be used to reference this user in an event\n   * @returns {NDKTag} an NDKTag\n   */\n  tagReference() {\n    return [\"p\", this.pubkey];\n  }\n  /**\n   * Get the tags that can be used to reference this user in an event\n   * @returns {NDKTag[]} an array of NDKTag\n   */\n  referenceTags(marker) {\n    const tag = [[\"p\", this.pubkey]];\n    if (!marker) return tag;\n    tag[0].push(\"\", marker);\n    return tag;\n  }\n  /**\n   * Publishes the current profile.\n   */\n  async publish() {\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    if (!this.profile) throw new Error(\"No profile available\");\n    this.ndk.assertSigner();\n    const event = new NDKEvent(this.ndk, {\n      kind: 0,\n      content: serializeProfile(this.profile)\n    });\n    await event.publish();\n  }\n  /**\n   * Add a follow to this user's contact list\n   *\n   * @param newFollow {NDKUser} The user to follow\n   * @param currentFollowList {Set<NDKUser>} The current follow list\n   * @param kind {NDKKind} The kind to use for this contact list (defaults to `3`)\n   * @returns {Promise<boolean>} True if the follow was added, false if the follow already exists\n   */\n  async follow(newFollow, currentFollowList, kind = 3 /* Contacts */) {\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    this.ndk.assertSigner();\n    if (!currentFollowList) {\n      currentFollowList = await this.follows(void 0, void 0, kind);\n    }\n    if (currentFollowList.has(newFollow)) {\n      return false;\n    }\n    currentFollowList.add(newFollow);\n    const event = new NDKEvent(this.ndk, { kind });\n    for (const follow of currentFollowList) {\n      event.tag(follow);\n    }\n    await event.publish();\n    return true;\n  }\n  /**\n   * Remove a follow from this user's contact list\n   *\n   * @param user {NDKUser} The user to unfollow\n   * @param currentFollowList {Set<NDKUser>} The current follow list\n   * @param kind {NDKKind} The kind to use for this contact list (defaults to `3`)\n   * @returns The relays were the follow list was published or false if the user wasn't found\n   */\n  async unfollow(user, currentFollowList, kind = 3 /* Contacts */) {\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    this.ndk.assertSigner();\n    if (!currentFollowList) {\n      currentFollowList = await this.follows(void 0, void 0, kind);\n    }\n    const newUserFollowList = /* @__PURE__ */ new Set();\n    let foundUser = false;\n    for (const follow of currentFollowList) {\n      if (follow.pubkey !== user.pubkey) {\n        newUserFollowList.add(follow);\n      } else {\n        foundUser = true;\n      }\n    }\n    if (!foundUser) return false;\n    const event = new NDKEvent(this.ndk, { kind });\n    for (const follow of newUserFollowList) {\n      event.tag(follow);\n    }\n    return await event.publish();\n  }\n  /**\n   * Validate a user's NIP-05 identifier (usually fetched from their kind:0 profile data)\n   *\n   * @param nip05Id The NIP-05 string to validate\n   * @returns {Promise<boolean | null>} True if the NIP-05 is found and matches this user's pubkey,\n   * False if the NIP-05 is found but doesn't match this user's pubkey,\n   * null if the NIP-05 isn't found on the domain or we're unable to verify (because of network issues, etc.)\n   */\n  async validateNip05(nip05Id) {\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    const profilePointer = await getNip05For(this.ndk, nip05Id);\n    if (profilePointer === null) return null;\n    return profilePointer.pubkey === this.pubkey;\n  }\n};\n\n// src/user/pin.ts\nasync function pinEvent(user, event, pinEvent2, publish) {\n  const kind = 10001 /* PinList */;\n  if (!user.ndk) throw new Error(\"No NDK instance found\");\n  user.ndk.assertSigner();\n  if (!pinEvent2) {\n    const events = await user.ndk.fetchEvents(\n      { kinds: [kind], authors: [user.pubkey] },\n      { cacheUsage: \"ONLY_RELAY\" /* ONLY_RELAY */ }\n    );\n    if (events.size > 0) {\n      pinEvent2 = lists_default.from(Array.from(events)[0]);\n    } else {\n      pinEvent2 = new NDKEvent(user.ndk, {\n        kind\n      });\n    }\n  }\n  pinEvent2.tag(event);\n  if (publish) {\n    await pinEvent2.publish();\n  }\n  return pinEvent2;\n}\n\n// src/events/kinds/classified.ts\nvar NDKClassified = class _NDKClassified extends NDKEvent {\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 30402 /* Classified */;\n  }\n  /**\n   * Creates a NDKClassified from an existing NDKEvent.\n   *\n   * @param event NDKEvent to create the NDKClassified from.\n   * @returns NDKClassified\n   */\n  static from(event) {\n    return new _NDKClassified(event.ndk, event);\n  }\n  /**\n   * Getter for the classified title.\n   *\n   * @returns {string | undefined} - The classified title if available, otherwise undefined.\n   */\n  get title() {\n    return this.tagValue(\"title\");\n  }\n  /**\n   * Setter for the classified title.\n   *\n   * @param {string | undefined} title - The title to set for the classified.\n   */\n  set title(title) {\n    this.removeTag(\"title\");\n    if (title) this.tags.push([\"title\", title]);\n  }\n  /**\n   * Getter for the classified summary.\n   *\n   * @returns {string | undefined} - The classified summary if available, otherwise undefined.\n   */\n  get summary() {\n    return this.tagValue(\"summary\");\n  }\n  /**\n   * Setter for the classified summary.\n   *\n   * @param {string | undefined} summary - The summary to set for the classified.\n   */\n  set summary(summary) {\n    this.removeTag(\"summary\");\n    if (summary) this.tags.push([\"summary\", summary]);\n  }\n  /**\n   * Getter for the classified's publication timestamp.\n   *\n   * @returns {number | undefined} - The Unix timestamp of when the classified was published or undefined.\n   */\n  get published_at() {\n    const tag = this.tagValue(\"published_at\");\n    if (tag) {\n      return parseInt(tag);\n    }\n    return void 0;\n  }\n  /**\n   * Setter for the classified's publication timestamp.\n   *\n   * @param {number | undefined} timestamp - The Unix timestamp to set for the classified's publication date.\n   */\n  set published_at(timestamp) {\n    this.removeTag(\"published_at\");\n    if (timestamp !== void 0) {\n      this.tags.push([\"published_at\", timestamp.toString()]);\n    }\n  }\n  /**\n   * Getter for the classified location.\n   *\n   * @returns {string | undefined} - The classified location if available, otherwise undefined.\n   */\n  get location() {\n    return this.tagValue(\"location\");\n  }\n  /**\n   * Setter for the classified location.\n   *\n   * @param {string | undefined} location - The location to set for the classified.\n   */\n  set location(location) {\n    this.removeTag(\"location\");\n    if (location) this.tags.push([\"location\", location]);\n  }\n  /**\n   * Getter for the classified price.\n   *\n   * @returns {NDKClassifiedPriceTag | undefined} - The classified price if available, otherwise undefined.\n   */\n  get price() {\n    const priceTag = this.tags.find((tag) => tag[0] === \"price\");\n    if (priceTag) {\n      return {\n        amount: parseFloat(priceTag[1]),\n        currency: priceTag[2],\n        frequency: priceTag[3]\n      };\n    } else {\n      return void 0;\n    }\n  }\n  /**\n   * Setter for the classified price.\n   *\n   * @param price - The price to set for the classified.\n   */\n  set price(priceTag) {\n    if (typeof priceTag === \"string\") {\n      priceTag = {\n        amount: parseFloat(priceTag)\n      };\n    }\n    if (priceTag?.amount) {\n      const tag = [\"price\", priceTag.amount.toString()];\n      if (priceTag.currency) tag.push(priceTag.currency);\n      if (priceTag.frequency) tag.push(priceTag.frequency);\n      this.tags.push(tag);\n    } else {\n      this.removeTag(\"price\");\n    }\n  }\n  /**\n   * Generates content tags for the classified.\n   *\n   * This method first checks and sets the publication date if not available,\n   * and then generates content tags based on the base NDKEvent class.\n   *\n   * @returns {ContentTag} - The generated content tags.\n   */\n  async generateTags() {\n    super.generateTags();\n    if (!this.published_at) {\n      this.published_at = this.created_at;\n    }\n    return super.generateTags();\n  }\n};\n\n// src/events/kinds/drafts.ts\nvar NDKDraft = class _NDKDraft extends NDKEvent {\n  _event;\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 31234 /* Draft */;\n  }\n  static from(event) {\n    return new _NDKDraft(event.ndk, event);\n  }\n  /**\n   * Sets an identifier (i.e. d-tag)\n   */\n  set identifier(id) {\n    this.removeTag(\"d\");\n    this.tags.push([\"d\", id]);\n  }\n  get identifier() {\n    return this.dTag;\n  }\n  /**\n   * Event that is to be saved.\n   */\n  set event(e) {\n    if (e instanceof NDKEvent) this._event = e.rawEvent();\n    else this._event = e;\n    this.prepareEvent();\n  }\n  /**\n   * Gets the event.\n   * @param param0\n   * @returns NDKEvent of the draft event or null if the draft event has been deleted (emptied).\n   */\n  async getEvent(signer) {\n    if (this._event) return new NDKEvent(this.ndk, this._event);\n    signer ??= this.ndk?.signer;\n    if (!signer) throw new Error(\"No signer available\");\n    const user = await signer.user();\n    if (this.content && this.content.length > 0) {\n      try {\n        await this.decrypt(user, signer);\n        const payload = JSON.parse(this.content);\n        this._event = payload;\n        return new NDKEvent(this.ndk, payload);\n      } catch (e) {\n        console.error(e);\n        return void 0;\n      }\n    } else {\n      return null;\n    }\n  }\n  prepareEvent() {\n    if (!this._event) throw new Error(\"No event has been provided\");\n    this.removeTag(\"k\");\n    if (this._event.kind) this.tags.push([\"k\", this._event.kind.toString()]);\n    this.content = JSON.stringify(this._event);\n  }\n  /**\n   * Generates draft event.\n   *\n   * @param signer: Optional signer to encrypt with\n   * @param publish: Whether to publish, optionally specifying relaySet to publish to\n   */\n  async save({\n    signer,\n    publish,\n    relaySet\n  }) {\n    signer ??= this.ndk?.signer;\n    if (!signer) throw new Error(\"No signer available\");\n    const user = await signer.user();\n    await this.encrypt(user, signer);\n    if (publish === false) return;\n    return this.publish(relaySet);\n  }\n};\n\n// src/events/kinds/dvm/feedback.ts\nvar NDKDvmJobFeedbackStatus = /* @__PURE__ */ ((NDKDvmJobFeedbackStatus2) => {\n  NDKDvmJobFeedbackStatus2[\"Processing\"] = \"processing\";\n  NDKDvmJobFeedbackStatus2[\"Success\"] = \"success\";\n  NDKDvmJobFeedbackStatus2[\"Scheduled\"] = \"scheduled\";\n  NDKDvmJobFeedbackStatus2[\"PayReq\"] = \"payment_required\";\n  return NDKDvmJobFeedbackStatus2;\n})(NDKDvmJobFeedbackStatus || {});\nvar NDKDVMJobFeedback = class _NDKDVMJobFeedback extends NDKEvent {\n  constructor(ndk, event) {\n    super(ndk, event);\n    this.kind ??= 7e3 /* DVMJobFeedback */;\n  }\n  static async from(event) {\n    const e = new _NDKDVMJobFeedback(event.ndk, event.rawEvent());\n    if (e.encrypted) await e.dvmDecrypt();\n    return e;\n  }\n  get status() {\n    return this.tagValue(\"status\");\n  }\n  set status(status) {\n    this.removeTag(\"status\");\n    if (status !== void 0) {\n      this.tags.push([\"status\", status]);\n    }\n  }\n  get encrypted() {\n    return !!this.getMatchingTags(\"encrypted\")[0];\n  }\n  async dvmDecrypt() {\n    await this.decrypt();\n    const decryptedContent = JSON.parse(this.content);\n    this.tags.push(...decryptedContent);\n  }\n};\n\n// src/events/kinds/dvm/request.ts\nvar NDKDVMRequest = class _NDKDVMRequest extends NDKEvent {\n  constructor(ndk, event) {\n    super(ndk, event);\n  }\n  static from(event) {\n    return new _NDKDVMRequest(event.ndk, event.rawEvent());\n  }\n  set bid(msatAmount) {\n    if (msatAmount === void 0) {\n      this.removeTag(\"bid\");\n    } else {\n      this.tags.push([\"bid\", msatAmount.toString()]);\n    }\n  }\n  get bid() {\n    const v = this.tagValue(\"bid\");\n    if (v === void 0) return void 0;\n    return parseInt(v);\n  }\n  /**\n   * Adds a new input to the job\n   * @param args The arguments to the input\n   */\n  addInput(...args) {\n    this.tags.push([\"i\", ...args]);\n  }\n  /**\n   * Adds a new parameter to the job\n   */\n  addParam(...args) {\n    this.tags.push([\"param\", ...args]);\n  }\n  set output(output) {\n    if (output === void 0) {\n      this.removeTag(\"output\");\n    } else {\n      if (typeof output === \"string\") output = [output];\n      this.tags.push([\"output\", ...output]);\n    }\n  }\n  get output() {\n    const outputTag = this.getMatchingTags(\"output\")[0];\n    return outputTag ? outputTag.slice(1) : void 0;\n  }\n  get params() {\n    const paramTags = this.getMatchingTags(\"param\");\n    return paramTags.map((t) => t.slice(1));\n  }\n  getParam(name) {\n    const paramTag = this.getMatchingTags(\"param\").find((t) => t[1] === name);\n    return paramTag ? paramTag[2] : void 0;\n  }\n  createFeedback(status) {\n    const feedback = new NDKDVMJobFeedback(this.ndk);\n    feedback.tag(this, \"job\");\n    feedback.status = status;\n    return feedback;\n  }\n  /**\n   * Enables job encryption for this event\n   * @param dvm DVM that will receive the event\n   * @param signer Signer to use for encryption\n   */\n  async encryption(dvm, signer) {\n    const dvmTags = [\"i\", \"param\", \"output\", \"relays\", \"bid\"];\n    const tags = this.tags.filter((t) => dvmTags.includes(t[0]));\n    this.tags = this.tags.filter((t) => !dvmTags.includes(t[0]));\n    this.content = JSON.stringify(tags);\n    this.tag(dvm);\n    this.tags.push([\"encrypted\"]);\n    await this.encrypt(dvm, signer);\n  }\n  /**\n   * Sets the DVM that will receive the event\n   */\n  set dvm(dvm) {\n    this.removeTag(\"p\");\n    if (dvm) this.tag(dvm);\n  }\n};\n\n// src/events/kinds/dvm/NDKTranscriptionDVM.ts\nvar NDKTranscriptionDVM = class _NDKTranscriptionDVM extends NDKDVMRequest {\n  constructor(ndk, event) {\n    super(ndk, event);\n    this.kind = 5e3 /* DVMReqTextExtraction */;\n  }\n  static from(event) {\n    return new _NDKTranscriptionDVM(event.ndk, event.rawEvent());\n  }\n  /**\n   * Returns the original source of the transcription\n   */\n  get url() {\n    const inputTags = this.getMatchingTags(\"i\");\n    if (inputTags.length !== 1) {\n      return void 0;\n    }\n    return inputTags[0][1];\n  }\n  /**\n   * Getter for the title tag\n   */\n  get title() {\n    return this.tagValue(\"title\");\n  }\n  /**\n   * Setter for the title tag\n   */\n  set title(value) {\n    this.removeTag(\"title\");\n    if (value) {\n      this.tags.push([\"title\", value]);\n    }\n  }\n  /**\n   * Getter for the image tag\n   */\n  get image() {\n    return this.tagValue(\"image\");\n  }\n  /**\n   * Setter for the image tag\n   */\n  set image(value) {\n    this.removeTag(\"image\");\n    if (value) {\n      this.tags.push([\"image\", value]);\n    }\n  }\n};\n\n// src/events/kinds/dvm/result.ts\nvar NDKDVMJobResult = class _NDKDVMJobResult extends NDKEvent {\n  constructor(ndk, event) {\n    super(ndk, event);\n  }\n  static from(event) {\n    return new _NDKDVMJobResult(event.ndk, event.rawEvent());\n  }\n  setAmount(msat, invoice) {\n    this.removeTag(\"amount\");\n    const tag = [\"amount\", msat.toString()];\n    if (invoice) tag.push(invoice);\n    this.tags.push(tag);\n  }\n  set result(result) {\n    if (result === void 0) {\n      this.content = \"\";\n    } else {\n      this.content = result;\n    }\n  }\n  get result() {\n    if (this.content === \"\") {\n      return void 0;\n    }\n    return this.content;\n  }\n  set status(status) {\n    this.removeTag(\"status\");\n    if (status !== void 0) {\n      this.tags.push([\"status\", status]);\n    }\n  }\n  get status() {\n    return this.tagValue(\"status\");\n  }\n  get jobRequestId() {\n    for (const eTag of this.getMatchingTags(\"e\")) {\n      if (eTag[2] === \"job\") return eTag[1];\n    }\n    if (this.jobRequest) return this.jobRequest.id;\n    return this.tagValue(\"e\");\n  }\n  set jobRequest(event) {\n    this.removeTag(\"request\");\n    if (event) {\n      this.kind = event.kind + 1e3;\n      this.tags.push([\"request\", JSON.stringify(event.rawEvent())]);\n      this.tag(event);\n    }\n  }\n  get jobRequest() {\n    const tag = this.tagValue(\"request\");\n    if (tag === void 0) {\n      return void 0;\n    }\n    return new NDKEvent(this.ndk, JSON.parse(tag));\n  }\n};\n\n// src/events/kinds/cashu/tx.ts\nvar MARKERS = {\n  REDEEMED: \"redeemed\",\n  CREATED: \"created\",\n  DESTROYED: \"destroyed\",\n  RESERVED: \"reserved\"\n};\nvar NDKCashuWalletTx = class _NDKCashuWalletTx extends NDKEvent {\n  static MARKERS = MARKERS;\n  static kind = 7376 /* CashuWalletTx */;\n  static kinds = [7376 /* CashuWalletTx */];\n  constructor(ndk, event) {\n    super(ndk, event);\n    this.kind ??= 7376 /* CashuWalletTx */;\n  }\n  static async from(event) {\n    const walletChange = new _NDKCashuWalletTx(event.ndk, event);\n    const prevContent = walletChange.content;\n    try {\n      await walletChange.decrypt();\n    } catch (e) {\n      walletChange.content ??= prevContent;\n    }\n    try {\n      const contentTags = JSON.parse(walletChange.content);\n      walletChange.tags = [...contentTags, ...walletChange.tags];\n    } catch (e) {\n      return;\n    }\n    return walletChange;\n  }\n  set direction(direction) {\n    this.removeTag(\"direction\");\n    if (direction) this.tags.push([\"direction\", direction]);\n  }\n  get direction() {\n    return this.tagValue(\"direction\");\n  }\n  set amount(amount) {\n    this.removeTag(\"amount\");\n    this.tags.push([\"amount\", amount.toString()]);\n  }\n  get amount() {\n    return this.tagValue(\"amount\");\n  }\n  set fee(fee) {\n    this.removeTag(\"fee\");\n    this.tags.push([\"fee\", fee.toString()]);\n  }\n  get fee() {\n    return this.tagValue(\"fee\");\n  }\n  set unit(unit) {\n    this.removeTag(\"unit\");\n    if (unit) this.tags.push([\"unit\", unit.toString()]);\n  }\n  get unit() {\n    return this.tagValue(\"unit\");\n  }\n  set description(description) {\n    this.removeTag(\"description\");\n    if (description) this.tags.push([\"description\", description.toString()]);\n  }\n  get description() {\n    return this.tagValue(\"description\");\n  }\n  set mint(mint) {\n    this.removeTag(\"mint\");\n    if (mint) this.tags.push([\"mint\", mint.toString()]);\n  }\n  get mint() {\n    return this.tagValue(\"mint\");\n  }\n  /**\n   * Tags tokens that were created in this history event\n   */\n  set destroyedTokens(events) {\n    for (const event of events) {\n      this.tags.push(event.tagReference(MARKERS.DESTROYED));\n    }\n  }\n  set destroyedTokenIds(ids) {\n    for (const id of ids) {\n      this.tags.push([\"e\", id, \"\", MARKERS.DESTROYED]);\n    }\n  }\n  /**\n   * Tags tokens that were created in this history event\n   */\n  set createdTokens(events) {\n    for (const event of events) {\n      this.tags.push(event.tagReference(MARKERS.CREATED));\n    }\n  }\n  set reservedTokens(events) {\n    for (const event of events) {\n      this.tags.push(event.tagReference(MARKERS.RESERVED));\n    }\n  }\n  addRedeemedNutzap(event) {\n    this.tag(event, MARKERS.REDEEMED);\n  }\n  async toNostrEvent(pubkey) {\n    const encryptedTags = [];\n    const unencryptedTags = [];\n    for (const tag of this.tags) {\n      if (!this.shouldEncryptTag(tag)) {\n        unencryptedTags.push(tag);\n      } else {\n        encryptedTags.push(tag);\n      }\n    }\n    this.tags = unencryptedTags.filter((t) => t[0] !== \"client\");\n    this.content = JSON.stringify(encryptedTags);\n    const user = await this.ndk.signer.user();\n    await this.encrypt(user, void 0, \"nip44\");\n    return super.toNostrEvent(pubkey);\n  }\n  /**\n   * Whether this entry includes a redemption of a Nutzap\n   */\n  get hasNutzapRedemption() {\n    return this.getMatchingTags(\"e\", MARKERS.REDEEMED).length > 0;\n  }\n  shouldEncryptTag(tag) {\n    const unencryptedTagNames = [\"client\"];\n    if (unencryptedTagNames.includes(tag[0])) {\n      return false;\n    }\n    if (tag[0] === \"e\" && tag[3] === MARKERS.REDEEMED) {\n      return false;\n    }\n    if (tag[0] === \"p\") return false;\n    return true;\n  }\n};\n\n// src/events/kinds/NDKRelayList.ts\nvar READ_MARKER = \"read\";\nvar WRITE_MARKER = \"write\";\nvar NDKRelayList = class _NDKRelayList extends NDKEvent {\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 10002 /* RelayList */;\n  }\n  static from(ndkEvent) {\n    return new _NDKRelayList(ndkEvent.ndk, ndkEvent.rawEvent());\n  }\n  get readRelayUrls() {\n    return this.tags.filter((tag) => tag[0] === \"r\" || tag[0] === \"relay\").filter((tag) => !tag[2] || tag[2] && tag[2] === READ_MARKER).map((tag) => tryNormalizeRelayUrl(tag[1])).filter((url) => !!url);\n  }\n  set readRelayUrls(relays) {\n    for (const relay of relays) {\n      this.tags.push([\"r\", relay, READ_MARKER]);\n    }\n  }\n  get writeRelayUrls() {\n    return this.tags.filter((tag) => tag[0] === \"r\" || tag[0] === \"relay\").filter((tag) => !tag[2] || tag[2] && tag[2] === WRITE_MARKER).map((tag) => tryNormalizeRelayUrl(tag[1])).filter((url) => !!url);\n  }\n  set writeRelayUrls(relays) {\n    for (const relay of relays) {\n      this.tags.push([\"r\", relay, WRITE_MARKER]);\n    }\n  }\n  get bothRelayUrls() {\n    return this.tags.filter((tag) => tag[0] === \"r\" || tag[0] === \"relay\").filter((tag) => !tag[2]).map((tag) => tag[1]);\n  }\n  set bothRelayUrls(relays) {\n    for (const relay of relays) {\n      this.tags.push([\"r\", relay]);\n    }\n  }\n  get relays() {\n    return this.tags.filter((tag) => tag[0] === \"r\" || tag[0] === \"relay\").map((tag) => tag[1]);\n  }\n  /**\n   * Provides a relaySet for the relays in this list.\n   */\n  get relaySet() {\n    if (!this.ndk) throw new Error(\"NDKRelayList has no NDK instance\");\n    return new NDKRelaySet(\n      new Set(this.relays.map((u) => this.ndk.pool.getRelay(u))),\n      this.ndk\n    );\n  }\n};\nfunction relayListFromKind3(ndk, contactList) {\n  try {\n    const content = JSON.parse(contactList.content);\n    const relayList = new NDKRelayList(ndk);\n    const readRelays = /* @__PURE__ */ new Set();\n    const writeRelays = /* @__PURE__ */ new Set();\n    for (let [key, config] of Object.entries(content)) {\n      try {\n        key = normalizeRelayUrl(key);\n      } catch {\n        continue;\n      }\n      if (!config) {\n        readRelays.add(key);\n        writeRelays.add(key);\n      } else {\n        const relayConfig = config;\n        if (relayConfig.write) writeRelays.add(key);\n        if (relayConfig.read) readRelays.add(key);\n      }\n    }\n    relayList.readRelayUrls = Array.from(readRelays);\n    relayList.writeRelayUrls = Array.from(writeRelays);\n    return relayList;\n  } catch {\n  }\n  return void 0;\n}\n\n// src/events/kinds/nip89/NDKAppHandler.ts\nvar NDKAppHandlerEvent = class _NDKAppHandlerEvent extends NDKEvent {\n  profile;\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 31990 /* AppHandler */;\n  }\n  static from(ndkEvent) {\n    return new _NDKAppHandlerEvent(ndkEvent.ndk, ndkEvent.rawEvent());\n  }\n  /**\n   * Fetches app handler information\n   * If no app information is available on the kind:31990,\n   * we fetch the event's author's profile and return that instead.\n   */\n  async fetchProfile() {\n    if (this.profile === void 0 && this.content.length > 0) {\n      try {\n        const profile = JSON.parse(this.content);\n        if (profile && profile.name) {\n          return profile;\n        } else {\n          this.profile = null;\n        }\n      } catch (e) {\n        this.profile = null;\n      }\n    }\n    return new Promise((resolve, reject) => {\n      const author = this.author;\n      author.fetchProfile().then(() => {\n        resolve(author.profile);\n      }).catch(reject);\n    });\n  }\n};\n\n// src/events/kinds/repost.ts\nvar NDKRepost = class _NDKRepost extends NDKEvent {\n  _repostedEvents;\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n  }\n  static from(event) {\n    return new _NDKRepost(event.ndk, event.rawEvent());\n  }\n  /**\n   * Returns all reposted events by the current event.\n   *\n   * @param klass Optional class to convert the events to.\n   * @returns\n   */\n  async repostedEvents(klass, opts) {\n    const items = [];\n    if (!this.ndk) throw new Error(\"NDK instance not set\");\n    if (this._repostedEvents !== void 0) return this._repostedEvents;\n    for (const eventId of this.repostedEventIds()) {\n      const filter = filterForId(eventId);\n      const event = await this.ndk.fetchEvent(filter, opts);\n      if (event) {\n        items.push(klass ? klass.from(event) : event);\n      }\n    }\n    return items;\n  }\n  /**\n   * Returns the reposted event IDs.\n   */\n  repostedEventIds() {\n    return this.tags.filter((t) => t[0] === \"e\" || t[0] === \"a\").map((t) => t[1]);\n  }\n};\nfunction filterForId(id) {\n  if (id.match(/:/)) {\n    const [kind, pubkey, identifier] = id.split(\":\");\n    return {\n      kinds: [parseInt(kind)],\n      authors: [pubkey],\n      \"#d\": [identifier]\n    };\n  } else {\n    return { ids: [id] };\n  }\n}\n\n// src/events/kinds/subscriptions/receipt.ts\n\nvar NDKSubscriptionReceipt = class _NDKSubscriptionReceipt extends NDKEvent {\n  debug;\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 7003 /* SubscriptionReceipt */;\n    this.debug = ndk?.debug.extend(\"subscription-start\") ?? debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:subscription-start\");\n  }\n  static from(event) {\n    return new _NDKSubscriptionReceipt(event.ndk, event.rawEvent());\n  }\n  /**\n   * This is the person being subscribed to\n   */\n  get recipient() {\n    const pTag = this.getMatchingTags(\"p\")?.[0];\n    if (!pTag) return void 0;\n    const user = new NDKUser({ pubkey: pTag[1] });\n    return user;\n  }\n  set recipient(user) {\n    this.removeTag(\"p\");\n    if (!user) return;\n    this.tags.push([\"p\", user.pubkey]);\n  }\n  /**\n   * This is the person subscribing\n   */\n  get subscriber() {\n    const PTag = this.getMatchingTags(\"P\")?.[0];\n    if (!PTag) return void 0;\n    const user = new NDKUser({ pubkey: PTag[1] });\n    return user;\n  }\n  set subscriber(user) {\n    this.removeTag(\"P\");\n    if (!user) return;\n    this.tags.push([\"P\", user.pubkey]);\n  }\n  set subscriptionStart(event) {\n    this.debug(`before setting subscription start: ${this.rawEvent}`);\n    this.removeTag(\"e\");\n    this.tag(event, \"subscription\", true);\n    this.debug(`after setting subscription start: ${this.rawEvent}`);\n  }\n  get tierName() {\n    const tag = this.getMatchingTags(\"tier\")?.[0];\n    return tag?.[1];\n  }\n  get isValid() {\n    const period = this.validPeriod;\n    if (!period) {\n      return false;\n    }\n    if (period.start > period.end) {\n      return false;\n    }\n    const pTags = this.getMatchingTags(\"p\");\n    const PTags = this.getMatchingTags(\"P\");\n    if (pTags.length !== 1 || PTags.length !== 1) {\n      return false;\n    }\n    return true;\n  }\n  get validPeriod() {\n    const tag = this.getMatchingTags(\"valid\")?.[0];\n    if (!tag) return void 0;\n    try {\n      return {\n        start: new Date(parseInt(tag[1]) * 1e3),\n        end: new Date(parseInt(tag[2]) * 1e3)\n      };\n    } catch {\n      return void 0;\n    }\n  }\n  set validPeriod(period) {\n    this.removeTag(\"valid\");\n    if (!period) return;\n    this.tags.push([\n      \"valid\",\n      Math.floor(period.start.getTime() / 1e3).toString(),\n      Math.floor(period.end.getTime() / 1e3).toString()\n    ]);\n  }\n  get startPeriod() {\n    return this.validPeriod?.start;\n  }\n  get endPeriod() {\n    return this.validPeriod?.end;\n  }\n  /**\n   * Whether the subscription is currently active\n   */\n  isActive(time) {\n    time ??= /* @__PURE__ */ new Date();\n    const period = this.validPeriod;\n    if (!period) return false;\n    if (time < period.start) return false;\n    if (time > period.end) return false;\n    return true;\n  }\n};\n\n// src/events/kinds/subscriptions/subscription-start.ts\n\nvar NDKSubscriptionStart = class _NDKSubscriptionStart extends NDKEvent {\n  debug;\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 7001 /* Subscribe */;\n    this.debug = ndk?.debug.extend(\"subscription-start\") ?? debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:subscription-start\");\n  }\n  static from(event) {\n    return new _NDKSubscriptionStart(event.ndk, event.rawEvent());\n  }\n  /**\n   * Recipient of the subscription. I.e. The author of this event subscribes to this user.\n   */\n  get recipient() {\n    const pTag = this.getMatchingTags(\"p\")?.[0];\n    if (!pTag) return void 0;\n    const user = new NDKUser({ pubkey: pTag[1] });\n    return user;\n  }\n  set recipient(user) {\n    this.removeTag(\"p\");\n    if (!user) return;\n    this.tags.push([\"p\", user.pubkey]);\n  }\n  /**\n   * The amount of the subscription.\n   */\n  get amount() {\n    const amountTag = this.getMatchingTags(\"amount\")?.[0];\n    if (!amountTag) return void 0;\n    return parseTagToSubscriptionAmount(amountTag);\n  }\n  set amount(amount) {\n    this.removeTag(\"amount\");\n    if (!amount) return;\n    this.tags.push(newAmount(amount.amount, amount.currency, amount.term));\n  }\n  /**\n   * The event id or NIP-33 tag id of the tier that the user is subscribing to.\n   */\n  get tierId() {\n    const eTag = this.getMatchingTags(\"e\")?.[0];\n    const aTag = this.getMatchingTags(\"a\")?.[0];\n    if (!eTag || !aTag) return void 0;\n    return eTag[1] ?? aTag[1];\n  }\n  set tier(tier) {\n    this.removeTag(\"e\");\n    this.removeTag(\"a\");\n    this.removeTag(\"event\");\n    if (!tier) return;\n    this.tag(tier);\n    this.removeTag(\"p\");\n    this.tags.push([\"p\", tier.pubkey]);\n    this.tags.push([\"event\", JSON.stringify(tier.rawEvent())]);\n  }\n  /**\n   * Fetches the tier that the user is subscribing to.\n   */\n  async fetchTier() {\n    const eventTag = this.tagValue(\"event\");\n    if (eventTag) {\n      try {\n        const parsedEvent = JSON.parse(eventTag);\n        return new NDKSubscriptionTier(this.ndk, parsedEvent);\n      } catch {\n        this.debug(\"Failed to parse event tag\");\n      }\n    }\n    const tierId = this.tierId;\n    if (!tierId) return void 0;\n    const e = await this.ndk?.fetchEvent(tierId);\n    if (!e) return void 0;\n    return NDKSubscriptionTier.from(e);\n  }\n  get isValid() {\n    if (this.getMatchingTags(\"amount\").length !== 1) {\n      this.debug(\"Invalid # of amount tag\");\n      return false;\n    }\n    if (!this.amount) {\n      this.debug(\"Invalid amount tag\");\n      return false;\n    }\n    if (this.getMatchingTags(\"p\").length !== 1) {\n      this.debug(\"Invalid # of p tag\");\n      return false;\n    }\n    if (!this.recipient) {\n      this.debug(\"Invalid p tag\");\n      return false;\n    }\n    return true;\n  }\n};\n\n// src/events/kinds/simple-group/index.ts\nvar NDKSimpleGroup = class _NDKSimpleGroup {\n  ndk;\n  groupId;\n  relaySet;\n  fetchingMetadata;\n  metadata;\n  memberList;\n  adminList;\n  constructor(ndk, relaySet, groupId) {\n    this.ndk = ndk;\n    this.groupId = groupId ?? randomId(24);\n    this.relaySet = relaySet;\n  }\n  get id() {\n    return this.groupId;\n  }\n  relayUrls() {\n    return this.relaySet.relayUrls;\n  }\n  get name() {\n    return this.metadata?.name;\n  }\n  get about() {\n    return this.metadata?.about;\n  }\n  get picture() {\n    return this.metadata?.picture;\n  }\n  get members() {\n    return this.memberList?.members ?? [];\n  }\n  get admins() {\n    return this.adminList?.members ?? [];\n  }\n  async getMetadata() {\n    await this.ensureMetadataEvent();\n    return this.metadata;\n  }\n  /**\n   * Creates the group by publishing a kind:9007 event.\n   * @param signer\n   * @returns\n   */\n  async createGroup(signer) {\n    signer ??= this.ndk.signer;\n    if (!signer) throw new Error(\"No signer available\");\n    const user = await signer.user();\n    if (!user) throw new Error(\"No user available\");\n    const event = new NDKEvent(this.ndk);\n    event.kind = 9007 /* GroupAdminCreateGroup */;\n    event.tags.push([\"h\", this.groupId]);\n    await event.sign(signer);\n    return event.publish(this.relaySet);\n  }\n  async setMetadata({\n    name,\n    about,\n    picture\n  }) {\n    const event = new NDKEvent(this.ndk);\n    event.kind = 9002 /* GroupAdminEditMetadata */;\n    event.tags.push([\"h\", this.groupId]);\n    if (name) event.tags.push([\"name\", name]);\n    if (about) event.tags.push([\"about\", about]);\n    if (picture) event.tags.push([\"picture\", picture]);\n    await event.sign();\n    return event.publish(this.relaySet);\n  }\n  /**\n   * Adds a user to the group using a kind:9000 event\n   * @param user user to add\n   * @param opts options\n   */\n  async addUser(user) {\n    const addUserEvent = _NDKSimpleGroup.generateAddUserEvent(user.pubkey, this.groupId);\n    addUserEvent.ndk = this.ndk;\n    return addUserEvent;\n  }\n  async getMemberListEvent() {\n    const memberList = await this.ndk.fetchEvent(\n      {\n        kinds: [39002 /* GroupMembers */],\n        \"#d\": [this.groupId]\n      },\n      void 0,\n      this.relaySet\n    );\n    if (!memberList) return null;\n    return NDKSimpleGroupMemberList.from(memberList);\n  }\n  /**\n   * Gets a list of users that belong to this group\n   */\n  async getMembers() {\n    const members = [];\n    const memberPubkeys = /* @__PURE__ */ new Set();\n    const memberListEvent = await this.getMemberListEvent();\n    if (!memberListEvent) return [];\n    for (const pTag of memberListEvent.getMatchingTags(\"p\")) {\n      const pubkey = pTag[1];\n      if (memberPubkeys.has(pubkey)) continue;\n      memberPubkeys.add(pubkey);\n      try {\n        members.push(this.ndk.getUser({ pubkey }));\n      } catch {\n      }\n    }\n    return members;\n  }\n  /**\n   * Generates an event that lists the members of a group.\n   * @param groupId\n   * @returns\n   */\n  static generateUserListEvent(groupId) {\n    const event = new NDKEvent(void 0, {\n      kind: 39002 /* GroupMembers */,\n      tags: [\n        [\"h\", groupId],\n        [\"alt\", \"Group Member List\"]\n      ]\n    });\n    return event;\n  }\n  /**\n   * Generates an event that adds a user to a group.\n   * @param userPubkey pubkey of the user to add\n   * @param groupId group to add the user to\n   * @returns\n   */\n  static generateAddUserEvent(userPubkey, groupId) {\n    const event = new NDKEvent(void 0, {\n      kind: 9e3 /* GroupAdminAddUser */,\n      tags: [[\"h\", groupId]]\n    });\n    event.tags.push([\"p\", userPubkey]);\n    return event;\n  }\n  async requestToJoin(pubkey, content) {\n    const event = new NDKEvent(this.ndk, {\n      kind: 9021 /* GroupAdminRequestJoin */,\n      content: content ?? \"\",\n      tags: [[\"h\", this.groupId]]\n    });\n    return event.publish(this.relaySet);\n  }\n  /**\n   * Makes sure that a metadata event exists locally\n   */\n  async ensureMetadataEvent() {\n    if (this.metadata) return;\n    if (this.fetchingMetadata) return this.fetchingMetadata;\n    this.fetchingMetadata = this.ndk.fetchEvent(\n      {\n        kinds: [39e3 /* GroupMetadata */],\n        \"#d\": [this.groupId]\n      },\n      void 0,\n      this.relaySet\n    ).then((event) => {\n      if (event) {\n        this.metadata = NDKSimpleGroupMetadata.from(event);\n      } else {\n        this.metadata = new NDKSimpleGroupMetadata(this.ndk);\n        this.metadata.dTag = this.groupId;\n      }\n    }).finally(() => {\n      this.fetchingMetadata = void 0;\n    }).catch(() => {\n      throw new Error(\"Failed to fetch metadata for group \" + this.groupId);\n    });\n    return this.fetchingMetadata;\n  }\n};\nfunction randomId(length) {\n  const chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n  const charsLength = chars.length;\n  let result = \"\";\n  for (let i = 0; i < length; i++) {\n    result += chars.charAt(Math.floor(Math.random() * charsLength));\n  }\n  return result;\n}\n\n// src/app-settings/index.ts\nvar NDKAppSettings = class _NDKAppSettings extends NDKEvent {\n  appName;\n  settings = {};\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 30078 /* AppSpecificData */;\n    this.dTag ??= this.appName;\n    if (this.content.length > 0) {\n      try {\n        this.settings = JSON.parse(this.content);\n      } catch (error) {\n        console.error(\"Error parsing app settings\", error);\n      }\n    }\n  }\n  static from(event) {\n    return new _NDKAppSettings(event.ndk, event);\n  }\n  /**\n   * Set a value for a given key.\n   *\n   * @param key\n   * @param value\n   */\n  set(key, value) {\n    this.settings[key] = value;\n  }\n  /**\n   * Get a value for a given key.\n   *\n   * @param key\n   * @returns\n   */\n  get(key) {\n    return this.settings[key];\n  }\n  async publishReplaceable(relaySet, timeoutMs, requiredRelayCount) {\n    this.content = JSON.stringify(this.settings);\n    return super.publishReplaceable(relaySet, timeoutMs, requiredRelayCount);\n  }\n};\n\n// src/relay/auth-policies.ts\n\nfunction disconnect(pool, debug8) {\n  debug8 ??= debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:relay:auth-policies:disconnect\");\n  return async (relay) => {\n    debug8(`Relay ${relay.url} requested authentication, disconnecting`);\n    pool.removeRelay(relay.url);\n  };\n}\nasync function signAndAuth(event, relay, signer, debug8, resolve, reject) {\n  try {\n    await event.sign(signer);\n    resolve(event);\n  } catch (e) {\n    debug8(`Failed to publish auth event to relay ${relay.url}`, e);\n    reject(event);\n  }\n}\nfunction signIn({ ndk, signer, debug: debug8 } = {}) {\n  debug8 ??= debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:auth-policies:signIn\");\n  return async (relay, challenge) => {\n    debug8(`Relay ${relay.url} requested authentication, signing in`);\n    const event = new NDKEvent(ndk);\n    event.kind = 22242 /* ClientAuth */;\n    event.tags = [\n      [\"relay\", relay.url],\n      [\"challenge\", challenge]\n    ];\n    signer ??= ndk?.signer;\n    return new Promise(async (resolve, reject) => {\n      if (signer) {\n        await signAndAuth(event, relay, signer, debug8, resolve, reject);\n      } else {\n        ndk?.once(\"signer:ready\", async (signer2) => {\n          await signAndAuth(event, relay, signer2, debug8, resolve, reject);\n        });\n      }\n    });\n  };\n}\nvar NDKRelayAuthPolicies = {\n  disconnect,\n  signIn\n};\n\n// src/signers/nip07/index.ts\n\nvar NDKNip07Signer = class {\n  _userPromise;\n  encryptionQueue = [];\n  encryptionProcessing = false;\n  debug;\n  waitTimeout;\n  /**\n   * @param waitTimeout - The timeout in milliseconds to wait for the NIP-07 to become available\n   */\n  constructor(waitTimeout = 1e3) {\n    this.debug = debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:nip07\");\n    this.waitTimeout = waitTimeout;\n  }\n  async blockUntilReady() {\n    await this.waitForExtension();\n    const pubkey = await window.nostr.getPublicKey();\n    if (!pubkey) {\n      throw new Error(\"User rejected access\");\n    }\n    return new NDKUser({ pubkey });\n  }\n  /**\n   * Getter for the user property.\n   * @returns The NDKUser instance.\n   */\n  async user() {\n    if (!this._userPromise) {\n      this._userPromise = this.blockUntilReady();\n    }\n    return this._userPromise;\n  }\n  /**\n   * Signs the given Nostr event.\n   * @param event - The Nostr event to be signed.\n   * @returns The signature of the signed event.\n   * @throws Error if the NIP-07 is not available on the window object.\n   */\n  async sign(event) {\n    await this.waitForExtension();\n    const signedEvent = await window.nostr.signEvent(event);\n    return signedEvent.sig;\n  }\n  async relays(ndk) {\n    await this.waitForExtension();\n    const relays = await window.nostr.getRelays?.() || {};\n    const activeRelays = [];\n    for (const url of Object.keys(relays)) {\n      if (relays[url].read && relays[url].write) {\n        activeRelays.push(url);\n      }\n    }\n    return activeRelays.map((url) => new NDKRelay(url, ndk?.relayAuthDefaultPolicy, ndk));\n  }\n  async encryptionEnabled(nip) {\n    let enabled = [];\n    if ((!nip || nip == \"nip04\") && Boolean(window.nostr.nip04)) enabled.push(\"nip04\");\n    if ((!nip || nip == \"nip44\") && Boolean(window.nostr.nip44)) enabled.push(\"nip44\");\n    return enabled;\n  }\n  async encrypt(recipient, value, nip = \"nip04\") {\n    if (!await this.encryptionEnabled(nip)) throw new Error(nip + \"encryption is not available from your browser extension\");\n    await this.waitForExtension();\n    const recipientHexPubKey = recipient.pubkey;\n    return this.queueEncryption(nip, \"encrypt\", recipientHexPubKey, value);\n  }\n  async decrypt(sender, value, nip = \"nip04\") {\n    if (!await this.encryptionEnabled(nip)) throw new Error(nip + \"encryption is not available from your browser extension\");\n    await this.waitForExtension();\n    const senderHexPubKey = sender.pubkey;\n    return this.queueEncryption(nip, \"decrypt\", senderHexPubKey, value);\n  }\n  async queueEncryption(scheme, method, counterpartyHexpubkey, value) {\n    return new Promise((resolve, reject) => {\n      this.encryptionQueue.push({\n        scheme,\n        method,\n        counterpartyHexpubkey,\n        value,\n        resolve,\n        reject\n      });\n      if (!this.encryptionProcessing) {\n        this.processEncryptionQueue();\n      }\n    });\n  }\n  async processEncryptionQueue(item, retries = 0) {\n    if (!item && this.encryptionQueue.length === 0) {\n      this.encryptionProcessing = false;\n      return;\n    }\n    this.encryptionProcessing = true;\n    const { scheme, method, counterpartyHexpubkey, value, resolve, reject } = item || this.encryptionQueue.shift();\n    this.debug(\"Processing encryption queue item\", {\n      method,\n      counterpartyHexpubkey,\n      value\n    });\n    try {\n      let result = await window.nostr[scheme][method](counterpartyHexpubkey, value);\n      resolve(result);\n    } catch (error) {\n      if (error.message && error.message.includes(\"call already executing\")) {\n        if (retries < 5) {\n          this.debug(\"Retrying encryption queue item\", {\n            method,\n            counterpartyHexpubkey,\n            value,\n            retries\n          });\n          setTimeout(() => {\n            this.processEncryptionQueue(item, retries + 1);\n          }, 50 * retries);\n          return;\n        }\n      }\n      reject(error);\n    }\n    this.processEncryptionQueue();\n  }\n  waitForExtension() {\n    return new Promise((resolve, reject) => {\n      if (window.nostr) {\n        resolve();\n        return;\n      }\n      let timerId;\n      const intervalId = setInterval(() => {\n        if (window.nostr) {\n          clearTimeout(timerId);\n          clearInterval(intervalId);\n          resolve();\n        }\n      }, 100);\n      timerId = setTimeout(() => {\n        clearInterval(intervalId);\n        reject(new Error(\"NIP-07 extension not available\"));\n      }, this.waitTimeout);\n    });\n  }\n};\n\n// src/signers/private-key/index.ts\n\n\n\nvar NDKPrivateKeySigner = class _NDKPrivateKeySigner {\n  _user;\n  _privateKey;\n  constructor(privateKey) {\n    if (privateKey) {\n      if (typeof privateKey === \"string\") {\n        if (privateKey.startsWith(\"nsec1\")) {\n          const { type, data } = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.decode(privateKey);\n          if (type === \"nsec\") this._privateKey = data;\n        } else if (privateKey.length === 64) {\n          this._privateKey = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_6__.hexToBytes)(privateKey);\n        } else {\n          throw new Error(\"Invalid private key provided.\");\n        }\n      } else {\n        this._privateKey = privateKey;\n      }\n      if (this._privateKey) {\n        this._user = new NDKUser({\n          pubkey: (0,nostr_tools__WEBPACK_IMPORTED_MODULE_2__.getPublicKey)(this._privateKey)\n        });\n      }\n    }\n  }\n  get privateKey() {\n    if (!this._privateKey) return void 0;\n    return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_6__.bytesToHex)(this._privateKey);\n  }\n  static generate() {\n    const privateKey = (0,nostr_tools__WEBPACK_IMPORTED_MODULE_2__.generateSecretKey)();\n    return new _NDKPrivateKeySigner(privateKey);\n  }\n  async blockUntilReady() {\n    if (!this._user) {\n      throw new Error(\"NDKUser not initialized\");\n    }\n    return this._user;\n  }\n  async user() {\n    await this.blockUntilReady();\n    return this._user;\n  }\n  async sign(event) {\n    if (!this._privateKey) {\n      throw Error(\"Attempted to sign without a private key\");\n    }\n    return (0,nostr_tools__WEBPACK_IMPORTED_MODULE_2__.finalizeEvent)(event, this._privateKey).sig;\n  }\n  async encryptionEnabled(scheme) {\n    let enabled = [];\n    if (!scheme || scheme == \"nip04\") enabled.push(\"nip04\");\n    if (!scheme || scheme == \"nip44\") enabled.push(\"nip44\");\n    return enabled;\n  }\n  async encrypt(recipient, value, scheme) {\n    if (!this._privateKey || !this.privateKey) {\n      throw Error(\"Attempted to encrypt without a private key\");\n    }\n    const recipientHexPubKey = recipient.pubkey;\n    if (scheme == \"nip44\") {\n      let conversationKey = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip44.v2.utils.getConversationKey(this._privateKey, recipientHexPubKey);\n      return await nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip44.v2.encrypt(value, conversationKey);\n    }\n    return await nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip04.encrypt(this._privateKey, recipientHexPubKey, value);\n  }\n  async decrypt(sender, value, scheme) {\n    if (!this._privateKey || !this.privateKey) {\n      throw Error(\"Attempted to decrypt without a private key\");\n    }\n    const senderHexPubKey = sender.pubkey;\n    if (scheme == \"nip44\") {\n      let conversationKey = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip44.v2.utils.getConversationKey(this._privateKey, senderHexPubKey);\n      return await nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip44.v2.decrypt(value, conversationKey);\n    }\n    return await nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip04.decrypt(this._privateKey, senderHexPubKey, value);\n  }\n};\n\n// src/signers/nip46/rpc.ts\n\nvar NDKNostrRpc = class extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  ndk;\n  signer;\n  relaySet;\n  debug;\n  encryptionType = \"nip04\";\n  pool;\n  constructor(ndk, signer, debug8, relayUrls) {\n    super();\n    this.ndk = ndk;\n    this.signer = signer;\n    if (relayUrls) {\n      this.pool = new NDKPool(\n        relayUrls,\n        [],\n        ndk,\n        {\n          debug: debug8.extend(\"rpc-pool\"),\n          name: \"Nostr RPC\"\n        }\n      );\n      this.relaySet = new NDKRelaySet(/* @__PURE__ */ new Set(), ndk, this.pool);\n      for (const url of relayUrls) {\n        const relay = this.pool.getRelay(url, false, false);\n        relay.authPolicy = NDKRelayAuthPolicies.signIn({ ndk, signer, debug: debug8 });\n        this.relaySet.addRelay(relay);\n        relay.connect();\n      }\n    }\n    this.debug = debug8.extend(\"rpc\");\n  }\n  /**\n   * Subscribe to a filter. This function will resolve once the subscription is ready.\n   */\n  subscribe(filter) {\n    const sub = this.ndk.subscribe(\n      filter,\n      {\n        closeOnEose: false,\n        groupable: false,\n        cacheUsage: \"ONLY_RELAY\" /* ONLY_RELAY */,\n        pool: this.pool\n      },\n      this.relaySet,\n      false\n    );\n    sub.on(\"event\", async (event) => {\n      try {\n        const parsedEvent = await this.parseEvent(event);\n        if (parsedEvent.method) {\n          this.emit(\"request\", parsedEvent);\n        } else {\n          this.emit(`response-${parsedEvent.id}`, parsedEvent);\n        }\n      } catch (e) {\n        this.debug(\"error parsing event\", e, event.rawEvent());\n      }\n    });\n    return new Promise((resolve) => {\n      sub.on(\"eose\", () => {\n        this.debug(\"eosed\");\n        resolve(sub);\n      });\n      sub.start();\n    });\n  }\n  async parseEvent(event) {\n    if (this.encryptionType === \"nip44\" && event.content.includes(\"?iv=\")) {\n      this.encryptionType = \"nip04\";\n    } else if (this.encryptionType === \"nip04\" && !event.content.includes(\"?iv=\")) {\n      this.encryptionType = \"nip44\";\n    }\n    const remoteUser = this.ndk.getUser({ pubkey: event.pubkey });\n    remoteUser.ndk = this.ndk;\n    let decryptedContent;\n    try {\n      decryptedContent = await this.signer.decrypt(\n        remoteUser,\n        event.content,\n        this.encryptionType\n      );\n    } catch (e) {\n      const otherEncryptionType = this.encryptionType === \"nip04\" ? \"nip44\" : \"nip04\";\n      decryptedContent = await this.signer.decrypt(remoteUser, event.content, otherEncryptionType);\n      this.encryptionType = otherEncryptionType;\n    }\n    const parsedContent = JSON.parse(decryptedContent);\n    const { id, method, params, result, error } = parsedContent;\n    if (method) {\n      return { id, pubkey: event.pubkey, method, params, event };\n    } else {\n      return { id, result, error, event };\n    }\n  }\n  async sendResponse(id, remotePubkey, result, kind = 24133 /* NostrConnect */, error) {\n    const res = { id, result };\n    if (error) {\n      res.error = error;\n    }\n    const localUser = await this.signer.user();\n    const remoteUser = this.ndk.getUser({ pubkey: remotePubkey });\n    const event = new NDKEvent(this.ndk, {\n      kind,\n      content: JSON.stringify(res),\n      tags: [[\"p\", remotePubkey]],\n      pubkey: localUser.pubkey\n    });\n    event.content = await this.signer.encrypt(remoteUser, event.content, this.encryptionType);\n    await event.sign(this.signer);\n    await event.publish(this.relaySet);\n  }\n  /**\n   * Sends a request.\n   * @param remotePubkey\n   * @param method\n   * @param params\n   * @param kind\n   * @param id\n   */\n  async sendRequest(remotePubkey, method, params = [], kind = 24133, cb) {\n    const id = Math.random().toString(36).substring(7);\n    const localUser = await this.signer.user();\n    const remoteUser = this.ndk.getUser({ pubkey: remotePubkey });\n    const request = { id, method, params };\n    const promise = new Promise(() => {\n      const responseHandler = (response) => {\n        if (response.result === \"auth_url\") {\n          this.once(`response-${id}`, responseHandler);\n          this.emit(\"authUrl\", response.error);\n        } else if (cb) {\n          cb(response);\n        }\n      };\n      this.once(`response-${id}`, responseHandler);\n    });\n    const event = new NDKEvent(this.ndk, {\n      kind,\n      content: JSON.stringify(request),\n      tags: [[\"p\", remotePubkey]],\n      pubkey: localUser.pubkey\n    });\n    event.content = await this.signer.encrypt(remoteUser, event.content, this.encryptionType);\n    await event.sign(this.signer);\n    await event.publish(this.relaySet);\n    return promise;\n  }\n};\n\n// src/signers/nip46/backend/ping.ts\nvar PingEventHandlingStrategy = class {\n  async handle(backend, id, remotePubkey, params) {\n    const debug8 = backend.debug.extend(\"ping\");\n    debug8(`ping request from ${remotePubkey}`);\n    if (await backend.pubkeyAllowed({ id, pubkey: remotePubkey, method: \"ping\" })) {\n      debug8(`connection request from ${remotePubkey} allowed`);\n      return \"pong\";\n    } else {\n      debug8(`connection request from ${remotePubkey} rejected`);\n    }\n    return void 0;\n  }\n};\n\n// src/signers/nip46/backend/connect.ts\nvar ConnectEventHandlingStrategy = class {\n  async handle(backend, id, remotePubkey, params) {\n    const [_, token] = params;\n    const debug8 = backend.debug.extend(\"connect\");\n    debug8(`connection request from ${remotePubkey}`);\n    if (token && backend.applyToken) {\n      debug8(`applying token`);\n      await backend.applyToken(remotePubkey, token);\n    }\n    if (await backend.pubkeyAllowed({\n      id,\n      pubkey: remotePubkey,\n      method: \"connect\",\n      params: token\n    })) {\n      debug8(`connection request from ${remotePubkey} allowed`);\n      return \"ack\";\n    } else {\n      debug8(`connection request from ${remotePubkey} rejected`);\n    }\n    return void 0;\n  }\n};\n\n// src/signers/nip46/backend/get-public-key.ts\nvar GetPublicKeyHandlingStrategy = class {\n  async handle(backend, id, remotePubkey, params) {\n    return backend.localUser?.pubkey;\n  }\n};\n\n// src/signers/nip46/backend/nip04-decrypt.ts\nvar Nip04DecryptHandlingStrategy = class {\n  async handle(backend, id, remotePubkey, params) {\n    const [senderPubkey, payload] = params;\n    const senderUser = new NDKUser({ pubkey: senderPubkey });\n    const decryptedPayload = await decrypt2(backend, id, remotePubkey, senderUser, payload);\n    return decryptedPayload;\n  }\n};\nasync function decrypt2(backend, id, remotePubkey, senderUser, payload) {\n  if (!await backend.pubkeyAllowed({\n    id,\n    pubkey: remotePubkey,\n    method: \"nip04_decrypt\",\n    params: payload\n  })) {\n    backend.debug(`decrypt request from ${remotePubkey} rejected`);\n    return void 0;\n  }\n  return await backend.signer.decrypt(senderUser, payload, \"nip04\");\n}\n\n// src/signers/nip46/backend/nip04-encrypt.ts\nvar Nip04EncryptHandlingStrategy = class {\n  async handle(backend, id, remotePubkey, params) {\n    const [recipientPubkey, payload] = params;\n    const recipientUser = new NDKUser({ pubkey: recipientPubkey });\n    const encryptedPayload = await encrypt2(backend, id, remotePubkey, recipientUser, payload);\n    return encryptedPayload;\n  }\n};\nasync function encrypt2(backend, id, remotePubkey, recipientUser, payload) {\n  if (!await backend.pubkeyAllowed({\n    id,\n    pubkey: remotePubkey,\n    method: \"nip04_encrypt\",\n    params: payload\n  })) {\n    backend.debug(`encrypt request from ${remotePubkey} rejected`);\n    return void 0;\n  }\n  return await backend.signer.encrypt(recipientUser, payload, \"nip04\");\n}\n\n// src/signers/nip46/backend/sign-event.ts\nvar SignEventHandlingStrategy = class {\n  async handle(backend, id, remotePubkey, params) {\n    const event = await signEvent(backend, id, remotePubkey, params);\n    if (!event) return void 0;\n    return JSON.stringify(await event.toNostrEvent());\n  }\n};\nasync function signEvent(backend, id, remotePubkey, params) {\n  const [eventString] = params;\n  backend.debug(`sign event request from ${remotePubkey}`);\n  const event = new NDKEvent(backend.ndk, JSON.parse(eventString));\n  backend.debug(\"event to sign\", event.rawEvent());\n  if (!await backend.pubkeyAllowed({\n    id,\n    pubkey: remotePubkey,\n    method: \"sign_event\",\n    params: event\n  })) {\n    backend.debug(`sign event request from ${remotePubkey} rejected`);\n    return void 0;\n  }\n  backend.debug(`sign event request from ${remotePubkey} allowed`);\n  await event.sign(backend.signer);\n  return event;\n}\n\n// src/signers/nip46/backend/nip44-encrypt.ts\nvar Nip04EncryptHandlingStrategy2 = class {\n  async handle(backend, id, remotePubkey, params) {\n    const [recipientPubkey, payload] = params;\n    const recipientUser = new NDKUser({ pubkey: recipientPubkey });\n    const encryptedPayload = await encrypt3(backend, id, remotePubkey, recipientUser, payload);\n    return encryptedPayload;\n  }\n};\nasync function encrypt3(backend, id, remotePubkey, recipientUser, payload) {\n  if (!await backend.pubkeyAllowed({\n    id,\n    pubkey: remotePubkey,\n    method: \"nip44_encrypt\",\n    params: payload\n  })) {\n    backend.debug(`encrypt request from ${remotePubkey} rejected`);\n    return void 0;\n  }\n  return await backend.signer.encrypt(recipientUser, payload, \"nip44\");\n}\n\n// src/signers/nip46/backend/nip44-decrypt.ts\nvar Nip04DecryptHandlingStrategy2 = class {\n  async handle(backend, id, remotePubkey, params) {\n    const [senderPubkey, payload] = params;\n    const senderUser = new NDKUser({ pubkey: senderPubkey });\n    const decryptedPayload = await decrypt3(backend, id, remotePubkey, senderUser, payload);\n    return decryptedPayload;\n  }\n};\nasync function decrypt3(backend, id, remotePubkey, senderUser, payload) {\n  if (!await backend.pubkeyAllowed({\n    id,\n    pubkey: remotePubkey,\n    method: \"nip44_decrypt\",\n    params: payload\n  })) {\n    backend.debug(`decrypt request from ${remotePubkey} rejected`);\n    return void 0;\n  }\n  return await backend.signer.decrypt(senderUser, payload, \"nip44\");\n}\n\n// src/signers/nip46/backend/index.ts\n\nvar NDKNip46Backend = class {\n  ndk;\n  signer;\n  localUser;\n  debug;\n  rpc;\n  permitCallback;\n  relayUrls;\n  /**\n   * @param ndk The NDK instance to use\n   * @param privateKeyOrSigner The private key or signer of the npub that wants to be published as\n   * @param permitCallback Callback executed when permission is requested\n   */\n  constructor(ndk, privateKeyOrSigner, permitCallback, relayUrls) {\n    this.ndk = ndk;\n    if (privateKeyOrSigner instanceof Uint8Array) {\n      this.signer = new NDKPrivateKeySigner(privateKeyOrSigner);\n    } else if (privateKeyOrSigner instanceof String) {\n      this.signer = new NDKPrivateKeySigner((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_6__.hexToBytes)(privateKeyOrSigner));\n    } else if (privateKeyOrSigner instanceof NDKPrivateKeySigner) {\n      this.signer = privateKeyOrSigner;\n    } else {\n      throw new Error(\"Invalid signer\");\n    }\n    this.debug = ndk.debug.extend(\"nip46:backend\");\n    this.relayUrls = relayUrls ?? Array.from(ndk.pool.relays.keys());\n    this.rpc = new NDKNostrRpc(ndk, this.signer, this.debug, this.relayUrls);\n    this.permitCallback = permitCallback;\n  }\n  /**\n   * This method starts the backend, which will start listening for incoming\n   * requests.\n   */\n  async start() {\n    this.localUser = await this.signer.user();\n    const sub = this.ndk.subscribe(\n      {\n        kinds: [24133],\n        \"#p\": [this.localUser.pubkey]\n      },\n      { closeOnEose: false }\n    );\n    sub.on(\"event\", (e) => this.handleIncomingEvent(e));\n  }\n  handlers = {\n    connect: new ConnectEventHandlingStrategy(),\n    sign_event: new SignEventHandlingStrategy(),\n    nip04_encrypt: new Nip04EncryptHandlingStrategy(),\n    nip04_decrypt: new Nip04DecryptHandlingStrategy(),\n    nip44_encrypt: new Nip04EncryptHandlingStrategy2(),\n    nip44_decrypt: new Nip04DecryptHandlingStrategy2(),\n    get_public_key: new GetPublicKeyHandlingStrategy(),\n    ping: new PingEventHandlingStrategy()\n  };\n  /**\n   * Enables the user to set a custom strategy for handling incoming events.\n   * @param method - The method to set the strategy for\n   * @param strategy - The strategy to set\n   */\n  setStrategy(method, strategy) {\n    this.handlers[method] = strategy;\n  }\n  /**\n   * Overload this method to apply tokens, which can\n   * wrap permission sets to be applied to a pubkey.\n   * @param pubkey public key to apply token to\n   * @param token token to apply\n   */\n  async applyToken(pubkey, token) {\n    throw new Error(\"connection token not supported\");\n  }\n  async handleIncomingEvent(event) {\n    const { id, method, params } = await this.rpc.parseEvent(event);\n    const remotePubkey = event.pubkey;\n    let response;\n    this.debug(\"incoming event\", { id, method, params });\n    if (!event.verifySignature(false)) {\n      this.debug(\"invalid signature\", event.rawEvent());\n      return;\n    }\n    const strategy = this.handlers[method];\n    if (strategy) {\n      try {\n        response = await strategy.handle(this, id, remotePubkey, params);\n      } catch (e) {\n        this.debug(\"error handling event\", e, { id, method, params });\n        this.rpc.sendResponse(id, remotePubkey, \"error\", void 0, e.message);\n      }\n    } else {\n      this.debug(\"unsupported method\", { method, params });\n    }\n    if (response) {\n      this.debug(`sending response to ${remotePubkey}`, response);\n      this.rpc.sendResponse(id, remotePubkey, response);\n    } else {\n      this.rpc.sendResponse(id, remotePubkey, \"error\", void 0, \"Not authorized\");\n    }\n  }\n  /**\n   * This method should be overriden by the user to allow or reject incoming\n   * connections.\n   */\n  async pubkeyAllowed(params) {\n    return this.permitCallback(params);\n  }\n};\n\n// src/signers/nip46/index.ts\n\nvar NDKNip46Signer = class extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  ndk;\n  _user;\n  /**\n   * The pubkey of the bunker that will be providing signatures\n   */\n  bunkerPubkey;\n  /**\n   * The pubkey of the user that events will be published as\n   */\n  userPubkey;\n  /**\n   * An optional secret value provided to connect to the bunker\n   */\n  secret;\n  localSigner;\n  nip05;\n  rpc;\n  debug;\n  relayUrls;\n  subscription;\n  /**\n   * @param ndk - The NDK instance to use\n   * @param userOrConnectionToken - The public key, or a connection token, of the npub that wants to be published as\n   * @param localSigner - The signer that will be used to request events to be signed\n   */\n  constructor(ndk, userOrConnectionToken, localSigner) {\n    super();\n    this.ndk = ndk;\n    this.debug = ndk.debug.extend(\"nip46:signer\");\n    if (userOrConnectionToken.startsWith(\"bunker://\")) {\n      this.connectionTokenInit(userOrConnectionToken);\n    } else {\n      this.nip05Init(userOrConnectionToken);\n    }\n    if (!localSigner) {\n      this.localSigner = NDKPrivateKeySigner.generate();\n    } else {\n      this.localSigner = localSigner;\n    }\n    this.rpc = new NDKNostrRpc(this.ndk, this.localSigner, this.debug, this.relayUrls);\n  }\n  connectionTokenInit(connectionToken) {\n    const bunkerUrl = new URL(connectionToken);\n    const bunkerPubkey = bunkerUrl.hostname || bunkerUrl.pathname.replace(/^\\/\\//, \"\");\n    const userPubkey = bunkerUrl.searchParams.get(\"pubkey\");\n    const relayUrls = bunkerUrl.searchParams.getAll(\"relay\");\n    const secret = bunkerUrl.searchParams.get(\"secret\");\n    this.bunkerPubkey = bunkerPubkey;\n    this.userPubkey = userPubkey;\n    this.relayUrls = relayUrls;\n    this.secret = secret;\n  }\n  nip05Init(nip05) {\n    this.nip05 = nip05;\n  }\n  /**\n   * @deprecated Use userPubkey instead\n   */\n  get remotePubkey() {\n    return this.userPubkey;\n  }\n  /**\n   * We start listening for events from the bunker\n   */\n  async startListening() {\n    if (this.subscription) return;\n    const localUser = await this.localSigner.user();\n    if (!localUser) throw new Error(\"Local signer not ready\");\n    this.subscription = await this.rpc.subscribe({\n      kinds: [24133 /* NostrConnect */],\n      \"#p\": [localUser.pubkey]\n    });\n  }\n  /**\n   * Get the user that is being published as\n   */\n  async user() {\n    if (!this._user && !this.userPubkey) throw new Error(\"Remote user not ready\");\n    this._user ??= new NDKUser({ pubkey: this.userPubkey });\n    return this._user;\n  }\n  async blockUntilReady() {\n    if (this.nip05 && !this.userPubkey) {\n      const user = await NDKUser.fromNip05(this.nip05, this.ndk);\n      if (user) {\n        this._user = user;\n        this.userPubkey = user.pubkey;\n        this.relayUrls = user.nip46Urls;\n        this.rpc = new NDKNostrRpc(this.ndk, this.localSigner, this.debug, this.relayUrls);\n      }\n    }\n    if (!this.bunkerPubkey && this.userPubkey) {\n      this.bunkerPubkey = this.userPubkey;\n    } else if (!this.bunkerPubkey) {\n      throw new Error(\"Bunker pubkey not set\");\n    }\n    await this.startListening();\n    this.rpc.on(\"authUrl\", (...props) => {\n      this.emit(\"authUrl\", ...props);\n    });\n    return new Promise((resolve, reject) => {\n      const connectParams = [this.userPubkey ?? \"\"];\n      if (this.secret) connectParams.push(this.secret);\n      if (!this.bunkerPubkey) throw new Error(\"Bunker pubkey not set\");\n      this.rpc.sendRequest(\n        this.bunkerPubkey,\n        \"connect\",\n        connectParams,\n        24133,\n        (response) => {\n          if (response.result === \"ack\") {\n            this.getPublicKey().then((pubkey) => {\n              this.userPubkey = pubkey;\n              this._user = new NDKUser({ pubkey });\n              resolve(this._user);\n            });\n          } else {\n            reject(response.error);\n          }\n        }\n      );\n    });\n  }\n  async getPublicKey() {\n    if (this.userPubkey) return this.userPubkey;\n    return new Promise((resolve, reject) => {\n      if (!this.bunkerPubkey) throw new Error(\"Bunker pubkey not set\");\n      this.rpc.sendRequest(\n        this.bunkerPubkey,\n        \"get_public_key\",\n        [],\n        24133,\n        (response) => {\n          resolve(response.result);\n        }\n      );\n    });\n  }\n  async encryptionEnabled(scheme) {\n    if (scheme) return [scheme];\n    return Promise.resolve([\"nip04\", \"nip44\"]);\n  }\n  async encrypt(recipient, value, scheme = \"nip04\") {\n    return this.encryption(recipient, value, scheme, \"encrypt\");\n  }\n  async decrypt(sender, value, scheme = \"nip04\") {\n    return this.encryption(sender, value, scheme, \"decrypt\");\n  }\n  async encryption(peer, value, scheme, method) {\n    const promise = new Promise((resolve, reject) => {\n      if (!this.bunkerPubkey) throw new Error(\"Bunker pubkey not set\");\n      this.rpc.sendRequest(\n        this.bunkerPubkey,\n        `${scheme}_${method}`,\n        [peer.pubkey, value],\n        24133,\n        (response) => {\n          if (!response.error) {\n            resolve(response.result);\n          } else {\n            reject(response.error);\n          }\n        }\n      );\n    });\n    return promise;\n  }\n  async sign(event) {\n    const promise = new Promise((resolve, reject) => {\n      if (!this.bunkerPubkey) throw new Error(\"Bunker pubkey not set\");\n      this.rpc.sendRequest(\n        this.bunkerPubkey,\n        \"sign_event\",\n        [JSON.stringify(event)],\n        24133,\n        (response) => {\n          if (!response.error) {\n            const json = JSON.parse(response.result);\n            resolve(json.sig);\n          } else {\n            reject(response.error);\n          }\n        }\n      );\n    });\n    return promise;\n  }\n  /**\n   * Allows creating a new account on the remote server.\n   * @param username Desired username for the NIP-05\n   * @param domain Desired domain for the NIP-05\n   * @param email Email address to associate with this account -- Remote servers may use this for recovery\n   * @returns The public key of the newly created account\n   */\n  async createAccount(username, domain, email) {\n    await this.startListening();\n    const req = [];\n    if (username) req.push(username);\n    if (domain) req.push(domain);\n    if (email) req.push(email);\n    return new Promise((resolve, reject) => {\n      if (!this.bunkerPubkey) throw new Error(\"Bunker pubkey not set\");\n      this.rpc.sendRequest(\n        this.bunkerPubkey,\n        \"create_account\",\n        req,\n        24133 /* NostrConnect */,\n        (response) => {\n          if (!response.error) {\n            const pubkey = response.result;\n            resolve(pubkey);\n          } else {\n            reject(response.error);\n          }\n        }\n      );\n    });\n  }\n};\n\n// src/dvm/schedule.ts\nfunction addRelays(event, relays) {\n  const tags = [];\n  if (!relays || relays.length === 0) {\n    const poolRelays = event.ndk?.pool.relays;\n    relays = poolRelays ? Object.keys(poolRelays) : void 0;\n  }\n  if (relays && relays.length > 0) tags.push([\"relays\", ...relays]);\n  return tags;\n}\nasync function dvmSchedule(events, dvm, relays, encrypted = true, waitForConfirmationForMs) {\n  if (!(events instanceof Array)) {\n    events = [events];\n  }\n  const ndk = events[0].ndk;\n  if (!ndk) throw new Error(\"NDK not set\");\n  for (const event of events) {\n    if (!event.sig) throw new Error(\"Event not signed\");\n    if (!event.created_at) throw new Error(\"Event has no date\");\n    if (!dvm) throw new Error(\"No DVM specified\");\n    if (event.created_at <= Date.now() / 1e3)\n      throw new Error(\"Event needs to be in the future\");\n  }\n  const scheduleEvent = new NDKDVMRequest(ndk, {\n    kind: 5905 /* DVMEventSchedule */\n  });\n  for (const event of events) {\n    scheduleEvent.addInput(JSON.stringify(event.rawEvent()), \"text\");\n  }\n  scheduleEvent.tags.push(...addRelays(events[0], relays));\n  if (encrypted) {\n    await scheduleEvent.encryption(dvm);\n  } else {\n    scheduleEvent.dvm = dvm;\n  }\n  await scheduleEvent.sign();\n  let res;\n  if (waitForConfirmationForMs) {\n    res = ndk.subscribe(\n      {\n        kinds: [5905 /* DVMEventSchedule */ + 1e3, 7e3 /* DVMJobFeedback */],\n        ...scheduleEvent.filter()\n      },\n      { groupable: false, closeOnEose: false }\n    );\n  }\n  const timeoutPromise = new Promise((reject) => {\n    setTimeout(() => {\n      res?.stop();\n      reject(\"Timeout waiting for an answer from the DVM\");\n    }, waitForConfirmationForMs);\n  });\n  const schedulePromise = new Promise(\n    (resolve, reject) => {\n      if (waitForConfirmationForMs) {\n        res?.on(\"event\", async (e) => {\n          res?.stop();\n          if (e.kind === 7e3 /* DVMJobFeedback */) {\n            const feedback = await NDKDVMJobFeedback.from(e);\n            if (feedback.status === \"error\") {\n              const statusTag = feedback.getMatchingTags(\"status\");\n              reject(statusTag?.[2] ?? feedback);\n            } else {\n              resolve(feedback);\n            }\n          }\n          resolve(e);\n        });\n      }\n      scheduleEvent.publish().then(() => {\n        if (!waitForConfirmationForMs) resolve();\n      });\n    }\n  );\n  return new Promise((resolve, reject) => {\n    if (waitForConfirmationForMs) {\n      Promise.race([timeoutPromise, schedulePromise]).then((e) => {\n        resolve(e);\n      }).catch(reject);\n    } else {\n      schedulePromise.then(resolve);\n    }\n  });\n}\n\n// src/ndk/index.ts\n\n\n\n// src/events/dedup.ts\nfunction dedup(event1, event2) {\n  if (event1.created_at > event2.created_at) {\n    return event1;\n  }\n  return event2;\n}\n\n// src/outbox/tracker.ts\n\n\n\n// src/utils/get-users-relay-list.ts\nasync function getRelayListForUser(pubkey, ndk) {\n  const list = await getRelayListForUsers([pubkey], ndk);\n  return list.get(pubkey);\n}\nasync function getRelayListForUsers(pubkeys, ndk, skipCache = false, timeout = 1e3) {\n  const pool = ndk.outboxPool || ndk.pool;\n  const set = /* @__PURE__ */ new Set();\n  for (const relay of pool.relays.values()) set.add(relay);\n  const relayLists = /* @__PURE__ */ new Map();\n  const fromContactList = /* @__PURE__ */ new Map();\n  const relaySet = new NDKRelaySet(set, ndk);\n  if (ndk.cacheAdapter?.locking && !skipCache) {\n    const cachedList = await ndk.fetchEvents(\n      { kinds: [3, 10002], authors: Array.from(new Set(pubkeys)) },\n      { cacheUsage: \"ONLY_CACHE\" /* ONLY_CACHE */, subId: \"ndk-relay-list-fetch\" }\n    );\n    for (const relayList of cachedList) {\n      if (relayList.kind === 10002)\n        relayLists.set(relayList.pubkey, NDKRelayList.from(relayList));\n    }\n    for (const relayList of cachedList) {\n      if (relayList.kind === 3) {\n        if (relayLists.has(relayList.pubkey)) continue;\n        const list = relayListFromKind3(ndk, relayList);\n        if (list) fromContactList.set(relayList.pubkey, list);\n      }\n    }\n    pubkeys = pubkeys.filter(\n      (pubkey) => !relayLists.has(pubkey) && !fromContactList.has(pubkey)\n    );\n  }\n  if (pubkeys.length === 0) return relayLists;\n  const relayListEvents = /* @__PURE__ */ new Map();\n  const contactListEvents = /* @__PURE__ */ new Map();\n  return new Promise(async (resolve) => {\n    const sub = ndk.subscribe(\n      { kinds: [3, 10002], authors: pubkeys },\n      {\n        closeOnEose: true,\n        pool,\n        groupable: true,\n        cacheUsage: \"ONLY_RELAY\" /* ONLY_RELAY */,\n        subId: \"ndk-relay-list-fetch\"\n      },\n      relaySet,\n      false\n    );\n    sub.on(\"event\", (event) => {\n      if (event.kind === 10002 /* RelayList */) {\n        const existingEvent = relayListEvents.get(event.pubkey);\n        if (existingEvent && existingEvent.created_at > event.created_at) return;\n        relayListEvents.set(event.pubkey, event);\n      } else if (event.kind === 3 /* Contacts */) {\n        const existingEvent = contactListEvents.get(event.pubkey);\n        if (existingEvent && existingEvent.created_at > event.created_at) return;\n        contactListEvents.set(event.pubkey, event);\n      }\n    });\n    sub.on(\"eose\", () => {\n      for (const event of relayListEvents.values()) {\n        relayLists.set(event.pubkey, NDKRelayList.from(event));\n      }\n      for (const pubkey of pubkeys) {\n        if (relayLists.has(pubkey)) continue;\n        const contactList = contactListEvents.get(pubkey);\n        if (!contactList) continue;\n        const list = relayListFromKind3(ndk, contactList);\n        if (list) relayLists.set(pubkey, list);\n      }\n      resolve(relayLists);\n    });\n    setTimeout(() => {\n      resolve(relayLists);\n    }, timeout);\n    sub.start();\n  });\n}\n\n// src/outbox/tracker.ts\nvar OutboxItem = class {\n  /**\n   * Type of item\n   */\n  type;\n  /**\n   * The relay URLs that are of interest to this item\n   */\n  relayUrlScores;\n  readRelays;\n  writeRelays;\n  constructor(type) {\n    this.type = type;\n    this.relayUrlScores = /* @__PURE__ */ new Map();\n    this.readRelays = /* @__PURE__ */ new Set();\n    this.writeRelays = /* @__PURE__ */ new Set();\n  }\n};\nvar OutboxTracker = class extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  data;\n  ndk;\n  debug;\n  constructor(ndk) {\n    super();\n    this.ndk = ndk;\n    this.debug = ndk.debug.extend(\"outbox-tracker\");\n    this.data = new typescript_lru_cache__WEBPACK_IMPORTED_MODULE_3__.LRUCache({\n      maxSize: 1e5,\n      entryExpirationTimeInMS: 2 * 60 * 1e3\n    });\n  }\n  /**\n   * Adds a list of users to the tracker.\n   * @param items\n   * @param skipCache\n   */\n  async trackUsers(items, skipCache = false) {\n    const promises = [];\n    for (let i = 0; i < items.length; i += 400) {\n      const slice = items.slice(i, i + 400);\n      const pubkeys = slice.map((item) => getKeyFromItem(item)).filter((pubkey) => !this.data.has(pubkey));\n      if (pubkeys.length === 0) continue;\n      for (const pubkey of pubkeys) {\n        this.data.set(pubkey, new OutboxItem(\"user\"));\n      }\n      promises.push(\n        new Promise((resolve) => {\n          getRelayListForUsers(pubkeys, this.ndk, skipCache).then((relayLists) => {\n            for (const [pubkey, relayList] of relayLists) {\n              let outboxItem = this.data.get(pubkey);\n              outboxItem ??= new OutboxItem(\"user\");\n              if (relayList) {\n                outboxItem.readRelays = new Set(\n                  normalize(relayList.readRelayUrls)\n                );\n                outboxItem.writeRelays = new Set(\n                  normalize(relayList.writeRelayUrls)\n                );\n                for (const relayUrl of outboxItem.readRelays) {\n                  if (this.ndk.pool.blacklistRelayUrls.has(relayUrl)) {\n                    outboxItem.readRelays.delete(relayUrl);\n                  }\n                }\n                for (const relayUrl of outboxItem.writeRelays) {\n                  if (this.ndk.pool.blacklistRelayUrls.has(relayUrl)) {\n                    outboxItem.writeRelays.delete(relayUrl);\n                  }\n                }\n                this.data.set(pubkey, outboxItem);\n              }\n            }\n          }).finally(resolve);\n        })\n      );\n    }\n    return Promise.all(promises);\n  }\n  /**\n   *\n   * @param key\n   * @param score\n   */\n  track(item, type, skipCache = true) {\n    const key = getKeyFromItem(item);\n    type ??= getTypeFromItem(item);\n    let outboxItem = this.data.get(key);\n    if (!outboxItem) {\n      outboxItem = new OutboxItem(type);\n      if (item instanceof NDKUser) {\n        this.trackUsers([item]);\n      }\n    }\n    return outboxItem;\n  }\n};\nfunction getKeyFromItem(item) {\n  if (item instanceof NDKUser) {\n    return item.pubkey;\n  } else {\n    return item;\n  }\n}\nfunction getTypeFromItem(item) {\n  if (item instanceof NDKUser) {\n    return \"user\";\n  } else {\n    return \"kind\";\n  }\n}\n\n// src/relay/sets/utils.ts\nfunction correctRelaySet(relaySet, pool) {\n  const connectedRelays = pool.connectedRelays();\n  const includesConnectedRelay = Array.from(relaySet.relays).some((relay) => {\n    return connectedRelays.map((r) => r.url).includes(relay.url);\n  });\n  if (!includesConnectedRelay) {\n    for (const relay of connectedRelays) {\n      relaySet.addRelay(relay);\n    }\n  }\n  if (connectedRelays.length === 0) {\n    for (const relay of pool.relays.values()) {\n      relaySet.addRelay(relay);\n    }\n  }\n  return relaySet;\n}\n\n// src/ndk/fetch-event-from-tag.ts\nfunction isValidHint(hint) {\n  if (!hint || hint === \"\") return false;\n  try {\n    new URL(hint);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nasync function fetchEventFromTag(tag, originalEvent, subOpts, fallback = {\n  type: \"timeout\"\n}) {\n  const d4 = this.debug.extend(\"fetch-event-from-tag\");\n  const [_, id, hint] = tag;\n  subOpts = {};\n  d4(\"fetching event from tag\", tag, subOpts, fallback);\n  const authorRelays = getRelaysForSync(this, originalEvent.pubkey);\n  if (authorRelays && authorRelays.size > 0) {\n    d4(\"fetching event from author relays %o\", Array.from(authorRelays));\n    const relaySet2 = NDKRelaySet.fromRelayUrls(Array.from(authorRelays), this);\n    const event2 = await this.fetchEvent(id, subOpts, relaySet2);\n    if (event2) return event2;\n  } else {\n    d4(\"no author relays found for %s\", originalEvent.pubkey, originalEvent);\n  }\n  const relaySet = calculateRelaySetsFromFilters(this, [{ ids: [id] }], this.pool);\n  d4(\"fetching event without relay hint\", relaySet);\n  const event = await this.fetchEvent(id, subOpts);\n  if (event) return event;\n  if (hint && hint !== \"\") {\n    const event2 = await this.fetchEvent(\n      id,\n      subOpts,\n      this.pool.getRelay(hint, true, true, [{ ids: [id] }])\n    );\n    if (event2) return event2;\n  }\n  let result = void 0;\n  const relay = isValidHint(hint) ? this.pool.getRelay(hint, false, true, [{ ids: [id] }]) : void 0;\n  const fetchMaybeWithRelayHint = new Promise((resolve) => {\n    this.fetchEvent(id, subOpts, relay).then(resolve);\n  });\n  if (!isValidHint(hint) || fallback.type === \"none\") {\n    return fetchMaybeWithRelayHint;\n  }\n  const fallbackFetchPromise = new Promise(async (resolve) => {\n    const fallbackRelaySet = fallback.relaySet;\n    const timeout = fallback.timeout ?? 1500;\n    const timeoutPromise = new Promise((resolve2) => setTimeout(resolve2, timeout));\n    if (fallback.type === \"timeout\") await timeoutPromise;\n    if (result) {\n      resolve(result);\n    } else {\n      d4(\"fallback fetch triggered\");\n      const fallbackEvent = await this.fetchEvent(id, subOpts, fallbackRelaySet);\n      resolve(fallbackEvent);\n    }\n  });\n  switch (fallback.type) {\n    case \"timeout\":\n      return Promise.race([fetchMaybeWithRelayHint, fallbackFetchPromise]);\n    case \"eose\":\n      result = await fetchMaybeWithRelayHint;\n      if (result) return result;\n      return fallbackFetchPromise;\n  }\n}\n\n// src/media/index.ts\nvar SPEC_PATH = \"/.well-known/nostr/nip96.json\";\nvar Nip96 = class {\n  ndk;\n  spec;\n  url;\n  nip98Required = false;\n  /**\n   * @param domain domain of the NIP96 service\n   */\n  constructor(domain, ndk) {\n    this.url = `https://${domain}${SPEC_PATH}`;\n    this.ndk = ndk;\n  }\n  async prepareUpload(blob, httpVerb = \"POST\") {\n    this.validateHttpFetch();\n    if (!this.spec) await this.fetchSpec();\n    if (!this.spec) throw new Error(\"Failed to fetch NIP96 spec\");\n    let headers = {};\n    if (this.nip98Required) {\n      const authorizationHeader = await this.generateNip98Header(\n        this.spec.api_url,\n        httpVerb,\n        blob\n      );\n      headers = { Authorization: authorizationHeader };\n    }\n    return {\n      url: this.spec.api_url,\n      headers\n    };\n  }\n  /**\n   * Provides an XMLHttpRequest-based upload method for browsers.\n   * @example\n   * const xhr = new XMLHttpRequest();\n   * xhr.upload.addEventListener(\"progress\", function(e) {\n   *    const percentComplete = e.loaded / e.total;\n   *    console.log(percentComplete);\n   * });\n   * const nip96 = ndk.getNip96(\"nostrcheck.me\");\n   * const blob = new Blob([\"Hello, world!\"], { type: \"text/plain\" });\n   * const response = await nip96.xhrUpload(xhr, blob);\n   * console.log(response);\n   * @returns Promise that resolves to the upload response\n   */\n  async xhrUpload(xhr, blob) {\n    const httpVerb = \"POST\";\n    const { url, headers } = await this.prepareUpload(blob, httpVerb);\n    xhr.open(httpVerb, url, true);\n    if (headers[\"Authorization\"]) {\n      xhr.setRequestHeader(\"Authorization\", headers[\"Authorization\"]);\n    }\n    const formData = new FormData();\n    formData.append(\"file\", blob);\n    return new Promise((resolve, reject) => {\n      xhr.onload = function() {\n        if (xhr.status >= 200 && xhr.status < 300) {\n          resolve(JSON.parse(xhr.responseText));\n        } else {\n          reject(new Error(xhr.statusText));\n        }\n      };\n      xhr.onerror = function() {\n        reject(new Error(\"Network Error\"));\n      };\n      xhr.send(formData);\n    });\n  }\n  /**\n   * Fetch-based upload method. Note that this will use NDK's httpFetch\n   * @param blob\n   * @returns Promise that resolves to the upload response\n   *\n   * @example\n   * const nip96 = ndk.getNip96(\"nostrcheck.me\");\n   * const blob = new Blob([\"Hello, world!\"], { type: \"text/plain\" });\n   * const response = await nip96.upload(blob);\n   * console.log(response);\n   */\n  async upload(blob) {\n    const httpVerb = \"POST\";\n    const { url, headers } = await this.prepareUpload(blob, httpVerb);\n    const formData = new FormData();\n    formData.append(\"file\", blob);\n    const res = await this.ndk.httpFetch(this.spec.api_url, {\n      method: httpVerb,\n      headers,\n      body: formData\n    });\n    if (res.status !== 200) throw new Error(`Failed to upload file to ${url}`);\n    const json = await res.json();\n    if (json.status !== \"success\") throw new Error(json.message);\n    return json;\n  }\n  validateHttpFetch() {\n    if (!this.ndk) throw new Error(\"NDK is required to fetch NIP96 spec\");\n    if (!this.ndk.httpFetch)\n      throw new Error(\"NDK must have an httpFetch method to fetch NIP96 spec\");\n  }\n  async fetchSpec() {\n    this.validateHttpFetch();\n    const res = await this.ndk.httpFetch(this.url);\n    if (res.status !== 200) throw new Error(`Failed to fetch NIP96 spec from ${this.url}`);\n    const spec = await res.json();\n    if (!spec) throw new Error(`Failed to parse NIP96 spec from ${this.url}`);\n    this.spec = spec;\n    this.nip98Required = this.spec.plans.free.is_nip98_required;\n  }\n  async generateNip98Header(requestUrl, httpMethod, blob) {\n    const event = new NDKEvent(this.ndk, {\n      kind: 27235 /* HttpAuth */,\n      tags: [\n        [\"u\", requestUrl],\n        [\"method\", httpMethod]\n      ]\n    });\n    if ([\"POST\", \"PUT\", \"PATCH\"].includes(httpMethod)) {\n      const sha256Hash = await this.calculateSha256(blob);\n      event.tags.push([\"payload\", sha256Hash]);\n    }\n    await event.sign();\n    const encodedEvent = btoa(JSON.stringify(event.rawEvent()));\n    return `Nostr ${encodedEvent}`;\n  }\n  async calculateSha256(blob) {\n    const buffer = await blob.arrayBuffer();\n    const hashBuffer = await crypto.subtle.digest(\"SHA-256\", buffer);\n    const hashArray = Array.from(new Uint8Array(hashBuffer));\n    const hashHex = hashArray.map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n    return hashHex;\n  }\n};\n\n// src/ndk/queue/index.ts\nvar Queue = class {\n  queue = [];\n  maxConcurrency;\n  processing = /* @__PURE__ */ new Set();\n  promises = /* @__PURE__ */ new Map();\n  constructor(name, maxConcurrency) {\n    this.maxConcurrency = maxConcurrency;\n  }\n  add(item) {\n    if (this.promises.has(item.id)) {\n      return this.promises.get(item.id);\n    } else {\n    }\n    const promise = new Promise((resolve, reject) => {\n      this.queue.push({\n        ...item,\n        func: () => item.func().then(\n          (result) => {\n            resolve(result);\n            return result;\n          },\n          (error) => {\n            reject(error);\n            throw error;\n          }\n        )\n      });\n      this.process();\n    });\n    this.promises.set(item.id, promise);\n    promise.finally(() => {\n      this.promises.delete(item.id);\n      this.processing.delete(item.id);\n      this.process();\n    });\n    return promise;\n  }\n  process() {\n    if (this.processing.size >= this.maxConcurrency || this.queue.length === 0) {\n      return;\n    }\n    const item = this.queue.shift();\n    if (!item || this.processing.has(item.id)) {\n      return;\n    }\n    this.processing.add(item.id);\n    item.func();\n  }\n  clear() {\n    this.queue = [];\n  }\n  clearProcessing() {\n    this.processing.clear();\n  }\n  clearAll() {\n    this.clear();\n    this.clearProcessing();\n  }\n  length() {\n    return this.queue.length;\n  }\n};\n\n// src/subscription/manager.ts\n\nvar NDKSubscriptionManager = class {\n  subscriptions;\n  seenEvents = /* @__PURE__ */ new Map();\n  constructor() {\n    this.subscriptions = /* @__PURE__ */ new Map();\n  }\n  add(sub) {\n    this.subscriptions.set(sub.internalId, sub);\n    if (sub.onStopped) {\n      console.log(\"SUB-MANAGER BUG: Subscription already had onStopped! \\u{1F914}\", sub.internalId);\n    }\n    sub.onStopped = () => {\n      this.subscriptions.delete(sub.internalId);\n    };\n    sub.on(\"close\", () => {\n      this.subscriptions.delete(sub.internalId);\n    });\n  }\n  seenEvent(eventId, relay) {\n    const current = this.seenEvents.get(eventId) || [];\n    current.push(relay);\n    this.seenEvents.set(eventId, current);\n  }\n  /**\n   * Whenever an event comes in, this function is called.\n   * This function matches the received event against all the\n   * known (i.e. active) NDKSubscriptions, and if it matches,\n   * it sends the event to the subscription.\n   * \n   * This is the single place in the codebase that matches\n   * incoming events with parties interested in the event.\n   * \n   * This is also what allows for reactivity in NDK apps, such that\n   * whenever an active subscription receives an event that some\n   * other active subscription would want to receive, both receive it.\n   * \n   * TODO This also allows for subscriptions that overlap in meaning\n   * to be collapsed into one.\n   * \n   * I.e. if a subscription with filter: kinds: [1], authors: [alice]\n   * is created and EOSEs, and then a subsequent subscription with\n   * kinds: [1], authors: [alice] is created, once the second subscription\n   * EOSEs we can safely close it, increment its refCount and close it,\n   * and when the first subscription receives a new event from Alice this\n   * code will make the second subscription receive the event even though\n   * it has no active subscription on a relay.\n   * @param event Raw event received from a relay\n   * @param relay Relay that sent the event\n   * @param optimisticPublish Whether the event is coming from an optimistic publish\n   */\n  dispatchEvent(event, relay, optimisticPublish = false) {\n    if (relay) this.seenEvent(event.id, relay);\n    const subscriptions = this.subscriptions.values();\n    const matchingSubs = [];\n    for (const sub of subscriptions) {\n      if ((0,nostr_tools__WEBPACK_IMPORTED_MODULE_2__.matchFilters)(sub.filters, event)) {\n        matchingSubs.push(sub);\n      }\n    }\n    for (const sub of matchingSubs) {\n      sub.eventReceived(event, relay, false, optimisticPublish);\n    }\n  }\n};\n\n// src/ndk/active-user.ts\n\nvar debug6 = debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:active-user\");\nasync function getUserRelayList(user) {\n  if (!this.autoConnectUserRelays) return;\n  const userRelays = await getRelayListForUser(user.pubkey, this);\n  if (!userRelays) return;\n  for (const url of userRelays.relays) {\n    let relay = this.pool.relays.get(url);\n    if (!relay) {\n      relay = new NDKRelay(url, this.relayAuthDefaultPolicy, this);\n      this.pool.addRelay(relay);\n    }\n  }\n  return userRelays;\n}\nasync function setActiveUser(user) {\n  const pool = this.outboxPool || this.pool;\n  if (pool.connectedRelays.length > 0) {\n    setActiveUserConnected.call(this, user);\n  } else {\n    pool.once(\"connect\", () => {\n      setActiveUserConnected.call(this, user);\n    });\n  }\n}\nasync function setActiveUserConnected(user) {\n  const userRelays = await getUserRelayList.call(this, user);\n  const filters = [\n    {\n      kinds: [10006 /* BlockRelayList */],\n      authors: [user.pubkey]\n    }\n  ];\n  if (this.autoFetchUserMutelist) {\n    filters[0].kinds.push(1e4 /* MuteList */);\n  }\n  const relaySet = userRelays ? userRelays.relaySet : void 0;\n  const sub = this.subscribe(\n    filters,\n    { subId: \"active-user-settings\", closeOnEose: true },\n    relaySet,\n    false\n  );\n  const events = /* @__PURE__ */ new Map();\n  sub.on(\"event\", (event) => {\n    const prevEvent = events.get(event.kind);\n    if (prevEvent && prevEvent.created_at >= event.created_at) return;\n    events.set(event.kind, event);\n  });\n  sub.on(\"eose\", () => {\n    for (const event of events.values()) {\n      processEvent.call(this, event);\n    }\n  });\n  sub.start();\n}\nasync function processEvent(event) {\n  if (event.kind === 10006 /* BlockRelayList */) {\n    processBlockRelayList.call(this, event);\n  } else if (event.kind === 1e4 /* MuteList */) {\n    processMuteList.call(this, event);\n  }\n}\nfunction processBlockRelayList(event) {\n  const list = lists_default.from(event);\n  for (const item of list.items) {\n    this.pool.blacklistRelayUrls.add(item[0]);\n  }\n  debug6(\"Added %d relays to relay blacklist\", list.items.length);\n}\nfunction processMuteList(muteList) {\n  const list = lists_default.from(muteList);\n  for (const item of list.items) {\n    this.mutedIds.set(item[1], item[0]);\n  }\n  debug6(\"Added %d users to mute list\", list.items.length);\n}\n\n// src/ndk/index.ts\nvar DEFAULT_OUTBOX_RELAYS = [\"wss://purplepag.es/\", \"wss://nos.lol/\"];\nvar DEFAULT_BLACKLISTED_RELAYS = [\n  \"wss://brb.io/\",\n  // BRB\n  \"wss://nostr.mutinywallet.com/\"\n  // Don't try to read from this relay since it's a write-only relay\n  // \"wss://purplepag.es/\", // This is a hack, since this is a mostly read-only relay, but not fully. Once we have relay routing this can be removed so it only receives the supported kinds\n];\nvar NDK = class extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  _explicitRelayUrls;\n  blacklistRelayUrls;\n  pool;\n  outboxPool;\n  _signer;\n  _activeUser;\n  cacheAdapter;\n  debug;\n  devWriteRelaySet;\n  outboxTracker;\n  mutedIds;\n  clientName;\n  clientNip89;\n  queuesZapConfig;\n  queuesNip05;\n  asyncSigVerification = false;\n  initialValidationRatio = 1;\n  lowestValidationRatio = 1;\n  validationRatioFn;\n  subManager;\n  publishingFailureHandled = false;\n  pools = [];\n  /**\n   * Default relay-auth policy that will be used when a relay requests authentication,\n   * if no other policy is specified for that relay.\n   *\n   * @example Disconnect from relays that request authentication:\n   * ```typescript\n   * ndk.relayAuthDefaultPolicy = NDKAuthPolicies.disconnect(ndk.pool);\n   * ```\n   *\n   * @example Sign in to relays that request authentication:\n   * ```typescript\n   * ndk.relayAuthDefaultPolicy = NDKAuthPolicies.signIn({ndk})\n   * ```\n   *\n   * @example Sign in to relays that request authentication, asking the user for confirmation:\n   * ```typescript\n   * ndk.relayAuthDefaultPolicy = (relay: NDKRelay) => {\n   *     const signIn = NDKAuthPolicies.signIn({ndk});\n   *     if (confirm(`Relay ${relay.url} is requesting authentication, do you want to sign in?`)) {\n   *        signIn(relay);\n   *     }\n   * }\n   * ```\n   */\n  relayAuthDefaultPolicy;\n  /**\n   * Fetch function to use for HTTP requests.\n   *\n   * @example\n   * ```typescript\n   * import fetch from \"node-fetch\";\n   *\n   * ndk.httpFetch = fetch;\n   * ```\n   */\n  httpFetch;\n  /**\n   * Provide a caller function to receive all networking traffic from relays\n   */\n  netDebug;\n  autoConnectUserRelays = true;\n  autoFetchUserMutelist = true;\n  walletConfig;\n  constructor(opts = {}) {\n    super();\n    this.debug = opts.debug || debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk\");\n    this.netDebug = opts.netDebug;\n    this._explicitRelayUrls = opts.explicitRelayUrls || [];\n    this.blacklistRelayUrls = opts.blacklistRelayUrls || DEFAULT_BLACKLISTED_RELAYS;\n    this.subManager = new NDKSubscriptionManager();\n    this.pool = new NDKPool(\n      opts.explicitRelayUrls || [],\n      [],\n      this\n    );\n    this.pool.name = \"Main\";\n    this.pool.on(\"relay:auth\", async (relay, challenge) => {\n      if (this.relayAuthDefaultPolicy) {\n        await this.relayAuthDefaultPolicy(relay, challenge);\n      }\n    });\n    this.autoConnectUserRelays = opts.autoConnectUserRelays ?? true;\n    this.autoFetchUserMutelist = opts.autoFetchUserMutelist ?? true;\n    this.clientName = opts.clientName;\n    this.clientNip89 = opts.clientNip89;\n    this.relayAuthDefaultPolicy = opts.relayAuthDefaultPolicy;\n    if (opts.enableOutboxModel) {\n      this.outboxPool = new NDKPool(\n        opts.outboxRelayUrls || DEFAULT_OUTBOX_RELAYS,\n        [],\n        this,\n        {\n          debug: this.debug.extend(\"outbox-pool\"),\n          name: \"Outbox Pool\"\n        }\n      );\n      this.outboxTracker = new OutboxTracker(this);\n    }\n    this.signer = opts.signer;\n    this.cacheAdapter = opts.cacheAdapter;\n    this.mutedIds = opts.mutedIds || /* @__PURE__ */ new Map();\n    if (opts.devWriteRelayUrls) {\n      this.devWriteRelaySet = NDKRelaySet.fromRelayUrls(opts.devWriteRelayUrls, this);\n    }\n    this.queuesZapConfig = new Queue(\"zaps\", 3);\n    this.queuesNip05 = new Queue(\"nip05\", 10);\n    this.signatureVerificationWorker = opts.signatureVerificationWorker;\n    this.initialValidationRatio = opts.initialValidationRatio || 1;\n    this.lowestValidationRatio = opts.lowestValidationRatio || 1;\n    try {\n      this.httpFetch = fetch;\n    } catch {\n    }\n  }\n  set explicitRelayUrls(urls) {\n    this._explicitRelayUrls = urls;\n    this.pool.relayUrls = urls;\n  }\n  get explicitRelayUrls() {\n    return this._explicitRelayUrls || [];\n  }\n  set signatureVerificationWorker(worker2) {\n    this.asyncSigVerification = !!worker2;\n    if (worker2) {\n      signatureVerificationInit(worker2);\n    }\n  }\n  /**\n   * Adds an explicit relay to the pool.\n   * @param url\n   * @param relayAuthPolicy Authentication policy to use if different from the default\n   * @param connect Whether to connect to the relay automatically\n   * @returns\n   */\n  addExplicitRelay(urlOrRelay, relayAuthPolicy, connect = true) {\n    let relay;\n    if (typeof urlOrRelay === \"string\") {\n      relay = new NDKRelay(urlOrRelay, relayAuthPolicy, this);\n    } else {\n      relay = urlOrRelay;\n    }\n    this.pool.addRelay(relay, connect);\n    this.explicitRelayUrls.push(relay.url);\n    return relay;\n  }\n  toJSON() {\n    return { relayCount: this.pool.relays.size }.toString();\n  }\n  get activeUser() {\n    return this._activeUser;\n  }\n  /**\n   * Sets the active user for this NDK instance, typically this will be\n   * called when assigning a signer to the NDK instance.\n   *\n   * This function will automatically connect to the user's relays if\n   * `autoConnectUserRelays` is set to true.\n   *\n   * It will also fetch the user's mutelist if `autoFetchUserMutelist` is set to true.\n   */\n  set activeUser(user) {\n    const differentUser = this._activeUser?.pubkey !== user?.pubkey;\n    this._activeUser = user;\n    if (user && differentUser) {\n      setActiveUser.call(this, user);\n    } else if (!user) {\n      this.mutedIds = /* @__PURE__ */ new Map();\n    }\n  }\n  get signer() {\n    return this._signer;\n  }\n  set signer(newSigner) {\n    this._signer = newSigner;\n    if (newSigner) this.emit(\"signer:ready\", newSigner);\n    newSigner?.user().then((user) => {\n      user.ndk = this;\n      this.activeUser = user;\n    });\n  }\n  /**\n   * Connect to relays with optional timeout.\n   * If the timeout is reached, the connection will be continued to be established in the background.\n   */\n  async connect(timeoutMs) {\n    if (this._signer && this.autoConnectUserRelays) {\n      this.debug(\n        \"Attempting to connect to user relays specified by signer %o\",\n        await this._signer.relays?.(this)\n      );\n      if (this._signer.relays) {\n        const relays = await this._signer.relays(this);\n        relays.forEach((relay) => this.pool.addRelay(relay));\n      }\n    }\n    const connections = [this.pool.connect(timeoutMs)];\n    if (this.outboxPool) {\n      connections.push(this.outboxPool.connect(timeoutMs));\n    }\n    this.debug(\"Connecting to relays %o\", { timeoutMs });\n    return Promise.allSettled(connections).then(() => {\n    });\n  }\n  /**\n   * Get a NDKUser object\n   *\n   * @param opts\n   * @returns\n   */\n  getUser(opts) {\n    const user = new NDKUser(opts);\n    user.ndk = this;\n    return user;\n  }\n  /**\n   * Get a NDKUser from a NIP05\n   * @param nip05 NIP-05 ID\n   * @param skipCache Skip cache\n   * @returns\n   */\n  async getUserFromNip05(nip05, skipCache = false) {\n    return NDKUser.fromNip05(nip05, this, skipCache);\n  }\n  /**\n   * Create a new subscription. Subscriptions automatically start, you can make them automatically close when all relays send back an EOSE by setting `opts.closeOnEose` to `true`)\n   *\n   * @param filters\n   * @param opts\n   * @param relaySet explicit relay set to use\n   * @param autoStart automatically start the subscription -- this can be a boolean or an object with `onEvent` and `onEose` handlers\n   * @returns NDKSubscription\n   */\n  subscribe(filters, opts, relaySet, autoStart = true) {\n    const subscription = new NDKSubscription(this, filters, opts, relaySet);\n    this.subManager.add(subscription);\n    const pool = opts?.pool ?? this.pool;\n    if (relaySet) {\n      for (const relay of relaySet.relays) {\n        pool.useTemporaryRelay(relay, void 0, subscription.filters);\n      }\n    }\n    if (this.outboxPool && subscription.hasAuthorsFilter()) {\n      const authors = subscription.filters.filter((filter) => filter.authors && filter.authors?.length > 0).map((filter) => filter.authors).flat();\n      this.outboxTracker?.trackUsers(authors);\n    }\n    if (autoStart) {\n      let eventsHandler;\n      if (typeof autoStart === \"object\") {\n        if (autoStart.onEvent) subscription.on(\"event\", autoStart.onEvent);\n        if (autoStart.onEose) subscription.on(\"eose\", autoStart.onEose);\n        if (autoStart.onEvents) eventsHandler = autoStart.onEvents;\n      }\n      setTimeout(() => {\n        const cachedEvents = subscription.start(!eventsHandler);\n        if (cachedEvents && !!eventsHandler) eventsHandler(cachedEvents);\n      }, 0);\n    }\n    return subscription;\n  }\n  /**\n   * Publish an event to a relay\n   * @param event event to publish\n   * @param relaySet explicit relay set to use\n   * @param timeoutMs timeout in milliseconds to wait for the event to be published\n   * @returns The relays the event was published to\n   *\n   * @deprecated Use `event.publish()` instead\n   */\n  async publish(event, relaySet, timeoutMs) {\n    this.debug(\"Deprecated: Use `event.publish()` instead\");\n    return event.publish(relaySet, timeoutMs);\n  }\n  /**\n   * Attempts to fetch an event from a tag, following relay hints and\n   * other best practices.\n   * @param tag Tag to fetch the event from\n   * @param originalEvent Event where the tag came from\n   * @param subOpts Subscription options to use when fetching the event\n   * @param fallback Fallback options to use when the hint relay doesn't respond\n   * @returns\n   */\n  fetchEventFromTag = fetchEventFromTag.bind(this);\n  /**\n   * Fetch an event from the cache synchronously.\n   * @param idOrFilter event id in bech32 format or filter\n   * @returns events from the cache or null if the cache is empty\n   */\n  fetchEventSync(idOrFilter) {\n    if (!this.cacheAdapter) throw new Error(\"Cache adapter not set\");\n    let filters;\n    if (typeof idOrFilter === \"string\") filters = [filterFromId(idOrFilter)];\n    else filters = idOrFilter;\n    const sub = new NDKSubscription(this, filters);\n    const events = this.cacheAdapter.query(sub);\n    if (events instanceof Promise) throw new Error(\"Cache adapter is async\");\n    return events.map((e) => {\n      e.ndk = this;\n      return e;\n    });\n  }\n  /**\n   * Fetch a single event.\n   *\n   * @param idOrFilter event id in bech32 format or filter\n   * @param opts subscription options\n   * @param relaySetOrRelay explicit relay set to use\n   */\n  async fetchEvent(idOrFilter, opts, relaySetOrRelay) {\n    let filters;\n    let relaySet;\n    if (relaySetOrRelay instanceof NDKRelay) {\n      relaySet = new NDKRelaySet(/* @__PURE__ */ new Set([relaySetOrRelay]), this);\n    } else if (relaySetOrRelay instanceof NDKRelaySet) {\n      relaySet = relaySetOrRelay;\n    }\n    if (!relaySetOrRelay && typeof idOrFilter === \"string\") {\n      if (!isNip33AValue(idOrFilter)) {\n        const relays = relaysFromBech32(idOrFilter, this);\n        if (relays.length > 0) {\n          relaySet = new NDKRelaySet(new Set(relays), this);\n          relaySet = correctRelaySet(relaySet, this.pool);\n        }\n      }\n    }\n    if (typeof idOrFilter === \"string\") {\n      filters = [filterFromId(idOrFilter)];\n    } else if (Array.isArray(idOrFilter)) {\n      filters = idOrFilter;\n    } else {\n      filters = [idOrFilter];\n    }\n    if (filters.length === 0) {\n      throw new Error(`Invalid filter: ${JSON.stringify(idOrFilter)}`);\n    }\n    return new Promise((resolve) => {\n      let fetchedEvent = null;\n      const s = this.subscribe(\n        filters,\n        { ...opts || {}, closeOnEose: true },\n        relaySet,\n        false\n      );\n      const t2 = setTimeout(() => {\n        s.stop();\n        resolve(fetchedEvent);\n      }, 1e4);\n      s.on(\"event\", (event) => {\n        event.ndk = this;\n        if (!event.isReplaceable()) {\n          clearTimeout(t2);\n          resolve(event);\n        } else if (!fetchedEvent || fetchedEvent.created_at < event.created_at) {\n          fetchedEvent = event;\n        }\n      });\n      s.on(\"eose\", () => {\n        clearTimeout(t2);\n        resolve(fetchedEvent);\n      });\n      s.start();\n    });\n  }\n  /**\n   * Fetch events\n   */\n  async fetchEvents(filters, opts, relaySet) {\n    return new Promise((resolve) => {\n      const events = /* @__PURE__ */ new Map();\n      const relaySetSubscription = this.subscribe(\n        filters,\n        { ...opts || {}, closeOnEose: true },\n        relaySet,\n        false\n      );\n      const onEvent = (event) => {\n        if (!(event instanceof NDKEvent)) event = new NDKEvent(void 0, event);\n        const dedupKey = event.deduplicationKey();\n        const existingEvent = events.get(dedupKey);\n        if (existingEvent) {\n          event = dedup(existingEvent, event);\n        }\n        event.ndk = this;\n        events.set(dedupKey, event);\n      };\n      relaySetSubscription.on(\"event\", onEvent);\n      relaySetSubscription.on(\"eose\", () => {\n        resolve(new Set(events.values()));\n      });\n      relaySetSubscription.start();\n    });\n  }\n  /**\n   * Ensures that a signer is available to sign an event.\n   */\n  assertSigner() {\n    if (!this.signer) {\n      this.emit(\"signer:required\");\n      throw new Error(\"Signer required\");\n    }\n  }\n  /**\n   * Creates a new Nip96 instance for the given domain.\n   * @param domain Domain to use for nip96 uploads\n   * @example Upload a file to a NIP-96 enabled domain:\n   *\n   * ```typescript\n   * const blob = new Blob([\"Hello, world!\"], { type: \"text/plain\" });\n   * const nip96 = ndk.getNip96(\"nostrcheck.me\");\n   * await nip96.upload(blob);\n   * ```\n   */\n  getNip96(domain) {\n    return new Nip96(domain, this);\n  }\n  set wallet(wallet) {\n    if (!wallet) {\n      this.walletConfig = void 0;\n      return;\n    }\n    this.walletConfig ??= {};\n    this.walletConfig.lnPay = wallet?.lnPay?.bind(wallet);\n    this.walletConfig.cashuPay = wallet?.cashuPay?.bind(wallet);\n  }\n};\n\n// src/zap/invoice.ts\n\nfunction zapInvoiceFromEvent(event) {\n  const description = event.getMatchingTags(\"description\")[0];\n  const bolt11 = event.getMatchingTags(\"bolt11\")[0];\n  let decodedInvoice;\n  let zapRequest;\n  if (!description || !bolt11 || !bolt11[1]) {\n    return null;\n  }\n  try {\n    let zapRequestPayload = description[1];\n    if (zapRequestPayload.startsWith(\"%\")) {\n      zapRequestPayload = decodeURIComponent(zapRequestPayload);\n    }\n    if (zapRequestPayload === \"\") {\n      return null;\n    }\n    zapRequest = JSON.parse(zapRequestPayload);\n    decodedInvoice = (0,light_bolt11_decoder__WEBPACK_IMPORTED_MODULE_7__.decode)(bolt11[1]);\n  } catch (e) {\n    return null;\n  }\n  const amountSection = decodedInvoice.sections.find((s) => s.name === \"amount\");\n  if (!amountSection) {\n    return null;\n  }\n  const amount = parseInt(amountSection.value);\n  if (!amount) {\n    return null;\n  }\n  const content = zapRequest.content;\n  const sender = zapRequest.pubkey;\n  const recipientTag = event.getMatchingTags(\"p\")[0];\n  const recipient = recipientTag[1];\n  let zappedEvent = event.getMatchingTags(\"e\")[0];\n  if (!zappedEvent) {\n    zappedEvent = event.getMatchingTags(\"a\")[0];\n  }\n  const zappedEventId = zappedEvent ? zappedEvent[1] : void 0;\n  const zapInvoice = {\n    id: event.id,\n    zapper: event.pubkey,\n    zappee: sender,\n    zapped: recipient,\n    zappedEvent: zappedEventId,\n    amount,\n    comment: content\n  };\n  return zapInvoice;\n}\n\n// src/zapper/index.ts\n\n\n\n// src/zapper/nip57.ts\n\nasync function generateZapRequest(target, ndk, data, pubkey, amount, relays, comment, tags, signer) {\n  const zapEndpoint = data.callback;\n  const zapRequest = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip57.makeZapRequest({\n    profile: pubkey,\n    // set the event to null since nostr-tools doesn't support nip-33 zaps\n    event: null,\n    amount,\n    comment: comment || \"\",\n    relays: relays.slice(0, 4)\n  });\n  if (target instanceof NDKEvent) {\n    const tags2 = target.referenceTags();\n    const nonPTags = tags2.filter((tag) => tag[0] !== \"p\");\n    zapRequest.tags.push(...nonPTags);\n  }\n  zapRequest.tags.push([\"lnurl\", zapEndpoint]);\n  const event = new NDKEvent(ndk, zapRequest);\n  if (tags) {\n    event.tags = event.tags.concat(tags);\n  }\n  if (event.hasTag(\"a\")) {\n    event.tags = event.tags.filter((tag) => tag[0] !== \"e\");\n  }\n  event.tags = event.tags.filter((tag) => tag[0] !== \"p\");\n  event.tags.push([\"p\", pubkey]);\n  await event.sign(signer);\n  return event;\n}\n\n// src/zapper/ln.ts\n\n\nvar d2 = debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:zapper:ln\");\nasync function getNip57ZapSpecFromLud({ lud06, lud16 }, ndk) {\n  let zapEndpoint;\n  if (lud16 && !lud16.startsWith(\"LNURL\")) {\n    const [name, domain] = lud16.split(\"@\");\n    zapEndpoint = `https://${domain}/.well-known/lnurlp/${name}`;\n  } else if (lud06) {\n    const { words } = _scure_base__WEBPACK_IMPORTED_MODULE_8__.bech32.decode(lud06, 1e3);\n    const data = _scure_base__WEBPACK_IMPORTED_MODULE_8__.bech32.fromWords(words);\n    const utf8Decoder = new TextDecoder(\"utf-8\");\n    zapEndpoint = utf8Decoder.decode(data);\n  }\n  if (!zapEndpoint) {\n    d2(\"No zap endpoint found %o\", { lud06, lud16 });\n    throw new Error(\"No zap endpoint found\");\n  }\n  try {\n    const _fetch = ndk.httpFetch || fetch;\n    const response = await _fetch(zapEndpoint);\n    if (response.status !== 200) {\n      const text = await response.text();\n      throw new Error(`Unable to fetch zap endpoint ${zapEndpoint}: ${text}`);\n    }\n    return await response.json();\n  } catch (e) {\n    throw new Error(`Unable to fetch zap endpoint ${zapEndpoint}: ${e}`);\n  }\n}\n\n// src/zapper/index.ts\nvar d3 = debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:zapper\");\nvar NDKZapper = class extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  target;\n  ndk;\n  comment;\n  amount;\n  unit;\n  tags;\n  signer;\n  zapMethod;\n  nutzapAsFallback;\n  lnPay;\n  /**\n   * Called when a cashu payment is to be made.\n   * This function should swap/mint proofs for the required amount, in the required unit,\n   * in any of the provided mints and return the proofs and mint used.\n   */\n  cashuPay;\n  onComplete;\n  maxRelays = 3;\n  /**\n   * \n   * @param target The target of the zap\n   * @param amount The amount to send indicated in the unit\n   * @param unit The unit of the amount\n   * @param opts Options for the zap\n   */\n  constructor(target, amount, unit = \"msat\", opts = {}) {\n    super();\n    this.target = target;\n    this.ndk = opts.ndk || target.ndk;\n    if (!this.ndk) {\n      throw new Error(\"No NDK instance provided\");\n    }\n    this.amount = amount;\n    this.comment = opts.comment;\n    this.unit = unit;\n    this.tags = opts.tags;\n    this.signer = opts.signer;\n    this.nutzapAsFallback = opts.nutzapAsFallback ?? false;\n    this.lnPay = opts.lnPay || this.ndk.walletConfig?.lnPay;\n    this.cashuPay = opts.cashuPay || this.ndk.walletConfig?.cashuPay;\n    this.onComplete = opts.onComplete || this.ndk.walletConfig?.onPaymentComplete;\n  }\n  /**\n   * Initiate zapping process\n   * \n   * This function will calculate the splits for this zap and initiate each zap split.\n   */\n  async zap(methods) {\n    const splits = this.getZapSplits();\n    const results = /* @__PURE__ */ new Map();\n    await Promise.all(\n      splits.map(async (split) => {\n        let result;\n        try {\n          result = await this.zapSplit(split, methods);\n        } catch (e) {\n          result = new Error(e.message);\n        }\n        this.emit(\"split:complete\", split, result);\n        results.set(split, result);\n      })\n    );\n    this.emit(\"complete\", results);\n    if (this.onComplete) this.onComplete(results);\n    return results;\n  }\n  async zapNip57(split, data) {\n    if (!this.lnPay) throw new Error(\"No lnPay function available\");\n    const zapSpec = await getNip57ZapSpecFromLud(data, this.ndk);\n    if (!zapSpec) throw new Error(\"No zap spec available for recipient\");\n    const relays = await this.relays(split.pubkey);\n    const zapRequest = await generateZapRequest(\n      this.target,\n      this.ndk,\n      zapSpec,\n      split.pubkey,\n      split.amount,\n      relays,\n      this.comment,\n      this.tags,\n      this.signer\n    );\n    if (!zapRequest) {\n      d3(\"Unable to generate zap request\");\n      throw new Error(\"Unable to generate zap request\");\n    }\n    const pr = await this.getLnInvoice(zapRequest, split.amount, zapSpec);\n    if (!pr) {\n      d3(\"Unable to get payment request\");\n      throw new Error(\"Unable to get payment request\");\n    }\n    this.emit(\"ln_invoice\", {\n      amount: split.amount,\n      recipientPubkey: split.pubkey,\n      unit: this.unit,\n      nip57ZapRequest: zapRequest,\n      pr,\n      type: \"nip57\"\n    });\n    const res = await this.lnPay(\n      {\n        target: this.target,\n        recipientPubkey: split.pubkey,\n        paymentDescription: \"NIP-57 Zap\",\n        pr,\n        amount: split.amount,\n        unit: this.unit,\n        nip57ZapRequest: zapRequest\n      }\n    );\n    if (res?.preimage) {\n      this.emit(\"ln_payment\", {\n        preimage: res.preimage,\n        amount: split.amount,\n        recipientPubkey: split.pubkey,\n        pr,\n        unit: this.unit,\n        nip57ZapRequest: zapRequest,\n        type: \"nip57\"\n      });\n    }\n    return res;\n  }\n  /**\n   * Fetches information about a NIP-61 zap and asks the caller to create cashu proofs for the zap.\n   * \n   * (note that the cashuPay function can use any method to create the proofs, including using lightning\n   * to mint proofs in the specified mint, the responsibility of minting the proofs is delegated to the caller (e.g. ndk-wallet))\n   */\n  async zapNip61(split, data) {\n    if (!this.cashuPay) throw new Error(\"No cashuPay function available\");\n    let ret;\n    ret = await this.cashuPay({\n      target: this.target,\n      recipientPubkey: split.pubkey,\n      paymentDescription: \"NIP-61 Zap\",\n      amount: split.amount,\n      unit: this.unit,\n      ...data ?? {}\n    }, (pr) => {\n      this.emit(\"ln_invoice\", {\n        pr,\n        amount: split.amount,\n        recipientPubkey: split.pubkey,\n        unit: this.unit,\n        type: \"nip61\"\n      });\n    });\n    d3(\"NIP-61 Zap result: %o\", ret);\n    if (ret instanceof Error) {\n      return ret;\n    } else if (ret) {\n      const { proofs, mint } = ret;\n      if (!proofs || !mint)\n        throw new Error(\n          \"Invalid zap confirmation: missing proofs or mint: \" + ret\n        );\n      const relays = await this.relays(split.pubkey);\n      const relaySet = NDKRelaySet.fromRelayUrls(relays, this.ndk);\n      const nutzap = new NDKNutzap(this.ndk);\n      nutzap.tags = [...nutzap.tags, ...this.tags || []];\n      nutzap.proofs = proofs;\n      nutzap.mint = mint;\n      nutzap.target = this.target;\n      nutzap.comment = this.comment;\n      nutzap.unit = this.unit;\n      nutzap.recipientPubkey = split.pubkey;\n      await nutzap.sign(this.signer);\n      nutzap.publish(relaySet);\n      return nutzap;\n    }\n  }\n  /**\n   * Get the zap methods available for the recipient and initiates the zap\n   * in the desired method.\n   * @param split \n   * @param methods - The methods to try, if not provided, all methods will be tried.\n   * @returns \n   */\n  async zapSplit(split, methods) {\n    const recipient = this.ndk.getUser({ pubkey: split.pubkey });\n    let zapMethods = await recipient.getZapInfo(2500);\n    let retVal;\n    const canFallbackToNip61 = this.nutzapAsFallback && this.cashuPay;\n    if (zapMethods.size === 0 && !canFallbackToNip61) throw new Error(\"No zap method available for recipient and NIP-61 fallback is disabled\");\n    const nip61Fallback = async () => {\n      if (!this.nutzapAsFallback) return;\n      const relayLists = await getRelayListForUsers([split.pubkey], this.ndk);\n      let relayUrls = relayLists.get(split.pubkey)?.readRelayUrls;\n      relayUrls = this.ndk.pool.connectedRelays().map((r) => r.url);\n      return await this.zapNip61(split, {\n        // use the user's relay list\n        relays: relayUrls,\n        // lock to the user's actual pubkey\n        p2pk: split.pubkey,\n        // allow intramint fallback\n        allowIntramintFallback: !!canFallbackToNip61\n      });\n    };\n    const canUseNip61 = !methods || methods.includes(\"nip61\");\n    const canUseNip57 = !methods || methods.includes(\"nip57\");\n    const nip61Method = zapMethods.get(\"nip61\");\n    if (nip61Method && canUseNip61) {\n      try {\n        retVal = await this.zapNip61(split, nip61Method);\n        if (retVal instanceof NDKNutzap) return retVal;\n      } catch (e) {\n        this.emit(\"notice\", `NIP-61 attempt failed: ${e.message}`);\n      }\n    }\n    const nip57Method = zapMethods.get(\"nip57\");\n    if (nip57Method && canUseNip57) {\n      try {\n        retVal = await this.zapNip57(split, nip57Method);\n        if (!(retVal instanceof Error)) return retVal;\n      } catch (e) {\n        this.emit(\"notice\", `NIP-57 attempt failed: ${e.message}`);\n      }\n    }\n    if (canFallbackToNip61) {\n      retVal = await nip61Fallback();\n      if (retVal instanceof Error) throw retVal;\n      return retVal;\n    } else {\n      this.emit(\"notice\", \"Zap methods exhausted and there was no fallback to NIP-61\");\n    }\n    if (retVal instanceof Error) throw retVal;\n    return retVal;\n  }\n  /**\n   * Gets a bolt11 for a nip57 zap\n   * @param event\n   * @param amount\n   * @param zapEndpoint\n   * @returns\n   */\n  async getLnInvoice(zapRequest, amount, data) {\n    const zapEndpoint = data.callback;\n    const eventPayload = JSON.stringify(zapRequest.rawEvent());\n    d3(\n      `Fetching invoice from ${zapEndpoint}?` + new URLSearchParams({\n        amount: amount.toString(),\n        nostr: eventPayload\n      })\n    );\n    const url = new URL(zapEndpoint);\n    url.searchParams.append(\"amount\", amount.toString());\n    url.searchParams.append(\"nostr\", eventPayload);\n    d3(`Fetching invoice from ${url.toString()}`);\n    const response = await fetch(url.toString());\n    d3(`Got response from zap endpoint: ${zapEndpoint}`, { status: response.status });\n    if (response.status !== 200) {\n      d3(`Received non-200 status from zap endpoint: ${zapEndpoint}`, {\n        status: response.status,\n        amount,\n        nostr: eventPayload\n      });\n      const text = await response.text();\n      throw new Error(`Unable to fetch zap endpoint ${zapEndpoint}: ${text}`);\n    }\n    const body = await response.json();\n    return body.pr;\n  }\n  getZapSplits() {\n    if (this.target instanceof NDKUser) {\n      return [\n        {\n          pubkey: this.target.pubkey,\n          amount: this.amount\n        }\n      ];\n    }\n    const zapTags = this.target.getMatchingTags(\"zap\");\n    if (zapTags.length === 0) {\n      return [\n        {\n          pubkey: this.target.pubkey,\n          amount: this.amount\n        }\n      ];\n    }\n    const splits = [];\n    const total = zapTags.reduce((acc, tag) => acc + parseInt(tag[2]), 0);\n    for (const tag of zapTags) {\n      const pubkey = tag[1];\n      const amount = Math.floor(parseInt(tag[2]) / total * this.amount);\n      splits.push({ pubkey, amount });\n    }\n    return splits;\n  }\n  /**\n   * Gets the zap method that should be used to zap a pubbkey\n   * @param ndk\n   * @param pubkey\n   * @returns\n   */\n  async getZapMethods(ndk, recipient, timeout = 2500) {\n    const user = ndk.getUser({ pubkey: recipient });\n    return await user.getZapInfo(timeout);\n  }\n  /**\n   * @returns the relays to use for the zap request\n   */\n  async relays(pubkey) {\n    let r = [];\n    if (this.ndk?.activeUser) {\n      const relayLists = await getRelayListForUsers(\n        [this.ndk.activeUser.pubkey, pubkey],\n        this.ndk\n      );\n      const relayScores = /* @__PURE__ */ new Map();\n      for (const relayList of relayLists.values()) {\n        for (const url of relayList.readRelayUrls) {\n          const score = relayScores.get(url) || 0;\n          relayScores.set(url, score + 1);\n        }\n      }\n      r = Array.from(relayScores.entries()).sort((a, b) => b[1] - a[1]).map(([url]) => url).slice(0, this.maxRelays);\n    }\n    if (this.ndk?.pool?.permanentAndConnectedRelays().length) {\n      r = this.ndk.pool.permanentAndConnectedRelays().map((relay) => relay.url);\n    }\n    if (!r.length) {\n      r = [];\n    }\n    return r;\n  }\n};\n\n// src/utils/filter.ts\nfunction matchFilter(filter, event) {\n  if (filter.ids && filter.ids.indexOf(event.id) === -1) {\n    return false;\n  }\n  if (filter.kinds && filter.kinds.indexOf(event.kind) === -1) {\n    return false;\n  }\n  if (filter.authors && filter.authors.indexOf(event.pubkey) === -1) {\n    return false;\n  }\n  for (let f in filter) {\n    if (f[0] === \"#\") {\n      let tagName = f.slice(1);\n      if (tagName === \"t\") {\n        let values = filter[`#${tagName}`]?.map((v) => v.toLowerCase());\n        if (values && !event.tags.find(([t, v]) => t === tagName && values.indexOf(v.toLowerCase()) !== -1)) return false;\n      } else {\n        let values = filter[`#${tagName}`];\n        if (values && !event.tags.find(([t, v]) => t === tagName && values.indexOf(v) !== -1)) return false;\n      }\n    }\n  }\n  if (filter.since && event.created_at < filter.since) return false;\n  if (filter.until && event.created_at > filter.until) return false;\n  return true;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9zdHItZGV2LWtpdC9uZGsvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZUFBZTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ3NEOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsV0FBVztBQUNYO0FBQ0EsZ0VBQWdFLHlCQUF5QixJQUFJO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLFVBQVUsd0NBQXdDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUVBQW1FLDJCQUEyQjtBQUM5Rjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxXQUFXO0FBQ2hEO0FBQ0E7QUFDQSxvQ0FBb0MsVUFBVTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLElBQUksRUFBRSxZQUFZLE1BQU0sT0FBTztBQUM3QyxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMkJBQTJCLEdBQUcsR0FBRyw4QkFBOEIsRUFBRSxXQUFXLEtBQUssT0FBTztBQUN6RztBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsd0JBQXdCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsS0FBSztBQUNuRDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLEdBQUc7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsR0FBRztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxLQUFLLGFBQWEsS0FBSztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQzBCO0FBQ1c7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTix5Q0FBeUMsa0JBQWtCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGtCQUFrQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxHQUFHO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxzQ0FBc0Msa0JBQWtCLElBQUksY0FBYztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsaUtBQWlLO0FBQ2pNO0FBQ0E7QUFDQSw4Q0FBOEMsdUJBQXVCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtB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O0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsVUFBVSxJQUFJLElBQUk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyx3Q0FBd0M7QUFDOUU7QUFDQTtBQUNBLG9DQUFvQyx3QkFBd0I7QUFDNUQsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELFVBQVU7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixnQ0FBZ0MsbUNBQW1DO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ2dDO0FBQ2hDLFFBQVEsa0NBQVc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxJQUFJO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsYUFBYSxFQUFFLDhDQUFLO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixhQUFhO0FBQ25DLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3QixNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHFCQUFxQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDhDQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSixXQUFXLDhDQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0osV0FBVyw4Q0FBTTtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixVQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDOEM7QUFDRztBQUNDOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNnRDtBQUNoRCw4QkFBOEIsR0FBRztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwwREFBUTtBQUNyQztBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOLG1CQUFtQiw0REFBTTtBQUN6QixrQkFBa0IsNERBQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNERBQU07QUFDMUIsU0FBUywrREFBVTtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QywrQ0FBYTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxxQkFBcUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsYUFBYSxJQUFJLFNBQVM7QUFDL0M7QUFDQTtBQUNBLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHFCQUFxQjtBQUM5QztBQUNBO0FBQ0E7QUFDQSwwQkFBMEIseUJBQXlCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix3Q0FBd0M7QUFDbEU7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHFCQUFxQjtBQUM5QztBQUNBO0FBQ0E7QUFDQSwyREFBMkQsS0FBSztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCLGVBQWUscUJBQXFCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsUUFBUTtBQUM3QixlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsYUFBYTtBQUNuQyxzQkFBc0IsUUFBUTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVLEdBQUcsWUFBWTtBQUN6QyxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVLEdBQUcsWUFBWSxHQUFHLE9BQU87QUFDbkQsTUFBTTtBQUNOLGdCQUFnQixVQUFVLEdBQUcsWUFBWTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUNBQWlDLDBEQUEwRDtBQUMzRixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsMERBQTBEO0FBQy9GLCtCQUErQjtBQUMvQjtBQUNBLHFDQUFxQywwQ0FBMEM7QUFDL0UsK0JBQStCO0FBQy9CLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsMERBQTBEO0FBQy9GLGdDQUFnQztBQUNoQztBQUNBLHFDQUFxQywwQ0FBMEM7QUFDL0UsZ0NBQWdDO0FBQ2hDLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQywwREFBMEQ7QUFDOUYsd0JBQXdCLEtBQUs7QUFDN0I7QUFDQSxvQ0FBb0MsMENBQTBDO0FBQzlFLHdCQUF3QixLQUFLO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsTUFBTTtBQUNOLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixNQUFNO0FBQ04sZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQyxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDc0Q7QUFDdEQsNEJBQTRCLCtDQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLHNCQUFzQixJQUFJO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9CQUFvQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9CQUFvQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9CQUFvQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQzhDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDhDQUFNLGVBQWUsMENBQTBDO0FBQ3RGO0FBQ0E7QUFDQSx1QkFBdUIsOENBQU07QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLDBDQUEwQyxhQUFhO0FBQ3ZEO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSx1QkFBdUIsS0FBSyxHQUFHLE9BQU87QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNCQUFzQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUMyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGtDQUFNO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BELHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxvQkFBb0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxvQkFBb0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsaUNBQWlDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQywrQ0FBYTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELG1DQUFtQztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1Q0FBdUM7QUFDL0MsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9CQUFvQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9CQUFvQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9CQUFvQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQ0FBbUM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsK0JBQStCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUMyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGtDQUFNO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGlCQUFpQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixpQkFBaUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxjQUFjO0FBQ25FO0FBQ0E7QUFDQSxvREFBb0QsY0FBYztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxrQ0FBTTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixpQkFBaUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsUUFBUTtBQUNoRCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQzJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxNQUFNO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx5REFBWTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ2lDO0FBQ2pDLGFBQWEsa0NBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxrREFBa0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLCtDQUFhO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxJQUFJO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsSUFBSTtBQUNwRCw4QkFBOEIsV0FBVztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSwrQkFBK0Isa0NBQU07QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUNBQW1DO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxXQUFXO0FBQ3ZEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sY0FBYyxlQUFlO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxzQkFBc0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixzREFBc0QsVUFBVTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixzREFBc0QsVUFBVTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsWUFBWTtBQUMzQztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGVBQWU7QUFDL0M7QUFDQSwwQ0FBMEMsWUFBWSxLQUFLLHlCQUF5QjtBQUNwRjtBQUNBLHVEQUF1RCxZQUFZO0FBQ25FO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHNEQUFzRCxZQUFZLElBQUksS0FBSztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG1CQUFtQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFFBQVE7QUFDeEM7QUFDQSxRQUFRO0FBQ1IsZ0NBQWdDLFFBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXlHRSIsInNvdXJjZXMiOlsiL2hvbWUvbGZnL0dpdC9NYWR0cmlwcy9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL2Rpc3QvaW5kZXgubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9ldmVudHMva2luZHMvaW5kZXgudHNcbnZhciBOREtLaW5kID0gLyogQF9fUFVSRV9fICovICgoTkRLS2luZDIpID0+IHtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJNZXRhZGF0YVwiXSA9IDBdID0gXCJNZXRhZGF0YVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIlRleHRcIl0gPSAxXSA9IFwiVGV4dFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIlJlY29tbWVuZFJlbGF5XCJdID0gMl0gPSBcIlJlY29tbWVuZFJlbGF5XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQ29udGFjdHNcIl0gPSAzXSA9IFwiQ29udGFjdHNcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJFbmNyeXB0ZWREaXJlY3RNZXNzYWdlXCJdID0gNF0gPSBcIkVuY3J5cHRlZERpcmVjdE1lc3NhZ2VcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJFdmVudERlbGV0aW9uXCJdID0gNV0gPSBcIkV2ZW50RGVsZXRpb25cIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJSZXBvc3RcIl0gPSA2XSA9IFwiUmVwb3N0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiUmVhY3Rpb25cIl0gPSA3XSA9IFwiUmVhY3Rpb25cIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJCYWRnZUF3YXJkXCJdID0gOF0gPSBcIkJhZGdlQXdhcmRcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJHcm91cENoYXRcIl0gPSA5XSA9IFwiR3JvdXBDaGF0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiR3JvdXBOb3RlXCJdID0gMTFdID0gXCJHcm91cE5vdGVcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJHcm91cFJlcGx5XCJdID0gMTJdID0gXCJHcm91cFJlcGx5XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiR2lmdFdyYXBTZWFsXCJdID0gMTNdID0gXCJHaWZ0V3JhcFNlYWxcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJQcml2YXRlRGlyZWN0TWVzc2FnZVwiXSA9IDE0XSA9IFwiUHJpdmF0ZURpcmVjdE1lc3NhZ2VcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJJbWFnZVwiXSA9IDIwXSA9IFwiSW1hZ2VcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJWYW5pc2hcIl0gPSA2Ml0gPSBcIlZhbmlzaFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkdpZnRXcmFwXCJdID0gMTA1OV0gPSBcIkdpZnRXcmFwXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiR2VuZXJpY1JlcG9zdFwiXSA9IDE2XSA9IFwiR2VuZXJpY1JlcG9zdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkNoYW5uZWxDcmVhdGlvblwiXSA9IDQwXSA9IFwiQ2hhbm5lbENyZWF0aW9uXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQ2hhbm5lbE1ldGFkYXRhXCJdID0gNDFdID0gXCJDaGFubmVsTWV0YWRhdGFcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJDaGFubmVsTWVzc2FnZVwiXSA9IDQyXSA9IFwiQ2hhbm5lbE1lc3NhZ2VcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJDaGFubmVsSGlkZU1lc3NhZ2VcIl0gPSA0M10gPSBcIkNoYW5uZWxIaWRlTWVzc2FnZVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkNoYW5uZWxNdXRlVXNlclwiXSA9IDQ0XSA9IFwiQ2hhbm5lbE11dGVVc2VyXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiR2VuZXJpY1JlcGx5XCJdID0gMTExMV0gPSBcIkdlbmVyaWNSZXBseVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIk1lZGlhXCJdID0gMTA2M10gPSBcIk1lZGlhXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiUmVwb3J0XCJdID0gMTk4NF0gPSBcIlJlcG9ydFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkxhYmVsXCJdID0gMTk4NV0gPSBcIkxhYmVsXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiRFZNUmVxVGV4dEV4dHJhY3Rpb25cIl0gPSA1ZTNdID0gXCJEVk1SZXFUZXh0RXh0cmFjdGlvblwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkRWTVJlcVRleHRTdW1tYXJpemF0aW9uXCJdID0gNTAwMV0gPSBcIkRWTVJlcVRleHRTdW1tYXJpemF0aW9uXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiRFZNUmVxVGV4dFRyYW5zbGF0aW9uXCJdID0gNTAwMl0gPSBcIkRWTVJlcVRleHRUcmFuc2xhdGlvblwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkRWTVJlcVRleHRHZW5lcmF0aW9uXCJdID0gNTA1MF0gPSBcIkRWTVJlcVRleHRHZW5lcmF0aW9uXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiRFZNUmVxSW1hZ2VHZW5lcmF0aW9uXCJdID0gNTEwMF0gPSBcIkRWTVJlcUltYWdlR2VuZXJhdGlvblwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkRWTVJlcVRleHRUb1NwZWVjaFwiXSA9IDUyNTBdID0gXCJEVk1SZXFUZXh0VG9TcGVlY2hcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJEVk1SZXFEaXNjb3ZlcnlOb3N0ckNvbnRlbnRcIl0gPSA1MzAwXSA9IFwiRFZNUmVxRGlzY292ZXJ5Tm9zdHJDb250ZW50XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiRFZNUmVxRGlzY292ZXJ5Tm9zdHJQZW9wbGVcIl0gPSA1MzAxXSA9IFwiRFZNUmVxRGlzY292ZXJ5Tm9zdHJQZW9wbGVcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJEVk1SZXFUaW1lc3RhbXBpbmdcIl0gPSA1OTAwXSA9IFwiRFZNUmVxVGltZXN0YW1waW5nXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiRFZNRXZlbnRTY2hlZHVsZVwiXSA9IDU5MDVdID0gXCJEVk1FdmVudFNjaGVkdWxlXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiRFZNSm9iRmVlZGJhY2tcIl0gPSA3ZTNdID0gXCJEVk1Kb2JGZWVkYmFja1wiO1xuICBOREtLaW5kMltOREtLaW5kMltcIlN1YnNjcmliZVwiXSA9IDcwMDFdID0gXCJTdWJzY3JpYmVcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJVbnN1YnNjcmliZVwiXSA9IDcwMDJdID0gXCJVbnN1YnNjcmliZVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIlN1YnNjcmlwdGlvblJlY2VpcHRcIl0gPSA3MDAzXSA9IFwiU3Vic2NyaXB0aW9uUmVjZWlwdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkNhc2h1UmVzZXJ2ZVwiXSA9IDczNzNdID0gXCJDYXNodVJlc2VydmVcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJDYXNodVF1b3RlXCJdID0gNzM3NF0gPSBcIkNhc2h1UXVvdGVcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJDYXNodVRva2VuXCJdID0gNzM3NV0gPSBcIkNhc2h1VG9rZW5cIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJDYXNodVdhbGxldFR4XCJdID0gNzM3Nl0gPSBcIkNhc2h1V2FsbGV0VHhcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJHcm91cEFkbWluQWRkVXNlclwiXSA9IDllM10gPSBcIkdyb3VwQWRtaW5BZGRVc2VyXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiR3JvdXBBZG1pblJlbW92ZVVzZXJcIl0gPSA5MDAxXSA9IFwiR3JvdXBBZG1pblJlbW92ZVVzZXJcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJHcm91cEFkbWluRWRpdE1ldGFkYXRhXCJdID0gOTAwMl0gPSBcIkdyb3VwQWRtaW5FZGl0TWV0YWRhdGFcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJHcm91cEFkbWluRWRpdFN0YXR1c1wiXSA9IDkwMDZdID0gXCJHcm91cEFkbWluRWRpdFN0YXR1c1wiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkdyb3VwQWRtaW5DcmVhdGVHcm91cFwiXSA9IDkwMDddID0gXCJHcm91cEFkbWluQ3JlYXRlR3JvdXBcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJHcm91cEFkbWluUmVxdWVzdEpvaW5cIl0gPSA5MDIxXSA9IFwiR3JvdXBBZG1pblJlcXVlc3RKb2luXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiTXV0ZUxpc3RcIl0gPSAxZTRdID0gXCJNdXRlTGlzdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIlBpbkxpc3RcIl0gPSAxMDAwMV0gPSBcIlBpbkxpc3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJSZWxheUxpc3RcIl0gPSAxMDAwMl0gPSBcIlJlbGF5TGlzdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkJvb2ttYXJrTGlzdFwiXSA9IDEwMDAzXSA9IFwiQm9va21hcmtMaXN0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQ29tbXVuaXR5TGlzdFwiXSA9IDEwMDA0XSA9IFwiQ29tbXVuaXR5TGlzdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIlB1YmxpY0NoYXRMaXN0XCJdID0gMTAwMDVdID0gXCJQdWJsaWNDaGF0TGlzdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkJsb2NrUmVsYXlMaXN0XCJdID0gMTAwMDZdID0gXCJCbG9ja1JlbGF5TGlzdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIlNlYXJjaFJlbGF5TGlzdFwiXSA9IDEwMDA3XSA9IFwiU2VhcmNoUmVsYXlMaXN0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiU2ltcGxlR3JvdXBMaXN0XCJdID0gMTAwMDldID0gXCJTaW1wbGVHcm91cExpc3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJJbnRlcmVzdExpc3RcIl0gPSAxMDAxNV0gPSBcIkludGVyZXN0TGlzdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkNhc2h1TWludExpc3RcIl0gPSAxMDAxOV0gPSBcIkNhc2h1TWludExpc3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJFbW9qaUxpc3RcIl0gPSAxMDAzMF0gPSBcIkVtb2ppTGlzdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkRpcmVjdE1lc3NhZ2VSZWNlaXZlUmVsYXlMaXN0XCJdID0gMTAwNTBdID0gXCJEaXJlY3RNZXNzYWdlUmVjZWl2ZVJlbGF5TGlzdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkJsb3Nzb21MaXN0XCJdID0gMTAwNjNdID0gXCJCbG9zc29tTGlzdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIk5vc3RyV2FsZXRDb25uZWN0SW5mb1wiXSA9IDEzMTk0XSA9IFwiTm9zdHJXYWxldENvbm5lY3RJbmZvXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiVGllckxpc3RcIl0gPSAxN2UzXSA9IFwiVGllckxpc3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJDYXNodVdhbGxldFwiXSA9IDE3Mzc1XSA9IFwiQ2FzaHVXYWxsZXRcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJGb2xsb3dTZXRcIl0gPSAzZTRdID0gXCJGb2xsb3dTZXRcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJDYXRlZ29yaXplZFBlb3BsZUxpc3RcIl0gPSAzZTQgLyogRm9sbG93U2V0ICovXSA9IFwiQ2F0ZWdvcml6ZWRQZW9wbGVMaXN0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQ2F0ZWdvcml6ZWRCb29rbWFya0xpc3RcIl0gPSAzMDAwMV0gPSBcIkNhdGVnb3JpemVkQm9va21hcmtMaXN0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiUmVsYXlTZXRcIl0gPSAzMDAwMl0gPSBcIlJlbGF5U2V0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQ2F0ZWdvcml6ZWRSZWxheUxpc3RcIl0gPSAzMDAwMiAvKiBSZWxheVNldCAqL10gPSBcIkNhdGVnb3JpemVkUmVsYXlMaXN0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQm9va21hcmtTZXRcIl0gPSAzMDAwM10gPSBcIkJvb2ttYXJrU2V0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQ3VyYXRpb25TZXRcIl0gPSAzMDAwNF0gPSBcIkN1cmF0aW9uU2V0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQXJ0aWNsZUN1cmF0aW9uU2V0XCJdID0gMzAwMDRdID0gXCJBcnRpY2xlQ3VyYXRpb25TZXRcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJWaWRlb0N1cmF0aW9uU2V0XCJdID0gMzAwMDVdID0gXCJWaWRlb0N1cmF0aW9uU2V0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiSW1hZ2VDdXJhdGlvblNldFwiXSA9IDMwMDA2XSA9IFwiSW1hZ2VDdXJhdGlvblNldFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkludGVyZXN0U2V0XCJdID0gMzAwMTVdID0gXCJJbnRlcmVzdFNldFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkludGVyZXN0c0xpc3RcIl0gPSAzMDAxNSAvKiBJbnRlcmVzdFNldCAqL10gPSBcIkludGVyZXN0c0xpc3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJFbW9qaVNldFwiXSA9IDMwMDMwXSA9IFwiRW1vamlTZXRcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJNb2R1bGFyQXJ0aWNsZVwiXSA9IDMwMDQwXSA9IFwiTW9kdWxhckFydGljbGVcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJNb2R1bGFyQXJ0aWNsZUl0ZW1cIl0gPSAzMDA0MV0gPSBcIk1vZHVsYXJBcnRpY2xlSXRlbVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIldpa2lcIl0gPSAzMDgxOF0gPSBcIldpa2lcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJEcmFmdFwiXSA9IDMxMjM0XSA9IFwiRHJhZnRcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJTdWJzY3JpcHRpb25UaWVyXCJdID0gMzcwMDFdID0gXCJTdWJzY3JpcHRpb25UaWVyXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiRWNhc2hNaW50UmVjb21tZW5kYXRpb25cIl0gPSAzOGUzXSA9IFwiRWNhc2hNaW50UmVjb21tZW5kYXRpb25cIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJIaWdobGlnaHRTZXRcIl0gPSAzOTgwMl0gPSBcIkhpZ2hsaWdodFNldFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkNhdGVnb3JpemVkSGlnaGxpZ2h0TGlzdFwiXSA9IDM5ODAyIC8qIEhpZ2hsaWdodFNldCAqL10gPSBcIkNhdGVnb3JpemVkSGlnaGxpZ2h0TGlzdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIk51dHphcFwiXSA9IDkzMjFdID0gXCJOdXR6YXBcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJaYXBSZXF1ZXN0XCJdID0gOTczNF0gPSBcIlphcFJlcXVlc3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJaYXBcIl0gPSA5NzM1XSA9IFwiWmFwXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiSGlnaGxpZ2h0XCJdID0gOTgwMl0gPSBcIkhpZ2hsaWdodFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkNsaWVudEF1dGhcIl0gPSAyMjI0Ml0gPSBcIkNsaWVudEF1dGhcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJOb3N0cldhbGxldENvbm5lY3RSZXFcIl0gPSAyMzE5NF0gPSBcIk5vc3RyV2FsbGV0Q29ubmVjdFJlcVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIk5vc3RyV2FsbGV0Q29ubmVjdFJlc1wiXSA9IDIzMTk1XSA9IFwiTm9zdHJXYWxsZXRDb25uZWN0UmVzXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiTm9zdHJDb25uZWN0XCJdID0gMjQxMzNdID0gXCJOb3N0ckNvbm5lY3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJCbG9zc29tVXBsb2FkXCJdID0gMjQyNDJdID0gXCJCbG9zc29tVXBsb2FkXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiSHR0cEF1dGhcIl0gPSAyNzIzNV0gPSBcIkh0dHBBdXRoXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiUHJvZmlsZUJhZGdlXCJdID0gMzAwMDhdID0gXCJQcm9maWxlQmFkZ2VcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJCYWRnZURlZmluaXRpb25cIl0gPSAzMDAwOV0gPSBcIkJhZGdlRGVmaW5pdGlvblwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIk1hcmtldFN0YWxsXCJdID0gMzAwMTddID0gXCJNYXJrZXRTdGFsbFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIk1hcmtldFByb2R1Y3RcIl0gPSAzMDAxOF0gPSBcIk1hcmtldFByb2R1Y3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJBcnRpY2xlXCJdID0gMzAwMjNdID0gXCJBcnRpY2xlXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQXBwU3BlY2lmaWNEYXRhXCJdID0gMzAwNzhdID0gXCJBcHBTcGVjaWZpY0RhdGFcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJDbGFzc2lmaWVkXCJdID0gMzA0MDJdID0gXCJDbGFzc2lmaWVkXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiSG9yaXpvbnRhbFZpZGVvXCJdID0gMzQyMzVdID0gXCJIb3Jpem9udGFsVmlkZW9cIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJWZXJ0aWNhbFZpZGVvXCJdID0gMzQyMzZdID0gXCJWZXJ0aWNhbFZpZGVvXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiTGVnYWN5Q2FzaHVXYWxsZXRcIl0gPSAzNzM3NV0gPSBcIkxlZ2FjeUNhc2h1V2FsbGV0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiR3JvdXBNZXRhZGF0YVwiXSA9IDM5ZTNdID0gXCJHcm91cE1ldGFkYXRhXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiR3JvdXBBZG1pbnNcIl0gPSAzOTAwMV0gPSBcIkdyb3VwQWRtaW5zXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiR3JvdXBNZW1iZXJzXCJdID0gMzkwMDJdID0gXCJHcm91cE1lbWJlcnNcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJBcHBSZWNvbW1lbmRhdGlvblwiXSA9IDMxOTg5XSA9IFwiQXBwUmVjb21tZW5kYXRpb25cIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJBcHBIYW5kbGVyXCJdID0gMzE5OTBdID0gXCJBcHBIYW5kbGVyXCI7XG4gIHJldHVybiBOREtLaW5kMjtcbn0pKE5ES0tpbmQgfHwge30pO1xudmFyIE5ES0xpc3RLaW5kcyA9IFtcbiAgMWU0IC8qIE11dGVMaXN0ICovLFxuICAxMDAwMSAvKiBQaW5MaXN0ICovLFxuICAxMDAwMiAvKiBSZWxheUxpc3QgKi8sXG4gIDEwMDAzIC8qIEJvb2ttYXJrTGlzdCAqLyxcbiAgMTAwMDQgLyogQ29tbXVuaXR5TGlzdCAqLyxcbiAgMTAwMDUgLyogUHVibGljQ2hhdExpc3QgKi8sXG4gIDEwMDA2IC8qIEJsb2NrUmVsYXlMaXN0ICovLFxuICAxMDAwNyAvKiBTZWFyY2hSZWxheUxpc3QgKi8sXG4gIDEwMDE1IC8qIEludGVyZXN0TGlzdCAqLyxcbiAgMTAwMzAgLyogRW1vamlMaXN0ICovLFxuICAxMDA1MCAvKiBEaXJlY3RNZXNzYWdlUmVjZWl2ZVJlbGF5TGlzdCAqLyxcbiAgM2U0IC8qIEZvbGxvd1NldCAqLyxcbiAgMzAwMDMgLyogQm9va21hcmtTZXQgKi8sXG4gIDMwMDAxIC8qIENhdGVnb3JpemVkQm9va21hcmtMaXN0ICovLFxuICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAzMDAwMiAvKiBSZWxheVNldCAqLyxcbiAgMzAwMDQgLyogQXJ0aWNsZUN1cmF0aW9uU2V0ICovLFxuICAzMDAwNSAvKiBWaWRlb0N1cmF0aW9uU2V0ICovLFxuICAzMDAxNSAvKiBJbnRlcmVzdFNldCAqLyxcbiAgMzAwMzAgLyogRW1vamlTZXQgKi8sXG4gIDM5ODAyIC8qIEhpZ2hsaWdodFNldCAqL1xuXTtcblxuLy8gc3JjL2V2ZW50cy9pbmRleC50c1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIGFzIEV2ZW50RW1pdHRlcjIgfSBmcm9tIFwidHNlZXBcIjtcblxuLy8gc3JjL291dGJveC93cml0ZS50c1xuZnVuY3Rpb24gZ2V0UmVsYXlzRm9yU3luYyhuZGssIGF1dGhvciwgdHlwZSA9IFwid3JpdGVcIikge1xuICBpZiAoIW5kay5vdXRib3hUcmFja2VyKSByZXR1cm4gdm9pZCAwO1xuICBjb25zdCBpdGVtID0gbmRrLm91dGJveFRyYWNrZXIuZGF0YS5nZXQoYXV0aG9yKTtcbiAgaWYgKCFpdGVtKSByZXR1cm4gdm9pZCAwO1xuICBpZiAodHlwZSA9PT0gXCJ3cml0ZVwiKSB7XG4gICAgcmV0dXJuIGl0ZW0ud3JpdGVSZWxheXM7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGl0ZW0ucmVhZFJlbGF5cztcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZ2V0V3JpdGVSZWxheXNGb3IobmRrLCBhdXRob3IsIHR5cGUgPSBcIndyaXRlXCIpIHtcbiAgaWYgKCFuZGsub3V0Ym94VHJhY2tlcikgcmV0dXJuIHZvaWQgMDtcbiAgaWYgKCFuZGsub3V0Ym94VHJhY2tlci5kYXRhLmhhcyhhdXRob3IpKSB7XG4gICAgYXdhaXQgbmRrLm91dGJveFRyYWNrZXIudHJhY2tVc2VycyhbYXV0aG9yXSk7XG4gIH1cbiAgcmV0dXJuIGdldFJlbGF5c0ZvclN5bmMobmRrLCBhdXRob3IsIHR5cGUpO1xufVxuXG4vLyBzcmMvb3V0Ym94L3JlbGF5LXJhbmtpbmcudHNcbmZ1bmN0aW9uIGdldFRvcFJlbGF5c0ZvckF1dGhvcnMobmRrLCBhdXRob3JzKSB7XG4gIGNvbnN0IHJlbGF5c1dpdGhDb3VudCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGF1dGhvcnMuZm9yRWFjaCgoYXV0aG9yKSA9PiB7XG4gICAgY29uc3Qgd3JpdGVSZWxheXMgPSBnZXRSZWxheXNGb3JTeW5jKG5kaywgYXV0aG9yKTtcbiAgICBpZiAod3JpdGVSZWxheXMpIHtcbiAgICAgIHdyaXRlUmVsYXlzLmZvckVhY2goKHJlbGF5KSA9PiB7XG4gICAgICAgIGNvbnN0IGNvdW50ID0gcmVsYXlzV2l0aENvdW50LmdldChyZWxheSkgfHwgMDtcbiAgICAgICAgcmVsYXlzV2l0aENvdW50LnNldChyZWxheSwgY291bnQgKyAxKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IHNvcnRlZFJlbGF5cyA9IEFycmF5LmZyb20ocmVsYXlzV2l0aENvdW50LmVudHJpZXMoKSkuc29ydCgoYSwgYikgPT4gYlsxXSAtIGFbMV0pO1xuICByZXR1cm4gc29ydGVkUmVsYXlzLm1hcCgoZW50cnkpID0+IGVudHJ5WzBdKTtcbn1cblxuLy8gc3JjL291dGJveC9pbmRleC50c1xuZnVuY3Rpb24gZ2V0QWxsUmVsYXlzRm9yQWxsUHVia2V5cyhuZGssIHB1YmtleXMsIHR5cGUgPSBcInJlYWRcIikge1xuICBjb25zdCBwdWJrZXlzVG9SZWxheXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCBhdXRob3JzTWlzc2luZ1JlbGF5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIHB1YmtleXMuZm9yRWFjaCgocHVia2V5KSA9PiB7XG4gICAgY29uc3QgcmVsYXlzID0gZ2V0UmVsYXlzRm9yU3luYyhuZGssIHB1YmtleSwgdHlwZSk7XG4gICAgaWYgKHJlbGF5cyAmJiByZWxheXMuc2l6ZSA+IDApIHtcbiAgICAgIHJlbGF5cy5mb3JFYWNoKChyZWxheSkgPT4ge1xuICAgICAgICBjb25zdCBwdWJrZXlzSW5SZWxheSA9IHB1YmtleXNUb1JlbGF5cy5nZXQocmVsYXkpIHx8IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICAgIHB1YmtleXNJblJlbGF5LmFkZChwdWJrZXkpO1xuICAgICAgfSk7XG4gICAgICBwdWJrZXlzVG9SZWxheXMuc2V0KHB1YmtleSwgcmVsYXlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXV0aG9yc01pc3NpbmdSZWxheXMuYWRkKHB1YmtleSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHsgcHVia2V5c1RvUmVsYXlzLCBhdXRob3JzTWlzc2luZ1JlbGF5cyB9O1xufVxuZnVuY3Rpb24gY2hvb3NlUmVsYXlDb21iaW5hdGlvbkZvclB1YmtleXMobmRrLCBwdWJrZXlzLCB0eXBlLCB7IGNvdW50LCBwcmVmZXJyZWRSZWxheXMgfSA9IHt9KSB7XG4gIGNvdW50ID8/PSAyO1xuICBwcmVmZXJyZWRSZWxheXMgPz89IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0IHBvb2wgPSBuZGsucG9vbDtcbiAgY29uc3QgY29ubmVjdGVkUmVsYXlzID0gcG9vbC5jb25uZWN0ZWRSZWxheXMoKTtcbiAgY29ubmVjdGVkUmVsYXlzLmZvckVhY2goKHJlbGF5KSA9PiB7XG4gICAgcHJlZmVycmVkUmVsYXlzLmFkZChyZWxheS51cmwpO1xuICB9KTtcbiAgY29uc3QgcmVsYXlUb0F1dGhvcnNNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCB7IHB1YmtleXNUb1JlbGF5cywgYXV0aG9yc01pc3NpbmdSZWxheXMgfSA9IGdldEFsbFJlbGF5c0ZvckFsbFB1YmtleXMobmRrLCBwdWJrZXlzLCB0eXBlKTtcbiAgY29uc3Qgc29ydGVkUmVsYXlzID0gZ2V0VG9wUmVsYXlzRm9yQXV0aG9ycyhuZGssIHB1YmtleXMpO1xuICBjb25zdCBhZGRBdXRob3JUb1JlbGF5ID0gKGF1dGhvciwgcmVsYXkpID0+IHtcbiAgICBjb25zdCBhdXRob3JzSW5SZWxheSA9IHJlbGF5VG9BdXRob3JzTWFwLmdldChyZWxheSkgfHwgW107XG4gICAgYXV0aG9yc0luUmVsYXkucHVzaChhdXRob3IpO1xuICAgIHJlbGF5VG9BdXRob3JzTWFwLnNldChyZWxheSwgYXV0aG9yc0luUmVsYXkpO1xuICB9O1xuICBmb3IgKGNvbnN0IFthdXRob3IsIGF1dGhvclJlbGF5c10gb2YgcHVia2V5c1RvUmVsYXlzLmVudHJpZXMoKSkge1xuICAgIGxldCBtaXNzaW5nUmVsYXlDb3VudCA9IGNvdW50O1xuICAgIGZvciAoY29uc3QgcmVsYXkgb2YgY29ubmVjdGVkUmVsYXlzKSB7XG4gICAgICBpZiAoYXV0aG9yUmVsYXlzLmhhcyhyZWxheS51cmwpKSB7XG4gICAgICAgIGFkZEF1dGhvclRvUmVsYXkoYXV0aG9yLCByZWxheS51cmwpO1xuICAgICAgICBtaXNzaW5nUmVsYXlDb3VudC0tO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGF1dGhvclJlbGF5IG9mIGF1dGhvclJlbGF5cykge1xuICAgICAgaWYgKHJlbGF5VG9BdXRob3JzTWFwLmhhcyhhdXRob3JSZWxheSkpIHtcbiAgICAgICAgYWRkQXV0aG9yVG9SZWxheShhdXRob3IsIGF1dGhvclJlbGF5KTtcbiAgICAgICAgbWlzc2luZ1JlbGF5Q291bnQtLTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1pc3NpbmdSZWxheUNvdW50IDw9IDApIGNvbnRpbnVlO1xuICAgIGZvciAoY29uc3QgcmVsYXkgb2Ygc29ydGVkUmVsYXlzKSB7XG4gICAgICBpZiAobWlzc2luZ1JlbGF5Q291bnQgPD0gMCkgYnJlYWs7XG4gICAgICBpZiAoYXV0aG9yUmVsYXlzLmhhcyhyZWxheSkpIHtcbiAgICAgICAgYWRkQXV0aG9yVG9SZWxheShhdXRob3IsIHJlbGF5KTtcbiAgICAgICAgbWlzc2luZ1JlbGF5Q291bnQtLTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCBhdXRob3Igb2YgYXV0aG9yc01pc3NpbmdSZWxheXMpIHtcbiAgICBwb29sLnBlcm1hbmVudEFuZENvbm5lY3RlZFJlbGF5cygpLmZvckVhY2goKHJlbGF5KSA9PiB7XG4gICAgICBjb25zdCBhdXRob3JzSW5SZWxheSA9IHJlbGF5VG9BdXRob3JzTWFwLmdldChyZWxheS51cmwpIHx8IFtdO1xuICAgICAgYXV0aG9yc0luUmVsYXkucHVzaChhdXRob3IpO1xuICAgICAgcmVsYXlUb0F1dGhvcnNNYXAuc2V0KHJlbGF5LnVybCwgYXV0aG9yc0luUmVsYXkpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiByZWxheVRvQXV0aG9yc01hcDtcbn1cblxuLy8gc3JjL291dGJveC9yZWFkL3dpdGgtYXV0aG9ycy50c1xuZnVuY3Rpb24gZ2V0UmVsYXlzRm9yRmlsdGVyV2l0aEF1dGhvcnMobmRrLCBhdXRob3JzLCByZWxheUdvYWxQZXJBdXRob3IgPSAyKSB7XG4gIHJldHVybiBjaG9vc2VSZWxheUNvbWJpbmF0aW9uRm9yUHVia2V5cyhuZGssIGF1dGhvcnMsIFwid3JpdGVcIiwgeyBjb3VudDogcmVsYXlHb2FsUGVyQXV0aG9yIH0pO1xufVxuXG4vLyBzcmMvdXRpbHMvbm9ybWFsaXplLXVybC50c1xuZnVuY3Rpb24gdHJ5Tm9ybWFsaXplUmVsYXlVcmwodXJsKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZVJlbGF5VXJsKHVybCk7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVJlbGF5VXJsKHVybCkge1xuICBsZXQgciA9IG5vcm1hbGl6ZVVybCh1cmwsIHtcbiAgICBzdHJpcEF1dGhlbnRpY2F0aW9uOiBmYWxzZSxcbiAgICBzdHJpcFdXVzogZmFsc2UsXG4gICAgc3RyaXBIYXNoOiB0cnVlXG4gIH0pO1xuICBpZiAoIXIuZW5kc1dpdGgoXCIvXCIpKSB7XG4gICAgciArPSBcIi9cIjtcbiAgfVxuICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZSh1cmxzKSB7XG4gIGNvbnN0IG5vcm1hbGl6ZWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBmb3IgKGNvbnN0IHVybCBvZiB1cmxzKSB7XG4gICAgdHJ5IHtcbiAgICAgIG5vcm1hbGl6ZWQuYWRkKG5vcm1hbGl6ZVJlbGF5VXJsKHVybCkpO1xuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgfVxuICByZXR1cm4gQXJyYXkuZnJvbShub3JtYWxpemVkKTtcbn1cbnZhciBEQVRBX1VSTF9ERUZBVUxUX01JTUVfVFlQRSA9IFwidGV4dC9wbGFpblwiO1xudmFyIERBVEFfVVJMX0RFRkFVTFRfQ0hBUlNFVCA9IFwidXMtYXNjaWlcIjtcbnZhciB0ZXN0UGFyYW1ldGVyID0gKG5hbWUsIGZpbHRlcnMpID0+IGZpbHRlcnMuc29tZSgoZmlsdGVyKSA9PiBmaWx0ZXIgaW5zdGFuY2VvZiBSZWdFeHAgPyBmaWx0ZXIudGVzdChuYW1lKSA6IGZpbHRlciA9PT0gbmFtZSk7XG52YXIgc3VwcG9ydGVkUHJvdG9jb2xzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wiaHR0cHM6XCIsIFwiaHR0cDpcIiwgXCJmaWxlOlwiXSk7XG52YXIgaGFzQ3VzdG9tUHJvdG9jb2wgPSAodXJsU3RyaW5nKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgeyBwcm90b2NvbCB9ID0gbmV3IFVSTCh1cmxTdHJpbmcpO1xuICAgIHJldHVybiBwcm90b2NvbC5lbmRzV2l0aChcIjpcIikgJiYgIXByb3RvY29sLmluY2x1ZGVzKFwiLlwiKSAmJiAhc3VwcG9ydGVkUHJvdG9jb2xzLmhhcyhwcm90b2NvbCk7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcbnZhciBub3JtYWxpemVEYXRhVVJMID0gKHVybFN0cmluZywgeyBzdHJpcEhhc2ggfSkgPT4ge1xuICBjb25zdCBtYXRjaCA9IC9eZGF0YTooPzx0eXBlPlteLF0qPyksKD88ZGF0YT5bXiNdKj8pKD86Iyg/PGhhc2g+LiopKT8kLy5leGVjKHVybFN0cmluZyk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgVVJMOiAke3VybFN0cmluZ31gKTtcbiAgfVxuICBsZXQgdHlwZSA9IG1hdGNoLmdyb3Vwcz8udHlwZSA/PyBcIlwiO1xuICBsZXQgZGF0YSA9IG1hdGNoLmdyb3Vwcz8uZGF0YSA/PyBcIlwiO1xuICBsZXQgaGFzaCA9IG1hdGNoLmdyb3Vwcz8uaGFzaCA/PyBcIlwiO1xuICBjb25zdCBtZWRpYVR5cGUgPSB0eXBlLnNwbGl0KFwiO1wiKTtcbiAgaGFzaCA9IHN0cmlwSGFzaCA/IFwiXCIgOiBoYXNoO1xuICBsZXQgaXNCYXNlNjQgPSBmYWxzZTtcbiAgaWYgKG1lZGlhVHlwZVttZWRpYVR5cGUubGVuZ3RoIC0gMV0gPT09IFwiYmFzZTY0XCIpIHtcbiAgICBtZWRpYVR5cGUucG9wKCk7XG4gICAgaXNCYXNlNjQgPSB0cnVlO1xuICB9XG4gIGNvbnN0IG1pbWVUeXBlID0gbWVkaWFUeXBlLnNoaWZ0KCk/LnRvTG93ZXJDYXNlKCkgPz8gXCJcIjtcbiAgY29uc3QgYXR0cmlidXRlcyA9IG1lZGlhVHlwZS5tYXAoKGF0dHJpYnV0ZSkgPT4ge1xuICAgIGxldCBba2V5LCB2YWx1ZSA9IFwiXCJdID0gYXR0cmlidXRlLnNwbGl0KFwiPVwiKS5tYXAoKHN0cmluZykgPT4gc3RyaW5nLnRyaW0oKSk7XG4gICAgaWYgKGtleSA9PT0gXCJjaGFyc2V0XCIpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gREFUQV9VUkxfREVGQVVMVF9DSEFSU0VUKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYCR7a2V5fSR7dmFsdWUgPyBgPSR7dmFsdWV9YCA6IFwiXCJ9YDtcbiAgfSkuZmlsdGVyKEJvb2xlYW4pO1xuICBjb25zdCBub3JtYWxpemVkTWVkaWFUeXBlID0gWy4uLmF0dHJpYnV0ZXNdO1xuICBpZiAoaXNCYXNlNjQpIHtcbiAgICBub3JtYWxpemVkTWVkaWFUeXBlLnB1c2goXCJiYXNlNjRcIik7XG4gIH1cbiAgaWYgKG5vcm1hbGl6ZWRNZWRpYVR5cGUubGVuZ3RoID4gMCB8fCBtaW1lVHlwZSAmJiBtaW1lVHlwZSAhPT0gREFUQV9VUkxfREVGQVVMVF9NSU1FX1RZUEUpIHtcbiAgICBub3JtYWxpemVkTWVkaWFUeXBlLnVuc2hpZnQobWltZVR5cGUpO1xuICB9XG4gIHJldHVybiBgZGF0YToke25vcm1hbGl6ZWRNZWRpYVR5cGUuam9pbihcIjtcIil9LCR7aXNCYXNlNjQgPyBkYXRhLnRyaW0oKSA6IGRhdGF9JHtoYXNoID8gYCMke2hhc2h9YCA6IFwiXCJ9YDtcbn07XG5mdW5jdGlvbiBub3JtYWxpemVVcmwodXJsU3RyaW5nLCBvcHRpb25zID0ge30pIHtcbiAgb3B0aW9ucyA9IHtcbiAgICBkZWZhdWx0UHJvdG9jb2w6IFwiaHR0cFwiLFxuICAgIG5vcm1hbGl6ZVByb3RvY29sOiB0cnVlLFxuICAgIGZvcmNlSHR0cDogZmFsc2UsXG4gICAgZm9yY2VIdHRwczogZmFsc2UsXG4gICAgc3RyaXBBdXRoZW50aWNhdGlvbjogdHJ1ZSxcbiAgICBzdHJpcEhhc2g6IGZhbHNlLFxuICAgIHN0cmlwVGV4dEZyYWdtZW50OiB0cnVlLFxuICAgIHN0cmlwV1dXOiB0cnVlLFxuICAgIHJlbW92ZVF1ZXJ5UGFyYW1ldGVyczogWy9edXRtX1xcdysvaV0sXG4gICAgcmVtb3ZlVHJhaWxpbmdTbGFzaDogdHJ1ZSxcbiAgICByZW1vdmVTaW5nbGVTbGFzaDogdHJ1ZSxcbiAgICByZW1vdmVEaXJlY3RvcnlJbmRleDogZmFsc2UsXG4gICAgcmVtb3ZlRXhwbGljaXRQb3J0OiBmYWxzZSxcbiAgICBzb3J0UXVlcnlQYXJhbWV0ZXJzOiB0cnVlLFxuICAgIC4uLm9wdGlvbnNcbiAgfTtcbiAgaWYgKHR5cGVvZiBvcHRpb25zLmRlZmF1bHRQcm90b2NvbCA9PT0gXCJzdHJpbmdcIiAmJiAhb3B0aW9ucy5kZWZhdWx0UHJvdG9jb2wuZW5kc1dpdGgoXCI6XCIpKSB7XG4gICAgb3B0aW9ucy5kZWZhdWx0UHJvdG9jb2wgPSBgJHtvcHRpb25zLmRlZmF1bHRQcm90b2NvbH06YDtcbiAgfVxuICB1cmxTdHJpbmcgPSB1cmxTdHJpbmcudHJpbSgpO1xuICBpZiAoL15kYXRhOi9pLnRlc3QodXJsU3RyaW5nKSkge1xuICAgIHJldHVybiBub3JtYWxpemVEYXRhVVJMKHVybFN0cmluZywgb3B0aW9ucyk7XG4gIH1cbiAgaWYgKGhhc0N1c3RvbVByb3RvY29sKHVybFN0cmluZykpIHtcbiAgICByZXR1cm4gdXJsU3RyaW5nO1xuICB9XG4gIGNvbnN0IGhhc1JlbGF0aXZlUHJvdG9jb2wgPSB1cmxTdHJpbmcuc3RhcnRzV2l0aChcIi8vXCIpO1xuICBjb25zdCBpc1JlbGF0aXZlVXJsID0gIWhhc1JlbGF0aXZlUHJvdG9jb2wgJiYgL15cXC4qXFwvLy50ZXN0KHVybFN0cmluZyk7XG4gIGlmICghaXNSZWxhdGl2ZVVybCkge1xuICAgIHVybFN0cmluZyA9IHVybFN0cmluZy5yZXBsYWNlKC9eKD8hKD86XFx3KzopP1xcL1xcLyl8XlxcL1xcLy8sIG9wdGlvbnMuZGVmYXVsdFByb3RvY29sKTtcbiAgfVxuICBjb25zdCB1cmxPYmplY3QgPSBuZXcgVVJMKHVybFN0cmluZyk7XG4gIHVybE9iamVjdC5ob3N0bmFtZSA9IHVybE9iamVjdC5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuICBpZiAob3B0aW9ucy5mb3JjZUh0dHAgJiYgb3B0aW9ucy5mb3JjZUh0dHBzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGBmb3JjZUh0dHBgIGFuZCBgZm9yY2VIdHRwc2Agb3B0aW9ucyBjYW5ub3QgYmUgdXNlZCB0b2dldGhlclwiKTtcbiAgfVxuICBpZiAob3B0aW9ucy5mb3JjZUh0dHAgJiYgdXJsT2JqZWN0LnByb3RvY29sID09PSBcImh0dHBzOlwiKSB7XG4gICAgdXJsT2JqZWN0LnByb3RvY29sID0gXCJodHRwOlwiO1xuICB9XG4gIGlmIChvcHRpb25zLmZvcmNlSHR0cHMgJiYgdXJsT2JqZWN0LnByb3RvY29sID09PSBcImh0dHA6XCIpIHtcbiAgICB1cmxPYmplY3QucHJvdG9jb2wgPSBcImh0dHBzOlwiO1xuICB9XG4gIGlmIChvcHRpb25zLnN0cmlwQXV0aGVudGljYXRpb24pIHtcbiAgICB1cmxPYmplY3QudXNlcm5hbWUgPSBcIlwiO1xuICAgIHVybE9iamVjdC5wYXNzd29yZCA9IFwiXCI7XG4gIH1cbiAgaWYgKG9wdGlvbnMuc3RyaXBIYXNoKSB7XG4gICAgdXJsT2JqZWN0Lmhhc2ggPSBcIlwiO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMuc3RyaXBUZXh0RnJhZ21lbnQpIHtcbiAgICB1cmxPYmplY3QuaGFzaCA9IHVybE9iamVjdC5oYXNoLnJlcGxhY2UoLyM/On46dGV4dC4qPyQvaSwgXCJcIik7XG4gIH1cbiAgaWYgKHVybE9iamVjdC5wYXRobmFtZSkge1xuICAgIGNvbnN0IHByb3RvY29sUmVnZXggPSAvXFxiW2Etel1bYS16XFxkK1xcLS5dezEsNTB9OlxcL1xcLy9nO1xuICAgIGxldCBsYXN0SW5kZXggPSAwO1xuICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgIGZvciAoOyA7ICkge1xuICAgICAgY29uc3QgbWF0Y2ggPSBwcm90b2NvbFJlZ2V4LmV4ZWModXJsT2JqZWN0LnBhdGhuYW1lKTtcbiAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjb25zdCBwcm90b2NvbCA9IG1hdGNoWzBdO1xuICAgICAgY29uc3QgcHJvdG9jb2xBdEluZGV4ID0gbWF0Y2guaW5kZXg7XG4gICAgICBjb25zdCBpbnRlcm1lZGlhdGUgPSB1cmxPYmplY3QucGF0aG5hbWUuc2xpY2UobGFzdEluZGV4LCBwcm90b2NvbEF0SW5kZXgpO1xuICAgICAgcmVzdWx0ICs9IGludGVybWVkaWF0ZS5yZXBsYWNlKC9cXC97Mix9L2csIFwiL1wiKTtcbiAgICAgIHJlc3VsdCArPSBwcm90b2NvbDtcbiAgICAgIGxhc3RJbmRleCA9IHByb3RvY29sQXRJbmRleCArIHByb3RvY29sLmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgcmVtbmFudCA9IHVybE9iamVjdC5wYXRobmFtZS5zbGljZShsYXN0SW5kZXgsIHVybE9iamVjdC5wYXRobmFtZS5sZW5ndGgpO1xuICAgIHJlc3VsdCArPSByZW1uYW50LnJlcGxhY2UoL1xcL3syLH0vZywgXCIvXCIpO1xuICAgIHVybE9iamVjdC5wYXRobmFtZSA9IHJlc3VsdDtcbiAgfVxuICBpZiAodXJsT2JqZWN0LnBhdGhuYW1lKSB7XG4gICAgdHJ5IHtcbiAgICAgIHVybE9iamVjdC5wYXRobmFtZSA9IGRlY29kZVVSSSh1cmxPYmplY3QucGF0aG5hbWUpO1xuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgfVxuICBpZiAob3B0aW9ucy5yZW1vdmVEaXJlY3RvcnlJbmRleCA9PT0gdHJ1ZSkge1xuICAgIG9wdGlvbnMucmVtb3ZlRGlyZWN0b3J5SW5kZXggPSBbL15pbmRleFxcLlthLXpdKyQvXTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLnJlbW92ZURpcmVjdG9yeUluZGV4KSAmJiBvcHRpb25zLnJlbW92ZURpcmVjdG9yeUluZGV4Lmxlbmd0aCA+IDApIHtcbiAgICBsZXQgcGF0aENvbXBvbmVudHMgPSB1cmxPYmplY3QucGF0aG5hbWUuc3BsaXQoXCIvXCIpO1xuICAgIGNvbnN0IGxhc3RDb21wb25lbnQgPSBwYXRoQ29tcG9uZW50c1twYXRoQ29tcG9uZW50cy5sZW5ndGggLSAxXTtcbiAgICBpZiAodGVzdFBhcmFtZXRlcihsYXN0Q29tcG9uZW50LCBvcHRpb25zLnJlbW92ZURpcmVjdG9yeUluZGV4KSkge1xuICAgICAgcGF0aENvbXBvbmVudHMgPSBwYXRoQ29tcG9uZW50cy5zbGljZSgwLCAtMSk7XG4gICAgICB1cmxPYmplY3QucGF0aG5hbWUgPSBwYXRoQ29tcG9uZW50cy5zbGljZSgxKS5qb2luKFwiL1wiKSArIFwiL1wiO1xuICAgIH1cbiAgfVxuICBpZiAodXJsT2JqZWN0Lmhvc3RuYW1lKSB7XG4gICAgdXJsT2JqZWN0Lmhvc3RuYW1lID0gdXJsT2JqZWN0Lmhvc3RuYW1lLnJlcGxhY2UoL1xcLiQvLCBcIlwiKTtcbiAgICBpZiAob3B0aW9ucy5zdHJpcFdXVyAmJiAvXnd3d1xcLig/IXd3d1xcLilbYS16XFwtXFxkXXsxLDYzfVxcLlthLXouXFwtXFxkXXsyLDYzfSQvLnRlc3QodXJsT2JqZWN0Lmhvc3RuYW1lKSkge1xuICAgICAgdXJsT2JqZWN0Lmhvc3RuYW1lID0gdXJsT2JqZWN0Lmhvc3RuYW1lLnJlcGxhY2UoL153d3dcXC4vLCBcIlwiKTtcbiAgICB9XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5yZW1vdmVRdWVyeVBhcmFtZXRlcnMpKSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgWy4uLnVybE9iamVjdC5zZWFyY2hQYXJhbXMua2V5cygpXSkge1xuICAgICAgaWYgKHRlc3RQYXJhbWV0ZXIoa2V5LCBvcHRpb25zLnJlbW92ZVF1ZXJ5UGFyYW1ldGVycykpIHtcbiAgICAgICAgdXJsT2JqZWN0LnNlYXJjaFBhcmFtcy5kZWxldGUoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFBcnJheS5pc0FycmF5KG9wdGlvbnMua2VlcFF1ZXJ5UGFyYW1ldGVycykgJiYgb3B0aW9ucy5yZW1vdmVRdWVyeVBhcmFtZXRlcnMgPT09IHRydWUpIHtcbiAgICB1cmxPYmplY3Quc2VhcmNoID0gXCJcIjtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLmtlZXBRdWVyeVBhcmFtZXRlcnMpICYmIG9wdGlvbnMua2VlcFF1ZXJ5UGFyYW1ldGVycy5sZW5ndGggPiAwKSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgWy4uLnVybE9iamVjdC5zZWFyY2hQYXJhbXMua2V5cygpXSkge1xuICAgICAgaWYgKCF0ZXN0UGFyYW1ldGVyKGtleSwgb3B0aW9ucy5rZWVwUXVlcnlQYXJhbWV0ZXJzKSkge1xuICAgICAgICB1cmxPYmplY3Quc2VhcmNoUGFyYW1zLmRlbGV0ZShrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAob3B0aW9ucy5zb3J0UXVlcnlQYXJhbWV0ZXJzKSB7XG4gICAgdXJsT2JqZWN0LnNlYXJjaFBhcmFtcy5zb3J0KCk7XG4gICAgdHJ5IHtcbiAgICAgIHVybE9iamVjdC5zZWFyY2ggPSBkZWNvZGVVUklDb21wb25lbnQodXJsT2JqZWN0LnNlYXJjaCk7XG4gICAgfSBjYXRjaCB7XG4gICAgfVxuICB9XG4gIGlmIChvcHRpb25zLnJlbW92ZVRyYWlsaW5nU2xhc2gpIHtcbiAgICB1cmxPYmplY3QucGF0aG5hbWUgPSB1cmxPYmplY3QucGF0aG5hbWUucmVwbGFjZSgvXFwvJC8sIFwiXCIpO1xuICB9XG4gIGlmIChvcHRpb25zLnJlbW92ZUV4cGxpY2l0UG9ydCAmJiB1cmxPYmplY3QucG9ydCkge1xuICAgIHVybE9iamVjdC5wb3J0ID0gXCJcIjtcbiAgfVxuICBjb25zdCBvbGRVcmxTdHJpbmcgPSB1cmxTdHJpbmc7XG4gIHVybFN0cmluZyA9IHVybE9iamVjdC50b1N0cmluZygpO1xuICBpZiAoIW9wdGlvbnMucmVtb3ZlU2luZ2xlU2xhc2ggJiYgdXJsT2JqZWN0LnBhdGhuYW1lID09PSBcIi9cIiAmJiAhb2xkVXJsU3RyaW5nLmVuZHNXaXRoKFwiL1wiKSAmJiB1cmxPYmplY3QuaGFzaCA9PT0gXCJcIikge1xuICAgIHVybFN0cmluZyA9IHVybFN0cmluZy5yZXBsYWNlKC9cXC8kLywgXCJcIik7XG4gIH1cbiAgaWYgKChvcHRpb25zLnJlbW92ZVRyYWlsaW5nU2xhc2ggfHwgdXJsT2JqZWN0LnBhdGhuYW1lID09PSBcIi9cIikgJiYgdXJsT2JqZWN0Lmhhc2ggPT09IFwiXCIgJiYgb3B0aW9ucy5yZW1vdmVTaW5nbGVTbGFzaCkge1xuICAgIHVybFN0cmluZyA9IHVybFN0cmluZy5yZXBsYWNlKC9cXC8kLywgXCJcIik7XG4gIH1cbiAgaWYgKGhhc1JlbGF0aXZlUHJvdG9jb2wgJiYgIW9wdGlvbnMubm9ybWFsaXplUHJvdG9jb2wpIHtcbiAgICB1cmxTdHJpbmcgPSB1cmxTdHJpbmcucmVwbGFjZSgvXmh0dHA6XFwvXFwvLywgXCIvL1wiKTtcbiAgfVxuICBpZiAob3B0aW9ucy5zdHJpcFByb3RvY29sKSB7XG4gICAgdXJsU3RyaW5nID0gdXJsU3RyaW5nLnJlcGxhY2UoL14oPzpodHRwcz86KT9cXC9cXC8vLCBcIlwiKTtcbiAgfVxuICByZXR1cm4gdXJsU3RyaW5nO1xufVxuXG4vLyBzcmMvcmVsYXkvaW5kZXgudHNcbmltcG9ydCBkZWJ1ZyBmcm9tIFwiZGVidWdcIjtcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gXCJ0c2VlcFwiO1xuXG4vLyBzcmMvcmVsYXkvY29ubmVjdGl2aXR5LnRzXG52YXIgTUFYX1JFQ09OTkVDVF9BVFRFTVBUUyA9IDU7XG52YXIgRkxBUFBJTkdfVEhSRVNIT0xEX01TID0gMWUzO1xudmFyIE5ES1JlbGF5Q29ubmVjdGl2aXR5ID0gY2xhc3Mge1xuICBuZGtSZWxheTtcbiAgd3M7XG4gIF9zdGF0dXM7XG4gIHRpbWVvdXRNcztcbiAgY29ubmVjdGVkQXQ7XG4gIF9jb25uZWN0aW9uU3RhdHMgPSB7XG4gICAgYXR0ZW1wdHM6IDAsXG4gICAgc3VjY2VzczogMCxcbiAgICBkdXJhdGlvbnM6IFtdXG4gIH07XG4gIGRlYnVnO1xuICBuZXREZWJ1ZztcbiAgY29ubmVjdFRpbWVvdXQ7XG4gIHJlY29ubmVjdFRpbWVvdXQ7XG4gIG5kaztcbiAgb3BlblN1YnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBvcGVuQ291bnRSZXF1ZXN0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIG9wZW5FdmVudFB1Ymxpc2hlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIHNlcmlhbCA9IDA7XG4gIGJhc2VFb3NlVGltZW91dCA9IDQ0MDA7XG4gIGNvbnN0cnVjdG9yKG5ka1JlbGF5LCBuZGspIHtcbiAgICB0aGlzLm5ka1JlbGF5ID0gbmRrUmVsYXk7XG4gICAgdGhpcy5fc3RhdHVzID0gMSAvKiBESVNDT05ORUNURUQgKi87XG4gICAgY29uc3QgcmFuZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDFlMyk7XG4gICAgdGhpcy5kZWJ1ZyA9IHRoaXMubmRrUmVsYXkuZGVidWcuZXh0ZW5kKFwiY29ubmVjdGl2aXR5XCIgKyByYW5kKTtcbiAgICB0aGlzLm5kayA9IG5kaztcbiAgfVxuICAvKipcbiAgICogQ29ubmVjdHMgdG8gdGhlIE5ESyByZWxheSBhbmQgaGFuZGxlcyB0aGUgY29ubmVjdGlvbiBsaWZlY3ljbGUuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGF0dGVtcHRzIHRvIGVzdGFibGlzaCBhIFdlYlNvY2tldCBjb25uZWN0aW9uIHRvIHRoZSBOREsgcmVsYXkgc3BlY2lmaWVkIGluIHRoZSBgbmRrUmVsYXlgIG9iamVjdC5cbiAgICogSWYgdGhlIGNvbm5lY3Rpb24gaXMgc3VjY2Vzc2Z1bCwgaXQgdXBkYXRlcyB0aGUgY29ubmVjdGlvbiBzdGF0aXN0aWNzLCBzZXRzIHRoZSBjb25uZWN0aW9uIHN0YXR1cyB0byBgQ09OTkVDVEVEYCxcbiAgICogYW5kIGVtaXRzIGBjb25uZWN0YCBhbmQgYHJlYWR5YCBldmVudHMgb24gdGhlIGBuZGtSZWxheWAgb2JqZWN0LlxuICAgKlxuICAgKiBJZiB0aGUgY29ubmVjdGlvbiBhdHRlbXB0IGZhaWxzLCBpdCBoYW5kbGVzIHRoZSBlcnJvciBieSBlaXRoZXIgaW5pdGlhdGluZyBhIHJlY29ubmVjdGlvbiBhdHRlbXB0IG9yIGVtaXR0aW5nIGFcbiAgICogYGRlbGF5ZWQtY29ubmVjdGAgZXZlbnQgb24gdGhlIGBuZGtSZWxheWAgb2JqZWN0LCBkZXBlbmRpbmcgb24gdGhlIGByZWNvbm5lY3RgIHBhcmFtZXRlci5cbiAgICpcbiAgICogQHBhcmFtIHRpbWVvdXRNcyAtIFRoZSB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyBmb3IgdGhlIGNvbm5lY3Rpb24gYXR0ZW1wdC4gSWYgbm90IHByb3ZpZGVkLCB0aGUgZGVmYXVsdCB0aW1lb3V0IGZyb20gdGhlIGBuZGtSZWxheWAgb2JqZWN0IGlzIHVzZWQuXG4gICAqIEBwYXJhbSByZWNvbm5lY3QgLSBJbmRpY2F0ZXMgd2hldGhlciBhIHJlY29ubmVjdGlvbiBzaG91bGQgYmUgYXR0ZW1wdGVkIGlmIHRoZSBjb25uZWN0aW9uIGZhaWxzLiBEZWZhdWx0cyB0byBgdHJ1ZWAuXG4gICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIGNvbm5lY3Rpb24gaXMgZXN0YWJsaXNoZWQsIG9yIHJlamVjdHMgaWYgdGhlIGNvbm5lY3Rpb24gZmFpbHMuXG4gICAqL1xuICBhc3luYyBjb25uZWN0KHRpbWVvdXRNcywgcmVjb25uZWN0ID0gdHJ1ZSkge1xuICAgIGlmICh0aGlzLl9zdGF0dXMgIT09IDIgLyogUkVDT05ORUNUSU5HICovICYmIHRoaXMuX3N0YXR1cyAhPT0gMSAvKiBESVNDT05ORUNURUQgKi8gfHwgdGhpcy5yZWNvbm5lY3RUaW1lb3V0KSB7XG4gICAgICB0aGlzLmRlYnVnKFxuICAgICAgICBcIlJlbGF5IHJlcXVlc3RlZCB0byBiZSBjb25uZWN0ZWQgYnV0IHdhcyBpbiBzdGF0ZSAlcyBvciBpdCBoYWQgYSByZWNvbm5lY3QgdGltZW91dFwiLFxuICAgICAgICB0aGlzLl9zdGF0dXNcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLnJlY29ubmVjdFRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlY29ubmVjdFRpbWVvdXQpO1xuICAgICAgdGhpcy5yZWNvbm5lY3RUaW1lb3V0ID0gdm9pZCAwO1xuICAgIH1cbiAgICBpZiAodGhpcy5jb25uZWN0VGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY29ubmVjdFRpbWVvdXQpO1xuICAgICAgdGhpcy5jb25uZWN0VGltZW91dCA9IHZvaWQgMDtcbiAgICB9XG4gICAgdGltZW91dE1zID8/PSB0aGlzLnRpbWVvdXRNcztcbiAgICBpZiAoIXRoaXMudGltZW91dE1zICYmIHRpbWVvdXRNcykgdGhpcy50aW1lb3V0TXMgPSB0aW1lb3V0TXM7XG4gICAgaWYgKHRoaXMudGltZW91dE1zKVxuICAgICAgdGhpcy5jb25uZWN0VGltZW91dCA9IHNldFRpbWVvdXQoXG4gICAgICAgICgpID0+IHRoaXMub25Db25uZWN0aW9uRXJyb3IocmVjb25uZWN0KSxcbiAgICAgICAgdGhpcy50aW1lb3V0TXNcbiAgICAgICk7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMudXBkYXRlQ29ubmVjdGlvblN0YXRzLmF0dGVtcHQoKTtcbiAgICAgIGlmICh0aGlzLl9zdGF0dXMgPT09IDEgLyogRElTQ09OTkVDVEVEICovKVxuICAgICAgICB0aGlzLl9zdGF0dXMgPSA0IC8qIENPTk5FQ1RJTkcgKi87XG4gICAgICBlbHNlIHRoaXMuX3N0YXR1cyA9IDIgLyogUkVDT05ORUNUSU5HICovO1xuICAgICAgdGhpcy53cyA9IG5ldyBXZWJTb2NrZXQodGhpcy5uZGtSZWxheS51cmwpO1xuICAgICAgdGhpcy53cy5vbm9wZW4gPSB0aGlzLm9uQ29ubmVjdC5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy53cy5vbmNsb3NlID0gdGhpcy5vbkRpc2Nvbm5lY3QuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMud3Mub25tZXNzYWdlID0gdGhpcy5vbk1lc3NhZ2UuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMud3Mub25lcnJvciA9IHRoaXMub25FcnJvci5iaW5kKHRoaXMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXMuZGVidWcoYEZhaWxlZCB0byBjb25uZWN0IHRvICR7dGhpcy5uZGtSZWxheS51cmx9YCwgZSk7XG4gICAgICB0aGlzLl9zdGF0dXMgPSAxIC8qIERJU0NPTk5FQ1RFRCAqLztcbiAgICAgIGlmIChyZWNvbm5lY3QpIHRoaXMuaGFuZGxlUmVjb25uZWN0aW9uKCk7XG4gICAgICBlbHNlIHRoaXMubmRrUmVsYXkuZW1pdChcImRlbGF5ZWQtY29ubmVjdFwiLCAyICogMjQgKiA2MCAqIDYwICogMWUzKTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBEaXNjb25uZWN0cyB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gdG8gdGhlIE5ESyByZWxheS5cbiAgICogVGhpcyBtZXRob2Qgc2V0cyB0aGUgY29ubmVjdGlvbiBzdGF0dXMgdG8gYE5ES1JlbGF5U3RhdHVzLkRJU0NPTk5FQ1RJTkdgLFxuICAgKiBhdHRlbXB0cyB0byBjbG9zZSB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24sIGFuZCBzZXRzIHRoZSBzdGF0dXMgdG9cbiAgICogYE5ES1JlbGF5U3RhdHVzLkRJU0NPTk5FQ1RFRGAgaWYgdGhlIGRpc2Nvbm5lY3Qgb3BlcmF0aW9uIGZhaWxzLlxuICAgKi9cbiAgZGlzY29ubmVjdCgpIHtcbiAgICB0aGlzLl9zdGF0dXMgPSAwIC8qIERJU0NPTk5FQ1RJTkcgKi87XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMud3M/LmNsb3NlKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhpcy5kZWJ1ZyhcIkZhaWxlZCB0byBkaXNjb25uZWN0XCIsIGUpO1xuICAgICAgdGhpcy5fc3RhdHVzID0gMSAvKiBESVNDT05ORUNURUQgKi87XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSBlcnJvciB0aGF0IG9jY3VycmVkIHdoZW4gYXR0ZW1wdGluZyB0byBjb25uZWN0IHRvIHRoZSBOREsgcmVsYXkuXG4gICAqIElmIGByZWNvbm5lY3RgIGlzIGB0cnVlYCwgdGhpcyBtZXRob2Qgd2lsbCBpbml0aWF0ZSBhIHJlY29ubmVjdGlvbiBhdHRlbXB0LlxuICAgKiBPdGhlcndpc2UsIGl0IHdpbGwgZW1pdCBhIGBkZWxheWVkLWNvbm5lY3RgIGV2ZW50IG9uIHRoZSBgbmRrUmVsYXlgIG9iamVjdCxcbiAgICogaW5kaWNhdGluZyB0aGF0IGEgcmVjb25uZWN0aW9uIHNob3VsZCBiZSBhdHRlbXB0ZWQgYWZ0ZXIgYSBkZWxheS5cbiAgICpcbiAgICogQHBhcmFtIHJlY29ubmVjdCAtIEluZGljYXRlcyB3aGV0aGVyIGEgcmVjb25uZWN0aW9uIHNob3VsZCBiZSBhdHRlbXB0ZWQuXG4gICAqL1xuICBvbkNvbm5lY3Rpb25FcnJvcihyZWNvbm5lY3QpIHtcbiAgICB0aGlzLmRlYnVnKGBFcnJvciBjb25uZWN0aW5nIHRvICR7dGhpcy5uZGtSZWxheS51cmx9YCwgdGhpcy50aW1lb3V0TXMpO1xuICAgIGlmIChyZWNvbm5lY3QgJiYgIXRoaXMucmVjb25uZWN0VGltZW91dCkge1xuICAgICAgdGhpcy5oYW5kbGVSZWNvbm5lY3Rpb24oKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIGNvbm5lY3Rpb24gZXZlbnQgd2hlbiB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gaXMgZXN0YWJsaXNoZWQuXG4gICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCB3aGVuIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBpcyBzdWNjZXNzZnVsbHkgb3BlbmVkLlxuICAgKiBJdCBjbGVhcnMgYW55IGV4aXN0aW5nIGNvbm5lY3Rpb24gYW5kIHJlY29ubmVjdGlvbiB0aW1lb3V0cywgdXBkYXRlcyB0aGUgY29ubmVjdGlvbiBzdGF0aXN0aWNzLFxuICAgKiBzZXRzIHRoZSBjb25uZWN0aW9uIHN0YXR1cyB0byBgQ09OTkVDVEVEYCwgYW5kIGVtaXRzIGBjb25uZWN0YCBhbmQgYHJlYWR5YCBldmVudHMgb24gdGhlIGBuZGtSZWxheWAgb2JqZWN0LlxuICAgKi9cbiAgb25Db25uZWN0KCkge1xuICAgIHRoaXMubmV0RGVidWc/LihcImNvbm5lY3RlZFwiLCB0aGlzLm5ka1JlbGF5KTtcbiAgICBpZiAodGhpcy5yZWNvbm5lY3RUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5yZWNvbm5lY3RUaW1lb3V0KTtcbiAgICAgIHRoaXMucmVjb25uZWN0VGltZW91dCA9IHZvaWQgMDtcbiAgICB9XG4gICAgaWYgKHRoaXMuY29ubmVjdFRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNvbm5lY3RUaW1lb3V0KTtcbiAgICAgIHRoaXMuY29ubmVjdFRpbWVvdXQgPSB2b2lkIDA7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlQ29ubmVjdGlvblN0YXRzLmNvbm5lY3RlZCgpO1xuICAgIHRoaXMuX3N0YXR1cyA9IDUgLyogQ09OTkVDVEVEICovO1xuICAgIHRoaXMubmRrUmVsYXkuZW1pdChcImNvbm5lY3RcIik7XG4gICAgdGhpcy5uZGtSZWxheS5lbWl0KFwicmVhZHlcIik7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIGRpc2Nvbm5lY3Rpb24gZXZlbnQgd2hlbiB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gaXMgY2xvc2VkLlxuICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgd2hlbiB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gaXMgc3VjY2Vzc2Z1bGx5IGNsb3NlZC5cbiAgICogSXQgdXBkYXRlcyB0aGUgY29ubmVjdGlvbiBzdGF0aXN0aWNzLCBzZXRzIHRoZSBjb25uZWN0aW9uIHN0YXR1cyB0byBgRElTQ09OTkVDVEVEYCxcbiAgICogaW5pdGlhdGVzIGEgcmVjb25uZWN0aW9uIGF0dGVtcHQgaWYgd2UgZGlkbid0IGRpc2Nvbm5lY3Qgb3Vyc2VsdmVzLFxuICAgKiBhbmQgZW1pdHMgYSBgZGlzY29ubmVjdGAgZXZlbnQgb24gdGhlIGBuZGtSZWxheWAgb2JqZWN0LlxuICAgKi9cbiAgb25EaXNjb25uZWN0KCkge1xuICAgIHRoaXMubmV0RGVidWc/LihcImRpc2Nvbm5lY3RlZFwiLCB0aGlzLm5ka1JlbGF5KTtcbiAgICB0aGlzLnVwZGF0ZUNvbm5lY3Rpb25TdGF0cy5kaXNjb25uZWN0ZWQoKTtcbiAgICBpZiAodGhpcy5fc3RhdHVzID09PSA1IC8qIENPTk5FQ1RFRCAqLykge1xuICAgICAgdGhpcy5oYW5kbGVSZWNvbm5lY3Rpb24oKTtcbiAgICB9XG4gICAgdGhpcy5fc3RhdHVzID0gMSAvKiBESVNDT05ORUNURUQgKi87XG4gICAgdGhpcy5uZGtSZWxheS5lbWl0KFwiZGlzY29ubmVjdFwiKTtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlcyBpbmNvbWluZyBtZXNzYWdlcyBmcm9tIHRoZSBOREsgcmVsYXkgV2ViU29ja2V0IGNvbm5lY3Rpb24uXG4gICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCB3aGVuZXZlciBhIG1lc3NhZ2UgaXMgcmVjZWl2ZWQgZnJvbSB0aGUgcmVsYXkuXG4gICAqIEl0IHBhcnNlcyB0aGUgbWVzc2FnZSBkYXRhIGFuZCBkaXNwYXRjaGVzIHRoZSBhcHByb3ByaWF0ZSBoYW5kbGluZyBsb2dpYyBiYXNlZCBvbiB0aGUgbWVzc2FnZSB0eXBlLlxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQgLSBUaGUgTWVzc2FnZUV2ZW50IGNvbnRhaW5pbmcgdGhlIHJlY2VpdmVkIG1lc3NhZ2UgZGF0YS5cbiAgICovXG4gIG9uTWVzc2FnZShldmVudCkge1xuICAgIHRoaXMubmV0RGVidWc/LihldmVudC5kYXRhLCB0aGlzLm5ka1JlbGF5LCBcInJlY3ZcIik7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpO1xuICAgICAgY29uc3QgW2NtZCwgaWQsIC4uLnJlc3RdID0gZGF0YTtcbiAgICAgIHN3aXRjaCAoY21kKSB7XG4gICAgICAgIGNhc2UgXCJFVkVOVFwiOiB7XG4gICAgICAgICAgY29uc3Qgc28gPSB0aGlzLm9wZW5TdWJzLmdldChpZCk7XG4gICAgICAgICAgY29uc3QgZXZlbnQyID0gZGF0YVsyXTtcbiAgICAgICAgICBpZiAoIXNvKSB7XG4gICAgICAgICAgICB0aGlzLmRlYnVnKGBSZWNlaXZlZCBldmVudCBmb3IgdW5rbm93biBzdWJzY3JpcHRpb24gJHtpZH1gKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgc28ub25ldmVudChldmVudDIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiQ09VTlRcIjoge1xuICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBkYXRhWzJdO1xuICAgICAgICAgIGNvbnN0IGNyID0gdGhpcy5vcGVuQ291bnRSZXF1ZXN0cy5nZXQoaWQpO1xuICAgICAgICAgIGlmIChjcikge1xuICAgICAgICAgICAgY3IucmVzb2x2ZShwYXlsb2FkLmNvdW50KTtcbiAgICAgICAgICAgIHRoaXMub3BlbkNvdW50UmVxdWVzdHMuZGVsZXRlKGlkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJFT1NFXCI6IHtcbiAgICAgICAgICBjb25zdCBzbyA9IHRoaXMub3BlblN1YnMuZ2V0KGlkKTtcbiAgICAgICAgICBpZiAoIXNvKSByZXR1cm47XG4gICAgICAgICAgc28ub25lb3NlKGlkKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIk9LXCI6IHtcbiAgICAgICAgICBjb25zdCBvayA9IGRhdGFbMl07XG4gICAgICAgICAgY29uc3QgcmVhc29uID0gZGF0YVszXTtcbiAgICAgICAgICBjb25zdCBlcCA9IHRoaXMub3BlbkV2ZW50UHVibGlzaGVzLmdldChpZCk7XG4gICAgICAgICAgY29uc3QgZmlyc3RFcCA9IGVwPy5wb3AoKTtcbiAgICAgICAgICBpZiAoIWVwIHx8ICFmaXJzdEVwKSB7XG4gICAgICAgICAgICB0aGlzLmRlYnVnKFwiUmVjZWl2ZWQgT0sgZm9yIHVua25vd24gZXZlbnQgcHVibGlzaFwiLCBpZCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvaykgZmlyc3RFcC5yZXNvbHZlKHJlYXNvbik7XG4gICAgICAgICAgZWxzZSBmaXJzdEVwLnJlamVjdChuZXcgRXJyb3IocmVhc29uKSk7XG4gICAgICAgICAgaWYgKGVwLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5vcGVuRXZlbnRQdWJsaXNoZXMuZGVsZXRlKGlkKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vcGVuRXZlbnRQdWJsaXNoZXMuc2V0KGlkLCBlcCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiQ0xPU0VEXCI6IHtcbiAgICAgICAgICBjb25zdCBzbyA9IHRoaXMub3BlblN1YnMuZ2V0KGlkKTtcbiAgICAgICAgICBpZiAoIXNvKSByZXR1cm47XG4gICAgICAgICAgc28ub25jbG9zZWQoZGF0YVsyXSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJOT1RJQ0VcIjpcbiAgICAgICAgICB0aGlzLm9uTm90aWNlKGRhdGFbMV0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSBcIkFVVEhcIjoge1xuICAgICAgICAgIHRoaXMub25BdXRoUmVxdWVzdGVkKGRhdGFbMV0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmRlYnVnKFxuICAgICAgICBgRXJyb3IgcGFyc2luZyBtZXNzYWdlIGZyb20gJHt0aGlzLm5ka1JlbGF5LnVybH06ICR7ZXJyb3IubWVzc2FnZX1gLFxuICAgICAgICBlcnJvcj8uc3RhY2tcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBIYW5kbGVzIGFuIGF1dGhlbnRpY2F0aW9uIHJlcXVlc3QgZnJvbSB0aGUgTkRLIHJlbGF5LlxuICAgKlxuICAgKiBJZiBhbiBhdXRoZW50aWNhdGlvbiBwb2xpY3kgaXMgY29uZmlndXJlZCwgaXQgd2lsbCBiZSB1c2VkIHRvIGF1dGhlbnRpY2F0ZSB0aGUgY29ubmVjdGlvbi5cbiAgICogT3RoZXJ3aXNlLCB0aGUgYGF1dGhgIGV2ZW50IHdpbGwgYmUgZW1pdHRlZCB0byBhbGxvdyB0aGUgYXBwbGljYXRpb24gdG8gaGFuZGxlIHRoZSBhdXRoZW50aWNhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIGNoYWxsZW5nZSAtIFRoZSBhdXRoZW50aWNhdGlvbiBjaGFsbGVuZ2UgcHJvdmlkZWQgYnkgdGhlIE5ESyByZWxheS5cbiAgICovXG4gIGFzeW5jIG9uQXV0aFJlcXVlc3RlZChjaGFsbGVuZ2UpIHtcbiAgICBjb25zdCBhdXRoUG9saWN5ID0gdGhpcy5uZGtSZWxheS5hdXRoUG9saWN5ID8/IHRoaXMubmRrPy5yZWxheUF1dGhEZWZhdWx0UG9saWN5O1xuICAgIHRoaXMuZGVidWcoXCJSZWxheSByZXF1ZXN0ZWQgYXV0aGVudGljYXRpb25cIiwge1xuICAgICAgaGF2ZVBvbGljeTogISFhdXRoUG9saWN5XG4gICAgfSk7XG4gICAgaWYgKHRoaXMuX3N0YXR1cyA9PT0gNyAvKiBBVVRIRU5USUNBVElORyAqLykge1xuICAgICAgdGhpcy5kZWJ1ZyhcIkFscmVhZHkgYXV0aGVudGljYXRpbmcsIGlnbm9yaW5nXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9zdGF0dXMgPSA2IC8qIEFVVEhfUkVRVUVTVEVEICovO1xuICAgIGlmIChhdXRoUG9saWN5KSB7XG4gICAgICBpZiAodGhpcy5fc3RhdHVzID49IDUgLyogQ09OTkVDVEVEICovKSB7XG4gICAgICAgIHRoaXMuX3N0YXR1cyA9IDcgLyogQVVUSEVOVElDQVRJTkcgKi87XG4gICAgICAgIGxldCByZXM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVzID0gYXdhaXQgYXV0aFBvbGljeSh0aGlzLm5ka1JlbGF5LCBjaGFsbGVuZ2UpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhpcy5kZWJ1ZyhcIkF1dGhlbnRpY2F0aW9uIHBvbGljeSB0aHJldyBhbiBlcnJvclwiLCBlKTtcbiAgICAgICAgICByZXMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlYnVnKFwiQXV0aGVudGljYXRpb24gcG9saWN5IHJldHVybmVkXCIsICEhcmVzKTtcbiAgICAgICAgaWYgKHJlcyBpbnN0YW5jZW9mIE5ES0V2ZW50IHx8IHJlcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGlmIChyZXMgaW5zdGFuY2VvZiBOREtFdmVudCkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5hdXRoKHJlcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGF1dGhlbnRpY2F0ZSA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0dXMgPj0gNSAvKiBDT05ORUNURUQgKi8gJiYgdGhpcy5fc3RhdHVzIDwgOCAvKiBBVVRIRU5USUNBVEVEICovKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IE5ES0V2ZW50KHRoaXMubmRrKTtcbiAgICAgICAgICAgICAgZXZlbnQua2luZCA9IDIyMjQyIC8qIENsaWVudEF1dGggKi87XG4gICAgICAgICAgICAgIGV2ZW50LnRhZ3MgPSBbXG4gICAgICAgICAgICAgICAgW1wicmVsYXlcIiwgdGhpcy5uZGtSZWxheS51cmxdLFxuICAgICAgICAgICAgICAgIFtcImNoYWxsZW5nZVwiLCBjaGFsbGVuZ2VdXG4gICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgIGF3YWl0IGV2ZW50LnNpZ24oKTtcbiAgICAgICAgICAgICAgdGhpcy5hdXRoKGV2ZW50KS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0dXMgPSA4IC8qIEFVVEhFTlRJQ0FURUQgKi87XG4gICAgICAgICAgICAgICAgdGhpcy5uZGtSZWxheS5lbWl0KFwiYXV0aGVkXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVidWcoXCJBdXRoZW50aWNhdGlvbiBzdWNjZXNzZnVsXCIpO1xuICAgICAgICAgICAgICB9KS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXR1cyA9IDYgLyogQVVUSF9SRVFVRVNURUQgKi87XG4gICAgICAgICAgICAgICAgdGhpcy5uZGtSZWxheS5lbWl0KFwiYXV0aDpmYWlsZWRcIiwgZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWJ1ZyhcIkF1dGhlbnRpY2F0aW9uIGZhaWxlZFwiLCBlKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLmRlYnVnKFxuICAgICAgICAgICAgICAgIFwiQXV0aGVudGljYXRpb24gZmFpbGVkLCBpdCBjaGFuZ2VkIHN0YXR1cywgc3RhdHVzIGlzICVkXCIsXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdHVzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAocmVzID09PSB0cnVlKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMubmRrPy5zaWduZXIpIHtcbiAgICAgICAgICAgICAgdGhpcy5kZWJ1ZyhcIk5vIHNpZ25lciBhdmFpbGFibGUgZm9yIGF1dGhlbnRpY2F0aW9uIGxvY2FsaG9zdFwiKTtcbiAgICAgICAgICAgICAgdGhpcy5uZGs/Lm9uY2UoXCJzaWduZXI6cmVhZHlcIiwgYXV0aGVudGljYXRlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGF1dGhlbnRpY2F0ZSgpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGF1dGhlbnRpY2F0aW5nXCIsIGUpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fc3RhdHVzID0gNSAvKiBDT05ORUNURUQgKi87XG4gICAgICAgICAgdGhpcy5uZGtSZWxheS5lbWl0KFwiYXV0aGVkXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubmRrUmVsYXkuZW1pdChcImF1dGhcIiwgY2hhbGxlbmdlKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZXMgZXJyb3JzIHRoYXQgb2NjdXIgb24gdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIHRvIHRoZSByZWxheS5cbiAgICogQHBhcmFtIGVycm9yIC0gVGhlIGVycm9yIG9yIGV2ZW50IHRoYXQgb2NjdXJyZWQuXG4gICAqL1xuICBvbkVycm9yKGVycm9yKSB7XG4gICAgdGhpcy5kZWJ1ZyhgV2ViU29ja2V0IGVycm9yIG9uICR7dGhpcy5uZGtSZWxheS51cmx9OmAsIGVycm9yKTtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgY3VycmVudCBzdGF0dXMgb2YgdGhlIE5ESyByZWxheSBjb25uZWN0aW9uLlxuICAgKiBAcmV0dXJucyB7TkRLUmVsYXlTdGF0dXN9IFRoZSBjdXJyZW50IHN0YXR1cyBvZiB0aGUgTkRLIHJlbGF5IGNvbm5lY3Rpb24uXG4gICAqL1xuICBnZXQgc3RhdHVzKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0dXM7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgTkRLIHJlbGF5IGNvbm5lY3Rpb24gaXMgY3VycmVudGx5IGF2YWlsYWJsZS5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgcmVsYXkgY29ubmVjdGlvbiBpcyBpbiB0aGUgYENPTk5FQ1RFRGAgc3RhdHVzLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICovXG4gIGlzQXZhaWxhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0dXMgPT09IDUgLyogQ09OTkVDVEVEICovO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIE5ESyByZWxheSBjb25uZWN0aW9uIGlzIGZsYXBwaW5nLCB3aGljaCBtZWFucyB0aGUgY29ubmVjdGlvbiBpcyByYXBpZGx5XG4gICAqIGRpc2Nvbm5lY3RpbmcgYW5kIHJlY29ubmVjdGluZy4gVGhpcyBpcyBkZXRlcm1pbmVkIGJ5IGFuYWx5emluZyB0aGUgZHVyYXRpb25zIG9mIHRoZVxuICAgKiBsYXN0IHRocmVlIGNvbm5lY3Rpb24gYXR0ZW1wdHMuIElmIHRoZSBzdGFuZGFyZCBkZXZpYXRpb24gb2YgdGhlIGR1cmF0aW9ucyBpcyBsZXNzXG4gICAqIHRoYW4gMTAwMCBtaWxsaXNlY29uZHMsIHRoZSBjb25uZWN0aW9uIGlzIGNvbnNpZGVyZWQgdG8gYmUgZmxhcHBpbmcuXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIGNvbm5lY3Rpb24gaXMgZmxhcHBpbmcsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgKi9cbiAgaXNGbGFwcGluZygpIHtcbiAgICBjb25zdCBkdXJhdGlvbnMgPSB0aGlzLl9jb25uZWN0aW9uU3RhdHMuZHVyYXRpb25zO1xuICAgIGlmIChkdXJhdGlvbnMubGVuZ3RoICUgMyAhPT0gMCkgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHN1bSA9IGR1cmF0aW9ucy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKTtcbiAgICBjb25zdCBhdmcgPSBzdW0gLyBkdXJhdGlvbnMubGVuZ3RoO1xuICAgIGNvbnN0IHZhcmlhbmNlID0gZHVyYXRpb25zLm1hcCgoeCkgPT4gTWF0aC5wb3coeCAtIGF2ZywgMikpLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApIC8gZHVyYXRpb25zLmxlbmd0aDtcbiAgICBjb25zdCBzdGREZXYgPSBNYXRoLnNxcnQodmFyaWFuY2UpO1xuICAgIGNvbnN0IGlzRmxhcHBpbmcgPSBzdGREZXYgPCBGTEFQUElOR19USFJFU0hPTERfTVM7XG4gICAgcmV0dXJuIGlzRmxhcHBpbmc7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZXMgYSBub3RpY2UgcmVjZWl2ZWQgZnJvbSB0aGUgTkRLIHJlbGF5LlxuICAgKiBJZiB0aGUgbm90aWNlIGluZGljYXRlcyB0aGUgcmVsYXkgaXMgY29tcGxhaW5pbmcgKGUuZy4gXCJ0b28gbWFueVwiIG9yIFwibWF4aW11bVwiKSxcbiAgICogdGhlIG1ldGhvZCBkaXNjb25uZWN0cyBmcm9tIHRoZSByZWxheSBhbmQgYXR0ZW1wdHMgdG8gcmVjb25uZWN0IGFmdGVyIGEgMi1zZWNvbmQgZGVsYXkuXG4gICAqIEEgZGVidWcgbWVzc2FnZSBpcyBsb2dnZWQgd2l0aCB0aGUgcmVsYXkgVVJMIGFuZCB0aGUgbm90aWNlIHRleHQuXG4gICAqIFRoZSBcIm5vdGljZVwiIGV2ZW50IGlzIGVtaXR0ZWQgb24gdGhlIG5ka1JlbGF5IGluc3RhbmNlIHdpdGggdGhlIG5vdGljZSB0ZXh0LlxuICAgKlxuICAgKiBAcGFyYW0gbm90aWNlIC0gVGhlIG5vdGljZSB0ZXh0IHJlY2VpdmVkIGZyb20gdGhlIE5ESyByZWxheS5cbiAgICovXG4gIGFzeW5jIG9uTm90aWNlKG5vdGljZSkge1xuICAgIHRoaXMubmRrUmVsYXkuZW1pdChcIm5vdGljZVwiLCBub3RpY2UpO1xuICB9XG4gIC8qKlxuICAgKiBBdHRlbXB0cyB0byByZWNvbm5lY3QgdG8gdGhlIE5ESyByZWxheSBhZnRlciBhIGNvbm5lY3Rpb24gaXMgbG9zdC5cbiAgICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgcmVjdXJzaXZlbHkgdG8gaGFuZGxlIG11bHRpcGxlIHJlY29ubmVjdGlvbiBhdHRlbXB0cy5cbiAgICogSXQgY2hlY2tzIGlmIHRoZSByZWxheSBpcyBmbGFwcGluZyBhbmQgZW1pdHMgYSBcImZsYXBwaW5nXCIgZXZlbnQgaWYgc28uXG4gICAqIEl0IHRoZW4gY2FsY3VsYXRlcyBhIGRlbGF5IGJlZm9yZSB0aGUgbmV4dCByZWNvbm5lY3Rpb24gYXR0ZW1wdCBiYXNlZCBvbiB0aGUgbnVtYmVyIG9mIHByZXZpb3VzIGF0dGVtcHRzLlxuICAgKiBUaGUgZnVuY3Rpb24gc2V0cyBhIHRpbWVvdXQgdG8gZXhlY3V0ZSB0aGUgbmV4dCByZWNvbm5lY3Rpb24gYXR0ZW1wdCBhZnRlciB0aGUgY2FsY3VsYXRlZCBkZWxheS5cbiAgICogSWYgdGhlIG1heGltdW0gbnVtYmVyIG9mIHJlY29ubmVjdGlvbiBhdHRlbXB0cyBpcyByZWFjaGVkLCBhIGRlYnVnIG1lc3NhZ2UgaXMgbG9nZ2VkLlxuICAgKlxuICAgKiBAcGFyYW0gYXR0ZW1wdCAtIFRoZSBjdXJyZW50IGF0dGVtcHQgbnVtYmVyIChkZWZhdWx0IGlzIDApLlxuICAgKi9cbiAgaGFuZGxlUmVjb25uZWN0aW9uKGF0dGVtcHQgPSAwKSB7XG4gICAgaWYgKHRoaXMucmVjb25uZWN0VGltZW91dCkgcmV0dXJuO1xuICAgIGlmICh0aGlzLmlzRmxhcHBpbmcoKSkge1xuICAgICAgdGhpcy5uZGtSZWxheS5lbWl0KFwiZmxhcHBpbmdcIiwgdGhpcy5fY29ubmVjdGlvblN0YXRzKTtcbiAgICAgIHRoaXMuX3N0YXR1cyA9IDMgLyogRkxBUFBJTkcgKi87XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlY29ubmVjdERlbGF5ID0gdGhpcy5jb25uZWN0ZWRBdCA/IE1hdGgubWF4KDAsIDZlNCAtIChEYXRlLm5vdygpIC0gdGhpcy5jb25uZWN0ZWRBdCkpIDogNWUzICogKHRoaXMuX2Nvbm5lY3Rpb25TdGF0cy5hdHRlbXB0cyArIDEpO1xuICAgIHRoaXMucmVjb25uZWN0VGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5yZWNvbm5lY3RUaW1lb3V0ID0gdm9pZCAwO1xuICAgICAgdGhpcy5fc3RhdHVzID0gMiAvKiBSRUNPTk5FQ1RJTkcgKi87XG4gICAgICB0aGlzLmNvbm5lY3QoKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIGlmIChhdHRlbXB0IDwgTUFYX1JFQ09OTkVDVF9BVFRFTVBUUykge1xuICAgICAgICAgIHNldFRpbWVvdXQoXG4gICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMuaGFuZGxlUmVjb25uZWN0aW9uKGF0dGVtcHQgKyAxKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAxZTMgKiAoYXR0ZW1wdCArIDEpIF4gNFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5kZWJ1ZyhcIlJlY29ubmVjdCBmYWlsZWRcIik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sIHJlY29ubmVjdERlbGF5KTtcbiAgICB0aGlzLm5ka1JlbGF5LmVtaXQoXCJkZWxheWVkLWNvbm5lY3RcIiwgcmVjb25uZWN0RGVsYXkpO1xuICAgIHRoaXMuZGVidWcoXCJSZWNvbm5lY3RpbmcgaW5cIiwgcmVjb25uZWN0RGVsYXkpO1xuICAgIHRoaXMuX2Nvbm5lY3Rpb25TdGF0cy5uZXh0UmVjb25uZWN0QXQgPSBEYXRlLm5vdygpICsgcmVjb25uZWN0RGVsYXk7XG4gIH1cbiAgLyoqXG4gICAqIFNlbmRzIGEgbWVzc2FnZSB0byB0aGUgTkRLIHJlbGF5IGlmIHRoZSBjb25uZWN0aW9uIGlzIGluIHRoZSBDT05ORUNURUQgc3RhdGUgYW5kIHRoZSBXZWJTb2NrZXQgaXMgb3Blbi5cbiAgICogSWYgdGhlIGNvbm5lY3Rpb24gaXMgbm90IGluIHRoZSBDT05ORUNURUQgc3RhdGUgb3IgdGhlIFdlYlNvY2tldCBpcyBub3Qgb3BlbiwgbG9ncyBhIGRlYnVnIG1lc3NhZ2UgYW5kIHRocm93cyBhbiBlcnJvci5cbiAgICpcbiAgICogQHBhcmFtIG1lc3NhZ2UgLSBUaGUgbWVzc2FnZSB0byBzZW5kIHRvIHRoZSBOREsgcmVsYXkuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBhdHRlbXB0aW5nIHRvIHNlbmQgb24gYSBjbG9zZWQgcmVsYXkgY29ubmVjdGlvbi5cbiAgICovXG4gIGFzeW5jIHNlbmQobWVzc2FnZSkge1xuICAgIGlmICh0aGlzLl9zdGF0dXMgPj0gNSAvKiBDT05ORUNURUQgKi8gJiYgdGhpcy53cz8ucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0Lk9QRU4pIHtcbiAgICAgIHRoaXMud3M/LnNlbmQobWVzc2FnZSk7XG4gICAgICB0aGlzLm5ldERlYnVnPy4obWVzc2FnZSwgdGhpcy5uZGtSZWxheSwgXCJzZW5kXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlYnVnKFxuICAgICAgICBgTm90IGNvbm5lY3RlZCB0byAke3RoaXMubmRrUmVsYXkudXJsfSAoJWQpLCBub3Qgc2VuZGluZyBtZXNzYWdlICR7bWVzc2FnZX1gLFxuICAgICAgICB0aGlzLl9zdGF0dXNcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBBdXRoZW50aWNhdGVzIHRoZSBOREsgZXZlbnQgYnkgc2VuZGluZyBpdCB0byB0aGUgTkRLIHJlbGF5IGFuZCByZXR1cm5pbmcgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgcmVzdWx0LlxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQgLSBUaGUgTkRLIGV2ZW50IHRvIGF1dGhlbnRpY2F0ZS5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgYXV0aGVudGljYXRpb24gcmVzdWx0LlxuICAgKi9cbiAgYXN5bmMgYXV0aChldmVudCkge1xuICAgIGNvbnN0IHJldCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHZhbCA9IHRoaXMub3BlbkV2ZW50UHVibGlzaGVzLmdldChldmVudC5pZCkgPz8gW107XG4gICAgICB2YWwucHVzaCh7IHJlc29sdmUsIHJlamVjdCB9KTtcbiAgICAgIHRoaXMub3BlbkV2ZW50UHVibGlzaGVzLnNldChldmVudC5pZCwgdmFsKTtcbiAgICB9KTtcbiAgICB0aGlzLnNlbmQoJ1tcIkFVVEhcIiwnICsgSlNPTi5zdHJpbmdpZnkoZXZlbnQucmF3RXZlbnQoKSkgKyBcIl1cIik7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICAvKipcbiAgICogUHVibGlzaGVzIGFuIE5ESyBldmVudCB0byB0aGUgcmVsYXkgYW5kIHJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgcmVzdWx0LlxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQgLSBUaGUgTkRLIGV2ZW50IHRvIHB1Ymxpc2guXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIHJlc3VsdCBvZiB0aGUgZXZlbnQgcHVibGljYXRpb24uXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBhdHRlbXB0aW5nIHRvIHB1Ymxpc2ggb24gYSBjbG9zZWQgcmVsYXkgY29ubmVjdGlvbi5cbiAgICovXG4gIGFzeW5jIHB1Ymxpc2goZXZlbnQpIHtcbiAgICBjb25zdCByZXQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCB2YWwgPSB0aGlzLm9wZW5FdmVudFB1Ymxpc2hlcy5nZXQoZXZlbnQuaWQpID8/IFtdO1xuICAgICAgaWYgKHZhbC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBcIkR1cGxpY2F0ZSBldmVudCBwdWJsaXNoaW5nIGRldGVjdGVkLCB5b3UgYXJlIHB1Ymxpc2hpbmcgZXZlbnQgXCIgKyBldmVudC5pZCArIFwiIHR3aWNlXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHZhbC5wdXNoKHsgcmVzb2x2ZSwgcmVqZWN0IH0pO1xuICAgICAgdGhpcy5vcGVuRXZlbnRQdWJsaXNoZXMuc2V0KGV2ZW50LmlkLCB2YWwpO1xuICAgIH0pO1xuICAgIHRoaXMuc2VuZCgnW1wiRVZFTlRcIiwnICsgSlNPTi5zdHJpbmdpZnkoZXZlbnQpICsgXCJdXCIpO1xuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgLyoqXG4gICAqIENvdW50cyB0aGUgbnVtYmVyIG9mIGV2ZW50cyB0aGF0IG1hdGNoIHRoZSBwcm92aWRlZCBmaWx0ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0gZmlsdGVycyAtIFRoZSBmaWx0ZXJzIHRvIGFwcGx5IHRvIHRoZSBjb3VudCByZXF1ZXN0LlxuICAgKiBAcGFyYW0gcGFyYW1zIC0gQW4gb3B0aW9uYWwgb2JqZWN0IGNvbnRhaW5pbmcgYSBjdXN0b20gaWQgZm9yIHRoZSBjb3VudCByZXF1ZXN0LlxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBudW1iZXIgb2YgbWF0Y2hpbmcgZXZlbnRzLlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgYXR0ZW1wdGluZyB0byBzZW5kIHRoZSBjb3VudCByZXF1ZXN0IG9uIGEgY2xvc2VkIHJlbGF5IGNvbm5lY3Rpb24uXG4gICAqL1xuICBhc3luYyBjb3VudChmaWx0ZXJzLCBwYXJhbXMpIHtcbiAgICB0aGlzLnNlcmlhbCsrO1xuICAgIGNvbnN0IGlkID0gcGFyYW1zPy5pZCB8fCBcImNvdW50OlwiICsgdGhpcy5zZXJpYWw7XG4gICAgY29uc3QgcmV0ID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5vcGVuQ291bnRSZXF1ZXN0cy5zZXQoaWQsIHsgcmVzb2x2ZSwgcmVqZWN0IH0pO1xuICAgIH0pO1xuICAgIHRoaXMuc2VuZCgnW1wiQ09VTlRcIixcIicgKyBpZCArICdcIiwnICsgSlNPTi5zdHJpbmdpZnkoZmlsdGVycykuc3Vic3RyaW5nKDEpKTtcbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGNsb3NlKHN1YklkLCByZWFzb24pIHtcbiAgICB0aGlzLnNlbmQoJ1tcIkNMT1NFXCIsXCInICsgc3ViSWQgKyAnXCJdJyk7XG4gICAgY29uc3Qgc3ViID0gdGhpcy5vcGVuU3Vicy5nZXQoc3ViSWQpO1xuICAgIHRoaXMub3BlblN1YnMuZGVsZXRlKHN1YklkKTtcbiAgICBpZiAoc3ViKSBzdWIub25jbG9zZShyZWFzb24pO1xuICB9XG4gIC8qKlxuICAgKiBTdWJzY3JpYmVzIHRvIHRoZSBOREsgcmVsYXkgd2l0aCB0aGUgcHJvdmlkZWQgZmlsdGVycyBhbmQgcGFyYW1ldGVycy5cbiAgICpcbiAgICogQHBhcmFtIGZpbHRlcnMgLSBUaGUgZmlsdGVycyB0byBhcHBseSB0byB0aGUgc3Vic2NyaXB0aW9uLlxuICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHN1YnNjcmlwdGlvbiBwYXJhbWV0ZXJzLCBpbmNsdWRpbmcgYW4gb3B0aW9uYWwgY3VzdG9tIGlkLlxuICAgKiBAcmV0dXJucyBBIG5ldyBOREtSZWxheVN1YnNjcmlwdGlvbiBpbnN0YW5jZS5cbiAgICovXG4gIHJlcShyZWxheVN1Yikge1xuICAgIHRoaXMuc2VuZChcbiAgICAgICdbXCJSRVFcIixcIicgKyByZWxheVN1Yi5zdWJJZCArICdcIiwnICsgSlNPTi5zdHJpbmdpZnkocmVsYXlTdWIuZXhlY3V0ZUZpbHRlcnMpLnN1YnN0cmluZygxKVxuICAgICkgKyBcIl1cIjtcbiAgICB0aGlzLm9wZW5TdWJzLnNldChyZWxheVN1Yi5zdWJJZCwgcmVsYXlTdWIpO1xuICB9XG4gIC8qKlxuICAgKiBVdGlsaXR5IGZ1bmN0aW9ucyB0byB1cGRhdGUgdGhlIGNvbm5lY3Rpb24gc3RhdHMuXG4gICAqL1xuICB1cGRhdGVDb25uZWN0aW9uU3RhdHMgPSB7XG4gICAgY29ubmVjdGVkOiAoKSA9PiB7XG4gICAgICB0aGlzLl9jb25uZWN0aW9uU3RhdHMuc3VjY2VzcysrO1xuICAgICAgdGhpcy5fY29ubmVjdGlvblN0YXRzLmNvbm5lY3RlZEF0ID0gRGF0ZS5ub3coKTtcbiAgICB9LFxuICAgIGRpc2Nvbm5lY3RlZDogKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuX2Nvbm5lY3Rpb25TdGF0cy5jb25uZWN0ZWRBdCkge1xuICAgICAgICB0aGlzLl9jb25uZWN0aW9uU3RhdHMuZHVyYXRpb25zLnB1c2goXG4gICAgICAgICAgRGF0ZS5ub3coKSAtIHRoaXMuX2Nvbm5lY3Rpb25TdGF0cy5jb25uZWN0ZWRBdFxuICAgICAgICApO1xuICAgICAgICBpZiAodGhpcy5fY29ubmVjdGlvblN0YXRzLmR1cmF0aW9ucy5sZW5ndGggPiAxMDApIHtcbiAgICAgICAgICB0aGlzLl9jb25uZWN0aW9uU3RhdHMuZHVyYXRpb25zLnNoaWZ0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX2Nvbm5lY3Rpb25TdGF0cy5jb25uZWN0ZWRBdCA9IHZvaWQgMDtcbiAgICB9LFxuICAgIGF0dGVtcHQ6ICgpID0+IHtcbiAgICAgIHRoaXMuX2Nvbm5lY3Rpb25TdGF0cy5hdHRlbXB0cysrO1xuICAgICAgdGhpcy5fY29ubmVjdGlvblN0YXRzLmNvbm5lY3RlZEF0ID0gRGF0ZS5ub3coKTtcbiAgICB9XG4gIH07XG4gIC8qKiBSZXR1cm5zIHRoZSBjb25uZWN0aW9uIHN0YXRzLiAqL1xuICBnZXQgY29ubmVjdGlvblN0YXRzKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25uZWN0aW9uU3RhdHM7XG4gIH1cbiAgLyoqIFJldHVybnMgdGhlIHJlbGF5IFVSTCAqL1xuICBnZXQgdXJsKCkge1xuICAgIHJldHVybiB0aGlzLm5ka1JlbGF5LnVybDtcbiAgfVxuICBnZXQgY29ubmVjdGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0dXMgPj0gNSAvKiBDT05ORUNURUQgKi8gJiYgdGhpcy53cz8ucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0Lk9QRU47XG4gIH1cbn07XG5cbi8vIHNyYy9yZWxheS9wdWJsaXNoZXIudHNcbnZhciBOREtSZWxheVB1Ymxpc2hlciA9IGNsYXNzIHtcbiAgbmRrUmVsYXk7XG4gIGRlYnVnO1xuICBjb25zdHJ1Y3RvcihuZGtSZWxheSkge1xuICAgIHRoaXMubmRrUmVsYXkgPSBuZGtSZWxheTtcbiAgICB0aGlzLmRlYnVnID0gbmRrUmVsYXkuZGVidWcuZXh0ZW5kKFwicHVibGlzaGVyXCIpO1xuICB9XG4gIC8qKlxuICAgKiBQdWJsaXNoZWQgYW4gZXZlbnQgdG8gdGhlIHJlbGF5OyBpZiB0aGUgcmVsYXkgaXMgbm90IGNvbm5lY3RlZCwgaXQgd2lsbFxuICAgKiB3YWl0IGZvciB0aGUgcmVsYXkgdG8gY29ubmVjdCBiZWZvcmUgcHVibGlzaGluZyB0aGUgZXZlbnQuXG4gICAqXG4gICAqIElmIHRoZSByZWxheSBkb2VzIG5vdCBjb25uZWN0IHdpdGhpbiB0aGUgdGltZW91dCwgdGhlIHB1Ymxpc2ggb3BlcmF0aW9uXG4gICAqIHdpbGwgZmFpbC5cbiAgICogQHBhcmFtIGV2ZW50ICBUaGUgZXZlbnQgdG8gcHVibGlzaFxuICAgKiBAcGFyYW0gdGltZW91dE1zICBUaGUgdGltZW91dCBmb3IgdGhlIHB1Ymxpc2ggb3BlcmF0aW9uIGluIG1pbGxpc2Vjb25kc1xuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBldmVudCBoYXMgYmVlbiBwdWJsaXNoZWQgb3IgcmVqZWN0cyBpZiB0aGUgb3BlcmF0aW9uIHRpbWVzIG91dFxuICAgKi9cbiAgYXN5bmMgcHVibGlzaChldmVudCwgdGltZW91dE1zID0gMjUwMCkge1xuICAgIGxldCB0aW1lb3V0O1xuICAgIGNvbnN0IHB1Ymxpc2hDb25uZWN0ZWQgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMucHVibGlzaEV2ZW50KGV2ZW50KS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgIHRoaXMubmRrUmVsYXkuZW1pdChcInB1Ymxpc2hlZFwiLCBldmVudCk7XG4gICAgICAgICAgICBldmVudC5lbWl0KFwicmVsYXk6cHVibGlzaGVkXCIsIHRoaXMubmRrUmVsYXkpO1xuICAgICAgICAgICAgcmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICB9KS5jYXRjaChyZWplY3QpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCB0aW1lb3V0UHJvbWlzZSA9IG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGltZW91dCA9IHZvaWQgMDtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIlRpbWVvdXQ6IFwiICsgdGltZW91dE1zICsgXCJtc1wiKSk7XG4gICAgICB9LCB0aW1lb3V0TXMpO1xuICAgIH0pO1xuICAgIGNvbnN0IG9uQ29ubmVjdEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICBwdWJsaXNoQ29ubmVjdGVkKCkudGhlbigocmVzdWx0KSA9PiBjb25uZWN0UmVzb2x2ZShyZXN1bHQpKS5jYXRjaCgoZXJyKSA9PiBjb25uZWN0UmVqZWN0KGVycikpO1xuICAgIH07XG4gICAgbGV0IGNvbm5lY3RSZXNvbHZlO1xuICAgIGxldCBjb25uZWN0UmVqZWN0O1xuICAgIGNvbnN0IG9uRXJyb3IgPSAoZXJyKSA9PiB7XG4gICAgICB0aGlzLm5ka1JlbGF5LmRlYnVnKFwiUHVibGlzaCBmYWlsZWRcIiwgZXJyLCBldmVudC5pZCk7XG4gICAgICB0aGlzLm5ka1JlbGF5LmVtaXQoXCJwdWJsaXNoOmZhaWxlZFwiLCBldmVudCwgZXJyKTtcbiAgICAgIGV2ZW50LmVtaXQoXCJyZWxheTpwdWJsaXNoOmZhaWxlZFwiLCB0aGlzLm5ka1JlbGF5LCBlcnIpO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH07XG4gICAgY29uc3Qgb25GaW5hbGx5ID0gKCkgPT4ge1xuICAgICAgaWYgKHRpbWVvdXQpIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIHRoaXMubmRrUmVsYXkucmVtb3ZlTGlzdGVuZXIoXCJjb25uZWN0XCIsIG9uQ29ubmVjdEhhbmRsZXIpO1xuICAgIH07XG4gICAgaWYgKHRoaXMubmRrUmVsYXkuc3RhdHVzID49IDUgLyogQ09OTkVDVEVEICovKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtwdWJsaXNoQ29ubmVjdGVkKCksIHRpbWVvdXRQcm9taXNlXSkuY2F0Y2gob25FcnJvcikuZmluYWxseShvbkZpbmFsbHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5uZGtSZWxheS5zdGF0dXMgPD0gMSAvKiBESVNDT05ORUNURUQgKi8pIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIFwiUmVsYXkgaXMgZGlzY29ubmVjdGVkLCB0cnlpbmcgdG8gY29ubmVjdCB0byBwdWJsaXNoIGFuIGV2ZW50XCIsXG4gICAgICAgICAgdGhpcy5uZGtSZWxheS51cmxcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5uZGtSZWxheS5jb25uZWN0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgXCJSZWxheSBub3QgY29ubmVjdGVkLCB3YWl0aW5nIGZvciBjb25uZWN0aW9uIHRvIHB1Ymxpc2ggYW4gZXZlbnRcIixcbiAgICAgICAgICB0aGlzLm5ka1JlbGF5LnVybFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFByb21pc2UucmFjZShbXG4gICAgICAgIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICBjb25uZWN0UmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgY29ubmVjdFJlamVjdCA9IHJlamVjdDtcbiAgICAgICAgICB0aGlzLm5ka1JlbGF5Lm9uY2UoXCJjb25uZWN0XCIsIG9uQ29ubmVjdEhhbmRsZXIpO1xuICAgICAgICB9KSxcbiAgICAgICAgdGltZW91dFByb21pc2VcbiAgICAgIF0pLmNhdGNoKG9uRXJyb3IpLmZpbmFsbHkob25GaW5hbGx5KTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgcHVibGlzaEV2ZW50KGV2ZW50KSB7XG4gICAgcmV0dXJuIHRoaXMubmRrUmVsYXkuY29ubmVjdGl2aXR5LnB1Ymxpc2goZXZlbnQucmF3RXZlbnQoKSk7XG4gIH1cbn07XG5cbi8vIHNyYy9zdWJzY3JpcHRpb24vZ3JvdXBpbmcudHNcbmZ1bmN0aW9uIGZpbHRlckZpbmdlcnByaW50KGZpbHRlcnMsIGNsb3NlT25Fb3NlKSB7XG4gIGNvbnN0IGVsZW1lbnRzID0gW107XG4gIGZvciAoY29uc3QgZmlsdGVyIG9mIGZpbHRlcnMpIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmVudHJpZXMoZmlsdGVyIHx8IHt9KS5tYXAoKFtrZXksIHZhbHVlc10pID0+IHtcbiAgICAgIGlmIChbXCJzaW5jZVwiLCBcInVudGlsXCJdLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgcmV0dXJuIGtleSArIFwiOlwiICsgdmFsdWVzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgIH1cbiAgICB9KS5zb3J0KCkuam9pbihcIi1cIik7XG4gICAgZWxlbWVudHMucHVzaChrZXlzKTtcbiAgfVxuICBsZXQgaWQgPSBjbG9zZU9uRW9zZSA/IFwiK1wiIDogXCJcIjtcbiAgaWQgKz0gZWxlbWVudHMuam9pbihcInxcIik7XG4gIHJldHVybiBpZDtcbn1cbmZ1bmN0aW9uIG1lcmdlRmlsdGVycyhmaWx0ZXJzKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBjb25zdCBsYXN0UmVzdWx0ID0ge307XG4gIGZpbHRlcnMuZmlsdGVyKChmKSA9PiAhIWYubGltaXQpLmZvckVhY2goKGZpbHRlcldpdGhMaW1pdCkgPT4gcmVzdWx0LnB1c2goZmlsdGVyV2l0aExpbWl0KSk7XG4gIGZpbHRlcnMgPSBmaWx0ZXJzLmZpbHRlcigoZikgPT4gIWYubGltaXQpO1xuICBpZiAoZmlsdGVycy5sZW5ndGggPT09IDApIHJldHVybiByZXN1bHQ7XG4gIGZpbHRlcnMuZm9yRWFjaCgoZmlsdGVyKSA9PiB7XG4gICAgT2JqZWN0LmVudHJpZXMoZmlsdGVyKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBpZiAobGFzdFJlc3VsdFtrZXldID09PSB2b2lkIDApIHtcbiAgICAgICAgICBsYXN0UmVzdWx0W2tleV0gPSBbLi4udmFsdWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxhc3RSZXN1bHRba2V5XSA9IEFycmF5LmZyb20oLyogQF9fUFVSRV9fICovIG5ldyBTZXQoWy4uLmxhc3RSZXN1bHRba2V5XSwgLi4udmFsdWVdKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxhc3RSZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIFsuLi5yZXN1bHQsIGxhc3RSZXN1bHRdO1xufVxuXG4vLyBzcmMvcmVsYXkvc3Vic2NyaXB0aW9uLnRzXG52YXIgTkRLUmVsYXlTdWJzY3JpcHRpb24gPSBjbGFzcyB7XG4gIGZpbmdlcnByaW50O1xuICBpdGVtcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIHRvcFN1Yk1hbmFnZXI7XG4gIGRlYnVnO1xuICAvKipcbiAgICogVHJhY2tzIHRoZSBzdGF0dXMgb2YgdGhpcyBSRVEuXG4gICAqL1xuICBzdGF0dXMgPSAwIC8qIElOSVRJQUwgKi87XG4gIG9uQ2xvc2U7XG4gIHJlbGF5O1xuICAvKipcbiAgICogV2hldGhlciB0aGlzIHN1YnNjcmlwdGlvbiBoYXMgcmVhY2hlZCBFT1NFLlxuICAgKi9cbiAgZW9zZWQgPSBmYWxzZTtcbiAgLyoqXG4gICAqIFRpbWVvdXQgYXQgd2hpY2ggdGhpcyBzdWJzY3JpcHRpb24gd2lsbFxuICAgKiBzdGFydCBleGVjdXRpbmcuXG4gICAqL1xuICBleGVjdXRpb25UaW1lcjtcbiAgLyoqXG4gICAqIFRyYWNrIHRoZSB0aW1lIGF0IHdoaWNoIHRoaXMgc3Vic2NyaXB0aW9uIHdpbGwgZmlyZS5cbiAgICovXG4gIGZpcmVUaW1lO1xuICAvKipcbiAgICogVGhlIGRlbGF5IHR5cGUgdGhhdCB0aGUgY3VycmVudCBmaXJlVGltZSB3YXMgY2FsY3VsYXRlZCB3aXRoLlxuICAgKi9cbiAgZGVsYXlUeXBlO1xuICAvKipcbiAgICogVGhlIGZpbHRlcnMgdGhhdCBoYXZlIGJlZW4gZXhlY3V0ZWQuXG4gICAqL1xuICBleGVjdXRlRmlsdGVycztcbiAgaWQgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoNyk7XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0gZmluZ2VycHJpbnQgVGhlIGZpbmdlcnByaW50IG9mIHRoaXMgc3Vic2NyaXB0aW9uLlxuICAgKi9cbiAgY29uc3RydWN0b3IocmVsYXksIGZpbmdlcnByaW50LCB0b3BTdWJNYW5hZ2VyKSB7XG4gICAgdGhpcy5yZWxheSA9IHJlbGF5O1xuICAgIHRoaXMudG9wU3ViTWFuYWdlciA9IHRvcFN1Yk1hbmFnZXI7XG4gICAgdGhpcy5kZWJ1ZyA9IHJlbGF5LmRlYnVnLmV4dGVuZChcInN1YnNjcmlwdGlvbi1cIiArIHRoaXMuaWQpO1xuICAgIHRoaXMuZmluZ2VycHJpbnQgPSBmaW5nZXJwcmludCB8fCBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoNyk7XG4gIH1cbiAgX3N1YklkO1xuICBnZXQgc3ViSWQoKSB7XG4gICAgaWYgKHRoaXMuX3N1YklkKSByZXR1cm4gdGhpcy5fc3ViSWQ7XG4gICAgdGhpcy5fc3ViSWQgPSB0aGlzLmZpbmdlcnByaW50LnNsaWNlKDAsIDE1KTtcbiAgICByZXR1cm4gdGhpcy5fc3ViSWQ7XG4gIH1cbiAgc3ViSWRQYXJ0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGFkZFN1YklkUGFydChwYXJ0KSB7XG4gICAgdGhpcy5zdWJJZFBhcnRzLmFkZChwYXJ0KTtcbiAgfVxuICBhZGRJdGVtKHN1YnNjcmlwdGlvbiwgZmlsdGVycykge1xuICAgIHRoaXMuZGVidWcoXCJBZGRpbmcgaXRlbVwiLCB7IGZpbHRlcnMsIGludGVybmFsSWQ6IHN1YnNjcmlwdGlvbi5pbnRlcm5hbElkLCBzdGF0dXM6IHRoaXMuc3RhdHVzLCBmaW5nZXJwcmludDogdGhpcy5maW5nZXJwcmludCwgaWQ6IHRoaXMuc3ViSWQsIGl0ZW1zOiB0aGlzLml0ZW1zLCBpdGVtc1NpemU6IHRoaXMuaXRlbXMuc2l6ZSB9KTtcbiAgICBpZiAodGhpcy5pdGVtcy5oYXMoc3Vic2NyaXB0aW9uLmludGVybmFsSWQpKSByZXR1cm47XG4gICAgc3Vic2NyaXB0aW9uLm9uKFwiY2xvc2VcIiwgdGhpcy5yZW1vdmVJdGVtLmJpbmQodGhpcywgc3Vic2NyaXB0aW9uKSk7XG4gICAgdGhpcy5pdGVtcy5zZXQoc3Vic2NyaXB0aW9uLmludGVybmFsSWQsIHsgc3Vic2NyaXB0aW9uLCBmaWx0ZXJzIH0pO1xuICAgIGlmICh0aGlzLnN0YXR1cyAhPT0gMyAvKiBSVU5OSU5HICovKSB7XG4gICAgICBpZiAoc3Vic2NyaXB0aW9uLnN1YklkICYmICghdGhpcy5fc3ViSWQgfHwgdGhpcy5fc3ViSWQubGVuZ3RoIDwgNDgpKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gMCAvKiBJTklUSUFMICovIHx8IHRoaXMuc3RhdHVzID09PSAxIC8qIFBFTkRJTkcgKi8pIHtcbiAgICAgICAgICB0aGlzLmFkZFN1YklkUGFydChzdWJzY3JpcHRpb24uc3ViSWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHN3aXRjaCAodGhpcy5zdGF0dXMpIHtcbiAgICAgIGNhc2UgMCAvKiBJTklUSUFMICovOlxuICAgICAgICB0aGlzLmV2YWx1YXRlRXhlY3V0aW9uUGxhbihzdWJzY3JpcHRpb24pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMyAvKiBSVU5OSU5HICovOlxuICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICBcIkJVRzogVGhpcyBzaG91bGQgbm90IGhhcHBlbjogVGhpcyBzdWJzY3JpcHRpb24gbmVlZHMgdG8gY2F0Y2ggdXAgd2l0aCBhIHN1YnNjcmlwdGlvbiB0aGF0IHdhcyBhbHJlYWR5IHJ1bm5pbmdcIixcbiAgICAgICAgICBmaWx0ZXJzXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxIC8qIFBFTkRJTkcgKi86XG4gICAgICAgIHRoaXMuZXZhbHVhdGVFeGVjdXRpb25QbGFuKHN1YnNjcmlwdGlvbik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA0IC8qIENMT1NFRCAqLzpcbiAgICAgICAgdGhpcy5kZWJ1ZyhcbiAgICAgICAgICBcIlN1YnNjcmlwdGlvbiBpcyBjbG9zZWQsIGNhbm5vdCBhZGQgbmV3IGl0ZW1zICVvICglbylcIixcbiAgICAgICAgICBzdWJzY3JpcHRpb24sXG4gICAgICAgICAgZmlsdGVyc1xuICAgICAgICApO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYWRkIG5ldyBpdGVtcyB0byBhIGNsb3NlZCBzdWJzY3JpcHRpb25cIik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBBIHN1YnNjcmlwdGlvbiBoYXMgYmVlbiBjbG9zZWQsIHJlbW92ZSBpdCBmcm9tIHRoZSBsaXN0IG9mIGl0ZW1zLlxuICAgKiBAcGFyYW0gc3Vic2NyaXB0aW9uXG4gICAqL1xuICByZW1vdmVJdGVtKHN1YnNjcmlwdGlvbikge1xuICAgIHRoaXMuaXRlbXMuZGVsZXRlKHN1YnNjcmlwdGlvbi5pbnRlcm5hbElkKTtcbiAgICBpZiAodGhpcy5pdGVtcy5zaXplID09PSAwKSB7XG4gICAgICBpZiAoIXRoaXMuZW9zZWQpIHJldHVybjtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgIHRoaXMuY2xlYW51cCgpO1xuICAgIH1cbiAgfVxuICBjbG9zZSgpIHtcbiAgICBpZiAodGhpcy5zdGF0dXMgPT09IDQgLyogQ0xPU0VEICovKSByZXR1cm47XG4gICAgY29uc3QgcHJldlN0YXR1cyA9IHRoaXMuc3RhdHVzO1xuICAgIHRoaXMuc3RhdHVzID0gNCAvKiBDTE9TRUQgKi87XG4gICAgaWYgKHByZXZTdGF0dXMgPT09IDMgLyogUlVOTklORyAqLykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5yZWxheS5jbG9zZSh0aGlzLnN1YklkKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhpcy5kZWJ1ZyhcIkVycm9yIGNsb3Npbmcgc3Vic2NyaXB0aW9uXCIsIGUsIHRoaXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlYnVnKFwiU3Vic2NyaXB0aW9uIHdhbnRlZCB0byBjbG9zZSBidXQgaXQgd2Fzbid0IHJ1bm5pbmcsIHRoaXMgaXMgcHJvYmFibHkgb2tcIiwge1xuICAgICAgICBzdWJJZDogdGhpcy5zdWJJZCxcbiAgICAgICAgcHJldlN0YXR1cyxcbiAgICAgICAgc3ViOiB0aGlzXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5jbGVhbnVwKCk7XG4gIH1cbiAgY2xlYW51cCgpIHtcbiAgICBpZiAodGhpcy5leGVjdXRpb25UaW1lcikgY2xlYXJUaW1lb3V0KHRoaXMuZXhlY3V0aW9uVGltZXIpO1xuICAgIHRoaXMucmVsYXkub2ZmKFwicmVhZHlcIiwgdGhpcy5leGVjdXRlT25SZWxheVJlYWR5KTtcbiAgICB0aGlzLnJlbGF5Lm9mZihcImF1dGhlZFwiLCB0aGlzLnJlRXhlY3V0ZUFmdGVyQXV0aCk7XG4gICAgaWYgKHRoaXMub25DbG9zZSkgdGhpcy5vbkNsb3NlKHRoaXMpO1xuICB9XG4gIGV2YWx1YXRlRXhlY3V0aW9uUGxhbihzdWJzY3JpcHRpb24pIHtcbiAgICBpZiAoIXN1YnNjcmlwdGlvbi5pc0dyb3VwYWJsZSgpKSB7XG4gICAgICB0aGlzLnN0YXR1cyA9IDEgLyogUEVORElORyAqLztcbiAgICAgIHRoaXMuZXhlY3V0ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc3Vic2NyaXB0aW9uLmZpbHRlcnMuZmluZCgoZmlsdGVyKSA9PiAhIWZpbHRlci5saW1pdCkpIHtcbiAgICAgIHRoaXMuZXhlY3V0ZUZpbHRlcnMgPSB0aGlzLmNvbXBpbGVGaWx0ZXJzKCk7XG4gICAgICBpZiAodGhpcy5leGVjdXRlRmlsdGVycy5sZW5ndGggPj0gMTApIHtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSAxIC8qIFBFTkRJTkcgKi87XG4gICAgICAgIHRoaXMuZXhlY3V0ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGRlbGF5ID0gc3Vic2NyaXB0aW9uLmdyb3VwYWJsZURlbGF5O1xuICAgIGNvbnN0IGRlbGF5VHlwZSA9IHN1YnNjcmlwdGlvbi5ncm91cGFibGVEZWxheVR5cGU7XG4gICAgaWYgKCFkZWxheSkgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdyb3VwIGEgc3Vic2NyaXB0aW9uIHdpdGhvdXQgYSBkZWxheVwiKTtcbiAgICBpZiAodGhpcy5zdGF0dXMgPT09IDAgLyogSU5JVElBTCAqLykge1xuICAgICAgdGhpcy5zY2hlZHVsZShkZWxheSwgZGVsYXlUeXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZXhpc3RpbmdEZWxheVR5cGUgPSB0aGlzLmRlbGF5VHlwZTtcbiAgICAgIGNvbnN0IHRpbWVVbnRpbEZpcmUgPSB0aGlzLmZpcmVUaW1lIC0gRGF0ZS5ub3coKTtcbiAgICAgIGlmIChleGlzdGluZ0RlbGF5VHlwZSA9PT0gXCJhdC1sZWFzdFwiICYmIGRlbGF5VHlwZSA9PT0gXCJhdC1sZWFzdFwiKSB7XG4gICAgICAgIGlmICh0aW1lVW50aWxGaXJlIDwgZGVsYXkpIHtcbiAgICAgICAgICBpZiAodGhpcy5leGVjdXRpb25UaW1lcikgY2xlYXJUaW1lb3V0KHRoaXMuZXhlY3V0aW9uVGltZXIpO1xuICAgICAgICAgIHRoaXMuc2NoZWR1bGUoZGVsYXksIGRlbGF5VHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZXhpc3RpbmdEZWxheVR5cGUgPT09IFwiYXQtbGVhc3RcIiAmJiBkZWxheVR5cGUgPT09IFwiYXQtbW9zdFwiKSB7XG4gICAgICAgIGlmICh0aW1lVW50aWxGaXJlID4gZGVsYXkpIHtcbiAgICAgICAgICBpZiAodGhpcy5leGVjdXRpb25UaW1lcikgY2xlYXJUaW1lb3V0KHRoaXMuZXhlY3V0aW9uVGltZXIpO1xuICAgICAgICAgIHRoaXMuc2NoZWR1bGUoZGVsYXksIGRlbGF5VHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZXhpc3RpbmdEZWxheVR5cGUgPT09IFwiYXQtbW9zdFwiICYmIGRlbGF5VHlwZSA9PT0gXCJhdC1tb3N0XCIpIHtcbiAgICAgICAgaWYgKHRpbWVVbnRpbEZpcmUgPiBkZWxheSkge1xuICAgICAgICAgIGlmICh0aGlzLmV4ZWN1dGlvblRpbWVyKSBjbGVhclRpbWVvdXQodGhpcy5leGVjdXRpb25UaW1lcik7XG4gICAgICAgICAgdGhpcy5zY2hlZHVsZShkZWxheSwgZGVsYXlUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChleGlzdGluZ0RlbGF5VHlwZSA9PT0gXCJhdC1tb3N0XCIgJiYgZGVsYXlUeXBlID09PSBcImF0LWxlYXN0XCIpIHtcbiAgICAgICAgaWYgKHRpbWVVbnRpbEZpcmUgPiBkZWxheSkge1xuICAgICAgICAgIGlmICh0aGlzLmV4ZWN1dGlvblRpbWVyKSBjbGVhclRpbWVvdXQodGhpcy5leGVjdXRpb25UaW1lcik7XG4gICAgICAgICAgdGhpcy5zY2hlZHVsZShkZWxheSwgZGVsYXlUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiVW5rbm93biBkZWxheSB0eXBlIGNvbWJpbmF0aW9uIFwiICsgZXhpc3RpbmdEZWxheVR5cGUgKyBcIiBcIiArIGRlbGF5VHlwZVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzY2hlZHVsZShkZWxheSwgZGVsYXlUeXBlKSB7XG4gICAgdGhpcy5zdGF0dXMgPSAxIC8qIFBFTkRJTkcgKi87XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIHRoaXMuZmlyZVRpbWUgPSBjdXJyZW50VGltZSArIGRlbGF5O1xuICAgIHRoaXMuZGVsYXlUeXBlID0gZGVsYXlUeXBlO1xuICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dCh0aGlzLmV4ZWN1dGUuYmluZCh0aGlzKSwgZGVsYXkpO1xuICAgIGlmIChkZWxheVR5cGUgPT09IFwiYXQtbGVhc3RcIikge1xuICAgICAgdGhpcy5leGVjdXRpb25UaW1lciA9IHRpbWVyO1xuICAgIH1cbiAgfVxuICBleGVjdXRlT25SZWxheVJlYWR5ID0gKCkgPT4ge1xuICAgIGlmICh0aGlzLnN0YXR1cyAhPT0gMiAvKiBXQUlUSU5HICovKSByZXR1cm47XG4gICAgaWYgKHRoaXMuaXRlbXMuc2l6ZSA9PT0gMCkge1xuICAgICAgdGhpcy5kZWJ1ZyhcIk5vIGl0ZW1zIHRvIGV4ZWN1dGU7IHRoaXMgcmVsYXkgd2FzIHByb2JhYmx5IHRvbyBzbG93IHRvIHJlc3BvbmQgYW5kIHRoZSBjYWxsZXIgZ2F2ZSB1cFwiLCB7IHN0YXR1czogdGhpcy5zdGF0dXMsIGZpbmdlcnByaW50OiB0aGlzLmZpbmdlcnByaW50LCBpdGVtczogdGhpcy5pdGVtcywgaXRlbXNTaXplOiB0aGlzLml0ZW1zLnNpemUsIGlkOiB0aGlzLmlkLCBzdWJJZDogdGhpcy5zdWJJZCB9KTtcbiAgICAgIHRoaXMuY2xlYW51cCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmRlYnVnKFwiRXhlY3V0aW5nIG9uIHJlbGF5IHJlYWR5XCIsIHsgc3RhdHVzOiB0aGlzLnN0YXR1cywgZmluZ2VycHJpbnQ6IHRoaXMuZmluZ2VycHJpbnQsIGl0ZW1zOiB0aGlzLml0ZW1zLCBpdGVtc1NpemU6IHRoaXMuaXRlbXMuc2l6ZSB9KTtcbiAgICB0aGlzLnN0YXR1cyA9IDEgLyogUEVORElORyAqLztcbiAgICB0aGlzLmV4ZWN1dGUoKTtcbiAgfTtcbiAgZmluYWxpemVTdWJJZCgpIHtcbiAgICBpZiAodGhpcy5zdWJJZFBhcnRzLnNpemUgPiAwKSB7XG4gICAgICB0aGlzLl9zdWJJZCA9IEFycmF5LmZyb20odGhpcy5zdWJJZFBhcnRzKS5qb2luKFwiLVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc3ViSWQgPSB0aGlzLmZpbmdlcnByaW50LnNsaWNlKDAsIDE1KTtcbiAgICB9XG4gICAgdGhpcy5fc3ViSWQgKz0gXCItXCIgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgNyk7XG4gIH1cbiAgLy8gd2UgZG8gaXQgdGhpcyB3YXkgc28gdGhhdCB3ZSBjYW4gcmVtb3ZlIHRoZSBsaXN0ZW5lclxuICByZUV4ZWN1dGVBZnRlckF1dGggPSAoKCkgPT4ge1xuICAgIGNvbnN0IG9sZFN1YklkID0gdGhpcy5zdWJJZDtcbiAgICB0aGlzLmRlYnVnKFwiUmUtZXhlY3V0aW5nIGFmdGVyIGF1dGhcIiwgdGhpcy5pdGVtcy5zaXplKTtcbiAgICBpZiAodGhpcy5lb3NlZCkge1xuICAgICAgdGhpcy5yZWxheS5jbG9zZSh0aGlzLnN1YklkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kZWJ1ZyhcbiAgICAgICAgXCJXZSBhcmUgYWJhbmRvbmluZyBhbiBvcGVuZWQgc3Vic2NyaXB0aW9uLCBvbmNlIGl0IEVPU0UncywgdGhlIGhhbmRsZXIgd2lsbCBjbG9zZSBpdFwiLFxuICAgICAgICB7IG9sZFN1YklkIH1cbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMuX3N1YklkID0gdm9pZCAwO1xuICAgIHRoaXMuc3RhdHVzID0gMSAvKiBQRU5ESU5HICovO1xuICAgIHRoaXMuZXhlY3V0ZSgpO1xuICAgIHRoaXMuZGVidWcoXCJSZS1leGVjdXRlZCBhZnRlciBhdXRoICVzIFxcdXsxRjQ0OX0gJXNcIiwgb2xkU3ViSWQsIHRoaXMuc3ViSWQpO1xuICB9KS5iaW5kKHRoaXMpO1xuICBleGVjdXRlKCkge1xuICAgIGlmICh0aGlzLnN0YXR1cyAhPT0gMSAvKiBQRU5ESU5HICovKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy5yZWxheS5jb25uZWN0ZWQpIHtcbiAgICAgIHRoaXMuc3RhdHVzID0gMiAvKiBXQUlUSU5HICovO1xuICAgICAgdGhpcy5kZWJ1ZyhcIldhaXRpbmcgZm9yIHJlbGF5IHRvIGJlIHJlYWR5XCIsIHsgc3RhdHVzOiB0aGlzLnN0YXR1cywgaWQ6IHRoaXMuc3ViSWQsIGZpbmdlcnByaW50OiB0aGlzLmZpbmdlcnByaW50LCBpdGVtczogdGhpcy5pdGVtcywgaXRlbXNTaXplOiB0aGlzLml0ZW1zLnNpemUgfSk7XG4gICAgICB0aGlzLnJlbGF5Lm9uY2UoXCJyZWFkeVwiLCB0aGlzLmV4ZWN1dGVPblJlbGF5UmVhZHkpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAodGhpcy5yZWxheS5zdGF0dXMgPCA4IC8qIEFVVEhFTlRJQ0FURUQgKi8pIHtcbiAgICAgIHRoaXMucmVsYXkub25jZShcImF1dGhlZFwiLCB0aGlzLnJlRXhlY3V0ZUFmdGVyQXV0aCk7XG4gICAgfVxuICAgIHRoaXMuc3RhdHVzID0gMyAvKiBSVU5OSU5HICovO1xuICAgIHRoaXMuZmluYWxpemVTdWJJZCgpO1xuICAgIHRoaXMuZXhlY3V0ZUZpbHRlcnMgPSB0aGlzLmNvbXBpbGVGaWx0ZXJzKCk7XG4gICAgdGhpcy5yZWxheS5yZXEodGhpcyk7XG4gIH1cbiAgb25zdGFydCgpIHtcbiAgfVxuICBvbmV2ZW50KGV2ZW50KSB7XG4gICAgdGhpcy50b3BTdWJNYW5hZ2VyLmRpc3BhdGNoRXZlbnQoZXZlbnQsIHRoaXMucmVsYXkpO1xuICB9XG4gIG9uZW9zZShzdWJJZCkge1xuICAgIHRoaXMuZW9zZWQgPSB0cnVlO1xuICAgIGlmIChzdWJJZCAhPT0gdGhpcy5zdWJJZCkge1xuICAgICAgdGhpcy5kZWJ1ZyhcIlJlY2VpdmVkIEVPU0UgZm9yIGFuIGFiYW5kb25lZCBzdWJzY3JpcHRpb25cIiwgc3ViSWQsIHRoaXMuc3ViSWQpO1xuICAgICAgdGhpcy5yZWxheS5jbG9zZShzdWJJZCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLml0ZW1zLnNpemUgPT09IDApIHtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCB7IHN1YnNjcmlwdGlvbiB9IG9mIHRoaXMuaXRlbXMudmFsdWVzKCkpIHtcbiAgICAgIHN1YnNjcmlwdGlvbi5lb3NlUmVjZWl2ZWQodGhpcy5yZWxheSk7XG4gICAgICBpZiAoc3Vic2NyaXB0aW9uLmNsb3NlT25Fb3NlKSB7XG4gICAgICAgIHRoaXMuZGVidWcoXCJSZW1vdmluZyBpdGVtIGJlY2F1c2Ugb2YgRU9TRVwiLCB7IGZpbHRlcnM6IHN1YnNjcmlwdGlvbi5maWx0ZXJzLCBpbnRlcm5hbElkOiBzdWJzY3JpcHRpb24uaW50ZXJuYWxJZCwgc3RhdHVzOiB0aGlzLnN0YXR1cywgZmluZ2VycHJpbnQ6IHRoaXMuZmluZ2VycHJpbnQsIGl0ZW1zOiB0aGlzLml0ZW1zLCBpdGVtc1NpemU6IHRoaXMuaXRlbXMuc2l6ZSB9KTtcbiAgICAgICAgdGhpcy5yZW1vdmVJdGVtKHN1YnNjcmlwdGlvbik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIG9uY2xvc2UocmVhc29uKSB7XG4gICAgdGhpcy5zdGF0dXMgPSA0IC8qIENMT1NFRCAqLztcbiAgfVxuICBvbmNsb3NlZChyZWFzb24pIHtcbiAgICBpZiAoIXJlYXNvbikgcmV0dXJuO1xuICAgIGZvciAoY29uc3QgeyBzdWJzY3JpcHRpb24gfSBvZiB0aGlzLml0ZW1zLnZhbHVlcygpKSB7XG4gICAgICBzdWJzY3JpcHRpb24uY2xvc2VkUmVjZWl2ZWQodGhpcy5yZWxheSwgcmVhc29uKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEdyYWJzIHRoZSBmaWx0ZXJzIGZyb20gYWxsIHRoZSBzdWJzY3JpcHRpb25zXG4gICAqIGFuZCBtZXJnZXMgdGhlbSBpbnRvIGEgc2luZ2xlIGZpbHRlci5cbiAgICovXG4gIGNvbXBpbGVGaWx0ZXJzKCkge1xuICAgIGNvbnN0IG1lcmdlZEZpbHRlcnMgPSBbXTtcbiAgICBjb25zdCBmaWx0ZXJzID0gQXJyYXkuZnJvbSh0aGlzLml0ZW1zLnZhbHVlcygpKS5tYXAoKGl0ZW0pID0+IGl0ZW0uZmlsdGVycyk7XG4gICAgaWYgKCFmaWx0ZXJzWzBdKSB7XG4gICAgICB0aGlzLmRlYnVnKFwiXFx1ezFGNDQwfSBObyBmaWx0ZXJzIHRvIG1lcmdlXCIsIHRoaXMuaXRlbXMpO1xuICAgICAgY29uc29sZS5lcnJvcihcIkJVRzogTm8gZmlsdGVycyB0byBtZXJnZSFcIiwgdGhpcy5pdGVtcyk7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IGZpbHRlckNvdW50ID0gZmlsdGVyc1swXS5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWx0ZXJDb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBhbGxGaWx0ZXJzQXRJbmRleCA9IGZpbHRlcnMubWFwKChmaWx0ZXIpID0+IGZpbHRlcltpXSk7XG4gICAgICBtZXJnZWRGaWx0ZXJzLnB1c2goLi4ubWVyZ2VGaWx0ZXJzKGFsbEZpbHRlcnNBdEluZGV4KSk7XG4gICAgfVxuICAgIHJldHVybiBtZXJnZWRGaWx0ZXJzO1xuICB9XG59O1xuXG4vLyBzcmMvcmVsYXkvc3ViLW1hbmFnZXIudHNcbnZhciBOREtSZWxheVN1YnNjcmlwdGlvbk1hbmFnZXIgPSBjbGFzcyB7XG4gIHJlbGF5O1xuICBzdWJzY3JpcHRpb25zO1xuICBnZW5lcmFsU3ViTWFuYWdlcjtcbiAgLyoqXG4gICAqIEBwYXJhbSByZWxheSAtIFRoZSByZWxheSBpbnN0YW5jZS5cbiAgICogQHBhcmFtIGdlbmVyYWxTdWJNYW5hZ2VyIC0gVGhlIHN1YnNjcmlwdGlvbiBtYW5hZ2VyIGluc3RhbmNlLlxuICAgKi9cbiAgY29uc3RydWN0b3IocmVsYXksIGdlbmVyYWxTdWJNYW5hZ2VyKSB7XG4gICAgdGhpcy5yZWxheSA9IHJlbGF5O1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5nZW5lcmFsU3ViTWFuYWdlciA9IGdlbmVyYWxTdWJNYW5hZ2VyO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGEgc3Vic2NyaXB0aW9uIHRvIHRoZSBtYW5hZ2VyLlxuICAgKi9cbiAgYWRkU3Vic2NyaXB0aW9uKHN1YiwgZmlsdGVycykge1xuICAgIGxldCByZWxheVN1YjtcbiAgICBpZiAoIXN1Yi5pc0dyb3VwYWJsZSgpKSB7XG4gICAgICByZWxheVN1YiA9IHRoaXMuY3JlYXRlU3Vic2NyaXB0aW9uKHN1YiwgZmlsdGVycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGZpbHRlckZwID0gZmlsdGVyRmluZ2VycHJpbnQoZmlsdGVycywgc3ViLmNsb3NlT25Fb3NlKTtcbiAgICAgIGlmIChmaWx0ZXJGcCkge1xuICAgICAgICBjb25zdCBleGlzdGluZ1N1YnMgPSB0aGlzLnN1YnNjcmlwdGlvbnMuZ2V0KGZpbHRlckZwKTtcbiAgICAgICAgcmVsYXlTdWIgPSAoZXhpc3RpbmdTdWJzIHx8IFtdKS5maW5kKFxuICAgICAgICAgIChzdWIyKSA9PiBzdWIyLnN0YXR1cyA8IDMgLyogUlVOTklORyAqL1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmVsYXlTdWIgPz89IHRoaXMuY3JlYXRlU3Vic2NyaXB0aW9uKHN1YiwgZmlsdGVycywgZmlsdGVyRnApO1xuICAgIH1cbiAgICByZWxheVN1Yi5hZGRJdGVtKHN1YiwgZmlsdGVycyk7XG4gIH1cbiAgY3JlYXRlU3Vic2NyaXB0aW9uKHN1YiwgZmlsdGVycywgZmluZ2VycHJpbnQpIHtcbiAgICBjb25zdCByZWxheVN1YiA9IG5ldyBOREtSZWxheVN1YnNjcmlwdGlvbih0aGlzLnJlbGF5LCBmaW5nZXJwcmludCB8fCBudWxsLCB0aGlzLmdlbmVyYWxTdWJNYW5hZ2VyKTtcbiAgICByZWxheVN1Yi5vbkNsb3NlID0gdGhpcy5vblJlbGF5U3Vic2NyaXB0aW9uQ2xvc2UuYmluZCh0aGlzKTtcbiAgICBjb25zdCBjdXJyZW50VmFsID0gdGhpcy5zdWJzY3JpcHRpb25zLmdldChyZWxheVN1Yi5maW5nZXJwcmludCkgPz8gW107XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnNldChyZWxheVN1Yi5maW5nZXJwcmludCwgWy4uLmN1cnJlbnRWYWwsIHJlbGF5U3ViXSk7XG4gICAgcmV0dXJuIHJlbGF5U3ViO1xuICB9XG4gIG9uUmVsYXlTdWJzY3JpcHRpb25DbG9zZShzdWIpIHtcbiAgICBsZXQgY3VycmVudFZhbCA9IHRoaXMuc3Vic2NyaXB0aW9ucy5nZXQoc3ViLmZpbmdlcnByaW50KSA/PyBbXTtcbiAgICBpZiAoIWN1cnJlbnRWYWwpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgXCJVbmV4cGVjdGVkbHkgZGlkIG5vdCBmaW5kIGEgc3Vic2NyaXB0aW9uIHdpdGggZmluZ2VycHJpbnRcIixcbiAgICAgICAgc3ViLmZpbmdlcnByaW50XG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudFZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5kZWxldGUoc3ViLmZpbmdlcnByaW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudFZhbCA9IGN1cnJlbnRWYWwuZmlsdGVyKChzKSA9PiBzLmlkICE9PSBzdWIuaWQpO1xuICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnNldChzdWIuZmluZ2VycHJpbnQsIGN1cnJlbnRWYWwpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL3JlbGF5L2luZGV4LnRzXG52YXIgTkRLUmVsYXlTdGF0dXMgPSAvKiBAX19QVVJFX18gKi8gKChOREtSZWxheVN0YXR1czIpID0+IHtcbiAgTkRLUmVsYXlTdGF0dXMyW05ES1JlbGF5U3RhdHVzMltcIkRJU0NPTk5FQ1RJTkdcIl0gPSAwXSA9IFwiRElTQ09OTkVDVElOR1wiO1xuICBOREtSZWxheVN0YXR1czJbTkRLUmVsYXlTdGF0dXMyW1wiRElTQ09OTkVDVEVEXCJdID0gMV0gPSBcIkRJU0NPTk5FQ1RFRFwiO1xuICBOREtSZWxheVN0YXR1czJbTkRLUmVsYXlTdGF0dXMyW1wiUkVDT05ORUNUSU5HXCJdID0gMl0gPSBcIlJFQ09OTkVDVElOR1wiO1xuICBOREtSZWxheVN0YXR1czJbTkRLUmVsYXlTdGF0dXMyW1wiRkxBUFBJTkdcIl0gPSAzXSA9IFwiRkxBUFBJTkdcIjtcbiAgTkRLUmVsYXlTdGF0dXMyW05ES1JlbGF5U3RhdHVzMltcIkNPTk5FQ1RJTkdcIl0gPSA0XSA9IFwiQ09OTkVDVElOR1wiO1xuICBOREtSZWxheVN0YXR1czJbTkRLUmVsYXlTdGF0dXMyW1wiQ09OTkVDVEVEXCJdID0gNV0gPSBcIkNPTk5FQ1RFRFwiO1xuICBOREtSZWxheVN0YXR1czJbTkRLUmVsYXlTdGF0dXMyW1wiQVVUSF9SRVFVRVNURURcIl0gPSA2XSA9IFwiQVVUSF9SRVFVRVNURURcIjtcbiAgTkRLUmVsYXlTdGF0dXMyW05ES1JlbGF5U3RhdHVzMltcIkFVVEhFTlRJQ0FUSU5HXCJdID0gN10gPSBcIkFVVEhFTlRJQ0FUSU5HXCI7XG4gIE5ES1JlbGF5U3RhdHVzMltOREtSZWxheVN0YXR1czJbXCJBVVRIRU5USUNBVEVEXCJdID0gOF0gPSBcIkFVVEhFTlRJQ0FURURcIjtcbiAgcmV0dXJuIE5ES1JlbGF5U3RhdHVzMjtcbn0pKE5ES1JlbGF5U3RhdHVzIHx8IHt9KTtcbnZhciBOREtSZWxheSA9IGNsYXNzIF9OREtSZWxheSBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIHVybDtcbiAgc2NvcmVzO1xuICBjb25uZWN0aXZpdHk7XG4gIHN1YnM7XG4gIHB1Ymxpc2hlcjtcbiAgYXV0aFBvbGljeTtcbiAgLyoqXG4gICAqIFRoZSBsb3dlc3QgdmFsaWRhdGlvbiByYXRpbyB0aGlzIHJlbGF5IGNhbiByZWFjaC5cbiAgICovXG4gIGxvd2VzdFZhbGlkYXRpb25SYXRpbztcbiAgLyoqXG4gICAqIEN1cnJlbnQgdmFsaWRhdGlvbiByYXRpbyB0aGlzIHJlbGF5IGlzIHRhcmdldGluZy5cbiAgICovXG4gIHRhcmdldFZhbGlkYXRpb25SYXRpbztcbiAgdmFsaWRhdGlvblJhdGlvRm47XG4gIC8qKlxuICAgKiBUaGlzIHRyYWNrcyBldmVudHMgdGhhdCBoYXZlIGJlZW4gc2VlbiBieSB0aGlzIHJlbGF5XG4gICAqIHdpdGggYSB2YWxpZCBzaWduYXR1cmUuXG4gICAqL1xuICB2YWxpZGF0ZWRFdmVudENvdW50ID0gMDtcbiAgLyoqXG4gICAqIFRoaXMgdHJhY2tzIGV2ZW50cyB0aGF0IGhhdmUgYmVlbiBzZWVuIGJ5IHRoaXMgcmVsYXlcbiAgICogYnV0IGhhdmUgbm90IGJlZW4gdmFsaWRhdGVkLlxuICAgKi9cbiAgbm9uVmFsaWRhdGVkRXZlbnRDb3VudCA9IDA7XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoaXMgcmVsYXkgaXMgdHJ1c3RlZC5cbiAgICpcbiAgICogVHJ1c3RlZCByZWxheSdzIGV2ZW50cyBkbyBub3QgZ2V0IHRoZWlyIHNpZ25hdHVyZSB2ZXJpZmllZC5cbiAgICovXG4gIHRydXN0ZWQgPSBmYWxzZTtcbiAgY29tcGxhaW5pbmcgPSBmYWxzZTtcbiAgZGVidWc7XG4gIHN0YXRpYyBkZWZhdWx0VmFsaWRhdGlvblJhdGlvVXBkYXRlRm4gPSAocmVsYXksIHZhbGlkYXRlZENvdW50LCBub25WYWxpZGF0ZWRDb3VudCkgPT4ge1xuICAgIGlmIChyZWxheS5sb3dlc3RWYWxpZGF0aW9uUmF0aW8gPT09IHZvaWQgMCB8fCByZWxheS50YXJnZXRWYWxpZGF0aW9uUmF0aW8gPT09IHZvaWQgMClcbiAgICAgIHJldHVybiAxO1xuICAgIGxldCBuZXdSYXRpbyA9IHJlbGF5LnZhbGlkYXRpb25SYXRpbztcbiAgICBpZiAocmVsYXkudmFsaWRhdGlvblJhdGlvID4gcmVsYXkudGFyZ2V0VmFsaWRhdGlvblJhdGlvKSB7XG4gICAgICBjb25zdCBmYWN0b3IgPSB2YWxpZGF0ZWRDb3VudCAvIDEwMDtcbiAgICAgIG5ld1JhdGlvID0gTWF0aC5tYXgocmVsYXkubG93ZXN0VmFsaWRhdGlvblJhdGlvLCByZWxheS52YWxpZGF0aW9uUmF0aW8gLSBmYWN0b3IpO1xuICAgIH1cbiAgICBpZiAobmV3UmF0aW8gPCByZWxheS52YWxpZGF0aW9uUmF0aW8pIHtcbiAgICAgIHJldHVybiBuZXdSYXRpbztcbiAgICB9XG4gICAgcmV0dXJuIHJlbGF5LnZhbGlkYXRpb25SYXRpbztcbiAgfTtcbiAgY29uc3RydWN0b3IodXJsLCBhdXRoUG9saWN5LCBuZGspIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMudXJsID0gbm9ybWFsaXplUmVsYXlVcmwodXJsKTtcbiAgICB0aGlzLnNjb3JlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5kZWJ1ZyA9IGRlYnVnKGBuZGs6cmVsYXk6JHt1cmx9YCk7XG4gICAgdGhpcy5jb25uZWN0aXZpdHkgPSBuZXcgTkRLUmVsYXlDb25uZWN0aXZpdHkodGhpcywgbmRrKTtcbiAgICB0aGlzLmNvbm5lY3Rpdml0eS5uZXREZWJ1ZyA9IG5kaz8ubmV0RGVidWc7XG4gICAgdGhpcy5yZXEgPSB0aGlzLmNvbm5lY3Rpdml0eS5yZXEuYmluZCh0aGlzLmNvbm5lY3Rpdml0eSk7XG4gICAgdGhpcy5jbG9zZSA9IHRoaXMuY29ubmVjdGl2aXR5LmNsb3NlLmJpbmQodGhpcy5jb25uZWN0aXZpdHkpO1xuICAgIHRoaXMuc3VicyA9IG5ldyBOREtSZWxheVN1YnNjcmlwdGlvbk1hbmFnZXIodGhpcywgbmRrLnN1Yk1hbmFnZXIpO1xuICAgIHRoaXMucHVibGlzaGVyID0gbmV3IE5ES1JlbGF5UHVibGlzaGVyKHRoaXMpO1xuICAgIHRoaXMuYXV0aFBvbGljeSA9IGF1dGhQb2xpY3k7XG4gICAgdGhpcy50YXJnZXRWYWxpZGF0aW9uUmF0aW8gPSBuZGs/LmluaXRpYWxWYWxpZGF0aW9uUmF0aW87XG4gICAgdGhpcy5sb3dlc3RWYWxpZGF0aW9uUmF0aW8gPSBuZGs/Lmxvd2VzdFZhbGlkYXRpb25SYXRpbztcbiAgICB0aGlzLnZhbGlkYXRpb25SYXRpb0ZuID0gKG5kaz8udmFsaWRhdGlvblJhdGlvRm4gPz8gX05ES1JlbGF5LmRlZmF1bHRWYWxpZGF0aW9uUmF0aW9VcGRhdGVGbikuYmluZCh0aGlzKTtcbiAgICB0aGlzLnVwZGF0ZVZhbGlkYXRpb25SYXRpbygpO1xuICAgIGlmICghbmRrKSB7XG4gICAgICBjb25zb2xlLnRyYWNlKFwicmVsYXkgY3JlYXRlZCB3aXRob3V0IG5ka1wiKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlVmFsaWRhdGlvblJhdGlvKCkge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy51cGRhdGVWYWxpZGF0aW9uUmF0aW8oKTtcbiAgICB9LCAzZTQpO1xuICB9XG4gIGdldCBzdGF0dXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29ubmVjdGl2aXR5LnN0YXR1cztcbiAgfVxuICBnZXQgY29ubmVjdGlvblN0YXRzKCkge1xuICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpdml0eS5jb25uZWN0aW9uU3RhdHM7XG4gIH1cbiAgLyoqXG4gICAqIENvbm5lY3RzIHRvIHRoZSByZWxheS5cbiAgICovXG4gIGFzeW5jIGNvbm5lY3QodGltZW91dE1zLCByZWNvbm5lY3QgPSB0cnVlKSB7XG4gICAgcmV0dXJuIHRoaXMuY29ubmVjdGl2aXR5LmNvbm5lY3QodGltZW91dE1zLCByZWNvbm5lY3QpO1xuICB9XG4gIC8qKlxuICAgKiBEaXNjb25uZWN0cyBmcm9tIHRoZSByZWxheS5cbiAgICovXG4gIGRpc2Nvbm5lY3QoKSB7XG4gICAgaWYgKHRoaXMuc3RhdHVzID09PSAxIC8qIERJU0NPTk5FQ1RFRCAqLykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmNvbm5lY3Rpdml0eS5kaXNjb25uZWN0KCk7XG4gIH1cbiAgLyoqXG4gICAqIFF1ZXVlcyBvciBleGVjdXRlcyB0aGUgc3Vic2NyaXB0aW9uIG9mIGEgc3BlY2lmaWMgc2V0IG9mIGZpbHRlcnNcbiAgICogd2l0aGluIHRoaXMgcmVsYXkuXG4gICAqXG4gICAqIEBwYXJhbSBzdWJzY3JpcHRpb24gTkRLU3Vic2NyaXB0aW9uIHRoaXMgZmlsdGVycyBiZWxvbmcgdG8uXG4gICAqIEBwYXJhbSBmaWx0ZXJzIEZpbHRlcnMgdG8gZXhlY3V0ZVxuICAgKi9cbiAgc3Vic2NyaWJlKHN1YnNjcmlwdGlvbiwgZmlsdGVycykge1xuICAgIHRoaXMuc3Vicy5hZGRTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uLCBmaWx0ZXJzKTtcbiAgfVxuICAvKipcbiAgICogUHVibGlzaGVzIGFuIGV2ZW50IHRvIHRoZSByZWxheSB3aXRoIGFuIG9wdGlvbmFsIHRpbWVvdXQuXG4gICAqXG4gICAqIElmIHRoZSByZWxheSBpcyBub3QgY29ubmVjdGVkLCB0aGUgZXZlbnQgd2lsbCBiZSBwdWJsaXNoZWQgd2hlbiB0aGUgcmVsYXkgY29ubmVjdHMsXG4gICAqIHVubGVzcyB0aGUgdGltZW91dCBpcyByZWFjaGVkIGJlZm9yZSB0aGUgcmVsYXkgY29ubmVjdHMuXG4gICAqXG4gICAqIEBwYXJhbSBldmVudCBUaGUgZXZlbnQgdG8gcHVibGlzaFxuICAgKiBAcGFyYW0gdGltZW91dE1zIFRoZSB0aW1lb3V0IGZvciB0aGUgcHVibGlzaCBvcGVyYXRpb24gaW4gbWlsbGlzZWNvbmRzXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIGV2ZW50IGhhcyBiZWVuIHB1Ymxpc2hlZCBvciByZWplY3RzIGlmIHRoZSBvcGVyYXRpb24gdGltZXMgb3V0XG4gICAqL1xuICBhc3luYyBwdWJsaXNoKGV2ZW50LCB0aW1lb3V0TXMgPSAyNTAwKSB7XG4gICAgcmV0dXJuIHRoaXMucHVibGlzaGVyLnB1Ymxpc2goZXZlbnQsIHRpbWVvdXRNcyk7XG4gIH1cbiAgcmVmZXJlbmNlVGFncygpIHtcbiAgICByZXR1cm4gW1tcInJcIiwgdGhpcy51cmxdXTtcbiAgfVxuICBhZGRWYWxpZGF0ZWRFdmVudCgpIHtcbiAgICB0aGlzLnZhbGlkYXRlZEV2ZW50Q291bnQrKztcbiAgfVxuICBhZGROb25WYWxpZGF0ZWRFdmVudCgpIHtcbiAgICB0aGlzLm5vblZhbGlkYXRlZEV2ZW50Q291bnQrKztcbiAgfVxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgdmFsaWRhdGlvbiByYXRpbyB0aGlzIHJlbGF5IGhhcyBhY2hpZXZlZC5cbiAgICovXG4gIGdldCB2YWxpZGF0aW9uUmF0aW8oKSB7XG4gICAgaWYgKHRoaXMubm9uVmFsaWRhdGVkRXZlbnRDb3VudCA9PT0gMCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnZhbGlkYXRlZEV2ZW50Q291bnQgLyAodGhpcy52YWxpZGF0ZWRFdmVudENvdW50ICsgdGhpcy5ub25WYWxpZGF0ZWRFdmVudENvdW50KTtcbiAgfVxuICBzaG91bGRWYWxpZGF0ZUV2ZW50KCkge1xuICAgIGlmICh0aGlzLnRydXN0ZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGFyZ2V0VmFsaWRhdGlvblJhdGlvID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy52YWxpZGF0aW9uUmF0aW8gPCB0aGlzLnRhcmdldFZhbGlkYXRpb25SYXRpbztcbiAgfVxuICBnZXQgY29ubmVjdGVkKCkge1xuICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpdml0eS5jb25uZWN0ZWQ7XG4gIH1cbiAgcmVxO1xuICBjbG9zZTtcbn07XG5cbi8vIHNyYy9yZWxheS9zZXRzL2luZGV4LnRzXG52YXIgTkRLUHVibGlzaEVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGVycm9ycztcbiAgcHVibGlzaGVkVG9SZWxheXM7XG4gIC8qKlxuICAgKiBJbnRlbmRlZCByZWxheSBzZXQgd2hlcmUgdGhlIHB1Ymxpc2hpbmcgd2FzIGludGVuZGVkIHRvIGhhcHBlbi5cbiAgICovXG4gIGludGVuZGVkUmVsYXlTZXQ7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGVycm9ycywgcHVibGlzaGVkVG9SZWxheXMsIGludGVuZGVkUmVsYXlTZXQpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICB0aGlzLnB1Ymxpc2hlZFRvUmVsYXlzID0gcHVibGlzaGVkVG9SZWxheXM7XG4gICAgdGhpcy5pbnRlbmRlZFJlbGF5U2V0ID0gaW50ZW5kZWRSZWxheVNldDtcbiAgfVxuICBnZXQgcmVsYXlFcnJvcnMoKSB7XG4gICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgZm9yIChjb25zdCBbcmVsYXksIGVycl0gb2YgdGhpcy5lcnJvcnMpIHtcbiAgICAgIGVycm9ycy5wdXNoKGAke3JlbGF5LnVybH06ICR7ZXJyfWApO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3JzLmpvaW4oXCJcXG5cIik7XG4gIH1cbn07XG52YXIgTkRLUmVsYXlTZXQgPSBjbGFzcyBfTkRLUmVsYXlTZXQge1xuICByZWxheXM7XG4gIGRlYnVnO1xuICBuZGs7XG4gIHBvb2w7XG4gIGNvbnN0cnVjdG9yKHJlbGF5cywgbmRrLCBwb29sKSB7XG4gICAgdGhpcy5yZWxheXMgPSByZWxheXM7XG4gICAgdGhpcy5uZGsgPSBuZGs7XG4gICAgdGhpcy5wb29sID0gcG9vbCA/PyBuZGsucG9vbDtcbiAgICB0aGlzLmRlYnVnID0gbmRrLmRlYnVnLmV4dGVuZChcInJlbGF5c2V0XCIpO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGEgcmVsYXkgdG8gdGhpcyBzZXQuXG4gICAqL1xuICBhZGRSZWxheShyZWxheSkge1xuICAgIHRoaXMucmVsYXlzLmFkZChyZWxheSk7XG4gIH1cbiAgZ2V0IHJlbGF5VXJscygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnJlbGF5cykubWFwKChyKSA9PiByLnVybCk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSByZWxheSBzZXQgZnJvbSBhIGxpc3Qgb2YgcmVsYXkgVVJMcy5cbiAgICpcbiAgICogSWYgbm8gY29ubmVjdGlvbiB0byB0aGUgcmVsYXkgaXMgZm91bmQgaW4gdGhlIHBvb2wgaXQgd2lsbCB0ZW1wb3JhcmlseVxuICAgKiBjb25uZWN0IHRvIGl0LlxuICAgKlxuICAgKiBAcGFyYW0gcmVsYXlVcmxzIC0gbGlzdCBvZiByZWxheSBVUkxzIHRvIGluY2x1ZGUgaW4gdGhpcyBzZXRcbiAgICogQHBhcmFtIG5ka1xuICAgKiBAcGFyYW0gY29ubmVjdCAtIHdoZXRoZXIgdG8gY29ubmVjdCB0byB0aGUgcmVsYXkgaW1tZWRpYXRlbHkgaWYgaXQgd2FzIGFscmVhZHkgaW4gdGhlIHBvb2wgYnV0IG5vdCBjb25uZWN0ZWRcbiAgICogQHJldHVybnMgTkRLUmVsYXlTZXRcbiAgICovXG4gIHN0YXRpYyBmcm9tUmVsYXlVcmxzKHJlbGF5VXJscywgbmRrLCBjb25uZWN0ID0gdHJ1ZSwgcG9vbCkge1xuICAgIHBvb2wgPSBwb29sID8/IG5kay5wb29sO1xuICAgIGlmICghcG9vbCkgdGhyb3cgbmV3IEVycm9yKFwiTm8gcG9vbCBwcm92aWRlZFwiKTtcbiAgICBjb25zdCByZWxheXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGZvciAoY29uc3QgdXJsIG9mIHJlbGF5VXJscykge1xuICAgICAgY29uc3QgcmVsYXkgPSBwb29sLnJlbGF5cy5nZXQobm9ybWFsaXplUmVsYXlVcmwodXJsKSk7XG4gICAgICBpZiAocmVsYXkpIHtcbiAgICAgICAgaWYgKHJlbGF5LnN0YXR1cyA8IDUgLyogQ09OTkVDVEVEICovICYmIGNvbm5lY3QpIHtcbiAgICAgICAgICByZWxheS5jb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVsYXlzLmFkZChyZWxheSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0ZW1wb3JhcnlSZWxheSA9IG5ldyBOREtSZWxheShcbiAgICAgICAgICBub3JtYWxpemVSZWxheVVybCh1cmwpLFxuICAgICAgICAgIG5kaz8ucmVsYXlBdXRoRGVmYXVsdFBvbGljeSxcbiAgICAgICAgICBuZGtcbiAgICAgICAgKTtcbiAgICAgICAgcG9vbC51c2VUZW1wb3JhcnlSZWxheShcbiAgICAgICAgICB0ZW1wb3JhcnlSZWxheSxcbiAgICAgICAgICB2b2lkIDAsXG4gICAgICAgICAgXCJyZXF1ZXN0ZWQgZnJvbSBmcm9tUmVsYXlVcmxzIFwiICsgcmVsYXlVcmxzXG4gICAgICAgICk7XG4gICAgICAgIHJlbGF5cy5hZGQodGVtcG9yYXJ5UmVsYXkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IF9OREtSZWxheVNldChuZXcgU2V0KHJlbGF5cyksIG5kaywgcG9vbCk7XG4gIH1cbiAgLyoqXG4gICAqIFB1Ymxpc2ggYW4gZXZlbnQgdG8gYWxsIHJlbGF5cyBpbiB0aGlzIHNldC4gUmV0dXJucyB0aGUgbnVtYmVyIG9mIHJlbGF5cyB0aGF0IGhhdmUgcmVjZWl2ZWQgdGhlIGV2ZW50LlxuICAgKiBAcGFyYW0gZXZlbnRcbiAgICogQHBhcmFtIHRpbWVvdXRNcyAtIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIGZvciBlYWNoIHB1Ymxpc2ggb3BlcmF0aW9uIGFuZCBjb25uZWN0aW9uIG9wZXJhdGlvblxuICAgKiBAcmV0dXJucyBBIHNldCB3aGVyZSB0aGUgZXZlbnQgd2FzIHN1Y2Nlc3NmdWxseSBwdWJsaXNoZWQgdG9cbiAgICogQHRocm93cyBOREtQdWJsaXNoRXJyb3IgaWYgbm8gcmVsYXkgd2FzIGFibGUgdG8gcmVjZWl2ZSB0aGUgZXZlbnRcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCBldmVudCA9IG5ldyBOREtFdmVudChuZGssIHtraW5kczogW05ES0tpbmQuTWVzc2FnZV0sIFwiI2RcIjogW1wiMTIzXCJdfSk7XG4gICAqIHRyeSB7XG4gICAqICAgIGNvbnN0IHB1Ymxpc2hlZFRvUmVsYXlzID0gYXdhaXQgcmVsYXlTZXQucHVibGlzaChldmVudCk7XG4gICAqICAgIGNvbnNvbGUubG9nKGBwdWJsaXNoZWQgdG8gJHtwdWJsaXNoZWRUb1JlbGF5cy5zaXplfSByZWxheXNgKVxuICAgKiB9IGNhdGNoIChlcnJvcikge1xuICAgKiAgIGNvbnNvbGUuZXJyb3IoXCJlcnJvciBwdWJsaXNoaW5nIHRvIHJlbGF5c1wiLCBlcnJvcik7XG4gICAqXG4gICAqICAgaWYgKGVycm9yIGluc3RhbmNlb2YgTkRLUHVibGlzaEVycm9yKSB7XG4gICAqICAgICAgZm9yIChjb25zdCBbcmVsYXksIGVycl0gb2YgZXJyb3IuZXJyb3JzKSB7XG4gICAqICAgICAgICAgY29uc29sZS5lcnJvcihgZXJyb3IgcHVibGlzaGluZyB0byByZWxheSAke3JlbGF5LnVybH1gLCBlcnIpO1xuICAgKiAgICAgICB9XG4gICAqICAgfVxuICAgKiB9XG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgcHVibGlzaChldmVudCwgdGltZW91dE1zLCByZXF1aXJlZFJlbGF5Q291bnQgPSAxKSB7XG4gICAgY29uc3QgcHVibGlzaGVkVG9SZWxheXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGNvbnN0IGVycm9ycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgY29uc3QgaXNFcGhlbWVyYWwyID0gZXZlbnQuaXNFcGhlbWVyYWwoKTtcbiAgICBldmVudC5wdWJsaXNoU3RhdHVzID0gXCJwZW5kaW5nXCI7XG4gICAgY29uc3QgcHJvbWlzZXMgPSBBcnJheS5mcm9tKHRoaXMucmVsYXlzKS5tYXAoKHJlbGF5KSA9PiB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgcmVsYXkucHVibGlzaChldmVudCwgdGltZW91dE1zKS50aGVuKChlKSA9PiB7XG4gICAgICAgICAgcHVibGlzaGVkVG9SZWxheXMuYWRkKHJlbGF5KTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICBpZiAoIWlzRXBoZW1lcmFsMikge1xuICAgICAgICAgICAgZXJyb3JzLnNldChyZWxheSwgZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICBpZiAocHVibGlzaGVkVG9SZWxheXMuc2l6ZSA8IHJlcXVpcmVkUmVsYXlDb3VudCkge1xuICAgICAgaWYgKCFpc0VwaGVtZXJhbDIpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgTkRLUHVibGlzaEVycm9yKFxuICAgICAgICAgIFwiTm90IGVub3VnaCByZWxheXMgcmVjZWl2ZWQgdGhlIGV2ZW50XCIsXG4gICAgICAgICAgZXJyb3JzLFxuICAgICAgICAgIHB1Ymxpc2hlZFRvUmVsYXlzLFxuICAgICAgICAgIHRoaXNcbiAgICAgICAgKTtcbiAgICAgICAgZXZlbnQucHVibGlzaFN0YXR1cyA9IFwiZXJyb3JcIjtcbiAgICAgICAgZXZlbnQucHVibGlzaEVycm9yID0gZXJyb3I7XG4gICAgICAgIHRoaXMubmRrLmVtaXQoXCJldmVudDpwdWJsaXNoLWZhaWxlZFwiLCBldmVudCwgZXJyb3IsIHRoaXMucmVsYXlVcmxzKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2ZW50LmVtaXQoXCJwdWJsaXNoZWRcIiwgeyByZWxheVNldDogdGhpcywgcHVibGlzaGVkVG9SZWxheXMgfSk7XG4gICAgfVxuICAgIHJldHVybiBwdWJsaXNoZWRUb1JlbGF5cztcbiAgfVxuICBnZXQgc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWxheXMuc2l6ZTtcbiAgfVxufTtcblxuLy8gc3JjL3JlbGF5L3NldHMvY2FsY3VsYXRlLnRzXG5pbXBvcnQgY3JlYXRlRGVidWcgZnJvbSBcImRlYnVnXCI7XG52YXIgZCA9IGNyZWF0ZURlYnVnKFwibmRrOm91dGJveDpjYWxjdWxhdGVcIik7XG5hc3luYyBmdW5jdGlvbiBjYWxjdWxhdGVSZWxheVNldEZyb21FdmVudChuZGssIGV2ZW50KSB7XG4gIGNvbnN0IHJlbGF5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0IGF1dGhvcldyaXRlUmVsYXlzID0gYXdhaXQgZ2V0V3JpdGVSZWxheXNGb3IobmRrLCBldmVudC5wdWJrZXkpO1xuICBpZiAoYXV0aG9yV3JpdGVSZWxheXMpIHtcbiAgICBhdXRob3JXcml0ZVJlbGF5cy5mb3JFYWNoKChyZWxheVVybCkgPT4ge1xuICAgICAgY29uc3QgcmVsYXkgPSBuZGsucG9vbD8uZ2V0UmVsYXkocmVsYXlVcmwpO1xuICAgICAgaWYgKHJlbGF5KSByZWxheXMuYWRkKHJlbGF5KTtcbiAgICB9KTtcbiAgfVxuICBsZXQgcmVsYXlIaW50cyA9IGV2ZW50LnRhZ3MuZmlsdGVyKCh0YWcpID0+IFtcImFcIiwgXCJlXCJdLmluY2x1ZGVzKHRhZ1swXSkpLm1hcCgodGFnKSA9PiB0YWdbMl0pLmZpbHRlcigodXJsKSA9PiB1cmwgJiYgdXJsLnN0YXJ0c1dpdGgoXCJ3c3M6Ly9cIikpLmZpbHRlcigodXJsKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIG5ldyBVUkwodXJsKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSkubWFwKCh1cmwpID0+IG5vcm1hbGl6ZVJlbGF5VXJsKHVybCkpO1xuICByZWxheUhpbnRzID0gQXJyYXkuZnJvbShuZXcgU2V0KHJlbGF5SGludHMpKS5zbGljZSgwLCA1KTtcbiAgcmVsYXlIaW50cy5mb3JFYWNoKChyZWxheVVybCkgPT4ge1xuICAgIGNvbnN0IHJlbGF5ID0gbmRrLnBvb2w/LmdldFJlbGF5KHJlbGF5VXJsLCB0cnVlLCB0cnVlKTtcbiAgICBpZiAocmVsYXkpIHtcbiAgICAgIGQoXCJBZGRpbmcgcmVsYXkgaGludCAlc1wiLCByZWxheVVybCk7XG4gICAgICByZWxheXMuYWRkKHJlbGF5KTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBwVGFncyA9IGV2ZW50LmdldE1hdGNoaW5nVGFncyhcInBcIikubWFwKCh0YWcpID0+IHRhZ1sxXSk7XG4gIGlmIChwVGFncy5sZW5ndGggPCA1KSB7XG4gICAgY29uc3QgcFRhZ2dlZFJlbGF5cyA9IEFycmF5LmZyb20oXG4gICAgICBjaG9vc2VSZWxheUNvbWJpbmF0aW9uRm9yUHVia2V5cyhuZGssIHBUYWdzLCBcInJlYWRcIiwge1xuICAgICAgICBwcmVmZXJyZWRSZWxheXM6IG5ldyBTZXQoYXV0aG9yV3JpdGVSZWxheXMpXG4gICAgICB9KS5rZXlzKClcbiAgICApO1xuICAgIHBUYWdnZWRSZWxheXMuZm9yRWFjaCgocmVsYXlVcmwpID0+IHtcbiAgICAgIGNvbnN0IHJlbGF5ID0gbmRrLnBvb2w/LmdldFJlbGF5KHJlbGF5VXJsLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICBpZiAocmVsYXkpIHtcbiAgICAgICAgZChcIkFkZGluZyBwLXRhZ2dlZCByZWxheSAlc1wiLCByZWxheVVybCk7XG4gICAgICAgIHJlbGF5cy5hZGQocmVsYXkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGQoXCJUb28gbWFueSBwLXRhZ3MgdG8gY29uc2lkZXIgJWRcIiwgcFRhZ3MubGVuZ3RoKTtcbiAgfVxuICBuZGsucG9vbD8ucGVybWFuZW50QW5kQ29ubmVjdGVkUmVsYXlzKCkuZm9yRWFjaCgocmVsYXkpID0+IHJlbGF5cy5hZGQocmVsYXkpKTtcbiAgcmV0dXJuIG5ldyBOREtSZWxheVNldChyZWxheXMsIG5kayk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVSZWxheVNldHNGcm9tRmlsdGVyKG5kaywgZmlsdGVycywgcG9vbCkge1xuICBjb25zdCByZXN1bHQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCBhdXRob3JzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgZmlsdGVycy5mb3JFYWNoKChmaWx0ZXIpID0+IHtcbiAgICBpZiAoZmlsdGVyLmF1dGhvcnMpIHtcbiAgICAgIGZpbHRlci5hdXRob3JzLmZvckVhY2goKGF1dGhvcikgPT4gYXV0aG9ycy5hZGQoYXV0aG9yKSk7XG4gICAgfVxuICB9KTtcbiAgaWYgKGF1dGhvcnMuc2l6ZSA+IDApIHtcbiAgICBjb25zdCBhdXRob3JUb1JlbGF5c01hcCA9IGdldFJlbGF5c0ZvckZpbHRlcldpdGhBdXRob3JzKG5kaywgQXJyYXkuZnJvbShhdXRob3JzKSk7XG4gICAgZm9yIChjb25zdCByZWxheVVybCBvZiBhdXRob3JUb1JlbGF5c01hcC5rZXlzKCkpIHtcbiAgICAgIHJlc3VsdC5zZXQocmVsYXlVcmwsIFtdKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBmaWx0ZXIgb2YgZmlsdGVycykge1xuICAgICAgaWYgKGZpbHRlci5hdXRob3JzKSB7XG4gICAgICAgIGZvciAoY29uc3QgW3JlbGF5VXJsLCBhdXRob3JzMl0gb2YgYXV0aG9yVG9SZWxheXNNYXAuZW50cmllcygpKSB7XG4gICAgICAgICAgY29uc3QgYXV0aG9yRmlsdGVyQW5kUmVsYXlQdWJrZXlJbnRlcnNlY3Rpb24gPSBmaWx0ZXIuYXV0aG9ycy5maWx0ZXIoXG4gICAgICAgICAgICAoYXV0aG9yKSA9PiBhdXRob3JzMi5pbmNsdWRlcyhhdXRob3IpXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXN1bHQuc2V0KHJlbGF5VXJsLCBbXG4gICAgICAgICAgICAuLi5yZXN1bHQuZ2V0KHJlbGF5VXJsKSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLi4uZmlsdGVyLFxuICAgICAgICAgICAgICAvLyBPdmVyd3JpdGUgYXV0aG9ycyBzZW50IHRvIHRoaXMgcmVsYXkgd2l0aCB0aGUgYXV0aG9ycyB0aGF0IHdlcmVcbiAgICAgICAgICAgICAgLy8gcHJlc2VudCBpbiB0aGUgZmlsdGVyIGFuZCBhcmUgYWxzbyBwcmVzZW50IGluIHRoZSByZWxheVxuICAgICAgICAgICAgICBhdXRob3JzOiBhdXRob3JGaWx0ZXJBbmRSZWxheVB1YmtleUludGVyc2VjdGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGNvbnN0IHJlbGF5VXJsIG9mIGF1dGhvclRvUmVsYXlzTWFwLmtleXMoKSkge1xuICAgICAgICAgIHJlc3VsdC5zZXQocmVsYXlVcmwsIFsuLi5yZXN1bHQuZ2V0KHJlbGF5VXJsKSwgZmlsdGVyXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKG5kay5leHBsaWNpdFJlbGF5VXJscykge1xuICAgICAgbmRrLmV4cGxpY2l0UmVsYXlVcmxzLmZvckVhY2goKHJlbGF5VXJsKSA9PiB7XG4gICAgICAgIHJlc3VsdC5zZXQocmVsYXlVcmwsIGZpbHRlcnMpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChyZXN1bHQuc2l6ZSA9PT0gMCkge1xuICAgIHBvb2wucGVybWFuZW50QW5kQ29ubmVjdGVkUmVsYXlzKCkuc2xpY2UoMCwgNSkuZm9yRWFjaCgocmVsYXkpID0+IHtcbiAgICAgIHJlc3VsdC5zZXQocmVsYXkudXJsLCBmaWx0ZXJzKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlUmVsYXlTZXRzRnJvbUZpbHRlcnMobmRrLCBmaWx0ZXJzLCBwb29sKSB7XG4gIGNvbnN0IGEgPSBjYWxjdWxhdGVSZWxheVNldHNGcm9tRmlsdGVyKG5kaywgZmlsdGVycywgcG9vbCk7XG4gIHJldHVybiBhO1xufVxuXG4vLyBzcmMvZXZlbnRzL2NvbnRlbnQtdGFnZ2VyLnRzXG5pbXBvcnQgeyBuaXAxOSB9IGZyb20gXCJub3N0ci10b29sc1wiO1xuZnVuY3Rpb24gbWVyZ2VUYWdzKHRhZ3MxLCB0YWdzMikge1xuICBjb25zdCB0YWdNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCBnZW5lcmF0ZUtleSA9ICh0YWcpID0+IHRhZy5qb2luKFwiLFwiKTtcbiAgY29uc3QgaXNDb250YWluZWQgPSAoc21hbGxlciwgbGFyZ2VyKSA9PiB7XG4gICAgcmV0dXJuIHNtYWxsZXIuZXZlcnkoKHZhbHVlLCBpbmRleCkgPT4gdmFsdWUgPT09IGxhcmdlcltpbmRleF0pO1xuICB9O1xuICBjb25zdCBwcm9jZXNzVGFnID0gKHRhZykgPT4ge1xuICAgIGZvciAoY29uc3QgW2tleSwgZXhpc3RpbmdUYWddIG9mIHRhZ01hcCkge1xuICAgICAgaWYgKGlzQ29udGFpbmVkKGV4aXN0aW5nVGFnLCB0YWcpIHx8IGlzQ29udGFpbmVkKHRhZywgZXhpc3RpbmdUYWcpKSB7XG4gICAgICAgIGlmICh0YWcubGVuZ3RoID49IGV4aXN0aW5nVGFnLmxlbmd0aCkge1xuICAgICAgICAgIHRhZ01hcC5zZXQoa2V5LCB0YWcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGFnTWFwLnNldChnZW5lcmF0ZUtleSh0YWcpLCB0YWcpO1xuICB9O1xuICB0YWdzMS5jb25jYXQodGFnczIpLmZvckVhY2gocHJvY2Vzc1RhZyk7XG4gIHJldHVybiBBcnJheS5mcm9tKHRhZ01hcC52YWx1ZXMoKSk7XG59XG5mdW5jdGlvbiB1bmlxdWVUYWcoYSwgYikge1xuICBjb25zdCBhTGVuZ3RoID0gYS5sZW5ndGg7XG4gIGNvbnN0IGJMZW5ndGggPSBiLmxlbmd0aDtcbiAgY29uc3Qgc2FtZUxlbmd0aCA9IGFMZW5ndGggPT09IGJMZW5ndGg7XG4gIGlmIChzYW1lTGVuZ3RoKSB7XG4gICAgaWYgKGEuZXZlcnkoKHYsIGkpID0+IHYgPT09IGJbaV0pKSB7XG4gICAgICByZXR1cm4gW2FdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW2EsIGJdO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhTGVuZ3RoID4gYkxlbmd0aCAmJiBhLmV2ZXJ5KCh2LCBpKSA9PiB2ID09PSBiW2ldKSkge1xuICAgIHJldHVybiBbYV07XG4gIH0gZWxzZSBpZiAoYkxlbmd0aCA+IGFMZW5ndGggJiYgYi5ldmVyeSgodiwgaSkgPT4gdiA9PT0gYVtpXSkpIHtcbiAgICByZXR1cm4gW2JdO1xuICB9XG4gIHJldHVybiBbYSwgYl07XG59XG52YXIgaGFzaHRhZ1JlZ2V4ID0gLyg/PD1cXHN8XikoI1teXFxzIUAjJCVeJiooKT0rLi8sW3tcXF19OzonXCI/PjxdKykvZztcbmZ1bmN0aW9uIGdlbmVyYXRlSGFzaHRhZ3MoY29udGVudCkge1xuICBjb25zdCBoYXNodGFncyA9IGNvbnRlbnQubWF0Y2goaGFzaHRhZ1JlZ2V4KTtcbiAgY29uc3QgdGFnSWRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgY29uc3QgdGFnID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgaWYgKGhhc2h0YWdzKSB7XG4gICAgZm9yIChjb25zdCBoYXNodGFnIG9mIGhhc2h0YWdzKSB7XG4gICAgICBpZiAodGFnSWRzLmhhcyhoYXNodGFnLnNsaWNlKDEpKSkgY29udGludWU7XG4gICAgICB0YWcuYWRkKGhhc2h0YWcuc2xpY2UoMSkpO1xuICAgICAgdGFnSWRzLmFkZChoYXNodGFnLnNsaWNlKDEpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIEFycmF5LmZyb20odGFnKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlQ29udGVudFRhZ3MoY29udGVudCwgdGFncyA9IFtdKSB7XG4gIGNvbnN0IHRhZ1JlZ2V4ID0gLyhAfG5vc3RyOikobnB1YnxucHJvZmlsZXxub3RlfG5ldmVudHxuYWRkcilbYS16QS1aMC05XSsvZztcbiAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgY29uc3QgYWRkVGFnSWZOZXcgPSAodCkgPT4ge1xuICAgIGlmICghdGFncy5maW5kKCh0MikgPT4gW1wicVwiLCB0WzBdXS5pbmNsdWRlcyh0MlswXSkgJiYgdDJbMV0gPT09IHRbMV0pKSB7XG4gICAgICB0YWdzLnB1c2godCk7XG4gICAgfVxuICB9O1xuICBjb250ZW50ID0gY29udGVudC5yZXBsYWNlKHRhZ1JlZ2V4LCAodGFnKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGVudGl0eSA9IHRhZy5zcGxpdCgvKEB8bm9zdHI6KS8pWzJdO1xuICAgICAgY29uc3QgeyB0eXBlLCBkYXRhIH0gPSBuaXAxOS5kZWNvZGUoZW50aXR5KTtcbiAgICAgIGxldCB0O1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJucHViXCI6XG4gICAgICAgICAgdCA9IFtcInBcIiwgZGF0YV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJucHJvZmlsZVwiOlxuICAgICAgICAgIHQgPSBbXCJwXCIsIGRhdGEucHVia2V5XTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm5vdGVcIjpcbiAgICAgICAgICBwcm9taXNlcy5wdXNoKFxuICAgICAgICAgICAgbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgYWRkVGFnSWZOZXcoW1xuICAgICAgICAgICAgICAgIFwicVwiLFxuICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgYXdhaXQgbWF5YmVHZXRFdmVudFJlbGF5VXJsKGVudGl0eSlcbiAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm5ldmVudFwiOlxuICAgICAgICAgIHByb21pc2VzLnB1c2goXG4gICAgICAgICAgICBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCB7IGlkLCBhdXRob3IgfSA9IGRhdGE7XG4gICAgICAgICAgICAgIGxldCB7IHJlbGF5cyB9ID0gZGF0YTtcbiAgICAgICAgICAgICAgaWYgKCFyZWxheXMgfHwgcmVsYXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJlbGF5cyA9IFthd2FpdCBtYXliZUdldEV2ZW50UmVsYXlVcmwoZW50aXR5KV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYWRkVGFnSWZOZXcoW1wicVwiLCBpZCwgcmVsYXlzWzBdXSk7XG4gICAgICAgICAgICAgIGlmIChhdXRob3IpIGFkZFRhZ0lmTmV3KFtcInBcIiwgYXV0aG9yXSk7XG4gICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm5hZGRyXCI6XG4gICAgICAgICAgcHJvbWlzZXMucHVzaChcbiAgICAgICAgICAgIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGlkID0gW2RhdGEua2luZCwgZGF0YS5wdWJrZXksIGRhdGEuaWRlbnRpZmllcl0uam9pbihcIjpcIik7XG4gICAgICAgICAgICAgIGxldCByZWxheXMgPSBkYXRhLnJlbGF5cyA/PyBbXTtcbiAgICAgICAgICAgICAgaWYgKHJlbGF5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZWxheXMgPSBbYXdhaXQgbWF5YmVHZXRFdmVudFJlbGF5VXJsKGVudGl0eSldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGFkZFRhZ0lmTmV3KFtcInFcIiwgaWQsIHJlbGF5c1swXV0pO1xuICAgICAgICAgICAgICBhZGRUYWdJZk5ldyhbXCJwXCIsIGRhdGEucHVia2V5XSk7XG4gICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gdGFnO1xuICAgICAgfVxuICAgICAgaWYgKHQpIGFkZFRhZ0lmTmV3KHQpO1xuICAgICAgcmV0dXJuIGBub3N0cjoke2VudGl0eX1gO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gdGFnO1xuICAgIH1cbiAgfSk7XG4gIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgY29uc3QgbmV3VGFncyA9IGdlbmVyYXRlSGFzaHRhZ3MoY29udGVudCkubWFwKChoYXNodGFnKSA9PiBbXCJ0XCIsIGhhc2h0YWddKTtcbiAgdGFncyA9IG1lcmdlVGFncyh0YWdzLCBuZXdUYWdzKTtcbiAgcmV0dXJuIHsgY29udGVudCwgdGFncyB9O1xufVxuYXN5bmMgZnVuY3Rpb24gbWF5YmVHZXRFdmVudFJlbGF5VXJsKG5pcDE5SWQpIHtcbiAgcmV0dXJuIFwiXCI7XG59XG5cbi8vIHNyYy9ldmVudHMva2luZC50c1xuZnVuY3Rpb24gaXNSZXBsYWNlYWJsZSgpIHtcbiAgaWYgKHRoaXMua2luZCA9PT0gdm9pZCAwKSB0aHJvdyBuZXcgRXJyb3IoXCJLaW5kIG5vdCBzZXRcIik7XG4gIHJldHVybiBbMCwgM10uaW5jbHVkZXModGhpcy5raW5kKSB8fCB0aGlzLmtpbmQgPj0gMWU0ICYmIHRoaXMua2luZCA8IDJlNCB8fCB0aGlzLmtpbmQgPj0gM2U0ICYmIHRoaXMua2luZCA8IDRlNDtcbn1cbmZ1bmN0aW9uIGlzRXBoZW1lcmFsKCkge1xuICBpZiAodGhpcy5raW5kID09PSB2b2lkIDApIHRocm93IG5ldyBFcnJvcihcIktpbmQgbm90IHNldFwiKTtcbiAgcmV0dXJuIHRoaXMua2luZCA+PSAyZTQgJiYgdGhpcy5raW5kIDwgM2U0O1xufVxuZnVuY3Rpb24gaXNQYXJhbVJlcGxhY2VhYmxlKCkge1xuICBpZiAodGhpcy5raW5kID09PSB2b2lkIDApIHRocm93IG5ldyBFcnJvcihcIktpbmQgbm90IHNldFwiKTtcbiAgcmV0dXJuIHRoaXMua2luZCA+PSAzZTQgJiYgdGhpcy5raW5kIDwgNGU0O1xufVxuXG4vLyBzcmMvZXZlbnRzL2VuY3J5cHRpb24udHNcbmFzeW5jIGZ1bmN0aW9uIGVuY3J5cHQocmVjaXBpZW50LCBzaWduZXIsIHNjaGVtZSA9IFwibmlwNDRcIikge1xuICBsZXQgZW5jcnlwdGVkO1xuICBpZiAoIXRoaXMubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBOREsgaW5zdGFuY2UgZm91bmQhXCIpO1xuICBpZiAoIXNpZ25lcikge1xuICAgIHRoaXMubmRrLmFzc2VydFNpZ25lcigpO1xuICAgIHNpZ25lciA9IHRoaXMubmRrLnNpZ25lcjtcbiAgfVxuICBpZiAoIXJlY2lwaWVudCkge1xuICAgIGNvbnN0IHBUYWdzID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJwXCIpO1xuICAgIGlmIChwVGFncy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJObyByZWNpcGllbnQgY291bGQgYmUgZGV0ZXJtaW5lZCBhbmQgbm8gZXhwbGljaXQgcmVjaXBpZW50IHdhcyBwcm92aWRlZFwiXG4gICAgICApO1xuICAgIH1cbiAgICByZWNpcGllbnQgPSB0aGlzLm5kay5nZXRVc2VyKHsgcHVia2V5OiBwVGFnc1swXVsxXSB9KTtcbiAgfVxuICBpZiAoc2NoZW1lID09PSBcIm5pcDQ0XCIgJiYgYXdhaXQgaXNFbmNyeXB0aW9uRW5hYmxlZChzaWduZXIsIFwibmlwNDRcIikpIHtcbiAgICBlbmNyeXB0ZWQgPSBhd2FpdCBzaWduZXI/LmVuY3J5cHQocmVjaXBpZW50LCB0aGlzLmNvbnRlbnQsIFwibmlwNDRcIik7XG4gIH1cbiAgaWYgKCghZW5jcnlwdGVkIHx8IHNjaGVtZSA9PT0gXCJuaXAwNFwiKSAmJiBhd2FpdCBpc0VuY3J5cHRpb25FbmFibGVkKHNpZ25lciwgXCJuaXAwNFwiKSkge1xuICAgIGVuY3J5cHRlZCA9IGF3YWl0IHNpZ25lci5lbmNyeXB0KHJlY2lwaWVudCwgdGhpcy5jb250ZW50LCBcIm5pcDA0XCIpO1xuICB9XG4gIGlmICghZW5jcnlwdGVkKSB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZW5jcnlwdCBldmVudC5cIik7XG4gIHRoaXMuY29udGVudCA9IGVuY3J5cHRlZDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGRlY3J5cHQoc2VuZGVyLCBzaWduZXIsIHNjaGVtZSkge1xuICBsZXQgZGVjcnlwdGVkO1xuICBpZiAoIXRoaXMubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBOREsgaW5zdGFuY2UgZm91bmQhXCIpO1xuICBpZiAoIXNpZ25lcikge1xuICAgIHRoaXMubmRrLmFzc2VydFNpZ25lcigpO1xuICAgIHNpZ25lciA9IHRoaXMubmRrLnNpZ25lcjtcbiAgfVxuICBpZiAoIXNpZ25lcikgdGhyb3cgbmV3IEVycm9yKFwibm8gTkRLIHNpZ25lclwiKTtcbiAgaWYgKCFzZW5kZXIpIHtcbiAgICBzZW5kZXIgPSB0aGlzLmF1dGhvcjtcbiAgfVxuICBpZiAoIXNjaGVtZSkgc2NoZW1lID0gdGhpcy5jb250ZW50Lm1hdGNoKC9cXFxcP2l2PS8pID8gXCJuaXAwNFwiIDogXCJuaXA0NFwiO1xuICBpZiAoKHNjaGVtZSA9PT0gXCJuaXAwNFwiIHx8IHRoaXMua2luZCA9PT0gNCkgJiYgYXdhaXQgaXNFbmNyeXB0aW9uRW5hYmxlZChzaWduZXIsIFwibmlwMDRcIikgJiYgdGhpcy5jb250ZW50LnNlYXJjaChcIlxcXFw/aXY9XCIpKSB7XG4gICAgZGVjcnlwdGVkID0gYXdhaXQgc2lnbmVyLmRlY3J5cHQoc2VuZGVyLCB0aGlzLmNvbnRlbnQsIFwibmlwMDRcIik7XG4gIH1cbiAgaWYgKCFkZWNyeXB0ZWQgJiYgc2NoZW1lID09PSBcIm5pcDQ0XCIgJiYgYXdhaXQgaXNFbmNyeXB0aW9uRW5hYmxlZChzaWduZXIsIFwibmlwNDRcIikpIHtcbiAgICBkZWNyeXB0ZWQgPSBhd2FpdCBzaWduZXIuZGVjcnlwdChzZW5kZXIsIHRoaXMuY29udGVudCwgXCJuaXA0NFwiKTtcbiAgfVxuICBpZiAoIWRlY3J5cHRlZCkgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGRlY3J5cHQgZXZlbnQuXCIpO1xuICB0aGlzLmNvbnRlbnQgPSBkZWNyeXB0ZWQ7XG59XG5hc3luYyBmdW5jdGlvbiBpc0VuY3J5cHRpb25FbmFibGVkKHNpZ25lciwgc2NoZW1lKSB7XG4gIGlmICghc2lnbmVyLmVuY3J5cHRpb25FbmFibGVkKSByZXR1cm4gZmFsc2U7XG4gIGlmICghc2NoZW1lKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIEJvb2xlYW4oYXdhaXQgc2lnbmVyLmVuY3J5cHRpb25FbmFibGVkKHNjaGVtZSkpO1xufVxuXG4vLyBzcmMvZXZlbnRzL25pcDE5LnRzXG5pbXBvcnQgeyBuaXAxOSBhcyBuaXAxOTIgfSBmcm9tIFwibm9zdHItdG9vbHNcIjtcbnZhciBERUZBVUxUX1JFTEFZX0NPVU5UID0gMjtcbmZ1bmN0aW9uIGVuY29kZShtYXhSZWxheUNvdW50ID0gREVGQVVMVF9SRUxBWV9DT1VOVCkge1xuICBsZXQgcmVsYXlzID0gW107XG4gIGlmICh0aGlzLm9uUmVsYXlzLmxlbmd0aCA+IDApIHtcbiAgICByZWxheXMgPSB0aGlzLm9uUmVsYXlzLm1hcCgocmVsYXkpID0+IHJlbGF5LnVybCk7XG4gIH0gZWxzZSBpZiAodGhpcy5yZWxheSkge1xuICAgIHJlbGF5cyA9IFt0aGlzLnJlbGF5LnVybF07XG4gIH1cbiAgaWYgKHJlbGF5cy5sZW5ndGggPiBtYXhSZWxheUNvdW50KSB7XG4gICAgcmVsYXlzID0gcmVsYXlzLnNsaWNlKDAsIG1heFJlbGF5Q291bnQpO1xuICB9XG4gIGlmICh0aGlzLmlzUGFyYW1SZXBsYWNlYWJsZSgpKSB7XG4gICAgcmV0dXJuIG5pcDE5Mi5uYWRkckVuY29kZSh7XG4gICAgICBraW5kOiB0aGlzLmtpbmQsXG4gICAgICBwdWJrZXk6IHRoaXMucHVia2V5LFxuICAgICAgaWRlbnRpZmllcjogdGhpcy5yZXBsYWNlYWJsZURUYWcoKSxcbiAgICAgIHJlbGF5c1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKHJlbGF5cy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIG5pcDE5Mi5uZXZlbnRFbmNvZGUoe1xuICAgICAgaWQ6IHRoaXMudGFnSWQoKSxcbiAgICAgIHJlbGF5cyxcbiAgICAgIGF1dGhvcjogdGhpcy5wdWJrZXlcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmlwMTkyLm5vdGVFbmNvZGUodGhpcy50YWdJZCgpKTtcbiAgfVxufVxuXG4vLyBzcmMvZXZlbnRzL3JlcG9zdC50c1xuYXN5bmMgZnVuY3Rpb24gcmVwb3N0KHB1Ymxpc2ggPSB0cnVlLCBzaWduZXIpIHtcbiAgaWYgKCFzaWduZXIgJiYgcHVibGlzaCkge1xuICAgIGlmICghdGhpcy5uZGspIHRocm93IG5ldyBFcnJvcihcIk5vIE5ESyBpbnN0YW5jZSBmb3VuZFwiKTtcbiAgICB0aGlzLm5kay5hc3NlcnRTaWduZXIoKTtcbiAgICBzaWduZXIgPSB0aGlzLm5kay5zaWduZXI7XG4gIH1cbiAgY29uc3QgZSA9IG5ldyBOREtFdmVudCh0aGlzLm5kaywge1xuICAgIGtpbmQ6IGdldEtpbmQodGhpcylcbiAgfSk7XG4gIGlmICghdGhpcy5pc1Byb3RlY3RlZClcbiAgICBlLmNvbnRlbnQgPSBKU09OLnN0cmluZ2lmeSh0aGlzLnJhd0V2ZW50KCkpO1xuICBlLnRhZyh0aGlzKTtcbiAgaWYgKHRoaXMua2luZCAhPT0gMSAvKiBUZXh0ICovKSB7XG4gICAgZS50YWdzLnB1c2goW1wia1wiLCBgJHt0aGlzLmtpbmR9YF0pO1xuICB9XG4gIGlmIChzaWduZXIpIGF3YWl0IGUuc2lnbihzaWduZXIpO1xuICBpZiAocHVibGlzaCkgYXdhaXQgZS5wdWJsaXNoKCk7XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gZ2V0S2luZChldmVudCkge1xuICBpZiAoZXZlbnQua2luZCA9PT0gMSkge1xuICAgIHJldHVybiA2IC8qIFJlcG9zdCAqLztcbiAgfVxuICByZXR1cm4gMTYgLyogR2VuZXJpY1JlcG9zdCAqLztcbn1cblxuLy8gc3JjL3RocmVhZC9pbmRleC50c1xuZnVuY3Rpb24gZXZlbnRzQnlTYW1lQXV0aG9yKG9wLCBldmVudHMpIHtcbiAgY29uc3QgZXZlbnRzQnlBdXRob3IgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBldmVudHNCeUF1dGhvci5zZXQob3AuaWQsIG9wKTtcbiAgZXZlbnRzLmZvckVhY2goKGV2ZW50KSA9PiB7XG4gICAgaWYgKGV2ZW50LnB1YmtleSA9PT0gb3AucHVia2V5KSB7XG4gICAgICBldmVudHNCeUF1dGhvci5zZXQoZXZlbnQuaWQsIGV2ZW50KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZXZlbnRzQnlBdXRob3I7XG59XG52YXIgaGFzTWFya2VycyA9IChldmVudCwgdGFnVHlwZSkgPT4ge1xuICByZXR1cm4gZXZlbnQuZ2V0TWF0Y2hpbmdUYWdzKHRhZ1R5cGUpLnNvbWUoKHRhZykgPT4gdGFnWzNdICYmIHRhZ1szXSAhPT0gXCJcIik7XG59O1xuZnVuY3Rpb24gZXZlbnRJc1JlcGx5KG9wLCBldmVudCwgdGhyZWFkSWRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSwgdGFnVHlwZSkge1xuICB0YWdUeXBlID8/PSBvcC50YWdUeXBlKCk7XG4gIGNvbnN0IHRhZ3MgPSBldmVudC5nZXRNYXRjaGluZ1RhZ3ModGFnVHlwZSk7XG4gIHRocmVhZElkcy5hZGQob3AudGFnSWQoKSk7XG4gIGlmICh0aHJlYWRJZHMuaGFzKGV2ZW50LnRhZ0lkKCkpKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IGhlZWRFeHBsaWNpdFJlcGx5TWFya2VyID0gKCkgPT4ge1xuICAgIGxldCBldmVudElzVGFnZ2VkID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCB0YWcgb2YgdGFncykge1xuICAgICAgaWYgKHRhZ1szXSA9PT0gXCJyZXBseVwiKSByZXR1cm4gdGhyZWFkSWRzLmhhcyh0YWdbMV0pO1xuICAgICAgY29uc3QgbWFya2VySXNFbXB0eSA9IHRhZ1szXSA9PT0gXCJcIiB8fCB0YWdbM10gPT09IHZvaWQgMDtcbiAgICAgIGNvbnN0IG1hcmtlcklzUm9vdCA9IHRhZ1szXSA9PT0gXCJyb290XCI7XG4gICAgICBpZiAodGFnWzFdID09PSBvcC50YWdJZCgpICYmIChtYXJrZXJJc0VtcHR5IHx8IG1hcmtlcklzUm9vdCkpIHtcbiAgICAgICAgZXZlbnRJc1RhZ2dlZCA9IG1hcmtlcklzUm9vdCA/IFwicm9vdFwiIDogdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFldmVudElzVGFnZ2VkKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGV2ZW50SXNUYWdnZWQgPT09IFwicm9vdFwiKSByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgY29uc3QgZXhwbGljaXRSZXBseU1hcmtlciA9IGhlZWRFeHBsaWNpdFJlcGx5TWFya2VyKCk7XG4gIGlmIChleHBsaWNpdFJlcGx5TWFya2VyICE9PSB2b2lkIDApIHJldHVybiBleHBsaWNpdFJlcGx5TWFya2VyO1xuICBpZiAoaGFzTWFya2VycyhldmVudCwgdGFnVHlwZSkpIHJldHVybiBmYWxzZTtcbiAgY29uc3QgZXhwZWN0ZWRUYWdzID0gb3AuZ2V0TWF0Y2hpbmdUYWdzKFwiZVwiKS5tYXAoKHRhZykgPT4gdGFnWzFdKTtcbiAgZXhwZWN0ZWRUYWdzLnB1c2gob3AuaWQpO1xuICByZXR1cm4gZXZlbnQuZ2V0TWF0Y2hpbmdUYWdzKFwiZVwiKS5ldmVyeSgodGFnKSA9PiBleHBlY3RlZFRhZ3MuaW5jbHVkZXModGFnWzFdKSk7XG59XG5mdW5jdGlvbiBldmVudFRocmVhZHMob3AsIGV2ZW50cykge1xuICBjb25zdCBldmVudHNCeUF1dGhvciA9IGV2ZW50c0J5U2FtZUF1dGhvcihvcCwgZXZlbnRzKTtcbiAgY29uc3QgdGhyZWFkRXZlbnRzID0gZXZlbnRzLmZpbHRlcigoZXZlbnQpID0+IGV2ZW50SXNQYXJ0T2ZUaHJlYWQob3AsIGV2ZW50LCBldmVudHNCeUF1dGhvcikpO1xuICByZXR1cm4gdGhyZWFkRXZlbnRzLnNvcnQoKGEsIGIpID0+IGEuY3JlYXRlZF9hdCAtIGIuY3JlYXRlZF9hdCk7XG59XG5mdW5jdGlvbiBnZXRFdmVudFJlcGx5SWQoZXZlbnQpIHtcbiAgY29uc3QgcmVwbHlUYWcgPSBnZXRSZXBseVRhZyhldmVudCk7XG4gIGlmIChyZXBseVRhZykgcmV0dXJuIHJlcGx5VGFnWzFdO1xuICBjb25zdCByb290VGFnID0gZ2V0Um9vdFRhZyhldmVudCk7XG4gIGlmIChyb290VGFnKSByZXR1cm4gcm9vdFRhZ1sxXTtcbn1cbmZ1bmN0aW9uIGlzRXZlbnRPcmlnaW5hbFBvc3QoZXZlbnQpIHtcbiAgcmV0dXJuIGdldEV2ZW50UmVwbHlJZChldmVudCkgPT09IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGV2ZW50VGhyZWFkSWRzKG9wLCBldmVudHMpIHtcbiAgY29uc3QgdGhyZWFkSWRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgdGhyZWFkRXZlbnRzID0gZXZlbnRUaHJlYWRzKG9wLCBldmVudHMpO1xuICB0aHJlYWRFdmVudHMuZm9yRWFjaCgoZXZlbnQpID0+IHRocmVhZElkcy5zZXQoZXZlbnQuaWQsIGV2ZW50KSk7XG4gIHJldHVybiB0aHJlYWRJZHM7XG59XG5mdW5jdGlvbiBldmVudFJlcGxpZXMob3AsIGV2ZW50cywgdGhyZWFkRXZlbnRJZHMpIHtcbiAgdGhyZWFkRXZlbnRJZHMgPz89IG5ldyBTZXQoZXZlbnRUaHJlYWRJZHMob3AsIGV2ZW50cykua2V5cygpKTtcbiAgcmV0dXJuIGV2ZW50cy5maWx0ZXIoKGV2ZW50KSA9PiBldmVudElzUmVwbHkob3AsIGV2ZW50LCB0aHJlYWRFdmVudElkcykpO1xufVxuZnVuY3Rpb24gZXZlbnRJc1BhcnRPZlRocmVhZChvcCwgZXZlbnQsIGV2ZW50c0J5QXV0aG9yKSB7XG4gIGlmIChvcC5wdWJrZXkgIT09IGV2ZW50LnB1YmtleSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCB0YWdnZWRFdmVudElkcyA9IGV2ZW50LmdldE1hdGNoaW5nVGFncyhcImVcIikubWFwKCh0YWcpID0+IHRhZ1sxXSk7XG4gIGNvbnN0IGFsbFRhZ2dlZEV2ZW50c0FyZUJ5T3JpZ2luYWxBdXRob3IgPSB0YWdnZWRFdmVudElkcy5ldmVyeSgoaWQpID0+IGV2ZW50c0J5QXV0aG9yLmhhcyhpZCkpO1xuICByZXR1cm4gYWxsVGFnZ2VkRXZlbnRzQXJlQnlPcmlnaW5hbEF1dGhvcjtcbn1cbmZ1bmN0aW9uIGV2ZW50SGFzRVRhZ01hcmtlcnMoZXZlbnQpIHtcbiAgZm9yIChjb25zdCB0YWcgb2YgZXZlbnQudGFncykge1xuICAgIGlmICh0YWdbMF0gPT09IFwiZVwiICYmICh0YWdbM10gPz8gXCJcIikubGVuZ3RoID4gMCkgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0Um9vdEV2ZW50SWQoZXZlbnQsIHNlYXJjaFRhZykge1xuICBzZWFyY2hUYWcgPz89IGV2ZW50LnRhZ1R5cGUoKTtcbiAgY29uc3Qgcm9vdEV2ZW50VGFnID0gZ2V0Um9vdFRhZyhldmVudCwgc2VhcmNoVGFnKTtcbiAgaWYgKHJvb3RFdmVudFRhZykgcmV0dXJuIHJvb3RFdmVudFRhZ1sxXTtcbiAgY29uc3QgcmVwbHlUYWcgPSBnZXRSZXBseVRhZyhldmVudCwgc2VhcmNoVGFnKTtcbiAgcmV0dXJuIHJlcGx5VGFnPy5bMV07XG59XG5mdW5jdGlvbiBnZXRSb290VGFnKGV2ZW50LCBzZWFyY2hUYWcpIHtcbiAgc2VhcmNoVGFnID8/PSBldmVudC50YWdUeXBlKCk7XG4gIGNvbnN0IHJvb3RFdmVudFRhZyA9IGV2ZW50LnRhZ3MuZmluZChpc1RhZ1Jvb3RUYWcpO1xuICBpZiAoIXJvb3RFdmVudFRhZykge1xuICAgIGlmIChldmVudEhhc0VUYWdNYXJrZXJzKGV2ZW50KSkgcmV0dXJuO1xuICAgIGNvbnN0IG1hdGNoaW5nVGFncyA9IGV2ZW50LmdldE1hdGNoaW5nVGFncyhzZWFyY2hUYWcpO1xuICAgIGlmIChtYXRjaGluZ1RhZ3MubGVuZ3RoIDwgMykgcmV0dXJuIG1hdGNoaW5nVGFnc1swXTtcbiAgfVxuICByZXR1cm4gcm9vdEV2ZW50VGFnO1xufVxudmFyIG5pcDIyUm9vdFRhZ3MgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJBXCIsIFwiRVwiLCBcIklcIl0pO1xudmFyIG5pcDIyUmVwbHlUYWdzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wiYVwiLCBcImVcIiwgXCJpXCJdKTtcbmZ1bmN0aW9uIGdldFJlcGx5VGFnKGV2ZW50LCBzZWFyY2hUYWcpIHtcbiAgaWYgKGV2ZW50LmtpbmQgPT09IDExMTEgLyogR2VuZXJpY1JlcGx5ICovKSB7XG4gICAgbGV0IHJlcGx5VGFnMjtcbiAgICBmb3IgKGNvbnN0IHRhZyBvZiBldmVudC50YWdzKSB7XG4gICAgICBpZiAobmlwMjJSb290VGFncy5oYXModGFnWzBdKSkgcmVwbHlUYWcyID0gdGFnO1xuICAgICAgZWxzZSBpZiAobmlwMjJSZXBseVRhZ3MuaGFzKHRhZ1swXSkpIHtcbiAgICAgICAgcmVwbHlUYWcyID0gdGFnO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcGx5VGFnMjtcbiAgfVxuICBzZWFyY2hUYWcgPz89IGV2ZW50LnRhZ1R5cGUoKTtcbiAgbGV0IGhhc01hcmtlcnMyID0gZmFsc2U7XG4gIGxldCByZXBseVRhZztcbiAgZm9yIChjb25zdCB0YWcgb2YgZXZlbnQudGFncykge1xuICAgIGlmICh0YWdbMF0gIT09IHNlYXJjaFRhZykgY29udGludWU7XG4gICAgaWYgKCh0YWdbM10gPz8gXCJcIikubGVuZ3RoID4gMCkgaGFzTWFya2VyczIgPSB0cnVlO1xuICAgIGlmIChoYXNNYXJrZXJzMiAmJiB0YWdbM10gPT09IFwicmVwbHlcIikgcmV0dXJuIHRhZztcbiAgICBpZiAoaGFzTWFya2VyczIgJiYgdGFnWzNdID09PSBcInJvb3RcIikgcmVwbHlUYWcgPSB0YWc7XG4gICAgaWYgKCFoYXNNYXJrZXJzMikgcmVwbHlUYWcgPSB0YWc7XG4gIH1cbiAgcmV0dXJuIHJlcGx5VGFnO1xufVxuZnVuY3Rpb24gaXNUYWdSb290VGFnKHRhZykge1xuICByZXR1cm4gdGFnWzBdID09PSBcIkVcIiB8fCB0YWdbM10gPT09IFwicm9vdFwiO1xufVxuXG4vLyBzcmMvZXZlbnRzL2ZldGNoLXRhZ2dlZC1ldmVudC50c1xuYXN5bmMgZnVuY3Rpb24gZmV0Y2hUYWdnZWRFdmVudCh0YWcsIG1hcmtlcikge1xuICBpZiAoIXRoaXMubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJOREsgaW5zdGFuY2Ugbm90IGZvdW5kXCIpO1xuICBjb25zdCB0ID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3ModGFnLCBtYXJrZXIpO1xuICBpZiAodC5sZW5ndGggPT09IDApIHJldHVybiB2b2lkIDA7XG4gIGNvbnN0IFtfLCBpZCwgaGludF0gPSB0WzBdO1xuICBsZXQgcmVsYXk7XG4gIGNvbnN0IGV2ZW50ID0gYXdhaXQgdGhpcy5uZGsuZmV0Y2hFdmVudChpZCwge30sIHJlbGF5KTtcbiAgcmV0dXJuIGV2ZW50O1xufVxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hSb290RXZlbnQoc3ViT3B0cykge1xuICBpZiAoIXRoaXMubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJOREsgaW5zdGFuY2Ugbm90IGZvdW5kXCIpO1xuICBjb25zdCByb290VGFnID0gZ2V0Um9vdFRhZyh0aGlzKTtcbiAgaWYgKCFyb290VGFnKSByZXR1cm4gdm9pZCAwO1xuICByZXR1cm4gdGhpcy5uZGsuZmV0Y2hFdmVudEZyb21UYWcocm9vdFRhZywgdGhpcywgc3ViT3B0cyk7XG59XG5hc3luYyBmdW5jdGlvbiBmZXRjaFJlcGx5RXZlbnQoc3ViT3B0cykge1xuICBpZiAoIXRoaXMubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJOREsgaW5zdGFuY2Ugbm90IGZvdW5kXCIpO1xuICBjb25zdCByZXBseVRhZyA9IGdldFJlcGx5VGFnKHRoaXMpO1xuICBpZiAoIXJlcGx5VGFnKSByZXR1cm4gdm9pZCAwO1xuICByZXR1cm4gdGhpcy5uZGsuZmV0Y2hFdmVudEZyb21UYWcocmVwbHlUYWcsIHRoaXMsIHN1Yk9wdHMpO1xufVxuXG4vLyBzcmMvZXZlbnRzL3NlcmlhbGl6ZXIudHNcbmZ1bmN0aW9uIHNlcmlhbGl6ZShpbmNsdWRlU2lnID0gZmFsc2UsIGluY2x1ZGVJZCA9IGZhbHNlKSB7XG4gIGNvbnN0IHBheWxvYWQgPSBbMCwgdGhpcy5wdWJrZXksIHRoaXMuY3JlYXRlZF9hdCwgdGhpcy5raW5kLCB0aGlzLnRhZ3MsIHRoaXMuY29udGVudF07XG4gIGlmIChpbmNsdWRlU2lnKSBwYXlsb2FkLnB1c2godGhpcy5zaWcpO1xuICBpZiAoaW5jbHVkZUlkKSBwYXlsb2FkLnB1c2godGhpcy5pZCk7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShwYXlsb2FkKTtcbn1cbmZ1bmN0aW9uIGRlc2VyaWFsaXplKHNlcmlhbGl6ZWRFdmVudCkge1xuICBjb25zdCBldmVudEFycmF5ID0gSlNPTi5wYXJzZShzZXJpYWxpemVkRXZlbnQpO1xuICBjb25zdCByZXQgPSB7XG4gICAgcHVia2V5OiBldmVudEFycmF5WzFdLFxuICAgIGNyZWF0ZWRfYXQ6IGV2ZW50QXJyYXlbMl0sXG4gICAga2luZDogZXZlbnRBcnJheVszXSxcbiAgICB0YWdzOiBldmVudEFycmF5WzRdLFxuICAgIGNvbnRlbnQ6IGV2ZW50QXJyYXlbNV1cbiAgfTtcbiAgaWYgKGV2ZW50QXJyYXkubGVuZ3RoID49IDcpIHJldC5zaWcgPSBldmVudEFycmF5WzZdO1xuICBpZiAoZXZlbnRBcnJheS5sZW5ndGggPj0gOCkgcmV0LmlkID0gZXZlbnRBcnJheVs3XTtcbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gc3JjL2V2ZW50cy92YWxpZGF0aW9uLnRzXG5pbXBvcnQgeyBzaGEyNTYgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy9zaGEyNTZcIjtcbmltcG9ydCB7IGJ5dGVzVG9IZXggfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy91dGlsc1wiO1xuaW1wb3J0IHsgc2Nobm9yciB9IGZyb20gXCJAbm9ibGUvY3VydmVzL3NlY3AyNTZrMVwiO1xuXG4vLyBzcmMvZXZlbnRzL3NpZ25hdHVyZS50c1xudmFyIHdvcmtlcjtcbnZhciBwcm9jZXNzaW5nUXVldWUgPSB7fTtcbmZ1bmN0aW9uIHNpZ25hdHVyZVZlcmlmaWNhdGlvbkluaXQodykge1xuICB3b3JrZXIgPSB3O1xuICB3b3JrZXIub25tZXNzYWdlID0gKG1zZykgPT4ge1xuICAgIGNvbnN0IFtldmVudElkLCByZXN1bHRdID0gbXNnLmRhdGE7XG4gICAgY29uc3QgcmVjb3JkID0gcHJvY2Vzc2luZ1F1ZXVlW2V2ZW50SWRdO1xuICAgIGlmICghcmVjb3JkKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiTm8gcmVjb3JkIGZvdW5kIGZvciBldmVudFwiLCBldmVudElkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGVsZXRlIHByb2Nlc3NpbmdRdWV1ZVtldmVudElkXTtcbiAgICBmb3IgKGNvbnN0IHJlc29sdmUgb2YgcmVjb3JkLnJlc29sdmVzKSB7XG4gICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgfVxuICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gdmVyaWZ5U2lnbmF0dXJlQXN5bmMoZXZlbnQsIHBlcnNpc3QpIHtcbiAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IGV2ZW50LnNlcmlhbGl6ZSgpO1xuICAgIGxldCBlbnF1ZXVlID0gZmFsc2U7XG4gICAgaWYgKCFwcm9jZXNzaW5nUXVldWVbZXZlbnQuaWRdKSB7XG4gICAgICBwcm9jZXNzaW5nUXVldWVbZXZlbnQuaWRdID0geyBldmVudCwgcmVzb2x2ZXM6IFtdIH07XG4gICAgICBlbnF1ZXVlID0gdHJ1ZTtcbiAgICB9XG4gICAgcHJvY2Vzc2luZ1F1ZXVlW2V2ZW50LmlkXS5yZXNvbHZlcy5wdXNoKHJlc29sdmUpO1xuICAgIGlmICghZW5xdWV1ZSkgcmV0dXJuO1xuICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICBzZXJpYWxpemVkLFxuICAgICAgaWQ6IGV2ZW50LmlkLFxuICAgICAgc2lnOiBldmVudC5zaWcsXG4gICAgICBwdWJrZXk6IGV2ZW50LnB1YmtleVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHByb21pc2U7XG59XG5cbi8vIHNyYy9ldmVudHMvdmFsaWRhdGlvbi50c1xuaW1wb3J0IHsgTFJVQ2FjaGUgfSBmcm9tIFwidHlwZXNjcmlwdC1scnUtY2FjaGVcIjtcbnZhciBQVUJLRVlfUkVHRVggPSAvXlthLWYwLTldezY0fSQvO1xuZnVuY3Rpb24gdmFsaWRhdGUoKSB7XG4gIGlmICh0eXBlb2YgdGhpcy5raW5kICE9PSBcIm51bWJlclwiKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgdGhpcy5jb250ZW50ICE9PSBcInN0cmluZ1wiKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgdGhpcy5jcmVhdGVkX2F0ICE9PSBcIm51bWJlclwiKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgdGhpcy5wdWJrZXkgIT09IFwic3RyaW5nXCIpIHJldHVybiBmYWxzZTtcbiAgaWYgKCF0aGlzLnB1YmtleS5tYXRjaChQVUJLRVlfUkVHRVgpKSByZXR1cm4gZmFsc2U7XG4gIGlmICghQXJyYXkuaXNBcnJheSh0aGlzLnRhZ3MpKSByZXR1cm4gZmFsc2U7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy50YWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdGFnID0gdGhpcy50YWdzW2ldO1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh0YWcpKSByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCB0YWcubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmICh0eXBlb2YgdGFnW2pdID09PSBcIm9iamVjdFwiKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxudmFyIHZlcmlmaWVkU2lnbmF0dXJlcyA9IG5ldyBMUlVDYWNoZSh7XG4gIG1heFNpemU6IDFlMyxcbiAgZW50cnlFeHBpcmF0aW9uVGltZUluTVM6IDZlNFxufSk7XG5mdW5jdGlvbiB2ZXJpZnlTaWduYXR1cmUocGVyc2lzdCkge1xuICBpZiAodHlwZW9mIHRoaXMuc2lnbmF0dXJlVmVyaWZpZWQgPT09IFwiYm9vbGVhblwiKSByZXR1cm4gdGhpcy5zaWduYXR1cmVWZXJpZmllZDtcbiAgY29uc3QgcHJldlZlcmlmaWNhdGlvbiA9IHZlcmlmaWVkU2lnbmF0dXJlcy5nZXQodGhpcy5pZCk7XG4gIGlmIChwcmV2VmVyaWZpY2F0aW9uICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuc2lnbmF0dXJlVmVyaWZpZWQgPSAhIXByZXZWZXJpZmljYXRpb247XG4gIH1cbiAgdHJ5IHtcbiAgICBpZiAodGhpcy5uZGs/LmFzeW5jU2lnVmVyaWZpY2F0aW9uKSB7XG4gICAgICB2ZXJpZnlTaWduYXR1cmVBc3luYyh0aGlzLCBwZXJzaXN0KS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgaWYgKHBlcnNpc3QpIHtcbiAgICAgICAgICB0aGlzLnNpZ25hdHVyZVZlcmlmaWVkID0gcmVzdWx0O1xuICAgICAgICAgIGlmIChyZXN1bHQpIHZlcmlmaWVkU2lnbmF0dXJlcy5zZXQodGhpcy5pZCwgdGhpcy5zaWcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgdGhpcy5uZGsuZW1pdChcImV2ZW50OmludmFsaWQtc2lnXCIsIHRoaXMpO1xuICAgICAgICAgIHZlcmlmaWVkU2lnbmF0dXJlcy5zZXQodGhpcy5pZCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaGFzaCA9IHNoYTI1NihuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUodGhpcy5zZXJpYWxpemUoKSkpO1xuICAgICAgY29uc3QgcmVzID0gc2Nobm9yci52ZXJpZnkodGhpcy5zaWcsIGhhc2gsIHRoaXMucHVia2V5KTtcbiAgICAgIGlmIChyZXMpIHZlcmlmaWVkU2lnbmF0dXJlcy5zZXQodGhpcy5pZCwgdGhpcy5zaWcpO1xuICAgICAgZWxzZSB2ZXJpZmllZFNpZ25hdHVyZXMuc2V0KHRoaXMuaWQsIGZhbHNlKTtcbiAgICAgIHJldHVybiB0aGlzLnNpZ25hdHVyZVZlcmlmaWVkID0gcmVzO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIHRoaXMuc2lnbmF0dXJlVmVyaWZpZWQgPSBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0RXZlbnRIYXNoKCkge1xuICByZXR1cm4gZ2V0RXZlbnRIYXNoRnJvbVNlcmlhbGl6ZWRFdmVudCh0aGlzLnNlcmlhbGl6ZSgpKTtcbn1cbmZ1bmN0aW9uIGdldEV2ZW50SGFzaEZyb21TZXJpYWxpemVkRXZlbnQoc2VyaWFsaXplZEV2ZW50KSB7XG4gIGNvbnN0IGV2ZW50SGFzaCA9IHNoYTI1NihuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc2VyaWFsaXplZEV2ZW50KSk7XG4gIHJldHVybiBieXRlc1RvSGV4KGV2ZW50SGFzaCk7XG59XG5cbi8vIHNyYy9ldmVudHMvaW5kZXgudHNcbnZhciBza2lwQ2xpZW50VGFnT25LaW5kcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcbiAgMCAvKiBNZXRhZGF0YSAqLyxcbiAgNCAvKiBFbmNyeXB0ZWREaXJlY3RNZXNzYWdlICovLFxuICAxMDU5IC8qIEdpZnRXcmFwICovLFxuICAxMyAvKiBHaWZ0V3JhcFNlYWwgKi8sXG4gIDMgLyogQ29udGFjdHMgKi8sXG4gIDk3MzQgLyogWmFwUmVxdWVzdCAqLyxcbiAgNSAvKiBFdmVudERlbGV0aW9uICovXG5dKTtcbnZhciBOREtFdmVudCA9IGNsYXNzIF9OREtFdmVudCBleHRlbmRzIEV2ZW50RW1pdHRlcjIge1xuICBuZGs7XG4gIGNyZWF0ZWRfYXQ7XG4gIGNvbnRlbnQgPSBcIlwiO1xuICB0YWdzID0gW107XG4gIGtpbmQ7XG4gIGlkID0gXCJcIjtcbiAgc2lnO1xuICBwdWJrZXkgPSBcIlwiO1xuICBzaWduYXR1cmVWZXJpZmllZDtcbiAgX2F1dGhvciA9IHZvaWQgMDtcbiAgLyoqXG4gICAqIFRoZSByZWxheSB0aGF0IHRoaXMgZXZlbnQgd2FzIGZpcnN0IHJlY2VpdmVkIGZyb20uXG4gICAqL1xuICByZWxheTtcbiAgLyoqXG4gICAqIFRoZSByZWxheXMgdGhhdCB0aGlzIGV2ZW50IHdhcyByZWNlaXZlZCBmcm9tIGFuZC9vciBzdWNjZXNzZnVsbHkgcHVibGlzaGVkIHRvLlxuICAgKi9cbiAgZ2V0IG9uUmVsYXlzKCkge1xuICAgIGxldCByZXMgPSBbXTtcbiAgICBpZiAoIXRoaXMubmRrKSB7XG4gICAgICBpZiAodGhpcy5yZWxheSkgcmVzLnB1c2godGhpcy5yZWxheSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcyA9IHRoaXMubmRrLnN1Yk1hbmFnZXIuc2VlbkV2ZW50cy5nZXQodGhpcy5pZCkgfHwgW107XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBzdGF0dXMgb2YgdGhlIHB1Ymxpc2ggb3BlcmF0aW9uLlxuICAgKi9cbiAgcHVibGlzaFN0YXR1cyA9IFwic3VjY2Vzc1wiO1xuICBwdWJsaXNoRXJyb3I7XG4gIGNvbnN0cnVjdG9yKG5kaywgZXZlbnQpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubmRrID0gbmRrO1xuICAgIHRoaXMuY3JlYXRlZF9hdCA9IGV2ZW50Py5jcmVhdGVkX2F0O1xuICAgIHRoaXMuY29udGVudCA9IGV2ZW50Py5jb250ZW50IHx8IFwiXCI7XG4gICAgdGhpcy50YWdzID0gZXZlbnQ/LnRhZ3MgfHwgW107XG4gICAgdGhpcy5pZCA9IGV2ZW50Py5pZCB8fCBcIlwiO1xuICAgIHRoaXMuc2lnID0gZXZlbnQ/LnNpZztcbiAgICB0aGlzLnB1YmtleSA9IGV2ZW50Py5wdWJrZXkgfHwgXCJcIjtcbiAgICB0aGlzLmtpbmQgPSBldmVudD8ua2luZDtcbiAgICBpZiAoZXZlbnQgaW5zdGFuY2VvZiBfTkRLRXZlbnQpIHtcbiAgICAgIGlmICh0aGlzLnJlbGF5KSB7XG4gICAgICAgIHRoaXMucmVsYXkgPSBldmVudC5yZWxheTtcbiAgICAgICAgdGhpcy5uZGs/LnN1Yk1hbmFnZXIuc2VlbkV2ZW50KGV2ZW50LmlkLCB0aGlzLnJlbGF5KTtcbiAgICAgIH1cbiAgICAgIHRoaXMucHVibGlzaFN0YXR1cyA9IGV2ZW50LnB1Ymxpc2hTdGF0dXM7XG4gICAgICB0aGlzLnB1Ymxpc2hFcnJvciA9IGV2ZW50LnB1Ymxpc2hFcnJvcjtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIERlc2VyaWFsaXplIGFuIE5ES0V2ZW50IGZyb20gYSBzZXJpYWxpemVkIHBheWxvYWQuXG4gICAqIEBwYXJhbSBuZGtcbiAgICogQHBhcmFtIGV2ZW50XG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBzdGF0aWMgZGVzZXJpYWxpemUobmRrLCBldmVudCkge1xuICAgIHJldHVybiBuZXcgX05ES0V2ZW50KG5kaywgZGVzZXJpYWxpemUoZXZlbnQpKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZXZlbnQgYXMgaXMuXG4gICAqL1xuICByYXdFdmVudCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY3JlYXRlZF9hdDogdGhpcy5jcmVhdGVkX2F0LFxuICAgICAgY29udGVudDogdGhpcy5jb250ZW50LFxuICAgICAgdGFnczogdGhpcy50YWdzLFxuICAgICAga2luZDogdGhpcy5raW5kLFxuICAgICAgcHVia2V5OiB0aGlzLnB1YmtleSxcbiAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgc2lnOiB0aGlzLnNpZ1xuICAgIH07XG4gIH1cbiAgc2V0IGF1dGhvcih1c2VyKSB7XG4gICAgdGhpcy5wdWJrZXkgPSB1c2VyLnB1YmtleTtcbiAgICB0aGlzLl9hdXRob3IgPSB1c2VyO1xuICAgIHRoaXMuX2F1dGhvci5uZGsgPz89IHRoaXMubmRrO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIE5ES1VzZXIgZm9yIHRoZSBhdXRob3Igb2YgdGhlIGV2ZW50LlxuICAgKi9cbiAgZ2V0IGF1dGhvcigpIHtcbiAgICBpZiAodGhpcy5fYXV0aG9yKSByZXR1cm4gdGhpcy5fYXV0aG9yO1xuICAgIGlmICghdGhpcy5uZGspIHRocm93IG5ldyBFcnJvcihcIk5vIE5ESyBpbnN0YW5jZSBmb3VuZFwiKTtcbiAgICBjb25zdCB1c2VyID0gdGhpcy5uZGsuZ2V0VXNlcih7IHB1YmtleTogdGhpcy5wdWJrZXkgfSk7XG4gICAgdGhpcy5fYXV0aG9yID0gdXNlcjtcbiAgICByZXR1cm4gdXNlcjtcbiAgfVxuICAvKipcbiAgICogTklQLTczIHRhZ2dpbmcgb2YgZXh0ZXJuYWwgZW50aXRpZXNcbiAgICogQHBhcmFtIGVudGl0eSB0byBiZSB0YWdnZWRcbiAgICogQHBhcmFtIHR5cGUgb2YgdGhlIGVudGl0eVxuICAgKiBAcGFyYW0gbWFya2VyVXJsIHRvIGJlIHVzZWQgYXMgdGhlIG1hcmtlciBVUkxcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBldmVudC50YWdFeHRlcm5hbChcImh0dHBzOi8vZXhhbXBsZS5jb20vYXJ0aWNsZS8xMjMjbm9zdHJcIiwgXCJ1cmxcIik7XG4gICAqIGV2ZW50LnRhZ3MgPT4gW1tcImlcIiwgXCJodHRwczovL2V4YW1wbGUuY29tLzEyM1wiXSwgW1wia1wiLCBcImh0dHBzOi8vZXhhbXBsZS5jb21cIl1dXG4gICAqIGBgYFxuICAgKlxuICAgKiBAZXhhbXBsZSB0YWcgYSBwb2RjYXN0Oml0ZW06Z3VpZFxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGV2ZW50LnRhZ0V4dGVybmFsKFwiZTMyYjQ4OTAtYjllYS00YWVmLWEwYmYtNTRiNzg3ODMzZGM1XCIsIFwicG9kY2FzdDppdGVtOmd1aWRcIik7XG4gICAqIGV2ZW50LnRhZ3MgPT4gW1tcImlcIiwgXCJwb2RjYXN0Oml0ZW06Z3VpZDplMzJiNDg5MC1iOWVhLTRhZWYtYTBiZi01NGI3ODc4MzNkYzVcIl0sIFtcImtcIiwgXCJwb2RjYXN0Oml0ZW06Z3VpZFwiXV1cbiAgICogYGBgXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL25vc3RyLXByb3RvY29sL25pcHMvYmxvYi9tYXN0ZXIvNzMubWRcbiAgICovXG4gIHRhZ0V4dGVybmFsKGVudGl0eSwgdHlwZSwgbWFya2VyVXJsKSB7XG4gICAgbGV0IGlUYWcgPSBbXCJpXCJdO1xuICAgIGxldCBrVGFnID0gW1wia1wiXTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgXCJ1cmxcIjpcbiAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChlbnRpdHkpO1xuICAgICAgICB1cmwuaGFzaCA9IFwiXCI7XG4gICAgICAgIGlUYWcucHVzaCh1cmwudG9TdHJpbmcoKSk7XG4gICAgICAgIGtUYWcucHVzaChgJHt1cmwucHJvdG9jb2x9Ly8ke3VybC5ob3N0fWApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJoYXNodGFnXCI6XG4gICAgICAgIGlUYWcucHVzaChgIyR7ZW50aXR5LnRvTG93ZXJDYXNlKCl9YCk7XG4gICAgICAgIGtUYWcucHVzaChcIiNcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImdlb2hhc2hcIjpcbiAgICAgICAgaVRhZy5wdXNoKGBnZW86JHtlbnRpdHkudG9Mb3dlckNhc2UoKX1gKTtcbiAgICAgICAga1RhZy5wdXNoKFwiZ2VvXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJpc2JuXCI6XG4gICAgICAgIGlUYWcucHVzaChgaXNibjoke2VudGl0eS5yZXBsYWNlKC8tL2csIFwiXCIpfWApO1xuICAgICAgICBrVGFnLnB1c2goXCJpc2JuXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJwb2RjYXN0Omd1aWRcIjpcbiAgICAgICAgaVRhZy5wdXNoKGBwb2RjYXN0Omd1aWQ6JHtlbnRpdHl9YCk7XG4gICAgICAgIGtUYWcucHVzaChcInBvZGNhc3Q6Z3VpZFwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwicG9kY2FzdDppdGVtOmd1aWRcIjpcbiAgICAgICAgaVRhZy5wdXNoKGBwb2RjYXN0Oml0ZW06Z3VpZDoke2VudGl0eX1gKTtcbiAgICAgICAga1RhZy5wdXNoKFwicG9kY2FzdDppdGVtOmd1aWRcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInBvZGNhc3Q6cHVibGlzaGVyOmd1aWRcIjpcbiAgICAgICAgaVRhZy5wdXNoKGBwb2RjYXN0OnB1Ymxpc2hlcjpndWlkOiR7ZW50aXR5fWApO1xuICAgICAgICBrVGFnLnB1c2goXCJwb2RjYXN0OnB1Ymxpc2hlcjpndWlkXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJpc2FuXCI6XG4gICAgICAgIGlUYWcucHVzaChgaXNhbjoke2VudGl0eS5zcGxpdChcIi1cIikuc2xpY2UoMCwgNCkuam9pbihcIi1cIil9YCk7XG4gICAgICAgIGtUYWcucHVzaChcImlzYW5cIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImRvaVwiOlxuICAgICAgICBpVGFnLnB1c2goYGRvaToke2VudGl0eS50b0xvd2VyQ2FzZSgpfWApO1xuICAgICAgICBrVGFnLnB1c2goXCJkb2lcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBOSVAtNzMgZW50aXR5IHR5cGU6ICR7dHlwZX1gKTtcbiAgICB9XG4gICAgaWYgKG1hcmtlclVybCkge1xuICAgICAgaVRhZy5wdXNoKG1hcmtlclVybCk7XG4gICAgfVxuICAgIHRoaXMudGFncy5wdXNoKGlUYWcpO1xuICAgIHRoaXMudGFncy5wdXNoKGtUYWcpO1xuICB9XG4gIC8qKlxuICAgKiBUYWcgYSB1c2VyIHdpdGggYW4gb3B0aW9uYWwgbWFya2VyLlxuICAgKiBAcGFyYW0gdGFyZ2V0IFdoYXQgaXMgdG8gYmUgdGFnZ2VkLiBDYW4gYmUgYW4gTkRLVXNlciwgTkRLRXZlbnQsIG9yIGFuIE5ES1RhZy5cbiAgICogQHBhcmFtIG1hcmtlciBUaGUgbWFya2VyIHRvIHVzZSBpbiB0aGUgdGFnLlxuICAgKiBAcGFyYW0gc2tpcEF1dGhvclRhZyBXaGV0aGVyIHRvIGV4cGxpY2l0bHkgc2tpcCBhZGRpbmcgdGhlIGF1dGhvciB0YWcgb2YgdGhlIGV2ZW50LlxuICAgKiBAcGFyYW0gZm9yY2VUYWcgRm9yY2UgYSBzcGVjaWZpYyB0YWcgdG8gYmUgdXNlZCBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IFwiZVwiIG9yIFwiYVwiIHRhZy5cbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiByZXBseS50YWcob3BFdmVudCwgXCJyZXBseVwiKTtcbiAgICogLy8gcmVwbHkudGFncyA9PiBbW1wiZVwiLCA8aWQ+LCA8cmVsYXk+LCBcInJlcGx5XCJdXVxuICAgKiBgYGBcbiAgICovXG4gIHRhZyh0YXJnZXQsIG1hcmtlciwgc2tpcEF1dGhvclRhZywgZm9yY2VUYWcpIHtcbiAgICBsZXQgdGFncyA9IFtdO1xuICAgIGNvbnN0IGlzTkRLVXNlciA9IHRhcmdldC5mZXRjaFByb2ZpbGUgIT09IHZvaWQgMDtcbiAgICBpZiAoaXNOREtVc2VyKSB7XG4gICAgICBmb3JjZVRhZyA/Pz0gXCJwXCI7XG4gICAgICBjb25zdCB0YWcgPSBbZm9yY2VUYWcsIHRhcmdldC5wdWJrZXldO1xuICAgICAgaWYgKG1hcmtlcikgdGFnLnB1c2goLi4uW1wiXCIsIG1hcmtlcl0pO1xuICAgICAgdGFncy5wdXNoKHRhZyk7XG4gICAgfSBlbHNlIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBfTkRLRXZlbnQpIHtcbiAgICAgIGNvbnN0IGV2ZW50ID0gdGFyZ2V0O1xuICAgICAgc2tpcEF1dGhvclRhZyA/Pz0gZXZlbnQ/LnB1YmtleSA9PT0gdGhpcy5wdWJrZXk7XG4gICAgICB0YWdzID0gZXZlbnQucmVmZXJlbmNlVGFncyhtYXJrZXIsIHNraXBBdXRob3JUYWcsIGZvcmNlVGFnKTtcbiAgICAgIGZvciAoY29uc3QgcFRhZyBvZiBldmVudC5nZXRNYXRjaGluZ1RhZ3MoXCJwXCIpKSB7XG4gICAgICAgIGlmIChwVGFnWzFdID09PSB0aGlzLnB1YmtleSkgY29udGludWU7XG4gICAgICAgIGlmICh0aGlzLnRhZ3MuZmluZCgodCkgPT4gdFswXSA9PT0gXCJwXCIgJiYgdFsxXSA9PT0gcFRhZ1sxXSkpIGNvbnRpbnVlO1xuICAgICAgICB0aGlzLnRhZ3MucHVzaChbXCJwXCIsIHBUYWdbMV1dKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSkge1xuICAgICAgdGFncyA9IFt0YXJnZXRdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50XCIsIHRhcmdldCk7XG4gICAgfVxuICAgIHRoaXMudGFncyA9IG1lcmdlVGFncyh0aGlzLnRhZ3MsIHRhZ3MpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gYSBOb3N0ckV2ZW50IG9iamVjdCwgdHJ5aW5nIHRvIGZpbGwgaW4gbWlzc2luZyBmaWVsZHNcbiAgICogd2hlbiBwb3NzaWJsZSwgYWRkaW5nIHRhZ3Mgd2hlbiBuZWNlc3NhcnkuXG4gICAqIEBwYXJhbSBwdWJrZXkge3N0cmluZ30gVGhlIHB1YmtleSBvZiB0aGUgdXNlciB3aG8gdGhlIGV2ZW50IGJlbG9uZ3MgdG8uXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE5vc3RyRXZlbnQ+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIE5vc3RyRXZlbnQuXG4gICAqL1xuICBhc3luYyB0b05vc3RyRXZlbnQocHVia2V5KSB7XG4gICAgaWYgKCFwdWJrZXkgJiYgdGhpcy5wdWJrZXkgPT09IFwiXCIpIHtcbiAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLm5kaz8uc2lnbmVyPy51c2VyKCk7XG4gICAgICB0aGlzLnB1YmtleSA9IHVzZXI/LnB1YmtleSB8fCBcIlwiO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuY3JlYXRlZF9hdCkge1xuICAgICAgdGhpcy5jcmVhdGVkX2F0ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMWUzKTtcbiAgICB9XG4gICAgY29uc3QgeyBjb250ZW50LCB0YWdzIH0gPSBhd2FpdCB0aGlzLmdlbmVyYXRlVGFncygpO1xuICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQgfHwgXCJcIjtcbiAgICB0aGlzLnRhZ3MgPSB0YWdzO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmlkID0gdGhpcy5nZXRFdmVudEhhc2goKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJhd0V2ZW50KCk7XG4gIH1cbiAgc2VyaWFsaXplID0gc2VyaWFsaXplLmJpbmQodGhpcyk7XG4gIGdldEV2ZW50SGFzaCA9IGdldEV2ZW50SGFzaC5iaW5kKHRoaXMpO1xuICB2YWxpZGF0ZSA9IHZhbGlkYXRlLmJpbmQodGhpcyk7XG4gIHZlcmlmeVNpZ25hdHVyZSA9IHZlcmlmeVNpZ25hdHVyZS5iaW5kKHRoaXMpO1xuICAvKipcbiAgICogSXMgdGhpcyBldmVudCByZXBsYWNlYWJsZSAod2hldGhlciBwYXJhbWV0ZXJpemVkIG9yIG5vdCk/XG4gICAqXG4gICAqIFRoaXMgd2lsbCByZXR1cm4gdHJ1ZSBmb3Iga2luZCAwLCAzLCAxMGstMjBrIGFuZCAzMGstNDBrXG4gICAqL1xuICBpc1JlcGxhY2VhYmxlID0gaXNSZXBsYWNlYWJsZS5iaW5kKHRoaXMpO1xuICBpc0VwaGVtZXJhbCA9IGlzRXBoZW1lcmFsLmJpbmQodGhpcyk7XG4gIGlzRHZtID0gKCkgPT4gdGhpcy5raW5kICYmIHRoaXMua2luZCA+PSA1ZTMgJiYgdGhpcy5raW5kIDw9IDdlMztcbiAgLyoqXG4gICAqIElzIHRoaXMgZXZlbnQgcGFyYW1ldGVyaXplZCByZXBsYWNlYWJsZT9cbiAgICpcbiAgICogVGhpcyB3aWxsIHJldHVybiB0cnVlIGZvciBraW5kIDMway00MGtcbiAgICovXG4gIGlzUGFyYW1SZXBsYWNlYWJsZSA9IGlzUGFyYW1SZXBsYWNlYWJsZS5iaW5kKHRoaXMpO1xuICAvKipcbiAgICogRW5jb2RlcyBhIGJlY2gzMiBpZC5cbiAgICpcbiAgICogQHBhcmFtIHJlbGF5cyB7c3RyaW5nW119IFRoZSByZWxheXMgdG8gZW5jb2RlIGluIHRoZSBpZFxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIEVuY29kZWQgbmFkZHIsIG5vdGUgb3IgbmV2ZW50LlxuICAgKi9cbiAgZW5jb2RlID0gZW5jb2RlLmJpbmQodGhpcyk7XG4gIGVuY3J5cHQgPSBlbmNyeXB0LmJpbmQodGhpcyk7XG4gIGRlY3J5cHQgPSBkZWNyeXB0LmJpbmQodGhpcyk7XG4gIC8qKlxuICAgKiBHZXQgYWxsIHRhZ3Mgd2l0aCB0aGUgZ2l2ZW4gbmFtZVxuICAgKiBAcGFyYW0gdGFnTmFtZSB7c3RyaW5nfSBUaGUgbmFtZSBvZiB0aGUgdGFnIHRvIHNlYXJjaCBmb3JcbiAgICogQHJldHVybnMge05ES1RhZ1tdfSBBbiBhcnJheSBvZiB0aGUgbWF0Y2hpbmcgdGFnc1xuICAgKi9cbiAgZ2V0TWF0Y2hpbmdUYWdzKHRhZ05hbWUsIG1hcmtlcikge1xuICAgIGNvbnN0IHQgPSB0aGlzLnRhZ3MuZmlsdGVyKCh0YWcpID0+IHRhZ1swXSA9PT0gdGFnTmFtZSk7XG4gICAgaWYgKG1hcmtlciA9PT0gdm9pZCAwKSByZXR1cm4gdDtcbiAgICByZXR1cm4gdC5maWx0ZXIoKHRhZykgPT4gdGFnWzNdID09PSBtYXJrZXIpO1xuICB9XG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgZXZlbnQgaGFzIGEgdGFnIHdpdGggdGhlIGdpdmVuIG5hbWVcbiAgICogQHBhcmFtIHRhZ05hbWVcbiAgICogQHBhcmFtIG1hcmtlclxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgaGFzVGFnKHRhZ05hbWUsIG1hcmtlcikge1xuICAgIHJldHVybiB0aGlzLnRhZ3Muc29tZSgodGFnKSA9PiB0YWdbMF0gPT09IHRhZ05hbWUgJiYgKCFtYXJrZXIgfHwgdGFnWzNdID09PSBtYXJrZXIpKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBmaXJzdCB0YWcgd2l0aCB0aGUgZ2l2ZW4gbmFtZVxuICAgKiBAcGFyYW0gdGFnTmFtZSBUYWcgbmFtZSB0byBzZWFyY2ggZm9yXG4gICAqIEByZXR1cm5zIFRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgdGFnIHdpdGggdGhlIGdpdmVuIG5hbWUsIG9yIHVuZGVmaW5lZCBpZiBubyBzdWNoIHRhZyBleGlzdHNcbiAgICovXG4gIHRhZ1ZhbHVlKHRhZ05hbWUpIHtcbiAgICBjb25zdCB0YWdzID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3ModGFnTmFtZSk7XG4gICAgaWYgKHRhZ3MubGVuZ3RoID09PSAwKSByZXR1cm4gdm9pZCAwO1xuICAgIHJldHVybiB0YWdzWzBdWzFdO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBOSVAtMzEgXCJhbHRcIiB0YWcgb2YgdGhlIGV2ZW50LlxuICAgKi9cbiAgZ2V0IGFsdCgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcImFsdFwiKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgTklQLTMxIFwiYWx0XCIgdGFnIG9mIHRoZSBldmVudC4gVXNlIHRoaXMgdG8gc2V0IGFuIGFsdCB0YWcgc29cbiAgICogY2xpZW50cyB0aGF0IGRvbid0IGhhbmRsZSBhIHBhcnRpY3VsYXIgZXZlbnQga2luZCBjYW4gZGlzcGxheSBzb21ldGhpbmdcbiAgICogdXNlZnVsIGZvciB1c2Vycy5cbiAgICovXG4gIHNldCBhbHQoYWx0KSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJhbHRcIik7XG4gICAgaWYgKGFsdCkgdGhpcy50YWdzLnB1c2goW1wiYWx0XCIsIGFsdF0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBOSVAtMzMgXCJkXCIgdGFnIG9mIHRoZSBldmVudC5cbiAgICovXG4gIGdldCBkVGFnKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwiZFwiKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgTklQLTMzIFwiZFwiIHRhZyBvZiB0aGUgZXZlbnQuXG4gICAqL1xuICBzZXQgZFRhZyh2YWx1ZSkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwiZFwiKTtcbiAgICBpZiAodmFsdWUpIHRoaXMudGFncy5wdXNoKFtcImRcIiwgdmFsdWVdKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIGFsbCB0YWdzIHdpdGggdGhlIGdpdmVuIG5hbWUgKGUuZy4gXCJkXCIsIFwiYVwiLCBcInBcIilcbiAgICogQHBhcmFtIHRhZ05hbWUgVGFnIG5hbWUocykgdG8gc2VhcmNoIGZvciBhbmQgcmVtb3ZlXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgcmVtb3ZlVGFnKHRhZ05hbWUpIHtcbiAgICBjb25zdCB0YWdOYW1lcyA9IEFycmF5LmlzQXJyYXkodGFnTmFtZSkgPyB0YWdOYW1lIDogW3RhZ05hbWVdO1xuICAgIHRoaXMudGFncyA9IHRoaXMudGFncy5maWx0ZXIoKHRhZykgPT4gIXRhZ05hbWVzLmluY2x1ZGVzKHRhZ1swXSkpO1xuICB9XG4gIC8qKlxuICAgKiBTaWduIHRoZSBldmVudCBpZiBhIHNpZ25lciBpcyBwcmVzZW50LlxuICAgKlxuICAgKiBJdCB3aWxsIGdlbmVyYXRlIHRhZ3MuXG4gICAqIFJlcGxlYWNhYmxlIGV2ZW50cyB3aWxsIGhhdmUgdGhlaXIgY3JlYXRlZF9hdCBmaWVsZCBzZXQgdG8gdGhlIGN1cnJlbnQgdGltZS5cbiAgICogQHBhcmFtIHNpZ25lciB7TkRLU2lnbmVyfSBUaGUgTkRLU2lnbmVyIHRvIHVzZSB0byBzaWduIHRoZSBldmVudFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgc2lnbmF0dXJlIG9mIHRoZSBzaWduZWQgZXZlbnQuXG4gICAqL1xuICBhc3luYyBzaWduKHNpZ25lcikge1xuICAgIGlmICghc2lnbmVyKSB7XG4gICAgICB0aGlzLm5kaz8uYXNzZXJ0U2lnbmVyKCk7XG4gICAgICBzaWduZXIgPSB0aGlzLm5kay5zaWduZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXV0aG9yID0gYXdhaXQgc2lnbmVyLnVzZXIoKTtcbiAgICB9XG4gICAgY29uc3Qgbm9zdHJFdmVudCA9IGF3YWl0IHRoaXMudG9Ob3N0ckV2ZW50KCk7XG4gICAgdGhpcy5zaWcgPSBhd2FpdCBzaWduZXIuc2lnbihub3N0ckV2ZW50KTtcbiAgICByZXR1cm4gdGhpcy5zaWc7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSByZWxheVNldFxuICAgKiBAcGFyYW0gdGltZW91dE1zXG4gICAqIEBwYXJhbSByZXF1aXJlZFJlbGF5Q291bnRcbiAgICogQHJldHVybnNcbiAgICovXG4gIGFzeW5jIHB1Ymxpc2hSZXBsYWNlYWJsZShyZWxheVNldCwgdGltZW91dE1zLCByZXF1aXJlZFJlbGF5Q291bnQpIHtcbiAgICB0aGlzLmlkID0gXCJcIjtcbiAgICB0aGlzLmNyZWF0ZWRfYXQgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxZTMpO1xuICAgIHRoaXMuc2lnID0gXCJcIjtcbiAgICByZXR1cm4gdGhpcy5wdWJsaXNoKHJlbGF5U2V0LCB0aW1lb3V0TXMsIHJlcXVpcmVkUmVsYXlDb3VudCk7XG4gIH1cbiAgLyoqXG4gICAqIEF0dGVtcHQgdG8gc2lnbiBhbmQgdGhlbiBwdWJsaXNoIGFuIE5ES0V2ZW50IHRvIGEgZ2l2ZW4gcmVsYXlTZXQuXG4gICAqIElmIG5vIHJlbGF5U2V0IGlzIHByb3ZpZGVkLCB0aGUgcmVsYXlTZXQgd2lsbCBiZSBjYWxjdWxhdGVkIGJ5IE5ESy5cbiAgICogQHBhcmFtIHJlbGF5U2V0IHtOREtSZWxheVNldH0gVGhlIHJlbGF5U2V0IHRvIHB1Ymxpc2ggdGhlIGV2ZW4gdG8uXG4gICAqIEBwYXJhbSB0aW1lb3V0TSB7bnVtYmVyfSBUaGUgdGltZW91dCBmb3IgdGhlIHB1Ymxpc2ggb3BlcmF0aW9uIGluIG1pbGxpc2Vjb25kcy5cbiAgICogQHBhcmFtIHJlcXVpcmVkUmVsYXlDb3VudCBUaGUgbnVtYmVyIG9mIHJlbGF5cyB0aGF0IG11c3QgcmVjZWl2ZSB0aGUgZXZlbnQgZm9yIHRoZSBwdWJsaXNoIHRvIGJlIGNvbnNpZGVyZWQgc3VjY2Vzc2Z1bC5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHJlbGF5cyB0aGUgZXZlbnQgd2FzIHB1Ymxpc2hlZCB0by5cbiAgICovXG4gIGFzeW5jIHB1Ymxpc2gocmVsYXlTZXQsIHRpbWVvdXRNcywgcmVxdWlyZWRSZWxheUNvdW50KSB7XG4gICAgaWYgKCF0aGlzLnNpZykgYXdhaXQgdGhpcy5zaWduKCk7XG4gICAgaWYgKCF0aGlzLm5kaylcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5ES0V2ZW50IG11c3QgYmUgYXNzb2NpYXRlZCB3aXRoIGFuIE5ESyBpbnN0YW5jZSB0byBwdWJsaXNoXCIpO1xuICAgIGlmICghcmVsYXlTZXQpIHtcbiAgICAgIHJlbGF5U2V0ID0gdGhpcy5uZGsuZGV2V3JpdGVSZWxheVNldCB8fCBhd2FpdCBjYWxjdWxhdGVSZWxheVNldEZyb21FdmVudCh0aGlzLm5kaywgdGhpcyk7XG4gICAgfVxuICAgIGlmICh0aGlzLmtpbmQgPT09IDUgLyogRXZlbnREZWxldGlvbiAqLyAmJiB0aGlzLm5kay5jYWNoZUFkYXB0ZXI/LmRlbGV0ZUV2ZW50SWRzKSB7XG4gICAgICBjb25zdCBlVGFncyA9IHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwiZVwiKS5tYXAoKHRhZykgPT4gdGFnWzFdKTtcbiAgICAgIHRoaXMubmRrLmNhY2hlQWRhcHRlci5kZWxldGVFdmVudElkcyhlVGFncyk7XG4gICAgfVxuICAgIGNvbnN0IHJhd0V2ZW50ID0gdGhpcy5yYXdFdmVudCgpO1xuICAgIGlmICh0aGlzLm5kay5jYWNoZUFkYXB0ZXI/LmFkZFVucHVibGlzaGVkRXZlbnQgJiYgc2hvdWxkVHJhY2tVbnB1Ymxpc2hlZEV2ZW50KHRoaXMpKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLm5kay5jYWNoZUFkYXB0ZXIuYWRkVW5wdWJsaXNoZWRFdmVudCh0aGlzLCByZWxheVNldC5yZWxheVVybHMpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgYWRkaW5nIHVucHVibGlzaGVkIGV2ZW50IHRvIGNhY2hlXCIsIGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5raW5kID09PSA1IC8qIEV2ZW50RGVsZXRpb24gKi8gJiYgdGhpcy5uZGsuY2FjaGVBZGFwdGVyPy5kZWxldGVFdmVudElkcykge1xuICAgICAgdGhpcy5uZGsuY2FjaGVBZGFwdGVyLmRlbGV0ZUV2ZW50SWRzKHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwiZVwiKS5tYXAoKHRhZykgPT4gdGFnWzFdKSk7XG4gICAgfVxuICAgIHRoaXMubmRrLnN1Yk1hbmFnZXIuZGlzcGF0Y2hFdmVudChyYXdFdmVudCwgdm9pZCAwLCB0cnVlKTtcbiAgICBjb25zdCByZWxheXMgPSBhd2FpdCByZWxheVNldC5wdWJsaXNoKHRoaXMsIHRpbWVvdXRNcywgcmVxdWlyZWRSZWxheUNvdW50KTtcbiAgICByZWxheXMuZm9yRWFjaCgocmVsYXkpID0+IHRoaXMubmRrPy5zdWJNYW5hZ2VyLnNlZW5FdmVudCh0aGlzLmlkLCByZWxheSkpO1xuICAgIHJldHVybiByZWxheXM7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyB0YWdzIGZvciB1c2Vycywgbm90ZXMsIGFuZCBvdGhlciBldmVudHMgdGFnZ2VkIGluIGNvbnRlbnQuXG4gICAqIFdpbGwgYWxzbyBnZW5lcmF0ZSByYW5kb20gXCJkXCIgdGFnIGZvciBwYXJhbWV0ZXJpemVkIHJlcGxhY2VhYmxlIGV2ZW50cyB3aGVyZSBuZWVkZWQuXG4gICAqIEByZXR1cm5zIHtDb250ZW50VGFnfSBUaGUgdGFncyBhbmQgY29udGVudCBvZiB0aGUgZXZlbnQuXG4gICAqL1xuICBhc3luYyBnZW5lcmF0ZVRhZ3MoKSB7XG4gICAgbGV0IHRhZ3MgPSBbXTtcbiAgICBjb25zdCBnID0gYXdhaXQgZ2VuZXJhdGVDb250ZW50VGFncyh0aGlzLmNvbnRlbnQsIHRoaXMudGFncyk7XG4gICAgY29uc3QgY29udGVudCA9IGcuY29udGVudDtcbiAgICB0YWdzID0gZy50YWdzO1xuICAgIGlmICh0aGlzLmtpbmQgJiYgdGhpcy5pc1BhcmFtUmVwbGFjZWFibGUoKSkge1xuICAgICAgY29uc3QgZFRhZyA9IHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwiZFwiKVswXTtcbiAgICAgIGlmICghZFRhZykge1xuICAgICAgICBjb25zdCB0aXRsZSA9IHRoaXMudGFnVmFsdWUoXCJ0aXRsZVwiKTtcbiAgICAgICAgY29uc3QgcmFuZExlbmd0aCA9IHRpdGxlID8gNiA6IDE2O1xuICAgICAgICBsZXQgc3RyID0gWy4uLkFycmF5KHJhbmRMZW5ndGgpXS5tYXAoKCkgPT4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNilbMl0pLmpvaW4oXCJcIik7XG4gICAgICAgIGlmICh0aXRsZSAmJiB0aXRsZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgc3RyID0gdGl0bGUucmVwbGFjZSgvW15hLXowLTldKy9naSwgXCItXCIpLnJlcGxhY2UoL14tfC0kL2csIFwiXCIpICsgXCItXCIgKyBzdHI7XG4gICAgICAgIH1cbiAgICAgICAgdGFncy5wdXNoKFtcImRcIiwgc3RyXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLnNob3VsZEFkZENsaWVudFRhZykge1xuICAgICAgY29uc3QgY2xpZW50VGFnID0gW1wiY2xpZW50XCIsIHRoaXMubmRrLmNsaWVudE5hbWUgPz8gXCJcIl07XG4gICAgICBpZiAodGhpcy5uZGsuY2xpZW50TmlwODkpIGNsaWVudFRhZy5wdXNoKHRoaXMubmRrLmNsaWVudE5pcDg5KTtcbiAgICAgIHRhZ3MucHVzaChjbGllbnRUYWcpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zaG91bGRTdHJpcENsaWVudFRhZykge1xuICAgICAgdGFncyA9IHRhZ3MuZmlsdGVyKCh0YWcpID0+IHRhZ1swXSAhPT0gXCJjbGllbnRcIik7XG4gICAgfVxuICAgIHJldHVybiB7IGNvbnRlbnQ6IGNvbnRlbnQgfHwgXCJcIiwgdGFncyB9O1xuICB9XG4gIGdldCBzaG91bGRBZGRDbGllbnRUYWcoKSB7XG4gICAgaWYgKCF0aGlzLm5kaz8uY2xpZW50TmFtZSAmJiAhdGhpcy5uZGs/LmNsaWVudE5pcDg5KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHNraXBDbGllbnRUYWdPbktpbmRzLmhhcyh0aGlzLmtpbmQpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHRoaXMuaXNFcGhlbWVyYWwoKSB8fCB0aGlzLmlzUmVwbGFjZWFibGUoKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0aGlzLmlzRHZtKCkpIHJldHVybiBmYWxzZTtcbiAgICBpZiAodGhpcy5oYXNUYWcoXCJjbGllbnRcIikpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBnZXQgc2hvdWxkU3RyaXBDbGllbnRUYWcoKSB7XG4gICAgcmV0dXJuIHNraXBDbGllbnRUYWdPbktpbmRzLmhhcyh0aGlzLmtpbmQpO1xuICB9XG4gIG11dGVkKCkge1xuICAgIGNvbnN0IGF1dGhvck11dGVkRW50cnkgPSB0aGlzLm5kaz8ubXV0ZWRJZHMuZ2V0KHRoaXMucHVia2V5KTtcbiAgICBpZiAoYXV0aG9yTXV0ZWRFbnRyeSAmJiBhdXRob3JNdXRlZEVudHJ5ID09PSBcInBcIikgcmV0dXJuIFwiYXV0aG9yXCI7XG4gICAgY29uc3QgZXZlbnRUYWdSZWZlcmVuY2UgPSB0aGlzLnRhZ1JlZmVyZW5jZSgpO1xuICAgIGNvbnN0IGV2ZW50TXV0ZWRFbnRyeSA9IHRoaXMubmRrPy5tdXRlZElkcy5nZXQoZXZlbnRUYWdSZWZlcmVuY2VbMV0pO1xuICAgIGlmIChldmVudE11dGVkRW50cnkgJiYgZXZlbnRNdXRlZEVudHJ5ID09PSBldmVudFRhZ1JlZmVyZW5jZVswXSkgcmV0dXJuIFwiZXZlbnRcIjtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgXCJkXCIgdGFnIG9mIGEgcGFyYW1ldGVyaXplZCByZXBsYWNlYWJsZSBldmVudCBvciB0aHJvd3MgYW4gZXJyb3IgaWYgdGhlIGV2ZW50IGlzbid0XG4gICAqIGEgcGFyYW1ldGVyaXplZCByZXBsYWNlYWJsZSBldmVudC5cbiAgICogQHJldHVybnMge3N0cmluZ30gdGhlIFwiZFwiIHRhZyBvZiB0aGUgZXZlbnQuXG4gICAqIFxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYGRUYWdgIGluc3RlYWQuXG4gICAqL1xuICByZXBsYWNlYWJsZURUYWcoKSB7XG4gICAgaWYgKHRoaXMua2luZCAmJiB0aGlzLmtpbmQgPj0gM2U0ICYmIHRoaXMua2luZCA8PSA0ZTQpIHtcbiAgICAgIGNvbnN0IGRUYWcgPSB0aGlzLmdldE1hdGNoaW5nVGFncyhcImRcIilbMF07XG4gICAgICBjb25zdCBkVGFnSWQgPSBkVGFnID8gZFRhZ1sxXSA6IFwiXCI7XG4gICAgICByZXR1cm4gZFRhZ0lkO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFdmVudCBpcyBub3QgYSBwYXJhbWV0ZXJpemVkIHJlcGxhY2VhYmxlIGV2ZW50XCIpO1xuICB9XG4gIC8qKlxuICAgKiBQcm92aWRlcyBhIGRlZHVwbGljYXRpb24ga2V5IGZvciB0aGUgZXZlbnQuXG4gICAqXG4gICAqIEZvciBraW5kcyAwLCAzLCAxMGstMjBrIHRoaXMgd2lsbCBiZSB0aGUgZXZlbnQgPGtpbmQ+OjxwdWJrZXk+XG4gICAqIEZvciBraW5kcyAzMGstNDBrIHRoaXMgd2lsbCBiZSB0aGUgZXZlbnQgPGtpbmQ+OjxwdWJrZXk+OjxkLXRhZz5cbiAgICogRm9yIGFsbCBvdGhlciBraW5kcyB0aGlzIHdpbGwgYmUgdGhlIGV2ZW50IGlkXG4gICAqL1xuICBkZWR1cGxpY2F0aW9uS2V5KCkge1xuICAgIGlmICh0aGlzLmtpbmQgPT09IDAgfHwgdGhpcy5raW5kID09PSAzIHx8IHRoaXMua2luZCAmJiB0aGlzLmtpbmQgPj0gMWU0ICYmIHRoaXMua2luZCA8IDJlNCkge1xuICAgICAgcmV0dXJuIGAke3RoaXMua2luZH06JHt0aGlzLnB1YmtleX1gO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy50YWdJZCgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaWQgb2YgdGhlIGV2ZW50IG9yLCBpZiBpdCdzIGEgcGFyYW1ldGVyaXplZCBldmVudCwgdGhlIGdlbmVyYXRlZCBpZCBvZiB0aGUgZXZlbnQgdXNpbmcgXCJkXCIgdGFnLCBwdWJrZXksIGFuZCBraW5kLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgaWRcbiAgICovXG4gIHRhZ0lkKCkge1xuICAgIGlmICh0aGlzLmlzUGFyYW1SZXBsYWNlYWJsZSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy50YWdBZGRyZXNzKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmlkO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RhYmxlIHJlZmVyZW5jZSB2YWx1ZSBmb3IgYSByZXBsYWNlYWJsZSBldmVudC5cbiAgICogXG4gICAqIFBhcmFtIHJlcGxhY2VhYmxlIGV2ZW50cyBhcmUgcmV0dXJuZWQgaW4gdGhlIGV4cGVjdGVkIGZvcm1hdCBvZiBgPGtpbmQ+OjxwdWJrZXk+OjxkLXRhZz5gLlxuICAgKiBLaW5kLXJlcGxhY2VhYmxlIGV2ZW50cyBhcmUgcmV0dXJuZWQgaW4gdGhlIGZvcm1hdCBvZiBgPGtpbmQ+OjxwdWJrZXk+OmAuXG4gICAqIFxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBBIHN0YWJsZSByZWZlcmVuY2UgdmFsdWUgZm9yIHJlcGxhY2VhYmxlIGV2ZW50c1xuICAgKi9cbiAgdGFnQWRkcmVzcygpIHtcbiAgICBpZiAodGhpcy5pc1BhcmFtUmVwbGFjZWFibGUoKSkge1xuICAgICAgY29uc3QgZFRhZ0lkID0gdGhpcy5kVGFnID8/IFwiXCI7XG4gICAgICByZXR1cm4gYCR7dGhpcy5raW5kfToke3RoaXMucHVia2V5fToke2RUYWdJZH1gO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc1JlcGxhY2VhYmxlKCkpIHtcbiAgICAgIHJldHVybiBgJHt0aGlzLmtpbmR9OiR7dGhpcy5wdWJrZXl9OmA7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIkV2ZW50IGlzIG5vdCBhIHJlcGxhY2VhYmxlIGV2ZW50XCIpO1xuICB9XG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHRoZSB0eXBlIG9mIHRhZyB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlZmVyZW5jZSB0aGlzIGV2ZW50IGZyb20gYW5vdGhlciBldmVudC5cbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIHRhZyB0eXBlXG4gICAqIEBleGFtcGxlXG4gICAqIGV2ZW50ID0gbmV3IE5ES0V2ZW50KG5kaywgeyBraW5kOiAzMDAwMCwgcHVia2V5OiAncHVia2V5JywgdGFnczogWyBbXCJkXCIsIFwiZC1jb2RlXCJdIF0gfSk7XG4gICAqIGV2ZW50LnRhZ1R5cGUoKTsgLy8gXCJhXCJcbiAgICovXG4gIHRhZ1R5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNQYXJhbVJlcGxhY2VhYmxlKCkgPyBcImFcIiA6IFwiZVwiO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHRhZyB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlZmVyZW5jZSB0aGlzIGV2ZW50IGZyb20gYW5vdGhlciBldmVudC5cbiAgICpcbiAgICogQ29uc2lkZXIgdXNpbmcgcmVmZXJlbmNlVGFncygpIGluc3RlYWQgKHVubGVzcyB5b3UgaGF2ZSBhIGdvb2QgcmVhc29uIHRvIHVzZSB0aGlzKVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgICAgZXZlbnQgPSBuZXcgTkRLRXZlbnQobmRrLCB7IGtpbmQ6IDMwMDAwLCBwdWJrZXk6ICdwdWJrZXknLCB0YWdzOiBbIFtcImRcIiwgXCJkLWNvZGVcIl0gXSB9KTtcbiAgICogICAgIGV2ZW50LnRhZ1JlZmVyZW5jZSgpOyAvLyBbXCJhXCIsIFwiMzAwMDA6cHVia2V5OmQtY29kZVwiXVxuICAgKlxuICAgKiAgICAgZXZlbnQgPSBuZXcgTkRLRXZlbnQobmRrLCB7IGtpbmQ6IDEsIHB1YmtleTogJ3B1YmtleScsIGlkOiBcImV2ZW50aWRcIiB9KTtcbiAgICogICAgIGV2ZW50LnRhZ1JlZmVyZW5jZSgpOyAvLyBbXCJlXCIsIFwiZXZlbnRpZFwiXVxuICAgKiBAcmV0dXJucyB7TkRLVGFnfSBUaGUgTkRLVGFnIG9iamVjdCByZWZlcmVuY2luZyB0aGlzIGV2ZW50XG4gICAqL1xuICB0YWdSZWZlcmVuY2UobWFya2VyKSB7XG4gICAgbGV0IHRhZztcbiAgICBpZiAodGhpcy5pc1BhcmFtUmVwbGFjZWFibGUoKSkge1xuICAgICAgdGFnID0gW1wiYVwiLCB0aGlzLnRhZ0FkZHJlc3MoKV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhZyA9IFtcImVcIiwgdGhpcy50YWdJZCgpXTtcbiAgICB9XG4gICAgaWYgKHRoaXMucmVsYXkpIHtcbiAgICAgIHRhZy5wdXNoKHRoaXMucmVsYXkudXJsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFnLnB1c2goXCJcIik7XG4gICAgfVxuICAgIHRhZy5wdXNoKG1hcmtlciA/PyBcIlwiKTtcbiAgICBpZiAoIXRoaXMuaXNQYXJhbVJlcGxhY2VhYmxlKCkpIHtcbiAgICAgIHRhZy5wdXNoKHRoaXMucHVia2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRhZztcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSB0YWdzIHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVmZXJlbmNlIHRoaXMgZXZlbnQgZnJvbSBhbm90aGVyIGV2ZW50XG4gICAqIEBwYXJhbSBtYXJrZXIgVGhlIG1hcmtlciB0byB1c2UgaW4gdGhlIHRhZ1xuICAgKiBAcGFyYW0gc2tpcEF1dGhvclRhZyBXaGV0aGVyIHRvIGV4cGxpY2l0bHkgc2tpcCBhZGRpbmcgdGhlIGF1dGhvciB0YWcgb2YgdGhlIGV2ZW50XG4gICAqIEBwYXJhbSBmb3JjZVRhZyBGb3JjZSBhIHNwZWNpZmljIHRhZyB0byBiZSB1c2VkIGluc3RlYWQgb2YgdGhlIGRlZmF1bHQgXCJlXCIgb3IgXCJhXCIgdGFnXG4gICAqIEBleGFtcGxlXG4gICAqICAgICBldmVudCA9IG5ldyBOREtFdmVudChuZGssIHsga2luZDogMzAwMDAsIHB1YmtleTogJ3B1YmtleScsIHRhZ3M6IFsgW1wiZFwiLCBcImQtY29kZVwiXSBdIH0pO1xuICAgKiAgICAgZXZlbnQucmVmZXJlbmNlVGFncygpOyAvLyBbW1wiYVwiLCBcIjMwMDAwOnB1YmtleTpkLWNvZGVcIl0sIFtcImVcIiwgXCJwYXJlbnQtaWRcIl1dXG4gICAqXG4gICAqICAgICBldmVudCA9IG5ldyBOREtFdmVudChuZGssIHsga2luZDogMSwgcHVia2V5OiAncHVia2V5JywgaWQ6IFwiZXZlbnRpZFwiIH0pO1xuICAgKiAgICAgZXZlbnQucmVmZXJlbmNlVGFncygpOyAvLyBbW1wiZVwiLCBcInBhcmVudC1pZFwiXV1cbiAgICogQHJldHVybnMge05ES1RhZ30gVGhlIE5ES1RhZyBvYmplY3QgcmVmZXJlbmNpbmcgdGhpcyBldmVudFxuICAgKi9cbiAgcmVmZXJlbmNlVGFncyhtYXJrZXIsIHNraXBBdXRob3JUYWcsIGZvcmNlVGFnKSB7XG4gICAgbGV0IHRhZ3MgPSBbXTtcbiAgICBpZiAodGhpcy5pc1BhcmFtUmVwbGFjZWFibGUoKSkge1xuICAgICAgdGFncyA9IFtcbiAgICAgICAgW2ZvcmNlVGFnID8/IFwiYVwiLCB0aGlzLnRhZ0FkZHJlc3MoKV0sXG4gICAgICAgIFtmb3JjZVRhZyA/PyBcImVcIiwgdGhpcy5pZF1cbiAgICAgIF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhZ3MgPSBbW2ZvcmNlVGFnID8/IFwiZVwiLCB0aGlzLmlkXV07XG4gICAgfVxuICAgIHRhZ3MgPSB0YWdzLm1hcCgodGFnKSA9PiB7XG4gICAgICBpZiAodGFnWzBdID09PSBcImVcIiB8fCBtYXJrZXIpIHtcbiAgICAgICAgdGFnLnB1c2godGhpcy5yZWxheT8udXJsID8/IFwiXCIpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnJlbGF5Py51cmwpIHtcbiAgICAgICAgdGFnLnB1c2godGhpcy5yZWxheT8udXJsKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YWc7XG4gICAgfSk7XG4gICAgdGFncy5mb3JFYWNoKCh0YWcpID0+IHtcbiAgICAgIGlmICh0YWdbMF0gPT09IFwiZVwiKSB7XG4gICAgICAgIHRhZy5wdXNoKG1hcmtlciA/PyBcIlwiKTtcbiAgICAgICAgdGFnLnB1c2godGhpcy5wdWJrZXkpO1xuICAgICAgfSBlbHNlIGlmIChtYXJrZXIpIHtcbiAgICAgICAgdGFnLnB1c2gobWFya2VyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0YWdzID0gWy4uLnRhZ3MsIC4uLnRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwiaFwiKV07XG4gICAgaWYgKCFza2lwQXV0aG9yVGFnKSB0YWdzLnB1c2goLi4udGhpcy5hdXRob3IucmVmZXJlbmNlVGFncygpKTtcbiAgICByZXR1cm4gdGFncztcbiAgfVxuICAvKipcbiAgICogUHJvdmlkZXMgdGhlIGZpbHRlciB0aGF0IHdpbGwgcmV0dXJuIG1hdGNoaW5nIGV2ZW50cyBmb3IgdGhpcyBldmVudC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogICAgZXZlbnQgPSBuZXcgTkRLRXZlbnQobmRrLCB7IGtpbmQ6IDMwMDAwLCBwdWJrZXk6ICdwdWJrZXknLCB0YWdzOiBbIFtcImRcIiwgXCJkLWNvZGVcIl0gXSB9KTtcbiAgICogICAgZXZlbnQuZmlsdGVyKCk7IC8vIHsgXCIjYVwiOiBbXCIzMDAwMDpwdWJrZXk6ZC1jb2RlXCJdIH1cbiAgICogQGV4YW1wbGVcbiAgICogICAgZXZlbnQgPSBuZXcgTkRLRXZlbnQobmRrLCB7IGtpbmQ6IDEsIHB1YmtleTogJ3B1YmtleScsIGlkOiBcImV2ZW50aWRcIiB9KTtcbiAgICogICAgZXZlbnQuZmlsdGVyKCk7IC8vIHsgXCIjZVwiOiBbXCJldmVudGlkXCJdIH1cbiAgICpcbiAgICogQHJldHVybnMgVGhlIGZpbHRlciB0aGF0IHdpbGwgcmV0dXJuIG1hdGNoaW5nIGV2ZW50cyBmb3IgdGhpcyBldmVudFxuICAgKi9cbiAgZmlsdGVyKCkge1xuICAgIGlmICh0aGlzLmlzUGFyYW1SZXBsYWNlYWJsZSgpKSB7XG4gICAgICByZXR1cm4geyBcIiNhXCI6IFt0aGlzLnRhZ0lkKCldIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7IFwiI2VcIjogW3RoaXMudGFnSWQoKV0gfTtcbiAgICB9XG4gIH1cbiAgbmlwMjJGaWx0ZXIoKSB7XG4gICAgaWYgKHRoaXMuaXNQYXJhbVJlcGxhY2VhYmxlKCkpIHtcbiAgICAgIHJldHVybiB7IFwiI0FcIjogW3RoaXMudGFnSWQoKV0gfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHsgXCIjRVwiOiBbdGhpcy50YWdJZCgpXSB9O1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgZGVsZXRpb24gZXZlbnQgb2YgdGhlIGN1cnJlbnQgZXZlbnRcbiAgICpcbiAgICogQHBhcmFtIHJlYXNvbiBUaGUgcmVhc29uIGZvciB0aGUgZGVsZXRpb25cbiAgICogQHBhcmFtIHB1Ymxpc2ggV2hldGhlciB0byBwdWJsaXNoIHRoZSBkZWxldGlvbiBldmVudCBhdXRvbWF0aWNhbGx5XG4gICAqIEByZXR1cm5zIFRoZSBkZWxldGlvbiBldmVudFxuICAgKi9cbiAgYXN5bmMgZGVsZXRlKHJlYXNvbiwgcHVibGlzaCA9IHRydWUpIHtcbiAgICBpZiAoIXRoaXMubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBOREsgaW5zdGFuY2UgZm91bmRcIik7XG4gICAgdGhpcy5uZGsuYXNzZXJ0U2lnbmVyKCk7XG4gICAgY29uc3QgZSA9IG5ldyBfTkRLRXZlbnQodGhpcy5uZGssIHtcbiAgICAgIGtpbmQ6IDUgLyogRXZlbnREZWxldGlvbiAqLyxcbiAgICAgIGNvbnRlbnQ6IHJlYXNvbiB8fCBcIlwiXG4gICAgfSk7XG4gICAgZS50YWcodGhpcywgdm9pZCAwLCB0cnVlKTtcbiAgICBlLnRhZ3MucHVzaChbXCJrXCIsIHRoaXMua2luZC50b1N0cmluZygpXSk7XG4gICAgaWYgKHB1Ymxpc2gpIHtcbiAgICAgIHRoaXMuZW1pdChcImRlbGV0ZWRcIik7XG4gICAgICBhd2FpdCBlLnB1Ymxpc2goKTtcbiAgICB9XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgLyoqXG4gICAqIEVzdGFibGlzaGVzIHdoZXRoZXIgdGhpcyBpcyBhIE5JUC03MC1wcm90ZWN0ZWRlIGV2ZW50LlxuICAgKiBAQHNhdGlzZmllcyBOSVAtNzBcbiAgICovXG4gIHNldCBpc1Byb3RlY3RlZCh2YWwpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcIi1cIik7XG4gICAgaWYgKHZhbCkgdGhpcy50YWdzLnB1c2goW1wiLVwiXSk7XG4gIH1cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhpcyBpcyBhIE5JUC03MC1wcm90ZWN0ZWRlIGV2ZW50LlxuICAgKiBAQHNhdGlzZmllcyBOSVAtNzBcbiAgICovXG4gIGdldCBpc1Byb3RlY3RlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNUYWcoXCItXCIpO1xuICB9XG4gIC8qKlxuICAgKiBGZXRjaCBhbiBldmVudCB0YWdnZWQgd2l0aCB0aGUgZ2l2ZW4gdGFnIGZvbGxvd2luZyByZWxheSBoaW50cyBpZiBwcm92aWRlZC5cbiAgICogQHBhcmFtIHRhZyBUaGUgdGFnIHRvIHNlYXJjaCBmb3JcbiAgICogQHBhcmFtIG1hcmtlciBUaGUgbWFya2VyIHRvIHVzZSBpbiB0aGUgdGFnIChlLmcuIFwicm9vdFwiKVxuICAgKiBAcmV0dXJucyBUaGUgZmV0Y2hlZCBldmVudCBvciBudWxsIGlmIG5vIGV2ZW50IHdhcyBmb3VuZCwgdW5kZWZpbmVkIGlmIG5vIG1hdGNoaW5nIHRhZyB3YXMgZm91bmQgaW4gdGhlIGV2ZW50XG4gICAqICogQGV4YW1wbGVcbiAgICogY29uc3QgcmVwbHlFdmVudCA9IGF3YWl0IG5kay5mZXRjaEV2ZW50KFwibmV2ZW50MXFxczh4OHZueWN5aGE3M2dydjM4MGdtdmx1cnk0d3RteDBucjlhNWRzMmRuZ3F3Z3U4N3duNmdwemVtaHh1ZTY5dWhoeWV0dnY5dWp1dXJqZDlra3ptcHdkZWpoZ3EzcWwydnloNDdtazJwMHFsc2t1N2hnMHZuMjlmYWVoeTloeTM0eWdhY2xwbjY2dWtxcDNhZnF6NGN3amRcIilcbiAgICogY29uc3Qgb3JpZ2luYWxFdmVudCA9IGF3YWl0IHJlcGx5RXZlbnQuZmV0Y2hUYWdnZWRFdmVudChcImVcIiwgXCJyZXBseVwiKTtcbiAgICogY29uc29sZS5sb2cocmVwbHlFdmVudC5lbmNvZGUoKSArIFwiIGlzIGEgcmVwbHkgdG8gZXZlbnQgXCIgKyBvcmlnaW5hbEV2ZW50Py5lbmNvZGUoKSk7XG4gICAqL1xuICBmZXRjaFRhZ2dlZEV2ZW50ID0gZmV0Y2hUYWdnZWRFdmVudC5iaW5kKHRoaXMpO1xuICAvKipcbiAgICogRmV0Y2ggdGhlIHJvb3QgZXZlbnQgb2YgdGhlIGN1cnJlbnQgZXZlbnQuXG4gICAqIEByZXR1cm5zIFRoZSBmZXRjaGVkIHJvb3QgZXZlbnQgb3IgbnVsbCBpZiBubyBldmVudCB3YXMgZm91bmRcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3QgcmVwbHlFdmVudCA9IGF3YWl0IG5kay5mZXRjaEV2ZW50KFwibmV2ZW50MXFxczh4OHZueWN5aGE3M2dydjM4MGdtdmx1cnk0d3RteDBucjlhNWRzMmRuZ3F3Z3U4N3duNmdwemVtaHh1ZTY5dWhoeWV0dnY5dWp1dXJqZDlra3ptcHdkZWpoZ3EzcWwydnloNDdtazJwMHFsc2t1N2hnMHZuMjlmYWVoeTloeTM0eWdhY2xwbjY2dWtxcDNhZnF6NGN3amRcIilcbiAgICogY29uc3Qgcm9vdEV2ZW50ID0gYXdhaXQgcmVwbHlFdmVudC5mZXRjaFJvb3RFdmVudCgpO1xuICAgKiBjb25zb2xlLmxvZyhyZXBseUV2ZW50LmVuY29kZSgpICsgXCIgaXMgYSByZXBseSBpbiB0aGUgdGhyZWFkIFwiICsgcm9vdEV2ZW50Py5lbmNvZGUoKSk7XG4gICAqL1xuICBmZXRjaFJvb3RFdmVudCA9IGZldGNoUm9vdEV2ZW50LmJpbmQodGhpcyk7XG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgZXZlbnQgdGhlIGN1cnJlbnQgZXZlbnQgaXMgcmVwbHlpbmcgdG8uXG4gICAqIEByZXR1cm5zIFRoZSBmZXRjaGVkIHJlcGx5IGV2ZW50IG9yIG51bGwgaWYgbm8gZXZlbnQgd2FzIGZvdW5kXG4gICAqL1xuICBmZXRjaFJlcGx5RXZlbnQgPSBmZXRjaFJlcGx5RXZlbnQuYmluZCh0aGlzKTtcbiAgLyoqXG4gICAqIE5JUC0xOCByZXBvc3RpbmcgZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSBwdWJsaXNoIFdoZXRoZXIgdG8gcHVibGlzaCB0aGUgcmVwb3N0ZWQgZXZlbnQgYXV0b21hdGljYWxseSBAZGVmYXVsdCB0cnVlXG4gICAqIEBwYXJhbSBzaWduZXIgVGhlIHNpZ25lciB0byB1c2UgZm9yIHNpZ25pbmcgdGhlIHJlcG9zdGVkIGV2ZW50XG4gICAqIEByZXR1cm5zIFRoZSByZXBvc3RlZCBldmVudFxuICAgKlxuICAgKiBAZnVuY3Rpb25cbiAgICovXG4gIHJlcG9zdCA9IHJlcG9zdC5iaW5kKHRoaXMpO1xuICAvKipcbiAgICogUmVhY3QgdG8gYW4gZXhpc3RpbmcgZXZlbnRcbiAgICpcbiAgICogQHBhcmFtIGNvbnRlbnQgVGhlIGNvbnRlbnQgb2YgdGhlIHJlYWN0aW9uXG4gICAqL1xuICBhc3luYyByZWFjdChjb250ZW50LCBwdWJsaXNoID0gdHJ1ZSkge1xuICAgIGlmICghdGhpcy5uZGspIHRocm93IG5ldyBFcnJvcihcIk5vIE5ESyBpbnN0YW5jZSBmb3VuZFwiKTtcbiAgICB0aGlzLm5kay5hc3NlcnRTaWduZXIoKTtcbiAgICBjb25zdCBlID0gbmV3IF9OREtFdmVudCh0aGlzLm5kaywge1xuICAgICAga2luZDogNyAvKiBSZWFjdGlvbiAqLyxcbiAgICAgIGNvbnRlbnRcbiAgICB9KTtcbiAgICBlLnRhZyh0aGlzKTtcbiAgICBpZiAocHVibGlzaCkgYXdhaXQgZS5wdWJsaXNoKCk7XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIHRoZSBldmVudCBpcyB2YWxpZCBwZXIgdW5kZXJseWluZyBOSVBzLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBtZWFudCB0byBiZSBvdmVycmlkZGVuIGJ5IHN1YmNsYXNzZXMgdGhhdCBpbXBsZW1lbnQgc3BlY2lmaWMgTklQc1xuICAgKiB0byBhbGxvdyB0aGUgZW5mb3JjZW1lbnQgb2YgTklQLXNwZWNpZmljIHZhbGlkYXRpb24gcnVsZXMuXG4gICAqXG4gICAqIE90aGVyd2lzZSwgaXQgd2lsbCBvbmx5IGNoZWNrIGZvciBiYXNpYyBldmVudCBwcm9wZXJ0aWVzLlxuICAgKlxuICAgKi9cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsaWRhdGUoKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIHJlcGx5IGV2ZW50IGZvciB0aGUgY3VycmVudCBldmVudC5cbiAgICogXG4gICAqIFRoaXMgZnVuY3Rpb24gd2lsbCB1c2UgTklQLTIyIHdoZW4gYXBwcm9wcmlhdGUgKGkuZS4gcmVwbGllcyB0byBub24ta2luZDoxIGV2ZW50cykuXG4gICAqIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgaGF2ZSBzaWRlLWVmZmVjdHM7IGl0IHdpbGwganVzdCByZXR1cm4gYW4gZXZlbnQgd2l0aCB0aGUgYXBwcm9wcmlhdGUgdGFnc1xuICAgKiB0byBnZW5lcmF0ZSB0aGUgcmVwbHkgZXZlbnQ7IHRoZSBjYWxsZXIgaXMgcmVzcG9uc2libGUgZm9yIHB1Ymxpc2hpbmcgdGhlIGV2ZW50LlxuICAgKi9cbiAgcmVwbHkoKSB7XG4gICAgY29uc3QgcmVwbHkgPSBuZXcgX05ES0V2ZW50KHRoaXMubmRrKTtcbiAgICBpZiAodGhpcy5raW5kID09PSAxKSB7XG4gICAgICByZXBseS5raW5kID0gMTtcbiAgICAgIGNvbnN0IG9wSGFzRVRhZyA9IHRoaXMuaGFzVGFnKFwiZVwiKTtcbiAgICAgIGlmIChvcEhhc0VUYWcpIHtcbiAgICAgICAgcmVwbHkudGFncyA9IFtcbiAgICAgICAgICAuLi5yZXBseS50YWdzLFxuICAgICAgICAgIC4uLnRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwiZVwiKSxcbiAgICAgICAgICAuLi50aGlzLmdldE1hdGNoaW5nVGFncyhcInBcIiksXG4gICAgICAgICAgLi4udGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJhXCIpLFxuICAgICAgICAgIC4uLnRoaXMucmVmZXJlbmNlVGFncyhcInJlcGx5XCIpXG4gICAgICAgIF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXBseS50YWcodGhpcywgXCJyb290XCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXBseS5raW5kID0gMTExMSAvKiBHZW5lcmljUmVwbHkgKi87XG4gICAgICBjb25zdCBjYXJyeU92ZXJUYWdzID0gW1wiQVwiLCBcIkVcIiwgXCJJXCIsIFwiUFwiXTtcbiAgICAgIGNvbnN0IHJvb3RUYWdzID0gdGhpcy50YWdzLmZpbHRlcigodGFnKSA9PiBjYXJyeU92ZXJUYWdzLmluY2x1ZGVzKHRhZ1swXSkpO1xuICAgICAgaWYgKHJvb3RUYWdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3Qgcm9vdEtpbmQgPSB0aGlzLnRhZ1ZhbHVlKFwiS1wiKTtcbiAgICAgICAgcmVwbHkudGFncy5wdXNoKC4uLnJvb3RUYWdzKTtcbiAgICAgICAgaWYgKHJvb3RLaW5kKSByZXBseS50YWdzLnB1c2goW1wiS1wiLCByb290S2luZF0pO1xuICAgICAgICBjb25zdCBbdHlwZSwgaWQsIF8sIC4uLmV4dHJhXSA9IHRoaXMudGFnUmVmZXJlbmNlKCk7XG4gICAgICAgIGNvbnN0IHRhZyA9IFt0eXBlLCBpZCwgLi4uZXh0cmFdO1xuICAgICAgICByZXBseS50YWdzLnB1c2godGFnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IFt0eXBlLCBpZCwgXywgcmVsYXlIaW50XSA9IHRoaXMudGFnUmVmZXJlbmNlKCk7XG4gICAgICAgIGNvbnN0IHRhZyA9IFt0eXBlLCBpZCwgcmVsYXlIaW50ID8/IFwiXCJdO1xuICAgICAgICBpZiAodHlwZSA9PT0gXCJlXCIpIHRhZy5wdXNoKHRoaXMucHVia2V5KTtcbiAgICAgICAgcmVwbHkudGFncy5wdXNoKHRhZyk7XG4gICAgICAgIGNvbnN0IHVwcGVyY2FzZVRhZyA9IFsuLi50YWddO1xuICAgICAgICB1cHBlcmNhc2VUYWdbMF0gPSB1cHBlcmNhc2VUYWdbMF0udG9VcHBlckNhc2UoKTtcbiAgICAgICAgcmVwbHkudGFncy5wdXNoKHVwcGVyY2FzZVRhZyk7XG4gICAgICAgIHJlcGx5LnRhZ3MucHVzaChbXCJLXCIsIHRoaXMua2luZC50b1N0cmluZygpXSk7XG4gICAgICAgIHJlcGx5LnRhZ3MucHVzaChbXCJQXCIsIHRoaXMucHVia2V5XSk7XG4gICAgICB9XG4gICAgICByZXBseS50YWdzLnB1c2goW1wia1wiLCB0aGlzLmtpbmQudG9TdHJpbmcoKV0pO1xuICAgICAgcmVwbHkudGFncy5wdXNoKC4uLnRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwicFwiKSk7XG4gICAgICByZXBseS50YWdzLnB1c2goW1wicFwiLCB0aGlzLnB1YmtleV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVwbHk7XG4gIH1cbn07XG52YXIgdW50cmFja2VkVW5wdWJsaXNoZWRFdmVudHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIDI0MTMzIC8qIE5vc3RyQ29ubmVjdCAqLyxcbiAgMTMxOTQgLyogTm9zdHJXYWxldENvbm5lY3RJbmZvICovLFxuICAyMzE5NCAvKiBOb3N0cldhbGxldENvbm5lY3RSZXEgKi8sXG4gIDIzMTk1IC8qIE5vc3RyV2FsbGV0Q29ubmVjdFJlcyAqL1xuXSk7XG5mdW5jdGlvbiBzaG91bGRUcmFja1VucHVibGlzaGVkRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuICF1bnRyYWNrZWRVbnB1Ymxpc2hlZEV2ZW50cy5oYXMoZXZlbnQua2luZCk7XG59XG5cbi8vIHNyYy9yZWxheS9wb29sL2luZGV4LnRzXG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgYXMgRXZlbnRFbWl0dGVyMyB9IGZyb20gXCJ0c2VlcFwiO1xudmFyIE5ES1Bvb2wgPSBjbGFzcyBleHRlbmRzIEV2ZW50RW1pdHRlcjMge1xuICAvLyBUT0RPOiBUaGlzIHNob3VsZCBwcm9iYWJseSBiZSBhbiBMUlUgY2FjaGVcbiAgX3JlbGF5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIHN0YXR1cyA9IFwiaWRsZVwiO1xuICBhdXRvQ29ubmVjdFJlbGF5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIHBvb2xCbGFja2xpc3RSZWxheVVybHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBkZWJ1ZztcbiAgdGVtcG9yYXJ5UmVsYXlUaW1lcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBmbGFwcGluZ1JlbGF5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIC8vIEEgbWFwIHRvIHN0b3JlIHRpbWVvdXRzIGZvciBlYWNoIGZsYXBwaW5nIHJlbGF5LlxuICBiYWNrb2ZmVGltZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBuZGs7XG4gIGdldCBibGFja2xpc3RSZWxheVVybHMoKSB7XG4gICAgY29uc3QgdmFsID0gbmV3IFNldCh0aGlzLm5kay5ibGFja2xpc3RSZWxheVVybHMpO1xuICAgIHRoaXMucG9vbEJsYWNrbGlzdFJlbGF5VXJscy5mb3JFYWNoKCh1cmwpID0+IHZhbC5hZGQodXJsKSk7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHJlbGF5VXJscyAtIFRoZSBVUkxzIG9mIHRoZSByZWxheXMgdG8gY29ubmVjdCB0by5cbiAgICogQHBhcmFtIGJsYWNrbGlzdGVkUmVsYXlVcmxzIC0gVVJMcyB0byBibGFja2xpc3QgZm9yIHRoaXMgcG9vbCBJTiBBRERJVElPTiB0byB0aG9zZSBibGFja2xpc3RlZCBhdCB0aGUgbmRrLWxldmVsXG4gICAqIEBwYXJhbSBuZGsgLSBUaGUgTkRLIGluc3RhbmNlLlxuICAgKiBAcGFyYW0gb3B0cyAtIE9wdGlvbnMgZm9yIHRoZSBwb29sLlxuICAgKi9cbiAgY29uc3RydWN0b3IocmVsYXlVcmxzID0gW10sIGJsYWNrbGlzdGVkUmVsYXlVcmxzID0gW10sIG5kaywgeyBkZWJ1ZzogZGVidWc4LCBuYW1lIH0gPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5kZWJ1ZyA9IGRlYnVnOCA/PyBuZGsuZGVidWcuZXh0ZW5kKFwicG9vbFwiKTtcbiAgICBpZiAobmFtZSkgdGhpcy5fbmFtZSA9IG5hbWU7XG4gICAgdGhpcy5uZGsgPSBuZGs7XG4gICAgdGhpcy5yZWxheVVybHMgPSByZWxheVVybHM7XG4gICAgdGhpcy5wb29sQmxhY2tsaXN0UmVsYXlVcmxzID0gbmV3IFNldChibGFja2xpc3RlZFJlbGF5VXJscyk7XG4gICAgdGhpcy5uZGsucG9vbHMucHVzaCh0aGlzKTtcbiAgfVxuICBnZXQgcmVsYXlzKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWxheXM7XG4gIH1cbiAgc2V0IHJlbGF5VXJscyh1cmxzKSB7XG4gICAgdGhpcy5fcmVsYXlzLmNsZWFyKCk7XG4gICAgZm9yIChjb25zdCByZWxheVVybCBvZiB1cmxzKSB7XG4gICAgICBjb25zdCByZWxheSA9IG5ldyBOREtSZWxheShyZWxheVVybCwgdm9pZCAwLCB0aGlzLm5kayk7XG4gICAgICByZWxheS5jb25uZWN0aXZpdHkubmV0RGVidWcgPSB0aGlzLm5kay5uZXREZWJ1ZztcbiAgICAgIHRoaXMuYWRkUmVsYXkocmVsYXkpO1xuICAgIH1cbiAgfVxuICBfbmFtZSA9IFwidW5uYW1lZFwiO1xuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgfVxuICBzZXQgbmFtZShuYW1lKSB7XG4gICAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gICAgdGhpcy5kZWJ1ZyA9IHRoaXMuZGVidWcuZXh0ZW5kKG5hbWUpO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGEgcmVsYXkgdG8gdGhlIHBvb2wsIGFuZCBzZXRzIGEgdGltZXIgdG8gcmVtb3ZlIGl0IGlmIGl0IGlzIG5vdCB1c2VkIHdpdGhpbiB0aGUgc3BlY2lmaWVkIHRpbWUuXG4gICAqIEBwYXJhbSByZWxheSAtIFRoZSByZWxheSB0byBhZGQgdG8gdGhlIHBvb2wuXG4gICAqIEBwYXJhbSByZW1vdmVJZlVudXNlZEFmdGVyIC0gVGhlIHRpbWUgaW4gbWlsbGlzZWNvbmRzIHRvIHdhaXQgYmVmb3JlIHJlbW92aW5nIHRoZSByZWxheSBmcm9tIHRoZSBwb29sIGFmdGVyIGl0IGlzIG5vIGxvbmdlciB1c2VkLlxuICAgKi9cbiAgdXNlVGVtcG9yYXJ5UmVsYXkocmVsYXksIHJlbW92ZUlmVW51c2VkQWZ0ZXIgPSAzZTQsIGZpbHRlcnMpIHtcbiAgICBjb25zdCByZWxheUFscmVhZHlJblBvb2wgPSB0aGlzLnJlbGF5cy5oYXMocmVsYXkudXJsKTtcbiAgICBpZiAoIXJlbGF5QWxyZWFkeUluUG9vbCkge1xuICAgICAgdGhpcy5hZGRSZWxheShyZWxheSk7XG4gICAgICB0aGlzLmRlYnVnKFwiQWRkaW5nIHRlbXBvcmFyeSByZWxheSAlcyBmb3IgZmlsdGVycyAlb1wiLCByZWxheS51cmwsIGZpbHRlcnMpO1xuICAgIH1cbiAgICBjb25zdCBleGlzdGluZ1RpbWVyID0gdGhpcy50ZW1wb3JhcnlSZWxheVRpbWVycy5nZXQocmVsYXkudXJsKTtcbiAgICBpZiAoZXhpc3RpbmdUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KGV4aXN0aW5nVGltZXIpO1xuICAgIH1cbiAgICBpZiAoIXJlbGF5QWxyZWFkeUluUG9vbCB8fCBleGlzdGluZ1RpbWVyKSB7XG4gICAgICBjb25zdCB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5uZGsuZXhwbGljaXRSZWxheVVybHM/LmluY2x1ZGVzKHJlbGF5LnVybCkpIHJldHVybjtcbiAgICAgICAgdGhpcy5yZW1vdmVSZWxheShyZWxheS51cmwpO1xuICAgICAgfSwgcmVtb3ZlSWZVbnVzZWRBZnRlcik7XG4gICAgICB0aGlzLnRlbXBvcmFyeVJlbGF5VGltZXJzLnNldChyZWxheS51cmwsIHRpbWVyKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYSByZWxheSB0byB0aGUgcG9vbC5cbiAgICpcbiAgICogQHBhcmFtIHJlbGF5IC0gVGhlIHJlbGF5IHRvIGFkZCB0byB0aGUgcG9vbC5cbiAgICogQHBhcmFtIGNvbm5lY3QgLSBXaGV0aGVyIG9yIG5vdCB0byBjb25uZWN0IHRvIHRoZSByZWxheS5cbiAgICovXG4gIGFkZFJlbGF5KHJlbGF5LCBjb25uZWN0ID0gdHJ1ZSkge1xuICAgIGNvbnN0IGlzQWxyZWFkeUluUG9vbCA9IHRoaXMucmVsYXlzLmhhcyhyZWxheS51cmwpO1xuICAgIGNvbnN0IGlzQmxhY2tsaXN0ZWQgPSB0aGlzLmJsYWNrbGlzdFJlbGF5VXJscz8uaGFzKHJlbGF5LnVybCk7XG4gICAgY29uc3QgaXNDdXN0b21SZWxheVVybCA9IHJlbGF5LnVybC5pbmNsdWRlcyhcIi9ucHViMVwiKTtcbiAgICBsZXQgcmVjb25uZWN0ID0gdHJ1ZTtcbiAgICBjb25zdCByZWxheVVybCA9IHJlbGF5LnVybDtcbiAgICBpZiAoaXNBbHJlYWR5SW5Qb29sKSByZXR1cm47XG4gICAgaWYgKGlzQmxhY2tsaXN0ZWQpIHtcbiAgICAgIHRoaXMuZGVidWcoYFJlZnVzaW5nIHRvIGFkZCByZWxheSAke3JlbGF5VXJsfTogYmxhY2tsaXN0ZWRgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGlzQ3VzdG9tUmVsYXlVcmwpIHtcbiAgICAgIHRoaXMuZGVidWcoYFJlZnVzaW5nIHRvIGFkZCByZWxheSAke3JlbGF5VXJsfTogaXMgYSBmaWx0ZXIgcmVsYXlgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMubmRrLmNhY2hlQWRhcHRlcj8uZ2V0UmVsYXlTdGF0dXMpIHtcbiAgICAgIGNvbnN0IGluZm8gPSB0aGlzLm5kay5jYWNoZUFkYXB0ZXIuZ2V0UmVsYXlTdGF0dXMocmVsYXlVcmwpO1xuICAgICAgaWYgKGluZm8gJiYgaW5mby5kb250Q29ubmVjdEJlZm9yZSkge1xuICAgICAgICBpZiAoaW5mby5kb250Q29ubmVjdEJlZm9yZSA+IERhdGUubm93KCkpIHtcbiAgICAgICAgICBjb25zdCBkZWxheSA9IGluZm8uZG9udENvbm5lY3RCZWZvcmUgLSBEYXRlLm5vdygpO1xuICAgICAgICAgIHRoaXMuZGVidWcoYFJlZnVzaW5nIHRvIGFkZCByZWxheSAke3JlbGF5VXJsfTogZGVsYXllZCBjb25uZWN0IGZvciAke2RlbGF5fW1zYCk7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFkZFJlbGF5KHJlbGF5LCBjb25uZWN0KTtcbiAgICAgICAgICB9LCBkZWxheSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlY29ubmVjdCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG5vdGljZUhhbmRsZXIgPSAobm90aWNlKSA9PiB0aGlzLmVtaXQoXCJub3RpY2VcIiwgcmVsYXksIG5vdGljZSk7XG4gICAgY29uc3QgY29ubmVjdEhhbmRsZXIgPSAoKSA9PiB0aGlzLmhhbmRsZVJlbGF5Q29ubmVjdChyZWxheVVybCk7XG4gICAgY29uc3QgcmVhZHlIYW5kbGVyID0gKCkgPT4gdGhpcy5oYW5kbGVSZWxheVJlYWR5KHJlbGF5KTtcbiAgICBjb25zdCBkaXNjb25uZWN0SGFuZGxlciA9ICgpID0+IHRoaXMuZW1pdChcInJlbGF5OmRpc2Nvbm5lY3RcIiwgcmVsYXkpO1xuICAgIGNvbnN0IGZsYXBwaW5nSGFuZGxlciA9ICgpID0+IHRoaXMuaGFuZGxlRmxhcHBpbmcocmVsYXkpO1xuICAgIGNvbnN0IGF1dGhIYW5kbGVyID0gKGNoYWxsZW5nZSkgPT4gdGhpcy5lbWl0KFwicmVsYXk6YXV0aFwiLCByZWxheSwgY2hhbGxlbmdlKTtcbiAgICBjb25zdCBhdXRoZWRIYW5kbGVyID0gKCkgPT4gdGhpcy5lbWl0KFwicmVsYXk6YXV0aGVkXCIsIHJlbGF5KTtcbiAgICByZWxheS5vZmYoXCJub3RpY2VcIiwgbm90aWNlSGFuZGxlcik7XG4gICAgcmVsYXkub2ZmKFwiY29ubmVjdFwiLCBjb25uZWN0SGFuZGxlcik7XG4gICAgcmVsYXkub2ZmKFwicmVhZHlcIiwgcmVhZHlIYW5kbGVyKTtcbiAgICByZWxheS5vZmYoXCJkaXNjb25uZWN0XCIsIGRpc2Nvbm5lY3RIYW5kbGVyKTtcbiAgICByZWxheS5vZmYoXCJmbGFwcGluZ1wiLCBmbGFwcGluZ0hhbmRsZXIpO1xuICAgIHJlbGF5Lm9mZihcImF1dGhcIiwgYXV0aEhhbmRsZXIpO1xuICAgIHJlbGF5Lm9mZihcImF1dGhlZFwiLCBhdXRoZWRIYW5kbGVyKTtcbiAgICByZWxheS5vbihcIm5vdGljZVwiLCBub3RpY2VIYW5kbGVyKTtcbiAgICByZWxheS5vbihcImNvbm5lY3RcIiwgY29ubmVjdEhhbmRsZXIpO1xuICAgIHJlbGF5Lm9uKFwicmVhZHlcIiwgcmVhZHlIYW5kbGVyKTtcbiAgICByZWxheS5vbihcImRpc2Nvbm5lY3RcIiwgZGlzY29ubmVjdEhhbmRsZXIpO1xuICAgIHJlbGF5Lm9uKFwiZmxhcHBpbmdcIiwgZmxhcHBpbmdIYW5kbGVyKTtcbiAgICByZWxheS5vbihcImF1dGhcIiwgYXV0aEhhbmRsZXIpO1xuICAgIHJlbGF5Lm9uKFwiYXV0aGVkXCIsIGF1dGhlZEhhbmRsZXIpO1xuICAgIHJlbGF5Lm9uKFwiZGVsYXllZC1jb25uZWN0XCIsIChkZWxheSkgPT4ge1xuICAgICAgaWYgKHRoaXMubmRrLmNhY2hlQWRhcHRlcj8udXBkYXRlUmVsYXlTdGF0dXMpIHtcbiAgICAgICAgdGhpcy5uZGsuY2FjaGVBZGFwdGVyLnVwZGF0ZVJlbGF5U3RhdHVzKHJlbGF5LnVybCwge1xuICAgICAgICAgIGRvbnRDb25uZWN0QmVmb3JlOiBEYXRlLm5vdygpICsgZGVsYXlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5fcmVsYXlzLnNldChyZWxheVVybCwgcmVsYXkpO1xuICAgIGlmIChjb25uZWN0KSB0aGlzLmF1dG9Db25uZWN0UmVsYXlzLmFkZChyZWxheVVybCk7XG4gICAgaWYgKGNvbm5lY3QgJiYgdGhpcy5zdGF0dXMgPT09IFwiYWN0aXZlXCIpIHtcbiAgICAgIHRoaXMuZW1pdChcInJlbGF5OmNvbm5lY3RpbmdcIiwgcmVsYXkpO1xuICAgICAgcmVsYXkuY29ubmVjdCh2b2lkIDAsIHJlY29ubmVjdCkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgdGhpcy5kZWJ1ZyhgRmFpbGVkIHRvIGNvbm5lY3QgdG8gcmVsYXkgJHtyZWxheVVybH1gLCBlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBhIHJlbGF5IGZyb20gdGhlIHBvb2wuXG4gICAqIEBwYXJhbSByZWxheVVybCAtIFRoZSBVUkwgb2YgdGhlIHJlbGF5IHRvIHJlbW92ZS5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHJlbGF5IHdhcyByZW1vdmVkLCBmYWxzZSBpZiBpdCB3YXMgbm90IGZvdW5kLlxuICAgKi9cbiAgcmVtb3ZlUmVsYXkocmVsYXlVcmwpIHtcbiAgICBjb25zdCByZWxheSA9IHRoaXMucmVsYXlzLmdldChyZWxheVVybCk7XG4gICAgaWYgKHJlbGF5KSB7XG4gICAgICByZWxheS5kaXNjb25uZWN0KCk7XG4gICAgICB0aGlzLnJlbGF5cy5kZWxldGUocmVsYXlVcmwpO1xuICAgICAgdGhpcy5hdXRvQ29ubmVjdFJlbGF5cy5kZWxldGUocmVsYXlVcmwpO1xuICAgICAgdGhpcy5lbWl0KFwicmVsYXk6ZGlzY29ubmVjdFwiLCByZWxheSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgZXhpc3RpbmdUaW1lciA9IHRoaXMudGVtcG9yYXJ5UmVsYXlUaW1lcnMuZ2V0KHJlbGF5VXJsKTtcbiAgICBpZiAoZXhpc3RpbmdUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KGV4aXN0aW5nVGltZXIpO1xuICAgICAgdGhpcy50ZW1wb3JhcnlSZWxheVRpbWVycy5kZWxldGUocmVsYXlVcmwpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIGEgcmVsYXkgaXMgYWxyZWFkeSBjb25uZWN0ZWQgaW4gdGhlIHBvb2wuXG4gICAqL1xuICBpc1JlbGF5Q29ubmVjdGVkKHVybCkge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRVcmwgPSBub3JtYWxpemVSZWxheVVybCh1cmwpO1xuICAgIGNvbnN0IHJlbGF5ID0gdGhpcy5yZWxheXMuZ2V0KG5vcm1hbGl6ZWRVcmwpO1xuICAgIGlmICghcmVsYXkpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gcmVsYXkuc3RhdHVzID09PSA1IC8qIENPTk5FQ1RFRCAqLztcbiAgfVxuICAvKipcbiAgICogRmV0Y2hlcyBhIHJlbGF5IGZyb20gdGhlIHBvb2wsIG9yIGNyZWF0ZXMgYSBuZXcgb25lIGlmIGl0IGRvZXMgbm90IGV4aXN0LlxuICAgKlxuICAgKiBOZXcgcmVsYXlzIHdpbGwgYmUgYXR0ZW1wdGVkIHRvIGJlIGNvbm5lY3RlZC5cbiAgICovXG4gIGdldFJlbGF5KHVybCwgY29ubmVjdCA9IHRydWUsIHRlbXBvcmFyeSA9IGZhbHNlLCBmaWx0ZXJzKSB7XG4gICAgbGV0IHJlbGF5ID0gdGhpcy5yZWxheXMuZ2V0KG5vcm1hbGl6ZVJlbGF5VXJsKHVybCkpO1xuICAgIGlmICghcmVsYXkpIHtcbiAgICAgIHJlbGF5ID0gbmV3IE5ES1JlbGF5KHVybCwgdm9pZCAwLCB0aGlzLm5kayk7XG4gICAgICByZWxheS5jb25uZWN0aXZpdHkubmV0RGVidWcgPSB0aGlzLm5kay5uZXREZWJ1ZztcbiAgICAgIGlmICh0ZW1wb3JhcnkpIHtcbiAgICAgICAgdGhpcy51c2VUZW1wb3JhcnlSZWxheShyZWxheSwgM2U0LCBmaWx0ZXJzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWRkUmVsYXkocmVsYXksIGNvbm5lY3QpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVsYXk7XG4gIH1cbiAgaGFuZGxlUmVsYXlDb25uZWN0KHJlbGF5VXJsKSB7XG4gICAgY29uc3QgcmVsYXkgPSB0aGlzLnJlbGF5cy5nZXQocmVsYXlVcmwpO1xuICAgIGlmICghcmVsYXkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJOREsgQlVHOiByZWxheSBub3QgZm91bmQgaW4gcG9vbFwiLCB7IHJlbGF5VXJsIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoXCJyZWxheTpjb25uZWN0XCIsIHJlbGF5KTtcbiAgICBpZiAodGhpcy5zdGF0cygpLmNvbm5lY3RlZCA9PT0gdGhpcy5yZWxheXMuc2l6ZSkge1xuICAgICAgdGhpcy5lbWl0KFwiY29ubmVjdFwiKTtcbiAgICB9XG4gIH1cbiAgaGFuZGxlUmVsYXlSZWFkeShyZWxheSkge1xuICAgIHRoaXMuZW1pdChcInJlbGF5OnJlYWR5XCIsIHJlbGF5KTtcbiAgfVxuICAvKipcbiAgICogQXR0ZW1wdHMgdG8gZXN0YWJsaXNoIGEgY29ubmVjdGlvbiB0byBlYWNoIHJlbGF5IGluIHRoZSBwb29sLlxuICAgKlxuICAgKiBAYXN5bmNcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt0aW1lb3V0TXNdIC0gT3B0aW9uYWwgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgZm9yIGVhY2ggY29ubmVjdGlvbiBhdHRlbXB0LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiBhbGwgY29ubmVjdGlvbiBhdHRlbXB0cyBoYXZlIGNvbXBsZXRlZC5cbiAgICogQHRocm93cyB7RXJyb3J9IElmIGFueSBvZiB0aGUgY29ubmVjdGlvbiBhdHRlbXB0cyByZXN1bHQgaW4gYW4gZXJyb3Igb3IgdGltZW91dC5cbiAgICovXG4gIGFzeW5jIGNvbm5lY3QodGltZW91dE1zKSB7XG4gICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICB0aGlzLnN0YXR1cyA9IFwiYWN0aXZlXCI7XG4gICAgdGhpcy5kZWJ1ZyhcbiAgICAgIGBDb25uZWN0aW5nIHRvICR7dGhpcy5yZWxheXMuc2l6ZX0gcmVsYXlzJHt0aW1lb3V0TXMgPyBgLCB0aW1lb3V0ICR7dGltZW91dE1zfS4uLmAgOiBcIlwifWBcbiAgICApO1xuICAgIGNvbnN0IHJlbGF5c1RvQ29ubmVjdCA9IG5ldyBTZXQodGhpcy5hdXRvQ29ubmVjdFJlbGF5cy5rZXlzKCkpO1xuICAgIGZvciAoY29uc3QgcmVsYXlVcmwgb2YgcmVsYXlzVG9Db25uZWN0KSB7XG4gICAgICBjb25zdCByZWxheSA9IHRoaXMucmVsYXlzLmdldChyZWxheVVybCk7XG4gICAgICBpZiAoIXJlbGF5KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBSZWxheSAke3JlbGF5VXJsfSBub3QgZm91bmQgaW4gcG9vbCAke3RoaXMubmFtZX1gKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBjb25uZWN0UHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdGhpcy5lbWl0KFwicmVsYXk6Y29ubmVjdGluZ1wiLCByZWxheSk7XG4gICAgICAgIHJldHVybiByZWxheS5jb25uZWN0KHRpbWVvdXRNcykudGhlbihyZXNvbHZlKS5jYXRjaChyZWplY3QpO1xuICAgICAgfSk7XG4gICAgICBpZiAodGltZW91dE1zKSB7XG4gICAgICAgIGNvbnN0IHRpbWVvdXRQcm9taXNlID0gbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gcmVqZWN0KGBUaW1lZCBvdXQgYWZ0ZXIgJHt0aW1lb3V0TXN9bXNgKSwgdGltZW91dE1zKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHByb21pc2VzLnB1c2goXG4gICAgICAgICAgUHJvbWlzZS5yYWNlKFtjb25uZWN0UHJvbWlzZSwgdGltZW91dFByb21pc2VdKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5kZWJ1ZyhcbiAgICAgICAgICAgICAgYEZhaWxlZCB0byBjb25uZWN0IHRvIHJlbGF5ICR7cmVsYXkudXJsfTogJHtlID8/IFwiTm8gcmVhc29uIHNwZWNpZmllZFwifWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb21pc2VzLnB1c2goY29ubmVjdFByb21pc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBtYXliZUVtaXRDb25uZWN0ID0gKCkgPT4ge1xuICAgICAgY29uc3QgYWxsQ29ubmVjdGVkID0gdGhpcy5zdGF0cygpLmNvbm5lY3RlZCA9PT0gdGhpcy5yZWxheXMuc2l6ZTtcbiAgICAgIGNvbnN0IHNvbWVDb25uZWN0ZWQgPSB0aGlzLnN0YXRzKCkuY29ubmVjdGVkID4gMDtcbiAgICAgIGlmICghYWxsQ29ubmVjdGVkICYmIHNvbWVDb25uZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5lbWl0KFwiY29ubmVjdFwiKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmICh0aW1lb3V0TXMpXG4gICAgICBzZXRUaW1lb3V0KG1heWJlRW1pdENvbm5lY3QsIHRpbWVvdXRNcyk7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgIG1heWJlRW1pdENvbm5lY3QoKTtcbiAgfVxuICBjaGVja09uRmxhcHBpbmdSZWxheXMoKSB7XG4gICAgY29uc3QgZmxhcHBpbmdSZWxheXNDb3VudCA9IHRoaXMuZmxhcHBpbmdSZWxheXMuc2l6ZTtcbiAgICBjb25zdCB0b3RhbFJlbGF5cyA9IHRoaXMucmVsYXlzLnNpemU7XG4gICAgaWYgKGZsYXBwaW5nUmVsYXlzQ291bnQgLyB0b3RhbFJlbGF5cyA+PSAwLjgpIHtcbiAgICAgIGZvciAoY29uc3QgcmVsYXlVcmwgb2YgdGhpcy5mbGFwcGluZ1JlbGF5cykge1xuICAgICAgICB0aGlzLmJhY2tvZmZUaW1lcy5zZXQocmVsYXlVcmwsIDApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBoYW5kbGVGbGFwcGluZyhyZWxheSkge1xuICAgIHRoaXMuZGVidWcoYFJlbGF5ICR7cmVsYXkudXJsfSBpcyBmbGFwcGluZ2ApO1xuICAgIGxldCBjdXJyZW50QmFja29mZiA9IHRoaXMuYmFja29mZlRpbWVzLmdldChyZWxheS51cmwpIHx8IDVlMztcbiAgICBjdXJyZW50QmFja29mZiA9IGN1cnJlbnRCYWNrb2ZmICogMjtcbiAgICB0aGlzLmJhY2tvZmZUaW1lcy5zZXQocmVsYXkudXJsLCBjdXJyZW50QmFja29mZik7XG4gICAgdGhpcy5kZWJ1ZyhgQmFja29mZiB0aW1lIGZvciAke3JlbGF5LnVybH0gaXMgJHtjdXJyZW50QmFja29mZn1tc2ApO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5kZWJ1ZyhgQXR0ZW1wdGluZyB0byByZWNvbm5lY3QgdG8gJHtyZWxheS51cmx9YCk7XG4gICAgICB0aGlzLmVtaXQoXCJyZWxheTpjb25uZWN0aW5nXCIsIHJlbGF5KTtcbiAgICAgIHJlbGF5LmNvbm5lY3QoKTtcbiAgICAgIHRoaXMuY2hlY2tPbkZsYXBwaW5nUmVsYXlzKCk7XG4gICAgfSwgY3VycmVudEJhY2tvZmYpO1xuICAgIHJlbGF5LmRpc2Nvbm5lY3QoKTtcbiAgICB0aGlzLmVtaXQoXCJmbGFwcGluZ1wiLCByZWxheSk7XG4gIH1cbiAgc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWxheXMuc2l6ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3RhdHVzIG9mIGVhY2ggcmVsYXkgaW4gdGhlIHBvb2wuXG4gICAqIEByZXR1cm5zIHtOREtQb29sU3RhdHN9IEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBudW1iZXIgb2YgcmVsYXlzIGluIGVhY2ggc3RhdHVzLlxuICAgKi9cbiAgc3RhdHMoKSB7XG4gICAgY29uc3Qgc3RhdHMgPSB7XG4gICAgICB0b3RhbDogMCxcbiAgICAgIGNvbm5lY3RlZDogMCxcbiAgICAgIGRpc2Nvbm5lY3RlZDogMCxcbiAgICAgIGNvbm5lY3Rpbmc6IDBcbiAgICB9O1xuICAgIGZvciAoY29uc3QgcmVsYXkgb2YgdGhpcy5yZWxheXMudmFsdWVzKCkpIHtcbiAgICAgIHN0YXRzLnRvdGFsKys7XG4gICAgICBpZiAocmVsYXkuc3RhdHVzID09PSA1IC8qIENPTk5FQ1RFRCAqLykge1xuICAgICAgICBzdGF0cy5jb25uZWN0ZWQrKztcbiAgICAgIH0gZWxzZSBpZiAocmVsYXkuc3RhdHVzID09PSAxIC8qIERJU0NPTk5FQ1RFRCAqLykge1xuICAgICAgICBzdGF0cy5kaXNjb25uZWN0ZWQrKztcbiAgICAgIH0gZWxzZSBpZiAocmVsYXkuc3RhdHVzID09PSA0IC8qIENPTk5FQ1RJTkcgKi8pIHtcbiAgICAgICAgc3RhdHMuY29ubmVjdGluZysrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RhdHM7XG4gIH1cbiAgY29ubmVjdGVkUmVsYXlzKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMucmVsYXlzLnZhbHVlcygpKS5maWx0ZXIoXG4gICAgICAocmVsYXkpID0+IHJlbGF5LnN0YXR1cyA+PSA1IC8qIENPTk5FQ1RFRCAqL1xuICAgICk7XG4gIH1cbiAgcGVybWFuZW50QW5kQ29ubmVjdGVkUmVsYXlzKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMucmVsYXlzLnZhbHVlcygpKS5maWx0ZXIoXG4gICAgICAocmVsYXkpID0+IHJlbGF5LnN0YXR1cyA+PSA1IC8qIENPTk5FQ1RFRCAqLyAmJiAhdGhpcy50ZW1wb3JhcnlSZWxheVRpbWVycy5oYXMocmVsYXkudXJsKVxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhIGxpc3Qgb2YgYWxsIHJlbGF5IHVybHMgaW4gdGhlIHBvb2wuXG4gICAqL1xuICB1cmxzKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMucmVsYXlzLmtleXMoKSk7XG4gIH1cbn07XG5cbi8vIHNyYy91c2VyL2luZGV4LnRzXG5pbXBvcnQgeyBuaXAxOSBhcyBuaXAxOTUgfSBmcm9tIFwibm9zdHItdG9vbHNcIjtcblxuLy8gc3JjL3N1YnNjcmlwdGlvbi9pbmRleC50c1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIGFzIEV2ZW50RW1pdHRlcjQgfSBmcm9tIFwidHNlZXBcIjtcblxuLy8gc3JjL3N1YnNjcmlwdGlvbi91dGlscy50c1xuaW1wb3J0IHsgbmlwMTkgYXMgbmlwMTkzIH0gZnJvbSBcIm5vc3RyLXRvb2xzXCI7XG52YXIgTUFYX1NVQklEX0xFTkdUSCA9IDIwO1xuZnVuY3Rpb24gcXVlcnlGdWxseUZpbGxlZChzdWJzY3JpcHRpb24pIHtcbiAgaWYgKGZpbHRlckluY2x1ZGVzSWRzKHN1YnNjcmlwdGlvbi5maWx0ZXIpKSB7XG4gICAgaWYgKHJlc3VsdEhhc0FsbFJlcXVlc3RlZElkcyhzdWJzY3JpcHRpb24pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY29tcGFyZUZpbHRlcihmaWx0ZXIxLCBmaWx0ZXIyKSB7XG4gIGlmIChPYmplY3Qua2V5cyhmaWx0ZXIxKS5sZW5ndGggIT09IE9iamVjdC5rZXlzKGZpbHRlcjIpLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhmaWx0ZXIxKSkge1xuICAgIGNvbnN0IHZhbHVlc0luRmlsdGVyMiA9IGZpbHRlcjJba2V5XTtcbiAgICBpZiAoIXZhbHVlc0luRmlsdGVyMikgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSAmJiBBcnJheS5pc0FycmF5KHZhbHVlc0luRmlsdGVyMikpIHtcbiAgICAgIGNvbnN0IHYgPSB2YWx1ZTtcbiAgICAgIGZvciAoY29uc3QgdmFsdWVJbkZpbHRlcjIgb2YgdmFsdWVzSW5GaWx0ZXIyKSB7XG4gICAgICAgIGNvbnN0IHZhbCA9IHZhbHVlSW5GaWx0ZXIyO1xuICAgICAgICBpZiAoIXYuaW5jbHVkZXModmFsKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodmFsdWVzSW5GaWx0ZXIyICE9PSB2YWx1ZSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGZpbHRlckluY2x1ZGVzSWRzKGZpbHRlcikge1xuICByZXR1cm4gISFmaWx0ZXJbXCJpZHNcIl07XG59XG5mdW5jdGlvbiByZXN1bHRIYXNBbGxSZXF1ZXN0ZWRJZHMoc3Vic2NyaXB0aW9uKSB7XG4gIGNvbnN0IGlkcyA9IHN1YnNjcmlwdGlvbi5maWx0ZXJbXCJpZHNcIl07XG4gIHJldHVybiAhIWlkcyAmJiBpZHMubGVuZ3RoID09PSBzdWJzY3JpcHRpb24uZXZlbnRGaXJzdFNlZW4uc2l6ZTtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlU3ViSWQoc3Vic2NyaXB0aW9ucywgZmlsdGVycykge1xuICBjb25zdCBzdWJJZHMgPSBzdWJzY3JpcHRpb25zLm1hcCgoc3ViKSA9PiBzdWIuc3ViSWQpLmZpbHRlcihCb29sZWFuKTtcbiAgY29uc3Qgc3ViSWRQYXJ0cyA9IFtdO1xuICBjb25zdCBmaWx0ZXJOb25LaW5kS2V5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0IGZpbHRlcktpbmRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgaWYgKHN1Yklkcy5sZW5ndGggPiAwKSB7XG4gICAgc3ViSWRQYXJ0cy5wdXNoKEFycmF5LmZyb20obmV3IFNldChzdWJJZHMpKS5qb2luKFwiLFwiKSk7XG4gIH0gZWxzZSB7XG4gICAgZm9yIChjb25zdCBmaWx0ZXIgb2YgZmlsdGVycykge1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoZmlsdGVyKSkge1xuICAgICAgICBpZiAoa2V5ID09PSBcImtpbmRzXCIpIHtcbiAgICAgICAgICBmaWx0ZXIua2luZHM/LmZvckVhY2goKGspID0+IGZpbHRlcktpbmRzLmFkZChrKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmlsdGVyTm9uS2luZEtleXMuYWRkKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZpbHRlcktpbmRzLnNpemUgPiAwKSB7XG4gICAgICBzdWJJZFBhcnRzLnB1c2goXCJraW5kczpcIiArIEFycmF5LmZyb20oZmlsdGVyS2luZHMpLmpvaW4oXCIsXCIpKTtcbiAgICB9XG4gICAgaWYgKGZpbHRlck5vbktpbmRLZXlzLnNpemUgPiAwKSB7XG4gICAgICBzdWJJZFBhcnRzLnB1c2goQXJyYXkuZnJvbShmaWx0ZXJOb25LaW5kS2V5cykuam9pbihcIixcIikpO1xuICAgIH1cbiAgfVxuICBsZXQgc3ViSWQgPSBzdWJJZFBhcnRzLmpvaW4oXCItXCIpO1xuICBpZiAoc3ViSWQubGVuZ3RoID4gTUFYX1NVQklEX0xFTkdUSCkgc3ViSWQgPSBzdWJJZC5zdWJzdHJpbmcoMCwgTUFYX1NVQklEX0xFTkdUSCk7XG4gIHN1YklkICs9IFwiLVwiICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogOTk5KS50b1N0cmluZygpO1xuICByZXR1cm4gc3ViSWQ7XG59XG5mdW5jdGlvbiBmaWx0ZXJGb3JFdmVudHNUYWdnaW5nSWQoaWQpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBkZWNvZGVkID0gbmlwMTkzLmRlY29kZShpZCk7XG4gICAgc3dpdGNoIChkZWNvZGVkLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJuYWRkclwiOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIFwiI2FcIjogW1xuICAgICAgICAgICAgYCR7ZGVjb2RlZC5kYXRhLmtpbmR9OiR7ZGVjb2RlZC5kYXRhLnB1YmtleX06JHtkZWNvZGVkLmRhdGEuaWRlbnRpZmllcn1gXG4gICAgICAgICAgXVxuICAgICAgICB9O1xuICAgICAgY2FzZSBcIm5ldmVudFwiOlxuICAgICAgICByZXR1cm4geyBcIiNlXCI6IFtkZWNvZGVkLmRhdGEuaWRdIH07XG4gICAgICBjYXNlIFwibm90ZVwiOlxuICAgICAgICByZXR1cm4geyBcIiNlXCI6IFtkZWNvZGVkLmRhdGFdIH07XG4gICAgICBjYXNlIFwibnByb2ZpbGVcIjpcbiAgICAgICAgcmV0dXJuIHsgXCIjcFwiOiBbZGVjb2RlZC5kYXRhLnB1YmtleV0gfTtcbiAgICAgIGNhc2UgXCJucHViXCI6XG4gICAgICAgIHJldHVybiB7IFwiI3BcIjogW2RlY29kZWQuZGF0YV0gfTtcbiAgICB9XG4gIH0gY2F0Y2gge1xuICB9XG59XG5mdW5jdGlvbiBmaWx0ZXJBbmRSZWxheVNldEZyb21CZWNoMzIoYmVjaGUyLCBuZGspIHtcbiAgY29uc3QgZmlsdGVyID0gZmlsdGVyRnJvbUlkKGJlY2hlMik7XG4gIGNvbnN0IHJlbGF5cyA9IHJlbGF5c0Zyb21CZWNoMzIoYmVjaGUyLCBuZGspO1xuICBpZiAocmVsYXlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHsgZmlsdGVyIH07XG4gIHJldHVybiB7XG4gICAgZmlsdGVyLFxuICAgIHJlbGF5U2V0OiBuZXcgTkRLUmVsYXlTZXQobmV3IFNldChyZWxheXMpLCBuZGspXG4gIH07XG59XG5mdW5jdGlvbiBmaWx0ZXJGcm9tSWQoaWQpIHtcbiAgbGV0IGRlY29kZWQ7XG4gIGlmIChpZC5tYXRjaChOSVAzM19BX1JFR0VYKSkge1xuICAgIGNvbnN0IFtraW5kLCBwdWJrZXksIGlkZW50aWZpZXJdID0gaWQuc3BsaXQoXCI6XCIpO1xuICAgIGNvbnN0IGZpbHRlciA9IHtcbiAgICAgIGF1dGhvcnM6IFtwdWJrZXldLFxuICAgICAga2luZHM6IFtwYXJzZUludChraW5kKV1cbiAgICB9O1xuICAgIGlmIChpZGVudGlmaWVyKSB7XG4gICAgICBmaWx0ZXJbXCIjZFwiXSA9IFtpZGVudGlmaWVyXTtcbiAgICB9XG4gICAgcmV0dXJuIGZpbHRlcjtcbiAgfVxuICBpZiAoaWQubWF0Y2goQkVDSDMyX1JFR0VYKSkge1xuICAgIHRyeSB7XG4gICAgICBkZWNvZGVkID0gbmlwMTkzLmRlY29kZShpZCk7XG4gICAgICBzd2l0Y2ggKGRlY29kZWQudHlwZSkge1xuICAgICAgICBjYXNlIFwibmV2ZW50XCI6IHtcbiAgICAgICAgICBjb25zdCBmaWx0ZXIyID0geyBpZHM6IFtkZWNvZGVkLmRhdGEuaWRdIH07XG4gICAgICAgICAgaWYgKGRlY29kZWQuZGF0YS5hdXRob3IpIGZpbHRlcjIuYXV0aG9ycyA9IFtkZWNvZGVkLmRhdGEuYXV0aG9yXTtcbiAgICAgICAgICBpZiAoZGVjb2RlZC5kYXRhLmtpbmQpIGZpbHRlcjIua2luZHMgPSBbZGVjb2RlZC5kYXRhLmtpbmRdO1xuICAgICAgICAgIHJldHVybiBmaWx0ZXIyO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJub3RlXCI6XG4gICAgICAgICAgcmV0dXJuIHsgaWRzOiBbZGVjb2RlZC5kYXRhXSB9O1xuICAgICAgICBjYXNlIFwibmFkZHJcIjpcbiAgICAgICAgICBjb25zdCBmaWx0ZXIgPSB7XG4gICAgICAgICAgICBhdXRob3JzOiBbZGVjb2RlZC5kYXRhLnB1YmtleV0sXG4gICAgICAgICAgICBraW5kczogW2RlY29kZWQuZGF0YS5raW5kXVxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKGRlY29kZWQuZGF0YS5pZGVudGlmaWVyKSBmaWx0ZXJbXCIjZFwiXSA9IFtkZWNvZGVkLmRhdGEuaWRlbnRpZmllcl07XG4gICAgICAgICAgcmV0dXJuIGZpbHRlcjtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZGVjb2RpbmdcIiwgaWQsIGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4geyBpZHM6IFtpZF0gfTtcbn1cbmZ1bmN0aW9uIGlzTmlwMzNBVmFsdWUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLm1hdGNoKE5JUDMzX0FfUkVHRVgpICE9PSBudWxsO1xufVxudmFyIE5JUDMzX0FfUkVHRVggPSAvXihcXGQrKTooWzAtOUEtRmEtZl0rKSg/OjooLiopKT8kLztcbnZhciBCRUNIMzJfUkVHRVggPSAvXm4oZXZlbnR8b3RlfHByb2ZpbGV8cHVifGFkZHIpMVtcXGRcXHddKyQvO1xuZnVuY3Rpb24gcmVsYXlzRnJvbUJlY2gzMihiZWNoMzIyLCBuZGspIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBkZWNvZGVkID0gbmlwMTkzLmRlY29kZShiZWNoMzIyKTtcbiAgICBpZiAoW1wibmFkZHJcIiwgXCJuZXZlbnRcIl0uaW5jbHVkZXMoZGVjb2RlZD8udHlwZSkpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSBkZWNvZGVkLmRhdGE7XG4gICAgICBpZiAoZGF0YT8ucmVsYXlzKSB7XG4gICAgICAgIHJldHVybiBkYXRhLnJlbGF5cy5tYXAoXG4gICAgICAgICAgKHIpID0+IG5ldyBOREtSZWxheShyLCBuZGsucmVsYXlBdXRoRGVmYXVsdFBvbGljeSwgbmRrKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICB9XG4gIHJldHVybiBbXTtcbn1cblxuLy8gc3JjL2V2ZW50cy9raW5kcy9hcnRpY2xlLnRzXG52YXIgTkRLQXJ0aWNsZSA9IGNsYXNzIF9OREtBcnRpY2xlIGV4dGVuZHMgTkRLRXZlbnQge1xuICBzdGF0aWMga2luZCA9IDMwMDIzIC8qIEFydGljbGUgKi87XG4gIHN0YXRpYyBraW5kcyA9IFszMDAyMyAvKiBBcnRpY2xlICovXTtcbiAgY29uc3RydWN0b3IobmRrLCByYXdFdmVudCkge1xuICAgIHN1cGVyKG5kaywgcmF3RXZlbnQpO1xuICAgIHRoaXMua2luZCA/Pz0gMzAwMjMgLyogQXJ0aWNsZSAqLztcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIE5ES0FydGljbGUgZnJvbSBhbiBleGlzdGluZyBOREtFdmVudC5cbiAgICpcbiAgICogQHBhcmFtIGV2ZW50IE5ES0V2ZW50IHRvIGNyZWF0ZSB0aGUgTkRLQXJ0aWNsZSBmcm9tLlxuICAgKiBAcmV0dXJucyBOREtBcnRpY2xlXG4gICAqL1xuICBzdGF0aWMgZnJvbShldmVudCkge1xuICAgIHJldHVybiBuZXcgX05ES0FydGljbGUoZXZlbnQubmRrLCBldmVudCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHRlciBmb3IgdGhlIGFydGljbGUgdGl0bGUuXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmcgfCB1bmRlZmluZWR9IC0gVGhlIGFydGljbGUgdGl0bGUgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgdW5kZWZpbmVkLlxuICAgKi9cbiAgZ2V0IHRpdGxlKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwidGl0bGVcIik7XG4gIH1cbiAgLyoqXG4gICAqIFNldHRlciBmb3IgdGhlIGFydGljbGUgdGl0bGUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSB0aXRsZSAtIFRoZSB0aXRsZSB0byBzZXQgZm9yIHRoZSBhcnRpY2xlLlxuICAgKi9cbiAgc2V0IHRpdGxlKHRpdGxlKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJ0aXRsZVwiKTtcbiAgICBpZiAodGl0bGUpIHRoaXMudGFncy5wdXNoKFtcInRpdGxlXCIsIHRpdGxlXSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHRlciBmb3IgdGhlIGFydGljbGUgaW1hZ2UuXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmcgfCB1bmRlZmluZWR9IC0gVGhlIGFydGljbGUgaW1hZ2UgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgdW5kZWZpbmVkLlxuICAgKi9cbiAgZ2V0IGltYWdlKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwiaW1hZ2VcIik7XG4gIH1cbiAgLyoqXG4gICAqIFNldHRlciBmb3IgdGhlIGFydGljbGUgaW1hZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBpbWFnZSAtIFRoZSBpbWFnZSB0byBzZXQgZm9yIHRoZSBhcnRpY2xlLlxuICAgKi9cbiAgc2V0IGltYWdlKGltYWdlKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJpbWFnZVwiKTtcbiAgICBpZiAoaW1hZ2UpIHRoaXMudGFncy5wdXNoKFtcImltYWdlXCIsIGltYWdlXSk7XG4gIH1cbiAgZ2V0IHN1bW1hcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJzdW1tYXJ5XCIpO1xuICB9XG4gIHNldCBzdW1tYXJ5KHN1bW1hcnkpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInN1bW1hcnlcIik7XG4gICAgaWYgKHN1bW1hcnkpIHRoaXMudGFncy5wdXNoKFtcInN1bW1hcnlcIiwgc3VtbWFyeV0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXR0ZXIgZm9yIHRoZSBhcnRpY2xlJ3MgcHVibGljYXRpb24gdGltZXN0YW1wLlxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyIHwgdW5kZWZpbmVkfSAtIFRoZSBVbml4IHRpbWVzdGFtcCBvZiB3aGVuIHRoZSBhcnRpY2xlIHdhcyBwdWJsaXNoZWQgb3IgdW5kZWZpbmVkLlxuICAgKi9cbiAgZ2V0IHB1Ymxpc2hlZF9hdCgpIHtcbiAgICBjb25zdCB0YWcgPSB0aGlzLnRhZ1ZhbHVlKFwicHVibGlzaGVkX2F0XCIpO1xuICAgIGlmICh0YWcpIHtcbiAgICAgIGxldCB2YWwgPSBwYXJzZUludCh0YWcpO1xuICAgICAgaWYgKHZhbCA+IDFlMTIpIHtcbiAgICAgICAgdmFsID0gTWF0aC5mbG9vcih2YWwgLyAxZTMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICAvKipcbiAgICogU2V0dGVyIGZvciB0aGUgYXJ0aWNsZSdzIHB1YmxpY2F0aW9uIHRpbWVzdGFtcC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXIgfCB1bmRlZmluZWR9IHRpbWVzdGFtcCAtIFRoZSBVbml4IHRpbWVzdGFtcCB0byBzZXQgZm9yIHRoZSBhcnRpY2xlJ3MgcHVibGljYXRpb24gZGF0ZS5cbiAgICovXG4gIHNldCBwdWJsaXNoZWRfYXQodGltZXN0YW1wKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJwdWJsaXNoZWRfYXRcIik7XG4gICAgaWYgKHRpbWVzdGFtcCAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJwdWJsaXNoZWRfYXRcIiwgdGltZXN0YW1wLnRvU3RyaW5nKCldKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBjb250ZW50IHRhZ3MgZm9yIHRoZSBhcnRpY2xlLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBmaXJzdCBjaGVja3MgYW5kIHNldHMgdGhlIHB1YmxpY2F0aW9uIGRhdGUgaWYgbm90IGF2YWlsYWJsZSxcbiAgICogYW5kIHRoZW4gZ2VuZXJhdGVzIGNvbnRlbnQgdGFncyBiYXNlZCBvbiB0aGUgYmFzZSBOREtFdmVudCBjbGFzcy5cbiAgICpcbiAgICogQHJldHVybnMge0NvbnRlbnRUYWd9IC0gVGhlIGdlbmVyYXRlZCBjb250ZW50IHRhZ3MuXG4gICAqL1xuICBhc3luYyBnZW5lcmF0ZVRhZ3MoKSB7XG4gICAgc3VwZXIuZ2VuZXJhdGVUYWdzKCk7XG4gICAgaWYgKCF0aGlzLnB1Ymxpc2hlZF9hdCkge1xuICAgICAgdGhpcy5wdWJsaXNoZWRfYXQgPSB0aGlzLmNyZWF0ZWRfYXQ7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5nZW5lcmF0ZVRhZ3MoKTtcbiAgfVxuICAvKipcbiAgICogR2V0dGVyIGZvciB0aGUgYXJ0aWNsZSdzIFVSTC5cbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZyB8IHVuZGVmaW5lZH0gLSBUaGUgYXJ0aWNsZSdzIFVSTCBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSB1bmRlZmluZWQuXG4gICAqL1xuICBnZXQgdXJsKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwidXJsXCIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXR0ZXIgZm9yIHRoZSBhcnRpY2xlJ3MgVVJMLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gdXJsIC0gVGhlIFVSTCB0byBzZXQgZm9yIHRoZSBhcnRpY2xlLlxuICAgKi9cbiAgc2V0IHVybCh1cmwpIHtcbiAgICBpZiAodXJsKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJ1cmxcIiwgdXJsXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlVGFnKFwidXJsXCIpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2V2ZW50cy9raW5kcy9jYXNodS90b2tlbi50c1xuZnVuY3Rpb24gcHJvb2ZzVG90YWxCYWxhbmNlKHByb29mcykge1xuICByZXR1cm4gcHJvb2ZzLnJlZHVjZSgoYWNjLCBwcm9vZikgPT4ge1xuICAgIGlmIChwcm9vZi5hbW91bnQgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwcm9vZiBhbW91bnQgaXMgbmVnYXRpdmVcIik7XG4gICAgfVxuICAgIHJldHVybiBhY2MgKyBwcm9vZi5hbW91bnQ7XG4gIH0sIDApO1xufVxudmFyIE5ES0Nhc2h1VG9rZW4gPSBjbGFzcyBfTkRLQ2FzaHVUb2tlbiBleHRlbmRzIE5ES0V2ZW50IHtcbiAgX3Byb29mcyA9IFtdO1xuICBfbWludDtcbiAgc3RhdGljIGtpbmQgPSA3Mzc1IC8qIENhc2h1VG9rZW4gKi87XG4gIHN0YXRpYyBraW5kcyA9IFs3Mzc1IC8qIENhc2h1VG9rZW4gKi9dO1xuICAvKipcbiAgICogVG9rZW5zIHRoYXQgdGhpcyB0b2tlbiBzdXBlcnNlZWRzXG4gICAqL1xuICBfZGVsZXRlcyA9IFtdO1xuICBvcmlnaW5hbDtcbiAgY29uc3RydWN0b3IobmRrLCBldmVudCkge1xuICAgIHN1cGVyKG5kaywgZXZlbnQpO1xuICAgIHRoaXMua2luZCA/Pz0gNzM3NSAvKiBDYXNodVRva2VuICovO1xuICB9XG4gIHN0YXRpYyBhc3luYyBmcm9tKGV2ZW50KSB7XG4gICAgY29uc3QgdG9rZW4gPSBuZXcgX05ES0Nhc2h1VG9rZW4oZXZlbnQubmRrLCBldmVudCk7XG4gICAgdG9rZW4ub3JpZ2luYWwgPSBldmVudDtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdG9rZW4uZGVjcnlwdCgpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgdG9rZW4uY29udGVudCA9IHRva2VuLm9yaWdpbmFsLmNvbnRlbnQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBjb250ZW50ID0gSlNPTi5wYXJzZSh0b2tlbi5jb250ZW50KTtcbiAgICAgIHRva2VuLnByb29mcyA9IGNvbnRlbnQucHJvb2ZzO1xuICAgICAgdG9rZW4ubWludCA9IGNvbnRlbnQubWludCA/PyB0b2tlbi50YWdWYWx1ZShcIm1pbnRcIik7XG4gICAgICB0b2tlbi5kZWxldGVkVG9rZW5zID0gY29udGVudC5kZWwgPz8gW107XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkodG9rZW4ucHJvb2ZzKSkgcmV0dXJuO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHRva2VuO1xuICB9XG4gIGdldCBwcm9vZnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Byb29mcztcbiAgfVxuICBzZXQgcHJvb2ZzKHByb29mcykge1xuICAgIGNvbnN0IGNzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB0aGlzLl9wcm9vZnMgPSBwcm9vZnMuZmlsdGVyKChwcm9vZikgPT4ge1xuICAgICAgaWYgKGNzLmhhcyhwcm9vZi5DKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJQYXNzZWQgaW4gcHJvb2ZzIGhhZCBkdXBsaWNhdGVzLCBpZ25vcmluZ1wiLCBwcm9vZi5DKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHByb29mLmFtb3VudCA8IDApIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiSW52YWxpZCBwcm9vZiB3aXRoIG5lZ2F0aXZlIGFtb3VudFwiLCBwcm9vZik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNzLmFkZChwcm9vZi5DKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pLm1hcCh0aGlzLmNsZWFuUHJvb2YpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbWluaW1hbCBwcm9vZiBvYmplY3Qgd2l0aCBvbmx5IGVzc2VudGlhbCBwcm9wZXJ0aWVzXG4gICAqL1xuICBjbGVhblByb29mKHByb29mKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiBwcm9vZi5pZCxcbiAgICAgIGFtb3VudDogcHJvb2YuYW1vdW50LFxuICAgICAgQzogcHJvb2YuQyxcbiAgICAgIHNlY3JldDogcHJvb2Yuc2VjcmV0XG4gICAgfTtcbiAgfVxuICBhc3luYyB0b05vc3RyRXZlbnQocHVia2V5KSB7XG4gICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgIHByb29mczogdGhpcy5wcm9vZnMubWFwKHRoaXMuY2xlYW5Qcm9vZiksXG4gICAgICBtaW50OiB0aGlzLm1pbnQsXG4gICAgICBkZWw6IHRoaXMuZGVsZXRlZFRva2VucyA/PyBbXVxuICAgIH07XG4gICAgdGhpcy5jb250ZW50ID0gSlNPTi5zdHJpbmdpZnkocGF5bG9hZCk7XG4gICAgY29uc3QgdXNlciA9IGF3YWl0IHRoaXMubmRrLnNpZ25lci51c2VyKCk7XG4gICAgYXdhaXQgdGhpcy5lbmNyeXB0KHVzZXIsIHZvaWQgMCwgXCJuaXA0NFwiKTtcbiAgICByZXR1cm4gc3VwZXIudG9Ob3N0ckV2ZW50KHB1YmtleSk7XG4gIH1cbiAgc2V0IG1pbnQobWludCkge1xuICAgIHRoaXMuX21pbnQgPSBtaW50O1xuICB9XG4gIGdldCBtaW50KCkge1xuICAgIHJldHVybiB0aGlzLl9taW50O1xuICB9XG4gIC8qKlxuICAgKiBUb2tlbnMgdGhhdCB3ZXJlIGRlbGV0ZWQgYnkgdGhlIGNyZWF0aW9uIG9mIHRoaXMgdG9rZW4uXG4gICAqL1xuICBnZXQgZGVsZXRlZFRva2VucygpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVsZXRlcztcbiAgfVxuICAvKipcbiAgICogTWFya3MgdG9rZW5zIHRoYXQgd2VyZSBkZWxldGVkIGJ5IHRoZSBjcmVhdGlvbiBvZiB0aGlzIHRva2VuLlxuICAgKi9cbiAgc2V0IGRlbGV0ZWRUb2tlbnModG9rZW5JZHMpIHtcbiAgICB0aGlzLl9kZWxldGVzID0gdG9rZW5JZHM7XG4gIH1cbiAgZ2V0IGFtb3VudCgpIHtcbiAgICByZXR1cm4gcHJvb2ZzVG90YWxCYWxhbmNlKHRoaXMucHJvb2ZzKTtcbiAgfVxuICBhc3luYyBwdWJsaXNoKHJlbGF5U2V0LCB0aW1lb3V0TXMsIHJlcXVpcmVkUmVsYXlDb3VudCkge1xuICAgIGlmICh0aGlzLm9yaWdpbmFsKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcmlnaW5hbC5wdWJsaXNoKHJlbGF5U2V0LCB0aW1lb3V0TXMsIHJlcXVpcmVkUmVsYXlDb3VudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzdXBlci5wdWJsaXNoKHJlbGF5U2V0LCB0aW1lb3V0TXMsIHJlcXVpcmVkUmVsYXlDb3VudCk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL2hpZ2hsaWdodC50c1xuaW1wb3J0IHsgbmlwMTkgYXMgbmlwMTk0IH0gZnJvbSBcIm5vc3RyLXRvb2xzXCI7XG52YXIgTkRLSGlnaGxpZ2h0ID0gY2xhc3MgX05ES0hpZ2hsaWdodCBleHRlbmRzIE5ES0V2ZW50IHtcbiAgX2FydGljbGU7XG4gIHN0YXRpYyBraW5kID0gOTgwMiAvKiBIaWdobGlnaHQgKi87XG4gIHN0YXRpYyBraW5kcyA9IFs5ODAyIC8qIEhpZ2hsaWdodCAqL107XG4gIGNvbnN0cnVjdG9yKG5kaywgcmF3RXZlbnQpIHtcbiAgICBzdXBlcihuZGssIHJhd0V2ZW50KTtcbiAgICB0aGlzLmtpbmQgPz89IDk4MDIgLyogSGlnaGxpZ2h0ICovO1xuICB9XG4gIHN0YXRpYyBmcm9tKGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLSGlnaGxpZ2h0KGV2ZW50Lm5kaywgZXZlbnQpO1xuICB9XG4gIGdldCB1cmwoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJyXCIpO1xuICB9XG4gIC8qKlxuICAgKiBDb250ZXh0IHRhZy5cbiAgICovXG4gIHNldCBjb250ZXh0KGNvbnRleHQpIHtcbiAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnRhZ3MgPSB0aGlzLnRhZ3MuZmlsdGVyKChbdGFnLCB2YWx1ZV0pID0+IHRhZyAhPT0gXCJjb250ZXh0XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRhZ3MgPSB0aGlzLnRhZ3MuZmlsdGVyKChbdGFnLCB2YWx1ZV0pID0+IHRhZyAhPT0gXCJjb250ZXh0XCIpO1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wiY29udGV4dFwiLCBjb250ZXh0XSk7XG4gICAgfVxuICB9XG4gIGdldCBjb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLnRhZ3MuZmluZCgoW3RhZywgdmFsdWVdKSA9PiB0YWcgPT09IFwiY29udGV4dFwiKT8uWzFdID8/IHZvaWQgMDtcbiAgfVxuICAvKipcbiAgICogV2lsbCByZXR1cm4gdGhlIGFydGljbGUgVVJMIG9yIE5ES0V2ZW50IGlmIHRoZXkgaGF2ZSBhbHJlYWR5IGJlZW5cbiAgICogc2V0IChpdCB3b24ndCBhdHRlbXB0IHRvIGxvYWQgcmVtb3RlIGV2ZW50cylcbiAgICovXG4gIGdldCBhcnRpY2xlKCkge1xuICAgIHJldHVybiB0aGlzLl9hcnRpY2xlO1xuICB9XG4gIC8qKlxuICAgKiBBcnRpY2xlIHRoZSBoaWdobGlnaHQgaXMgY29taW5nIGZyb20uXG4gICAqXG4gICAqIEBwYXJhbSBhcnRpY2xlIEFydGljbGUgVVJMIG9yIE5ES0V2ZW50LlxuICAgKi9cbiAgc2V0IGFydGljbGUoYXJ0aWNsZSkge1xuICAgIHRoaXMuX2FydGljbGUgPSBhcnRpY2xlO1xuICAgIGlmICh0eXBlb2YgYXJ0aWNsZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wiclwiLCBhcnRpY2xlXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudGFnKGFydGljbGUpO1xuICAgIH1cbiAgfVxuICBnZXRBcnRpY2xlVGFnKCkge1xuICAgIHJldHVybiB0aGlzLmdldE1hdGNoaW5nVGFncyhcImFcIilbMF0gfHwgdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJlXCIpWzBdIHx8IHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwiclwiKVswXTtcbiAgfVxuICBhc3luYyBnZXRBcnRpY2xlKCkge1xuICAgIGlmICh0aGlzLl9hcnRpY2xlICE9PSB2b2lkIDApIHJldHVybiB0aGlzLl9hcnRpY2xlO1xuICAgIGxldCB0YWdnZWRCZWNoMzI7XG4gICAgY29uc3QgYXJ0aWNsZVRhZyA9IHRoaXMuZ2V0QXJ0aWNsZVRhZygpO1xuICAgIGlmICghYXJ0aWNsZVRhZykgcmV0dXJuIHZvaWQgMDtcbiAgICBzd2l0Y2ggKGFydGljbGVUYWdbMF0pIHtcbiAgICAgIGNhc2UgXCJhXCI6XG4gICAgICAgIGNvbnN0IFtraW5kLCBwdWJrZXksIGlkZW50aWZpZXJdID0gYXJ0aWNsZVRhZ1sxXS5zcGxpdChcIjpcIik7XG4gICAgICAgIHRhZ2dlZEJlY2gzMiA9IG5pcDE5NC5uYWRkckVuY29kZSh7IGtpbmQ6IHBhcnNlSW50KGtpbmQpLCBwdWJrZXksIGlkZW50aWZpZXIgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImVcIjpcbiAgICAgICAgdGFnZ2VkQmVjaDMyID0gbmlwMTk0Lm5vdGVFbmNvZGUoYXJ0aWNsZVRhZ1sxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInJcIjpcbiAgICAgICAgdGhpcy5fYXJ0aWNsZSA9IGFydGljbGVUYWdbMV07XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAodGFnZ2VkQmVjaDMyKSB7XG4gICAgICBsZXQgYSA9IGF3YWl0IHRoaXMubmRrPy5mZXRjaEV2ZW50KHRhZ2dlZEJlY2gzMik7XG4gICAgICBpZiAoYSkge1xuICAgICAgICBpZiAoYS5raW5kID09PSAzMDAyMyAvKiBBcnRpY2xlICovKSB7XG4gICAgICAgICAgYSA9IE5ES0FydGljbGUuZnJvbShhKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hcnRpY2xlID0gYTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2FydGljbGU7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlscy9pbWV0YS50c1xuZnVuY3Rpb24gbWFwSW1ldGFUYWcodGFnKSB7XG4gIGNvbnN0IGRhdGEgPSB7fTtcbiAgaWYgKHRhZy5sZW5ndGggPT09IDIpIHtcbiAgICBjb25zdCBwYXJ0cyA9IHRhZ1sxXS5zcGxpdChcIiBcIik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgY29uc3Qga2V5ID0gcGFydHNbaV07XG4gICAgICBjb25zdCB2YWx1ZSA9IHBhcnRzW2kgKyAxXTtcbiAgICAgIGlmIChrZXkgPT09IFwiZmFsbGJhY2tcIikge1xuICAgICAgICBpZiAoIWRhdGEuZmFsbGJhY2spIGRhdGEuZmFsbGJhY2sgPSBbXTtcbiAgICAgICAgZGF0YS5mYWxsYmFjay5wdXNoKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGFba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IHZhbCBvZiB0YWcpIHtcbiAgICBjb25zdCBwYXJ0cyA9IHZhbC5zcGxpdChcIiBcIik7XG4gICAgY29uc3Qga2V5ID0gcGFydHNbMF07XG4gICAgY29uc3QgdmFsdWUgPSBwYXJ0cy5zbGljZSgxKS5qb2luKFwiIFwiKTtcbiAgICBpZiAoa2V5ID09PSBcImZhbGxiYWNrXCIpIHtcbiAgICAgIGlmICghZGF0YS5mYWxsYmFjaykgZGF0YS5mYWxsYmFjayA9IFtdO1xuICAgICAgZGF0YS5mYWxsYmFjay5wdXNoKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YVtrZXldID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBkYXRhO1xufVxuZnVuY3Rpb24gaW1ldGFUYWdUb1RhZyhpbWV0YSkge1xuICBjb25zdCB0YWcgPSBbXCJpbWV0YVwiXTtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoaW1ldGEpKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBmb3IgKGNvbnN0IHYgb2YgdmFsdWUpIHtcbiAgICAgICAgdGFnLnB1c2goa2V5LCB2KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICB0YWcucHVzaChrZXksIHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhZztcbn1cblxuLy8gc3JjL2V2ZW50cy9raW5kcy9pbWFnZS50c1xudmFyIE5ES0ltYWdlID0gY2xhc3MgX05ES0ltYWdlIGV4dGVuZHMgTkRLRXZlbnQge1xuICBzdGF0aWMga2luZCA9IDIwIC8qIEltYWdlICovO1xuICBzdGF0aWMga2luZHMgPSBbMjAgLyogSW1hZ2UgKi9dO1xuICBfaW1ldGFzO1xuICBjb25zdHJ1Y3RvcihuZGssIHJhd0V2ZW50KSB7XG4gICAgc3VwZXIobmRrLCByYXdFdmVudCk7XG4gICAgdGhpcy5raW5kID8/PSAyMCAvKiBJbWFnZSAqLztcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIE5ES0ltYWdlIGZyb20gYW4gZXhpc3RpbmcgTkRLRXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSBldmVudCBOREtFdmVudCB0byBjcmVhdGUgdGhlIE5ES0ltYWdlIGZyb20uXG4gICAqIEByZXR1cm5zIE5ES0ltYWdlXG4gICAqL1xuICBzdGF0aWMgZnJvbShldmVudCkge1xuICAgIHJldHVybiBuZXcgX05ES0ltYWdlKGV2ZW50Lm5kaywgZXZlbnQucmF3RXZlbnQoKSk7XG4gIH1cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW1ldGFzLmxlbmd0aCA+IDA7XG4gIH1cbiAgZ2V0IGltZXRhcygpIHtcbiAgICBpZiAodGhpcy5faW1ldGFzKSByZXR1cm4gdGhpcy5faW1ldGFzO1xuICAgIHRoaXMuX2ltZXRhcyA9IHRoaXMudGFncy5maWx0ZXIoKHRhZykgPT4gdGFnWzBdID09PSBcImltZXRhXCIpLm1hcChtYXBJbWV0YVRhZykuZmlsdGVyKChpbWV0YSkgPT4gISFpbWV0YS51cmwpO1xuICAgIHJldHVybiB0aGlzLl9pbWV0YXM7XG4gIH1cbiAgc2V0IGltZXRhcyh0YWdzKSB7XG4gICAgdGhpcy5faW1ldGFzID0gdGFncztcbiAgICB0aGlzLnRhZ3MgPSB0aGlzLnRhZ3MuZmlsdGVyKCh0YWcpID0+IHRhZ1swXSAhPT0gXCJpbWV0YVwiKTtcbiAgICB0aGlzLnRhZ3MucHVzaCguLi50YWdzLm1hcChpbWV0YVRhZ1RvVGFnKSk7XG4gIH1cbn07XG5cbi8vIHNyYy9ldmVudHMva2luZHMvbGlzdHMvaW5kZXgudHNcbnZhciBOREtMaXN0ID0gY2xhc3MgX05ES0xpc3QgZXh0ZW5kcyBOREtFdmVudCB7XG4gIF9lbmNyeXB0ZWRUYWdzO1xuICBzdGF0aWMga2luZHMgPSBbXG4gICAgMTAwNjMgLyogQmxvc3NvbUxpc3QgKi8sXG4gICAgMzAwMDEgLyogQ2F0ZWdvcml6ZWRCb29rbWFya0xpc3QgKi8sXG4gICAgMTAwMDQgLyogQ29tbXVuaXR5TGlzdCAqLyxcbiAgICAxMDA1MCAvKiBEaXJlY3RNZXNzYWdlUmVjZWl2ZVJlbGF5TGlzdCAqLyxcbiAgICAxMDAzMCAvKiBFbW9qaUxpc3QgKi8sXG4gICAgMTAwMTUgLyogSW50ZXJlc3RMaXN0ICovLFxuICAgIDEwMDAxIC8qIFBpbkxpc3QgKi8sXG4gICAgMTAwMDIgLyogUmVsYXlMaXN0ICovLFxuICAgIDEwMDA3IC8qIFNlYXJjaFJlbGF5TGlzdCAqLyxcbiAgICAxMDAwNiAvKiBCbG9ja1JlbGF5TGlzdCAqLyxcbiAgICAxMDAwMyAvKiBCb29rbWFya0xpc3QgKi9cbiAgXTtcbiAgLyoqXG4gICAqIFN0b3JlcyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBjb250ZW50IHdhcyBiZWZvcmUgZGVjcnlwdGlvblxuICAgKiB0byBleHBpcmUgdGhlIGNhY2hlIHdoZW4gdGhlIGNvbnRlbnQgY2hhbmdlcy5cbiAgICovXG4gIGVuY3J5cHRlZFRhZ3NMZW5ndGg7XG4gIGNvbnN0cnVjdG9yKG5kaywgcmF3RXZlbnQpIHtcbiAgICBzdXBlcihuZGssIHJhd0V2ZW50KTtcbiAgICB0aGlzLmtpbmQgPz89IDMwMDAxIC8qIENhdGVnb3JpemVkQm9va21hcmtMaXN0ICovO1xuICB9XG4gIC8qKlxuICAgKiBXcmFwIGEgTkRLRXZlbnQgaW50byBhIE5ES0xpc3RcbiAgICovXG4gIHN0YXRpYyBmcm9tKG5ka0V2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLTGlzdChuZGtFdmVudC5uZGssIG5ka0V2ZW50KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdGl0bGUgb2YgdGhlIGxpc3QuIEZhbGxzIGJhY2sgb24gZmV0Y2hpbmcgdGhlIG5hbWUgdGFnIHZhbHVlLlxuICAgKi9cbiAgZ2V0IHRpdGxlKCkge1xuICAgIGNvbnN0IHRpdGxlVGFnID0gdGhpcy50YWdWYWx1ZShcInRpdGxlXCIpIHx8IHRoaXMudGFnVmFsdWUoXCJuYW1lXCIpO1xuICAgIGlmICh0aXRsZVRhZykgcmV0dXJuIHRpdGxlVGFnO1xuICAgIGlmICh0aGlzLmtpbmQgPT09IDMgLyogQ29udGFjdHMgKi8pIHtcbiAgICAgIHJldHVybiBcIkNvbnRhY3RzXCI7XG4gICAgfSBlbHNlIGlmICh0aGlzLmtpbmQgPT09IDFlNCAvKiBNdXRlTGlzdCAqLykge1xuICAgICAgcmV0dXJuIFwiTXV0ZVwiO1xuICAgIH0gZWxzZSBpZiAodGhpcy5raW5kID09PSAxMDAwMSAvKiBQaW5MaXN0ICovKSB7XG4gICAgICByZXR1cm4gXCJQaW5uZWQgTm90ZXNcIjtcbiAgICB9IGVsc2UgaWYgKHRoaXMua2luZCA9PT0gMTAwMDIgLyogUmVsYXlMaXN0ICovKSB7XG4gICAgICByZXR1cm4gXCJSZWxheSBNZXRhZGF0YVwiO1xuICAgIH0gZWxzZSBpZiAodGhpcy5raW5kID09PSAxMDAwMyAvKiBCb29rbWFya0xpc3QgKi8pIHtcbiAgICAgIHJldHVybiBcIkJvb2ttYXJrc1wiO1xuICAgIH0gZWxzZSBpZiAodGhpcy5raW5kID09PSAxMDAwNCAvKiBDb21tdW5pdHlMaXN0ICovKSB7XG4gICAgICByZXR1cm4gXCJDb21tdW5pdGllc1wiO1xuICAgIH0gZWxzZSBpZiAodGhpcy5raW5kID09PSAxMDAwNSAvKiBQdWJsaWNDaGF0TGlzdCAqLykge1xuICAgICAgcmV0dXJuIFwiUHVibGljIENoYXRzXCI7XG4gICAgfSBlbHNlIGlmICh0aGlzLmtpbmQgPT09IDEwMDA2IC8qIEJsb2NrUmVsYXlMaXN0ICovKSB7XG4gICAgICByZXR1cm4gXCJCbG9ja2VkIFJlbGF5c1wiO1xuICAgIH0gZWxzZSBpZiAodGhpcy5raW5kID09PSAxMDAwNyAvKiBTZWFyY2hSZWxheUxpc3QgKi8pIHtcbiAgICAgIHJldHVybiBcIlNlYXJjaCBSZWxheXNcIjtcbiAgICB9IGVsc2UgaWYgKHRoaXMua2luZCA9PT0gMTAwNTAgLyogRGlyZWN0TWVzc2FnZVJlY2VpdmVSZWxheUxpc3QgKi8pIHtcbiAgICAgIHJldHVybiBcIkRpcmVjdCBNZXNzYWdlIFJlY2VpdmUgUmVsYXlzXCI7XG4gICAgfSBlbHNlIGlmICh0aGlzLmtpbmQgPT09IDEwMDE1IC8qIEludGVyZXN0TGlzdCAqLykge1xuICAgICAgcmV0dXJuIFwiSW50ZXJlc3RzXCI7XG4gICAgfSBlbHNlIGlmICh0aGlzLmtpbmQgPT09IDEwMDMwIC8qIEVtb2ppTGlzdCAqLykge1xuICAgICAgcmV0dXJuIFwiRW1vamlzXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwiZFwiKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHRpdGxlIG9mIHRoZSBsaXN0LlxuICAgKi9cbiAgc2V0IHRpdGxlKHRpdGxlKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoW1widGl0bGVcIiwgXCJuYW1lXCJdKTtcbiAgICBpZiAodGl0bGUpIHRoaXMudGFncy5wdXNoKFtcInRpdGxlXCIsIHRpdGxlXSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG5hbWUgb2YgdGhlIGxpc3QuXG4gICAqIEBkZXByZWNhdGVkIFBsZWFzZSB1c2UgXCJ0aXRsZVwiIGluc3RlYWQuXG4gICAqL1xuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy50aXRsZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgbmFtZSBvZiB0aGUgbGlzdC5cbiAgICogQGRlcHJlY2F0ZWQgUGxlYXNlIHVzZSBcInRpdGxlXCIgaW5zdGVhZC4gVGhpcyBtZXRob2Qgd2lsbCB1c2UgdGhlIGB0aXRsZWAgdGFnIGluc3RlYWQuXG4gICAqL1xuICBzZXQgbmFtZShuYW1lKSB7XG4gICAgdGhpcy50aXRsZSA9IG5hbWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBsaXN0LlxuICAgKi9cbiAgZ2V0IGRlc2NyaXB0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwiZGVzY3JpcHRpb25cIik7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBsaXN0LlxuICAgKi9cbiAgc2V0IGRlc2NyaXB0aW9uKG5hbWUpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImRlc2NyaXB0aW9uXCIpO1xuICAgIGlmIChuYW1lKSB0aGlzLnRhZ3MucHVzaChbXCJkZXNjcmlwdGlvblwiLCBuYW1lXSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGltYWdlIG9mIHRoZSBsaXN0LlxuICAgKi9cbiAgZ2V0IGltYWdlKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwiaW1hZ2VcIik7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGltYWdlIG9mIHRoZSBsaXN0LlxuICAgKi9cbiAgc2V0IGltYWdlKG5hbWUpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImltYWdlXCIpO1xuICAgIGlmIChuYW1lKSB0aGlzLnRhZ3MucHVzaChbXCJpbWFnZVwiLCBuYW1lXSk7XG4gIH1cbiAgaXNFbmNyeXB0ZWRUYWdzQ2FjaGVWYWxpZCgpIHtcbiAgICByZXR1cm4gISEodGhpcy5fZW5jcnlwdGVkVGFncyAmJiB0aGlzLmVuY3J5cHRlZFRhZ3NMZW5ndGggPT09IHRoaXMuY29udGVudC5sZW5ndGgpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkZWNyeXB0ZWQgY29udGVudCBvZiB0aGUgbGlzdC5cbiAgICovXG4gIGFzeW5jIGVuY3J5cHRlZFRhZ3ModXNlQ2FjaGUgPSB0cnVlKSB7XG4gICAgaWYgKHVzZUNhY2hlICYmIHRoaXMuaXNFbmNyeXB0ZWRUYWdzQ2FjaGVWYWxpZCgpKSByZXR1cm4gdGhpcy5fZW5jcnlwdGVkVGFncztcbiAgICBpZiAoIXRoaXMubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJOREsgaW5zdGFuY2Ugbm90IHNldFwiKTtcbiAgICBpZiAoIXRoaXMubmRrLnNpZ25lcikgdGhyb3cgbmV3IEVycm9yKFwiTkRLIHNpZ25lciBub3Qgc2V0XCIpO1xuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLm5kay5zaWduZXIudXNlcigpO1xuICAgIHRyeSB7XG4gICAgICBpZiAodGhpcy5jb250ZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBkZWNyeXB0ZWRDb250ZW50ID0gYXdhaXQgdGhpcy5uZGsuc2lnbmVyLmRlY3J5cHQodXNlciwgdGhpcy5jb250ZW50KTtcbiAgICAgICAgICBjb25zdCBhID0gSlNPTi5wYXJzZShkZWNyeXB0ZWRDb250ZW50KTtcbiAgICAgICAgICBpZiAoYSAmJiBhWzBdKSB7XG4gICAgICAgICAgICB0aGlzLmVuY3J5cHRlZFRhZ3NMZW5ndGggPSB0aGlzLmNvbnRlbnQubGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2VuY3J5cHRlZFRhZ3MgPSBhO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmVuY3J5cHRlZFRhZ3NMZW5ndGggPSB0aGlzLmNvbnRlbnQubGVuZ3RoO1xuICAgICAgICAgIHJldHVybiB0aGlzLl9lbmNyeXB0ZWRUYWdzID0gW107XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgZXJyb3IgZGVjcnlwdGluZyAke3RoaXMuY29udGVudH1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBjYW4gYmUgb3ZlcnJpZGVuIHRvIHZhbGlkYXRlIHRoYXQgYSB0YWcgaXMgdmFsaWQgZm9yIHRoaXMgbGlzdC5cbiAgICpcbiAgICogKGkuZS4gdGhlIE5ES1BlcnNvbkxpc3QgY2FuIHZhbGlkYXRlIHRoYXQgaXRlbXMgYXJlIE5ES1VzZXIgaW5zdGFuY2VzKVxuICAgKi9cbiAgdmFsaWRhdGVUYWcodGFnVmFsdWUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBnZXRJdGVtcyh0eXBlKSB7XG4gICAgcmV0dXJuIHRoaXMudGFncy5maWx0ZXIoKHRhZykgPT4gdGFnWzBdID09PSB0eXBlKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdW5lY3J5cHRlZCBpdGVtcyBpbiB0aGlzIGxpc3QuXG4gICAqL1xuICBnZXQgaXRlbXMoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFncy5maWx0ZXIoKHQpID0+IHtcbiAgICAgIHJldHVybiAhW1xuICAgICAgICBcImRcIixcbiAgICAgICAgXCJMXCIsXG4gICAgICAgIFwibFwiLFxuICAgICAgICBcInRpdGxlXCIsXG4gICAgICAgIFwibmFtZVwiLFxuICAgICAgICBcImRlc2NyaXB0aW9uXCIsXG4gICAgICAgIFwicHVibGlzaGVkX2F0XCIsXG4gICAgICAgIFwic3VtbWFyeVwiLFxuICAgICAgICBcImltYWdlXCIsXG4gICAgICAgIFwidGh1bWJcIixcbiAgICAgICAgXCJhbHRcIixcbiAgICAgICAgXCJleHBpcmF0aW9uXCIsXG4gICAgICAgIFwic3ViamVjdFwiLFxuICAgICAgICBcImNsaWVudFwiXG4gICAgICBdLmluY2x1ZGVzKHRbMF0pO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGEgbmV3IGl0ZW0gdG8gdGhlIGxpc3QuXG4gICAqIEBwYXJhbSByZWxheSBSZWxheSB0byBhZGRcbiAgICogQHBhcmFtIG1hcmsgT3B0aW9uYWwgbWFyayB0byBhZGQgdG8gdGhlIGl0ZW1cbiAgICogQHBhcmFtIGVuY3J5cHRlZCBXaGV0aGVyIHRvIGVuY3J5cHQgdGhlIGl0ZW1cbiAgICogQHBhcmFtIHBvc2l0aW9uIFdoZXJlIHRvIGFkZCB0aGUgaXRlbSBpbiB0aGUgbGlzdCAodG9wIG9yIGJvdHRvbSlcbiAgICovXG4gIGFzeW5jIGFkZEl0ZW0oaXRlbSwgbWFyayA9IHZvaWQgMCwgZW5jcnlwdGVkID0gZmFsc2UsIHBvc2l0aW9uID0gXCJib3R0b21cIikge1xuICAgIGlmICghdGhpcy5uZGspIHRocm93IG5ldyBFcnJvcihcIk5ESyBpbnN0YW5jZSBub3Qgc2V0XCIpO1xuICAgIGlmICghdGhpcy5uZGsuc2lnbmVyKSB0aHJvdyBuZXcgRXJyb3IoXCJOREsgc2lnbmVyIG5vdCBzZXRcIik7XG4gICAgbGV0IHRhZ3M7XG4gICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBOREtFdmVudCkge1xuICAgICAgdGFncyA9IFtpdGVtLnRhZ1JlZmVyZW5jZShtYXJrKV07XG4gICAgfSBlbHNlIGlmIChpdGVtIGluc3RhbmNlb2YgTkRLVXNlcikge1xuICAgICAgdGFncyA9IGl0ZW0ucmVmZXJlbmNlVGFncygpO1xuICAgIH0gZWxzZSBpZiAoaXRlbSBpbnN0YW5jZW9mIE5ES1JlbGF5KSB7XG4gICAgICB0YWdzID0gaXRlbS5yZWZlcmVuY2VUYWdzKCk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgICB0YWdzID0gW2l0ZW1dO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG9iamVjdCB0eXBlXCIpO1xuICAgIH1cbiAgICBpZiAobWFyaykgdGFnc1swXS5wdXNoKG1hcmspO1xuICAgIGlmIChlbmNyeXB0ZWQpIHtcbiAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLm5kay5zaWduZXIudXNlcigpO1xuICAgICAgY29uc3QgY3VycmVudExpc3QgPSBhd2FpdCB0aGlzLmVuY3J5cHRlZFRhZ3MoKTtcbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gXCJ0b3BcIikgY3VycmVudExpc3QudW5zaGlmdCguLi50YWdzKTtcbiAgICAgIGVsc2UgY3VycmVudExpc3QucHVzaCguLi50YWdzKTtcbiAgICAgIHRoaXMuX2VuY3J5cHRlZFRhZ3MgPSBjdXJyZW50TGlzdDtcbiAgICAgIHRoaXMuZW5jcnlwdGVkVGFnc0xlbmd0aCA9IHRoaXMuY29udGVudC5sZW5ndGg7XG4gICAgICB0aGlzLmNvbnRlbnQgPSBKU09OLnN0cmluZ2lmeShjdXJyZW50TGlzdCk7XG4gICAgICBhd2FpdCB0aGlzLmVuY3J5cHQodXNlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gXCJ0b3BcIikgdGhpcy50YWdzLnVuc2hpZnQoLi4udGFncyk7XG4gICAgICBlbHNlIHRoaXMudGFncy5wdXNoKC4uLnRhZ3MpO1xuICAgIH1cbiAgICB0aGlzLmNyZWF0ZWRfYXQgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxZTMpO1xuICAgIHRoaXMuZW1pdChcImNoYW5nZVwiKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBhbiBpdGVtIGZyb20gdGhlIGxpc3QgZnJvbSBib3RoIHRoZSBlbmNyeXB0ZWQgYW5kIHVuZW5jcnlwdGVkIGxpc3RzLlxuICAgKiBAcGFyYW0gdmFsdWUgdmFsdWUgb2YgaXRlbSB0byByZW1vdmUgZnJvbSB0aGUgbGlzdFxuICAgKiBAcGFyYW0gcHVibGlzaCB3aGV0aGVyIHRvIHB1Ymxpc2ggdGhlIGNoYW5nZVxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgYXN5bmMgcmVtb3ZlSXRlbUJ5VmFsdWUodmFsdWUsIHB1Ymxpc2ggPSB0cnVlKSB7XG4gICAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTkRLIGluc3RhbmNlIG5vdCBzZXRcIik7XG4gICAgaWYgKCF0aGlzLm5kay5zaWduZXIpIHRocm93IG5ldyBFcnJvcihcIk5ESyBzaWduZXIgbm90IHNldFwiKTtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMudGFncy5maW5kSW5kZXgoKHRhZykgPT4gdGFnWzFdID09PSB2YWx1ZSk7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHRoaXMudGFncy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgICBjb25zdCB1c2VyID0gYXdhaXQgdGhpcy5uZGsuc2lnbmVyLnVzZXIoKTtcbiAgICBjb25zdCBlbmNyeXB0ZWRUYWdzID0gYXdhaXQgdGhpcy5lbmNyeXB0ZWRUYWdzKCk7XG4gICAgY29uc3QgZW5jcnlwdGVkSW5kZXggPSBlbmNyeXB0ZWRUYWdzLmZpbmRJbmRleCgodGFnKSA9PiB0YWdbMV0gPT09IHZhbHVlKTtcbiAgICBpZiAoZW5jcnlwdGVkSW5kZXggPj0gMCkge1xuICAgICAgZW5jcnlwdGVkVGFncy5zcGxpY2UoZW5jcnlwdGVkSW5kZXgsIDEpO1xuICAgICAgdGhpcy5fZW5jcnlwdGVkVGFncyA9IGVuY3J5cHRlZFRhZ3M7XG4gICAgICB0aGlzLmVuY3J5cHRlZFRhZ3NMZW5ndGggPSB0aGlzLmNvbnRlbnQubGVuZ3RoO1xuICAgICAgdGhpcy5jb250ZW50ID0gSlNPTi5zdHJpbmdpZnkoZW5jcnlwdGVkVGFncyk7XG4gICAgICBhd2FpdCB0aGlzLmVuY3J5cHQodXNlcik7XG4gICAgfVxuICAgIGlmIChwdWJsaXNoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdWJsaXNoUmVwbGFjZWFibGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jcmVhdGVkX2F0ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMWUzKTtcbiAgICB9XG4gICAgdGhpcy5lbWl0KFwiY2hhbmdlXCIpO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIGFuIGl0ZW0gZnJvbSB0aGUgbGlzdC5cbiAgICpcbiAgICogQHBhcmFtIGluZGV4IFRoZSBpbmRleCBvZiB0aGUgaXRlbSB0byByZW1vdmUuXG4gICAqIEBwYXJhbSBlbmNyeXB0ZWQgV2hldGhlciB0byByZW1vdmUgZnJvbSB0aGUgZW5jcnlwdGVkIGxpc3Qgb3Igbm90LlxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlSXRlbShpbmRleCwgZW5jcnlwdGVkKSB7XG4gICAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTkRLIGluc3RhbmNlIG5vdCBzZXRcIik7XG4gICAgaWYgKCF0aGlzLm5kay5zaWduZXIpIHRocm93IG5ldyBFcnJvcihcIk5ESyBzaWduZXIgbm90IHNldFwiKTtcbiAgICBpZiAoZW5jcnlwdGVkKSB7XG4gICAgICBjb25zdCB1c2VyID0gYXdhaXQgdGhpcy5uZGsuc2lnbmVyLnVzZXIoKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRMaXN0ID0gYXdhaXQgdGhpcy5lbmNyeXB0ZWRUYWdzKCk7XG4gICAgICBjdXJyZW50TGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgdGhpcy5fZW5jcnlwdGVkVGFncyA9IGN1cnJlbnRMaXN0O1xuICAgICAgdGhpcy5lbmNyeXB0ZWRUYWdzTGVuZ3RoID0gdGhpcy5jb250ZW50Lmxlbmd0aDtcbiAgICAgIHRoaXMuY29udGVudCA9IEpTT04uc3RyaW5naWZ5KGN1cnJlbnRMaXN0KTtcbiAgICAgIGF3YWl0IHRoaXMuZW5jcnlwdCh1c2VyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50YWdzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICAgIHRoaXMuY3JlYXRlZF9hdCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDFlMyk7XG4gICAgdGhpcy5lbWl0KFwiY2hhbmdlXCIpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGhhcyhpdGVtKSB7XG4gICAgcmV0dXJuIHRoaXMuaXRlbXMuc29tZSgodGFnKSA9PiB0YWdbMV0gPT09IGl0ZW0pO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZmlsdGVyIHRoYXQgd2lsbCByZXN1bHQgaW4gZmV0Y2hpbmdcbiAgICogdGhlIGl0ZW1zIG9mIHRoaXMgbGlzdFxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBsaXN0ID0gbmV3IE5ES0xpc3QoLi4uKTtcbiAgICogY29uc3QgZmlsdGVycyA9IGxpc3QuZmlsdGVyRm9ySXRlbXMoKTtcbiAgICogY29uc3QgZXZlbnRzID0gYXdhaXQgbmRrLmZldGNoRXZlbnRzKGZpbHRlcnMpO1xuICAgKi9cbiAgZmlsdGVyRm9ySXRlbXMoKSB7XG4gICAgY29uc3QgaWRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBjb25zdCBuaXAzM1F1ZXJpZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGZpbHRlcnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHRhZyBvZiB0aGlzLml0ZW1zKSB7XG4gICAgICBpZiAodGFnWzBdID09PSBcImVcIiAmJiB0YWdbMV0pIHtcbiAgICAgICAgaWRzLmFkZCh0YWdbMV0pO1xuICAgICAgfSBlbHNlIGlmICh0YWdbMF0gPT09IFwiYVwiICYmIHRhZ1sxXSkge1xuICAgICAgICBjb25zdCBba2luZCwgcHVia2V5LCBkVGFnXSA9IHRhZ1sxXS5zcGxpdChcIjpcIik7XG4gICAgICAgIGlmICgha2luZCB8fCAhcHVia2V5KSBjb250aW51ZTtcbiAgICAgICAgY29uc3Qga2V5ID0gYCR7a2luZH06JHtwdWJrZXl9YDtcbiAgICAgICAgY29uc3QgaXRlbSA9IG5pcDMzUXVlcmllcy5nZXQoa2V5KSB8fCBbXTtcbiAgICAgICAgaXRlbS5wdXNoKGRUYWcgfHwgXCJcIik7XG4gICAgICAgIG5pcDMzUXVlcmllcy5zZXQoa2V5LCBpdGVtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlkcy5zaXplID4gMCkge1xuICAgICAgZmlsdGVycy5wdXNoKHsgaWRzOiBBcnJheS5mcm9tKGlkcykgfSk7XG4gICAgfVxuICAgIGlmIChuaXAzM1F1ZXJpZXMuc2l6ZSA+IDApIHtcbiAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVzXSBvZiBuaXAzM1F1ZXJpZXMuZW50cmllcygpKSB7XG4gICAgICAgIGNvbnN0IFtraW5kLCBwdWJrZXldID0ga2V5LnNwbGl0KFwiOlwiKTtcbiAgICAgICAgZmlsdGVycy5wdXNoKHtcbiAgICAgICAgICBraW5kczogW3BhcnNlSW50KGtpbmQpXSxcbiAgICAgICAgICBhdXRob3JzOiBbcHVia2V5XSxcbiAgICAgICAgICBcIiNkXCI6IHZhbHVlc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZpbHRlcnM7XG4gIH1cbn07XG52YXIgbGlzdHNfZGVmYXVsdCA9IE5ES0xpc3Q7XG5cbi8vIHNyYy9ldmVudHMva2luZHMvbnV0emFwL2luZGV4LnRzXG5pbXBvcnQgZGVidWcyIGZyb20gXCJkZWJ1Z1wiO1xudmFyIE5ES051dHphcCA9IGNsYXNzIF9OREtOdXR6YXAgZXh0ZW5kcyBOREtFdmVudCB7XG4gIGRlYnVnO1xuICBfcHJvb2ZzID0gW107XG4gIHN0YXRpYyBraW5kID0gOTMyMSAvKiBOdXR6YXAgKi87XG4gIHN0YXRpYyBraW5kcyA9IFtfTkRLTnV0emFwLmtpbmRdO1xuICBjb25zdHJ1Y3RvcihuZGssIGV2ZW50KSB7XG4gICAgc3VwZXIobmRrLCBldmVudCk7XG4gICAgdGhpcy5raW5kID8/PSA5MzIxIC8qIE51dHphcCAqLztcbiAgICB0aGlzLmRlYnVnID0gbmRrPy5kZWJ1Zy5leHRlbmQoXCJudXR6YXBcIikgPz8gZGVidWcyKFwibmRrOm51dHphcFwiKTtcbiAgICBpZiAoIXRoaXMuYWx0KSB0aGlzLmFsdCA9IFwiVGhpcyBpcyBhIG51dHphcFwiO1xuICB9XG4gIHN0YXRpYyBmcm9tKGV2ZW50KSB7XG4gICAgY29uc3QgZSA9IG5ldyB0aGlzKGV2ZW50Lm5kaywgZXZlbnQpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwcm9vZlRhZ3MgPSBlLmdldE1hdGNoaW5nVGFncyhcInByb29mXCIpO1xuICAgICAgaWYgKHByb29mVGFncy5sZW5ndGgpIHtcbiAgICAgICAgZS5fcHJvb2ZzID0gcHJvb2ZUYWdzLm1hcCgodGFnKSA9PiBKU09OLnBhcnNlKHRhZ1sxXSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZS5fcHJvb2ZzID0gSlNPTi5wYXJzZShlLmNvbnRlbnQpO1xuICAgICAgfVxuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWUuX3Byb29mcyB8fCAhZS5fcHJvb2ZzLmxlbmd0aCkgcmV0dXJuO1xuICAgIHJldHVybiBlO1xuICB9XG4gIHNldCBjb21tZW50KGNvbW1lbnQpIHtcbiAgICB0aGlzLmNvbnRlbnQgPSBjb21tZW50ID8/IFwiXCI7XG4gIH1cbiAgZ2V0IGNvbW1lbnQoKSB7XG4gICAgY29uc3QgYyA9IHRoaXMudGFnVmFsdWUoXCJjb21tZW50XCIpO1xuICAgIGlmIChjKSByZXR1cm4gYztcbiAgICByZXR1cm4gdGhpcy5jb250ZW50O1xuICB9XG4gIHNldCBwcm9vZnMocHJvb2ZzKSB7XG4gICAgdGhpcy5fcHJvb2ZzID0gcHJvb2ZzO1xuICAgIHRoaXMudGFncyA9IHRoaXMudGFncy5maWx0ZXIoKHRhZykgPT4gdGFnWzBdICE9PSBcInByb29mXCIpO1xuICAgIGZvciAoY29uc3QgcHJvb2Ygb2YgcHJvb2ZzKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJwcm9vZlwiLCBKU09OLnN0cmluZ2lmeShwcm9vZildKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHByb29mcygpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvb2ZzO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBwMnBrIHB1YmtleSB0aGF0IGlzIGVtYmVkZGVkIGluIHRoZSBmaXJzdCBwcm9vZlxuICAgKi9cbiAgZ2V0IHAycGsoKSB7XG4gICAgY29uc3QgZmlyc3RQcm9vZiA9IHRoaXMucHJvb2ZzWzBdO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzZWNyZXQgPSBKU09OLnBhcnNlKGZpcnN0UHJvb2Yuc2VjcmV0KTtcbiAgICAgIGxldCBwYXlsb2FkID0ge307XG4gICAgICBpZiAodHlwZW9mIHNlY3JldCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBwYXlsb2FkID0gSlNPTi5wYXJzZShzZWNyZXQpO1xuICAgICAgICB0aGlzLmRlYnVnKFwic3RyaW5naWZpZWQgcGF5bG9hZFwiLCBmaXJzdFByb29mLnNlY3JldCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZWNyZXQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgcGF5bG9hZCA9IHNlY3JldDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlzUDJQS0xvY2tlZCA9IHBheWxvYWRbMF0gPT09IFwiUDJQS1wiICYmIHBheWxvYWRbMV0/LmRhdGE7XG4gICAgICBpZiAoaXNQMlBLTG9ja2VkKSB7XG4gICAgICAgIGNvbnN0IHBhZGRlZHAycGsgPSBwYXlsb2FkWzFdLmRhdGE7XG4gICAgICAgIGNvbnN0IHAycGsgPSBwYWRkZWRwMnBrLnNsaWNlKDIpO1xuICAgICAgICBpZiAocDJwaykgcmV0dXJuIHAycGs7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhpcy5kZWJ1ZyhcImVycm9yIHBhcnNpbmcgcDJwayBwdWJrZXlcIiwgZSwgdGhpcy5wcm9vZnNbMF0pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBtaW50IHdoZXJlIHRoaXMgbnV0emFwIHByb29mcyBleGlzdFxuICAgKi9cbiAgZ2V0IG1pbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJ1XCIpO1xuICB9XG4gIHNldCBtaW50KHZhbHVlKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJ1XCIpO1xuICAgIHRoaXMudGFnKFtcInVcIiwgdmFsdWVdKTtcbiAgfVxuICBnZXQgdW5pdCgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcInVuaXRcIikgPz8gXCJzYXRcIjtcbiAgfVxuICBzZXQgdW5pdCh2YWx1ZSkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwidW5pdFwiKTtcbiAgICBpZiAodmFsdWUpIHRoaXMudGFnKFtcInVuaXRcIiwgdmFsdWVdKTtcbiAgfVxuICBnZXQgYW1vdW50KCkge1xuICAgIGNvbnN0IGFtb3VudCA9IHRoaXMucHJvb2ZzLnJlZHVjZSgodG90YWwsIHByb29mKSA9PiB0b3RhbCArIHByb29mLmFtb3VudCwgMCk7XG4gICAgaWYgKHRoaXMudW5pdCA9PT0gXCJtc2F0XCIpIHJldHVybiBhbW91bnQgKiAxZTM7XG4gICAgcmV0dXJuIGFtb3VudDtcbiAgfVxuICBzZW5kZXIgPSB0aGlzLmF1dGhvcjtcbiAgLyoqXG4gICAqIFNldCB0aGUgdGFyZ2V0IG9mIHRoZSBudXR6YXBcbiAgICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0IG9mIHRoZSBudXR6YXAgKGEgdXNlciBvciBhbiBldmVudClcbiAgICovXG4gIHNldCB0YXJnZXQodGFyZ2V0KSB7XG4gICAgdGhpcy50YWdzID0gdGhpcy50YWdzLmZpbHRlcigodCkgPT4gdFswXSAhPT0gXCJwXCIpO1xuICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBOREtFdmVudCkge1xuICAgICAgdGhpcy50YWdzLnB1c2godGFyZ2V0LnRhZ1JlZmVyZW5jZSgpKTtcbiAgICB9XG4gIH1cbiAgc2V0IHJlY2lwaWVudFB1YmtleShwdWJrZXkpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInBcIik7XG4gICAgdGhpcy50YWcoW1wicFwiLCBwdWJrZXldKTtcbiAgfVxuICBnZXQgcmVjaXBpZW50UHVia2V5KCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwicFwiKTtcbiAgfVxuICBnZXQgcmVjaXBpZW50KCkge1xuICAgIGNvbnN0IHB1YmtleSA9IHRoaXMucmVjaXBpZW50UHVia2V5O1xuICAgIGlmICh0aGlzLm5kaykgcmV0dXJuIHRoaXMubmRrLmdldFVzZXIoeyBwdWJrZXkgfSk7XG4gICAgcmV0dXJuIG5ldyBOREtVc2VyKHsgcHVia2V5IH0pO1xuICB9XG4gIGFzeW5jIHRvTm9zdHJFdmVudCgpIHtcbiAgICBpZiAodGhpcy51bml0ID09PSBcIm1zYXRcIikge1xuICAgICAgdGhpcy51bml0ID0gXCJzYXRcIjtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJhbW91bnRcIik7XG4gICAgdGhpcy50YWdzLnB1c2goW1wiYW1vdW50XCIsIHRoaXMuYW1vdW50LnRvU3RyaW5nKCldKTtcbiAgICBjb25zdCBldmVudCA9IGF3YWl0IHN1cGVyLnRvTm9zdHJFdmVudCgpO1xuICAgIGV2ZW50LmNvbnRlbnQgPSB0aGlzLmNvbW1lbnQ7XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9XG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgdGhhdCB0aGUgbnV0emFwIGNvbmZvcm1zIHRvIE5JUC02MVxuICAgKi9cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgbGV0IGVUYWdDb3VudCA9IDA7XG4gICAgbGV0IHBUYWdDb3VudCA9IDA7XG4gICAgbGV0IG1pbnRUYWdDb3VudCA9IDA7XG4gICAgZm9yIChjb25zdCB0YWcgb2YgdGhpcy50YWdzKSB7XG4gICAgICBpZiAodGFnWzBdID09PSBcImVcIikgZVRhZ0NvdW50Kys7XG4gICAgICBpZiAodGFnWzBdID09PSBcInBcIikgcFRhZ0NvdW50Kys7XG4gICAgICBpZiAodGFnWzBdID09PSBcInVcIikgbWludFRhZ0NvdW50Kys7XG4gICAgfVxuICAgIHJldHVybiAoXG4gICAgICAvLyBleGFjdGx5IG9uZSByZWNpcGllbnQgYW5kIG1pbnRcbiAgICAgIHBUYWdDb3VudCA9PT0gMSAmJiBtaW50VGFnQ291bnQgPT09IDEgJiYgLy8gbXVzdCBoYXZlIGF0IG1vc3Qgb25lIGUgdGFnXG4gICAgICBlVGFnQ291bnQgPD0gMSAmJiAvLyBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIHByb29mXG4gICAgICB0aGlzLnByb29mcy5sZW5ndGggPiAwXG4gICAgKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHByb29mUDJwayhwcm9vZikge1xuICB0cnkge1xuICAgIGNvbnN0IHNlY3JldCA9IEpTT04ucGFyc2UocHJvb2Yuc2VjcmV0KTtcbiAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgIGlmICh0eXBlb2Ygc2VjcmV0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBwYXlsb2FkID0gSlNPTi5wYXJzZShzZWNyZXQpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHNlY3JldCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgcGF5bG9hZCA9IHNlY3JldDtcbiAgICB9XG4gICAgY29uc3QgaXNQMlBLTG9ja2VkID0gcGF5bG9hZFswXSA9PT0gXCJQMlBLXCIgJiYgcGF5bG9hZFsxXT8uZGF0YTtcbiAgICBpZiAoaXNQMlBLTG9ja2VkKSB7XG4gICAgICByZXR1cm4gcGF5bG9hZFsxXS5kYXRhO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJlcnJvciBwYXJzaW5nIHAycGsgcHVia2V5XCIsIGUsIHByb29mKTtcbiAgfVxufVxuZnVuY3Rpb24gcHJvb2ZQMnBrTm9zdHIocHJvb2YpIHtcbiAgY29uc3QgcDJwayA9IHByb29mUDJwayhwcm9vZik7XG4gIGlmICghcDJwaykgcmV0dXJuO1xuICBpZiAocDJway5zdGFydHNXaXRoKFwiMDJcIikgJiYgcDJway5sZW5ndGggPT09IDY2KSByZXR1cm4gcDJway5zbGljZSgyKTtcbiAgcmV0dXJuIHAycGs7XG59XG5cbi8vIHNyYy9ldmVudHMva2luZHMvbnV0emFwL21pbnQtbGlzdC50c1xudmFyIE5ES0Nhc2h1TWludExpc3QgPSBjbGFzcyBfTkRLQ2FzaHVNaW50TGlzdCBleHRlbmRzIE5ES0V2ZW50IHtcbiAgc3RhdGljIGtpbmQgPSAxMDAxOSAvKiBDYXNodU1pbnRMaXN0ICovO1xuICBzdGF0aWMga2luZHMgPSBbMTAwMTkgLyogQ2FzaHVNaW50TGlzdCAqL107XG4gIF9wMnBrO1xuICBjb25zdHJ1Y3RvcihuZGssIGV2ZW50KSB7XG4gICAgc3VwZXIobmRrLCBldmVudCk7XG4gICAgdGhpcy5raW5kID8/PSAxMDAxOSAvKiBDYXNodU1pbnRMaXN0ICovO1xuICB9XG4gIHN0YXRpYyBmcm9tKGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLQ2FzaHVNaW50TGlzdChldmVudC5uZGssIGV2ZW50KTtcbiAgfVxuICBzZXQgcmVsYXlzKHVybHMpIHtcbiAgICB0aGlzLnRhZ3MgPSB0aGlzLnRhZ3MuZmlsdGVyKCh0KSA9PiB0WzBdICE9PSBcInJlbGF5XCIpO1xuICAgIGZvciAoY29uc3QgdXJsIG9mIHVybHMpIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcInJlbGF5XCIsIHVybF0pO1xuICAgIH1cbiAgfVxuICBnZXQgcmVsYXlzKCkge1xuICAgIGNvbnN0IHIgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHRhZyBvZiB0aGlzLnRhZ3MpIHtcbiAgICAgIGlmICh0YWdbMF0gPT09IFwicmVsYXlcIikge1xuICAgICAgICByLnB1c2godGFnWzFdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgc2V0IG1pbnRzKHVybHMpIHtcbiAgICB0aGlzLnRhZ3MgPSB0aGlzLnRhZ3MuZmlsdGVyKCh0KSA9PiB0WzBdICE9PSBcIm1pbnRcIik7XG4gICAgZm9yIChjb25zdCB1cmwgb2YgdXJscykge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wibWludFwiLCB1cmxdKTtcbiAgICB9XG4gIH1cbiAgZ2V0IG1pbnRzKCkge1xuICAgIGNvbnN0IHIgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHRhZyBvZiB0aGlzLnRhZ3MpIHtcbiAgICAgIGlmICh0YWdbMF0gPT09IFwibWludFwiKSB7XG4gICAgICAgIHIucHVzaCh0YWdbMV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gQXJyYXkuZnJvbShuZXcgU2V0KHIpKTtcbiAgfVxuICBnZXQgcDJwaygpIHtcbiAgICBpZiAodGhpcy5fcDJwaykge1xuICAgICAgcmV0dXJuIHRoaXMuX3AycGs7XG4gICAgfVxuICAgIHRoaXMuX3AycGsgPSB0aGlzLnRhZ1ZhbHVlKFwicHVia2V5XCIpID8/IHRoaXMucHVia2V5O1xuICAgIHJldHVybiB0aGlzLl9wMnBrO1xuICB9XG4gIHNldCBwMnBrKHB1YmtleSkge1xuICAgIHRoaXMuX3AycGsgPSBwdWJrZXk7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJwdWJrZXlcIik7XG4gICAgaWYgKHB1YmtleSkge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wicHVia2V5XCIsIHB1YmtleV0pO1xuICAgIH1cbiAgfVxuICBnZXQgcmVsYXlTZXQoKSB7XG4gICAgcmV0dXJuIE5ES1JlbGF5U2V0LmZyb21SZWxheVVybHModGhpcy5yZWxheXMsIHRoaXMubmRrKTtcbiAgfVxufTtcblxuLy8gc3JjL2V2ZW50cy9raW5kcy9zaW1wbGUtZ3JvdXAvbWVtYmVyLWxpc3QudHNcbnZhciBOREtTaW1wbGVHcm91cE1lbWJlckxpc3QgPSBjbGFzcyBfTkRLU2ltcGxlR3JvdXBNZW1iZXJMaXN0IGV4dGVuZHMgTkRLRXZlbnQge1xuICByZWxheVNldDtcbiAgbWVtYmVyU2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgc3RhdGljIGtpbmQgPSAzOTAwMiAvKiBHcm91cE1lbWJlcnMgKi87XG4gIHN0YXRpYyBraW5kcyA9IFszOTAwMiAvKiBHcm91cE1lbWJlcnMgKi9dO1xuICBjb25zdHJ1Y3RvcihuZGssIHJhd0V2ZW50KSB7XG4gICAgc3VwZXIobmRrLCByYXdFdmVudCk7XG4gICAgdGhpcy5raW5kID8/PSAzOTAwMiAvKiBHcm91cE1lbWJlcnMgKi87XG4gICAgdGhpcy5tZW1iZXJTZXQgPSBuZXcgU2V0KHRoaXMubWVtYmVycyk7XG4gIH1cbiAgc3RhdGljIGZyb20oZXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtTaW1wbGVHcm91cE1lbWJlckxpc3QoZXZlbnQubmRrLCBldmVudCk7XG4gIH1cbiAgZ2V0IG1lbWJlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwicFwiKS5tYXAoKHRhZykgPT4gdGFnWzFdKTtcbiAgfVxuICBoYXNNZW1iZXIobWVtYmVyKSB7XG4gICAgcmV0dXJuIHRoaXMubWVtYmVyU2V0LmhhcyhtZW1iZXIpO1xuICB9XG4gIGFzeW5jIHB1Ymxpc2gocmVsYXlTZXQsIHRpbWVvdXRNcywgcmVxdWlyZWRSZWxheUNvdW50KSB7XG4gICAgcmVsYXlTZXQgPz89IHRoaXMucmVsYXlTZXQ7XG4gICAgcmV0dXJuIHN1cGVyLnB1Ymxpc2hSZXBsYWNlYWJsZShyZWxheVNldCwgdGltZW91dE1zLCByZXF1aXJlZFJlbGF5Q291bnQpO1xuICB9XG59O1xuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL3NpbXBsZS1ncm91cC9tZXRhZGF0YS50c1xudmFyIE5ES1NpbXBsZUdyb3VwTWV0YWRhdGEgPSBjbGFzcyBfTkRLU2ltcGxlR3JvdXBNZXRhZGF0YSBleHRlbmRzIE5ES0V2ZW50IHtcbiAgc3RhdGljIGtpbmQgPSAzOWUzIC8qIEdyb3VwTWV0YWRhdGEgKi87XG4gIHN0YXRpYyBraW5kcyA9IFszOWUzIC8qIEdyb3VwTWV0YWRhdGEgKi9dO1xuICBjb25zdHJ1Y3RvcihuZGssIHJhd0V2ZW50KSB7XG4gICAgc3VwZXIobmRrLCByYXdFdmVudCk7XG4gICAgdGhpcy5raW5kID8/PSAzOWUzIC8qIEdyb3VwTWV0YWRhdGEgKi87XG4gIH1cbiAgc3RhdGljIGZyb20oZXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtTaW1wbGVHcm91cE1ldGFkYXRhKGV2ZW50Lm5kaywgZXZlbnQpO1xuICB9XG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwibmFtZVwiKTtcbiAgfVxuICBnZXQgcGljdHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcInBpY3R1cmVcIik7XG4gIH1cbiAgZ2V0IGFib3V0KCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwiYWJvdXRcIik7XG4gIH1cbiAgZ2V0IHNjb3BlKCkge1xuICAgIGlmICh0aGlzLmdldE1hdGNoaW5nVGFncyhcInB1YmxpY1wiKS5sZW5ndGggPiAwKSByZXR1cm4gXCJwdWJsaWNcIjtcbiAgICBpZiAodGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJwdWJsaWNcIikubGVuZ3RoID4gMCkgcmV0dXJuIFwicHJpdmF0ZVwiO1xuICB9XG4gIHNldCBzY29wZShzY29wZSkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwicHVibGljXCIpO1xuICAgIHRoaXMucmVtb3ZlVGFnKFwicHJpdmF0ZVwiKTtcbiAgICBpZiAoc2NvcGUgPT09IFwicHVibGljXCIpIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcInB1YmxpY1wiLCBcIlwiXSk7XG4gICAgfSBlbHNlIGlmIChzY29wZSA9PT0gXCJwcml2YXRlXCIpIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcInByaXZhdGVcIiwgXCJcIl0pO1xuICAgIH1cbiAgfVxuICBnZXQgYWNjZXNzKCkge1xuICAgIGlmICh0aGlzLmdldE1hdGNoaW5nVGFncyhcIm9wZW5cIikubGVuZ3RoID4gMCkgcmV0dXJuIFwib3BlblwiO1xuICAgIGlmICh0aGlzLmdldE1hdGNoaW5nVGFncyhcImNsb3NlZFwiKS5sZW5ndGggPiAwKSByZXR1cm4gXCJjbG9zZWRcIjtcbiAgfVxuICBzZXQgYWNjZXNzKGFjY2Vzcykge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwib3BlblwiKTtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImNsb3NlZFwiKTtcbiAgICBpZiAoYWNjZXNzID09PSBcIm9wZW5cIikge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wib3BlblwiLCBcIlwiXSk7XG4gICAgfSBlbHNlIGlmIChhY2Nlc3MgPT09IFwiY2xvc2VkXCIpIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcImNsb3NlZFwiLCBcIlwiXSk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL3N1YnNjcmlwdGlvbnMvYW1vdW50LnRzXG52YXIgcG9zc2libGVJbnRlcnZhbEZyZXF1ZW5jaWVzID0gW1xuICBcImRhaWx5XCIsXG4gIFwid2Vla2x5XCIsXG4gIFwibW9udGhseVwiLFxuICBcInF1YXJ0ZXJseVwiLFxuICBcInllYXJseVwiXG5dO1xuZnVuY3Rpb24gY2FsY3VsYXRlVGVybUR1cmF0aW9uSW5TZWNvbmRzKHRlcm0pIHtcbiAgc3dpdGNoICh0ZXJtKSB7XG4gICAgY2FzZSBcImRhaWx5XCI6XG4gICAgICByZXR1cm4gMjQgKiA2MCAqIDYwO1xuICAgIGNhc2UgXCJ3ZWVrbHlcIjpcbiAgICAgIHJldHVybiA3ICogMjQgKiA2MCAqIDYwO1xuICAgIGNhc2UgXCJtb250aGx5XCI6XG4gICAgICByZXR1cm4gMzAgKiAyNCAqIDYwICogNjA7XG4gICAgY2FzZSBcInF1YXJ0ZXJseVwiOlxuICAgICAgcmV0dXJuIDMgKiAzMCAqIDI0ICogNjAgKiA2MDtcbiAgICBjYXNlIFwieWVhcmx5XCI6XG4gICAgICByZXR1cm4gMzY1ICogMjQgKiA2MCAqIDYwO1xuICB9XG59XG5mdW5jdGlvbiBuZXdBbW91bnQoYW1vdW50LCBjdXJyZW5jeSwgdGVybSkge1xuICByZXR1cm4gW1wiYW1vdW50XCIsIGFtb3VudC50b1N0cmluZygpLCBjdXJyZW5jeSwgdGVybV07XG59XG5mdW5jdGlvbiBwYXJzZVRhZ1RvU3Vic2NyaXB0aW9uQW1vdW50KHRhZykge1xuICBjb25zdCBhbW91bnQgPSBwYXJzZUludCh0YWdbMV0pO1xuICBpZiAoaXNOYU4oYW1vdW50KSB8fCBhbW91bnQgPT09IHZvaWQgMCB8fCBhbW91bnQgPT09IG51bGwgfHwgYW1vdW50IDw9IDApIHJldHVybiB2b2lkIDA7XG4gIGNvbnN0IGN1cnJlbmN5ID0gdGFnWzJdO1xuICBpZiAoY3VycmVuY3kgPT09IHZvaWQgMCB8fCBjdXJyZW5jeSA9PT0gXCJcIikgcmV0dXJuIHZvaWQgMDtcbiAgY29uc3QgdGVybSA9IHRhZ1szXTtcbiAgaWYgKHRlcm0gPT09IHZvaWQgMCkgcmV0dXJuIHZvaWQgMDtcbiAgaWYgKCFwb3NzaWJsZUludGVydmFsRnJlcXVlbmNpZXMuaW5jbHVkZXModGVybSkpIHJldHVybiB2b2lkIDA7XG4gIHJldHVybiB7XG4gICAgYW1vdW50LFxuICAgIGN1cnJlbmN5LFxuICAgIHRlcm1cbiAgfTtcbn1cblxuLy8gc3JjL2V2ZW50cy9raW5kcy9zdWJzY3JpcHRpb25zL3RpZXIudHNcbnZhciBOREtTdWJzY3JpcHRpb25UaWVyID0gY2xhc3MgX05ES1N1YnNjcmlwdGlvblRpZXIgZXh0ZW5kcyBOREtBcnRpY2xlIHtcbiAgc3RhdGljIGtpbmQgPSAzNzAwMSAvKiBTdWJzY3JpcHRpb25UaWVyICovO1xuICBzdGF0aWMga2luZHMgPSBbMzcwMDEgLyogU3Vic2NyaXB0aW9uVGllciAqL107XG4gIGNvbnN0cnVjdG9yKG5kaywgcmF3RXZlbnQpIHtcbiAgICBjb25zdCBrID0gcmF3RXZlbnQ/LmtpbmQgPz8gMzcwMDEgLyogU3Vic2NyaXB0aW9uVGllciAqLztcbiAgICBzdXBlcihuZGssIHJhd0V2ZW50KTtcbiAgICB0aGlzLmtpbmQgPSBrO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IE5ES1N1YnNjcmlwdGlvblRpZXIgZnJvbSBhbiBldmVudFxuICAgKiBAcGFyYW0gZXZlbnRcbiAgICogQHJldHVybnMgTkRLU3Vic2NyaXB0aW9uVGllclxuICAgKi9cbiAgc3RhdGljIGZyb20oZXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtTdWJzY3JpcHRpb25UaWVyKGV2ZW50Lm5kaywgZXZlbnQpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHBlcmtzIGZvciB0aGlzIHRpZXJcbiAgICovXG4gIGdldCBwZXJrcygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJwZXJrXCIpLm1hcCgodGFnKSA9PiB0YWdbMV0pLmZpbHRlcigocGVyaykgPT4gcGVyayAhPT0gdm9pZCAwKTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIHBlcmsgdG8gdGhpcyB0aWVyXG4gICAqL1xuICBhZGRQZXJrKHBlcmspIHtcbiAgICB0aGlzLnRhZ3MucHVzaChbXCJwZXJrXCIsIHBlcmtdKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYW1vdW50IGZvciB0aGlzIHRpZXJcbiAgICovXG4gIGdldCBhbW91bnRzKCkge1xuICAgIHJldHVybiB0aGlzLmdldE1hdGNoaW5nVGFncyhcImFtb3VudFwiKS5tYXAoKHRhZykgPT4gcGFyc2VUYWdUb1N1YnNjcmlwdGlvbkFtb3VudCh0YWcpKS5maWx0ZXIoKGEpID0+IGEgIT09IHZvaWQgMCk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYW4gYW1vdW50IHRvIHRoaXMgdGllclxuICAgKiBAcGFyYW0gYW1vdW50IEFtb3VudCBpbiB0aGUgc21hbGxlc3QgdW5pdCBvZiB0aGUgY3VycmVuY3kgKGUuZy4gY2VudHMsIG1zYXRzKVxuICAgKiBAcGFyYW0gY3VycmVuY3kgQ3VycmVuY3kgY29kZS4gVXNlIG1zYXQgZm9yIG1pbGxpc2F0b3NoaXNcbiAgICogQHBhcmFtIHRlcm0gT25lIG9mIGRhaWx5LCB3ZWVrbHksIG1vbnRobHksIHF1YXJ0ZXJseSwgeWVhcmx5XG4gICAqL1xuICBhZGRBbW91bnQoYW1vdW50LCBjdXJyZW5jeSwgdGVybSkge1xuICAgIHRoaXMudGFncy5wdXNoKG5ld0Ftb3VudChhbW91bnQsIGN1cnJlbmN5LCB0ZXJtKSk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgYSByZWxheSB3aGVyZSBjb250ZW50IHJlbGF0ZWQgdG8gdGhpcyB0aWVyIGNhbiBiZSBmb3VuZFxuICAgKiBAcGFyYW0gcmVsYXlVcmwgVVJMIG9mIHRoZSByZWxheVxuICAgKi9cbiAgc2V0IHJlbGF5VXJsKHJlbGF5VXJsKSB7XG4gICAgdGhpcy50YWdzLnB1c2goW1wiclwiLCByZWxheVVybF0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByZWxheSBVUkxzIGZvciB0aGlzIHRpZXJcbiAgICovXG4gIGdldCByZWxheVVybHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwiclwiKS5tYXAoKHRhZykgPT4gdGFnWzFdKS5maWx0ZXIoKHJlbGF5KSA9PiByZWxheSAhPT0gdm9pZCAwKTtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgdmVyaWZpZXIgcHVia2V5IGZvciB0aGlzIHRpZXIuIFRoaXMgaXMgdGhlIHB1YmtleSB0aGF0IHdpbGwgZ2VuZXJhdGVcbiAgICogc3Vic2NyaXB0aW9uIHBheW1lbnQgcmVjZWlwdHNcbiAgICovXG4gIGdldCB2ZXJpZmllclB1YmtleSgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcInBcIik7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZlcmlmaWVyIHB1YmtleSBmb3IgdGhpcyB0aWVyLlxuICAgKi9cbiAgc2V0IHZlcmlmaWVyUHVia2V5KHB1YmtleSkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwicFwiKTtcbiAgICBpZiAocHVia2V5KSB0aGlzLnRhZ3MucHVzaChbXCJwXCIsIHB1YmtleV0pO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhpcyB0aWVyIGlzIHZhbGlkXG4gICAqL1xuICBnZXQgaXNWYWxpZCgpIHtcbiAgICByZXR1cm4gdGhpcy50aXRsZSAhPT0gdm9pZCAwICYmIC8vIE11c3QgaGF2ZSBhIHRpdGxlXG4gICAgdGhpcy5hbW91bnRzLmxlbmd0aCA+IDA7XG4gIH1cbn07XG5cbi8vIHNyYy9ldmVudHMva2luZHMvdmlkZW8udHNcbnZhciBOREtWaWRlbyA9IGNsYXNzIF9OREtWaWRlbyBleHRlbmRzIE5ES0V2ZW50IHtcbiAgc3RhdGljIGtpbmQgPSAzNDIzNSAvKiBIb3Jpem9udGFsVmlkZW8gKi87XG4gIHN0YXRpYyBraW5kcyA9IFszNDIzNSAvKiBIb3Jpem9udGFsVmlkZW8gKi8sIDM0MjM2IC8qIFZlcnRpY2FsVmlkZW8gKi9dO1xuICBfaW1ldGFzO1xuICBjb25zdHJ1Y3RvcihuZGssIHJhd0V2ZW50KSB7XG4gICAgc3VwZXIobmRrLCByYXdFdmVudCk7XG4gICAgdGhpcy5raW5kID8/PSAzNDIzNSAvKiBIb3Jpem9udGFsVmlkZW8gKi87XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBOREtBcnRpY2xlIGZyb20gYW4gZXhpc3RpbmcgTkRLRXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSBldmVudCBOREtFdmVudCB0byBjcmVhdGUgdGhlIE5ES0FydGljbGUgZnJvbS5cbiAgICogQHJldHVybnMgTkRLQXJ0aWNsZVxuICAgKi9cbiAgc3RhdGljIGZyb20oZXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtWaWRlbyhldmVudC5uZGssIGV2ZW50LnJhd0V2ZW50KCkpO1xuICB9XG4gIC8qKlxuICAgKiBHZXR0ZXIgZm9yIHRoZSBhcnRpY2xlIHRpdGxlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nIHwgdW5kZWZpbmVkfSAtIFRoZSBhcnRpY2xlIHRpdGxlIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIHVuZGVmaW5lZC5cbiAgICovXG4gIGdldCB0aXRsZSgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcInRpdGxlXCIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXR0ZXIgZm9yIHRoZSBhcnRpY2xlIHRpdGxlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gdGl0bGUgLSBUaGUgdGl0bGUgdG8gc2V0IGZvciB0aGUgYXJ0aWNsZS5cbiAgICovXG4gIHNldCB0aXRsZSh0aXRsZSkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwidGl0bGVcIik7XG4gICAgaWYgKHRpdGxlKSB0aGlzLnRhZ3MucHVzaChbXCJ0aXRsZVwiLCB0aXRsZV0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXR0ZXIgZm9yIHRoZSBhcnRpY2xlIHRodW1ibmFpbC5cbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZyB8IHVuZGVmaW5lZH0gLSBUaGUgYXJ0aWNsZSB0aHVtYm5haWwgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgdW5kZWZpbmVkLlxuICAgKi9cbiAgZ2V0IHRodW1ibmFpbCgpIHtcbiAgICBsZXQgdGh1bWJuYWlsO1xuICAgIGlmICh0aGlzLmltZXRhcyAmJiB0aGlzLmltZXRhcy5sZW5ndGggPiAwKSB7XG4gICAgICB0aHVtYm5haWwgPSB0aGlzLmltZXRhc1swXS5pbWFnZT8uWzBdO1xuICAgIH1cbiAgICByZXR1cm4gdGh1bWJuYWlsID8/IHRoaXMudGFnVmFsdWUoXCJ0aHVtYlwiKTtcbiAgfVxuICBnZXQgaW1ldGFzKCkge1xuICAgIGlmICh0aGlzLl9pbWV0YXMpIHJldHVybiB0aGlzLl9pbWV0YXM7XG4gICAgdGhpcy5faW1ldGFzID0gdGhpcy50YWdzLmZpbHRlcigodGFnKSA9PiB0YWdbMF0gPT09IFwiaW1ldGFcIikubWFwKG1hcEltZXRhVGFnKTtcbiAgICByZXR1cm4gdGhpcy5faW1ldGFzO1xuICB9XG4gIHNldCBpbWV0YXModGFncykge1xuICAgIHRoaXMuX2ltZXRhcyA9IHRhZ3M7XG4gICAgdGhpcy50YWdzID0gdGhpcy50YWdzLmZpbHRlcigodGFnKSA9PiB0YWdbMF0gIT09IFwiaW1ldGFcIik7XG4gICAgdGhpcy50YWdzLnB1c2goLi4udGFncy5tYXAoaW1ldGFUYWdUb1RhZykpO1xuICB9XG4gIGdldCB1cmwoKSB7XG4gICAgaWYgKHRoaXMuaW1ldGFzICYmIHRoaXMuaW1ldGFzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiB0aGlzLmltZXRhc1swXS51cmw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwidXJsXCIpO1xuICB9XG4gIC8qKlxuICAgKiBHZXR0ZXIgZm9yIHRoZSBhcnRpY2xlJ3MgcHVibGljYXRpb24gdGltZXN0YW1wLlxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyIHwgdW5kZWZpbmVkfSAtIFRoZSBVbml4IHRpbWVzdGFtcCBvZiB3aGVuIHRoZSBhcnRpY2xlIHdhcyBwdWJsaXNoZWQgb3IgdW5kZWZpbmVkLlxuICAgKi9cbiAgZ2V0IHB1Ymxpc2hlZF9hdCgpIHtcbiAgICBjb25zdCB0YWcgPSB0aGlzLnRhZ1ZhbHVlKFwicHVibGlzaGVkX2F0XCIpO1xuICAgIGlmICh0YWcpIHtcbiAgICAgIHJldHVybiBwYXJzZUludCh0YWcpO1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIC8qKlxuICAgKiBTZXR0ZXIgZm9yIHRoZSBhcnRpY2xlJ3MgcHVibGljYXRpb24gdGltZXN0YW1wLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlciB8IHVuZGVmaW5lZH0gdGltZXN0YW1wIC0gVGhlIFVuaXggdGltZXN0YW1wIHRvIHNldCBmb3IgdGhlIGFydGljbGUncyBwdWJsaWNhdGlvbiBkYXRlLlxuICAgKi9cbiAgc2V0IHB1Ymxpc2hlZF9hdCh0aW1lc3RhbXApIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInB1Ymxpc2hlZF9hdFwiKTtcbiAgICBpZiAodGltZXN0YW1wICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcInB1Ymxpc2hlZF9hdFwiLCB0aW1lc3RhbXAudG9TdHJpbmcoKV0pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGNvbnRlbnQgdGFncyBmb3IgdGhlIGFydGljbGUuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGZpcnN0IGNoZWNrcyBhbmQgc2V0cyB0aGUgcHVibGljYXRpb24gZGF0ZSBpZiBub3QgYXZhaWxhYmxlLFxuICAgKiBhbmQgdGhlbiBnZW5lcmF0ZXMgY29udGVudCB0YWdzIGJhc2VkIG9uIHRoZSBiYXNlIE5ES0V2ZW50IGNsYXNzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Q29udGVudFRhZ30gLSBUaGUgZ2VuZXJhdGVkIGNvbnRlbnQgdGFncy5cbiAgICovXG4gIGFzeW5jIGdlbmVyYXRlVGFncygpIHtcbiAgICBzdXBlci5nZW5lcmF0ZVRhZ3MoKTtcbiAgICBpZiAoIXRoaXMucHVibGlzaGVkX2F0KSB7XG4gICAgICB0aGlzLnB1Ymxpc2hlZF9hdCA9IHRoaXMuY3JlYXRlZF9hdDtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmdlbmVyYXRlVGFncygpO1xuICB9XG4gIGdldCBkdXJhdGlvbigpIHtcbiAgICBjb25zdCB0YWcgPSB0aGlzLnRhZ1ZhbHVlKFwiZHVyYXRpb25cIik7XG4gICAgaWYgKHRhZykge1xuICAgICAgcmV0dXJuIHBhcnNlSW50KHRhZyk7XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgLyoqXG4gICAqIFNldHRlciBmb3IgdGhlIHZpZGVvJ3MgZHVyYXRpb25cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXIgfCB1bmRlZmluZWR9IGR1cmF0aW9uIC0gVGhlIGR1cmF0aW9uIHRvIHNldCBmb3IgdGhlIHZpZGVvIChpbiBzZWNvbmRzKVxuICAgKi9cbiAgc2V0IGR1cmF0aW9uKGR1cikge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwiZHVyYXRpb25cIik7XG4gICAgaWYgKGR1ciAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJkdXJhdGlvblwiLCBNYXRoLmZsb29yKGR1cikudG9TdHJpbmcoKV0pO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2V2ZW50cy9raW5kcy93aWtpLnRzXG52YXIgTkRLV2lraSA9IGNsYXNzIGV4dGVuZHMgTkRLQXJ0aWNsZSB7XG4gIHN0YXRpYyBraW5kID0gMzA4MTggLyogV2lraSAqLztcbiAgc3RhdGljIGtpbmRzID0gWzMwODE4IC8qIFdpa2kgKi9dO1xufTtcblxuLy8gc3JjL2V2ZW50cy93cmFwLnRzXG5mdW5jdGlvbiB3cmFwRXZlbnQoZXZlbnQpIHtcbiAgY29uc3QgZXZlbnRXcmFwcGluZ01hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIFtcbiAgICBOREtJbWFnZSxcbiAgICBOREtWaWRlbyxcbiAgICBOREtDYXNodU1pbnRMaXN0LFxuICAgIE5ES0FydGljbGUsXG4gICAgTkRLSGlnaGxpZ2h0LFxuICAgIE5ES1dpa2ksXG4gICAgTkRLTnV0emFwLFxuICAgIE5ES1NpbXBsZUdyb3VwTWVtYmVyTGlzdCxcbiAgICBOREtTaW1wbGVHcm91cE1ldGFkYXRhLFxuICAgIE5ES1N1YnNjcmlwdGlvblRpZXIsXG4gICAgTkRLQ2FzaHVUb2tlbixcbiAgICBOREtMaXN0XG4gIF0uZm9yRWFjaCgoa2xhc3MyKSA9PiB7XG4gICAga2xhc3MyLmtpbmRzLmZvckVhY2goKGtpbmQpID0+IHtcbiAgICAgIGV2ZW50V3JhcHBpbmdNYXAuc2V0KGtpbmQsIGtsYXNzMik7XG4gICAgfSk7XG4gIH0pO1xuICBjb25zdCBrbGFzcyA9IGV2ZW50V3JhcHBpbmdNYXAuZ2V0KGV2ZW50LmtpbmQpO1xuICBpZiAoa2xhc3MpIHJldHVybiBrbGFzcy5mcm9tKGV2ZW50KTtcbiAgcmV0dXJuIGV2ZW50O1xufVxuXG4vLyBzcmMvc3Vic2NyaXB0aW9uL2luZGV4LnRzXG52YXIgTkRLU3Vic2NyaXB0aW9uQ2FjaGVVc2FnZSA9IC8qIEBfX1BVUkVfXyAqLyAoKE5ES1N1YnNjcmlwdGlvbkNhY2hlVXNhZ2UyKSA9PiB7XG4gIE5ES1N1YnNjcmlwdGlvbkNhY2hlVXNhZ2UyW1wiT05MWV9DQUNIRVwiXSA9IFwiT05MWV9DQUNIRVwiO1xuICBOREtTdWJzY3JpcHRpb25DYWNoZVVzYWdlMltcIkNBQ0hFX0ZJUlNUXCJdID0gXCJDQUNIRV9GSVJTVFwiO1xuICBOREtTdWJzY3JpcHRpb25DYWNoZVVzYWdlMltcIlBBUkFMTEVMXCJdID0gXCJQQVJBTExFTFwiO1xuICBOREtTdWJzY3JpcHRpb25DYWNoZVVzYWdlMltcIk9OTFlfUkVMQVlcIl0gPSBcIk9OTFlfUkVMQVlcIjtcbiAgcmV0dXJuIE5ES1N1YnNjcmlwdGlvbkNhY2hlVXNhZ2UyO1xufSkoTkRLU3Vic2NyaXB0aW9uQ2FjaGVVc2FnZSB8fCB7fSk7XG52YXIgZGVmYXVsdE9wdHMgPSB7XG4gIGNsb3NlT25Fb3NlOiBmYWxzZSxcbiAgY2FjaGVVc2FnZTogXCJDQUNIRV9GSVJTVFwiIC8qIENBQ0hFX0ZJUlNUICovLFxuICBkb250U2F2ZVRvQ2FjaGU6IGZhbHNlLFxuICBncm91cGFibGU6IHRydWUsXG4gIGdyb3VwYWJsZURlbGF5OiAxMDAsXG4gIGdyb3VwYWJsZURlbGF5VHlwZTogXCJhdC1tb3N0XCIsXG4gIGNhY2hlVW5jb25zdHJhaW5GaWx0ZXI6IFtcImxpbWl0XCIsIFwic2luY2VcIiwgXCJ1bnRpbFwiXVxufTtcbnZhciBOREtTdWJzY3JpcHRpb24gPSBjbGFzcyBleHRlbmRzIEV2ZW50RW1pdHRlcjQge1xuICBzdWJJZDtcbiAgZmlsdGVycztcbiAgb3B0cztcbiAgcG9vbDtcbiAgc2tpcFZlcmlmaWNhdGlvbiA9IGZhbHNlO1xuICBza2lwVmFsaWRhdGlvbiA9IGZhbHNlO1xuICAvKipcbiAgICogVHJhY2tzIHRoZSBmaWx0ZXJzIGFzIHRoZXkgYXJlIGV4ZWN1dGVkIG9uIGVhY2ggcmVsYXlcbiAgICovXG4gIHJlbGF5RmlsdGVycztcbiAgcmVsYXlTZXQ7XG4gIG5kaztcbiAgZGVidWc7XG4gIC8qKlxuICAgKiBFdmVudHMgdGhhdCBoYXZlIGJlZW4gc2VlbiBieSB0aGUgc3Vic2NyaXB0aW9uLCB3aXRoIHRoZSB0aW1lIHRoZXkgd2VyZSBmaXJzdCBzZWVuLlxuICAgKi9cbiAgZXZlbnRGaXJzdFNlZW4gPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAvKipcbiAgICogUmVsYXlzIHRoYXQgaGF2ZSBzZW50IGFuIEVPU0UuXG4gICAqL1xuICBlb3Nlc1NlZW4gPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAvKipcbiAgICogVGhlIHRpbWUgdGhlIGxhc3QgZXZlbnQgd2FzIHJlY2VpdmVkIGJ5IHRoZSBzdWJzY3JpcHRpb24uXG4gICAqIFRoaXMgaXMgdXNlZCB0byBjYWxjdWxhdGUgd2hlbiBFT1NFIHNob3VsZCBiZSBlbWl0dGVkLlxuICAgKi9cbiAgbGFzdEV2ZW50UmVjZWl2ZWRBdDtcbiAgaW50ZXJuYWxJZDtcbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIHN1YnNjcmlwdGlvbiBzaG91bGQgY2xvc2Ugd2hlbiBhbGwgcmVsYXlzIGhhdmUgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBldmVudCBzdHJlYW0uXG4gICAqL1xuICBjbG9zZU9uRW9zZTtcbiAgLyoqXG4gICAqIFBvb2wgbW9uaXRvciBjYWxsYmFja1xuICAgKi9cbiAgcG9vbE1vbml0b3I7XG4gIHNraXBPcHRpbWlzdGljUHVibGlzaEV2ZW50ID0gZmFsc2U7XG4gIC8qKlxuICAgKiBGaWx0ZXJzIHRvIHJlbW92ZSB3aGVuIHF1ZXJ5aW5nIHRoZSBjYWNoZS5cbiAgICovXG4gIGNhY2hlVW5jb25zdHJhaW5GaWx0ZXI7XG4gIGNvbnN0cnVjdG9yKG5kaywgZmlsdGVycywgb3B0cywgcmVsYXlTZXQsIHN1YklkKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm5kayA9IG5kaztcbiAgICB0aGlzLnBvb2wgPSBvcHRzPy5wb29sIHx8IG5kay5wb29sO1xuICAgIHRoaXMub3B0cyA9IHsgLi4uZGVmYXVsdE9wdHMsIC4uLm9wdHMgfHwge30gfTtcbiAgICB0aGlzLmZpbHRlcnMgPSBmaWx0ZXJzIGluc3RhbmNlb2YgQXJyYXkgPyBmaWx0ZXJzIDogW2ZpbHRlcnNdO1xuICAgIHRoaXMuc3ViSWQgPSBzdWJJZCB8fCB0aGlzLm9wdHMuc3ViSWQ7XG4gICAgdGhpcy5pbnRlcm5hbElkID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDcpO1xuICAgIHRoaXMucmVsYXlTZXQgPSByZWxheVNldDtcbiAgICB0aGlzLmRlYnVnID0gbmRrLmRlYnVnLmV4dGVuZChgc3Vic2NyaXB0aW9uWyR7dGhpcy5vcHRzLnN1YklkID8/IHRoaXMuaW50ZXJuYWxJZH1dYCk7XG4gICAgdGhpcy5za2lwVmVyaWZpY2F0aW9uID0gdGhpcy5vcHRzLnNraXBWZXJpZmljYXRpb24gfHwgZmFsc2U7XG4gICAgdGhpcy5za2lwVmFsaWRhdGlvbiA9IHRoaXMub3B0cy5za2lwVmFsaWRhdGlvbiB8fCBmYWxzZTtcbiAgICB0aGlzLmNsb3NlT25Fb3NlID0gdGhpcy5vcHRzLmNsb3NlT25Fb3NlIHx8IGZhbHNlO1xuICAgIHRoaXMuc2tpcE9wdGltaXN0aWNQdWJsaXNoRXZlbnQgPSB0aGlzLm9wdHMuc2tpcE9wdGltaXN0aWNQdWJsaXNoRXZlbnQgfHwgZmFsc2U7XG4gICAgdGhpcy5jYWNoZVVuY29uc3RyYWluRmlsdGVyID0gdGhpcy5vcHRzLmNhY2hlVW5jb25zdHJhaW5GaWx0ZXI7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJlbGF5cyB0aGF0IGhhdmUgbm90IHlldCBzZW50IGFuIEVPU0UuXG4gICAqL1xuICByZWxheXNNaXNzaW5nRW9zZSgpIHtcbiAgICBpZiAoIXRoaXMucmVsYXlGaWx0ZXJzKSByZXR1cm4gW107XG4gICAgY29uc3QgcmVsYXlzTWlzc2luZ0Vvc2UgPSBBcnJheS5mcm9tKHRoaXMucmVsYXlGaWx0ZXJzLmtleXMoKSkuZmlsdGVyKFxuICAgICAgKHVybCkgPT4gIXRoaXMuZW9zZXNTZWVuLmhhcyh0aGlzLnBvb2wuZ2V0UmVsYXkodXJsLCBmYWxzZSwgZmFsc2UpKVxuICAgICk7XG4gICAgcmV0dXJuIHJlbGF5c01pc3NpbmdFb3NlO1xuICB9XG4gIC8qKlxuICAgKiBQcm92aWRlcyBhY2Nlc3MgdG8gdGhlIGZpcnN0IGZpbHRlciBvZiB0aGUgc3Vic2NyaXB0aW9uIGZvclxuICAgKiBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgICovXG4gIGdldCBmaWx0ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsdGVyc1swXTtcbiAgfVxuICBnZXQgZ3JvdXBhYmxlRGVsYXkoKSB7XG4gICAgaWYgKCF0aGlzLmlzR3JvdXBhYmxlKCkpIHJldHVybiB2b2lkIDA7XG4gICAgcmV0dXJuIHRoaXMub3B0cz8uZ3JvdXBhYmxlRGVsYXk7XG4gIH1cbiAgZ2V0IGdyb3VwYWJsZURlbGF5VHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRzPy5ncm91cGFibGVEZWxheVR5cGUgfHwgXCJhdC1tb3N0XCI7XG4gIH1cbiAgaXNHcm91cGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0cz8uZ3JvdXBhYmxlIHx8IGZhbHNlO1xuICB9XG4gIHNob3VsZFF1ZXJ5Q2FjaGUoKSB7XG4gICAgaWYgKHRoaXMub3B0cz8uY2FjaGVVc2FnZSA9PT0gXCJPTkxZX1JFTEFZXCIgLyogT05MWV9SRUxBWSAqLykgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGhhc05vbkVwaGVtZXJhbEtpbmQgPSB0aGlzLmZpbHRlcnMuc29tZSgoZikgPT4gZi5raW5kcz8uc29tZSgoaykgPT4ga2luZElzRXBoZW1lcmFsKGspKSk7XG4gICAgaWYgKGhhc05vbkVwaGVtZXJhbEtpbmQpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHNob3VsZFF1ZXJ5UmVsYXlzKCkge1xuICAgIHJldHVybiB0aGlzLm9wdHM/LmNhY2hlVXNhZ2UgIT09IFwiT05MWV9DQUNIRVwiIC8qIE9OTFlfQ0FDSEUgKi87XG4gIH1cbiAgc2hvdWxkV2FpdEZvckNhY2hlKCkge1xuICAgIHJldHVybiAoXG4gICAgICAvLyBNdXN0IHdhbnQgdG8gY2xvc2Ugb24gRU9TRTsgc3Vic2NyaXB0aW9uc1xuICAgICAgLy8gdGhhdCB3YW50IHRvIHJlY2VpdmUgZnVydGhlciB1cGRhdGVzIG11c3RcbiAgICAgIC8vIGFsd2F5cyBoaXQgdGhlIHJlbGF5XG4gICAgICB0aGlzLm9wdHMuY2xvc2VPbkVvc2UgJiYgLy8gQ2FjaGUgYWRhcHRlciBtdXN0IGNsYWltIHRvIGJlIGZhc3RcbiAgICAgICEhdGhpcy5uZGsuY2FjaGVBZGFwdGVyPy5sb2NraW5nICYmIC8vIElmIGV4cGxpY2l0bHkgdG9sZCB0byBydW4gaW4gcGFyYWxsZWwsIHRoZW5cbiAgICAgIC8vIHdlIHNob3VsZCBub3Qgd2FpdCBmb3IgdGhlIGNhY2hlXG4gICAgICB0aGlzLm9wdHMuY2FjaGVVc2FnZSAhPT0gXCJQQVJBTExFTFwiIC8qIFBBUkFMTEVMICovXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogU3RhcnQgdGhlIHN1YnNjcmlwdGlvbi4gVGhpcyBpcyB0aGUgbWFpbiBtZXRob2QgdGhhdCBzaG91bGQgYmUgY2FsbGVkXG4gICAqIGFmdGVyIGNyZWF0aW5nIGEgc3Vic2NyaXB0aW9uLlxuICAgKiBcbiAgICogQHBhcmFtIGVtaXRDYWNoZWRFdmVudHMgLSBXaGV0aGVyIHRvIGVtaXQgZXZlbnRzIGNvbWluZyBmcm9tIGEgc3luY2hyb25vdXMgY2FjaGVcbiAgICogXG4gICAqIFdoZW4gdXNpbmcgYSBzeW5jaHJvbm91cyBjYWNoZSwgdGhlIGV2ZW50cyB3aWxsIGJlIHJldHVybmVkIGltbWVkaWF0ZWx5XG4gICAqIGJ5IHRoaXMgZnVuY3Rpb24uIElmIHlvdSB3aWxsIHVzZSB0aG9zZSByZXR1cm5lZCBldmVudHMsIHlvdSBzaG91bGRcbiAgICogc2V0IGVtaXRDYWNoZWRFdmVudHMgdG8gZmFsc2UgdG8gcHJldmVudCBzZWVpbmcgdGhlbSBhcyBkdXBsaWNhdGUgZXZlbnRzLlxuICAgKi9cbiAgc3RhcnQoZW1pdENhY2hlZEV2ZW50cyA9IHRydWUpIHtcbiAgICBsZXQgY2FjaGVSZXN1bHQ7XG4gICAgY29uc3QgdXBkYXRlU3RhdGVGcm9tQ2FjaGVSZXN1bHRzID0gKGV2ZW50cykgPT4ge1xuICAgICAgaWYgKGVtaXRDYWNoZWRFdmVudHMpIHtcbiAgICAgICAgZm9yIChjb25zdCBldmVudCBvZiBldmVudHMpIHtcbiAgICAgICAgICB0aGlzLmV2ZW50UmVjZWl2ZWQoZXZlbnQsIHZvaWQgMCwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWNoZVJlc3VsdCA9IFtdO1xuICAgICAgICBldmVudHMuZm9yRWFjaCgoZXZlbnQpID0+IHtcbiAgICAgICAgICBldmVudC5uZGsgPSB0aGlzLm5kaztcbiAgICAgICAgICBjb25zdCBlID0gdGhpcy5vcHRzLndyYXAgPyB3cmFwRXZlbnQoZXZlbnQpIDogZXZlbnQ7XG4gICAgICAgICAgaWYgKCFlKSByZXR1cm47XG4gICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICBlLnRoZW4oKHdyYXBwZWRFdmVudCkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLmVtaXRFdmVudChmYWxzZSwgd3JhcHBlZEV2ZW50LCB2b2lkIDAsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmV2ZW50Rmlyc3RTZWVuLnNldChlLmlkLCBEYXRlLm5vdygpKTtcbiAgICAgICAgICBjYWNoZVJlc3VsdC5wdXNoKGUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGxvYWRGcm9tUmVsYXlzID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuc2hvdWxkUXVlcnlSZWxheXMoKSkge1xuICAgICAgICB0aGlzLnN0YXJ0V2l0aFJlbGF5cygpO1xuICAgICAgICB0aGlzLnN0YXJ0UG9vbE1vbml0b3IoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZW1pdChcImVvc2VcIiwgdGhpcyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAodGhpcy5zaG91bGRRdWVyeUNhY2hlKCkpIHtcbiAgICAgIGNhY2hlUmVzdWx0ID0gdGhpcy5zdGFydFdpdGhDYWNoZSgpO1xuICAgICAgaWYgKGNhY2hlUmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICBpZiAodGhpcy5zaG91bGRXYWl0Rm9yQ2FjaGUoKSkge1xuICAgICAgICAgIGNhY2hlUmVzdWx0LnRoZW4oKGV2ZW50cykgPT4ge1xuICAgICAgICAgICAgdXBkYXRlU3RhdGVGcm9tQ2FjaGVSZXN1bHRzKGV2ZW50cyk7XG4gICAgICAgICAgICBpZiAocXVlcnlGdWxseUZpbGxlZCh0aGlzKSkge1xuICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJlb3NlXCIsIHRoaXMpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBsb2FkRnJvbVJlbGF5cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhY2hlUmVzdWx0LnRoZW4oKGV2ZW50cykgPT4ge1xuICAgICAgICAgICAgdXBkYXRlU3RhdGVGcm9tQ2FjaGVSZXN1bHRzKGV2ZW50cyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cGRhdGVTdGF0ZUZyb21DYWNoZVJlc3VsdHMoY2FjaGVSZXN1bHQpO1xuICAgICAgICBpZiAocXVlcnlGdWxseUZpbGxlZCh0aGlzKSkge1xuICAgICAgICAgIHRoaXMuZW1pdChcImVvc2VcIiwgdGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9hZEZyb21SZWxheXMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FjaGVSZXN1bHQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvYWRGcm9tUmVsYXlzKCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFdlIHdhbnQgdG8gbW9uaXRvciBmb3IgbmV3IHJlbGF5cyB0aGF0IGFyZSBjb21pbmcgb25saW5lLCBpbiBjYXNlXG4gICAqIHRoZXkgc2hvdWxkIGJlIHBhcnQgb2YgdGhpcyBzdWJzY3JpcHRpb24uXG4gICAqL1xuICBzdGFydFBvb2xNb25pdG9yKCkge1xuICAgIGNvbnN0IGQ0ID0gdGhpcy5kZWJ1Zy5leHRlbmQoXCJwb29sLW1vbml0b3JcIik7XG4gICAgdGhpcy5wb29sTW9uaXRvciA9IChyZWxheSkgPT4ge1xuICAgICAgaWYgKHRoaXMucmVsYXlGaWx0ZXJzPy5oYXMocmVsYXkudXJsKSkgcmV0dXJuO1xuICAgICAgY29uc3QgY2FsYyA9IGNhbGN1bGF0ZVJlbGF5U2V0c0Zyb21GaWx0ZXJzKHRoaXMubmRrLCB0aGlzLmZpbHRlcnMsIHRoaXMucG9vbCk7XG4gICAgICBpZiAoY2FsYy5nZXQocmVsYXkudXJsKSkge1xuICAgICAgICB0aGlzLnJlbGF5RmlsdGVycz8uc2V0KHJlbGF5LnVybCwgdGhpcy5maWx0ZXJzKTtcbiAgICAgICAgcmVsYXkuc3Vic2NyaWJlKHRoaXMsIHRoaXMuZmlsdGVycyk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnBvb2wub24oXCJyZWxheTpjb25uZWN0XCIsIHRoaXMucG9vbE1vbml0b3IpO1xuICB9XG4gIG9uU3RvcHBlZDtcbiAgc3RvcCgpIHtcbiAgICB0aGlzLmVtaXQoXCJjbG9zZVwiLCB0aGlzKTtcbiAgICB0aGlzLnBvb2xNb25pdG9yICYmIHRoaXMucG9vbC5vZmYoXCJyZWxheTpjb25uZWN0XCIsIHRoaXMucG9vbE1vbml0b3IpO1xuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5vblN0b3BwZWQ/LigpO1xuICB9XG4gIC8qKlxuICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBzdWJzY3JpcHRpb24gaGFzIGFuIGF1dGhvcnMgZmlsdGVyLlxuICAgKi9cbiAgaGFzQXV0aG9yc0ZpbHRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5maWx0ZXJzLnNvbWUoKGYpID0+IGYuYXV0aG9ycz8ubGVuZ3RoKTtcbiAgfVxuICBzdGFydFdpdGhDYWNoZSgpIHtcbiAgICBpZiAodGhpcy5uZGsuY2FjaGVBZGFwdGVyPy5xdWVyeSkge1xuICAgICAgcmV0dXJuIHRoaXMubmRrLmNhY2hlQWRhcHRlci5xdWVyeSh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU2VuZCBSRVEgdG8gcmVsYXlzXG4gICAqL1xuICBzdGFydFdpdGhSZWxheXMoKSB7XG4gICAgaWYgKCF0aGlzLnJlbGF5U2V0IHx8IHRoaXMucmVsYXlTZXQucmVsYXlzLnNpemUgPT09IDApIHtcbiAgICAgIHRoaXMucmVsYXlGaWx0ZXJzID0gY2FsY3VsYXRlUmVsYXlTZXRzRnJvbUZpbHRlcnModGhpcy5uZGssIHRoaXMuZmlsdGVycywgdGhpcy5wb29sKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZWxheUZpbHRlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgZm9yIChjb25zdCByZWxheSBvZiB0aGlzLnJlbGF5U2V0LnJlbGF5cykge1xuICAgICAgICB0aGlzLnJlbGF5RmlsdGVycy5zZXQocmVsYXkudXJsLCB0aGlzLmZpbHRlcnMpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRoaXMucmVsYXlGaWx0ZXJzIHx8IHRoaXMucmVsYXlGaWx0ZXJzLnNpemUgPT09IDApIHJldHVybjtcbiAgICBmb3IgKGNvbnN0IFtyZWxheVVybCwgZmlsdGVyc10gb2YgdGhpcy5yZWxheUZpbHRlcnMpIHtcbiAgICAgIGNvbnN0IHJlbGF5ID0gdGhpcy5wb29sLmdldFJlbGF5KHJlbGF5VXJsLCB0cnVlLCB0cnVlLCBmaWx0ZXJzKTtcbiAgICAgIHJlbGF5LnN1YnNjcmliZSh0aGlzLCBmaWx0ZXJzKTtcbiAgICB9XG4gIH1cbiAgLy8gRVZFTlQgaGFuZGxpbmdcbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIGFuIGV2ZW50IGlzIHJlY2VpdmVkIGZyb20gYSByZWxheSBvciB0aGUgY2FjaGVcbiAgICogQHBhcmFtIGV2ZW50XG4gICAqIEBwYXJhbSByZWxheVxuICAgKiBAcGFyYW0gZnJvbUNhY2hlIFdoZXRoZXIgdGhlIGV2ZW50IHdhcyByZWNlaXZlZCBmcm9tIHRoZSBjYWNoZVxuICAgKiBAcGFyYW0gb3B0aW1pc3RpY1B1Ymxpc2ggV2hldGhlciB0aGlzIGV2ZW50IGlzIGNvbWluZyBmcm9tIGFuIG9wdGltaXN0aWMgcHVibGlzaFxuICAgKi9cbiAgZXZlbnRSZWNlaXZlZChldmVudCwgcmVsYXksIGZyb21DYWNoZSA9IGZhbHNlLCBvcHRpbWlzdGljUHVibGlzaCA9IGZhbHNlKSB7XG4gICAgY29uc3QgZXZlbnRJZCA9IGV2ZW50LmlkO1xuICAgIGNvbnN0IGV2ZW50QWxyZWFkeVNlZW4gPSB0aGlzLmV2ZW50Rmlyc3RTZWVuLmhhcyhldmVudElkKTtcbiAgICBsZXQgbmRrRXZlbnQ7XG4gICAgaWYgKGV2ZW50IGluc3RhbmNlb2YgTkRLRXZlbnQpIG5ka0V2ZW50ID0gZXZlbnQ7XG4gICAgaWYgKCFldmVudEFscmVhZHlTZWVuKSB7XG4gICAgICBuZGtFdmVudCA/Pz0gbmV3IE5ES0V2ZW50KHRoaXMubmRrLCBldmVudCk7XG4gICAgICBuZGtFdmVudC5uZGsgPSB0aGlzLm5kaztcbiAgICAgIG5ka0V2ZW50LnJlbGF5ID0gcmVsYXk7XG4gICAgICBpZiAoIWZyb21DYWNoZSAmJiAhb3B0aW1pc3RpY1B1Ymxpc2gpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNraXBWYWxpZGF0aW9uKSB7XG4gICAgICAgICAgaWYgKCFuZGtFdmVudC5pc1ZhbGlkKSB7XG4gICAgICAgICAgICB0aGlzLmRlYnVnKGBFdmVudCBmYWlsZWQgdmFsaWRhdGlvbiAlcyBmcm9tIHJlbGF5ICVzYCwgZXZlbnRJZCwgcmVsYXk/LnVybCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZWxheSkge1xuICAgICAgICAgIGlmIChyZWxheT8uc2hvdWxkVmFsaWRhdGVFdmVudCgpICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnNraXBWZXJpZmljYXRpb24pIHtcbiAgICAgICAgICAgICAgaWYgKCFuZGtFdmVudC52ZXJpZnlTaWduYXR1cmUodHJ1ZSkgJiYgIXRoaXMubmRrLmFzeW5jU2lnVmVyaWZpY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWJ1ZyhgRXZlbnQgZmFpbGVkIHNpZ25hdHVyZSB2YWxpZGF0aW9uYCwgZXZlbnQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZWxheSkge1xuICAgICAgICAgICAgICAgIHJlbGF5LmFkZFZhbGlkYXRlZEV2ZW50KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVsYXkuYWRkTm9uVmFsaWRhdGVkRXZlbnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubmRrLmNhY2hlQWRhcHRlciAmJiAhdGhpcy5vcHRzLmRvbnRTYXZlVG9DYWNoZSkge1xuICAgICAgICAgIHRoaXMubmRrLmNhY2hlQWRhcHRlci5zZXRFdmVudChuZGtFdmVudCwgdGhpcy5maWx0ZXJzLCByZWxheSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghb3B0aW1pc3RpY1B1Ymxpc2ggfHwgdGhpcy5za2lwT3B0aW1pc3RpY1B1Ymxpc2hFdmVudCAhPT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmVtaXRFdmVudCh0aGlzLm9wdHM/LndyYXAsIG5ka0V2ZW50LCByZWxheSwgZnJvbUNhY2hlLCBvcHRpbWlzdGljUHVibGlzaCk7XG4gICAgICAgIHRoaXMuZXZlbnRGaXJzdFNlZW4uc2V0KGV2ZW50SWQsIERhdGUubm93KCkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0aW1lU2luY2VGaXJzdFNlZW4gPSBEYXRlLm5vdygpIC0gKHRoaXMuZXZlbnRGaXJzdFNlZW4uZ2V0KGV2ZW50SWQpIHx8IDApO1xuICAgICAgdGhpcy5lbWl0KFwiZXZlbnQ6ZHVwXCIsIGV2ZW50LCByZWxheSwgdGltZVNpbmNlRmlyc3RTZWVuLCB0aGlzLCBmcm9tQ2FjaGUsIG9wdGltaXN0aWNQdWJsaXNoKTtcbiAgICAgIGlmIChyZWxheSkge1xuICAgICAgICBjb25zdCBzaWduYXR1cmUgPSB2ZXJpZmllZFNpZ25hdHVyZXMuZ2V0KGV2ZW50SWQpO1xuICAgICAgICBpZiAoc2lnbmF0dXJlICYmIHR5cGVvZiBzaWduYXR1cmUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBpZiAoZXZlbnQuc2lnID09PSBzaWduYXR1cmUpIHtcbiAgICAgICAgICAgIHJlbGF5LmFkZFZhbGlkYXRlZEV2ZW50KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubGFzdEV2ZW50UmVjZWl2ZWRBdCA9IERhdGUubm93KCk7XG4gIH1cbiAgLyoqXG4gICAqIE9wdGlvbmFsbHkgd3JhcHMsIHN5bmMgb3IgYXN5bmMsIGFuZCBlbWl0cyB0aGUgZXZlbnQgKGlmIG9uZSBjb21lcyBiYWNrIGZyb20gdGhlIHdyYXBwZXIpXG4gICAqL1xuICBlbWl0RXZlbnQod3JhcCA9IGZhbHNlLCBldnQsIHJlbGF5LCBmcm9tQ2FjaGUsIG9wdGltaXN0aWNQdWJsaXNoKSB7XG4gICAgY29uc3Qgd3JhcHBlZCA9IHdyYXAgPyB3cmFwRXZlbnQoZXZ0KSA6IGV2dDtcbiAgICBpZiAod3JhcHBlZCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgIHdyYXBwZWQudGhlbigoZSkgPT4gdGhpcy5lbWl0RXZlbnQoZmFsc2UsIGUsIHJlbGF5LCBmcm9tQ2FjaGUsIG9wdGltaXN0aWNQdWJsaXNoKSk7XG4gICAgfSBlbHNlIGlmICh3cmFwcGVkKSB7XG4gICAgICB0aGlzLmVtaXQoXCJldmVudFwiLCB3cmFwcGVkLCByZWxheSwgdGhpcywgZnJvbUNhY2hlLCBvcHRpbWlzdGljUHVibGlzaCk7XG4gICAgfVxuICB9XG4gIGNsb3NlZFJlY2VpdmVkKHJlbGF5LCByZWFzb24pIHtcbiAgICB0aGlzLmVtaXQoXCJjbG9zZWRcIiwgcmVsYXksIHJlYXNvbik7XG4gIH1cbiAgLy8gRU9TRSBoYW5kbGluZ1xuICBlb3NlVGltZW91dDtcbiAgZW9zZWQgPSBmYWxzZTtcbiAgZW9zZVJlY2VpdmVkKHJlbGF5KSB7XG4gICAgdGhpcy5kZWJ1ZyhcIkVPU0UgcmVjZWl2ZWQgZnJvbSAlc1wiLCByZWxheS51cmwpO1xuICAgIHRoaXMuZW9zZXNTZWVuLmFkZChyZWxheSk7XG4gICAgbGV0IGxhc3RFdmVudFNlZW4gPSB0aGlzLmxhc3RFdmVudFJlY2VpdmVkQXQgPyBEYXRlLm5vdygpIC0gdGhpcy5sYXN0RXZlbnRSZWNlaXZlZEF0IDogdm9pZCAwO1xuICAgIGNvbnN0IGhhc1NlZW5BbGxFb3NlcyA9IHRoaXMuZW9zZXNTZWVuLnNpemUgPT09IHRoaXMucmVsYXlGaWx0ZXJzPy5zaXplO1xuICAgIGNvbnN0IHF1ZXJ5RmlsbGVkID0gcXVlcnlGdWxseUZpbGxlZCh0aGlzKTtcbiAgICBjb25zdCBwZXJmb3JtRW9zZSA9IChyZWFzb24pID0+IHtcbiAgICAgIHRoaXMuZGVidWcoXCJQZXJmb3JtaW5nIEVPU0U6ICVzICVkXCIsIHJlYXNvbiwgdGhpcy5lb3NlZCk7XG4gICAgICBpZiAodGhpcy5lb3NlZCkgcmV0dXJuO1xuICAgICAgaWYgKHRoaXMuZW9zZVRpbWVvdXQpIGNsZWFyVGltZW91dCh0aGlzLmVvc2VUaW1lb3V0KTtcbiAgICAgIHRoaXMuZW1pdChcImVvc2VcIiwgdGhpcyk7XG4gICAgICB0aGlzLmVvc2VkID0gdHJ1ZTtcbiAgICB9O1xuICAgIGlmIChxdWVyeUZpbGxlZCB8fCBoYXNTZWVuQWxsRW9zZXMpIHtcbiAgICAgIHBlcmZvcm1Fb3NlKFwicXVlcnkgZmlsbGVkIG9yIHNlZW4gYWxsXCIpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5yZWxheUZpbHRlcnMpIHtcbiAgICAgIGxldCB0aW1lVG9XYWl0Rm9yTmV4dEVvc2UgPSAxZTM7XG4gICAgICBjb25zdCBjb25uZWN0ZWRSZWxheXMgPSBuZXcgU2V0KHRoaXMucG9vbC5jb25uZWN0ZWRSZWxheXMoKS5tYXAoKHIpID0+IHIudXJsKSk7XG4gICAgICBjb25zdCBjb25uZWN0ZWRSZWxheXNXaXRoRmlsdGVycyA9IEFycmF5LmZyb20odGhpcy5yZWxheUZpbHRlcnMua2V5cygpKS5maWx0ZXIoXG4gICAgICAgICh1cmwpID0+IGNvbm5lY3RlZFJlbGF5cy5oYXModXJsKVxuICAgICAgKTtcbiAgICAgIGlmIChjb25uZWN0ZWRSZWxheXNXaXRoRmlsdGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcGVyY2VudGFnZU9mUmVsYXlzVGhhdEhhdmVTZW50RW9zZSA9IHRoaXMuZW9zZXNTZWVuLnNpemUgLyBjb25uZWN0ZWRSZWxheXNXaXRoRmlsdGVycy5sZW5ndGg7XG4gICAgICB0aGlzLmRlYnVnKFwiUGVyY2VudGFnZSBvZiByZWxheXMgdGhhdCBoYXZlIHNlbnQgRU9TRVwiLCB7IHN1YklkOiB0aGlzLnN1YklkLCBwZXJjZW50YWdlT2ZSZWxheXNUaGF0SGF2ZVNlbnRFb3NlLCBzZWVuOiB0aGlzLmVvc2VzU2Vlbi5zaXplLCB0b3RhbDogY29ubmVjdGVkUmVsYXlzV2l0aEZpbHRlcnMubGVuZ3RoIH0pO1xuICAgICAgaWYgKHRoaXMuZW9zZXNTZWVuLnNpemUgPj0gMiAmJiBwZXJjZW50YWdlT2ZSZWxheXNUaGF0SGF2ZVNlbnRFb3NlID49IDAuNSkge1xuICAgICAgICB0aW1lVG9XYWl0Rm9yTmV4dEVvc2UgPSB0aW1lVG9XYWl0Rm9yTmV4dEVvc2UgKiAoMSAtIHBlcmNlbnRhZ2VPZlJlbGF5c1RoYXRIYXZlU2VudEVvc2UpO1xuICAgICAgICBpZiAodGltZVRvV2FpdEZvck5leHRFb3NlID09PSAwKSB7XG4gICAgICAgICAgcGVyZm9ybUVvc2UoXCJ0aW1lIHRvIHdhaXQgd2FzIDBcIik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmVvc2VUaW1lb3V0KSBjbGVhclRpbWVvdXQodGhpcy5lb3NlVGltZW91dCk7XG4gICAgICAgIGNvbnN0IHNlbmRFb3NlVGltZW91dCA9ICgpID0+IHtcbiAgICAgICAgICBsYXN0RXZlbnRTZWVuID0gdGhpcy5sYXN0RXZlbnRSZWNlaXZlZEF0ID8gRGF0ZS5ub3coKSAtIHRoaXMubGFzdEV2ZW50UmVjZWl2ZWRBdCA6IHZvaWQgMDtcbiAgICAgICAgICBpZiAobGFzdEV2ZW50U2VlbiAhPT0gdm9pZCAwICYmIGxhc3RFdmVudFNlZW4gPCAyMCkge1xuICAgICAgICAgICAgdGhpcy5lb3NlVGltZW91dCA9IHNldFRpbWVvdXQoc2VuZEVvc2VUaW1lb3V0LCB0aW1lVG9XYWl0Rm9yTmV4dEVvc2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZXJmb3JtRW9zZShcInNlbmQgZW9zZSB0aW1lb3V0OiBcIiArIHRpbWVUb1dhaXRGb3JOZXh0RW9zZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmVvc2VUaW1lb3V0ID0gc2V0VGltZW91dChzZW5kRW9zZVRpbWVvdXQsIHRpbWVUb1dhaXRGb3JOZXh0RW9zZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xudmFyIGtpbmRJc0VwaGVtZXJhbCA9IChraW5kKSA9PiBraW5kID49IDJlNCAmJiBraW5kIDwgM2U0O1xuXG4vLyBzcmMvdXNlci9mb2xsb3dzLnRzXG5hc3luYyBmdW5jdGlvbiBmb2xsb3dzKG9wdHMsIG91dGJveCwga2luZCA9IDMgLyogQ29udGFjdHMgKi8pIHtcbiAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTkRLIG5vdCBzZXRcIik7XG4gIGNvbnN0IGNvbnRhY3RMaXN0RXZlbnQgPSBhd2FpdCB0aGlzLm5kay5mZXRjaEV2ZW50KFxuICAgIHsga2luZHM6IFtraW5kXSwgYXV0aG9yczogW3RoaXMucHVia2V5XSB9LFxuICAgIG9wdHMgfHwgeyBncm91cGFibGU6IGZhbHNlIH1cbiAgKTtcbiAgaWYgKGNvbnRhY3RMaXN0RXZlbnQpIHtcbiAgICBjb25zdCBwdWJrZXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBjb250YWN0TGlzdEV2ZW50LnRhZ3MuZm9yRWFjaCgodGFnKSA9PiB7XG4gICAgICBpZiAodGFnWzBdID09PSBcInBcIikgcHVia2V5cy5hZGQodGFnWzFdKTtcbiAgICB9KTtcbiAgICBpZiAob3V0Ym94KSB7XG4gICAgICB0aGlzLm5kaz8ub3V0Ym94VHJhY2tlcj8udHJhY2tVc2VycyhBcnJheS5mcm9tKHB1YmtleXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIFsuLi5wdWJrZXlzXS5yZWR1Y2UoKGFjYywgcHVia2V5KSA9PiB7XG4gICAgICBjb25zdCB1c2VyID0gbmV3IE5ES1VzZXIoeyBwdWJrZXkgfSk7XG4gICAgICB1c2VyLm5kayA9IHRoaXMubmRrO1xuICAgICAgYWNjLmFkZCh1c2VyKTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSk7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG59XG5cbi8vIHNyYy91c2VyL3Byb2ZpbGUudHNcbmZ1bmN0aW9uIHByb2ZpbGVGcm9tRXZlbnQoZXZlbnQpIHtcbiAgY29uc3QgcHJvZmlsZSA9IHt9O1xuICBsZXQgcGF5bG9hZDtcbiAgdHJ5IHtcbiAgICBwYXlsb2FkID0gSlNPTi5wYXJzZShldmVudC5jb250ZW50KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwYXJzZSBwcm9maWxlIGV2ZW50OiAke2Vycm9yfWApO1xuICB9XG4gIHByb2ZpbGUuY3JlYXRlZF9hdCA9IGV2ZW50LmNyZWF0ZWRfYXQ7XG4gIHByb2ZpbGUucHJvZmlsZUV2ZW50ID0gSlNPTi5zdHJpbmdpZnkoZXZlbnQucmF3RXZlbnQoKSk7XG4gIE9iamVjdC5rZXlzKHBheWxvYWQpLmZvckVhY2goKGtleSkgPT4ge1xuICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICBjYXNlIFwibmFtZVwiOlxuICAgICAgICBwcm9maWxlLm5hbWUgPSBwYXlsb2FkLm5hbWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImRpc3BsYXlfbmFtZVwiOlxuICAgICAgICBwcm9maWxlLmRpc3BsYXlOYW1lID0gcGF5bG9hZC5kaXNwbGF5X25hbWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImltYWdlXCI6XG4gICAgICBjYXNlIFwicGljdHVyZVwiOlxuICAgICAgICBwcm9maWxlLnBpY3R1cmUgPSBwYXlsb2FkLnBpY3R1cmUgfHwgcGF5bG9hZC5pbWFnZTtcbiAgICAgICAgcHJvZmlsZS5pbWFnZSA9IHByb2ZpbGUucGljdHVyZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYmFubmVyXCI6XG4gICAgICAgIHByb2ZpbGUuYmFubmVyID0gcGF5bG9hZC5iYW5uZXI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImJpb1wiOlxuICAgICAgICBwcm9maWxlLmJpbyA9IHBheWxvYWQuYmlvO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJuaXAwNVwiOlxuICAgICAgICBwcm9maWxlLm5pcDA1ID0gcGF5bG9hZC5uaXAwNTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibHVkMDZcIjpcbiAgICAgICAgcHJvZmlsZS5sdWQwNiA9IHBheWxvYWQubHVkMDY7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImx1ZDE2XCI6XG4gICAgICAgIHByb2ZpbGUubHVkMTYgPSBwYXlsb2FkLmx1ZDE2O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJhYm91dFwiOlxuICAgICAgICBwcm9maWxlLmFib3V0ID0gcGF5bG9hZC5hYm91dDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwid2Vic2l0ZVwiOlxuICAgICAgICBwcm9maWxlLndlYnNpdGUgPSBwYXlsb2FkLndlYnNpdGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcHJvZmlsZVtrZXldID0gcGF5bG9hZFtrZXldO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcHJvZmlsZTtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZVByb2ZpbGUocHJvZmlsZSkge1xuICBjb25zdCBwYXlsb2FkID0ge307XG4gIGZvciAoY29uc3QgW2tleSwgdmFsXSBvZiBPYmplY3QuZW50cmllcyhwcm9maWxlKSkge1xuICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICBjYXNlIFwidXNlcm5hbWVcIjpcbiAgICAgIGNhc2UgXCJuYW1lXCI6XG4gICAgICAgIHBheWxvYWQubmFtZSA9IHZhbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZGlzcGxheU5hbWVcIjpcbiAgICAgICAgcGF5bG9hZC5kaXNwbGF5X25hbWUgPSB2YWw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImltYWdlXCI6XG4gICAgICBjYXNlIFwicGljdHVyZVwiOlxuICAgICAgICBwYXlsb2FkLnBpY3R1cmUgPSB2YWw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImJpb1wiOlxuICAgICAgY2FzZSBcImFib3V0XCI6XG4gICAgICAgIHBheWxvYWQuYWJvdXQgPSB2YWw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcGF5bG9hZFtrZXldID0gdmFsO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHBheWxvYWQpO1xufVxuXG4vLyBzcmMvdXNlci9uaXAwNS50c1xudmFyIE5JUDA1X1JFR0VYID0gL14oPzooW1xcdy4rLV0rKUApPyhbXFx3Li1dKykkLztcbmFzeW5jIGZ1bmN0aW9uIGdldE5pcDA1Rm9yKG5kaywgZnVsbG5hbWUsIF9mZXRjaCA9IGZldGNoLCBmZXRjaE9wdHMgPSB7fSkge1xuICByZXR1cm4gYXdhaXQgbmRrLnF1ZXVlc05pcDA1LmFkZCh7XG4gICAgaWQ6IGZ1bGxuYW1lLFxuICAgIGZ1bmM6IGFzeW5jICgpID0+IHtcbiAgICAgIGlmIChuZGsuY2FjaGVBZGFwdGVyICYmIG5kay5jYWNoZUFkYXB0ZXIubG9hZE5pcDA1KSB7XG4gICAgICAgIGNvbnN0IHByb2ZpbGUgPSBhd2FpdCBuZGsuY2FjaGVBZGFwdGVyLmxvYWROaXAwNShmdWxsbmFtZSk7XG4gICAgICAgIGlmIChwcm9maWxlICE9PSBcIm1pc3NpbmdcIikge1xuICAgICAgICAgIGlmIChwcm9maWxlKSB7XG4gICAgICAgICAgICBjb25zdCB1c2VyID0gbmV3IE5ES1VzZXIoe1xuICAgICAgICAgICAgICBwdWJrZXk6IHByb2ZpbGUucHVia2V5LFxuICAgICAgICAgICAgICByZWxheVVybHM6IHByb2ZpbGUucmVsYXlzLFxuICAgICAgICAgICAgICBuaXA0NlVybHM6IHByb2ZpbGUubmlwNDZcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdXNlci5uZGsgPSBuZGs7XG4gICAgICAgICAgICByZXR1cm4gdXNlcjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGZldGNoT3B0cy5jYWNoZSAhPT0gXCJuby1jYWNoZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IG1hdGNoID0gZnVsbG5hbWUubWF0Y2goTklQMDVfUkVHRVgpO1xuICAgICAgaWYgKCFtYXRjaCkgcmV0dXJuIG51bGw7XG4gICAgICBjb25zdCBbXywgbmFtZSA9IFwiX1wiLCBkb21haW5dID0gbWF0Y2g7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBfZmV0Y2goXG4gICAgICAgICAgYGh0dHBzOi8vJHtkb21haW59Ly53ZWxsLWtub3duL25vc3RyLmpzb24/bmFtZT0ke25hbWV9YCxcbiAgICAgICAgICBmZXRjaE9wdHNcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgeyBuYW1lcywgcmVsYXlzLCBuaXA0NiB9ID0gcGFyc2VOSVAwNVJlc3VsdChhd2FpdCByZXMuanNvbigpKTtcbiAgICAgICAgY29uc3QgcHVia2V5ID0gbmFtZXNbbmFtZS50b0xvd2VyQ2FzZSgpXTtcbiAgICAgICAgbGV0IHByb2ZpbGUgPSBudWxsO1xuICAgICAgICBpZiAocHVia2V5KSB7XG4gICAgICAgICAgcHJvZmlsZSA9IHsgcHVia2V5LCByZWxheXM6IHJlbGF5cz8uW3B1YmtleV0sIG5pcDQ2OiBuaXA0Nj8uW3B1YmtleV0gfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmRrPy5jYWNoZUFkYXB0ZXIgJiYgbmRrLmNhY2hlQWRhcHRlci5zYXZlTmlwMDUpIHtcbiAgICAgICAgICBuZGsuY2FjaGVBZGFwdGVyLnNhdmVOaXAwNShmdWxsbmFtZSwgcHJvZmlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb2ZpbGU7XG4gICAgICB9IGNhdGNoIChfZSkge1xuICAgICAgICBpZiAobmRrPy5jYWNoZUFkYXB0ZXIgJiYgbmRrLmNhY2hlQWRhcHRlci5zYXZlTmlwMDUpIHtcbiAgICAgICAgICBuZGs/LmNhY2hlQWRhcHRlci5zYXZlTmlwMDUoZnVsbG5hbWUsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gZmV0Y2ggTklQMDUgZm9yXCIsIGZ1bGxuYW1lLCBfZSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBwYXJzZU5JUDA1UmVzdWx0KGpzb24pIHtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIG5hbWVzOiB7fVxuICB9O1xuICBmb3IgKGNvbnN0IFtuYW1lLCBwdWJrZXldIG9mIE9iamVjdC5lbnRyaWVzKGpzb24ubmFtZXMpKSB7XG4gICAgaWYgKHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBwdWJrZXkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJlc3VsdC5uYW1lc1tuYW1lLnRvTG93ZXJDYXNlKCldID0gcHVia2V5O1xuICAgIH1cbiAgfVxuICBpZiAoanNvbi5yZWxheXMpIHtcbiAgICByZXN1bHQucmVsYXlzID0ge307XG4gICAgZm9yIChjb25zdCBbcHVia2V5LCByZWxheXNdIG9mIE9iamVjdC5lbnRyaWVzKGpzb24ucmVsYXlzKSkge1xuICAgICAgaWYgKHR5cGVvZiBwdWJrZXkgPT09IFwic3RyaW5nXCIgJiYgQXJyYXkuaXNBcnJheShyZWxheXMpKSB7XG4gICAgICAgIHJlc3VsdC5yZWxheXNbcHVia2V5XSA9IHJlbGF5cy5maWx0ZXIoXG4gICAgICAgICAgKHJlbGF5KSA9PiB0eXBlb2YgcmVsYXkgPT09IFwic3RyaW5nXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGpzb24ubmlwNDYpIHtcbiAgICByZXN1bHQubmlwNDYgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtwdWJrZXksIG5pcDQ2XSBvZiBPYmplY3QuZW50cmllcyhqc29uLm5pcDQ2KSkge1xuICAgICAgaWYgKHR5cGVvZiBwdWJrZXkgPT09IFwic3RyaW5nXCIgJiYgQXJyYXkuaXNBcnJheShuaXA0NikpIHtcbiAgICAgICAgcmVzdWx0Lm5pcDQ2W3B1YmtleV0gPSBuaXA0Ni5maWx0ZXIoKHJlbGF5KSA9PiB0eXBlb2YgcmVsYXkgPT09IFwic3RyaW5nXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBzcmMvdXNlci9pbmRleC50c1xudmFyIE5ES1VzZXIgPSBjbGFzcyBfTkRLVXNlciB7XG4gIG5kaztcbiAgcHJvZmlsZTtcbiAgcHJvZmlsZUV2ZW50O1xuICBfbnB1YjtcbiAgX3B1YmtleTtcbiAgcmVsYXlVcmxzID0gW107XG4gIG5pcDQ2VXJscyA9IFtdO1xuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgaWYgKG9wdHMubnB1YikgdGhpcy5fbnB1YiA9IG9wdHMubnB1YjtcbiAgICBpZiAob3B0cy5oZXhwdWJrZXkpIHRoaXMuX3B1YmtleSA9IG9wdHMuaGV4cHVia2V5O1xuICAgIGlmIChvcHRzLnB1YmtleSkgdGhpcy5fcHVia2V5ID0gb3B0cy5wdWJrZXk7XG4gICAgaWYgKG9wdHMucmVsYXlVcmxzKSB0aGlzLnJlbGF5VXJscyA9IG9wdHMucmVsYXlVcmxzO1xuICAgIGlmIChvcHRzLm5pcDQ2VXJscykgdGhpcy5uaXA0NlVybHMgPSBvcHRzLm5pcDQ2VXJscztcbiAgfVxuICBnZXQgbnB1YigpIHtcbiAgICBpZiAoIXRoaXMuX25wdWIpIHtcbiAgICAgIGlmICghdGhpcy5fcHVia2V5KSB0aHJvdyBuZXcgRXJyb3IoXCJwdWJrZXkgbm90IHNldFwiKTtcbiAgICAgIHRoaXMuX25wdWIgPSBuaXAxOTUubnB1YkVuY29kZSh0aGlzLnB1YmtleSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9ucHViO1xuICB9XG4gIGdldCBucHJvZmlsZSgpIHtcbiAgICBjb25zdCByZWxheXMgPSB0aGlzLnByb2ZpbGVFdmVudD8ub25SZWxheXM/Lm1hcCgocikgPT4gci51cmwpO1xuICAgIHJldHVybiBuaXAxOTUubnByb2ZpbGVFbmNvZGUoe1xuICAgICAgcHVia2V5OiB0aGlzLnB1YmtleSxcbiAgICAgIHJlbGF5c1xuICAgIH0pO1xuICB9XG4gIHNldCBucHViKG5wdWIpIHtcbiAgICB0aGlzLl9ucHViID0gbnB1YjtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSB1c2VyJ3MgcHVia2V5XG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSB1c2VyJ3MgcHVia2V5XG4gICAqL1xuICBnZXQgcHVia2V5KCkge1xuICAgIGlmICghdGhpcy5fcHVia2V5KSB7XG4gICAgICBpZiAoIXRoaXMuX25wdWIpIHRocm93IG5ldyBFcnJvcihcIm5wdWIgbm90IHNldFwiKTtcbiAgICAgIHRoaXMuX3B1YmtleSA9IG5pcDE5NS5kZWNvZGUodGhpcy5ucHViKS5kYXRhO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcHVia2V5O1xuICB9XG4gIC8qKlxuICAgKiBTZXQgdGhlIHVzZXIncyBwdWJrZXlcbiAgICogQHBhcmFtIHB1YmtleSB7c3RyaW5nfSBUaGUgdXNlcidzIHB1YmtleVxuICAgKi9cbiAgc2V0IHB1YmtleShwdWJrZXkpIHtcbiAgICB0aGlzLl9wdWJrZXkgPSBwdWJrZXk7XG4gIH1cbiAgLyoqXG4gICAqIEVxdWl2YWxlbnQgdG8gTkRLRXZlbnQuZmlsdGVycygpLlxuICAgKiBAcmV0dXJucyB7TkRLRmlsdGVyfVxuICAgKi9cbiAgZmlsdGVyKCkge1xuICAgIHJldHVybiB7IFwiI3BcIjogW3RoaXMucHVia2V5XSB9O1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIE5JUC01NyBhbmQgTklQLTYxIGluZm9ybWF0aW9uIHRoYXQgdGhpcyB1c2VyIGhhcyBzaWduYWxlZFxuICAgKlxuICAgKiBAcGFyYW0gZ2V0QWxsIHtib29sZWFufSBXaGV0aGVyIHRvIGdldCBhbGwgemFwIGluZm8gb3IganVzdCB0aGUgZmlyc3Qgb25lXG4gICAqL1xuICBhc3luYyBnZXRaYXBJbmZvKHRpbWVvdXRNcykge1xuICAgIGlmICghdGhpcy5uZGspIHRocm93IG5ldyBFcnJvcihcIk5vIE5ESyBpbnN0YW5jZSBmb3VuZFwiKTtcbiAgICBjb25zdCBwcm9taXNlV2l0aFRpbWVvdXQgPSBhc3luYyAocHJvbWlzZSkgPT4ge1xuICAgICAgaWYgKCF0aW1lb3V0TXMpIHJldHVybiBwcm9taXNlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IFByb21pc2UucmFjZShbXG4gICAgICAgICAgcHJvbWlzZSxcbiAgICAgICAgICBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiBzZXRUaW1lb3V0KCgpID0+IHJlamVjdCgpLCB0aW1lb3V0TXMpKVxuICAgICAgICBdKTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgW3VzZXJQcm9maWxlLCBtaW50TGlzdEV2ZW50XSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgIHByb21pc2VXaXRoVGltZW91dCh0aGlzLmZldGNoUHJvZmlsZSgpKSxcbiAgICAgIHByb21pc2VXaXRoVGltZW91dCh0aGlzLm5kay5mZXRjaEV2ZW50KHsga2luZHM6IFsxMDAxOSAvKiBDYXNodU1pbnRMaXN0ICovXSwgYXV0aG9yczogW3RoaXMucHVia2V5XSB9KSlcbiAgICBdKTtcbiAgICBjb25zdCByZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGlmIChtaW50TGlzdEV2ZW50KSB7XG4gICAgICBjb25zdCBtaW50TGlzdCA9IE5ES0Nhc2h1TWludExpc3QuZnJvbShtaW50TGlzdEV2ZW50KTtcbiAgICAgIGlmIChtaW50TGlzdC5taW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJlcy5zZXQoXCJuaXA2MVwiLCB7XG4gICAgICAgICAgbWludHM6IG1pbnRMaXN0Lm1pbnRzLFxuICAgICAgICAgIHJlbGF5czogbWludExpc3QucmVsYXlzLFxuICAgICAgICAgIHAycGs6IG1pbnRMaXN0LnAycGtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh1c2VyUHJvZmlsZSkge1xuICAgICAgY29uc3QgeyBsdWQwNiwgbHVkMTYgfSA9IHVzZXJQcm9maWxlO1xuICAgICAgcmVzLnNldChcIm5pcDU3XCIsIHsgbHVkMDYsIGx1ZDE2IH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIC8qKlxuICAgKiBJbnN0YW50aWF0ZSBhbiBOREtVc2VyIGZyb20gYSBOSVAtMDUgc3RyaW5nXG4gICAqIEBwYXJhbSBuaXAwNUlkIHtzdHJpbmd9IFRoZSB1c2VyJ3MgTklQLTA1XG4gICAqIEBwYXJhbSBuZGsge05ES30gQW4gTkRLIGluc3RhbmNlXG4gICAqIEBwYXJhbSBza2lwQ2FjaGUge2Jvb2xlYW59IFdoZXRoZXIgdG8gc2tpcCB0aGUgY2FjaGUgb3Igbm90XG4gICAqIEByZXR1cm5zIHtOREtVc2VyIHwgdW5kZWZpbmVkfSBBbiBOREtVc2VyIGlmIG9uZSBpcyBmb3VuZCBmb3IgdGhlIGdpdmVuIE5JUC0wNSwgdW5kZWZpbmVkIG90aGVyd2lzZS5cbiAgICovXG4gIHN0YXRpYyBhc3luYyBmcm9tTmlwMDUobmlwMDVJZCwgbmRrLCBza2lwQ2FjaGUgPSBmYWxzZSkge1xuICAgIGlmICghbmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBOREsgaW5zdGFuY2UgZm91bmRcIik7XG4gICAgY29uc3Qgb3B0cyA9IHt9O1xuICAgIGlmIChza2lwQ2FjaGUpIG9wdHMuY2FjaGUgPSBcIm5vLWNhY2hlXCI7XG4gICAgY29uc3QgcHJvZmlsZSA9IGF3YWl0IGdldE5pcDA1Rm9yKG5kaywgbmlwMDVJZCwgbmRrPy5odHRwRmV0Y2gsIG9wdHMpO1xuICAgIGlmIChwcm9maWxlKSB7XG4gICAgICBjb25zdCB1c2VyID0gbmV3IF9OREtVc2VyKHtcbiAgICAgICAgcHVia2V5OiBwcm9maWxlLnB1YmtleSxcbiAgICAgICAgcmVsYXlVcmxzOiBwcm9maWxlLnJlbGF5cyxcbiAgICAgICAgbmlwNDZVcmxzOiBwcm9maWxlLm5pcDQ2XG4gICAgICB9KTtcbiAgICAgIHVzZXIubmRrID0gbmRrO1xuICAgICAgcmV0dXJuIHVzZXI7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBGZXRjaCBhIHVzZXIncyBwcm9maWxlXG4gICAqIEBwYXJhbSBvcHRzIHtOREtTdWJzY3JpcHRpb25PcHRpb25zfSBBIHNldCBvZiBOREtTdWJzY3JpcHRpb25PcHRpb25zXG4gICAqIEBwYXJhbSBzdG9yZVByb2ZpbGVFdmVudCB7Ym9vbGVhbn0gV2hldGhlciB0byBzdG9yZSB0aGUgcHJvZmlsZSBldmVudCBvciBub3RcbiAgICogQHJldHVybnMgVXNlciBQcm9maWxlXG4gICAqL1xuICBhc3luYyBmZXRjaFByb2ZpbGUob3B0cywgc3RvcmVQcm9maWxlRXZlbnQgPSBmYWxzZSkge1xuICAgIGlmICghdGhpcy5uZGspIHRocm93IG5ldyBFcnJvcihcIk5ESyBub3Qgc2V0XCIpO1xuICAgIGlmICghdGhpcy5wcm9maWxlKSB0aGlzLnByb2ZpbGUgPSB7fTtcbiAgICBsZXQgc2V0TWV0YWRhdGFFdmVudCA9IG51bGw7XG4gICAgaWYgKHRoaXMubmRrLmNhY2hlQWRhcHRlciAmJiB0aGlzLm5kay5jYWNoZUFkYXB0ZXIuZmV0Y2hQcm9maWxlICYmIG9wdHM/LmNhY2hlVXNhZ2UgIT09IFwiT05MWV9SRUxBWVwiIC8qIE9OTFlfUkVMQVkgKi8pIHtcbiAgICAgIGNvbnN0IHByb2ZpbGUgPSBhd2FpdCB0aGlzLm5kay5jYWNoZUFkYXB0ZXIuZmV0Y2hQcm9maWxlKHRoaXMucHVia2V5KTtcbiAgICAgIGlmIChwcm9maWxlKSB7XG4gICAgICAgIHRoaXMucHJvZmlsZSA9IHByb2ZpbGU7XG4gICAgICAgIHJldHVybiBwcm9maWxlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIW9wdHMgJiYgLy8gaWYgbm8gb3B0aW9ucyBoYXZlIGJlZW4gc2V0XG4gICAgdGhpcy5uZGsuY2FjaGVBZGFwdGVyICYmIC8vIGFuZCB3ZSBoYXZlIGEgY2FjaGVcbiAgICB0aGlzLm5kay5jYWNoZUFkYXB0ZXIubG9ja2luZykge1xuICAgICAgc2V0TWV0YWRhdGFFdmVudCA9IGF3YWl0IHRoaXMubmRrLmZldGNoRXZlbnQoXG4gICAgICAgIHtcbiAgICAgICAgICBraW5kczogWzBdLFxuICAgICAgICAgIGF1dGhvcnM6IFt0aGlzLnB1YmtleV1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGNhY2hlVXNhZ2U6IFwiT05MWV9DQUNIRVwiIC8qIE9OTFlfQ0FDSEUgKi8sXG4gICAgICAgICAgY2xvc2VPbkVvc2U6IHRydWUsXG4gICAgICAgICAgZ3JvdXBhYmxlOiBmYWxzZVxuICAgICAgICB9XG4gICAgICApO1xuICAgICAgb3B0cyA9IHtcbiAgICAgICAgY2FjaGVVc2FnZTogXCJPTkxZX1JFTEFZXCIgLyogT05MWV9SRUxBWSAqLyxcbiAgICAgICAgY2xvc2VPbkVvc2U6IHRydWUsXG4gICAgICAgIGdyb3VwYWJsZTogdHJ1ZSxcbiAgICAgICAgZ3JvdXBhYmxlRGVsYXk6IDI1MFxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKCFzZXRNZXRhZGF0YUV2ZW50KSB7XG4gICAgICBzZXRNZXRhZGF0YUV2ZW50ID0gYXdhaXQgdGhpcy5uZGsuZmV0Y2hFdmVudChcbiAgICAgICAge1xuICAgICAgICAgIGtpbmRzOiBbMF0sXG4gICAgICAgICAgYXV0aG9yczogW3RoaXMucHVia2V5XVxuICAgICAgICB9LFxuICAgICAgICBvcHRzXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIXNldE1ldGFkYXRhRXZlbnQpIHJldHVybiBudWxsO1xuICAgIHRoaXMucHJvZmlsZSA9IHByb2ZpbGVGcm9tRXZlbnQoc2V0TWV0YWRhdGFFdmVudCk7XG4gICAgaWYgKHN0b3JlUHJvZmlsZUV2ZW50KSB7XG4gICAgICB0aGlzLnByb2ZpbGUucHJvZmlsZUV2ZW50ID0gSlNPTi5zdHJpbmdpZnkoc2V0TWV0YWRhdGFFdmVudCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnByb2ZpbGUgJiYgdGhpcy5uZGsuY2FjaGVBZGFwdGVyICYmIHRoaXMubmRrLmNhY2hlQWRhcHRlci5zYXZlUHJvZmlsZSkge1xuICAgICAgdGhpcy5uZGsuY2FjaGVBZGFwdGVyLnNhdmVQcm9maWxlKHRoaXMucHVia2V5LCB0aGlzLnByb2ZpbGUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wcm9maWxlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc2V0IG9mIHVzZXJzIHRoYXQgdGhpcyB1c2VyIGZvbGxvd3MuXG4gICAqIFxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZm9sbG93U2V0IGluc3RlYWRcbiAgICovXG4gIGZvbGxvd3MgPSBmb2xsb3dzLmJpbmQodGhpcyk7XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc2V0IG9mIHB1YmtleXMgdGhhdCB0aGlzIHVzZXIgZm9sbG93cy5cbiAgICogXG4gICAqIEBwYXJhbSBvcHRzIC0gTkRLU3Vic2NyaXB0aW9uT3B0aW9uc1xuICAgKiBAcGFyYW0gb3V0Ym94IC0gYm9vbGVhblxuICAgKiBAcGFyYW0ga2luZCAtIG51bWJlclxuICAgKi9cbiAgYXN5bmMgZm9sbG93U2V0KG9wdHMsIG91dGJveCwga2luZCA9IDMgLyogQ29udGFjdHMgKi8pIHtcbiAgICBjb25zdCBmb2xsb3dzMiA9IGF3YWl0IHRoaXMuZm9sbG93cyhvcHRzLCBvdXRib3gsIGtpbmQpO1xuICAgIHJldHVybiBuZXcgU2V0KEFycmF5LmZyb20oZm9sbG93czIpLm1hcCgoZikgPT4gZi5wdWJrZXkpKTtcbiAgfVxuICAvKiogQGRlcHJlY2F0ZWQgVXNlIHJlZmVyZW5jZVRhZ3MgaW5zdGVhZC4gKi9cbiAgLyoqXG4gICAqIEdldCB0aGUgdGFnIHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVmZXJlbmNlIHRoaXMgdXNlciBpbiBhbiBldmVudFxuICAgKiBAcmV0dXJucyB7TkRLVGFnfSBhbiBOREtUYWdcbiAgICovXG4gIHRhZ1JlZmVyZW5jZSgpIHtcbiAgICByZXR1cm4gW1wicFwiLCB0aGlzLnB1YmtleV07XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgdGFncyB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlZmVyZW5jZSB0aGlzIHVzZXIgaW4gYW4gZXZlbnRcbiAgICogQHJldHVybnMge05ES1RhZ1tdfSBhbiBhcnJheSBvZiBOREtUYWdcbiAgICovXG4gIHJlZmVyZW5jZVRhZ3MobWFya2VyKSB7XG4gICAgY29uc3QgdGFnID0gW1tcInBcIiwgdGhpcy5wdWJrZXldXTtcbiAgICBpZiAoIW1hcmtlcikgcmV0dXJuIHRhZztcbiAgICB0YWdbMF0ucHVzaChcIlwiLCBtYXJrZXIpO1xuICAgIHJldHVybiB0YWc7XG4gIH1cbiAgLyoqXG4gICAqIFB1Ymxpc2hlcyB0aGUgY3VycmVudCBwcm9maWxlLlxuICAgKi9cbiAgYXN5bmMgcHVibGlzaCgpIHtcbiAgICBpZiAoIXRoaXMubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBOREsgaW5zdGFuY2UgZm91bmRcIik7XG4gICAgaWYgKCF0aGlzLnByb2ZpbGUpIHRocm93IG5ldyBFcnJvcihcIk5vIHByb2ZpbGUgYXZhaWxhYmxlXCIpO1xuICAgIHRoaXMubmRrLmFzc2VydFNpZ25lcigpO1xuICAgIGNvbnN0IGV2ZW50ID0gbmV3IE5ES0V2ZW50KHRoaXMubmRrLCB7XG4gICAgICBraW5kOiAwLFxuICAgICAgY29udGVudDogc2VyaWFsaXplUHJvZmlsZSh0aGlzLnByb2ZpbGUpXG4gICAgfSk7XG4gICAgYXdhaXQgZXZlbnQucHVibGlzaCgpO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgYSBmb2xsb3cgdG8gdGhpcyB1c2VyJ3MgY29udGFjdCBsaXN0XG4gICAqXG4gICAqIEBwYXJhbSBuZXdGb2xsb3cge05ES1VzZXJ9IFRoZSB1c2VyIHRvIGZvbGxvd1xuICAgKiBAcGFyYW0gY3VycmVudEZvbGxvd0xpc3Qge1NldDxOREtVc2VyPn0gVGhlIGN1cnJlbnQgZm9sbG93IGxpc3RcbiAgICogQHBhcmFtIGtpbmQge05ES0tpbmR9IFRoZSBraW5kIHRvIHVzZSBmb3IgdGhpcyBjb250YWN0IGxpc3QgKGRlZmF1bHRzIHRvIGAzYClcbiAgICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59IFRydWUgaWYgdGhlIGZvbGxvdyB3YXMgYWRkZWQsIGZhbHNlIGlmIHRoZSBmb2xsb3cgYWxyZWFkeSBleGlzdHNcbiAgICovXG4gIGFzeW5jIGZvbGxvdyhuZXdGb2xsb3csIGN1cnJlbnRGb2xsb3dMaXN0LCBraW5kID0gMyAvKiBDb250YWN0cyAqLykge1xuICAgIGlmICghdGhpcy5uZGspIHRocm93IG5ldyBFcnJvcihcIk5vIE5ESyBpbnN0YW5jZSBmb3VuZFwiKTtcbiAgICB0aGlzLm5kay5hc3NlcnRTaWduZXIoKTtcbiAgICBpZiAoIWN1cnJlbnRGb2xsb3dMaXN0KSB7XG4gICAgICBjdXJyZW50Rm9sbG93TGlzdCA9IGF3YWl0IHRoaXMuZm9sbG93cyh2b2lkIDAsIHZvaWQgMCwga2luZCk7XG4gICAgfVxuICAgIGlmIChjdXJyZW50Rm9sbG93TGlzdC5oYXMobmV3Rm9sbG93KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjdXJyZW50Rm9sbG93TGlzdC5hZGQobmV3Rm9sbG93KTtcbiAgICBjb25zdCBldmVudCA9IG5ldyBOREtFdmVudCh0aGlzLm5kaywgeyBraW5kIH0pO1xuICAgIGZvciAoY29uc3QgZm9sbG93IG9mIGN1cnJlbnRGb2xsb3dMaXN0KSB7XG4gICAgICBldmVudC50YWcoZm9sbG93KTtcbiAgICB9XG4gICAgYXdhaXQgZXZlbnQucHVibGlzaCgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgYSBmb2xsb3cgZnJvbSB0aGlzIHVzZXIncyBjb250YWN0IGxpc3RcbiAgICpcbiAgICogQHBhcmFtIHVzZXIge05ES1VzZXJ9IFRoZSB1c2VyIHRvIHVuZm9sbG93XG4gICAqIEBwYXJhbSBjdXJyZW50Rm9sbG93TGlzdCB7U2V0PE5ES1VzZXI+fSBUaGUgY3VycmVudCBmb2xsb3cgbGlzdFxuICAgKiBAcGFyYW0ga2luZCB7TkRLS2luZH0gVGhlIGtpbmQgdG8gdXNlIGZvciB0aGlzIGNvbnRhY3QgbGlzdCAoZGVmYXVsdHMgdG8gYDNgKVxuICAgKiBAcmV0dXJucyBUaGUgcmVsYXlzIHdlcmUgdGhlIGZvbGxvdyBsaXN0IHdhcyBwdWJsaXNoZWQgb3IgZmFsc2UgaWYgdGhlIHVzZXIgd2Fzbid0IGZvdW5kXG4gICAqL1xuICBhc3luYyB1bmZvbGxvdyh1c2VyLCBjdXJyZW50Rm9sbG93TGlzdCwga2luZCA9IDMgLyogQ29udGFjdHMgKi8pIHtcbiAgICBpZiAoIXRoaXMubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBOREsgaW5zdGFuY2UgZm91bmRcIik7XG4gICAgdGhpcy5uZGsuYXNzZXJ0U2lnbmVyKCk7XG4gICAgaWYgKCFjdXJyZW50Rm9sbG93TGlzdCkge1xuICAgICAgY3VycmVudEZvbGxvd0xpc3QgPSBhd2FpdCB0aGlzLmZvbGxvd3Modm9pZCAwLCB2b2lkIDAsIGtpbmQpO1xuICAgIH1cbiAgICBjb25zdCBuZXdVc2VyRm9sbG93TGlzdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgbGV0IGZvdW5kVXNlciA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgZm9sbG93IG9mIGN1cnJlbnRGb2xsb3dMaXN0KSB7XG4gICAgICBpZiAoZm9sbG93LnB1YmtleSAhPT0gdXNlci5wdWJrZXkpIHtcbiAgICAgICAgbmV3VXNlckZvbGxvd0xpc3QuYWRkKGZvbGxvdyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3VuZFVzZXIgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWZvdW5kVXNlcikgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGV2ZW50ID0gbmV3IE5ES0V2ZW50KHRoaXMubmRrLCB7IGtpbmQgfSk7XG4gICAgZm9yIChjb25zdCBmb2xsb3cgb2YgbmV3VXNlckZvbGxvd0xpc3QpIHtcbiAgICAgIGV2ZW50LnRhZyhmb2xsb3cpO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgZXZlbnQucHVibGlzaCgpO1xuICB9XG4gIC8qKlxuICAgKiBWYWxpZGF0ZSBhIHVzZXIncyBOSVAtMDUgaWRlbnRpZmllciAodXN1YWxseSBmZXRjaGVkIGZyb20gdGhlaXIga2luZDowIHByb2ZpbGUgZGF0YSlcbiAgICpcbiAgICogQHBhcmFtIG5pcDA1SWQgVGhlIE5JUC0wNSBzdHJpbmcgdG8gdmFsaWRhdGVcbiAgICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbiB8IG51bGw+fSBUcnVlIGlmIHRoZSBOSVAtMDUgaXMgZm91bmQgYW5kIG1hdGNoZXMgdGhpcyB1c2VyJ3MgcHVia2V5LFxuICAgKiBGYWxzZSBpZiB0aGUgTklQLTA1IGlzIGZvdW5kIGJ1dCBkb2Vzbid0IG1hdGNoIHRoaXMgdXNlcidzIHB1YmtleSxcbiAgICogbnVsbCBpZiB0aGUgTklQLTA1IGlzbid0IGZvdW5kIG9uIHRoZSBkb21haW4gb3Igd2UncmUgdW5hYmxlIHRvIHZlcmlmeSAoYmVjYXVzZSBvZiBuZXR3b3JrIGlzc3VlcywgZXRjLilcbiAgICovXG4gIGFzeW5jIHZhbGlkYXRlTmlwMDUobmlwMDVJZCkge1xuICAgIGlmICghdGhpcy5uZGspIHRocm93IG5ldyBFcnJvcihcIk5vIE5ESyBpbnN0YW5jZSBmb3VuZFwiKTtcbiAgICBjb25zdCBwcm9maWxlUG9pbnRlciA9IGF3YWl0IGdldE5pcDA1Rm9yKHRoaXMubmRrLCBuaXAwNUlkKTtcbiAgICBpZiAocHJvZmlsZVBvaW50ZXIgPT09IG51bGwpIHJldHVybiBudWxsO1xuICAgIHJldHVybiBwcm9maWxlUG9pbnRlci5wdWJrZXkgPT09IHRoaXMucHVia2V5O1xuICB9XG59O1xuXG4vLyBzcmMvdXNlci9waW4udHNcbmFzeW5jIGZ1bmN0aW9uIHBpbkV2ZW50KHVzZXIsIGV2ZW50LCBwaW5FdmVudDIsIHB1Ymxpc2gpIHtcbiAgY29uc3Qga2luZCA9IDEwMDAxIC8qIFBpbkxpc3QgKi87XG4gIGlmICghdXNlci5uZGspIHRocm93IG5ldyBFcnJvcihcIk5vIE5ESyBpbnN0YW5jZSBmb3VuZFwiKTtcbiAgdXNlci5uZGsuYXNzZXJ0U2lnbmVyKCk7XG4gIGlmICghcGluRXZlbnQyKSB7XG4gICAgY29uc3QgZXZlbnRzID0gYXdhaXQgdXNlci5uZGsuZmV0Y2hFdmVudHMoXG4gICAgICB7IGtpbmRzOiBba2luZF0sIGF1dGhvcnM6IFt1c2VyLnB1YmtleV0gfSxcbiAgICAgIHsgY2FjaGVVc2FnZTogXCJPTkxZX1JFTEFZXCIgLyogT05MWV9SRUxBWSAqLyB9XG4gICAgKTtcbiAgICBpZiAoZXZlbnRzLnNpemUgPiAwKSB7XG4gICAgICBwaW5FdmVudDIgPSBsaXN0c19kZWZhdWx0LmZyb20oQXJyYXkuZnJvbShldmVudHMpWzBdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGluRXZlbnQyID0gbmV3IE5ES0V2ZW50KHVzZXIubmRrLCB7XG4gICAgICAgIGtpbmRcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBwaW5FdmVudDIudGFnKGV2ZW50KTtcbiAgaWYgKHB1Ymxpc2gpIHtcbiAgICBhd2FpdCBwaW5FdmVudDIucHVibGlzaCgpO1xuICB9XG4gIHJldHVybiBwaW5FdmVudDI7XG59XG5cbi8vIHNyYy9ldmVudHMva2luZHMvY2xhc3NpZmllZC50c1xudmFyIE5ES0NsYXNzaWZpZWQgPSBjbGFzcyBfTkRLQ2xhc3NpZmllZCBleHRlbmRzIE5ES0V2ZW50IHtcbiAgY29uc3RydWN0b3IobmRrLCByYXdFdmVudCkge1xuICAgIHN1cGVyKG5kaywgcmF3RXZlbnQpO1xuICAgIHRoaXMua2luZCA/Pz0gMzA0MDIgLyogQ2xhc3NpZmllZCAqLztcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIE5ES0NsYXNzaWZpZWQgZnJvbSBhbiBleGlzdGluZyBOREtFdmVudC5cbiAgICpcbiAgICogQHBhcmFtIGV2ZW50IE5ES0V2ZW50IHRvIGNyZWF0ZSB0aGUgTkRLQ2xhc3NpZmllZCBmcm9tLlxuICAgKiBAcmV0dXJucyBOREtDbGFzc2lmaWVkXG4gICAqL1xuICBzdGF0aWMgZnJvbShldmVudCkge1xuICAgIHJldHVybiBuZXcgX05ES0NsYXNzaWZpZWQoZXZlbnQubmRrLCBldmVudCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHRlciBmb3IgdGhlIGNsYXNzaWZpZWQgdGl0bGUuXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmcgfCB1bmRlZmluZWR9IC0gVGhlIGNsYXNzaWZpZWQgdGl0bGUgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgdW5kZWZpbmVkLlxuICAgKi9cbiAgZ2V0IHRpdGxlKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwidGl0bGVcIik7XG4gIH1cbiAgLyoqXG4gICAqIFNldHRlciBmb3IgdGhlIGNsYXNzaWZpZWQgdGl0bGUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSB0aXRsZSAtIFRoZSB0aXRsZSB0byBzZXQgZm9yIHRoZSBjbGFzc2lmaWVkLlxuICAgKi9cbiAgc2V0IHRpdGxlKHRpdGxlKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJ0aXRsZVwiKTtcbiAgICBpZiAodGl0bGUpIHRoaXMudGFncy5wdXNoKFtcInRpdGxlXCIsIHRpdGxlXSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHRlciBmb3IgdGhlIGNsYXNzaWZpZWQgc3VtbWFyeS5cbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZyB8IHVuZGVmaW5lZH0gLSBUaGUgY2xhc3NpZmllZCBzdW1tYXJ5IGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIHVuZGVmaW5lZC5cbiAgICovXG4gIGdldCBzdW1tYXJ5KCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwic3VtbWFyeVwiKTtcbiAgfVxuICAvKipcbiAgICogU2V0dGVyIGZvciB0aGUgY2xhc3NpZmllZCBzdW1tYXJ5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gc3VtbWFyeSAtIFRoZSBzdW1tYXJ5IHRvIHNldCBmb3IgdGhlIGNsYXNzaWZpZWQuXG4gICAqL1xuICBzZXQgc3VtbWFyeShzdW1tYXJ5KSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJzdW1tYXJ5XCIpO1xuICAgIGlmIChzdW1tYXJ5KSB0aGlzLnRhZ3MucHVzaChbXCJzdW1tYXJ5XCIsIHN1bW1hcnldKTtcbiAgfVxuICAvKipcbiAgICogR2V0dGVyIGZvciB0aGUgY2xhc3NpZmllZCdzIHB1YmxpY2F0aW9uIHRpbWVzdGFtcC5cbiAgICpcbiAgICogQHJldHVybnMge251bWJlciB8IHVuZGVmaW5lZH0gLSBUaGUgVW5peCB0aW1lc3RhbXAgb2Ygd2hlbiB0aGUgY2xhc3NpZmllZCB3YXMgcHVibGlzaGVkIG9yIHVuZGVmaW5lZC5cbiAgICovXG4gIGdldCBwdWJsaXNoZWRfYXQoKSB7XG4gICAgY29uc3QgdGFnID0gdGhpcy50YWdWYWx1ZShcInB1Ymxpc2hlZF9hdFwiKTtcbiAgICBpZiAodGFnKSB7XG4gICAgICByZXR1cm4gcGFyc2VJbnQodGFnKTtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICAvKipcbiAgICogU2V0dGVyIGZvciB0aGUgY2xhc3NpZmllZCdzIHB1YmxpY2F0aW9uIHRpbWVzdGFtcC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXIgfCB1bmRlZmluZWR9IHRpbWVzdGFtcCAtIFRoZSBVbml4IHRpbWVzdGFtcCB0byBzZXQgZm9yIHRoZSBjbGFzc2lmaWVkJ3MgcHVibGljYXRpb24gZGF0ZS5cbiAgICovXG4gIHNldCBwdWJsaXNoZWRfYXQodGltZXN0YW1wKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJwdWJsaXNoZWRfYXRcIik7XG4gICAgaWYgKHRpbWVzdGFtcCAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJwdWJsaXNoZWRfYXRcIiwgdGltZXN0YW1wLnRvU3RyaW5nKCldKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEdldHRlciBmb3IgdGhlIGNsYXNzaWZpZWQgbG9jYXRpb24uXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmcgfCB1bmRlZmluZWR9IC0gVGhlIGNsYXNzaWZpZWQgbG9jYXRpb24gaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgdW5kZWZpbmVkLlxuICAgKi9cbiAgZ2V0IGxvY2F0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwibG9jYXRpb25cIik7XG4gIH1cbiAgLyoqXG4gICAqIFNldHRlciBmb3IgdGhlIGNsYXNzaWZpZWQgbG9jYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBsb2NhdGlvbiAtIFRoZSBsb2NhdGlvbiB0byBzZXQgZm9yIHRoZSBjbGFzc2lmaWVkLlxuICAgKi9cbiAgc2V0IGxvY2F0aW9uKGxvY2F0aW9uKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJsb2NhdGlvblwiKTtcbiAgICBpZiAobG9jYXRpb24pIHRoaXMudGFncy5wdXNoKFtcImxvY2F0aW9uXCIsIGxvY2F0aW9uXSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHRlciBmb3IgdGhlIGNsYXNzaWZpZWQgcHJpY2UuXG4gICAqXG4gICAqIEByZXR1cm5zIHtOREtDbGFzc2lmaWVkUHJpY2VUYWcgfCB1bmRlZmluZWR9IC0gVGhlIGNsYXNzaWZpZWQgcHJpY2UgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgdW5kZWZpbmVkLlxuICAgKi9cbiAgZ2V0IHByaWNlKCkge1xuICAgIGNvbnN0IHByaWNlVGFnID0gdGhpcy50YWdzLmZpbmQoKHRhZykgPT4gdGFnWzBdID09PSBcInByaWNlXCIpO1xuICAgIGlmIChwcmljZVRhZykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYW1vdW50OiBwYXJzZUZsb2F0KHByaWNlVGFnWzFdKSxcbiAgICAgICAgY3VycmVuY3k6IHByaWNlVGFnWzJdLFxuICAgICAgICBmcmVxdWVuY3k6IHByaWNlVGFnWzNdXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU2V0dGVyIGZvciB0aGUgY2xhc3NpZmllZCBwcmljZS5cbiAgICpcbiAgICogQHBhcmFtIHByaWNlIC0gVGhlIHByaWNlIHRvIHNldCBmb3IgdGhlIGNsYXNzaWZpZWQuXG4gICAqL1xuICBzZXQgcHJpY2UocHJpY2VUYWcpIHtcbiAgICBpZiAodHlwZW9mIHByaWNlVGFnID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBwcmljZVRhZyA9IHtcbiAgICAgICAgYW1vdW50OiBwYXJzZUZsb2F0KHByaWNlVGFnKVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHByaWNlVGFnPy5hbW91bnQpIHtcbiAgICAgIGNvbnN0IHRhZyA9IFtcInByaWNlXCIsIHByaWNlVGFnLmFtb3VudC50b1N0cmluZygpXTtcbiAgICAgIGlmIChwcmljZVRhZy5jdXJyZW5jeSkgdGFnLnB1c2gocHJpY2VUYWcuY3VycmVuY3kpO1xuICAgICAgaWYgKHByaWNlVGFnLmZyZXF1ZW5jeSkgdGFnLnB1c2gocHJpY2VUYWcuZnJlcXVlbmN5KTtcbiAgICAgIHRoaXMudGFncy5wdXNoKHRhZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlVGFnKFwicHJpY2VcIik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgY29udGVudCB0YWdzIGZvciB0aGUgY2xhc3NpZmllZC5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgZmlyc3QgY2hlY2tzIGFuZCBzZXRzIHRoZSBwdWJsaWNhdGlvbiBkYXRlIGlmIG5vdCBhdmFpbGFibGUsXG4gICAqIGFuZCB0aGVuIGdlbmVyYXRlcyBjb250ZW50IHRhZ3MgYmFzZWQgb24gdGhlIGJhc2UgTkRLRXZlbnQgY2xhc3MuXG4gICAqXG4gICAqIEByZXR1cm5zIHtDb250ZW50VGFnfSAtIFRoZSBnZW5lcmF0ZWQgY29udGVudCB0YWdzLlxuICAgKi9cbiAgYXN5bmMgZ2VuZXJhdGVUYWdzKCkge1xuICAgIHN1cGVyLmdlbmVyYXRlVGFncygpO1xuICAgIGlmICghdGhpcy5wdWJsaXNoZWRfYXQpIHtcbiAgICAgIHRoaXMucHVibGlzaGVkX2F0ID0gdGhpcy5jcmVhdGVkX2F0O1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuZ2VuZXJhdGVUYWdzKCk7XG4gIH1cbn07XG5cbi8vIHNyYy9ldmVudHMva2luZHMvZHJhZnRzLnRzXG52YXIgTkRLRHJhZnQgPSBjbGFzcyBfTkRLRHJhZnQgZXh0ZW5kcyBOREtFdmVudCB7XG4gIF9ldmVudDtcbiAgY29uc3RydWN0b3IobmRrLCByYXdFdmVudCkge1xuICAgIHN1cGVyKG5kaywgcmF3RXZlbnQpO1xuICAgIHRoaXMua2luZCA/Pz0gMzEyMzQgLyogRHJhZnQgKi87XG4gIH1cbiAgc3RhdGljIGZyb20oZXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtEcmFmdChldmVudC5uZGssIGV2ZW50KTtcbiAgfVxuICAvKipcbiAgICogU2V0cyBhbiBpZGVudGlmaWVyIChpLmUuIGQtdGFnKVxuICAgKi9cbiAgc2V0IGlkZW50aWZpZXIoaWQpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImRcIik7XG4gICAgdGhpcy50YWdzLnB1c2goW1wiZFwiLCBpZF0pO1xuICB9XG4gIGdldCBpZGVudGlmaWVyKCkge1xuICAgIHJldHVybiB0aGlzLmRUYWc7XG4gIH1cbiAgLyoqXG4gICAqIEV2ZW50IHRoYXQgaXMgdG8gYmUgc2F2ZWQuXG4gICAqL1xuICBzZXQgZXZlbnQoZSkge1xuICAgIGlmIChlIGluc3RhbmNlb2YgTkRLRXZlbnQpIHRoaXMuX2V2ZW50ID0gZS5yYXdFdmVudCgpO1xuICAgIGVsc2UgdGhpcy5fZXZlbnQgPSBlO1xuICAgIHRoaXMucHJlcGFyZUV2ZW50KCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIGV2ZW50LlxuICAgKiBAcGFyYW0gcGFyYW0wXG4gICAqIEByZXR1cm5zIE5ES0V2ZW50IG9mIHRoZSBkcmFmdCBldmVudCBvciBudWxsIGlmIHRoZSBkcmFmdCBldmVudCBoYXMgYmVlbiBkZWxldGVkIChlbXB0aWVkKS5cbiAgICovXG4gIGFzeW5jIGdldEV2ZW50KHNpZ25lcikge1xuICAgIGlmICh0aGlzLl9ldmVudCkgcmV0dXJuIG5ldyBOREtFdmVudCh0aGlzLm5kaywgdGhpcy5fZXZlbnQpO1xuICAgIHNpZ25lciA/Pz0gdGhpcy5uZGs/LnNpZ25lcjtcbiAgICBpZiAoIXNpZ25lcikgdGhyb3cgbmV3IEVycm9yKFwiTm8gc2lnbmVyIGF2YWlsYWJsZVwiKTtcbiAgICBjb25zdCB1c2VyID0gYXdhaXQgc2lnbmVyLnVzZXIoKTtcbiAgICBpZiAodGhpcy5jb250ZW50ICYmIHRoaXMuY29udGVudC5sZW5ndGggPiAwKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLmRlY3J5cHQodXNlciwgc2lnbmVyKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IEpTT04ucGFyc2UodGhpcy5jb250ZW50KTtcbiAgICAgICAgdGhpcy5fZXZlbnQgPSBwYXlsb2FkO1xuICAgICAgICByZXR1cm4gbmV3IE5ES0V2ZW50KHRoaXMubmRrLCBwYXlsb2FkKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIHByZXBhcmVFdmVudCgpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50KSB0aHJvdyBuZXcgRXJyb3IoXCJObyBldmVudCBoYXMgYmVlbiBwcm92aWRlZFwiKTtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImtcIik7XG4gICAgaWYgKHRoaXMuX2V2ZW50LmtpbmQpIHRoaXMudGFncy5wdXNoKFtcImtcIiwgdGhpcy5fZXZlbnQua2luZC50b1N0cmluZygpXSk7XG4gICAgdGhpcy5jb250ZW50ID0gSlNPTi5zdHJpbmdpZnkodGhpcy5fZXZlbnQpO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgZHJhZnQgZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSBzaWduZXI6IE9wdGlvbmFsIHNpZ25lciB0byBlbmNyeXB0IHdpdGhcbiAgICogQHBhcmFtIHB1Ymxpc2g6IFdoZXRoZXIgdG8gcHVibGlzaCwgb3B0aW9uYWxseSBzcGVjaWZ5aW5nIHJlbGF5U2V0IHRvIHB1Ymxpc2ggdG9cbiAgICovXG4gIGFzeW5jIHNhdmUoe1xuICAgIHNpZ25lcixcbiAgICBwdWJsaXNoLFxuICAgIHJlbGF5U2V0XG4gIH0pIHtcbiAgICBzaWduZXIgPz89IHRoaXMubmRrPy5zaWduZXI7XG4gICAgaWYgKCFzaWduZXIpIHRocm93IG5ldyBFcnJvcihcIk5vIHNpZ25lciBhdmFpbGFibGVcIik7XG4gICAgY29uc3QgdXNlciA9IGF3YWl0IHNpZ25lci51c2VyKCk7XG4gICAgYXdhaXQgdGhpcy5lbmNyeXB0KHVzZXIsIHNpZ25lcik7XG4gICAgaWYgKHB1Ymxpc2ggPT09IGZhbHNlKSByZXR1cm47XG4gICAgcmV0dXJuIHRoaXMucHVibGlzaChyZWxheVNldCk7XG4gIH1cbn07XG5cbi8vIHNyYy9ldmVudHMva2luZHMvZHZtL2ZlZWRiYWNrLnRzXG52YXIgTkRLRHZtSm9iRmVlZGJhY2tTdGF0dXMgPSAvKiBAX19QVVJFX18gKi8gKChOREtEdm1Kb2JGZWVkYmFja1N0YXR1czIpID0+IHtcbiAgTkRLRHZtSm9iRmVlZGJhY2tTdGF0dXMyW1wiUHJvY2Vzc2luZ1wiXSA9IFwicHJvY2Vzc2luZ1wiO1xuICBOREtEdm1Kb2JGZWVkYmFja1N0YXR1czJbXCJTdWNjZXNzXCJdID0gXCJzdWNjZXNzXCI7XG4gIE5ES0R2bUpvYkZlZWRiYWNrU3RhdHVzMltcIlNjaGVkdWxlZFwiXSA9IFwic2NoZWR1bGVkXCI7XG4gIE5ES0R2bUpvYkZlZWRiYWNrU3RhdHVzMltcIlBheVJlcVwiXSA9IFwicGF5bWVudF9yZXF1aXJlZFwiO1xuICByZXR1cm4gTkRLRHZtSm9iRmVlZGJhY2tTdGF0dXMyO1xufSkoTkRLRHZtSm9iRmVlZGJhY2tTdGF0dXMgfHwge30pO1xudmFyIE5ES0RWTUpvYkZlZWRiYWNrID0gY2xhc3MgX05ES0RWTUpvYkZlZWRiYWNrIGV4dGVuZHMgTkRLRXZlbnQge1xuICBjb25zdHJ1Y3RvcihuZGssIGV2ZW50KSB7XG4gICAgc3VwZXIobmRrLCBldmVudCk7XG4gICAgdGhpcy5raW5kID8/PSA3ZTMgLyogRFZNSm9iRmVlZGJhY2sgKi87XG4gIH1cbiAgc3RhdGljIGFzeW5jIGZyb20oZXZlbnQpIHtcbiAgICBjb25zdCBlID0gbmV3IF9OREtEVk1Kb2JGZWVkYmFjayhldmVudC5uZGssIGV2ZW50LnJhd0V2ZW50KCkpO1xuICAgIGlmIChlLmVuY3J5cHRlZCkgYXdhaXQgZS5kdm1EZWNyeXB0KCk7XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgZ2V0IHN0YXR1cygpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcInN0YXR1c1wiKTtcbiAgfVxuICBzZXQgc3RhdHVzKHN0YXR1cykge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwic3RhdHVzXCIpO1xuICAgIGlmIChzdGF0dXMgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wic3RhdHVzXCIsIHN0YXR1c10pO1xuICAgIH1cbiAgfVxuICBnZXQgZW5jcnlwdGVkKCkge1xuICAgIHJldHVybiAhIXRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwiZW5jcnlwdGVkXCIpWzBdO1xuICB9XG4gIGFzeW5jIGR2bURlY3J5cHQoKSB7XG4gICAgYXdhaXQgdGhpcy5kZWNyeXB0KCk7XG4gICAgY29uc3QgZGVjcnlwdGVkQ29udGVudCA9IEpTT04ucGFyc2UodGhpcy5jb250ZW50KTtcbiAgICB0aGlzLnRhZ3MucHVzaCguLi5kZWNyeXB0ZWRDb250ZW50KTtcbiAgfVxufTtcblxuLy8gc3JjL2V2ZW50cy9raW5kcy9kdm0vcmVxdWVzdC50c1xudmFyIE5ES0RWTVJlcXVlc3QgPSBjbGFzcyBfTkRLRFZNUmVxdWVzdCBleHRlbmRzIE5ES0V2ZW50IHtcbiAgY29uc3RydWN0b3IobmRrLCBldmVudCkge1xuICAgIHN1cGVyKG5kaywgZXZlbnQpO1xuICB9XG4gIHN0YXRpYyBmcm9tKGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLRFZNUmVxdWVzdChldmVudC5uZGssIGV2ZW50LnJhd0V2ZW50KCkpO1xuICB9XG4gIHNldCBiaWQobXNhdEFtb3VudCkge1xuICAgIGlmIChtc2F0QW1vdW50ID09PSB2b2lkIDApIHtcbiAgICAgIHRoaXMucmVtb3ZlVGFnKFwiYmlkXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJiaWRcIiwgbXNhdEFtb3VudC50b1N0cmluZygpXSk7XG4gICAgfVxuICB9XG4gIGdldCBiaWQoKSB7XG4gICAgY29uc3QgdiA9IHRoaXMudGFnVmFsdWUoXCJiaWRcIik7XG4gICAgaWYgKHYgPT09IHZvaWQgMCkgcmV0dXJuIHZvaWQgMDtcbiAgICByZXR1cm4gcGFyc2VJbnQodik7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYSBuZXcgaW5wdXQgdG8gdGhlIGpvYlxuICAgKiBAcGFyYW0gYXJncyBUaGUgYXJndW1lbnRzIHRvIHRoZSBpbnB1dFxuICAgKi9cbiAgYWRkSW5wdXQoLi4uYXJncykge1xuICAgIHRoaXMudGFncy5wdXNoKFtcImlcIiwgLi4uYXJnc10pO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGEgbmV3IHBhcmFtZXRlciB0byB0aGUgam9iXG4gICAqL1xuICBhZGRQYXJhbSguLi5hcmdzKSB7XG4gICAgdGhpcy50YWdzLnB1c2goW1wicGFyYW1cIiwgLi4uYXJnc10pO1xuICB9XG4gIHNldCBvdXRwdXQob3V0cHV0KSB7XG4gICAgaWYgKG91dHB1dCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnJlbW92ZVRhZyhcIm91dHB1dFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiBvdXRwdXQgPT09IFwic3RyaW5nXCIpIG91dHB1dCA9IFtvdXRwdXRdO1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wib3V0cHV0XCIsIC4uLm91dHB1dF0pO1xuICAgIH1cbiAgfVxuICBnZXQgb3V0cHV0KCkge1xuICAgIGNvbnN0IG91dHB1dFRhZyA9IHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwib3V0cHV0XCIpWzBdO1xuICAgIHJldHVybiBvdXRwdXRUYWcgPyBvdXRwdXRUYWcuc2xpY2UoMSkgOiB2b2lkIDA7XG4gIH1cbiAgZ2V0IHBhcmFtcygpIHtcbiAgICBjb25zdCBwYXJhbVRhZ3MgPSB0aGlzLmdldE1hdGNoaW5nVGFncyhcInBhcmFtXCIpO1xuICAgIHJldHVybiBwYXJhbVRhZ3MubWFwKCh0KSA9PiB0LnNsaWNlKDEpKTtcbiAgfVxuICBnZXRQYXJhbShuYW1lKSB7XG4gICAgY29uc3QgcGFyYW1UYWcgPSB0aGlzLmdldE1hdGNoaW5nVGFncyhcInBhcmFtXCIpLmZpbmQoKHQpID0+IHRbMV0gPT09IG5hbWUpO1xuICAgIHJldHVybiBwYXJhbVRhZyA/IHBhcmFtVGFnWzJdIDogdm9pZCAwO1xuICB9XG4gIGNyZWF0ZUZlZWRiYWNrKHN0YXR1cykge1xuICAgIGNvbnN0IGZlZWRiYWNrID0gbmV3IE5ES0RWTUpvYkZlZWRiYWNrKHRoaXMubmRrKTtcbiAgICBmZWVkYmFjay50YWcodGhpcywgXCJqb2JcIik7XG4gICAgZmVlZGJhY2suc3RhdHVzID0gc3RhdHVzO1xuICAgIHJldHVybiBmZWVkYmFjaztcbiAgfVxuICAvKipcbiAgICogRW5hYmxlcyBqb2IgZW5jcnlwdGlvbiBmb3IgdGhpcyBldmVudFxuICAgKiBAcGFyYW0gZHZtIERWTSB0aGF0IHdpbGwgcmVjZWl2ZSB0aGUgZXZlbnRcbiAgICogQHBhcmFtIHNpZ25lciBTaWduZXIgdG8gdXNlIGZvciBlbmNyeXB0aW9uXG4gICAqL1xuICBhc3luYyBlbmNyeXB0aW9uKGR2bSwgc2lnbmVyKSB7XG4gICAgY29uc3QgZHZtVGFncyA9IFtcImlcIiwgXCJwYXJhbVwiLCBcIm91dHB1dFwiLCBcInJlbGF5c1wiLCBcImJpZFwiXTtcbiAgICBjb25zdCB0YWdzID0gdGhpcy50YWdzLmZpbHRlcigodCkgPT4gZHZtVGFncy5pbmNsdWRlcyh0WzBdKSk7XG4gICAgdGhpcy50YWdzID0gdGhpcy50YWdzLmZpbHRlcigodCkgPT4gIWR2bVRhZ3MuaW5jbHVkZXModFswXSkpO1xuICAgIHRoaXMuY29udGVudCA9IEpTT04uc3RyaW5naWZ5KHRhZ3MpO1xuICAgIHRoaXMudGFnKGR2bSk7XG4gICAgdGhpcy50YWdzLnB1c2goW1wiZW5jcnlwdGVkXCJdKTtcbiAgICBhd2FpdCB0aGlzLmVuY3J5cHQoZHZtLCBzaWduZXIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBEVk0gdGhhdCB3aWxsIHJlY2VpdmUgdGhlIGV2ZW50XG4gICAqL1xuICBzZXQgZHZtKGR2bSkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwicFwiKTtcbiAgICBpZiAoZHZtKSB0aGlzLnRhZyhkdm0pO1xuICB9XG59O1xuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL2R2bS9OREtUcmFuc2NyaXB0aW9uRFZNLnRzXG52YXIgTkRLVHJhbnNjcmlwdGlvbkRWTSA9IGNsYXNzIF9OREtUcmFuc2NyaXB0aW9uRFZNIGV4dGVuZHMgTkRLRFZNUmVxdWVzdCB7XG4gIGNvbnN0cnVjdG9yKG5kaywgZXZlbnQpIHtcbiAgICBzdXBlcihuZGssIGV2ZW50KTtcbiAgICB0aGlzLmtpbmQgPSA1ZTMgLyogRFZNUmVxVGV4dEV4dHJhY3Rpb24gKi87XG4gIH1cbiAgc3RhdGljIGZyb20oZXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtUcmFuc2NyaXB0aW9uRFZNKGV2ZW50Lm5kaywgZXZlbnQucmF3RXZlbnQoKSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSBvZiB0aGUgdHJhbnNjcmlwdGlvblxuICAgKi9cbiAgZ2V0IHVybCgpIHtcbiAgICBjb25zdCBpbnB1dFRhZ3MgPSB0aGlzLmdldE1hdGNoaW5nVGFncyhcImlcIik7XG4gICAgaWYgKGlucHV0VGFncy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBpbnB1dFRhZ3NbMF1bMV07XG4gIH1cbiAgLyoqXG4gICAqIEdldHRlciBmb3IgdGhlIHRpdGxlIHRhZ1xuICAgKi9cbiAgZ2V0IHRpdGxlKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwidGl0bGVcIik7XG4gIH1cbiAgLyoqXG4gICAqIFNldHRlciBmb3IgdGhlIHRpdGxlIHRhZ1xuICAgKi9cbiAgc2V0IHRpdGxlKHZhbHVlKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJ0aXRsZVwiKTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcInRpdGxlXCIsIHZhbHVlXSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBHZXR0ZXIgZm9yIHRoZSBpbWFnZSB0YWdcbiAgICovXG4gIGdldCBpbWFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcImltYWdlXCIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXR0ZXIgZm9yIHRoZSBpbWFnZSB0YWdcbiAgICovXG4gIHNldCBpbWFnZSh2YWx1ZSkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwiaW1hZ2VcIik7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJpbWFnZVwiLCB2YWx1ZV0pO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2V2ZW50cy9raW5kcy9kdm0vcmVzdWx0LnRzXG52YXIgTkRLRFZNSm9iUmVzdWx0ID0gY2xhc3MgX05ES0RWTUpvYlJlc3VsdCBleHRlbmRzIE5ES0V2ZW50IHtcbiAgY29uc3RydWN0b3IobmRrLCBldmVudCkge1xuICAgIHN1cGVyKG5kaywgZXZlbnQpO1xuICB9XG4gIHN0YXRpYyBmcm9tKGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLRFZNSm9iUmVzdWx0KGV2ZW50Lm5kaywgZXZlbnQucmF3RXZlbnQoKSk7XG4gIH1cbiAgc2V0QW1vdW50KG1zYXQsIGludm9pY2UpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImFtb3VudFwiKTtcbiAgICBjb25zdCB0YWcgPSBbXCJhbW91bnRcIiwgbXNhdC50b1N0cmluZygpXTtcbiAgICBpZiAoaW52b2ljZSkgdGFnLnB1c2goaW52b2ljZSk7XG4gICAgdGhpcy50YWdzLnB1c2godGFnKTtcbiAgfVxuICBzZXQgcmVzdWx0KHJlc3VsdCkge1xuICAgIGlmIChyZXN1bHQgPT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5jb250ZW50ID0gXCJcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb250ZW50ID0gcmVzdWx0O1xuICAgIH1cbiAgfVxuICBnZXQgcmVzdWx0KCkge1xuICAgIGlmICh0aGlzLmNvbnRlbnQgPT09IFwiXCIpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRlbnQ7XG4gIH1cbiAgc2V0IHN0YXR1cyhzdGF0dXMpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInN0YXR1c1wiKTtcbiAgICBpZiAoc3RhdHVzICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcInN0YXR1c1wiLCBzdGF0dXNdKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHN0YXR1cygpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcInN0YXR1c1wiKTtcbiAgfVxuICBnZXQgam9iUmVxdWVzdElkKCkge1xuICAgIGZvciAoY29uc3QgZVRhZyBvZiB0aGlzLmdldE1hdGNoaW5nVGFncyhcImVcIikpIHtcbiAgICAgIGlmIChlVGFnWzJdID09PSBcImpvYlwiKSByZXR1cm4gZVRhZ1sxXTtcbiAgICB9XG4gICAgaWYgKHRoaXMuam9iUmVxdWVzdCkgcmV0dXJuIHRoaXMuam9iUmVxdWVzdC5pZDtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcImVcIik7XG4gIH1cbiAgc2V0IGpvYlJlcXVlc3QoZXZlbnQpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInJlcXVlc3RcIik7XG4gICAgaWYgKGV2ZW50KSB7XG4gICAgICB0aGlzLmtpbmQgPSBldmVudC5raW5kICsgMWUzO1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wicmVxdWVzdFwiLCBKU09OLnN0cmluZ2lmeShldmVudC5yYXdFdmVudCgpKV0pO1xuICAgICAgdGhpcy50YWcoZXZlbnQpO1xuICAgIH1cbiAgfVxuICBnZXQgam9iUmVxdWVzdCgpIHtcbiAgICBjb25zdCB0YWcgPSB0aGlzLnRhZ1ZhbHVlKFwicmVxdWVzdFwiKTtcbiAgICBpZiAodGFnID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTkRLRXZlbnQodGhpcy5uZGssIEpTT04ucGFyc2UodGFnKSk7XG4gIH1cbn07XG5cbi8vIHNyYy9ldmVudHMva2luZHMvY2FzaHUvdHgudHNcbnZhciBNQVJLRVJTID0ge1xuICBSRURFRU1FRDogXCJyZWRlZW1lZFwiLFxuICBDUkVBVEVEOiBcImNyZWF0ZWRcIixcbiAgREVTVFJPWUVEOiBcImRlc3Ryb3llZFwiLFxuICBSRVNFUlZFRDogXCJyZXNlcnZlZFwiXG59O1xudmFyIE5ES0Nhc2h1V2FsbGV0VHggPSBjbGFzcyBfTkRLQ2FzaHVXYWxsZXRUeCBleHRlbmRzIE5ES0V2ZW50IHtcbiAgc3RhdGljIE1BUktFUlMgPSBNQVJLRVJTO1xuICBzdGF0aWMga2luZCA9IDczNzYgLyogQ2FzaHVXYWxsZXRUeCAqLztcbiAgc3RhdGljIGtpbmRzID0gWzczNzYgLyogQ2FzaHVXYWxsZXRUeCAqL107XG4gIGNvbnN0cnVjdG9yKG5kaywgZXZlbnQpIHtcbiAgICBzdXBlcihuZGssIGV2ZW50KTtcbiAgICB0aGlzLmtpbmQgPz89IDczNzYgLyogQ2FzaHVXYWxsZXRUeCAqLztcbiAgfVxuICBzdGF0aWMgYXN5bmMgZnJvbShldmVudCkge1xuICAgIGNvbnN0IHdhbGxldENoYW5nZSA9IG5ldyBfTkRLQ2FzaHVXYWxsZXRUeChldmVudC5uZGssIGV2ZW50KTtcbiAgICBjb25zdCBwcmV2Q29udGVudCA9IHdhbGxldENoYW5nZS5jb250ZW50O1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB3YWxsZXRDaGFuZ2UuZGVjcnlwdCgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHdhbGxldENoYW5nZS5jb250ZW50ID8/PSBwcmV2Q29udGVudDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNvbnRlbnRUYWdzID0gSlNPTi5wYXJzZSh3YWxsZXRDaGFuZ2UuY29udGVudCk7XG4gICAgICB3YWxsZXRDaGFuZ2UudGFncyA9IFsuLi5jb250ZW50VGFncywgLi4ud2FsbGV0Q2hhbmdlLnRhZ3NdO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHdhbGxldENoYW5nZTtcbiAgfVxuICBzZXQgZGlyZWN0aW9uKGRpcmVjdGlvbikge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwiZGlyZWN0aW9uXCIpO1xuICAgIGlmIChkaXJlY3Rpb24pIHRoaXMudGFncy5wdXNoKFtcImRpcmVjdGlvblwiLCBkaXJlY3Rpb25dKTtcbiAgfVxuICBnZXQgZGlyZWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwiZGlyZWN0aW9uXCIpO1xuICB9XG4gIHNldCBhbW91bnQoYW1vdW50KSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJhbW91bnRcIik7XG4gICAgdGhpcy50YWdzLnB1c2goW1wiYW1vdW50XCIsIGFtb3VudC50b1N0cmluZygpXSk7XG4gIH1cbiAgZ2V0IGFtb3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcImFtb3VudFwiKTtcbiAgfVxuICBzZXQgZmVlKGZlZSkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwiZmVlXCIpO1xuICAgIHRoaXMudGFncy5wdXNoKFtcImZlZVwiLCBmZWUudG9TdHJpbmcoKV0pO1xuICB9XG4gIGdldCBmZWUoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJmZWVcIik7XG4gIH1cbiAgc2V0IHVuaXQodW5pdCkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwidW5pdFwiKTtcbiAgICBpZiAodW5pdCkgdGhpcy50YWdzLnB1c2goW1widW5pdFwiLCB1bml0LnRvU3RyaW5nKCldKTtcbiAgfVxuICBnZXQgdW5pdCgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcInVuaXRcIik7XG4gIH1cbiAgc2V0IGRlc2NyaXB0aW9uKGRlc2NyaXB0aW9uKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJkZXNjcmlwdGlvblwiKTtcbiAgICBpZiAoZGVzY3JpcHRpb24pIHRoaXMudGFncy5wdXNoKFtcImRlc2NyaXB0aW9uXCIsIGRlc2NyaXB0aW9uLnRvU3RyaW5nKCldKTtcbiAgfVxuICBnZXQgZGVzY3JpcHRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJkZXNjcmlwdGlvblwiKTtcbiAgfVxuICBzZXQgbWludChtaW50KSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJtaW50XCIpO1xuICAgIGlmIChtaW50KSB0aGlzLnRhZ3MucHVzaChbXCJtaW50XCIsIG1pbnQudG9TdHJpbmcoKV0pO1xuICB9XG4gIGdldCBtaW50KCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwibWludFwiKTtcbiAgfVxuICAvKipcbiAgICogVGFncyB0b2tlbnMgdGhhdCB3ZXJlIGNyZWF0ZWQgaW4gdGhpcyBoaXN0b3J5IGV2ZW50XG4gICAqL1xuICBzZXQgZGVzdHJveWVkVG9rZW5zKGV2ZW50cykge1xuICAgIGZvciAoY29uc3QgZXZlbnQgb2YgZXZlbnRzKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChldmVudC50YWdSZWZlcmVuY2UoTUFSS0VSUy5ERVNUUk9ZRUQpKTtcbiAgICB9XG4gIH1cbiAgc2V0IGRlc3Ryb3llZFRva2VuSWRzKGlkcykge1xuICAgIGZvciAoY29uc3QgaWQgb2YgaWRzKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJlXCIsIGlkLCBcIlwiLCBNQVJLRVJTLkRFU1RST1lFRF0pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVGFncyB0b2tlbnMgdGhhdCB3ZXJlIGNyZWF0ZWQgaW4gdGhpcyBoaXN0b3J5IGV2ZW50XG4gICAqL1xuICBzZXQgY3JlYXRlZFRva2VucyhldmVudHMpIHtcbiAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIGV2ZW50cykge1xuICAgICAgdGhpcy50YWdzLnB1c2goZXZlbnQudGFnUmVmZXJlbmNlKE1BUktFUlMuQ1JFQVRFRCkpO1xuICAgIH1cbiAgfVxuICBzZXQgcmVzZXJ2ZWRUb2tlbnMoZXZlbnRzKSB7XG4gICAgZm9yIChjb25zdCBldmVudCBvZiBldmVudHMpIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKGV2ZW50LnRhZ1JlZmVyZW5jZShNQVJLRVJTLlJFU0VSVkVEKSk7XG4gICAgfVxuICB9XG4gIGFkZFJlZGVlbWVkTnV0emFwKGV2ZW50KSB7XG4gICAgdGhpcy50YWcoZXZlbnQsIE1BUktFUlMuUkVERUVNRUQpO1xuICB9XG4gIGFzeW5jIHRvTm9zdHJFdmVudChwdWJrZXkpIHtcbiAgICBjb25zdCBlbmNyeXB0ZWRUYWdzID0gW107XG4gICAgY29uc3QgdW5lbmNyeXB0ZWRUYWdzID0gW107XG4gICAgZm9yIChjb25zdCB0YWcgb2YgdGhpcy50YWdzKSB7XG4gICAgICBpZiAoIXRoaXMuc2hvdWxkRW5jcnlwdFRhZyh0YWcpKSB7XG4gICAgICAgIHVuZW5jcnlwdGVkVGFncy5wdXNoKHRhZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbmNyeXB0ZWRUYWdzLnB1c2godGFnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy50YWdzID0gdW5lbmNyeXB0ZWRUYWdzLmZpbHRlcigodCkgPT4gdFswXSAhPT0gXCJjbGllbnRcIik7XG4gICAgdGhpcy5jb250ZW50ID0gSlNPTi5zdHJpbmdpZnkoZW5jcnlwdGVkVGFncyk7XG4gICAgY29uc3QgdXNlciA9IGF3YWl0IHRoaXMubmRrLnNpZ25lci51c2VyKCk7XG4gICAgYXdhaXQgdGhpcy5lbmNyeXB0KHVzZXIsIHZvaWQgMCwgXCJuaXA0NFwiKTtcbiAgICByZXR1cm4gc3VwZXIudG9Ob3N0ckV2ZW50KHB1YmtleSk7XG4gIH1cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhpcyBlbnRyeSBpbmNsdWRlcyBhIHJlZGVtcHRpb24gb2YgYSBOdXR6YXBcbiAgICovXG4gIGdldCBoYXNOdXR6YXBSZWRlbXB0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmdldE1hdGNoaW5nVGFncyhcImVcIiwgTUFSS0VSUy5SRURFRU1FRCkubGVuZ3RoID4gMDtcbiAgfVxuICBzaG91bGRFbmNyeXB0VGFnKHRhZykge1xuICAgIGNvbnN0IHVuZW5jcnlwdGVkVGFnTmFtZXMgPSBbXCJjbGllbnRcIl07XG4gICAgaWYgKHVuZW5jcnlwdGVkVGFnTmFtZXMuaW5jbHVkZXModGFnWzBdKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGFnWzBdID09PSBcImVcIiAmJiB0YWdbM10gPT09IE1BUktFUlMuUkVERUVNRUQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRhZ1swXSA9PT0gXCJwXCIpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuLy8gc3JjL2V2ZW50cy9raW5kcy9OREtSZWxheUxpc3QudHNcbnZhciBSRUFEX01BUktFUiA9IFwicmVhZFwiO1xudmFyIFdSSVRFX01BUktFUiA9IFwid3JpdGVcIjtcbnZhciBOREtSZWxheUxpc3QgPSBjbGFzcyBfTkRLUmVsYXlMaXN0IGV4dGVuZHMgTkRLRXZlbnQge1xuICBjb25zdHJ1Y3RvcihuZGssIHJhd0V2ZW50KSB7XG4gICAgc3VwZXIobmRrLCByYXdFdmVudCk7XG4gICAgdGhpcy5raW5kID8/PSAxMDAwMiAvKiBSZWxheUxpc3QgKi87XG4gIH1cbiAgc3RhdGljIGZyb20obmRrRXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtSZWxheUxpc3QobmRrRXZlbnQubmRrLCBuZGtFdmVudC5yYXdFdmVudCgpKTtcbiAgfVxuICBnZXQgcmVhZFJlbGF5VXJscygpIHtcbiAgICByZXR1cm4gdGhpcy50YWdzLmZpbHRlcigodGFnKSA9PiB0YWdbMF0gPT09IFwiclwiIHx8IHRhZ1swXSA9PT0gXCJyZWxheVwiKS5maWx0ZXIoKHRhZykgPT4gIXRhZ1syXSB8fCB0YWdbMl0gJiYgdGFnWzJdID09PSBSRUFEX01BUktFUikubWFwKCh0YWcpID0+IHRyeU5vcm1hbGl6ZVJlbGF5VXJsKHRhZ1sxXSkpLmZpbHRlcigodXJsKSA9PiAhIXVybCk7XG4gIH1cbiAgc2V0IHJlYWRSZWxheVVybHMocmVsYXlzKSB7XG4gICAgZm9yIChjb25zdCByZWxheSBvZiByZWxheXMpIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcInJcIiwgcmVsYXksIFJFQURfTUFSS0VSXSk7XG4gICAgfVxuICB9XG4gIGdldCB3cml0ZVJlbGF5VXJscygpIHtcbiAgICByZXR1cm4gdGhpcy50YWdzLmZpbHRlcigodGFnKSA9PiB0YWdbMF0gPT09IFwiclwiIHx8IHRhZ1swXSA9PT0gXCJyZWxheVwiKS5maWx0ZXIoKHRhZykgPT4gIXRhZ1syXSB8fCB0YWdbMl0gJiYgdGFnWzJdID09PSBXUklURV9NQVJLRVIpLm1hcCgodGFnKSA9PiB0cnlOb3JtYWxpemVSZWxheVVybCh0YWdbMV0pKS5maWx0ZXIoKHVybCkgPT4gISF1cmwpO1xuICB9XG4gIHNldCB3cml0ZVJlbGF5VXJscyhyZWxheXMpIHtcbiAgICBmb3IgKGNvbnN0IHJlbGF5IG9mIHJlbGF5cykge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wiclwiLCByZWxheSwgV1JJVEVfTUFSS0VSXSk7XG4gICAgfVxuICB9XG4gIGdldCBib3RoUmVsYXlVcmxzKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ3MuZmlsdGVyKCh0YWcpID0+IHRhZ1swXSA9PT0gXCJyXCIgfHwgdGFnWzBdID09PSBcInJlbGF5XCIpLmZpbHRlcigodGFnKSA9PiAhdGFnWzJdKS5tYXAoKHRhZykgPT4gdGFnWzFdKTtcbiAgfVxuICBzZXQgYm90aFJlbGF5VXJscyhyZWxheXMpIHtcbiAgICBmb3IgKGNvbnN0IHJlbGF5IG9mIHJlbGF5cykge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wiclwiLCByZWxheV0pO1xuICAgIH1cbiAgfVxuICBnZXQgcmVsYXlzKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ3MuZmlsdGVyKCh0YWcpID0+IHRhZ1swXSA9PT0gXCJyXCIgfHwgdGFnWzBdID09PSBcInJlbGF5XCIpLm1hcCgodGFnKSA9PiB0YWdbMV0pO1xuICB9XG4gIC8qKlxuICAgKiBQcm92aWRlcyBhIHJlbGF5U2V0IGZvciB0aGUgcmVsYXlzIGluIHRoaXMgbGlzdC5cbiAgICovXG4gIGdldCByZWxheVNldCgpIHtcbiAgICBpZiAoIXRoaXMubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJOREtSZWxheUxpc3QgaGFzIG5vIE5ESyBpbnN0YW5jZVwiKTtcbiAgICByZXR1cm4gbmV3IE5ES1JlbGF5U2V0KFxuICAgICAgbmV3IFNldCh0aGlzLnJlbGF5cy5tYXAoKHUpID0+IHRoaXMubmRrLnBvb2wuZ2V0UmVsYXkodSkpKSxcbiAgICAgIHRoaXMubmRrXG4gICAgKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHJlbGF5TGlzdEZyb21LaW5kMyhuZGssIGNvbnRhY3RMaXN0KSB7XG4gIHRyeSB7XG4gICAgY29uc3QgY29udGVudCA9IEpTT04ucGFyc2UoY29udGFjdExpc3QuY29udGVudCk7XG4gICAgY29uc3QgcmVsYXlMaXN0ID0gbmV3IE5ES1JlbGF5TGlzdChuZGspO1xuICAgIGNvbnN0IHJlYWRSZWxheXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGNvbnN0IHdyaXRlUmVsYXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBmb3IgKGxldCBba2V5LCBjb25maWddIG9mIE9iamVjdC5lbnRyaWVzKGNvbnRlbnQpKSB7XG4gICAgICB0cnkge1xuICAgICAgICBrZXkgPSBub3JtYWxpemVSZWxheVVybChrZXkpO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFjb25maWcpIHtcbiAgICAgICAgcmVhZFJlbGF5cy5hZGQoa2V5KTtcbiAgICAgICAgd3JpdGVSZWxheXMuYWRkKGtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCByZWxheUNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgaWYgKHJlbGF5Q29uZmlnLndyaXRlKSB3cml0ZVJlbGF5cy5hZGQoa2V5KTtcbiAgICAgICAgaWYgKHJlbGF5Q29uZmlnLnJlYWQpIHJlYWRSZWxheXMuYWRkKGtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlbGF5TGlzdC5yZWFkUmVsYXlVcmxzID0gQXJyYXkuZnJvbShyZWFkUmVsYXlzKTtcbiAgICByZWxheUxpc3Qud3JpdGVSZWxheVVybHMgPSBBcnJheS5mcm9tKHdyaXRlUmVsYXlzKTtcbiAgICByZXR1cm4gcmVsYXlMaXN0O1xuICB9IGNhdGNoIHtcbiAgfVxuICByZXR1cm4gdm9pZCAwO1xufVxuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL25pcDg5L05ES0FwcEhhbmRsZXIudHNcbnZhciBOREtBcHBIYW5kbGVyRXZlbnQgPSBjbGFzcyBfTkRLQXBwSGFuZGxlckV2ZW50IGV4dGVuZHMgTkRLRXZlbnQge1xuICBwcm9maWxlO1xuICBjb25zdHJ1Y3RvcihuZGssIHJhd0V2ZW50KSB7XG4gICAgc3VwZXIobmRrLCByYXdFdmVudCk7XG4gICAgdGhpcy5raW5kID8/PSAzMTk5MCAvKiBBcHBIYW5kbGVyICovO1xuICB9XG4gIHN0YXRpYyBmcm9tKG5ka0V2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLQXBwSGFuZGxlckV2ZW50KG5ka0V2ZW50Lm5kaywgbmRrRXZlbnQucmF3RXZlbnQoKSk7XG4gIH1cbiAgLyoqXG4gICAqIEZldGNoZXMgYXBwIGhhbmRsZXIgaW5mb3JtYXRpb25cbiAgICogSWYgbm8gYXBwIGluZm9ybWF0aW9uIGlzIGF2YWlsYWJsZSBvbiB0aGUga2luZDozMTk5MCxcbiAgICogd2UgZmV0Y2ggdGhlIGV2ZW50J3MgYXV0aG9yJ3MgcHJvZmlsZSBhbmQgcmV0dXJuIHRoYXQgaW5zdGVhZC5cbiAgICovXG4gIGFzeW5jIGZldGNoUHJvZmlsZSgpIHtcbiAgICBpZiAodGhpcy5wcm9maWxlID09PSB2b2lkIDAgJiYgdGhpcy5jb250ZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHByb2ZpbGUgPSBKU09OLnBhcnNlKHRoaXMuY29udGVudCk7XG4gICAgICAgIGlmIChwcm9maWxlICYmIHByb2ZpbGUubmFtZSkge1xuICAgICAgICAgIHJldHVybiBwcm9maWxlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucHJvZmlsZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhpcy5wcm9maWxlID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IGF1dGhvciA9IHRoaXMuYXV0aG9yO1xuICAgICAgYXV0aG9yLmZldGNoUHJvZmlsZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICByZXNvbHZlKGF1dGhvci5wcm9maWxlKTtcbiAgICAgIH0pLmNhdGNoKHJlamVjdCk7XG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIHNyYy9ldmVudHMva2luZHMvcmVwb3N0LnRzXG52YXIgTkRLUmVwb3N0ID0gY2xhc3MgX05ES1JlcG9zdCBleHRlbmRzIE5ES0V2ZW50IHtcbiAgX3JlcG9zdGVkRXZlbnRzO1xuICBjb25zdHJ1Y3RvcihuZGssIHJhd0V2ZW50KSB7XG4gICAgc3VwZXIobmRrLCByYXdFdmVudCk7XG4gIH1cbiAgc3RhdGljIGZyb20oZXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtSZXBvc3QoZXZlbnQubmRrLCBldmVudC5yYXdFdmVudCgpKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbGwgcmVwb3N0ZWQgZXZlbnRzIGJ5IHRoZSBjdXJyZW50IGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ga2xhc3MgT3B0aW9uYWwgY2xhc3MgdG8gY29udmVydCB0aGUgZXZlbnRzIHRvLlxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgYXN5bmMgcmVwb3N0ZWRFdmVudHMoa2xhc3MsIG9wdHMpIHtcbiAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgIGlmICghdGhpcy5uZGspIHRocm93IG5ldyBFcnJvcihcIk5ESyBpbnN0YW5jZSBub3Qgc2V0XCIpO1xuICAgIGlmICh0aGlzLl9yZXBvc3RlZEV2ZW50cyAhPT0gdm9pZCAwKSByZXR1cm4gdGhpcy5fcmVwb3N0ZWRFdmVudHM7XG4gICAgZm9yIChjb25zdCBldmVudElkIG9mIHRoaXMucmVwb3N0ZWRFdmVudElkcygpKSB7XG4gICAgICBjb25zdCBmaWx0ZXIgPSBmaWx0ZXJGb3JJZChldmVudElkKTtcbiAgICAgIGNvbnN0IGV2ZW50ID0gYXdhaXQgdGhpcy5uZGsuZmV0Y2hFdmVudChmaWx0ZXIsIG9wdHMpO1xuICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgIGl0ZW1zLnB1c2goa2xhc3MgPyBrbGFzcy5mcm9tKGV2ZW50KSA6IGV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByZXBvc3RlZCBldmVudCBJRHMuXG4gICAqL1xuICByZXBvc3RlZEV2ZW50SWRzKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ3MuZmlsdGVyKCh0KSA9PiB0WzBdID09PSBcImVcIiB8fCB0WzBdID09PSBcImFcIikubWFwKCh0KSA9PiB0WzFdKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGZpbHRlckZvcklkKGlkKSB7XG4gIGlmIChpZC5tYXRjaCgvOi8pKSB7XG4gICAgY29uc3QgW2tpbmQsIHB1YmtleSwgaWRlbnRpZmllcl0gPSBpZC5zcGxpdChcIjpcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtpbmRzOiBbcGFyc2VJbnQoa2luZCldLFxuICAgICAgYXV0aG9yczogW3B1YmtleV0sXG4gICAgICBcIiNkXCI6IFtpZGVudGlmaWVyXVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHsgaWRzOiBbaWRdIH07XG4gIH1cbn1cblxuLy8gc3JjL2V2ZW50cy9raW5kcy9zdWJzY3JpcHRpb25zL3JlY2VpcHQudHNcbmltcG9ydCBkZWJ1ZzMgZnJvbSBcImRlYnVnXCI7XG52YXIgTkRLU3Vic2NyaXB0aW9uUmVjZWlwdCA9IGNsYXNzIF9OREtTdWJzY3JpcHRpb25SZWNlaXB0IGV4dGVuZHMgTkRLRXZlbnQge1xuICBkZWJ1ZztcbiAgY29uc3RydWN0b3IobmRrLCByYXdFdmVudCkge1xuICAgIHN1cGVyKG5kaywgcmF3RXZlbnQpO1xuICAgIHRoaXMua2luZCA/Pz0gNzAwMyAvKiBTdWJzY3JpcHRpb25SZWNlaXB0ICovO1xuICAgIHRoaXMuZGVidWcgPSBuZGs/LmRlYnVnLmV4dGVuZChcInN1YnNjcmlwdGlvbi1zdGFydFwiKSA/PyBkZWJ1ZzMoXCJuZGs6c3Vic2NyaXB0aW9uLXN0YXJ0XCIpO1xuICB9XG4gIHN0YXRpYyBmcm9tKGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLU3Vic2NyaXB0aW9uUmVjZWlwdChldmVudC5uZGssIGV2ZW50LnJhd0V2ZW50KCkpO1xuICB9XG4gIC8qKlxuICAgKiBUaGlzIGlzIHRoZSBwZXJzb24gYmVpbmcgc3Vic2NyaWJlZCB0b1xuICAgKi9cbiAgZ2V0IHJlY2lwaWVudCgpIHtcbiAgICBjb25zdCBwVGFnID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJwXCIpPy5bMF07XG4gICAgaWYgKCFwVGFnKSByZXR1cm4gdm9pZCAwO1xuICAgIGNvbnN0IHVzZXIgPSBuZXcgTkRLVXNlcih7IHB1YmtleTogcFRhZ1sxXSB9KTtcbiAgICByZXR1cm4gdXNlcjtcbiAgfVxuICBzZXQgcmVjaXBpZW50KHVzZXIpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInBcIik7XG4gICAgaWYgKCF1c2VyKSByZXR1cm47XG4gICAgdGhpcy50YWdzLnB1c2goW1wicFwiLCB1c2VyLnB1YmtleV0pO1xuICB9XG4gIC8qKlxuICAgKiBUaGlzIGlzIHRoZSBwZXJzb24gc3Vic2NyaWJpbmdcbiAgICovXG4gIGdldCBzdWJzY3JpYmVyKCkge1xuICAgIGNvbnN0IFBUYWcgPSB0aGlzLmdldE1hdGNoaW5nVGFncyhcIlBcIik/LlswXTtcbiAgICBpZiAoIVBUYWcpIHJldHVybiB2b2lkIDA7XG4gICAgY29uc3QgdXNlciA9IG5ldyBOREtVc2VyKHsgcHVia2V5OiBQVGFnWzFdIH0pO1xuICAgIHJldHVybiB1c2VyO1xuICB9XG4gIHNldCBzdWJzY3JpYmVyKHVzZXIpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcIlBcIik7XG4gICAgaWYgKCF1c2VyKSByZXR1cm47XG4gICAgdGhpcy50YWdzLnB1c2goW1wiUFwiLCB1c2VyLnB1YmtleV0pO1xuICB9XG4gIHNldCBzdWJzY3JpcHRpb25TdGFydChldmVudCkge1xuICAgIHRoaXMuZGVidWcoYGJlZm9yZSBzZXR0aW5nIHN1YnNjcmlwdGlvbiBzdGFydDogJHt0aGlzLnJhd0V2ZW50fWApO1xuICAgIHRoaXMucmVtb3ZlVGFnKFwiZVwiKTtcbiAgICB0aGlzLnRhZyhldmVudCwgXCJzdWJzY3JpcHRpb25cIiwgdHJ1ZSk7XG4gICAgdGhpcy5kZWJ1ZyhgYWZ0ZXIgc2V0dGluZyBzdWJzY3JpcHRpb24gc3RhcnQ6ICR7dGhpcy5yYXdFdmVudH1gKTtcbiAgfVxuICBnZXQgdGllck5hbWUoKSB7XG4gICAgY29uc3QgdGFnID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJ0aWVyXCIpPy5bMF07XG4gICAgcmV0dXJuIHRhZz8uWzFdO1xuICB9XG4gIGdldCBpc1ZhbGlkKCkge1xuICAgIGNvbnN0IHBlcmlvZCA9IHRoaXMudmFsaWRQZXJpb2Q7XG4gICAgaWYgKCFwZXJpb2QpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHBlcmlvZC5zdGFydCA+IHBlcmlvZC5lbmQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgcFRhZ3MgPSB0aGlzLmdldE1hdGNoaW5nVGFncyhcInBcIik7XG4gICAgY29uc3QgUFRhZ3MgPSB0aGlzLmdldE1hdGNoaW5nVGFncyhcIlBcIik7XG4gICAgaWYgKHBUYWdzLmxlbmd0aCAhPT0gMSB8fCBQVGFncy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZ2V0IHZhbGlkUGVyaW9kKCkge1xuICAgIGNvbnN0IHRhZyA9IHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwidmFsaWRcIik/LlswXTtcbiAgICBpZiAoIXRhZykgcmV0dXJuIHZvaWQgMDtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IG5ldyBEYXRlKHBhcnNlSW50KHRhZ1sxXSkgKiAxZTMpLFxuICAgICAgICBlbmQ6IG5ldyBEYXRlKHBhcnNlSW50KHRhZ1syXSkgKiAxZTMpXG4gICAgICB9O1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgc2V0IHZhbGlkUGVyaW9kKHBlcmlvZCkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwidmFsaWRcIik7XG4gICAgaWYgKCFwZXJpb2QpIHJldHVybjtcbiAgICB0aGlzLnRhZ3MucHVzaChbXG4gICAgICBcInZhbGlkXCIsXG4gICAgICBNYXRoLmZsb29yKHBlcmlvZC5zdGFydC5nZXRUaW1lKCkgLyAxZTMpLnRvU3RyaW5nKCksXG4gICAgICBNYXRoLmZsb29yKHBlcmlvZC5lbmQuZ2V0VGltZSgpIC8gMWUzKS50b1N0cmluZygpXG4gICAgXSk7XG4gIH1cbiAgZ2V0IHN0YXJ0UGVyaW9kKCkge1xuICAgIHJldHVybiB0aGlzLnZhbGlkUGVyaW9kPy5zdGFydDtcbiAgfVxuICBnZXQgZW5kUGVyaW9kKCkge1xuICAgIHJldHVybiB0aGlzLnZhbGlkUGVyaW9kPy5lbmQ7XG4gIH1cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIHN1YnNjcmlwdGlvbiBpcyBjdXJyZW50bHkgYWN0aXZlXG4gICAqL1xuICBpc0FjdGl2ZSh0aW1lKSB7XG4gICAgdGltZSA/Pz0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgY29uc3QgcGVyaW9kID0gdGhpcy52YWxpZFBlcmlvZDtcbiAgICBpZiAoIXBlcmlvZCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0aW1lIDwgcGVyaW9kLnN0YXJ0KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHRpbWUgPiBwZXJpb2QuZW5kKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cbi8vIHNyYy9ldmVudHMva2luZHMvc3Vic2NyaXB0aW9ucy9zdWJzY3JpcHRpb24tc3RhcnQudHNcbmltcG9ydCBkZWJ1ZzQgZnJvbSBcImRlYnVnXCI7XG52YXIgTkRLU3Vic2NyaXB0aW9uU3RhcnQgPSBjbGFzcyBfTkRLU3Vic2NyaXB0aW9uU3RhcnQgZXh0ZW5kcyBOREtFdmVudCB7XG4gIGRlYnVnO1xuICBjb25zdHJ1Y3RvcihuZGssIHJhd0V2ZW50KSB7XG4gICAgc3VwZXIobmRrLCByYXdFdmVudCk7XG4gICAgdGhpcy5raW5kID8/PSA3MDAxIC8qIFN1YnNjcmliZSAqLztcbiAgICB0aGlzLmRlYnVnID0gbmRrPy5kZWJ1Zy5leHRlbmQoXCJzdWJzY3JpcHRpb24tc3RhcnRcIikgPz8gZGVidWc0KFwibmRrOnN1YnNjcmlwdGlvbi1zdGFydFwiKTtcbiAgfVxuICBzdGF0aWMgZnJvbShldmVudCkge1xuICAgIHJldHVybiBuZXcgX05ES1N1YnNjcmlwdGlvblN0YXJ0KGV2ZW50Lm5kaywgZXZlbnQucmF3RXZlbnQoKSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlY2lwaWVudCBvZiB0aGUgc3Vic2NyaXB0aW9uLiBJLmUuIFRoZSBhdXRob3Igb2YgdGhpcyBldmVudCBzdWJzY3JpYmVzIHRvIHRoaXMgdXNlci5cbiAgICovXG4gIGdldCByZWNpcGllbnQoKSB7XG4gICAgY29uc3QgcFRhZyA9IHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwicFwiKT8uWzBdO1xuICAgIGlmICghcFRhZykgcmV0dXJuIHZvaWQgMDtcbiAgICBjb25zdCB1c2VyID0gbmV3IE5ES1VzZXIoeyBwdWJrZXk6IHBUYWdbMV0gfSk7XG4gICAgcmV0dXJuIHVzZXI7XG4gIH1cbiAgc2V0IHJlY2lwaWVudCh1c2VyKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJwXCIpO1xuICAgIGlmICghdXNlcikgcmV0dXJuO1xuICAgIHRoaXMudGFncy5wdXNoKFtcInBcIiwgdXNlci5wdWJrZXldKTtcbiAgfVxuICAvKipcbiAgICogVGhlIGFtb3VudCBvZiB0aGUgc3Vic2NyaXB0aW9uLlxuICAgKi9cbiAgZ2V0IGFtb3VudCgpIHtcbiAgICBjb25zdCBhbW91bnRUYWcgPSB0aGlzLmdldE1hdGNoaW5nVGFncyhcImFtb3VudFwiKT8uWzBdO1xuICAgIGlmICghYW1vdW50VGFnKSByZXR1cm4gdm9pZCAwO1xuICAgIHJldHVybiBwYXJzZVRhZ1RvU3Vic2NyaXB0aW9uQW1vdW50KGFtb3VudFRhZyk7XG4gIH1cbiAgc2V0IGFtb3VudChhbW91bnQpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImFtb3VudFwiKTtcbiAgICBpZiAoIWFtb3VudCkgcmV0dXJuO1xuICAgIHRoaXMudGFncy5wdXNoKG5ld0Ftb3VudChhbW91bnQuYW1vdW50LCBhbW91bnQuY3VycmVuY3ksIGFtb3VudC50ZXJtKSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBldmVudCBpZCBvciBOSVAtMzMgdGFnIGlkIG9mIHRoZSB0aWVyIHRoYXQgdGhlIHVzZXIgaXMgc3Vic2NyaWJpbmcgdG8uXG4gICAqL1xuICBnZXQgdGllcklkKCkge1xuICAgIGNvbnN0IGVUYWcgPSB0aGlzLmdldE1hdGNoaW5nVGFncyhcImVcIik/LlswXTtcbiAgICBjb25zdCBhVGFnID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJhXCIpPy5bMF07XG4gICAgaWYgKCFlVGFnIHx8ICFhVGFnKSByZXR1cm4gdm9pZCAwO1xuICAgIHJldHVybiBlVGFnWzFdID8/IGFUYWdbMV07XG4gIH1cbiAgc2V0IHRpZXIodGllcikge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwiZVwiKTtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImFcIik7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJldmVudFwiKTtcbiAgICBpZiAoIXRpZXIpIHJldHVybjtcbiAgICB0aGlzLnRhZyh0aWVyKTtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInBcIik7XG4gICAgdGhpcy50YWdzLnB1c2goW1wicFwiLCB0aWVyLnB1YmtleV0pO1xuICAgIHRoaXMudGFncy5wdXNoKFtcImV2ZW50XCIsIEpTT04uc3RyaW5naWZ5KHRpZXIucmF3RXZlbnQoKSldKTtcbiAgfVxuICAvKipcbiAgICogRmV0Y2hlcyB0aGUgdGllciB0aGF0IHRoZSB1c2VyIGlzIHN1YnNjcmliaW5nIHRvLlxuICAgKi9cbiAgYXN5bmMgZmV0Y2hUaWVyKCkge1xuICAgIGNvbnN0IGV2ZW50VGFnID0gdGhpcy50YWdWYWx1ZShcImV2ZW50XCIpO1xuICAgIGlmIChldmVudFRhZykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcGFyc2VkRXZlbnQgPSBKU09OLnBhcnNlKGV2ZW50VGFnKTtcbiAgICAgICAgcmV0dXJuIG5ldyBOREtTdWJzY3JpcHRpb25UaWVyKHRoaXMubmRrLCBwYXJzZWRFdmVudCk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgdGhpcy5kZWJ1ZyhcIkZhaWxlZCB0byBwYXJzZSBldmVudCB0YWdcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRpZXJJZCA9IHRoaXMudGllcklkO1xuICAgIGlmICghdGllcklkKSByZXR1cm4gdm9pZCAwO1xuICAgIGNvbnN0IGUgPSBhd2FpdCB0aGlzLm5kaz8uZmV0Y2hFdmVudCh0aWVySWQpO1xuICAgIGlmICghZSkgcmV0dXJuIHZvaWQgMDtcbiAgICByZXR1cm4gTkRLU3Vic2NyaXB0aW9uVGllci5mcm9tKGUpO1xuICB9XG4gIGdldCBpc1ZhbGlkKCkge1xuICAgIGlmICh0aGlzLmdldE1hdGNoaW5nVGFncyhcImFtb3VudFwiKS5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRoaXMuZGVidWcoXCJJbnZhbGlkICMgb2YgYW1vdW50IHRhZ1wiKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmFtb3VudCkge1xuICAgICAgdGhpcy5kZWJ1ZyhcIkludmFsaWQgYW1vdW50IHRhZ1wiKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwicFwiKS5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRoaXMuZGVidWcoXCJJbnZhbGlkICMgb2YgcCB0YWdcIik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghdGhpcy5yZWNpcGllbnQpIHtcbiAgICAgIHRoaXMuZGVidWcoXCJJbnZhbGlkIHAgdGFnXCIpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuLy8gc3JjL2V2ZW50cy9raW5kcy9zaW1wbGUtZ3JvdXAvaW5kZXgudHNcbnZhciBOREtTaW1wbGVHcm91cCA9IGNsYXNzIF9OREtTaW1wbGVHcm91cCB7XG4gIG5kaztcbiAgZ3JvdXBJZDtcbiAgcmVsYXlTZXQ7XG4gIGZldGNoaW5nTWV0YWRhdGE7XG4gIG1ldGFkYXRhO1xuICBtZW1iZXJMaXN0O1xuICBhZG1pbkxpc3Q7XG4gIGNvbnN0cnVjdG9yKG5kaywgcmVsYXlTZXQsIGdyb3VwSWQpIHtcbiAgICB0aGlzLm5kayA9IG5kaztcbiAgICB0aGlzLmdyb3VwSWQgPSBncm91cElkID8/IHJhbmRvbUlkKDI0KTtcbiAgICB0aGlzLnJlbGF5U2V0ID0gcmVsYXlTZXQ7XG4gIH1cbiAgZ2V0IGlkKCkge1xuICAgIHJldHVybiB0aGlzLmdyb3VwSWQ7XG4gIH1cbiAgcmVsYXlVcmxzKCkge1xuICAgIHJldHVybiB0aGlzLnJlbGF5U2V0LnJlbGF5VXJscztcbiAgfVxuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXRhZGF0YT8ubmFtZTtcbiAgfVxuICBnZXQgYWJvdXQoKSB7XG4gICAgcmV0dXJuIHRoaXMubWV0YWRhdGE/LmFib3V0O1xuICB9XG4gIGdldCBwaWN0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLm1ldGFkYXRhPy5waWN0dXJlO1xuICB9XG4gIGdldCBtZW1iZXJzKCkge1xuICAgIHJldHVybiB0aGlzLm1lbWJlckxpc3Q/Lm1lbWJlcnMgPz8gW107XG4gIH1cbiAgZ2V0IGFkbWlucygpIHtcbiAgICByZXR1cm4gdGhpcy5hZG1pbkxpc3Q/Lm1lbWJlcnMgPz8gW107XG4gIH1cbiAgYXN5bmMgZ2V0TWV0YWRhdGEoKSB7XG4gICAgYXdhaXQgdGhpcy5lbnN1cmVNZXRhZGF0YUV2ZW50KCk7XG4gICAgcmV0dXJuIHRoaXMubWV0YWRhdGE7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGhlIGdyb3VwIGJ5IHB1Ymxpc2hpbmcgYSBraW5kOjkwMDcgZXZlbnQuXG4gICAqIEBwYXJhbSBzaWduZXJcbiAgICogQHJldHVybnNcbiAgICovXG4gIGFzeW5jIGNyZWF0ZUdyb3VwKHNpZ25lcikge1xuICAgIHNpZ25lciA/Pz0gdGhpcy5uZGsuc2lnbmVyO1xuICAgIGlmICghc2lnbmVyKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBzaWduZXIgYXZhaWxhYmxlXCIpO1xuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBzaWduZXIudXNlcigpO1xuICAgIGlmICghdXNlcikgdGhyb3cgbmV3IEVycm9yKFwiTm8gdXNlciBhdmFpbGFibGVcIik7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgTkRLRXZlbnQodGhpcy5uZGspO1xuICAgIGV2ZW50LmtpbmQgPSA5MDA3IC8qIEdyb3VwQWRtaW5DcmVhdGVHcm91cCAqLztcbiAgICBldmVudC50YWdzLnB1c2goW1wiaFwiLCB0aGlzLmdyb3VwSWRdKTtcbiAgICBhd2FpdCBldmVudC5zaWduKHNpZ25lcik7XG4gICAgcmV0dXJuIGV2ZW50LnB1Ymxpc2godGhpcy5yZWxheVNldCk7XG4gIH1cbiAgYXN5bmMgc2V0TWV0YWRhdGEoe1xuICAgIG5hbWUsXG4gICAgYWJvdXQsXG4gICAgcGljdHVyZVxuICB9KSB7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgTkRLRXZlbnQodGhpcy5uZGspO1xuICAgIGV2ZW50LmtpbmQgPSA5MDAyIC8qIEdyb3VwQWRtaW5FZGl0TWV0YWRhdGEgKi87XG4gICAgZXZlbnQudGFncy5wdXNoKFtcImhcIiwgdGhpcy5ncm91cElkXSk7XG4gICAgaWYgKG5hbWUpIGV2ZW50LnRhZ3MucHVzaChbXCJuYW1lXCIsIG5hbWVdKTtcbiAgICBpZiAoYWJvdXQpIGV2ZW50LnRhZ3MucHVzaChbXCJhYm91dFwiLCBhYm91dF0pO1xuICAgIGlmIChwaWN0dXJlKSBldmVudC50YWdzLnB1c2goW1wicGljdHVyZVwiLCBwaWN0dXJlXSk7XG4gICAgYXdhaXQgZXZlbnQuc2lnbigpO1xuICAgIHJldHVybiBldmVudC5wdWJsaXNoKHRoaXMucmVsYXlTZXQpO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGEgdXNlciB0byB0aGUgZ3JvdXAgdXNpbmcgYSBraW5kOjkwMDAgZXZlbnRcbiAgICogQHBhcmFtIHVzZXIgdXNlciB0byBhZGRcbiAgICogQHBhcmFtIG9wdHMgb3B0aW9uc1xuICAgKi9cbiAgYXN5bmMgYWRkVXNlcih1c2VyKSB7XG4gICAgY29uc3QgYWRkVXNlckV2ZW50ID0gX05ES1NpbXBsZUdyb3VwLmdlbmVyYXRlQWRkVXNlckV2ZW50KHVzZXIucHVia2V5LCB0aGlzLmdyb3VwSWQpO1xuICAgIGFkZFVzZXJFdmVudC5uZGsgPSB0aGlzLm5kaztcbiAgICByZXR1cm4gYWRkVXNlckV2ZW50O1xuICB9XG4gIGFzeW5jIGdldE1lbWJlckxpc3RFdmVudCgpIHtcbiAgICBjb25zdCBtZW1iZXJMaXN0ID0gYXdhaXQgdGhpcy5uZGsuZmV0Y2hFdmVudChcbiAgICAgIHtcbiAgICAgICAga2luZHM6IFszOTAwMiAvKiBHcm91cE1lbWJlcnMgKi9dLFxuICAgICAgICBcIiNkXCI6IFt0aGlzLmdyb3VwSWRdXG4gICAgICB9LFxuICAgICAgdm9pZCAwLFxuICAgICAgdGhpcy5yZWxheVNldFxuICAgICk7XG4gICAgaWYgKCFtZW1iZXJMaXN0KSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gTkRLU2ltcGxlR3JvdXBNZW1iZXJMaXN0LmZyb20obWVtYmVyTGlzdCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgYSBsaXN0IG9mIHVzZXJzIHRoYXQgYmVsb25nIHRvIHRoaXMgZ3JvdXBcbiAgICovXG4gIGFzeW5jIGdldE1lbWJlcnMoKSB7XG4gICAgY29uc3QgbWVtYmVycyA9IFtdO1xuICAgIGNvbnN0IG1lbWJlclB1YmtleXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGNvbnN0IG1lbWJlckxpc3RFdmVudCA9IGF3YWl0IHRoaXMuZ2V0TWVtYmVyTGlzdEV2ZW50KCk7XG4gICAgaWYgKCFtZW1iZXJMaXN0RXZlbnQpIHJldHVybiBbXTtcbiAgICBmb3IgKGNvbnN0IHBUYWcgb2YgbWVtYmVyTGlzdEV2ZW50LmdldE1hdGNoaW5nVGFncyhcInBcIikpIHtcbiAgICAgIGNvbnN0IHB1YmtleSA9IHBUYWdbMV07XG4gICAgICBpZiAobWVtYmVyUHVia2V5cy5oYXMocHVia2V5KSkgY29udGludWU7XG4gICAgICBtZW1iZXJQdWJrZXlzLmFkZChwdWJrZXkpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgbWVtYmVycy5wdXNoKHRoaXMubmRrLmdldFVzZXIoeyBwdWJrZXkgfSkpO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZW1iZXJzO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYW4gZXZlbnQgdGhhdCBsaXN0cyB0aGUgbWVtYmVycyBvZiBhIGdyb3VwLlxuICAgKiBAcGFyYW0gZ3JvdXBJZFxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgc3RhdGljIGdlbmVyYXRlVXNlckxpc3RFdmVudChncm91cElkKSB7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgTkRLRXZlbnQodm9pZCAwLCB7XG4gICAgICBraW5kOiAzOTAwMiAvKiBHcm91cE1lbWJlcnMgKi8sXG4gICAgICB0YWdzOiBbXG4gICAgICAgIFtcImhcIiwgZ3JvdXBJZF0sXG4gICAgICAgIFtcImFsdFwiLCBcIkdyb3VwIE1lbWJlciBMaXN0XCJdXG4gICAgICBdXG4gICAgfSk7XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYW4gZXZlbnQgdGhhdCBhZGRzIGEgdXNlciB0byBhIGdyb3VwLlxuICAgKiBAcGFyYW0gdXNlclB1YmtleSBwdWJrZXkgb2YgdGhlIHVzZXIgdG8gYWRkXG4gICAqIEBwYXJhbSBncm91cElkIGdyb3VwIHRvIGFkZCB0aGUgdXNlciB0b1xuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgc3RhdGljIGdlbmVyYXRlQWRkVXNlckV2ZW50KHVzZXJQdWJrZXksIGdyb3VwSWQpIHtcbiAgICBjb25zdCBldmVudCA9IG5ldyBOREtFdmVudCh2b2lkIDAsIHtcbiAgICAgIGtpbmQ6IDllMyAvKiBHcm91cEFkbWluQWRkVXNlciAqLyxcbiAgICAgIHRhZ3M6IFtbXCJoXCIsIGdyb3VwSWRdXVxuICAgIH0pO1xuICAgIGV2ZW50LnRhZ3MucHVzaChbXCJwXCIsIHVzZXJQdWJrZXldKTtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH1cbiAgYXN5bmMgcmVxdWVzdFRvSm9pbihwdWJrZXksIGNvbnRlbnQpIHtcbiAgICBjb25zdCBldmVudCA9IG5ldyBOREtFdmVudCh0aGlzLm5kaywge1xuICAgICAga2luZDogOTAyMSAvKiBHcm91cEFkbWluUmVxdWVzdEpvaW4gKi8sXG4gICAgICBjb250ZW50OiBjb250ZW50ID8/IFwiXCIsXG4gICAgICB0YWdzOiBbW1wiaFwiLCB0aGlzLmdyb3VwSWRdXVxuICAgIH0pO1xuICAgIHJldHVybiBldmVudC5wdWJsaXNoKHRoaXMucmVsYXlTZXQpO1xuICB9XG4gIC8qKlxuICAgKiBNYWtlcyBzdXJlIHRoYXQgYSBtZXRhZGF0YSBldmVudCBleGlzdHMgbG9jYWxseVxuICAgKi9cbiAgYXN5bmMgZW5zdXJlTWV0YWRhdGFFdmVudCgpIHtcbiAgICBpZiAodGhpcy5tZXRhZGF0YSkgcmV0dXJuO1xuICAgIGlmICh0aGlzLmZldGNoaW5nTWV0YWRhdGEpIHJldHVybiB0aGlzLmZldGNoaW5nTWV0YWRhdGE7XG4gICAgdGhpcy5mZXRjaGluZ01ldGFkYXRhID0gdGhpcy5uZGsuZmV0Y2hFdmVudChcbiAgICAgIHtcbiAgICAgICAga2luZHM6IFszOWUzIC8qIEdyb3VwTWV0YWRhdGEgKi9dLFxuICAgICAgICBcIiNkXCI6IFt0aGlzLmdyb3VwSWRdXG4gICAgICB9LFxuICAgICAgdm9pZCAwLFxuICAgICAgdGhpcy5yZWxheVNldFxuICAgICkudGhlbigoZXZlbnQpID0+IHtcbiAgICAgIGlmIChldmVudCkge1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gTkRLU2ltcGxlR3JvdXBNZXRhZGF0YS5mcm9tKGV2ZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBuZXcgTkRLU2ltcGxlR3JvdXBNZXRhZGF0YSh0aGlzLm5kayk7XG4gICAgICAgIHRoaXMubWV0YWRhdGEuZFRhZyA9IHRoaXMuZ3JvdXBJZDtcbiAgICAgIH1cbiAgICB9KS5maW5hbGx5KCgpID0+IHtcbiAgICAgIHRoaXMuZmV0Y2hpbmdNZXRhZGF0YSA9IHZvaWQgMDtcbiAgICB9KS5jYXRjaCgoKSA9PiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZmV0Y2ggbWV0YWRhdGEgZm9yIGdyb3VwIFwiICsgdGhpcy5ncm91cElkKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5mZXRjaGluZ01ldGFkYXRhO1xuICB9XG59O1xuZnVuY3Rpb24gcmFuZG9tSWQobGVuZ3RoKSB7XG4gIGNvbnN0IGNoYXJzID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OVwiO1xuICBjb25zdCBjaGFyc0xlbmd0aCA9IGNoYXJzLmxlbmd0aDtcbiAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICByZXN1bHQgKz0gY2hhcnMuY2hhckF0KE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNoYXJzTGVuZ3RoKSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gc3JjL2FwcC1zZXR0aW5ncy9pbmRleC50c1xudmFyIE5ES0FwcFNldHRpbmdzID0gY2xhc3MgX05ES0FwcFNldHRpbmdzIGV4dGVuZHMgTkRLRXZlbnQge1xuICBhcHBOYW1lO1xuICBzZXR0aW5ncyA9IHt9O1xuICBjb25zdHJ1Y3RvcihuZGssIHJhd0V2ZW50KSB7XG4gICAgc3VwZXIobmRrLCByYXdFdmVudCk7XG4gICAgdGhpcy5raW5kID8/PSAzMDA3OCAvKiBBcHBTcGVjaWZpY0RhdGEgKi87XG4gICAgdGhpcy5kVGFnID8/PSB0aGlzLmFwcE5hbWU7XG4gICAgaWYgKHRoaXMuY29udGVudC5sZW5ndGggPiAwKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLnNldHRpbmdzID0gSlNPTi5wYXJzZSh0aGlzLmNvbnRlbnQpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHBhcnNpbmcgYXBwIHNldHRpbmdzXCIsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc3RhdGljIGZyb20oZXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtBcHBTZXR0aW5ncyhldmVudC5uZGssIGV2ZW50KTtcbiAgfVxuICAvKipcbiAgICogU2V0IGEgdmFsdWUgZm9yIGEgZ2l2ZW4ga2V5LlxuICAgKlxuICAgKiBAcGFyYW0ga2V5XG4gICAqIEBwYXJhbSB2YWx1ZVxuICAgKi9cbiAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLnNldHRpbmdzW2tleV0gPSB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogR2V0IGEgdmFsdWUgZm9yIGEgZ2l2ZW4ga2V5LlxuICAgKlxuICAgKiBAcGFyYW0ga2V5XG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBnZXQoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0dGluZ3Nba2V5XTtcbiAgfVxuICBhc3luYyBwdWJsaXNoUmVwbGFjZWFibGUocmVsYXlTZXQsIHRpbWVvdXRNcywgcmVxdWlyZWRSZWxheUNvdW50KSB7XG4gICAgdGhpcy5jb250ZW50ID0gSlNPTi5zdHJpbmdpZnkodGhpcy5zZXR0aW5ncyk7XG4gICAgcmV0dXJuIHN1cGVyLnB1Ymxpc2hSZXBsYWNlYWJsZShyZWxheVNldCwgdGltZW91dE1zLCByZXF1aXJlZFJlbGF5Q291bnQpO1xuICB9XG59O1xuXG4vLyBzcmMvcmVsYXkvYXV0aC1wb2xpY2llcy50c1xuaW1wb3J0IGNyZWF0ZURlYnVnMiBmcm9tIFwiZGVidWdcIjtcbmZ1bmN0aW9uIGRpc2Nvbm5lY3QocG9vbCwgZGVidWc4KSB7XG4gIGRlYnVnOCA/Pz0gY3JlYXRlRGVidWcyKFwibmRrOnJlbGF5OmF1dGgtcG9saWNpZXM6ZGlzY29ubmVjdFwiKTtcbiAgcmV0dXJuIGFzeW5jIChyZWxheSkgPT4ge1xuICAgIGRlYnVnOChgUmVsYXkgJHtyZWxheS51cmx9IHJlcXVlc3RlZCBhdXRoZW50aWNhdGlvbiwgZGlzY29ubmVjdGluZ2ApO1xuICAgIHBvb2wucmVtb3ZlUmVsYXkocmVsYXkudXJsKTtcbiAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNpZ25BbmRBdXRoKGV2ZW50LCByZWxheSwgc2lnbmVyLCBkZWJ1ZzgsIHJlc29sdmUsIHJlamVjdCkge1xuICB0cnkge1xuICAgIGF3YWl0IGV2ZW50LnNpZ24oc2lnbmVyKTtcbiAgICByZXNvbHZlKGV2ZW50KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGRlYnVnOChgRmFpbGVkIHRvIHB1Ymxpc2ggYXV0aCBldmVudCB0byByZWxheSAke3JlbGF5LnVybH1gLCBlKTtcbiAgICByZWplY3QoZXZlbnQpO1xuICB9XG59XG5mdW5jdGlvbiBzaWduSW4oeyBuZGssIHNpZ25lciwgZGVidWc6IGRlYnVnOCB9ID0ge30pIHtcbiAgZGVidWc4ID8/PSBjcmVhdGVEZWJ1ZzIoXCJuZGs6YXV0aC1wb2xpY2llczpzaWduSW5cIik7XG4gIHJldHVybiBhc3luYyAocmVsYXksIGNoYWxsZW5nZSkgPT4ge1xuICAgIGRlYnVnOChgUmVsYXkgJHtyZWxheS51cmx9IHJlcXVlc3RlZCBhdXRoZW50aWNhdGlvbiwgc2lnbmluZyBpbmApO1xuICAgIGNvbnN0IGV2ZW50ID0gbmV3IE5ES0V2ZW50KG5kayk7XG4gICAgZXZlbnQua2luZCA9IDIyMjQyIC8qIENsaWVudEF1dGggKi87XG4gICAgZXZlbnQudGFncyA9IFtcbiAgICAgIFtcInJlbGF5XCIsIHJlbGF5LnVybF0sXG4gICAgICBbXCJjaGFsbGVuZ2VcIiwgY2hhbGxlbmdlXVxuICAgIF07XG4gICAgc2lnbmVyID8/PSBuZGs/LnNpZ25lcjtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKHNpZ25lcikge1xuICAgICAgICBhd2FpdCBzaWduQW5kQXV0aChldmVudCwgcmVsYXksIHNpZ25lciwgZGVidWc4LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmRrPy5vbmNlKFwic2lnbmVyOnJlYWR5XCIsIGFzeW5jIChzaWduZXIyKSA9PiB7XG4gICAgICAgICAgYXdhaXQgc2lnbkFuZEF1dGgoZXZlbnQsIHJlbGF5LCBzaWduZXIyLCBkZWJ1ZzgsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xufVxudmFyIE5ES1JlbGF5QXV0aFBvbGljaWVzID0ge1xuICBkaXNjb25uZWN0LFxuICBzaWduSW5cbn07XG5cbi8vIHNyYy9zaWduZXJzL25pcDA3L2luZGV4LnRzXG5pbXBvcnQgZGVidWc1IGZyb20gXCJkZWJ1Z1wiO1xudmFyIE5ES05pcDA3U2lnbmVyID0gY2xhc3Mge1xuICBfdXNlclByb21pc2U7XG4gIGVuY3J5cHRpb25RdWV1ZSA9IFtdO1xuICBlbmNyeXB0aW9uUHJvY2Vzc2luZyA9IGZhbHNlO1xuICBkZWJ1ZztcbiAgd2FpdFRpbWVvdXQ7XG4gIC8qKlxuICAgKiBAcGFyYW0gd2FpdFRpbWVvdXQgLSBUaGUgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgdG8gd2FpdCBmb3IgdGhlIE5JUC0wNyB0byBiZWNvbWUgYXZhaWxhYmxlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih3YWl0VGltZW91dCA9IDFlMykge1xuICAgIHRoaXMuZGVidWcgPSBkZWJ1ZzUoXCJuZGs6bmlwMDdcIik7XG4gICAgdGhpcy53YWl0VGltZW91dCA9IHdhaXRUaW1lb3V0O1xuICB9XG4gIGFzeW5jIGJsb2NrVW50aWxSZWFkeSgpIHtcbiAgICBhd2FpdCB0aGlzLndhaXRGb3JFeHRlbnNpb24oKTtcbiAgICBjb25zdCBwdWJrZXkgPSBhd2FpdCB3aW5kb3cubm9zdHIuZ2V0UHVibGljS2V5KCk7XG4gICAgaWYgKCFwdWJrZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVzZXIgcmVqZWN0ZWQgYWNjZXNzXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE5ES1VzZXIoeyBwdWJrZXkgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHRlciBmb3IgdGhlIHVzZXIgcHJvcGVydHkuXG4gICAqIEByZXR1cm5zIFRoZSBOREtVc2VyIGluc3RhbmNlLlxuICAgKi9cbiAgYXN5bmMgdXNlcigpIHtcbiAgICBpZiAoIXRoaXMuX3VzZXJQcm9taXNlKSB7XG4gICAgICB0aGlzLl91c2VyUHJvbWlzZSA9IHRoaXMuYmxvY2tVbnRpbFJlYWR5KCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl91c2VyUHJvbWlzZTtcbiAgfVxuICAvKipcbiAgICogU2lnbnMgdGhlIGdpdmVuIE5vc3RyIGV2ZW50LlxuICAgKiBAcGFyYW0gZXZlbnQgLSBUaGUgTm9zdHIgZXZlbnQgdG8gYmUgc2lnbmVkLlxuICAgKiBAcmV0dXJucyBUaGUgc2lnbmF0dXJlIG9mIHRoZSBzaWduZWQgZXZlbnQuXG4gICAqIEB0aHJvd3MgRXJyb3IgaWYgdGhlIE5JUC0wNyBpcyBub3QgYXZhaWxhYmxlIG9uIHRoZSB3aW5kb3cgb2JqZWN0LlxuICAgKi9cbiAgYXN5bmMgc2lnbihldmVudCkge1xuICAgIGF3YWl0IHRoaXMud2FpdEZvckV4dGVuc2lvbigpO1xuICAgIGNvbnN0IHNpZ25lZEV2ZW50ID0gYXdhaXQgd2luZG93Lm5vc3RyLnNpZ25FdmVudChldmVudCk7XG4gICAgcmV0dXJuIHNpZ25lZEV2ZW50LnNpZztcbiAgfVxuICBhc3luYyByZWxheXMobmRrKSB7XG4gICAgYXdhaXQgdGhpcy53YWl0Rm9yRXh0ZW5zaW9uKCk7XG4gICAgY29uc3QgcmVsYXlzID0gYXdhaXQgd2luZG93Lm5vc3RyLmdldFJlbGF5cz8uKCkgfHwge307XG4gICAgY29uc3QgYWN0aXZlUmVsYXlzID0gW107XG4gICAgZm9yIChjb25zdCB1cmwgb2YgT2JqZWN0LmtleXMocmVsYXlzKSkge1xuICAgICAgaWYgKHJlbGF5c1t1cmxdLnJlYWQgJiYgcmVsYXlzW3VybF0ud3JpdGUpIHtcbiAgICAgICAgYWN0aXZlUmVsYXlzLnB1c2godXJsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFjdGl2ZVJlbGF5cy5tYXAoKHVybCkgPT4gbmV3IE5ES1JlbGF5KHVybCwgbmRrPy5yZWxheUF1dGhEZWZhdWx0UG9saWN5LCBuZGspKTtcbiAgfVxuICBhc3luYyBlbmNyeXB0aW9uRW5hYmxlZChuaXApIHtcbiAgICBsZXQgZW5hYmxlZCA9IFtdO1xuICAgIGlmICgoIW5pcCB8fCBuaXAgPT0gXCJuaXAwNFwiKSAmJiBCb29sZWFuKHdpbmRvdy5ub3N0ci5uaXAwNCkpIGVuYWJsZWQucHVzaChcIm5pcDA0XCIpO1xuICAgIGlmICgoIW5pcCB8fCBuaXAgPT0gXCJuaXA0NFwiKSAmJiBCb29sZWFuKHdpbmRvdy5ub3N0ci5uaXA0NCkpIGVuYWJsZWQucHVzaChcIm5pcDQ0XCIpO1xuICAgIHJldHVybiBlbmFibGVkO1xuICB9XG4gIGFzeW5jIGVuY3J5cHQocmVjaXBpZW50LCB2YWx1ZSwgbmlwID0gXCJuaXAwNFwiKSB7XG4gICAgaWYgKCFhd2FpdCB0aGlzLmVuY3J5cHRpb25FbmFibGVkKG5pcCkpIHRocm93IG5ldyBFcnJvcihuaXAgKyBcImVuY3J5cHRpb24gaXMgbm90IGF2YWlsYWJsZSBmcm9tIHlvdXIgYnJvd3NlciBleHRlbnNpb25cIik7XG4gICAgYXdhaXQgdGhpcy53YWl0Rm9yRXh0ZW5zaW9uKCk7XG4gICAgY29uc3QgcmVjaXBpZW50SGV4UHViS2V5ID0gcmVjaXBpZW50LnB1YmtleTtcbiAgICByZXR1cm4gdGhpcy5xdWV1ZUVuY3J5cHRpb24obmlwLCBcImVuY3J5cHRcIiwgcmVjaXBpZW50SGV4UHViS2V5LCB2YWx1ZSk7XG4gIH1cbiAgYXN5bmMgZGVjcnlwdChzZW5kZXIsIHZhbHVlLCBuaXAgPSBcIm5pcDA0XCIpIHtcbiAgICBpZiAoIWF3YWl0IHRoaXMuZW5jcnlwdGlvbkVuYWJsZWQobmlwKSkgdGhyb3cgbmV3IEVycm9yKG5pcCArIFwiZW5jcnlwdGlvbiBpcyBub3QgYXZhaWxhYmxlIGZyb20geW91ciBicm93c2VyIGV4dGVuc2lvblwiKTtcbiAgICBhd2FpdCB0aGlzLndhaXRGb3JFeHRlbnNpb24oKTtcbiAgICBjb25zdCBzZW5kZXJIZXhQdWJLZXkgPSBzZW5kZXIucHVia2V5O1xuICAgIHJldHVybiB0aGlzLnF1ZXVlRW5jcnlwdGlvbihuaXAsIFwiZGVjcnlwdFwiLCBzZW5kZXJIZXhQdWJLZXksIHZhbHVlKTtcbiAgfVxuICBhc3luYyBxdWV1ZUVuY3J5cHRpb24oc2NoZW1lLCBtZXRob2QsIGNvdW50ZXJwYXJ0eUhleHB1YmtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5lbmNyeXB0aW9uUXVldWUucHVzaCh7XG4gICAgICAgIHNjaGVtZSxcbiAgICAgICAgbWV0aG9kLFxuICAgICAgICBjb3VudGVycGFydHlIZXhwdWJrZXksXG4gICAgICAgIHZhbHVlLFxuICAgICAgICByZXNvbHZlLFxuICAgICAgICByZWplY3RcbiAgICAgIH0pO1xuICAgICAgaWYgKCF0aGlzLmVuY3J5cHRpb25Qcm9jZXNzaW5nKSB7XG4gICAgICAgIHRoaXMucHJvY2Vzc0VuY3J5cHRpb25RdWV1ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIHByb2Nlc3NFbmNyeXB0aW9uUXVldWUoaXRlbSwgcmV0cmllcyA9IDApIHtcbiAgICBpZiAoIWl0ZW0gJiYgdGhpcy5lbmNyeXB0aW9uUXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLmVuY3J5cHRpb25Qcm9jZXNzaW5nID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZW5jcnlwdGlvblByb2Nlc3NpbmcgPSB0cnVlO1xuICAgIGNvbnN0IHsgc2NoZW1lLCBtZXRob2QsIGNvdW50ZXJwYXJ0eUhleHB1YmtleSwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCB9ID0gaXRlbSB8fCB0aGlzLmVuY3J5cHRpb25RdWV1ZS5zaGlmdCgpO1xuICAgIHRoaXMuZGVidWcoXCJQcm9jZXNzaW5nIGVuY3J5cHRpb24gcXVldWUgaXRlbVwiLCB7XG4gICAgICBtZXRob2QsXG4gICAgICBjb3VudGVycGFydHlIZXhwdWJrZXksXG4gICAgICB2YWx1ZVxuICAgIH0pO1xuICAgIHRyeSB7XG4gICAgICBsZXQgcmVzdWx0ID0gYXdhaXQgd2luZG93Lm5vc3RyW3NjaGVtZV1bbWV0aG9kXShjb3VudGVycGFydHlIZXhwdWJrZXksIHZhbHVlKTtcbiAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yLm1lc3NhZ2UgJiYgZXJyb3IubWVzc2FnZS5pbmNsdWRlcyhcImNhbGwgYWxyZWFkeSBleGVjdXRpbmdcIikpIHtcbiAgICAgICAgaWYgKHJldHJpZXMgPCA1KSB7XG4gICAgICAgICAgdGhpcy5kZWJ1ZyhcIlJldHJ5aW5nIGVuY3J5cHRpb24gcXVldWUgaXRlbVwiLCB7XG4gICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICBjb3VudGVycGFydHlIZXhwdWJrZXksXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIHJldHJpZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc0VuY3J5cHRpb25RdWV1ZShpdGVtLCByZXRyaWVzICsgMSk7XG4gICAgICAgICAgfSwgNTAgKiByZXRyaWVzKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlamVjdChlcnJvcik7XG4gICAgfVxuICAgIHRoaXMucHJvY2Vzc0VuY3J5cHRpb25RdWV1ZSgpO1xuICB9XG4gIHdhaXRGb3JFeHRlbnNpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmICh3aW5kb3cubm9zdHIpIHtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgdGltZXJJZDtcbiAgICAgIGNvbnN0IGludGVydmFsSWQgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgIGlmICh3aW5kb3cubm9zdHIpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbElkKTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgIH0sIDEwMCk7XG4gICAgICB0aW1lcklkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxJZCk7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJOSVAtMDcgZXh0ZW5zaW9uIG5vdCBhdmFpbGFibGVcIikpO1xuICAgICAgfSwgdGhpcy53YWl0VGltZW91dCk7XG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIHNyYy9zaWduZXJzL3ByaXZhdGUta2V5L2luZGV4LnRzXG5pbXBvcnQgeyBnZW5lcmF0ZVNlY3JldEtleSwgZ2V0UHVibGljS2V5LCBmaW5hbGl6ZUV2ZW50LCBuaXAwNCwgbmlwNDQgfSBmcm9tIFwibm9zdHItdG9vbHNcIjtcbmltcG9ydCB7IGJ5dGVzVG9IZXggYXMgYnl0ZXNUb0hleDIsIGhleFRvQnl0ZXMgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy91dGlsc1wiO1xuaW1wb3J0IHsgbmlwMTkgYXMgbmlwMTk2IH0gZnJvbSBcIm5vc3RyLXRvb2xzXCI7XG52YXIgTkRLUHJpdmF0ZUtleVNpZ25lciA9IGNsYXNzIF9OREtQcml2YXRlS2V5U2lnbmVyIHtcbiAgX3VzZXI7XG4gIF9wcml2YXRlS2V5O1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlS2V5KSB7XG4gICAgaWYgKHByaXZhdGVLZXkpIHtcbiAgICAgIGlmICh0eXBlb2YgcHJpdmF0ZUtleSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAocHJpdmF0ZUtleS5zdGFydHNXaXRoKFwibnNlYzFcIikpIHtcbiAgICAgICAgICBjb25zdCB7IHR5cGUsIGRhdGEgfSA9IG5pcDE5Ni5kZWNvZGUocHJpdmF0ZUtleSk7XG4gICAgICAgICAgaWYgKHR5cGUgPT09IFwibnNlY1wiKSB0aGlzLl9wcml2YXRlS2V5ID0gZGF0YTtcbiAgICAgICAgfSBlbHNlIGlmIChwcml2YXRlS2V5Lmxlbmd0aCA9PT0gNjQpIHtcbiAgICAgICAgICB0aGlzLl9wcml2YXRlS2V5ID0gaGV4VG9CeXRlcyhwcml2YXRlS2V5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHByaXZhdGUga2V5IHByb3ZpZGVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZUtleSA9IHByaXZhdGVLZXk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fcHJpdmF0ZUtleSkge1xuICAgICAgICB0aGlzLl91c2VyID0gbmV3IE5ES1VzZXIoe1xuICAgICAgICAgIHB1YmtleTogZ2V0UHVibGljS2V5KHRoaXMuX3ByaXZhdGVLZXkpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXQgcHJpdmF0ZUtleSgpIHtcbiAgICBpZiAoIXRoaXMuX3ByaXZhdGVLZXkpIHJldHVybiB2b2lkIDA7XG4gICAgcmV0dXJuIGJ5dGVzVG9IZXgyKHRoaXMuX3ByaXZhdGVLZXkpO1xuICB9XG4gIHN0YXRpYyBnZW5lcmF0ZSgpIHtcbiAgICBjb25zdCBwcml2YXRlS2V5ID0gZ2VuZXJhdGVTZWNyZXRLZXkoKTtcbiAgICByZXR1cm4gbmV3IF9OREtQcml2YXRlS2V5U2lnbmVyKHByaXZhdGVLZXkpO1xuICB9XG4gIGFzeW5jIGJsb2NrVW50aWxSZWFkeSgpIHtcbiAgICBpZiAoIXRoaXMuX3VzZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5ES1VzZXIgbm90IGluaXRpYWxpemVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdXNlcjtcbiAgfVxuICBhc3luYyB1c2VyKCkge1xuICAgIGF3YWl0IHRoaXMuYmxvY2tVbnRpbFJlYWR5KCk7XG4gICAgcmV0dXJuIHRoaXMuX3VzZXI7XG4gIH1cbiAgYXN5bmMgc2lnbihldmVudCkge1xuICAgIGlmICghdGhpcy5fcHJpdmF0ZUtleSkge1xuICAgICAgdGhyb3cgRXJyb3IoXCJBdHRlbXB0ZWQgdG8gc2lnbiB3aXRob3V0IGEgcHJpdmF0ZSBrZXlcIik7XG4gICAgfVxuICAgIHJldHVybiBmaW5hbGl6ZUV2ZW50KGV2ZW50LCB0aGlzLl9wcml2YXRlS2V5KS5zaWc7XG4gIH1cbiAgYXN5bmMgZW5jcnlwdGlvbkVuYWJsZWQoc2NoZW1lKSB7XG4gICAgbGV0IGVuYWJsZWQgPSBbXTtcbiAgICBpZiAoIXNjaGVtZSB8fCBzY2hlbWUgPT0gXCJuaXAwNFwiKSBlbmFibGVkLnB1c2goXCJuaXAwNFwiKTtcbiAgICBpZiAoIXNjaGVtZSB8fCBzY2hlbWUgPT0gXCJuaXA0NFwiKSBlbmFibGVkLnB1c2goXCJuaXA0NFwiKTtcbiAgICByZXR1cm4gZW5hYmxlZDtcbiAgfVxuICBhc3luYyBlbmNyeXB0KHJlY2lwaWVudCwgdmFsdWUsIHNjaGVtZSkge1xuICAgIGlmICghdGhpcy5fcHJpdmF0ZUtleSB8fCAhdGhpcy5wcml2YXRlS2V5KSB7XG4gICAgICB0aHJvdyBFcnJvcihcIkF0dGVtcHRlZCB0byBlbmNyeXB0IHdpdGhvdXQgYSBwcml2YXRlIGtleVwiKTtcbiAgICB9XG4gICAgY29uc3QgcmVjaXBpZW50SGV4UHViS2V5ID0gcmVjaXBpZW50LnB1YmtleTtcbiAgICBpZiAoc2NoZW1lID09IFwibmlwNDRcIikge1xuICAgICAgbGV0IGNvbnZlcnNhdGlvbktleSA9IG5pcDQ0LnYyLnV0aWxzLmdldENvbnZlcnNhdGlvbktleSh0aGlzLl9wcml2YXRlS2V5LCByZWNpcGllbnRIZXhQdWJLZXkpO1xuICAgICAgcmV0dXJuIGF3YWl0IG5pcDQ0LnYyLmVuY3J5cHQodmFsdWUsIGNvbnZlcnNhdGlvbktleSk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCBuaXAwNC5lbmNyeXB0KHRoaXMuX3ByaXZhdGVLZXksIHJlY2lwaWVudEhleFB1YktleSwgdmFsdWUpO1xuICB9XG4gIGFzeW5jIGRlY3J5cHQoc2VuZGVyLCB2YWx1ZSwgc2NoZW1lKSB7XG4gICAgaWYgKCF0aGlzLl9wcml2YXRlS2V5IHx8ICF0aGlzLnByaXZhdGVLZXkpIHtcbiAgICAgIHRocm93IEVycm9yKFwiQXR0ZW1wdGVkIHRvIGRlY3J5cHQgd2l0aG91dCBhIHByaXZhdGUga2V5XCIpO1xuICAgIH1cbiAgICBjb25zdCBzZW5kZXJIZXhQdWJLZXkgPSBzZW5kZXIucHVia2V5O1xuICAgIGlmIChzY2hlbWUgPT0gXCJuaXA0NFwiKSB7XG4gICAgICBsZXQgY29udmVyc2F0aW9uS2V5ID0gbmlwNDQudjIudXRpbHMuZ2V0Q29udmVyc2F0aW9uS2V5KHRoaXMuX3ByaXZhdGVLZXksIHNlbmRlckhleFB1YktleSk7XG4gICAgICByZXR1cm4gYXdhaXQgbmlwNDQudjIuZGVjcnlwdCh2YWx1ZSwgY29udmVyc2F0aW9uS2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IG5pcDA0LmRlY3J5cHQodGhpcy5fcHJpdmF0ZUtleSwgc2VuZGVySGV4UHViS2V5LCB2YWx1ZSk7XG4gIH1cbn07XG5cbi8vIHNyYy9zaWduZXJzL25pcDQ2L3JwYy50c1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIGFzIEV2ZW50RW1pdHRlcjUgfSBmcm9tIFwidHNlZXBcIjtcbnZhciBOREtOb3N0clJwYyA9IGNsYXNzIGV4dGVuZHMgRXZlbnRFbWl0dGVyNSB7XG4gIG5kaztcbiAgc2lnbmVyO1xuICByZWxheVNldDtcbiAgZGVidWc7XG4gIGVuY3J5cHRpb25UeXBlID0gXCJuaXAwNFwiO1xuICBwb29sO1xuICBjb25zdHJ1Y3RvcihuZGssIHNpZ25lciwgZGVidWc4LCByZWxheVVybHMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubmRrID0gbmRrO1xuICAgIHRoaXMuc2lnbmVyID0gc2lnbmVyO1xuICAgIGlmIChyZWxheVVybHMpIHtcbiAgICAgIHRoaXMucG9vbCA9IG5ldyBOREtQb29sKFxuICAgICAgICByZWxheVVybHMsXG4gICAgICAgIFtdLFxuICAgICAgICBuZGssXG4gICAgICAgIHtcbiAgICAgICAgICBkZWJ1ZzogZGVidWc4LmV4dGVuZChcInJwYy1wb29sXCIpLFxuICAgICAgICAgIG5hbWU6IFwiTm9zdHIgUlBDXCJcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIHRoaXMucmVsYXlTZXQgPSBuZXcgTkRLUmVsYXlTZXQoLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSwgbmRrLCB0aGlzLnBvb2wpO1xuICAgICAgZm9yIChjb25zdCB1cmwgb2YgcmVsYXlVcmxzKSB7XG4gICAgICAgIGNvbnN0IHJlbGF5ID0gdGhpcy5wb29sLmdldFJlbGF5KHVybCwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgcmVsYXkuYXV0aFBvbGljeSA9IE5ES1JlbGF5QXV0aFBvbGljaWVzLnNpZ25Jbih7IG5kaywgc2lnbmVyLCBkZWJ1ZzogZGVidWc4IH0pO1xuICAgICAgICB0aGlzLnJlbGF5U2V0LmFkZFJlbGF5KHJlbGF5KTtcbiAgICAgICAgcmVsYXkuY29ubmVjdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmRlYnVnID0gZGVidWc4LmV4dGVuZChcInJwY1wiKTtcbiAgfVxuICAvKipcbiAgICogU3Vic2NyaWJlIHRvIGEgZmlsdGVyLiBUaGlzIGZ1bmN0aW9uIHdpbGwgcmVzb2x2ZSBvbmNlIHRoZSBzdWJzY3JpcHRpb24gaXMgcmVhZHkuXG4gICAqL1xuICBzdWJzY3JpYmUoZmlsdGVyKSB7XG4gICAgY29uc3Qgc3ViID0gdGhpcy5uZGsuc3Vic2NyaWJlKFxuICAgICAgZmlsdGVyLFxuICAgICAge1xuICAgICAgICBjbG9zZU9uRW9zZTogZmFsc2UsXG4gICAgICAgIGdyb3VwYWJsZTogZmFsc2UsXG4gICAgICAgIGNhY2hlVXNhZ2U6IFwiT05MWV9SRUxBWVwiIC8qIE9OTFlfUkVMQVkgKi8sXG4gICAgICAgIHBvb2w6IHRoaXMucG9vbFxuICAgICAgfSxcbiAgICAgIHRoaXMucmVsYXlTZXQsXG4gICAgICBmYWxzZVxuICAgICk7XG4gICAgc3ViLm9uKFwiZXZlbnRcIiwgYXN5bmMgKGV2ZW50KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBwYXJzZWRFdmVudCA9IGF3YWl0IHRoaXMucGFyc2VFdmVudChldmVudCk7XG4gICAgICAgIGlmIChwYXJzZWRFdmVudC5tZXRob2QpIHtcbiAgICAgICAgICB0aGlzLmVtaXQoXCJyZXF1ZXN0XCIsIHBhcnNlZEV2ZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmVtaXQoYHJlc3BvbnNlLSR7cGFyc2VkRXZlbnQuaWR9YCwgcGFyc2VkRXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRoaXMuZGVidWcoXCJlcnJvciBwYXJzaW5nIGV2ZW50XCIsIGUsIGV2ZW50LnJhd0V2ZW50KCkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgc3ViLm9uKFwiZW9zZVwiLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuZGVidWcoXCJlb3NlZFwiKTtcbiAgICAgICAgcmVzb2x2ZShzdWIpO1xuICAgICAgfSk7XG4gICAgICBzdWIuc3RhcnQoKTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBwYXJzZUV2ZW50KGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuZW5jcnlwdGlvblR5cGUgPT09IFwibmlwNDRcIiAmJiBldmVudC5jb250ZW50LmluY2x1ZGVzKFwiP2l2PVwiKSkge1xuICAgICAgdGhpcy5lbmNyeXB0aW9uVHlwZSA9IFwibmlwMDRcIjtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZW5jcnlwdGlvblR5cGUgPT09IFwibmlwMDRcIiAmJiAhZXZlbnQuY29udGVudC5pbmNsdWRlcyhcIj9pdj1cIikpIHtcbiAgICAgIHRoaXMuZW5jcnlwdGlvblR5cGUgPSBcIm5pcDQ0XCI7XG4gICAgfVxuICAgIGNvbnN0IHJlbW90ZVVzZXIgPSB0aGlzLm5kay5nZXRVc2VyKHsgcHVia2V5OiBldmVudC5wdWJrZXkgfSk7XG4gICAgcmVtb3RlVXNlci5uZGsgPSB0aGlzLm5kaztcbiAgICBsZXQgZGVjcnlwdGVkQ29udGVudDtcbiAgICB0cnkge1xuICAgICAgZGVjcnlwdGVkQ29udGVudCA9IGF3YWl0IHRoaXMuc2lnbmVyLmRlY3J5cHQoXG4gICAgICAgIHJlbW90ZVVzZXIsXG4gICAgICAgIGV2ZW50LmNvbnRlbnQsXG4gICAgICAgIHRoaXMuZW5jcnlwdGlvblR5cGVcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc3Qgb3RoZXJFbmNyeXB0aW9uVHlwZSA9IHRoaXMuZW5jcnlwdGlvblR5cGUgPT09IFwibmlwMDRcIiA/IFwibmlwNDRcIiA6IFwibmlwMDRcIjtcbiAgICAgIGRlY3J5cHRlZENvbnRlbnQgPSBhd2FpdCB0aGlzLnNpZ25lci5kZWNyeXB0KHJlbW90ZVVzZXIsIGV2ZW50LmNvbnRlbnQsIG90aGVyRW5jcnlwdGlvblR5cGUpO1xuICAgICAgdGhpcy5lbmNyeXB0aW9uVHlwZSA9IG90aGVyRW5jcnlwdGlvblR5cGU7XG4gICAgfVxuICAgIGNvbnN0IHBhcnNlZENvbnRlbnQgPSBKU09OLnBhcnNlKGRlY3J5cHRlZENvbnRlbnQpO1xuICAgIGNvbnN0IHsgaWQsIG1ldGhvZCwgcGFyYW1zLCByZXN1bHQsIGVycm9yIH0gPSBwYXJzZWRDb250ZW50O1xuICAgIGlmIChtZXRob2QpIHtcbiAgICAgIHJldHVybiB7IGlkLCBwdWJrZXk6IGV2ZW50LnB1YmtleSwgbWV0aG9kLCBwYXJhbXMsIGV2ZW50IH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7IGlkLCByZXN1bHQsIGVycm9yLCBldmVudCB9O1xuICAgIH1cbiAgfVxuICBhc3luYyBzZW5kUmVzcG9uc2UoaWQsIHJlbW90ZVB1YmtleSwgcmVzdWx0LCBraW5kID0gMjQxMzMgLyogTm9zdHJDb25uZWN0ICovLCBlcnJvcikge1xuICAgIGNvbnN0IHJlcyA9IHsgaWQsIHJlc3VsdCB9O1xuICAgIGlmIChlcnJvcikge1xuICAgICAgcmVzLmVycm9yID0gZXJyb3I7XG4gICAgfVxuICAgIGNvbnN0IGxvY2FsVXNlciA9IGF3YWl0IHRoaXMuc2lnbmVyLnVzZXIoKTtcbiAgICBjb25zdCByZW1vdGVVc2VyID0gdGhpcy5uZGsuZ2V0VXNlcih7IHB1YmtleTogcmVtb3RlUHVia2V5IH0pO1xuICAgIGNvbnN0IGV2ZW50ID0gbmV3IE5ES0V2ZW50KHRoaXMubmRrLCB7XG4gICAgICBraW5kLFxuICAgICAgY29udGVudDogSlNPTi5zdHJpbmdpZnkocmVzKSxcbiAgICAgIHRhZ3M6IFtbXCJwXCIsIHJlbW90ZVB1YmtleV1dLFxuICAgICAgcHVia2V5OiBsb2NhbFVzZXIucHVia2V5XG4gICAgfSk7XG4gICAgZXZlbnQuY29udGVudCA9IGF3YWl0IHRoaXMuc2lnbmVyLmVuY3J5cHQocmVtb3RlVXNlciwgZXZlbnQuY29udGVudCwgdGhpcy5lbmNyeXB0aW9uVHlwZSk7XG4gICAgYXdhaXQgZXZlbnQuc2lnbih0aGlzLnNpZ25lcik7XG4gICAgYXdhaXQgZXZlbnQucHVibGlzaCh0aGlzLnJlbGF5U2V0KTtcbiAgfVxuICAvKipcbiAgICogU2VuZHMgYSByZXF1ZXN0LlxuICAgKiBAcGFyYW0gcmVtb3RlUHVia2V5XG4gICAqIEBwYXJhbSBtZXRob2RcbiAgICogQHBhcmFtIHBhcmFtc1xuICAgKiBAcGFyYW0ga2luZFxuICAgKiBAcGFyYW0gaWRcbiAgICovXG4gIGFzeW5jIHNlbmRSZXF1ZXN0KHJlbW90ZVB1YmtleSwgbWV0aG9kLCBwYXJhbXMgPSBbXSwga2luZCA9IDI0MTMzLCBjYikge1xuICAgIGNvbnN0IGlkID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDcpO1xuICAgIGNvbnN0IGxvY2FsVXNlciA9IGF3YWl0IHRoaXMuc2lnbmVyLnVzZXIoKTtcbiAgICBjb25zdCByZW1vdGVVc2VyID0gdGhpcy5uZGsuZ2V0VXNlcih7IHB1YmtleTogcmVtb3RlUHVia2V5IH0pO1xuICAgIGNvbnN0IHJlcXVlc3QgPSB7IGlkLCBtZXRob2QsIHBhcmFtcyB9O1xuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgoKSA9PiB7XG4gICAgICBjb25zdCByZXNwb25zZUhhbmRsZXIgPSAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnJlc3VsdCA9PT0gXCJhdXRoX3VybFwiKSB7XG4gICAgICAgICAgdGhpcy5vbmNlKGByZXNwb25zZS0ke2lkfWAsIHJlc3BvbnNlSGFuZGxlcik7XG4gICAgICAgICAgdGhpcy5lbWl0KFwiYXV0aFVybFwiLCByZXNwb25zZS5lcnJvcik7XG4gICAgICAgIH0gZWxzZSBpZiAoY2IpIHtcbiAgICAgICAgICBjYihyZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLm9uY2UoYHJlc3BvbnNlLSR7aWR9YCwgcmVzcG9uc2VIYW5kbGVyKTtcbiAgICB9KTtcbiAgICBjb25zdCBldmVudCA9IG5ldyBOREtFdmVudCh0aGlzLm5kaywge1xuICAgICAga2luZCxcbiAgICAgIGNvbnRlbnQ6IEpTT04uc3RyaW5naWZ5KHJlcXVlc3QpLFxuICAgICAgdGFnczogW1tcInBcIiwgcmVtb3RlUHVia2V5XV0sXG4gICAgICBwdWJrZXk6IGxvY2FsVXNlci5wdWJrZXlcbiAgICB9KTtcbiAgICBldmVudC5jb250ZW50ID0gYXdhaXQgdGhpcy5zaWduZXIuZW5jcnlwdChyZW1vdGVVc2VyLCBldmVudC5jb250ZW50LCB0aGlzLmVuY3J5cHRpb25UeXBlKTtcbiAgICBhd2FpdCBldmVudC5zaWduKHRoaXMuc2lnbmVyKTtcbiAgICBhd2FpdCBldmVudC5wdWJsaXNoKHRoaXMucmVsYXlTZXQpO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG59O1xuXG4vLyBzcmMvc2lnbmVycy9uaXA0Ni9iYWNrZW5kL3BpbmcudHNcbnZhciBQaW5nRXZlbnRIYW5kbGluZ1N0cmF0ZWd5ID0gY2xhc3Mge1xuICBhc3luYyBoYW5kbGUoYmFja2VuZCwgaWQsIHJlbW90ZVB1YmtleSwgcGFyYW1zKSB7XG4gICAgY29uc3QgZGVidWc4ID0gYmFja2VuZC5kZWJ1Zy5leHRlbmQoXCJwaW5nXCIpO1xuICAgIGRlYnVnOChgcGluZyByZXF1ZXN0IGZyb20gJHtyZW1vdGVQdWJrZXl9YCk7XG4gICAgaWYgKGF3YWl0IGJhY2tlbmQucHVia2V5QWxsb3dlZCh7IGlkLCBwdWJrZXk6IHJlbW90ZVB1YmtleSwgbWV0aG9kOiBcInBpbmdcIiB9KSkge1xuICAgICAgZGVidWc4KGBjb25uZWN0aW9uIHJlcXVlc3QgZnJvbSAke3JlbW90ZVB1YmtleX0gYWxsb3dlZGApO1xuICAgICAgcmV0dXJuIFwicG9uZ1wiO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1ZzgoYGNvbm5lY3Rpb24gcmVxdWVzdCBmcm9tICR7cmVtb3RlUHVia2V5fSByZWplY3RlZGApO1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG59O1xuXG4vLyBzcmMvc2lnbmVycy9uaXA0Ni9iYWNrZW5kL2Nvbm5lY3QudHNcbnZhciBDb25uZWN0RXZlbnRIYW5kbGluZ1N0cmF0ZWd5ID0gY2xhc3Mge1xuICBhc3luYyBoYW5kbGUoYmFja2VuZCwgaWQsIHJlbW90ZVB1YmtleSwgcGFyYW1zKSB7XG4gICAgY29uc3QgW18sIHRva2VuXSA9IHBhcmFtcztcbiAgICBjb25zdCBkZWJ1ZzggPSBiYWNrZW5kLmRlYnVnLmV4dGVuZChcImNvbm5lY3RcIik7XG4gICAgZGVidWc4KGBjb25uZWN0aW9uIHJlcXVlc3QgZnJvbSAke3JlbW90ZVB1YmtleX1gKTtcbiAgICBpZiAodG9rZW4gJiYgYmFja2VuZC5hcHBseVRva2VuKSB7XG4gICAgICBkZWJ1ZzgoYGFwcGx5aW5nIHRva2VuYCk7XG4gICAgICBhd2FpdCBiYWNrZW5kLmFwcGx5VG9rZW4ocmVtb3RlUHVia2V5LCB0b2tlbik7XG4gICAgfVxuICAgIGlmIChhd2FpdCBiYWNrZW5kLnB1YmtleUFsbG93ZWQoe1xuICAgICAgaWQsXG4gICAgICBwdWJrZXk6IHJlbW90ZVB1YmtleSxcbiAgICAgIG1ldGhvZDogXCJjb25uZWN0XCIsXG4gICAgICBwYXJhbXM6IHRva2VuXG4gICAgfSkpIHtcbiAgICAgIGRlYnVnOChgY29ubmVjdGlvbiByZXF1ZXN0IGZyb20gJHtyZW1vdGVQdWJrZXl9IGFsbG93ZWRgKTtcbiAgICAgIHJldHVybiBcImFja1wiO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1ZzgoYGNvbm5lY3Rpb24gcmVxdWVzdCBmcm9tICR7cmVtb3RlUHVia2V5fSByZWplY3RlZGApO1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG59O1xuXG4vLyBzcmMvc2lnbmVycy9uaXA0Ni9iYWNrZW5kL2dldC1wdWJsaWMta2V5LnRzXG52YXIgR2V0UHVibGljS2V5SGFuZGxpbmdTdHJhdGVneSA9IGNsYXNzIHtcbiAgYXN5bmMgaGFuZGxlKGJhY2tlbmQsIGlkLCByZW1vdGVQdWJrZXksIHBhcmFtcykge1xuICAgIHJldHVybiBiYWNrZW5kLmxvY2FsVXNlcj8ucHVia2V5O1xuICB9XG59O1xuXG4vLyBzcmMvc2lnbmVycy9uaXA0Ni9iYWNrZW5kL25pcDA0LWRlY3J5cHQudHNcbnZhciBOaXAwNERlY3J5cHRIYW5kbGluZ1N0cmF0ZWd5ID0gY2xhc3Mge1xuICBhc3luYyBoYW5kbGUoYmFja2VuZCwgaWQsIHJlbW90ZVB1YmtleSwgcGFyYW1zKSB7XG4gICAgY29uc3QgW3NlbmRlclB1YmtleSwgcGF5bG9hZF0gPSBwYXJhbXM7XG4gICAgY29uc3Qgc2VuZGVyVXNlciA9IG5ldyBOREtVc2VyKHsgcHVia2V5OiBzZW5kZXJQdWJrZXkgfSk7XG4gICAgY29uc3QgZGVjcnlwdGVkUGF5bG9hZCA9IGF3YWl0IGRlY3J5cHQyKGJhY2tlbmQsIGlkLCByZW1vdGVQdWJrZXksIHNlbmRlclVzZXIsIHBheWxvYWQpO1xuICAgIHJldHVybiBkZWNyeXB0ZWRQYXlsb2FkO1xuICB9XG59O1xuYXN5bmMgZnVuY3Rpb24gZGVjcnlwdDIoYmFja2VuZCwgaWQsIHJlbW90ZVB1YmtleSwgc2VuZGVyVXNlciwgcGF5bG9hZCkge1xuICBpZiAoIWF3YWl0IGJhY2tlbmQucHVia2V5QWxsb3dlZCh7XG4gICAgaWQsXG4gICAgcHVia2V5OiByZW1vdGVQdWJrZXksXG4gICAgbWV0aG9kOiBcIm5pcDA0X2RlY3J5cHRcIixcbiAgICBwYXJhbXM6IHBheWxvYWRcbiAgfSkpIHtcbiAgICBiYWNrZW5kLmRlYnVnKGBkZWNyeXB0IHJlcXVlc3QgZnJvbSAke3JlbW90ZVB1YmtleX0gcmVqZWN0ZWRgKTtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHJldHVybiBhd2FpdCBiYWNrZW5kLnNpZ25lci5kZWNyeXB0KHNlbmRlclVzZXIsIHBheWxvYWQsIFwibmlwMDRcIik7XG59XG5cbi8vIHNyYy9zaWduZXJzL25pcDQ2L2JhY2tlbmQvbmlwMDQtZW5jcnlwdC50c1xudmFyIE5pcDA0RW5jcnlwdEhhbmRsaW5nU3RyYXRlZ3kgPSBjbGFzcyB7XG4gIGFzeW5jIGhhbmRsZShiYWNrZW5kLCBpZCwgcmVtb3RlUHVia2V5LCBwYXJhbXMpIHtcbiAgICBjb25zdCBbcmVjaXBpZW50UHVia2V5LCBwYXlsb2FkXSA9IHBhcmFtcztcbiAgICBjb25zdCByZWNpcGllbnRVc2VyID0gbmV3IE5ES1VzZXIoeyBwdWJrZXk6IHJlY2lwaWVudFB1YmtleSB9KTtcbiAgICBjb25zdCBlbmNyeXB0ZWRQYXlsb2FkID0gYXdhaXQgZW5jcnlwdDIoYmFja2VuZCwgaWQsIHJlbW90ZVB1YmtleSwgcmVjaXBpZW50VXNlciwgcGF5bG9hZCk7XG4gICAgcmV0dXJuIGVuY3J5cHRlZFBheWxvYWQ7XG4gIH1cbn07XG5hc3luYyBmdW5jdGlvbiBlbmNyeXB0MihiYWNrZW5kLCBpZCwgcmVtb3RlUHVia2V5LCByZWNpcGllbnRVc2VyLCBwYXlsb2FkKSB7XG4gIGlmICghYXdhaXQgYmFja2VuZC5wdWJrZXlBbGxvd2VkKHtcbiAgICBpZCxcbiAgICBwdWJrZXk6IHJlbW90ZVB1YmtleSxcbiAgICBtZXRob2Q6IFwibmlwMDRfZW5jcnlwdFwiLFxuICAgIHBhcmFtczogcGF5bG9hZFxuICB9KSkge1xuICAgIGJhY2tlbmQuZGVidWcoYGVuY3J5cHQgcmVxdWVzdCBmcm9tICR7cmVtb3RlUHVia2V5fSByZWplY3RlZGApO1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIGF3YWl0IGJhY2tlbmQuc2lnbmVyLmVuY3J5cHQocmVjaXBpZW50VXNlciwgcGF5bG9hZCwgXCJuaXAwNFwiKTtcbn1cblxuLy8gc3JjL3NpZ25lcnMvbmlwNDYvYmFja2VuZC9zaWduLWV2ZW50LnRzXG52YXIgU2lnbkV2ZW50SGFuZGxpbmdTdHJhdGVneSA9IGNsYXNzIHtcbiAgYXN5bmMgaGFuZGxlKGJhY2tlbmQsIGlkLCByZW1vdGVQdWJrZXksIHBhcmFtcykge1xuICAgIGNvbnN0IGV2ZW50ID0gYXdhaXQgc2lnbkV2ZW50KGJhY2tlbmQsIGlkLCByZW1vdGVQdWJrZXksIHBhcmFtcyk7XG4gICAgaWYgKCFldmVudCkgcmV0dXJuIHZvaWQgMDtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXdhaXQgZXZlbnQudG9Ob3N0ckV2ZW50KCkpO1xuICB9XG59O1xuYXN5bmMgZnVuY3Rpb24gc2lnbkV2ZW50KGJhY2tlbmQsIGlkLCByZW1vdGVQdWJrZXksIHBhcmFtcykge1xuICBjb25zdCBbZXZlbnRTdHJpbmddID0gcGFyYW1zO1xuICBiYWNrZW5kLmRlYnVnKGBzaWduIGV2ZW50IHJlcXVlc3QgZnJvbSAke3JlbW90ZVB1YmtleX1gKTtcbiAgY29uc3QgZXZlbnQgPSBuZXcgTkRLRXZlbnQoYmFja2VuZC5uZGssIEpTT04ucGFyc2UoZXZlbnRTdHJpbmcpKTtcbiAgYmFja2VuZC5kZWJ1ZyhcImV2ZW50IHRvIHNpZ25cIiwgZXZlbnQucmF3RXZlbnQoKSk7XG4gIGlmICghYXdhaXQgYmFja2VuZC5wdWJrZXlBbGxvd2VkKHtcbiAgICBpZCxcbiAgICBwdWJrZXk6IHJlbW90ZVB1YmtleSxcbiAgICBtZXRob2Q6IFwic2lnbl9ldmVudFwiLFxuICAgIHBhcmFtczogZXZlbnRcbiAgfSkpIHtcbiAgICBiYWNrZW5kLmRlYnVnKGBzaWduIGV2ZW50IHJlcXVlc3QgZnJvbSAke3JlbW90ZVB1YmtleX0gcmVqZWN0ZWRgKTtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGJhY2tlbmQuZGVidWcoYHNpZ24gZXZlbnQgcmVxdWVzdCBmcm9tICR7cmVtb3RlUHVia2V5fSBhbGxvd2VkYCk7XG4gIGF3YWl0IGV2ZW50LnNpZ24oYmFja2VuZC5zaWduZXIpO1xuICByZXR1cm4gZXZlbnQ7XG59XG5cbi8vIHNyYy9zaWduZXJzL25pcDQ2L2JhY2tlbmQvbmlwNDQtZW5jcnlwdC50c1xudmFyIE5pcDA0RW5jcnlwdEhhbmRsaW5nU3RyYXRlZ3kyID0gY2xhc3Mge1xuICBhc3luYyBoYW5kbGUoYmFja2VuZCwgaWQsIHJlbW90ZVB1YmtleSwgcGFyYW1zKSB7XG4gICAgY29uc3QgW3JlY2lwaWVudFB1YmtleSwgcGF5bG9hZF0gPSBwYXJhbXM7XG4gICAgY29uc3QgcmVjaXBpZW50VXNlciA9IG5ldyBOREtVc2VyKHsgcHVia2V5OiByZWNpcGllbnRQdWJrZXkgfSk7XG4gICAgY29uc3QgZW5jcnlwdGVkUGF5bG9hZCA9IGF3YWl0IGVuY3J5cHQzKGJhY2tlbmQsIGlkLCByZW1vdGVQdWJrZXksIHJlY2lwaWVudFVzZXIsIHBheWxvYWQpO1xuICAgIHJldHVybiBlbmNyeXB0ZWRQYXlsb2FkO1xuICB9XG59O1xuYXN5bmMgZnVuY3Rpb24gZW5jcnlwdDMoYmFja2VuZCwgaWQsIHJlbW90ZVB1YmtleSwgcmVjaXBpZW50VXNlciwgcGF5bG9hZCkge1xuICBpZiAoIWF3YWl0IGJhY2tlbmQucHVia2V5QWxsb3dlZCh7XG4gICAgaWQsXG4gICAgcHVia2V5OiByZW1vdGVQdWJrZXksXG4gICAgbWV0aG9kOiBcIm5pcDQ0X2VuY3J5cHRcIixcbiAgICBwYXJhbXM6IHBheWxvYWRcbiAgfSkpIHtcbiAgICBiYWNrZW5kLmRlYnVnKGBlbmNyeXB0IHJlcXVlc3QgZnJvbSAke3JlbW90ZVB1YmtleX0gcmVqZWN0ZWRgKTtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHJldHVybiBhd2FpdCBiYWNrZW5kLnNpZ25lci5lbmNyeXB0KHJlY2lwaWVudFVzZXIsIHBheWxvYWQsIFwibmlwNDRcIik7XG59XG5cbi8vIHNyYy9zaWduZXJzL25pcDQ2L2JhY2tlbmQvbmlwNDQtZGVjcnlwdC50c1xudmFyIE5pcDA0RGVjcnlwdEhhbmRsaW5nU3RyYXRlZ3kyID0gY2xhc3Mge1xuICBhc3luYyBoYW5kbGUoYmFja2VuZCwgaWQsIHJlbW90ZVB1YmtleSwgcGFyYW1zKSB7XG4gICAgY29uc3QgW3NlbmRlclB1YmtleSwgcGF5bG9hZF0gPSBwYXJhbXM7XG4gICAgY29uc3Qgc2VuZGVyVXNlciA9IG5ldyBOREtVc2VyKHsgcHVia2V5OiBzZW5kZXJQdWJrZXkgfSk7XG4gICAgY29uc3QgZGVjcnlwdGVkUGF5bG9hZCA9IGF3YWl0IGRlY3J5cHQzKGJhY2tlbmQsIGlkLCByZW1vdGVQdWJrZXksIHNlbmRlclVzZXIsIHBheWxvYWQpO1xuICAgIHJldHVybiBkZWNyeXB0ZWRQYXlsb2FkO1xuICB9XG59O1xuYXN5bmMgZnVuY3Rpb24gZGVjcnlwdDMoYmFja2VuZCwgaWQsIHJlbW90ZVB1YmtleSwgc2VuZGVyVXNlciwgcGF5bG9hZCkge1xuICBpZiAoIWF3YWl0IGJhY2tlbmQucHVia2V5QWxsb3dlZCh7XG4gICAgaWQsXG4gICAgcHVia2V5OiByZW1vdGVQdWJrZXksXG4gICAgbWV0aG9kOiBcIm5pcDQ0X2RlY3J5cHRcIixcbiAgICBwYXJhbXM6IHBheWxvYWRcbiAgfSkpIHtcbiAgICBiYWNrZW5kLmRlYnVnKGBkZWNyeXB0IHJlcXVlc3QgZnJvbSAke3JlbW90ZVB1YmtleX0gcmVqZWN0ZWRgKTtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHJldHVybiBhd2FpdCBiYWNrZW5kLnNpZ25lci5kZWNyeXB0KHNlbmRlclVzZXIsIHBheWxvYWQsIFwibmlwNDRcIik7XG59XG5cbi8vIHNyYy9zaWduZXJzL25pcDQ2L2JhY2tlbmQvaW5kZXgudHNcbmltcG9ydCB7IGhleFRvQnl0ZXMgYXMgaGV4VG9CeXRlczIgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy91dGlsc1wiO1xudmFyIE5ES05pcDQ2QmFja2VuZCA9IGNsYXNzIHtcbiAgbmRrO1xuICBzaWduZXI7XG4gIGxvY2FsVXNlcjtcbiAgZGVidWc7XG4gIHJwYztcbiAgcGVybWl0Q2FsbGJhY2s7XG4gIHJlbGF5VXJscztcbiAgLyoqXG4gICAqIEBwYXJhbSBuZGsgVGhlIE5ESyBpbnN0YW5jZSB0byB1c2VcbiAgICogQHBhcmFtIHByaXZhdGVLZXlPclNpZ25lciBUaGUgcHJpdmF0ZSBrZXkgb3Igc2lnbmVyIG9mIHRoZSBucHViIHRoYXQgd2FudHMgdG8gYmUgcHVibGlzaGVkIGFzXG4gICAqIEBwYXJhbSBwZXJtaXRDYWxsYmFjayBDYWxsYmFjayBleGVjdXRlZCB3aGVuIHBlcm1pc3Npb24gaXMgcmVxdWVzdGVkXG4gICAqL1xuICBjb25zdHJ1Y3RvcihuZGssIHByaXZhdGVLZXlPclNpZ25lciwgcGVybWl0Q2FsbGJhY2ssIHJlbGF5VXJscykge1xuICAgIHRoaXMubmRrID0gbmRrO1xuICAgIGlmIChwcml2YXRlS2V5T3JTaWduZXIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICB0aGlzLnNpZ25lciA9IG5ldyBOREtQcml2YXRlS2V5U2lnbmVyKHByaXZhdGVLZXlPclNpZ25lcik7XG4gICAgfSBlbHNlIGlmIChwcml2YXRlS2V5T3JTaWduZXIgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAgIHRoaXMuc2lnbmVyID0gbmV3IE5ES1ByaXZhdGVLZXlTaWduZXIoaGV4VG9CeXRlczIocHJpdmF0ZUtleU9yU2lnbmVyKSk7XG4gICAgfSBlbHNlIGlmIChwcml2YXRlS2V5T3JTaWduZXIgaW5zdGFuY2VvZiBOREtQcml2YXRlS2V5U2lnbmVyKSB7XG4gICAgICB0aGlzLnNpZ25lciA9IHByaXZhdGVLZXlPclNpZ25lcjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzaWduZXJcIik7XG4gICAgfVxuICAgIHRoaXMuZGVidWcgPSBuZGsuZGVidWcuZXh0ZW5kKFwibmlwNDY6YmFja2VuZFwiKTtcbiAgICB0aGlzLnJlbGF5VXJscyA9IHJlbGF5VXJscyA/PyBBcnJheS5mcm9tKG5kay5wb29sLnJlbGF5cy5rZXlzKCkpO1xuICAgIHRoaXMucnBjID0gbmV3IE5ES05vc3RyUnBjKG5kaywgdGhpcy5zaWduZXIsIHRoaXMuZGVidWcsIHRoaXMucmVsYXlVcmxzKTtcbiAgICB0aGlzLnBlcm1pdENhbGxiYWNrID0gcGVybWl0Q2FsbGJhY2s7XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHN0YXJ0cyB0aGUgYmFja2VuZCwgd2hpY2ggd2lsbCBzdGFydCBsaXN0ZW5pbmcgZm9yIGluY29taW5nXG4gICAqIHJlcXVlc3RzLlxuICAgKi9cbiAgYXN5bmMgc3RhcnQoKSB7XG4gICAgdGhpcy5sb2NhbFVzZXIgPSBhd2FpdCB0aGlzLnNpZ25lci51c2VyKCk7XG4gICAgY29uc3Qgc3ViID0gdGhpcy5uZGsuc3Vic2NyaWJlKFxuICAgICAge1xuICAgICAgICBraW5kczogWzI0MTMzXSxcbiAgICAgICAgXCIjcFwiOiBbdGhpcy5sb2NhbFVzZXIucHVia2V5XVxuICAgICAgfSxcbiAgICAgIHsgY2xvc2VPbkVvc2U6IGZhbHNlIH1cbiAgICApO1xuICAgIHN1Yi5vbihcImV2ZW50XCIsIChlKSA9PiB0aGlzLmhhbmRsZUluY29taW5nRXZlbnQoZSkpO1xuICB9XG4gIGhhbmRsZXJzID0ge1xuICAgIGNvbm5lY3Q6IG5ldyBDb25uZWN0RXZlbnRIYW5kbGluZ1N0cmF0ZWd5KCksXG4gICAgc2lnbl9ldmVudDogbmV3IFNpZ25FdmVudEhhbmRsaW5nU3RyYXRlZ3koKSxcbiAgICBuaXAwNF9lbmNyeXB0OiBuZXcgTmlwMDRFbmNyeXB0SGFuZGxpbmdTdHJhdGVneSgpLFxuICAgIG5pcDA0X2RlY3J5cHQ6IG5ldyBOaXAwNERlY3J5cHRIYW5kbGluZ1N0cmF0ZWd5KCksXG4gICAgbmlwNDRfZW5jcnlwdDogbmV3IE5pcDA0RW5jcnlwdEhhbmRsaW5nU3RyYXRlZ3kyKCksXG4gICAgbmlwNDRfZGVjcnlwdDogbmV3IE5pcDA0RGVjcnlwdEhhbmRsaW5nU3RyYXRlZ3kyKCksXG4gICAgZ2V0X3B1YmxpY19rZXk6IG5ldyBHZXRQdWJsaWNLZXlIYW5kbGluZ1N0cmF0ZWd5KCksXG4gICAgcGluZzogbmV3IFBpbmdFdmVudEhhbmRsaW5nU3RyYXRlZ3koKVxuICB9O1xuICAvKipcbiAgICogRW5hYmxlcyB0aGUgdXNlciB0byBzZXQgYSBjdXN0b20gc3RyYXRlZ3kgZm9yIGhhbmRsaW5nIGluY29taW5nIGV2ZW50cy5cbiAgICogQHBhcmFtIG1ldGhvZCAtIFRoZSBtZXRob2QgdG8gc2V0IHRoZSBzdHJhdGVneSBmb3JcbiAgICogQHBhcmFtIHN0cmF0ZWd5IC0gVGhlIHN0cmF0ZWd5IHRvIHNldFxuICAgKi9cbiAgc2V0U3RyYXRlZ3kobWV0aG9kLCBzdHJhdGVneSkge1xuICAgIHRoaXMuaGFuZGxlcnNbbWV0aG9kXSA9IHN0cmF0ZWd5O1xuICB9XG4gIC8qKlxuICAgKiBPdmVybG9hZCB0aGlzIG1ldGhvZCB0byBhcHBseSB0b2tlbnMsIHdoaWNoIGNhblxuICAgKiB3cmFwIHBlcm1pc3Npb24gc2V0cyB0byBiZSBhcHBsaWVkIHRvIGEgcHVia2V5LlxuICAgKiBAcGFyYW0gcHVia2V5IHB1YmxpYyBrZXkgdG8gYXBwbHkgdG9rZW4gdG9cbiAgICogQHBhcmFtIHRva2VuIHRva2VuIHRvIGFwcGx5XG4gICAqL1xuICBhc3luYyBhcHBseVRva2VuKHB1YmtleSwgdG9rZW4pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb25uZWN0aW9uIHRva2VuIG5vdCBzdXBwb3J0ZWRcIik7XG4gIH1cbiAgYXN5bmMgaGFuZGxlSW5jb21pbmdFdmVudChldmVudCkge1xuICAgIGNvbnN0IHsgaWQsIG1ldGhvZCwgcGFyYW1zIH0gPSBhd2FpdCB0aGlzLnJwYy5wYXJzZUV2ZW50KGV2ZW50KTtcbiAgICBjb25zdCByZW1vdGVQdWJrZXkgPSBldmVudC5wdWJrZXk7XG4gICAgbGV0IHJlc3BvbnNlO1xuICAgIHRoaXMuZGVidWcoXCJpbmNvbWluZyBldmVudFwiLCB7IGlkLCBtZXRob2QsIHBhcmFtcyB9KTtcbiAgICBpZiAoIWV2ZW50LnZlcmlmeVNpZ25hdHVyZShmYWxzZSkpIHtcbiAgICAgIHRoaXMuZGVidWcoXCJpbnZhbGlkIHNpZ25hdHVyZVwiLCBldmVudC5yYXdFdmVudCgpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3RyYXRlZ3kgPSB0aGlzLmhhbmRsZXJzW21ldGhvZF07XG4gICAgaWYgKHN0cmF0ZWd5KSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXNwb25zZSA9IGF3YWl0IHN0cmF0ZWd5LmhhbmRsZSh0aGlzLCBpZCwgcmVtb3RlUHVia2V5LCBwYXJhbXMpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLmRlYnVnKFwiZXJyb3IgaGFuZGxpbmcgZXZlbnRcIiwgZSwgeyBpZCwgbWV0aG9kLCBwYXJhbXMgfSk7XG4gICAgICAgIHRoaXMucnBjLnNlbmRSZXNwb25zZShpZCwgcmVtb3RlUHVia2V5LCBcImVycm9yXCIsIHZvaWQgMCwgZS5tZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kZWJ1ZyhcInVuc3VwcG9ydGVkIG1ldGhvZFwiLCB7IG1ldGhvZCwgcGFyYW1zIH0pO1xuICAgIH1cbiAgICBpZiAocmVzcG9uc2UpIHtcbiAgICAgIHRoaXMuZGVidWcoYHNlbmRpbmcgcmVzcG9uc2UgdG8gJHtyZW1vdGVQdWJrZXl9YCwgcmVzcG9uc2UpO1xuICAgICAgdGhpcy5ycGMuc2VuZFJlc3BvbnNlKGlkLCByZW1vdGVQdWJrZXksIHJlc3BvbnNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ycGMuc2VuZFJlc3BvbnNlKGlkLCByZW1vdGVQdWJrZXksIFwiZXJyb3JcIiwgdm9pZCAwLCBcIk5vdCBhdXRob3JpemVkXCIpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVGhpcyBtZXRob2Qgc2hvdWxkIGJlIG92ZXJyaWRlbiBieSB0aGUgdXNlciB0byBhbGxvdyBvciByZWplY3QgaW5jb21pbmdcbiAgICogY29ubmVjdGlvbnMuXG4gICAqL1xuICBhc3luYyBwdWJrZXlBbGxvd2VkKHBhcmFtcykge1xuICAgIHJldHVybiB0aGlzLnBlcm1pdENhbGxiYWNrKHBhcmFtcyk7XG4gIH1cbn07XG5cbi8vIHNyYy9zaWduZXJzL25pcDQ2L2luZGV4LnRzXG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgYXMgRXZlbnRFbWl0dGVyNiB9IGZyb20gXCJ0c2VlcFwiO1xudmFyIE5ES05pcDQ2U2lnbmVyID0gY2xhc3MgZXh0ZW5kcyBFdmVudEVtaXR0ZXI2IHtcbiAgbmRrO1xuICBfdXNlcjtcbiAgLyoqXG4gICAqIFRoZSBwdWJrZXkgb2YgdGhlIGJ1bmtlciB0aGF0IHdpbGwgYmUgcHJvdmlkaW5nIHNpZ25hdHVyZXNcbiAgICovXG4gIGJ1bmtlclB1YmtleTtcbiAgLyoqXG4gICAqIFRoZSBwdWJrZXkgb2YgdGhlIHVzZXIgdGhhdCBldmVudHMgd2lsbCBiZSBwdWJsaXNoZWQgYXNcbiAgICovXG4gIHVzZXJQdWJrZXk7XG4gIC8qKlxuICAgKiBBbiBvcHRpb25hbCBzZWNyZXQgdmFsdWUgcHJvdmlkZWQgdG8gY29ubmVjdCB0byB0aGUgYnVua2VyXG4gICAqL1xuICBzZWNyZXQ7XG4gIGxvY2FsU2lnbmVyO1xuICBuaXAwNTtcbiAgcnBjO1xuICBkZWJ1ZztcbiAgcmVsYXlVcmxzO1xuICBzdWJzY3JpcHRpb247XG4gIC8qKlxuICAgKiBAcGFyYW0gbmRrIC0gVGhlIE5ESyBpbnN0YW5jZSB0byB1c2VcbiAgICogQHBhcmFtIHVzZXJPckNvbm5lY3Rpb25Ub2tlbiAtIFRoZSBwdWJsaWMga2V5LCBvciBhIGNvbm5lY3Rpb24gdG9rZW4sIG9mIHRoZSBucHViIHRoYXQgd2FudHMgdG8gYmUgcHVibGlzaGVkIGFzXG4gICAqIEBwYXJhbSBsb2NhbFNpZ25lciAtIFRoZSBzaWduZXIgdGhhdCB3aWxsIGJlIHVzZWQgdG8gcmVxdWVzdCBldmVudHMgdG8gYmUgc2lnbmVkXG4gICAqL1xuICBjb25zdHJ1Y3RvcihuZGssIHVzZXJPckNvbm5lY3Rpb25Ub2tlbiwgbG9jYWxTaWduZXIpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubmRrID0gbmRrO1xuICAgIHRoaXMuZGVidWcgPSBuZGsuZGVidWcuZXh0ZW5kKFwibmlwNDY6c2lnbmVyXCIpO1xuICAgIGlmICh1c2VyT3JDb25uZWN0aW9uVG9rZW4uc3RhcnRzV2l0aChcImJ1bmtlcjovL1wiKSkge1xuICAgICAgdGhpcy5jb25uZWN0aW9uVG9rZW5Jbml0KHVzZXJPckNvbm5lY3Rpb25Ub2tlbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubmlwMDVJbml0KHVzZXJPckNvbm5lY3Rpb25Ub2tlbik7XG4gICAgfVxuICAgIGlmICghbG9jYWxTaWduZXIpIHtcbiAgICAgIHRoaXMubG9jYWxTaWduZXIgPSBOREtQcml2YXRlS2V5U2lnbmVyLmdlbmVyYXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubG9jYWxTaWduZXIgPSBsb2NhbFNpZ25lcjtcbiAgICB9XG4gICAgdGhpcy5ycGMgPSBuZXcgTkRLTm9zdHJScGModGhpcy5uZGssIHRoaXMubG9jYWxTaWduZXIsIHRoaXMuZGVidWcsIHRoaXMucmVsYXlVcmxzKTtcbiAgfVxuICBjb25uZWN0aW9uVG9rZW5Jbml0KGNvbm5lY3Rpb25Ub2tlbikge1xuICAgIGNvbnN0IGJ1bmtlclVybCA9IG5ldyBVUkwoY29ubmVjdGlvblRva2VuKTtcbiAgICBjb25zdCBidW5rZXJQdWJrZXkgPSBidW5rZXJVcmwuaG9zdG5hbWUgfHwgYnVua2VyVXJsLnBhdGhuYW1lLnJlcGxhY2UoL15cXC9cXC8vLCBcIlwiKTtcbiAgICBjb25zdCB1c2VyUHVia2V5ID0gYnVua2VyVXJsLnNlYXJjaFBhcmFtcy5nZXQoXCJwdWJrZXlcIik7XG4gICAgY29uc3QgcmVsYXlVcmxzID0gYnVua2VyVXJsLnNlYXJjaFBhcmFtcy5nZXRBbGwoXCJyZWxheVwiKTtcbiAgICBjb25zdCBzZWNyZXQgPSBidW5rZXJVcmwuc2VhcmNoUGFyYW1zLmdldChcInNlY3JldFwiKTtcbiAgICB0aGlzLmJ1bmtlclB1YmtleSA9IGJ1bmtlclB1YmtleTtcbiAgICB0aGlzLnVzZXJQdWJrZXkgPSB1c2VyUHVia2V5O1xuICAgIHRoaXMucmVsYXlVcmxzID0gcmVsYXlVcmxzO1xuICAgIHRoaXMuc2VjcmV0ID0gc2VjcmV0O1xuICB9XG4gIG5pcDA1SW5pdChuaXAwNSkge1xuICAgIHRoaXMubmlwMDUgPSBuaXAwNTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHVzZXJQdWJrZXkgaW5zdGVhZFxuICAgKi9cbiAgZ2V0IHJlbW90ZVB1YmtleSgpIHtcbiAgICByZXR1cm4gdGhpcy51c2VyUHVia2V5O1xuICB9XG4gIC8qKlxuICAgKiBXZSBzdGFydCBsaXN0ZW5pbmcgZm9yIGV2ZW50cyBmcm9tIHRoZSBidW5rZXJcbiAgICovXG4gIGFzeW5jIHN0YXJ0TGlzdGVuaW5nKCkge1xuICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvbikgcmV0dXJuO1xuICAgIGNvbnN0IGxvY2FsVXNlciA9IGF3YWl0IHRoaXMubG9jYWxTaWduZXIudXNlcigpO1xuICAgIGlmICghbG9jYWxVc2VyKSB0aHJvdyBuZXcgRXJyb3IoXCJMb2NhbCBzaWduZXIgbm90IHJlYWR5XCIpO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gYXdhaXQgdGhpcy5ycGMuc3Vic2NyaWJlKHtcbiAgICAgIGtpbmRzOiBbMjQxMzMgLyogTm9zdHJDb25uZWN0ICovXSxcbiAgICAgIFwiI3BcIjogW2xvY2FsVXNlci5wdWJrZXldXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgdXNlciB0aGF0IGlzIGJlaW5nIHB1Ymxpc2hlZCBhc1xuICAgKi9cbiAgYXN5bmMgdXNlcigpIHtcbiAgICBpZiAoIXRoaXMuX3VzZXIgJiYgIXRoaXMudXNlclB1YmtleSkgdGhyb3cgbmV3IEVycm9yKFwiUmVtb3RlIHVzZXIgbm90IHJlYWR5XCIpO1xuICAgIHRoaXMuX3VzZXIgPz89IG5ldyBOREtVc2VyKHsgcHVia2V5OiB0aGlzLnVzZXJQdWJrZXkgfSk7XG4gICAgcmV0dXJuIHRoaXMuX3VzZXI7XG4gIH1cbiAgYXN5bmMgYmxvY2tVbnRpbFJlYWR5KCkge1xuICAgIGlmICh0aGlzLm5pcDA1ICYmICF0aGlzLnVzZXJQdWJrZXkpIHtcbiAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBOREtVc2VyLmZyb21OaXAwNSh0aGlzLm5pcDA1LCB0aGlzLm5kayk7XG4gICAgICBpZiAodXNlcikge1xuICAgICAgICB0aGlzLl91c2VyID0gdXNlcjtcbiAgICAgICAgdGhpcy51c2VyUHVia2V5ID0gdXNlci5wdWJrZXk7XG4gICAgICAgIHRoaXMucmVsYXlVcmxzID0gdXNlci5uaXA0NlVybHM7XG4gICAgICAgIHRoaXMucnBjID0gbmV3IE5ES05vc3RyUnBjKHRoaXMubmRrLCB0aGlzLmxvY2FsU2lnbmVyLCB0aGlzLmRlYnVnLCB0aGlzLnJlbGF5VXJscyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdGhpcy5idW5rZXJQdWJrZXkgJiYgdGhpcy51c2VyUHVia2V5KSB7XG4gICAgICB0aGlzLmJ1bmtlclB1YmtleSA9IHRoaXMudXNlclB1YmtleTtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLmJ1bmtlclB1YmtleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQnVua2VyIHB1YmtleSBub3Qgc2V0XCIpO1xuICAgIH1cbiAgICBhd2FpdCB0aGlzLnN0YXJ0TGlzdGVuaW5nKCk7XG4gICAgdGhpcy5ycGMub24oXCJhdXRoVXJsXCIsICguLi5wcm9wcykgPT4ge1xuICAgICAgdGhpcy5lbWl0KFwiYXV0aFVybFwiLCAuLi5wcm9wcyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IGNvbm5lY3RQYXJhbXMgPSBbdGhpcy51c2VyUHVia2V5ID8/IFwiXCJdO1xuICAgICAgaWYgKHRoaXMuc2VjcmV0KSBjb25uZWN0UGFyYW1zLnB1c2godGhpcy5zZWNyZXQpO1xuICAgICAgaWYgKCF0aGlzLmJ1bmtlclB1YmtleSkgdGhyb3cgbmV3IEVycm9yKFwiQnVua2VyIHB1YmtleSBub3Qgc2V0XCIpO1xuICAgICAgdGhpcy5ycGMuc2VuZFJlcXVlc3QoXG4gICAgICAgIHRoaXMuYnVua2VyUHVia2V5LFxuICAgICAgICBcImNvbm5lY3RcIixcbiAgICAgICAgY29ubmVjdFBhcmFtcyxcbiAgICAgICAgMjQxMzMsXG4gICAgICAgIChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgIGlmIChyZXNwb25zZS5yZXN1bHQgPT09IFwiYWNrXCIpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0UHVibGljS2V5KCkudGhlbigocHVia2V5KSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMudXNlclB1YmtleSA9IHB1YmtleTtcbiAgICAgICAgICAgICAgdGhpcy5fdXNlciA9IG5ldyBOREtVc2VyKHsgcHVia2V5IH0pO1xuICAgICAgICAgICAgICByZXNvbHZlKHRoaXMuX3VzZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlamVjdChyZXNwb25zZS5lcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGdldFB1YmxpY0tleSgpIHtcbiAgICBpZiAodGhpcy51c2VyUHVia2V5KSByZXR1cm4gdGhpcy51c2VyUHVia2V5O1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAoIXRoaXMuYnVua2VyUHVia2V5KSB0aHJvdyBuZXcgRXJyb3IoXCJCdW5rZXIgcHVia2V5IG5vdCBzZXRcIik7XG4gICAgICB0aGlzLnJwYy5zZW5kUmVxdWVzdChcbiAgICAgICAgdGhpcy5idW5rZXJQdWJrZXksXG4gICAgICAgIFwiZ2V0X3B1YmxpY19rZXlcIixcbiAgICAgICAgW10sXG4gICAgICAgIDI0MTMzLFxuICAgICAgICAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICByZXNvbHZlKHJlc3BvbnNlLnJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZW5jcnlwdGlvbkVuYWJsZWQoc2NoZW1lKSB7XG4gICAgaWYgKHNjaGVtZSkgcmV0dXJuIFtzY2hlbWVdO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoW1wibmlwMDRcIiwgXCJuaXA0NFwiXSk7XG4gIH1cbiAgYXN5bmMgZW5jcnlwdChyZWNpcGllbnQsIHZhbHVlLCBzY2hlbWUgPSBcIm5pcDA0XCIpIHtcbiAgICByZXR1cm4gdGhpcy5lbmNyeXB0aW9uKHJlY2lwaWVudCwgdmFsdWUsIHNjaGVtZSwgXCJlbmNyeXB0XCIpO1xuICB9XG4gIGFzeW5jIGRlY3J5cHQoc2VuZGVyLCB2YWx1ZSwgc2NoZW1lID0gXCJuaXAwNFwiKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5jcnlwdGlvbihzZW5kZXIsIHZhbHVlLCBzY2hlbWUsIFwiZGVjcnlwdFwiKTtcbiAgfVxuICBhc3luYyBlbmNyeXB0aW9uKHBlZXIsIHZhbHVlLCBzY2hlbWUsIG1ldGhvZCkge1xuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAoIXRoaXMuYnVua2VyUHVia2V5KSB0aHJvdyBuZXcgRXJyb3IoXCJCdW5rZXIgcHVia2V5IG5vdCBzZXRcIik7XG4gICAgICB0aGlzLnJwYy5zZW5kUmVxdWVzdChcbiAgICAgICAgdGhpcy5idW5rZXJQdWJrZXksXG4gICAgICAgIGAke3NjaGVtZX1fJHttZXRob2R9YCxcbiAgICAgICAgW3BlZXIucHVia2V5LCB2YWx1ZV0sXG4gICAgICAgIDI0MTMzLFxuICAgICAgICAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICBpZiAoIXJlc3BvbnNlLmVycm9yKSB7XG4gICAgICAgICAgICByZXNvbHZlKHJlc3BvbnNlLnJlc3VsdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlamVjdChyZXNwb25zZS5lcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApO1xuICAgIH0pO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG4gIGFzeW5jIHNpZ24oZXZlbnQpIHtcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLmJ1bmtlclB1YmtleSkgdGhyb3cgbmV3IEVycm9yKFwiQnVua2VyIHB1YmtleSBub3Qgc2V0XCIpO1xuICAgICAgdGhpcy5ycGMuc2VuZFJlcXVlc3QoXG4gICAgICAgIHRoaXMuYnVua2VyUHVia2V5LFxuICAgICAgICBcInNpZ25fZXZlbnRcIixcbiAgICAgICAgW0pTT04uc3RyaW5naWZ5KGV2ZW50KV0sXG4gICAgICAgIDI0MTMzLFxuICAgICAgICAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICBpZiAoIXJlc3BvbnNlLmVycm9yKSB7XG4gICAgICAgICAgICBjb25zdCBqc29uID0gSlNPTi5wYXJzZShyZXNwb25zZS5yZXN1bHQpO1xuICAgICAgICAgICAgcmVzb2x2ZShqc29uLnNpZyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlamVjdChyZXNwb25zZS5lcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApO1xuICAgIH0pO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG4gIC8qKlxuICAgKiBBbGxvd3MgY3JlYXRpbmcgYSBuZXcgYWNjb3VudCBvbiB0aGUgcmVtb3RlIHNlcnZlci5cbiAgICogQHBhcmFtIHVzZXJuYW1lIERlc2lyZWQgdXNlcm5hbWUgZm9yIHRoZSBOSVAtMDVcbiAgICogQHBhcmFtIGRvbWFpbiBEZXNpcmVkIGRvbWFpbiBmb3IgdGhlIE5JUC0wNVxuICAgKiBAcGFyYW0gZW1haWwgRW1haWwgYWRkcmVzcyB0byBhc3NvY2lhdGUgd2l0aCB0aGlzIGFjY291bnQgLS0gUmVtb3RlIHNlcnZlcnMgbWF5IHVzZSB0aGlzIGZvciByZWNvdmVyeVxuICAgKiBAcmV0dXJucyBUaGUgcHVibGljIGtleSBvZiB0aGUgbmV3bHkgY3JlYXRlZCBhY2NvdW50XG4gICAqL1xuICBhc3luYyBjcmVhdGVBY2NvdW50KHVzZXJuYW1lLCBkb21haW4sIGVtYWlsKSB7XG4gICAgYXdhaXQgdGhpcy5zdGFydExpc3RlbmluZygpO1xuICAgIGNvbnN0IHJlcSA9IFtdO1xuICAgIGlmICh1c2VybmFtZSkgcmVxLnB1c2godXNlcm5hbWUpO1xuICAgIGlmIChkb21haW4pIHJlcS5wdXNoKGRvbWFpbik7XG4gICAgaWYgKGVtYWlsKSByZXEucHVzaChlbWFpbCk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmICghdGhpcy5idW5rZXJQdWJrZXkpIHRocm93IG5ldyBFcnJvcihcIkJ1bmtlciBwdWJrZXkgbm90IHNldFwiKTtcbiAgICAgIHRoaXMucnBjLnNlbmRSZXF1ZXN0KFxuICAgICAgICB0aGlzLmJ1bmtlclB1YmtleSxcbiAgICAgICAgXCJjcmVhdGVfYWNjb3VudFwiLFxuICAgICAgICByZXEsXG4gICAgICAgIDI0MTMzIC8qIE5vc3RyQ29ubmVjdCAqLyxcbiAgICAgICAgKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgaWYgKCFyZXNwb25zZS5lcnJvcikge1xuICAgICAgICAgICAgY29uc3QgcHVia2V5ID0gcmVzcG9uc2UucmVzdWx0O1xuICAgICAgICAgICAgcmVzb2x2ZShwdWJrZXkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWplY3QocmVzcG9uc2UuZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxufTtcblxuLy8gc3JjL2R2bS9zY2hlZHVsZS50c1xuZnVuY3Rpb24gYWRkUmVsYXlzKGV2ZW50LCByZWxheXMpIHtcbiAgY29uc3QgdGFncyA9IFtdO1xuICBpZiAoIXJlbGF5cyB8fCByZWxheXMubGVuZ3RoID09PSAwKSB7XG4gICAgY29uc3QgcG9vbFJlbGF5cyA9IGV2ZW50Lm5kaz8ucG9vbC5yZWxheXM7XG4gICAgcmVsYXlzID0gcG9vbFJlbGF5cyA/IE9iamVjdC5rZXlzKHBvb2xSZWxheXMpIDogdm9pZCAwO1xuICB9XG4gIGlmIChyZWxheXMgJiYgcmVsYXlzLmxlbmd0aCA+IDApIHRhZ3MucHVzaChbXCJyZWxheXNcIiwgLi4ucmVsYXlzXSk7XG4gIHJldHVybiB0YWdzO1xufVxuYXN5bmMgZnVuY3Rpb24gZHZtU2NoZWR1bGUoZXZlbnRzLCBkdm0sIHJlbGF5cywgZW5jcnlwdGVkID0gdHJ1ZSwgd2FpdEZvckNvbmZpcm1hdGlvbkZvck1zKSB7XG4gIGlmICghKGV2ZW50cyBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgIGV2ZW50cyA9IFtldmVudHNdO1xuICB9XG4gIGNvbnN0IG5kayA9IGV2ZW50c1swXS5uZGs7XG4gIGlmICghbmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJOREsgbm90IHNldFwiKTtcbiAgZm9yIChjb25zdCBldmVudCBvZiBldmVudHMpIHtcbiAgICBpZiAoIWV2ZW50LnNpZykgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnQgbm90IHNpZ25lZFwiKTtcbiAgICBpZiAoIWV2ZW50LmNyZWF0ZWRfYXQpIHRocm93IG5ldyBFcnJvcihcIkV2ZW50IGhhcyBubyBkYXRlXCIpO1xuICAgIGlmICghZHZtKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBEVk0gc3BlY2lmaWVkXCIpO1xuICAgIGlmIChldmVudC5jcmVhdGVkX2F0IDw9IERhdGUubm93KCkgLyAxZTMpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFdmVudCBuZWVkcyB0byBiZSBpbiB0aGUgZnV0dXJlXCIpO1xuICB9XG4gIGNvbnN0IHNjaGVkdWxlRXZlbnQgPSBuZXcgTkRLRFZNUmVxdWVzdChuZGssIHtcbiAgICBraW5kOiA1OTA1IC8qIERWTUV2ZW50U2NoZWR1bGUgKi9cbiAgfSk7XG4gIGZvciAoY29uc3QgZXZlbnQgb2YgZXZlbnRzKSB7XG4gICAgc2NoZWR1bGVFdmVudC5hZGRJbnB1dChKU09OLnN0cmluZ2lmeShldmVudC5yYXdFdmVudCgpKSwgXCJ0ZXh0XCIpO1xuICB9XG4gIHNjaGVkdWxlRXZlbnQudGFncy5wdXNoKC4uLmFkZFJlbGF5cyhldmVudHNbMF0sIHJlbGF5cykpO1xuICBpZiAoZW5jcnlwdGVkKSB7XG4gICAgYXdhaXQgc2NoZWR1bGVFdmVudC5lbmNyeXB0aW9uKGR2bSk7XG4gIH0gZWxzZSB7XG4gICAgc2NoZWR1bGVFdmVudC5kdm0gPSBkdm07XG4gIH1cbiAgYXdhaXQgc2NoZWR1bGVFdmVudC5zaWduKCk7XG4gIGxldCByZXM7XG4gIGlmICh3YWl0Rm9yQ29uZmlybWF0aW9uRm9yTXMpIHtcbiAgICByZXMgPSBuZGsuc3Vic2NyaWJlKFxuICAgICAge1xuICAgICAgICBraW5kczogWzU5MDUgLyogRFZNRXZlbnRTY2hlZHVsZSAqLyArIDFlMywgN2UzIC8qIERWTUpvYkZlZWRiYWNrICovXSxcbiAgICAgICAgLi4uc2NoZWR1bGVFdmVudC5maWx0ZXIoKVxuICAgICAgfSxcbiAgICAgIHsgZ3JvdXBhYmxlOiBmYWxzZSwgY2xvc2VPbkVvc2U6IGZhbHNlIH1cbiAgICApO1xuICB9XG4gIGNvbnN0IHRpbWVvdXRQcm9taXNlID0gbmV3IFByb21pc2UoKHJlamVjdCkgPT4ge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgcmVzPy5zdG9wKCk7XG4gICAgICByZWplY3QoXCJUaW1lb3V0IHdhaXRpbmcgZm9yIGFuIGFuc3dlciBmcm9tIHRoZSBEVk1cIik7XG4gICAgfSwgd2FpdEZvckNvbmZpcm1hdGlvbkZvck1zKTtcbiAgfSk7XG4gIGNvbnN0IHNjaGVkdWxlUHJvbWlzZSA9IG5ldyBQcm9taXNlKFxuICAgIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmICh3YWl0Rm9yQ29uZmlybWF0aW9uRm9yTXMpIHtcbiAgICAgICAgcmVzPy5vbihcImV2ZW50XCIsIGFzeW5jIChlKSA9PiB7XG4gICAgICAgICAgcmVzPy5zdG9wKCk7XG4gICAgICAgICAgaWYgKGUua2luZCA9PT0gN2UzIC8qIERWTUpvYkZlZWRiYWNrICovKSB7XG4gICAgICAgICAgICBjb25zdCBmZWVkYmFjayA9IGF3YWl0IE5ES0RWTUpvYkZlZWRiYWNrLmZyb20oZSk7XG4gICAgICAgICAgICBpZiAoZmVlZGJhY2suc3RhdHVzID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgICAgICAgY29uc3Qgc3RhdHVzVGFnID0gZmVlZGJhY2suZ2V0TWF0Y2hpbmdUYWdzKFwic3RhdHVzXCIpO1xuICAgICAgICAgICAgICByZWplY3Qoc3RhdHVzVGFnPy5bMl0gPz8gZmVlZGJhY2spO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShmZWVkYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUoZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgc2NoZWR1bGVFdmVudC5wdWJsaXNoKCkudGhlbigoKSA9PiB7XG4gICAgICAgIGlmICghd2FpdEZvckNvbmZpcm1hdGlvbkZvck1zKSByZXNvbHZlKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICk7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgaWYgKHdhaXRGb3JDb25maXJtYXRpb25Gb3JNcykge1xuICAgICAgUHJvbWlzZS5yYWNlKFt0aW1lb3V0UHJvbWlzZSwgc2NoZWR1bGVQcm9taXNlXSkudGhlbigoZSkgPT4ge1xuICAgICAgICByZXNvbHZlKGUpO1xuICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NoZWR1bGVQcm9taXNlLnRoZW4ocmVzb2x2ZSk7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3JjL25kay9pbmRleC50c1xuaW1wb3J0IGRlYnVnNyBmcm9tIFwiZGVidWdcIjtcbmltcG9ydCB7IEV2ZW50RW1pdHRlciBhcyBFdmVudEVtaXR0ZXI4IH0gZnJvbSBcInRzZWVwXCI7XG5cbi8vIHNyYy9ldmVudHMvZGVkdXAudHNcbmZ1bmN0aW9uIGRlZHVwKGV2ZW50MSwgZXZlbnQyKSB7XG4gIGlmIChldmVudDEuY3JlYXRlZF9hdCA+IGV2ZW50Mi5jcmVhdGVkX2F0KSB7XG4gICAgcmV0dXJuIGV2ZW50MTtcbiAgfVxuICByZXR1cm4gZXZlbnQyO1xufVxuXG4vLyBzcmMvb3V0Ym94L3RyYWNrZXIudHNcbmltcG9ydCB7IEV2ZW50RW1pdHRlciBhcyBFdmVudEVtaXR0ZXI3IH0gZnJvbSBcInRzZWVwXCI7XG5pbXBvcnQgeyBMUlVDYWNoZSBhcyBMUlVDYWNoZTIgfSBmcm9tIFwidHlwZXNjcmlwdC1scnUtY2FjaGVcIjtcblxuLy8gc3JjL3V0aWxzL2dldC11c2Vycy1yZWxheS1saXN0LnRzXG5hc3luYyBmdW5jdGlvbiBnZXRSZWxheUxpc3RGb3JVc2VyKHB1YmtleSwgbmRrKSB7XG4gIGNvbnN0IGxpc3QgPSBhd2FpdCBnZXRSZWxheUxpc3RGb3JVc2VycyhbcHVia2V5XSwgbmRrKTtcbiAgcmV0dXJuIGxpc3QuZ2V0KHB1YmtleSk7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRSZWxheUxpc3RGb3JVc2VycyhwdWJrZXlzLCBuZGssIHNraXBDYWNoZSA9IGZhbHNlLCB0aW1lb3V0ID0gMWUzKSB7XG4gIGNvbnN0IHBvb2wgPSBuZGsub3V0Ym94UG9vbCB8fCBuZGsucG9vbDtcbiAgY29uc3Qgc2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgZm9yIChjb25zdCByZWxheSBvZiBwb29sLnJlbGF5cy52YWx1ZXMoKSkgc2V0LmFkZChyZWxheSk7XG4gIGNvbnN0IHJlbGF5TGlzdHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCBmcm9tQ29udGFjdExpc3QgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCByZWxheVNldCA9IG5ldyBOREtSZWxheVNldChzZXQsIG5kayk7XG4gIGlmIChuZGsuY2FjaGVBZGFwdGVyPy5sb2NraW5nICYmICFza2lwQ2FjaGUpIHtcbiAgICBjb25zdCBjYWNoZWRMaXN0ID0gYXdhaXQgbmRrLmZldGNoRXZlbnRzKFxuICAgICAgeyBraW5kczogWzMsIDEwMDAyXSwgYXV0aG9yczogQXJyYXkuZnJvbShuZXcgU2V0KHB1YmtleXMpKSB9LFxuICAgICAgeyBjYWNoZVVzYWdlOiBcIk9OTFlfQ0FDSEVcIiAvKiBPTkxZX0NBQ0hFICovLCBzdWJJZDogXCJuZGstcmVsYXktbGlzdC1mZXRjaFwiIH1cbiAgICApO1xuICAgIGZvciAoY29uc3QgcmVsYXlMaXN0IG9mIGNhY2hlZExpc3QpIHtcbiAgICAgIGlmIChyZWxheUxpc3Qua2luZCA9PT0gMTAwMDIpXG4gICAgICAgIHJlbGF5TGlzdHMuc2V0KHJlbGF5TGlzdC5wdWJrZXksIE5ES1JlbGF5TGlzdC5mcm9tKHJlbGF5TGlzdCkpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHJlbGF5TGlzdCBvZiBjYWNoZWRMaXN0KSB7XG4gICAgICBpZiAocmVsYXlMaXN0LmtpbmQgPT09IDMpIHtcbiAgICAgICAgaWYgKHJlbGF5TGlzdHMuaGFzKHJlbGF5TGlzdC5wdWJrZXkpKSBjb250aW51ZTtcbiAgICAgICAgY29uc3QgbGlzdCA9IHJlbGF5TGlzdEZyb21LaW5kMyhuZGssIHJlbGF5TGlzdCk7XG4gICAgICAgIGlmIChsaXN0KSBmcm9tQ29udGFjdExpc3Quc2V0KHJlbGF5TGlzdC5wdWJrZXksIGxpc3QpO1xuICAgICAgfVxuICAgIH1cbiAgICBwdWJrZXlzID0gcHVia2V5cy5maWx0ZXIoXG4gICAgICAocHVia2V5KSA9PiAhcmVsYXlMaXN0cy5oYXMocHVia2V5KSAmJiAhZnJvbUNvbnRhY3RMaXN0LmhhcyhwdWJrZXkpXG4gICAgKTtcbiAgfVxuICBpZiAocHVia2V5cy5sZW5ndGggPT09IDApIHJldHVybiByZWxheUxpc3RzO1xuICBjb25zdCByZWxheUxpc3RFdmVudHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCBjb250YWN0TGlzdEV2ZW50cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSkgPT4ge1xuICAgIGNvbnN0IHN1YiA9IG5kay5zdWJzY3JpYmUoXG4gICAgICB7IGtpbmRzOiBbMywgMTAwMDJdLCBhdXRob3JzOiBwdWJrZXlzIH0sXG4gICAgICB7XG4gICAgICAgIGNsb3NlT25Fb3NlOiB0cnVlLFxuICAgICAgICBwb29sLFxuICAgICAgICBncm91cGFibGU6IHRydWUsXG4gICAgICAgIGNhY2hlVXNhZ2U6IFwiT05MWV9SRUxBWVwiIC8qIE9OTFlfUkVMQVkgKi8sXG4gICAgICAgIHN1YklkOiBcIm5kay1yZWxheS1saXN0LWZldGNoXCJcbiAgICAgIH0sXG4gICAgICByZWxheVNldCxcbiAgICAgIGZhbHNlXG4gICAgKTtcbiAgICBzdWIub24oXCJldmVudFwiLCAoZXZlbnQpID0+IHtcbiAgICAgIGlmIChldmVudC5raW5kID09PSAxMDAwMiAvKiBSZWxheUxpc3QgKi8pIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdFdmVudCA9IHJlbGF5TGlzdEV2ZW50cy5nZXQoZXZlbnQucHVia2V5KTtcbiAgICAgICAgaWYgKGV4aXN0aW5nRXZlbnQgJiYgZXhpc3RpbmdFdmVudC5jcmVhdGVkX2F0ID4gZXZlbnQuY3JlYXRlZF9hdCkgcmV0dXJuO1xuICAgICAgICByZWxheUxpc3RFdmVudHMuc2V0KGV2ZW50LnB1YmtleSwgZXZlbnQpO1xuICAgICAgfSBlbHNlIGlmIChldmVudC5raW5kID09PSAzIC8qIENvbnRhY3RzICovKSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nRXZlbnQgPSBjb250YWN0TGlzdEV2ZW50cy5nZXQoZXZlbnQucHVia2V5KTtcbiAgICAgICAgaWYgKGV4aXN0aW5nRXZlbnQgJiYgZXhpc3RpbmdFdmVudC5jcmVhdGVkX2F0ID4gZXZlbnQuY3JlYXRlZF9hdCkgcmV0dXJuO1xuICAgICAgICBjb250YWN0TGlzdEV2ZW50cy5zZXQoZXZlbnQucHVia2V5LCBldmVudCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgc3ViLm9uKFwiZW9zZVwiLCAoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIHJlbGF5TGlzdEV2ZW50cy52YWx1ZXMoKSkge1xuICAgICAgICByZWxheUxpc3RzLnNldChldmVudC5wdWJrZXksIE5ES1JlbGF5TGlzdC5mcm9tKGV2ZW50KSk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IHB1YmtleSBvZiBwdWJrZXlzKSB7XG4gICAgICAgIGlmIChyZWxheUxpc3RzLmhhcyhwdWJrZXkpKSBjb250aW51ZTtcbiAgICAgICAgY29uc3QgY29udGFjdExpc3QgPSBjb250YWN0TGlzdEV2ZW50cy5nZXQocHVia2V5KTtcbiAgICAgICAgaWYgKCFjb250YWN0TGlzdCkgY29udGludWU7XG4gICAgICAgIGNvbnN0IGxpc3QgPSByZWxheUxpc3RGcm9tS2luZDMobmRrLCBjb250YWN0TGlzdCk7XG4gICAgICAgIGlmIChsaXN0KSByZWxheUxpc3RzLnNldChwdWJrZXksIGxpc3QpO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZShyZWxheUxpc3RzKTtcbiAgICB9KTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHJlc29sdmUocmVsYXlMaXN0cyk7XG4gICAgfSwgdGltZW91dCk7XG4gICAgc3ViLnN0YXJ0KCk7XG4gIH0pO1xufVxuXG4vLyBzcmMvb3V0Ym94L3RyYWNrZXIudHNcbnZhciBPdXRib3hJdGVtID0gY2xhc3Mge1xuICAvKipcbiAgICogVHlwZSBvZiBpdGVtXG4gICAqL1xuICB0eXBlO1xuICAvKipcbiAgICogVGhlIHJlbGF5IFVSTHMgdGhhdCBhcmUgb2YgaW50ZXJlc3QgdG8gdGhpcyBpdGVtXG4gICAqL1xuICByZWxheVVybFNjb3JlcztcbiAgcmVhZFJlbGF5cztcbiAgd3JpdGVSZWxheXM7XG4gIGNvbnN0cnVjdG9yKHR5cGUpIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMucmVsYXlVcmxTY29yZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMucmVhZFJlbGF5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgdGhpcy53cml0ZVJlbGF5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIH1cbn07XG52YXIgT3V0Ym94VHJhY2tlciA9IGNsYXNzIGV4dGVuZHMgRXZlbnRFbWl0dGVyNyB7XG4gIGRhdGE7XG4gIG5kaztcbiAgZGVidWc7XG4gIGNvbnN0cnVjdG9yKG5kaykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5uZGsgPSBuZGs7XG4gICAgdGhpcy5kZWJ1ZyA9IG5kay5kZWJ1Zy5leHRlbmQoXCJvdXRib3gtdHJhY2tlclwiKTtcbiAgICB0aGlzLmRhdGEgPSBuZXcgTFJVQ2FjaGUyKHtcbiAgICAgIG1heFNpemU6IDFlNSxcbiAgICAgIGVudHJ5RXhwaXJhdGlvblRpbWVJbk1TOiAyICogNjAgKiAxZTNcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIGxpc3Qgb2YgdXNlcnMgdG8gdGhlIHRyYWNrZXIuXG4gICAqIEBwYXJhbSBpdGVtc1xuICAgKiBAcGFyYW0gc2tpcENhY2hlXG4gICAqL1xuICBhc3luYyB0cmFja1VzZXJzKGl0ZW1zLCBza2lwQ2FjaGUgPSBmYWxzZSkge1xuICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkgKz0gNDAwKSB7XG4gICAgICBjb25zdCBzbGljZSA9IGl0ZW1zLnNsaWNlKGksIGkgKyA0MDApO1xuICAgICAgY29uc3QgcHVia2V5cyA9IHNsaWNlLm1hcCgoaXRlbSkgPT4gZ2V0S2V5RnJvbUl0ZW0oaXRlbSkpLmZpbHRlcigocHVia2V5KSA9PiAhdGhpcy5kYXRhLmhhcyhwdWJrZXkpKTtcbiAgICAgIGlmIChwdWJrZXlzLmxlbmd0aCA9PT0gMCkgY29udGludWU7XG4gICAgICBmb3IgKGNvbnN0IHB1YmtleSBvZiBwdWJrZXlzKSB7XG4gICAgICAgIHRoaXMuZGF0YS5zZXQocHVia2V5LCBuZXcgT3V0Ym94SXRlbShcInVzZXJcIikpO1xuICAgICAgfVxuICAgICAgcHJvbWlzZXMucHVzaChcbiAgICAgICAgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICBnZXRSZWxheUxpc3RGb3JVc2VycyhwdWJrZXlzLCB0aGlzLm5kaywgc2tpcENhY2hlKS50aGVuKChyZWxheUxpc3RzKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtwdWJrZXksIHJlbGF5TGlzdF0gb2YgcmVsYXlMaXN0cykge1xuICAgICAgICAgICAgICBsZXQgb3V0Ym94SXRlbSA9IHRoaXMuZGF0YS5nZXQocHVia2V5KTtcbiAgICAgICAgICAgICAgb3V0Ym94SXRlbSA/Pz0gbmV3IE91dGJveEl0ZW0oXCJ1c2VyXCIpO1xuICAgICAgICAgICAgICBpZiAocmVsYXlMaXN0KSB7XG4gICAgICAgICAgICAgICAgb3V0Ym94SXRlbS5yZWFkUmVsYXlzID0gbmV3IFNldChcbiAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZShyZWxheUxpc3QucmVhZFJlbGF5VXJscylcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIG91dGJveEl0ZW0ud3JpdGVSZWxheXMgPSBuZXcgU2V0KFxuICAgICAgICAgICAgICAgICAgbm9ybWFsaXplKHJlbGF5TGlzdC53cml0ZVJlbGF5VXJscylcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcmVsYXlVcmwgb2Ygb3V0Ym94SXRlbS5yZWFkUmVsYXlzKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodGhpcy5uZGsucG9vbC5ibGFja2xpc3RSZWxheVVybHMuaGFzKHJlbGF5VXJsKSkge1xuICAgICAgICAgICAgICAgICAgICBvdXRib3hJdGVtLnJlYWRSZWxheXMuZGVsZXRlKHJlbGF5VXJsKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCByZWxheVVybCBvZiBvdXRib3hJdGVtLndyaXRlUmVsYXlzKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodGhpcy5uZGsucG9vbC5ibGFja2xpc3RSZWxheVVybHMuaGFzKHJlbGF5VXJsKSkge1xuICAgICAgICAgICAgICAgICAgICBvdXRib3hJdGVtLndyaXRlUmVsYXlzLmRlbGV0ZShyZWxheVVybCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5zZXQocHVia2V5LCBvdXRib3hJdGVtKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLmZpbmFsbHkocmVzb2x2ZSk7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ga2V5XG4gICAqIEBwYXJhbSBzY29yZVxuICAgKi9cbiAgdHJhY2soaXRlbSwgdHlwZSwgc2tpcENhY2hlID0gdHJ1ZSkge1xuICAgIGNvbnN0IGtleSA9IGdldEtleUZyb21JdGVtKGl0ZW0pO1xuICAgIHR5cGUgPz89IGdldFR5cGVGcm9tSXRlbShpdGVtKTtcbiAgICBsZXQgb3V0Ym94SXRlbSA9IHRoaXMuZGF0YS5nZXQoa2V5KTtcbiAgICBpZiAoIW91dGJveEl0ZW0pIHtcbiAgICAgIG91dGJveEl0ZW0gPSBuZXcgT3V0Ym94SXRlbSh0eXBlKTtcbiAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgTkRLVXNlcikge1xuICAgICAgICB0aGlzLnRyYWNrVXNlcnMoW2l0ZW1dKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dGJveEl0ZW07XG4gIH1cbn07XG5mdW5jdGlvbiBnZXRLZXlGcm9tSXRlbShpdGVtKSB7XG4gIGlmIChpdGVtIGluc3RhbmNlb2YgTkRLVXNlcikge1xuICAgIHJldHVybiBpdGVtLnB1YmtleTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gaXRlbTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0VHlwZUZyb21JdGVtKGl0ZW0pIHtcbiAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBOREtVc2VyKSB7XG4gICAgcmV0dXJuIFwidXNlclwiO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBcImtpbmRcIjtcbiAgfVxufVxuXG4vLyBzcmMvcmVsYXkvc2V0cy91dGlscy50c1xuZnVuY3Rpb24gY29ycmVjdFJlbGF5U2V0KHJlbGF5U2V0LCBwb29sKSB7XG4gIGNvbnN0IGNvbm5lY3RlZFJlbGF5cyA9IHBvb2wuY29ubmVjdGVkUmVsYXlzKCk7XG4gIGNvbnN0IGluY2x1ZGVzQ29ubmVjdGVkUmVsYXkgPSBBcnJheS5mcm9tKHJlbGF5U2V0LnJlbGF5cykuc29tZSgocmVsYXkpID0+IHtcbiAgICByZXR1cm4gY29ubmVjdGVkUmVsYXlzLm1hcCgocikgPT4gci51cmwpLmluY2x1ZGVzKHJlbGF5LnVybCk7XG4gIH0pO1xuICBpZiAoIWluY2x1ZGVzQ29ubmVjdGVkUmVsYXkpIHtcbiAgICBmb3IgKGNvbnN0IHJlbGF5IG9mIGNvbm5lY3RlZFJlbGF5cykge1xuICAgICAgcmVsYXlTZXQuYWRkUmVsYXkocmVsYXkpO1xuICAgIH1cbiAgfVxuICBpZiAoY29ubmVjdGVkUmVsYXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAoY29uc3QgcmVsYXkgb2YgcG9vbC5yZWxheXMudmFsdWVzKCkpIHtcbiAgICAgIHJlbGF5U2V0LmFkZFJlbGF5KHJlbGF5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlbGF5U2V0O1xufVxuXG4vLyBzcmMvbmRrL2ZldGNoLWV2ZW50LWZyb20tdGFnLnRzXG5mdW5jdGlvbiBpc1ZhbGlkSGludChoaW50KSB7XG4gIGlmICghaGludCB8fCBoaW50ID09PSBcIlwiKSByZXR1cm4gZmFsc2U7XG4gIHRyeSB7XG4gICAgbmV3IFVSTChoaW50KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hFdmVudEZyb21UYWcodGFnLCBvcmlnaW5hbEV2ZW50LCBzdWJPcHRzLCBmYWxsYmFjayA9IHtcbiAgdHlwZTogXCJ0aW1lb3V0XCJcbn0pIHtcbiAgY29uc3QgZDQgPSB0aGlzLmRlYnVnLmV4dGVuZChcImZldGNoLWV2ZW50LWZyb20tdGFnXCIpO1xuICBjb25zdCBbXywgaWQsIGhpbnRdID0gdGFnO1xuICBzdWJPcHRzID0ge307XG4gIGQ0KFwiZmV0Y2hpbmcgZXZlbnQgZnJvbSB0YWdcIiwgdGFnLCBzdWJPcHRzLCBmYWxsYmFjayk7XG4gIGNvbnN0IGF1dGhvclJlbGF5cyA9IGdldFJlbGF5c0ZvclN5bmModGhpcywgb3JpZ2luYWxFdmVudC5wdWJrZXkpO1xuICBpZiAoYXV0aG9yUmVsYXlzICYmIGF1dGhvclJlbGF5cy5zaXplID4gMCkge1xuICAgIGQ0KFwiZmV0Y2hpbmcgZXZlbnQgZnJvbSBhdXRob3IgcmVsYXlzICVvXCIsIEFycmF5LmZyb20oYXV0aG9yUmVsYXlzKSk7XG4gICAgY29uc3QgcmVsYXlTZXQyID0gTkRLUmVsYXlTZXQuZnJvbVJlbGF5VXJscyhBcnJheS5mcm9tKGF1dGhvclJlbGF5cyksIHRoaXMpO1xuICAgIGNvbnN0IGV2ZW50MiA9IGF3YWl0IHRoaXMuZmV0Y2hFdmVudChpZCwgc3ViT3B0cywgcmVsYXlTZXQyKTtcbiAgICBpZiAoZXZlbnQyKSByZXR1cm4gZXZlbnQyO1xuICB9IGVsc2Uge1xuICAgIGQ0KFwibm8gYXV0aG9yIHJlbGF5cyBmb3VuZCBmb3IgJXNcIiwgb3JpZ2luYWxFdmVudC5wdWJrZXksIG9yaWdpbmFsRXZlbnQpO1xuICB9XG4gIGNvbnN0IHJlbGF5U2V0ID0gY2FsY3VsYXRlUmVsYXlTZXRzRnJvbUZpbHRlcnModGhpcywgW3sgaWRzOiBbaWRdIH1dLCB0aGlzLnBvb2wpO1xuICBkNChcImZldGNoaW5nIGV2ZW50IHdpdGhvdXQgcmVsYXkgaGludFwiLCByZWxheVNldCk7XG4gIGNvbnN0IGV2ZW50ID0gYXdhaXQgdGhpcy5mZXRjaEV2ZW50KGlkLCBzdWJPcHRzKTtcbiAgaWYgKGV2ZW50KSByZXR1cm4gZXZlbnQ7XG4gIGlmIChoaW50ICYmIGhpbnQgIT09IFwiXCIpIHtcbiAgICBjb25zdCBldmVudDIgPSBhd2FpdCB0aGlzLmZldGNoRXZlbnQoXG4gICAgICBpZCxcbiAgICAgIHN1Yk9wdHMsXG4gICAgICB0aGlzLnBvb2wuZ2V0UmVsYXkoaGludCwgdHJ1ZSwgdHJ1ZSwgW3sgaWRzOiBbaWRdIH1dKVxuICAgICk7XG4gICAgaWYgKGV2ZW50MikgcmV0dXJuIGV2ZW50MjtcbiAgfVxuICBsZXQgcmVzdWx0ID0gdm9pZCAwO1xuICBjb25zdCByZWxheSA9IGlzVmFsaWRIaW50KGhpbnQpID8gdGhpcy5wb29sLmdldFJlbGF5KGhpbnQsIGZhbHNlLCB0cnVlLCBbeyBpZHM6IFtpZF0gfV0pIDogdm9pZCAwO1xuICBjb25zdCBmZXRjaE1heWJlV2l0aFJlbGF5SGludCA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgdGhpcy5mZXRjaEV2ZW50KGlkLCBzdWJPcHRzLCByZWxheSkudGhlbihyZXNvbHZlKTtcbiAgfSk7XG4gIGlmICghaXNWYWxpZEhpbnQoaGludCkgfHwgZmFsbGJhY2sudHlwZSA9PT0gXCJub25lXCIpIHtcbiAgICByZXR1cm4gZmV0Y2hNYXliZVdpdGhSZWxheUhpbnQ7XG4gIH1cbiAgY29uc3QgZmFsbGJhY2tGZXRjaFByb21pc2UgPSBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSkgPT4ge1xuICAgIGNvbnN0IGZhbGxiYWNrUmVsYXlTZXQgPSBmYWxsYmFjay5yZWxheVNldDtcbiAgICBjb25zdCB0aW1lb3V0ID0gZmFsbGJhY2sudGltZW91dCA/PyAxNTAwO1xuICAgIGNvbnN0IHRpbWVvdXRQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUyKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUyLCB0aW1lb3V0KSk7XG4gICAgaWYgKGZhbGxiYWNrLnR5cGUgPT09IFwidGltZW91dFwiKSBhd2FpdCB0aW1lb3V0UHJvbWlzZTtcbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGQ0KFwiZmFsbGJhY2sgZmV0Y2ggdHJpZ2dlcmVkXCIpO1xuICAgICAgY29uc3QgZmFsbGJhY2tFdmVudCA9IGF3YWl0IHRoaXMuZmV0Y2hFdmVudChpZCwgc3ViT3B0cywgZmFsbGJhY2tSZWxheVNldCk7XG4gICAgICByZXNvbHZlKGZhbGxiYWNrRXZlbnQpO1xuICAgIH1cbiAgfSk7XG4gIHN3aXRjaCAoZmFsbGJhY2sudHlwZSkge1xuICAgIGNhc2UgXCJ0aW1lb3V0XCI6XG4gICAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtmZXRjaE1heWJlV2l0aFJlbGF5SGludCwgZmFsbGJhY2tGZXRjaFByb21pc2VdKTtcbiAgICBjYXNlIFwiZW9zZVwiOlxuICAgICAgcmVzdWx0ID0gYXdhaXQgZmV0Y2hNYXliZVdpdGhSZWxheUhpbnQ7XG4gICAgICBpZiAocmVzdWx0KSByZXR1cm4gcmVzdWx0O1xuICAgICAgcmV0dXJuIGZhbGxiYWNrRmV0Y2hQcm9taXNlO1xuICB9XG59XG5cbi8vIHNyYy9tZWRpYS9pbmRleC50c1xudmFyIFNQRUNfUEFUSCA9IFwiLy53ZWxsLWtub3duL25vc3RyL25pcDk2Lmpzb25cIjtcbnZhciBOaXA5NiA9IGNsYXNzIHtcbiAgbmRrO1xuICBzcGVjO1xuICB1cmw7XG4gIG5pcDk4UmVxdWlyZWQgPSBmYWxzZTtcbiAgLyoqXG4gICAqIEBwYXJhbSBkb21haW4gZG9tYWluIG9mIHRoZSBOSVA5NiBzZXJ2aWNlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihkb21haW4sIG5kaykge1xuICAgIHRoaXMudXJsID0gYGh0dHBzOi8vJHtkb21haW59JHtTUEVDX1BBVEh9YDtcbiAgICB0aGlzLm5kayA9IG5kaztcbiAgfVxuICBhc3luYyBwcmVwYXJlVXBsb2FkKGJsb2IsIGh0dHBWZXJiID0gXCJQT1NUXCIpIHtcbiAgICB0aGlzLnZhbGlkYXRlSHR0cEZldGNoKCk7XG4gICAgaWYgKCF0aGlzLnNwZWMpIGF3YWl0IHRoaXMuZmV0Y2hTcGVjKCk7XG4gICAgaWYgKCF0aGlzLnNwZWMpIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBmZXRjaCBOSVA5NiBzcGVjXCIpO1xuICAgIGxldCBoZWFkZXJzID0ge307XG4gICAgaWYgKHRoaXMubmlwOThSZXF1aXJlZCkge1xuICAgICAgY29uc3QgYXV0aG9yaXphdGlvbkhlYWRlciA9IGF3YWl0IHRoaXMuZ2VuZXJhdGVOaXA5OEhlYWRlcihcbiAgICAgICAgdGhpcy5zcGVjLmFwaV91cmwsXG4gICAgICAgIGh0dHBWZXJiLFxuICAgICAgICBibG9iXG4gICAgICApO1xuICAgICAgaGVhZGVycyA9IHsgQXV0aG9yaXphdGlvbjogYXV0aG9yaXphdGlvbkhlYWRlciB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdXJsOiB0aGlzLnNwZWMuYXBpX3VybCxcbiAgICAgIGhlYWRlcnNcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBQcm92aWRlcyBhbiBYTUxIdHRwUmVxdWVzdC1iYXNlZCB1cGxvYWQgbWV0aG9kIGZvciBicm93c2Vycy5cbiAgICogQGV4YW1wbGVcbiAgICogY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAqIHhoci51cGxvYWQuYWRkRXZlbnRMaXN0ZW5lcihcInByb2dyZXNzXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICogICAgY29uc3QgcGVyY2VudENvbXBsZXRlID0gZS5sb2FkZWQgLyBlLnRvdGFsO1xuICAgKiAgICBjb25zb2xlLmxvZyhwZXJjZW50Q29tcGxldGUpO1xuICAgKiB9KTtcbiAgICogY29uc3QgbmlwOTYgPSBuZGsuZ2V0TmlwOTYoXCJub3N0cmNoZWNrLm1lXCIpO1xuICAgKiBjb25zdCBibG9iID0gbmV3IEJsb2IoW1wiSGVsbG8sIHdvcmxkIVwiXSwgeyB0eXBlOiBcInRleHQvcGxhaW5cIiB9KTtcbiAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBuaXA5Ni54aHJVcGxvYWQoeGhyLCBibG9iKTtcbiAgICogY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICAgKiBAcmV0dXJucyBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHVwbG9hZCByZXNwb25zZVxuICAgKi9cbiAgYXN5bmMgeGhyVXBsb2FkKHhociwgYmxvYikge1xuICAgIGNvbnN0IGh0dHBWZXJiID0gXCJQT1NUXCI7XG4gICAgY29uc3QgeyB1cmwsIGhlYWRlcnMgfSA9IGF3YWl0IHRoaXMucHJlcGFyZVVwbG9hZChibG9iLCBodHRwVmVyYik7XG4gICAgeGhyLm9wZW4oaHR0cFZlcmIsIHVybCwgdHJ1ZSk7XG4gICAgaWYgKGhlYWRlcnNbXCJBdXRob3JpemF0aW9uXCJdKSB7XG4gICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkF1dGhvcml6YXRpb25cIiwgaGVhZGVyc1tcIkF1dGhvcml6YXRpb25cIl0pO1xuICAgIH1cbiAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgIGZvcm1EYXRhLmFwcGVuZChcImZpbGVcIiwgYmxvYik7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDApIHtcbiAgICAgICAgICByZXNvbHZlKEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlVGV4dCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoeGhyLnN0YXR1c1RleHQpKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJOZXR3b3JrIEVycm9yXCIpKTtcbiAgICAgIH07XG4gICAgICB4aHIuc2VuZChmb3JtRGF0YSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEZldGNoLWJhc2VkIHVwbG9hZCBtZXRob2QuIE5vdGUgdGhhdCB0aGlzIHdpbGwgdXNlIE5ESydzIGh0dHBGZXRjaFxuICAgKiBAcGFyYW0gYmxvYlxuICAgKiBAcmV0dXJucyBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHVwbG9hZCByZXNwb25zZVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb25zdCBuaXA5NiA9IG5kay5nZXROaXA5NihcIm5vc3RyY2hlY2subWVcIik7XG4gICAqIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbXCJIZWxsbywgd29ybGQhXCJdLCB7IHR5cGU6IFwidGV4dC9wbGFpblwiIH0pO1xuICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IG5pcDk2LnVwbG9hZChibG9iKTtcbiAgICogY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICAgKi9cbiAgYXN5bmMgdXBsb2FkKGJsb2IpIHtcbiAgICBjb25zdCBodHRwVmVyYiA9IFwiUE9TVFwiO1xuICAgIGNvbnN0IHsgdXJsLCBoZWFkZXJzIH0gPSBhd2FpdCB0aGlzLnByZXBhcmVVcGxvYWQoYmxvYiwgaHR0cFZlcmIpO1xuICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgZm9ybURhdGEuYXBwZW5kKFwiZmlsZVwiLCBibG9iKTtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLm5kay5odHRwRmV0Y2godGhpcy5zcGVjLmFwaV91cmwsIHtcbiAgICAgIG1ldGhvZDogaHR0cFZlcmIsXG4gICAgICBoZWFkZXJzLFxuICAgICAgYm9keTogZm9ybURhdGFcbiAgICB9KTtcbiAgICBpZiAocmVzLnN0YXR1cyAhPT0gMjAwKSB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byB1cGxvYWQgZmlsZSB0byAke3VybH1gKTtcbiAgICBjb25zdCBqc29uID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICBpZiAoanNvbi5zdGF0dXMgIT09IFwic3VjY2Vzc1wiKSB0aHJvdyBuZXcgRXJyb3IoanNvbi5tZXNzYWdlKTtcbiAgICByZXR1cm4ganNvbjtcbiAgfVxuICB2YWxpZGF0ZUh0dHBGZXRjaCgpIHtcbiAgICBpZiAoIXRoaXMubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJOREsgaXMgcmVxdWlyZWQgdG8gZmV0Y2ggTklQOTYgc3BlY1wiKTtcbiAgICBpZiAoIXRoaXMubmRrLmh0dHBGZXRjaClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5ESyBtdXN0IGhhdmUgYW4gaHR0cEZldGNoIG1ldGhvZCB0byBmZXRjaCBOSVA5NiBzcGVjXCIpO1xuICB9XG4gIGFzeW5jIGZldGNoU3BlYygpIHtcbiAgICB0aGlzLnZhbGlkYXRlSHR0cEZldGNoKCk7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5uZGsuaHR0cEZldGNoKHRoaXMudXJsKTtcbiAgICBpZiAocmVzLnN0YXR1cyAhPT0gMjAwKSB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCBOSVA5NiBzcGVjIGZyb20gJHt0aGlzLnVybH1gKTtcbiAgICBjb25zdCBzcGVjID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICBpZiAoIXNwZWMpIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHBhcnNlIE5JUDk2IHNwZWMgZnJvbSAke3RoaXMudXJsfWApO1xuICAgIHRoaXMuc3BlYyA9IHNwZWM7XG4gICAgdGhpcy5uaXA5OFJlcXVpcmVkID0gdGhpcy5zcGVjLnBsYW5zLmZyZWUuaXNfbmlwOThfcmVxdWlyZWQ7XG4gIH1cbiAgYXN5bmMgZ2VuZXJhdGVOaXA5OEhlYWRlcihyZXF1ZXN0VXJsLCBodHRwTWV0aG9kLCBibG9iKSB7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgTkRLRXZlbnQodGhpcy5uZGssIHtcbiAgICAgIGtpbmQ6IDI3MjM1IC8qIEh0dHBBdXRoICovLFxuICAgICAgdGFnczogW1xuICAgICAgICBbXCJ1XCIsIHJlcXVlc3RVcmxdLFxuICAgICAgICBbXCJtZXRob2RcIiwgaHR0cE1ldGhvZF1cbiAgICAgIF1cbiAgICB9KTtcbiAgICBpZiAoW1wiUE9TVFwiLCBcIlBVVFwiLCBcIlBBVENIXCJdLmluY2x1ZGVzKGh0dHBNZXRob2QpKSB7XG4gICAgICBjb25zdCBzaGEyNTZIYXNoID0gYXdhaXQgdGhpcy5jYWxjdWxhdGVTaGEyNTYoYmxvYik7XG4gICAgICBldmVudC50YWdzLnB1c2goW1wicGF5bG9hZFwiLCBzaGEyNTZIYXNoXSk7XG4gICAgfVxuICAgIGF3YWl0IGV2ZW50LnNpZ24oKTtcbiAgICBjb25zdCBlbmNvZGVkRXZlbnQgPSBidG9hKEpTT04uc3RyaW5naWZ5KGV2ZW50LnJhd0V2ZW50KCkpKTtcbiAgICByZXR1cm4gYE5vc3RyICR7ZW5jb2RlZEV2ZW50fWA7XG4gIH1cbiAgYXN5bmMgY2FsY3VsYXRlU2hhMjU2KGJsb2IpIHtcbiAgICBjb25zdCBidWZmZXIgPSBhd2FpdCBibG9iLmFycmF5QnVmZmVyKCk7XG4gICAgY29uc3QgaGFzaEJ1ZmZlciA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuZGlnZXN0KFwiU0hBLTI1NlwiLCBidWZmZXIpO1xuICAgIGNvbnN0IGhhc2hBcnJheSA9IEFycmF5LmZyb20obmV3IFVpbnQ4QXJyYXkoaGFzaEJ1ZmZlcikpO1xuICAgIGNvbnN0IGhhc2hIZXggPSBoYXNoQXJyYXkubWFwKChiKSA9PiBiLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIikpLmpvaW4oXCJcIik7XG4gICAgcmV0dXJuIGhhc2hIZXg7XG4gIH1cbn07XG5cbi8vIHNyYy9uZGsvcXVldWUvaW5kZXgudHNcbnZhciBRdWV1ZSA9IGNsYXNzIHtcbiAgcXVldWUgPSBbXTtcbiAgbWF4Q29uY3VycmVuY3k7XG4gIHByb2Nlc3NpbmcgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBwcm9taXNlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0cnVjdG9yKG5hbWUsIG1heENvbmN1cnJlbmN5KSB7XG4gICAgdGhpcy5tYXhDb25jdXJyZW5jeSA9IG1heENvbmN1cnJlbmN5O1xuICB9XG4gIGFkZChpdGVtKSB7XG4gICAgaWYgKHRoaXMucHJvbWlzZXMuaGFzKGl0ZW0uaWQpKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9taXNlcy5nZXQoaXRlbS5pZCk7XG4gICAgfSBlbHNlIHtcbiAgICB9XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMucXVldWUucHVzaCh7XG4gICAgICAgIC4uLml0ZW0sXG4gICAgICAgIGZ1bmM6ICgpID0+IGl0ZW0uZnVuYygpLnRoZW4oXG4gICAgICAgICAgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgfSk7XG4gICAgICB0aGlzLnByb2Nlc3MoKTtcbiAgICB9KTtcbiAgICB0aGlzLnByb21pc2VzLnNldChpdGVtLmlkLCBwcm9taXNlKTtcbiAgICBwcm9taXNlLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgdGhpcy5wcm9taXNlcy5kZWxldGUoaXRlbS5pZCk7XG4gICAgICB0aGlzLnByb2Nlc3NpbmcuZGVsZXRlKGl0ZW0uaWQpO1xuICAgICAgdGhpcy5wcm9jZXNzKCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cbiAgcHJvY2VzcygpIHtcbiAgICBpZiAodGhpcy5wcm9jZXNzaW5nLnNpemUgPj0gdGhpcy5tYXhDb25jdXJyZW5jeSB8fCB0aGlzLnF1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpdGVtID0gdGhpcy5xdWV1ZS5zaGlmdCgpO1xuICAgIGlmICghaXRlbSB8fCB0aGlzLnByb2Nlc3NpbmcuaGFzKGl0ZW0uaWQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucHJvY2Vzc2luZy5hZGQoaXRlbS5pZCk7XG4gICAgaXRlbS5mdW5jKCk7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5xdWV1ZSA9IFtdO1xuICB9XG4gIGNsZWFyUHJvY2Vzc2luZygpIHtcbiAgICB0aGlzLnByb2Nlc3NpbmcuY2xlYXIoKTtcbiAgfVxuICBjbGVhckFsbCgpIHtcbiAgICB0aGlzLmNsZWFyKCk7XG4gICAgdGhpcy5jbGVhclByb2Nlc3NpbmcoKTtcbiAgfVxuICBsZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVldWUubGVuZ3RoO1xuICB9XG59O1xuXG4vLyBzcmMvc3Vic2NyaXB0aW9uL21hbmFnZXIudHNcbmltcG9ydCB7IG1hdGNoRmlsdGVycyB9IGZyb20gXCJub3N0ci10b29sc1wiO1xudmFyIE5ES1N1YnNjcmlwdGlvbk1hbmFnZXIgPSBjbGFzcyB7XG4gIHN1YnNjcmlwdGlvbnM7XG4gIHNlZW5FdmVudHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG4gIGFkZChzdWIpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuc2V0KHN1Yi5pbnRlcm5hbElkLCBzdWIpO1xuICAgIGlmIChzdWIub25TdG9wcGVkKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIlNVQi1NQU5BR0VSIEJVRzogU3Vic2NyaXB0aW9uIGFscmVhZHkgaGFkIG9uU3RvcHBlZCEgXFx1ezFGOTE0fVwiLCBzdWIuaW50ZXJuYWxJZCk7XG4gICAgfVxuICAgIHN1Yi5vblN0b3BwZWQgPSAoKSA9PiB7XG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZGVsZXRlKHN1Yi5pbnRlcm5hbElkKTtcbiAgICB9O1xuICAgIHN1Yi5vbihcImNsb3NlXCIsICgpID0+IHtcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5kZWxldGUoc3ViLmludGVybmFsSWQpO1xuICAgIH0pO1xuICB9XG4gIHNlZW5FdmVudChldmVudElkLCByZWxheSkge1xuICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLnNlZW5FdmVudHMuZ2V0KGV2ZW50SWQpIHx8IFtdO1xuICAgIGN1cnJlbnQucHVzaChyZWxheSk7XG4gICAgdGhpcy5zZWVuRXZlbnRzLnNldChldmVudElkLCBjdXJyZW50KTtcbiAgfVxuICAvKipcbiAgICogV2hlbmV2ZXIgYW4gZXZlbnQgY29tZXMgaW4sIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkLlxuICAgKiBUaGlzIGZ1bmN0aW9uIG1hdGNoZXMgdGhlIHJlY2VpdmVkIGV2ZW50IGFnYWluc3QgYWxsIHRoZVxuICAgKiBrbm93biAoaS5lLiBhY3RpdmUpIE5ES1N1YnNjcmlwdGlvbnMsIGFuZCBpZiBpdCBtYXRjaGVzLFxuICAgKiBpdCBzZW5kcyB0aGUgZXZlbnQgdG8gdGhlIHN1YnNjcmlwdGlvbi5cbiAgICogXG4gICAqIFRoaXMgaXMgdGhlIHNpbmdsZSBwbGFjZSBpbiB0aGUgY29kZWJhc2UgdGhhdCBtYXRjaGVzXG4gICAqIGluY29taW5nIGV2ZW50cyB3aXRoIHBhcnRpZXMgaW50ZXJlc3RlZCBpbiB0aGUgZXZlbnQuXG4gICAqIFxuICAgKiBUaGlzIGlzIGFsc28gd2hhdCBhbGxvd3MgZm9yIHJlYWN0aXZpdHkgaW4gTkRLIGFwcHMsIHN1Y2ggdGhhdFxuICAgKiB3aGVuZXZlciBhbiBhY3RpdmUgc3Vic2NyaXB0aW9uIHJlY2VpdmVzIGFuIGV2ZW50IHRoYXQgc29tZVxuICAgKiBvdGhlciBhY3RpdmUgc3Vic2NyaXB0aW9uIHdvdWxkIHdhbnQgdG8gcmVjZWl2ZSwgYm90aCByZWNlaXZlIGl0LlxuICAgKiBcbiAgICogVE9ETyBUaGlzIGFsc28gYWxsb3dzIGZvciBzdWJzY3JpcHRpb25zIHRoYXQgb3ZlcmxhcCBpbiBtZWFuaW5nXG4gICAqIHRvIGJlIGNvbGxhcHNlZCBpbnRvIG9uZS5cbiAgICogXG4gICAqIEkuZS4gaWYgYSBzdWJzY3JpcHRpb24gd2l0aCBmaWx0ZXI6IGtpbmRzOiBbMV0sIGF1dGhvcnM6IFthbGljZV1cbiAgICogaXMgY3JlYXRlZCBhbmQgRU9TRXMsIGFuZCB0aGVuIGEgc3Vic2VxdWVudCBzdWJzY3JpcHRpb24gd2l0aFxuICAgKiBraW5kczogWzFdLCBhdXRob3JzOiBbYWxpY2VdIGlzIGNyZWF0ZWQsIG9uY2UgdGhlIHNlY29uZCBzdWJzY3JpcHRpb25cbiAgICogRU9TRXMgd2UgY2FuIHNhZmVseSBjbG9zZSBpdCwgaW5jcmVtZW50IGl0cyByZWZDb3VudCBhbmQgY2xvc2UgaXQsXG4gICAqIGFuZCB3aGVuIHRoZSBmaXJzdCBzdWJzY3JpcHRpb24gcmVjZWl2ZXMgYSBuZXcgZXZlbnQgZnJvbSBBbGljZSB0aGlzXG4gICAqIGNvZGUgd2lsbCBtYWtlIHRoZSBzZWNvbmQgc3Vic2NyaXB0aW9uIHJlY2VpdmUgdGhlIGV2ZW50IGV2ZW4gdGhvdWdoXG4gICAqIGl0IGhhcyBubyBhY3RpdmUgc3Vic2NyaXB0aW9uIG9uIGEgcmVsYXkuXG4gICAqIEBwYXJhbSBldmVudCBSYXcgZXZlbnQgcmVjZWl2ZWQgZnJvbSBhIHJlbGF5XG4gICAqIEBwYXJhbSByZWxheSBSZWxheSB0aGF0IHNlbnQgdGhlIGV2ZW50XG4gICAqIEBwYXJhbSBvcHRpbWlzdGljUHVibGlzaCBXaGV0aGVyIHRoZSBldmVudCBpcyBjb21pbmcgZnJvbSBhbiBvcHRpbWlzdGljIHB1Ymxpc2hcbiAgICovXG4gIGRpc3BhdGNoRXZlbnQoZXZlbnQsIHJlbGF5LCBvcHRpbWlzdGljUHVibGlzaCA9IGZhbHNlKSB7XG4gICAgaWYgKHJlbGF5KSB0aGlzLnNlZW5FdmVudChldmVudC5pZCwgcmVsYXkpO1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbnMgPSB0aGlzLnN1YnNjcmlwdGlvbnMudmFsdWVzKCk7XG4gICAgY29uc3QgbWF0Y2hpbmdTdWJzID0gW107XG4gICAgZm9yIChjb25zdCBzdWIgb2Ygc3Vic2NyaXB0aW9ucykge1xuICAgICAgaWYgKG1hdGNoRmlsdGVycyhzdWIuZmlsdGVycywgZXZlbnQpKSB7XG4gICAgICAgIG1hdGNoaW5nU3Vicy5wdXNoKHN1Yik7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3Qgc3ViIG9mIG1hdGNoaW5nU3Vicykge1xuICAgICAgc3ViLmV2ZW50UmVjZWl2ZWQoZXZlbnQsIHJlbGF5LCBmYWxzZSwgb3B0aW1pc3RpY1B1Ymxpc2gpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL25kay9hY3RpdmUtdXNlci50c1xuaW1wb3J0IGNyZWF0ZURlYnVnMyBmcm9tIFwiZGVidWdcIjtcbnZhciBkZWJ1ZzYgPSBjcmVhdGVEZWJ1ZzMoXCJuZGs6YWN0aXZlLXVzZXJcIik7XG5hc3luYyBmdW5jdGlvbiBnZXRVc2VyUmVsYXlMaXN0KHVzZXIpIHtcbiAgaWYgKCF0aGlzLmF1dG9Db25uZWN0VXNlclJlbGF5cykgcmV0dXJuO1xuICBjb25zdCB1c2VyUmVsYXlzID0gYXdhaXQgZ2V0UmVsYXlMaXN0Rm9yVXNlcih1c2VyLnB1YmtleSwgdGhpcyk7XG4gIGlmICghdXNlclJlbGF5cykgcmV0dXJuO1xuICBmb3IgKGNvbnN0IHVybCBvZiB1c2VyUmVsYXlzLnJlbGF5cykge1xuICAgIGxldCByZWxheSA9IHRoaXMucG9vbC5yZWxheXMuZ2V0KHVybCk7XG4gICAgaWYgKCFyZWxheSkge1xuICAgICAgcmVsYXkgPSBuZXcgTkRLUmVsYXkodXJsLCB0aGlzLnJlbGF5QXV0aERlZmF1bHRQb2xpY3ksIHRoaXMpO1xuICAgICAgdGhpcy5wb29sLmFkZFJlbGF5KHJlbGF5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVzZXJSZWxheXM7XG59XG5hc3luYyBmdW5jdGlvbiBzZXRBY3RpdmVVc2VyKHVzZXIpIHtcbiAgY29uc3QgcG9vbCA9IHRoaXMub3V0Ym94UG9vbCB8fCB0aGlzLnBvb2w7XG4gIGlmIChwb29sLmNvbm5lY3RlZFJlbGF5cy5sZW5ndGggPiAwKSB7XG4gICAgc2V0QWN0aXZlVXNlckNvbm5lY3RlZC5jYWxsKHRoaXMsIHVzZXIpO1xuICB9IGVsc2Uge1xuICAgIHBvb2wub25jZShcImNvbm5lY3RcIiwgKCkgPT4ge1xuICAgICAgc2V0QWN0aXZlVXNlckNvbm5lY3RlZC5jYWxsKHRoaXMsIHVzZXIpO1xuICAgIH0pO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBzZXRBY3RpdmVVc2VyQ29ubmVjdGVkKHVzZXIpIHtcbiAgY29uc3QgdXNlclJlbGF5cyA9IGF3YWl0IGdldFVzZXJSZWxheUxpc3QuY2FsbCh0aGlzLCB1c2VyKTtcbiAgY29uc3QgZmlsdGVycyA9IFtcbiAgICB7XG4gICAgICBraW5kczogWzEwMDA2IC8qIEJsb2NrUmVsYXlMaXN0ICovXSxcbiAgICAgIGF1dGhvcnM6IFt1c2VyLnB1YmtleV1cbiAgICB9XG4gIF07XG4gIGlmICh0aGlzLmF1dG9GZXRjaFVzZXJNdXRlbGlzdCkge1xuICAgIGZpbHRlcnNbMF0ua2luZHMucHVzaCgxZTQgLyogTXV0ZUxpc3QgKi8pO1xuICB9XG4gIGNvbnN0IHJlbGF5U2V0ID0gdXNlclJlbGF5cyA/IHVzZXJSZWxheXMucmVsYXlTZXQgOiB2b2lkIDA7XG4gIGNvbnN0IHN1YiA9IHRoaXMuc3Vic2NyaWJlKFxuICAgIGZpbHRlcnMsXG4gICAgeyBzdWJJZDogXCJhY3RpdmUtdXNlci1zZXR0aW5nc1wiLCBjbG9zZU9uRW9zZTogdHJ1ZSB9LFxuICAgIHJlbGF5U2V0LFxuICAgIGZhbHNlXG4gICk7XG4gIGNvbnN0IGV2ZW50cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIHN1Yi5vbihcImV2ZW50XCIsIChldmVudCkgPT4ge1xuICAgIGNvbnN0IHByZXZFdmVudCA9IGV2ZW50cy5nZXQoZXZlbnQua2luZCk7XG4gICAgaWYgKHByZXZFdmVudCAmJiBwcmV2RXZlbnQuY3JlYXRlZF9hdCA+PSBldmVudC5jcmVhdGVkX2F0KSByZXR1cm47XG4gICAgZXZlbnRzLnNldChldmVudC5raW5kLCBldmVudCk7XG4gIH0pO1xuICBzdWIub24oXCJlb3NlXCIsICgpID0+IHtcbiAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIGV2ZW50cy52YWx1ZXMoKSkge1xuICAgICAgcHJvY2Vzc0V2ZW50LmNhbGwodGhpcywgZXZlbnQpO1xuICAgIH1cbiAgfSk7XG4gIHN1Yi5zdGFydCgpO1xufVxuYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0V2ZW50KGV2ZW50KSB7XG4gIGlmIChldmVudC5raW5kID09PSAxMDAwNiAvKiBCbG9ja1JlbGF5TGlzdCAqLykge1xuICAgIHByb2Nlc3NCbG9ja1JlbGF5TGlzdC5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgfSBlbHNlIGlmIChldmVudC5raW5kID09PSAxZTQgLyogTXV0ZUxpc3QgKi8pIHtcbiAgICBwcm9jZXNzTXV0ZUxpc3QuY2FsbCh0aGlzLCBldmVudCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHByb2Nlc3NCbG9ja1JlbGF5TGlzdChldmVudCkge1xuICBjb25zdCBsaXN0ID0gbGlzdHNfZGVmYXVsdC5mcm9tKGV2ZW50KTtcbiAgZm9yIChjb25zdCBpdGVtIG9mIGxpc3QuaXRlbXMpIHtcbiAgICB0aGlzLnBvb2wuYmxhY2tsaXN0UmVsYXlVcmxzLmFkZChpdGVtWzBdKTtcbiAgfVxuICBkZWJ1ZzYoXCJBZGRlZCAlZCByZWxheXMgdG8gcmVsYXkgYmxhY2tsaXN0XCIsIGxpc3QuaXRlbXMubGVuZ3RoKTtcbn1cbmZ1bmN0aW9uIHByb2Nlc3NNdXRlTGlzdChtdXRlTGlzdCkge1xuICBjb25zdCBsaXN0ID0gbGlzdHNfZGVmYXVsdC5mcm9tKG11dGVMaXN0KTtcbiAgZm9yIChjb25zdCBpdGVtIG9mIGxpc3QuaXRlbXMpIHtcbiAgICB0aGlzLm11dGVkSWRzLnNldChpdGVtWzFdLCBpdGVtWzBdKTtcbiAgfVxuICBkZWJ1ZzYoXCJBZGRlZCAlZCB1c2VycyB0byBtdXRlIGxpc3RcIiwgbGlzdC5pdGVtcy5sZW5ndGgpO1xufVxuXG4vLyBzcmMvbmRrL2luZGV4LnRzXG52YXIgREVGQVVMVF9PVVRCT1hfUkVMQVlTID0gW1wid3NzOi8vcHVycGxlcGFnLmVzL1wiLCBcIndzczovL25vcy5sb2wvXCJdO1xudmFyIERFRkFVTFRfQkxBQ0tMSVNURURfUkVMQVlTID0gW1xuICBcIndzczovL2JyYi5pby9cIixcbiAgLy8gQlJCXG4gIFwid3NzOi8vbm9zdHIubXV0aW55d2FsbGV0LmNvbS9cIlxuICAvLyBEb24ndCB0cnkgdG8gcmVhZCBmcm9tIHRoaXMgcmVsYXkgc2luY2UgaXQncyBhIHdyaXRlLW9ubHkgcmVsYXlcbiAgLy8gXCJ3c3M6Ly9wdXJwbGVwYWcuZXMvXCIsIC8vIFRoaXMgaXMgYSBoYWNrLCBzaW5jZSB0aGlzIGlzIGEgbW9zdGx5IHJlYWQtb25seSByZWxheSwgYnV0IG5vdCBmdWxseS4gT25jZSB3ZSBoYXZlIHJlbGF5IHJvdXRpbmcgdGhpcyBjYW4gYmUgcmVtb3ZlZCBzbyBpdCBvbmx5IHJlY2VpdmVzIHRoZSBzdXBwb3J0ZWQga2luZHNcbl07XG52YXIgTkRLID0gY2xhc3MgZXh0ZW5kcyBFdmVudEVtaXR0ZXI4IHtcbiAgX2V4cGxpY2l0UmVsYXlVcmxzO1xuICBibGFja2xpc3RSZWxheVVybHM7XG4gIHBvb2w7XG4gIG91dGJveFBvb2w7XG4gIF9zaWduZXI7XG4gIF9hY3RpdmVVc2VyO1xuICBjYWNoZUFkYXB0ZXI7XG4gIGRlYnVnO1xuICBkZXZXcml0ZVJlbGF5U2V0O1xuICBvdXRib3hUcmFja2VyO1xuICBtdXRlZElkcztcbiAgY2xpZW50TmFtZTtcbiAgY2xpZW50TmlwODk7XG4gIHF1ZXVlc1phcENvbmZpZztcbiAgcXVldWVzTmlwMDU7XG4gIGFzeW5jU2lnVmVyaWZpY2F0aW9uID0gZmFsc2U7XG4gIGluaXRpYWxWYWxpZGF0aW9uUmF0aW8gPSAxO1xuICBsb3dlc3RWYWxpZGF0aW9uUmF0aW8gPSAxO1xuICB2YWxpZGF0aW9uUmF0aW9GbjtcbiAgc3ViTWFuYWdlcjtcbiAgcHVibGlzaGluZ0ZhaWx1cmVIYW5kbGVkID0gZmFsc2U7XG4gIHBvb2xzID0gW107XG4gIC8qKlxuICAgKiBEZWZhdWx0IHJlbGF5LWF1dGggcG9saWN5IHRoYXQgd2lsbCBiZSB1c2VkIHdoZW4gYSByZWxheSByZXF1ZXN0cyBhdXRoZW50aWNhdGlvbixcbiAgICogaWYgbm8gb3RoZXIgcG9saWN5IGlzIHNwZWNpZmllZCBmb3IgdGhhdCByZWxheS5cbiAgICpcbiAgICogQGV4YW1wbGUgRGlzY29ubmVjdCBmcm9tIHJlbGF5cyB0aGF0IHJlcXVlc3QgYXV0aGVudGljYXRpb246XG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogbmRrLnJlbGF5QXV0aERlZmF1bHRQb2xpY3kgPSBOREtBdXRoUG9saWNpZXMuZGlzY29ubmVjdChuZGsucG9vbCk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAZXhhbXBsZSBTaWduIGluIHRvIHJlbGF5cyB0aGF0IHJlcXVlc3QgYXV0aGVudGljYXRpb246XG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogbmRrLnJlbGF5QXV0aERlZmF1bHRQb2xpY3kgPSBOREtBdXRoUG9saWNpZXMuc2lnbkluKHtuZGt9KVxuICAgKiBgYGBcbiAgICpcbiAgICogQGV4YW1wbGUgU2lnbiBpbiB0byByZWxheXMgdGhhdCByZXF1ZXN0IGF1dGhlbnRpY2F0aW9uLCBhc2tpbmcgdGhlIHVzZXIgZm9yIGNvbmZpcm1hdGlvbjpcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBuZGsucmVsYXlBdXRoRGVmYXVsdFBvbGljeSA9IChyZWxheTogTkRLUmVsYXkpID0+IHtcbiAgICogICAgIGNvbnN0IHNpZ25JbiA9IE5ES0F1dGhQb2xpY2llcy5zaWduSW4oe25ka30pO1xuICAgKiAgICAgaWYgKGNvbmZpcm0oYFJlbGF5ICR7cmVsYXkudXJsfSBpcyByZXF1ZXN0aW5nIGF1dGhlbnRpY2F0aW9uLCBkbyB5b3Ugd2FudCB0byBzaWduIGluP2ApKSB7XG4gICAqICAgICAgICBzaWduSW4ocmVsYXkpO1xuICAgKiAgICAgfVxuICAgKiB9XG4gICAqIGBgYFxuICAgKi9cbiAgcmVsYXlBdXRoRGVmYXVsdFBvbGljeTtcbiAgLyoqXG4gICAqIEZldGNoIGZ1bmN0aW9uIHRvIHVzZSBmb3IgSFRUUCByZXF1ZXN0cy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBpbXBvcnQgZmV0Y2ggZnJvbSBcIm5vZGUtZmV0Y2hcIjtcbiAgICpcbiAgICogbmRrLmh0dHBGZXRjaCA9IGZldGNoO1xuICAgKiBgYGBcbiAgICovXG4gIGh0dHBGZXRjaDtcbiAgLyoqXG4gICAqIFByb3ZpZGUgYSBjYWxsZXIgZnVuY3Rpb24gdG8gcmVjZWl2ZSBhbGwgbmV0d29ya2luZyB0cmFmZmljIGZyb20gcmVsYXlzXG4gICAqL1xuICBuZXREZWJ1ZztcbiAgYXV0b0Nvbm5lY3RVc2VyUmVsYXlzID0gdHJ1ZTtcbiAgYXV0b0ZldGNoVXNlck11dGVsaXN0ID0gdHJ1ZTtcbiAgd2FsbGV0Q29uZmlnO1xuICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZGVidWcgPSBvcHRzLmRlYnVnIHx8IGRlYnVnNyhcIm5ka1wiKTtcbiAgICB0aGlzLm5ldERlYnVnID0gb3B0cy5uZXREZWJ1ZztcbiAgICB0aGlzLl9leHBsaWNpdFJlbGF5VXJscyA9IG9wdHMuZXhwbGljaXRSZWxheVVybHMgfHwgW107XG4gICAgdGhpcy5ibGFja2xpc3RSZWxheVVybHMgPSBvcHRzLmJsYWNrbGlzdFJlbGF5VXJscyB8fCBERUZBVUxUX0JMQUNLTElTVEVEX1JFTEFZUztcbiAgICB0aGlzLnN1Yk1hbmFnZXIgPSBuZXcgTkRLU3Vic2NyaXB0aW9uTWFuYWdlcigpO1xuICAgIHRoaXMucG9vbCA9IG5ldyBOREtQb29sKFxuICAgICAgb3B0cy5leHBsaWNpdFJlbGF5VXJscyB8fCBbXSxcbiAgICAgIFtdLFxuICAgICAgdGhpc1xuICAgICk7XG4gICAgdGhpcy5wb29sLm5hbWUgPSBcIk1haW5cIjtcbiAgICB0aGlzLnBvb2wub24oXCJyZWxheTphdXRoXCIsIGFzeW5jIChyZWxheSwgY2hhbGxlbmdlKSA9PiB7XG4gICAgICBpZiAodGhpcy5yZWxheUF1dGhEZWZhdWx0UG9saWN5KSB7XG4gICAgICAgIGF3YWl0IHRoaXMucmVsYXlBdXRoRGVmYXVsdFBvbGljeShyZWxheSwgY2hhbGxlbmdlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmF1dG9Db25uZWN0VXNlclJlbGF5cyA9IG9wdHMuYXV0b0Nvbm5lY3RVc2VyUmVsYXlzID8/IHRydWU7XG4gICAgdGhpcy5hdXRvRmV0Y2hVc2VyTXV0ZWxpc3QgPSBvcHRzLmF1dG9GZXRjaFVzZXJNdXRlbGlzdCA/PyB0cnVlO1xuICAgIHRoaXMuY2xpZW50TmFtZSA9IG9wdHMuY2xpZW50TmFtZTtcbiAgICB0aGlzLmNsaWVudE5pcDg5ID0gb3B0cy5jbGllbnROaXA4OTtcbiAgICB0aGlzLnJlbGF5QXV0aERlZmF1bHRQb2xpY3kgPSBvcHRzLnJlbGF5QXV0aERlZmF1bHRQb2xpY3k7XG4gICAgaWYgKG9wdHMuZW5hYmxlT3V0Ym94TW9kZWwpIHtcbiAgICAgIHRoaXMub3V0Ym94UG9vbCA9IG5ldyBOREtQb29sKFxuICAgICAgICBvcHRzLm91dGJveFJlbGF5VXJscyB8fCBERUZBVUxUX09VVEJPWF9SRUxBWVMsXG4gICAgICAgIFtdLFxuICAgICAgICB0aGlzLFxuICAgICAgICB7XG4gICAgICAgICAgZGVidWc6IHRoaXMuZGVidWcuZXh0ZW5kKFwib3V0Ym94LXBvb2xcIiksXG4gICAgICAgICAgbmFtZTogXCJPdXRib3ggUG9vbFwiXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICB0aGlzLm91dGJveFRyYWNrZXIgPSBuZXcgT3V0Ym94VHJhY2tlcih0aGlzKTtcbiAgICB9XG4gICAgdGhpcy5zaWduZXIgPSBvcHRzLnNpZ25lcjtcbiAgICB0aGlzLmNhY2hlQWRhcHRlciA9IG9wdHMuY2FjaGVBZGFwdGVyO1xuICAgIHRoaXMubXV0ZWRJZHMgPSBvcHRzLm11dGVkSWRzIHx8IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgaWYgKG9wdHMuZGV2V3JpdGVSZWxheVVybHMpIHtcbiAgICAgIHRoaXMuZGV2V3JpdGVSZWxheVNldCA9IE5ES1JlbGF5U2V0LmZyb21SZWxheVVybHMob3B0cy5kZXZXcml0ZVJlbGF5VXJscywgdGhpcyk7XG4gICAgfVxuICAgIHRoaXMucXVldWVzWmFwQ29uZmlnID0gbmV3IFF1ZXVlKFwiemFwc1wiLCAzKTtcbiAgICB0aGlzLnF1ZXVlc05pcDA1ID0gbmV3IFF1ZXVlKFwibmlwMDVcIiwgMTApO1xuICAgIHRoaXMuc2lnbmF0dXJlVmVyaWZpY2F0aW9uV29ya2VyID0gb3B0cy5zaWduYXR1cmVWZXJpZmljYXRpb25Xb3JrZXI7XG4gICAgdGhpcy5pbml0aWFsVmFsaWRhdGlvblJhdGlvID0gb3B0cy5pbml0aWFsVmFsaWRhdGlvblJhdGlvIHx8IDE7XG4gICAgdGhpcy5sb3dlc3RWYWxpZGF0aW9uUmF0aW8gPSBvcHRzLmxvd2VzdFZhbGlkYXRpb25SYXRpbyB8fCAxO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmh0dHBGZXRjaCA9IGZldGNoO1xuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgfVxuICBzZXQgZXhwbGljaXRSZWxheVVybHModXJscykge1xuICAgIHRoaXMuX2V4cGxpY2l0UmVsYXlVcmxzID0gdXJscztcbiAgICB0aGlzLnBvb2wucmVsYXlVcmxzID0gdXJscztcbiAgfVxuICBnZXQgZXhwbGljaXRSZWxheVVybHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2V4cGxpY2l0UmVsYXlVcmxzIHx8IFtdO1xuICB9XG4gIHNldCBzaWduYXR1cmVWZXJpZmljYXRpb25Xb3JrZXIod29ya2VyMikge1xuICAgIHRoaXMuYXN5bmNTaWdWZXJpZmljYXRpb24gPSAhIXdvcmtlcjI7XG4gICAgaWYgKHdvcmtlcjIpIHtcbiAgICAgIHNpZ25hdHVyZVZlcmlmaWNhdGlvbkluaXQod29ya2VyMik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBBZGRzIGFuIGV4cGxpY2l0IHJlbGF5IHRvIHRoZSBwb29sLlxuICAgKiBAcGFyYW0gdXJsXG4gICAqIEBwYXJhbSByZWxheUF1dGhQb2xpY3kgQXV0aGVudGljYXRpb24gcG9saWN5IHRvIHVzZSBpZiBkaWZmZXJlbnQgZnJvbSB0aGUgZGVmYXVsdFxuICAgKiBAcGFyYW0gY29ubmVjdCBXaGV0aGVyIHRvIGNvbm5lY3QgdG8gdGhlIHJlbGF5IGF1dG9tYXRpY2FsbHlcbiAgICogQHJldHVybnNcbiAgICovXG4gIGFkZEV4cGxpY2l0UmVsYXkodXJsT3JSZWxheSwgcmVsYXlBdXRoUG9saWN5LCBjb25uZWN0ID0gdHJ1ZSkge1xuICAgIGxldCByZWxheTtcbiAgICBpZiAodHlwZW9mIHVybE9yUmVsYXkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJlbGF5ID0gbmV3IE5ES1JlbGF5KHVybE9yUmVsYXksIHJlbGF5QXV0aFBvbGljeSwgdGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbGF5ID0gdXJsT3JSZWxheTtcbiAgICB9XG4gICAgdGhpcy5wb29sLmFkZFJlbGF5KHJlbGF5LCBjb25uZWN0KTtcbiAgICB0aGlzLmV4cGxpY2l0UmVsYXlVcmxzLnB1c2gocmVsYXkudXJsKTtcbiAgICByZXR1cm4gcmVsYXk7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7IHJlbGF5Q291bnQ6IHRoaXMucG9vbC5yZWxheXMuc2l6ZSB9LnRvU3RyaW5nKCk7XG4gIH1cbiAgZ2V0IGFjdGl2ZVVzZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZVVzZXI7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGFjdGl2ZSB1c2VyIGZvciB0aGlzIE5ESyBpbnN0YW5jZSwgdHlwaWNhbGx5IHRoaXMgd2lsbCBiZVxuICAgKiBjYWxsZWQgd2hlbiBhc3NpZ25pbmcgYSBzaWduZXIgdG8gdGhlIE5ESyBpbnN0YW5jZS5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiB3aWxsIGF1dG9tYXRpY2FsbHkgY29ubmVjdCB0byB0aGUgdXNlcidzIHJlbGF5cyBpZlxuICAgKiBgYXV0b0Nvbm5lY3RVc2VyUmVsYXlzYCBpcyBzZXQgdG8gdHJ1ZS5cbiAgICpcbiAgICogSXQgd2lsbCBhbHNvIGZldGNoIHRoZSB1c2VyJ3MgbXV0ZWxpc3QgaWYgYGF1dG9GZXRjaFVzZXJNdXRlbGlzdGAgaXMgc2V0IHRvIHRydWUuXG4gICAqL1xuICBzZXQgYWN0aXZlVXNlcih1c2VyKSB7XG4gICAgY29uc3QgZGlmZmVyZW50VXNlciA9IHRoaXMuX2FjdGl2ZVVzZXI/LnB1YmtleSAhPT0gdXNlcj8ucHVia2V5O1xuICAgIHRoaXMuX2FjdGl2ZVVzZXIgPSB1c2VyO1xuICAgIGlmICh1c2VyICYmIGRpZmZlcmVudFVzZXIpIHtcbiAgICAgIHNldEFjdGl2ZVVzZXIuY2FsbCh0aGlzLCB1c2VyKTtcbiAgICB9IGVsc2UgaWYgKCF1c2VyKSB7XG4gICAgICB0aGlzLm11dGVkSWRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHNpZ25lcigpIHtcbiAgICByZXR1cm4gdGhpcy5fc2lnbmVyO1xuICB9XG4gIHNldCBzaWduZXIobmV3U2lnbmVyKSB7XG4gICAgdGhpcy5fc2lnbmVyID0gbmV3U2lnbmVyO1xuICAgIGlmIChuZXdTaWduZXIpIHRoaXMuZW1pdChcInNpZ25lcjpyZWFkeVwiLCBuZXdTaWduZXIpO1xuICAgIG5ld1NpZ25lcj8udXNlcigpLnRoZW4oKHVzZXIpID0+IHtcbiAgICAgIHVzZXIubmRrID0gdGhpcztcbiAgICAgIHRoaXMuYWN0aXZlVXNlciA9IHVzZXI7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENvbm5lY3QgdG8gcmVsYXlzIHdpdGggb3B0aW9uYWwgdGltZW91dC5cbiAgICogSWYgdGhlIHRpbWVvdXQgaXMgcmVhY2hlZCwgdGhlIGNvbm5lY3Rpb24gd2lsbCBiZSBjb250aW51ZWQgdG8gYmUgZXN0YWJsaXNoZWQgaW4gdGhlIGJhY2tncm91bmQuXG4gICAqL1xuICBhc3luYyBjb25uZWN0KHRpbWVvdXRNcykge1xuICAgIGlmICh0aGlzLl9zaWduZXIgJiYgdGhpcy5hdXRvQ29ubmVjdFVzZXJSZWxheXMpIHtcbiAgICAgIHRoaXMuZGVidWcoXG4gICAgICAgIFwiQXR0ZW1wdGluZyB0byBjb25uZWN0IHRvIHVzZXIgcmVsYXlzIHNwZWNpZmllZCBieSBzaWduZXIgJW9cIixcbiAgICAgICAgYXdhaXQgdGhpcy5fc2lnbmVyLnJlbGF5cz8uKHRoaXMpXG4gICAgICApO1xuICAgICAgaWYgKHRoaXMuX3NpZ25lci5yZWxheXMpIHtcbiAgICAgICAgY29uc3QgcmVsYXlzID0gYXdhaXQgdGhpcy5fc2lnbmVyLnJlbGF5cyh0aGlzKTtcbiAgICAgICAgcmVsYXlzLmZvckVhY2goKHJlbGF5KSA9PiB0aGlzLnBvb2wuYWRkUmVsYXkocmVsYXkpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgY29ubmVjdGlvbnMgPSBbdGhpcy5wb29sLmNvbm5lY3QodGltZW91dE1zKV07XG4gICAgaWYgKHRoaXMub3V0Ym94UG9vbCkge1xuICAgICAgY29ubmVjdGlvbnMucHVzaCh0aGlzLm91dGJveFBvb2wuY29ubmVjdCh0aW1lb3V0TXMpKTtcbiAgICB9XG4gICAgdGhpcy5kZWJ1ZyhcIkNvbm5lY3RpbmcgdG8gcmVsYXlzICVvXCIsIHsgdGltZW91dE1zIH0pO1xuICAgIHJldHVybiBQcm9taXNlLmFsbFNldHRsZWQoY29ubmVjdGlvbnMpLnRoZW4oKCkgPT4ge1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSBOREtVc2VyIG9iamVjdFxuICAgKlxuICAgKiBAcGFyYW0gb3B0c1xuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgZ2V0VXNlcihvcHRzKSB7XG4gICAgY29uc3QgdXNlciA9IG5ldyBOREtVc2VyKG9wdHMpO1xuICAgIHVzZXIubmRrID0gdGhpcztcbiAgICByZXR1cm4gdXNlcjtcbiAgfVxuICAvKipcbiAgICogR2V0IGEgTkRLVXNlciBmcm9tIGEgTklQMDVcbiAgICogQHBhcmFtIG5pcDA1IE5JUC0wNSBJRFxuICAgKiBAcGFyYW0gc2tpcENhY2hlIFNraXAgY2FjaGVcbiAgICogQHJldHVybnNcbiAgICovXG4gIGFzeW5jIGdldFVzZXJGcm9tTmlwMDUobmlwMDUsIHNraXBDYWNoZSA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIE5ES1VzZXIuZnJvbU5pcDA1KG5pcDA1LCB0aGlzLCBza2lwQ2FjaGUpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgc3Vic2NyaXB0aW9uLiBTdWJzY3JpcHRpb25zIGF1dG9tYXRpY2FsbHkgc3RhcnQsIHlvdSBjYW4gbWFrZSB0aGVtIGF1dG9tYXRpY2FsbHkgY2xvc2Ugd2hlbiBhbGwgcmVsYXlzIHNlbmQgYmFjayBhbiBFT1NFIGJ5IHNldHRpbmcgYG9wdHMuY2xvc2VPbkVvc2VgIHRvIGB0cnVlYClcbiAgICpcbiAgICogQHBhcmFtIGZpbHRlcnNcbiAgICogQHBhcmFtIG9wdHNcbiAgICogQHBhcmFtIHJlbGF5U2V0IGV4cGxpY2l0IHJlbGF5IHNldCB0byB1c2VcbiAgICogQHBhcmFtIGF1dG9TdGFydCBhdXRvbWF0aWNhbGx5IHN0YXJ0IHRoZSBzdWJzY3JpcHRpb24gLS0gdGhpcyBjYW4gYmUgYSBib29sZWFuIG9yIGFuIG9iamVjdCB3aXRoIGBvbkV2ZW50YCBhbmQgYG9uRW9zZWAgaGFuZGxlcnNcbiAgICogQHJldHVybnMgTkRLU3Vic2NyaXB0aW9uXG4gICAqL1xuICBzdWJzY3JpYmUoZmlsdGVycywgb3B0cywgcmVsYXlTZXQsIGF1dG9TdGFydCA9IHRydWUpIHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBuZXcgTkRLU3Vic2NyaXB0aW9uKHRoaXMsIGZpbHRlcnMsIG9wdHMsIHJlbGF5U2V0KTtcbiAgICB0aGlzLnN1Yk1hbmFnZXIuYWRkKHN1YnNjcmlwdGlvbik7XG4gICAgY29uc3QgcG9vbCA9IG9wdHM/LnBvb2wgPz8gdGhpcy5wb29sO1xuICAgIGlmIChyZWxheVNldCkge1xuICAgICAgZm9yIChjb25zdCByZWxheSBvZiByZWxheVNldC5yZWxheXMpIHtcbiAgICAgICAgcG9vbC51c2VUZW1wb3JhcnlSZWxheShyZWxheSwgdm9pZCAwLCBzdWJzY3JpcHRpb24uZmlsdGVycyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLm91dGJveFBvb2wgJiYgc3Vic2NyaXB0aW9uLmhhc0F1dGhvcnNGaWx0ZXIoKSkge1xuICAgICAgY29uc3QgYXV0aG9ycyA9IHN1YnNjcmlwdGlvbi5maWx0ZXJzLmZpbHRlcigoZmlsdGVyKSA9PiBmaWx0ZXIuYXV0aG9ycyAmJiBmaWx0ZXIuYXV0aG9ycz8ubGVuZ3RoID4gMCkubWFwKChmaWx0ZXIpID0+IGZpbHRlci5hdXRob3JzKS5mbGF0KCk7XG4gICAgICB0aGlzLm91dGJveFRyYWNrZXI/LnRyYWNrVXNlcnMoYXV0aG9ycyk7XG4gICAgfVxuICAgIGlmIChhdXRvU3RhcnQpIHtcbiAgICAgIGxldCBldmVudHNIYW5kbGVyO1xuICAgICAgaWYgKHR5cGVvZiBhdXRvU3RhcnQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgaWYgKGF1dG9TdGFydC5vbkV2ZW50KSBzdWJzY3JpcHRpb24ub24oXCJldmVudFwiLCBhdXRvU3RhcnQub25FdmVudCk7XG4gICAgICAgIGlmIChhdXRvU3RhcnQub25Fb3NlKSBzdWJzY3JpcHRpb24ub24oXCJlb3NlXCIsIGF1dG9TdGFydC5vbkVvc2UpO1xuICAgICAgICBpZiAoYXV0b1N0YXJ0Lm9uRXZlbnRzKSBldmVudHNIYW5kbGVyID0gYXV0b1N0YXJ0Lm9uRXZlbnRzO1xuICAgICAgfVxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGNhY2hlZEV2ZW50cyA9IHN1YnNjcmlwdGlvbi5zdGFydCghZXZlbnRzSGFuZGxlcik7XG4gICAgICAgIGlmIChjYWNoZWRFdmVudHMgJiYgISFldmVudHNIYW5kbGVyKSBldmVudHNIYW5kbGVyKGNhY2hlZEV2ZW50cyk7XG4gICAgICB9LCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgfVxuICAvKipcbiAgICogUHVibGlzaCBhbiBldmVudCB0byBhIHJlbGF5XG4gICAqIEBwYXJhbSBldmVudCBldmVudCB0byBwdWJsaXNoXG4gICAqIEBwYXJhbSByZWxheVNldCBleHBsaWNpdCByZWxheSBzZXQgdG8gdXNlXG4gICAqIEBwYXJhbSB0aW1lb3V0TXMgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgdG8gd2FpdCBmb3IgdGhlIGV2ZW50IHRvIGJlIHB1Ymxpc2hlZFxuICAgKiBAcmV0dXJucyBUaGUgcmVsYXlzIHRoZSBldmVudCB3YXMgcHVibGlzaGVkIHRvXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBgZXZlbnQucHVibGlzaCgpYCBpbnN0ZWFkXG4gICAqL1xuICBhc3luYyBwdWJsaXNoKGV2ZW50LCByZWxheVNldCwgdGltZW91dE1zKSB7XG4gICAgdGhpcy5kZWJ1ZyhcIkRlcHJlY2F0ZWQ6IFVzZSBgZXZlbnQucHVibGlzaCgpYCBpbnN0ZWFkXCIpO1xuICAgIHJldHVybiBldmVudC5wdWJsaXNoKHJlbGF5U2V0LCB0aW1lb3V0TXMpO1xuICB9XG4gIC8qKlxuICAgKiBBdHRlbXB0cyB0byBmZXRjaCBhbiBldmVudCBmcm9tIGEgdGFnLCBmb2xsb3dpbmcgcmVsYXkgaGludHMgYW5kXG4gICAqIG90aGVyIGJlc3QgcHJhY3RpY2VzLlxuICAgKiBAcGFyYW0gdGFnIFRhZyB0byBmZXRjaCB0aGUgZXZlbnQgZnJvbVxuICAgKiBAcGFyYW0gb3JpZ2luYWxFdmVudCBFdmVudCB3aGVyZSB0aGUgdGFnIGNhbWUgZnJvbVxuICAgKiBAcGFyYW0gc3ViT3B0cyBTdWJzY3JpcHRpb24gb3B0aW9ucyB0byB1c2Ugd2hlbiBmZXRjaGluZyB0aGUgZXZlbnRcbiAgICogQHBhcmFtIGZhbGxiYWNrIEZhbGxiYWNrIG9wdGlvbnMgdG8gdXNlIHdoZW4gdGhlIGhpbnQgcmVsYXkgZG9lc24ndCByZXNwb25kXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBmZXRjaEV2ZW50RnJvbVRhZyA9IGZldGNoRXZlbnRGcm9tVGFnLmJpbmQodGhpcyk7XG4gIC8qKlxuICAgKiBGZXRjaCBhbiBldmVudCBmcm9tIHRoZSBjYWNoZSBzeW5jaHJvbm91c2x5LlxuICAgKiBAcGFyYW0gaWRPckZpbHRlciBldmVudCBpZCBpbiBiZWNoMzIgZm9ybWF0IG9yIGZpbHRlclxuICAgKiBAcmV0dXJucyBldmVudHMgZnJvbSB0aGUgY2FjaGUgb3IgbnVsbCBpZiB0aGUgY2FjaGUgaXMgZW1wdHlcbiAgICovXG4gIGZldGNoRXZlbnRTeW5jKGlkT3JGaWx0ZXIpIHtcbiAgICBpZiAoIXRoaXMuY2FjaGVBZGFwdGVyKSB0aHJvdyBuZXcgRXJyb3IoXCJDYWNoZSBhZGFwdGVyIG5vdCBzZXRcIik7XG4gICAgbGV0IGZpbHRlcnM7XG4gICAgaWYgKHR5cGVvZiBpZE9yRmlsdGVyID09PSBcInN0cmluZ1wiKSBmaWx0ZXJzID0gW2ZpbHRlckZyb21JZChpZE9yRmlsdGVyKV07XG4gICAgZWxzZSBmaWx0ZXJzID0gaWRPckZpbHRlcjtcbiAgICBjb25zdCBzdWIgPSBuZXcgTkRLU3Vic2NyaXB0aW9uKHRoaXMsIGZpbHRlcnMpO1xuICAgIGNvbnN0IGV2ZW50cyA9IHRoaXMuY2FjaGVBZGFwdGVyLnF1ZXJ5KHN1Yik7XG4gICAgaWYgKGV2ZW50cyBpbnN0YW5jZW9mIFByb21pc2UpIHRocm93IG5ldyBFcnJvcihcIkNhY2hlIGFkYXB0ZXIgaXMgYXN5bmNcIik7XG4gICAgcmV0dXJuIGV2ZW50cy5tYXAoKGUpID0+IHtcbiAgICAgIGUubmRrID0gdGhpcztcbiAgICAgIHJldHVybiBlO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBGZXRjaCBhIHNpbmdsZSBldmVudC5cbiAgICpcbiAgICogQHBhcmFtIGlkT3JGaWx0ZXIgZXZlbnQgaWQgaW4gYmVjaDMyIGZvcm1hdCBvciBmaWx0ZXJcbiAgICogQHBhcmFtIG9wdHMgc3Vic2NyaXB0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIHJlbGF5U2V0T3JSZWxheSBleHBsaWNpdCByZWxheSBzZXQgdG8gdXNlXG4gICAqL1xuICBhc3luYyBmZXRjaEV2ZW50KGlkT3JGaWx0ZXIsIG9wdHMsIHJlbGF5U2V0T3JSZWxheSkge1xuICAgIGxldCBmaWx0ZXJzO1xuICAgIGxldCByZWxheVNldDtcbiAgICBpZiAocmVsYXlTZXRPclJlbGF5IGluc3RhbmNlb2YgTkRLUmVsYXkpIHtcbiAgICAgIHJlbGF5U2V0ID0gbmV3IE5ES1JlbGF5U2V0KC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtyZWxheVNldE9yUmVsYXldKSwgdGhpcyk7XG4gICAgfSBlbHNlIGlmIChyZWxheVNldE9yUmVsYXkgaW5zdGFuY2VvZiBOREtSZWxheVNldCkge1xuICAgICAgcmVsYXlTZXQgPSByZWxheVNldE9yUmVsYXk7XG4gICAgfVxuICAgIGlmICghcmVsYXlTZXRPclJlbGF5ICYmIHR5cGVvZiBpZE9yRmlsdGVyID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBpZiAoIWlzTmlwMzNBVmFsdWUoaWRPckZpbHRlcikpIHtcbiAgICAgICAgY29uc3QgcmVsYXlzID0gcmVsYXlzRnJvbUJlY2gzMihpZE9yRmlsdGVyLCB0aGlzKTtcbiAgICAgICAgaWYgKHJlbGF5cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcmVsYXlTZXQgPSBuZXcgTkRLUmVsYXlTZXQobmV3IFNldChyZWxheXMpLCB0aGlzKTtcbiAgICAgICAgICByZWxheVNldCA9IGNvcnJlY3RSZWxheVNldChyZWxheVNldCwgdGhpcy5wb29sKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGlkT3JGaWx0ZXIgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGZpbHRlcnMgPSBbZmlsdGVyRnJvbUlkKGlkT3JGaWx0ZXIpXTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaWRPckZpbHRlcikpIHtcbiAgICAgIGZpbHRlcnMgPSBpZE9yRmlsdGVyO1xuICAgIH0gZWxzZSB7XG4gICAgICBmaWx0ZXJzID0gW2lkT3JGaWx0ZXJdO1xuICAgIH1cbiAgICBpZiAoZmlsdGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBmaWx0ZXI6ICR7SlNPTi5zdHJpbmdpZnkoaWRPckZpbHRlcil9YCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgbGV0IGZldGNoZWRFdmVudCA9IG51bGw7XG4gICAgICBjb25zdCBzID0gdGhpcy5zdWJzY3JpYmUoXG4gICAgICAgIGZpbHRlcnMsXG4gICAgICAgIHsgLi4ub3B0cyB8fCB7fSwgY2xvc2VPbkVvc2U6IHRydWUgfSxcbiAgICAgICAgcmVsYXlTZXQsXG4gICAgICAgIGZhbHNlXG4gICAgICApO1xuICAgICAgY29uc3QgdDIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgcy5zdG9wKCk7XG4gICAgICAgIHJlc29sdmUoZmV0Y2hlZEV2ZW50KTtcbiAgICAgIH0sIDFlNCk7XG4gICAgICBzLm9uKFwiZXZlbnRcIiwgKGV2ZW50KSA9PiB7XG4gICAgICAgIGV2ZW50Lm5kayA9IHRoaXM7XG4gICAgICAgIGlmICghZXZlbnQuaXNSZXBsYWNlYWJsZSgpKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHQyKTtcbiAgICAgICAgICByZXNvbHZlKGV2ZW50KTtcbiAgICAgICAgfSBlbHNlIGlmICghZmV0Y2hlZEV2ZW50IHx8IGZldGNoZWRFdmVudC5jcmVhdGVkX2F0IDwgZXZlbnQuY3JlYXRlZF9hdCkge1xuICAgICAgICAgIGZldGNoZWRFdmVudCA9IGV2ZW50O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHMub24oXCJlb3NlXCIsICgpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHQyKTtcbiAgICAgICAgcmVzb2x2ZShmZXRjaGVkRXZlbnQpO1xuICAgICAgfSk7XG4gICAgICBzLnN0YXJ0KCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEZldGNoIGV2ZW50c1xuICAgKi9cbiAgYXN5bmMgZmV0Y2hFdmVudHMoZmlsdGVycywgb3B0cywgcmVsYXlTZXQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGNvbnN0IGV2ZW50cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBjb25zdCByZWxheVNldFN1YnNjcmlwdGlvbiA9IHRoaXMuc3Vic2NyaWJlKFxuICAgICAgICBmaWx0ZXJzLFxuICAgICAgICB7IC4uLm9wdHMgfHwge30sIGNsb3NlT25Fb3NlOiB0cnVlIH0sXG4gICAgICAgIHJlbGF5U2V0LFxuICAgICAgICBmYWxzZVxuICAgICAgKTtcbiAgICAgIGNvbnN0IG9uRXZlbnQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKCEoZXZlbnQgaW5zdGFuY2VvZiBOREtFdmVudCkpIGV2ZW50ID0gbmV3IE5ES0V2ZW50KHZvaWQgMCwgZXZlbnQpO1xuICAgICAgICBjb25zdCBkZWR1cEtleSA9IGV2ZW50LmRlZHVwbGljYXRpb25LZXkoKTtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdFdmVudCA9IGV2ZW50cy5nZXQoZGVkdXBLZXkpO1xuICAgICAgICBpZiAoZXhpc3RpbmdFdmVudCkge1xuICAgICAgICAgIGV2ZW50ID0gZGVkdXAoZXhpc3RpbmdFdmVudCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50Lm5kayA9IHRoaXM7XG4gICAgICAgIGV2ZW50cy5zZXQoZGVkdXBLZXksIGV2ZW50KTtcbiAgICAgIH07XG4gICAgICByZWxheVNldFN1YnNjcmlwdGlvbi5vbihcImV2ZW50XCIsIG9uRXZlbnQpO1xuICAgICAgcmVsYXlTZXRTdWJzY3JpcHRpb24ub24oXCJlb3NlXCIsICgpID0+IHtcbiAgICAgICAgcmVzb2x2ZShuZXcgU2V0KGV2ZW50cy52YWx1ZXMoKSkpO1xuICAgICAgfSk7XG4gICAgICByZWxheVNldFN1YnNjcmlwdGlvbi5zdGFydCgpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBFbnN1cmVzIHRoYXQgYSBzaWduZXIgaXMgYXZhaWxhYmxlIHRvIHNpZ24gYW4gZXZlbnQuXG4gICAqL1xuICBhc3NlcnRTaWduZXIoKSB7XG4gICAgaWYgKCF0aGlzLnNpZ25lcikge1xuICAgICAgdGhpcy5lbWl0KFwic2lnbmVyOnJlcXVpcmVkXCIpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2lnbmVyIHJlcXVpcmVkXCIpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBOaXA5NiBpbnN0YW5jZSBmb3IgdGhlIGdpdmVuIGRvbWFpbi5cbiAgICogQHBhcmFtIGRvbWFpbiBEb21haW4gdG8gdXNlIGZvciBuaXA5NiB1cGxvYWRzXG4gICAqIEBleGFtcGxlIFVwbG9hZCBhIGZpbGUgdG8gYSBOSVAtOTYgZW5hYmxlZCBkb21haW46XG4gICAqXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtcIkhlbGxvLCB3b3JsZCFcIl0sIHsgdHlwZTogXCJ0ZXh0L3BsYWluXCIgfSk7XG4gICAqIGNvbnN0IG5pcDk2ID0gbmRrLmdldE5pcDk2KFwibm9zdHJjaGVjay5tZVwiKTtcbiAgICogYXdhaXQgbmlwOTYudXBsb2FkKGJsb2IpO1xuICAgKiBgYGBcbiAgICovXG4gIGdldE5pcDk2KGRvbWFpbikge1xuICAgIHJldHVybiBuZXcgTmlwOTYoZG9tYWluLCB0aGlzKTtcbiAgfVxuICBzZXQgd2FsbGV0KHdhbGxldCkge1xuICAgIGlmICghd2FsbGV0KSB7XG4gICAgICB0aGlzLndhbGxldENvbmZpZyA9IHZvaWQgMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy53YWxsZXRDb25maWcgPz89IHt9O1xuICAgIHRoaXMud2FsbGV0Q29uZmlnLmxuUGF5ID0gd2FsbGV0Py5sblBheT8uYmluZCh3YWxsZXQpO1xuICAgIHRoaXMud2FsbGV0Q29uZmlnLmNhc2h1UGF5ID0gd2FsbGV0Py5jYXNodVBheT8uYmluZCh3YWxsZXQpO1xuICB9XG59O1xuXG4vLyBzcmMvemFwL2ludm9pY2UudHNcbmltcG9ydCB7IGRlY29kZSB9IGZyb20gXCJsaWdodC1ib2x0MTEtZGVjb2RlclwiO1xuZnVuY3Rpb24gemFwSW52b2ljZUZyb21FdmVudChldmVudCkge1xuICBjb25zdCBkZXNjcmlwdGlvbiA9IGV2ZW50LmdldE1hdGNoaW5nVGFncyhcImRlc2NyaXB0aW9uXCIpWzBdO1xuICBjb25zdCBib2x0MTEgPSBldmVudC5nZXRNYXRjaGluZ1RhZ3MoXCJib2x0MTFcIilbMF07XG4gIGxldCBkZWNvZGVkSW52b2ljZTtcbiAgbGV0IHphcFJlcXVlc3Q7XG4gIGlmICghZGVzY3JpcHRpb24gfHwgIWJvbHQxMSB8fCAhYm9sdDExWzFdKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdHJ5IHtcbiAgICBsZXQgemFwUmVxdWVzdFBheWxvYWQgPSBkZXNjcmlwdGlvblsxXTtcbiAgICBpZiAoemFwUmVxdWVzdFBheWxvYWQuc3RhcnRzV2l0aChcIiVcIikpIHtcbiAgICAgIHphcFJlcXVlc3RQYXlsb2FkID0gZGVjb2RlVVJJQ29tcG9uZW50KHphcFJlcXVlc3RQYXlsb2FkKTtcbiAgICB9XG4gICAgaWYgKHphcFJlcXVlc3RQYXlsb2FkID09PSBcIlwiKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgemFwUmVxdWVzdCA9IEpTT04ucGFyc2UoemFwUmVxdWVzdFBheWxvYWQpO1xuICAgIGRlY29kZWRJbnZvaWNlID0gZGVjb2RlKGJvbHQxMVsxXSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBhbW91bnRTZWN0aW9uID0gZGVjb2RlZEludm9pY2Uuc2VjdGlvbnMuZmluZCgocykgPT4gcy5uYW1lID09PSBcImFtb3VudFwiKTtcbiAgaWYgKCFhbW91bnRTZWN0aW9uKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgYW1vdW50ID0gcGFyc2VJbnQoYW1vdW50U2VjdGlvbi52YWx1ZSk7XG4gIGlmICghYW1vdW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgY29udGVudCA9IHphcFJlcXVlc3QuY29udGVudDtcbiAgY29uc3Qgc2VuZGVyID0gemFwUmVxdWVzdC5wdWJrZXk7XG4gIGNvbnN0IHJlY2lwaWVudFRhZyA9IGV2ZW50LmdldE1hdGNoaW5nVGFncyhcInBcIilbMF07XG4gIGNvbnN0IHJlY2lwaWVudCA9IHJlY2lwaWVudFRhZ1sxXTtcbiAgbGV0IHphcHBlZEV2ZW50ID0gZXZlbnQuZ2V0TWF0Y2hpbmdUYWdzKFwiZVwiKVswXTtcbiAgaWYgKCF6YXBwZWRFdmVudCkge1xuICAgIHphcHBlZEV2ZW50ID0gZXZlbnQuZ2V0TWF0Y2hpbmdUYWdzKFwiYVwiKVswXTtcbiAgfVxuICBjb25zdCB6YXBwZWRFdmVudElkID0gemFwcGVkRXZlbnQgPyB6YXBwZWRFdmVudFsxXSA6IHZvaWQgMDtcbiAgY29uc3QgemFwSW52b2ljZSA9IHtcbiAgICBpZDogZXZlbnQuaWQsXG4gICAgemFwcGVyOiBldmVudC5wdWJrZXksXG4gICAgemFwcGVlOiBzZW5kZXIsXG4gICAgemFwcGVkOiByZWNpcGllbnQsXG4gICAgemFwcGVkRXZlbnQ6IHphcHBlZEV2ZW50SWQsXG4gICAgYW1vdW50LFxuICAgIGNvbW1lbnQ6IGNvbnRlbnRcbiAgfTtcbiAgcmV0dXJuIHphcEludm9pY2U7XG59XG5cbi8vIHNyYy96YXBwZXIvaW5kZXgudHNcbmltcG9ydCBjcmVhdGVEZWJ1ZzUgZnJvbSBcImRlYnVnXCI7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgYXMgRXZlbnRFbWl0dGVyOSB9IGZyb20gXCJ0c2VlcFwiO1xuXG4vLyBzcmMvemFwcGVyL25pcDU3LnRzXG5pbXBvcnQgeyBuaXA1NyB9IGZyb20gXCJub3N0ci10b29sc1wiO1xuYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVaYXBSZXF1ZXN0KHRhcmdldCwgbmRrLCBkYXRhLCBwdWJrZXksIGFtb3VudCwgcmVsYXlzLCBjb21tZW50LCB0YWdzLCBzaWduZXIpIHtcbiAgY29uc3QgemFwRW5kcG9pbnQgPSBkYXRhLmNhbGxiYWNrO1xuICBjb25zdCB6YXBSZXF1ZXN0ID0gbmlwNTcubWFrZVphcFJlcXVlc3Qoe1xuICAgIHByb2ZpbGU6IHB1YmtleSxcbiAgICAvLyBzZXQgdGhlIGV2ZW50IHRvIG51bGwgc2luY2Ugbm9zdHItdG9vbHMgZG9lc24ndCBzdXBwb3J0IG5pcC0zMyB6YXBzXG4gICAgZXZlbnQ6IG51bGwsXG4gICAgYW1vdW50LFxuICAgIGNvbW1lbnQ6IGNvbW1lbnQgfHwgXCJcIixcbiAgICByZWxheXM6IHJlbGF5cy5zbGljZSgwLCA0KVxuICB9KTtcbiAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIE5ES0V2ZW50KSB7XG4gICAgY29uc3QgdGFnczIgPSB0YXJnZXQucmVmZXJlbmNlVGFncygpO1xuICAgIGNvbnN0IG5vblBUYWdzID0gdGFnczIuZmlsdGVyKCh0YWcpID0+IHRhZ1swXSAhPT0gXCJwXCIpO1xuICAgIHphcFJlcXVlc3QudGFncy5wdXNoKC4uLm5vblBUYWdzKTtcbiAgfVxuICB6YXBSZXF1ZXN0LnRhZ3MucHVzaChbXCJsbnVybFwiLCB6YXBFbmRwb2ludF0pO1xuICBjb25zdCBldmVudCA9IG5ldyBOREtFdmVudChuZGssIHphcFJlcXVlc3QpO1xuICBpZiAodGFncykge1xuICAgIGV2ZW50LnRhZ3MgPSBldmVudC50YWdzLmNvbmNhdCh0YWdzKTtcbiAgfVxuICBpZiAoZXZlbnQuaGFzVGFnKFwiYVwiKSkge1xuICAgIGV2ZW50LnRhZ3MgPSBldmVudC50YWdzLmZpbHRlcigodGFnKSA9PiB0YWdbMF0gIT09IFwiZVwiKTtcbiAgfVxuICBldmVudC50YWdzID0gZXZlbnQudGFncy5maWx0ZXIoKHRhZykgPT4gdGFnWzBdICE9PSBcInBcIik7XG4gIGV2ZW50LnRhZ3MucHVzaChbXCJwXCIsIHB1YmtleV0pO1xuICBhd2FpdCBldmVudC5zaWduKHNpZ25lcik7XG4gIHJldHVybiBldmVudDtcbn1cblxuLy8gc3JjL3phcHBlci9sbi50c1xuaW1wb3J0IHsgYmVjaDMyIH0gZnJvbSBcIkBzY3VyZS9iYXNlXCI7XG5pbXBvcnQgY3JlYXRlRGVidWc0IGZyb20gXCJkZWJ1Z1wiO1xudmFyIGQyID0gY3JlYXRlRGVidWc0KFwibmRrOnphcHBlcjpsblwiKTtcbmFzeW5jIGZ1bmN0aW9uIGdldE5pcDU3WmFwU3BlY0Zyb21MdWQoeyBsdWQwNiwgbHVkMTYgfSwgbmRrKSB7XG4gIGxldCB6YXBFbmRwb2ludDtcbiAgaWYgKGx1ZDE2ICYmICFsdWQxNi5zdGFydHNXaXRoKFwiTE5VUkxcIikpIHtcbiAgICBjb25zdCBbbmFtZSwgZG9tYWluXSA9IGx1ZDE2LnNwbGl0KFwiQFwiKTtcbiAgICB6YXBFbmRwb2ludCA9IGBodHRwczovLyR7ZG9tYWlufS8ud2VsbC1rbm93bi9sbnVybHAvJHtuYW1lfWA7XG4gIH0gZWxzZSBpZiAobHVkMDYpIHtcbiAgICBjb25zdCB7IHdvcmRzIH0gPSBiZWNoMzIuZGVjb2RlKGx1ZDA2LCAxZTMpO1xuICAgIGNvbnN0IGRhdGEgPSBiZWNoMzIuZnJvbVdvcmRzKHdvcmRzKTtcbiAgICBjb25zdCB1dGY4RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcihcInV0Zi04XCIpO1xuICAgIHphcEVuZHBvaW50ID0gdXRmOERlY29kZXIuZGVjb2RlKGRhdGEpO1xuICB9XG4gIGlmICghemFwRW5kcG9pbnQpIHtcbiAgICBkMihcIk5vIHphcCBlbmRwb2ludCBmb3VuZCAlb1wiLCB7IGx1ZDA2LCBsdWQxNiB9KTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyB6YXAgZW5kcG9pbnQgZm91bmRcIik7XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCBfZmV0Y2ggPSBuZGsuaHR0cEZldGNoIHx8IGZldGNoO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgX2ZldGNoKHphcEVuZHBvaW50KTtcbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBmZXRjaCB6YXAgZW5kcG9pbnQgJHt6YXBFbmRwb2ludH06ICR7dGV4dH1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGZldGNoIHphcCBlbmRwb2ludCAke3phcEVuZHBvaW50fTogJHtlfWApO1xuICB9XG59XG5cbi8vIHNyYy96YXBwZXIvaW5kZXgudHNcbnZhciBkMyA9IGNyZWF0ZURlYnVnNShcIm5kazp6YXBwZXJcIik7XG52YXIgTkRLWmFwcGVyID0gY2xhc3MgZXh0ZW5kcyBFdmVudEVtaXR0ZXI5IHtcbiAgdGFyZ2V0O1xuICBuZGs7XG4gIGNvbW1lbnQ7XG4gIGFtb3VudDtcbiAgdW5pdDtcbiAgdGFncztcbiAgc2lnbmVyO1xuICB6YXBNZXRob2Q7XG4gIG51dHphcEFzRmFsbGJhY2s7XG4gIGxuUGF5O1xuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gYSBjYXNodSBwYXltZW50IGlzIHRvIGJlIG1hZGUuXG4gICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIHN3YXAvbWludCBwcm9vZnMgZm9yIHRoZSByZXF1aXJlZCBhbW91bnQsIGluIHRoZSByZXF1aXJlZCB1bml0LFxuICAgKiBpbiBhbnkgb2YgdGhlIHByb3ZpZGVkIG1pbnRzIGFuZCByZXR1cm4gdGhlIHByb29mcyBhbmQgbWludCB1c2VkLlxuICAgKi9cbiAgY2FzaHVQYXk7XG4gIG9uQ29tcGxldGU7XG4gIG1heFJlbGF5cyA9IDM7XG4gIC8qKlxuICAgKiBcbiAgICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0IG9mIHRoZSB6YXBcbiAgICogQHBhcmFtIGFtb3VudCBUaGUgYW1vdW50IHRvIHNlbmQgaW5kaWNhdGVkIGluIHRoZSB1bml0XG4gICAqIEBwYXJhbSB1bml0IFRoZSB1bml0IG9mIHRoZSBhbW91bnRcbiAgICogQHBhcmFtIG9wdHMgT3B0aW9ucyBmb3IgdGhlIHphcFxuICAgKi9cbiAgY29uc3RydWN0b3IodGFyZ2V0LCBhbW91bnQsIHVuaXQgPSBcIm1zYXRcIiwgb3B0cyA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICB0aGlzLm5kayA9IG9wdHMubmRrIHx8IHRhcmdldC5uZGs7XG4gICAgaWYgKCF0aGlzLm5kaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gTkRLIGluc3RhbmNlIHByb3ZpZGVkXCIpO1xuICAgIH1cbiAgICB0aGlzLmFtb3VudCA9IGFtb3VudDtcbiAgICB0aGlzLmNvbW1lbnQgPSBvcHRzLmNvbW1lbnQ7XG4gICAgdGhpcy51bml0ID0gdW5pdDtcbiAgICB0aGlzLnRhZ3MgPSBvcHRzLnRhZ3M7XG4gICAgdGhpcy5zaWduZXIgPSBvcHRzLnNpZ25lcjtcbiAgICB0aGlzLm51dHphcEFzRmFsbGJhY2sgPSBvcHRzLm51dHphcEFzRmFsbGJhY2sgPz8gZmFsc2U7XG4gICAgdGhpcy5sblBheSA9IG9wdHMubG5QYXkgfHwgdGhpcy5uZGsud2FsbGV0Q29uZmlnPy5sblBheTtcbiAgICB0aGlzLmNhc2h1UGF5ID0gb3B0cy5jYXNodVBheSB8fCB0aGlzLm5kay53YWxsZXRDb25maWc/LmNhc2h1UGF5O1xuICAgIHRoaXMub25Db21wbGV0ZSA9IG9wdHMub25Db21wbGV0ZSB8fCB0aGlzLm5kay53YWxsZXRDb25maWc/Lm9uUGF5bWVudENvbXBsZXRlO1xuICB9XG4gIC8qKlxuICAgKiBJbml0aWF0ZSB6YXBwaW5nIHByb2Nlc3NcbiAgICogXG4gICAqIFRoaXMgZnVuY3Rpb24gd2lsbCBjYWxjdWxhdGUgdGhlIHNwbGl0cyBmb3IgdGhpcyB6YXAgYW5kIGluaXRpYXRlIGVhY2ggemFwIHNwbGl0LlxuICAgKi9cbiAgYXN5bmMgemFwKG1ldGhvZHMpIHtcbiAgICBjb25zdCBzcGxpdHMgPSB0aGlzLmdldFphcFNwbGl0cygpO1xuICAgIGNvbnN0IHJlc3VsdHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgc3BsaXRzLm1hcChhc3luYyAoc3BsaXQpID0+IHtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXN1bHQgPSBhd2FpdCB0aGlzLnphcFNwbGl0KHNwbGl0LCBtZXRob2RzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJlc3VsdCA9IG5ldyBFcnJvcihlLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdChcInNwbGl0OmNvbXBsZXRlXCIsIHNwbGl0LCByZXN1bHQpO1xuICAgICAgICByZXN1bHRzLnNldChzcGxpdCwgcmVzdWx0KTtcbiAgICAgIH0pXG4gICAgKTtcbiAgICB0aGlzLmVtaXQoXCJjb21wbGV0ZVwiLCByZXN1bHRzKTtcbiAgICBpZiAodGhpcy5vbkNvbXBsZXRlKSB0aGlzLm9uQ29tcGxldGUocmVzdWx0cyk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cbiAgYXN5bmMgemFwTmlwNTcoc3BsaXQsIGRhdGEpIHtcbiAgICBpZiAoIXRoaXMubG5QYXkpIHRocm93IG5ldyBFcnJvcihcIk5vIGxuUGF5IGZ1bmN0aW9uIGF2YWlsYWJsZVwiKTtcbiAgICBjb25zdCB6YXBTcGVjID0gYXdhaXQgZ2V0TmlwNTdaYXBTcGVjRnJvbUx1ZChkYXRhLCB0aGlzLm5kayk7XG4gICAgaWYgKCF6YXBTcGVjKSB0aHJvdyBuZXcgRXJyb3IoXCJObyB6YXAgc3BlYyBhdmFpbGFibGUgZm9yIHJlY2lwaWVudFwiKTtcbiAgICBjb25zdCByZWxheXMgPSBhd2FpdCB0aGlzLnJlbGF5cyhzcGxpdC5wdWJrZXkpO1xuICAgIGNvbnN0IHphcFJlcXVlc3QgPSBhd2FpdCBnZW5lcmF0ZVphcFJlcXVlc3QoXG4gICAgICB0aGlzLnRhcmdldCxcbiAgICAgIHRoaXMubmRrLFxuICAgICAgemFwU3BlYyxcbiAgICAgIHNwbGl0LnB1YmtleSxcbiAgICAgIHNwbGl0LmFtb3VudCxcbiAgICAgIHJlbGF5cyxcbiAgICAgIHRoaXMuY29tbWVudCxcbiAgICAgIHRoaXMudGFncyxcbiAgICAgIHRoaXMuc2lnbmVyXG4gICAgKTtcbiAgICBpZiAoIXphcFJlcXVlc3QpIHtcbiAgICAgIGQzKFwiVW5hYmxlIHRvIGdlbmVyYXRlIHphcCByZXF1ZXN0XCIpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGdlbmVyYXRlIHphcCByZXF1ZXN0XCIpO1xuICAgIH1cbiAgICBjb25zdCBwciA9IGF3YWl0IHRoaXMuZ2V0TG5JbnZvaWNlKHphcFJlcXVlc3QsIHNwbGl0LmFtb3VudCwgemFwU3BlYyk7XG4gICAgaWYgKCFwcikge1xuICAgICAgZDMoXCJVbmFibGUgdG8gZ2V0IHBheW1lbnQgcmVxdWVzdFwiKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBnZXQgcGF5bWVudCByZXF1ZXN0XCIpO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoXCJsbl9pbnZvaWNlXCIsIHtcbiAgICAgIGFtb3VudDogc3BsaXQuYW1vdW50LFxuICAgICAgcmVjaXBpZW50UHVia2V5OiBzcGxpdC5wdWJrZXksXG4gICAgICB1bml0OiB0aGlzLnVuaXQsXG4gICAgICBuaXA1N1phcFJlcXVlc3Q6IHphcFJlcXVlc3QsXG4gICAgICBwcixcbiAgICAgIHR5cGU6IFwibmlwNTdcIlxuICAgIH0pO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMubG5QYXkoXG4gICAgICB7XG4gICAgICAgIHRhcmdldDogdGhpcy50YXJnZXQsXG4gICAgICAgIHJlY2lwaWVudFB1YmtleTogc3BsaXQucHVia2V5LFxuICAgICAgICBwYXltZW50RGVzY3JpcHRpb246IFwiTklQLTU3IFphcFwiLFxuICAgICAgICBwcixcbiAgICAgICAgYW1vdW50OiBzcGxpdC5hbW91bnQsXG4gICAgICAgIHVuaXQ6IHRoaXMudW5pdCxcbiAgICAgICAgbmlwNTdaYXBSZXF1ZXN0OiB6YXBSZXF1ZXN0XG4gICAgICB9XG4gICAgKTtcbiAgICBpZiAocmVzPy5wcmVpbWFnZSkge1xuICAgICAgdGhpcy5lbWl0KFwibG5fcGF5bWVudFwiLCB7XG4gICAgICAgIHByZWltYWdlOiByZXMucHJlaW1hZ2UsXG4gICAgICAgIGFtb3VudDogc3BsaXQuYW1vdW50LFxuICAgICAgICByZWNpcGllbnRQdWJrZXk6IHNwbGl0LnB1YmtleSxcbiAgICAgICAgcHIsXG4gICAgICAgIHVuaXQ6IHRoaXMudW5pdCxcbiAgICAgICAgbmlwNTdaYXBSZXF1ZXN0OiB6YXBSZXF1ZXN0LFxuICAgICAgICB0eXBlOiBcIm5pcDU3XCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIC8qKlxuICAgKiBGZXRjaGVzIGluZm9ybWF0aW9uIGFib3V0IGEgTklQLTYxIHphcCBhbmQgYXNrcyB0aGUgY2FsbGVyIHRvIGNyZWF0ZSBjYXNodSBwcm9vZnMgZm9yIHRoZSB6YXAuXG4gICAqIFxuICAgKiAobm90ZSB0aGF0IHRoZSBjYXNodVBheSBmdW5jdGlvbiBjYW4gdXNlIGFueSBtZXRob2QgdG8gY3JlYXRlIHRoZSBwcm9vZnMsIGluY2x1ZGluZyB1c2luZyBsaWdodG5pbmdcbiAgICogdG8gbWludCBwcm9vZnMgaW4gdGhlIHNwZWNpZmllZCBtaW50LCB0aGUgcmVzcG9uc2liaWxpdHkgb2YgbWludGluZyB0aGUgcHJvb2ZzIGlzIGRlbGVnYXRlZCB0byB0aGUgY2FsbGVyIChlLmcuIG5kay13YWxsZXQpKVxuICAgKi9cbiAgYXN5bmMgemFwTmlwNjEoc3BsaXQsIGRhdGEpIHtcbiAgICBpZiAoIXRoaXMuY2FzaHVQYXkpIHRocm93IG5ldyBFcnJvcihcIk5vIGNhc2h1UGF5IGZ1bmN0aW9uIGF2YWlsYWJsZVwiKTtcbiAgICBsZXQgcmV0O1xuICAgIHJldCA9IGF3YWl0IHRoaXMuY2FzaHVQYXkoe1xuICAgICAgdGFyZ2V0OiB0aGlzLnRhcmdldCxcbiAgICAgIHJlY2lwaWVudFB1YmtleTogc3BsaXQucHVia2V5LFxuICAgICAgcGF5bWVudERlc2NyaXB0aW9uOiBcIk5JUC02MSBaYXBcIixcbiAgICAgIGFtb3VudDogc3BsaXQuYW1vdW50LFxuICAgICAgdW5pdDogdGhpcy51bml0LFxuICAgICAgLi4uZGF0YSA/PyB7fVxuICAgIH0sIChwcikgPT4ge1xuICAgICAgdGhpcy5lbWl0KFwibG5faW52b2ljZVwiLCB7XG4gICAgICAgIHByLFxuICAgICAgICBhbW91bnQ6IHNwbGl0LmFtb3VudCxcbiAgICAgICAgcmVjaXBpZW50UHVia2V5OiBzcGxpdC5wdWJrZXksXG4gICAgICAgIHVuaXQ6IHRoaXMudW5pdCxcbiAgICAgICAgdHlwZTogXCJuaXA2MVwiXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBkMyhcIk5JUC02MSBaYXAgcmVzdWx0OiAlb1wiLCByZXQpO1xuICAgIGlmIChyZXQgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9IGVsc2UgaWYgKHJldCkge1xuICAgICAgY29uc3QgeyBwcm9vZnMsIG1pbnQgfSA9IHJldDtcbiAgICAgIGlmICghcHJvb2ZzIHx8ICFtaW50KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJJbnZhbGlkIHphcCBjb25maXJtYXRpb246IG1pc3NpbmcgcHJvb2ZzIG9yIG1pbnQ6IFwiICsgcmV0XG4gICAgICAgICk7XG4gICAgICBjb25zdCByZWxheXMgPSBhd2FpdCB0aGlzLnJlbGF5cyhzcGxpdC5wdWJrZXkpO1xuICAgICAgY29uc3QgcmVsYXlTZXQgPSBOREtSZWxheVNldC5mcm9tUmVsYXlVcmxzKHJlbGF5cywgdGhpcy5uZGspO1xuICAgICAgY29uc3QgbnV0emFwID0gbmV3IE5ES051dHphcCh0aGlzLm5kayk7XG4gICAgICBudXR6YXAudGFncyA9IFsuLi5udXR6YXAudGFncywgLi4udGhpcy50YWdzIHx8IFtdXTtcbiAgICAgIG51dHphcC5wcm9vZnMgPSBwcm9vZnM7XG4gICAgICBudXR6YXAubWludCA9IG1pbnQ7XG4gICAgICBudXR6YXAudGFyZ2V0ID0gdGhpcy50YXJnZXQ7XG4gICAgICBudXR6YXAuY29tbWVudCA9IHRoaXMuY29tbWVudDtcbiAgICAgIG51dHphcC51bml0ID0gdGhpcy51bml0O1xuICAgICAgbnV0emFwLnJlY2lwaWVudFB1YmtleSA9IHNwbGl0LnB1YmtleTtcbiAgICAgIGF3YWl0IG51dHphcC5zaWduKHRoaXMuc2lnbmVyKTtcbiAgICAgIG51dHphcC5wdWJsaXNoKHJlbGF5U2V0KTtcbiAgICAgIHJldHVybiBudXR6YXA7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHphcCBtZXRob2RzIGF2YWlsYWJsZSBmb3IgdGhlIHJlY2lwaWVudCBhbmQgaW5pdGlhdGVzIHRoZSB6YXBcbiAgICogaW4gdGhlIGRlc2lyZWQgbWV0aG9kLlxuICAgKiBAcGFyYW0gc3BsaXQgXG4gICAqIEBwYXJhbSBtZXRob2RzIC0gVGhlIG1ldGhvZHMgdG8gdHJ5LCBpZiBub3QgcHJvdmlkZWQsIGFsbCBtZXRob2RzIHdpbGwgYmUgdHJpZWQuXG4gICAqIEByZXR1cm5zIFxuICAgKi9cbiAgYXN5bmMgemFwU3BsaXQoc3BsaXQsIG1ldGhvZHMpIHtcbiAgICBjb25zdCByZWNpcGllbnQgPSB0aGlzLm5kay5nZXRVc2VyKHsgcHVia2V5OiBzcGxpdC5wdWJrZXkgfSk7XG4gICAgbGV0IHphcE1ldGhvZHMgPSBhd2FpdCByZWNpcGllbnQuZ2V0WmFwSW5mbygyNTAwKTtcbiAgICBsZXQgcmV0VmFsO1xuICAgIGNvbnN0IGNhbkZhbGxiYWNrVG9OaXA2MSA9IHRoaXMubnV0emFwQXNGYWxsYmFjayAmJiB0aGlzLmNhc2h1UGF5O1xuICAgIGlmICh6YXBNZXRob2RzLnNpemUgPT09IDAgJiYgIWNhbkZhbGxiYWNrVG9OaXA2MSkgdGhyb3cgbmV3IEVycm9yKFwiTm8gemFwIG1ldGhvZCBhdmFpbGFibGUgZm9yIHJlY2lwaWVudCBhbmQgTklQLTYxIGZhbGxiYWNrIGlzIGRpc2FibGVkXCIpO1xuICAgIGNvbnN0IG5pcDYxRmFsbGJhY2sgPSBhc3luYyAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMubnV0emFwQXNGYWxsYmFjaykgcmV0dXJuO1xuICAgICAgY29uc3QgcmVsYXlMaXN0cyA9IGF3YWl0IGdldFJlbGF5TGlzdEZvclVzZXJzKFtzcGxpdC5wdWJrZXldLCB0aGlzLm5kayk7XG4gICAgICBsZXQgcmVsYXlVcmxzID0gcmVsYXlMaXN0cy5nZXQoc3BsaXQucHVia2V5KT8ucmVhZFJlbGF5VXJscztcbiAgICAgIHJlbGF5VXJscyA9IHRoaXMubmRrLnBvb2wuY29ubmVjdGVkUmVsYXlzKCkubWFwKChyKSA9PiByLnVybCk7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy56YXBOaXA2MShzcGxpdCwge1xuICAgICAgICAvLyB1c2UgdGhlIHVzZXIncyByZWxheSBsaXN0XG4gICAgICAgIHJlbGF5czogcmVsYXlVcmxzLFxuICAgICAgICAvLyBsb2NrIHRvIHRoZSB1c2VyJ3MgYWN0dWFsIHB1YmtleVxuICAgICAgICBwMnBrOiBzcGxpdC5wdWJrZXksXG4gICAgICAgIC8vIGFsbG93IGludHJhbWludCBmYWxsYmFja1xuICAgICAgICBhbGxvd0ludHJhbWludEZhbGxiYWNrOiAhIWNhbkZhbGxiYWNrVG9OaXA2MVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBjYW5Vc2VOaXA2MSA9ICFtZXRob2RzIHx8IG1ldGhvZHMuaW5jbHVkZXMoXCJuaXA2MVwiKTtcbiAgICBjb25zdCBjYW5Vc2VOaXA1NyA9ICFtZXRob2RzIHx8IG1ldGhvZHMuaW5jbHVkZXMoXCJuaXA1N1wiKTtcbiAgICBjb25zdCBuaXA2MU1ldGhvZCA9IHphcE1ldGhvZHMuZ2V0KFwibmlwNjFcIik7XG4gICAgaWYgKG5pcDYxTWV0aG9kICYmIGNhblVzZU5pcDYxKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXRWYWwgPSBhd2FpdCB0aGlzLnphcE5pcDYxKHNwbGl0LCBuaXA2MU1ldGhvZCk7XG4gICAgICAgIGlmIChyZXRWYWwgaW5zdGFuY2VvZiBOREtOdXR6YXApIHJldHVybiByZXRWYWw7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRoaXMuZW1pdChcIm5vdGljZVwiLCBgTklQLTYxIGF0dGVtcHQgZmFpbGVkOiAke2UubWVzc2FnZX1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbmlwNTdNZXRob2QgPSB6YXBNZXRob2RzLmdldChcIm5pcDU3XCIpO1xuICAgIGlmIChuaXA1N01ldGhvZCAmJiBjYW5Vc2VOaXA1Nykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0VmFsID0gYXdhaXQgdGhpcy56YXBOaXA1NyhzcGxpdCwgbmlwNTdNZXRob2QpO1xuICAgICAgICBpZiAoIShyZXRWYWwgaW5zdGFuY2VvZiBFcnJvcikpIHJldHVybiByZXRWYWw7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRoaXMuZW1pdChcIm5vdGljZVwiLCBgTklQLTU3IGF0dGVtcHQgZmFpbGVkOiAke2UubWVzc2FnZX1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNhbkZhbGxiYWNrVG9OaXA2MSkge1xuICAgICAgcmV0VmFsID0gYXdhaXQgbmlwNjFGYWxsYmFjaygpO1xuICAgICAgaWYgKHJldFZhbCBpbnN0YW5jZW9mIEVycm9yKSB0aHJvdyByZXRWYWw7XG4gICAgICByZXR1cm4gcmV0VmFsO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVtaXQoXCJub3RpY2VcIiwgXCJaYXAgbWV0aG9kcyBleGhhdXN0ZWQgYW5kIHRoZXJlIHdhcyBubyBmYWxsYmFjayB0byBOSVAtNjFcIik7XG4gICAgfVxuICAgIGlmIChyZXRWYWwgaW5zdGFuY2VvZiBFcnJvcikgdGhyb3cgcmV0VmFsO1xuICAgIHJldHVybiByZXRWYWw7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgYSBib2x0MTEgZm9yIGEgbmlwNTcgemFwXG4gICAqIEBwYXJhbSBldmVudFxuICAgKiBAcGFyYW0gYW1vdW50XG4gICAqIEBwYXJhbSB6YXBFbmRwb2ludFxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgYXN5bmMgZ2V0TG5JbnZvaWNlKHphcFJlcXVlc3QsIGFtb3VudCwgZGF0YSkge1xuICAgIGNvbnN0IHphcEVuZHBvaW50ID0gZGF0YS5jYWxsYmFjaztcbiAgICBjb25zdCBldmVudFBheWxvYWQgPSBKU09OLnN0cmluZ2lmeSh6YXBSZXF1ZXN0LnJhd0V2ZW50KCkpO1xuICAgIGQzKFxuICAgICAgYEZldGNoaW5nIGludm9pY2UgZnJvbSAke3phcEVuZHBvaW50fT9gICsgbmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgICAgIGFtb3VudDogYW1vdW50LnRvU3RyaW5nKCksXG4gICAgICAgIG5vc3RyOiBldmVudFBheWxvYWRcbiAgICAgIH0pXG4gICAgKTtcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHphcEVuZHBvaW50KTtcbiAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChcImFtb3VudFwiLCBhbW91bnQudG9TdHJpbmcoKSk7XG4gICAgdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJub3N0clwiLCBldmVudFBheWxvYWQpO1xuICAgIGQzKGBGZXRjaGluZyBpbnZvaWNlIGZyb20gJHt1cmwudG9TdHJpbmcoKX1gKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybC50b1N0cmluZygpKTtcbiAgICBkMyhgR290IHJlc3BvbnNlIGZyb20gemFwIGVuZHBvaW50OiAke3phcEVuZHBvaW50fWAsIHsgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMgfSk7XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICBkMyhgUmVjZWl2ZWQgbm9uLTIwMCBzdGF0dXMgZnJvbSB6YXAgZW5kcG9pbnQ6ICR7emFwRW5kcG9pbnR9YCwge1xuICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgYW1vdW50LFxuICAgICAgICBub3N0cjogZXZlbnRQYXlsb2FkXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBmZXRjaCB6YXAgZW5kcG9pbnQgJHt6YXBFbmRwb2ludH06ICR7dGV4dH1gKTtcbiAgICB9XG4gICAgY29uc3QgYm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICByZXR1cm4gYm9keS5wcjtcbiAgfVxuICBnZXRaYXBTcGxpdHMoKSB7XG4gICAgaWYgKHRoaXMudGFyZ2V0IGluc3RhbmNlb2YgTkRLVXNlcikge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAge1xuICAgICAgICAgIHB1YmtleTogdGhpcy50YXJnZXQucHVia2V5LFxuICAgICAgICAgIGFtb3VudDogdGhpcy5hbW91bnRcbiAgICAgICAgfVxuICAgICAgXTtcbiAgICB9XG4gICAgY29uc3QgemFwVGFncyA9IHRoaXMudGFyZ2V0LmdldE1hdGNoaW5nVGFncyhcInphcFwiKTtcbiAgICBpZiAoemFwVGFncy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHtcbiAgICAgICAgICBwdWJrZXk6IHRoaXMudGFyZ2V0LnB1YmtleSxcbiAgICAgICAgICBhbW91bnQ6IHRoaXMuYW1vdW50XG4gICAgICAgIH1cbiAgICAgIF07XG4gICAgfVxuICAgIGNvbnN0IHNwbGl0cyA9IFtdO1xuICAgIGNvbnN0IHRvdGFsID0gemFwVGFncy5yZWR1Y2UoKGFjYywgdGFnKSA9PiBhY2MgKyBwYXJzZUludCh0YWdbMl0pLCAwKTtcbiAgICBmb3IgKGNvbnN0IHRhZyBvZiB6YXBUYWdzKSB7XG4gICAgICBjb25zdCBwdWJrZXkgPSB0YWdbMV07XG4gICAgICBjb25zdCBhbW91bnQgPSBNYXRoLmZsb29yKHBhcnNlSW50KHRhZ1syXSkgLyB0b3RhbCAqIHRoaXMuYW1vdW50KTtcbiAgICAgIHNwbGl0cy5wdXNoKHsgcHVia2V5LCBhbW91bnQgfSk7XG4gICAgfVxuICAgIHJldHVybiBzcGxpdHM7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIHphcCBtZXRob2QgdGhhdCBzaG91bGQgYmUgdXNlZCB0byB6YXAgYSBwdWJia2V5XG4gICAqIEBwYXJhbSBuZGtcbiAgICogQHBhcmFtIHB1YmtleVxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgYXN5bmMgZ2V0WmFwTWV0aG9kcyhuZGssIHJlY2lwaWVudCwgdGltZW91dCA9IDI1MDApIHtcbiAgICBjb25zdCB1c2VyID0gbmRrLmdldFVzZXIoeyBwdWJrZXk6IHJlY2lwaWVudCB9KTtcbiAgICByZXR1cm4gYXdhaXQgdXNlci5nZXRaYXBJbmZvKHRpbWVvdXQpO1xuICB9XG4gIC8qKlxuICAgKiBAcmV0dXJucyB0aGUgcmVsYXlzIHRvIHVzZSBmb3IgdGhlIHphcCByZXF1ZXN0XG4gICAqL1xuICBhc3luYyByZWxheXMocHVia2V5KSB7XG4gICAgbGV0IHIgPSBbXTtcbiAgICBpZiAodGhpcy5uZGs/LmFjdGl2ZVVzZXIpIHtcbiAgICAgIGNvbnN0IHJlbGF5TGlzdHMgPSBhd2FpdCBnZXRSZWxheUxpc3RGb3JVc2VycyhcbiAgICAgICAgW3RoaXMubmRrLmFjdGl2ZVVzZXIucHVia2V5LCBwdWJrZXldLFxuICAgICAgICB0aGlzLm5ka1xuICAgICAgKTtcbiAgICAgIGNvbnN0IHJlbGF5U2NvcmVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIGZvciAoY29uc3QgcmVsYXlMaXN0IG9mIHJlbGF5TGlzdHMudmFsdWVzKCkpIHtcbiAgICAgICAgZm9yIChjb25zdCB1cmwgb2YgcmVsYXlMaXN0LnJlYWRSZWxheVVybHMpIHtcbiAgICAgICAgICBjb25zdCBzY29yZSA9IHJlbGF5U2NvcmVzLmdldCh1cmwpIHx8IDA7XG4gICAgICAgICAgcmVsYXlTY29yZXMuc2V0KHVybCwgc2NvcmUgKyAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgciA9IEFycmF5LmZyb20ocmVsYXlTY29yZXMuZW50cmllcygpKS5zb3J0KChhLCBiKSA9PiBiWzFdIC0gYVsxXSkubWFwKChbdXJsXSkgPT4gdXJsKS5zbGljZSgwLCB0aGlzLm1heFJlbGF5cyk7XG4gICAgfVxuICAgIGlmICh0aGlzLm5kaz8ucG9vbD8ucGVybWFuZW50QW5kQ29ubmVjdGVkUmVsYXlzKCkubGVuZ3RoKSB7XG4gICAgICByID0gdGhpcy5uZGsucG9vbC5wZXJtYW5lbnRBbmRDb25uZWN0ZWRSZWxheXMoKS5tYXAoKHJlbGF5KSA9PiByZWxheS51cmwpO1xuICAgIH1cbiAgICBpZiAoIXIubGVuZ3RoKSB7XG4gICAgICByID0gW107XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG59O1xuXG4vLyBzcmMvdXRpbHMvZmlsdGVyLnRzXG5mdW5jdGlvbiBtYXRjaEZpbHRlcihmaWx0ZXIsIGV2ZW50KSB7XG4gIGlmIChmaWx0ZXIuaWRzICYmIGZpbHRlci5pZHMuaW5kZXhPZihldmVudC5pZCkgPT09IC0xKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChmaWx0ZXIua2luZHMgJiYgZmlsdGVyLmtpbmRzLmluZGV4T2YoZXZlbnQua2luZCkgPT09IC0xKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChmaWx0ZXIuYXV0aG9ycyAmJiBmaWx0ZXIuYXV0aG9ycy5pbmRleE9mKGV2ZW50LnB1YmtleSkgPT09IC0xKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAobGV0IGYgaW4gZmlsdGVyKSB7XG4gICAgaWYgKGZbMF0gPT09IFwiI1wiKSB7XG4gICAgICBsZXQgdGFnTmFtZSA9IGYuc2xpY2UoMSk7XG4gICAgICBpZiAodGFnTmFtZSA9PT0gXCJ0XCIpIHtcbiAgICAgICAgbGV0IHZhbHVlcyA9IGZpbHRlcltgIyR7dGFnTmFtZX1gXT8ubWFwKCh2KSA9PiB2LnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICBpZiAodmFsdWVzICYmICFldmVudC50YWdzLmZpbmQoKFt0LCB2XSkgPT4gdCA9PT0gdGFnTmFtZSAmJiB2YWx1ZXMuaW5kZXhPZih2LnRvTG93ZXJDYXNlKCkpICE9PSAtMSkpIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCB2YWx1ZXMgPSBmaWx0ZXJbYCMke3RhZ05hbWV9YF07XG4gICAgICAgIGlmICh2YWx1ZXMgJiYgIWV2ZW50LnRhZ3MuZmluZCgoW3QsIHZdKSA9PiB0ID09PSB0YWdOYW1lICYmIHZhbHVlcy5pbmRleE9mKHYpICE9PSAtMSkpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGZpbHRlci5zaW5jZSAmJiBldmVudC5jcmVhdGVkX2F0IDwgZmlsdGVyLnNpbmNlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChmaWx0ZXIudW50aWwgJiYgZXZlbnQuY3JlYXRlZF9hdCA+IGZpbHRlci51bnRpbCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydCB7XG4gIEJFQ0gzMl9SRUdFWCxcbiAgTkRLQXBwSGFuZGxlckV2ZW50LFxuICBOREtBcHBTZXR0aW5ncyxcbiAgTkRLQXJ0aWNsZSxcbiAgTkRLQ2FzaHVNaW50TGlzdCxcbiAgTkRLQ2FzaHVUb2tlbixcbiAgTkRLQ2FzaHVXYWxsZXRUeCxcbiAgTkRLQ2xhc3NpZmllZCxcbiAgTkRLRFZNSm9iRmVlZGJhY2ssXG4gIE5ES0RWTUpvYlJlc3VsdCxcbiAgTkRLRFZNUmVxdWVzdCxcbiAgTkRLRHJhZnQsXG4gIE5ES0R2bUpvYkZlZWRiYWNrU3RhdHVzLFxuICBOREtFdmVudCxcbiAgTkRLSGlnaGxpZ2h0LFxuICBOREtJbWFnZSxcbiAgTkRLS2luZCxcbiAgTkRLTGlzdCxcbiAgTkRLTGlzdEtpbmRzLFxuICBOREtOaXAwN1NpZ25lcixcbiAgTkRLTmlwNDZCYWNrZW5kLFxuICBOREtOaXA0NlNpZ25lcixcbiAgTkRLTm9zdHJScGMsXG4gIE5ES051dHphcCxcbiAgTkRLUG9vbCxcbiAgTkRLUHJpdmF0ZUtleVNpZ25lcixcbiAgTkRLUHVibGlzaEVycm9yLFxuICBOREtSZWxheSxcbiAgTkRLUmVsYXlBdXRoUG9saWNpZXMsXG4gIE5ES1JlbGF5TGlzdCxcbiAgTkRLUmVsYXlTZXQsXG4gIE5ES1JlbGF5U3RhdHVzLFxuICBOREtSZXBvc3QsXG4gIE5ES1NpbXBsZUdyb3VwLFxuICBOREtTaW1wbGVHcm91cE1lbWJlckxpc3QsXG4gIE5ES1NpbXBsZUdyb3VwTWV0YWRhdGEsXG4gIE5ES1N1YnNjcmlwdGlvbixcbiAgTkRLU3Vic2NyaXB0aW9uQ2FjaGVVc2FnZSxcbiAgTkRLU3Vic2NyaXB0aW9uUmVjZWlwdCxcbiAgTkRLU3Vic2NyaXB0aW9uU3RhcnQsXG4gIE5ES1N1YnNjcmlwdGlvblRpZXIsXG4gIE5ES1RyYW5zY3JpcHRpb25EVk0sXG4gIE5ES1VzZXIsXG4gIE5ES1ZpZGVvLFxuICBOREtXaWtpLFxuICBOREtaYXBwZXIsXG4gIE5JUDMzX0FfUkVHRVgsXG4gIGNhbGN1bGF0ZVJlbGF5U2V0RnJvbUV2ZW50LFxuICBjYWxjdWxhdGVUZXJtRHVyYXRpb25JblNlY29uZHMsXG4gIGNvbXBhcmVGaWx0ZXIsXG4gIE5ESyBhcyBkZWZhdWx0LFxuICBkZWZhdWx0T3B0cyxcbiAgZGVzZXJpYWxpemUsXG4gIGR2bVNjaGVkdWxlLFxuICBldmVudEhhc0VUYWdNYXJrZXJzLFxuICBldmVudElzUGFydE9mVGhyZWFkLFxuICBldmVudElzUmVwbHksXG4gIGV2ZW50UmVwbGllcyxcbiAgZXZlbnRUaHJlYWRJZHMsXG4gIGV2ZW50VGhyZWFkcyxcbiAgZXZlbnRzQnlTYW1lQXV0aG9yLFxuICBmaWx0ZXJBbmRSZWxheVNldEZyb21CZWNoMzIsXG4gIGZpbHRlckZpbmdlcnByaW50LFxuICBmaWx0ZXJGb3JFdmVudHNUYWdnaW5nSWQsXG4gIGZpbHRlckZyb21JZCxcbiAgZ2VuZXJhdGVDb250ZW50VGFncyxcbiAgZ2VuZXJhdGVIYXNodGFncyxcbiAgZ2VuZXJhdGVTdWJJZCxcbiAgZ2VuZXJhdGVaYXBSZXF1ZXN0LFxuICBnZXRFdmVudFJlcGx5SWQsXG4gIGdldE5pcDU3WmFwU3BlY0Zyb21MdWQsXG4gIGdldFJlbGF5TGlzdEZvclVzZXIsXG4gIGdldFJlbGF5TGlzdEZvclVzZXJzLFxuICBnZXRSZXBseVRhZyxcbiAgZ2V0Um9vdEV2ZW50SWQsXG4gIGdldFJvb3RUYWcsXG4gIGltZXRhVGFnVG9UYWcsXG4gIGlzRXZlbnRPcmlnaW5hbFBvc3QsXG4gIGlzTmlwMzNBVmFsdWUsXG4gIG1hcEltZXRhVGFnLFxuICBtYXRjaEZpbHRlcixcbiAgbWVyZ2VGaWx0ZXJzLFxuICBtZXJnZVRhZ3MsXG4gIG5ld0Ftb3VudCxcbiAgbm9ybWFsaXplLFxuICBub3JtYWxpemVSZWxheVVybCxcbiAgbm9ybWFsaXplVXJsLFxuICBwYXJzZVRhZ1RvU3Vic2NyaXB0aW9uQW1vdW50LFxuICBwaW5FdmVudCxcbiAgcG9zc2libGVJbnRlcnZhbEZyZXF1ZW5jaWVzLFxuICBwcm9maWxlRnJvbUV2ZW50LFxuICBwcm9vZlAycGssXG4gIHByb29mUDJwa05vc3RyLFxuICBwcm9vZnNUb3RhbEJhbGFuY2UsXG4gIHF1ZXJ5RnVsbHlGaWxsZWQsXG4gIHJlbGF5TGlzdEZyb21LaW5kMyxcbiAgcmVsYXlzRnJvbUJlY2gzMixcbiAgc2VyaWFsaXplLFxuICBzZXJpYWxpemVQcm9maWxlLFxuICB0cnlOb3JtYWxpemVSZWxheVVybCxcbiAgdW5pcXVlVGFnLFxuICB3cmFwRXZlbnQsXG4gIHphcEludm9pY2VGcm9tRXZlbnRcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/dist/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/lib/esm/index.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/lib/esm/index.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Relay: () => (/* binding */ Relay),\n/* harmony export */   SimplePool: () => (/* binding */ SimplePool),\n/* harmony export */   finalizeEvent: () => (/* binding */ finalizeEvent),\n/* harmony export */   fj: () => (/* binding */ fakejson_exports),\n/* harmony export */   generateSecretKey: () => (/* binding */ generateSecretKey),\n/* harmony export */   getEventHash: () => (/* binding */ getEventHash),\n/* harmony export */   getFilterLimit: () => (/* binding */ getFilterLimit),\n/* harmony export */   getPublicKey: () => (/* binding */ getPublicKey),\n/* harmony export */   kinds: () => (/* binding */ kinds_exports),\n/* harmony export */   matchFilter: () => (/* binding */ matchFilter),\n/* harmony export */   matchFilters: () => (/* binding */ matchFilters),\n/* harmony export */   mergeFilters: () => (/* binding */ mergeFilters),\n/* harmony export */   nip04: () => (/* binding */ nip04_exports),\n/* harmony export */   nip05: () => (/* binding */ nip05_exports),\n/* harmony export */   nip10: () => (/* binding */ nip10_exports),\n/* harmony export */   nip11: () => (/* binding */ nip11_exports),\n/* harmony export */   nip13: () => (/* binding */ nip13_exports),\n/* harmony export */   nip18: () => (/* binding */ nip18_exports),\n/* harmony export */   nip19: () => (/* binding */ nip19_exports),\n/* harmony export */   nip21: () => (/* binding */ nip21_exports),\n/* harmony export */   nip25: () => (/* binding */ nip25_exports),\n/* harmony export */   nip27: () => (/* binding */ nip27_exports),\n/* harmony export */   nip28: () => (/* binding */ nip28_exports),\n/* harmony export */   nip30: () => (/* binding */ nip30_exports),\n/* harmony export */   nip39: () => (/* binding */ nip39_exports),\n/* harmony export */   nip42: () => (/* binding */ nip42_exports),\n/* harmony export */   nip44: () => (/* binding */ nip44_exports),\n/* harmony export */   nip47: () => (/* binding */ nip47_exports),\n/* harmony export */   nip57: () => (/* binding */ nip57_exports),\n/* harmony export */   nip59: () => (/* binding */ nip59_exports),\n/* harmony export */   nip98: () => (/* binding */ nip98_exports),\n/* harmony export */   parseReferences: () => (/* binding */ parseReferences),\n/* harmony export */   serializeEvent: () => (/* binding */ serializeEvent),\n/* harmony export */   sortEvents: () => (/* binding */ sortEvents),\n/* harmony export */   utils: () => (/* binding */ utils_exports),\n/* harmony export */   validateEvent: () => (/* binding */ validateEvent),\n/* harmony export */   verifiedSymbol: () => (/* binding */ verifiedSymbol),\n/* harmony export */   verifyEvent: () => (/* binding */ verifyEvent)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/secp256k1.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/utils */ \"(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _scure_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @scure/base */ \"(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@scure/base/lib/esm/index.js\");\n/* harmony import */ var _noble_ciphers_aes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/ciphers/aes */ \"(app-pages-browser)/./node_modules/@noble/ciphers/esm/aes.js\");\n/* harmony import */ var _noble_ciphers_chacha__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @noble/ciphers/chacha */ \"(app-pages-browser)/./node_modules/@noble/ciphers/esm/chacha.js\");\n/* harmony import */ var _noble_ciphers_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @noble/ciphers/utils */ \"(app-pages-browser)/./node_modules/@noble/ciphers/esm/utils.js\");\n/* harmony import */ var _noble_hashes_hkdf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @noble/hashes/hkdf */ \"(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/hkdf.js\");\n/* harmony import */ var _noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @noble/hashes/hmac */ \"(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/hmac.js\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// pure.ts\n\n\n\n// core.ts\nvar verifiedSymbol = Symbol(\"verified\");\nvar isRecord = (obj) => obj instanceof Object;\nfunction validateEvent(event) {\n  if (!isRecord(event))\n    return false;\n  if (typeof event.kind !== \"number\")\n    return false;\n  if (typeof event.content !== \"string\")\n    return false;\n  if (typeof event.created_at !== \"number\")\n    return false;\n  if (typeof event.pubkey !== \"string\")\n    return false;\n  if (!event.pubkey.match(/^[a-f0-9]{64}$/))\n    return false;\n  if (!Array.isArray(event.tags))\n    return false;\n  for (let i2 = 0; i2 < event.tags.length; i2++) {\n    let tag = event.tags[i2];\n    if (!Array.isArray(tag))\n      return false;\n    for (let j = 0; j < tag.length; j++) {\n      if (typeof tag[j] === \"object\")\n        return false;\n    }\n  }\n  return true;\n}\nfunction sortEvents(events) {\n  return events.sort((a, b) => {\n    if (a.created_at !== b.created_at) {\n      return b.created_at - a.created_at;\n    }\n    return a.id.localeCompare(b.id);\n  });\n}\n\n// pure.ts\n\n\n// utils.ts\nvar utils_exports = {};\n__export(utils_exports, {\n  Queue: () => Queue,\n  QueueNode: () => QueueNode,\n  binarySearch: () => binarySearch,\n  insertEventIntoAscendingList: () => insertEventIntoAscendingList,\n  insertEventIntoDescendingList: () => insertEventIntoDescendingList,\n  normalizeURL: () => normalizeURL,\n  utf8Decoder: () => utf8Decoder,\n  utf8Encoder: () => utf8Encoder\n});\nvar utf8Decoder = new TextDecoder(\"utf-8\");\nvar utf8Encoder = new TextEncoder();\nfunction normalizeURL(url) {\n  if (url.indexOf(\"://\") === -1)\n    url = \"wss://\" + url;\n  let p = new URL(url);\n  p.pathname = p.pathname.replace(/\\/+/g, \"/\");\n  if (p.pathname.endsWith(\"/\"))\n    p.pathname = p.pathname.slice(0, -1);\n  if (p.port === \"80\" && p.protocol === \"ws:\" || p.port === \"443\" && p.protocol === \"wss:\")\n    p.port = \"\";\n  p.searchParams.sort();\n  p.hash = \"\";\n  return p.toString();\n}\nfunction insertEventIntoDescendingList(sortedArray, event) {\n  const [idx, found] = binarySearch(sortedArray, (b) => {\n    if (event.id === b.id)\n      return 0;\n    if (event.created_at === b.created_at)\n      return -1;\n    return b.created_at - event.created_at;\n  });\n  if (!found) {\n    sortedArray.splice(idx, 0, event);\n  }\n  return sortedArray;\n}\nfunction insertEventIntoAscendingList(sortedArray, event) {\n  const [idx, found] = binarySearch(sortedArray, (b) => {\n    if (event.id === b.id)\n      return 0;\n    if (event.created_at === b.created_at)\n      return -1;\n    return event.created_at - b.created_at;\n  });\n  if (!found) {\n    sortedArray.splice(idx, 0, event);\n  }\n  return sortedArray;\n}\nfunction binarySearch(arr, compare) {\n  let start = 0;\n  let end = arr.length - 1;\n  while (start <= end) {\n    const mid = Math.floor((start + end) / 2);\n    const cmp = compare(arr[mid]);\n    if (cmp === 0) {\n      return [mid, true];\n    }\n    if (cmp < 0) {\n      end = mid - 1;\n    } else {\n      start = mid + 1;\n    }\n  }\n  return [start, false];\n}\nvar QueueNode = class {\n  value;\n  next = null;\n  prev = null;\n  constructor(message) {\n    this.value = message;\n  }\n};\nvar Queue = class {\n  first;\n  last;\n  constructor() {\n    this.first = null;\n    this.last = null;\n  }\n  enqueue(value) {\n    const newNode = new QueueNode(value);\n    if (!this.last) {\n      this.first = newNode;\n      this.last = newNode;\n    } else if (this.last === this.first) {\n      this.last = newNode;\n      this.last.prev = this.first;\n      this.first.next = newNode;\n    } else {\n      newNode.prev = this.last;\n      this.last.next = newNode;\n      this.last = newNode;\n    }\n    return true;\n  }\n  dequeue() {\n    if (!this.first)\n      return null;\n    if (this.first === this.last) {\n      const target2 = this.first;\n      this.first = null;\n      this.last = null;\n      return target2.value;\n    }\n    const target = this.first;\n    this.first = target.next;\n    return target.value;\n  }\n};\n\n// pure.ts\nvar JS = class {\n  generateSecretKey() {\n    return _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.schnorr.utils.randomPrivateKey();\n  }\n  getPublicKey(secretKey) {\n    return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.schnorr.getPublicKey(secretKey));\n  }\n  finalizeEvent(t, secretKey) {\n    const event = t;\n    event.pubkey = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.schnorr.getPublicKey(secretKey));\n    event.id = getEventHash(event);\n    event.sig = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.schnorr.sign(getEventHash(event), secretKey));\n    event[verifiedSymbol] = true;\n    return event;\n  }\n  verifyEvent(event) {\n    if (typeof event[verifiedSymbol] === \"boolean\")\n      return event[verifiedSymbol];\n    const hash = getEventHash(event);\n    if (hash !== event.id) {\n      event[verifiedSymbol] = false;\n      return false;\n    }\n    try {\n      const valid = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.schnorr.verify(event.sig, hash, event.pubkey);\n      event[verifiedSymbol] = valid;\n      return valid;\n    } catch (err) {\n      event[verifiedSymbol] = false;\n      return false;\n    }\n  }\n};\nfunction serializeEvent(evt) {\n  if (!validateEvent(evt))\n    throw new Error(\"can't serialize event with wrong or missing properties\");\n  return JSON.stringify([0, evt.pubkey, evt.created_at, evt.kind, evt.tags, evt.content]);\n}\nfunction getEventHash(event) {\n  let eventHash = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_1__.sha256)(utf8Encoder.encode(serializeEvent(event)));\n  return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(eventHash);\n}\nvar i = new JS();\nvar generateSecretKey = i.generateSecretKey;\nvar getPublicKey = i.getPublicKey;\nvar finalizeEvent = i.finalizeEvent;\nvar verifyEvent = i.verifyEvent;\n\n// kinds.ts\nvar kinds_exports = {};\n__export(kinds_exports, {\n  Application: () => Application,\n  BadgeAward: () => BadgeAward,\n  BadgeDefinition: () => BadgeDefinition,\n  BlockedRelaysList: () => BlockedRelaysList,\n  BookmarkList: () => BookmarkList,\n  Bookmarksets: () => Bookmarksets,\n  Calendar: () => Calendar,\n  CalendarEventRSVP: () => CalendarEventRSVP,\n  ChannelCreation: () => ChannelCreation,\n  ChannelHideMessage: () => ChannelHideMessage,\n  ChannelMessage: () => ChannelMessage,\n  ChannelMetadata: () => ChannelMetadata,\n  ChannelMuteUser: () => ChannelMuteUser,\n  ClassifiedListing: () => ClassifiedListing,\n  ClientAuth: () => ClientAuth,\n  CommunitiesList: () => CommunitiesList,\n  CommunityDefinition: () => CommunityDefinition,\n  CommunityPostApproval: () => CommunityPostApproval,\n  Contacts: () => Contacts,\n  CreateOrUpdateProduct: () => CreateOrUpdateProduct,\n  CreateOrUpdateStall: () => CreateOrUpdateStall,\n  Curationsets: () => Curationsets,\n  Date: () => Date2,\n  DirectMessageRelaysList: () => DirectMessageRelaysList,\n  DraftClassifiedListing: () => DraftClassifiedListing,\n  DraftLong: () => DraftLong,\n  Emojisets: () => Emojisets,\n  EncryptedDirectMessage: () => EncryptedDirectMessage,\n  EventDeletion: () => EventDeletion,\n  FileMetadata: () => FileMetadata,\n  FileServerPreference: () => FileServerPreference,\n  Followsets: () => Followsets,\n  GenericRepost: () => GenericRepost,\n  Genericlists: () => Genericlists,\n  GiftWrap: () => GiftWrap,\n  HTTPAuth: () => HTTPAuth,\n  Handlerinformation: () => Handlerinformation,\n  Handlerrecommendation: () => Handlerrecommendation,\n  Highlights: () => Highlights,\n  InterestsList: () => InterestsList,\n  Interestsets: () => Interestsets,\n  JobFeedback: () => JobFeedback,\n  JobRequest: () => JobRequest,\n  JobResult: () => JobResult,\n  Label: () => Label,\n  LightningPubRPC: () => LightningPubRPC,\n  LiveChatMessage: () => LiveChatMessage,\n  LiveEvent: () => LiveEvent,\n  LongFormArticle: () => LongFormArticle,\n  Metadata: () => Metadata,\n  Mutelist: () => Mutelist,\n  NWCWalletInfo: () => NWCWalletInfo,\n  NWCWalletRequest: () => NWCWalletRequest,\n  NWCWalletResponse: () => NWCWalletResponse,\n  NostrConnect: () => NostrConnect,\n  OpenTimestamps: () => OpenTimestamps,\n  Pinlist: () => Pinlist,\n  PrivateDirectMessage: () => PrivateDirectMessage,\n  ProblemTracker: () => ProblemTracker,\n  ProfileBadges: () => ProfileBadges,\n  PublicChatsList: () => PublicChatsList,\n  Reaction: () => Reaction,\n  RecommendRelay: () => RecommendRelay,\n  RelayList: () => RelayList,\n  Relaysets: () => Relaysets,\n  Report: () => Report,\n  Reporting: () => Reporting,\n  Repost: () => Repost,\n  Seal: () => Seal,\n  SearchRelaysList: () => SearchRelaysList,\n  ShortTextNote: () => ShortTextNote,\n  Time: () => Time,\n  UserEmojiList: () => UserEmojiList,\n  UserStatuses: () => UserStatuses,\n  Zap: () => Zap,\n  ZapGoal: () => ZapGoal,\n  ZapRequest: () => ZapRequest,\n  classifyKind: () => classifyKind,\n  isEphemeralKind: () => isEphemeralKind,\n  isKind: () => isKind,\n  isParameterizedReplaceableKind: () => isParameterizedReplaceableKind,\n  isRegularKind: () => isRegularKind,\n  isReplaceableKind: () => isReplaceableKind\n});\nfunction isRegularKind(kind) {\n  return 1e3 <= kind && kind < 1e4 || [1, 2, 4, 5, 6, 7, 8, 16, 40, 41, 42, 43, 44].includes(kind);\n}\nfunction isReplaceableKind(kind) {\n  return [0, 3].includes(kind) || 1e4 <= kind && kind < 2e4;\n}\nfunction isEphemeralKind(kind) {\n  return 2e4 <= kind && kind < 3e4;\n}\nfunction isParameterizedReplaceableKind(kind) {\n  return 3e4 <= kind && kind < 4e4;\n}\nfunction classifyKind(kind) {\n  if (isRegularKind(kind))\n    return \"regular\";\n  if (isReplaceableKind(kind))\n    return \"replaceable\";\n  if (isEphemeralKind(kind))\n    return \"ephemeral\";\n  if (isParameterizedReplaceableKind(kind))\n    return \"parameterized\";\n  return \"unknown\";\n}\nfunction isKind(event, kind) {\n  const kindAsArray = kind instanceof Array ? kind : [kind];\n  return validateEvent(event) && kindAsArray.includes(event.kind) || false;\n}\nvar Metadata = 0;\nvar ShortTextNote = 1;\nvar RecommendRelay = 2;\nvar Contacts = 3;\nvar EncryptedDirectMessage = 4;\nvar EventDeletion = 5;\nvar Repost = 6;\nvar Reaction = 7;\nvar BadgeAward = 8;\nvar Seal = 13;\nvar PrivateDirectMessage = 14;\nvar GenericRepost = 16;\nvar ChannelCreation = 40;\nvar ChannelMetadata = 41;\nvar ChannelMessage = 42;\nvar ChannelHideMessage = 43;\nvar ChannelMuteUser = 44;\nvar OpenTimestamps = 1040;\nvar GiftWrap = 1059;\nvar FileMetadata = 1063;\nvar LiveChatMessage = 1311;\nvar ProblemTracker = 1971;\nvar Report = 1984;\nvar Reporting = 1984;\nvar Label = 1985;\nvar CommunityPostApproval = 4550;\nvar JobRequest = 5999;\nvar JobResult = 6999;\nvar JobFeedback = 7e3;\nvar ZapGoal = 9041;\nvar ZapRequest = 9734;\nvar Zap = 9735;\nvar Highlights = 9802;\nvar Mutelist = 1e4;\nvar Pinlist = 10001;\nvar RelayList = 10002;\nvar BookmarkList = 10003;\nvar CommunitiesList = 10004;\nvar PublicChatsList = 10005;\nvar BlockedRelaysList = 10006;\nvar SearchRelaysList = 10007;\nvar InterestsList = 10015;\nvar UserEmojiList = 10030;\nvar DirectMessageRelaysList = 10050;\nvar FileServerPreference = 10096;\nvar NWCWalletInfo = 13194;\nvar LightningPubRPC = 21e3;\nvar ClientAuth = 22242;\nvar NWCWalletRequest = 23194;\nvar NWCWalletResponse = 23195;\nvar NostrConnect = 24133;\nvar HTTPAuth = 27235;\nvar Followsets = 3e4;\nvar Genericlists = 30001;\nvar Relaysets = 30002;\nvar Bookmarksets = 30003;\nvar Curationsets = 30004;\nvar ProfileBadges = 30008;\nvar BadgeDefinition = 30009;\nvar Interestsets = 30015;\nvar CreateOrUpdateStall = 30017;\nvar CreateOrUpdateProduct = 30018;\nvar LongFormArticle = 30023;\nvar DraftLong = 30024;\nvar Emojisets = 30030;\nvar Application = 30078;\nvar LiveEvent = 30311;\nvar UserStatuses = 30315;\nvar ClassifiedListing = 30402;\nvar DraftClassifiedListing = 30403;\nvar Date2 = 31922;\nvar Time = 31923;\nvar Calendar = 31924;\nvar CalendarEventRSVP = 31925;\nvar Handlerrecommendation = 31989;\nvar Handlerinformation = 31990;\nvar CommunityDefinition = 34550;\n\n// filter.ts\nfunction matchFilter(filter, event) {\n  if (filter.ids && filter.ids.indexOf(event.id) === -1) {\n    return false;\n  }\n  if (filter.kinds && filter.kinds.indexOf(event.kind) === -1) {\n    return false;\n  }\n  if (filter.authors && filter.authors.indexOf(event.pubkey) === -1) {\n    return false;\n  }\n  for (let f in filter) {\n    if (f[0] === \"#\") {\n      let tagName = f.slice(1);\n      let values = filter[`#${tagName}`];\n      if (values && !event.tags.find(([t, v]) => t === f.slice(1) && values.indexOf(v) !== -1))\n        return false;\n    }\n  }\n  if (filter.since && event.created_at < filter.since)\n    return false;\n  if (filter.until && event.created_at > filter.until)\n    return false;\n  return true;\n}\nfunction matchFilters(filters, event) {\n  for (let i2 = 0; i2 < filters.length; i2++) {\n    if (matchFilter(filters[i2], event)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction mergeFilters(...filters) {\n  let result = {};\n  for (let i2 = 0; i2 < filters.length; i2++) {\n    let filter = filters[i2];\n    Object.entries(filter).forEach(([property, values]) => {\n      if (property === \"kinds\" || property === \"ids\" || property === \"authors\" || property[0] === \"#\") {\n        result[property] = result[property] || [];\n        for (let v = 0; v < values.length; v++) {\n          let value = values[v];\n          if (!result[property].includes(value))\n            result[property].push(value);\n        }\n      }\n    });\n    if (filter.limit && (!result.limit || filter.limit > result.limit))\n      result.limit = filter.limit;\n    if (filter.until && (!result.until || filter.until > result.until))\n      result.until = filter.until;\n    if (filter.since && (!result.since || filter.since < result.since))\n      result.since = filter.since;\n  }\n  return result;\n}\nfunction getFilterLimit(filter) {\n  if (filter.ids && !filter.ids.length)\n    return 0;\n  if (filter.kinds && !filter.kinds.length)\n    return 0;\n  if (filter.authors && !filter.authors.length)\n    return 0;\n  for (const [key, value] of Object.entries(filter)) {\n    if (key[0] === \"#\" && Array.isArray(value) && !value.length)\n      return 0;\n  }\n  return Math.min(\n    Math.max(0, filter.limit ?? Infinity),\n    filter.ids?.length ?? Infinity,\n    filter.authors?.length && filter.kinds?.every((kind) => isReplaceableKind(kind)) ? filter.authors.length * filter.kinds.length : Infinity,\n    filter.authors?.length && filter.kinds?.every((kind) => isParameterizedReplaceableKind(kind)) && filter[\"#d\"]?.length ? filter.authors.length * filter.kinds.length * filter[\"#d\"].length : Infinity\n  );\n}\n\n// fakejson.ts\nvar fakejson_exports = {};\n__export(fakejson_exports, {\n  getHex64: () => getHex64,\n  getInt: () => getInt,\n  getSubscriptionId: () => getSubscriptionId,\n  matchEventId: () => matchEventId,\n  matchEventKind: () => matchEventKind,\n  matchEventPubkey: () => matchEventPubkey\n});\nfunction getHex64(json, field) {\n  let len = field.length + 3;\n  let idx = json.indexOf(`\"${field}\":`) + len;\n  let s = json.slice(idx).indexOf(`\"`) + idx + 1;\n  return json.slice(s, s + 64);\n}\nfunction getInt(json, field) {\n  let len = field.length;\n  let idx = json.indexOf(`\"${field}\":`) + len + 3;\n  let sliced = json.slice(idx);\n  let end = Math.min(sliced.indexOf(\",\"), sliced.indexOf(\"}\"));\n  return parseInt(sliced.slice(0, end), 10);\n}\nfunction getSubscriptionId(json) {\n  let idx = json.slice(0, 22).indexOf(`\"EVENT\"`);\n  if (idx === -1)\n    return null;\n  let pstart = json.slice(idx + 7 + 1).indexOf(`\"`);\n  if (pstart === -1)\n    return null;\n  let start = idx + 7 + 1 + pstart;\n  let pend = json.slice(start + 1, 80).indexOf(`\"`);\n  if (pend === -1)\n    return null;\n  let end = start + 1 + pend;\n  return json.slice(start + 1, end);\n}\nfunction matchEventId(json, id) {\n  return id === getHex64(json, \"id\");\n}\nfunction matchEventPubkey(json, pubkey) {\n  return pubkey === getHex64(json, \"pubkey\");\n}\nfunction matchEventKind(json, kind) {\n  return kind === getInt(json, \"kind\");\n}\n\n// nip42.ts\nvar nip42_exports = {};\n__export(nip42_exports, {\n  makeAuthEvent: () => makeAuthEvent\n});\nfunction makeAuthEvent(relayURL, challenge) {\n  return {\n    kind: ClientAuth,\n    created_at: Math.floor(Date.now() / 1e3),\n    tags: [\n      [\"relay\", relayURL],\n      [\"challenge\", challenge]\n    ],\n    content: \"\"\n  };\n}\n\n// helpers.ts\nasync function yieldThread() {\n  return new Promise((resolve) => {\n    const ch = new MessageChannel();\n    const handler = () => {\n      ch.port1.removeEventListener(\"message\", handler);\n      resolve();\n    };\n    ch.port1.addEventListener(\"message\", handler);\n    ch.port2.postMessage(0);\n    ch.port1.start();\n  });\n}\nvar alwaysTrue = (t) => {\n  t[verifiedSymbol] = true;\n  return true;\n};\n\n// abstract-relay.ts\nvar AbstractRelay = class {\n  url;\n  _connected = false;\n  onclose = null;\n  onnotice = (msg) => console.debug(`NOTICE from ${this.url}: ${msg}`);\n  _onauth = null;\n  baseEoseTimeout = 4400;\n  connectionTimeout = 4400;\n  publishTimeout = 4400;\n  openSubs = /* @__PURE__ */ new Map();\n  connectionTimeoutHandle;\n  connectionPromise;\n  openCountRequests = /* @__PURE__ */ new Map();\n  openEventPublishes = /* @__PURE__ */ new Map();\n  ws;\n  incomingMessageQueue = new Queue();\n  queueRunning = false;\n  challenge;\n  serial = 0;\n  verifyEvent;\n  _WebSocket;\n  constructor(url, opts) {\n    this.url = normalizeURL(url);\n    this.verifyEvent = opts.verifyEvent;\n    this._WebSocket = opts.websocketImplementation || WebSocket;\n  }\n  static async connect(url, opts) {\n    const relay = new AbstractRelay(url, opts);\n    await relay.connect();\n    return relay;\n  }\n  closeAllSubscriptions(reason) {\n    for (let [_, sub] of this.openSubs) {\n      sub.close(reason);\n    }\n    this.openSubs.clear();\n    for (let [_, ep] of this.openEventPublishes) {\n      ep.reject(new Error(reason));\n    }\n    this.openEventPublishes.clear();\n    for (let [_, cr] of this.openCountRequests) {\n      cr.reject(new Error(reason));\n    }\n    this.openCountRequests.clear();\n  }\n  get connected() {\n    return this._connected;\n  }\n  async connect() {\n    if (this.connectionPromise)\n      return this.connectionPromise;\n    this.challenge = void 0;\n    this.connectionPromise = new Promise((resolve, reject) => {\n      this.connectionTimeoutHandle = setTimeout(() => {\n        reject(\"connection timed out\");\n        this.connectionPromise = void 0;\n        this.onclose?.();\n        this.closeAllSubscriptions(\"relay connection timed out\");\n      }, this.connectionTimeout);\n      try {\n        this.ws = new this._WebSocket(this.url);\n      } catch (err) {\n        reject(err);\n        return;\n      }\n      this.ws.onopen = () => {\n        clearTimeout(this.connectionTimeoutHandle);\n        this._connected = true;\n        resolve();\n      };\n      this.ws.onerror = (ev) => {\n        reject(ev.message || \"websocket error\");\n        if (this._connected) {\n          this._connected = false;\n          this.connectionPromise = void 0;\n          this.onclose?.();\n          this.closeAllSubscriptions(\"relay connection errored\");\n        }\n      };\n      this.ws.onclose = async () => {\n        if (this._connected) {\n          this._connected = false;\n          this.connectionPromise = void 0;\n          this.onclose?.();\n          this.closeAllSubscriptions(\"relay connection closed\");\n        }\n      };\n      this.ws.onmessage = this._onmessage.bind(this);\n    });\n    return this.connectionPromise;\n  }\n  async runQueue() {\n    this.queueRunning = true;\n    while (true) {\n      if (false === this.handleNext()) {\n        break;\n      }\n      await yieldThread();\n    }\n    this.queueRunning = false;\n  }\n  handleNext() {\n    const json = this.incomingMessageQueue.dequeue();\n    if (!json) {\n      return false;\n    }\n    const subid = getSubscriptionId(json);\n    if (subid) {\n      const so = this.openSubs.get(subid);\n      if (!so) {\n        return;\n      }\n      const id = getHex64(json, \"id\");\n      const alreadyHave = so.alreadyHaveEvent?.(id);\n      so.receivedEvent?.(this, id);\n      if (alreadyHave) {\n        return;\n      }\n    }\n    try {\n      let data = JSON.parse(json);\n      switch (data[0]) {\n        case \"EVENT\": {\n          const so = this.openSubs.get(data[1]);\n          const event = data[2];\n          if (this.verifyEvent(event) && matchFilters(so.filters, event)) {\n            so.onevent(event);\n          }\n          return;\n        }\n        case \"COUNT\": {\n          const id = data[1];\n          const payload = data[2];\n          const cr = this.openCountRequests.get(id);\n          if (cr) {\n            cr.resolve(payload.count);\n            this.openCountRequests.delete(id);\n          }\n          return;\n        }\n        case \"EOSE\": {\n          const so = this.openSubs.get(data[1]);\n          if (!so)\n            return;\n          so.receivedEose();\n          return;\n        }\n        case \"OK\": {\n          const id = data[1];\n          const ok = data[2];\n          const reason = data[3];\n          const ep = this.openEventPublishes.get(id);\n          if (ep) {\n            if (ok)\n              ep.resolve(reason);\n            else\n              ep.reject(new Error(reason));\n            this.openEventPublishes.delete(id);\n          }\n          return;\n        }\n        case \"CLOSED\": {\n          const id = data[1];\n          const so = this.openSubs.get(id);\n          if (!so)\n            return;\n          so.closed = true;\n          so.close(data[2]);\n          return;\n        }\n        case \"NOTICE\":\n          this.onnotice(data[1]);\n          return;\n        case \"AUTH\": {\n          this.challenge = data[1];\n          this._onauth?.(data[1]);\n          return;\n        }\n      }\n    } catch (err) {\n      return;\n    }\n  }\n  async send(message) {\n    if (!this.connectionPromise)\n      throw new Error(\"sending on closed connection\");\n    this.connectionPromise.then(() => {\n      this.ws?.send(message);\n    });\n  }\n  async auth(signAuthEvent) {\n    if (!this.challenge)\n      throw new Error(\"can't perform auth, no challenge was received\");\n    const evt = await signAuthEvent(makeAuthEvent(this.url, this.challenge));\n    const ret = new Promise((resolve, reject) => {\n      this.openEventPublishes.set(evt.id, { resolve, reject });\n    });\n    this.send('[\"AUTH\",' + JSON.stringify(evt) + \"]\");\n    return ret;\n  }\n  async publish(event) {\n    const ret = new Promise((resolve, reject) => {\n      this.openEventPublishes.set(event.id, { resolve, reject });\n    });\n    this.send('[\"EVENT\",' + JSON.stringify(event) + \"]\");\n    setTimeout(() => {\n      const ep = this.openEventPublishes.get(event.id);\n      if (ep) {\n        ep.reject(new Error(\"publish timed out\"));\n        this.openEventPublishes.delete(event.id);\n      }\n    }, this.publishTimeout);\n    return ret;\n  }\n  async count(filters, params) {\n    this.serial++;\n    const id = params?.id || \"count:\" + this.serial;\n    const ret = new Promise((resolve, reject) => {\n      this.openCountRequests.set(id, { resolve, reject });\n    });\n    this.send('[\"COUNT\",\"' + id + '\",' + JSON.stringify(filters).substring(1));\n    return ret;\n  }\n  subscribe(filters, params) {\n    const subscription = this.prepareSubscription(filters, params);\n    subscription.fire();\n    return subscription;\n  }\n  prepareSubscription(filters, params) {\n    this.serial++;\n    const id = params.id || \"sub:\" + this.serial;\n    const subscription = new Subscription(this, id, filters, params);\n    this.openSubs.set(id, subscription);\n    return subscription;\n  }\n  close() {\n    this.closeAllSubscriptions(\"relay connection closed by us\");\n    this._connected = false;\n    this.ws?.close();\n  }\n  _onmessage(ev) {\n    this.incomingMessageQueue.enqueue(ev.data);\n    if (!this.queueRunning) {\n      this.runQueue();\n    }\n  }\n};\nvar Subscription = class {\n  relay;\n  id;\n  closed = false;\n  eosed = false;\n  filters;\n  alreadyHaveEvent;\n  receivedEvent;\n  onevent;\n  oneose;\n  onclose;\n  eoseTimeout;\n  eoseTimeoutHandle;\n  constructor(relay, id, filters, params) {\n    this.relay = relay;\n    this.filters = filters;\n    this.id = id;\n    this.alreadyHaveEvent = params.alreadyHaveEvent;\n    this.receivedEvent = params.receivedEvent;\n    this.eoseTimeout = params.eoseTimeout || relay.baseEoseTimeout;\n    this.oneose = params.oneose;\n    this.onclose = params.onclose;\n    this.onevent = params.onevent || ((event) => {\n      console.warn(\n        `onevent() callback not defined for subscription '${this.id}' in relay ${this.relay.url}. event received:`,\n        event\n      );\n    });\n  }\n  fire() {\n    this.relay.send('[\"REQ\",\"' + this.id + '\",' + JSON.stringify(this.filters).substring(1));\n    this.eoseTimeoutHandle = setTimeout(this.receivedEose.bind(this), this.eoseTimeout);\n  }\n  receivedEose() {\n    if (this.eosed)\n      return;\n    clearTimeout(this.eoseTimeoutHandle);\n    this.eosed = true;\n    this.oneose?.();\n  }\n  close(reason = \"closed by caller\") {\n    if (!this.closed && this.relay.connected) {\n      this.relay.send('[\"CLOSE\",' + JSON.stringify(this.id) + \"]\");\n      this.closed = true;\n    }\n    this.relay.openSubs.delete(this.id);\n    this.onclose?.(reason);\n  }\n};\n\n// relay.ts\nvar _WebSocket;\ntry {\n  _WebSocket = WebSocket;\n} catch {\n}\nvar Relay = class extends AbstractRelay {\n  constructor(url) {\n    super(url, { verifyEvent, websocketImplementation: _WebSocket });\n  }\n  static async connect(url) {\n    const relay = new Relay(url);\n    await relay.connect();\n    return relay;\n  }\n};\n\n// abstract-pool.ts\nvar AbstractSimplePool = class {\n  relays = /* @__PURE__ */ new Map();\n  seenOn = /* @__PURE__ */ new Map();\n  trackRelays = false;\n  verifyEvent;\n  trustedRelayURLs = /* @__PURE__ */ new Set();\n  _WebSocket;\n  constructor(opts) {\n    this.verifyEvent = opts.verifyEvent;\n    this._WebSocket = opts.websocketImplementation;\n  }\n  async ensureRelay(url, params) {\n    url = normalizeURL(url);\n    let relay = this.relays.get(url);\n    if (!relay) {\n      relay = new AbstractRelay(url, {\n        verifyEvent: this.trustedRelayURLs.has(url) ? alwaysTrue : this.verifyEvent,\n        websocketImplementation: this._WebSocket\n      });\n      if (params?.connectionTimeout)\n        relay.connectionTimeout = params.connectionTimeout;\n      this.relays.set(url, relay);\n    }\n    await relay.connect();\n    return relay;\n  }\n  close(relays) {\n    relays.map(normalizeURL).forEach((url) => {\n      this.relays.get(url)?.close();\n    });\n  }\n  subscribeMany(relays, filters, params) {\n    return this.subscribeManyMap(Object.fromEntries(relays.map((url) => [url, filters])), params);\n  }\n  subscribeManyMap(requests, params) {\n    if (this.trackRelays) {\n      params.receivedEvent = (relay, id) => {\n        let set = this.seenOn.get(id);\n        if (!set) {\n          set = /* @__PURE__ */ new Set();\n          this.seenOn.set(id, set);\n        }\n        set.add(relay);\n      };\n    }\n    const _knownIds = /* @__PURE__ */ new Set();\n    const subs = [];\n    const relaysLength = Object.keys(requests).length;\n    const eosesReceived = [];\n    let handleEose = (i2) => {\n      eosesReceived[i2] = true;\n      if (eosesReceived.filter((a) => a).length === relaysLength) {\n        params.oneose?.();\n        handleEose = () => {\n        };\n      }\n    };\n    const closesReceived = [];\n    let handleClose = (i2, reason) => {\n      handleEose(i2);\n      closesReceived[i2] = reason;\n      if (closesReceived.filter((a) => a).length === relaysLength) {\n        params.onclose?.(closesReceived);\n        handleClose = () => {\n        };\n      }\n    };\n    const localAlreadyHaveEventHandler = (id) => {\n      if (params.alreadyHaveEvent?.(id)) {\n        return true;\n      }\n      const have = _knownIds.has(id);\n      _knownIds.add(id);\n      return have;\n    };\n    const allOpened = Promise.all(\n      Object.entries(requests).map(async (req, i2, arr) => {\n        if (arr.indexOf(req) !== i2) {\n          handleClose(i2, \"duplicate url\");\n          return;\n        }\n        let [url, filters] = req;\n        url = normalizeURL(url);\n        let relay;\n        try {\n          relay = await this.ensureRelay(url, {\n            connectionTimeout: params.maxWait ? Math.max(params.maxWait * 0.8, params.maxWait - 1e3) : void 0\n          });\n        } catch (err) {\n          handleClose(i2, err?.message || String(err));\n          return;\n        }\n        let subscription = relay.subscribe(filters, {\n          ...params,\n          oneose: () => handleEose(i2),\n          onclose: (reason) => handleClose(i2, reason),\n          alreadyHaveEvent: localAlreadyHaveEventHandler,\n          eoseTimeout: params.maxWait\n        });\n        subs.push(subscription);\n      })\n    );\n    return {\n      async close() {\n        await allOpened;\n        subs.forEach((sub) => {\n          sub.close();\n        });\n      }\n    };\n  }\n  subscribeManyEose(relays, filters, params) {\n    const subcloser = this.subscribeMany(relays, filters, {\n      ...params,\n      oneose() {\n        subcloser.close();\n      }\n    });\n    return subcloser;\n  }\n  async querySync(relays, filter, params) {\n    return new Promise(async (resolve) => {\n      const events = [];\n      this.subscribeManyEose(relays, [filter], {\n        ...params,\n        onevent(event) {\n          events.push(event);\n        },\n        onclose(_) {\n          resolve(events);\n        }\n      });\n    });\n  }\n  async get(relays, filter, params) {\n    filter.limit = 1;\n    const events = await this.querySync(relays, filter, params);\n    events.sort((a, b) => b.created_at - a.created_at);\n    return events[0] || null;\n  }\n  publish(relays, event) {\n    return relays.map(normalizeURL).map(async (url, i2, arr) => {\n      if (arr.indexOf(url) !== i2) {\n        return Promise.reject(\"duplicate url\");\n      }\n      let r = await this.ensureRelay(url);\n      return r.publish(event).then((reason) => {\n        if (this.trackRelays) {\n          let set = this.seenOn.get(event.id);\n          if (!set) {\n            set = /* @__PURE__ */ new Set();\n            this.seenOn.set(event.id, set);\n          }\n          set.add(r);\n        }\n        return reason;\n      });\n    });\n  }\n  listConnectionStatus() {\n    const map = /* @__PURE__ */ new Map();\n    this.relays.forEach((relay, url) => map.set(url, relay.connected));\n    return map;\n  }\n  destroy() {\n    this.relays.forEach((conn) => conn.close());\n    this.relays = /* @__PURE__ */ new Map();\n  }\n};\n\n// pool.ts\nvar _WebSocket2;\ntry {\n  _WebSocket2 = WebSocket;\n} catch {\n}\nvar SimplePool = class extends AbstractSimplePool {\n  constructor() {\n    super({ verifyEvent, websocketImplementation: _WebSocket2 });\n  }\n};\n\n// nip19.ts\nvar nip19_exports = {};\n__export(nip19_exports, {\n  BECH32_REGEX: () => BECH32_REGEX,\n  Bech32MaxSize: () => Bech32MaxSize,\n  NostrTypeGuard: () => NostrTypeGuard,\n  decode: () => decode,\n  encodeBytes: () => encodeBytes,\n  naddrEncode: () => naddrEncode,\n  neventEncode: () => neventEncode,\n  noteEncode: () => noteEncode,\n  nprofileEncode: () => nprofileEncode,\n  npubEncode: () => npubEncode,\n  nsecEncode: () => nsecEncode\n});\n\n\nvar NostrTypeGuard = {\n  isNProfile: (value) => /^nprofile1[a-z\\d]+$/.test(value || \"\"),\n  isNEvent: (value) => /^nevent1[a-z\\d]+$/.test(value || \"\"),\n  isNAddr: (value) => /^naddr1[a-z\\d]+$/.test(value || \"\"),\n  isNSec: (value) => /^nsec1[a-z\\d]{58}$/.test(value || \"\"),\n  isNPub: (value) => /^npub1[a-z\\d]{58}$/.test(value || \"\"),\n  isNote: (value) => /^note1[a-z\\d]+$/.test(value || \"\"),\n  isNcryptsec: (value) => /^ncryptsec1[a-z\\d]+$/.test(value || \"\")\n};\nvar Bech32MaxSize = 5e3;\nvar BECH32_REGEX = /[\\x21-\\x7E]{1,83}1[023456789acdefghjklmnpqrstuvwxyz]{6,}/;\nfunction integerToUint8Array(number) {\n  const uint8Array = new Uint8Array(4);\n  uint8Array[0] = number >> 24 & 255;\n  uint8Array[1] = number >> 16 & 255;\n  uint8Array[2] = number >> 8 & 255;\n  uint8Array[3] = number & 255;\n  return uint8Array;\n}\nfunction decode(nip19) {\n  let { prefix, words } = _scure_base__WEBPACK_IMPORTED_MODULE_3__.bech32.decode(nip19, Bech32MaxSize);\n  let data = new Uint8Array(_scure_base__WEBPACK_IMPORTED_MODULE_3__.bech32.fromWords(words));\n  switch (prefix) {\n    case \"nprofile\": {\n      let tlv = parseTLV(data);\n      if (!tlv[0]?.[0])\n        throw new Error(\"missing TLV 0 for nprofile\");\n      if (tlv[0][0].length !== 32)\n        throw new Error(\"TLV 0 should be 32 bytes\");\n      return {\n        type: \"nprofile\",\n        data: {\n          pubkey: (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(tlv[0][0]),\n          relays: tlv[1] ? tlv[1].map((d) => utf8Decoder.decode(d)) : []\n        }\n      };\n    }\n    case \"nevent\": {\n      let tlv = parseTLV(data);\n      if (!tlv[0]?.[0])\n        throw new Error(\"missing TLV 0 for nevent\");\n      if (tlv[0][0].length !== 32)\n        throw new Error(\"TLV 0 should be 32 bytes\");\n      if (tlv[2] && tlv[2][0].length !== 32)\n        throw new Error(\"TLV 2 should be 32 bytes\");\n      if (tlv[3] && tlv[3][0].length !== 4)\n        throw new Error(\"TLV 3 should be 4 bytes\");\n      return {\n        type: \"nevent\",\n        data: {\n          id: (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(tlv[0][0]),\n          relays: tlv[1] ? tlv[1].map((d) => utf8Decoder.decode(d)) : [],\n          author: tlv[2]?.[0] ? (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(tlv[2][0]) : void 0,\n          kind: tlv[3]?.[0] ? parseInt((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(tlv[3][0]), 16) : void 0\n        }\n      };\n    }\n    case \"naddr\": {\n      let tlv = parseTLV(data);\n      if (!tlv[0]?.[0])\n        throw new Error(\"missing TLV 0 for naddr\");\n      if (!tlv[2]?.[0])\n        throw new Error(\"missing TLV 2 for naddr\");\n      if (tlv[2][0].length !== 32)\n        throw new Error(\"TLV 2 should be 32 bytes\");\n      if (!tlv[3]?.[0])\n        throw new Error(\"missing TLV 3 for naddr\");\n      if (tlv[3][0].length !== 4)\n        throw new Error(\"TLV 3 should be 4 bytes\");\n      return {\n        type: \"naddr\",\n        data: {\n          identifier: utf8Decoder.decode(tlv[0][0]),\n          pubkey: (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(tlv[2][0]),\n          kind: parseInt((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(tlv[3][0]), 16),\n          relays: tlv[1] ? tlv[1].map((d) => utf8Decoder.decode(d)) : []\n        }\n      };\n    }\n    case \"nsec\":\n      return { type: prefix, data };\n    case \"npub\":\n    case \"note\":\n      return { type: prefix, data: (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(data) };\n    default:\n      throw new Error(`unknown prefix ${prefix}`);\n  }\n}\nfunction parseTLV(data) {\n  let result = {};\n  let rest = data;\n  while (rest.length > 0) {\n    let t = rest[0];\n    let l = rest[1];\n    let v = rest.slice(2, 2 + l);\n    rest = rest.slice(2 + l);\n    if (v.length < l)\n      throw new Error(`not enough data to read on TLV ${t}`);\n    result[t] = result[t] || [];\n    result[t].push(v);\n  }\n  return result;\n}\nfunction nsecEncode(key) {\n  return encodeBytes(\"nsec\", key);\n}\nfunction npubEncode(hex) {\n  return encodeBytes(\"npub\", (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.hexToBytes)(hex));\n}\nfunction noteEncode(hex) {\n  return encodeBytes(\"note\", (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.hexToBytes)(hex));\n}\nfunction encodeBech32(prefix, data) {\n  let words = _scure_base__WEBPACK_IMPORTED_MODULE_3__.bech32.toWords(data);\n  return _scure_base__WEBPACK_IMPORTED_MODULE_3__.bech32.encode(prefix, words, Bech32MaxSize);\n}\nfunction encodeBytes(prefix, bytes) {\n  return encodeBech32(prefix, bytes);\n}\nfunction nprofileEncode(profile) {\n  let data = encodeTLV({\n    0: [(0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.hexToBytes)(profile.pubkey)],\n    1: (profile.relays || []).map((url) => utf8Encoder.encode(url))\n  });\n  return encodeBech32(\"nprofile\", data);\n}\nfunction neventEncode(event) {\n  let kindArray;\n  if (event.kind !== void 0) {\n    kindArray = integerToUint8Array(event.kind);\n  }\n  let data = encodeTLV({\n    0: [(0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.hexToBytes)(event.id)],\n    1: (event.relays || []).map((url) => utf8Encoder.encode(url)),\n    2: event.author ? [(0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.hexToBytes)(event.author)] : [],\n    3: kindArray ? [new Uint8Array(kindArray)] : []\n  });\n  return encodeBech32(\"nevent\", data);\n}\nfunction naddrEncode(addr) {\n  let kind = new ArrayBuffer(4);\n  new DataView(kind).setUint32(0, addr.kind, false);\n  let data = encodeTLV({\n    0: [utf8Encoder.encode(addr.identifier)],\n    1: (addr.relays || []).map((url) => utf8Encoder.encode(url)),\n    2: [(0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.hexToBytes)(addr.pubkey)],\n    3: [new Uint8Array(kind)]\n  });\n  return encodeBech32(\"naddr\", data);\n}\nfunction encodeTLV(tlv) {\n  let entries = [];\n  Object.entries(tlv).reverse().forEach(([t, vs]) => {\n    vs.forEach((v) => {\n      let entry = new Uint8Array(v.length + 2);\n      entry.set([parseInt(t)], 0);\n      entry.set([v.length], 1);\n      entry.set(v, 2);\n      entries.push(entry);\n    });\n  });\n  return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...entries);\n}\n\n// references.ts\nvar mentionRegex = /\\bnostr:((note|npub|naddr|nevent|nprofile)1\\w+)\\b|#\\[(\\d+)\\]/g;\nfunction parseReferences(evt) {\n  let references = [];\n  for (let ref of evt.content.matchAll(mentionRegex)) {\n    if (ref[2]) {\n      try {\n        let { type, data } = decode(ref[1]);\n        switch (type) {\n          case \"npub\": {\n            references.push({\n              text: ref[0],\n              profile: { pubkey: data, relays: [] }\n            });\n            break;\n          }\n          case \"nprofile\": {\n            references.push({\n              text: ref[0],\n              profile: data\n            });\n            break;\n          }\n          case \"note\": {\n            references.push({\n              text: ref[0],\n              event: { id: data, relays: [] }\n            });\n            break;\n          }\n          case \"nevent\": {\n            references.push({\n              text: ref[0],\n              event: data\n            });\n            break;\n          }\n          case \"naddr\": {\n            references.push({\n              text: ref[0],\n              address: data\n            });\n            break;\n          }\n        }\n      } catch (err) {\n      }\n    } else if (ref[3]) {\n      let idx = parseInt(ref[3], 10);\n      let tag = evt.tags[idx];\n      if (!tag)\n        continue;\n      switch (tag[0]) {\n        case \"p\": {\n          references.push({\n            text: ref[0],\n            profile: { pubkey: tag[1], relays: tag[2] ? [tag[2]] : [] }\n          });\n          break;\n        }\n        case \"e\": {\n          references.push({\n            text: ref[0],\n            event: { id: tag[1], relays: tag[2] ? [tag[2]] : [] }\n          });\n          break;\n        }\n        case \"a\": {\n          try {\n            let [kind, pubkey, identifier] = tag[1].split(\":\");\n            references.push({\n              text: ref[0],\n              address: {\n                identifier,\n                pubkey,\n                kind: parseInt(kind, 10),\n                relays: tag[2] ? [tag[2]] : []\n              }\n            });\n          } catch (err) {\n          }\n          break;\n        }\n      }\n    }\n  }\n  return references;\n}\n\n// nip04.ts\nvar nip04_exports = {};\n__export(nip04_exports, {\n  decrypt: () => decrypt,\n  encrypt: () => encrypt\n});\n\n\n\n\nasync function encrypt(secretKey, pubkey, text) {\n  const privkey = secretKey instanceof Uint8Array ? (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(secretKey) : secretKey;\n  const key = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.getSharedSecret(privkey, \"02\" + pubkey);\n  const normalizedKey = getNormalizedX(key);\n  let iv = Uint8Array.from((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.randomBytes)(16));\n  let plaintext = utf8Encoder.encode(text);\n  let ciphertext = (0,_noble_ciphers_aes__WEBPACK_IMPORTED_MODULE_4__.cbc)(normalizedKey, iv).encrypt(plaintext);\n  let ctb64 = _scure_base__WEBPACK_IMPORTED_MODULE_3__.base64.encode(new Uint8Array(ciphertext));\n  let ivb64 = _scure_base__WEBPACK_IMPORTED_MODULE_3__.base64.encode(new Uint8Array(iv.buffer));\n  return `${ctb64}?iv=${ivb64}`;\n}\nasync function decrypt(secretKey, pubkey, data) {\n  const privkey = secretKey instanceof Uint8Array ? (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(secretKey) : secretKey;\n  let [ctb64, ivb64] = data.split(\"?iv=\");\n  let key = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.getSharedSecret(privkey, \"02\" + pubkey);\n  let normalizedKey = getNormalizedX(key);\n  let iv = _scure_base__WEBPACK_IMPORTED_MODULE_3__.base64.decode(ivb64);\n  let ciphertext = _scure_base__WEBPACK_IMPORTED_MODULE_3__.base64.decode(ctb64);\n  let plaintext = (0,_noble_ciphers_aes__WEBPACK_IMPORTED_MODULE_4__.cbc)(normalizedKey, iv).decrypt(ciphertext);\n  return utf8Decoder.decode(plaintext);\n}\nfunction getNormalizedX(key) {\n  return key.slice(1, 33);\n}\n\n// nip05.ts\nvar nip05_exports = {};\n__export(nip05_exports, {\n  NIP05_REGEX: () => NIP05_REGEX,\n  isNip05: () => isNip05,\n  isValid: () => isValid,\n  queryProfile: () => queryProfile,\n  searchDomain: () => searchDomain,\n  useFetchImplementation: () => useFetchImplementation\n});\nvar NIP05_REGEX = /^(?:([\\w.+-]+)@)?([\\w_-]+(\\.[\\w_-]+)+)$/;\nvar isNip05 = (value) => NIP05_REGEX.test(value || \"\");\nvar _fetch;\ntry {\n  _fetch = fetch;\n} catch (_) {\n  null;\n}\nfunction useFetchImplementation(fetchImplementation) {\n  _fetch = fetchImplementation;\n}\nasync function searchDomain(domain, query = \"\") {\n  try {\n    const url = `https://${domain}/.well-known/nostr.json?name=${query}`;\n    const res = await _fetch(url, { redirect: \"manual\" });\n    if (res.status !== 200) {\n      throw Error(\"Wrong response code\");\n    }\n    const json = await res.json();\n    return json.names;\n  } catch (_) {\n    return {};\n  }\n}\nasync function queryProfile(fullname) {\n  const match = fullname.match(NIP05_REGEX);\n  if (!match)\n    return null;\n  const [, name = \"_\", domain] = match;\n  try {\n    const url = `https://${domain}/.well-known/nostr.json?name=${name}`;\n    const res = await _fetch(url, { redirect: \"manual\" });\n    if (res.status !== 200) {\n      throw Error(\"Wrong response code\");\n    }\n    const json = await res.json();\n    const pubkey = json.names[name];\n    return pubkey ? { pubkey, relays: json.relays?.[pubkey] } : null;\n  } catch (_e) {\n    return null;\n  }\n}\nasync function isValid(pubkey, nip05) {\n  const res = await queryProfile(nip05);\n  return res ? res.pubkey === pubkey : false;\n}\n\n// nip10.ts\nvar nip10_exports = {};\n__export(nip10_exports, {\n  parse: () => parse\n});\nfunction parse(event) {\n  const result = {\n    reply: void 0,\n    root: void 0,\n    mentions: [],\n    profiles: [],\n    quotes: []\n  };\n  let maybeParent;\n  let maybeRoot;\n  for (let i2 = event.tags.length - 1; i2 >= 0; i2--) {\n    const tag = event.tags[i2];\n    if (tag[0] === \"e\" && tag[1]) {\n      const [_, eTagEventId, eTagRelayUrl, eTagMarker, eTagAuthor] = tag;\n      const eventPointer = {\n        id: eTagEventId,\n        relays: eTagRelayUrl ? [eTagRelayUrl] : [],\n        author: eTagAuthor\n      };\n      if (eTagMarker === \"root\") {\n        result.root = eventPointer;\n        continue;\n      }\n      if (eTagMarker === \"reply\") {\n        result.reply = eventPointer;\n        continue;\n      }\n      if (eTagMarker === \"mention\") {\n        result.mentions.push(eventPointer);\n        continue;\n      }\n      if (!maybeParent) {\n        maybeParent = eventPointer;\n      } else {\n        maybeRoot = eventPointer;\n      }\n      result.mentions.push(eventPointer);\n      continue;\n    }\n    if (tag[0] === \"q\" && tag[1]) {\n      const [_, eTagEventId, eTagRelayUrl] = tag;\n      result.quotes.push({\n        id: eTagEventId,\n        relays: eTagRelayUrl ? [eTagRelayUrl] : []\n      });\n    }\n    if (tag[0] === \"p\" && tag[1]) {\n      result.profiles.push({\n        pubkey: tag[1],\n        relays: tag[2] ? [tag[2]] : []\n      });\n      continue;\n    }\n  }\n  if (!result.root) {\n    result.root = maybeRoot || maybeParent || result.reply;\n  }\n  if (!result.reply) {\n    result.reply = maybeParent || result.root;\n  }\n  ;\n  [result.reply, result.root].forEach((ref) => {\n    if (!ref)\n      return;\n    let idx = result.mentions.indexOf(ref);\n    if (idx !== -1) {\n      result.mentions.splice(idx, 1);\n    }\n    if (ref.author) {\n      let author = result.profiles.find((p) => p.pubkey === ref.author);\n      if (author && author.relays) {\n        if (!ref.relays) {\n          ref.relays = [];\n        }\n        author.relays.forEach((url) => {\n          if (ref.relays?.indexOf(url) === -1)\n            ref.relays.push(url);\n        });\n        author.relays = ref.relays;\n      }\n    }\n  });\n  result.mentions.forEach((ref) => {\n    if (ref.author) {\n      let author = result.profiles.find((p) => p.pubkey === ref.author);\n      if (author && author.relays) {\n        if (!ref.relays) {\n          ref.relays = [];\n        }\n        author.relays.forEach((url) => {\n          if (ref.relays.indexOf(url) === -1)\n            ref.relays.push(url);\n        });\n        author.relays = ref.relays;\n      }\n    }\n  });\n  return result;\n}\n\n// nip11.ts\nvar nip11_exports = {};\n__export(nip11_exports, {\n  fetchRelayInformation: () => fetchRelayInformation,\n  useFetchImplementation: () => useFetchImplementation2\n});\nvar _fetch2;\ntry {\n  _fetch2 = fetch;\n} catch {\n}\nfunction useFetchImplementation2(fetchImplementation) {\n  _fetch2 = fetchImplementation;\n}\nasync function fetchRelayInformation(url) {\n  return await (await fetch(url.replace(\"ws://\", \"http://\").replace(\"wss://\", \"https://\"), {\n    headers: { Accept: \"application/nostr+json\" }\n  })).json();\n}\n\n// nip13.ts\nvar nip13_exports = {};\n__export(nip13_exports, {\n  fastEventHash: () => fastEventHash,\n  getPow: () => getPow,\n  minePow: () => minePow\n});\n\n\nfunction getPow(hex) {\n  let count = 0;\n  for (let i2 = 0; i2 < 64; i2 += 8) {\n    const nibble = parseInt(hex.substring(i2, i2 + 8), 16);\n    if (nibble === 0) {\n      count += 32;\n    } else {\n      count += Math.clz32(nibble);\n      break;\n    }\n  }\n  return count;\n}\nfunction minePow(unsigned, difficulty) {\n  let count = 0;\n  const event = unsigned;\n  const tag = [\"nonce\", count.toString(), difficulty.toString()];\n  event.tags.push(tag);\n  while (true) {\n    const now2 = Math.floor(new Date().getTime() / 1e3);\n    if (now2 !== event.created_at) {\n      count = 0;\n      event.created_at = now2;\n    }\n    tag[1] = (++count).toString();\n    event.id = fastEventHash(event);\n    if (getPow(event.id) >= difficulty) {\n      break;\n    }\n  }\n  return event;\n}\nfunction fastEventHash(evt) {\n  return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(\n    (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_1__.sha256)(utf8Encoder.encode(JSON.stringify([0, evt.pubkey, evt.created_at, evt.kind, evt.tags, evt.content])))\n  );\n}\n\n// nip18.ts\nvar nip18_exports = {};\n__export(nip18_exports, {\n  finishRepostEvent: () => finishRepostEvent,\n  getRepostedEvent: () => getRepostedEvent,\n  getRepostedEventPointer: () => getRepostedEventPointer\n});\nfunction finishRepostEvent(t, reposted, relayUrl, privateKey) {\n  return finalizeEvent(\n    {\n      kind: Repost,\n      tags: [...t.tags ?? [], [\"e\", reposted.id, relayUrl], [\"p\", reposted.pubkey]],\n      content: t.content === \"\" ? \"\" : JSON.stringify(reposted),\n      created_at: t.created_at\n    },\n    privateKey\n  );\n}\nfunction getRepostedEventPointer(event) {\n  if (event.kind !== Repost) {\n    return void 0;\n  }\n  let lastETag;\n  let lastPTag;\n  for (let i2 = event.tags.length - 1; i2 >= 0 && (lastETag === void 0 || lastPTag === void 0); i2--) {\n    const tag = event.tags[i2];\n    if (tag.length >= 2) {\n      if (tag[0] === \"e\" && lastETag === void 0) {\n        lastETag = tag;\n      } else if (tag[0] === \"p\" && lastPTag === void 0) {\n        lastPTag = tag;\n      }\n    }\n  }\n  if (lastETag === void 0) {\n    return void 0;\n  }\n  return {\n    id: lastETag[1],\n    relays: [lastETag[2], lastPTag?.[2]].filter((x) => typeof x === \"string\"),\n    author: lastPTag?.[1]\n  };\n}\nfunction getRepostedEvent(event, { skipVerification } = {}) {\n  const pointer = getRepostedEventPointer(event);\n  if (pointer === void 0 || event.content === \"\") {\n    return void 0;\n  }\n  let repostedEvent;\n  try {\n    repostedEvent = JSON.parse(event.content);\n  } catch (error) {\n    return void 0;\n  }\n  if (repostedEvent.id !== pointer.id) {\n    return void 0;\n  }\n  if (!skipVerification && !verifyEvent(repostedEvent)) {\n    return void 0;\n  }\n  return repostedEvent;\n}\n\n// nip21.ts\nvar nip21_exports = {};\n__export(nip21_exports, {\n  NOSTR_URI_REGEX: () => NOSTR_URI_REGEX,\n  parse: () => parse2,\n  test: () => test\n});\nvar NOSTR_URI_REGEX = new RegExp(`nostr:(${BECH32_REGEX.source})`);\nfunction test(value) {\n  return typeof value === \"string\" && new RegExp(`^${NOSTR_URI_REGEX.source}$`).test(value);\n}\nfunction parse2(uri) {\n  const match = uri.match(new RegExp(`^${NOSTR_URI_REGEX.source}$`));\n  if (!match)\n    throw new Error(`Invalid Nostr URI: ${uri}`);\n  return {\n    uri: match[0],\n    value: match[1],\n    decoded: decode(match[1])\n  };\n}\n\n// nip25.ts\nvar nip25_exports = {};\n__export(nip25_exports, {\n  finishReactionEvent: () => finishReactionEvent,\n  getReactedEventPointer: () => getReactedEventPointer\n});\nfunction finishReactionEvent(t, reacted, privateKey) {\n  const inheritedTags = reacted.tags.filter((tag) => tag.length >= 2 && (tag[0] === \"e\" || tag[0] === \"p\"));\n  return finalizeEvent(\n    {\n      ...t,\n      kind: Reaction,\n      tags: [...t.tags ?? [], ...inheritedTags, [\"e\", reacted.id], [\"p\", reacted.pubkey]],\n      content: t.content ?? \"+\"\n    },\n    privateKey\n  );\n}\nfunction getReactedEventPointer(event) {\n  if (event.kind !== Reaction) {\n    return void 0;\n  }\n  let lastETag;\n  let lastPTag;\n  for (let i2 = event.tags.length - 1; i2 >= 0 && (lastETag === void 0 || lastPTag === void 0); i2--) {\n    const tag = event.tags[i2];\n    if (tag.length >= 2) {\n      if (tag[0] === \"e\" && lastETag === void 0) {\n        lastETag = tag;\n      } else if (tag[0] === \"p\" && lastPTag === void 0) {\n        lastPTag = tag;\n      }\n    }\n  }\n  if (lastETag === void 0 || lastPTag === void 0) {\n    return void 0;\n  }\n  return {\n    id: lastETag[1],\n    relays: [lastETag[2], lastPTag[2]].filter((x) => x !== void 0),\n    author: lastPTag[1]\n  };\n}\n\n// nip27.ts\nvar nip27_exports = {};\n__export(nip27_exports, {\n  matchAll: () => matchAll,\n  regex: () => regex,\n  replaceAll: () => replaceAll\n});\nvar regex = () => new RegExp(`\\\\b${NOSTR_URI_REGEX.source}\\\\b`, \"g\");\nfunction* matchAll(content) {\n  const matches = content.matchAll(regex());\n  for (const match of matches) {\n    try {\n      const [uri, value] = match;\n      yield {\n        uri,\n        value,\n        decoded: decode(value),\n        start: match.index,\n        end: match.index + uri.length\n      };\n    } catch (_e) {\n    }\n  }\n}\nfunction replaceAll(content, replacer) {\n  return content.replaceAll(regex(), (uri, value) => {\n    return replacer({\n      uri,\n      value,\n      decoded: decode(value)\n    });\n  });\n}\n\n// nip28.ts\nvar nip28_exports = {};\n__export(nip28_exports, {\n  channelCreateEvent: () => channelCreateEvent,\n  channelHideMessageEvent: () => channelHideMessageEvent,\n  channelMessageEvent: () => channelMessageEvent,\n  channelMetadataEvent: () => channelMetadataEvent,\n  channelMuteUserEvent: () => channelMuteUserEvent\n});\nvar channelCreateEvent = (t, privateKey) => {\n  let content;\n  if (typeof t.content === \"object\") {\n    content = JSON.stringify(t.content);\n  } else if (typeof t.content === \"string\") {\n    content = t.content;\n  } else {\n    return void 0;\n  }\n  return finalizeEvent(\n    {\n      kind: ChannelCreation,\n      tags: [...t.tags ?? []],\n      content,\n      created_at: t.created_at\n    },\n    privateKey\n  );\n};\nvar channelMetadataEvent = (t, privateKey) => {\n  let content;\n  if (typeof t.content === \"object\") {\n    content = JSON.stringify(t.content);\n  } else if (typeof t.content === \"string\") {\n    content = t.content;\n  } else {\n    return void 0;\n  }\n  return finalizeEvent(\n    {\n      kind: ChannelMetadata,\n      tags: [[\"e\", t.channel_create_event_id], ...t.tags ?? []],\n      content,\n      created_at: t.created_at\n    },\n    privateKey\n  );\n};\nvar channelMessageEvent = (t, privateKey) => {\n  const tags = [[\"e\", t.channel_create_event_id, t.relay_url, \"root\"]];\n  if (t.reply_to_channel_message_event_id) {\n    tags.push([\"e\", t.reply_to_channel_message_event_id, t.relay_url, \"reply\"]);\n  }\n  return finalizeEvent(\n    {\n      kind: ChannelMessage,\n      tags: [...tags, ...t.tags ?? []],\n      content: t.content,\n      created_at: t.created_at\n    },\n    privateKey\n  );\n};\nvar channelHideMessageEvent = (t, privateKey) => {\n  let content;\n  if (typeof t.content === \"object\") {\n    content = JSON.stringify(t.content);\n  } else if (typeof t.content === \"string\") {\n    content = t.content;\n  } else {\n    return void 0;\n  }\n  return finalizeEvent(\n    {\n      kind: ChannelHideMessage,\n      tags: [[\"e\", t.channel_message_event_id], ...t.tags ?? []],\n      content,\n      created_at: t.created_at\n    },\n    privateKey\n  );\n};\nvar channelMuteUserEvent = (t, privateKey) => {\n  let content;\n  if (typeof t.content === \"object\") {\n    content = JSON.stringify(t.content);\n  } else if (typeof t.content === \"string\") {\n    content = t.content;\n  } else {\n    return void 0;\n  }\n  return finalizeEvent(\n    {\n      kind: ChannelMuteUser,\n      tags: [[\"p\", t.pubkey_to_mute], ...t.tags ?? []],\n      content,\n      created_at: t.created_at\n    },\n    privateKey\n  );\n};\n\n// nip30.ts\nvar nip30_exports = {};\n__export(nip30_exports, {\n  EMOJI_SHORTCODE_REGEX: () => EMOJI_SHORTCODE_REGEX,\n  matchAll: () => matchAll2,\n  regex: () => regex2,\n  replaceAll: () => replaceAll2\n});\nvar EMOJI_SHORTCODE_REGEX = /:(\\w+):/;\nvar regex2 = () => new RegExp(`\\\\B${EMOJI_SHORTCODE_REGEX.source}\\\\B`, \"g\");\nfunction* matchAll2(content) {\n  const matches = content.matchAll(regex2());\n  for (const match of matches) {\n    try {\n      const [shortcode, name] = match;\n      yield {\n        shortcode,\n        name,\n        start: match.index,\n        end: match.index + shortcode.length\n      };\n    } catch (_e) {\n    }\n  }\n}\nfunction replaceAll2(content, replacer) {\n  return content.replaceAll(regex2(), (shortcode, name) => {\n    return replacer({\n      shortcode,\n      name\n    });\n  });\n}\n\n// nip39.ts\nvar nip39_exports = {};\n__export(nip39_exports, {\n  useFetchImplementation: () => useFetchImplementation3,\n  validateGithub: () => validateGithub\n});\nvar _fetch3;\ntry {\n  _fetch3 = fetch;\n} catch {\n}\nfunction useFetchImplementation3(fetchImplementation) {\n  _fetch3 = fetchImplementation;\n}\nasync function validateGithub(pubkey, username, proof) {\n  try {\n    let res = await (await _fetch3(`https://gist.github.com/${username}/${proof}/raw`)).text();\n    return res === `Verifying that I control the following Nostr public key: ${pubkey}`;\n  } catch (_) {\n    return false;\n  }\n}\n\n// nip44.ts\nvar nip44_exports = {};\n__export(nip44_exports, {\n  decrypt: () => decrypt2,\n  encrypt: () => encrypt2,\n  getConversationKey: () => getConversationKey,\n  v2: () => v2\n});\n\n\n\n\n\n\n\n\nvar minPlaintextSize = 1;\nvar maxPlaintextSize = 65535;\nfunction getConversationKey(privkeyA, pubkeyB) {\n  const sharedX = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.getSharedSecret(privkeyA, \"02\" + pubkeyB).subarray(1, 33);\n  return (0,_noble_hashes_hkdf__WEBPACK_IMPORTED_MODULE_5__.extract)(_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_1__.sha256, sharedX, \"nip44-v2\");\n}\nfunction getMessageKeys(conversationKey, nonce) {\n  const keys = (0,_noble_hashes_hkdf__WEBPACK_IMPORTED_MODULE_5__.expand)(_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_1__.sha256, conversationKey, nonce, 76);\n  return {\n    chacha_key: keys.subarray(0, 32),\n    chacha_nonce: keys.subarray(32, 44),\n    hmac_key: keys.subarray(44, 76)\n  };\n}\nfunction calcPaddedLen(len) {\n  if (!Number.isSafeInteger(len) || len < 1)\n    throw new Error(\"expected positive integer\");\n  if (len <= 32)\n    return 32;\n  const nextPower = 1 << Math.floor(Math.log2(len - 1)) + 1;\n  const chunk = nextPower <= 256 ? 32 : nextPower / 8;\n  return chunk * (Math.floor((len - 1) / chunk) + 1);\n}\nfunction writeU16BE(num) {\n  if (!Number.isSafeInteger(num) || num < minPlaintextSize || num > maxPlaintextSize)\n    throw new Error(\"invalid plaintext size: must be between 1 and 65535 bytes\");\n  const arr = new Uint8Array(2);\n  new DataView(arr.buffer).setUint16(0, num, false);\n  return arr;\n}\nfunction pad(plaintext) {\n  const unpadded = utf8Encoder.encode(plaintext);\n  const unpaddedLen = unpadded.length;\n  const prefix = writeU16BE(unpaddedLen);\n  const suffix = new Uint8Array(calcPaddedLen(unpaddedLen) - unpaddedLen);\n  return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(prefix, unpadded, suffix);\n}\nfunction unpad(padded) {\n  const unpaddedLen = new DataView(padded.buffer).getUint16(0);\n  const unpadded = padded.subarray(2, 2 + unpaddedLen);\n  if (unpaddedLen < minPlaintextSize || unpaddedLen > maxPlaintextSize || unpadded.length !== unpaddedLen || padded.length !== 2 + calcPaddedLen(unpaddedLen))\n    throw new Error(\"invalid padding\");\n  return utf8Decoder.decode(unpadded);\n}\nfunction hmacAad(key, message, aad) {\n  if (aad.length !== 32)\n    throw new Error(\"AAD associated data must be 32 bytes\");\n  const combined = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(aad, message);\n  return (0,_noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_6__.hmac)(_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_1__.sha256, key, combined);\n}\nfunction decodePayload(payload) {\n  if (typeof payload !== \"string\")\n    throw new Error(\"payload must be a valid string\");\n  const plen = payload.length;\n  if (plen < 132 || plen > 87472)\n    throw new Error(\"invalid payload length: \" + plen);\n  if (payload[0] === \"#\")\n    throw new Error(\"unknown encryption version\");\n  let data;\n  try {\n    data = _scure_base__WEBPACK_IMPORTED_MODULE_3__.base64.decode(payload);\n  } catch (error) {\n    throw new Error(\"invalid base64: \" + error.message);\n  }\n  const dlen = data.length;\n  if (dlen < 99 || dlen > 65603)\n    throw new Error(\"invalid data length: \" + dlen);\n  const vers = data[0];\n  if (vers !== 2)\n    throw new Error(\"unknown encryption version \" + vers);\n  return {\n    nonce: data.subarray(1, 33),\n    ciphertext: data.subarray(33, -32),\n    mac: data.subarray(-32)\n  };\n}\nfunction encrypt2(plaintext, conversationKey, nonce = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.randomBytes)(32)) {\n  const { chacha_key, chacha_nonce, hmac_key } = getMessageKeys(conversationKey, nonce);\n  const padded = pad(plaintext);\n  const ciphertext = (0,_noble_ciphers_chacha__WEBPACK_IMPORTED_MODULE_7__.chacha20)(chacha_key, chacha_nonce, padded);\n  const mac = hmacAad(hmac_key, ciphertext, nonce);\n  return _scure_base__WEBPACK_IMPORTED_MODULE_3__.base64.encode((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(new Uint8Array([2]), nonce, ciphertext, mac));\n}\nfunction decrypt2(payload, conversationKey) {\n  const { nonce, ciphertext, mac } = decodePayload(payload);\n  const { chacha_key, chacha_nonce, hmac_key } = getMessageKeys(conversationKey, nonce);\n  const calculatedMac = hmacAad(hmac_key, ciphertext, nonce);\n  if (!(0,_noble_ciphers_utils__WEBPACK_IMPORTED_MODULE_8__.equalBytes)(calculatedMac, mac))\n    throw new Error(\"invalid MAC\");\n  const padded = (0,_noble_ciphers_chacha__WEBPACK_IMPORTED_MODULE_7__.chacha20)(chacha_key, chacha_nonce, ciphertext);\n  return unpad(padded);\n}\nvar v2 = {\n  utils: {\n    getConversationKey,\n    calcPaddedLen\n  },\n  encrypt: encrypt2,\n  decrypt: decrypt2\n};\n\n// nip47.ts\nvar nip47_exports = {};\n__export(nip47_exports, {\n  makeNwcRequestEvent: () => makeNwcRequestEvent,\n  parseConnectionString: () => parseConnectionString\n});\nfunction parseConnectionString(connectionString) {\n  const { pathname, searchParams } = new URL(connectionString);\n  const pubkey = pathname;\n  const relay = searchParams.get(\"relay\");\n  const secret = searchParams.get(\"secret\");\n  if (!pubkey || !relay || !secret) {\n    throw new Error(\"invalid connection string\");\n  }\n  return { pubkey, relay, secret };\n}\nasync function makeNwcRequestEvent(pubkey, secretKey, invoice) {\n  const content = {\n    method: \"pay_invoice\",\n    params: {\n      invoice\n    }\n  };\n  const encryptedContent = await encrypt(secretKey, pubkey, JSON.stringify(content));\n  const eventTemplate = {\n    kind: NWCWalletRequest,\n    created_at: Math.round(Date.now() / 1e3),\n    content: encryptedContent,\n    tags: [[\"p\", pubkey]]\n  };\n  return finalizeEvent(eventTemplate, secretKey);\n}\n\n// nip57.ts\nvar nip57_exports = {};\n__export(nip57_exports, {\n  getZapEndpoint: () => getZapEndpoint,\n  makeZapReceipt: () => makeZapReceipt,\n  makeZapRequest: () => makeZapRequest,\n  useFetchImplementation: () => useFetchImplementation4,\n  validateZapRequest: () => validateZapRequest\n});\n\nvar _fetch4;\ntry {\n  _fetch4 = fetch;\n} catch {\n}\nfunction useFetchImplementation4(fetchImplementation) {\n  _fetch4 = fetchImplementation;\n}\nasync function getZapEndpoint(metadata) {\n  try {\n    let lnurl = \"\";\n    let { lud06, lud16 } = JSON.parse(metadata.content);\n    if (lud06) {\n      let { words } = _scure_base__WEBPACK_IMPORTED_MODULE_3__.bech32.decode(lud06, 1e3);\n      let data = _scure_base__WEBPACK_IMPORTED_MODULE_3__.bech32.fromWords(words);\n      lnurl = utf8Decoder.decode(data);\n    } else if (lud16) {\n      let [name, domain] = lud16.split(\"@\");\n      lnurl = new URL(`/.well-known/lnurlp/${name}`, `https://${domain}`).toString();\n    } else {\n      return null;\n    }\n    let res = await _fetch4(lnurl);\n    let body = await res.json();\n    if (body.allowsNostr && body.nostrPubkey) {\n      return body.callback;\n    }\n  } catch (err) {\n  }\n  return null;\n}\nfunction makeZapRequest({\n  profile,\n  event,\n  amount,\n  relays,\n  comment = \"\"\n}) {\n  if (!amount)\n    throw new Error(\"amount not given\");\n  if (!profile)\n    throw new Error(\"profile not given\");\n  let zr = {\n    kind: 9734,\n    created_at: Math.round(Date.now() / 1e3),\n    content: comment,\n    tags: [\n      [\"p\", profile],\n      [\"amount\", amount.toString()],\n      [\"relays\", ...relays]\n    ]\n  };\n  if (event) {\n    zr.tags.push([\"e\", event]);\n  }\n  return zr;\n}\nfunction validateZapRequest(zapRequestString) {\n  let zapRequest;\n  try {\n    zapRequest = JSON.parse(zapRequestString);\n  } catch (err) {\n    return \"Invalid zap request JSON.\";\n  }\n  if (!validateEvent(zapRequest))\n    return \"Zap request is not a valid Nostr event.\";\n  if (!verifyEvent(zapRequest))\n    return \"Invalid signature on zap request.\";\n  let p = zapRequest.tags.find(([t, v]) => t === \"p\" && v);\n  if (!p)\n    return \"Zap request doesn't have a 'p' tag.\";\n  if (!p[1].match(/^[a-f0-9]{64}$/))\n    return \"Zap request 'p' tag is not valid hex.\";\n  let e = zapRequest.tags.find(([t, v]) => t === \"e\" && v);\n  if (e && !e[1].match(/^[a-f0-9]{64}$/))\n    return \"Zap request 'e' tag is not valid hex.\";\n  let relays = zapRequest.tags.find(([t, v]) => t === \"relays\" && v);\n  if (!relays)\n    return \"Zap request doesn't have a 'relays' tag.\";\n  return null;\n}\nfunction makeZapReceipt({\n  zapRequest,\n  preimage,\n  bolt11,\n  paidAt\n}) {\n  let zr = JSON.parse(zapRequest);\n  let tagsFromZapRequest = zr.tags.filter(([t]) => t === \"e\" || t === \"p\" || t === \"a\");\n  let zap = {\n    kind: 9735,\n    created_at: Math.round(paidAt.getTime() / 1e3),\n    content: \"\",\n    tags: [...tagsFromZapRequest, [\"P\", zr.pubkey], [\"bolt11\", bolt11], [\"description\", zapRequest]]\n  };\n  if (preimage) {\n    zap.tags.push([\"preimage\", preimage]);\n  }\n  return zap;\n}\n\n// nip59.ts\nvar nip59_exports = {};\n__export(nip59_exports, {\n  createRumor: () => createRumor,\n  createSeal: () => createSeal,\n  createWrap: () => createWrap,\n  unwrapEvent: () => unwrapEvent,\n  unwrapManyEvents: () => unwrapManyEvents,\n  wrapEvent: () => wrapEvent,\n  wrapManyEvents: () => wrapManyEvents\n});\nvar TWO_DAYS = 2 * 24 * 60 * 60;\nvar now = () => Math.round(Date.now() / 1e3);\nvar randomNow = () => Math.round(now() - Math.random() * TWO_DAYS);\nvar nip44ConversationKey = (privateKey, publicKey) => getConversationKey(privateKey, publicKey);\nvar nip44Encrypt = (data, privateKey, publicKey) => encrypt2(JSON.stringify(data), nip44ConversationKey(privateKey, publicKey));\nvar nip44Decrypt = (data, privateKey) => JSON.parse(decrypt2(data.content, nip44ConversationKey(privateKey, data.pubkey)));\nfunction createRumor(event, privateKey) {\n  const rumor = {\n    created_at: now(),\n    content: \"\",\n    tags: [],\n    ...event,\n    pubkey: getPublicKey(privateKey)\n  };\n  rumor.id = getEventHash(rumor);\n  return rumor;\n}\nfunction createSeal(rumor, privateKey, recipientPublicKey) {\n  return finalizeEvent(\n    {\n      kind: Seal,\n      content: nip44Encrypt(rumor, privateKey, recipientPublicKey),\n      created_at: randomNow(),\n      tags: []\n    },\n    privateKey\n  );\n}\nfunction createWrap(seal, recipientPublicKey) {\n  const randomKey = generateSecretKey();\n  return finalizeEvent(\n    {\n      kind: GiftWrap,\n      content: nip44Encrypt(seal, randomKey, recipientPublicKey),\n      created_at: randomNow(),\n      tags: [[\"p\", recipientPublicKey]]\n    },\n    randomKey\n  );\n}\nfunction wrapEvent(event, senderPrivateKey, recipientPublicKey) {\n  const rumor = createRumor(event, senderPrivateKey);\n  const seal = createSeal(rumor, senderPrivateKey, recipientPublicKey);\n  return createWrap(seal, recipientPublicKey);\n}\nfunction wrapManyEvents(event, senderPrivateKey, recipientsPublicKeys) {\n  if (!recipientsPublicKeys || recipientsPublicKeys.length === 0) {\n    throw new Error(\"At least one recipient is required.\");\n  }\n  const senderPublicKey = getPublicKey(senderPrivateKey);\n  const wrappeds = [wrapEvent(event, senderPrivateKey, senderPublicKey)];\n  recipientsPublicKeys.forEach((recipientPublicKey) => {\n    wrappeds.push(wrapEvent(event, senderPrivateKey, recipientPublicKey));\n  });\n  return wrappeds;\n}\nfunction unwrapEvent(wrap, recipientPrivateKey) {\n  const unwrappedSeal = nip44Decrypt(wrap, recipientPrivateKey);\n  return nip44Decrypt(unwrappedSeal, recipientPrivateKey);\n}\nfunction unwrapManyEvents(wrappedEvents, recipientPrivateKey) {\n  let unwrappedEvents = [];\n  wrappedEvents.forEach((e) => {\n    unwrappedEvents.push(unwrapEvent(e, recipientPrivateKey));\n  });\n  unwrappedEvents.sort((a, b) => a.created_at - b.created_at);\n  return unwrappedEvents;\n}\n\n// nip98.ts\nvar nip98_exports = {};\n__export(nip98_exports, {\n  getToken: () => getToken,\n  hashPayload: () => hashPayload,\n  unpackEventFromToken: () => unpackEventFromToken,\n  validateEvent: () => validateEvent2,\n  validateEventKind: () => validateEventKind,\n  validateEventMethodTag: () => validateEventMethodTag,\n  validateEventPayloadTag: () => validateEventPayloadTag,\n  validateEventTimestamp: () => validateEventTimestamp,\n  validateEventUrlTag: () => validateEventUrlTag,\n  validateToken: () => validateToken\n});\n\n\n\nvar _authorizationScheme = \"Nostr \";\nasync function getToken(loginUrl, httpMethod, sign, includeAuthorizationScheme = false, payload) {\n  const event = {\n    kind: HTTPAuth,\n    tags: [\n      [\"u\", loginUrl],\n      [\"method\", httpMethod]\n    ],\n    created_at: Math.round(new Date().getTime() / 1e3),\n    content: \"\"\n  };\n  if (payload) {\n    event.tags.push([\"payload\", hashPayload(payload)]);\n  }\n  const signedEvent = await sign(event);\n  const authorizationScheme = includeAuthorizationScheme ? _authorizationScheme : \"\";\n  return authorizationScheme + _scure_base__WEBPACK_IMPORTED_MODULE_3__.base64.encode(utf8Encoder.encode(JSON.stringify(signedEvent)));\n}\nasync function validateToken(token, url, method) {\n  const event = await unpackEventFromToken(token).catch((error) => {\n    throw error;\n  });\n  const valid = await validateEvent2(event, url, method).catch((error) => {\n    throw error;\n  });\n  return valid;\n}\nasync function unpackEventFromToken(token) {\n  if (!token) {\n    throw new Error(\"Missing token\");\n  }\n  token = token.replace(_authorizationScheme, \"\");\n  const eventB64 = utf8Decoder.decode(_scure_base__WEBPACK_IMPORTED_MODULE_3__.base64.decode(token));\n  if (!eventB64 || eventB64.length === 0 || !eventB64.startsWith(\"{\")) {\n    throw new Error(\"Invalid token\");\n  }\n  const event = JSON.parse(eventB64);\n  return event;\n}\nfunction validateEventTimestamp(event) {\n  if (!event.created_at) {\n    return false;\n  }\n  return Math.round(new Date().getTime() / 1e3) - event.created_at < 60;\n}\nfunction validateEventKind(event) {\n  return event.kind === HTTPAuth;\n}\nfunction validateEventUrlTag(event, url) {\n  const urlTag = event.tags.find((t) => t[0] === \"u\");\n  if (!urlTag) {\n    return false;\n  }\n  return urlTag.length > 0 && urlTag[1] === url;\n}\nfunction validateEventMethodTag(event, method) {\n  const methodTag = event.tags.find((t) => t[0] === \"method\");\n  if (!methodTag) {\n    return false;\n  }\n  return methodTag.length > 0 && methodTag[1].toLowerCase() === method.toLowerCase();\n}\nfunction hashPayload(payload) {\n  const hash = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_1__.sha256)(utf8Encoder.encode(JSON.stringify(payload)));\n  return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(hash);\n}\nfunction validateEventPayloadTag(event, payload) {\n  const payloadTag = event.tags.find((t) => t[0] === \"payload\");\n  if (!payloadTag) {\n    return false;\n  }\n  const payloadHash = hashPayload(payload);\n  return payloadTag.length > 0 && payloadTag[1] === payloadHash;\n}\nasync function validateEvent2(event, url, method, body) {\n  if (!verifyEvent(event)) {\n    throw new Error(\"Invalid nostr event, signature invalid\");\n  }\n  if (!validateEventKind(event)) {\n    throw new Error(\"Invalid nostr event, kind invalid\");\n  }\n  if (!validateEventTimestamp(event)) {\n    throw new Error(\"Invalid nostr event, created_at timestamp invalid\");\n  }\n  if (!validateEventUrlTag(event, url)) {\n    throw new Error(\"Invalid nostr event, url tag invalid\");\n  }\n  if (!validateEventMethodTag(event, method)) {\n    throw new Error(\"Invalid nostr event, method tag invalid\");\n  }\n  if (Boolean(body) && typeof body === \"object\" && Object.keys(body).length > 0) {\n    if (!validateEventPayloadTag(event, body)) {\n      throw new Error(\"Invalid nostr event, payload tag does not match request body hash\");\n    }\n  }\n  return true;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9zdHItZGV2LWtpdC9uZGsvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL2xpYi9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFOztBQUVBO0FBQ2tEO0FBQ0Q7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsR0FBRztBQUN4QztBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQzhDOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDREQUFPO0FBQ2xCO0FBQ0E7QUFDQSxXQUFXLCtEQUFVLENBQUMsNERBQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLCtEQUFVLENBQUMsNERBQU87QUFDckM7QUFDQSxnQkFBZ0IsK0RBQVUsQ0FBQyw0REFBTztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNERBQU87QUFDM0I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDREQUFNO0FBQ3hCLFNBQVMsK0RBQVU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFFBQVE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixxQkFBcUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixxQkFBcUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsNkJBQTZCLE1BQU07QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixNQUFNO0FBQ25DO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsU0FBUyxJQUFJLElBQUk7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGlCQUFpQjtBQUM3RCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxpQkFBaUI7QUFDL0QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxpQkFBaUI7QUFDeEQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxRQUFRLGFBQWEsZUFBZTtBQUNoRztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0RBQWtEO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUN3RDtBQUNPO0FBQ2hCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLCtDQUFPO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsK0NBQU87QUFDN0MsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDREQUFPO0FBQ3RCLFNBQVMsK0RBQVc7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXdDRSIsInNvdXJjZXMiOlsiL2hvbWUvbGZnL0dpdC9NYWR0cmlwcy9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9saWIvZXNtL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG5cbi8vIHB1cmUudHNcbmltcG9ydCB7IHNjaG5vcnIgfSBmcm9tIFwiQG5vYmxlL2N1cnZlcy9zZWNwMjU2azFcIjtcbmltcG9ydCB7IGJ5dGVzVG9IZXggfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy91dGlsc1wiO1xuXG4vLyBjb3JlLnRzXG52YXIgdmVyaWZpZWRTeW1ib2wgPSBTeW1ib2woXCJ2ZXJpZmllZFwiKTtcbnZhciBpc1JlY29yZCA9IChvYmopID0+IG9iaiBpbnN0YW5jZW9mIE9iamVjdDtcbmZ1bmN0aW9uIHZhbGlkYXRlRXZlbnQoZXZlbnQpIHtcbiAgaWYgKCFpc1JlY29yZChldmVudCkpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIGV2ZW50LmtpbmQgIT09IFwibnVtYmVyXCIpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIGV2ZW50LmNvbnRlbnQgIT09IFwic3RyaW5nXCIpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIGV2ZW50LmNyZWF0ZWRfYXQgIT09IFwibnVtYmVyXCIpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIGV2ZW50LnB1YmtleSAhPT0gXCJzdHJpbmdcIilcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmICghZXZlbnQucHVia2V5Lm1hdGNoKC9eW2EtZjAtOV17NjR9JC8pKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGV2ZW50LnRhZ3MpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IGV2ZW50LnRhZ3MubGVuZ3RoOyBpMisrKSB7XG4gICAgbGV0IHRhZyA9IGV2ZW50LnRhZ3NbaTJdO1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh0YWcpKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGFnLmxlbmd0aDsgaisrKSB7XG4gICAgICBpZiAodHlwZW9mIHRhZ1tqXSA9PT0gXCJvYmplY3RcIilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHNvcnRFdmVudHMoZXZlbnRzKSB7XG4gIHJldHVybiBldmVudHMuc29ydCgoYSwgYikgPT4ge1xuICAgIGlmIChhLmNyZWF0ZWRfYXQgIT09IGIuY3JlYXRlZF9hdCkge1xuICAgICAgcmV0dXJuIGIuY3JlYXRlZF9hdCAtIGEuY3JlYXRlZF9hdDtcbiAgICB9XG4gICAgcmV0dXJuIGEuaWQubG9jYWxlQ29tcGFyZShiLmlkKTtcbiAgfSk7XG59XG5cbi8vIHB1cmUudHNcbmltcG9ydCB7IHNoYTI1NiB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3NoYTI1NlwiO1xuXG4vLyB1dGlscy50c1xudmFyIHV0aWxzX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHV0aWxzX2V4cG9ydHMsIHtcbiAgUXVldWU6ICgpID0+IFF1ZXVlLFxuICBRdWV1ZU5vZGU6ICgpID0+IFF1ZXVlTm9kZSxcbiAgYmluYXJ5U2VhcmNoOiAoKSA9PiBiaW5hcnlTZWFyY2gsXG4gIGluc2VydEV2ZW50SW50b0FzY2VuZGluZ0xpc3Q6ICgpID0+IGluc2VydEV2ZW50SW50b0FzY2VuZGluZ0xpc3QsXG4gIGluc2VydEV2ZW50SW50b0Rlc2NlbmRpbmdMaXN0OiAoKSA9PiBpbnNlcnRFdmVudEludG9EZXNjZW5kaW5nTGlzdCxcbiAgbm9ybWFsaXplVVJMOiAoKSA9PiBub3JtYWxpemVVUkwsXG4gIHV0ZjhEZWNvZGVyOiAoKSA9PiB1dGY4RGVjb2RlcixcbiAgdXRmOEVuY29kZXI6ICgpID0+IHV0ZjhFbmNvZGVyXG59KTtcbnZhciB1dGY4RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcihcInV0Zi04XCIpO1xudmFyIHV0ZjhFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG5mdW5jdGlvbiBub3JtYWxpemVVUkwodXJsKSB7XG4gIGlmICh1cmwuaW5kZXhPZihcIjovL1wiKSA9PT0gLTEpXG4gICAgdXJsID0gXCJ3c3M6Ly9cIiArIHVybDtcbiAgbGV0IHAgPSBuZXcgVVJMKHVybCk7XG4gIHAucGF0aG5hbWUgPSBwLnBhdGhuYW1lLnJlcGxhY2UoL1xcLysvZywgXCIvXCIpO1xuICBpZiAocC5wYXRobmFtZS5lbmRzV2l0aChcIi9cIikpXG4gICAgcC5wYXRobmFtZSA9IHAucGF0aG5hbWUuc2xpY2UoMCwgLTEpO1xuICBpZiAocC5wb3J0ID09PSBcIjgwXCIgJiYgcC5wcm90b2NvbCA9PT0gXCJ3czpcIiB8fCBwLnBvcnQgPT09IFwiNDQzXCIgJiYgcC5wcm90b2NvbCA9PT0gXCJ3c3M6XCIpXG4gICAgcC5wb3J0ID0gXCJcIjtcbiAgcC5zZWFyY2hQYXJhbXMuc29ydCgpO1xuICBwLmhhc2ggPSBcIlwiO1xuICByZXR1cm4gcC50b1N0cmluZygpO1xufVxuZnVuY3Rpb24gaW5zZXJ0RXZlbnRJbnRvRGVzY2VuZGluZ0xpc3Qoc29ydGVkQXJyYXksIGV2ZW50KSB7XG4gIGNvbnN0IFtpZHgsIGZvdW5kXSA9IGJpbmFyeVNlYXJjaChzb3J0ZWRBcnJheSwgKGIpID0+IHtcbiAgICBpZiAoZXZlbnQuaWQgPT09IGIuaWQpXG4gICAgICByZXR1cm4gMDtcbiAgICBpZiAoZXZlbnQuY3JlYXRlZF9hdCA9PT0gYi5jcmVhdGVkX2F0KVxuICAgICAgcmV0dXJuIC0xO1xuICAgIHJldHVybiBiLmNyZWF0ZWRfYXQgLSBldmVudC5jcmVhdGVkX2F0O1xuICB9KTtcbiAgaWYgKCFmb3VuZCkge1xuICAgIHNvcnRlZEFycmF5LnNwbGljZShpZHgsIDAsIGV2ZW50KTtcbiAgfVxuICByZXR1cm4gc29ydGVkQXJyYXk7XG59XG5mdW5jdGlvbiBpbnNlcnRFdmVudEludG9Bc2NlbmRpbmdMaXN0KHNvcnRlZEFycmF5LCBldmVudCkge1xuICBjb25zdCBbaWR4LCBmb3VuZF0gPSBiaW5hcnlTZWFyY2goc29ydGVkQXJyYXksIChiKSA9PiB7XG4gICAgaWYgKGV2ZW50LmlkID09PSBiLmlkKVxuICAgICAgcmV0dXJuIDA7XG4gICAgaWYgKGV2ZW50LmNyZWF0ZWRfYXQgPT09IGIuY3JlYXRlZF9hdClcbiAgICAgIHJldHVybiAtMTtcbiAgICByZXR1cm4gZXZlbnQuY3JlYXRlZF9hdCAtIGIuY3JlYXRlZF9hdDtcbiAgfSk7XG4gIGlmICghZm91bmQpIHtcbiAgICBzb3J0ZWRBcnJheS5zcGxpY2UoaWR4LCAwLCBldmVudCk7XG4gIH1cbiAgcmV0dXJuIHNvcnRlZEFycmF5O1xufVxuZnVuY3Rpb24gYmluYXJ5U2VhcmNoKGFyciwgY29tcGFyZSkge1xuICBsZXQgc3RhcnQgPSAwO1xuICBsZXQgZW5kID0gYXJyLmxlbmd0aCAtIDE7XG4gIHdoaWxlIChzdGFydCA8PSBlbmQpIHtcbiAgICBjb25zdCBtaWQgPSBNYXRoLmZsb29yKChzdGFydCArIGVuZCkgLyAyKTtcbiAgICBjb25zdCBjbXAgPSBjb21wYXJlKGFyclttaWRdKTtcbiAgICBpZiAoY21wID09PSAwKSB7XG4gICAgICByZXR1cm4gW21pZCwgdHJ1ZV07XG4gICAgfVxuICAgIGlmIChjbXAgPCAwKSB7XG4gICAgICBlbmQgPSBtaWQgLSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydCA9IG1pZCArIDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBbc3RhcnQsIGZhbHNlXTtcbn1cbnZhciBRdWV1ZU5vZGUgPSBjbGFzcyB7XG4gIHZhbHVlO1xuICBuZXh0ID0gbnVsbDtcbiAgcHJldiA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICB0aGlzLnZhbHVlID0gbWVzc2FnZTtcbiAgfVxufTtcbnZhciBRdWV1ZSA9IGNsYXNzIHtcbiAgZmlyc3Q7XG4gIGxhc3Q7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZmlyc3QgPSBudWxsO1xuICAgIHRoaXMubGFzdCA9IG51bGw7XG4gIH1cbiAgZW5xdWV1ZSh2YWx1ZSkge1xuICAgIGNvbnN0IG5ld05vZGUgPSBuZXcgUXVldWVOb2RlKHZhbHVlKTtcbiAgICBpZiAoIXRoaXMubGFzdCkge1xuICAgICAgdGhpcy5maXJzdCA9IG5ld05vZGU7XG4gICAgICB0aGlzLmxhc3QgPSBuZXdOb2RlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5sYXN0ID09PSB0aGlzLmZpcnN0KSB7XG4gICAgICB0aGlzLmxhc3QgPSBuZXdOb2RlO1xuICAgICAgdGhpcy5sYXN0LnByZXYgPSB0aGlzLmZpcnN0O1xuICAgICAgdGhpcy5maXJzdC5uZXh0ID0gbmV3Tm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3Tm9kZS5wcmV2ID0gdGhpcy5sYXN0O1xuICAgICAgdGhpcy5sYXN0Lm5leHQgPSBuZXdOb2RlO1xuICAgICAgdGhpcy5sYXN0ID0gbmV3Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZGVxdWV1ZSgpIHtcbiAgICBpZiAoIXRoaXMuZmlyc3QpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAodGhpcy5maXJzdCA9PT0gdGhpcy5sYXN0KSB7XG4gICAgICBjb25zdCB0YXJnZXQyID0gdGhpcy5maXJzdDtcbiAgICAgIHRoaXMuZmlyc3QgPSBudWxsO1xuICAgICAgdGhpcy5sYXN0ID0gbnVsbDtcbiAgICAgIHJldHVybiB0YXJnZXQyLnZhbHVlO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXQgPSB0aGlzLmZpcnN0O1xuICAgIHRoaXMuZmlyc3QgPSB0YXJnZXQubmV4dDtcbiAgICByZXR1cm4gdGFyZ2V0LnZhbHVlO1xuICB9XG59O1xuXG4vLyBwdXJlLnRzXG52YXIgSlMgPSBjbGFzcyB7XG4gIGdlbmVyYXRlU2VjcmV0S2V5KCkge1xuICAgIHJldHVybiBzY2hub3JyLnV0aWxzLnJhbmRvbVByaXZhdGVLZXkoKTtcbiAgfVxuICBnZXRQdWJsaWNLZXkoc2VjcmV0S2V5KSB7XG4gICAgcmV0dXJuIGJ5dGVzVG9IZXgoc2Nobm9yci5nZXRQdWJsaWNLZXkoc2VjcmV0S2V5KSk7XG4gIH1cbiAgZmluYWxpemVFdmVudCh0LCBzZWNyZXRLZXkpIHtcbiAgICBjb25zdCBldmVudCA9IHQ7XG4gICAgZXZlbnQucHVia2V5ID0gYnl0ZXNUb0hleChzY2hub3JyLmdldFB1YmxpY0tleShzZWNyZXRLZXkpKTtcbiAgICBldmVudC5pZCA9IGdldEV2ZW50SGFzaChldmVudCk7XG4gICAgZXZlbnQuc2lnID0gYnl0ZXNUb0hleChzY2hub3JyLnNpZ24oZ2V0RXZlbnRIYXNoKGV2ZW50KSwgc2VjcmV0S2V5KSk7XG4gICAgZXZlbnRbdmVyaWZpZWRTeW1ib2xdID0gdHJ1ZTtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH1cbiAgdmVyaWZ5RXZlbnQoZXZlbnQpIHtcbiAgICBpZiAodHlwZW9mIGV2ZW50W3ZlcmlmaWVkU3ltYm9sXSA9PT0gXCJib29sZWFuXCIpXG4gICAgICByZXR1cm4gZXZlbnRbdmVyaWZpZWRTeW1ib2xdO1xuICAgIGNvbnN0IGhhc2ggPSBnZXRFdmVudEhhc2goZXZlbnQpO1xuICAgIGlmIChoYXNoICE9PSBldmVudC5pZCkge1xuICAgICAgZXZlbnRbdmVyaWZpZWRTeW1ib2xdID0gZmFsc2U7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCB2YWxpZCA9IHNjaG5vcnIudmVyaWZ5KGV2ZW50LnNpZywgaGFzaCwgZXZlbnQucHVia2V5KTtcbiAgICAgIGV2ZW50W3ZlcmlmaWVkU3ltYm9sXSA9IHZhbGlkO1xuICAgICAgcmV0dXJuIHZhbGlkO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgZXZlbnRbdmVyaWZpZWRTeW1ib2xdID0gZmFsc2U7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59O1xuZnVuY3Rpb24gc2VyaWFsaXplRXZlbnQoZXZ0KSB7XG4gIGlmICghdmFsaWRhdGVFdmVudChldnQpKVxuICAgIHRocm93IG5ldyBFcnJvcihcImNhbid0IHNlcmlhbGl6ZSBldmVudCB3aXRoIHdyb25nIG9yIG1pc3NpbmcgcHJvcGVydGllc1wiKTtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KFswLCBldnQucHVia2V5LCBldnQuY3JlYXRlZF9hdCwgZXZ0LmtpbmQsIGV2dC50YWdzLCBldnQuY29udGVudF0pO1xufVxuZnVuY3Rpb24gZ2V0RXZlbnRIYXNoKGV2ZW50KSB7XG4gIGxldCBldmVudEhhc2ggPSBzaGEyNTYodXRmOEVuY29kZXIuZW5jb2RlKHNlcmlhbGl6ZUV2ZW50KGV2ZW50KSkpO1xuICByZXR1cm4gYnl0ZXNUb0hleChldmVudEhhc2gpO1xufVxudmFyIGkgPSBuZXcgSlMoKTtcbnZhciBnZW5lcmF0ZVNlY3JldEtleSA9IGkuZ2VuZXJhdGVTZWNyZXRLZXk7XG52YXIgZ2V0UHVibGljS2V5ID0gaS5nZXRQdWJsaWNLZXk7XG52YXIgZmluYWxpemVFdmVudCA9IGkuZmluYWxpemVFdmVudDtcbnZhciB2ZXJpZnlFdmVudCA9IGkudmVyaWZ5RXZlbnQ7XG5cbi8vIGtpbmRzLnRzXG52YXIga2luZHNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoa2luZHNfZXhwb3J0cywge1xuICBBcHBsaWNhdGlvbjogKCkgPT4gQXBwbGljYXRpb24sXG4gIEJhZGdlQXdhcmQ6ICgpID0+IEJhZGdlQXdhcmQsXG4gIEJhZGdlRGVmaW5pdGlvbjogKCkgPT4gQmFkZ2VEZWZpbml0aW9uLFxuICBCbG9ja2VkUmVsYXlzTGlzdDogKCkgPT4gQmxvY2tlZFJlbGF5c0xpc3QsXG4gIEJvb2ttYXJrTGlzdDogKCkgPT4gQm9va21hcmtMaXN0LFxuICBCb29rbWFya3NldHM6ICgpID0+IEJvb2ttYXJrc2V0cyxcbiAgQ2FsZW5kYXI6ICgpID0+IENhbGVuZGFyLFxuICBDYWxlbmRhckV2ZW50UlNWUDogKCkgPT4gQ2FsZW5kYXJFdmVudFJTVlAsXG4gIENoYW5uZWxDcmVhdGlvbjogKCkgPT4gQ2hhbm5lbENyZWF0aW9uLFxuICBDaGFubmVsSGlkZU1lc3NhZ2U6ICgpID0+IENoYW5uZWxIaWRlTWVzc2FnZSxcbiAgQ2hhbm5lbE1lc3NhZ2U6ICgpID0+IENoYW5uZWxNZXNzYWdlLFxuICBDaGFubmVsTWV0YWRhdGE6ICgpID0+IENoYW5uZWxNZXRhZGF0YSxcbiAgQ2hhbm5lbE11dGVVc2VyOiAoKSA9PiBDaGFubmVsTXV0ZVVzZXIsXG4gIENsYXNzaWZpZWRMaXN0aW5nOiAoKSA9PiBDbGFzc2lmaWVkTGlzdGluZyxcbiAgQ2xpZW50QXV0aDogKCkgPT4gQ2xpZW50QXV0aCxcbiAgQ29tbXVuaXRpZXNMaXN0OiAoKSA9PiBDb21tdW5pdGllc0xpc3QsXG4gIENvbW11bml0eURlZmluaXRpb246ICgpID0+IENvbW11bml0eURlZmluaXRpb24sXG4gIENvbW11bml0eVBvc3RBcHByb3ZhbDogKCkgPT4gQ29tbXVuaXR5UG9zdEFwcHJvdmFsLFxuICBDb250YWN0czogKCkgPT4gQ29udGFjdHMsXG4gIENyZWF0ZU9yVXBkYXRlUHJvZHVjdDogKCkgPT4gQ3JlYXRlT3JVcGRhdGVQcm9kdWN0LFxuICBDcmVhdGVPclVwZGF0ZVN0YWxsOiAoKSA9PiBDcmVhdGVPclVwZGF0ZVN0YWxsLFxuICBDdXJhdGlvbnNldHM6ICgpID0+IEN1cmF0aW9uc2V0cyxcbiAgRGF0ZTogKCkgPT4gRGF0ZTIsXG4gIERpcmVjdE1lc3NhZ2VSZWxheXNMaXN0OiAoKSA9PiBEaXJlY3RNZXNzYWdlUmVsYXlzTGlzdCxcbiAgRHJhZnRDbGFzc2lmaWVkTGlzdGluZzogKCkgPT4gRHJhZnRDbGFzc2lmaWVkTGlzdGluZyxcbiAgRHJhZnRMb25nOiAoKSA9PiBEcmFmdExvbmcsXG4gIEVtb2ppc2V0czogKCkgPT4gRW1vamlzZXRzLFxuICBFbmNyeXB0ZWREaXJlY3RNZXNzYWdlOiAoKSA9PiBFbmNyeXB0ZWREaXJlY3RNZXNzYWdlLFxuICBFdmVudERlbGV0aW9uOiAoKSA9PiBFdmVudERlbGV0aW9uLFxuICBGaWxlTWV0YWRhdGE6ICgpID0+IEZpbGVNZXRhZGF0YSxcbiAgRmlsZVNlcnZlclByZWZlcmVuY2U6ICgpID0+IEZpbGVTZXJ2ZXJQcmVmZXJlbmNlLFxuICBGb2xsb3dzZXRzOiAoKSA9PiBGb2xsb3dzZXRzLFxuICBHZW5lcmljUmVwb3N0OiAoKSA9PiBHZW5lcmljUmVwb3N0LFxuICBHZW5lcmljbGlzdHM6ICgpID0+IEdlbmVyaWNsaXN0cyxcbiAgR2lmdFdyYXA6ICgpID0+IEdpZnRXcmFwLFxuICBIVFRQQXV0aDogKCkgPT4gSFRUUEF1dGgsXG4gIEhhbmRsZXJpbmZvcm1hdGlvbjogKCkgPT4gSGFuZGxlcmluZm9ybWF0aW9uLFxuICBIYW5kbGVycmVjb21tZW5kYXRpb246ICgpID0+IEhhbmRsZXJyZWNvbW1lbmRhdGlvbixcbiAgSGlnaGxpZ2h0czogKCkgPT4gSGlnaGxpZ2h0cyxcbiAgSW50ZXJlc3RzTGlzdDogKCkgPT4gSW50ZXJlc3RzTGlzdCxcbiAgSW50ZXJlc3RzZXRzOiAoKSA9PiBJbnRlcmVzdHNldHMsXG4gIEpvYkZlZWRiYWNrOiAoKSA9PiBKb2JGZWVkYmFjayxcbiAgSm9iUmVxdWVzdDogKCkgPT4gSm9iUmVxdWVzdCxcbiAgSm9iUmVzdWx0OiAoKSA9PiBKb2JSZXN1bHQsXG4gIExhYmVsOiAoKSA9PiBMYWJlbCxcbiAgTGlnaHRuaW5nUHViUlBDOiAoKSA9PiBMaWdodG5pbmdQdWJSUEMsXG4gIExpdmVDaGF0TWVzc2FnZTogKCkgPT4gTGl2ZUNoYXRNZXNzYWdlLFxuICBMaXZlRXZlbnQ6ICgpID0+IExpdmVFdmVudCxcbiAgTG9uZ0Zvcm1BcnRpY2xlOiAoKSA9PiBMb25nRm9ybUFydGljbGUsXG4gIE1ldGFkYXRhOiAoKSA9PiBNZXRhZGF0YSxcbiAgTXV0ZWxpc3Q6ICgpID0+IE11dGVsaXN0LFxuICBOV0NXYWxsZXRJbmZvOiAoKSA9PiBOV0NXYWxsZXRJbmZvLFxuICBOV0NXYWxsZXRSZXF1ZXN0OiAoKSA9PiBOV0NXYWxsZXRSZXF1ZXN0LFxuICBOV0NXYWxsZXRSZXNwb25zZTogKCkgPT4gTldDV2FsbGV0UmVzcG9uc2UsXG4gIE5vc3RyQ29ubmVjdDogKCkgPT4gTm9zdHJDb25uZWN0LFxuICBPcGVuVGltZXN0YW1wczogKCkgPT4gT3BlblRpbWVzdGFtcHMsXG4gIFBpbmxpc3Q6ICgpID0+IFBpbmxpc3QsXG4gIFByaXZhdGVEaXJlY3RNZXNzYWdlOiAoKSA9PiBQcml2YXRlRGlyZWN0TWVzc2FnZSxcbiAgUHJvYmxlbVRyYWNrZXI6ICgpID0+IFByb2JsZW1UcmFja2VyLFxuICBQcm9maWxlQmFkZ2VzOiAoKSA9PiBQcm9maWxlQmFkZ2VzLFxuICBQdWJsaWNDaGF0c0xpc3Q6ICgpID0+IFB1YmxpY0NoYXRzTGlzdCxcbiAgUmVhY3Rpb246ICgpID0+IFJlYWN0aW9uLFxuICBSZWNvbW1lbmRSZWxheTogKCkgPT4gUmVjb21tZW5kUmVsYXksXG4gIFJlbGF5TGlzdDogKCkgPT4gUmVsYXlMaXN0LFxuICBSZWxheXNldHM6ICgpID0+IFJlbGF5c2V0cyxcbiAgUmVwb3J0OiAoKSA9PiBSZXBvcnQsXG4gIFJlcG9ydGluZzogKCkgPT4gUmVwb3J0aW5nLFxuICBSZXBvc3Q6ICgpID0+IFJlcG9zdCxcbiAgU2VhbDogKCkgPT4gU2VhbCxcbiAgU2VhcmNoUmVsYXlzTGlzdDogKCkgPT4gU2VhcmNoUmVsYXlzTGlzdCxcbiAgU2hvcnRUZXh0Tm90ZTogKCkgPT4gU2hvcnRUZXh0Tm90ZSxcbiAgVGltZTogKCkgPT4gVGltZSxcbiAgVXNlckVtb2ppTGlzdDogKCkgPT4gVXNlckVtb2ppTGlzdCxcbiAgVXNlclN0YXR1c2VzOiAoKSA9PiBVc2VyU3RhdHVzZXMsXG4gIFphcDogKCkgPT4gWmFwLFxuICBaYXBHb2FsOiAoKSA9PiBaYXBHb2FsLFxuICBaYXBSZXF1ZXN0OiAoKSA9PiBaYXBSZXF1ZXN0LFxuICBjbGFzc2lmeUtpbmQ6ICgpID0+IGNsYXNzaWZ5S2luZCxcbiAgaXNFcGhlbWVyYWxLaW5kOiAoKSA9PiBpc0VwaGVtZXJhbEtpbmQsXG4gIGlzS2luZDogKCkgPT4gaXNLaW5kLFxuICBpc1BhcmFtZXRlcml6ZWRSZXBsYWNlYWJsZUtpbmQ6ICgpID0+IGlzUGFyYW1ldGVyaXplZFJlcGxhY2VhYmxlS2luZCxcbiAgaXNSZWd1bGFyS2luZDogKCkgPT4gaXNSZWd1bGFyS2luZCxcbiAgaXNSZXBsYWNlYWJsZUtpbmQ6ICgpID0+IGlzUmVwbGFjZWFibGVLaW5kXG59KTtcbmZ1bmN0aW9uIGlzUmVndWxhcktpbmQoa2luZCkge1xuICByZXR1cm4gMWUzIDw9IGtpbmQgJiYga2luZCA8IDFlNCB8fCBbMSwgMiwgNCwgNSwgNiwgNywgOCwgMTYsIDQwLCA0MSwgNDIsIDQzLCA0NF0uaW5jbHVkZXMoa2luZCk7XG59XG5mdW5jdGlvbiBpc1JlcGxhY2VhYmxlS2luZChraW5kKSB7XG4gIHJldHVybiBbMCwgM10uaW5jbHVkZXMoa2luZCkgfHwgMWU0IDw9IGtpbmQgJiYga2luZCA8IDJlNDtcbn1cbmZ1bmN0aW9uIGlzRXBoZW1lcmFsS2luZChraW5kKSB7XG4gIHJldHVybiAyZTQgPD0ga2luZCAmJiBraW5kIDwgM2U0O1xufVxuZnVuY3Rpb24gaXNQYXJhbWV0ZXJpemVkUmVwbGFjZWFibGVLaW5kKGtpbmQpIHtcbiAgcmV0dXJuIDNlNCA8PSBraW5kICYmIGtpbmQgPCA0ZTQ7XG59XG5mdW5jdGlvbiBjbGFzc2lmeUtpbmQoa2luZCkge1xuICBpZiAoaXNSZWd1bGFyS2luZChraW5kKSlcbiAgICByZXR1cm4gXCJyZWd1bGFyXCI7XG4gIGlmIChpc1JlcGxhY2VhYmxlS2luZChraW5kKSlcbiAgICByZXR1cm4gXCJyZXBsYWNlYWJsZVwiO1xuICBpZiAoaXNFcGhlbWVyYWxLaW5kKGtpbmQpKVxuICAgIHJldHVybiBcImVwaGVtZXJhbFwiO1xuICBpZiAoaXNQYXJhbWV0ZXJpemVkUmVwbGFjZWFibGVLaW5kKGtpbmQpKVxuICAgIHJldHVybiBcInBhcmFtZXRlcml6ZWRcIjtcbiAgcmV0dXJuIFwidW5rbm93blwiO1xufVxuZnVuY3Rpb24gaXNLaW5kKGV2ZW50LCBraW5kKSB7XG4gIGNvbnN0IGtpbmRBc0FycmF5ID0ga2luZCBpbnN0YW5jZW9mIEFycmF5ID8ga2luZCA6IFtraW5kXTtcbiAgcmV0dXJuIHZhbGlkYXRlRXZlbnQoZXZlbnQpICYmIGtpbmRBc0FycmF5LmluY2x1ZGVzKGV2ZW50LmtpbmQpIHx8IGZhbHNlO1xufVxudmFyIE1ldGFkYXRhID0gMDtcbnZhciBTaG9ydFRleHROb3RlID0gMTtcbnZhciBSZWNvbW1lbmRSZWxheSA9IDI7XG52YXIgQ29udGFjdHMgPSAzO1xudmFyIEVuY3J5cHRlZERpcmVjdE1lc3NhZ2UgPSA0O1xudmFyIEV2ZW50RGVsZXRpb24gPSA1O1xudmFyIFJlcG9zdCA9IDY7XG52YXIgUmVhY3Rpb24gPSA3O1xudmFyIEJhZGdlQXdhcmQgPSA4O1xudmFyIFNlYWwgPSAxMztcbnZhciBQcml2YXRlRGlyZWN0TWVzc2FnZSA9IDE0O1xudmFyIEdlbmVyaWNSZXBvc3QgPSAxNjtcbnZhciBDaGFubmVsQ3JlYXRpb24gPSA0MDtcbnZhciBDaGFubmVsTWV0YWRhdGEgPSA0MTtcbnZhciBDaGFubmVsTWVzc2FnZSA9IDQyO1xudmFyIENoYW5uZWxIaWRlTWVzc2FnZSA9IDQzO1xudmFyIENoYW5uZWxNdXRlVXNlciA9IDQ0O1xudmFyIE9wZW5UaW1lc3RhbXBzID0gMTA0MDtcbnZhciBHaWZ0V3JhcCA9IDEwNTk7XG52YXIgRmlsZU1ldGFkYXRhID0gMTA2MztcbnZhciBMaXZlQ2hhdE1lc3NhZ2UgPSAxMzExO1xudmFyIFByb2JsZW1UcmFja2VyID0gMTk3MTtcbnZhciBSZXBvcnQgPSAxOTg0O1xudmFyIFJlcG9ydGluZyA9IDE5ODQ7XG52YXIgTGFiZWwgPSAxOTg1O1xudmFyIENvbW11bml0eVBvc3RBcHByb3ZhbCA9IDQ1NTA7XG52YXIgSm9iUmVxdWVzdCA9IDU5OTk7XG52YXIgSm9iUmVzdWx0ID0gNjk5OTtcbnZhciBKb2JGZWVkYmFjayA9IDdlMztcbnZhciBaYXBHb2FsID0gOTA0MTtcbnZhciBaYXBSZXF1ZXN0ID0gOTczNDtcbnZhciBaYXAgPSA5NzM1O1xudmFyIEhpZ2hsaWdodHMgPSA5ODAyO1xudmFyIE11dGVsaXN0ID0gMWU0O1xudmFyIFBpbmxpc3QgPSAxMDAwMTtcbnZhciBSZWxheUxpc3QgPSAxMDAwMjtcbnZhciBCb29rbWFya0xpc3QgPSAxMDAwMztcbnZhciBDb21tdW5pdGllc0xpc3QgPSAxMDAwNDtcbnZhciBQdWJsaWNDaGF0c0xpc3QgPSAxMDAwNTtcbnZhciBCbG9ja2VkUmVsYXlzTGlzdCA9IDEwMDA2O1xudmFyIFNlYXJjaFJlbGF5c0xpc3QgPSAxMDAwNztcbnZhciBJbnRlcmVzdHNMaXN0ID0gMTAwMTU7XG52YXIgVXNlckVtb2ppTGlzdCA9IDEwMDMwO1xudmFyIERpcmVjdE1lc3NhZ2VSZWxheXNMaXN0ID0gMTAwNTA7XG52YXIgRmlsZVNlcnZlclByZWZlcmVuY2UgPSAxMDA5NjtcbnZhciBOV0NXYWxsZXRJbmZvID0gMTMxOTQ7XG52YXIgTGlnaHRuaW5nUHViUlBDID0gMjFlMztcbnZhciBDbGllbnRBdXRoID0gMjIyNDI7XG52YXIgTldDV2FsbGV0UmVxdWVzdCA9IDIzMTk0O1xudmFyIE5XQ1dhbGxldFJlc3BvbnNlID0gMjMxOTU7XG52YXIgTm9zdHJDb25uZWN0ID0gMjQxMzM7XG52YXIgSFRUUEF1dGggPSAyNzIzNTtcbnZhciBGb2xsb3dzZXRzID0gM2U0O1xudmFyIEdlbmVyaWNsaXN0cyA9IDMwMDAxO1xudmFyIFJlbGF5c2V0cyA9IDMwMDAyO1xudmFyIEJvb2ttYXJrc2V0cyA9IDMwMDAzO1xudmFyIEN1cmF0aW9uc2V0cyA9IDMwMDA0O1xudmFyIFByb2ZpbGVCYWRnZXMgPSAzMDAwODtcbnZhciBCYWRnZURlZmluaXRpb24gPSAzMDAwOTtcbnZhciBJbnRlcmVzdHNldHMgPSAzMDAxNTtcbnZhciBDcmVhdGVPclVwZGF0ZVN0YWxsID0gMzAwMTc7XG52YXIgQ3JlYXRlT3JVcGRhdGVQcm9kdWN0ID0gMzAwMTg7XG52YXIgTG9uZ0Zvcm1BcnRpY2xlID0gMzAwMjM7XG52YXIgRHJhZnRMb25nID0gMzAwMjQ7XG52YXIgRW1vamlzZXRzID0gMzAwMzA7XG52YXIgQXBwbGljYXRpb24gPSAzMDA3ODtcbnZhciBMaXZlRXZlbnQgPSAzMDMxMTtcbnZhciBVc2VyU3RhdHVzZXMgPSAzMDMxNTtcbnZhciBDbGFzc2lmaWVkTGlzdGluZyA9IDMwNDAyO1xudmFyIERyYWZ0Q2xhc3NpZmllZExpc3RpbmcgPSAzMDQwMztcbnZhciBEYXRlMiA9IDMxOTIyO1xudmFyIFRpbWUgPSAzMTkyMztcbnZhciBDYWxlbmRhciA9IDMxOTI0O1xudmFyIENhbGVuZGFyRXZlbnRSU1ZQID0gMzE5MjU7XG52YXIgSGFuZGxlcnJlY29tbWVuZGF0aW9uID0gMzE5ODk7XG52YXIgSGFuZGxlcmluZm9ybWF0aW9uID0gMzE5OTA7XG52YXIgQ29tbXVuaXR5RGVmaW5pdGlvbiA9IDM0NTUwO1xuXG4vLyBmaWx0ZXIudHNcbmZ1bmN0aW9uIG1hdGNoRmlsdGVyKGZpbHRlciwgZXZlbnQpIHtcbiAgaWYgKGZpbHRlci5pZHMgJiYgZmlsdGVyLmlkcy5pbmRleE9mKGV2ZW50LmlkKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGZpbHRlci5raW5kcyAmJiBmaWx0ZXIua2luZHMuaW5kZXhPZihldmVudC5raW5kKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGZpbHRlci5hdXRob3JzICYmIGZpbHRlci5hdXRob3JzLmluZGV4T2YoZXZlbnQucHVia2V5KSA9PT0gLTEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgZiBpbiBmaWx0ZXIpIHtcbiAgICBpZiAoZlswXSA9PT0gXCIjXCIpIHtcbiAgICAgIGxldCB0YWdOYW1lID0gZi5zbGljZSgxKTtcbiAgICAgIGxldCB2YWx1ZXMgPSBmaWx0ZXJbYCMke3RhZ05hbWV9YF07XG4gICAgICBpZiAodmFsdWVzICYmICFldmVudC50YWdzLmZpbmQoKFt0LCB2XSkgPT4gdCA9PT0gZi5zbGljZSgxKSAmJiB2YWx1ZXMuaW5kZXhPZih2KSAhPT0gLTEpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmIChmaWx0ZXIuc2luY2UgJiYgZXZlbnQuY3JlYXRlZF9hdCA8IGZpbHRlci5zaW5jZSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmIChmaWx0ZXIudW50aWwgJiYgZXZlbnQuY3JlYXRlZF9hdCA+IGZpbHRlci51bnRpbClcbiAgICByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gbWF0Y2hGaWx0ZXJzKGZpbHRlcnMsIGV2ZW50KSB7XG4gIGZvciAobGV0IGkyID0gMDsgaTIgPCBmaWx0ZXJzLmxlbmd0aDsgaTIrKykge1xuICAgIGlmIChtYXRjaEZpbHRlcihmaWx0ZXJzW2kyXSwgZXZlbnQpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gbWVyZ2VGaWx0ZXJzKC4uLmZpbHRlcnMpIHtcbiAgbGV0IHJlc3VsdCA9IHt9O1xuICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgZmlsdGVycy5sZW5ndGg7IGkyKyspIHtcbiAgICBsZXQgZmlsdGVyID0gZmlsdGVyc1tpMl07XG4gICAgT2JqZWN0LmVudHJpZXMoZmlsdGVyKS5mb3JFYWNoKChbcHJvcGVydHksIHZhbHVlc10pID0+IHtcbiAgICAgIGlmIChwcm9wZXJ0eSA9PT0gXCJraW5kc1wiIHx8IHByb3BlcnR5ID09PSBcImlkc1wiIHx8IHByb3BlcnR5ID09PSBcImF1dGhvcnNcIiB8fCBwcm9wZXJ0eVswXSA9PT0gXCIjXCIpIHtcbiAgICAgICAgcmVzdWx0W3Byb3BlcnR5XSA9IHJlc3VsdFtwcm9wZXJ0eV0gfHwgW107XG4gICAgICAgIGZvciAobGV0IHYgPSAwOyB2IDwgdmFsdWVzLmxlbmd0aDsgdisrKSB7XG4gICAgICAgICAgbGV0IHZhbHVlID0gdmFsdWVzW3ZdO1xuICAgICAgICAgIGlmICghcmVzdWx0W3Byb3BlcnR5XS5pbmNsdWRlcyh2YWx1ZSkpXG4gICAgICAgICAgICByZXN1bHRbcHJvcGVydHldLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGZpbHRlci5saW1pdCAmJiAoIXJlc3VsdC5saW1pdCB8fCBmaWx0ZXIubGltaXQgPiByZXN1bHQubGltaXQpKVxuICAgICAgcmVzdWx0LmxpbWl0ID0gZmlsdGVyLmxpbWl0O1xuICAgIGlmIChmaWx0ZXIudW50aWwgJiYgKCFyZXN1bHQudW50aWwgfHwgZmlsdGVyLnVudGlsID4gcmVzdWx0LnVudGlsKSlcbiAgICAgIHJlc3VsdC51bnRpbCA9IGZpbHRlci51bnRpbDtcbiAgICBpZiAoZmlsdGVyLnNpbmNlICYmICghcmVzdWx0LnNpbmNlIHx8IGZpbHRlci5zaW5jZSA8IHJlc3VsdC5zaW5jZSkpXG4gICAgICByZXN1bHQuc2luY2UgPSBmaWx0ZXIuc2luY2U7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldEZpbHRlckxpbWl0KGZpbHRlcikge1xuICBpZiAoZmlsdGVyLmlkcyAmJiAhZmlsdGVyLmlkcy5sZW5ndGgpXG4gICAgcmV0dXJuIDA7XG4gIGlmIChmaWx0ZXIua2luZHMgJiYgIWZpbHRlci5raW5kcy5sZW5ndGgpXG4gICAgcmV0dXJuIDA7XG4gIGlmIChmaWx0ZXIuYXV0aG9ycyAmJiAhZmlsdGVyLmF1dGhvcnMubGVuZ3RoKVxuICAgIHJldHVybiAwO1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhmaWx0ZXIpKSB7XG4gICAgaWYgKGtleVswXSA9PT0gXCIjXCIgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgIXZhbHVlLmxlbmd0aClcbiAgICAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiBNYXRoLm1pbihcbiAgICBNYXRoLm1heCgwLCBmaWx0ZXIubGltaXQgPz8gSW5maW5pdHkpLFxuICAgIGZpbHRlci5pZHM/Lmxlbmd0aCA/PyBJbmZpbml0eSxcbiAgICBmaWx0ZXIuYXV0aG9ycz8ubGVuZ3RoICYmIGZpbHRlci5raW5kcz8uZXZlcnkoKGtpbmQpID0+IGlzUmVwbGFjZWFibGVLaW5kKGtpbmQpKSA/IGZpbHRlci5hdXRob3JzLmxlbmd0aCAqIGZpbHRlci5raW5kcy5sZW5ndGggOiBJbmZpbml0eSxcbiAgICBmaWx0ZXIuYXV0aG9ycz8ubGVuZ3RoICYmIGZpbHRlci5raW5kcz8uZXZlcnkoKGtpbmQpID0+IGlzUGFyYW1ldGVyaXplZFJlcGxhY2VhYmxlS2luZChraW5kKSkgJiYgZmlsdGVyW1wiI2RcIl0/Lmxlbmd0aCA/IGZpbHRlci5hdXRob3JzLmxlbmd0aCAqIGZpbHRlci5raW5kcy5sZW5ndGggKiBmaWx0ZXJbXCIjZFwiXS5sZW5ndGggOiBJbmZpbml0eVxuICApO1xufVxuXG4vLyBmYWtlanNvbi50c1xudmFyIGZha2Vqc29uX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGZha2Vqc29uX2V4cG9ydHMsIHtcbiAgZ2V0SGV4NjQ6ICgpID0+IGdldEhleDY0LFxuICBnZXRJbnQ6ICgpID0+IGdldEludCxcbiAgZ2V0U3Vic2NyaXB0aW9uSWQ6ICgpID0+IGdldFN1YnNjcmlwdGlvbklkLFxuICBtYXRjaEV2ZW50SWQ6ICgpID0+IG1hdGNoRXZlbnRJZCxcbiAgbWF0Y2hFdmVudEtpbmQ6ICgpID0+IG1hdGNoRXZlbnRLaW5kLFxuICBtYXRjaEV2ZW50UHVia2V5OiAoKSA9PiBtYXRjaEV2ZW50UHVia2V5XG59KTtcbmZ1bmN0aW9uIGdldEhleDY0KGpzb24sIGZpZWxkKSB7XG4gIGxldCBsZW4gPSBmaWVsZC5sZW5ndGggKyAzO1xuICBsZXQgaWR4ID0ganNvbi5pbmRleE9mKGBcIiR7ZmllbGR9XCI6YCkgKyBsZW47XG4gIGxldCBzID0ganNvbi5zbGljZShpZHgpLmluZGV4T2YoYFwiYCkgKyBpZHggKyAxO1xuICByZXR1cm4ganNvbi5zbGljZShzLCBzICsgNjQpO1xufVxuZnVuY3Rpb24gZ2V0SW50KGpzb24sIGZpZWxkKSB7XG4gIGxldCBsZW4gPSBmaWVsZC5sZW5ndGg7XG4gIGxldCBpZHggPSBqc29uLmluZGV4T2YoYFwiJHtmaWVsZH1cIjpgKSArIGxlbiArIDM7XG4gIGxldCBzbGljZWQgPSBqc29uLnNsaWNlKGlkeCk7XG4gIGxldCBlbmQgPSBNYXRoLm1pbihzbGljZWQuaW5kZXhPZihcIixcIiksIHNsaWNlZC5pbmRleE9mKFwifVwiKSk7XG4gIHJldHVybiBwYXJzZUludChzbGljZWQuc2xpY2UoMCwgZW5kKSwgMTApO1xufVxuZnVuY3Rpb24gZ2V0U3Vic2NyaXB0aW9uSWQoanNvbikge1xuICBsZXQgaWR4ID0ganNvbi5zbGljZSgwLCAyMikuaW5kZXhPZihgXCJFVkVOVFwiYCk7XG4gIGlmIChpZHggPT09IC0xKVxuICAgIHJldHVybiBudWxsO1xuICBsZXQgcHN0YXJ0ID0ganNvbi5zbGljZShpZHggKyA3ICsgMSkuaW5kZXhPZihgXCJgKTtcbiAgaWYgKHBzdGFydCA9PT0gLTEpXG4gICAgcmV0dXJuIG51bGw7XG4gIGxldCBzdGFydCA9IGlkeCArIDcgKyAxICsgcHN0YXJ0O1xuICBsZXQgcGVuZCA9IGpzb24uc2xpY2Uoc3RhcnQgKyAxLCA4MCkuaW5kZXhPZihgXCJgKTtcbiAgaWYgKHBlbmQgPT09IC0xKVxuICAgIHJldHVybiBudWxsO1xuICBsZXQgZW5kID0gc3RhcnQgKyAxICsgcGVuZDtcbiAgcmV0dXJuIGpzb24uc2xpY2Uoc3RhcnQgKyAxLCBlbmQpO1xufVxuZnVuY3Rpb24gbWF0Y2hFdmVudElkKGpzb24sIGlkKSB7XG4gIHJldHVybiBpZCA9PT0gZ2V0SGV4NjQoanNvbiwgXCJpZFwiKTtcbn1cbmZ1bmN0aW9uIG1hdGNoRXZlbnRQdWJrZXkoanNvbiwgcHVia2V5KSB7XG4gIHJldHVybiBwdWJrZXkgPT09IGdldEhleDY0KGpzb24sIFwicHVia2V5XCIpO1xufVxuZnVuY3Rpb24gbWF0Y2hFdmVudEtpbmQoanNvbiwga2luZCkge1xuICByZXR1cm4ga2luZCA9PT0gZ2V0SW50KGpzb24sIFwia2luZFwiKTtcbn1cblxuLy8gbmlwNDIudHNcbnZhciBuaXA0Ml9leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXA0Ml9leHBvcnRzLCB7XG4gIG1ha2VBdXRoRXZlbnQ6ICgpID0+IG1ha2VBdXRoRXZlbnRcbn0pO1xuZnVuY3Rpb24gbWFrZUF1dGhFdmVudChyZWxheVVSTCwgY2hhbGxlbmdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogQ2xpZW50QXV0aCxcbiAgICBjcmVhdGVkX2F0OiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxZTMpLFxuICAgIHRhZ3M6IFtcbiAgICAgIFtcInJlbGF5XCIsIHJlbGF5VVJMXSxcbiAgICAgIFtcImNoYWxsZW5nZVwiLCBjaGFsbGVuZ2VdXG4gICAgXSxcbiAgICBjb250ZW50OiBcIlwiXG4gIH07XG59XG5cbi8vIGhlbHBlcnMudHNcbmFzeW5jIGZ1bmN0aW9uIHlpZWxkVGhyZWFkKCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBjb25zdCBjaCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgIGNvbnN0IGhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICBjaC5wb3J0MS5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBoYW5kbGVyKTtcbiAgICAgIHJlc29sdmUoKTtcbiAgICB9O1xuICAgIGNoLnBvcnQxLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGhhbmRsZXIpO1xuICAgIGNoLnBvcnQyLnBvc3RNZXNzYWdlKDApO1xuICAgIGNoLnBvcnQxLnN0YXJ0KCk7XG4gIH0pO1xufVxudmFyIGFsd2F5c1RydWUgPSAodCkgPT4ge1xuICB0W3ZlcmlmaWVkU3ltYm9sXSA9IHRydWU7XG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gYWJzdHJhY3QtcmVsYXkudHNcbnZhciBBYnN0cmFjdFJlbGF5ID0gY2xhc3Mge1xuICB1cmw7XG4gIF9jb25uZWN0ZWQgPSBmYWxzZTtcbiAgb25jbG9zZSA9IG51bGw7XG4gIG9ubm90aWNlID0gKG1zZykgPT4gY29uc29sZS5kZWJ1ZyhgTk9USUNFIGZyb20gJHt0aGlzLnVybH06ICR7bXNnfWApO1xuICBfb25hdXRoID0gbnVsbDtcbiAgYmFzZUVvc2VUaW1lb3V0ID0gNDQwMDtcbiAgY29ubmVjdGlvblRpbWVvdXQgPSA0NDAwO1xuICBwdWJsaXNoVGltZW91dCA9IDQ0MDA7XG4gIG9wZW5TdWJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29ubmVjdGlvblRpbWVvdXRIYW5kbGU7XG4gIGNvbm5lY3Rpb25Qcm9taXNlO1xuICBvcGVuQ291bnRSZXF1ZXN0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIG9wZW5FdmVudFB1Ymxpc2hlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIHdzO1xuICBpbmNvbWluZ01lc3NhZ2VRdWV1ZSA9IG5ldyBRdWV1ZSgpO1xuICBxdWV1ZVJ1bm5pbmcgPSBmYWxzZTtcbiAgY2hhbGxlbmdlO1xuICBzZXJpYWwgPSAwO1xuICB2ZXJpZnlFdmVudDtcbiAgX1dlYlNvY2tldDtcbiAgY29uc3RydWN0b3IodXJsLCBvcHRzKSB7XG4gICAgdGhpcy51cmwgPSBub3JtYWxpemVVUkwodXJsKTtcbiAgICB0aGlzLnZlcmlmeUV2ZW50ID0gb3B0cy52ZXJpZnlFdmVudDtcbiAgICB0aGlzLl9XZWJTb2NrZXQgPSBvcHRzLndlYnNvY2tldEltcGxlbWVudGF0aW9uIHx8IFdlYlNvY2tldDtcbiAgfVxuICBzdGF0aWMgYXN5bmMgY29ubmVjdCh1cmwsIG9wdHMpIHtcbiAgICBjb25zdCByZWxheSA9IG5ldyBBYnN0cmFjdFJlbGF5KHVybCwgb3B0cyk7XG4gICAgYXdhaXQgcmVsYXkuY29ubmVjdCgpO1xuICAgIHJldHVybiByZWxheTtcbiAgfVxuICBjbG9zZUFsbFN1YnNjcmlwdGlvbnMocmVhc29uKSB7XG4gICAgZm9yIChsZXQgW18sIHN1Yl0gb2YgdGhpcy5vcGVuU3Vicykge1xuICAgICAgc3ViLmNsb3NlKHJlYXNvbik7XG4gICAgfVxuICAgIHRoaXMub3BlblN1YnMuY2xlYXIoKTtcbiAgICBmb3IgKGxldCBbXywgZXBdIG9mIHRoaXMub3BlbkV2ZW50UHVibGlzaGVzKSB7XG4gICAgICBlcC5yZWplY3QobmV3IEVycm9yKHJlYXNvbikpO1xuICAgIH1cbiAgICB0aGlzLm9wZW5FdmVudFB1Ymxpc2hlcy5jbGVhcigpO1xuICAgIGZvciAobGV0IFtfLCBjcl0gb2YgdGhpcy5vcGVuQ291bnRSZXF1ZXN0cykge1xuICAgICAgY3IucmVqZWN0KG5ldyBFcnJvcihyZWFzb24pKTtcbiAgICB9XG4gICAgdGhpcy5vcGVuQ291bnRSZXF1ZXN0cy5jbGVhcigpO1xuICB9XG4gIGdldCBjb25uZWN0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3RlZDtcbiAgfVxuICBhc3luYyBjb25uZWN0KCkge1xuICAgIGlmICh0aGlzLmNvbm5lY3Rpb25Qcm9taXNlKVxuICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvblByb21pc2U7XG4gICAgdGhpcy5jaGFsbGVuZ2UgPSB2b2lkIDA7XG4gICAgdGhpcy5jb25uZWN0aW9uUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuY29ubmVjdGlvblRpbWVvdXRIYW5kbGUgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgcmVqZWN0KFwiY29ubmVjdGlvbiB0aW1lZCBvdXRcIik7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvblByb21pc2UgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMub25jbG9zZT8uKCk7XG4gICAgICAgIHRoaXMuY2xvc2VBbGxTdWJzY3JpcHRpb25zKFwicmVsYXkgY29ubmVjdGlvbiB0aW1lZCBvdXRcIik7XG4gICAgICB9LCB0aGlzLmNvbm5lY3Rpb25UaW1lb3V0KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMud3MgPSBuZXcgdGhpcy5fV2ViU29ja2V0KHRoaXMudXJsKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy53cy5vbm9wZW4gPSAoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNvbm5lY3Rpb25UaW1lb3V0SGFuZGxlKTtcbiAgICAgICAgdGhpcy5fY29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfTtcbiAgICAgIHRoaXMud3Mub25lcnJvciA9IChldikgPT4ge1xuICAgICAgICByZWplY3QoZXYubWVzc2FnZSB8fCBcIndlYnNvY2tldCBlcnJvclwiKTtcbiAgICAgICAgaWYgKHRoaXMuX2Nvbm5lY3RlZCkge1xuICAgICAgICAgIHRoaXMuX2Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuY29ubmVjdGlvblByb21pc2UgPSB2b2lkIDA7XG4gICAgICAgICAgdGhpcy5vbmNsb3NlPy4oKTtcbiAgICAgICAgICB0aGlzLmNsb3NlQWxsU3Vic2NyaXB0aW9ucyhcInJlbGF5IGNvbm5lY3Rpb24gZXJyb3JlZFwiKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHRoaXMud3Mub25jbG9zZSA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX2Nvbm5lY3RlZCkge1xuICAgICAgICAgIHRoaXMuX2Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuY29ubmVjdGlvblByb21pc2UgPSB2b2lkIDA7XG4gICAgICAgICAgdGhpcy5vbmNsb3NlPy4oKTtcbiAgICAgICAgICB0aGlzLmNsb3NlQWxsU3Vic2NyaXB0aW9ucyhcInJlbGF5IGNvbm5lY3Rpb24gY2xvc2VkXCIpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy53cy5vbm1lc3NhZ2UgPSB0aGlzLl9vbm1lc3NhZ2UuYmluZCh0aGlzKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uUHJvbWlzZTtcbiAgfVxuICBhc3luYyBydW5RdWV1ZSgpIHtcbiAgICB0aGlzLnF1ZXVlUnVubmluZyA9IHRydWU7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChmYWxzZSA9PT0gdGhpcy5oYW5kbGVOZXh0KCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBhd2FpdCB5aWVsZFRocmVhZCgpO1xuICAgIH1cbiAgICB0aGlzLnF1ZXVlUnVubmluZyA9IGZhbHNlO1xuICB9XG4gIGhhbmRsZU5leHQoKSB7XG4gICAgY29uc3QganNvbiA9IHRoaXMuaW5jb21pbmdNZXNzYWdlUXVldWUuZGVxdWV1ZSgpO1xuICAgIGlmICghanNvbikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBzdWJpZCA9IGdldFN1YnNjcmlwdGlvbklkKGpzb24pO1xuICAgIGlmIChzdWJpZCkge1xuICAgICAgY29uc3Qgc28gPSB0aGlzLm9wZW5TdWJzLmdldChzdWJpZCk7XG4gICAgICBpZiAoIXNvKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlkID0gZ2V0SGV4NjQoanNvbiwgXCJpZFwiKTtcbiAgICAgIGNvbnN0IGFscmVhZHlIYXZlID0gc28uYWxyZWFkeUhhdmVFdmVudD8uKGlkKTtcbiAgICAgIHNvLnJlY2VpdmVkRXZlbnQ/Lih0aGlzLCBpZCk7XG4gICAgICBpZiAoYWxyZWFkeUhhdmUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgbGV0IGRhdGEgPSBKU09OLnBhcnNlKGpzb24pO1xuICAgICAgc3dpdGNoIChkYXRhWzBdKSB7XG4gICAgICAgIGNhc2UgXCJFVkVOVFwiOiB7XG4gICAgICAgICAgY29uc3Qgc28gPSB0aGlzLm9wZW5TdWJzLmdldChkYXRhWzFdKTtcbiAgICAgICAgICBjb25zdCBldmVudCA9IGRhdGFbMl07XG4gICAgICAgICAgaWYgKHRoaXMudmVyaWZ5RXZlbnQoZXZlbnQpICYmIG1hdGNoRmlsdGVycyhzby5maWx0ZXJzLCBldmVudCkpIHtcbiAgICAgICAgICAgIHNvLm9uZXZlbnQoZXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIkNPVU5UXCI6IHtcbiAgICAgICAgICBjb25zdCBpZCA9IGRhdGFbMV07XG4gICAgICAgICAgY29uc3QgcGF5bG9hZCA9IGRhdGFbMl07XG4gICAgICAgICAgY29uc3QgY3IgPSB0aGlzLm9wZW5Db3VudFJlcXVlc3RzLmdldChpZCk7XG4gICAgICAgICAgaWYgKGNyKSB7XG4gICAgICAgICAgICBjci5yZXNvbHZlKHBheWxvYWQuY291bnQpO1xuICAgICAgICAgICAgdGhpcy5vcGVuQ291bnRSZXF1ZXN0cy5kZWxldGUoaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIkVPU0VcIjoge1xuICAgICAgICAgIGNvbnN0IHNvID0gdGhpcy5vcGVuU3Vicy5nZXQoZGF0YVsxXSk7XG4gICAgICAgICAgaWYgKCFzbylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBzby5yZWNlaXZlZEVvc2UoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIk9LXCI6IHtcbiAgICAgICAgICBjb25zdCBpZCA9IGRhdGFbMV07XG4gICAgICAgICAgY29uc3Qgb2sgPSBkYXRhWzJdO1xuICAgICAgICAgIGNvbnN0IHJlYXNvbiA9IGRhdGFbM107XG4gICAgICAgICAgY29uc3QgZXAgPSB0aGlzLm9wZW5FdmVudFB1Ymxpc2hlcy5nZXQoaWQpO1xuICAgICAgICAgIGlmIChlcCkge1xuICAgICAgICAgICAgaWYgKG9rKVxuICAgICAgICAgICAgICBlcC5yZXNvbHZlKHJlYXNvbik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGVwLnJlamVjdChuZXcgRXJyb3IocmVhc29uKSk7XG4gICAgICAgICAgICB0aGlzLm9wZW5FdmVudFB1Ymxpc2hlcy5kZWxldGUoaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIkNMT1NFRFwiOiB7XG4gICAgICAgICAgY29uc3QgaWQgPSBkYXRhWzFdO1xuICAgICAgICAgIGNvbnN0IHNvID0gdGhpcy5vcGVuU3Vicy5nZXQoaWQpO1xuICAgICAgICAgIGlmICghc28pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgc28uY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgICBzby5jbG9zZShkYXRhWzJdKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIk5PVElDRVwiOlxuICAgICAgICAgIHRoaXMub25ub3RpY2UoZGF0YVsxXSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlIFwiQVVUSFwiOiB7XG4gICAgICAgICAgdGhpcy5jaGFsbGVuZ2UgPSBkYXRhWzFdO1xuICAgICAgICAgIHRoaXMuX29uYXV0aD8uKGRhdGFbMV0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBhc3luYyBzZW5kKG1lc3NhZ2UpIHtcbiAgICBpZiAoIXRoaXMuY29ubmVjdGlvblByb21pc2UpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzZW5kaW5nIG9uIGNsb3NlZCBjb25uZWN0aW9uXCIpO1xuICAgIHRoaXMuY29ubmVjdGlvblByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICB0aGlzLndzPy5zZW5kKG1lc3NhZ2UpO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGF1dGgoc2lnbkF1dGhFdmVudCkge1xuICAgIGlmICghdGhpcy5jaGFsbGVuZ2UpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW4ndCBwZXJmb3JtIGF1dGgsIG5vIGNoYWxsZW5nZSB3YXMgcmVjZWl2ZWRcIik7XG4gICAgY29uc3QgZXZ0ID0gYXdhaXQgc2lnbkF1dGhFdmVudChtYWtlQXV0aEV2ZW50KHRoaXMudXJsLCB0aGlzLmNoYWxsZW5nZSkpO1xuICAgIGNvbnN0IHJldCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMub3BlbkV2ZW50UHVibGlzaGVzLnNldChldnQuaWQsIHsgcmVzb2x2ZSwgcmVqZWN0IH0pO1xuICAgIH0pO1xuICAgIHRoaXMuc2VuZCgnW1wiQVVUSFwiLCcgKyBKU09OLnN0cmluZ2lmeShldnQpICsgXCJdXCIpO1xuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgYXN5bmMgcHVibGlzaChldmVudCkge1xuICAgIGNvbnN0IHJldCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMub3BlbkV2ZW50UHVibGlzaGVzLnNldChldmVudC5pZCwgeyByZXNvbHZlLCByZWplY3QgfSk7XG4gICAgfSk7XG4gICAgdGhpcy5zZW5kKCdbXCJFVkVOVFwiLCcgKyBKU09OLnN0cmluZ2lmeShldmVudCkgKyBcIl1cIik7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBjb25zdCBlcCA9IHRoaXMub3BlbkV2ZW50UHVibGlzaGVzLmdldChldmVudC5pZCk7XG4gICAgICBpZiAoZXApIHtcbiAgICAgICAgZXAucmVqZWN0KG5ldyBFcnJvcihcInB1Ymxpc2ggdGltZWQgb3V0XCIpKTtcbiAgICAgICAgdGhpcy5vcGVuRXZlbnRQdWJsaXNoZXMuZGVsZXRlKGV2ZW50LmlkKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLnB1Ymxpc2hUaW1lb3V0KTtcbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGFzeW5jIGNvdW50KGZpbHRlcnMsIHBhcmFtcykge1xuICAgIHRoaXMuc2VyaWFsKys7XG4gICAgY29uc3QgaWQgPSBwYXJhbXM/LmlkIHx8IFwiY291bnQ6XCIgKyB0aGlzLnNlcmlhbDtcbiAgICBjb25zdCByZXQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLm9wZW5Db3VudFJlcXVlc3RzLnNldChpZCwgeyByZXNvbHZlLCByZWplY3QgfSk7XG4gICAgfSk7XG4gICAgdGhpcy5zZW5kKCdbXCJDT1VOVFwiLFwiJyArIGlkICsgJ1wiLCcgKyBKU09OLnN0cmluZ2lmeShmaWx0ZXJzKS5zdWJzdHJpbmcoMSkpO1xuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgc3Vic2NyaWJlKGZpbHRlcnMsIHBhcmFtcykge1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHRoaXMucHJlcGFyZVN1YnNjcmlwdGlvbihmaWx0ZXJzLCBwYXJhbXMpO1xuICAgIHN1YnNjcmlwdGlvbi5maXJlKCk7XG4gICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgfVxuICBwcmVwYXJlU3Vic2NyaXB0aW9uKGZpbHRlcnMsIHBhcmFtcykge1xuICAgIHRoaXMuc2VyaWFsKys7XG4gICAgY29uc3QgaWQgPSBwYXJhbXMuaWQgfHwgXCJzdWI6XCIgKyB0aGlzLnNlcmlhbDtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uKHRoaXMsIGlkLCBmaWx0ZXJzLCBwYXJhbXMpO1xuICAgIHRoaXMub3BlblN1YnMuc2V0KGlkLCBzdWJzY3JpcHRpb24pO1xuICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gIH1cbiAgY2xvc2UoKSB7XG4gICAgdGhpcy5jbG9zZUFsbFN1YnNjcmlwdGlvbnMoXCJyZWxheSBjb25uZWN0aW9uIGNsb3NlZCBieSB1c1wiKTtcbiAgICB0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLndzPy5jbG9zZSgpO1xuICB9XG4gIF9vbm1lc3NhZ2UoZXYpIHtcbiAgICB0aGlzLmluY29taW5nTWVzc2FnZVF1ZXVlLmVucXVldWUoZXYuZGF0YSk7XG4gICAgaWYgKCF0aGlzLnF1ZXVlUnVubmluZykge1xuICAgICAgdGhpcy5ydW5RdWV1ZSgpO1xuICAgIH1cbiAgfVxufTtcbnZhciBTdWJzY3JpcHRpb24gPSBjbGFzcyB7XG4gIHJlbGF5O1xuICBpZDtcbiAgY2xvc2VkID0gZmFsc2U7XG4gIGVvc2VkID0gZmFsc2U7XG4gIGZpbHRlcnM7XG4gIGFscmVhZHlIYXZlRXZlbnQ7XG4gIHJlY2VpdmVkRXZlbnQ7XG4gIG9uZXZlbnQ7XG4gIG9uZW9zZTtcbiAgb25jbG9zZTtcbiAgZW9zZVRpbWVvdXQ7XG4gIGVvc2VUaW1lb3V0SGFuZGxlO1xuICBjb25zdHJ1Y3RvcihyZWxheSwgaWQsIGZpbHRlcnMsIHBhcmFtcykge1xuICAgIHRoaXMucmVsYXkgPSByZWxheTtcbiAgICB0aGlzLmZpbHRlcnMgPSBmaWx0ZXJzO1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLmFscmVhZHlIYXZlRXZlbnQgPSBwYXJhbXMuYWxyZWFkeUhhdmVFdmVudDtcbiAgICB0aGlzLnJlY2VpdmVkRXZlbnQgPSBwYXJhbXMucmVjZWl2ZWRFdmVudDtcbiAgICB0aGlzLmVvc2VUaW1lb3V0ID0gcGFyYW1zLmVvc2VUaW1lb3V0IHx8IHJlbGF5LmJhc2VFb3NlVGltZW91dDtcbiAgICB0aGlzLm9uZW9zZSA9IHBhcmFtcy5vbmVvc2U7XG4gICAgdGhpcy5vbmNsb3NlID0gcGFyYW1zLm9uY2xvc2U7XG4gICAgdGhpcy5vbmV2ZW50ID0gcGFyYW1zLm9uZXZlbnQgfHwgKChldmVudCkgPT4ge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgb25ldmVudCgpIGNhbGxiYWNrIG5vdCBkZWZpbmVkIGZvciBzdWJzY3JpcHRpb24gJyR7dGhpcy5pZH0nIGluIHJlbGF5ICR7dGhpcy5yZWxheS51cmx9LiBldmVudCByZWNlaXZlZDpgLFxuICAgICAgICBldmVudFxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuICBmaXJlKCkge1xuICAgIHRoaXMucmVsYXkuc2VuZCgnW1wiUkVRXCIsXCInICsgdGhpcy5pZCArICdcIiwnICsgSlNPTi5zdHJpbmdpZnkodGhpcy5maWx0ZXJzKS5zdWJzdHJpbmcoMSkpO1xuICAgIHRoaXMuZW9zZVRpbWVvdXRIYW5kbGUgPSBzZXRUaW1lb3V0KHRoaXMucmVjZWl2ZWRFb3NlLmJpbmQodGhpcyksIHRoaXMuZW9zZVRpbWVvdXQpO1xuICB9XG4gIHJlY2VpdmVkRW9zZSgpIHtcbiAgICBpZiAodGhpcy5lb3NlZClcbiAgICAgIHJldHVybjtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5lb3NlVGltZW91dEhhbmRsZSk7XG4gICAgdGhpcy5lb3NlZCA9IHRydWU7XG4gICAgdGhpcy5vbmVvc2U/LigpO1xuICB9XG4gIGNsb3NlKHJlYXNvbiA9IFwiY2xvc2VkIGJ5IGNhbGxlclwiKSB7XG4gICAgaWYgKCF0aGlzLmNsb3NlZCAmJiB0aGlzLnJlbGF5LmNvbm5lY3RlZCkge1xuICAgICAgdGhpcy5yZWxheS5zZW5kKCdbXCJDTE9TRVwiLCcgKyBKU09OLnN0cmluZ2lmeSh0aGlzLmlkKSArIFwiXVwiKTtcbiAgICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5yZWxheS5vcGVuU3Vicy5kZWxldGUodGhpcy5pZCk7XG4gICAgdGhpcy5vbmNsb3NlPy4ocmVhc29uKTtcbiAgfVxufTtcblxuLy8gcmVsYXkudHNcbnZhciBfV2ViU29ja2V0O1xudHJ5IHtcbiAgX1dlYlNvY2tldCA9IFdlYlNvY2tldDtcbn0gY2F0Y2gge1xufVxudmFyIFJlbGF5ID0gY2xhc3MgZXh0ZW5kcyBBYnN0cmFjdFJlbGF5IHtcbiAgY29uc3RydWN0b3IodXJsKSB7XG4gICAgc3VwZXIodXJsLCB7IHZlcmlmeUV2ZW50LCB3ZWJzb2NrZXRJbXBsZW1lbnRhdGlvbjogX1dlYlNvY2tldCB9KTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgY29ubmVjdCh1cmwpIHtcbiAgICBjb25zdCByZWxheSA9IG5ldyBSZWxheSh1cmwpO1xuICAgIGF3YWl0IHJlbGF5LmNvbm5lY3QoKTtcbiAgICByZXR1cm4gcmVsYXk7XG4gIH1cbn07XG5cbi8vIGFic3RyYWN0LXBvb2wudHNcbnZhciBBYnN0cmFjdFNpbXBsZVBvb2wgPSBjbGFzcyB7XG4gIHJlbGF5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIHNlZW5PbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIHRyYWNrUmVsYXlzID0gZmFsc2U7XG4gIHZlcmlmeUV2ZW50O1xuICB0cnVzdGVkUmVsYXlVUkxzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgX1dlYlNvY2tldDtcbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHRoaXMudmVyaWZ5RXZlbnQgPSBvcHRzLnZlcmlmeUV2ZW50O1xuICAgIHRoaXMuX1dlYlNvY2tldCA9IG9wdHMud2Vic29ja2V0SW1wbGVtZW50YXRpb247XG4gIH1cbiAgYXN5bmMgZW5zdXJlUmVsYXkodXJsLCBwYXJhbXMpIHtcbiAgICB1cmwgPSBub3JtYWxpemVVUkwodXJsKTtcbiAgICBsZXQgcmVsYXkgPSB0aGlzLnJlbGF5cy5nZXQodXJsKTtcbiAgICBpZiAoIXJlbGF5KSB7XG4gICAgICByZWxheSA9IG5ldyBBYnN0cmFjdFJlbGF5KHVybCwge1xuICAgICAgICB2ZXJpZnlFdmVudDogdGhpcy50cnVzdGVkUmVsYXlVUkxzLmhhcyh1cmwpID8gYWx3YXlzVHJ1ZSA6IHRoaXMudmVyaWZ5RXZlbnQsXG4gICAgICAgIHdlYnNvY2tldEltcGxlbWVudGF0aW9uOiB0aGlzLl9XZWJTb2NrZXRcbiAgICAgIH0pO1xuICAgICAgaWYgKHBhcmFtcz8uY29ubmVjdGlvblRpbWVvdXQpXG4gICAgICAgIHJlbGF5LmNvbm5lY3Rpb25UaW1lb3V0ID0gcGFyYW1zLmNvbm5lY3Rpb25UaW1lb3V0O1xuICAgICAgdGhpcy5yZWxheXMuc2V0KHVybCwgcmVsYXkpO1xuICAgIH1cbiAgICBhd2FpdCByZWxheS5jb25uZWN0KCk7XG4gICAgcmV0dXJuIHJlbGF5O1xuICB9XG4gIGNsb3NlKHJlbGF5cykge1xuICAgIHJlbGF5cy5tYXAobm9ybWFsaXplVVJMKS5mb3JFYWNoKCh1cmwpID0+IHtcbiAgICAgIHRoaXMucmVsYXlzLmdldCh1cmwpPy5jbG9zZSgpO1xuICAgIH0pO1xuICB9XG4gIHN1YnNjcmliZU1hbnkocmVsYXlzLCBmaWx0ZXJzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gdGhpcy5zdWJzY3JpYmVNYW55TWFwKE9iamVjdC5mcm9tRW50cmllcyhyZWxheXMubWFwKCh1cmwpID0+IFt1cmwsIGZpbHRlcnNdKSksIHBhcmFtcyk7XG4gIH1cbiAgc3Vic2NyaWJlTWFueU1hcChyZXF1ZXN0cywgcGFyYW1zKSB7XG4gICAgaWYgKHRoaXMudHJhY2tSZWxheXMpIHtcbiAgICAgIHBhcmFtcy5yZWNlaXZlZEV2ZW50ID0gKHJlbGF5LCBpZCkgPT4ge1xuICAgICAgICBsZXQgc2V0ID0gdGhpcy5zZWVuT24uZ2V0KGlkKTtcbiAgICAgICAgaWYgKCFzZXQpIHtcbiAgICAgICAgICBzZXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgICAgIHRoaXMuc2Vlbk9uLnNldChpZCwgc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBzZXQuYWRkKHJlbGF5KTtcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IF9rbm93bklkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgY29uc3Qgc3VicyA9IFtdO1xuICAgIGNvbnN0IHJlbGF5c0xlbmd0aCA9IE9iamVjdC5rZXlzKHJlcXVlc3RzKS5sZW5ndGg7XG4gICAgY29uc3QgZW9zZXNSZWNlaXZlZCA9IFtdO1xuICAgIGxldCBoYW5kbGVFb3NlID0gKGkyKSA9PiB7XG4gICAgICBlb3Nlc1JlY2VpdmVkW2kyXSA9IHRydWU7XG4gICAgICBpZiAoZW9zZXNSZWNlaXZlZC5maWx0ZXIoKGEpID0+IGEpLmxlbmd0aCA9PT0gcmVsYXlzTGVuZ3RoKSB7XG4gICAgICAgIHBhcmFtcy5vbmVvc2U/LigpO1xuICAgICAgICBoYW5kbGVFb3NlID0gKCkgPT4ge1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgY2xvc2VzUmVjZWl2ZWQgPSBbXTtcbiAgICBsZXQgaGFuZGxlQ2xvc2UgPSAoaTIsIHJlYXNvbikgPT4ge1xuICAgICAgaGFuZGxlRW9zZShpMik7XG4gICAgICBjbG9zZXNSZWNlaXZlZFtpMl0gPSByZWFzb247XG4gICAgICBpZiAoY2xvc2VzUmVjZWl2ZWQuZmlsdGVyKChhKSA9PiBhKS5sZW5ndGggPT09IHJlbGF5c0xlbmd0aCkge1xuICAgICAgICBwYXJhbXMub25jbG9zZT8uKGNsb3Nlc1JlY2VpdmVkKTtcbiAgICAgICAgaGFuZGxlQ2xvc2UgPSAoKSA9PiB7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBsb2NhbEFscmVhZHlIYXZlRXZlbnRIYW5kbGVyID0gKGlkKSA9PiB7XG4gICAgICBpZiAocGFyYW1zLmFscmVhZHlIYXZlRXZlbnQ/LihpZCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBjb25zdCBoYXZlID0gX2tub3duSWRzLmhhcyhpZCk7XG4gICAgICBfa25vd25JZHMuYWRkKGlkKTtcbiAgICAgIHJldHVybiBoYXZlO1xuICAgIH07XG4gICAgY29uc3QgYWxsT3BlbmVkID0gUHJvbWlzZS5hbGwoXG4gICAgICBPYmplY3QuZW50cmllcyhyZXF1ZXN0cykubWFwKGFzeW5jIChyZXEsIGkyLCBhcnIpID0+IHtcbiAgICAgICAgaWYgKGFyci5pbmRleE9mKHJlcSkgIT09IGkyKSB7XG4gICAgICAgICAgaGFuZGxlQ2xvc2UoaTIsIFwiZHVwbGljYXRlIHVybFwiKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IFt1cmwsIGZpbHRlcnNdID0gcmVxO1xuICAgICAgICB1cmwgPSBub3JtYWxpemVVUkwodXJsKTtcbiAgICAgICAgbGV0IHJlbGF5O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlbGF5ID0gYXdhaXQgdGhpcy5lbnN1cmVSZWxheSh1cmwsIHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb25UaW1lb3V0OiBwYXJhbXMubWF4V2FpdCA/IE1hdGgubWF4KHBhcmFtcy5tYXhXYWl0ICogMC44LCBwYXJhbXMubWF4V2FpdCAtIDFlMykgOiB2b2lkIDBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgaGFuZGxlQ2xvc2UoaTIsIGVycj8ubWVzc2FnZSB8fCBTdHJpbmcoZXJyKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdWJzY3JpcHRpb24gPSByZWxheS5zdWJzY3JpYmUoZmlsdGVycywge1xuICAgICAgICAgIC4uLnBhcmFtcyxcbiAgICAgICAgICBvbmVvc2U6ICgpID0+IGhhbmRsZUVvc2UoaTIpLFxuICAgICAgICAgIG9uY2xvc2U6IChyZWFzb24pID0+IGhhbmRsZUNsb3NlKGkyLCByZWFzb24pLFxuICAgICAgICAgIGFscmVhZHlIYXZlRXZlbnQ6IGxvY2FsQWxyZWFkeUhhdmVFdmVudEhhbmRsZXIsXG4gICAgICAgICAgZW9zZVRpbWVvdXQ6IHBhcmFtcy5tYXhXYWl0XG4gICAgICAgIH0pO1xuICAgICAgICBzdWJzLnB1c2goc3Vic2NyaXB0aW9uKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgYXN5bmMgY2xvc2UoKSB7XG4gICAgICAgIGF3YWl0IGFsbE9wZW5lZDtcbiAgICAgICAgc3Vicy5mb3JFYWNoKChzdWIpID0+IHtcbiAgICAgICAgICBzdWIuY2xvc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBzdWJzY3JpYmVNYW55RW9zZShyZWxheXMsIGZpbHRlcnMsIHBhcmFtcykge1xuICAgIGNvbnN0IHN1YmNsb3NlciA9IHRoaXMuc3Vic2NyaWJlTWFueShyZWxheXMsIGZpbHRlcnMsIHtcbiAgICAgIC4uLnBhcmFtcyxcbiAgICAgIG9uZW9zZSgpIHtcbiAgICAgICAgc3ViY2xvc2VyLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHN1YmNsb3NlcjtcbiAgfVxuICBhc3luYyBxdWVyeVN5bmMocmVsYXlzLCBmaWx0ZXIsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSkgPT4ge1xuICAgICAgY29uc3QgZXZlbnRzID0gW107XG4gICAgICB0aGlzLnN1YnNjcmliZU1hbnlFb3NlKHJlbGF5cywgW2ZpbHRlcl0sIHtcbiAgICAgICAgLi4ucGFyYW1zLFxuICAgICAgICBvbmV2ZW50KGV2ZW50KSB7XG4gICAgICAgICAgZXZlbnRzLnB1c2goZXZlbnQpO1xuICAgICAgICB9LFxuICAgICAgICBvbmNsb3NlKF8pIHtcbiAgICAgICAgICByZXNvbHZlKGV2ZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGdldChyZWxheXMsIGZpbHRlciwgcGFyYW1zKSB7XG4gICAgZmlsdGVyLmxpbWl0ID0gMTtcbiAgICBjb25zdCBldmVudHMgPSBhd2FpdCB0aGlzLnF1ZXJ5U3luYyhyZWxheXMsIGZpbHRlciwgcGFyYW1zKTtcbiAgICBldmVudHMuc29ydCgoYSwgYikgPT4gYi5jcmVhdGVkX2F0IC0gYS5jcmVhdGVkX2F0KTtcbiAgICByZXR1cm4gZXZlbnRzWzBdIHx8IG51bGw7XG4gIH1cbiAgcHVibGlzaChyZWxheXMsIGV2ZW50KSB7XG4gICAgcmV0dXJuIHJlbGF5cy5tYXAobm9ybWFsaXplVVJMKS5tYXAoYXN5bmMgKHVybCwgaTIsIGFycikgPT4ge1xuICAgICAgaWYgKGFyci5pbmRleE9mKHVybCkgIT09IGkyKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcImR1cGxpY2F0ZSB1cmxcIik7XG4gICAgICB9XG4gICAgICBsZXQgciA9IGF3YWl0IHRoaXMuZW5zdXJlUmVsYXkodXJsKTtcbiAgICAgIHJldHVybiByLnB1Ymxpc2goZXZlbnQpLnRoZW4oKHJlYXNvbikgPT4ge1xuICAgICAgICBpZiAodGhpcy50cmFja1JlbGF5cykge1xuICAgICAgICAgIGxldCBzZXQgPSB0aGlzLnNlZW5Pbi5nZXQoZXZlbnQuaWQpO1xuICAgICAgICAgIGlmICghc2V0KSB7XG4gICAgICAgICAgICBzZXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgICAgICAgdGhpcy5zZWVuT24uc2V0KGV2ZW50LmlkLCBzZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZXQuYWRkKHIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWFzb247XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBsaXN0Q29ubmVjdGlvblN0YXR1cygpIHtcbiAgICBjb25zdCBtYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMucmVsYXlzLmZvckVhY2goKHJlbGF5LCB1cmwpID0+IG1hcC5zZXQodXJsLCByZWxheS5jb25uZWN0ZWQpKTtcbiAgICByZXR1cm4gbWFwO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5yZWxheXMuZm9yRWFjaCgoY29ubikgPT4gY29ubi5jbG9zZSgpKTtcbiAgICB0aGlzLnJlbGF5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbn07XG5cbi8vIHBvb2wudHNcbnZhciBfV2ViU29ja2V0MjtcbnRyeSB7XG4gIF9XZWJTb2NrZXQyID0gV2ViU29ja2V0O1xufSBjYXRjaCB7XG59XG52YXIgU2ltcGxlUG9vbCA9IGNsYXNzIGV4dGVuZHMgQWJzdHJhY3RTaW1wbGVQb29sIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoeyB2ZXJpZnlFdmVudCwgd2Vic29ja2V0SW1wbGVtZW50YXRpb246IF9XZWJTb2NrZXQyIH0pO1xuICB9XG59O1xuXG4vLyBuaXAxOS50c1xudmFyIG5pcDE5X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDE5X2V4cG9ydHMsIHtcbiAgQkVDSDMyX1JFR0VYOiAoKSA9PiBCRUNIMzJfUkVHRVgsXG4gIEJlY2gzMk1heFNpemU6ICgpID0+IEJlY2gzMk1heFNpemUsXG4gIE5vc3RyVHlwZUd1YXJkOiAoKSA9PiBOb3N0clR5cGVHdWFyZCxcbiAgZGVjb2RlOiAoKSA9PiBkZWNvZGUsXG4gIGVuY29kZUJ5dGVzOiAoKSA9PiBlbmNvZGVCeXRlcyxcbiAgbmFkZHJFbmNvZGU6ICgpID0+IG5hZGRyRW5jb2RlLFxuICBuZXZlbnRFbmNvZGU6ICgpID0+IG5ldmVudEVuY29kZSxcbiAgbm90ZUVuY29kZTogKCkgPT4gbm90ZUVuY29kZSxcbiAgbnByb2ZpbGVFbmNvZGU6ICgpID0+IG5wcm9maWxlRW5jb2RlLFxuICBucHViRW5jb2RlOiAoKSA9PiBucHViRW5jb2RlLFxuICBuc2VjRW5jb2RlOiAoKSA9PiBuc2VjRW5jb2RlXG59KTtcbmltcG9ydCB7IGJ5dGVzVG9IZXggYXMgYnl0ZXNUb0hleDIsIGNvbmNhdEJ5dGVzLCBoZXhUb0J5dGVzIH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvdXRpbHNcIjtcbmltcG9ydCB7IGJlY2gzMiB9IGZyb20gXCJAc2N1cmUvYmFzZVwiO1xudmFyIE5vc3RyVHlwZUd1YXJkID0ge1xuICBpc05Qcm9maWxlOiAodmFsdWUpID0+IC9ebnByb2ZpbGUxW2EtelxcZF0rJC8udGVzdCh2YWx1ZSB8fCBcIlwiKSxcbiAgaXNORXZlbnQ6ICh2YWx1ZSkgPT4gL15uZXZlbnQxW2EtelxcZF0rJC8udGVzdCh2YWx1ZSB8fCBcIlwiKSxcbiAgaXNOQWRkcjogKHZhbHVlKSA9PiAvXm5hZGRyMVthLXpcXGRdKyQvLnRlc3QodmFsdWUgfHwgXCJcIiksXG4gIGlzTlNlYzogKHZhbHVlKSA9PiAvXm5zZWMxW2EtelxcZF17NTh9JC8udGVzdCh2YWx1ZSB8fCBcIlwiKSxcbiAgaXNOUHViOiAodmFsdWUpID0+IC9ebnB1YjFbYS16XFxkXXs1OH0kLy50ZXN0KHZhbHVlIHx8IFwiXCIpLFxuICBpc05vdGU6ICh2YWx1ZSkgPT4gL15ub3RlMVthLXpcXGRdKyQvLnRlc3QodmFsdWUgfHwgXCJcIiksXG4gIGlzTmNyeXB0c2VjOiAodmFsdWUpID0+IC9ebmNyeXB0c2VjMVthLXpcXGRdKyQvLnRlc3QodmFsdWUgfHwgXCJcIilcbn07XG52YXIgQmVjaDMyTWF4U2l6ZSA9IDVlMztcbnZhciBCRUNIMzJfUkVHRVggPSAvW1xceDIxLVxceDdFXXsxLDgzfTFbMDIzNDU2Nzg5YWNkZWZnaGprbG1ucHFyc3R1dnd4eXpdezYsfS87XG5mdW5jdGlvbiBpbnRlZ2VyVG9VaW50OEFycmF5KG51bWJlcikge1xuICBjb25zdCB1aW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gIHVpbnQ4QXJyYXlbMF0gPSBudW1iZXIgPj4gMjQgJiAyNTU7XG4gIHVpbnQ4QXJyYXlbMV0gPSBudW1iZXIgPj4gMTYgJiAyNTU7XG4gIHVpbnQ4QXJyYXlbMl0gPSBudW1iZXIgPj4gOCAmIDI1NTtcbiAgdWludDhBcnJheVszXSA9IG51bWJlciAmIDI1NTtcbiAgcmV0dXJuIHVpbnQ4QXJyYXk7XG59XG5mdW5jdGlvbiBkZWNvZGUobmlwMTkpIHtcbiAgbGV0IHsgcHJlZml4LCB3b3JkcyB9ID0gYmVjaDMyLmRlY29kZShuaXAxOSwgQmVjaDMyTWF4U2l6ZSk7XG4gIGxldCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoYmVjaDMyLmZyb21Xb3Jkcyh3b3JkcykpO1xuICBzd2l0Y2ggKHByZWZpeCkge1xuICAgIGNhc2UgXCJucHJvZmlsZVwiOiB7XG4gICAgICBsZXQgdGx2ID0gcGFyc2VUTFYoZGF0YSk7XG4gICAgICBpZiAoIXRsdlswXT8uWzBdKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIFRMViAwIGZvciBucHJvZmlsZVwiKTtcbiAgICAgIGlmICh0bHZbMF1bMF0ubGVuZ3RoICE9PSAzMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVExWIDAgc2hvdWxkIGJlIDMyIGJ5dGVzXCIpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJucHJvZmlsZVwiLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgcHVia2V5OiBieXRlc1RvSGV4Mih0bHZbMF1bMF0pLFxuICAgICAgICAgIHJlbGF5czogdGx2WzFdID8gdGx2WzFdLm1hcCgoZCkgPT4gdXRmOERlY29kZXIuZGVjb2RlKGQpKSA6IFtdXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgXCJuZXZlbnRcIjoge1xuICAgICAgbGV0IHRsdiA9IHBhcnNlVExWKGRhdGEpO1xuICAgICAgaWYgKCF0bHZbMF0/LlswXSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBUTFYgMCBmb3IgbmV2ZW50XCIpO1xuICAgICAgaWYgKHRsdlswXVswXS5sZW5ndGggIT09IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUTFYgMCBzaG91bGQgYmUgMzIgYnl0ZXNcIik7XG4gICAgICBpZiAodGx2WzJdICYmIHRsdlsyXVswXS5sZW5ndGggIT09IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUTFYgMiBzaG91bGQgYmUgMzIgYnl0ZXNcIik7XG4gICAgICBpZiAodGx2WzNdICYmIHRsdlszXVswXS5sZW5ndGggIT09IDQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRMViAzIHNob3VsZCBiZSA0IGJ5dGVzXCIpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJuZXZlbnRcIixcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGlkOiBieXRlc1RvSGV4Mih0bHZbMF1bMF0pLFxuICAgICAgICAgIHJlbGF5czogdGx2WzFdID8gdGx2WzFdLm1hcCgoZCkgPT4gdXRmOERlY29kZXIuZGVjb2RlKGQpKSA6IFtdLFxuICAgICAgICAgIGF1dGhvcjogdGx2WzJdPy5bMF0gPyBieXRlc1RvSGV4Mih0bHZbMl1bMF0pIDogdm9pZCAwLFxuICAgICAgICAgIGtpbmQ6IHRsdlszXT8uWzBdID8gcGFyc2VJbnQoYnl0ZXNUb0hleDIodGx2WzNdWzBdKSwgMTYpIDogdm9pZCAwXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgXCJuYWRkclwiOiB7XG4gICAgICBsZXQgdGx2ID0gcGFyc2VUTFYoZGF0YSk7XG4gICAgICBpZiAoIXRsdlswXT8uWzBdKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIFRMViAwIGZvciBuYWRkclwiKTtcbiAgICAgIGlmICghdGx2WzJdPy5bMF0pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgVExWIDIgZm9yIG5hZGRyXCIpO1xuICAgICAgaWYgKHRsdlsyXVswXS5sZW5ndGggIT09IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUTFYgMiBzaG91bGQgYmUgMzIgYnl0ZXNcIik7XG4gICAgICBpZiAoIXRsdlszXT8uWzBdKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIFRMViAzIGZvciBuYWRkclwiKTtcbiAgICAgIGlmICh0bHZbM11bMF0ubGVuZ3RoICE9PSA0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUTFYgMyBzaG91bGQgYmUgNCBieXRlc1wiKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwibmFkZHJcIixcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGlkZW50aWZpZXI6IHV0ZjhEZWNvZGVyLmRlY29kZSh0bHZbMF1bMF0pLFxuICAgICAgICAgIHB1YmtleTogYnl0ZXNUb0hleDIodGx2WzJdWzBdKSxcbiAgICAgICAgICBraW5kOiBwYXJzZUludChieXRlc1RvSGV4Mih0bHZbM11bMF0pLCAxNiksXG4gICAgICAgICAgcmVsYXlzOiB0bHZbMV0gPyB0bHZbMV0ubWFwKChkKSA9PiB1dGY4RGVjb2Rlci5kZWNvZGUoZCkpIDogW11cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBcIm5zZWNcIjpcbiAgICAgIHJldHVybiB7IHR5cGU6IHByZWZpeCwgZGF0YSB9O1xuICAgIGNhc2UgXCJucHViXCI6XG4gICAgY2FzZSBcIm5vdGVcIjpcbiAgICAgIHJldHVybiB7IHR5cGU6IHByZWZpeCwgZGF0YTogYnl0ZXNUb0hleDIoZGF0YSkgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIHByZWZpeCAke3ByZWZpeH1gKTtcbiAgfVxufVxuZnVuY3Rpb24gcGFyc2VUTFYoZGF0YSkge1xuICBsZXQgcmVzdWx0ID0ge307XG4gIGxldCByZXN0ID0gZGF0YTtcbiAgd2hpbGUgKHJlc3QubGVuZ3RoID4gMCkge1xuICAgIGxldCB0ID0gcmVzdFswXTtcbiAgICBsZXQgbCA9IHJlc3RbMV07XG4gICAgbGV0IHYgPSByZXN0LnNsaWNlKDIsIDIgKyBsKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZSgyICsgbCk7XG4gICAgaWYgKHYubGVuZ3RoIDwgbClcbiAgICAgIHRocm93IG5ldyBFcnJvcihgbm90IGVub3VnaCBkYXRhIHRvIHJlYWQgb24gVExWICR7dH1gKTtcbiAgICByZXN1bHRbdF0gPSByZXN1bHRbdF0gfHwgW107XG4gICAgcmVzdWx0W3RdLnB1c2godik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG5zZWNFbmNvZGUoa2V5KSB7XG4gIHJldHVybiBlbmNvZGVCeXRlcyhcIm5zZWNcIiwga2V5KTtcbn1cbmZ1bmN0aW9uIG5wdWJFbmNvZGUoaGV4KSB7XG4gIHJldHVybiBlbmNvZGVCeXRlcyhcIm5wdWJcIiwgaGV4VG9CeXRlcyhoZXgpKTtcbn1cbmZ1bmN0aW9uIG5vdGVFbmNvZGUoaGV4KSB7XG4gIHJldHVybiBlbmNvZGVCeXRlcyhcIm5vdGVcIiwgaGV4VG9CeXRlcyhoZXgpKTtcbn1cbmZ1bmN0aW9uIGVuY29kZUJlY2gzMihwcmVmaXgsIGRhdGEpIHtcbiAgbGV0IHdvcmRzID0gYmVjaDMyLnRvV29yZHMoZGF0YSk7XG4gIHJldHVybiBiZWNoMzIuZW5jb2RlKHByZWZpeCwgd29yZHMsIEJlY2gzMk1heFNpemUpO1xufVxuZnVuY3Rpb24gZW5jb2RlQnl0ZXMocHJlZml4LCBieXRlcykge1xuICByZXR1cm4gZW5jb2RlQmVjaDMyKHByZWZpeCwgYnl0ZXMpO1xufVxuZnVuY3Rpb24gbnByb2ZpbGVFbmNvZGUocHJvZmlsZSkge1xuICBsZXQgZGF0YSA9IGVuY29kZVRMVih7XG4gICAgMDogW2hleFRvQnl0ZXMocHJvZmlsZS5wdWJrZXkpXSxcbiAgICAxOiAocHJvZmlsZS5yZWxheXMgfHwgW10pLm1hcCgodXJsKSA9PiB1dGY4RW5jb2Rlci5lbmNvZGUodXJsKSlcbiAgfSk7XG4gIHJldHVybiBlbmNvZGVCZWNoMzIoXCJucHJvZmlsZVwiLCBkYXRhKTtcbn1cbmZ1bmN0aW9uIG5ldmVudEVuY29kZShldmVudCkge1xuICBsZXQga2luZEFycmF5O1xuICBpZiAoZXZlbnQua2luZCAhPT0gdm9pZCAwKSB7XG4gICAga2luZEFycmF5ID0gaW50ZWdlclRvVWludDhBcnJheShldmVudC5raW5kKTtcbiAgfVxuICBsZXQgZGF0YSA9IGVuY29kZVRMVih7XG4gICAgMDogW2hleFRvQnl0ZXMoZXZlbnQuaWQpXSxcbiAgICAxOiAoZXZlbnQucmVsYXlzIHx8IFtdKS5tYXAoKHVybCkgPT4gdXRmOEVuY29kZXIuZW5jb2RlKHVybCkpLFxuICAgIDI6IGV2ZW50LmF1dGhvciA/IFtoZXhUb0J5dGVzKGV2ZW50LmF1dGhvcildIDogW10sXG4gICAgMzoga2luZEFycmF5ID8gW25ldyBVaW50OEFycmF5KGtpbmRBcnJheSldIDogW11cbiAgfSk7XG4gIHJldHVybiBlbmNvZGVCZWNoMzIoXCJuZXZlbnRcIiwgZGF0YSk7XG59XG5mdW5jdGlvbiBuYWRkckVuY29kZShhZGRyKSB7XG4gIGxldCBraW5kID0gbmV3IEFycmF5QnVmZmVyKDQpO1xuICBuZXcgRGF0YVZpZXcoa2luZCkuc2V0VWludDMyKDAsIGFkZHIua2luZCwgZmFsc2UpO1xuICBsZXQgZGF0YSA9IGVuY29kZVRMVih7XG4gICAgMDogW3V0ZjhFbmNvZGVyLmVuY29kZShhZGRyLmlkZW50aWZpZXIpXSxcbiAgICAxOiAoYWRkci5yZWxheXMgfHwgW10pLm1hcCgodXJsKSA9PiB1dGY4RW5jb2Rlci5lbmNvZGUodXJsKSksXG4gICAgMjogW2hleFRvQnl0ZXMoYWRkci5wdWJrZXkpXSxcbiAgICAzOiBbbmV3IFVpbnQ4QXJyYXkoa2luZCldXG4gIH0pO1xuICByZXR1cm4gZW5jb2RlQmVjaDMyKFwibmFkZHJcIiwgZGF0YSk7XG59XG5mdW5jdGlvbiBlbmNvZGVUTFYodGx2KSB7XG4gIGxldCBlbnRyaWVzID0gW107XG4gIE9iamVjdC5lbnRyaWVzKHRsdikucmV2ZXJzZSgpLmZvckVhY2goKFt0LCB2c10pID0+IHtcbiAgICB2cy5mb3JFYWNoKCh2KSA9PiB7XG4gICAgICBsZXQgZW50cnkgPSBuZXcgVWludDhBcnJheSh2Lmxlbmd0aCArIDIpO1xuICAgICAgZW50cnkuc2V0KFtwYXJzZUludCh0KV0sIDApO1xuICAgICAgZW50cnkuc2V0KFt2Lmxlbmd0aF0sIDEpO1xuICAgICAgZW50cnkuc2V0KHYsIDIpO1xuICAgICAgZW50cmllcy5wdXNoKGVudHJ5KTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBjb25jYXRCeXRlcyguLi5lbnRyaWVzKTtcbn1cblxuLy8gcmVmZXJlbmNlcy50c1xudmFyIG1lbnRpb25SZWdleCA9IC9cXGJub3N0cjooKG5vdGV8bnB1YnxuYWRkcnxuZXZlbnR8bnByb2ZpbGUpMVxcdyspXFxifCNcXFsoXFxkKylcXF0vZztcbmZ1bmN0aW9uIHBhcnNlUmVmZXJlbmNlcyhldnQpIHtcbiAgbGV0IHJlZmVyZW5jZXMgPSBbXTtcbiAgZm9yIChsZXQgcmVmIG9mIGV2dC5jb250ZW50Lm1hdGNoQWxsKG1lbnRpb25SZWdleCkpIHtcbiAgICBpZiAocmVmWzJdKSB7XG4gICAgICB0cnkge1xuICAgICAgICBsZXQgeyB0eXBlLCBkYXRhIH0gPSBkZWNvZGUocmVmWzFdKTtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBcIm5wdWJcIjoge1xuICAgICAgICAgICAgcmVmZXJlbmNlcy5wdXNoKHtcbiAgICAgICAgICAgICAgdGV4dDogcmVmWzBdLFxuICAgICAgICAgICAgICBwcm9maWxlOiB7IHB1YmtleTogZGF0YSwgcmVsYXlzOiBbXSB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwibnByb2ZpbGVcIjoge1xuICAgICAgICAgICAgcmVmZXJlbmNlcy5wdXNoKHtcbiAgICAgICAgICAgICAgdGV4dDogcmVmWzBdLFxuICAgICAgICAgICAgICBwcm9maWxlOiBkYXRhXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwibm90ZVwiOiB7XG4gICAgICAgICAgICByZWZlcmVuY2VzLnB1c2goe1xuICAgICAgICAgICAgICB0ZXh0OiByZWZbMF0sXG4gICAgICAgICAgICAgIGV2ZW50OiB7IGlkOiBkYXRhLCByZWxheXM6IFtdIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJuZXZlbnRcIjoge1xuICAgICAgICAgICAgcmVmZXJlbmNlcy5wdXNoKHtcbiAgICAgICAgICAgICAgdGV4dDogcmVmWzBdLFxuICAgICAgICAgICAgICBldmVudDogZGF0YVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIm5hZGRyXCI6IHtcbiAgICAgICAgICAgIHJlZmVyZW5jZXMucHVzaCh7XG4gICAgICAgICAgICAgIHRleHQ6IHJlZlswXSxcbiAgICAgICAgICAgICAgYWRkcmVzczogZGF0YVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocmVmWzNdKSB7XG4gICAgICBsZXQgaWR4ID0gcGFyc2VJbnQocmVmWzNdLCAxMCk7XG4gICAgICBsZXQgdGFnID0gZXZ0LnRhZ3NbaWR4XTtcbiAgICAgIGlmICghdGFnKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHN3aXRjaCAodGFnWzBdKSB7XG4gICAgICAgIGNhc2UgXCJwXCI6IHtcbiAgICAgICAgICByZWZlcmVuY2VzLnB1c2goe1xuICAgICAgICAgICAgdGV4dDogcmVmWzBdLFxuICAgICAgICAgICAgcHJvZmlsZTogeyBwdWJrZXk6IHRhZ1sxXSwgcmVsYXlzOiB0YWdbMl0gPyBbdGFnWzJdXSA6IFtdIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiZVwiOiB7XG4gICAgICAgICAgcmVmZXJlbmNlcy5wdXNoKHtcbiAgICAgICAgICAgIHRleHQ6IHJlZlswXSxcbiAgICAgICAgICAgIGV2ZW50OiB7IGlkOiB0YWdbMV0sIHJlbGF5czogdGFnWzJdID8gW3RhZ1syXV0gOiBbXSB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImFcIjoge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgW2tpbmQsIHB1YmtleSwgaWRlbnRpZmllcl0gPSB0YWdbMV0uc3BsaXQoXCI6XCIpO1xuICAgICAgICAgICAgcmVmZXJlbmNlcy5wdXNoKHtcbiAgICAgICAgICAgICAgdGV4dDogcmVmWzBdLFxuICAgICAgICAgICAgICBhZGRyZXNzOiB7XG4gICAgICAgICAgICAgICAgaWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICBwdWJrZXksXG4gICAgICAgICAgICAgICAga2luZDogcGFyc2VJbnQoa2luZCwgMTApLFxuICAgICAgICAgICAgICAgIHJlbGF5czogdGFnWzJdID8gW3RhZ1syXV0gOiBbXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlZmVyZW5jZXM7XG59XG5cbi8vIG5pcDA0LnRzXG52YXIgbmlwMDRfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobmlwMDRfZXhwb3J0cywge1xuICBkZWNyeXB0OiAoKSA9PiBkZWNyeXB0LFxuICBlbmNyeXB0OiAoKSA9PiBlbmNyeXB0XG59KTtcbmltcG9ydCB7IGJ5dGVzVG9IZXggYXMgYnl0ZXNUb0hleDMsIHJhbmRvbUJ5dGVzIH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvdXRpbHNcIjtcbmltcG9ydCB7IHNlY3AyNTZrMSB9IGZyb20gXCJAbm9ibGUvY3VydmVzL3NlY3AyNTZrMVwiO1xuaW1wb3J0IHsgY2JjIH0gZnJvbSBcIkBub2JsZS9jaXBoZXJzL2Flc1wiO1xuaW1wb3J0IHsgYmFzZTY0IH0gZnJvbSBcIkBzY3VyZS9iYXNlXCI7XG5hc3luYyBmdW5jdGlvbiBlbmNyeXB0KHNlY3JldEtleSwgcHVia2V5LCB0ZXh0KSB7XG4gIGNvbnN0IHByaXZrZXkgPSBzZWNyZXRLZXkgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gYnl0ZXNUb0hleDMoc2VjcmV0S2V5KSA6IHNlY3JldEtleTtcbiAgY29uc3Qga2V5ID0gc2VjcDI1NmsxLmdldFNoYXJlZFNlY3JldChwcml2a2V5LCBcIjAyXCIgKyBwdWJrZXkpO1xuICBjb25zdCBub3JtYWxpemVkS2V5ID0gZ2V0Tm9ybWFsaXplZFgoa2V5KTtcbiAgbGV0IGl2ID0gVWludDhBcnJheS5mcm9tKHJhbmRvbUJ5dGVzKDE2KSk7XG4gIGxldCBwbGFpbnRleHQgPSB1dGY4RW5jb2Rlci5lbmNvZGUodGV4dCk7XG4gIGxldCBjaXBoZXJ0ZXh0ID0gY2JjKG5vcm1hbGl6ZWRLZXksIGl2KS5lbmNyeXB0KHBsYWludGV4dCk7XG4gIGxldCBjdGI2NCA9IGJhc2U2NC5lbmNvZGUobmV3IFVpbnQ4QXJyYXkoY2lwaGVydGV4dCkpO1xuICBsZXQgaXZiNjQgPSBiYXNlNjQuZW5jb2RlKG5ldyBVaW50OEFycmF5KGl2LmJ1ZmZlcikpO1xuICByZXR1cm4gYCR7Y3RiNjR9P2l2PSR7aXZiNjR9YDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGRlY3J5cHQoc2VjcmV0S2V5LCBwdWJrZXksIGRhdGEpIHtcbiAgY29uc3QgcHJpdmtleSA9IHNlY3JldEtleSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyBieXRlc1RvSGV4MyhzZWNyZXRLZXkpIDogc2VjcmV0S2V5O1xuICBsZXQgW2N0YjY0LCBpdmI2NF0gPSBkYXRhLnNwbGl0KFwiP2l2PVwiKTtcbiAgbGV0IGtleSA9IHNlY3AyNTZrMS5nZXRTaGFyZWRTZWNyZXQocHJpdmtleSwgXCIwMlwiICsgcHVia2V5KTtcbiAgbGV0IG5vcm1hbGl6ZWRLZXkgPSBnZXROb3JtYWxpemVkWChrZXkpO1xuICBsZXQgaXYgPSBiYXNlNjQuZGVjb2RlKGl2YjY0KTtcbiAgbGV0IGNpcGhlcnRleHQgPSBiYXNlNjQuZGVjb2RlKGN0YjY0KTtcbiAgbGV0IHBsYWludGV4dCA9IGNiYyhub3JtYWxpemVkS2V5LCBpdikuZGVjcnlwdChjaXBoZXJ0ZXh0KTtcbiAgcmV0dXJuIHV0ZjhEZWNvZGVyLmRlY29kZShwbGFpbnRleHQpO1xufVxuZnVuY3Rpb24gZ2V0Tm9ybWFsaXplZFgoa2V5KSB7XG4gIHJldHVybiBrZXkuc2xpY2UoMSwgMzMpO1xufVxuXG4vLyBuaXAwNS50c1xudmFyIG5pcDA1X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDA1X2V4cG9ydHMsIHtcbiAgTklQMDVfUkVHRVg6ICgpID0+IE5JUDA1X1JFR0VYLFxuICBpc05pcDA1OiAoKSA9PiBpc05pcDA1LFxuICBpc1ZhbGlkOiAoKSA9PiBpc1ZhbGlkLFxuICBxdWVyeVByb2ZpbGU6ICgpID0+IHF1ZXJ5UHJvZmlsZSxcbiAgc2VhcmNoRG9tYWluOiAoKSA9PiBzZWFyY2hEb21haW4sXG4gIHVzZUZldGNoSW1wbGVtZW50YXRpb246ICgpID0+IHVzZUZldGNoSW1wbGVtZW50YXRpb25cbn0pO1xudmFyIE5JUDA1X1JFR0VYID0gL14oPzooW1xcdy4rLV0rKUApPyhbXFx3Xy1dKyhcXC5bXFx3Xy1dKykrKSQvO1xudmFyIGlzTmlwMDUgPSAodmFsdWUpID0+IE5JUDA1X1JFR0VYLnRlc3QodmFsdWUgfHwgXCJcIik7XG52YXIgX2ZldGNoO1xudHJ5IHtcbiAgX2ZldGNoID0gZmV0Y2g7XG59IGNhdGNoIChfKSB7XG4gIG51bGw7XG59XG5mdW5jdGlvbiB1c2VGZXRjaEltcGxlbWVudGF0aW9uKGZldGNoSW1wbGVtZW50YXRpb24pIHtcbiAgX2ZldGNoID0gZmV0Y2hJbXBsZW1lbnRhdGlvbjtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNlYXJjaERvbWFpbihkb21haW4sIHF1ZXJ5ID0gXCJcIikge1xuICB0cnkge1xuICAgIGNvbnN0IHVybCA9IGBodHRwczovLyR7ZG9tYWlufS8ud2VsbC1rbm93bi9ub3N0ci5qc29uP25hbWU9JHtxdWVyeX1gO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IF9mZXRjaCh1cmwsIHsgcmVkaXJlY3Q6IFwibWFudWFsXCIgfSk7XG4gICAgaWYgKHJlcy5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgdGhyb3cgRXJyb3IoXCJXcm9uZyByZXNwb25zZSBjb2RlXCIpO1xuICAgIH1cbiAgICBjb25zdCBqc29uID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICByZXR1cm4ganNvbi5uYW1lcztcbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiB7fTtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gcXVlcnlQcm9maWxlKGZ1bGxuYW1lKSB7XG4gIGNvbnN0IG1hdGNoID0gZnVsbG5hbWUubWF0Y2goTklQMDVfUkVHRVgpO1xuICBpZiAoIW1hdGNoKVxuICAgIHJldHVybiBudWxsO1xuICBjb25zdCBbLCBuYW1lID0gXCJfXCIsIGRvbWFpbl0gPSBtYXRjaDtcbiAgdHJ5IHtcbiAgICBjb25zdCB1cmwgPSBgaHR0cHM6Ly8ke2RvbWFpbn0vLndlbGwta25vd24vbm9zdHIuanNvbj9uYW1lPSR7bmFtZX1gO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IF9mZXRjaCh1cmwsIHsgcmVkaXJlY3Q6IFwibWFudWFsXCIgfSk7XG4gICAgaWYgKHJlcy5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgdGhyb3cgRXJyb3IoXCJXcm9uZyByZXNwb25zZSBjb2RlXCIpO1xuICAgIH1cbiAgICBjb25zdCBqc29uID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICBjb25zdCBwdWJrZXkgPSBqc29uLm5hbWVzW25hbWVdO1xuICAgIHJldHVybiBwdWJrZXkgPyB7IHB1YmtleSwgcmVsYXlzOiBqc29uLnJlbGF5cz8uW3B1YmtleV0gfSA6IG51bGw7XG4gIH0gY2F0Y2ggKF9lKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGlzVmFsaWQocHVia2V5LCBuaXAwNSkge1xuICBjb25zdCByZXMgPSBhd2FpdCBxdWVyeVByb2ZpbGUobmlwMDUpO1xuICByZXR1cm4gcmVzID8gcmVzLnB1YmtleSA9PT0gcHVia2V5IDogZmFsc2U7XG59XG5cbi8vIG5pcDEwLnRzXG52YXIgbmlwMTBfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobmlwMTBfZXhwb3J0cywge1xuICBwYXJzZTogKCkgPT4gcGFyc2Vcbn0pO1xuZnVuY3Rpb24gcGFyc2UoZXZlbnQpIHtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIHJlcGx5OiB2b2lkIDAsXG4gICAgcm9vdDogdm9pZCAwLFxuICAgIG1lbnRpb25zOiBbXSxcbiAgICBwcm9maWxlczogW10sXG4gICAgcXVvdGVzOiBbXVxuICB9O1xuICBsZXQgbWF5YmVQYXJlbnQ7XG4gIGxldCBtYXliZVJvb3Q7XG4gIGZvciAobGV0IGkyID0gZXZlbnQudGFncy5sZW5ndGggLSAxOyBpMiA+PSAwOyBpMi0tKSB7XG4gICAgY29uc3QgdGFnID0gZXZlbnQudGFnc1tpMl07XG4gICAgaWYgKHRhZ1swXSA9PT0gXCJlXCIgJiYgdGFnWzFdKSB7XG4gICAgICBjb25zdCBbXywgZVRhZ0V2ZW50SWQsIGVUYWdSZWxheVVybCwgZVRhZ01hcmtlciwgZVRhZ0F1dGhvcl0gPSB0YWc7XG4gICAgICBjb25zdCBldmVudFBvaW50ZXIgPSB7XG4gICAgICAgIGlkOiBlVGFnRXZlbnRJZCxcbiAgICAgICAgcmVsYXlzOiBlVGFnUmVsYXlVcmwgPyBbZVRhZ1JlbGF5VXJsXSA6IFtdLFxuICAgICAgICBhdXRob3I6IGVUYWdBdXRob3JcbiAgICAgIH07XG4gICAgICBpZiAoZVRhZ01hcmtlciA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgcmVzdWx0LnJvb3QgPSBldmVudFBvaW50ZXI7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGVUYWdNYXJrZXIgPT09IFwicmVwbHlcIikge1xuICAgICAgICByZXN1bHQucmVwbHkgPSBldmVudFBvaW50ZXI7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGVUYWdNYXJrZXIgPT09IFwibWVudGlvblwiKSB7XG4gICAgICAgIHJlc3VsdC5tZW50aW9ucy5wdXNoKGV2ZW50UG9pbnRlcik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFtYXliZVBhcmVudCkge1xuICAgICAgICBtYXliZVBhcmVudCA9IGV2ZW50UG9pbnRlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1heWJlUm9vdCA9IGV2ZW50UG9pbnRlcjtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5tZW50aW9ucy5wdXNoKGV2ZW50UG9pbnRlcik7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHRhZ1swXSA9PT0gXCJxXCIgJiYgdGFnWzFdKSB7XG4gICAgICBjb25zdCBbXywgZVRhZ0V2ZW50SWQsIGVUYWdSZWxheVVybF0gPSB0YWc7XG4gICAgICByZXN1bHQucXVvdGVzLnB1c2goe1xuICAgICAgICBpZDogZVRhZ0V2ZW50SWQsXG4gICAgICAgIHJlbGF5czogZVRhZ1JlbGF5VXJsID8gW2VUYWdSZWxheVVybF0gOiBbXVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0YWdbMF0gPT09IFwicFwiICYmIHRhZ1sxXSkge1xuICAgICAgcmVzdWx0LnByb2ZpbGVzLnB1c2goe1xuICAgICAgICBwdWJrZXk6IHRhZ1sxXSxcbiAgICAgICAgcmVsYXlzOiB0YWdbMl0gPyBbdGFnWzJdXSA6IFtdXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgfVxuICBpZiAoIXJlc3VsdC5yb290KSB7XG4gICAgcmVzdWx0LnJvb3QgPSBtYXliZVJvb3QgfHwgbWF5YmVQYXJlbnQgfHwgcmVzdWx0LnJlcGx5O1xuICB9XG4gIGlmICghcmVzdWx0LnJlcGx5KSB7XG4gICAgcmVzdWx0LnJlcGx5ID0gbWF5YmVQYXJlbnQgfHwgcmVzdWx0LnJvb3Q7XG4gIH1cbiAgO1xuICBbcmVzdWx0LnJlcGx5LCByZXN1bHQucm9vdF0uZm9yRWFjaCgocmVmKSA9PiB7XG4gICAgaWYgKCFyZWYpXG4gICAgICByZXR1cm47XG4gICAgbGV0IGlkeCA9IHJlc3VsdC5tZW50aW9ucy5pbmRleE9mKHJlZik7XG4gICAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICAgIHJlc3VsdC5tZW50aW9ucy5zcGxpY2UoaWR4LCAxKTtcbiAgICB9XG4gICAgaWYgKHJlZi5hdXRob3IpIHtcbiAgICAgIGxldCBhdXRob3IgPSByZXN1bHQucHJvZmlsZXMuZmluZCgocCkgPT4gcC5wdWJrZXkgPT09IHJlZi5hdXRob3IpO1xuICAgICAgaWYgKGF1dGhvciAmJiBhdXRob3IucmVsYXlzKSB7XG4gICAgICAgIGlmICghcmVmLnJlbGF5cykge1xuICAgICAgICAgIHJlZi5yZWxheXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBhdXRob3IucmVsYXlzLmZvckVhY2goKHVybCkgPT4ge1xuICAgICAgICAgIGlmIChyZWYucmVsYXlzPy5pbmRleE9mKHVybCkgPT09IC0xKVxuICAgICAgICAgICAgcmVmLnJlbGF5cy5wdXNoKHVybCk7XG4gICAgICAgIH0pO1xuICAgICAgICBhdXRob3IucmVsYXlzID0gcmVmLnJlbGF5cztcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXN1bHQubWVudGlvbnMuZm9yRWFjaCgocmVmKSA9PiB7XG4gICAgaWYgKHJlZi5hdXRob3IpIHtcbiAgICAgIGxldCBhdXRob3IgPSByZXN1bHQucHJvZmlsZXMuZmluZCgocCkgPT4gcC5wdWJrZXkgPT09IHJlZi5hdXRob3IpO1xuICAgICAgaWYgKGF1dGhvciAmJiBhdXRob3IucmVsYXlzKSB7XG4gICAgICAgIGlmICghcmVmLnJlbGF5cykge1xuICAgICAgICAgIHJlZi5yZWxheXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBhdXRob3IucmVsYXlzLmZvckVhY2goKHVybCkgPT4ge1xuICAgICAgICAgIGlmIChyZWYucmVsYXlzLmluZGV4T2YodXJsKSA9PT0gLTEpXG4gICAgICAgICAgICByZWYucmVsYXlzLnB1c2godXJsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGF1dGhvci5yZWxheXMgPSByZWYucmVsYXlzO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIG5pcDExLnRzXG52YXIgbmlwMTFfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobmlwMTFfZXhwb3J0cywge1xuICBmZXRjaFJlbGF5SW5mb3JtYXRpb246ICgpID0+IGZldGNoUmVsYXlJbmZvcm1hdGlvbixcbiAgdXNlRmV0Y2hJbXBsZW1lbnRhdGlvbjogKCkgPT4gdXNlRmV0Y2hJbXBsZW1lbnRhdGlvbjJcbn0pO1xudmFyIF9mZXRjaDI7XG50cnkge1xuICBfZmV0Y2gyID0gZmV0Y2g7XG59IGNhdGNoIHtcbn1cbmZ1bmN0aW9uIHVzZUZldGNoSW1wbGVtZW50YXRpb24yKGZldGNoSW1wbGVtZW50YXRpb24pIHtcbiAgX2ZldGNoMiA9IGZldGNoSW1wbGVtZW50YXRpb247XG59XG5hc3luYyBmdW5jdGlvbiBmZXRjaFJlbGF5SW5mb3JtYXRpb24odXJsKSB7XG4gIHJldHVybiBhd2FpdCAoYXdhaXQgZmV0Y2godXJsLnJlcGxhY2UoXCJ3czovL1wiLCBcImh0dHA6Ly9cIikucmVwbGFjZShcIndzczovL1wiLCBcImh0dHBzOi8vXCIpLCB7XG4gICAgaGVhZGVyczogeyBBY2NlcHQ6IFwiYXBwbGljYXRpb24vbm9zdHIranNvblwiIH1cbiAgfSkpLmpzb24oKTtcbn1cblxuLy8gbmlwMTMudHNcbnZhciBuaXAxM19leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXAxM19leHBvcnRzLCB7XG4gIGZhc3RFdmVudEhhc2g6ICgpID0+IGZhc3RFdmVudEhhc2gsXG4gIGdldFBvdzogKCkgPT4gZ2V0UG93LFxuICBtaW5lUG93OiAoKSA9PiBtaW5lUG93XG59KTtcbmltcG9ydCB7IGJ5dGVzVG9IZXggYXMgYnl0ZXNUb0hleDQgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy91dGlsc1wiO1xuaW1wb3J0IHsgc2hhMjU2IGFzIHNoYTI1NjIgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy9zaGEyNTZcIjtcbmZ1bmN0aW9uIGdldFBvdyhoZXgpIHtcbiAgbGV0IGNvdW50ID0gMDtcbiAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IDY0OyBpMiArPSA4KSB7XG4gICAgY29uc3QgbmliYmxlID0gcGFyc2VJbnQoaGV4LnN1YnN0cmluZyhpMiwgaTIgKyA4KSwgMTYpO1xuICAgIGlmIChuaWJibGUgPT09IDApIHtcbiAgICAgIGNvdW50ICs9IDMyO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb3VudCArPSBNYXRoLmNsejMyKG5pYmJsZSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvdW50O1xufVxuZnVuY3Rpb24gbWluZVBvdyh1bnNpZ25lZCwgZGlmZmljdWx0eSkge1xuICBsZXQgY291bnQgPSAwO1xuICBjb25zdCBldmVudCA9IHVuc2lnbmVkO1xuICBjb25zdCB0YWcgPSBbXCJub25jZVwiLCBjb3VudC50b1N0cmluZygpLCBkaWZmaWN1bHR5LnRvU3RyaW5nKCldO1xuICBldmVudC50YWdzLnB1c2godGFnKTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCBub3cyID0gTWF0aC5mbG9vcihuZXcgRGF0ZSgpLmdldFRpbWUoKSAvIDFlMyk7XG4gICAgaWYgKG5vdzIgIT09IGV2ZW50LmNyZWF0ZWRfYXQpIHtcbiAgICAgIGNvdW50ID0gMDtcbiAgICAgIGV2ZW50LmNyZWF0ZWRfYXQgPSBub3cyO1xuICAgIH1cbiAgICB0YWdbMV0gPSAoKytjb3VudCkudG9TdHJpbmcoKTtcbiAgICBldmVudC5pZCA9IGZhc3RFdmVudEhhc2goZXZlbnQpO1xuICAgIGlmIChnZXRQb3coZXZlbnQuaWQpID49IGRpZmZpY3VsdHkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZXZlbnQ7XG59XG5mdW5jdGlvbiBmYXN0RXZlbnRIYXNoKGV2dCkge1xuICByZXR1cm4gYnl0ZXNUb0hleDQoXG4gICAgc2hhMjU2Mih1dGY4RW5jb2Rlci5lbmNvZGUoSlNPTi5zdHJpbmdpZnkoWzAsIGV2dC5wdWJrZXksIGV2dC5jcmVhdGVkX2F0LCBldnQua2luZCwgZXZ0LnRhZ3MsIGV2dC5jb250ZW50XSkpKVxuICApO1xufVxuXG4vLyBuaXAxOC50c1xudmFyIG5pcDE4X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDE4X2V4cG9ydHMsIHtcbiAgZmluaXNoUmVwb3N0RXZlbnQ6ICgpID0+IGZpbmlzaFJlcG9zdEV2ZW50LFxuICBnZXRSZXBvc3RlZEV2ZW50OiAoKSA9PiBnZXRSZXBvc3RlZEV2ZW50LFxuICBnZXRSZXBvc3RlZEV2ZW50UG9pbnRlcjogKCkgPT4gZ2V0UmVwb3N0ZWRFdmVudFBvaW50ZXJcbn0pO1xuZnVuY3Rpb24gZmluaXNoUmVwb3N0RXZlbnQodCwgcmVwb3N0ZWQsIHJlbGF5VXJsLCBwcml2YXRlS2V5KSB7XG4gIHJldHVybiBmaW5hbGl6ZUV2ZW50KFxuICAgIHtcbiAgICAgIGtpbmQ6IFJlcG9zdCxcbiAgICAgIHRhZ3M6IFsuLi50LnRhZ3MgPz8gW10sIFtcImVcIiwgcmVwb3N0ZWQuaWQsIHJlbGF5VXJsXSwgW1wicFwiLCByZXBvc3RlZC5wdWJrZXldXSxcbiAgICAgIGNvbnRlbnQ6IHQuY29udGVudCA9PT0gXCJcIiA/IFwiXCIgOiBKU09OLnN0cmluZ2lmeShyZXBvc3RlZCksXG4gICAgICBjcmVhdGVkX2F0OiB0LmNyZWF0ZWRfYXRcbiAgICB9LFxuICAgIHByaXZhdGVLZXlcbiAgKTtcbn1cbmZ1bmN0aW9uIGdldFJlcG9zdGVkRXZlbnRQb2ludGVyKGV2ZW50KSB7XG4gIGlmIChldmVudC5raW5kICE9PSBSZXBvc3QpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGxldCBsYXN0RVRhZztcbiAgbGV0IGxhc3RQVGFnO1xuICBmb3IgKGxldCBpMiA9IGV2ZW50LnRhZ3MubGVuZ3RoIC0gMTsgaTIgPj0gMCAmJiAobGFzdEVUYWcgPT09IHZvaWQgMCB8fCBsYXN0UFRhZyA9PT0gdm9pZCAwKTsgaTItLSkge1xuICAgIGNvbnN0IHRhZyA9IGV2ZW50LnRhZ3NbaTJdO1xuICAgIGlmICh0YWcubGVuZ3RoID49IDIpIHtcbiAgICAgIGlmICh0YWdbMF0gPT09IFwiZVwiICYmIGxhc3RFVGFnID09PSB2b2lkIDApIHtcbiAgICAgICAgbGFzdEVUYWcgPSB0YWc7XG4gICAgICB9IGVsc2UgaWYgKHRhZ1swXSA9PT0gXCJwXCIgJiYgbGFzdFBUYWcgPT09IHZvaWQgMCkge1xuICAgICAgICBsYXN0UFRhZyA9IHRhZztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGxhc3RFVGFnID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHJldHVybiB7XG4gICAgaWQ6IGxhc3RFVGFnWzFdLFxuICAgIHJlbGF5czogW2xhc3RFVGFnWzJdLCBsYXN0UFRhZz8uWzJdXS5maWx0ZXIoKHgpID0+IHR5cGVvZiB4ID09PSBcInN0cmluZ1wiKSxcbiAgICBhdXRob3I6IGxhc3RQVGFnPy5bMV1cbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFJlcG9zdGVkRXZlbnQoZXZlbnQsIHsgc2tpcFZlcmlmaWNhdGlvbiB9ID0ge30pIHtcbiAgY29uc3QgcG9pbnRlciA9IGdldFJlcG9zdGVkRXZlbnRQb2ludGVyKGV2ZW50KTtcbiAgaWYgKHBvaW50ZXIgPT09IHZvaWQgMCB8fCBldmVudC5jb250ZW50ID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBsZXQgcmVwb3N0ZWRFdmVudDtcbiAgdHJ5IHtcbiAgICByZXBvc3RlZEV2ZW50ID0gSlNPTi5wYXJzZShldmVudC5jb250ZW50KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGlmIChyZXBvc3RlZEV2ZW50LmlkICE9PSBwb2ludGVyLmlkKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBpZiAoIXNraXBWZXJpZmljYXRpb24gJiYgIXZlcmlmeUV2ZW50KHJlcG9zdGVkRXZlbnQpKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4gcmVwb3N0ZWRFdmVudDtcbn1cblxuLy8gbmlwMjEudHNcbnZhciBuaXAyMV9leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXAyMV9leHBvcnRzLCB7XG4gIE5PU1RSX1VSSV9SRUdFWDogKCkgPT4gTk9TVFJfVVJJX1JFR0VYLFxuICBwYXJzZTogKCkgPT4gcGFyc2UyLFxuICB0ZXN0OiAoKSA9PiB0ZXN0XG59KTtcbnZhciBOT1NUUl9VUklfUkVHRVggPSBuZXcgUmVnRXhwKGBub3N0cjooJHtCRUNIMzJfUkVHRVguc291cmNlfSlgKTtcbmZ1bmN0aW9uIHRlc3QodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiBuZXcgUmVnRXhwKGBeJHtOT1NUUl9VUklfUkVHRVguc291cmNlfSRgKS50ZXN0KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHBhcnNlMih1cmkpIHtcbiAgY29uc3QgbWF0Y2ggPSB1cmkubWF0Y2gobmV3IFJlZ0V4cChgXiR7Tk9TVFJfVVJJX1JFR0VYLnNvdXJjZX0kYCkpO1xuICBpZiAoIW1hdGNoKVxuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBOb3N0ciBVUkk6ICR7dXJpfWApO1xuICByZXR1cm4ge1xuICAgIHVyaTogbWF0Y2hbMF0sXG4gICAgdmFsdWU6IG1hdGNoWzFdLFxuICAgIGRlY29kZWQ6IGRlY29kZShtYXRjaFsxXSlcbiAgfTtcbn1cblxuLy8gbmlwMjUudHNcbnZhciBuaXAyNV9leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXAyNV9leHBvcnRzLCB7XG4gIGZpbmlzaFJlYWN0aW9uRXZlbnQ6ICgpID0+IGZpbmlzaFJlYWN0aW9uRXZlbnQsXG4gIGdldFJlYWN0ZWRFdmVudFBvaW50ZXI6ICgpID0+IGdldFJlYWN0ZWRFdmVudFBvaW50ZXJcbn0pO1xuZnVuY3Rpb24gZmluaXNoUmVhY3Rpb25FdmVudCh0LCByZWFjdGVkLCBwcml2YXRlS2V5KSB7XG4gIGNvbnN0IGluaGVyaXRlZFRhZ3MgPSByZWFjdGVkLnRhZ3MuZmlsdGVyKCh0YWcpID0+IHRhZy5sZW5ndGggPj0gMiAmJiAodGFnWzBdID09PSBcImVcIiB8fCB0YWdbMF0gPT09IFwicFwiKSk7XG4gIHJldHVybiBmaW5hbGl6ZUV2ZW50KFxuICAgIHtcbiAgICAgIC4uLnQsXG4gICAgICBraW5kOiBSZWFjdGlvbixcbiAgICAgIHRhZ3M6IFsuLi50LnRhZ3MgPz8gW10sIC4uLmluaGVyaXRlZFRhZ3MsIFtcImVcIiwgcmVhY3RlZC5pZF0sIFtcInBcIiwgcmVhY3RlZC5wdWJrZXldXSxcbiAgICAgIGNvbnRlbnQ6IHQuY29udGVudCA/PyBcIitcIlxuICAgIH0sXG4gICAgcHJpdmF0ZUtleVxuICApO1xufVxuZnVuY3Rpb24gZ2V0UmVhY3RlZEV2ZW50UG9pbnRlcihldmVudCkge1xuICBpZiAoZXZlbnQua2luZCAhPT0gUmVhY3Rpb24pIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGxldCBsYXN0RVRhZztcbiAgbGV0IGxhc3RQVGFnO1xuICBmb3IgKGxldCBpMiA9IGV2ZW50LnRhZ3MubGVuZ3RoIC0gMTsgaTIgPj0gMCAmJiAobGFzdEVUYWcgPT09IHZvaWQgMCB8fCBsYXN0UFRhZyA9PT0gdm9pZCAwKTsgaTItLSkge1xuICAgIGNvbnN0IHRhZyA9IGV2ZW50LnRhZ3NbaTJdO1xuICAgIGlmICh0YWcubGVuZ3RoID49IDIpIHtcbiAgICAgIGlmICh0YWdbMF0gPT09IFwiZVwiICYmIGxhc3RFVGFnID09PSB2b2lkIDApIHtcbiAgICAgICAgbGFzdEVUYWcgPSB0YWc7XG4gICAgICB9IGVsc2UgaWYgKHRhZ1swXSA9PT0gXCJwXCIgJiYgbGFzdFBUYWcgPT09IHZvaWQgMCkge1xuICAgICAgICBsYXN0UFRhZyA9IHRhZztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGxhc3RFVGFnID09PSB2b2lkIDAgfHwgbGFzdFBUYWcgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBpZDogbGFzdEVUYWdbMV0sXG4gICAgcmVsYXlzOiBbbGFzdEVUYWdbMl0sIGxhc3RQVGFnWzJdXS5maWx0ZXIoKHgpID0+IHggIT09IHZvaWQgMCksXG4gICAgYXV0aG9yOiBsYXN0UFRhZ1sxXVxuICB9O1xufVxuXG4vLyBuaXAyNy50c1xudmFyIG5pcDI3X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDI3X2V4cG9ydHMsIHtcbiAgbWF0Y2hBbGw6ICgpID0+IG1hdGNoQWxsLFxuICByZWdleDogKCkgPT4gcmVnZXgsXG4gIHJlcGxhY2VBbGw6ICgpID0+IHJlcGxhY2VBbGxcbn0pO1xudmFyIHJlZ2V4ID0gKCkgPT4gbmV3IFJlZ0V4cChgXFxcXGIke05PU1RSX1VSSV9SRUdFWC5zb3VyY2V9XFxcXGJgLCBcImdcIik7XG5mdW5jdGlvbiogbWF0Y2hBbGwoY29udGVudCkge1xuICBjb25zdCBtYXRjaGVzID0gY29udGVudC5tYXRjaEFsbChyZWdleCgpKTtcbiAgZm9yIChjb25zdCBtYXRjaCBvZiBtYXRjaGVzKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IFt1cmksIHZhbHVlXSA9IG1hdGNoO1xuICAgICAgeWllbGQge1xuICAgICAgICB1cmksXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBkZWNvZGVkOiBkZWNvZGUodmFsdWUpLFxuICAgICAgICBzdGFydDogbWF0Y2guaW5kZXgsXG4gICAgICAgIGVuZDogbWF0Y2guaW5kZXggKyB1cmkubGVuZ3RoXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKF9lKSB7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiByZXBsYWNlQWxsKGNvbnRlbnQsIHJlcGxhY2VyKSB7XG4gIHJldHVybiBjb250ZW50LnJlcGxhY2VBbGwocmVnZXgoKSwgKHVyaSwgdmFsdWUpID0+IHtcbiAgICByZXR1cm4gcmVwbGFjZXIoe1xuICAgICAgdXJpLFxuICAgICAgdmFsdWUsXG4gICAgICBkZWNvZGVkOiBkZWNvZGUodmFsdWUpXG4gICAgfSk7XG4gIH0pO1xufVxuXG4vLyBuaXAyOC50c1xudmFyIG5pcDI4X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDI4X2V4cG9ydHMsIHtcbiAgY2hhbm5lbENyZWF0ZUV2ZW50OiAoKSA9PiBjaGFubmVsQ3JlYXRlRXZlbnQsXG4gIGNoYW5uZWxIaWRlTWVzc2FnZUV2ZW50OiAoKSA9PiBjaGFubmVsSGlkZU1lc3NhZ2VFdmVudCxcbiAgY2hhbm5lbE1lc3NhZ2VFdmVudDogKCkgPT4gY2hhbm5lbE1lc3NhZ2VFdmVudCxcbiAgY2hhbm5lbE1ldGFkYXRhRXZlbnQ6ICgpID0+IGNoYW5uZWxNZXRhZGF0YUV2ZW50LFxuICBjaGFubmVsTXV0ZVVzZXJFdmVudDogKCkgPT4gY2hhbm5lbE11dGVVc2VyRXZlbnRcbn0pO1xudmFyIGNoYW5uZWxDcmVhdGVFdmVudCA9ICh0LCBwcml2YXRlS2V5KSA9PiB7XG4gIGxldCBjb250ZW50O1xuICBpZiAodHlwZW9mIHQuY29udGVudCA9PT0gXCJvYmplY3RcIikge1xuICAgIGNvbnRlbnQgPSBKU09OLnN0cmluZ2lmeSh0LmNvbnRlbnQpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB0LmNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICBjb250ZW50ID0gdC5jb250ZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIGZpbmFsaXplRXZlbnQoXG4gICAge1xuICAgICAga2luZDogQ2hhbm5lbENyZWF0aW9uLFxuICAgICAgdGFnczogWy4uLnQudGFncyA/PyBbXV0sXG4gICAgICBjb250ZW50LFxuICAgICAgY3JlYXRlZF9hdDogdC5jcmVhdGVkX2F0XG4gICAgfSxcbiAgICBwcml2YXRlS2V5XG4gICk7XG59O1xudmFyIGNoYW5uZWxNZXRhZGF0YUV2ZW50ID0gKHQsIHByaXZhdGVLZXkpID0+IHtcbiAgbGV0IGNvbnRlbnQ7XG4gIGlmICh0eXBlb2YgdC5jb250ZW50ID09PSBcIm9iamVjdFwiKSB7XG4gICAgY29udGVudCA9IEpTT04uc3RyaW5naWZ5KHQuY29udGVudCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHQuY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnRlbnQgPSB0LmNvbnRlbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4gZmluYWxpemVFdmVudChcbiAgICB7XG4gICAgICBraW5kOiBDaGFubmVsTWV0YWRhdGEsXG4gICAgICB0YWdzOiBbW1wiZVwiLCB0LmNoYW5uZWxfY3JlYXRlX2V2ZW50X2lkXSwgLi4udC50YWdzID8/IFtdXSxcbiAgICAgIGNvbnRlbnQsXG4gICAgICBjcmVhdGVkX2F0OiB0LmNyZWF0ZWRfYXRcbiAgICB9LFxuICAgIHByaXZhdGVLZXlcbiAgKTtcbn07XG52YXIgY2hhbm5lbE1lc3NhZ2VFdmVudCA9ICh0LCBwcml2YXRlS2V5KSA9PiB7XG4gIGNvbnN0IHRhZ3MgPSBbW1wiZVwiLCB0LmNoYW5uZWxfY3JlYXRlX2V2ZW50X2lkLCB0LnJlbGF5X3VybCwgXCJyb290XCJdXTtcbiAgaWYgKHQucmVwbHlfdG9fY2hhbm5lbF9tZXNzYWdlX2V2ZW50X2lkKSB7XG4gICAgdGFncy5wdXNoKFtcImVcIiwgdC5yZXBseV90b19jaGFubmVsX21lc3NhZ2VfZXZlbnRfaWQsIHQucmVsYXlfdXJsLCBcInJlcGx5XCJdKTtcbiAgfVxuICByZXR1cm4gZmluYWxpemVFdmVudChcbiAgICB7XG4gICAgICBraW5kOiBDaGFubmVsTWVzc2FnZSxcbiAgICAgIHRhZ3M6IFsuLi50YWdzLCAuLi50LnRhZ3MgPz8gW11dLFxuICAgICAgY29udGVudDogdC5jb250ZW50LFxuICAgICAgY3JlYXRlZF9hdDogdC5jcmVhdGVkX2F0XG4gICAgfSxcbiAgICBwcml2YXRlS2V5XG4gICk7XG59O1xudmFyIGNoYW5uZWxIaWRlTWVzc2FnZUV2ZW50ID0gKHQsIHByaXZhdGVLZXkpID0+IHtcbiAgbGV0IGNvbnRlbnQ7XG4gIGlmICh0eXBlb2YgdC5jb250ZW50ID09PSBcIm9iamVjdFwiKSB7XG4gICAgY29udGVudCA9IEpTT04uc3RyaW5naWZ5KHQuY29udGVudCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHQuY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnRlbnQgPSB0LmNvbnRlbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4gZmluYWxpemVFdmVudChcbiAgICB7XG4gICAgICBraW5kOiBDaGFubmVsSGlkZU1lc3NhZ2UsXG4gICAgICB0YWdzOiBbW1wiZVwiLCB0LmNoYW5uZWxfbWVzc2FnZV9ldmVudF9pZF0sIC4uLnQudGFncyA/PyBbXV0sXG4gICAgICBjb250ZW50LFxuICAgICAgY3JlYXRlZF9hdDogdC5jcmVhdGVkX2F0XG4gICAgfSxcbiAgICBwcml2YXRlS2V5XG4gICk7XG59O1xudmFyIGNoYW5uZWxNdXRlVXNlckV2ZW50ID0gKHQsIHByaXZhdGVLZXkpID0+IHtcbiAgbGV0IGNvbnRlbnQ7XG4gIGlmICh0eXBlb2YgdC5jb250ZW50ID09PSBcIm9iamVjdFwiKSB7XG4gICAgY29udGVudCA9IEpTT04uc3RyaW5naWZ5KHQuY29udGVudCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHQuY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnRlbnQgPSB0LmNvbnRlbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4gZmluYWxpemVFdmVudChcbiAgICB7XG4gICAgICBraW5kOiBDaGFubmVsTXV0ZVVzZXIsXG4gICAgICB0YWdzOiBbW1wicFwiLCB0LnB1YmtleV90b19tdXRlXSwgLi4udC50YWdzID8/IFtdXSxcbiAgICAgIGNvbnRlbnQsXG4gICAgICBjcmVhdGVkX2F0OiB0LmNyZWF0ZWRfYXRcbiAgICB9LFxuICAgIHByaXZhdGVLZXlcbiAgKTtcbn07XG5cbi8vIG5pcDMwLnRzXG52YXIgbmlwMzBfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobmlwMzBfZXhwb3J0cywge1xuICBFTU9KSV9TSE9SVENPREVfUkVHRVg6ICgpID0+IEVNT0pJX1NIT1JUQ09ERV9SRUdFWCxcbiAgbWF0Y2hBbGw6ICgpID0+IG1hdGNoQWxsMixcbiAgcmVnZXg6ICgpID0+IHJlZ2V4MixcbiAgcmVwbGFjZUFsbDogKCkgPT4gcmVwbGFjZUFsbDJcbn0pO1xudmFyIEVNT0pJX1NIT1JUQ09ERV9SRUdFWCA9IC86KFxcdyspOi87XG52YXIgcmVnZXgyID0gKCkgPT4gbmV3IFJlZ0V4cChgXFxcXEIke0VNT0pJX1NIT1JUQ09ERV9SRUdFWC5zb3VyY2V9XFxcXEJgLCBcImdcIik7XG5mdW5jdGlvbiogbWF0Y2hBbGwyKGNvbnRlbnQpIHtcbiAgY29uc3QgbWF0Y2hlcyA9IGNvbnRlbnQubWF0Y2hBbGwocmVnZXgyKCkpO1xuICBmb3IgKGNvbnN0IG1hdGNoIG9mIG1hdGNoZXMpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgW3Nob3J0Y29kZSwgbmFtZV0gPSBtYXRjaDtcbiAgICAgIHlpZWxkIHtcbiAgICAgICAgc2hvcnRjb2RlLFxuICAgICAgICBuYW1lLFxuICAgICAgICBzdGFydDogbWF0Y2guaW5kZXgsXG4gICAgICAgIGVuZDogbWF0Y2guaW5kZXggKyBzaG9ydGNvZGUubGVuZ3RoXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKF9lKSB7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiByZXBsYWNlQWxsMihjb250ZW50LCByZXBsYWNlcikge1xuICByZXR1cm4gY29udGVudC5yZXBsYWNlQWxsKHJlZ2V4MigpLCAoc2hvcnRjb2RlLCBuYW1lKSA9PiB7XG4gICAgcmV0dXJuIHJlcGxhY2VyKHtcbiAgICAgIHNob3J0Y29kZSxcbiAgICAgIG5hbWVcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8vIG5pcDM5LnRzXG52YXIgbmlwMzlfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobmlwMzlfZXhwb3J0cywge1xuICB1c2VGZXRjaEltcGxlbWVudGF0aW9uOiAoKSA9PiB1c2VGZXRjaEltcGxlbWVudGF0aW9uMyxcbiAgdmFsaWRhdGVHaXRodWI6ICgpID0+IHZhbGlkYXRlR2l0aHViXG59KTtcbnZhciBfZmV0Y2gzO1xudHJ5IHtcbiAgX2ZldGNoMyA9IGZldGNoO1xufSBjYXRjaCB7XG59XG5mdW5jdGlvbiB1c2VGZXRjaEltcGxlbWVudGF0aW9uMyhmZXRjaEltcGxlbWVudGF0aW9uKSB7XG4gIF9mZXRjaDMgPSBmZXRjaEltcGxlbWVudGF0aW9uO1xufVxuYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVHaXRodWIocHVia2V5LCB1c2VybmFtZSwgcHJvb2YpIHtcbiAgdHJ5IHtcbiAgICBsZXQgcmVzID0gYXdhaXQgKGF3YWl0IF9mZXRjaDMoYGh0dHBzOi8vZ2lzdC5naXRodWIuY29tLyR7dXNlcm5hbWV9LyR7cHJvb2Z9L3Jhd2ApKS50ZXh0KCk7XG4gICAgcmV0dXJuIHJlcyA9PT0gYFZlcmlmeWluZyB0aGF0IEkgY29udHJvbCB0aGUgZm9sbG93aW5nIE5vc3RyIHB1YmxpYyBrZXk6ICR7cHVia2V5fWA7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLy8gbmlwNDQudHNcbnZhciBuaXA0NF9leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXA0NF9leHBvcnRzLCB7XG4gIGRlY3J5cHQ6ICgpID0+IGRlY3J5cHQyLFxuICBlbmNyeXB0OiAoKSA9PiBlbmNyeXB0MixcbiAgZ2V0Q29udmVyc2F0aW9uS2V5OiAoKSA9PiBnZXRDb252ZXJzYXRpb25LZXksXG4gIHYyOiAoKSA9PiB2MlxufSk7XG5pbXBvcnQgeyBjaGFjaGEyMCB9IGZyb20gXCJAbm9ibGUvY2lwaGVycy9jaGFjaGFcIjtcbmltcG9ydCB7IGVxdWFsQnl0ZXMgfSBmcm9tIFwiQG5vYmxlL2NpcGhlcnMvdXRpbHNcIjtcbmltcG9ydCB7IHNlY3AyNTZrMSBhcyBzZWNwMjU2azEyIH0gZnJvbSBcIkBub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxXCI7XG5pbXBvcnQgeyBleHRyYWN0IGFzIGhrZGZfZXh0cmFjdCwgZXhwYW5kIGFzIGhrZGZfZXhwYW5kIH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvaGtkZlwiO1xuaW1wb3J0IHsgaG1hYyB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL2htYWNcIjtcbmltcG9ydCB7IHNoYTI1NiBhcyBzaGEyNTYzIH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvc2hhMjU2XCI7XG5pbXBvcnQgeyBjb25jYXRCeXRlcyBhcyBjb25jYXRCeXRlczIsIHJhbmRvbUJ5dGVzIGFzIHJhbmRvbUJ5dGVzMiB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3V0aWxzXCI7XG5pbXBvcnQgeyBiYXNlNjQgYXMgYmFzZTY0MiB9IGZyb20gXCJAc2N1cmUvYmFzZVwiO1xudmFyIG1pblBsYWludGV4dFNpemUgPSAxO1xudmFyIG1heFBsYWludGV4dFNpemUgPSA2NTUzNTtcbmZ1bmN0aW9uIGdldENvbnZlcnNhdGlvbktleShwcml2a2V5QSwgcHVia2V5Qikge1xuICBjb25zdCBzaGFyZWRYID0gc2VjcDI1NmsxMi5nZXRTaGFyZWRTZWNyZXQocHJpdmtleUEsIFwiMDJcIiArIHB1YmtleUIpLnN1YmFycmF5KDEsIDMzKTtcbiAgcmV0dXJuIGhrZGZfZXh0cmFjdChzaGEyNTYzLCBzaGFyZWRYLCBcIm5pcDQ0LXYyXCIpO1xufVxuZnVuY3Rpb24gZ2V0TWVzc2FnZUtleXMoY29udmVyc2F0aW9uS2V5LCBub25jZSkge1xuICBjb25zdCBrZXlzID0gaGtkZl9leHBhbmQoc2hhMjU2MywgY29udmVyc2F0aW9uS2V5LCBub25jZSwgNzYpO1xuICByZXR1cm4ge1xuICAgIGNoYWNoYV9rZXk6IGtleXMuc3ViYXJyYXkoMCwgMzIpLFxuICAgIGNoYWNoYV9ub25jZToga2V5cy5zdWJhcnJheSgzMiwgNDQpLFxuICAgIGhtYWNfa2V5OiBrZXlzLnN1YmFycmF5KDQ0LCA3NilcbiAgfTtcbn1cbmZ1bmN0aW9uIGNhbGNQYWRkZWRMZW4obGVuKSB7XG4gIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobGVuKSB8fCBsZW4gPCAxKVxuICAgIHRocm93IG5ldyBFcnJvcihcImV4cGVjdGVkIHBvc2l0aXZlIGludGVnZXJcIik7XG4gIGlmIChsZW4gPD0gMzIpXG4gICAgcmV0dXJuIDMyO1xuICBjb25zdCBuZXh0UG93ZXIgPSAxIDw8IE1hdGguZmxvb3IoTWF0aC5sb2cyKGxlbiAtIDEpKSArIDE7XG4gIGNvbnN0IGNodW5rID0gbmV4dFBvd2VyIDw9IDI1NiA/IDMyIDogbmV4dFBvd2VyIC8gODtcbiAgcmV0dXJuIGNodW5rICogKE1hdGguZmxvb3IoKGxlbiAtIDEpIC8gY2h1bmspICsgMSk7XG59XG5mdW5jdGlvbiB3cml0ZVUxNkJFKG51bSkge1xuICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG51bSkgfHwgbnVtIDwgbWluUGxhaW50ZXh0U2l6ZSB8fCBudW0gPiBtYXhQbGFpbnRleHRTaXplKVxuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcGxhaW50ZXh0IHNpemU6IG11c3QgYmUgYmV0d2VlbiAxIGFuZCA2NTUzNSBieXRlc1wiKTtcbiAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMik7XG4gIG5ldyBEYXRhVmlldyhhcnIuYnVmZmVyKS5zZXRVaW50MTYoMCwgbnVtLCBmYWxzZSk7XG4gIHJldHVybiBhcnI7XG59XG5mdW5jdGlvbiBwYWQocGxhaW50ZXh0KSB7XG4gIGNvbnN0IHVucGFkZGVkID0gdXRmOEVuY29kZXIuZW5jb2RlKHBsYWludGV4dCk7XG4gIGNvbnN0IHVucGFkZGVkTGVuID0gdW5wYWRkZWQubGVuZ3RoO1xuICBjb25zdCBwcmVmaXggPSB3cml0ZVUxNkJFKHVucGFkZGVkTGVuKTtcbiAgY29uc3Qgc3VmZml4ID0gbmV3IFVpbnQ4QXJyYXkoY2FsY1BhZGRlZExlbih1bnBhZGRlZExlbikgLSB1bnBhZGRlZExlbik7XG4gIHJldHVybiBjb25jYXRCeXRlczIocHJlZml4LCB1bnBhZGRlZCwgc3VmZml4KTtcbn1cbmZ1bmN0aW9uIHVucGFkKHBhZGRlZCkge1xuICBjb25zdCB1bnBhZGRlZExlbiA9IG5ldyBEYXRhVmlldyhwYWRkZWQuYnVmZmVyKS5nZXRVaW50MTYoMCk7XG4gIGNvbnN0IHVucGFkZGVkID0gcGFkZGVkLnN1YmFycmF5KDIsIDIgKyB1bnBhZGRlZExlbik7XG4gIGlmICh1bnBhZGRlZExlbiA8IG1pblBsYWludGV4dFNpemUgfHwgdW5wYWRkZWRMZW4gPiBtYXhQbGFpbnRleHRTaXplIHx8IHVucGFkZGVkLmxlbmd0aCAhPT0gdW5wYWRkZWRMZW4gfHwgcGFkZGVkLmxlbmd0aCAhPT0gMiArIGNhbGNQYWRkZWRMZW4odW5wYWRkZWRMZW4pKVxuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcGFkZGluZ1wiKTtcbiAgcmV0dXJuIHV0ZjhEZWNvZGVyLmRlY29kZSh1bnBhZGRlZCk7XG59XG5mdW5jdGlvbiBobWFjQWFkKGtleSwgbWVzc2FnZSwgYWFkKSB7XG4gIGlmIChhYWQubGVuZ3RoICE9PSAzMilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJBQUQgYXNzb2NpYXRlZCBkYXRhIG11c3QgYmUgMzIgYnl0ZXNcIik7XG4gIGNvbnN0IGNvbWJpbmVkID0gY29uY2F0Qnl0ZXMyKGFhZCwgbWVzc2FnZSk7XG4gIHJldHVybiBobWFjKHNoYTI1NjMsIGtleSwgY29tYmluZWQpO1xufVxuZnVuY3Rpb24gZGVjb2RlUGF5bG9hZChwYXlsb2FkKSB7XG4gIGlmICh0eXBlb2YgcGF5bG9hZCAhPT0gXCJzdHJpbmdcIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJwYXlsb2FkIG11c3QgYmUgYSB2YWxpZCBzdHJpbmdcIik7XG4gIGNvbnN0IHBsZW4gPSBwYXlsb2FkLmxlbmd0aDtcbiAgaWYgKHBsZW4gPCAxMzIgfHwgcGxlbiA+IDg3NDcyKVxuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcGF5bG9hZCBsZW5ndGg6IFwiICsgcGxlbik7XG4gIGlmIChwYXlsb2FkWzBdID09PSBcIiNcIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIGVuY3J5cHRpb24gdmVyc2lvblwiKTtcbiAgbGV0IGRhdGE7XG4gIHRyeSB7XG4gICAgZGF0YSA9IGJhc2U2NDIuZGVjb2RlKHBheWxvYWQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYmFzZTY0OiBcIiArIGVycm9yLm1lc3NhZ2UpO1xuICB9XG4gIGNvbnN0IGRsZW4gPSBkYXRhLmxlbmd0aDtcbiAgaWYgKGRsZW4gPCA5OSB8fCBkbGVuID4gNjU2MDMpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBkYXRhIGxlbmd0aDogXCIgKyBkbGVuKTtcbiAgY29uc3QgdmVycyA9IGRhdGFbMF07XG4gIGlmICh2ZXJzICE9PSAyKVxuICAgIHRocm93IG5ldyBFcnJvcihcInVua25vd24gZW5jcnlwdGlvbiB2ZXJzaW9uIFwiICsgdmVycyk7XG4gIHJldHVybiB7XG4gICAgbm9uY2U6IGRhdGEuc3ViYXJyYXkoMSwgMzMpLFxuICAgIGNpcGhlcnRleHQ6IGRhdGEuc3ViYXJyYXkoMzMsIC0zMiksXG4gICAgbWFjOiBkYXRhLnN1YmFycmF5KC0zMilcbiAgfTtcbn1cbmZ1bmN0aW9uIGVuY3J5cHQyKHBsYWludGV4dCwgY29udmVyc2F0aW9uS2V5LCBub25jZSA9IHJhbmRvbUJ5dGVzMigzMikpIHtcbiAgY29uc3QgeyBjaGFjaGFfa2V5LCBjaGFjaGFfbm9uY2UsIGhtYWNfa2V5IH0gPSBnZXRNZXNzYWdlS2V5cyhjb252ZXJzYXRpb25LZXksIG5vbmNlKTtcbiAgY29uc3QgcGFkZGVkID0gcGFkKHBsYWludGV4dCk7XG4gIGNvbnN0IGNpcGhlcnRleHQgPSBjaGFjaGEyMChjaGFjaGFfa2V5LCBjaGFjaGFfbm9uY2UsIHBhZGRlZCk7XG4gIGNvbnN0IG1hYyA9IGhtYWNBYWQoaG1hY19rZXksIGNpcGhlcnRleHQsIG5vbmNlKTtcbiAgcmV0dXJuIGJhc2U2NDIuZW5jb2RlKGNvbmNhdEJ5dGVzMihuZXcgVWludDhBcnJheShbMl0pLCBub25jZSwgY2lwaGVydGV4dCwgbWFjKSk7XG59XG5mdW5jdGlvbiBkZWNyeXB0MihwYXlsb2FkLCBjb252ZXJzYXRpb25LZXkpIHtcbiAgY29uc3QgeyBub25jZSwgY2lwaGVydGV4dCwgbWFjIH0gPSBkZWNvZGVQYXlsb2FkKHBheWxvYWQpO1xuICBjb25zdCB7IGNoYWNoYV9rZXksIGNoYWNoYV9ub25jZSwgaG1hY19rZXkgfSA9IGdldE1lc3NhZ2VLZXlzKGNvbnZlcnNhdGlvbktleSwgbm9uY2UpO1xuICBjb25zdCBjYWxjdWxhdGVkTWFjID0gaG1hY0FhZChobWFjX2tleSwgY2lwaGVydGV4dCwgbm9uY2UpO1xuICBpZiAoIWVxdWFsQnl0ZXMoY2FsY3VsYXRlZE1hYywgbWFjKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIE1BQ1wiKTtcbiAgY29uc3QgcGFkZGVkID0gY2hhY2hhMjAoY2hhY2hhX2tleSwgY2hhY2hhX25vbmNlLCBjaXBoZXJ0ZXh0KTtcbiAgcmV0dXJuIHVucGFkKHBhZGRlZCk7XG59XG52YXIgdjIgPSB7XG4gIHV0aWxzOiB7XG4gICAgZ2V0Q29udmVyc2F0aW9uS2V5LFxuICAgIGNhbGNQYWRkZWRMZW5cbiAgfSxcbiAgZW5jcnlwdDogZW5jcnlwdDIsXG4gIGRlY3J5cHQ6IGRlY3J5cHQyXG59O1xuXG4vLyBuaXA0Ny50c1xudmFyIG5pcDQ3X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDQ3X2V4cG9ydHMsIHtcbiAgbWFrZU53Y1JlcXVlc3RFdmVudDogKCkgPT4gbWFrZU53Y1JlcXVlc3RFdmVudCxcbiAgcGFyc2VDb25uZWN0aW9uU3RyaW5nOiAoKSA9PiBwYXJzZUNvbm5lY3Rpb25TdHJpbmdcbn0pO1xuZnVuY3Rpb24gcGFyc2VDb25uZWN0aW9uU3RyaW5nKGNvbm5lY3Rpb25TdHJpbmcpIHtcbiAgY29uc3QgeyBwYXRobmFtZSwgc2VhcmNoUGFyYW1zIH0gPSBuZXcgVVJMKGNvbm5lY3Rpb25TdHJpbmcpO1xuICBjb25zdCBwdWJrZXkgPSBwYXRobmFtZTtcbiAgY29uc3QgcmVsYXkgPSBzZWFyY2hQYXJhbXMuZ2V0KFwicmVsYXlcIik7XG4gIGNvbnN0IHNlY3JldCA9IHNlYXJjaFBhcmFtcy5nZXQoXCJzZWNyZXRcIik7XG4gIGlmICghcHVia2V5IHx8ICFyZWxheSB8fCAhc2VjcmV0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBjb25uZWN0aW9uIHN0cmluZ1wiKTtcbiAgfVxuICByZXR1cm4geyBwdWJrZXksIHJlbGF5LCBzZWNyZXQgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIG1ha2VOd2NSZXF1ZXN0RXZlbnQocHVia2V5LCBzZWNyZXRLZXksIGludm9pY2UpIHtcbiAgY29uc3QgY29udGVudCA9IHtcbiAgICBtZXRob2Q6IFwicGF5X2ludm9pY2VcIixcbiAgICBwYXJhbXM6IHtcbiAgICAgIGludm9pY2VcbiAgICB9XG4gIH07XG4gIGNvbnN0IGVuY3J5cHRlZENvbnRlbnQgPSBhd2FpdCBlbmNyeXB0KHNlY3JldEtleSwgcHVia2V5LCBKU09OLnN0cmluZ2lmeShjb250ZW50KSk7XG4gIGNvbnN0IGV2ZW50VGVtcGxhdGUgPSB7XG4gICAga2luZDogTldDV2FsbGV0UmVxdWVzdCxcbiAgICBjcmVhdGVkX2F0OiBNYXRoLnJvdW5kKERhdGUubm93KCkgLyAxZTMpLFxuICAgIGNvbnRlbnQ6IGVuY3J5cHRlZENvbnRlbnQsXG4gICAgdGFnczogW1tcInBcIiwgcHVia2V5XV1cbiAgfTtcbiAgcmV0dXJuIGZpbmFsaXplRXZlbnQoZXZlbnRUZW1wbGF0ZSwgc2VjcmV0S2V5KTtcbn1cblxuLy8gbmlwNTcudHNcbnZhciBuaXA1N19leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXA1N19leHBvcnRzLCB7XG4gIGdldFphcEVuZHBvaW50OiAoKSA9PiBnZXRaYXBFbmRwb2ludCxcbiAgbWFrZVphcFJlY2VpcHQ6ICgpID0+IG1ha2VaYXBSZWNlaXB0LFxuICBtYWtlWmFwUmVxdWVzdDogKCkgPT4gbWFrZVphcFJlcXVlc3QsXG4gIHVzZUZldGNoSW1wbGVtZW50YXRpb246ICgpID0+IHVzZUZldGNoSW1wbGVtZW50YXRpb240LFxuICB2YWxpZGF0ZVphcFJlcXVlc3Q6ICgpID0+IHZhbGlkYXRlWmFwUmVxdWVzdFxufSk7XG5pbXBvcnQgeyBiZWNoMzIgYXMgYmVjaDMyMiB9IGZyb20gXCJAc2N1cmUvYmFzZVwiO1xudmFyIF9mZXRjaDQ7XG50cnkge1xuICBfZmV0Y2g0ID0gZmV0Y2g7XG59IGNhdGNoIHtcbn1cbmZ1bmN0aW9uIHVzZUZldGNoSW1wbGVtZW50YXRpb240KGZldGNoSW1wbGVtZW50YXRpb24pIHtcbiAgX2ZldGNoNCA9IGZldGNoSW1wbGVtZW50YXRpb247XG59XG5hc3luYyBmdW5jdGlvbiBnZXRaYXBFbmRwb2ludChtZXRhZGF0YSkge1xuICB0cnkge1xuICAgIGxldCBsbnVybCA9IFwiXCI7XG4gICAgbGV0IHsgbHVkMDYsIGx1ZDE2IH0gPSBKU09OLnBhcnNlKG1ldGFkYXRhLmNvbnRlbnQpO1xuICAgIGlmIChsdWQwNikge1xuICAgICAgbGV0IHsgd29yZHMgfSA9IGJlY2gzMjIuZGVjb2RlKGx1ZDA2LCAxZTMpO1xuICAgICAgbGV0IGRhdGEgPSBiZWNoMzIyLmZyb21Xb3Jkcyh3b3Jkcyk7XG4gICAgICBsbnVybCA9IHV0ZjhEZWNvZGVyLmRlY29kZShkYXRhKTtcbiAgICB9IGVsc2UgaWYgKGx1ZDE2KSB7XG4gICAgICBsZXQgW25hbWUsIGRvbWFpbl0gPSBsdWQxNi5zcGxpdChcIkBcIik7XG4gICAgICBsbnVybCA9IG5ldyBVUkwoYC8ud2VsbC1rbm93bi9sbnVybHAvJHtuYW1lfWAsIGBodHRwczovLyR7ZG9tYWlufWApLnRvU3RyaW5nKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBsZXQgcmVzID0gYXdhaXQgX2ZldGNoNChsbnVybCk7XG4gICAgbGV0IGJvZHkgPSBhd2FpdCByZXMuanNvbigpO1xuICAgIGlmIChib2R5LmFsbG93c05vc3RyICYmIGJvZHkubm9zdHJQdWJrZXkpIHtcbiAgICAgIHJldHVybiBib2R5LmNhbGxiYWNrO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBtYWtlWmFwUmVxdWVzdCh7XG4gIHByb2ZpbGUsXG4gIGV2ZW50LFxuICBhbW91bnQsXG4gIHJlbGF5cyxcbiAgY29tbWVudCA9IFwiXCJcbn0pIHtcbiAgaWYgKCFhbW91bnQpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYW1vdW50IG5vdCBnaXZlblwiKTtcbiAgaWYgKCFwcm9maWxlKVxuICAgIHRocm93IG5ldyBFcnJvcihcInByb2ZpbGUgbm90IGdpdmVuXCIpO1xuICBsZXQgenIgPSB7XG4gICAga2luZDogOTczNCxcbiAgICBjcmVhdGVkX2F0OiBNYXRoLnJvdW5kKERhdGUubm93KCkgLyAxZTMpLFxuICAgIGNvbnRlbnQ6IGNvbW1lbnQsXG4gICAgdGFnczogW1xuICAgICAgW1wicFwiLCBwcm9maWxlXSxcbiAgICAgIFtcImFtb3VudFwiLCBhbW91bnQudG9TdHJpbmcoKV0sXG4gICAgICBbXCJyZWxheXNcIiwgLi4ucmVsYXlzXVxuICAgIF1cbiAgfTtcbiAgaWYgKGV2ZW50KSB7XG4gICAgenIudGFncy5wdXNoKFtcImVcIiwgZXZlbnRdKTtcbiAgfVxuICByZXR1cm4genI7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVphcFJlcXVlc3QoemFwUmVxdWVzdFN0cmluZykge1xuICBsZXQgemFwUmVxdWVzdDtcbiAgdHJ5IHtcbiAgICB6YXBSZXF1ZXN0ID0gSlNPTi5wYXJzZSh6YXBSZXF1ZXN0U3RyaW5nKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIFwiSW52YWxpZCB6YXAgcmVxdWVzdCBKU09OLlwiO1xuICB9XG4gIGlmICghdmFsaWRhdGVFdmVudCh6YXBSZXF1ZXN0KSlcbiAgICByZXR1cm4gXCJaYXAgcmVxdWVzdCBpcyBub3QgYSB2YWxpZCBOb3N0ciBldmVudC5cIjtcbiAgaWYgKCF2ZXJpZnlFdmVudCh6YXBSZXF1ZXN0KSlcbiAgICByZXR1cm4gXCJJbnZhbGlkIHNpZ25hdHVyZSBvbiB6YXAgcmVxdWVzdC5cIjtcbiAgbGV0IHAgPSB6YXBSZXF1ZXN0LnRhZ3MuZmluZCgoW3QsIHZdKSA9PiB0ID09PSBcInBcIiAmJiB2KTtcbiAgaWYgKCFwKVxuICAgIHJldHVybiBcIlphcCByZXF1ZXN0IGRvZXNuJ3QgaGF2ZSBhICdwJyB0YWcuXCI7XG4gIGlmICghcFsxXS5tYXRjaCgvXlthLWYwLTldezY0fSQvKSlcbiAgICByZXR1cm4gXCJaYXAgcmVxdWVzdCAncCcgdGFnIGlzIG5vdCB2YWxpZCBoZXguXCI7XG4gIGxldCBlID0gemFwUmVxdWVzdC50YWdzLmZpbmQoKFt0LCB2XSkgPT4gdCA9PT0gXCJlXCIgJiYgdik7XG4gIGlmIChlICYmICFlWzFdLm1hdGNoKC9eW2EtZjAtOV17NjR9JC8pKVxuICAgIHJldHVybiBcIlphcCByZXF1ZXN0ICdlJyB0YWcgaXMgbm90IHZhbGlkIGhleC5cIjtcbiAgbGV0IHJlbGF5cyA9IHphcFJlcXVlc3QudGFncy5maW5kKChbdCwgdl0pID0+IHQgPT09IFwicmVsYXlzXCIgJiYgdik7XG4gIGlmICghcmVsYXlzKVxuICAgIHJldHVybiBcIlphcCByZXF1ZXN0IGRvZXNuJ3QgaGF2ZSBhICdyZWxheXMnIHRhZy5cIjtcbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBtYWtlWmFwUmVjZWlwdCh7XG4gIHphcFJlcXVlc3QsXG4gIHByZWltYWdlLFxuICBib2x0MTEsXG4gIHBhaWRBdFxufSkge1xuICBsZXQgenIgPSBKU09OLnBhcnNlKHphcFJlcXVlc3QpO1xuICBsZXQgdGFnc0Zyb21aYXBSZXF1ZXN0ID0genIudGFncy5maWx0ZXIoKFt0XSkgPT4gdCA9PT0gXCJlXCIgfHwgdCA9PT0gXCJwXCIgfHwgdCA9PT0gXCJhXCIpO1xuICBsZXQgemFwID0ge1xuICAgIGtpbmQ6IDk3MzUsXG4gICAgY3JlYXRlZF9hdDogTWF0aC5yb3VuZChwYWlkQXQuZ2V0VGltZSgpIC8gMWUzKSxcbiAgICBjb250ZW50OiBcIlwiLFxuICAgIHRhZ3M6IFsuLi50YWdzRnJvbVphcFJlcXVlc3QsIFtcIlBcIiwgenIucHVia2V5XSwgW1wiYm9sdDExXCIsIGJvbHQxMV0sIFtcImRlc2NyaXB0aW9uXCIsIHphcFJlcXVlc3RdXVxuICB9O1xuICBpZiAocHJlaW1hZ2UpIHtcbiAgICB6YXAudGFncy5wdXNoKFtcInByZWltYWdlXCIsIHByZWltYWdlXSk7XG4gIH1cbiAgcmV0dXJuIHphcDtcbn1cblxuLy8gbmlwNTkudHNcbnZhciBuaXA1OV9leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXA1OV9leHBvcnRzLCB7XG4gIGNyZWF0ZVJ1bW9yOiAoKSA9PiBjcmVhdGVSdW1vcixcbiAgY3JlYXRlU2VhbDogKCkgPT4gY3JlYXRlU2VhbCxcbiAgY3JlYXRlV3JhcDogKCkgPT4gY3JlYXRlV3JhcCxcbiAgdW53cmFwRXZlbnQ6ICgpID0+IHVud3JhcEV2ZW50LFxuICB1bndyYXBNYW55RXZlbnRzOiAoKSA9PiB1bndyYXBNYW55RXZlbnRzLFxuICB3cmFwRXZlbnQ6ICgpID0+IHdyYXBFdmVudCxcbiAgd3JhcE1hbnlFdmVudHM6ICgpID0+IHdyYXBNYW55RXZlbnRzXG59KTtcbnZhciBUV09fREFZUyA9IDIgKiAyNCAqIDYwICogNjA7XG52YXIgbm93ID0gKCkgPT4gTWF0aC5yb3VuZChEYXRlLm5vdygpIC8gMWUzKTtcbnZhciByYW5kb21Ob3cgPSAoKSA9PiBNYXRoLnJvdW5kKG5vdygpIC0gTWF0aC5yYW5kb20oKSAqIFRXT19EQVlTKTtcbnZhciBuaXA0NENvbnZlcnNhdGlvbktleSA9IChwcml2YXRlS2V5LCBwdWJsaWNLZXkpID0+IGdldENvbnZlcnNhdGlvbktleShwcml2YXRlS2V5LCBwdWJsaWNLZXkpO1xudmFyIG5pcDQ0RW5jcnlwdCA9IChkYXRhLCBwcml2YXRlS2V5LCBwdWJsaWNLZXkpID0+IGVuY3J5cHQyKEpTT04uc3RyaW5naWZ5KGRhdGEpLCBuaXA0NENvbnZlcnNhdGlvbktleShwcml2YXRlS2V5LCBwdWJsaWNLZXkpKTtcbnZhciBuaXA0NERlY3J5cHQgPSAoZGF0YSwgcHJpdmF0ZUtleSkgPT4gSlNPTi5wYXJzZShkZWNyeXB0MihkYXRhLmNvbnRlbnQsIG5pcDQ0Q29udmVyc2F0aW9uS2V5KHByaXZhdGVLZXksIGRhdGEucHVia2V5KSkpO1xuZnVuY3Rpb24gY3JlYXRlUnVtb3IoZXZlbnQsIHByaXZhdGVLZXkpIHtcbiAgY29uc3QgcnVtb3IgPSB7XG4gICAgY3JlYXRlZF9hdDogbm93KCksXG4gICAgY29udGVudDogXCJcIixcbiAgICB0YWdzOiBbXSxcbiAgICAuLi5ldmVudCxcbiAgICBwdWJrZXk6IGdldFB1YmxpY0tleShwcml2YXRlS2V5KVxuICB9O1xuICBydW1vci5pZCA9IGdldEV2ZW50SGFzaChydW1vcik7XG4gIHJldHVybiBydW1vcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNlYWwocnVtb3IsIHByaXZhdGVLZXksIHJlY2lwaWVudFB1YmxpY0tleSkge1xuICByZXR1cm4gZmluYWxpemVFdmVudChcbiAgICB7XG4gICAgICBraW5kOiBTZWFsLFxuICAgICAgY29udGVudDogbmlwNDRFbmNyeXB0KHJ1bW9yLCBwcml2YXRlS2V5LCByZWNpcGllbnRQdWJsaWNLZXkpLFxuICAgICAgY3JlYXRlZF9hdDogcmFuZG9tTm93KCksXG4gICAgICB0YWdzOiBbXVxuICAgIH0sXG4gICAgcHJpdmF0ZUtleVxuICApO1xufVxuZnVuY3Rpb24gY3JlYXRlV3JhcChzZWFsLCByZWNpcGllbnRQdWJsaWNLZXkpIHtcbiAgY29uc3QgcmFuZG9tS2V5ID0gZ2VuZXJhdGVTZWNyZXRLZXkoKTtcbiAgcmV0dXJuIGZpbmFsaXplRXZlbnQoXG4gICAge1xuICAgICAga2luZDogR2lmdFdyYXAsXG4gICAgICBjb250ZW50OiBuaXA0NEVuY3J5cHQoc2VhbCwgcmFuZG9tS2V5LCByZWNpcGllbnRQdWJsaWNLZXkpLFxuICAgICAgY3JlYXRlZF9hdDogcmFuZG9tTm93KCksXG4gICAgICB0YWdzOiBbW1wicFwiLCByZWNpcGllbnRQdWJsaWNLZXldXVxuICAgIH0sXG4gICAgcmFuZG9tS2V5XG4gICk7XG59XG5mdW5jdGlvbiB3cmFwRXZlbnQoZXZlbnQsIHNlbmRlclByaXZhdGVLZXksIHJlY2lwaWVudFB1YmxpY0tleSkge1xuICBjb25zdCBydW1vciA9IGNyZWF0ZVJ1bW9yKGV2ZW50LCBzZW5kZXJQcml2YXRlS2V5KTtcbiAgY29uc3Qgc2VhbCA9IGNyZWF0ZVNlYWwocnVtb3IsIHNlbmRlclByaXZhdGVLZXksIHJlY2lwaWVudFB1YmxpY0tleSk7XG4gIHJldHVybiBjcmVhdGVXcmFwKHNlYWwsIHJlY2lwaWVudFB1YmxpY0tleSk7XG59XG5mdW5jdGlvbiB3cmFwTWFueUV2ZW50cyhldmVudCwgc2VuZGVyUHJpdmF0ZUtleSwgcmVjaXBpZW50c1B1YmxpY0tleXMpIHtcbiAgaWYgKCFyZWNpcGllbnRzUHVibGljS2V5cyB8fCByZWNpcGllbnRzUHVibGljS2V5cy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdCBsZWFzdCBvbmUgcmVjaXBpZW50IGlzIHJlcXVpcmVkLlwiKTtcbiAgfVxuICBjb25zdCBzZW5kZXJQdWJsaWNLZXkgPSBnZXRQdWJsaWNLZXkoc2VuZGVyUHJpdmF0ZUtleSk7XG4gIGNvbnN0IHdyYXBwZWRzID0gW3dyYXBFdmVudChldmVudCwgc2VuZGVyUHJpdmF0ZUtleSwgc2VuZGVyUHVibGljS2V5KV07XG4gIHJlY2lwaWVudHNQdWJsaWNLZXlzLmZvckVhY2goKHJlY2lwaWVudFB1YmxpY0tleSkgPT4ge1xuICAgIHdyYXBwZWRzLnB1c2god3JhcEV2ZW50KGV2ZW50LCBzZW5kZXJQcml2YXRlS2V5LCByZWNpcGllbnRQdWJsaWNLZXkpKTtcbiAgfSk7XG4gIHJldHVybiB3cmFwcGVkcztcbn1cbmZ1bmN0aW9uIHVud3JhcEV2ZW50KHdyYXAsIHJlY2lwaWVudFByaXZhdGVLZXkpIHtcbiAgY29uc3QgdW53cmFwcGVkU2VhbCA9IG5pcDQ0RGVjcnlwdCh3cmFwLCByZWNpcGllbnRQcml2YXRlS2V5KTtcbiAgcmV0dXJuIG5pcDQ0RGVjcnlwdCh1bndyYXBwZWRTZWFsLCByZWNpcGllbnRQcml2YXRlS2V5KTtcbn1cbmZ1bmN0aW9uIHVud3JhcE1hbnlFdmVudHMod3JhcHBlZEV2ZW50cywgcmVjaXBpZW50UHJpdmF0ZUtleSkge1xuICBsZXQgdW53cmFwcGVkRXZlbnRzID0gW107XG4gIHdyYXBwZWRFdmVudHMuZm9yRWFjaCgoZSkgPT4ge1xuICAgIHVud3JhcHBlZEV2ZW50cy5wdXNoKHVud3JhcEV2ZW50KGUsIHJlY2lwaWVudFByaXZhdGVLZXkpKTtcbiAgfSk7XG4gIHVud3JhcHBlZEV2ZW50cy5zb3J0KChhLCBiKSA9PiBhLmNyZWF0ZWRfYXQgLSBiLmNyZWF0ZWRfYXQpO1xuICByZXR1cm4gdW53cmFwcGVkRXZlbnRzO1xufVxuXG4vLyBuaXA5OC50c1xudmFyIG5pcDk4X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDk4X2V4cG9ydHMsIHtcbiAgZ2V0VG9rZW46ICgpID0+IGdldFRva2VuLFxuICBoYXNoUGF5bG9hZDogKCkgPT4gaGFzaFBheWxvYWQsXG4gIHVucGFja0V2ZW50RnJvbVRva2VuOiAoKSA9PiB1bnBhY2tFdmVudEZyb21Ub2tlbixcbiAgdmFsaWRhdGVFdmVudDogKCkgPT4gdmFsaWRhdGVFdmVudDIsXG4gIHZhbGlkYXRlRXZlbnRLaW5kOiAoKSA9PiB2YWxpZGF0ZUV2ZW50S2luZCxcbiAgdmFsaWRhdGVFdmVudE1ldGhvZFRhZzogKCkgPT4gdmFsaWRhdGVFdmVudE1ldGhvZFRhZyxcbiAgdmFsaWRhdGVFdmVudFBheWxvYWRUYWc6ICgpID0+IHZhbGlkYXRlRXZlbnRQYXlsb2FkVGFnLFxuICB2YWxpZGF0ZUV2ZW50VGltZXN0YW1wOiAoKSA9PiB2YWxpZGF0ZUV2ZW50VGltZXN0YW1wLFxuICB2YWxpZGF0ZUV2ZW50VXJsVGFnOiAoKSA9PiB2YWxpZGF0ZUV2ZW50VXJsVGFnLFxuICB2YWxpZGF0ZVRva2VuOiAoKSA9PiB2YWxpZGF0ZVRva2VuXG59KTtcbmltcG9ydCB7IHNoYTI1NiBhcyBzaGEyNTY0IH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvc2hhMjU2XCI7XG5pbXBvcnQgeyBieXRlc1RvSGV4IGFzIGJ5dGVzVG9IZXg1IH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvdXRpbHNcIjtcbmltcG9ydCB7IGJhc2U2NCBhcyBiYXNlNjQzIH0gZnJvbSBcIkBzY3VyZS9iYXNlXCI7XG52YXIgX2F1dGhvcml6YXRpb25TY2hlbWUgPSBcIk5vc3RyIFwiO1xuYXN5bmMgZnVuY3Rpb24gZ2V0VG9rZW4obG9naW5VcmwsIGh0dHBNZXRob2QsIHNpZ24sIGluY2x1ZGVBdXRob3JpemF0aW9uU2NoZW1lID0gZmFsc2UsIHBheWxvYWQpIHtcbiAgY29uc3QgZXZlbnQgPSB7XG4gICAga2luZDogSFRUUEF1dGgsXG4gICAgdGFnczogW1xuICAgICAgW1widVwiLCBsb2dpblVybF0sXG4gICAgICBbXCJtZXRob2RcIiwgaHR0cE1ldGhvZF1cbiAgICBdLFxuICAgIGNyZWF0ZWRfYXQ6IE1hdGgucm91bmQobmV3IERhdGUoKS5nZXRUaW1lKCkgLyAxZTMpLFxuICAgIGNvbnRlbnQ6IFwiXCJcbiAgfTtcbiAgaWYgKHBheWxvYWQpIHtcbiAgICBldmVudC50YWdzLnB1c2goW1wicGF5bG9hZFwiLCBoYXNoUGF5bG9hZChwYXlsb2FkKV0pO1xuICB9XG4gIGNvbnN0IHNpZ25lZEV2ZW50ID0gYXdhaXQgc2lnbihldmVudCk7XG4gIGNvbnN0IGF1dGhvcml6YXRpb25TY2hlbWUgPSBpbmNsdWRlQXV0aG9yaXphdGlvblNjaGVtZSA/IF9hdXRob3JpemF0aW9uU2NoZW1lIDogXCJcIjtcbiAgcmV0dXJuIGF1dGhvcml6YXRpb25TY2hlbWUgKyBiYXNlNjQzLmVuY29kZSh1dGY4RW5jb2Rlci5lbmNvZGUoSlNPTi5zdHJpbmdpZnkoc2lnbmVkRXZlbnQpKSk7XG59XG5hc3luYyBmdW5jdGlvbiB2YWxpZGF0ZVRva2VuKHRva2VuLCB1cmwsIG1ldGhvZCkge1xuICBjb25zdCBldmVudCA9IGF3YWl0IHVucGFja0V2ZW50RnJvbVRva2VuKHRva2VuKS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfSk7XG4gIGNvbnN0IHZhbGlkID0gYXdhaXQgdmFsaWRhdGVFdmVudDIoZXZlbnQsIHVybCwgbWV0aG9kKS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfSk7XG4gIHJldHVybiB2YWxpZDtcbn1cbmFzeW5jIGZ1bmN0aW9uIHVucGFja0V2ZW50RnJvbVRva2VuKHRva2VuKSB7XG4gIGlmICghdG9rZW4pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHRva2VuXCIpO1xuICB9XG4gIHRva2VuID0gdG9rZW4ucmVwbGFjZShfYXV0aG9yaXphdGlvblNjaGVtZSwgXCJcIik7XG4gIGNvbnN0IGV2ZW50QjY0ID0gdXRmOERlY29kZXIuZGVjb2RlKGJhc2U2NDMuZGVjb2RlKHRva2VuKSk7XG4gIGlmICghZXZlbnRCNjQgfHwgZXZlbnRCNjQubGVuZ3RoID09PSAwIHx8ICFldmVudEI2NC5zdGFydHNXaXRoKFwie1wiKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdG9rZW5cIik7XG4gIH1cbiAgY29uc3QgZXZlbnQgPSBKU09OLnBhcnNlKGV2ZW50QjY0KTtcbiAgcmV0dXJuIGV2ZW50O1xufVxuZnVuY3Rpb24gdmFsaWRhdGVFdmVudFRpbWVzdGFtcChldmVudCkge1xuICBpZiAoIWV2ZW50LmNyZWF0ZWRfYXQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIE1hdGgucm91bmQobmV3IERhdGUoKS5nZXRUaW1lKCkgLyAxZTMpIC0gZXZlbnQuY3JlYXRlZF9hdCA8IDYwO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVFdmVudEtpbmQoZXZlbnQpIHtcbiAgcmV0dXJuIGV2ZW50LmtpbmQgPT09IEhUVFBBdXRoO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVFdmVudFVybFRhZyhldmVudCwgdXJsKSB7XG4gIGNvbnN0IHVybFRhZyA9IGV2ZW50LnRhZ3MuZmluZCgodCkgPT4gdFswXSA9PT0gXCJ1XCIpO1xuICBpZiAoIXVybFRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdXJsVGFnLmxlbmd0aCA+IDAgJiYgdXJsVGFnWzFdID09PSB1cmw7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUV2ZW50TWV0aG9kVGFnKGV2ZW50LCBtZXRob2QpIHtcbiAgY29uc3QgbWV0aG9kVGFnID0gZXZlbnQudGFncy5maW5kKCh0KSA9PiB0WzBdID09PSBcIm1ldGhvZFwiKTtcbiAgaWYgKCFtZXRob2RUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIG1ldGhvZFRhZy5sZW5ndGggPiAwICYmIG1ldGhvZFRhZ1sxXS50b0xvd2VyQ2FzZSgpID09PSBtZXRob2QudG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIGhhc2hQYXlsb2FkKHBheWxvYWQpIHtcbiAgY29uc3QgaGFzaCA9IHNoYTI1NjQodXRmOEVuY29kZXIuZW5jb2RlKEpTT04uc3RyaW5naWZ5KHBheWxvYWQpKSk7XG4gIHJldHVybiBieXRlc1RvSGV4NShoYXNoKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlRXZlbnRQYXlsb2FkVGFnKGV2ZW50LCBwYXlsb2FkKSB7XG4gIGNvbnN0IHBheWxvYWRUYWcgPSBldmVudC50YWdzLmZpbmQoKHQpID0+IHRbMF0gPT09IFwicGF5bG9hZFwiKTtcbiAgaWYgKCFwYXlsb2FkVGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHBheWxvYWRIYXNoID0gaGFzaFBheWxvYWQocGF5bG9hZCk7XG4gIHJldHVybiBwYXlsb2FkVGFnLmxlbmd0aCA+IDAgJiYgcGF5bG9hZFRhZ1sxXSA9PT0gcGF5bG9hZEhhc2g7XG59XG5hc3luYyBmdW5jdGlvbiB2YWxpZGF0ZUV2ZW50MihldmVudCwgdXJsLCBtZXRob2QsIGJvZHkpIHtcbiAgaWYgKCF2ZXJpZnlFdmVudChldmVudCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG5vc3RyIGV2ZW50LCBzaWduYXR1cmUgaW52YWxpZFwiKTtcbiAgfVxuICBpZiAoIXZhbGlkYXRlRXZlbnRLaW5kKGV2ZW50KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbm9zdHIgZXZlbnQsIGtpbmQgaW52YWxpZFwiKTtcbiAgfVxuICBpZiAoIXZhbGlkYXRlRXZlbnRUaW1lc3RhbXAoZXZlbnQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBub3N0ciBldmVudCwgY3JlYXRlZF9hdCB0aW1lc3RhbXAgaW52YWxpZFwiKTtcbiAgfVxuICBpZiAoIXZhbGlkYXRlRXZlbnRVcmxUYWcoZXZlbnQsIHVybCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG5vc3RyIGV2ZW50LCB1cmwgdGFnIGludmFsaWRcIik7XG4gIH1cbiAgaWYgKCF2YWxpZGF0ZUV2ZW50TWV0aG9kVGFnKGV2ZW50LCBtZXRob2QpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBub3N0ciBldmVudCwgbWV0aG9kIHRhZyBpbnZhbGlkXCIpO1xuICB9XG4gIGlmIChCb29sZWFuKGJvZHkpICYmIHR5cGVvZiBib2R5ID09PSBcIm9iamVjdFwiICYmIE9iamVjdC5rZXlzKGJvZHkpLmxlbmd0aCA+IDApIHtcbiAgICBpZiAoIXZhbGlkYXRlRXZlbnRQYXlsb2FkVGFnKGV2ZW50LCBib2R5KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBub3N0ciBldmVudCwgcGF5bG9hZCB0YWcgZG9lcyBub3QgbWF0Y2ggcmVxdWVzdCBib2R5IGhhc2hcIik7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZXhwb3J0IHtcbiAgUmVsYXksXG4gIFNpbXBsZVBvb2wsXG4gIGZpbmFsaXplRXZlbnQsXG4gIGZha2Vqc29uX2V4cG9ydHMgYXMgZmosXG4gIGdlbmVyYXRlU2VjcmV0S2V5LFxuICBnZXRFdmVudEhhc2gsXG4gIGdldEZpbHRlckxpbWl0LFxuICBnZXRQdWJsaWNLZXksXG4gIGtpbmRzX2V4cG9ydHMgYXMga2luZHMsXG4gIG1hdGNoRmlsdGVyLFxuICBtYXRjaEZpbHRlcnMsXG4gIG1lcmdlRmlsdGVycyxcbiAgbmlwMDRfZXhwb3J0cyBhcyBuaXAwNCxcbiAgbmlwMDVfZXhwb3J0cyBhcyBuaXAwNSxcbiAgbmlwMTBfZXhwb3J0cyBhcyBuaXAxMCxcbiAgbmlwMTFfZXhwb3J0cyBhcyBuaXAxMSxcbiAgbmlwMTNfZXhwb3J0cyBhcyBuaXAxMyxcbiAgbmlwMThfZXhwb3J0cyBhcyBuaXAxOCxcbiAgbmlwMTlfZXhwb3J0cyBhcyBuaXAxOSxcbiAgbmlwMjFfZXhwb3J0cyBhcyBuaXAyMSxcbiAgbmlwMjVfZXhwb3J0cyBhcyBuaXAyNSxcbiAgbmlwMjdfZXhwb3J0cyBhcyBuaXAyNyxcbiAgbmlwMjhfZXhwb3J0cyBhcyBuaXAyOCxcbiAgbmlwMzBfZXhwb3J0cyBhcyBuaXAzMCxcbiAgbmlwMzlfZXhwb3J0cyBhcyBuaXAzOSxcbiAgbmlwNDJfZXhwb3J0cyBhcyBuaXA0MixcbiAgbmlwNDRfZXhwb3J0cyBhcyBuaXA0NCxcbiAgbmlwNDdfZXhwb3J0cyBhcyBuaXA0NyxcbiAgbmlwNTdfZXhwb3J0cyBhcyBuaXA1NyxcbiAgbmlwNTlfZXhwb3J0cyBhcyBuaXA1OSxcbiAgbmlwOThfZXhwb3J0cyBhcyBuaXA5OCxcbiAgcGFyc2VSZWZlcmVuY2VzLFxuICBzZXJpYWxpemVFdmVudCxcbiAgc29ydEV2ZW50cyxcbiAgdXRpbHNfZXhwb3J0cyBhcyB1dGlscyxcbiAgdmFsaWRhdGVFdmVudCxcbiAgdmVyaWZpZWRTeW1ib2wsXG4gIHZlcmlmeUV2ZW50XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/lib/esm/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/_shortw_utils.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/_shortw_utils.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createCurve: () => (/* binding */ createCurve),\n/* harmony export */   getHash: () => (/* binding */ getHash)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/hmac */ \"(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/hmac.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/utils */ \"(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\n\n// connects noble-curves to noble-hashes\nfunction getHash(hash) {\n    return {\n        hash,\n        hmac: (key, ...msgs) => (0,_noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__.hmac)(hash, key, (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(...msgs)),\n        randomBytes: _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.randomBytes,\n    };\n}\nfunction createCurve(curveDef, defHash) {\n    const create = (hash) => (0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__.weierstrass)({ ...curveDef, ...getHash(hash) });\n    return Object.freeze({ ...create(defHash), create });\n}\n//# sourceMappingURL=_shortw_utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9zdHItZGV2LWtpdC9uZGsvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9fc2hvcnR3X3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDMEM7QUFDcUI7QUFDUDtBQUN4RDtBQUNPO0FBQ1A7QUFDQTtBQUNBLGdDQUFnQyx3REFBSSxZQUFZLGdFQUFXO0FBQzNELG1CQUFtQjtBQUNuQjtBQUNBO0FBQ087QUFDUCw2QkFBNkIscUVBQVcsR0FBRywrQkFBK0I7QUFDMUUsMkJBQTJCLDRCQUE0QjtBQUN2RDtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9sZmcvR2l0L01hZHRyaXBzL25vZGVfbW9kdWxlcy9Abm9zdHItZGV2LWtpdC9uZGsvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9fc2hvcnR3X3V0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmltcG9ydCB7IGhtYWMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL2htYWMnO1xuaW1wb3J0IHsgY29uY2F0Qnl0ZXMsIHJhbmRvbUJ5dGVzIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy91dGlscyc7XG5pbXBvcnQgeyB3ZWllcnN0cmFzcyB9IGZyb20gJy4vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanMnO1xuLy8gY29ubmVjdHMgbm9ibGUtY3VydmVzIHRvIG5vYmxlLWhhc2hlc1xuZXhwb3J0IGZ1bmN0aW9uIGdldEhhc2goaGFzaCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGhhc2gsXG4gICAgICAgIGhtYWM6IChrZXksIC4uLm1zZ3MpID0+IGhtYWMoaGFzaCwga2V5LCBjb25jYXRCeXRlcyguLi5tc2dzKSksXG4gICAgICAgIHJhbmRvbUJ5dGVzLFxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ3VydmUoY3VydmVEZWYsIGRlZkhhc2gpIHtcbiAgICBjb25zdCBjcmVhdGUgPSAoaGFzaCkgPT4gd2VpZXJzdHJhc3MoeyAuLi5jdXJ2ZURlZiwgLi4uZ2V0SGFzaChoYXNoKSB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IC4uLmNyZWF0ZShkZWZIYXNoKSwgY3JlYXRlIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3Nob3J0d191dGlscy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/_shortw_utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/curve.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/curve.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   validateBasic: () => (/* binding */ validateBasic),\n/* harmony export */   wNAF: () => (/* binding */ wNAF)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modular.js */ \"(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Abelian group utilities\n\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n// Elliptic curve multiplication of Point by scalar. Fragile.\n// Scalars should always be less than curve order: this should be checked inside of a curve itself.\n// Creates precomputation tables for fast multiplication:\n// - private scalar is split by fixed size windows of W bits\n// - every window point is collected from window's table & added to accumulator\n// - since windows are different, same point inside tables won't be accessed more than once per calc\n// - each multiplication is 'Math.ceil(CURVE_ORDER / ùëä) + 1' point additions (fixed for any scalar)\n// - +1 window is neccessary for wNAF\n// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow\n// windows to be in different memory locations\nfunction wNAF(c, bits) {\n    const constTimeNegate = (condition, item) => {\n        const neg = item.negate();\n        return condition ? neg : item;\n    };\n    const opts = (W) => {\n        const windows = Math.ceil(bits / W) + 1; // +1, because\n        const windowSize = 2 ** (W - 1); // -1 because we skip zero\n        return { windows, windowSize };\n    };\n    return {\n        constTimeNegate,\n        // non-const time multiplication ladder\n        unsafeLadder(elm, n) {\n            let p = c.ZERO;\n            let d = elm;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(ùëä‚àí1) * (Math.ceil(ùëõ / ùëä) + 1), where:\n         * - ùëä is the window size\n         * - ùëõ is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @returns precomputed point tables flattened to a single array\n         */\n        precomputeWindow(elm, W) {\n            const { windows, windowSize } = opts(W);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for (let window = 0; window < windows; window++) {\n                base = p;\n                points.push(base);\n                // =1, because we skip zero\n                for (let i = 1; i < windowSize; i++) {\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */\n        wNAF(W, precomputes, n) {\n            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n            // But need to carefully remove other checks before wNAF. ORDER == bits here\n            const { windows, windowSize } = opts(W);\n            let p = c.ZERO;\n            let f = c.BASE;\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for (let window = 0; window < windows; window++) {\n                const offset = window * windowSize;\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n                // there is negate now: it is possible that negated element from low value\n                // would be the same as high element, which will create carry into next window.\n                // It's not obvious how this can fail, but still worth investigating later.\n                // Check if we're onto Zero point.\n                // Add random point inside current window to f.\n                const offset1 = offset;\n                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n                const cond1 = window % 2 !== 0;\n                const cond2 = wbits < 0;\n                if (wbits === 0) {\n                    // The most important part for const-time getPublicKey\n                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n                }\n                else {\n                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n                }\n            }\n            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n            // Even if the variable is still unused, there are some checks which will\n            // throw an exception, so compiler needs to prove they won't happen, which is hard.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return { p, f };\n        },\n        wNAFCached(P, precomputesMap, n, transform) {\n            // @ts-ignore\n            const W = P._WINDOW_SIZE || 1;\n            // Calculate precomputes on a first run, reuse them after\n            let comp = precomputesMap.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1) {\n                    precomputesMap.set(P, transform(comp));\n                }\n            }\n            return this.wNAF(W, comp, n);\n        },\n    };\n}\nfunction validateBasic(curve) {\n    (0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.validateField)(curve.Fp);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject)(curve, {\n        n: 'bigint',\n        h: 'bigint',\n        Gx: 'field',\n        Gy: 'field',\n    }, {\n        nBitLength: 'isSafeInteger',\n        nByteLength: 'isSafeInteger',\n    });\n    // Set defaults\n    return Object.freeze({\n        ...(0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.nLength)(curve.n, curve.nBitLength),\n        ...curve,\n        ...{ p: curve.Fp.ORDER },\n    });\n}\n//# sourceMappingURL=curve.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9zdHItZGV2LWtpdC9uZGsvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9jdXJ2ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNzRDtBQUNWO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pELHlDQUF5QztBQUN6QyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsa0JBQWtCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxnQkFBZ0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQSxpQ0FBaUMsa0JBQWtCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDTztBQUNQLElBQUksMERBQWE7QUFDakIsSUFBSSx5REFBYztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxXQUFXLG9EQUFPO0FBQ2xCO0FBQ0EsYUFBYSxtQkFBbUI7QUFDaEMsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2xmZy9HaXQvTWFkdHJpcHMvbm9kZV9tb2R1bGVzL0Bub3N0ci1kZXYta2l0L25kay9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L2N1cnZlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIEFiZWxpYW4gZ3JvdXAgdXRpbGl0aWVzXG5pbXBvcnQgeyB2YWxpZGF0ZUZpZWxkLCBuTGVuZ3RoIH0gZnJvbSAnLi9tb2R1bGFyLmpzJztcbmltcG9ydCB7IHZhbGlkYXRlT2JqZWN0IH0gZnJvbSAnLi91dGlscy5qcyc7XG5jb25zdCBfMG4gPSBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSBCaWdJbnQoMSk7XG4vLyBFbGxpcHRpYyBjdXJ2ZSBtdWx0aXBsaWNhdGlvbiBvZiBQb2ludCBieSBzY2FsYXIuIEZyYWdpbGUuXG4vLyBTY2FsYXJzIHNob3VsZCBhbHdheXMgYmUgbGVzcyB0aGFuIGN1cnZlIG9yZGVyOiB0aGlzIHNob3VsZCBiZSBjaGVja2VkIGluc2lkZSBvZiBhIGN1cnZlIGl0c2VsZi5cbi8vIENyZWF0ZXMgcHJlY29tcHV0YXRpb24gdGFibGVzIGZvciBmYXN0IG11bHRpcGxpY2F0aW9uOlxuLy8gLSBwcml2YXRlIHNjYWxhciBpcyBzcGxpdCBieSBmaXhlZCBzaXplIHdpbmRvd3Mgb2YgVyBiaXRzXG4vLyAtIGV2ZXJ5IHdpbmRvdyBwb2ludCBpcyBjb2xsZWN0ZWQgZnJvbSB3aW5kb3cncyB0YWJsZSAmIGFkZGVkIHRvIGFjY3VtdWxhdG9yXG4vLyAtIHNpbmNlIHdpbmRvd3MgYXJlIGRpZmZlcmVudCwgc2FtZSBwb2ludCBpbnNpZGUgdGFibGVzIHdvbid0IGJlIGFjY2Vzc2VkIG1vcmUgdGhhbiBvbmNlIHBlciBjYWxjXG4vLyAtIGVhY2ggbXVsdGlwbGljYXRpb24gaXMgJ01hdGguY2VpbChDVVJWRV9PUkRFUiAvIPCdkYopICsgMScgcG9pbnQgYWRkaXRpb25zIChmaXhlZCBmb3IgYW55IHNjYWxhcilcbi8vIC0gKzEgd2luZG93IGlzIG5lY2Nlc3NhcnkgZm9yIHdOQUZcbi8vIC0gd05BRiByZWR1Y2VzIHRhYmxlIHNpemU6IDJ4IGxlc3MgbWVtb3J5ICsgMnggZmFzdGVyIGdlbmVyYXRpb24sIGJ1dCAxMCUgc2xvd2VyIG11bHRpcGxpY2F0aW9uXG4vLyBUT0RPOiBSZXNlYXJjaCByZXR1cm5pbmcgMmQgSlMgYXJyYXkgb2Ygd2luZG93cywgaW5zdGVhZCBvZiBhIHNpbmdsZSB3aW5kb3cuIFRoaXMgd291bGQgYWxsb3dcbi8vIHdpbmRvd3MgdG8gYmUgaW4gZGlmZmVyZW50IG1lbW9yeSBsb2NhdGlvbnNcbmV4cG9ydCBmdW5jdGlvbiB3TkFGKGMsIGJpdHMpIHtcbiAgICBjb25zdCBjb25zdFRpbWVOZWdhdGUgPSAoY29uZGl0aW9uLCBpdGVtKSA9PiB7XG4gICAgICAgIGNvbnN0IG5lZyA9IGl0ZW0ubmVnYXRlKCk7XG4gICAgICAgIHJldHVybiBjb25kaXRpb24gPyBuZWcgOiBpdGVtO1xuICAgIH07XG4gICAgY29uc3Qgb3B0cyA9IChXKSA9PiB7XG4gICAgICAgIGNvbnN0IHdpbmRvd3MgPSBNYXRoLmNlaWwoYml0cyAvIFcpICsgMTsgLy8gKzEsIGJlY2F1c2VcbiAgICAgICAgY29uc3Qgd2luZG93U2l6ZSA9IDIgKiogKFcgLSAxKTsgLy8gLTEgYmVjYXVzZSB3ZSBza2lwIHplcm9cbiAgICAgICAgcmV0dXJuIHsgd2luZG93cywgd2luZG93U2l6ZSB9O1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29uc3RUaW1lTmVnYXRlLFxuICAgICAgICAvLyBub24tY29uc3QgdGltZSBtdWx0aXBsaWNhdGlvbiBsYWRkZXJcbiAgICAgICAgdW5zYWZlTGFkZGVyKGVsbSwgbikge1xuICAgICAgICAgICAgbGV0IHAgPSBjLlpFUk87XG4gICAgICAgICAgICBsZXQgZCA9IGVsbTtcbiAgICAgICAgICAgIHdoaWxlIChuID4gXzBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKG4gJiBfMW4pXG4gICAgICAgICAgICAgICAgICAgIHAgPSBwLmFkZChkKTtcbiAgICAgICAgICAgICAgICBkID0gZC5kb3VibGUoKTtcbiAgICAgICAgICAgICAgICBuID4+PSBfMW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSB3TkFGIHByZWNvbXB1dGF0aW9uIHdpbmRvdy4gVXNlZCBmb3IgY2FjaGluZy5cbiAgICAgICAgICogRGVmYXVsdCB3aW5kb3cgc2l6ZSBpcyBzZXQgYnkgYHV0aWxzLnByZWNvbXB1dGUoKWAgYW5kIGlzIGVxdWFsIHRvIDguXG4gICAgICAgICAqIE51bWJlciBvZiBwcmVjb21wdXRlZCBwb2ludHMgZGVwZW5kcyBvbiB0aGUgY3VydmUgc2l6ZTpcbiAgICAgICAgICogMl4o8J2RiuKIkjEpICogKE1hdGguY2VpbCjwnZGbIC8g8J2RiikgKyAxKSwgd2hlcmU6XG4gICAgICAgICAqIC0g8J2RiiBpcyB0aGUgd2luZG93IHNpemVcbiAgICAgICAgICogLSDwnZGbIGlzIHRoZSBiaXRsZW5ndGggb2YgdGhlIGN1cnZlIG9yZGVyLlxuICAgICAgICAgKiBGb3IgYSAyNTYtYml0IGN1cnZlIGFuZCB3aW5kb3cgc2l6ZSA4LCB0aGUgbnVtYmVyIG9mIHByZWNvbXB1dGVkIHBvaW50cyBpcyAxMjggKiAzMyA9IDQyMjQuXG4gICAgICAgICAqIEByZXR1cm5zIHByZWNvbXB1dGVkIHBvaW50IHRhYmxlcyBmbGF0dGVuZWQgdG8gYSBzaW5nbGUgYXJyYXlcbiAgICAgICAgICovXG4gICAgICAgIHByZWNvbXB1dGVXaW5kb3coZWxtLCBXKSB7XG4gICAgICAgICAgICBjb25zdCB7IHdpbmRvd3MsIHdpbmRvd1NpemUgfSA9IG9wdHMoVyk7XG4gICAgICAgICAgICBjb25zdCBwb2ludHMgPSBbXTtcbiAgICAgICAgICAgIGxldCBwID0gZWxtO1xuICAgICAgICAgICAgbGV0IGJhc2UgPSBwO1xuICAgICAgICAgICAgZm9yIChsZXQgd2luZG93ID0gMDsgd2luZG93IDwgd2luZG93czsgd2luZG93KyspIHtcbiAgICAgICAgICAgICAgICBiYXNlID0gcDtcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaChiYXNlKTtcbiAgICAgICAgICAgICAgICAvLyA9MSwgYmVjYXVzZSB3ZSBza2lwIHplcm9cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHdpbmRvd1NpemU7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBiYXNlID0gYmFzZS5hZGQocCk7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGJhc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwID0gYmFzZS5kb3VibGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwb2ludHM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbXBsZW1lbnRzIGVjIG11bHRpcGxpY2F0aW9uIHVzaW5nIHByZWNvbXB1dGVkIHRhYmxlcyBhbmQgdy1hcnkgbm9uLWFkamFjZW50IGZvcm0uXG4gICAgICAgICAqIEBwYXJhbSBXIHdpbmRvdyBzaXplXG4gICAgICAgICAqIEBwYXJhbSBwcmVjb21wdXRlcyBwcmVjb21wdXRlZCB0YWJsZXNcbiAgICAgICAgICogQHBhcmFtIG4gc2NhbGFyICh3ZSBkb24ndCBjaGVjayBoZXJlLCBidXQgc2hvdWxkIGJlIGxlc3MgdGhhbiBjdXJ2ZSBvcmRlcilcbiAgICAgICAgICogQHJldHVybnMgcmVhbCBhbmQgZmFrZSAoZm9yIGNvbnN0LXRpbWUpIHBvaW50c1xuICAgICAgICAgKi9cbiAgICAgICAgd05BRihXLCBwcmVjb21wdXRlcywgbikge1xuICAgICAgICAgICAgLy8gVE9ETzogbWF5YmUgY2hlY2sgdGhhdCBzY2FsYXIgaXMgbGVzcyB0aGFuIGdyb3VwIG9yZGVyPyB3TkFGIGJlaGF2aW91cyBpcyB1bmRlZmluZWQgb3RoZXJ3aXNlXG4gICAgICAgICAgICAvLyBCdXQgbmVlZCB0byBjYXJlZnVsbHkgcmVtb3ZlIG90aGVyIGNoZWNrcyBiZWZvcmUgd05BRi4gT1JERVIgPT0gYml0cyBoZXJlXG4gICAgICAgICAgICBjb25zdCB7IHdpbmRvd3MsIHdpbmRvd1NpemUgfSA9IG9wdHMoVyk7XG4gICAgICAgICAgICBsZXQgcCA9IGMuWkVSTztcbiAgICAgICAgICAgIGxldCBmID0gYy5CQVNFO1xuICAgICAgICAgICAgY29uc3QgbWFzayA9IEJpZ0ludCgyICoqIFcgLSAxKTsgLy8gQ3JlYXRlIG1hc2sgd2l0aCBXIG9uZXM6IDBiMTExMSBmb3IgVz00IGV0Yy5cbiAgICAgICAgICAgIGNvbnN0IG1heE51bWJlciA9IDIgKiogVztcbiAgICAgICAgICAgIGNvbnN0IHNoaWZ0QnkgPSBCaWdJbnQoVyk7XG4gICAgICAgICAgICBmb3IgKGxldCB3aW5kb3cgPSAwOyB3aW5kb3cgPCB3aW5kb3dzOyB3aW5kb3crKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHdpbmRvdyAqIHdpbmRvd1NpemU7XG4gICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBXIGJpdHMuXG4gICAgICAgICAgICAgICAgbGV0IHdiaXRzID0gTnVtYmVyKG4gJiBtYXNrKTtcbiAgICAgICAgICAgICAgICAvLyBTaGlmdCBudW1iZXIgYnkgVyBiaXRzLlxuICAgICAgICAgICAgICAgIG4gPj49IHNoaWZ0Qnk7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGJpdHMgYXJlIGJpZ2dlciB0aGFuIG1heCBzaXplLCB3ZSdsbCBzcGxpdCB0aG9zZS5cbiAgICAgICAgICAgICAgICAvLyArMjI0ID0+IDI1NiAtIDMyXG4gICAgICAgICAgICAgICAgaWYgKHdiaXRzID4gd2luZG93U2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICB3Yml0cyAtPSBtYXhOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgIG4gKz0gXzFuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGNvZGUgd2FzIGZpcnN0IHdyaXR0ZW4gd2l0aCBhc3N1bXB0aW9uIHRoYXQgJ2YnIGFuZCAncCcgd2lsbCBuZXZlciBiZSBpbmZpbml0eSBwb2ludDpcbiAgICAgICAgICAgICAgICAvLyBzaW5jZSBlYWNoIGFkZGl0aW9uIGlzIG11bHRpcGxpZWQgYnkgMiAqKiBXLCBpdCBjYW5ub3QgY2FuY2VsIGVhY2ggb3RoZXIuIEhvd2V2ZXIsXG4gICAgICAgICAgICAgICAgLy8gdGhlcmUgaXMgbmVnYXRlIG5vdzogaXQgaXMgcG9zc2libGUgdGhhdCBuZWdhdGVkIGVsZW1lbnQgZnJvbSBsb3cgdmFsdWVcbiAgICAgICAgICAgICAgICAvLyB3b3VsZCBiZSB0aGUgc2FtZSBhcyBoaWdoIGVsZW1lbnQsIHdoaWNoIHdpbGwgY3JlYXRlIGNhcnJ5IGludG8gbmV4dCB3aW5kb3cuXG4gICAgICAgICAgICAgICAgLy8gSXQncyBub3Qgb2J2aW91cyBob3cgdGhpcyBjYW4gZmFpbCwgYnV0IHN0aWxsIHdvcnRoIGludmVzdGlnYXRpbmcgbGF0ZXIuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2UncmUgb250byBaZXJvIHBvaW50LlxuICAgICAgICAgICAgICAgIC8vIEFkZCByYW5kb20gcG9pbnQgaW5zaWRlIGN1cnJlbnQgd2luZG93IHRvIGYuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0MSA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQyID0gb2Zmc2V0ICsgTWF0aC5hYnMod2JpdHMpIC0gMTsgLy8gLTEgYmVjYXVzZSB3ZSBza2lwIHplcm9cbiAgICAgICAgICAgICAgICBjb25zdCBjb25kMSA9IHdpbmRvdyAlIDIgIT09IDA7XG4gICAgICAgICAgICAgICAgY29uc3QgY29uZDIgPSB3Yml0cyA8IDA7XG4gICAgICAgICAgICAgICAgaWYgKHdiaXRzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBtb3N0IGltcG9ydGFudCBwYXJ0IGZvciBjb25zdC10aW1lIGdldFB1YmxpY0tleVxuICAgICAgICAgICAgICAgICAgICBmID0gZi5hZGQoY29uc3RUaW1lTmVnYXRlKGNvbmQxLCBwcmVjb21wdXRlc1tvZmZzZXQxXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAuYWRkKGNvbnN0VGltZU5lZ2F0ZShjb25kMiwgcHJlY29tcHV0ZXNbb2Zmc2V0Ml0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBKSVQtY29tcGlsZXIgc2hvdWxkIG5vdCBlbGltaW5hdGUgZiBoZXJlLCBzaW5jZSBpdCB3aWxsIGxhdGVyIGJlIHVzZWQgaW4gbm9ybWFsaXplWigpXG4gICAgICAgICAgICAvLyBFdmVuIGlmIHRoZSB2YXJpYWJsZSBpcyBzdGlsbCB1bnVzZWQsIHRoZXJlIGFyZSBzb21lIGNoZWNrcyB3aGljaCB3aWxsXG4gICAgICAgICAgICAvLyB0aHJvdyBhbiBleGNlcHRpb24sIHNvIGNvbXBpbGVyIG5lZWRzIHRvIHByb3ZlIHRoZXkgd29uJ3QgaGFwcGVuLCB3aGljaCBpcyBoYXJkLlxuICAgICAgICAgICAgLy8gQXQgdGhpcyBwb2ludCB0aGVyZSBpcyBhIHdheSB0byBGIGJlIGluZmluaXR5LXBvaW50IGV2ZW4gaWYgcCBpcyBub3QsXG4gICAgICAgICAgICAvLyB3aGljaCBtYWtlcyBpdCBsZXNzIGNvbnN0LXRpbWU6IGFyb3VuZCAxIGJpZ2ludCBtdWx0aXBseS5cbiAgICAgICAgICAgIHJldHVybiB7IHAsIGYgfTtcbiAgICAgICAgfSxcbiAgICAgICAgd05BRkNhY2hlZChQLCBwcmVjb21wdXRlc01hcCwgbiwgdHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBjb25zdCBXID0gUC5fV0lORE9XX1NJWkUgfHwgMTtcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBwcmVjb21wdXRlcyBvbiBhIGZpcnN0IHJ1biwgcmV1c2UgdGhlbSBhZnRlclxuICAgICAgICAgICAgbGV0IGNvbXAgPSBwcmVjb21wdXRlc01hcC5nZXQoUCk7XG4gICAgICAgICAgICBpZiAoIWNvbXApIHtcbiAgICAgICAgICAgICAgICBjb21wID0gdGhpcy5wcmVjb21wdXRlV2luZG93KFAsIFcpO1xuICAgICAgICAgICAgICAgIGlmIChXICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZWNvbXB1dGVzTWFwLnNldChQLCB0cmFuc2Zvcm0oY29tcCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLndOQUYoVywgY29tcCwgbik7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUJhc2ljKGN1cnZlKSB7XG4gICAgdmFsaWRhdGVGaWVsZChjdXJ2ZS5GcCk7XG4gICAgdmFsaWRhdGVPYmplY3QoY3VydmUsIHtcbiAgICAgICAgbjogJ2JpZ2ludCcsXG4gICAgICAgIGg6ICdiaWdpbnQnLFxuICAgICAgICBHeDogJ2ZpZWxkJyxcbiAgICAgICAgR3k6ICdmaWVsZCcsXG4gICAgfSwge1xuICAgICAgICBuQml0TGVuZ3RoOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgICAgIG5CeXRlTGVuZ3RoOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgfSk7XG4gICAgLy8gU2V0IGRlZmF1bHRzXG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuICAgICAgICAuLi5uTGVuZ3RoKGN1cnZlLm4sIGN1cnZlLm5CaXRMZW5ndGgpLFxuICAgICAgICAuLi5jdXJ2ZSxcbiAgICAgICAgLi4ueyBwOiBjdXJ2ZS5GcC5PUkRFUiB9LFxuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3VydmUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/curve.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/hash-to-curve.js":
/*!***************************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/hash-to-curve.js ***!
  \***************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createHasher: () => (/* binding */ createHasher),\n/* harmony export */   expand_message_xmd: () => (/* binding */ expand_message_xmd),\n/* harmony export */   expand_message_xof: () => (/* binding */ expand_message_xof),\n/* harmony export */   hash_to_field: () => (/* binding */ hash_to_field),\n/* harmony export */   isogenyMap: () => (/* binding */ isogenyMap)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modular.js */ \"(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/utils.js\");\n\n\nfunction validateDST(dst) {\n    if (dst instanceof Uint8Array)\n        return dst;\n    if (typeof dst === 'string')\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)(dst);\n    throw new Error('DST must be Uint8Array or string');\n}\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE;\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value, length) {\n    if (value < 0 || value >= 1 << (8 * length)) {\n        throw new Error(`bad I2OSP call: value=${value} length=${length}`);\n    }\n    const res = Array.from({ length }).fill(0);\n    for (let i = length - 1; i >= 0; i--) {\n        res[i] = value & 0xff;\n        value >>>= 8;\n    }\n    return new Uint8Array(res);\n}\nfunction strxor(a, b) {\n    const arr = new Uint8Array(a.length);\n    for (let i = 0; i < a.length; i++) {\n        arr[i] = a[i] ^ b[i];\n    }\n    return arr;\n}\nfunction isBytes(item) {\n    if (!(item instanceof Uint8Array))\n        throw new Error('Uint8Array expected');\n}\nfunction isNum(item) {\n    if (!Number.isSafeInteger(item))\n        throw new Error('number expected');\n}\n// Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1\nfunction expand_message_xmd(msg, DST, lenInBytes, H) {\n    isBytes(msg);\n    isBytes(DST);\n    isNum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    if (DST.length > 255)\n        DST = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)('H2C-OVERSIZE-DST-'), DST));\n    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n    const ell = Math.ceil(lenInBytes / b_in_bytes);\n    if (ell > 255)\n        throw new Error('Invalid xmd length');\n    const DST_prime = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(DST, i2osp(DST.length, 1));\n    const Z_pad = i2osp(0, r_in_bytes);\n    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n    const b = new Array(ell);\n    const b_0 = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n    b[0] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(b_0, i2osp(1, 1), DST_prime));\n    for (let i = 1; i <= ell; i++) {\n        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];\n        b[i] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...args));\n    }\n    const pseudo_random_bytes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...b);\n    return pseudo_random_bytes.slice(0, lenInBytes);\n}\n// Produces a uniformly random byte string using an extendable-output function (XOF) H.\n// 1. The collision resistance of H MUST be at least k bits.\n// 2. H MUST be an XOF that has been proved indifferentiable from\n//    a random oracle under a reasonable cryptographic assumption.\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2\nfunction expand_message_xof(msg, DST, lenInBytes, k, H) {\n    isBytes(msg);\n    isBytes(DST);\n    isNum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n    if (DST.length > 255) {\n        const dkLen = Math.ceil((2 * k) / 8);\n        DST = H.create({ dkLen }).update((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)('H2C-OVERSIZE-DST-')).update(DST).digest();\n    }\n    if (lenInBytes > 65535 || DST.length > 255)\n        throw new Error('expand_message_xof: invalid lenInBytes');\n    return (H.create({ dkLen: lenInBytes })\n        .update(msg)\n        .update(i2osp(lenInBytes, 2))\n        // 2. DST_prime = DST || I2OSP(len(DST), 1)\n        .update(DST)\n        .update(i2osp(DST.length, 1))\n        .digest());\n}\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F\n * https://www.rfc-editor.org/rfc/rfc9380#section-5.2\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */\nfunction hash_to_field(msg, count, options) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(options, {\n        DST: 'stringOrUint8Array',\n        p: 'bigint',\n        m: 'isSafeInteger',\n        k: 'isSafeInteger',\n        hash: 'hash',\n    });\n    const { p, k, m, hash, expand, DST: _DST } = options;\n    isBytes(msg);\n    isNum(count);\n    const DST = validateDST(_DST);\n    const log2p = p.toString(2).length;\n    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n    const len_in_bytes = count * m * L;\n    let prb; // pseudo_random_bytes\n    if (expand === 'xmd') {\n        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n    }\n    else if (expand === 'xof') {\n        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n    }\n    else if (expand === '_internal_pass') {\n        // for internal tests only\n        prb = msg;\n    }\n    else {\n        throw new Error('expand must be \"xmd\" or \"xof\"');\n    }\n    const u = new Array(count);\n    for (let i = 0; i < count; i++) {\n        const e = new Array(m);\n        for (let j = 0; j < m; j++) {\n            const elm_offset = L * (j + i * m);\n            const tv = prb.subarray(elm_offset, elm_offset + L);\n            e[j] = (0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.mod)(os2ip(tv), p);\n        }\n        u[i] = e;\n    }\n    return u;\n}\nfunction isogenyMap(field, map) {\n    // Make same order as in spec\n    const COEFF = map.map((i) => Array.from(i).reverse());\n    return (x, y) => {\n        const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));\n        x = field.div(xNum, xDen); // xNum / xDen\n        y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)\n        return { x, y };\n    };\n}\nfunction createHasher(Point, mapToCurve, def) {\n    if (typeof mapToCurve !== 'function')\n        throw new Error('mapToCurve() must be defined');\n    return {\n        // Encodes byte string to elliptic curve.\n        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        hashToCurve(msg, options) {\n            const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });\n            const u0 = Point.fromAffine(mapToCurve(u[0]));\n            const u1 = Point.fromAffine(mapToCurve(u[1]));\n            const P = u0.add(u1).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n        // Encodes byte string to elliptic curve.\n        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        encodeToCurve(msg, options) {\n            const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });\n            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n    };\n}\n//# sourceMappingURL=hash-to-curve.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9zdHItZGV2LWtpdC9uZGsvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBbUM7QUFDb0Q7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNEQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLGNBQWMsc0RBQWU7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsaURBQWlELE9BQU8sU0FBUyxPQUFPO0FBQ3hFO0FBQ0EsNkJBQTZCLFFBQVE7QUFDckMsNkJBQTZCLFFBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNEQUFXLENBQUMsc0RBQVc7QUFDdkMsWUFBWSw4Q0FBOEM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNEQUFXO0FBQ2pDO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0Esa0JBQWtCLHNEQUFXO0FBQzdCLGFBQWEsc0RBQVc7QUFDeEIsb0JBQW9CLFVBQVU7QUFDOUI7QUFDQSxpQkFBaUIsc0RBQVc7QUFDNUI7QUFDQSxnQ0FBZ0Msc0RBQVc7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE9BQU8sU0FBUyxzREFBVztBQUNwRDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw2RUFBNkU7QUFDakc7QUFDQTtBQUNPO0FBQ1AsSUFBSSx5REFBYztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFlBQVksbUNBQW1DO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQSxtQkFBbUIsZ0RBQUc7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsaURBQWlEO0FBQ2pELGlCQUFpQjtBQUNqQjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsa0NBQWtDO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHdDQUF3QztBQUN0RjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9sZmcvR2l0L01hZHRyaXBzL25vZGVfbW9kdWxlcy9Abm9zdHItZGV2LWtpdC9uZGsvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IG1vZCB9IGZyb20gJy4vbW9kdWxhci5qcyc7XG5pbXBvcnQgeyBieXRlc1RvTnVtYmVyQkUsIGNvbmNhdEJ5dGVzLCB1dGY4VG9CeXRlcywgdmFsaWRhdGVPYmplY3QgfSBmcm9tICcuL3V0aWxzLmpzJztcbmZ1bmN0aW9uIHZhbGlkYXRlRFNUKGRzdCkge1xuICAgIGlmIChkc3QgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxuICAgICAgICByZXR1cm4gZHN0O1xuICAgIGlmICh0eXBlb2YgZHN0ID09PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKGRzdCk7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdEU1QgbXVzdCBiZSBVaW50OEFycmF5IG9yIHN0cmluZycpO1xufVxuLy8gT2N0ZXQgU3RyZWFtIHRvIEludGVnZXIuIFwic3BlY1wiIGltcGxlbWVudGF0aW9uIG9mIG9zMmlwIGlzIDIuNXggc2xvd2VyIHZzIGJ5dGVzVG9OdW1iZXJCRS5cbmNvbnN0IG9zMmlwID0gYnl0ZXNUb051bWJlckJFO1xuLy8gSW50ZWdlciB0byBPY3RldCBTdHJlYW0gKG51bWJlclRvQnl0ZXNCRSlcbmZ1bmN0aW9uIGkyb3NwKHZhbHVlLCBsZW5ndGgpIHtcbiAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID49IDEgPDwgKDggKiBsZW5ndGgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgYmFkIEkyT1NQIGNhbGw6IHZhbHVlPSR7dmFsdWV9IGxlbmd0aD0ke2xlbmd0aH1gKTtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gQXJyYXkuZnJvbSh7IGxlbmd0aCB9KS5maWxsKDApO1xuICAgIGZvciAobGV0IGkgPSBsZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICByZXNbaV0gPSB2YWx1ZSAmIDB4ZmY7XG4gICAgICAgIHZhbHVlID4+Pj0gODtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHJlcyk7XG59XG5mdW5jdGlvbiBzdHJ4b3IoYSwgYikge1xuICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KGEubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyW2ldID0gYVtpXSBeIGJbaV07XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG59XG5mdW5jdGlvbiBpc0J5dGVzKGl0ZW0pIHtcbiAgICBpZiAoIShpdGVtIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xufVxuZnVuY3Rpb24gaXNOdW0oaXRlbSkge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoaXRlbSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbnVtYmVyIGV4cGVjdGVkJyk7XG59XG4vLyBQcm9kdWNlcyBhIHVuaWZvcm1seSByYW5kb20gYnl0ZSBzdHJpbmcgdXNpbmcgYSBjcnlwdG9ncmFwaGljIGhhc2ggZnVuY3Rpb24gSCB0aGF0IG91dHB1dHMgYiBiaXRzXG4vLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMy4xXG5leHBvcnQgZnVuY3Rpb24gZXhwYW5kX21lc3NhZ2VfeG1kKG1zZywgRFNULCBsZW5JbkJ5dGVzLCBIKSB7XG4gICAgaXNCeXRlcyhtc2cpO1xuICAgIGlzQnl0ZXMoRFNUKTtcbiAgICBpc051bShsZW5JbkJ5dGVzKTtcbiAgICAvLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMy4zXG4gICAgaWYgKERTVC5sZW5ndGggPiAyNTUpXG4gICAgICAgIERTVCA9IEgoY29uY2F0Qnl0ZXModXRmOFRvQnl0ZXMoJ0gyQy1PVkVSU0laRS1EU1QtJyksIERTVCkpO1xuICAgIGNvbnN0IHsgb3V0cHV0TGVuOiBiX2luX2J5dGVzLCBibG9ja0xlbjogcl9pbl9ieXRlcyB9ID0gSDtcbiAgICBjb25zdCBlbGwgPSBNYXRoLmNlaWwobGVuSW5CeXRlcyAvIGJfaW5fYnl0ZXMpO1xuICAgIGlmIChlbGwgPiAyNTUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB4bWQgbGVuZ3RoJyk7XG4gICAgY29uc3QgRFNUX3ByaW1lID0gY29uY2F0Qnl0ZXMoRFNULCBpMm9zcChEU1QubGVuZ3RoLCAxKSk7XG4gICAgY29uc3QgWl9wYWQgPSBpMm9zcCgwLCByX2luX2J5dGVzKTtcbiAgICBjb25zdCBsX2lfYl9zdHIgPSBpMm9zcChsZW5JbkJ5dGVzLCAyKTsgLy8gbGVuX2luX2J5dGVzX3N0clxuICAgIGNvbnN0IGIgPSBuZXcgQXJyYXkoZWxsKTtcbiAgICBjb25zdCBiXzAgPSBIKGNvbmNhdEJ5dGVzKFpfcGFkLCBtc2csIGxfaV9iX3N0ciwgaTJvc3AoMCwgMSksIERTVF9wcmltZSkpO1xuICAgIGJbMF0gPSBIKGNvbmNhdEJ5dGVzKGJfMCwgaTJvc3AoMSwgMSksIERTVF9wcmltZSkpO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IGVsbDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBbc3RyeG9yKGJfMCwgYltpIC0gMV0pLCBpMm9zcChpICsgMSwgMSksIERTVF9wcmltZV07XG4gICAgICAgIGJbaV0gPSBIKGNvbmNhdEJ5dGVzKC4uLmFyZ3MpKTtcbiAgICB9XG4gICAgY29uc3QgcHNldWRvX3JhbmRvbV9ieXRlcyA9IGNvbmNhdEJ5dGVzKC4uLmIpO1xuICAgIHJldHVybiBwc2V1ZG9fcmFuZG9tX2J5dGVzLnNsaWNlKDAsIGxlbkluQnl0ZXMpO1xufVxuLy8gUHJvZHVjZXMgYSB1bmlmb3JtbHkgcmFuZG9tIGJ5dGUgc3RyaW5nIHVzaW5nIGFuIGV4dGVuZGFibGUtb3V0cHV0IGZ1bmN0aW9uIChYT0YpIEguXG4vLyAxLiBUaGUgY29sbGlzaW9uIHJlc2lzdGFuY2Ugb2YgSCBNVVNUIGJlIGF0IGxlYXN0IGsgYml0cy5cbi8vIDIuIEggTVVTVCBiZSBhbiBYT0YgdGhhdCBoYXMgYmVlbiBwcm92ZWQgaW5kaWZmZXJlbnRpYWJsZSBmcm9tXG4vLyAgICBhIHJhbmRvbSBvcmFjbGUgdW5kZXIgYSByZWFzb25hYmxlIGNyeXB0b2dyYXBoaWMgYXNzdW1wdGlvbi5cbi8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4zLjJcbmV4cG9ydCBmdW5jdGlvbiBleHBhbmRfbWVzc2FnZV94b2YobXNnLCBEU1QsIGxlbkluQnl0ZXMsIGssIEgpIHtcbiAgICBpc0J5dGVzKG1zZyk7XG4gICAgaXNCeXRlcyhEU1QpO1xuICAgIGlzTnVtKGxlbkluQnl0ZXMpO1xuICAgIC8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4zLjNcbiAgICAvLyBEU1QgPSBIKCdIMkMtT1ZFUlNJWkUtRFNULScgfHwgYV92ZXJ5X2xvbmdfRFNULCBNYXRoLmNlaWwoKGxlbkluQnl0ZXMgKiBrKSAvIDgpKTtcbiAgICBpZiAoRFNULmxlbmd0aCA+IDI1NSkge1xuICAgICAgICBjb25zdCBka0xlbiA9IE1hdGguY2VpbCgoMiAqIGspIC8gOCk7XG4gICAgICAgIERTVCA9IEguY3JlYXRlKHsgZGtMZW4gfSkudXBkYXRlKHV0ZjhUb0J5dGVzKCdIMkMtT1ZFUlNJWkUtRFNULScpKS51cGRhdGUoRFNUKS5kaWdlc3QoKTtcbiAgICB9XG4gICAgaWYgKGxlbkluQnl0ZXMgPiA2NTUzNSB8fCBEU1QubGVuZ3RoID4gMjU1KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGFuZF9tZXNzYWdlX3hvZjogaW52YWxpZCBsZW5JbkJ5dGVzJyk7XG4gICAgcmV0dXJuIChILmNyZWF0ZSh7IGRrTGVuOiBsZW5JbkJ5dGVzIH0pXG4gICAgICAgIC51cGRhdGUobXNnKVxuICAgICAgICAudXBkYXRlKGkyb3NwKGxlbkluQnl0ZXMsIDIpKVxuICAgICAgICAvLyAyLiBEU1RfcHJpbWUgPSBEU1QgfHwgSTJPU1AobGVuKERTVCksIDEpXG4gICAgICAgIC51cGRhdGUoRFNUKVxuICAgICAgICAudXBkYXRlKGkyb3NwKERTVC5sZW5ndGgsIDEpKVxuICAgICAgICAuZGlnZXN0KCkpO1xufVxuLyoqXG4gKiBIYXNoZXMgYXJiaXRyYXJ5LWxlbmd0aCBieXRlIHN0cmluZ3MgdG8gYSBsaXN0IG9mIG9uZSBvciBtb3JlIGVsZW1lbnRzIG9mIGEgZmluaXRlIGZpZWxkIEZcbiAqIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4yXG4gKiBAcGFyYW0gbXNnIGEgYnl0ZSBzdHJpbmcgY29udGFpbmluZyB0aGUgbWVzc2FnZSB0byBoYXNoXG4gKiBAcGFyYW0gY291bnQgdGhlIG51bWJlciBvZiBlbGVtZW50cyBvZiBGIHRvIG91dHB1dFxuICogQHBhcmFtIG9wdGlvbnMgYHtEU1Q6IHN0cmluZywgcDogYmlnaW50LCBtOiBudW1iZXIsIGs6IG51bWJlciwgZXhwYW5kOiAneG1kJyB8ICd4b2YnLCBoYXNoOiBIfWAsIHNlZSBhYm92ZVxuICogQHJldHVybnMgW3VfMCwgLi4uLCB1Xyhjb3VudCAtIDEpXSwgYSBsaXN0IG9mIGZpZWxkIGVsZW1lbnRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzaF90b19maWVsZChtc2csIGNvdW50LCBvcHRpb25zKSB7XG4gICAgdmFsaWRhdGVPYmplY3Qob3B0aW9ucywge1xuICAgICAgICBEU1Q6ICdzdHJpbmdPclVpbnQ4QXJyYXknLFxuICAgICAgICBwOiAnYmlnaW50JyxcbiAgICAgICAgbTogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBrOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgICAgIGhhc2g6ICdoYXNoJyxcbiAgICB9KTtcbiAgICBjb25zdCB7IHAsIGssIG0sIGhhc2gsIGV4cGFuZCwgRFNUOiBfRFNUIH0gPSBvcHRpb25zO1xuICAgIGlzQnl0ZXMobXNnKTtcbiAgICBpc051bShjb3VudCk7XG4gICAgY29uc3QgRFNUID0gdmFsaWRhdGVEU1QoX0RTVCk7XG4gICAgY29uc3QgbG9nMnAgPSBwLnRvU3RyaW5nKDIpLmxlbmd0aDtcbiAgICBjb25zdCBMID0gTWF0aC5jZWlsKChsb2cycCArIGspIC8gOCk7IC8vIHNlY3Rpb24gNS4xIG9mIGlldGYgZHJhZnQgbGluayBhYm92ZVxuICAgIGNvbnN0IGxlbl9pbl9ieXRlcyA9IGNvdW50ICogbSAqIEw7XG4gICAgbGV0IHByYjsgLy8gcHNldWRvX3JhbmRvbV9ieXRlc1xuICAgIGlmIChleHBhbmQgPT09ICd4bWQnKSB7XG4gICAgICAgIHByYiA9IGV4cGFuZF9tZXNzYWdlX3htZChtc2csIERTVCwgbGVuX2luX2J5dGVzLCBoYXNoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXhwYW5kID09PSAneG9mJykge1xuICAgICAgICBwcmIgPSBleHBhbmRfbWVzc2FnZV94b2YobXNnLCBEU1QsIGxlbl9pbl9ieXRlcywgaywgaGFzaCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV4cGFuZCA9PT0gJ19pbnRlcm5hbF9wYXNzJykge1xuICAgICAgICAvLyBmb3IgaW50ZXJuYWwgdGVzdHMgb25seVxuICAgICAgICBwcmIgPSBtc2c7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGFuZCBtdXN0IGJlIFwieG1kXCIgb3IgXCJ4b2ZcIicpO1xuICAgIH1cbiAgICBjb25zdCB1ID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgY29uc3QgZSA9IG5ldyBBcnJheShtKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGVsbV9vZmZzZXQgPSBMICogKGogKyBpICogbSk7XG4gICAgICAgICAgICBjb25zdCB0diA9IHByYi5zdWJhcnJheShlbG1fb2Zmc2V0LCBlbG1fb2Zmc2V0ICsgTCk7XG4gICAgICAgICAgICBlW2pdID0gbW9kKG9zMmlwKHR2KSwgcCk7XG4gICAgICAgIH1cbiAgICAgICAgdVtpXSA9IGU7XG4gICAgfVxuICAgIHJldHVybiB1O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzb2dlbnlNYXAoZmllbGQsIG1hcCkge1xuICAgIC8vIE1ha2Ugc2FtZSBvcmRlciBhcyBpbiBzcGVjXG4gICAgY29uc3QgQ09FRkYgPSBtYXAubWFwKChpKSA9PiBBcnJheS5mcm9tKGkpLnJldmVyc2UoKSk7XG4gICAgcmV0dXJuICh4LCB5KSA9PiB7XG4gICAgICAgIGNvbnN0IFt4TnVtLCB4RGVuLCB5TnVtLCB5RGVuXSA9IENPRUZGLm1hcCgodmFsKSA9PiB2YWwucmVkdWNlKChhY2MsIGkpID0+IGZpZWxkLmFkZChmaWVsZC5tdWwoYWNjLCB4KSwgaSkpKTtcbiAgICAgICAgeCA9IGZpZWxkLmRpdih4TnVtLCB4RGVuKTsgLy8geE51bSAvIHhEZW5cbiAgICAgICAgeSA9IGZpZWxkLm11bCh5LCBmaWVsZC5kaXYoeU51bSwgeURlbikpOyAvLyB5ICogKHlOdW0gLyB5RGV2KVxuICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVIYXNoZXIoUG9pbnQsIG1hcFRvQ3VydmUsIGRlZikge1xuICAgIGlmICh0eXBlb2YgbWFwVG9DdXJ2ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXBUb0N1cnZlKCkgbXVzdCBiZSBkZWZpbmVkJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLy8gRW5jb2RlcyBieXRlIHN0cmluZyB0byBlbGxpcHRpYyBjdXJ2ZS5cbiAgICAgICAgLy8gaGFzaF90b19jdXJ2ZSBmcm9tIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tM1xuICAgICAgICBoYXNoVG9DdXJ2ZShtc2csIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHUgPSBoYXNoX3RvX2ZpZWxkKG1zZywgMiwgeyAuLi5kZWYsIERTVDogZGVmLkRTVCwgLi4ub3B0aW9ucyB9KTtcbiAgICAgICAgICAgIGNvbnN0IHUwID0gUG9pbnQuZnJvbUFmZmluZShtYXBUb0N1cnZlKHVbMF0pKTtcbiAgICAgICAgICAgIGNvbnN0IHUxID0gUG9pbnQuZnJvbUFmZmluZShtYXBUb0N1cnZlKHVbMV0pKTtcbiAgICAgICAgICAgIGNvbnN0IFAgPSB1MC5hZGQodTEpLmNsZWFyQ29mYWN0b3IoKTtcbiAgICAgICAgICAgIFAuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiBQO1xuICAgICAgICB9LFxuICAgICAgICAvLyBFbmNvZGVzIGJ5dGUgc3RyaW5nIHRvIGVsbGlwdGljIGN1cnZlLlxuICAgICAgICAvLyBlbmNvZGVfdG9fY3VydmUgZnJvbSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTNcbiAgICAgICAgZW5jb2RlVG9DdXJ2ZShtc2csIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHUgPSBoYXNoX3RvX2ZpZWxkKG1zZywgMSwgeyAuLi5kZWYsIERTVDogZGVmLmVuY29kZURTVCwgLi4ub3B0aW9ucyB9KTtcbiAgICAgICAgICAgIGNvbnN0IFAgPSBQb2ludC5mcm9tQWZmaW5lKG1hcFRvQ3VydmUodVswXSkpLmNsZWFyQ29mYWN0b3IoKTtcbiAgICAgICAgICAgIFAuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiBQO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXNoLXRvLWN1cnZlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/hash-to-curve.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/modular.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/modular.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Field: () => (/* binding */ Field),\n/* harmony export */   FpDiv: () => (/* binding */ FpDiv),\n/* harmony export */   FpInvertBatch: () => (/* binding */ FpInvertBatch),\n/* harmony export */   FpIsSquare: () => (/* binding */ FpIsSquare),\n/* harmony export */   FpPow: () => (/* binding */ FpPow),\n/* harmony export */   FpSqrt: () => (/* binding */ FpSqrt),\n/* harmony export */   FpSqrtEven: () => (/* binding */ FpSqrtEven),\n/* harmony export */   FpSqrtOdd: () => (/* binding */ FpSqrtOdd),\n/* harmony export */   getFieldBytesLength: () => (/* binding */ getFieldBytesLength),\n/* harmony export */   getMinHashLength: () => (/* binding */ getMinHashLength),\n/* harmony export */   hashToPrivateScalar: () => (/* binding */ hashToPrivateScalar),\n/* harmony export */   invert: () => (/* binding */ invert),\n/* harmony export */   isNegativeLE: () => (/* binding */ isNegativeLE),\n/* harmony export */   mapHashToField: () => (/* binding */ mapHashToField),\n/* harmony export */   mod: () => (/* binding */ mod),\n/* harmony export */   nLength: () => (/* binding */ nLength),\n/* harmony export */   pow: () => (/* binding */ pow),\n/* harmony export */   pow2: () => (/* binding */ pow2),\n/* harmony export */   tonelliShanks: () => (/* binding */ tonelliShanks),\n/* harmony export */   validateField: () => (/* binding */ validateField)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Utilities for modular arithmetics and finite fields\n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);\n// prettier-ignore\nconst _9n = BigInt(9), _16n = BigInt(16);\n// Calculates a modulo b\nfunction mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\n// TODO: use field version && remove\nfunction pow(num, power, modulo) {\n    if (modulo <= _0n || power < _0n)\n        throw new Error('Expected power/modulo > 0');\n    if (modulo === _1n)\n        return _0n;\n    let res = _1n;\n    while (power > _0n) {\n        if (power & _1n)\n            res = (res * num) % modulo;\n        num = (num * num) % modulo;\n        power >>= _1n;\n    }\n    return res;\n}\n// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)\nfunction pow2(x, power, modulo) {\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n// Inverses number over modulo\nfunction invert(number, modulo) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * Will start an infinite loop if field order P is not prime.\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nfunction tonelliShanks(P) {\n    // Legendre constant: used to calculate Legendre symbol (a | p),\n    // which denotes the value of a^((p-1)/2) (mod p).\n    // (a | p) ‚â° 1    if a is a square (mod p)\n    // (a | p) ‚â° -1   if a is not a square (mod p)\n    // (a | p) ‚â° 0    if a ‚â° 0 (mod p)\n    const legendreC = (P - _1n) / _2n;\n    let Q, S, Z;\n    // Step 1: By factoring out powers of 2 from p - 1,\n    // find q and s such that p - 1 = q*(2^s) with q odd\n    for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)\n        ;\n    // Step 2: Select a non-square z such that (z | p) ‚â° -1 and set c ‚â° zq\n    for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++)\n        ;\n    // Fast-path\n    if (S === 1) {\n        const p1div4 = (P + _1n) / _4n;\n        return function tonelliFast(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Slow-path\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        // Step 0: Check that n is indeed a square: (n | p) should not be ‚â° -1\n        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))\n            throw new Error('Cannot find square root');\n        let r = S;\n        // TODO: will fail at Fp2/etc\n        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n        let x = Fp.pow(n, Q1div2); // first guess at the square root\n        let b = Fp.pow(n, Q); // first guess at the fudge factor\n        while (!Fp.eql(b, Fp.ONE)) {\n            if (Fp.eql(b, Fp.ZERO))\n                return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n            // Find m such b^(2^m)==1\n            let m = 1;\n            for (let t2 = Fp.sqr(b); m < r; m++) {\n                if (Fp.eql(t2, Fp.ONE))\n                    break;\n                t2 = Fp.sqr(t2); // t2 *= t2\n            }\n            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n            g = Fp.sqr(ge); // g = ge * ge\n            x = Fp.mul(x, ge); // x *= ge\n            b = Fp.mul(b, g); // b *= g\n            r = m;\n        }\n        return x;\n    };\n}\nfunction FpSqrt(P) {\n    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.\n    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n    // P ‚â° 3 (mod 4)\n    // ‚àön = n^((P+1)/4)\n    if (P % _4n === _3n) {\n        // Not all roots possible!\n        // const ORDER =\n        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n        // const NUM = 72057594037927816n;\n        const p1div4 = (P + _1n) / _4n;\n        return function sqrt3mod4(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            // Throw if root**2 != n\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Atkin algorithm for q ‚â° 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n    if (P % _8n === _5n) {\n        const c1 = (P - _5n) / _8n;\n        return function sqrt5mod8(Fp, n) {\n            const n2 = Fp.mul(n, _2n);\n            const v = Fp.pow(n2, c1);\n            const nv = Fp.mul(n, v);\n            const i = Fp.mul(Fp.mul(nv, _2n), v);\n            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // P ‚â° 9 (mod 16)\n    if (P % _16n === _9n) {\n        // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n        // Means we cannot use sqrt for constants at all!\n        //\n        // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n        // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n        // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n        // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n        // sqrt = (x) => {\n        //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n        //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n        //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n        //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n        //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n        //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n        //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n        //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n        //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n        //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n        // }\n    }\n    // Other cases: Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nconst isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n    'eql', 'add', 'sub', 'mul', 'pow', 'div',\n    'addN', 'subN', 'mulN', 'sqrN'\n];\nfunction validateField(field) {\n    const initial = {\n        ORDER: 'bigint',\n        MASK: 'bigint',\n        BYTES: 'isSafeInteger',\n        BITS: 'isSafeInteger',\n    };\n    const opts = FIELD_FIELDS.reduce((map, val) => {\n        map[val] = 'function';\n        return map;\n    }, initial);\n    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(field, opts);\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nfunction FpPow(f, num, power) {\n    // Should have same speed as pow for bigints\n    // TODO: benchmark!\n    if (power < _0n)\n        throw new Error('Expected power > 0');\n    if (power === _0n)\n        return f.ONE;\n    if (power === _1n)\n        return num;\n    let p = f.ONE;\n    let d = num;\n    while (power > _0n) {\n        if (power & _1n)\n            p = f.mul(p, d);\n        d = f.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * `inv(0)` will return `undefined` here: make sure to throw an error.\n */\nfunction FpInvertBatch(f, nums) {\n    const tmp = new Array(nums.length);\n    // Walk from first to last, multiply them by each other MOD p\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = acc;\n        return f.mul(acc, num);\n    }, f.ONE);\n    // Invert last element\n    const inverted = f.inv(lastMultiplied);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = f.mul(acc, tmp[i]);\n        return f.mul(acc, num);\n    }, inverted);\n    return tmp;\n}\nfunction FpDiv(f, lhs, rhs) {\n    return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\n// This function returns True whenever the value x is a square in the field F.\nfunction FpIsSquare(f) {\n    const legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic\n    return (x) => {\n        const p = f.pow(x, legendreConst);\n        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n    };\n}\n// CURVE.n lengths\nfunction nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return { nBitLength: _nBitLength, nByteLength };\n}\n/**\n * Initializes a finite field over prime. **Non-primes are not supported.**\n * Do not init in loop: slow. Very fragile: always run a benchmark on a change.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nfunction Field(ORDER, bitLen, isLE = false, redef = {}) {\n    if (ORDER <= _0n)\n        throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n    if (BYTES > 2048)\n        throw new Error('Field lengths over 2048 bytes are not supported');\n    const sqrtP = FpSqrt(ORDER);\n    const f = Object.freeze({\n        ORDER,\n        BITS,\n        BYTES,\n        MASK: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        create: (num) => mod(num, ORDER),\n        isValid: (num) => {\n            if (typeof num !== 'bigint')\n                throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num) => num === _0n,\n        isOdd: (num) => (num & _1n) === _1n,\n        neg: (num) => mod(-num, ORDER),\n        eql: (lhs, rhs) => lhs === rhs,\n        sqr: (num) => mod(num * num, ORDER),\n        add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n        pow: (num, power) => FpPow(f, num, power),\n        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num) => num * num,\n        addN: (lhs, rhs) => lhs + rhs,\n        subN: (lhs, rhs) => lhs - rhs,\n        mulN: (lhs, rhs) => lhs * rhs,\n        inv: (num) => invert(num, ORDER),\n        sqrt: redef.sqrt || ((n) => sqrtP(f, n)),\n        invertBatch: (lst) => FpInvertBatch(f, lst),\n        // TODO: do we really need constant cmov?\n        // We don't have const-time bigints anyway, so probably will be not very useful\n        cmov: (a, b, c) => (c ? b : a),\n        toBytes: (num) => (isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(num, BYTES) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(num, BYTES)),\n        fromBytes: (bytes) => {\n            if (bytes.length !== BYTES)\n                throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);\n            return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(bytes) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(bytes);\n        },\n    });\n    return Object.freeze(f);\n}\nfunction FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nfunction FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use mapKeyToField instead\n */\nfunction hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('privateHash', hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n        throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(hash) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nfunction getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== 'bigint')\n        throw new Error('field order must be bigint');\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nfunction getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nfunction mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024)\n        throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(key) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(reduced, fieldLen) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(reduced, fieldLen);\n}\n//# sourceMappingURL=modular.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9zdHItZGV2LWtpdC9uZGsvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9tb2R1bGFyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDdUk7QUFDdkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLHFFQUFxRSxRQUFRLE1BQU0sT0FBTztBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpQkFBaUI7QUFDOUM7QUFDQTtBQUNBLGtCQUFrQiwyQ0FBMkM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUMsbUNBQW1DO0FBQ25DLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPLDRCQUE0QixJQUFJO0FBQzNFLHVCQUF1QiwwREFBZSxRQUFRLDBEQUFlO0FBQzdEO0FBQ0E7QUFDQSxrQkFBa0IsMERBQWUsc0JBQXNCLDBEQUFlO0FBQ3RFO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2xmZy9HaXQvTWFkdHJpcHMvbm9kZV9tb2R1bGVzL0Bub3N0ci1kZXYta2l0L25kay9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L21vZHVsYXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gVXRpbGl0aWVzIGZvciBtb2R1bGFyIGFyaXRobWV0aWNzIGFuZCBmaW5pdGUgZmllbGRzXG5pbXBvcnQgeyBiaXRNYXNrLCBudW1iZXJUb0J5dGVzQkUsIG51bWJlclRvQnl0ZXNMRSwgYnl0ZXNUb051bWJlckJFLCBieXRlc1RvTnVtYmVyTEUsIGVuc3VyZUJ5dGVzLCB2YWxpZGF0ZU9iamVjdCwgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzBuID0gQmlnSW50KDApLCBfMW4gPSBCaWdJbnQoMSksIF8ybiA9IEJpZ0ludCgyKSwgXzNuID0gQmlnSW50KDMpO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfNG4gPSBCaWdJbnQoNCksIF81biA9IEJpZ0ludCg1KSwgXzhuID0gQmlnSW50KDgpO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfOW4gPSBCaWdJbnQoOSksIF8xNm4gPSBCaWdJbnQoMTYpO1xuLy8gQ2FsY3VsYXRlcyBhIG1vZHVsbyBiXG5leHBvcnQgZnVuY3Rpb24gbW9kKGEsIGIpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhICUgYjtcbiAgICByZXR1cm4gcmVzdWx0ID49IF8wbiA/IHJlc3VsdCA6IGIgKyByZXN1bHQ7XG59XG4vKipcbiAqIEVmZmljaWVudGx5IHJhaXNlIG51bSB0byBwb3dlciBhbmQgZG8gbW9kdWxhciBkaXZpc2lvbi5cbiAqIFVuc2FmZSBpbiBzb21lIGNvbnRleHRzOiB1c2VzIGxhZGRlciwgc28gY2FuIGV4cG9zZSBiaWdpbnQgYml0cy5cbiAqIEBleGFtcGxlXG4gKiBwb3coMm4sIDZuLCAxMW4pIC8vIDY0biAlIDExbiA9PSA5blxuICovXG4vLyBUT0RPOiB1c2UgZmllbGQgdmVyc2lvbiAmJiByZW1vdmVcbmV4cG9ydCBmdW5jdGlvbiBwb3cobnVtLCBwb3dlciwgbW9kdWxvKSB7XG4gICAgaWYgKG1vZHVsbyA8PSBfMG4gfHwgcG93ZXIgPCBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcG93ZXIvbW9kdWxvID4gMCcpO1xuICAgIGlmIChtb2R1bG8gPT09IF8xbilcbiAgICAgICAgcmV0dXJuIF8wbjtcbiAgICBsZXQgcmVzID0gXzFuO1xuICAgIHdoaWxlIChwb3dlciA+IF8wbikge1xuICAgICAgICBpZiAocG93ZXIgJiBfMW4pXG4gICAgICAgICAgICByZXMgPSAocmVzICogbnVtKSAlIG1vZHVsbztcbiAgICAgICAgbnVtID0gKG51bSAqIG51bSkgJSBtb2R1bG87XG4gICAgICAgIHBvd2VyID4+PSBfMW47XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vLyBEb2VzIHggXiAoMiBeIHBvd2VyKSBtb2QgcC4gcG93MigzMCwgNCkgPT0gMzAgXiAoMiBeIDQpXG5leHBvcnQgZnVuY3Rpb24gcG93Mih4LCBwb3dlciwgbW9kdWxvKSB7XG4gICAgbGV0IHJlcyA9IHg7XG4gICAgd2hpbGUgKHBvd2VyLS0gPiBfMG4pIHtcbiAgICAgICAgcmVzICo9IHJlcztcbiAgICAgICAgcmVzICU9IG1vZHVsbztcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbi8vIEludmVyc2VzIG51bWJlciBvdmVyIG1vZHVsb1xuZXhwb3J0IGZ1bmN0aW9uIGludmVydChudW1iZXIsIG1vZHVsbykge1xuICAgIGlmIChudW1iZXIgPT09IF8wbiB8fCBtb2R1bG8gPD0gXzBuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52ZXJ0OiBleHBlY3RlZCBwb3NpdGl2ZSBpbnRlZ2VycywgZ290IG49JHtudW1iZXJ9IG1vZD0ke21vZHVsb31gKTtcbiAgICB9XG4gICAgLy8gRXVjbGlkZWFuIEdDRCBodHRwczovL2JyaWxsaWFudC5vcmcvd2lraS9leHRlbmRlZC1ldWNsaWRlYW4tYWxnb3JpdGhtL1xuICAgIC8vIEZlcm1hdCdzIGxpdHRsZSB0aGVvcmVtIFwiQ1QtbGlrZVwiIHZlcnNpb24gaW52KG4pID0gbl4obS0yKSBtb2QgbSBpcyAzMHggc2xvd2VyLlxuICAgIGxldCBhID0gbW9kKG51bWJlciwgbW9kdWxvKTtcbiAgICBsZXQgYiA9IG1vZHVsbztcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBsZXQgeCA9IF8wbiwgeSA9IF8xbiwgdSA9IF8xbiwgdiA9IF8wbjtcbiAgICB3aGlsZSAoYSAhPT0gXzBuKSB7XG4gICAgICAgIC8vIEpJVCBhcHBsaWVzIG9wdGltaXphdGlvbiBpZiB0aG9zZSB0d28gbGluZXMgZm9sbG93IGVhY2ggb3RoZXJcbiAgICAgICAgY29uc3QgcSA9IGIgLyBhO1xuICAgICAgICBjb25zdCByID0gYiAlIGE7XG4gICAgICAgIGNvbnN0IG0gPSB4IC0gdSAqIHE7XG4gICAgICAgIGNvbnN0IG4gPSB5IC0gdiAqIHE7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBiID0gYSwgYSA9IHIsIHggPSB1LCB5ID0gdiwgdSA9IG0sIHYgPSBuO1xuICAgIH1cbiAgICBjb25zdCBnY2QgPSBiO1xuICAgIGlmIChnY2QgIT09IF8xbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZlcnQ6IGRvZXMgbm90IGV4aXN0Jyk7XG4gICAgcmV0dXJuIG1vZCh4LCBtb2R1bG8pO1xufVxuLyoqXG4gKiBUb25lbGxpLVNoYW5rcyBzcXVhcmUgcm9vdCBzZWFyY2ggYWxnb3JpdGhtLlxuICogMS4gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxMi82ODUucGRmIChwYWdlIDEyKVxuICogMi4gU3F1YXJlIFJvb3RzIGZyb20gMTsgMjQsIDUxLCAxMCB0byBEYW4gU2hhbmtzXG4gKiBXaWxsIHN0YXJ0IGFuIGluZmluaXRlIGxvb3AgaWYgZmllbGQgb3JkZXIgUCBpcyBub3QgcHJpbWUuXG4gKiBAcGFyYW0gUCBmaWVsZCBvcmRlclxuICogQHJldHVybnMgZnVuY3Rpb24gdGhhdCB0YWtlcyBmaWVsZCBGcCAoY3JlYXRlZCBmcm9tIFApIGFuZCBudW1iZXIgblxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9uZWxsaVNoYW5rcyhQKSB7XG4gICAgLy8gTGVnZW5kcmUgY29uc3RhbnQ6IHVzZWQgdG8gY2FsY3VsYXRlIExlZ2VuZHJlIHN5bWJvbCAoYSB8IHApLFxuICAgIC8vIHdoaWNoIGRlbm90ZXMgdGhlIHZhbHVlIG9mIGFeKChwLTEpLzIpIChtb2QgcCkuXG4gICAgLy8gKGEgfCBwKSDiiaEgMSAgICBpZiBhIGlzIGEgc3F1YXJlIChtb2QgcClcbiAgICAvLyAoYSB8IHApIOKJoSAtMSAgIGlmIGEgaXMgbm90IGEgc3F1YXJlIChtb2QgcClcbiAgICAvLyAoYSB8IHApIOKJoSAwICAgIGlmIGEg4omhIDAgKG1vZCBwKVxuICAgIGNvbnN0IGxlZ2VuZHJlQyA9IChQIC0gXzFuKSAvIF8ybjtcbiAgICBsZXQgUSwgUywgWjtcbiAgICAvLyBTdGVwIDE6IEJ5IGZhY3RvcmluZyBvdXQgcG93ZXJzIG9mIDIgZnJvbSBwIC0gMSxcbiAgICAvLyBmaW5kIHEgYW5kIHMgc3VjaCB0aGF0IHAgLSAxID0gcSooMl5zKSB3aXRoIHEgb2RkXG4gICAgZm9yIChRID0gUCAtIF8xbiwgUyA9IDA7IFEgJSBfMm4gPT09IF8wbjsgUSAvPSBfMm4sIFMrKylcbiAgICAgICAgO1xuICAgIC8vIFN0ZXAgMjogU2VsZWN0IGEgbm9uLXNxdWFyZSB6IHN1Y2ggdGhhdCAoeiB8IHApIOKJoSAtMSBhbmQgc2V0IGMg4omhIHpxXG4gICAgZm9yIChaID0gXzJuOyBaIDwgUCAmJiBwb3coWiwgbGVnZW5kcmVDLCBQKSAhPT0gUCAtIF8xbjsgWisrKVxuICAgICAgICA7XG4gICAgLy8gRmFzdC1wYXRoXG4gICAgaWYgKFMgPT09IDEpIHtcbiAgICAgICAgY29uc3QgcDFkaXY0ID0gKFAgKyBfMW4pIC8gXzRuO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gdG9uZWxsaUZhc3QoRnAsIG4pIHtcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSBGcC5wb3cobiwgcDFkaXY0KTtcbiAgICAgICAgICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgbikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIFNsb3ctcGF0aFxuICAgIGNvbnN0IFExZGl2MiA9IChRICsgXzFuKSAvIF8ybjtcbiAgICByZXR1cm4gZnVuY3Rpb24gdG9uZWxsaVNsb3coRnAsIG4pIHtcbiAgICAgICAgLy8gU3RlcCAwOiBDaGVjayB0aGF0IG4gaXMgaW5kZWVkIGEgc3F1YXJlOiAobiB8IHApIHNob3VsZCBub3QgYmUg4omhIC0xXG4gICAgICAgIGlmIChGcC5wb3cobiwgbGVnZW5kcmVDKSA9PT0gRnAubmVnKEZwLk9ORSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgIGxldCByID0gUztcbiAgICAgICAgLy8gVE9ETzogd2lsbCBmYWlsIGF0IEZwMi9ldGNcbiAgICAgICAgbGV0IGcgPSBGcC5wb3coRnAubXVsKEZwLk9ORSwgWiksIFEpOyAvLyB3aWxsIHVwZGF0ZSBib3RoIHggYW5kIGJcbiAgICAgICAgbGV0IHggPSBGcC5wb3cobiwgUTFkaXYyKTsgLy8gZmlyc3QgZ3Vlc3MgYXQgdGhlIHNxdWFyZSByb290XG4gICAgICAgIGxldCBiID0gRnAucG93KG4sIFEpOyAvLyBmaXJzdCBndWVzcyBhdCB0aGUgZnVkZ2UgZmFjdG9yXG4gICAgICAgIHdoaWxlICghRnAuZXFsKGIsIEZwLk9ORSkpIHtcbiAgICAgICAgICAgIGlmIChGcC5lcWwoYiwgRnAuWkVSTykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIEZwLlpFUk87IC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RvbmVsbGklRTIlODAlOTNTaGFua3NfYWxnb3JpdGhtICg0LiBJZiB0ID0gMCwgcmV0dXJuIHIgPSAwKVxuICAgICAgICAgICAgLy8gRmluZCBtIHN1Y2ggYl4oMl5tKT09MVxuICAgICAgICAgICAgbGV0IG0gPSAxO1xuICAgICAgICAgICAgZm9yIChsZXQgdDIgPSBGcC5zcXIoYik7IG0gPCByOyBtKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoRnAuZXFsKHQyLCBGcC5PTkUpKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB0MiA9IEZwLnNxcih0Mik7IC8vIHQyICo9IHQyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOT1RFOiByLW0tMSBjYW4gYmUgYmlnZ2VyIHRoYW4gMzIsIG5lZWQgdG8gY29udmVydCB0byBiaWdpbnQgYmVmb3JlIHNoaWZ0LCBvdGhlcndpc2UgdGhlcmUgd2lsbCBiZSBvdmVyZmxvd1xuICAgICAgICAgICAgY29uc3QgZ2UgPSBGcC5wb3coZywgXzFuIDw8IEJpZ0ludChyIC0gbSAtIDEpKTsgLy8gZ2UgPSAyXihyLW0tMSlcbiAgICAgICAgICAgIGcgPSBGcC5zcXIoZ2UpOyAvLyBnID0gZ2UgKiBnZVxuICAgICAgICAgICAgeCA9IEZwLm11bCh4LCBnZSk7IC8vIHggKj0gZ2VcbiAgICAgICAgICAgIGIgPSBGcC5tdWwoYiwgZyk7IC8vIGIgKj0gZ1xuICAgICAgICAgICAgciA9IG07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBGcFNxcnQoUCkge1xuICAgIC8vIE5PVEU6IGRpZmZlcmVudCBhbGdvcml0aG1zIGNhbiBnaXZlIGRpZmZlcmVudCByb290cywgaXQgaXMgdXAgdG8gdXNlciB0byBkZWNpZGUgd2hpY2ggb25lIHRoZXkgd2FudC5cbiAgICAvLyBGb3IgZXhhbXBsZSB0aGVyZSBpcyBGcFNxcnRPZGQvRnBTcXJ0RXZlbiB0byBjaG9pY2Ugcm9vdCBiYXNlZCBvbiBvZGRuZXNzICh1c2VkIGZvciBoYXNoLXRvLWN1cnZlKS5cbiAgICAvLyBQIOKJoSAzIChtb2QgNClcbiAgICAvLyDiiJpuID0gbl4oKFArMSkvNClcbiAgICBpZiAoUCAlIF80biA9PT0gXzNuKSB7XG4gICAgICAgIC8vIE5vdCBhbGwgcm9vdHMgcG9zc2libGUhXG4gICAgICAgIC8vIGNvbnN0IE9SREVSID1cbiAgICAgICAgLy8gICAweDFhMDExMWVhMzk3ZmU2OWE0YjFiYTdiNjQzNGJhY2Q3NjQ3NzRiODRmMzg1MTJiZjY3MzBkMmEwZjZiMGY2MjQxZWFiZmZmZWIxNTNmZmZmYjlmZWZmZmZmZmZmYWFhYm47XG4gICAgICAgIC8vIGNvbnN0IE5VTSA9IDcyMDU3NTk0MDM3OTI3ODE2bjtcbiAgICAgICAgY29uc3QgcDFkaXY0ID0gKFAgKyBfMW4pIC8gXzRuO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gc3FydDNtb2Q0KEZwLCBuKSB7XG4gICAgICAgICAgICBjb25zdCByb290ID0gRnAucG93KG4sIHAxZGl2NCk7XG4gICAgICAgICAgICAvLyBUaHJvdyBpZiByb290KioyICE9IG5cbiAgICAgICAgICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgbikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIEF0a2luIGFsZ29yaXRobSBmb3IgcSDiiaEgNSAobW9kIDgpLCBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDEyLzY4NS5wZGYgKHBhZ2UgMTApXG4gICAgaWYgKFAgJSBfOG4gPT09IF81bikge1xuICAgICAgICBjb25zdCBjMSA9IChQIC0gXzVuKSAvIF84bjtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNxcnQ1bW9kOChGcCwgbikge1xuICAgICAgICAgICAgY29uc3QgbjIgPSBGcC5tdWwobiwgXzJuKTtcbiAgICAgICAgICAgIGNvbnN0IHYgPSBGcC5wb3cobjIsIGMxKTtcbiAgICAgICAgICAgIGNvbnN0IG52ID0gRnAubXVsKG4sIHYpO1xuICAgICAgICAgICAgY29uc3QgaSA9IEZwLm11bChGcC5tdWwobnYsIF8ybiksIHYpO1xuICAgICAgICAgICAgY29uc3Qgcm9vdCA9IEZwLm11bChudiwgRnAuc3ViKGksIEZwLk9ORSkpO1xuICAgICAgICAgICAgaWYgKCFGcC5lcWwoRnAuc3FyKHJvb3QpLCBuKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gUCDiiaEgOSAobW9kIDE2KVxuICAgIGlmIChQICUgXzE2biA9PT0gXzluKSB7XG4gICAgICAgIC8vIE5PVEU6IHRvbmVsbGkgaXMgdG9vIHNsb3cgZm9yIGJscy1GcDIgY2FsY3VsYXRpb25zIGV2ZW4gb24gc3RhcnRcbiAgICAgICAgLy8gTWVhbnMgd2UgY2Fubm90IHVzZSBzcXJ0IGZvciBjb25zdGFudHMgYXQgYWxsIVxuICAgICAgICAvL1xuICAgICAgICAvLyBjb25zdCBjMSA9IEZwLnNxcnQoRnAubmVnYXRlKEZwLk9ORSkpOyAvLyAgMS4gYzEgPSBzcXJ0KC0xKSBpbiBGLCBpLmUuLCAoYzFeMikgPT0gLTEgaW4gRlxuICAgICAgICAvLyBjb25zdCBjMiA9IEZwLnNxcnQoYzEpOyAgICAgICAgICAgICAgICAvLyAgMi4gYzIgPSBzcXJ0KGMxKSBpbiBGLCBpLmUuLCAoYzJeMikgPT0gYzEgaW4gRlxuICAgICAgICAvLyBjb25zdCBjMyA9IEZwLnNxcnQoRnAubmVnYXRlKGMxKSk7ICAgICAvLyAgMy4gYzMgPSBzcXJ0KC1jMSkgaW4gRiwgaS5lLiwgKGMzXjIpID09IC1jMSBpbiBGXG4gICAgICAgIC8vIGNvbnN0IGM0ID0gKFAgKyBfN24pIC8gXzE2bjsgICAgICAgICAgIC8vICA0LiBjNCA9IChxICsgNykgLyAxNiAgICAgICAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcbiAgICAgICAgLy8gc3FydCA9ICh4KSA9PiB7XG4gICAgICAgIC8vICAgbGV0IHR2MSA9IEZwLnBvdyh4LCBjNCk7ICAgICAgICAgICAgIC8vICAxLiB0djEgPSB4XmM0XG4gICAgICAgIC8vICAgbGV0IHR2MiA9IEZwLm11bChjMSwgdHYxKTsgICAgICAgICAgIC8vICAyLiB0djIgPSBjMSAqIHR2MVxuICAgICAgICAvLyAgIGNvbnN0IHR2MyA9IEZwLm11bChjMiwgdHYxKTsgICAgICAgICAvLyAgMy4gdHYzID0gYzIgKiB0djFcbiAgICAgICAgLy8gICBsZXQgdHY0ID0gRnAubXVsKGMzLCB0djEpOyAgICAgICAgICAgLy8gIDQuIHR2NCA9IGMzICogdHYxXG4gICAgICAgIC8vICAgY29uc3QgZTEgPSBGcC5lcXVhbHMoRnAuc3F1YXJlKHR2MiksIHgpOyAvLyAgNS4gIGUxID0gKHR2Ml4yKSA9PSB4XG4gICAgICAgIC8vICAgY29uc3QgZTIgPSBGcC5lcXVhbHMoRnAuc3F1YXJlKHR2MyksIHgpOyAvLyAgNi4gIGUyID0gKHR2M14yKSA9PSB4XG4gICAgICAgIC8vICAgdHYxID0gRnAuY21vdih0djEsIHR2MiwgZTEpOyAvLyAgNy4gdHYxID0gQ01PVih0djEsIHR2MiwgZTEpICAjIFNlbGVjdCB0djIgaWYgKHR2Ml4yKSA9PSB4XG4gICAgICAgIC8vICAgdHYyID0gRnAuY21vdih0djQsIHR2MywgZTIpOyAvLyAgOC4gdHYyID0gQ01PVih0djQsIHR2MywgZTIpICAjIFNlbGVjdCB0djMgaWYgKHR2M14yKSA9PSB4XG4gICAgICAgIC8vICAgY29uc3QgZTMgPSBGcC5lcXVhbHMoRnAuc3F1YXJlKHR2MiksIHgpOyAvLyAgOS4gIGUzID0gKHR2Ml4yKSA9PSB4XG4gICAgICAgIC8vICAgcmV0dXJuIEZwLmNtb3YodHYxLCB0djIsIGUzKTsgLy8gIDEwLiAgeiA9IENNT1YodHYxLCB0djIsIGUzKSAgIyBTZWxlY3QgdGhlIHNxcnQgZnJvbSB0djEgYW5kIHR2MlxuICAgICAgICAvLyB9XG4gICAgfVxuICAgIC8vIE90aGVyIGNhc2VzOiBUb25lbGxpLVNoYW5rcyBhbGdvcml0aG1cbiAgICByZXR1cm4gdG9uZWxsaVNoYW5rcyhQKTtcbn1cbi8vIExpdHRsZS1lbmRpYW4gY2hlY2sgZm9yIGZpcnN0IExFIGJpdCAobGFzdCBCRSBiaXQpO1xuZXhwb3J0IGNvbnN0IGlzTmVnYXRpdmVMRSA9IChudW0sIG1vZHVsbykgPT4gKG1vZChudW0sIG1vZHVsbykgJiBfMW4pID09PSBfMW47XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IEZJRUxEX0ZJRUxEUyA9IFtcbiAgICAnY3JlYXRlJywgJ2lzVmFsaWQnLCAnaXMwJywgJ25lZycsICdpbnYnLCAnc3FydCcsICdzcXInLFxuICAgICdlcWwnLCAnYWRkJywgJ3N1YicsICdtdWwnLCAncG93JywgJ2RpdicsXG4gICAgJ2FkZE4nLCAnc3ViTicsICdtdWxOJywgJ3Nxck4nXG5dO1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlRmllbGQoZmllbGQpIHtcbiAgICBjb25zdCBpbml0aWFsID0ge1xuICAgICAgICBPUkRFUjogJ2JpZ2ludCcsXG4gICAgICAgIE1BU0s6ICdiaWdpbnQnLFxuICAgICAgICBCWVRFUzogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBCSVRTOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgfTtcbiAgICBjb25zdCBvcHRzID0gRklFTERfRklFTERTLnJlZHVjZSgobWFwLCB2YWwpID0+IHtcbiAgICAgICAgbWFwW3ZhbF0gPSAnZnVuY3Rpb24nO1xuICAgICAgICByZXR1cm4gbWFwO1xuICAgIH0sIGluaXRpYWwpO1xuICAgIHJldHVybiB2YWxpZGF0ZU9iamVjdChmaWVsZCwgb3B0cyk7XG59XG4vLyBHZW5lcmljIGZpZWxkIGZ1bmN0aW9uc1xuLyoqXG4gKiBTYW1lIGFzIGBwb3dgIGJ1dCBmb3IgRnA6IG5vbi1jb25zdGFudC10aW1lLlxuICogVW5zYWZlIGluIHNvbWUgY29udGV4dHM6IHVzZXMgbGFkZGVyLCBzbyBjYW4gZXhwb3NlIGJpZ2ludCBiaXRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gRnBQb3coZiwgbnVtLCBwb3dlcikge1xuICAgIC8vIFNob3VsZCBoYXZlIHNhbWUgc3BlZWQgYXMgcG93IGZvciBiaWdpbnRzXG4gICAgLy8gVE9ETzogYmVuY2htYXJrIVxuICAgIGlmIChwb3dlciA8IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBwb3dlciA+IDAnKTtcbiAgICBpZiAocG93ZXIgPT09IF8wbilcbiAgICAgICAgcmV0dXJuIGYuT05FO1xuICAgIGlmIChwb3dlciA9PT0gXzFuKVxuICAgICAgICByZXR1cm4gbnVtO1xuICAgIGxldCBwID0gZi5PTkU7XG4gICAgbGV0IGQgPSBudW07XG4gICAgd2hpbGUgKHBvd2VyID4gXzBuKSB7XG4gICAgICAgIGlmIChwb3dlciAmIF8xbilcbiAgICAgICAgICAgIHAgPSBmLm11bChwLCBkKTtcbiAgICAgICAgZCA9IGYuc3FyKGQpO1xuICAgICAgICBwb3dlciA+Pj0gXzFuO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbn1cbi8qKlxuICogRWZmaWNpZW50bHkgaW52ZXJ0IGFuIGFycmF5IG9mIEZpZWxkIGVsZW1lbnRzLlxuICogYGludigwKWAgd2lsbCByZXR1cm4gYHVuZGVmaW5lZGAgaGVyZTogbWFrZSBzdXJlIHRvIHRocm93IGFuIGVycm9yLlxuICovXG5leHBvcnQgZnVuY3Rpb24gRnBJbnZlcnRCYXRjaChmLCBudW1zKSB7XG4gICAgY29uc3QgdG1wID0gbmV3IEFycmF5KG51bXMubGVuZ3RoKTtcbiAgICAvLyBXYWxrIGZyb20gZmlyc3QgdG8gbGFzdCwgbXVsdGlwbHkgdGhlbSBieSBlYWNoIG90aGVyIE1PRCBwXG4gICAgY29uc3QgbGFzdE11bHRpcGxpZWQgPSBudW1zLnJlZHVjZSgoYWNjLCBudW0sIGkpID0+IHtcbiAgICAgICAgaWYgKGYuaXMwKG51bSkpXG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB0bXBbaV0gPSBhY2M7XG4gICAgICAgIHJldHVybiBmLm11bChhY2MsIG51bSk7XG4gICAgfSwgZi5PTkUpO1xuICAgIC8vIEludmVydCBsYXN0IGVsZW1lbnRcbiAgICBjb25zdCBpbnZlcnRlZCA9IGYuaW52KGxhc3RNdWx0aXBsaWVkKTtcbiAgICAvLyBXYWxrIGZyb20gbGFzdCB0byBmaXJzdCwgbXVsdGlwbHkgdGhlbSBieSBpbnZlcnRlZCBlYWNoIG90aGVyIE1PRCBwXG4gICAgbnVtcy5yZWR1Y2VSaWdodCgoYWNjLCBudW0sIGkpID0+IHtcbiAgICAgICAgaWYgKGYuaXMwKG51bSkpXG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB0bXBbaV0gPSBmLm11bChhY2MsIHRtcFtpXSk7XG4gICAgICAgIHJldHVybiBmLm11bChhY2MsIG51bSk7XG4gICAgfSwgaW52ZXJ0ZWQpO1xuICAgIHJldHVybiB0bXA7XG59XG5leHBvcnQgZnVuY3Rpb24gRnBEaXYoZiwgbGhzLCByaHMpIHtcbiAgICByZXR1cm4gZi5tdWwobGhzLCB0eXBlb2YgcmhzID09PSAnYmlnaW50JyA/IGludmVydChyaHMsIGYuT1JERVIpIDogZi5pbnYocmhzKSk7XG59XG4vLyBUaGlzIGZ1bmN0aW9uIHJldHVybnMgVHJ1ZSB3aGVuZXZlciB0aGUgdmFsdWUgeCBpcyBhIHNxdWFyZSBpbiB0aGUgZmllbGQgRi5cbmV4cG9ydCBmdW5jdGlvbiBGcElzU3F1YXJlKGYpIHtcbiAgICBjb25zdCBsZWdlbmRyZUNvbnN0ID0gKGYuT1JERVIgLSBfMW4pIC8gXzJuOyAvLyBJbnRlZ2VyIGFyaXRobWV0aWNcbiAgICByZXR1cm4gKHgpID0+IHtcbiAgICAgICAgY29uc3QgcCA9IGYucG93KHgsIGxlZ2VuZHJlQ29uc3QpO1xuICAgICAgICByZXR1cm4gZi5lcWwocCwgZi5aRVJPKSB8fCBmLmVxbChwLCBmLk9ORSk7XG4gICAgfTtcbn1cbi8vIENVUlZFLm4gbGVuZ3Roc1xuZXhwb3J0IGZ1bmN0aW9uIG5MZW5ndGgobiwgbkJpdExlbmd0aCkge1xuICAgIC8vIEJpdCBzaXplLCBieXRlIHNpemUgb2YgQ1VSVkUublxuICAgIGNvbnN0IF9uQml0TGVuZ3RoID0gbkJpdExlbmd0aCAhPT0gdW5kZWZpbmVkID8gbkJpdExlbmd0aCA6IG4udG9TdHJpbmcoMikubGVuZ3RoO1xuICAgIGNvbnN0IG5CeXRlTGVuZ3RoID0gTWF0aC5jZWlsKF9uQml0TGVuZ3RoIC8gOCk7XG4gICAgcmV0dXJuIHsgbkJpdExlbmd0aDogX25CaXRMZW5ndGgsIG5CeXRlTGVuZ3RoIH07XG59XG4vKipcbiAqIEluaXRpYWxpemVzIGEgZmluaXRlIGZpZWxkIG92ZXIgcHJpbWUuICoqTm9uLXByaW1lcyBhcmUgbm90IHN1cHBvcnRlZC4qKlxuICogRG8gbm90IGluaXQgaW4gbG9vcDogc2xvdy4gVmVyeSBmcmFnaWxlOiBhbHdheXMgcnVuIGEgYmVuY2htYXJrIG9uIGEgY2hhbmdlLlxuICogTWFqb3IgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uczpcbiAqICogYSkgZGVub3JtYWxpemVkIG9wZXJhdGlvbnMgbGlrZSBtdWxOIGluc3RlYWQgb2YgbXVsXG4gKiAqIGIpIHNhbWUgb2JqZWN0IHNoYXBlOiBuZXZlciBhZGQgb3IgcmVtb3ZlIGtleXNcbiAqICogYykgT2JqZWN0LmZyZWV6ZVxuICogQHBhcmFtIE9SREVSIHByaW1lIHBvc2l0aXZlIGJpZ2ludFxuICogQHBhcmFtIGJpdExlbiBob3cgbWFueSBiaXRzIHRoZSBmaWVsZCBjb25zdW1lc1xuICogQHBhcmFtIGlzTEUgKGRlZjogZmFsc2UpIGlmIGVuY29kaW5nIC8gZGVjb2Rpbmcgc2hvdWxkIGJlIGluIGxpdHRsZS1lbmRpYW5cbiAqIEBwYXJhbSByZWRlZiBvcHRpb25hbCBmYXN0ZXIgcmVkZWZpbml0aW9ucyBvZiBzcXJ0IGFuZCBvdGhlciBtZXRob2RzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBGaWVsZChPUkRFUiwgYml0TGVuLCBpc0xFID0gZmFsc2UsIHJlZGVmID0ge30pIHtcbiAgICBpZiAoT1JERVIgPD0gXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIEZpZWxkIE9SREVSID4gMCwgZ290ICR7T1JERVJ9YCk7XG4gICAgY29uc3QgeyBuQml0TGVuZ3RoOiBCSVRTLCBuQnl0ZUxlbmd0aDogQllURVMgfSA9IG5MZW5ndGgoT1JERVIsIGJpdExlbik7XG4gICAgaWYgKEJZVEVTID4gMjA0OClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaWVsZCBsZW5ndGhzIG92ZXIgMjA0OCBieXRlcyBhcmUgbm90IHN1cHBvcnRlZCcpO1xuICAgIGNvbnN0IHNxcnRQID0gRnBTcXJ0KE9SREVSKTtcbiAgICBjb25zdCBmID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIE9SREVSLFxuICAgICAgICBCSVRTLFxuICAgICAgICBCWVRFUyxcbiAgICAgICAgTUFTSzogYml0TWFzayhCSVRTKSxcbiAgICAgICAgWkVSTzogXzBuLFxuICAgICAgICBPTkU6IF8xbixcbiAgICAgICAgY3JlYXRlOiAobnVtKSA9PiBtb2QobnVtLCBPUkRFUiksXG4gICAgICAgIGlzVmFsaWQ6IChudW0pID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbnVtICE9PSAnYmlnaW50JylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZmllbGQgZWxlbWVudDogZXhwZWN0ZWQgYmlnaW50LCBnb3QgJHt0eXBlb2YgbnVtfWApO1xuICAgICAgICAgICAgcmV0dXJuIF8wbiA8PSBudW0gJiYgbnVtIDwgT1JERVI7IC8vIDAgaXMgdmFsaWQgZWxlbWVudCwgYnV0IGl0J3Mgbm90IGludmVydGlibGVcbiAgICAgICAgfSxcbiAgICAgICAgaXMwOiAobnVtKSA9PiBudW0gPT09IF8wbixcbiAgICAgICAgaXNPZGQ6IChudW0pID0+IChudW0gJiBfMW4pID09PSBfMW4sXG4gICAgICAgIG5lZzogKG51bSkgPT4gbW9kKC1udW0sIE9SREVSKSxcbiAgICAgICAgZXFsOiAobGhzLCByaHMpID0+IGxocyA9PT0gcmhzLFxuICAgICAgICBzcXI6IChudW0pID0+IG1vZChudW0gKiBudW0sIE9SREVSKSxcbiAgICAgICAgYWRkOiAobGhzLCByaHMpID0+IG1vZChsaHMgKyByaHMsIE9SREVSKSxcbiAgICAgICAgc3ViOiAobGhzLCByaHMpID0+IG1vZChsaHMgLSByaHMsIE9SREVSKSxcbiAgICAgICAgbXVsOiAobGhzLCByaHMpID0+IG1vZChsaHMgKiByaHMsIE9SREVSKSxcbiAgICAgICAgcG93OiAobnVtLCBwb3dlcikgPT4gRnBQb3coZiwgbnVtLCBwb3dlciksXG4gICAgICAgIGRpdjogKGxocywgcmhzKSA9PiBtb2QobGhzICogaW52ZXJ0KHJocywgT1JERVIpLCBPUkRFUiksXG4gICAgICAgIC8vIFNhbWUgYXMgYWJvdmUsIGJ1dCBkb2Vzbid0IG5vcm1hbGl6ZVxuICAgICAgICBzcXJOOiAobnVtKSA9PiBudW0gKiBudW0sXG4gICAgICAgIGFkZE46IChsaHMsIHJocykgPT4gbGhzICsgcmhzLFxuICAgICAgICBzdWJOOiAobGhzLCByaHMpID0+IGxocyAtIHJocyxcbiAgICAgICAgbXVsTjogKGxocywgcmhzKSA9PiBsaHMgKiByaHMsXG4gICAgICAgIGludjogKG51bSkgPT4gaW52ZXJ0KG51bSwgT1JERVIpLFxuICAgICAgICBzcXJ0OiByZWRlZi5zcXJ0IHx8ICgobikgPT4gc3FydFAoZiwgbikpLFxuICAgICAgICBpbnZlcnRCYXRjaDogKGxzdCkgPT4gRnBJbnZlcnRCYXRjaChmLCBsc3QpLFxuICAgICAgICAvLyBUT0RPOiBkbyB3ZSByZWFsbHkgbmVlZCBjb25zdGFudCBjbW92P1xuICAgICAgICAvLyBXZSBkb24ndCBoYXZlIGNvbnN0LXRpbWUgYmlnaW50cyBhbnl3YXksIHNvIHByb2JhYmx5IHdpbGwgYmUgbm90IHZlcnkgdXNlZnVsXG4gICAgICAgIGNtb3Y6IChhLCBiLCBjKSA9PiAoYyA/IGIgOiBhKSxcbiAgICAgICAgdG9CeXRlczogKG51bSkgPT4gKGlzTEUgPyBudW1iZXJUb0J5dGVzTEUobnVtLCBCWVRFUykgOiBudW1iZXJUb0J5dGVzQkUobnVtLCBCWVRFUykpLFxuICAgICAgICBmcm9tQnl0ZXM6IChieXRlcykgPT4ge1xuICAgICAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCAhPT0gQllURVMpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGcC5mcm9tQnl0ZXM6IGV4cGVjdGVkICR7QllURVN9LCBnb3QgJHtieXRlcy5sZW5ndGh9YCk7XG4gICAgICAgICAgICByZXR1cm4gaXNMRSA/IGJ5dGVzVG9OdW1iZXJMRShieXRlcykgOiBieXRlc1RvTnVtYmVyQkUoYnl0ZXMpO1xuICAgICAgICB9LFxuICAgIH0pO1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKGYpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIEZwU3FydE9kZChGcCwgZWxtKSB7XG4gICAgaWYgKCFGcC5pc09kZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGaWVsZCBkb2Vzbid0IGhhdmUgaXNPZGRgKTtcbiAgICBjb25zdCByb290ID0gRnAuc3FydChlbG0pO1xuICAgIHJldHVybiBGcC5pc09kZChyb290KSA/IHJvb3QgOiBGcC5uZWcocm9vdCk7XG59XG5leHBvcnQgZnVuY3Rpb24gRnBTcXJ0RXZlbihGcCwgZWxtKSB7XG4gICAgaWYgKCFGcC5pc09kZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGaWVsZCBkb2Vzbid0IGhhdmUgaXNPZGRgKTtcbiAgICBjb25zdCByb290ID0gRnAuc3FydChlbG0pO1xuICAgIHJldHVybiBGcC5pc09kZChyb290KSA/IEZwLm5lZyhyb290KSA6IHJvb3Q7XG59XG4vKipcbiAqIFwiQ29uc3RhbnQtdGltZVwiIHByaXZhdGUga2V5IGdlbmVyYXRpb24gdXRpbGl0eS5cbiAqIFNhbWUgYXMgbWFwS2V5VG9GaWVsZCwgYnV0IGFjY2VwdHMgbGVzcyBieXRlcyAoNDAgaW5zdGVhZCBvZiA0OCBmb3IgMzItYnl0ZSBmaWVsZCkuXG4gKiBXaGljaCBtYWtlcyBpdCBzbGlnaHRseSBtb3JlIGJpYXNlZCwgbGVzcyBzZWN1cmUuXG4gKiBAZGVwcmVjYXRlZCB1c2UgbWFwS2V5VG9GaWVsZCBpbnN0ZWFkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNoVG9Qcml2YXRlU2NhbGFyKGhhc2gsIGdyb3VwT3JkZXIsIGlzTEUgPSBmYWxzZSkge1xuICAgIGhhc2ggPSBlbnN1cmVCeXRlcygncHJpdmF0ZUhhc2gnLCBoYXNoKTtcbiAgICBjb25zdCBoYXNoTGVuID0gaGFzaC5sZW5ndGg7XG4gICAgY29uc3QgbWluTGVuID0gbkxlbmd0aChncm91cE9yZGVyKS5uQnl0ZUxlbmd0aCArIDg7XG4gICAgaWYgKG1pbkxlbiA8IDI0IHx8IGhhc2hMZW4gPCBtaW5MZW4gfHwgaGFzaExlbiA+IDEwMjQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaGFzaFRvUHJpdmF0ZVNjYWxhcjogZXhwZWN0ZWQgJHttaW5MZW59LTEwMjQgYnl0ZXMgb2YgaW5wdXQsIGdvdCAke2hhc2hMZW59YCk7XG4gICAgY29uc3QgbnVtID0gaXNMRSA/IGJ5dGVzVG9OdW1iZXJMRShoYXNoKSA6IGJ5dGVzVG9OdW1iZXJCRShoYXNoKTtcbiAgICByZXR1cm4gbW9kKG51bSwgZ3JvdXBPcmRlciAtIF8xbikgKyBfMW47XG59XG4vKipcbiAqIFJldHVybnMgdG90YWwgbnVtYmVyIG9mIGJ5dGVzIGNvbnN1bWVkIGJ5IHRoZSBmaWVsZCBlbGVtZW50LlxuICogRm9yIGV4YW1wbGUsIDMyIGJ5dGVzIGZvciB1c3VhbCAyNTYtYml0IHdlaWVyc3RyYXNzIGN1cnZlLlxuICogQHBhcmFtIGZpZWxkT3JkZXIgbnVtYmVyIG9mIGZpZWxkIGVsZW1lbnRzLCB1c3VhbGx5IENVUlZFLm5cbiAqIEByZXR1cm5zIGJ5dGUgbGVuZ3RoIG9mIGZpZWxkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRGaWVsZEJ5dGVzTGVuZ3RoKGZpZWxkT3JkZXIpIHtcbiAgICBpZiAodHlwZW9mIGZpZWxkT3JkZXIgIT09ICdiaWdpbnQnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpZWxkIG9yZGVyIG11c3QgYmUgYmlnaW50Jyk7XG4gICAgY29uc3QgYml0TGVuZ3RoID0gZmllbGRPcmRlci50b1N0cmluZygyKS5sZW5ndGg7XG4gICAgcmV0dXJuIE1hdGguY2VpbChiaXRMZW5ndGggLyA4KTtcbn1cbi8qKlxuICogUmV0dXJucyBtaW5pbWFsIGFtb3VudCBvZiBieXRlcyB0aGF0IGNhbiBiZSBzYWZlbHkgcmVkdWNlZFxuICogYnkgZmllbGQgb3JkZXIuXG4gKiBTaG91bGQgYmUgMl4tMTI4IGZvciAxMjgtYml0IGN1cnZlIHN1Y2ggYXMgUDI1Ni5cbiAqIEBwYXJhbSBmaWVsZE9yZGVyIG51bWJlciBvZiBmaWVsZCBlbGVtZW50cywgdXN1YWxseSBDVVJWRS5uXG4gKiBAcmV0dXJucyBieXRlIGxlbmd0aCBvZiB0YXJnZXQgaGFzaFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWluSGFzaExlbmd0aChmaWVsZE9yZGVyKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gZ2V0RmllbGRCeXRlc0xlbmd0aChmaWVsZE9yZGVyKTtcbiAgICByZXR1cm4gbGVuZ3RoICsgTWF0aC5jZWlsKGxlbmd0aCAvIDIpO1xufVxuLyoqXG4gKiBcIkNvbnN0YW50LXRpbWVcIiBwcml2YXRlIGtleSBnZW5lcmF0aW9uIHV0aWxpdHkuXG4gKiBDYW4gdGFrZSAobiArIG4vMikgb3IgbW9yZSBieXRlcyBvZiB1bmlmb3JtIGlucHV0IGUuZy4gZnJvbSBDU1BSTkcgb3IgS0RGXG4gKiBhbmQgY29udmVydCB0aGVtIGludG8gcHJpdmF0ZSBzY2FsYXIsIHdpdGggdGhlIG1vZHVsbyBiaWFzIGJlaW5nIG5lZ2xpZ2libGUuXG4gKiBOZWVkcyBhdCBsZWFzdCA0OCBieXRlcyBvZiBpbnB1dCBmb3IgMzItYnl0ZSBwcml2YXRlIGtleS5cbiAqIGh0dHBzOi8vcmVzZWFyY2gua3VkZWxza2lzZWN1cml0eS5jb20vMjAyMC8wNy8yOC90aGUtZGVmaW5pdGl2ZS1ndWlkZS10by1tb2R1bG8tYmlhcy1hbmQtaG93LXRvLWF2b2lkLWl0L1xuICogRklQUyAxODYtNSwgQS4yIGh0dHBzOi8vY3NyYy5uaXN0Lmdvdi9wdWJsaWNhdGlvbnMvZGV0YWlsL2ZpcHMvMTg2LzUvZmluYWxcbiAqIFJGQyA5MzgwLCBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTVcbiAqIEBwYXJhbSBoYXNoIGhhc2ggb3V0cHV0IGZyb20gU0hBMyBvciBhIHNpbWlsYXIgZnVuY3Rpb25cbiAqIEBwYXJhbSBncm91cE9yZGVyIHNpemUgb2Ygc3ViZ3JvdXAgLSAoZS5nLiBzZWNwMjU2azEuQ1VSVkUubilcbiAqIEBwYXJhbSBpc0xFIGludGVycHJldCBoYXNoIGJ5dGVzIGFzIExFIG51bVxuICogQHJldHVybnMgdmFsaWQgcHJpdmF0ZSBzY2FsYXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcEhhc2hUb0ZpZWxkKGtleSwgZmllbGRPcmRlciwgaXNMRSA9IGZhbHNlKSB7XG4gICAgY29uc3QgbGVuID0ga2V5Lmxlbmd0aDtcbiAgICBjb25zdCBmaWVsZExlbiA9IGdldEZpZWxkQnl0ZXNMZW5ndGgoZmllbGRPcmRlcik7XG4gICAgY29uc3QgbWluTGVuID0gZ2V0TWluSGFzaExlbmd0aChmaWVsZE9yZGVyKTtcbiAgICAvLyBObyBzbWFsbCBudW1iZXJzOiBuZWVkIHRvIHVuZGVyc3RhbmQgYmlhcyBzdG9yeS4gTm8gaHVnZSBudW1iZXJzOiBlYXNpZXIgdG8gZGV0ZWN0IEpTIHRpbWluZ3MuXG4gICAgaWYgKGxlbiA8IDE2IHx8IGxlbiA8IG1pbkxlbiB8fCBsZW4gPiAxMDI0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkICR7bWluTGVufS0xMDI0IGJ5dGVzIG9mIGlucHV0LCBnb3QgJHtsZW59YCk7XG4gICAgY29uc3QgbnVtID0gaXNMRSA/IGJ5dGVzVG9OdW1iZXJCRShrZXkpIDogYnl0ZXNUb051bWJlckxFKGtleSk7XG4gICAgLy8gYG1vZCh4LCAxMSlgIGNhbiBzb21ldGltZXMgcHJvZHVjZSAwLiBgbW9kKHgsIDEwKSArIDFgIGlzIHRoZSBzYW1lLCBidXQgbm8gMFxuICAgIGNvbnN0IHJlZHVjZWQgPSBtb2QobnVtLCBmaWVsZE9yZGVyIC0gXzFuKSArIF8xbjtcbiAgICByZXR1cm4gaXNMRSA/IG51bWJlclRvQnl0ZXNMRShyZWR1Y2VkLCBmaWVsZExlbikgOiBudW1iZXJUb0J5dGVzQkUocmVkdWNlZCwgZmllbGRMZW4pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxhci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/modular.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/utils.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/utils.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bitGet: () => (/* binding */ bitGet),\n/* harmony export */   bitLen: () => (/* binding */ bitLen),\n/* harmony export */   bitMask: () => (/* binding */ bitMask),\n/* harmony export */   bitSet: () => (/* binding */ bitSet),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   bytesToNumberBE: () => (/* binding */ bytesToNumberBE),\n/* harmony export */   bytesToNumberLE: () => (/* binding */ bytesToNumberLE),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createHmacDrbg: () => (/* binding */ createHmacDrbg),\n/* harmony export */   ensureBytes: () => (/* binding */ ensureBytes),\n/* harmony export */   equalBytes: () => (/* binding */ equalBytes),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   hexToNumber: () => (/* binding */ hexToNumber),\n/* harmony export */   numberToBytesBE: () => (/* binding */ numberToBytesBE),\n/* harmony export */   numberToBytesLE: () => (/* binding */ numberToBytesLE),\n/* harmony export */   numberToHexUnpadded: () => (/* binding */ numberToHexUnpadded),\n/* harmony export */   numberToVarBytesBE: () => (/* binding */ numberToVarBytesBE),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   validateObject: () => (/* binding */ validateObject)\n/* harmony export */ });\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst u8a = (a) => a instanceof Uint8Array;\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    if (!u8a(bytes))\n        throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // Big Endian\n    return BigInt(hex === '' ? '0' : `0x${hex}`);\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const len = hex.length;\n    if (len % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n    const array = new Uint8Array(len / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction bytesToNumberLE(bytes) {\n    if (!u8a(bytes))\n        throw new Error('Uint8Array expected');\n    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nfunction numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nfunction numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nfunction numberToVarBytesBE(n) {\n    return hexToBytes(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nfunction ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === 'string') {\n        try {\n            res = hexToBytes(hex);\n        }\n        catch (e) {\n            throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`);\n        }\n    }\n    else if (u8a(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    }\n    else {\n        throw new Error(`${title} must be hex string or Uint8Array`);\n    }\n    const len = res.length;\n    if (typeof expectedLength === 'number' && len !== expectedLength)\n        throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);\n    return res;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n    let pad = 0; // walk through each item, ensure they have proper type\n    arrays.forEach((a) => {\n        if (!u8a(a))\n            throw new Error('Uint8Array expected');\n        r.set(a, pad);\n        pad += a.length;\n    });\n    return r;\n}\nfunction equalBytes(b1, b2) {\n    // We don't care about timing attacks here\n    if (b1.length !== b2.length)\n        return false;\n    for (let i = 0; i < b1.length; i++)\n        if (b1[i] !== b2[i])\n            return false;\n    return true;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */\nfunction bitLen(n) {\n    let len;\n    for (len = 0; n > _0n; n >>= _1n, len += 1)\n        ;\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nfunction bitGet(n, pos) {\n    return (n >> BigInt(pos)) & _1n;\n}\n/**\n * Sets single bit at position.\n */\nconst bitSet = (n, pos, value) => {\n    return n | ((value ? _1n : _0n) << BigInt(pos));\n};\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nconst bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;\n// DRBG\nconst u8n = (data) => new Uint8Array(data); // creates Uint8Array\nconst u8fr = (arr) => Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nfunction createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== 'number' || hashLen < 2)\n        throw new Error('hashLen must be a number');\n    if (typeof qByteLen !== 'number' || qByteLen < 2)\n        throw new Error('qByteLen must be a number');\n    if (typeof hmacFn !== 'function')\n        throw new Error('hmacFn must be a function');\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = () => {\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n()) => {\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0)\n            return;\n        k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = () => {\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000)\n            throw new Error('drbg: tried 1000 values');\n        let len = 0;\n        const out = [];\n        while (len < qByteLen) {\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes(...out);\n    };\n    const genUntil = (seed, pred) => {\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while (!(res = pred(gen())))\n            reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val) => typeof val === 'bigint',\n    function: (val) => typeof val === 'function',\n    boolean: (val) => typeof val === 'boolean',\n    string: (val) => typeof val === 'string',\n    stringOrUint8Array: (val) => typeof val === 'string' || val instanceof Uint8Array,\n    isSafeInteger: (val) => Number.isSafeInteger(val),\n    array: (val) => Array.isArray(val),\n    field: (val, object) => object.Fp.isValid(val),\n    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nfunction validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional) => {\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== 'function')\n            throw new Error(`Invalid validator \"${type}\", expected function`);\n        const val = object[fieldName];\n        if (isOptional && val === undefined)\n            return;\n        if (!checkVal(val, object)) {\n            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))\n        checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))\n        checkField(fieldName, type, true);\n    return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9zdHItZGV2LWtpdC9uZGsvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGFBQWE7QUFDeEQ7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsZ0NBQWdDLElBQUk7QUFDcEM7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxJQUFJO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsT0FBTyxpQ0FBaUMsSUFBSSxZQUFZLEVBQUU7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixPQUFPO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixPQUFPLFdBQVcsZ0JBQWdCLGFBQWEsSUFBSTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDREQUE0RCxXQUFXO0FBQ3ZFLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNEJBQTRCO0FBQ25EO0FBQ087QUFDUDtBQUNBLDRDQUE0QztBQUM1Qyw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQ25ELDhEQUE4RDtBQUNyRTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsS0FBSztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxrQkFBa0IsR0FBRyxLQUFLLEdBQUcsV0FBVyxjQUFjLEtBQUs7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxXQUFXLFdBQVcsWUFBWSxJQUFJO0FBQ3BELGtDQUFrQyxvQkFBb0IsSUFBSSxhQUFhLEdBQUc7QUFDMUU7QUFDQSxrQ0FBa0MsVUFBVSxJQUFJLFNBQVM7QUFDekQsa0NBQWtDLG9CQUFvQixJQUFJLFNBQVM7QUFDbkUsa0NBQWtDLDJCQUEyQjtBQUM3RCxrQ0FBa0Msd0JBQXdCO0FBQzFEIiwic291cmNlcyI6WyIvaG9tZS9sZmcvR2l0L01hZHRyaXBzL25vZGVfbW9kdWxlcy9Abm9zdHItZGV2LWtpdC9uZGsvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC91dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyAxMDAgbGluZXMgb2YgY29kZSBpbiB0aGUgZmlsZSBhcmUgZHVwbGljYXRlZCBmcm9tIG5vYmxlLWhhc2hlcyAodXRpbHMpLlxuLy8gVGhpcyBpcyBPSzogYGFic3RyYWN0YCBkaXJlY3RvcnkgZG9lcyBub3QgdXNlIG5vYmxlLWhhc2hlcy5cbi8vIFVzZXIgbWF5IG9wdC1pbiBpbnRvIHVzaW5nIGRpZmZlcmVudCBoYXNoaW5nIGxpYnJhcnkuIFRoaXMgd2F5LCBub2JsZS1oYXNoZXNcbi8vIHdvbid0IGJlIGluY2x1ZGVkIGludG8gdGhlaXIgYnVuZGxlLlxuY29uc3QgXzBuID0gQmlnSW50KDApO1xuY29uc3QgXzFuID0gQmlnSW50KDEpO1xuY29uc3QgXzJuID0gQmlnSW50KDIpO1xuY29uc3QgdThhID0gKGEpID0+IGEgaW5zdGFuY2VvZiBVaW50OEFycmF5O1xuY29uc3QgaGV4ZXMgPSAvKiBAX19QVVJFX18gKi8gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sIChfLCBpKSA9PiBpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbi8qKlxuICogQGV4YW1wbGUgYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKSkgLy8gJ2NhZmUwMTIzJ1xuICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuICAgIGlmICghdThhKGJ5dGVzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgLy8gcHJlLWNhY2hpbmcgaW1wcm92ZXMgdGhlIHNwZWVkIDZ4XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IGhleGVzW2J5dGVzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb0hleFVucGFkZGVkKG51bSkge1xuICAgIGNvbnN0IGhleCA9IG51bS50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIGhleC5sZW5ndGggJiAxID8gYDAke2hleH1gIDogaGV4O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhleFRvTnVtYmVyKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIC8vIEJpZyBFbmRpYW5cbiAgICByZXR1cm4gQmlnSW50KGhleCA9PT0gJycgPyAnMCcgOiBgMHgke2hleH1gKTtcbn1cbi8qKlxuICogQGV4YW1wbGUgaGV4VG9CeXRlcygnY2FmZTAxMjMnKSAvLyBVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGV4VG9CeXRlcyhoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICBjb25zdCBsZW4gPSBoZXgubGVuZ3RoO1xuICAgIGlmIChsZW4gJSAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRlZCBoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgdW5wYWRkZWQgaGV4IG9mIGxlbmd0aCAnICsgbGVuKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGxlbiAvIDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaiA9IGkgKiAyO1xuICAgICAgICBjb25zdCBoZXhCeXRlID0gaGV4LnNsaWNlKGosIGogKyAyKTtcbiAgICAgICAgY29uc3QgYnl0ZSA9IE51bWJlci5wYXJzZUludChoZXhCeXRlLCAxNik7XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4oYnl0ZSkgfHwgYnl0ZSA8IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYnl0ZSBzZXF1ZW5jZScpO1xuICAgICAgICBhcnJheVtpXSA9IGJ5dGU7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbi8vIEJFOiBCaWcgRW5kaWFuLCBMRTogTGl0dGxlIEVuZGlhblxuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9OdW1iZXJCRShieXRlcykge1xuICAgIHJldHVybiBoZXhUb051bWJlcihieXRlc1RvSGV4KGJ5dGVzKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb051bWJlckxFKGJ5dGVzKSB7XG4gICAgaWYgKCF1OGEoYnl0ZXMpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbiAgICByZXR1cm4gaGV4VG9OdW1iZXIoYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oYnl0ZXMpLnJldmVyc2UoKSkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlclRvQnl0ZXNCRShuLCBsZW4pIHtcbiAgICByZXR1cm4gaGV4VG9CeXRlcyhuLnRvU3RyaW5nKDE2KS5wYWRTdGFydChsZW4gKiAyLCAnMCcpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb0J5dGVzTEUobiwgbGVuKSB7XG4gICAgcmV0dXJuIG51bWJlclRvQnl0ZXNCRShuLCBsZW4pLnJldmVyc2UoKTtcbn1cbi8vIFVucGFkZGVkLCByYXJlbHkgdXNlZFxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlclRvVmFyQnl0ZXNCRShuKSB7XG4gICAgcmV0dXJuIGhleFRvQnl0ZXMobnVtYmVyVG9IZXhVbnBhZGRlZChuKSk7XG59XG4vKipcbiAqIFRha2VzIGhleCBzdHJpbmcgb3IgVWludDhBcnJheSwgY29udmVydHMgdG8gVWludDhBcnJheS5cbiAqIFZhbGlkYXRlcyBvdXRwdXQgbGVuZ3RoLlxuICogV2lsbCB0aHJvdyBlcnJvciBmb3Igb3RoZXIgdHlwZXMuXG4gKiBAcGFyYW0gdGl0bGUgZGVzY3JpcHRpdmUgdGl0bGUgZm9yIGFuIGVycm9yIGUuZy4gJ3ByaXZhdGUga2V5J1xuICogQHBhcmFtIGhleCBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXlcbiAqIEBwYXJhbSBleHBlY3RlZExlbmd0aCBvcHRpb25hbCwgd2lsbCBjb21wYXJlIHRvIHJlc3VsdCBhcnJheSdzIGxlbmd0aFxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZUJ5dGVzKHRpdGxlLCBoZXgsIGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgbGV0IHJlcztcbiAgICBpZiAodHlwZW9mIGhleCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlcyA9IGhleFRvQnl0ZXMoaGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RpdGxlfSBtdXN0IGJlIHZhbGlkIGhleCBzdHJpbmcsIGdvdCBcIiR7aGV4fVwiLiBDYXVzZTogJHtlfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHU4YShoZXgpKSB7XG4gICAgICAgIC8vIFVpbnQ4QXJyYXkuZnJvbSgpIGluc3RlYWQgb2YgaGFzaC5zbGljZSgpIGJlY2F1c2Ugbm9kZS5qcyBCdWZmZXJcbiAgICAgICAgLy8gaXMgaW5zdGFuY2Ugb2YgVWludDhBcnJheSwgYW5kIGl0cyBzbGljZSgpIGNyZWF0ZXMgKiptdXRhYmxlKiogY29weVxuICAgICAgICByZXMgPSBVaW50OEFycmF5LmZyb20oaGV4KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aXRsZX0gbXVzdCBiZSBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXlgKTtcbiAgICB9XG4gICAgY29uc3QgbGVuID0gcmVzLmxlbmd0aDtcbiAgICBpZiAodHlwZW9mIGV4cGVjdGVkTGVuZ3RoID09PSAnbnVtYmVyJyAmJiBsZW4gIT09IGV4cGVjdGVkTGVuZ3RoKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGl0bGV9IGV4cGVjdGVkICR7ZXhwZWN0ZWRMZW5ndGh9IGJ5dGVzLCBnb3QgJHtsZW59YCk7XG4gICAgcmV0dXJuIHJlcztcbn1cbi8qKlxuICogQ29waWVzIHNldmVyYWwgVWludDhBcnJheXMgaW50byBvbmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25jYXRCeXRlcyguLi5hcnJheXMpIHtcbiAgICBjb25zdCByID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlzLnJlZHVjZSgoc3VtLCBhKSA9PiBzdW0gKyBhLmxlbmd0aCwgMCkpO1xuICAgIGxldCBwYWQgPSAwOyAvLyB3YWxrIHRocm91Z2ggZWFjaCBpdGVtLCBlbnN1cmUgdGhleSBoYXZlIHByb3BlciB0eXBlXG4gICAgYXJyYXlzLmZvckVhY2goKGEpID0+IHtcbiAgICAgICAgaWYgKCF1OGEoYSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAgICAgci5zZXQoYSwgcGFkKTtcbiAgICAgICAgcGFkICs9IGEubGVuZ3RoO1xuICAgIH0pO1xuICAgIHJldHVybiByO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVxdWFsQnl0ZXMoYjEsIGIyKSB7XG4gICAgLy8gV2UgZG9uJ3QgY2FyZSBhYm91dCB0aW1pbmcgYXR0YWNrcyBoZXJlXG4gICAgaWYgKGIxLmxlbmd0aCAhPT0gYjIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiMS5sZW5ndGg7IGkrKylcbiAgICAgICAgaWYgKGIxW2ldICE9PSBiMltpXSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogQGV4YW1wbGUgdXRmOFRvQnl0ZXMoJ2FiYycpIC8vIG5ldyBVaW50OEFycmF5KFs5NywgOTgsIDk5XSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1dGY4VG9CeXRlcyBleHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiBzdHJ9YCk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpKTsgLy8gaHR0cHM6Ly9idWd6aWwubGEvMTY4MTgwOVxufVxuLy8gQml0IG9wZXJhdGlvbnNcbi8qKlxuICogQ2FsY3VsYXRlcyBhbW91bnQgb2YgYml0cyBpbiBhIGJpZ2ludC5cbiAqIFNhbWUgYXMgYG4udG9TdHJpbmcoMikubGVuZ3RoYFxuICovXG5leHBvcnQgZnVuY3Rpb24gYml0TGVuKG4pIHtcbiAgICBsZXQgbGVuO1xuICAgIGZvciAobGVuID0gMDsgbiA+IF8wbjsgbiA+Pj0gXzFuLCBsZW4gKz0gMSlcbiAgICAgICAgO1xuICAgIHJldHVybiBsZW47XG59XG4vKipcbiAqIEdldHMgc2luZ2xlIGJpdCBhdCBwb3NpdGlvbi5cbiAqIE5PVEU6IGZpcnN0IGJpdCBwb3NpdGlvbiBpcyAwIChzYW1lIGFzIGFycmF5cylcbiAqIFNhbWUgYXMgYCEhK0FycmF5LmZyb20obi50b1N0cmluZygyKSkucmV2ZXJzZSgpW3Bvc11gXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaXRHZXQobiwgcG9zKSB7XG4gICAgcmV0dXJuIChuID4+IEJpZ0ludChwb3MpKSAmIF8xbjtcbn1cbi8qKlxuICogU2V0cyBzaW5nbGUgYml0IGF0IHBvc2l0aW9uLlxuICovXG5leHBvcnQgY29uc3QgYml0U2V0ID0gKG4sIHBvcywgdmFsdWUpID0+IHtcbiAgICByZXR1cm4gbiB8ICgodmFsdWUgPyBfMW4gOiBfMG4pIDw8IEJpZ0ludChwb3MpKTtcbn07XG4vKipcbiAqIENhbGN1bGF0ZSBtYXNrIGZvciBOIGJpdHMuIE5vdCB1c2luZyAqKiBvcGVyYXRvciB3aXRoIGJpZ2ludHMgYmVjYXVzZSBvZiBvbGQgZW5naW5lcy5cbiAqIFNhbWUgYXMgQmlnSW50KGAwYiR7QXJyYXkoaSkuZmlsbCgnMScpLmpvaW4oJycpfWApXG4gKi9cbmV4cG9ydCBjb25zdCBiaXRNYXNrID0gKG4pID0+IChfMm4gPDwgQmlnSW50KG4gLSAxKSkgLSBfMW47XG4vLyBEUkJHXG5jb25zdCB1OG4gPSAoZGF0YSkgPT4gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7IC8vIGNyZWF0ZXMgVWludDhBcnJheVxuY29uc3QgdThmciA9IChhcnIpID0+IFVpbnQ4QXJyYXkuZnJvbShhcnIpOyAvLyBhbm90aGVyIHNob3J0Y3V0XG4vKipcbiAqIE1pbmltYWwgSE1BQy1EUkJHIGZyb20gTklTVCA4MDAtOTAgZm9yIFJGQzY5Nzkgc2lncy5cbiAqIEByZXR1cm5zIGZ1bmN0aW9uIHRoYXQgd2lsbCBjYWxsIERSQkcgdW50aWwgMm5kIGFyZyByZXR1cm5zIHNvbWV0aGluZyBtZWFuaW5nZnVsXG4gKiBAZXhhbXBsZVxuICogICBjb25zdCBkcmJnID0gY3JlYXRlSG1hY0RSQkc8S2V5PigzMiwgMzIsIGhtYWMpO1xuICogICBkcmJnKHNlZWQsIGJ5dGVzVG9LZXkpOyAvLyBieXRlc1RvS2V5IG11c3QgcmV0dXJuIEtleSBvciB1bmRlZmluZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUhtYWNEcmJnKGhhc2hMZW4sIHFCeXRlTGVuLCBobWFjRm4pIHtcbiAgICBpZiAodHlwZW9mIGhhc2hMZW4gIT09ICdudW1iZXInIHx8IGhhc2hMZW4gPCAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hhc2hMZW4gbXVzdCBiZSBhIG51bWJlcicpO1xuICAgIGlmICh0eXBlb2YgcUJ5dGVMZW4gIT09ICdudW1iZXInIHx8IHFCeXRlTGVuIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdxQnl0ZUxlbiBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgaWYgKHR5cGVvZiBobWFjRm4gIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaG1hY0ZuIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIC8vIFN0ZXAgQiwgU3RlcCBDOiBzZXQgaGFzaExlbiB0byA4KmNlaWwoaGxlbi84KVxuICAgIGxldCB2ID0gdThuKGhhc2hMZW4pOyAvLyBNaW5pbWFsIG5vbi1mdWxsLXNwZWMgSE1BQy1EUkJHIGZyb20gTklTVCA4MDAtOTAgZm9yIFJGQzY5Nzkgc2lncy5cbiAgICBsZXQgayA9IHU4bihoYXNoTGVuKTsgLy8gU3RlcHMgQiBhbmQgQyBvZiBSRkM2OTc5IDMuMjogc2V0IGhhc2hMZW4sIGluIG91ciBjYXNlIGFsd2F5cyBzYW1lXG4gICAgbGV0IGkgPSAwOyAvLyBJdGVyYXRpb25zIGNvdW50ZXIsIHdpbGwgdGhyb3cgd2hlbiBvdmVyIDEwMDBcbiAgICBjb25zdCByZXNldCA9ICgpID0+IHtcbiAgICAgICAgdi5maWxsKDEpO1xuICAgICAgICBrLmZpbGwoMCk7XG4gICAgICAgIGkgPSAwO1xuICAgIH07XG4gICAgY29uc3QgaCA9ICguLi5iKSA9PiBobWFjRm4oaywgdiwgLi4uYik7IC8vIGhtYWMoaykodiwgLi4udmFsdWVzKVxuICAgIGNvbnN0IHJlc2VlZCA9IChzZWVkID0gdThuKCkpID0+IHtcbiAgICAgICAgLy8gSE1BQy1EUkJHIHJlc2VlZCgpIGZ1bmN0aW9uLiBTdGVwcyBELUdcbiAgICAgICAgayA9IGgodThmcihbMHgwMF0pLCBzZWVkKTsgLy8gayA9IGhtYWMoayB8fCB2IHx8IDB4MDAgfHwgc2VlZClcbiAgICAgICAgdiA9IGgoKTsgLy8gdiA9IGhtYWMoayB8fCB2KVxuICAgICAgICBpZiAoc2VlZC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGsgPSBoKHU4ZnIoWzB4MDFdKSwgc2VlZCk7IC8vIGsgPSBobWFjKGsgfHwgdiB8fCAweDAxIHx8IHNlZWQpXG4gICAgICAgIHYgPSBoKCk7IC8vIHYgPSBobWFjKGsgfHwgdilcbiAgICB9O1xuICAgIGNvbnN0IGdlbiA9ICgpID0+IHtcbiAgICAgICAgLy8gSE1BQy1EUkJHIGdlbmVyYXRlKCkgZnVuY3Rpb25cbiAgICAgICAgaWYgKGkrKyA+PSAxMDAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkcmJnOiB0cmllZCAxMDAwIHZhbHVlcycpO1xuICAgICAgICBsZXQgbGVuID0gMDtcbiAgICAgICAgY29uc3Qgb3V0ID0gW107XG4gICAgICAgIHdoaWxlIChsZW4gPCBxQnl0ZUxlbikge1xuICAgICAgICAgICAgdiA9IGgoKTtcbiAgICAgICAgICAgIGNvbnN0IHNsID0gdi5zbGljZSgpO1xuICAgICAgICAgICAgb3V0LnB1c2goc2wpO1xuICAgICAgICAgICAgbGVuICs9IHYubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25jYXRCeXRlcyguLi5vdXQpO1xuICAgIH07XG4gICAgY29uc3QgZ2VuVW50aWwgPSAoc2VlZCwgcHJlZCkgPT4ge1xuICAgICAgICByZXNldCgpO1xuICAgICAgICByZXNlZWQoc2VlZCk7IC8vIFN0ZXBzIEQtR1xuICAgICAgICBsZXQgcmVzID0gdW5kZWZpbmVkOyAvLyBTdGVwIEg6IGdyaW5kIHVudGlsIGsgaXMgaW4gWzEuLm4tMV1cbiAgICAgICAgd2hpbGUgKCEocmVzID0gcHJlZChnZW4oKSkpKVxuICAgICAgICAgICAgcmVzZWVkKCk7XG4gICAgICAgIHJlc2V0KCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICByZXR1cm4gZ2VuVW50aWw7XG59XG4vLyBWYWxpZGF0aW5nIGN1cnZlcyBhbmQgZmllbGRzXG5jb25zdCB2YWxpZGF0b3JGbnMgPSB7XG4gICAgYmlnaW50OiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnYmlnaW50JyxcbiAgICBmdW5jdGlvbjogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyxcbiAgICBib29sZWFuOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnYm9vbGVhbicsXG4gICAgc3RyaW5nOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyxcbiAgICBzdHJpbmdPclVpbnQ4QXJyYXk6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnIHx8IHZhbCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXksXG4gICAgaXNTYWZlSW50ZWdlcjogKHZhbCkgPT4gTnVtYmVyLmlzU2FmZUludGVnZXIodmFsKSxcbiAgICBhcnJheTogKHZhbCkgPT4gQXJyYXkuaXNBcnJheSh2YWwpLFxuICAgIGZpZWxkOiAodmFsLCBvYmplY3QpID0+IG9iamVjdC5GcC5pc1ZhbGlkKHZhbCksXG4gICAgaGFzaDogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyAmJiBOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWwub3V0cHV0TGVuKSxcbn07XG4vLyB0eXBlIFJlY29yZDxLIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyIHwgc3ltYm9sLCBUPiA9IHsgW1AgaW4gS106IFQ7IH1cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZU9iamVjdChvYmplY3QsIHZhbGlkYXRvcnMsIG9wdFZhbGlkYXRvcnMgPSB7fSkge1xuICAgIGNvbnN0IGNoZWNrRmllbGQgPSAoZmllbGROYW1lLCB0eXBlLCBpc09wdGlvbmFsKSA9PiB7XG4gICAgICAgIGNvbnN0IGNoZWNrVmFsID0gdmFsaWRhdG9yRm5zW3R5cGVdO1xuICAgICAgICBpZiAodHlwZW9mIGNoZWNrVmFsICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHZhbGlkYXRvciBcIiR7dHlwZX1cIiwgZXhwZWN0ZWQgZnVuY3Rpb25gKTtcbiAgICAgICAgY29uc3QgdmFsID0gb2JqZWN0W2ZpZWxkTmFtZV07XG4gICAgICAgIGlmIChpc09wdGlvbmFsICYmIHZhbCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIWNoZWNrVmFsKHZhbCwgb2JqZWN0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHBhcmFtICR7U3RyaW5nKGZpZWxkTmFtZSl9PSR7dmFsfSAoJHt0eXBlb2YgdmFsfSksIGV4cGVjdGVkICR7dHlwZX1gKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZm9yIChjb25zdCBbZmllbGROYW1lLCB0eXBlXSBvZiBPYmplY3QuZW50cmllcyh2YWxpZGF0b3JzKSlcbiAgICAgICAgY2hlY2tGaWVsZChmaWVsZE5hbWUsIHR5cGUsIGZhbHNlKTtcbiAgICBmb3IgKGNvbnN0IFtmaWVsZE5hbWUsIHR5cGVdIG9mIE9iamVjdC5lbnRyaWVzKG9wdFZhbGlkYXRvcnMpKVxuICAgICAgICBjaGVja0ZpZWxkKGZpZWxkTmFtZSwgdHlwZSwgdHJ1ZSk7XG4gICAgcmV0dXJuIG9iamVjdDtcbn1cbi8vIHZhbGlkYXRlIHR5cGUgdGVzdHNcbi8vIGNvbnN0IG86IHsgYTogbnVtYmVyOyBiOiBudW1iZXI7IGM6IG51bWJlciB9ID0geyBhOiAxLCBiOiA1LCBjOiA2IH07XG4vLyBjb25zdCB6MCA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ2lzU2FmZUludGVnZXInIH0sIHsgYzogJ2JpZ2ludCcgfSk7IC8vIE9rIVxuLy8gLy8gU2hvdWxkIGZhaWwgdHlwZS1jaGVja1xuLy8gY29uc3QgejEgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICd0bXAnIH0sIHsgYzogJ3p6JyB9KTtcbi8vIGNvbnN0IHoyID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAnaXNTYWZlSW50ZWdlcicgfSwgeyBjOiAnenonIH0pO1xuLy8gY29uc3QgejMgPSB2YWxpZGF0ZU9iamVjdChvLCB7IHRlc3Q6ICdib29sZWFuJywgejogJ2J1ZycgfSk7XG4vLyBjb25zdCB6NCA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ2Jvb2xlYW4nLCB6OiAnYnVnJyB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/weierstrass.js":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/weierstrass.js ***!
  \*************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DER: () => (/* binding */ DER),\n/* harmony export */   SWUFpSqrtRatio: () => (/* binding */ SWUFpSqrtRatio),\n/* harmony export */   mapToCurveSimpleSWU: () => (/* binding */ mapToCurveSimpleSWU),\n/* harmony export */   weierstrass: () => (/* binding */ weierstrass),\n/* harmony export */   weierstrassPoints: () => (/* binding */ weierstrassPoints)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modular.js */ \"(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _curve_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curve.js */ \"(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/curve.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Short Weierstrass curve. The formula is: y¬≤ = x¬≥ + ax + b\n\n\n\n\nfunction validatePointOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject(opts, {\n        a: 'field',\n        b: 'field',\n    }, {\n        allowedPrivateKeyLengths: 'array',\n        wrapPrivateKey: 'boolean',\n        isTorsionFree: 'function',\n        clearCofactor: 'function',\n        allowInfinityPoint: 'boolean',\n        fromBytes: 'function',\n        toBytes: 'function',\n    });\n    const { endo, Fp, a } = opts;\n    if (endo) {\n        if (!Fp.eql(a, Fp.ZERO)) {\n            throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');\n        }\n        if (typeof endo !== 'object' ||\n            typeof endo.beta !== 'bigint' ||\n            typeof endo.splitScalar !== 'function') {\n            throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');\n        }\n    }\n    return Object.freeze({ ...opts });\n}\n// ASN.1 DER encoding utilities\nconst { bytesToNumberBE: b2n, hexToBytes: h2b } = _utils_js__WEBPACK_IMPORTED_MODULE_1__;\nconst DER = {\n    // asn.1 DER encoding utils\n    Err: class DERErr extends Error {\n        constructor(m = '') {\n            super(m);\n        }\n    },\n    _parseInt(data) {\n        const { Err: E } = DER;\n        if (data.length < 2 || data[0] !== 0x02)\n            throw new E('Invalid signature integer tag');\n        const len = data[1];\n        const res = data.subarray(2, len + 2);\n        if (!len || res.length !== len)\n            throw new E('Invalid signature integer: wrong length');\n        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n        // since we always use positive integers here. It must always be empty:\n        // - add zero byte if exists\n        // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n        if (res[0] & 0b10000000)\n            throw new E('Invalid signature integer: negative');\n        if (res[0] === 0x00 && !(res[1] & 0b10000000))\n            throw new E('Invalid signature integer: unnecessary leading zero');\n        return { d: b2n(res), l: data.subarray(len + 2) }; // d is data, l is left\n    },\n    toSig(hex) {\n        // parse DER signature\n        const { Err: E } = DER;\n        const data = typeof hex === 'string' ? h2b(hex) : hex;\n        if (!(data instanceof Uint8Array))\n            throw new Error('ui8a expected');\n        let l = data.length;\n        if (l < 2 || data[0] != 0x30)\n            throw new E('Invalid signature tag');\n        if (data[1] !== l - 2)\n            throw new E('Invalid signature: incorrect length');\n        const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));\n        const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);\n        if (rBytesLeft.length)\n            throw new E('Invalid signature: left bytes after parsing');\n        return { r, s };\n    },\n    hexFromSig(sig) {\n        // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'\n        const slice = (s) => (Number.parseInt(s[0], 16) & 0b1000 ? '00' + s : s);\n        const h = (num) => {\n            const hex = num.toString(16);\n            return hex.length & 1 ? `0${hex}` : hex;\n        };\n        const s = slice(h(sig.s));\n        const r = slice(h(sig.r));\n        const shl = s.length / 2;\n        const rhl = r.length / 2;\n        const sl = h(shl);\n        const rl = h(rhl);\n        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;\n    },\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nfunction weierstrassPoints(opts) {\n    const CURVE = validatePointOpts(opts);\n    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n    const toBytes = CURVE.toBytes ||\n        ((_c, point, _isCompressed) => {\n            const a = point.toAffine();\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n        });\n    const fromBytes = CURVE.fromBytes ||\n        ((bytes) => {\n            // const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n            return { x, y };\n        });\n    /**\n     * y¬≤ = x¬≥ + ax + b: Short weierstrass curve formula\n     * @returns y¬≤\n     */\n    function weierstrassEquation(x) {\n        const { a, b } = CURVE;\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x2 * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n    }\n    // Validate whether the passed curve params are valid.\n    // We check if curve equation works for generator point.\n    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\n    // ProjectivePoint class has not been initialized yet.\n    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))\n        throw new Error('bad generator point: equation left != right');\n    // Valid group elements reside in range 1..n-1\n    function isWithinCurveOrder(num) {\n        return typeof num === 'bigint' && _0n < num && num < CURVE.n;\n    }\n    function assertGE(num) {\n        if (!isWithinCurveOrder(num))\n            throw new Error('Expected valid bigint: 0 < bigint < curve.n');\n    }\n    // Validates if priv key is valid and converts it to bigint.\n    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n    function normPrivateKeyToScalar(key) {\n        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;\n        if (lengths && typeof key !== 'bigint') {\n            if (key instanceof Uint8Array)\n                key = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(key);\n            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n            if (typeof key !== 'string' || !lengths.includes(key.length))\n                throw new Error('Invalid key');\n            key = key.padStart(nByteLength * 2, '0');\n        }\n        let num;\n        try {\n            num =\n                typeof key === 'bigint'\n                    ? key\n                    : _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('private key', key, nByteLength));\n        }\n        catch (error) {\n            throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);\n        }\n        if (wrapPrivateKey)\n            num = _modular_js__WEBPACK_IMPORTED_MODULE_2__.mod(num, n); // disabled by default, enabled for BLS\n        assertGE(num); // num in range [1..N-1]\n        return num;\n    }\n    const pointPrecomputes = new Map();\n    function assertPrjPoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('ProjectivePoint expected');\n    }\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z) ‚àã (x=x/z, y=y/z)\n     * Default Point works in 2d / affine coordinates: (x, y)\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */\n    class Point {\n        constructor(px, py, pz) {\n            this.px = px;\n            this.py = py;\n            this.pz = pz;\n            if (px == null || !Fp.isValid(px))\n                throw new Error('x required');\n            if (py == null || !Fp.isValid(py))\n                throw new Error('y required');\n            if (pz == null || !Fp.isValid(pz))\n                throw new Error('z required');\n        }\n        // Does not validate if the point is on-curve.\n        // Use fromHex instead, or call assertValidity() later.\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('invalid affine point');\n            if (p instanceof Point)\n                throw new Error('projective point not allowed');\n            const is0 = (i) => Fp.eql(i, Fp.ZERO);\n            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n            if (is0(x) && is0(y))\n                return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         * Takes a bunch of Projective Points but executes only one\n         * inversion on all of them. Inversion is very slow operation,\n         * so this improves performance massively.\n         * Optimization: converts a list of projective points to a list of identical points with Z=1.\n         */\n        static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p) => p.pz));\n            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        /**\n         * Converts hash string or Uint8Array to Point.\n         * @param hex short/long ECDSA hex\n         */\n        static fromHex(hex) {\n            const P = Point.fromAffine(fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('pointHex', hex)));\n            P.assertValidity();\n            return P;\n        }\n        // Multiplies generator point by privateKey.\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            this._WINDOW_SIZE = windowSize;\n            pointPrecomputes.delete(this);\n        }\n        // A point on curve is valid if it conforms to equation.\n        assertValidity() {\n            if (this.is0()) {\n                // (0, 1, 0) aka ZERO is invalid in most contexts.\n                // In BLS, ZERO can be serialized, so we allow it.\n                // (0, 0, 0) is wrong representation of ZERO and is always invalid.\n                if (CURVE.allowInfinityPoint && !Fp.is0(this.py))\n                    return;\n                throw new Error('bad point: ZERO');\n            }\n            // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n            const { x, y } = this.toAffine();\n            // Check if x, y are valid field elements\n            if (!Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('bad point: x or y not FE');\n            const left = Fp.sqr(y); // y¬≤\n            const right = weierstrassEquation(x); // x¬≥ + ax + b\n            if (!Fp.eql(left, right))\n                throw new Error('bad point: equation left != right');\n            if (!this.isTorsionFree())\n                throw new Error('bad point: not in prime-order subgroup');\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (Fp.isOdd)\n                return !Fp.isOdd(y);\n            throw new Error(\"Field doesn't support isOdd\");\n        }\n        /**\n         * Compare one point to another.\n         */\n        equals(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /**\n         * Flips point to one corresponding to (x, -y) in Affine coordinates.\n         */\n        negate() {\n            return new Point(this.px, Fp.neg(this.py), this.pz);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {\n                const toInv = Fp.invertBatch(comp.map((p) => p.pz));\n                return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n            });\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed private key e.g. sig verification, which works over *public* keys.\n         */\n        multiplyUnsafe(n) {\n            const I = Point.ZERO;\n            if (n === _0n)\n                return I;\n            assertGE(n); // Will throw on 0\n            if (n === _1n)\n                return this;\n            const { endo } = CURVE;\n            if (!endo)\n                return wnaf.unsafeLadder(this, n);\n            // Apply endomorphism\n            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n            let k1p = I;\n            let k2p = I;\n            let d = this;\n            while (k1 > _0n || k2 > _0n) {\n                if (k1 & _1n)\n                    k1p = k1p.add(d);\n                if (k2 & _1n)\n                    k2p = k2p.add(d);\n                d = d.double();\n                k1 >>= _1n;\n                k2 >>= _1n;\n            }\n            if (k1neg)\n                k1p = k1p.negate();\n            if (k2neg)\n                k2p = k2p.negate();\n            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n            return k1p.add(k2p);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */\n        multiply(scalar) {\n            assertGE(scalar);\n            let n = scalar;\n            let point, fake; // Fake point is used to const-time mult\n            const { endo } = CURVE;\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n                let { p: k1p, f: f1p } = this.wNAF(k1);\n                let { p: k2p, f: f2p } = this.wNAF(k2);\n                k1p = wnaf.constTimeNegate(k1neg, k1p);\n                k2p = wnaf.constTimeNegate(k2neg, k2p);\n                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n                point = k1p.add(k2p);\n                fake = f1p.add(f2p);\n            }\n            else {\n                const { p, f } = this.wNAF(n);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return Point.normalizeZ([point, fake])[0];\n        }\n        /**\n         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n         * Not using Strauss-Shamir trick: precomputation tables are faster.\n         * The trick could be useful if both P and Q are not G (not in our case).\n         * @returns non-zero affine point\n         */\n        multiplyAndAddUnsafe(Q, a, b) {\n            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n            const mul = (P, a // Select faster multiply() method\n            ) => (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));\n            const sum = mul(this, a).add(mul(Q, b));\n            return sum.is0() ? undefined : sum;\n        }\n        // Converts Projective point to affine (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        // (x, y, z) ‚àã (x=x/z, y=y/z)\n        toAffine(iz) {\n            const { px: x, py: y, pz: z } = this;\n            const is0 = this.is0();\n            // If invZ was 0, we return zero point. However we still want to execute\n            // all operations, so we replace invZ with a random number, 1.\n            if (iz == null)\n                iz = is0 ? Fp.ONE : Fp.inv(z);\n            const ax = Fp.mul(x, iz);\n            const ay = Fp.mul(y, iz);\n            const zz = Fp.mul(z, iz);\n            if (is0)\n                return { x: Fp.ZERO, y: Fp.ZERO };\n            if (!Fp.eql(zz, Fp.ONE))\n                throw new Error('invZ was invalid');\n            return { x: ax, y: ay };\n        }\n        isTorsionFree() {\n            const { h: cofactor, isTorsionFree } = CURVE;\n            if (cofactor === _1n)\n                return true; // No subgroups, always torsion-free\n            if (isTorsionFree)\n                return isTorsionFree(Point, this);\n            throw new Error('isTorsionFree() has not been declared for the elliptic curve');\n        }\n        clearCofactor() {\n            const { h: cofactor, clearCofactor } = CURVE;\n            if (cofactor === _1n)\n                return this; // Fast-path\n            if (clearCofactor)\n                return clearCofactor(Point, this);\n            return this.multiplyUnsafe(CURVE.h);\n        }\n        toRawBytes(isCompressed = true) {\n            this.assertValidity();\n            return toBytes(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(this.toRawBytes(isCompressed));\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n    const _bits = CURVE.nBitLength;\n    const wnaf = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n    // Validate if generator point is on curve\n    return {\n        CURVE,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar,\n        weierstrassEquation,\n        isWithinCurveOrder,\n    };\n}\nfunction validateOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject(opts, {\n        hash: 'hash',\n        hmac: 'function',\n        randomBytes: 'function',\n    }, {\n        bits2int: 'function',\n        bits2int_modN: 'function',\n        lowS: 'boolean',\n    });\n    return Object.freeze({ lowS: true, ...opts });\n}\nfunction weierstrass(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER } = CURVE;\n    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n    function isValidFieldElement(num) {\n        return _0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE\n    }\n    function modN(a) {\n        return _modular_js__WEBPACK_IMPORTED_MODULE_2__.mod(a, CURVE_ORDER);\n    }\n    function invN(a) {\n        return _modular_js__WEBPACK_IMPORTED_MODULE_2__.invert(a, CURVE_ORDER);\n    }\n    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder, } = weierstrassPoints({\n        ...CURVE,\n        toBytes(_c, point, isCompressed) {\n            const a = point.toAffine();\n            const x = Fp.toBytes(a.x);\n            const cat = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes;\n            if (isCompressed) {\n                return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);\n            }\n            else {\n                return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));\n            }\n        },\n        fromBytes(bytes) {\n            const len = bytes.length;\n            const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // this.assertValidity() is done inside of fromHex\n            if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n                const x = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(tail);\n                if (!isValidFieldElement(x))\n                    throw new Error('Point is not on curve');\n                const y2 = weierstrassEquation(x); // y¬≤ = x¬≥ + ax + b\n                let y = Fp.sqrt(y2); // y = y¬≤ ^ (p+1)/4\n                const isYOdd = (y & _1n) === _1n;\n                // ECDSA\n                const isHeadOdd = (head & 1) === 1;\n                if (isHeadOdd !== isYOdd)\n                    y = Fp.neg(y);\n                return { x, y };\n            }\n            else if (len === uncompressedLen && head === 0x04) {\n                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n                return { x, y };\n            }\n            else {\n                throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);\n            }\n        },\n    });\n    const numToNByteStr = (num) => _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(_utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE(num, CURVE.nByteLength));\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function normalizeS(s) {\n        return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n    }\n    // slice bytes num\n    const slcNum = (b, from, to) => _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(b.slice(from, to));\n    /**\n     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n     */\n    class Signature {\n        constructor(r, s, recovery) {\n            this.r = r;\n            this.s = s;\n            this.recovery = recovery;\n            this.assertValidity();\n        }\n        // pair (bytes of r, bytes of s)\n        static fromCompact(hex) {\n            const l = CURVE.nByteLength;\n            hex = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('compactSignature', hex, l * 2);\n            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n        }\n        // DER encoded ECDSA signature\n        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n        static fromDER(hex) {\n            const { r, s } = DER.toSig((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('DER', hex));\n            return new Signature(r, s);\n        }\n        assertValidity() {\n            // can use assertGE here\n            if (!isWithinCurveOrder(this.r))\n                throw new Error('r must be 0 < r < CURVE.n');\n            if (!isWithinCurveOrder(this.s))\n                throw new Error('s must be 0 < s < CURVE.n');\n        }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(msgHash) {\n            const { r, s, recovery: rec } = this;\n            const h = bits2int_modN((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('msgHash', msgHash)); // Truncate hash\n            if (rec == null || ![0, 1, 2, 3].includes(rec))\n                throw new Error('recovery id invalid');\n            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n            if (radj >= Fp.ORDER)\n                throw new Error('recovery id 2 or 3 invalid');\n            const prefix = (rec & 1) === 0 ? '02' : '03';\n            const R = Point.fromHex(prefix + numToNByteStr(radj));\n            const ir = invN(radj); // r^-1\n            const u1 = modN(-h * ir); // -hr^-1\n            const u2 = modN(s * ir); // sr^-1\n            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n            if (!Q)\n                throw new Error('point at infinify'); // unsafe is fine: no priv data leaked\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n        }\n        // DER-encoded\n        toDERRawBytes() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.hexToBytes(this.toDERHex());\n        }\n        toDERHex() {\n            return DER.hexFromSig({ r: this.r, s: this.s });\n        }\n        // padded bytes of r, then padded bytes of s\n        toCompactRawBytes() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.hexToBytes(this.toCompactHex());\n        }\n        toCompactHex() {\n            return numToNByteStr(this.r) + numToNByteStr(this.s);\n        }\n    }\n    const utils = {\n        isValidPrivateKey(privateKey) {\n            try {\n                normPrivateKeyToScalar(privateKey);\n                return true;\n            }\n            catch (error) {\n                return false;\n            }\n        },\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\n        /**\n         * Produces cryptographically secure private key from random of size\n         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n         */\n        randomPrivateKey: () => {\n            const length = _modular_js__WEBPACK_IMPORTED_MODULE_2__.getMinHashLength(CURVE.n);\n            return _modular_js__WEBPACK_IMPORTED_MODULE_2__.mapHashToField(CURVE.randomBytes(length), CURVE.n);\n        },\n        /**\n         * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n         * Allows to massively speed-up `point.multiply(scalar)`.\n         * @returns cached point\n         * @example\n         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n         * fast.multiply(privKey); // much faster ECDH now\n         */\n        precompute(windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n            return point;\n        },\n    };\n    /**\n     * Computes public key for a private key. Checks for validity of the private key.\n     * @param privateKey private key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */\n    function getPublicKey(privateKey, isCompressed = true) {\n        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */\n    function isProbPub(item) {\n        const arr = item instanceof Uint8Array;\n        const str = typeof item === 'string';\n        const len = (arr || str) && item.length;\n        if (arr)\n            return len === compressedLen || len === uncompressedLen;\n        if (str)\n            return len === 2 * compressedLen || len === 2 * uncompressedLen;\n        if (item instanceof Point)\n            return true;\n        return false;\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from private key and public key.\n     * Checks: 1) private key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param privateA private key\n     * @param publicB different public key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */\n    function getSharedSecret(privateA, publicB, isCompressed = true) {\n        if (isProbPub(privateA))\n            throw new Error('first arg must be private key');\n        if (!isProbPub(publicB))\n            throw new Error('second arg must be public key');\n        const b = Point.fromHex(publicB); // check for being on-curve\n        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = CURVE.bits2int ||\n        function (bytes) {\n            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n            // for some cases, since bytes.length * 8 is not actual bitLength.\n            const num = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(bytes); // check for == u8 done here\n            const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n            return delta > 0 ? num >> BigInt(delta) : num;\n        };\n    const bits2int_modN = CURVE.bits2int_modN ||\n        function (bytes) {\n            return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n        };\n    // NOTE: pads output with zero as per spec\n    const ORDER_MASK = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bitMask(CURVE.nBitLength);\n    /**\n     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n     */\n    function int2octets(num) {\n        if (typeof num !== 'bigint')\n            throw new Error('bigint expected');\n        if (!(_0n <= num && num < ORDER_MASK))\n            throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);\n        // works with order, can have different size than numToField!\n        return _utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE(num, CURVE.nByteLength);\n    }\n    // Steps A, D of RFC6979 3.2\n    // Creates RFC6979 seed; converts msg/privKey to numbers.\n    // Used only in sign, not in verify.\n    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.\n    // Also it can be bigger for P224 + SHA256\n    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n        if (['recovered', 'canonical'].some((k) => k in opts))\n            throw new Error('sign() legacy options not supported');\n        const { hash, randomBytes } = CURVE;\n        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n        if (lowS == null)\n            lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('msgHash', msgHash);\n        if (prehash)\n            msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('prehashed msgHash', hash(msgHash));\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(msgHash);\n        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n        const seedArgs = [int2octets(d), int2octets(h1int)];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (ent != null) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n            seedArgs.push((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('extraEntropy', e)); // check for being bytes\n        }\n        const seed = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n            if (!isWithinCurveOrder(k))\n                return; // Important: all mod() calls here must be done over N\n            const ik = invN(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n            const r = modN(q.x); // r = q.x mod n\n            if (r === _0n)\n                return;\n            // Can use scalar blinding b^-1(bm + bdr) where b ‚àà [1,q‚àí1] according to\n            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n            const s = modN(ik * modN(m + r * d)); // Not using blinding here\n            if (s === _0n)\n                return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = normalizeS(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return { seed, k2sig };\n    }\n    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };\n    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };\n    /**\n     * Signs message hash with a private key.\n     * ```\n     * sign(m, d, k) where\n     *   (x, y) = G √ó k\n     *   r = x mod n\n     *   s = (m + dr)/k mod n\n     * ```\n     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n     * @param privKey private key\n     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n     * @returns signature with recovery param\n     */\n    function sign(msgHash, privKey, opts = defaultSigOpts) {\n        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n        const C = CURVE;\n        const drbg = _utils_js__WEBPACK_IMPORTED_MODULE_1__.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);\n        return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    }\n    // Enable precomputes. Slows down first publicKey computation by 20ms.\n    Point.BASE._setWindowSize(8);\n    // utils.precompute(8, ProjectivePoint.BASE)\n    /**\n     * Verifies a signature against message hash and public key.\n     * Rejects lowS signatures by default: to override,\n     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   U1 = hs^-1 mod n\n     *   U2 = rs^-1 mod n\n     *   R = U1‚ãÖG - U2‚ãÖP\n     *   mod(R.x, n) == r\n     * ```\n     */\n    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n        const sg = signature;\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('msgHash', msgHash);\n        publicKey = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('publicKey', publicKey);\n        if ('strict' in opts)\n            throw new Error('options.strict was renamed to lowS');\n        const { lowS, prehash } = opts;\n        let _sig = undefined;\n        let P;\n        try {\n            if (typeof sg === 'string' || sg instanceof Uint8Array) {\n                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n                // Since DER can also be 2*nByteLength bytes, we check for it first.\n                try {\n                    _sig = Signature.fromDER(sg);\n                }\n                catch (derError) {\n                    if (!(derError instanceof DER.Err))\n                        throw derError;\n                    _sig = Signature.fromCompact(sg);\n                }\n            }\n            else if (typeof sg === 'object' && typeof sg.r === 'bigint' && typeof sg.s === 'bigint') {\n                const { r, s } = sg;\n                _sig = new Signature(r, s);\n            }\n            else {\n                throw new Error('PARSE');\n            }\n            P = Point.fromHex(publicKey);\n        }\n        catch (error) {\n            if (error.message === 'PARSE')\n                throw new Error(`signature must be Signature instance, Uint8Array or hex string`);\n            return false;\n        }\n        if (lowS && _sig.hasHighS())\n            return false;\n        if (prehash)\n            msgHash = CURVE.hash(msgHash);\n        const { r, s } = _sig;\n        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n        const is = invN(s); // s^-1\n        const u1 = modN(h * is); // u1 = hs^-1 mod n\n        const u2 = modN(r * is); // u2 = rs^-1 mod n\n        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1‚ãÖG + u2‚ãÖP\n        if (!R)\n            return false;\n        const v = modN(R.x);\n        return v === r;\n    }\n    return {\n        CURVE,\n        getPublicKey,\n        getSharedSecret,\n        sign,\n        verify,\n        ProjectivePoint: Point,\n        Signature,\n        utils,\n    };\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nfunction SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for (let o = q - _1n; o % _2n === _0n; o /= _2n)\n        l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v) => {\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for (let i = c1; i > _1n; i--) {\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return { isValid: isQR, value: tv3 };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v) => {\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */\nfunction mapToCurveSimpleSWU(Fp, opts) {\n    _modular_js__WEBPACK_IMPORTED_MODULE_2__.validateField(Fp);\n    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))\n        throw new Error('mapToCurveSimpleSWU: invalid opts');\n    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n    if (!Fp.isOdd)\n        throw new Error('Fp.isOdd is not implemented!');\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u) => {\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        x = Fp.div(x, tv4); // 25.   x = x / tv4\n        return { x, y };\n    };\n}\n//# sourceMappingURL=weierstrass.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9zdHItZGV2LWtpdC9uZGsvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC93ZWllcnN0cmFzcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDb0M7QUFDSDtBQUNRO0FBQ1E7QUFDakQ7QUFDQSxpQkFBaUIsd0RBQWE7QUFDOUIsSUFBSSxxREFBaUI7QUFDckI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0EsUUFBUSx3Q0FBd0MsRUFBRSxzQ0FBRTtBQUM3QztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDBDQUEwQztBQUMzRCxLQUFLO0FBQ0w7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDLGdCQUFnQixzQkFBc0I7QUFDdEM7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxJQUFJO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQixJQUFJLEdBQUcsRUFBRSxFQUFFLElBQUksR0FBRyxFQUFFLEVBQUU7QUFDM0QsS0FBSztBQUNMO0FB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QUNBIiwic291cmNlcyI6WyIvaG9tZS9sZmcvR2l0L01hZHRyaXBzL25vZGVfbW9kdWxlcy9Abm9zdHItZGV2LWtpdC9uZGsvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC93ZWllcnN0cmFzcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBTaG9ydCBXZWllcnN0cmFzcyBjdXJ2ZS4gVGhlIGZvcm11bGEgaXM6IHnCsiA9IHjCsyArIGF4ICsgYlxuaW1wb3J0ICogYXMgbW9kIGZyb20gJy4vbW9kdWxhci5qcyc7XG5pbXBvcnQgKiBhcyB1dCBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7IGVuc3VyZUJ5dGVzIH0gZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgeyB3TkFGLCB2YWxpZGF0ZUJhc2ljIH0gZnJvbSAnLi9jdXJ2ZS5qcyc7XG5mdW5jdGlvbiB2YWxpZGF0ZVBvaW50T3B0cyhjdXJ2ZSkge1xuICAgIGNvbnN0IG9wdHMgPSB2YWxpZGF0ZUJhc2ljKGN1cnZlKTtcbiAgICB1dC52YWxpZGF0ZU9iamVjdChvcHRzLCB7XG4gICAgICAgIGE6ICdmaWVsZCcsXG4gICAgICAgIGI6ICdmaWVsZCcsXG4gICAgfSwge1xuICAgICAgICBhbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHM6ICdhcnJheScsXG4gICAgICAgIHdyYXBQcml2YXRlS2V5OiAnYm9vbGVhbicsXG4gICAgICAgIGlzVG9yc2lvbkZyZWU6ICdmdW5jdGlvbicsXG4gICAgICAgIGNsZWFyQ29mYWN0b3I6ICdmdW5jdGlvbicsXG4gICAgICAgIGFsbG93SW5maW5pdHlQb2ludDogJ2Jvb2xlYW4nLFxuICAgICAgICBmcm9tQnl0ZXM6ICdmdW5jdGlvbicsXG4gICAgICAgIHRvQnl0ZXM6ICdmdW5jdGlvbicsXG4gICAgfSk7XG4gICAgY29uc3QgeyBlbmRvLCBGcCwgYSB9ID0gb3B0cztcbiAgICBpZiAoZW5kbykge1xuICAgICAgICBpZiAoIUZwLmVxbChhLCBGcC5aRVJPKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbmRvbW9ycGhpc20gY2FuIG9ubHkgYmUgZGVmaW5lZCBmb3IgS29ibGl0eiBjdXJ2ZXMgdGhhdCBoYXZlIGE9MCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZW5kbyAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgICAgIHR5cGVvZiBlbmRvLmJldGEgIT09ICdiaWdpbnQnIHx8XG4gICAgICAgICAgICB0eXBlb2YgZW5kby5zcGxpdFNjYWxhciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBlbmRvbW9ycGhpc20gd2l0aCBiZXRhOiBiaWdpbnQgYW5kIHNwbGl0U2NhbGFyOiBmdW5jdGlvbicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHsgLi4ub3B0cyB9KTtcbn1cbi8vIEFTTi4xIERFUiBlbmNvZGluZyB1dGlsaXRpZXNcbmNvbnN0IHsgYnl0ZXNUb051bWJlckJFOiBiMm4sIGhleFRvQnl0ZXM6IGgyYiB9ID0gdXQ7XG5leHBvcnQgY29uc3QgREVSID0ge1xuICAgIC8vIGFzbi4xIERFUiBlbmNvZGluZyB1dGlsc1xuICAgIEVycjogY2xhc3MgREVSRXJyIGV4dGVuZHMgRXJyb3Ige1xuICAgICAgICBjb25zdHJ1Y3RvcihtID0gJycpIHtcbiAgICAgICAgICAgIHN1cGVyKG0pO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBfcGFyc2VJbnQoZGF0YSkge1xuICAgICAgICBjb25zdCB7IEVycjogRSB9ID0gREVSO1xuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPCAyIHx8IGRhdGFbMF0gIT09IDB4MDIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmUgaW50ZWdlciB0YWcnKTtcbiAgICAgICAgY29uc3QgbGVuID0gZGF0YVsxXTtcbiAgICAgICAgY29uc3QgcmVzID0gZGF0YS5zdWJhcnJheSgyLCBsZW4gKyAyKTtcbiAgICAgICAgaWYgKCFsZW4gfHwgcmVzLmxlbmd0aCAhPT0gbGVuKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlIGludGVnZXI6IHdyb25nIGxlbmd0aCcpO1xuICAgICAgICAvLyBodHRwczovL2NyeXB0by5zdGFja2V4Y2hhbmdlLmNvbS9hLzU3NzM0IExlZnRtb3N0IGJpdCBvZiBmaXJzdCBieXRlIGlzICduZWdhdGl2ZScgZmxhZyxcbiAgICAgICAgLy8gc2luY2Ugd2UgYWx3YXlzIHVzZSBwb3NpdGl2ZSBpbnRlZ2VycyBoZXJlLiBJdCBtdXN0IGFsd2F5cyBiZSBlbXB0eTpcbiAgICAgICAgLy8gLSBhZGQgemVybyBieXRlIGlmIGV4aXN0c1xuICAgICAgICAvLyAtIGlmIG5leHQgYnl0ZSBkb2Vzbid0IGhhdmUgYSBmbGFnLCBsZWFkaW5nIHplcm8gaXMgbm90IGFsbG93ZWQgKG1pbmltYWwgZW5jb2RpbmcpXG4gICAgICAgIGlmIChyZXNbMF0gJiAwYjEwMDAwMDAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlIGludGVnZXI6IG5lZ2F0aXZlJyk7XG4gICAgICAgIGlmIChyZXNbMF0gPT09IDB4MDAgJiYgIShyZXNbMV0gJiAwYjEwMDAwMDAwKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiB1bm5lY2Vzc2FyeSBsZWFkaW5nIHplcm8nKTtcbiAgICAgICAgcmV0dXJuIHsgZDogYjJuKHJlcyksIGw6IGRhdGEuc3ViYXJyYXkobGVuICsgMikgfTsgLy8gZCBpcyBkYXRhLCBsIGlzIGxlZnRcbiAgICB9LFxuICAgIHRvU2lnKGhleCkge1xuICAgICAgICAvLyBwYXJzZSBERVIgc2lnbmF0dXJlXG4gICAgICAgIGNvbnN0IHsgRXJyOiBFIH0gPSBERVI7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0eXBlb2YgaGV4ID09PSAnc3RyaW5nJyA/IGgyYihoZXgpIDogaGV4O1xuICAgICAgICBpZiAoIShkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VpOGEgZXhwZWN0ZWQnKTtcbiAgICAgICAgbGV0IGwgPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgaWYgKGwgPCAyIHx8IGRhdGFbMF0gIT0gMHgzMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSB0YWcnKTtcbiAgICAgICAgaWYgKGRhdGFbMV0gIT09IGwgLSAyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlOiBpbmNvcnJlY3QgbGVuZ3RoJyk7XG4gICAgICAgIGNvbnN0IHsgZDogciwgbDogc0J5dGVzIH0gPSBERVIuX3BhcnNlSW50KGRhdGEuc3ViYXJyYXkoMikpO1xuICAgICAgICBjb25zdCB7IGQ6IHMsIGw6IHJCeXRlc0xlZnQgfSA9IERFUi5fcGFyc2VJbnQoc0J5dGVzKTtcbiAgICAgICAgaWYgKHJCeXRlc0xlZnQubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlOiBsZWZ0IGJ5dGVzIGFmdGVyIHBhcnNpbmcnKTtcbiAgICAgICAgcmV0dXJuIHsgciwgcyB9O1xuICAgIH0sXG4gICAgaGV4RnJvbVNpZyhzaWcpIHtcbiAgICAgICAgLy8gQWRkIGxlYWRpbmcgemVybyBpZiBmaXJzdCBieXRlIGhhcyBuZWdhdGl2ZSBiaXQgZW5hYmxlZC4gTW9yZSBkZXRhaWxzIGluICdfcGFyc2VJbnQnXG4gICAgICAgIGNvbnN0IHNsaWNlID0gKHMpID0+IChOdW1iZXIucGFyc2VJbnQoc1swXSwgMTYpICYgMGIxMDAwID8gJzAwJyArIHMgOiBzKTtcbiAgICAgICAgY29uc3QgaCA9IChudW0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGhleCA9IG51bS50b1N0cmluZygxNik7XG4gICAgICAgICAgICByZXR1cm4gaGV4Lmxlbmd0aCAmIDEgPyBgMCR7aGV4fWAgOiBoZXg7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHMgPSBzbGljZShoKHNpZy5zKSk7XG4gICAgICAgIGNvbnN0IHIgPSBzbGljZShoKHNpZy5yKSk7XG4gICAgICAgIGNvbnN0IHNobCA9IHMubGVuZ3RoIC8gMjtcbiAgICAgICAgY29uc3QgcmhsID0gci5sZW5ndGggLyAyO1xuICAgICAgICBjb25zdCBzbCA9IGgoc2hsKTtcbiAgICAgICAgY29uc3QgcmwgPSBoKHJobCk7XG4gICAgICAgIHJldHVybiBgMzAke2gocmhsICsgc2hsICsgNCl9MDIke3JsfSR7cn0wMiR7c2x9JHtzfWA7XG4gICAgfSxcbn07XG4vLyBCZSBmcmllbmRseSB0byBiYWQgRUNNQVNjcmlwdCBwYXJzZXJzIGJ5IG5vdCB1c2luZyBiaWdpbnQgbGl0ZXJhbHNcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzBuID0gQmlnSW50KDApLCBfMW4gPSBCaWdJbnQoMSksIF8ybiA9IEJpZ0ludCgyKSwgXzNuID0gQmlnSW50KDMpLCBfNG4gPSBCaWdJbnQoNCk7XG5leHBvcnQgZnVuY3Rpb24gd2VpZXJzdHJhc3NQb2ludHMob3B0cykge1xuICAgIGNvbnN0IENVUlZFID0gdmFsaWRhdGVQb2ludE9wdHMob3B0cyk7XG4gICAgY29uc3QgeyBGcCB9ID0gQ1VSVkU7IC8vIEFsbCBjdXJ2ZXMgaGFzIHNhbWUgZmllbGQgLyBncm91cCBsZW5ndGggYXMgZm9yIG5vdywgYnV0IHRoZXkgY2FuIGRpZmZlclxuICAgIGNvbnN0IHRvQnl0ZXMgPSBDVVJWRS50b0J5dGVzIHx8XG4gICAgICAgICgoX2MsIHBvaW50LCBfaXNDb21wcmVzc2VkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhID0gcG9pbnQudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIHJldHVybiB1dC5jb25jYXRCeXRlcyhVaW50OEFycmF5LmZyb20oWzB4MDRdKSwgRnAudG9CeXRlcyhhLngpLCBGcC50b0J5dGVzKGEueSkpO1xuICAgICAgICB9KTtcbiAgICBjb25zdCBmcm9tQnl0ZXMgPSBDVVJWRS5mcm9tQnl0ZXMgfHxcbiAgICAgICAgKChieXRlcykgPT4ge1xuICAgICAgICAgICAgLy8gY29uc3QgaGVhZCA9IGJ5dGVzWzBdO1xuICAgICAgICAgICAgY29uc3QgdGFpbCA9IGJ5dGVzLnN1YmFycmF5KDEpO1xuICAgICAgICAgICAgLy8gaWYgKGhlYWQgIT09IDB4MDQpIHRocm93IG5ldyBFcnJvcignT25seSBub24tY29tcHJlc3NlZCBlbmNvZGluZyBpcyBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgIGNvbnN0IHggPSBGcC5mcm9tQnl0ZXModGFpbC5zdWJhcnJheSgwLCBGcC5CWVRFUykpO1xuICAgICAgICAgICAgY29uc3QgeSA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KEZwLkJZVEVTLCAyICogRnAuQllURVMpKTtcbiAgICAgICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICAgICAgfSk7XG4gICAgLyoqXG4gICAgICogecKyID0geMKzICsgYXggKyBiOiBTaG9ydCB3ZWllcnN0cmFzcyBjdXJ2ZSBmb3JtdWxhXG4gICAgICogQHJldHVybnMgecKyXG4gICAgICovXG4gICAgZnVuY3Rpb24gd2VpZXJzdHJhc3NFcXVhdGlvbih4KSB7XG4gICAgICAgIGNvbnN0IHsgYSwgYiB9ID0gQ1VSVkU7XG4gICAgICAgIGNvbnN0IHgyID0gRnAuc3FyKHgpOyAvLyB4ICogeFxuICAgICAgICBjb25zdCB4MyA9IEZwLm11bCh4MiwgeCk7IC8vIHgyICogeFxuICAgICAgICByZXR1cm4gRnAuYWRkKEZwLmFkZCh4MywgRnAubXVsKHgsIGEpKSwgYik7IC8vIHgzICsgYSAqIHggKyBiXG4gICAgfVxuICAgIC8vIFZhbGlkYXRlIHdoZXRoZXIgdGhlIHBhc3NlZCBjdXJ2ZSBwYXJhbXMgYXJlIHZhbGlkLlxuICAgIC8vIFdlIGNoZWNrIGlmIGN1cnZlIGVxdWF0aW9uIHdvcmtzIGZvciBnZW5lcmF0b3IgcG9pbnQuXG4gICAgLy8gYGFzc2VydFZhbGlkaXR5KClgIHdvbid0IHdvcms6IGBpc1RvcnNpb25GcmVlKClgIGlzIG5vdCBhdmFpbGFibGUgYXQgdGhpcyBwb2ludCBpbiBibHMxMi0zODEuXG4gICAgLy8gUHJvamVjdGl2ZVBvaW50IGNsYXNzIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXQuXG4gICAgaWYgKCFGcC5lcWwoRnAuc3FyKENVUlZFLkd5KSwgd2VpZXJzdHJhc3NFcXVhdGlvbihDVVJWRS5HeCkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBnZW5lcmF0b3IgcG9pbnQ6IGVxdWF0aW9uIGxlZnQgIT0gcmlnaHQnKTtcbiAgICAvLyBWYWxpZCBncm91cCBlbGVtZW50cyByZXNpZGUgaW4gcmFuZ2UgMS4ubi0xXG4gICAgZnVuY3Rpb24gaXNXaXRoaW5DdXJ2ZU9yZGVyKG51bSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIG51bSA9PT0gJ2JpZ2ludCcgJiYgXzBuIDwgbnVtICYmIG51bSA8IENVUlZFLm47XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFzc2VydEdFKG51bSkge1xuICAgICAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcihudW0pKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB2YWxpZCBiaWdpbnQ6IDAgPCBiaWdpbnQgPCBjdXJ2ZS5uJyk7XG4gICAgfVxuICAgIC8vIFZhbGlkYXRlcyBpZiBwcml2IGtleSBpcyB2YWxpZCBhbmQgY29udmVydHMgaXQgdG8gYmlnaW50LlxuICAgIC8vIFN1cHBvcnRzIG9wdGlvbnMgYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzIGFuZCB3cmFwUHJpdmF0ZUtleS5cbiAgICBmdW5jdGlvbiBub3JtUHJpdmF0ZUtleVRvU2NhbGFyKGtleSkge1xuICAgICAgICBjb25zdCB7IGFsbG93ZWRQcml2YXRlS2V5TGVuZ3RoczogbGVuZ3RocywgbkJ5dGVMZW5ndGgsIHdyYXBQcml2YXRlS2V5LCBuIH0gPSBDVVJWRTtcbiAgICAgICAgaWYgKGxlbmd0aHMgJiYgdHlwZW9mIGtleSAhPT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgIGlmIChrZXkgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxuICAgICAgICAgICAgICAgIGtleSA9IHV0LmJ5dGVzVG9IZXgoa2V5KTtcbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSB0byBoZXggc3RyaW5nLCBwYWQuIEUuZy4gUDUyMSB3b3VsZCBub3JtIDEzMC0xMzIgY2hhciBoZXggdG8gMTMyLWNoYXIgYnl0ZXNcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJyB8fCAhbGVuZ3Rocy5pbmNsdWRlcyhrZXkubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQga2V5Jyk7XG4gICAgICAgICAgICBrZXkgPSBrZXkucGFkU3RhcnQobkJ5dGVMZW5ndGggKiAyLCAnMCcpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBudW07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBudW0gPVxuICAgICAgICAgICAgICAgIHR5cGVvZiBrZXkgPT09ICdiaWdpbnQnXG4gICAgICAgICAgICAgICAgICAgID8ga2V5XG4gICAgICAgICAgICAgICAgICAgIDogdXQuYnl0ZXNUb051bWJlckJFKGVuc3VyZUJ5dGVzKCdwcml2YXRlIGtleScsIGtleSwgbkJ5dGVMZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcHJpdmF0ZSBrZXkgbXVzdCBiZSAke25CeXRlTGVuZ3RofSBieXRlcywgaGV4IG9yIGJpZ2ludCwgbm90ICR7dHlwZW9mIGtleX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod3JhcFByaXZhdGVLZXkpXG4gICAgICAgICAgICBudW0gPSBtb2QubW9kKG51bSwgbik7IC8vIGRpc2FibGVkIGJ5IGRlZmF1bHQsIGVuYWJsZWQgZm9yIEJMU1xuICAgICAgICBhc3NlcnRHRShudW0pOyAvLyBudW0gaW4gcmFuZ2UgWzEuLk4tMV1cbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICB9XG4gICAgY29uc3QgcG9pbnRQcmVjb21wdXRlcyA9IG5ldyBNYXAoKTtcbiAgICBmdW5jdGlvbiBhc3NlcnRQcmpQb2ludChvdGhlcikge1xuICAgICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFBvaW50KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvamVjdGl2ZVBvaW50IGV4cGVjdGVkJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2plY3RpdmUgUG9pbnQgd29ya3MgaW4gM2QgLyBwcm9qZWN0aXZlIChob21vZ2VuZW91cykgY29vcmRpbmF0ZXM6ICh4LCB5LCB6KSDiiIsgKHg9eC96LCB5PXkveilcbiAgICAgKiBEZWZhdWx0IFBvaW50IHdvcmtzIGluIDJkIC8gYWZmaW5lIGNvb3JkaW5hdGVzOiAoeCwgeSlcbiAgICAgKiBXZSdyZSBkb2luZyBjYWxjdWxhdGlvbnMgaW4gcHJvamVjdGl2ZSwgYmVjYXVzZSBpdHMgb3BlcmF0aW9ucyBkb24ndCByZXF1aXJlIGNvc3RseSBpbnZlcnNpb24uXG4gICAgICovXG4gICAgY2xhc3MgUG9pbnQge1xuICAgICAgICBjb25zdHJ1Y3RvcihweCwgcHksIHB6KSB7XG4gICAgICAgICAgICB0aGlzLnB4ID0gcHg7XG4gICAgICAgICAgICB0aGlzLnB5ID0gcHk7XG4gICAgICAgICAgICB0aGlzLnB6ID0gcHo7XG4gICAgICAgICAgICBpZiAocHggPT0gbnVsbCB8fCAhRnAuaXNWYWxpZChweCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd4IHJlcXVpcmVkJyk7XG4gICAgICAgICAgICBpZiAocHkgPT0gbnVsbCB8fCAhRnAuaXNWYWxpZChweSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd5IHJlcXVpcmVkJyk7XG4gICAgICAgICAgICBpZiAocHogPT0gbnVsbCB8fCAhRnAuaXNWYWxpZChweikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd6IHJlcXVpcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG9lcyBub3QgdmFsaWRhdGUgaWYgdGhlIHBvaW50IGlzIG9uLWN1cnZlLlxuICAgICAgICAvLyBVc2UgZnJvbUhleCBpbnN0ZWFkLCBvciBjYWxsIGFzc2VydFZhbGlkaXR5KCkgbGF0ZXIuXG4gICAgICAgIHN0YXRpYyBmcm9tQWZmaW5lKHApIHtcbiAgICAgICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gcCB8fCB7fTtcbiAgICAgICAgICAgIGlmICghcCB8fCAhRnAuaXNWYWxpZCh4KSB8fCAhRnAuaXNWYWxpZCh5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYWZmaW5lIHBvaW50Jyk7XG4gICAgICAgICAgICBpZiAocCBpbnN0YW5jZW9mIFBvaW50KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncHJvamVjdGl2ZSBwb2ludCBub3QgYWxsb3dlZCcpO1xuICAgICAgICAgICAgY29uc3QgaXMwID0gKGkpID0+IEZwLmVxbChpLCBGcC5aRVJPKTtcbiAgICAgICAgICAgIC8vIGZyb21BZmZpbmUoeDowLCB5OjApIHdvdWxkIHByb2R1Y2UgKHg6MCwgeTowLCB6OjEpLCBidXQgd2UgbmVlZCAoeDowLCB5OjEsIHo6MClcbiAgICAgICAgICAgIGlmIChpczAoeCkgJiYgaXMwKHkpKVxuICAgICAgICAgICAgICAgIHJldHVybiBQb2ludC5aRVJPO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh4LCB5LCBGcC5PTkUpO1xuICAgICAgICB9XG4gICAgICAgIGdldCB4KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9BZmZpbmUoKS54O1xuICAgICAgICB9XG4gICAgICAgIGdldCB5KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9BZmZpbmUoKS55O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUYWtlcyBhIGJ1bmNoIG9mIFByb2plY3RpdmUgUG9pbnRzIGJ1dCBleGVjdXRlcyBvbmx5IG9uZVxuICAgICAgICAgKiBpbnZlcnNpb24gb24gYWxsIG9mIHRoZW0uIEludmVyc2lvbiBpcyB2ZXJ5IHNsb3cgb3BlcmF0aW9uLFxuICAgICAgICAgKiBzbyB0aGlzIGltcHJvdmVzIHBlcmZvcm1hbmNlIG1hc3NpdmVseS5cbiAgICAgICAgICogT3B0aW1pemF0aW9uOiBjb252ZXJ0cyBhIGxpc3Qgb2YgcHJvamVjdGl2ZSBwb2ludHMgdG8gYSBsaXN0IG9mIGlkZW50aWNhbCBwb2ludHMgd2l0aCBaPTEuXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgbm9ybWFsaXplWihwb2ludHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvSW52ID0gRnAuaW52ZXJ0QmF0Y2gocG9pbnRzLm1hcCgocCkgPT4gcC5weikpO1xuICAgICAgICAgICAgcmV0dXJuIHBvaW50cy5tYXAoKHAsIGkpID0+IHAudG9BZmZpbmUodG9JbnZbaV0pKS5tYXAoUG9pbnQuZnJvbUFmZmluZSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIGhhc2ggc3RyaW5nIG9yIFVpbnQ4QXJyYXkgdG8gUG9pbnQuXG4gICAgICAgICAqIEBwYXJhbSBoZXggc2hvcnQvbG9uZyBFQ0RTQSBoZXhcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBmcm9tSGV4KGhleCkge1xuICAgICAgICAgICAgY29uc3QgUCA9IFBvaW50LmZyb21BZmZpbmUoZnJvbUJ5dGVzKGVuc3VyZUJ5dGVzKCdwb2ludEhleCcsIGhleCkpKTtcbiAgICAgICAgICAgIFAuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiBQO1xuICAgICAgICB9XG4gICAgICAgIC8vIE11bHRpcGxpZXMgZ2VuZXJhdG9yIHBvaW50IGJ5IHByaXZhdGVLZXkuXG4gICAgICAgIHN0YXRpYyBmcm9tUHJpdmF0ZUtleShwcml2YXRlS2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gUG9pbnQuQkFTRS5tdWx0aXBseShub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVLZXkpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBcIlByaXZhdGUgbWV0aG9kXCIsIGRvbid0IHVzZSBpdCBkaXJlY3RseVxuICAgICAgICBfc2V0V2luZG93U2l6ZSh3aW5kb3dTaXplKSB7XG4gICAgICAgICAgICB0aGlzLl9XSU5ET1dfU0laRSA9IHdpbmRvd1NpemU7XG4gICAgICAgICAgICBwb2ludFByZWNvbXB1dGVzLmRlbGV0ZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBIHBvaW50IG9uIGN1cnZlIGlzIHZhbGlkIGlmIGl0IGNvbmZvcm1zIHRvIGVxdWF0aW9uLlxuICAgICAgICBhc3NlcnRWYWxpZGl0eSgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzMCgpKSB7XG4gICAgICAgICAgICAgICAgLy8gKDAsIDEsIDApIGFrYSBaRVJPIGlzIGludmFsaWQgaW4gbW9zdCBjb250ZXh0cy5cbiAgICAgICAgICAgICAgICAvLyBJbiBCTFMsIFpFUk8gY2FuIGJlIHNlcmlhbGl6ZWQsIHNvIHdlIGFsbG93IGl0LlxuICAgICAgICAgICAgICAgIC8vICgwLCAwLCAwKSBpcyB3cm9uZyByZXByZXNlbnRhdGlvbiBvZiBaRVJPIGFuZCBpcyBhbHdheXMgaW52YWxpZC5cbiAgICAgICAgICAgICAgICBpZiAoQ1VSVkUuYWxsb3dJbmZpbml0eVBvaW50ICYmICFGcC5pczAodGhpcy5weSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogWkVSTycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU29tZSAzcmQtcGFydHkgdGVzdCB2ZWN0b3JzIHJlcXVpcmUgZGlmZmVyZW50IHdvcmRpbmcgYmV0d2VlbiBoZXJlICYgYGZyb21Db21wcmVzc2VkSGV4YFxuICAgICAgICAgICAgY29uc3QgeyB4LCB5IH0gPSB0aGlzLnRvQWZmaW5lKCk7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB4LCB5IGFyZSB2YWxpZCBmaWVsZCBlbGVtZW50c1xuICAgICAgICAgICAgaWYgKCFGcC5pc1ZhbGlkKHgpIHx8ICFGcC5pc1ZhbGlkKHkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiB4IG9yIHkgbm90IEZFJyk7XG4gICAgICAgICAgICBjb25zdCBsZWZ0ID0gRnAuc3FyKHkpOyAvLyB5wrJcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gd2VpZXJzdHJhc3NFcXVhdGlvbih4KTsgLy8geMKzICsgYXggKyBiXG4gICAgICAgICAgICBpZiAoIUZwLmVxbChsZWZ0LCByaWdodCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IGVxdWF0aW9uIGxlZnQgIT0gcmlnaHQnKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc1RvcnNpb25GcmVlKCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IG5vdCBpbiBwcmltZS1vcmRlciBzdWJncm91cCcpO1xuICAgICAgICB9XG4gICAgICAgIGhhc0V2ZW5ZKCkge1xuICAgICAgICAgICAgY29uc3QgeyB5IH0gPSB0aGlzLnRvQWZmaW5lKCk7XG4gICAgICAgICAgICBpZiAoRnAuaXNPZGQpXG4gICAgICAgICAgICAgICAgcmV0dXJuICFGcC5pc09kZCh5KTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZpZWxkIGRvZXNuJ3Qgc3VwcG9ydCBpc09kZFwiKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ29tcGFyZSBvbmUgcG9pbnQgdG8gYW5vdGhlci5cbiAgICAgICAgICovXG4gICAgICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICAgICAgYXNzZXJ0UHJqUG9pbnQob3RoZXIpO1xuICAgICAgICAgICAgY29uc3QgeyBweDogWDEsIHB5OiBZMSwgcHo6IFoxIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgeyBweDogWDIsIHB5OiBZMiwgcHo6IFoyIH0gPSBvdGhlcjtcbiAgICAgICAgICAgIGNvbnN0IFUxID0gRnAuZXFsKEZwLm11bChYMSwgWjIpLCBGcC5tdWwoWDIsIFoxKSk7XG4gICAgICAgICAgICBjb25zdCBVMiA9IEZwLmVxbChGcC5tdWwoWTEsIFoyKSwgRnAubXVsKFkyLCBaMSkpO1xuICAgICAgICAgICAgcmV0dXJuIFUxICYmIFUyO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGbGlwcyBwb2ludCB0byBvbmUgY29ycmVzcG9uZGluZyB0byAoeCwgLXkpIGluIEFmZmluZSBjb29yZGluYXRlcy5cbiAgICAgICAgICovXG4gICAgICAgIG5lZ2F0ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy5weCwgRnAubmVnKHRoaXMucHkpLCB0aGlzLnB6KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW5lcy1Db3N0ZWxsby1CYXRpbmEgZXhjZXB0aW9uLWZyZWUgZG91YmxpbmcgZm9ybXVsYS5cbiAgICAgICAgLy8gVGhlcmUgaXMgMzAlIGZhc3RlciBKYWNvYmlhbiBmb3JtdWxhLCBidXQgaXQgaXMgbm90IGNvbXBsZXRlLlxuICAgICAgICAvLyBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDE1LzEwNjAsIGFsZ29yaXRobSAzXG4gICAgICAgIC8vIENvc3Q6IDhNICsgM1MgKyAzKmEgKyAyKmIzICsgMTVhZGQuXG4gICAgICAgIGRvdWJsZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgYSwgYiB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBjb25zdCBiMyA9IEZwLm11bChiLCBfM24pO1xuICAgICAgICAgICAgY29uc3QgeyBweDogWDEsIHB5OiBZMSwgcHo6IFoxIH0gPSB0aGlzO1xuICAgICAgICAgICAgbGV0IFgzID0gRnAuWkVSTywgWTMgPSBGcC5aRVJPLCBaMyA9IEZwLlpFUk87IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgbGV0IHQwID0gRnAubXVsKFgxLCBYMSk7IC8vIHN0ZXAgMVxuICAgICAgICAgICAgbGV0IHQxID0gRnAubXVsKFkxLCBZMSk7XG4gICAgICAgICAgICBsZXQgdDIgPSBGcC5tdWwoWjEsIFoxKTtcbiAgICAgICAgICAgIGxldCB0MyA9IEZwLm11bChYMSwgWTEpO1xuICAgICAgICAgICAgdDMgPSBGcC5hZGQodDMsIHQzKTsgLy8gc3RlcCA1XG4gICAgICAgICAgICBaMyA9IEZwLm11bChYMSwgWjEpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWjMsIFozKTtcbiAgICAgICAgICAgIFgzID0gRnAubXVsKGEsIFozKTtcbiAgICAgICAgICAgIFkzID0gRnAubXVsKGIzLCB0Mik7XG4gICAgICAgICAgICBZMyA9IEZwLmFkZChYMywgWTMpOyAvLyBzdGVwIDEwXG4gICAgICAgICAgICBYMyA9IEZwLnN1Yih0MSwgWTMpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQodDEsIFkzKTtcbiAgICAgICAgICAgIFkzID0gRnAubXVsKFgzLCBZMyk7XG4gICAgICAgICAgICBYMyA9IEZwLm11bCh0MywgWDMpO1xuICAgICAgICAgICAgWjMgPSBGcC5tdWwoYjMsIFozKTsgLy8gc3RlcCAxNVxuICAgICAgICAgICAgdDIgPSBGcC5tdWwoYSwgdDIpO1xuICAgICAgICAgICAgdDMgPSBGcC5zdWIodDAsIHQyKTtcbiAgICAgICAgICAgIHQzID0gRnAubXVsKGEsIHQzKTtcbiAgICAgICAgICAgIHQzID0gRnAuYWRkKHQzLCBaMyk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZCh0MCwgdDApOyAvLyBzdGVwIDIwXG4gICAgICAgICAgICB0MCA9IEZwLmFkZChaMywgdDApO1xuICAgICAgICAgICAgdDAgPSBGcC5hZGQodDAsIHQyKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQwLCB0Myk7XG4gICAgICAgICAgICBZMyA9IEZwLmFkZChZMywgdDApO1xuICAgICAgICAgICAgdDIgPSBGcC5tdWwoWTEsIFoxKTsgLy8gc3RlcCAyNVxuICAgICAgICAgICAgdDIgPSBGcC5hZGQodDIsIHQyKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQyLCB0Myk7XG4gICAgICAgICAgICBYMyA9IEZwLnN1YihYMywgdDApO1xuICAgICAgICAgICAgWjMgPSBGcC5tdWwodDIsIHQxKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCBaMyk7IC8vIHN0ZXAgMzBcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCBaMyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KFgzLCBZMywgWjMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbmVzLUNvc3RlbGxvLUJhdGluYSBleGNlcHRpb24tZnJlZSBhZGRpdGlvbiBmb3JtdWxhLlxuICAgICAgICAvLyBUaGVyZSBpcyAzMCUgZmFzdGVyIEphY29iaWFuIGZvcm11bGEsIGJ1dCBpdCBpcyBub3QgY29tcGxldGUuXG4gICAgICAgIC8vIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTUvMTA2MCwgYWxnb3JpdGhtIDFcbiAgICAgICAgLy8gQ29zdDogMTJNICsgMFMgKyAzKmEgKyAzKmIzICsgMjNhZGQuXG4gICAgICAgIGFkZChvdGhlcikge1xuICAgICAgICAgICAgYXNzZXJ0UHJqUG9pbnQob3RoZXIpO1xuICAgICAgICAgICAgY29uc3QgeyBweDogWDEsIHB5OiBZMSwgcHo6IFoxIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgeyBweDogWDIsIHB5OiBZMiwgcHo6IFoyIH0gPSBvdGhlcjtcbiAgICAgICAgICAgIGxldCBYMyA9IEZwLlpFUk8sIFkzID0gRnAuWkVSTywgWjMgPSBGcC5aRVJPOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IGEgPSBDVVJWRS5hO1xuICAgICAgICAgICAgY29uc3QgYjMgPSBGcC5tdWwoQ1VSVkUuYiwgXzNuKTtcbiAgICAgICAgICAgIGxldCB0MCA9IEZwLm11bChYMSwgWDIpOyAvLyBzdGVwIDFcbiAgICAgICAgICAgIGxldCB0MSA9IEZwLm11bChZMSwgWTIpO1xuICAgICAgICAgICAgbGV0IHQyID0gRnAubXVsKFoxLCBaMik7XG4gICAgICAgICAgICBsZXQgdDMgPSBGcC5hZGQoWDEsIFkxKTtcbiAgICAgICAgICAgIGxldCB0NCA9IEZwLmFkZChYMiwgWTIpOyAvLyBzdGVwIDVcbiAgICAgICAgICAgIHQzID0gRnAubXVsKHQzLCB0NCk7XG4gICAgICAgICAgICB0NCA9IEZwLmFkZCh0MCwgdDEpO1xuICAgICAgICAgICAgdDMgPSBGcC5zdWIodDMsIHQ0KTtcbiAgICAgICAgICAgIHQ0ID0gRnAuYWRkKFgxLCBaMSk7XG4gICAgICAgICAgICBsZXQgdDUgPSBGcC5hZGQoWDIsIFoyKTsgLy8gc3RlcCAxMFxuICAgICAgICAgICAgdDQgPSBGcC5tdWwodDQsIHQ1KTtcbiAgICAgICAgICAgIHQ1ID0gRnAuYWRkKHQwLCB0Mik7XG4gICAgICAgICAgICB0NCA9IEZwLnN1Yih0NCwgdDUpO1xuICAgICAgICAgICAgdDUgPSBGcC5hZGQoWTEsIFoxKTtcbiAgICAgICAgICAgIFgzID0gRnAuYWRkKFkyLCBaMik7IC8vIHN0ZXAgMTVcbiAgICAgICAgICAgIHQ1ID0gRnAubXVsKHQ1LCBYMyk7XG4gICAgICAgICAgICBYMyA9IEZwLmFkZCh0MSwgdDIpO1xuICAgICAgICAgICAgdDUgPSBGcC5zdWIodDUsIFgzKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKGEsIHQ0KTtcbiAgICAgICAgICAgIFgzID0gRnAubXVsKGIzLCB0Mik7IC8vIHN0ZXAgMjBcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFgzLCBaMyk7XG4gICAgICAgICAgICBYMyA9IEZwLnN1Yih0MSwgWjMpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQodDEsIFozKTtcbiAgICAgICAgICAgIFkzID0gRnAubXVsKFgzLCBaMyk7XG4gICAgICAgICAgICB0MSA9IEZwLmFkZCh0MCwgdDApOyAvLyBzdGVwIDI1XG4gICAgICAgICAgICB0MSA9IEZwLmFkZCh0MSwgdDApO1xuICAgICAgICAgICAgdDIgPSBGcC5tdWwoYSwgdDIpO1xuICAgICAgICAgICAgdDQgPSBGcC5tdWwoYjMsIHQ0KTtcbiAgICAgICAgICAgIHQxID0gRnAuYWRkKHQxLCB0Mik7XG4gICAgICAgICAgICB0MiA9IEZwLnN1Yih0MCwgdDIpOyAvLyBzdGVwIDMwXG4gICAgICAgICAgICB0MiA9IEZwLm11bChhLCB0Mik7XG4gICAgICAgICAgICB0NCA9IEZwLmFkZCh0NCwgdDIpO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDEsIHQ0KTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKFkzLCB0MCk7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0NSwgdDQpOyAvLyBzdGVwIDM1XG4gICAgICAgICAgICBYMyA9IEZwLm11bCh0MywgWDMpO1xuICAgICAgICAgICAgWDMgPSBGcC5zdWIoWDMsIHQwKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQzLCB0MSk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bCh0NSwgWjMpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWjMsIHQwKTsgLy8gc3RlcCA0MFxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChYMywgWTMsIFozKTtcbiAgICAgICAgfVxuICAgICAgICBzdWJ0cmFjdChvdGhlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKG90aGVyLm5lZ2F0ZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBpczAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lcXVhbHMoUG9pbnQuWkVSTyk7XG4gICAgICAgIH1cbiAgICAgICAgd05BRihuKSB7XG4gICAgICAgICAgICByZXR1cm4gd25hZi53TkFGQ2FjaGVkKHRoaXMsIHBvaW50UHJlY29tcHV0ZXMsIG4sIChjb21wKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9JbnYgPSBGcC5pbnZlcnRCYXRjaChjb21wLm1hcCgocCkgPT4gcC5weikpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21wLm1hcCgocCwgaSkgPT4gcC50b0FmZmluZSh0b0ludltpXSkpLm1hcChQb2ludC5mcm9tQWZmaW5lKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOb24tY29uc3RhbnQtdGltZSBtdWx0aXBsaWNhdGlvbi4gVXNlcyBkb3VibGUtYW5kLWFkZCBhbGdvcml0aG0uXG4gICAgICAgICAqIEl0J3MgZmFzdGVyLCBidXQgc2hvdWxkIG9ubHkgYmUgdXNlZCB3aGVuIHlvdSBkb24ndCBjYXJlIGFib3V0XG4gICAgICAgICAqIGFuIGV4cG9zZWQgcHJpdmF0ZSBrZXkgZS5nLiBzaWcgdmVyaWZpY2F0aW9uLCB3aGljaCB3b3JrcyBvdmVyICpwdWJsaWMqIGtleXMuXG4gICAgICAgICAqL1xuICAgICAgICBtdWx0aXBseVVuc2FmZShuKSB7XG4gICAgICAgICAgICBjb25zdCBJID0gUG9pbnQuWkVSTztcbiAgICAgICAgICAgIGlmIChuID09PSBfMG4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIEk7XG4gICAgICAgICAgICBhc3NlcnRHRShuKTsgLy8gV2lsbCB0aHJvdyBvbiAwXG4gICAgICAgICAgICBpZiAobiA9PT0gXzFuKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgY29uc3QgeyBlbmRvIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGlmICghZW5kbylcbiAgICAgICAgICAgICAgICByZXR1cm4gd25hZi51bnNhZmVMYWRkZXIodGhpcywgbik7XG4gICAgICAgICAgICAvLyBBcHBseSBlbmRvbW9ycGhpc21cbiAgICAgICAgICAgIGxldCB7IGsxbmVnLCBrMSwgazJuZWcsIGsyIH0gPSBlbmRvLnNwbGl0U2NhbGFyKG4pO1xuICAgICAgICAgICAgbGV0IGsxcCA9IEk7XG4gICAgICAgICAgICBsZXQgazJwID0gSTtcbiAgICAgICAgICAgIGxldCBkID0gdGhpcztcbiAgICAgICAgICAgIHdoaWxlIChrMSA+IF8wbiB8fCBrMiA+IF8wbikge1xuICAgICAgICAgICAgICAgIGlmIChrMSAmIF8xbilcbiAgICAgICAgICAgICAgICAgICAgazFwID0gazFwLmFkZChkKTtcbiAgICAgICAgICAgICAgICBpZiAoazIgJiBfMW4pXG4gICAgICAgICAgICAgICAgICAgIGsycCA9IGsycC5hZGQoZCk7XG4gICAgICAgICAgICAgICAgZCA9IGQuZG91YmxlKCk7XG4gICAgICAgICAgICAgICAgazEgPj49IF8xbjtcbiAgICAgICAgICAgICAgICBrMiA+Pj0gXzFuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGsxbmVnKVxuICAgICAgICAgICAgICAgIGsxcCA9IGsxcC5uZWdhdGUoKTtcbiAgICAgICAgICAgIGlmIChrMm5lZylcbiAgICAgICAgICAgICAgICBrMnAgPSBrMnAubmVnYXRlKCk7XG4gICAgICAgICAgICBrMnAgPSBuZXcgUG9pbnQoRnAubXVsKGsycC5weCwgZW5kby5iZXRhKSwgazJwLnB5LCBrMnAucHopO1xuICAgICAgICAgICAgcmV0dXJuIGsxcC5hZGQoazJwKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RhbnQgdGltZSBtdWx0aXBsaWNhdGlvbi5cbiAgICAgICAgICogVXNlcyB3TkFGIG1ldGhvZC4gV2luZG93ZWQgbWV0aG9kIG1heSBiZSAxMCUgZmFzdGVyLFxuICAgICAgICAgKiBidXQgdGFrZXMgMnggbG9uZ2VyIHRvIGdlbmVyYXRlIGFuZCBjb25zdW1lcyAyeCBtZW1vcnkuXG4gICAgICAgICAqIFVzZXMgcHJlY29tcHV0ZXMgd2hlbiBhdmFpbGFibGUuXG4gICAgICAgICAqIFVzZXMgZW5kb21vcnBoaXNtIGZvciBLb2JsaXR6IGN1cnZlcy5cbiAgICAgICAgICogQHBhcmFtIHNjYWxhciBieSB3aGljaCB0aGUgcG9pbnQgd291bGQgYmUgbXVsdGlwbGllZFxuICAgICAgICAgKiBAcmV0dXJucyBOZXcgcG9pbnRcbiAgICAgICAgICovXG4gICAgICAgIG11bHRpcGx5KHNjYWxhcikge1xuICAgICAgICAgICAgYXNzZXJ0R0Uoc2NhbGFyKTtcbiAgICAgICAgICAgIGxldCBuID0gc2NhbGFyO1xuICAgICAgICAgICAgbGV0IHBvaW50LCBmYWtlOyAvLyBGYWtlIHBvaW50IGlzIHVzZWQgdG8gY29uc3QtdGltZSBtdWx0XG4gICAgICAgICAgICBjb25zdCB7IGVuZG8gfSA9IENVUlZFO1xuICAgICAgICAgICAgaWYgKGVuZG8pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGsxbmVnLCBrMSwgazJuZWcsIGsyIH0gPSBlbmRvLnNwbGl0U2NhbGFyKG4pO1xuICAgICAgICAgICAgICAgIGxldCB7IHA6IGsxcCwgZjogZjFwIH0gPSB0aGlzLndOQUYoazEpO1xuICAgICAgICAgICAgICAgIGxldCB7IHA6IGsycCwgZjogZjJwIH0gPSB0aGlzLndOQUYoazIpO1xuICAgICAgICAgICAgICAgIGsxcCA9IHduYWYuY29uc3RUaW1lTmVnYXRlKGsxbmVnLCBrMXApO1xuICAgICAgICAgICAgICAgIGsycCA9IHduYWYuY29uc3RUaW1lTmVnYXRlKGsybmVnLCBrMnApO1xuICAgICAgICAgICAgICAgIGsycCA9IG5ldyBQb2ludChGcC5tdWwoazJwLnB4LCBlbmRvLmJldGEpLCBrMnAucHksIGsycC5weik7XG4gICAgICAgICAgICAgICAgcG9pbnQgPSBrMXAuYWRkKGsycCk7XG4gICAgICAgICAgICAgICAgZmFrZSA9IGYxcC5hZGQoZjJwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcCwgZiB9ID0gdGhpcy53TkFGKG4pO1xuICAgICAgICAgICAgICAgIHBvaW50ID0gcDtcbiAgICAgICAgICAgICAgICBmYWtlID0gZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSBgemAgZm9yIGJvdGggcG9pbnRzLCBidXQgcmV0dXJuIG9ubHkgcmVhbCBvbmVcbiAgICAgICAgICAgIHJldHVybiBQb2ludC5ub3JtYWxpemVaKFtwb2ludCwgZmFrZV0pWzBdO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFZmZpY2llbnRseSBjYWxjdWxhdGUgYGFQICsgYlFgLiBVbnNhZmUsIGNhbiBleHBvc2UgcHJpdmF0ZSBrZXksIGlmIHVzZWQgaW5jb3JyZWN0bHkuXG4gICAgICAgICAqIE5vdCB1c2luZyBTdHJhdXNzLVNoYW1pciB0cmljazogcHJlY29tcHV0YXRpb24gdGFibGVzIGFyZSBmYXN0ZXIuXG4gICAgICAgICAqIFRoZSB0cmljayBjb3VsZCBiZSB1c2VmdWwgaWYgYm90aCBQIGFuZCBRIGFyZSBub3QgRyAobm90IGluIG91ciBjYXNlKS5cbiAgICAgICAgICogQHJldHVybnMgbm9uLXplcm8gYWZmaW5lIHBvaW50XG4gICAgICAgICAqL1xuICAgICAgICBtdWx0aXBseUFuZEFkZFVuc2FmZShRLCBhLCBiKSB7XG4gICAgICAgICAgICBjb25zdCBHID0gUG9pbnQuQkFTRTsgLy8gTm8gU3RyYXVzcy1TaGFtaXIgdHJpY2s6IHdlIGhhdmUgMTAlIGZhc3RlciBHIHByZWNvbXB1dGVzXG4gICAgICAgICAgICBjb25zdCBtdWwgPSAoUCwgYSAvLyBTZWxlY3QgZmFzdGVyIG11bHRpcGx5KCkgbWV0aG9kXG4gICAgICAgICAgICApID0+IChhID09PSBfMG4gfHwgYSA9PT0gXzFuIHx8ICFQLmVxdWFscyhHKSA/IFAubXVsdGlwbHlVbnNhZmUoYSkgOiBQLm11bHRpcGx5KGEpKTtcbiAgICAgICAgICAgIGNvbnN0IHN1bSA9IG11bCh0aGlzLCBhKS5hZGQobXVsKFEsIGIpKTtcbiAgICAgICAgICAgIHJldHVybiBzdW0uaXMwKCkgPyB1bmRlZmluZWQgOiBzdW07XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29udmVydHMgUHJvamVjdGl2ZSBwb2ludCB0byBhZmZpbmUgKHgsIHkpIGNvb3JkaW5hdGVzLlxuICAgICAgICAvLyBDYW4gYWNjZXB0IHByZWNvbXB1dGVkIFpeLTEgLSBmb3IgZXhhbXBsZSwgZnJvbSBpbnZlcnRCYXRjaC5cbiAgICAgICAgLy8gKHgsIHksIHopIOKIiyAoeD14L3osIHk9eS96KVxuICAgICAgICB0b0FmZmluZShpeikge1xuICAgICAgICAgICAgY29uc3QgeyBweDogeCwgcHk6IHksIHB6OiB6IH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgaXMwID0gdGhpcy5pczAoKTtcbiAgICAgICAgICAgIC8vIElmIGludlogd2FzIDAsIHdlIHJldHVybiB6ZXJvIHBvaW50LiBIb3dldmVyIHdlIHN0aWxsIHdhbnQgdG8gZXhlY3V0ZVxuICAgICAgICAgICAgLy8gYWxsIG9wZXJhdGlvbnMsIHNvIHdlIHJlcGxhY2UgaW52WiB3aXRoIGEgcmFuZG9tIG51bWJlciwgMS5cbiAgICAgICAgICAgIGlmIChpeiA9PSBudWxsKVxuICAgICAgICAgICAgICAgIGl6ID0gaXMwID8gRnAuT05FIDogRnAuaW52KHopO1xuICAgICAgICAgICAgY29uc3QgYXggPSBGcC5tdWwoeCwgaXopO1xuICAgICAgICAgICAgY29uc3QgYXkgPSBGcC5tdWwoeSwgaXopO1xuICAgICAgICAgICAgY29uc3QgenogPSBGcC5tdWwoeiwgaXopO1xuICAgICAgICAgICAgaWYgKGlzMClcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4OiBGcC5aRVJPLCB5OiBGcC5aRVJPIH07XG4gICAgICAgICAgICBpZiAoIUZwLmVxbCh6eiwgRnAuT05FKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludlogd2FzIGludmFsaWQnKTtcbiAgICAgICAgICAgIHJldHVybiB7IHg6IGF4LCB5OiBheSB9O1xuICAgICAgICB9XG4gICAgICAgIGlzVG9yc2lvbkZyZWUoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGg6IGNvZmFjdG9yLCBpc1RvcnNpb25GcmVlIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGlmIChjb2ZhY3RvciA9PT0gXzFuKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBObyBzdWJncm91cHMsIGFsd2F5cyB0b3JzaW9uLWZyZWVcbiAgICAgICAgICAgIGlmIChpc1RvcnNpb25GcmVlKVxuICAgICAgICAgICAgICAgIHJldHVybiBpc1RvcnNpb25GcmVlKFBvaW50LCB0aGlzKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaXNUb3JzaW9uRnJlZSgpIGhhcyBub3QgYmVlbiBkZWNsYXJlZCBmb3IgdGhlIGVsbGlwdGljIGN1cnZlJyk7XG4gICAgICAgIH1cbiAgICAgICAgY2xlYXJDb2ZhY3RvcigpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaDogY29mYWN0b3IsIGNsZWFyQ29mYWN0b3IgfSA9IENVUlZFO1xuICAgICAgICAgICAgaWYgKGNvZmFjdG9yID09PSBfMW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7IC8vIEZhc3QtcGF0aFxuICAgICAgICAgICAgaWYgKGNsZWFyQ29mYWN0b3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsZWFyQ29mYWN0b3IoUG9pbnQsIHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHlVbnNhZmUoQ1VSVkUuaCk7XG4gICAgICAgIH1cbiAgICAgICAgdG9SYXdCeXRlcyhpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gdG9CeXRlcyhQb2ludCwgdGhpcywgaXNDb21wcmVzc2VkKTtcbiAgICAgICAgfVxuICAgICAgICB0b0hleChpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdXQuYnl0ZXNUb0hleCh0aGlzLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgUG9pbnQuQkFTRSA9IG5ldyBQb2ludChDVVJWRS5HeCwgQ1VSVkUuR3ksIEZwLk9ORSk7XG4gICAgUG9pbnQuWkVSTyA9IG5ldyBQb2ludChGcC5aRVJPLCBGcC5PTkUsIEZwLlpFUk8pO1xuICAgIGNvbnN0IF9iaXRzID0gQ1VSVkUubkJpdExlbmd0aDtcbiAgICBjb25zdCB3bmFmID0gd05BRihQb2ludCwgQ1VSVkUuZW5kbyA/IE1hdGguY2VpbChfYml0cyAvIDIpIDogX2JpdHMpO1xuICAgIC8vIFZhbGlkYXRlIGlmIGdlbmVyYXRvciBwb2ludCBpcyBvbiBjdXJ2ZVxuICAgIHJldHVybiB7XG4gICAgICAgIENVUlZFLFxuICAgICAgICBQcm9qZWN0aXZlUG9pbnQ6IFBvaW50LFxuICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyLFxuICAgICAgICB3ZWllcnN0cmFzc0VxdWF0aW9uLFxuICAgICAgICBpc1dpdGhpbkN1cnZlT3JkZXIsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlT3B0cyhjdXJ2ZSkge1xuICAgIGNvbnN0IG9wdHMgPSB2YWxpZGF0ZUJhc2ljKGN1cnZlKTtcbiAgICB1dC52YWxpZGF0ZU9iamVjdChvcHRzLCB7XG4gICAgICAgIGhhc2g6ICdoYXNoJyxcbiAgICAgICAgaG1hYzogJ2Z1bmN0aW9uJyxcbiAgICAgICAgcmFuZG9tQnl0ZXM6ICdmdW5jdGlvbicsXG4gICAgfSwge1xuICAgICAgICBiaXRzMmludDogJ2Z1bmN0aW9uJyxcbiAgICAgICAgYml0czJpbnRfbW9kTjogJ2Z1bmN0aW9uJyxcbiAgICAgICAgbG93UzogJ2Jvb2xlYW4nLFxuICAgIH0pO1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHsgbG93UzogdHJ1ZSwgLi4ub3B0cyB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB3ZWllcnN0cmFzcyhjdXJ2ZURlZikge1xuICAgIGNvbnN0IENVUlZFID0gdmFsaWRhdGVPcHRzKGN1cnZlRGVmKTtcbiAgICBjb25zdCB7IEZwLCBuOiBDVVJWRV9PUkRFUiB9ID0gQ1VSVkU7XG4gICAgY29uc3QgY29tcHJlc3NlZExlbiA9IEZwLkJZVEVTICsgMTsgLy8gZS5nLiAzMyBmb3IgMzJcbiAgICBjb25zdCB1bmNvbXByZXNzZWRMZW4gPSAyICogRnAuQllURVMgKyAxOyAvLyBlLmcuIDY1IGZvciAzMlxuICAgIGZ1bmN0aW9uIGlzVmFsaWRGaWVsZEVsZW1lbnQobnVtKSB7XG4gICAgICAgIHJldHVybiBfMG4gPCBudW0gJiYgbnVtIDwgRnAuT1JERVI7IC8vIDAgaXMgYmFubmVkIHNpbmNlIGl0J3Mgbm90IGludmVydGlibGUgRkVcbiAgICB9XG4gICAgZnVuY3Rpb24gbW9kTihhKSB7XG4gICAgICAgIHJldHVybiBtb2QubW9kKGEsIENVUlZFX09SREVSKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW52TihhKSB7XG4gICAgICAgIHJldHVybiBtb2QuaW52ZXJ0KGEsIENVUlZFX09SREVSKTtcbiAgICB9XG4gICAgY29uc3QgeyBQcm9qZWN0aXZlUG9pbnQ6IFBvaW50LCBub3JtUHJpdmF0ZUtleVRvU2NhbGFyLCB3ZWllcnN0cmFzc0VxdWF0aW9uLCBpc1dpdGhpbkN1cnZlT3JkZXIsIH0gPSB3ZWllcnN0cmFzc1BvaW50cyh7XG4gICAgICAgIC4uLkNVUlZFLFxuICAgICAgICB0b0J5dGVzKF9jLCBwb2ludCwgaXNDb21wcmVzc2VkKSB7XG4gICAgICAgICAgICBjb25zdCBhID0gcG9pbnQudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIGNvbnN0IHggPSBGcC50b0J5dGVzKGEueCk7XG4gICAgICAgICAgICBjb25zdCBjYXQgPSB1dC5jb25jYXRCeXRlcztcbiAgICAgICAgICAgIGlmIChpc0NvbXByZXNzZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2F0KFVpbnQ4QXJyYXkuZnJvbShbcG9pbnQuaGFzRXZlblkoKSA/IDB4MDIgOiAweDAzXSksIHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhdChVaW50OEFycmF5LmZyb20oWzB4MDRdKSwgeCwgRnAudG9CeXRlcyhhLnkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZnJvbUJ5dGVzKGJ5dGVzKSB7XG4gICAgICAgICAgICBjb25zdCBsZW4gPSBieXRlcy5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBoZWFkID0gYnl0ZXNbMF07XG4gICAgICAgICAgICBjb25zdCB0YWlsID0gYnl0ZXMuc3ViYXJyYXkoMSk7XG4gICAgICAgICAgICAvLyB0aGlzLmFzc2VydFZhbGlkaXR5KCkgaXMgZG9uZSBpbnNpZGUgb2YgZnJvbUhleFxuICAgICAgICAgICAgaWYgKGxlbiA9PT0gY29tcHJlc3NlZExlbiAmJiAoaGVhZCA9PT0gMHgwMiB8fCBoZWFkID09PSAweDAzKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSB1dC5ieXRlc1RvTnVtYmVyQkUodGFpbCk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkRmllbGRFbGVtZW50KHgpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvaW50IGlzIG5vdCBvbiBjdXJ2ZScpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkyID0gd2VpZXJzdHJhc3NFcXVhdGlvbih4KTsgLy8gecKyID0geMKzICsgYXggKyBiXG4gICAgICAgICAgICAgICAgbGV0IHkgPSBGcC5zcXJ0KHkyKTsgLy8geSA9IHnCsiBeIChwKzEpLzRcbiAgICAgICAgICAgICAgICBjb25zdCBpc1lPZGQgPSAoeSAmIF8xbikgPT09IF8xbjtcbiAgICAgICAgICAgICAgICAvLyBFQ0RTQVxuICAgICAgICAgICAgICAgIGNvbnN0IGlzSGVhZE9kZCA9IChoZWFkICYgMSkgPT09IDE7XG4gICAgICAgICAgICAgICAgaWYgKGlzSGVhZE9kZCAhPT0gaXNZT2RkKVxuICAgICAgICAgICAgICAgICAgICB5ID0gRnAubmVnKHkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGxlbiA9PT0gdW5jb21wcmVzc2VkTGVuICYmIGhlYWQgPT09IDB4MDQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoMCwgRnAuQllURVMpKTtcbiAgICAgICAgICAgICAgICBjb25zdCB5ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoRnAuQllURVMsIDIgKiBGcC5CWVRFUykpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9pbnQgb2YgbGVuZ3RoICR7bGVufSB3YXMgaW52YWxpZC4gRXhwZWN0ZWQgJHtjb21wcmVzc2VkTGVufSBjb21wcmVzc2VkIGJ5dGVzIG9yICR7dW5jb21wcmVzc2VkTGVufSB1bmNvbXByZXNzZWQgYnl0ZXNgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICBjb25zdCBudW1Ub05CeXRlU3RyID0gKG51bSkgPT4gdXQuYnl0ZXNUb0hleCh1dC5udW1iZXJUb0J5dGVzQkUobnVtLCBDVVJWRS5uQnl0ZUxlbmd0aCkpO1xuICAgIGZ1bmN0aW9uIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihudW1iZXIpIHtcbiAgICAgICAgY29uc3QgSEFMRiA9IENVUlZFX09SREVSID4+IF8xbjtcbiAgICAgICAgcmV0dXJuIG51bWJlciA+IEhBTEY7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZVMocykge1xuICAgICAgICByZXR1cm4gaXNCaWdnZXJUaGFuSGFsZk9yZGVyKHMpID8gbW9kTigtcykgOiBzO1xuICAgIH1cbiAgICAvLyBzbGljZSBieXRlcyBudW1cbiAgICBjb25zdCBzbGNOdW0gPSAoYiwgZnJvbSwgdG8pID0+IHV0LmJ5dGVzVG9OdW1iZXJCRShiLnNsaWNlKGZyb20sIHRvKSk7XG4gICAgLyoqXG4gICAgICogRUNEU0Egc2lnbmF0dXJlIHdpdGggaXRzIChyLCBzKSBwcm9wZXJ0aWVzLiBTdXBwb3J0cyBERVIgJiBjb21wYWN0IHJlcHJlc2VudGF0aW9ucy5cbiAgICAgKi9cbiAgICBjbGFzcyBTaWduYXR1cmUge1xuICAgICAgICBjb25zdHJ1Y3RvcihyLCBzLCByZWNvdmVyeSkge1xuICAgICAgICAgICAgdGhpcy5yID0gcjtcbiAgICAgICAgICAgIHRoaXMucyA9IHM7XG4gICAgICAgICAgICB0aGlzLnJlY292ZXJ5ID0gcmVjb3Zlcnk7XG4gICAgICAgICAgICB0aGlzLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcGFpciAoYnl0ZXMgb2YgciwgYnl0ZXMgb2YgcylcbiAgICAgICAgc3RhdGljIGZyb21Db21wYWN0KGhleCkge1xuICAgICAgICAgICAgY29uc3QgbCA9IENVUlZFLm5CeXRlTGVuZ3RoO1xuICAgICAgICAgICAgaGV4ID0gZW5zdXJlQnl0ZXMoJ2NvbXBhY3RTaWduYXR1cmUnLCBoZXgsIGwgKiAyKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHNsY051bShoZXgsIDAsIGwpLCBzbGNOdW0oaGV4LCBsLCAyICogbCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERFUiBlbmNvZGVkIEVDRFNBIHNpZ25hdHVyZVxuICAgICAgICAvLyBodHRwczovL2JpdGNvaW4uc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzU3NjQ0L3doYXQtYXJlLXRoZS1wYXJ0cy1vZi1hLWJpdGNvaW4tdHJhbnNhY3Rpb24taW5wdXQtc2NyaXB0XG4gICAgICAgIHN0YXRpYyBmcm9tREVSKGhleCkge1xuICAgICAgICAgICAgY29uc3QgeyByLCBzIH0gPSBERVIudG9TaWcoZW5zdXJlQnl0ZXMoJ0RFUicsIGhleCkpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUociwgcyk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0VmFsaWRpdHkoKSB7XG4gICAgICAgICAgICAvLyBjYW4gdXNlIGFzc2VydEdFIGhlcmVcbiAgICAgICAgICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKHRoaXMucikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyIG11c3QgYmUgMCA8IHIgPCBDVVJWRS5uJyk7XG4gICAgICAgICAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcih0aGlzLnMpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncyBtdXN0IGJlIDAgPCBzIDwgQ1VSVkUubicpO1xuICAgICAgICB9XG4gICAgICAgIGFkZFJlY292ZXJ5Qml0KHJlY292ZXJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZSh0aGlzLnIsIHRoaXMucywgcmVjb3ZlcnkpO1xuICAgICAgICB9XG4gICAgICAgIHJlY292ZXJQdWJsaWNLZXkobXNnSGFzaCkge1xuICAgICAgICAgICAgY29uc3QgeyByLCBzLCByZWNvdmVyeTogcmVjIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgaCA9IGJpdHMyaW50X21vZE4oZW5zdXJlQnl0ZXMoJ21zZ0hhc2gnLCBtc2dIYXNoKSk7IC8vIFRydW5jYXRlIGhhc2hcbiAgICAgICAgICAgIGlmIChyZWMgPT0gbnVsbCB8fCAhWzAsIDEsIDIsIDNdLmluY2x1ZGVzKHJlYykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWNvdmVyeSBpZCBpbnZhbGlkJyk7XG4gICAgICAgICAgICBjb25zdCByYWRqID0gcmVjID09PSAyIHx8IHJlYyA9PT0gMyA/IHIgKyBDVVJWRS5uIDogcjtcbiAgICAgICAgICAgIGlmIChyYWRqID49IEZwLk9SREVSKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVjb3ZlcnkgaWQgMiBvciAzIGludmFsaWQnKTtcbiAgICAgICAgICAgIGNvbnN0IHByZWZpeCA9IChyZWMgJiAxKSA9PT0gMCA/ICcwMicgOiAnMDMnO1xuICAgICAgICAgICAgY29uc3QgUiA9IFBvaW50LmZyb21IZXgocHJlZml4ICsgbnVtVG9OQnl0ZVN0cihyYWRqKSk7XG4gICAgICAgICAgICBjb25zdCBpciA9IGludk4ocmFkaik7IC8vIHJeLTFcbiAgICAgICAgICAgIGNvbnN0IHUxID0gbW9kTigtaCAqIGlyKTsgLy8gLWhyXi0xXG4gICAgICAgICAgICBjb25zdCB1MiA9IG1vZE4ocyAqIGlyKTsgLy8gc3JeLTFcbiAgICAgICAgICAgIGNvbnN0IFEgPSBQb2ludC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKFIsIHUxLCB1Mik7IC8vIChzcl4tMSlSLShocl4tMSlHID0gLShocl4tMSlHICsgKHNyXi0xKVxuICAgICAgICAgICAgaWYgKCFRKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncG9pbnQgYXQgaW5maW5pZnknKTsgLy8gdW5zYWZlIGlzIGZpbmU6IG5vIHByaXYgZGF0YSBsZWFrZWRcbiAgICAgICAgICAgIFEuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiBRO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNpZ25hdHVyZXMgc2hvdWxkIGJlIGxvdy1zLCB0byBwcmV2ZW50IG1hbGxlYWJpbGl0eS5cbiAgICAgICAgaGFzSGlnaFMoKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNCaWdnZXJUaGFuSGFsZk9yZGVyKHRoaXMucyk7XG4gICAgICAgIH1cbiAgICAgICAgbm9ybWFsaXplUygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhc0hpZ2hTKCkgPyBuZXcgU2lnbmF0dXJlKHRoaXMuciwgbW9kTigtdGhpcy5zKSwgdGhpcy5yZWNvdmVyeSkgOiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIERFUi1lbmNvZGVkXG4gICAgICAgIHRvREVSUmF3Qnl0ZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdXQuaGV4VG9CeXRlcyh0aGlzLnRvREVSSGV4KCkpO1xuICAgICAgICB9XG4gICAgICAgIHRvREVSSGV4KCkge1xuICAgICAgICAgICAgcmV0dXJuIERFUi5oZXhGcm9tU2lnKHsgcjogdGhpcy5yLCBzOiB0aGlzLnMgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcGFkZGVkIGJ5dGVzIG9mIHIsIHRoZW4gcGFkZGVkIGJ5dGVzIG9mIHNcbiAgICAgICAgdG9Db21wYWN0UmF3Qnl0ZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdXQuaGV4VG9CeXRlcyh0aGlzLnRvQ29tcGFjdEhleCgpKTtcbiAgICAgICAgfVxuICAgICAgICB0b0NvbXBhY3RIZXgoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtVG9OQnl0ZVN0cih0aGlzLnIpICsgbnVtVG9OQnl0ZVN0cih0aGlzLnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHV0aWxzID0ge1xuICAgICAgICBpc1ZhbGlkUHJpdmF0ZUtleShwcml2YXRlS2V5KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUtleSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXI6IG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9kdWNlcyBjcnlwdG9ncmFwaGljYWxseSBzZWN1cmUgcHJpdmF0ZSBrZXkgZnJvbSByYW5kb20gb2Ygc2l6ZVxuICAgICAgICAgKiAoZ3JvdXBMZW4gKyBjZWlsKGdyb3VwTGVuIC8gMikpIHdpdGggbW9kdWxvIGJpYXMgYmVpbmcgbmVnbGlnaWJsZS5cbiAgICAgICAgICovXG4gICAgICAgIHJhbmRvbVByaXZhdGVLZXk6ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IG1vZC5nZXRNaW5IYXNoTGVuZ3RoKENVUlZFLm4pO1xuICAgICAgICAgICAgcmV0dXJuIG1vZC5tYXBIYXNoVG9GaWVsZChDVVJWRS5yYW5kb21CeXRlcyhsZW5ndGgpLCBDVVJWRS5uKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgcHJlY29tcHV0ZSB0YWJsZSBmb3IgYW4gYXJiaXRyYXJ5IEVDIHBvaW50LiBNYWtlcyBwb2ludCBcImNhY2hlZFwiLlxuICAgICAgICAgKiBBbGxvd3MgdG8gbWFzc2l2ZWx5IHNwZWVkLXVwIGBwb2ludC5tdWx0aXBseShzY2FsYXIpYC5cbiAgICAgICAgICogQHJldHVybnMgY2FjaGVkIHBvaW50XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGNvbnN0IGZhc3QgPSB1dGlscy5wcmVjb21wdXRlKDgsIFByb2plY3RpdmVQb2ludC5mcm9tSGV4KHNvbWVvbmVzUHViS2V5KSk7XG4gICAgICAgICAqIGZhc3QubXVsdGlwbHkocHJpdktleSk7IC8vIG11Y2ggZmFzdGVyIEVDREggbm93XG4gICAgICAgICAqL1xuICAgICAgICBwcmVjb21wdXRlKHdpbmRvd1NpemUgPSA4LCBwb2ludCA9IFBvaW50LkJBU0UpIHtcbiAgICAgICAgICAgIHBvaW50Ll9zZXRXaW5kb3dTaXplKHdpbmRvd1NpemUpO1xuICAgICAgICAgICAgcG9pbnQubXVsdGlwbHkoQmlnSW50KDMpKTsgLy8gMyBpcyBhcmJpdHJhcnksIGp1c3QgbmVlZCBhbnkgbnVtYmVyIGhlcmVcbiAgICAgICAgICAgIHJldHVybiBwb2ludDtcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHB1YmxpYyBrZXkgZm9yIGEgcHJpdmF0ZSBrZXkuIENoZWNrcyBmb3IgdmFsaWRpdHkgb2YgdGhlIHByaXZhdGUga2V5LlxuICAgICAqIEBwYXJhbSBwcml2YXRlS2V5IHByaXZhdGUga2V5XG4gICAgICogQHBhcmFtIGlzQ29tcHJlc3NlZCB3aGV0aGVyIHRvIHJldHVybiBjb21wYWN0IChkZWZhdWx0KSwgb3IgZnVsbCBrZXlcbiAgICAgKiBAcmV0dXJucyBQdWJsaWMga2V5LCBmdWxsIHdoZW4gaXNDb21wcmVzc2VkPWZhbHNlOyBzaG9ydCB3aGVuIGlzQ29tcHJlc3NlZD10cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0UHVibGljS2V5KHByaXZhdGVLZXksIGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIFBvaW50LmZyb21Qcml2YXRlS2V5KHByaXZhdGVLZXkpLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUXVpY2sgYW5kIGRpcnR5IGNoZWNrIGZvciBpdGVtIGJlaW5nIHB1YmxpYyBrZXkuIERvZXMgbm90IHZhbGlkYXRlIGhleCwgb3IgYmVpbmcgb24tY3VydmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNQcm9iUHViKGl0ZW0pIHtcbiAgICAgICAgY29uc3QgYXJyID0gaXRlbSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XG4gICAgICAgIGNvbnN0IHN0ciA9IHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJztcbiAgICAgICAgY29uc3QgbGVuID0gKGFyciB8fCBzdHIpICYmIGl0ZW0ubGVuZ3RoO1xuICAgICAgICBpZiAoYXJyKVxuICAgICAgICAgICAgcmV0dXJuIGxlbiA9PT0gY29tcHJlc3NlZExlbiB8fCBsZW4gPT09IHVuY29tcHJlc3NlZExlbjtcbiAgICAgICAgaWYgKHN0cilcbiAgICAgICAgICAgIHJldHVybiBsZW4gPT09IDIgKiBjb21wcmVzc2VkTGVuIHx8IGxlbiA9PT0gMiAqIHVuY29tcHJlc3NlZExlbjtcbiAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBQb2ludClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVDREggKEVsbGlwdGljIEN1cnZlIERpZmZpZSBIZWxsbWFuKS5cbiAgICAgKiBDb21wdXRlcyBzaGFyZWQgcHVibGljIGtleSBmcm9tIHByaXZhdGUga2V5IGFuZCBwdWJsaWMga2V5LlxuICAgICAqIENoZWNrczogMSkgcHJpdmF0ZSBrZXkgdmFsaWRpdHkgMikgc2hhcmVkIGtleSBpcyBvbi1jdXJ2ZS5cbiAgICAgKiBEb2VzIE5PVCBoYXNoIHRoZSByZXN1bHQuXG4gICAgICogQHBhcmFtIHByaXZhdGVBIHByaXZhdGUga2V5XG4gICAgICogQHBhcmFtIHB1YmxpY0IgZGlmZmVyZW50IHB1YmxpYyBrZXlcbiAgICAgKiBAcGFyYW0gaXNDb21wcmVzc2VkIHdoZXRoZXIgdG8gcmV0dXJuIGNvbXBhY3QgKGRlZmF1bHQpLCBvciBmdWxsIGtleVxuICAgICAqIEByZXR1cm5zIHNoYXJlZCBwdWJsaWMga2V5XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0U2hhcmVkU2VjcmV0KHByaXZhdGVBLCBwdWJsaWNCLCBpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgIGlmIChpc1Byb2JQdWIocHJpdmF0ZUEpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaXJzdCBhcmcgbXVzdCBiZSBwcml2YXRlIGtleScpO1xuICAgICAgICBpZiAoIWlzUHJvYlB1YihwdWJsaWNCKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2Vjb25kIGFyZyBtdXN0IGJlIHB1YmxpYyBrZXknKTtcbiAgICAgICAgY29uc3QgYiA9IFBvaW50LmZyb21IZXgocHVibGljQik7IC8vIGNoZWNrIGZvciBiZWluZyBvbi1jdXJ2ZVxuICAgICAgICByZXR1cm4gYi5tdWx0aXBseShub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVBKSkudG9SYXdCeXRlcyhpc0NvbXByZXNzZWQpO1xuICAgIH1cbiAgICAvLyBSRkM2OTc5OiBlbnN1cmUgRUNEU0EgbXNnIGlzIFggYnl0ZXMgYW5kIDwgTi4gUkZDIHN1Z2dlc3RzIG9wdGlvbmFsIHRydW5jYXRpbmcgdmlhIGJpdHMyb2N0ZXRzLlxuICAgIC8vIEZJUFMgMTg2LTQgNC42IHN1Z2dlc3RzIHRoZSBsZWZ0bW9zdCBtaW4obkJpdExlbiwgb3V0TGVuKSBiaXRzLCB3aGljaCBtYXRjaGVzIGJpdHMyaW50LlxuICAgIC8vIGJpdHMyaW50IGNhbiBwcm9kdWNlIHJlcz5OLCB3ZSBjYW4gZG8gbW9kKHJlcywgTikgc2luY2UgdGhlIGJpdExlbiBpcyB0aGUgc2FtZS5cbiAgICAvLyBpbnQyb2N0ZXRzIGNhbid0IGJlIHVzZWQ7IHBhZHMgc21hbGwgbXNncyB3aXRoIDA6IHVuYWNjZXB0YXRibGUgZm9yIHRydW5jIGFzIHBlciBSRkMgdmVjdG9yc1xuICAgIGNvbnN0IGJpdHMyaW50ID0gQ1VSVkUuYml0czJpbnQgfHxcbiAgICAgICAgZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgICAgICAgICAvLyBGb3IgY3VydmVzIHdpdGggbkJpdExlbmd0aCAlIDggIT09IDA6IGJpdHMyb2N0ZXRzKGJpdHMyb2N0ZXRzKG0pKSAhPT0gYml0czJvY3RldHMobSlcbiAgICAgICAgICAgIC8vIGZvciBzb21lIGNhc2VzLCBzaW5jZSBieXRlcy5sZW5ndGggKiA4IGlzIG5vdCBhY3R1YWwgYml0TGVuZ3RoLlxuICAgICAgICAgICAgY29uc3QgbnVtID0gdXQuYnl0ZXNUb051bWJlckJFKGJ5dGVzKTsgLy8gY2hlY2sgZm9yID09IHU4IGRvbmUgaGVyZVxuICAgICAgICAgICAgY29uc3QgZGVsdGEgPSBieXRlcy5sZW5ndGggKiA4IC0gQ1VSVkUubkJpdExlbmd0aDsgLy8gdHJ1bmNhdGUgdG8gbkJpdExlbmd0aCBsZWZ0bW9zdCBiaXRzXG4gICAgICAgICAgICByZXR1cm4gZGVsdGEgPiAwID8gbnVtID4+IEJpZ0ludChkZWx0YSkgOiBudW07XG4gICAgICAgIH07XG4gICAgY29uc3QgYml0czJpbnRfbW9kTiA9IENVUlZFLmJpdHMyaW50X21vZE4gfHxcbiAgICAgICAgZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9kTihiaXRzMmludChieXRlcykpOyAvLyBjYW4ndCB1c2UgYnl0ZXNUb051bWJlckJFIGhlcmVcbiAgICAgICAgfTtcbiAgICAvLyBOT1RFOiBwYWRzIG91dHB1dCB3aXRoIHplcm8gYXMgcGVyIHNwZWNcbiAgICBjb25zdCBPUkRFUl9NQVNLID0gdXQuYml0TWFzayhDVVJWRS5uQml0TGVuZ3RoKTtcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0byBieXRlcy4gQ2hlY2tzIGlmIG51bSBpbiBgWzAuLk9SREVSX01BU0stMV1gIGUuZy46IGBbMC4uMl4yNTYtMV1gLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludDJvY3RldHMobnVtKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbnVtICE9PSAnYmlnaW50JylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmlnaW50IGV4cGVjdGVkJyk7XG4gICAgICAgIGlmICghKF8wbiA8PSBudW0gJiYgbnVtIDwgT1JERVJfTUFTSykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJpZ2ludCBleHBlY3RlZCA8IDJeJHtDVVJWRS5uQml0TGVuZ3RofWApO1xuICAgICAgICAvLyB3b3JrcyB3aXRoIG9yZGVyLCBjYW4gaGF2ZSBkaWZmZXJlbnQgc2l6ZSB0aGFuIG51bVRvRmllbGQhXG4gICAgICAgIHJldHVybiB1dC5udW1iZXJUb0J5dGVzQkUobnVtLCBDVVJWRS5uQnl0ZUxlbmd0aCk7XG4gICAgfVxuICAgIC8vIFN0ZXBzIEEsIEQgb2YgUkZDNjk3OSAzLjJcbiAgICAvLyBDcmVhdGVzIFJGQzY5Nzkgc2VlZDsgY29udmVydHMgbXNnL3ByaXZLZXkgdG8gbnVtYmVycy5cbiAgICAvLyBVc2VkIG9ubHkgaW4gc2lnbiwgbm90IGluIHZlcmlmeS5cbiAgICAvLyBOT1RFOiB3ZSBjYW5ub3QgYXNzdW1lIGhlcmUgdGhhdCBtc2dIYXNoIGhhcyBzYW1lIGFtb3VudCBvZiBieXRlcyBhcyBjdXJ2ZSBvcmRlciwgdGhpcyB3aWxsIGJlIHdyb25nIGF0IGxlYXN0IGZvciBQNTIxLlxuICAgIC8vIEFsc28gaXQgY2FuIGJlIGJpZ2dlciBmb3IgUDIyNCArIFNIQTI1NlxuICAgIGZ1bmN0aW9uIHByZXBTaWcobXNnSGFzaCwgcHJpdmF0ZUtleSwgb3B0cyA9IGRlZmF1bHRTaWdPcHRzKSB7XG4gICAgICAgIGlmIChbJ3JlY292ZXJlZCcsICdjYW5vbmljYWwnXS5zb21lKChrKSA9PiBrIGluIG9wdHMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduKCkgbGVnYWN5IG9wdGlvbnMgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICBjb25zdCB7IGhhc2gsIHJhbmRvbUJ5dGVzIH0gPSBDVVJWRTtcbiAgICAgICAgbGV0IHsgbG93UywgcHJlaGFzaCwgZXh0cmFFbnRyb3B5OiBlbnQgfSA9IG9wdHM7IC8vIGdlbmVyYXRlcyBsb3ctcyBzaWdzIGJ5IGRlZmF1bHRcbiAgICAgICAgaWYgKGxvd1MgPT0gbnVsbClcbiAgICAgICAgICAgIGxvd1MgPSB0cnVlOyAvLyBSRkM2OTc5IDMuMjogd2Ugc2tpcCBzdGVwIEEsIGJlY2F1c2Ugd2UgYWxyZWFkeSBwcm92aWRlIGhhc2hcbiAgICAgICAgbXNnSGFzaCA9IGVuc3VyZUJ5dGVzKCdtc2dIYXNoJywgbXNnSGFzaCk7XG4gICAgICAgIGlmIChwcmVoYXNoKVxuICAgICAgICAgICAgbXNnSGFzaCA9IGVuc3VyZUJ5dGVzKCdwcmVoYXNoZWQgbXNnSGFzaCcsIGhhc2gobXNnSGFzaCkpO1xuICAgICAgICAvLyBXZSBjYW4ndCBsYXRlciBjYWxsIGJpdHMyb2N0ZXRzLCBzaW5jZSBuZXN0ZWQgYml0czJpbnQgaXMgYnJva2VuIGZvciBjdXJ2ZXNcbiAgICAgICAgLy8gd2l0aCBuQml0TGVuZ3RoICUgOCAhPT0gMC4gQmVjYXVzZSBvZiB0aGF0LCB3ZSB1bndyYXAgaXQgaGVyZSBhcyBpbnQyb2N0ZXRzIGNhbGwuXG4gICAgICAgIC8vIGNvbnN0IGJpdHMyb2N0ZXRzID0gKGJpdHMpID0+IGludDJvY3RldHMoYml0czJpbnRfbW9kTihiaXRzKSlcbiAgICAgICAgY29uc3QgaDFpbnQgPSBiaXRzMmludF9tb2ROKG1zZ0hhc2gpO1xuICAgICAgICBjb25zdCBkID0gbm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlS2V5KTsgLy8gdmFsaWRhdGUgcHJpdmF0ZSBrZXksIGNvbnZlcnQgdG8gYmlnaW50XG4gICAgICAgIGNvbnN0IHNlZWRBcmdzID0gW2ludDJvY3RldHMoZCksIGludDJvY3RldHMoaDFpbnQpXTtcbiAgICAgICAgLy8gZXh0cmFFbnRyb3B5LiBSRkM2OTc5IDMuNjogYWRkaXRpb25hbCBrJyAob3B0aW9uYWwpLlxuICAgICAgICBpZiAoZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIEsgPSBITUFDX0soViB8fCAweDAwIHx8IGludDJvY3RldHMoeCkgfHwgYml0czJvY3RldHMoaDEpIHx8IGsnKVxuICAgICAgICAgICAgY29uc3QgZSA9IGVudCA9PT0gdHJ1ZSA/IHJhbmRvbUJ5dGVzKEZwLkJZVEVTKSA6IGVudDsgLy8gZ2VuZXJhdGUgcmFuZG9tIGJ5dGVzIE9SIHBhc3MgYXMtaXNcbiAgICAgICAgICAgIHNlZWRBcmdzLnB1c2goZW5zdXJlQnl0ZXMoJ2V4dHJhRW50cm9weScsIGUpKTsgLy8gY2hlY2sgZm9yIGJlaW5nIGJ5dGVzXG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VlZCA9IHV0LmNvbmNhdEJ5dGVzKC4uLnNlZWRBcmdzKTsgLy8gU3RlcCBEIG9mIFJGQzY5NzkgMy4yXG4gICAgICAgIGNvbnN0IG0gPSBoMWludDsgLy8gTk9URTogbm8gbmVlZCB0byBjYWxsIGJpdHMyaW50IHNlY29uZCB0aW1lIGhlcmUsIGl0IGlzIGluc2lkZSB0cnVuY2F0ZUhhc2ghXG4gICAgICAgIC8vIENvbnZlcnRzIHNpZ25hdHVyZSBwYXJhbXMgaW50byBwb2ludCB3IHIvcywgY2hlY2tzIHJlc3VsdCBmb3IgdmFsaWRpdHkuXG4gICAgICAgIGZ1bmN0aW9uIGsyc2lnKGtCeXRlcykge1xuICAgICAgICAgICAgLy8gUkZDIDY5NzkgU2VjdGlvbiAzLjIsIHN0ZXAgMzogayA9IGJpdHMyaW50KFQpXG4gICAgICAgICAgICBjb25zdCBrID0gYml0czJpbnQoa0J5dGVzKTsgLy8gQ2Fubm90IHVzZSBmaWVsZHMgbWV0aG9kcywgc2luY2UgaXQgaXMgZ3JvdXAgZWxlbWVudFxuICAgICAgICAgICAgaWYgKCFpc1dpdGhpbkN1cnZlT3JkZXIoaykpXG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBJbXBvcnRhbnQ6IGFsbCBtb2QoKSBjYWxscyBoZXJlIG11c3QgYmUgZG9uZSBvdmVyIE5cbiAgICAgICAgICAgIGNvbnN0IGlrID0gaW52TihrKTsgLy8ga14tMSBtb2QgblxuICAgICAgICAgICAgY29uc3QgcSA9IFBvaW50LkJBU0UubXVsdGlwbHkoaykudG9BZmZpbmUoKTsgLy8gcSA9IEdrXG4gICAgICAgICAgICBjb25zdCByID0gbW9kTihxLngpOyAvLyByID0gcS54IG1vZCBuXG4gICAgICAgICAgICBpZiAociA9PT0gXzBuKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8vIENhbiB1c2Ugc2NhbGFyIGJsaW5kaW5nIGJeLTEoYm0gKyBiZHIpIHdoZXJlIGIg4oiIIFsxLHHiiJIxXSBhY2NvcmRpbmcgdG9cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vdGNoZXMuaWFjci5vcmcvaW5kZXgucGhwL1RDSEVTL2FydGljbGUvdmlldy83MzM3LzY1MDkuIFdlJ3ZlIGRlY2lkZWQgYWdhaW5zdCBpdDpcbiAgICAgICAgICAgIC8vIGEpIGRlcGVuZGVuY3kgb24gQ1NQUk5HIGIpIDE1JSBzbG93ZG93biBjKSBkb2Vzbid0IHJlYWxseSBoZWxwIHNpbmNlIGJpZ2ludHMgYXJlIG5vdCBDVFxuICAgICAgICAgICAgY29uc3QgcyA9IG1vZE4oaWsgKiBtb2ROKG0gKyByICogZCkpOyAvLyBOb3QgdXNpbmcgYmxpbmRpbmcgaGVyZVxuICAgICAgICAgICAgaWYgKHMgPT09IF8wbilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgcmVjb3ZlcnkgPSAocS54ID09PSByID8gMCA6IDIpIHwgTnVtYmVyKHEueSAmIF8xbik7IC8vIHJlY292ZXJ5IGJpdCAoMiBvciAzLCB3aGVuIHEueCA+IG4pXG4gICAgICAgICAgICBsZXQgbm9ybVMgPSBzO1xuICAgICAgICAgICAgaWYgKGxvd1MgJiYgaXNCaWdnZXJUaGFuSGFsZk9yZGVyKHMpKSB7XG4gICAgICAgICAgICAgICAgbm9ybVMgPSBub3JtYWxpemVTKHMpOyAvLyBpZiBsb3dTIHdhcyBwYXNzZWQsIGVuc3VyZSBzIGlzIGFsd2F5c1xuICAgICAgICAgICAgICAgIHJlY292ZXJ5IF49IDE7IC8vIC8vIGluIHRoZSBib3R0b20gaGFsZiBvZiBOXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShyLCBub3JtUywgcmVjb3ZlcnkpOyAvLyB1c2Ugbm9ybVMsIG5vdCBzXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc2VlZCwgazJzaWcgfTtcbiAgICB9XG4gICAgY29uc3QgZGVmYXVsdFNpZ09wdHMgPSB7IGxvd1M6IENVUlZFLmxvd1MsIHByZWhhc2g6IGZhbHNlIH07XG4gICAgY29uc3QgZGVmYXVsdFZlck9wdHMgPSB7IGxvd1M6IENVUlZFLmxvd1MsIHByZWhhc2g6IGZhbHNlIH07XG4gICAgLyoqXG4gICAgICogU2lnbnMgbWVzc2FnZSBoYXNoIHdpdGggYSBwcml2YXRlIGtleS5cbiAgICAgKiBgYGBcbiAgICAgKiBzaWduKG0sIGQsIGspIHdoZXJlXG4gICAgICogICAoeCwgeSkgPSBHIMOXIGtcbiAgICAgKiAgIHIgPSB4IG1vZCBuXG4gICAgICogICBzID0gKG0gKyBkcikvayBtb2QgblxuICAgICAqIGBgYFxuICAgICAqIEBwYXJhbSBtc2dIYXNoIE5PVCBtZXNzYWdlLiBtc2cgbmVlZHMgdG8gYmUgaGFzaGVkIHRvIGBtc2dIYXNoYCwgb3IgdXNlIGBwcmVoYXNoYC5cbiAgICAgKiBAcGFyYW0gcHJpdktleSBwcml2YXRlIGtleVxuICAgICAqIEBwYXJhbSBvcHRzIGxvd1MgZm9yIG5vbi1tYWxsZWFibGUgc2lncy4gZXh0cmFFbnRyb3B5IGZvciBtaXhpbmcgcmFuZG9tbmVzcyBpbnRvIGsuIHByZWhhc2ggd2lsbCBoYXNoIGZpcnN0IGFyZy5cbiAgICAgKiBAcmV0dXJucyBzaWduYXR1cmUgd2l0aCByZWNvdmVyeSBwYXJhbVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNpZ24obXNnSGFzaCwgcHJpdktleSwgb3B0cyA9IGRlZmF1bHRTaWdPcHRzKSB7XG4gICAgICAgIGNvbnN0IHsgc2VlZCwgazJzaWcgfSA9IHByZXBTaWcobXNnSGFzaCwgcHJpdktleSwgb3B0cyk7IC8vIFN0ZXBzIEEsIEQgb2YgUkZDNjk3OSAzLjIuXG4gICAgICAgIGNvbnN0IEMgPSBDVVJWRTtcbiAgICAgICAgY29uc3QgZHJiZyA9IHV0LmNyZWF0ZUhtYWNEcmJnKEMuaGFzaC5vdXRwdXRMZW4sIEMubkJ5dGVMZW5ndGgsIEMuaG1hYyk7XG4gICAgICAgIHJldHVybiBkcmJnKHNlZWQsIGsyc2lnKTsgLy8gU3RlcHMgQiwgQywgRCwgRSwgRiwgR1xuICAgIH1cbiAgICAvLyBFbmFibGUgcHJlY29tcHV0ZXMuIFNsb3dzIGRvd24gZmlyc3QgcHVibGljS2V5IGNvbXB1dGF0aW9uIGJ5IDIwbXMuXG4gICAgUG9pbnQuQkFTRS5fc2V0V2luZG93U2l6ZSg4KTtcbiAgICAvLyB1dGlscy5wcmVjb21wdXRlKDgsIFByb2plY3RpdmVQb2ludC5CQVNFKVxuICAgIC8qKlxuICAgICAqIFZlcmlmaWVzIGEgc2lnbmF0dXJlIGFnYWluc3QgbWVzc2FnZSBoYXNoIGFuZCBwdWJsaWMga2V5LlxuICAgICAqIFJlamVjdHMgbG93UyBzaWduYXR1cmVzIGJ5IGRlZmF1bHQ6IHRvIG92ZXJyaWRlLFxuICAgICAqIHNwZWNpZnkgb3B0aW9uIGB7bG93UzogZmFsc2V9YC4gSW1wbGVtZW50cyBzZWN0aW9uIDQuMS40IGZyb20gaHR0cHM6Ly93d3cuc2VjZy5vcmcvc2VjMS12Mi5wZGY6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiB2ZXJpZnkociwgcywgaCwgUCkgd2hlcmVcbiAgICAgKiAgIFUxID0gaHNeLTEgbW9kIG5cbiAgICAgKiAgIFUyID0gcnNeLTEgbW9kIG5cbiAgICAgKiAgIFIgPSBVMeKLhUcgLSBVMuKLhVBcbiAgICAgKiAgIG1vZChSLngsIG4pID09IHJcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2ZXJpZnkoc2lnbmF0dXJlLCBtc2dIYXNoLCBwdWJsaWNLZXksIG9wdHMgPSBkZWZhdWx0VmVyT3B0cykge1xuICAgICAgICBjb25zdCBzZyA9IHNpZ25hdHVyZTtcbiAgICAgICAgbXNnSGFzaCA9IGVuc3VyZUJ5dGVzKCdtc2dIYXNoJywgbXNnSGFzaCk7XG4gICAgICAgIHB1YmxpY0tleSA9IGVuc3VyZUJ5dGVzKCdwdWJsaWNLZXknLCBwdWJsaWNLZXkpO1xuICAgICAgICBpZiAoJ3N0cmljdCcgaW4gb3B0cylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9ucy5zdHJpY3Qgd2FzIHJlbmFtZWQgdG8gbG93UycpO1xuICAgICAgICBjb25zdCB7IGxvd1MsIHByZWhhc2ggfSA9IG9wdHM7XG4gICAgICAgIGxldCBfc2lnID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgUDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2cgPT09ICdzdHJpbmcnIHx8IHNnIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgICAgIC8vIFNpZ25hdHVyZSBjYW4gYmUgcmVwcmVzZW50ZWQgaW4gMiB3YXlzOiBjb21wYWN0ICgyKm5CeXRlTGVuZ3RoKSAmIERFUiAodmFyaWFibGUtbGVuZ3RoKS5cbiAgICAgICAgICAgICAgICAvLyBTaW5jZSBERVIgY2FuIGFsc28gYmUgMipuQnl0ZUxlbmd0aCBieXRlcywgd2UgY2hlY2sgZm9yIGl0IGZpcnN0LlxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIF9zaWcgPSBTaWduYXR1cmUuZnJvbURFUihzZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChkZXJFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShkZXJFcnJvciBpbnN0YW5jZW9mIERFUi5FcnIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZGVyRXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIF9zaWcgPSBTaWduYXR1cmUuZnJvbUNvbXBhY3Qoc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzZyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHNnLnIgPT09ICdiaWdpbnQnICYmIHR5cGVvZiBzZy5zID09PSAnYmlnaW50Jykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgciwgcyB9ID0gc2c7XG4gICAgICAgICAgICAgICAgX3NpZyA9IG5ldyBTaWduYXR1cmUociwgcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BBUlNFJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBQID0gUG9pbnQuZnJvbUhleChwdWJsaWNLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UgPT09ICdQQVJTRScpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzaWduYXR1cmUgbXVzdCBiZSBTaWduYXR1cmUgaW5zdGFuY2UsIFVpbnQ4QXJyYXkgb3IgaGV4IHN0cmluZ2ApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb3dTICYmIF9zaWcuaGFzSGlnaFMoKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHByZWhhc2gpXG4gICAgICAgICAgICBtc2dIYXNoID0gQ1VSVkUuaGFzaChtc2dIYXNoKTtcbiAgICAgICAgY29uc3QgeyByLCBzIH0gPSBfc2lnO1xuICAgICAgICBjb25zdCBoID0gYml0czJpbnRfbW9kTihtc2dIYXNoKTsgLy8gQ2Fubm90IHVzZSBmaWVsZHMgbWV0aG9kcywgc2luY2UgaXQgaXMgZ3JvdXAgZWxlbWVudFxuICAgICAgICBjb25zdCBpcyA9IGludk4ocyk7IC8vIHNeLTFcbiAgICAgICAgY29uc3QgdTEgPSBtb2ROKGggKiBpcyk7IC8vIHUxID0gaHNeLTEgbW9kIG5cbiAgICAgICAgY29uc3QgdTIgPSBtb2ROKHIgKiBpcyk7IC8vIHUyID0gcnNeLTEgbW9kIG5cbiAgICAgICAgY29uc3QgUiA9IFBvaW50LkJBU0UubXVsdGlwbHlBbmRBZGRVbnNhZmUoUCwgdTEsIHUyKT8udG9BZmZpbmUoKTsgLy8gUiA9IHUx4ouFRyArIHUy4ouFUFxuICAgICAgICBpZiAoIVIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IHYgPSBtb2ROKFIueCk7XG4gICAgICAgIHJldHVybiB2ID09PSByO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBDVVJWRSxcbiAgICAgICAgZ2V0UHVibGljS2V5LFxuICAgICAgICBnZXRTaGFyZWRTZWNyZXQsXG4gICAgICAgIHNpZ24sXG4gICAgICAgIHZlcmlmeSxcbiAgICAgICAgUHJvamVjdGl2ZVBvaW50OiBQb2ludCxcbiAgICAgICAgU2lnbmF0dXJlLFxuICAgICAgICB1dGlscyxcbiAgICB9O1xufVxuLyoqXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgU2hhbGx1ZSBhbmQgdmFuIGRlIFdvZXN0aWpuZSBtZXRob2QgZm9yIGFueSB3ZWllcnN0cmFzcyBjdXJ2ZS5cbiAqIFRPRE86IGNoZWNrIGlmIHRoZXJlIGlzIGEgd2F5IHRvIG1lcmdlIHRoaXMgd2l0aCB1dlJhdGlvIGluIEVkd2FyZHM7IG1vdmUgdG8gbW9kdWxhci5cbiAqIGIgPSBUcnVlIGFuZCB5ID0gc3FydCh1IC8gdikgaWYgKHUgLyB2KSBpcyBzcXVhcmUgaW4gRiwgYW5kXG4gKiBiID0gRmFsc2UgYW5kIHkgPSBzcXJ0KFogKiAodSAvIHYpKSBvdGhlcndpc2UuXG4gKiBAcGFyYW0gRnBcbiAqIEBwYXJhbSBaXG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gU1dVRnBTcXJ0UmF0aW8oRnAsIFopIHtcbiAgICAvLyBHZW5lcmljIGltcGxlbWVudGF0aW9uXG4gICAgY29uc3QgcSA9IEZwLk9SREVSO1xuICAgIGxldCBsID0gXzBuO1xuICAgIGZvciAobGV0IG8gPSBxIC0gXzFuOyBvICUgXzJuID09PSBfMG47IG8gLz0gXzJuKVxuICAgICAgICBsICs9IF8xbjtcbiAgICBjb25zdCBjMSA9IGw7IC8vIDEuIGMxLCB0aGUgbGFyZ2VzdCBpbnRlZ2VyIHN1Y2ggdGhhdCAyXmMxIGRpdmlkZXMgcSAtIDEuXG4gICAgLy8gV2UgbmVlZCAybiAqKiBjMSBhbmQgMm4gKiogKGMxLTEpLiBXZSBjYW4ndCB1c2UgKio7IGJ1dCB3ZSBjYW4gdXNlIDw8LlxuICAgIC8vIDJuICoqIGMxID09IDJuIDw8IChjMS0xKVxuICAgIGNvbnN0IF8ybl9wb3dfYzFfMSA9IF8ybiA8PCAoYzEgLSBfMW4gLSBfMW4pO1xuICAgIGNvbnN0IF8ybl9wb3dfYzEgPSBfMm5fcG93X2MxXzEgKiBfMm47XG4gICAgY29uc3QgYzIgPSAocSAtIF8xbikgLyBfMm5fcG93X2MxOyAvLyAyLiBjMiA9IChxIC0gMSkgLyAoMl5jMSkgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzMgPSAoYzIgLSBfMW4pIC8gXzJuOyAvLyAzLiBjMyA9IChjMiAtIDEpIC8gMiAgICAgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzQgPSBfMm5fcG93X2MxIC0gXzFuOyAvLyA0LiBjNCA9IDJeYzEgLSAxICAgICAgICAgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzUgPSBfMm5fcG93X2MxXzE7IC8vIDUuIGM1ID0gMl4oYzEgLSAxKSAgICAgICAgICAgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzYgPSBGcC5wb3coWiwgYzIpOyAvLyA2LiBjNiA9IFpeYzJcbiAgICBjb25zdCBjNyA9IEZwLnBvdyhaLCAoYzIgKyBfMW4pIC8gXzJuKTsgLy8gNy4gYzcgPSBaXigoYzIgKyAxKSAvIDIpXG4gICAgbGV0IHNxcnRSYXRpbyA9ICh1LCB2KSA9PiB7XG4gICAgICAgIGxldCB0djEgPSBjNjsgLy8gMS4gdHYxID0gYzZcbiAgICAgICAgbGV0IHR2MiA9IEZwLnBvdyh2LCBjNCk7IC8vIDIuIHR2MiA9IHZeYzRcbiAgICAgICAgbGV0IHR2MyA9IEZwLnNxcih0djIpOyAvLyAzLiB0djMgPSB0djJeMlxuICAgICAgICB0djMgPSBGcC5tdWwodHYzLCB2KTsgLy8gNC4gdHYzID0gdHYzICogdlxuICAgICAgICBsZXQgdHY1ID0gRnAubXVsKHUsIHR2Myk7IC8vIDUuIHR2NSA9IHUgKiB0djNcbiAgICAgICAgdHY1ID0gRnAucG93KHR2NSwgYzMpOyAvLyA2LiB0djUgPSB0djVeYzNcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2NSwgdHYyKTsgLy8gNy4gdHY1ID0gdHY1ICogdHYyXG4gICAgICAgIHR2MiA9IEZwLm11bCh0djUsIHYpOyAvLyA4LiB0djIgPSB0djUgKiB2XG4gICAgICAgIHR2MyA9IEZwLm11bCh0djUsIHUpOyAvLyA5LiB0djMgPSB0djUgKiB1XG4gICAgICAgIGxldCB0djQgPSBGcC5tdWwodHYzLCB0djIpOyAvLyAxMC4gdHY0ID0gdHYzICogdHYyXG4gICAgICAgIHR2NSA9IEZwLnBvdyh0djQsIGM1KTsgLy8gMTEuIHR2NSA9IHR2NF5jNVxuICAgICAgICBsZXQgaXNRUiA9IEZwLmVxbCh0djUsIEZwLk9ORSk7IC8vIDEyLiBpc1FSID0gdHY1ID09IDFcbiAgICAgICAgdHYyID0gRnAubXVsKHR2MywgYzcpOyAvLyAxMy4gdHYyID0gdHYzICogYzdcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2NCwgdHYxKTsgLy8gMTQuIHR2NSA9IHR2NCAqIHR2MVxuICAgICAgICB0djMgPSBGcC5jbW92KHR2MiwgdHYzLCBpc1FSKTsgLy8gMTUuIHR2MyA9IENNT1YodHYyLCB0djMsIGlzUVIpXG4gICAgICAgIHR2NCA9IEZwLmNtb3YodHY1LCB0djQsIGlzUVIpOyAvLyAxNi4gdHY0ID0gQ01PVih0djUsIHR2NCwgaXNRUilcbiAgICAgICAgLy8gMTcuIGZvciBpIGluIChjMSwgYzEgLSAxLCAuLi4sIDIpOlxuICAgICAgICBmb3IgKGxldCBpID0gYzE7IGkgPiBfMW47IGktLSkge1xuICAgICAgICAgICAgbGV0IHR2NSA9IGkgLSBfMm47IC8vIDE4LiAgICB0djUgPSBpIC0gMlxuICAgICAgICAgICAgdHY1ID0gXzJuIDw8ICh0djUgLSBfMW4pOyAvLyAxOS4gICAgdHY1ID0gMl50djVcbiAgICAgICAgICAgIGxldCB0dnY1ID0gRnAucG93KHR2NCwgdHY1KTsgLy8gMjAuICAgIHR2NSA9IHR2NF50djVcbiAgICAgICAgICAgIGNvbnN0IGUxID0gRnAuZXFsKHR2djUsIEZwLk9ORSk7IC8vIDIxLiAgICBlMSA9IHR2NSA9PSAxXG4gICAgICAgICAgICB0djIgPSBGcC5tdWwodHYzLCB0djEpOyAvLyAyMi4gICAgdHYyID0gdHYzICogdHYxXG4gICAgICAgICAgICB0djEgPSBGcC5tdWwodHYxLCB0djEpOyAvLyAyMy4gICAgdHYxID0gdHYxICogdHYxXG4gICAgICAgICAgICB0dnY1ID0gRnAubXVsKHR2NCwgdHYxKTsgLy8gMjQuICAgIHR2NSA9IHR2NCAqIHR2MVxuICAgICAgICAgICAgdHYzID0gRnAuY21vdih0djIsIHR2MywgZTEpOyAvLyAyNS4gICAgdHYzID0gQ01PVih0djIsIHR2MywgZTEpXG4gICAgICAgICAgICB0djQgPSBGcC5jbW92KHR2djUsIHR2NCwgZTEpOyAvLyAyNi4gICAgdHY0ID0gQ01PVih0djUsIHR2NCwgZTEpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogaXNRUiwgdmFsdWU6IHR2MyB9O1xuICAgIH07XG4gICAgaWYgKEZwLk9SREVSICUgXzRuID09PSBfM24pIHtcbiAgICAgICAgLy8gc3FydF9yYXRpb18zbW9kNCh1LCB2KVxuICAgICAgICBjb25zdCBjMSA9IChGcC5PUkRFUiAtIF8zbikgLyBfNG47IC8vIDEuIGMxID0gKHEgLSAzKSAvIDQgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgICAgIGNvbnN0IGMyID0gRnAuc3FydChGcC5uZWcoWikpOyAvLyAyLiBjMiA9IHNxcnQoLVopXG4gICAgICAgIHNxcnRSYXRpbyA9ICh1LCB2KSA9PiB7XG4gICAgICAgICAgICBsZXQgdHYxID0gRnAuc3FyKHYpOyAvLyAxLiB0djEgPSB2XjJcbiAgICAgICAgICAgIGNvbnN0IHR2MiA9IEZwLm11bCh1LCB2KTsgLy8gMi4gdHYyID0gdSAqIHZcbiAgICAgICAgICAgIHR2MSA9IEZwLm11bCh0djEsIHR2Mik7IC8vIDMuIHR2MSA9IHR2MSAqIHR2MlxuICAgICAgICAgICAgbGV0IHkxID0gRnAucG93KHR2MSwgYzEpOyAvLyA0LiB5MSA9IHR2MV5jMVxuICAgICAgICAgICAgeTEgPSBGcC5tdWwoeTEsIHR2Mik7IC8vIDUuIHkxID0geTEgKiB0djJcbiAgICAgICAgICAgIGNvbnN0IHkyID0gRnAubXVsKHkxLCBjMik7IC8vIDYuIHkyID0geTEgKiBjMlxuICAgICAgICAgICAgY29uc3QgdHYzID0gRnAubXVsKEZwLnNxcih5MSksIHYpOyAvLyA3LiB0djMgPSB5MV4yOyA4LiB0djMgPSB0djMgKiB2XG4gICAgICAgICAgICBjb25zdCBpc1FSID0gRnAuZXFsKHR2MywgdSk7IC8vIDkuIGlzUVIgPSB0djMgPT0gdVxuICAgICAgICAgICAgbGV0IHkgPSBGcC5jbW92KHkyLCB5MSwgaXNRUik7IC8vIDEwLiB5ID0gQ01PVih5MiwgeTEsIGlzUVIpXG4gICAgICAgICAgICByZXR1cm4geyBpc1ZhbGlkOiBpc1FSLCB2YWx1ZTogeSB9OyAvLyAxMS4gcmV0dXJuIChpc1FSLCB5KSBpc1FSID8geSA6IHkqYzJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gTm8gY3VydmVzIHVzZXMgdGhhdFxuICAgIC8vIGlmIChGcC5PUkRFUiAlIF84biA9PT0gXzVuKSAvLyBzcXJ0X3JhdGlvXzVtb2Q4XG4gICAgcmV0dXJuIHNxcnRSYXRpbztcbn1cbi8qKlxuICogU2ltcGxpZmllZCBTaGFsbHVlLXZhbiBkZSBXb2VzdGlqbmUtVWxhcyBNZXRob2RcbiAqIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNi42LjJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcFRvQ3VydmVTaW1wbGVTV1UoRnAsIG9wdHMpIHtcbiAgICBtb2QudmFsaWRhdGVGaWVsZChGcCk7XG4gICAgaWYgKCFGcC5pc1ZhbGlkKG9wdHMuQSkgfHwgIUZwLmlzVmFsaWQob3B0cy5CKSB8fCAhRnAuaXNWYWxpZChvcHRzLlopKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcFRvQ3VydmVTaW1wbGVTV1U6IGludmFsaWQgb3B0cycpO1xuICAgIGNvbnN0IHNxcnRSYXRpbyA9IFNXVUZwU3FydFJhdGlvKEZwLCBvcHRzLlopO1xuICAgIGlmICghRnAuaXNPZGQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRnAuaXNPZGQgaXMgbm90IGltcGxlbWVudGVkIScpO1xuICAgIC8vIElucHV0OiB1LCBhbiBlbGVtZW50IG9mIEYuXG4gICAgLy8gT3V0cHV0OiAoeCwgeSksIGEgcG9pbnQgb24gRS5cbiAgICByZXR1cm4gKHUpID0+IHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGxldCB0djEsIHR2MiwgdHYzLCB0djQsIHR2NSwgdHY2LCB4LCB5O1xuICAgICAgICB0djEgPSBGcC5zcXIodSk7IC8vIDEuICB0djEgPSB1XjJcbiAgICAgICAgdHYxID0gRnAubXVsKHR2MSwgb3B0cy5aKTsgLy8gMi4gIHR2MSA9IFogKiB0djFcbiAgICAgICAgdHYyID0gRnAuc3FyKHR2MSk7IC8vIDMuICB0djIgPSB0djFeMlxuICAgICAgICB0djIgPSBGcC5hZGQodHYyLCB0djEpOyAvLyA0LiAgdHYyID0gdHYyICsgdHYxXG4gICAgICAgIHR2MyA9IEZwLmFkZCh0djIsIEZwLk9ORSk7IC8vIDUuICB0djMgPSB0djIgKyAxXG4gICAgICAgIHR2MyA9IEZwLm11bCh0djMsIG9wdHMuQik7IC8vIDYuICB0djMgPSBCICogdHYzXG4gICAgICAgIHR2NCA9IEZwLmNtb3Yob3B0cy5aLCBGcC5uZWcodHYyKSwgIUZwLmVxbCh0djIsIEZwLlpFUk8pKTsgLy8gNy4gIHR2NCA9IENNT1YoWiwgLXR2MiwgdHYyICE9IDApXG4gICAgICAgIHR2NCA9IEZwLm11bCh0djQsIG9wdHMuQSk7IC8vIDguICB0djQgPSBBICogdHY0XG4gICAgICAgIHR2MiA9IEZwLnNxcih0djMpOyAvLyA5LiAgdHYyID0gdHYzXjJcbiAgICAgICAgdHY2ID0gRnAuc3FyKHR2NCk7IC8vIDEwLiB0djYgPSB0djReMlxuICAgICAgICB0djUgPSBGcC5tdWwodHY2LCBvcHRzLkEpOyAvLyAxMS4gdHY1ID0gQSAqIHR2NlxuICAgICAgICB0djIgPSBGcC5hZGQodHYyLCB0djUpOyAvLyAxMi4gdHYyID0gdHYyICsgdHY1XG4gICAgICAgIHR2MiA9IEZwLm11bCh0djIsIHR2Myk7IC8vIDEzLiB0djIgPSB0djIgKiB0djNcbiAgICAgICAgdHY2ID0gRnAubXVsKHR2NiwgdHY0KTsgLy8gMTQuIHR2NiA9IHR2NiAqIHR2NFxuICAgICAgICB0djUgPSBGcC5tdWwodHY2LCBvcHRzLkIpOyAvLyAxNS4gdHY1ID0gQiAqIHR2NlxuICAgICAgICB0djIgPSBGcC5hZGQodHYyLCB0djUpOyAvLyAxNi4gdHYyID0gdHYyICsgdHY1XG4gICAgICAgIHggPSBGcC5tdWwodHYxLCB0djMpOyAvLyAxNy4gICB4ID0gdHYxICogdHYzXG4gICAgICAgIGNvbnN0IHsgaXNWYWxpZCwgdmFsdWUgfSA9IHNxcnRSYXRpbyh0djIsIHR2Nik7IC8vIDE4LiAoaXNfZ3gxX3NxdWFyZSwgeTEpID0gc3FydF9yYXRpbyh0djIsIHR2NilcbiAgICAgICAgeSA9IEZwLm11bCh0djEsIHUpOyAvLyAxOS4gICB5ID0gdHYxICogdSAgLT4gWiAqIHVeMyAqIHkxXG4gICAgICAgIHkgPSBGcC5tdWwoeSwgdmFsdWUpOyAvLyAyMC4gICB5ID0geSAqIHkxXG4gICAgICAgIHggPSBGcC5jbW92KHgsIHR2MywgaXNWYWxpZCk7IC8vIDIxLiAgIHggPSBDTU9WKHgsIHR2MywgaXNfZ3gxX3NxdWFyZSlcbiAgICAgICAgeSA9IEZwLmNtb3YoeSwgdmFsdWUsIGlzVmFsaWQpOyAvLyAyMi4gICB5ID0gQ01PVih5LCB5MSwgaXNfZ3gxX3NxdWFyZSlcbiAgICAgICAgY29uc3QgZTEgPSBGcC5pc09kZCh1KSA9PT0gRnAuaXNPZGQoeSk7IC8vIDIzLiAgZTEgPSBzZ24wKHUpID09IHNnbjAoeSlcbiAgICAgICAgeSA9IEZwLmNtb3YoRnAubmVnKHkpLCB5LCBlMSk7IC8vIDI0LiAgIHkgPSBDTU9WKC15LCB5LCBlMSlcbiAgICAgICAgeCA9IEZwLmRpdih4LCB0djQpOyAvLyAyNS4gICB4ID0geCAvIHR2NFxuICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdlaWVyc3RyYXNzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/weierstrass.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/secp256k1.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/secp256k1.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encodeToCurve: () => (/* binding */ encodeToCurve),\n/* harmony export */   hashToCurve: () => (/* binding */ hashToCurve),\n/* harmony export */   schnorr: () => (/* binding */ schnorr),\n/* harmony export */   secp256k1: () => (/* binding */ secp256k1)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/utils */ \"(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract/modular.js */ \"(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/* harmony import */ var _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./abstract/utils.js */ \"(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./abstract/hash-to-curve.js */ \"(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/hash-to-curve.js\");\n/* harmony import */ var _shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_shortw_utils.js */ \"(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/_shortw_utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\n\n\n\n\n\nconst secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');\nconst secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst divNearest = (a, b) => (a + b / _2n) / b;\n/**\n * ‚àön = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */\nfunction sqrtMod(y) {\n    const P = secp256k1P;\n    // prettier-ignore\n    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n    // prettier-ignore\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n    const b2 = (y * y * y) % P; // x^3, 11\n    const b3 = (b2 * b2 * y) % P; // x^7\n    const b6 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b3, _3n, P) * b3) % P;\n    const b9 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b6, _3n, P) * b3) % P;\n    const b11 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b9, _2n, P) * b2) % P;\n    const b22 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b11, _11n, P) * b11) % P;\n    const b44 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b22, _22n, P) * b22) % P;\n    const b88 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b44, _44n, P) * b44) % P;\n    const b176 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b88, _88n, P) * b88) % P;\n    const b220 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b176, _44n, P) * b44) % P;\n    const b223 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b220, _3n, P) * b3) % P;\n    const t1 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b223, _23n, P) * b22) % P;\n    const t2 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(t1, _6n, P) * b2) % P;\n    const root = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(t2, _2n, P);\n    if (!Fp.eql(Fp.sqr(root), y))\n        throw new Error('Cannot find square root');\n    return root;\n}\nconst Fp = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field)(secp256k1P, undefined, undefined, { sqrt: sqrtMod });\nconst secp256k1 = (0,_shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__.createCurve)({\n    a: BigInt(0),\n    b: BigInt(7),\n    Fp,\n    n: secp256k1N,\n    // Base point (x, y) aka generator point\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    h: BigInt(1),\n    lowS: true,\n    /**\n     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066\n     */\n    endo: {\n        beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n        splitScalar: (k) => {\n            const n = secp256k1N;\n            const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n            const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n            const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n            const b2 = a1;\n            const POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)\n            const c1 = divNearest(b2 * k, n);\n            const c2 = divNearest(-b1 * k, n);\n            let k1 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(k - c1 * a1 - c2 * a2, n);\n            let k2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(-c1 * b1 - c2 * b2, n);\n            const k1neg = k1 > POW_2_128;\n            const k2neg = k2 > POW_2_128;\n            if (k1neg)\n                k1 = n - k1;\n            if (k2neg)\n                k2 = n - k2;\n            if (k1 > POW_2_128 || k2 > POW_2_128) {\n                throw new Error('splitScalar: Endomorphism failed, k=' + k);\n            }\n            return { k1neg, k1, k2neg, k2 };\n        },\n    },\n}, _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256);\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\nconst _0n = BigInt(0);\nconst fe = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1P;\nconst ge = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1N;\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\nconst TAGGED_HASH_PREFIXES = {};\nfunction taggedHash(tag, ...messages) {\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n        const tagH = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256)(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n        tagP = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(tagH, tagH);\n        TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    return (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256)((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(tagP, ...messages));\n}\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point) => point.toRawBytes(true).slice(1);\nconst numTo32b = (n) => (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.numberToBytesBE)(n, 32);\nconst modP = (x) => (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x, secp256k1P);\nconst modN = (x) => (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x, secp256k1N);\nconst Point = secp256k1.ProjectivePoint;\nconst GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv) {\n    let d_ = secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\n    let p = Point.fromPrivateKey(d_); // P = d'‚ãÖG; 0 < d' < n check is done inside\n    const scalar = p.hasEvenY() ? d_ : modN(-d_);\n    return { scalar: scalar, bytes: pointToBytes(p) };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */\nfunction lift_x(x) {\n    if (!fe(x))\n        throw new Error('bad x: need 0 < x < p'); // Fail if x ‚â• p.\n    const xx = modP(x * x);\n    const c = modP(xx * x + BigInt(7)); // Let c = x¬≥ + 7 mod p.\n    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n    if (y % _2n !== _0n)\n        y = modP(-y); // Return the unique point P such that x(P) = x and\n    const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n    p.assertValidity();\n    return p;\n}\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */\nfunction challenge(...args) {\n    return modN((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(taggedHash('BIP0340/challenge', ...args)));\n}\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */\nfunction schnorrGetPublicKey(privateKey) {\n    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'‚â•n. Ret bytes(d'‚ãÖG)\n}\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */\nfunction schnorrSign(message, privateKey, auxRand = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__.randomBytes)(32)) {\n    const m = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('message', message);\n    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\n    const a = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array\n    const t = numTo32b(d ^ (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n    const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n    const k_ = modN((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(rand)); // Let k' = int(rand) mod n\n    if (k_ === _0n)\n        throw new Error('sign failed: k is zero'); // Fail if k' = 0.\n    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'‚ãÖG.\n    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n    sig.set(rx, 0);\n    sig.set(numTo32b(modN(k + e * d)), 32);\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n    if (!schnorrVerify(sig, m, px))\n        throw new Error('sign: Invalid signature produced');\n    return sig;\n}\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */\nfunction schnorrVerify(signature, message, publicKey) {\n    const sig = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('signature', signature, 64);\n    const m = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('message', message);\n    const pub = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('publicKey', publicKey, 32);\n    try {\n        const P = lift_x((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(pub)); // P = lift_x(int(pk)); fail if that fails\n        const r = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r ‚â• p.\n        if (!fe(r))\n            return false;\n        const s = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s ‚â• n.\n        if (!ge(s))\n            return false;\n        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n        const R = GmulAdd(P, s, modN(-e)); // R = s‚ãÖG - e‚ãÖP\n        if (!R || !R.hasEvenY() || R.toAffine().x !== r)\n            return false; // -eP == (n-e)P\n        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R) ‚â† r.\n    }\n    catch (error) {\n        return false;\n    }\n}\nconst schnorr = /* @__PURE__ */ (() => ({\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n    utils: {\n        randomPrivateKey: secp256k1.utils.randomPrivateKey,\n        lift_x,\n        pointToBytes,\n        numberToBytesBE: _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.numberToBytesBE,\n        bytesToNumberBE: _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE,\n        taggedHash,\n        mod: _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod,\n    },\n}))();\nconst isoMap = /* @__PURE__ */ (() => (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.isogenyMap)(Fp, [\n    // xNum\n    [\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',\n        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',\n        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',\n    ],\n    // xDen\n    [\n        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',\n        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n    // yNum\n    [\n        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',\n        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',\n        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',\n        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',\n    ],\n    // yDen\n    [\n        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',\n        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',\n        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n].map((i) => i.map((j) => BigInt(j)))))();\nconst mapSWU = /* @__PURE__ */ (() => (0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_6__.mapToCurveSimpleSWU)(Fp, {\n    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),\n    B: BigInt('1771'),\n    Z: Fp.create(BigInt('-11')),\n}))();\nconst htf = /* @__PURE__ */ (() => (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.createHasher)(secp256k1.ProjectivePoint, (scalars) => {\n    const { x, y } = mapSWU(Fp.create(scalars[0]));\n    return isoMap(x, y);\n}, {\n    DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',\n    encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',\n    p: Fp.ORDER,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256,\n}))();\nconst hashToCurve = /* @__PURE__ */ (() => htf.hashToCurve)();\nconst encodeToCurve = /* @__PURE__ */ (() => htf.encodeToCurve)();\n//# sourceMappingURL=secp256k1.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9zdHItZGV2LWtpdC9uZGsvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9zZWNwMjU2azEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUM4QztBQUNJO0FBQ087QUFDTztBQUNpQztBQUMxQjtBQUN0QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsa0NBQWtDO0FBQ2xDLGdCQUFnQiwwREFBSTtBQUNwQixnQkFBZ0IsMERBQUk7QUFDcEIsaUJBQWlCLDBEQUFJO0FBQ3JCLGlCQUFpQiwwREFBSTtBQUNyQixpQkFBaUIsMERBQUk7QUFDckIsaUJBQWlCLDBEQUFJO0FBQ3JCLGtCQUFrQiwwREFBSTtBQUN0QixrQkFBa0IsMERBQUk7QUFDdEIsa0JBQWtCLDBEQUFJO0FBQ3RCLGdCQUFnQiwwREFBSTtBQUNwQixnQkFBZ0IsMERBQUk7QUFDcEIsaUJBQWlCLDBEQUFJO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywyREFBSyxxQ0FBcUMsZUFBZTtBQUM3RCxrQkFBa0IsNkRBQVc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RTtBQUM3RTtBQUNBO0FBQ0EscUJBQXFCLHlEQUFHO0FBQ3hCLHFCQUFxQix5REFBRztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsU0FBUztBQUNULEtBQUs7QUFDTCxDQUFDLEVBQUUsd0RBQU07QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw0REFBTTtBQUMzQixlQUFlLCtEQUFXO0FBQzFCO0FBQ0E7QUFDQSxXQUFXLDREQUFNLENBQUMsK0RBQVc7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1FQUFlO0FBQ3ZDLG9CQUFvQix5REFBRztBQUN2QixvQkFBb0IseURBQUc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Qsc0NBQXNDLGFBQWE7QUFDbkQ7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQSx3Q0FBd0M7QUFDeEMsd0JBQXdCO0FBQ3hCO0FBQ0Esc0JBQXNCO0FBQ3RCLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtRUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsZ0VBQVc7QUFDL0QsY0FBYywrREFBVztBQUN6QixZQUFZLHVCQUF1QixtQ0FBbUM7QUFDdEUsY0FBYywrREFBVywwQkFBMEI7QUFDbkQsMkJBQTJCLG1FQUFlLGlDQUFpQztBQUMzRSx3REFBd0Q7QUFDeEQsb0JBQW9CLG1FQUFlLFNBQVM7QUFDNUM7QUFDQSxtREFBbUQ7QUFDbkQsWUFBWSx1QkFBdUIsMkJBQTJCO0FBQzlELG9DQUFvQztBQUNwQyxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtEQUFXO0FBQzNCLGNBQWMsK0RBQVc7QUFDekIsZ0JBQWdCLCtEQUFXO0FBQzNCO0FBQ0EseUJBQXlCLG1FQUFlLFFBQVEsd0JBQXdCO0FBQ3hFLGtCQUFrQixtRUFBZSx1QkFBdUIsMkJBQTJCO0FBQ25GO0FBQ0E7QUFDQSxrQkFBa0IsbUVBQWUsd0JBQXdCLDRCQUE0QjtBQUNyRjtBQUNBO0FBQ0EsOERBQThEO0FBQzlELDJDQUEyQztBQUMzQztBQUNBLDBCQUEwQjtBQUMxQixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsdUJBQXVCO0FBQ3ZCO0FBQ0EsV0FBVztBQUNYLEtBQUs7QUFDTCxDQUFDO0FBQ0Qsc0NBQXNDLHNFQUFVO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDZFQUFtQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsbUNBQW1DLHdFQUFZO0FBQy9DLFlBQVksT0FBTztBQUNuQjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHdEQUFNO0FBQ2hCLENBQUM7QUFDTTtBQUNBO0FBQ1AiLCJzb3VyY2VzIjpbIi9ob21lL2xmZy9HaXQvTWFkdHJpcHMvbm9kZV9tb2R1bGVzL0Bub3N0ci1kZXYta2l0L25kay9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL3NlY3AyNTZrMS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5pbXBvcnQgeyBzaGEyNTYgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3NoYTI1Nic7XG5pbXBvcnQgeyByYW5kb21CeXRlcyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvdXRpbHMnO1xuaW1wb3J0IHsgRmllbGQsIG1vZCwgcG93MiB9IGZyb20gJy4vYWJzdHJhY3QvbW9kdWxhci5qcyc7XG5pbXBvcnQgeyBtYXBUb0N1cnZlU2ltcGxlU1dVIH0gZnJvbSAnLi9hYnN0cmFjdC93ZWllcnN0cmFzcy5qcyc7XG5pbXBvcnQgeyBieXRlc1RvTnVtYmVyQkUsIGNvbmNhdEJ5dGVzLCBlbnN1cmVCeXRlcywgbnVtYmVyVG9CeXRlc0JFIH0gZnJvbSAnLi9hYnN0cmFjdC91dGlscy5qcyc7XG5pbXBvcnQgeyBjcmVhdGVIYXNoZXIsIGlzb2dlbnlNYXAgfSBmcm9tICcuL2Fic3RyYWN0L2hhc2gtdG8tY3VydmUuanMnO1xuaW1wb3J0IHsgY3JlYXRlQ3VydmUgfSBmcm9tICcuL19zaG9ydHdfdXRpbHMuanMnO1xuY29uc3Qgc2VjcDI1NmsxUCA9IEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWZmZmZmYzJmJyk7XG5jb25zdCBzZWNwMjU2azFOID0gQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlYmFhZWRjZTZhZjQ4YTAzYmJmZDI1ZThjZDAzNjQxNDEnKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbmNvbnN0IF8ybiA9IEJpZ0ludCgyKTtcbmNvbnN0IGRpdk5lYXJlc3QgPSAoYSwgYikgPT4gKGEgKyBiIC8gXzJuKSAvIGI7XG4vKipcbiAqIOKImm4gPSBuXigocCsxKS80KSBmb3IgZmllbGRzIHAgPSAzIG1vZCA0LiBXZSB1bndyYXAgdGhlIGxvb3AgYW5kIG11bHRpcGx5IGJpdC1ieS1iaXQuXG4gKiAoUCsxbi80bikudG9TdHJpbmcoMikgd291bGQgcHJvZHVjZSBiaXRzIFsyMjN4IDEsIDAsIDIyeCAxLCA0eCAwLCAxMSwgMDBdXG4gKi9cbmZ1bmN0aW9uIHNxcnRNb2QoeSkge1xuICAgIGNvbnN0IFAgPSBzZWNwMjU2azFQO1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGNvbnN0IF8zbiA9IEJpZ0ludCgzKSwgXzZuID0gQmlnSW50KDYpLCBfMTFuID0gQmlnSW50KDExKSwgXzIybiA9IEJpZ0ludCgyMik7XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgY29uc3QgXzIzbiA9IEJpZ0ludCgyMyksIF80NG4gPSBCaWdJbnQoNDQpLCBfODhuID0gQmlnSW50KDg4KTtcbiAgICBjb25zdCBiMiA9ICh5ICogeSAqIHkpICUgUDsgLy8geF4zLCAxMVxuICAgIGNvbnN0IGIzID0gKGIyICogYjIgKiB5KSAlIFA7IC8vIHheN1xuICAgIGNvbnN0IGI2ID0gKHBvdzIoYjMsIF8zbiwgUCkgKiBiMykgJSBQO1xuICAgIGNvbnN0IGI5ID0gKHBvdzIoYjYsIF8zbiwgUCkgKiBiMykgJSBQO1xuICAgIGNvbnN0IGIxMSA9IChwb3cyKGI5LCBfMm4sIFApICogYjIpICUgUDtcbiAgICBjb25zdCBiMjIgPSAocG93MihiMTEsIF8xMW4sIFApICogYjExKSAlIFA7XG4gICAgY29uc3QgYjQ0ID0gKHBvdzIoYjIyLCBfMjJuLCBQKSAqIGIyMikgJSBQO1xuICAgIGNvbnN0IGI4OCA9IChwb3cyKGI0NCwgXzQ0biwgUCkgKiBiNDQpICUgUDtcbiAgICBjb25zdCBiMTc2ID0gKHBvdzIoYjg4LCBfODhuLCBQKSAqIGI4OCkgJSBQO1xuICAgIGNvbnN0IGIyMjAgPSAocG93MihiMTc2LCBfNDRuLCBQKSAqIGI0NCkgJSBQO1xuICAgIGNvbnN0IGIyMjMgPSAocG93MihiMjIwLCBfM24sIFApICogYjMpICUgUDtcbiAgICBjb25zdCB0MSA9IChwb3cyKGIyMjMsIF8yM24sIFApICogYjIyKSAlIFA7XG4gICAgY29uc3QgdDIgPSAocG93Mih0MSwgXzZuLCBQKSAqIGIyKSAlIFA7XG4gICAgY29uc3Qgcm9vdCA9IHBvdzIodDIsIF8ybiwgUCk7XG4gICAgaWYgKCFGcC5lcWwoRnAuc3FyKHJvb3QpLCB5KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgIHJldHVybiByb290O1xufVxuY29uc3QgRnAgPSBGaWVsZChzZWNwMjU2azFQLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgeyBzcXJ0OiBzcXJ0TW9kIH0pO1xuZXhwb3J0IGNvbnN0IHNlY3AyNTZrMSA9IGNyZWF0ZUN1cnZlKHtcbiAgICBhOiBCaWdJbnQoMCksXG4gICAgYjogQmlnSW50KDcpLFxuICAgIEZwLFxuICAgIG46IHNlY3AyNTZrMU4sXG4gICAgLy8gQmFzZSBwb2ludCAoeCwgeSkgYWthIGdlbmVyYXRvciBwb2ludFxuICAgIEd4OiBCaWdJbnQoJzU1MDY2MjYzMDIyMjc3MzQzNjY5NTc4NzE4ODk1MTY4NTM0MzI2MjUwNjAzNDUzNzc3NTk0MTc1NTAwMTg3MzYwMzg5MTE2NzI5MjQwJyksXG4gICAgR3k6IEJpZ0ludCgnMzI2NzA1MTAwMjA3NTg4MTY5NzgwODMwODUxMzA1MDcwNDMxODQ0NzEyNzMzODA2NTkyNDMyNzU5Mzg5MDQzMzU3NTczMzc0ODI0MjQnKSxcbiAgICBoOiBCaWdJbnQoMSksXG4gICAgbG93UzogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBzZWNwMjU2azEgYmVsb25ncyB0byBLb2JsaXR6IGN1cnZlczogaXQgaGFzIGVmZmljaWVudGx5IGNvbXB1dGFibGUgZW5kb21vcnBoaXNtLlxuICAgICAqIEVuZG9tb3JwaGlzbSB1c2VzIDJ4IGxlc3MgUkFNLCBzcGVlZHMgdXAgcHJlY29tcHV0YXRpb24gYnkgMnggYW5kIEVDREggLyBrZXkgcmVjb3ZlcnkgYnkgMjAlLlxuICAgICAqIEZvciBwcmVjb21wdXRlZCB3TkFGIGl0IHRyYWRlcyBvZmYgMS8yIGluaXQgdGltZSAmIDEvMyByYW0gZm9yIDIwJSBwZXJmIGhpdC5cbiAgICAgKiBFeHBsYW5hdGlvbjogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vcGF1bG1pbGxyL2ViNjcwODA2NzkzZTg0ZGY2MjhhN2M0MzRhODczMDY2XG4gICAgICovXG4gICAgZW5kbzoge1xuICAgICAgICBiZXRhOiBCaWdJbnQoJzB4N2FlOTZhMmI2NTdjMDcxMDZlNjQ0NzllYWMzNDM0ZTk5Y2YwNDk3NTEyZjU4OTk1YzEzOTZjMjg3MTk1MDFlZScpLFxuICAgICAgICBzcGxpdFNjYWxhcjogKGspID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBzZWNwMjU2azFOO1xuICAgICAgICAgICAgY29uc3QgYTEgPSBCaWdJbnQoJzB4MzA4NmQyMjFhN2Q0NmJjZGU4NmM5MGU0OTI4NGViMTUnKTtcbiAgICAgICAgICAgIGNvbnN0IGIxID0gLV8xbiAqIEJpZ0ludCgnMHhlNDQzN2VkNjAxMGU4ODI4NmY1NDdmYTkwYWJmZTRjMycpO1xuICAgICAgICAgICAgY29uc3QgYTIgPSBCaWdJbnQoJzB4MTE0Y2E1MGY3YThlMmYzZjY1N2MxMTA4ZDlkNDRjZmQ4Jyk7XG4gICAgICAgICAgICBjb25zdCBiMiA9IGExO1xuICAgICAgICAgICAgY29uc3QgUE9XXzJfMTI4ID0gQmlnSW50KCcweDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcpOyAvLyAoMm4qKjEyOG4pLnRvU3RyaW5nKDE2KVxuICAgICAgICAgICAgY29uc3QgYzEgPSBkaXZOZWFyZXN0KGIyICogaywgbik7XG4gICAgICAgICAgICBjb25zdCBjMiA9IGRpdk5lYXJlc3QoLWIxICogaywgbik7XG4gICAgICAgICAgICBsZXQgazEgPSBtb2QoayAtIGMxICogYTEgLSBjMiAqIGEyLCBuKTtcbiAgICAgICAgICAgIGxldCBrMiA9IG1vZCgtYzEgKiBiMSAtIGMyICogYjIsIG4pO1xuICAgICAgICAgICAgY29uc3QgazFuZWcgPSBrMSA+IFBPV18yXzEyODtcbiAgICAgICAgICAgIGNvbnN0IGsybmVnID0gazIgPiBQT1dfMl8xMjg7XG4gICAgICAgICAgICBpZiAoazFuZWcpXG4gICAgICAgICAgICAgICAgazEgPSBuIC0gazE7XG4gICAgICAgICAgICBpZiAoazJuZWcpXG4gICAgICAgICAgICAgICAgazIgPSBuIC0gazI7XG4gICAgICAgICAgICBpZiAoazEgPiBQT1dfMl8xMjggfHwgazIgPiBQT1dfMl8xMjgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NwbGl0U2NhbGFyOiBFbmRvbW9ycGhpc20gZmFpbGVkLCBrPScgKyBrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGsxbmVnLCBrMSwgazJuZWcsIGsyIH07XG4gICAgICAgIH0sXG4gICAgfSxcbn0sIHNoYTI1Nik7XG4vLyBTY2hub3JyIHNpZ25hdHVyZXMgYXJlIHN1cGVyaW9yIHRvIEVDRFNBIGZyb20gYWJvdmUuIEJlbG93IGlzIFNjaG5vcnItc3BlY2lmaWMgQklQMDM0MCBjb2RlLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDM0MC5tZWRpYXdpa2lcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IGZlID0gKHgpID0+IHR5cGVvZiB4ID09PSAnYmlnaW50JyAmJiBfMG4gPCB4ICYmIHggPCBzZWNwMjU2azFQO1xuY29uc3QgZ2UgPSAoeCkgPT4gdHlwZW9mIHggPT09ICdiaWdpbnQnICYmIF8wbiA8IHggJiYgeCA8IHNlY3AyNTZrMU47XG4vKiogQW4gb2JqZWN0IG1hcHBpbmcgdGFncyB0byB0aGVpciB0YWdnZWQgaGFzaCBwcmVmaXggb2YgW1NIQTI1Nih0YWcpIHwgU0hBMjU2KHRhZyldICovXG5jb25zdCBUQUdHRURfSEFTSF9QUkVGSVhFUyA9IHt9O1xuZnVuY3Rpb24gdGFnZ2VkSGFzaCh0YWcsIC4uLm1lc3NhZ2VzKSB7XG4gICAgbGV0IHRhZ1AgPSBUQUdHRURfSEFTSF9QUkVGSVhFU1t0YWddO1xuICAgIGlmICh0YWdQID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgdGFnSCA9IHNoYTI1NihVaW50OEFycmF5LmZyb20odGFnLCAoYykgPT4gYy5jaGFyQ29kZUF0KDApKSk7XG4gICAgICAgIHRhZ1AgPSBjb25jYXRCeXRlcyh0YWdILCB0YWdIKTtcbiAgICAgICAgVEFHR0VEX0hBU0hfUFJFRklYRVNbdGFnXSA9IHRhZ1A7XG4gICAgfVxuICAgIHJldHVybiBzaGEyNTYoY29uY2F0Qnl0ZXModGFnUCwgLi4ubWVzc2FnZXMpKTtcbn1cbi8vIEVDRFNBIGNvbXBhY3QgcG9pbnRzIGFyZSAzMy1ieXRlLiBTY2hub3JyIGlzIDMyOiB3ZSBzdHJpcCBmaXJzdCBieXRlIDB4MDIgb3IgMHgwM1xuY29uc3QgcG9pbnRUb0J5dGVzID0gKHBvaW50KSA9PiBwb2ludC50b1Jhd0J5dGVzKHRydWUpLnNsaWNlKDEpO1xuY29uc3QgbnVtVG8zMmIgPSAobikgPT4gbnVtYmVyVG9CeXRlc0JFKG4sIDMyKTtcbmNvbnN0IG1vZFAgPSAoeCkgPT4gbW9kKHgsIHNlY3AyNTZrMVApO1xuY29uc3QgbW9kTiA9ICh4KSA9PiBtb2QoeCwgc2VjcDI1NmsxTik7XG5jb25zdCBQb2ludCA9IHNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQ7XG5jb25zdCBHbXVsQWRkID0gKFEsIGEsIGIpID0+IFBvaW50LkJBU0UubXVsdGlwbHlBbmRBZGRVbnNhZmUoUSwgYSwgYik7XG4vLyBDYWxjdWxhdGUgcG9pbnQsIHNjYWxhciBhbmQgYnl0ZXNcbmZ1bmN0aW9uIHNjaG5vcnJHZXRFeHRQdWJLZXkocHJpdikge1xuICAgIGxldCBkXyA9IHNlY3AyNTZrMS51dGlscy5ub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXYpOyAvLyBzYW1lIG1ldGhvZCBleGVjdXRlZCBpbiBmcm9tUHJpdmF0ZUtleVxuICAgIGxldCBwID0gUG9pbnQuZnJvbVByaXZhdGVLZXkoZF8pOyAvLyBQID0gZCfii4VHOyAwIDwgZCcgPCBuIGNoZWNrIGlzIGRvbmUgaW5zaWRlXG4gICAgY29uc3Qgc2NhbGFyID0gcC5oYXNFdmVuWSgpID8gZF8gOiBtb2ROKC1kXyk7XG4gICAgcmV0dXJuIHsgc2NhbGFyOiBzY2FsYXIsIGJ5dGVzOiBwb2ludFRvQnl0ZXMocCkgfTtcbn1cbi8qKlxuICogbGlmdF94IGZyb20gQklQMzQwLiBDb252ZXJ0IDMyLWJ5dGUgeCBjb29yZGluYXRlIHRvIGVsbGlwdGljIGN1cnZlIHBvaW50LlxuICogQHJldHVybnMgdmFsaWQgcG9pbnQgY2hlY2tlZCBmb3IgYmVpbmcgb24tY3VydmVcbiAqL1xuZnVuY3Rpb24gbGlmdF94KHgpIHtcbiAgICBpZiAoIWZlKHgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCB4OiBuZWVkIDAgPCB4IDwgcCcpOyAvLyBGYWlsIGlmIHgg4omlIHAuXG4gICAgY29uc3QgeHggPSBtb2RQKHggKiB4KTtcbiAgICBjb25zdCBjID0gbW9kUCh4eCAqIHggKyBCaWdJbnQoNykpOyAvLyBMZXQgYyA9IHjCsyArIDcgbW9kIHAuXG4gICAgbGV0IHkgPSBzcXJ0TW9kKGMpOyAvLyBMZXQgeSA9IGNeKHArMSkvNCBtb2QgcC5cbiAgICBpZiAoeSAlIF8ybiAhPT0gXzBuKVxuICAgICAgICB5ID0gbW9kUCgteSk7IC8vIFJldHVybiB0aGUgdW5pcXVlIHBvaW50IFAgc3VjaCB0aGF0IHgoUCkgPSB4IGFuZFxuICAgIGNvbnN0IHAgPSBuZXcgUG9pbnQoeCwgeSwgXzFuKTsgLy8geShQKSA9IHkgaWYgeSBtb2QgMiA9IDAgb3IgeShQKSA9IHAteSBvdGhlcndpc2UuXG4gICAgcC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgIHJldHVybiBwO1xufVxuLyoqXG4gKiBDcmVhdGUgdGFnZ2VkIGhhc2gsIGNvbnZlcnQgaXQgdG8gYmlnaW50LCByZWR1Y2UgbW9kdWxvLW4uXG4gKi9cbmZ1bmN0aW9uIGNoYWxsZW5nZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIG1vZE4oYnl0ZXNUb051bWJlckJFKHRhZ2dlZEhhc2goJ0JJUDAzNDAvY2hhbGxlbmdlJywgLi4uYXJncykpKTtcbn1cbi8qKlxuICogU2Nobm9yciBwdWJsaWMga2V5IGlzIGp1c3QgYHhgIGNvb3JkaW5hdGUgb2YgUG9pbnQgYXMgcGVyIEJJUDM0MC5cbiAqL1xuZnVuY3Rpb24gc2Nobm9yckdldFB1YmxpY0tleShwcml2YXRlS2V5KSB7XG4gICAgcmV0dXJuIHNjaG5vcnJHZXRFeHRQdWJLZXkocHJpdmF0ZUtleSkuYnl0ZXM7IC8vIGQnPWludChzaykuIEZhaWwgaWYgZCc9MCBvciBkJ+KJpW4uIFJldCBieXRlcyhkJ+KLhUcpXG59XG4vKipcbiAqIENyZWF0ZXMgU2Nobm9yciBzaWduYXR1cmUgYXMgcGVyIEJJUDM0MC4gVmVyaWZpZXMgaXRzZWxmIGJlZm9yZSByZXR1cm5pbmcgYW55dGhpbmcuXG4gKiBhdXhSYW5kIGlzIG9wdGlvbmFsIGFuZCBpcyBub3QgdGhlIHNvbGUgc291cmNlIG9mIGsgZ2VuZXJhdGlvbjogYmFkIENTUFJORyB3b24ndCBiZSBkYW5nZXJvdXMuXG4gKi9cbmZ1bmN0aW9uIHNjaG5vcnJTaWduKG1lc3NhZ2UsIHByaXZhdGVLZXksIGF1eFJhbmQgPSByYW5kb21CeXRlcygzMikpIHtcbiAgICBjb25zdCBtID0gZW5zdXJlQnl0ZXMoJ21lc3NhZ2UnLCBtZXNzYWdlKTtcbiAgICBjb25zdCB7IGJ5dGVzOiBweCwgc2NhbGFyOiBkIH0gPSBzY2hub3JyR2V0RXh0UHViS2V5KHByaXZhdGVLZXkpOyAvLyBjaGVja3MgZm9yIGlzV2l0aGluQ3VydmVPcmRlclxuICAgIGNvbnN0IGEgPSBlbnN1cmVCeXRlcygnYXV4UmFuZCcsIGF1eFJhbmQsIDMyKTsgLy8gQXV4aWxpYXJ5IHJhbmRvbSBkYXRhIGE6IGEgMzItYnl0ZSBhcnJheVxuICAgIGNvbnN0IHQgPSBudW1UbzMyYihkIF4gYnl0ZXNUb051bWJlckJFKHRhZ2dlZEhhc2goJ0JJUDAzNDAvYXV4JywgYSkpKTsgLy8gTGV0IHQgYmUgdGhlIGJ5dGUtd2lzZSB4b3Igb2YgYnl0ZXMoZCkgYW5kIGhhc2gvYXV4KGEpXG4gICAgY29uc3QgcmFuZCA9IHRhZ2dlZEhhc2goJ0JJUDAzNDAvbm9uY2UnLCB0LCBweCwgbSk7IC8vIExldCByYW5kID0gaGFzaC9ub25jZSh0IHx8IGJ5dGVzKFApIHx8IG0pXG4gICAgY29uc3Qga18gPSBtb2ROKGJ5dGVzVG9OdW1iZXJCRShyYW5kKSk7IC8vIExldCBrJyA9IGludChyYW5kKSBtb2QgblxuICAgIGlmIChrXyA9PT0gXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ24gZmFpbGVkOiBrIGlzIHplcm8nKTsgLy8gRmFpbCBpZiBrJyA9IDAuXG4gICAgY29uc3QgeyBieXRlczogcngsIHNjYWxhcjogayB9ID0gc2Nobm9yckdldEV4dFB1YktleShrXyk7IC8vIExldCBSID0gayfii4VHLlxuICAgIGNvbnN0IGUgPSBjaGFsbGVuZ2UocngsIHB4LCBtKTsgLy8gTGV0IGUgPSBpbnQoaGFzaC9jaGFsbGVuZ2UoYnl0ZXMoUikgfHwgYnl0ZXMoUCkgfHwgbSkpIG1vZCBuLlxuICAgIGNvbnN0IHNpZyA9IG5ldyBVaW50OEFycmF5KDY0KTsgLy8gTGV0IHNpZyA9IGJ5dGVzKFIpIHx8IGJ5dGVzKChrICsgZWQpIG1vZCBuKS5cbiAgICBzaWcuc2V0KHJ4LCAwKTtcbiAgICBzaWcuc2V0KG51bVRvMzJiKG1vZE4oayArIGUgKiBkKSksIDMyKTtcbiAgICAvLyBJZiBWZXJpZnkoYnl0ZXMoUCksIG0sIHNpZykgKHNlZSBiZWxvdykgcmV0dXJucyBmYWlsdXJlLCBhYm9ydFxuICAgIGlmICghc2Nobm9yclZlcmlmeShzaWcsIG0sIHB4KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduOiBJbnZhbGlkIHNpZ25hdHVyZSBwcm9kdWNlZCcpO1xuICAgIHJldHVybiBzaWc7XG59XG4vKipcbiAqIFZlcmlmaWVzIFNjaG5vcnIgc2lnbmF0dXJlLlxuICogV2lsbCBzd2FsbG93IGVycm9ycyAmIHJldHVybiBmYWxzZSBleGNlcHQgZm9yIGluaXRpYWwgdHlwZSB2YWxpZGF0aW9uIG9mIGFyZ3VtZW50cy5cbiAqL1xuZnVuY3Rpb24gc2Nobm9yclZlcmlmeShzaWduYXR1cmUsIG1lc3NhZ2UsIHB1YmxpY0tleSkge1xuICAgIGNvbnN0IHNpZyA9IGVuc3VyZUJ5dGVzKCdzaWduYXR1cmUnLCBzaWduYXR1cmUsIDY0KTtcbiAgICBjb25zdCBtID0gZW5zdXJlQnl0ZXMoJ21lc3NhZ2UnLCBtZXNzYWdlKTtcbiAgICBjb25zdCBwdWIgPSBlbnN1cmVCeXRlcygncHVibGljS2V5JywgcHVibGljS2V5LCAzMik7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgUCA9IGxpZnRfeChieXRlc1RvTnVtYmVyQkUocHViKSk7IC8vIFAgPSBsaWZ0X3goaW50KHBrKSk7IGZhaWwgaWYgdGhhdCBmYWlsc1xuICAgICAgICBjb25zdCByID0gYnl0ZXNUb051bWJlckJFKHNpZy5zdWJhcnJheSgwLCAzMikpOyAvLyBMZXQgciA9IGludChzaWdbMDozMl0pOyBmYWlsIGlmIHIg4omlIHAuXG4gICAgICAgIGlmICghZmUocikpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IHMgPSBieXRlc1RvTnVtYmVyQkUoc2lnLnN1YmFycmF5KDMyLCA2NCkpOyAvLyBMZXQgcyA9IGludChzaWdbMzI6NjRdKTsgZmFpbCBpZiBzIOKJpSBuLlxuICAgICAgICBpZiAoIWdlKHMpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBlID0gY2hhbGxlbmdlKG51bVRvMzJiKHIpLCBwb2ludFRvQnl0ZXMoUCksIG0pOyAvLyBpbnQoY2hhbGxlbmdlKGJ5dGVzKHIpfHxieXRlcyhQKXx8bSkpJW5cbiAgICAgICAgY29uc3QgUiA9IEdtdWxBZGQoUCwgcywgbW9kTigtZSkpOyAvLyBSID0gc+KLhUcgLSBl4ouFUFxuICAgICAgICBpZiAoIVIgfHwgIVIuaGFzRXZlblkoKSB8fCBSLnRvQWZmaW5lKCkueCAhPT0gcilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gLWVQID09IChuLWUpUFxuICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gRmFpbCBpZiBpc19pbmZpbml0ZShSKSAvIG5vdCBoYXNfZXZlbl95KFIpIC8geChSKSDiiaAgci5cbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnQgY29uc3Qgc2Nobm9yciA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gKHtcbiAgICBnZXRQdWJsaWNLZXk6IHNjaG5vcnJHZXRQdWJsaWNLZXksXG4gICAgc2lnbjogc2Nobm9yclNpZ24sXG4gICAgdmVyaWZ5OiBzY2hub3JyVmVyaWZ5LFxuICAgIHV0aWxzOiB7XG4gICAgICAgIHJhbmRvbVByaXZhdGVLZXk6IHNlY3AyNTZrMS51dGlscy5yYW5kb21Qcml2YXRlS2V5LFxuICAgICAgICBsaWZ0X3gsXG4gICAgICAgIHBvaW50VG9CeXRlcyxcbiAgICAgICAgbnVtYmVyVG9CeXRlc0JFLFxuICAgICAgICBieXRlc1RvTnVtYmVyQkUsXG4gICAgICAgIHRhZ2dlZEhhc2gsXG4gICAgICAgIG1vZCxcbiAgICB9LFxufSkpKCk7XG5jb25zdCBpc29NYXAgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGlzb2dlbnlNYXAoRnAsIFtcbiAgICAvLyB4TnVtXG4gICAgW1xuICAgICAgICAnMHg4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZGFhYWFhOGM3JyxcbiAgICAgICAgJzB4N2QzZDRjODBiYzMyMWQ1YjlmMzE1Y2VhN2ZkNDRjNWQ1OTVkMmZjMGJmNjNiOTJkZmZmMTA0NGYxN2M2NTgxJyxcbiAgICAgICAgJzB4NTM0YzMyOGQyM2YyMzRlNmUyYTQxM2RlY2EyNWNhZWNlNDUwNjE0NDAzN2M0MDMxNGVjYmQwYjUzZDlkZDI2MicsXG4gICAgICAgICcweDhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhkYWFhYWE4OGMnLFxuICAgIF0sXG4gICAgLy8geERlblxuICAgIFtcbiAgICAgICAgJzB4ZDM1NzcxMTkzZDk0OTE4YTljYTM0Y2NiYjdiNjQwZGQ4NmNkNDA5NTQyZjg0ODdkOWZlNmI3NDU3ODFlYjQ5YicsXG4gICAgICAgICcweGVkYWRjNmY2NDM4M2RjMWRmN2M0YjJkNTFiNTQyMjU0MDZkMzZiNjQxZjVlNDFiYmM1MmE1NjYxMmE4YzZkMTQnLFxuICAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJywgLy8gTEFTVCAxXG4gICAgXSxcbiAgICAvLyB5TnVtXG4gICAgW1xuICAgICAgICAnMHg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YjhlMzhlMjNjJyxcbiAgICAgICAgJzB4Yzc1ZTBjMzJkNWNiN2MwZmE5ZDBhNTRiMTJhMGE2ZDU2NDdhYjA0NmQ2ODZkYTZmZGZmYzkwZmMyMDFkNzFhMycsXG4gICAgICAgICcweDI5YTYxOTQ2OTFmOTFhNzM3MTUyMDllZjY1MTJlNTc2NzIyODMwYTIwMWJlMjAxOGE3NjVlODVhOWVjZWU5MzEnLFxuICAgICAgICAnMHgyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjM4ZTM4ZDg0JyxcbiAgICBdLFxuICAgIC8vIHlEZW5cbiAgICBbXG4gICAgICAgICcweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZmZmZmY5M2InLFxuICAgICAgICAnMHg3YTA2NTM0YmI4YmRiNDlmZDVlOWU2NjMyNzIyYzI5ODk0NjdjMWJmYzhlOGQ5NzhkZmI0MjVkMjY4NWMyNTczJyxcbiAgICAgICAgJzB4NjQ4NGFhNzE2NTQ1Y2EyY2YzYTcwYzNmYThmZTMzN2UwYTNkMjExNjJmMGQ2Mjk5YTdiZjgxOTJiZmQyYTc2ZicsXG4gICAgICAgICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnLCAvLyBMQVNUIDFcbiAgICBdLFxuXS5tYXAoKGkpID0+IGkubWFwKChqKSA9PiBCaWdJbnQoaikpKSkpKCk7XG5jb25zdCBtYXBTV1UgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IG1hcFRvQ3VydmVTaW1wbGVTV1UoRnAsIHtcbiAgICBBOiBCaWdJbnQoJzB4M2Y4NzMxYWJkZDY2MWFkY2EwOGE1NTU4ZjBmNWQyNzJlOTUzZDM2M2NiNmYwZTVkNDA1NDQ3YzAxYTQ0NDUzMycpLFxuICAgIEI6IEJpZ0ludCgnMTc3MScpLFxuICAgIFo6IEZwLmNyZWF0ZShCaWdJbnQoJy0xMScpKSxcbn0pKSgpO1xuY29uc3QgaHRmID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBjcmVhdGVIYXNoZXIoc2VjcDI1NmsxLlByb2plY3RpdmVQb2ludCwgKHNjYWxhcnMpID0+IHtcbiAgICBjb25zdCB7IHgsIHkgfSA9IG1hcFNXVShGcC5jcmVhdGUoc2NhbGFyc1swXSkpO1xuICAgIHJldHVybiBpc29NYXAoeCwgeSk7XG59LCB7XG4gICAgRFNUOiAnc2VjcDI1NmsxX1hNRDpTSEEtMjU2X1NTV1VfUk9fJyxcbiAgICBlbmNvZGVEU1Q6ICdzZWNwMjU2azFfWE1EOlNIQS0yNTZfU1NXVV9OVV8nLFxuICAgIHA6IEZwLk9SREVSLFxuICAgIG06IDEsXG4gICAgazogMTI4LFxuICAgIGV4cGFuZDogJ3htZCcsXG4gICAgaGFzaDogc2hhMjU2LFxufSkpKCk7XG5leHBvcnQgY29uc3QgaGFzaFRvQ3VydmUgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGh0Zi5oYXNoVG9DdXJ2ZSkoKTtcbmV4cG9ydCBjb25zdCBlbmNvZGVUb0N1cnZlID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBodGYuZW5jb2RlVG9DdXJ2ZSkoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlY3AyNTZrMS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/secp256k1.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js":
/*!***************************************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js ***!
  \***************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bool: () => (/* binding */ bool),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   exists: () => (/* binding */ exists),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   output: () => (/* binding */ output)\n/* harmony export */ });\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`Wrong positive integer: ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`Expected boolean, not ${b}`);\n}\nfunction bytes(b, ...lengths) {\n    if (!(b instanceof Uint8Array))\n        throw new Error('Expected Uint8Array');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(hash) {\n    if (typeof hash !== 'function' || typeof hash.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(hash.outputLen);\n    number(hash.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\n\nconst assert = { number, bool, bytes, hash, exists, output };\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (assert);\n//# sourceMappingURL=_assert.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9zdHItZGV2LWtpdC9uZGsvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fYXNzZXJ0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0EsbURBQW1ELEVBQUU7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsaURBQWlELEVBQUU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxRQUFRLGtCQUFrQixTQUFTO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsSUFBSTtBQUNyRjtBQUNBO0FBQ3FEO0FBQ3JELGlCQUFpQjtBQUNqQixpRUFBZSxNQUFNLEVBQUM7QUFDdEIiLCJzb3VyY2VzIjpbIi9ob21lL2xmZy9HaXQvTWFkdHJpcHMvbm9kZV9tb2R1bGVzL0Bub3N0ci1kZXYta2l0L25kay9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19hc3NlcnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gbnVtYmVyKG4pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG4pIHx8IG4gPCAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdyb25nIHBvc2l0aXZlIGludGVnZXI6ICR7bn1gKTtcbn1cbmZ1bmN0aW9uIGJvb2woYikge1xuICAgIGlmICh0eXBlb2YgYiAhPT0gJ2Jvb2xlYW4nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGJvb2xlYW4sIG5vdCAke2J9YCk7XG59XG5mdW5jdGlvbiBieXRlcyhiLCAuLi5sZW5ndGhzKSB7XG4gICAgaWYgKCEoYiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIFVpbnQ4QXJyYXknKTtcbiAgICBpZiAobGVuZ3Rocy5sZW5ndGggPiAwICYmICFsZW5ndGhzLmluY2x1ZGVzKGIubGVuZ3RoKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBVaW50OEFycmF5IG9mIGxlbmd0aCAke2xlbmd0aHN9LCBub3Qgb2YgbGVuZ3RoPSR7Yi5sZW5ndGh9YCk7XG59XG5mdW5jdGlvbiBoYXNoKGhhc2gpIHtcbiAgICBpZiAodHlwZW9mIGhhc2ggIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGhhc2guY3JlYXRlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggc2hvdWxkIGJlIHdyYXBwZWQgYnkgdXRpbHMud3JhcENvbnN0cnVjdG9yJyk7XG4gICAgbnVtYmVyKGhhc2gub3V0cHV0TGVuKTtcbiAgICBudW1iZXIoaGFzaC5ibG9ja0xlbik7XG59XG5mdW5jdGlvbiBleGlzdHMoaW5zdGFuY2UsIGNoZWNrRmluaXNoZWQgPSB0cnVlKSB7XG4gICAgaWYgKGluc3RhbmNlLmRlc3Ryb3llZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIGluc3RhbmNlIGhhcyBiZWVuIGRlc3Ryb3llZCcpO1xuICAgIGlmIChjaGVja0ZpbmlzaGVkICYmIGluc3RhbmNlLmZpbmlzaGVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2gjZGlnZXN0KCkgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWQnKTtcbn1cbmZ1bmN0aW9uIG91dHB1dChvdXQsIGluc3RhbmNlKSB7XG4gICAgYnl0ZXMob3V0KTtcbiAgICBjb25zdCBtaW4gPSBpbnN0YW5jZS5vdXRwdXRMZW47XG4gICAgaWYgKG91dC5sZW5ndGggPCBtaW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkaWdlc3RJbnRvKCkgZXhwZWN0cyBvdXRwdXQgYnVmZmVyIG9mIGxlbmd0aCBhdCBsZWFzdCAke21pbn1gKTtcbiAgICB9XG59XG5leHBvcnQgeyBudW1iZXIsIGJvb2wsIGJ5dGVzLCBoYXNoLCBleGlzdHMsIG91dHB1dCB9O1xuY29uc3QgYXNzZXJ0ID0geyBudW1iZXIsIGJvb2wsIGJ5dGVzLCBoYXNoLCBleGlzdHMsIG91dHB1dCB9O1xuZXhwb3J0IGRlZmF1bHQgYXNzZXJ0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X2Fzc2VydC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/_sha2.js":
/*!*************************************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/_sha2.js ***!
  \*************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHA2: () => (/* binding */ SHA2)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nclass SHA2 extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(this.buffer);\n    }\n    update(data) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        const { view, buffer, blockLen } = this;\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.output)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n//# sourceMappingURL=_sha2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9zdHItZGV2LWtpdC9uZGsvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fc2hhMi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBOEM7QUFDUztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sbUJBQW1CLDJDQUFJO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscURBQVU7QUFDOUI7QUFDQTtBQUNBLFFBQVEsa0RBQU07QUFDZCxnQkFBZ0IseUJBQXlCO0FBQ3pDLGVBQWUsa0RBQU87QUFDdEI7QUFDQSwwQkFBMEIsVUFBVTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMscURBQVU7QUFDM0MsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQU07QUFDZCxRQUFRLGtEQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0JBQStCO0FBQy9DLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsY0FBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscURBQVU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxREFBcUQ7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2xmZy9HaXQvTWFkdHJpcHMvbm9kZV9tb2R1bGVzL0Bub3N0ci1kZXYta2l0L25kay9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19zaGEyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGV4aXN0cywgb3V0cHV0IH0gZnJvbSAnLi9fYXNzZXJ0LmpzJztcbmltcG9ydCB7IEhhc2gsIGNyZWF0ZVZpZXcsIHRvQnl0ZXMgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIFBvbHlmaWxsIGZvciBTYWZhcmkgMTRcbmZ1bmN0aW9uIHNldEJpZ1VpbnQ2NCh2aWV3LCBieXRlT2Zmc2V0LCB2YWx1ZSwgaXNMRSkge1xuICAgIGlmICh0eXBlb2Ygdmlldy5zZXRCaWdVaW50NjQgPT09ICdmdW5jdGlvbicpXG4gICAgICAgIHJldHVybiB2aWV3LnNldEJpZ1VpbnQ2NChieXRlT2Zmc2V0LCB2YWx1ZSwgaXNMRSk7XG4gICAgY29uc3QgXzMybiA9IEJpZ0ludCgzMik7XG4gICAgY29uc3QgX3UzMl9tYXggPSBCaWdJbnQoMHhmZmZmZmZmZik7XG4gICAgY29uc3Qgd2ggPSBOdW1iZXIoKHZhbHVlID4+IF8zMm4pICYgX3UzMl9tYXgpO1xuICAgIGNvbnN0IHdsID0gTnVtYmVyKHZhbHVlICYgX3UzMl9tYXgpO1xuICAgIGNvbnN0IGggPSBpc0xFID8gNCA6IDA7XG4gICAgY29uc3QgbCA9IGlzTEUgPyAwIDogNDtcbiAgICB2aWV3LnNldFVpbnQzMihieXRlT2Zmc2V0ICsgaCwgd2gsIGlzTEUpO1xuICAgIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBsLCB3bCwgaXNMRSk7XG59XG4vLyBCYXNlIFNIQTIgY2xhc3MgKFJGQyA2MjM0KVxuZXhwb3J0IGNsYXNzIFNIQTIgZXh0ZW5kcyBIYXNoIHtcbiAgICBjb25zdHJ1Y3RvcihibG9ja0xlbiwgb3V0cHV0TGVuLCBwYWRPZmZzZXQsIGlzTEUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdGhpcy5wYWRPZmZzZXQgPSBwYWRPZmZzZXQ7XG4gICAgICAgIHRoaXMuaXNMRSA9IGlzTEU7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tMZW4pO1xuICAgICAgICB0aGlzLnZpZXcgPSBjcmVhdGVWaWV3KHRoaXMuYnVmZmVyKTtcbiAgICB9XG4gICAgdXBkYXRlKGRhdGEpIHtcbiAgICAgICAgZXhpc3RzKHRoaXMpO1xuICAgICAgICBjb25zdCB7IHZpZXcsIGJ1ZmZlciwgYmxvY2tMZW4gfSA9IHRoaXM7XG4gICAgICAgIGRhdGEgPSB0b0J5dGVzKGRhdGEpO1xuICAgICAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3MsIGxlbiAtIHBvcyk7XG4gICAgICAgICAgICAvLyBGYXN0IHBhdGg6IHdlIGhhdmUgYXQgbGVhc3Qgb25lIGJsb2NrIGluIGlucHV0LCBjYXN0IGl0IHRvIHZpZXcgYW5kIHByb2Nlc3NcbiAgICAgICAgICAgIGlmICh0YWtlID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFWaWV3ID0gY3JlYXRlVmlldyhkYXRhKTtcbiAgICAgICAgICAgICAgICBmb3IgKDsgYmxvY2tMZW4gPD0gbGVuIC0gcG9zOyBwb3MgKz0gYmxvY2tMZW4pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2VzcyhkYXRhVmlldywgcG9zKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlci5zZXQoZGF0YS5zdWJhcnJheShwb3MsIHBvcyArIHRha2UpLCB0aGlzLnBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSB0YWtlO1xuICAgICAgICAgICAgcG9zICs9IHRha2U7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxlbmd0aCArPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgdGhpcy5yb3VuZENsZWFuKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBleGlzdHModGhpcyk7XG4gICAgICAgIG91dHB1dChvdXQsIHRoaXMpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgLy8gUGFkZGluZ1xuICAgICAgICAvLyBXZSBjYW4gYXZvaWQgYWxsb2NhdGlvbiBvZiBidWZmZXIgZm9yIHBhZGRpbmcgY29tcGxldGVseSBpZiBpdFxuICAgICAgICAvLyB3YXMgcHJldmlvdXNseSBub3QgYWxsb2NhdGVkIGhlcmUuIEJ1dCBpdCB3b24ndCBjaGFuZ2UgcGVyZm9ybWFuY2UuXG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCB2aWV3LCBibG9ja0xlbiwgaXNMRSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgcG9zIH0gPSB0aGlzO1xuICAgICAgICAvLyBhcHBlbmQgdGhlIGJpdCAnMScgdG8gdGhlIG1lc3NhZ2VcbiAgICAgICAgYnVmZmVyW3BvcysrXSA9IDBiMTAwMDAwMDA7XG4gICAgICAgIHRoaXMuYnVmZmVyLnN1YmFycmF5KHBvcykuZmlsbCgwKTtcbiAgICAgICAgLy8gd2UgaGF2ZSBsZXNzIHRoYW4gcGFkT2Zmc2V0IGxlZnQgaW4gYnVmZmVyLCBzbyB3ZSBjYW5ub3QgcHV0IGxlbmd0aCBpbiBjdXJyZW50IGJsb2NrLCBuZWVkIHByb2Nlc3MgaXQgYW5kIHBhZCBhZ2FpblxuICAgICAgICBpZiAodGhpcy5wYWRPZmZzZXQgPiBibG9ja0xlbiAtIHBvcykge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICAgICAgcG9zID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBQYWQgdW50aWwgZnVsbCBibG9jayBieXRlIHdpdGggemVyb3NcbiAgICAgICAgZm9yIChsZXQgaSA9IHBvczsgaSA8IGJsb2NrTGVuOyBpKyspXG4gICAgICAgICAgICBidWZmZXJbaV0gPSAwO1xuICAgICAgICAvLyBOb3RlOiBzaGE1MTIgcmVxdWlyZXMgbGVuZ3RoIHRvIGJlIDEyOGJpdCBpbnRlZ2VyLCBidXQgbGVuZ3RoIGluIEpTIHdpbGwgb3ZlcmZsb3cgYmVmb3JlIHRoYXRcbiAgICAgICAgLy8gWW91IG5lZWQgdG8gd3JpdGUgYXJvdW5kIDIgZXhhYnl0ZXMgKHU2NF9tYXggLyA4IC8gKDEwMjQqKjYpKSBmb3IgdGhpcyB0byBoYXBwZW4uXG4gICAgICAgIC8vIFNvIHdlIGp1c3Qgd3JpdGUgbG93ZXN0IDY0IGJpdHMgb2YgdGhhdCB2YWx1ZS5cbiAgICAgICAgc2V0QmlnVWludDY0KHZpZXcsIGJsb2NrTGVuIC0gOCwgQmlnSW50KHRoaXMubGVuZ3RoICogOCksIGlzTEUpO1xuICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgIGNvbnN0IG92aWV3ID0gY3JlYXRlVmlldyhvdXQpO1xuICAgICAgICBjb25zdCBsZW4gPSB0aGlzLm91dHB1dExlbjtcbiAgICAgICAgLy8gTk9URTogd2UgZG8gZGl2aXNpb24gYnkgNCBsYXRlciwgd2hpY2ggc2hvdWxkIGJlIGZ1c2VkIGluIHNpbmdsZSBvcCB3aXRoIG1vZHVsbyBieSBKSVRcbiAgICAgICAgaWYgKGxlbiAlIDQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ19zaGEyOiBvdXRwdXRMZW4gc2hvdWxkIGJlIGFsaWduZWQgdG8gMzJiaXQnKTtcbiAgICAgICAgY29uc3Qgb3V0TGVuID0gbGVuIC8gNDtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldCgpO1xuICAgICAgICBpZiAob3V0TGVuID4gc3RhdGUubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfc2hhMjogb3V0cHV0TGVuIGJpZ2dlciB0aGFuIHN0YXRlJyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0TGVuOyBpKyspXG4gICAgICAgICAgICBvdmlldy5zZXRVaW50MzIoNCAqIGksIHN0YXRlW2ldLCBpc0xFKTtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgb3V0cHV0TGVuIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLmRpZ2VzdEludG8oYnVmZmVyKTtcbiAgICAgICAgY29uc3QgcmVzID0gYnVmZmVyLnNsaWNlKDAsIG91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIHRvIHx8ICh0byA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkpO1xuICAgICAgICB0by5zZXQoLi4udGhpcy5nZXQoKSk7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIGJ1ZmZlciwgbGVuZ3RoLCBmaW5pc2hlZCwgZGVzdHJveWVkLCBwb3MgfSA9IHRoaXM7XG4gICAgICAgIHRvLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdG8ucG9zID0gcG9zO1xuICAgICAgICB0by5maW5pc2hlZCA9IGZpbmlzaGVkO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSBkZXN0cm95ZWQ7XG4gICAgICAgIGlmIChsZW5ndGggJSBibG9ja0xlbilcbiAgICAgICAgICAgIHRvLmJ1ZmZlci5zZXQoYnVmZmVyKTtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9zaGEyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/_sha2.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/crypto.js":
/*!**************************************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/crypto.js ***!
  \**************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   crypto: () => (/* binding */ crypto)\n/* harmony export */ });\nconst crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n//# sourceMappingURL=crypto.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9zdHItZGV2LWtpdC9uZGsvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9jcnlwdG8uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPO0FBQ1AiLCJzb3VyY2VzIjpbIi9ob21lL2xmZy9HaXQvTWFkdHJpcHMvbm9kZV9tb2R1bGVzL0Bub3N0ci1kZXYta2l0L25kay9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2NyeXB0by5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgY3J5cHRvID0gdHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnICYmICdjcnlwdG8nIGluIGdsb2JhbFRoaXMgPyBnbG9iYWxUaGlzLmNyeXB0byA6IHVuZGVmaW5lZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyeXB0by5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/crypto.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/hmac.js":
/*!************************************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/hmac.js ***!
  \************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HMAC: () => (/* binding */ HMAC),\n/* harmony export */   hmac: () => (/* binding */ hmac)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// HMAC (RFC 2104)\nclass HMAC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.hash)(hash);\n        const key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.bytes)(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */\nconst hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key) => new HMAC(hash, key);\n//# sourceMappingURL=hmac.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9zdHItZGV2LWtpdC9uZGsvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9obWFjLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBZ0c7QUFDckQ7QUFDM0M7QUFDTyxtQkFBbUIsMkNBQUk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdEQUFVO0FBQ2xCLG9CQUFvQixrREFBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFZO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBWTtBQUNwQixRQUFRLGlEQUFXO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFLGdCQUFnQix5REFBeUQ7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9sZmcvR2l0L01hZHRyaXBzL25vZGVfbW9kdWxlcy9Abm9zdHItZGV2LWtpdC9uZGsvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9obWFjLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGhhc2ggYXMgYXNzZXJ0SGFzaCwgYnl0ZXMgYXMgYXNzZXJ0Qnl0ZXMsIGV4aXN0cyBhcyBhc3NlcnRFeGlzdHMgfSBmcm9tICcuL19hc3NlcnQuanMnO1xuaW1wb3J0IHsgSGFzaCwgdG9CeXRlcyB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gSE1BQyAoUkZDIDIxMDQpXG5leHBvcnQgY2xhc3MgSE1BQyBleHRlbmRzIEhhc2gge1xuICAgIGNvbnN0cnVjdG9yKGhhc2gsIF9rZXkpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICBhc3NlcnRIYXNoKGhhc2gpO1xuICAgICAgICBjb25zdCBrZXkgPSB0b0J5dGVzKF9rZXkpO1xuICAgICAgICB0aGlzLmlIYXNoID0gaGFzaC5jcmVhdGUoKTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmlIYXNoLnVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgaW5zdGFuY2Ugb2YgY2xhc3Mgd2hpY2ggZXh0ZW5kcyB1dGlscy5IYXNoJyk7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSB0aGlzLmlIYXNoLmJsb2NrTGVuO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IHRoaXMuaUhhc2gub3V0cHV0TGVuO1xuICAgICAgICBjb25zdCBibG9ja0xlbiA9IHRoaXMuYmxvY2tMZW47XG4gICAgICAgIGNvbnN0IHBhZCA9IG5ldyBVaW50OEFycmF5KGJsb2NrTGVuKTtcbiAgICAgICAgLy8gYmxvY2tMZW4gY2FuIGJlIGJpZ2dlciB0aGFuIG91dHB1dExlblxuICAgICAgICBwYWQuc2V0KGtleS5sZW5ndGggPiBibG9ja0xlbiA/IGhhc2guY3JlYXRlKCkudXBkYXRlKGtleSkuZGlnZXN0KCkgOiBrZXkpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHBhZFtpXSBePSAweDM2O1xuICAgICAgICB0aGlzLmlIYXNoLnVwZGF0ZShwYWQpO1xuICAgICAgICAvLyBCeSBkb2luZyB1cGRhdGUgKHByb2Nlc3Npbmcgb2YgZmlyc3QgYmxvY2spIG9mIG91dGVyIGhhc2ggaGVyZSB3ZSBjYW4gcmUtdXNlIGl0IGJldHdlZW4gbXVsdGlwbGUgY2FsbHMgdmlhIGNsb25lXG4gICAgICAgIHRoaXMub0hhc2ggPSBoYXNoLmNyZWF0ZSgpO1xuICAgICAgICAvLyBVbmRvIGludGVybmFsIFhPUiAmJiBhcHBseSBvdXRlciBYT1JcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBwYWRbaV0gXj0gMHgzNiBeIDB4NWM7XG4gICAgICAgIHRoaXMub0hhc2gudXBkYXRlKHBhZCk7XG4gICAgICAgIHBhZC5maWxsKDApO1xuICAgIH1cbiAgICB1cGRhdGUoYnVmKSB7XG4gICAgICAgIGFzc2VydEV4aXN0cyh0aGlzKTtcbiAgICAgICAgdGhpcy5pSGFzaC51cGRhdGUoYnVmKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgIGFzc2VydEV4aXN0cyh0aGlzKTtcbiAgICAgICAgYXNzZXJ0Qnl0ZXMob3V0LCB0aGlzLm91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmlIYXNoLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgdGhpcy5vSGFzaC51cGRhdGUob3V0KTtcbiAgICAgICAgdGhpcy5vSGFzaC5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgIH1cbiAgICBkaWdlc3QoKSB7XG4gICAgICAgIGNvbnN0IG91dCA9IG5ldyBVaW50OEFycmF5KHRoaXMub0hhc2gub3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIF9jbG9uZUludG8odG8pIHtcbiAgICAgICAgLy8gQ3JlYXRlIG5ldyBpbnN0YW5jZSB3aXRob3V0IGNhbGxpbmcgY29uc3RydWN0b3Igc2luY2Uga2V5IGFscmVhZHkgaW4gc3RhdGUgYW5kIHdlIGRvbid0IGtub3cgaXQuXG4gICAgICAgIHRvIHx8ICh0byA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLCB7fSkpO1xuICAgICAgICBjb25zdCB7IG9IYXNoLCBpSGFzaCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgYmxvY2tMZW4sIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICAgICAgdG8gPSB0bztcbiAgICAgICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gZGVzdHJveWVkO1xuICAgICAgICB0by5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgICB0by5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRvLm9IYXNoID0gb0hhc2guX2Nsb25lSW50byh0by5vSGFzaCk7XG4gICAgICAgIHRvLmlIYXNoID0gaUhhc2guX2Nsb25lSW50byh0by5pSGFzaCk7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLm9IYXNoLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5pSGFzaC5kZXN0cm95KCk7XG4gICAgfVxufVxuLyoqXG4gKiBITUFDOiBSRkMyMTA0IG1lc3NhZ2UgYXV0aGVudGljYXRpb24gY29kZS5cbiAqIEBwYXJhbSBoYXNoIC0gZnVuY3Rpb24gdGhhdCB3b3VsZCBiZSB1c2VkIGUuZy4gc2hhMjU2XG4gKiBAcGFyYW0ga2V5IC0gbWVzc2FnZSBrZXlcbiAqIEBwYXJhbSBtZXNzYWdlIC0gbWVzc2FnZSBkYXRhXG4gKi9cbmV4cG9ydCBjb25zdCBobWFjID0gKGhhc2gsIGtleSwgbWVzc2FnZSkgPT4gbmV3IEhNQUMoaGFzaCwga2V5KS51cGRhdGUobWVzc2FnZSkuZGlnZXN0KCk7XG5obWFjLmNyZWF0ZSA9IChoYXNoLCBrZXkpID0+IG5ldyBITUFDKGhhc2gsIGtleSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1obWFjLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/hmac.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/sha256.js":
/*!**************************************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/sha256.js ***!
  \**************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sha224: () => (/* binding */ sha224),\n/* harmony export */   sha256: () => (/* binding */ sha256)\n/* harmony export */ });\n/* harmony import */ var _sha2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_sha2.js */ \"(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/_sha2.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n// Choice: a ? b : c\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends _sha2_js__WEBPACK_IMPORTED_MODULE_0__.SHA2 {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = IV[0] | 0;\n        this.B = IV[1] | 0;\n        this.C = IV[2] | 0;\n        this.D = IV[3] | 0;\n        this.E = IV[4] | 0;\n        this.F = IV[5] | 0;\n        this.G = IV[6] | 0;\n        this.H = IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 7) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 18) ^ (W15 >>> 3);\n            const s1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 17) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 6) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 11) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 2) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 13) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nconst sha256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA256());\nconst sha224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA224());\n//# sourceMappingURL=sha256.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9zdHItZGV2LWtpdC9uZGsvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGEyNTYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFrQztBQUNpQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMENBQUk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5QkFBeUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0EsdUJBQXVCLCtDQUFJLFdBQVcsK0NBQUk7QUFDMUMsdUJBQXVCLCtDQUFJLFdBQVcsK0NBQUk7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsY0FBYyx5QkFBeUI7QUFDdkMsd0JBQXdCLFFBQVE7QUFDaEMsMkJBQTJCLCtDQUFJLFNBQVMsK0NBQUksVUFBVSwrQ0FBSTtBQUMxRDtBQUNBLDJCQUEyQiwrQ0FBSSxTQUFTLCtDQUFJLFVBQVUsK0NBQUk7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sK0JBQStCLDBEQUFlO0FBQzlDLCtCQUErQiwwREFBZTtBQUNyRCIsInNvdXJjZXMiOlsiL2hvbWUvbGZnL0dpdC9NYWR0cmlwcy9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vc2hhMjU2LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNIQTIgfSBmcm9tICcuL19zaGEyLmpzJztcbmltcG9ydCB7IHJvdHIsIHdyYXBDb25zdHJ1Y3RvciB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gU0hBMi0yNTYgbmVlZCB0byB0cnkgMl4xMjggaGFzaGVzIHRvIGV4ZWN1dGUgYmlydGhkYXkgYXR0YWNrLlxuLy8gQlRDIG5ldHdvcmsgaXMgZG9pbmcgMl42NyBoYXNoZXMvc2VjIGFzIHBlciBlYXJseSAyMDIzLlxuLy8gQ2hvaWNlOiBhID8gYiA6IGNcbmNvbnN0IENoaSA9IChhLCBiLCBjKSA9PiAoYSAmIGIpIF4gKH5hICYgYyk7XG4vLyBNYWpvcml0eSBmdW5jdGlvbiwgdHJ1ZSBpZiBhbnkgdHdvIGlucHVzdCBpcyB0cnVlXG5jb25zdCBNYWogPSAoYSwgYiwgYykgPT4gKGEgJiBiKSBeIChhICYgYykgXiAoYiAmIGMpO1xuLy8gUm91bmQgY29uc3RhbnRzOlxuLy8gZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgY3ViZSByb290cyBvZiB0aGUgZmlyc3QgNjQgcHJpbWVzIDIuLjMxMSlcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgU0hBMjU2X0sgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KFtcbiAgICAweDQyOGEyZjk4LCAweDcxMzc0NDkxLCAweGI1YzBmYmNmLCAweGU5YjVkYmE1LCAweDM5NTZjMjViLCAweDU5ZjExMWYxLCAweDkyM2Y4MmE0LCAweGFiMWM1ZWQ1LFxuICAgIDB4ZDgwN2FhOTgsIDB4MTI4MzViMDEsIDB4MjQzMTg1YmUsIDB4NTUwYzdkYzMsIDB4NzJiZTVkNzQsIDB4ODBkZWIxZmUsIDB4OWJkYzA2YTcsIDB4YzE5YmYxNzQsXG4gICAgMHhlNDliNjljMSwgMHhlZmJlNDc4NiwgMHgwZmMxOWRjNiwgMHgyNDBjYTFjYywgMHgyZGU5MmM2ZiwgMHg0YTc0ODRhYSwgMHg1Y2IwYTlkYywgMHg3NmY5ODhkYSxcbiAgICAweDk4M2U1MTUyLCAweGE4MzFjNjZkLCAweGIwMDMyN2M4LCAweGJmNTk3ZmM3LCAweGM2ZTAwYmYzLCAweGQ1YTc5MTQ3LCAweDA2Y2E2MzUxLCAweDE0MjkyOTY3LFxuICAgIDB4MjdiNzBhODUsIDB4MmUxYjIxMzgsIDB4NGQyYzZkZmMsIDB4NTMzODBkMTMsIDB4NjUwYTczNTQsIDB4NzY2YTBhYmIsIDB4ODFjMmM5MmUsIDB4OTI3MjJjODUsXG4gICAgMHhhMmJmZThhMSwgMHhhODFhNjY0YiwgMHhjMjRiOGI3MCwgMHhjNzZjNTFhMywgMHhkMTkyZTgxOSwgMHhkNjk5MDYyNCwgMHhmNDBlMzU4NSwgMHgxMDZhYTA3MCxcbiAgICAweDE5YTRjMTE2LCAweDFlMzc2YzA4LCAweDI3NDg3NzRjLCAweDM0YjBiY2I1LCAweDM5MWMwY2IzLCAweDRlZDhhYTRhLCAweDViOWNjYTRmLCAweDY4MmU2ZmYzLFxuICAgIDB4NzQ4ZjgyZWUsIDB4NzhhNTYzNmYsIDB4ODRjODc4MTQsIDB4OGNjNzAyMDgsIDB4OTBiZWZmZmEsIDB4YTQ1MDZjZWIsIDB4YmVmOWEzZjcsIDB4YzY3MTc4ZjJcbl0pO1xuLy8gSW5pdGlhbCBzdGF0ZSAoZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgc3F1YXJlIHJvb3RzIG9mIHRoZSBmaXJzdCA4IHByaW1lcyAyLi4xOSk6XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IElWID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheShbXG4gICAgMHg2YTA5ZTY2NywgMHhiYjY3YWU4NSwgMHgzYzZlZjM3MiwgMHhhNTRmZjUzYSwgMHg1MTBlNTI3ZiwgMHg5YjA1Njg4YywgMHgxZjgzZDlhYiwgMHg1YmUwY2QxOVxuXSk7XG4vLyBUZW1wb3JhcnkgYnVmZmVyLCBub3QgdXNlZCB0byBzdG9yZSBhbnl0aGluZyBiZXR3ZWVuIHJ1bnNcbi8vIE5hbWVkIHRoaXMgd2F5IGJlY2F1c2UgaXQgbWF0Y2hlcyBzcGVjaWZpY2F0aW9uLlxuY29uc3QgU0hBMjU2X1cgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDY0KTtcbmNsYXNzIFNIQTI1NiBleHRlbmRzIFNIQTIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcig2NCwgMzIsIDgsIGZhbHNlKTtcbiAgICAgICAgLy8gV2UgY2Fubm90IHVzZSBhcnJheSBoZXJlIHNpbmNlIGFycmF5IGFsbG93cyBpbmRleGluZyBieSB2YXJpYWJsZVxuICAgICAgICAvLyB3aGljaCBtZWFucyBvcHRpbWl6ZXIvY29tcGlsZXIgY2Fubm90IHVzZSByZWdpc3RlcnMuXG4gICAgICAgIHRoaXMuQSA9IElWWzBdIHwgMDtcbiAgICAgICAgdGhpcy5CID0gSVZbMV0gfCAwO1xuICAgICAgICB0aGlzLkMgPSBJVlsyXSB8IDA7XG4gICAgICAgIHRoaXMuRCA9IElWWzNdIHwgMDtcbiAgICAgICAgdGhpcy5FID0gSVZbNF0gfCAwO1xuICAgICAgICB0aGlzLkYgPSBJVls1XSB8IDA7XG4gICAgICAgIHRoaXMuRyA9IElWWzZdIHwgMDtcbiAgICAgICAgdGhpcy5IID0gSVZbN10gfCAwO1xuICAgIH1cbiAgICBnZXQoKSB7XG4gICAgICAgIGNvbnN0IHsgQSwgQiwgQywgRCwgRSwgRiwgRywgSCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFtBLCBCLCBDLCBELCBFLCBGLCBHLCBIXTtcbiAgICB9XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpIHtcbiAgICAgICAgdGhpcy5BID0gQSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IEIgfCAwO1xuICAgICAgICB0aGlzLkMgPSBDIHwgMDtcbiAgICAgICAgdGhpcy5EID0gRCB8IDA7XG4gICAgICAgIHRoaXMuRSA9IEUgfCAwO1xuICAgICAgICB0aGlzLkYgPSBGIHwgMDtcbiAgICAgICAgdGhpcy5HID0gRyB8IDA7XG4gICAgICAgIHRoaXMuSCA9IEggfCAwO1xuICAgIH1cbiAgICBwcm9jZXNzKHZpZXcsIG9mZnNldCkge1xuICAgICAgICAvLyBFeHRlbmQgdGhlIGZpcnN0IDE2IHdvcmRzIGludG8gdGhlIHJlbWFpbmluZyA0OCB3b3JkcyB3WzE2Li42M10gb2YgdGhlIG1lc3NhZ2Ugc2NoZWR1bGUgYXJyYXlcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrLCBvZmZzZXQgKz0gNClcbiAgICAgICAgICAgIFNIQTI1Nl9XW2ldID0gdmlldy5nZXRVaW50MzIob2Zmc2V0LCBmYWxzZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAxNjsgaSA8IDY0OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IFcxNSA9IFNIQTI1Nl9XW2kgLSAxNV07XG4gICAgICAgICAgICBjb25zdCBXMiA9IFNIQTI1Nl9XW2kgLSAyXTtcbiAgICAgICAgICAgIGNvbnN0IHMwID0gcm90cihXMTUsIDcpIF4gcm90cihXMTUsIDE4KSBeIChXMTUgPj4+IDMpO1xuICAgICAgICAgICAgY29uc3QgczEgPSByb3RyKFcyLCAxNykgXiByb3RyKFcyLCAxOSkgXiAoVzIgPj4+IDEwKTtcbiAgICAgICAgICAgIFNIQTI1Nl9XW2ldID0gKHMxICsgU0hBMjU2X1dbaSAtIDddICsgczAgKyBTSEEyNTZfV1tpIC0gMTZdKSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcHJlc3Npb24gZnVuY3Rpb24gbWFpbiBsb29wLCA2NCByb3VuZHNcbiAgICAgICAgbGV0IHsgQSwgQiwgQywgRCwgRSwgRiwgRywgSCB9ID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2NDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTEgPSByb3RyKEUsIDYpIF4gcm90cihFLCAxMSkgXiByb3RyKEUsIDI1KTtcbiAgICAgICAgICAgIGNvbnN0IFQxID0gKEggKyBzaWdtYTEgKyBDaGkoRSwgRiwgRykgKyBTSEEyNTZfS1tpXSArIFNIQTI1Nl9XW2ldKSB8IDA7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTAgPSByb3RyKEEsIDIpIF4gcm90cihBLCAxMykgXiByb3RyKEEsIDIyKTtcbiAgICAgICAgICAgIGNvbnN0IFQyID0gKHNpZ21hMCArIE1haihBLCBCLCBDKSkgfCAwO1xuICAgICAgICAgICAgSCA9IEc7XG4gICAgICAgICAgICBHID0gRjtcbiAgICAgICAgICAgIEYgPSBFO1xuICAgICAgICAgICAgRSA9IChEICsgVDEpIHwgMDtcbiAgICAgICAgICAgIEQgPSBDO1xuICAgICAgICAgICAgQyA9IEI7XG4gICAgICAgICAgICBCID0gQTtcbiAgICAgICAgICAgIEEgPSAoVDEgKyBUMikgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgY29tcHJlc3NlZCBjaHVuayB0byB0aGUgY3VycmVudCBoYXNoIHZhbHVlXG4gICAgICAgIEEgPSAoQSArIHRoaXMuQSkgfCAwO1xuICAgICAgICBCID0gKEIgKyB0aGlzLkIpIHwgMDtcbiAgICAgICAgQyA9IChDICsgdGhpcy5DKSB8IDA7XG4gICAgICAgIEQgPSAoRCArIHRoaXMuRCkgfCAwO1xuICAgICAgICBFID0gKEUgKyB0aGlzLkUpIHwgMDtcbiAgICAgICAgRiA9IChGICsgdGhpcy5GKSB8IDA7XG4gICAgICAgIEcgPSAoRyArIHRoaXMuRykgfCAwO1xuICAgICAgICBIID0gKEggKyB0aGlzLkgpIHwgMDtcbiAgICAgICAgdGhpcy5zZXQoQSwgQiwgQywgRCwgRSwgRiwgRywgSCk7XG4gICAgfVxuICAgIHJvdW5kQ2xlYW4oKSB7XG4gICAgICAgIFNIQTI1Nl9XLmZpbGwoMCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgICAgICB0aGlzLmJ1ZmZlci5maWxsKDApO1xuICAgIH1cbn1cbi8vIENvbnN0YW50cyBmcm9tIGh0dHBzOi8vbnZscHVicy5uaXN0Lmdvdi9uaXN0cHVicy9GSVBTL05JU1QuRklQUy4xODAtNC5wZGZcbmNsYXNzIFNIQTIyNCBleHRlbmRzIFNIQTI1NiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuQSA9IDB4YzEwNTllZDggfCAwO1xuICAgICAgICB0aGlzLkIgPSAweDM2N2NkNTA3IHwgMDtcbiAgICAgICAgdGhpcy5DID0gMHgzMDcwZGQxNyB8IDA7XG4gICAgICAgIHRoaXMuRCA9IDB4ZjcwZTU5MzkgfCAwO1xuICAgICAgICB0aGlzLkUgPSAweGZmYzAwYjMxIHwgMDtcbiAgICAgICAgdGhpcy5GID0gMHg2ODU4MTUxMSB8IDA7XG4gICAgICAgIHRoaXMuRyA9IDB4NjRmOThmYTcgfCAwO1xuICAgICAgICB0aGlzLkggPSAweGJlZmE0ZmE0IHwgMDtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSAyODtcbiAgICB9XG59XG4vKipcbiAqIFNIQTItMjU2IGhhc2ggZnVuY3Rpb25cbiAqIEBwYXJhbSBtZXNzYWdlIC0gZGF0YSB0aGF0IHdvdWxkIGJlIGhhc2hlZFxuICovXG5leHBvcnQgY29uc3Qgc2hhMjU2ID0gLyogQF9fUFVSRV9fICovIHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgU0hBMjU2KCkpO1xuZXhwb3J0IGNvbnN0IHNoYTIyNCA9IC8qIEBfX1BVUkVfXyAqLyB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTIyNCgpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYTI1Ni5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/sha256.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js":
/*!*************************************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js ***!
  \*************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hash: () => (/* binding */ Hash),\n/* harmony export */   asyncLoop: () => (/* binding */ asyncLoop),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   checkOpts: () => (/* binding */ checkOpts),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createView: () => (/* binding */ createView),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   isLE: () => (/* binding */ isLE),\n/* harmony export */   nextTick: () => (/* binding */ nextTick),\n/* harmony export */   randomBytes: () => (/* binding */ randomBytes),\n/* harmony export */   rotr: () => (/* binding */ rotr),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   u32: () => (/* binding */ u32),\n/* harmony export */   u8: () => (/* binding */ u8),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   wrapConstructor: () => (/* binding */ wrapConstructor),\n/* harmony export */   wrapConstructorWithOpts: () => (/* binding */ wrapConstructorWithOpts),\n/* harmony export */   wrapXOFConstructorWithOpts: () => (/* binding */ wrapXOFConstructorWithOpts)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/crypto */ \"(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/crypto.js\");\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated, we can just drop the import.\n\nconst u8a = (a) => a instanceof Uint8Array;\n// Cast array to different type\nconst u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nconst u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nconst createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\nconst isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE)\n    throw new Error('Non little-endian hardware is not supported');\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    if (!u8a(bytes))\n        throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const len = hex.length;\n    if (len % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n    const array = new Uint8Array(len / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    if (!u8a(data))\n        throw new Error(`expected Uint8Array, got ${typeof data}`);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n    let pad = 0; // walk through each item, ensure they have proper type\n    arrays.forEach((a) => {\n        if (!u8a(a))\n            throw new Error('Uint8Array expected');\n        r.set(a, pad);\n        pad += a.length;\n    });\n    return r;\n}\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nconst toStr = {}.toString;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nfunction wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nfunction randomBytes(bytesLength = 32) {\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues === 'function') {\n        return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9zdHItZGV2LWtpdC9uZGsvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDOEM7QUFDOUM7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSwyQ0FBMkMsYUFBYTtBQUN4RDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSw0REFBNEQsV0FBVztBQUN2RSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsWUFBWTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNUO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFFBQVEsd0RBQU0sV0FBVyx3REFBTTtBQUMvQixlQUFlLHdEQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9sZmcvR2l0L01hZHRyaXBzL25vZGVfbW9kdWxlcy9Abm9zdHItZGV2LWtpdC9uZGsvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS91dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtaGFzaGVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBXZSB1c2UgV2ViQ3J5cHRvIGFrYSBnbG9iYWxUaGlzLmNyeXB0bywgd2hpY2ggZXhpc3RzIGluIGJyb3dzZXJzIGFuZCBub2RlLmpzIDE2Ky5cbi8vIG5vZGUuanMgdmVyc2lvbnMgZWFybGllciB0aGFuIHYxOSBkb24ndCBkZWNsYXJlIGl0IGluIGdsb2JhbCBzY29wZS5cbi8vIEZvciBub2RlLmpzLCBwYWNrYWdlLmpzb24jZXhwb3J0cyBmaWVsZCBtYXBwaW5nIHJld3JpdGVzIGltcG9ydFxuLy8gZnJvbSBgY3J5cHRvYCB0byBgY3J5cHRvTm9kZWAsIHdoaWNoIGltcG9ydHMgbmF0aXZlIG1vZHVsZS5cbi8vIE1ha2VzIHRoZSB1dGlscyB1bi1pbXBvcnRhYmxlIGluIGJyb3dzZXJzIHdpdGhvdXQgYSBidW5kbGVyLlxuLy8gT25jZSBub2RlLmpzIDE4IGlzIGRlcHJlY2F0ZWQsIHdlIGNhbiBqdXN0IGRyb3AgdGhlIGltcG9ydC5cbmltcG9ydCB7IGNyeXB0byB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvY3J5cHRvJztcbmNvbnN0IHU4YSA9IChhKSA9PiBhIGluc3RhbmNlb2YgVWludDhBcnJheTtcbi8vIENhc3QgYXJyYXkgdG8gZGlmZmVyZW50IHR5cGVcbmV4cG9ydCBjb25zdCB1OCA9IChhcnIpID0+IG5ldyBVaW50OEFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG5leHBvcnQgY29uc3QgdTMyID0gKGFycikgPT4gbmV3IFVpbnQzMkFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBNYXRoLmZsb29yKGFyci5ieXRlTGVuZ3RoIC8gNCkpO1xuLy8gQ2FzdCBhcnJheSB0byB2aWV3XG5leHBvcnQgY29uc3QgY3JlYXRlVmlldyA9IChhcnIpID0+IG5ldyBEYXRhVmlldyhhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xuLy8gVGhlIHJvdGF0ZSByaWdodCAoY2lyY3VsYXIgcmlnaHQgc2hpZnQpIG9wZXJhdGlvbiBmb3IgdWludDMyXG5leHBvcnQgY29uc3Qgcm90ciA9ICh3b3JkLCBzaGlmdCkgPT4gKHdvcmQgPDwgKDMyIC0gc2hpZnQpKSB8ICh3b3JkID4+PiBzaGlmdCk7XG4vLyBiaWctZW5kaWFuIGhhcmR3YXJlIGlzIHJhcmUuIEp1c3QgaW4gY2FzZSBzb21lb25lIHN0aWxsIGRlY2lkZXMgdG8gcnVuIGhhc2hlczpcbi8vIGVhcmx5LXRocm93IGFuIGVycm9yIGJlY2F1c2Ugd2UgZG9uJ3Qgc3VwcG9ydCBCRSB5ZXQuXG5leHBvcnQgY29uc3QgaXNMRSA9IG5ldyBVaW50OEFycmF5KG5ldyBVaW50MzJBcnJheShbMHgxMTIyMzM0NF0pLmJ1ZmZlcilbMF0gPT09IDB4NDQ7XG5pZiAoIWlzTEUpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb24gbGl0dGxlLWVuZGlhbiBoYXJkd2FyZSBpcyBub3Qgc3VwcG9ydGVkJyk7XG5jb25zdCBoZXhlcyA9IC8qIEBfX1BVUkVfXyAqLyBBcnJheS5mcm9tKHsgbGVuZ3RoOiAyNTYgfSwgKF8sIGkpID0+IGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuLyoqXG4gKiBAZXhhbXBsZSBieXRlc1RvSGV4KFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pKSAvLyAnY2FmZTAxMjMnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvSGV4KGJ5dGVzKSB7XG4gICAgaWYgKCF1OGEoYnl0ZXMpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAvLyBwcmUtY2FjaGluZyBpbXByb3ZlcyB0aGUgc3BlZWQgNnhcbiAgICBsZXQgaGV4ID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBoZXggKz0gaGV4ZXNbYnl0ZXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufVxuLyoqXG4gKiBAZXhhbXBsZSBoZXhUb0J5dGVzKCdjYWZlMDEyMycpIC8vIFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb0J5dGVzKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIGNvbnN0IGxlbiA9IGhleC5sZW5ndGg7XG4gICAgaWYgKGxlbiAlIDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGVkIGhleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCB1bnBhZGRlZCBoZXggb2YgbGVuZ3RoICcgKyBsZW4pO1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkobGVuIC8gMik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBqID0gaSAqIDI7XG4gICAgICAgIGNvbnN0IGhleEJ5dGUgPSBoZXguc2xpY2UoaiwgaiArIDIpO1xuICAgICAgICBjb25zdCBieXRlID0gTnVtYmVyLnBhcnNlSW50KGhleEJ5dGUsIDE2KTtcbiAgICAgICAgaWYgKE51bWJlci5pc05hTihieXRlKSB8fCBieXRlIDwgMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBieXRlIHNlcXVlbmNlJyk7XG4gICAgICAgIGFycmF5W2ldID0gYnl0ZTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuLy8gVGhlcmUgaXMgbm8gc2V0SW1tZWRpYXRlIGluIGJyb3dzZXIgYW5kIHNldFRpbWVvdXQgaXMgc2xvdy5cbi8vIGNhbGwgb2YgYXN5bmMgZm4gd2lsbCByZXR1cm4gUHJvbWlzZSwgd2hpY2ggd2lsbCBiZSBmdWxsZmlsZWQgb25seSBvblxuLy8gbmV4dCBzY2hlZHVsZXIgcXVldWUgcHJvY2Vzc2luZyBzdGVwIGFuZCB0aGlzIGlzIGV4YWN0bHkgd2hhdCB3ZSBuZWVkLlxuZXhwb3J0IGNvbnN0IG5leHRUaWNrID0gYXN5bmMgKCkgPT4geyB9O1xuLy8gUmV0dXJucyBjb250cm9sIHRvIHRocmVhZCBlYWNoICd0aWNrJyBtcyB0byBhdm9pZCBibG9ja2luZ1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFzeW5jTG9vcChpdGVycywgdGljaywgY2IpIHtcbiAgICBsZXQgdHMgPSBEYXRlLm5vdygpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcnM7IGkrKykge1xuICAgICAgICBjYihpKTtcbiAgICAgICAgLy8gRGF0ZS5ub3coKSBpcyBub3QgbW9ub3RvbmljLCBzbyBpbiBjYXNlIGlmIGNsb2NrIGdvZXMgYmFja3dhcmRzIHdlIHJldHVybiByZXR1cm4gY29udHJvbCB0b29cbiAgICAgICAgY29uc3QgZGlmZiA9IERhdGUubm93KCkgLSB0cztcbiAgICAgICAgaWYgKGRpZmYgPj0gMCAmJiBkaWZmIDwgdGljaylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBhd2FpdCBuZXh0VGljaygpO1xuICAgICAgICB0cyArPSBkaWZmO1xuICAgIH1cbn1cbi8qKlxuICogQGV4YW1wbGUgdXRmOFRvQnl0ZXMoJ2FiYycpIC8vIG5ldyBVaW50OEFycmF5KFs5NywgOTgsIDk5XSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1dGY4VG9CeXRlcyBleHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiBzdHJ9YCk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpKTsgLy8gaHR0cHM6Ly9idWd6aWwubGEvMTY4MTgwOVxufVxuLyoqXG4gKiBOb3JtYWxpemVzIChub24taGV4KSBzdHJpbmcgb3IgVWludDhBcnJheSB0byBVaW50OEFycmF5LlxuICogV2FybmluZzogd2hlbiBVaW50OEFycmF5IGlzIHBhc3NlZCwgaXQgd291bGQgTk9UIGdldCBjb3BpZWQuXG4gKiBLZWVwIGluIG1pbmQgZm9yIGZ1dHVyZSBtdXRhYmxlIG9wZXJhdGlvbnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0J5dGVzKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKVxuICAgICAgICBkYXRhID0gdXRmOFRvQnl0ZXMoZGF0YSk7XG4gICAgaWYgKCF1OGEoZGF0YSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgVWludDhBcnJheSwgZ290ICR7dHlwZW9mIGRhdGF9YCk7XG4gICAgcmV0dXJuIGRhdGE7XG59XG4vKipcbiAqIENvcGllcyBzZXZlcmFsIFVpbnQ4QXJyYXlzIGludG8gb25lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0Qnl0ZXMoLi4uYXJyYXlzKSB7XG4gICAgY29uc3QgciA9IG5ldyBVaW50OEFycmF5KGFycmF5cy5yZWR1Y2UoKHN1bSwgYSkgPT4gc3VtICsgYS5sZW5ndGgsIDApKTtcbiAgICBsZXQgcGFkID0gMDsgLy8gd2FsayB0aHJvdWdoIGVhY2ggaXRlbSwgZW5zdXJlIHRoZXkgaGF2ZSBwcm9wZXIgdHlwZVxuICAgIGFycmF5cy5mb3JFYWNoKChhKSA9PiB7XG4gICAgICAgIGlmICghdThhKGEpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgICAgIHIuc2V0KGEsIHBhZCk7XG4gICAgICAgIHBhZCArPSBhLmxlbmd0aDtcbiAgICB9KTtcbiAgICByZXR1cm4gcjtcbn1cbi8vIEZvciBydW50aW1lIGNoZWNrIGlmIGNsYXNzIGltcGxlbWVudHMgaW50ZXJmYWNlXG5leHBvcnQgY2xhc3MgSGFzaCB7XG4gICAgLy8gU2FmZSB2ZXJzaW9uIHRoYXQgY2xvbmVzIGludGVybmFsIHN0YXRlXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbG9uZUludG8oKTtcbiAgICB9XG59XG5jb25zdCB0b1N0ciA9IHt9LnRvU3RyaW5nO1xuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrT3B0cyhkZWZhdWx0cywgb3B0cykge1xuICAgIGlmIChvcHRzICE9PSB1bmRlZmluZWQgJiYgdG9TdHIuY2FsbChvcHRzKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignT3B0aW9ucyBzaG91bGQgYmUgb2JqZWN0IG9yIHVuZGVmaW5lZCcpO1xuICAgIGNvbnN0IG1lcmdlZCA9IE9iamVjdC5hc3NpZ24oZGVmYXVsdHMsIG9wdHMpO1xuICAgIHJldHVybiBtZXJnZWQ7XG59XG5leHBvcnQgZnVuY3Rpb24gd3JhcENvbnN0cnVjdG9yKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnKSA9PiBoYXNoQ29ucygpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKCk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAoKSA9PiBoYXNoQ29ucygpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbmV4cG9ydCBmdW5jdGlvbiB3cmFwQ29uc3RydWN0b3JXaXRoT3B0cyhoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZywgb3B0cykgPT4gaGFzaENvbnMob3B0cykudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoe30pO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKG9wdHMpID0+IGhhc2hDb25zKG9wdHMpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbmV4cG9ydCBmdW5jdGlvbiB3cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cyhoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZywgb3B0cykgPT4gaGFzaENvbnMob3B0cykudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoe30pO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKG9wdHMpID0+IGhhc2hDb25zKG9wdHMpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbi8qKlxuICogU2VjdXJlIFBSTkcuIFVzZXMgYGNyeXB0by5nZXRSYW5kb21WYWx1ZXNgLCB3aGljaCBkZWZlcnMgdG8gT1MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByYW5kb21CeXRlcyhieXRlc0xlbmd0aCA9IDMyKSB7XG4gICAgaWYgKGNyeXB0byAmJiB0eXBlb2YgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShieXRlc0xlbmd0aCkpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyeXB0by5nZXRSYW5kb21WYWx1ZXMgbXVzdCBiZSBkZWZpbmVkJyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/_assert.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/_assert.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bool: () => (/* binding */ bool),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   exists: () => (/* binding */ exists),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   output: () => (/* binding */ output)\n/* harmony export */ });\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`Wrong positive integer: ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`Expected boolean, not ${b}`);\n}\nfunction bytes(b, ...lengths) {\n    if (!(b instanceof Uint8Array))\n        throw new Error('Expected Uint8Array');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(hash) {\n    if (typeof hash !== 'function' || typeof hash.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(hash.outputLen);\n    number(hash.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\nconst assert = {\n    number,\n    bool,\n    bytes,\n    hash,\n    exists,\n    output,\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (assert);\n//# sourceMappingURL=_assert.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9zdHItZGV2LWtpdC9uZGsvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fYXNzZXJ0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBTztBQUNQO0FBQ0EsbURBQW1ELEVBQUU7QUFDckQ7QUFDTztBQUNQO0FBQ0EsaURBQWlELEVBQUU7QUFDbkQ7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxRQUFRLGtCQUFrQixTQUFTO0FBQzVGO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsSUFBSTtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFlLE1BQU0sRUFBQztBQUN0QiIsInNvdXJjZXMiOlsiL2hvbWUvbGZnL0dpdC9NYWR0cmlwcy9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX2Fzc2VydC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gbnVtYmVyKG4pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG4pIHx8IG4gPCAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdyb25nIHBvc2l0aXZlIGludGVnZXI6ICR7bn1gKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBib29sKGIpIHtcbiAgICBpZiAodHlwZW9mIGIgIT09ICdib29sZWFuJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBib29sZWFuLCBub3QgJHtifWApO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzKGIsIC4uLmxlbmd0aHMpIHtcbiAgICBpZiAoIShiIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgVWludDhBcnJheScpO1xuICAgIGlmIChsZW5ndGhzLmxlbmd0aCA+IDAgJiYgIWxlbmd0aHMuaW5jbHVkZXMoYi5sZW5ndGgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIFVpbnQ4QXJyYXkgb2YgbGVuZ3RoICR7bGVuZ3Roc30sIG5vdCBvZiBsZW5ndGg9JHtiLmxlbmd0aH1gKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoYXNoKGhhc2gpIHtcbiAgICBpZiAodHlwZW9mIGhhc2ggIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGhhc2guY3JlYXRlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggc2hvdWxkIGJlIHdyYXBwZWQgYnkgdXRpbHMud3JhcENvbnN0cnVjdG9yJyk7XG4gICAgbnVtYmVyKGhhc2gub3V0cHV0TGVuKTtcbiAgICBudW1iZXIoaGFzaC5ibG9ja0xlbik7XG59XG5leHBvcnQgZnVuY3Rpb24gZXhpc3RzKGluc3RhbmNlLCBjaGVja0ZpbmlzaGVkID0gdHJ1ZSkge1xuICAgIGlmIChpbnN0YW5jZS5kZXN0cm95ZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWQnKTtcbiAgICBpZiAoY2hlY2tGaW5pc2hlZCAmJiBpbnN0YW5jZS5maW5pc2hlZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoI2RpZ2VzdCgpIGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkJyk7XG59XG5leHBvcnQgZnVuY3Rpb24gb3V0cHV0KG91dCwgaW5zdGFuY2UpIHtcbiAgICBieXRlcyhvdXQpO1xuICAgIGNvbnN0IG1pbiA9IGluc3RhbmNlLm91dHB1dExlbjtcbiAgICBpZiAob3V0Lmxlbmd0aCA8IG1pbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGRpZ2VzdEludG8oKSBleHBlY3RzIG91dHB1dCBidWZmZXIgb2YgbGVuZ3RoIGF0IGxlYXN0ICR7bWlufWApO1xuICAgIH1cbn1cbmNvbnN0IGFzc2VydCA9IHtcbiAgICBudW1iZXIsXG4gICAgYm9vbCxcbiAgICBieXRlcyxcbiAgICBoYXNoLFxuICAgIGV4aXN0cyxcbiAgICBvdXRwdXQsXG59O1xuZXhwb3J0IGRlZmF1bHQgYXNzZXJ0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X2Fzc2VydC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/_assert.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/_sha2.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/_sha2.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHA2: () => (/* binding */ SHA2)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nclass SHA2 extends _utils_js__WEBPACK_IMPORTED_MODULE_1__.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createView)(this.buffer);\n    }\n    update(data) {\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].exists(this);\n        const { view, buffer, blockLen } = this;\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createView)(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].exists(this);\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].output(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n//# sourceMappingURL=_sha2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9zdHItZGV2LWtpdC9uZGsvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fc2hhMi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBa0M7QUFDcUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLG1CQUFtQiwyQ0FBSTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFEQUFVO0FBQzlCO0FBQ0E7QUFDQSxRQUFRLHlEQUFhO0FBQ3JCLGdCQUFnQix5QkFBeUI7QUFDekMsZUFBZSxrREFBTztBQUN0QjtBQUNBLDBCQUEwQixVQUFVO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxxREFBVTtBQUMzQyx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx5REFBYTtBQUNyQixRQUFRLHlEQUFhO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtCQUErQjtBQUMvQyxjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGNBQWM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFEQUFVO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscURBQXFEO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9sZmcvR2l0L01hZHRyaXBzL25vZGVfbW9kdWxlcy9Abm9zdHItZGV2LWtpdC9uZGsvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fc2hhMi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYXNzZXJ0IGZyb20gJy4vX2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBIYXNoLCBjcmVhdGVWaWV3LCB0b0J5dGVzIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBQb2x5ZmlsbCBmb3IgU2FmYXJpIDE0XG5mdW5jdGlvbiBzZXRCaWdVaW50NjQodmlldywgYnl0ZU9mZnNldCwgdmFsdWUsIGlzTEUpIHtcbiAgICBpZiAodHlwZW9mIHZpZXcuc2V0QmlnVWludDY0ID09PSAnZnVuY3Rpb24nKVxuICAgICAgICByZXR1cm4gdmlldy5zZXRCaWdVaW50NjQoYnl0ZU9mZnNldCwgdmFsdWUsIGlzTEUpO1xuICAgIGNvbnN0IF8zMm4gPSBCaWdJbnQoMzIpO1xuICAgIGNvbnN0IF91MzJfbWF4ID0gQmlnSW50KDB4ZmZmZmZmZmYpO1xuICAgIGNvbnN0IHdoID0gTnVtYmVyKCh2YWx1ZSA+PiBfMzJuKSAmIF91MzJfbWF4KTtcbiAgICBjb25zdCB3bCA9IE51bWJlcih2YWx1ZSAmIF91MzJfbWF4KTtcbiAgICBjb25zdCBoID0gaXNMRSA/IDQgOiAwO1xuICAgIGNvbnN0IGwgPSBpc0xFID8gMCA6IDQ7XG4gICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGgsIHdoLCBpc0xFKTtcbiAgICB2aWV3LnNldFVpbnQzMihieXRlT2Zmc2V0ICsgbCwgd2wsIGlzTEUpO1xufVxuLy8gQmFzZSBTSEEyIGNsYXNzIChSRkMgNjIzNClcbmV4cG9ydCBjbGFzcyBTSEEyIGV4dGVuZHMgSGFzaCB7XG4gICAgY29uc3RydWN0b3IoYmxvY2tMZW4sIG91dHB1dExlbiwgcGFkT2Zmc2V0LCBpc0xFKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRoaXMucGFkT2Zmc2V0ID0gcGFkT2Zmc2V0O1xuICAgICAgICB0aGlzLmlzTEUgPSBpc0xFO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGJsb2NrTGVuKTtcbiAgICAgICAgdGhpcy52aWV3ID0gY3JlYXRlVmlldyh0aGlzLmJ1ZmZlcik7XG4gICAgfVxuICAgIHVwZGF0ZShkYXRhKSB7XG4gICAgICAgIGFzc2VydC5leGlzdHModGhpcyk7XG4gICAgICAgIGNvbnN0IHsgdmlldywgYnVmZmVyLCBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgICAgZGF0YSA9IHRvQnl0ZXMoZGF0YSk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW47KSB7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvcywgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIC8vIEZhc3QgcGF0aDogd2UgaGF2ZSBhdCBsZWFzdCBvbmUgYmxvY2sgaW4gaW5wdXQsIGNhc3QgaXQgdG8gdmlldyBhbmQgcHJvY2Vzc1xuICAgICAgICAgICAgaWYgKHRha2UgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YVZpZXcgPSBjcmVhdGVWaWV3KGRhdGEpO1xuICAgICAgICAgICAgICAgIGZvciAoOyBibG9ja0xlbiA8PSBsZW4gLSBwb3M7IHBvcyArPSBibG9ja0xlbilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzKGRhdGFWaWV3LCBwb3MpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmZmVyLnNldChkYXRhLnN1YmFycmF5KHBvcywgcG9zICsgdGFrZSksIHRoaXMucG9zKTtcbiAgICAgICAgICAgIHRoaXMucG9zICs9IHRha2U7XG4gICAgICAgICAgICBwb3MgKz0gdGFrZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA9PT0gYmxvY2tMZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubGVuZ3RoICs9IGRhdGEubGVuZ3RoO1xuICAgICAgICB0aGlzLnJvdW5kQ2xlYW4oKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgIGFzc2VydC5leGlzdHModGhpcyk7XG4gICAgICAgIGFzc2VydC5vdXRwdXQob3V0LCB0aGlzKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIC8vIFBhZGRpbmdcbiAgICAgICAgLy8gV2UgY2FuIGF2b2lkIGFsbG9jYXRpb24gb2YgYnVmZmVyIGZvciBwYWRkaW5nIGNvbXBsZXRlbHkgaWYgaXRcbiAgICAgICAgLy8gd2FzIHByZXZpb3VzbHkgbm90IGFsbG9jYXRlZCBoZXJlLiBCdXQgaXQgd29uJ3QgY2hhbmdlIHBlcmZvcm1hbmNlLlxuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgdmlldywgYmxvY2tMZW4sIGlzTEUgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IHBvcyB9ID0gdGhpcztcbiAgICAgICAgLy8gYXBwZW5kIHRoZSBiaXQgJzEnIHRvIHRoZSBtZXNzYWdlXG4gICAgICAgIGJ1ZmZlcltwb3MrK10gPSAwYjEwMDAwMDAwO1xuICAgICAgICB0aGlzLmJ1ZmZlci5zdWJhcnJheShwb3MpLmZpbGwoMCk7XG4gICAgICAgIC8vIHdlIGhhdmUgbGVzcyB0aGFuIHBhZE9mZnNldCBsZWZ0IGluIGJ1ZmZlciwgc28gd2UgY2Fubm90IHB1dCBsZW5ndGggaW4gY3VycmVudCBibG9jaywgbmVlZCBwcm9jZXNzIGl0IGFuZCBwYWQgYWdhaW5cbiAgICAgICAgaWYgKHRoaXMucGFkT2Zmc2V0ID4gYmxvY2tMZW4gLSBwb3MpIHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgICAgIHBvcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUGFkIHVudGlsIGZ1bGwgYmxvY2sgYnl0ZSB3aXRoIHplcm9zXG4gICAgICAgIGZvciAobGV0IGkgPSBwb3M7IGkgPCBibG9ja0xlbjsgaSsrKVxuICAgICAgICAgICAgYnVmZmVyW2ldID0gMDtcbiAgICAgICAgLy8gTm90ZTogc2hhNTEyIHJlcXVpcmVzIGxlbmd0aCB0byBiZSAxMjhiaXQgaW50ZWdlciwgYnV0IGxlbmd0aCBpbiBKUyB3aWxsIG92ZXJmbG93IGJlZm9yZSB0aGF0XG4gICAgICAgIC8vIFlvdSBuZWVkIHRvIHdyaXRlIGFyb3VuZCAyIGV4YWJ5dGVzICh1NjRfbWF4IC8gOCAvICgxMDI0Kio2KSkgZm9yIHRoaXMgdG8gaGFwcGVuLlxuICAgICAgICAvLyBTbyB3ZSBqdXN0IHdyaXRlIGxvd2VzdCA2NCBiaXRzIG9mIHRoYXQgdmFsdWUuXG4gICAgICAgIHNldEJpZ1VpbnQ2NCh2aWV3LCBibG9ja0xlbiAtIDgsIEJpZ0ludCh0aGlzLmxlbmd0aCAqIDgpLCBpc0xFKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICBjb25zdCBvdmlldyA9IGNyZWF0ZVZpZXcob3V0KTtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5vdXRwdXRMZW47XG4gICAgICAgIC8vIE5PVEU6IHdlIGRvIGRpdmlzaW9uIGJ5IDQgbGF0ZXIsIHdoaWNoIHNob3VsZCBiZSBmdXNlZCBpbiBzaW5nbGUgb3Agd2l0aCBtb2R1bG8gYnkgSklUXG4gICAgICAgIGlmIChsZW4gJSA0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfc2hhMjogb3V0cHV0TGVuIHNob3VsZCBiZSBhbGlnbmVkIHRvIDMyYml0Jyk7XG4gICAgICAgIGNvbnN0IG91dExlbiA9IGxlbiAvIDQ7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXQoKTtcbiAgICAgICAgaWYgKG91dExlbiA+IHN0YXRlLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX3NoYTI6IG91dHB1dExlbiBiaWdnZXIgdGhhbiBzdGF0ZScpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dExlbjsgaSsrKVxuICAgICAgICAgICAgb3ZpZXcuc2V0VWludDMyKDQgKiBpLCBzdGF0ZVtpXSwgaXNMRSk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3QgeyBidWZmZXIsIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5kaWdlc3RJbnRvKGJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IHJlcyA9IGJ1ZmZlci5zbGljZSgwLCBvdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICB0byB8fCAodG8gPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpKTtcbiAgICAgICAgdG8uc2V0KC4uLnRoaXMuZ2V0KCkpO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBidWZmZXIsIGxlbmd0aCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgcG9zIH0gPSB0aGlzO1xuICAgICAgICB0by5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRvLnBvcyA9IHBvcztcbiAgICAgICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gZGVzdHJveWVkO1xuICAgICAgICBpZiAobGVuZ3RoICUgYmxvY2tMZW4pXG4gICAgICAgICAgICB0by5idWZmZXIuc2V0KGJ1ZmZlcik7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fc2hhMi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/_sha2.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/crypto.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/crypto.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   crypto: () => (/* binding */ crypto)\n/* harmony export */ });\nconst crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n//# sourceMappingURL=crypto.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9zdHItZGV2LWtpdC9uZGsvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9jcnlwdG8uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPO0FBQ1AiLCJzb3VyY2VzIjpbIi9ob21lL2xmZy9HaXQvTWFkdHJpcHMvbm9kZV9tb2R1bGVzL0Bub3N0ci1kZXYta2l0L25kay9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2NyeXB0by5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgY3J5cHRvID0gdHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnICYmICdjcnlwdG8nIGluIGdsb2JhbFRoaXMgPyBnbG9iYWxUaGlzLmNyeXB0byA6IHVuZGVmaW5lZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyeXB0by5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/crypto.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/hkdf.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/hkdf.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   expand: () => (/* binding */ expand),\n/* harmony export */   extract: () => (/* binding */ extract),\n/* harmony export */   hkdf: () => (/* binding */ hkdf)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _hmac_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./hmac.js */ \"(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/hmac.js\");\n\n\n\n// HKDF (RFC 5869)\n// https://soatok.blog/2021/11/17/understanding-hkdf/\n/**\n * HKDF-Extract(IKM, salt) -> PRK\n * Arguments position differs from spec (IKM is first one, since it is not optional)\n * @param hash\n * @param ikm\n * @param salt\n * @returns\n */\nfunction extract(hash, ikm, salt) {\n    _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].hash(hash);\n    // NOTE: some libraries treat zero-length array as 'not provided';\n    // we don't, since we have undefined as 'not provided'\n    // https://github.com/RustCrypto/KDFs/issues/15\n    if (salt === undefined)\n        salt = new Uint8Array(hash.outputLen); // if not provided, it is set to a string of HashLen zeros\n    return (0,_hmac_js__WEBPACK_IMPORTED_MODULE_2__.hmac)(hash, (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(salt), (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(ikm));\n}\n// HKDF-Expand(PRK, info, L) -> OKM\nconst HKDF_COUNTER = new Uint8Array([0]);\nconst EMPTY_BUFFER = new Uint8Array();\n/**\n * HKDF-expand from the spec.\n * @param prk - a pseudorandom key of at least HashLen octets (usually, the output from the extract step)\n * @param info - optional context and application specific information (can be a zero-length string)\n * @param length - length of output keying material in octets\n */\nfunction expand(hash, prk, info, length = 32) {\n    _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].hash(hash);\n    _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].number(length);\n    if (length > 255 * hash.outputLen)\n        throw new Error('Length should be <= 255*HashLen');\n    const blocks = Math.ceil(length / hash.outputLen);\n    if (info === undefined)\n        info = EMPTY_BUFFER;\n    // first L(ength) octets of T\n    const okm = new Uint8Array(blocks * hash.outputLen);\n    // Re-use HMAC instance between blocks\n    const HMAC = _hmac_js__WEBPACK_IMPORTED_MODULE_2__.hmac.create(hash, prk);\n    const HMACTmp = HMAC._cloneInto();\n    const T = new Uint8Array(HMAC.outputLen);\n    for (let counter = 0; counter < blocks; counter++) {\n        HKDF_COUNTER[0] = counter + 1;\n        // T(0) = empty string (zero length)\n        // T(N) = HMAC-Hash(PRK, T(N-1) | info | N)\n        HMACTmp.update(counter === 0 ? EMPTY_BUFFER : T)\n            .update(info)\n            .update(HKDF_COUNTER)\n            .digestInto(T);\n        okm.set(T, hash.outputLen * counter);\n        HMAC._cloneInto(HMACTmp);\n    }\n    HMAC.destroy();\n    HMACTmp.destroy();\n    T.fill(0);\n    HKDF_COUNTER.fill(0);\n    return okm.slice(0, length);\n}\n/**\n * HKDF (RFC 5869): extract + expand in one step.\n * @param hash - hash function that would be used (e.g. sha256)\n * @param ikm - input keying material, the initial key\n * @param salt - optional salt value (a non-secret random value)\n * @param info - optional context and application specific information\n * @param length - length of output keying material in octets\n */\nconst hkdf = (hash, ikm, salt, info, length) => expand(hash, extract(hash, ikm, salt), info, length);\n//# sourceMappingURL=hkdf.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9zdHItZGV2LWtpdC9uZGsvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9oa2RmLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFrQztBQUNHO0FBQ0o7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLElBQUksdURBQVc7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQyxXQUFXLDhDQUFJLE9BQU8sa0RBQU8sUUFBUSxrREFBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsSUFBSSx1REFBVztBQUNmLElBQUkseURBQWE7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwwQ0FBSTtBQUNyQjtBQUNBO0FBQ0EsMEJBQTBCLGtCQUFrQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQIiwic291cmNlcyI6WyIvaG9tZS9sZmcvR2l0L01hZHRyaXBzL25vZGVfbW9kdWxlcy9Abm9zdHItZGV2LWtpdC9uZGsvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9oa2RmLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBhc3NlcnQgZnJvbSAnLi9fYXNzZXJ0LmpzJztcbmltcG9ydCB7IHRvQnl0ZXMgfSBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7IGhtYWMgfSBmcm9tICcuL2htYWMuanMnO1xuLy8gSEtERiAoUkZDIDU4NjkpXG4vLyBodHRwczovL3NvYXRvay5ibG9nLzIwMjEvMTEvMTcvdW5kZXJzdGFuZGluZy1oa2RmL1xuLyoqXG4gKiBIS0RGLUV4dHJhY3QoSUtNLCBzYWx0KSAtPiBQUktcbiAqIEFyZ3VtZW50cyBwb3NpdGlvbiBkaWZmZXJzIGZyb20gc3BlYyAoSUtNIGlzIGZpcnN0IG9uZSwgc2luY2UgaXQgaXMgbm90IG9wdGlvbmFsKVxuICogQHBhcmFtIGhhc2hcbiAqIEBwYXJhbSBpa21cbiAqIEBwYXJhbSBzYWx0XG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdChoYXNoLCBpa20sIHNhbHQpIHtcbiAgICBhc3NlcnQuaGFzaChoYXNoKTtcbiAgICAvLyBOT1RFOiBzb21lIGxpYnJhcmllcyB0cmVhdCB6ZXJvLWxlbmd0aCBhcnJheSBhcyAnbm90IHByb3ZpZGVkJztcbiAgICAvLyB3ZSBkb24ndCwgc2luY2Ugd2UgaGF2ZSB1bmRlZmluZWQgYXMgJ25vdCBwcm92aWRlZCdcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vUnVzdENyeXB0by9LREZzL2lzc3Vlcy8xNVxuICAgIGlmIChzYWx0ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHNhbHQgPSBuZXcgVWludDhBcnJheShoYXNoLm91dHB1dExlbik7IC8vIGlmIG5vdCBwcm92aWRlZCwgaXQgaXMgc2V0IHRvIGEgc3RyaW5nIG9mIEhhc2hMZW4gemVyb3NcbiAgICByZXR1cm4gaG1hYyhoYXNoLCB0b0J5dGVzKHNhbHQpLCB0b0J5dGVzKGlrbSkpO1xufVxuLy8gSEtERi1FeHBhbmQoUFJLLCBpbmZvLCBMKSAtPiBPS01cbmNvbnN0IEhLREZfQ09VTlRFUiA9IG5ldyBVaW50OEFycmF5KFswXSk7XG5jb25zdCBFTVBUWV9CVUZGRVIgPSBuZXcgVWludDhBcnJheSgpO1xuLyoqXG4gKiBIS0RGLWV4cGFuZCBmcm9tIHRoZSBzcGVjLlxuICogQHBhcmFtIHByayAtIGEgcHNldWRvcmFuZG9tIGtleSBvZiBhdCBsZWFzdCBIYXNoTGVuIG9jdGV0cyAodXN1YWxseSwgdGhlIG91dHB1dCBmcm9tIHRoZSBleHRyYWN0IHN0ZXApXG4gKiBAcGFyYW0gaW5mbyAtIG9wdGlvbmFsIGNvbnRleHQgYW5kIGFwcGxpY2F0aW9uIHNwZWNpZmljIGluZm9ybWF0aW9uIChjYW4gYmUgYSB6ZXJvLWxlbmd0aCBzdHJpbmcpXG4gKiBAcGFyYW0gbGVuZ3RoIC0gbGVuZ3RoIG9mIG91dHB1dCBrZXlpbmcgbWF0ZXJpYWwgaW4gb2N0ZXRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHBhbmQoaGFzaCwgcHJrLCBpbmZvLCBsZW5ndGggPSAzMikge1xuICAgIGFzc2VydC5oYXNoKGhhc2gpO1xuICAgIGFzc2VydC5udW1iZXIobGVuZ3RoKTtcbiAgICBpZiAobGVuZ3RoID4gMjU1ICogaGFzaC5vdXRwdXRMZW4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTGVuZ3RoIHNob3VsZCBiZSA8PSAyNTUqSGFzaExlbicpO1xuICAgIGNvbnN0IGJsb2NrcyA9IE1hdGguY2VpbChsZW5ndGggLyBoYXNoLm91dHB1dExlbik7XG4gICAgaWYgKGluZm8gPT09IHVuZGVmaW5lZClcbiAgICAgICAgaW5mbyA9IEVNUFRZX0JVRkZFUjtcbiAgICAvLyBmaXJzdCBMKGVuZ3RoKSBvY3RldHMgb2YgVFxuICAgIGNvbnN0IG9rbSA9IG5ldyBVaW50OEFycmF5KGJsb2NrcyAqIGhhc2gub3V0cHV0TGVuKTtcbiAgICAvLyBSZS11c2UgSE1BQyBpbnN0YW5jZSBiZXR3ZWVuIGJsb2Nrc1xuICAgIGNvbnN0IEhNQUMgPSBobWFjLmNyZWF0ZShoYXNoLCBwcmspO1xuICAgIGNvbnN0IEhNQUNUbXAgPSBITUFDLl9jbG9uZUludG8oKTtcbiAgICBjb25zdCBUID0gbmV3IFVpbnQ4QXJyYXkoSE1BQy5vdXRwdXRMZW4pO1xuICAgIGZvciAobGV0IGNvdW50ZXIgPSAwOyBjb3VudGVyIDwgYmxvY2tzOyBjb3VudGVyKyspIHtcbiAgICAgICAgSEtERl9DT1VOVEVSWzBdID0gY291bnRlciArIDE7XG4gICAgICAgIC8vIFQoMCkgPSBlbXB0eSBzdHJpbmcgKHplcm8gbGVuZ3RoKVxuICAgICAgICAvLyBUKE4pID0gSE1BQy1IYXNoKFBSSywgVChOLTEpIHwgaW5mbyB8IE4pXG4gICAgICAgIEhNQUNUbXAudXBkYXRlKGNvdW50ZXIgPT09IDAgPyBFTVBUWV9CVUZGRVIgOiBUKVxuICAgICAgICAgICAgLnVwZGF0ZShpbmZvKVxuICAgICAgICAgICAgLnVwZGF0ZShIS0RGX0NPVU5URVIpXG4gICAgICAgICAgICAuZGlnZXN0SW50byhUKTtcbiAgICAgICAgb2ttLnNldChULCBoYXNoLm91dHB1dExlbiAqIGNvdW50ZXIpO1xuICAgICAgICBITUFDLl9jbG9uZUludG8oSE1BQ1RtcCk7XG4gICAgfVxuICAgIEhNQUMuZGVzdHJveSgpO1xuICAgIEhNQUNUbXAuZGVzdHJveSgpO1xuICAgIFQuZmlsbCgwKTtcbiAgICBIS0RGX0NPVU5URVIuZmlsbCgwKTtcbiAgICByZXR1cm4gb2ttLnNsaWNlKDAsIGxlbmd0aCk7XG59XG4vKipcbiAqIEhLREYgKFJGQyA1ODY5KTogZXh0cmFjdCArIGV4cGFuZCBpbiBvbmUgc3RlcC5cbiAqIEBwYXJhbSBoYXNoIC0gaGFzaCBmdW5jdGlvbiB0aGF0IHdvdWxkIGJlIHVzZWQgKGUuZy4gc2hhMjU2KVxuICogQHBhcmFtIGlrbSAtIGlucHV0IGtleWluZyBtYXRlcmlhbCwgdGhlIGluaXRpYWwga2V5XG4gKiBAcGFyYW0gc2FsdCAtIG9wdGlvbmFsIHNhbHQgdmFsdWUgKGEgbm9uLXNlY3JldCByYW5kb20gdmFsdWUpXG4gKiBAcGFyYW0gaW5mbyAtIG9wdGlvbmFsIGNvbnRleHQgYW5kIGFwcGxpY2F0aW9uIHNwZWNpZmljIGluZm9ybWF0aW9uXG4gKiBAcGFyYW0gbGVuZ3RoIC0gbGVuZ3RoIG9mIG91dHB1dCBrZXlpbmcgbWF0ZXJpYWwgaW4gb2N0ZXRzXG4gKi9cbmV4cG9ydCBjb25zdCBoa2RmID0gKGhhc2gsIGlrbSwgc2FsdCwgaW5mbywgbGVuZ3RoKSA9PiBleHBhbmQoaGFzaCwgZXh0cmFjdChoYXNoLCBpa20sIHNhbHQpLCBpbmZvLCBsZW5ndGgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGtkZi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/hkdf.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/hmac.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/hmac.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HMAC: () => (/* binding */ HMAC),\n/* harmony export */   hmac: () => (/* binding */ hmac)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// HMAC (RFC 2104)\nclass HMAC extends _utils_js__WEBPACK_IMPORTED_MODULE_1__.Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].hash(hash);\n        const key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].exists(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].exists(this);\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].bytes(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */\nconst hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key) => new HMAC(hash, key);\n//# sourceMappingURL=hmac.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9zdHItZGV2LWtpdC9uZGsvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9obWFjLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBa0M7QUFDUztBQUMzQztBQUNPLG1CQUFtQiwyQ0FBSTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQVc7QUFDbkIsb0JBQW9CLGtEQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEseURBQWE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlEQUFhO0FBQ3JCLFFBQVEsd0RBQVk7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakUsZ0JBQWdCLHlEQUF5RDtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2xmZy9HaXQvTWFkdHJpcHMvbm9kZV9tb2R1bGVzL0Bub3N0ci1kZXYta2l0L25kay9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2htYWMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGFzc2VydCBmcm9tICcuL19hc3NlcnQuanMnO1xuaW1wb3J0IHsgSGFzaCwgdG9CeXRlcyB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gSE1BQyAoUkZDIDIxMDQpXG5leHBvcnQgY2xhc3MgSE1BQyBleHRlbmRzIEhhc2gge1xuICAgIGNvbnN0cnVjdG9yKGhhc2gsIF9rZXkpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICBhc3NlcnQuaGFzaChoYXNoKTtcbiAgICAgICAgY29uc3Qga2V5ID0gdG9CeXRlcyhfa2V5KTtcbiAgICAgICAgdGhpcy5pSGFzaCA9IGhhc2guY3JlYXRlKCk7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5pSGFzaC51cGRhdGUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGluc3RhbmNlIG9mIGNsYXNzIHdoaWNoIGV4dGVuZHMgdXRpbHMuSGFzaCcpO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gdGhpcy5pSGFzaC5ibG9ja0xlbjtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSB0aGlzLmlIYXNoLm91dHB1dExlbjtcbiAgICAgICAgY29uc3QgYmxvY2tMZW4gPSB0aGlzLmJsb2NrTGVuO1xuICAgICAgICBjb25zdCBwYWQgPSBuZXcgVWludDhBcnJheShibG9ja0xlbik7XG4gICAgICAgIC8vIGJsb2NrTGVuIGNhbiBiZSBiaWdnZXIgdGhhbiBvdXRwdXRMZW5cbiAgICAgICAgcGFkLnNldChrZXkubGVuZ3RoID4gYmxvY2tMZW4gPyBoYXNoLmNyZWF0ZSgpLnVwZGF0ZShrZXkpLmRpZ2VzdCgpIDoga2V5KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBwYWRbaV0gXj0gMHgzNjtcbiAgICAgICAgdGhpcy5pSGFzaC51cGRhdGUocGFkKTtcbiAgICAgICAgLy8gQnkgZG9pbmcgdXBkYXRlIChwcm9jZXNzaW5nIG9mIGZpcnN0IGJsb2NrKSBvZiBvdXRlciBoYXNoIGhlcmUgd2UgY2FuIHJlLXVzZSBpdCBiZXR3ZWVuIG11bHRpcGxlIGNhbGxzIHZpYSBjbG9uZVxuICAgICAgICB0aGlzLm9IYXNoID0gaGFzaC5jcmVhdGUoKTtcbiAgICAgICAgLy8gVW5kbyBpbnRlcm5hbCBYT1IgJiYgYXBwbHkgb3V0ZXIgWE9SXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcGFkW2ldIF49IDB4MzYgXiAweDVjO1xuICAgICAgICB0aGlzLm9IYXNoLnVwZGF0ZShwYWQpO1xuICAgICAgICBwYWQuZmlsbCgwKTtcbiAgICB9XG4gICAgdXBkYXRlKGJ1Zikge1xuICAgICAgICBhc3NlcnQuZXhpc3RzKHRoaXMpO1xuICAgICAgICB0aGlzLmlIYXNoLnVwZGF0ZShidWYpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgYXNzZXJ0LmV4aXN0cyh0aGlzKTtcbiAgICAgICAgYXNzZXJ0LmJ5dGVzKG91dCwgdGhpcy5vdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pSGFzaC5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHRoaXMub0hhc2gudXBkYXRlKG91dCk7XG4gICAgICAgIHRoaXMub0hhc2guZGlnZXN0SW50byhvdXQpO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICBjb25zdCBvdXQgPSBuZXcgVWludDhBcnJheSh0aGlzLm9IYXNoLm91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZGlnZXN0SW50byhvdXQpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIC8vIENyZWF0ZSBuZXcgaW5zdGFuY2Ugd2l0aG91dCBjYWxsaW5nIGNvbnN0cnVjdG9yIHNpbmNlIGtleSBhbHJlYWR5IGluIHN0YXRlIGFuZCB3ZSBkb24ndCBrbm93IGl0LlxuICAgICAgICB0byB8fCAodG8gPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSwge30pKTtcbiAgICAgICAgY29uc3QgeyBvSGFzaCwgaUhhc2gsIGZpbmlzaGVkLCBkZXN0cm95ZWQsIGJsb2NrTGVuLCBvdXRwdXRMZW4gfSA9IHRoaXM7XG4gICAgICAgIHRvID0gdG87XG4gICAgICAgIHRvLmZpbmlzaGVkID0gZmluaXNoZWQ7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IGRlc3Ryb3llZDtcbiAgICAgICAgdG8uYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdG8ub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0by5vSGFzaCA9IG9IYXNoLl9jbG9uZUludG8odG8ub0hhc2gpO1xuICAgICAgICB0by5pSGFzaCA9IGlIYXNoLl9jbG9uZUludG8odG8uaUhhc2gpO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vSGFzaC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuaUhhc2guZGVzdHJveSgpO1xuICAgIH1cbn1cbi8qKlxuICogSE1BQzogUkZDMjEwNCBtZXNzYWdlIGF1dGhlbnRpY2F0aW9uIGNvZGUuXG4gKiBAcGFyYW0gaGFzaCAtIGZ1bmN0aW9uIHRoYXQgd291bGQgYmUgdXNlZCBlLmcuIHNoYTI1NlxuICogQHBhcmFtIGtleSAtIG1lc3NhZ2Uga2V5XG4gKiBAcGFyYW0gbWVzc2FnZSAtIG1lc3NhZ2UgZGF0YVxuICovXG5leHBvcnQgY29uc3QgaG1hYyA9IChoYXNoLCBrZXksIG1lc3NhZ2UpID0+IG5ldyBITUFDKGhhc2gsIGtleSkudXBkYXRlKG1lc3NhZ2UpLmRpZ2VzdCgpO1xuaG1hYy5jcmVhdGUgPSAoaGFzaCwga2V5KSA9PiBuZXcgSE1BQyhoYXNoLCBrZXkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aG1hYy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/hmac.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/sha256.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/sha256.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sha224: () => (/* binding */ sha224),\n/* harmony export */   sha256: () => (/* binding */ sha256)\n/* harmony export */ });\n/* harmony import */ var _sha2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_sha2.js */ \"(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/_sha2.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// Choice: a ? b : c\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = new Uint32Array(64);\nclass SHA256 extends _sha2_js__WEBPACK_IMPORTED_MODULE_0__.SHA2 {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = IV[0] | 0;\n        this.B = IV[1] | 0;\n        this.C = IV[2] | 0;\n        this.D = IV[3] | 0;\n        this.E = IV[4] | 0;\n        this.F = IV[5] | 0;\n        this.G = IV[6] | 0;\n        this.H = IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 7) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 18) ^ (W15 >>> 3);\n            const s1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 17) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 6) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 11) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 2) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 13) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nconst sha256 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA256());\nconst sha224 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA224());\n//# sourceMappingURL=sha256.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9zdHItZGV2LWtpdC9uZGsvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGEyNTYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFrQztBQUNpQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwwQ0FBSTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlCQUF5QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQSx1QkFBdUIsK0NBQUksV0FBVywrQ0FBSTtBQUMxQyx1QkFBdUIsK0NBQUksV0FBVywrQ0FBSTtBQUMxQztBQUNBO0FBQ0E7QUFDQSxjQUFjLHlCQUF5QjtBQUN2Qyx3QkFBd0IsUUFBUTtBQUNoQywyQkFBMkIsK0NBQUksU0FBUywrQ0FBSSxVQUFVLCtDQUFJO0FBQzFEO0FBQ0EsMkJBQTJCLCtDQUFJLFNBQVMsK0NBQUksVUFBVSwrQ0FBSTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxlQUFlLDBEQUFlO0FBQzlCLGVBQWUsMERBQWU7QUFDckMiLCJzb3VyY2VzIjpbIi9ob21lL2xmZy9HaXQvTWFkdHJpcHMvbm9kZV9tb2R1bGVzL0Bub3N0ci1kZXYta2l0L25kay9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTI1Ni5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTSEEyIH0gZnJvbSAnLi9fc2hhMi5qcyc7XG5pbXBvcnQgeyByb3RyLCB3cmFwQ29uc3RydWN0b3IgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIENob2ljZTogYSA/IGIgOiBjXG5jb25zdCBDaGkgPSAoYSwgYiwgYykgPT4gKGEgJiBiKSBeICh+YSAmIGMpO1xuLy8gTWFqb3JpdHkgZnVuY3Rpb24sIHRydWUgaWYgYW55IHR3byBpbnB1c3QgaXMgdHJ1ZVxuY29uc3QgTWFqID0gKGEsIGIsIGMpID0+IChhICYgYikgXiAoYSAmIGMpIF4gKGIgJiBjKTtcbi8vIFJvdW5kIGNvbnN0YW50czpcbi8vIGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIGN1YmUgcm9vdHMgb2YgdGhlIGZpcnN0IDY0IHByaW1lcyAyLi4zMTEpXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IFNIQTI1Nl9LID0gbmV3IFVpbnQzMkFycmF5KFtcbiAgICAweDQyOGEyZjk4LCAweDcxMzc0NDkxLCAweGI1YzBmYmNmLCAweGU5YjVkYmE1LCAweDM5NTZjMjViLCAweDU5ZjExMWYxLCAweDkyM2Y4MmE0LCAweGFiMWM1ZWQ1LFxuICAgIDB4ZDgwN2FhOTgsIDB4MTI4MzViMDEsIDB4MjQzMTg1YmUsIDB4NTUwYzdkYzMsIDB4NzJiZTVkNzQsIDB4ODBkZWIxZmUsIDB4OWJkYzA2YTcsIDB4YzE5YmYxNzQsXG4gICAgMHhlNDliNjljMSwgMHhlZmJlNDc4NiwgMHgwZmMxOWRjNiwgMHgyNDBjYTFjYywgMHgyZGU5MmM2ZiwgMHg0YTc0ODRhYSwgMHg1Y2IwYTlkYywgMHg3NmY5ODhkYSxcbiAgICAweDk4M2U1MTUyLCAweGE4MzFjNjZkLCAweGIwMDMyN2M4LCAweGJmNTk3ZmM3LCAweGM2ZTAwYmYzLCAweGQ1YTc5MTQ3LCAweDA2Y2E2MzUxLCAweDE0MjkyOTY3LFxuICAgIDB4MjdiNzBhODUsIDB4MmUxYjIxMzgsIDB4NGQyYzZkZmMsIDB4NTMzODBkMTMsIDB4NjUwYTczNTQsIDB4NzY2YTBhYmIsIDB4ODFjMmM5MmUsIDB4OTI3MjJjODUsXG4gICAgMHhhMmJmZThhMSwgMHhhODFhNjY0YiwgMHhjMjRiOGI3MCwgMHhjNzZjNTFhMywgMHhkMTkyZTgxOSwgMHhkNjk5MDYyNCwgMHhmNDBlMzU4NSwgMHgxMDZhYTA3MCxcbiAgICAweDE5YTRjMTE2LCAweDFlMzc2YzA4LCAweDI3NDg3NzRjLCAweDM0YjBiY2I1LCAweDM5MWMwY2IzLCAweDRlZDhhYTRhLCAweDViOWNjYTRmLCAweDY4MmU2ZmYzLFxuICAgIDB4NzQ4ZjgyZWUsIDB4NzhhNTYzNmYsIDB4ODRjODc4MTQsIDB4OGNjNzAyMDgsIDB4OTBiZWZmZmEsIDB4YTQ1MDZjZWIsIDB4YmVmOWEzZjcsIDB4YzY3MTc4ZjJcbl0pO1xuLy8gSW5pdGlhbCBzdGF0ZSAoZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgc3F1YXJlIHJvb3RzIG9mIHRoZSBmaXJzdCA4IHByaW1lcyAyLi4xOSk6XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IElWID0gbmV3IFVpbnQzMkFycmF5KFtcbiAgICAweDZhMDllNjY3LCAweGJiNjdhZTg1LCAweDNjNmVmMzcyLCAweGE1NGZmNTNhLCAweDUxMGU1MjdmLCAweDliMDU2ODhjLCAweDFmODNkOWFiLCAweDViZTBjZDE5XG5dKTtcbi8vIFRlbXBvcmFyeSBidWZmZXIsIG5vdCB1c2VkIHRvIHN0b3JlIGFueXRoaW5nIGJldHdlZW4gcnVuc1xuLy8gTmFtZWQgdGhpcyB3YXkgYmVjYXVzZSBpdCBtYXRjaGVzIHNwZWNpZmljYXRpb24uXG5jb25zdCBTSEEyNTZfVyA9IG5ldyBVaW50MzJBcnJheSg2NCk7XG5jbGFzcyBTSEEyNTYgZXh0ZW5kcyBTSEEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoNjQsIDMyLCA4LCBmYWxzZSk7XG4gICAgICAgIC8vIFdlIGNhbm5vdCB1c2UgYXJyYXkgaGVyZSBzaW5jZSBhcnJheSBhbGxvd3MgaW5kZXhpbmcgYnkgdmFyaWFibGVcbiAgICAgICAgLy8gd2hpY2ggbWVhbnMgb3B0aW1pemVyL2NvbXBpbGVyIGNhbm5vdCB1c2UgcmVnaXN0ZXJzLlxuICAgICAgICB0aGlzLkEgPSBJVlswXSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IElWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5DID0gSVZbMl0gfCAwO1xuICAgICAgICB0aGlzLkQgPSBJVlszXSB8IDA7XG4gICAgICAgIHRoaXMuRSA9IElWWzRdIHwgMDtcbiAgICAgICAgdGhpcy5GID0gSVZbNV0gfCAwO1xuICAgICAgICB0aGlzLkcgPSBJVls2XSB8IDA7XG4gICAgICAgIHRoaXMuSCA9IElWWzddIHwgMDtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbQSwgQiwgQywgRCwgRSwgRiwgRywgSF07XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIHNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKSB7XG4gICAgICAgIHRoaXMuQSA9IEEgfCAwO1xuICAgICAgICB0aGlzLkIgPSBCIHwgMDtcbiAgICAgICAgdGhpcy5DID0gQyB8IDA7XG4gICAgICAgIHRoaXMuRCA9IEQgfCAwO1xuICAgICAgICB0aGlzLkUgPSBFIHwgMDtcbiAgICAgICAgdGhpcy5GID0gRiB8IDA7XG4gICAgICAgIHRoaXMuRyA9IEcgfCAwO1xuICAgICAgICB0aGlzLkggPSBIIHwgMDtcbiAgICB9XG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgLy8gRXh0ZW5kIHRoZSBmaXJzdCAxNiB3b3JkcyBpbnRvIHRoZSByZW1haW5pbmcgNDggd29yZHMgd1sxNi4uNjNdIG9mIHRoZSBtZXNzYWdlIHNjaGVkdWxlIGFycmF5XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpXG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCwgZmFsc2UpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA2NDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBXMTUgPSBTSEEyNTZfV1tpIC0gMTVdO1xuICAgICAgICAgICAgY29uc3QgVzIgPSBTSEEyNTZfV1tpIC0gMl07XG4gICAgICAgICAgICBjb25zdCBzMCA9IHJvdHIoVzE1LCA3KSBeIHJvdHIoVzE1LCAxOCkgXiAoVzE1ID4+PiAzKTtcbiAgICAgICAgICAgIGNvbnN0IHMxID0gcm90cihXMiwgMTcpIF4gcm90cihXMiwgMTkpIF4gKFcyID4+PiAxMCk7XG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IChzMSArIFNIQTI1Nl9XW2kgLSA3XSArIHMwICsgU0hBMjU2X1dbaSAtIDE2XSkgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXByZXNzaW9uIGZ1bmN0aW9uIG1haW4gbG9vcCwgNjQgcm91bmRzXG4gICAgICAgIGxldCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc2lnbWExID0gcm90cihFLCA2KSBeIHJvdHIoRSwgMTEpIF4gcm90cihFLCAyNSk7XG4gICAgICAgICAgICBjb25zdCBUMSA9IChIICsgc2lnbWExICsgQ2hpKEUsIEYsIEcpICsgU0hBMjU2X0tbaV0gKyBTSEEyNTZfV1tpXSkgfCAwO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWEwID0gcm90cihBLCAyKSBeIHJvdHIoQSwgMTMpIF4gcm90cihBLCAyMik7XG4gICAgICAgICAgICBjb25zdCBUMiA9IChzaWdtYTAgKyBNYWooQSwgQiwgQykpIHwgMDtcbiAgICAgICAgICAgIEggPSBHO1xuICAgICAgICAgICAgRyA9IEY7XG4gICAgICAgICAgICBGID0gRTtcbiAgICAgICAgICAgIEUgPSAoRCArIFQxKSB8IDA7XG4gICAgICAgICAgICBEID0gQztcbiAgICAgICAgICAgIEMgPSBCO1xuICAgICAgICAgICAgQiA9IEE7XG4gICAgICAgICAgICBBID0gKFQxICsgVDIpIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICBBID0gKEEgKyB0aGlzLkEpIHwgMDtcbiAgICAgICAgQiA9IChCICsgdGhpcy5CKSB8IDA7XG4gICAgICAgIEMgPSAoQyArIHRoaXMuQykgfCAwO1xuICAgICAgICBEID0gKEQgKyB0aGlzLkQpIHwgMDtcbiAgICAgICAgRSA9IChFICsgdGhpcy5FKSB8IDA7XG4gICAgICAgIEYgPSAoRiArIHRoaXMuRikgfCAwO1xuICAgICAgICBHID0gKEcgKyB0aGlzLkcpIHwgMDtcbiAgICAgICAgSCA9IChIICsgdGhpcy5IKSB8IDA7XG4gICAgICAgIHRoaXMuc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpO1xuICAgIH1cbiAgICByb3VuZENsZWFuKCkge1xuICAgICAgICBTSEEyNTZfVy5maWxsKDApO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICAgICAgdGhpcy5idWZmZXIuZmlsbCgwKTtcbiAgICB9XG59XG4vLyBDb25zdGFudHMgZnJvbSBodHRwczovL252bHB1YnMubmlzdC5nb3YvbmlzdHB1YnMvRklQUy9OSVNULkZJUFMuMTgwLTQucGRmXG5jbGFzcyBTSEEyMjQgZXh0ZW5kcyBTSEEyNTYge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLkEgPSAweGMxMDU5ZWQ4IHwgMDtcbiAgICAgICAgdGhpcy5CID0gMHgzNjdjZDUwNyB8IDA7XG4gICAgICAgIHRoaXMuQyA9IDB4MzA3MGRkMTcgfCAwO1xuICAgICAgICB0aGlzLkQgPSAweGY3MGU1OTM5IHwgMDtcbiAgICAgICAgdGhpcy5FID0gMHhmZmMwMGIzMSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IDB4Njg1ODE1MTEgfCAwO1xuICAgICAgICB0aGlzLkcgPSAweDY0Zjk4ZmE3IHwgMDtcbiAgICAgICAgdGhpcy5IID0gMHhiZWZhNGZhNCB8IDA7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gMjg7XG4gICAgfVxufVxuLyoqXG4gKiBTSEEyLTI1NiBoYXNoIGZ1bmN0aW9uXG4gKiBAcGFyYW0gbWVzc2FnZSAtIGRhdGEgdGhhdCB3b3VsZCBiZSBoYXNoZWRcbiAqL1xuZXhwb3J0IGNvbnN0IHNoYTI1NiA9IHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgU0hBMjU2KCkpO1xuZXhwb3J0IGNvbnN0IHNoYTIyNCA9IHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgU0hBMjI0KCkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhMjU2LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/sha256.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/utils.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/utils.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hash: () => (/* binding */ Hash),\n/* harmony export */   asyncLoop: () => (/* binding */ asyncLoop),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   checkOpts: () => (/* binding */ checkOpts),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createView: () => (/* binding */ createView),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   isLE: () => (/* binding */ isLE),\n/* harmony export */   nextTick: () => (/* binding */ nextTick),\n/* harmony export */   randomBytes: () => (/* binding */ randomBytes),\n/* harmony export */   rotr: () => (/* binding */ rotr),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   u32: () => (/* binding */ u32),\n/* harmony export */   u8: () => (/* binding */ u8),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   wrapConstructor: () => (/* binding */ wrapConstructor),\n/* harmony export */   wrapConstructorWithOpts: () => (/* binding */ wrapConstructorWithOpts),\n/* harmony export */   wrapXOFConstructorWithOpts: () => (/* binding */ wrapXOFConstructorWithOpts)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/crypto */ \"(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/crypto.js\");\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated, we can just drop the import.\n\nconst u8a = (a) => a instanceof Uint8Array;\n// Cast array to different type\nconst u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nconst u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nconst createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\nconst isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE)\n    throw new Error('Non little-endian hardware is not supported');\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    if (!u8a(bytes))\n        throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const len = hex.length;\n    if (len % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n    const array = new Uint8Array(len / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    if (!u8a(data))\n        throw new Error(`expected Uint8Array, got ${typeof data}`);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n    let pad = 0; // walk through each item, ensure they have proper type\n    arrays.forEach((a) => {\n        if (!u8a(a))\n            throw new Error('Uint8Array expected');\n        r.set(a, pad);\n        pad += a.length;\n    });\n    return r;\n}\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\n// Check if object doens't have custom constructor (like Uint8Array/Array)\nconst isPlainObject = (obj) => Object.prototype.toString.call(obj) === '[object Object]' && obj.constructor === Object;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && (typeof opts !== 'object' || !isPlainObject(opts)))\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nfunction wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nfunction randomBytes(bytesLength = 32) {\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues === 'function') {\n        return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9zdHItZGV2LWtpdC9uZGsvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDOEM7QUFDOUM7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSw0REFBNEQsV0FBVztBQUN2RSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsWUFBWTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxRQUFRLHdEQUFNLFdBQVcsd0RBQU07QUFDL0IsZUFBZSx3REFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbGZnL0dpdC9NYWR0cmlwcy9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vdXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWhhc2hlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gV2UgdXNlIFdlYkNyeXB0byBha2EgZ2xvYmFsVGhpcy5jcnlwdG8sIHdoaWNoIGV4aXN0cyBpbiBicm93c2VycyBhbmQgbm9kZS5qcyAxNisuXG4vLyBub2RlLmpzIHZlcnNpb25zIGVhcmxpZXIgdGhhbiB2MTkgZG9uJ3QgZGVjbGFyZSBpdCBpbiBnbG9iYWwgc2NvcGUuXG4vLyBGb3Igbm9kZS5qcywgcGFja2FnZS5qc29uI2V4cG9ydHMgZmllbGQgbWFwcGluZyByZXdyaXRlcyBpbXBvcnRcbi8vIGZyb20gYGNyeXB0b2AgdG8gYGNyeXB0b05vZGVgLCB3aGljaCBpbXBvcnRzIG5hdGl2ZSBtb2R1bGUuXG4vLyBNYWtlcyB0aGUgdXRpbHMgdW4taW1wb3J0YWJsZSBpbiBicm93c2VycyB3aXRob3V0IGEgYnVuZGxlci5cbi8vIE9uY2Ugbm9kZS5qcyAxOCBpcyBkZXByZWNhdGVkLCB3ZSBjYW4ganVzdCBkcm9wIHRoZSBpbXBvcnQuXG5pbXBvcnQgeyBjcnlwdG8gfSBmcm9tICdAbm9ibGUvaGFzaGVzL2NyeXB0byc7XG5jb25zdCB1OGEgPSAoYSkgPT4gYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XG4vLyBDYXN0IGFycmF5IHRvIGRpZmZlcmVudCB0eXBlXG5leHBvcnQgY29uc3QgdTggPSAoYXJyKSA9PiBuZXcgVWludDhBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xuZXhwb3J0IGNvbnN0IHUzMiA9IChhcnIpID0+IG5ldyBVaW50MzJBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgTWF0aC5mbG9vcihhcnIuYnl0ZUxlbmd0aCAvIDQpKTtcbi8vIENhc3QgYXJyYXkgdG8gdmlld1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVZpZXcgPSAoYXJyKSA9PiBuZXcgRGF0YVZpZXcoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbi8vIFRoZSByb3RhdGUgcmlnaHQgKGNpcmN1bGFyIHJpZ2h0IHNoaWZ0KSBvcGVyYXRpb24gZm9yIHVpbnQzMlxuZXhwb3J0IGNvbnN0IHJvdHIgPSAod29yZCwgc2hpZnQpID0+ICh3b3JkIDw8ICgzMiAtIHNoaWZ0KSkgfCAod29yZCA+Pj4gc2hpZnQpO1xuLy8gYmlnLWVuZGlhbiBoYXJkd2FyZSBpcyByYXJlLiBKdXN0IGluIGNhc2Ugc29tZW9uZSBzdGlsbCBkZWNpZGVzIHRvIHJ1biBoYXNoZXM6XG4vLyBlYXJseS10aHJvdyBhbiBlcnJvciBiZWNhdXNlIHdlIGRvbid0IHN1cHBvcnQgQkUgeWV0LlxuZXhwb3J0IGNvbnN0IGlzTEUgPSBuZXcgVWludDhBcnJheShuZXcgVWludDMyQXJyYXkoWzB4MTEyMjMzNDRdKS5idWZmZXIpWzBdID09PSAweDQ0O1xuaWYgKCFpc0xFKVxuICAgIHRocm93IG5ldyBFcnJvcignTm9uIGxpdHRsZS1lbmRpYW4gaGFyZHdhcmUgaXMgbm90IHN1cHBvcnRlZCcpO1xuY29uc3QgaGV4ZXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAyNTYgfSwgKHYsIGkpID0+IGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuLyoqXG4gKiBAZXhhbXBsZSBieXRlc1RvSGV4KFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pKSAvLyAnY2FmZTAxMjMnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvSGV4KGJ5dGVzKSB7XG4gICAgaWYgKCF1OGEoYnl0ZXMpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAvLyBwcmUtY2FjaGluZyBpbXByb3ZlcyB0aGUgc3BlZWQgNnhcbiAgICBsZXQgaGV4ID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBoZXggKz0gaGV4ZXNbYnl0ZXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufVxuLyoqXG4gKiBAZXhhbXBsZSBoZXhUb0J5dGVzKCdjYWZlMDEyMycpIC8vIFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb0J5dGVzKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIGNvbnN0IGxlbiA9IGhleC5sZW5ndGg7XG4gICAgaWYgKGxlbiAlIDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGVkIGhleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCB1bnBhZGRlZCBoZXggb2YgbGVuZ3RoICcgKyBsZW4pO1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkobGVuIC8gMik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBqID0gaSAqIDI7XG4gICAgICAgIGNvbnN0IGhleEJ5dGUgPSBoZXguc2xpY2UoaiwgaiArIDIpO1xuICAgICAgICBjb25zdCBieXRlID0gTnVtYmVyLnBhcnNlSW50KGhleEJ5dGUsIDE2KTtcbiAgICAgICAgaWYgKE51bWJlci5pc05hTihieXRlKSB8fCBieXRlIDwgMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBieXRlIHNlcXVlbmNlJyk7XG4gICAgICAgIGFycmF5W2ldID0gYnl0ZTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuLy8gVGhlcmUgaXMgbm8gc2V0SW1tZWRpYXRlIGluIGJyb3dzZXIgYW5kIHNldFRpbWVvdXQgaXMgc2xvdy5cbi8vIGNhbGwgb2YgYXN5bmMgZm4gd2lsbCByZXR1cm4gUHJvbWlzZSwgd2hpY2ggd2lsbCBiZSBmdWxsZmlsZWQgb25seSBvblxuLy8gbmV4dCBzY2hlZHVsZXIgcXVldWUgcHJvY2Vzc2luZyBzdGVwIGFuZCB0aGlzIGlzIGV4YWN0bHkgd2hhdCB3ZSBuZWVkLlxuZXhwb3J0IGNvbnN0IG5leHRUaWNrID0gYXN5bmMgKCkgPT4geyB9O1xuLy8gUmV0dXJucyBjb250cm9sIHRvIHRocmVhZCBlYWNoICd0aWNrJyBtcyB0byBhdm9pZCBibG9ja2luZ1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFzeW5jTG9vcChpdGVycywgdGljaywgY2IpIHtcbiAgICBsZXQgdHMgPSBEYXRlLm5vdygpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcnM7IGkrKykge1xuICAgICAgICBjYihpKTtcbiAgICAgICAgLy8gRGF0ZS5ub3coKSBpcyBub3QgbW9ub3RvbmljLCBzbyBpbiBjYXNlIGlmIGNsb2NrIGdvZXMgYmFja3dhcmRzIHdlIHJldHVybiByZXR1cm4gY29udHJvbCB0b29cbiAgICAgICAgY29uc3QgZGlmZiA9IERhdGUubm93KCkgLSB0cztcbiAgICAgICAgaWYgKGRpZmYgPj0gMCAmJiBkaWZmIDwgdGljaylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBhd2FpdCBuZXh0VGljaygpO1xuICAgICAgICB0cyArPSBkaWZmO1xuICAgIH1cbn1cbi8qKlxuICogQGV4YW1wbGUgdXRmOFRvQnl0ZXMoJ2FiYycpIC8vIG5ldyBVaW50OEFycmF5KFs5NywgOTgsIDk5XSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1dGY4VG9CeXRlcyBleHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiBzdHJ9YCk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpKTsgLy8gaHR0cHM6Ly9idWd6aWwubGEvMTY4MTgwOVxufVxuLyoqXG4gKiBOb3JtYWxpemVzIChub24taGV4KSBzdHJpbmcgb3IgVWludDhBcnJheSB0byBVaW50OEFycmF5LlxuICogV2FybmluZzogd2hlbiBVaW50OEFycmF5IGlzIHBhc3NlZCwgaXQgd291bGQgTk9UIGdldCBjb3BpZWQuXG4gKiBLZWVwIGluIG1pbmQgZm9yIGZ1dHVyZSBtdXRhYmxlIG9wZXJhdGlvbnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0J5dGVzKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKVxuICAgICAgICBkYXRhID0gdXRmOFRvQnl0ZXMoZGF0YSk7XG4gICAgaWYgKCF1OGEoZGF0YSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgVWludDhBcnJheSwgZ290ICR7dHlwZW9mIGRhdGF9YCk7XG4gICAgcmV0dXJuIGRhdGE7XG59XG4vKipcbiAqIENvcGllcyBzZXZlcmFsIFVpbnQ4QXJyYXlzIGludG8gb25lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0Qnl0ZXMoLi4uYXJyYXlzKSB7XG4gICAgY29uc3QgciA9IG5ldyBVaW50OEFycmF5KGFycmF5cy5yZWR1Y2UoKHN1bSwgYSkgPT4gc3VtICsgYS5sZW5ndGgsIDApKTtcbiAgICBsZXQgcGFkID0gMDsgLy8gd2FsayB0aHJvdWdoIGVhY2ggaXRlbSwgZW5zdXJlIHRoZXkgaGF2ZSBwcm9wZXIgdHlwZVxuICAgIGFycmF5cy5mb3JFYWNoKChhKSA9PiB7XG4gICAgICAgIGlmICghdThhKGEpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgICAgIHIuc2V0KGEsIHBhZCk7XG4gICAgICAgIHBhZCArPSBhLmxlbmd0aDtcbiAgICB9KTtcbiAgICByZXR1cm4gcjtcbn1cbi8vIEZvciBydW50aW1lIGNoZWNrIGlmIGNsYXNzIGltcGxlbWVudHMgaW50ZXJmYWNlXG5leHBvcnQgY2xhc3MgSGFzaCB7XG4gICAgLy8gU2FmZSB2ZXJzaW9uIHRoYXQgY2xvbmVzIGludGVybmFsIHN0YXRlXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbG9uZUludG8oKTtcbiAgICB9XG59XG4vLyBDaGVjayBpZiBvYmplY3QgZG9lbnMndCBoYXZlIGN1c3RvbSBjb25zdHJ1Y3RvciAobGlrZSBVaW50OEFycmF5L0FycmF5KVxuY29uc3QgaXNQbGFpbk9iamVjdCA9IChvYmopID0+IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBPYmplY3RdJyAmJiBvYmouY29uc3RydWN0b3IgPT09IE9iamVjdDtcbmV4cG9ydCBmdW5jdGlvbiBjaGVja09wdHMoZGVmYXVsdHMsIG9wdHMpIHtcbiAgICBpZiAob3B0cyAhPT0gdW5kZWZpbmVkICYmICh0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcgfHwgIWlzUGxhaW5PYmplY3Qob3B0cykpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09wdGlvbnMgc2hvdWxkIGJlIG9iamVjdCBvciB1bmRlZmluZWQnKTtcbiAgICBjb25zdCBtZXJnZWQgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRzLCBvcHRzKTtcbiAgICByZXR1cm4gbWVyZ2VkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBDb25zdHJ1Y3RvcihoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZykgPT4gaGFzaENvbnMoKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucygpO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKCkgPT4gaGFzaENvbnMoKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnQgZnVuY3Rpb24gd3JhcENvbnN0cnVjdG9yV2l0aE9wdHMoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIG9wdHMpID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKHt9KTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9IChvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnQgZnVuY3Rpb24gd3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIG9wdHMpID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKHt9KTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9IChvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG4vKipcbiAqIFNlY3VyZSBQUk5HLiBVc2VzIGBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzYCwgd2hpY2ggZGVmZXJzIHRvIE9TLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tQnl0ZXMoYnl0ZXNMZW5ndGggPSAzMikge1xuICAgIGlmIChjcnlwdG8gJiYgdHlwZW9mIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoYnl0ZXNMZW5ndGgpKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIG11c3QgYmUgZGVmaW5lZCcpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@scure/base/lib/esm/index.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@scure/base/lib/esm/index.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertNumber: () => (/* binding */ assertNumber),\n/* harmony export */   base16: () => (/* binding */ base16),\n/* harmony export */   base32: () => (/* binding */ base32),\n/* harmony export */   base32crockford: () => (/* binding */ base32crockford),\n/* harmony export */   base32hex: () => (/* binding */ base32hex),\n/* harmony export */   base58: () => (/* binding */ base58),\n/* harmony export */   base58check: () => (/* binding */ base58check),\n/* harmony export */   base58flickr: () => (/* binding */ base58flickr),\n/* harmony export */   base58xmr: () => (/* binding */ base58xmr),\n/* harmony export */   base58xrp: () => (/* binding */ base58xrp),\n/* harmony export */   base64: () => (/* binding */ base64),\n/* harmony export */   base64url: () => (/* binding */ base64url),\n/* harmony export */   bech32: () => (/* binding */ bech32),\n/* harmony export */   bech32m: () => (/* binding */ bech32m),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   bytesToString: () => (/* binding */ bytesToString),\n/* harmony export */   hex: () => (/* binding */ hex),\n/* harmony export */   str: () => (/* binding */ str),\n/* harmony export */   stringToBytes: () => (/* binding */ stringToBytes),\n/* harmony export */   utf8: () => (/* binding */ utf8),\n/* harmony export */   utils: () => (/* binding */ utils)\n/* harmony export */ });\n/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nfunction assertNumber(n) {\n    if (!Number.isSafeInteger(n))\n        throw new Error(`Wrong integer: ${n}`);\n}\nfunction chain(...args) {\n    const wrap = (a, b) => (c) => a(b(c));\n    const encode = Array.from(args)\n        .reverse()\n        .reduce((acc, i) => (acc ? wrap(acc, i.encode) : i.encode), undefined);\n    const decode = args.reduce((acc, i) => (acc ? wrap(acc, i.decode) : i.decode), undefined);\n    return { encode, decode };\n}\nfunction alphabet(alphabet) {\n    return {\n        encode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('alphabet.encode input should be an array of numbers');\n            return digits.map((i) => {\n                assertNumber(i);\n                if (i < 0 || i >= alphabet.length)\n                    throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet.length})`);\n                return alphabet[i];\n            });\n        },\n        decode: (input) => {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('alphabet.decode input should be array of strings');\n            return input.map((letter) => {\n                if (typeof letter !== 'string')\n                    throw new Error(`alphabet.decode: not string element=${letter}`);\n                const index = alphabet.indexOf(letter);\n                if (index === -1)\n                    throw new Error(`Unknown letter: \"${letter}\". Allowed: ${alphabet}`);\n                return index;\n            });\n        },\n    };\n}\nfunction join(separator = '') {\n    if (typeof separator !== 'string')\n        throw new Error('join separator should be string');\n    return {\n        encode: (from) => {\n            if (!Array.isArray(from) || (from.length && typeof from[0] !== 'string'))\n                throw new Error('join.encode input should be array of strings');\n            for (let i of from)\n                if (typeof i !== 'string')\n                    throw new Error(`join.encode: non-string input=${i}`);\n            return from.join(separator);\n        },\n        decode: (to) => {\n            if (typeof to !== 'string')\n                throw new Error('join.decode input should be string');\n            return to.split(separator);\n        },\n    };\n}\nfunction padding(bits, chr = '=') {\n    assertNumber(bits);\n    if (typeof chr !== 'string')\n        throw new Error('padding chr should be string');\n    return {\n        encode(data) {\n            if (!Array.isArray(data) || (data.length && typeof data[0] !== 'string'))\n                throw new Error('padding.encode input should be array of strings');\n            for (let i of data)\n                if (typeof i !== 'string')\n                    throw new Error(`padding.encode: non-string input=${i}`);\n            while ((data.length * bits) % 8)\n                data.push(chr);\n            return data;\n        },\n        decode(input) {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('padding.encode input should be array of strings');\n            for (let i of input)\n                if (typeof i !== 'string')\n                    throw new Error(`padding.decode: non-string input=${i}`);\n            let end = input.length;\n            if ((end * bits) % 8)\n                throw new Error('Invalid padding: string should have whole number of bytes');\n            for (; end > 0 && input[end - 1] === chr; end--) {\n                if (!(((end - 1) * bits) % 8))\n                    throw new Error('Invalid padding: string has too much padding');\n            }\n            return input.slice(0, end);\n        },\n    };\n}\nfunction normalize(fn) {\n    if (typeof fn !== 'function')\n        throw new Error('normalize fn should be function');\n    return { encode: (from) => from, decode: (to) => fn(to) };\n}\nfunction convertRadix(data, from, to) {\n    if (from < 2)\n        throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);\n    if (to < 2)\n        throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);\n    if (!Array.isArray(data))\n        throw new Error('convertRadix: data should be array');\n    if (!data.length)\n        return [];\n    let pos = 0;\n    const res = [];\n    const digits = Array.from(data);\n    digits.forEach((d) => {\n        assertNumber(d);\n        if (d < 0 || d >= from)\n            throw new Error(`Wrong integer: ${d}`);\n    });\n    while (true) {\n        let carry = 0;\n        let done = true;\n        for (let i = pos; i < digits.length; i++) {\n            const digit = digits[i];\n            const digitBase = from * carry + digit;\n            if (!Number.isSafeInteger(digitBase) ||\n                (from * carry) / from !== carry ||\n                digitBase - digit !== from * carry) {\n                throw new Error('convertRadix: carry overflow');\n            }\n            carry = digitBase % to;\n            digits[i] = Math.floor(digitBase / to);\n            if (!Number.isSafeInteger(digits[i]) || digits[i] * to + carry !== digitBase)\n                throw new Error('convertRadix: carry overflow');\n            if (!done)\n                continue;\n            else if (!digits[i])\n                pos = i;\n            else\n                done = false;\n        }\n        res.push(carry);\n        if (done)\n            break;\n    }\n    for (let i = 0; i < data.length - 1 && data[i] === 0; i++)\n        res.push(0);\n    return res.reverse();\n}\nconst gcd = (a, b) => (!b ? a : gcd(b, a % b));\nconst radix2carry = (from, to) => from + (to - gcd(from, to));\nfunction convertRadix2(data, from, to, padding) {\n    if (!Array.isArray(data))\n        throw new Error('convertRadix2: data should be array');\n    if (from <= 0 || from > 32)\n        throw new Error(`convertRadix2: wrong from=${from}`);\n    if (to <= 0 || to > 32)\n        throw new Error(`convertRadix2: wrong to=${to}`);\n    if (radix2carry(from, to) > 32) {\n        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);\n    }\n    let carry = 0;\n    let pos = 0;\n    const mask = 2 ** to - 1;\n    const res = [];\n    for (const n of data) {\n        assertNumber(n);\n        if (n >= 2 ** from)\n            throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n        carry = (carry << from) | n;\n        if (pos + from > 32)\n            throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n        pos += from;\n        for (; pos >= to; pos -= to)\n            res.push(((carry >> (pos - to)) & mask) >>> 0);\n        carry &= 2 ** pos - 1;\n    }\n    carry = (carry << (to - pos)) & mask;\n    if (!padding && pos >= from)\n        throw new Error('Excess padding');\n    if (!padding && carry)\n        throw new Error(`Non-zero padding: ${carry}`);\n    if (padding && pos > 0)\n        res.push(carry >>> 0);\n    return res;\n}\nfunction radix(num) {\n    assertNumber(num);\n    return {\n        encode: (bytes) => {\n            if (!(bytes instanceof Uint8Array))\n                throw new Error('radix.encode input should be Uint8Array');\n            return convertRadix(Array.from(bytes), 2 ** 8, num);\n        },\n        decode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('radix.decode input should be array of strings');\n            return Uint8Array.from(convertRadix(digits, num, 2 ** 8));\n        },\n    };\n}\nfunction radix2(bits, revPadding = false) {\n    assertNumber(bits);\n    if (bits <= 0 || bits > 32)\n        throw new Error('radix2: bits should be in (0..32]');\n    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)\n        throw new Error('radix2: carry overflow');\n    return {\n        encode: (bytes) => {\n            if (!(bytes instanceof Uint8Array))\n                throw new Error('radix2.encode input should be Uint8Array');\n            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n        },\n        decode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('radix2.decode input should be array of strings');\n            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n        },\n    };\n}\nfunction unsafeWrapper(fn) {\n    if (typeof fn !== 'function')\n        throw new Error('unsafeWrapper fn should be function');\n    return function (...args) {\n        try {\n            return fn.apply(null, args);\n        }\n        catch (e) { }\n    };\n}\nfunction checksum(len, fn) {\n    assertNumber(len);\n    if (typeof fn !== 'function')\n        throw new Error('checksum fn should be function');\n    return {\n        encode(data) {\n            if (!(data instanceof Uint8Array))\n                throw new Error('checksum.encode: input should be Uint8Array');\n            const checksum = fn(data).slice(0, len);\n            const res = new Uint8Array(data.length + len);\n            res.set(data);\n            res.set(checksum, data.length);\n            return res;\n        },\n        decode(data) {\n            if (!(data instanceof Uint8Array))\n                throw new Error('checksum.decode: input should be Uint8Array');\n            const payload = data.slice(0, -len);\n            const newChecksum = fn(payload).slice(0, len);\n            const oldChecksum = data.slice(-len);\n            for (let i = 0; i < len; i++)\n                if (newChecksum[i] !== oldChecksum[i])\n                    throw new Error('Invalid checksum');\n            return payload;\n        },\n    };\n}\nconst utils = { alphabet, chain, checksum, radix, radix2, join, padding };\nconst base16 = chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));\nconst base32 = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));\nconst base32hex = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));\nconst base32crockford = chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize((s) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')));\nconst base64 = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));\nconst base64url = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));\nconst genBase58 = (abc) => chain(radix(58), alphabet(abc), join(''));\nconst base58 = genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');\nconst base58flickr = genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');\nconst base58xrp = genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');\nconst XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\nconst base58xmr = {\n    encode(data) {\n        let res = '';\n        for (let i = 0; i < data.length; i += 8) {\n            const block = data.subarray(i, i + 8);\n            res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');\n        }\n        return res;\n    },\n    decode(str) {\n        let res = [];\n        for (let i = 0; i < str.length; i += 11) {\n            const slice = str.slice(i, i + 11);\n            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n            const block = base58.decode(slice);\n            for (let j = 0; j < block.length - blockLen; j++) {\n                if (block[j] !== 0)\n                    throw new Error('base58xmr: wrong padding');\n            }\n            res = res.concat(Array.from(block.slice(block.length - blockLen)));\n        }\n        return Uint8Array.from(res);\n    },\n};\nconst base58check = (sha256) => chain(checksum(4, (data) => sha256(sha256(data))), base58);\nconst BECH_ALPHABET = chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));\nconst POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\nfunction bech32Polymod(pre) {\n    const b = pre >> 25;\n    let chk = (pre & 0x1ffffff) << 5;\n    for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {\n        if (((b >> i) & 1) === 1)\n            chk ^= POLYMOD_GENERATORS[i];\n    }\n    return chk;\n}\nfunction bechChecksum(prefix, words, encodingConst = 1) {\n    const len = prefix.length;\n    let chk = 1;\n    for (let i = 0; i < len; i++) {\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126)\n            throw new Error(`Invalid prefix (${prefix})`);\n        chk = bech32Polymod(chk) ^ (c >> 5);\n    }\n    chk = bech32Polymod(chk);\n    for (let i = 0; i < len; i++)\n        chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);\n    for (let v of words)\n        chk = bech32Polymod(chk) ^ v;\n    for (let i = 0; i < 6; i++)\n        chk = bech32Polymod(chk);\n    chk ^= encodingConst;\n    return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));\n}\nfunction genBech32(encoding) {\n    const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n    const _words = radix2(5);\n    const fromWords = _words.decode;\n    const toWords = _words.encode;\n    const fromWordsUnsafe = unsafeWrapper(fromWords);\n    function encode(prefix, words, limit = 90) {\n        if (typeof prefix !== 'string')\n            throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);\n        if (!Array.isArray(words) || (words.length && typeof words[0] !== 'number'))\n            throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);\n        const actualLength = prefix.length + 7 + words.length;\n        if (limit !== false && actualLength > limit)\n            throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n        prefix = prefix.toLowerCase();\n        return `${prefix}1${BECH_ALPHABET.encode(words)}${bechChecksum(prefix, words, ENCODING_CONST)}`;\n    }\n    function decode(str, limit = 90) {\n        if (typeof str !== 'string')\n            throw new Error(`bech32.decode input should be string, not ${typeof str}`);\n        if (str.length < 8 || (limit !== false && str.length > limit))\n            throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);\n        const lowered = str.toLowerCase();\n        if (str !== lowered && str !== str.toUpperCase())\n            throw new Error(`String must be lowercase or uppercase`);\n        str = lowered;\n        const sepIndex = str.lastIndexOf('1');\n        if (sepIndex === 0 || sepIndex === -1)\n            throw new Error(`Letter \"1\" must be present between prefix and data only`);\n        const prefix = str.slice(0, sepIndex);\n        const _words = str.slice(sepIndex + 1);\n        if (_words.length < 6)\n            throw new Error('Data must be at least 6 characters long');\n        const words = BECH_ALPHABET.decode(_words).slice(0, -6);\n        const sum = bechChecksum(prefix, words, ENCODING_CONST);\n        if (!_words.endsWith(sum))\n            throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n        return { prefix, words };\n    }\n    const decodeUnsafe = unsafeWrapper(decode);\n    function decodeToBytes(str) {\n        const { prefix, words } = decode(str, false);\n        return { prefix, words, bytes: fromWords(words) };\n    }\n    return { encode, decode, decodeToBytes, decodeUnsafe, fromWords, fromWordsUnsafe, toWords };\n}\nconst bech32 = genBech32('bech32');\nconst bech32m = genBech32('bech32m');\nconst utf8 = {\n    encode: (data) => new TextDecoder().decode(data),\n    decode: (str) => new TextEncoder().encode(str),\n};\nconst hex = chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize((s) => {\n    if (typeof s !== 'string' || s.length % 2)\n        throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);\n    return s.toLowerCase();\n}));\nconst CODERS = {\n    utf8, hex, base16, base32, base64, base64url, base58, base58xmr\n};\nconst coderTypeError = `Invalid encoding type. Available types: ${Object.keys(CODERS).join(', ')}`;\nconst bytesToString = (type, bytes) => {\n    if (typeof type !== 'string' || !CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (!(bytes instanceof Uint8Array))\n        throw new TypeError('bytesToString() expects Uint8Array');\n    return CODERS[type].encode(bytes);\n};\nconst str = bytesToString;\nconst stringToBytes = (type, str) => {\n    if (!CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (typeof str !== 'string')\n        throw new TypeError('stringToBytes() expects string');\n    return CODERS[type].decode(str);\n};\nconst bytes = stringToBytes;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9zdHItZGV2LWtpdC9uZGsvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Ac2N1cmUvYmFzZS9saWIvZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ087QUFDUDtBQUNBLDBDQUEwQyxFQUFFO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxHQUFHLGFBQWEsZ0JBQWdCO0FBQ3JHO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLE9BQU87QUFDbEY7QUFDQTtBQUNBLHdEQUF3RCxPQUFPLGNBQWMsU0FBUztBQUN0RjtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxFQUFFO0FBQ3ZFO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxFQUFFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLEVBQUU7QUFDMUU7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1DQUFtQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxLQUFLO0FBQ3pEO0FBQ0Esa0RBQWtELEdBQUc7QUFDckQ7QUFDQTtBQUNBO0FB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QWdCLGdCQUFnQjtBQUNoQyxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDTztBQUNBO0FBQ0E7QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsZ0VBQWdFLFVBQVUsY0FBYyxTQUFTO0FBQ2pHO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSwrQkFBK0I7QUFDMUY7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08iLCJzb3VyY2VzIjpbIi9ob21lL2xmZy9HaXQvTWFkdHJpcHMvbm9kZV9tb2R1bGVzL0Bub3N0ci1kZXYta2l0L25kay9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0BzY3VyZS9iYXNlL2xpYi9lc20vaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIHNjdXJlLWJhc2UgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnROdW1iZXIobikge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgV3JvbmcgaW50ZWdlcjogJHtufWApO1xufVxuZnVuY3Rpb24gY2hhaW4oLi4uYXJncykge1xuICAgIGNvbnN0IHdyYXAgPSAoYSwgYikgPT4gKGMpID0+IGEoYihjKSk7XG4gICAgY29uc3QgZW5jb2RlID0gQXJyYXkuZnJvbShhcmdzKVxuICAgICAgICAucmV2ZXJzZSgpXG4gICAgICAgIC5yZWR1Y2UoKGFjYywgaSkgPT4gKGFjYyA/IHdyYXAoYWNjLCBpLmVuY29kZSkgOiBpLmVuY29kZSksIHVuZGVmaW5lZCk7XG4gICAgY29uc3QgZGVjb2RlID0gYXJncy5yZWR1Y2UoKGFjYywgaSkgPT4gKGFjYyA/IHdyYXAoYWNjLCBpLmRlY29kZSkgOiBpLmRlY29kZSksIHVuZGVmaW5lZCk7XG4gICAgcmV0dXJuIHsgZW5jb2RlLCBkZWNvZGUgfTtcbn1cbmZ1bmN0aW9uIGFscGhhYmV0KGFscGhhYmV0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlOiAoZGlnaXRzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGlnaXRzKSB8fCAoZGlnaXRzLmxlbmd0aCAmJiB0eXBlb2YgZGlnaXRzWzBdICE9PSAnbnVtYmVyJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhbHBoYWJldC5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIGFuIGFycmF5IG9mIG51bWJlcnMnKTtcbiAgICAgICAgICAgIHJldHVybiBkaWdpdHMubWFwKChpKSA9PiB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0TnVtYmVyKGkpO1xuICAgICAgICAgICAgICAgIGlmIChpIDwgMCB8fCBpID49IGFscGhhYmV0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEaWdpdCBpbmRleCBvdXRzaWRlIGFscGhhYmV0OiAke2l9IChhbHBoYWJldDogJHthbHBoYWJldC5sZW5ndGh9KWApO1xuICAgICAgICAgICAgICAgIHJldHVybiBhbHBoYWJldFtpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGU6IChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSB8fCAoaW5wdXQubGVuZ3RoICYmIHR5cGVvZiBpbnB1dFswXSAhPT0gJ3N0cmluZycpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYWxwaGFiZXQuZGVjb2RlIGlucHV0IHNob3VsZCBiZSBhcnJheSBvZiBzdHJpbmdzJyk7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQubWFwKChsZXR0ZXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGxldHRlciAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYWxwaGFiZXQuZGVjb2RlOiBub3Qgc3RyaW5nIGVsZW1lbnQ9JHtsZXR0ZXJ9YCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBhbHBoYWJldC5pbmRleE9mKGxldHRlcik7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGxldHRlcjogXCIke2xldHRlcn1cIi4gQWxsb3dlZDogJHthbHBoYWJldH1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gam9pbihzZXBhcmF0b3IgPSAnJykge1xuICAgIGlmICh0eXBlb2Ygc2VwYXJhdG9yICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdqb2luIHNlcGFyYXRvciBzaG91bGQgYmUgc3RyaW5nJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlOiAoZnJvbSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGZyb20pIHx8IChmcm9tLmxlbmd0aCAmJiB0eXBlb2YgZnJvbVswXSAhPT0gJ3N0cmluZycpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignam9pbi5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIGFycmF5IG9mIHN0cmluZ3MnKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgb2YgZnJvbSlcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGkgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGpvaW4uZW5jb2RlOiBub24tc3RyaW5nIGlucHV0PSR7aX1gKTtcbiAgICAgICAgICAgIHJldHVybiBmcm9tLmpvaW4oc2VwYXJhdG9yKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlOiAodG8pID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdG8gIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignam9pbi5kZWNvZGUgaW5wdXQgc2hvdWxkIGJlIHN0cmluZycpO1xuICAgICAgICAgICAgcmV0dXJuIHRvLnNwbGl0KHNlcGFyYXRvcik7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHBhZGRpbmcoYml0cywgY2hyID0gJz0nKSB7XG4gICAgYXNzZXJ0TnVtYmVyKGJpdHMpO1xuICAgIGlmICh0eXBlb2YgY2hyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkaW5nIGNociBzaG91bGQgYmUgc3RyaW5nJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlKGRhdGEpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSB8fCAoZGF0YS5sZW5ndGggJiYgdHlwZW9mIGRhdGFbMF0gIT09ICdzdHJpbmcnKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRpbmcuZW5jb2RlIGlucHV0IHNob3VsZCBiZSBhcnJheSBvZiBzdHJpbmdzJyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpIG9mIGRhdGEpXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwYWRkaW5nLmVuY29kZTogbm9uLXN0cmluZyBpbnB1dD0ke2l9YCk7XG4gICAgICAgICAgICB3aGlsZSAoKGRhdGEubGVuZ3RoICogYml0cykgJSA4KVxuICAgICAgICAgICAgICAgIGRhdGEucHVzaChjaHIpO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZShpbnB1dCkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSB8fCAoaW5wdXQubGVuZ3RoICYmIHR5cGVvZiBpbnB1dFswXSAhPT0gJ3N0cmluZycpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGluZy5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIGFycmF5IG9mIHN0cmluZ3MnKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgb2YgaW5wdXQpXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwYWRkaW5nLmRlY29kZTogbm9uLXN0cmluZyBpbnB1dD0ke2l9YCk7XG4gICAgICAgICAgICBsZXQgZW5kID0gaW5wdXQubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKChlbmQgKiBiaXRzKSAlIDgpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHBhZGRpbmc6IHN0cmluZyBzaG91bGQgaGF2ZSB3aG9sZSBudW1iZXIgb2YgYnl0ZXMnKTtcbiAgICAgICAgICAgIGZvciAoOyBlbmQgPiAwICYmIGlucHV0W2VuZCAtIDFdID09PSBjaHI7IGVuZC0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoKChlbmQgLSAxKSAqIGJpdHMpICUgOCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwYWRkaW5nOiBzdHJpbmcgaGFzIHRvbyBtdWNoIHBhZGRpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbnB1dC5zbGljZSgwLCBlbmQpO1xuICAgICAgICB9LFxuICAgIH07XG59XG5mdW5jdGlvbiBub3JtYWxpemUoZm4pIHtcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vcm1hbGl6ZSBmbiBzaG91bGQgYmUgZnVuY3Rpb24nKTtcbiAgICByZXR1cm4geyBlbmNvZGU6IChmcm9tKSA9PiBmcm9tLCBkZWNvZGU6ICh0bykgPT4gZm4odG8pIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0UmFkaXgoZGF0YSwgZnJvbSwgdG8pIHtcbiAgICBpZiAoZnJvbSA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4OiB3cm9uZyBmcm9tPSR7ZnJvbX0sIGJhc2UgY2Fubm90IGJlIGxlc3MgdGhhbiAyYCk7XG4gICAgaWYgKHRvIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXg6IHdyb25nIHRvPSR7dG99LCBiYXNlIGNhbm5vdCBiZSBsZXNzIHRoYW4gMmApO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb252ZXJ0UmFkaXg6IGRhdGEgc2hvdWxkIGJlIGFycmF5Jyk7XG4gICAgaWYgKCFkYXRhLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIGxldCBwb3MgPSAwO1xuICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgIGNvbnN0IGRpZ2l0cyA9IEFycmF5LmZyb20oZGF0YSk7XG4gICAgZGlnaXRzLmZvckVhY2goKGQpID0+IHtcbiAgICAgICAgYXNzZXJ0TnVtYmVyKGQpO1xuICAgICAgICBpZiAoZCA8IDAgfHwgZCA+PSBmcm9tKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXcm9uZyBpbnRlZ2VyOiAke2R9YCk7XG4gICAgfSk7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgbGV0IGNhcnJ5ID0gMDtcbiAgICAgICAgbGV0IGRvbmUgPSB0cnVlO1xuICAgICAgICBmb3IgKGxldCBpID0gcG9zOyBpIDwgZGlnaXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBkaWdpdCA9IGRpZ2l0c1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGRpZ2l0QmFzZSA9IGZyb20gKiBjYXJyeSArIGRpZ2l0O1xuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihkaWdpdEJhc2UpIHx8XG4gICAgICAgICAgICAgICAgKGZyb20gKiBjYXJyeSkgLyBmcm9tICE9PSBjYXJyeSB8fFxuICAgICAgICAgICAgICAgIGRpZ2l0QmFzZSAtIGRpZ2l0ICE9PSBmcm9tICogY2FycnkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbnZlcnRSYWRpeDogY2Fycnkgb3ZlcmZsb3cnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhcnJ5ID0gZGlnaXRCYXNlICUgdG87XG4gICAgICAgICAgICBkaWdpdHNbaV0gPSBNYXRoLmZsb29yKGRpZ2l0QmFzZSAvIHRvKTtcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoZGlnaXRzW2ldKSB8fCBkaWdpdHNbaV0gKiB0byArIGNhcnJ5ICE9PSBkaWdpdEJhc2UpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb252ZXJ0UmFkaXg6IGNhcnJ5IG92ZXJmbG93Jyk7XG4gICAgICAgICAgICBpZiAoIWRvbmUpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBlbHNlIGlmICghZGlnaXRzW2ldKVxuICAgICAgICAgICAgICAgIHBvcyA9IGk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZG9uZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5wdXNoKGNhcnJ5KTtcbiAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aCAtIDEgJiYgZGF0YVtpXSA9PT0gMDsgaSsrKVxuICAgICAgICByZXMucHVzaCgwKTtcbiAgICByZXR1cm4gcmVzLnJldmVyc2UoKTtcbn1cbmNvbnN0IGdjZCA9IChhLCBiKSA9PiAoIWIgPyBhIDogZ2NkKGIsIGEgJSBiKSk7XG5jb25zdCByYWRpeDJjYXJyeSA9IChmcm9tLCB0bykgPT4gZnJvbSArICh0byAtIGdjZChmcm9tLCB0bykpO1xuZnVuY3Rpb24gY29udmVydFJhZGl4MihkYXRhLCBmcm9tLCB0bywgcGFkZGluZykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb252ZXJ0UmFkaXgyOiBkYXRhIHNob3VsZCBiZSBhcnJheScpO1xuICAgIGlmIChmcm9tIDw9IDAgfHwgZnJvbSA+IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDI6IHdyb25nIGZyb209JHtmcm9tfWApO1xuICAgIGlmICh0byA8PSAwIHx8IHRvID4gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4Mjogd3JvbmcgdG89JHt0b31gKTtcbiAgICBpZiAocmFkaXgyY2FycnkoZnJvbSwgdG8pID4gMzIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXgyOiBjYXJyeSBvdmVyZmxvdyBmcm9tPSR7ZnJvbX0gdG89JHt0b30gY2FycnlCaXRzPSR7cmFkaXgyY2FycnkoZnJvbSwgdG8pfWApO1xuICAgIH1cbiAgICBsZXQgY2FycnkgPSAwO1xuICAgIGxldCBwb3MgPSAwO1xuICAgIGNvbnN0IG1hc2sgPSAyICoqIHRvIC0gMTtcbiAgICBjb25zdCByZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IG4gb2YgZGF0YSkge1xuICAgICAgICBhc3NlcnROdW1iZXIobik7XG4gICAgICAgIGlmIChuID49IDIgKiogZnJvbSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4MjogaW52YWxpZCBkYXRhIHdvcmQ9JHtufSBmcm9tPSR7ZnJvbX1gKTtcbiAgICAgICAgY2FycnkgPSAoY2FycnkgPDwgZnJvbSkgfCBuO1xuICAgICAgICBpZiAocG9zICsgZnJvbSA+IDMyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXgyOiBjYXJyeSBvdmVyZmxvdyBwb3M9JHtwb3N9IGZyb209JHtmcm9tfWApO1xuICAgICAgICBwb3MgKz0gZnJvbTtcbiAgICAgICAgZm9yICg7IHBvcyA+PSB0bzsgcG9zIC09IHRvKVxuICAgICAgICAgICAgcmVzLnB1c2goKChjYXJyeSA+PiAocG9zIC0gdG8pKSAmIG1hc2spID4+PiAwKTtcbiAgICAgICAgY2FycnkgJj0gMiAqKiBwb3MgLSAxO1xuICAgIH1cbiAgICBjYXJyeSA9IChjYXJyeSA8PCAodG8gLSBwb3MpKSAmIG1hc2s7XG4gICAgaWYgKCFwYWRkaW5nICYmIHBvcyA+PSBmcm9tKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4Y2VzcyBwYWRkaW5nJyk7XG4gICAgaWYgKCFwYWRkaW5nICYmIGNhcnJ5KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vbi16ZXJvIHBhZGRpbmc6ICR7Y2Fycnl9YCk7XG4gICAgaWYgKHBhZGRpbmcgJiYgcG9zID4gMClcbiAgICAgICAgcmVzLnB1c2goY2FycnkgPj4+IDApO1xuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiByYWRpeChudW0pIHtcbiAgICBhc3NlcnROdW1iZXIobnVtKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGU6IChieXRlcykgPT4ge1xuICAgICAgICAgICAgaWYgKCEoYnl0ZXMgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4LmVuY29kZSBpbnB1dCBzaG91bGQgYmUgVWludDhBcnJheScpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRSYWRpeChBcnJheS5mcm9tKGJ5dGVzKSwgMiAqKiA4LCBudW0pO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGU6IChkaWdpdHMpID0+IHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkaWdpdHMpIHx8IChkaWdpdHMubGVuZ3RoICYmIHR5cGVvZiBkaWdpdHNbMF0gIT09ICdudW1iZXInKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4LmRlY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2Ygc3RyaW5ncycpO1xuICAgICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShjb252ZXJ0UmFkaXgoZGlnaXRzLCBudW0sIDIgKiogOCkpO1xuICAgICAgICB9LFxuICAgIH07XG59XG5mdW5jdGlvbiByYWRpeDIoYml0cywgcmV2UGFkZGluZyA9IGZhbHNlKSB7XG4gICAgYXNzZXJ0TnVtYmVyKGJpdHMpO1xuICAgIGlmIChiaXRzIDw9IDAgfHwgYml0cyA+IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4MjogYml0cyBzaG91bGQgYmUgaW4gKDAuLjMyXScpO1xuICAgIGlmIChyYWRpeDJjYXJyeSg4LCBiaXRzKSA+IDMyIHx8IHJhZGl4MmNhcnJ5KGJpdHMsIDgpID4gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmFkaXgyOiBjYXJyeSBvdmVyZmxvdycpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZTogKGJ5dGVzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIShieXRlcyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmFkaXgyLmVuY29kZSBpbnB1dCBzaG91bGQgYmUgVWludDhBcnJheScpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRSYWRpeDIoQXJyYXkuZnJvbShieXRlcyksIDgsIGJpdHMsICFyZXZQYWRkaW5nKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlOiAoZGlnaXRzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGlnaXRzKSB8fCAoZGlnaXRzLmxlbmd0aCAmJiB0eXBlb2YgZGlnaXRzWzBdICE9PSAnbnVtYmVyJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpeDIuZGVjb2RlIGlucHV0IHNob3VsZCBiZSBhcnJheSBvZiBzdHJpbmdzJyk7XG4gICAgICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGNvbnZlcnRSYWRpeDIoZGlnaXRzLCBiaXRzLCA4LCByZXZQYWRkaW5nKSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHVuc2FmZVdyYXBwZXIoZm4pIHtcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc2FmZVdyYXBwZXIgZm4gc2hvdWxkIGJlIGZ1bmN0aW9uJyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgIH07XG59XG5mdW5jdGlvbiBjaGVja3N1bShsZW4sIGZuKSB7XG4gICAgYXNzZXJ0TnVtYmVyKGxlbik7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjaGVja3N1bSBmbiBzaG91bGQgYmUgZnVuY3Rpb24nKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGUoZGF0YSkge1xuICAgICAgICAgICAgaWYgKCEoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2hlY2tzdW0uZW5jb2RlOiBpbnB1dCBzaG91bGQgYmUgVWludDhBcnJheScpO1xuICAgICAgICAgICAgY29uc3QgY2hlY2tzdW0gPSBmbihkYXRhKS5zbGljZSgwLCBsZW4pO1xuICAgICAgICAgICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGggKyBsZW4pO1xuICAgICAgICAgICAgcmVzLnNldChkYXRhKTtcbiAgICAgICAgICAgIHJlcy5zZXQoY2hlY2tzdW0sIGRhdGEubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZShkYXRhKSB7XG4gICAgICAgICAgICBpZiAoIShkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjaGVja3N1bS5kZWNvZGU6IGlucHV0IHNob3VsZCBiZSBVaW50OEFycmF5Jyk7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gZGF0YS5zbGljZSgwLCAtbGVuKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0NoZWNrc3VtID0gZm4ocGF5bG9hZCkuc2xpY2UoMCwgbGVuKTtcbiAgICAgICAgICAgIGNvbnN0IG9sZENoZWNrc3VtID0gZGF0YS5zbGljZSgtbGVuKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKG5ld0NoZWNrc3VtW2ldICE9PSBvbGRDaGVja3N1bVtpXSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNoZWNrc3VtJyk7XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZXhwb3J0IGNvbnN0IHV0aWxzID0geyBhbHBoYWJldCwgY2hhaW4sIGNoZWNrc3VtLCByYWRpeCwgcmFkaXgyLCBqb2luLCBwYWRkaW5nIH07XG5leHBvcnQgY29uc3QgYmFzZTE2ID0gY2hhaW4ocmFkaXgyKDQpLCBhbHBoYWJldCgnMDEyMzQ1Njc4OUFCQ0RFRicpLCBqb2luKCcnKSk7XG5leHBvcnQgY29uc3QgYmFzZTMyID0gY2hhaW4ocmFkaXgyKDUpLCBhbHBoYWJldCgnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVoyMzQ1NjcnKSwgcGFkZGluZyg1KSwgam9pbignJykpO1xuZXhwb3J0IGNvbnN0IGJhc2UzMmhleCA9IGNoYWluKHJhZGl4Mig1KSwgYWxwaGFiZXQoJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWJyksIHBhZGRpbmcoNSksIGpvaW4oJycpKTtcbmV4cG9ydCBjb25zdCBiYXNlMzJjcm9ja2ZvcmQgPSBjaGFpbihyYWRpeDIoNSksIGFscGhhYmV0KCcwMTIzNDU2Nzg5QUJDREVGR0hKS01OUFFSU1RWV1hZWicpLCBqb2luKCcnKSwgbm9ybWFsaXplKChzKSA9PiBzLnRvVXBwZXJDYXNlKCkucmVwbGFjZSgvTy9nLCAnMCcpLnJlcGxhY2UoL1tJTF0vZywgJzEnKSkpO1xuZXhwb3J0IGNvbnN0IGJhc2U2NCA9IGNoYWluKHJhZGl4Mig2KSwgYWxwaGFiZXQoJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nKSwgcGFkZGluZyg2KSwgam9pbignJykpO1xuZXhwb3J0IGNvbnN0IGJhc2U2NHVybCA9IGNoYWluKHJhZGl4Mig2KSwgYWxwaGFiZXQoJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5LV8nKSwgcGFkZGluZyg2KSwgam9pbignJykpO1xuY29uc3QgZ2VuQmFzZTU4ID0gKGFiYykgPT4gY2hhaW4ocmFkaXgoNTgpLCBhbHBoYWJldChhYmMpLCBqb2luKCcnKSk7XG5leHBvcnQgY29uc3QgYmFzZTU4ID0gZ2VuQmFzZTU4KCcxMjM0NTY3ODlBQkNERUZHSEpLTE1OUFFSU1RVVldYWVphYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6Jyk7XG5leHBvcnQgY29uc3QgYmFzZTU4ZmxpY2tyID0gZ2VuQmFzZTU4KCcxMjM0NTY3ODlhYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaJyk7XG5leHBvcnQgY29uc3QgYmFzZTU4eHJwID0gZ2VuQmFzZTU4KCdycHNobmFmMzl3QlVETkVHSEpLTE00UFFSU1Q3VldYWVoyYmNkZUNnNjVqa204b0ZxaTF0dXZBeHl6Jyk7XG5jb25zdCBYTVJfQkxPQ0tfTEVOID0gWzAsIDIsIDMsIDUsIDYsIDcsIDksIDEwLCAxMV07XG5leHBvcnQgY29uc3QgYmFzZTU4eG1yID0ge1xuICAgIGVuY29kZShkYXRhKSB7XG4gICAgICAgIGxldCByZXMgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSA4KSB7XG4gICAgICAgICAgICBjb25zdCBibG9jayA9IGRhdGEuc3ViYXJyYXkoaSwgaSArIDgpO1xuICAgICAgICAgICAgcmVzICs9IGJhc2U1OC5lbmNvZGUoYmxvY2spLnBhZFN0YXJ0KFhNUl9CTE9DS19MRU5bYmxvY2subGVuZ3RoXSwgJzEnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0sXG4gICAgZGVjb2RlKHN0cikge1xuICAgICAgICBsZXQgcmVzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSArPSAxMSkge1xuICAgICAgICAgICAgY29uc3Qgc2xpY2UgPSBzdHIuc2xpY2UoaSwgaSArIDExKTtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrTGVuID0gWE1SX0JMT0NLX0xFTi5pbmRleE9mKHNsaWNlLmxlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCBibG9jayA9IGJhc2U1OC5kZWNvZGUoc2xpY2UpO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBibG9jay5sZW5ndGggLSBibG9ja0xlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrW2pdICE9PSAwKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Jhc2U1OHhtcjogd3JvbmcgcGFkZGluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzID0gcmVzLmNvbmNhdChBcnJheS5mcm9tKGJsb2NrLnNsaWNlKGJsb2NrLmxlbmd0aCAtIGJsb2NrTGVuKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20ocmVzKTtcbiAgICB9LFxufTtcbmV4cG9ydCBjb25zdCBiYXNlNThjaGVjayA9IChzaGEyNTYpID0+IGNoYWluKGNoZWNrc3VtKDQsIChkYXRhKSA9PiBzaGEyNTYoc2hhMjU2KGRhdGEpKSksIGJhc2U1OCk7XG5jb25zdCBCRUNIX0FMUEhBQkVUID0gY2hhaW4oYWxwaGFiZXQoJ3FwenJ5OXg4Z2YydHZkdzBzM2puNTRraGNlNm11YTdsJyksIGpvaW4oJycpKTtcbmNvbnN0IFBPTFlNT0RfR0VORVJBVE9SUyA9IFsweDNiNmE1N2IyLCAweDI2NTA4ZTZkLCAweDFlYTExOWZhLCAweDNkNDIzM2RkLCAweDJhMTQ2MmIzXTtcbmZ1bmN0aW9uIGJlY2gzMlBvbHltb2QocHJlKSB7XG4gICAgY29uc3QgYiA9IHByZSA+PiAyNTtcbiAgICBsZXQgY2hrID0gKHByZSAmIDB4MWZmZmZmZikgPDwgNTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IFBPTFlNT0RfR0VORVJBVE9SUy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoKChiID4+IGkpICYgMSkgPT09IDEpXG4gICAgICAgICAgICBjaGsgXj0gUE9MWU1PRF9HRU5FUkFUT1JTW2ldO1xuICAgIH1cbiAgICByZXR1cm4gY2hrO1xufVxuZnVuY3Rpb24gYmVjaENoZWNrc3VtKHByZWZpeCwgd29yZHMsIGVuY29kaW5nQ29uc3QgPSAxKSB7XG4gICAgY29uc3QgbGVuID0gcHJlZml4Lmxlbmd0aDtcbiAgICBsZXQgY2hrID0gMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGMgPSBwcmVmaXguY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPCAzMyB8fCBjID4gMTI2KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHByZWZpeCAoJHtwcmVmaXh9KWApO1xuICAgICAgICBjaGsgPSBiZWNoMzJQb2x5bW9kKGNoaykgXiAoYyA+PiA1KTtcbiAgICB9XG4gICAgY2hrID0gYmVjaDMyUG9seW1vZChjaGspO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKSBeIChwcmVmaXguY2hhckNvZGVBdChpKSAmIDB4MWYpO1xuICAgIGZvciAobGV0IHYgb2Ygd29yZHMpXG4gICAgICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKSBeIHY7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspXG4gICAgICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKTtcbiAgICBjaGsgXj0gZW5jb2RpbmdDb25zdDtcbiAgICByZXR1cm4gQkVDSF9BTFBIQUJFVC5lbmNvZGUoY29udmVydFJhZGl4MihbY2hrICUgMiAqKiAzMF0sIDMwLCA1LCBmYWxzZSkpO1xufVxuZnVuY3Rpb24gZ2VuQmVjaDMyKGVuY29kaW5nKSB7XG4gICAgY29uc3QgRU5DT0RJTkdfQ09OU1QgPSBlbmNvZGluZyA9PT0gJ2JlY2gzMicgPyAxIDogMHgyYmM4MzBhMztcbiAgICBjb25zdCBfd29yZHMgPSByYWRpeDIoNSk7XG4gICAgY29uc3QgZnJvbVdvcmRzID0gX3dvcmRzLmRlY29kZTtcbiAgICBjb25zdCB0b1dvcmRzID0gX3dvcmRzLmVuY29kZTtcbiAgICBjb25zdCBmcm9tV29yZHNVbnNhZmUgPSB1bnNhZmVXcmFwcGVyKGZyb21Xb3Jkcyk7XG4gICAgZnVuY3Rpb24gZW5jb2RlKHByZWZpeCwgd29yZHMsIGxpbWl0ID0gOTApIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwcmVmaXggIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBiZWNoMzIuZW5jb2RlIHByZWZpeCBzaG91bGQgYmUgc3RyaW5nLCBub3QgJHt0eXBlb2YgcHJlZml4fWApO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkod29yZHMpIHx8ICh3b3Jkcy5sZW5ndGggJiYgdHlwZW9mIHdvcmRzWzBdICE9PSAnbnVtYmVyJykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJlY2gzMi5lbmNvZGUgd29yZHMgc2hvdWxkIGJlIGFycmF5IG9mIG51bWJlcnMsIG5vdCAke3R5cGVvZiB3b3Jkc31gKTtcbiAgICAgICAgY29uc3QgYWN0dWFsTGVuZ3RoID0gcHJlZml4Lmxlbmd0aCArIDcgKyB3b3Jkcy5sZW5ndGg7XG4gICAgICAgIGlmIChsaW1pdCAhPT0gZmFsc2UgJiYgYWN0dWFsTGVuZ3RoID4gbGltaXQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBMZW5ndGggJHthY3R1YWxMZW5ndGh9IGV4Y2VlZHMgbGltaXQgJHtsaW1pdH1gKTtcbiAgICAgICAgcHJlZml4ID0gcHJlZml4LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiBgJHtwcmVmaXh9MSR7QkVDSF9BTFBIQUJFVC5lbmNvZGUod29yZHMpfSR7YmVjaENoZWNrc3VtKHByZWZpeCwgd29yZHMsIEVOQ09ESU5HX0NPTlNUKX1gO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWNvZGUoc3RyLCBsaW1pdCA9IDkwKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYmVjaDMyLmRlY29kZSBpbnB1dCBzaG91bGQgYmUgc3RyaW5nLCBub3QgJHt0eXBlb2Ygc3RyfWApO1xuICAgICAgICBpZiAoc3RyLmxlbmd0aCA8IDggfHwgKGxpbWl0ICE9PSBmYWxzZSAmJiBzdHIubGVuZ3RoID4gbGltaXQpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgV3Jvbmcgc3RyaW5nIGxlbmd0aDogJHtzdHIubGVuZ3RofSAoJHtzdHJ9KS4gRXhwZWN0ZWQgKDguLiR7bGltaXR9KWApO1xuICAgICAgICBjb25zdCBsb3dlcmVkID0gc3RyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChzdHIgIT09IGxvd2VyZWQgJiYgc3RyICE9PSBzdHIudG9VcHBlckNhc2UoKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU3RyaW5nIG11c3QgYmUgbG93ZXJjYXNlIG9yIHVwcGVyY2FzZWApO1xuICAgICAgICBzdHIgPSBsb3dlcmVkO1xuICAgICAgICBjb25zdCBzZXBJbmRleCA9IHN0ci5sYXN0SW5kZXhPZignMScpO1xuICAgICAgICBpZiAoc2VwSW5kZXggPT09IDAgfHwgc2VwSW5kZXggPT09IC0xKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMZXR0ZXIgXCIxXCIgbXVzdCBiZSBwcmVzZW50IGJldHdlZW4gcHJlZml4IGFuZCBkYXRhIG9ubHlgKTtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gc3RyLnNsaWNlKDAsIHNlcEluZGV4KTtcbiAgICAgICAgY29uc3QgX3dvcmRzID0gc3RyLnNsaWNlKHNlcEluZGV4ICsgMSk7XG4gICAgICAgIGlmIChfd29yZHMubGVuZ3RoIDwgNilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGF0YSBtdXN0IGJlIGF0IGxlYXN0IDYgY2hhcmFjdGVycyBsb25nJyk7XG4gICAgICAgIGNvbnN0IHdvcmRzID0gQkVDSF9BTFBIQUJFVC5kZWNvZGUoX3dvcmRzKS5zbGljZSgwLCAtNik7XG4gICAgICAgIGNvbnN0IHN1bSA9IGJlY2hDaGVja3N1bShwcmVmaXgsIHdvcmRzLCBFTkNPRElOR19DT05TVCk7XG4gICAgICAgIGlmICghX3dvcmRzLmVuZHNXaXRoKHN1bSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY2hlY2tzdW0gaW4gJHtzdHJ9OiBleHBlY3RlZCBcIiR7c3VtfVwiYCk7XG4gICAgICAgIHJldHVybiB7IHByZWZpeCwgd29yZHMgfTtcbiAgICB9XG4gICAgY29uc3QgZGVjb2RlVW5zYWZlID0gdW5zYWZlV3JhcHBlcihkZWNvZGUpO1xuICAgIGZ1bmN0aW9uIGRlY29kZVRvQnl0ZXMoc3RyKSB7XG4gICAgICAgIGNvbnN0IHsgcHJlZml4LCB3b3JkcyB9ID0gZGVjb2RlKHN0ciwgZmFsc2UpO1xuICAgICAgICByZXR1cm4geyBwcmVmaXgsIHdvcmRzLCBieXRlczogZnJvbVdvcmRzKHdvcmRzKSB9O1xuICAgIH1cbiAgICByZXR1cm4geyBlbmNvZGUsIGRlY29kZSwgZGVjb2RlVG9CeXRlcywgZGVjb2RlVW5zYWZlLCBmcm9tV29yZHMsIGZyb21Xb3Jkc1Vuc2FmZSwgdG9Xb3JkcyB9O1xufVxuZXhwb3J0IGNvbnN0IGJlY2gzMiA9IGdlbkJlY2gzMignYmVjaDMyJyk7XG5leHBvcnQgY29uc3QgYmVjaDMybSA9IGdlbkJlY2gzMignYmVjaDMybScpO1xuZXhwb3J0IGNvbnN0IHV0ZjggPSB7XG4gICAgZW5jb2RlOiAoZGF0YSkgPT4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGRhdGEpLFxuICAgIGRlY29kZTogKHN0cikgPT4gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0ciksXG59O1xuZXhwb3J0IGNvbnN0IGhleCA9IGNoYWluKHJhZGl4Mig0KSwgYWxwaGFiZXQoJzAxMjM0NTY3ODlhYmNkZWYnKSwgam9pbignJyksIG5vcm1hbGl6ZSgocykgPT4ge1xuICAgIGlmICh0eXBlb2YgcyAhPT0gJ3N0cmluZycgfHwgcy5sZW5ndGggJSAyKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBoZXguZGVjb2RlOiBleHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiBzfSB3aXRoIGxlbmd0aCAke3MubGVuZ3RofWApO1xuICAgIHJldHVybiBzLnRvTG93ZXJDYXNlKCk7XG59KSk7XG5jb25zdCBDT0RFUlMgPSB7XG4gICAgdXRmOCwgaGV4LCBiYXNlMTYsIGJhc2UzMiwgYmFzZTY0LCBiYXNlNjR1cmwsIGJhc2U1OCwgYmFzZTU4eG1yXG59O1xuY29uc3QgY29kZXJUeXBlRXJyb3IgPSBgSW52YWxpZCBlbmNvZGluZyB0eXBlLiBBdmFpbGFibGUgdHlwZXM6ICR7T2JqZWN0LmtleXMoQ09ERVJTKS5qb2luKCcsICcpfWA7XG5leHBvcnQgY29uc3QgYnl0ZXNUb1N0cmluZyA9ICh0eXBlLCBieXRlcykgPT4ge1xuICAgIGlmICh0eXBlb2YgdHlwZSAhPT0gJ3N0cmluZycgfHwgIUNPREVSUy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihjb2RlclR5cGVFcnJvcik7XG4gICAgaWYgKCEoYnl0ZXMgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYnl0ZXNUb1N0cmluZygpIGV4cGVjdHMgVWludDhBcnJheScpO1xuICAgIHJldHVybiBDT0RFUlNbdHlwZV0uZW5jb2RlKGJ5dGVzKTtcbn07XG5leHBvcnQgY29uc3Qgc3RyID0gYnl0ZXNUb1N0cmluZztcbmV4cG9ydCBjb25zdCBzdHJpbmdUb0J5dGVzID0gKHR5cGUsIHN0cikgPT4ge1xuICAgIGlmICghQ09ERVJTLmhhc093blByb3BlcnR5KHR5cGUpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGNvZGVyVHlwZUVycm9yKTtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3N0cmluZ1RvQnl0ZXMoKSBleHBlY3RzIHN0cmluZycpO1xuICAgIHJldHVybiBDT0RFUlNbdHlwZV0uZGVjb2RlKHN0cik7XG59O1xuZXhwb3J0IGNvbnN0IGJ5dGVzID0gc3RyaW5nVG9CeXRlcztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@scure/base/lib/esm/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@scure/base/lib/esm/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@scure/base/lib/esm/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertNumber: () => (/* binding */ assertNumber),\n/* harmony export */   base16: () => (/* binding */ base16),\n/* harmony export */   base32: () => (/* binding */ base32),\n/* harmony export */   base32crockford: () => (/* binding */ base32crockford),\n/* harmony export */   base32hex: () => (/* binding */ base32hex),\n/* harmony export */   base32hexnopad: () => (/* binding */ base32hexnopad),\n/* harmony export */   base32nopad: () => (/* binding */ base32nopad),\n/* harmony export */   base58: () => (/* binding */ base58),\n/* harmony export */   base58check: () => (/* binding */ base58check),\n/* harmony export */   base58flickr: () => (/* binding */ base58flickr),\n/* harmony export */   base58xmr: () => (/* binding */ base58xmr),\n/* harmony export */   base58xrp: () => (/* binding */ base58xrp),\n/* harmony export */   base64: () => (/* binding */ base64),\n/* harmony export */   base64nopad: () => (/* binding */ base64nopad),\n/* harmony export */   base64url: () => (/* binding */ base64url),\n/* harmony export */   base64urlnopad: () => (/* binding */ base64urlnopad),\n/* harmony export */   bech32: () => (/* binding */ bech32),\n/* harmony export */   bech32m: () => (/* binding */ bech32m),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   bytesToString: () => (/* binding */ bytesToString),\n/* harmony export */   createBase58check: () => (/* binding */ createBase58check),\n/* harmony export */   hex: () => (/* binding */ hex),\n/* harmony export */   str: () => (/* binding */ str),\n/* harmony export */   stringToBytes: () => (/* binding */ stringToBytes),\n/* harmony export */   utf8: () => (/* binding */ utf8),\n/* harmony export */   utils: () => (/* binding */ utils)\n/* harmony export */ });\n/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nfunction isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\nfunction isArrayOf(isString, arr) {\n    if (!Array.isArray(arr))\n        return false;\n    if (arr.length === 0)\n        return true;\n    if (isString) {\n        return arr.every((item) => typeof item === 'string');\n    }\n    else {\n        return arr.every((item) => Number.isSafeInteger(item));\n    }\n}\n// no abytes: seems to have 10% slowdown. Why?!\nfunction afn(input) {\n    if (typeof input !== 'function')\n        throw new Error('function expected');\n    return true;\n}\nfunction astr(label, input) {\n    if (typeof input !== 'string')\n        throw new Error(`${label}: string expected`);\n    return true;\n}\nfunction anumber(n) {\n    if (!Number.isSafeInteger(n))\n        throw new Error(`invalid integer: ${n}`);\n}\nconst assertNumber = anumber;\nfunction aArr(input) {\n    if (!Array.isArray(input))\n        throw new Error('array expected');\n}\nfunction astrArr(label, input) {\n    if (!isArrayOf(true, input))\n        throw new Error(`${label}: array of strings expected`);\n}\nfunction anumArr(label, input) {\n    if (!isArrayOf(false, input))\n        throw new Error(`${label}: array of numbers expected`);\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction chain(...args) {\n    const id = (a) => a;\n    // Wrap call in closure so JIT can inline calls\n    const wrap = (a, b) => (c) => a(b(c));\n    // Construct chain of args[-1].encode(args[-2].encode([...]))\n    const encode = args.map((x) => x.encode).reduceRight(wrap, id);\n    // Construct chain of args[0].decode(args[1].decode(...))\n    const decode = args.map((x) => x.decode).reduce(wrap, id);\n    return { encode, decode };\n}\n/**\n * Encodes integer radix representation to array of strings using alphabet and back.\n * Could also be array of strings.\n * @__NO_SIDE_EFFECTS__\n */\nfunction alphabet(letters) {\n    // mapping 1 to \"b\"\n    const lettersA = typeof letters === 'string' ? letters.split('') : letters;\n    const len = lettersA.length;\n    astrArr('alphabet', lettersA);\n    // mapping \"b\" to 1\n    const indexes = new Map(lettersA.map((l, i) => [l, i]));\n    return {\n        encode: (digits) => {\n            aArr(digits);\n            return digits.map((i) => {\n                if (!Number.isSafeInteger(i) || i < 0 || i >= len)\n                    throw new Error(`alphabet.encode: digit index outside alphabet \"${i}\". Allowed: ${letters}`);\n                return lettersA[i];\n            });\n        },\n        decode: (input) => {\n            aArr(input);\n            return input.map((letter) => {\n                astr('alphabet.decode', letter);\n                const i = indexes.get(letter);\n                if (i === undefined)\n                    throw new Error(`Unknown letter: \"${letter}\". Allowed: ${letters}`);\n                return i;\n            });\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction join(separator = '') {\n    astr('join', separator);\n    return {\n        encode: (from) => {\n            astrArr('join.decode', from);\n            return from.join(separator);\n        },\n        decode: (to) => {\n            astr('join.decode', to);\n            return to.split(separator);\n        },\n    };\n}\n/**\n * Pad strings array so it has integer number of bits\n * @__NO_SIDE_EFFECTS__\n */\nfunction padding(bits, chr = '=') {\n    anumber(bits);\n    astr('padding', chr);\n    return {\n        encode(data) {\n            astrArr('padding.encode', data);\n            while ((data.length * bits) % 8)\n                data.push(chr);\n            return data;\n        },\n        decode(input) {\n            astrArr('padding.decode', input);\n            let end = input.length;\n            if ((end * bits) % 8)\n                throw new Error('padding: invalid, string should have whole number of bytes');\n            for (; end > 0 && input[end - 1] === chr; end--) {\n                const last = end - 1;\n                const byte = last * bits;\n                if (byte % 8 === 0)\n                    throw new Error('padding: invalid, string has too much padding');\n            }\n            return input.slice(0, end);\n        },\n    };\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction normalize(fn) {\n    afn(fn);\n    return { encode: (from) => from, decode: (to) => fn(to) };\n}\n/**\n * Slow: O(n^2) time complexity\n */\nfunction convertRadix(data, from, to) {\n    // base 1 is impossible\n    if (from < 2)\n        throw new Error(`convertRadix: invalid from=${from}, base cannot be less than 2`);\n    if (to < 2)\n        throw new Error(`convertRadix: invalid to=${to}, base cannot be less than 2`);\n    aArr(data);\n    if (!data.length)\n        return [];\n    let pos = 0;\n    const res = [];\n    const digits = Array.from(data, (d) => {\n        anumber(d);\n        if (d < 0 || d >= from)\n            throw new Error(`invalid integer: ${d}`);\n        return d;\n    });\n    const dlen = digits.length;\n    while (true) {\n        let carry = 0;\n        let done = true;\n        for (let i = pos; i < dlen; i++) {\n            const digit = digits[i];\n            const fromCarry = from * carry;\n            const digitBase = fromCarry + digit;\n            if (!Number.isSafeInteger(digitBase) ||\n                fromCarry / from !== carry ||\n                digitBase - digit !== fromCarry) {\n                throw new Error('convertRadix: carry overflow');\n            }\n            const div = digitBase / to;\n            carry = digitBase % to;\n            const rounded = Math.floor(div);\n            digits[i] = rounded;\n            if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)\n                throw new Error('convertRadix: carry overflow');\n            if (!done)\n                continue;\n            else if (!rounded)\n                pos = i;\n            else\n                done = false;\n        }\n        res.push(carry);\n        if (done)\n            break;\n    }\n    for (let i = 0; i < data.length - 1 && data[i] === 0; i++)\n        res.push(0);\n    return res.reverse();\n}\nconst gcd = (a, b) => (b === 0 ? a : gcd(b, a % b));\nconst radix2carry = /* @__NO_SIDE_EFFECTS__ */ (from, to) => from + (to - gcd(from, to));\nconst powers = /* @__PURE__ */ (() => {\n    let res = [];\n    for (let i = 0; i < 40; i++)\n        res.push(2 ** i);\n    return res;\n})();\n/**\n * Implemented with numbers, because BigInt is 5x slower\n */\nfunction convertRadix2(data, from, to, padding) {\n    aArr(data);\n    if (from <= 0 || from > 32)\n        throw new Error(`convertRadix2: wrong from=${from}`);\n    if (to <= 0 || to > 32)\n        throw new Error(`convertRadix2: wrong to=${to}`);\n    if (radix2carry(from, to) > 32) {\n        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);\n    }\n    let carry = 0;\n    let pos = 0; // bitwise position in current element\n    const max = powers[from];\n    const mask = powers[to] - 1;\n    const res = [];\n    for (const n of data) {\n        anumber(n);\n        if (n >= max)\n            throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n        carry = (carry << from) | n;\n        if (pos + from > 32)\n            throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n        pos += from;\n        for (; pos >= to; pos -= to)\n            res.push(((carry >> (pos - to)) & mask) >>> 0);\n        const pow = powers[pos];\n        if (pow === undefined)\n            throw new Error('invalid carry');\n        carry &= pow - 1; // clean carry, otherwise it will cause overflow\n    }\n    carry = (carry << (to - pos)) & mask;\n    if (!padding && pos >= from)\n        throw new Error('Excess padding');\n    if (!padding && carry > 0)\n        throw new Error(`Non-zero padding: ${carry}`);\n    if (padding && pos > 0)\n        res.push(carry >>> 0);\n    return res;\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix(num) {\n    anumber(num);\n    const _256 = 2 ** 8;\n    return {\n        encode: (bytes) => {\n            if (!isBytes(bytes))\n                throw new Error('radix.encode input should be Uint8Array');\n            return convertRadix(Array.from(bytes), _256, num);\n        },\n        decode: (digits) => {\n            anumArr('radix.decode', digits);\n            return Uint8Array.from(convertRadix(digits, num, _256));\n        },\n    };\n}\n/**\n * If both bases are power of same number (like `2**8 <-> 2**64`),\n * there is a linear algorithm. For now we have implementation for power-of-two bases only.\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix2(bits, revPadding = false) {\n    anumber(bits);\n    if (bits <= 0 || bits > 32)\n        throw new Error('radix2: bits should be in (0..32]');\n    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)\n        throw new Error('radix2: carry overflow');\n    return {\n        encode: (bytes) => {\n            if (!isBytes(bytes))\n                throw new Error('radix2.encode input should be Uint8Array');\n            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n        },\n        decode: (digits) => {\n            anumArr('radix2.decode', digits);\n            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n        },\n    };\n}\nfunction unsafeWrapper(fn) {\n    afn(fn);\n    return function (...args) {\n        try {\n            return fn.apply(null, args);\n        }\n        catch (e) { }\n    };\n}\nfunction checksum(len, fn) {\n    anumber(len);\n    afn(fn);\n    return {\n        encode(data) {\n            if (!isBytes(data))\n                throw new Error('checksum.encode: input should be Uint8Array');\n            const sum = fn(data).slice(0, len);\n            const res = new Uint8Array(data.length + len);\n            res.set(data);\n            res.set(sum, data.length);\n            return res;\n        },\n        decode(data) {\n            if (!isBytes(data))\n                throw new Error('checksum.decode: input should be Uint8Array');\n            const payload = data.slice(0, -len);\n            const oldChecksum = data.slice(-len);\n            const newChecksum = fn(payload).slice(0, len);\n            for (let i = 0; i < len; i++)\n                if (newChecksum[i] !== oldChecksum[i])\n                    throw new Error('Invalid checksum');\n            return payload;\n        },\n    };\n}\n// prettier-ignore\nconst utils = {\n    alphabet, chain, checksum, convertRadix, convertRadix2, radix, radix2, join, padding,\n};\n// RFC 4648 aka RFC 3548\n// ---------------------\n/**\n * base16 encoding.\n */\nconst base16 = chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));\nconst base32 = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));\nconst base32nopad = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), join(''));\nconst base32hex = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));\nconst base32hexnopad = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), join(''));\nconst base32crockford = chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize((s) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')));\n/**\n * base64 with padding. For no padding, use `base64nopad`.\n * @example\n * const b = base64.decode('A951'); // Uint8Array.from([ 3, 222, 117 ])\n * base64.encode(b); // 'A951'\n */\nconst base64 = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));\n/**\n * base64 without padding.\n */\nconst base64nopad = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), join(''));\nconst base64url = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));\nconst base64urlnopad = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), join(''));\n// base58 code\n// -----------\nconst genBase58 = /* @__NO_SIDE_EFFECTS__ */ (abc) => chain(radix(58), alphabet(abc), join(''));\n/**\n * Base58: base64 without characters +, /, 0, O, I, l.\n * Quadratic (O(n^2)) - so, can't be used on large inputs.\n */\nconst base58 = genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');\nconst base58flickr = genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');\nconst base58xrp = genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');\n// Data len (index) -> encoded block len\nconst XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\n/**\n * XMR version of base58.\n * Done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.\n * Block encoding significantly reduces quadratic complexity of base58.\n */\nconst base58xmr = {\n    encode(data) {\n        let res = '';\n        for (let i = 0; i < data.length; i += 8) {\n            const block = data.subarray(i, i + 8);\n            res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');\n        }\n        return res;\n    },\n    decode(str) {\n        let res = [];\n        for (let i = 0; i < str.length; i += 11) {\n            const slice = str.slice(i, i + 11);\n            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n            const block = base58.decode(slice);\n            for (let j = 0; j < block.length - blockLen; j++) {\n                if (block[j] !== 0)\n                    throw new Error('base58xmr: wrong padding');\n            }\n            res = res.concat(Array.from(block.slice(block.length - blockLen)));\n        }\n        return Uint8Array.from(res);\n    },\n};\nconst createBase58check = (sha256) => chain(checksum(4, (data) => sha256(sha256(data))), base58);\n/**\n * Use `createBase58check` instead.\n * @deprecated\n */\nconst base58check = createBase58check;\nconst BECH_ALPHABET = chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));\nconst POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\nfunction bech32Polymod(pre) {\n    const b = pre >> 25;\n    let chk = (pre & 0x1ffffff) << 5;\n    for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {\n        if (((b >> i) & 1) === 1)\n            chk ^= POLYMOD_GENERATORS[i];\n    }\n    return chk;\n}\nfunction bechChecksum(prefix, words, encodingConst = 1) {\n    const len = prefix.length;\n    let chk = 1;\n    for (let i = 0; i < len; i++) {\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126)\n            throw new Error(`Invalid prefix (${prefix})`);\n        chk = bech32Polymod(chk) ^ (c >> 5);\n    }\n    chk = bech32Polymod(chk);\n    for (let i = 0; i < len; i++)\n        chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);\n    for (let v of words)\n        chk = bech32Polymod(chk) ^ v;\n    for (let i = 0; i < 6; i++)\n        chk = bech32Polymod(chk);\n    chk ^= encodingConst;\n    return BECH_ALPHABET.encode(convertRadix2([chk % powers[30]], 30, 5, false));\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction genBech32(encoding) {\n    const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n    const _words = radix2(5);\n    const fromWords = _words.decode;\n    const toWords = _words.encode;\n    const fromWordsUnsafe = unsafeWrapper(fromWords);\n    function encode(prefix, words, limit = 90) {\n        astr('bech32.encode prefix', prefix);\n        if (isBytes(words))\n            words = Array.from(words);\n        anumArr('bech32.encode', words);\n        const plen = prefix.length;\n        if (plen === 0)\n            throw new TypeError(`Invalid prefix length ${plen}`);\n        const actualLength = plen + 7 + words.length;\n        if (limit !== false && actualLength > limit)\n            throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n        const lowered = prefix.toLowerCase();\n        const sum = bechChecksum(lowered, words, ENCODING_CONST);\n        return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;\n    }\n    function decode(str, limit = 90) {\n        astr('bech32.decode input', str);\n        const slen = str.length;\n        if (slen < 8 || (limit !== false && slen > limit))\n            throw new TypeError(`invalid string length: ${slen} (${str}). Expected (8..${limit})`);\n        // don't allow mixed case\n        const lowered = str.toLowerCase();\n        if (str !== lowered && str !== str.toUpperCase())\n            throw new Error(`String must be lowercase or uppercase`);\n        const sepIndex = lowered.lastIndexOf('1');\n        if (sepIndex === 0 || sepIndex === -1)\n            throw new Error(`Letter \"1\" must be present between prefix and data only`);\n        const prefix = lowered.slice(0, sepIndex);\n        const data = lowered.slice(sepIndex + 1);\n        if (data.length < 6)\n            throw new Error('Data must be at least 6 characters long');\n        const words = BECH_ALPHABET.decode(data).slice(0, -6);\n        const sum = bechChecksum(prefix, words, ENCODING_CONST);\n        if (!data.endsWith(sum))\n            throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n        return { prefix, words };\n    }\n    const decodeUnsafe = unsafeWrapper(decode);\n    function decodeToBytes(str) {\n        const { prefix, words } = decode(str, false);\n        return { prefix, words, bytes: fromWords(words) };\n    }\n    function encodeFromBytes(prefix, bytes) {\n        return encode(prefix, toWords(bytes));\n    }\n    return {\n        encode,\n        decode,\n        encodeFromBytes,\n        decodeToBytes,\n        decodeUnsafe,\n        fromWords,\n        fromWordsUnsafe,\n        toWords,\n    };\n}\n/**\n * Low-level bech32 operations. Operates on words.\n */\nconst bech32 = genBech32('bech32');\nconst bech32m = genBech32('bech32m');\n/**\n * UTF-8-to-byte decoder. Uses built-in TextDecoder / TextEncoder.\n * @example\n * const b = utf8.decode(\"hey\"); // => new Uint8Array([ 104, 101, 121 ])\n * const str = utf8.encode(b); // \"hey\"\n */\nconst utf8 = {\n    encode: (data) => new TextDecoder().decode(data),\n    decode: (str) => new TextEncoder().encode(str),\n};\n/**\n * hex string decoder.\n * @example\n * const b = hex.decode(\"0102ff\"); // => new Uint8Array([ 1, 2, 255 ])\n * const str = hex.encode(b); // \"0102ff\"\n */\nconst hex = chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize((s) => {\n    if (typeof s !== 'string' || s.length % 2 !== 0)\n        throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);\n    return s.toLowerCase();\n}));\n// prettier-ignore\nconst CODERS = {\n    utf8, hex, base16, base32, base64, base64url, base58, base58xmr\n};\nconst coderTypeError = 'Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr';\nconst bytesToString = (type, bytes) => {\n    if (typeof type !== 'string' || !CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (!isBytes(bytes))\n        throw new TypeError('bytesToString() expects Uint8Array');\n    return CODERS[type].encode(bytes);\n};\nconst str = bytesToString; // as in python, but for bytes only\nconst stringToBytes = (type, str) => {\n    if (!CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (typeof str !== 'string')\n        throw new TypeError('stringToBytes() expects string');\n    return CODERS[type].decode(str);\n};\nconst bytes = stringToBytes;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2N1cmUvYmFzZS9saWIvZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLE1BQU07QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsRUFBRTtBQUM5QztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLE1BQU07QUFDakM7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLE1BQU07QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRixFQUFFLGNBQWMsUUFBUTtBQUM5RztBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELE9BQU8sY0FBYyxRQUFRO0FBQ3JGO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQ0FBbUM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELEtBQUs7QUFDM0Q7QUFDQSxvREFBb0QsR0FBRztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELEVBQUU7QUFDbEQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsVUFBVTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQ0FBc0M7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxLQUFLO0FBQzFEO0FBQ0EsbURBQW1ELEdBQUc7QUFDdEQ7QUFDQSw4REFBOEQsTUFBTSxLQUFLLElBQUksWUFBWSxzQkFBc0I7QUFDL0c7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsR0FBRyxPQUFPLEtBQUs7QUFDL0U7QUFDQTtBQUNBLGlFQUFpRSxLQUFLLE9BQU8sS0FBSztBQUNsRjtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE1BQU07QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFNBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDUDtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMscUJBQXFCO0FBQ3JCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNBO0FBQ0E7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ0E7QUFDQTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNkJBQTZCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsK0JBQStCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0EsK0NBQStDLE9BQU87QUFDdEQ7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxLQUFLO0FBQzlEO0FBQ0E7QUFDQSwwQ0FBMEMsY0FBYyxnQkFBZ0IsTUFBTTtBQUM5RTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVEsR0FBRyw0QkFBNEIsRUFBRSxJQUFJO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsTUFBTSxHQUFHLElBQUksa0JBQWtCLE1BQU07QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxJQUFJLGNBQWMsSUFBSTtBQUN6RSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQywrQkFBK0I7QUFDL0I7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyw4QkFBOEI7QUFDOUI7QUFDTztBQUNQO0FBQ0EsZ0VBQWdFLFVBQVUsY0FBYyxTQUFTO0FBQ2pHO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDJCQUEyQjtBQUMzQjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AiLCJzb3VyY2VzIjpbIi9ob21lL2xmZy9HaXQvTWFkdHJpcHMvbm9kZV9tb2R1bGVzL0BzY3VyZS9iYXNlL2xpYi9lc20vaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIHNjdXJlLWJhc2UgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmZ1bmN0aW9uIGlzQnl0ZXMoYSkge1xuICAgIHJldHVybiBhIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCAoQXJyYXlCdWZmZXIuaXNWaWV3KGEpICYmIGEuY29uc3RydWN0b3IubmFtZSA9PT0gJ1VpbnQ4QXJyYXknKTtcbn1cbmZ1bmN0aW9uIGlzQXJyYXlPZihpc1N0cmluZywgYXJyKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFycikpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoYXJyLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKGlzU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBhcnIuZXZlcnkoKGl0ZW0pID0+IHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gYXJyLmV2ZXJ5KChpdGVtKSA9PiBOdW1iZXIuaXNTYWZlSW50ZWdlcihpdGVtKSk7XG4gICAgfVxufVxuLy8gbm8gYWJ5dGVzOiBzZWVtcyB0byBoYXZlIDEwJSBzbG93ZG93bi4gV2h5PyFcbmZ1bmN0aW9uIGFmbihpbnB1dCkge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZnVuY3Rpb24gZXhwZWN0ZWQnKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGFzdHIobGFiZWwsIGlucHV0KSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtsYWJlbH06IHN0cmluZyBleHBlY3RlZGApO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gYW51bWJlcihuKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGludGVnZXI6ICR7bn1gKTtcbn1cbmV4cG9ydCBjb25zdCBhc3NlcnROdW1iZXIgPSBhbnVtYmVyO1xuZnVuY3Rpb24gYUFycihpbnB1dCkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYXJyYXkgZXhwZWN0ZWQnKTtcbn1cbmZ1bmN0aW9uIGFzdHJBcnIobGFiZWwsIGlucHV0KSB7XG4gICAgaWYgKCFpc0FycmF5T2YodHJ1ZSwgaW5wdXQpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bGFiZWx9OiBhcnJheSBvZiBzdHJpbmdzIGV4cGVjdGVkYCk7XG59XG5mdW5jdGlvbiBhbnVtQXJyKGxhYmVsLCBpbnB1dCkge1xuICAgIGlmICghaXNBcnJheU9mKGZhbHNlLCBpbnB1dCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtsYWJlbH06IGFycmF5IG9mIG51bWJlcnMgZXhwZWN0ZWRgKTtcbn1cbi8qKlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gY2hhaW4oLi4uYXJncykge1xuICAgIGNvbnN0IGlkID0gKGEpID0+IGE7XG4gICAgLy8gV3JhcCBjYWxsIGluIGNsb3N1cmUgc28gSklUIGNhbiBpbmxpbmUgY2FsbHNcbiAgICBjb25zdCB3cmFwID0gKGEsIGIpID0+IChjKSA9PiBhKGIoYykpO1xuICAgIC8vIENvbnN0cnVjdCBjaGFpbiBvZiBhcmdzWy0xXS5lbmNvZGUoYXJnc1stMl0uZW5jb2RlKFsuLi5dKSlcbiAgICBjb25zdCBlbmNvZGUgPSBhcmdzLm1hcCgoeCkgPT4geC5lbmNvZGUpLnJlZHVjZVJpZ2h0KHdyYXAsIGlkKTtcbiAgICAvLyBDb25zdHJ1Y3QgY2hhaW4gb2YgYXJnc1swXS5kZWNvZGUoYXJnc1sxXS5kZWNvZGUoLi4uKSlcbiAgICBjb25zdCBkZWNvZGUgPSBhcmdzLm1hcCgoeCkgPT4geC5kZWNvZGUpLnJlZHVjZSh3cmFwLCBpZCk7XG4gICAgcmV0dXJuIHsgZW5jb2RlLCBkZWNvZGUgfTtcbn1cbi8qKlxuICogRW5jb2RlcyBpbnRlZ2VyIHJhZGl4IHJlcHJlc2VudGF0aW9uIHRvIGFycmF5IG9mIHN0cmluZ3MgdXNpbmcgYWxwaGFiZXQgYW5kIGJhY2suXG4gKiBDb3VsZCBhbHNvIGJlIGFycmF5IG9mIHN0cmluZ3MuXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBhbHBoYWJldChsZXR0ZXJzKSB7XG4gICAgLy8gbWFwcGluZyAxIHRvIFwiYlwiXG4gICAgY29uc3QgbGV0dGVyc0EgPSB0eXBlb2YgbGV0dGVycyA9PT0gJ3N0cmluZycgPyBsZXR0ZXJzLnNwbGl0KCcnKSA6IGxldHRlcnM7XG4gICAgY29uc3QgbGVuID0gbGV0dGVyc0EubGVuZ3RoO1xuICAgIGFzdHJBcnIoJ2FscGhhYmV0JywgbGV0dGVyc0EpO1xuICAgIC8vIG1hcHBpbmcgXCJiXCIgdG8gMVxuICAgIGNvbnN0IGluZGV4ZXMgPSBuZXcgTWFwKGxldHRlcnNBLm1hcCgobCwgaSkgPT4gW2wsIGldKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlOiAoZGlnaXRzKSA9PiB7XG4gICAgICAgICAgICBhQXJyKGRpZ2l0cyk7XG4gICAgICAgICAgICByZXR1cm4gZGlnaXRzLm1hcCgoaSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoaSkgfHwgaSA8IDAgfHwgaSA+PSBsZW4pXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYWxwaGFiZXQuZW5jb2RlOiBkaWdpdCBpbmRleCBvdXRzaWRlIGFscGhhYmV0IFwiJHtpfVwiLiBBbGxvd2VkOiAke2xldHRlcnN9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxldHRlcnNBW2ldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZTogKGlucHV0KSA9PiB7XG4gICAgICAgICAgICBhQXJyKGlucHV0KTtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dC5tYXAoKGxldHRlcikgPT4ge1xuICAgICAgICAgICAgICAgIGFzdHIoJ2FscGhhYmV0LmRlY29kZScsIGxldHRlcik7XG4gICAgICAgICAgICAgICAgY29uc3QgaSA9IGluZGV4ZXMuZ2V0KGxldHRlcik7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGxldHRlcjogXCIke2xldHRlcn1cIi4gQWxsb3dlZDogJHtsZXR0ZXJzfWApO1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gam9pbihzZXBhcmF0b3IgPSAnJykge1xuICAgIGFzdHIoJ2pvaW4nLCBzZXBhcmF0b3IpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZTogKGZyb20pID0+IHtcbiAgICAgICAgICAgIGFzdHJBcnIoJ2pvaW4uZGVjb2RlJywgZnJvbSk7XG4gICAgICAgICAgICByZXR1cm4gZnJvbS5qb2luKHNlcGFyYXRvcik7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZTogKHRvKSA9PiB7XG4gICAgICAgICAgICBhc3RyKCdqb2luLmRlY29kZScsIHRvKTtcbiAgICAgICAgICAgIHJldHVybiB0by5zcGxpdChzZXBhcmF0b3IpO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIFBhZCBzdHJpbmdzIGFycmF5IHNvIGl0IGhhcyBpbnRlZ2VyIG51bWJlciBvZiBiaXRzXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBwYWRkaW5nKGJpdHMsIGNociA9ICc9Jykge1xuICAgIGFudW1iZXIoYml0cyk7XG4gICAgYXN0cigncGFkZGluZycsIGNocik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlKGRhdGEpIHtcbiAgICAgICAgICAgIGFzdHJBcnIoJ3BhZGRpbmcuZW5jb2RlJywgZGF0YSk7XG4gICAgICAgICAgICB3aGlsZSAoKGRhdGEubGVuZ3RoICogYml0cykgJSA4KVxuICAgICAgICAgICAgICAgIGRhdGEucHVzaChjaHIpO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZShpbnB1dCkge1xuICAgICAgICAgICAgYXN0ckFycigncGFkZGluZy5kZWNvZGUnLCBpbnB1dCk7XG4gICAgICAgICAgICBsZXQgZW5kID0gaW5wdXQubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKChlbmQgKiBiaXRzKSAlIDgpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkaW5nOiBpbnZhbGlkLCBzdHJpbmcgc2hvdWxkIGhhdmUgd2hvbGUgbnVtYmVyIG9mIGJ5dGVzJyk7XG4gICAgICAgICAgICBmb3IgKDsgZW5kID4gMCAmJiBpbnB1dFtlbmQgLSAxXSA9PT0gY2hyOyBlbmQtLSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3QgPSBlbmQgLSAxO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ5dGUgPSBsYXN0ICogYml0cztcbiAgICAgICAgICAgICAgICBpZiAoYnl0ZSAlIDggPT09IDApXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGluZzogaW52YWxpZCwgc3RyaW5nIGhhcyB0b28gbXVjaCBwYWRkaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQuc2xpY2UoMCwgZW5kKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBub3JtYWxpemUoZm4pIHtcbiAgICBhZm4oZm4pO1xuICAgIHJldHVybiB7IGVuY29kZTogKGZyb20pID0+IGZyb20sIGRlY29kZTogKHRvKSA9PiBmbih0bykgfTtcbn1cbi8qKlxuICogU2xvdzogTyhuXjIpIHRpbWUgY29tcGxleGl0eVxuICovXG5mdW5jdGlvbiBjb252ZXJ0UmFkaXgoZGF0YSwgZnJvbSwgdG8pIHtcbiAgICAvLyBiYXNlIDEgaXMgaW1wb3NzaWJsZVxuICAgIGlmIChmcm9tIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXg6IGludmFsaWQgZnJvbT0ke2Zyb219LCBiYXNlIGNhbm5vdCBiZSBsZXNzIHRoYW4gMmApO1xuICAgIGlmICh0byA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4OiBpbnZhbGlkIHRvPSR7dG99LCBiYXNlIGNhbm5vdCBiZSBsZXNzIHRoYW4gMmApO1xuICAgIGFBcnIoZGF0YSk7XG4gICAgaWYgKCFkYXRhLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIGxldCBwb3MgPSAwO1xuICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgIGNvbnN0IGRpZ2l0cyA9IEFycmF5LmZyb20oZGF0YSwgKGQpID0+IHtcbiAgICAgICAgYW51bWJlcihkKTtcbiAgICAgICAgaWYgKGQgPCAwIHx8IGQgPj0gZnJvbSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBpbnRlZ2VyOiAke2R9YCk7XG4gICAgICAgIHJldHVybiBkO1xuICAgIH0pO1xuICAgIGNvbnN0IGRsZW4gPSBkaWdpdHMubGVuZ3RoO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGxldCBjYXJyeSA9IDA7XG4gICAgICAgIGxldCBkb25lID0gdHJ1ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHBvczsgaSA8IGRsZW47IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZGlnaXQgPSBkaWdpdHNbaV07XG4gICAgICAgICAgICBjb25zdCBmcm9tQ2FycnkgPSBmcm9tICogY2Fycnk7XG4gICAgICAgICAgICBjb25zdCBkaWdpdEJhc2UgPSBmcm9tQ2FycnkgKyBkaWdpdDtcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoZGlnaXRCYXNlKSB8fFxuICAgICAgICAgICAgICAgIGZyb21DYXJyeSAvIGZyb20gIT09IGNhcnJ5IHx8XG4gICAgICAgICAgICAgICAgZGlnaXRCYXNlIC0gZGlnaXQgIT09IGZyb21DYXJyeSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY29udmVydFJhZGl4OiBjYXJyeSBvdmVyZmxvdycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGl2ID0gZGlnaXRCYXNlIC8gdG87XG4gICAgICAgICAgICBjYXJyeSA9IGRpZ2l0QmFzZSAlIHRvO1xuICAgICAgICAgICAgY29uc3Qgcm91bmRlZCA9IE1hdGguZmxvb3IoZGl2KTtcbiAgICAgICAgICAgIGRpZ2l0c1tpXSA9IHJvdW5kZWQ7XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKHJvdW5kZWQpIHx8IHJvdW5kZWQgKiB0byArIGNhcnJ5ICE9PSBkaWdpdEJhc2UpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb252ZXJ0UmFkaXg6IGNhcnJ5IG92ZXJmbG93Jyk7XG4gICAgICAgICAgICBpZiAoIWRvbmUpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBlbHNlIGlmICghcm91bmRlZClcbiAgICAgICAgICAgICAgICBwb3MgPSBpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGRvbmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXMucHVzaChjYXJyeSk7XG4gICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGggLSAxICYmIGRhdGFbaV0gPT09IDA7IGkrKylcbiAgICAgICAgcmVzLnB1c2goMCk7XG4gICAgcmV0dXJuIHJlcy5yZXZlcnNlKCk7XG59XG5jb25zdCBnY2QgPSAoYSwgYikgPT4gKGIgPT09IDAgPyBhIDogZ2NkKGIsIGEgJSBiKSk7XG5jb25zdCByYWRpeDJjYXJyeSA9IC8qIEBfX05PX1NJREVfRUZGRUNUU19fICovIChmcm9tLCB0bykgPT4gZnJvbSArICh0byAtIGdjZChmcm9tLCB0bykpO1xuY29uc3QgcG93ZXJzID0gLyogQF9fUFVSRV9fICovICgoKSA9PiB7XG4gICAgbGV0IHJlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDA7IGkrKylcbiAgICAgICAgcmVzLnB1c2goMiAqKiBpKTtcbiAgICByZXR1cm4gcmVzO1xufSkoKTtcbi8qKlxuICogSW1wbGVtZW50ZWQgd2l0aCBudW1iZXJzLCBiZWNhdXNlIEJpZ0ludCBpcyA1eCBzbG93ZXJcbiAqL1xuZnVuY3Rpb24gY29udmVydFJhZGl4MihkYXRhLCBmcm9tLCB0bywgcGFkZGluZykge1xuICAgIGFBcnIoZGF0YSk7XG4gICAgaWYgKGZyb20gPD0gMCB8fCBmcm9tID4gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4Mjogd3JvbmcgZnJvbT0ke2Zyb219YCk7XG4gICAgaWYgKHRvIDw9IDAgfHwgdG8gPiAzMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXgyOiB3cm9uZyB0bz0ke3RvfWApO1xuICAgIGlmIChyYWRpeDJjYXJyeShmcm9tLCB0bykgPiAzMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDI6IGNhcnJ5IG92ZXJmbG93IGZyb209JHtmcm9tfSB0bz0ke3RvfSBjYXJyeUJpdHM9JHtyYWRpeDJjYXJyeShmcm9tLCB0byl9YCk7XG4gICAgfVxuICAgIGxldCBjYXJyeSA9IDA7XG4gICAgbGV0IHBvcyA9IDA7IC8vIGJpdHdpc2UgcG9zaXRpb24gaW4gY3VycmVudCBlbGVtZW50XG4gICAgY29uc3QgbWF4ID0gcG93ZXJzW2Zyb21dO1xuICAgIGNvbnN0IG1hc2sgPSBwb3dlcnNbdG9dIC0gMTtcbiAgICBjb25zdCByZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IG4gb2YgZGF0YSkge1xuICAgICAgICBhbnVtYmVyKG4pO1xuICAgICAgICBpZiAobiA+PSBtYXgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDI6IGludmFsaWQgZGF0YSB3b3JkPSR7bn0gZnJvbT0ke2Zyb219YCk7XG4gICAgICAgIGNhcnJ5ID0gKGNhcnJ5IDw8IGZyb20pIHwgbjtcbiAgICAgICAgaWYgKHBvcyArIGZyb20gPiAzMilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4MjogY2Fycnkgb3ZlcmZsb3cgcG9zPSR7cG9zfSBmcm9tPSR7ZnJvbX1gKTtcbiAgICAgICAgcG9zICs9IGZyb207XG4gICAgICAgIGZvciAoOyBwb3MgPj0gdG87IHBvcyAtPSB0bylcbiAgICAgICAgICAgIHJlcy5wdXNoKCgoY2FycnkgPj4gKHBvcyAtIHRvKSkgJiBtYXNrKSA+Pj4gMCk7XG4gICAgICAgIGNvbnN0IHBvdyA9IHBvd2Vyc1twb3NdO1xuICAgICAgICBpZiAocG93ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgY2FycnknKTtcbiAgICAgICAgY2FycnkgJj0gcG93IC0gMTsgLy8gY2xlYW4gY2FycnksIG90aGVyd2lzZSBpdCB3aWxsIGNhdXNlIG92ZXJmbG93XG4gICAgfVxuICAgIGNhcnJ5ID0gKGNhcnJ5IDw8ICh0byAtIHBvcykpICYgbWFzaztcbiAgICBpZiAoIXBhZGRpbmcgJiYgcG9zID49IGZyb20pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhjZXNzIHBhZGRpbmcnKTtcbiAgICBpZiAoIXBhZGRpbmcgJiYgY2FycnkgPiAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vbi16ZXJvIHBhZGRpbmc6ICR7Y2Fycnl9YCk7XG4gICAgaWYgKHBhZGRpbmcgJiYgcG9zID4gMClcbiAgICAgICAgcmVzLnB1c2goY2FycnkgPj4+IDApO1xuICAgIHJldHVybiByZXM7XG59XG4vKipcbiAqIEBfX05PX1NJREVfRUZGRUNUU19fXG4gKi9cbmZ1bmN0aW9uIHJhZGl4KG51bSkge1xuICAgIGFudW1iZXIobnVtKTtcbiAgICBjb25zdCBfMjU2ID0gMiAqKiA4O1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZTogKGJ5dGVzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWlzQnl0ZXMoYnl0ZXMpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmFkaXguZW5jb2RlIGlucHV0IHNob3VsZCBiZSBVaW50OEFycmF5Jyk7XG4gICAgICAgICAgICByZXR1cm4gY29udmVydFJhZGl4KEFycmF5LmZyb20oYnl0ZXMpLCBfMjU2LCBudW0pO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGU6IChkaWdpdHMpID0+IHtcbiAgICAgICAgICAgIGFudW1BcnIoJ3JhZGl4LmRlY29kZScsIGRpZ2l0cyk7XG4gICAgICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGNvbnZlcnRSYWRpeChkaWdpdHMsIG51bSwgXzI1NikpO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vKipcbiAqIElmIGJvdGggYmFzZXMgYXJlIHBvd2VyIG9mIHNhbWUgbnVtYmVyIChsaWtlIGAyKio4IDwtPiAyKio2NGApLFxuICogdGhlcmUgaXMgYSBsaW5lYXIgYWxnb3JpdGhtLiBGb3Igbm93IHdlIGhhdmUgaW1wbGVtZW50YXRpb24gZm9yIHBvd2VyLW9mLXR3byBiYXNlcyBvbmx5LlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuZnVuY3Rpb24gcmFkaXgyKGJpdHMsIHJldlBhZGRpbmcgPSBmYWxzZSkge1xuICAgIGFudW1iZXIoYml0cyk7XG4gICAgaWYgKGJpdHMgPD0gMCB8fCBiaXRzID4gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmFkaXgyOiBiaXRzIHNob3VsZCBiZSBpbiAoMC4uMzJdJyk7XG4gICAgaWYgKHJhZGl4MmNhcnJ5KDgsIGJpdHMpID4gMzIgfHwgcmFkaXgyY2FycnkoYml0cywgOCkgPiAzMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpeDI6IGNhcnJ5IG92ZXJmbG93Jyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlOiAoYnl0ZXMpID0+IHtcbiAgICAgICAgICAgIGlmICghaXNCeXRlcyhieXRlcykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpeDIuZW5jb2RlIGlucHV0IHNob3VsZCBiZSBVaW50OEFycmF5Jyk7XG4gICAgICAgICAgICByZXR1cm4gY29udmVydFJhZGl4MihBcnJheS5mcm9tKGJ5dGVzKSwgOCwgYml0cywgIXJldlBhZGRpbmcpO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGU6IChkaWdpdHMpID0+IHtcbiAgICAgICAgICAgIGFudW1BcnIoJ3JhZGl4Mi5kZWNvZGUnLCBkaWdpdHMpO1xuICAgICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShjb252ZXJ0UmFkaXgyKGRpZ2l0cywgYml0cywgOCwgcmV2UGFkZGluZykpO1xuICAgICAgICB9LFxuICAgIH07XG59XG5mdW5jdGlvbiB1bnNhZmVXcmFwcGVyKGZuKSB7XG4gICAgYWZuKGZuKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNoZWNrc3VtKGxlbiwgZm4pIHtcbiAgICBhbnVtYmVyKGxlbik7XG4gICAgYWZuKGZuKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGUoZGF0YSkge1xuICAgICAgICAgICAgaWYgKCFpc0J5dGVzKGRhdGEpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2hlY2tzdW0uZW5jb2RlOiBpbnB1dCBzaG91bGQgYmUgVWludDhBcnJheScpO1xuICAgICAgICAgICAgY29uc3Qgc3VtID0gZm4oZGF0YSkuc2xpY2UoMCwgbGVuKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KGRhdGEubGVuZ3RoICsgbGVuKTtcbiAgICAgICAgICAgIHJlcy5zZXQoZGF0YSk7XG4gICAgICAgICAgICByZXMuc2V0KHN1bSwgZGF0YS5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlKGRhdGEpIHtcbiAgICAgICAgICAgIGlmICghaXNCeXRlcyhkYXRhKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NoZWNrc3VtLmRlY29kZTogaW5wdXQgc2hvdWxkIGJlIFVpbnQ4QXJyYXknKTtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBkYXRhLnNsaWNlKDAsIC1sZW4pO1xuICAgICAgICAgICAgY29uc3Qgb2xkQ2hlY2tzdW0gPSBkYXRhLnNsaWNlKC1sZW4pO1xuICAgICAgICAgICAgY29uc3QgbmV3Q2hlY2tzdW0gPSBmbihwYXlsb2FkKS5zbGljZSgwLCBsZW4pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgICAgICAgICAgICBpZiAobmV3Q2hlY2tzdW1baV0gIT09IG9sZENoZWNrc3VtW2ldKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY2hlY2tzdW0nKTtcbiAgICAgICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vLyBwcmV0dGllci1pZ25vcmVcbmV4cG9ydCBjb25zdCB1dGlscyA9IHtcbiAgICBhbHBoYWJldCwgY2hhaW4sIGNoZWNrc3VtLCBjb252ZXJ0UmFkaXgsIGNvbnZlcnRSYWRpeDIsIHJhZGl4LCByYWRpeDIsIGpvaW4sIHBhZGRpbmcsXG59O1xuLy8gUkZDIDQ2NDggYWthIFJGQyAzNTQ4XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8qKlxuICogYmFzZTE2IGVuY29kaW5nLlxuICovXG5leHBvcnQgY29uc3QgYmFzZTE2ID0gY2hhaW4ocmFkaXgyKDQpLCBhbHBoYWJldCgnMDEyMzQ1Njc4OUFCQ0RFRicpLCBqb2luKCcnKSk7XG5leHBvcnQgY29uc3QgYmFzZTMyID0gY2hhaW4ocmFkaXgyKDUpLCBhbHBoYWJldCgnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVoyMzQ1NjcnKSwgcGFkZGluZyg1KSwgam9pbignJykpO1xuZXhwb3J0IGNvbnN0IGJhc2UzMm5vcGFkID0gY2hhaW4ocmFkaXgyKDUpLCBhbHBoYWJldCgnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVoyMzQ1NjcnKSwgam9pbignJykpO1xuZXhwb3J0IGNvbnN0IGJhc2UzMmhleCA9IGNoYWluKHJhZGl4Mig1KSwgYWxwaGFiZXQoJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWJyksIHBhZGRpbmcoNSksIGpvaW4oJycpKTtcbmV4cG9ydCBjb25zdCBiYXNlMzJoZXhub3BhZCA9IGNoYWluKHJhZGl4Mig1KSwgYWxwaGFiZXQoJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWJyksIGpvaW4oJycpKTtcbmV4cG9ydCBjb25zdCBiYXNlMzJjcm9ja2ZvcmQgPSBjaGFpbihyYWRpeDIoNSksIGFscGhhYmV0KCcwMTIzNDU2Nzg5QUJDREVGR0hKS01OUFFSU1RWV1hZWicpLCBqb2luKCcnKSwgbm9ybWFsaXplKChzKSA9PiBzLnRvVXBwZXJDYXNlKCkucmVwbGFjZSgvTy9nLCAnMCcpLnJlcGxhY2UoL1tJTF0vZywgJzEnKSkpO1xuLyoqXG4gKiBiYXNlNjQgd2l0aCBwYWRkaW5nLiBGb3Igbm8gcGFkZGluZywgdXNlIGBiYXNlNjRub3BhZGAuXG4gKiBAZXhhbXBsZVxuICogY29uc3QgYiA9IGJhc2U2NC5kZWNvZGUoJ0E5NTEnKTsgLy8gVWludDhBcnJheS5mcm9tKFsgMywgMjIyLCAxMTcgXSlcbiAqIGJhc2U2NC5lbmNvZGUoYik7IC8vICdBOTUxJ1xuICovXG5leHBvcnQgY29uc3QgYmFzZTY0ID0gY2hhaW4ocmFkaXgyKDYpLCBhbHBoYWJldCgnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLycpLCBwYWRkaW5nKDYpLCBqb2luKCcnKSk7XG4vKipcbiAqIGJhc2U2NCB3aXRob3V0IHBhZGRpbmcuXG4gKi9cbmV4cG9ydCBjb25zdCBiYXNlNjRub3BhZCA9IGNoYWluKHJhZGl4Mig2KSwgYWxwaGFiZXQoJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nKSwgam9pbignJykpO1xuZXhwb3J0IGNvbnN0IGJhc2U2NHVybCA9IGNoYWluKHJhZGl4Mig2KSwgYWxwaGFiZXQoJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5LV8nKSwgcGFkZGluZyg2KSwgam9pbignJykpO1xuZXhwb3J0IGNvbnN0IGJhc2U2NHVybG5vcGFkID0gY2hhaW4ocmFkaXgyKDYpLCBhbHBoYWJldCgnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktXycpLCBqb2luKCcnKSk7XG4vLyBiYXNlNTggY29kZVxuLy8gLS0tLS0tLS0tLS1cbmNvbnN0IGdlbkJhc2U1OCA9IC8qIEBfX05PX1NJREVfRUZGRUNUU19fICovIChhYmMpID0+IGNoYWluKHJhZGl4KDU4KSwgYWxwaGFiZXQoYWJjKSwgam9pbignJykpO1xuLyoqXG4gKiBCYXNlNTg6IGJhc2U2NCB3aXRob3V0IGNoYXJhY3RlcnMgKywgLywgMCwgTywgSSwgbC5cbiAqIFF1YWRyYXRpYyAoTyhuXjIpKSAtIHNvLCBjYW4ndCBiZSB1c2VkIG9uIGxhcmdlIGlucHV0cy5cbiAqL1xuZXhwb3J0IGNvbnN0IGJhc2U1OCA9IGdlbkJhc2U1OCgnMTIzNDU2Nzg5QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaYWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5eicpO1xuZXhwb3J0IGNvbnN0IGJhc2U1OGZsaWNrciA9IGdlbkJhc2U1OCgnMTIzNDU2Nzg5YWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5ekFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWicpO1xuZXhwb3J0IGNvbnN0IGJhc2U1OHhycCA9IGdlbkJhc2U1OCgncnBzaG5hZjM5d0JVRE5FR0hKS0xNNFBRUlNUN1ZXWFlaMmJjZGVDZzY1amttOG9GcWkxdHV2QXh5eicpO1xuLy8gRGF0YSBsZW4gKGluZGV4KSAtPiBlbmNvZGVkIGJsb2NrIGxlblxuY29uc3QgWE1SX0JMT0NLX0xFTiA9IFswLCAyLCAzLCA1LCA2LCA3LCA5LCAxMCwgMTFdO1xuLyoqXG4gKiBYTVIgdmVyc2lvbiBvZiBiYXNlNTguXG4gKiBEb25lIGluIDgtYnl0ZSBibG9ja3MgKHdoaWNoIGVxdWFscyAxMSBjaGFycyBpbiBkZWNvZGluZykuIExhc3QgKG5vbi1mdWxsKSBibG9jayBwYWRkZWQgd2l0aCAnMScgdG8gc2l6ZSBpbiBYTVJfQkxPQ0tfTEVOLlxuICogQmxvY2sgZW5jb2Rpbmcgc2lnbmlmaWNhbnRseSByZWR1Y2VzIHF1YWRyYXRpYyBjb21wbGV4aXR5IG9mIGJhc2U1OC5cbiAqL1xuZXhwb3J0IGNvbnN0IGJhc2U1OHhtciA9IHtcbiAgICBlbmNvZGUoZGF0YSkge1xuICAgICAgICBsZXQgcmVzID0gJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gOCkge1xuICAgICAgICAgICAgY29uc3QgYmxvY2sgPSBkYXRhLnN1YmFycmF5KGksIGkgKyA4KTtcbiAgICAgICAgICAgIHJlcyArPSBiYXNlNTguZW5jb2RlKGJsb2NrKS5wYWRTdGFydChYTVJfQkxPQ0tfTEVOW2Jsb2NrLmxlbmd0aF0sICcxJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9LFxuICAgIGRlY29kZShzdHIpIHtcbiAgICAgICAgbGV0IHJlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkgKz0gMTEpIHtcbiAgICAgICAgICAgIGNvbnN0IHNsaWNlID0gc3RyLnNsaWNlKGksIGkgKyAxMSk7XG4gICAgICAgICAgICBjb25zdCBibG9ja0xlbiA9IFhNUl9CTE9DS19MRU4uaW5kZXhPZihzbGljZS5sZW5ndGgpO1xuICAgICAgICAgICAgY29uc3QgYmxvY2sgPSBiYXNlNTguZGVjb2RlKHNsaWNlKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYmxvY2subGVuZ3RoIC0gYmxvY2tMZW47IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChibG9ja1tqXSAhPT0gMClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYXNlNTh4bXI6IHdyb25nIHBhZGRpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcyA9IHJlcy5jb25jYXQoQXJyYXkuZnJvbShibG9jay5zbGljZShibG9jay5sZW5ndGggLSBibG9ja0xlbikpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKHJlcyk7XG4gICAgfSxcbn07XG5leHBvcnQgY29uc3QgY3JlYXRlQmFzZTU4Y2hlY2sgPSAoc2hhMjU2KSA9PiBjaGFpbihjaGVja3N1bSg0LCAoZGF0YSkgPT4gc2hhMjU2KHNoYTI1NihkYXRhKSkpLCBiYXNlNTgpO1xuLyoqXG4gKiBVc2UgYGNyZWF0ZUJhc2U1OGNoZWNrYCBpbnN0ZWFkLlxuICogQGRlcHJlY2F0ZWRcbiAqL1xuZXhwb3J0IGNvbnN0IGJhc2U1OGNoZWNrID0gY3JlYXRlQmFzZTU4Y2hlY2s7XG5jb25zdCBCRUNIX0FMUEhBQkVUID0gY2hhaW4oYWxwaGFiZXQoJ3FwenJ5OXg4Z2YydHZkdzBzM2puNTRraGNlNm11YTdsJyksIGpvaW4oJycpKTtcbmNvbnN0IFBPTFlNT0RfR0VORVJBVE9SUyA9IFsweDNiNmE1N2IyLCAweDI2NTA4ZTZkLCAweDFlYTExOWZhLCAweDNkNDIzM2RkLCAweDJhMTQ2MmIzXTtcbmZ1bmN0aW9uIGJlY2gzMlBvbHltb2QocHJlKSB7XG4gICAgY29uc3QgYiA9IHByZSA+PiAyNTtcbiAgICBsZXQgY2hrID0gKHByZSAmIDB4MWZmZmZmZikgPDwgNTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IFBPTFlNT0RfR0VORVJBVE9SUy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoKChiID4+IGkpICYgMSkgPT09IDEpXG4gICAgICAgICAgICBjaGsgXj0gUE9MWU1PRF9HRU5FUkFUT1JTW2ldO1xuICAgIH1cbiAgICByZXR1cm4gY2hrO1xufVxuZnVuY3Rpb24gYmVjaENoZWNrc3VtKHByZWZpeCwgd29yZHMsIGVuY29kaW5nQ29uc3QgPSAxKSB7XG4gICAgY29uc3QgbGVuID0gcHJlZml4Lmxlbmd0aDtcbiAgICBsZXQgY2hrID0gMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGMgPSBwcmVmaXguY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPCAzMyB8fCBjID4gMTI2KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHByZWZpeCAoJHtwcmVmaXh9KWApO1xuICAgICAgICBjaGsgPSBiZWNoMzJQb2x5bW9kKGNoaykgXiAoYyA+PiA1KTtcbiAgICB9XG4gICAgY2hrID0gYmVjaDMyUG9seW1vZChjaGspO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKSBeIChwcmVmaXguY2hhckNvZGVBdChpKSAmIDB4MWYpO1xuICAgIGZvciAobGV0IHYgb2Ygd29yZHMpXG4gICAgICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKSBeIHY7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspXG4gICAgICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKTtcbiAgICBjaGsgXj0gZW5jb2RpbmdDb25zdDtcbiAgICByZXR1cm4gQkVDSF9BTFBIQUJFVC5lbmNvZGUoY29udmVydFJhZGl4MihbY2hrICUgcG93ZXJzWzMwXV0sIDMwLCA1LCBmYWxzZSkpO1xufVxuLyoqXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5mdW5jdGlvbiBnZW5CZWNoMzIoZW5jb2RpbmcpIHtcbiAgICBjb25zdCBFTkNPRElOR19DT05TVCA9IGVuY29kaW5nID09PSAnYmVjaDMyJyA/IDEgOiAweDJiYzgzMGEzO1xuICAgIGNvbnN0IF93b3JkcyA9IHJhZGl4Mig1KTtcbiAgICBjb25zdCBmcm9tV29yZHMgPSBfd29yZHMuZGVjb2RlO1xuICAgIGNvbnN0IHRvV29yZHMgPSBfd29yZHMuZW5jb2RlO1xuICAgIGNvbnN0IGZyb21Xb3Jkc1Vuc2FmZSA9IHVuc2FmZVdyYXBwZXIoZnJvbVdvcmRzKTtcbiAgICBmdW5jdGlvbiBlbmNvZGUocHJlZml4LCB3b3JkcywgbGltaXQgPSA5MCkge1xuICAgICAgICBhc3RyKCdiZWNoMzIuZW5jb2RlIHByZWZpeCcsIHByZWZpeCk7XG4gICAgICAgIGlmIChpc0J5dGVzKHdvcmRzKSlcbiAgICAgICAgICAgIHdvcmRzID0gQXJyYXkuZnJvbSh3b3Jkcyk7XG4gICAgICAgIGFudW1BcnIoJ2JlY2gzMi5lbmNvZGUnLCB3b3Jkcyk7XG4gICAgICAgIGNvbnN0IHBsZW4gPSBwcmVmaXgubGVuZ3RoO1xuICAgICAgICBpZiAocGxlbiA9PT0gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgcHJlZml4IGxlbmd0aCAke3BsZW59YCk7XG4gICAgICAgIGNvbnN0IGFjdHVhbExlbmd0aCA9IHBsZW4gKyA3ICsgd29yZHMubGVuZ3RoO1xuICAgICAgICBpZiAobGltaXQgIT09IGZhbHNlICYmIGFjdHVhbExlbmd0aCA+IGxpbWl0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTGVuZ3RoICR7YWN0dWFsTGVuZ3RofSBleGNlZWRzIGxpbWl0ICR7bGltaXR9YCk7XG4gICAgICAgIGNvbnN0IGxvd2VyZWQgPSBwcmVmaXgudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3Qgc3VtID0gYmVjaENoZWNrc3VtKGxvd2VyZWQsIHdvcmRzLCBFTkNPRElOR19DT05TVCk7XG4gICAgICAgIHJldHVybiBgJHtsb3dlcmVkfTEke0JFQ0hfQUxQSEFCRVQuZW5jb2RlKHdvcmRzKX0ke3N1bX1gO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWNvZGUoc3RyLCBsaW1pdCA9IDkwKSB7XG4gICAgICAgIGFzdHIoJ2JlY2gzMi5kZWNvZGUgaW5wdXQnLCBzdHIpO1xuICAgICAgICBjb25zdCBzbGVuID0gc3RyLmxlbmd0aDtcbiAgICAgICAgaWYgKHNsZW4gPCA4IHx8IChsaW1pdCAhPT0gZmFsc2UgJiYgc2xlbiA+IGxpbWl0KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGludmFsaWQgc3RyaW5nIGxlbmd0aDogJHtzbGVufSAoJHtzdHJ9KS4gRXhwZWN0ZWQgKDguLiR7bGltaXR9KWApO1xuICAgICAgICAvLyBkb24ndCBhbGxvdyBtaXhlZCBjYXNlXG4gICAgICAgIGNvbnN0IGxvd2VyZWQgPSBzdHIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKHN0ciAhPT0gbG93ZXJlZCAmJiBzdHIgIT09IHN0ci50b1VwcGVyQ2FzZSgpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTdHJpbmcgbXVzdCBiZSBsb3dlcmNhc2Ugb3IgdXBwZXJjYXNlYCk7XG4gICAgICAgIGNvbnN0IHNlcEluZGV4ID0gbG93ZXJlZC5sYXN0SW5kZXhPZignMScpO1xuICAgICAgICBpZiAoc2VwSW5kZXggPT09IDAgfHwgc2VwSW5kZXggPT09IC0xKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMZXR0ZXIgXCIxXCIgbXVzdCBiZSBwcmVzZW50IGJldHdlZW4gcHJlZml4IGFuZCBkYXRhIG9ubHlgKTtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gbG93ZXJlZC5zbGljZSgwLCBzZXBJbmRleCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBsb3dlcmVkLnNsaWNlKHNlcEluZGV4ICsgMSk7XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA8IDYpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgbXVzdCBiZSBhdCBsZWFzdCA2IGNoYXJhY3RlcnMgbG9uZycpO1xuICAgICAgICBjb25zdCB3b3JkcyA9IEJFQ0hfQUxQSEFCRVQuZGVjb2RlKGRhdGEpLnNsaWNlKDAsIC02KTtcbiAgICAgICAgY29uc3Qgc3VtID0gYmVjaENoZWNrc3VtKHByZWZpeCwgd29yZHMsIEVOQ09ESU5HX0NPTlNUKTtcbiAgICAgICAgaWYgKCFkYXRhLmVuZHNXaXRoKHN1bSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY2hlY2tzdW0gaW4gJHtzdHJ9OiBleHBlY3RlZCBcIiR7c3VtfVwiYCk7XG4gICAgICAgIHJldHVybiB7IHByZWZpeCwgd29yZHMgfTtcbiAgICB9XG4gICAgY29uc3QgZGVjb2RlVW5zYWZlID0gdW5zYWZlV3JhcHBlcihkZWNvZGUpO1xuICAgIGZ1bmN0aW9uIGRlY29kZVRvQnl0ZXMoc3RyKSB7XG4gICAgICAgIGNvbnN0IHsgcHJlZml4LCB3b3JkcyB9ID0gZGVjb2RlKHN0ciwgZmFsc2UpO1xuICAgICAgICByZXR1cm4geyBwcmVmaXgsIHdvcmRzLCBieXRlczogZnJvbVdvcmRzKHdvcmRzKSB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbmNvZGVGcm9tQnl0ZXMocHJlZml4LCBieXRlcykge1xuICAgICAgICByZXR1cm4gZW5jb2RlKHByZWZpeCwgdG9Xb3JkcyhieXRlcykpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGUsXG4gICAgICAgIGRlY29kZSxcbiAgICAgICAgZW5jb2RlRnJvbUJ5dGVzLFxuICAgICAgICBkZWNvZGVUb0J5dGVzLFxuICAgICAgICBkZWNvZGVVbnNhZmUsXG4gICAgICAgIGZyb21Xb3JkcyxcbiAgICAgICAgZnJvbVdvcmRzVW5zYWZlLFxuICAgICAgICB0b1dvcmRzLFxuICAgIH07XG59XG4vKipcbiAqIExvdy1sZXZlbCBiZWNoMzIgb3BlcmF0aW9ucy4gT3BlcmF0ZXMgb24gd29yZHMuXG4gKi9cbmV4cG9ydCBjb25zdCBiZWNoMzIgPSBnZW5CZWNoMzIoJ2JlY2gzMicpO1xuZXhwb3J0IGNvbnN0IGJlY2gzMm0gPSBnZW5CZWNoMzIoJ2JlY2gzMm0nKTtcbi8qKlxuICogVVRGLTgtdG8tYnl0ZSBkZWNvZGVyLiBVc2VzIGJ1aWx0LWluIFRleHREZWNvZGVyIC8gVGV4dEVuY29kZXIuXG4gKiBAZXhhbXBsZVxuICogY29uc3QgYiA9IHV0ZjguZGVjb2RlKFwiaGV5XCIpOyAvLyA9PiBuZXcgVWludDhBcnJheShbIDEwNCwgMTAxLCAxMjEgXSlcbiAqIGNvbnN0IHN0ciA9IHV0ZjguZW5jb2RlKGIpOyAvLyBcImhleVwiXG4gKi9cbmV4cG9ydCBjb25zdCB1dGY4ID0ge1xuICAgIGVuY29kZTogKGRhdGEpID0+IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShkYXRhKSxcbiAgICBkZWNvZGU6IChzdHIpID0+IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpLFxufTtcbi8qKlxuICogaGV4IHN0cmluZyBkZWNvZGVyLlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IGIgPSBoZXguZGVjb2RlKFwiMDEwMmZmXCIpOyAvLyA9PiBuZXcgVWludDhBcnJheShbIDEsIDIsIDI1NSBdKVxuICogY29uc3Qgc3RyID0gaGV4LmVuY29kZShiKTsgLy8gXCIwMTAyZmZcIlxuICovXG5leHBvcnQgY29uc3QgaGV4ID0gY2hhaW4ocmFkaXgyKDQpLCBhbHBoYWJldCgnMDEyMzQ1Njc4OWFiY2RlZicpLCBqb2luKCcnKSwgbm9ybWFsaXplKChzKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBzICE9PSAnc3RyaW5nJyB8fCBzLmxlbmd0aCAlIDIgIT09IDApXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGhleC5kZWNvZGU6IGV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIHN9IHdpdGggbGVuZ3RoICR7cy5sZW5ndGh9YCk7XG4gICAgcmV0dXJuIHMudG9Mb3dlckNhc2UoKTtcbn0pKTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgQ09ERVJTID0ge1xuICAgIHV0ZjgsIGhleCwgYmFzZTE2LCBiYXNlMzIsIGJhc2U2NCwgYmFzZTY0dXJsLCBiYXNlNTgsIGJhc2U1OHhtclxufTtcbmNvbnN0IGNvZGVyVHlwZUVycm9yID0gJ0ludmFsaWQgZW5jb2RpbmcgdHlwZS4gQXZhaWxhYmxlIHR5cGVzOiB1dGY4LCBoZXgsIGJhc2UxNiwgYmFzZTMyLCBiYXNlNjQsIGJhc2U2NHVybCwgYmFzZTU4LCBiYXNlNTh4bXInO1xuZXhwb3J0IGNvbnN0IGJ5dGVzVG9TdHJpbmcgPSAodHlwZSwgYnl0ZXMpID0+IHtcbiAgICBpZiAodHlwZW9mIHR5cGUgIT09ICdzdHJpbmcnIHx8ICFDT0RFUlMuaGFzT3duUHJvcGVydHkodHlwZSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoY29kZXJUeXBlRXJyb3IpO1xuICAgIGlmICghaXNCeXRlcyhieXRlcykpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2J5dGVzVG9TdHJpbmcoKSBleHBlY3RzIFVpbnQ4QXJyYXknKTtcbiAgICByZXR1cm4gQ09ERVJTW3R5cGVdLmVuY29kZShieXRlcyk7XG59O1xuZXhwb3J0IGNvbnN0IHN0ciA9IGJ5dGVzVG9TdHJpbmc7IC8vIGFzIGluIHB5dGhvbiwgYnV0IGZvciBieXRlcyBvbmx5XG5leHBvcnQgY29uc3Qgc3RyaW5nVG9CeXRlcyA9ICh0eXBlLCBzdHIpID0+IHtcbiAgICBpZiAoIUNPREVSUy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihjb2RlclR5cGVFcnJvcik7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzdHJpbmdUb0J5dGVzKCkgZXhwZWN0cyBzdHJpbmcnKTtcbiAgICByZXR1cm4gQ09ERVJTW3R5cGVdLmRlY29kZShzdHIpO1xufTtcbmV4cG9ydCBjb25zdCBieXRlcyA9IHN0cmluZ1RvQnl0ZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@scure/base/lib/esm/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/debug/src/browser.js":
/*!*******************************************!*\
  !*** ./node_modules/debug/src/browser.js ***!
  \*******************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (() => {\n\tlet warned = false;\n\n\treturn () => {\n\t\tif (!warned) {\n\t\t\twarned = true;\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t\t}\n\t};\n})();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\tlet m;\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\t// eslint-disable-next-line no-return-assign\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/)) && parseInt(m[1], 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (() => {});\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = __webpack_require__(/*! ./common */ \"(app-pages-browser)/./node_modules/debug/src/common.js\")(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQixZQUFZO0FBQ1osWUFBWTtBQUNaLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2YsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDRDQUE0Qzs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLE9BQU8sNkJBQTZCLE9BQU87QUFDN0QsTUFBTSxPQUFPO0FBQ2I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLG1CQUFPLENBQUMsd0VBQVU7O0FBRW5DLE9BQU8sWUFBWTs7QUFFbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2xmZy9HaXQvTWFkdHJpcHMvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9IGxvY2Fsc3RvcmFnZSgpO1xuZXhwb3J0cy5kZXN0cm95ID0gKCgpID0+IHtcblx0bGV0IHdhcm5lZCA9IGZhbHNlO1xuXG5cdHJldHVybiAoKSA9PiB7XG5cdFx0aWYgKCF3YXJuZWQpIHtcblx0XHRcdHdhcm5lZCA9IHRydWU7XG5cdFx0XHRjb25zb2xlLndhcm4oJ0luc3RhbmNlIG1ldGhvZCBgZGVidWcuZGVzdHJveSgpYCBpcyBkZXByZWNhdGVkIGFuZCBubyBsb25nZXIgZG9lcyBhbnl0aGluZy4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgYGRlYnVnYC4nKTtcblx0XHR9XG5cdH07XG59KSgpO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFtcblx0JyMwMDAwQ0MnLFxuXHQnIzAwMDBGRicsXG5cdCcjMDAzM0NDJyxcblx0JyMwMDMzRkYnLFxuXHQnIzAwNjZDQycsXG5cdCcjMDA2NkZGJyxcblx0JyMwMDk5Q0MnLFxuXHQnIzAwOTlGRicsXG5cdCcjMDBDQzAwJyxcblx0JyMwMENDMzMnLFxuXHQnIzAwQ0M2NicsXG5cdCcjMDBDQzk5Jyxcblx0JyMwMENDQ0MnLFxuXHQnIzAwQ0NGRicsXG5cdCcjMzMwMENDJyxcblx0JyMzMzAwRkYnLFxuXHQnIzMzMzNDQycsXG5cdCcjMzMzM0ZGJyxcblx0JyMzMzY2Q0MnLFxuXHQnIzMzNjZGRicsXG5cdCcjMzM5OUNDJyxcblx0JyMzMzk5RkYnLFxuXHQnIzMzQ0MwMCcsXG5cdCcjMzNDQzMzJyxcblx0JyMzM0NDNjYnLFxuXHQnIzMzQ0M5OScsXG5cdCcjMzNDQ0NDJyxcblx0JyMzM0NDRkYnLFxuXHQnIzY2MDBDQycsXG5cdCcjNjYwMEZGJyxcblx0JyM2NjMzQ0MnLFxuXHQnIzY2MzNGRicsXG5cdCcjNjZDQzAwJyxcblx0JyM2NkNDMzMnLFxuXHQnIzk5MDBDQycsXG5cdCcjOTkwMEZGJyxcblx0JyM5OTMzQ0MnLFxuXHQnIzk5MzNGRicsXG5cdCcjOTlDQzAwJyxcblx0JyM5OUNDMzMnLFxuXHQnI0NDMDAwMCcsXG5cdCcjQ0MwMDMzJyxcblx0JyNDQzAwNjYnLFxuXHQnI0NDMDA5OScsXG5cdCcjQ0MwMENDJyxcblx0JyNDQzAwRkYnLFxuXHQnI0NDMzMwMCcsXG5cdCcjQ0MzMzMzJyxcblx0JyNDQzMzNjYnLFxuXHQnI0NDMzM5OScsXG5cdCcjQ0MzM0NDJyxcblx0JyNDQzMzRkYnLFxuXHQnI0NDNjYwMCcsXG5cdCcjQ0M2NjMzJyxcblx0JyNDQzk5MDAnLFxuXHQnI0NDOTkzMycsXG5cdCcjQ0NDQzAwJyxcblx0JyNDQ0NDMzMnLFxuXHQnI0ZGMDAwMCcsXG5cdCcjRkYwMDMzJyxcblx0JyNGRjAwNjYnLFxuXHQnI0ZGMDA5OScsXG5cdCcjRkYwMENDJyxcblx0JyNGRjAwRkYnLFxuXHQnI0ZGMzMwMCcsXG5cdCcjRkYzMzMzJyxcblx0JyNGRjMzNjYnLFxuXHQnI0ZGMzM5OScsXG5cdCcjRkYzM0NDJyxcblx0JyNGRjMzRkYnLFxuXHQnI0ZGNjYwMCcsXG5cdCcjRkY2NjMzJyxcblx0JyNGRjk5MDAnLFxuXHQnI0ZGOTkzMycsXG5cdCcjRkZDQzAwJyxcblx0JyNGRkNDMzMnXG5dO1xuXG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG5cdC8vIE5COiBJbiBhbiBFbGVjdHJvbiBwcmVsb2FkIHNjcmlwdCwgZG9jdW1lbnQgd2lsbCBiZSBkZWZpbmVkIGJ1dCBub3QgZnVsbHlcblx0Ly8gaW5pdGlhbGl6ZWQuIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gQ2hyb21lLCB3ZSdsbCBqdXN0IGRldGVjdCB0aGlzIGNhc2Vcblx0Ly8gZXhwbGljaXRseVxuXHRpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnByb2Nlc3MgJiYgKHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicgfHwgd2luZG93LnByb2Nlc3MuX19ud2pzKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Ly8gSW50ZXJuZXQgRXhwbG9yZXIgYW5kIEVkZ2UgZG8gbm90IHN1cHBvcnQgY29sb3JzLlxuXHRpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goLyhlZGdlfHRyaWRlbnQpXFwvKFxcZCspLykpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRsZXQgbTtcblxuXHQvLyBJcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuXHQvLyBkb2N1bWVudCBpcyB1bmRlZmluZWQgaW4gcmVhY3QtbmF0aXZlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtbmF0aXZlL3B1bGwvMTYzMlxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmV0dXJuLWFzc2lnblxuXHRyZXR1cm4gKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuV2Via2l0QXBwZWFyYW5jZSkgfHxcblx0XHQvLyBJcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG5cdFx0KHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS5maXJlYnVnIHx8ICh3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpKSkgfHxcblx0XHQvLyBJcyBmaXJlZm94ID49IHYzMT9cblx0XHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcblx0XHQodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiAobSA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pKSAmJiBwYXJzZUludChtWzFdLCAxMCkgPj0gMzEpIHx8XG5cdFx0Ly8gRG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuXHRcdCh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKSk7XG59XG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG5cdGFyZ3NbMF0gPSAodGhpcy51c2VDb2xvcnMgPyAnJWMnIDogJycpICtcblx0XHR0aGlzLm5hbWVzcGFjZSArXG5cdFx0KHRoaXMudXNlQ29sb3JzID8gJyAlYycgOiAnICcpICtcblx0XHRhcmdzWzBdICtcblx0XHQodGhpcy51c2VDb2xvcnMgPyAnJWMgJyA6ICcgJykgK1xuXHRcdCcrJyArIG1vZHVsZS5leHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cblx0aWYgKCF0aGlzLnVzZUNvbG9ycykge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGNvbnN0IGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuXHRhcmdzLnNwbGljZSgxLCAwLCBjLCAnY29sb3I6IGluaGVyaXQnKTtcblxuXHQvLyBUaGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuXHQvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG5cdC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuXHRsZXQgaW5kZXggPSAwO1xuXHRsZXQgbGFzdEMgPSAwO1xuXHRhcmdzWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZywgbWF0Y2ggPT4ge1xuXHRcdGlmIChtYXRjaCA9PT0gJyUlJykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpbmRleCsrO1xuXHRcdGlmIChtYXRjaCA9PT0gJyVjJykge1xuXHRcdFx0Ly8gV2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG5cdFx0XHQvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuXHRcdFx0bGFzdEMgPSBpbmRleDtcblx0XHR9XG5cdH0pO1xuXG5cdGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmRlYnVnKClgIHdoZW4gYXZhaWxhYmxlLlxuICogTm8tb3Agd2hlbiBgY29uc29sZS5kZWJ1Z2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICogSWYgYGNvbnNvbGUuZGVidWdgIGlzIG5vdCBhdmFpbGFibGUsIGZhbGxzIGJhY2tcbiAqIHRvIGBjb25zb2xlLmxvZ2AuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZXhwb3J0cy5sb2cgPSBjb25zb2xlLmRlYnVnIHx8IGNvbnNvbGUubG9nIHx8ICgoKSA9PiB7fSk7XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcblx0dHJ5IHtcblx0XHRpZiAobmFtZXNwYWNlcykge1xuXHRcdFx0ZXhwb3J0cy5zdG9yYWdlLnNldEl0ZW0oJ2RlYnVnJywgbmFtZXNwYWNlcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuXHRcdH1cblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbG9hZCgpIHtcblx0bGV0IHI7XG5cdHRyeSB7XG5cdFx0ciA9IGV4cG9ydHMuc3RvcmFnZS5nZXRJdGVtKCdkZWJ1ZycpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxuXG5cdC8vIElmIGRlYnVnIGlzbid0IHNldCBpbiBMUywgYW5kIHdlJ3JlIGluIEVsZWN0cm9uLCB0cnkgdG8gbG9hZCAkREVCVUdcblx0aWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG5cdFx0ciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuXHR9XG5cblx0cmV0dXJuIHI7XG59XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuXHR0cnkge1xuXHRcdC8vIFRWTUxLaXQgKEFwcGxlIFRWIEpTIFJ1bnRpbWUpIGRvZXMgbm90IGhhdmUgYSB3aW5kb3cgb2JqZWN0LCBqdXN0IGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHRcblx0XHQvLyBUaGUgQnJvd3NlciBhbHNvIGhhcyBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0LlxuXHRcdHJldHVybiBsb2NhbFN0b3JhZ2U7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9jb21tb24nKShleHBvcnRzKTtcblxuY29uc3Qge2Zvcm1hdHRlcnN9ID0gbW9kdWxlLmV4cG9ydHM7XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uICh2KSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdHJldHVybiAnW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06ICcgKyBlcnJvci5tZXNzYWdlO1xuXHR9XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/debug/src/browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/debug/src/common.js":
/*!******************************************!*\
  !*** ./node_modules/debug/src/common.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = __webpack_require__(/*! ms */ \"(app-pages-browser)/./node_modules/ms/index.js\");\n\tcreateDebug.destroy = destroy;\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\t\tlet enableOverride = null;\n\t\tlet namespacesCache;\n\t\tlet enabledCache;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn '%';\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = createDebug.selectColor(namespace);\n\t\tdebug.extend = extend;\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n\t\tObject.defineProperty(debug, 'enabled', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false,\n\t\t\tget: () => {\n\t\t\t\tif (enableOverride !== null) {\n\t\t\t\t\treturn enableOverride;\n\t\t\t\t}\n\t\t\t\tif (namespacesCache !== createDebug.namespaces) {\n\t\t\t\t\tnamespacesCache = createDebug.namespaces;\n\t\t\t\t\tenabledCache = createDebug.enabled(namespace);\n\t\t\t\t}\n\n\t\t\t\treturn enabledCache;\n\t\t\t},\n\t\t\tset: v => {\n\t\t\t\tenableOverride = v;\n\t\t\t}\n\t\t});\n\n\t\t// Env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\treturn debug;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\t\tcreateDebug.namespaces = namespaces;\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '')\n\t\t\t.trim()\n\t\t\t.replace(' ', ',')\n\t\t\t.split(',')\n\t\t\t.filter(Boolean);\n\n\t\tfor (const ns of split) {\n\t\t\tif (ns[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(ns.slice(1));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(ns);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Checks if the given string matches a namespace template, honoring\n\t * asterisks as wildcards.\n\t *\n\t * @param {String} search\n\t * @param {String} template\n\t * @return {Boolean}\n\t */\n\tfunction matchesTemplate(search, template) {\n\t\tlet searchIndex = 0;\n\t\tlet templateIndex = 0;\n\t\tlet starIndex = -1;\n\t\tlet matchIndex = 0;\n\n\t\twhile (searchIndex < search.length) {\n\t\t\tif (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === '*')) {\n\t\t\t\t// Match character or proceed with wildcard\n\t\t\t\tif (template[templateIndex] === '*') {\n\t\t\t\t\tstarIndex = templateIndex;\n\t\t\t\t\tmatchIndex = searchIndex;\n\t\t\t\t\ttemplateIndex++; // Skip the '*'\n\t\t\t\t} else {\n\t\t\t\t\tsearchIndex++;\n\t\t\t\t\ttemplateIndex++;\n\t\t\t\t}\n\t\t\t} else if (starIndex !== -1) { // eslint-disable-line no-negated-condition\n\t\t\t\t// Backtrack to the last '*' and try to match more characters\n\t\t\t\ttemplateIndex = starIndex + 1;\n\t\t\t\tmatchIndex++;\n\t\t\t\tsearchIndex = matchIndex;\n\t\t\t} else {\n\t\t\t\treturn false; // No match\n\t\t\t}\n\t\t}\n\n\t\t// Handle trailing '*' in template\n\t\twhile (templateIndex < template.length && template[templateIndex] === '*') {\n\t\t\ttemplateIndex++;\n\t\t}\n\n\t\treturn templateIndex === template.length;\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names,\n\t\t\t...createDebug.skips.map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tfor (const skip of createDebug.skips) {\n\t\t\tif (matchesTemplate(name, skip)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (const ns of createDebug.names) {\n\t\t\tif (matchesTemplate(name, ns)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/\n\tfunction destroy() {\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvY29tbW9uLmpzIiwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBTyxDQUFDLDBEQUFJO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEtBQUssNkJBQTZCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi9ob21lL2xmZy9HaXQvTWFkdHJpcHMvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9jb21tb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKi9cblxuZnVuY3Rpb24gc2V0dXAoZW52KSB7XG5cdGNyZWF0ZURlYnVnLmRlYnVnID0gY3JlYXRlRGVidWc7XG5cdGNyZWF0ZURlYnVnLmRlZmF1bHQgPSBjcmVhdGVEZWJ1Zztcblx0Y3JlYXRlRGVidWcuY29lcmNlID0gY29lcmNlO1xuXHRjcmVhdGVEZWJ1Zy5kaXNhYmxlID0gZGlzYWJsZTtcblx0Y3JlYXRlRGVidWcuZW5hYmxlID0gZW5hYmxlO1xuXHRjcmVhdGVEZWJ1Zy5lbmFibGVkID0gZW5hYmxlZDtcblx0Y3JlYXRlRGVidWcuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xuXHRjcmVhdGVEZWJ1Zy5kZXN0cm95ID0gZGVzdHJveTtcblxuXHRPYmplY3Qua2V5cyhlbnYpLmZvckVhY2goa2V5ID0+IHtcblx0XHRjcmVhdGVEZWJ1Z1trZXldID0gZW52W2tleV07XG5cdH0pO1xuXG5cdC8qKlxuXHQqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuXHQqL1xuXG5cdGNyZWF0ZURlYnVnLm5hbWVzID0gW107XG5cdGNyZWF0ZURlYnVnLnNraXBzID0gW107XG5cblx0LyoqXG5cdCogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuXHQqXG5cdCogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXIgb3IgdXBwZXItY2FzZSBsZXR0ZXIsIGkuZS4gXCJuXCIgYW5kIFwiTlwiLlxuXHQqL1xuXHRjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzID0ge307XG5cblx0LyoqXG5cdCogU2VsZWN0cyBhIGNvbG9yIGZvciBhIGRlYnVnIG5hbWVzcGFjZVxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2UgVGhlIG5hbWVzcGFjZSBzdHJpbmcgZm9yIHRoZSBkZWJ1ZyBpbnN0YW5jZSB0byBiZSBjb2xvcmVkXG5cdCogQHJldHVybiB7TnVtYmVyfFN0cmluZ30gQW4gQU5TSSBjb2xvciBjb2RlIGZvciB0aGUgZ2l2ZW4gbmFtZXNwYWNlXG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIHNlbGVjdENvbG9yKG5hbWVzcGFjZSkge1xuXHRcdGxldCBoYXNoID0gMDtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXNwYWNlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRoYXNoID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgKyBuYW1lc3BhY2UuY2hhckNvZGVBdChpKTtcblx0XHRcdGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNyZWF0ZURlYnVnLmNvbG9yc1tNYXRoLmFicyhoYXNoKSAlIGNyZWF0ZURlYnVnLmNvbG9ycy5sZW5ndGhdO1xuXHR9XG5cdGNyZWF0ZURlYnVnLnNlbGVjdENvbG9yID0gc2VsZWN0Q29sb3I7XG5cblx0LyoqXG5cdCogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG5cdCogQHJldHVybiB7RnVuY3Rpb259XG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gY3JlYXRlRGVidWcobmFtZXNwYWNlKSB7XG5cdFx0bGV0IHByZXZUaW1lO1xuXHRcdGxldCBlbmFibGVPdmVycmlkZSA9IG51bGw7XG5cdFx0bGV0IG5hbWVzcGFjZXNDYWNoZTtcblx0XHRsZXQgZW5hYmxlZENhY2hlO1xuXG5cdFx0ZnVuY3Rpb24gZGVidWcoLi4uYXJncykge1xuXHRcdFx0Ly8gRGlzYWJsZWQ/XG5cdFx0XHRpZiAoIWRlYnVnLmVuYWJsZWQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBzZWxmID0gZGVidWc7XG5cblx0XHRcdC8vIFNldCBgZGlmZmAgdGltZXN0YW1wXG5cdFx0XHRjb25zdCBjdXJyID0gTnVtYmVyKG5ldyBEYXRlKCkpO1xuXHRcdFx0Y29uc3QgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuXHRcdFx0c2VsZi5kaWZmID0gbXM7XG5cdFx0XHRzZWxmLnByZXYgPSBwcmV2VGltZTtcblx0XHRcdHNlbGYuY3VyciA9IGN1cnI7XG5cdFx0XHRwcmV2VGltZSA9IGN1cnI7XG5cblx0XHRcdGFyZ3NbMF0gPSBjcmVhdGVEZWJ1Zy5jb2VyY2UoYXJnc1swXSk7XG5cblx0XHRcdGlmICh0eXBlb2YgYXJnc1swXSAhPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0Ly8gQW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJU9cblx0XHRcdFx0YXJncy51bnNoaWZ0KCclTycpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuXHRcdFx0bGV0IGluZGV4ID0gMDtcblx0XHRcdGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCAobWF0Y2gsIGZvcm1hdCkgPT4ge1xuXHRcdFx0XHQvLyBJZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG5cdFx0XHRcdGlmIChtYXRjaCA9PT0gJyUlJykge1xuXHRcdFx0XHRcdHJldHVybiAnJSc7XG5cdFx0XHRcdH1cblx0XHRcdFx0aW5kZXgrKztcblx0XHRcdFx0Y29uc3QgZm9ybWF0dGVyID0gY3JlYXRlRGVidWcuZm9ybWF0dGVyc1tmb3JtYXRdO1xuXHRcdFx0XHRpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdGNvbnN0IHZhbCA9IGFyZ3NbaW5kZXhdO1xuXHRcdFx0XHRcdG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuXHRcdFx0XHRcdC8vIE5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcblx0XHRcdFx0XHRhcmdzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHRcdFx0aW5kZXgtLTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gQXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmcgKGNvbG9ycywgZXRjLilcblx0XHRcdGNyZWF0ZURlYnVnLmZvcm1hdEFyZ3MuY2FsbChzZWxmLCBhcmdzKTtcblxuXHRcdFx0Y29uc3QgbG9nRm4gPSBzZWxmLmxvZyB8fCBjcmVhdGVEZWJ1Zy5sb2c7XG5cdFx0XHRsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcblx0XHR9XG5cblx0XHRkZWJ1Zy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG5cdFx0ZGVidWcudXNlQ29sb3JzID0gY3JlYXRlRGVidWcudXNlQ29sb3JzKCk7XG5cdFx0ZGVidWcuY29sb3IgPSBjcmVhdGVEZWJ1Zy5zZWxlY3RDb2xvcihuYW1lc3BhY2UpO1xuXHRcdGRlYnVnLmV4dGVuZCA9IGV4dGVuZDtcblx0XHRkZWJ1Zy5kZXN0cm95ID0gY3JlYXRlRGVidWcuZGVzdHJveTsgLy8gWFhYIFRlbXBvcmFyeS4gV2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuXG5cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZGVidWcsICdlbmFibGVkJywge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG5cdFx0XHRnZXQ6ICgpID0+IHtcblx0XHRcdFx0aWYgKGVuYWJsZU92ZXJyaWRlICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVuYWJsZU92ZXJyaWRlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChuYW1lc3BhY2VzQ2FjaGUgIT09IGNyZWF0ZURlYnVnLm5hbWVzcGFjZXMpIHtcblx0XHRcdFx0XHRuYW1lc3BhY2VzQ2FjaGUgPSBjcmVhdGVEZWJ1Zy5uYW1lc3BhY2VzO1xuXHRcdFx0XHRcdGVuYWJsZWRDYWNoZSA9IGNyZWF0ZURlYnVnLmVuYWJsZWQobmFtZXNwYWNlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBlbmFibGVkQ2FjaGU7XG5cdFx0XHR9LFxuXHRcdFx0c2V0OiB2ID0+IHtcblx0XHRcdFx0ZW5hYmxlT3ZlcnJpZGUgPSB2O1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gRW52LXNwZWNpZmljIGluaXRpYWxpemF0aW9uIGxvZ2ljIGZvciBkZWJ1ZyBpbnN0YW5jZXNcblx0XHRpZiAodHlwZW9mIGNyZWF0ZURlYnVnLmluaXQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGNyZWF0ZURlYnVnLmluaXQoZGVidWcpO1xuXHRcdH1cblxuXHRcdHJldHVybiBkZWJ1Zztcblx0fVxuXG5cdGZ1bmN0aW9uIGV4dGVuZChuYW1lc3BhY2UsIGRlbGltaXRlcikge1xuXHRcdGNvbnN0IG5ld0RlYnVnID0gY3JlYXRlRGVidWcodGhpcy5uYW1lc3BhY2UgKyAodHlwZW9mIGRlbGltaXRlciA9PT0gJ3VuZGVmaW5lZCcgPyAnOicgOiBkZWxpbWl0ZXIpICsgbmFtZXNwYWNlKTtcblx0XHRuZXdEZWJ1Zy5sb2cgPSB0aGlzLmxvZztcblx0XHRyZXR1cm4gbmV3RGVidWc7XG5cdH1cblxuXHQvKipcblx0KiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG5cdCogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcblx0XHRjcmVhdGVEZWJ1Zy5zYXZlKG5hbWVzcGFjZXMpO1xuXHRcdGNyZWF0ZURlYnVnLm5hbWVzcGFjZXMgPSBuYW1lc3BhY2VzO1xuXG5cdFx0Y3JlYXRlRGVidWcubmFtZXMgPSBbXTtcblx0XHRjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuXG5cdFx0Y29uc3Qgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnID8gbmFtZXNwYWNlcyA6ICcnKVxuXHRcdFx0LnRyaW0oKVxuXHRcdFx0LnJlcGxhY2UoJyAnLCAnLCcpXG5cdFx0XHQuc3BsaXQoJywnKVxuXHRcdFx0LmZpbHRlcihCb29sZWFuKTtcblxuXHRcdGZvciAoY29uc3QgbnMgb2Ygc3BsaXQpIHtcblx0XHRcdGlmIChuc1swXSA9PT0gJy0nKSB7XG5cdFx0XHRcdGNyZWF0ZURlYnVnLnNraXBzLnB1c2gobnMuc2xpY2UoMSkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y3JlYXRlRGVidWcubmFtZXMucHVzaChucyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gc3RyaW5nIG1hdGNoZXMgYSBuYW1lc3BhY2UgdGVtcGxhdGUsIGhvbm9yaW5nXG5cdCAqIGFzdGVyaXNrcyBhcyB3aWxkY2FyZHMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzZWFyY2hcblx0ICogQHBhcmFtIHtTdHJpbmd9IHRlbXBsYXRlXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCAqL1xuXHRmdW5jdGlvbiBtYXRjaGVzVGVtcGxhdGUoc2VhcmNoLCB0ZW1wbGF0ZSkge1xuXHRcdGxldCBzZWFyY2hJbmRleCA9IDA7XG5cdFx0bGV0IHRlbXBsYXRlSW5kZXggPSAwO1xuXHRcdGxldCBzdGFySW5kZXggPSAtMTtcblx0XHRsZXQgbWF0Y2hJbmRleCA9IDA7XG5cblx0XHR3aGlsZSAoc2VhcmNoSW5kZXggPCBzZWFyY2gubGVuZ3RoKSB7XG5cdFx0XHRpZiAodGVtcGxhdGVJbmRleCA8IHRlbXBsYXRlLmxlbmd0aCAmJiAodGVtcGxhdGVbdGVtcGxhdGVJbmRleF0gPT09IHNlYXJjaFtzZWFyY2hJbmRleF0gfHwgdGVtcGxhdGVbdGVtcGxhdGVJbmRleF0gPT09ICcqJykpIHtcblx0XHRcdFx0Ly8gTWF0Y2ggY2hhcmFjdGVyIG9yIHByb2NlZWQgd2l0aCB3aWxkY2FyZFxuXHRcdFx0XHRpZiAodGVtcGxhdGVbdGVtcGxhdGVJbmRleF0gPT09ICcqJykge1xuXHRcdFx0XHRcdHN0YXJJbmRleCA9IHRlbXBsYXRlSW5kZXg7XG5cdFx0XHRcdFx0bWF0Y2hJbmRleCA9IHNlYXJjaEluZGV4O1xuXHRcdFx0XHRcdHRlbXBsYXRlSW5kZXgrKzsgLy8gU2tpcCB0aGUgJyonXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c2VhcmNoSW5kZXgrKztcblx0XHRcdFx0XHR0ZW1wbGF0ZUluZGV4Kys7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoc3RhckluZGV4ICE9PSAtMSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5lZ2F0ZWQtY29uZGl0aW9uXG5cdFx0XHRcdC8vIEJhY2t0cmFjayB0byB0aGUgbGFzdCAnKicgYW5kIHRyeSB0byBtYXRjaCBtb3JlIGNoYXJhY3RlcnNcblx0XHRcdFx0dGVtcGxhdGVJbmRleCA9IHN0YXJJbmRleCArIDE7XG5cdFx0XHRcdG1hdGNoSW5kZXgrKztcblx0XHRcdFx0c2VhcmNoSW5kZXggPSBtYXRjaEluZGV4O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlOyAvLyBObyBtYXRjaFxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEhhbmRsZSB0cmFpbGluZyAnKicgaW4gdGVtcGxhdGVcblx0XHR3aGlsZSAodGVtcGxhdGVJbmRleCA8IHRlbXBsYXRlLmxlbmd0aCAmJiB0ZW1wbGF0ZVt0ZW1wbGF0ZUluZGV4XSA9PT0gJyonKSB7XG5cdFx0XHR0ZW1wbGF0ZUluZGV4Kys7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRlbXBsYXRlSW5kZXggPT09IHRlbXBsYXRlLmxlbmd0aDtcblx0fVxuXG5cdC8qKlxuXHQqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuXHQqXG5cdCogQHJldHVybiB7U3RyaW5nfSBuYW1lc3BhY2VzXG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZGlzYWJsZSgpIHtcblx0XHRjb25zdCBuYW1lc3BhY2VzID0gW1xuXHRcdFx0Li4uY3JlYXRlRGVidWcubmFtZXMsXG5cdFx0XHQuLi5jcmVhdGVEZWJ1Zy5za2lwcy5tYXAobmFtZXNwYWNlID0+ICctJyArIG5hbWVzcGFjZSlcblx0XHRdLmpvaW4oJywnKTtcblx0XHRjcmVhdGVEZWJ1Zy5lbmFibGUoJycpO1xuXHRcdHJldHVybiBuYW1lc3BhY2VzO1xuXHR9XG5cblx0LyoqXG5cdCogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVcblx0KiBAcmV0dXJuIHtCb29sZWFufVxuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuXHRcdGZvciAoY29uc3Qgc2tpcCBvZiBjcmVhdGVEZWJ1Zy5za2lwcykge1xuXHRcdFx0aWYgKG1hdGNoZXNUZW1wbGF0ZShuYW1lLCBza2lwKSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yIChjb25zdCBucyBvZiBjcmVhdGVEZWJ1Zy5uYW1lcykge1xuXHRcdFx0aWYgKG1hdGNoZXNUZW1wbGF0ZShuYW1lLCBucykpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCogQ29lcmNlIGB2YWxgLlxuXHQqXG5cdCogQHBhcmFtIHtNaXhlZH0gdmFsXG5cdCogQHJldHVybiB7TWl4ZWR9XG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcblx0XHRpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0XHRcdHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG5cdFx0fVxuXHRcdHJldHVybiB2YWw7XG5cdH1cblxuXHQvKipcblx0KiBYWFggRE8gTk9UIFVTRS4gVGhpcyBpcyBhIHRlbXBvcmFyeSBzdHViIGZ1bmN0aW9uLlxuXHQqIFhYWCBJdCBXSUxMIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS5cblx0Ki9cblx0ZnVuY3Rpb24gZGVzdHJveSgpIHtcblx0XHRjb25zb2xlLndhcm4oJ0luc3RhbmNlIG1ldGhvZCBgZGVidWcuZGVzdHJveSgpYCBpcyBkZXByZWNhdGVkIGFuZCBubyBsb25nZXIgZG9lcyBhbnl0aGluZy4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgYGRlYnVnYC4nKTtcblx0fVxuXG5cdGNyZWF0ZURlYnVnLmVuYWJsZShjcmVhdGVEZWJ1Zy5sb2FkKCkpO1xuXG5cdHJldHVybiBjcmVhdGVEZWJ1Zztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXR1cDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/debug/src/common.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/light-bolt11-decoder/bolt11.js":
/*!*****************************************************!*\
  !*** ./node_modules/light-bolt11-decoder/bolt11.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("const {bech32, hex, utf8} = __webpack_require__(/*! @scure/base */ \"(app-pages-browser)/./node_modules/light-bolt11-decoder/node_modules/@scure/base/lib/index.js\")\n\n// defaults for encode; default timestamp is current time at call\nconst DEFAULTNETWORK = {\n  // default network is bitcoin\n  bech32: 'bc',\n  pubKeyHash: 0x00,\n  scriptHash: 0x05,\n  validWitnessVersions: [0]\n}\nconst TESTNETWORK = {\n  bech32: 'tb',\n  pubKeyHash: 0x6f,\n  scriptHash: 0xc4,\n  validWitnessVersions: [0]\n}\nconst SIGNETNETWORK = {\n  bech32: 'tbs',\n  pubKeyHash: 0x6f,\n  scriptHash: 0xc4,\n  validWitnessVersions: [0]\n}\nconst REGTESTNETWORK = {\n  bech32: 'bcrt',\n  pubKeyHash: 0x6f,\n  scriptHash: 0xc4,\n  validWitnessVersions: [0]\n}\nconst SIMNETWORK = {\n  bech32: 'sb',\n  pubKeyHash: 0x3f,\n  scriptHash: 0x7b,\n  validWitnessVersions: [0]\n}\n\nconst FEATUREBIT_ORDER = [\n  'option_data_loss_protect',\n  'initial_routing_sync',\n  'option_upfront_shutdown_script',\n  'gossip_queries',\n  'var_onion_optin',\n  'gossip_queries_ex',\n  'option_static_remotekey',\n  'payment_secret',\n  'basic_mpp',\n  'option_support_large_channel'\n]\n\nconst DIVISORS = {\n  m: BigInt(1e3),\n  u: BigInt(1e6),\n  n: BigInt(1e9),\n  p: BigInt(1e12)\n}\n\nconst MAX_MILLISATS = BigInt('2100000000000000000')\n\nconst MILLISATS_PER_BTC = BigInt(1e11)\n\nconst TAGCODES = {\n  payment_hash: 1,\n  payment_secret: 16,\n  description: 13,\n  payee: 19,\n  description_hash: 23, // commit to longer descriptions (used by lnurl-pay)\n  expiry: 6, // default: 3600 (1 hour)\n  min_final_cltv_expiry: 24, // default: 9\n  fallback_address: 9,\n  route_hint: 3, // for extra routing info (private etc.)\n  feature_bits: 5,\n  metadata: 27\n}\n\n// reverse the keys and values of TAGCODES and insert into TAGNAMES\nconst TAGNAMES = {}\nfor (let i = 0, keys = Object.keys(TAGCODES); i < keys.length; i++) {\n  const currentName = keys[i]\n  const currentCode = TAGCODES[keys[i]].toString()\n  TAGNAMES[currentCode] = currentName\n}\n\nconst TAGPARSERS = {\n  1: words => hex.encode(bech32.fromWordsUnsafe(words)), // 256 bits\n  16: words => hex.encode(bech32.fromWordsUnsafe(words)), // 256 bits\n  13: words => utf8.encode(bech32.fromWordsUnsafe(words)), // string variable length\n  19: words => hex.encode(bech32.fromWordsUnsafe(words)), // 264 bits\n  23: words => hex.encode(bech32.fromWordsUnsafe(words)), // 256 bits\n  27: words => hex.encode(bech32.fromWordsUnsafe(words)), // variable\n  6: wordsToIntBE, // default: 3600 (1 hour)\n  24: wordsToIntBE, // default: 9\n  3: routingInfoParser, // for extra routing info (private etc.)\n  5: featureBitsParser // keep feature bits as array of 5 bit words\n}\n\nfunction getUnknownParser(tagCode) {\n  return words => ({\n    tagCode: parseInt(tagCode),\n    words: bech32.encode('unknown', words, Number.MAX_SAFE_INTEGER)\n  })\n}\n\nfunction wordsToIntBE(words) {\n  return words.reverse().reduce((total, item, index) => {\n    return total + item * Math.pow(32, index)\n  }, 0)\n}\n\n// first convert from words to buffer, trimming padding where necessary\n// parse in 51 byte chunks. See encoder for details.\nfunction routingInfoParser(words) {\n  const routes = []\n  let pubkey,\n    shortChannelId,\n    feeBaseMSats,\n    feeProportionalMillionths,\n    cltvExpiryDelta\n  let routesBuffer = bech32.fromWordsUnsafe(words)\n  while (routesBuffer.length > 0) {\n    pubkey = hex.encode(routesBuffer.slice(0, 33)) // 33 bytes\n    shortChannelId = hex.encode(routesBuffer.slice(33, 41)) // 8 bytes\n    feeBaseMSats = parseInt(hex.encode(routesBuffer.slice(41, 45)), 16) // 4 bytes\n    feeProportionalMillionths = parseInt(\n      hex.encode(routesBuffer.slice(45, 49)),\n      16\n    ) // 4 bytes\n    cltvExpiryDelta = parseInt(hex.encode(routesBuffer.slice(49, 51)), 16) // 2 bytes\n\n    routesBuffer = routesBuffer.slice(51)\n\n    routes.push({\n      pubkey,\n      short_channel_id: shortChannelId,\n      fee_base_msat: feeBaseMSats,\n      fee_proportional_millionths: feeProportionalMillionths,\n      cltv_expiry_delta: cltvExpiryDelta\n    })\n  }\n  return routes\n}\n\nfunction featureBitsParser(words) {\n  const bools = words\n    .slice()\n    .reverse()\n    .map(word => [\n      !!(word & 0b1),\n      !!(word & 0b10),\n      !!(word & 0b100),\n      !!(word & 0b1000),\n      !!(word & 0b10000)\n    ])\n    .reduce((finalArr, itemArr) => finalArr.concat(itemArr), [])\n  while (bools.length < FEATUREBIT_ORDER.length * 2) {\n    bools.push(false)\n  }\n\n  const featureBits = {}\n\n  FEATUREBIT_ORDER.forEach((featureName, index) => {\n    let status\n    if (bools[index * 2]) {\n      status = 'required'\n    } else if (bools[index * 2 + 1]) {\n      status = 'supported'\n    } else {\n      status = 'unsupported'\n    }\n    featureBits[featureName] = status\n  })\n\n  const extraBits = bools.slice(FEATUREBIT_ORDER.length * 2)\n  featureBits.extra_bits = {\n    start_bit: FEATUREBIT_ORDER.length * 2,\n    bits: extraBits,\n    has_required: extraBits.reduce(\n      (result, bit, index) =>\n        index % 2 !== 0 ? result || false : result || bit,\n      false\n    )\n  }\n\n  return featureBits\n}\n\nfunction hrpToMillisat(hrpString, outputString) {\n  let divisor, value\n  if (hrpString.slice(-1).match(/^[munp]$/)) {\n    divisor = hrpString.slice(-1)\n    value = hrpString.slice(0, -1)\n  } else if (hrpString.slice(-1).match(/^[^munp0-9]$/)) {\n    throw new Error('Not a valid multiplier for the amount')\n  } else {\n    value = hrpString\n  }\n\n  if (!value.match(/^\\d+$/))\n    throw new Error('Not a valid human readable amount')\n\n  const valueBN = BigInt(value)\n\n  const millisatoshisBN = divisor\n    ? (valueBN * MILLISATS_PER_BTC) / DIVISORS[divisor]\n    : valueBN * MILLISATS_PER_BTC\n\n  if (\n    (divisor === 'p' && !(valueBN % BigInt(10) === BigInt(0))) ||\n    millisatoshisBN > MAX_MILLISATS\n  ) {\n    throw new Error('Amount is outside of valid range')\n  }\n\n  return outputString ? millisatoshisBN.toString() : millisatoshisBN\n}\n\n// decode will only have extra comments that aren't covered in encode comments.\n// also if anything is hard to read I'll comment.\nfunction decode(paymentRequest, network) {\n  if (typeof paymentRequest !== 'string')\n    throw new Error('Lightning Payment Request must be string')\n  if (paymentRequest.slice(0, 2).toLowerCase() !== 'ln')\n    throw new Error('Not a proper lightning payment request')\n\n  const sections = []\n  const decoded = bech32.decode(paymentRequest, Number.MAX_SAFE_INTEGER)\n  paymentRequest = paymentRequest.toLowerCase()\n  const prefix = decoded.prefix\n  let words = decoded.words\n  let letters = paymentRequest.slice(prefix.length + 1)\n  let sigWords = words.slice(-104)\n  words = words.slice(0, -104)\n\n  // Without reverse lookups, can't say that the multipier at the end must\n  // have a number before it, so instead we parse, and if the second group\n  // doesn't have anything, there's a good chance the last letter of the\n  // coin type got captured by the third group, so just re-regex without\n  // the number.\n  let prefixMatches = prefix.match(/^ln(\\S+?)(\\d*)([a-zA-Z]?)$/)\n  if (prefixMatches && !prefixMatches[2])\n    prefixMatches = prefix.match(/^ln(\\S+)$/)\n  if (!prefixMatches) {\n    throw new Error('Not a proper lightning payment request')\n  }\n\n  // \"ln\" section\n  sections.push({\n    name: 'lightning_network',\n    letters: 'ln'\n  })\n\n  // \"bc\" section\n  const bech32Prefix = prefixMatches[1]\n  let coinNetwork\n  if (!network) {\n    switch (bech32Prefix) {\n      case DEFAULTNETWORK.bech32:\n        coinNetwork = DEFAULTNETWORK\n        break\n      case TESTNETWORK.bech32:\n        coinNetwork = TESTNETWORK\n        break\n      case SIGNETNETWORK.bech32:\n        coinNetwork = SIGNETNETWORK\n        break\n      case REGTESTNETWORK.bech32:\n        coinNetwork = REGTESTNETWORK\n        break\n      case SIMNETWORK.bech32:\n        coinNetwork = SIMNETWORK\n        break\n    }\n  } else {\n    if (\n      network.bech32 === undefined ||\n      network.pubKeyHash === undefined ||\n      network.scriptHash === undefined ||\n      !Array.isArray(network.validWitnessVersions)\n    )\n      throw new Error('Invalid network')\n    coinNetwork = network\n  }\n  if (!coinNetwork || coinNetwork.bech32 !== bech32Prefix) {\n    throw new Error('Unknown coin bech32 prefix')\n  }\n  sections.push({\n    name: 'coin_network',\n    letters: bech32Prefix,\n    value: coinNetwork\n  })\n\n  // amount section\n  const value = prefixMatches[2]\n  let millisatoshis\n  if (value) {\n    const divisor = prefixMatches[3]\n    millisatoshis = hrpToMillisat(value + divisor, true)\n    sections.push({\n      name: 'amount',\n      letters: prefixMatches[2] + prefixMatches[3],\n      value: millisatoshis\n    })\n  } else {\n    millisatoshis = null\n  }\n\n  // \"1\" separator\n  sections.push({\n    name: 'separator',\n    letters: '1'\n  })\n\n  // timestamp\n  const timestamp = wordsToIntBE(words.slice(0, 7))\n  words = words.slice(7) // trim off the left 7 words\n  sections.push({\n    name: 'timestamp',\n    letters: letters.slice(0, 7),\n    value: timestamp\n  })\n  letters = letters.slice(7)\n\n  let tagName, parser, tagLength, tagWords\n  // we have no tag count to go on, so just keep hacking off words\n  // until we have none.\n  while (words.length > 0) {\n    const tagCode = words[0].toString()\n    tagName = TAGNAMES[tagCode] || 'unknown_tag'\n    parser = TAGPARSERS[tagCode] || getUnknownParser(tagCode)\n    words = words.slice(1)\n\n    tagLength = wordsToIntBE(words.slice(0, 2))\n    words = words.slice(2)\n\n    tagWords = words.slice(0, tagLength)\n    words = words.slice(tagLength)\n\n    sections.push({\n      name: tagName,\n      tag: letters[0],\n      letters: letters.slice(0, 1 + 2 + tagLength),\n      value: parser(tagWords) // see: parsers for more comments\n    })\n    letters = letters.slice(1 + 2 + tagLength)\n  }\n\n  // signature\n  sections.push({\n    name: 'signature',\n    letters: letters.slice(0, 104),\n    value: hex.encode(bech32.fromWordsUnsafe(sigWords))\n  })\n  letters = letters.slice(104)\n\n  // checksum\n  sections.push({\n    name: 'checksum',\n    letters: letters\n  })\n\n  let result = {\n    paymentRequest,\n    sections,\n\n    get expiry() {\n      let exp = sections.find(s => s.name === 'expiry')\n      if (exp) return getValue('timestamp') + exp.value\n    },\n\n    get route_hints() {\n      return sections.filter(s => s.name === 'route_hint').map(s => s.value)\n    }\n  }\n\n  for (let name in TAGCODES) {\n    if (name === 'route_hint') {\n      // route hints can be multiple, so this won't work for them\n      continue\n    }\n\n    Object.defineProperty(result, name, {\n      get() {\n        return getValue(name)\n      }\n    })\n  }\n\n  return result\n\n  function getValue(name) {\n    let section = sections.find(s => s.name === name)\n    return section ? section.value : undefined\n  }\n}\n\nmodule.exports = {\n  decode,\n  hrpToMillisat\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9saWdodC1ib2x0MTEtZGVjb2Rlci9ib2x0MTEuanMiLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxtQkFBbUIsRUFBRSxtQkFBTyxDQUFDLGtIQUFhOztBQUVqRCx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOENBQThDLGlCQUFpQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9sZmcvR2l0L01hZHRyaXBzL25vZGVfbW9kdWxlcy9saWdodC1ib2x0MTEtZGVjb2Rlci9ib2x0MTEuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3Qge2JlY2gzMiwgaGV4LCB1dGY4fSA9IHJlcXVpcmUoJ0BzY3VyZS9iYXNlJylcblxuLy8gZGVmYXVsdHMgZm9yIGVuY29kZTsgZGVmYXVsdCB0aW1lc3RhbXAgaXMgY3VycmVudCB0aW1lIGF0IGNhbGxcbmNvbnN0IERFRkFVTFRORVRXT1JLID0ge1xuICAvLyBkZWZhdWx0IG5ldHdvcmsgaXMgYml0Y29pblxuICBiZWNoMzI6ICdiYycsXG4gIHB1YktleUhhc2g6IDB4MDAsXG4gIHNjcmlwdEhhc2g6IDB4MDUsXG4gIHZhbGlkV2l0bmVzc1ZlcnNpb25zOiBbMF1cbn1cbmNvbnN0IFRFU1RORVRXT1JLID0ge1xuICBiZWNoMzI6ICd0YicsXG4gIHB1YktleUhhc2g6IDB4NmYsXG4gIHNjcmlwdEhhc2g6IDB4YzQsXG4gIHZhbGlkV2l0bmVzc1ZlcnNpb25zOiBbMF1cbn1cbmNvbnN0IFNJR05FVE5FVFdPUksgPSB7XG4gIGJlY2gzMjogJ3RicycsXG4gIHB1YktleUhhc2g6IDB4NmYsXG4gIHNjcmlwdEhhc2g6IDB4YzQsXG4gIHZhbGlkV2l0bmVzc1ZlcnNpb25zOiBbMF1cbn1cbmNvbnN0IFJFR1RFU1RORVRXT1JLID0ge1xuICBiZWNoMzI6ICdiY3J0JyxcbiAgcHViS2V5SGFzaDogMHg2ZixcbiAgc2NyaXB0SGFzaDogMHhjNCxcbiAgdmFsaWRXaXRuZXNzVmVyc2lvbnM6IFswXVxufVxuY29uc3QgU0lNTkVUV09SSyA9IHtcbiAgYmVjaDMyOiAnc2InLFxuICBwdWJLZXlIYXNoOiAweDNmLFxuICBzY3JpcHRIYXNoOiAweDdiLFxuICB2YWxpZFdpdG5lc3NWZXJzaW9uczogWzBdXG59XG5cbmNvbnN0IEZFQVRVUkVCSVRfT1JERVIgPSBbXG4gICdvcHRpb25fZGF0YV9sb3NzX3Byb3RlY3QnLFxuICAnaW5pdGlhbF9yb3V0aW5nX3N5bmMnLFxuICAnb3B0aW9uX3VwZnJvbnRfc2h1dGRvd25fc2NyaXB0JyxcbiAgJ2dvc3NpcF9xdWVyaWVzJyxcbiAgJ3Zhcl9vbmlvbl9vcHRpbicsXG4gICdnb3NzaXBfcXVlcmllc19leCcsXG4gICdvcHRpb25fc3RhdGljX3JlbW90ZWtleScsXG4gICdwYXltZW50X3NlY3JldCcsXG4gICdiYXNpY19tcHAnLFxuICAnb3B0aW9uX3N1cHBvcnRfbGFyZ2VfY2hhbm5lbCdcbl1cblxuY29uc3QgRElWSVNPUlMgPSB7XG4gIG06IEJpZ0ludCgxZTMpLFxuICB1OiBCaWdJbnQoMWU2KSxcbiAgbjogQmlnSW50KDFlOSksXG4gIHA6IEJpZ0ludCgxZTEyKVxufVxuXG5jb25zdCBNQVhfTUlMTElTQVRTID0gQmlnSW50KCcyMTAwMDAwMDAwMDAwMDAwMDAwJylcblxuY29uc3QgTUlMTElTQVRTX1BFUl9CVEMgPSBCaWdJbnQoMWUxMSlcblxuY29uc3QgVEFHQ09ERVMgPSB7XG4gIHBheW1lbnRfaGFzaDogMSxcbiAgcGF5bWVudF9zZWNyZXQ6IDE2LFxuICBkZXNjcmlwdGlvbjogMTMsXG4gIHBheWVlOiAxOSxcbiAgZGVzY3JpcHRpb25faGFzaDogMjMsIC8vIGNvbW1pdCB0byBsb25nZXIgZGVzY3JpcHRpb25zICh1c2VkIGJ5IGxudXJsLXBheSlcbiAgZXhwaXJ5OiA2LCAvLyBkZWZhdWx0OiAzNjAwICgxIGhvdXIpXG4gIG1pbl9maW5hbF9jbHR2X2V4cGlyeTogMjQsIC8vIGRlZmF1bHQ6IDlcbiAgZmFsbGJhY2tfYWRkcmVzczogOSxcbiAgcm91dGVfaGludDogMywgLy8gZm9yIGV4dHJhIHJvdXRpbmcgaW5mbyAocHJpdmF0ZSBldGMuKVxuICBmZWF0dXJlX2JpdHM6IDUsXG4gIG1ldGFkYXRhOiAyN1xufVxuXG4vLyByZXZlcnNlIHRoZSBrZXlzIGFuZCB2YWx1ZXMgb2YgVEFHQ09ERVMgYW5kIGluc2VydCBpbnRvIFRBR05BTUVTXG5jb25zdCBUQUdOQU1FUyA9IHt9XG5mb3IgKGxldCBpID0gMCwga2V5cyA9IE9iamVjdC5rZXlzKFRBR0NPREVTKTsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgY29uc3QgY3VycmVudE5hbWUgPSBrZXlzW2ldXG4gIGNvbnN0IGN1cnJlbnRDb2RlID0gVEFHQ09ERVNba2V5c1tpXV0udG9TdHJpbmcoKVxuICBUQUdOQU1FU1tjdXJyZW50Q29kZV0gPSBjdXJyZW50TmFtZVxufVxuXG5jb25zdCBUQUdQQVJTRVJTID0ge1xuICAxOiB3b3JkcyA9PiBoZXguZW5jb2RlKGJlY2gzMi5mcm9tV29yZHNVbnNhZmUod29yZHMpKSwgLy8gMjU2IGJpdHNcbiAgMTY6IHdvcmRzID0+IGhleC5lbmNvZGUoYmVjaDMyLmZyb21Xb3Jkc1Vuc2FmZSh3b3JkcykpLCAvLyAyNTYgYml0c1xuICAxMzogd29yZHMgPT4gdXRmOC5lbmNvZGUoYmVjaDMyLmZyb21Xb3Jkc1Vuc2FmZSh3b3JkcykpLCAvLyBzdHJpbmcgdmFyaWFibGUgbGVuZ3RoXG4gIDE5OiB3b3JkcyA9PiBoZXguZW5jb2RlKGJlY2gzMi5mcm9tV29yZHNVbnNhZmUod29yZHMpKSwgLy8gMjY0IGJpdHNcbiAgMjM6IHdvcmRzID0+IGhleC5lbmNvZGUoYmVjaDMyLmZyb21Xb3Jkc1Vuc2FmZSh3b3JkcykpLCAvLyAyNTYgYml0c1xuICAyNzogd29yZHMgPT4gaGV4LmVuY29kZShiZWNoMzIuZnJvbVdvcmRzVW5zYWZlKHdvcmRzKSksIC8vIHZhcmlhYmxlXG4gIDY6IHdvcmRzVG9JbnRCRSwgLy8gZGVmYXVsdDogMzYwMCAoMSBob3VyKVxuICAyNDogd29yZHNUb0ludEJFLCAvLyBkZWZhdWx0OiA5XG4gIDM6IHJvdXRpbmdJbmZvUGFyc2VyLCAvLyBmb3IgZXh0cmEgcm91dGluZyBpbmZvIChwcml2YXRlIGV0Yy4pXG4gIDU6IGZlYXR1cmVCaXRzUGFyc2VyIC8vIGtlZXAgZmVhdHVyZSBiaXRzIGFzIGFycmF5IG9mIDUgYml0IHdvcmRzXG59XG5cbmZ1bmN0aW9uIGdldFVua25vd25QYXJzZXIodGFnQ29kZSkge1xuICByZXR1cm4gd29yZHMgPT4gKHtcbiAgICB0YWdDb2RlOiBwYXJzZUludCh0YWdDb2RlKSxcbiAgICB3b3JkczogYmVjaDMyLmVuY29kZSgndW5rbm93bicsIHdvcmRzLCBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUilcbiAgfSlcbn1cblxuZnVuY3Rpb24gd29yZHNUb0ludEJFKHdvcmRzKSB7XG4gIHJldHVybiB3b3Jkcy5yZXZlcnNlKCkucmVkdWNlKCh0b3RhbCwgaXRlbSwgaW5kZXgpID0+IHtcbiAgICByZXR1cm4gdG90YWwgKyBpdGVtICogTWF0aC5wb3coMzIsIGluZGV4KVxuICB9LCAwKVxufVxuXG4vLyBmaXJzdCBjb252ZXJ0IGZyb20gd29yZHMgdG8gYnVmZmVyLCB0cmltbWluZyBwYWRkaW5nIHdoZXJlIG5lY2Vzc2FyeVxuLy8gcGFyc2UgaW4gNTEgYnl0ZSBjaHVua3MuIFNlZSBlbmNvZGVyIGZvciBkZXRhaWxzLlxuZnVuY3Rpb24gcm91dGluZ0luZm9QYXJzZXIod29yZHMpIHtcbiAgY29uc3Qgcm91dGVzID0gW11cbiAgbGV0IHB1YmtleSxcbiAgICBzaG9ydENoYW5uZWxJZCxcbiAgICBmZWVCYXNlTVNhdHMsXG4gICAgZmVlUHJvcG9ydGlvbmFsTWlsbGlvbnRocyxcbiAgICBjbHR2RXhwaXJ5RGVsdGFcbiAgbGV0IHJvdXRlc0J1ZmZlciA9IGJlY2gzMi5mcm9tV29yZHNVbnNhZmUod29yZHMpXG4gIHdoaWxlIChyb3V0ZXNCdWZmZXIubGVuZ3RoID4gMCkge1xuICAgIHB1YmtleSA9IGhleC5lbmNvZGUocm91dGVzQnVmZmVyLnNsaWNlKDAsIDMzKSkgLy8gMzMgYnl0ZXNcbiAgICBzaG9ydENoYW5uZWxJZCA9IGhleC5lbmNvZGUocm91dGVzQnVmZmVyLnNsaWNlKDMzLCA0MSkpIC8vIDggYnl0ZXNcbiAgICBmZWVCYXNlTVNhdHMgPSBwYXJzZUludChoZXguZW5jb2RlKHJvdXRlc0J1ZmZlci5zbGljZSg0MSwgNDUpKSwgMTYpIC8vIDQgYnl0ZXNcbiAgICBmZWVQcm9wb3J0aW9uYWxNaWxsaW9udGhzID0gcGFyc2VJbnQoXG4gICAgICBoZXguZW5jb2RlKHJvdXRlc0J1ZmZlci5zbGljZSg0NSwgNDkpKSxcbiAgICAgIDE2XG4gICAgKSAvLyA0IGJ5dGVzXG4gICAgY2x0dkV4cGlyeURlbHRhID0gcGFyc2VJbnQoaGV4LmVuY29kZShyb3V0ZXNCdWZmZXIuc2xpY2UoNDksIDUxKSksIDE2KSAvLyAyIGJ5dGVzXG5cbiAgICByb3V0ZXNCdWZmZXIgPSByb3V0ZXNCdWZmZXIuc2xpY2UoNTEpXG5cbiAgICByb3V0ZXMucHVzaCh7XG4gICAgICBwdWJrZXksXG4gICAgICBzaG9ydF9jaGFubmVsX2lkOiBzaG9ydENoYW5uZWxJZCxcbiAgICAgIGZlZV9iYXNlX21zYXQ6IGZlZUJhc2VNU2F0cyxcbiAgICAgIGZlZV9wcm9wb3J0aW9uYWxfbWlsbGlvbnRoczogZmVlUHJvcG9ydGlvbmFsTWlsbGlvbnRocyxcbiAgICAgIGNsdHZfZXhwaXJ5X2RlbHRhOiBjbHR2RXhwaXJ5RGVsdGFcbiAgICB9KVxuICB9XG4gIHJldHVybiByb3V0ZXNcbn1cblxuZnVuY3Rpb24gZmVhdHVyZUJpdHNQYXJzZXIod29yZHMpIHtcbiAgY29uc3QgYm9vbHMgPSB3b3Jkc1xuICAgIC5zbGljZSgpXG4gICAgLnJldmVyc2UoKVxuICAgIC5tYXAod29yZCA9PiBbXG4gICAgICAhISh3b3JkICYgMGIxKSxcbiAgICAgICEhKHdvcmQgJiAwYjEwKSxcbiAgICAgICEhKHdvcmQgJiAwYjEwMCksXG4gICAgICAhISh3b3JkICYgMGIxMDAwKSxcbiAgICAgICEhKHdvcmQgJiAwYjEwMDAwKVxuICAgIF0pXG4gICAgLnJlZHVjZSgoZmluYWxBcnIsIGl0ZW1BcnIpID0+IGZpbmFsQXJyLmNvbmNhdChpdGVtQXJyKSwgW10pXG4gIHdoaWxlIChib29scy5sZW5ndGggPCBGRUFUVVJFQklUX09SREVSLmxlbmd0aCAqIDIpIHtcbiAgICBib29scy5wdXNoKGZhbHNlKVxuICB9XG5cbiAgY29uc3QgZmVhdHVyZUJpdHMgPSB7fVxuXG4gIEZFQVRVUkVCSVRfT1JERVIuZm9yRWFjaCgoZmVhdHVyZU5hbWUsIGluZGV4KSA9PiB7XG4gICAgbGV0IHN0YXR1c1xuICAgIGlmIChib29sc1tpbmRleCAqIDJdKSB7XG4gICAgICBzdGF0dXMgPSAncmVxdWlyZWQnXG4gICAgfSBlbHNlIGlmIChib29sc1tpbmRleCAqIDIgKyAxXSkge1xuICAgICAgc3RhdHVzID0gJ3N1cHBvcnRlZCdcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdHVzID0gJ3Vuc3VwcG9ydGVkJ1xuICAgIH1cbiAgICBmZWF0dXJlQml0c1tmZWF0dXJlTmFtZV0gPSBzdGF0dXNcbiAgfSlcblxuICBjb25zdCBleHRyYUJpdHMgPSBib29scy5zbGljZShGRUFUVVJFQklUX09SREVSLmxlbmd0aCAqIDIpXG4gIGZlYXR1cmVCaXRzLmV4dHJhX2JpdHMgPSB7XG4gICAgc3RhcnRfYml0OiBGRUFUVVJFQklUX09SREVSLmxlbmd0aCAqIDIsXG4gICAgYml0czogZXh0cmFCaXRzLFxuICAgIGhhc19yZXF1aXJlZDogZXh0cmFCaXRzLnJlZHVjZShcbiAgICAgIChyZXN1bHQsIGJpdCwgaW5kZXgpID0+XG4gICAgICAgIGluZGV4ICUgMiAhPT0gMCA/IHJlc3VsdCB8fCBmYWxzZSA6IHJlc3VsdCB8fCBiaXQsXG4gICAgICBmYWxzZVxuICAgIClcbiAgfVxuXG4gIHJldHVybiBmZWF0dXJlQml0c1xufVxuXG5mdW5jdGlvbiBocnBUb01pbGxpc2F0KGhycFN0cmluZywgb3V0cHV0U3RyaW5nKSB7XG4gIGxldCBkaXZpc29yLCB2YWx1ZVxuICBpZiAoaHJwU3RyaW5nLnNsaWNlKC0xKS5tYXRjaCgvXlttdW5wXSQvKSkge1xuICAgIGRpdmlzb3IgPSBocnBTdHJpbmcuc2xpY2UoLTEpXG4gICAgdmFsdWUgPSBocnBTdHJpbmcuc2xpY2UoMCwgLTEpXG4gIH0gZWxzZSBpZiAoaHJwU3RyaW5nLnNsaWNlKC0xKS5tYXRjaCgvXltebXVucDAtOV0kLykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhIHZhbGlkIG11bHRpcGxpZXIgZm9yIHRoZSBhbW91bnQnKVxuICB9IGVsc2Uge1xuICAgIHZhbHVlID0gaHJwU3RyaW5nXG4gIH1cblxuICBpZiAoIXZhbHVlLm1hdGNoKC9eXFxkKyQvKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhIHZhbGlkIGh1bWFuIHJlYWRhYmxlIGFtb3VudCcpXG5cbiAgY29uc3QgdmFsdWVCTiA9IEJpZ0ludCh2YWx1ZSlcblxuICBjb25zdCBtaWxsaXNhdG9zaGlzQk4gPSBkaXZpc29yXG4gICAgPyAodmFsdWVCTiAqIE1JTExJU0FUU19QRVJfQlRDKSAvIERJVklTT1JTW2Rpdmlzb3JdXG4gICAgOiB2YWx1ZUJOICogTUlMTElTQVRTX1BFUl9CVENcblxuICBpZiAoXG4gICAgKGRpdmlzb3IgPT09ICdwJyAmJiAhKHZhbHVlQk4gJSBCaWdJbnQoMTApID09PSBCaWdJbnQoMCkpKSB8fFxuICAgIG1pbGxpc2F0b3NoaXNCTiA+IE1BWF9NSUxMSVNBVFNcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBbW91bnQgaXMgb3V0c2lkZSBvZiB2YWxpZCByYW5nZScpXG4gIH1cblxuICByZXR1cm4gb3V0cHV0U3RyaW5nID8gbWlsbGlzYXRvc2hpc0JOLnRvU3RyaW5nKCkgOiBtaWxsaXNhdG9zaGlzQk5cbn1cblxuLy8gZGVjb2RlIHdpbGwgb25seSBoYXZlIGV4dHJhIGNvbW1lbnRzIHRoYXQgYXJlbid0IGNvdmVyZWQgaW4gZW5jb2RlIGNvbW1lbnRzLlxuLy8gYWxzbyBpZiBhbnl0aGluZyBpcyBoYXJkIHRvIHJlYWQgSSdsbCBjb21tZW50LlxuZnVuY3Rpb24gZGVjb2RlKHBheW1lbnRSZXF1ZXN0LCBuZXR3b3JrKSB7XG4gIGlmICh0eXBlb2YgcGF5bWVudFJlcXVlc3QgIT09ICdzdHJpbmcnKVxuICAgIHRocm93IG5ldyBFcnJvcignTGlnaHRuaW5nIFBheW1lbnQgUmVxdWVzdCBtdXN0IGJlIHN0cmluZycpXG4gIGlmIChwYXltZW50UmVxdWVzdC5zbGljZSgwLCAyKS50b0xvd2VyQ2FzZSgpICE9PSAnbG4nKVxuICAgIHRocm93IG5ldyBFcnJvcignTm90IGEgcHJvcGVyIGxpZ2h0bmluZyBwYXltZW50IHJlcXVlc3QnKVxuXG4gIGNvbnN0IHNlY3Rpb25zID0gW11cbiAgY29uc3QgZGVjb2RlZCA9IGJlY2gzMi5kZWNvZGUocGF5bWVudFJlcXVlc3QsIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKVxuICBwYXltZW50UmVxdWVzdCA9IHBheW1lbnRSZXF1ZXN0LnRvTG93ZXJDYXNlKClcbiAgY29uc3QgcHJlZml4ID0gZGVjb2RlZC5wcmVmaXhcbiAgbGV0IHdvcmRzID0gZGVjb2RlZC53b3Jkc1xuICBsZXQgbGV0dGVycyA9IHBheW1lbnRSZXF1ZXN0LnNsaWNlKHByZWZpeC5sZW5ndGggKyAxKVxuICBsZXQgc2lnV29yZHMgPSB3b3Jkcy5zbGljZSgtMTA0KVxuICB3b3JkcyA9IHdvcmRzLnNsaWNlKDAsIC0xMDQpXG5cbiAgLy8gV2l0aG91dCByZXZlcnNlIGxvb2t1cHMsIGNhbid0IHNheSB0aGF0IHRoZSBtdWx0aXBpZXIgYXQgdGhlIGVuZCBtdXN0XG4gIC8vIGhhdmUgYSBudW1iZXIgYmVmb3JlIGl0LCBzbyBpbnN0ZWFkIHdlIHBhcnNlLCBhbmQgaWYgdGhlIHNlY29uZCBncm91cFxuICAvLyBkb2Vzbid0IGhhdmUgYW55dGhpbmcsIHRoZXJlJ3MgYSBnb29kIGNoYW5jZSB0aGUgbGFzdCBsZXR0ZXIgb2YgdGhlXG4gIC8vIGNvaW4gdHlwZSBnb3QgY2FwdHVyZWQgYnkgdGhlIHRoaXJkIGdyb3VwLCBzbyBqdXN0IHJlLXJlZ2V4IHdpdGhvdXRcbiAgLy8gdGhlIG51bWJlci5cbiAgbGV0IHByZWZpeE1hdGNoZXMgPSBwcmVmaXgubWF0Y2goL15sbihcXFMrPykoXFxkKikoW2EtekEtWl0/KSQvKVxuICBpZiAocHJlZml4TWF0Y2hlcyAmJiAhcHJlZml4TWF0Y2hlc1syXSlcbiAgICBwcmVmaXhNYXRjaGVzID0gcHJlZml4Lm1hdGNoKC9ebG4oXFxTKykkLylcbiAgaWYgKCFwcmVmaXhNYXRjaGVzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYSBwcm9wZXIgbGlnaHRuaW5nIHBheW1lbnQgcmVxdWVzdCcpXG4gIH1cblxuICAvLyBcImxuXCIgc2VjdGlvblxuICBzZWN0aW9ucy5wdXNoKHtcbiAgICBuYW1lOiAnbGlnaHRuaW5nX25ldHdvcmsnLFxuICAgIGxldHRlcnM6ICdsbidcbiAgfSlcblxuICAvLyBcImJjXCIgc2VjdGlvblxuICBjb25zdCBiZWNoMzJQcmVmaXggPSBwcmVmaXhNYXRjaGVzWzFdXG4gIGxldCBjb2luTmV0d29ya1xuICBpZiAoIW5ldHdvcmspIHtcbiAgICBzd2l0Y2ggKGJlY2gzMlByZWZpeCkge1xuICAgICAgY2FzZSBERUZBVUxUTkVUV09SSy5iZWNoMzI6XG4gICAgICAgIGNvaW5OZXR3b3JrID0gREVGQVVMVE5FVFdPUktcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgVEVTVE5FVFdPUksuYmVjaDMyOlxuICAgICAgICBjb2luTmV0d29yayA9IFRFU1RORVRXT1JLXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIFNJR05FVE5FVFdPUksuYmVjaDMyOlxuICAgICAgICBjb2luTmV0d29yayA9IFNJR05FVE5FVFdPUktcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgUkVHVEVTVE5FVFdPUksuYmVjaDMyOlxuICAgICAgICBjb2luTmV0d29yayA9IFJFR1RFU1RORVRXT1JLXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIFNJTU5FVFdPUksuYmVjaDMyOlxuICAgICAgICBjb2luTmV0d29yayA9IFNJTU5FVFdPUktcbiAgICAgICAgYnJlYWtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKFxuICAgICAgbmV0d29yay5iZWNoMzIgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgbmV0d29yay5wdWJLZXlIYXNoID09PSB1bmRlZmluZWQgfHxcbiAgICAgIG5ldHdvcmsuc2NyaXB0SGFzaCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAhQXJyYXkuaXNBcnJheShuZXR3b3JrLnZhbGlkV2l0bmVzc1ZlcnNpb25zKVxuICAgIClcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBuZXR3b3JrJylcbiAgICBjb2luTmV0d29yayA9IG5ldHdvcmtcbiAgfVxuICBpZiAoIWNvaW5OZXR3b3JrIHx8IGNvaW5OZXR3b3JrLmJlY2gzMiAhPT0gYmVjaDMyUHJlZml4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGNvaW4gYmVjaDMyIHByZWZpeCcpXG4gIH1cbiAgc2VjdGlvbnMucHVzaCh7XG4gICAgbmFtZTogJ2NvaW5fbmV0d29yaycsXG4gICAgbGV0dGVyczogYmVjaDMyUHJlZml4LFxuICAgIHZhbHVlOiBjb2luTmV0d29ya1xuICB9KVxuXG4gIC8vIGFtb3VudCBzZWN0aW9uXG4gIGNvbnN0IHZhbHVlID0gcHJlZml4TWF0Y2hlc1syXVxuICBsZXQgbWlsbGlzYXRvc2hpc1xuICBpZiAodmFsdWUpIHtcbiAgICBjb25zdCBkaXZpc29yID0gcHJlZml4TWF0Y2hlc1szXVxuICAgIG1pbGxpc2F0b3NoaXMgPSBocnBUb01pbGxpc2F0KHZhbHVlICsgZGl2aXNvciwgdHJ1ZSlcbiAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgIG5hbWU6ICdhbW91bnQnLFxuICAgICAgbGV0dGVyczogcHJlZml4TWF0Y2hlc1syXSArIHByZWZpeE1hdGNoZXNbM10sXG4gICAgICB2YWx1ZTogbWlsbGlzYXRvc2hpc1xuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgbWlsbGlzYXRvc2hpcyA9IG51bGxcbiAgfVxuXG4gIC8vIFwiMVwiIHNlcGFyYXRvclxuICBzZWN0aW9ucy5wdXNoKHtcbiAgICBuYW1lOiAnc2VwYXJhdG9yJyxcbiAgICBsZXR0ZXJzOiAnMSdcbiAgfSlcblxuICAvLyB0aW1lc3RhbXBcbiAgY29uc3QgdGltZXN0YW1wID0gd29yZHNUb0ludEJFKHdvcmRzLnNsaWNlKDAsIDcpKVxuICB3b3JkcyA9IHdvcmRzLnNsaWNlKDcpIC8vIHRyaW0gb2ZmIHRoZSBsZWZ0IDcgd29yZHNcbiAgc2VjdGlvbnMucHVzaCh7XG4gICAgbmFtZTogJ3RpbWVzdGFtcCcsXG4gICAgbGV0dGVyczogbGV0dGVycy5zbGljZSgwLCA3KSxcbiAgICB2YWx1ZTogdGltZXN0YW1wXG4gIH0pXG4gIGxldHRlcnMgPSBsZXR0ZXJzLnNsaWNlKDcpXG5cbiAgbGV0IHRhZ05hbWUsIHBhcnNlciwgdGFnTGVuZ3RoLCB0YWdXb3Jkc1xuICAvLyB3ZSBoYXZlIG5vIHRhZyBjb3VudCB0byBnbyBvbiwgc28ganVzdCBrZWVwIGhhY2tpbmcgb2ZmIHdvcmRzXG4gIC8vIHVudGlsIHdlIGhhdmUgbm9uZS5cbiAgd2hpbGUgKHdvcmRzLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCB0YWdDb2RlID0gd29yZHNbMF0udG9TdHJpbmcoKVxuICAgIHRhZ05hbWUgPSBUQUdOQU1FU1t0YWdDb2RlXSB8fCAndW5rbm93bl90YWcnXG4gICAgcGFyc2VyID0gVEFHUEFSU0VSU1t0YWdDb2RlXSB8fCBnZXRVbmtub3duUGFyc2VyKHRhZ0NvZGUpXG4gICAgd29yZHMgPSB3b3Jkcy5zbGljZSgxKVxuXG4gICAgdGFnTGVuZ3RoID0gd29yZHNUb0ludEJFKHdvcmRzLnNsaWNlKDAsIDIpKVxuICAgIHdvcmRzID0gd29yZHMuc2xpY2UoMilcblxuICAgIHRhZ1dvcmRzID0gd29yZHMuc2xpY2UoMCwgdGFnTGVuZ3RoKVxuICAgIHdvcmRzID0gd29yZHMuc2xpY2UodGFnTGVuZ3RoKVxuXG4gICAgc2VjdGlvbnMucHVzaCh7XG4gICAgICBuYW1lOiB0YWdOYW1lLFxuICAgICAgdGFnOiBsZXR0ZXJzWzBdLFxuICAgICAgbGV0dGVyczogbGV0dGVycy5zbGljZSgwLCAxICsgMiArIHRhZ0xlbmd0aCksXG4gICAgICB2YWx1ZTogcGFyc2VyKHRhZ1dvcmRzKSAvLyBzZWU6IHBhcnNlcnMgZm9yIG1vcmUgY29tbWVudHNcbiAgICB9KVxuICAgIGxldHRlcnMgPSBsZXR0ZXJzLnNsaWNlKDEgKyAyICsgdGFnTGVuZ3RoKVxuICB9XG5cbiAgLy8gc2lnbmF0dXJlXG4gIHNlY3Rpb25zLnB1c2goe1xuICAgIG5hbWU6ICdzaWduYXR1cmUnLFxuICAgIGxldHRlcnM6IGxldHRlcnMuc2xpY2UoMCwgMTA0KSxcbiAgICB2YWx1ZTogaGV4LmVuY29kZShiZWNoMzIuZnJvbVdvcmRzVW5zYWZlKHNpZ1dvcmRzKSlcbiAgfSlcbiAgbGV0dGVycyA9IGxldHRlcnMuc2xpY2UoMTA0KVxuXG4gIC8vIGNoZWNrc3VtXG4gIHNlY3Rpb25zLnB1c2goe1xuICAgIG5hbWU6ICdjaGVja3N1bScsXG4gICAgbGV0dGVyczogbGV0dGVyc1xuICB9KVxuXG4gIGxldCByZXN1bHQgPSB7XG4gICAgcGF5bWVudFJlcXVlc3QsXG4gICAgc2VjdGlvbnMsXG5cbiAgICBnZXQgZXhwaXJ5KCkge1xuICAgICAgbGV0IGV4cCA9IHNlY3Rpb25zLmZpbmQocyA9PiBzLm5hbWUgPT09ICdleHBpcnknKVxuICAgICAgaWYgKGV4cCkgcmV0dXJuIGdldFZhbHVlKCd0aW1lc3RhbXAnKSArIGV4cC52YWx1ZVxuICAgIH0sXG5cbiAgICBnZXQgcm91dGVfaGludHMoKSB7XG4gICAgICByZXR1cm4gc2VjdGlvbnMuZmlsdGVyKHMgPT4gcy5uYW1lID09PSAncm91dGVfaGludCcpLm1hcChzID0+IHMudmFsdWUpXG4gICAgfVxuICB9XG5cbiAgZm9yIChsZXQgbmFtZSBpbiBUQUdDT0RFUykge1xuICAgIGlmIChuYW1lID09PSAncm91dGVfaGludCcpIHtcbiAgICAgIC8vIHJvdXRlIGhpbnRzIGNhbiBiZSBtdWx0aXBsZSwgc28gdGhpcyB3b24ndCB3b3JrIGZvciB0aGVtXG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXN1bHQsIG5hbWUsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIGdldFZhbHVlKG5hbWUpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHJldHVybiByZXN1bHRcblxuICBmdW5jdGlvbiBnZXRWYWx1ZShuYW1lKSB7XG4gICAgbGV0IHNlY3Rpb24gPSBzZWN0aW9ucy5maW5kKHMgPT4gcy5uYW1lID09PSBuYW1lKVxuICAgIHJldHVybiBzZWN0aW9uID8gc2VjdGlvbi52YWx1ZSA6IHVuZGVmaW5lZFxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkZWNvZGUsXG4gIGhycFRvTWlsbGlzYXRcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/light-bolt11-decoder/bolt11.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/light-bolt11-decoder/node_modules/@scure/base/lib/index.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/light-bolt11-decoder/node_modules/@scure/base/lib/index.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.bytes = exports.stringToBytes = exports.str = exports.bytesToString = exports.hex = exports.utf8 = exports.bech32m = exports.bech32 = exports.base58check = exports.base58xmr = exports.base58xrp = exports.base58flickr = exports.base58 = exports.base64url = exports.base64 = exports.base32crockford = exports.base32hex = exports.base32 = exports.base16 = exports.utils = exports.assertNumber = void 0;\nfunction assertNumber(n) {\n    if (!Number.isSafeInteger(n))\n        throw new Error(`Wrong integer: ${n}`);\n}\nexports.assertNumber = assertNumber;\nfunction chain(...args) {\n    const wrap = (a, b) => (c) => a(b(c));\n    const encode = Array.from(args)\n        .reverse()\n        .reduce((acc, i) => (acc ? wrap(acc, i.encode) : i.encode), undefined);\n    const decode = args.reduce((acc, i) => (acc ? wrap(acc, i.decode) : i.decode), undefined);\n    return { encode, decode };\n}\nfunction alphabet(alphabet) {\n    return {\n        encode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('alphabet.encode input should be an array of numbers');\n            return digits.map((i) => {\n                assertNumber(i);\n                if (i < 0 || i >= alphabet.length)\n                    throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet.length})`);\n                return alphabet[i];\n            });\n        },\n        decode: (input) => {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('alphabet.decode input should be array of strings');\n            return input.map((letter) => {\n                if (typeof letter !== 'string')\n                    throw new Error(`alphabet.decode: not string element=${letter}`);\n                const index = alphabet.indexOf(letter);\n                if (index === -1)\n                    throw new Error(`Unknown letter: \"${letter}\". Allowed: ${alphabet}`);\n                return index;\n            });\n        },\n    };\n}\nfunction join(separator = '') {\n    if (typeof separator !== 'string')\n        throw new Error('join separator should be string');\n    return {\n        encode: (from) => {\n            if (!Array.isArray(from) || (from.length && typeof from[0] !== 'string'))\n                throw new Error('join.encode input should be array of strings');\n            for (let i of from)\n                if (typeof i !== 'string')\n                    throw new Error(`join.encode: non-string input=${i}`);\n            return from.join(separator);\n        },\n        decode: (to) => {\n            if (typeof to !== 'string')\n                throw new Error('join.decode input should be string');\n            return to.split(separator);\n        },\n    };\n}\nfunction padding(bits, chr = '=') {\n    assertNumber(bits);\n    if (typeof chr !== 'string')\n        throw new Error('padding chr should be string');\n    return {\n        encode(data) {\n            if (!Array.isArray(data) || (data.length && typeof data[0] !== 'string'))\n                throw new Error('padding.encode input should be array of strings');\n            for (let i of data)\n                if (typeof i !== 'string')\n                    throw new Error(`padding.encode: non-string input=${i}`);\n            while ((data.length * bits) % 8)\n                data.push(chr);\n            return data;\n        },\n        decode(input) {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('padding.encode input should be array of strings');\n            for (let i of input)\n                if (typeof i !== 'string')\n                    throw new Error(`padding.decode: non-string input=${i}`);\n            let end = input.length;\n            if ((end * bits) % 8)\n                throw new Error('Invalid padding: string should have whole number of bytes');\n            for (; end > 0 && input[end - 1] === chr; end--) {\n                if (!(((end - 1) * bits) % 8))\n                    throw new Error('Invalid padding: string has too much padding');\n            }\n            return input.slice(0, end);\n        },\n    };\n}\nfunction normalize(fn) {\n    if (typeof fn !== 'function')\n        throw new Error('normalize fn should be function');\n    return { encode: (from) => from, decode: (to) => fn(to) };\n}\nfunction convertRadix(data, from, to) {\n    if (from < 2)\n        throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);\n    if (to < 2)\n        throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);\n    if (!Array.isArray(data))\n        throw new Error('convertRadix: data should be array');\n    if (!data.length)\n        return [];\n    let pos = 0;\n    const res = [];\n    const digits = Array.from(data);\n    digits.forEach((d) => {\n        assertNumber(d);\n        if (d < 0 || d >= from)\n            throw new Error(`Wrong integer: ${d}`);\n    });\n    while (true) {\n        let carry = 0;\n        let done = true;\n        for (let i = pos; i < digits.length; i++) {\n            const digit = digits[i];\n            const digitBase = from * carry + digit;\n            if (!Number.isSafeInteger(digitBase) ||\n                (from * carry) / from !== carry ||\n                digitBase - digit !== from * carry) {\n                throw new Error('convertRadix: carry overflow');\n            }\n            carry = digitBase % to;\n            digits[i] = Math.floor(digitBase / to);\n            if (!Number.isSafeInteger(digits[i]) || digits[i] * to + carry !== digitBase)\n                throw new Error('convertRadix: carry overflow');\n            if (!done)\n                continue;\n            else if (!digits[i])\n                pos = i;\n            else\n                done = false;\n        }\n        res.push(carry);\n        if (done)\n            break;\n    }\n    for (let i = 0; i < data.length - 1 && data[i] === 0; i++)\n        res.push(0);\n    return res.reverse();\n}\nconst gcd = (a, b) => (!b ? a : gcd(b, a % b));\nconst radix2carry = (from, to) => from + (to - gcd(from, to));\nfunction convertRadix2(data, from, to, padding) {\n    if (!Array.isArray(data))\n        throw new Error('convertRadix2: data should be array');\n    if (from <= 0 || from > 32)\n        throw new Error(`convertRadix2: wrong from=${from}`);\n    if (to <= 0 || to > 32)\n        throw new Error(`convertRadix2: wrong to=${to}`);\n    if (radix2carry(from, to) > 32) {\n        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);\n    }\n    let carry = 0;\n    let pos = 0;\n    const mask = 2 ** to - 1;\n    const res = [];\n    for (const n of data) {\n        assertNumber(n);\n        if (n >= 2 ** from)\n            throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n        carry = (carry << from) | n;\n        if (pos + from > 32)\n            throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n        pos += from;\n        for (; pos >= to; pos -= to)\n            res.push(((carry >> (pos - to)) & mask) >>> 0);\n        carry &= 2 ** pos - 1;\n    }\n    carry = (carry << (to - pos)) & mask;\n    if (!padding && pos >= from)\n        throw new Error('Excess padding');\n    if (!padding && carry)\n        throw new Error(`Non-zero padding: ${carry}`);\n    if (padding && pos > 0)\n        res.push(carry >>> 0);\n    return res;\n}\nfunction radix(num) {\n    assertNumber(num);\n    return {\n        encode: (bytes) => {\n            if (!(bytes instanceof Uint8Array))\n                throw new Error('radix.encode input should be Uint8Array');\n            return convertRadix(Array.from(bytes), 2 ** 8, num);\n        },\n        decode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('radix.decode input should be array of strings');\n            return Uint8Array.from(convertRadix(digits, num, 2 ** 8));\n        },\n    };\n}\nfunction radix2(bits, revPadding = false) {\n    assertNumber(bits);\n    if (bits <= 0 || bits > 32)\n        throw new Error('radix2: bits should be in (0..32]');\n    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)\n        throw new Error('radix2: carry overflow');\n    return {\n        encode: (bytes) => {\n            if (!(bytes instanceof Uint8Array))\n                throw new Error('radix2.encode input should be Uint8Array');\n            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n        },\n        decode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('radix2.decode input should be array of strings');\n            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n        },\n    };\n}\nfunction unsafeWrapper(fn) {\n    if (typeof fn !== 'function')\n        throw new Error('unsafeWrapper fn should be function');\n    return function (...args) {\n        try {\n            return fn.apply(null, args);\n        }\n        catch (e) { }\n    };\n}\nfunction checksum(len, fn) {\n    assertNumber(len);\n    if (typeof fn !== 'function')\n        throw new Error('checksum fn should be function');\n    return {\n        encode(data) {\n            if (!(data instanceof Uint8Array))\n                throw new Error('checksum.encode: input should be Uint8Array');\n            const checksum = fn(data).slice(0, len);\n            const res = new Uint8Array(data.length + len);\n            res.set(data);\n            res.set(checksum, data.length);\n            return res;\n        },\n        decode(data) {\n            if (!(data instanceof Uint8Array))\n                throw new Error('checksum.decode: input should be Uint8Array');\n            const payload = data.slice(0, -len);\n            const newChecksum = fn(payload).slice(0, len);\n            const oldChecksum = data.slice(-len);\n            for (let i = 0; i < len; i++)\n                if (newChecksum[i] !== oldChecksum[i])\n                    throw new Error('Invalid checksum');\n            return payload;\n        },\n    };\n}\nexports.utils = { alphabet, chain, checksum, radix, radix2, join, padding };\nexports.base16 = chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));\nexports.base32 = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));\nexports.base32hex = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));\nexports.base32crockford = chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize((s) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')));\nexports.base64 = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));\nexports.base64url = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));\nconst genBase58 = (abc) => chain(radix(58), alphabet(abc), join(''));\nexports.base58 = genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');\nexports.base58flickr = genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');\nexports.base58xrp = genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');\nconst XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\nexports.base58xmr = {\n    encode(data) {\n        let res = '';\n        for (let i = 0; i < data.length; i += 8) {\n            const block = data.subarray(i, i + 8);\n            res += exports.base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');\n        }\n        return res;\n    },\n    decode(str) {\n        let res = [];\n        for (let i = 0; i < str.length; i += 11) {\n            const slice = str.slice(i, i + 11);\n            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n            const block = exports.base58.decode(slice);\n            for (let j = 0; j < block.length - blockLen; j++) {\n                if (block[j] !== 0)\n                    throw new Error('base58xmr: wrong padding');\n            }\n            res = res.concat(Array.from(block.slice(block.length - blockLen)));\n        }\n        return Uint8Array.from(res);\n    },\n};\nconst base58check = (sha256) => chain(checksum(4, (data) => sha256(sha256(data))), exports.base58);\nexports.base58check = base58check;\nconst BECH_ALPHABET = chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));\nconst POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\nfunction bech32Polymod(pre) {\n    const b = pre >> 25;\n    let chk = (pre & 0x1ffffff) << 5;\n    for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {\n        if (((b >> i) & 1) === 1)\n            chk ^= POLYMOD_GENERATORS[i];\n    }\n    return chk;\n}\nfunction bechChecksum(prefix, words, encodingConst = 1) {\n    const len = prefix.length;\n    let chk = 1;\n    for (let i = 0; i < len; i++) {\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126)\n            throw new Error(`Invalid prefix (${prefix})`);\n        chk = bech32Polymod(chk) ^ (c >> 5);\n    }\n    chk = bech32Polymod(chk);\n    for (let i = 0; i < len; i++)\n        chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);\n    for (let v of words)\n        chk = bech32Polymod(chk) ^ v;\n    for (let i = 0; i < 6; i++)\n        chk = bech32Polymod(chk);\n    chk ^= encodingConst;\n    return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));\n}\nfunction genBech32(encoding) {\n    const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n    const _words = radix2(5);\n    const fromWords = _words.decode;\n    const toWords = _words.encode;\n    const fromWordsUnsafe = unsafeWrapper(fromWords);\n    function encode(prefix, words, limit = 90) {\n        if (typeof prefix !== 'string')\n            throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);\n        if (!Array.isArray(words) || (words.length && typeof words[0] !== 'number'))\n            throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);\n        const actualLength = prefix.length + 7 + words.length;\n        if (limit !== false && actualLength > limit)\n            throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n        prefix = prefix.toLowerCase();\n        return `${prefix}1${BECH_ALPHABET.encode(words)}${bechChecksum(prefix, words, ENCODING_CONST)}`;\n    }\n    function decode(str, limit = 90) {\n        if (typeof str !== 'string')\n            throw new Error(`bech32.decode input should be string, not ${typeof str}`);\n        if (str.length < 8 || (limit !== false && str.length > limit))\n            throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);\n        const lowered = str.toLowerCase();\n        if (str !== lowered && str !== str.toUpperCase())\n            throw new Error(`String must be lowercase or uppercase`);\n        str = lowered;\n        const sepIndex = str.lastIndexOf('1');\n        if (sepIndex === 0 || sepIndex === -1)\n            throw new Error(`Letter \"1\" must be present between prefix and data only`);\n        const prefix = str.slice(0, sepIndex);\n        const _words = str.slice(sepIndex + 1);\n        if (_words.length < 6)\n            throw new Error('Data must be at least 6 characters long');\n        const words = BECH_ALPHABET.decode(_words).slice(0, -6);\n        const sum = bechChecksum(prefix, words, ENCODING_CONST);\n        if (!_words.endsWith(sum))\n            throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n        return { prefix, words };\n    }\n    const decodeUnsafe = unsafeWrapper(decode);\n    function decodeToBytes(str) {\n        const { prefix, words } = decode(str, false);\n        return { prefix, words, bytes: fromWords(words) };\n    }\n    return { encode, decode, decodeToBytes, decodeUnsafe, fromWords, fromWordsUnsafe, toWords };\n}\nexports.bech32 = genBech32('bech32');\nexports.bech32m = genBech32('bech32m');\nexports.utf8 = {\n    encode: (data) => new TextDecoder().decode(data),\n    decode: (str) => new TextEncoder().encode(str),\n};\nexports.hex = chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize((s) => {\n    if (typeof s !== 'string' || s.length % 2)\n        throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);\n    return s.toLowerCase();\n}));\nconst CODERS = {\n    utf8: exports.utf8, hex: exports.hex, base16: exports.base16, base32: exports.base32, base64: exports.base64, base64url: exports.base64url, base58: exports.base58, base58xmr: exports.base58xmr\n};\nconst coderTypeError = `Invalid encoding type. Available types: ${Object.keys(CODERS).join(', ')}`;\nconst bytesToString = (type, bytes) => {\n    if (typeof type !== 'string' || !CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (!(bytes instanceof Uint8Array))\n        throw new TypeError('bytesToString() expects Uint8Array');\n    return CODERS[type].encode(bytes);\n};\nexports.bytesToString = bytesToString;\nexports.str = exports.bytesToString;\nconst stringToBytes = (type, str) => {\n    if (!CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (typeof str !== 'string')\n        throw new TypeError('stringToBytes() expects string');\n    return CODERS[type].decode(str);\n};\nexports.stringToBytes = stringToBytes;\nexports.bytes = exports.stringToBytes;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9saWdodC1ib2x0MTEtZGVjb2Rlci9ub2RlX21vZHVsZXMvQHNjdXJlL2Jhc2UvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxHQUFHLHFCQUFxQixHQUFHLFdBQVcsR0FBRyxxQkFBcUIsR0FBRyxXQUFXLEdBQUcsWUFBWSxHQUFHLGVBQWUsR0FBRyxjQUFjLEdBQUcsbUJBQW1CLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsb0JBQW9CLEdBQUcsY0FBYyxHQUFHLGlCQUFpQixHQUFHLGNBQWMsR0FBRyx1QkFBdUIsR0FBRyxpQkFBaUIsR0FBRyxjQUFjLEdBQUcsY0FBYyxHQUFHLGFBQWEsR0FBRyxvQkFBb0I7QUFDN1k7QUFDQTtBQUNBLDBDQUEwQyxFQUFFO0FBQzVDO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsR0FBRyxhQUFhLGdCQUFnQjtBQUNyRztBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxPQUFPO0FBQ2xGO0FBQ0E7QUFDQSx3REFBd0QsT0FBTyxjQUFjLFNBQVM7QUFDdEY7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsRUFBRTtBQUN2RTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsRUFBRTtBQUMxRTtBQUNBO0FBQ0E7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QUFtRixhQUFhO0FBQ2hHO0FBQ0E7QUFDQSwwQ0FBMEMsY0FBYyxnQkFBZ0IsTUFBTTtBQUM5RTtBQUNBLGtCQUFrQixPQUFPLEdBQUcsNEJBQTRCLEVBQUUsNENBQTRDO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxXQUFXO0FBQ3BGO0FBQ0Esd0RBQXdELFlBQVksR0FBRyxJQUFJLGtCQUFrQixNQUFNO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsSUFBSSxjQUFjLElBQUk7QUFDekUsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnQkFBZ0I7QUFDaEMsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsY0FBYztBQUNkLGVBQWU7QUFDZixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsZ0VBQWdFLFVBQVUsY0FBYyxTQUFTO0FBQ2pHO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSwrQkFBK0I7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGFBQWEiLCJzb3VyY2VzIjpbIi9ob21lL2xmZy9HaXQvTWFkdHJpcHMvbm9kZV9tb2R1bGVzL2xpZ2h0LWJvbHQxMS1kZWNvZGVyL25vZGVfbW9kdWxlcy9Ac2N1cmUvYmFzZS9saWIvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKiEgc2N1cmUtYmFzZSAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ieXRlcyA9IGV4cG9ydHMuc3RyaW5nVG9CeXRlcyA9IGV4cG9ydHMuc3RyID0gZXhwb3J0cy5ieXRlc1RvU3RyaW5nID0gZXhwb3J0cy5oZXggPSBleHBvcnRzLnV0ZjggPSBleHBvcnRzLmJlY2gzMm0gPSBleHBvcnRzLmJlY2gzMiA9IGV4cG9ydHMuYmFzZTU4Y2hlY2sgPSBleHBvcnRzLmJhc2U1OHhtciA9IGV4cG9ydHMuYmFzZTU4eHJwID0gZXhwb3J0cy5iYXNlNThmbGlja3IgPSBleHBvcnRzLmJhc2U1OCA9IGV4cG9ydHMuYmFzZTY0dXJsID0gZXhwb3J0cy5iYXNlNjQgPSBleHBvcnRzLmJhc2UzMmNyb2NrZm9yZCA9IGV4cG9ydHMuYmFzZTMyaGV4ID0gZXhwb3J0cy5iYXNlMzIgPSBleHBvcnRzLmJhc2UxNiA9IGV4cG9ydHMudXRpbHMgPSBleHBvcnRzLmFzc2VydE51bWJlciA9IHZvaWQgMDtcbmZ1bmN0aW9uIGFzc2VydE51bWJlcihuKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXcm9uZyBpbnRlZ2VyOiAke259YCk7XG59XG5leHBvcnRzLmFzc2VydE51bWJlciA9IGFzc2VydE51bWJlcjtcbmZ1bmN0aW9uIGNoYWluKC4uLmFyZ3MpIHtcbiAgICBjb25zdCB3cmFwID0gKGEsIGIpID0+IChjKSA9PiBhKGIoYykpO1xuICAgIGNvbnN0IGVuY29kZSA9IEFycmF5LmZyb20oYXJncylcbiAgICAgICAgLnJldmVyc2UoKVxuICAgICAgICAucmVkdWNlKChhY2MsIGkpID0+IChhY2MgPyB3cmFwKGFjYywgaS5lbmNvZGUpIDogaS5lbmNvZGUpLCB1bmRlZmluZWQpO1xuICAgIGNvbnN0IGRlY29kZSA9IGFyZ3MucmVkdWNlKChhY2MsIGkpID0+IChhY2MgPyB3cmFwKGFjYywgaS5kZWNvZGUpIDogaS5kZWNvZGUpLCB1bmRlZmluZWQpO1xuICAgIHJldHVybiB7IGVuY29kZSwgZGVjb2RlIH07XG59XG5mdW5jdGlvbiBhbHBoYWJldChhbHBoYWJldCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZTogKGRpZ2l0cykgPT4ge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRpZ2l0cykgfHwgKGRpZ2l0cy5sZW5ndGggJiYgdHlwZW9mIGRpZ2l0c1swXSAhPT0gJ251bWJlcicpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYWxwaGFiZXQuZW5jb2RlIGlucHV0IHNob3VsZCBiZSBhbiBhcnJheSBvZiBudW1iZXJzJyk7XG4gICAgICAgICAgICByZXR1cm4gZGlnaXRzLm1hcCgoaSkgPT4ge1xuICAgICAgICAgICAgICAgIGFzc2VydE51bWJlcihpKTtcbiAgICAgICAgICAgICAgICBpZiAoaSA8IDAgfHwgaSA+PSBhbHBoYWJldC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRGlnaXQgaW5kZXggb3V0c2lkZSBhbHBoYWJldDogJHtpfSAoYWxwaGFiZXQ6ICR7YWxwaGFiZXQubGVuZ3RofSlgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWxwaGFiZXRbaV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlOiAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkgfHwgKGlucHV0Lmxlbmd0aCAmJiB0eXBlb2YgaW5wdXRbMF0gIT09ICdzdHJpbmcnKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FscGhhYmV0LmRlY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2Ygc3RyaW5ncycpO1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0Lm1hcCgobGV0dGVyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsZXR0ZXIgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGFscGhhYmV0LmRlY29kZTogbm90IHN0cmluZyBlbGVtZW50PSR7bGV0dGVyfWApO1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gYWxwaGFiZXQuaW5kZXhPZihsZXR0ZXIpO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBsZXR0ZXI6IFwiJHtsZXR0ZXJ9XCIuIEFsbG93ZWQ6ICR7YWxwaGFiZXR9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGpvaW4oc2VwYXJhdG9yID0gJycpIHtcbiAgICBpZiAodHlwZW9mIHNlcGFyYXRvciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignam9pbiBzZXBhcmF0b3Igc2hvdWxkIGJlIHN0cmluZycpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZTogKGZyb20pID0+IHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShmcm9tKSB8fCAoZnJvbS5sZW5ndGggJiYgdHlwZW9mIGZyb21bMF0gIT09ICdzdHJpbmcnKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2pvaW4uZW5jb2RlIGlucHV0IHNob3VsZCBiZSBhcnJheSBvZiBzdHJpbmdzJyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpIG9mIGZyb20pXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBqb2luLmVuY29kZTogbm9uLXN0cmluZyBpbnB1dD0ke2l9YCk7XG4gICAgICAgICAgICByZXR1cm4gZnJvbS5qb2luKHNlcGFyYXRvcik7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZTogKHRvKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRvICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2pvaW4uZGVjb2RlIGlucHV0IHNob3VsZCBiZSBzdHJpbmcnKTtcbiAgICAgICAgICAgIHJldHVybiB0by5zcGxpdChzZXBhcmF0b3IpO1xuICAgICAgICB9LFxuICAgIH07XG59XG5mdW5jdGlvbiBwYWRkaW5nKGJpdHMsIGNociA9ICc9Jykge1xuICAgIGFzc2VydE51bWJlcihiaXRzKTtcbiAgICBpZiAodHlwZW9mIGNociAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGluZyBjaHIgc2hvdWxkIGJlIHN0cmluZycpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZShkYXRhKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkgfHwgKGRhdGEubGVuZ3RoICYmIHR5cGVvZiBkYXRhWzBdICE9PSAnc3RyaW5nJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkaW5nLmVuY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2Ygc3RyaW5ncycpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSBvZiBkYXRhKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaSAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcGFkZGluZy5lbmNvZGU6IG5vbi1zdHJpbmcgaW5wdXQ9JHtpfWApO1xuICAgICAgICAgICAgd2hpbGUgKChkYXRhLmxlbmd0aCAqIGJpdHMpICUgOClcbiAgICAgICAgICAgICAgICBkYXRhLnB1c2goY2hyKTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGUoaW5wdXQpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkgfHwgKGlucHV0Lmxlbmd0aCAmJiB0eXBlb2YgaW5wdXRbMF0gIT09ICdzdHJpbmcnKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRpbmcuZW5jb2RlIGlucHV0IHNob3VsZCBiZSBhcnJheSBvZiBzdHJpbmdzJyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpIG9mIGlucHV0KVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaSAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcGFkZGluZy5kZWNvZGU6IG5vbi1zdHJpbmcgaW5wdXQ9JHtpfWApO1xuICAgICAgICAgICAgbGV0IGVuZCA9IGlucHV0Lmxlbmd0aDtcbiAgICAgICAgICAgIGlmICgoZW5kICogYml0cykgJSA4KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwYWRkaW5nOiBzdHJpbmcgc2hvdWxkIGhhdmUgd2hvbGUgbnVtYmVyIG9mIGJ5dGVzJyk7XG4gICAgICAgICAgICBmb3IgKDsgZW5kID4gMCAmJiBpbnB1dFtlbmQgLSAxXSA9PT0gY2hyOyBlbmQtLSkge1xuICAgICAgICAgICAgICAgIGlmICghKCgoZW5kIC0gMSkgKiBiaXRzKSAlIDgpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcGFkZGluZzogc3RyaW5nIGhhcyB0b28gbXVjaCBwYWRkaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQuc2xpY2UoMCwgZW5kKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplKGZuKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3JtYWxpemUgZm4gc2hvdWxkIGJlIGZ1bmN0aW9uJyk7XG4gICAgcmV0dXJuIHsgZW5jb2RlOiAoZnJvbSkgPT4gZnJvbSwgZGVjb2RlOiAodG8pID0+IGZuKHRvKSB9O1xufVxuZnVuY3Rpb24gY29udmVydFJhZGl4KGRhdGEsIGZyb20sIHRvKSB7XG4gICAgaWYgKGZyb20gPCAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDogd3JvbmcgZnJvbT0ke2Zyb219LCBiYXNlIGNhbm5vdCBiZSBsZXNzIHRoYW4gMmApO1xuICAgIGlmICh0byA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4OiB3cm9uZyB0bz0ke3RvfSwgYmFzZSBjYW5ub3QgYmUgbGVzcyB0aGFuIDJgKTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY29udmVydFJhZGl4OiBkYXRhIHNob3VsZCBiZSBhcnJheScpO1xuICAgIGlmICghZGF0YS5sZW5ndGgpXG4gICAgICAgIHJldHVybiBbXTtcbiAgICBsZXQgcG9zID0gMDtcbiAgICBjb25zdCByZXMgPSBbXTtcbiAgICBjb25zdCBkaWdpdHMgPSBBcnJheS5mcm9tKGRhdGEpO1xuICAgIGRpZ2l0cy5mb3JFYWNoKChkKSA9PiB7XG4gICAgICAgIGFzc2VydE51bWJlcihkKTtcbiAgICAgICAgaWYgKGQgPCAwIHx8IGQgPj0gZnJvbSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgV3JvbmcgaW50ZWdlcjogJHtkfWApO1xuICAgIH0pO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGxldCBjYXJyeSA9IDA7XG4gICAgICAgIGxldCBkb25lID0gdHJ1ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHBvczsgaSA8IGRpZ2l0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZGlnaXQgPSBkaWdpdHNbaV07XG4gICAgICAgICAgICBjb25zdCBkaWdpdEJhc2UgPSBmcm9tICogY2FycnkgKyBkaWdpdDtcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoZGlnaXRCYXNlKSB8fFxuICAgICAgICAgICAgICAgIChmcm9tICogY2FycnkpIC8gZnJvbSAhPT0gY2FycnkgfHxcbiAgICAgICAgICAgICAgICBkaWdpdEJhc2UgLSBkaWdpdCAhPT0gZnJvbSAqIGNhcnJ5KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb252ZXJ0UmFkaXg6IGNhcnJ5IG92ZXJmbG93Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXJyeSA9IGRpZ2l0QmFzZSAlIHRvO1xuICAgICAgICAgICAgZGlnaXRzW2ldID0gTWF0aC5mbG9vcihkaWdpdEJhc2UgLyB0byk7XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGRpZ2l0c1tpXSkgfHwgZGlnaXRzW2ldICogdG8gKyBjYXJyeSAhPT0gZGlnaXRCYXNlKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY29udmVydFJhZGl4OiBjYXJyeSBvdmVyZmxvdycpO1xuICAgICAgICAgICAgaWYgKCFkb25lKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgZWxzZSBpZiAoIWRpZ2l0c1tpXSlcbiAgICAgICAgICAgICAgICBwb3MgPSBpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGRvbmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXMucHVzaChjYXJyeSk7XG4gICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGggLSAxICYmIGRhdGFbaV0gPT09IDA7IGkrKylcbiAgICAgICAgcmVzLnB1c2goMCk7XG4gICAgcmV0dXJuIHJlcy5yZXZlcnNlKCk7XG59XG5jb25zdCBnY2QgPSAoYSwgYikgPT4gKCFiID8gYSA6IGdjZChiLCBhICUgYikpO1xuY29uc3QgcmFkaXgyY2FycnkgPSAoZnJvbSwgdG8pID0+IGZyb20gKyAodG8gLSBnY2QoZnJvbSwgdG8pKTtcbmZ1bmN0aW9uIGNvbnZlcnRSYWRpeDIoZGF0YSwgZnJvbSwgdG8sIHBhZGRpbmcpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY29udmVydFJhZGl4MjogZGF0YSBzaG91bGQgYmUgYXJyYXknKTtcbiAgICBpZiAoZnJvbSA8PSAwIHx8IGZyb20gPiAzMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXgyOiB3cm9uZyBmcm9tPSR7ZnJvbX1gKTtcbiAgICBpZiAodG8gPD0gMCB8fCB0byA+IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDI6IHdyb25nIHRvPSR7dG99YCk7XG4gICAgaWYgKHJhZGl4MmNhcnJ5KGZyb20sIHRvKSA+IDMyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4MjogY2Fycnkgb3ZlcmZsb3cgZnJvbT0ke2Zyb219IHRvPSR7dG99IGNhcnJ5Qml0cz0ke3JhZGl4MmNhcnJ5KGZyb20sIHRvKX1gKTtcbiAgICB9XG4gICAgbGV0IGNhcnJ5ID0gMDtcbiAgICBsZXQgcG9zID0gMDtcbiAgICBjb25zdCBtYXNrID0gMiAqKiB0byAtIDE7XG4gICAgY29uc3QgcmVzID0gW107XG4gICAgZm9yIChjb25zdCBuIG9mIGRhdGEpIHtcbiAgICAgICAgYXNzZXJ0TnVtYmVyKG4pO1xuICAgICAgICBpZiAobiA+PSAyICoqIGZyb20pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDI6IGludmFsaWQgZGF0YSB3b3JkPSR7bn0gZnJvbT0ke2Zyb219YCk7XG4gICAgICAgIGNhcnJ5ID0gKGNhcnJ5IDw8IGZyb20pIHwgbjtcbiAgICAgICAgaWYgKHBvcyArIGZyb20gPiAzMilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4MjogY2Fycnkgb3ZlcmZsb3cgcG9zPSR7cG9zfSBmcm9tPSR7ZnJvbX1gKTtcbiAgICAgICAgcG9zICs9IGZyb207XG4gICAgICAgIGZvciAoOyBwb3MgPj0gdG87IHBvcyAtPSB0bylcbiAgICAgICAgICAgIHJlcy5wdXNoKCgoY2FycnkgPj4gKHBvcyAtIHRvKSkgJiBtYXNrKSA+Pj4gMCk7XG4gICAgICAgIGNhcnJ5ICY9IDIgKiogcG9zIC0gMTtcbiAgICB9XG4gICAgY2FycnkgPSAoY2FycnkgPDwgKHRvIC0gcG9zKSkgJiBtYXNrO1xuICAgIGlmICghcGFkZGluZyAmJiBwb3MgPj0gZnJvbSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeGNlc3MgcGFkZGluZycpO1xuICAgIGlmICghcGFkZGluZyAmJiBjYXJyeSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb24temVybyBwYWRkaW5nOiAke2NhcnJ5fWApO1xuICAgIGlmIChwYWRkaW5nICYmIHBvcyA+IDApXG4gICAgICAgIHJlcy5wdXNoKGNhcnJ5ID4+PiAwKTtcbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gcmFkaXgobnVtKSB7XG4gICAgYXNzZXJ0TnVtYmVyKG51bSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlOiAoYnl0ZXMpID0+IHtcbiAgICAgICAgICAgIGlmICghKGJ5dGVzIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpeC5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIFVpbnQ4QXJyYXknKTtcbiAgICAgICAgICAgIHJldHVybiBjb252ZXJ0UmFkaXgoQXJyYXkuZnJvbShieXRlcyksIDIgKiogOCwgbnVtKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlOiAoZGlnaXRzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGlnaXRzKSB8fCAoZGlnaXRzLmxlbmd0aCAmJiB0eXBlb2YgZGlnaXRzWzBdICE9PSAnbnVtYmVyJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpeC5kZWNvZGUgaW5wdXQgc2hvdWxkIGJlIGFycmF5IG9mIHN0cmluZ3MnKTtcbiAgICAgICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oY29udmVydFJhZGl4KGRpZ2l0cywgbnVtLCAyICoqIDgpKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gcmFkaXgyKGJpdHMsIHJldlBhZGRpbmcgPSBmYWxzZSkge1xuICAgIGFzc2VydE51bWJlcihiaXRzKTtcbiAgICBpZiAoYml0cyA8PSAwIHx8IGJpdHMgPiAzMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpeDI6IGJpdHMgc2hvdWxkIGJlIGluICgwLi4zMl0nKTtcbiAgICBpZiAocmFkaXgyY2FycnkoOCwgYml0cykgPiAzMiB8fCByYWRpeDJjYXJyeShiaXRzLCA4KSA+IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4MjogY2Fycnkgb3ZlcmZsb3cnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGU6IChieXRlcykgPT4ge1xuICAgICAgICAgICAgaWYgKCEoYnl0ZXMgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4Mi5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIFVpbnQ4QXJyYXknKTtcbiAgICAgICAgICAgIHJldHVybiBjb252ZXJ0UmFkaXgyKEFycmF5LmZyb20oYnl0ZXMpLCA4LCBiaXRzLCAhcmV2UGFkZGluZyk7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZTogKGRpZ2l0cykgPT4ge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRpZ2l0cykgfHwgKGRpZ2l0cy5sZW5ndGggJiYgdHlwZW9mIGRpZ2l0c1swXSAhPT0gJ251bWJlcicpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmFkaXgyLmRlY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2Ygc3RyaW5ncycpO1xuICAgICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShjb252ZXJ0UmFkaXgyKGRpZ2l0cywgYml0cywgOCwgcmV2UGFkZGluZykpO1xuICAgICAgICB9LFxuICAgIH07XG59XG5mdW5jdGlvbiB1bnNhZmVXcmFwcGVyKGZuKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnNhZmVXcmFwcGVyIGZuIHNob3VsZCBiZSBmdW5jdGlvbicpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICB9O1xufVxuZnVuY3Rpb24gY2hlY2tzdW0obGVuLCBmbikge1xuICAgIGFzc2VydE51bWJlcihsZW4pO1xuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY2hlY2tzdW0gZm4gc2hvdWxkIGJlIGZ1bmN0aW9uJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlKGRhdGEpIHtcbiAgICAgICAgICAgIGlmICghKGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NoZWNrc3VtLmVuY29kZTogaW5wdXQgc2hvdWxkIGJlIFVpbnQ4QXJyYXknKTtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrc3VtID0gZm4oZGF0YSkuc2xpY2UoMCwgbGVuKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KGRhdGEubGVuZ3RoICsgbGVuKTtcbiAgICAgICAgICAgIHJlcy5zZXQoZGF0YSk7XG4gICAgICAgICAgICByZXMuc2V0KGNoZWNrc3VtLCBkYXRhLmxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGUoZGF0YSkge1xuICAgICAgICAgICAgaWYgKCEoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2hlY2tzdW0uZGVjb2RlOiBpbnB1dCBzaG91bGQgYmUgVWludDhBcnJheScpO1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IGRhdGEuc2xpY2UoMCwgLWxlbik7XG4gICAgICAgICAgICBjb25zdCBuZXdDaGVja3N1bSA9IGZuKHBheWxvYWQpLnNsaWNlKDAsIGxlbik7XG4gICAgICAgICAgICBjb25zdCBvbGRDaGVja3N1bSA9IGRhdGEuc2xpY2UoLWxlbik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgICAgICAgICAgIGlmIChuZXdDaGVja3N1bVtpXSAhPT0gb2xkQ2hlY2tzdW1baV0pXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjaGVja3N1bScpO1xuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmV4cG9ydHMudXRpbHMgPSB7IGFscGhhYmV0LCBjaGFpbiwgY2hlY2tzdW0sIHJhZGl4LCByYWRpeDIsIGpvaW4sIHBhZGRpbmcgfTtcbmV4cG9ydHMuYmFzZTE2ID0gY2hhaW4ocmFkaXgyKDQpLCBhbHBoYWJldCgnMDEyMzQ1Njc4OUFCQ0RFRicpLCBqb2luKCcnKSk7XG5leHBvcnRzLmJhc2UzMiA9IGNoYWluKHJhZGl4Mig1KSwgYWxwaGFiZXQoJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaMjM0NTY3JyksIHBhZGRpbmcoNSksIGpvaW4oJycpKTtcbmV4cG9ydHMuYmFzZTMyaGV4ID0gY2hhaW4ocmFkaXgyKDUpLCBhbHBoYWJldCgnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVYnKSwgcGFkZGluZyg1KSwgam9pbignJykpO1xuZXhwb3J0cy5iYXNlMzJjcm9ja2ZvcmQgPSBjaGFpbihyYWRpeDIoNSksIGFscGhhYmV0KCcwMTIzNDU2Nzg5QUJDREVGR0hKS01OUFFSU1RWV1hZWicpLCBqb2luKCcnKSwgbm9ybWFsaXplKChzKSA9PiBzLnRvVXBwZXJDYXNlKCkucmVwbGFjZSgvTy9nLCAnMCcpLnJlcGxhY2UoL1tJTF0vZywgJzEnKSkpO1xuZXhwb3J0cy5iYXNlNjQgPSBjaGFpbihyYWRpeDIoNiksIGFscGhhYmV0KCdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJyksIHBhZGRpbmcoNiksIGpvaW4oJycpKTtcbmV4cG9ydHMuYmFzZTY0dXJsID0gY2hhaW4ocmFkaXgyKDYpLCBhbHBoYWJldCgnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktXycpLCBwYWRkaW5nKDYpLCBqb2luKCcnKSk7XG5jb25zdCBnZW5CYXNlNTggPSAoYWJjKSA9PiBjaGFpbihyYWRpeCg1OCksIGFscGhhYmV0KGFiYyksIGpvaW4oJycpKTtcbmV4cG9ydHMuYmFzZTU4ID0gZ2VuQmFzZTU4KCcxMjM0NTY3ODlBQkNERUZHSEpLTE1OUFFSU1RVVldYWVphYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6Jyk7XG5leHBvcnRzLmJhc2U1OGZsaWNrciA9IGdlbkJhc2U1OCgnMTIzNDU2Nzg5YWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5ekFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWicpO1xuZXhwb3J0cy5iYXNlNTh4cnAgPSBnZW5CYXNlNTgoJ3Jwc2huYWYzOXdCVURORUdISktMTTRQUVJTVDdWV1hZWjJiY2RlQ2c2NWprbThvRnFpMXR1dkF4eXonKTtcbmNvbnN0IFhNUl9CTE9DS19MRU4gPSBbMCwgMiwgMywgNSwgNiwgNywgOSwgMTAsIDExXTtcbmV4cG9ydHMuYmFzZTU4eG1yID0ge1xuICAgIGVuY29kZShkYXRhKSB7XG4gICAgICAgIGxldCByZXMgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSA4KSB7XG4gICAgICAgICAgICBjb25zdCBibG9jayA9IGRhdGEuc3ViYXJyYXkoaSwgaSArIDgpO1xuICAgICAgICAgICAgcmVzICs9IGV4cG9ydHMuYmFzZTU4LmVuY29kZShibG9jaykucGFkU3RhcnQoWE1SX0JMT0NLX0xFTltibG9jay5sZW5ndGhdLCAnMScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSxcbiAgICBkZWNvZGUoc3RyKSB7XG4gICAgICAgIGxldCByZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpICs9IDExKSB7XG4gICAgICAgICAgICBjb25zdCBzbGljZSA9IHN0ci5zbGljZShpLCBpICsgMTEpO1xuICAgICAgICAgICAgY29uc3QgYmxvY2tMZW4gPSBYTVJfQkxPQ0tfTEVOLmluZGV4T2Yoc2xpY2UubGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrID0gZXhwb3J0cy5iYXNlNTguZGVjb2RlKHNsaWNlKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYmxvY2subGVuZ3RoIC0gYmxvY2tMZW47IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChibG9ja1tqXSAhPT0gMClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYXNlNTh4bXI6IHdyb25nIHBhZGRpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcyA9IHJlcy5jb25jYXQoQXJyYXkuZnJvbShibG9jay5zbGljZShibG9jay5sZW5ndGggLSBibG9ja0xlbikpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKHJlcyk7XG4gICAgfSxcbn07XG5jb25zdCBiYXNlNThjaGVjayA9IChzaGEyNTYpID0+IGNoYWluKGNoZWNrc3VtKDQsIChkYXRhKSA9PiBzaGEyNTYoc2hhMjU2KGRhdGEpKSksIGV4cG9ydHMuYmFzZTU4KTtcbmV4cG9ydHMuYmFzZTU4Y2hlY2sgPSBiYXNlNThjaGVjaztcbmNvbnN0IEJFQ0hfQUxQSEFCRVQgPSBjaGFpbihhbHBoYWJldCgncXB6cnk5eDhnZjJ0dmR3MHMzam41NGtoY2U2bXVhN2wnKSwgam9pbignJykpO1xuY29uc3QgUE9MWU1PRF9HRU5FUkFUT1JTID0gWzB4M2I2YTU3YjIsIDB4MjY1MDhlNmQsIDB4MWVhMTE5ZmEsIDB4M2Q0MjMzZGQsIDB4MmExNDYyYjNdO1xuZnVuY3Rpb24gYmVjaDMyUG9seW1vZChwcmUpIHtcbiAgICBjb25zdCBiID0gcHJlID4+IDI1O1xuICAgIGxldCBjaGsgPSAocHJlICYgMHgxZmZmZmZmKSA8PCA1O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgUE9MWU1PRF9HRU5FUkFUT1JTLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICgoKGIgPj4gaSkgJiAxKSA9PT0gMSlcbiAgICAgICAgICAgIGNoayBePSBQT0xZTU9EX0dFTkVSQVRPUlNbaV07XG4gICAgfVxuICAgIHJldHVybiBjaGs7XG59XG5mdW5jdGlvbiBiZWNoQ2hlY2tzdW0ocHJlZml4LCB3b3JkcywgZW5jb2RpbmdDb25zdCA9IDEpIHtcbiAgICBjb25zdCBsZW4gPSBwcmVmaXgubGVuZ3RoO1xuICAgIGxldCBjaGsgPSAxO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgYyA9IHByZWZpeC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA8IDMzIHx8IGMgPiAxMjYpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcHJlZml4ICgke3ByZWZpeH0pYCk7XG4gICAgICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKSBeIChjID4+IDUpO1xuICAgIH1cbiAgICBjaGsgPSBiZWNoMzJQb2x5bW9kKGNoayk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgICAgY2hrID0gYmVjaDMyUG9seW1vZChjaGspIF4gKHByZWZpeC5jaGFyQ29kZUF0KGkpICYgMHgxZik7XG4gICAgZm9yIChsZXQgdiBvZiB3b3JkcylcbiAgICAgICAgY2hrID0gYmVjaDMyUG9seW1vZChjaGspIF4gdjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkrKylcbiAgICAgICAgY2hrID0gYmVjaDMyUG9seW1vZChjaGspO1xuICAgIGNoayBePSBlbmNvZGluZ0NvbnN0O1xuICAgIHJldHVybiBCRUNIX0FMUEhBQkVULmVuY29kZShjb252ZXJ0UmFkaXgyKFtjaGsgJSAyICoqIDMwXSwgMzAsIDUsIGZhbHNlKSk7XG59XG5mdW5jdGlvbiBnZW5CZWNoMzIoZW5jb2RpbmcpIHtcbiAgICBjb25zdCBFTkNPRElOR19DT05TVCA9IGVuY29kaW5nID09PSAnYmVjaDMyJyA/IDEgOiAweDJiYzgzMGEzO1xuICAgIGNvbnN0IF93b3JkcyA9IHJhZGl4Mig1KTtcbiAgICBjb25zdCBmcm9tV29yZHMgPSBfd29yZHMuZGVjb2RlO1xuICAgIGNvbnN0IHRvV29yZHMgPSBfd29yZHMuZW5jb2RlO1xuICAgIGNvbnN0IGZyb21Xb3Jkc1Vuc2FmZSA9IHVuc2FmZVdyYXBwZXIoZnJvbVdvcmRzKTtcbiAgICBmdW5jdGlvbiBlbmNvZGUocHJlZml4LCB3b3JkcywgbGltaXQgPSA5MCkge1xuICAgICAgICBpZiAodHlwZW9mIHByZWZpeCAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJlY2gzMi5lbmNvZGUgcHJlZml4IHNob3VsZCBiZSBzdHJpbmcsIG5vdCAke3R5cGVvZiBwcmVmaXh9YCk7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh3b3JkcykgfHwgKHdvcmRzLmxlbmd0aCAmJiB0eXBlb2Ygd29yZHNbMF0gIT09ICdudW1iZXInKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYmVjaDMyLmVuY29kZSB3b3JkcyBzaG91bGQgYmUgYXJyYXkgb2YgbnVtYmVycywgbm90ICR7dHlwZW9mIHdvcmRzfWApO1xuICAgICAgICBjb25zdCBhY3R1YWxMZW5ndGggPSBwcmVmaXgubGVuZ3RoICsgNyArIHdvcmRzLmxlbmd0aDtcbiAgICAgICAgaWYgKGxpbWl0ICE9PSBmYWxzZSAmJiBhY3R1YWxMZW5ndGggPiBsaW1pdClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYExlbmd0aCAke2FjdHVhbExlbmd0aH0gZXhjZWVkcyBsaW1pdCAke2xpbWl0fWApO1xuICAgICAgICBwcmVmaXggPSBwcmVmaXgudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0dXJuIGAke3ByZWZpeH0xJHtCRUNIX0FMUEhBQkVULmVuY29kZSh3b3Jkcyl9JHtiZWNoQ2hlY2tzdW0ocHJlZml4LCB3b3JkcywgRU5DT0RJTkdfQ09OU1QpfWA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlY29kZShzdHIsIGxpbWl0ID0gOTApIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBiZWNoMzIuZGVjb2RlIGlucHV0IHNob3VsZCBiZSBzdHJpbmcsIG5vdCAke3R5cGVvZiBzdHJ9YCk7XG4gICAgICAgIGlmIChzdHIubGVuZ3RoIDwgOCB8fCAobGltaXQgIT09IGZhbHNlICYmIHN0ci5sZW5ndGggPiBsaW1pdCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBXcm9uZyBzdHJpbmcgbGVuZ3RoOiAke3N0ci5sZW5ndGh9ICgke3N0cn0pLiBFeHBlY3RlZCAoOC4uJHtsaW1pdH0pYCk7XG4gICAgICAgIGNvbnN0IGxvd2VyZWQgPSBzdHIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKHN0ciAhPT0gbG93ZXJlZCAmJiBzdHIgIT09IHN0ci50b1VwcGVyQ2FzZSgpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTdHJpbmcgbXVzdCBiZSBsb3dlcmNhc2Ugb3IgdXBwZXJjYXNlYCk7XG4gICAgICAgIHN0ciA9IGxvd2VyZWQ7XG4gICAgICAgIGNvbnN0IHNlcEluZGV4ID0gc3RyLmxhc3RJbmRleE9mKCcxJyk7XG4gICAgICAgIGlmIChzZXBJbmRleCA9PT0gMCB8fCBzZXBJbmRleCA9PT0gLTEpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExldHRlciBcIjFcIiBtdXN0IGJlIHByZXNlbnQgYmV0d2VlbiBwcmVmaXggYW5kIGRhdGEgb25seWApO1xuICAgICAgICBjb25zdCBwcmVmaXggPSBzdHIuc2xpY2UoMCwgc2VwSW5kZXgpO1xuICAgICAgICBjb25zdCBfd29yZHMgPSBzdHIuc2xpY2Uoc2VwSW5kZXggKyAxKTtcbiAgICAgICAgaWYgKF93b3Jkcy5sZW5ndGggPCA2KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIG11c3QgYmUgYXQgbGVhc3QgNiBjaGFyYWN0ZXJzIGxvbmcnKTtcbiAgICAgICAgY29uc3Qgd29yZHMgPSBCRUNIX0FMUEhBQkVULmRlY29kZShfd29yZHMpLnNsaWNlKDAsIC02KTtcbiAgICAgICAgY29uc3Qgc3VtID0gYmVjaENoZWNrc3VtKHByZWZpeCwgd29yZHMsIEVOQ09ESU5HX0NPTlNUKTtcbiAgICAgICAgaWYgKCFfd29yZHMuZW5kc1dpdGgoc3VtKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjaGVja3N1bSBpbiAke3N0cn06IGV4cGVjdGVkIFwiJHtzdW19XCJgKTtcbiAgICAgICAgcmV0dXJuIHsgcHJlZml4LCB3b3JkcyB9O1xuICAgIH1cbiAgICBjb25zdCBkZWNvZGVVbnNhZmUgPSB1bnNhZmVXcmFwcGVyKGRlY29kZSk7XG4gICAgZnVuY3Rpb24gZGVjb2RlVG9CeXRlcyhzdHIpIHtcbiAgICAgICAgY29uc3QgeyBwcmVmaXgsIHdvcmRzIH0gPSBkZWNvZGUoc3RyLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiB7IHByZWZpeCwgd29yZHMsIGJ5dGVzOiBmcm9tV29yZHMod29yZHMpIH07XG4gICAgfVxuICAgIHJldHVybiB7IGVuY29kZSwgZGVjb2RlLCBkZWNvZGVUb0J5dGVzLCBkZWNvZGVVbnNhZmUsIGZyb21Xb3JkcywgZnJvbVdvcmRzVW5zYWZlLCB0b1dvcmRzIH07XG59XG5leHBvcnRzLmJlY2gzMiA9IGdlbkJlY2gzMignYmVjaDMyJyk7XG5leHBvcnRzLmJlY2gzMm0gPSBnZW5CZWNoMzIoJ2JlY2gzMm0nKTtcbmV4cG9ydHMudXRmOCA9IHtcbiAgICBlbmNvZGU6IChkYXRhKSA9PiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoZGF0YSksXG4gICAgZGVjb2RlOiAoc3RyKSA9PiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSxcbn07XG5leHBvcnRzLmhleCA9IGNoYWluKHJhZGl4Mig0KSwgYWxwaGFiZXQoJzAxMjM0NTY3ODlhYmNkZWYnKSwgam9pbignJyksIG5vcm1hbGl6ZSgocykgPT4ge1xuICAgIGlmICh0eXBlb2YgcyAhPT0gJ3N0cmluZycgfHwgcy5sZW5ndGggJSAyKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBoZXguZGVjb2RlOiBleHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiBzfSB3aXRoIGxlbmd0aCAke3MubGVuZ3RofWApO1xuICAgIHJldHVybiBzLnRvTG93ZXJDYXNlKCk7XG59KSk7XG5jb25zdCBDT0RFUlMgPSB7XG4gICAgdXRmODogZXhwb3J0cy51dGY4LCBoZXg6IGV4cG9ydHMuaGV4LCBiYXNlMTY6IGV4cG9ydHMuYmFzZTE2LCBiYXNlMzI6IGV4cG9ydHMuYmFzZTMyLCBiYXNlNjQ6IGV4cG9ydHMuYmFzZTY0LCBiYXNlNjR1cmw6IGV4cG9ydHMuYmFzZTY0dXJsLCBiYXNlNTg6IGV4cG9ydHMuYmFzZTU4LCBiYXNlNTh4bXI6IGV4cG9ydHMuYmFzZTU4eG1yXG59O1xuY29uc3QgY29kZXJUeXBlRXJyb3IgPSBgSW52YWxpZCBlbmNvZGluZyB0eXBlLiBBdmFpbGFibGUgdHlwZXM6ICR7T2JqZWN0LmtleXMoQ09ERVJTKS5qb2luKCcsICcpfWA7XG5jb25zdCBieXRlc1RvU3RyaW5nID0gKHR5cGUsIGJ5dGVzKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB0eXBlICE9PSAnc3RyaW5nJyB8fCAhQ09ERVJTLmhhc093blByb3BlcnR5KHR5cGUpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGNvZGVyVHlwZUVycm9yKTtcbiAgICBpZiAoIShieXRlcyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdieXRlc1RvU3RyaW5nKCkgZXhwZWN0cyBVaW50OEFycmF5Jyk7XG4gICAgcmV0dXJuIENPREVSU1t0eXBlXS5lbmNvZGUoYnl0ZXMpO1xufTtcbmV4cG9ydHMuYnl0ZXNUb1N0cmluZyA9IGJ5dGVzVG9TdHJpbmc7XG5leHBvcnRzLnN0ciA9IGV4cG9ydHMuYnl0ZXNUb1N0cmluZztcbmNvbnN0IHN0cmluZ1RvQnl0ZXMgPSAodHlwZSwgc3RyKSA9PiB7XG4gICAgaWYgKCFDT0RFUlMuaGFzT3duUHJvcGVydHkodHlwZSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoY29kZXJUeXBlRXJyb3IpO1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc3RyaW5nVG9CeXRlcygpIGV4cGVjdHMgc3RyaW5nJyk7XG4gICAgcmV0dXJuIENPREVSU1t0eXBlXS5kZWNvZGUoc3RyKTtcbn07XG5leHBvcnRzLnN0cmluZ1RvQnl0ZXMgPSBzdHJpbmdUb0J5dGVzO1xuZXhwb3J0cy5ieXRlcyA9IGV4cG9ydHMuc3RyaW5nVG9CeXRlcztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/light-bolt11-decoder/node_modules/@scure/base/lib/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ms/index.js":
/*!**********************************!*\
  !*** ./node_modules/ms/index.js ***!
  \**********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function (val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsUUFBUTtBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbGZnL0dpdC9NYWR0cmlwcy9ub2RlX21vZHVsZXMvbXMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMDtcbnZhciBtID0gcyAqIDYwO1xudmFyIGggPSBtICogNjA7XG52YXIgZCA9IGggKiAyNDtcbnZhciB3ID0gZCAqIDc7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsO1xuICBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gcGFyc2UodmFsKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSh2YWwpKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubG9uZyA/IGZtdExvbmcodmFsKSA6IGZtdFNob3J0KHZhbCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICd2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIHZhbGlkIG51bWJlci4gdmFsPScgK1xuICAgICAgSlNPTi5zdHJpbmdpZnkodmFsKVxuICApO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHN0ciA9IFN0cmluZyhzdHIpO1xuICBpZiAoc3RyLmxlbmd0aCA+IDEwMCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbWF0Y2ggPSAvXigtPyg/OlxcZCspP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8d2Vla3M/fHd8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoXG4gICAgc3RyXG4gICk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3lycyc6XG4gICAgY2FzZSAneXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5O1xuICAgIGNhc2UgJ3dlZWtzJzpcbiAgICBjYXNlICd3ZWVrJzpcbiAgICBjYXNlICd3JzpcbiAgICAgIHJldHVybiBuICogdztcbiAgICBjYXNlICdkYXlzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2QnOlxuICAgICAgcmV0dXJuIG4gKiBkO1xuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaDtcbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICBjYXNlICdtaW51dGUnOlxuICAgIGNhc2UgJ21pbnMnOlxuICAgIGNhc2UgJ21pbic6XG4gICAgY2FzZSAnbSc6XG4gICAgICByZXR1cm4gbiAqIG07XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICBjYXNlICdzZWNzJzpcbiAgICBjYXNlICdzZWMnOlxuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIG4gKiBzO1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gbjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdFNob3J0KG1zKSB7XG4gIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgaWYgKG1zQWJzID49IGQpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuICB9XG4gIGlmIChtc0FicyA+PSBoKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuICB9XG4gIHJldHVybiBtcyArICdtcyc7XG59XG5cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRMb25nKG1zKSB7XG4gIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgaWYgKG1zQWJzID49IGQpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgZCwgJ2RheScpO1xuICB9XG4gIGlmIChtc0FicyA+PSBoKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGgsICdob3VyJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IG0pIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgbSwgJ21pbnV0ZScpO1xuICB9XG4gIGlmIChtc0FicyA+PSBzKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIHMsICdzZWNvbmQnKTtcbiAgfVxuICByZXR1cm4gbXMgKyAnIG1zJztcbn1cblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWwobXMsIG1zQWJzLCBuLCBuYW1lKSB7XG4gIHZhciBpc1BsdXJhbCA9IG1zQWJzID49IG4gKiAxLjU7XG4gIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbikgKyAnICcgKyBuYW1lICsgKGlzUGx1cmFsID8gJ3MnIDogJycpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ms/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Fhome%2Flfg%2FGit%2FMadtrips%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fapp-dir%2Flink.js%22%2C%22ids%22%3A%5B%22__esModule%22%2C%22default%22%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Flfg%2FGit%2FMadtrips%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fimage-component.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Flfg%2FGit%2FMadtrips%2Fnode_modules%2Fnext%2Ffont%2Fgoogle%2Ftarget.css%3F%7B%5C%22path%5C%22%3A%5C%22src%2Fapp%2Flayout.tsx%5C%22%2C%5C%22import%5C%22%3A%5C%22Inter%5C%22%2C%5C%22arguments%5C%22%3A%5B%7B%5C%22subsets%5C%22%3A%5B%5C%22latin%5C%22%5D%2C%5C%22display%5C%22%3A%5C%22swap%5C%22%7D%5D%2C%5C%22variableName%5C%22%3A%5C%22inter%5C%22%7D%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Flfg%2FGit%2FMadtrips%2Fsrc%2Fapp%2Fglobals.css%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Flfg%2FGit%2FMadtrips%2Fsrc%2Fcomponents%2Flayout%2FNavigation.tsx%22%2C%22ids%22%3A%5B%22Navigation%22%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Flfg%2FGit%2FMadtrips%2Fsrc%2Fcomponents%2FNostrLink.tsx%22%2C%22ids%22%3A%5B%22NostrLink%22%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Flfg%2FGit%2FMadtrips%2Fsrc%2Fcomponents%2FThemeProvider.tsx%22%2C%22ids%22%3A%5B%22ThemeProvider%22%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Flfg%2FGit%2FMadtrips%2Fsrc%2Flib%2Fnostr%2FNostrAuthProvider.tsx%22%2C%22ids%22%3A%5B%22NostrAuthProvider%22%5D%7D&server=false!":
/*!********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Fhome%2Flfg%2FGit%2FMadtrips%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fapp-dir%2Flink.js%22%2C%22ids%22%3A%5B%22__esModule%22%2C%22default%22%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Flfg%2FGit%2FMadtrips%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fimage-component.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Flfg%2FGit%2FMadtrips%2Fnode_modules%2Fnext%2Ffont%2Fgoogle%2Ftarget.css%3F%7B%5C%22path%5C%22%3A%5C%22src%2Fapp%2Flayout.tsx%5C%22%2C%5C%22import%5C%22%3A%5C%22Inter%5C%22%2C%5C%22arguments%5C%22%3A%5B%7B%5C%22subsets%5C%22%3A%5B%5C%22latin%5C%22%5D%2C%5C%22display%5C%22%3A%5C%22swap%5C%22%7D%5D%2C%5C%22variableName%5C%22%3A%5C%22inter%5C%22%7D%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Flfg%2FGit%2FMadtrips%2Fsrc%2Fapp%2Fglobals.css%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Flfg%2FGit%2FMadtrips%2Fsrc%2Fcomponents%2Flayout%2FNavigation.tsx%22%2C%22ids%22%3A%5B%22Navigation%22%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Flfg%2FGit%2FMadtrips%2Fsrc%2Fcomponents%2FNostrLink.tsx%22%2C%22ids%22%3A%5B%22NostrLink%22%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Flfg%2FGit%2FMadtrips%2Fsrc%2Fcomponents%2FThemeProvider.tsx%22%2C%22ids%22%3A%5B%22ThemeProvider%22%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Flfg%2FGit%2FMadtrips%2Fsrc%2Flib%2Fnostr%2FNostrAuthProvider.tsx%22%2C%22ids%22%3A%5B%22NostrAuthProvider%22%5D%7D&server=false! ***!
  \********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/app-dir/link.js */ \"(app-pages-browser)/./node_modules/next/dist/client/app-dir/link.js\", 23));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/image-component.js */ \"(app-pages-browser)/./node_modules/next/dist/client/image-component.js\", 23));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/font/google/target.css?{\"path\":\"src/app/layout.tsx\",\"import\":\"Inter\",\"arguments\":[{\"subsets\":[\"latin\"],\"display\":\"swap\"}],\"variableName\":\"inter\"} */ \"(app-pages-browser)/./node_modules/next/font/google/target.css?{\\\"path\\\":\\\"src/app/layout.tsx\\\",\\\"import\\\":\\\"Inter\\\",\\\"arguments\\\":[{\\\"subsets\\\":[\\\"latin\\\"],\\\"display\\\":\\\"swap\\\"}],\\\"variableName\\\":\\\"inter\\\"}\", 23));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/app/globals.css */ \"(app-pages-browser)/./src/app/globals.css\"));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/components/layout/Navigation.tsx */ \"(app-pages-browser)/./src/components/layout/Navigation.tsx\"));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/components/NostrLink.tsx */ \"(app-pages-browser)/./src/components/NostrLink.tsx\"));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/components/ThemeProvider.tsx */ \"(app-pages-browser)/./src/components/ThemeProvider.tsx\"));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/lib/nostr/NostrAuthProvider.tsx */ \"(app-pages-browser)/./src/lib/nostr/NostrAuthProvider.tsx\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyJTJGaG9tZSUyRmxmZyUyRkdpdCUyRk1hZHRyaXBzJTJGbm9kZV9tb2R1bGVzJTJGbmV4dCUyRmRpc3QlMkZjbGllbnQlMkZhcHAtZGlyJTJGbGluay5qcyUyMiUyQyUyMmlkcyUyMiUzQSU1QiUyMl9fZXNNb2R1bGUlMjIlMkMlMjJkZWZhdWx0JTIyJTVEJTdEJm1vZHVsZXM9JTdCJTIycmVxdWVzdCUyMiUzQSUyMiUyRmhvbWUlMkZsZmclMkZHaXQlMkZNYWR0cmlwcyUyRm5vZGVfbW9kdWxlcyUyRm5leHQlMkZkaXN0JTJGY2xpZW50JTJGaW1hZ2UtY29tcG9uZW50LmpzJTIyJTJDJTIyaWRzJTIyJTNBJTVCJTVEJTdEJm1vZHVsZXM9JTdCJTIycmVxdWVzdCUyMiUzQSUyMiUyRmhvbWUlMkZsZmclMkZHaXQlMkZNYWR0cmlwcyUyRm5vZGVfbW9kdWxlcyUyRm5leHQlMkZmb250JTJGZ29vZ2xlJTJGdGFyZ2V0LmNzcyUzRiU3QiU1QyUyMnBhdGglNUMlMjIlM0ElNUMlMjJzcmMlMkZhcHAlMkZsYXlvdXQudHN4JTVDJTIyJTJDJTVDJTIyaW1wb3J0JTVDJTIyJTNBJTVDJTIySW50ZXIlNUMlMjIlMkMlNUMlMjJhcmd1bWVudHMlNUMlMjIlM0ElNUIlN0IlNUMlMjJzdWJzZXRzJTVDJTIyJTNBJTVCJTVDJTIybGF0aW4lNUMlMjIlNUQlMkMlNUMlMjJkaXNwbGF5JTVDJTIyJTNBJTVDJTIyc3dhcCU1QyUyMiU3RCU1RCUyQyU1QyUyMnZhcmlhYmxlTmFtZSU1QyUyMiUzQSU1QyUyMmludGVyJTVDJTIyJTdEJTIyJTJDJTIyaWRzJTIyJTNBJTVCJTVEJTdEJm1vZHVsZXM9JTdCJTIycmVxdWVzdCUyMiUzQSUyMiUyRmhvbWUlMkZsZmclMkZHaXQlMkZNYWR0cmlwcyUyRnNyYyUyRmFwcCUyRmdsb2JhbHMuY3NzJTIyJTJDJTIyaWRzJTIyJTNBJTVCJTVEJTdEJm1vZHVsZXM9JTdCJTIycmVxdWVzdCUyMiUzQSUyMiUyRmhvbWUlMkZsZmclMkZHaXQlMkZNYWR0cmlwcyUyRnNyYyUyRmNvbXBvbmVudHMlMkZsYXlvdXQlMkZOYXZpZ2F0aW9uLnRzeCUyMiUyQyUyMmlkcyUyMiUzQSU1QiUyMk5hdmlnYXRpb24lMjIlNUQlN0QmbW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyJTJGaG9tZSUyRmxmZyUyRkdpdCUyRk1hZHRyaXBzJTJGc3JjJTJGY29tcG9uZW50cyUyRk5vc3RyTGluay50c3glMjIlMkMlMjJpZHMlMjIlM0ElNUIlMjJOb3N0ckxpbmslMjIlNUQlN0QmbW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyJTJGaG9tZSUyRmxmZyUyRkdpdCUyRk1hZHRyaXBzJTJGc3JjJTJGY29tcG9uZW50cyUyRlRoZW1lUHJvdmlkZXIudHN4JTIyJTJDJTIyaWRzJTIyJTNBJTVCJTIyVGhlbWVQcm92aWRlciUyMiU1RCU3RCZtb2R1bGVzPSU3QiUyMnJlcXVlc3QlMjIlM0ElMjIlMkZob21lJTJGbGZnJTJGR2l0JTJGTWFkdHJpcHMlMkZzcmMlMkZsaWIlMkZub3N0ciUyRk5vc3RyQXV0aFByb3ZpZGVyLnRzeCUyMiUyQyUyMmlkcyUyMiUzQSU1QiUyMk5vc3RyQXV0aFByb3ZpZGVyJTIyJTVEJTdEJnNlcnZlcj1mYWxzZSEiLCJtYXBwaW5ncyI6IkFBQUEsOE5BQW1KO0FBQ25KO0FBQ0Esb09BQTRHO0FBQzVHO0FBQ0EsZ2VBQXFQO0FBQ3JQO0FBQ0Esb0tBQStFO0FBQy9FO0FBQ0Esc01BQWdJO0FBQ2hJO0FBQ0Esc0xBQXVIO0FBQ3ZIO0FBQ0EsOExBQStIO0FBQy9IO0FBQ0Esb01BQXNJIiwic291cmNlcyI6WyIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIsIHdlYnBhY2tFeHBvcnRzOiBbXCJfX2VzTW9kdWxlXCIsXCJkZWZhdWx0XCJdICovIFwiL2hvbWUvbGZnL0dpdC9NYWR0cmlwcy9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9hcHAtZGlyL2xpbmsuanNcIik7XG47XG5pbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIi9ob21lL2xmZy9HaXQvTWFkdHJpcHMvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvaW1hZ2UtY29tcG9uZW50LmpzXCIpO1xuO1xuaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCIvaG9tZS9sZmcvR2l0L01hZHRyaXBzL25vZGVfbW9kdWxlcy9uZXh0L2ZvbnQvZ29vZ2xlL3RhcmdldC5jc3M/e1xcXCJwYXRoXFxcIjpcXFwic3JjL2FwcC9sYXlvdXQudHN4XFxcIixcXFwiaW1wb3J0XFxcIjpcXFwiSW50ZXJcXFwiLFxcXCJhcmd1bWVudHNcXFwiOlt7XFxcInN1YnNldHNcXFwiOltcXFwibGF0aW5cXFwiXSxcXFwiZGlzcGxheVxcXCI6XFxcInN3YXBcXFwifV0sXFxcInZhcmlhYmxlTmFtZVxcXCI6XFxcImludGVyXFxcIn1cIik7XG47XG5pbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIi9ob21lL2xmZy9HaXQvTWFkdHJpcHMvc3JjL2FwcC9nbG9iYWxzLmNzc1wiKTtcbjtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiLCB3ZWJwYWNrRXhwb3J0czogW1wiTmF2aWdhdGlvblwiXSAqLyBcIi9ob21lL2xmZy9HaXQvTWFkdHJpcHMvc3JjL2NvbXBvbmVudHMvbGF5b3V0L05hdmlnYXRpb24udHN4XCIpO1xuO1xuaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIsIHdlYnBhY2tFeHBvcnRzOiBbXCJOb3N0ckxpbmtcIl0gKi8gXCIvaG9tZS9sZmcvR2l0L01hZHRyaXBzL3NyYy9jb21wb25lbnRzL05vc3RyTGluay50c3hcIik7XG47XG5pbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiwgd2VicGFja0V4cG9ydHM6IFtcIlRoZW1lUHJvdmlkZXJcIl0gKi8gXCIvaG9tZS9sZmcvR2l0L01hZHRyaXBzL3NyYy9jb21wb25lbnRzL1RoZW1lUHJvdmlkZXIudHN4XCIpO1xuO1xuaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIsIHdlYnBhY2tFeHBvcnRzOiBbXCJOb3N0ckF1dGhQcm92aWRlclwiXSAqLyBcIi9ob21lL2xmZy9HaXQvTWFkdHJpcHMvc3JjL2xpYi9ub3N0ci9Ob3N0ckF1dGhQcm92aWRlci50c3hcIik7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Fhome%2Flfg%2FGit%2FMadtrips%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fapp-dir%2Flink.js%22%2C%22ids%22%3A%5B%22__esModule%22%2C%22default%22%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Flfg%2FGit%2FMadtrips%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fimage-component.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Flfg%2FGit%2FMadtrips%2Fnode_modules%2Fnext%2Ffont%2Fgoogle%2Ftarget.css%3F%7B%5C%22path%5C%22%3A%5C%22src%2Fapp%2Flayout.tsx%5C%22%2C%5C%22import%5C%22%3A%5C%22Inter%5C%22%2C%5C%22arguments%5C%22%3A%5B%7B%5C%22subsets%5C%22%3A%5B%5C%22latin%5C%22%5D%2C%5C%22display%5C%22%3A%5C%22swap%5C%22%7D%5D%2C%5C%22variableName%5C%22%3A%5C%22inter%5C%22%7D%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Flfg%2FGit%2FMadtrips%2Fsrc%2Fapp%2Fglobals.css%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Flfg%2FGit%2FMadtrips%2Fsrc%2Fcomponents%2Flayout%2FNavigation.tsx%22%2C%22ids%22%3A%5B%22Navigation%22%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Flfg%2FGit%2FMadtrips%2Fsrc%2Fcomponents%2FNostrLink.tsx%22%2C%22ids%22%3A%5B%22NostrLink%22%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Flfg%2FGit%2FMadtrips%2Fsrc%2Fcomponents%2FThemeProvider.tsx%22%2C%22ids%22%3A%5B%22ThemeProvider%22%5D%7D&modules=%7B%22request%22%3A%22%2Fhome%2Flfg%2FGit%2FMadtrips%2Fsrc%2Flib%2Fnostr%2FNostrAuthProvider.tsx%22%2C%22ids%22%3A%5B%22NostrAuthProvider%22%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/buffer/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/next/dist/compiled/buffer/index.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){var e={675:function(e,r){\"use strict\";r.byteLength=byteLength;r.toByteArray=toByteArray;r.fromByteArray=fromByteArray;var t=[];var f=[];var n=typeof Uint8Array!==\"undefined\"?Uint8Array:Array;var i=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";for(var o=0,u=i.length;o<u;++o){t[o]=i[o];f[i.charCodeAt(o)]=o}f[\"-\".charCodeAt(0)]=62;f[\"_\".charCodeAt(0)]=63;function getLens(e){var r=e.length;if(r%4>0){throw new Error(\"Invalid string. Length must be a multiple of 4\")}var t=e.indexOf(\"=\");if(t===-1)t=r;var f=t===r?0:4-t%4;return[t,f]}function byteLength(e){var r=getLens(e);var t=r[0];var f=r[1];return(t+f)*3/4-f}function _byteLength(e,r,t){return(r+t)*3/4-t}function toByteArray(e){var r;var t=getLens(e);var i=t[0];var o=t[1];var u=new n(_byteLength(e,i,o));var a=0;var s=o>0?i-4:i;var h;for(h=0;h<s;h+=4){r=f[e.charCodeAt(h)]<<18|f[e.charCodeAt(h+1)]<<12|f[e.charCodeAt(h+2)]<<6|f[e.charCodeAt(h+3)];u[a++]=r>>16&255;u[a++]=r>>8&255;u[a++]=r&255}if(o===2){r=f[e.charCodeAt(h)]<<2|f[e.charCodeAt(h+1)]>>4;u[a++]=r&255}if(o===1){r=f[e.charCodeAt(h)]<<10|f[e.charCodeAt(h+1)]<<4|f[e.charCodeAt(h+2)]>>2;u[a++]=r>>8&255;u[a++]=r&255}return u}function tripletToBase64(e){return t[e>>18&63]+t[e>>12&63]+t[e>>6&63]+t[e&63]}function encodeChunk(e,r,t){var f;var n=[];for(var i=r;i<t;i+=3){f=(e[i]<<16&16711680)+(e[i+1]<<8&65280)+(e[i+2]&255);n.push(tripletToBase64(f))}return n.join(\"\")}function fromByteArray(e){var r;var f=e.length;var n=f%3;var i=[];var o=16383;for(var u=0,a=f-n;u<a;u+=o){i.push(encodeChunk(e,u,u+o>a?a:u+o))}if(n===1){r=e[f-1];i.push(t[r>>2]+t[r<<4&63]+\"==\")}else if(n===2){r=(e[f-2]<<8)+e[f-1];i.push(t[r>>10]+t[r>>4&63]+t[r<<2&63]+\"=\")}return i.join(\"\")}},72:function(e,r,t){\"use strict\";\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */var f=t(675);var n=t(783);var i=typeof Symbol===\"function\"&&typeof Symbol.for===\"function\"?Symbol.for(\"nodejs.util.inspect.custom\"):null;r.Buffer=Buffer;r.SlowBuffer=SlowBuffer;r.INSPECT_MAX_BYTES=50;var o=2147483647;r.kMaxLength=o;Buffer.TYPED_ARRAY_SUPPORT=typedArraySupport();if(!Buffer.TYPED_ARRAY_SUPPORT&&typeof console!==\"undefined\"&&typeof console.error===\"function\"){console.error(\"This browser lacks typed array (Uint8Array) support which is required by \"+\"`buffer` v5.x. Use `buffer` v4.x if you require old browser support.\")}function typedArraySupport(){try{var e=new Uint8Array(1);var r={foo:function(){return 42}};Object.setPrototypeOf(r,Uint8Array.prototype);Object.setPrototypeOf(e,r);return e.foo()===42}catch(e){return false}}Object.defineProperty(Buffer.prototype,\"parent\",{enumerable:true,get:function(){if(!Buffer.isBuffer(this))return undefined;return this.buffer}});Object.defineProperty(Buffer.prototype,\"offset\",{enumerable:true,get:function(){if(!Buffer.isBuffer(this))return undefined;return this.byteOffset}});function createBuffer(e){if(e>o){throw new RangeError('The value \"'+e+'\" is invalid for option \"size\"')}var r=new Uint8Array(e);Object.setPrototypeOf(r,Buffer.prototype);return r}function Buffer(e,r,t){if(typeof e===\"number\"){if(typeof r===\"string\"){throw new TypeError('The \"string\" argument must be of type string. Received type number')}return allocUnsafe(e)}return from(e,r,t)}Buffer.poolSize=8192;function from(e,r,t){if(typeof e===\"string\"){return fromString(e,r)}if(ArrayBuffer.isView(e)){return fromArrayLike(e)}if(e==null){throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, \"+\"or Array-like Object. Received type \"+typeof e)}if(isInstance(e,ArrayBuffer)||e&&isInstance(e.buffer,ArrayBuffer)){return fromArrayBuffer(e,r,t)}if(typeof SharedArrayBuffer!==\"undefined\"&&(isInstance(e,SharedArrayBuffer)||e&&isInstance(e.buffer,SharedArrayBuffer))){return fromArrayBuffer(e,r,t)}if(typeof e===\"number\"){throw new TypeError('The \"value\" argument must not be of type number. Received type number')}var f=e.valueOf&&e.valueOf();if(f!=null&&f!==e){return Buffer.from(f,r,t)}var n=fromObject(e);if(n)return n;if(typeof Symbol!==\"undefined\"&&Symbol.toPrimitive!=null&&typeof e[Symbol.toPrimitive]===\"function\"){return Buffer.from(e[Symbol.toPrimitive](\"string\"),r,t)}throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, \"+\"or Array-like Object. Received type \"+typeof e)}Buffer.from=function(e,r,t){return from(e,r,t)};Object.setPrototypeOf(Buffer.prototype,Uint8Array.prototype);Object.setPrototypeOf(Buffer,Uint8Array);function assertSize(e){if(typeof e!==\"number\"){throw new TypeError('\"size\" argument must be of type number')}else if(e<0){throw new RangeError('The value \"'+e+'\" is invalid for option \"size\"')}}function alloc(e,r,t){assertSize(e);if(e<=0){return createBuffer(e)}if(r!==undefined){return typeof t===\"string\"?createBuffer(e).fill(r,t):createBuffer(e).fill(r)}return createBuffer(e)}Buffer.alloc=function(e,r,t){return alloc(e,r,t)};function allocUnsafe(e){assertSize(e);return createBuffer(e<0?0:checked(e)|0)}Buffer.allocUnsafe=function(e){return allocUnsafe(e)};Buffer.allocUnsafeSlow=function(e){return allocUnsafe(e)};function fromString(e,r){if(typeof r!==\"string\"||r===\"\"){r=\"utf8\"}if(!Buffer.isEncoding(r)){throw new TypeError(\"Unknown encoding: \"+r)}var t=byteLength(e,r)|0;var f=createBuffer(t);var n=f.write(e,r);if(n!==t){f=f.slice(0,n)}return f}function fromArrayLike(e){var r=e.length<0?0:checked(e.length)|0;var t=createBuffer(r);for(var f=0;f<r;f+=1){t[f]=e[f]&255}return t}function fromArrayBuffer(e,r,t){if(r<0||e.byteLength<r){throw new RangeError('\"offset\" is outside of buffer bounds')}if(e.byteLength<r+(t||0)){throw new RangeError('\"length\" is outside of buffer bounds')}var f;if(r===undefined&&t===undefined){f=new Uint8Array(e)}else if(t===undefined){f=new Uint8Array(e,r)}else{f=new Uint8Array(e,r,t)}Object.setPrototypeOf(f,Buffer.prototype);return f}function fromObject(e){if(Buffer.isBuffer(e)){var r=checked(e.length)|0;var t=createBuffer(r);if(t.length===0){return t}e.copy(t,0,0,r);return t}if(e.length!==undefined){if(typeof e.length!==\"number\"||numberIsNaN(e.length)){return createBuffer(0)}return fromArrayLike(e)}if(e.type===\"Buffer\"&&Array.isArray(e.data)){return fromArrayLike(e.data)}}function checked(e){if(e>=o){throw new RangeError(\"Attempt to allocate Buffer larger than maximum \"+\"size: 0x\"+o.toString(16)+\" bytes\")}return e|0}function SlowBuffer(e){if(+e!=e){e=0}return Buffer.alloc(+e)}Buffer.isBuffer=function isBuffer(e){return e!=null&&e._isBuffer===true&&e!==Buffer.prototype};Buffer.compare=function compare(e,r){if(isInstance(e,Uint8Array))e=Buffer.from(e,e.offset,e.byteLength);if(isInstance(r,Uint8Array))r=Buffer.from(r,r.offset,r.byteLength);if(!Buffer.isBuffer(e)||!Buffer.isBuffer(r)){throw new TypeError('The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array')}if(e===r)return 0;var t=e.length;var f=r.length;for(var n=0,i=Math.min(t,f);n<i;++n){if(e[n]!==r[n]){t=e[n];f=r[n];break}}if(t<f)return-1;if(f<t)return 1;return 0};Buffer.isEncoding=function isEncoding(e){switch(String(e).toLowerCase()){case\"hex\":case\"utf8\":case\"utf-8\":case\"ascii\":case\"latin1\":case\"binary\":case\"base64\":case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return true;default:return false}};Buffer.concat=function concat(e,r){if(!Array.isArray(e)){throw new TypeError('\"list\" argument must be an Array of Buffers')}if(e.length===0){return Buffer.alloc(0)}var t;if(r===undefined){r=0;for(t=0;t<e.length;++t){r+=e[t].length}}var f=Buffer.allocUnsafe(r);var n=0;for(t=0;t<e.length;++t){var i=e[t];if(isInstance(i,Uint8Array)){i=Buffer.from(i)}if(!Buffer.isBuffer(i)){throw new TypeError('\"list\" argument must be an Array of Buffers')}i.copy(f,n);n+=i.length}return f};function byteLength(e,r){if(Buffer.isBuffer(e)){return e.length}if(ArrayBuffer.isView(e)||isInstance(e,ArrayBuffer)){return e.byteLength}if(typeof e!==\"string\"){throw new TypeError('The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. '+\"Received type \"+typeof e)}var t=e.length;var f=arguments.length>2&&arguments[2]===true;if(!f&&t===0)return 0;var n=false;for(;;){switch(r){case\"ascii\":case\"latin1\":case\"binary\":return t;case\"utf8\":case\"utf-8\":return utf8ToBytes(e).length;case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return t*2;case\"hex\":return t>>>1;case\"base64\":return base64ToBytes(e).length;default:if(n){return f?-1:utf8ToBytes(e).length}r=(\"\"+r).toLowerCase();n=true}}}Buffer.byteLength=byteLength;function slowToString(e,r,t){var f=false;if(r===undefined||r<0){r=0}if(r>this.length){return\"\"}if(t===undefined||t>this.length){t=this.length}if(t<=0){return\"\"}t>>>=0;r>>>=0;if(t<=r){return\"\"}if(!e)e=\"utf8\";while(true){switch(e){case\"hex\":return hexSlice(this,r,t);case\"utf8\":case\"utf-8\":return utf8Slice(this,r,t);case\"ascii\":return asciiSlice(this,r,t);case\"latin1\":case\"binary\":return latin1Slice(this,r,t);case\"base64\":return base64Slice(this,r,t);case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return utf16leSlice(this,r,t);default:if(f)throw new TypeError(\"Unknown encoding: \"+e);e=(e+\"\").toLowerCase();f=true}}}Buffer.prototype._isBuffer=true;function swap(e,r,t){var f=e[r];e[r]=e[t];e[t]=f}Buffer.prototype.swap16=function swap16(){var e=this.length;if(e%2!==0){throw new RangeError(\"Buffer size must be a multiple of 16-bits\")}for(var r=0;r<e;r+=2){swap(this,r,r+1)}return this};Buffer.prototype.swap32=function swap32(){var e=this.length;if(e%4!==0){throw new RangeError(\"Buffer size must be a multiple of 32-bits\")}for(var r=0;r<e;r+=4){swap(this,r,r+3);swap(this,r+1,r+2)}return this};Buffer.prototype.swap64=function swap64(){var e=this.length;if(e%8!==0){throw new RangeError(\"Buffer size must be a multiple of 64-bits\")}for(var r=0;r<e;r+=8){swap(this,r,r+7);swap(this,r+1,r+6);swap(this,r+2,r+5);swap(this,r+3,r+4)}return this};Buffer.prototype.toString=function toString(){var e=this.length;if(e===0)return\"\";if(arguments.length===0)return utf8Slice(this,0,e);return slowToString.apply(this,arguments)};Buffer.prototype.toLocaleString=Buffer.prototype.toString;Buffer.prototype.equals=function equals(e){if(!Buffer.isBuffer(e))throw new TypeError(\"Argument must be a Buffer\");if(this===e)return true;return Buffer.compare(this,e)===0};Buffer.prototype.inspect=function inspect(){var e=\"\";var t=r.INSPECT_MAX_BYTES;e=this.toString(\"hex\",0,t).replace(/(.{2})/g,\"$1 \").trim();if(this.length>t)e+=\" ... \";return\"<Buffer \"+e+\">\"};if(i){Buffer.prototype[i]=Buffer.prototype.inspect}Buffer.prototype.compare=function compare(e,r,t,f,n){if(isInstance(e,Uint8Array)){e=Buffer.from(e,e.offset,e.byteLength)}if(!Buffer.isBuffer(e)){throw new TypeError('The \"target\" argument must be one of type Buffer or Uint8Array. '+\"Received type \"+typeof e)}if(r===undefined){r=0}if(t===undefined){t=e?e.length:0}if(f===undefined){f=0}if(n===undefined){n=this.length}if(r<0||t>e.length||f<0||n>this.length){throw new RangeError(\"out of range index\")}if(f>=n&&r>=t){return 0}if(f>=n){return-1}if(r>=t){return 1}r>>>=0;t>>>=0;f>>>=0;n>>>=0;if(this===e)return 0;var i=n-f;var o=t-r;var u=Math.min(i,o);var a=this.slice(f,n);var s=e.slice(r,t);for(var h=0;h<u;++h){if(a[h]!==s[h]){i=a[h];o=s[h];break}}if(i<o)return-1;if(o<i)return 1;return 0};function bidirectionalIndexOf(e,r,t,f,n){if(e.length===0)return-1;if(typeof t===\"string\"){f=t;t=0}else if(t>2147483647){t=2147483647}else if(t<-2147483648){t=-2147483648}t=+t;if(numberIsNaN(t)){t=n?0:e.length-1}if(t<0)t=e.length+t;if(t>=e.length){if(n)return-1;else t=e.length-1}else if(t<0){if(n)t=0;else return-1}if(typeof r===\"string\"){r=Buffer.from(r,f)}if(Buffer.isBuffer(r)){if(r.length===0){return-1}return arrayIndexOf(e,r,t,f,n)}else if(typeof r===\"number\"){r=r&255;if(typeof Uint8Array.prototype.indexOf===\"function\"){if(n){return Uint8Array.prototype.indexOf.call(e,r,t)}else{return Uint8Array.prototype.lastIndexOf.call(e,r,t)}}return arrayIndexOf(e,[r],t,f,n)}throw new TypeError(\"val must be string, number or Buffer\")}function arrayIndexOf(e,r,t,f,n){var i=1;var o=e.length;var u=r.length;if(f!==undefined){f=String(f).toLowerCase();if(f===\"ucs2\"||f===\"ucs-2\"||f===\"utf16le\"||f===\"utf-16le\"){if(e.length<2||r.length<2){return-1}i=2;o/=2;u/=2;t/=2}}function read(e,r){if(i===1){return e[r]}else{return e.readUInt16BE(r*i)}}var a;if(n){var s=-1;for(a=t;a<o;a++){if(read(e,a)===read(r,s===-1?0:a-s)){if(s===-1)s=a;if(a-s+1===u)return s*i}else{if(s!==-1)a-=a-s;s=-1}}}else{if(t+u>o)t=o-u;for(a=t;a>=0;a--){var h=true;for(var c=0;c<u;c++){if(read(e,a+c)!==read(r,c)){h=false;break}}if(h)return a}}return-1}Buffer.prototype.includes=function includes(e,r,t){return this.indexOf(e,r,t)!==-1};Buffer.prototype.indexOf=function indexOf(e,r,t){return bidirectionalIndexOf(this,e,r,t,true)};Buffer.prototype.lastIndexOf=function lastIndexOf(e,r,t){return bidirectionalIndexOf(this,e,r,t,false)};function hexWrite(e,r,t,f){t=Number(t)||0;var n=e.length-t;if(!f){f=n}else{f=Number(f);if(f>n){f=n}}var i=r.length;if(f>i/2){f=i/2}for(var o=0;o<f;++o){var u=parseInt(r.substr(o*2,2),16);if(numberIsNaN(u))return o;e[t+o]=u}return o}function utf8Write(e,r,t,f){return blitBuffer(utf8ToBytes(r,e.length-t),e,t,f)}function asciiWrite(e,r,t,f){return blitBuffer(asciiToBytes(r),e,t,f)}function latin1Write(e,r,t,f){return asciiWrite(e,r,t,f)}function base64Write(e,r,t,f){return blitBuffer(base64ToBytes(r),e,t,f)}function ucs2Write(e,r,t,f){return blitBuffer(utf16leToBytes(r,e.length-t),e,t,f)}Buffer.prototype.write=function write(e,r,t,f){if(r===undefined){f=\"utf8\";t=this.length;r=0}else if(t===undefined&&typeof r===\"string\"){f=r;t=this.length;r=0}else if(isFinite(r)){r=r>>>0;if(isFinite(t)){t=t>>>0;if(f===undefined)f=\"utf8\"}else{f=t;t=undefined}}else{throw new Error(\"Buffer.write(string, encoding, offset[, length]) is no longer supported\")}var n=this.length-r;if(t===undefined||t>n)t=n;if(e.length>0&&(t<0||r<0)||r>this.length){throw new RangeError(\"Attempt to write outside buffer bounds\")}if(!f)f=\"utf8\";var i=false;for(;;){switch(f){case\"hex\":return hexWrite(this,e,r,t);case\"utf8\":case\"utf-8\":return utf8Write(this,e,r,t);case\"ascii\":return asciiWrite(this,e,r,t);case\"latin1\":case\"binary\":return latin1Write(this,e,r,t);case\"base64\":return base64Write(this,e,r,t);case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return ucs2Write(this,e,r,t);default:if(i)throw new TypeError(\"Unknown encoding: \"+f);f=(\"\"+f).toLowerCase();i=true}}};Buffer.prototype.toJSON=function toJSON(){return{type:\"Buffer\",data:Array.prototype.slice.call(this._arr||this,0)}};function base64Slice(e,r,t){if(r===0&&t===e.length){return f.fromByteArray(e)}else{return f.fromByteArray(e.slice(r,t))}}function utf8Slice(e,r,t){t=Math.min(e.length,t);var f=[];var n=r;while(n<t){var i=e[n];var o=null;var u=i>239?4:i>223?3:i>191?2:1;if(n+u<=t){var a,s,h,c;switch(u){case 1:if(i<128){o=i}break;case 2:a=e[n+1];if((a&192)===128){c=(i&31)<<6|a&63;if(c>127){o=c}}break;case 3:a=e[n+1];s=e[n+2];if((a&192)===128&&(s&192)===128){c=(i&15)<<12|(a&63)<<6|s&63;if(c>2047&&(c<55296||c>57343)){o=c}}break;case 4:a=e[n+1];s=e[n+2];h=e[n+3];if((a&192)===128&&(s&192)===128&&(h&192)===128){c=(i&15)<<18|(a&63)<<12|(s&63)<<6|h&63;if(c>65535&&c<1114112){o=c}}}}if(o===null){o=65533;u=1}else if(o>65535){o-=65536;f.push(o>>>10&1023|55296);o=56320|o&1023}f.push(o);n+=u}return decodeCodePointsArray(f)}var u=4096;function decodeCodePointsArray(e){var r=e.length;if(r<=u){return String.fromCharCode.apply(String,e)}var t=\"\";var f=0;while(f<r){t+=String.fromCharCode.apply(String,e.slice(f,f+=u))}return t}function asciiSlice(e,r,t){var f=\"\";t=Math.min(e.length,t);for(var n=r;n<t;++n){f+=String.fromCharCode(e[n]&127)}return f}function latin1Slice(e,r,t){var f=\"\";t=Math.min(e.length,t);for(var n=r;n<t;++n){f+=String.fromCharCode(e[n])}return f}function hexSlice(e,r,t){var f=e.length;if(!r||r<0)r=0;if(!t||t<0||t>f)t=f;var n=\"\";for(var i=r;i<t;++i){n+=s[e[i]]}return n}function utf16leSlice(e,r,t){var f=e.slice(r,t);var n=\"\";for(var i=0;i<f.length;i+=2){n+=String.fromCharCode(f[i]+f[i+1]*256)}return n}Buffer.prototype.slice=function slice(e,r){var t=this.length;e=~~e;r=r===undefined?t:~~r;if(e<0){e+=t;if(e<0)e=0}else if(e>t){e=t}if(r<0){r+=t;if(r<0)r=0}else if(r>t){r=t}if(r<e)r=e;var f=this.subarray(e,r);Object.setPrototypeOf(f,Buffer.prototype);return f};function checkOffset(e,r,t){if(e%1!==0||e<0)throw new RangeError(\"offset is not uint\");if(e+r>t)throw new RangeError(\"Trying to access beyond buffer length\")}Buffer.prototype.readUIntLE=function readUIntLE(e,r,t){e=e>>>0;r=r>>>0;if(!t)checkOffset(e,r,this.length);var f=this[e];var n=1;var i=0;while(++i<r&&(n*=256)){f+=this[e+i]*n}return f};Buffer.prototype.readUIntBE=function readUIntBE(e,r,t){e=e>>>0;r=r>>>0;if(!t){checkOffset(e,r,this.length)}var f=this[e+--r];var n=1;while(r>0&&(n*=256)){f+=this[e+--r]*n}return f};Buffer.prototype.readUInt8=function readUInt8(e,r){e=e>>>0;if(!r)checkOffset(e,1,this.length);return this[e]};Buffer.prototype.readUInt16LE=function readUInt16LE(e,r){e=e>>>0;if(!r)checkOffset(e,2,this.length);return this[e]|this[e+1]<<8};Buffer.prototype.readUInt16BE=function readUInt16BE(e,r){e=e>>>0;if(!r)checkOffset(e,2,this.length);return this[e]<<8|this[e+1]};Buffer.prototype.readUInt32LE=function readUInt32LE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return(this[e]|this[e+1]<<8|this[e+2]<<16)+this[e+3]*16777216};Buffer.prototype.readUInt32BE=function readUInt32BE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return this[e]*16777216+(this[e+1]<<16|this[e+2]<<8|this[e+3])};Buffer.prototype.readIntLE=function readIntLE(e,r,t){e=e>>>0;r=r>>>0;if(!t)checkOffset(e,r,this.length);var f=this[e];var n=1;var i=0;while(++i<r&&(n*=256)){f+=this[e+i]*n}n*=128;if(f>=n)f-=Math.pow(2,8*r);return f};Buffer.prototype.readIntBE=function readIntBE(e,r,t){e=e>>>0;r=r>>>0;if(!t)checkOffset(e,r,this.length);var f=r;var n=1;var i=this[e+--f];while(f>0&&(n*=256)){i+=this[e+--f]*n}n*=128;if(i>=n)i-=Math.pow(2,8*r);return i};Buffer.prototype.readInt8=function readInt8(e,r){e=e>>>0;if(!r)checkOffset(e,1,this.length);if(!(this[e]&128))return this[e];return(255-this[e]+1)*-1};Buffer.prototype.readInt16LE=function readInt16LE(e,r){e=e>>>0;if(!r)checkOffset(e,2,this.length);var t=this[e]|this[e+1]<<8;return t&32768?t|4294901760:t};Buffer.prototype.readInt16BE=function readInt16BE(e,r){e=e>>>0;if(!r)checkOffset(e,2,this.length);var t=this[e+1]|this[e]<<8;return t&32768?t|4294901760:t};Buffer.prototype.readInt32LE=function readInt32LE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24};Buffer.prototype.readInt32BE=function readInt32BE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]};Buffer.prototype.readFloatLE=function readFloatLE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return n.read(this,e,true,23,4)};Buffer.prototype.readFloatBE=function readFloatBE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return n.read(this,e,false,23,4)};Buffer.prototype.readDoubleLE=function readDoubleLE(e,r){e=e>>>0;if(!r)checkOffset(e,8,this.length);return n.read(this,e,true,52,8)};Buffer.prototype.readDoubleBE=function readDoubleBE(e,r){e=e>>>0;if(!r)checkOffset(e,8,this.length);return n.read(this,e,false,52,8)};function checkInt(e,r,t,f,n,i){if(!Buffer.isBuffer(e))throw new TypeError('\"buffer\" argument must be a Buffer instance');if(r>n||r<i)throw new RangeError('\"value\" argument is out of bounds');if(t+f>e.length)throw new RangeError(\"Index out of range\")}Buffer.prototype.writeUIntLE=function writeUIntLE(e,r,t,f){e=+e;r=r>>>0;t=t>>>0;if(!f){var n=Math.pow(2,8*t)-1;checkInt(this,e,r,t,n,0)}var i=1;var o=0;this[r]=e&255;while(++o<t&&(i*=256)){this[r+o]=e/i&255}return r+t};Buffer.prototype.writeUIntBE=function writeUIntBE(e,r,t,f){e=+e;r=r>>>0;t=t>>>0;if(!f){var n=Math.pow(2,8*t)-1;checkInt(this,e,r,t,n,0)}var i=t-1;var o=1;this[r+i]=e&255;while(--i>=0&&(o*=256)){this[r+i]=e/o&255}return r+t};Buffer.prototype.writeUInt8=function writeUInt8(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,1,255,0);this[r]=e&255;return r+1};Buffer.prototype.writeUInt16LE=function writeUInt16LE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,2,65535,0);this[r]=e&255;this[r+1]=e>>>8;return r+2};Buffer.prototype.writeUInt16BE=function writeUInt16BE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,2,65535,0);this[r]=e>>>8;this[r+1]=e&255;return r+2};Buffer.prototype.writeUInt32LE=function writeUInt32LE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,4,4294967295,0);this[r+3]=e>>>24;this[r+2]=e>>>16;this[r+1]=e>>>8;this[r]=e&255;return r+4};Buffer.prototype.writeUInt32BE=function writeUInt32BE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,4,4294967295,0);this[r]=e>>>24;this[r+1]=e>>>16;this[r+2]=e>>>8;this[r+3]=e&255;return r+4};Buffer.prototype.writeIntLE=function writeIntLE(e,r,t,f){e=+e;r=r>>>0;if(!f){var n=Math.pow(2,8*t-1);checkInt(this,e,r,t,n-1,-n)}var i=0;var o=1;var u=0;this[r]=e&255;while(++i<t&&(o*=256)){if(e<0&&u===0&&this[r+i-1]!==0){u=1}this[r+i]=(e/o>>0)-u&255}return r+t};Buffer.prototype.writeIntBE=function writeIntBE(e,r,t,f){e=+e;r=r>>>0;if(!f){var n=Math.pow(2,8*t-1);checkInt(this,e,r,t,n-1,-n)}var i=t-1;var o=1;var u=0;this[r+i]=e&255;while(--i>=0&&(o*=256)){if(e<0&&u===0&&this[r+i+1]!==0){u=1}this[r+i]=(e/o>>0)-u&255}return r+t};Buffer.prototype.writeInt8=function writeInt8(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,1,127,-128);if(e<0)e=255+e+1;this[r]=e&255;return r+1};Buffer.prototype.writeInt16LE=function writeInt16LE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,2,32767,-32768);this[r]=e&255;this[r+1]=e>>>8;return r+2};Buffer.prototype.writeInt16BE=function writeInt16BE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,2,32767,-32768);this[r]=e>>>8;this[r+1]=e&255;return r+2};Buffer.prototype.writeInt32LE=function writeInt32LE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,4,2147483647,-2147483648);this[r]=e&255;this[r+1]=e>>>8;this[r+2]=e>>>16;this[r+3]=e>>>24;return r+4};Buffer.prototype.writeInt32BE=function writeInt32BE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,4,2147483647,-2147483648);if(e<0)e=4294967295+e+1;this[r]=e>>>24;this[r+1]=e>>>16;this[r+2]=e>>>8;this[r+3]=e&255;return r+4};function checkIEEE754(e,r,t,f,n,i){if(t+f>e.length)throw new RangeError(\"Index out of range\");if(t<0)throw new RangeError(\"Index out of range\")}function writeFloat(e,r,t,f,i){r=+r;t=t>>>0;if(!i){checkIEEE754(e,r,t,4,34028234663852886e22,-34028234663852886e22)}n.write(e,r,t,f,23,4);return t+4}Buffer.prototype.writeFloatLE=function writeFloatLE(e,r,t){return writeFloat(this,e,r,true,t)};Buffer.prototype.writeFloatBE=function writeFloatBE(e,r,t){return writeFloat(this,e,r,false,t)};function writeDouble(e,r,t,f,i){r=+r;t=t>>>0;if(!i){checkIEEE754(e,r,t,8,17976931348623157e292,-17976931348623157e292)}n.write(e,r,t,f,52,8);return t+8}Buffer.prototype.writeDoubleLE=function writeDoubleLE(e,r,t){return writeDouble(this,e,r,true,t)};Buffer.prototype.writeDoubleBE=function writeDoubleBE(e,r,t){return writeDouble(this,e,r,false,t)};Buffer.prototype.copy=function copy(e,r,t,f){if(!Buffer.isBuffer(e))throw new TypeError(\"argument should be a Buffer\");if(!t)t=0;if(!f&&f!==0)f=this.length;if(r>=e.length)r=e.length;if(!r)r=0;if(f>0&&f<t)f=t;if(f===t)return 0;if(e.length===0||this.length===0)return 0;if(r<0){throw new RangeError(\"targetStart out of bounds\")}if(t<0||t>=this.length)throw new RangeError(\"Index out of range\");if(f<0)throw new RangeError(\"sourceEnd out of bounds\");if(f>this.length)f=this.length;if(e.length-r<f-t){f=e.length-r+t}var n=f-t;if(this===e&&typeof Uint8Array.prototype.copyWithin===\"function\"){this.copyWithin(r,t,f)}else if(this===e&&t<r&&r<f){for(var i=n-1;i>=0;--i){e[i+r]=this[i+t]}}else{Uint8Array.prototype.set.call(e,this.subarray(t,f),r)}return n};Buffer.prototype.fill=function fill(e,r,t,f){if(typeof e===\"string\"){if(typeof r===\"string\"){f=r;r=0;t=this.length}else if(typeof t===\"string\"){f=t;t=this.length}if(f!==undefined&&typeof f!==\"string\"){throw new TypeError(\"encoding must be a string\")}if(typeof f===\"string\"&&!Buffer.isEncoding(f)){throw new TypeError(\"Unknown encoding: \"+f)}if(e.length===1){var n=e.charCodeAt(0);if(f===\"utf8\"&&n<128||f===\"latin1\"){e=n}}}else if(typeof e===\"number\"){e=e&255}else if(typeof e===\"boolean\"){e=Number(e)}if(r<0||this.length<r||this.length<t){throw new RangeError(\"Out of range index\")}if(t<=r){return this}r=r>>>0;t=t===undefined?this.length:t>>>0;if(!e)e=0;var i;if(typeof e===\"number\"){for(i=r;i<t;++i){this[i]=e}}else{var o=Buffer.isBuffer(e)?e:Buffer.from(e,f);var u=o.length;if(u===0){throw new TypeError('The value \"'+e+'\" is invalid for argument \"value\"')}for(i=0;i<t-r;++i){this[i+r]=o[i%u]}}return this};var a=/[^+/0-9A-Za-z-_]/g;function base64clean(e){e=e.split(\"=\")[0];e=e.trim().replace(a,\"\");if(e.length<2)return\"\";while(e.length%4!==0){e=e+\"=\"}return e}function utf8ToBytes(e,r){r=r||Infinity;var t;var f=e.length;var n=null;var i=[];for(var o=0;o<f;++o){t=e.charCodeAt(o);if(t>55295&&t<57344){if(!n){if(t>56319){if((r-=3)>-1)i.push(239,191,189);continue}else if(o+1===f){if((r-=3)>-1)i.push(239,191,189);continue}n=t;continue}if(t<56320){if((r-=3)>-1)i.push(239,191,189);n=t;continue}t=(n-55296<<10|t-56320)+65536}else if(n){if((r-=3)>-1)i.push(239,191,189)}n=null;if(t<128){if((r-=1)<0)break;i.push(t)}else if(t<2048){if((r-=2)<0)break;i.push(t>>6|192,t&63|128)}else if(t<65536){if((r-=3)<0)break;i.push(t>>12|224,t>>6&63|128,t&63|128)}else if(t<1114112){if((r-=4)<0)break;i.push(t>>18|240,t>>12&63|128,t>>6&63|128,t&63|128)}else{throw new Error(\"Invalid code point\")}}return i}function asciiToBytes(e){var r=[];for(var t=0;t<e.length;++t){r.push(e.charCodeAt(t)&255)}return r}function utf16leToBytes(e,r){var t,f,n;var i=[];for(var o=0;o<e.length;++o){if((r-=2)<0)break;t=e.charCodeAt(o);f=t>>8;n=t%256;i.push(n);i.push(f)}return i}function base64ToBytes(e){return f.toByteArray(base64clean(e))}function blitBuffer(e,r,t,f){for(var n=0;n<f;++n){if(n+t>=r.length||n>=e.length)break;r[n+t]=e[n]}return n}function isInstance(e,r){return e instanceof r||e!=null&&e.constructor!=null&&e.constructor.name!=null&&e.constructor.name===r.name}function numberIsNaN(e){return e!==e}var s=function(){var e=\"0123456789abcdef\";var r=new Array(256);for(var t=0;t<16;++t){var f=t*16;for(var n=0;n<16;++n){r[f+n]=e[t]+e[n]}}return r}()},783:function(e,r){\n/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nr.read=function(e,r,t,f,n){var i,o;var u=n*8-f-1;var a=(1<<u)-1;var s=a>>1;var h=-7;var c=t?n-1:0;var l=t?-1:1;var p=e[r+c];c+=l;i=p&(1<<-h)-1;p>>=-h;h+=u;for(;h>0;i=i*256+e[r+c],c+=l,h-=8){}o=i&(1<<-h)-1;i>>=-h;h+=f;for(;h>0;o=o*256+e[r+c],c+=l,h-=8){}if(i===0){i=1-s}else if(i===a){return o?NaN:(p?-1:1)*Infinity}else{o=o+Math.pow(2,f);i=i-s}return(p?-1:1)*o*Math.pow(2,i-f)};r.write=function(e,r,t,f,n,i){var o,u,a;var s=i*8-n-1;var h=(1<<s)-1;var c=h>>1;var l=n===23?Math.pow(2,-24)-Math.pow(2,-77):0;var p=f?0:i-1;var y=f?1:-1;var g=r<0||r===0&&1/r<0?1:0;r=Math.abs(r);if(isNaN(r)||r===Infinity){u=isNaN(r)?1:0;o=h}else{o=Math.floor(Math.log(r)/Math.LN2);if(r*(a=Math.pow(2,-o))<1){o--;a*=2}if(o+c>=1){r+=l/a}else{r+=l*Math.pow(2,1-c)}if(r*a>=2){o++;a/=2}if(o+c>=h){u=0;o=h}else if(o+c>=1){u=(r*a-1)*Math.pow(2,n);o=o+c}else{u=r*Math.pow(2,c-1)*Math.pow(2,n);o=0}}for(;n>=8;e[t+p]=u&255,p+=y,u/=256,n-=8){}o=o<<n|u;s+=n;for(;s>0;e[t+p]=o&255,p+=y,o/=256,s-=8){}e[t+p-y]|=g*128}}};var r={};function __nccwpck_require__(t){var f=r[t];if(f!==undefined){return f.exports}var n=r[t]={exports:{}};var i=true;try{e[t](n,n.exports,__nccwpck_require__);i=false}finally{if(i)delete r[t]}return n.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var t=__nccwpck_require__(72);module.exports=t})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvYnVmZmVyL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7QUFBQSxZQUFZLE9BQU8sa0JBQWtCLGFBQWEsd0JBQXdCLDBCQUEwQiw4QkFBOEIsU0FBUyxTQUFTLHVEQUF1RCx5RUFBeUUsdUJBQXVCLElBQUksS0FBSyxVQUFVLHFCQUFxQix3QkFBd0Isd0JBQXdCLG9CQUFvQixlQUFlLFVBQVUsa0VBQWtFLHFCQUFxQixjQUFjLG9CQUFvQixZQUFZLHVCQUF1QixpQkFBaUIsV0FBVyxXQUFXLGtCQUFrQiw0QkFBNEIsa0JBQWtCLHdCQUF3QixNQUFNLGlCQUFpQixXQUFXLFdBQVcsZ0NBQWdDLFFBQVEsZ0JBQWdCLE1BQU0sUUFBUSxJQUFJLE1BQU0sK0ZBQStGLGlCQUFpQixnQkFBZ0IsYUFBYSxVQUFVLGdEQUFnRCxhQUFhLFVBQVUseUVBQXlFLGdCQUFnQixhQUFhLFNBQVMsNEJBQTRCLGtEQUFrRCw0QkFBNEIsTUFBTSxTQUFTLFlBQVksSUFBSSxNQUFNLHFEQUFxRCwyQkFBMkIsa0JBQWtCLDBCQUEwQixNQUFNLGVBQWUsVUFBVSxTQUFTLFlBQVksa0JBQWtCLElBQUksTUFBTSxxQ0FBcUMsVUFBVSxTQUFTLGdDQUFnQyxlQUFlLHFCQUFxQiwyQ0FBMkMsbUJBQW1CLG9CQUFvQjtBQUM5ckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhLCtHQUErRyxnQkFBZ0Isd0JBQXdCLHVCQUF1QixpQkFBaUIsZUFBZSwrQ0FBK0MsaUdBQWlHLGtLQUFrSyw2QkFBNkIsSUFBSSx3QkFBd0IsT0FBTyxlQUFlLFlBQVksOENBQThDLDJCQUEyQixvQkFBb0IsU0FBUyxjQUFjLGlEQUFpRCwrQkFBK0IsMkNBQTJDLG9CQUFvQixFQUFFLGlEQUFpRCwrQkFBK0IsMkNBQTJDLHdCQUF3QixFQUFFLHlCQUF5QixRQUFRLHVFQUF1RSx3QkFBd0IsMENBQTBDLFNBQVMs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Q0FBK0MsY0FBYyxhQUFhLDRCQUE0QixjQUFjLDJCQUEyQixlQUFlLElBQUksS0FBSyxtQ0FBbUMsMkJBQTJCLElBQUksS0FBSyxXQUFXLE9BQU8sS0FBSyxxQkFBcUIsV0FBVyxJQUFJLEtBQUssV0FBVyxJQUFJLElBQUksZ0JBQWdCLHdCQUF3QixNQUFNLEtBQUssa0NBQWtDLEtBQUssS0FBSyxLQUFLLGdDQUFnQyxTQUFTLEtBQUssS0FBSyxJQUFJLGdDQUFnQyxtQkFBbUIsU0FBUyxnQ0FBZ0MsV0FBVyxrQkFBa0IsaUJBQWlCLFlBQVksWUFBWSxXQUFXLElBQUksc0NBQXNDLFFBQVEsUUFBUSxpQkFBaUIsaUJBQWlCLG1FQUFtRSxTQUFTLEtBQUssOEJBQThCLGlCQUFpQiIsInNvdXJjZXMiOlsiL2hvbWUvbGZnL0dpdC9NYWR0cmlwcy9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2J1ZmZlci9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXt2YXIgZT17Njc1OmZ1bmN0aW9uKGUscil7XCJ1c2Ugc3RyaWN0XCI7ci5ieXRlTGVuZ3RoPWJ5dGVMZW5ndGg7ci50b0J5dGVBcnJheT10b0J5dGVBcnJheTtyLmZyb21CeXRlQXJyYXk9ZnJvbUJ5dGVBcnJheTt2YXIgdD1bXTt2YXIgZj1bXTt2YXIgbj10eXBlb2YgVWludDhBcnJheSE9PVwidW5kZWZpbmVkXCI/VWludDhBcnJheTpBcnJheTt2YXIgaT1cIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIjtmb3IodmFyIG89MCx1PWkubGVuZ3RoO288dTsrK28pe3Rbb109aVtvXTtmW2kuY2hhckNvZGVBdChvKV09b31mW1wiLVwiLmNoYXJDb2RlQXQoMCldPTYyO2ZbXCJfXCIuY2hhckNvZGVBdCgwKV09NjM7ZnVuY3Rpb24gZ2V0TGVucyhlKXt2YXIgcj1lLmxlbmd0aDtpZihyJTQ+MCl7dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNFwiKX12YXIgdD1lLmluZGV4T2YoXCI9XCIpO2lmKHQ9PT0tMSl0PXI7dmFyIGY9dD09PXI/MDo0LXQlNDtyZXR1cm5bdCxmXX1mdW5jdGlvbiBieXRlTGVuZ3RoKGUpe3ZhciByPWdldExlbnMoZSk7dmFyIHQ9clswXTt2YXIgZj1yWzFdO3JldHVybih0K2YpKjMvNC1mfWZ1bmN0aW9uIF9ieXRlTGVuZ3RoKGUscix0KXtyZXR1cm4ocit0KSozLzQtdH1mdW5jdGlvbiB0b0J5dGVBcnJheShlKXt2YXIgcjt2YXIgdD1nZXRMZW5zKGUpO3ZhciBpPXRbMF07dmFyIG89dFsxXTt2YXIgdT1uZXcgbihfYnl0ZUxlbmd0aChlLGksbykpO3ZhciBhPTA7dmFyIHM9bz4wP2ktNDppO3ZhciBoO2ZvcihoPTA7aDxzO2grPTQpe3I9ZltlLmNoYXJDb2RlQXQoaCldPDwxOHxmW2UuY2hhckNvZGVBdChoKzEpXTw8MTJ8ZltlLmNoYXJDb2RlQXQoaCsyKV08PDZ8ZltlLmNoYXJDb2RlQXQoaCszKV07dVthKytdPXI+PjE2JjI1NTt1W2ErK109cj4+OCYyNTU7dVthKytdPXImMjU1fWlmKG89PT0yKXtyPWZbZS5jaGFyQ29kZUF0KGgpXTw8MnxmW2UuY2hhckNvZGVBdChoKzEpXT4+NDt1W2ErK109ciYyNTV9aWYobz09PTEpe3I9ZltlLmNoYXJDb2RlQXQoaCldPDwxMHxmW2UuY2hhckNvZGVBdChoKzEpXTw8NHxmW2UuY2hhckNvZGVBdChoKzIpXT4+Mjt1W2ErK109cj4+OCYyNTU7dVthKytdPXImMjU1fXJldHVybiB1fWZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NChlKXtyZXR1cm4gdFtlPj4xOCY2M10rdFtlPj4xMiY2M10rdFtlPj42JjYzXSt0W2UmNjNdfWZ1bmN0aW9uIGVuY29kZUNodW5rKGUscix0KXt2YXIgZjt2YXIgbj1bXTtmb3IodmFyIGk9cjtpPHQ7aSs9Myl7Zj0oZVtpXTw8MTYmMTY3MTE2ODApKyhlW2krMV08PDgmNjUyODApKyhlW2krMl0mMjU1KTtuLnB1c2godHJpcGxldFRvQmFzZTY0KGYpKX1yZXR1cm4gbi5qb2luKFwiXCIpfWZ1bmN0aW9uIGZyb21CeXRlQXJyYXkoZSl7dmFyIHI7dmFyIGY9ZS5sZW5ndGg7dmFyIG49ZiUzO3ZhciBpPVtdO3ZhciBvPTE2MzgzO2Zvcih2YXIgdT0wLGE9Zi1uO3U8YTt1Kz1vKXtpLnB1c2goZW5jb2RlQ2h1bmsoZSx1LHUrbz5hP2E6dStvKSl9aWYobj09PTEpe3I9ZVtmLTFdO2kucHVzaCh0W3I+PjJdK3Rbcjw8NCY2M10rXCI9PVwiKX1lbHNlIGlmKG49PT0yKXtyPShlW2YtMl08PDgpK2VbZi0xXTtpLnB1c2godFtyPj4xMF0rdFtyPj40JjYzXSt0W3I8PDImNjNdK1wiPVwiKX1yZXR1cm4gaS5qb2luKFwiXCIpfX0sNzI6ZnVuY3Rpb24oZSxyLHQpe1widXNlIHN0cmljdFwiO1xuLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovdmFyIGY9dCg2NzUpO3ZhciBuPXQoNzgzKTt2YXIgaT10eXBlb2YgU3ltYm9sPT09XCJmdW5jdGlvblwiJiZ0eXBlb2YgU3ltYm9sLmZvcj09PVwiZnVuY3Rpb25cIj9TeW1ib2wuZm9yKFwibm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b21cIik6bnVsbDtyLkJ1ZmZlcj1CdWZmZXI7ci5TbG93QnVmZmVyPVNsb3dCdWZmZXI7ci5JTlNQRUNUX01BWF9CWVRFUz01MDt2YXIgbz0yMTQ3NDgzNjQ3O3Iua01heExlbmd0aD1vO0J1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUPXR5cGVkQXJyYXlTdXBwb3J0KCk7aWYoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUJiZ0eXBlb2YgY29uc29sZSE9PVwidW5kZWZpbmVkXCImJnR5cGVvZiBjb25zb2xlLmVycm9yPT09XCJmdW5jdGlvblwiKXtjb25zb2xlLmVycm9yKFwiVGhpcyBicm93c2VyIGxhY2tzIHR5cGVkIGFycmF5IChVaW50OEFycmF5KSBzdXBwb3J0IHdoaWNoIGlzIHJlcXVpcmVkIGJ5IFwiK1wiYGJ1ZmZlcmAgdjUueC4gVXNlIGBidWZmZXJgIHY0LnggaWYgeW91IHJlcXVpcmUgb2xkIGJyb3dzZXIgc3VwcG9ydC5cIil9ZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQoKXt0cnl7dmFyIGU9bmV3IFVpbnQ4QXJyYXkoMSk7dmFyIHI9e2ZvbzpmdW5jdGlvbigpe3JldHVybiA0Mn19O09iamVjdC5zZXRQcm90b3R5cGVPZihyLFVpbnQ4QXJyYXkucHJvdG90eXBlKTtPYmplY3Quc2V0UHJvdG90eXBlT2YoZSxyKTtyZXR1cm4gZS5mb28oKT09PTQyfWNhdGNoKGUpe3JldHVybiBmYWxzZX19T2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsXCJwYXJlbnRcIix7ZW51bWVyYWJsZTp0cnVlLGdldDpmdW5jdGlvbigpe2lmKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpcmV0dXJuIHVuZGVmaW5lZDtyZXR1cm4gdGhpcy5idWZmZXJ9fSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsXCJvZmZzZXRcIix7ZW51bWVyYWJsZTp0cnVlLGdldDpmdW5jdGlvbigpe2lmKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpcmV0dXJuIHVuZGVmaW5lZDtyZXR1cm4gdGhpcy5ieXRlT2Zmc2V0fX0pO2Z1bmN0aW9uIGNyZWF0ZUJ1ZmZlcihlKXtpZihlPm8pe3Rocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInK2UrJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpfXZhciByPW5ldyBVaW50OEFycmF5KGUpO09iamVjdC5zZXRQcm90b3R5cGVPZihyLEJ1ZmZlci5wcm90b3R5cGUpO3JldHVybiByfWZ1bmN0aW9uIEJ1ZmZlcihlLHIsdCl7aWYodHlwZW9mIGU9PT1cIm51bWJlclwiKXtpZih0eXBlb2Ygcj09PVwic3RyaW5nXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBzdHJpbmcuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJyl9cmV0dXJuIGFsbG9jVW5zYWZlKGUpfXJldHVybiBmcm9tKGUscix0KX1CdWZmZXIucG9vbFNpemU9ODE5MjtmdW5jdGlvbiBmcm9tKGUscix0KXtpZih0eXBlb2YgZT09PVwic3RyaW5nXCIpe3JldHVybiBmcm9tU3RyaW5nKGUscil9aWYoQXJyYXlCdWZmZXIuaXNWaWV3KGUpKXtyZXR1cm4gZnJvbUFycmF5TGlrZShlKX1pZihlPT1udWxsKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgXCIrXCJvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSBcIit0eXBlb2YgZSl9aWYoaXNJbnN0YW5jZShlLEFycmF5QnVmZmVyKXx8ZSYmaXNJbnN0YW5jZShlLmJ1ZmZlcixBcnJheUJ1ZmZlcikpe3JldHVybiBmcm9tQXJyYXlCdWZmZXIoZSxyLHQpfWlmKHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciE9PVwidW5kZWZpbmVkXCImJihpc0luc3RhbmNlKGUsU2hhcmVkQXJyYXlCdWZmZXIpfHxlJiZpc0luc3RhbmNlKGUuYnVmZmVyLFNoYXJlZEFycmF5QnVmZmVyKSkpe3JldHVybiBmcm9tQXJyYXlCdWZmZXIoZSxyLHQpfWlmKHR5cGVvZiBlPT09XCJudW1iZXJcIil7dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwidmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSBudW1iZXInKX12YXIgZj1lLnZhbHVlT2YmJmUudmFsdWVPZigpO2lmKGYhPW51bGwmJmYhPT1lKXtyZXR1cm4gQnVmZmVyLmZyb20oZixyLHQpfXZhciBuPWZyb21PYmplY3QoZSk7aWYobilyZXR1cm4gbjtpZih0eXBlb2YgU3ltYm9sIT09XCJ1bmRlZmluZWRcIiYmU3ltYm9sLnRvUHJpbWl0aXZlIT1udWxsJiZ0eXBlb2YgZVtTeW1ib2wudG9QcmltaXRpdmVdPT09XCJmdW5jdGlvblwiKXtyZXR1cm4gQnVmZmVyLmZyb20oZVtTeW1ib2wudG9QcmltaXRpdmVdKFwic3RyaW5nXCIpLHIsdCl9dGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIFwiK1wib3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgXCIrdHlwZW9mIGUpfUJ1ZmZlci5mcm9tPWZ1bmN0aW9uKGUscix0KXtyZXR1cm4gZnJvbShlLHIsdCl9O09iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIucHJvdG90eXBlLFVpbnQ4QXJyYXkucHJvdG90eXBlKTtPYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyLFVpbnQ4QXJyYXkpO2Z1bmN0aW9uIGFzc2VydFNpemUoZSl7aWYodHlwZW9mIGUhPT1cIm51bWJlclwiKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyJyl9ZWxzZSBpZihlPDApe3Rocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInK2UrJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpfX1mdW5jdGlvbiBhbGxvYyhlLHIsdCl7YXNzZXJ0U2l6ZShlKTtpZihlPD0wKXtyZXR1cm4gY3JlYXRlQnVmZmVyKGUpfWlmKHIhPT11bmRlZmluZWQpe3JldHVybiB0eXBlb2YgdD09PVwic3RyaW5nXCI/Y3JlYXRlQnVmZmVyKGUpLmZpbGwocix0KTpjcmVhdGVCdWZmZXIoZSkuZmlsbChyKX1yZXR1cm4gY3JlYXRlQnVmZmVyKGUpfUJ1ZmZlci5hbGxvYz1mdW5jdGlvbihlLHIsdCl7cmV0dXJuIGFsbG9jKGUscix0KX07ZnVuY3Rpb24gYWxsb2NVbnNhZmUoZSl7YXNzZXJ0U2l6ZShlKTtyZXR1cm4gY3JlYXRlQnVmZmVyKGU8MD8wOmNoZWNrZWQoZSl8MCl9QnVmZmVyLmFsbG9jVW5zYWZlPWZ1bmN0aW9uKGUpe3JldHVybiBhbGxvY1Vuc2FmZShlKX07QnVmZmVyLmFsbG9jVW5zYWZlU2xvdz1mdW5jdGlvbihlKXtyZXR1cm4gYWxsb2NVbnNhZmUoZSl9O2Z1bmN0aW9uIGZyb21TdHJpbmcoZSxyKXtpZih0eXBlb2YgciE9PVwic3RyaW5nXCJ8fHI9PT1cIlwiKXtyPVwidXRmOFwifWlmKCFCdWZmZXIuaXNFbmNvZGluZyhyKSl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gZW5jb2Rpbmc6IFwiK3IpfXZhciB0PWJ5dGVMZW5ndGgoZSxyKXwwO3ZhciBmPWNyZWF0ZUJ1ZmZlcih0KTt2YXIgbj1mLndyaXRlKGUscik7aWYobiE9PXQpe2Y9Zi5zbGljZSgwLG4pfXJldHVybiBmfWZ1bmN0aW9uIGZyb21BcnJheUxpa2UoZSl7dmFyIHI9ZS5sZW5ndGg8MD8wOmNoZWNrZWQoZS5sZW5ndGgpfDA7dmFyIHQ9Y3JlYXRlQnVmZmVyKHIpO2Zvcih2YXIgZj0wO2Y8cjtmKz0xKXt0W2ZdPWVbZl0mMjU1fXJldHVybiB0fWZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlcihlLHIsdCl7aWYocjwwfHxlLmJ5dGVMZW5ndGg8cil7dGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wib2Zmc2V0XCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJyl9aWYoZS5ieXRlTGVuZ3RoPHIrKHR8fDApKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJsZW5ndGhcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKX12YXIgZjtpZihyPT09dW5kZWZpbmVkJiZ0PT09dW5kZWZpbmVkKXtmPW5ldyBVaW50OEFycmF5KGUpfWVsc2UgaWYodD09PXVuZGVmaW5lZCl7Zj1uZXcgVWludDhBcnJheShlLHIpfWVsc2V7Zj1uZXcgVWludDhBcnJheShlLHIsdCl9T2JqZWN0LnNldFByb3RvdHlwZU9mKGYsQnVmZmVyLnByb3RvdHlwZSk7cmV0dXJuIGZ9ZnVuY3Rpb24gZnJvbU9iamVjdChlKXtpZihCdWZmZXIuaXNCdWZmZXIoZSkpe3ZhciByPWNoZWNrZWQoZS5sZW5ndGgpfDA7dmFyIHQ9Y3JlYXRlQnVmZmVyKHIpO2lmKHQubGVuZ3RoPT09MCl7cmV0dXJuIHR9ZS5jb3B5KHQsMCwwLHIpO3JldHVybiB0fWlmKGUubGVuZ3RoIT09dW5kZWZpbmVkKXtpZih0eXBlb2YgZS5sZW5ndGghPT1cIm51bWJlclwifHxudW1iZXJJc05hTihlLmxlbmd0aCkpe3JldHVybiBjcmVhdGVCdWZmZXIoMCl9cmV0dXJuIGZyb21BcnJheUxpa2UoZSl9aWYoZS50eXBlPT09XCJCdWZmZXJcIiYmQXJyYXkuaXNBcnJheShlLmRhdGEpKXtyZXR1cm4gZnJvbUFycmF5TGlrZShlLmRhdGEpfX1mdW5jdGlvbiBjaGVja2VkKGUpe2lmKGU+PW8pe3Rocm93IG5ldyBSYW5nZUVycm9yKFwiQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSBcIitcInNpemU6IDB4XCIrby50b1N0cmluZygxNikrXCIgYnl0ZXNcIil9cmV0dXJuIGV8MH1mdW5jdGlvbiBTbG93QnVmZmVyKGUpe2lmKCtlIT1lKXtlPTB9cmV0dXJuIEJ1ZmZlci5hbGxvYygrZSl9QnVmZmVyLmlzQnVmZmVyPWZ1bmN0aW9uIGlzQnVmZmVyKGUpe3JldHVybiBlIT1udWxsJiZlLl9pc0J1ZmZlcj09PXRydWUmJmUhPT1CdWZmZXIucHJvdG90eXBlfTtCdWZmZXIuY29tcGFyZT1mdW5jdGlvbiBjb21wYXJlKGUscil7aWYoaXNJbnN0YW5jZShlLFVpbnQ4QXJyYXkpKWU9QnVmZmVyLmZyb20oZSxlLm9mZnNldCxlLmJ5dGVMZW5ndGgpO2lmKGlzSW5zdGFuY2UocixVaW50OEFycmF5KSlyPUJ1ZmZlci5mcm9tKHIsci5vZmZzZXQsci5ieXRlTGVuZ3RoKTtpZighQnVmZmVyLmlzQnVmZmVyKGUpfHwhQnVmZmVyLmlzQnVmZmVyKHIpKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJidWYxXCIsIFwiYnVmMlwiIGFyZ3VtZW50cyBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5Jyl9aWYoZT09PXIpcmV0dXJuIDA7dmFyIHQ9ZS5sZW5ndGg7dmFyIGY9ci5sZW5ndGg7Zm9yKHZhciBuPTAsaT1NYXRoLm1pbih0LGYpO248aTsrK24pe2lmKGVbbl0hPT1yW25dKXt0PWVbbl07Zj1yW25dO2JyZWFrfX1pZih0PGYpcmV0dXJuLTE7aWYoZjx0KXJldHVybiAxO3JldHVybiAwfTtCdWZmZXIuaXNFbmNvZGluZz1mdW5jdGlvbiBpc0VuY29kaW5nKGUpe3N3aXRjaChTdHJpbmcoZSkudG9Mb3dlckNhc2UoKSl7Y2FzZVwiaGV4XCI6Y2FzZVwidXRmOFwiOmNhc2VcInV0Zi04XCI6Y2FzZVwiYXNjaWlcIjpjYXNlXCJsYXRpbjFcIjpjYXNlXCJiaW5hcnlcIjpjYXNlXCJiYXNlNjRcIjpjYXNlXCJ1Y3MyXCI6Y2FzZVwidWNzLTJcIjpjYXNlXCJ1dGYxNmxlXCI6Y2FzZVwidXRmLTE2bGVcIjpyZXR1cm4gdHJ1ZTtkZWZhdWx0OnJldHVybiBmYWxzZX19O0J1ZmZlci5jb25jYXQ9ZnVuY3Rpb24gY29uY2F0KGUscil7aWYoIUFycmF5LmlzQXJyYXkoZSkpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpfWlmKGUubGVuZ3RoPT09MCl7cmV0dXJuIEJ1ZmZlci5hbGxvYygwKX12YXIgdDtpZihyPT09dW5kZWZpbmVkKXtyPTA7Zm9yKHQ9MDt0PGUubGVuZ3RoOysrdCl7cis9ZVt0XS5sZW5ndGh9fXZhciBmPUJ1ZmZlci5hbGxvY1Vuc2FmZShyKTt2YXIgbj0wO2Zvcih0PTA7dDxlLmxlbmd0aDsrK3Qpe3ZhciBpPWVbdF07aWYoaXNJbnN0YW5jZShpLFVpbnQ4QXJyYXkpKXtpPUJ1ZmZlci5mcm9tKGkpfWlmKCFCdWZmZXIuaXNCdWZmZXIoaSkpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpfWkuY29weShmLG4pO24rPWkubGVuZ3RofXJldHVybiBmfTtmdW5jdGlvbiBieXRlTGVuZ3RoKGUscil7aWYoQnVmZmVyLmlzQnVmZmVyKGUpKXtyZXR1cm4gZS5sZW5ndGh9aWYoQXJyYXlCdWZmZXIuaXNWaWV3KGUpfHxpc0luc3RhbmNlKGUsQXJyYXlCdWZmZXIpKXtyZXR1cm4gZS5ieXRlTGVuZ3RofWlmKHR5cGVvZiBlIT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgb3IgQXJyYXlCdWZmZXIuICcrXCJSZWNlaXZlZCB0eXBlIFwiK3R5cGVvZiBlKX12YXIgdD1lLmxlbmd0aDt2YXIgZj1hcmd1bWVudHMubGVuZ3RoPjImJmFyZ3VtZW50c1syXT09PXRydWU7aWYoIWYmJnQ9PT0wKXJldHVybiAwO3ZhciBuPWZhbHNlO2Zvcig7Oyl7c3dpdGNoKHIpe2Nhc2VcImFzY2lpXCI6Y2FzZVwibGF0aW4xXCI6Y2FzZVwiYmluYXJ5XCI6cmV0dXJuIHQ7Y2FzZVwidXRmOFwiOmNhc2VcInV0Zi04XCI6cmV0dXJuIHV0ZjhUb0J5dGVzKGUpLmxlbmd0aDtjYXNlXCJ1Y3MyXCI6Y2FzZVwidWNzLTJcIjpjYXNlXCJ1dGYxNmxlXCI6Y2FzZVwidXRmLTE2bGVcIjpyZXR1cm4gdCoyO2Nhc2VcImhleFwiOnJldHVybiB0Pj4+MTtjYXNlXCJiYXNlNjRcIjpyZXR1cm4gYmFzZTY0VG9CeXRlcyhlKS5sZW5ndGg7ZGVmYXVsdDppZihuKXtyZXR1cm4gZj8tMTp1dGY4VG9CeXRlcyhlKS5sZW5ndGh9cj0oXCJcIityKS50b0xvd2VyQ2FzZSgpO249dHJ1ZX19fUJ1ZmZlci5ieXRlTGVuZ3RoPWJ5dGVMZW5ndGg7ZnVuY3Rpb24gc2xvd1RvU3RyaW5nKGUscix0KXt2YXIgZj1mYWxzZTtpZihyPT09dW5kZWZpbmVkfHxyPDApe3I9MH1pZihyPnRoaXMubGVuZ3RoKXtyZXR1cm5cIlwifWlmKHQ9PT11bmRlZmluZWR8fHQ+dGhpcy5sZW5ndGgpe3Q9dGhpcy5sZW5ndGh9aWYodDw9MCl7cmV0dXJuXCJcIn10Pj4+PTA7cj4+Pj0wO2lmKHQ8PXIpe3JldHVyblwiXCJ9aWYoIWUpZT1cInV0ZjhcIjt3aGlsZSh0cnVlKXtzd2l0Y2goZSl7Y2FzZVwiaGV4XCI6cmV0dXJuIGhleFNsaWNlKHRoaXMscix0KTtjYXNlXCJ1dGY4XCI6Y2FzZVwidXRmLThcIjpyZXR1cm4gdXRmOFNsaWNlKHRoaXMscix0KTtjYXNlXCJhc2NpaVwiOnJldHVybiBhc2NpaVNsaWNlKHRoaXMscix0KTtjYXNlXCJsYXRpbjFcIjpjYXNlXCJiaW5hcnlcIjpyZXR1cm4gbGF0aW4xU2xpY2UodGhpcyxyLHQpO2Nhc2VcImJhc2U2NFwiOnJldHVybiBiYXNlNjRTbGljZSh0aGlzLHIsdCk7Y2FzZVwidWNzMlwiOmNhc2VcInVjcy0yXCI6Y2FzZVwidXRmMTZsZVwiOmNhc2VcInV0Zi0xNmxlXCI6cmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLHIsdCk7ZGVmYXVsdDppZihmKXRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmtub3duIGVuY29kaW5nOiBcIitlKTtlPShlK1wiXCIpLnRvTG93ZXJDYXNlKCk7Zj10cnVlfX19QnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXI9dHJ1ZTtmdW5jdGlvbiBzd2FwKGUscix0KXt2YXIgZj1lW3JdO2Vbcl09ZVt0XTtlW3RdPWZ9QnVmZmVyLnByb3RvdHlwZS5zd2FwMTY9ZnVuY3Rpb24gc3dhcDE2KCl7dmFyIGU9dGhpcy5sZW5ndGg7aWYoZSUyIT09MCl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0c1wiKX1mb3IodmFyIHI9MDtyPGU7cis9Mil7c3dhcCh0aGlzLHIscisxKX1yZXR1cm4gdGhpc307QnVmZmVyLnByb3RvdHlwZS5zd2FwMzI9ZnVuY3Rpb24gc3dhcDMyKCl7dmFyIGU9dGhpcy5sZW5ndGg7aWYoZSU0IT09MCl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0c1wiKX1mb3IodmFyIHI9MDtyPGU7cis9NCl7c3dhcCh0aGlzLHIsciszKTtzd2FwKHRoaXMscisxLHIrMil9cmV0dXJuIHRoaXN9O0J1ZmZlci5wcm90b3R5cGUuc3dhcDY0PWZ1bmN0aW9uIHN3YXA2NCgpe3ZhciBlPXRoaXMubGVuZ3RoO2lmKGUlOCE9PTApe3Rocm93IG5ldyBSYW5nZUVycm9yKFwiQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHNcIil9Zm9yKHZhciByPTA7cjxlO3IrPTgpe3N3YXAodGhpcyxyLHIrNyk7c3dhcCh0aGlzLHIrMSxyKzYpO3N3YXAodGhpcyxyKzIscis1KTtzd2FwKHRoaXMsciszLHIrNCl9cmV0dXJuIHRoaXN9O0J1ZmZlci5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24gdG9TdHJpbmcoKXt2YXIgZT10aGlzLmxlbmd0aDtpZihlPT09MClyZXR1cm5cIlwiO2lmKGFyZ3VtZW50cy5sZW5ndGg9PT0wKXJldHVybiB1dGY4U2xpY2UodGhpcywwLGUpO3JldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcyxhcmd1bWVudHMpfTtCdWZmZXIucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nPUJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmc7QnVmZmVyLnByb3RvdHlwZS5lcXVhbHM9ZnVuY3Rpb24gZXF1YWxzKGUpe2lmKCFCdWZmZXIuaXNCdWZmZXIoZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXJcIik7aWYodGhpcz09PWUpcmV0dXJuIHRydWU7cmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsZSk9PT0wfTtCdWZmZXIucHJvdG90eXBlLmluc3BlY3Q9ZnVuY3Rpb24gaW5zcGVjdCgpe3ZhciBlPVwiXCI7dmFyIHQ9ci5JTlNQRUNUX01BWF9CWVRFUztlPXRoaXMudG9TdHJpbmcoXCJoZXhcIiwwLHQpLnJlcGxhY2UoLyguezJ9KS9nLFwiJDEgXCIpLnRyaW0oKTtpZih0aGlzLmxlbmd0aD50KWUrPVwiIC4uLiBcIjtyZXR1cm5cIjxCdWZmZXIgXCIrZStcIj5cIn07aWYoaSl7QnVmZmVyLnByb3RvdHlwZVtpXT1CdWZmZXIucHJvdG90eXBlLmluc3BlY3R9QnVmZmVyLnByb3RvdHlwZS5jb21wYXJlPWZ1bmN0aW9uIGNvbXBhcmUoZSxyLHQsZixuKXtpZihpc0luc3RhbmNlKGUsVWludDhBcnJheSkpe2U9QnVmZmVyLmZyb20oZSxlLm9mZnNldCxlLmJ5dGVMZW5ndGgpfWlmKCFCdWZmZXIuaXNCdWZmZXIoZSkpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInRhcmdldFwiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXkuICcrXCJSZWNlaXZlZCB0eXBlIFwiK3R5cGVvZiBlKX1pZihyPT09dW5kZWZpbmVkKXtyPTB9aWYodD09PXVuZGVmaW5lZCl7dD1lP2UubGVuZ3RoOjB9aWYoZj09PXVuZGVmaW5lZCl7Zj0wfWlmKG49PT11bmRlZmluZWQpe249dGhpcy5sZW5ndGh9aWYocjwwfHx0PmUubGVuZ3RofHxmPDB8fG4+dGhpcy5sZW5ndGgpe3Rocm93IG5ldyBSYW5nZUVycm9yKFwib3V0IG9mIHJhbmdlIGluZGV4XCIpfWlmKGY+PW4mJnI+PXQpe3JldHVybiAwfWlmKGY+PW4pe3JldHVybi0xfWlmKHI+PXQpe3JldHVybiAxfXI+Pj49MDt0Pj4+PTA7Zj4+Pj0wO24+Pj49MDtpZih0aGlzPT09ZSlyZXR1cm4gMDt2YXIgaT1uLWY7dmFyIG89dC1yO3ZhciB1PU1hdGgubWluKGksbyk7dmFyIGE9dGhpcy5zbGljZShmLG4pO3ZhciBzPWUuc2xpY2Uocix0KTtmb3IodmFyIGg9MDtoPHU7KytoKXtpZihhW2hdIT09c1toXSl7aT1hW2hdO289c1toXTticmVha319aWYoaTxvKXJldHVybi0xO2lmKG88aSlyZXR1cm4gMTtyZXR1cm4gMH07ZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YoZSxyLHQsZixuKXtpZihlLmxlbmd0aD09PTApcmV0dXJuLTE7aWYodHlwZW9mIHQ9PT1cInN0cmluZ1wiKXtmPXQ7dD0wfWVsc2UgaWYodD4yMTQ3NDgzNjQ3KXt0PTIxNDc0ODM2NDd9ZWxzZSBpZih0PC0yMTQ3NDgzNjQ4KXt0PS0yMTQ3NDgzNjQ4fXQ9K3Q7aWYobnVtYmVySXNOYU4odCkpe3Q9bj8wOmUubGVuZ3RoLTF9aWYodDwwKXQ9ZS5sZW5ndGgrdDtpZih0Pj1lLmxlbmd0aCl7aWYobilyZXR1cm4tMTtlbHNlIHQ9ZS5sZW5ndGgtMX1lbHNlIGlmKHQ8MCl7aWYobil0PTA7ZWxzZSByZXR1cm4tMX1pZih0eXBlb2Ygcj09PVwic3RyaW5nXCIpe3I9QnVmZmVyLmZyb20ocixmKX1pZihCdWZmZXIuaXNCdWZmZXIocikpe2lmKHIubGVuZ3RoPT09MCl7cmV0dXJuLTF9cmV0dXJuIGFycmF5SW5kZXhPZihlLHIsdCxmLG4pfWVsc2UgaWYodHlwZW9mIHI9PT1cIm51bWJlclwiKXtyPXImMjU1O2lmKHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mPT09XCJmdW5jdGlvblwiKXtpZihuKXtyZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGUscix0KX1lbHNle3JldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGUscix0KX19cmV0dXJuIGFycmF5SW5kZXhPZihlLFtyXSx0LGYsbil9dGhyb3cgbmV3IFR5cGVFcnJvcihcInZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlclwiKX1mdW5jdGlvbiBhcnJheUluZGV4T2YoZSxyLHQsZixuKXt2YXIgaT0xO3ZhciBvPWUubGVuZ3RoO3ZhciB1PXIubGVuZ3RoO2lmKGYhPT11bmRlZmluZWQpe2Y9U3RyaW5nKGYpLnRvTG93ZXJDYXNlKCk7aWYoZj09PVwidWNzMlwifHxmPT09XCJ1Y3MtMlwifHxmPT09XCJ1dGYxNmxlXCJ8fGY9PT1cInV0Zi0xNmxlXCIpe2lmKGUubGVuZ3RoPDJ8fHIubGVuZ3RoPDIpe3JldHVybi0xfWk9MjtvLz0yO3UvPTI7dC89Mn19ZnVuY3Rpb24gcmVhZChlLHIpe2lmKGk9PT0xKXtyZXR1cm4gZVtyXX1lbHNle3JldHVybiBlLnJlYWRVSW50MTZCRShyKmkpfX12YXIgYTtpZihuKXt2YXIgcz0tMTtmb3IoYT10O2E8bzthKyspe2lmKHJlYWQoZSxhKT09PXJlYWQocixzPT09LTE/MDphLXMpKXtpZihzPT09LTEpcz1hO2lmKGEtcysxPT09dSlyZXR1cm4gcyppfWVsc2V7aWYocyE9PS0xKWEtPWEtcztzPS0xfX19ZWxzZXtpZih0K3U+byl0PW8tdTtmb3IoYT10O2E+PTA7YS0tKXt2YXIgaD10cnVlO2Zvcih2YXIgYz0wO2M8dTtjKyspe2lmKHJlYWQoZSxhK2MpIT09cmVhZChyLGMpKXtoPWZhbHNlO2JyZWFrfX1pZihoKXJldHVybiBhfX1yZXR1cm4tMX1CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzPWZ1bmN0aW9uIGluY2x1ZGVzKGUscix0KXtyZXR1cm4gdGhpcy5pbmRleE9mKGUscix0KSE9PS0xfTtCdWZmZXIucHJvdG90eXBlLmluZGV4T2Y9ZnVuY3Rpb24gaW5kZXhPZihlLHIsdCl7cmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsZSxyLHQsdHJ1ZSl9O0J1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2Y9ZnVuY3Rpb24gbGFzdEluZGV4T2YoZSxyLHQpe3JldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLGUscix0LGZhbHNlKX07ZnVuY3Rpb24gaGV4V3JpdGUoZSxyLHQsZil7dD1OdW1iZXIodCl8fDA7dmFyIG49ZS5sZW5ndGgtdDtpZighZil7Zj1ufWVsc2V7Zj1OdW1iZXIoZik7aWYoZj5uKXtmPW59fXZhciBpPXIubGVuZ3RoO2lmKGY+aS8yKXtmPWkvMn1mb3IodmFyIG89MDtvPGY7KytvKXt2YXIgdT1wYXJzZUludChyLnN1YnN0cihvKjIsMiksMTYpO2lmKG51bWJlcklzTmFOKHUpKXJldHVybiBvO2VbdCtvXT11fXJldHVybiBvfWZ1bmN0aW9uIHV0ZjhXcml0ZShlLHIsdCxmKXtyZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhyLGUubGVuZ3RoLXQpLGUsdCxmKX1mdW5jdGlvbiBhc2NpaVdyaXRlKGUscix0LGYpe3JldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhyKSxlLHQsZil9ZnVuY3Rpb24gbGF0aW4xV3JpdGUoZSxyLHQsZil7cmV0dXJuIGFzY2lpV3JpdGUoZSxyLHQsZil9ZnVuY3Rpb24gYmFzZTY0V3JpdGUoZSxyLHQsZil7cmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhyKSxlLHQsZil9ZnVuY3Rpb24gdWNzMldyaXRlKGUscix0LGYpe3JldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHIsZS5sZW5ndGgtdCksZSx0LGYpfUJ1ZmZlci5wcm90b3R5cGUud3JpdGU9ZnVuY3Rpb24gd3JpdGUoZSxyLHQsZil7aWYocj09PXVuZGVmaW5lZCl7Zj1cInV0ZjhcIjt0PXRoaXMubGVuZ3RoO3I9MH1lbHNlIGlmKHQ9PT11bmRlZmluZWQmJnR5cGVvZiByPT09XCJzdHJpbmdcIil7Zj1yO3Q9dGhpcy5sZW5ndGg7cj0wfWVsc2UgaWYoaXNGaW5pdGUocikpe3I9cj4+PjA7aWYoaXNGaW5pdGUodCkpe3Q9dD4+PjA7aWYoZj09PXVuZGVmaW5lZClmPVwidXRmOFwifWVsc2V7Zj10O3Q9dW5kZWZpbmVkfX1lbHNle3Rocm93IG5ldyBFcnJvcihcIkJ1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkXCIpfXZhciBuPXRoaXMubGVuZ3RoLXI7aWYodD09PXVuZGVmaW5lZHx8dD5uKXQ9bjtpZihlLmxlbmd0aD4wJiYodDwwfHxyPDApfHxyPnRoaXMubGVuZ3RoKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkF0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzXCIpfWlmKCFmKWY9XCJ1dGY4XCI7dmFyIGk9ZmFsc2U7Zm9yKDs7KXtzd2l0Y2goZil7Y2FzZVwiaGV4XCI6cmV0dXJuIGhleFdyaXRlKHRoaXMsZSxyLHQpO2Nhc2VcInV0ZjhcIjpjYXNlXCJ1dGYtOFwiOnJldHVybiB1dGY4V3JpdGUodGhpcyxlLHIsdCk7Y2FzZVwiYXNjaWlcIjpyZXR1cm4gYXNjaWlXcml0ZSh0aGlzLGUscix0KTtjYXNlXCJsYXRpbjFcIjpjYXNlXCJiaW5hcnlcIjpyZXR1cm4gbGF0aW4xV3JpdGUodGhpcyxlLHIsdCk7Y2FzZVwiYmFzZTY0XCI6cmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsZSxyLHQpO2Nhc2VcInVjczJcIjpjYXNlXCJ1Y3MtMlwiOmNhc2VcInV0ZjE2bGVcIjpjYXNlXCJ1dGYtMTZsZVwiOnJldHVybiB1Y3MyV3JpdGUodGhpcyxlLHIsdCk7ZGVmYXVsdDppZihpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmtub3duIGVuY29kaW5nOiBcIitmKTtmPShcIlwiK2YpLnRvTG93ZXJDYXNlKCk7aT10cnVlfX19O0J1ZmZlci5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uIHRvSlNPTigpe3JldHVybnt0eXBlOlwiQnVmZmVyXCIsZGF0YTpBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnJ8fHRoaXMsMCl9fTtmdW5jdGlvbiBiYXNlNjRTbGljZShlLHIsdCl7aWYocj09PTAmJnQ9PT1lLmxlbmd0aCl7cmV0dXJuIGYuZnJvbUJ5dGVBcnJheShlKX1lbHNle3JldHVybiBmLmZyb21CeXRlQXJyYXkoZS5zbGljZShyLHQpKX19ZnVuY3Rpb24gdXRmOFNsaWNlKGUscix0KXt0PU1hdGgubWluKGUubGVuZ3RoLHQpO3ZhciBmPVtdO3ZhciBuPXI7d2hpbGUobjx0KXt2YXIgaT1lW25dO3ZhciBvPW51bGw7dmFyIHU9aT4yMzk/NDppPjIyMz8zOmk+MTkxPzI6MTtpZihuK3U8PXQpe3ZhciBhLHMsaCxjO3N3aXRjaCh1KXtjYXNlIDE6aWYoaTwxMjgpe289aX1icmVhaztjYXNlIDI6YT1lW24rMV07aWYoKGEmMTkyKT09PTEyOCl7Yz0oaSYzMSk8PDZ8YSY2MztpZihjPjEyNyl7bz1jfX1icmVhaztjYXNlIDM6YT1lW24rMV07cz1lW24rMl07aWYoKGEmMTkyKT09PTEyOCYmKHMmMTkyKT09PTEyOCl7Yz0oaSYxNSk8PDEyfChhJjYzKTw8NnxzJjYzO2lmKGM+MjA0NyYmKGM8NTUyOTZ8fGM+NTczNDMpKXtvPWN9fWJyZWFrO2Nhc2UgNDphPWVbbisxXTtzPWVbbisyXTtoPWVbbiszXTtpZigoYSYxOTIpPT09MTI4JiYocyYxOTIpPT09MTI4JiYoaCYxOTIpPT09MTI4KXtjPShpJjE1KTw8MTh8KGEmNjMpPDwxMnwocyY2Myk8PDZ8aCY2MztpZihjPjY1NTM1JiZjPDExMTQxMTIpe289Y319fX1pZihvPT09bnVsbCl7bz02NTUzMzt1PTF9ZWxzZSBpZihvPjY1NTM1KXtvLT02NTUzNjtmLnB1c2gobz4+PjEwJjEwMjN8NTUyOTYpO289NTYzMjB8byYxMDIzfWYucHVzaChvKTtuKz11fXJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkoZil9dmFyIHU9NDA5NjtmdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkoZSl7dmFyIHI9ZS5sZW5ndGg7aWYocjw9dSl7cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLGUpfXZhciB0PVwiXCI7dmFyIGY9MDt3aGlsZShmPHIpe3QrPVN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLGUuc2xpY2UoZixmKz11KSl9cmV0dXJuIHR9ZnVuY3Rpb24gYXNjaWlTbGljZShlLHIsdCl7dmFyIGY9XCJcIjt0PU1hdGgubWluKGUubGVuZ3RoLHQpO2Zvcih2YXIgbj1yO248dDsrK24pe2YrPVN0cmluZy5mcm9tQ2hhckNvZGUoZVtuXSYxMjcpfXJldHVybiBmfWZ1bmN0aW9uIGxhdGluMVNsaWNlKGUscix0KXt2YXIgZj1cIlwiO3Q9TWF0aC5taW4oZS5sZW5ndGgsdCk7Zm9yKHZhciBuPXI7bjx0Oysrbil7Zis9U3RyaW5nLmZyb21DaGFyQ29kZShlW25dKX1yZXR1cm4gZn1mdW5jdGlvbiBoZXhTbGljZShlLHIsdCl7dmFyIGY9ZS5sZW5ndGg7aWYoIXJ8fHI8MClyPTA7aWYoIXR8fHQ8MHx8dD5mKXQ9Zjt2YXIgbj1cIlwiO2Zvcih2YXIgaT1yO2k8dDsrK2kpe24rPXNbZVtpXV19cmV0dXJuIG59ZnVuY3Rpb24gdXRmMTZsZVNsaWNlKGUscix0KXt2YXIgZj1lLnNsaWNlKHIsdCk7dmFyIG49XCJcIjtmb3IodmFyIGk9MDtpPGYubGVuZ3RoO2krPTIpe24rPVN0cmluZy5mcm9tQ2hhckNvZGUoZltpXStmW2krMV0qMjU2KX1yZXR1cm4gbn1CdWZmZXIucHJvdG90eXBlLnNsaWNlPWZ1bmN0aW9uIHNsaWNlKGUscil7dmFyIHQ9dGhpcy5sZW5ndGg7ZT1+fmU7cj1yPT09dW5kZWZpbmVkP3Q6fn5yO2lmKGU8MCl7ZSs9dDtpZihlPDApZT0wfWVsc2UgaWYoZT50KXtlPXR9aWYocjwwKXtyKz10O2lmKHI8MClyPTB9ZWxzZSBpZihyPnQpe3I9dH1pZihyPGUpcj1lO3ZhciBmPXRoaXMuc3ViYXJyYXkoZSxyKTtPYmplY3Quc2V0UHJvdG90eXBlT2YoZixCdWZmZXIucHJvdG90eXBlKTtyZXR1cm4gZn07ZnVuY3Rpb24gY2hlY2tPZmZzZXQoZSxyLHQpe2lmKGUlMSE9PTB8fGU8MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIm9mZnNldCBpcyBub3QgdWludFwiKTtpZihlK3I+dCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGhcIil9QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFPWZ1bmN0aW9uIHJlYWRVSW50TEUoZSxyLHQpe2U9ZT4+PjA7cj1yPj4+MDtpZighdCljaGVja09mZnNldChlLHIsdGhpcy5sZW5ndGgpO3ZhciBmPXRoaXNbZV07dmFyIG49MTt2YXIgaT0wO3doaWxlKCsraTxyJiYobio9MjU2KSl7Zis9dGhpc1tlK2ldKm59cmV0dXJuIGZ9O0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRT1mdW5jdGlvbiByZWFkVUludEJFKGUscix0KXtlPWU+Pj4wO3I9cj4+PjA7aWYoIXQpe2NoZWNrT2Zmc2V0KGUscix0aGlzLmxlbmd0aCl9dmFyIGY9dGhpc1tlKy0tcl07dmFyIG49MTt3aGlsZShyPjAmJihuKj0yNTYpKXtmKz10aGlzW2UrLS1yXSpufXJldHVybiBmfTtCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OD1mdW5jdGlvbiByZWFkVUludDgoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsMSx0aGlzLmxlbmd0aCk7cmV0dXJuIHRoaXNbZV19O0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFPWZ1bmN0aW9uIHJlYWRVSW50MTZMRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSwyLHRoaXMubGVuZ3RoKTtyZXR1cm4gdGhpc1tlXXx0aGlzW2UrMV08PDh9O0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFPWZ1bmN0aW9uIHJlYWRVSW50MTZCRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSwyLHRoaXMubGVuZ3RoKTtyZXR1cm4gdGhpc1tlXTw8OHx0aGlzW2UrMV19O0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFPWZ1bmN0aW9uIHJlYWRVSW50MzJMRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSw0LHRoaXMubGVuZ3RoKTtyZXR1cm4odGhpc1tlXXx0aGlzW2UrMV08PDh8dGhpc1tlKzJdPDwxNikrdGhpc1tlKzNdKjE2Nzc3MjE2fTtCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRT1mdW5jdGlvbiByZWFkVUludDMyQkUoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsNCx0aGlzLmxlbmd0aCk7cmV0dXJuIHRoaXNbZV0qMTY3NzcyMTYrKHRoaXNbZSsxXTw8MTZ8dGhpc1tlKzJdPDw4fHRoaXNbZSszXSl9O0J1ZmZlci5wcm90b3R5cGUucmVhZEludExFPWZ1bmN0aW9uIHJlYWRJbnRMRShlLHIsdCl7ZT1lPj4+MDtyPXI+Pj4wO2lmKCF0KWNoZWNrT2Zmc2V0KGUscix0aGlzLmxlbmd0aCk7dmFyIGY9dGhpc1tlXTt2YXIgbj0xO3ZhciBpPTA7d2hpbGUoKytpPHImJihuKj0yNTYpKXtmKz10aGlzW2UraV0qbn1uKj0xMjg7aWYoZj49bilmLT1NYXRoLnBvdygyLDgqcik7cmV0dXJuIGZ9O0J1ZmZlci5wcm90b3R5cGUucmVhZEludEJFPWZ1bmN0aW9uIHJlYWRJbnRCRShlLHIsdCl7ZT1lPj4+MDtyPXI+Pj4wO2lmKCF0KWNoZWNrT2Zmc2V0KGUscix0aGlzLmxlbmd0aCk7dmFyIGY9cjt2YXIgbj0xO3ZhciBpPXRoaXNbZSstLWZdO3doaWxlKGY+MCYmKG4qPTI1Nikpe2krPXRoaXNbZSstLWZdKm59bio9MTI4O2lmKGk+PW4paS09TWF0aC5wb3coMiw4KnIpO3JldHVybiBpfTtCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4PWZ1bmN0aW9uIHJlYWRJbnQ4KGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDEsdGhpcy5sZW5ndGgpO2lmKCEodGhpc1tlXSYxMjgpKXJldHVybiB0aGlzW2VdO3JldHVybigyNTUtdGhpc1tlXSsxKSotMX07QnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRT1mdW5jdGlvbiByZWFkSW50MTZMRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSwyLHRoaXMubGVuZ3RoKTt2YXIgdD10aGlzW2VdfHRoaXNbZSsxXTw8ODtyZXR1cm4gdCYzMjc2OD90fDQyOTQ5MDE3NjA6dH07QnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRT1mdW5jdGlvbiByZWFkSW50MTZCRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSwyLHRoaXMubGVuZ3RoKTt2YXIgdD10aGlzW2UrMV18dGhpc1tlXTw8ODtyZXR1cm4gdCYzMjc2OD90fDQyOTQ5MDE3NjA6dH07QnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRT1mdW5jdGlvbiByZWFkSW50MzJMRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSw0LHRoaXMubGVuZ3RoKTtyZXR1cm4gdGhpc1tlXXx0aGlzW2UrMV08PDh8dGhpc1tlKzJdPDwxNnx0aGlzW2UrM108PDI0fTtCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFPWZ1bmN0aW9uIHJlYWRJbnQzMkJFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDQsdGhpcy5sZW5ndGgpO3JldHVybiB0aGlzW2VdPDwyNHx0aGlzW2UrMV08PDE2fHRoaXNbZSsyXTw8OHx0aGlzW2UrM119O0J1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEU9ZnVuY3Rpb24gcmVhZEZsb2F0TEUoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsNCx0aGlzLmxlbmd0aCk7cmV0dXJuIG4ucmVhZCh0aGlzLGUsdHJ1ZSwyMyw0KX07QnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRT1mdW5jdGlvbiByZWFkRmxvYXRCRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSw0LHRoaXMubGVuZ3RoKTtyZXR1cm4gbi5yZWFkKHRoaXMsZSxmYWxzZSwyMyw0KX07QnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEU9ZnVuY3Rpb24gcmVhZERvdWJsZUxFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDgsdGhpcy5sZW5ndGgpO3JldHVybiBuLnJlYWQodGhpcyxlLHRydWUsNTIsOCl9O0J1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFPWZ1bmN0aW9uIHJlYWREb3VibGVCRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSw4LHRoaXMubGVuZ3RoKTtyZXR1cm4gbi5yZWFkKHRoaXMsZSxmYWxzZSw1Miw4KX07ZnVuY3Rpb24gY2hlY2tJbnQoZSxyLHQsZixuLGkpe2lmKCFCdWZmZXIuaXNCdWZmZXIoZSkpdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJyk7aWYocj5ufHxyPGkpdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJyk7aWYodCtmPmUubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggb3V0IG9mIHJhbmdlXCIpfUJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEU9ZnVuY3Rpb24gd3JpdGVVSW50TEUoZSxyLHQsZil7ZT0rZTtyPXI+Pj4wO3Q9dD4+PjA7aWYoIWYpe3ZhciBuPU1hdGgucG93KDIsOCp0KS0xO2NoZWNrSW50KHRoaXMsZSxyLHQsbiwwKX12YXIgaT0xO3ZhciBvPTA7dGhpc1tyXT1lJjI1NTt3aGlsZSgrK288dCYmKGkqPTI1Nikpe3RoaXNbcitvXT1lL2kmMjU1fXJldHVybiByK3R9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkU9ZnVuY3Rpb24gd3JpdGVVSW50QkUoZSxyLHQsZil7ZT0rZTtyPXI+Pj4wO3Q9dD4+PjA7aWYoIWYpe3ZhciBuPU1hdGgucG93KDIsOCp0KS0xO2NoZWNrSW50KHRoaXMsZSxyLHQsbiwwKX12YXIgaT10LTE7dmFyIG89MTt0aGlzW3IraV09ZSYyNTU7d2hpbGUoLS1pPj0wJiYobyo9MjU2KSl7dGhpc1tyK2ldPWUvbyYyNTV9cmV0dXJuIHIrdH07QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4PWZ1bmN0aW9uIHdyaXRlVUludDgoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciwxLDI1NSwwKTt0aGlzW3JdPWUmMjU1O3JldHVybiByKzF9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRT1mdW5jdGlvbiB3cml0ZVVJbnQxNkxFKGUscix0KXtlPStlO3I9cj4+PjA7aWYoIXQpY2hlY2tJbnQodGhpcyxlLHIsMiw2NTUzNSwwKTt0aGlzW3JdPWUmMjU1O3RoaXNbcisxXT1lPj4+ODtyZXR1cm4gcisyfTtCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkU9ZnVuY3Rpb24gd3JpdGVVSW50MTZCRShlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDIsNjU1MzUsMCk7dGhpc1tyXT1lPj4+ODt0aGlzW3IrMV09ZSYyNTU7cmV0dXJuIHIrMn07QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFPWZ1bmN0aW9uIHdyaXRlVUludDMyTEUoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciw0LDQyOTQ5NjcyOTUsMCk7dGhpc1tyKzNdPWU+Pj4yNDt0aGlzW3IrMl09ZT4+PjE2O3RoaXNbcisxXT1lPj4+ODt0aGlzW3JdPWUmMjU1O3JldHVybiByKzR9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRT1mdW5jdGlvbiB3cml0ZVVJbnQzMkJFKGUscix0KXtlPStlO3I9cj4+PjA7aWYoIXQpY2hlY2tJbnQodGhpcyxlLHIsNCw0Mjk0OTY3Mjk1LDApO3RoaXNbcl09ZT4+PjI0O3RoaXNbcisxXT1lPj4+MTY7dGhpc1tyKzJdPWU+Pj44O3RoaXNbciszXT1lJjI1NTtyZXR1cm4gcis0fTtCdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEU9ZnVuY3Rpb24gd3JpdGVJbnRMRShlLHIsdCxmKXtlPStlO3I9cj4+PjA7aWYoIWYpe3ZhciBuPU1hdGgucG93KDIsOCp0LTEpO2NoZWNrSW50KHRoaXMsZSxyLHQsbi0xLC1uKX12YXIgaT0wO3ZhciBvPTE7dmFyIHU9MDt0aGlzW3JdPWUmMjU1O3doaWxlKCsraTx0JiYobyo9MjU2KSl7aWYoZTwwJiZ1PT09MCYmdGhpc1tyK2ktMV0hPT0wKXt1PTF9dGhpc1tyK2ldPShlL28+PjApLXUmMjU1fXJldHVybiByK3R9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRT1mdW5jdGlvbiB3cml0ZUludEJFKGUscix0LGYpe2U9K2U7cj1yPj4+MDtpZighZil7dmFyIG49TWF0aC5wb3coMiw4KnQtMSk7Y2hlY2tJbnQodGhpcyxlLHIsdCxuLTEsLW4pfXZhciBpPXQtMTt2YXIgbz0xO3ZhciB1PTA7dGhpc1tyK2ldPWUmMjU1O3doaWxlKC0taT49MCYmKG8qPTI1Nikpe2lmKGU8MCYmdT09PTAmJnRoaXNbcitpKzFdIT09MCl7dT0xfXRoaXNbcitpXT0oZS9vPj4wKS11JjI1NX1yZXR1cm4gcit0fTtCdWZmZXIucHJvdG90eXBlLndyaXRlSW50OD1mdW5jdGlvbiB3cml0ZUludDgoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciwxLDEyNywtMTI4KTtpZihlPDApZT0yNTUrZSsxO3RoaXNbcl09ZSYyNTU7cmV0dXJuIHIrMX07QnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEU9ZnVuY3Rpb24gd3JpdGVJbnQxNkxFKGUscix0KXtlPStlO3I9cj4+PjA7aWYoIXQpY2hlY2tJbnQodGhpcyxlLHIsMiwzMjc2NywtMzI3NjgpO3RoaXNbcl09ZSYyNTU7dGhpc1tyKzFdPWU+Pj44O3JldHVybiByKzJ9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFPWZ1bmN0aW9uIHdyaXRlSW50MTZCRShlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDIsMzI3NjcsLTMyNzY4KTt0aGlzW3JdPWU+Pj44O3RoaXNbcisxXT1lJjI1NTtyZXR1cm4gcisyfTtCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRT1mdW5jdGlvbiB3cml0ZUludDMyTEUoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciw0LDIxNDc0ODM2NDcsLTIxNDc0ODM2NDgpO3RoaXNbcl09ZSYyNTU7dGhpc1tyKzFdPWU+Pj44O3RoaXNbcisyXT1lPj4+MTY7dGhpc1tyKzNdPWU+Pj4yNDtyZXR1cm4gcis0fTtCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRT1mdW5jdGlvbiB3cml0ZUludDMyQkUoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciw0LDIxNDc0ODM2NDcsLTIxNDc0ODM2NDgpO2lmKGU8MCllPTQyOTQ5NjcyOTUrZSsxO3RoaXNbcl09ZT4+PjI0O3RoaXNbcisxXT1lPj4+MTY7dGhpc1tyKzJdPWU+Pj44O3RoaXNbciszXT1lJjI1NTtyZXR1cm4gcis0fTtmdW5jdGlvbiBjaGVja0lFRUU3NTQoZSxyLHQsZixuLGkpe2lmKHQrZj5lLmxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IG91dCBvZiByYW5nZVwiKTtpZih0PDApdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIil9ZnVuY3Rpb24gd3JpdGVGbG9hdChlLHIsdCxmLGkpe3I9K3I7dD10Pj4+MDtpZighaSl7Y2hlY2tJRUVFNzU0KGUscix0LDQsMzQwMjgyMzQ2NjM4NTI4ODZlMjIsLTM0MDI4MjM0NjYzODUyODg2ZTIyKX1uLndyaXRlKGUscix0LGYsMjMsNCk7cmV0dXJuIHQrNH1CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRT1mdW5jdGlvbiB3cml0ZUZsb2F0TEUoZSxyLHQpe3JldHVybiB3cml0ZUZsb2F0KHRoaXMsZSxyLHRydWUsdCl9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFPWZ1bmN0aW9uIHdyaXRlRmxvYXRCRShlLHIsdCl7cmV0dXJuIHdyaXRlRmxvYXQodGhpcyxlLHIsZmFsc2UsdCl9O2Z1bmN0aW9uIHdyaXRlRG91YmxlKGUscix0LGYsaSl7cj0rcjt0PXQ+Pj4wO2lmKCFpKXtjaGVja0lFRUU3NTQoZSxyLHQsOCwxNzk3NjkzMTM0ODYyMzE1N2UyOTIsLTE3OTc2OTMxMzQ4NjIzMTU3ZTI5Mil9bi53cml0ZShlLHIsdCxmLDUyLDgpO3JldHVybiB0Kzh9QnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFPWZ1bmN0aW9uIHdyaXRlRG91YmxlTEUoZSxyLHQpe3JldHVybiB3cml0ZURvdWJsZSh0aGlzLGUscix0cnVlLHQpfTtCdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkU9ZnVuY3Rpb24gd3JpdGVEb3VibGVCRShlLHIsdCl7cmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsZSxyLGZhbHNlLHQpfTtCdWZmZXIucHJvdG90eXBlLmNvcHk9ZnVuY3Rpb24gY29weShlLHIsdCxmKXtpZighQnVmZmVyLmlzQnVmZmVyKGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJhcmd1bWVudCBzaG91bGQgYmUgYSBCdWZmZXJcIik7aWYoIXQpdD0wO2lmKCFmJiZmIT09MClmPXRoaXMubGVuZ3RoO2lmKHI+PWUubGVuZ3RoKXI9ZS5sZW5ndGg7aWYoIXIpcj0wO2lmKGY+MCYmZjx0KWY9dDtpZihmPT09dClyZXR1cm4gMDtpZihlLmxlbmd0aD09PTB8fHRoaXMubGVuZ3RoPT09MClyZXR1cm4gMDtpZihyPDApe3Rocm93IG5ldyBSYW5nZUVycm9yKFwidGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kc1wiKX1pZih0PDB8fHQ+PXRoaXMubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggb3V0IG9mIHJhbmdlXCIpO2lmKGY8MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInNvdXJjZUVuZCBvdXQgb2YgYm91bmRzXCIpO2lmKGY+dGhpcy5sZW5ndGgpZj10aGlzLmxlbmd0aDtpZihlLmxlbmd0aC1yPGYtdCl7Zj1lLmxlbmd0aC1yK3R9dmFyIG49Zi10O2lmKHRoaXM9PT1lJiZ0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbj09PVwiZnVuY3Rpb25cIil7dGhpcy5jb3B5V2l0aGluKHIsdCxmKX1lbHNlIGlmKHRoaXM9PT1lJiZ0PHImJnI8Zil7Zm9yKHZhciBpPW4tMTtpPj0wOy0taSl7ZVtpK3JdPXRoaXNbaSt0XX19ZWxzZXtVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChlLHRoaXMuc3ViYXJyYXkodCxmKSxyKX1yZXR1cm4gbn07QnVmZmVyLnByb3RvdHlwZS5maWxsPWZ1bmN0aW9uIGZpbGwoZSxyLHQsZil7aWYodHlwZW9mIGU9PT1cInN0cmluZ1wiKXtpZih0eXBlb2Ygcj09PVwic3RyaW5nXCIpe2Y9cjtyPTA7dD10aGlzLmxlbmd0aH1lbHNlIGlmKHR5cGVvZiB0PT09XCJzdHJpbmdcIil7Zj10O3Q9dGhpcy5sZW5ndGh9aWYoZiE9PXVuZGVmaW5lZCYmdHlwZW9mIGYhPT1cInN0cmluZ1wiKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZ1wiKX1pZih0eXBlb2YgZj09PVwic3RyaW5nXCImJiFCdWZmZXIuaXNFbmNvZGluZyhmKSl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gZW5jb2Rpbmc6IFwiK2YpfWlmKGUubGVuZ3RoPT09MSl7dmFyIG49ZS5jaGFyQ29kZUF0KDApO2lmKGY9PT1cInV0ZjhcIiYmbjwxMjh8fGY9PT1cImxhdGluMVwiKXtlPW59fX1lbHNlIGlmKHR5cGVvZiBlPT09XCJudW1iZXJcIil7ZT1lJjI1NX1lbHNlIGlmKHR5cGVvZiBlPT09XCJib29sZWFuXCIpe2U9TnVtYmVyKGUpfWlmKHI8MHx8dGhpcy5sZW5ndGg8cnx8dGhpcy5sZW5ndGg8dCl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJPdXQgb2YgcmFuZ2UgaW5kZXhcIil9aWYodDw9cil7cmV0dXJuIHRoaXN9cj1yPj4+MDt0PXQ9PT11bmRlZmluZWQ/dGhpcy5sZW5ndGg6dD4+PjA7aWYoIWUpZT0wO3ZhciBpO2lmKHR5cGVvZiBlPT09XCJudW1iZXJcIil7Zm9yKGk9cjtpPHQ7KytpKXt0aGlzW2ldPWV9fWVsc2V7dmFyIG89QnVmZmVyLmlzQnVmZmVyKGUpP2U6QnVmZmVyLmZyb20oZSxmKTt2YXIgdT1vLmxlbmd0aDtpZih1PT09MCl7dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZhbHVlIFwiJytlKydcIiBpcyBpbnZhbGlkIGZvciBhcmd1bWVudCBcInZhbHVlXCInKX1mb3IoaT0wO2k8dC1yOysraSl7dGhpc1tpK3JdPW9baSV1XX19cmV0dXJuIHRoaXN9O3ZhciBhPS9bXisvMC05QS1aYS16LV9dL2c7ZnVuY3Rpb24gYmFzZTY0Y2xlYW4oZSl7ZT1lLnNwbGl0KFwiPVwiKVswXTtlPWUudHJpbSgpLnJlcGxhY2UoYSxcIlwiKTtpZihlLmxlbmd0aDwyKXJldHVyblwiXCI7d2hpbGUoZS5sZW5ndGglNCE9PTApe2U9ZStcIj1cIn1yZXR1cm4gZX1mdW5jdGlvbiB1dGY4VG9CeXRlcyhlLHIpe3I9cnx8SW5maW5pdHk7dmFyIHQ7dmFyIGY9ZS5sZW5ndGg7dmFyIG49bnVsbDt2YXIgaT1bXTtmb3IodmFyIG89MDtvPGY7KytvKXt0PWUuY2hhckNvZGVBdChvKTtpZih0PjU1Mjk1JiZ0PDU3MzQ0KXtpZighbil7aWYodD41NjMxOSl7aWYoKHItPTMpPi0xKWkucHVzaCgyMzksMTkxLDE4OSk7Y29udGludWV9ZWxzZSBpZihvKzE9PT1mKXtpZigoci09Myk+LTEpaS5wdXNoKDIzOSwxOTEsMTg5KTtjb250aW51ZX1uPXQ7Y29udGludWV9aWYodDw1NjMyMCl7aWYoKHItPTMpPi0xKWkucHVzaCgyMzksMTkxLDE4OSk7bj10O2NvbnRpbnVlfXQ9KG4tNTUyOTY8PDEwfHQtNTYzMjApKzY1NTM2fWVsc2UgaWYobil7aWYoKHItPTMpPi0xKWkucHVzaCgyMzksMTkxLDE4OSl9bj1udWxsO2lmKHQ8MTI4KXtpZigoci09MSk8MClicmVhaztpLnB1c2godCl9ZWxzZSBpZih0PDIwNDgpe2lmKChyLT0yKTwwKWJyZWFrO2kucHVzaCh0Pj42fDE5Mix0JjYzfDEyOCl9ZWxzZSBpZih0PDY1NTM2KXtpZigoci09Myk8MClicmVhaztpLnB1c2godD4+MTJ8MjI0LHQ+PjYmNjN8MTI4LHQmNjN8MTI4KX1lbHNlIGlmKHQ8MTExNDExMil7aWYoKHItPTQpPDApYnJlYWs7aS5wdXNoKHQ+PjE4fDI0MCx0Pj4xMiY2M3wxMjgsdD4+NiY2M3wxMjgsdCY2M3wxMjgpfWVsc2V7dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjb2RlIHBvaW50XCIpfX1yZXR1cm4gaX1mdW5jdGlvbiBhc2NpaVRvQnl0ZXMoZSl7dmFyIHI9W107Zm9yKHZhciB0PTA7dDxlLmxlbmd0aDsrK3Qpe3IucHVzaChlLmNoYXJDb2RlQXQodCkmMjU1KX1yZXR1cm4gcn1mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyhlLHIpe3ZhciB0LGYsbjt2YXIgaT1bXTtmb3IodmFyIG89MDtvPGUubGVuZ3RoOysrbyl7aWYoKHItPTIpPDApYnJlYWs7dD1lLmNoYXJDb2RlQXQobyk7Zj10Pj44O249dCUyNTY7aS5wdXNoKG4pO2kucHVzaChmKX1yZXR1cm4gaX1mdW5jdGlvbiBiYXNlNjRUb0J5dGVzKGUpe3JldHVybiBmLnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKGUpKX1mdW5jdGlvbiBibGl0QnVmZmVyKGUscix0LGYpe2Zvcih2YXIgbj0wO248ZjsrK24pe2lmKG4rdD49ci5sZW5ndGh8fG4+PWUubGVuZ3RoKWJyZWFrO3Jbbit0XT1lW25dfXJldHVybiBufWZ1bmN0aW9uIGlzSW5zdGFuY2UoZSxyKXtyZXR1cm4gZSBpbnN0YW5jZW9mIHJ8fGUhPW51bGwmJmUuY29uc3RydWN0b3IhPW51bGwmJmUuY29uc3RydWN0b3IubmFtZSE9bnVsbCYmZS5jb25zdHJ1Y3Rvci5uYW1lPT09ci5uYW1lfWZ1bmN0aW9uIG51bWJlcklzTmFOKGUpe3JldHVybiBlIT09ZX12YXIgcz1mdW5jdGlvbigpe3ZhciBlPVwiMDEyMzQ1Njc4OWFiY2RlZlwiO3ZhciByPW5ldyBBcnJheSgyNTYpO2Zvcih2YXIgdD0wO3Q8MTY7Kyt0KXt2YXIgZj10KjE2O2Zvcih2YXIgbj0wO248MTY7KytuKXtyW2Yrbl09ZVt0XStlW25dfX1yZXR1cm4gcn0oKX0sNzgzOmZ1bmN0aW9uKGUscil7XG4vKiEgaWVlZTc1NC4gQlNELTMtQ2xhdXNlIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL1xuci5yZWFkPWZ1bmN0aW9uKGUscix0LGYsbil7dmFyIGksbzt2YXIgdT1uKjgtZi0xO3ZhciBhPSgxPDx1KS0xO3ZhciBzPWE+PjE7dmFyIGg9LTc7dmFyIGM9dD9uLTE6MDt2YXIgbD10Py0xOjE7dmFyIHA9ZVtyK2NdO2MrPWw7aT1wJigxPDwtaCktMTtwPj49LWg7aCs9dTtmb3IoO2g+MDtpPWkqMjU2K2VbcitjXSxjKz1sLGgtPTgpe31vPWkmKDE8PC1oKS0xO2k+Pj0taDtoKz1mO2Zvcig7aD4wO289byoyNTYrZVtyK2NdLGMrPWwsaC09OCl7fWlmKGk9PT0wKXtpPTEtc31lbHNlIGlmKGk9PT1hKXtyZXR1cm4gbz9OYU46KHA/LTE6MSkqSW5maW5pdHl9ZWxzZXtvPW8rTWF0aC5wb3coMixmKTtpPWktc31yZXR1cm4ocD8tMToxKSpvKk1hdGgucG93KDIsaS1mKX07ci53cml0ZT1mdW5jdGlvbihlLHIsdCxmLG4saSl7dmFyIG8sdSxhO3ZhciBzPWkqOC1uLTE7dmFyIGg9KDE8PHMpLTE7dmFyIGM9aD4+MTt2YXIgbD1uPT09MjM/TWF0aC5wb3coMiwtMjQpLU1hdGgucG93KDIsLTc3KTowO3ZhciBwPWY/MDppLTE7dmFyIHk9Zj8xOi0xO3ZhciBnPXI8MHx8cj09PTAmJjEvcjwwPzE6MDtyPU1hdGguYWJzKHIpO2lmKGlzTmFOKHIpfHxyPT09SW5maW5pdHkpe3U9aXNOYU4ocik/MTowO289aH1lbHNle289TWF0aC5mbG9vcihNYXRoLmxvZyhyKS9NYXRoLkxOMik7aWYociooYT1NYXRoLnBvdygyLC1vKSk8MSl7by0tO2EqPTJ9aWYobytjPj0xKXtyKz1sL2F9ZWxzZXtyKz1sKk1hdGgucG93KDIsMS1jKX1pZihyKmE+PTIpe28rKzthLz0yfWlmKG8rYz49aCl7dT0wO289aH1lbHNlIGlmKG8rYz49MSl7dT0ociphLTEpKk1hdGgucG93KDIsbik7bz1vK2N9ZWxzZXt1PXIqTWF0aC5wb3coMixjLTEpKk1hdGgucG93KDIsbik7bz0wfX1mb3IoO24+PTg7ZVt0K3BdPXUmMjU1LHArPXksdS89MjU2LG4tPTgpe31vPW88PG58dTtzKz1uO2Zvcig7cz4wO2VbdCtwXT1vJjI1NSxwKz15LG8vPTI1NixzLT04KXt9ZVt0K3AteV18PWcqMTI4fX19O3ZhciByPXt9O2Z1bmN0aW9uIF9fbmNjd3Bja19yZXF1aXJlX18odCl7dmFyIGY9clt0XTtpZihmIT09dW5kZWZpbmVkKXtyZXR1cm4gZi5leHBvcnRzfXZhciBuPXJbdF09e2V4cG9ydHM6e319O3ZhciBpPXRydWU7dHJ5e2VbdF0obixuLmV4cG9ydHMsX19uY2N3cGNrX3JlcXVpcmVfXyk7aT1mYWxzZX1maW5hbGx5e2lmKGkpZGVsZXRlIHJbdF19cmV0dXJuIG4uZXhwb3J0c31pZih0eXBlb2YgX19uY2N3cGNrX3JlcXVpcmVfXyE9PVwidW5kZWZpbmVkXCIpX19uY2N3cGNrX3JlcXVpcmVfXy5hYj1fX2Rpcm5hbWUrXCIvXCI7dmFyIHQ9X19uY2N3cGNrX3JlcXVpcmVfXyg3Mik7bW9kdWxlLmV4cG9ydHM9dH0pKCk7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/buffer/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tseep/lib/ee.js":
/*!**************************************!*\
  !*** ./node_modules/tseep/lib/ee.js ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EventEmitter = void 0;\nvar task_collection_1 = __webpack_require__(/*! ./task-collection */ \"(app-pages-browser)/./node_modules/tseep/lib/task-collection/index.js\");\nvar utils_1 = __webpack_require__(/*! ./task-collection/utils */ \"(app-pages-browser)/./node_modules/tseep/lib/task-collection/utils.js\");\nvar utils_2 = __webpack_require__(/*! ./utils */ \"(app-pages-browser)/./node_modules/tseep/lib/utils.js\");\nfunction emit(event, a, b, c, d, e) {\n    var ev = this.events[event];\n    if (ev) {\n        if (ev.length === 0)\n            return false;\n        if (ev.argsNum < 6) {\n            ev.call(a, b, c, d, e);\n        }\n        else {\n            var arr = new Array(ev.argsNum);\n            for (var i = 0, len = arr.length; i < len; ++i) {\n                arr[i] = arguments[i + 1];\n            }\n            ev.call.apply(undefined, arr);\n        }\n        return true;\n    }\n    return false;\n}\nfunction emitHasOnce(event, a, b, c, d, e) {\n    var ev = this.events[event];\n    var argsArr;\n    if (ev !== undefined) {\n        if (ev.length === 0)\n            return false;\n        if (ev.argsNum < 6) {\n            ev.call(a, b, c, d, e);\n        }\n        else {\n            argsArr = new Array(ev.argsNum);\n            for (var i = 0, len = argsArr.length; i < len; ++i) {\n                argsArr[i] = arguments[i + 1];\n            }\n            ev.call.apply(undefined, argsArr);\n        }\n    }\n    var oev = this.onceEvents[event];\n    if (oev) {\n        if (typeof oev === 'function') {\n            this.onceEvents[event] = undefined;\n            if (arguments.length < 6) {\n                oev(a, b, c, d, e);\n            }\n            else {\n                if (argsArr === undefined) {\n                    argsArr = new Array(arguments.length - 1);\n                    for (var i = 0, len = argsArr.length; i < len; ++i) {\n                        argsArr[i] = arguments[i + 1];\n                    }\n                }\n                oev.apply(undefined, argsArr);\n            }\n        }\n        else {\n            var fncs = oev;\n            this.onceEvents[event] = undefined;\n            if (arguments.length < 6) {\n                for (var i = 0; i < fncs.length; ++i) {\n                    fncs[i](a, b, c, d, e);\n                }\n            }\n            else {\n                if (argsArr === undefined) {\n                    argsArr = new Array(arguments.length - 1);\n                    for (var i = 0, len = argsArr.length; i < len; ++i) {\n                        argsArr[i] = arguments[i + 1];\n                    }\n                }\n                for (var i = 0; i < fncs.length; ++i) {\n                    fncs[i].apply(undefined, argsArr);\n                }\n            }\n        }\n        return true;\n    }\n    return ev !== undefined;\n}\n/** Implemented event emitter */\nvar EventEmitter = /** @class */ (function () {\n    function EventEmitter() {\n        this.events = (0, utils_2.nullObj)();\n        this.onceEvents = (0, utils_2.nullObj)();\n        this._symbolKeys = new Set;\n        this.maxListeners = Infinity;\n    }\n    Object.defineProperty(EventEmitter.prototype, \"_eventsCount\", {\n        get: function () {\n            return this.eventNames().length;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return EventEmitter;\n}());\nexports.EventEmitter = EventEmitter;\nfunction once(event, listener) {\n    if (this.emit === emit) {\n        this.emit = emitHasOnce;\n    }\n    switch (typeof this.onceEvents[event]) {\n        case 'undefined':\n            this.onceEvents[event] = listener;\n            if (typeof event === 'symbol')\n                this._symbolKeys.add(event);\n            break;\n        case 'function':\n            this.onceEvents[event] = [this.onceEvents[event], listener];\n            break;\n        case 'object':\n            this.onceEvents[event].push(listener);\n    }\n    return this;\n}\nfunction addListener(event, listener, argsNum) {\n    if (argsNum === void 0) { argsNum = listener.length; }\n    if (typeof listener !== 'function')\n        throw new TypeError('The listener must be a function');\n    var evtmap = this.events[event];\n    if (!evtmap) {\n        this.events[event] = new task_collection_1.TaskCollection(argsNum, true, listener, false);\n        if (typeof event === 'symbol')\n            this._symbolKeys.add(event);\n    }\n    else {\n        evtmap.push(listener);\n        evtmap.growArgsNum(argsNum);\n        if (this.maxListeners !== Infinity && this.maxListeners <= evtmap.length)\n            console.warn(\"Maximum event listeners for \\\"\".concat(String(event), \"\\\" event!\"));\n    }\n    return this;\n}\nfunction removeListener(event, listener) {\n    var evt = this.events[event];\n    if (evt) {\n        evt.removeLast(listener);\n    }\n    var evto = this.onceEvents[event];\n    if (evto) {\n        if (typeof evto === 'function') {\n            this.onceEvents[event] = undefined;\n        }\n        else if (typeof evto === 'object') {\n            if (evto.length === 1 && evto[0] === listener) {\n                this.onceEvents[event] = undefined;\n            }\n            else {\n                (0, utils_1._fast_remove_single)(evto, evto.lastIndexOf(listener));\n            }\n        }\n    }\n    return this;\n}\nfunction addListenerBound(event, listener, bindTo, argsNum) {\n    if (bindTo === void 0) { bindTo = this; }\n    if (argsNum === void 0) { argsNum = listener.length; }\n    if (!this.boundFuncs)\n        this.boundFuncs = new Map;\n    var bound = listener.bind(bindTo);\n    this.boundFuncs.set(listener, bound);\n    return this.addListener(event, bound, argsNum);\n}\nfunction removeListenerBound(event, listener) {\n    var _a, _b;\n    var bound = (_a = this.boundFuncs) === null || _a === void 0 ? void 0 : _a.get(listener);\n    (_b = this.boundFuncs) === null || _b === void 0 ? void 0 : _b.delete(listener);\n    return this.removeListener(event, bound);\n}\nfunction hasListeners(event) {\n    return this.events[event] && !!this.events[event].length;\n}\nfunction prependListener(event, listener, argsNum) {\n    if (argsNum === void 0) { argsNum = listener.length; }\n    if (typeof listener !== 'function')\n        throw new TypeError('The listener must be a function');\n    var evtmap = this.events[event];\n    if (!evtmap || !(evtmap instanceof task_collection_1.TaskCollection)) {\n        evtmap = this.events[event] = new task_collection_1.TaskCollection(argsNum, true, listener, false);\n        if (typeof event === 'symbol')\n            this._symbolKeys.add(event);\n    }\n    else {\n        evtmap.insert(0, listener);\n        evtmap.growArgsNum(argsNum);\n        if (this.maxListeners !== Infinity && this.maxListeners <= evtmap.length)\n            console.warn(\"Maximum event listeners for \\\"\".concat(String(event), \"\\\" event!\"));\n    }\n    return this;\n}\nfunction prependOnceListener(event, listener) {\n    if (this.emit === emit) {\n        this.emit = emitHasOnce;\n    }\n    var evtmap = this.onceEvents[event];\n    if (!evtmap) {\n        this.onceEvents[event] = [listener];\n        if (typeof event === 'symbol')\n            this._symbolKeys.add(event);\n    }\n    else if (typeof evtmap !== 'object') {\n        this.onceEvents[event] = [listener, evtmap];\n        if (typeof event === 'symbol')\n            this._symbolKeys.add(event);\n    }\n    else {\n        evtmap.unshift(listener);\n        if (this.maxListeners !== Infinity && this.maxListeners <= evtmap.length) {\n            console.warn(\"Maximum event listeners for \\\"\".concat(String(event), \"\\\" once event!\"));\n        }\n    }\n    return this;\n}\nfunction removeAllListeners(event) {\n    if (event === undefined) {\n        this.events = (0, utils_2.nullObj)();\n        this.onceEvents = (0, utils_2.nullObj)();\n        this._symbolKeys = new Set;\n    }\n    else {\n        this.events[event] = undefined;\n        this.onceEvents[event] = undefined;\n        if (typeof event === 'symbol')\n            this._symbolKeys.delete(event);\n    }\n    return this;\n}\nfunction setMaxListeners(n) {\n    this.maxListeners = n;\n    return this;\n}\nfunction getMaxListeners() {\n    return this.maxListeners;\n}\nfunction listeners(event) {\n    if (this.emit === emit)\n        return this.events[event] ? this.events[event].tasksAsArray().slice() : [];\n    else {\n        if (this.events[event] && this.onceEvents[event]) {\n            return __spreadArray(__spreadArray([], this.events[event].tasksAsArray(), true), (typeof this.onceEvents[event] === 'function' ? [this.onceEvents[event]] : this.onceEvents[event]), true);\n        }\n        else if (this.events[event])\n            return this.events[event].tasksAsArray();\n        else if (this.onceEvents[event])\n            return (typeof this.onceEvents[event] === 'function' ? [this.onceEvents[event]] : this.onceEvents[event]);\n        else\n            return [];\n    }\n}\nfunction eventNames() {\n    var _this = this;\n    if (this.emit === emit) {\n        var keys = Object.keys(this.events);\n        return __spreadArray(__spreadArray([], keys, true), Array.from(this._symbolKeys), true).filter(function (x) { return (x in _this.events) && _this.events[x] && _this.events[x].length; });\n    }\n    else {\n        var keys = Object.keys(this.events).filter(function (x) { return _this.events[x] && _this.events[x].length; });\n        var keysO = Object.keys(this.onceEvents).filter(function (x) { return _this.onceEvents[x] && _this.onceEvents[x].length; });\n        return __spreadArray(__spreadArray(__spreadArray([], keys, true), keysO, true), Array.from(this._symbolKeys).filter(function (x) { return (((x in _this.events) && _this.events[x] && _this.events[x].length) ||\n            ((x in _this.onceEvents) && _this.onceEvents[x] && _this.onceEvents[x].length)); }), true);\n    }\n}\nfunction listenerCount(type) {\n    if (this.emit === emit)\n        return this.events[type] && this.events[type].length || 0;\n    else\n        return (this.events[type] && this.events[type].length || 0) + (this.onceEvents[type] && this.onceEvents[type].length || 0);\n}\nEventEmitter.prototype.emit = emit;\nEventEmitter.prototype.on = addListener;\nEventEmitter.prototype.once = once;\nEventEmitter.prototype.addListener = addListener;\nEventEmitter.prototype.removeListener = removeListener;\nEventEmitter.prototype.addListenerBound = addListenerBound;\nEventEmitter.prototype.removeListenerBound = removeListenerBound;\nEventEmitter.prototype.hasListeners = hasListeners;\nEventEmitter.prototype.prependListener = prependListener;\nEventEmitter.prototype.prependOnceListener = prependOnceListener;\nEventEmitter.prototype.off = removeListener;\nEventEmitter.prototype.removeAllListeners = removeAllListeners;\nEventEmitter.prototype.setMaxListeners = setMaxListeners;\nEventEmitter.prototype.getMaxListeners = getMaxListeners;\nEventEmitter.prototype.listeners = listeners;\nEventEmitter.prototype.eventNames = eventNames;\nEventEmitter.prototype.listenerCount = listenerCount;\n//# sourceMappingURL=ee.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90c2VlcC9saWIvZWUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZFQUE2RSxPQUFPO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQjtBQUNwQix3QkFBd0IsbUJBQU8sQ0FBQyxnR0FBbUI7QUFDbkQsY0FBYyxtQkFBTyxDQUFDLHNHQUF5QjtBQUMvQyxjQUFjLG1CQUFPLENBQUMsc0VBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsU0FBUztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxTQUFTO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxTQUFTO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGlCQUFpQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsU0FBUztBQUNuRTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsaUJBQWlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Qsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0hBQXNILDBFQUEwRTtBQUNoTTtBQUNBO0FBQ0Esa0VBQWtFLG1EQUFtRDtBQUNySCx1RUFBdUUsMkRBQTJEO0FBQ2xJLDJJQUEySTtBQUMzSSw4RkFBOEY7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbGZnL0dpdC9NYWR0cmlwcy9ub2RlX21vZHVsZXMvdHNlZXAvbGliL2VlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSwgcGFjaykge1xuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5FdmVudEVtaXR0ZXIgPSB2b2lkIDA7XG52YXIgdGFza19jb2xsZWN0aW9uXzEgPSByZXF1aXJlKFwiLi90YXNrLWNvbGxlY3Rpb25cIik7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3Rhc2stY29sbGVjdGlvbi91dGlsc1wiKTtcbnZhciB1dGlsc18yID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5mdW5jdGlvbiBlbWl0KGV2ZW50LCBhLCBiLCBjLCBkLCBlKSB7XG4gICAgdmFyIGV2ID0gdGhpcy5ldmVudHNbZXZlbnRdO1xuICAgIGlmIChldikge1xuICAgICAgICBpZiAoZXYubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZXYuYXJnc051bSA8IDYpIHtcbiAgICAgICAgICAgIGV2LmNhbGwoYSwgYiwgYywgZCwgZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgYXJyID0gbmV3IEFycmF5KGV2LmFyZ3NOdW0pO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFyci5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICAgIGFycltpXSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBldi5jYWxsLmFwcGx5KHVuZGVmaW5lZCwgYXJyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZW1pdEhhc09uY2UoZXZlbnQsIGEsIGIsIGMsIGQsIGUpIHtcbiAgICB2YXIgZXYgPSB0aGlzLmV2ZW50c1tldmVudF07XG4gICAgdmFyIGFyZ3NBcnI7XG4gICAgaWYgKGV2ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGV2Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGV2LmFyZ3NOdW0gPCA2KSB7XG4gICAgICAgICAgICBldi5jYWxsKGEsIGIsIGMsIGQsIGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXJnc0FyciA9IG5ldyBBcnJheShldi5hcmdzTnVtKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcmdzQXJyLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgYXJnc0FycltpXSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBldi5jYWxsLmFwcGx5KHVuZGVmaW5lZCwgYXJnc0Fycik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIG9ldiA9IHRoaXMub25jZUV2ZW50c1tldmVudF07XG4gICAgaWYgKG9ldikge1xuICAgICAgICBpZiAodHlwZW9mIG9ldiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5vbmNlRXZlbnRzW2V2ZW50XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgNikge1xuICAgICAgICAgICAgICAgIG9ldihhLCBiLCBjLCBkLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChhcmdzQXJyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnc0FyciA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcmdzQXJyLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzQXJyW2ldID0gYXJndW1lbnRzW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvZXYuYXBwbHkodW5kZWZpbmVkLCBhcmdzQXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBmbmNzID0gb2V2O1xuICAgICAgICAgICAgdGhpcy5vbmNlRXZlbnRzW2V2ZW50XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgNikge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm5jcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBmbmNzW2ldKGEsIGIsIGMsIGQsIGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChhcmdzQXJyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnc0FyciA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcmdzQXJyLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzQXJyW2ldID0gYXJndW1lbnRzW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZuY3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgZm5jc1tpXS5hcHBseSh1bmRlZmluZWQsIGFyZ3NBcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGV2ICE9PSB1bmRlZmluZWQ7XG59XG4vKiogSW1wbGVtZW50ZWQgZXZlbnQgZW1pdHRlciAqL1xudmFyIEV2ZW50RW1pdHRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gICAgICAgIHRoaXMuZXZlbnRzID0gKDAsIHV0aWxzXzIubnVsbE9iaikoKTtcbiAgICAgICAgdGhpcy5vbmNlRXZlbnRzID0gKDAsIHV0aWxzXzIubnVsbE9iaikoKTtcbiAgICAgICAgdGhpcy5fc3ltYm9sS2V5cyA9IG5ldyBTZXQ7XG4gICAgICAgIHRoaXMubWF4TGlzdGVuZXJzID0gSW5maW5pdHk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEVtaXR0ZXIucHJvdG90eXBlLCBcIl9ldmVudHNDb3VudFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnROYW1lcygpLmxlbmd0aDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBFdmVudEVtaXR0ZXI7XG59KCkpO1xuZXhwb3J0cy5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5mdW5jdGlvbiBvbmNlKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgIGlmICh0aGlzLmVtaXQgPT09IGVtaXQpIHtcbiAgICAgICAgdGhpcy5lbWl0ID0gZW1pdEhhc09uY2U7XG4gICAgfVxuICAgIHN3aXRjaCAodHlwZW9mIHRoaXMub25jZUV2ZW50c1tldmVudF0pIHtcbiAgICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgICAgIHRoaXMub25jZUV2ZW50c1tldmVudF0gPSBsaXN0ZW5lcjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXZlbnQgPT09ICdzeW1ib2wnKVxuICAgICAgICAgICAgICAgIHRoaXMuX3N5bWJvbEtleXMuYWRkKGV2ZW50KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgICB0aGlzLm9uY2VFdmVudHNbZXZlbnRdID0gW3RoaXMub25jZUV2ZW50c1tldmVudF0sIGxpc3RlbmVyXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgdGhpcy5vbmNlRXZlbnRzW2V2ZW50XS5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59XG5mdW5jdGlvbiBhZGRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGFyZ3NOdW0pIHtcbiAgICBpZiAoYXJnc051bSA9PT0gdm9pZCAwKSB7IGFyZ3NOdW0gPSBsaXN0ZW5lci5sZW5ndGg7IH1cbiAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgdmFyIGV2dG1hcCA9IHRoaXMuZXZlbnRzW2V2ZW50XTtcbiAgICBpZiAoIWV2dG1hcCkge1xuICAgICAgICB0aGlzLmV2ZW50c1tldmVudF0gPSBuZXcgdGFza19jb2xsZWN0aW9uXzEuVGFza0NvbGxlY3Rpb24oYXJnc051bSwgdHJ1ZSwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgICAgICAgaWYgKHR5cGVvZiBldmVudCA9PT0gJ3N5bWJvbCcpXG4gICAgICAgICAgICB0aGlzLl9zeW1ib2xLZXlzLmFkZChldmVudCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBldnRtYXAucHVzaChsaXN0ZW5lcik7XG4gICAgICAgIGV2dG1hcC5ncm93QXJnc051bShhcmdzTnVtKTtcbiAgICAgICAgaWYgKHRoaXMubWF4TGlzdGVuZXJzICE9PSBJbmZpbml0eSAmJiB0aGlzLm1heExpc3RlbmVycyA8PSBldnRtYXAubGVuZ3RoKVxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiTWF4aW11bSBldmVudCBsaXN0ZW5lcnMgZm9yIFxcXCJcIi5jb25jYXQoU3RyaW5nKGV2ZW50KSwgXCJcXFwiIGV2ZW50IVwiKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufVxuZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgdmFyIGV2dCA9IHRoaXMuZXZlbnRzW2V2ZW50XTtcbiAgICBpZiAoZXZ0KSB7XG4gICAgICAgIGV2dC5yZW1vdmVMYXN0KGxpc3RlbmVyKTtcbiAgICB9XG4gICAgdmFyIGV2dG8gPSB0aGlzLm9uY2VFdmVudHNbZXZlbnRdO1xuICAgIGlmIChldnRvKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZXZ0byA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5vbmNlRXZlbnRzW2V2ZW50XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgZXZ0byA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGlmIChldnRvLmxlbmd0aCA9PT0gMSAmJiBldnRvWzBdID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIHRoaXMub25jZUV2ZW50c1tldmVudF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAoMCwgdXRpbHNfMS5fZmFzdF9yZW1vdmVfc2luZ2xlKShldnRvLCBldnRvLmxhc3RJbmRleE9mKGxpc3RlbmVyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59XG5mdW5jdGlvbiBhZGRMaXN0ZW5lckJvdW5kKGV2ZW50LCBsaXN0ZW5lciwgYmluZFRvLCBhcmdzTnVtKSB7XG4gICAgaWYgKGJpbmRUbyA9PT0gdm9pZCAwKSB7IGJpbmRUbyA9IHRoaXM7IH1cbiAgICBpZiAoYXJnc051bSA9PT0gdm9pZCAwKSB7IGFyZ3NOdW0gPSBsaXN0ZW5lci5sZW5ndGg7IH1cbiAgICBpZiAoIXRoaXMuYm91bmRGdW5jcylcbiAgICAgICAgdGhpcy5ib3VuZEZ1bmNzID0gbmV3IE1hcDtcbiAgICB2YXIgYm91bmQgPSBsaXN0ZW5lci5iaW5kKGJpbmRUbyk7XG4gICAgdGhpcy5ib3VuZEZ1bmNzLnNldChsaXN0ZW5lciwgYm91bmQpO1xuICAgIHJldHVybiB0aGlzLmFkZExpc3RlbmVyKGV2ZW50LCBib3VuZCwgYXJnc051bSk7XG59XG5mdW5jdGlvbiByZW1vdmVMaXN0ZW5lckJvdW5kKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgIHZhciBfYSwgX2I7XG4gICAgdmFyIGJvdW5kID0gKF9hID0gdGhpcy5ib3VuZEZ1bmNzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0KGxpc3RlbmVyKTtcbiAgICAoX2IgPSB0aGlzLmJvdW5kRnVuY3MpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kZWxldGUobGlzdGVuZXIpO1xuICAgIHJldHVybiB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBib3VuZCk7XG59XG5mdW5jdGlvbiBoYXNMaXN0ZW5lcnMoZXZlbnQpIHtcbiAgICByZXR1cm4gdGhpcy5ldmVudHNbZXZlbnRdICYmICEhdGhpcy5ldmVudHNbZXZlbnRdLmxlbmd0aDtcbn1cbmZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGFyZ3NOdW0pIHtcbiAgICBpZiAoYXJnc051bSA9PT0gdm9pZCAwKSB7IGFyZ3NOdW0gPSBsaXN0ZW5lci5sZW5ndGg7IH1cbiAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgdmFyIGV2dG1hcCA9IHRoaXMuZXZlbnRzW2V2ZW50XTtcbiAgICBpZiAoIWV2dG1hcCB8fCAhKGV2dG1hcCBpbnN0YW5jZW9mIHRhc2tfY29sbGVjdGlvbl8xLlRhc2tDb2xsZWN0aW9uKSkge1xuICAgICAgICBldnRtYXAgPSB0aGlzLmV2ZW50c1tldmVudF0gPSBuZXcgdGFza19jb2xsZWN0aW9uXzEuVGFza0NvbGxlY3Rpb24oYXJnc051bSwgdHJ1ZSwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgICAgICAgaWYgKHR5cGVvZiBldmVudCA9PT0gJ3N5bWJvbCcpXG4gICAgICAgICAgICB0aGlzLl9zeW1ib2xLZXlzLmFkZChldmVudCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBldnRtYXAuaW5zZXJ0KDAsIGxpc3RlbmVyKTtcbiAgICAgICAgZXZ0bWFwLmdyb3dBcmdzTnVtKGFyZ3NOdW0pO1xuICAgICAgICBpZiAodGhpcy5tYXhMaXN0ZW5lcnMgIT09IEluZmluaXR5ICYmIHRoaXMubWF4TGlzdGVuZXJzIDw9IGV2dG1hcC5sZW5ndGgpXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJNYXhpbXVtIGV2ZW50IGxpc3RlbmVycyBmb3IgXFxcIlwiLmNvbmNhdChTdHJpbmcoZXZlbnQpLCBcIlxcXCIgZXZlbnQhXCIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59XG5mdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgIGlmICh0aGlzLmVtaXQgPT09IGVtaXQpIHtcbiAgICAgICAgdGhpcy5lbWl0ID0gZW1pdEhhc09uY2U7XG4gICAgfVxuICAgIHZhciBldnRtYXAgPSB0aGlzLm9uY2VFdmVudHNbZXZlbnRdO1xuICAgIGlmICghZXZ0bWFwKSB7XG4gICAgICAgIHRoaXMub25jZUV2ZW50c1tldmVudF0gPSBbbGlzdGVuZXJdO1xuICAgICAgICBpZiAodHlwZW9mIGV2ZW50ID09PSAnc3ltYm9sJylcbiAgICAgICAgICAgIHRoaXMuX3N5bWJvbEtleXMuYWRkKGV2ZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGV2dG1hcCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhpcy5vbmNlRXZlbnRzW2V2ZW50XSA9IFtsaXN0ZW5lciwgZXZ0bWFwXTtcbiAgICAgICAgaWYgKHR5cGVvZiBldmVudCA9PT0gJ3N5bWJvbCcpXG4gICAgICAgICAgICB0aGlzLl9zeW1ib2xLZXlzLmFkZChldmVudCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBldnRtYXAudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgICAgIGlmICh0aGlzLm1heExpc3RlbmVycyAhPT0gSW5maW5pdHkgJiYgdGhpcy5tYXhMaXN0ZW5lcnMgPD0gZXZ0bWFwLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiTWF4aW11bSBldmVudCBsaXN0ZW5lcnMgZm9yIFxcXCJcIi5jb25jYXQoU3RyaW5nKGV2ZW50KSwgXCJcXFwiIG9uY2UgZXZlbnQhXCIpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn1cbmZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyhldmVudCkge1xuICAgIGlmIChldmVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuZXZlbnRzID0gKDAsIHV0aWxzXzIubnVsbE9iaikoKTtcbiAgICAgICAgdGhpcy5vbmNlRXZlbnRzID0gKDAsIHV0aWxzXzIubnVsbE9iaikoKTtcbiAgICAgICAgdGhpcy5fc3ltYm9sS2V5cyA9IG5ldyBTZXQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLmV2ZW50c1tldmVudF0gPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMub25jZUV2ZW50c1tldmVudF0gPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh0eXBlb2YgZXZlbnQgPT09ICdzeW1ib2wnKVxuICAgICAgICAgICAgdGhpcy5fc3ltYm9sS2V5cy5kZWxldGUoZXZlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn1cbmZ1bmN0aW9uIHNldE1heExpc3RlbmVycyhuKSB7XG4gICAgdGhpcy5tYXhMaXN0ZW5lcnMgPSBuO1xuICAgIHJldHVybiB0aGlzO1xufVxuZnVuY3Rpb24gZ2V0TWF4TGlzdGVuZXJzKCkge1xuICAgIHJldHVybiB0aGlzLm1heExpc3RlbmVycztcbn1cbmZ1bmN0aW9uIGxpc3RlbmVycyhldmVudCkge1xuICAgIGlmICh0aGlzLmVtaXQgPT09IGVtaXQpXG4gICAgICAgIHJldHVybiB0aGlzLmV2ZW50c1tldmVudF0gPyB0aGlzLmV2ZW50c1tldmVudF0udGFza3NBc0FycmF5KCkuc2xpY2UoKSA6IFtdO1xuICAgIGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5ldmVudHNbZXZlbnRdICYmIHRoaXMub25jZUV2ZW50c1tldmVudF0pIHtcbiAgICAgICAgICAgIHJldHVybiBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIHRoaXMuZXZlbnRzW2V2ZW50XS50YXNrc0FzQXJyYXkoKSwgdHJ1ZSksICh0eXBlb2YgdGhpcy5vbmNlRXZlbnRzW2V2ZW50XSA9PT0gJ2Z1bmN0aW9uJyA/IFt0aGlzLm9uY2VFdmVudHNbZXZlbnRdXSA6IHRoaXMub25jZUV2ZW50c1tldmVudF0pLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmV2ZW50c1tldmVudF0pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ldmVudHNbZXZlbnRdLnRhc2tzQXNBcnJheSgpO1xuICAgICAgICBlbHNlIGlmICh0aGlzLm9uY2VFdmVudHNbZXZlbnRdKVxuICAgICAgICAgICAgcmV0dXJuICh0eXBlb2YgdGhpcy5vbmNlRXZlbnRzW2V2ZW50XSA9PT0gJ2Z1bmN0aW9uJyA/IFt0aGlzLm9uY2VFdmVudHNbZXZlbnRdXSA6IHRoaXMub25jZUV2ZW50c1tldmVudF0pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgfVxufVxuZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIGlmICh0aGlzLmVtaXQgPT09IGVtaXQpIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLmV2ZW50cyk7XG4gICAgICAgIHJldHVybiBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIGtleXMsIHRydWUpLCBBcnJheS5mcm9tKHRoaXMuX3N5bWJvbEtleXMpLCB0cnVlKS5maWx0ZXIoZnVuY3Rpb24gKHgpIHsgcmV0dXJuICh4IGluIF90aGlzLmV2ZW50cykgJiYgX3RoaXMuZXZlbnRzW3hdICYmIF90aGlzLmV2ZW50c1t4XS5sZW5ndGg7IH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLmV2ZW50cykuZmlsdGVyKGZ1bmN0aW9uICh4KSB7IHJldHVybiBfdGhpcy5ldmVudHNbeF0gJiYgX3RoaXMuZXZlbnRzW3hdLmxlbmd0aDsgfSk7XG4gICAgICAgIHZhciBrZXlzTyA9IE9iamVjdC5rZXlzKHRoaXMub25jZUV2ZW50cykuZmlsdGVyKGZ1bmN0aW9uICh4KSB7IHJldHVybiBfdGhpcy5vbmNlRXZlbnRzW3hdICYmIF90aGlzLm9uY2VFdmVudHNbeF0ubGVuZ3RoOyB9KTtcbiAgICAgICAgcmV0dXJuIF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBrZXlzLCB0cnVlKSwga2V5c08sIHRydWUpLCBBcnJheS5mcm9tKHRoaXMuX3N5bWJvbEtleXMpLmZpbHRlcihmdW5jdGlvbiAoeCkgeyByZXR1cm4gKCgoeCBpbiBfdGhpcy5ldmVudHMpICYmIF90aGlzLmV2ZW50c1t4XSAmJiBfdGhpcy5ldmVudHNbeF0ubGVuZ3RoKSB8fFxuICAgICAgICAgICAgKCh4IGluIF90aGlzLm9uY2VFdmVudHMpICYmIF90aGlzLm9uY2VFdmVudHNbeF0gJiYgX3RoaXMub25jZUV2ZW50c1t4XS5sZW5ndGgpKTsgfSksIHRydWUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGxpc3RlbmVyQ291bnQodHlwZSkge1xuICAgIGlmICh0aGlzLmVtaXQgPT09IGVtaXQpXG4gICAgICAgIHJldHVybiB0aGlzLmV2ZW50c1t0eXBlXSAmJiB0aGlzLmV2ZW50c1t0eXBlXS5sZW5ndGggfHwgMDtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiAodGhpcy5ldmVudHNbdHlwZV0gJiYgdGhpcy5ldmVudHNbdHlwZV0ubGVuZ3RoIHx8IDApICsgKHRoaXMub25jZUV2ZW50c1t0eXBlXSAmJiB0aGlzLm9uY2VFdmVudHNbdHlwZV0ubGVuZ3RoIHx8IDApO1xufVxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZW1pdDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBhZGRMaXN0ZW5lcjtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IG9uY2U7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gYWRkTGlzdGVuZXI7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gcmVtb3ZlTGlzdGVuZXI7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyQm91bmQgPSBhZGRMaXN0ZW5lckJvdW5kO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lckJvdW5kID0gcmVtb3ZlTGlzdGVuZXJCb3VuZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuaGFzTGlzdGVuZXJzID0gaGFzTGlzdGVuZXJzO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPSBwcmVwZW5kTGlzdGVuZXI7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBwcmVwZW5kT25jZUxpc3RlbmVyO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSByZW1vdmVMaXN0ZW5lcjtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gcmVtb3ZlQWxsTGlzdGVuZXJzO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBzZXRNYXhMaXN0ZW5lcnM7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldE1heExpc3RlbmVycyA9IGdldE1heExpc3RlbmVycztcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZXZlbnROYW1lcztcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGxpc3RlbmVyQ291bnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tseep/lib/ee.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tseep/lib/index.js":
/*!*****************************************!*\
  !*** ./node_modules/tseep/lib/index.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./types */ \"(app-pages-browser)/./node_modules/tseep/lib/types.js\"), exports);\n__exportStar(__webpack_require__(/*! ./ee */ \"(app-pages-browser)/./node_modules/tseep/lib/ee.js\"), exports);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90c2VlcC9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxtQkFBTyxDQUFDLHNFQUFTO0FBQzlCLGFBQWEsbUJBQU8sQ0FBQyxnRUFBTTtBQUMzQiIsInNvdXJjZXMiOlsiL2hvbWUvbGZnL0dpdC9NYWR0cmlwcy9ub2RlX21vZHVsZXMvdHNlZXAvbGliL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHlwZXNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2VlXCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tseep/lib/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tseep/lib/task-collection/bake-collection.js":
/*!*******************************************************************!*\
  !*** ./node_modules/tseep/lib/task-collection/bake-collection.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.bakeCollectionVariadic = exports.bakeCollectionAwait = exports.bakeCollection = exports.BAKED_EMPTY_FUNC = void 0;\nexports.BAKED_EMPTY_FUNC = (function () { });\nvar FORLOOP_FALLBACK = 1500;\nfunction generateArgsDefCode(numArgs) {\n    var argsDefCode = '';\n    if (numArgs === 0)\n        return argsDefCode;\n    for (var i = 0; i < numArgs - 1; ++i) {\n        argsDefCode += ('arg' + String(i) + ', ');\n    }\n    argsDefCode += ('arg' + String(numArgs - 1));\n    return argsDefCode;\n}\nfunction generateBodyPartsCode(argsDefCode, collectionLength) {\n    var funcDefCode = '', funcCallCode = '';\n    for (var i = 0; i < collectionLength; ++i) {\n        funcDefCode += \"var f\".concat(i, \" = collection[\").concat(i, \"];\\n\");\n        funcCallCode += \"f\".concat(i, \"(\").concat(argsDefCode, \")\\n\");\n    }\n    return { funcDefCode: funcDefCode, funcCallCode: funcCallCode };\n}\nfunction generateBodyPartsVariadicCode(collectionLength) {\n    var funcDefCode = '', funcCallCode = '';\n    for (var i = 0; i < collectionLength; ++i) {\n        funcDefCode += \"var f\".concat(i, \" = collection[\").concat(i, \"];\\n\");\n        funcCallCode += \"f\".concat(i, \".apply(undefined, arguments)\\n\");\n    }\n    return { funcDefCode: funcDefCode, funcCallCode: funcCallCode };\n}\nfunction bakeCollection(collection, fixedArgsNum) {\n    if (collection.length === 0)\n        return exports.BAKED_EMPTY_FUNC;\n    else if (collection.length === 1)\n        return collection[0];\n    var funcFactoryCode;\n    if (collection.length < FORLOOP_FALLBACK) {\n        var argsDefCode = generateArgsDefCode(fixedArgsNum);\n        var _a = generateBodyPartsCode(argsDefCode, collection.length), funcDefCode = _a.funcDefCode, funcCallCode = _a.funcCallCode;\n        funcFactoryCode = \"(function(collection) {\\n            \".concat(funcDefCode, \"\\n            collection = undefined;\\n            return (function(\").concat(argsDefCode, \") {\\n                \").concat(funcCallCode, \"\\n            });\\n        })\");\n    }\n    else {\n        var argsDefCode = generateArgsDefCode(fixedArgsNum);\n        // loop unroll\n        if (collection.length % 10 === 0) {\n            funcFactoryCode = \"(function(collection) {\\n                return (function(\".concat(argsDefCode, \") {\\n                    for (var i = 0; i < collection.length; i += 10) {\\n                        collection[i](\").concat(argsDefCode, \");\\n                        collection[i+1](\").concat(argsDefCode, \");\\n                        collection[i+2](\").concat(argsDefCode, \");\\n                        collection[i+3](\").concat(argsDefCode, \");\\n                        collection[i+4](\").concat(argsDefCode, \");\\n                        collection[i+5](\").concat(argsDefCode, \");\\n                        collection[i+6](\").concat(argsDefCode, \");\\n                        collection[i+7](\").concat(argsDefCode, \");\\n                        collection[i+8](\").concat(argsDefCode, \");\\n                        collection[i+9](\").concat(argsDefCode, \");\\n                    }\\n                });\\n            })\");\n        }\n        else if (collection.length % 4 === 0) {\n            funcFactoryCode = \"(function(collection) {\\n                return (function(\".concat(argsDefCode, \") {\\n                    for (var i = 0; i < collection.length; i += 4) {\\n                        collection[i](\").concat(argsDefCode, \");\\n                        collection[i+1](\").concat(argsDefCode, \");\\n                        collection[i+2](\").concat(argsDefCode, \");\\n                        collection[i+3](\").concat(argsDefCode, \");\\n                    }\\n                });\\n            })\");\n        }\n        else if (collection.length % 3 === 0) {\n            funcFactoryCode = \"(function(collection) {\\n                return (function(\".concat(argsDefCode, \") {\\n                    for (var i = 0; i < collection.length; i += 3) {\\n                        collection[i](\").concat(argsDefCode, \");\\n                        collection[i+1](\").concat(argsDefCode, \");\\n                        collection[i+2](\").concat(argsDefCode, \");\\n                    }\\n                });\\n            })\");\n        }\n        else {\n            funcFactoryCode = \"(function(collection) {\\n                return (function(\".concat(argsDefCode, \") {\\n                    for (var i = 0; i < collection.length; ++i) {\\n                        collection[i](\").concat(argsDefCode, \");\\n                    }\\n                });\\n            })\");\n        }\n    }\n    {\n        // isolate\n        var bakeCollection_1 = undefined;\n        var fixedArgsNum_1 = undefined;\n        var bakeCollectionVariadic_1 = undefined;\n        var bakeCollectionAwait_1 = undefined;\n        var funcFactory = eval(funcFactoryCode);\n        return funcFactory(collection);\n    }\n}\nexports.bakeCollection = bakeCollection;\nfunction bakeCollectionAwait(collection, fixedArgsNum) {\n    if (collection.length === 0)\n        return exports.BAKED_EMPTY_FUNC;\n    else if (collection.length === 1)\n        return collection[0];\n    var funcFactoryCode;\n    if (collection.length < FORLOOP_FALLBACK) {\n        var argsDefCode = generateArgsDefCode(fixedArgsNum);\n        var _a = generateBodyPartsCode(argsDefCode, collection.length), funcDefCode = _a.funcDefCode, funcCallCode = _a.funcCallCode;\n        funcFactoryCode = \"(function(collection) {\\n            \".concat(funcDefCode, \"\\n            collection = undefined;\\n            return (function(\").concat(argsDefCode, \") {\\n                return Promise.all([ \").concat(funcCallCode, \" ]);\\n            });\\n        })\");\n    }\n    else {\n        var argsDefCode = generateArgsDefCode(fixedArgsNum);\n        funcFactoryCode = \"(function(collection) {\\n            return (function(\".concat(argsDefCode, \") {\\n                var promises = Array(collection.length);\\n                for (var i = 0; i < collection.length; ++i) {\\n                    promises[i] = collection[i](\").concat(argsDefCode, \");\\n                }\\n                return Promise.all(promises);\\n            });\\n        })\");\n    }\n    {\n        // isolate\n        var bakeCollection_2 = undefined;\n        var fixedArgsNum_2 = undefined;\n        var bakeCollectionVariadic_2 = undefined;\n        var bakeCollectionAwait_2 = undefined;\n        var funcFactory = eval(funcFactoryCode);\n        return funcFactory(collection);\n    }\n}\nexports.bakeCollectionAwait = bakeCollectionAwait;\nfunction bakeCollectionVariadic(collection) {\n    if (collection.length === 0)\n        return exports.BAKED_EMPTY_FUNC;\n    else if (collection.length === 1)\n        return collection[0];\n    var funcFactoryCode;\n    if (collection.length < FORLOOP_FALLBACK) {\n        var _a = generateBodyPartsVariadicCode(collection.length), funcDefCode = _a.funcDefCode, funcCallCode = _a.funcCallCode;\n        funcFactoryCode = \"(function(collection) {\\n            \".concat(funcDefCode, \"\\n            collection = undefined;\\n            return (function() {\\n                \").concat(funcCallCode, \"\\n            });\\n        })\");\n    }\n    else {\n        funcFactoryCode = \"(function(collection) {\\n            return (function() {\\n                for (var i = 0; i < collection.length; ++i) {\\n                    collection[i].apply(undefined, arguments);\\n                }\\n            });\\n        })\";\n    }\n    {\n        // isolate\n        var bakeCollection_3 = undefined;\n        var fixedArgsNum = undefined;\n        var bakeCollectionVariadic_3 = undefined;\n        var bakeCollectionAwait_3 = undefined;\n        var funcFactory = eval(funcFactoryCode);\n        return funcFactory(collection);\n    }\n}\nexports.bakeCollectionVariadic = bakeCollectionVariadic;\n//# sourceMappingURL=bake-collection.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90c2VlcC9saWIvdGFzay1jb2xsZWN0aW9uL2Jha2UtY29sbGVjdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw4QkFBOEIsR0FBRywyQkFBMkIsR0FBRyxzQkFBc0IsR0FBRyx3QkFBd0I7QUFDaEgsd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUMsd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQyx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCwwRUFBMEUsMERBQTBELDBEQUEwRCxFQUFFLFdBQVc7QUFDN1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCw2REFBNkQsc0NBQXNDLHVCQUF1QixVQUFVLGtFQUFrRSxvRUFBb0Usb0VBQW9FLG9FQUFvRSxvRUFBb0Usb0VBQW9FLG9FQUFvRSxvRUFBb0Usb0VBQW9FLG9FQUFvRSx1QkFBdUIsbUJBQW1CLEVBQUUsZUFBZTtBQUMzNUI7QUFDQTtBQUNBLHNEQUFzRCw2REFBNkQsc0NBQXNDLHVCQUF1QixTQUFTLGtFQUFrRSxvRUFBb0Usb0VBQW9FLG9FQUFvRSx1QkFBdUIsbUJBQW1CLEVBQUUsZUFBZTtBQUNsZ0I7QUFDQTtBQUNBLHNEQUFzRCw2REFBNkQsc0NBQXNDLHVCQUF1QixTQUFTLGtFQUFrRSxvRUFBb0Usb0VBQW9FLHVCQUF1QixtQkFBbUIsRUFBRSxlQUFlO0FBQzliO0FBQ0E7QUFDQSxzREFBc0QsNkRBQTZELHNDQUFzQyx1QkFBdUIsTUFBTSxrRUFBa0UsdUJBQXVCLG1CQUFtQixFQUFFLGVBQWU7QUFDblQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCwwRUFBMEUsMERBQTBELG9FQUFvRSxlQUFlLEVBQUUsV0FBVztBQUN0UjtBQUNBO0FBQ0E7QUFDQSxrREFBa0QseURBQXlELDBEQUEwRCxrQ0FBa0MsdUJBQXVCLE1BQU0sNEVBQTRFLG1CQUFtQiwrQ0FBK0MsZUFBZSxFQUFFLFdBQVc7QUFDOVk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELDBFQUEwRSxrQ0FBa0MsMERBQTBELEVBQUUsV0FBVztBQUNyTztBQUNBO0FBQ0Esa0RBQWtELGtDQUFrQyxrQ0FBa0MsdUJBQXVCLE1BQU0sZ0VBQWdFLG1CQUFtQixlQUFlLEVBQUUsV0FBVztBQUNsUTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCIiwic291cmNlcyI6WyIvaG9tZS9sZmcvR2l0L01hZHRyaXBzL25vZGVfbW9kdWxlcy90c2VlcC9saWIvdGFzay1jb2xsZWN0aW9uL2Jha2UtY29sbGVjdGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYmFrZUNvbGxlY3Rpb25WYXJpYWRpYyA9IGV4cG9ydHMuYmFrZUNvbGxlY3Rpb25Bd2FpdCA9IGV4cG9ydHMuYmFrZUNvbGxlY3Rpb24gPSBleHBvcnRzLkJBS0VEX0VNUFRZX0ZVTkMgPSB2b2lkIDA7XG5leHBvcnRzLkJBS0VEX0VNUFRZX0ZVTkMgPSAoZnVuY3Rpb24gKCkgeyB9KTtcbnZhciBGT1JMT09QX0ZBTExCQUNLID0gMTUwMDtcbmZ1bmN0aW9uIGdlbmVyYXRlQXJnc0RlZkNvZGUobnVtQXJncykge1xuICAgIHZhciBhcmdzRGVmQ29kZSA9ICcnO1xuICAgIGlmIChudW1BcmdzID09PSAwKVxuICAgICAgICByZXR1cm4gYXJnc0RlZkNvZGU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1BcmdzIC0gMTsgKytpKSB7XG4gICAgICAgIGFyZ3NEZWZDb2RlICs9ICgnYXJnJyArIFN0cmluZyhpKSArICcsICcpO1xuICAgIH1cbiAgICBhcmdzRGVmQ29kZSArPSAoJ2FyZycgKyBTdHJpbmcobnVtQXJncyAtIDEpKTtcbiAgICByZXR1cm4gYXJnc0RlZkNvZGU7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZUJvZHlQYXJ0c0NvZGUoYXJnc0RlZkNvZGUsIGNvbGxlY3Rpb25MZW5ndGgpIHtcbiAgICB2YXIgZnVuY0RlZkNvZGUgPSAnJywgZnVuY0NhbGxDb2RlID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xsZWN0aW9uTGVuZ3RoOyArK2kpIHtcbiAgICAgICAgZnVuY0RlZkNvZGUgKz0gXCJ2YXIgZlwiLmNvbmNhdChpLCBcIiA9IGNvbGxlY3Rpb25bXCIpLmNvbmNhdChpLCBcIl07XFxuXCIpO1xuICAgICAgICBmdW5jQ2FsbENvZGUgKz0gXCJmXCIuY29uY2F0KGksIFwiKFwiKS5jb25jYXQoYXJnc0RlZkNvZGUsIFwiKVxcblwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgZnVuY0RlZkNvZGU6IGZ1bmNEZWZDb2RlLCBmdW5jQ2FsbENvZGU6IGZ1bmNDYWxsQ29kZSB9O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVCb2R5UGFydHNWYXJpYWRpY0NvZGUoY29sbGVjdGlvbkxlbmd0aCkge1xuICAgIHZhciBmdW5jRGVmQ29kZSA9ICcnLCBmdW5jQ2FsbENvZGUgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbGxlY3Rpb25MZW5ndGg7ICsraSkge1xuICAgICAgICBmdW5jRGVmQ29kZSArPSBcInZhciBmXCIuY29uY2F0KGksIFwiID0gY29sbGVjdGlvbltcIikuY29uY2F0KGksIFwiXTtcXG5cIik7XG4gICAgICAgIGZ1bmNDYWxsQ29kZSArPSBcImZcIi5jb25jYXQoaSwgXCIuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpXFxuXCIpO1xuICAgIH1cbiAgICByZXR1cm4geyBmdW5jRGVmQ29kZTogZnVuY0RlZkNvZGUsIGZ1bmNDYWxsQ29kZTogZnVuY0NhbGxDb2RlIH07XG59XG5mdW5jdGlvbiBiYWtlQ29sbGVjdGlvbihjb2xsZWN0aW9uLCBmaXhlZEFyZ3NOdW0pIHtcbiAgICBpZiAoY29sbGVjdGlvbi5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiBleHBvcnRzLkJBS0VEX0VNUFRZX0ZVTkM7XG4gICAgZWxzZSBpZiAoY29sbGVjdGlvbi5sZW5ndGggPT09IDEpXG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uWzBdO1xuICAgIHZhciBmdW5jRmFjdG9yeUNvZGU7XG4gICAgaWYgKGNvbGxlY3Rpb24ubGVuZ3RoIDwgRk9STE9PUF9GQUxMQkFDSykge1xuICAgICAgICB2YXIgYXJnc0RlZkNvZGUgPSBnZW5lcmF0ZUFyZ3NEZWZDb2RlKGZpeGVkQXJnc051bSk7XG4gICAgICAgIHZhciBfYSA9IGdlbmVyYXRlQm9keVBhcnRzQ29kZShhcmdzRGVmQ29kZSwgY29sbGVjdGlvbi5sZW5ndGgpLCBmdW5jRGVmQ29kZSA9IF9hLmZ1bmNEZWZDb2RlLCBmdW5jQ2FsbENvZGUgPSBfYS5mdW5jQ2FsbENvZGU7XG4gICAgICAgIGZ1bmNGYWN0b3J5Q29kZSA9IFwiKGZ1bmN0aW9uKGNvbGxlY3Rpb24pIHtcXG4gICAgICAgICAgICBcIi5jb25jYXQoZnVuY0RlZkNvZGUsIFwiXFxuICAgICAgICAgICAgY29sbGVjdGlvbiA9IHVuZGVmaW5lZDtcXG4gICAgICAgICAgICByZXR1cm4gKGZ1bmN0aW9uKFwiKS5jb25jYXQoYXJnc0RlZkNvZGUsIFwiKSB7XFxuICAgICAgICAgICAgICAgIFwiKS5jb25jYXQoZnVuY0NhbGxDb2RlLCBcIlxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgfSlcIik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgYXJnc0RlZkNvZGUgPSBnZW5lcmF0ZUFyZ3NEZWZDb2RlKGZpeGVkQXJnc051bSk7XG4gICAgICAgIC8vIGxvb3AgdW5yb2xsXG4gICAgICAgIGlmIChjb2xsZWN0aW9uLmxlbmd0aCAlIDEwID09PSAwKSB7XG4gICAgICAgICAgICBmdW5jRmFjdG9yeUNvZGUgPSBcIihmdW5jdGlvbihjb2xsZWN0aW9uKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiAoZnVuY3Rpb24oXCIuY29uY2F0KGFyZ3NEZWZDb2RlLCBcIikge1xcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xsZWN0aW9uLmxlbmd0aDsgaSArPSAxMCkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25baV0oXCIpLmNvbmNhdChhcmdzRGVmQ29kZSwgXCIpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25baSsxXShcIikuY29uY2F0KGFyZ3NEZWZDb2RlLCBcIik7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbltpKzJdKFwiKS5jb25jYXQoYXJnc0RlZkNvZGUsIFwiKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uW2krM10oXCIpLmNvbmNhdChhcmdzRGVmQ29kZSwgXCIpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25baSs0XShcIikuY29uY2F0KGFyZ3NEZWZDb2RlLCBcIik7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbltpKzVdKFwiKS5jb25jYXQoYXJnc0RlZkNvZGUsIFwiKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uW2krNl0oXCIpLmNvbmNhdChhcmdzRGVmQ29kZSwgXCIpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25baSs3XShcIikuY29uY2F0KGFyZ3NEZWZDb2RlLCBcIik7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbltpKzhdKFwiKS5jb25jYXQoYXJnc0RlZkNvZGUsIFwiKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uW2krOV0oXCIpLmNvbmNhdChhcmdzRGVmQ29kZSwgXCIpO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICB9KVwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb2xsZWN0aW9uLmxlbmd0aCAlIDQgPT09IDApIHtcbiAgICAgICAgICAgIGZ1bmNGYWN0b3J5Q29kZSA9IFwiKGZ1bmN0aW9uKGNvbGxlY3Rpb24pIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIChmdW5jdGlvbihcIi5jb25jYXQoYXJnc0RlZkNvZGUsIFwiKSB7XFxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbGxlY3Rpb24ubGVuZ3RoOyBpICs9IDQpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uW2ldKFwiKS5jb25jYXQoYXJnc0RlZkNvZGUsIFwiKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uW2krMV0oXCIpLmNvbmNhdChhcmdzRGVmQ29kZSwgXCIpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25baSsyXShcIikuY29uY2F0KGFyZ3NEZWZDb2RlLCBcIik7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbltpKzNdKFwiKS5jb25jYXQoYXJnc0RlZkNvZGUsIFwiKTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgfSlcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29sbGVjdGlvbi5sZW5ndGggJSAzID09PSAwKSB7XG4gICAgICAgICAgICBmdW5jRmFjdG9yeUNvZGUgPSBcIihmdW5jdGlvbihjb2xsZWN0aW9uKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiAoZnVuY3Rpb24oXCIuY29uY2F0KGFyZ3NEZWZDb2RlLCBcIikge1xcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xsZWN0aW9uLmxlbmd0aDsgaSArPSAzKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbltpXShcIikuY29uY2F0KGFyZ3NEZWZDb2RlLCBcIik7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbltpKzFdKFwiKS5jb25jYXQoYXJnc0RlZkNvZGUsIFwiKTtcXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uW2krMl0oXCIpLmNvbmNhdChhcmdzRGVmQ29kZSwgXCIpO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICB9KVwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZ1bmNGYWN0b3J5Q29kZSA9IFwiKGZ1bmN0aW9uKGNvbGxlY3Rpb24pIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIChmdW5jdGlvbihcIi5jb25jYXQoYXJnc0RlZkNvZGUsIFwiKSB7XFxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbGxlY3Rpb24ubGVuZ3RoOyArK2kpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uW2ldKFwiKS5jb25jYXQoYXJnc0RlZkNvZGUsIFwiKTtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgfSlcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAge1xuICAgICAgICAvLyBpc29sYXRlXG4gICAgICAgIHZhciBiYWtlQ29sbGVjdGlvbl8xID0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgZml4ZWRBcmdzTnVtXzEgPSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBiYWtlQ29sbGVjdGlvblZhcmlhZGljXzEgPSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBiYWtlQ29sbGVjdGlvbkF3YWl0XzEgPSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBmdW5jRmFjdG9yeSA9IGV2YWwoZnVuY0ZhY3RvcnlDb2RlKTtcbiAgICAgICAgcmV0dXJuIGZ1bmNGYWN0b3J5KGNvbGxlY3Rpb24pO1xuICAgIH1cbn1cbmV4cG9ydHMuYmFrZUNvbGxlY3Rpb24gPSBiYWtlQ29sbGVjdGlvbjtcbmZ1bmN0aW9uIGJha2VDb2xsZWN0aW9uQXdhaXQoY29sbGVjdGlvbiwgZml4ZWRBcmdzTnVtKSB7XG4gICAgaWYgKGNvbGxlY3Rpb24ubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gZXhwb3J0cy5CQUtFRF9FTVBUWV9GVU5DO1xuICAgIGVsc2UgaWYgKGNvbGxlY3Rpb24ubGVuZ3RoID09PSAxKVxuICAgICAgICByZXR1cm4gY29sbGVjdGlvblswXTtcbiAgICB2YXIgZnVuY0ZhY3RvcnlDb2RlO1xuICAgIGlmIChjb2xsZWN0aW9uLmxlbmd0aCA8IEZPUkxPT1BfRkFMTEJBQ0spIHtcbiAgICAgICAgdmFyIGFyZ3NEZWZDb2RlID0gZ2VuZXJhdGVBcmdzRGVmQ29kZShmaXhlZEFyZ3NOdW0pO1xuICAgICAgICB2YXIgX2EgPSBnZW5lcmF0ZUJvZHlQYXJ0c0NvZGUoYXJnc0RlZkNvZGUsIGNvbGxlY3Rpb24ubGVuZ3RoKSwgZnVuY0RlZkNvZGUgPSBfYS5mdW5jRGVmQ29kZSwgZnVuY0NhbGxDb2RlID0gX2EuZnVuY0NhbGxDb2RlO1xuICAgICAgICBmdW5jRmFjdG9yeUNvZGUgPSBcIihmdW5jdGlvbihjb2xsZWN0aW9uKSB7XFxuICAgICAgICAgICAgXCIuY29uY2F0KGZ1bmNEZWZDb2RlLCBcIlxcbiAgICAgICAgICAgIGNvbGxlY3Rpb24gPSB1bmRlZmluZWQ7XFxuICAgICAgICAgICAgcmV0dXJuIChmdW5jdGlvbihcIikuY29uY2F0KGFyZ3NEZWZDb2RlLCBcIikge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoWyBcIikuY29uY2F0KGZ1bmNDYWxsQ29kZSwgXCIgXSk7XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICB9KVwiKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBhcmdzRGVmQ29kZSA9IGdlbmVyYXRlQXJnc0RlZkNvZGUoZml4ZWRBcmdzTnVtKTtcbiAgICAgICAgZnVuY0ZhY3RvcnlDb2RlID0gXCIoZnVuY3Rpb24oY29sbGVjdGlvbikge1xcbiAgICAgICAgICAgIHJldHVybiAoZnVuY3Rpb24oXCIuY29uY2F0KGFyZ3NEZWZDb2RlLCBcIikge1xcbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZXMgPSBBcnJheShjb2xsZWN0aW9uLmxlbmd0aCk7XFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sbGVjdGlvbi5sZW5ndGg7ICsraSkge1xcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXNbaV0gPSBjb2xsZWN0aW9uW2ldKFwiKS5jb25jYXQoYXJnc0RlZkNvZGUsIFwiKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgfSlcIik7XG4gICAgfVxuICAgIHtcbiAgICAgICAgLy8gaXNvbGF0ZVxuICAgICAgICB2YXIgYmFrZUNvbGxlY3Rpb25fMiA9IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGZpeGVkQXJnc051bV8yID0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgYmFrZUNvbGxlY3Rpb25WYXJpYWRpY18yID0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgYmFrZUNvbGxlY3Rpb25Bd2FpdF8yID0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgZnVuY0ZhY3RvcnkgPSBldmFsKGZ1bmNGYWN0b3J5Q29kZSk7XG4gICAgICAgIHJldHVybiBmdW5jRmFjdG9yeShjb2xsZWN0aW9uKTtcbiAgICB9XG59XG5leHBvcnRzLmJha2VDb2xsZWN0aW9uQXdhaXQgPSBiYWtlQ29sbGVjdGlvbkF3YWl0O1xuZnVuY3Rpb24gYmFrZUNvbGxlY3Rpb25WYXJpYWRpYyhjb2xsZWN0aW9uKSB7XG4gICAgaWYgKGNvbGxlY3Rpb24ubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gZXhwb3J0cy5CQUtFRF9FTVBUWV9GVU5DO1xuICAgIGVsc2UgaWYgKGNvbGxlY3Rpb24ubGVuZ3RoID09PSAxKVxuICAgICAgICByZXR1cm4gY29sbGVjdGlvblswXTtcbiAgICB2YXIgZnVuY0ZhY3RvcnlDb2RlO1xuICAgIGlmIChjb2xsZWN0aW9uLmxlbmd0aCA8IEZPUkxPT1BfRkFMTEJBQ0spIHtcbiAgICAgICAgdmFyIF9hID0gZ2VuZXJhdGVCb2R5UGFydHNWYXJpYWRpY0NvZGUoY29sbGVjdGlvbi5sZW5ndGgpLCBmdW5jRGVmQ29kZSA9IF9hLmZ1bmNEZWZDb2RlLCBmdW5jQ2FsbENvZGUgPSBfYS5mdW5jQ2FsbENvZGU7XG4gICAgICAgIGZ1bmNGYWN0b3J5Q29kZSA9IFwiKGZ1bmN0aW9uKGNvbGxlY3Rpb24pIHtcXG4gICAgICAgICAgICBcIi5jb25jYXQoZnVuY0RlZkNvZGUsIFwiXFxuICAgICAgICAgICAgY29sbGVjdGlvbiA9IHVuZGVmaW5lZDtcXG4gICAgICAgICAgICByZXR1cm4gKGZ1bmN0aW9uKCkge1xcbiAgICAgICAgICAgICAgICBcIikuY29uY2F0KGZ1bmNDYWxsQ29kZSwgXCJcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH0pXCIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZnVuY0ZhY3RvcnlDb2RlID0gXCIoZnVuY3Rpb24oY29sbGVjdGlvbikge1xcbiAgICAgICAgICAgIHJldHVybiAoZnVuY3Rpb24oKSB7XFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sbGVjdGlvbi5sZW5ndGg7ICsraSkge1xcbiAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbltpXS5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH0pXCI7XG4gICAgfVxuICAgIHtcbiAgICAgICAgLy8gaXNvbGF0ZVxuICAgICAgICB2YXIgYmFrZUNvbGxlY3Rpb25fMyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGZpeGVkQXJnc051bSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGJha2VDb2xsZWN0aW9uVmFyaWFkaWNfMyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGJha2VDb2xsZWN0aW9uQXdhaXRfMyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGZ1bmNGYWN0b3J5ID0gZXZhbChmdW5jRmFjdG9yeUNvZGUpO1xuICAgICAgICByZXR1cm4gZnVuY0ZhY3RvcnkoY29sbGVjdGlvbik7XG4gICAgfVxufVxuZXhwb3J0cy5iYWtlQ29sbGVjdGlvblZhcmlhZGljID0gYmFrZUNvbGxlY3Rpb25WYXJpYWRpYztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJha2UtY29sbGVjdGlvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tseep/lib/task-collection/bake-collection.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tseep/lib/task-collection/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/tseep/lib/task-collection/index.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./task-collection */ \"(app-pages-browser)/./node_modules/tseep/lib/task-collection/task-collection.js\"), exports);\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90c2VlcC9saWIvdGFzay1jb2xsZWN0aW9uL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsbUJBQU8sQ0FBQywwR0FBbUI7QUFDeEMiLCJzb3VyY2VzIjpbIi9ob21lL2xmZy9HaXQvTWFkdHJpcHMvbm9kZV9tb2R1bGVzL3RzZWVwL2xpYi90YXNrLWNvbGxlY3Rpb24vaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90YXNrLWNvbGxlY3Rpb25cIiksIGV4cG9ydHMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tseep/lib/task-collection/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tseep/lib/task-collection/task-collection.js":
/*!*******************************************************************!*\
  !*** ./node_modules/tseep/lib/task-collection/task-collection.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TaskCollection = void 0;\nvar utils_1 = __webpack_require__(/*! ./utils */ \"(app-pages-browser)/./node_modules/tseep/lib/task-collection/utils.js\");\nvar bake_collection_1 = __webpack_require__(/*! ./bake-collection */ \"(app-pages-browser)/./node_modules/tseep/lib/task-collection/bake-collection.js\");\nfunction push_norebuild(a, b /*, ...func: Func[] */) {\n    var len = this.length;\n    if (len > 1) { // tasks is array\n        if (b) { // if multiple args\n            var _a;\n            (_a = this._tasks).push.apply(_a, arguments);\n            this.length += arguments.length;\n        }\n        else { // if single arg (most often case)\n            this._tasks.push(a);\n            this.length++;\n        }\n    }\n    else { // tasks is (function or null)\n        if (b) { // if multiple args\n            if (len === 1) { // if this._tasks is function\n                var newAr = Array(1 + arguments.length);\n                newAr.push(newAr);\n                newAr.push.apply(newAr, arguments);\n                this._tasks = newAr;\n            }\n            else {\n                var newAr = Array(arguments.length);\n                newAr.push.apply(newAr, arguments);\n                this._tasks = newAr;\n            }\n            this.length += arguments.length;\n        }\n        else { // if single arg (most often case)\n            if (len === 1)\n                this._tasks = [this._tasks, a];\n            else\n                this._tasks = a;\n            this.length++;\n        }\n    }\n}\nfunction push_rebuild(a, b /*, ...func: Func[] */) {\n    var len = this.length;\n    if (len > 1) { // tasks is array\n        if (b) { // if multiple args\n            var _a;\n            (_a = this._tasks).push.apply(_a, arguments);\n            this.length += arguments.length;\n        }\n        else { // if single arg (most often case)\n            this._tasks.push(a);\n            this.length++;\n        }\n    }\n    else { // tasks is (function or null)\n        if (b) { // if multiple args\n            if (len === 1) { // if this._tasks is function\n                var newAr = Array(1 + arguments.length);\n                newAr.push(newAr);\n                newAr.push.apply(newAr, arguments);\n                this._tasks = newAr;\n            }\n            else {\n                var newAr = Array(arguments.length);\n                newAr.push.apply(newAr, arguments);\n                this._tasks = newAr;\n            }\n            this.length += arguments.length;\n        }\n        else { // if single arg (most often case)\n            if (len === 1)\n                this._tasks = [this._tasks, a];\n            else\n                this._tasks = a;\n            this.length++;\n        }\n    }\n    if (this.firstEmitBuildStrategy)\n        this.call = rebuild_on_first_call;\n    else\n        this.rebuild();\n}\nfunction removeLast_norebuild(a) {\n    if (this.length === 0)\n        return;\n    if (this.length === 1) {\n        if (this._tasks === a) {\n            this.length = 0;\n        }\n    }\n    else {\n        (0, utils_1._fast_remove_single)(this._tasks, this._tasks.lastIndexOf(a));\n        if (this._tasks.length === 1) {\n            this._tasks = this._tasks[0];\n            this.length = 1;\n        }\n        else\n            this.length = this._tasks.length;\n    }\n}\nfunction removeLast_rebuild(a) {\n    if (this.length === 0)\n        return;\n    if (this.length === 1) {\n        if (this._tasks === a) {\n            this.length = 0;\n        }\n        if (this.firstEmitBuildStrategy) {\n            this.call = bake_collection_1.BAKED_EMPTY_FUNC;\n            return;\n        }\n        else {\n            this.rebuild();\n            return;\n        }\n    }\n    else {\n        (0, utils_1._fast_remove_single)(this._tasks, this._tasks.lastIndexOf(a));\n        if (this._tasks.length === 1) {\n            this._tasks = this._tasks[0];\n            this.length = 1;\n        }\n        else\n            this.length = this._tasks.length;\n    }\n    if (this.firstEmitBuildStrategy)\n        this.call = rebuild_on_first_call;\n    else\n        this.rebuild();\n}\nfunction insert_norebuild(index) {\n    var _b;\n    var func = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        func[_i - 1] = arguments[_i];\n    }\n    if (this.length === 0) {\n        this._tasks = func;\n        this.length = 1;\n    }\n    else if (this.length === 1) {\n        func.unshift(this._tasks);\n        this._tasks = func;\n        this.length = this._tasks.length;\n    }\n    else {\n        (_b = this._tasks).splice.apply(_b, __spreadArray([index, 0], func, false));\n        this.length = this._tasks.length;\n    }\n}\nfunction insert_rebuild(index) {\n    var _b;\n    var func = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        func[_i - 1] = arguments[_i];\n    }\n    if (this.length === 0) {\n        this._tasks = func;\n        this.length = 1;\n    }\n    else if (this.length === 1) {\n        func.unshift(this._tasks);\n        this._tasks = func;\n        this.length = this._tasks.length;\n    }\n    else {\n        (_b = this._tasks).splice.apply(_b, __spreadArray([index, 0], func, false));\n        this.length = this._tasks.length;\n    }\n    if (this.firstEmitBuildStrategy)\n        this.call = rebuild_on_first_call;\n    else\n        this.rebuild();\n}\nfunction rebuild_noawait() {\n    if (this.length === 0)\n        this.call = bake_collection_1.BAKED_EMPTY_FUNC;\n    else if (this.length === 1)\n        this.call = this._tasks;\n    else\n        this.call = (0, bake_collection_1.bakeCollection)(this._tasks, this.argsNum);\n}\nfunction rebuild_await() {\n    if (this.length === 0)\n        this.call = bake_collection_1.BAKED_EMPTY_FUNC;\n    else if (this.length === 1)\n        this.call = this._tasks;\n    else\n        this.call = (0, bake_collection_1.bakeCollectionAwait)(this._tasks, this.argsNum);\n}\nfunction rebuild_on_first_call() {\n    this.rebuild();\n    this.call.apply(undefined, arguments);\n}\nvar TaskCollection = /** @class */ (function () {\n    function TaskCollection(argsNum, autoRebuild, initialTasks, awaitTasks) {\n        if (autoRebuild === void 0) { autoRebuild = true; }\n        if (initialTasks === void 0) { initialTasks = null; }\n        if (awaitTasks === void 0) { awaitTasks = false; }\n        this.awaitTasks = awaitTasks;\n        this.call = bake_collection_1.BAKED_EMPTY_FUNC;\n        this.argsNum = argsNum;\n        this.firstEmitBuildStrategy = true;\n        if (awaitTasks)\n            this.rebuild = rebuild_await.bind(this);\n        else\n            this.rebuild = rebuild_noawait.bind(this);\n        this.setAutoRebuild(autoRebuild);\n        if (initialTasks) {\n            if (typeof initialTasks === 'function') {\n                this._tasks = initialTasks;\n                this.length = 1;\n            }\n            else {\n                this._tasks = initialTasks;\n                this.length = initialTasks.length;\n            }\n        }\n        else {\n            this._tasks = null;\n            this.length = 0;\n        }\n        if (autoRebuild)\n            this.rebuild();\n    }\n    return TaskCollection;\n}());\nexports.TaskCollection = TaskCollection;\nfunction fastClear() {\n    this._tasks = null;\n    this.length = 0;\n    this.call = bake_collection_1.BAKED_EMPTY_FUNC;\n}\nfunction clear() {\n    this._tasks = null;\n    this.length = 0;\n    this.call = bake_collection_1.BAKED_EMPTY_FUNC;\n}\nfunction growArgsNum(argsNum) {\n    if (this.argsNum < argsNum) {\n        this.argsNum = argsNum;\n        if (this.firstEmitBuildStrategy)\n            this.call = rebuild_on_first_call;\n        else\n            this.rebuild();\n    }\n}\nfunction setAutoRebuild(newVal) {\n    if (newVal) {\n        this.push = push_rebuild.bind(this);\n        this.insert = insert_rebuild.bind(this);\n        this.removeLast = removeLast_rebuild.bind(this);\n    }\n    else {\n        this.push = push_norebuild.bind(this);\n        this.insert = insert_norebuild.bind(this);\n        this.removeLast = removeLast_norebuild.bind(this);\n    }\n}\n;\nfunction tasksAsArray() {\n    if (this.length === 0)\n        return [];\n    if (this.length === 1)\n        return [this._tasks];\n    return this._tasks;\n}\nfunction setTasks(tasks) {\n    if (tasks.length === 0) {\n        this.length = 0;\n        this.call = bake_collection_1.BAKED_EMPTY_FUNC;\n    }\n    else if (tasks.length === 1) {\n        this.length = 1;\n        this.call = tasks[0];\n        this._tasks = tasks[0];\n    }\n    else {\n        this.length = tasks.length;\n        this._tasks = tasks;\n        if (this.firstEmitBuildStrategy)\n            this.call = rebuild_on_first_call;\n        else\n            this.rebuild();\n    }\n}\nTaskCollection.prototype.fastClear = fastClear;\nTaskCollection.prototype.clear = clear;\nTaskCollection.prototype.growArgsNum = growArgsNum;\nTaskCollection.prototype.setAutoRebuild = setAutoRebuild;\nTaskCollection.prototype.tasksAsArray = tasksAsArray;\nTaskCollection.prototype.setTasks = setTasks;\n//# sourceMappingURL=task-collection.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90c2VlcC9saWIvdGFzay1jb2xsZWN0aW9uL3Rhc2stY29sbGVjdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkVBQTZFLE9BQU87QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCO0FBQ3RCLGNBQWMsbUJBQU8sQ0FBQyxzRkFBUztBQUMvQix3QkFBd0IsbUJBQU8sQ0FBQywwR0FBbUI7QUFDbkQ7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsaUJBQWlCO0FBQ2pCLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLGlCQUFpQjtBQUNqQiw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQXVCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0Qyx1Q0FBdUM7QUFDdkMscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbGZnL0dpdC9NYWR0cmlwcy9ub2RlX21vZHVsZXMvdHNlZXAvbGliL3Rhc2stY29sbGVjdGlvbi90YXNrLWNvbGxlY3Rpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tLCBwYWNrKSB7XG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRhc2tDb2xsZWN0aW9uID0gdm9pZCAwO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbnZhciBiYWtlX2NvbGxlY3Rpb25fMSA9IHJlcXVpcmUoXCIuL2Jha2UtY29sbGVjdGlvblwiKTtcbmZ1bmN0aW9uIHB1c2hfbm9yZWJ1aWxkKGEsIGIgLyosIC4uLmZ1bmM6IEZ1bmNbXSAqLykge1xuICAgIHZhciBsZW4gPSB0aGlzLmxlbmd0aDtcbiAgICBpZiAobGVuID4gMSkgeyAvLyB0YXNrcyBpcyBhcnJheVxuICAgICAgICBpZiAoYikgeyAvLyBpZiBtdWx0aXBsZSBhcmdzXG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLl90YXNrcykucHVzaC5hcHBseShfYSwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoICs9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIGlmIHNpbmdsZSBhcmcgKG1vc3Qgb2Z0ZW4gY2FzZSlcbiAgICAgICAgICAgIHRoaXMuX3Rhc2tzLnB1c2goYSk7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgeyAvLyB0YXNrcyBpcyAoZnVuY3Rpb24gb3IgbnVsbClcbiAgICAgICAgaWYgKGIpIHsgLy8gaWYgbXVsdGlwbGUgYXJnc1xuICAgICAgICAgICAgaWYgKGxlbiA9PT0gMSkgeyAvLyBpZiB0aGlzLl90YXNrcyBpcyBmdW5jdGlvblxuICAgICAgICAgICAgICAgIHZhciBuZXdBciA9IEFycmF5KDEgKyBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBuZXdBci5wdXNoKG5ld0FyKTtcbiAgICAgICAgICAgICAgICBuZXdBci5wdXNoLmFwcGx5KG5ld0FyLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Rhc2tzID0gbmV3QXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3QXIgPSBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBuZXdBci5wdXNoLmFwcGx5KG5ld0FyLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Rhc2tzID0gbmV3QXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCArPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBpZiBzaW5nbGUgYXJnIChtb3N0IG9mdGVuIGNhc2UpXG4gICAgICAgICAgICBpZiAobGVuID09PSAxKVxuICAgICAgICAgICAgICAgIHRoaXMuX3Rhc2tzID0gW3RoaXMuX3Rhc2tzLCBhXTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLl90YXNrcyA9IGE7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCsrO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gcHVzaF9yZWJ1aWxkKGEsIGIgLyosIC4uLmZ1bmM6IEZ1bmNbXSAqLykge1xuICAgIHZhciBsZW4gPSB0aGlzLmxlbmd0aDtcbiAgICBpZiAobGVuID4gMSkgeyAvLyB0YXNrcyBpcyBhcnJheVxuICAgICAgICBpZiAoYikgeyAvLyBpZiBtdWx0aXBsZSBhcmdzXG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLl90YXNrcykucHVzaC5hcHBseShfYSwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoICs9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIGlmIHNpbmdsZSBhcmcgKG1vc3Qgb2Z0ZW4gY2FzZSlcbiAgICAgICAgICAgIHRoaXMuX3Rhc2tzLnB1c2goYSk7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgeyAvLyB0YXNrcyBpcyAoZnVuY3Rpb24gb3IgbnVsbClcbiAgICAgICAgaWYgKGIpIHsgLy8gaWYgbXVsdGlwbGUgYXJnc1xuICAgICAgICAgICAgaWYgKGxlbiA9PT0gMSkgeyAvLyBpZiB0aGlzLl90YXNrcyBpcyBmdW5jdGlvblxuICAgICAgICAgICAgICAgIHZhciBuZXdBciA9IEFycmF5KDEgKyBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBuZXdBci5wdXNoKG5ld0FyKTtcbiAgICAgICAgICAgICAgICBuZXdBci5wdXNoLmFwcGx5KG5ld0FyLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Rhc2tzID0gbmV3QXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3QXIgPSBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBuZXdBci5wdXNoLmFwcGx5KG5ld0FyLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Rhc2tzID0gbmV3QXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCArPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBpZiBzaW5nbGUgYXJnIChtb3N0IG9mdGVuIGNhc2UpXG4gICAgICAgICAgICBpZiAobGVuID09PSAxKVxuICAgICAgICAgICAgICAgIHRoaXMuX3Rhc2tzID0gW3RoaXMuX3Rhc2tzLCBhXTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLl90YXNrcyA9IGE7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmZpcnN0RW1pdEJ1aWxkU3RyYXRlZ3kpXG4gICAgICAgIHRoaXMuY2FsbCA9IHJlYnVpbGRfb25fZmlyc3RfY2FsbDtcbiAgICBlbHNlXG4gICAgICAgIHRoaXMucmVidWlsZCgpO1xufVxuZnVuY3Rpb24gcmVtb3ZlTGFzdF9ub3JlYnVpbGQoYSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBpZiAodGhpcy5fdGFza3MgPT09IGEpIHtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgKDAsIHV0aWxzXzEuX2Zhc3RfcmVtb3ZlX3NpbmdsZSkodGhpcy5fdGFza3MsIHRoaXMuX3Rhc2tzLmxhc3RJbmRleE9mKGEpKTtcbiAgICAgICAgaWYgKHRoaXMuX3Rhc2tzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5fdGFza3MgPSB0aGlzLl90YXNrc1swXTtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmxlbmd0aCA9IHRoaXMuX3Rhc2tzLmxlbmd0aDtcbiAgICB9XG59XG5mdW5jdGlvbiByZW1vdmVMYXN0X3JlYnVpbGQoYSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBpZiAodGhpcy5fdGFza3MgPT09IGEpIHtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5maXJzdEVtaXRCdWlsZFN0cmF0ZWd5KSB7XG4gICAgICAgICAgICB0aGlzLmNhbGwgPSBiYWtlX2NvbGxlY3Rpb25fMS5CQUtFRF9FTVBUWV9GVU5DO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZWJ1aWxkKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgICgwLCB1dGlsc18xLl9mYXN0X3JlbW92ZV9zaW5nbGUpKHRoaXMuX3Rhc2tzLCB0aGlzLl90YXNrcy5sYXN0SW5kZXhPZihhKSk7XG4gICAgICAgIGlmICh0aGlzLl90YXNrcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuX3Rhc2tzID0gdGhpcy5fdGFza3NbMF07XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5sZW5ndGggPSB0aGlzLl90YXNrcy5sZW5ndGg7XG4gICAgfVxuICAgIGlmICh0aGlzLmZpcnN0RW1pdEJ1aWxkU3RyYXRlZ3kpXG4gICAgICAgIHRoaXMuY2FsbCA9IHJlYnVpbGRfb25fZmlyc3RfY2FsbDtcbiAgICBlbHNlXG4gICAgICAgIHRoaXMucmVidWlsZCgpO1xufVxuZnVuY3Rpb24gaW5zZXJ0X25vcmVidWlsZChpbmRleCkge1xuICAgIHZhciBfYjtcbiAgICB2YXIgZnVuYyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGZ1bmNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLl90YXNrcyA9IGZ1bmM7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgZnVuYy51bnNoaWZ0KHRoaXMuX3Rhc2tzKTtcbiAgICAgICAgdGhpcy5fdGFza3MgPSBmdW5jO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IHRoaXMuX3Rhc2tzLmxlbmd0aDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIChfYiA9IHRoaXMuX3Rhc2tzKS5zcGxpY2UuYXBwbHkoX2IsIF9fc3ByZWFkQXJyYXkoW2luZGV4LCAwXSwgZnVuYywgZmFsc2UpKTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSB0aGlzLl90YXNrcy5sZW5ndGg7XG4gICAgfVxufVxuZnVuY3Rpb24gaW5zZXJ0X3JlYnVpbGQoaW5kZXgpIHtcbiAgICB2YXIgX2I7XG4gICAgdmFyIGZ1bmMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBmdW5jW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5fdGFza3MgPSBmdW5jO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGZ1bmMudW5zaGlmdCh0aGlzLl90YXNrcyk7XG4gICAgICAgIHRoaXMuX3Rhc2tzID0gZnVuYztcbiAgICAgICAgdGhpcy5sZW5ndGggPSB0aGlzLl90YXNrcy5sZW5ndGg7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAoX2IgPSB0aGlzLl90YXNrcykuc3BsaWNlLmFwcGx5KF9iLCBfX3NwcmVhZEFycmF5KFtpbmRleCwgMF0sIGZ1bmMsIGZhbHNlKSk7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5fdGFza3MubGVuZ3RoO1xuICAgIH1cbiAgICBpZiAodGhpcy5maXJzdEVtaXRCdWlsZFN0cmF0ZWd5KVxuICAgICAgICB0aGlzLmNhbGwgPSByZWJ1aWxkX29uX2ZpcnN0X2NhbGw7XG4gICAgZWxzZVxuICAgICAgICB0aGlzLnJlYnVpbGQoKTtcbn1cbmZ1bmN0aW9uIHJlYnVpbGRfbm9hd2FpdCgpIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApXG4gICAgICAgIHRoaXMuY2FsbCA9IGJha2VfY29sbGVjdGlvbl8xLkJBS0VEX0VNUFRZX0ZVTkM7XG4gICAgZWxzZSBpZiAodGhpcy5sZW5ndGggPT09IDEpXG4gICAgICAgIHRoaXMuY2FsbCA9IHRoaXMuX3Rhc2tzO1xuICAgIGVsc2VcbiAgICAgICAgdGhpcy5jYWxsID0gKDAsIGJha2VfY29sbGVjdGlvbl8xLmJha2VDb2xsZWN0aW9uKSh0aGlzLl90YXNrcywgdGhpcy5hcmdzTnVtKTtcbn1cbmZ1bmN0aW9uIHJlYnVpbGRfYXdhaXQoKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKVxuICAgICAgICB0aGlzLmNhbGwgPSBiYWtlX2NvbGxlY3Rpb25fMS5CQUtFRF9FTVBUWV9GVU5DO1xuICAgIGVsc2UgaWYgKHRoaXMubGVuZ3RoID09PSAxKVxuICAgICAgICB0aGlzLmNhbGwgPSB0aGlzLl90YXNrcztcbiAgICBlbHNlXG4gICAgICAgIHRoaXMuY2FsbCA9ICgwLCBiYWtlX2NvbGxlY3Rpb25fMS5iYWtlQ29sbGVjdGlvbkF3YWl0KSh0aGlzLl90YXNrcywgdGhpcy5hcmdzTnVtKTtcbn1cbmZ1bmN0aW9uIHJlYnVpbGRfb25fZmlyc3RfY2FsbCgpIHtcbiAgICB0aGlzLnJlYnVpbGQoKTtcbiAgICB0aGlzLmNhbGwuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xufVxudmFyIFRhc2tDb2xsZWN0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRhc2tDb2xsZWN0aW9uKGFyZ3NOdW0sIGF1dG9SZWJ1aWxkLCBpbml0aWFsVGFza3MsIGF3YWl0VGFza3MpIHtcbiAgICAgICAgaWYgKGF1dG9SZWJ1aWxkID09PSB2b2lkIDApIHsgYXV0b1JlYnVpbGQgPSB0cnVlOyB9XG4gICAgICAgIGlmIChpbml0aWFsVGFza3MgPT09IHZvaWQgMCkgeyBpbml0aWFsVGFza3MgPSBudWxsOyB9XG4gICAgICAgIGlmIChhd2FpdFRhc2tzID09PSB2b2lkIDApIHsgYXdhaXRUYXNrcyA9IGZhbHNlOyB9XG4gICAgICAgIHRoaXMuYXdhaXRUYXNrcyA9IGF3YWl0VGFza3M7XG4gICAgICAgIHRoaXMuY2FsbCA9IGJha2VfY29sbGVjdGlvbl8xLkJBS0VEX0VNUFRZX0ZVTkM7XG4gICAgICAgIHRoaXMuYXJnc051bSA9IGFyZ3NOdW07XG4gICAgICAgIHRoaXMuZmlyc3RFbWl0QnVpbGRTdHJhdGVneSA9IHRydWU7XG4gICAgICAgIGlmIChhd2FpdFRhc2tzKVxuICAgICAgICAgICAgdGhpcy5yZWJ1aWxkID0gcmVidWlsZF9hd2FpdC5iaW5kKHRoaXMpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnJlYnVpbGQgPSByZWJ1aWxkX25vYXdhaXQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXRBdXRvUmVidWlsZChhdXRvUmVidWlsZCk7XG4gICAgICAgIGlmIChpbml0aWFsVGFza3MpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5pdGlhbFRhc2tzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGFza3MgPSBpbml0aWFsVGFza3M7XG4gICAgICAgICAgICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGFza3MgPSBpbml0aWFsVGFza3M7XG4gICAgICAgICAgICAgICAgdGhpcy5sZW5ndGggPSBpbml0aWFsVGFza3MubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdGFza3MgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdXRvUmVidWlsZClcbiAgICAgICAgICAgIHRoaXMucmVidWlsZCgpO1xuICAgIH1cbiAgICByZXR1cm4gVGFza0NvbGxlY3Rpb247XG59KCkpO1xuZXhwb3J0cy5UYXNrQ29sbGVjdGlvbiA9IFRhc2tDb2xsZWN0aW9uO1xuZnVuY3Rpb24gZmFzdENsZWFyKCkge1xuICAgIHRoaXMuX3Rhc2tzID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5jYWxsID0gYmFrZV9jb2xsZWN0aW9uXzEuQkFLRURfRU1QVFlfRlVOQztcbn1cbmZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIHRoaXMuX3Rhc2tzID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5jYWxsID0gYmFrZV9jb2xsZWN0aW9uXzEuQkFLRURfRU1QVFlfRlVOQztcbn1cbmZ1bmN0aW9uIGdyb3dBcmdzTnVtKGFyZ3NOdW0pIHtcbiAgICBpZiAodGhpcy5hcmdzTnVtIDwgYXJnc051bSkge1xuICAgICAgICB0aGlzLmFyZ3NOdW0gPSBhcmdzTnVtO1xuICAgICAgICBpZiAodGhpcy5maXJzdEVtaXRCdWlsZFN0cmF0ZWd5KVxuICAgICAgICAgICAgdGhpcy5jYWxsID0gcmVidWlsZF9vbl9maXJzdF9jYWxsO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnJlYnVpbGQoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXRBdXRvUmVidWlsZChuZXdWYWwpIHtcbiAgICBpZiAobmV3VmFsKSB7XG4gICAgICAgIHRoaXMucHVzaCA9IHB1c2hfcmVidWlsZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmluc2VydCA9IGluc2VydF9yZWJ1aWxkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucmVtb3ZlTGFzdCA9IHJlbW92ZUxhc3RfcmVidWlsZC5iaW5kKHRoaXMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5wdXNoID0gcHVzaF9ub3JlYnVpbGQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5pbnNlcnQgPSBpbnNlcnRfbm9yZWJ1aWxkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucmVtb3ZlTGFzdCA9IHJlbW92ZUxhc3Rfbm9yZWJ1aWxkLmJpbmQodGhpcyk7XG4gICAgfVxufVxuO1xuZnVuY3Rpb24gdGFza3NBc0FycmF5KCkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgcmV0dXJuIFt0aGlzLl90YXNrc107XG4gICAgcmV0dXJuIHRoaXMuX3Rhc2tzO1xufVxuZnVuY3Rpb24gc2V0VGFza3ModGFza3MpIHtcbiAgICBpZiAodGFza3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5jYWxsID0gYmFrZV9jb2xsZWN0aW9uXzEuQkFLRURfRU1QVFlfRlVOQztcbiAgICB9XG4gICAgZWxzZSBpZiAodGFza3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICAgICAgdGhpcy5jYWxsID0gdGFza3NbMF07XG4gICAgICAgIHRoaXMuX3Rhc2tzID0gdGFza3NbMF07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLmxlbmd0aCA9IHRhc2tzLmxlbmd0aDtcbiAgICAgICAgdGhpcy5fdGFza3MgPSB0YXNrcztcbiAgICAgICAgaWYgKHRoaXMuZmlyc3RFbWl0QnVpbGRTdHJhdGVneSlcbiAgICAgICAgICAgIHRoaXMuY2FsbCA9IHJlYnVpbGRfb25fZmlyc3RfY2FsbDtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5yZWJ1aWxkKCk7XG4gICAgfVxufVxuVGFza0NvbGxlY3Rpb24ucHJvdG90eXBlLmZhc3RDbGVhciA9IGZhc3RDbGVhcjtcblRhc2tDb2xsZWN0aW9uLnByb3RvdHlwZS5jbGVhciA9IGNsZWFyO1xuVGFza0NvbGxlY3Rpb24ucHJvdG90eXBlLmdyb3dBcmdzTnVtID0gZ3Jvd0FyZ3NOdW07XG5UYXNrQ29sbGVjdGlvbi5wcm90b3R5cGUuc2V0QXV0b1JlYnVpbGQgPSBzZXRBdXRvUmVidWlsZDtcblRhc2tDb2xsZWN0aW9uLnByb3RvdHlwZS50YXNrc0FzQXJyYXkgPSB0YXNrc0FzQXJyYXk7XG5UYXNrQ29sbGVjdGlvbi5wcm90b3R5cGUuc2V0VGFza3MgPSBzZXRUYXNrcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRhc2stY29sbGVjdGlvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tseep/lib/task-collection/task-collection.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tseep/lib/task-collection/utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/tseep/lib/task-collection/utils.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports._fast_remove_single = void 0;\nfunction _fast_remove_single(arr, index) {\n    if (index === -1)\n        return;\n    if (index === 0)\n        arr.shift();\n    else if (index === arr.length - 1)\n        arr.length = arr.length - 1;\n    else\n        arr.splice(index, 1);\n}\nexports._fast_remove_single = _fast_remove_single;\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90c2VlcC9saWIvdGFzay1jb2xsZWN0aW9uL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQiIsInNvdXJjZXMiOlsiL2hvbWUvbGZnL0dpdC9NYWR0cmlwcy9ub2RlX21vZHVsZXMvdHNlZXAvbGliL3Rhc2stY29sbGVjdGlvbi91dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuX2Zhc3RfcmVtb3ZlX3NpbmdsZSA9IHZvaWQgMDtcbmZ1bmN0aW9uIF9mYXN0X3JlbW92ZV9zaW5nbGUoYXJyLCBpbmRleCkge1xuICAgIGlmIChpbmRleCA9PT0gLTEpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoaW5kZXggPT09IDApXG4gICAgICAgIGFyci5zaGlmdCgpO1xuICAgIGVsc2UgaWYgKGluZGV4ID09PSBhcnIubGVuZ3RoIC0gMSlcbiAgICAgICAgYXJyLmxlbmd0aCA9IGFyci5sZW5ndGggLSAxO1xuICAgIGVsc2VcbiAgICAgICAgYXJyLnNwbGljZShpbmRleCwgMSk7XG59XG5leHBvcnRzLl9mYXN0X3JlbW92ZV9zaW5nbGUgPSBfZmFzdF9yZW1vdmVfc2luZ2xlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tseep/lib/task-collection/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tseep/lib/types.js":
/*!*****************************************!*\
  !*** ./node_modules/tseep/lib/types.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90c2VlcC9saWIvdHlwZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QiLCJzb3VyY2VzIjpbIi9ob21lL2xmZy9HaXQvTWFkdHJpcHMvbm9kZV9tb2R1bGVzL3RzZWVwL2xpYi90eXBlcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tseep/lib/types.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tseep/lib/utils.js":
/*!*****************************************!*\
  !*** ./node_modules/tseep/lib/utils.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.nullObj = void 0;\nfunction nullObj() {\n    var x = {};\n    x.__proto__ = null;\n    return x;\n}\nexports.nullObj = nullObj;\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90c2VlcC9saWIvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIi9ob21lL2xmZy9HaXQvTWFkdHJpcHMvbm9kZV9tb2R1bGVzL3RzZWVwL2xpYi91dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubnVsbE9iaiA9IHZvaWQgMDtcbmZ1bmN0aW9uIG51bGxPYmooKSB7XG4gICAgdmFyIHggPSB7fTtcbiAgICB4Ll9fcHJvdG9fXyA9IG51bGw7XG4gICAgcmV0dXJuIHg7XG59XG5leHBvcnRzLm51bGxPYmogPSBudWxsT2JqO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tseep/lib/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/typescript-lru-cache/dist/LRUCache.js":
/*!************************************************************!*\
  !*** ./node_modules/typescript-lru-cache/dist/LRUCache.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.LRUCache = void 0;\r\nconst LRUCacheNode_1 = __webpack_require__(/*! ./LRUCacheNode */ \"(app-pages-browser)/./node_modules/typescript-lru-cache/dist/LRUCacheNode.js\");\r\n/**\r\n * A key value cache that implements the LRU policy.\r\n *\r\n * @typeparam TKey The type of the keys in the cache. Defaults to `string`.\r\n * @typeparam TValue The type of the values in the cache. Defaults to `any`.\r\n *\r\n * @see {@link https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)}\r\n */\r\nclass LRUCache {\r\n    /**\r\n     * Creates a new instance of the LRUCache.\r\n     *\r\n     * @param options Additional configuration options for the LRUCache.\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * // No options.\r\n     * const cache = new LRUCache();\r\n     *\r\n     * // With options.\r\n     * const cache = new LRUCache({\r\n     *  entryExpirationTimeInMS: 10000\r\n     * });\r\n     * ```\r\n     */\r\n    constructor(options) {\r\n        this.lookupTable = new Map();\r\n        this.head = null;\r\n        this.tail = null;\r\n        const { maxSize = 25, entryExpirationTimeInMS = null, onEntryEvicted, onEntryMarkedAsMostRecentlyUsed, cloneFn, clone } = options !== null && options !== void 0 ? options : {};\r\n        if (Number.isNaN(maxSize) || maxSize <= 0) {\r\n            throw new Error('maxSize must be greater than 0.');\r\n        }\r\n        if (typeof entryExpirationTimeInMS === 'number' &&\r\n            (entryExpirationTimeInMS <= 0 || Number.isNaN(entryExpirationTimeInMS))) {\r\n            throw new Error('entryExpirationTimeInMS must either be null (no expiry) or greater than 0');\r\n        }\r\n        this.maxSizeInternal = maxSize;\r\n        this.entryExpirationTimeInMS = entryExpirationTimeInMS;\r\n        this.onEntryEvicted = onEntryEvicted;\r\n        this.onEntryMarkedAsMostRecentlyUsed = onEntryMarkedAsMostRecentlyUsed;\r\n        this.clone = clone;\r\n        this.cloneFn = cloneFn;\r\n    }\r\n    /**\r\n     * Returns the number of entries in the LRUCache object.\r\n     * If the cache has entryExpirationTimeInMS set, expired entries will be removed before the size is returned.\r\n     *\r\n     * @returns The number of entries in the cache.\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * const cache = new LRUCache();\r\n     *\r\n     * cache.set('testKey', 'testValue');\r\n     *\r\n     * const size = cache.size;\r\n     *\r\n     * // Will log 1\r\n     * console.log(size);\r\n     * ```\r\n     */\r\n    get size() {\r\n        this.cleanCache();\r\n        return this.lookupTable.size;\r\n    }\r\n    /**\r\n     * Returns the number of entries that can still be added to the LRUCache without evicting existing entries.\r\n     *\r\n     * @returns The number of entries that can still be added without evicting existing entries.\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * const cache = new LRUCache({ maxSize: 10 });\r\n     *\r\n     * cache.set('testKey', 'testValue');\r\n     *\r\n     * const remainingSize = cache.remainingSize;\r\n     *\r\n     * // Will log 9 due to 9 spots remaining before reaching maxSize of 10.\r\n     * console.log(remainingSize);\r\n     * ```\r\n     */\r\n    get remainingSize() {\r\n        return this.maxSizeInternal - this.size;\r\n    }\r\n    /**\r\n     * Returns the most recently used (newest) entry in the cache.\r\n     * This will not mark the entry as recently used.\r\n     * If the newest node is expired, it will be removed.\r\n     *\r\n     * @returns The most recently used (newest) entry in the cache.\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * const cache = new LRUCache({ maxSize: 10 });\r\n     *\r\n     * cache.set('testKey', 'testValue');\r\n     *\r\n     * const newest = cache.newest;\r\n     *\r\n     * // Will log testValue\r\n     * console.log(newest.value);\r\n     *\r\n     * // Will log testKey\r\n     * console.log(newest.key);\r\n     * ```\r\n     */\r\n    get newest() {\r\n        if (!this.head) {\r\n            return null;\r\n        }\r\n        if (this.head.isExpired) {\r\n            this.removeNodeFromListAndLookupTable(this.head);\r\n            return this.newest;\r\n        }\r\n        return this.mapNodeToEntry(this.head);\r\n    }\r\n    /**\r\n     * Returns the least recently used (oldest) entry in the cache.\r\n     * This will not mark the entry as recently used.\r\n     * If the oldest node is expired, it will be removed.\r\n     *\r\n     * @returns The least recently used (oldest) entry in the cache.\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * const cache = new LRUCache({ maxSize: 10 });\r\n     *\r\n     * cache.set('testKey', 'testValue');\r\n     *\r\n     * const oldest = cache.oldest;\r\n     *\r\n     * // Will log testValue\r\n     * console.log(oldest.value);\r\n     *\r\n     * // Will log testKey\r\n     * console.log(oldest.key);\r\n     * ```\r\n     */\r\n    get oldest() {\r\n        if (!this.tail) {\r\n            return null;\r\n        }\r\n        if (this.tail.isExpired) {\r\n            this.removeNodeFromListAndLookupTable(this.tail);\r\n            return this.oldest;\r\n        }\r\n        return this.mapNodeToEntry(this.tail);\r\n    }\r\n    /**\r\n     * Gets or sets the maxSize of the cache.\r\n     * This will evict the least recently used entries if needed to reach new maxSize.\r\n     *\r\n     * @param value The new value for maxSize. Must be greater than 0.\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * const cache = new LRUCache({ maxSize: 10 });\r\n     *\r\n     * cache.set('testKey', 'testValue');\r\n     *\r\n     * // Will be 10\r\n     * const maxSize = cache.maxSize;\r\n     *\r\n     * // Set new maxSize to 5. If there are more than 5 items in the cache, the least recently used entries will be removed until cache size is 5.\r\n     * cache.maxSize = 5;\r\n     * ```\r\n     */\r\n    get maxSize() {\r\n        return this.maxSizeInternal;\r\n    }\r\n    set maxSize(value) {\r\n        if (Number.isNaN(value) || value <= 0) {\r\n            throw new Error('maxSize must be greater than 0.');\r\n        }\r\n        this.maxSizeInternal = value;\r\n        this.enforceSizeLimit();\r\n    }\r\n    /**\r\n     * Sets the value for the key in the LRUCache object. Returns the LRUCache object.\r\n     * This marks the newly added entry as the most recently used entry.\r\n     * If adding the new entry makes the cache size go above maxSize,\r\n     * this will evict the least recently used entries until size is equal to maxSize.\r\n     *\r\n     * @param key The key of the entry.\r\n     * @param value The value to set for the key.\r\n     * @param entryOptions Additional configuration options for the cache entry.\r\n     *\r\n     * @returns The LRUCache instance.\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * const cache = new LRUCache();\r\n     *\r\n     * // Set the key testKey to value testValue\r\n     * cache.set('testKey', 'testValue');\r\n     *\r\n     * // Set the key key2 to value value2. Pass in optional options.\r\n     * cache.set('key2', 'value2', { entryExpirationTimeInMS: 10 });\r\n     * ```\r\n     */\r\n    set(key, value, entryOptions) {\r\n        const currentNodeForKey = this.lookupTable.get(key);\r\n        if (currentNodeForKey) {\r\n            this.removeNodeFromListAndLookupTable(currentNodeForKey);\r\n        }\r\n        const node = new LRUCacheNode_1.LRUCacheNode(key, value, {\r\n            entryExpirationTimeInMS: this.entryExpirationTimeInMS,\r\n            onEntryEvicted: this.onEntryEvicted,\r\n            onEntryMarkedAsMostRecentlyUsed: this.onEntryMarkedAsMostRecentlyUsed,\r\n            clone: this.clone,\r\n            cloneFn: this.cloneFn,\r\n            ...entryOptions\r\n        });\r\n        this.setNodeAsHead(node);\r\n        this.lookupTable.set(key, node);\r\n        this.enforceSizeLimit();\r\n        return this;\r\n    }\r\n    /**\r\n     * Returns the value associated to the key, or null if there is none or if the entry is expired.\r\n     * If an entry is returned, this marks the returned entry as the most recently used entry.\r\n     *\r\n     * @param key The key of the entry to get.\r\n     *\r\n     * @returns The cached value or null.\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * const cache = new LRUCache();\r\n     *\r\n     * // Set the key testKey to value testValue\r\n     * cache.set('testKey', 'testValue');\r\n     *\r\n     * // Will be 'testValue'. Entry will now be most recently used.\r\n     * const item1 = cache.get('testKey');\r\n     *\r\n     * // Will be null\r\n     * const item2 = cache.get('keyNotInCache');\r\n     * ```\r\n     */\r\n    get(key) {\r\n        const node = this.lookupTable.get(key);\r\n        if (!node) {\r\n            return null;\r\n        }\r\n        if (node.isExpired) {\r\n            this.removeNodeFromListAndLookupTable(node);\r\n            return null;\r\n        }\r\n        this.setNodeAsHead(node);\r\n        return node.value;\r\n    }\r\n    /**\r\n     * Returns the value associated to the key, or null if there is none or if the entry is expired.\r\n     * If an entry is returned, this will not mark the entry as most recently accessed.\r\n     * Useful if a value is needed but the order of the cache should not be changed.\r\n     *\r\n     * @param key The key of the entry to get.\r\n     *\r\n     * @returns The cached value or null.\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * const cache = new LRUCache();\r\n     *\r\n     * // Set the key testKey to value testValue\r\n     * cache.set('testKey', 'testValue');\r\n     *\r\n     * // Will be 'testValue'\r\n     * const item1 = cache.peek('testKey');\r\n     *\r\n     * // Will be null\r\n     * const item2 = cache.peek('keyNotInCache');\r\n     * ```\r\n     */\r\n    peek(key) {\r\n        const node = this.lookupTable.get(key);\r\n        if (!node) {\r\n            return null;\r\n        }\r\n        if (node.isExpired) {\r\n            this.removeNodeFromListAndLookupTable(node);\r\n            return null;\r\n        }\r\n        return node.value;\r\n    }\r\n    /**\r\n     * Deletes the entry for the passed in key.\r\n     *\r\n     * @param key The key of the entry to delete\r\n     *\r\n     * @returns True if an element in the LRUCache object existed and has been removed,\r\n     * or false if the element does not exist.\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * const cache = new LRUCache();\r\n     *\r\n     * // Set the key testKey to value testValue\r\n     * cache.set('testKey', 'testValue');\r\n     *\r\n     * // Will be true\r\n     * const wasDeleted = cache.delete('testKey');\r\n     *\r\n     * // Will be false\r\n     * const wasDeleted2 = cache.delete('keyNotInCache');\r\n     * ```\r\n     */\r\n    delete(key) {\r\n        const node = this.lookupTable.get(key);\r\n        if (!node) {\r\n            return false;\r\n        }\r\n        return this.removeNodeFromListAndLookupTable(node);\r\n    }\r\n    /**\r\n     * Returns a boolean asserting whether a value has been associated to the key in the LRUCache object or not.\r\n     * This does not mark the entry as recently used.\r\n     * If the cache has a key but the entry is expired, it will be removed and false will be returned.\r\n     *\r\n     * @param key The key of the entry to check if exists\r\n     *\r\n     * @returns true if the cache contains the supplied key. False if not.\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * const cache = new LRUCache();\r\n     *\r\n     * // Set the key testKey to value testValue\r\n     * cache.set('testKey', 'testValue');\r\n     *\r\n     * // Will be true\r\n     * const wasDeleted = cache.has('testKey');\r\n     *\r\n     * // Will be false\r\n     * const wasDeleted2 = cache.has('keyNotInCache');\r\n     * ```\r\n     */\r\n    has(key) {\r\n        const node = this.lookupTable.get(key);\r\n        if (!node) {\r\n            return false;\r\n        }\r\n        if (node.isExpired) {\r\n            this.removeNodeFromListAndLookupTable(node);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * Removes all entries in the cache.\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * const cache = new LRUCache();\r\n     *\r\n     * // Set the key testKey to value testValue\r\n     * cache.set('testKey', 'testValue');\r\n     *\r\n     * // Clear cache.\r\n     * cache.clear();\r\n     * ```\r\n     */\r\n    clear() {\r\n        this.head = null;\r\n        this.tail = null;\r\n        this.lookupTable.clear();\r\n    }\r\n    /**\r\n     * Searches the cache for an entry matching the passed in condition.\r\n     * Expired entries will be skipped (and removed).\r\n     * If multiply entries in the cache match the condition, the most recently used entry will be returned.\r\n     * If an entry is returned, this marks the returned entry as the most recently used entry.\r\n     *\r\n     * @param condition The condition to apply to each entry in the\r\n     *\r\n     * @returns The first cache entry to match the condition. Null if none match.\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * const cache = new LRUCache();\r\n     *\r\n     * // Set the key testKey to value testValue\r\n     * cache.set('testKey', 'testValue');\r\n     *\r\n     * // item will be { key: 'testKey', value: 'testValue }\r\n     * const item = cache.find(entry => {\r\n     *   const { key, value } = entry;\r\n     *\r\n     *   if (key === 'testKey' || value === 'something') {\r\n     *     return true;\r\n     *   }\r\n     *\r\n     *   return false;\r\n     * });\r\n     *\r\n     * // item2 will be null\r\n     * const item2 = cache.find(entry => entry.key === 'notInCache');\r\n     * ```\r\n     */\r\n    find(condition) {\r\n        let node = this.head;\r\n        while (node) {\r\n            if (node.isExpired) {\r\n                const next = node.next;\r\n                this.removeNodeFromListAndLookupTable(node);\r\n                node = next;\r\n                continue;\r\n            }\r\n            const entry = this.mapNodeToEntry(node);\r\n            if (condition(entry)) {\r\n                this.setNodeAsHead(node);\r\n                return entry;\r\n            }\r\n            node = node.next;\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Iterates over and applies the callback function to each entry in the cache.\r\n     * Iterates in order from most recently accessed entry to least recently.\r\n     * Expired entries will be skipped (and removed).\r\n     * No entry will be marked as recently used.\r\n     *\r\n     * @param callback the callback function to apply to the entry\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * const cache = new LRUCache();\r\n     *\r\n     * // Set the key testKey to value testValue\r\n     * cache.set('testKey', 'testValue');\r\n     *\r\n     * cache.forEach((key, value, index) => {\r\n     *   // do something with key, value, and/or index\r\n     * });\r\n     * ```\r\n     */\r\n    forEach(callback) {\r\n        let node = this.head;\r\n        let index = 0;\r\n        while (node) {\r\n            if (node.isExpired) {\r\n                const next = node.next;\r\n                this.removeNodeFromListAndLookupTable(node);\r\n                node = next;\r\n                continue;\r\n            }\r\n            callback(node.value, node.key, index);\r\n            node = node.next;\r\n            index++;\r\n        }\r\n    }\r\n    /**\r\n     * Creates a Generator which can be used with for ... of ... to iterate over the cache values.\r\n     * Iterates in order from most recently accessed entry to least recently.\r\n     * Expired entries will be skipped (and removed).\r\n     * No entry will be marked as accessed.\r\n     *\r\n     * @returns A Generator for the cache values.\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * const cache = new LRUCache();\r\n     *\r\n     * // Set the key testKey to value testValue\r\n     * cache.set('testKey', 'testValue');\r\n     *\r\n     * for (const value of cache.values()) {\r\n     *   // do something with the value\r\n     * }\r\n     * ```\r\n     */\r\n    *values() {\r\n        let node = this.head;\r\n        while (node) {\r\n            if (node.isExpired) {\r\n                const next = node.next;\r\n                this.removeNodeFromListAndLookupTable(node);\r\n                node = next;\r\n                continue;\r\n            }\r\n            yield node.value;\r\n            node = node.next;\r\n        }\r\n    }\r\n    /**\r\n     * Creates a Generator which can be used with for ... of ... to iterate over the cache keys.\r\n     * Iterates in order from most recently accessed entry to least recently.\r\n     * Expired entries will be skipped (and removed).\r\n     * No entry will be marked as accessed.\r\n     *\r\n     * @returns A Generator for the cache keys.\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * const cache = new LRUCache();\r\n     *\r\n     * // Set the key testKey to value testValue\r\n     * cache.set('testKey', 'testValue');\r\n     *\r\n     * for (const key of cache.keys()) {\r\n     *   // do something with the key\r\n     * }\r\n     * ```\r\n     */\r\n    *keys() {\r\n        let node = this.head;\r\n        while (node) {\r\n            if (node.isExpired) {\r\n                const next = node.next;\r\n                this.removeNodeFromListAndLookupTable(node);\r\n                node = next;\r\n                continue;\r\n            }\r\n            yield node.key;\r\n            node = node.next;\r\n        }\r\n    }\r\n    /**\r\n     * Creates a Generator which can be used with for ... of ... to iterate over the cache entries.\r\n     * Iterates in order from most recently accessed entry to least recently.\r\n     * Expired entries will be skipped (and removed).\r\n     * No entry will be marked as accessed.\r\n     *\r\n     * @returns A Generator for the cache entries.\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * const cache = new LRUCache();\r\n     *\r\n     * // Set the key testKey to value testValue\r\n     * cache.set('testKey', 'testValue');\r\n     *\r\n     * for (const entry of cache.entries()) {\r\n     *   const { key, value } = entry;\r\n     *   // do something with the entry\r\n     * }\r\n     * ```\r\n     */\r\n    *entries() {\r\n        let node = this.head;\r\n        while (node) {\r\n            if (node.isExpired) {\r\n                const next = node.next;\r\n                this.removeNodeFromListAndLookupTable(node);\r\n                node = next;\r\n                continue;\r\n            }\r\n            yield this.mapNodeToEntry(node);\r\n            node = node.next;\r\n        }\r\n    }\r\n    /**\r\n     * Creates a Generator which can be used with for ... of ... to iterate over the cache entries.\r\n     * Iterates in order from most recently accessed entry to least recently.\r\n     * Expired entries will be skipped (and removed).\r\n     * No entry will be marked as accessed.\r\n     *\r\n     * @returns A Generator for the cache entries.\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * const cache = new LRUCache();\r\n     *\r\n     * // Set the key testKey to value testValue\r\n     * cache.set('testKey', 'testValue');\r\n     *\r\n     * for (const entry of cache) {\r\n     *   const { key, value } = entry;\r\n     *   // do something with the entry\r\n     * }\r\n     * ```\r\n     */\r\n    *[Symbol.iterator]() {\r\n        let node = this.head;\r\n        while (node) {\r\n            if (node.isExpired) {\r\n                const next = node.next;\r\n                this.removeNodeFromListAndLookupTable(node);\r\n                node = next;\r\n                continue;\r\n            }\r\n            yield this.mapNodeToEntry(node);\r\n            node = node.next;\r\n        }\r\n    }\r\n    enforceSizeLimit() {\r\n        let node = this.tail;\r\n        while (node !== null && this.size > this.maxSizeInternal) {\r\n            const prev = node.prev;\r\n            this.removeNodeFromListAndLookupTable(node);\r\n            node = prev;\r\n        }\r\n    }\r\n    mapNodeToEntry({ key, value }) {\r\n        return {\r\n            key,\r\n            value\r\n        };\r\n    }\r\n    setNodeAsHead(node) {\r\n        this.removeNodeFromList(node);\r\n        if (!this.head) {\r\n            this.head = node;\r\n            this.tail = node;\r\n        }\r\n        else {\r\n            node.next = this.head;\r\n            this.head.prev = node;\r\n            this.head = node;\r\n        }\r\n        node.invokeOnEntryMarkedAsMostRecentlyUsed();\r\n    }\r\n    removeNodeFromList(node) {\r\n        if (node.prev !== null) {\r\n            node.prev.next = node.next;\r\n        }\r\n        if (node.next !== null) {\r\n            node.next.prev = node.prev;\r\n        }\r\n        if (this.head === node) {\r\n            this.head = node.next;\r\n        }\r\n        if (this.tail === node) {\r\n            this.tail = node.prev;\r\n        }\r\n        node.next = null;\r\n        node.prev = null;\r\n    }\r\n    removeNodeFromListAndLookupTable(node) {\r\n        node.invokeOnEvicted();\r\n        this.removeNodeFromList(node);\r\n        return this.lookupTable.delete(node.key);\r\n    }\r\n    cleanCache() {\r\n        // Don't spend time cleaning if entries don't expire.\r\n        if (!this.entryExpirationTimeInMS) {\r\n            return;\r\n        }\r\n        const expiredNodes = [];\r\n        for (const node of this.lookupTable.values()) {\r\n            if (node.isExpired) {\r\n                expiredNodes.push(node);\r\n            }\r\n        }\r\n        expiredNodes.forEach(node => this.removeNodeFromListAndLookupTable(node));\r\n    }\r\n}\r\nexports.LRUCache = LRUCache;\r\n//# sourceMappingURL=LRUCache.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90eXBlc2NyaXB0LWxydS1jYWNoZS9kaXN0L0xSVUNhY2hlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQjtBQUNoQix1QkFBdUIsbUJBQU8sQ0FBQyxvR0FBZ0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0hBQWdIO0FBQ2hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGFBQWE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGFBQWE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsYUFBYTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsYUFBYTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyw2QkFBNkI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLGlCQUFpQixhQUFhO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsYUFBYTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsYUFBYTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixZQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIiLCJzb3VyY2VzIjpbIi9ob21lL2xmZy9HaXQvTWFkdHJpcHMvbm9kZV9tb2R1bGVzL3R5cGVzY3JpcHQtbHJ1LWNhY2hlL2Rpc3QvTFJVQ2FjaGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5MUlVDYWNoZSA9IHZvaWQgMDtcclxuY29uc3QgTFJVQ2FjaGVOb2RlXzEgPSByZXF1aXJlKFwiLi9MUlVDYWNoZU5vZGVcIik7XHJcbi8qKlxyXG4gKiBBIGtleSB2YWx1ZSBjYWNoZSB0aGF0IGltcGxlbWVudHMgdGhlIExSVSBwb2xpY3kuXHJcbiAqXHJcbiAqIEB0eXBlcGFyYW0gVEtleSBUaGUgdHlwZSBvZiB0aGUga2V5cyBpbiB0aGUgY2FjaGUuIERlZmF1bHRzIHRvIGBzdHJpbmdgLlxyXG4gKiBAdHlwZXBhcmFtIFRWYWx1ZSBUaGUgdHlwZSBvZiB0aGUgdmFsdWVzIGluIHRoZSBjYWNoZS4gRGVmYXVsdHMgdG8gYGFueWAuXHJcbiAqXHJcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NhY2hlX3JlcGxhY2VtZW50X3BvbGljaWVzI0xlYXN0X3JlY2VudGx5X3VzZWRfKExSVSl9XHJcbiAqL1xyXG5jbGFzcyBMUlVDYWNoZSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIExSVUNhY2hlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIEFkZGl0aW9uYWwgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgTFJVQ2FjaGUuXHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIC8vIE5vIG9wdGlvbnMuXHJcbiAgICAgKiBjb25zdCBjYWNoZSA9IG5ldyBMUlVDYWNoZSgpO1xyXG4gICAgICpcclxuICAgICAqIC8vIFdpdGggb3B0aW9ucy5cclxuICAgICAqIGNvbnN0IGNhY2hlID0gbmV3IExSVUNhY2hlKHtcclxuICAgICAqICBlbnRyeUV4cGlyYXRpb25UaW1lSW5NUzogMTAwMDBcclxuICAgICAqIH0pO1xyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLmxvb2t1cFRhYmxlID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuaGVhZCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy50YWlsID0gbnVsbDtcclxuICAgICAgICBjb25zdCB7IG1heFNpemUgPSAyNSwgZW50cnlFeHBpcmF0aW9uVGltZUluTVMgPSBudWxsLCBvbkVudHJ5RXZpY3RlZCwgb25FbnRyeU1hcmtlZEFzTW9zdFJlY2VudGx5VXNlZCwgY2xvbmVGbiwgY2xvbmUgfSA9IG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IHt9O1xyXG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4obWF4U2l6ZSkgfHwgbWF4U2l6ZSA8PSAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWF4U2l6ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIGVudHJ5RXhwaXJhdGlvblRpbWVJbk1TID09PSAnbnVtYmVyJyAmJlxyXG4gICAgICAgICAgICAoZW50cnlFeHBpcmF0aW9uVGltZUluTVMgPD0gMCB8fCBOdW1iZXIuaXNOYU4oZW50cnlFeHBpcmF0aW9uVGltZUluTVMpKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VudHJ5RXhwaXJhdGlvblRpbWVJbk1TIG11c3QgZWl0aGVyIGJlIG51bGwgKG5vIGV4cGlyeSkgb3IgZ3JlYXRlciB0aGFuIDAnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5tYXhTaXplSW50ZXJuYWwgPSBtYXhTaXplO1xyXG4gICAgICAgIHRoaXMuZW50cnlFeHBpcmF0aW9uVGltZUluTVMgPSBlbnRyeUV4cGlyYXRpb25UaW1lSW5NUztcclxuICAgICAgICB0aGlzLm9uRW50cnlFdmljdGVkID0gb25FbnRyeUV2aWN0ZWQ7XHJcbiAgICAgICAgdGhpcy5vbkVudHJ5TWFya2VkQXNNb3N0UmVjZW50bHlVc2VkID0gb25FbnRyeU1hcmtlZEFzTW9zdFJlY2VudGx5VXNlZDtcclxuICAgICAgICB0aGlzLmNsb25lID0gY2xvbmU7XHJcbiAgICAgICAgdGhpcy5jbG9uZUZuID0gY2xvbmVGbjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGVudHJpZXMgaW4gdGhlIExSVUNhY2hlIG9iamVjdC5cclxuICAgICAqIElmIHRoZSBjYWNoZSBoYXMgZW50cnlFeHBpcmF0aW9uVGltZUluTVMgc2V0LCBleHBpcmVkIGVudHJpZXMgd2lsbCBiZSByZW1vdmVkIGJlZm9yZSB0aGUgc2l6ZSBpcyByZXR1cm5lZC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIGVudHJpZXMgaW4gdGhlIGNhY2hlLlxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiBjb25zdCBjYWNoZSA9IG5ldyBMUlVDYWNoZSgpO1xyXG4gICAgICpcclxuICAgICAqIGNhY2hlLnNldCgndGVzdEtleScsICd0ZXN0VmFsdWUnKTtcclxuICAgICAqXHJcbiAgICAgKiBjb25zdCBzaXplID0gY2FjaGUuc2l6ZTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBXaWxsIGxvZyAxXHJcbiAgICAgKiBjb25zb2xlLmxvZyhzaXplKTtcclxuICAgICAqIGBgYFxyXG4gICAgICovXHJcbiAgICBnZXQgc2l6ZSgpIHtcclxuICAgICAgICB0aGlzLmNsZWFuQ2FjaGUoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5sb29rdXBUYWJsZS5zaXplO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZW50cmllcyB0aGF0IGNhbiBzdGlsbCBiZSBhZGRlZCB0byB0aGUgTFJVQ2FjaGUgd2l0aG91dCBldmljdGluZyBleGlzdGluZyBlbnRyaWVzLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2YgZW50cmllcyB0aGF0IGNhbiBzdGlsbCBiZSBhZGRlZCB3aXRob3V0IGV2aWN0aW5nIGV4aXN0aW5nIGVudHJpZXMuXHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIGNvbnN0IGNhY2hlID0gbmV3IExSVUNhY2hlKHsgbWF4U2l6ZTogMTAgfSk7XHJcbiAgICAgKlxyXG4gICAgICogY2FjaGUuc2V0KCd0ZXN0S2V5JywgJ3Rlc3RWYWx1ZScpO1xyXG4gICAgICpcclxuICAgICAqIGNvbnN0IHJlbWFpbmluZ1NpemUgPSBjYWNoZS5yZW1haW5pbmdTaXplO1xyXG4gICAgICpcclxuICAgICAqIC8vIFdpbGwgbG9nIDkgZHVlIHRvIDkgc3BvdHMgcmVtYWluaW5nIGJlZm9yZSByZWFjaGluZyBtYXhTaXplIG9mIDEwLlxyXG4gICAgICogY29uc29sZS5sb2cocmVtYWluaW5nU2l6ZSk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgZ2V0IHJlbWFpbmluZ1NpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWF4U2l6ZUludGVybmFsIC0gdGhpcy5zaXplO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBtb3N0IHJlY2VudGx5IHVzZWQgKG5ld2VzdCkgZW50cnkgaW4gdGhlIGNhY2hlLlxyXG4gICAgICogVGhpcyB3aWxsIG5vdCBtYXJrIHRoZSBlbnRyeSBhcyByZWNlbnRseSB1c2VkLlxyXG4gICAgICogSWYgdGhlIG5ld2VzdCBub2RlIGlzIGV4cGlyZWQsIGl0IHdpbGwgYmUgcmVtb3ZlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgbW9zdCByZWNlbnRseSB1c2VkIChuZXdlc3QpIGVudHJ5IGluIHRoZSBjYWNoZS5cclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogY29uc3QgY2FjaGUgPSBuZXcgTFJVQ2FjaGUoeyBtYXhTaXplOiAxMCB9KTtcclxuICAgICAqXHJcbiAgICAgKiBjYWNoZS5zZXQoJ3Rlc3RLZXknLCAndGVzdFZhbHVlJyk7XHJcbiAgICAgKlxyXG4gICAgICogY29uc3QgbmV3ZXN0ID0gY2FjaGUubmV3ZXN0O1xyXG4gICAgICpcclxuICAgICAqIC8vIFdpbGwgbG9nIHRlc3RWYWx1ZVxyXG4gICAgICogY29uc29sZS5sb2cobmV3ZXN0LnZhbHVlKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBXaWxsIGxvZyB0ZXN0S2V5XHJcbiAgICAgKiBjb25zb2xlLmxvZyhuZXdlc3Qua2V5KTtcclxuICAgICAqIGBgYFxyXG4gICAgICovXHJcbiAgICBnZXQgbmV3ZXN0KCkge1xyXG4gICAgICAgIGlmICghdGhpcy5oZWFkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5oZWFkLmlzRXhwaXJlZCkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZU5vZGVGcm9tTGlzdEFuZExvb2t1cFRhYmxlKHRoaXMuaGVhZCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5ld2VzdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwTm9kZVRvRW50cnkodGhpcy5oZWFkKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbGVhc3QgcmVjZW50bHkgdXNlZCAob2xkZXN0KSBlbnRyeSBpbiB0aGUgY2FjaGUuXHJcbiAgICAgKiBUaGlzIHdpbGwgbm90IG1hcmsgdGhlIGVudHJ5IGFzIHJlY2VudGx5IHVzZWQuXHJcbiAgICAgKiBJZiB0aGUgb2xkZXN0IG5vZGUgaXMgZXhwaXJlZCwgaXQgd2lsbCBiZSByZW1vdmVkLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFRoZSBsZWFzdCByZWNlbnRseSB1c2VkIChvbGRlc3QpIGVudHJ5IGluIHRoZSBjYWNoZS5cclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogY29uc3QgY2FjaGUgPSBuZXcgTFJVQ2FjaGUoeyBtYXhTaXplOiAxMCB9KTtcclxuICAgICAqXHJcbiAgICAgKiBjYWNoZS5zZXQoJ3Rlc3RLZXknLCAndGVzdFZhbHVlJyk7XHJcbiAgICAgKlxyXG4gICAgICogY29uc3Qgb2xkZXN0ID0gY2FjaGUub2xkZXN0O1xyXG4gICAgICpcclxuICAgICAqIC8vIFdpbGwgbG9nIHRlc3RWYWx1ZVxyXG4gICAgICogY29uc29sZS5sb2cob2xkZXN0LnZhbHVlKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBXaWxsIGxvZyB0ZXN0S2V5XHJcbiAgICAgKiBjb25zb2xlLmxvZyhvbGRlc3Qua2V5KTtcclxuICAgICAqIGBgYFxyXG4gICAgICovXHJcbiAgICBnZXQgb2xkZXN0KCkge1xyXG4gICAgICAgIGlmICghdGhpcy50YWlsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy50YWlsLmlzRXhwaXJlZCkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZU5vZGVGcm9tTGlzdEFuZExvb2t1cFRhYmxlKHRoaXMudGFpbCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9sZGVzdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwTm9kZVRvRW50cnkodGhpcy50YWlsKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSBtYXhTaXplIG9mIHRoZSBjYWNoZS5cclxuICAgICAqIFRoaXMgd2lsbCBldmljdCB0aGUgbGVhc3QgcmVjZW50bHkgdXNlZCBlbnRyaWVzIGlmIG5lZWRlZCB0byByZWFjaCBuZXcgbWF4U2l6ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIG5ldyB2YWx1ZSBmb3IgbWF4U2l6ZS4gTXVzdCBiZSBncmVhdGVyIHRoYW4gMC5cclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogY29uc3QgY2FjaGUgPSBuZXcgTFJVQ2FjaGUoeyBtYXhTaXplOiAxMCB9KTtcclxuICAgICAqXHJcbiAgICAgKiBjYWNoZS5zZXQoJ3Rlc3RLZXknLCAndGVzdFZhbHVlJyk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gV2lsbCBiZSAxMFxyXG4gICAgICogY29uc3QgbWF4U2l6ZSA9IGNhY2hlLm1heFNpemU7XHJcbiAgICAgKlxyXG4gICAgICogLy8gU2V0IG5ldyBtYXhTaXplIHRvIDUuIElmIHRoZXJlIGFyZSBtb3JlIHRoYW4gNSBpdGVtcyBpbiB0aGUgY2FjaGUsIHRoZSBsZWFzdCByZWNlbnRseSB1c2VkIGVudHJpZXMgd2lsbCBiZSByZW1vdmVkIHVudGlsIGNhY2hlIHNpemUgaXMgNS5cclxuICAgICAqIGNhY2hlLm1heFNpemUgPSA1O1xyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIGdldCBtYXhTaXplKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1heFNpemVJbnRlcm5hbDtcclxuICAgIH1cclxuICAgIHNldCBtYXhTaXplKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKE51bWJlci5pc05hTih2YWx1ZSkgfHwgdmFsdWUgPD0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21heFNpemUgbXVzdCBiZSBncmVhdGVyIHRoYW4gMC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5tYXhTaXplSW50ZXJuYWwgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLmVuZm9yY2VTaXplTGltaXQoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgdmFsdWUgZm9yIHRoZSBrZXkgaW4gdGhlIExSVUNhY2hlIG9iamVjdC4gUmV0dXJucyB0aGUgTFJVQ2FjaGUgb2JqZWN0LlxyXG4gICAgICogVGhpcyBtYXJrcyB0aGUgbmV3bHkgYWRkZWQgZW50cnkgYXMgdGhlIG1vc3QgcmVjZW50bHkgdXNlZCBlbnRyeS5cclxuICAgICAqIElmIGFkZGluZyB0aGUgbmV3IGVudHJ5IG1ha2VzIHRoZSBjYWNoZSBzaXplIGdvIGFib3ZlIG1heFNpemUsXHJcbiAgICAgKiB0aGlzIHdpbGwgZXZpY3QgdGhlIGxlYXN0IHJlY2VudGx5IHVzZWQgZW50cmllcyB1bnRpbCBzaXplIGlzIGVxdWFsIHRvIG1heFNpemUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeS5cclxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0IGZvciB0aGUga2V5LlxyXG4gICAgICogQHBhcmFtIGVudHJ5T3B0aW9ucyBBZGRpdGlvbmFsIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIGNhY2hlIGVudHJ5LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFRoZSBMUlVDYWNoZSBpbnN0YW5jZS5cclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogY29uc3QgY2FjaGUgPSBuZXcgTFJVQ2FjaGUoKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBTZXQgdGhlIGtleSB0ZXN0S2V5IHRvIHZhbHVlIHRlc3RWYWx1ZVxyXG4gICAgICogY2FjaGUuc2V0KCd0ZXN0S2V5JywgJ3Rlc3RWYWx1ZScpO1xyXG4gICAgICpcclxuICAgICAqIC8vIFNldCB0aGUga2V5IGtleTIgdG8gdmFsdWUgdmFsdWUyLiBQYXNzIGluIG9wdGlvbmFsIG9wdGlvbnMuXHJcbiAgICAgKiBjYWNoZS5zZXQoJ2tleTInLCAndmFsdWUyJywgeyBlbnRyeUV4cGlyYXRpb25UaW1lSW5NUzogMTAgfSk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgc2V0KGtleSwgdmFsdWUsIGVudHJ5T3B0aW9ucykge1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnROb2RlRm9yS2V5ID0gdGhpcy5sb29rdXBUYWJsZS5nZXQoa2V5KTtcclxuICAgICAgICBpZiAoY3VycmVudE5vZGVGb3JLZXkpIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVOb2RlRnJvbUxpc3RBbmRMb29rdXBUYWJsZShjdXJyZW50Tm9kZUZvcktleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG5vZGUgPSBuZXcgTFJVQ2FjaGVOb2RlXzEuTFJVQ2FjaGVOb2RlKGtleSwgdmFsdWUsIHtcclxuICAgICAgICAgICAgZW50cnlFeHBpcmF0aW9uVGltZUluTVM6IHRoaXMuZW50cnlFeHBpcmF0aW9uVGltZUluTVMsXHJcbiAgICAgICAgICAgIG9uRW50cnlFdmljdGVkOiB0aGlzLm9uRW50cnlFdmljdGVkLFxyXG4gICAgICAgICAgICBvbkVudHJ5TWFya2VkQXNNb3N0UmVjZW50bHlVc2VkOiB0aGlzLm9uRW50cnlNYXJrZWRBc01vc3RSZWNlbnRseVVzZWQsXHJcbiAgICAgICAgICAgIGNsb25lOiB0aGlzLmNsb25lLFxyXG4gICAgICAgICAgICBjbG9uZUZuOiB0aGlzLmNsb25lRm4sXHJcbiAgICAgICAgICAgIC4uLmVudHJ5T3B0aW9uc1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuc2V0Tm9kZUFzSGVhZChub2RlKTtcclxuICAgICAgICB0aGlzLmxvb2t1cFRhYmxlLnNldChrZXksIG5vZGUpO1xyXG4gICAgICAgIHRoaXMuZW5mb3JjZVNpemVMaW1pdCgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHRvIHRoZSBrZXksIG9yIG51bGwgaWYgdGhlcmUgaXMgbm9uZSBvciBpZiB0aGUgZW50cnkgaXMgZXhwaXJlZC5cclxuICAgICAqIElmIGFuIGVudHJ5IGlzIHJldHVybmVkLCB0aGlzIG1hcmtzIHRoZSByZXR1cm5lZCBlbnRyeSBhcyB0aGUgbW9zdCByZWNlbnRseSB1c2VkIGVudHJ5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gZ2V0LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFRoZSBjYWNoZWQgdmFsdWUgb3IgbnVsbC5cclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogY29uc3QgY2FjaGUgPSBuZXcgTFJVQ2FjaGUoKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBTZXQgdGhlIGtleSB0ZXN0S2V5IHRvIHZhbHVlIHRlc3RWYWx1ZVxyXG4gICAgICogY2FjaGUuc2V0KCd0ZXN0S2V5JywgJ3Rlc3RWYWx1ZScpO1xyXG4gICAgICpcclxuICAgICAqIC8vIFdpbGwgYmUgJ3Rlc3RWYWx1ZScuIEVudHJ5IHdpbGwgbm93IGJlIG1vc3QgcmVjZW50bHkgdXNlZC5cclxuICAgICAqIGNvbnN0IGl0ZW0xID0gY2FjaGUuZ2V0KCd0ZXN0S2V5Jyk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gV2lsbCBiZSBudWxsXHJcbiAgICAgKiBjb25zdCBpdGVtMiA9IGNhY2hlLmdldCgna2V5Tm90SW5DYWNoZScpO1xyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIGdldChrZXkpIHtcclxuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5sb29rdXBUYWJsZS5nZXQoa2V5KTtcclxuICAgICAgICBpZiAoIW5vZGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChub2RlLmlzRXhwaXJlZCkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZU5vZGVGcm9tTGlzdEFuZExvb2t1cFRhYmxlKG5vZGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZXROb2RlQXNIZWFkKG5vZGUpO1xyXG4gICAgICAgIHJldHVybiBub2RlLnZhbHVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHRvIHRoZSBrZXksIG9yIG51bGwgaWYgdGhlcmUgaXMgbm9uZSBvciBpZiB0aGUgZW50cnkgaXMgZXhwaXJlZC5cclxuICAgICAqIElmIGFuIGVudHJ5IGlzIHJldHVybmVkLCB0aGlzIHdpbGwgbm90IG1hcmsgdGhlIGVudHJ5IGFzIG1vc3QgcmVjZW50bHkgYWNjZXNzZWQuXHJcbiAgICAgKiBVc2VmdWwgaWYgYSB2YWx1ZSBpcyBuZWVkZWQgYnV0IHRoZSBvcmRlciBvZiB0aGUgY2FjaGUgc2hvdWxkIG5vdCBiZSBjaGFuZ2VkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gZ2V0LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFRoZSBjYWNoZWQgdmFsdWUgb3IgbnVsbC5cclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogY29uc3QgY2FjaGUgPSBuZXcgTFJVQ2FjaGUoKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBTZXQgdGhlIGtleSB0ZXN0S2V5IHRvIHZhbHVlIHRlc3RWYWx1ZVxyXG4gICAgICogY2FjaGUuc2V0KCd0ZXN0S2V5JywgJ3Rlc3RWYWx1ZScpO1xyXG4gICAgICpcclxuICAgICAqIC8vIFdpbGwgYmUgJ3Rlc3RWYWx1ZSdcclxuICAgICAqIGNvbnN0IGl0ZW0xID0gY2FjaGUucGVlaygndGVzdEtleScpO1xyXG4gICAgICpcclxuICAgICAqIC8vIFdpbGwgYmUgbnVsbFxyXG4gICAgICogY29uc3QgaXRlbTIgPSBjYWNoZS5wZWVrKCdrZXlOb3RJbkNhY2hlJyk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgcGVlayhrZXkpIHtcclxuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5sb29rdXBUYWJsZS5nZXQoa2V5KTtcclxuICAgICAgICBpZiAoIW5vZGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChub2RlLmlzRXhwaXJlZCkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZU5vZGVGcm9tTGlzdEFuZExvb2t1cFRhYmxlKG5vZGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5vZGUudmFsdWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERlbGV0ZXMgdGhlIGVudHJ5IGZvciB0aGUgcGFzc2VkIGluIGtleS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGRlbGV0ZVxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgYW4gZWxlbWVudCBpbiB0aGUgTFJVQ2FjaGUgb2JqZWN0IGV4aXN0ZWQgYW5kIGhhcyBiZWVuIHJlbW92ZWQsXHJcbiAgICAgKiBvciBmYWxzZSBpZiB0aGUgZWxlbWVudCBkb2VzIG5vdCBleGlzdC5cclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogY29uc3QgY2FjaGUgPSBuZXcgTFJVQ2FjaGUoKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBTZXQgdGhlIGtleSB0ZXN0S2V5IHRvIHZhbHVlIHRlc3RWYWx1ZVxyXG4gICAgICogY2FjaGUuc2V0KCd0ZXN0S2V5JywgJ3Rlc3RWYWx1ZScpO1xyXG4gICAgICpcclxuICAgICAqIC8vIFdpbGwgYmUgdHJ1ZVxyXG4gICAgICogY29uc3Qgd2FzRGVsZXRlZCA9IGNhY2hlLmRlbGV0ZSgndGVzdEtleScpO1xyXG4gICAgICpcclxuICAgICAqIC8vIFdpbGwgYmUgZmFsc2VcclxuICAgICAqIGNvbnN0IHdhc0RlbGV0ZWQyID0gY2FjaGUuZGVsZXRlKCdrZXlOb3RJbkNhY2hlJyk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgZGVsZXRlKGtleSkge1xyXG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLmxvb2t1cFRhYmxlLmdldChrZXkpO1xyXG4gICAgICAgIGlmICghbm9kZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnJlbW92ZU5vZGVGcm9tTGlzdEFuZExvb2t1cFRhYmxlKG5vZGUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgYm9vbGVhbiBhc3NlcnRpbmcgd2hldGhlciBhIHZhbHVlIGhhcyBiZWVuIGFzc29jaWF0ZWQgdG8gdGhlIGtleSBpbiB0aGUgTFJVQ2FjaGUgb2JqZWN0IG9yIG5vdC5cclxuICAgICAqIFRoaXMgZG9lcyBub3QgbWFyayB0aGUgZW50cnkgYXMgcmVjZW50bHkgdXNlZC5cclxuICAgICAqIElmIHRoZSBjYWNoZSBoYXMgYSBrZXkgYnV0IHRoZSBlbnRyeSBpcyBleHBpcmVkLCBpdCB3aWxsIGJlIHJlbW92ZWQgYW5kIGZhbHNlIHdpbGwgYmUgcmV0dXJuZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjayBpZiBleGlzdHNcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBjYWNoZSBjb250YWlucyB0aGUgc3VwcGxpZWQga2V5LiBGYWxzZSBpZiBub3QuXHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIGNvbnN0IGNhY2hlID0gbmV3IExSVUNhY2hlKCk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gU2V0IHRoZSBrZXkgdGVzdEtleSB0byB2YWx1ZSB0ZXN0VmFsdWVcclxuICAgICAqIGNhY2hlLnNldCgndGVzdEtleScsICd0ZXN0VmFsdWUnKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBXaWxsIGJlIHRydWVcclxuICAgICAqIGNvbnN0IHdhc0RlbGV0ZWQgPSBjYWNoZS5oYXMoJ3Rlc3RLZXknKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBXaWxsIGJlIGZhbHNlXHJcbiAgICAgKiBjb25zdCB3YXNEZWxldGVkMiA9IGNhY2hlLmhhcygna2V5Tm90SW5DYWNoZScpO1xyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIGhhcyhrZXkpIHtcclxuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5sb29rdXBUYWJsZS5nZXQoa2V5KTtcclxuICAgICAgICBpZiAoIW5vZGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobm9kZS5pc0V4cGlyZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVOb2RlRnJvbUxpc3RBbmRMb29rdXBUYWJsZShub2RlKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhbGwgZW50cmllcyBpbiB0aGUgY2FjaGUuXHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIGNvbnN0IGNhY2hlID0gbmV3IExSVUNhY2hlKCk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gU2V0IHRoZSBrZXkgdGVzdEtleSB0byB2YWx1ZSB0ZXN0VmFsdWVcclxuICAgICAqIGNhY2hlLnNldCgndGVzdEtleScsICd0ZXN0VmFsdWUnKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBDbGVhciBjYWNoZS5cclxuICAgICAqIGNhY2hlLmNsZWFyKCk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgY2xlYXIoKSB7XHJcbiAgICAgICAgdGhpcy5oZWFkID0gbnVsbDtcclxuICAgICAgICB0aGlzLnRhaWwgPSBudWxsO1xyXG4gICAgICAgIHRoaXMubG9va3VwVGFibGUuY2xlYXIoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2VhcmNoZXMgdGhlIGNhY2hlIGZvciBhbiBlbnRyeSBtYXRjaGluZyB0aGUgcGFzc2VkIGluIGNvbmRpdGlvbi5cclxuICAgICAqIEV4cGlyZWQgZW50cmllcyB3aWxsIGJlIHNraXBwZWQgKGFuZCByZW1vdmVkKS5cclxuICAgICAqIElmIG11bHRpcGx5IGVudHJpZXMgaW4gdGhlIGNhY2hlIG1hdGNoIHRoZSBjb25kaXRpb24sIHRoZSBtb3N0IHJlY2VudGx5IHVzZWQgZW50cnkgd2lsbCBiZSByZXR1cm5lZC5cclxuICAgICAqIElmIGFuIGVudHJ5IGlzIHJldHVybmVkLCB0aGlzIG1hcmtzIHRoZSByZXR1cm5lZCBlbnRyeSBhcyB0aGUgbW9zdCByZWNlbnRseSB1c2VkIGVudHJ5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjb25kaXRpb24gVGhlIGNvbmRpdGlvbiB0byBhcHBseSB0byBlYWNoIGVudHJ5IGluIHRoZVxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFRoZSBmaXJzdCBjYWNoZSBlbnRyeSB0byBtYXRjaCB0aGUgY29uZGl0aW9uLiBOdWxsIGlmIG5vbmUgbWF0Y2guXHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIGNvbnN0IGNhY2hlID0gbmV3IExSVUNhY2hlKCk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gU2V0IHRoZSBrZXkgdGVzdEtleSB0byB2YWx1ZSB0ZXN0VmFsdWVcclxuICAgICAqIGNhY2hlLnNldCgndGVzdEtleScsICd0ZXN0VmFsdWUnKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBpdGVtIHdpbGwgYmUgeyBrZXk6ICd0ZXN0S2V5JywgdmFsdWU6ICd0ZXN0VmFsdWUgfVxyXG4gICAgICogY29uc3QgaXRlbSA9IGNhY2hlLmZpbmQoZW50cnkgPT4ge1xyXG4gICAgICogICBjb25zdCB7IGtleSwgdmFsdWUgfSA9IGVudHJ5O1xyXG4gICAgICpcclxuICAgICAqICAgaWYgKGtleSA9PT0gJ3Rlc3RLZXknIHx8IHZhbHVlID09PSAnc29tZXRoaW5nJykge1xyXG4gICAgICogICAgIHJldHVybiB0cnVlO1xyXG4gICAgICogICB9XHJcbiAgICAgKlxyXG4gICAgICogICByZXR1cm4gZmFsc2U7XHJcbiAgICAgKiB9KTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBpdGVtMiB3aWxsIGJlIG51bGxcclxuICAgICAqIGNvbnN0IGl0ZW0yID0gY2FjaGUuZmluZChlbnRyeSA9PiBlbnRyeS5rZXkgPT09ICdub3RJbkNhY2hlJyk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgZmluZChjb25kaXRpb24pIHtcclxuICAgICAgICBsZXQgbm9kZSA9IHRoaXMuaGVhZDtcclxuICAgICAgICB3aGlsZSAobm9kZSkge1xyXG4gICAgICAgICAgICBpZiAobm9kZS5pc0V4cGlyZWQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSBub2RlLm5leHQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZU5vZGVGcm9tTGlzdEFuZExvb2t1cFRhYmxlKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5leHQ7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBlbnRyeSA9IHRoaXMubWFwTm9kZVRvRW50cnkobm9kZSk7XHJcbiAgICAgICAgICAgIGlmIChjb25kaXRpb24oZW50cnkpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldE5vZGVBc0hlYWQobm9kZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZW50cnk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEl0ZXJhdGVzIG92ZXIgYW5kIGFwcGxpZXMgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGVhY2ggZW50cnkgaW4gdGhlIGNhY2hlLlxyXG4gICAgICogSXRlcmF0ZXMgaW4gb3JkZXIgZnJvbSBtb3N0IHJlY2VudGx5IGFjY2Vzc2VkIGVudHJ5IHRvIGxlYXN0IHJlY2VudGx5LlxyXG4gICAgICogRXhwaXJlZCBlbnRyaWVzIHdpbGwgYmUgc2tpcHBlZCAoYW5kIHJlbW92ZWQpLlxyXG4gICAgICogTm8gZW50cnkgd2lsbCBiZSBtYXJrZWQgYXMgcmVjZW50bHkgdXNlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIHRoZSBlbnRyeVxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiBjb25zdCBjYWNoZSA9IG5ldyBMUlVDYWNoZSgpO1xyXG4gICAgICpcclxuICAgICAqIC8vIFNldCB0aGUga2V5IHRlc3RLZXkgdG8gdmFsdWUgdGVzdFZhbHVlXHJcbiAgICAgKiBjYWNoZS5zZXQoJ3Rlc3RLZXknLCAndGVzdFZhbHVlJyk7XHJcbiAgICAgKlxyXG4gICAgICogY2FjaGUuZm9yRWFjaCgoa2V5LCB2YWx1ZSwgaW5kZXgpID0+IHtcclxuICAgICAqICAgLy8gZG8gc29tZXRoaW5nIHdpdGgga2V5LCB2YWx1ZSwgYW5kL29yIGluZGV4XHJcbiAgICAgKiB9KTtcclxuICAgICAqIGBgYFxyXG4gICAgICovXHJcbiAgICBmb3JFYWNoKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmhlYWQ7XHJcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcclxuICAgICAgICB3aGlsZSAobm9kZSkge1xyXG4gICAgICAgICAgICBpZiAobm9kZS5pc0V4cGlyZWQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSBub2RlLm5leHQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZU5vZGVGcm9tTGlzdEFuZExvb2t1cFRhYmxlKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5leHQ7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYWxsYmFjayhub2RlLnZhbHVlLCBub2RlLmtleSwgaW5kZXgpO1xyXG4gICAgICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xyXG4gICAgICAgICAgICBpbmRleCsrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIEdlbmVyYXRvciB3aGljaCBjYW4gYmUgdXNlZCB3aXRoIGZvciAuLi4gb2YgLi4uIHRvIGl0ZXJhdGUgb3ZlciB0aGUgY2FjaGUgdmFsdWVzLlxyXG4gICAgICogSXRlcmF0ZXMgaW4gb3JkZXIgZnJvbSBtb3N0IHJlY2VudGx5IGFjY2Vzc2VkIGVudHJ5IHRvIGxlYXN0IHJlY2VudGx5LlxyXG4gICAgICogRXhwaXJlZCBlbnRyaWVzIHdpbGwgYmUgc2tpcHBlZCAoYW5kIHJlbW92ZWQpLlxyXG4gICAgICogTm8gZW50cnkgd2lsbCBiZSBtYXJrZWQgYXMgYWNjZXNzZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgQSBHZW5lcmF0b3IgZm9yIHRoZSBjYWNoZSB2YWx1ZXMuXHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIGNvbnN0IGNhY2hlID0gbmV3IExSVUNhY2hlKCk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gU2V0IHRoZSBrZXkgdGVzdEtleSB0byB2YWx1ZSB0ZXN0VmFsdWVcclxuICAgICAqIGNhY2hlLnNldCgndGVzdEtleScsICd0ZXN0VmFsdWUnKTtcclxuICAgICAqXHJcbiAgICAgKiBmb3IgKGNvbnN0IHZhbHVlIG9mIGNhY2hlLnZhbHVlcygpKSB7XHJcbiAgICAgKiAgIC8vIGRvIHNvbWV0aGluZyB3aXRoIHRoZSB2YWx1ZVxyXG4gICAgICogfVxyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgICp2YWx1ZXMoKSB7XHJcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmhlYWQ7XHJcbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcclxuICAgICAgICAgICAgaWYgKG5vZGUuaXNFeHBpcmVkKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gbm9kZS5uZXh0O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVOb2RlRnJvbUxpc3RBbmRMb29rdXBUYWJsZShub2RlKTtcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBuZXh0O1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgeWllbGQgbm9kZS52YWx1ZTtcclxuICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBHZW5lcmF0b3Igd2hpY2ggY2FuIGJlIHVzZWQgd2l0aCBmb3IgLi4uIG9mIC4uLiB0byBpdGVyYXRlIG92ZXIgdGhlIGNhY2hlIGtleXMuXHJcbiAgICAgKiBJdGVyYXRlcyBpbiBvcmRlciBmcm9tIG1vc3QgcmVjZW50bHkgYWNjZXNzZWQgZW50cnkgdG8gbGVhc3QgcmVjZW50bHkuXHJcbiAgICAgKiBFeHBpcmVkIGVudHJpZXMgd2lsbCBiZSBza2lwcGVkIChhbmQgcmVtb3ZlZCkuXHJcbiAgICAgKiBObyBlbnRyeSB3aWxsIGJlIG1hcmtlZCBhcyBhY2Nlc3NlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBBIEdlbmVyYXRvciBmb3IgdGhlIGNhY2hlIGtleXMuXHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIGNvbnN0IGNhY2hlID0gbmV3IExSVUNhY2hlKCk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gU2V0IHRoZSBrZXkgdGVzdEtleSB0byB2YWx1ZSB0ZXN0VmFsdWVcclxuICAgICAqIGNhY2hlLnNldCgndGVzdEtleScsICd0ZXN0VmFsdWUnKTtcclxuICAgICAqXHJcbiAgICAgKiBmb3IgKGNvbnN0IGtleSBvZiBjYWNoZS5rZXlzKCkpIHtcclxuICAgICAqICAgLy8gZG8gc29tZXRoaW5nIHdpdGggdGhlIGtleVxyXG4gICAgICogfVxyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgICprZXlzKCkge1xyXG4gICAgICAgIGxldCBub2RlID0gdGhpcy5oZWFkO1xyXG4gICAgICAgIHdoaWxlIChub2RlKSB7XHJcbiAgICAgICAgICAgIGlmIChub2RlLmlzRXhwaXJlZCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IG5vZGUubmV4dDtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTm9kZUZyb21MaXN0QW5kTG9va3VwVGFibGUobm9kZSk7XHJcbiAgICAgICAgICAgICAgICBub2RlID0gbmV4dDtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHlpZWxkIG5vZGUua2V5O1xyXG4gICAgICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIEdlbmVyYXRvciB3aGljaCBjYW4gYmUgdXNlZCB3aXRoIGZvciAuLi4gb2YgLi4uIHRvIGl0ZXJhdGUgb3ZlciB0aGUgY2FjaGUgZW50cmllcy5cclxuICAgICAqIEl0ZXJhdGVzIGluIG9yZGVyIGZyb20gbW9zdCByZWNlbnRseSBhY2Nlc3NlZCBlbnRyeSB0byBsZWFzdCByZWNlbnRseS5cclxuICAgICAqIEV4cGlyZWQgZW50cmllcyB3aWxsIGJlIHNraXBwZWQgKGFuZCByZW1vdmVkKS5cclxuICAgICAqIE5vIGVudHJ5IHdpbGwgYmUgbWFya2VkIGFzIGFjY2Vzc2VkLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIEEgR2VuZXJhdG9yIGZvciB0aGUgY2FjaGUgZW50cmllcy5cclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogY29uc3QgY2FjaGUgPSBuZXcgTFJVQ2FjaGUoKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBTZXQgdGhlIGtleSB0ZXN0S2V5IHRvIHZhbHVlIHRlc3RWYWx1ZVxyXG4gICAgICogY2FjaGUuc2V0KCd0ZXN0S2V5JywgJ3Rlc3RWYWx1ZScpO1xyXG4gICAgICpcclxuICAgICAqIGZvciAoY29uc3QgZW50cnkgb2YgY2FjaGUuZW50cmllcygpKSB7XHJcbiAgICAgKiAgIGNvbnN0IHsga2V5LCB2YWx1ZSB9ID0gZW50cnk7XHJcbiAgICAgKiAgIC8vIGRvIHNvbWV0aGluZyB3aXRoIHRoZSBlbnRyeVxyXG4gICAgICogfVxyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgICplbnRyaWVzKCkge1xyXG4gICAgICAgIGxldCBub2RlID0gdGhpcy5oZWFkO1xyXG4gICAgICAgIHdoaWxlIChub2RlKSB7XHJcbiAgICAgICAgICAgIGlmIChub2RlLmlzRXhwaXJlZCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IG5vZGUubmV4dDtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTm9kZUZyb21MaXN0QW5kTG9va3VwVGFibGUobm9kZSk7XHJcbiAgICAgICAgICAgICAgICBub2RlID0gbmV4dDtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHlpZWxkIHRoaXMubWFwTm9kZVRvRW50cnkobm9kZSk7XHJcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgR2VuZXJhdG9yIHdoaWNoIGNhbiBiZSB1c2VkIHdpdGggZm9yIC4uLiBvZiAuLi4gdG8gaXRlcmF0ZSBvdmVyIHRoZSBjYWNoZSBlbnRyaWVzLlxyXG4gICAgICogSXRlcmF0ZXMgaW4gb3JkZXIgZnJvbSBtb3N0IHJlY2VudGx5IGFjY2Vzc2VkIGVudHJ5IHRvIGxlYXN0IHJlY2VudGx5LlxyXG4gICAgICogRXhwaXJlZCBlbnRyaWVzIHdpbGwgYmUgc2tpcHBlZCAoYW5kIHJlbW92ZWQpLlxyXG4gICAgICogTm8gZW50cnkgd2lsbCBiZSBtYXJrZWQgYXMgYWNjZXNzZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgQSBHZW5lcmF0b3IgZm9yIHRoZSBjYWNoZSBlbnRyaWVzLlxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiBjb25zdCBjYWNoZSA9IG5ldyBMUlVDYWNoZSgpO1xyXG4gICAgICpcclxuICAgICAqIC8vIFNldCB0aGUga2V5IHRlc3RLZXkgdG8gdmFsdWUgdGVzdFZhbHVlXHJcbiAgICAgKiBjYWNoZS5zZXQoJ3Rlc3RLZXknLCAndGVzdFZhbHVlJyk7XHJcbiAgICAgKlxyXG4gICAgICogZm9yIChjb25zdCBlbnRyeSBvZiBjYWNoZSkge1xyXG4gICAgICogICBjb25zdCB7IGtleSwgdmFsdWUgfSA9IGVudHJ5O1xyXG4gICAgICogICAvLyBkbyBzb21ldGhpbmcgd2l0aCB0aGUgZW50cnlcclxuICAgICAqIH1cclxuICAgICAqIGBgYFxyXG4gICAgICovXHJcbiAgICAqW1N5bWJvbC5pdGVyYXRvcl0oKSB7XHJcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmhlYWQ7XHJcbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcclxuICAgICAgICAgICAgaWYgKG5vZGUuaXNFeHBpcmVkKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gbm9kZS5uZXh0O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVOb2RlRnJvbUxpc3RBbmRMb29rdXBUYWJsZShub2RlKTtcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBuZXh0O1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgeWllbGQgdGhpcy5tYXBOb2RlVG9FbnRyeShub2RlKTtcclxuICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbmZvcmNlU2l6ZUxpbWl0KCkge1xyXG4gICAgICAgIGxldCBub2RlID0gdGhpcy50YWlsO1xyXG4gICAgICAgIHdoaWxlIChub2RlICE9PSBudWxsICYmIHRoaXMuc2l6ZSA+IHRoaXMubWF4U2l6ZUludGVybmFsKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByZXYgPSBub2RlLnByZXY7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlTm9kZUZyb21MaXN0QW5kTG9va3VwVGFibGUobm9kZSk7XHJcbiAgICAgICAgICAgIG5vZGUgPSBwcmV2O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG1hcE5vZGVUb0VudHJ5KHsga2V5LCB2YWx1ZSB9KSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAga2V5LFxyXG4gICAgICAgICAgICB2YWx1ZVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBzZXROb2RlQXNIZWFkKG5vZGUpIHtcclxuICAgICAgICB0aGlzLnJlbW92ZU5vZGVGcm9tTGlzdChub2RlKTtcclxuICAgICAgICBpZiAoIXRoaXMuaGVhZCkge1xyXG4gICAgICAgICAgICB0aGlzLmhlYWQgPSBub2RlO1xyXG4gICAgICAgICAgICB0aGlzLnRhaWwgPSBub2RlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbm9kZS5uZXh0ID0gdGhpcy5oZWFkO1xyXG4gICAgICAgICAgICB0aGlzLmhlYWQucHJldiA9IG5vZGU7XHJcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IG5vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG5vZGUuaW52b2tlT25FbnRyeU1hcmtlZEFzTW9zdFJlY2VudGx5VXNlZCgpO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlTm9kZUZyb21MaXN0KG5vZGUpIHtcclxuICAgICAgICBpZiAobm9kZS5wcmV2ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIG5vZGUucHJldi5uZXh0ID0gbm9kZS5uZXh0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobm9kZS5uZXh0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIG5vZGUubmV4dC5wcmV2ID0gbm9kZS5wcmV2O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5oZWFkID09PSBub2RlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IG5vZGUubmV4dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMudGFpbCA9PT0gbm9kZSkge1xyXG4gICAgICAgICAgICB0aGlzLnRhaWwgPSBub2RlLnByZXY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG5vZGUubmV4dCA9IG51bGw7XHJcbiAgICAgICAgbm9kZS5wcmV2ID0gbnVsbDtcclxuICAgIH1cclxuICAgIHJlbW92ZU5vZGVGcm9tTGlzdEFuZExvb2t1cFRhYmxlKG5vZGUpIHtcclxuICAgICAgICBub2RlLmludm9rZU9uRXZpY3RlZCgpO1xyXG4gICAgICAgIHRoaXMucmVtb3ZlTm9kZUZyb21MaXN0KG5vZGUpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxvb2t1cFRhYmxlLmRlbGV0ZShub2RlLmtleSk7XHJcbiAgICB9XHJcbiAgICBjbGVhbkNhY2hlKCkge1xyXG4gICAgICAgIC8vIERvbid0IHNwZW5kIHRpbWUgY2xlYW5pbmcgaWYgZW50cmllcyBkb24ndCBleHBpcmUuXHJcbiAgICAgICAgaWYgKCF0aGlzLmVudHJ5RXhwaXJhdGlvblRpbWVJbk1TKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZXhwaXJlZE5vZGVzID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIHRoaXMubG9va3VwVGFibGUudmFsdWVzKCkpIHtcclxuICAgICAgICAgICAgaWYgKG5vZGUuaXNFeHBpcmVkKSB7XHJcbiAgICAgICAgICAgICAgICBleHBpcmVkTm9kZXMucHVzaChub2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBleHBpcmVkTm9kZXMuZm9yRWFjaChub2RlID0+IHRoaXMucmVtb3ZlTm9kZUZyb21MaXN0QW5kTG9va3VwVGFibGUobm9kZSkpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuTFJVQ2FjaGUgPSBMUlVDYWNoZTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TFJVQ2FjaGUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/typescript-lru-cache/dist/LRUCache.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/typescript-lru-cache/dist/LRUCacheNode.js":
/*!****************************************************************!*\
  !*** ./node_modules/typescript-lru-cache/dist/LRUCacheNode.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.LRUCacheNode = void 0;\r\nclass LRUCacheNode {\r\n    constructor(key, value, options) {\r\n        const { entryExpirationTimeInMS = null, next = null, prev = null, onEntryEvicted, onEntryMarkedAsMostRecentlyUsed, clone, cloneFn } = options !== null && options !== void 0 ? options : {};\r\n        if (typeof entryExpirationTimeInMS === 'number' &&\r\n            (entryExpirationTimeInMS <= 0 || Number.isNaN(entryExpirationTimeInMS))) {\r\n            throw new Error('entryExpirationTimeInMS must either be null (no expiry) or greater than 0');\r\n        }\r\n        this.clone = clone !== null && clone !== void 0 ? clone : false;\r\n        this.cloneFn = cloneFn !== null && cloneFn !== void 0 ? cloneFn : this.defaultClone;\r\n        this.key = key;\r\n        this.internalValue = this.clone ? this.cloneFn(value) : value;\r\n        this.created = Date.now();\r\n        this.entryExpirationTimeInMS = entryExpirationTimeInMS;\r\n        this.next = next;\r\n        this.prev = prev;\r\n        this.onEntryEvicted = onEntryEvicted;\r\n        this.onEntryMarkedAsMostRecentlyUsed = onEntryMarkedAsMostRecentlyUsed;\r\n    }\r\n    get value() {\r\n        return this.clone ? this.cloneFn(this.internalValue) : this.internalValue;\r\n    }\r\n    get isExpired() {\r\n        return typeof this.entryExpirationTimeInMS === 'number' && Date.now() - this.created > this.entryExpirationTimeInMS;\r\n    }\r\n    invokeOnEvicted() {\r\n        if (this.onEntryEvicted) {\r\n            const { key, value, isExpired } = this;\r\n            this.onEntryEvicted({ key, value, isExpired });\r\n        }\r\n    }\r\n    invokeOnEntryMarkedAsMostRecentlyUsed() {\r\n        if (this.onEntryMarkedAsMostRecentlyUsed) {\r\n            const { key, value } = this;\r\n            this.onEntryMarkedAsMostRecentlyUsed({ key, value });\r\n        }\r\n    }\r\n    defaultClone(value) {\r\n        if (typeof value === 'boolean' || typeof value === 'string' || typeof value === 'number') {\r\n            return value;\r\n        }\r\n        return JSON.parse(JSON.stringify(value));\r\n    }\r\n}\r\nexports.LRUCacheNode = LRUCacheNode;\r\n//# sourceMappingURL=LRUCacheNode.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90eXBlc2NyaXB0LWxydS1jYWNoZS9kaXN0L0xSVUNhY2hlTm9kZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLGdCQUFnQiw0SEFBNEg7QUFDNUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUMsa0NBQWtDLHVCQUF1QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDLG1EQUFtRCxZQUFZO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQiIsInNvdXJjZXMiOlsiL2hvbWUvbGZnL0dpdC9NYWR0cmlwcy9ub2RlX21vZHVsZXMvdHlwZXNjcmlwdC1scnUtY2FjaGUvZGlzdC9MUlVDYWNoZU5vZGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5MUlVDYWNoZU5vZGUgPSB2b2lkIDA7XHJcbmNsYXNzIExSVUNhY2hlTm9kZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihrZXksIHZhbHVlLCBvcHRpb25zKSB7XHJcbiAgICAgICAgY29uc3QgeyBlbnRyeUV4cGlyYXRpb25UaW1lSW5NUyA9IG51bGwsIG5leHQgPSBudWxsLCBwcmV2ID0gbnVsbCwgb25FbnRyeUV2aWN0ZWQsIG9uRW50cnlNYXJrZWRBc01vc3RSZWNlbnRseVVzZWQsIGNsb25lLCBjbG9uZUZuIH0gPSBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB7fTtcclxuICAgICAgICBpZiAodHlwZW9mIGVudHJ5RXhwaXJhdGlvblRpbWVJbk1TID09PSAnbnVtYmVyJyAmJlxyXG4gICAgICAgICAgICAoZW50cnlFeHBpcmF0aW9uVGltZUluTVMgPD0gMCB8fCBOdW1iZXIuaXNOYU4oZW50cnlFeHBpcmF0aW9uVGltZUluTVMpKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VudHJ5RXhwaXJhdGlvblRpbWVJbk1TIG11c3QgZWl0aGVyIGJlIG51bGwgKG5vIGV4cGlyeSkgb3IgZ3JlYXRlciB0aGFuIDAnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jbG9uZSA9IGNsb25lICE9PSBudWxsICYmIGNsb25lICE9PSB2b2lkIDAgPyBjbG9uZSA6IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuY2xvbmVGbiA9IGNsb25lRm4gIT09IG51bGwgJiYgY2xvbmVGbiAhPT0gdm9pZCAwID8gY2xvbmVGbiA6IHRoaXMuZGVmYXVsdENsb25lO1xyXG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xyXG4gICAgICAgIHRoaXMuaW50ZXJuYWxWYWx1ZSA9IHRoaXMuY2xvbmUgPyB0aGlzLmNsb25lRm4odmFsdWUpIDogdmFsdWU7XHJcbiAgICAgICAgdGhpcy5jcmVhdGVkID0gRGF0ZS5ub3coKTtcclxuICAgICAgICB0aGlzLmVudHJ5RXhwaXJhdGlvblRpbWVJbk1TID0gZW50cnlFeHBpcmF0aW9uVGltZUluTVM7XHJcbiAgICAgICAgdGhpcy5uZXh0ID0gbmV4dDtcclxuICAgICAgICB0aGlzLnByZXYgPSBwcmV2O1xyXG4gICAgICAgIHRoaXMub25FbnRyeUV2aWN0ZWQgPSBvbkVudHJ5RXZpY3RlZDtcclxuICAgICAgICB0aGlzLm9uRW50cnlNYXJrZWRBc01vc3RSZWNlbnRseVVzZWQgPSBvbkVudHJ5TWFya2VkQXNNb3N0UmVjZW50bHlVc2VkO1xyXG4gICAgfVxyXG4gICAgZ2V0IHZhbHVlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lID8gdGhpcy5jbG9uZUZuKHRoaXMuaW50ZXJuYWxWYWx1ZSkgOiB0aGlzLmludGVybmFsVmFsdWU7XHJcbiAgICB9XHJcbiAgICBnZXQgaXNFeHBpcmVkKCkge1xyXG4gICAgICAgIHJldHVybiB0eXBlb2YgdGhpcy5lbnRyeUV4cGlyYXRpb25UaW1lSW5NUyA9PT0gJ251bWJlcicgJiYgRGF0ZS5ub3coKSAtIHRoaXMuY3JlYXRlZCA+IHRoaXMuZW50cnlFeHBpcmF0aW9uVGltZUluTVM7XHJcbiAgICB9XHJcbiAgICBpbnZva2VPbkV2aWN0ZWQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMub25FbnRyeUV2aWN0ZWQpIHtcclxuICAgICAgICAgICAgY29uc3QgeyBrZXksIHZhbHVlLCBpc0V4cGlyZWQgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIHRoaXMub25FbnRyeUV2aWN0ZWQoeyBrZXksIHZhbHVlLCBpc0V4cGlyZWQgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaW52b2tlT25FbnRyeU1hcmtlZEFzTW9zdFJlY2VudGx5VXNlZCgpIHtcclxuICAgICAgICBpZiAodGhpcy5vbkVudHJ5TWFya2VkQXNNb3N0UmVjZW50bHlVc2VkKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsga2V5LCB2YWx1ZSB9ID0gdGhpcztcclxuICAgICAgICAgICAgdGhpcy5vbkVudHJ5TWFya2VkQXNNb3N0UmVjZW50bHlVc2VkKHsga2V5LCB2YWx1ZSB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBkZWZhdWx0Q2xvbmUodmFsdWUpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgfHwgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkxSVUNhY2hlTm9kZSA9IExSVUNhY2hlTm9kZTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TFJVQ2FjaGVOb2RlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/typescript-lru-cache/dist/LRUCacheNode.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/typescript-lru-cache/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/typescript-lru-cache/dist/index.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n      desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n__exportStar(__webpack_require__(/*! ./LRUCache */ \"(app-pages-browser)/./node_modules/typescript-lru-cache/dist/LRUCache.js\"), exports);\r\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90eXBlc2NyaXB0LWxydS1jYWNoZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsbUJBQU8sQ0FBQyw0RkFBWTtBQUNqQyIsInNvdXJjZXMiOlsiL2hvbWUvbGZnL0dpdC9NYWR0cmlwcy9ub2RlX21vZHVsZXMvdHlwZXNjcmlwdC1scnUtY2FjaGUvZGlzdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcclxuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XHJcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xyXG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIG9bazJdID0gbVtrXTtcclxufSkpO1xyXG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vTFJVQ2FjaGVcIiksIGV4cG9ydHMpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/typescript-lru-cache/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/lib/nostr/NostrAuthProvider.tsx":
/*!*********************************************!*\
  !*** ./src/lib/nostr/NostrAuthProvider.tsx ***!
  \*********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NostrAuthProvider: () => (/* binding */ NostrAuthProvider),\n/* harmony export */   TrustLevel: () => (/* binding */ TrustLevel),\n/* harmony export */   useNostrAuth: () => (/* binding */ useNostrAuth)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @nostr-dev-kit/ndk */ \"(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk/dist/index.mjs\");\n/* harmony import */ var _nostr_dev_kit_ndk_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @nostr-dev-kit/ndk-react */ \"(app-pages-browser)/./node_modules/@nostr-dev-kit/ndk-react/dist/ndk-react.es.js\");\n/* harmony import */ var nostr_tools__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! nostr-tools */ \"(app-pages-browser)/./node_modules/nostr-tools/lib/esm/index.js\");\n/* __next_internal_client_entry_do_not_use__ TrustLevel,useNostrAuth,NostrAuthProvider auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\n\n// Define the trust level enum\nvar TrustLevel = /*#__PURE__*/ function(TrustLevel) {\n    TrustLevel[TrustLevel[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n    TrustLevel[TrustLevel[\"LOW\"] = 1] = \"LOW\";\n    TrustLevel[TrustLevel[\"MEDIUM\"] = 2] = \"MEDIUM\";\n    TrustLevel[TrustLevel[\"HIGH\"] = 3] = \"HIGH\";\n    TrustLevel[TrustLevel[\"VERIFIED\"] = 4] = \"VERIFIED\";\n    return TrustLevel;\n}({});\n// Define core NPUBs to check for trust\nconst CORE_NPUBS = [\n    \"npub1etgqcj9gc6yaxttuwu9eqgs3ynt2dzaudvwnrssrn2zdt2useaasfj8n6e\",\n    \"npub1s0veng2gvfwr62acrxhnqexq76sj6ldg3a5t935jy8e6w3shr5vsnwrmq5\",\n    \"npub1dxd02kcjhgpkyrx60qnkd6j42kmc72u5lum0rp2ud8x5zfhnk4zscjj6hh\",\n    \"npub1funchalx8v747rsee6ahsuyrcd2s3rnxlyrtumfex9lecpmgwars6hq8kc\"\n];\n// Define a list of community relays\nconst COMMUNITY_RELAYS = [\n    \"wss://relay.damus.io\",\n    \"wss://relay.nostr.band\",\n    \"wss://nos.lol\",\n    \"wss://nostr.mutinywallet.com\"\n];\n// Create the context\nconst NostrAuthContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\n// Custom hook for accessing the context\nconst useNostrAuth = ()=>{\n    _s();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(NostrAuthContext);\n    if (!context) {\n        throw new Error('useNostrAuth must be used within a NostrAuthProvider');\n    }\n    return context;\n};\n_s(useNostrAuth, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\n// The provider component\nconst NostrAuthProvider = (param)=>{\n    let { children } = param;\n    _s1();\n    // NDK instance from the NDK provider\n    const { ndk } = (0,_nostr_dev_kit_ndk_react__WEBPACK_IMPORTED_MODULE_3__.useNDK)();\n    // State for authentication status\n    const [user, setUser] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [npub, setNpub] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [pubkey, setPubkey] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [isConnected, setIsConnected] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    // Reference to the connect manager - we'll create our own minimal implementation\n    const [connectManager, setConnectManager] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    // Initialize NostrConnect - simplified for this implementation\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"NostrAuthProvider.useEffect\": ()=>{\n            if (!ndk) return;\n            try {\n                // Instead of using the Connect class which has compatibility issues,\n                // we'll create a minimal manager object for testing purposes\n                const minimalManager = {\n                    connect: {\n                        \"NostrAuthProvider.useEffect\": async ()=>{\n                            // Simulate connection by returning a random core NPUB\n                            const mockPubkey = CORE_NPUBS[Math.floor(Math.random() * CORE_NPUBS.length)];\n                            const { data: hexPubkey } = nostr_tools__WEBPACK_IMPORTED_MODULE_4__.nip19.decode(mockPubkey);\n                            return {\n                                pubkey: hexPubkey,\n                                secretKey: 'mock_secret'\n                            };\n                        }\n                    }[\"NostrAuthProvider.useEffect\"]\n                };\n                setConnectManager(minimalManager);\n                // Try to restore session\n                const restoreSession = {\n                    \"NostrAuthProvider.useEffect.restoreSession\": async ()=>{\n                        try {\n                            const session = localStorage.getItem('nostrSession');\n                            if (session) {\n                                const sessionData = JSON.parse(session);\n                                if (sessionData && sessionData.pubkey && sessionData.npub) {\n                                    setPubkey(sessionData.pubkey);\n                                    setNpub(sessionData.npub);\n                                    setIsConnected(true);\n                                    // Create user object\n                                    const userObj = {\n                                        pubkey: sessionData.pubkey,\n                                        npub: sessionData.npub,\n                                        name: sessionData.name || '',\n                                        profileImage: sessionData.profileImage || ''\n                                    };\n                                    setUser(userObj);\n                                    // Load the user profile\n                                    await loadUserProfile(sessionData.npub);\n                                }\n                            }\n                        } catch (err) {\n                            console.error('Error restoring session:', err);\n                            localStorage.removeItem('nostrSession');\n                        }\n                    }\n                }[\"NostrAuthProvider.useEffect.restoreSession\"];\n                restoreSession();\n            } catch (err) {\n                console.error('Error initializing Nostr:', err);\n                setError('Failed to initialize Nostr connection');\n            }\n        }\n    }[\"NostrAuthProvider.useEffect\"], [\n        ndk\n    ]);\n    // Function to load user profile data\n    const loadUserProfile = async (userNpub)=>{\n        if (!ndk) return;\n        try {\n            var _user_profile, _user_profile1, _user_profile2, _user_profile3;\n            // Create an NDK user from the npub\n            const { type, data: hexPubkey } = nostr_tools__WEBPACK_IMPORTED_MODULE_4__.nip19.decode(userNpub);\n            if (type !== 'npub') {\n                throw new Error('Invalid npub');\n            }\n            // Fetch user profile\n            const user = ndk.getUser({\n                pubkey: hexPubkey\n            });\n            await user.fetchProfile();\n            // Update user data\n            setUser({\n                pubkey: hexPubkey,\n                npub: userNpub,\n                name: ((_user_profile = user.profile) === null || _user_profile === void 0 ? void 0 : _user_profile.name) || '',\n                profileImage: ((_user_profile1 = user.profile) === null || _user_profile1 === void 0 ? void 0 : _user_profile1.image) || ''\n            });\n            // Save to local storage\n            const sessionData = {\n                pubkey: hexPubkey,\n                npub: userNpub,\n                name: ((_user_profile2 = user.profile) === null || _user_profile2 === void 0 ? void 0 : _user_profile2.name) || '',\n                profileImage: ((_user_profile3 = user.profile) === null || _user_profile3 === void 0 ? void 0 : _user_profile3.image) || ''\n            };\n            localStorage.setItem('nostrSession', JSON.stringify(sessionData));\n        } catch (err) {\n            console.error('Error loading user profile:', err);\n        }\n    };\n    // Login function\n    const login = async ()=>{\n        if (!ndk || !connectManager) {\n            setError('Nostr connection not initialized');\n            return;\n        }\n        setIsLoading(true);\n        setError(null);\n        try {\n            // First try NIP-07 login if available\n            try {\n                // Check if the browser has a NIP-07 extension\n                const hasNip07 = window && 'nostr' in window;\n                if (hasNip07) {\n                    // Use the NIP-07 signer\n                    const signer = new _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKNip07Signer();\n                    ndk.signer = signer;\n                    // Get the user's public key\n                    const userPubkey = await signer.user();\n                    if (userPubkey) {\n                        const userNpub = nostr_tools__WEBPACK_IMPORTED_MODULE_4__.nip19.npubEncode(userPubkey.pubkey);\n                        setPubkey(userPubkey.pubkey);\n                        setNpub(userNpub);\n                        setIsConnected(true);\n                        await loadUserProfile(userNpub);\n                        return;\n                    }\n                }\n            } catch (err) {\n                console.log('NIP-07 login failed, falling back to our minimal connect implementation:', err);\n            }\n            // Fall back to our minimal connect implementation\n            const { pubkey: hexPubkey } = await connectManager.connect();\n            // Convert to npub\n            const mockPubkey = nostr_tools__WEBPACK_IMPORTED_MODULE_4__.nip19.npubEncode(hexPubkey);\n            setPubkey(hexPubkey);\n            setNpub(mockPubkey);\n            setIsConnected(true);\n            // Create a basic user object\n            const userObj = {\n                pubkey: hexPubkey,\n                npub: mockPubkey,\n                name: 'Test User',\n                profileImage: ''\n            };\n            setUser(userObj);\n            // Save to local storage\n            localStorage.setItem('nostrSession', JSON.stringify(userObj));\n        } catch (err) {\n            console.error('Login error:', err);\n            setError('Failed to login with Nostr');\n        } finally{\n            setIsLoading(false);\n        }\n    };\n    // Logout function\n    const logout = ()=>{\n        setUser(null);\n        setNpub(null);\n        setPubkey(null);\n        setIsConnected(false);\n        // Clear local storage\n        localStorage.removeItem('nostrSession');\n    };\n    // Check trust level of a npub\n    const checkTrustLevel = async (targetNpub)=>{\n        if (!ndk || !isConnected) return 0;\n        try {\n            // Check if it's a core npub\n            if (CORE_NPUBS.includes(targetNpub)) {\n                return 4;\n            }\n            // Check if it's directly connected to us\n            const { directConnections } = await getWebOfTrust();\n            if (directConnections.includes(targetNpub)) {\n                return 3;\n            }\n            // Check if it's indirectly connected\n            const { secondDegreeConnections } = await getWebOfTrust();\n            if (secondDegreeConnections.includes(targetNpub)) {\n                return 2;\n            }\n            // Otherwise, it's a low trust connection\n            return 1;\n        } catch (err) {\n            console.error('Error checking trust level:', err);\n            return 0;\n        }\n    };\n    // Publish an event\n    const publishEvent = async (event)=>{\n        if (!ndk || !isConnected) return null;\n        try {\n            const ndkEvent = new _nostr_dev_kit_ndk__WEBPACK_IMPORTED_MODULE_2__.NDKEvent(ndk);\n            ndkEvent.kind = event.kind;\n            ndkEvent.content = event.content;\n            ndkEvent.tags = event.tags || [];\n            // Publish the event\n            await ndkEvent.publish();\n            return ndkEvent;\n        } catch (err) {\n            console.error('Error publishing event:', err);\n            return null;\n        }\n    };\n    // Get web of trust\n    const getWebOfTrust = async ()=>{\n        if (!ndk || !isConnected || !pubkey) {\n            return {\n                directConnections: [],\n                secondDegreeConnections: [],\n                coreFollowers: []\n            };\n        }\n        try {\n            // For simplicity, we'll use a mock implementation\n            // In a real implementation, this would query the relays for follows\n            // Mock direct connections\n            const directConnections = CORE_NPUBS.filter(()=>Math.random() > 0.5);\n            // Mock second-degree connections\n            const secondDegreeConnections = CORE_NPUBS.filter(()=>Math.random() > 0.7);\n            // Mock core followers\n            const coreFollowers = CORE_NPUBS.filter(()=>Math.random() > 0.8);\n            return {\n                directConnections,\n                secondDegreeConnections,\n                coreFollowers\n            };\n        } catch (err) {\n            console.error('Error getting web of trust:', err);\n            return {\n                directConnections: [],\n                secondDegreeConnections: [],\n                coreFollowers: []\n            };\n        }\n    };\n    // Context value\n    const value = {\n        user,\n        npub,\n        pubkey,\n        isConnected,\n        isLoading,\n        error,\n        login,\n        logout,\n        checkTrustLevel,\n        publishEvent,\n        getWebOfTrust\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(NostrAuthContext.Provider, {\n        value: value,\n        children: children\n    }, void 0, false, {\n        fileName: \"/home/lfg/Git/Madtrips/src/lib/nostr/NostrAuthProvider.tsx\",\n        lineNumber: 372,\n        columnNumber: 5\n    }, undefined);\n};\n_s1(NostrAuthProvider, \"JC1CBGG50mdECnkG6AfQzMMmKxg=\", false, function() {\n    return [\n        _nostr_dev_kit_ndk_react__WEBPACK_IMPORTED_MODULE_3__.useNDK\n    ];\n});\n_c = NostrAuthProvider;\nvar _c;\n$RefreshReg$(_c, \"NostrAuthProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvbm9zdHIvTm9zdHJBdXRoUHJvdmlkZXIudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBRXlGO0FBQ1U7QUFDakQ7QUFDZDtBQUVwQyw4QkFBOEI7QUFDdkIsd0NBQUtTOzs7Ozs7V0FBQUE7TUFNWDtBQXlCRCx1Q0FBdUM7QUFDdkMsTUFBTUMsYUFBYTtJQUNqQjtJQUNBO0lBQ0E7SUFDQTtDQUNEO0FBRUQsb0NBQW9DO0FBQ3BDLE1BQU1DLG1CQUFtQjtJQUN2QjtJQUNBO0lBQ0E7SUFDQTtDQUNEO0FBRUQscUJBQXFCO0FBQ3JCLE1BQU1DLGlDQUFtQlgsb0RBQWFBLENBQW1CO0FBT3pELHdDQUF3QztBQUNqQyxNQUFNWSxlQUFlOztJQUMxQixNQUFNQyxVQUFVWixpREFBVUEsQ0FBQ1U7SUFDM0IsSUFBSSxDQUFDRSxTQUFTO1FBQ1osTUFBTSxJQUFJQyxNQUFNO0lBQ2xCO0lBQ0EsT0FBT0Q7QUFDVCxFQUFFO0dBTldEO0FBUWIseUJBQXlCO0FBQ2xCLE1BQU1HLG9CQUFzRDtRQUFDLEVBQUVDLFFBQVEsRUFBRTs7SUFDOUUscUNBQXFDO0lBQ3JDLE1BQU0sRUFBRUMsR0FBRyxFQUFFLEdBQUdYLGdFQUFNQTtJQUV0QixrQ0FBa0M7SUFDbEMsTUFBTSxDQUFDWSxNQUFNQyxRQUFRLEdBQUdqQiwrQ0FBUUEsQ0FBaUY7SUFDakgsTUFBTSxDQUFDa0IsTUFBTUMsUUFBUSxHQUFHbkIsK0NBQVFBLENBQWdCO0lBQ2hELE1BQU0sQ0FBQ29CLFFBQVFDLFVBQVUsR0FBR3JCLCtDQUFRQSxDQUFnQjtJQUNwRCxNQUFNLENBQUNzQixhQUFhQyxlQUFlLEdBQUd2QiwrQ0FBUUEsQ0FBQztJQUMvQyxNQUFNLENBQUN3QixXQUFXQyxhQUFhLEdBQUd6QiwrQ0FBUUEsQ0FBQztJQUMzQyxNQUFNLENBQUMwQixPQUFPQyxTQUFTLEdBQUczQiwrQ0FBUUEsQ0FBZ0I7SUFFbEQsaUZBQWlGO0lBQ2pGLE1BQU0s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O1FBQ0FxQztRQUNBTztRQUNBQztRQUNBTTtRQUNBRjtJQUNGO0lBRUEscUJBQ0UsOERBQUNsRSxpQkFBaUI4RSxRQUFRO1FBQUNELE9BQU9BO2tCQUMvQnhFOzs7Ozs7QUFHUCxFQUFFO0lBOVNXRDs7UUFFS1QsNERBQU1BOzs7S0FGWFMiLCJzb3VyY2VzIjpbIi9ob21lL2xmZy9HaXQvTWFkdHJpcHMvc3JjL2xpYi9ub3N0ci9Ob3N0ckF1dGhQcm92aWRlci50c3giXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgUmVhY3QsIHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlU3RhdGUsIHVzZUVmZmVjdCwgUmVhY3ROb2RlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IE5ESywgeyBOREtOaXAwN1NpZ25lciwgTkRLVXNlciwgTkRLRXZlbnQsIE5ES0ZpbHRlciwgTm9zdHJFdmVudCB9IGZyb20gJ0Bub3N0ci1kZXYta2l0L25kayc7XG5pbXBvcnQgeyB1c2VOREsgfSBmcm9tICdAbm9zdHItZGV2LWtpdC9uZGstcmVhY3QnO1xuaW1wb3J0IHsgbmlwMTkgfSBmcm9tICdub3N0ci10b29scyc7XG5cbi8vIERlZmluZSB0aGUgdHJ1c3QgbGV2ZWwgZW51bVxuZXhwb3J0IGVudW0gVHJ1c3RMZXZlbCB7XG4gIFVOS05PV04gPSAwLFxuICBMT1cgPSAxLFxuICBNRURJVU0gPSAyLFxuICBISUdIID0gMyxcbiAgVkVSSUZJRUQgPSA0XG59XG5cbmludGVyZmFjZSBOb3N0ckF1dGgge1xuICB1c2VyOiB7XG4gICAgcHVia2V5OiBzdHJpbmc7XG4gICAgbnB1Yjogc3RyaW5nO1xuICAgIG5hbWU/OiBzdHJpbmc7XG4gICAgcHJvZmlsZUltYWdlPzogc3RyaW5nO1xuICB9IHwgbnVsbDtcbiAgbnB1Yjogc3RyaW5nIHwgbnVsbDtcbiAgcHVia2V5OiBzdHJpbmcgfCBudWxsO1xuICBpc0Nvbm5lY3RlZDogYm9vbGVhbjtcbiAgaXNMb2FkaW5nOiBib29sZWFuO1xuICBlcnJvcjogc3RyaW5nIHwgbnVsbDtcbiAgbG9naW46ICgpID0+IFByb21pc2U8dm9pZD47XG4gIGxvZ291dDogKCkgPT4gdm9pZDtcbiAgY2hlY2tUcnVzdExldmVsOiAodGFyZ2V0TnB1Yjogc3RyaW5nKSA9PiBQcm9taXNlPFRydXN0TGV2ZWw+O1xuICBwdWJsaXNoRXZlbnQ6IChldmVudDogTm9zdHJFdmVudCkgPT4gUHJvbWlzZTxOREtFdmVudCB8IG51bGw+O1xuICBnZXRXZWJPZlRydXN0OiAoKSA9PiBQcm9taXNlPHtcbiAgICBkaXJlY3RDb25uZWN0aW9uczogc3RyaW5nW107XG4gICAgc2Vjb25kRGVncmVlQ29ubmVjdGlvbnM6IHN0cmluZ1tdO1xuICAgIGNvcmVGb2xsb3dlcnM6IHN0cmluZ1tdO1xuICB9Pjtcbn1cblxuLy8gRGVmaW5lIGNvcmUgTlBVQnMgdG8gY2hlY2sgZm9yIHRydXN0XG5jb25zdCBDT1JFX05QVUJTID0gW1xuICBcIm5wdWIxZXRncWNqOWdjNnlheHR0dXd1OWVxZ3MzeW50MmR6YXVkdnducnNzcm4yemR0MnVzZWFhc2ZqOG42ZVwiLCAvLyBGcmVlIE1hZGVpcmFcbiAgXCJucHViMXMwdmVuZzJndmZ3cjYyYWNyeGhucWV4cTc2c2o2bGRnM2E1dDkzNWp5OGU2dzNzaHI1dnNud3JtcTVcIiwgLy8gQml0Y29pbiBNYWRlaXJhXG4gIFwibnB1YjFkeGQwMmtjamhncGt5cng2MHFua2Q2ajQya21jNzJ1NWx1bTBycDJ1ZDh4NXpmaG5rNHpzY2pqNmhoXCIsIC8vIE1hZHRyaXBzXG4gIFwibnB1YjFmdW5jaGFseDh2NzQ3cnNlZTZhaHN1eXJjZDJzM3JueGx5cnR1bWZleDlsZWNwbWd3YXJzNmhxOGtjXCIsIC8vIEZ1bmNoYWxcbl07XG5cbi8vIERlZmluZSBhIGxpc3Qgb2YgY29tbXVuaXR5IHJlbGF5c1xuY29uc3QgQ09NTVVOSVRZX1JFTEFZUyA9IFtcbiAgXCJ3c3M6Ly9yZWxheS5kYW11cy5pb1wiLFxuICBcIndzczovL3JlbGF5Lm5vc3RyLmJhbmRcIiwgXG4gIFwid3NzOi8vbm9zLmxvbFwiLFxuICBcIndzczovL25vc3RyLm11dGlueXdhbGxldC5jb21cIlxuXTtcblxuLy8gQ3JlYXRlIHRoZSBjb250ZXh0XG5jb25zdCBOb3N0ckF1dGhDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxOb3N0ckF1dGggfCBudWxsPihudWxsKTtcblxuLy8gUHJvdmlkZXIgcHJvcHMgaW50ZXJmYWNlXG5pbnRlcmZhY2UgTm9zdHJBdXRoUHJvdmlkZXJQcm9wcyB7XG4gIGNoaWxkcmVuOiBSZWFjdE5vZGU7XG59XG5cbi8vIEN1c3RvbSBob29rIGZvciBhY2Nlc3NpbmcgdGhlIGNvbnRleHRcbmV4cG9ydCBjb25zdCB1c2VOb3N0ckF1dGggPSAoKSA9PiB7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KE5vc3RyQXV0aENvbnRleHQpO1xuICBpZiAoIWNvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzZU5vc3RyQXV0aCBtdXN0IGJlIHVzZWQgd2l0aGluIGEgTm9zdHJBdXRoUHJvdmlkZXInKTtcbiAgfVxuICByZXR1cm4gY29udGV4dDtcbn07XG5cbi8vIFRoZSBwcm92aWRlciBjb21wb25lbnRcbmV4cG9ydCBjb25zdCBOb3N0ckF1dGhQcm92aWRlcjogUmVhY3QuRkM8Tm9zdHJBdXRoUHJvdmlkZXJQcm9wcz4gPSAoeyBjaGlsZHJlbiB9KSA9PiB7XG4gIC8vIE5ESyBpbnN0YW5jZSBmcm9tIHRoZSBOREsgcHJvdmlkZXJcbiAgY29uc3QgeyBuZGsgfSA9IHVzZU5ESygpO1xuICBcbiAgLy8gU3RhdGUgZm9yIGF1dGhlbnRpY2F0aW9uIHN0YXR1c1xuICBjb25zdCBbdXNlciwgc2V0VXNlcl0gPSB1c2VTdGF0ZTx7IHB1YmtleTogc3RyaW5nOyBucHViOiBzdHJpbmc7IG5hbWU/OiBzdHJpbmc7IHByb2ZpbGVJbWFnZT86IHN0cmluZzsgfSB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbbnB1Yiwgc2V0TnB1Yl0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW3B1YmtleSwgc2V0UHVia2V5XSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbaXNDb25uZWN0ZWQsIHNldElzQ29ubmVjdGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2lzTG9hZGluZywgc2V0SXNMb2FkaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgXG4gIC8vIFJlZmVyZW5jZSB0byB0aGUgY29ubmVjdCBtYW5hZ2VyIC0gd2UnbGwgY3JlYXRlIG91ciBvd24gbWluaW1hbCBpbXBsZW1lbnRhdGlvblxuICBjb25zdCBbY29ubmVjdE1hbmFnZXIsIHNldENvbm5lY3RNYW5hZ2VyXSA9IHVzZVN0YXRlPGFueT4obnVsbCk7XG5cbiAgLy8gSW5pdGlhbGl6ZSBOb3N0ckNvbm5lY3QgLSBzaW1wbGlmaWVkIGZvciB0aGlzIGltcGxlbWVudGF0aW9uXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFuZGspIHJldHVybjtcbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gSW5zdGVhZCBvZiB1c2luZyB0aGUgQ29ubmVjdCBjbGFzcyB3aGljaCBoYXMgY29tcGF0aWJpbGl0eSBpc3N1ZXMsXG4gICAgICAvLyB3ZSdsbCBjcmVhdGUgYSBtaW5pbWFsIG1hbmFnZXIgb2JqZWN0IGZvciB0ZXN0aW5nIHB1cnBvc2VzXG4gICAgICBjb25zdCBtaW5pbWFsTWFuYWdlciA9IHtcbiAgICAgICAgY29ubmVjdDogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIC8vIFNpbXVsYXRlIGNvbm5lY3Rpb24gYnkgcmV0dXJuaW5nIGEgcmFuZG9tIGNvcmUgTlBVQlxuICAgICAgICAgIGNvbnN0IG1vY2tQdWJrZXkgPSBDT1JFX05QVUJTW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIENPUkVfTlBVQlMubGVuZ3RoKV07XG4gICAgICAgICAgY29uc3QgeyBkYXRhOiBoZXhQdWJrZXkgfSA9IG5pcDE5LmRlY29kZShtb2NrUHVia2V5KTtcbiAgICAgICAgICByZXR1cm4geyBwdWJrZXk6IGhleFB1YmtleSwgc2VjcmV0S2V5OiAnbW9ja19zZWNyZXQnIH07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBcbiAgICAgIHNldENvbm5lY3RNYW5hZ2VyKG1pbmltYWxNYW5hZ2VyKTtcbiAgICAgIFxuICAgICAgLy8gVHJ5IHRvIHJlc3RvcmUgc2Vzc2lvblxuICAgICAgY29uc3QgcmVzdG9yZVNlc3Npb24gPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdub3N0clNlc3Npb24nKTtcbiAgICAgICAgICBpZiAoc2Vzc2lvbikge1xuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbkRhdGEgPSBKU09OLnBhcnNlKHNlc3Npb24pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoc2Vzc2lvbkRhdGEgJiYgc2Vzc2lvbkRhdGEucHVia2V5ICYmIHNlc3Npb25EYXRhLm5wdWIpIHtcbiAgICAgICAgICAgICAgc2V0UHVia2V5KHNlc3Npb25EYXRhLnB1YmtleSk7XG4gICAgICAgICAgICAgIHNldE5wdWIoc2Vzc2lvbkRhdGEubnB1Yik7XG4gICAgICAgICAgICAgIHNldElzQ29ubmVjdGVkKHRydWUpO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gQ3JlYXRlIHVzZXIgb2JqZWN0XG4gICAgICAgICAgICAgIGNvbnN0IHVzZXJPYmogPSB7XG4gICAgICAgICAgICAgICAgcHVia2V5OiBzZXNzaW9uRGF0YS5wdWJrZXksXG4gICAgICAgICAgICAgICAgbnB1Yjogc2Vzc2lvbkRhdGEubnB1YixcbiAgICAgICAgICAgICAgICBuYW1lOiBzZXNzaW9uRGF0YS5uYW1lIHx8ICcnLFxuICAgICAgICAgICAgICAgIHByb2ZpbGVJbWFnZTogc2Vzc2lvbkRhdGEucHJvZmlsZUltYWdlIHx8ICcnLFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgc2V0VXNlcih1c2VyT2JqKTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIExvYWQgdGhlIHVzZXIgcHJvZmlsZVxuICAgICAgICAgICAgICBhd2FpdCBsb2FkVXNlclByb2ZpbGUoc2Vzc2lvbkRhdGEubnB1Yik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZXN0b3Jpbmcgc2Vzc2lvbjonLCBlcnIpO1xuICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdub3N0clNlc3Npb24nKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgcmVzdG9yZVNlc3Npb24oKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluaXRpYWxpemluZyBOb3N0cjonLCBlcnIpO1xuICAgICAgc2V0RXJyb3IoJ0ZhaWxlZCB0byBpbml0aWFsaXplIE5vc3RyIGNvbm5lY3Rpb24nKTtcbiAgICB9XG4gIH0sIFtuZGtdKTtcblxuICAvLyBGdW5jdGlvbiB0byBsb2FkIHVzZXIgcHJvZmlsZSBkYXRhXG4gIGNvbnN0IGxvYWRVc2VyUHJvZmlsZSA9IGFzeW5jICh1c2VyTnB1Yjogc3RyaW5nKSA9PiB7XG4gICAgaWYgKCFuZGspIHJldHVybjtcbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gQ3JlYXRlIGFuIE5ESyB1c2VyIGZyb20gdGhlIG5wdWJcbiAgICAgIGNvbnN0IHsgdHlwZSwgZGF0YTogaGV4UHVia2V5IH0gPSBuaXAxOS5kZWNvZGUodXNlck5wdWIpO1xuICAgICAgXG4gICAgICBpZiAodHlwZSAhPT0gJ25wdWInKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBucHViJyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEZldGNoIHVzZXIgcHJvZmlsZVxuICAgICAgY29uc3QgdXNlciA9IG5kay5nZXRVc2VyKHsgcHVia2V5OiBoZXhQdWJrZXkgYXMgc3RyaW5nIH0pO1xuICAgICAgYXdhaXQgdXNlci5mZXRjaFByb2ZpbGUoKTtcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIHVzZXIgZGF0YVxuICAgICAgc2V0VXNlcih7XG4gICAgICAgIHB1YmtleTogaGV4UHVia2V5IGFzIHN0cmluZyxcbiAgICAgICAgbnB1YjogdXNlck5wdWIsXG4gICAgICAgIG5hbWU6IHVzZXIucHJvZmlsZT8ubmFtZSB8fCAnJyxcbiAgICAgICAgcHJvZmlsZUltYWdlOiB1c2VyLnByb2ZpbGU/LmltYWdlIHx8ICcnLFxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIFNhdmUgdG8gbG9jYWwgc3RvcmFnZVxuICAgICAgY29uc3Qgc2Vzc2lvbkRhdGEgPSB7XG4gICAgICAgIHB1YmtleTogaGV4UHVia2V5LFxuICAgICAgICBucHViOiB1c2VyTnB1YixcbiAgICAgICAgbmFtZTogdXNlci5wcm9maWxlPy5uYW1lIHx8ICcnLFxuICAgICAgICBwcm9maWxlSW1hZ2U6IHVzZXIucHJvZmlsZT8uaW1hZ2UgfHwgJycsXG4gICAgICB9O1xuICAgICAgXG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnbm9zdHJTZXNzaW9uJywgSlNPTi5zdHJpbmdpZnkoc2Vzc2lvbkRhdGEpKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgdXNlciBwcm9maWxlOicsIGVycik7XG4gICAgfVxuICB9O1xuXG4gIC8vIExvZ2luIGZ1bmN0aW9uXG4gIGNvbnN0IGxvZ2luID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmICghbmRrIHx8ICFjb25uZWN0TWFuYWdlcikge1xuICAgICAgc2V0RXJyb3IoJ05vc3RyIGNvbm5lY3Rpb24gbm90IGluaXRpYWxpemVkJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIHNldElzTG9hZGluZyh0cnVlKTtcbiAgICBzZXRFcnJvcihudWxsKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gRmlyc3QgdHJ5IE5JUC0wNyBsb2dpbiBpZiBhdmFpbGFibGVcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBicm93c2VyIGhhcyBhIE5JUC0wNyBleHRlbnNpb25cbiAgICAgICAgY29uc3QgaGFzTmlwMDcgPSB3aW5kb3cgJiYgJ25vc3RyJyBpbiB3aW5kb3c7XG4gICAgICAgIFxuICAgICAgICBpZiAoaGFzTmlwMDcpIHtcbiAgICAgICAgICAvLyBVc2UgdGhlIE5JUC0wNyBzaWduZXJcbiAgICAgICAgICBjb25zdCBzaWduZXIgPSBuZXcgTkRLTmlwMDdTaWduZXIoKTtcbiAgICAgICAgICBuZGsuc2lnbmVyID0gc2lnbmVyO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEdldCB0aGUgdXNlcidzIHB1YmxpYyBrZXlcbiAgICAgICAgICBjb25zdCB1c2VyUHVia2V5ID0gYXdhaXQgc2lnbmVyLnVzZXIoKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAodXNlclB1YmtleSkge1xuICAgICAgICAgICAgY29uc3QgdXNlck5wdWIgPSBuaXAxOS5ucHViRW5jb2RlKHVzZXJQdWJrZXkucHVia2V5KTtcbiAgICAgICAgICAgIHNldFB1YmtleSh1c2VyUHVia2V5LnB1YmtleSk7XG4gICAgICAgICAgICBzZXROcHViKHVzZXJOcHViKTtcbiAgICAgICAgICAgIHNldElzQ29ubmVjdGVkKHRydWUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBhd2FpdCBsb2FkVXNlclByb2ZpbGUodXNlck5wdWIpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ05JUC0wNyBsb2dpbiBmYWlsZWQsIGZhbGxpbmcgYmFjayB0byBvdXIgbWluaW1hbCBjb25uZWN0IGltcGxlbWVudGF0aW9uOicsIGVycik7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEZhbGwgYmFjayB0byBvdXIgbWluaW1hbCBjb25uZWN0IGltcGxlbWVudGF0aW9uXG4gICAgICBjb25zdCB7IHB1YmtleTogaGV4UHVia2V5IH0gPSBhd2FpdCBjb25uZWN0TWFuYWdlci5jb25uZWN0KCk7XG4gICAgICBcbiAgICAgIC8vIENvbnZlcnQgdG8gbnB1YlxuICAgICAgY29uc3QgbW9ja1B1YmtleSA9IG5pcDE5Lm5wdWJFbmNvZGUoaGV4UHVia2V5IGFzIHN0cmluZyk7XG4gICAgICBcbiAgICAgIHNldFB1YmtleShoZXhQdWJrZXkgYXMgc3RyaW5nKTtcbiAgICAgIHNldE5wdWIobW9ja1B1YmtleSk7XG4gICAgICBzZXRJc0Nvbm5lY3RlZCh0cnVlKTtcbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIGEgYmFzaWMgdXNlciBvYmplY3RcbiAgICAgIGNvbnN0IHVzZXJPYmogPSB7XG4gICAgICAgIHB1YmtleTogaGV4UHVia2V5IGFzIHN0cmluZyxcbiAgICAgICAgbnB1YjogbW9ja1B1YmtleSxcbiAgICAgICAgbmFtZTogJ1Rlc3QgVXNlcicsXG4gICAgICAgIHByb2ZpbGVJbWFnZTogJycsXG4gICAgICB9O1xuICAgICAgXG4gICAgICBzZXRVc2VyKHVzZXJPYmopO1xuICAgICAgXG4gICAgICAvLyBTYXZlIHRvIGxvY2FsIHN0b3JhZ2VcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdub3N0clNlc3Npb24nLCBKU09OLnN0cmluZ2lmeSh1c2VyT2JqKSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdMb2dpbiBlcnJvcjonLCBlcnIpO1xuICAgICAgc2V0RXJyb3IoJ0ZhaWxlZCB0byBsb2dpbiB3aXRoIE5vc3RyJyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIExvZ291dCBmdW5jdGlvblxuICBjb25zdCBsb2dvdXQgPSAoKSA9PiB7XG4gICAgc2V0VXNlcihudWxsKTtcbiAgICBzZXROcHViKG51bGwpO1xuICAgIHNldFB1YmtleShudWxsKTtcbiAgICBzZXRJc0Nvbm5lY3RlZChmYWxzZSk7XG4gICAgXG4gICAgLy8gQ2xlYXIgbG9jYWwgc3RvcmFnZVxuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdub3N0clNlc3Npb24nKTtcbiAgfTtcblxuICAvLyBDaGVjayB0cnVzdCBsZXZlbCBvZiBhIG5wdWJcbiAgY29uc3QgY2hlY2tUcnVzdExldmVsID0gYXN5bmMgKHRhcmdldE5wdWI6IHN0cmluZyk6IFByb21pc2U8VHJ1c3RMZXZlbD4gPT4ge1xuICAgIGlmICghbmRrIHx8ICFpc0Nvbm5lY3RlZCkgcmV0dXJuIFRydXN0TGV2ZWwuVU5LTk9XTjtcbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gQ2hlY2sgaWYgaXQncyBhIGNvcmUgbnB1YlxuICAgICAgaWYgKENPUkVfTlBVQlMuaW5jbHVkZXModGFyZ2V0TnB1YikpIHtcbiAgICAgICAgcmV0dXJuIFRydXN0TGV2ZWwuVkVSSUZJRUQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIGl0J3MgZGlyZWN0bHkgY29ubmVjdGVkIHRvIHVzXG4gICAgICBjb25zdCB7IGRpcmVjdENvbm5lY3Rpb25zIH0gPSBhd2FpdCBnZXRXZWJPZlRydXN0KCk7XG4gICAgICBpZiAoZGlyZWN0Q29ubmVjdGlvbnMuaW5jbHVkZXModGFyZ2V0TnB1YikpIHtcbiAgICAgICAgcmV0dXJuIFRydXN0TGV2ZWwuSElHSDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgaXQncyBpbmRpcmVjdGx5IGNvbm5lY3RlZFxuICAgICAgY29uc3QgeyBzZWNvbmREZWdyZWVDb25uZWN0aW9ucyB9ID0gYXdhaXQgZ2V0V2ViT2ZUcnVzdCgpO1xuICAgICAgaWYgKHNlY29uZERlZ3JlZUNvbm5lY3Rpb25zLmluY2x1ZGVzKHRhcmdldE5wdWIpKSB7XG4gICAgICAgIHJldHVybiBUcnVzdExldmVsLk1FRElVTTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gT3RoZXJ3aXNlLCBpdCdzIGEgbG93IHRydXN0IGNvbm5lY3Rpb25cbiAgICAgIHJldHVybiBUcnVzdExldmVsLkxPVztcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNoZWNraW5nIHRydXN0IGxldmVsOicsIGVycik7XG4gICAgICByZXR1cm4gVHJ1c3RMZXZlbC5VTktOT1dOO1xuICAgIH1cbiAgfTtcblxuICAvLyBQdWJsaXNoIGFuIGV2ZW50XG4gIGNvbnN0IHB1Ymxpc2hFdmVudCA9IGFzeW5jIChldmVudDogTm9zdHJFdmVudCk6IFByb21pc2U8TkRLRXZlbnQgfCBudWxsPiA9PiB7XG4gICAgaWYgKCFuZGsgfHwgIWlzQ29ubmVjdGVkKSByZXR1cm4gbnVsbDtcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgbmRrRXZlbnQgPSBuZXcgTkRLRXZlbnQobmRrKTtcbiAgICAgIG5ka0V2ZW50LmtpbmQgPSBldmVudC5raW5kO1xuICAgICAgbmRrRXZlbnQuY29udGVudCA9IGV2ZW50LmNvbnRlbnQ7XG4gICAgICBuZGtFdmVudC50YWdzID0gZXZlbnQudGFncyB8fCBbXTtcbiAgICAgIFxuICAgICAgLy8gUHVibGlzaCB0aGUgZXZlbnRcbiAgICAgIGF3YWl0IG5ka0V2ZW50LnB1Ymxpc2goKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIG5ka0V2ZW50O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcHVibGlzaGluZyBldmVudDonLCBlcnIpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9O1xuXG4gIC8vIEdldCB3ZWIgb2YgdHJ1c3RcbiAgY29uc3QgZ2V0V2ViT2ZUcnVzdCA9IGFzeW5jICgpOiBQcm9taXNlPHtcbiAgICBkaXJlY3RDb25uZWN0aW9uczogc3RyaW5nW107XG4gICAgc2Vjb25kRGVncmVlQ29ubmVjdGlvbnM6IHN0cmluZ1tdO1xuICAgIGNvcmVGb2xsb3dlcnM6IHN0cmluZ1tdO1xuICB9PiA9PiB7XG4gICAgaWYgKCFuZGsgfHwgIWlzQ29ubmVjdGVkIHx8ICFwdWJrZXkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpcmVjdENvbm5lY3Rpb25zOiBbXSxcbiAgICAgICAgc2Vjb25kRGVncmVlQ29ubmVjdGlvbnM6IFtdLFxuICAgICAgICBjb3JlRm9sbG93ZXJzOiBbXSxcbiAgICAgIH07XG4gICAgfVxuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBGb3Igc2ltcGxpY2l0eSwgd2UnbGwgdXNlIGEgbW9jayBpbXBsZW1lbnRhdGlvblxuICAgICAgLy8gSW4gYSByZWFsIGltcGxlbWVudGF0aW9uLCB0aGlzIHdvdWxkIHF1ZXJ5IHRoZSByZWxheXMgZm9yIGZvbGxvd3NcbiAgICAgIFxuICAgICAgLy8gTW9jayBkaXJlY3QgY29ubmVjdGlvbnNcbiAgICAgIGNvbnN0IGRpcmVjdENvbm5lY3Rpb25zID0gQ09SRV9OUFVCUy5maWx0ZXIoKCkgPT4gTWF0aC5yYW5kb20oKSA+IDAuNSk7XG4gICAgICBcbiAgICAgIC8vIE1vY2sgc2Vjb25kLWRlZ3JlZSBjb25uZWN0aW9uc1xuICAgICAgY29uc3Qgc2Vjb25kRGVncmVlQ29ubmVjdGlvbnMgPSBDT1JFX05QVUJTLmZpbHRlcigoKSA9PiBNYXRoLnJhbmRvbSgpID4gMC43KTtcbiAgICAgIFxuICAgICAgLy8gTW9jayBjb3JlIGZvbGxvd2Vyc1xuICAgICAgY29uc3QgY29yZUZvbGxvd2VycyA9IENPUkVfTlBVQlMuZmlsdGVyKCgpID0+IE1hdGgucmFuZG9tKCkgPiAwLjgpO1xuICAgICAgXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXJlY3RDb25uZWN0aW9ucyxcbiAgICAgICAgc2Vjb25kRGVncmVlQ29ubmVjdGlvbnMsXG4gICAgICAgIGNvcmVGb2xsb3dlcnMsXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyB3ZWIgb2YgdHJ1c3Q6JywgZXJyKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpcmVjdENvbm5lY3Rpb25zOiBbXSxcbiAgICAgICAgc2Vjb25kRGVncmVlQ29ubmVjdGlvbnM6IFtdLFxuICAgICAgICBjb3JlRm9sbG93ZXJzOiBbXSxcbiAgICAgIH07XG4gICAgfVxuICB9O1xuXG4gIC8vIENvbnRleHQgdmFsdWVcbiAgY29uc3QgdmFsdWU6IE5vc3RyQXV0aCA9IHtcbiAgICB1c2VyLFxuICAgIG5wdWIsXG4gICAgcHVia2V5LFxuICAgIGlzQ29ubmVjdGVkLFxuICAgIGlzTG9hZGluZyxcbiAgICBlcnJvcixcbiAgICBsb2dpbixcbiAgICBsb2dvdXQsXG4gICAgY2hlY2tUcnVzdExldmVsLFxuICAgIHB1Ymxpc2hFdmVudCxcbiAgICBnZXRXZWJPZlRydXN0LFxuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPE5vc3RyQXV0aENvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3ZhbHVlfT5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L05vc3RyQXV0aENvbnRleHQuUHJvdmlkZXI+XG4gICk7XG59OyAiXSwibmFtZXMiOlsiUmVhY3QiLCJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwiTkRLTmlwMDdTaWduZXIiLCJOREtFdmVudCIsInVzZU5ESyIsIm5pcDE5IiwiVHJ1c3RMZXZlbCIsIkNPUkVfTlBVQlMiLCJDT01NVU5JVFlfUkVMQVlTIiwiTm9zdHJBdXRoQ29udGV4dCIsInVzZU5vc3RyQXV0aCIsImNvbnRleHQiLCJFcnJvciIsIk5vc3RyQXV0aFByb3ZpZGVyIiwiY2hpbGRyZW4iLCJuZGsiLCJ1c2VyIiwic2V0VXNlciIsIm5wdWIiLCJzZXROcHViIiwicHVia2V5Iiwic2V0UHVia2V5IiwiaXNDb25uZWN0ZWQiLCJzZXRJc0Nvbm5lY3RlZCIsImlzTG9hZGluZyIsInNldElzTG9hZGluZyIsImVycm9yIiwic2V0RXJyb3IiLCJjb25uZWN0TWFuYWdlciIsInNldENvbm5lY3RNYW5hZ2VyIiwibWluaW1hbE1hbmFnZXIiLCJjb25uZWN0IiwibW9ja1B1YmtleSIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsImxlbmd0aCIsImRhdGEiLCJoZXhQdWJrZXkiLCJkZWNvZGUiLCJzZWNyZXRLZXkiLCJyZXN0b3JlU2Vzc2lvbiIsInNlc3Npb24iLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwic2Vzc2lvbkRhdGEiLCJKU09OIiwicGFyc2UiLCJ1c2VyT2JqIiwibmFtZSIsInByb2ZpbGVJbWFnZSIsImxvYWRVc2VyUHJvZmlsZSIsImVyciIsImNvbnNvbGUiLCJyZW1vdmVJdGVtIiwidXNlck5wdWIiLCJ0eXBlIiwiZ2V0VXNlciIsImZldGNoUHJvZmlsZSIsInByb2ZpbGUiLCJpbWFnZSIsInNldEl0ZW0iLCJzdHJpbmdpZnkiLCJsb2dpbiIsImhhc05pcDA3Iiwid2luZG93Iiwic2lnbmVyIiwidXNlclB1YmtleSIsIm5wdWJFbmNvZGUiLCJsb2ciLCJsb2dvdXQiLCJjaGVja1RydXN0TGV2ZWwiLCJ0YXJnZXROcHViIiwiaW5jbHVkZXMiLCJkaXJlY3RDb25uZWN0aW9ucyIsImdldFdlYk9mVHJ1c3QiLCJzZWNvbmREZWdyZWVDb25uZWN0aW9ucyIsInB1Ymxpc2hFdmVudCIsImV2ZW50IiwibmRrRXZlbnQiLCJraW5kIiwiY29udGVudCIsInRhZ3MiLCJwdWJsaXNoIiwiY29yZUZvbGxvd2VycyIsImZpbHRlciIsInZhbHVlIiwiUHJvdmlkZXIiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/nostr/NostrAuthProvider.tsx\n"));

/***/ })

});