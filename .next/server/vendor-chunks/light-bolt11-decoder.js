/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/light-bolt11-decoder";
exports.ids = ["vendor-chunks/light-bolt11-decoder"];
exports.modules = {

/***/ "(ssr)/./node_modules/light-bolt11-decoder/bolt11.js":
/*!*****************************************************!*\
  !*** ./node_modules/light-bolt11-decoder/bolt11.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const {bech32, hex, utf8} = __webpack_require__(/*! @scure/base */ \"(ssr)/./node_modules/light-bolt11-decoder/node_modules/@scure/base/lib/index.js\")\n\n// defaults for encode; default timestamp is current time at call\nconst DEFAULTNETWORK = {\n  // default network is bitcoin\n  bech32: 'bc',\n  pubKeyHash: 0x00,\n  scriptHash: 0x05,\n  validWitnessVersions: [0]\n}\nconst TESTNETWORK = {\n  bech32: 'tb',\n  pubKeyHash: 0x6f,\n  scriptHash: 0xc4,\n  validWitnessVersions: [0]\n}\nconst SIGNETNETWORK = {\n  bech32: 'tbs',\n  pubKeyHash: 0x6f,\n  scriptHash: 0xc4,\n  validWitnessVersions: [0]\n}\nconst REGTESTNETWORK = {\n  bech32: 'bcrt',\n  pubKeyHash: 0x6f,\n  scriptHash: 0xc4,\n  validWitnessVersions: [0]\n}\nconst SIMNETWORK = {\n  bech32: 'sb',\n  pubKeyHash: 0x3f,\n  scriptHash: 0x7b,\n  validWitnessVersions: [0]\n}\n\nconst FEATUREBIT_ORDER = [\n  'option_data_loss_protect',\n  'initial_routing_sync',\n  'option_upfront_shutdown_script',\n  'gossip_queries',\n  'var_onion_optin',\n  'gossip_queries_ex',\n  'option_static_remotekey',\n  'payment_secret',\n  'basic_mpp',\n  'option_support_large_channel'\n]\n\nconst DIVISORS = {\n  m: BigInt(1e3),\n  u: BigInt(1e6),\n  n: BigInt(1e9),\n  p: BigInt(1e12)\n}\n\nconst MAX_MILLISATS = BigInt('2100000000000000000')\n\nconst MILLISATS_PER_BTC = BigInt(1e11)\n\nconst TAGCODES = {\n  payment_hash: 1,\n  payment_secret: 16,\n  description: 13,\n  payee: 19,\n  description_hash: 23, // commit to longer descriptions (used by lnurl-pay)\n  expiry: 6, // default: 3600 (1 hour)\n  min_final_cltv_expiry: 24, // default: 9\n  fallback_address: 9,\n  route_hint: 3, // for extra routing info (private etc.)\n  feature_bits: 5,\n  metadata: 27\n}\n\n// reverse the keys and values of TAGCODES and insert into TAGNAMES\nconst TAGNAMES = {}\nfor (let i = 0, keys = Object.keys(TAGCODES); i < keys.length; i++) {\n  const currentName = keys[i]\n  const currentCode = TAGCODES[keys[i]].toString()\n  TAGNAMES[currentCode] = currentName\n}\n\nconst TAGPARSERS = {\n  1: words => hex.encode(bech32.fromWordsUnsafe(words)), // 256 bits\n  16: words => hex.encode(bech32.fromWordsUnsafe(words)), // 256 bits\n  13: words => utf8.encode(bech32.fromWordsUnsafe(words)), // string variable length\n  19: words => hex.encode(bech32.fromWordsUnsafe(words)), // 264 bits\n  23: words => hex.encode(bech32.fromWordsUnsafe(words)), // 256 bits\n  27: words => hex.encode(bech32.fromWordsUnsafe(words)), // variable\n  6: wordsToIntBE, // default: 3600 (1 hour)\n  24: wordsToIntBE, // default: 9\n  3: routingInfoParser, // for extra routing info (private etc.)\n  5: featureBitsParser // keep feature bits as array of 5 bit words\n}\n\nfunction getUnknownParser(tagCode) {\n  return words => ({\n    tagCode: parseInt(tagCode),\n    words: bech32.encode('unknown', words, Number.MAX_SAFE_INTEGER)\n  })\n}\n\nfunction wordsToIntBE(words) {\n  return words.reverse().reduce((total, item, index) => {\n    return total + item * Math.pow(32, index)\n  }, 0)\n}\n\n// first convert from words to buffer, trimming padding where necessary\n// parse in 51 byte chunks. See encoder for details.\nfunction routingInfoParser(words) {\n  const routes = []\n  let pubkey,\n    shortChannelId,\n    feeBaseMSats,\n    feeProportionalMillionths,\n    cltvExpiryDelta\n  let routesBuffer = bech32.fromWordsUnsafe(words)\n  while (routesBuffer.length > 0) {\n    pubkey = hex.encode(routesBuffer.slice(0, 33)) // 33 bytes\n    shortChannelId = hex.encode(routesBuffer.slice(33, 41)) // 8 bytes\n    feeBaseMSats = parseInt(hex.encode(routesBuffer.slice(41, 45)), 16) // 4 bytes\n    feeProportionalMillionths = parseInt(\n      hex.encode(routesBuffer.slice(45, 49)),\n      16\n    ) // 4 bytes\n    cltvExpiryDelta = parseInt(hex.encode(routesBuffer.slice(49, 51)), 16) // 2 bytes\n\n    routesBuffer = routesBuffer.slice(51)\n\n    routes.push({\n      pubkey,\n      short_channel_id: shortChannelId,\n      fee_base_msat: feeBaseMSats,\n      fee_proportional_millionths: feeProportionalMillionths,\n      cltv_expiry_delta: cltvExpiryDelta\n    })\n  }\n  return routes\n}\n\nfunction featureBitsParser(words) {\n  const bools = words\n    .slice()\n    .reverse()\n    .map(word => [\n      !!(word & 0b1),\n      !!(word & 0b10),\n      !!(word & 0b100),\n      !!(word & 0b1000),\n      !!(word & 0b10000)\n    ])\n    .reduce((finalArr, itemArr) => finalArr.concat(itemArr), [])\n  while (bools.length < FEATUREBIT_ORDER.length * 2) {\n    bools.push(false)\n  }\n\n  const featureBits = {}\n\n  FEATUREBIT_ORDER.forEach((featureName, index) => {\n    let status\n    if (bools[index * 2]) {\n      status = 'required'\n    } else if (bools[index * 2 + 1]) {\n      status = 'supported'\n    } else {\n      status = 'unsupported'\n    }\n    featureBits[featureName] = status\n  })\n\n  const extraBits = bools.slice(FEATUREBIT_ORDER.length * 2)\n  featureBits.extra_bits = {\n    start_bit: FEATUREBIT_ORDER.length * 2,\n    bits: extraBits,\n    has_required: extraBits.reduce(\n      (result, bit, index) =>\n        index % 2 !== 0 ? result || false : result || bit,\n      false\n    )\n  }\n\n  return featureBits\n}\n\nfunction hrpToMillisat(hrpString, outputString) {\n  let divisor, value\n  if (hrpString.slice(-1).match(/^[munp]$/)) {\n    divisor = hrpString.slice(-1)\n    value = hrpString.slice(0, -1)\n  } else if (hrpString.slice(-1).match(/^[^munp0-9]$/)) {\n    throw new Error('Not a valid multiplier for the amount')\n  } else {\n    value = hrpString\n  }\n\n  if (!value.match(/^\\d+$/))\n    throw new Error('Not a valid human readable amount')\n\n  const valueBN = BigInt(value)\n\n  const millisatoshisBN = divisor\n    ? (valueBN * MILLISATS_PER_BTC) / DIVISORS[divisor]\n    : valueBN * MILLISATS_PER_BTC\n\n  if (\n    (divisor === 'p' && !(valueBN % BigInt(10) === BigInt(0))) ||\n    millisatoshisBN > MAX_MILLISATS\n  ) {\n    throw new Error('Amount is outside of valid range')\n  }\n\n  return outputString ? millisatoshisBN.toString() : millisatoshisBN\n}\n\n// decode will only have extra comments that aren't covered in encode comments.\n// also if anything is hard to read I'll comment.\nfunction decode(paymentRequest, network) {\n  if (typeof paymentRequest !== 'string')\n    throw new Error('Lightning Payment Request must be string')\n  if (paymentRequest.slice(0, 2).toLowerCase() !== 'ln')\n    throw new Error('Not a proper lightning payment request')\n\n  const sections = []\n  const decoded = bech32.decode(paymentRequest, Number.MAX_SAFE_INTEGER)\n  paymentRequest = paymentRequest.toLowerCase()\n  const prefix = decoded.prefix\n  let words = decoded.words\n  let letters = paymentRequest.slice(prefix.length + 1)\n  let sigWords = words.slice(-104)\n  words = words.slice(0, -104)\n\n  // Without reverse lookups, can't say that the multipier at the end must\n  // have a number before it, so instead we parse, and if the second group\n  // doesn't have anything, there's a good chance the last letter of the\n  // coin type got captured by the third group, so just re-regex without\n  // the number.\n  let prefixMatches = prefix.match(/^ln(\\S+?)(\\d*)([a-zA-Z]?)$/)\n  if (prefixMatches && !prefixMatches[2])\n    prefixMatches = prefix.match(/^ln(\\S+)$/)\n  if (!prefixMatches) {\n    throw new Error('Not a proper lightning payment request')\n  }\n\n  // \"ln\" section\n  sections.push({\n    name: 'lightning_network',\n    letters: 'ln'\n  })\n\n  // \"bc\" section\n  const bech32Prefix = prefixMatches[1]\n  let coinNetwork\n  if (!network) {\n    switch (bech32Prefix) {\n      case DEFAULTNETWORK.bech32:\n        coinNetwork = DEFAULTNETWORK\n        break\n      case TESTNETWORK.bech32:\n        coinNetwork = TESTNETWORK\n        break\n      case SIGNETNETWORK.bech32:\n        coinNetwork = SIGNETNETWORK\n        break\n      case REGTESTNETWORK.bech32:\n        coinNetwork = REGTESTNETWORK\n        break\n      case SIMNETWORK.bech32:\n        coinNetwork = SIMNETWORK\n        break\n    }\n  } else {\n    if (\n      network.bech32 === undefined ||\n      network.pubKeyHash === undefined ||\n      network.scriptHash === undefined ||\n      !Array.isArray(network.validWitnessVersions)\n    )\n      throw new Error('Invalid network')\n    coinNetwork = network\n  }\n  if (!coinNetwork || coinNetwork.bech32 !== bech32Prefix) {\n    throw new Error('Unknown coin bech32 prefix')\n  }\n  sections.push({\n    name: 'coin_network',\n    letters: bech32Prefix,\n    value: coinNetwork\n  })\n\n  // amount section\n  const value = prefixMatches[2]\n  let millisatoshis\n  if (value) {\n    const divisor = prefixMatches[3]\n    millisatoshis = hrpToMillisat(value + divisor, true)\n    sections.push({\n      name: 'amount',\n      letters: prefixMatches[2] + prefixMatches[3],\n      value: millisatoshis\n    })\n  } else {\n    millisatoshis = null\n  }\n\n  // \"1\" separator\n  sections.push({\n    name: 'separator',\n    letters: '1'\n  })\n\n  // timestamp\n  const timestamp = wordsToIntBE(words.slice(0, 7))\n  words = words.slice(7) // trim off the left 7 words\n  sections.push({\n    name: 'timestamp',\n    letters: letters.slice(0, 7),\n    value: timestamp\n  })\n  letters = letters.slice(7)\n\n  let tagName, parser, tagLength, tagWords\n  // we have no tag count to go on, so just keep hacking off words\n  // until we have none.\n  while (words.length > 0) {\n    const tagCode = words[0].toString()\n    tagName = TAGNAMES[tagCode] || 'unknown_tag'\n    parser = TAGPARSERS[tagCode] || getUnknownParser(tagCode)\n    words = words.slice(1)\n\n    tagLength = wordsToIntBE(words.slice(0, 2))\n    words = words.slice(2)\n\n    tagWords = words.slice(0, tagLength)\n    words = words.slice(tagLength)\n\n    sections.push({\n      name: tagName,\n      tag: letters[0],\n      letters: letters.slice(0, 1 + 2 + tagLength),\n      value: parser(tagWords) // see: parsers for more comments\n    })\n    letters = letters.slice(1 + 2 + tagLength)\n  }\n\n  // signature\n  sections.push({\n    name: 'signature',\n    letters: letters.slice(0, 104),\n    value: hex.encode(bech32.fromWordsUnsafe(sigWords))\n  })\n  letters = letters.slice(104)\n\n  // checksum\n  sections.push({\n    name: 'checksum',\n    letters: letters\n  })\n\n  let result = {\n    paymentRequest,\n    sections,\n\n    get expiry() {\n      let exp = sections.find(s => s.name === 'expiry')\n      if (exp) return getValue('timestamp') + exp.value\n    },\n\n    get route_hints() {\n      return sections.filter(s => s.name === 'route_hint').map(s => s.value)\n    }\n  }\n\n  for (let name in TAGCODES) {\n    if (name === 'route_hint') {\n      // route hints can be multiple, so this won't work for them\n      continue\n    }\n\n    Object.defineProperty(result, name, {\n      get() {\n        return getValue(name)\n      }\n    })\n  }\n\n  return result\n\n  function getValue(name) {\n    let section = sections.find(s => s.name === name)\n    return section ? section.value : undefined\n  }\n}\n\nmodule.exports = {\n  decode,\n  hrpToMillisat\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGlnaHQtYm9sdDExLWRlY29kZXIvYm9sdDExLmpzIiwibWFwcGluZ3MiOiJBQUFBLE9BQU8sbUJBQW1CLEVBQUUsbUJBQU8sQ0FBQyxvR0FBYTs7QUFFakQsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhDQUE4QyxpQkFBaUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbGZnL0dpdC9NYWR0cmlwcy9ub2RlX21vZHVsZXMvbGlnaHQtYm9sdDExLWRlY29kZXIvYm9sdDExLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHtiZWNoMzIsIGhleCwgdXRmOH0gPSByZXF1aXJlKCdAc2N1cmUvYmFzZScpXG5cbi8vIGRlZmF1bHRzIGZvciBlbmNvZGU7IGRlZmF1bHQgdGltZXN0YW1wIGlzIGN1cnJlbnQgdGltZSBhdCBjYWxsXG5jb25zdCBERUZBVUxUTkVUV09SSyA9IHtcbiAgLy8gZGVmYXVsdCBuZXR3b3JrIGlzIGJpdGNvaW5cbiAgYmVjaDMyOiAnYmMnLFxuICBwdWJLZXlIYXNoOiAweDAwLFxuICBzY3JpcHRIYXNoOiAweDA1LFxuICB2YWxpZFdpdG5lc3NWZXJzaW9uczogWzBdXG59XG5jb25zdCBURVNUTkVUV09SSyA9IHtcbiAgYmVjaDMyOiAndGInLFxuICBwdWJLZXlIYXNoOiAweDZmLFxuICBzY3JpcHRIYXNoOiAweGM0LFxuICB2YWxpZFdpdG5lc3NWZXJzaW9uczogWzBdXG59XG5jb25zdCBTSUdORVRORVRXT1JLID0ge1xuICBiZWNoMzI6ICd0YnMnLFxuICBwdWJLZXlIYXNoOiAweDZmLFxuICBzY3JpcHRIYXNoOiAweGM0LFxuICB2YWxpZFdpdG5lc3NWZXJzaW9uczogWzBdXG59XG5jb25zdCBSRUdURVNUTkVUV09SSyA9IHtcbiAgYmVjaDMyOiAnYmNydCcsXG4gIHB1YktleUhhc2g6IDB4NmYsXG4gIHNjcmlwdEhhc2g6IDB4YzQsXG4gIHZhbGlkV2l0bmVzc1ZlcnNpb25zOiBbMF1cbn1cbmNvbnN0IFNJTU5FVFdPUksgPSB7XG4gIGJlY2gzMjogJ3NiJyxcbiAgcHViS2V5SGFzaDogMHgzZixcbiAgc2NyaXB0SGFzaDogMHg3YixcbiAgdmFsaWRXaXRuZXNzVmVyc2lvbnM6IFswXVxufVxuXG5jb25zdCBGRUFUVVJFQklUX09SREVSID0gW1xuICAnb3B0aW9uX2RhdGFfbG9zc19wcm90ZWN0JyxcbiAgJ2luaXRpYWxfcm91dGluZ19zeW5jJyxcbiAgJ29wdGlvbl91cGZyb250X3NodXRkb3duX3NjcmlwdCcsXG4gICdnb3NzaXBfcXVlcmllcycsXG4gICd2YXJfb25pb25fb3B0aW4nLFxuICAnZ29zc2lwX3F1ZXJpZXNfZXgnLFxuICAnb3B0aW9uX3N0YXRpY19yZW1vdGVrZXknLFxuICAncGF5bWVudF9zZWNyZXQnLFxuICAnYmFzaWNfbXBwJyxcbiAgJ29wdGlvbl9zdXBwb3J0X2xhcmdlX2NoYW5uZWwnXG5dXG5cbmNvbnN0IERJVklTT1JTID0ge1xuICBtOiBCaWdJbnQoMWUzKSxcbiAgdTogQmlnSW50KDFlNiksXG4gIG46IEJpZ0ludCgxZTkpLFxuICBwOiBCaWdJbnQoMWUxMilcbn1cblxuY29uc3QgTUFYX01JTExJU0FUUyA9IEJpZ0ludCgnMjEwMDAwMDAwMDAwMDAwMDAwMCcpXG5cbmNvbnN0IE1JTExJU0FUU19QRVJfQlRDID0gQmlnSW50KDFlMTEpXG5cbmNvbnN0IFRBR0NPREVTID0ge1xuICBwYXltZW50X2hhc2g6IDEsXG4gIHBheW1lbnRfc2VjcmV0OiAxNixcbiAgZGVzY3JpcHRpb246IDEzLFxuICBwYXllZTogMTksXG4gIGRlc2NyaXB0aW9uX2hhc2g6IDIzLCAvLyBjb21taXQgdG8gbG9uZ2VyIGRlc2NyaXB0aW9ucyAodXNlZCBieSBsbnVybC1wYXkpXG4gIGV4cGlyeTogNiwgLy8gZGVmYXVsdDogMzYwMCAoMSBob3VyKVxuICBtaW5fZmluYWxfY2x0dl9leHBpcnk6IDI0LCAvLyBkZWZhdWx0OiA5XG4gIGZhbGxiYWNrX2FkZHJlc3M6IDksXG4gIHJvdXRlX2hpbnQ6IDMsIC8vIGZvciBleHRyYSByb3V0aW5nIGluZm8gKHByaXZhdGUgZXRjLilcbiAgZmVhdHVyZV9iaXRzOiA1LFxuICBtZXRhZGF0YTogMjdcbn1cblxuLy8gcmV2ZXJzZSB0aGUga2V5cyBhbmQgdmFsdWVzIG9mIFRBR0NPREVTIGFuZCBpbnNlcnQgaW50byBUQUdOQU1FU1xuY29uc3QgVEFHTkFNRVMgPSB7fVxuZm9yIChsZXQgaSA9IDAsIGtleXMgPSBPYmplY3Qua2V5cyhUQUdDT0RFUyk7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gIGNvbnN0IGN1cnJlbnROYW1lID0ga2V5c1tpXVxuICBjb25zdCBjdXJyZW50Q29kZSA9IFRBR0NPREVTW2tleXNbaV1dLnRvU3RyaW5nKClcbiAgVEFHTkFNRVNbY3VycmVudENvZGVdID0gY3VycmVudE5hbWVcbn1cblxuY29uc3QgVEFHUEFSU0VSUyA9IHtcbiAgMTogd29yZHMgPT4gaGV4LmVuY29kZShiZWNoMzIuZnJvbVdvcmRzVW5zYWZlKHdvcmRzKSksIC8vIDI1NiBiaXRzXG4gIDE2OiB3b3JkcyA9PiBoZXguZW5jb2RlKGJlY2gzMi5mcm9tV29yZHNVbnNhZmUod29yZHMpKSwgLy8gMjU2IGJpdHNcbiAgMTM6IHdvcmRzID0+IHV0ZjguZW5jb2RlKGJlY2gzMi5mcm9tV29yZHNVbnNhZmUod29yZHMpKSwgLy8gc3RyaW5nIHZhcmlhYmxlIGxlbmd0aFxuICAxOTogd29yZHMgPT4gaGV4LmVuY29kZShiZWNoMzIuZnJvbVdvcmRzVW5zYWZlKHdvcmRzKSksIC8vIDI2NCBiaXRzXG4gIDIzOiB3b3JkcyA9PiBoZXguZW5jb2RlKGJlY2gzMi5mcm9tV29yZHNVbnNhZmUod29yZHMpKSwgLy8gMjU2IGJpdHNcbiAgMjc6IHdvcmRzID0+IGhleC5lbmNvZGUoYmVjaDMyLmZyb21Xb3Jkc1Vuc2FmZSh3b3JkcykpLCAvLyB2YXJpYWJsZVxuICA2OiB3b3Jkc1RvSW50QkUsIC8vIGRlZmF1bHQ6IDM2MDAgKDEgaG91cilcbiAgMjQ6IHdvcmRzVG9JbnRCRSwgLy8gZGVmYXVsdDogOVxuICAzOiByb3V0aW5nSW5mb1BhcnNlciwgLy8gZm9yIGV4dHJhIHJvdXRpbmcgaW5mbyAocHJpdmF0ZSBldGMuKVxuICA1OiBmZWF0dXJlQml0c1BhcnNlciAvLyBrZWVwIGZlYXR1cmUgYml0cyBhcyBhcnJheSBvZiA1IGJpdCB3b3Jkc1xufVxuXG5mdW5jdGlvbiBnZXRVbmtub3duUGFyc2VyKHRhZ0NvZGUpIHtcbiAgcmV0dXJuIHdvcmRzID0+ICh7XG4gICAgdGFnQ29kZTogcGFyc2VJbnQodGFnQ29kZSksXG4gICAgd29yZHM6IGJlY2gzMi5lbmNvZGUoJ3Vua25vd24nLCB3b3JkcywgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIHdvcmRzVG9JbnRCRSh3b3Jkcykge1xuICByZXR1cm4gd29yZHMucmV2ZXJzZSgpLnJlZHVjZSgodG90YWwsIGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgcmV0dXJuIHRvdGFsICsgaXRlbSAqIE1hdGgucG93KDMyLCBpbmRleClcbiAgfSwgMClcbn1cblxuLy8gZmlyc3QgY29udmVydCBmcm9tIHdvcmRzIHRvIGJ1ZmZlciwgdHJpbW1pbmcgcGFkZGluZyB3aGVyZSBuZWNlc3Nhcnlcbi8vIHBhcnNlIGluIDUxIGJ5dGUgY2h1bmtzLiBTZWUgZW5jb2RlciBmb3IgZGV0YWlscy5cbmZ1bmN0aW9uIHJvdXRpbmdJbmZvUGFyc2VyKHdvcmRzKSB7XG4gIGNvbnN0IHJvdXRlcyA9IFtdXG4gIGxldCBwdWJrZXksXG4gICAgc2hvcnRDaGFubmVsSWQsXG4gICAgZmVlQmFzZU1TYXRzLFxuICAgIGZlZVByb3BvcnRpb25hbE1pbGxpb250aHMsXG4gICAgY2x0dkV4cGlyeURlbHRhXG4gIGxldCByb3V0ZXNCdWZmZXIgPSBiZWNoMzIuZnJvbVdvcmRzVW5zYWZlKHdvcmRzKVxuICB3aGlsZSAocm91dGVzQnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICBwdWJrZXkgPSBoZXguZW5jb2RlKHJvdXRlc0J1ZmZlci5zbGljZSgwLCAzMykpIC8vIDMzIGJ5dGVzXG4gICAgc2hvcnRDaGFubmVsSWQgPSBoZXguZW5jb2RlKHJvdXRlc0J1ZmZlci5zbGljZSgzMywgNDEpKSAvLyA4IGJ5dGVzXG4gICAgZmVlQmFzZU1TYXRzID0gcGFyc2VJbnQoaGV4LmVuY29kZShyb3V0ZXNCdWZmZXIuc2xpY2UoNDEsIDQ1KSksIDE2KSAvLyA0IGJ5dGVzXG4gICAgZmVlUHJvcG9ydGlvbmFsTWlsbGlvbnRocyA9IHBhcnNlSW50KFxuICAgICAgaGV4LmVuY29kZShyb3V0ZXNCdWZmZXIuc2xpY2UoNDUsIDQ5KSksXG4gICAgICAxNlxuICAgICkgLy8gNCBieXRlc1xuICAgIGNsdHZFeHBpcnlEZWx0YSA9IHBhcnNlSW50KGhleC5lbmNvZGUocm91dGVzQnVmZmVyLnNsaWNlKDQ5LCA1MSkpLCAxNikgLy8gMiBieXRlc1xuXG4gICAgcm91dGVzQnVmZmVyID0gcm91dGVzQnVmZmVyLnNsaWNlKDUxKVxuXG4gICAgcm91dGVzLnB1c2goe1xuICAgICAgcHVia2V5LFxuICAgICAgc2hvcnRfY2hhbm5lbF9pZDogc2hvcnRDaGFubmVsSWQsXG4gICAgICBmZWVfYmFzZV9tc2F0OiBmZWVCYXNlTVNhdHMsXG4gICAgICBmZWVfcHJvcG9ydGlvbmFsX21pbGxpb250aHM6IGZlZVByb3BvcnRpb25hbE1pbGxpb250aHMsXG4gICAgICBjbHR2X2V4cGlyeV9kZWx0YTogY2x0dkV4cGlyeURlbHRhXG4gICAgfSlcbiAgfVxuICByZXR1cm4gcm91dGVzXG59XG5cbmZ1bmN0aW9uIGZlYXR1cmVCaXRzUGFyc2VyKHdvcmRzKSB7XG4gIGNvbnN0IGJvb2xzID0gd29yZHNcbiAgICAuc2xpY2UoKVxuICAgIC5yZXZlcnNlKClcbiAgICAubWFwKHdvcmQgPT4gW1xuICAgICAgISEod29yZCAmIDBiMSksXG4gICAgICAhISh3b3JkICYgMGIxMCksXG4gICAgICAhISh3b3JkICYgMGIxMDApLFxuICAgICAgISEod29yZCAmIDBiMTAwMCksXG4gICAgICAhISh3b3JkICYgMGIxMDAwMClcbiAgICBdKVxuICAgIC5yZWR1Y2UoKGZpbmFsQXJyLCBpdGVtQXJyKSA9PiBmaW5hbEFyci5jb25jYXQoaXRlbUFyciksIFtdKVxuICB3aGlsZSAoYm9vbHMubGVuZ3RoIDwgRkVBVFVSRUJJVF9PUkRFUi5sZW5ndGggKiAyKSB7XG4gICAgYm9vbHMucHVzaChmYWxzZSlcbiAgfVxuXG4gIGNvbnN0IGZlYXR1cmVCaXRzID0ge31cblxuICBGRUFUVVJFQklUX09SREVSLmZvckVhY2goKGZlYXR1cmVOYW1lLCBpbmRleCkgPT4ge1xuICAgIGxldCBzdGF0dXNcbiAgICBpZiAoYm9vbHNbaW5kZXggKiAyXSkge1xuICAgICAgc3RhdHVzID0gJ3JlcXVpcmVkJ1xuICAgIH0gZWxzZSBpZiAoYm9vbHNbaW5kZXggKiAyICsgMV0pIHtcbiAgICAgIHN0YXR1cyA9ICdzdXBwb3J0ZWQnXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXR1cyA9ICd1bnN1cHBvcnRlZCdcbiAgICB9XG4gICAgZmVhdHVyZUJpdHNbZmVhdHVyZU5hbWVdID0gc3RhdHVzXG4gIH0pXG5cbiAgY29uc3QgZXh0cmFCaXRzID0gYm9vbHMuc2xpY2UoRkVBVFVSRUJJVF9PUkRFUi5sZW5ndGggKiAyKVxuICBmZWF0dXJlQml0cy5leHRyYV9iaXRzID0ge1xuICAgIHN0YXJ0X2JpdDogRkVBVFVSRUJJVF9PUkRFUi5sZW5ndGggKiAyLFxuICAgIGJpdHM6IGV4dHJhQml0cyxcbiAgICBoYXNfcmVxdWlyZWQ6IGV4dHJhQml0cy5yZWR1Y2UoXG4gICAgICAocmVzdWx0LCBiaXQsIGluZGV4KSA9PlxuICAgICAgICBpbmRleCAlIDIgIT09IDAgPyByZXN1bHQgfHwgZmFsc2UgOiByZXN1bHQgfHwgYml0LFxuICAgICAgZmFsc2VcbiAgICApXG4gIH1cblxuICByZXR1cm4gZmVhdHVyZUJpdHNcbn1cblxuZnVuY3Rpb24gaHJwVG9NaWxsaXNhdChocnBTdHJpbmcsIG91dHB1dFN0cmluZykge1xuICBsZXQgZGl2aXNvciwgdmFsdWVcbiAgaWYgKGhycFN0cmluZy5zbGljZSgtMSkubWF0Y2goL15bbXVucF0kLykpIHtcbiAgICBkaXZpc29yID0gaHJwU3RyaW5nLnNsaWNlKC0xKVxuICAgIHZhbHVlID0gaHJwU3RyaW5nLnNsaWNlKDAsIC0xKVxuICB9IGVsc2UgaWYgKGhycFN0cmluZy5zbGljZSgtMSkubWF0Y2goL15bXm11bnAwLTldJC8pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYSB2YWxpZCBtdWx0aXBsaWVyIGZvciB0aGUgYW1vdW50JylcbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IGhycFN0cmluZ1xuICB9XG5cbiAgaWYgKCF2YWx1ZS5tYXRjaCgvXlxcZCskLykpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYSB2YWxpZCBodW1hbiByZWFkYWJsZSBhbW91bnQnKVxuXG4gIGNvbnN0IHZhbHVlQk4gPSBCaWdJbnQodmFsdWUpXG5cbiAgY29uc3QgbWlsbGlzYXRvc2hpc0JOID0gZGl2aXNvclxuICAgID8gKHZhbHVlQk4gKiBNSUxMSVNBVFNfUEVSX0JUQykgLyBESVZJU09SU1tkaXZpc29yXVxuICAgIDogdmFsdWVCTiAqIE1JTExJU0FUU19QRVJfQlRDXG5cbiAgaWYgKFxuICAgIChkaXZpc29yID09PSAncCcgJiYgISh2YWx1ZUJOICUgQmlnSW50KDEwKSA9PT0gQmlnSW50KDApKSkgfHxcbiAgICBtaWxsaXNhdG9zaGlzQk4gPiBNQVhfTUlMTElTQVRTXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcignQW1vdW50IGlzIG91dHNpZGUgb2YgdmFsaWQgcmFuZ2UnKVxuICB9XG5cbiAgcmV0dXJuIG91dHB1dFN0cmluZyA/IG1pbGxpc2F0b3NoaXNCTi50b1N0cmluZygpIDogbWlsbGlzYXRvc2hpc0JOXG59XG5cbi8vIGRlY29kZSB3aWxsIG9ubHkgaGF2ZSBleHRyYSBjb21tZW50cyB0aGF0IGFyZW4ndCBjb3ZlcmVkIGluIGVuY29kZSBjb21tZW50cy5cbi8vIGFsc28gaWYgYW55dGhpbmcgaXMgaGFyZCB0byByZWFkIEknbGwgY29tbWVudC5cbmZ1bmN0aW9uIGRlY29kZShwYXltZW50UmVxdWVzdCwgbmV0d29yaykge1xuICBpZiAodHlwZW9mIHBheW1lbnRSZXF1ZXN0ICE9PSAnc3RyaW5nJylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0xpZ2h0bmluZyBQYXltZW50IFJlcXVlc3QgbXVzdCBiZSBzdHJpbmcnKVxuICBpZiAocGF5bWVudFJlcXVlc3Quc2xpY2UoMCwgMikudG9Mb3dlckNhc2UoKSAhPT0gJ2xuJylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhIHByb3BlciBsaWdodG5pbmcgcGF5bWVudCByZXF1ZXN0JylcblxuICBjb25zdCBzZWN0aW9ucyA9IFtdXG4gIGNvbnN0IGRlY29kZWQgPSBiZWNoMzIuZGVjb2RlKHBheW1lbnRSZXF1ZXN0LCBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUilcbiAgcGF5bWVudFJlcXVlc3QgPSBwYXltZW50UmVxdWVzdC50b0xvd2VyQ2FzZSgpXG4gIGNvbnN0IHByZWZpeCA9IGRlY29kZWQucHJlZml4XG4gIGxldCB3b3JkcyA9IGRlY29kZWQud29yZHNcbiAgbGV0IGxldHRlcnMgPSBwYXltZW50UmVxdWVzdC5zbGljZShwcmVmaXgubGVuZ3RoICsgMSlcbiAgbGV0IHNpZ1dvcmRzID0gd29yZHMuc2xpY2UoLTEwNClcbiAgd29yZHMgPSB3b3Jkcy5zbGljZSgwLCAtMTA0KVxuXG4gIC8vIFdpdGhvdXQgcmV2ZXJzZSBsb29rdXBzLCBjYW4ndCBzYXkgdGhhdCB0aGUgbXVsdGlwaWVyIGF0IHRoZSBlbmQgbXVzdFxuICAvLyBoYXZlIGEgbnVtYmVyIGJlZm9yZSBpdCwgc28gaW5zdGVhZCB3ZSBwYXJzZSwgYW5kIGlmIHRoZSBzZWNvbmQgZ3JvdXBcbiAgLy8gZG9lc24ndCBoYXZlIGFueXRoaW5nLCB0aGVyZSdzIGEgZ29vZCBjaGFuY2UgdGhlIGxhc3QgbGV0dGVyIG9mIHRoZVxuICAvLyBjb2luIHR5cGUgZ290IGNhcHR1cmVkIGJ5IHRoZSB0aGlyZCBncm91cCwgc28ganVzdCByZS1yZWdleCB3aXRob3V0XG4gIC8vIHRoZSBudW1iZXIuXG4gIGxldCBwcmVmaXhNYXRjaGVzID0gcHJlZml4Lm1hdGNoKC9ebG4oXFxTKz8pKFxcZCopKFthLXpBLVpdPykkLylcbiAgaWYgKHByZWZpeE1hdGNoZXMgJiYgIXByZWZpeE1hdGNoZXNbMl0pXG4gICAgcHJlZml4TWF0Y2hlcyA9IHByZWZpeC5tYXRjaCgvXmxuKFxcUyspJC8pXG4gIGlmICghcHJlZml4TWF0Y2hlcykge1xuICAgIHRocm93IG5ldyBFcnJvcignTm90IGEgcHJvcGVyIGxpZ2h0bmluZyBwYXltZW50IHJlcXVlc3QnKVxuICB9XG5cbiAgLy8gXCJsblwiIHNlY3Rpb25cbiAgc2VjdGlvbnMucHVzaCh7XG4gICAgbmFtZTogJ2xpZ2h0bmluZ19uZXR3b3JrJyxcbiAgICBsZXR0ZXJzOiAnbG4nXG4gIH0pXG5cbiAgLy8gXCJiY1wiIHNlY3Rpb25cbiAgY29uc3QgYmVjaDMyUHJlZml4ID0gcHJlZml4TWF0Y2hlc1sxXVxuICBsZXQgY29pbk5ldHdvcmtcbiAgaWYgKCFuZXR3b3JrKSB7XG4gICAgc3dpdGNoIChiZWNoMzJQcmVmaXgpIHtcbiAgICAgIGNhc2UgREVGQVVMVE5FVFdPUksuYmVjaDMyOlxuICAgICAgICBjb2luTmV0d29yayA9IERFRkFVTFRORVRXT1JLXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIFRFU1RORVRXT1JLLmJlY2gzMjpcbiAgICAgICAgY29pbk5ldHdvcmsgPSBURVNUTkVUV09SS1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSBTSUdORVRORVRXT1JLLmJlY2gzMjpcbiAgICAgICAgY29pbk5ldHdvcmsgPSBTSUdORVRORVRXT1JLXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIFJFR1RFU1RORVRXT1JLLmJlY2gzMjpcbiAgICAgICAgY29pbk5ldHdvcmsgPSBSRUdURVNUTkVUV09SS1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSBTSU1ORVRXT1JLLmJlY2gzMjpcbiAgICAgICAgY29pbk5ldHdvcmsgPSBTSU1ORVRXT1JLXG4gICAgICAgIGJyZWFrXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChcbiAgICAgIG5ldHdvcmsuYmVjaDMyID09PSB1bmRlZmluZWQgfHxcbiAgICAgIG5ldHdvcmsucHViS2V5SGFzaCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICBuZXR3b3JrLnNjcmlwdEhhc2ggPT09IHVuZGVmaW5lZCB8fFxuICAgICAgIUFycmF5LmlzQXJyYXkobmV0d29yay52YWxpZFdpdG5lc3NWZXJzaW9ucylcbiAgICApXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbmV0d29yaycpXG4gICAgY29pbk5ldHdvcmsgPSBuZXR3b3JrXG4gIH1cbiAgaWYgKCFjb2luTmV0d29yayB8fCBjb2luTmV0d29yay5iZWNoMzIgIT09IGJlY2gzMlByZWZpeCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBjb2luIGJlY2gzMiBwcmVmaXgnKVxuICB9XG4gIHNlY3Rpb25zLnB1c2goe1xuICAgIG5hbWU6ICdjb2luX25ldHdvcmsnLFxuICAgIGxldHRlcnM6IGJlY2gzMlByZWZpeCxcbiAgICB2YWx1ZTogY29pbk5ldHdvcmtcbiAgfSlcblxuICAvLyBhbW91bnQgc2VjdGlvblxuICBjb25zdCB2YWx1ZSA9IHByZWZpeE1hdGNoZXNbMl1cbiAgbGV0IG1pbGxpc2F0b3NoaXNcbiAgaWYgKHZhbHVlKSB7XG4gICAgY29uc3QgZGl2aXNvciA9IHByZWZpeE1hdGNoZXNbM11cbiAgICBtaWxsaXNhdG9zaGlzID0gaHJwVG9NaWxsaXNhdCh2YWx1ZSArIGRpdmlzb3IsIHRydWUpXG4gICAgc2VjdGlvbnMucHVzaCh7XG4gICAgICBuYW1lOiAnYW1vdW50JyxcbiAgICAgIGxldHRlcnM6IHByZWZpeE1hdGNoZXNbMl0gKyBwcmVmaXhNYXRjaGVzWzNdLFxuICAgICAgdmFsdWU6IG1pbGxpc2F0b3NoaXNcbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIG1pbGxpc2F0b3NoaXMgPSBudWxsXG4gIH1cblxuICAvLyBcIjFcIiBzZXBhcmF0b3JcbiAgc2VjdGlvbnMucHVzaCh7XG4gICAgbmFtZTogJ3NlcGFyYXRvcicsXG4gICAgbGV0dGVyczogJzEnXG4gIH0pXG5cbiAgLy8gdGltZXN0YW1wXG4gIGNvbnN0IHRpbWVzdGFtcCA9IHdvcmRzVG9JbnRCRSh3b3Jkcy5zbGljZSgwLCA3KSlcbiAgd29yZHMgPSB3b3Jkcy5zbGljZSg3KSAvLyB0cmltIG9mZiB0aGUgbGVmdCA3IHdvcmRzXG4gIHNlY3Rpb25zLnB1c2goe1xuICAgIG5hbWU6ICd0aW1lc3RhbXAnLFxuICAgIGxldHRlcnM6IGxldHRlcnMuc2xpY2UoMCwgNyksXG4gICAgdmFsdWU6IHRpbWVzdGFtcFxuICB9KVxuICBsZXR0ZXJzID0gbGV0dGVycy5zbGljZSg3KVxuXG4gIGxldCB0YWdOYW1lLCBwYXJzZXIsIHRhZ0xlbmd0aCwgdGFnV29yZHNcbiAgLy8gd2UgaGF2ZSBubyB0YWcgY291bnQgdG8gZ28gb24sIHNvIGp1c3Qga2VlcCBoYWNraW5nIG9mZiB3b3Jkc1xuICAvLyB1bnRpbCB3ZSBoYXZlIG5vbmUuXG4gIHdoaWxlICh3b3Jkcy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgdGFnQ29kZSA9IHdvcmRzWzBdLnRvU3RyaW5nKClcbiAgICB0YWdOYW1lID0gVEFHTkFNRVNbdGFnQ29kZV0gfHwgJ3Vua25vd25fdGFnJ1xuICAgIHBhcnNlciA9IFRBR1BBUlNFUlNbdGFnQ29kZV0gfHwgZ2V0VW5rbm93blBhcnNlcih0YWdDb2RlKVxuICAgIHdvcmRzID0gd29yZHMuc2xpY2UoMSlcblxuICAgIHRhZ0xlbmd0aCA9IHdvcmRzVG9JbnRCRSh3b3Jkcy5zbGljZSgwLCAyKSlcbiAgICB3b3JkcyA9IHdvcmRzLnNsaWNlKDIpXG5cbiAgICB0YWdXb3JkcyA9IHdvcmRzLnNsaWNlKDAsIHRhZ0xlbmd0aClcbiAgICB3b3JkcyA9IHdvcmRzLnNsaWNlKHRhZ0xlbmd0aClcblxuICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgbmFtZTogdGFnTmFtZSxcbiAgICAgIHRhZzogbGV0dGVyc1swXSxcbiAgICAgIGxldHRlcnM6IGxldHRlcnMuc2xpY2UoMCwgMSArIDIgKyB0YWdMZW5ndGgpLFxuICAgICAgdmFsdWU6IHBhcnNlcih0YWdXb3JkcykgLy8gc2VlOiBwYXJzZXJzIGZvciBtb3JlIGNvbW1lbnRzXG4gICAgfSlcbiAgICBsZXR0ZXJzID0gbGV0dGVycy5zbGljZSgxICsgMiArIHRhZ0xlbmd0aClcbiAgfVxuXG4gIC8vIHNpZ25hdHVyZVxuICBzZWN0aW9ucy5wdXNoKHtcbiAgICBuYW1lOiAnc2lnbmF0dXJlJyxcbiAgICBsZXR0ZXJzOiBsZXR0ZXJzLnNsaWNlKDAsIDEwNCksXG4gICAgdmFsdWU6IGhleC5lbmNvZGUoYmVjaDMyLmZyb21Xb3Jkc1Vuc2FmZShzaWdXb3JkcykpXG4gIH0pXG4gIGxldHRlcnMgPSBsZXR0ZXJzLnNsaWNlKDEwNClcblxuICAvLyBjaGVja3N1bVxuICBzZWN0aW9ucy5wdXNoKHtcbiAgICBuYW1lOiAnY2hlY2tzdW0nLFxuICAgIGxldHRlcnM6IGxldHRlcnNcbiAgfSlcblxuICBsZXQgcmVzdWx0ID0ge1xuICAgIHBheW1lbnRSZXF1ZXN0LFxuICAgIHNlY3Rpb25zLFxuXG4gICAgZ2V0IGV4cGlyeSgpIHtcbiAgICAgIGxldCBleHAgPSBzZWN0aW9ucy5maW5kKHMgPT4gcy5uYW1lID09PSAnZXhwaXJ5JylcbiAgICAgIGlmIChleHApIHJldHVybiBnZXRWYWx1ZSgndGltZXN0YW1wJykgKyBleHAudmFsdWVcbiAgICB9LFxuXG4gICAgZ2V0IHJvdXRlX2hpbnRzKCkge1xuICAgICAgcmV0dXJuIHNlY3Rpb25zLmZpbHRlcihzID0+IHMubmFtZSA9PT0gJ3JvdXRlX2hpbnQnKS5tYXAocyA9PiBzLnZhbHVlKVxuICAgIH1cbiAgfVxuXG4gIGZvciAobGV0IG5hbWUgaW4gVEFHQ09ERVMpIHtcbiAgICBpZiAobmFtZSA9PT0gJ3JvdXRlX2hpbnQnKSB7XG4gICAgICAvLyByb3V0ZSBoaW50cyBjYW4gYmUgbXVsdGlwbGUsIHNvIHRoaXMgd29uJ3Qgd29yayBmb3IgdGhlbVxuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzdWx0LCBuYW1lLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiBnZXRWYWx1ZShuYW1lKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG5cbiAgZnVuY3Rpb24gZ2V0VmFsdWUobmFtZSkge1xuICAgIGxldCBzZWN0aW9uID0gc2VjdGlvbnMuZmluZChzID0+IHMubmFtZSA9PT0gbmFtZSlcbiAgICByZXR1cm4gc2VjdGlvbiA/IHNlY3Rpb24udmFsdWUgOiB1bmRlZmluZWRcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGVjb2RlLFxuICBocnBUb01pbGxpc2F0XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/light-bolt11-decoder/bolt11.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/light-bolt11-decoder/node_modules/@scure/base/lib/index.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/light-bolt11-decoder/node_modules/@scure/base/lib/index.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.bytes = exports.stringToBytes = exports.str = exports.bytesToString = exports.hex = exports.utf8 = exports.bech32m = exports.bech32 = exports.base58check = exports.base58xmr = exports.base58xrp = exports.base58flickr = exports.base58 = exports.base64url = exports.base64 = exports.base32crockford = exports.base32hex = exports.base32 = exports.base16 = exports.utils = exports.assertNumber = void 0;\nfunction assertNumber(n) {\n    if (!Number.isSafeInteger(n))\n        throw new Error(`Wrong integer: ${n}`);\n}\nexports.assertNumber = assertNumber;\nfunction chain(...args) {\n    const wrap = (a, b) => (c) => a(b(c));\n    const encode = Array.from(args)\n        .reverse()\n        .reduce((acc, i) => (acc ? wrap(acc, i.encode) : i.encode), undefined);\n    const decode = args.reduce((acc, i) => (acc ? wrap(acc, i.decode) : i.decode), undefined);\n    return { encode, decode };\n}\nfunction alphabet(alphabet) {\n    return {\n        encode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('alphabet.encode input should be an array of numbers');\n            return digits.map((i) => {\n                assertNumber(i);\n                if (i < 0 || i >= alphabet.length)\n                    throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet.length})`);\n                return alphabet[i];\n            });\n        },\n        decode: (input) => {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('alphabet.decode input should be array of strings');\n            return input.map((letter) => {\n                if (typeof letter !== 'string')\n                    throw new Error(`alphabet.decode: not string element=${letter}`);\n                const index = alphabet.indexOf(letter);\n                if (index === -1)\n                    throw new Error(`Unknown letter: \"${letter}\". Allowed: ${alphabet}`);\n                return index;\n            });\n        },\n    };\n}\nfunction join(separator = '') {\n    if (typeof separator !== 'string')\n        throw new Error('join separator should be string');\n    return {\n        encode: (from) => {\n            if (!Array.isArray(from) || (from.length && typeof from[0] !== 'string'))\n                throw new Error('join.encode input should be array of strings');\n            for (let i of from)\n                if (typeof i !== 'string')\n                    throw new Error(`join.encode: non-string input=${i}`);\n            return from.join(separator);\n        },\n        decode: (to) => {\n            if (typeof to !== 'string')\n                throw new Error('join.decode input should be string');\n            return to.split(separator);\n        },\n    };\n}\nfunction padding(bits, chr = '=') {\n    assertNumber(bits);\n    if (typeof chr !== 'string')\n        throw new Error('padding chr should be string');\n    return {\n        encode(data) {\n            if (!Array.isArray(data) || (data.length && typeof data[0] !== 'string'))\n                throw new Error('padding.encode input should be array of strings');\n            for (let i of data)\n                if (typeof i !== 'string')\n                    throw new Error(`padding.encode: non-string input=${i}`);\n            while ((data.length * bits) % 8)\n                data.push(chr);\n            return data;\n        },\n        decode(input) {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('padding.encode input should be array of strings');\n            for (let i of input)\n                if (typeof i !== 'string')\n                    throw new Error(`padding.decode: non-string input=${i}`);\n            let end = input.length;\n            if ((end * bits) % 8)\n                throw new Error('Invalid padding: string should have whole number of bytes');\n            for (; end > 0 && input[end - 1] === chr; end--) {\n                if (!(((end - 1) * bits) % 8))\n                    throw new Error('Invalid padding: string has too much padding');\n            }\n            return input.slice(0, end);\n        },\n    };\n}\nfunction normalize(fn) {\n    if (typeof fn !== 'function')\n        throw new Error('normalize fn should be function');\n    return { encode: (from) => from, decode: (to) => fn(to) };\n}\nfunction convertRadix(data, from, to) {\n    if (from < 2)\n        throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);\n    if (to < 2)\n        throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);\n    if (!Array.isArray(data))\n        throw new Error('convertRadix: data should be array');\n    if (!data.length)\n        return [];\n    let pos = 0;\n    const res = [];\n    const digits = Array.from(data);\n    digits.forEach((d) => {\n        assertNumber(d);\n        if (d < 0 || d >= from)\n            throw new Error(`Wrong integer: ${d}`);\n    });\n    while (true) {\n        let carry = 0;\n        let done = true;\n        for (let i = pos; i < digits.length; i++) {\n            const digit = digits[i];\n            const digitBase = from * carry + digit;\n            if (!Number.isSafeInteger(digitBase) ||\n                (from * carry) / from !== carry ||\n                digitBase - digit !== from * carry) {\n                throw new Error('convertRadix: carry overflow');\n            }\n            carry = digitBase % to;\n            digits[i] = Math.floor(digitBase / to);\n            if (!Number.isSafeInteger(digits[i]) || digits[i] * to + carry !== digitBase)\n                throw new Error('convertRadix: carry overflow');\n            if (!done)\n                continue;\n            else if (!digits[i])\n                pos = i;\n            else\n                done = false;\n        }\n        res.push(carry);\n        if (done)\n            break;\n    }\n    for (let i = 0; i < data.length - 1 && data[i] === 0; i++)\n        res.push(0);\n    return res.reverse();\n}\nconst gcd = (a, b) => (!b ? a : gcd(b, a % b));\nconst radix2carry = (from, to) => from + (to - gcd(from, to));\nfunction convertRadix2(data, from, to, padding) {\n    if (!Array.isArray(data))\n        throw new Error('convertRadix2: data should be array');\n    if (from <= 0 || from > 32)\n        throw new Error(`convertRadix2: wrong from=${from}`);\n    if (to <= 0 || to > 32)\n        throw new Error(`convertRadix2: wrong to=${to}`);\n    if (radix2carry(from, to) > 32) {\n        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);\n    }\n    let carry = 0;\n    let pos = 0;\n    const mask = 2 ** to - 1;\n    const res = [];\n    for (const n of data) {\n        assertNumber(n);\n        if (n >= 2 ** from)\n            throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n        carry = (carry << from) | n;\n        if (pos + from > 32)\n            throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n        pos += from;\n        for (; pos >= to; pos -= to)\n            res.push(((carry >> (pos - to)) & mask) >>> 0);\n        carry &= 2 ** pos - 1;\n    }\n    carry = (carry << (to - pos)) & mask;\n    if (!padding && pos >= from)\n        throw new Error('Excess padding');\n    if (!padding && carry)\n        throw new Error(`Non-zero padding: ${carry}`);\n    if (padding && pos > 0)\n        res.push(carry >>> 0);\n    return res;\n}\nfunction radix(num) {\n    assertNumber(num);\n    return {\n        encode: (bytes) => {\n            if (!(bytes instanceof Uint8Array))\n                throw new Error('radix.encode input should be Uint8Array');\n            return convertRadix(Array.from(bytes), 2 ** 8, num);\n        },\n        decode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('radix.decode input should be array of strings');\n            return Uint8Array.from(convertRadix(digits, num, 2 ** 8));\n        },\n    };\n}\nfunction radix2(bits, revPadding = false) {\n    assertNumber(bits);\n    if (bits <= 0 || bits > 32)\n        throw new Error('radix2: bits should be in (0..32]');\n    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)\n        throw new Error('radix2: carry overflow');\n    return {\n        encode: (bytes) => {\n            if (!(bytes instanceof Uint8Array))\n                throw new Error('radix2.encode input should be Uint8Array');\n            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n        },\n        decode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('radix2.decode input should be array of strings');\n            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n        },\n    };\n}\nfunction unsafeWrapper(fn) {\n    if (typeof fn !== 'function')\n        throw new Error('unsafeWrapper fn should be function');\n    return function (...args) {\n        try {\n            return fn.apply(null, args);\n        }\n        catch (e) { }\n    };\n}\nfunction checksum(len, fn) {\n    assertNumber(len);\n    if (typeof fn !== 'function')\n        throw new Error('checksum fn should be function');\n    return {\n        encode(data) {\n            if (!(data instanceof Uint8Array))\n                throw new Error('checksum.encode: input should be Uint8Array');\n            const checksum = fn(data).slice(0, len);\n            const res = new Uint8Array(data.length + len);\n            res.set(data);\n            res.set(checksum, data.length);\n            return res;\n        },\n        decode(data) {\n            if (!(data instanceof Uint8Array))\n                throw new Error('checksum.decode: input should be Uint8Array');\n            const payload = data.slice(0, -len);\n            const newChecksum = fn(payload).slice(0, len);\n            const oldChecksum = data.slice(-len);\n            for (let i = 0; i < len; i++)\n                if (newChecksum[i] !== oldChecksum[i])\n                    throw new Error('Invalid checksum');\n            return payload;\n        },\n    };\n}\nexports.utils = { alphabet, chain, checksum, radix, radix2, join, padding };\nexports.base16 = chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));\nexports.base32 = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));\nexports.base32hex = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));\nexports.base32crockford = chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize((s) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')));\nexports.base64 = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));\nexports.base64url = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));\nconst genBase58 = (abc) => chain(radix(58), alphabet(abc), join(''));\nexports.base58 = genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');\nexports.base58flickr = genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');\nexports.base58xrp = genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');\nconst XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\nexports.base58xmr = {\n    encode(data) {\n        let res = '';\n        for (let i = 0; i < data.length; i += 8) {\n            const block = data.subarray(i, i + 8);\n            res += exports.base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');\n        }\n        return res;\n    },\n    decode(str) {\n        let res = [];\n        for (let i = 0; i < str.length; i += 11) {\n            const slice = str.slice(i, i + 11);\n            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n            const block = exports.base58.decode(slice);\n            for (let j = 0; j < block.length - blockLen; j++) {\n                if (block[j] !== 0)\n                    throw new Error('base58xmr: wrong padding');\n            }\n            res = res.concat(Array.from(block.slice(block.length - blockLen)));\n        }\n        return Uint8Array.from(res);\n    },\n};\nconst base58check = (sha256) => chain(checksum(4, (data) => sha256(sha256(data))), exports.base58);\nexports.base58check = base58check;\nconst BECH_ALPHABET = chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));\nconst POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\nfunction bech32Polymod(pre) {\n    const b = pre >> 25;\n    let chk = (pre & 0x1ffffff) << 5;\n    for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {\n        if (((b >> i) & 1) === 1)\n            chk ^= POLYMOD_GENERATORS[i];\n    }\n    return chk;\n}\nfunction bechChecksum(prefix, words, encodingConst = 1) {\n    const len = prefix.length;\n    let chk = 1;\n    for (let i = 0; i < len; i++) {\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126)\n            throw new Error(`Invalid prefix (${prefix})`);\n        chk = bech32Polymod(chk) ^ (c >> 5);\n    }\n    chk = bech32Polymod(chk);\n    for (let i = 0; i < len; i++)\n        chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);\n    for (let v of words)\n        chk = bech32Polymod(chk) ^ v;\n    for (let i = 0; i < 6; i++)\n        chk = bech32Polymod(chk);\n    chk ^= encodingConst;\n    return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));\n}\nfunction genBech32(encoding) {\n    const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n    const _words = radix2(5);\n    const fromWords = _words.decode;\n    const toWords = _words.encode;\n    const fromWordsUnsafe = unsafeWrapper(fromWords);\n    function encode(prefix, words, limit = 90) {\n        if (typeof prefix !== 'string')\n            throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);\n        if (!Array.isArray(words) || (words.length && typeof words[0] !== 'number'))\n            throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);\n        const actualLength = prefix.length + 7 + words.length;\n        if (limit !== false && actualLength > limit)\n            throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n        prefix = prefix.toLowerCase();\n        return `${prefix}1${BECH_ALPHABET.encode(words)}${bechChecksum(prefix, words, ENCODING_CONST)}`;\n    }\n    function decode(str, limit = 90) {\n        if (typeof str !== 'string')\n            throw new Error(`bech32.decode input should be string, not ${typeof str}`);\n        if (str.length < 8 || (limit !== false && str.length > limit))\n            throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);\n        const lowered = str.toLowerCase();\n        if (str !== lowered && str !== str.toUpperCase())\n            throw new Error(`String must be lowercase or uppercase`);\n        str = lowered;\n        const sepIndex = str.lastIndexOf('1');\n        if (sepIndex === 0 || sepIndex === -1)\n            throw new Error(`Letter \"1\" must be present between prefix and data only`);\n        const prefix = str.slice(0, sepIndex);\n        const _words = str.slice(sepIndex + 1);\n        if (_words.length < 6)\n            throw new Error('Data must be at least 6 characters long');\n        const words = BECH_ALPHABET.decode(_words).slice(0, -6);\n        const sum = bechChecksum(prefix, words, ENCODING_CONST);\n        if (!_words.endsWith(sum))\n            throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n        return { prefix, words };\n    }\n    const decodeUnsafe = unsafeWrapper(decode);\n    function decodeToBytes(str) {\n        const { prefix, words } = decode(str, false);\n        return { prefix, words, bytes: fromWords(words) };\n    }\n    return { encode, decode, decodeToBytes, decodeUnsafe, fromWords, fromWordsUnsafe, toWords };\n}\nexports.bech32 = genBech32('bech32');\nexports.bech32m = genBech32('bech32m');\nexports.utf8 = {\n    encode: (data) => new TextDecoder().decode(data),\n    decode: (str) => new TextEncoder().encode(str),\n};\nexports.hex = chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize((s) => {\n    if (typeof s !== 'string' || s.length % 2)\n        throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);\n    return s.toLowerCase();\n}));\nconst CODERS = {\n    utf8: exports.utf8, hex: exports.hex, base16: exports.base16, base32: exports.base32, base64: exports.base64, base64url: exports.base64url, base58: exports.base58, base58xmr: exports.base58xmr\n};\nconst coderTypeError = `Invalid encoding type. Available types: ${Object.keys(CODERS).join(', ')}`;\nconst bytesToString = (type, bytes) => {\n    if (typeof type !== 'string' || !CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (!(bytes instanceof Uint8Array))\n        throw new TypeError('bytesToString() expects Uint8Array');\n    return CODERS[type].encode(bytes);\n};\nexports.bytesToString = bytesToString;\nexports.str = exports.bytesToString;\nconst stringToBytes = (type, str) => {\n    if (!CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (typeof str !== 'string')\n        throw new TypeError('stringToBytes() expects string');\n    return CODERS[type].decode(str);\n};\nexports.stringToBytes = stringToBytes;\nexports.bytes = exports.stringToBytes;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGlnaHQtYm9sdDExLWRlY29kZXIvbm9kZV9tb2R1bGVzL0BzY3VyZS9iYXNlL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsR0FBRyxxQkFBcUIsR0FBRyxXQUFXLEdBQUcscUJBQXFCLEdBQUcsV0FBVyxHQUFHLFlBQVksR0FBRyxlQUFlLEdBQUcsY0FBYyxHQUFHLG1CQUFtQixHQUFHLGlCQUFpQixHQUFHLGlCQUFpQixHQUFHLG9CQUFvQixHQUFHLGNBQWMsR0FBRyxpQkFBaUIsR0FBRyxjQUFjLEdBQUcsdUJBQXVCLEdBQUcsaUJBQWlCLEdBQUcsY0FBYyxHQUFHLGNBQWMsR0FBRyxhQUFhLEdBQUcsb0JBQW9CO0FBQzdZO0FBQ0E7QUFDQSwwQ0FBMEMsRUFBRTtBQUM1QztBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLEdBQUcsYUFBYSxnQkFBZ0I7QUFDckc7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsT0FBTztBQUNsRjtBQUNBO0FBQ0Esd0RBQXdELE9BQU8sY0FBYyxTQUFTO0FBQ3RGO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLEVBQUU7QUFDdkU7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLEVBQUU7QUFDMUU7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsRUFBRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUNBQW1DO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELEtBQUs7QUFDekQ7QUFDQSxrREFBa0QsR0FBRztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxFQUFFO0FBQ2hELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsbUJBQW1CO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNDQUFzQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsS0FBSztBQUMxRDtBQUNBLG1EQUFtRCxHQUFHO0FBQ3REO0FBQ0EsOERBQThELE1BQU0sS0FBSyxJQUFJLFlBQVksc0JBQXNCO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsR0FBRyxPQUFPLEtBQUs7QUFDL0U7QUFDQTtBQUNBLGlFQUFpRSxLQUFLLE9BQU8sS0FBSztBQUNsRjtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxNQUFNO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFNBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxhQUFhLEtBQUs7QUFDbEIsY0FBYztBQUNkLGNBQWM7QUFDZCxpQkFBaUI7QUFDakIsdUJBQXVCO0FBQ3ZCLGNBQWM7QUFDZCxpQkFBaUI7QUFDakI7QUFDQSxjQUFjO0FBQ2Qsb0JBQW9CO0FBQ3BCLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNkJBQTZCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsK0JBQStCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0EsK0NBQStDLE9BQU87QUFDdEQ7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLGNBQWM7QUFDeEY7QUFDQSxtRkFBbUYsYUFBYTtBQUNoRztBQUNBO0FBQ0EsMENBQTBDLGNBQWMsZ0JBQWdCLE1BQU07QUFDOUU7QUFDQSxrQkFBa0IsT0FBTyxHQUFHLDRCQUE0QixFQUFFLDRDQUE0QztBQUN0RztBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsV0FBVztBQUNwRjtBQUNBLHdEQUF3RCxZQUFZLEdBQUcsSUFBSSxrQkFBa0IsTUFBTTtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELElBQUksY0FBYyxJQUFJO0FBQ3pFLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBLGNBQWM7QUFDZCxlQUFlO0FBQ2YsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLGdFQUFnRSxVQUFVLGNBQWMsU0FBUztBQUNqRztBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsK0JBQStCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixhQUFhIiwic291cmNlcyI6WyIvaG9tZS9sZmcvR2l0L01hZHRyaXBzL25vZGVfbW9kdWxlcy9saWdodC1ib2x0MTEtZGVjb2Rlci9ub2RlX21vZHVsZXMvQHNjdXJlL2Jhc2UvbGliL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyohIHNjdXJlLWJhc2UgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYnl0ZXMgPSBleHBvcnRzLnN0cmluZ1RvQnl0ZXMgPSBleHBvcnRzLnN0ciA9IGV4cG9ydHMuYnl0ZXNUb1N0cmluZyA9IGV4cG9ydHMuaGV4ID0gZXhwb3J0cy51dGY4ID0gZXhwb3J0cy5iZWNoMzJtID0gZXhwb3J0cy5iZWNoMzIgPSBleHBvcnRzLmJhc2U1OGNoZWNrID0gZXhwb3J0cy5iYXNlNTh4bXIgPSBleHBvcnRzLmJhc2U1OHhycCA9IGV4cG9ydHMuYmFzZTU4ZmxpY2tyID0gZXhwb3J0cy5iYXNlNTggPSBleHBvcnRzLmJhc2U2NHVybCA9IGV4cG9ydHMuYmFzZTY0ID0gZXhwb3J0cy5iYXNlMzJjcm9ja2ZvcmQgPSBleHBvcnRzLmJhc2UzMmhleCA9IGV4cG9ydHMuYmFzZTMyID0gZXhwb3J0cy5iYXNlMTYgPSBleHBvcnRzLnV0aWxzID0gZXhwb3J0cy5hc3NlcnROdW1iZXIgPSB2b2lkIDA7XG5mdW5jdGlvbiBhc3NlcnROdW1iZXIobikge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgV3JvbmcgaW50ZWdlcjogJHtufWApO1xufVxuZXhwb3J0cy5hc3NlcnROdW1iZXIgPSBhc3NlcnROdW1iZXI7XG5mdW5jdGlvbiBjaGFpbiguLi5hcmdzKSB7XG4gICAgY29uc3Qgd3JhcCA9IChhLCBiKSA9PiAoYykgPT4gYShiKGMpKTtcbiAgICBjb25zdCBlbmNvZGUgPSBBcnJheS5mcm9tKGFyZ3MpXG4gICAgICAgIC5yZXZlcnNlKClcbiAgICAgICAgLnJlZHVjZSgoYWNjLCBpKSA9PiAoYWNjID8gd3JhcChhY2MsIGkuZW5jb2RlKSA6IGkuZW5jb2RlKSwgdW5kZWZpbmVkKTtcbiAgICBjb25zdCBkZWNvZGUgPSBhcmdzLnJlZHVjZSgoYWNjLCBpKSA9PiAoYWNjID8gd3JhcChhY2MsIGkuZGVjb2RlKSA6IGkuZGVjb2RlKSwgdW5kZWZpbmVkKTtcbiAgICByZXR1cm4geyBlbmNvZGUsIGRlY29kZSB9O1xufVxuZnVuY3Rpb24gYWxwaGFiZXQoYWxwaGFiZXQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGU6IChkaWdpdHMpID0+IHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkaWdpdHMpIHx8IChkaWdpdHMubGVuZ3RoICYmIHR5cGVvZiBkaWdpdHNbMF0gIT09ICdudW1iZXInKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FscGhhYmV0LmVuY29kZSBpbnB1dCBzaG91bGQgYmUgYW4gYXJyYXkgb2YgbnVtYmVycycpO1xuICAgICAgICAgICAgcmV0dXJuIGRpZ2l0cy5tYXAoKGkpID0+IHtcbiAgICAgICAgICAgICAgICBhc3NlcnROdW1iZXIoaSk7XG4gICAgICAgICAgICAgICAgaWYgKGkgPCAwIHx8IGkgPj0gYWxwaGFiZXQubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERpZ2l0IGluZGV4IG91dHNpZGUgYWxwaGFiZXQ6ICR7aX0gKGFscGhhYmV0OiAke2FscGhhYmV0Lmxlbmd0aH0pYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFscGhhYmV0W2ldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZTogKGlucHV0KSA9PiB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXQpIHx8IChpbnB1dC5sZW5ndGggJiYgdHlwZW9mIGlucHV0WzBdICE9PSAnc3RyaW5nJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhbHBoYWJldC5kZWNvZGUgaW5wdXQgc2hvdWxkIGJlIGFycmF5IG9mIHN0cmluZ3MnKTtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dC5tYXAoKGxldHRlcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbGV0dGVyICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBhbHBoYWJldC5kZWNvZGU6IG5vdCBzdHJpbmcgZWxlbWVudD0ke2xldHRlcn1gKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGFscGhhYmV0LmluZGV4T2YobGV0dGVyKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gbGV0dGVyOiBcIiR7bGV0dGVyfVwiLiBBbGxvd2VkOiAke2FscGhhYmV0fWApO1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgIH07XG59XG5mdW5jdGlvbiBqb2luKHNlcGFyYXRvciA9ICcnKSB7XG4gICAgaWYgKHR5cGVvZiBzZXBhcmF0b3IgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2pvaW4gc2VwYXJhdG9yIHNob3VsZCBiZSBzdHJpbmcnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGU6IChmcm9tKSA9PiB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZnJvbSkgfHwgKGZyb20ubGVuZ3RoICYmIHR5cGVvZiBmcm9tWzBdICE9PSAnc3RyaW5nJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdqb2luLmVuY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2Ygc3RyaW5ncycpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSBvZiBmcm9tKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaSAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgam9pbi5lbmNvZGU6IG5vbi1zdHJpbmcgaW5wdXQ9JHtpfWApO1xuICAgICAgICAgICAgcmV0dXJuIGZyb20uam9pbihzZXBhcmF0b3IpO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGU6ICh0bykgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0byAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdqb2luLmRlY29kZSBpbnB1dCBzaG91bGQgYmUgc3RyaW5nJyk7XG4gICAgICAgICAgICByZXR1cm4gdG8uc3BsaXQoc2VwYXJhdG9yKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gcGFkZGluZyhiaXRzLCBjaHIgPSAnPScpIHtcbiAgICBhc3NlcnROdW1iZXIoYml0cyk7XG4gICAgaWYgKHR5cGVvZiBjaHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRpbmcgY2hyIHNob3VsZCBiZSBzdHJpbmcnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGUoZGF0YSkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpIHx8IChkYXRhLmxlbmd0aCAmJiB0eXBlb2YgZGF0YVswXSAhPT0gJ3N0cmluZycpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGluZy5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIGFycmF5IG9mIHN0cmluZ3MnKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgb2YgZGF0YSlcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGkgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHBhZGRpbmcuZW5jb2RlOiBub24tc3RyaW5nIGlucHV0PSR7aX1gKTtcbiAgICAgICAgICAgIHdoaWxlICgoZGF0YS5sZW5ndGggKiBiaXRzKSAlIDgpXG4gICAgICAgICAgICAgICAgZGF0YS5wdXNoKGNocik7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlKGlucHV0KSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXQpIHx8IChpbnB1dC5sZW5ndGggJiYgdHlwZW9mIGlucHV0WzBdICE9PSAnc3RyaW5nJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkaW5nLmVuY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2Ygc3RyaW5ncycpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSBvZiBpbnB1dClcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGkgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHBhZGRpbmcuZGVjb2RlOiBub24tc3RyaW5nIGlucHV0PSR7aX1gKTtcbiAgICAgICAgICAgIGxldCBlbmQgPSBpbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoKGVuZCAqIGJpdHMpICUgOClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcGFkZGluZzogc3RyaW5nIHNob3VsZCBoYXZlIHdob2xlIG51bWJlciBvZiBieXRlcycpO1xuICAgICAgICAgICAgZm9yICg7IGVuZCA+IDAgJiYgaW5wdXRbZW5kIC0gMV0gPT09IGNocjsgZW5kLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoISgoKGVuZCAtIDEpICogYml0cykgJSA4KSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHBhZGRpbmc6IHN0cmluZyBoYXMgdG9vIG11Y2ggcGFkZGluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGlucHV0LnNsaWNlKDAsIGVuZCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZShmbikge1xuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbm9ybWFsaXplIGZuIHNob3VsZCBiZSBmdW5jdGlvbicpO1xuICAgIHJldHVybiB7IGVuY29kZTogKGZyb20pID0+IGZyb20sIGRlY29kZTogKHRvKSA9PiBmbih0bykgfTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRSYWRpeChkYXRhLCBmcm9tLCB0bykge1xuICAgIGlmIChmcm9tIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXg6IHdyb25nIGZyb209JHtmcm9tfSwgYmFzZSBjYW5ub3QgYmUgbGVzcyB0aGFuIDJgKTtcbiAgICBpZiAodG8gPCAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDogd3JvbmcgdG89JHt0b30sIGJhc2UgY2Fubm90IGJlIGxlc3MgdGhhbiAyYCk7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbnZlcnRSYWRpeDogZGF0YSBzaG91bGQgYmUgYXJyYXknKTtcbiAgICBpZiAoIWRhdGEubGVuZ3RoKVxuICAgICAgICByZXR1cm4gW107XG4gICAgbGV0IHBvcyA9IDA7XG4gICAgY29uc3QgcmVzID0gW107XG4gICAgY29uc3QgZGlnaXRzID0gQXJyYXkuZnJvbShkYXRhKTtcbiAgICBkaWdpdHMuZm9yRWFjaCgoZCkgPT4ge1xuICAgICAgICBhc3NlcnROdW1iZXIoZCk7XG4gICAgICAgIGlmIChkIDwgMCB8fCBkID49IGZyb20pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdyb25nIGludGVnZXI6ICR7ZH1gKTtcbiAgICB9KTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBsZXQgY2FycnkgPSAwO1xuICAgICAgICBsZXQgZG9uZSA9IHRydWU7XG4gICAgICAgIGZvciAobGV0IGkgPSBwb3M7IGkgPCBkaWdpdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGRpZ2l0ID0gZGlnaXRzW2ldO1xuICAgICAgICAgICAgY29uc3QgZGlnaXRCYXNlID0gZnJvbSAqIGNhcnJ5ICsgZGlnaXQ7XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGRpZ2l0QmFzZSkgfHxcbiAgICAgICAgICAgICAgICAoZnJvbSAqIGNhcnJ5KSAvIGZyb20gIT09IGNhcnJ5IHx8XG4gICAgICAgICAgICAgICAgZGlnaXRCYXNlIC0gZGlnaXQgIT09IGZyb20gKiBjYXJyeSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY29udmVydFJhZGl4OiBjYXJyeSBvdmVyZmxvdycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FycnkgPSBkaWdpdEJhc2UgJSB0bztcbiAgICAgICAgICAgIGRpZ2l0c1tpXSA9IE1hdGguZmxvb3IoZGlnaXRCYXNlIC8gdG8pO1xuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihkaWdpdHNbaV0pIHx8IGRpZ2l0c1tpXSAqIHRvICsgY2FycnkgIT09IGRpZ2l0QmFzZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbnZlcnRSYWRpeDogY2Fycnkgb3ZlcmZsb3cnKTtcbiAgICAgICAgICAgIGlmICghZG9uZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKCFkaWdpdHNbaV0pXG4gICAgICAgICAgICAgICAgcG9zID0gaTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBkb25lID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2goY2FycnkpO1xuICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoIC0gMSAmJiBkYXRhW2ldID09PSAwOyBpKyspXG4gICAgICAgIHJlcy5wdXNoKDApO1xuICAgIHJldHVybiByZXMucmV2ZXJzZSgpO1xufVxuY29uc3QgZ2NkID0gKGEsIGIpID0+ICghYiA/IGEgOiBnY2QoYiwgYSAlIGIpKTtcbmNvbnN0IHJhZGl4MmNhcnJ5ID0gKGZyb20sIHRvKSA9PiBmcm9tICsgKHRvIC0gZ2NkKGZyb20sIHRvKSk7XG5mdW5jdGlvbiBjb252ZXJ0UmFkaXgyKGRhdGEsIGZyb20sIHRvLCBwYWRkaW5nKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbnZlcnRSYWRpeDI6IGRhdGEgc2hvdWxkIGJlIGFycmF5Jyk7XG4gICAgaWYgKGZyb20gPD0gMCB8fCBmcm9tID4gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4Mjogd3JvbmcgZnJvbT0ke2Zyb219YCk7XG4gICAgaWYgKHRvIDw9IDAgfHwgdG8gPiAzMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXgyOiB3cm9uZyB0bz0ke3RvfWApO1xuICAgIGlmIChyYWRpeDJjYXJyeShmcm9tLCB0bykgPiAzMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDI6IGNhcnJ5IG92ZXJmbG93IGZyb209JHtmcm9tfSB0bz0ke3RvfSBjYXJyeUJpdHM9JHtyYWRpeDJjYXJyeShmcm9tLCB0byl9YCk7XG4gICAgfVxuICAgIGxldCBjYXJyeSA9IDA7XG4gICAgbGV0IHBvcyA9IDA7XG4gICAgY29uc3QgbWFzayA9IDIgKiogdG8gLSAxO1xuICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgbiBvZiBkYXRhKSB7XG4gICAgICAgIGFzc2VydE51bWJlcihuKTtcbiAgICAgICAgaWYgKG4gPj0gMiAqKiBmcm9tKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXgyOiBpbnZhbGlkIGRhdGEgd29yZD0ke259IGZyb209JHtmcm9tfWApO1xuICAgICAgICBjYXJyeSA9IChjYXJyeSA8PCBmcm9tKSB8IG47XG4gICAgICAgIGlmIChwb3MgKyBmcm9tID4gMzIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDI6IGNhcnJ5IG92ZXJmbG93IHBvcz0ke3Bvc30gZnJvbT0ke2Zyb219YCk7XG4gICAgICAgIHBvcyArPSBmcm9tO1xuICAgICAgICBmb3IgKDsgcG9zID49IHRvOyBwb3MgLT0gdG8pXG4gICAgICAgICAgICByZXMucHVzaCgoKGNhcnJ5ID4+IChwb3MgLSB0bykpICYgbWFzaykgPj4+IDApO1xuICAgICAgICBjYXJyeSAmPSAyICoqIHBvcyAtIDE7XG4gICAgfVxuICAgIGNhcnJ5ID0gKGNhcnJ5IDw8ICh0byAtIHBvcykpICYgbWFzaztcbiAgICBpZiAoIXBhZGRpbmcgJiYgcG9zID49IGZyb20pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhjZXNzIHBhZGRpbmcnKTtcbiAgICBpZiAoIXBhZGRpbmcgJiYgY2FycnkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTm9uLXplcm8gcGFkZGluZzogJHtjYXJyeX1gKTtcbiAgICBpZiAocGFkZGluZyAmJiBwb3MgPiAwKVxuICAgICAgICByZXMucHVzaChjYXJyeSA+Pj4gMCk7XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIHJhZGl4KG51bSkge1xuICAgIGFzc2VydE51bWJlcihudW0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZTogKGJ5dGVzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIShieXRlcyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmFkaXguZW5jb2RlIGlucHV0IHNob3VsZCBiZSBVaW50OEFycmF5Jyk7XG4gICAgICAgICAgICByZXR1cm4gY29udmVydFJhZGl4KEFycmF5LmZyb20oYnl0ZXMpLCAyICoqIDgsIG51bSk7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZTogKGRpZ2l0cykgPT4ge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRpZ2l0cykgfHwgKGRpZ2l0cy5sZW5ndGggJiYgdHlwZW9mIGRpZ2l0c1swXSAhPT0gJ251bWJlcicpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmFkaXguZGVjb2RlIGlucHV0IHNob3VsZCBiZSBhcnJheSBvZiBzdHJpbmdzJyk7XG4gICAgICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGNvbnZlcnRSYWRpeChkaWdpdHMsIG51bSwgMiAqKiA4KSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJhZGl4MihiaXRzLCByZXZQYWRkaW5nID0gZmFsc2UpIHtcbiAgICBhc3NlcnROdW1iZXIoYml0cyk7XG4gICAgaWYgKGJpdHMgPD0gMCB8fCBiaXRzID4gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmFkaXgyOiBiaXRzIHNob3VsZCBiZSBpbiAoMC4uMzJdJyk7XG4gICAgaWYgKHJhZGl4MmNhcnJ5KDgsIGJpdHMpID4gMzIgfHwgcmFkaXgyY2FycnkoYml0cywgOCkgPiAzMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpeDI6IGNhcnJ5IG92ZXJmbG93Jyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlOiAoYnl0ZXMpID0+IHtcbiAgICAgICAgICAgIGlmICghKGJ5dGVzIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpeDIuZW5jb2RlIGlucHV0IHNob3VsZCBiZSBVaW50OEFycmF5Jyk7XG4gICAgICAgICAgICByZXR1cm4gY29udmVydFJhZGl4MihBcnJheS5mcm9tKGJ5dGVzKSwgOCwgYml0cywgIXJldlBhZGRpbmcpO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGU6IChkaWdpdHMpID0+IHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkaWdpdHMpIHx8IChkaWdpdHMubGVuZ3RoICYmIHR5cGVvZiBkaWdpdHNbMF0gIT09ICdudW1iZXInKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4Mi5kZWNvZGUgaW5wdXQgc2hvdWxkIGJlIGFycmF5IG9mIHN0cmluZ3MnKTtcbiAgICAgICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oY29udmVydFJhZGl4MihkaWdpdHMsIGJpdHMsIDgsIHJldlBhZGRpbmcpKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gdW5zYWZlV3JhcHBlcihmbikge1xuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5zYWZlV3JhcHBlciBmbiBzaG91bGQgYmUgZnVuY3Rpb24nKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNoZWNrc3VtKGxlbiwgZm4pIHtcbiAgICBhc3NlcnROdW1iZXIobGVuKTtcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NoZWNrc3VtIGZuIHNob3VsZCBiZSBmdW5jdGlvbicpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZShkYXRhKSB7XG4gICAgICAgICAgICBpZiAoIShkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjaGVja3N1bS5lbmNvZGU6IGlucHV0IHNob3VsZCBiZSBVaW50OEFycmF5Jyk7XG4gICAgICAgICAgICBjb25zdCBjaGVja3N1bSA9IGZuKGRhdGEpLnNsaWNlKDAsIGxlbik7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheShkYXRhLmxlbmd0aCArIGxlbik7XG4gICAgICAgICAgICByZXMuc2V0KGRhdGEpO1xuICAgICAgICAgICAgcmVzLnNldChjaGVja3N1bSwgZGF0YS5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlKGRhdGEpIHtcbiAgICAgICAgICAgIGlmICghKGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NoZWNrc3VtLmRlY29kZTogaW5wdXQgc2hvdWxkIGJlIFVpbnQ4QXJyYXknKTtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBkYXRhLnNsaWNlKDAsIC1sZW4pO1xuICAgICAgICAgICAgY29uc3QgbmV3Q2hlY2tzdW0gPSBmbihwYXlsb2FkKS5zbGljZSgwLCBsZW4pO1xuICAgICAgICAgICAgY29uc3Qgb2xkQ2hlY2tzdW0gPSBkYXRhLnNsaWNlKC1sZW4pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgICAgICAgICAgICBpZiAobmV3Q2hlY2tzdW1baV0gIT09IG9sZENoZWNrc3VtW2ldKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY2hlY2tzdW0nKTtcbiAgICAgICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgICB9LFxuICAgIH07XG59XG5leHBvcnRzLnV0aWxzID0geyBhbHBoYWJldCwgY2hhaW4sIGNoZWNrc3VtLCByYWRpeCwgcmFkaXgyLCBqb2luLCBwYWRkaW5nIH07XG5leHBvcnRzLmJhc2UxNiA9IGNoYWluKHJhZGl4Mig0KSwgYWxwaGFiZXQoJzAxMjM0NTY3ODlBQkNERUYnKSwgam9pbignJykpO1xuZXhwb3J0cy5iYXNlMzIgPSBjaGFpbihyYWRpeDIoNSksIGFscGhhYmV0KCdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjIzNDU2NycpLCBwYWRkaW5nKDUpLCBqb2luKCcnKSk7XG5leHBvcnRzLmJhc2UzMmhleCA9IGNoYWluKHJhZGl4Mig1KSwgYWxwaGFiZXQoJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWJyksIHBhZGRpbmcoNSksIGpvaW4oJycpKTtcbmV4cG9ydHMuYmFzZTMyY3JvY2tmb3JkID0gY2hhaW4ocmFkaXgyKDUpLCBhbHBoYWJldCgnMDEyMzQ1Njc4OUFCQ0RFRkdISktNTlBRUlNUVldYWVonKSwgam9pbignJyksIG5vcm1hbGl6ZSgocykgPT4gcy50b1VwcGVyQ2FzZSgpLnJlcGxhY2UoL08vZywgJzAnKS5yZXBsYWNlKC9bSUxdL2csICcxJykpKTtcbmV4cG9ydHMuYmFzZTY0ID0gY2hhaW4ocmFkaXgyKDYpLCBhbHBoYWJldCgnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLycpLCBwYWRkaW5nKDYpLCBqb2luKCcnKSk7XG5leHBvcnRzLmJhc2U2NHVybCA9IGNoYWluKHJhZGl4Mig2KSwgYWxwaGFiZXQoJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5LV8nKSwgcGFkZGluZyg2KSwgam9pbignJykpO1xuY29uc3QgZ2VuQmFzZTU4ID0gKGFiYykgPT4gY2hhaW4ocmFkaXgoNTgpLCBhbHBoYWJldChhYmMpLCBqb2luKCcnKSk7XG5leHBvcnRzLmJhc2U1OCA9IGdlbkJhc2U1OCgnMTIzNDU2Nzg5QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaYWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5eicpO1xuZXhwb3J0cy5iYXNlNThmbGlja3IgPSBnZW5CYXNlNTgoJzEyMzQ1Njc4OWFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXpBQkNERUZHSEpLTE1OUFFSU1RVVldYWVonKTtcbmV4cG9ydHMuYmFzZTU4eHJwID0gZ2VuQmFzZTU4KCdycHNobmFmMzl3QlVETkVHSEpLTE00UFFSU1Q3VldYWVoyYmNkZUNnNjVqa204b0ZxaTF0dXZBeHl6Jyk7XG5jb25zdCBYTVJfQkxPQ0tfTEVOID0gWzAsIDIsIDMsIDUsIDYsIDcsIDksIDEwLCAxMV07XG5leHBvcnRzLmJhc2U1OHhtciA9IHtcbiAgICBlbmNvZGUoZGF0YSkge1xuICAgICAgICBsZXQgcmVzID0gJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gOCkge1xuICAgICAgICAgICAgY29uc3QgYmxvY2sgPSBkYXRhLnN1YmFycmF5KGksIGkgKyA4KTtcbiAgICAgICAgICAgIHJlcyArPSBleHBvcnRzLmJhc2U1OC5lbmNvZGUoYmxvY2spLnBhZFN0YXJ0KFhNUl9CTE9DS19MRU5bYmxvY2subGVuZ3RoXSwgJzEnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0sXG4gICAgZGVjb2RlKHN0cikge1xuICAgICAgICBsZXQgcmVzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSArPSAxMSkge1xuICAgICAgICAgICAgY29uc3Qgc2xpY2UgPSBzdHIuc2xpY2UoaSwgaSArIDExKTtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrTGVuID0gWE1SX0JMT0NLX0xFTi5pbmRleE9mKHNsaWNlLmxlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCBibG9jayA9IGV4cG9ydHMuYmFzZTU4LmRlY29kZShzbGljZSk7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGJsb2NrLmxlbmd0aCAtIGJsb2NrTGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2tbal0gIT09IDApXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFzZTU4eG1yOiB3cm9uZyBwYWRkaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXMgPSByZXMuY29uY2F0KEFycmF5LmZyb20oYmxvY2suc2xpY2UoYmxvY2subGVuZ3RoIC0gYmxvY2tMZW4pKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShyZXMpO1xuICAgIH0sXG59O1xuY29uc3QgYmFzZTU4Y2hlY2sgPSAoc2hhMjU2KSA9PiBjaGFpbihjaGVja3N1bSg0LCAoZGF0YSkgPT4gc2hhMjU2KHNoYTI1NihkYXRhKSkpLCBleHBvcnRzLmJhc2U1OCk7XG5leHBvcnRzLmJhc2U1OGNoZWNrID0gYmFzZTU4Y2hlY2s7XG5jb25zdCBCRUNIX0FMUEhBQkVUID0gY2hhaW4oYWxwaGFiZXQoJ3FwenJ5OXg4Z2YydHZkdzBzM2puNTRraGNlNm11YTdsJyksIGpvaW4oJycpKTtcbmNvbnN0IFBPTFlNT0RfR0VORVJBVE9SUyA9IFsweDNiNmE1N2IyLCAweDI2NTA4ZTZkLCAweDFlYTExOWZhLCAweDNkNDIzM2RkLCAweDJhMTQ2MmIzXTtcbmZ1bmN0aW9uIGJlY2gzMlBvbHltb2QocHJlKSB7XG4gICAgY29uc3QgYiA9IHByZSA+PiAyNTtcbiAgICBsZXQgY2hrID0gKHByZSAmIDB4MWZmZmZmZikgPDwgNTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IFBPTFlNT0RfR0VORVJBVE9SUy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoKChiID4+IGkpICYgMSkgPT09IDEpXG4gICAgICAgICAgICBjaGsgXj0gUE9MWU1PRF9HRU5FUkFUT1JTW2ldO1xuICAgIH1cbiAgICByZXR1cm4gY2hrO1xufVxuZnVuY3Rpb24gYmVjaENoZWNrc3VtKHByZWZpeCwgd29yZHMsIGVuY29kaW5nQ29uc3QgPSAxKSB7XG4gICAgY29uc3QgbGVuID0gcHJlZml4Lmxlbmd0aDtcbiAgICBsZXQgY2hrID0gMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGMgPSBwcmVmaXguY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPCAzMyB8fCBjID4gMTI2KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHByZWZpeCAoJHtwcmVmaXh9KWApO1xuICAgICAgICBjaGsgPSBiZWNoMzJQb2x5bW9kKGNoaykgXiAoYyA+PiA1KTtcbiAgICB9XG4gICAgY2hrID0gYmVjaDMyUG9seW1vZChjaGspO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKSBeIChwcmVmaXguY2hhckNvZGVBdChpKSAmIDB4MWYpO1xuICAgIGZvciAobGV0IHYgb2Ygd29yZHMpXG4gICAgICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKSBeIHY7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspXG4gICAgICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKTtcbiAgICBjaGsgXj0gZW5jb2RpbmdDb25zdDtcbiAgICByZXR1cm4gQkVDSF9BTFBIQUJFVC5lbmNvZGUoY29udmVydFJhZGl4MihbY2hrICUgMiAqKiAzMF0sIDMwLCA1LCBmYWxzZSkpO1xufVxuZnVuY3Rpb24gZ2VuQmVjaDMyKGVuY29kaW5nKSB7XG4gICAgY29uc3QgRU5DT0RJTkdfQ09OU1QgPSBlbmNvZGluZyA9PT0gJ2JlY2gzMicgPyAxIDogMHgyYmM4MzBhMztcbiAgICBjb25zdCBfd29yZHMgPSByYWRpeDIoNSk7XG4gICAgY29uc3QgZnJvbVdvcmRzID0gX3dvcmRzLmRlY29kZTtcbiAgICBjb25zdCB0b1dvcmRzID0gX3dvcmRzLmVuY29kZTtcbiAgICBjb25zdCBmcm9tV29yZHNVbnNhZmUgPSB1bnNhZmVXcmFwcGVyKGZyb21Xb3Jkcyk7XG4gICAgZnVuY3Rpb24gZW5jb2RlKHByZWZpeCwgd29yZHMsIGxpbWl0ID0gOTApIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwcmVmaXggIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBiZWNoMzIuZW5jb2RlIHByZWZpeCBzaG91bGQgYmUgc3RyaW5nLCBub3QgJHt0eXBlb2YgcHJlZml4fWApO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkod29yZHMpIHx8ICh3b3Jkcy5sZW5ndGggJiYgdHlwZW9mIHdvcmRzWzBdICE9PSAnbnVtYmVyJykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJlY2gzMi5lbmNvZGUgd29yZHMgc2hvdWxkIGJlIGFycmF5IG9mIG51bWJlcnMsIG5vdCAke3R5cGVvZiB3b3Jkc31gKTtcbiAgICAgICAgY29uc3QgYWN0dWFsTGVuZ3RoID0gcHJlZml4Lmxlbmd0aCArIDcgKyB3b3Jkcy5sZW5ndGg7XG4gICAgICAgIGlmIChsaW1pdCAhPT0gZmFsc2UgJiYgYWN0dWFsTGVuZ3RoID4gbGltaXQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBMZW5ndGggJHthY3R1YWxMZW5ndGh9IGV4Y2VlZHMgbGltaXQgJHtsaW1pdH1gKTtcbiAgICAgICAgcHJlZml4ID0gcHJlZml4LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiBgJHtwcmVmaXh9MSR7QkVDSF9BTFBIQUJFVC5lbmNvZGUod29yZHMpfSR7YmVjaENoZWNrc3VtKHByZWZpeCwgd29yZHMsIEVOQ09ESU5HX0NPTlNUKX1gO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWNvZGUoc3RyLCBsaW1pdCA9IDkwKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYmVjaDMyLmRlY29kZSBpbnB1dCBzaG91bGQgYmUgc3RyaW5nLCBub3QgJHt0eXBlb2Ygc3RyfWApO1xuICAgICAgICBpZiAoc3RyLmxlbmd0aCA8IDggfHwgKGxpbWl0ICE9PSBmYWxzZSAmJiBzdHIubGVuZ3RoID4gbGltaXQpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgV3Jvbmcgc3RyaW5nIGxlbmd0aDogJHtzdHIubGVuZ3RofSAoJHtzdHJ9KS4gRXhwZWN0ZWQgKDguLiR7bGltaXR9KWApO1xuICAgICAgICBjb25zdCBsb3dlcmVkID0gc3RyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChzdHIgIT09IGxvd2VyZWQgJiYgc3RyICE9PSBzdHIudG9VcHBlckNhc2UoKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU3RyaW5nIG11c3QgYmUgbG93ZXJjYXNlIG9yIHVwcGVyY2FzZWApO1xuICAgICAgICBzdHIgPSBsb3dlcmVkO1xuICAgICAgICBjb25zdCBzZXBJbmRleCA9IHN0ci5sYXN0SW5kZXhPZignMScpO1xuICAgICAgICBpZiAoc2VwSW5kZXggPT09IDAgfHwgc2VwSW5kZXggPT09IC0xKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMZXR0ZXIgXCIxXCIgbXVzdCBiZSBwcmVzZW50IGJldHdlZW4gcHJlZml4IGFuZCBkYXRhIG9ubHlgKTtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gc3RyLnNsaWNlKDAsIHNlcEluZGV4KTtcbiAgICAgICAgY29uc3QgX3dvcmRzID0gc3RyLnNsaWNlKHNlcEluZGV4ICsgMSk7XG4gICAgICAgIGlmIChfd29yZHMubGVuZ3RoIDwgNilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGF0YSBtdXN0IGJlIGF0IGxlYXN0IDYgY2hhcmFjdGVycyBsb25nJyk7XG4gICAgICAgIGNvbnN0IHdvcmRzID0gQkVDSF9BTFBIQUJFVC5kZWNvZGUoX3dvcmRzKS5zbGljZSgwLCAtNik7XG4gICAgICAgIGNvbnN0IHN1bSA9IGJlY2hDaGVja3N1bShwcmVmaXgsIHdvcmRzLCBFTkNPRElOR19DT05TVCk7XG4gICAgICAgIGlmICghX3dvcmRzLmVuZHNXaXRoKHN1bSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY2hlY2tzdW0gaW4gJHtzdHJ9OiBleHBlY3RlZCBcIiR7c3VtfVwiYCk7XG4gICAgICAgIHJldHVybiB7IHByZWZpeCwgd29yZHMgfTtcbiAgICB9XG4gICAgY29uc3QgZGVjb2RlVW5zYWZlID0gdW5zYWZlV3JhcHBlcihkZWNvZGUpO1xuICAgIGZ1bmN0aW9uIGRlY29kZVRvQnl0ZXMoc3RyKSB7XG4gICAgICAgIGNvbnN0IHsgcHJlZml4LCB3b3JkcyB9ID0gZGVjb2RlKHN0ciwgZmFsc2UpO1xuICAgICAgICByZXR1cm4geyBwcmVmaXgsIHdvcmRzLCBieXRlczogZnJvbVdvcmRzKHdvcmRzKSB9O1xuICAgIH1cbiAgICByZXR1cm4geyBlbmNvZGUsIGRlY29kZSwgZGVjb2RlVG9CeXRlcywgZGVjb2RlVW5zYWZlLCBmcm9tV29yZHMsIGZyb21Xb3Jkc1Vuc2FmZSwgdG9Xb3JkcyB9O1xufVxuZXhwb3J0cy5iZWNoMzIgPSBnZW5CZWNoMzIoJ2JlY2gzMicpO1xuZXhwb3J0cy5iZWNoMzJtID0gZ2VuQmVjaDMyKCdiZWNoMzJtJyk7XG5leHBvcnRzLnV0ZjggPSB7XG4gICAgZW5jb2RlOiAoZGF0YSkgPT4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGRhdGEpLFxuICAgIGRlY29kZTogKHN0cikgPT4gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0ciksXG59O1xuZXhwb3J0cy5oZXggPSBjaGFpbihyYWRpeDIoNCksIGFscGhhYmV0KCcwMTIzNDU2Nzg5YWJjZGVmJyksIGpvaW4oJycpLCBub3JtYWxpemUoKHMpID0+IHtcbiAgICBpZiAodHlwZW9mIHMgIT09ICdzdHJpbmcnIHx8IHMubGVuZ3RoICUgMilcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgaGV4LmRlY29kZTogZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygc30gd2l0aCBsZW5ndGggJHtzLmxlbmd0aH1gKTtcbiAgICByZXR1cm4gcy50b0xvd2VyQ2FzZSgpO1xufSkpO1xuY29uc3QgQ09ERVJTID0ge1xuICAgIHV0Zjg6IGV4cG9ydHMudXRmOCwgaGV4OiBleHBvcnRzLmhleCwgYmFzZTE2OiBleHBvcnRzLmJhc2UxNiwgYmFzZTMyOiBleHBvcnRzLmJhc2UzMiwgYmFzZTY0OiBleHBvcnRzLmJhc2U2NCwgYmFzZTY0dXJsOiBleHBvcnRzLmJhc2U2NHVybCwgYmFzZTU4OiBleHBvcnRzLmJhc2U1OCwgYmFzZTU4eG1yOiBleHBvcnRzLmJhc2U1OHhtclxufTtcbmNvbnN0IGNvZGVyVHlwZUVycm9yID0gYEludmFsaWQgZW5jb2RpbmcgdHlwZS4gQXZhaWxhYmxlIHR5cGVzOiAke09iamVjdC5rZXlzKENPREVSUykuam9pbignLCAnKX1gO1xuY29uc3QgYnl0ZXNUb1N0cmluZyA9ICh0eXBlLCBieXRlcykgPT4ge1xuICAgIGlmICh0eXBlb2YgdHlwZSAhPT0gJ3N0cmluZycgfHwgIUNPREVSUy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihjb2RlclR5cGVFcnJvcik7XG4gICAgaWYgKCEoYnl0ZXMgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYnl0ZXNUb1N0cmluZygpIGV4cGVjdHMgVWludDhBcnJheScpO1xuICAgIHJldHVybiBDT0RFUlNbdHlwZV0uZW5jb2RlKGJ5dGVzKTtcbn07XG5leHBvcnRzLmJ5dGVzVG9TdHJpbmcgPSBieXRlc1RvU3RyaW5nO1xuZXhwb3J0cy5zdHIgPSBleHBvcnRzLmJ5dGVzVG9TdHJpbmc7XG5jb25zdCBzdHJpbmdUb0J5dGVzID0gKHR5cGUsIHN0cikgPT4ge1xuICAgIGlmICghQ09ERVJTLmhhc093blByb3BlcnR5KHR5cGUpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGNvZGVyVHlwZUVycm9yKTtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3N0cmluZ1RvQnl0ZXMoKSBleHBlY3RzIHN0cmluZycpO1xuICAgIHJldHVybiBDT0RFUlNbdHlwZV0uZGVjb2RlKHN0cik7XG59O1xuZXhwb3J0cy5zdHJpbmdUb0J5dGVzID0gc3RyaW5nVG9CeXRlcztcbmV4cG9ydHMuYnl0ZXMgPSBleHBvcnRzLnN0cmluZ1RvQnl0ZXM7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/light-bolt11-decoder/node_modules/@scure/base/lib/index.js\n");

/***/ })

};
;