"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/typescript-lru-cache";
exports.ids = ["vendor-chunks/typescript-lru-cache"];
exports.modules = {

/***/ "(ssr)/./node_modules/typescript-lru-cache/dist/LRUCache.js":
/*!************************************************************!*\
  !*** ./node_modules/typescript-lru-cache/dist/LRUCache.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.LRUCache = void 0;\r\nconst LRUCacheNode_1 = __webpack_require__(/*! ./LRUCacheNode */ \"(ssr)/./node_modules/typescript-lru-cache/dist/LRUCacheNode.js\");\r\n/**\r\n * A key value cache that implements the LRU policy.\r\n *\r\n * @typeparam TKey The type of the keys in the cache. Defaults to `string`.\r\n * @typeparam TValue The type of the values in the cache. Defaults to `any`.\r\n *\r\n * @see {@link https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)}\r\n */\r\nclass LRUCache {\r\n    /**\r\n     * Creates a new instance of the LRUCache.\r\n     *\r\n     * @param options Additional configuration options for the LRUCache.\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * // No options.\r\n     * const cache = new LRUCache();\r\n     *\r\n     * // With options.\r\n     * const cache = new LRUCache({\r\n     *  entryExpirationTimeInMS: 10000\r\n     * });\r\n     * ```\r\n     */\r\n    constructor(options) {\r\n        this.lookupTable = new Map();\r\n        this.head = null;\r\n        this.tail = null;\r\n        const { maxSize = 25, entryExpirationTimeInMS = null, onEntryEvicted, onEntryMarkedAsMostRecentlyUsed, cloneFn, clone } = options !== null && options !== void 0 ? options : {};\r\n        if (Number.isNaN(maxSize) || maxSize <= 0) {\r\n            throw new Error('maxSize must be greater than 0.');\r\n        }\r\n        if (typeof entryExpirationTimeInMS === 'number' &&\r\n            (entryExpirationTimeInMS <= 0 || Number.isNaN(entryExpirationTimeInMS))) {\r\n            throw new Error('entryExpirationTimeInMS must either be null (no expiry) or greater than 0');\r\n        }\r\n        this.maxSizeInternal = maxSize;\r\n        this.entryExpirationTimeInMS = entryExpirationTimeInMS;\r\n        this.onEntryEvicted = onEntryEvicted;\r\n        this.onEntryMarkedAsMostRecentlyUsed = onEntryMarkedAsMostRecentlyUsed;\r\n        this.clone = clone;\r\n        this.cloneFn = cloneFn;\r\n    }\r\n    /**\r\n     * Returns the number of entries in the LRUCache object.\r\n     * If the cache has entryExpirationTimeInMS set, expired entries will be removed before the size is returned.\r\n     *\r\n     * @returns The number of entries in the cache.\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * const cache = new LRUCache();\r\n     *\r\n     * cache.set('testKey', 'testValue');\r\n     *\r\n     * const size = cache.size;\r\n     *\r\n     * // Will log 1\r\n     * console.log(size);\r\n     * ```\r\n     */\r\n    get size() {\r\n        this.cleanCache();\r\n        return this.lookupTable.size;\r\n    }\r\n    /**\r\n     * Returns the number of entries that can still be added to the LRUCache without evicting existing entries.\r\n     *\r\n     * @returns The number of entries that can still be added without evicting existing entries.\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * const cache = new LRUCache({ maxSize: 10 });\r\n     *\r\n     * cache.set('testKey', 'testValue');\r\n     *\r\n     * const remainingSize = cache.remainingSize;\r\n     *\r\n     * // Will log 9 due to 9 spots remaining before reaching maxSize of 10.\r\n     * console.log(remainingSize);\r\n     * ```\r\n     */\r\n    get remainingSize() {\r\n        return this.maxSizeInternal - this.size;\r\n    }\r\n    /**\r\n     * Returns the most recently used (newest) entry in the cache.\r\n     * This will not mark the entry as recently used.\r\n     * If the newest node is expired, it will be removed.\r\n     *\r\n     * @returns The most recently used (newest) entry in the cache.\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * const cache = new LRUCache({ maxSize: 10 });\r\n     *\r\n     * cache.set('testKey', 'testValue');\r\n     *\r\n     * const newest = cache.newest;\r\n     *\r\n     * // Will log testValue\r\n     * console.log(newest.value);\r\n     *\r\n     * // Will log testKey\r\n     * console.log(newest.key);\r\n     * ```\r\n     */\r\n    get newest() {\r\n        if (!this.head) {\r\n            return null;\r\n        }\r\n        if (this.head.isExpired) {\r\n            this.removeNodeFromListAndLookupTable(this.head);\r\n            return this.newest;\r\n        }\r\n        return this.mapNodeToEntry(this.head);\r\n    }\r\n    /**\r\n     * Returns the least recently used (oldest) entry in the cache.\r\n     * This will not mark the entry as recently used.\r\n     * If the oldest node is expired, it will be removed.\r\n     *\r\n     * @returns The least recently used (oldest) entry in the cache.\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * const cache = new LRUCache({ maxSize: 10 });\r\n     *\r\n     * cache.set('testKey', 'testValue');\r\n     *\r\n     * const oldest = cache.oldest;\r\n     *\r\n     * // Will log testValue\r\n     * console.log(oldest.value);\r\n     *\r\n     * // Will log testKey\r\n     * console.log(oldest.key);\r\n     * ```\r\n     */\r\n    get oldest() {\r\n        if (!this.tail) {\r\n            return null;\r\n        }\r\n        if (this.tail.isExpired) {\r\n            this.removeNodeFromListAndLookupTable(this.tail);\r\n            return this.oldest;\r\n        }\r\n        return this.mapNodeToEntry(this.tail);\r\n    }\r\n    /**\r\n     * Gets or sets the maxSize of the cache.\r\n     * This will evict the least recently used entries if needed to reach new maxSize.\r\n     *\r\n     * @param value The new value for maxSize. Must be greater than 0.\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * const cache = new LRUCache({ maxSize: 10 });\r\n     *\r\n     * cache.set('testKey', 'testValue');\r\n     *\r\n     * // Will be 10\r\n     * const maxSize = cache.maxSize;\r\n     *\r\n     * // Set new maxSize to 5. If there are more than 5 items in the cache, the least recently used entries will be removed until cache size is 5.\r\n     * cache.maxSize = 5;\r\n     * ```\r\n     */\r\n    get maxSize() {\r\n        return this.maxSizeInternal;\r\n    }\r\n    set maxSize(value) {\r\n        if (Number.isNaN(value) || value <= 0) {\r\n            throw new Error('maxSize must be greater than 0.');\r\n        }\r\n        this.maxSizeInternal = value;\r\n        this.enforceSizeLimit();\r\n    }\r\n    /**\r\n     * Sets the value for the key in the LRUCache object. Returns the LRUCache object.\r\n     * This marks the newly added entry as the most recently used entry.\r\n     * If adding the new entry makes the cache size go above maxSize,\r\n     * this will evict the least recently used entries until size is equal to maxSize.\r\n     *\r\n     * @param key The key of the entry.\r\n     * @param value The value to set for the key.\r\n     * @param entryOptions Additional configuration options for the cache entry.\r\n     *\r\n     * @returns The LRUCache instance.\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * const cache = new LRUCache();\r\n     *\r\n     * // Set the key testKey to value testValue\r\n     * cache.set('testKey', 'testValue');\r\n     *\r\n     * // Set the key key2 to value value2. Pass in optional options.\r\n     * cache.set('key2', 'value2', { entryExpirationTimeInMS: 10 });\r\n     * ```\r\n     */\r\n    set(key, value, entryOptions) {\r\n        const currentNodeForKey = this.lookupTable.get(key);\r\n        if (currentNodeForKey) {\r\n            this.removeNodeFromListAndLookupTable(currentNodeForKey);\r\n        }\r\n        const node = new LRUCacheNode_1.LRUCacheNode(key, value, {\r\n            entryExpirationTimeInMS: this.entryExpirationTimeInMS,\r\n            onEntryEvicted: this.onEntryEvicted,\r\n            onEntryMarkedAsMostRecentlyUsed: this.onEntryMarkedAsMostRecentlyUsed,\r\n            clone: this.clone,\r\n            cloneFn: this.cloneFn,\r\n            ...entryOptions\r\n        });\r\n        this.setNodeAsHead(node);\r\n        this.lookupTable.set(key, node);\r\n        this.enforceSizeLimit();\r\n        return this;\r\n    }\r\n    /**\r\n     * Returns the value associated to the key, or null if there is none or if the entry is expired.\r\n     * If an entry is returned, this marks the returned entry as the most recently used entry.\r\n     *\r\n     * @param key The key of the entry to get.\r\n     *\r\n     * @returns The cached value or null.\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * const cache = new LRUCache();\r\n     *\r\n     * // Set the key testKey to value testValue\r\n     * cache.set('testKey', 'testValue');\r\n     *\r\n     * // Will be 'testValue'. Entry will now be most recently used.\r\n     * const item1 = cache.get('testKey');\r\n     *\r\n     * // Will be null\r\n     * const item2 = cache.get('keyNotInCache');\r\n     * ```\r\n     */\r\n    get(key) {\r\n        const node = this.lookupTable.get(key);\r\n        if (!node) {\r\n            return null;\r\n        }\r\n        if (node.isExpired) {\r\n            this.removeNodeFromListAndLookupTable(node);\r\n            return null;\r\n        }\r\n        this.setNodeAsHead(node);\r\n        return node.value;\r\n    }\r\n    /**\r\n     * Returns the value associated to the key, or null if there is none or if the entry is expired.\r\n     * If an entry is returned, this will not mark the entry as most recently accessed.\r\n     * Useful if a value is needed but the order of the cache should not be changed.\r\n     *\r\n     * @param key The key of the entry to get.\r\n     *\r\n     * @returns The cached value or null.\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * const cache = new LRUCache();\r\n     *\r\n     * // Set the key testKey to value testValue\r\n     * cache.set('testKey', 'testValue');\r\n     *\r\n     * // Will be 'testValue'\r\n     * const item1 = cache.peek('testKey');\r\n     *\r\n     * // Will be null\r\n     * const item2 = cache.peek('keyNotInCache');\r\n     * ```\r\n     */\r\n    peek(key) {\r\n        const node = this.lookupTable.get(key);\r\n        if (!node) {\r\n            return null;\r\n        }\r\n        if (node.isExpired) {\r\n            this.removeNodeFromListAndLookupTable(node);\r\n            return null;\r\n        }\r\n        return node.value;\r\n    }\r\n    /**\r\n     * Deletes the entry for the passed in key.\r\n     *\r\n     * @param key The key of the entry to delete\r\n     *\r\n     * @returns True if an element in the LRUCache object existed and has been removed,\r\n     * or false if the element does not exist.\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * const cache = new LRUCache();\r\n     *\r\n     * // Set the key testKey to value testValue\r\n     * cache.set('testKey', 'testValue');\r\n     *\r\n     * // Will be true\r\n     * const wasDeleted = cache.delete('testKey');\r\n     *\r\n     * // Will be false\r\n     * const wasDeleted2 = cache.delete('keyNotInCache');\r\n     * ```\r\n     */\r\n    delete(key) {\r\n        const node = this.lookupTable.get(key);\r\n        if (!node) {\r\n            return false;\r\n        }\r\n        return this.removeNodeFromListAndLookupTable(node);\r\n    }\r\n    /**\r\n     * Returns a boolean asserting whether a value has been associated to the key in the LRUCache object or not.\r\n     * This does not mark the entry as recently used.\r\n     * If the cache has a key but the entry is expired, it will be removed and false will be returned.\r\n     *\r\n     * @param key The key of the entry to check if exists\r\n     *\r\n     * @returns true if the cache contains the supplied key. False if not.\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * const cache = new LRUCache();\r\n     *\r\n     * // Set the key testKey to value testValue\r\n     * cache.set('testKey', 'testValue');\r\n     *\r\n     * // Will be true\r\n     * const wasDeleted = cache.has('testKey');\r\n     *\r\n     * // Will be false\r\n     * const wasDeleted2 = cache.has('keyNotInCache');\r\n     * ```\r\n     */\r\n    has(key) {\r\n        const node = this.lookupTable.get(key);\r\n        if (!node) {\r\n            return false;\r\n        }\r\n        if (node.isExpired) {\r\n            this.removeNodeFromListAndLookupTable(node);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * Removes all entries in the cache.\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * const cache = new LRUCache();\r\n     *\r\n     * // Set the key testKey to value testValue\r\n     * cache.set('testKey', 'testValue');\r\n     *\r\n     * // Clear cache.\r\n     * cache.clear();\r\n     * ```\r\n     */\r\n    clear() {\r\n        this.head = null;\r\n        this.tail = null;\r\n        this.lookupTable.clear();\r\n    }\r\n    /**\r\n     * Searches the cache for an entry matching the passed in condition.\r\n     * Expired entries will be skipped (and removed).\r\n     * If multiply entries in the cache match the condition, the most recently used entry will be returned.\r\n     * If an entry is returned, this marks the returned entry as the most recently used entry.\r\n     *\r\n     * @param condition The condition to apply to each entry in the\r\n     *\r\n     * @returns The first cache entry to match the condition. Null if none match.\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * const cache = new LRUCache();\r\n     *\r\n     * // Set the key testKey to value testValue\r\n     * cache.set('testKey', 'testValue');\r\n     *\r\n     * // item will be { key: 'testKey', value: 'testValue }\r\n     * const item = cache.find(entry => {\r\n     *   const { key, value } = entry;\r\n     *\r\n     *   if (key === 'testKey' || value === 'something') {\r\n     *     return true;\r\n     *   }\r\n     *\r\n     *   return false;\r\n     * });\r\n     *\r\n     * // item2 will be null\r\n     * const item2 = cache.find(entry => entry.key === 'notInCache');\r\n     * ```\r\n     */\r\n    find(condition) {\r\n        let node = this.head;\r\n        while (node) {\r\n            if (node.isExpired) {\r\n                const next = node.next;\r\n                this.removeNodeFromListAndLookupTable(node);\r\n                node = next;\r\n                continue;\r\n            }\r\n            const entry = this.mapNodeToEntry(node);\r\n            if (condition(entry)) {\r\n                this.setNodeAsHead(node);\r\n                return entry;\r\n            }\r\n            node = node.next;\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Iterates over and applies the callback function to each entry in the cache.\r\n     * Iterates in order from most recently accessed entry to least recently.\r\n     * Expired entries will be skipped (and removed).\r\n     * No entry will be marked as recently used.\r\n     *\r\n     * @param callback the callback function to apply to the entry\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * const cache = new LRUCache();\r\n     *\r\n     * // Set the key testKey to value testValue\r\n     * cache.set('testKey', 'testValue');\r\n     *\r\n     * cache.forEach((key, value, index) => {\r\n     *   // do something with key, value, and/or index\r\n     * });\r\n     * ```\r\n     */\r\n    forEach(callback) {\r\n        let node = this.head;\r\n        let index = 0;\r\n        while (node) {\r\n            if (node.isExpired) {\r\n                const next = node.next;\r\n                this.removeNodeFromListAndLookupTable(node);\r\n                node = next;\r\n                continue;\r\n            }\r\n            callback(node.value, node.key, index);\r\n            node = node.next;\r\n            index++;\r\n        }\r\n    }\r\n    /**\r\n     * Creates a Generator which can be used with for ... of ... to iterate over the cache values.\r\n     * Iterates in order from most recently accessed entry to least recently.\r\n     * Expired entries will be skipped (and removed).\r\n     * No entry will be marked as accessed.\r\n     *\r\n     * @returns A Generator for the cache values.\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * const cache = new LRUCache();\r\n     *\r\n     * // Set the key testKey to value testValue\r\n     * cache.set('testKey', 'testValue');\r\n     *\r\n     * for (const value of cache.values()) {\r\n     *   // do something with the value\r\n     * }\r\n     * ```\r\n     */\r\n    *values() {\r\n        let node = this.head;\r\n        while (node) {\r\n            if (node.isExpired) {\r\n                const next = node.next;\r\n                this.removeNodeFromListAndLookupTable(node);\r\n                node = next;\r\n                continue;\r\n            }\r\n            yield node.value;\r\n            node = node.next;\r\n        }\r\n    }\r\n    /**\r\n     * Creates a Generator which can be used with for ... of ... to iterate over the cache keys.\r\n     * Iterates in order from most recently accessed entry to least recently.\r\n     * Expired entries will be skipped (and removed).\r\n     * No entry will be marked as accessed.\r\n     *\r\n     * @returns A Generator for the cache keys.\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * const cache = new LRUCache();\r\n     *\r\n     * // Set the key testKey to value testValue\r\n     * cache.set('testKey', 'testValue');\r\n     *\r\n     * for (const key of cache.keys()) {\r\n     *   // do something with the key\r\n     * }\r\n     * ```\r\n     */\r\n    *keys() {\r\n        let node = this.head;\r\n        while (node) {\r\n            if (node.isExpired) {\r\n                const next = node.next;\r\n                this.removeNodeFromListAndLookupTable(node);\r\n                node = next;\r\n                continue;\r\n            }\r\n            yield node.key;\r\n            node = node.next;\r\n        }\r\n    }\r\n    /**\r\n     * Creates a Generator which can be used with for ... of ... to iterate over the cache entries.\r\n     * Iterates in order from most recently accessed entry to least recently.\r\n     * Expired entries will be skipped (and removed).\r\n     * No entry will be marked as accessed.\r\n     *\r\n     * @returns A Generator for the cache entries.\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * const cache = new LRUCache();\r\n     *\r\n     * // Set the key testKey to value testValue\r\n     * cache.set('testKey', 'testValue');\r\n     *\r\n     * for (const entry of cache.entries()) {\r\n     *   const { key, value } = entry;\r\n     *   // do something with the entry\r\n     * }\r\n     * ```\r\n     */\r\n    *entries() {\r\n        let node = this.head;\r\n        while (node) {\r\n            if (node.isExpired) {\r\n                const next = node.next;\r\n                this.removeNodeFromListAndLookupTable(node);\r\n                node = next;\r\n                continue;\r\n            }\r\n            yield this.mapNodeToEntry(node);\r\n            node = node.next;\r\n        }\r\n    }\r\n    /**\r\n     * Creates a Generator which can be used with for ... of ... to iterate over the cache entries.\r\n     * Iterates in order from most recently accessed entry to least recently.\r\n     * Expired entries will be skipped (and removed).\r\n     * No entry will be marked as accessed.\r\n     *\r\n     * @returns A Generator for the cache entries.\r\n     *\r\n     * @example\r\n     * ```typescript\r\n     * const cache = new LRUCache();\r\n     *\r\n     * // Set the key testKey to value testValue\r\n     * cache.set('testKey', 'testValue');\r\n     *\r\n     * for (const entry of cache) {\r\n     *   const { key, value } = entry;\r\n     *   // do something with the entry\r\n     * }\r\n     * ```\r\n     */\r\n    *[Symbol.iterator]() {\r\n        let node = this.head;\r\n        while (node) {\r\n            if (node.isExpired) {\r\n                const next = node.next;\r\n                this.removeNodeFromListAndLookupTable(node);\r\n                node = next;\r\n                continue;\r\n            }\r\n            yield this.mapNodeToEntry(node);\r\n            node = node.next;\r\n        }\r\n    }\r\n    enforceSizeLimit() {\r\n        let node = this.tail;\r\n        while (node !== null && this.size > this.maxSizeInternal) {\r\n            const prev = node.prev;\r\n            this.removeNodeFromListAndLookupTable(node);\r\n            node = prev;\r\n        }\r\n    }\r\n    mapNodeToEntry({ key, value }) {\r\n        return {\r\n            key,\r\n            value\r\n        };\r\n    }\r\n    setNodeAsHead(node) {\r\n        this.removeNodeFromList(node);\r\n        if (!this.head) {\r\n            this.head = node;\r\n            this.tail = node;\r\n        }\r\n        else {\r\n            node.next = this.head;\r\n            this.head.prev = node;\r\n            this.head = node;\r\n        }\r\n        node.invokeOnEntryMarkedAsMostRecentlyUsed();\r\n    }\r\n    removeNodeFromList(node) {\r\n        if (node.prev !== null) {\r\n            node.prev.next = node.next;\r\n        }\r\n        if (node.next !== null) {\r\n            node.next.prev = node.prev;\r\n        }\r\n        if (this.head === node) {\r\n            this.head = node.next;\r\n        }\r\n        if (this.tail === node) {\r\n            this.tail = node.prev;\r\n        }\r\n        node.next = null;\r\n        node.prev = null;\r\n    }\r\n    removeNodeFromListAndLookupTable(node) {\r\n        node.invokeOnEvicted();\r\n        this.removeNodeFromList(node);\r\n        return this.lookupTable.delete(node.key);\r\n    }\r\n    cleanCache() {\r\n        // Don't spend time cleaning if entries don't expire.\r\n        if (!this.entryExpirationTimeInMS) {\r\n            return;\r\n        }\r\n        const expiredNodes = [];\r\n        for (const node of this.lookupTable.values()) {\r\n            if (node.isExpired) {\r\n                expiredNodes.push(node);\r\n            }\r\n        }\r\n        expiredNodes.forEach(node => this.removeNodeFromListAndLookupTable(node));\r\n    }\r\n}\r\nexports.LRUCache = LRUCache;\r\n//# sourceMappingURL=LRUCache.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdHlwZXNjcmlwdC1scnUtY2FjaGUvZGlzdC9MUlVDYWNoZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0I7QUFDaEIsdUJBQXVCLG1CQUFPLENBQUMsc0ZBQWdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdIQUFnSDtBQUNoSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxhQUFhO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxhQUFhO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGFBQWE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGFBQWE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsNkJBQTZCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxpQkFBaUIsYUFBYTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGFBQWE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGFBQWE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsWUFBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCIiwic291cmNlcyI6WyIvaG9tZS9sZmcvR2l0L01hZHRyaXBzL25vZGVfbW9kdWxlcy90eXBlc2NyaXB0LWxydS1jYWNoZS9kaXN0L0xSVUNhY2hlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuTFJVQ2FjaGUgPSB2b2lkIDA7XHJcbmNvbnN0IExSVUNhY2hlTm9kZV8xID0gcmVxdWlyZShcIi4vTFJVQ2FjaGVOb2RlXCIpO1xyXG4vKipcclxuICogQSBrZXkgdmFsdWUgY2FjaGUgdGhhdCBpbXBsZW1lbnRzIHRoZSBMUlUgcG9saWN5LlxyXG4gKlxyXG4gKiBAdHlwZXBhcmFtIFRLZXkgVGhlIHR5cGUgb2YgdGhlIGtleXMgaW4gdGhlIGNhY2hlLiBEZWZhdWx0cyB0byBgc3RyaW5nYC5cclxuICogQHR5cGVwYXJhbSBUVmFsdWUgVGhlIHR5cGUgb2YgdGhlIHZhbHVlcyBpbiB0aGUgY2FjaGUuIERlZmF1bHRzIHRvIGBhbnlgLlxyXG4gKlxyXG4gKiBAc2VlIHtAbGluayBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DYWNoZV9yZXBsYWNlbWVudF9wb2xpY2llcyNMZWFzdF9yZWNlbnRseV91c2VkXyhMUlUpfVxyXG4gKi9cclxuY2xhc3MgTFJVQ2FjaGUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBMUlVDYWNoZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBBZGRpdGlvbmFsIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIExSVUNhY2hlLlxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiAvLyBObyBvcHRpb25zLlxyXG4gICAgICogY29uc3QgY2FjaGUgPSBuZXcgTFJVQ2FjaGUoKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBXaXRoIG9wdGlvbnMuXHJcbiAgICAgKiBjb25zdCBjYWNoZSA9IG5ldyBMUlVDYWNoZSh7XHJcbiAgICAgKiAgZW50cnlFeHBpcmF0aW9uVGltZUluTVM6IDEwMDAwXHJcbiAgICAgKiB9KTtcclxuICAgICAqIGBgYFxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5sb29rdXBUYWJsZSA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLmhlYWQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudGFpbCA9IG51bGw7XHJcbiAgICAgICAgY29uc3QgeyBtYXhTaXplID0gMjUsIGVudHJ5RXhwaXJhdGlvblRpbWVJbk1TID0gbnVsbCwgb25FbnRyeUV2aWN0ZWQsIG9uRW50cnlNYXJrZWRBc01vc3RSZWNlbnRseVVzZWQsIGNsb25lRm4sIGNsb25lIH0gPSBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB7fTtcclxuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKG1heFNpemUpIHx8IG1heFNpemUgPD0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21heFNpemUgbXVzdCBiZSBncmVhdGVyIHRoYW4gMC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBlbnRyeUV4cGlyYXRpb25UaW1lSW5NUyA9PT0gJ251bWJlcicgJiZcclxuICAgICAgICAgICAgKGVudHJ5RXhwaXJhdGlvblRpbWVJbk1TIDw9IDAgfHwgTnVtYmVyLmlzTmFOKGVudHJ5RXhwaXJhdGlvblRpbWVJbk1TKSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlbnRyeUV4cGlyYXRpb25UaW1lSW5NUyBtdXN0IGVpdGhlciBiZSBudWxsIChubyBleHBpcnkpIG9yIGdyZWF0ZXIgdGhhbiAwJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubWF4U2l6ZUludGVybmFsID0gbWF4U2l6ZTtcclxuICAgICAgICB0aGlzLmVudHJ5RXhwaXJhdGlvblRpbWVJbk1TID0gZW50cnlFeHBpcmF0aW9uVGltZUluTVM7XHJcbiAgICAgICAgdGhpcy5vbkVudHJ5RXZpY3RlZCA9IG9uRW50cnlFdmljdGVkO1xyXG4gICAgICAgIHRoaXMub25FbnRyeU1hcmtlZEFzTW9zdFJlY2VudGx5VXNlZCA9IG9uRW50cnlNYXJrZWRBc01vc3RSZWNlbnRseVVzZWQ7XHJcbiAgICAgICAgdGhpcy5jbG9uZSA9IGNsb25lO1xyXG4gICAgICAgIHRoaXMuY2xvbmVGbiA9IGNsb25lRm47XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBlbnRyaWVzIGluIHRoZSBMUlVDYWNoZSBvYmplY3QuXHJcbiAgICAgKiBJZiB0aGUgY2FjaGUgaGFzIGVudHJ5RXhwaXJhdGlvblRpbWVJbk1TIHNldCwgZXhwaXJlZCBlbnRyaWVzIHdpbGwgYmUgcmVtb3ZlZCBiZWZvcmUgdGhlIHNpemUgaXMgcmV0dXJuZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgVGhlIG51bWJlciBvZiBlbnRyaWVzIGluIHRoZSBjYWNoZS5cclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogY29uc3QgY2FjaGUgPSBuZXcgTFJVQ2FjaGUoKTtcclxuICAgICAqXHJcbiAgICAgKiBjYWNoZS5zZXQoJ3Rlc3RLZXknLCAndGVzdFZhbHVlJyk7XHJcbiAgICAgKlxyXG4gICAgICogY29uc3Qgc2l6ZSA9IGNhY2hlLnNpemU7XHJcbiAgICAgKlxyXG4gICAgICogLy8gV2lsbCBsb2cgMVxyXG4gICAgICogY29uc29sZS5sb2coc2l6ZSk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgZ2V0IHNpemUoKSB7XHJcbiAgICAgICAgdGhpcy5jbGVhbkNhY2hlKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubG9va3VwVGFibGUuc2l6ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGVudHJpZXMgdGhhdCBjYW4gc3RpbGwgYmUgYWRkZWQgdG8gdGhlIExSVUNhY2hlIHdpdGhvdXQgZXZpY3RpbmcgZXhpc3RpbmcgZW50cmllcy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIGVudHJpZXMgdGhhdCBjYW4gc3RpbGwgYmUgYWRkZWQgd2l0aG91dCBldmljdGluZyBleGlzdGluZyBlbnRyaWVzLlxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiBjb25zdCBjYWNoZSA9IG5ldyBMUlVDYWNoZSh7IG1heFNpemU6IDEwIH0pO1xyXG4gICAgICpcclxuICAgICAqIGNhY2hlLnNldCgndGVzdEtleScsICd0ZXN0VmFsdWUnKTtcclxuICAgICAqXHJcbiAgICAgKiBjb25zdCByZW1haW5pbmdTaXplID0gY2FjaGUucmVtYWluaW5nU2l6ZTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBXaWxsIGxvZyA5IGR1ZSB0byA5IHNwb3RzIHJlbWFpbmluZyBiZWZvcmUgcmVhY2hpbmcgbWF4U2l6ZSBvZiAxMC5cclxuICAgICAqIGNvbnNvbGUubG9nKHJlbWFpbmluZ1NpemUpO1xyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIGdldCByZW1haW5pbmdTaXplKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1heFNpemVJbnRlcm5hbCAtIHRoaXMuc2l6ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbW9zdCByZWNlbnRseSB1c2VkIChuZXdlc3QpIGVudHJ5IGluIHRoZSBjYWNoZS5cclxuICAgICAqIFRoaXMgd2lsbCBub3QgbWFyayB0aGUgZW50cnkgYXMgcmVjZW50bHkgdXNlZC5cclxuICAgICAqIElmIHRoZSBuZXdlc3Qgbm9kZSBpcyBleHBpcmVkLCBpdCB3aWxsIGJlIHJlbW92ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgVGhlIG1vc3QgcmVjZW50bHkgdXNlZCAobmV3ZXN0KSBlbnRyeSBpbiB0aGUgY2FjaGUuXHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIGNvbnN0IGNhY2hlID0gbmV3IExSVUNhY2hlKHsgbWF4U2l6ZTogMTAgfSk7XHJcbiAgICAgKlxyXG4gICAgICogY2FjaGUuc2V0KCd0ZXN0S2V5JywgJ3Rlc3RWYWx1ZScpO1xyXG4gICAgICpcclxuICAgICAqIGNvbnN0IG5ld2VzdCA9IGNhY2hlLm5ld2VzdDtcclxuICAgICAqXHJcbiAgICAgKiAvLyBXaWxsIGxvZyB0ZXN0VmFsdWVcclxuICAgICAqIGNvbnNvbGUubG9nKG5ld2VzdC52YWx1ZSk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gV2lsbCBsb2cgdGVzdEtleVxyXG4gICAgICogY29uc29sZS5sb2cobmV3ZXN0LmtleSk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgZ2V0IG5ld2VzdCgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaGVhZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaGVhZC5pc0V4cGlyZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVOb2RlRnJvbUxpc3RBbmRMb29rdXBUYWJsZSh0aGlzLmhlYWQpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uZXdlc3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLm1hcE5vZGVUb0VudHJ5KHRoaXMuaGVhZCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGxlYXN0IHJlY2VudGx5IHVzZWQgKG9sZGVzdCkgZW50cnkgaW4gdGhlIGNhY2hlLlxyXG4gICAgICogVGhpcyB3aWxsIG5vdCBtYXJrIHRoZSBlbnRyeSBhcyByZWNlbnRseSB1c2VkLlxyXG4gICAgICogSWYgdGhlIG9sZGVzdCBub2RlIGlzIGV4cGlyZWQsIGl0IHdpbGwgYmUgcmVtb3ZlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgbGVhc3QgcmVjZW50bHkgdXNlZCAob2xkZXN0KSBlbnRyeSBpbiB0aGUgY2FjaGUuXHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIGNvbnN0IGNhY2hlID0gbmV3IExSVUNhY2hlKHsgbWF4U2l6ZTogMTAgfSk7XHJcbiAgICAgKlxyXG4gICAgICogY2FjaGUuc2V0KCd0ZXN0S2V5JywgJ3Rlc3RWYWx1ZScpO1xyXG4gICAgICpcclxuICAgICAqIGNvbnN0IG9sZGVzdCA9IGNhY2hlLm9sZGVzdDtcclxuICAgICAqXHJcbiAgICAgKiAvLyBXaWxsIGxvZyB0ZXN0VmFsdWVcclxuICAgICAqIGNvbnNvbGUubG9nKG9sZGVzdC52YWx1ZSk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gV2lsbCBsb2cgdGVzdEtleVxyXG4gICAgICogY29uc29sZS5sb2cob2xkZXN0LmtleSk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgZ2V0IG9sZGVzdCgpIHtcclxuICAgICAgICBpZiAoIXRoaXMudGFpbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMudGFpbC5pc0V4cGlyZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVOb2RlRnJvbUxpc3RBbmRMb29rdXBUYWJsZSh0aGlzLnRhaWwpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vbGRlc3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLm1hcE5vZGVUb0VudHJ5KHRoaXMudGFpbCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgbWF4U2l6ZSBvZiB0aGUgY2FjaGUuXHJcbiAgICAgKiBUaGlzIHdpbGwgZXZpY3QgdGhlIGxlYXN0IHJlY2VudGx5IHVzZWQgZW50cmllcyBpZiBuZWVkZWQgdG8gcmVhY2ggbmV3IG1heFNpemUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSBuZXcgdmFsdWUgZm9yIG1heFNpemUuIE11c3QgYmUgZ3JlYXRlciB0aGFuIDAuXHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIGNvbnN0IGNhY2hlID0gbmV3IExSVUNhY2hlKHsgbWF4U2l6ZTogMTAgfSk7XHJcbiAgICAgKlxyXG4gICAgICogY2FjaGUuc2V0KCd0ZXN0S2V5JywgJ3Rlc3RWYWx1ZScpO1xyXG4gICAgICpcclxuICAgICAqIC8vIFdpbGwgYmUgMTBcclxuICAgICAqIGNvbnN0IG1heFNpemUgPSBjYWNoZS5tYXhTaXplO1xyXG4gICAgICpcclxuICAgICAqIC8vIFNldCBuZXcgbWF4U2l6ZSB0byA1LiBJZiB0aGVyZSBhcmUgbW9yZSB0aGFuIDUgaXRlbXMgaW4gdGhlIGNhY2hlLCB0aGUgbGVhc3QgcmVjZW50bHkgdXNlZCBlbnRyaWVzIHdpbGwgYmUgcmVtb3ZlZCB1bnRpbCBjYWNoZSBzaXplIGlzIDUuXHJcbiAgICAgKiBjYWNoZS5tYXhTaXplID0gNTtcclxuICAgICAqIGBgYFxyXG4gICAgICovXHJcbiAgICBnZXQgbWF4U2l6ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tYXhTaXplSW50ZXJuYWw7XHJcbiAgICB9XHJcbiAgICBzZXQgbWF4U2l6ZSh2YWx1ZSkge1xyXG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4odmFsdWUpIHx8IHZhbHVlIDw9IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXhTaXplIG11c3QgYmUgZ3JlYXRlciB0aGFuIDAuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubWF4U2l6ZUludGVybmFsID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5lbmZvcmNlU2l6ZUxpbWl0KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHZhbHVlIGZvciB0aGUga2V5IGluIHRoZSBMUlVDYWNoZSBvYmplY3QuIFJldHVybnMgdGhlIExSVUNhY2hlIG9iamVjdC5cclxuICAgICAqIFRoaXMgbWFya3MgdGhlIG5ld2x5IGFkZGVkIGVudHJ5IGFzIHRoZSBtb3N0IHJlY2VudGx5IHVzZWQgZW50cnkuXHJcbiAgICAgKiBJZiBhZGRpbmcgdGhlIG5ldyBlbnRyeSBtYWtlcyB0aGUgY2FjaGUgc2l6ZSBnbyBhYm92ZSBtYXhTaXplLFxyXG4gICAgICogdGhpcyB3aWxsIGV2aWN0IHRoZSBsZWFzdCByZWNlbnRseSB1c2VkIGVudHJpZXMgdW50aWwgc2l6ZSBpcyBlcXVhbCB0byBtYXhTaXplLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldCBmb3IgdGhlIGtleS5cclxuICAgICAqIEBwYXJhbSBlbnRyeU9wdGlvbnMgQWRkaXRpb25hbCBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBjYWNoZSBlbnRyeS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgTFJVQ2FjaGUgaW5zdGFuY2UuXHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIGNvbnN0IGNhY2hlID0gbmV3IExSVUNhY2hlKCk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gU2V0IHRoZSBrZXkgdGVzdEtleSB0byB2YWx1ZSB0ZXN0VmFsdWVcclxuICAgICAqIGNhY2hlLnNldCgndGVzdEtleScsICd0ZXN0VmFsdWUnKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBTZXQgdGhlIGtleSBrZXkyIHRvIHZhbHVlIHZhbHVlMi4gUGFzcyBpbiBvcHRpb25hbCBvcHRpb25zLlxyXG4gICAgICogY2FjaGUuc2V0KCdrZXkyJywgJ3ZhbHVlMicsIHsgZW50cnlFeHBpcmF0aW9uVGltZUluTVM6IDEwIH0pO1xyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIHNldChrZXksIHZhbHVlLCBlbnRyeU9wdGlvbnMpIHtcclxuICAgICAgICBjb25zdCBjdXJyZW50Tm9kZUZvcktleSA9IHRoaXMubG9va3VwVGFibGUuZ2V0KGtleSk7XHJcbiAgICAgICAgaWYgKGN1cnJlbnROb2RlRm9yS2V5KSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlTm9kZUZyb21MaXN0QW5kTG9va3VwVGFibGUoY3VycmVudE5vZGVGb3JLZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBub2RlID0gbmV3IExSVUNhY2hlTm9kZV8xLkxSVUNhY2hlTm9kZShrZXksIHZhbHVlLCB7XHJcbiAgICAgICAgICAgIGVudHJ5RXhwaXJhdGlvblRpbWVJbk1TOiB0aGlzLmVudHJ5RXhwaXJhdGlvblRpbWVJbk1TLFxyXG4gICAgICAgICAgICBvbkVudHJ5RXZpY3RlZDogdGhpcy5vbkVudHJ5RXZpY3RlZCxcclxuICAgICAgICAgICAgb25FbnRyeU1hcmtlZEFzTW9zdFJlY2VudGx5VXNlZDogdGhpcy5vbkVudHJ5TWFya2VkQXNNb3N0UmVjZW50bHlVc2VkLFxyXG4gICAgICAgICAgICBjbG9uZTogdGhpcy5jbG9uZSxcclxuICAgICAgICAgICAgY2xvbmVGbjogdGhpcy5jbG9uZUZuLFxyXG4gICAgICAgICAgICAuLi5lbnRyeU9wdGlvbnNcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLnNldE5vZGVBc0hlYWQobm9kZSk7XHJcbiAgICAgICAgdGhpcy5sb29rdXBUYWJsZS5zZXQoa2V5LCBub2RlKTtcclxuICAgICAgICB0aGlzLmVuZm9yY2VTaXplTGltaXQoKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgYXNzb2NpYXRlZCB0byB0aGUga2V5LCBvciBudWxsIGlmIHRoZXJlIGlzIG5vbmUgb3IgaWYgdGhlIGVudHJ5IGlzIGV4cGlyZWQuXHJcbiAgICAgKiBJZiBhbiBlbnRyeSBpcyByZXR1cm5lZCwgdGhpcyBtYXJrcyB0aGUgcmV0dXJuZWQgZW50cnkgYXMgdGhlIG1vc3QgcmVjZW50bHkgdXNlZCBlbnRyeS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGdldC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgY2FjaGVkIHZhbHVlIG9yIG51bGwuXHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIGNvbnN0IGNhY2hlID0gbmV3IExSVUNhY2hlKCk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gU2V0IHRoZSBrZXkgdGVzdEtleSB0byB2YWx1ZSB0ZXN0VmFsdWVcclxuICAgICAqIGNhY2hlLnNldCgndGVzdEtleScsICd0ZXN0VmFsdWUnKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBXaWxsIGJlICd0ZXN0VmFsdWUnLiBFbnRyeSB3aWxsIG5vdyBiZSBtb3N0IHJlY2VudGx5IHVzZWQuXHJcbiAgICAgKiBjb25zdCBpdGVtMSA9IGNhY2hlLmdldCgndGVzdEtleScpO1xyXG4gICAgICpcclxuICAgICAqIC8vIFdpbGwgYmUgbnVsbFxyXG4gICAgICogY29uc3QgaXRlbTIgPSBjYWNoZS5nZXQoJ2tleU5vdEluQ2FjaGUnKTtcclxuICAgICAqIGBgYFxyXG4gICAgICovXHJcbiAgICBnZXQoa2V5KSB7XHJcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMubG9va3VwVGFibGUuZ2V0KGtleSk7XHJcbiAgICAgICAgaWYgKCFub2RlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobm9kZS5pc0V4cGlyZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVOb2RlRnJvbUxpc3RBbmRMb29rdXBUYWJsZShub2RlKTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2V0Tm9kZUFzSGVhZChub2RlKTtcclxuICAgICAgICByZXR1cm4gbm9kZS52YWx1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgYXNzb2NpYXRlZCB0byB0aGUga2V5LCBvciBudWxsIGlmIHRoZXJlIGlzIG5vbmUgb3IgaWYgdGhlIGVudHJ5IGlzIGV4cGlyZWQuXHJcbiAgICAgKiBJZiBhbiBlbnRyeSBpcyByZXR1cm5lZCwgdGhpcyB3aWxsIG5vdCBtYXJrIHRoZSBlbnRyeSBhcyBtb3N0IHJlY2VudGx5IGFjY2Vzc2VkLlxyXG4gICAgICogVXNlZnVsIGlmIGEgdmFsdWUgaXMgbmVlZGVkIGJ1dCB0aGUgb3JkZXIgb2YgdGhlIGNhY2hlIHNob3VsZCBub3QgYmUgY2hhbmdlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGdldC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgY2FjaGVkIHZhbHVlIG9yIG51bGwuXHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIGNvbnN0IGNhY2hlID0gbmV3IExSVUNhY2hlKCk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gU2V0IHRoZSBrZXkgdGVzdEtleSB0byB2YWx1ZSB0ZXN0VmFsdWVcclxuICAgICAqIGNhY2hlLnNldCgndGVzdEtleScsICd0ZXN0VmFsdWUnKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBXaWxsIGJlICd0ZXN0VmFsdWUnXHJcbiAgICAgKiBjb25zdCBpdGVtMSA9IGNhY2hlLnBlZWsoJ3Rlc3RLZXknKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBXaWxsIGJlIG51bGxcclxuICAgICAqIGNvbnN0IGl0ZW0yID0gY2FjaGUucGVlaygna2V5Tm90SW5DYWNoZScpO1xyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIHBlZWsoa2V5KSB7XHJcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMubG9va3VwVGFibGUuZ2V0KGtleSk7XHJcbiAgICAgICAgaWYgKCFub2RlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobm9kZS5pc0V4cGlyZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVOb2RlRnJvbUxpc3RBbmRMb29rdXBUYWJsZShub2RlKTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBub2RlLnZhbHVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxldGVzIHRoZSBlbnRyeSBmb3IgdGhlIHBhc3NlZCBpbiBrZXkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBkZWxldGVcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIGFuIGVsZW1lbnQgaW4gdGhlIExSVUNhY2hlIG9iamVjdCBleGlzdGVkIGFuZCBoYXMgYmVlbiByZW1vdmVkLFxyXG4gICAgICogb3IgZmFsc2UgaWYgdGhlIGVsZW1lbnQgZG9lcyBub3QgZXhpc3QuXHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIGNvbnN0IGNhY2hlID0gbmV3IExSVUNhY2hlKCk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gU2V0IHRoZSBrZXkgdGVzdEtleSB0byB2YWx1ZSB0ZXN0VmFsdWVcclxuICAgICAqIGNhY2hlLnNldCgndGVzdEtleScsICd0ZXN0VmFsdWUnKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBXaWxsIGJlIHRydWVcclxuICAgICAqIGNvbnN0IHdhc0RlbGV0ZWQgPSBjYWNoZS5kZWxldGUoJ3Rlc3RLZXknKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBXaWxsIGJlIGZhbHNlXHJcbiAgICAgKiBjb25zdCB3YXNEZWxldGVkMiA9IGNhY2hlLmRlbGV0ZSgna2V5Tm90SW5DYWNoZScpO1xyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIGRlbGV0ZShrZXkpIHtcclxuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5sb29rdXBUYWJsZS5nZXQoa2V5KTtcclxuICAgICAgICBpZiAoIW5vZGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVOb2RlRnJvbUxpc3RBbmRMb29rdXBUYWJsZShub2RlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGJvb2xlYW4gYXNzZXJ0aW5nIHdoZXRoZXIgYSB2YWx1ZSBoYXMgYmVlbiBhc3NvY2lhdGVkIHRvIHRoZSBrZXkgaW4gdGhlIExSVUNhY2hlIG9iamVjdCBvciBub3QuXHJcbiAgICAgKiBUaGlzIGRvZXMgbm90IG1hcmsgdGhlIGVudHJ5IGFzIHJlY2VudGx5IHVzZWQuXHJcbiAgICAgKiBJZiB0aGUgY2FjaGUgaGFzIGEga2V5IGJ1dCB0aGUgZW50cnkgaXMgZXhwaXJlZCwgaXQgd2lsbCBiZSByZW1vdmVkIGFuZCBmYWxzZSB3aWxsIGJlIHJldHVybmVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2sgaWYgZXhpc3RzXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgY2FjaGUgY29udGFpbnMgdGhlIHN1cHBsaWVkIGtleS4gRmFsc2UgaWYgbm90LlxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiBjb25zdCBjYWNoZSA9IG5ldyBMUlVDYWNoZSgpO1xyXG4gICAgICpcclxuICAgICAqIC8vIFNldCB0aGUga2V5IHRlc3RLZXkgdG8gdmFsdWUgdGVzdFZhbHVlXHJcbiAgICAgKiBjYWNoZS5zZXQoJ3Rlc3RLZXknLCAndGVzdFZhbHVlJyk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gV2lsbCBiZSB0cnVlXHJcbiAgICAgKiBjb25zdCB3YXNEZWxldGVkID0gY2FjaGUuaGFzKCd0ZXN0S2V5Jyk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gV2lsbCBiZSBmYWxzZVxyXG4gICAgICogY29uc3Qgd2FzRGVsZXRlZDIgPSBjYWNoZS5oYXMoJ2tleU5vdEluQ2FjaGUnKTtcclxuICAgICAqIGBgYFxyXG4gICAgICovXHJcbiAgICBoYXMoa2V5KSB7XHJcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMubG9va3VwVGFibGUuZ2V0KGtleSk7XHJcbiAgICAgICAgaWYgKCFub2RlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5vZGUuaXNFeHBpcmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlTm9kZUZyb21MaXN0QW5kTG9va3VwVGFibGUobm9kZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYWxsIGVudHJpZXMgaW4gdGhlIGNhY2hlLlxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiBjb25zdCBjYWNoZSA9IG5ldyBMUlVDYWNoZSgpO1xyXG4gICAgICpcclxuICAgICAqIC8vIFNldCB0aGUga2V5IHRlc3RLZXkgdG8gdmFsdWUgdGVzdFZhbHVlXHJcbiAgICAgKiBjYWNoZS5zZXQoJ3Rlc3RLZXknLCAndGVzdFZhbHVlJyk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gQ2xlYXIgY2FjaGUuXHJcbiAgICAgKiBjYWNoZS5jbGVhcigpO1xyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIGNsZWFyKCkge1xyXG4gICAgICAgIHRoaXMuaGVhZCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy50YWlsID0gbnVsbDtcclxuICAgICAgICB0aGlzLmxvb2t1cFRhYmxlLmNsZWFyKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNlYXJjaGVzIHRoZSBjYWNoZSBmb3IgYW4gZW50cnkgbWF0Y2hpbmcgdGhlIHBhc3NlZCBpbiBjb25kaXRpb24uXHJcbiAgICAgKiBFeHBpcmVkIGVudHJpZXMgd2lsbCBiZSBza2lwcGVkIChhbmQgcmVtb3ZlZCkuXHJcbiAgICAgKiBJZiBtdWx0aXBseSBlbnRyaWVzIGluIHRoZSBjYWNoZSBtYXRjaCB0aGUgY29uZGl0aW9uLCB0aGUgbW9zdCByZWNlbnRseSB1c2VkIGVudHJ5IHdpbGwgYmUgcmV0dXJuZWQuXHJcbiAgICAgKiBJZiBhbiBlbnRyeSBpcyByZXR1cm5lZCwgdGhpcyBtYXJrcyB0aGUgcmV0dXJuZWQgZW50cnkgYXMgdGhlIG1vc3QgcmVjZW50bHkgdXNlZCBlbnRyeS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY29uZGl0aW9uIFRoZSBjb25kaXRpb24gdG8gYXBwbHkgdG8gZWFjaCBlbnRyeSBpbiB0aGVcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgZmlyc3QgY2FjaGUgZW50cnkgdG8gbWF0Y2ggdGhlIGNvbmRpdGlvbi4gTnVsbCBpZiBub25lIG1hdGNoLlxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiBjb25zdCBjYWNoZSA9IG5ldyBMUlVDYWNoZSgpO1xyXG4gICAgICpcclxuICAgICAqIC8vIFNldCB0aGUga2V5IHRlc3RLZXkgdG8gdmFsdWUgdGVzdFZhbHVlXHJcbiAgICAgKiBjYWNoZS5zZXQoJ3Rlc3RLZXknLCAndGVzdFZhbHVlJyk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gaXRlbSB3aWxsIGJlIHsga2V5OiAndGVzdEtleScsIHZhbHVlOiAndGVzdFZhbHVlIH1cclxuICAgICAqIGNvbnN0IGl0ZW0gPSBjYWNoZS5maW5kKGVudHJ5ID0+IHtcclxuICAgICAqICAgY29uc3QgeyBrZXksIHZhbHVlIH0gPSBlbnRyeTtcclxuICAgICAqXHJcbiAgICAgKiAgIGlmIChrZXkgPT09ICd0ZXN0S2V5JyB8fCB2YWx1ZSA9PT0gJ3NvbWV0aGluZycpIHtcclxuICAgICAqICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAqICAgfVxyXG4gICAgICpcclxuICAgICAqICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICogfSk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gaXRlbTIgd2lsbCBiZSBudWxsXHJcbiAgICAgKiBjb25zdCBpdGVtMiA9IGNhY2hlLmZpbmQoZW50cnkgPT4gZW50cnkua2V5ID09PSAnbm90SW5DYWNoZScpO1xyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIGZpbmQoY29uZGl0aW9uKSB7XHJcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmhlYWQ7XHJcbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcclxuICAgICAgICAgICAgaWYgKG5vZGUuaXNFeHBpcmVkKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gbm9kZS5uZXh0O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVOb2RlRnJvbUxpc3RBbmRMb29rdXBUYWJsZShub2RlKTtcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBuZXh0O1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgZW50cnkgPSB0aGlzLm1hcE5vZGVUb0VudHJ5KG5vZGUpO1xyXG4gICAgICAgICAgICBpZiAoY29uZGl0aW9uKGVudHJ5KSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXROb2RlQXNIZWFkKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVudHJ5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGFuZCBhcHBsaWVzIHRoZSBjYWxsYmFjayBmdW5jdGlvbiB0byBlYWNoIGVudHJ5IGluIHRoZSBjYWNoZS5cclxuICAgICAqIEl0ZXJhdGVzIGluIG9yZGVyIGZyb20gbW9zdCByZWNlbnRseSBhY2Nlc3NlZCBlbnRyeSB0byBsZWFzdCByZWNlbnRseS5cclxuICAgICAqIEV4cGlyZWQgZW50cmllcyB3aWxsIGJlIHNraXBwZWQgKGFuZCByZW1vdmVkKS5cclxuICAgICAqIE5vIGVudHJ5IHdpbGwgYmUgbWFya2VkIGFzIHJlY2VudGx5IHVzZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIHRoZSBjYWxsYmFjayBmdW5jdGlvbiB0byBhcHBseSB0byB0aGUgZW50cnlcclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogY29uc3QgY2FjaGUgPSBuZXcgTFJVQ2FjaGUoKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBTZXQgdGhlIGtleSB0ZXN0S2V5IHRvIHZhbHVlIHRlc3RWYWx1ZVxyXG4gICAgICogY2FjaGUuc2V0KCd0ZXN0S2V5JywgJ3Rlc3RWYWx1ZScpO1xyXG4gICAgICpcclxuICAgICAqIGNhY2hlLmZvckVhY2goKGtleSwgdmFsdWUsIGluZGV4KSA9PiB7XHJcbiAgICAgKiAgIC8vIGRvIHNvbWV0aGluZyB3aXRoIGtleSwgdmFsdWUsIGFuZC9vciBpbmRleFxyXG4gICAgICogfSk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgZm9yRWFjaChjYWxsYmFjaykge1xyXG4gICAgICAgIGxldCBub2RlID0gdGhpcy5oZWFkO1xyXG4gICAgICAgIGxldCBpbmRleCA9IDA7XHJcbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcclxuICAgICAgICAgICAgaWYgKG5vZGUuaXNFeHBpcmVkKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gbm9kZS5uZXh0O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVOb2RlRnJvbUxpc3RBbmRMb29rdXBUYWJsZShub2RlKTtcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBuZXh0O1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FsbGJhY2sobm9kZS52YWx1ZSwgbm9kZS5rZXksIGluZGV4KTtcclxuICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcclxuICAgICAgICAgICAgaW5kZXgrKztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBHZW5lcmF0b3Igd2hpY2ggY2FuIGJlIHVzZWQgd2l0aCBmb3IgLi4uIG9mIC4uLiB0byBpdGVyYXRlIG92ZXIgdGhlIGNhY2hlIHZhbHVlcy5cclxuICAgICAqIEl0ZXJhdGVzIGluIG9yZGVyIGZyb20gbW9zdCByZWNlbnRseSBhY2Nlc3NlZCBlbnRyeSB0byBsZWFzdCByZWNlbnRseS5cclxuICAgICAqIEV4cGlyZWQgZW50cmllcyB3aWxsIGJlIHNraXBwZWQgKGFuZCByZW1vdmVkKS5cclxuICAgICAqIE5vIGVudHJ5IHdpbGwgYmUgbWFya2VkIGFzIGFjY2Vzc2VkLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIEEgR2VuZXJhdG9yIGZvciB0aGUgY2FjaGUgdmFsdWVzLlxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiBjb25zdCBjYWNoZSA9IG5ldyBMUlVDYWNoZSgpO1xyXG4gICAgICpcclxuICAgICAqIC8vIFNldCB0aGUga2V5IHRlc3RLZXkgdG8gdmFsdWUgdGVzdFZhbHVlXHJcbiAgICAgKiBjYWNoZS5zZXQoJ3Rlc3RLZXknLCAndGVzdFZhbHVlJyk7XHJcbiAgICAgKlxyXG4gICAgICogZm9yIChjb25zdCB2YWx1ZSBvZiBjYWNoZS52YWx1ZXMoKSkge1xyXG4gICAgICogICAvLyBkbyBzb21ldGhpbmcgd2l0aCB0aGUgdmFsdWVcclxuICAgICAqIH1cclxuICAgICAqIGBgYFxyXG4gICAgICovXHJcbiAgICAqdmFsdWVzKCkge1xyXG4gICAgICAgIGxldCBub2RlID0gdGhpcy5oZWFkO1xyXG4gICAgICAgIHdoaWxlIChub2RlKSB7XHJcbiAgICAgICAgICAgIGlmIChub2RlLmlzRXhwaXJlZCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IG5vZGUubmV4dDtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTm9kZUZyb21MaXN0QW5kTG9va3VwVGFibGUobm9kZSk7XHJcbiAgICAgICAgICAgICAgICBub2RlID0gbmV4dDtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHlpZWxkIG5vZGUudmFsdWU7XHJcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgR2VuZXJhdG9yIHdoaWNoIGNhbiBiZSB1c2VkIHdpdGggZm9yIC4uLiBvZiAuLi4gdG8gaXRlcmF0ZSBvdmVyIHRoZSBjYWNoZSBrZXlzLlxyXG4gICAgICogSXRlcmF0ZXMgaW4gb3JkZXIgZnJvbSBtb3N0IHJlY2VudGx5IGFjY2Vzc2VkIGVudHJ5IHRvIGxlYXN0IHJlY2VudGx5LlxyXG4gICAgICogRXhwaXJlZCBlbnRyaWVzIHdpbGwgYmUgc2tpcHBlZCAoYW5kIHJlbW92ZWQpLlxyXG4gICAgICogTm8gZW50cnkgd2lsbCBiZSBtYXJrZWQgYXMgYWNjZXNzZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgQSBHZW5lcmF0b3IgZm9yIHRoZSBjYWNoZSBrZXlzLlxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiBjb25zdCBjYWNoZSA9IG5ldyBMUlVDYWNoZSgpO1xyXG4gICAgICpcclxuICAgICAqIC8vIFNldCB0aGUga2V5IHRlc3RLZXkgdG8gdmFsdWUgdGVzdFZhbHVlXHJcbiAgICAgKiBjYWNoZS5zZXQoJ3Rlc3RLZXknLCAndGVzdFZhbHVlJyk7XHJcbiAgICAgKlxyXG4gICAgICogZm9yIChjb25zdCBrZXkgb2YgY2FjaGUua2V5cygpKSB7XHJcbiAgICAgKiAgIC8vIGRvIHNvbWV0aGluZyB3aXRoIHRoZSBrZXlcclxuICAgICAqIH1cclxuICAgICAqIGBgYFxyXG4gICAgICovXHJcbiAgICAqa2V5cygpIHtcclxuICAgICAgICBsZXQgbm9kZSA9IHRoaXMuaGVhZDtcclxuICAgICAgICB3aGlsZSAobm9kZSkge1xyXG4gICAgICAgICAgICBpZiAobm9kZS5pc0V4cGlyZWQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSBub2RlLm5leHQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZU5vZGVGcm9tTGlzdEFuZExvb2t1cFRhYmxlKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5leHQ7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB5aWVsZCBub2RlLmtleTtcclxuICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBHZW5lcmF0b3Igd2hpY2ggY2FuIGJlIHVzZWQgd2l0aCBmb3IgLi4uIG9mIC4uLiB0byBpdGVyYXRlIG92ZXIgdGhlIGNhY2hlIGVudHJpZXMuXHJcbiAgICAgKiBJdGVyYXRlcyBpbiBvcmRlciBmcm9tIG1vc3QgcmVjZW50bHkgYWNjZXNzZWQgZW50cnkgdG8gbGVhc3QgcmVjZW50bHkuXHJcbiAgICAgKiBFeHBpcmVkIGVudHJpZXMgd2lsbCBiZSBza2lwcGVkIChhbmQgcmVtb3ZlZCkuXHJcbiAgICAgKiBObyBlbnRyeSB3aWxsIGJlIG1hcmtlZCBhcyBhY2Nlc3NlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBBIEdlbmVyYXRvciBmb3IgdGhlIGNhY2hlIGVudHJpZXMuXHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIGNvbnN0IGNhY2hlID0gbmV3IExSVUNhY2hlKCk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gU2V0IHRoZSBrZXkgdGVzdEtleSB0byB2YWx1ZSB0ZXN0VmFsdWVcclxuICAgICAqIGNhY2hlLnNldCgndGVzdEtleScsICd0ZXN0VmFsdWUnKTtcclxuICAgICAqXHJcbiAgICAgKiBmb3IgKGNvbnN0IGVudHJ5IG9mIGNhY2hlLmVudHJpZXMoKSkge1xyXG4gICAgICogICBjb25zdCB7IGtleSwgdmFsdWUgfSA9IGVudHJ5O1xyXG4gICAgICogICAvLyBkbyBzb21ldGhpbmcgd2l0aCB0aGUgZW50cnlcclxuICAgICAqIH1cclxuICAgICAqIGBgYFxyXG4gICAgICovXHJcbiAgICAqZW50cmllcygpIHtcclxuICAgICAgICBsZXQgbm9kZSA9IHRoaXMuaGVhZDtcclxuICAgICAgICB3aGlsZSAobm9kZSkge1xyXG4gICAgICAgICAgICBpZiAobm9kZS5pc0V4cGlyZWQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSBub2RlLm5leHQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZU5vZGVGcm9tTGlzdEFuZExvb2t1cFRhYmxlKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5leHQ7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB5aWVsZCB0aGlzLm1hcE5vZGVUb0VudHJ5KG5vZGUpO1xyXG4gICAgICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIEdlbmVyYXRvciB3aGljaCBjYW4gYmUgdXNlZCB3aXRoIGZvciAuLi4gb2YgLi4uIHRvIGl0ZXJhdGUgb3ZlciB0aGUgY2FjaGUgZW50cmllcy5cclxuICAgICAqIEl0ZXJhdGVzIGluIG9yZGVyIGZyb20gbW9zdCByZWNlbnRseSBhY2Nlc3NlZCBlbnRyeSB0byBsZWFzdCByZWNlbnRseS5cclxuICAgICAqIEV4cGlyZWQgZW50cmllcyB3aWxsIGJlIHNraXBwZWQgKGFuZCByZW1vdmVkKS5cclxuICAgICAqIE5vIGVudHJ5IHdpbGwgYmUgbWFya2VkIGFzIGFjY2Vzc2VkLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIEEgR2VuZXJhdG9yIGZvciB0aGUgY2FjaGUgZW50cmllcy5cclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogY29uc3QgY2FjaGUgPSBuZXcgTFJVQ2FjaGUoKTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBTZXQgdGhlIGtleSB0ZXN0S2V5IHRvIHZhbHVlIHRlc3RWYWx1ZVxyXG4gICAgICogY2FjaGUuc2V0KCd0ZXN0S2V5JywgJ3Rlc3RWYWx1ZScpO1xyXG4gICAgICpcclxuICAgICAqIGZvciAoY29uc3QgZW50cnkgb2YgY2FjaGUpIHtcclxuICAgICAqICAgY29uc3QgeyBrZXksIHZhbHVlIH0gPSBlbnRyeTtcclxuICAgICAqICAgLy8gZG8gc29tZXRoaW5nIHdpdGggdGhlIGVudHJ5XHJcbiAgICAgKiB9XHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgKltTeW1ib2wuaXRlcmF0b3JdKCkge1xyXG4gICAgICAgIGxldCBub2RlID0gdGhpcy5oZWFkO1xyXG4gICAgICAgIHdoaWxlIChub2RlKSB7XHJcbiAgICAgICAgICAgIGlmIChub2RlLmlzRXhwaXJlZCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IG5vZGUubmV4dDtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTm9kZUZyb21MaXN0QW5kTG9va3VwVGFibGUobm9kZSk7XHJcbiAgICAgICAgICAgICAgICBub2RlID0gbmV4dDtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHlpZWxkIHRoaXMubWFwTm9kZVRvRW50cnkobm9kZSk7XHJcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZW5mb3JjZVNpemVMaW1pdCgpIHtcclxuICAgICAgICBsZXQgbm9kZSA9IHRoaXMudGFpbDtcclxuICAgICAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCAmJiB0aGlzLnNpemUgPiB0aGlzLm1heFNpemVJbnRlcm5hbCkge1xyXG4gICAgICAgICAgICBjb25zdCBwcmV2ID0gbm9kZS5wcmV2O1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZU5vZGVGcm9tTGlzdEFuZExvb2t1cFRhYmxlKG5vZGUpO1xyXG4gICAgICAgICAgICBub2RlID0gcHJldjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBtYXBOb2RlVG9FbnRyeSh7IGtleSwgdmFsdWUgfSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGtleSxcclxuICAgICAgICAgICAgdmFsdWVcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgc2V0Tm9kZUFzSGVhZChub2RlKSB7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVOb2RlRnJvbUxpc3Qobm9kZSk7XHJcbiAgICAgICAgaWYgKCF0aGlzLmhlYWQpIHtcclxuICAgICAgICAgICAgdGhpcy5oZWFkID0gbm9kZTtcclxuICAgICAgICAgICAgdGhpcy50YWlsID0gbm9kZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG5vZGUubmV4dCA9IHRoaXMuaGVhZDtcclxuICAgICAgICAgICAgdGhpcy5oZWFkLnByZXYgPSBub2RlO1xyXG4gICAgICAgICAgICB0aGlzLmhlYWQgPSBub2RlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBub2RlLmludm9rZU9uRW50cnlNYXJrZWRBc01vc3RSZWNlbnRseVVzZWQoKTtcclxuICAgIH1cclxuICAgIHJlbW92ZU5vZGVGcm9tTGlzdChub2RlKSB7XHJcbiAgICAgICAgaWYgKG5vZGUucHJldiAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBub2RlLnByZXYubmV4dCA9IG5vZGUubmV4dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5vZGUubmV4dCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBub2RlLm5leHQucHJldiA9IG5vZGUucHJldjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaGVhZCA9PT0gbm9kZSkge1xyXG4gICAgICAgICAgICB0aGlzLmhlYWQgPSBub2RlLm5leHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnRhaWwgPT09IG5vZGUpIHtcclxuICAgICAgICAgICAgdGhpcy50YWlsID0gbm9kZS5wcmV2O1xyXG4gICAgICAgIH1cclxuICAgICAgICBub2RlLm5leHQgPSBudWxsO1xyXG4gICAgICAgIG5vZGUucHJldiA9IG51bGw7XHJcbiAgICB9XHJcbiAgICByZW1vdmVOb2RlRnJvbUxpc3RBbmRMb29rdXBUYWJsZShub2RlKSB7XHJcbiAgICAgICAgbm9kZS5pbnZva2VPbkV2aWN0ZWQoKTtcclxuICAgICAgICB0aGlzLnJlbW92ZU5vZGVGcm9tTGlzdChub2RlKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5sb29rdXBUYWJsZS5kZWxldGUobm9kZS5rZXkpO1xyXG4gICAgfVxyXG4gICAgY2xlYW5DYWNoZSgpIHtcclxuICAgICAgICAvLyBEb24ndCBzcGVuZCB0aW1lIGNsZWFuaW5nIGlmIGVudHJpZXMgZG9uJ3QgZXhwaXJlLlxyXG4gICAgICAgIGlmICghdGhpcy5lbnRyeUV4cGlyYXRpb25UaW1lSW5NUykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGV4cGlyZWROb2RlcyA9IFtdO1xyXG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiB0aGlzLmxvb2t1cFRhYmxlLnZhbHVlcygpKSB7XHJcbiAgICAgICAgICAgIGlmIChub2RlLmlzRXhwaXJlZCkge1xyXG4gICAgICAgICAgICAgICAgZXhwaXJlZE5vZGVzLnB1c2gobm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZXhwaXJlZE5vZGVzLmZvckVhY2gobm9kZSA9PiB0aGlzLnJlbW92ZU5vZGVGcm9tTGlzdEFuZExvb2t1cFRhYmxlKG5vZGUpKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkxSVUNhY2hlID0gTFJVQ2FjaGU7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxSVUNhY2hlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/typescript-lru-cache/dist/LRUCache.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/typescript-lru-cache/dist/LRUCacheNode.js":
/*!****************************************************************!*\
  !*** ./node_modules/typescript-lru-cache/dist/LRUCacheNode.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\nexports.LRUCacheNode = void 0;\r\nclass LRUCacheNode {\r\n    constructor(key, value, options) {\r\n        const { entryExpirationTimeInMS = null, next = null, prev = null, onEntryEvicted, onEntryMarkedAsMostRecentlyUsed, clone, cloneFn } = options !== null && options !== void 0 ? options : {};\r\n        if (typeof entryExpirationTimeInMS === 'number' &&\r\n            (entryExpirationTimeInMS <= 0 || Number.isNaN(entryExpirationTimeInMS))) {\r\n            throw new Error('entryExpirationTimeInMS must either be null (no expiry) or greater than 0');\r\n        }\r\n        this.clone = clone !== null && clone !== void 0 ? clone : false;\r\n        this.cloneFn = cloneFn !== null && cloneFn !== void 0 ? cloneFn : this.defaultClone;\r\n        this.key = key;\r\n        this.internalValue = this.clone ? this.cloneFn(value) : value;\r\n        this.created = Date.now();\r\n        this.entryExpirationTimeInMS = entryExpirationTimeInMS;\r\n        this.next = next;\r\n        this.prev = prev;\r\n        this.onEntryEvicted = onEntryEvicted;\r\n        this.onEntryMarkedAsMostRecentlyUsed = onEntryMarkedAsMostRecentlyUsed;\r\n    }\r\n    get value() {\r\n        return this.clone ? this.cloneFn(this.internalValue) : this.internalValue;\r\n    }\r\n    get isExpired() {\r\n        return typeof this.entryExpirationTimeInMS === 'number' && Date.now() - this.created > this.entryExpirationTimeInMS;\r\n    }\r\n    invokeOnEvicted() {\r\n        if (this.onEntryEvicted) {\r\n            const { key, value, isExpired } = this;\r\n            this.onEntryEvicted({ key, value, isExpired });\r\n        }\r\n    }\r\n    invokeOnEntryMarkedAsMostRecentlyUsed() {\r\n        if (this.onEntryMarkedAsMostRecentlyUsed) {\r\n            const { key, value } = this;\r\n            this.onEntryMarkedAsMostRecentlyUsed({ key, value });\r\n        }\r\n    }\r\n    defaultClone(value) {\r\n        if (typeof value === 'boolean' || typeof value === 'string' || typeof value === 'number') {\r\n            return value;\r\n        }\r\n        return JSON.parse(JSON.stringify(value));\r\n    }\r\n}\r\nexports.LRUCacheNode = LRUCacheNode;\r\n//# sourceMappingURL=LRUCacheNode.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdHlwZXNjcmlwdC1scnUtY2FjaGUvZGlzdC9MUlVDYWNoZU5vZGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxnQkFBZ0IsNEhBQTRIO0FBQzVJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQXdCO0FBQzVDLGtDQUFrQyx1QkFBdUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQyxtREFBbUQsWUFBWTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIiLCJzb3VyY2VzIjpbIi9ob21lL2xmZy9HaXQvTWFkdHJpcHMvbm9kZV9tb2R1bGVzL3R5cGVzY3JpcHQtbHJ1LWNhY2hlL2Rpc3QvTFJVQ2FjaGVOb2RlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuTFJVQ2FjaGVOb2RlID0gdm9pZCAwO1xyXG5jbGFzcyBMUlVDYWNoZU5vZGUge1xyXG4gICAgY29uc3RydWN0b3Ioa2V5LCB2YWx1ZSwgb3B0aW9ucykge1xyXG4gICAgICAgIGNvbnN0IHsgZW50cnlFeHBpcmF0aW9uVGltZUluTVMgPSBudWxsLCBuZXh0ID0gbnVsbCwgcHJldiA9IG51bGwsIG9uRW50cnlFdmljdGVkLCBvbkVudHJ5TWFya2VkQXNNb3N0UmVjZW50bHlVc2VkLCBjbG9uZSwgY2xvbmVGbiB9ID0gb3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgPyBvcHRpb25zIDoge307XHJcbiAgICAgICAgaWYgKHR5cGVvZiBlbnRyeUV4cGlyYXRpb25UaW1lSW5NUyA9PT0gJ251bWJlcicgJiZcclxuICAgICAgICAgICAgKGVudHJ5RXhwaXJhdGlvblRpbWVJbk1TIDw9IDAgfHwgTnVtYmVyLmlzTmFOKGVudHJ5RXhwaXJhdGlvblRpbWVJbk1TKSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlbnRyeUV4cGlyYXRpb25UaW1lSW5NUyBtdXN0IGVpdGhlciBiZSBudWxsIChubyBleHBpcnkpIG9yIGdyZWF0ZXIgdGhhbiAwJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2xvbmUgPSBjbG9uZSAhPT0gbnVsbCAmJiBjbG9uZSAhPT0gdm9pZCAwID8gY2xvbmUgOiBmYWxzZTtcclxuICAgICAgICB0aGlzLmNsb25lRm4gPSBjbG9uZUZuICE9PSBudWxsICYmIGNsb25lRm4gIT09IHZvaWQgMCA/IGNsb25lRm4gOiB0aGlzLmRlZmF1bHRDbG9uZTtcclxuICAgICAgICB0aGlzLmtleSA9IGtleTtcclxuICAgICAgICB0aGlzLmludGVybmFsVmFsdWUgPSB0aGlzLmNsb25lID8gdGhpcy5jbG9uZUZuKHZhbHVlKSA6IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuY3JlYXRlZCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgdGhpcy5lbnRyeUV4cGlyYXRpb25UaW1lSW5NUyA9IGVudHJ5RXhwaXJhdGlvblRpbWVJbk1TO1xyXG4gICAgICAgIHRoaXMubmV4dCA9IG5leHQ7XHJcbiAgICAgICAgdGhpcy5wcmV2ID0gcHJldjtcclxuICAgICAgICB0aGlzLm9uRW50cnlFdmljdGVkID0gb25FbnRyeUV2aWN0ZWQ7XHJcbiAgICAgICAgdGhpcy5vbkVudHJ5TWFya2VkQXNNb3N0UmVjZW50bHlVc2VkID0gb25FbnRyeU1hcmtlZEFzTW9zdFJlY2VudGx5VXNlZDtcclxuICAgIH1cclxuICAgIGdldCB2YWx1ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSA/IHRoaXMuY2xvbmVGbih0aGlzLmludGVybmFsVmFsdWUpIDogdGhpcy5pbnRlcm5hbFZhbHVlO1xyXG4gICAgfVxyXG4gICAgZ2V0IGlzRXhwaXJlZCgpIHtcclxuICAgICAgICByZXR1cm4gdHlwZW9mIHRoaXMuZW50cnlFeHBpcmF0aW9uVGltZUluTVMgPT09ICdudW1iZXInICYmIERhdGUubm93KCkgLSB0aGlzLmNyZWF0ZWQgPiB0aGlzLmVudHJ5RXhwaXJhdGlvblRpbWVJbk1TO1xyXG4gICAgfVxyXG4gICAgaW52b2tlT25FdmljdGVkKCkge1xyXG4gICAgICAgIGlmICh0aGlzLm9uRW50cnlFdmljdGVkKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsga2V5LCB2YWx1ZSwgaXNFeHBpcmVkIH0gPSB0aGlzO1xyXG4gICAgICAgICAgICB0aGlzLm9uRW50cnlFdmljdGVkKHsga2V5LCB2YWx1ZSwgaXNFeHBpcmVkIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGludm9rZU9uRW50cnlNYXJrZWRBc01vc3RSZWNlbnRseVVzZWQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMub25FbnRyeU1hcmtlZEFzTW9zdFJlY2VudGx5VXNlZCkge1xyXG4gICAgICAgICAgICBjb25zdCB7IGtleSwgdmFsdWUgfSA9IHRoaXM7XHJcbiAgICAgICAgICAgIHRoaXMub25FbnRyeU1hcmtlZEFzTW9zdFJlY2VudGx5VXNlZCh7IGtleSwgdmFsdWUgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZGVmYXVsdENsb25lKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5MUlVDYWNoZU5vZGUgPSBMUlVDYWNoZU5vZGU7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxSVUNhY2hlTm9kZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/typescript-lru-cache/dist/LRUCacheNode.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/typescript-lru-cache/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/typescript-lru-cache/dist/index.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n      desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n__exportStar(__webpack_require__(/*! ./LRUCache */ \"(ssr)/./node_modules/typescript-lru-cache/dist/LRUCache.js\"), exports);\r\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdHlwZXNjcmlwdC1scnUtY2FjaGUvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLG1CQUFPLENBQUMsOEVBQVk7QUFDakMiLCJzb3VyY2VzIjpbIi9ob21lL2xmZy9HaXQvTWFkdHJpcHMvbm9kZV9tb2R1bGVzL3R5cGVzY3JpcHQtbHJ1LWNhY2hlL2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XHJcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xyXG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcclxufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBvW2syXSA9IG1ba107XHJcbn0pKTtcclxudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL0xSVUNhY2hlXCIpLCBleHBvcnRzKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/typescript-lru-cache/dist/index.js\n");

/***/ })

};
;