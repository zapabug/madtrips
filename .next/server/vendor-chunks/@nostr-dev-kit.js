"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@nostr-dev-kit";
exports.ids = ["vendor-chunks/@nostr-dev-kit"];
exports.modules = {

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk/dist/index.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/dist/index.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BECH32_REGEX: () => (/* binding */ BECH32_REGEX),\n/* harmony export */   NDKAppHandlerEvent: () => (/* binding */ NDKAppHandlerEvent),\n/* harmony export */   NDKAppSettings: () => (/* binding */ NDKAppSettings),\n/* harmony export */   NDKArticle: () => (/* binding */ NDKArticle),\n/* harmony export */   NDKCashuMintList: () => (/* binding */ NDKCashuMintList),\n/* harmony export */   NDKCashuToken: () => (/* binding */ NDKCashuToken),\n/* harmony export */   NDKCashuWalletTx: () => (/* binding */ NDKCashuWalletTx),\n/* harmony export */   NDKClassified: () => (/* binding */ NDKClassified),\n/* harmony export */   NDKDVMJobFeedback: () => (/* binding */ NDKDVMJobFeedback),\n/* harmony export */   NDKDVMJobResult: () => (/* binding */ NDKDVMJobResult),\n/* harmony export */   NDKDVMRequest: () => (/* binding */ NDKDVMRequest),\n/* harmony export */   NDKDraft: () => (/* binding */ NDKDraft),\n/* harmony export */   NDKDvmJobFeedbackStatus: () => (/* binding */ NDKDvmJobFeedbackStatus),\n/* harmony export */   NDKEvent: () => (/* binding */ NDKEvent),\n/* harmony export */   NDKHighlight: () => (/* binding */ NDKHighlight),\n/* harmony export */   NDKImage: () => (/* binding */ NDKImage),\n/* harmony export */   NDKKind: () => (/* binding */ NDKKind),\n/* harmony export */   NDKList: () => (/* binding */ NDKList),\n/* harmony export */   NDKListKinds: () => (/* binding */ NDKListKinds),\n/* harmony export */   NDKNip07Signer: () => (/* binding */ NDKNip07Signer),\n/* harmony export */   NDKNip46Backend: () => (/* binding */ NDKNip46Backend),\n/* harmony export */   NDKNip46Signer: () => (/* binding */ NDKNip46Signer),\n/* harmony export */   NDKNostrRpc: () => (/* binding */ NDKNostrRpc),\n/* harmony export */   NDKNutzap: () => (/* binding */ NDKNutzap),\n/* harmony export */   NDKPool: () => (/* binding */ NDKPool),\n/* harmony export */   NDKPrivateKeySigner: () => (/* binding */ NDKPrivateKeySigner),\n/* harmony export */   NDKPublishError: () => (/* binding */ NDKPublishError),\n/* harmony export */   NDKRelay: () => (/* binding */ NDKRelay),\n/* harmony export */   NDKRelayAuthPolicies: () => (/* binding */ NDKRelayAuthPolicies),\n/* harmony export */   NDKRelayList: () => (/* binding */ NDKRelayList),\n/* harmony export */   NDKRelaySet: () => (/* binding */ NDKRelaySet),\n/* harmony export */   NDKRelayStatus: () => (/* binding */ NDKRelayStatus),\n/* harmony export */   NDKRepost: () => (/* binding */ NDKRepost),\n/* harmony export */   NDKSimpleGroup: () => (/* binding */ NDKSimpleGroup),\n/* harmony export */   NDKSimpleGroupMemberList: () => (/* binding */ NDKSimpleGroupMemberList),\n/* harmony export */   NDKSimpleGroupMetadata: () => (/* binding */ NDKSimpleGroupMetadata),\n/* harmony export */   NDKSubscription: () => (/* binding */ NDKSubscription),\n/* harmony export */   NDKSubscriptionCacheUsage: () => (/* binding */ NDKSubscriptionCacheUsage),\n/* harmony export */   NDKSubscriptionReceipt: () => (/* binding */ NDKSubscriptionReceipt),\n/* harmony export */   NDKSubscriptionStart: () => (/* binding */ NDKSubscriptionStart),\n/* harmony export */   NDKSubscriptionTier: () => (/* binding */ NDKSubscriptionTier),\n/* harmony export */   NDKTranscriptionDVM: () => (/* binding */ NDKTranscriptionDVM),\n/* harmony export */   NDKUser: () => (/* binding */ NDKUser),\n/* harmony export */   NDKVideo: () => (/* binding */ NDKVideo),\n/* harmony export */   NDKWiki: () => (/* binding */ NDKWiki),\n/* harmony export */   NDKZapper: () => (/* binding */ NDKZapper),\n/* harmony export */   NIP33_A_REGEX: () => (/* binding */ NIP33_A_REGEX),\n/* harmony export */   calculateRelaySetFromEvent: () => (/* binding */ calculateRelaySetFromEvent),\n/* harmony export */   calculateTermDurationInSeconds: () => (/* binding */ calculateTermDurationInSeconds),\n/* harmony export */   compareFilter: () => (/* binding */ compareFilter),\n/* harmony export */   \"default\": () => (/* binding */ NDK),\n/* harmony export */   defaultOpts: () => (/* binding */ defaultOpts),\n/* harmony export */   deserialize: () => (/* binding */ deserialize),\n/* harmony export */   dvmSchedule: () => (/* binding */ dvmSchedule),\n/* harmony export */   eventHasETagMarkers: () => (/* binding */ eventHasETagMarkers),\n/* harmony export */   eventIsPartOfThread: () => (/* binding */ eventIsPartOfThread),\n/* harmony export */   eventIsReply: () => (/* binding */ eventIsReply),\n/* harmony export */   eventReplies: () => (/* binding */ eventReplies),\n/* harmony export */   eventThreadIds: () => (/* binding */ eventThreadIds),\n/* harmony export */   eventThreads: () => (/* binding */ eventThreads),\n/* harmony export */   eventsBySameAuthor: () => (/* binding */ eventsBySameAuthor),\n/* harmony export */   filterAndRelaySetFromBech32: () => (/* binding */ filterAndRelaySetFromBech32),\n/* harmony export */   filterFingerprint: () => (/* binding */ filterFingerprint),\n/* harmony export */   filterForEventsTaggingId: () => (/* binding */ filterForEventsTaggingId),\n/* harmony export */   filterFromId: () => (/* binding */ filterFromId),\n/* harmony export */   generateContentTags: () => (/* binding */ generateContentTags),\n/* harmony export */   generateHashtags: () => (/* binding */ generateHashtags),\n/* harmony export */   generateSubId: () => (/* binding */ generateSubId),\n/* harmony export */   generateZapRequest: () => (/* binding */ generateZapRequest),\n/* harmony export */   getEventReplyId: () => (/* binding */ getEventReplyId),\n/* harmony export */   getNip57ZapSpecFromLud: () => (/* binding */ getNip57ZapSpecFromLud),\n/* harmony export */   getRelayListForUser: () => (/* binding */ getRelayListForUser),\n/* harmony export */   getRelayListForUsers: () => (/* binding */ getRelayListForUsers),\n/* harmony export */   getReplyTag: () => (/* binding */ getReplyTag),\n/* harmony export */   getRootEventId: () => (/* binding */ getRootEventId),\n/* harmony export */   getRootTag: () => (/* binding */ getRootTag),\n/* harmony export */   imetaTagToTag: () => (/* binding */ imetaTagToTag),\n/* harmony export */   isEventOriginalPost: () => (/* binding */ isEventOriginalPost),\n/* harmony export */   isNip33AValue: () => (/* binding */ isNip33AValue),\n/* harmony export */   mapImetaTag: () => (/* binding */ mapImetaTag),\n/* harmony export */   matchFilter: () => (/* binding */ matchFilter),\n/* harmony export */   mergeFilters: () => (/* binding */ mergeFilters),\n/* harmony export */   mergeTags: () => (/* binding */ mergeTags),\n/* harmony export */   newAmount: () => (/* binding */ newAmount),\n/* harmony export */   normalize: () => (/* binding */ normalize),\n/* harmony export */   normalizeRelayUrl: () => (/* binding */ normalizeRelayUrl),\n/* harmony export */   normalizeUrl: () => (/* binding */ normalizeUrl),\n/* harmony export */   parseTagToSubscriptionAmount: () => (/* binding */ parseTagToSubscriptionAmount),\n/* harmony export */   pinEvent: () => (/* binding */ pinEvent),\n/* harmony export */   possibleIntervalFrequencies: () => (/* binding */ possibleIntervalFrequencies),\n/* harmony export */   profileFromEvent: () => (/* binding */ profileFromEvent),\n/* harmony export */   proofP2pk: () => (/* binding */ proofP2pk),\n/* harmony export */   proofP2pkNostr: () => (/* binding */ proofP2pkNostr),\n/* harmony export */   proofsTotalBalance: () => (/* binding */ proofsTotalBalance),\n/* harmony export */   queryFullyFilled: () => (/* binding */ queryFullyFilled),\n/* harmony export */   relayListFromKind3: () => (/* binding */ relayListFromKind3),\n/* harmony export */   relaysFromBech32: () => (/* binding */ relaysFromBech32),\n/* harmony export */   serialize: () => (/* binding */ serialize),\n/* harmony export */   serializeProfile: () => (/* binding */ serializeProfile),\n/* harmony export */   tryNormalizeRelayUrl: () => (/* binding */ tryNormalizeRelayUrl),\n/* harmony export */   uniqueTag: () => (/* binding */ uniqueTag),\n/* harmony export */   wrapEvent: () => (/* binding */ wrapEvent),\n/* harmony export */   zapInvoiceFromEvent: () => (/* binding */ zapInvoiceFromEvent)\n/* harmony export */ });\n/* harmony import */ var tseep__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tseep */ \"(ssr)/./node_modules/tseep/lib/index.js\");\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\");\n/* harmony import */ var nostr_tools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! nostr-tools */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/lib/esm/index.js\");\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(ssr)/./node_modules/@noble/curves/esm/secp256k1.js\");\n/* harmony import */ var typescript_lru_cache__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! typescript-lru-cache */ \"(ssr)/./node_modules/typescript-lru-cache/dist/index.js\");\n/* harmony import */ var light_bolt11_decoder__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! light-bolt11-decoder */ \"(ssr)/./node_modules/light-bolt11-decoder/bolt11.js\");\n/* harmony import */ var _scure_base__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @scure/base */ \"(ssr)/./node_modules/@scure/base/lib/esm/index.js\");\n// src/events/kinds/index.ts\nvar NDKKind = /* @__PURE__ */ ((NDKKind2) => {\n  NDKKind2[NDKKind2[\"Metadata\"] = 0] = \"Metadata\";\n  NDKKind2[NDKKind2[\"Text\"] = 1] = \"Text\";\n  NDKKind2[NDKKind2[\"RecommendRelay\"] = 2] = \"RecommendRelay\";\n  NDKKind2[NDKKind2[\"Contacts\"] = 3] = \"Contacts\";\n  NDKKind2[NDKKind2[\"EncryptedDirectMessage\"] = 4] = \"EncryptedDirectMessage\";\n  NDKKind2[NDKKind2[\"EventDeletion\"] = 5] = \"EventDeletion\";\n  NDKKind2[NDKKind2[\"Repost\"] = 6] = \"Repost\";\n  NDKKind2[NDKKind2[\"Reaction\"] = 7] = \"Reaction\";\n  NDKKind2[NDKKind2[\"BadgeAward\"] = 8] = \"BadgeAward\";\n  NDKKind2[NDKKind2[\"GroupChat\"] = 9] = \"GroupChat\";\n  NDKKind2[NDKKind2[\"GroupNote\"] = 11] = \"GroupNote\";\n  NDKKind2[NDKKind2[\"GroupReply\"] = 12] = \"GroupReply\";\n  NDKKind2[NDKKind2[\"GiftWrapSeal\"] = 13] = \"GiftWrapSeal\";\n  NDKKind2[NDKKind2[\"PrivateDirectMessage\"] = 14] = \"PrivateDirectMessage\";\n  NDKKind2[NDKKind2[\"Image\"] = 20] = \"Image\";\n  NDKKind2[NDKKind2[\"Vanish\"] = 62] = \"Vanish\";\n  NDKKind2[NDKKind2[\"GiftWrap\"] = 1059] = \"GiftWrap\";\n  NDKKind2[NDKKind2[\"GenericRepost\"] = 16] = \"GenericRepost\";\n  NDKKind2[NDKKind2[\"ChannelCreation\"] = 40] = \"ChannelCreation\";\n  NDKKind2[NDKKind2[\"ChannelMetadata\"] = 41] = \"ChannelMetadata\";\n  NDKKind2[NDKKind2[\"ChannelMessage\"] = 42] = \"ChannelMessage\";\n  NDKKind2[NDKKind2[\"ChannelHideMessage\"] = 43] = \"ChannelHideMessage\";\n  NDKKind2[NDKKind2[\"ChannelMuteUser\"] = 44] = \"ChannelMuteUser\";\n  NDKKind2[NDKKind2[\"GenericReply\"] = 1111] = \"GenericReply\";\n  NDKKind2[NDKKind2[\"Media\"] = 1063] = \"Media\";\n  NDKKind2[NDKKind2[\"Report\"] = 1984] = \"Report\";\n  NDKKind2[NDKKind2[\"Label\"] = 1985] = \"Label\";\n  NDKKind2[NDKKind2[\"DVMReqTextExtraction\"] = 5e3] = \"DVMReqTextExtraction\";\n  NDKKind2[NDKKind2[\"DVMReqTextSummarization\"] = 5001] = \"DVMReqTextSummarization\";\n  NDKKind2[NDKKind2[\"DVMReqTextTranslation\"] = 5002] = \"DVMReqTextTranslation\";\n  NDKKind2[NDKKind2[\"DVMReqTextGeneration\"] = 5050] = \"DVMReqTextGeneration\";\n  NDKKind2[NDKKind2[\"DVMReqImageGeneration\"] = 5100] = \"DVMReqImageGeneration\";\n  NDKKind2[NDKKind2[\"DVMReqTextToSpeech\"] = 5250] = \"DVMReqTextToSpeech\";\n  NDKKind2[NDKKind2[\"DVMReqDiscoveryNostrContent\"] = 5300] = \"DVMReqDiscoveryNostrContent\";\n  NDKKind2[NDKKind2[\"DVMReqDiscoveryNostrPeople\"] = 5301] = \"DVMReqDiscoveryNostrPeople\";\n  NDKKind2[NDKKind2[\"DVMReqTimestamping\"] = 5900] = \"DVMReqTimestamping\";\n  NDKKind2[NDKKind2[\"DVMEventSchedule\"] = 5905] = \"DVMEventSchedule\";\n  NDKKind2[NDKKind2[\"DVMJobFeedback\"] = 7e3] = \"DVMJobFeedback\";\n  NDKKind2[NDKKind2[\"Subscribe\"] = 7001] = \"Subscribe\";\n  NDKKind2[NDKKind2[\"Unsubscribe\"] = 7002] = \"Unsubscribe\";\n  NDKKind2[NDKKind2[\"SubscriptionReceipt\"] = 7003] = \"SubscriptionReceipt\";\n  NDKKind2[NDKKind2[\"CashuReserve\"] = 7373] = \"CashuReserve\";\n  NDKKind2[NDKKind2[\"CashuQuote\"] = 7374] = \"CashuQuote\";\n  NDKKind2[NDKKind2[\"CashuToken\"] = 7375] = \"CashuToken\";\n  NDKKind2[NDKKind2[\"CashuWalletTx\"] = 7376] = \"CashuWalletTx\";\n  NDKKind2[NDKKind2[\"GroupAdminAddUser\"] = 9e3] = \"GroupAdminAddUser\";\n  NDKKind2[NDKKind2[\"GroupAdminRemoveUser\"] = 9001] = \"GroupAdminRemoveUser\";\n  NDKKind2[NDKKind2[\"GroupAdminEditMetadata\"] = 9002] = \"GroupAdminEditMetadata\";\n  NDKKind2[NDKKind2[\"GroupAdminEditStatus\"] = 9006] = \"GroupAdminEditStatus\";\n  NDKKind2[NDKKind2[\"GroupAdminCreateGroup\"] = 9007] = \"GroupAdminCreateGroup\";\n  NDKKind2[NDKKind2[\"GroupAdminRequestJoin\"] = 9021] = \"GroupAdminRequestJoin\";\n  NDKKind2[NDKKind2[\"MuteList\"] = 1e4] = \"MuteList\";\n  NDKKind2[NDKKind2[\"PinList\"] = 10001] = \"PinList\";\n  NDKKind2[NDKKind2[\"RelayList\"] = 10002] = \"RelayList\";\n  NDKKind2[NDKKind2[\"BookmarkList\"] = 10003] = \"BookmarkList\";\n  NDKKind2[NDKKind2[\"CommunityList\"] = 10004] = \"CommunityList\";\n  NDKKind2[NDKKind2[\"PublicChatList\"] = 10005] = \"PublicChatList\";\n  NDKKind2[NDKKind2[\"BlockRelayList\"] = 10006] = \"BlockRelayList\";\n  NDKKind2[NDKKind2[\"SearchRelayList\"] = 10007] = \"SearchRelayList\";\n  NDKKind2[NDKKind2[\"SimpleGroupList\"] = 10009] = \"SimpleGroupList\";\n  NDKKind2[NDKKind2[\"InterestList\"] = 10015] = \"InterestList\";\n  NDKKind2[NDKKind2[\"CashuMintList\"] = 10019] = \"CashuMintList\";\n  NDKKind2[NDKKind2[\"EmojiList\"] = 10030] = \"EmojiList\";\n  NDKKind2[NDKKind2[\"DirectMessageReceiveRelayList\"] = 10050] = \"DirectMessageReceiveRelayList\";\n  NDKKind2[NDKKind2[\"BlossomList\"] = 10063] = \"BlossomList\";\n  NDKKind2[NDKKind2[\"NostrWaletConnectInfo\"] = 13194] = \"NostrWaletConnectInfo\";\n  NDKKind2[NDKKind2[\"TierList\"] = 17e3] = \"TierList\";\n  NDKKind2[NDKKind2[\"CashuWallet\"] = 17375] = \"CashuWallet\";\n  NDKKind2[NDKKind2[\"FollowSet\"] = 3e4] = \"FollowSet\";\n  NDKKind2[NDKKind2[\"CategorizedPeopleList\"] = 3e4 /* FollowSet */] = \"CategorizedPeopleList\";\n  NDKKind2[NDKKind2[\"CategorizedBookmarkList\"] = 30001] = \"CategorizedBookmarkList\";\n  NDKKind2[NDKKind2[\"RelaySet\"] = 30002] = \"RelaySet\";\n  NDKKind2[NDKKind2[\"CategorizedRelayList\"] = 30002 /* RelaySet */] = \"CategorizedRelayList\";\n  NDKKind2[NDKKind2[\"BookmarkSet\"] = 30003] = \"BookmarkSet\";\n  NDKKind2[NDKKind2[\"CurationSet\"] = 30004] = \"CurationSet\";\n  NDKKind2[NDKKind2[\"ArticleCurationSet\"] = 30004] = \"ArticleCurationSet\";\n  NDKKind2[NDKKind2[\"VideoCurationSet\"] = 30005] = \"VideoCurationSet\";\n  NDKKind2[NDKKind2[\"ImageCurationSet\"] = 30006] = \"ImageCurationSet\";\n  NDKKind2[NDKKind2[\"InterestSet\"] = 30015] = \"InterestSet\";\n  NDKKind2[NDKKind2[\"InterestsList\"] = 30015 /* InterestSet */] = \"InterestsList\";\n  NDKKind2[NDKKind2[\"EmojiSet\"] = 30030] = \"EmojiSet\";\n  NDKKind2[NDKKind2[\"ModularArticle\"] = 30040] = \"ModularArticle\";\n  NDKKind2[NDKKind2[\"ModularArticleItem\"] = 30041] = \"ModularArticleItem\";\n  NDKKind2[NDKKind2[\"Wiki\"] = 30818] = \"Wiki\";\n  NDKKind2[NDKKind2[\"Draft\"] = 31234] = \"Draft\";\n  NDKKind2[NDKKind2[\"SubscriptionTier\"] = 37001] = \"SubscriptionTier\";\n  NDKKind2[NDKKind2[\"EcashMintRecommendation\"] = 38e3] = \"EcashMintRecommendation\";\n  NDKKind2[NDKKind2[\"HighlightSet\"] = 39802] = \"HighlightSet\";\n  NDKKind2[NDKKind2[\"CategorizedHighlightList\"] = 39802 /* HighlightSet */] = \"CategorizedHighlightList\";\n  NDKKind2[NDKKind2[\"Nutzap\"] = 9321] = \"Nutzap\";\n  NDKKind2[NDKKind2[\"ZapRequest\"] = 9734] = \"ZapRequest\";\n  NDKKind2[NDKKind2[\"Zap\"] = 9735] = \"Zap\";\n  NDKKind2[NDKKind2[\"Highlight\"] = 9802] = \"Highlight\";\n  NDKKind2[NDKKind2[\"ClientAuth\"] = 22242] = \"ClientAuth\";\n  NDKKind2[NDKKind2[\"NostrWalletConnectReq\"] = 23194] = \"NostrWalletConnectReq\";\n  NDKKind2[NDKKind2[\"NostrWalletConnectRes\"] = 23195] = \"NostrWalletConnectRes\";\n  NDKKind2[NDKKind2[\"NostrConnect\"] = 24133] = \"NostrConnect\";\n  NDKKind2[NDKKind2[\"BlossomUpload\"] = 24242] = \"BlossomUpload\";\n  NDKKind2[NDKKind2[\"HttpAuth\"] = 27235] = \"HttpAuth\";\n  NDKKind2[NDKKind2[\"ProfileBadge\"] = 30008] = \"ProfileBadge\";\n  NDKKind2[NDKKind2[\"BadgeDefinition\"] = 30009] = \"BadgeDefinition\";\n  NDKKind2[NDKKind2[\"MarketStall\"] = 30017] = \"MarketStall\";\n  NDKKind2[NDKKind2[\"MarketProduct\"] = 30018] = \"MarketProduct\";\n  NDKKind2[NDKKind2[\"Article\"] = 30023] = \"Article\";\n  NDKKind2[NDKKind2[\"AppSpecificData\"] = 30078] = \"AppSpecificData\";\n  NDKKind2[NDKKind2[\"Classified\"] = 30402] = \"Classified\";\n  NDKKind2[NDKKind2[\"HorizontalVideo\"] = 34235] = \"HorizontalVideo\";\n  NDKKind2[NDKKind2[\"VerticalVideo\"] = 34236] = \"VerticalVideo\";\n  NDKKind2[NDKKind2[\"LegacyCashuWallet\"] = 37375] = \"LegacyCashuWallet\";\n  NDKKind2[NDKKind2[\"GroupMetadata\"] = 39e3] = \"GroupMetadata\";\n  NDKKind2[NDKKind2[\"GroupAdmins\"] = 39001] = \"GroupAdmins\";\n  NDKKind2[NDKKind2[\"GroupMembers\"] = 39002] = \"GroupMembers\";\n  NDKKind2[NDKKind2[\"AppRecommendation\"] = 31989] = \"AppRecommendation\";\n  NDKKind2[NDKKind2[\"AppHandler\"] = 31990] = \"AppHandler\";\n  return NDKKind2;\n})(NDKKind || {});\nvar NDKListKinds = [\n  1e4 /* MuteList */,\n  10001 /* PinList */,\n  10002 /* RelayList */,\n  10003 /* BookmarkList */,\n  10004 /* CommunityList */,\n  10005 /* PublicChatList */,\n  10006 /* BlockRelayList */,\n  10007 /* SearchRelayList */,\n  10015 /* InterestList */,\n  10030 /* EmojiList */,\n  10050 /* DirectMessageReceiveRelayList */,\n  3e4 /* FollowSet */,\n  30003 /* BookmarkSet */,\n  30001 /* CategorizedBookmarkList */,\n  // Backwards compatibility\n  30002 /* RelaySet */,\n  30004 /* ArticleCurationSet */,\n  30005 /* VideoCurationSet */,\n  30015 /* InterestSet */,\n  30030 /* EmojiSet */,\n  39802 /* HighlightSet */\n];\n\n// src/events/index.ts\n\n\n// src/outbox/write.ts\nfunction getRelaysForSync(ndk, author, type = \"write\") {\n  if (!ndk.outboxTracker) return void 0;\n  const item = ndk.outboxTracker.data.get(author);\n  if (!item) return void 0;\n  if (type === \"write\") {\n    return item.writeRelays;\n  } else {\n    return item.readRelays;\n  }\n}\nasync function getWriteRelaysFor(ndk, author, type = \"write\") {\n  if (!ndk.outboxTracker) return void 0;\n  if (!ndk.outboxTracker.data.has(author)) {\n    await ndk.outboxTracker.trackUsers([author]);\n  }\n  return getRelaysForSync(ndk, author, type);\n}\n\n// src/outbox/relay-ranking.ts\nfunction getTopRelaysForAuthors(ndk, authors) {\n  const relaysWithCount = /* @__PURE__ */ new Map();\n  authors.forEach((author) => {\n    const writeRelays = getRelaysForSync(ndk, author);\n    if (writeRelays) {\n      writeRelays.forEach((relay) => {\n        const count = relaysWithCount.get(relay) || 0;\n        relaysWithCount.set(relay, count + 1);\n      });\n    }\n  });\n  const sortedRelays = Array.from(relaysWithCount.entries()).sort((a, b) => b[1] - a[1]);\n  return sortedRelays.map((entry) => entry[0]);\n}\n\n// src/outbox/index.ts\nfunction getAllRelaysForAllPubkeys(ndk, pubkeys, type = \"read\") {\n  const pubkeysToRelays = /* @__PURE__ */ new Map();\n  const authorsMissingRelays = /* @__PURE__ */ new Set();\n  pubkeys.forEach((pubkey) => {\n    const relays = getRelaysForSync(ndk, pubkey, type);\n    if (relays && relays.size > 0) {\n      relays.forEach((relay) => {\n        const pubkeysInRelay = pubkeysToRelays.get(relay) || /* @__PURE__ */ new Set();\n        pubkeysInRelay.add(pubkey);\n      });\n      pubkeysToRelays.set(pubkey, relays);\n    } else {\n      authorsMissingRelays.add(pubkey);\n    }\n  });\n  return { pubkeysToRelays, authorsMissingRelays };\n}\nfunction chooseRelayCombinationForPubkeys(ndk, pubkeys, type, { count, preferredRelays } = {}) {\n  count ??= 2;\n  preferredRelays ??= /* @__PURE__ */ new Set();\n  const pool = ndk.pool;\n  const connectedRelays = pool.connectedRelays();\n  connectedRelays.forEach((relay) => {\n    preferredRelays.add(relay.url);\n  });\n  const relayToAuthorsMap = /* @__PURE__ */ new Map();\n  const { pubkeysToRelays, authorsMissingRelays } = getAllRelaysForAllPubkeys(ndk, pubkeys, type);\n  const sortedRelays = getTopRelaysForAuthors(ndk, pubkeys);\n  const addAuthorToRelay = (author, relay) => {\n    const authorsInRelay = relayToAuthorsMap.get(relay) || [];\n    authorsInRelay.push(author);\n    relayToAuthorsMap.set(relay, authorsInRelay);\n  };\n  for (const [author, authorRelays] of pubkeysToRelays.entries()) {\n    let missingRelayCount = count;\n    for (const relay of connectedRelays) {\n      if (authorRelays.has(relay.url)) {\n        addAuthorToRelay(author, relay.url);\n        missingRelayCount--;\n      }\n    }\n    for (const authorRelay of authorRelays) {\n      if (relayToAuthorsMap.has(authorRelay)) {\n        addAuthorToRelay(author, authorRelay);\n        missingRelayCount--;\n      }\n    }\n    if (missingRelayCount <= 0) continue;\n    for (const relay of sortedRelays) {\n      if (missingRelayCount <= 0) break;\n      if (authorRelays.has(relay)) {\n        addAuthorToRelay(author, relay);\n        missingRelayCount--;\n      }\n    }\n  }\n  for (const author of authorsMissingRelays) {\n    pool.permanentAndConnectedRelays().forEach((relay) => {\n      const authorsInRelay = relayToAuthorsMap.get(relay.url) || [];\n      authorsInRelay.push(author);\n      relayToAuthorsMap.set(relay.url, authorsInRelay);\n    });\n  }\n  return relayToAuthorsMap;\n}\n\n// src/outbox/read/with-authors.ts\nfunction getRelaysForFilterWithAuthors(ndk, authors, relayGoalPerAuthor = 2) {\n  return chooseRelayCombinationForPubkeys(ndk, authors, \"write\", { count: relayGoalPerAuthor });\n}\n\n// src/utils/normalize-url.ts\nfunction tryNormalizeRelayUrl(url) {\n  try {\n    return normalizeRelayUrl(url);\n  } catch {\n    return void 0;\n  }\n}\nfunction normalizeRelayUrl(url) {\n  let r = normalizeUrl(url, {\n    stripAuthentication: false,\n    stripWWW: false,\n    stripHash: true\n  });\n  if (!r.endsWith(\"/\")) {\n    r += \"/\";\n  }\n  return r;\n}\nfunction normalize(urls) {\n  const normalized = /* @__PURE__ */ new Set();\n  for (const url of urls) {\n    try {\n      normalized.add(normalizeRelayUrl(url));\n    } catch {\n    }\n  }\n  return Array.from(normalized);\n}\nvar DATA_URL_DEFAULT_MIME_TYPE = \"text/plain\";\nvar DATA_URL_DEFAULT_CHARSET = \"us-ascii\";\nvar testParameter = (name, filters) => filters.some((filter) => filter instanceof RegExp ? filter.test(name) : filter === name);\nvar supportedProtocols = /* @__PURE__ */ new Set([\"https:\", \"http:\", \"file:\"]);\nvar hasCustomProtocol = (urlString) => {\n  try {\n    const { protocol } = new URL(urlString);\n    return protocol.endsWith(\":\") && !protocol.includes(\".\") && !supportedProtocols.has(protocol);\n  } catch {\n    return false;\n  }\n};\nvar normalizeDataURL = (urlString, { stripHash }) => {\n  const match = /^data:(?<type>[^,]*?),(?<data>[^#]*?)(?:#(?<hash>.*))?$/.exec(urlString);\n  if (!match) {\n    throw new Error(`Invalid URL: ${urlString}`);\n  }\n  let type = match.groups?.type ?? \"\";\n  let data = match.groups?.data ?? \"\";\n  let hash = match.groups?.hash ?? \"\";\n  const mediaType = type.split(\";\");\n  hash = stripHash ? \"\" : hash;\n  let isBase64 = false;\n  if (mediaType[mediaType.length - 1] === \"base64\") {\n    mediaType.pop();\n    isBase64 = true;\n  }\n  const mimeType = mediaType.shift()?.toLowerCase() ?? \"\";\n  const attributes = mediaType.map((attribute) => {\n    let [key, value = \"\"] = attribute.split(\"=\").map((string) => string.trim());\n    if (key === \"charset\") {\n      value = value.toLowerCase();\n      if (value === DATA_URL_DEFAULT_CHARSET) {\n        return \"\";\n      }\n    }\n    return `${key}${value ? `=${value}` : \"\"}`;\n  }).filter(Boolean);\n  const normalizedMediaType = [...attributes];\n  if (isBase64) {\n    normalizedMediaType.push(\"base64\");\n  }\n  if (normalizedMediaType.length > 0 || mimeType && mimeType !== DATA_URL_DEFAULT_MIME_TYPE) {\n    normalizedMediaType.unshift(mimeType);\n  }\n  return `data:${normalizedMediaType.join(\";\")},${isBase64 ? data.trim() : data}${hash ? `#${hash}` : \"\"}`;\n};\nfunction normalizeUrl(urlString, options = {}) {\n  options = {\n    defaultProtocol: \"http\",\n    normalizeProtocol: true,\n    forceHttp: false,\n    forceHttps: false,\n    stripAuthentication: true,\n    stripHash: false,\n    stripTextFragment: true,\n    stripWWW: true,\n    removeQueryParameters: [/^utm_\\w+/i],\n    removeTrailingSlash: true,\n    removeSingleSlash: true,\n    removeDirectoryIndex: false,\n    removeExplicitPort: false,\n    sortQueryParameters: true,\n    ...options\n  };\n  if (typeof options.defaultProtocol === \"string\" && !options.defaultProtocol.endsWith(\":\")) {\n    options.defaultProtocol = `${options.defaultProtocol}:`;\n  }\n  urlString = urlString.trim();\n  if (/^data:/i.test(urlString)) {\n    return normalizeDataURL(urlString, options);\n  }\n  if (hasCustomProtocol(urlString)) {\n    return urlString;\n  }\n  const hasRelativeProtocol = urlString.startsWith(\"//\");\n  const isRelativeUrl = !hasRelativeProtocol && /^\\.*\\//.test(urlString);\n  if (!isRelativeUrl) {\n    urlString = urlString.replace(/^(?!(?:\\w+:)?\\/\\/)|^\\/\\//, options.defaultProtocol);\n  }\n  const urlObject = new URL(urlString);\n  urlObject.hostname = urlObject.hostname.toLowerCase();\n  if (options.forceHttp && options.forceHttps) {\n    throw new Error(\"The `forceHttp` and `forceHttps` options cannot be used together\");\n  }\n  if (options.forceHttp && urlObject.protocol === \"https:\") {\n    urlObject.protocol = \"http:\";\n  }\n  if (options.forceHttps && urlObject.protocol === \"http:\") {\n    urlObject.protocol = \"https:\";\n  }\n  if (options.stripAuthentication) {\n    urlObject.username = \"\";\n    urlObject.password = \"\";\n  }\n  if (options.stripHash) {\n    urlObject.hash = \"\";\n  } else if (options.stripTextFragment) {\n    urlObject.hash = urlObject.hash.replace(/#?:~:text.*?$/i, \"\");\n  }\n  if (urlObject.pathname) {\n    const protocolRegex = /\\b[a-z][a-z\\d+\\-.]{1,50}:\\/\\//g;\n    let lastIndex = 0;\n    let result = \"\";\n    for (; ; ) {\n      const match = protocolRegex.exec(urlObject.pathname);\n      if (!match) {\n        break;\n      }\n      const protocol = match[0];\n      const protocolAtIndex = match.index;\n      const intermediate = urlObject.pathname.slice(lastIndex, protocolAtIndex);\n      result += intermediate.replace(/\\/{2,}/g, \"/\");\n      result += protocol;\n      lastIndex = protocolAtIndex + protocol.length;\n    }\n    const remnant = urlObject.pathname.slice(lastIndex, urlObject.pathname.length);\n    result += remnant.replace(/\\/{2,}/g, \"/\");\n    urlObject.pathname = result;\n  }\n  if (urlObject.pathname) {\n    try {\n      urlObject.pathname = decodeURI(urlObject.pathname);\n    } catch {\n    }\n  }\n  if (options.removeDirectoryIndex === true) {\n    options.removeDirectoryIndex = [/^index\\.[a-z]+$/];\n  }\n  if (Array.isArray(options.removeDirectoryIndex) && options.removeDirectoryIndex.length > 0) {\n    let pathComponents = urlObject.pathname.split(\"/\");\n    const lastComponent = pathComponents[pathComponents.length - 1];\n    if (testParameter(lastComponent, options.removeDirectoryIndex)) {\n      pathComponents = pathComponents.slice(0, -1);\n      urlObject.pathname = pathComponents.slice(1).join(\"/\") + \"/\";\n    }\n  }\n  if (urlObject.hostname) {\n    urlObject.hostname = urlObject.hostname.replace(/\\.$/, \"\");\n    if (options.stripWWW && /^www\\.(?!www\\.)[a-z\\-\\d]{1,63}\\.[a-z.\\-\\d]{2,63}$/.test(urlObject.hostname)) {\n      urlObject.hostname = urlObject.hostname.replace(/^www\\./, \"\");\n    }\n  }\n  if (Array.isArray(options.removeQueryParameters)) {\n    for (const key of [...urlObject.searchParams.keys()]) {\n      if (testParameter(key, options.removeQueryParameters)) {\n        urlObject.searchParams.delete(key);\n      }\n    }\n  }\n  if (!Array.isArray(options.keepQueryParameters) && options.removeQueryParameters === true) {\n    urlObject.search = \"\";\n  }\n  if (Array.isArray(options.keepQueryParameters) && options.keepQueryParameters.length > 0) {\n    for (const key of [...urlObject.searchParams.keys()]) {\n      if (!testParameter(key, options.keepQueryParameters)) {\n        urlObject.searchParams.delete(key);\n      }\n    }\n  }\n  if (options.sortQueryParameters) {\n    urlObject.searchParams.sort();\n    try {\n      urlObject.search = decodeURIComponent(urlObject.search);\n    } catch {\n    }\n  }\n  if (options.removeTrailingSlash) {\n    urlObject.pathname = urlObject.pathname.replace(/\\/$/, \"\");\n  }\n  if (options.removeExplicitPort && urlObject.port) {\n    urlObject.port = \"\";\n  }\n  const oldUrlString = urlString;\n  urlString = urlObject.toString();\n  if (!options.removeSingleSlash && urlObject.pathname === \"/\" && !oldUrlString.endsWith(\"/\") && urlObject.hash === \"\") {\n    urlString = urlString.replace(/\\/$/, \"\");\n  }\n  if ((options.removeTrailingSlash || urlObject.pathname === \"/\") && urlObject.hash === \"\" && options.removeSingleSlash) {\n    urlString = urlString.replace(/\\/$/, \"\");\n  }\n  if (hasRelativeProtocol && !options.normalizeProtocol) {\n    urlString = urlString.replace(/^http:\\/\\//, \"//\");\n  }\n  if (options.stripProtocol) {\n    urlString = urlString.replace(/^(?:https?:)?\\/\\//, \"\");\n  }\n  return urlString;\n}\n\n// src/relay/index.ts\n\n\n\n// src/relay/connectivity.ts\nvar MAX_RECONNECT_ATTEMPTS = 5;\nvar FLAPPING_THRESHOLD_MS = 1e3;\nvar NDKRelayConnectivity = class {\n  ndkRelay;\n  ws;\n  _status;\n  timeoutMs;\n  connectedAt;\n  _connectionStats = {\n    attempts: 0,\n    success: 0,\n    durations: []\n  };\n  debug;\n  netDebug;\n  connectTimeout;\n  reconnectTimeout;\n  ndk;\n  openSubs = /* @__PURE__ */ new Map();\n  openCountRequests = /* @__PURE__ */ new Map();\n  openEventPublishes = /* @__PURE__ */ new Map();\n  serial = 0;\n  baseEoseTimeout = 4400;\n  constructor(ndkRelay, ndk) {\n    this.ndkRelay = ndkRelay;\n    this._status = 1 /* DISCONNECTED */;\n    const rand = Math.floor(Math.random() * 1e3);\n    this.debug = this.ndkRelay.debug.extend(\"connectivity\" + rand);\n    this.ndk = ndk;\n  }\n  /**\n   * Connects to the NDK relay and handles the connection lifecycle.\n   *\n   * This method attempts to establish a WebSocket connection to the NDK relay specified in the `ndkRelay` object.\n   * If the connection is successful, it updates the connection statistics, sets the connection status to `CONNECTED`,\n   * and emits `connect` and `ready` events on the `ndkRelay` object.\n   *\n   * If the connection attempt fails, it handles the error by either initiating a reconnection attempt or emitting a\n   * `delayed-connect` event on the `ndkRelay` object, depending on the `reconnect` parameter.\n   *\n   * @param timeoutMs - The timeout in milliseconds for the connection attempt. If not provided, the default timeout from the `ndkRelay` object is used.\n   * @param reconnect - Indicates whether a reconnection should be attempted if the connection fails. Defaults to `true`.\n   * @returns A Promise that resolves when the connection is established, or rejects if the connection fails.\n   */\n  async connect(timeoutMs, reconnect = true) {\n    if (this._status !== 2 /* RECONNECTING */ && this._status !== 1 /* DISCONNECTED */ || this.reconnectTimeout) {\n      this.debug(\n        \"Relay requested to be connected but was in state %s or it had a reconnect timeout\",\n        this._status\n      );\n      return;\n    }\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = void 0;\n    }\n    if (this.connectTimeout) {\n      clearTimeout(this.connectTimeout);\n      this.connectTimeout = void 0;\n    }\n    timeoutMs ??= this.timeoutMs;\n    if (!this.timeoutMs && timeoutMs) this.timeoutMs = timeoutMs;\n    if (this.timeoutMs)\n      this.connectTimeout = setTimeout(\n        () => this.onConnectionError(reconnect),\n        this.timeoutMs\n      );\n    try {\n      this.updateConnectionStats.attempt();\n      if (this._status === 1 /* DISCONNECTED */)\n        this._status = 4 /* CONNECTING */;\n      else this._status = 2 /* RECONNECTING */;\n      this.ws = new WebSocket(this.ndkRelay.url);\n      this.ws.onopen = this.onConnect.bind(this);\n      this.ws.onclose = this.onDisconnect.bind(this);\n      this.ws.onmessage = this.onMessage.bind(this);\n      this.ws.onerror = this.onError.bind(this);\n    } catch (e) {\n      this.debug(`Failed to connect to ${this.ndkRelay.url}`, e);\n      this._status = 1 /* DISCONNECTED */;\n      if (reconnect) this.handleReconnection();\n      else this.ndkRelay.emit(\"delayed-connect\", 2 * 24 * 60 * 60 * 1e3);\n      throw e;\n    }\n  }\n  /**\n   * Disconnects the WebSocket connection to the NDK relay.\n   * This method sets the connection status to `NDKRelayStatus.DISCONNECTING`,\n   * attempts to close the WebSocket connection, and sets the status to\n   * `NDKRelayStatus.DISCONNECTED` if the disconnect operation fails.\n   */\n  disconnect() {\n    this._status = 0 /* DISCONNECTING */;\n    try {\n      this.ws?.close();\n    } catch (e) {\n      this.debug(\"Failed to disconnect\", e);\n      this._status = 1 /* DISCONNECTED */;\n    }\n  }\n  /**\n   * Handles the error that occurred when attempting to connect to the NDK relay.\n   * If `reconnect` is `true`, this method will initiate a reconnection attempt.\n   * Otherwise, it will emit a `delayed-connect` event on the `ndkRelay` object,\n   * indicating that a reconnection should be attempted after a delay.\n   *\n   * @param reconnect - Indicates whether a reconnection should be attempted.\n   */\n  onConnectionError(reconnect) {\n    this.debug(`Error connecting to ${this.ndkRelay.url}`, this.timeoutMs);\n    if (reconnect && !this.reconnectTimeout) {\n      this.handleReconnection();\n    }\n  }\n  /**\n   * Handles the connection event when the WebSocket connection is established.\n   * This method is called when the WebSocket connection is successfully opened.\n   * It clears any existing connection and reconnection timeouts, updates the connection statistics,\n   * sets the connection status to `CONNECTED`, and emits `connect` and `ready` events on the `ndkRelay` object.\n   */\n  onConnect() {\n    this.netDebug?.(\"connected\", this.ndkRelay);\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = void 0;\n    }\n    if (this.connectTimeout) {\n      clearTimeout(this.connectTimeout);\n      this.connectTimeout = void 0;\n    }\n    this.updateConnectionStats.connected();\n    this._status = 5 /* CONNECTED */;\n    this.ndkRelay.emit(\"connect\");\n    this.ndkRelay.emit(\"ready\");\n  }\n  /**\n   * Handles the disconnection event when the WebSocket connection is closed.\n   * This method is called when the WebSocket connection is successfully closed.\n   * It updates the connection statistics, sets the connection status to `DISCONNECTED`,\n   * initiates a reconnection attempt if we didn't disconnect ourselves,\n   * and emits a `disconnect` event on the `ndkRelay` object.\n   */\n  onDisconnect() {\n    this.netDebug?.(\"disconnected\", this.ndkRelay);\n    this.updateConnectionStats.disconnected();\n    if (this._status === 5 /* CONNECTED */) {\n      this.handleReconnection();\n    }\n    this._status = 1 /* DISCONNECTED */;\n    this.ndkRelay.emit(\"disconnect\");\n  }\n  /**\n   * Handles incoming messages from the NDK relay WebSocket connection.\n   * This method is called whenever a message is received from the relay.\n   * It parses the message data and dispatches the appropriate handling logic based on the message type.\n   *\n   * @param event - The MessageEvent containing the received message data.\n   */\n  onMessage(event) {\n    this.netDebug?.(event.data, this.ndkRelay, \"recv\");\n    try {\n      const data = JSON.parse(event.data);\n      const [cmd, id, ...rest] = data;\n      switch (cmd) {\n        case \"EVENT\": {\n          const so = this.openSubs.get(id);\n          const event2 = data[2];\n          if (!so) {\n            this.debug(`Received event for unknown subscription ${id}`);\n            return;\n          }\n          so.onevent(event2);\n          return;\n        }\n        case \"COUNT\": {\n          const payload = data[2];\n          const cr = this.openCountRequests.get(id);\n          if (cr) {\n            cr.resolve(payload.count);\n            this.openCountRequests.delete(id);\n          }\n          return;\n        }\n        case \"EOSE\": {\n          const so = this.openSubs.get(id);\n          if (!so) return;\n          so.oneose(id);\n          return;\n        }\n        case \"OK\": {\n          const ok = data[2];\n          const reason = data[3];\n          const ep = this.openEventPublishes.get(id);\n          const firstEp = ep?.pop();\n          if (!ep || !firstEp) {\n            this.debug(\"Received OK for unknown event publish\", id);\n            return;\n          }\n          if (ok) firstEp.resolve(reason);\n          else firstEp.reject(new Error(reason));\n          if (ep.length === 0) {\n            this.openEventPublishes.delete(id);\n          } else {\n            this.openEventPublishes.set(id, ep);\n          }\n          return;\n        }\n        case \"CLOSED\": {\n          const so = this.openSubs.get(id);\n          if (!so) return;\n          so.onclosed(data[2]);\n          return;\n        }\n        case \"NOTICE\":\n          this.onNotice(data[1]);\n          return;\n        case \"AUTH\": {\n          this.onAuthRequested(data[1]);\n          return;\n        }\n      }\n    } catch (error) {\n      this.debug(\n        `Error parsing message from ${this.ndkRelay.url}: ${error.message}`,\n        error?.stack\n      );\n      return;\n    }\n  }\n  /**\n   * Handles an authentication request from the NDK relay.\n   *\n   * If an authentication policy is configured, it will be used to authenticate the connection.\n   * Otherwise, the `auth` event will be emitted to allow the application to handle the authentication.\n   *\n   * @param challenge - The authentication challenge provided by the NDK relay.\n   */\n  async onAuthRequested(challenge) {\n    const authPolicy = this.ndkRelay.authPolicy ?? this.ndk?.relayAuthDefaultPolicy;\n    this.debug(\"Relay requested authentication\", {\n      havePolicy: !!authPolicy\n    });\n    if (this._status === 7 /* AUTHENTICATING */) {\n      this.debug(\"Already authenticating, ignoring\");\n      return;\n    }\n    this._status = 6 /* AUTH_REQUESTED */;\n    if (authPolicy) {\n      if (this._status >= 5 /* CONNECTED */) {\n        this._status = 7 /* AUTHENTICATING */;\n        let res;\n        try {\n          res = await authPolicy(this.ndkRelay, challenge);\n        } catch (e) {\n          this.debug(\"Authentication policy threw an error\", e);\n          res = false;\n        }\n        this.debug(\"Authentication policy returned\", !!res);\n        if (res instanceof NDKEvent || res === true) {\n          if (res instanceof NDKEvent) {\n            await this.auth(res);\n          }\n          const authenticate = async () => {\n            if (this._status >= 5 /* CONNECTED */ && this._status < 8 /* AUTHENTICATED */) {\n              const event = new NDKEvent(this.ndk);\n              event.kind = 22242 /* ClientAuth */;\n              event.tags = [\n                [\"relay\", this.ndkRelay.url],\n                [\"challenge\", challenge]\n              ];\n              await event.sign();\n              this.auth(event).then(() => {\n                this._status = 8 /* AUTHENTICATED */;\n                this.ndkRelay.emit(\"authed\");\n                this.debug(\"Authentication successful\");\n              }).catch((e) => {\n                this._status = 6 /* AUTH_REQUESTED */;\n                this.ndkRelay.emit(\"auth:failed\", e);\n                this.debug(\"Authentication failed\", e);\n              });\n            } else {\n              this.debug(\n                \"Authentication failed, it changed status, status is %d\",\n                this._status\n              );\n            }\n          };\n          if (res === true) {\n            if (!this.ndk?.signer) {\n              this.debug(\"No signer available for authentication localhost\");\n              this.ndk?.once(\"signer:ready\", authenticate);\n            } else {\n              authenticate().catch((e) => {\n                console.error(\"Error authenticating\", e);\n              });\n            }\n          }\n          this._status = 5 /* CONNECTED */;\n          this.ndkRelay.emit(\"authed\");\n        }\n      }\n    } else {\n      this.ndkRelay.emit(\"auth\", challenge);\n    }\n  }\n  /**\n   * Handles errors that occur on the WebSocket connection to the relay.\n   * @param error - The error or event that occurred.\n   */\n  onError(error) {\n    this.debug(`WebSocket error on ${this.ndkRelay.url}:`, error);\n  }\n  /**\n   * Gets the current status of the NDK relay connection.\n   * @returns {NDKRelayStatus} The current status of the NDK relay connection.\n   */\n  get status() {\n    return this._status;\n  }\n  /**\n   * Checks if the NDK relay connection is currently available.\n   * @returns {boolean} `true` if the relay connection is in the `CONNECTED` status, `false` otherwise.\n   */\n  isAvailable() {\n    return this._status === 5 /* CONNECTED */;\n  }\n  /**\n   * Checks if the NDK relay connection is flapping, which means the connection is rapidly\n   * disconnecting and reconnecting. This is determined by analyzing the durations of the\n   * last three connection attempts. If the standard deviation of the durations is less\n   * than 1000 milliseconds, the connection is considered to be flapping.\n   *\n   * @returns {boolean} `true` if the connection is flapping, `false` otherwise.\n   */\n  isFlapping() {\n    const durations = this._connectionStats.durations;\n    if (durations.length % 3 !== 0) return false;\n    const sum = durations.reduce((a, b) => a + b, 0);\n    const avg = sum / durations.length;\n    const variance = durations.map((x) => Math.pow(x - avg, 2)).reduce((a, b) => a + b, 0) / durations.length;\n    const stdDev = Math.sqrt(variance);\n    const isFlapping = stdDev < FLAPPING_THRESHOLD_MS;\n    return isFlapping;\n  }\n  /**\n   * Handles a notice received from the NDK relay.\n   * If the notice indicates the relay is complaining (e.g. \"too many\" or \"maximum\"),\n   * the method disconnects from the relay and attempts to reconnect after a 2-second delay.\n   * A debug message is logged with the relay URL and the notice text.\n   * The \"notice\" event is emitted on the ndkRelay instance with the notice text.\n   *\n   * @param notice - The notice text received from the NDK relay.\n   */\n  async onNotice(notice) {\n    this.ndkRelay.emit(\"notice\", notice);\n  }\n  /**\n   * Attempts to reconnect to the NDK relay after a connection is lost.\n   * This function is called recursively to handle multiple reconnection attempts.\n   * It checks if the relay is flapping and emits a \"flapping\" event if so.\n   * It then calculates a delay before the next reconnection attempt based on the number of previous attempts.\n   * The function sets a timeout to execute the next reconnection attempt after the calculated delay.\n   * If the maximum number of reconnection attempts is reached, a debug message is logged.\n   *\n   * @param attempt - The current attempt number (default is 0).\n   */\n  handleReconnection(attempt = 0) {\n    if (this.reconnectTimeout) return;\n    if (this.isFlapping()) {\n      this.ndkRelay.emit(\"flapping\", this._connectionStats);\n      this._status = 3 /* FLAPPING */;\n      return;\n    }\n    const reconnectDelay = this.connectedAt ? Math.max(0, 6e4 - (Date.now() - this.connectedAt)) : 5e3 * (this._connectionStats.attempts + 1);\n    this.reconnectTimeout = setTimeout(() => {\n      this.reconnectTimeout = void 0;\n      this._status = 2 /* RECONNECTING */;\n      this.connect().catch((err) => {\n        if (attempt < MAX_RECONNECT_ATTEMPTS) {\n          setTimeout(\n            () => {\n              this.handleReconnection(attempt + 1);\n            },\n            1e3 * (attempt + 1) ^ 4\n          );\n        } else {\n          this.debug(\"Reconnect failed\");\n        }\n      });\n    }, reconnectDelay);\n    this.ndkRelay.emit(\"delayed-connect\", reconnectDelay);\n    this.debug(\"Reconnecting in\", reconnectDelay);\n    this._connectionStats.nextReconnectAt = Date.now() + reconnectDelay;\n  }\n  /**\n   * Sends a message to the NDK relay if the connection is in the CONNECTED state and the WebSocket is open.\n   * If the connection is not in the CONNECTED state or the WebSocket is not open, logs a debug message and throws an error.\n   *\n   * @param message - The message to send to the NDK relay.\n   * @throws {Error} If attempting to send on a closed relay connection.\n   */\n  async send(message) {\n    if (this._status >= 5 /* CONNECTED */ && this.ws?.readyState === WebSocket.OPEN) {\n      this.ws?.send(message);\n      this.netDebug?.(message, this.ndkRelay, \"send\");\n    } else {\n      this.debug(\n        `Not connected to ${this.ndkRelay.url} (%d), not sending message ${message}`,\n        this._status\n      );\n    }\n  }\n  /**\n   * Authenticates the NDK event by sending it to the NDK relay and returning a promise that resolves with the result.\n   *\n   * @param event - The NDK event to authenticate.\n   * @returns A promise that resolves with the authentication result.\n   */\n  async auth(event) {\n    const ret = new Promise((resolve, reject) => {\n      const val = this.openEventPublishes.get(event.id) ?? [];\n      val.push({ resolve, reject });\n      this.openEventPublishes.set(event.id, val);\n    });\n    this.send('[\"AUTH\",' + JSON.stringify(event.rawEvent()) + \"]\");\n    return ret;\n  }\n  /**\n   * Publishes an NDK event to the relay and returns a promise that resolves with the result.\n   *\n   * @param event - The NDK event to publish.\n   * @returns A promise that resolves with the result of the event publication.\n   * @throws {Error} If attempting to publish on a closed relay connection.\n   */\n  async publish(event) {\n    const ret = new Promise((resolve, reject) => {\n      const val = this.openEventPublishes.get(event.id) ?? [];\n      if (val.length > 0) {\n        console.warn(\n          \"Duplicate event publishing detected, you are publishing event \" + event.id + \" twice\"\n        );\n      }\n      val.push({ resolve, reject });\n      this.openEventPublishes.set(event.id, val);\n    });\n    this.send('[\"EVENT\",' + JSON.stringify(event) + \"]\");\n    return ret;\n  }\n  /**\n   * Counts the number of events that match the provided filters.\n   *\n   * @param filters - The filters to apply to the count request.\n   * @param params - An optional object containing a custom id for the count request.\n   * @returns A promise that resolves with the number of matching events.\n   * @throws {Error} If attempting to send the count request on a closed relay connection.\n   */\n  async count(filters, params) {\n    this.serial++;\n    const id = params?.id || \"count:\" + this.serial;\n    const ret = new Promise((resolve, reject) => {\n      this.openCountRequests.set(id, { resolve, reject });\n    });\n    this.send('[\"COUNT\",\"' + id + '\",' + JSON.stringify(filters).substring(1));\n    return ret;\n  }\n  close(subId, reason) {\n    this.send('[\"CLOSE\",\"' + subId + '\"]');\n    const sub = this.openSubs.get(subId);\n    this.openSubs.delete(subId);\n    if (sub) sub.onclose(reason);\n  }\n  /**\n   * Subscribes to the NDK relay with the provided filters and parameters.\n   *\n   * @param filters - The filters to apply to the subscription.\n   * @param params - The subscription parameters, including an optional custom id.\n   * @returns A new NDKRelaySubscription instance.\n   */\n  req(relaySub) {\n    this.send(\n      '[\"REQ\",\"' + relaySub.subId + '\",' + JSON.stringify(relaySub.executeFilters).substring(1)\n    ) + \"]\";\n    this.openSubs.set(relaySub.subId, relaySub);\n  }\n  /**\n   * Utility functions to update the connection stats.\n   */\n  updateConnectionStats = {\n    connected: () => {\n      this._connectionStats.success++;\n      this._connectionStats.connectedAt = Date.now();\n    },\n    disconnected: () => {\n      if (this._connectionStats.connectedAt) {\n        this._connectionStats.durations.push(\n          Date.now() - this._connectionStats.connectedAt\n        );\n        if (this._connectionStats.durations.length > 100) {\n          this._connectionStats.durations.shift();\n        }\n      }\n      this._connectionStats.connectedAt = void 0;\n    },\n    attempt: () => {\n      this._connectionStats.attempts++;\n      this._connectionStats.connectedAt = Date.now();\n    }\n  };\n  /** Returns the connection stats. */\n  get connectionStats() {\n    return this._connectionStats;\n  }\n  /** Returns the relay URL */\n  get url() {\n    return this.ndkRelay.url;\n  }\n  get connected() {\n    return this._status >= 5 /* CONNECTED */ && this.ws?.readyState === WebSocket.OPEN;\n  }\n};\n\n// src/relay/publisher.ts\nvar NDKRelayPublisher = class {\n  ndkRelay;\n  debug;\n  constructor(ndkRelay) {\n    this.ndkRelay = ndkRelay;\n    this.debug = ndkRelay.debug.extend(\"publisher\");\n  }\n  /**\n   * Published an event to the relay; if the relay is not connected, it will\n   * wait for the relay to connect before publishing the event.\n   *\n   * If the relay does not connect within the timeout, the publish operation\n   * will fail.\n   * @param event  The event to publish\n   * @param timeoutMs  The timeout for the publish operation in milliseconds\n   * @returns A promise that resolves when the event has been published or rejects if the operation times out\n   */\n  async publish(event, timeoutMs = 2500) {\n    let timeout;\n    const publishConnected = () => {\n      return new Promise((resolve, reject) => {\n        try {\n          this.publishEvent(event).then((result) => {\n            this.ndkRelay.emit(\"published\", event);\n            event.emit(\"relay:published\", this.ndkRelay);\n            resolve(true);\n          }).catch(reject);\n        } catch (err) {\n          reject(err);\n        }\n      });\n    };\n    const timeoutPromise = new Promise((_, reject) => {\n      timeout = setTimeout(() => {\n        timeout = void 0;\n        reject(new Error(\"Timeout: \" + timeoutMs + \"ms\"));\n      }, timeoutMs);\n    });\n    const onConnectHandler = () => {\n      publishConnected().then((result) => connectResolve(result)).catch((err) => connectReject(err));\n    };\n    let connectResolve;\n    let connectReject;\n    const onError = (err) => {\n      this.ndkRelay.debug(\"Publish failed\", err, event.id);\n      this.ndkRelay.emit(\"publish:failed\", event, err);\n      event.emit(\"relay:publish:failed\", this.ndkRelay, err);\n      throw err;\n    };\n    const onFinally = () => {\n      if (timeout) clearTimeout(timeout);\n      this.ndkRelay.removeListener(\"connect\", onConnectHandler);\n    };\n    if (this.ndkRelay.status >= 5 /* CONNECTED */) {\n      return Promise.race([publishConnected(), timeoutPromise]).catch(onError).finally(onFinally);\n    } else {\n      if (this.ndkRelay.status <= 1 /* DISCONNECTED */) {\n        console.warn(\n          \"Relay is disconnected, trying to connect to publish an event\",\n          this.ndkRelay.url\n        );\n        this.ndkRelay.connect();\n      } else {\n        console.warn(\n          \"Relay not connected, waiting for connection to publish an event\",\n          this.ndkRelay.url\n        );\n      }\n      return Promise.race([\n        new Promise((resolve, reject) => {\n          connectResolve = resolve;\n          connectReject = reject;\n          this.ndkRelay.once(\"connect\", onConnectHandler);\n        }),\n        timeoutPromise\n      ]).catch(onError).finally(onFinally);\n    }\n  }\n  async publishEvent(event) {\n    return this.ndkRelay.connectivity.publish(event.rawEvent());\n  }\n};\n\n// src/subscription/grouping.ts\nfunction filterFingerprint(filters, closeOnEose) {\n  const elements = [];\n  for (const filter of filters) {\n    const keys = Object.entries(filter || {}).map(([key, values]) => {\n      if ([\"since\", \"until\"].includes(key)) {\n        return key + \":\" + values;\n      } else {\n        return key;\n      }\n    }).sort().join(\"-\");\n    elements.push(keys);\n  }\n  let id = closeOnEose ? \"+\" : \"\";\n  id += elements.join(\"|\");\n  return id;\n}\nfunction mergeFilters(filters) {\n  const result = [];\n  const lastResult = {};\n  filters.filter((f) => !!f.limit).forEach((filterWithLimit) => result.push(filterWithLimit));\n  filters = filters.filter((f) => !f.limit);\n  if (filters.length === 0) return result;\n  filters.forEach((filter) => {\n    Object.entries(filter).forEach(([key, value]) => {\n      if (Array.isArray(value)) {\n        if (lastResult[key] === void 0) {\n          lastResult[key] = [...value];\n        } else {\n          lastResult[key] = Array.from(/* @__PURE__ */ new Set([...lastResult[key], ...value]));\n        }\n      } else {\n        lastResult[key] = value;\n      }\n    });\n  });\n  return [...result, lastResult];\n}\n\n// src/relay/subscription.ts\nvar NDKRelaySubscription = class {\n  fingerprint;\n  items = /* @__PURE__ */ new Map();\n  topSubManager;\n  debug;\n  /**\n   * Tracks the status of this REQ.\n   */\n  status = 0 /* INITIAL */;\n  onClose;\n  relay;\n  /**\n   * Whether this subscription has reached EOSE.\n   */\n  eosed = false;\n  /**\n   * Timeout at which this subscription will\n   * start executing.\n   */\n  executionTimer;\n  /**\n   * Track the time at which this subscription will fire.\n   */\n  fireTime;\n  /**\n   * The delay type that the current fireTime was calculated with.\n   */\n  delayType;\n  /**\n   * The filters that have been executed.\n   */\n  executeFilters;\n  id = Math.random().toString(36).substring(7);\n  /**\n   *\n   * @param fingerprint The fingerprint of this subscription.\n   */\n  constructor(relay, fingerprint, topSubManager) {\n    this.relay = relay;\n    this.topSubManager = topSubManager;\n    this.debug = relay.debug.extend(\"subscription-\" + this.id);\n    this.fingerprint = fingerprint || Math.random().toString(36).substring(7);\n  }\n  _subId;\n  get subId() {\n    if (this._subId) return this._subId;\n    this._subId = this.fingerprint.slice(0, 15);\n    return this._subId;\n  }\n  subIdParts = /* @__PURE__ */ new Set();\n  addSubIdPart(part) {\n    this.subIdParts.add(part);\n  }\n  addItem(subscription, filters) {\n    this.debug(\"Adding item\", { filters, internalId: subscription.internalId, status: this.status, fingerprint: this.fingerprint, id: this.subId, items: this.items, itemsSize: this.items.size });\n    if (this.items.has(subscription.internalId)) return;\n    subscription.on(\"close\", this.removeItem.bind(this, subscription));\n    this.items.set(subscription.internalId, { subscription, filters });\n    if (this.status !== 3 /* RUNNING */) {\n      if (subscription.subId && (!this._subId || this._subId.length < 48)) {\n        if (this.status === 0 /* INITIAL */ || this.status === 1 /* PENDING */) {\n          this.addSubIdPart(subscription.subId);\n        }\n      }\n    }\n    switch (this.status) {\n      case 0 /* INITIAL */:\n        this.evaluateExecutionPlan(subscription);\n        break;\n      case 3 /* RUNNING */:\n        console.log(\n          \"BUG: This should not happen: This subscription needs to catch up with a subscription that was already running\",\n          filters\n        );\n        break;\n      case 1 /* PENDING */:\n        this.evaluateExecutionPlan(subscription);\n        break;\n      case 4 /* CLOSED */:\n        this.debug(\n          \"Subscription is closed, cannot add new items %o (%o)\",\n          subscription,\n          filters\n        );\n        throw new Error(\"Cannot add new items to a closed subscription\");\n    }\n  }\n  /**\n   * A subscription has been closed, remove it from the list of items.\n   * @param subscription\n   */\n  removeItem(subscription) {\n    this.items.delete(subscription.internalId);\n    if (this.items.size === 0) {\n      if (!this.eosed) return;\n      this.close();\n      this.cleanup();\n    }\n  }\n  close() {\n    if (this.status === 4 /* CLOSED */) return;\n    const prevStatus = this.status;\n    this.status = 4 /* CLOSED */;\n    if (prevStatus === 3 /* RUNNING */) {\n      try {\n        this.relay.close(this.subId);\n      } catch (e) {\n        this.debug(\"Error closing subscription\", e, this);\n      }\n    } else {\n      this.debug(\"Subscription wanted to close but it wasn't running, this is probably ok\", {\n        subId: this.subId,\n        prevStatus,\n        sub: this\n      });\n    }\n    this.cleanup();\n  }\n  cleanup() {\n    if (this.executionTimer) clearTimeout(this.executionTimer);\n    this.relay.off(\"ready\", this.executeOnRelayReady);\n    this.relay.off(\"authed\", this.reExecuteAfterAuth);\n    if (this.onClose) this.onClose(this);\n  }\n  evaluateExecutionPlan(subscription) {\n    if (!subscription.isGroupable()) {\n      this.status = 1 /* PENDING */;\n      this.execute();\n      return;\n    }\n    if (subscription.filters.find((filter) => !!filter.limit)) {\n      this.executeFilters = this.compileFilters();\n      if (this.executeFilters.length >= 10) {\n        this.status = 1 /* PENDING */;\n        this.execute();\n        return;\n      }\n    }\n    const delay = subscription.groupableDelay;\n    const delayType = subscription.groupableDelayType;\n    if (!delay) throw new Error(\"Cannot group a subscription without a delay\");\n    if (this.status === 0 /* INITIAL */) {\n      this.schedule(delay, delayType);\n    } else {\n      const existingDelayType = this.delayType;\n      const timeUntilFire = this.fireTime - Date.now();\n      if (existingDelayType === \"at-least\" && delayType === \"at-least\") {\n        if (timeUntilFire < delay) {\n          if (this.executionTimer) clearTimeout(this.executionTimer);\n          this.schedule(delay, delayType);\n        }\n      } else if (existingDelayType === \"at-least\" && delayType === \"at-most\") {\n        if (timeUntilFire > delay) {\n          if (this.executionTimer) clearTimeout(this.executionTimer);\n          this.schedule(delay, delayType);\n        }\n      } else if (existingDelayType === \"at-most\" && delayType === \"at-most\") {\n        if (timeUntilFire > delay) {\n          if (this.executionTimer) clearTimeout(this.executionTimer);\n          this.schedule(delay, delayType);\n        }\n      } else if (existingDelayType === \"at-most\" && delayType === \"at-least\") {\n        if (timeUntilFire > delay) {\n          if (this.executionTimer) clearTimeout(this.executionTimer);\n          this.schedule(delay, delayType);\n        }\n      } else {\n        throw new Error(\n          \"Unknown delay type combination \" + existingDelayType + \" \" + delayType\n        );\n      }\n    }\n  }\n  schedule(delay, delayType) {\n    this.status = 1 /* PENDING */;\n    const currentTime = Date.now();\n    this.fireTime = currentTime + delay;\n    this.delayType = delayType;\n    const timer = setTimeout(this.execute.bind(this), delay);\n    if (delayType === \"at-least\") {\n      this.executionTimer = timer;\n    }\n  }\n  executeOnRelayReady = () => {\n    if (this.status !== 2 /* WAITING */) return;\n    if (this.items.size === 0) {\n      this.debug(\"No items to execute; this relay was probably too slow to respond and the caller gave up\", { status: this.status, fingerprint: this.fingerprint, items: this.items, itemsSize: this.items.size, id: this.id, subId: this.subId });\n      this.cleanup();\n      return;\n    }\n    this.debug(\"Executing on relay ready\", { status: this.status, fingerprint: this.fingerprint, items: this.items, itemsSize: this.items.size });\n    this.status = 1 /* PENDING */;\n    this.execute();\n  };\n  finalizeSubId() {\n    if (this.subIdParts.size > 0) {\n      this._subId = Array.from(this.subIdParts).join(\"-\");\n    } else {\n      this._subId = this.fingerprint.slice(0, 15);\n    }\n    this._subId += \"-\" + Math.random().toString(36).substring(2, 7);\n  }\n  // we do it this way so that we can remove the listener\n  reExecuteAfterAuth = (() => {\n    const oldSubId = this.subId;\n    this.debug(\"Re-executing after auth\", this.items.size);\n    if (this.eosed) {\n      this.relay.close(this.subId);\n    } else {\n      this.debug(\n        \"We are abandoning an opened subscription, once it EOSE's, the handler will close it\",\n        { oldSubId }\n      );\n    }\n    this._subId = void 0;\n    this.status = 1 /* PENDING */;\n    this.execute();\n    this.debug(\"Re-executed after auth %s \\u{1F449} %s\", oldSubId, this.subId);\n  }).bind(this);\n  execute() {\n    if (this.status !== 1 /* PENDING */) {\n      return;\n    }\n    if (!this.relay.connected) {\n      this.status = 2 /* WAITING */;\n      this.debug(\"Waiting for relay to be ready\", { status: this.status, id: this.subId, fingerprint: this.fingerprint, items: this.items, itemsSize: this.items.size });\n      this.relay.once(\"ready\", this.executeOnRelayReady);\n      return;\n    } else if (this.relay.status < 8 /* AUTHENTICATED */) {\n      this.relay.once(\"authed\", this.reExecuteAfterAuth);\n    }\n    this.status = 3 /* RUNNING */;\n    this.finalizeSubId();\n    this.executeFilters = this.compileFilters();\n    this.relay.req(this);\n  }\n  onstart() {\n  }\n  onevent(event) {\n    this.topSubManager.dispatchEvent(event, this.relay);\n  }\n  oneose(subId) {\n    this.eosed = true;\n    if (subId !== this.subId) {\n      this.debug(\"Received EOSE for an abandoned subscription\", subId, this.subId);\n      this.relay.close(subId);\n      return;\n    }\n    if (this.items.size === 0) {\n      this.close();\n    }\n    for (const { subscription } of this.items.values()) {\n      subscription.eoseReceived(this.relay);\n      if (subscription.closeOnEose) {\n        this.debug(\"Removing item because of EOSE\", { filters: subscription.filters, internalId: subscription.internalId, status: this.status, fingerprint: this.fingerprint, items: this.items, itemsSize: this.items.size });\n        this.removeItem(subscription);\n      }\n    }\n  }\n  onclose(reason) {\n    this.status = 4 /* CLOSED */;\n  }\n  onclosed(reason) {\n    if (!reason) return;\n    for (const { subscription } of this.items.values()) {\n      subscription.closedReceived(this.relay, reason);\n    }\n  }\n  /**\n   * Grabs the filters from all the subscriptions\n   * and merges them into a single filter.\n   */\n  compileFilters() {\n    const mergedFilters = [];\n    const filters = Array.from(this.items.values()).map((item) => item.filters);\n    if (!filters[0]) {\n      this.debug(\"\\u{1F440} No filters to merge\", this.items);\n      console.error(\"BUG: No filters to merge!\", this.items);\n      return [];\n    }\n    const filterCount = filters[0].length;\n    for (let i = 0; i < filterCount; i++) {\n      const allFiltersAtIndex = filters.map((filter) => filter[i]);\n      mergedFilters.push(...mergeFilters(allFiltersAtIndex));\n    }\n    return mergedFilters;\n  }\n};\n\n// src/relay/sub-manager.ts\nvar NDKRelaySubscriptionManager = class {\n  relay;\n  subscriptions;\n  generalSubManager;\n  /**\n   * @param relay - The relay instance.\n   * @param generalSubManager - The subscription manager instance.\n   */\n  constructor(relay, generalSubManager) {\n    this.relay = relay;\n    this.subscriptions = /* @__PURE__ */ new Map();\n    this.generalSubManager = generalSubManager;\n  }\n  /**\n   * Adds a subscription to the manager.\n   */\n  addSubscription(sub, filters) {\n    let relaySub;\n    if (!sub.isGroupable()) {\n      relaySub = this.createSubscription(sub, filters);\n    } else {\n      const filterFp = filterFingerprint(filters, sub.closeOnEose);\n      if (filterFp) {\n        const existingSubs = this.subscriptions.get(filterFp);\n        relaySub = (existingSubs || []).find(\n          (sub2) => sub2.status < 3 /* RUNNING */\n        );\n      }\n      relaySub ??= this.createSubscription(sub, filters, filterFp);\n    }\n    relaySub.addItem(sub, filters);\n  }\n  createSubscription(sub, filters, fingerprint) {\n    const relaySub = new NDKRelaySubscription(this.relay, fingerprint || null, this.generalSubManager);\n    relaySub.onClose = this.onRelaySubscriptionClose.bind(this);\n    const currentVal = this.subscriptions.get(relaySub.fingerprint) ?? [];\n    this.subscriptions.set(relaySub.fingerprint, [...currentVal, relaySub]);\n    return relaySub;\n  }\n  onRelaySubscriptionClose(sub) {\n    let currentVal = this.subscriptions.get(sub.fingerprint) ?? [];\n    if (!currentVal) {\n      console.warn(\n        \"Unexpectedly did not find a subscription with fingerprint\",\n        sub.fingerprint\n      );\n    } else if (currentVal.length === 1) {\n      this.subscriptions.delete(sub.fingerprint);\n    } else {\n      currentVal = currentVal.filter((s) => s.id !== sub.id);\n      this.subscriptions.set(sub.fingerprint, currentVal);\n    }\n  }\n};\n\n// src/relay/index.ts\nvar NDKRelayStatus = /* @__PURE__ */ ((NDKRelayStatus2) => {\n  NDKRelayStatus2[NDKRelayStatus2[\"DISCONNECTING\"] = 0] = \"DISCONNECTING\";\n  NDKRelayStatus2[NDKRelayStatus2[\"DISCONNECTED\"] = 1] = \"DISCONNECTED\";\n  NDKRelayStatus2[NDKRelayStatus2[\"RECONNECTING\"] = 2] = \"RECONNECTING\";\n  NDKRelayStatus2[NDKRelayStatus2[\"FLAPPING\"] = 3] = \"FLAPPING\";\n  NDKRelayStatus2[NDKRelayStatus2[\"CONNECTING\"] = 4] = \"CONNECTING\";\n  NDKRelayStatus2[NDKRelayStatus2[\"CONNECTED\"] = 5] = \"CONNECTED\";\n  NDKRelayStatus2[NDKRelayStatus2[\"AUTH_REQUESTED\"] = 6] = \"AUTH_REQUESTED\";\n  NDKRelayStatus2[NDKRelayStatus2[\"AUTHENTICATING\"] = 7] = \"AUTHENTICATING\";\n  NDKRelayStatus2[NDKRelayStatus2[\"AUTHENTICATED\"] = 8] = \"AUTHENTICATED\";\n  return NDKRelayStatus2;\n})(NDKRelayStatus || {});\nvar NDKRelay = class _NDKRelay extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  url;\n  scores;\n  connectivity;\n  subs;\n  publisher;\n  authPolicy;\n  /**\n   * The lowest validation ratio this relay can reach.\n   */\n  lowestValidationRatio;\n  /**\n   * Current validation ratio this relay is targeting.\n   */\n  targetValidationRatio;\n  validationRatioFn;\n  /**\n   * This tracks events that have been seen by this relay\n   * with a valid signature.\n   */\n  validatedEventCount = 0;\n  /**\n   * This tracks events that have been seen by this relay\n   * but have not been validated.\n   */\n  nonValidatedEventCount = 0;\n  /**\n   * Whether this relay is trusted.\n   *\n   * Trusted relay's events do not get their signature verified.\n   */\n  trusted = false;\n  complaining = false;\n  debug;\n  static defaultValidationRatioUpdateFn = (relay, validatedCount, nonValidatedCount) => {\n    if (relay.lowestValidationRatio === void 0 || relay.targetValidationRatio === void 0)\n      return 1;\n    let newRatio = relay.validationRatio;\n    if (relay.validationRatio > relay.targetValidationRatio) {\n      const factor = validatedCount / 100;\n      newRatio = Math.max(relay.lowestValidationRatio, relay.validationRatio - factor);\n    }\n    if (newRatio < relay.validationRatio) {\n      return newRatio;\n    }\n    return relay.validationRatio;\n  };\n  constructor(url, authPolicy, ndk) {\n    super();\n    this.url = normalizeRelayUrl(url);\n    this.scores = /* @__PURE__ */ new Map();\n    this.debug = debug__WEBPACK_IMPORTED_MODULE_1__(`ndk:relay:${url}`);\n    this.connectivity = new NDKRelayConnectivity(this, ndk);\n    this.connectivity.netDebug = ndk?.netDebug;\n    this.req = this.connectivity.req.bind(this.connectivity);\n    this.close = this.connectivity.close.bind(this.connectivity);\n    this.subs = new NDKRelaySubscriptionManager(this, ndk.subManager);\n    this.publisher = new NDKRelayPublisher(this);\n    this.authPolicy = authPolicy;\n    this.targetValidationRatio = ndk?.initialValidationRatio;\n    this.lowestValidationRatio = ndk?.lowestValidationRatio;\n    this.validationRatioFn = (ndk?.validationRatioFn ?? _NDKRelay.defaultValidationRatioUpdateFn).bind(this);\n    this.updateValidationRatio();\n    if (!ndk) {\n      console.trace(\"relay created without ndk\");\n    }\n  }\n  updateValidationRatio() {\n    setTimeout(() => {\n      this.updateValidationRatio();\n    }, 3e4);\n  }\n  get status() {\n    return this.connectivity.status;\n  }\n  get connectionStats() {\n    return this.connectivity.connectionStats;\n  }\n  /**\n   * Connects to the relay.\n   */\n  async connect(timeoutMs, reconnect = true) {\n    return this.connectivity.connect(timeoutMs, reconnect);\n  }\n  /**\n   * Disconnects from the relay.\n   */\n  disconnect() {\n    if (this.status === 1 /* DISCONNECTED */) {\n      return;\n    }\n    this.connectivity.disconnect();\n  }\n  /**\n   * Queues or executes the subscription of a specific set of filters\n   * within this relay.\n   *\n   * @param subscription NDKSubscription this filters belong to.\n   * @param filters Filters to execute\n   */\n  subscribe(subscription, filters) {\n    this.subs.addSubscription(subscription, filters);\n  }\n  /**\n   * Publishes an event to the relay with an optional timeout.\n   *\n   * If the relay is not connected, the event will be published when the relay connects,\n   * unless the timeout is reached before the relay connects.\n   *\n   * @param event The event to publish\n   * @param timeoutMs The timeout for the publish operation in milliseconds\n   * @returns A promise that resolves when the event has been published or rejects if the operation times out\n   */\n  async publish(event, timeoutMs = 2500) {\n    return this.publisher.publish(event, timeoutMs);\n  }\n  referenceTags() {\n    return [[\"r\", this.url]];\n  }\n  addValidatedEvent() {\n    this.validatedEventCount++;\n  }\n  addNonValidatedEvent() {\n    this.nonValidatedEventCount++;\n  }\n  /**\n   * The current validation ratio this relay has achieved.\n   */\n  get validationRatio() {\n    if (this.nonValidatedEventCount === 0) {\n      return 1;\n    }\n    return this.validatedEventCount / (this.validatedEventCount + this.nonValidatedEventCount);\n  }\n  shouldValidateEvent() {\n    if (this.trusted) {\n      return false;\n    }\n    if (this.targetValidationRatio === void 0) {\n      return true;\n    }\n    return this.validationRatio < this.targetValidationRatio;\n  }\n  get connected() {\n    return this.connectivity.connected;\n  }\n  req;\n  close;\n};\n\n// src/relay/sets/index.ts\nvar NDKPublishError = class extends Error {\n  errors;\n  publishedToRelays;\n  /**\n   * Intended relay set where the publishing was intended to happen.\n   */\n  intendedRelaySet;\n  constructor(message, errors, publishedToRelays, intendedRelaySet) {\n    super(message);\n    this.errors = errors;\n    this.publishedToRelays = publishedToRelays;\n    this.intendedRelaySet = intendedRelaySet;\n  }\n  get relayErrors() {\n    const errors = [];\n    for (const [relay, err] of this.errors) {\n      errors.push(`${relay.url}: ${err}`);\n    }\n    return errors.join(\"\\n\");\n  }\n};\nvar NDKRelaySet = class _NDKRelaySet {\n  relays;\n  debug;\n  ndk;\n  pool;\n  constructor(relays, ndk, pool) {\n    this.relays = relays;\n    this.ndk = ndk;\n    this.pool = pool ?? ndk.pool;\n    this.debug = ndk.debug.extend(\"relayset\");\n  }\n  /**\n   * Adds a relay to this set.\n   */\n  addRelay(relay) {\n    this.relays.add(relay);\n  }\n  get relayUrls() {\n    return Array.from(this.relays).map((r) => r.url);\n  }\n  /**\n   * Creates a relay set from a list of relay URLs.\n   *\n   * If no connection to the relay is found in the pool it will temporarily\n   * connect to it.\n   *\n   * @param relayUrls - list of relay URLs to include in this set\n   * @param ndk\n   * @param connect - whether to connect to the relay immediately if it was already in the pool but not connected\n   * @returns NDKRelaySet\n   */\n  static fromRelayUrls(relayUrls, ndk, connect = true, pool) {\n    pool = pool ?? ndk.pool;\n    if (!pool) throw new Error(\"No pool provided\");\n    const relays = /* @__PURE__ */ new Set();\n    for (const url of relayUrls) {\n      const relay = pool.relays.get(normalizeRelayUrl(url));\n      if (relay) {\n        if (relay.status < 5 /* CONNECTED */ && connect) {\n          relay.connect();\n        }\n        relays.add(relay);\n      } else {\n        const temporaryRelay = new NDKRelay(\n          normalizeRelayUrl(url),\n          ndk?.relayAuthDefaultPolicy,\n          ndk\n        );\n        pool.useTemporaryRelay(\n          temporaryRelay,\n          void 0,\n          \"requested from fromRelayUrls \" + relayUrls\n        );\n        relays.add(temporaryRelay);\n      }\n    }\n    return new _NDKRelaySet(new Set(relays), ndk, pool);\n  }\n  /**\n   * Publish an event to all relays in this set. Returns the number of relays that have received the event.\n   * @param event\n   * @param timeoutMs - timeout in milliseconds for each publish operation and connection operation\n   * @returns A set where the event was successfully published to\n   * @throws NDKPublishError if no relay was able to receive the event\n   * @example\n   * ```typescript\n   * const event = new NDKEvent(ndk, {kinds: [NDKKind.Message], \"#d\": [\"123\"]});\n   * try {\n   *    const publishedToRelays = await relaySet.publish(event);\n   *    console.log(`published to ${publishedToRelays.size} relays`)\n   * } catch (error) {\n   *   console.error(\"error publishing to relays\", error);\n   *\n   *   if (error instanceof NDKPublishError) {\n   *      for (const [relay, err] of error.errors) {\n   *         console.error(`error publishing to relay ${relay.url}`, err);\n   *       }\n   *   }\n   * }\n   * ```\n   */\n  async publish(event, timeoutMs, requiredRelayCount = 1) {\n    const publishedToRelays = /* @__PURE__ */ new Set();\n    const errors = /* @__PURE__ */ new Map();\n    const isEphemeral2 = event.isEphemeral();\n    event.publishStatus = \"pending\";\n    const promises = Array.from(this.relays).map((relay) => {\n      return new Promise((resolve) => {\n        relay.publish(event, timeoutMs).then((e) => {\n          publishedToRelays.add(relay);\n          resolve();\n        }).catch((err) => {\n          if (!isEphemeral2) {\n            errors.set(relay, err);\n          }\n          resolve();\n        });\n      });\n    });\n    await Promise.all(promises);\n    if (publishedToRelays.size < requiredRelayCount) {\n      if (!isEphemeral2) {\n        const error = new NDKPublishError(\n          \"Not enough relays received the event\",\n          errors,\n          publishedToRelays,\n          this\n        );\n        event.publishStatus = \"error\";\n        event.publishError = error;\n        this.ndk.emit(\"event:publish-failed\", event, error, this.relayUrls);\n        throw error;\n      }\n    } else {\n      event.emit(\"published\", { relaySet: this, publishedToRelays });\n    }\n    return publishedToRelays;\n  }\n  get size() {\n    return this.relays.size;\n  }\n};\n\n// src/relay/sets/calculate.ts\n\nvar d = debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:outbox:calculate\");\nasync function calculateRelaySetFromEvent(ndk, event) {\n  const relays = /* @__PURE__ */ new Set();\n  const authorWriteRelays = await getWriteRelaysFor(ndk, event.pubkey);\n  if (authorWriteRelays) {\n    authorWriteRelays.forEach((relayUrl) => {\n      const relay = ndk.pool?.getRelay(relayUrl);\n      if (relay) relays.add(relay);\n    });\n  }\n  let relayHints = event.tags.filter((tag) => [\"a\", \"e\"].includes(tag[0])).map((tag) => tag[2]).filter((url) => url && url.startsWith(\"wss://\")).filter((url) => {\n    try {\n      new URL(url);\n      return true;\n    } catch {\n      return false;\n    }\n  }).map((url) => normalizeRelayUrl(url));\n  relayHints = Array.from(new Set(relayHints)).slice(0, 5);\n  relayHints.forEach((relayUrl) => {\n    const relay = ndk.pool?.getRelay(relayUrl, true, true);\n    if (relay) {\n      d(\"Adding relay hint %s\", relayUrl);\n      relays.add(relay);\n    }\n  });\n  const pTags = event.getMatchingTags(\"p\").map((tag) => tag[1]);\n  if (pTags.length < 5) {\n    const pTaggedRelays = Array.from(\n      chooseRelayCombinationForPubkeys(ndk, pTags, \"read\", {\n        preferredRelays: new Set(authorWriteRelays)\n      }).keys()\n    );\n    pTaggedRelays.forEach((relayUrl) => {\n      const relay = ndk.pool?.getRelay(relayUrl, false, true);\n      if (relay) {\n        d(\"Adding p-tagged relay %s\", relayUrl);\n        relays.add(relay);\n      }\n    });\n  } else {\n    d(\"Too many p-tags to consider %d\", pTags.length);\n  }\n  ndk.pool?.permanentAndConnectedRelays().forEach((relay) => relays.add(relay));\n  return new NDKRelaySet(relays, ndk);\n}\nfunction calculateRelaySetsFromFilter(ndk, filters, pool) {\n  const result = /* @__PURE__ */ new Map();\n  const authors = /* @__PURE__ */ new Set();\n  filters.forEach((filter) => {\n    if (filter.authors) {\n      filter.authors.forEach((author) => authors.add(author));\n    }\n  });\n  if (authors.size > 0) {\n    const authorToRelaysMap = getRelaysForFilterWithAuthors(ndk, Array.from(authors));\n    for (const relayUrl of authorToRelaysMap.keys()) {\n      result.set(relayUrl, []);\n    }\n    for (const filter of filters) {\n      if (filter.authors) {\n        for (const [relayUrl, authors2] of authorToRelaysMap.entries()) {\n          const authorFilterAndRelayPubkeyIntersection = filter.authors.filter(\n            (author) => authors2.includes(author)\n          );\n          result.set(relayUrl, [\n            ...result.get(relayUrl),\n            {\n              ...filter,\n              // Overwrite authors sent to this relay with the authors that were\n              // present in the filter and are also present in the relay\n              authors: authorFilterAndRelayPubkeyIntersection\n            }\n          ]);\n        }\n      } else {\n        for (const relayUrl of authorToRelaysMap.keys()) {\n          result.set(relayUrl, [...result.get(relayUrl), filter]);\n        }\n      }\n    }\n  } else {\n    if (ndk.explicitRelayUrls) {\n      ndk.explicitRelayUrls.forEach((relayUrl) => {\n        result.set(relayUrl, filters);\n      });\n    }\n  }\n  if (result.size === 0) {\n    pool.permanentAndConnectedRelays().slice(0, 5).forEach((relay) => {\n      result.set(relay.url, filters);\n    });\n  }\n  return result;\n}\nfunction calculateRelaySetsFromFilters(ndk, filters, pool) {\n  const a = calculateRelaySetsFromFilter(ndk, filters, pool);\n  return a;\n}\n\n// src/events/content-tagger.ts\n\nfunction mergeTags(tags1, tags2) {\n  const tagMap = /* @__PURE__ */ new Map();\n  const generateKey = (tag) => tag.join(\",\");\n  const isContained = (smaller, larger) => {\n    return smaller.every((value, index) => value === larger[index]);\n  };\n  const processTag = (tag) => {\n    for (const [key, existingTag] of tagMap) {\n      if (isContained(existingTag, tag) || isContained(tag, existingTag)) {\n        if (tag.length >= existingTag.length) {\n          tagMap.set(key, tag);\n        }\n        return;\n      }\n    }\n    tagMap.set(generateKey(tag), tag);\n  };\n  tags1.concat(tags2).forEach(processTag);\n  return Array.from(tagMap.values());\n}\nfunction uniqueTag(a, b) {\n  const aLength = a.length;\n  const bLength = b.length;\n  const sameLength = aLength === bLength;\n  if (sameLength) {\n    if (a.every((v, i) => v === b[i])) {\n      return [a];\n    } else {\n      return [a, b];\n    }\n  } else if (aLength > bLength && a.every((v, i) => v === b[i])) {\n    return [a];\n  } else if (bLength > aLength && b.every((v, i) => v === a[i])) {\n    return [b];\n  }\n  return [a, b];\n}\nvar hashtagRegex = /(?<=\\s|^)(#[^\\s!@#$%^&*()=+./,[{\\]};:'\"?><]+)/g;\nfunction generateHashtags(content) {\n  const hashtags = content.match(hashtagRegex);\n  const tagIds = /* @__PURE__ */ new Set();\n  const tag = /* @__PURE__ */ new Set();\n  if (hashtags) {\n    for (const hashtag of hashtags) {\n      if (tagIds.has(hashtag.slice(1))) continue;\n      tag.add(hashtag.slice(1));\n      tagIds.add(hashtag.slice(1));\n    }\n  }\n  return Array.from(tag);\n}\nasync function generateContentTags(content, tags = []) {\n  const tagRegex = /(@|nostr:)(npub|nprofile|note|nevent|naddr)[a-zA-Z0-9]+/g;\n  const promises = [];\n  const addTagIfNew = (t) => {\n    if (!tags.find((t2) => [\"q\", t[0]].includes(t2[0]) && t2[1] === t[1])) {\n      tags.push(t);\n    }\n  };\n  content = content.replace(tagRegex, (tag) => {\n    try {\n      const entity = tag.split(/(@|nostr:)/)[2];\n      const { type, data } = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.decode(entity);\n      let t;\n      switch (type) {\n        case \"npub\":\n          t = [\"p\", data];\n          break;\n        case \"nprofile\":\n          t = [\"p\", data.pubkey];\n          break;\n        case \"note\":\n          promises.push(\n            new Promise(async (resolve) => {\n              addTagIfNew([\n                \"q\",\n                data,\n                await maybeGetEventRelayUrl(entity)\n              ]);\n              resolve();\n            })\n          );\n          break;\n        case \"nevent\":\n          promises.push(\n            new Promise(async (resolve) => {\n              const { id, author } = data;\n              let { relays } = data;\n              if (!relays || relays.length === 0) {\n                relays = [await maybeGetEventRelayUrl(entity)];\n              }\n              addTagIfNew([\"q\", id, relays[0]]);\n              if (author) addTagIfNew([\"p\", author]);\n              resolve();\n            })\n          );\n          break;\n        case \"naddr\":\n          promises.push(\n            new Promise(async (resolve) => {\n              const id = [data.kind, data.pubkey, data.identifier].join(\":\");\n              let relays = data.relays ?? [];\n              if (relays.length === 0) {\n                relays = [await maybeGetEventRelayUrl(entity)];\n              }\n              addTagIfNew([\"q\", id, relays[0]]);\n              addTagIfNew([\"p\", data.pubkey]);\n              resolve();\n            })\n          );\n          break;\n        default:\n          return tag;\n      }\n      if (t) addTagIfNew(t);\n      return `nostr:${entity}`;\n    } catch (error) {\n      return tag;\n    }\n  });\n  await Promise.all(promises);\n  const newTags = generateHashtags(content).map((hashtag) => [\"t\", hashtag]);\n  tags = mergeTags(tags, newTags);\n  return { content, tags };\n}\nasync function maybeGetEventRelayUrl(nip19Id) {\n  return \"\";\n}\n\n// src/events/kind.ts\nfunction isReplaceable() {\n  if (this.kind === void 0) throw new Error(\"Kind not set\");\n  return [0, 3].includes(this.kind) || this.kind >= 1e4 && this.kind < 2e4 || this.kind >= 3e4 && this.kind < 4e4;\n}\nfunction isEphemeral() {\n  if (this.kind === void 0) throw new Error(\"Kind not set\");\n  return this.kind >= 2e4 && this.kind < 3e4;\n}\nfunction isParamReplaceable() {\n  if (this.kind === void 0) throw new Error(\"Kind not set\");\n  return this.kind >= 3e4 && this.kind < 4e4;\n}\n\n// src/events/encryption.ts\nasync function encrypt(recipient, signer, scheme = \"nip44\") {\n  let encrypted;\n  if (!this.ndk) throw new Error(\"No NDK instance found!\");\n  if (!signer) {\n    this.ndk.assertSigner();\n    signer = this.ndk.signer;\n  }\n  if (!recipient) {\n    const pTags = this.getMatchingTags(\"p\");\n    if (pTags.length !== 1) {\n      throw new Error(\n        \"No recipient could be determined and no explicit recipient was provided\"\n      );\n    }\n    recipient = this.ndk.getUser({ pubkey: pTags[0][1] });\n  }\n  if (scheme === \"nip44\" && await isEncryptionEnabled(signer, \"nip44\")) {\n    encrypted = await signer?.encrypt(recipient, this.content, \"nip44\");\n  }\n  if ((!encrypted || scheme === \"nip04\") && await isEncryptionEnabled(signer, \"nip04\")) {\n    encrypted = await signer.encrypt(recipient, this.content, \"nip04\");\n  }\n  if (!encrypted) throw new Error(\"Failed to encrypt event.\");\n  this.content = encrypted;\n}\nasync function decrypt(sender, signer, scheme) {\n  let decrypted;\n  if (!this.ndk) throw new Error(\"No NDK instance found!\");\n  if (!signer) {\n    this.ndk.assertSigner();\n    signer = this.ndk.signer;\n  }\n  if (!signer) throw new Error(\"no NDK signer\");\n  if (!sender) {\n    sender = this.author;\n  }\n  if (!scheme) scheme = this.content.match(/\\\\?iv=/) ? \"nip04\" : \"nip44\";\n  if ((scheme === \"nip04\" || this.kind === 4) && await isEncryptionEnabled(signer, \"nip04\") && this.content.search(\"\\\\?iv=\")) {\n    decrypted = await signer.decrypt(sender, this.content, \"nip04\");\n  }\n  if (!decrypted && scheme === \"nip44\" && await isEncryptionEnabled(signer, \"nip44\")) {\n    decrypted = await signer.decrypt(sender, this.content, \"nip44\");\n  }\n  if (!decrypted) throw new Error(\"Failed to decrypt event.\");\n  this.content = decrypted;\n}\nasync function isEncryptionEnabled(signer, scheme) {\n  if (!signer.encryptionEnabled) return false;\n  if (!scheme) return true;\n  return Boolean(await signer.encryptionEnabled(scheme));\n}\n\n// src/events/nip19.ts\n\nvar DEFAULT_RELAY_COUNT = 2;\nfunction encode(maxRelayCount = DEFAULT_RELAY_COUNT) {\n  let relays = [];\n  if (this.onRelays.length > 0) {\n    relays = this.onRelays.map((relay) => relay.url);\n  } else if (this.relay) {\n    relays = [this.relay.url];\n  }\n  if (relays.length > maxRelayCount) {\n    relays = relays.slice(0, maxRelayCount);\n  }\n  if (this.isParamReplaceable()) {\n    return nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.naddrEncode({\n      kind: this.kind,\n      pubkey: this.pubkey,\n      identifier: this.replaceableDTag(),\n      relays\n    });\n  } else if (relays.length > 0) {\n    return nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.neventEncode({\n      id: this.tagId(),\n      relays,\n      author: this.pubkey\n    });\n  } else {\n    return nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.noteEncode(this.tagId());\n  }\n}\n\n// src/events/repost.ts\nasync function repost(publish = true, signer) {\n  if (!signer && publish) {\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    this.ndk.assertSigner();\n    signer = this.ndk.signer;\n  }\n  const e = new NDKEvent(this.ndk, {\n    kind: getKind(this)\n  });\n  if (!this.isProtected)\n    e.content = JSON.stringify(this.rawEvent());\n  e.tag(this);\n  if (this.kind !== 1 /* Text */) {\n    e.tags.push([\"k\", `${this.kind}`]);\n  }\n  if (signer) await e.sign(signer);\n  if (publish) await e.publish();\n  return e;\n}\nfunction getKind(event) {\n  if (event.kind === 1) {\n    return 6 /* Repost */;\n  }\n  return 16 /* GenericRepost */;\n}\n\n// src/thread/index.ts\nfunction eventsBySameAuthor(op, events) {\n  const eventsByAuthor = /* @__PURE__ */ new Map();\n  eventsByAuthor.set(op.id, op);\n  events.forEach((event) => {\n    if (event.pubkey === op.pubkey) {\n      eventsByAuthor.set(event.id, event);\n    }\n  });\n  return eventsByAuthor;\n}\nvar hasMarkers = (event, tagType) => {\n  return event.getMatchingTags(tagType).some((tag) => tag[3] && tag[3] !== \"\");\n};\nfunction eventIsReply(op, event, threadIds = /* @__PURE__ */ new Set(), tagType) {\n  tagType ??= op.tagType();\n  const tags = event.getMatchingTags(tagType);\n  threadIds.add(op.tagId());\n  if (threadIds.has(event.tagId())) return false;\n  const heedExplicitReplyMarker = () => {\n    let eventIsTagged = false;\n    for (const tag of tags) {\n      if (tag[3] === \"reply\") return threadIds.has(tag[1]);\n      const markerIsEmpty = tag[3] === \"\" || tag[3] === void 0;\n      const markerIsRoot = tag[3] === \"root\";\n      if (tag[1] === op.tagId() && (markerIsEmpty || markerIsRoot)) {\n        eventIsTagged = markerIsRoot ? \"root\" : true;\n      }\n    }\n    if (!eventIsTagged) return false;\n    if (eventIsTagged === \"root\") return true;\n  };\n  const explicitReplyMarker = heedExplicitReplyMarker();\n  if (explicitReplyMarker !== void 0) return explicitReplyMarker;\n  if (hasMarkers(event, tagType)) return false;\n  const expectedTags = op.getMatchingTags(\"e\").map((tag) => tag[1]);\n  expectedTags.push(op.id);\n  return event.getMatchingTags(\"e\").every((tag) => expectedTags.includes(tag[1]));\n}\nfunction eventThreads(op, events) {\n  const eventsByAuthor = eventsBySameAuthor(op, events);\n  const threadEvents = events.filter((event) => eventIsPartOfThread(op, event, eventsByAuthor));\n  return threadEvents.sort((a, b) => a.created_at - b.created_at);\n}\nfunction getEventReplyId(event) {\n  const replyTag = getReplyTag(event);\n  if (replyTag) return replyTag[1];\n  const rootTag = getRootTag(event);\n  if (rootTag) return rootTag[1];\n}\nfunction isEventOriginalPost(event) {\n  return getEventReplyId(event) === void 0;\n}\nfunction eventThreadIds(op, events) {\n  const threadIds = /* @__PURE__ */ new Map();\n  const threadEvents = eventThreads(op, events);\n  threadEvents.forEach((event) => threadIds.set(event.id, event));\n  return threadIds;\n}\nfunction eventReplies(op, events, threadEventIds) {\n  threadEventIds ??= new Set(eventThreadIds(op, events).keys());\n  return events.filter((event) => eventIsReply(op, event, threadEventIds));\n}\nfunction eventIsPartOfThread(op, event, eventsByAuthor) {\n  if (op.pubkey !== event.pubkey) return false;\n  const taggedEventIds = event.getMatchingTags(\"e\").map((tag) => tag[1]);\n  const allTaggedEventsAreByOriginalAuthor = taggedEventIds.every((id) => eventsByAuthor.has(id));\n  return allTaggedEventsAreByOriginalAuthor;\n}\nfunction eventHasETagMarkers(event) {\n  for (const tag of event.tags) {\n    if (tag[0] === \"e\" && (tag[3] ?? \"\").length > 0) return true;\n  }\n  return false;\n}\nfunction getRootEventId(event, searchTag) {\n  searchTag ??= event.tagType();\n  const rootEventTag = getRootTag(event, searchTag);\n  if (rootEventTag) return rootEventTag[1];\n  const replyTag = getReplyTag(event, searchTag);\n  return replyTag?.[1];\n}\nfunction getRootTag(event, searchTag) {\n  searchTag ??= event.tagType();\n  const rootEventTag = event.tags.find(isTagRootTag);\n  if (!rootEventTag) {\n    if (eventHasETagMarkers(event)) return;\n    const matchingTags = event.getMatchingTags(searchTag);\n    if (matchingTags.length < 3) return matchingTags[0];\n  }\n  return rootEventTag;\n}\nvar nip22RootTags = /* @__PURE__ */ new Set([\"A\", \"E\", \"I\"]);\nvar nip22ReplyTags = /* @__PURE__ */ new Set([\"a\", \"e\", \"i\"]);\nfunction getReplyTag(event, searchTag) {\n  if (event.kind === 1111 /* GenericReply */) {\n    let replyTag2;\n    for (const tag of event.tags) {\n      if (nip22RootTags.has(tag[0])) replyTag2 = tag;\n      else if (nip22ReplyTags.has(tag[0])) {\n        replyTag2 = tag;\n        break;\n      }\n    }\n    return replyTag2;\n  }\n  searchTag ??= event.tagType();\n  let hasMarkers2 = false;\n  let replyTag;\n  for (const tag of event.tags) {\n    if (tag[0] !== searchTag) continue;\n    if ((tag[3] ?? \"\").length > 0) hasMarkers2 = true;\n    if (hasMarkers2 && tag[3] === \"reply\") return tag;\n    if (hasMarkers2 && tag[3] === \"root\") replyTag = tag;\n    if (!hasMarkers2) replyTag = tag;\n  }\n  return replyTag;\n}\nfunction isTagRootTag(tag) {\n  return tag[0] === \"E\" || tag[3] === \"root\";\n}\n\n// src/events/fetch-tagged-event.ts\nasync function fetchTaggedEvent(tag, marker) {\n  if (!this.ndk) throw new Error(\"NDK instance not found\");\n  const t = this.getMatchingTags(tag, marker);\n  if (t.length === 0) return void 0;\n  const [_, id, hint] = t[0];\n  let relay;\n  const event = await this.ndk.fetchEvent(id, {}, relay);\n  return event;\n}\nasync function fetchRootEvent(subOpts) {\n  if (!this.ndk) throw new Error(\"NDK instance not found\");\n  const rootTag = getRootTag(this);\n  if (!rootTag) return void 0;\n  return this.ndk.fetchEventFromTag(rootTag, this, subOpts);\n}\nasync function fetchReplyEvent(subOpts) {\n  if (!this.ndk) throw new Error(\"NDK instance not found\");\n  const replyTag = getReplyTag(this);\n  if (!replyTag) return void 0;\n  return this.ndk.fetchEventFromTag(replyTag, this, subOpts);\n}\n\n// src/events/serializer.ts\nfunction serialize(includeSig = false, includeId = false) {\n  const payload = [0, this.pubkey, this.created_at, this.kind, this.tags, this.content];\n  if (includeSig) payload.push(this.sig);\n  if (includeId) payload.push(this.id);\n  return JSON.stringify(payload);\n}\nfunction deserialize(serializedEvent) {\n  const eventArray = JSON.parse(serializedEvent);\n  const ret = {\n    pubkey: eventArray[1],\n    created_at: eventArray[2],\n    kind: eventArray[3],\n    tags: eventArray[4],\n    content: eventArray[5]\n  };\n  if (eventArray.length >= 7) ret.sig = eventArray[6];\n  if (eventArray.length >= 8) ret.id = eventArray[7];\n  return ret;\n}\n\n// src/events/validation.ts\n\n\n\n\n// src/events/signature.ts\nvar worker;\nvar processingQueue = {};\nfunction signatureVerificationInit(w) {\n  worker = w;\n  worker.onmessage = (msg) => {\n    const [eventId, result] = msg.data;\n    const record = processingQueue[eventId];\n    if (!record) {\n      console.error(\"No record found for event\", eventId);\n      return;\n    }\n    delete processingQueue[eventId];\n    for (const resolve of record.resolves) {\n      resolve(result);\n    }\n  };\n}\nasync function verifySignatureAsync(event, persist) {\n  const promise = new Promise((resolve) => {\n    const serialized = event.serialize();\n    let enqueue = false;\n    if (!processingQueue[event.id]) {\n      processingQueue[event.id] = { event, resolves: [] };\n      enqueue = true;\n    }\n    processingQueue[event.id].resolves.push(resolve);\n    if (!enqueue) return;\n    worker.postMessage({\n      serialized,\n      id: event.id,\n      sig: event.sig,\n      pubkey: event.pubkey\n    });\n  });\n  return promise;\n}\n\n// src/events/validation.ts\n\nvar PUBKEY_REGEX = /^[a-f0-9]{64}$/;\nfunction validate() {\n  if (typeof this.kind !== \"number\") return false;\n  if (typeof this.content !== \"string\") return false;\n  if (typeof this.created_at !== \"number\") return false;\n  if (typeof this.pubkey !== \"string\") return false;\n  if (!this.pubkey.match(PUBKEY_REGEX)) return false;\n  if (!Array.isArray(this.tags)) return false;\n  for (let i = 0; i < this.tags.length; i++) {\n    const tag = this.tags[i];\n    if (!Array.isArray(tag)) return false;\n    for (let j = 0; j < tag.length; j++) {\n      if (typeof tag[j] === \"object\") return false;\n    }\n  }\n  return true;\n}\nvar verifiedSignatures = new typescript_lru_cache__WEBPACK_IMPORTED_MODULE_3__.LRUCache({\n  maxSize: 1e3,\n  entryExpirationTimeInMS: 6e4\n});\nfunction verifySignature(persist) {\n  if (typeof this.signatureVerified === \"boolean\") return this.signatureVerified;\n  const prevVerification = verifiedSignatures.get(this.id);\n  if (prevVerification !== null) {\n    return this.signatureVerified = !!prevVerification;\n  }\n  try {\n    if (this.ndk?.asyncSigVerification) {\n      verifySignatureAsync(this, persist).then((result) => {\n        if (persist) {\n          this.signatureVerified = result;\n          if (result) verifiedSignatures.set(this.id, this.sig);\n        }\n        if (!result) {\n          this.ndk.emit(\"event:invalid-sig\", this);\n          verifiedSignatures.set(this.id, false);\n        }\n      });\n    } else {\n      const hash = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__.sha256)(new TextEncoder().encode(this.serialize()));\n      const res = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_5__.schnorr.verify(this.sig, hash, this.pubkey);\n      if (res) verifiedSignatures.set(this.id, this.sig);\n      else verifiedSignatures.set(this.id, false);\n      return this.signatureVerified = res;\n    }\n  } catch (err) {\n    return this.signatureVerified = false;\n  }\n}\nfunction getEventHash() {\n  return getEventHashFromSerializedEvent(this.serialize());\n}\nfunction getEventHashFromSerializedEvent(serializedEvent) {\n  const eventHash = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__.sha256)(new TextEncoder().encode(serializedEvent));\n  return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_6__.bytesToHex)(eventHash);\n}\n\n// src/events/index.ts\nvar skipClientTagOnKinds = /* @__PURE__ */ new Set([\n  0 /* Metadata */,\n  4 /* EncryptedDirectMessage */,\n  1059 /* GiftWrap */,\n  13 /* GiftWrapSeal */,\n  3 /* Contacts */,\n  9734 /* ZapRequest */,\n  5 /* EventDeletion */\n]);\nvar NDKEvent = class _NDKEvent extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  ndk;\n  created_at;\n  content = \"\";\n  tags = [];\n  kind;\n  id = \"\";\n  sig;\n  pubkey = \"\";\n  signatureVerified;\n  _author = void 0;\n  /**\n   * The relay that this event was first received from.\n   */\n  relay;\n  /**\n   * The relays that this event was received from and/or successfully published to.\n   */\n  get onRelays() {\n    let res = [];\n    if (!this.ndk) {\n      if (this.relay) res.push(this.relay);\n    } else {\n      res = this.ndk.subManager.seenEvents.get(this.id) || [];\n    }\n    return res;\n  }\n  /**\n   * The status of the publish operation.\n   */\n  publishStatus = \"success\";\n  publishError;\n  constructor(ndk, event) {\n    super();\n    this.ndk = ndk;\n    this.created_at = event?.created_at;\n    this.content = event?.content || \"\";\n    this.tags = event?.tags || [];\n    this.id = event?.id || \"\";\n    this.sig = event?.sig;\n    this.pubkey = event?.pubkey || \"\";\n    this.kind = event?.kind;\n    if (event instanceof _NDKEvent) {\n      if (this.relay) {\n        this.relay = event.relay;\n        this.ndk?.subManager.seenEvent(event.id, this.relay);\n      }\n      this.publishStatus = event.publishStatus;\n      this.publishError = event.publishError;\n    }\n  }\n  /**\n   * Deserialize an NDKEvent from a serialized payload.\n   * @param ndk\n   * @param event\n   * @returns\n   */\n  static deserialize(ndk, event) {\n    return new _NDKEvent(ndk, deserialize(event));\n  }\n  /**\n   * Returns the event as is.\n   */\n  rawEvent() {\n    return {\n      created_at: this.created_at,\n      content: this.content,\n      tags: this.tags,\n      kind: this.kind,\n      pubkey: this.pubkey,\n      id: this.id,\n      sig: this.sig\n    };\n  }\n  set author(user) {\n    this.pubkey = user.pubkey;\n    this._author = user;\n    this._author.ndk ??= this.ndk;\n  }\n  /**\n   * Returns an NDKUser for the author of the event.\n   */\n  get author() {\n    if (this._author) return this._author;\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    const user = this.ndk.getUser({ pubkey: this.pubkey });\n    this._author = user;\n    return user;\n  }\n  /**\n   * NIP-73 tagging of external entities\n   * @param entity to be tagged\n   * @param type of the entity\n   * @param markerUrl to be used as the marker URL\n   *\n   * @example\n   * ```typescript\n   * event.tagExternal(\"https://example.com/article/123#nostr\", \"url\");\n   * event.tags => [[\"i\", \"https://example.com/123\"], [\"k\", \"https://example.com\"]]\n   * ```\n   *\n   * @example tag a podcast:item:guid\n   * ```typescript\n   * event.tagExternal(\"e32b4890-b9ea-4aef-a0bf-54b787833dc5\", \"podcast:item:guid\");\n   * event.tags => [[\"i\", \"podcast:item:guid:e32b4890-b9ea-4aef-a0bf-54b787833dc5\"], [\"k\", \"podcast:item:guid\"]]\n   * ```\n   *\n   * @see https://github.com/nostr-protocol/nips/blob/master/73.md\n   */\n  tagExternal(entity, type, markerUrl) {\n    let iTag = [\"i\"];\n    let kTag = [\"k\"];\n    switch (type) {\n      case \"url\":\n        const url = new URL(entity);\n        url.hash = \"\";\n        iTag.push(url.toString());\n        kTag.push(`${url.protocol}//${url.host}`);\n        break;\n      case \"hashtag\":\n        iTag.push(`#${entity.toLowerCase()}`);\n        kTag.push(\"#\");\n        break;\n      case \"geohash\":\n        iTag.push(`geo:${entity.toLowerCase()}`);\n        kTag.push(\"geo\");\n        break;\n      case \"isbn\":\n        iTag.push(`isbn:${entity.replace(/-/g, \"\")}`);\n        kTag.push(\"isbn\");\n        break;\n      case \"podcast:guid\":\n        iTag.push(`podcast:guid:${entity}`);\n        kTag.push(\"podcast:guid\");\n        break;\n      case \"podcast:item:guid\":\n        iTag.push(`podcast:item:guid:${entity}`);\n        kTag.push(\"podcast:item:guid\");\n        break;\n      case \"podcast:publisher:guid\":\n        iTag.push(`podcast:publisher:guid:${entity}`);\n        kTag.push(\"podcast:publisher:guid\");\n        break;\n      case \"isan\":\n        iTag.push(`isan:${entity.split(\"-\").slice(0, 4).join(\"-\")}`);\n        kTag.push(\"isan\");\n        break;\n      case \"doi\":\n        iTag.push(`doi:${entity.toLowerCase()}`);\n        kTag.push(\"doi\");\n        break;\n      default:\n        throw new Error(`Unsupported NIP-73 entity type: ${type}`);\n    }\n    if (markerUrl) {\n      iTag.push(markerUrl);\n    }\n    this.tags.push(iTag);\n    this.tags.push(kTag);\n  }\n  /**\n   * Tag a user with an optional marker.\n   * @param target What is to be tagged. Can be an NDKUser, NDKEvent, or an NDKTag.\n   * @param marker The marker to use in the tag.\n   * @param skipAuthorTag Whether to explicitly skip adding the author tag of the event.\n   * @param forceTag Force a specific tag to be used instead of the default \"e\" or \"a\" tag.\n   * @example\n   * ```typescript\n   * reply.tag(opEvent, \"reply\");\n   * // reply.tags => [[\"e\", <id>, <relay>, \"reply\"]]\n   * ```\n   */\n  tag(target, marker, skipAuthorTag, forceTag) {\n    let tags = [];\n    const isNDKUser = target.fetchProfile !== void 0;\n    if (isNDKUser) {\n      forceTag ??= \"p\";\n      const tag = [forceTag, target.pubkey];\n      if (marker) tag.push(...[\"\", marker]);\n      tags.push(tag);\n    } else if (target instanceof _NDKEvent) {\n      const event = target;\n      skipAuthorTag ??= event?.pubkey === this.pubkey;\n      tags = event.referenceTags(marker, skipAuthorTag, forceTag);\n      for (const pTag of event.getMatchingTags(\"p\")) {\n        if (pTag[1] === this.pubkey) continue;\n        if (this.tags.find((t) => t[0] === \"p\" && t[1] === pTag[1])) continue;\n        this.tags.push([\"p\", pTag[1]]);\n      }\n    } else if (Array.isArray(target)) {\n      tags = [target];\n    } else {\n      throw new Error(\"Invalid argument\", target);\n    }\n    this.tags = mergeTags(this.tags, tags);\n  }\n  /**\n   * Return a NostrEvent object, trying to fill in missing fields\n   * when possible, adding tags when necessary.\n   * @param pubkey {string} The pubkey of the user who the event belongs to.\n   * @returns {Promise<NostrEvent>} A promise that resolves to a NostrEvent.\n   */\n  async toNostrEvent(pubkey) {\n    if (!pubkey && this.pubkey === \"\") {\n      const user = await this.ndk?.signer?.user();\n      this.pubkey = user?.pubkey || \"\";\n    }\n    if (!this.created_at) {\n      this.created_at = Math.floor(Date.now() / 1e3);\n    }\n    const { content, tags } = await this.generateTags();\n    this.content = content || \"\";\n    this.tags = tags;\n    try {\n      this.id = this.getEventHash();\n    } catch (e) {\n    }\n    return this.rawEvent();\n  }\n  serialize = serialize.bind(this);\n  getEventHash = getEventHash.bind(this);\n  validate = validate.bind(this);\n  verifySignature = verifySignature.bind(this);\n  /**\n   * Is this event replaceable (whether parameterized or not)?\n   *\n   * This will return true for kind 0, 3, 10k-20k and 30k-40k\n   */\n  isReplaceable = isReplaceable.bind(this);\n  isEphemeral = isEphemeral.bind(this);\n  isDvm = () => this.kind && this.kind >= 5e3 && this.kind <= 7e3;\n  /**\n   * Is this event parameterized replaceable?\n   *\n   * This will return true for kind 30k-40k\n   */\n  isParamReplaceable = isParamReplaceable.bind(this);\n  /**\n   * Encodes a bech32 id.\n   *\n   * @param relays {string[]} The relays to encode in the id\n   * @returns {string} - Encoded naddr, note or nevent.\n   */\n  encode = encode.bind(this);\n  encrypt = encrypt.bind(this);\n  decrypt = decrypt.bind(this);\n  /**\n   * Get all tags with the given name\n   * @param tagName {string} The name of the tag to search for\n   * @returns {NDKTag[]} An array of the matching tags\n   */\n  getMatchingTags(tagName, marker) {\n    const t = this.tags.filter((tag) => tag[0] === tagName);\n    if (marker === void 0) return t;\n    return t.filter((tag) => tag[3] === marker);\n  }\n  /**\n   * Check if the event has a tag with the given name\n   * @param tagName\n   * @param marker\n   * @returns\n   */\n  hasTag(tagName, marker) {\n    return this.tags.some((tag) => tag[0] === tagName && (!marker || tag[3] === marker));\n  }\n  /**\n   * Get the first tag with the given name\n   * @param tagName Tag name to search for\n   * @returns The value of the first tag with the given name, or undefined if no such tag exists\n   */\n  tagValue(tagName) {\n    const tags = this.getMatchingTags(tagName);\n    if (tags.length === 0) return void 0;\n    return tags[0][1];\n  }\n  /**\n   * Gets the NIP-31 \"alt\" tag of the event.\n   */\n  get alt() {\n    return this.tagValue(\"alt\");\n  }\n  /**\n   * Sets the NIP-31 \"alt\" tag of the event. Use this to set an alt tag so\n   * clients that don't handle a particular event kind can display something\n   * useful for users.\n   */\n  set alt(alt) {\n    this.removeTag(\"alt\");\n    if (alt) this.tags.push([\"alt\", alt]);\n  }\n  /**\n   * Gets the NIP-33 \"d\" tag of the event.\n   */\n  get dTag() {\n    return this.tagValue(\"d\");\n  }\n  /**\n   * Sets the NIP-33 \"d\" tag of the event.\n   */\n  set dTag(value) {\n    this.removeTag(\"d\");\n    if (value) this.tags.push([\"d\", value]);\n  }\n  /**\n   * Remove all tags with the given name (e.g. \"d\", \"a\", \"p\")\n   * @param tagName Tag name(s) to search for and remove\n   * @returns {void}\n   */\n  removeTag(tagName) {\n    const tagNames = Array.isArray(tagName) ? tagName : [tagName];\n    this.tags = this.tags.filter((tag) => !tagNames.includes(tag[0]));\n  }\n  /**\n   * Sign the event if a signer is present.\n   *\n   * It will generate tags.\n   * Repleacable events will have their created_at field set to the current time.\n   * @param signer {NDKSigner} The NDKSigner to use to sign the event\n   * @returns {Promise<string>} A Promise that resolves to the signature of the signed event.\n   */\n  async sign(signer) {\n    if (!signer) {\n      this.ndk?.assertSigner();\n      signer = this.ndk.signer;\n    } else {\n      this.author = await signer.user();\n    }\n    const nostrEvent = await this.toNostrEvent();\n    this.sig = await signer.sign(nostrEvent);\n    return this.sig;\n  }\n  /**\n   *\n   * @param relaySet\n   * @param timeoutMs\n   * @param requiredRelayCount\n   * @returns\n   */\n  async publishReplaceable(relaySet, timeoutMs, requiredRelayCount) {\n    this.id = \"\";\n    this.created_at = Math.floor(Date.now() / 1e3);\n    this.sig = \"\";\n    return this.publish(relaySet, timeoutMs, requiredRelayCount);\n  }\n  /**\n   * Attempt to sign and then publish an NDKEvent to a given relaySet.\n   * If no relaySet is provided, the relaySet will be calculated by NDK.\n   * @param relaySet {NDKRelaySet} The relaySet to publish the even to.\n   * @param timeoutM {number} The timeout for the publish operation in milliseconds.\n   * @param requiredRelayCount The number of relays that must receive the event for the publish to be considered successful.\n   * @returns A promise that resolves to the relays the event was published to.\n   */\n  async publish(relaySet, timeoutMs, requiredRelayCount) {\n    if (!this.sig) await this.sign();\n    if (!this.ndk)\n      throw new Error(\"NDKEvent must be associated with an NDK instance to publish\");\n    if (!relaySet) {\n      relaySet = this.ndk.devWriteRelaySet || await calculateRelaySetFromEvent(this.ndk, this);\n    }\n    if (this.kind === 5 /* EventDeletion */ && this.ndk.cacheAdapter?.deleteEventIds) {\n      const eTags = this.getMatchingTags(\"e\").map((tag) => tag[1]);\n      this.ndk.cacheAdapter.deleteEventIds(eTags);\n    }\n    const rawEvent = this.rawEvent();\n    if (this.ndk.cacheAdapter?.addUnpublishedEvent && shouldTrackUnpublishedEvent(this)) {\n      try {\n        this.ndk.cacheAdapter.addUnpublishedEvent(this, relaySet.relayUrls);\n      } catch (e) {\n        console.error(\"Error adding unpublished event to cache\", e);\n      }\n    }\n    if (this.kind === 5 /* EventDeletion */ && this.ndk.cacheAdapter?.deleteEventIds) {\n      this.ndk.cacheAdapter.deleteEventIds(this.getMatchingTags(\"e\").map((tag) => tag[1]));\n    }\n    this.ndk.subManager.dispatchEvent(rawEvent, void 0, true);\n    const relays = await relaySet.publish(this, timeoutMs, requiredRelayCount);\n    relays.forEach((relay) => this.ndk?.subManager.seenEvent(this.id, relay));\n    return relays;\n  }\n  /**\n   * Generates tags for users, notes, and other events tagged in content.\n   * Will also generate random \"d\" tag for parameterized replaceable events where needed.\n   * @returns {ContentTag} The tags and content of the event.\n   */\n  async generateTags() {\n    let tags = [];\n    const g = await generateContentTags(this.content, this.tags);\n    const content = g.content;\n    tags = g.tags;\n    if (this.kind && this.isParamReplaceable()) {\n      const dTag = this.getMatchingTags(\"d\")[0];\n      if (!dTag) {\n        const title = this.tagValue(\"title\");\n        const randLength = title ? 6 : 16;\n        let str = [...Array(randLength)].map(() => Math.random().toString(36)[2]).join(\"\");\n        if (title && title.length > 0) {\n          str = title.replace(/[^a-z0-9]+/gi, \"-\").replace(/^-|-$/g, \"\") + \"-\" + str;\n        }\n        tags.push([\"d\", str]);\n      }\n    }\n    if (this.shouldAddClientTag) {\n      const clientTag = [\"client\", this.ndk.clientName ?? \"\"];\n      if (this.ndk.clientNip89) clientTag.push(this.ndk.clientNip89);\n      tags.push(clientTag);\n    } else if (this.shouldStripClientTag) {\n      tags = tags.filter((tag) => tag[0] !== \"client\");\n    }\n    return { content: content || \"\", tags };\n  }\n  get shouldAddClientTag() {\n    if (!this.ndk?.clientName && !this.ndk?.clientNip89) return false;\n    if (skipClientTagOnKinds.has(this.kind)) return false;\n    if (this.isEphemeral() || this.isReplaceable()) return false;\n    if (this.isDvm()) return false;\n    if (this.hasTag(\"client\")) return false;\n    return true;\n  }\n  get shouldStripClientTag() {\n    return skipClientTagOnKinds.has(this.kind);\n  }\n  muted() {\n    const authorMutedEntry = this.ndk?.mutedIds.get(this.pubkey);\n    if (authorMutedEntry && authorMutedEntry === \"p\") return \"author\";\n    const eventTagReference = this.tagReference();\n    const eventMutedEntry = this.ndk?.mutedIds.get(eventTagReference[1]);\n    if (eventMutedEntry && eventMutedEntry === eventTagReference[0]) return \"event\";\n    return null;\n  }\n  /**\n   * Returns the \"d\" tag of a parameterized replaceable event or throws an error if the event isn't\n   * a parameterized replaceable event.\n   * @returns {string} the \"d\" tag of the event.\n   * \n   * @deprecated Use `dTag` instead.\n   */\n  replaceableDTag() {\n    if (this.kind && this.kind >= 3e4 && this.kind <= 4e4) {\n      const dTag = this.getMatchingTags(\"d\")[0];\n      const dTagId = dTag ? dTag[1] : \"\";\n      return dTagId;\n    }\n    throw new Error(\"Event is not a parameterized replaceable event\");\n  }\n  /**\n   * Provides a deduplication key for the event.\n   *\n   * For kinds 0, 3, 10k-20k this will be the event <kind>:<pubkey>\n   * For kinds 30k-40k this will be the event <kind>:<pubkey>:<d-tag>\n   * For all other kinds this will be the event id\n   */\n  deduplicationKey() {\n    if (this.kind === 0 || this.kind === 3 || this.kind && this.kind >= 1e4 && this.kind < 2e4) {\n      return `${this.kind}:${this.pubkey}`;\n    } else {\n      return this.tagId();\n    }\n  }\n  /**\n   * Returns the id of the event or, if it's a parameterized event, the generated id of the event using \"d\" tag, pubkey, and kind.\n   * @returns {string} The id\n   */\n  tagId() {\n    if (this.isParamReplaceable()) {\n      return this.tagAddress();\n    }\n    return this.id;\n  }\n  /**\n   * Returns a stable reference value for a replaceable event.\n   * \n   * Param replaceable events are returned in the expected format of `<kind>:<pubkey>:<d-tag>`.\n   * Kind-replaceable events are returned in the format of `<kind>:<pubkey>:`.\n   * \n   * @returns {string} A stable reference value for replaceable events\n   */\n  tagAddress() {\n    if (this.isParamReplaceable()) {\n      const dTagId = this.dTag ?? \"\";\n      return `${this.kind}:${this.pubkey}:${dTagId}`;\n    } else if (this.isReplaceable()) {\n      return `${this.kind}:${this.pubkey}:`;\n    }\n    throw new Error(\"Event is not a replaceable event\");\n  }\n  /**\n   * Determines the type of tag that can be used to reference this event from another event.\n   * @returns {string} The tag type\n   * @example\n   * event = new NDKEvent(ndk, { kind: 30000, pubkey: 'pubkey', tags: [ [\"d\", \"d-code\"] ] });\n   * event.tagType(); // \"a\"\n   */\n  tagType() {\n    return this.isParamReplaceable() ? \"a\" : \"e\";\n  }\n  /**\n   * Get the tag that can be used to reference this event from another event.\n   *\n   * Consider using referenceTags() instead (unless you have a good reason to use this)\n   *\n   * @example\n   *     event = new NDKEvent(ndk, { kind: 30000, pubkey: 'pubkey', tags: [ [\"d\", \"d-code\"] ] });\n   *     event.tagReference(); // [\"a\", \"30000:pubkey:d-code\"]\n   *\n   *     event = new NDKEvent(ndk, { kind: 1, pubkey: 'pubkey', id: \"eventid\" });\n   *     event.tagReference(); // [\"e\", \"eventid\"]\n   * @returns {NDKTag} The NDKTag object referencing this event\n   */\n  tagReference(marker) {\n    let tag;\n    if (this.isParamReplaceable()) {\n      tag = [\"a\", this.tagAddress()];\n    } else {\n      tag = [\"e\", this.tagId()];\n    }\n    if (this.relay) {\n      tag.push(this.relay.url);\n    } else {\n      tag.push(\"\");\n    }\n    tag.push(marker ?? \"\");\n    if (!this.isParamReplaceable()) {\n      tag.push(this.pubkey);\n    }\n    return tag;\n  }\n  /**\n   * Get the tags that can be used to reference this event from another event\n   * @param marker The marker to use in the tag\n   * @param skipAuthorTag Whether to explicitly skip adding the author tag of the event\n   * @param forceTag Force a specific tag to be used instead of the default \"e\" or \"a\" tag\n   * @example\n   *     event = new NDKEvent(ndk, { kind: 30000, pubkey: 'pubkey', tags: [ [\"d\", \"d-code\"] ] });\n   *     event.referenceTags(); // [[\"a\", \"30000:pubkey:d-code\"], [\"e\", \"parent-id\"]]\n   *\n   *     event = new NDKEvent(ndk, { kind: 1, pubkey: 'pubkey', id: \"eventid\" });\n   *     event.referenceTags(); // [[\"e\", \"parent-id\"]]\n   * @returns {NDKTag} The NDKTag object referencing this event\n   */\n  referenceTags(marker, skipAuthorTag, forceTag) {\n    let tags = [];\n    if (this.isParamReplaceable()) {\n      tags = [\n        [forceTag ?? \"a\", this.tagAddress()],\n        [forceTag ?? \"e\", this.id]\n      ];\n    } else {\n      tags = [[forceTag ?? \"e\", this.id]];\n    }\n    tags = tags.map((tag) => {\n      if (tag[0] === \"e\" || marker) {\n        tag.push(this.relay?.url ?? \"\");\n      } else if (this.relay?.url) {\n        tag.push(this.relay?.url);\n      }\n      return tag;\n    });\n    tags.forEach((tag) => {\n      if (tag[0] === \"e\") {\n        tag.push(marker ?? \"\");\n        tag.push(this.pubkey);\n      } else if (marker) {\n        tag.push(marker);\n      }\n    });\n    tags = [...tags, ...this.getMatchingTags(\"h\")];\n    if (!skipAuthorTag) tags.push(...this.author.referenceTags());\n    return tags;\n  }\n  /**\n   * Provides the filter that will return matching events for this event.\n   *\n   * @example\n   *    event = new NDKEvent(ndk, { kind: 30000, pubkey: 'pubkey', tags: [ [\"d\", \"d-code\"] ] });\n   *    event.filter(); // { \"#a\": [\"30000:pubkey:d-code\"] }\n   * @example\n   *    event = new NDKEvent(ndk, { kind: 1, pubkey: 'pubkey', id: \"eventid\" });\n   *    event.filter(); // { \"#e\": [\"eventid\"] }\n   *\n   * @returns The filter that will return matching events for this event\n   */\n  filter() {\n    if (this.isParamReplaceable()) {\n      return { \"#a\": [this.tagId()] };\n    } else {\n      return { \"#e\": [this.tagId()] };\n    }\n  }\n  nip22Filter() {\n    if (this.isParamReplaceable()) {\n      return { \"#A\": [this.tagId()] };\n    } else {\n      return { \"#E\": [this.tagId()] };\n    }\n  }\n  /**\n   * Generates a deletion event of the current event\n   *\n   * @param reason The reason for the deletion\n   * @param publish Whether to publish the deletion event automatically\n   * @returns The deletion event\n   */\n  async delete(reason, publish = true) {\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    this.ndk.assertSigner();\n    const e = new _NDKEvent(this.ndk, {\n      kind: 5 /* EventDeletion */,\n      content: reason || \"\"\n    });\n    e.tag(this, void 0, true);\n    e.tags.push([\"k\", this.kind.toString()]);\n    if (publish) {\n      this.emit(\"deleted\");\n      await e.publish();\n    }\n    return e;\n  }\n  /**\n   * Establishes whether this is a NIP-70-protectede event.\n   * @@satisfies NIP-70\n   */\n  set isProtected(val) {\n    this.removeTag(\"-\");\n    if (val) this.tags.push([\"-\"]);\n  }\n  /**\n   * Whether this is a NIP-70-protectede event.\n   * @@satisfies NIP-70\n   */\n  get isProtected() {\n    return this.hasTag(\"-\");\n  }\n  /**\n   * Fetch an event tagged with the given tag following relay hints if provided.\n   * @param tag The tag to search for\n   * @param marker The marker to use in the tag (e.g. \"root\")\n   * @returns The fetched event or null if no event was found, undefined if no matching tag was found in the event\n   * * @example\n   * const replyEvent = await ndk.fetchEvent(\"nevent1qqs8x8vnycyha73grv380gmvlury4wtmx0nr9a5ds2dngqwgu87wn6gpzemhxue69uhhyetvv9ujuurjd9kkzmpwdejhgq3ql2vyh47mk2p0qlsku7hg0vn29faehy9hy34ygaclpn66ukqp3afqz4cwjd\")\n   * const originalEvent = await replyEvent.fetchTaggedEvent(\"e\", \"reply\");\n   * console.log(replyEvent.encode() + \" is a reply to event \" + originalEvent?.encode());\n   */\n  fetchTaggedEvent = fetchTaggedEvent.bind(this);\n  /**\n   * Fetch the root event of the current event.\n   * @returns The fetched root event or null if no event was found\n   * @example\n   * const replyEvent = await ndk.fetchEvent(\"nevent1qqs8x8vnycyha73grv380gmvlury4wtmx0nr9a5ds2dngqwgu87wn6gpzemhxue69uhhyetvv9ujuurjd9kkzmpwdejhgq3ql2vyh47mk2p0qlsku7hg0vn29faehy9hy34ygaclpn66ukqp3afqz4cwjd\")\n   * const rootEvent = await replyEvent.fetchRootEvent();\n   * console.log(replyEvent.encode() + \" is a reply in the thread \" + rootEvent?.encode());\n   */\n  fetchRootEvent = fetchRootEvent.bind(this);\n  /**\n   * Fetch the event the current event is replying to.\n   * @returns The fetched reply event or null if no event was found\n   */\n  fetchReplyEvent = fetchReplyEvent.bind(this);\n  /**\n   * NIP-18 reposting event.\n   *\n   * @param publish Whether to publish the reposted event automatically @default true\n   * @param signer The signer to use for signing the reposted event\n   * @returns The reposted event\n   *\n   * @function\n   */\n  repost = repost.bind(this);\n  /**\n   * React to an existing event\n   *\n   * @param content The content of the reaction\n   */\n  async react(content, publish = true) {\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    this.ndk.assertSigner();\n    const e = new _NDKEvent(this.ndk, {\n      kind: 7 /* Reaction */,\n      content\n    });\n    e.tag(this);\n    if (publish) await e.publish();\n    return e;\n  }\n  /**\n   * Checks whether the event is valid per underlying NIPs.\n   *\n   * This method is meant to be overridden by subclasses that implement specific NIPs\n   * to allow the enforcement of NIP-specific validation rules.\n   *\n   * Otherwise, it will only check for basic event properties.\n   *\n   */\n  get isValid() {\n    return this.validate();\n  }\n  /**\n   * Creates a reply event for the current event.\n   * \n   * This function will use NIP-22 when appropriate (i.e. replies to non-kind:1 events).\n   * This function does not have side-effects; it will just return an event with the appropriate tags\n   * to generate the reply event; the caller is responsible for publishing the event.\n   */\n  reply() {\n    const reply = new _NDKEvent(this.ndk);\n    if (this.kind === 1) {\n      reply.kind = 1;\n      const opHasETag = this.hasTag(\"e\");\n      if (opHasETag) {\n        reply.tags = [\n          ...reply.tags,\n          ...this.getMatchingTags(\"e\"),\n          ...this.getMatchingTags(\"p\"),\n          ...this.getMatchingTags(\"a\"),\n          ...this.referenceTags(\"reply\")\n        ];\n      } else {\n        reply.tag(this, \"root\");\n      }\n    } else {\n      reply.kind = 1111 /* GenericReply */;\n      const carryOverTags = [\"A\", \"E\", \"I\", \"P\"];\n      const rootTags = this.tags.filter((tag) => carryOverTags.includes(tag[0]));\n      if (rootTags.length > 0) {\n        const rootKind = this.tagValue(\"K\");\n        reply.tags.push(...rootTags);\n        if (rootKind) reply.tags.push([\"K\", rootKind]);\n        const [type, id, _, ...extra] = this.tagReference();\n        const tag = [type, id, ...extra];\n        reply.tags.push(tag);\n      } else {\n        const [type, id, _, relayHint] = this.tagReference();\n        const tag = [type, id, relayHint ?? \"\"];\n        if (type === \"e\") tag.push(this.pubkey);\n        reply.tags.push(tag);\n        const uppercaseTag = [...tag];\n        uppercaseTag[0] = uppercaseTag[0].toUpperCase();\n        reply.tags.push(uppercaseTag);\n        reply.tags.push([\"K\", this.kind.toString()]);\n        reply.tags.push([\"P\", this.pubkey]);\n      }\n      reply.tags.push([\"k\", this.kind.toString()]);\n      reply.tags.push(...this.getMatchingTags(\"p\"));\n      reply.tags.push([\"p\", this.pubkey]);\n    }\n    return reply;\n  }\n};\nvar untrackedUnpublishedEvents = /* @__PURE__ */ new Set([\n  24133 /* NostrConnect */,\n  13194 /* NostrWaletConnectInfo */,\n  23194 /* NostrWalletConnectReq */,\n  23195 /* NostrWalletConnectRes */\n]);\nfunction shouldTrackUnpublishedEvent(event) {\n  return !untrackedUnpublishedEvents.has(event.kind);\n}\n\n// src/relay/pool/index.ts\n\nvar NDKPool = class extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  // TODO: This should probably be an LRU cache\n  _relays = /* @__PURE__ */ new Map();\n  status = \"idle\";\n  autoConnectRelays = /* @__PURE__ */ new Set();\n  poolBlacklistRelayUrls = /* @__PURE__ */ new Set();\n  debug;\n  temporaryRelayTimers = /* @__PURE__ */ new Map();\n  flappingRelays = /* @__PURE__ */ new Set();\n  // A map to store timeouts for each flapping relay.\n  backoffTimes = /* @__PURE__ */ new Map();\n  ndk;\n  get blacklistRelayUrls() {\n    const val = new Set(this.ndk.blacklistRelayUrls);\n    this.poolBlacklistRelayUrls.forEach((url) => val.add(url));\n    return val;\n  }\n  /**\n   * @param relayUrls - The URLs of the relays to connect to.\n   * @param blacklistedRelayUrls - URLs to blacklist for this pool IN ADDITION to those blacklisted at the ndk-level\n   * @param ndk - The NDK instance.\n   * @param opts - Options for the pool.\n   */\n  constructor(relayUrls = [], blacklistedRelayUrls = [], ndk, { debug: debug8, name } = {}) {\n    super();\n    this.debug = debug8 ?? ndk.debug.extend(\"pool\");\n    if (name) this._name = name;\n    this.ndk = ndk;\n    this.relayUrls = relayUrls;\n    this.poolBlacklistRelayUrls = new Set(blacklistedRelayUrls);\n    this.ndk.pools.push(this);\n  }\n  get relays() {\n    return this._relays;\n  }\n  set relayUrls(urls) {\n    this._relays.clear();\n    for (const relayUrl of urls) {\n      const relay = new NDKRelay(relayUrl, void 0, this.ndk);\n      relay.connectivity.netDebug = this.ndk.netDebug;\n      this.addRelay(relay);\n    }\n  }\n  _name = \"unnamed\";\n  get name() {\n    return this._name;\n  }\n  set name(name) {\n    this._name = name;\n    this.debug = this.debug.extend(name);\n  }\n  /**\n   * Adds a relay to the pool, and sets a timer to remove it if it is not used within the specified time.\n   * @param relay - The relay to add to the pool.\n   * @param removeIfUnusedAfter - The time in milliseconds to wait before removing the relay from the pool after it is no longer used.\n   */\n  useTemporaryRelay(relay, removeIfUnusedAfter = 3e4, filters) {\n    const relayAlreadyInPool = this.relays.has(relay.url);\n    if (!relayAlreadyInPool) {\n      this.addRelay(relay);\n      this.debug(\"Adding temporary relay %s for filters %o\", relay.url, filters);\n    }\n    const existingTimer = this.temporaryRelayTimers.get(relay.url);\n    if (existingTimer) {\n      clearTimeout(existingTimer);\n    }\n    if (!relayAlreadyInPool || existingTimer) {\n      const timer = setTimeout(() => {\n        if (this.ndk.explicitRelayUrls?.includes(relay.url)) return;\n        this.removeRelay(relay.url);\n      }, removeIfUnusedAfter);\n      this.temporaryRelayTimers.set(relay.url, timer);\n    }\n  }\n  /**\n   * Adds a relay to the pool.\n   *\n   * @param relay - The relay to add to the pool.\n   * @param connect - Whether or not to connect to the relay.\n   */\n  addRelay(relay, connect = true) {\n    const isAlreadyInPool = this.relays.has(relay.url);\n    const isBlacklisted = this.blacklistRelayUrls?.has(relay.url);\n    const isCustomRelayUrl = relay.url.includes(\"/npub1\");\n    let reconnect = true;\n    const relayUrl = relay.url;\n    if (isAlreadyInPool) return;\n    if (isBlacklisted) {\n      this.debug(`Refusing to add relay ${relayUrl}: blacklisted`);\n      return;\n    }\n    if (isCustomRelayUrl) {\n      this.debug(`Refusing to add relay ${relayUrl}: is a filter relay`);\n      return;\n    }\n    if (this.ndk.cacheAdapter?.getRelayStatus) {\n      const info = this.ndk.cacheAdapter.getRelayStatus(relayUrl);\n      if (info && info.dontConnectBefore) {\n        if (info.dontConnectBefore > Date.now()) {\n          const delay = info.dontConnectBefore - Date.now();\n          this.debug(`Refusing to add relay ${relayUrl}: delayed connect for ${delay}ms`);\n          setTimeout(() => {\n            this.addRelay(relay, connect);\n          }, delay);\n          return;\n        } else {\n          reconnect = false;\n        }\n      }\n    }\n    const noticeHandler = (notice) => this.emit(\"notice\", relay, notice);\n    const connectHandler = () => this.handleRelayConnect(relayUrl);\n    const readyHandler = () => this.handleRelayReady(relay);\n    const disconnectHandler = () => this.emit(\"relay:disconnect\", relay);\n    const flappingHandler = () => this.handleFlapping(relay);\n    const authHandler = (challenge) => this.emit(\"relay:auth\", relay, challenge);\n    const authedHandler = () => this.emit(\"relay:authed\", relay);\n    relay.off(\"notice\", noticeHandler);\n    relay.off(\"connect\", connectHandler);\n    relay.off(\"ready\", readyHandler);\n    relay.off(\"disconnect\", disconnectHandler);\n    relay.off(\"flapping\", flappingHandler);\n    relay.off(\"auth\", authHandler);\n    relay.off(\"authed\", authedHandler);\n    relay.on(\"notice\", noticeHandler);\n    relay.on(\"connect\", connectHandler);\n    relay.on(\"ready\", readyHandler);\n    relay.on(\"disconnect\", disconnectHandler);\n    relay.on(\"flapping\", flappingHandler);\n    relay.on(\"auth\", authHandler);\n    relay.on(\"authed\", authedHandler);\n    relay.on(\"delayed-connect\", (delay) => {\n      if (this.ndk.cacheAdapter?.updateRelayStatus) {\n        this.ndk.cacheAdapter.updateRelayStatus(relay.url, {\n          dontConnectBefore: Date.now() + delay\n        });\n      }\n    });\n    this._relays.set(relayUrl, relay);\n    if (connect) this.autoConnectRelays.add(relayUrl);\n    if (connect && this.status === \"active\") {\n      this.emit(\"relay:connecting\", relay);\n      relay.connect(void 0, reconnect).catch((e) => {\n        this.debug(`Failed to connect to relay ${relayUrl}`, e);\n      });\n    }\n  }\n  /**\n   * Removes a relay from the pool.\n   * @param relayUrl - The URL of the relay to remove.\n   * @returns {boolean} True if the relay was removed, false if it was not found.\n   */\n  removeRelay(relayUrl) {\n    const relay = this.relays.get(relayUrl);\n    if (relay) {\n      relay.disconnect();\n      this.relays.delete(relayUrl);\n      this.autoConnectRelays.delete(relayUrl);\n      this.emit(\"relay:disconnect\", relay);\n      return true;\n    }\n    const existingTimer = this.temporaryRelayTimers.get(relayUrl);\n    if (existingTimer) {\n      clearTimeout(existingTimer);\n      this.temporaryRelayTimers.delete(relayUrl);\n    }\n    return false;\n  }\n  /**\n   * Checks whether a relay is already connected in the pool.\n   */\n  isRelayConnected(url) {\n    const normalizedUrl = normalizeRelayUrl(url);\n    const relay = this.relays.get(normalizedUrl);\n    if (!relay) return false;\n    return relay.status === 5 /* CONNECTED */;\n  }\n  /**\n   * Fetches a relay from the pool, or creates a new one if it does not exist.\n   *\n   * New relays will be attempted to be connected.\n   */\n  getRelay(url, connect = true, temporary = false, filters) {\n    let relay = this.relays.get(normalizeRelayUrl(url));\n    if (!relay) {\n      relay = new NDKRelay(url, void 0, this.ndk);\n      relay.connectivity.netDebug = this.ndk.netDebug;\n      if (temporary) {\n        this.useTemporaryRelay(relay, 3e4, filters);\n      } else {\n        this.addRelay(relay, connect);\n      }\n    }\n    return relay;\n  }\n  handleRelayConnect(relayUrl) {\n    const relay = this.relays.get(relayUrl);\n    if (!relay) {\n      console.error(\"NDK BUG: relay not found in pool\", { relayUrl });\n      return;\n    }\n    this.emit(\"relay:connect\", relay);\n    if (this.stats().connected === this.relays.size) {\n      this.emit(\"connect\");\n    }\n  }\n  handleRelayReady(relay) {\n    this.emit(\"relay:ready\", relay);\n  }\n  /**\n   * Attempts to establish a connection to each relay in the pool.\n   *\n   * @async\n   * @param {number} [timeoutMs] - Optional timeout in milliseconds for each connection attempt.\n   * @returns {Promise<void>} A promise that resolves when all connection attempts have completed.\n   * @throws {Error} If any of the connection attempts result in an error or timeout.\n   */\n  async connect(timeoutMs) {\n    const promises = [];\n    this.status = \"active\";\n    this.debug(\n      `Connecting to ${this.relays.size} relays${timeoutMs ? `, timeout ${timeoutMs}...` : \"\"}`\n    );\n    const relaysToConnect = new Set(this.autoConnectRelays.keys());\n    for (const relayUrl of relaysToConnect) {\n      const relay = this.relays.get(relayUrl);\n      if (!relay) {\n        console.log(`Relay ${relayUrl} not found in pool ${this.name}`);\n        continue;\n      }\n      const connectPromise = new Promise((resolve, reject) => {\n        this.emit(\"relay:connecting\", relay);\n        return relay.connect(timeoutMs).then(resolve).catch(reject);\n      });\n      if (timeoutMs) {\n        const timeoutPromise = new Promise((_, reject) => {\n          setTimeout(() => reject(`Timed out after ${timeoutMs}ms`), timeoutMs);\n        });\n        promises.push(\n          Promise.race([connectPromise, timeoutPromise]).catch((e) => {\n            this.debug(\n              `Failed to connect to relay ${relay.url}: ${e ?? \"No reason specified\"}`\n            );\n          })\n        );\n      } else {\n        promises.push(connectPromise);\n      }\n    }\n    const maybeEmitConnect = () => {\n      const allConnected = this.stats().connected === this.relays.size;\n      const someConnected = this.stats().connected > 0;\n      if (!allConnected && someConnected) {\n        this.emit(\"connect\");\n      }\n    };\n    if (timeoutMs)\n      setTimeout(maybeEmitConnect, timeoutMs);\n    await Promise.all(promises);\n    maybeEmitConnect();\n  }\n  checkOnFlappingRelays() {\n    const flappingRelaysCount = this.flappingRelays.size;\n    const totalRelays = this.relays.size;\n    if (flappingRelaysCount / totalRelays >= 0.8) {\n      for (const relayUrl of this.flappingRelays) {\n        this.backoffTimes.set(relayUrl, 0);\n      }\n    }\n  }\n  handleFlapping(relay) {\n    this.debug(`Relay ${relay.url} is flapping`);\n    let currentBackoff = this.backoffTimes.get(relay.url) || 5e3;\n    currentBackoff = currentBackoff * 2;\n    this.backoffTimes.set(relay.url, currentBackoff);\n    this.debug(`Backoff time for ${relay.url} is ${currentBackoff}ms`);\n    setTimeout(() => {\n      this.debug(`Attempting to reconnect to ${relay.url}`);\n      this.emit(\"relay:connecting\", relay);\n      relay.connect();\n      this.checkOnFlappingRelays();\n    }, currentBackoff);\n    relay.disconnect();\n    this.emit(\"flapping\", relay);\n  }\n  size() {\n    return this.relays.size;\n  }\n  /**\n   * Returns the status of each relay in the pool.\n   * @returns {NDKPoolStats} An object containing the number of relays in each status.\n   */\n  stats() {\n    const stats = {\n      total: 0,\n      connected: 0,\n      disconnected: 0,\n      connecting: 0\n    };\n    for (const relay of this.relays.values()) {\n      stats.total++;\n      if (relay.status === 5 /* CONNECTED */) {\n        stats.connected++;\n      } else if (relay.status === 1 /* DISCONNECTED */) {\n        stats.disconnected++;\n      } else if (relay.status === 4 /* CONNECTING */) {\n        stats.connecting++;\n      }\n    }\n    return stats;\n  }\n  connectedRelays() {\n    return Array.from(this.relays.values()).filter(\n      (relay) => relay.status >= 5 /* CONNECTED */\n    );\n  }\n  permanentAndConnectedRelays() {\n    return Array.from(this.relays.values()).filter(\n      (relay) => relay.status >= 5 /* CONNECTED */ && !this.temporaryRelayTimers.has(relay.url)\n    );\n  }\n  /**\n   * Get a list of all relay urls in the pool.\n   */\n  urls() {\n    return Array.from(this.relays.keys());\n  }\n};\n\n// src/user/index.ts\n\n\n// src/subscription/index.ts\n\n\n// src/subscription/utils.ts\n\nvar MAX_SUBID_LENGTH = 20;\nfunction queryFullyFilled(subscription) {\n  if (filterIncludesIds(subscription.filter)) {\n    if (resultHasAllRequestedIds(subscription)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction compareFilter(filter1, filter2) {\n  if (Object.keys(filter1).length !== Object.keys(filter2).length) return false;\n  for (const [key, value] of Object.entries(filter1)) {\n    const valuesInFilter2 = filter2[key];\n    if (!valuesInFilter2) return false;\n    if (Array.isArray(value) && Array.isArray(valuesInFilter2)) {\n      const v = value;\n      for (const valueInFilter2 of valuesInFilter2) {\n        const val = valueInFilter2;\n        if (!v.includes(val)) {\n          return false;\n        }\n      }\n    } else {\n      if (valuesInFilter2 !== value) return false;\n    }\n  }\n  return true;\n}\nfunction filterIncludesIds(filter) {\n  return !!filter[\"ids\"];\n}\nfunction resultHasAllRequestedIds(subscription) {\n  const ids = subscription.filter[\"ids\"];\n  return !!ids && ids.length === subscription.eventFirstSeen.size;\n}\nfunction generateSubId(subscriptions, filters) {\n  const subIds = subscriptions.map((sub) => sub.subId).filter(Boolean);\n  const subIdParts = [];\n  const filterNonKindKeys = /* @__PURE__ */ new Set();\n  const filterKinds = /* @__PURE__ */ new Set();\n  if (subIds.length > 0) {\n    subIdParts.push(Array.from(new Set(subIds)).join(\",\"));\n  } else {\n    for (const filter of filters) {\n      for (const key of Object.keys(filter)) {\n        if (key === \"kinds\") {\n          filter.kinds?.forEach((k) => filterKinds.add(k));\n        } else {\n          filterNonKindKeys.add(key);\n        }\n      }\n    }\n    if (filterKinds.size > 0) {\n      subIdParts.push(\"kinds:\" + Array.from(filterKinds).join(\",\"));\n    }\n    if (filterNonKindKeys.size > 0) {\n      subIdParts.push(Array.from(filterNonKindKeys).join(\",\"));\n    }\n  }\n  let subId = subIdParts.join(\"-\");\n  if (subId.length > MAX_SUBID_LENGTH) subId = subId.substring(0, MAX_SUBID_LENGTH);\n  subId += \"-\" + Math.floor(Math.random() * 999).toString();\n  return subId;\n}\nfunction filterForEventsTaggingId(id) {\n  try {\n    const decoded = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.decode(id);\n    switch (decoded.type) {\n      case \"naddr\":\n        return {\n          \"#a\": [\n            `${decoded.data.kind}:${decoded.data.pubkey}:${decoded.data.identifier}`\n          ]\n        };\n      case \"nevent\":\n        return { \"#e\": [decoded.data.id] };\n      case \"note\":\n        return { \"#e\": [decoded.data] };\n      case \"nprofile\":\n        return { \"#p\": [decoded.data.pubkey] };\n      case \"npub\":\n        return { \"#p\": [decoded.data] };\n    }\n  } catch {\n  }\n}\nfunction filterAndRelaySetFromBech32(beche2, ndk) {\n  const filter = filterFromId(beche2);\n  const relays = relaysFromBech32(beche2, ndk);\n  if (relays.length === 0) return { filter };\n  return {\n    filter,\n    relaySet: new NDKRelaySet(new Set(relays), ndk)\n  };\n}\nfunction filterFromId(id) {\n  let decoded;\n  if (id.match(NIP33_A_REGEX)) {\n    const [kind, pubkey, identifier] = id.split(\":\");\n    const filter = {\n      authors: [pubkey],\n      kinds: [parseInt(kind)]\n    };\n    if (identifier) {\n      filter[\"#d\"] = [identifier];\n    }\n    return filter;\n  }\n  if (id.match(BECH32_REGEX)) {\n    try {\n      decoded = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.decode(id);\n      switch (decoded.type) {\n        case \"nevent\": {\n          const filter2 = { ids: [decoded.data.id] };\n          if (decoded.data.author) filter2.authors = [decoded.data.author];\n          if (decoded.data.kind) filter2.kinds = [decoded.data.kind];\n          return filter2;\n        }\n        case \"note\":\n          return { ids: [decoded.data] };\n        case \"naddr\":\n          const filter = {\n            authors: [decoded.data.pubkey],\n            kinds: [decoded.data.kind]\n          };\n          if (decoded.data.identifier) filter[\"#d\"] = [decoded.data.identifier];\n          return filter;\n      }\n    } catch (e) {\n      console.error(\"Error decoding\", id, e);\n    }\n  }\n  return { ids: [id] };\n}\nfunction isNip33AValue(value) {\n  return value.match(NIP33_A_REGEX) !== null;\n}\nvar NIP33_A_REGEX = /^(\\d+):([0-9A-Fa-f]+)(?::(.*))?$/;\nvar BECH32_REGEX = /^n(event|ote|profile|pub|addr)1[\\d\\w]+$/;\nfunction relaysFromBech32(bech322, ndk) {\n  try {\n    const decoded = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.decode(bech322);\n    if ([\"naddr\", \"nevent\"].includes(decoded?.type)) {\n      const data = decoded.data;\n      if (data?.relays) {\n        return data.relays.map(\n          (r) => new NDKRelay(r, ndk.relayAuthDefaultPolicy, ndk)\n        );\n      }\n    }\n  } catch (e) {\n  }\n  return [];\n}\n\n// src/events/kinds/article.ts\nvar NDKArticle = class _NDKArticle extends NDKEvent {\n  static kind = 30023 /* Article */;\n  static kinds = [30023 /* Article */];\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 30023 /* Article */;\n  }\n  /**\n   * Creates a NDKArticle from an existing NDKEvent.\n   *\n   * @param event NDKEvent to create the NDKArticle from.\n   * @returns NDKArticle\n   */\n  static from(event) {\n    return new _NDKArticle(event.ndk, event);\n  }\n  /**\n   * Getter for the article title.\n   *\n   * @returns {string | undefined} - The article title if available, otherwise undefined.\n   */\n  get title() {\n    return this.tagValue(\"title\");\n  }\n  /**\n   * Setter for the article title.\n   *\n   * @param {string | undefined} title - The title to set for the article.\n   */\n  set title(title) {\n    this.removeTag(\"title\");\n    if (title) this.tags.push([\"title\", title]);\n  }\n  /**\n   * Getter for the article image.\n   *\n   * @returns {string | undefined} - The article image if available, otherwise undefined.\n   */\n  get image() {\n    return this.tagValue(\"image\");\n  }\n  /**\n   * Setter for the article image.\n   *\n   * @param {string | undefined} image - The image to set for the article.\n   */\n  set image(image) {\n    this.removeTag(\"image\");\n    if (image) this.tags.push([\"image\", image]);\n  }\n  get summary() {\n    return this.tagValue(\"summary\");\n  }\n  set summary(summary) {\n    this.removeTag(\"summary\");\n    if (summary) this.tags.push([\"summary\", summary]);\n  }\n  /**\n   * Getter for the article's publication timestamp.\n   *\n   * @returns {number | undefined} - The Unix timestamp of when the article was published or undefined.\n   */\n  get published_at() {\n    const tag = this.tagValue(\"published_at\");\n    if (tag) {\n      let val = parseInt(tag);\n      if (val > 1e12) {\n        val = Math.floor(val / 1e3);\n      }\n      return val;\n    }\n    return void 0;\n  }\n  /**\n   * Setter for the article's publication timestamp.\n   *\n   * @param {number | undefined} timestamp - The Unix timestamp to set for the article's publication date.\n   */\n  set published_at(timestamp) {\n    this.removeTag(\"published_at\");\n    if (timestamp !== void 0) {\n      this.tags.push([\"published_at\", timestamp.toString()]);\n    }\n  }\n  /**\n   * Generates content tags for the article.\n   *\n   * This method first checks and sets the publication date if not available,\n   * and then generates content tags based on the base NDKEvent class.\n   *\n   * @returns {ContentTag} - The generated content tags.\n   */\n  async generateTags() {\n    super.generateTags();\n    if (!this.published_at) {\n      this.published_at = this.created_at;\n    }\n    return super.generateTags();\n  }\n  /**\n   * Getter for the article's URL.\n   *\n   * @returns {string | undefined} - The article's URL if available, otherwise undefined.\n   */\n  get url() {\n    return this.tagValue(\"url\");\n  }\n  /**\n   * Setter for the article's URL.\n   *\n   * @param {string | undefined} url - The URL to set for the article.\n   */\n  set url(url) {\n    if (url) {\n      this.tags.push([\"url\", url]);\n    } else {\n      this.removeTag(\"url\");\n    }\n  }\n};\n\n// src/events/kinds/cashu/token.ts\nfunction proofsTotalBalance(proofs) {\n  return proofs.reduce((acc, proof) => {\n    if (proof.amount < 0) {\n      throw new Error(\"proof amount is negative\");\n    }\n    return acc + proof.amount;\n  }, 0);\n}\nvar NDKCashuToken = class _NDKCashuToken extends NDKEvent {\n  _proofs = [];\n  _mint;\n  static kind = 7375 /* CashuToken */;\n  static kinds = [7375 /* CashuToken */];\n  /**\n   * Tokens that this token superseeds\n   */\n  _deletes = [];\n  original;\n  constructor(ndk, event) {\n    super(ndk, event);\n    this.kind ??= 7375 /* CashuToken */;\n  }\n  static async from(event) {\n    const token = new _NDKCashuToken(event.ndk, event);\n    token.original = event;\n    try {\n      await token.decrypt();\n    } catch {\n      token.content = token.original.content;\n    }\n    try {\n      const content = JSON.parse(token.content);\n      token.proofs = content.proofs;\n      token.mint = content.mint ?? token.tagValue(\"mint\");\n      token.deletedTokens = content.del ?? [];\n      if (!Array.isArray(token.proofs)) return;\n    } catch (e) {\n      return;\n    }\n    return token;\n  }\n  get proofs() {\n    return this._proofs;\n  }\n  set proofs(proofs) {\n    const cs = /* @__PURE__ */ new Set();\n    this._proofs = proofs.filter((proof) => {\n      if (cs.has(proof.C)) {\n        console.warn(\"Passed in proofs had duplicates, ignoring\", proof.C);\n        return false;\n      }\n      if (proof.amount < 0) {\n        console.warn(\"Invalid proof with negative amount\", proof);\n        return false;\n      }\n      cs.add(proof.C);\n      return true;\n    }).map(this.cleanProof);\n  }\n  /**\n   * Returns a minimal proof object with only essential properties\n   */\n  cleanProof(proof) {\n    return {\n      id: proof.id,\n      amount: proof.amount,\n      C: proof.C,\n      secret: proof.secret\n    };\n  }\n  async toNostrEvent(pubkey) {\n    const payload = {\n      proofs: this.proofs.map(this.cleanProof),\n      mint: this.mint,\n      del: this.deletedTokens ?? []\n    };\n    this.content = JSON.stringify(payload);\n    const user = await this.ndk.signer.user();\n    await this.encrypt(user, void 0, \"nip44\");\n    return super.toNostrEvent(pubkey);\n  }\n  set mint(mint) {\n    this._mint = mint;\n  }\n  get mint() {\n    return this._mint;\n  }\n  /**\n   * Tokens that were deleted by the creation of this token.\n   */\n  get deletedTokens() {\n    return this._deletes;\n  }\n  /**\n   * Marks tokens that were deleted by the creation of this token.\n   */\n  set deletedTokens(tokenIds) {\n    this._deletes = tokenIds;\n  }\n  get amount() {\n    return proofsTotalBalance(this.proofs);\n  }\n  async publish(relaySet, timeoutMs, requiredRelayCount) {\n    if (this.original) {\n      return this.original.publish(relaySet, timeoutMs, requiredRelayCount);\n    } else {\n      return super.publish(relaySet, timeoutMs, requiredRelayCount);\n    }\n  }\n};\n\n// src/events/kinds/highlight.ts\n\nvar NDKHighlight = class _NDKHighlight extends NDKEvent {\n  _article;\n  static kind = 9802 /* Highlight */;\n  static kinds = [9802 /* Highlight */];\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 9802 /* Highlight */;\n  }\n  static from(event) {\n    return new _NDKHighlight(event.ndk, event);\n  }\n  get url() {\n    return this.tagValue(\"r\");\n  }\n  /**\n   * Context tag.\n   */\n  set context(context) {\n    if (context === void 0) {\n      this.tags = this.tags.filter(([tag, value]) => tag !== \"context\");\n    } else {\n      this.tags = this.tags.filter(([tag, value]) => tag !== \"context\");\n      this.tags.push([\"context\", context]);\n    }\n  }\n  get context() {\n    return this.tags.find(([tag, value]) => tag === \"context\")?.[1] ?? void 0;\n  }\n  /**\n   * Will return the article URL or NDKEvent if they have already been\n   * set (it won't attempt to load remote events)\n   */\n  get article() {\n    return this._article;\n  }\n  /**\n   * Article the highlight is coming from.\n   *\n   * @param article Article URL or NDKEvent.\n   */\n  set article(article) {\n    this._article = article;\n    if (typeof article === \"string\") {\n      this.tags.push([\"r\", article]);\n    } else {\n      this.tag(article);\n    }\n  }\n  getArticleTag() {\n    return this.getMatchingTags(\"a\")[0] || this.getMatchingTags(\"e\")[0] || this.getMatchingTags(\"r\")[0];\n  }\n  async getArticle() {\n    if (this._article !== void 0) return this._article;\n    let taggedBech32;\n    const articleTag = this.getArticleTag();\n    if (!articleTag) return void 0;\n    switch (articleTag[0]) {\n      case \"a\":\n        const [kind, pubkey, identifier] = articleTag[1].split(\":\");\n        taggedBech32 = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.naddrEncode({ kind: parseInt(kind), pubkey, identifier });\n        break;\n      case \"e\":\n        taggedBech32 = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.noteEncode(articleTag[1]);\n        break;\n      case \"r\":\n        this._article = articleTag[1];\n        break;\n    }\n    if (taggedBech32) {\n      let a = await this.ndk?.fetchEvent(taggedBech32);\n      if (a) {\n        if (a.kind === 30023 /* Article */) {\n          a = NDKArticle.from(a);\n        }\n        this._article = a;\n      }\n    }\n    return this._article;\n  }\n};\n\n// src/utils/imeta.ts\nfunction mapImetaTag(tag) {\n  const data = {};\n  if (tag.length === 2) {\n    const parts = tag[1].split(\" \");\n    for (let i = 0; i < parts.length; i += 2) {\n      const key = parts[i];\n      const value = parts[i + 1];\n      if (key === \"fallback\") {\n        if (!data.fallback) data.fallback = [];\n        data.fallback.push(value);\n      } else {\n        data[key] = value;\n      }\n    }\n  }\n  for (const val of tag) {\n    const parts = val.split(\" \");\n    const key = parts[0];\n    const value = parts.slice(1).join(\" \");\n    if (key === \"fallback\") {\n      if (!data.fallback) data.fallback = [];\n      data.fallback.push(value);\n    } else {\n      data[key] = value;\n    }\n  }\n  return data;\n}\nfunction imetaTagToTag(imeta) {\n  const tag = [\"imeta\"];\n  for (const [key, value] of Object.entries(imeta)) {\n    if (Array.isArray(value)) {\n      for (const v of value) {\n        tag.push(key, v);\n      }\n    } else if (value) {\n      tag.push(key, value);\n    }\n  }\n  return tag;\n}\n\n// src/events/kinds/image.ts\nvar NDKImage = class _NDKImage extends NDKEvent {\n  static kind = 20 /* Image */;\n  static kinds = [20 /* Image */];\n  _imetas;\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 20 /* Image */;\n  }\n  /**\n   * Creates a NDKImage from an existing NDKEvent.\n   *\n   * @param event NDKEvent to create the NDKImage from.\n   * @returns NDKImage\n   */\n  static from(event) {\n    return new _NDKImage(event.ndk, event.rawEvent());\n  }\n  get isValid() {\n    return this.imetas.length > 0;\n  }\n  get imetas() {\n    if (this._imetas) return this._imetas;\n    this._imetas = this.tags.filter((tag) => tag[0] === \"imeta\").map(mapImetaTag).filter((imeta) => !!imeta.url);\n    return this._imetas;\n  }\n  set imetas(tags) {\n    this._imetas = tags;\n    this.tags = this.tags.filter((tag) => tag[0] !== \"imeta\");\n    this.tags.push(...tags.map(imetaTagToTag));\n  }\n};\n\n// src/events/kinds/lists/index.ts\nvar NDKList = class _NDKList extends NDKEvent {\n  _encryptedTags;\n  static kinds = [\n    10063 /* BlossomList */,\n    30001 /* CategorizedBookmarkList */,\n    10004 /* CommunityList */,\n    10050 /* DirectMessageReceiveRelayList */,\n    10030 /* EmojiList */,\n    10015 /* InterestList */,\n    10001 /* PinList */,\n    10002 /* RelayList */,\n    10007 /* SearchRelayList */,\n    10006 /* BlockRelayList */,\n    10003 /* BookmarkList */\n  ];\n  /**\n   * Stores the number of bytes the content was before decryption\n   * to expire the cache when the content changes.\n   */\n  encryptedTagsLength;\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 30001 /* CategorizedBookmarkList */;\n  }\n  /**\n   * Wrap a NDKEvent into a NDKList\n   */\n  static from(ndkEvent) {\n    return new _NDKList(ndkEvent.ndk, ndkEvent);\n  }\n  /**\n   * Returns the title of the list. Falls back on fetching the name tag value.\n   */\n  get title() {\n    const titleTag = this.tagValue(\"title\") || this.tagValue(\"name\");\n    if (titleTag) return titleTag;\n    if (this.kind === 3 /* Contacts */) {\n      return \"Contacts\";\n    } else if (this.kind === 1e4 /* MuteList */) {\n      return \"Mute\";\n    } else if (this.kind === 10001 /* PinList */) {\n      return \"Pinned Notes\";\n    } else if (this.kind === 10002 /* RelayList */) {\n      return \"Relay Metadata\";\n    } else if (this.kind === 10003 /* BookmarkList */) {\n      return \"Bookmarks\";\n    } else if (this.kind === 10004 /* CommunityList */) {\n      return \"Communities\";\n    } else if (this.kind === 10005 /* PublicChatList */) {\n      return \"Public Chats\";\n    } else if (this.kind === 10006 /* BlockRelayList */) {\n      return \"Blocked Relays\";\n    } else if (this.kind === 10007 /* SearchRelayList */) {\n      return \"Search Relays\";\n    } else if (this.kind === 10050 /* DirectMessageReceiveRelayList */) {\n      return \"Direct Message Receive Relays\";\n    } else if (this.kind === 10015 /* InterestList */) {\n      return \"Interests\";\n    } else if (this.kind === 10030 /* EmojiList */) {\n      return \"Emojis\";\n    } else {\n      return this.tagValue(\"d\");\n    }\n  }\n  /**\n   * Sets the title of the list.\n   */\n  set title(title) {\n    this.removeTag([\"title\", \"name\"]);\n    if (title) this.tags.push([\"title\", title]);\n  }\n  /**\n   * Returns the name of the list.\n   * @deprecated Please use \"title\" instead.\n   */\n  get name() {\n    return this.title;\n  }\n  /**\n   * Sets the name of the list.\n   * @deprecated Please use \"title\" instead. This method will use the `title` tag instead.\n   */\n  set name(name) {\n    this.title = name;\n  }\n  /**\n   * Returns the description of the list.\n   */\n  get description() {\n    return this.tagValue(\"description\");\n  }\n  /**\n   * Sets the description of the list.\n   */\n  set description(name) {\n    this.removeTag(\"description\");\n    if (name) this.tags.push([\"description\", name]);\n  }\n  /**\n   * Returns the image of the list.\n   */\n  get image() {\n    return this.tagValue(\"image\");\n  }\n  /**\n   * Sets the image of the list.\n   */\n  set image(name) {\n    this.removeTag(\"image\");\n    if (name) this.tags.push([\"image\", name]);\n  }\n  isEncryptedTagsCacheValid() {\n    return !!(this._encryptedTags && this.encryptedTagsLength === this.content.length);\n  }\n  /**\n   * Returns the decrypted content of the list.\n   */\n  async encryptedTags(useCache = true) {\n    if (useCache && this.isEncryptedTagsCacheValid()) return this._encryptedTags;\n    if (!this.ndk) throw new Error(\"NDK instance not set\");\n    if (!this.ndk.signer) throw new Error(\"NDK signer not set\");\n    const user = await this.ndk.signer.user();\n    try {\n      if (this.content.length > 0) {\n        try {\n          const decryptedContent = await this.ndk.signer.decrypt(user, this.content);\n          const a = JSON.parse(decryptedContent);\n          if (a && a[0]) {\n            this.encryptedTagsLength = this.content.length;\n            return this._encryptedTags = a;\n          }\n          this.encryptedTagsLength = this.content.length;\n          return this._encryptedTags = [];\n        } catch (e) {\n          console.log(`error decrypting ${this.content}`);\n        }\n      }\n    } catch (e) {\n    }\n    return [];\n  }\n  /**\n   * This method can be overriden to validate that a tag is valid for this list.\n   *\n   * (i.e. the NDKPersonList can validate that items are NDKUser instances)\n   */\n  validateTag(tagValue) {\n    return true;\n  }\n  getItems(type) {\n    return this.tags.filter((tag) => tag[0] === type);\n  }\n  /**\n   * Returns the unecrypted items in this list.\n   */\n  get items() {\n    return this.tags.filter((t) => {\n      return ![\n        \"d\",\n        \"L\",\n        \"l\",\n        \"title\",\n        \"name\",\n        \"description\",\n        \"published_at\",\n        \"summary\",\n        \"image\",\n        \"thumb\",\n        \"alt\",\n        \"expiration\",\n        \"subject\",\n        \"client\"\n      ].includes(t[0]);\n    });\n  }\n  /**\n   * Adds a new item to the list.\n   * @param relay Relay to add\n   * @param mark Optional mark to add to the item\n   * @param encrypted Whether to encrypt the item\n   * @param position Where to add the item in the list (top or bottom)\n   */\n  async addItem(item, mark = void 0, encrypted = false, position = \"bottom\") {\n    if (!this.ndk) throw new Error(\"NDK instance not set\");\n    if (!this.ndk.signer) throw new Error(\"NDK signer not set\");\n    let tags;\n    if (item instanceof NDKEvent) {\n      tags = [item.tagReference(mark)];\n    } else if (item instanceof NDKUser) {\n      tags = item.referenceTags();\n    } else if (item instanceof NDKRelay) {\n      tags = item.referenceTags();\n    } else if (Array.isArray(item)) {\n      tags = [item];\n    } else {\n      throw new Error(\"Invalid object type\");\n    }\n    if (mark) tags[0].push(mark);\n    if (encrypted) {\n      const user = await this.ndk.signer.user();\n      const currentList = await this.encryptedTags();\n      if (position === \"top\") currentList.unshift(...tags);\n      else currentList.push(...tags);\n      this._encryptedTags = currentList;\n      this.encryptedTagsLength = this.content.length;\n      this.content = JSON.stringify(currentList);\n      await this.encrypt(user);\n    } else {\n      if (position === \"top\") this.tags.unshift(...tags);\n      else this.tags.push(...tags);\n    }\n    this.created_at = Math.floor(Date.now() / 1e3);\n    this.emit(\"change\");\n  }\n  /**\n   * Removes an item from the list from both the encrypted and unencrypted lists.\n   * @param value value of item to remove from the list\n   * @param publish whether to publish the change\n   * @returns\n   */\n  async removeItemByValue(value, publish = true) {\n    if (!this.ndk) throw new Error(\"NDK instance not set\");\n    if (!this.ndk.signer) throw new Error(\"NDK signer not set\");\n    const index = this.tags.findIndex((tag) => tag[1] === value);\n    if (index >= 0) {\n      this.tags.splice(index, 1);\n    }\n    const user = await this.ndk.signer.user();\n    const encryptedTags = await this.encryptedTags();\n    const encryptedIndex = encryptedTags.findIndex((tag) => tag[1] === value);\n    if (encryptedIndex >= 0) {\n      encryptedTags.splice(encryptedIndex, 1);\n      this._encryptedTags = encryptedTags;\n      this.encryptedTagsLength = this.content.length;\n      this.content = JSON.stringify(encryptedTags);\n      await this.encrypt(user);\n    }\n    if (publish) {\n      return this.publishReplaceable();\n    } else {\n      this.created_at = Math.floor(Date.now() / 1e3);\n    }\n    this.emit(\"change\");\n  }\n  /**\n   * Removes an item from the list.\n   *\n   * @param index The index of the item to remove.\n   * @param encrypted Whether to remove from the encrypted list or not.\n   */\n  async removeItem(index, encrypted) {\n    if (!this.ndk) throw new Error(\"NDK instance not set\");\n    if (!this.ndk.signer) throw new Error(\"NDK signer not set\");\n    if (encrypted) {\n      const user = await this.ndk.signer.user();\n      const currentList = await this.encryptedTags();\n      currentList.splice(index, 1);\n      this._encryptedTags = currentList;\n      this.encryptedTagsLength = this.content.length;\n      this.content = JSON.stringify(currentList);\n      await this.encrypt(user);\n    } else {\n      this.tags.splice(index, 1);\n    }\n    this.created_at = Math.floor(Date.now() / 1e3);\n    this.emit(\"change\");\n    return this;\n  }\n  has(item) {\n    return this.items.some((tag) => tag[1] === item);\n  }\n  /**\n   * Creates a filter that will result in fetching\n   * the items of this list\n   * @example\n   * const list = new NDKList(...);\n   * const filters = list.filterForItems();\n   * const events = await ndk.fetchEvents(filters);\n   */\n  filterForItems() {\n    const ids = /* @__PURE__ */ new Set();\n    const nip33Queries = /* @__PURE__ */ new Map();\n    const filters = [];\n    for (const tag of this.items) {\n      if (tag[0] === \"e\" && tag[1]) {\n        ids.add(tag[1]);\n      } else if (tag[0] === \"a\" && tag[1]) {\n        const [kind, pubkey, dTag] = tag[1].split(\":\");\n        if (!kind || !pubkey) continue;\n        const key = `${kind}:${pubkey}`;\n        const item = nip33Queries.get(key) || [];\n        item.push(dTag || \"\");\n        nip33Queries.set(key, item);\n      }\n    }\n    if (ids.size > 0) {\n      filters.push({ ids: Array.from(ids) });\n    }\n    if (nip33Queries.size > 0) {\n      for (const [key, values] of nip33Queries.entries()) {\n        const [kind, pubkey] = key.split(\":\");\n        filters.push({\n          kinds: [parseInt(kind)],\n          authors: [pubkey],\n          \"#d\": values\n        });\n      }\n    }\n    return filters;\n  }\n};\nvar lists_default = NDKList;\n\n// src/events/kinds/nutzap/index.ts\n\nvar NDKNutzap = class _NDKNutzap extends NDKEvent {\n  debug;\n  _proofs = [];\n  static kind = 9321 /* Nutzap */;\n  static kinds = [_NDKNutzap.kind];\n  constructor(ndk, event) {\n    super(ndk, event);\n    this.kind ??= 9321 /* Nutzap */;\n    this.debug = ndk?.debug.extend(\"nutzap\") ?? debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:nutzap\");\n    if (!this.alt) this.alt = \"This is a nutzap\";\n  }\n  static from(event) {\n    const e = new this(event.ndk, event);\n    try {\n      const proofTags = e.getMatchingTags(\"proof\");\n      if (proofTags.length) {\n        e._proofs = proofTags.map((tag) => JSON.parse(tag[1]));\n      } else {\n        e._proofs = JSON.parse(e.content);\n      }\n    } catch {\n      return;\n    }\n    if (!e._proofs || !e._proofs.length) return;\n    return e;\n  }\n  set comment(comment) {\n    this.content = comment ?? \"\";\n  }\n  get comment() {\n    const c = this.tagValue(\"comment\");\n    if (c) return c;\n    return this.content;\n  }\n  set proofs(proofs) {\n    this._proofs = proofs;\n    this.tags = this.tags.filter((tag) => tag[0] !== \"proof\");\n    for (const proof of proofs) {\n      this.tags.push([\"proof\", JSON.stringify(proof)]);\n    }\n  }\n  get proofs() {\n    return this._proofs;\n  }\n  /**\n   * Gets the p2pk pubkey that is embedded in the first proof\n   */\n  get p2pk() {\n    const firstProof = this.proofs[0];\n    try {\n      const secret = JSON.parse(firstProof.secret);\n      let payload = {};\n      if (typeof secret === \"string\") {\n        payload = JSON.parse(secret);\n        this.debug(\"stringified payload\", firstProof.secret);\n      } else if (typeof secret === \"object\") {\n        payload = secret;\n      }\n      const isP2PKLocked = payload[0] === \"P2PK\" && payload[1]?.data;\n      if (isP2PKLocked) {\n        const paddedp2pk = payload[1].data;\n        const p2pk = paddedp2pk.slice(2);\n        if (p2pk) return p2pk;\n      }\n    } catch (e) {\n      this.debug(\"error parsing p2pk pubkey\", e, this.proofs[0]);\n    }\n  }\n  /**\n   * Get the mint where this nutzap proofs exist\n   */\n  get mint() {\n    return this.tagValue(\"u\");\n  }\n  set mint(value) {\n    this.removeTag(\"u\");\n    this.tag([\"u\", value]);\n  }\n  get unit() {\n    return this.tagValue(\"unit\") ?? \"sat\";\n  }\n  set unit(value) {\n    this.removeTag(\"unit\");\n    if (value) this.tag([\"unit\", value]);\n  }\n  get amount() {\n    const amount = this.proofs.reduce((total, proof) => total + proof.amount, 0);\n    if (this.unit === \"msat\") return amount * 1e3;\n    return amount;\n  }\n  sender = this.author;\n  /**\n   * Set the target of the nutzap\n   * @param target The target of the nutzap (a user or an event)\n   */\n  set target(target) {\n    this.tags = this.tags.filter((t) => t[0] !== \"p\");\n    if (target instanceof NDKEvent) {\n      this.tags.push(target.tagReference());\n    }\n  }\n  set recipientPubkey(pubkey) {\n    this.removeTag(\"p\");\n    this.tag([\"p\", pubkey]);\n  }\n  get recipientPubkey() {\n    return this.tagValue(\"p\");\n  }\n  get recipient() {\n    const pubkey = this.recipientPubkey;\n    if (this.ndk) return this.ndk.getUser({ pubkey });\n    return new NDKUser({ pubkey });\n  }\n  async toNostrEvent() {\n    if (this.unit === \"msat\") {\n      this.unit = \"sat\";\n    }\n    this.removeTag(\"amount\");\n    this.tags.push([\"amount\", this.amount.toString()]);\n    const event = await super.toNostrEvent();\n    event.content = this.comment;\n    return event;\n  }\n  /**\n   * Validates that the nutzap conforms to NIP-61\n   */\n  get isValid() {\n    let eTagCount = 0;\n    let pTagCount = 0;\n    let mintTagCount = 0;\n    for (const tag of this.tags) {\n      if (tag[0] === \"e\") eTagCount++;\n      if (tag[0] === \"p\") pTagCount++;\n      if (tag[0] === \"u\") mintTagCount++;\n    }\n    return (\n      // exactly one recipient and mint\n      pTagCount === 1 && mintTagCount === 1 && // must have at most one e tag\n      eTagCount <= 1 && // must have at least one proof\n      this.proofs.length > 0\n    );\n  }\n};\nfunction proofP2pk(proof) {\n  try {\n    const secret = JSON.parse(proof.secret);\n    let payload = {};\n    if (typeof secret === \"string\") {\n      payload = JSON.parse(secret);\n    } else if (typeof secret === \"object\") {\n      payload = secret;\n    }\n    const isP2PKLocked = payload[0] === \"P2PK\" && payload[1]?.data;\n    if (isP2PKLocked) {\n      return payload[1].data;\n    }\n  } catch (e) {\n    console.error(\"error parsing p2pk pubkey\", e, proof);\n  }\n}\nfunction proofP2pkNostr(proof) {\n  const p2pk = proofP2pk(proof);\n  if (!p2pk) return;\n  if (p2pk.startsWith(\"02\") && p2pk.length === 66) return p2pk.slice(2);\n  return p2pk;\n}\n\n// src/events/kinds/nutzap/mint-list.ts\nvar NDKCashuMintList = class _NDKCashuMintList extends NDKEvent {\n  static kind = 10019 /* CashuMintList */;\n  static kinds = [10019 /* CashuMintList */];\n  _p2pk;\n  constructor(ndk, event) {\n    super(ndk, event);\n    this.kind ??= 10019 /* CashuMintList */;\n  }\n  static from(event) {\n    return new _NDKCashuMintList(event.ndk, event);\n  }\n  set relays(urls) {\n    this.tags = this.tags.filter((t) => t[0] !== \"relay\");\n    for (const url of urls) {\n      this.tags.push([\"relay\", url]);\n    }\n  }\n  get relays() {\n    const r = [];\n    for (const tag of this.tags) {\n      if (tag[0] === \"relay\") {\n        r.push(tag[1]);\n      }\n    }\n    return r;\n  }\n  set mints(urls) {\n    this.tags = this.tags.filter((t) => t[0] !== \"mint\");\n    for (const url of urls) {\n      this.tags.push([\"mint\", url]);\n    }\n  }\n  get mints() {\n    const r = [];\n    for (const tag of this.tags) {\n      if (tag[0] === \"mint\") {\n        r.push(tag[1]);\n      }\n    }\n    return Array.from(new Set(r));\n  }\n  get p2pk() {\n    if (this._p2pk) {\n      return this._p2pk;\n    }\n    this._p2pk = this.tagValue(\"pubkey\") ?? this.pubkey;\n    return this._p2pk;\n  }\n  set p2pk(pubkey) {\n    this._p2pk = pubkey;\n    this.removeTag(\"pubkey\");\n    if (pubkey) {\n      this.tags.push([\"pubkey\", pubkey]);\n    }\n  }\n  get relaySet() {\n    return NDKRelaySet.fromRelayUrls(this.relays, this.ndk);\n  }\n};\n\n// src/events/kinds/simple-group/member-list.ts\nvar NDKSimpleGroupMemberList = class _NDKSimpleGroupMemberList extends NDKEvent {\n  relaySet;\n  memberSet = /* @__PURE__ */ new Set();\n  static kind = 39002 /* GroupMembers */;\n  static kinds = [39002 /* GroupMembers */];\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 39002 /* GroupMembers */;\n    this.memberSet = new Set(this.members);\n  }\n  static from(event) {\n    return new _NDKSimpleGroupMemberList(event.ndk, event);\n  }\n  get members() {\n    return this.getMatchingTags(\"p\").map((tag) => tag[1]);\n  }\n  hasMember(member) {\n    return this.memberSet.has(member);\n  }\n  async publish(relaySet, timeoutMs, requiredRelayCount) {\n    relaySet ??= this.relaySet;\n    return super.publishReplaceable(relaySet, timeoutMs, requiredRelayCount);\n  }\n};\n\n// src/events/kinds/simple-group/metadata.ts\nvar NDKSimpleGroupMetadata = class _NDKSimpleGroupMetadata extends NDKEvent {\n  static kind = 39e3 /* GroupMetadata */;\n  static kinds = [39e3 /* GroupMetadata */];\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 39e3 /* GroupMetadata */;\n  }\n  static from(event) {\n    return new _NDKSimpleGroupMetadata(event.ndk, event);\n  }\n  get name() {\n    return this.tagValue(\"name\");\n  }\n  get picture() {\n    return this.tagValue(\"picture\");\n  }\n  get about() {\n    return this.tagValue(\"about\");\n  }\n  get scope() {\n    if (this.getMatchingTags(\"public\").length > 0) return \"public\";\n    if (this.getMatchingTags(\"public\").length > 0) return \"private\";\n  }\n  set scope(scope) {\n    this.removeTag(\"public\");\n    this.removeTag(\"private\");\n    if (scope === \"public\") {\n      this.tags.push([\"public\", \"\"]);\n    } else if (scope === \"private\") {\n      this.tags.push([\"private\", \"\"]);\n    }\n  }\n  get access() {\n    if (this.getMatchingTags(\"open\").length > 0) return \"open\";\n    if (this.getMatchingTags(\"closed\").length > 0) return \"closed\";\n  }\n  set access(access) {\n    this.removeTag(\"open\");\n    this.removeTag(\"closed\");\n    if (access === \"open\") {\n      this.tags.push([\"open\", \"\"]);\n    } else if (access === \"closed\") {\n      this.tags.push([\"closed\", \"\"]);\n    }\n  }\n};\n\n// src/events/kinds/subscriptions/amount.ts\nvar possibleIntervalFrequencies = [\n  \"daily\",\n  \"weekly\",\n  \"monthly\",\n  \"quarterly\",\n  \"yearly\"\n];\nfunction calculateTermDurationInSeconds(term) {\n  switch (term) {\n    case \"daily\":\n      return 24 * 60 * 60;\n    case \"weekly\":\n      return 7 * 24 * 60 * 60;\n    case \"monthly\":\n      return 30 * 24 * 60 * 60;\n    case \"quarterly\":\n      return 3 * 30 * 24 * 60 * 60;\n    case \"yearly\":\n      return 365 * 24 * 60 * 60;\n  }\n}\nfunction newAmount(amount, currency, term) {\n  return [\"amount\", amount.toString(), currency, term];\n}\nfunction parseTagToSubscriptionAmount(tag) {\n  const amount = parseInt(tag[1]);\n  if (isNaN(amount) || amount === void 0 || amount === null || amount <= 0) return void 0;\n  const currency = tag[2];\n  if (currency === void 0 || currency === \"\") return void 0;\n  const term = tag[3];\n  if (term === void 0) return void 0;\n  if (!possibleIntervalFrequencies.includes(term)) return void 0;\n  return {\n    amount,\n    currency,\n    term\n  };\n}\n\n// src/events/kinds/subscriptions/tier.ts\nvar NDKSubscriptionTier = class _NDKSubscriptionTier extends NDKArticle {\n  static kind = 37001 /* SubscriptionTier */;\n  static kinds = [37001 /* SubscriptionTier */];\n  constructor(ndk, rawEvent) {\n    const k = rawEvent?.kind ?? 37001 /* SubscriptionTier */;\n    super(ndk, rawEvent);\n    this.kind = k;\n  }\n  /**\n   * Creates a new NDKSubscriptionTier from an event\n   * @param event\n   * @returns NDKSubscriptionTier\n   */\n  static from(event) {\n    return new _NDKSubscriptionTier(event.ndk, event);\n  }\n  /**\n   * Returns perks for this tier\n   */\n  get perks() {\n    return this.getMatchingTags(\"perk\").map((tag) => tag[1]).filter((perk) => perk !== void 0);\n  }\n  /**\n   * Adds a perk to this tier\n   */\n  addPerk(perk) {\n    this.tags.push([\"perk\", perk]);\n  }\n  /**\n   * Returns the amount for this tier\n   */\n  get amounts() {\n    return this.getMatchingTags(\"amount\").map((tag) => parseTagToSubscriptionAmount(tag)).filter((a) => a !== void 0);\n  }\n  /**\n   * Adds an amount to this tier\n   * @param amount Amount in the smallest unit of the currency (e.g. cents, msats)\n   * @param currency Currency code. Use msat for millisatoshis\n   * @param term One of daily, weekly, monthly, quarterly, yearly\n   */\n  addAmount(amount, currency, term) {\n    this.tags.push(newAmount(amount, currency, term));\n  }\n  /**\n   * Sets a relay where content related to this tier can be found\n   * @param relayUrl URL of the relay\n   */\n  set relayUrl(relayUrl) {\n    this.tags.push([\"r\", relayUrl]);\n  }\n  /**\n   * Returns the relay URLs for this tier\n   */\n  get relayUrls() {\n    return this.getMatchingTags(\"r\").map((tag) => tag[1]).filter((relay) => relay !== void 0);\n  }\n  /**\n   * Gets the verifier pubkey for this tier. This is the pubkey that will generate\n   * subscription payment receipts\n   */\n  get verifierPubkey() {\n    return this.tagValue(\"p\");\n  }\n  /**\n   * Sets the verifier pubkey for this tier.\n   */\n  set verifierPubkey(pubkey) {\n    this.removeTag(\"p\");\n    if (pubkey) this.tags.push([\"p\", pubkey]);\n  }\n  /**\n   * Checks if this tier is valid\n   */\n  get isValid() {\n    return this.title !== void 0 && // Must have a title\n    this.amounts.length > 0;\n  }\n};\n\n// src/events/kinds/video.ts\nvar NDKVideo = class _NDKVideo extends NDKEvent {\n  static kind = 34235 /* HorizontalVideo */;\n  static kinds = [34235 /* HorizontalVideo */, 34236 /* VerticalVideo */];\n  _imetas;\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 34235 /* HorizontalVideo */;\n  }\n  /**\n   * Creates a NDKArticle from an existing NDKEvent.\n   *\n   * @param event NDKEvent to create the NDKArticle from.\n   * @returns NDKArticle\n   */\n  static from(event) {\n    return new _NDKVideo(event.ndk, event.rawEvent());\n  }\n  /**\n   * Getter for the article title.\n   *\n   * @returns {string | undefined} - The article title if available, otherwise undefined.\n   */\n  get title() {\n    return this.tagValue(\"title\");\n  }\n  /**\n   * Setter for the article title.\n   *\n   * @param {string | undefined} title - The title to set for the article.\n   */\n  set title(title) {\n    this.removeTag(\"title\");\n    if (title) this.tags.push([\"title\", title]);\n  }\n  /**\n   * Getter for the article thumbnail.\n   *\n   * @returns {string | undefined} - The article thumbnail if available, otherwise undefined.\n   */\n  get thumbnail() {\n    let thumbnail;\n    if (this.imetas && this.imetas.length > 0) {\n      thumbnail = this.imetas[0].image?.[0];\n    }\n    return thumbnail ?? this.tagValue(\"thumb\");\n  }\n  get imetas() {\n    if (this._imetas) return this._imetas;\n    this._imetas = this.tags.filter((tag) => tag[0] === \"imeta\").map(mapImetaTag);\n    return this._imetas;\n  }\n  set imetas(tags) {\n    this._imetas = tags;\n    this.tags = this.tags.filter((tag) => tag[0] !== \"imeta\");\n    this.tags.push(...tags.map(imetaTagToTag));\n  }\n  get url() {\n    if (this.imetas && this.imetas.length > 0) {\n      return this.imetas[0].url;\n    }\n    return this.tagValue(\"url\");\n  }\n  /**\n   * Getter for the article's publication timestamp.\n   *\n   * @returns {number | undefined} - The Unix timestamp of when the article was published or undefined.\n   */\n  get published_at() {\n    const tag = this.tagValue(\"published_at\");\n    if (tag) {\n      return parseInt(tag);\n    }\n    return void 0;\n  }\n  /**\n   * Setter for the article's publication timestamp.\n   *\n   * @param {number | undefined} timestamp - The Unix timestamp to set for the article's publication date.\n   */\n  set published_at(timestamp) {\n    this.removeTag(\"published_at\");\n    if (timestamp !== void 0) {\n      this.tags.push([\"published_at\", timestamp.toString()]);\n    }\n  }\n  /**\n   * Generates content tags for the article.\n   *\n   * This method first checks and sets the publication date if not available,\n   * and then generates content tags based on the base NDKEvent class.\n   *\n   * @returns {ContentTag} - The generated content tags.\n   */\n  async generateTags() {\n    super.generateTags();\n    if (!this.published_at) {\n      this.published_at = this.created_at;\n    }\n    return super.generateTags();\n  }\n  get duration() {\n    const tag = this.tagValue(\"duration\");\n    if (tag) {\n      return parseInt(tag);\n    }\n    return void 0;\n  }\n  /**\n   * Setter for the video's duration\n   *\n   * @param {number | undefined} duration - The duration to set for the video (in seconds)\n   */\n  set duration(dur) {\n    this.removeTag(\"duration\");\n    if (dur !== void 0) {\n      this.tags.push([\"duration\", Math.floor(dur).toString()]);\n    }\n  }\n};\n\n// src/events/kinds/wiki.ts\nvar NDKWiki = class extends NDKArticle {\n  static kind = 30818 /* Wiki */;\n  static kinds = [30818 /* Wiki */];\n};\n\n// src/events/wrap.ts\nfunction wrapEvent(event) {\n  const eventWrappingMap = /* @__PURE__ */ new Map();\n  [\n    NDKImage,\n    NDKVideo,\n    NDKCashuMintList,\n    NDKArticle,\n    NDKHighlight,\n    NDKWiki,\n    NDKNutzap,\n    NDKSimpleGroupMemberList,\n    NDKSimpleGroupMetadata,\n    NDKSubscriptionTier,\n    NDKCashuToken,\n    NDKList\n  ].forEach((klass2) => {\n    klass2.kinds.forEach((kind) => {\n      eventWrappingMap.set(kind, klass2);\n    });\n  });\n  const klass = eventWrappingMap.get(event.kind);\n  if (klass) return klass.from(event);\n  return event;\n}\n\n// src/subscription/index.ts\nvar NDKSubscriptionCacheUsage = /* @__PURE__ */ ((NDKSubscriptionCacheUsage2) => {\n  NDKSubscriptionCacheUsage2[\"ONLY_CACHE\"] = \"ONLY_CACHE\";\n  NDKSubscriptionCacheUsage2[\"CACHE_FIRST\"] = \"CACHE_FIRST\";\n  NDKSubscriptionCacheUsage2[\"PARALLEL\"] = \"PARALLEL\";\n  NDKSubscriptionCacheUsage2[\"ONLY_RELAY\"] = \"ONLY_RELAY\";\n  return NDKSubscriptionCacheUsage2;\n})(NDKSubscriptionCacheUsage || {});\nvar defaultOpts = {\n  closeOnEose: false,\n  cacheUsage: \"CACHE_FIRST\" /* CACHE_FIRST */,\n  dontSaveToCache: false,\n  groupable: true,\n  groupableDelay: 100,\n  groupableDelayType: \"at-most\",\n  cacheUnconstrainFilter: [\"limit\", \"since\", \"until\"]\n};\nvar NDKSubscription = class extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  subId;\n  filters;\n  opts;\n  pool;\n  skipVerification = false;\n  skipValidation = false;\n  /**\n   * Tracks the filters as they are executed on each relay\n   */\n  relayFilters;\n  relaySet;\n  ndk;\n  debug;\n  /**\n   * Events that have been seen by the subscription, with the time they were first seen.\n   */\n  eventFirstSeen = /* @__PURE__ */ new Map();\n  /**\n   * Relays that have sent an EOSE.\n   */\n  eosesSeen = /* @__PURE__ */ new Set();\n  /**\n   * The time the last event was received by the subscription.\n   * This is used to calculate when EOSE should be emitted.\n   */\n  lastEventReceivedAt;\n  internalId;\n  /**\n   * Whether the subscription should close when all relays have reached the end of the event stream.\n   */\n  closeOnEose;\n  /**\n   * Pool monitor callback\n   */\n  poolMonitor;\n  skipOptimisticPublishEvent = false;\n  /**\n   * Filters to remove when querying the cache.\n   */\n  cacheUnconstrainFilter;\n  constructor(ndk, filters, opts, relaySet, subId) {\n    super();\n    this.ndk = ndk;\n    this.pool = opts?.pool || ndk.pool;\n    this.opts = { ...defaultOpts, ...opts || {} };\n    this.filters = filters instanceof Array ? filters : [filters];\n    this.subId = subId || this.opts.subId;\n    this.internalId = Math.random().toString(36).substring(7);\n    this.relaySet = relaySet;\n    this.debug = ndk.debug.extend(`subscription[${this.opts.subId ?? this.internalId}]`);\n    this.skipVerification = this.opts.skipVerification || false;\n    this.skipValidation = this.opts.skipValidation || false;\n    this.closeOnEose = this.opts.closeOnEose || false;\n    this.skipOptimisticPublishEvent = this.opts.skipOptimisticPublishEvent || false;\n    this.cacheUnconstrainFilter = this.opts.cacheUnconstrainFilter;\n  }\n  /**\n   * Returns the relays that have not yet sent an EOSE.\n   */\n  relaysMissingEose() {\n    if (!this.relayFilters) return [];\n    const relaysMissingEose = Array.from(this.relayFilters.keys()).filter(\n      (url) => !this.eosesSeen.has(this.pool.getRelay(url, false, false))\n    );\n    return relaysMissingEose;\n  }\n  /**\n   * Provides access to the first filter of the subscription for\n   * backwards compatibility.\n   */\n  get filter() {\n    return this.filters[0];\n  }\n  get groupableDelay() {\n    if (!this.isGroupable()) return void 0;\n    return this.opts?.groupableDelay;\n  }\n  get groupableDelayType() {\n    return this.opts?.groupableDelayType || \"at-most\";\n  }\n  isGroupable() {\n    return this.opts?.groupable || false;\n  }\n  shouldQueryCache() {\n    if (this.opts?.cacheUsage === \"ONLY_RELAY\" /* ONLY_RELAY */) return false;\n    const hasNonEphemeralKind = this.filters.some((f) => f.kinds?.some((k) => kindIsEphemeral(k)));\n    if (hasNonEphemeralKind) return true;\n    return true;\n  }\n  shouldQueryRelays() {\n    return this.opts?.cacheUsage !== \"ONLY_CACHE\" /* ONLY_CACHE */;\n  }\n  shouldWaitForCache() {\n    return (\n      // Must want to close on EOSE; subscriptions\n      // that want to receive further updates must\n      // always hit the relay\n      this.opts.closeOnEose && // Cache adapter must claim to be fast\n      !!this.ndk.cacheAdapter?.locking && // If explicitly told to run in parallel, then\n      // we should not wait for the cache\n      this.opts.cacheUsage !== \"PARALLEL\" /* PARALLEL */\n    );\n  }\n  /**\n   * Start the subscription. This is the main method that should be called\n   * after creating a subscription.\n   * \n   * @param emitCachedEvents - Whether to emit events coming from a synchronous cache\n   * \n   * When using a synchronous cache, the events will be returned immediately\n   * by this function. If you will use those returned events, you should\n   * set emitCachedEvents to false to prevent seeing them as duplicate events.\n   */\n  start(emitCachedEvents = true) {\n    let cacheResult;\n    const updateStateFromCacheResults = (events) => {\n      if (emitCachedEvents) {\n        for (const event of events) {\n          this.eventReceived(event, void 0, true, false);\n        }\n      } else {\n        cacheResult = [];\n        events.forEach((event) => {\n          event.ndk = this.ndk;\n          const e = this.opts.wrap ? wrapEvent(event) : event;\n          if (!e) return;\n          if (e instanceof Promise) {\n            e.then((wrappedEvent) => {\n              this.emitEvent(false, wrappedEvent, void 0, true, false);\n            });\n            return;\n          }\n          this.eventFirstSeen.set(e.id, Date.now());\n          cacheResult.push(e);\n        });\n      }\n    };\n    const loadFromRelays = () => {\n      if (this.shouldQueryRelays()) {\n        this.startWithRelays();\n        this.startPoolMonitor();\n      } else {\n        this.emit(\"eose\", this);\n      }\n    };\n    if (this.shouldQueryCache()) {\n      cacheResult = this.startWithCache();\n      if (cacheResult instanceof Promise) {\n        if (this.shouldWaitForCache()) {\n          cacheResult.then((events) => {\n            updateStateFromCacheResults(events);\n            if (queryFullyFilled(this)) {\n              this.emit(\"eose\", this);\n              return;\n            } else {\n              loadFromRelays();\n            }\n          });\n          return null;\n        } else {\n          cacheResult.then((events) => {\n            updateStateFromCacheResults(events);\n          });\n        }\n        return null;\n      } else {\n        updateStateFromCacheResults(cacheResult);\n        if (queryFullyFilled(this)) {\n          this.emit(\"eose\", this);\n        } else {\n          loadFromRelays();\n        }\n        return cacheResult;\n      }\n    } else {\n      loadFromRelays();\n      return null;\n    }\n  }\n  /**\n   * We want to monitor for new relays that are coming online, in case\n   * they should be part of this subscription.\n   */\n  startPoolMonitor() {\n    const d4 = this.debug.extend(\"pool-monitor\");\n    this.poolMonitor = (relay) => {\n      if (this.relayFilters?.has(relay.url)) return;\n      const calc = calculateRelaySetsFromFilters(this.ndk, this.filters, this.pool);\n      if (calc.get(relay.url)) {\n        this.relayFilters?.set(relay.url, this.filters);\n        relay.subscribe(this, this.filters);\n      }\n    };\n    this.pool.on(\"relay:connect\", this.poolMonitor);\n  }\n  onStopped;\n  stop() {\n    this.emit(\"close\", this);\n    this.poolMonitor && this.pool.off(\"relay:connect\", this.poolMonitor);\n    this.removeAllListeners();\n    this.onStopped?.();\n  }\n  /**\n   * @returns Whether the subscription has an authors filter.\n   */\n  hasAuthorsFilter() {\n    return this.filters.some((f) => f.authors?.length);\n  }\n  startWithCache() {\n    if (this.ndk.cacheAdapter?.query) {\n      return this.ndk.cacheAdapter.query(this);\n    } else {\n      return [];\n    }\n  }\n  /**\n   * Send REQ to relays\n   */\n  startWithRelays() {\n    if (!this.relaySet || this.relaySet.relays.size === 0) {\n      this.relayFilters = calculateRelaySetsFromFilters(this.ndk, this.filters, this.pool);\n    } else {\n      this.relayFilters = /* @__PURE__ */ new Map();\n      for (const relay of this.relaySet.relays) {\n        this.relayFilters.set(relay.url, this.filters);\n      }\n    }\n    if (!this.relayFilters || this.relayFilters.size === 0) return;\n    for (const [relayUrl, filters] of this.relayFilters) {\n      const relay = this.pool.getRelay(relayUrl, true, true, filters);\n      relay.subscribe(this, filters);\n    }\n  }\n  // EVENT handling\n  /**\n   * Called when an event is received from a relay or the cache\n   * @param event\n   * @param relay\n   * @param fromCache Whether the event was received from the cache\n   * @param optimisticPublish Whether this event is coming from an optimistic publish\n   */\n  eventReceived(event, relay, fromCache = false, optimisticPublish = false) {\n    const eventId = event.id;\n    const eventAlreadySeen = this.eventFirstSeen.has(eventId);\n    let ndkEvent;\n    if (event instanceof NDKEvent) ndkEvent = event;\n    if (!eventAlreadySeen) {\n      ndkEvent ??= new NDKEvent(this.ndk, event);\n      ndkEvent.ndk = this.ndk;\n      ndkEvent.relay = relay;\n      if (!fromCache && !optimisticPublish) {\n        if (!this.skipValidation) {\n          if (!ndkEvent.isValid) {\n            this.debug(`Event failed validation %s from relay %s`, eventId, relay?.url);\n            return;\n          }\n        }\n        if (relay) {\n          if (relay?.shouldValidateEvent() !== false) {\n            if (!this.skipVerification) {\n              if (!ndkEvent.verifySignature(true) && !this.ndk.asyncSigVerification) {\n                this.debug(`Event failed signature validation`, event);\n                return;\n              } else if (relay) {\n                relay.addValidatedEvent();\n              }\n            }\n          } else {\n            relay.addNonValidatedEvent();\n          }\n        }\n        if (this.ndk.cacheAdapter && !this.opts.dontSaveToCache) {\n          this.ndk.cacheAdapter.setEvent(ndkEvent, this.filters, relay);\n        }\n      }\n      if (!optimisticPublish || this.skipOptimisticPublishEvent !== true) {\n        this.emitEvent(this.opts?.wrap, ndkEvent, relay, fromCache, optimisticPublish);\n        this.eventFirstSeen.set(eventId, Date.now());\n      }\n    } else {\n      const timeSinceFirstSeen = Date.now() - (this.eventFirstSeen.get(eventId) || 0);\n      this.emit(\"event:dup\", event, relay, timeSinceFirstSeen, this, fromCache, optimisticPublish);\n      if (relay) {\n        const signature = verifiedSignatures.get(eventId);\n        if (signature && typeof signature === \"string\") {\n          if (event.sig === signature) {\n            relay.addValidatedEvent();\n          }\n        }\n      }\n    }\n    this.lastEventReceivedAt = Date.now();\n  }\n  /**\n   * Optionally wraps, sync or async, and emits the event (if one comes back from the wrapper)\n   */\n  emitEvent(wrap = false, evt, relay, fromCache, optimisticPublish) {\n    const wrapped = wrap ? wrapEvent(evt) : evt;\n    if (wrapped instanceof Promise) {\n      wrapped.then((e) => this.emitEvent(false, e, relay, fromCache, optimisticPublish));\n    } else if (wrapped) {\n      this.emit(\"event\", wrapped, relay, this, fromCache, optimisticPublish);\n    }\n  }\n  closedReceived(relay, reason) {\n    this.emit(\"closed\", relay, reason);\n  }\n  // EOSE handling\n  eoseTimeout;\n  eosed = false;\n  eoseReceived(relay) {\n    this.debug(\"EOSE received from %s\", relay.url);\n    this.eosesSeen.add(relay);\n    let lastEventSeen = this.lastEventReceivedAt ? Date.now() - this.lastEventReceivedAt : void 0;\n    const hasSeenAllEoses = this.eosesSeen.size === this.relayFilters?.size;\n    const queryFilled = queryFullyFilled(this);\n    const performEose = (reason) => {\n      this.debug(\"Performing EOSE: %s %d\", reason, this.eosed);\n      if (this.eosed) return;\n      if (this.eoseTimeout) clearTimeout(this.eoseTimeout);\n      this.emit(\"eose\", this);\n      this.eosed = true;\n    };\n    if (queryFilled || hasSeenAllEoses) {\n      performEose(\"query filled or seen all\");\n    } else if (this.relayFilters) {\n      let timeToWaitForNextEose = 1e3;\n      const connectedRelays = new Set(this.pool.connectedRelays().map((r) => r.url));\n      const connectedRelaysWithFilters = Array.from(this.relayFilters.keys()).filter(\n        (url) => connectedRelays.has(url)\n      );\n      if (connectedRelaysWithFilters.length === 0) {\n        return;\n      }\n      const percentageOfRelaysThatHaveSentEose = this.eosesSeen.size / connectedRelaysWithFilters.length;\n      this.debug(\"Percentage of relays that have sent EOSE\", { subId: this.subId, percentageOfRelaysThatHaveSentEose, seen: this.eosesSeen.size, total: connectedRelaysWithFilters.length });\n      if (this.eosesSeen.size >= 2 && percentageOfRelaysThatHaveSentEose >= 0.5) {\n        timeToWaitForNextEose = timeToWaitForNextEose * (1 - percentageOfRelaysThatHaveSentEose);\n        if (timeToWaitForNextEose === 0) {\n          performEose(\"time to wait was 0\");\n          return;\n        }\n        if (this.eoseTimeout) clearTimeout(this.eoseTimeout);\n        const sendEoseTimeout = () => {\n          lastEventSeen = this.lastEventReceivedAt ? Date.now() - this.lastEventReceivedAt : void 0;\n          if (lastEventSeen !== void 0 && lastEventSeen < 20) {\n            this.eoseTimeout = setTimeout(sendEoseTimeout, timeToWaitForNextEose);\n          } else {\n            performEose(\"send eose timeout: \" + timeToWaitForNextEose);\n          }\n        };\n        this.eoseTimeout = setTimeout(sendEoseTimeout, timeToWaitForNextEose);\n      }\n    }\n  }\n};\nvar kindIsEphemeral = (kind) => kind >= 2e4 && kind < 3e4;\n\n// src/user/follows.ts\nasync function follows(opts, outbox, kind = 3 /* Contacts */) {\n  if (!this.ndk) throw new Error(\"NDK not set\");\n  const contactListEvent = await this.ndk.fetchEvent(\n    { kinds: [kind], authors: [this.pubkey] },\n    opts || { groupable: false }\n  );\n  if (contactListEvent) {\n    const pubkeys = /* @__PURE__ */ new Set();\n    contactListEvent.tags.forEach((tag) => {\n      if (tag[0] === \"p\") pubkeys.add(tag[1]);\n    });\n    if (outbox) {\n      this.ndk?.outboxTracker?.trackUsers(Array.from(pubkeys));\n    }\n    return [...pubkeys].reduce((acc, pubkey) => {\n      const user = new NDKUser({ pubkey });\n      user.ndk = this.ndk;\n      acc.add(user);\n      return acc;\n    }, /* @__PURE__ */ new Set());\n  }\n  return /* @__PURE__ */ new Set();\n}\n\n// src/user/profile.ts\nfunction profileFromEvent(event) {\n  const profile = {};\n  let payload;\n  try {\n    payload = JSON.parse(event.content);\n  } catch (error) {\n    throw new Error(`Failed to parse profile event: ${error}`);\n  }\n  profile.created_at = event.created_at;\n  profile.profileEvent = JSON.stringify(event.rawEvent());\n  Object.keys(payload).forEach((key) => {\n    switch (key) {\n      case \"name\":\n        profile.name = payload.name;\n        break;\n      case \"display_name\":\n        profile.displayName = payload.display_name;\n        break;\n      case \"image\":\n      case \"picture\":\n        profile.picture = payload.picture || payload.image;\n        profile.image = profile.picture;\n        break;\n      case \"banner\":\n        profile.banner = payload.banner;\n        break;\n      case \"bio\":\n        profile.bio = payload.bio;\n        break;\n      case \"nip05\":\n        profile.nip05 = payload.nip05;\n        break;\n      case \"lud06\":\n        profile.lud06 = payload.lud06;\n        break;\n      case \"lud16\":\n        profile.lud16 = payload.lud16;\n        break;\n      case \"about\":\n        profile.about = payload.about;\n        break;\n      case \"website\":\n        profile.website = payload.website;\n        break;\n      default:\n        profile[key] = payload[key];\n        break;\n    }\n  });\n  return profile;\n}\nfunction serializeProfile(profile) {\n  const payload = {};\n  for (const [key, val] of Object.entries(profile)) {\n    switch (key) {\n      case \"username\":\n      case \"name\":\n        payload.name = val;\n        break;\n      case \"displayName\":\n        payload.display_name = val;\n        break;\n      case \"image\":\n      case \"picture\":\n        payload.picture = val;\n        break;\n      case \"bio\":\n      case \"about\":\n        payload.about = val;\n        break;\n      default:\n        payload[key] = val;\n        break;\n    }\n  }\n  return JSON.stringify(payload);\n}\n\n// src/user/nip05.ts\nvar NIP05_REGEX = /^(?:([\\w.+-]+)@)?([\\w.-]+)$/;\nasync function getNip05For(ndk, fullname, _fetch = fetch, fetchOpts = {}) {\n  return await ndk.queuesNip05.add({\n    id: fullname,\n    func: async () => {\n      if (ndk.cacheAdapter && ndk.cacheAdapter.loadNip05) {\n        const profile = await ndk.cacheAdapter.loadNip05(fullname);\n        if (profile !== \"missing\") {\n          if (profile) {\n            const user = new NDKUser({\n              pubkey: profile.pubkey,\n              relayUrls: profile.relays,\n              nip46Urls: profile.nip46\n            });\n            user.ndk = ndk;\n            return user;\n          } else if (fetchOpts.cache !== \"no-cache\") {\n            return null;\n          }\n        }\n      }\n      const match = fullname.match(NIP05_REGEX);\n      if (!match) return null;\n      const [_, name = \"_\", domain] = match;\n      try {\n        const res = await _fetch(\n          `https://${domain}/.well-known/nostr.json?name=${name}`,\n          fetchOpts\n        );\n        const { names, relays, nip46 } = parseNIP05Result(await res.json());\n        const pubkey = names[name.toLowerCase()];\n        let profile = null;\n        if (pubkey) {\n          profile = { pubkey, relays: relays?.[pubkey], nip46: nip46?.[pubkey] };\n        }\n        if (ndk?.cacheAdapter && ndk.cacheAdapter.saveNip05) {\n          ndk.cacheAdapter.saveNip05(fullname, profile);\n        }\n        return profile;\n      } catch (_e) {\n        if (ndk?.cacheAdapter && ndk.cacheAdapter.saveNip05) {\n          ndk?.cacheAdapter.saveNip05(fullname, null);\n        }\n        console.error(\"Failed to fetch NIP05 for\", fullname, _e);\n        return null;\n      }\n    }\n  });\n}\nfunction parseNIP05Result(json) {\n  const result = {\n    names: {}\n  };\n  for (const [name, pubkey] of Object.entries(json.names)) {\n    if (typeof name === \"string\" && typeof pubkey === \"string\") {\n      result.names[name.toLowerCase()] = pubkey;\n    }\n  }\n  if (json.relays) {\n    result.relays = {};\n    for (const [pubkey, relays] of Object.entries(json.relays)) {\n      if (typeof pubkey === \"string\" && Array.isArray(relays)) {\n        result.relays[pubkey] = relays.filter(\n          (relay) => typeof relay === \"string\"\n        );\n      }\n    }\n  }\n  if (json.nip46) {\n    result.nip46 = {};\n    for (const [pubkey, nip46] of Object.entries(json.nip46)) {\n      if (typeof pubkey === \"string\" && Array.isArray(nip46)) {\n        result.nip46[pubkey] = nip46.filter((relay) => typeof relay === \"string\");\n      }\n    }\n  }\n  return result;\n}\n\n// src/user/index.ts\nvar NDKUser = class _NDKUser {\n  ndk;\n  profile;\n  profileEvent;\n  _npub;\n  _pubkey;\n  relayUrls = [];\n  nip46Urls = [];\n  constructor(opts) {\n    if (opts.npub) this._npub = opts.npub;\n    if (opts.hexpubkey) this._pubkey = opts.hexpubkey;\n    if (opts.pubkey) this._pubkey = opts.pubkey;\n    if (opts.relayUrls) this.relayUrls = opts.relayUrls;\n    if (opts.nip46Urls) this.nip46Urls = opts.nip46Urls;\n  }\n  get npub() {\n    if (!this._npub) {\n      if (!this._pubkey) throw new Error(\"pubkey not set\");\n      this._npub = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.npubEncode(this.pubkey);\n    }\n    return this._npub;\n  }\n  get nprofile() {\n    const relays = this.profileEvent?.onRelays?.map((r) => r.url);\n    return nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.nprofileEncode({\n      pubkey: this.pubkey,\n      relays\n    });\n  }\n  set npub(npub) {\n    this._npub = npub;\n  }\n  /**\n   * Get the user's pubkey\n   * @returns {string} The user's pubkey\n   */\n  get pubkey() {\n    if (!this._pubkey) {\n      if (!this._npub) throw new Error(\"npub not set\");\n      this._pubkey = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.decode(this.npub).data;\n    }\n    return this._pubkey;\n  }\n  /**\n   * Set the user's pubkey\n   * @param pubkey {string} The user's pubkey\n   */\n  set pubkey(pubkey) {\n    this._pubkey = pubkey;\n  }\n  /**\n   * Equivalent to NDKEvent.filters().\n   * @returns {NDKFilter}\n   */\n  filter() {\n    return { \"#p\": [this.pubkey] };\n  }\n  /**\n   * Gets NIP-57 and NIP-61 information that this user has signaled\n   *\n   * @param getAll {boolean} Whether to get all zap info or just the first one\n   */\n  async getZapInfo(timeoutMs) {\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    const promiseWithTimeout = async (promise) => {\n      if (!timeoutMs) return promise;\n      try {\n        return await Promise.race([\n          promise,\n          new Promise((_, reject) => setTimeout(() => reject(), timeoutMs))\n        ]);\n      } catch {\n        return void 0;\n      }\n    };\n    const [userProfile, mintListEvent] = await Promise.all([\n      promiseWithTimeout(this.fetchProfile()),\n      promiseWithTimeout(this.ndk.fetchEvent({ kinds: [10019 /* CashuMintList */], authors: [this.pubkey] }))\n    ]);\n    const res = /* @__PURE__ */ new Map();\n    if (mintListEvent) {\n      const mintList = NDKCashuMintList.from(mintListEvent);\n      if (mintList.mints.length > 0) {\n        res.set(\"nip61\", {\n          mints: mintList.mints,\n          relays: mintList.relays,\n          p2pk: mintList.p2pk\n        });\n      }\n    }\n    if (userProfile) {\n      const { lud06, lud16 } = userProfile;\n      res.set(\"nip57\", { lud06, lud16 });\n    }\n    return res;\n  }\n  /**\n   * Instantiate an NDKUser from a NIP-05 string\n   * @param nip05Id {string} The user's NIP-05\n   * @param ndk {NDK} An NDK instance\n   * @param skipCache {boolean} Whether to skip the cache or not\n   * @returns {NDKUser | undefined} An NDKUser if one is found for the given NIP-05, undefined otherwise.\n   */\n  static async fromNip05(nip05Id, ndk, skipCache = false) {\n    if (!ndk) throw new Error(\"No NDK instance found\");\n    const opts = {};\n    if (skipCache) opts.cache = \"no-cache\";\n    const profile = await getNip05For(ndk, nip05Id, ndk?.httpFetch, opts);\n    if (profile) {\n      const user = new _NDKUser({\n        pubkey: profile.pubkey,\n        relayUrls: profile.relays,\n        nip46Urls: profile.nip46\n      });\n      user.ndk = ndk;\n      return user;\n    }\n  }\n  /**\n   * Fetch a user's profile\n   * @param opts {NDKSubscriptionOptions} A set of NDKSubscriptionOptions\n   * @param storeProfileEvent {boolean} Whether to store the profile event or not\n   * @returns User Profile\n   */\n  async fetchProfile(opts, storeProfileEvent = false) {\n    if (!this.ndk) throw new Error(\"NDK not set\");\n    if (!this.profile) this.profile = {};\n    let setMetadataEvent = null;\n    if (this.ndk.cacheAdapter && this.ndk.cacheAdapter.fetchProfile && opts?.cacheUsage !== \"ONLY_RELAY\" /* ONLY_RELAY */) {\n      const profile = await this.ndk.cacheAdapter.fetchProfile(this.pubkey);\n      if (profile) {\n        this.profile = profile;\n        return profile;\n      }\n    }\n    if (!opts && // if no options have been set\n    this.ndk.cacheAdapter && // and we have a cache\n    this.ndk.cacheAdapter.locking) {\n      setMetadataEvent = await this.ndk.fetchEvent(\n        {\n          kinds: [0],\n          authors: [this.pubkey]\n        },\n        {\n          cacheUsage: \"ONLY_CACHE\" /* ONLY_CACHE */,\n          closeOnEose: true,\n          groupable: false\n        }\n      );\n      opts = {\n        cacheUsage: \"ONLY_RELAY\" /* ONLY_RELAY */,\n        closeOnEose: true,\n        groupable: true,\n        groupableDelay: 250\n      };\n    }\n    if (!setMetadataEvent) {\n      setMetadataEvent = await this.ndk.fetchEvent(\n        {\n          kinds: [0],\n          authors: [this.pubkey]\n        },\n        opts\n      );\n    }\n    if (!setMetadataEvent) return null;\n    this.profile = profileFromEvent(setMetadataEvent);\n    if (storeProfileEvent) {\n      this.profile.profileEvent = JSON.stringify(setMetadataEvent);\n    }\n    if (this.profile && this.ndk.cacheAdapter && this.ndk.cacheAdapter.saveProfile) {\n      this.ndk.cacheAdapter.saveProfile(this.pubkey, this.profile);\n    }\n    return this.profile;\n  }\n  /**\n   * Returns a set of users that this user follows.\n   * \n   * @deprecated Use followSet instead\n   */\n  follows = follows.bind(this);\n  /**\n   * Returns a set of pubkeys that this user follows.\n   * \n   * @param opts - NDKSubscriptionOptions\n   * @param outbox - boolean\n   * @param kind - number\n   */\n  async followSet(opts, outbox, kind = 3 /* Contacts */) {\n    const follows2 = await this.follows(opts, outbox, kind);\n    return new Set(Array.from(follows2).map((f) => f.pubkey));\n  }\n  /** @deprecated Use referenceTags instead. */\n  /**\n   * Get the tag that can be used to reference this user in an event\n   * @returns {NDKTag} an NDKTag\n   */\n  tagReference() {\n    return [\"p\", this.pubkey];\n  }\n  /**\n   * Get the tags that can be used to reference this user in an event\n   * @returns {NDKTag[]} an array of NDKTag\n   */\n  referenceTags(marker) {\n    const tag = [[\"p\", this.pubkey]];\n    if (!marker) return tag;\n    tag[0].push(\"\", marker);\n    return tag;\n  }\n  /**\n   * Publishes the current profile.\n   */\n  async publish() {\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    if (!this.profile) throw new Error(\"No profile available\");\n    this.ndk.assertSigner();\n    const event = new NDKEvent(this.ndk, {\n      kind: 0,\n      content: serializeProfile(this.profile)\n    });\n    await event.publish();\n  }\n  /**\n   * Add a follow to this user's contact list\n   *\n   * @param newFollow {NDKUser} The user to follow\n   * @param currentFollowList {Set<NDKUser>} The current follow list\n   * @param kind {NDKKind} The kind to use for this contact list (defaults to `3`)\n   * @returns {Promise<boolean>} True if the follow was added, false if the follow already exists\n   */\n  async follow(newFollow, currentFollowList, kind = 3 /* Contacts */) {\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    this.ndk.assertSigner();\n    if (!currentFollowList) {\n      currentFollowList = await this.follows(void 0, void 0, kind);\n    }\n    if (currentFollowList.has(newFollow)) {\n      return false;\n    }\n    currentFollowList.add(newFollow);\n    const event = new NDKEvent(this.ndk, { kind });\n    for (const follow of currentFollowList) {\n      event.tag(follow);\n    }\n    await event.publish();\n    return true;\n  }\n  /**\n   * Remove a follow from this user's contact list\n   *\n   * @param user {NDKUser} The user to unfollow\n   * @param currentFollowList {Set<NDKUser>} The current follow list\n   * @param kind {NDKKind} The kind to use for this contact list (defaults to `3`)\n   * @returns The relays were the follow list was published or false if the user wasn't found\n   */\n  async unfollow(user, currentFollowList, kind = 3 /* Contacts */) {\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    this.ndk.assertSigner();\n    if (!currentFollowList) {\n      currentFollowList = await this.follows(void 0, void 0, kind);\n    }\n    const newUserFollowList = /* @__PURE__ */ new Set();\n    let foundUser = false;\n    for (const follow of currentFollowList) {\n      if (follow.pubkey !== user.pubkey) {\n        newUserFollowList.add(follow);\n      } else {\n        foundUser = true;\n      }\n    }\n    if (!foundUser) return false;\n    const event = new NDKEvent(this.ndk, { kind });\n    for (const follow of newUserFollowList) {\n      event.tag(follow);\n    }\n    return await event.publish();\n  }\n  /**\n   * Validate a user's NIP-05 identifier (usually fetched from their kind:0 profile data)\n   *\n   * @param nip05Id The NIP-05 string to validate\n   * @returns {Promise<boolean | null>} True if the NIP-05 is found and matches this user's pubkey,\n   * False if the NIP-05 is found but doesn't match this user's pubkey,\n   * null if the NIP-05 isn't found on the domain or we're unable to verify (because of network issues, etc.)\n   */\n  async validateNip05(nip05Id) {\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    const profilePointer = await getNip05For(this.ndk, nip05Id);\n    if (profilePointer === null) return null;\n    return profilePointer.pubkey === this.pubkey;\n  }\n};\n\n// src/user/pin.ts\nasync function pinEvent(user, event, pinEvent2, publish) {\n  const kind = 10001 /* PinList */;\n  if (!user.ndk) throw new Error(\"No NDK instance found\");\n  user.ndk.assertSigner();\n  if (!pinEvent2) {\n    const events = await user.ndk.fetchEvents(\n      { kinds: [kind], authors: [user.pubkey] },\n      { cacheUsage: \"ONLY_RELAY\" /* ONLY_RELAY */ }\n    );\n    if (events.size > 0) {\n      pinEvent2 = lists_default.from(Array.from(events)[0]);\n    } else {\n      pinEvent2 = new NDKEvent(user.ndk, {\n        kind\n      });\n    }\n  }\n  pinEvent2.tag(event);\n  if (publish) {\n    await pinEvent2.publish();\n  }\n  return pinEvent2;\n}\n\n// src/events/kinds/classified.ts\nvar NDKClassified = class _NDKClassified extends NDKEvent {\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 30402 /* Classified */;\n  }\n  /**\n   * Creates a NDKClassified from an existing NDKEvent.\n   *\n   * @param event NDKEvent to create the NDKClassified from.\n   * @returns NDKClassified\n   */\n  static from(event) {\n    return new _NDKClassified(event.ndk, event);\n  }\n  /**\n   * Getter for the classified title.\n   *\n   * @returns {string | undefined} - The classified title if available, otherwise undefined.\n   */\n  get title() {\n    return this.tagValue(\"title\");\n  }\n  /**\n   * Setter for the classified title.\n   *\n   * @param {string | undefined} title - The title to set for the classified.\n   */\n  set title(title) {\n    this.removeTag(\"title\");\n    if (title) this.tags.push([\"title\", title]);\n  }\n  /**\n   * Getter for the classified summary.\n   *\n   * @returns {string | undefined} - The classified summary if available, otherwise undefined.\n   */\n  get summary() {\n    return this.tagValue(\"summary\");\n  }\n  /**\n   * Setter for the classified summary.\n   *\n   * @param {string | undefined} summary - The summary to set for the classified.\n   */\n  set summary(summary) {\n    this.removeTag(\"summary\");\n    if (summary) this.tags.push([\"summary\", summary]);\n  }\n  /**\n   * Getter for the classified's publication timestamp.\n   *\n   * @returns {number | undefined} - The Unix timestamp of when the classified was published or undefined.\n   */\n  get published_at() {\n    const tag = this.tagValue(\"published_at\");\n    if (tag) {\n      return parseInt(tag);\n    }\n    return void 0;\n  }\n  /**\n   * Setter for the classified's publication timestamp.\n   *\n   * @param {number | undefined} timestamp - The Unix timestamp to set for the classified's publication date.\n   */\n  set published_at(timestamp) {\n    this.removeTag(\"published_at\");\n    if (timestamp !== void 0) {\n      this.tags.push([\"published_at\", timestamp.toString()]);\n    }\n  }\n  /**\n   * Getter for the classified location.\n   *\n   * @returns {string | undefined} - The classified location if available, otherwise undefined.\n   */\n  get location() {\n    return this.tagValue(\"location\");\n  }\n  /**\n   * Setter for the classified location.\n   *\n   * @param {string | undefined} location - The location to set for the classified.\n   */\n  set location(location) {\n    this.removeTag(\"location\");\n    if (location) this.tags.push([\"location\", location]);\n  }\n  /**\n   * Getter for the classified price.\n   *\n   * @returns {NDKClassifiedPriceTag | undefined} - The classified price if available, otherwise undefined.\n   */\n  get price() {\n    const priceTag = this.tags.find((tag) => tag[0] === \"price\");\n    if (priceTag) {\n      return {\n        amount: parseFloat(priceTag[1]),\n        currency: priceTag[2],\n        frequency: priceTag[3]\n      };\n    } else {\n      return void 0;\n    }\n  }\n  /**\n   * Setter for the classified price.\n   *\n   * @param price - The price to set for the classified.\n   */\n  set price(priceTag) {\n    if (typeof priceTag === \"string\") {\n      priceTag = {\n        amount: parseFloat(priceTag)\n      };\n    }\n    if (priceTag?.amount) {\n      const tag = [\"price\", priceTag.amount.toString()];\n      if (priceTag.currency) tag.push(priceTag.currency);\n      if (priceTag.frequency) tag.push(priceTag.frequency);\n      this.tags.push(tag);\n    } else {\n      this.removeTag(\"price\");\n    }\n  }\n  /**\n   * Generates content tags for the classified.\n   *\n   * This method first checks and sets the publication date if not available,\n   * and then generates content tags based on the base NDKEvent class.\n   *\n   * @returns {ContentTag} - The generated content tags.\n   */\n  async generateTags() {\n    super.generateTags();\n    if (!this.published_at) {\n      this.published_at = this.created_at;\n    }\n    return super.generateTags();\n  }\n};\n\n// src/events/kinds/drafts.ts\nvar NDKDraft = class _NDKDraft extends NDKEvent {\n  _event;\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 31234 /* Draft */;\n  }\n  static from(event) {\n    return new _NDKDraft(event.ndk, event);\n  }\n  /**\n   * Sets an identifier (i.e. d-tag)\n   */\n  set identifier(id) {\n    this.removeTag(\"d\");\n    this.tags.push([\"d\", id]);\n  }\n  get identifier() {\n    return this.dTag;\n  }\n  /**\n   * Event that is to be saved.\n   */\n  set event(e) {\n    if (e instanceof NDKEvent) this._event = e.rawEvent();\n    else this._event = e;\n    this.prepareEvent();\n  }\n  /**\n   * Gets the event.\n   * @param param0\n   * @returns NDKEvent of the draft event or null if the draft event has been deleted (emptied).\n   */\n  async getEvent(signer) {\n    if (this._event) return new NDKEvent(this.ndk, this._event);\n    signer ??= this.ndk?.signer;\n    if (!signer) throw new Error(\"No signer available\");\n    const user = await signer.user();\n    if (this.content && this.content.length > 0) {\n      try {\n        await this.decrypt(user, signer);\n        const payload = JSON.parse(this.content);\n        this._event = payload;\n        return new NDKEvent(this.ndk, payload);\n      } catch (e) {\n        console.error(e);\n        return void 0;\n      }\n    } else {\n      return null;\n    }\n  }\n  prepareEvent() {\n    if (!this._event) throw new Error(\"No event has been provided\");\n    this.removeTag(\"k\");\n    if (this._event.kind) this.tags.push([\"k\", this._event.kind.toString()]);\n    this.content = JSON.stringify(this._event);\n  }\n  /**\n   * Generates draft event.\n   *\n   * @param signer: Optional signer to encrypt with\n   * @param publish: Whether to publish, optionally specifying relaySet to publish to\n   */\n  async save({\n    signer,\n    publish,\n    relaySet\n  }) {\n    signer ??= this.ndk?.signer;\n    if (!signer) throw new Error(\"No signer available\");\n    const user = await signer.user();\n    await this.encrypt(user, signer);\n    if (publish === false) return;\n    return this.publish(relaySet);\n  }\n};\n\n// src/events/kinds/dvm/feedback.ts\nvar NDKDvmJobFeedbackStatus = /* @__PURE__ */ ((NDKDvmJobFeedbackStatus2) => {\n  NDKDvmJobFeedbackStatus2[\"Processing\"] = \"processing\";\n  NDKDvmJobFeedbackStatus2[\"Success\"] = \"success\";\n  NDKDvmJobFeedbackStatus2[\"Scheduled\"] = \"scheduled\";\n  NDKDvmJobFeedbackStatus2[\"PayReq\"] = \"payment_required\";\n  return NDKDvmJobFeedbackStatus2;\n})(NDKDvmJobFeedbackStatus || {});\nvar NDKDVMJobFeedback = class _NDKDVMJobFeedback extends NDKEvent {\n  constructor(ndk, event) {\n    super(ndk, event);\n    this.kind ??= 7e3 /* DVMJobFeedback */;\n  }\n  static async from(event) {\n    const e = new _NDKDVMJobFeedback(event.ndk, event.rawEvent());\n    if (e.encrypted) await e.dvmDecrypt();\n    return e;\n  }\n  get status() {\n    return this.tagValue(\"status\");\n  }\n  set status(status) {\n    this.removeTag(\"status\");\n    if (status !== void 0) {\n      this.tags.push([\"status\", status]);\n    }\n  }\n  get encrypted() {\n    return !!this.getMatchingTags(\"encrypted\")[0];\n  }\n  async dvmDecrypt() {\n    await this.decrypt();\n    const decryptedContent = JSON.parse(this.content);\n    this.tags.push(...decryptedContent);\n  }\n};\n\n// src/events/kinds/dvm/request.ts\nvar NDKDVMRequest = class _NDKDVMRequest extends NDKEvent {\n  constructor(ndk, event) {\n    super(ndk, event);\n  }\n  static from(event) {\n    return new _NDKDVMRequest(event.ndk, event.rawEvent());\n  }\n  set bid(msatAmount) {\n    if (msatAmount === void 0) {\n      this.removeTag(\"bid\");\n    } else {\n      this.tags.push([\"bid\", msatAmount.toString()]);\n    }\n  }\n  get bid() {\n    const v = this.tagValue(\"bid\");\n    if (v === void 0) return void 0;\n    return parseInt(v);\n  }\n  /**\n   * Adds a new input to the job\n   * @param args The arguments to the input\n   */\n  addInput(...args) {\n    this.tags.push([\"i\", ...args]);\n  }\n  /**\n   * Adds a new parameter to the job\n   */\n  addParam(...args) {\n    this.tags.push([\"param\", ...args]);\n  }\n  set output(output) {\n    if (output === void 0) {\n      this.removeTag(\"output\");\n    } else {\n      if (typeof output === \"string\") output = [output];\n      this.tags.push([\"output\", ...output]);\n    }\n  }\n  get output() {\n    const outputTag = this.getMatchingTags(\"output\")[0];\n    return outputTag ? outputTag.slice(1) : void 0;\n  }\n  get params() {\n    const paramTags = this.getMatchingTags(\"param\");\n    return paramTags.map((t) => t.slice(1));\n  }\n  getParam(name) {\n    const paramTag = this.getMatchingTags(\"param\").find((t) => t[1] === name);\n    return paramTag ? paramTag[2] : void 0;\n  }\n  createFeedback(status) {\n    const feedback = new NDKDVMJobFeedback(this.ndk);\n    feedback.tag(this, \"job\");\n    feedback.status = status;\n    return feedback;\n  }\n  /**\n   * Enables job encryption for this event\n   * @param dvm DVM that will receive the event\n   * @param signer Signer to use for encryption\n   */\n  async encryption(dvm, signer) {\n    const dvmTags = [\"i\", \"param\", \"output\", \"relays\", \"bid\"];\n    const tags = this.tags.filter((t) => dvmTags.includes(t[0]));\n    this.tags = this.tags.filter((t) => !dvmTags.includes(t[0]));\n    this.content = JSON.stringify(tags);\n    this.tag(dvm);\n    this.tags.push([\"encrypted\"]);\n    await this.encrypt(dvm, signer);\n  }\n  /**\n   * Sets the DVM that will receive the event\n   */\n  set dvm(dvm) {\n    this.removeTag(\"p\");\n    if (dvm) this.tag(dvm);\n  }\n};\n\n// src/events/kinds/dvm/NDKTranscriptionDVM.ts\nvar NDKTranscriptionDVM = class _NDKTranscriptionDVM extends NDKDVMRequest {\n  constructor(ndk, event) {\n    super(ndk, event);\n    this.kind = 5e3 /* DVMReqTextExtraction */;\n  }\n  static from(event) {\n    return new _NDKTranscriptionDVM(event.ndk, event.rawEvent());\n  }\n  /**\n   * Returns the original source of the transcription\n   */\n  get url() {\n    const inputTags = this.getMatchingTags(\"i\");\n    if (inputTags.length !== 1) {\n      return void 0;\n    }\n    return inputTags[0][1];\n  }\n  /**\n   * Getter for the title tag\n   */\n  get title() {\n    return this.tagValue(\"title\");\n  }\n  /**\n   * Setter for the title tag\n   */\n  set title(value) {\n    this.removeTag(\"title\");\n    if (value) {\n      this.tags.push([\"title\", value]);\n    }\n  }\n  /**\n   * Getter for the image tag\n   */\n  get image() {\n    return this.tagValue(\"image\");\n  }\n  /**\n   * Setter for the image tag\n   */\n  set image(value) {\n    this.removeTag(\"image\");\n    if (value) {\n      this.tags.push([\"image\", value]);\n    }\n  }\n};\n\n// src/events/kinds/dvm/result.ts\nvar NDKDVMJobResult = class _NDKDVMJobResult extends NDKEvent {\n  constructor(ndk, event) {\n    super(ndk, event);\n  }\n  static from(event) {\n    return new _NDKDVMJobResult(event.ndk, event.rawEvent());\n  }\n  setAmount(msat, invoice) {\n    this.removeTag(\"amount\");\n    const tag = [\"amount\", msat.toString()];\n    if (invoice) tag.push(invoice);\n    this.tags.push(tag);\n  }\n  set result(result) {\n    if (result === void 0) {\n      this.content = \"\";\n    } else {\n      this.content = result;\n    }\n  }\n  get result() {\n    if (this.content === \"\") {\n      return void 0;\n    }\n    return this.content;\n  }\n  set status(status) {\n    this.removeTag(\"status\");\n    if (status !== void 0) {\n      this.tags.push([\"status\", status]);\n    }\n  }\n  get status() {\n    return this.tagValue(\"status\");\n  }\n  get jobRequestId() {\n    for (const eTag of this.getMatchingTags(\"e\")) {\n      if (eTag[2] === \"job\") return eTag[1];\n    }\n    if (this.jobRequest) return this.jobRequest.id;\n    return this.tagValue(\"e\");\n  }\n  set jobRequest(event) {\n    this.removeTag(\"request\");\n    if (event) {\n      this.kind = event.kind + 1e3;\n      this.tags.push([\"request\", JSON.stringify(event.rawEvent())]);\n      this.tag(event);\n    }\n  }\n  get jobRequest() {\n    const tag = this.tagValue(\"request\");\n    if (tag === void 0) {\n      return void 0;\n    }\n    return new NDKEvent(this.ndk, JSON.parse(tag));\n  }\n};\n\n// src/events/kinds/cashu/tx.ts\nvar MARKERS = {\n  REDEEMED: \"redeemed\",\n  CREATED: \"created\",\n  DESTROYED: \"destroyed\",\n  RESERVED: \"reserved\"\n};\nvar NDKCashuWalletTx = class _NDKCashuWalletTx extends NDKEvent {\n  static MARKERS = MARKERS;\n  static kind = 7376 /* CashuWalletTx */;\n  static kinds = [7376 /* CashuWalletTx */];\n  constructor(ndk, event) {\n    super(ndk, event);\n    this.kind ??= 7376 /* CashuWalletTx */;\n  }\n  static async from(event) {\n    const walletChange = new _NDKCashuWalletTx(event.ndk, event);\n    const prevContent = walletChange.content;\n    try {\n      await walletChange.decrypt();\n    } catch (e) {\n      walletChange.content ??= prevContent;\n    }\n    try {\n      const contentTags = JSON.parse(walletChange.content);\n      walletChange.tags = [...contentTags, ...walletChange.tags];\n    } catch (e) {\n      return;\n    }\n    return walletChange;\n  }\n  set direction(direction) {\n    this.removeTag(\"direction\");\n    if (direction) this.tags.push([\"direction\", direction]);\n  }\n  get direction() {\n    return this.tagValue(\"direction\");\n  }\n  set amount(amount) {\n    this.removeTag(\"amount\");\n    this.tags.push([\"amount\", amount.toString()]);\n  }\n  get amount() {\n    return this.tagValue(\"amount\");\n  }\n  set fee(fee) {\n    this.removeTag(\"fee\");\n    this.tags.push([\"fee\", fee.toString()]);\n  }\n  get fee() {\n    return this.tagValue(\"fee\");\n  }\n  set unit(unit) {\n    this.removeTag(\"unit\");\n    if (unit) this.tags.push([\"unit\", unit.toString()]);\n  }\n  get unit() {\n    return this.tagValue(\"unit\");\n  }\n  set description(description) {\n    this.removeTag(\"description\");\n    if (description) this.tags.push([\"description\", description.toString()]);\n  }\n  get description() {\n    return this.tagValue(\"description\");\n  }\n  set mint(mint) {\n    this.removeTag(\"mint\");\n    if (mint) this.tags.push([\"mint\", mint.toString()]);\n  }\n  get mint() {\n    return this.tagValue(\"mint\");\n  }\n  /**\n   * Tags tokens that were created in this history event\n   */\n  set destroyedTokens(events) {\n    for (const event of events) {\n      this.tags.push(event.tagReference(MARKERS.DESTROYED));\n    }\n  }\n  set destroyedTokenIds(ids) {\n    for (const id of ids) {\n      this.tags.push([\"e\", id, \"\", MARKERS.DESTROYED]);\n    }\n  }\n  /**\n   * Tags tokens that were created in this history event\n   */\n  set createdTokens(events) {\n    for (const event of events) {\n      this.tags.push(event.tagReference(MARKERS.CREATED));\n    }\n  }\n  set reservedTokens(events) {\n    for (const event of events) {\n      this.tags.push(event.tagReference(MARKERS.RESERVED));\n    }\n  }\n  addRedeemedNutzap(event) {\n    this.tag(event, MARKERS.REDEEMED);\n  }\n  async toNostrEvent(pubkey) {\n    const encryptedTags = [];\n    const unencryptedTags = [];\n    for (const tag of this.tags) {\n      if (!this.shouldEncryptTag(tag)) {\n        unencryptedTags.push(tag);\n      } else {\n        encryptedTags.push(tag);\n      }\n    }\n    this.tags = unencryptedTags.filter((t) => t[0] !== \"client\");\n    this.content = JSON.stringify(encryptedTags);\n    const user = await this.ndk.signer.user();\n    await this.encrypt(user, void 0, \"nip44\");\n    return super.toNostrEvent(pubkey);\n  }\n  /**\n   * Whether this entry includes a redemption of a Nutzap\n   */\n  get hasNutzapRedemption() {\n    return this.getMatchingTags(\"e\", MARKERS.REDEEMED).length > 0;\n  }\n  shouldEncryptTag(tag) {\n    const unencryptedTagNames = [\"client\"];\n    if (unencryptedTagNames.includes(tag[0])) {\n      return false;\n    }\n    if (tag[0] === \"e\" && tag[3] === MARKERS.REDEEMED) {\n      return false;\n    }\n    if (tag[0] === \"p\") return false;\n    return true;\n  }\n};\n\n// src/events/kinds/NDKRelayList.ts\nvar READ_MARKER = \"read\";\nvar WRITE_MARKER = \"write\";\nvar NDKRelayList = class _NDKRelayList extends NDKEvent {\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 10002 /* RelayList */;\n  }\n  static from(ndkEvent) {\n    return new _NDKRelayList(ndkEvent.ndk, ndkEvent.rawEvent());\n  }\n  get readRelayUrls() {\n    return this.tags.filter((tag) => tag[0] === \"r\" || tag[0] === \"relay\").filter((tag) => !tag[2] || tag[2] && tag[2] === READ_MARKER).map((tag) => tryNormalizeRelayUrl(tag[1])).filter((url) => !!url);\n  }\n  set readRelayUrls(relays) {\n    for (const relay of relays) {\n      this.tags.push([\"r\", relay, READ_MARKER]);\n    }\n  }\n  get writeRelayUrls() {\n    return this.tags.filter((tag) => tag[0] === \"r\" || tag[0] === \"relay\").filter((tag) => !tag[2] || tag[2] && tag[2] === WRITE_MARKER).map((tag) => tryNormalizeRelayUrl(tag[1])).filter((url) => !!url);\n  }\n  set writeRelayUrls(relays) {\n    for (const relay of relays) {\n      this.tags.push([\"r\", relay, WRITE_MARKER]);\n    }\n  }\n  get bothRelayUrls() {\n    return this.tags.filter((tag) => tag[0] === \"r\" || tag[0] === \"relay\").filter((tag) => !tag[2]).map((tag) => tag[1]);\n  }\n  set bothRelayUrls(relays) {\n    for (const relay of relays) {\n      this.tags.push([\"r\", relay]);\n    }\n  }\n  get relays() {\n    return this.tags.filter((tag) => tag[0] === \"r\" || tag[0] === \"relay\").map((tag) => tag[1]);\n  }\n  /**\n   * Provides a relaySet for the relays in this list.\n   */\n  get relaySet() {\n    if (!this.ndk) throw new Error(\"NDKRelayList has no NDK instance\");\n    return new NDKRelaySet(\n      new Set(this.relays.map((u) => this.ndk.pool.getRelay(u))),\n      this.ndk\n    );\n  }\n};\nfunction relayListFromKind3(ndk, contactList) {\n  try {\n    const content = JSON.parse(contactList.content);\n    const relayList = new NDKRelayList(ndk);\n    const readRelays = /* @__PURE__ */ new Set();\n    const writeRelays = /* @__PURE__ */ new Set();\n    for (let [key, config] of Object.entries(content)) {\n      try {\n        key = normalizeRelayUrl(key);\n      } catch {\n        continue;\n      }\n      if (!config) {\n        readRelays.add(key);\n        writeRelays.add(key);\n      } else {\n        const relayConfig = config;\n        if (relayConfig.write) writeRelays.add(key);\n        if (relayConfig.read) readRelays.add(key);\n      }\n    }\n    relayList.readRelayUrls = Array.from(readRelays);\n    relayList.writeRelayUrls = Array.from(writeRelays);\n    return relayList;\n  } catch {\n  }\n  return void 0;\n}\n\n// src/events/kinds/nip89/NDKAppHandler.ts\nvar NDKAppHandlerEvent = class _NDKAppHandlerEvent extends NDKEvent {\n  profile;\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 31990 /* AppHandler */;\n  }\n  static from(ndkEvent) {\n    return new _NDKAppHandlerEvent(ndkEvent.ndk, ndkEvent.rawEvent());\n  }\n  /**\n   * Fetches app handler information\n   * If no app information is available on the kind:31990,\n   * we fetch the event's author's profile and return that instead.\n   */\n  async fetchProfile() {\n    if (this.profile === void 0 && this.content.length > 0) {\n      try {\n        const profile = JSON.parse(this.content);\n        if (profile && profile.name) {\n          return profile;\n        } else {\n          this.profile = null;\n        }\n      } catch (e) {\n        this.profile = null;\n      }\n    }\n    return new Promise((resolve, reject) => {\n      const author = this.author;\n      author.fetchProfile().then(() => {\n        resolve(author.profile);\n      }).catch(reject);\n    });\n  }\n};\n\n// src/events/kinds/repost.ts\nvar NDKRepost = class _NDKRepost extends NDKEvent {\n  _repostedEvents;\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n  }\n  static from(event) {\n    return new _NDKRepost(event.ndk, event.rawEvent());\n  }\n  /**\n   * Returns all reposted events by the current event.\n   *\n   * @param klass Optional class to convert the events to.\n   * @returns\n   */\n  async repostedEvents(klass, opts) {\n    const items = [];\n    if (!this.ndk) throw new Error(\"NDK instance not set\");\n    if (this._repostedEvents !== void 0) return this._repostedEvents;\n    for (const eventId of this.repostedEventIds()) {\n      const filter = filterForId(eventId);\n      const event = await this.ndk.fetchEvent(filter, opts);\n      if (event) {\n        items.push(klass ? klass.from(event) : event);\n      }\n    }\n    return items;\n  }\n  /**\n   * Returns the reposted event IDs.\n   */\n  repostedEventIds() {\n    return this.tags.filter((t) => t[0] === \"e\" || t[0] === \"a\").map((t) => t[1]);\n  }\n};\nfunction filterForId(id) {\n  if (id.match(/:/)) {\n    const [kind, pubkey, identifier] = id.split(\":\");\n    return {\n      kinds: [parseInt(kind)],\n      authors: [pubkey],\n      \"#d\": [identifier]\n    };\n  } else {\n    return { ids: [id] };\n  }\n}\n\n// src/events/kinds/subscriptions/receipt.ts\n\nvar NDKSubscriptionReceipt = class _NDKSubscriptionReceipt extends NDKEvent {\n  debug;\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 7003 /* SubscriptionReceipt */;\n    this.debug = ndk?.debug.extend(\"subscription-start\") ?? debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:subscription-start\");\n  }\n  static from(event) {\n    return new _NDKSubscriptionReceipt(event.ndk, event.rawEvent());\n  }\n  /**\n   * This is the person being subscribed to\n   */\n  get recipient() {\n    const pTag = this.getMatchingTags(\"p\")?.[0];\n    if (!pTag) return void 0;\n    const user = new NDKUser({ pubkey: pTag[1] });\n    return user;\n  }\n  set recipient(user) {\n    this.removeTag(\"p\");\n    if (!user) return;\n    this.tags.push([\"p\", user.pubkey]);\n  }\n  /**\n   * This is the person subscribing\n   */\n  get subscriber() {\n    const PTag = this.getMatchingTags(\"P\")?.[0];\n    if (!PTag) return void 0;\n    const user = new NDKUser({ pubkey: PTag[1] });\n    return user;\n  }\n  set subscriber(user) {\n    this.removeTag(\"P\");\n    if (!user) return;\n    this.tags.push([\"P\", user.pubkey]);\n  }\n  set subscriptionStart(event) {\n    this.debug(`before setting subscription start: ${this.rawEvent}`);\n    this.removeTag(\"e\");\n    this.tag(event, \"subscription\", true);\n    this.debug(`after setting subscription start: ${this.rawEvent}`);\n  }\n  get tierName() {\n    const tag = this.getMatchingTags(\"tier\")?.[0];\n    return tag?.[1];\n  }\n  get isValid() {\n    const period = this.validPeriod;\n    if (!period) {\n      return false;\n    }\n    if (period.start > period.end) {\n      return false;\n    }\n    const pTags = this.getMatchingTags(\"p\");\n    const PTags = this.getMatchingTags(\"P\");\n    if (pTags.length !== 1 || PTags.length !== 1) {\n      return false;\n    }\n    return true;\n  }\n  get validPeriod() {\n    const tag = this.getMatchingTags(\"valid\")?.[0];\n    if (!tag) return void 0;\n    try {\n      return {\n        start: new Date(parseInt(tag[1]) * 1e3),\n        end: new Date(parseInt(tag[2]) * 1e3)\n      };\n    } catch {\n      return void 0;\n    }\n  }\n  set validPeriod(period) {\n    this.removeTag(\"valid\");\n    if (!period) return;\n    this.tags.push([\n      \"valid\",\n      Math.floor(period.start.getTime() / 1e3).toString(),\n      Math.floor(period.end.getTime() / 1e3).toString()\n    ]);\n  }\n  get startPeriod() {\n    return this.validPeriod?.start;\n  }\n  get endPeriod() {\n    return this.validPeriod?.end;\n  }\n  /**\n   * Whether the subscription is currently active\n   */\n  isActive(time) {\n    time ??= /* @__PURE__ */ new Date();\n    const period = this.validPeriod;\n    if (!period) return false;\n    if (time < period.start) return false;\n    if (time > period.end) return false;\n    return true;\n  }\n};\n\n// src/events/kinds/subscriptions/subscription-start.ts\n\nvar NDKSubscriptionStart = class _NDKSubscriptionStart extends NDKEvent {\n  debug;\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 7001 /* Subscribe */;\n    this.debug = ndk?.debug.extend(\"subscription-start\") ?? debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:subscription-start\");\n  }\n  static from(event) {\n    return new _NDKSubscriptionStart(event.ndk, event.rawEvent());\n  }\n  /**\n   * Recipient of the subscription. I.e. The author of this event subscribes to this user.\n   */\n  get recipient() {\n    const pTag = this.getMatchingTags(\"p\")?.[0];\n    if (!pTag) return void 0;\n    const user = new NDKUser({ pubkey: pTag[1] });\n    return user;\n  }\n  set recipient(user) {\n    this.removeTag(\"p\");\n    if (!user) return;\n    this.tags.push([\"p\", user.pubkey]);\n  }\n  /**\n   * The amount of the subscription.\n   */\n  get amount() {\n    const amountTag = this.getMatchingTags(\"amount\")?.[0];\n    if (!amountTag) return void 0;\n    return parseTagToSubscriptionAmount(amountTag);\n  }\n  set amount(amount) {\n    this.removeTag(\"amount\");\n    if (!amount) return;\n    this.tags.push(newAmount(amount.amount, amount.currency, amount.term));\n  }\n  /**\n   * The event id or NIP-33 tag id of the tier that the user is subscribing to.\n   */\n  get tierId() {\n    const eTag = this.getMatchingTags(\"e\")?.[0];\n    const aTag = this.getMatchingTags(\"a\")?.[0];\n    if (!eTag || !aTag) return void 0;\n    return eTag[1] ?? aTag[1];\n  }\n  set tier(tier) {\n    this.removeTag(\"e\");\n    this.removeTag(\"a\");\n    this.removeTag(\"event\");\n    if (!tier) return;\n    this.tag(tier);\n    this.removeTag(\"p\");\n    this.tags.push([\"p\", tier.pubkey]);\n    this.tags.push([\"event\", JSON.stringify(tier.rawEvent())]);\n  }\n  /**\n   * Fetches the tier that the user is subscribing to.\n   */\n  async fetchTier() {\n    const eventTag = this.tagValue(\"event\");\n    if (eventTag) {\n      try {\n        const parsedEvent = JSON.parse(eventTag);\n        return new NDKSubscriptionTier(this.ndk, parsedEvent);\n      } catch {\n        this.debug(\"Failed to parse event tag\");\n      }\n    }\n    const tierId = this.tierId;\n    if (!tierId) return void 0;\n    const e = await this.ndk?.fetchEvent(tierId);\n    if (!e) return void 0;\n    return NDKSubscriptionTier.from(e);\n  }\n  get isValid() {\n    if (this.getMatchingTags(\"amount\").length !== 1) {\n      this.debug(\"Invalid # of amount tag\");\n      return false;\n    }\n    if (!this.amount) {\n      this.debug(\"Invalid amount tag\");\n      return false;\n    }\n    if (this.getMatchingTags(\"p\").length !== 1) {\n      this.debug(\"Invalid # of p tag\");\n      return false;\n    }\n    if (!this.recipient) {\n      this.debug(\"Invalid p tag\");\n      return false;\n    }\n    return true;\n  }\n};\n\n// src/events/kinds/simple-group/index.ts\nvar NDKSimpleGroup = class _NDKSimpleGroup {\n  ndk;\n  groupId;\n  relaySet;\n  fetchingMetadata;\n  metadata;\n  memberList;\n  adminList;\n  constructor(ndk, relaySet, groupId) {\n    this.ndk = ndk;\n    this.groupId = groupId ?? randomId(24);\n    this.relaySet = relaySet;\n  }\n  get id() {\n    return this.groupId;\n  }\n  relayUrls() {\n    return this.relaySet.relayUrls;\n  }\n  get name() {\n    return this.metadata?.name;\n  }\n  get about() {\n    return this.metadata?.about;\n  }\n  get picture() {\n    return this.metadata?.picture;\n  }\n  get members() {\n    return this.memberList?.members ?? [];\n  }\n  get admins() {\n    return this.adminList?.members ?? [];\n  }\n  async getMetadata() {\n    await this.ensureMetadataEvent();\n    return this.metadata;\n  }\n  /**\n   * Creates the group by publishing a kind:9007 event.\n   * @param signer\n   * @returns\n   */\n  async createGroup(signer) {\n    signer ??= this.ndk.signer;\n    if (!signer) throw new Error(\"No signer available\");\n    const user = await signer.user();\n    if (!user) throw new Error(\"No user available\");\n    const event = new NDKEvent(this.ndk);\n    event.kind = 9007 /* GroupAdminCreateGroup */;\n    event.tags.push([\"h\", this.groupId]);\n    await event.sign(signer);\n    return event.publish(this.relaySet);\n  }\n  async setMetadata({\n    name,\n    about,\n    picture\n  }) {\n    const event = new NDKEvent(this.ndk);\n    event.kind = 9002 /* GroupAdminEditMetadata */;\n    event.tags.push([\"h\", this.groupId]);\n    if (name) event.tags.push([\"name\", name]);\n    if (about) event.tags.push([\"about\", about]);\n    if (picture) event.tags.push([\"picture\", picture]);\n    await event.sign();\n    return event.publish(this.relaySet);\n  }\n  /**\n   * Adds a user to the group using a kind:9000 event\n   * @param user user to add\n   * @param opts options\n   */\n  async addUser(user) {\n    const addUserEvent = _NDKSimpleGroup.generateAddUserEvent(user.pubkey, this.groupId);\n    addUserEvent.ndk = this.ndk;\n    return addUserEvent;\n  }\n  async getMemberListEvent() {\n    const memberList = await this.ndk.fetchEvent(\n      {\n        kinds: [39002 /* GroupMembers */],\n        \"#d\": [this.groupId]\n      },\n      void 0,\n      this.relaySet\n    );\n    if (!memberList) return null;\n    return NDKSimpleGroupMemberList.from(memberList);\n  }\n  /**\n   * Gets a list of users that belong to this group\n   */\n  async getMembers() {\n    const members = [];\n    const memberPubkeys = /* @__PURE__ */ new Set();\n    const memberListEvent = await this.getMemberListEvent();\n    if (!memberListEvent) return [];\n    for (const pTag of memberListEvent.getMatchingTags(\"p\")) {\n      const pubkey = pTag[1];\n      if (memberPubkeys.has(pubkey)) continue;\n      memberPubkeys.add(pubkey);\n      try {\n        members.push(this.ndk.getUser({ pubkey }));\n      } catch {\n      }\n    }\n    return members;\n  }\n  /**\n   * Generates an event that lists the members of a group.\n   * @param groupId\n   * @returns\n   */\n  static generateUserListEvent(groupId) {\n    const event = new NDKEvent(void 0, {\n      kind: 39002 /* GroupMembers */,\n      tags: [\n        [\"h\", groupId],\n        [\"alt\", \"Group Member List\"]\n      ]\n    });\n    return event;\n  }\n  /**\n   * Generates an event that adds a user to a group.\n   * @param userPubkey pubkey of the user to add\n   * @param groupId group to add the user to\n   * @returns\n   */\n  static generateAddUserEvent(userPubkey, groupId) {\n    const event = new NDKEvent(void 0, {\n      kind: 9e3 /* GroupAdminAddUser */,\n      tags: [[\"h\", groupId]]\n    });\n    event.tags.push([\"p\", userPubkey]);\n    return event;\n  }\n  async requestToJoin(pubkey, content) {\n    const event = new NDKEvent(this.ndk, {\n      kind: 9021 /* GroupAdminRequestJoin */,\n      content: content ?? \"\",\n      tags: [[\"h\", this.groupId]]\n    });\n    return event.publish(this.relaySet);\n  }\n  /**\n   * Makes sure that a metadata event exists locally\n   */\n  async ensureMetadataEvent() {\n    if (this.metadata) return;\n    if (this.fetchingMetadata) return this.fetchingMetadata;\n    this.fetchingMetadata = this.ndk.fetchEvent(\n      {\n        kinds: [39e3 /* GroupMetadata */],\n        \"#d\": [this.groupId]\n      },\n      void 0,\n      this.relaySet\n    ).then((event) => {\n      if (event) {\n        this.metadata = NDKSimpleGroupMetadata.from(event);\n      } else {\n        this.metadata = new NDKSimpleGroupMetadata(this.ndk);\n        this.metadata.dTag = this.groupId;\n      }\n    }).finally(() => {\n      this.fetchingMetadata = void 0;\n    }).catch(() => {\n      throw new Error(\"Failed to fetch metadata for group \" + this.groupId);\n    });\n    return this.fetchingMetadata;\n  }\n};\nfunction randomId(length) {\n  const chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n  const charsLength = chars.length;\n  let result = \"\";\n  for (let i = 0; i < length; i++) {\n    result += chars.charAt(Math.floor(Math.random() * charsLength));\n  }\n  return result;\n}\n\n// src/app-settings/index.ts\nvar NDKAppSettings = class _NDKAppSettings extends NDKEvent {\n  appName;\n  settings = {};\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 30078 /* AppSpecificData */;\n    this.dTag ??= this.appName;\n    if (this.content.length > 0) {\n      try {\n        this.settings = JSON.parse(this.content);\n      } catch (error) {\n        console.error(\"Error parsing app settings\", error);\n      }\n    }\n  }\n  static from(event) {\n    return new _NDKAppSettings(event.ndk, event);\n  }\n  /**\n   * Set a value for a given key.\n   *\n   * @param key\n   * @param value\n   */\n  set(key, value) {\n    this.settings[key] = value;\n  }\n  /**\n   * Get a value for a given key.\n   *\n   * @param key\n   * @returns\n   */\n  get(key) {\n    return this.settings[key];\n  }\n  async publishReplaceable(relaySet, timeoutMs, requiredRelayCount) {\n    this.content = JSON.stringify(this.settings);\n    return super.publishReplaceable(relaySet, timeoutMs, requiredRelayCount);\n  }\n};\n\n// src/relay/auth-policies.ts\n\nfunction disconnect(pool, debug8) {\n  debug8 ??= debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:relay:auth-policies:disconnect\");\n  return async (relay) => {\n    debug8(`Relay ${relay.url} requested authentication, disconnecting`);\n    pool.removeRelay(relay.url);\n  };\n}\nasync function signAndAuth(event, relay, signer, debug8, resolve, reject) {\n  try {\n    await event.sign(signer);\n    resolve(event);\n  } catch (e) {\n    debug8(`Failed to publish auth event to relay ${relay.url}`, e);\n    reject(event);\n  }\n}\nfunction signIn({ ndk, signer, debug: debug8 } = {}) {\n  debug8 ??= debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:auth-policies:signIn\");\n  return async (relay, challenge) => {\n    debug8(`Relay ${relay.url} requested authentication, signing in`);\n    const event = new NDKEvent(ndk);\n    event.kind = 22242 /* ClientAuth */;\n    event.tags = [\n      [\"relay\", relay.url],\n      [\"challenge\", challenge]\n    ];\n    signer ??= ndk?.signer;\n    return new Promise(async (resolve, reject) => {\n      if (signer) {\n        await signAndAuth(event, relay, signer, debug8, resolve, reject);\n      } else {\n        ndk?.once(\"signer:ready\", async (signer2) => {\n          await signAndAuth(event, relay, signer2, debug8, resolve, reject);\n        });\n      }\n    });\n  };\n}\nvar NDKRelayAuthPolicies = {\n  disconnect,\n  signIn\n};\n\n// src/signers/nip07/index.ts\n\nvar NDKNip07Signer = class {\n  _userPromise;\n  encryptionQueue = [];\n  encryptionProcessing = false;\n  debug;\n  waitTimeout;\n  /**\n   * @param waitTimeout - The timeout in milliseconds to wait for the NIP-07 to become available\n   */\n  constructor(waitTimeout = 1e3) {\n    this.debug = debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:nip07\");\n    this.waitTimeout = waitTimeout;\n  }\n  async blockUntilReady() {\n    await this.waitForExtension();\n    const pubkey = await window.nostr.getPublicKey();\n    if (!pubkey) {\n      throw new Error(\"User rejected access\");\n    }\n    return new NDKUser({ pubkey });\n  }\n  /**\n   * Getter for the user property.\n   * @returns The NDKUser instance.\n   */\n  async user() {\n    if (!this._userPromise) {\n      this._userPromise = this.blockUntilReady();\n    }\n    return this._userPromise;\n  }\n  /**\n   * Signs the given Nostr event.\n   * @param event - The Nostr event to be signed.\n   * @returns The signature of the signed event.\n   * @throws Error if the NIP-07 is not available on the window object.\n   */\n  async sign(event) {\n    await this.waitForExtension();\n    const signedEvent = await window.nostr.signEvent(event);\n    return signedEvent.sig;\n  }\n  async relays(ndk) {\n    await this.waitForExtension();\n    const relays = await window.nostr.getRelays?.() || {};\n    const activeRelays = [];\n    for (const url of Object.keys(relays)) {\n      if (relays[url].read && relays[url].write) {\n        activeRelays.push(url);\n      }\n    }\n    return activeRelays.map((url) => new NDKRelay(url, ndk?.relayAuthDefaultPolicy, ndk));\n  }\n  async encryptionEnabled(nip) {\n    let enabled = [];\n    if ((!nip || nip == \"nip04\") && Boolean(window.nostr.nip04)) enabled.push(\"nip04\");\n    if ((!nip || nip == \"nip44\") && Boolean(window.nostr.nip44)) enabled.push(\"nip44\");\n    return enabled;\n  }\n  async encrypt(recipient, value, nip = \"nip04\") {\n    if (!await this.encryptionEnabled(nip)) throw new Error(nip + \"encryption is not available from your browser extension\");\n    await this.waitForExtension();\n    const recipientHexPubKey = recipient.pubkey;\n    return this.queueEncryption(nip, \"encrypt\", recipientHexPubKey, value);\n  }\n  async decrypt(sender, value, nip = \"nip04\") {\n    if (!await this.encryptionEnabled(nip)) throw new Error(nip + \"encryption is not available from your browser extension\");\n    await this.waitForExtension();\n    const senderHexPubKey = sender.pubkey;\n    return this.queueEncryption(nip, \"decrypt\", senderHexPubKey, value);\n  }\n  async queueEncryption(scheme, method, counterpartyHexpubkey, value) {\n    return new Promise((resolve, reject) => {\n      this.encryptionQueue.push({\n        scheme,\n        method,\n        counterpartyHexpubkey,\n        value,\n        resolve,\n        reject\n      });\n      if (!this.encryptionProcessing) {\n        this.processEncryptionQueue();\n      }\n    });\n  }\n  async processEncryptionQueue(item, retries = 0) {\n    if (!item && this.encryptionQueue.length === 0) {\n      this.encryptionProcessing = false;\n      return;\n    }\n    this.encryptionProcessing = true;\n    const { scheme, method, counterpartyHexpubkey, value, resolve, reject } = item || this.encryptionQueue.shift();\n    this.debug(\"Processing encryption queue item\", {\n      method,\n      counterpartyHexpubkey,\n      value\n    });\n    try {\n      let result = await window.nostr[scheme][method](counterpartyHexpubkey, value);\n      resolve(result);\n    } catch (error) {\n      if (error.message && error.message.includes(\"call already executing\")) {\n        if (retries < 5) {\n          this.debug(\"Retrying encryption queue item\", {\n            method,\n            counterpartyHexpubkey,\n            value,\n            retries\n          });\n          setTimeout(() => {\n            this.processEncryptionQueue(item, retries + 1);\n          }, 50 * retries);\n          return;\n        }\n      }\n      reject(error);\n    }\n    this.processEncryptionQueue();\n  }\n  waitForExtension() {\n    return new Promise((resolve, reject) => {\n      if (window.nostr) {\n        resolve();\n        return;\n      }\n      let timerId;\n      const intervalId = setInterval(() => {\n        if (window.nostr) {\n          clearTimeout(timerId);\n          clearInterval(intervalId);\n          resolve();\n        }\n      }, 100);\n      timerId = setTimeout(() => {\n        clearInterval(intervalId);\n        reject(new Error(\"NIP-07 extension not available\"));\n      }, this.waitTimeout);\n    });\n  }\n};\n\n// src/signers/private-key/index.ts\n\n\n\nvar NDKPrivateKeySigner = class _NDKPrivateKeySigner {\n  _user;\n  _privateKey;\n  constructor(privateKey) {\n    if (privateKey) {\n      if (typeof privateKey === \"string\") {\n        if (privateKey.startsWith(\"nsec1\")) {\n          const { type, data } = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.decode(privateKey);\n          if (type === \"nsec\") this._privateKey = data;\n        } else if (privateKey.length === 64) {\n          this._privateKey = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_6__.hexToBytes)(privateKey);\n        } else {\n          throw new Error(\"Invalid private key provided.\");\n        }\n      } else {\n        this._privateKey = privateKey;\n      }\n      if (this._privateKey) {\n        this._user = new NDKUser({\n          pubkey: (0,nostr_tools__WEBPACK_IMPORTED_MODULE_2__.getPublicKey)(this._privateKey)\n        });\n      }\n    }\n  }\n  get privateKey() {\n    if (!this._privateKey) return void 0;\n    return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_6__.bytesToHex)(this._privateKey);\n  }\n  static generate() {\n    const privateKey = (0,nostr_tools__WEBPACK_IMPORTED_MODULE_2__.generateSecretKey)();\n    return new _NDKPrivateKeySigner(privateKey);\n  }\n  async blockUntilReady() {\n    if (!this._user) {\n      throw new Error(\"NDKUser not initialized\");\n    }\n    return this._user;\n  }\n  async user() {\n    await this.blockUntilReady();\n    return this._user;\n  }\n  async sign(event) {\n    if (!this._privateKey) {\n      throw Error(\"Attempted to sign without a private key\");\n    }\n    return (0,nostr_tools__WEBPACK_IMPORTED_MODULE_2__.finalizeEvent)(event, this._privateKey).sig;\n  }\n  async encryptionEnabled(scheme) {\n    let enabled = [];\n    if (!scheme || scheme == \"nip04\") enabled.push(\"nip04\");\n    if (!scheme || scheme == \"nip44\") enabled.push(\"nip44\");\n    return enabled;\n  }\n  async encrypt(recipient, value, scheme) {\n    if (!this._privateKey || !this.privateKey) {\n      throw Error(\"Attempted to encrypt without a private key\");\n    }\n    const recipientHexPubKey = recipient.pubkey;\n    if (scheme == \"nip44\") {\n      let conversationKey = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip44.v2.utils.getConversationKey(this._privateKey, recipientHexPubKey);\n      return await nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip44.v2.encrypt(value, conversationKey);\n    }\n    return await nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip04.encrypt(this._privateKey, recipientHexPubKey, value);\n  }\n  async decrypt(sender, value, scheme) {\n    if (!this._privateKey || !this.privateKey) {\n      throw Error(\"Attempted to decrypt without a private key\");\n    }\n    const senderHexPubKey = sender.pubkey;\n    if (scheme == \"nip44\") {\n      let conversationKey = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip44.v2.utils.getConversationKey(this._privateKey, senderHexPubKey);\n      return await nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip44.v2.decrypt(value, conversationKey);\n    }\n    return await nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip04.decrypt(this._privateKey, senderHexPubKey, value);\n  }\n};\n\n// src/signers/nip46/rpc.ts\n\nvar NDKNostrRpc = class extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  ndk;\n  signer;\n  relaySet;\n  debug;\n  encryptionType = \"nip04\";\n  pool;\n  constructor(ndk, signer, debug8, relayUrls) {\n    super();\n    this.ndk = ndk;\n    this.signer = signer;\n    if (relayUrls) {\n      this.pool = new NDKPool(\n        relayUrls,\n        [],\n        ndk,\n        {\n          debug: debug8.extend(\"rpc-pool\"),\n          name: \"Nostr RPC\"\n        }\n      );\n      this.relaySet = new NDKRelaySet(/* @__PURE__ */ new Set(), ndk, this.pool);\n      for (const url of relayUrls) {\n        const relay = this.pool.getRelay(url, false, false);\n        relay.authPolicy = NDKRelayAuthPolicies.signIn({ ndk, signer, debug: debug8 });\n        this.relaySet.addRelay(relay);\n        relay.connect();\n      }\n    }\n    this.debug = debug8.extend(\"rpc\");\n  }\n  /**\n   * Subscribe to a filter. This function will resolve once the subscription is ready.\n   */\n  subscribe(filter) {\n    const sub = this.ndk.subscribe(\n      filter,\n      {\n        closeOnEose: false,\n        groupable: false,\n        cacheUsage: \"ONLY_RELAY\" /* ONLY_RELAY */,\n        pool: this.pool\n      },\n      this.relaySet,\n      false\n    );\n    sub.on(\"event\", async (event) => {\n      try {\n        const parsedEvent = await this.parseEvent(event);\n        if (parsedEvent.method) {\n          this.emit(\"request\", parsedEvent);\n        } else {\n          this.emit(`response-${parsedEvent.id}`, parsedEvent);\n        }\n      } catch (e) {\n        this.debug(\"error parsing event\", e, event.rawEvent());\n      }\n    });\n    return new Promise((resolve) => {\n      sub.on(\"eose\", () => {\n        this.debug(\"eosed\");\n        resolve(sub);\n      });\n      sub.start();\n    });\n  }\n  async parseEvent(event) {\n    if (this.encryptionType === \"nip44\" && event.content.includes(\"?iv=\")) {\n      this.encryptionType = \"nip04\";\n    } else if (this.encryptionType === \"nip04\" && !event.content.includes(\"?iv=\")) {\n      this.encryptionType = \"nip44\";\n    }\n    const remoteUser = this.ndk.getUser({ pubkey: event.pubkey });\n    remoteUser.ndk = this.ndk;\n    let decryptedContent;\n    try {\n      decryptedContent = await this.signer.decrypt(\n        remoteUser,\n        event.content,\n        this.encryptionType\n      );\n    } catch (e) {\n      const otherEncryptionType = this.encryptionType === \"nip04\" ? \"nip44\" : \"nip04\";\n      decryptedContent = await this.signer.decrypt(remoteUser, event.content, otherEncryptionType);\n      this.encryptionType = otherEncryptionType;\n    }\n    const parsedContent = JSON.parse(decryptedContent);\n    const { id, method, params, result, error } = parsedContent;\n    if (method) {\n      return { id, pubkey: event.pubkey, method, params, event };\n    } else {\n      return { id, result, error, event };\n    }\n  }\n  async sendResponse(id, remotePubkey, result, kind = 24133 /* NostrConnect */, error) {\n    const res = { id, result };\n    if (error) {\n      res.error = error;\n    }\n    const localUser = await this.signer.user();\n    const remoteUser = this.ndk.getUser({ pubkey: remotePubkey });\n    const event = new NDKEvent(this.ndk, {\n      kind,\n      content: JSON.stringify(res),\n      tags: [[\"p\", remotePubkey]],\n      pubkey: localUser.pubkey\n    });\n    event.content = await this.signer.encrypt(remoteUser, event.content, this.encryptionType);\n    await event.sign(this.signer);\n    await event.publish(this.relaySet);\n  }\n  /**\n   * Sends a request.\n   * @param remotePubkey\n   * @param method\n   * @param params\n   * @param kind\n   * @param id\n   */\n  async sendRequest(remotePubkey, method, params = [], kind = 24133, cb) {\n    const id = Math.random().toString(36).substring(7);\n    const localUser = await this.signer.user();\n    const remoteUser = this.ndk.getUser({ pubkey: remotePubkey });\n    const request = { id, method, params };\n    const promise = new Promise(() => {\n      const responseHandler = (response) => {\n        if (response.result === \"auth_url\") {\n          this.once(`response-${id}`, responseHandler);\n          this.emit(\"authUrl\", response.error);\n        } else if (cb) {\n          cb(response);\n        }\n      };\n      this.once(`response-${id}`, responseHandler);\n    });\n    const event = new NDKEvent(this.ndk, {\n      kind,\n      content: JSON.stringify(request),\n      tags: [[\"p\", remotePubkey]],\n      pubkey: localUser.pubkey\n    });\n    event.content = await this.signer.encrypt(remoteUser, event.content, this.encryptionType);\n    await event.sign(this.signer);\n    await event.publish(this.relaySet);\n    return promise;\n  }\n};\n\n// src/signers/nip46/backend/ping.ts\nvar PingEventHandlingStrategy = class {\n  async handle(backend, id, remotePubkey, params) {\n    const debug8 = backend.debug.extend(\"ping\");\n    debug8(`ping request from ${remotePubkey}`);\n    if (await backend.pubkeyAllowed({ id, pubkey: remotePubkey, method: \"ping\" })) {\n      debug8(`connection request from ${remotePubkey} allowed`);\n      return \"pong\";\n    } else {\n      debug8(`connection request from ${remotePubkey} rejected`);\n    }\n    return void 0;\n  }\n};\n\n// src/signers/nip46/backend/connect.ts\nvar ConnectEventHandlingStrategy = class {\n  async handle(backend, id, remotePubkey, params) {\n    const [_, token] = params;\n    const debug8 = backend.debug.extend(\"connect\");\n    debug8(`connection request from ${remotePubkey}`);\n    if (token && backend.applyToken) {\n      debug8(`applying token`);\n      await backend.applyToken(remotePubkey, token);\n    }\n    if (await backend.pubkeyAllowed({\n      id,\n      pubkey: remotePubkey,\n      method: \"connect\",\n      params: token\n    })) {\n      debug8(`connection request from ${remotePubkey} allowed`);\n      return \"ack\";\n    } else {\n      debug8(`connection request from ${remotePubkey} rejected`);\n    }\n    return void 0;\n  }\n};\n\n// src/signers/nip46/backend/get-public-key.ts\nvar GetPublicKeyHandlingStrategy = class {\n  async handle(backend, id, remotePubkey, params) {\n    return backend.localUser?.pubkey;\n  }\n};\n\n// src/signers/nip46/backend/nip04-decrypt.ts\nvar Nip04DecryptHandlingStrategy = class {\n  async handle(backend, id, remotePubkey, params) {\n    const [senderPubkey, payload] = params;\n    const senderUser = new NDKUser({ pubkey: senderPubkey });\n    const decryptedPayload = await decrypt2(backend, id, remotePubkey, senderUser, payload);\n    return decryptedPayload;\n  }\n};\nasync function decrypt2(backend, id, remotePubkey, senderUser, payload) {\n  if (!await backend.pubkeyAllowed({\n    id,\n    pubkey: remotePubkey,\n    method: \"nip04_decrypt\",\n    params: payload\n  })) {\n    backend.debug(`decrypt request from ${remotePubkey} rejected`);\n    return void 0;\n  }\n  return await backend.signer.decrypt(senderUser, payload, \"nip04\");\n}\n\n// src/signers/nip46/backend/nip04-encrypt.ts\nvar Nip04EncryptHandlingStrategy = class {\n  async handle(backend, id, remotePubkey, params) {\n    const [recipientPubkey, payload] = params;\n    const recipientUser = new NDKUser({ pubkey: recipientPubkey });\n    const encryptedPayload = await encrypt2(backend, id, remotePubkey, recipientUser, payload);\n    return encryptedPayload;\n  }\n};\nasync function encrypt2(backend, id, remotePubkey, recipientUser, payload) {\n  if (!await backend.pubkeyAllowed({\n    id,\n    pubkey: remotePubkey,\n    method: \"nip04_encrypt\",\n    params: payload\n  })) {\n    backend.debug(`encrypt request from ${remotePubkey} rejected`);\n    return void 0;\n  }\n  return await backend.signer.encrypt(recipientUser, payload, \"nip04\");\n}\n\n// src/signers/nip46/backend/sign-event.ts\nvar SignEventHandlingStrategy = class {\n  async handle(backend, id, remotePubkey, params) {\n    const event = await signEvent(backend, id, remotePubkey, params);\n    if (!event) return void 0;\n    return JSON.stringify(await event.toNostrEvent());\n  }\n};\nasync function signEvent(backend, id, remotePubkey, params) {\n  const [eventString] = params;\n  backend.debug(`sign event request from ${remotePubkey}`);\n  const event = new NDKEvent(backend.ndk, JSON.parse(eventString));\n  backend.debug(\"event to sign\", event.rawEvent());\n  if (!await backend.pubkeyAllowed({\n    id,\n    pubkey: remotePubkey,\n    method: \"sign_event\",\n    params: event\n  })) {\n    backend.debug(`sign event request from ${remotePubkey} rejected`);\n    return void 0;\n  }\n  backend.debug(`sign event request from ${remotePubkey} allowed`);\n  await event.sign(backend.signer);\n  return event;\n}\n\n// src/signers/nip46/backend/nip44-encrypt.ts\nvar Nip04EncryptHandlingStrategy2 = class {\n  async handle(backend, id, remotePubkey, params) {\n    const [recipientPubkey, payload] = params;\n    const recipientUser = new NDKUser({ pubkey: recipientPubkey });\n    const encryptedPayload = await encrypt3(backend, id, remotePubkey, recipientUser, payload);\n    return encryptedPayload;\n  }\n};\nasync function encrypt3(backend, id, remotePubkey, recipientUser, payload) {\n  if (!await backend.pubkeyAllowed({\n    id,\n    pubkey: remotePubkey,\n    method: \"nip44_encrypt\",\n    params: payload\n  })) {\n    backend.debug(`encrypt request from ${remotePubkey} rejected`);\n    return void 0;\n  }\n  return await backend.signer.encrypt(recipientUser, payload, \"nip44\");\n}\n\n// src/signers/nip46/backend/nip44-decrypt.ts\nvar Nip04DecryptHandlingStrategy2 = class {\n  async handle(backend, id, remotePubkey, params) {\n    const [senderPubkey, payload] = params;\n    const senderUser = new NDKUser({ pubkey: senderPubkey });\n    const decryptedPayload = await decrypt3(backend, id, remotePubkey, senderUser, payload);\n    return decryptedPayload;\n  }\n};\nasync function decrypt3(backend, id, remotePubkey, senderUser, payload) {\n  if (!await backend.pubkeyAllowed({\n    id,\n    pubkey: remotePubkey,\n    method: \"nip44_decrypt\",\n    params: payload\n  })) {\n    backend.debug(`decrypt request from ${remotePubkey} rejected`);\n    return void 0;\n  }\n  return await backend.signer.decrypt(senderUser, payload, \"nip44\");\n}\n\n// src/signers/nip46/backend/index.ts\n\nvar NDKNip46Backend = class {\n  ndk;\n  signer;\n  localUser;\n  debug;\n  rpc;\n  permitCallback;\n  relayUrls;\n  /**\n   * @param ndk The NDK instance to use\n   * @param privateKeyOrSigner The private key or signer of the npub that wants to be published as\n   * @param permitCallback Callback executed when permission is requested\n   */\n  constructor(ndk, privateKeyOrSigner, permitCallback, relayUrls) {\n    this.ndk = ndk;\n    if (privateKeyOrSigner instanceof Uint8Array) {\n      this.signer = new NDKPrivateKeySigner(privateKeyOrSigner);\n    } else if (privateKeyOrSigner instanceof String) {\n      this.signer = new NDKPrivateKeySigner((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_6__.hexToBytes)(privateKeyOrSigner));\n    } else if (privateKeyOrSigner instanceof NDKPrivateKeySigner) {\n      this.signer = privateKeyOrSigner;\n    } else {\n      throw new Error(\"Invalid signer\");\n    }\n    this.debug = ndk.debug.extend(\"nip46:backend\");\n    this.relayUrls = relayUrls ?? Array.from(ndk.pool.relays.keys());\n    this.rpc = new NDKNostrRpc(ndk, this.signer, this.debug, this.relayUrls);\n    this.permitCallback = permitCallback;\n  }\n  /**\n   * This method starts the backend, which will start listening for incoming\n   * requests.\n   */\n  async start() {\n    this.localUser = await this.signer.user();\n    const sub = this.ndk.subscribe(\n      {\n        kinds: [24133],\n        \"#p\": [this.localUser.pubkey]\n      },\n      { closeOnEose: false }\n    );\n    sub.on(\"event\", (e) => this.handleIncomingEvent(e));\n  }\n  handlers = {\n    connect: new ConnectEventHandlingStrategy(),\n    sign_event: new SignEventHandlingStrategy(),\n    nip04_encrypt: new Nip04EncryptHandlingStrategy(),\n    nip04_decrypt: new Nip04DecryptHandlingStrategy(),\n    nip44_encrypt: new Nip04EncryptHandlingStrategy2(),\n    nip44_decrypt: new Nip04DecryptHandlingStrategy2(),\n    get_public_key: new GetPublicKeyHandlingStrategy(),\n    ping: new PingEventHandlingStrategy()\n  };\n  /**\n   * Enables the user to set a custom strategy for handling incoming events.\n   * @param method - The method to set the strategy for\n   * @param strategy - The strategy to set\n   */\n  setStrategy(method, strategy) {\n    this.handlers[method] = strategy;\n  }\n  /**\n   * Overload this method to apply tokens, which can\n   * wrap permission sets to be applied to a pubkey.\n   * @param pubkey public key to apply token to\n   * @param token token to apply\n   */\n  async applyToken(pubkey, token) {\n    throw new Error(\"connection token not supported\");\n  }\n  async handleIncomingEvent(event) {\n    const { id, method, params } = await this.rpc.parseEvent(event);\n    const remotePubkey = event.pubkey;\n    let response;\n    this.debug(\"incoming event\", { id, method, params });\n    if (!event.verifySignature(false)) {\n      this.debug(\"invalid signature\", event.rawEvent());\n      return;\n    }\n    const strategy = this.handlers[method];\n    if (strategy) {\n      try {\n        response = await strategy.handle(this, id, remotePubkey, params);\n      } catch (e) {\n        this.debug(\"error handling event\", e, { id, method, params });\n        this.rpc.sendResponse(id, remotePubkey, \"error\", void 0, e.message);\n      }\n    } else {\n      this.debug(\"unsupported method\", { method, params });\n    }\n    if (response) {\n      this.debug(`sending response to ${remotePubkey}`, response);\n      this.rpc.sendResponse(id, remotePubkey, response);\n    } else {\n      this.rpc.sendResponse(id, remotePubkey, \"error\", void 0, \"Not authorized\");\n    }\n  }\n  /**\n   * This method should be overriden by the user to allow or reject incoming\n   * connections.\n   */\n  async pubkeyAllowed(params) {\n    return this.permitCallback(params);\n  }\n};\n\n// src/signers/nip46/index.ts\n\nvar NDKNip46Signer = class extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  ndk;\n  _user;\n  /**\n   * The pubkey of the bunker that will be providing signatures\n   */\n  bunkerPubkey;\n  /**\n   * The pubkey of the user that events will be published as\n   */\n  userPubkey;\n  /**\n   * An optional secret value provided to connect to the bunker\n   */\n  secret;\n  localSigner;\n  nip05;\n  rpc;\n  debug;\n  relayUrls;\n  subscription;\n  /**\n   * @param ndk - The NDK instance to use\n   * @param userOrConnectionToken - The public key, or a connection token, of the npub that wants to be published as\n   * @param localSigner - The signer that will be used to request events to be signed\n   */\n  constructor(ndk, userOrConnectionToken, localSigner) {\n    super();\n    this.ndk = ndk;\n    this.debug = ndk.debug.extend(\"nip46:signer\");\n    if (userOrConnectionToken.startsWith(\"bunker://\")) {\n      this.connectionTokenInit(userOrConnectionToken);\n    } else {\n      this.nip05Init(userOrConnectionToken);\n    }\n    if (!localSigner) {\n      this.localSigner = NDKPrivateKeySigner.generate();\n    } else {\n      this.localSigner = localSigner;\n    }\n    this.rpc = new NDKNostrRpc(this.ndk, this.localSigner, this.debug, this.relayUrls);\n  }\n  connectionTokenInit(connectionToken) {\n    const bunkerUrl = new URL(connectionToken);\n    const bunkerPubkey = bunkerUrl.hostname || bunkerUrl.pathname.replace(/^\\/\\//, \"\");\n    const userPubkey = bunkerUrl.searchParams.get(\"pubkey\");\n    const relayUrls = bunkerUrl.searchParams.getAll(\"relay\");\n    const secret = bunkerUrl.searchParams.get(\"secret\");\n    this.bunkerPubkey = bunkerPubkey;\n    this.userPubkey = userPubkey;\n    this.relayUrls = relayUrls;\n    this.secret = secret;\n  }\n  nip05Init(nip05) {\n    this.nip05 = nip05;\n  }\n  /**\n   * @deprecated Use userPubkey instead\n   */\n  get remotePubkey() {\n    return this.userPubkey;\n  }\n  /**\n   * We start listening for events from the bunker\n   */\n  async startListening() {\n    if (this.subscription) return;\n    const localUser = await this.localSigner.user();\n    if (!localUser) throw new Error(\"Local signer not ready\");\n    this.subscription = await this.rpc.subscribe({\n      kinds: [24133 /* NostrConnect */],\n      \"#p\": [localUser.pubkey]\n    });\n  }\n  /**\n   * Get the user that is being published as\n   */\n  async user() {\n    if (!this._user && !this.userPubkey) throw new Error(\"Remote user not ready\");\n    this._user ??= new NDKUser({ pubkey: this.userPubkey });\n    return this._user;\n  }\n  async blockUntilReady() {\n    if (this.nip05 && !this.userPubkey) {\n      const user = await NDKUser.fromNip05(this.nip05, this.ndk);\n      if (user) {\n        this._user = user;\n        this.userPubkey = user.pubkey;\n        this.relayUrls = user.nip46Urls;\n        this.rpc = new NDKNostrRpc(this.ndk, this.localSigner, this.debug, this.relayUrls);\n      }\n    }\n    if (!this.bunkerPubkey && this.userPubkey) {\n      this.bunkerPubkey = this.userPubkey;\n    } else if (!this.bunkerPubkey) {\n      throw new Error(\"Bunker pubkey not set\");\n    }\n    await this.startListening();\n    this.rpc.on(\"authUrl\", (...props) => {\n      this.emit(\"authUrl\", ...props);\n    });\n    return new Promise((resolve, reject) => {\n      const connectParams = [this.userPubkey ?? \"\"];\n      if (this.secret) connectParams.push(this.secret);\n      if (!this.bunkerPubkey) throw new Error(\"Bunker pubkey not set\");\n      this.rpc.sendRequest(\n        this.bunkerPubkey,\n        \"connect\",\n        connectParams,\n        24133,\n        (response) => {\n          if (response.result === \"ack\") {\n            this.getPublicKey().then((pubkey) => {\n              this.userPubkey = pubkey;\n              this._user = new NDKUser({ pubkey });\n              resolve(this._user);\n            });\n          } else {\n            reject(response.error);\n          }\n        }\n      );\n    });\n  }\n  async getPublicKey() {\n    if (this.userPubkey) return this.userPubkey;\n    return new Promise((resolve, reject) => {\n      if (!this.bunkerPubkey) throw new Error(\"Bunker pubkey not set\");\n      this.rpc.sendRequest(\n        this.bunkerPubkey,\n        \"get_public_key\",\n        [],\n        24133,\n        (response) => {\n          resolve(response.result);\n        }\n      );\n    });\n  }\n  async encryptionEnabled(scheme) {\n    if (scheme) return [scheme];\n    return Promise.resolve([\"nip04\", \"nip44\"]);\n  }\n  async encrypt(recipient, value, scheme = \"nip04\") {\n    return this.encryption(recipient, value, scheme, \"encrypt\");\n  }\n  async decrypt(sender, value, scheme = \"nip04\") {\n    return this.encryption(sender, value, scheme, \"decrypt\");\n  }\n  async encryption(peer, value, scheme, method) {\n    const promise = new Promise((resolve, reject) => {\n      if (!this.bunkerPubkey) throw new Error(\"Bunker pubkey not set\");\n      this.rpc.sendRequest(\n        this.bunkerPubkey,\n        `${scheme}_${method}`,\n        [peer.pubkey, value],\n        24133,\n        (response) => {\n          if (!response.error) {\n            resolve(response.result);\n          } else {\n            reject(response.error);\n          }\n        }\n      );\n    });\n    return promise;\n  }\n  async sign(event) {\n    const promise = new Promise((resolve, reject) => {\n      if (!this.bunkerPubkey) throw new Error(\"Bunker pubkey not set\");\n      this.rpc.sendRequest(\n        this.bunkerPubkey,\n        \"sign_event\",\n        [JSON.stringify(event)],\n        24133,\n        (response) => {\n          if (!response.error) {\n            const json = JSON.parse(response.result);\n            resolve(json.sig);\n          } else {\n            reject(response.error);\n          }\n        }\n      );\n    });\n    return promise;\n  }\n  /**\n   * Allows creating a new account on the remote server.\n   * @param username Desired username for the NIP-05\n   * @param domain Desired domain for the NIP-05\n   * @param email Email address to associate with this account -- Remote servers may use this for recovery\n   * @returns The public key of the newly created account\n   */\n  async createAccount(username, domain, email) {\n    await this.startListening();\n    const req = [];\n    if (username) req.push(username);\n    if (domain) req.push(domain);\n    if (email) req.push(email);\n    return new Promise((resolve, reject) => {\n      if (!this.bunkerPubkey) throw new Error(\"Bunker pubkey not set\");\n      this.rpc.sendRequest(\n        this.bunkerPubkey,\n        \"create_account\",\n        req,\n        24133 /* NostrConnect */,\n        (response) => {\n          if (!response.error) {\n            const pubkey = response.result;\n            resolve(pubkey);\n          } else {\n            reject(response.error);\n          }\n        }\n      );\n    });\n  }\n};\n\n// src/dvm/schedule.ts\nfunction addRelays(event, relays) {\n  const tags = [];\n  if (!relays || relays.length === 0) {\n    const poolRelays = event.ndk?.pool.relays;\n    relays = poolRelays ? Object.keys(poolRelays) : void 0;\n  }\n  if (relays && relays.length > 0) tags.push([\"relays\", ...relays]);\n  return tags;\n}\nasync function dvmSchedule(events, dvm, relays, encrypted = true, waitForConfirmationForMs) {\n  if (!(events instanceof Array)) {\n    events = [events];\n  }\n  const ndk = events[0].ndk;\n  if (!ndk) throw new Error(\"NDK not set\");\n  for (const event of events) {\n    if (!event.sig) throw new Error(\"Event not signed\");\n    if (!event.created_at) throw new Error(\"Event has no date\");\n    if (!dvm) throw new Error(\"No DVM specified\");\n    if (event.created_at <= Date.now() / 1e3)\n      throw new Error(\"Event needs to be in the future\");\n  }\n  const scheduleEvent = new NDKDVMRequest(ndk, {\n    kind: 5905 /* DVMEventSchedule */\n  });\n  for (const event of events) {\n    scheduleEvent.addInput(JSON.stringify(event.rawEvent()), \"text\");\n  }\n  scheduleEvent.tags.push(...addRelays(events[0], relays));\n  if (encrypted) {\n    await scheduleEvent.encryption(dvm);\n  } else {\n    scheduleEvent.dvm = dvm;\n  }\n  await scheduleEvent.sign();\n  let res;\n  if (waitForConfirmationForMs) {\n    res = ndk.subscribe(\n      {\n        kinds: [5905 /* DVMEventSchedule */ + 1e3, 7e3 /* DVMJobFeedback */],\n        ...scheduleEvent.filter()\n      },\n      { groupable: false, closeOnEose: false }\n    );\n  }\n  const timeoutPromise = new Promise((reject) => {\n    setTimeout(() => {\n      res?.stop();\n      reject(\"Timeout waiting for an answer from the DVM\");\n    }, waitForConfirmationForMs);\n  });\n  const schedulePromise = new Promise(\n    (resolve, reject) => {\n      if (waitForConfirmationForMs) {\n        res?.on(\"event\", async (e) => {\n          res?.stop();\n          if (e.kind === 7e3 /* DVMJobFeedback */) {\n            const feedback = await NDKDVMJobFeedback.from(e);\n            if (feedback.status === \"error\") {\n              const statusTag = feedback.getMatchingTags(\"status\");\n              reject(statusTag?.[2] ?? feedback);\n            } else {\n              resolve(feedback);\n            }\n          }\n          resolve(e);\n        });\n      }\n      scheduleEvent.publish().then(() => {\n        if (!waitForConfirmationForMs) resolve();\n      });\n    }\n  );\n  return new Promise((resolve, reject) => {\n    if (waitForConfirmationForMs) {\n      Promise.race([timeoutPromise, schedulePromise]).then((e) => {\n        resolve(e);\n      }).catch(reject);\n    } else {\n      schedulePromise.then(resolve);\n    }\n  });\n}\n\n// src/ndk/index.ts\n\n\n\n// src/events/dedup.ts\nfunction dedup(event1, event2) {\n  if (event1.created_at > event2.created_at) {\n    return event1;\n  }\n  return event2;\n}\n\n// src/outbox/tracker.ts\n\n\n\n// src/utils/get-users-relay-list.ts\nasync function getRelayListForUser(pubkey, ndk) {\n  const list = await getRelayListForUsers([pubkey], ndk);\n  return list.get(pubkey);\n}\nasync function getRelayListForUsers(pubkeys, ndk, skipCache = false, timeout = 1e3) {\n  const pool = ndk.outboxPool || ndk.pool;\n  const set = /* @__PURE__ */ new Set();\n  for (const relay of pool.relays.values()) set.add(relay);\n  const relayLists = /* @__PURE__ */ new Map();\n  const fromContactList = /* @__PURE__ */ new Map();\n  const relaySet = new NDKRelaySet(set, ndk);\n  if (ndk.cacheAdapter?.locking && !skipCache) {\n    const cachedList = await ndk.fetchEvents(\n      { kinds: [3, 10002], authors: Array.from(new Set(pubkeys)) },\n      { cacheUsage: \"ONLY_CACHE\" /* ONLY_CACHE */, subId: \"ndk-relay-list-fetch\" }\n    );\n    for (const relayList of cachedList) {\n      if (relayList.kind === 10002)\n        relayLists.set(relayList.pubkey, NDKRelayList.from(relayList));\n    }\n    for (const relayList of cachedList) {\n      if (relayList.kind === 3) {\n        if (relayLists.has(relayList.pubkey)) continue;\n        const list = relayListFromKind3(ndk, relayList);\n        if (list) fromContactList.set(relayList.pubkey, list);\n      }\n    }\n    pubkeys = pubkeys.filter(\n      (pubkey) => !relayLists.has(pubkey) && !fromContactList.has(pubkey)\n    );\n  }\n  if (pubkeys.length === 0) return relayLists;\n  const relayListEvents = /* @__PURE__ */ new Map();\n  const contactListEvents = /* @__PURE__ */ new Map();\n  return new Promise(async (resolve) => {\n    const sub = ndk.subscribe(\n      { kinds: [3, 10002], authors: pubkeys },\n      {\n        closeOnEose: true,\n        pool,\n        groupable: true,\n        cacheUsage: \"ONLY_RELAY\" /* ONLY_RELAY */,\n        subId: \"ndk-relay-list-fetch\"\n      },\n      relaySet,\n      false\n    );\n    sub.on(\"event\", (event) => {\n      if (event.kind === 10002 /* RelayList */) {\n        const existingEvent = relayListEvents.get(event.pubkey);\n        if (existingEvent && existingEvent.created_at > event.created_at) return;\n        relayListEvents.set(event.pubkey, event);\n      } else if (event.kind === 3 /* Contacts */) {\n        const existingEvent = contactListEvents.get(event.pubkey);\n        if (existingEvent && existingEvent.created_at > event.created_at) return;\n        contactListEvents.set(event.pubkey, event);\n      }\n    });\n    sub.on(\"eose\", () => {\n      for (const event of relayListEvents.values()) {\n        relayLists.set(event.pubkey, NDKRelayList.from(event));\n      }\n      for (const pubkey of pubkeys) {\n        if (relayLists.has(pubkey)) continue;\n        const contactList = contactListEvents.get(pubkey);\n        if (!contactList) continue;\n        const list = relayListFromKind3(ndk, contactList);\n        if (list) relayLists.set(pubkey, list);\n      }\n      resolve(relayLists);\n    });\n    setTimeout(() => {\n      resolve(relayLists);\n    }, timeout);\n    sub.start();\n  });\n}\n\n// src/outbox/tracker.ts\nvar OutboxItem = class {\n  /**\n   * Type of item\n   */\n  type;\n  /**\n   * The relay URLs that are of interest to this item\n   */\n  relayUrlScores;\n  readRelays;\n  writeRelays;\n  constructor(type) {\n    this.type = type;\n    this.relayUrlScores = /* @__PURE__ */ new Map();\n    this.readRelays = /* @__PURE__ */ new Set();\n    this.writeRelays = /* @__PURE__ */ new Set();\n  }\n};\nvar OutboxTracker = class extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  data;\n  ndk;\n  debug;\n  constructor(ndk) {\n    super();\n    this.ndk = ndk;\n    this.debug = ndk.debug.extend(\"outbox-tracker\");\n    this.data = new typescript_lru_cache__WEBPACK_IMPORTED_MODULE_3__.LRUCache({\n      maxSize: 1e5,\n      entryExpirationTimeInMS: 2 * 60 * 1e3\n    });\n  }\n  /**\n   * Adds a list of users to the tracker.\n   * @param items\n   * @param skipCache\n   */\n  async trackUsers(items, skipCache = false) {\n    const promises = [];\n    for (let i = 0; i < items.length; i += 400) {\n      const slice = items.slice(i, i + 400);\n      const pubkeys = slice.map((item) => getKeyFromItem(item)).filter((pubkey) => !this.data.has(pubkey));\n      if (pubkeys.length === 0) continue;\n      for (const pubkey of pubkeys) {\n        this.data.set(pubkey, new OutboxItem(\"user\"));\n      }\n      promises.push(\n        new Promise((resolve) => {\n          getRelayListForUsers(pubkeys, this.ndk, skipCache).then((relayLists) => {\n            for (const [pubkey, relayList] of relayLists) {\n              let outboxItem = this.data.get(pubkey);\n              outboxItem ??= new OutboxItem(\"user\");\n              if (relayList) {\n                outboxItem.readRelays = new Set(\n                  normalize(relayList.readRelayUrls)\n                );\n                outboxItem.writeRelays = new Set(\n                  normalize(relayList.writeRelayUrls)\n                );\n                for (const relayUrl of outboxItem.readRelays) {\n                  if (this.ndk.pool.blacklistRelayUrls.has(relayUrl)) {\n                    outboxItem.readRelays.delete(relayUrl);\n                  }\n                }\n                for (const relayUrl of outboxItem.writeRelays) {\n                  if (this.ndk.pool.blacklistRelayUrls.has(relayUrl)) {\n                    outboxItem.writeRelays.delete(relayUrl);\n                  }\n                }\n                this.data.set(pubkey, outboxItem);\n              }\n            }\n          }).finally(resolve);\n        })\n      );\n    }\n    return Promise.all(promises);\n  }\n  /**\n   *\n   * @param key\n   * @param score\n   */\n  track(item, type, skipCache = true) {\n    const key = getKeyFromItem(item);\n    type ??= getTypeFromItem(item);\n    let outboxItem = this.data.get(key);\n    if (!outboxItem) {\n      outboxItem = new OutboxItem(type);\n      if (item instanceof NDKUser) {\n        this.trackUsers([item]);\n      }\n    }\n    return outboxItem;\n  }\n};\nfunction getKeyFromItem(item) {\n  if (item instanceof NDKUser) {\n    return item.pubkey;\n  } else {\n    return item;\n  }\n}\nfunction getTypeFromItem(item) {\n  if (item instanceof NDKUser) {\n    return \"user\";\n  } else {\n    return \"kind\";\n  }\n}\n\n// src/relay/sets/utils.ts\nfunction correctRelaySet(relaySet, pool) {\n  const connectedRelays = pool.connectedRelays();\n  const includesConnectedRelay = Array.from(relaySet.relays).some((relay) => {\n    return connectedRelays.map((r) => r.url).includes(relay.url);\n  });\n  if (!includesConnectedRelay) {\n    for (const relay of connectedRelays) {\n      relaySet.addRelay(relay);\n    }\n  }\n  if (connectedRelays.length === 0) {\n    for (const relay of pool.relays.values()) {\n      relaySet.addRelay(relay);\n    }\n  }\n  return relaySet;\n}\n\n// src/ndk/fetch-event-from-tag.ts\nfunction isValidHint(hint) {\n  if (!hint || hint === \"\") return false;\n  try {\n    new URL(hint);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nasync function fetchEventFromTag(tag, originalEvent, subOpts, fallback = {\n  type: \"timeout\"\n}) {\n  const d4 = this.debug.extend(\"fetch-event-from-tag\");\n  const [_, id, hint] = tag;\n  subOpts = {};\n  d4(\"fetching event from tag\", tag, subOpts, fallback);\n  const authorRelays = getRelaysForSync(this, originalEvent.pubkey);\n  if (authorRelays && authorRelays.size > 0) {\n    d4(\"fetching event from author relays %o\", Array.from(authorRelays));\n    const relaySet2 = NDKRelaySet.fromRelayUrls(Array.from(authorRelays), this);\n    const event2 = await this.fetchEvent(id, subOpts, relaySet2);\n    if (event2) return event2;\n  } else {\n    d4(\"no author relays found for %s\", originalEvent.pubkey, originalEvent);\n  }\n  const relaySet = calculateRelaySetsFromFilters(this, [{ ids: [id] }], this.pool);\n  d4(\"fetching event without relay hint\", relaySet);\n  const event = await this.fetchEvent(id, subOpts);\n  if (event) return event;\n  if (hint && hint !== \"\") {\n    const event2 = await this.fetchEvent(\n      id,\n      subOpts,\n      this.pool.getRelay(hint, true, true, [{ ids: [id] }])\n    );\n    if (event2) return event2;\n  }\n  let result = void 0;\n  const relay = isValidHint(hint) ? this.pool.getRelay(hint, false, true, [{ ids: [id] }]) : void 0;\n  const fetchMaybeWithRelayHint = new Promise((resolve) => {\n    this.fetchEvent(id, subOpts, relay).then(resolve);\n  });\n  if (!isValidHint(hint) || fallback.type === \"none\") {\n    return fetchMaybeWithRelayHint;\n  }\n  const fallbackFetchPromise = new Promise(async (resolve) => {\n    const fallbackRelaySet = fallback.relaySet;\n    const timeout = fallback.timeout ?? 1500;\n    const timeoutPromise = new Promise((resolve2) => setTimeout(resolve2, timeout));\n    if (fallback.type === \"timeout\") await timeoutPromise;\n    if (result) {\n      resolve(result);\n    } else {\n      d4(\"fallback fetch triggered\");\n      const fallbackEvent = await this.fetchEvent(id, subOpts, fallbackRelaySet);\n      resolve(fallbackEvent);\n    }\n  });\n  switch (fallback.type) {\n    case \"timeout\":\n      return Promise.race([fetchMaybeWithRelayHint, fallbackFetchPromise]);\n    case \"eose\":\n      result = await fetchMaybeWithRelayHint;\n      if (result) return result;\n      return fallbackFetchPromise;\n  }\n}\n\n// src/media/index.ts\nvar SPEC_PATH = \"/.well-known/nostr/nip96.json\";\nvar Nip96 = class {\n  ndk;\n  spec;\n  url;\n  nip98Required = false;\n  /**\n   * @param domain domain of the NIP96 service\n   */\n  constructor(domain, ndk) {\n    this.url = `https://${domain}${SPEC_PATH}`;\n    this.ndk = ndk;\n  }\n  async prepareUpload(blob, httpVerb = \"POST\") {\n    this.validateHttpFetch();\n    if (!this.spec) await this.fetchSpec();\n    if (!this.spec) throw new Error(\"Failed to fetch NIP96 spec\");\n    let headers = {};\n    if (this.nip98Required) {\n      const authorizationHeader = await this.generateNip98Header(\n        this.spec.api_url,\n        httpVerb,\n        blob\n      );\n      headers = { Authorization: authorizationHeader };\n    }\n    return {\n      url: this.spec.api_url,\n      headers\n    };\n  }\n  /**\n   * Provides an XMLHttpRequest-based upload method for browsers.\n   * @example\n   * const xhr = new XMLHttpRequest();\n   * xhr.upload.addEventListener(\"progress\", function(e) {\n   *    const percentComplete = e.loaded / e.total;\n   *    console.log(percentComplete);\n   * });\n   * const nip96 = ndk.getNip96(\"nostrcheck.me\");\n   * const blob = new Blob([\"Hello, world!\"], { type: \"text/plain\" });\n   * const response = await nip96.xhrUpload(xhr, blob);\n   * console.log(response);\n   * @returns Promise that resolves to the upload response\n   */\n  async xhrUpload(xhr, blob) {\n    const httpVerb = \"POST\";\n    const { url, headers } = await this.prepareUpload(blob, httpVerb);\n    xhr.open(httpVerb, url, true);\n    if (headers[\"Authorization\"]) {\n      xhr.setRequestHeader(\"Authorization\", headers[\"Authorization\"]);\n    }\n    const formData = new FormData();\n    formData.append(\"file\", blob);\n    return new Promise((resolve, reject) => {\n      xhr.onload = function() {\n        if (xhr.status >= 200 && xhr.status < 300) {\n          resolve(JSON.parse(xhr.responseText));\n        } else {\n          reject(new Error(xhr.statusText));\n        }\n      };\n      xhr.onerror = function() {\n        reject(new Error(\"Network Error\"));\n      };\n      xhr.send(formData);\n    });\n  }\n  /**\n   * Fetch-based upload method. Note that this will use NDK's httpFetch\n   * @param blob\n   * @returns Promise that resolves to the upload response\n   *\n   * @example\n   * const nip96 = ndk.getNip96(\"nostrcheck.me\");\n   * const blob = new Blob([\"Hello, world!\"], { type: \"text/plain\" });\n   * const response = await nip96.upload(blob);\n   * console.log(response);\n   */\n  async upload(blob) {\n    const httpVerb = \"POST\";\n    const { url, headers } = await this.prepareUpload(blob, httpVerb);\n    const formData = new FormData();\n    formData.append(\"file\", blob);\n    const res = await this.ndk.httpFetch(this.spec.api_url, {\n      method: httpVerb,\n      headers,\n      body: formData\n    });\n    if (res.status !== 200) throw new Error(`Failed to upload file to ${url}`);\n    const json = await res.json();\n    if (json.status !== \"success\") throw new Error(json.message);\n    return json;\n  }\n  validateHttpFetch() {\n    if (!this.ndk) throw new Error(\"NDK is required to fetch NIP96 spec\");\n    if (!this.ndk.httpFetch)\n      throw new Error(\"NDK must have an httpFetch method to fetch NIP96 spec\");\n  }\n  async fetchSpec() {\n    this.validateHttpFetch();\n    const res = await this.ndk.httpFetch(this.url);\n    if (res.status !== 200) throw new Error(`Failed to fetch NIP96 spec from ${this.url}`);\n    const spec = await res.json();\n    if (!spec) throw new Error(`Failed to parse NIP96 spec from ${this.url}`);\n    this.spec = spec;\n    this.nip98Required = this.spec.plans.free.is_nip98_required;\n  }\n  async generateNip98Header(requestUrl, httpMethod, blob) {\n    const event = new NDKEvent(this.ndk, {\n      kind: 27235 /* HttpAuth */,\n      tags: [\n        [\"u\", requestUrl],\n        [\"method\", httpMethod]\n      ]\n    });\n    if ([\"POST\", \"PUT\", \"PATCH\"].includes(httpMethod)) {\n      const sha256Hash = await this.calculateSha256(blob);\n      event.tags.push([\"payload\", sha256Hash]);\n    }\n    await event.sign();\n    const encodedEvent = btoa(JSON.stringify(event.rawEvent()));\n    return `Nostr ${encodedEvent}`;\n  }\n  async calculateSha256(blob) {\n    const buffer = await blob.arrayBuffer();\n    const hashBuffer = await crypto.subtle.digest(\"SHA-256\", buffer);\n    const hashArray = Array.from(new Uint8Array(hashBuffer));\n    const hashHex = hashArray.map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n    return hashHex;\n  }\n};\n\n// src/ndk/queue/index.ts\nvar Queue = class {\n  queue = [];\n  maxConcurrency;\n  processing = /* @__PURE__ */ new Set();\n  promises = /* @__PURE__ */ new Map();\n  constructor(name, maxConcurrency) {\n    this.maxConcurrency = maxConcurrency;\n  }\n  add(item) {\n    if (this.promises.has(item.id)) {\n      return this.promises.get(item.id);\n    } else {\n    }\n    const promise = new Promise((resolve, reject) => {\n      this.queue.push({\n        ...item,\n        func: () => item.func().then(\n          (result) => {\n            resolve(result);\n            return result;\n          },\n          (error) => {\n            reject(error);\n            throw error;\n          }\n        )\n      });\n      this.process();\n    });\n    this.promises.set(item.id, promise);\n    promise.finally(() => {\n      this.promises.delete(item.id);\n      this.processing.delete(item.id);\n      this.process();\n    });\n    return promise;\n  }\n  process() {\n    if (this.processing.size >= this.maxConcurrency || this.queue.length === 0) {\n      return;\n    }\n    const item = this.queue.shift();\n    if (!item || this.processing.has(item.id)) {\n      return;\n    }\n    this.processing.add(item.id);\n    item.func();\n  }\n  clear() {\n    this.queue = [];\n  }\n  clearProcessing() {\n    this.processing.clear();\n  }\n  clearAll() {\n    this.clear();\n    this.clearProcessing();\n  }\n  length() {\n    return this.queue.length;\n  }\n};\n\n// src/subscription/manager.ts\n\nvar NDKSubscriptionManager = class {\n  subscriptions;\n  seenEvents = /* @__PURE__ */ new Map();\n  constructor() {\n    this.subscriptions = /* @__PURE__ */ new Map();\n  }\n  add(sub) {\n    this.subscriptions.set(sub.internalId, sub);\n    if (sub.onStopped) {\n      console.log(\"SUB-MANAGER BUG: Subscription already had onStopped! \\u{1F914}\", sub.internalId);\n    }\n    sub.onStopped = () => {\n      this.subscriptions.delete(sub.internalId);\n    };\n    sub.on(\"close\", () => {\n      this.subscriptions.delete(sub.internalId);\n    });\n  }\n  seenEvent(eventId, relay) {\n    const current = this.seenEvents.get(eventId) || [];\n    current.push(relay);\n    this.seenEvents.set(eventId, current);\n  }\n  /**\n   * Whenever an event comes in, this function is called.\n   * This function matches the received event against all the\n   * known (i.e. active) NDKSubscriptions, and if it matches,\n   * it sends the event to the subscription.\n   * \n   * This is the single place in the codebase that matches\n   * incoming events with parties interested in the event.\n   * \n   * This is also what allows for reactivity in NDK apps, such that\n   * whenever an active subscription receives an event that some\n   * other active subscription would want to receive, both receive it.\n   * \n   * TODO This also allows for subscriptions that overlap in meaning\n   * to be collapsed into one.\n   * \n   * I.e. if a subscription with filter: kinds: [1], authors: [alice]\n   * is created and EOSEs, and then a subsequent subscription with\n   * kinds: [1], authors: [alice] is created, once the second subscription\n   * EOSEs we can safely close it, increment its refCount and close it,\n   * and when the first subscription receives a new event from Alice this\n   * code will make the second subscription receive the event even though\n   * it has no active subscription on a relay.\n   * @param event Raw event received from a relay\n   * @param relay Relay that sent the event\n   * @param optimisticPublish Whether the event is coming from an optimistic publish\n   */\n  dispatchEvent(event, relay, optimisticPublish = false) {\n    if (relay) this.seenEvent(event.id, relay);\n    const subscriptions = this.subscriptions.values();\n    const matchingSubs = [];\n    for (const sub of subscriptions) {\n      if ((0,nostr_tools__WEBPACK_IMPORTED_MODULE_2__.matchFilters)(sub.filters, event)) {\n        matchingSubs.push(sub);\n      }\n    }\n    for (const sub of matchingSubs) {\n      sub.eventReceived(event, relay, false, optimisticPublish);\n    }\n  }\n};\n\n// src/ndk/active-user.ts\n\nvar debug6 = debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:active-user\");\nasync function getUserRelayList(user) {\n  if (!this.autoConnectUserRelays) return;\n  const userRelays = await getRelayListForUser(user.pubkey, this);\n  if (!userRelays) return;\n  for (const url of userRelays.relays) {\n    let relay = this.pool.relays.get(url);\n    if (!relay) {\n      relay = new NDKRelay(url, this.relayAuthDefaultPolicy, this);\n      this.pool.addRelay(relay);\n    }\n  }\n  return userRelays;\n}\nasync function setActiveUser(user) {\n  const pool = this.outboxPool || this.pool;\n  if (pool.connectedRelays.length > 0) {\n    setActiveUserConnected.call(this, user);\n  } else {\n    pool.once(\"connect\", () => {\n      setActiveUserConnected.call(this, user);\n    });\n  }\n}\nasync function setActiveUserConnected(user) {\n  const userRelays = await getUserRelayList.call(this, user);\n  const filters = [\n    {\n      kinds: [10006 /* BlockRelayList */],\n      authors: [user.pubkey]\n    }\n  ];\n  if (this.autoFetchUserMutelist) {\n    filters[0].kinds.push(1e4 /* MuteList */);\n  }\n  const relaySet = userRelays ? userRelays.relaySet : void 0;\n  const sub = this.subscribe(\n    filters,\n    { subId: \"active-user-settings\", closeOnEose: true },\n    relaySet,\n    false\n  );\n  const events = /* @__PURE__ */ new Map();\n  sub.on(\"event\", (event) => {\n    const prevEvent = events.get(event.kind);\n    if (prevEvent && prevEvent.created_at >= event.created_at) return;\n    events.set(event.kind, event);\n  });\n  sub.on(\"eose\", () => {\n    for (const event of events.values()) {\n      processEvent.call(this, event);\n    }\n  });\n  sub.start();\n}\nasync function processEvent(event) {\n  if (event.kind === 10006 /* BlockRelayList */) {\n    processBlockRelayList.call(this, event);\n  } else if (event.kind === 1e4 /* MuteList */) {\n    processMuteList.call(this, event);\n  }\n}\nfunction processBlockRelayList(event) {\n  const list = lists_default.from(event);\n  for (const item of list.items) {\n    this.pool.blacklistRelayUrls.add(item[0]);\n  }\n  debug6(\"Added %d relays to relay blacklist\", list.items.length);\n}\nfunction processMuteList(muteList) {\n  const list = lists_default.from(muteList);\n  for (const item of list.items) {\n    this.mutedIds.set(item[1], item[0]);\n  }\n  debug6(\"Added %d users to mute list\", list.items.length);\n}\n\n// src/ndk/index.ts\nvar DEFAULT_OUTBOX_RELAYS = [\"wss://purplepag.es/\", \"wss://nos.lol/\"];\nvar DEFAULT_BLACKLISTED_RELAYS = [\n  \"wss://brb.io/\",\n  // BRB\n  \"wss://nostr.mutinywallet.com/\"\n  // Don't try to read from this relay since it's a write-only relay\n  // \"wss://purplepag.es/\", // This is a hack, since this is a mostly read-only relay, but not fully. Once we have relay routing this can be removed so it only receives the supported kinds\n];\nvar NDK = class extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  _explicitRelayUrls;\n  blacklistRelayUrls;\n  pool;\n  outboxPool;\n  _signer;\n  _activeUser;\n  cacheAdapter;\n  debug;\n  devWriteRelaySet;\n  outboxTracker;\n  mutedIds;\n  clientName;\n  clientNip89;\n  queuesZapConfig;\n  queuesNip05;\n  asyncSigVerification = false;\n  initialValidationRatio = 1;\n  lowestValidationRatio = 1;\n  validationRatioFn;\n  subManager;\n  publishingFailureHandled = false;\n  pools = [];\n  /**\n   * Default relay-auth policy that will be used when a relay requests authentication,\n   * if no other policy is specified for that relay.\n   *\n   * @example Disconnect from relays that request authentication:\n   * ```typescript\n   * ndk.relayAuthDefaultPolicy = NDKAuthPolicies.disconnect(ndk.pool);\n   * ```\n   *\n   * @example Sign in to relays that request authentication:\n   * ```typescript\n   * ndk.relayAuthDefaultPolicy = NDKAuthPolicies.signIn({ndk})\n   * ```\n   *\n   * @example Sign in to relays that request authentication, asking the user for confirmation:\n   * ```typescript\n   * ndk.relayAuthDefaultPolicy = (relay: NDKRelay) => {\n   *     const signIn = NDKAuthPolicies.signIn({ndk});\n   *     if (confirm(`Relay ${relay.url} is requesting authentication, do you want to sign in?`)) {\n   *        signIn(relay);\n   *     }\n   * }\n   * ```\n   */\n  relayAuthDefaultPolicy;\n  /**\n   * Fetch function to use for HTTP requests.\n   *\n   * @example\n   * ```typescript\n   * import fetch from \"node-fetch\";\n   *\n   * ndk.httpFetch = fetch;\n   * ```\n   */\n  httpFetch;\n  /**\n   * Provide a caller function to receive all networking traffic from relays\n   */\n  netDebug;\n  autoConnectUserRelays = true;\n  autoFetchUserMutelist = true;\n  walletConfig;\n  constructor(opts = {}) {\n    super();\n    this.debug = opts.debug || debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk\");\n    this.netDebug = opts.netDebug;\n    this._explicitRelayUrls = opts.explicitRelayUrls || [];\n    this.blacklistRelayUrls = opts.blacklistRelayUrls || DEFAULT_BLACKLISTED_RELAYS;\n    this.subManager = new NDKSubscriptionManager();\n    this.pool = new NDKPool(\n      opts.explicitRelayUrls || [],\n      [],\n      this\n    );\n    this.pool.name = \"Main\";\n    this.pool.on(\"relay:auth\", async (relay, challenge) => {\n      if (this.relayAuthDefaultPolicy) {\n        await this.relayAuthDefaultPolicy(relay, challenge);\n      }\n    });\n    this.autoConnectUserRelays = opts.autoConnectUserRelays ?? true;\n    this.autoFetchUserMutelist = opts.autoFetchUserMutelist ?? true;\n    this.clientName = opts.clientName;\n    this.clientNip89 = opts.clientNip89;\n    this.relayAuthDefaultPolicy = opts.relayAuthDefaultPolicy;\n    if (opts.enableOutboxModel) {\n      this.outboxPool = new NDKPool(\n        opts.outboxRelayUrls || DEFAULT_OUTBOX_RELAYS,\n        [],\n        this,\n        {\n          debug: this.debug.extend(\"outbox-pool\"),\n          name: \"Outbox Pool\"\n        }\n      );\n      this.outboxTracker = new OutboxTracker(this);\n    }\n    this.signer = opts.signer;\n    this.cacheAdapter = opts.cacheAdapter;\n    this.mutedIds = opts.mutedIds || /* @__PURE__ */ new Map();\n    if (opts.devWriteRelayUrls) {\n      this.devWriteRelaySet = NDKRelaySet.fromRelayUrls(opts.devWriteRelayUrls, this);\n    }\n    this.queuesZapConfig = new Queue(\"zaps\", 3);\n    this.queuesNip05 = new Queue(\"nip05\", 10);\n    this.signatureVerificationWorker = opts.signatureVerificationWorker;\n    this.initialValidationRatio = opts.initialValidationRatio || 1;\n    this.lowestValidationRatio = opts.lowestValidationRatio || 1;\n    try {\n      this.httpFetch = fetch;\n    } catch {\n    }\n  }\n  set explicitRelayUrls(urls) {\n    this._explicitRelayUrls = urls;\n    this.pool.relayUrls = urls;\n  }\n  get explicitRelayUrls() {\n    return this._explicitRelayUrls || [];\n  }\n  set signatureVerificationWorker(worker2) {\n    this.asyncSigVerification = !!worker2;\n    if (worker2) {\n      signatureVerificationInit(worker2);\n    }\n  }\n  /**\n   * Adds an explicit relay to the pool.\n   * @param url\n   * @param relayAuthPolicy Authentication policy to use if different from the default\n   * @param connect Whether to connect to the relay automatically\n   * @returns\n   */\n  addExplicitRelay(urlOrRelay, relayAuthPolicy, connect = true) {\n    let relay;\n    if (typeof urlOrRelay === \"string\") {\n      relay = new NDKRelay(urlOrRelay, relayAuthPolicy, this);\n    } else {\n      relay = urlOrRelay;\n    }\n    this.pool.addRelay(relay, connect);\n    this.explicitRelayUrls.push(relay.url);\n    return relay;\n  }\n  toJSON() {\n    return { relayCount: this.pool.relays.size }.toString();\n  }\n  get activeUser() {\n    return this._activeUser;\n  }\n  /**\n   * Sets the active user for this NDK instance, typically this will be\n   * called when assigning a signer to the NDK instance.\n   *\n   * This function will automatically connect to the user's relays if\n   * `autoConnectUserRelays` is set to true.\n   *\n   * It will also fetch the user's mutelist if `autoFetchUserMutelist` is set to true.\n   */\n  set activeUser(user) {\n    const differentUser = this._activeUser?.pubkey !== user?.pubkey;\n    this._activeUser = user;\n    if (user && differentUser) {\n      setActiveUser.call(this, user);\n    } else if (!user) {\n      this.mutedIds = /* @__PURE__ */ new Map();\n    }\n  }\n  get signer() {\n    return this._signer;\n  }\n  set signer(newSigner) {\n    this._signer = newSigner;\n    if (newSigner) this.emit(\"signer:ready\", newSigner);\n    newSigner?.user().then((user) => {\n      user.ndk = this;\n      this.activeUser = user;\n    });\n  }\n  /**\n   * Connect to relays with optional timeout.\n   * If the timeout is reached, the connection will be continued to be established in the background.\n   */\n  async connect(timeoutMs) {\n    if (this._signer && this.autoConnectUserRelays) {\n      this.debug(\n        \"Attempting to connect to user relays specified by signer %o\",\n        await this._signer.relays?.(this)\n      );\n      if (this._signer.relays) {\n        const relays = await this._signer.relays(this);\n        relays.forEach((relay) => this.pool.addRelay(relay));\n      }\n    }\n    const connections = [this.pool.connect(timeoutMs)];\n    if (this.outboxPool) {\n      connections.push(this.outboxPool.connect(timeoutMs));\n    }\n    this.debug(\"Connecting to relays %o\", { timeoutMs });\n    return Promise.allSettled(connections).then(() => {\n    });\n  }\n  /**\n   * Get a NDKUser object\n   *\n   * @param opts\n   * @returns\n   */\n  getUser(opts) {\n    const user = new NDKUser(opts);\n    user.ndk = this;\n    return user;\n  }\n  /**\n   * Get a NDKUser from a NIP05\n   * @param nip05 NIP-05 ID\n   * @param skipCache Skip cache\n   * @returns\n   */\n  async getUserFromNip05(nip05, skipCache = false) {\n    return NDKUser.fromNip05(nip05, this, skipCache);\n  }\n  /**\n   * Create a new subscription. Subscriptions automatically start, you can make them automatically close when all relays send back an EOSE by setting `opts.closeOnEose` to `true`)\n   *\n   * @param filters\n   * @param opts\n   * @param relaySet explicit relay set to use\n   * @param autoStart automatically start the subscription -- this can be a boolean or an object with `onEvent` and `onEose` handlers\n   * @returns NDKSubscription\n   */\n  subscribe(filters, opts, relaySet, autoStart = true) {\n    const subscription = new NDKSubscription(this, filters, opts, relaySet);\n    this.subManager.add(subscription);\n    const pool = opts?.pool ?? this.pool;\n    if (relaySet) {\n      for (const relay of relaySet.relays) {\n        pool.useTemporaryRelay(relay, void 0, subscription.filters);\n      }\n    }\n    if (this.outboxPool && subscription.hasAuthorsFilter()) {\n      const authors = subscription.filters.filter((filter) => filter.authors && filter.authors?.length > 0).map((filter) => filter.authors).flat();\n      this.outboxTracker?.trackUsers(authors);\n    }\n    if (autoStart) {\n      let eventsHandler;\n      if (typeof autoStart === \"object\") {\n        if (autoStart.onEvent) subscription.on(\"event\", autoStart.onEvent);\n        if (autoStart.onEose) subscription.on(\"eose\", autoStart.onEose);\n        if (autoStart.onEvents) eventsHandler = autoStart.onEvents;\n      }\n      setTimeout(() => {\n        const cachedEvents = subscription.start(!eventsHandler);\n        if (cachedEvents && !!eventsHandler) eventsHandler(cachedEvents);\n      }, 0);\n    }\n    return subscription;\n  }\n  /**\n   * Publish an event to a relay\n   * @param event event to publish\n   * @param relaySet explicit relay set to use\n   * @param timeoutMs timeout in milliseconds to wait for the event to be published\n   * @returns The relays the event was published to\n   *\n   * @deprecated Use `event.publish()` instead\n   */\n  async publish(event, relaySet, timeoutMs) {\n    this.debug(\"Deprecated: Use `event.publish()` instead\");\n    return event.publish(relaySet, timeoutMs);\n  }\n  /**\n   * Attempts to fetch an event from a tag, following relay hints and\n   * other best practices.\n   * @param tag Tag to fetch the event from\n   * @param originalEvent Event where the tag came from\n   * @param subOpts Subscription options to use when fetching the event\n   * @param fallback Fallback options to use when the hint relay doesn't respond\n   * @returns\n   */\n  fetchEventFromTag = fetchEventFromTag.bind(this);\n  /**\n   * Fetch an event from the cache synchronously.\n   * @param idOrFilter event id in bech32 format or filter\n   * @returns events from the cache or null if the cache is empty\n   */\n  fetchEventSync(idOrFilter) {\n    if (!this.cacheAdapter) throw new Error(\"Cache adapter not set\");\n    let filters;\n    if (typeof idOrFilter === \"string\") filters = [filterFromId(idOrFilter)];\n    else filters = idOrFilter;\n    const sub = new NDKSubscription(this, filters);\n    const events = this.cacheAdapter.query(sub);\n    if (events instanceof Promise) throw new Error(\"Cache adapter is async\");\n    return events.map((e) => {\n      e.ndk = this;\n      return e;\n    });\n  }\n  /**\n   * Fetch a single event.\n   *\n   * @param idOrFilter event id in bech32 format or filter\n   * @param opts subscription options\n   * @param relaySetOrRelay explicit relay set to use\n   */\n  async fetchEvent(idOrFilter, opts, relaySetOrRelay) {\n    let filters;\n    let relaySet;\n    if (relaySetOrRelay instanceof NDKRelay) {\n      relaySet = new NDKRelaySet(/* @__PURE__ */ new Set([relaySetOrRelay]), this);\n    } else if (relaySetOrRelay instanceof NDKRelaySet) {\n      relaySet = relaySetOrRelay;\n    }\n    if (!relaySetOrRelay && typeof idOrFilter === \"string\") {\n      if (!isNip33AValue(idOrFilter)) {\n        const relays = relaysFromBech32(idOrFilter, this);\n        if (relays.length > 0) {\n          relaySet = new NDKRelaySet(new Set(relays), this);\n          relaySet = correctRelaySet(relaySet, this.pool);\n        }\n      }\n    }\n    if (typeof idOrFilter === \"string\") {\n      filters = [filterFromId(idOrFilter)];\n    } else if (Array.isArray(idOrFilter)) {\n      filters = idOrFilter;\n    } else {\n      filters = [idOrFilter];\n    }\n    if (filters.length === 0) {\n      throw new Error(`Invalid filter: ${JSON.stringify(idOrFilter)}`);\n    }\n    return new Promise((resolve) => {\n      let fetchedEvent = null;\n      const s = this.subscribe(\n        filters,\n        { ...opts || {}, closeOnEose: true },\n        relaySet,\n        false\n      );\n      const t2 = setTimeout(() => {\n        s.stop();\n        resolve(fetchedEvent);\n      }, 1e4);\n      s.on(\"event\", (event) => {\n        event.ndk = this;\n        if (!event.isReplaceable()) {\n          clearTimeout(t2);\n          resolve(event);\n        } else if (!fetchedEvent || fetchedEvent.created_at < event.created_at) {\n          fetchedEvent = event;\n        }\n      });\n      s.on(\"eose\", () => {\n        clearTimeout(t2);\n        resolve(fetchedEvent);\n      });\n      s.start();\n    });\n  }\n  /**\n   * Fetch events\n   */\n  async fetchEvents(filters, opts, relaySet) {\n    return new Promise((resolve) => {\n      const events = /* @__PURE__ */ new Map();\n      const relaySetSubscription = this.subscribe(\n        filters,\n        { ...opts || {}, closeOnEose: true },\n        relaySet,\n        false\n      );\n      const onEvent = (event) => {\n        if (!(event instanceof NDKEvent)) event = new NDKEvent(void 0, event);\n        const dedupKey = event.deduplicationKey();\n        const existingEvent = events.get(dedupKey);\n        if (existingEvent) {\n          event = dedup(existingEvent, event);\n        }\n        event.ndk = this;\n        events.set(dedupKey, event);\n      };\n      relaySetSubscription.on(\"event\", onEvent);\n      relaySetSubscription.on(\"eose\", () => {\n        resolve(new Set(events.values()));\n      });\n      relaySetSubscription.start();\n    });\n  }\n  /**\n   * Ensures that a signer is available to sign an event.\n   */\n  assertSigner() {\n    if (!this.signer) {\n      this.emit(\"signer:required\");\n      throw new Error(\"Signer required\");\n    }\n  }\n  /**\n   * Creates a new Nip96 instance for the given domain.\n   * @param domain Domain to use for nip96 uploads\n   * @example Upload a file to a NIP-96 enabled domain:\n   *\n   * ```typescript\n   * const blob = new Blob([\"Hello, world!\"], { type: \"text/plain\" });\n   * const nip96 = ndk.getNip96(\"nostrcheck.me\");\n   * await nip96.upload(blob);\n   * ```\n   */\n  getNip96(domain) {\n    return new Nip96(domain, this);\n  }\n  set wallet(wallet) {\n    if (!wallet) {\n      this.walletConfig = void 0;\n      return;\n    }\n    this.walletConfig ??= {};\n    this.walletConfig.lnPay = wallet?.lnPay?.bind(wallet);\n    this.walletConfig.cashuPay = wallet?.cashuPay?.bind(wallet);\n  }\n};\n\n// src/zap/invoice.ts\n\nfunction zapInvoiceFromEvent(event) {\n  const description = event.getMatchingTags(\"description\")[0];\n  const bolt11 = event.getMatchingTags(\"bolt11\")[0];\n  let decodedInvoice;\n  let zapRequest;\n  if (!description || !bolt11 || !bolt11[1]) {\n    return null;\n  }\n  try {\n    let zapRequestPayload = description[1];\n    if (zapRequestPayload.startsWith(\"%\")) {\n      zapRequestPayload = decodeURIComponent(zapRequestPayload);\n    }\n    if (zapRequestPayload === \"\") {\n      return null;\n    }\n    zapRequest = JSON.parse(zapRequestPayload);\n    decodedInvoice = (0,light_bolt11_decoder__WEBPACK_IMPORTED_MODULE_7__.decode)(bolt11[1]);\n  } catch (e) {\n    return null;\n  }\n  const amountSection = decodedInvoice.sections.find((s) => s.name === \"amount\");\n  if (!amountSection) {\n    return null;\n  }\n  const amount = parseInt(amountSection.value);\n  if (!amount) {\n    return null;\n  }\n  const content = zapRequest.content;\n  const sender = zapRequest.pubkey;\n  const recipientTag = event.getMatchingTags(\"p\")[0];\n  const recipient = recipientTag[1];\n  let zappedEvent = event.getMatchingTags(\"e\")[0];\n  if (!zappedEvent) {\n    zappedEvent = event.getMatchingTags(\"a\")[0];\n  }\n  const zappedEventId = zappedEvent ? zappedEvent[1] : void 0;\n  const zapInvoice = {\n    id: event.id,\n    zapper: event.pubkey,\n    zappee: sender,\n    zapped: recipient,\n    zappedEvent: zappedEventId,\n    amount,\n    comment: content\n  };\n  return zapInvoice;\n}\n\n// src/zapper/index.ts\n\n\n\n// src/zapper/nip57.ts\n\nasync function generateZapRequest(target, ndk, data, pubkey, amount, relays, comment, tags, signer) {\n  const zapEndpoint = data.callback;\n  const zapRequest = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip57.makeZapRequest({\n    profile: pubkey,\n    // set the event to null since nostr-tools doesn't support nip-33 zaps\n    event: null,\n    amount,\n    comment: comment || \"\",\n    relays: relays.slice(0, 4)\n  });\n  if (target instanceof NDKEvent) {\n    const tags2 = target.referenceTags();\n    const nonPTags = tags2.filter((tag) => tag[0] !== \"p\");\n    zapRequest.tags.push(...nonPTags);\n  }\n  zapRequest.tags.push([\"lnurl\", zapEndpoint]);\n  const event = new NDKEvent(ndk, zapRequest);\n  if (tags) {\n    event.tags = event.tags.concat(tags);\n  }\n  if (event.hasTag(\"a\")) {\n    event.tags = event.tags.filter((tag) => tag[0] !== \"e\");\n  }\n  event.tags = event.tags.filter((tag) => tag[0] !== \"p\");\n  event.tags.push([\"p\", pubkey]);\n  await event.sign(signer);\n  return event;\n}\n\n// src/zapper/ln.ts\n\n\nvar d2 = debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:zapper:ln\");\nasync function getNip57ZapSpecFromLud({ lud06, lud16 }, ndk) {\n  let zapEndpoint;\n  if (lud16 && !lud16.startsWith(\"LNURL\")) {\n    const [name, domain] = lud16.split(\"@\");\n    zapEndpoint = `https://${domain}/.well-known/lnurlp/${name}`;\n  } else if (lud06) {\n    const { words } = _scure_base__WEBPACK_IMPORTED_MODULE_8__.bech32.decode(lud06, 1e3);\n    const data = _scure_base__WEBPACK_IMPORTED_MODULE_8__.bech32.fromWords(words);\n    const utf8Decoder = new TextDecoder(\"utf-8\");\n    zapEndpoint = utf8Decoder.decode(data);\n  }\n  if (!zapEndpoint) {\n    d2(\"No zap endpoint found %o\", { lud06, lud16 });\n    throw new Error(\"No zap endpoint found\");\n  }\n  try {\n    const _fetch = ndk.httpFetch || fetch;\n    const response = await _fetch(zapEndpoint);\n    if (response.status !== 200) {\n      const text = await response.text();\n      throw new Error(`Unable to fetch zap endpoint ${zapEndpoint}: ${text}`);\n    }\n    return await response.json();\n  } catch (e) {\n    throw new Error(`Unable to fetch zap endpoint ${zapEndpoint}: ${e}`);\n  }\n}\n\n// src/zapper/index.ts\nvar d3 = debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:zapper\");\nvar NDKZapper = class extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  target;\n  ndk;\n  comment;\n  amount;\n  unit;\n  tags;\n  signer;\n  zapMethod;\n  nutzapAsFallback;\n  lnPay;\n  /**\n   * Called when a cashu payment is to be made.\n   * This function should swap/mint proofs for the required amount, in the required unit,\n   * in any of the provided mints and return the proofs and mint used.\n   */\n  cashuPay;\n  onComplete;\n  maxRelays = 3;\n  /**\n   * \n   * @param target The target of the zap\n   * @param amount The amount to send indicated in the unit\n   * @param unit The unit of the amount\n   * @param opts Options for the zap\n   */\n  constructor(target, amount, unit = \"msat\", opts = {}) {\n    super();\n    this.target = target;\n    this.ndk = opts.ndk || target.ndk;\n    if (!this.ndk) {\n      throw new Error(\"No NDK instance provided\");\n    }\n    this.amount = amount;\n    this.comment = opts.comment;\n    this.unit = unit;\n    this.tags = opts.tags;\n    this.signer = opts.signer;\n    this.nutzapAsFallback = opts.nutzapAsFallback ?? false;\n    this.lnPay = opts.lnPay || this.ndk.walletConfig?.lnPay;\n    this.cashuPay = opts.cashuPay || this.ndk.walletConfig?.cashuPay;\n    this.onComplete = opts.onComplete || this.ndk.walletConfig?.onPaymentComplete;\n  }\n  /**\n   * Initiate zapping process\n   * \n   * This function will calculate the splits for this zap and initiate each zap split.\n   */\n  async zap(methods) {\n    const splits = this.getZapSplits();\n    const results = /* @__PURE__ */ new Map();\n    await Promise.all(\n      splits.map(async (split) => {\n        let result;\n        try {\n          result = await this.zapSplit(split, methods);\n        } catch (e) {\n          result = new Error(e.message);\n        }\n        this.emit(\"split:complete\", split, result);\n        results.set(split, result);\n      })\n    );\n    this.emit(\"complete\", results);\n    if (this.onComplete) this.onComplete(results);\n    return results;\n  }\n  async zapNip57(split, data) {\n    if (!this.lnPay) throw new Error(\"No lnPay function available\");\n    const zapSpec = await getNip57ZapSpecFromLud(data, this.ndk);\n    if (!zapSpec) throw new Error(\"No zap spec available for recipient\");\n    const relays = await this.relays(split.pubkey);\n    const zapRequest = await generateZapRequest(\n      this.target,\n      this.ndk,\n      zapSpec,\n      split.pubkey,\n      split.amount,\n      relays,\n      this.comment,\n      this.tags,\n      this.signer\n    );\n    if (!zapRequest) {\n      d3(\"Unable to generate zap request\");\n      throw new Error(\"Unable to generate zap request\");\n    }\n    const pr = await this.getLnInvoice(zapRequest, split.amount, zapSpec);\n    if (!pr) {\n      d3(\"Unable to get payment request\");\n      throw new Error(\"Unable to get payment request\");\n    }\n    this.emit(\"ln_invoice\", {\n      amount: split.amount,\n      recipientPubkey: split.pubkey,\n      unit: this.unit,\n      nip57ZapRequest: zapRequest,\n      pr,\n      type: \"nip57\"\n    });\n    const res = await this.lnPay(\n      {\n        target: this.target,\n        recipientPubkey: split.pubkey,\n        paymentDescription: \"NIP-57 Zap\",\n        pr,\n        amount: split.amount,\n        unit: this.unit,\n        nip57ZapRequest: zapRequest\n      }\n    );\n    if (res?.preimage) {\n      this.emit(\"ln_payment\", {\n        preimage: res.preimage,\n        amount: split.amount,\n        recipientPubkey: split.pubkey,\n        pr,\n        unit: this.unit,\n        nip57ZapRequest: zapRequest,\n        type: \"nip57\"\n      });\n    }\n    return res;\n  }\n  /**\n   * Fetches information about a NIP-61 zap and asks the caller to create cashu proofs for the zap.\n   * \n   * (note that the cashuPay function can use any method to create the proofs, including using lightning\n   * to mint proofs in the specified mint, the responsibility of minting the proofs is delegated to the caller (e.g. ndk-wallet))\n   */\n  async zapNip61(split, data) {\n    if (!this.cashuPay) throw new Error(\"No cashuPay function available\");\n    let ret;\n    ret = await this.cashuPay({\n      target: this.target,\n      recipientPubkey: split.pubkey,\n      paymentDescription: \"NIP-61 Zap\",\n      amount: split.amount,\n      unit: this.unit,\n      ...data ?? {}\n    }, (pr) => {\n      this.emit(\"ln_invoice\", {\n        pr,\n        amount: split.amount,\n        recipientPubkey: split.pubkey,\n        unit: this.unit,\n        type: \"nip61\"\n      });\n    });\n    d3(\"NIP-61 Zap result: %o\", ret);\n    if (ret instanceof Error) {\n      return ret;\n    } else if (ret) {\n      const { proofs, mint } = ret;\n      if (!proofs || !mint)\n        throw new Error(\n          \"Invalid zap confirmation: missing proofs or mint: \" + ret\n        );\n      const relays = await this.relays(split.pubkey);\n      const relaySet = NDKRelaySet.fromRelayUrls(relays, this.ndk);\n      const nutzap = new NDKNutzap(this.ndk);\n      nutzap.tags = [...nutzap.tags, ...this.tags || []];\n      nutzap.proofs = proofs;\n      nutzap.mint = mint;\n      nutzap.target = this.target;\n      nutzap.comment = this.comment;\n      nutzap.unit = this.unit;\n      nutzap.recipientPubkey = split.pubkey;\n      await nutzap.sign(this.signer);\n      nutzap.publish(relaySet);\n      return nutzap;\n    }\n  }\n  /**\n   * Get the zap methods available for the recipient and initiates the zap\n   * in the desired method.\n   * @param split \n   * @param methods - The methods to try, if not provided, all methods will be tried.\n   * @returns \n   */\n  async zapSplit(split, methods) {\n    const recipient = this.ndk.getUser({ pubkey: split.pubkey });\n    let zapMethods = await recipient.getZapInfo(2500);\n    let retVal;\n    const canFallbackToNip61 = this.nutzapAsFallback && this.cashuPay;\n    if (zapMethods.size === 0 && !canFallbackToNip61) throw new Error(\"No zap method available for recipient and NIP-61 fallback is disabled\");\n    const nip61Fallback = async () => {\n      if (!this.nutzapAsFallback) return;\n      const relayLists = await getRelayListForUsers([split.pubkey], this.ndk);\n      let relayUrls = relayLists.get(split.pubkey)?.readRelayUrls;\n      relayUrls = this.ndk.pool.connectedRelays().map((r) => r.url);\n      return await this.zapNip61(split, {\n        // use the user's relay list\n        relays: relayUrls,\n        // lock to the user's actual pubkey\n        p2pk: split.pubkey,\n        // allow intramint fallback\n        allowIntramintFallback: !!canFallbackToNip61\n      });\n    };\n    const canUseNip61 = !methods || methods.includes(\"nip61\");\n    const canUseNip57 = !methods || methods.includes(\"nip57\");\n    const nip61Method = zapMethods.get(\"nip61\");\n    if (nip61Method && canUseNip61) {\n      try {\n        retVal = await this.zapNip61(split, nip61Method);\n        if (retVal instanceof NDKNutzap) return retVal;\n      } catch (e) {\n        this.emit(\"notice\", `NIP-61 attempt failed: ${e.message}`);\n      }\n    }\n    const nip57Method = zapMethods.get(\"nip57\");\n    if (nip57Method && canUseNip57) {\n      try {\n        retVal = await this.zapNip57(split, nip57Method);\n        if (!(retVal instanceof Error)) return retVal;\n      } catch (e) {\n        this.emit(\"notice\", `NIP-57 attempt failed: ${e.message}`);\n      }\n    }\n    if (canFallbackToNip61) {\n      retVal = await nip61Fallback();\n      if (retVal instanceof Error) throw retVal;\n      return retVal;\n    } else {\n      this.emit(\"notice\", \"Zap methods exhausted and there was no fallback to NIP-61\");\n    }\n    if (retVal instanceof Error) throw retVal;\n    return retVal;\n  }\n  /**\n   * Gets a bolt11 for a nip57 zap\n   * @param event\n   * @param amount\n   * @param zapEndpoint\n   * @returns\n   */\n  async getLnInvoice(zapRequest, amount, data) {\n    const zapEndpoint = data.callback;\n    const eventPayload = JSON.stringify(zapRequest.rawEvent());\n    d3(\n      `Fetching invoice from ${zapEndpoint}?` + new URLSearchParams({\n        amount: amount.toString(),\n        nostr: eventPayload\n      })\n    );\n    const url = new URL(zapEndpoint);\n    url.searchParams.append(\"amount\", amount.toString());\n    url.searchParams.append(\"nostr\", eventPayload);\n    d3(`Fetching invoice from ${url.toString()}`);\n    const response = await fetch(url.toString());\n    d3(`Got response from zap endpoint: ${zapEndpoint}`, { status: response.status });\n    if (response.status !== 200) {\n      d3(`Received non-200 status from zap endpoint: ${zapEndpoint}`, {\n        status: response.status,\n        amount,\n        nostr: eventPayload\n      });\n      const text = await response.text();\n      throw new Error(`Unable to fetch zap endpoint ${zapEndpoint}: ${text}`);\n    }\n    const body = await response.json();\n    return body.pr;\n  }\n  getZapSplits() {\n    if (this.target instanceof NDKUser) {\n      return [\n        {\n          pubkey: this.target.pubkey,\n          amount: this.amount\n        }\n      ];\n    }\n    const zapTags = this.target.getMatchingTags(\"zap\");\n    if (zapTags.length === 0) {\n      return [\n        {\n          pubkey: this.target.pubkey,\n          amount: this.amount\n        }\n      ];\n    }\n    const splits = [];\n    const total = zapTags.reduce((acc, tag) => acc + parseInt(tag[2]), 0);\n    for (const tag of zapTags) {\n      const pubkey = tag[1];\n      const amount = Math.floor(parseInt(tag[2]) / total * this.amount);\n      splits.push({ pubkey, amount });\n    }\n    return splits;\n  }\n  /**\n   * Gets the zap method that should be used to zap a pubbkey\n   * @param ndk\n   * @param pubkey\n   * @returns\n   */\n  async getZapMethods(ndk, recipient, timeout = 2500) {\n    const user = ndk.getUser({ pubkey: recipient });\n    return await user.getZapInfo(timeout);\n  }\n  /**\n   * @returns the relays to use for the zap request\n   */\n  async relays(pubkey) {\n    let r = [];\n    if (this.ndk?.activeUser) {\n      const relayLists = await getRelayListForUsers(\n        [this.ndk.activeUser.pubkey, pubkey],\n        this.ndk\n      );\n      const relayScores = /* @__PURE__ */ new Map();\n      for (const relayList of relayLists.values()) {\n        for (const url of relayList.readRelayUrls) {\n          const score = relayScores.get(url) || 0;\n          relayScores.set(url, score + 1);\n        }\n      }\n      r = Array.from(relayScores.entries()).sort((a, b) => b[1] - a[1]).map(([url]) => url).slice(0, this.maxRelays);\n    }\n    if (this.ndk?.pool?.permanentAndConnectedRelays().length) {\n      r = this.ndk.pool.permanentAndConnectedRelays().map((relay) => relay.url);\n    }\n    if (!r.length) {\n      r = [];\n    }\n    return r;\n  }\n};\n\n// src/utils/filter.ts\nfunction matchFilter(filter, event) {\n  if (filter.ids && filter.ids.indexOf(event.id) === -1) {\n    return false;\n  }\n  if (filter.kinds && filter.kinds.indexOf(event.kind) === -1) {\n    return false;\n  }\n  if (filter.authors && filter.authors.indexOf(event.pubkey) === -1) {\n    return false;\n  }\n  for (let f in filter) {\n    if (f[0] === \"#\") {\n      let tagName = f.slice(1);\n      if (tagName === \"t\") {\n        let values = filter[`#${tagName}`]?.map((v) => v.toLowerCase());\n        if (values && !event.tags.find(([t, v]) => t === tagName && values.indexOf(v.toLowerCase()) !== -1)) return false;\n      } else {\n        let values = filter[`#${tagName}`];\n        if (values && !event.tags.find(([t, v]) => t === tagName && values.indexOf(v) !== -1)) return false;\n      }\n    }\n  }\n  if (filter.since && event.created_at < filter.since) return false;\n  if (filter.until && event.created_at > filter.until) return false;\n  return true;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGVBQWU7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUMwQjtBQUNXOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04seUNBQXlDLGtCQUFrQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxrQkFBa0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsR0FBRztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0Esc0NBQXNDLGtCQUFrQixJQUFJLGNBQWM7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNk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QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGlLQUFpSztBQUNqTTtBQUNBO0FBQ0EsOENBQThDLHVCQUF1QjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFVBQVUsSUFBSSxJQUFJO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msd0NBQXdDO0FBQzlFO0FBQ0E7QUFDQSxvQ0FBb0Msd0JBQXdCO0FBQzVE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QUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTixtQkFBbUIsNERBQU07QUFDekIsa0JBQWtCLDREQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDREQUFNO0FBQzFCLFNBQVMsK0RBQVU7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsK0NBQWE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MscUJBQXFCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGFBQWEsSUFBSSxTQUFTO0FBQy9DO0FBQ0E7QUFDQSxzQkFBc0IscUJBQXFCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixxQkFBcUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHlCQUF5QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsd0NBQXdDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixxQkFBcUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELEtBQUs7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QixlQUFlLHFCQUFxQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0IsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQixlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGFBQWE7QUFDbkMsc0JBQXNCLFFBQVE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViwwQ0FBMEMsYUFBYTtBQUN2RDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsdUJBQXVCLEtBQUssR0FBRyxPQUFPO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxrQ0FBTTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRCx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9CQUFvQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGlDQUFpQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsK0NBQWE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxtQ0FBbUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsNEhBQTRIO0FBQzNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSx1Q0FBdUM7QUFDN0MsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsUUFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLCtCQUErQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxrQ0FBTTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixpQkFBaUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsaUJBQWlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsY0FBYztBQUNuRTtBQUNBO0FBQ0Esb0RBQW9ELGNBQWM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQzJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsa0NBQU07QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsaUJBQWlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1DQUFtQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsV0FBVztBQUN2RDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGNBQWMsZUFBZTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsc0JBQXNCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1Isc0RBQXNELFVBQVU7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1Isc0RBQXNELFVBQVU7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFlBQVk7QUFDM0M7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxlQUFlO0FBQy9DO0FBQ0EsMENBQTBDLFlBQVksS0FBSyx5QkFBeUI7QUFDcEY7QUFDQSx1REFBdUQsWUFBWTtBQUNuRTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxzREFBc0QsWUFBWSxJQUFJLEtBQUs7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixtQkFBbUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxRQUFRO0FBQ3hDO0FBQ0EsUUFBUTtBQUNSLGdDQUFnQyxRQUFRO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF5R0UiLCJzb3VyY2VzIjpbIi9ob21lL2xmZy9HaXQvTWFkdHJpcHMvbm9kZV9tb2R1bGVzL0Bub3N0ci1kZXYta2l0L25kay9kaXN0L2luZGV4Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvZXZlbnRzL2tpbmRzL2luZGV4LnRzXG52YXIgTkRLS2luZCA9IC8qIEBfX1BVUkVfXyAqLyAoKE5ES0tpbmQyKSA9PiB7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiTWV0YWRhdGFcIl0gPSAwXSA9IFwiTWV0YWRhdGFcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJUZXh0XCJdID0gMV0gPSBcIlRleHRcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJSZWNvbW1lbmRSZWxheVwiXSA9IDJdID0gXCJSZWNvbW1lbmRSZWxheVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkNvbnRhY3RzXCJdID0gM10gPSBcIkNvbnRhY3RzXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiRW5jcnlwdGVkRGlyZWN0TWVzc2FnZVwiXSA9IDRdID0gXCJFbmNyeXB0ZWREaXJlY3RNZXNzYWdlXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiRXZlbnREZWxldGlvblwiXSA9IDVdID0gXCJFdmVudERlbGV0aW9uXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiUmVwb3N0XCJdID0gNl0gPSBcIlJlcG9zdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIlJlYWN0aW9uXCJdID0gN10gPSBcIlJlYWN0aW9uXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQmFkZ2VBd2FyZFwiXSA9IDhdID0gXCJCYWRnZUF3YXJkXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiR3JvdXBDaGF0XCJdID0gOV0gPSBcIkdyb3VwQ2hhdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkdyb3VwTm90ZVwiXSA9IDExXSA9IFwiR3JvdXBOb3RlXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiR3JvdXBSZXBseVwiXSA9IDEyXSA9IFwiR3JvdXBSZXBseVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkdpZnRXcmFwU2VhbFwiXSA9IDEzXSA9IFwiR2lmdFdyYXBTZWFsXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiUHJpdmF0ZURpcmVjdE1lc3NhZ2VcIl0gPSAxNF0gPSBcIlByaXZhdGVEaXJlY3RNZXNzYWdlXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiSW1hZ2VcIl0gPSAyMF0gPSBcIkltYWdlXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiVmFuaXNoXCJdID0gNjJdID0gXCJWYW5pc2hcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJHaWZ0V3JhcFwiXSA9IDEwNTldID0gXCJHaWZ0V3JhcFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkdlbmVyaWNSZXBvc3RcIl0gPSAxNl0gPSBcIkdlbmVyaWNSZXBvc3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJDaGFubmVsQ3JlYXRpb25cIl0gPSA0MF0gPSBcIkNoYW5uZWxDcmVhdGlvblwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkNoYW5uZWxNZXRhZGF0YVwiXSA9IDQxXSA9IFwiQ2hhbm5lbE1ldGFkYXRhXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQ2hhbm5lbE1lc3NhZ2VcIl0gPSA0Ml0gPSBcIkNoYW5uZWxNZXNzYWdlXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQ2hhbm5lbEhpZGVNZXNzYWdlXCJdID0gNDNdID0gXCJDaGFubmVsSGlkZU1lc3NhZ2VcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJDaGFubmVsTXV0ZVVzZXJcIl0gPSA0NF0gPSBcIkNoYW5uZWxNdXRlVXNlclwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkdlbmVyaWNSZXBseVwiXSA9IDExMTFdID0gXCJHZW5lcmljUmVwbHlcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJNZWRpYVwiXSA9IDEwNjNdID0gXCJNZWRpYVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIlJlcG9ydFwiXSA9IDE5ODRdID0gXCJSZXBvcnRcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJMYWJlbFwiXSA9IDE5ODVdID0gXCJMYWJlbFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkRWTVJlcVRleHRFeHRyYWN0aW9uXCJdID0gNWUzXSA9IFwiRFZNUmVxVGV4dEV4dHJhY3Rpb25cIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJEVk1SZXFUZXh0U3VtbWFyaXphdGlvblwiXSA9IDUwMDFdID0gXCJEVk1SZXFUZXh0U3VtbWFyaXphdGlvblwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkRWTVJlcVRleHRUcmFuc2xhdGlvblwiXSA9IDUwMDJdID0gXCJEVk1SZXFUZXh0VHJhbnNsYXRpb25cIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJEVk1SZXFUZXh0R2VuZXJhdGlvblwiXSA9IDUwNTBdID0gXCJEVk1SZXFUZXh0R2VuZXJhdGlvblwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkRWTVJlcUltYWdlR2VuZXJhdGlvblwiXSA9IDUxMDBdID0gXCJEVk1SZXFJbWFnZUdlbmVyYXRpb25cIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJEVk1SZXFUZXh0VG9TcGVlY2hcIl0gPSA1MjUwXSA9IFwiRFZNUmVxVGV4dFRvU3BlZWNoXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiRFZNUmVxRGlzY292ZXJ5Tm9zdHJDb250ZW50XCJdID0gNTMwMF0gPSBcIkRWTVJlcURpc2NvdmVyeU5vc3RyQ29udGVudFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkRWTVJlcURpc2NvdmVyeU5vc3RyUGVvcGxlXCJdID0gNTMwMV0gPSBcIkRWTVJlcURpc2NvdmVyeU5vc3RyUGVvcGxlXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiRFZNUmVxVGltZXN0YW1waW5nXCJdID0gNTkwMF0gPSBcIkRWTVJlcVRpbWVzdGFtcGluZ1wiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkRWTUV2ZW50U2NoZWR1bGVcIl0gPSA1OTA1XSA9IFwiRFZNRXZlbnRTY2hlZHVsZVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkRWTUpvYkZlZWRiYWNrXCJdID0gN2UzXSA9IFwiRFZNSm9iRmVlZGJhY2tcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJTdWJzY3JpYmVcIl0gPSA3MDAxXSA9IFwiU3Vic2NyaWJlXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiVW5zdWJzY3JpYmVcIl0gPSA3MDAyXSA9IFwiVW5zdWJzY3JpYmVcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJTdWJzY3JpcHRpb25SZWNlaXB0XCJdID0gNzAwM10gPSBcIlN1YnNjcmlwdGlvblJlY2VpcHRcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJDYXNodVJlc2VydmVcIl0gPSA3MzczXSA9IFwiQ2FzaHVSZXNlcnZlXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQ2FzaHVRdW90ZVwiXSA9IDczNzRdID0gXCJDYXNodVF1b3RlXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQ2FzaHVUb2tlblwiXSA9IDczNzVdID0gXCJDYXNodVRva2VuXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQ2FzaHVXYWxsZXRUeFwiXSA9IDczNzZdID0gXCJDYXNodVdhbGxldFR4XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiR3JvdXBBZG1pbkFkZFVzZXJcIl0gPSA5ZTNdID0gXCJHcm91cEFkbWluQWRkVXNlclwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkdyb3VwQWRtaW5SZW1vdmVVc2VyXCJdID0gOTAwMV0gPSBcIkdyb3VwQWRtaW5SZW1vdmVVc2VyXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiR3JvdXBBZG1pbkVkaXRNZXRhZGF0YVwiXSA9IDkwMDJdID0gXCJHcm91cEFkbWluRWRpdE1ldGFkYXRhXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiR3JvdXBBZG1pbkVkaXRTdGF0dXNcIl0gPSA5MDA2XSA9IFwiR3JvdXBBZG1pbkVkaXRTdGF0dXNcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJHcm91cEFkbWluQ3JlYXRlR3JvdXBcIl0gPSA5MDA3XSA9IFwiR3JvdXBBZG1pbkNyZWF0ZUdyb3VwXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiR3JvdXBBZG1pblJlcXVlc3RKb2luXCJdID0gOTAyMV0gPSBcIkdyb3VwQWRtaW5SZXF1ZXN0Sm9pblwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIk11dGVMaXN0XCJdID0gMWU0XSA9IFwiTXV0ZUxpc3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJQaW5MaXN0XCJdID0gMTAwMDFdID0gXCJQaW5MaXN0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiUmVsYXlMaXN0XCJdID0gMTAwMDJdID0gXCJSZWxheUxpc3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJCb29rbWFya0xpc3RcIl0gPSAxMDAwM10gPSBcIkJvb2ttYXJrTGlzdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkNvbW11bml0eUxpc3RcIl0gPSAxMDAwNF0gPSBcIkNvbW11bml0eUxpc3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJQdWJsaWNDaGF0TGlzdFwiXSA9IDEwMDA1XSA9IFwiUHVibGljQ2hhdExpc3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJCbG9ja1JlbGF5TGlzdFwiXSA9IDEwMDA2XSA9IFwiQmxvY2tSZWxheUxpc3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJTZWFyY2hSZWxheUxpc3RcIl0gPSAxMDAwN10gPSBcIlNlYXJjaFJlbGF5TGlzdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIlNpbXBsZUdyb3VwTGlzdFwiXSA9IDEwMDA5XSA9IFwiU2ltcGxlR3JvdXBMaXN0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiSW50ZXJlc3RMaXN0XCJdID0gMTAwMTVdID0gXCJJbnRlcmVzdExpc3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJDYXNodU1pbnRMaXN0XCJdID0gMTAwMTldID0gXCJDYXNodU1pbnRMaXN0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiRW1vamlMaXN0XCJdID0gMTAwMzBdID0gXCJFbW9qaUxpc3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJEaXJlY3RNZXNzYWdlUmVjZWl2ZVJlbGF5TGlzdFwiXSA9IDEwMDUwXSA9IFwiRGlyZWN0TWVzc2FnZVJlY2VpdmVSZWxheUxpc3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJCbG9zc29tTGlzdFwiXSA9IDEwMDYzXSA9IFwiQmxvc3NvbUxpc3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJOb3N0cldhbGV0Q29ubmVjdEluZm9cIl0gPSAxMzE5NF0gPSBcIk5vc3RyV2FsZXRDb25uZWN0SW5mb1wiO1xuICBOREtLaW5kMltOREtLaW5kMltcIlRpZXJMaXN0XCJdID0gMTdlM10gPSBcIlRpZXJMaXN0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQ2FzaHVXYWxsZXRcIl0gPSAxNzM3NV0gPSBcIkNhc2h1V2FsbGV0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiRm9sbG93U2V0XCJdID0gM2U0XSA9IFwiRm9sbG93U2V0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQ2F0ZWdvcml6ZWRQZW9wbGVMaXN0XCJdID0gM2U0IC8qIEZvbGxvd1NldCAqL10gPSBcIkNhdGVnb3JpemVkUGVvcGxlTGlzdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkNhdGVnb3JpemVkQm9va21hcmtMaXN0XCJdID0gMzAwMDFdID0gXCJDYXRlZ29yaXplZEJvb2ttYXJrTGlzdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIlJlbGF5U2V0XCJdID0gMzAwMDJdID0gXCJSZWxheVNldFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkNhdGVnb3JpemVkUmVsYXlMaXN0XCJdID0gMzAwMDIgLyogUmVsYXlTZXQgKi9dID0gXCJDYXRlZ29yaXplZFJlbGF5TGlzdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkJvb2ttYXJrU2V0XCJdID0gMzAwMDNdID0gXCJCb29rbWFya1NldFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkN1cmF0aW9uU2V0XCJdID0gMzAwMDRdID0gXCJDdXJhdGlvblNldFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkFydGljbGVDdXJhdGlvblNldFwiXSA9IDMwMDA0XSA9IFwiQXJ0aWNsZUN1cmF0aW9uU2V0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiVmlkZW9DdXJhdGlvblNldFwiXSA9IDMwMDA1XSA9IFwiVmlkZW9DdXJhdGlvblNldFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkltYWdlQ3VyYXRpb25TZXRcIl0gPSAzMDAwNl0gPSBcIkltYWdlQ3VyYXRpb25TZXRcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJJbnRlcmVzdFNldFwiXSA9IDMwMDE1XSA9IFwiSW50ZXJlc3RTZXRcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJJbnRlcmVzdHNMaXN0XCJdID0gMzAwMTUgLyogSW50ZXJlc3RTZXQgKi9dID0gXCJJbnRlcmVzdHNMaXN0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiRW1vamlTZXRcIl0gPSAzMDAzMF0gPSBcIkVtb2ppU2V0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiTW9kdWxhckFydGljbGVcIl0gPSAzMDA0MF0gPSBcIk1vZHVsYXJBcnRpY2xlXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiTW9kdWxhckFydGljbGVJdGVtXCJdID0gMzAwNDFdID0gXCJNb2R1bGFyQXJ0aWNsZUl0ZW1cIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJXaWtpXCJdID0gMzA4MThdID0gXCJXaWtpXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiRHJhZnRcIl0gPSAzMTIzNF0gPSBcIkRyYWZ0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiU3Vic2NyaXB0aW9uVGllclwiXSA9IDM3MDAxXSA9IFwiU3Vic2NyaXB0aW9uVGllclwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkVjYXNoTWludFJlY29tbWVuZGF0aW9uXCJdID0gMzhlM10gPSBcIkVjYXNoTWludFJlY29tbWVuZGF0aW9uXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiSGlnaGxpZ2h0U2V0XCJdID0gMzk4MDJdID0gXCJIaWdobGlnaHRTZXRcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJDYXRlZ29yaXplZEhpZ2hsaWdodExpc3RcIl0gPSAzOTgwMiAvKiBIaWdobGlnaHRTZXQgKi9dID0gXCJDYXRlZ29yaXplZEhpZ2hsaWdodExpc3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJOdXR6YXBcIl0gPSA5MzIxXSA9IFwiTnV0emFwXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiWmFwUmVxdWVzdFwiXSA9IDk3MzRdID0gXCJaYXBSZXF1ZXN0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiWmFwXCJdID0gOTczNV0gPSBcIlphcFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkhpZ2hsaWdodFwiXSA9IDk4MDJdID0gXCJIaWdobGlnaHRcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJDbGllbnRBdXRoXCJdID0gMjIyNDJdID0gXCJDbGllbnRBdXRoXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiTm9zdHJXYWxsZXRDb25uZWN0UmVxXCJdID0gMjMxOTRdID0gXCJOb3N0cldhbGxldENvbm5lY3RSZXFcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJOb3N0cldhbGxldENvbm5lY3RSZXNcIl0gPSAyMzE5NV0gPSBcIk5vc3RyV2FsbGV0Q29ubmVjdFJlc1wiO1xuICBOREtLaW5kMltOREtLaW5kMltcIk5vc3RyQ29ubmVjdFwiXSA9IDI0MTMzXSA9IFwiTm9zdHJDb25uZWN0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQmxvc3NvbVVwbG9hZFwiXSA9IDI0MjQyXSA9IFwiQmxvc3NvbVVwbG9hZFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkh0dHBBdXRoXCJdID0gMjcyMzVdID0gXCJIdHRwQXV0aFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIlByb2ZpbGVCYWRnZVwiXSA9IDMwMDA4XSA9IFwiUHJvZmlsZUJhZGdlXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQmFkZ2VEZWZpbml0aW9uXCJdID0gMzAwMDldID0gXCJCYWRnZURlZmluaXRpb25cIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJNYXJrZXRTdGFsbFwiXSA9IDMwMDE3XSA9IFwiTWFya2V0U3RhbGxcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJNYXJrZXRQcm9kdWN0XCJdID0gMzAwMThdID0gXCJNYXJrZXRQcm9kdWN0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQXJ0aWNsZVwiXSA9IDMwMDIzXSA9IFwiQXJ0aWNsZVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkFwcFNwZWNpZmljRGF0YVwiXSA9IDMwMDc4XSA9IFwiQXBwU3BlY2lmaWNEYXRhXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQ2xhc3NpZmllZFwiXSA9IDMwNDAyXSA9IFwiQ2xhc3NpZmllZFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkhvcml6b250YWxWaWRlb1wiXSA9IDM0MjM1XSA9IFwiSG9yaXpvbnRhbFZpZGVvXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiVmVydGljYWxWaWRlb1wiXSA9IDM0MjM2XSA9IFwiVmVydGljYWxWaWRlb1wiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkxlZ2FjeUNhc2h1V2FsbGV0XCJdID0gMzczNzVdID0gXCJMZWdhY3lDYXNodVdhbGxldFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkdyb3VwTWV0YWRhdGFcIl0gPSAzOWUzXSA9IFwiR3JvdXBNZXRhZGF0YVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkdyb3VwQWRtaW5zXCJdID0gMzkwMDFdID0gXCJHcm91cEFkbWluc1wiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkdyb3VwTWVtYmVyc1wiXSA9IDM5MDAyXSA9IFwiR3JvdXBNZW1iZXJzXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQXBwUmVjb21tZW5kYXRpb25cIl0gPSAzMTk4OV0gPSBcIkFwcFJlY29tbWVuZGF0aW9uXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQXBwSGFuZGxlclwiXSA9IDMxOTkwXSA9IFwiQXBwSGFuZGxlclwiO1xuICByZXR1cm4gTkRLS2luZDI7XG59KShOREtLaW5kIHx8IHt9KTtcbnZhciBOREtMaXN0S2luZHMgPSBbXG4gIDFlNCAvKiBNdXRlTGlzdCAqLyxcbiAgMTAwMDEgLyogUGluTGlzdCAqLyxcbiAgMTAwMDIgLyogUmVsYXlMaXN0ICovLFxuICAxMDAwMyAvKiBCb29rbWFya0xpc3QgKi8sXG4gIDEwMDA0IC8qIENvbW11bml0eUxpc3QgKi8sXG4gIDEwMDA1IC8qIFB1YmxpY0NoYXRMaXN0ICovLFxuICAxMDAwNiAvKiBCbG9ja1JlbGF5TGlzdCAqLyxcbiAgMTAwMDcgLyogU2VhcmNoUmVsYXlMaXN0ICovLFxuICAxMDAxNSAvKiBJbnRlcmVzdExpc3QgKi8sXG4gIDEwMDMwIC8qIEVtb2ppTGlzdCAqLyxcbiAgMTAwNTAgLyogRGlyZWN0TWVzc2FnZVJlY2VpdmVSZWxheUxpc3QgKi8sXG4gIDNlNCAvKiBGb2xsb3dTZXQgKi8sXG4gIDMwMDAzIC8qIEJvb2ttYXJrU2V0ICovLFxuICAzMDAwMSAvKiBDYXRlZ29yaXplZEJvb2ttYXJrTGlzdCAqLyxcbiAgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgMzAwMDIgLyogUmVsYXlTZXQgKi8sXG4gIDMwMDA0IC8qIEFydGljbGVDdXJhdGlvblNldCAqLyxcbiAgMzAwMDUgLyogVmlkZW9DdXJhdGlvblNldCAqLyxcbiAgMzAwMTUgLyogSW50ZXJlc3RTZXQgKi8sXG4gIDMwMDMwIC8qIEVtb2ppU2V0ICovLFxuICAzOTgwMiAvKiBIaWdobGlnaHRTZXQgKi9cbl07XG5cbi8vIHNyYy9ldmVudHMvaW5kZXgudHNcbmltcG9ydCB7IEV2ZW50RW1pdHRlciBhcyBFdmVudEVtaXR0ZXIyIH0gZnJvbSBcInRzZWVwXCI7XG5cbi8vIHNyYy9vdXRib3gvd3JpdGUudHNcbmZ1bmN0aW9uIGdldFJlbGF5c0ZvclN5bmMobmRrLCBhdXRob3IsIHR5cGUgPSBcIndyaXRlXCIpIHtcbiAgaWYgKCFuZGsub3V0Ym94VHJhY2tlcikgcmV0dXJuIHZvaWQgMDtcbiAgY29uc3QgaXRlbSA9IG5kay5vdXRib3hUcmFja2VyLmRhdGEuZ2V0KGF1dGhvcik7XG4gIGlmICghaXRlbSkgcmV0dXJuIHZvaWQgMDtcbiAgaWYgKHR5cGUgPT09IFwid3JpdGVcIikge1xuICAgIHJldHVybiBpdGVtLndyaXRlUmVsYXlzO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBpdGVtLnJlYWRSZWxheXM7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGdldFdyaXRlUmVsYXlzRm9yKG5kaywgYXV0aG9yLCB0eXBlID0gXCJ3cml0ZVwiKSB7XG4gIGlmICghbmRrLm91dGJveFRyYWNrZXIpIHJldHVybiB2b2lkIDA7XG4gIGlmICghbmRrLm91dGJveFRyYWNrZXIuZGF0YS5oYXMoYXV0aG9yKSkge1xuICAgIGF3YWl0IG5kay5vdXRib3hUcmFja2VyLnRyYWNrVXNlcnMoW2F1dGhvcl0pO1xuICB9XG4gIHJldHVybiBnZXRSZWxheXNGb3JTeW5jKG5kaywgYXV0aG9yLCB0eXBlKTtcbn1cblxuLy8gc3JjL291dGJveC9yZWxheS1yYW5raW5nLnRzXG5mdW5jdGlvbiBnZXRUb3BSZWxheXNGb3JBdXRob3JzKG5kaywgYXV0aG9ycykge1xuICBjb25zdCByZWxheXNXaXRoQ291bnQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBhdXRob3JzLmZvckVhY2goKGF1dGhvcikgPT4ge1xuICAgIGNvbnN0IHdyaXRlUmVsYXlzID0gZ2V0UmVsYXlzRm9yU3luYyhuZGssIGF1dGhvcik7XG4gICAgaWYgKHdyaXRlUmVsYXlzKSB7XG4gICAgICB3cml0ZVJlbGF5cy5mb3JFYWNoKChyZWxheSkgPT4ge1xuICAgICAgICBjb25zdCBjb3VudCA9IHJlbGF5c1dpdGhDb3VudC5nZXQocmVsYXkpIHx8IDA7XG4gICAgICAgIHJlbGF5c1dpdGhDb3VudC5zZXQocmVsYXksIGNvdW50ICsgMSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBzb3J0ZWRSZWxheXMgPSBBcnJheS5mcm9tKHJlbGF5c1dpdGhDb3VudC5lbnRyaWVzKCkpLnNvcnQoKGEsIGIpID0+IGJbMV0gLSBhWzFdKTtcbiAgcmV0dXJuIHNvcnRlZFJlbGF5cy5tYXAoKGVudHJ5KSA9PiBlbnRyeVswXSk7XG59XG5cbi8vIHNyYy9vdXRib3gvaW5kZXgudHNcbmZ1bmN0aW9uIGdldEFsbFJlbGF5c0ZvckFsbFB1YmtleXMobmRrLCBwdWJrZXlzLCB0eXBlID0gXCJyZWFkXCIpIHtcbiAgY29uc3QgcHVia2V5c1RvUmVsYXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgYXV0aG9yc01pc3NpbmdSZWxheXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBwdWJrZXlzLmZvckVhY2goKHB1YmtleSkgPT4ge1xuICAgIGNvbnN0IHJlbGF5cyA9IGdldFJlbGF5c0ZvclN5bmMobmRrLCBwdWJrZXksIHR5cGUpO1xuICAgIGlmIChyZWxheXMgJiYgcmVsYXlzLnNpemUgPiAwKSB7XG4gICAgICByZWxheXMuZm9yRWFjaCgocmVsYXkpID0+IHtcbiAgICAgICAgY29uc3QgcHVia2V5c0luUmVsYXkgPSBwdWJrZXlzVG9SZWxheXMuZ2V0KHJlbGF5KSB8fCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgICBwdWJrZXlzSW5SZWxheS5hZGQocHVia2V5KTtcbiAgICAgIH0pO1xuICAgICAgcHVia2V5c1RvUmVsYXlzLnNldChwdWJrZXksIHJlbGF5cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF1dGhvcnNNaXNzaW5nUmVsYXlzLmFkZChwdWJrZXkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB7IHB1YmtleXNUb1JlbGF5cywgYXV0aG9yc01pc3NpbmdSZWxheXMgfTtcbn1cbmZ1bmN0aW9uIGNob29zZVJlbGF5Q29tYmluYXRpb25Gb3JQdWJrZXlzKG5kaywgcHVia2V5cywgdHlwZSwgeyBjb3VudCwgcHJlZmVycmVkUmVsYXlzIH0gPSB7fSkge1xuICBjb3VudCA/Pz0gMjtcbiAgcHJlZmVycmVkUmVsYXlzID8/PSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBjb25zdCBwb29sID0gbmRrLnBvb2w7XG4gIGNvbnN0IGNvbm5lY3RlZFJlbGF5cyA9IHBvb2wuY29ubmVjdGVkUmVsYXlzKCk7XG4gIGNvbm5lY3RlZFJlbGF5cy5mb3JFYWNoKChyZWxheSkgPT4ge1xuICAgIHByZWZlcnJlZFJlbGF5cy5hZGQocmVsYXkudXJsKTtcbiAgfSk7XG4gIGNvbnN0IHJlbGF5VG9BdXRob3JzTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgeyBwdWJrZXlzVG9SZWxheXMsIGF1dGhvcnNNaXNzaW5nUmVsYXlzIH0gPSBnZXRBbGxSZWxheXNGb3JBbGxQdWJrZXlzKG5kaywgcHVia2V5cywgdHlwZSk7XG4gIGNvbnN0IHNvcnRlZFJlbGF5cyA9IGdldFRvcFJlbGF5c0ZvckF1dGhvcnMobmRrLCBwdWJrZXlzKTtcbiAgY29uc3QgYWRkQXV0aG9yVG9SZWxheSA9IChhdXRob3IsIHJlbGF5KSA9PiB7XG4gICAgY29uc3QgYXV0aG9yc0luUmVsYXkgPSByZWxheVRvQXV0aG9yc01hcC5nZXQocmVsYXkpIHx8IFtdO1xuICAgIGF1dGhvcnNJblJlbGF5LnB1c2goYXV0aG9yKTtcbiAgICByZWxheVRvQXV0aG9yc01hcC5zZXQocmVsYXksIGF1dGhvcnNJblJlbGF5KTtcbiAgfTtcbiAgZm9yIChjb25zdCBbYXV0aG9yLCBhdXRob3JSZWxheXNdIG9mIHB1YmtleXNUb1JlbGF5cy5lbnRyaWVzKCkpIHtcbiAgICBsZXQgbWlzc2luZ1JlbGF5Q291bnQgPSBjb3VudDtcbiAgICBmb3IgKGNvbnN0IHJlbGF5IG9mIGNvbm5lY3RlZFJlbGF5cykge1xuICAgICAgaWYgKGF1dGhvclJlbGF5cy5oYXMocmVsYXkudXJsKSkge1xuICAgICAgICBhZGRBdXRob3JUb1JlbGF5KGF1dGhvciwgcmVsYXkudXJsKTtcbiAgICAgICAgbWlzc2luZ1JlbGF5Q291bnQtLTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBhdXRob3JSZWxheSBvZiBhdXRob3JSZWxheXMpIHtcbiAgICAgIGlmIChyZWxheVRvQXV0aG9yc01hcC5oYXMoYXV0aG9yUmVsYXkpKSB7XG4gICAgICAgIGFkZEF1dGhvclRvUmVsYXkoYXV0aG9yLCBhdXRob3JSZWxheSk7XG4gICAgICAgIG1pc3NpbmdSZWxheUNvdW50LS07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtaXNzaW5nUmVsYXlDb3VudCA8PSAwKSBjb250aW51ZTtcbiAgICBmb3IgKGNvbnN0IHJlbGF5IG9mIHNvcnRlZFJlbGF5cykge1xuICAgICAgaWYgKG1pc3NpbmdSZWxheUNvdW50IDw9IDApIGJyZWFrO1xuICAgICAgaWYgKGF1dGhvclJlbGF5cy5oYXMocmVsYXkpKSB7XG4gICAgICAgIGFkZEF1dGhvclRvUmVsYXkoYXV0aG9yLCByZWxheSk7XG4gICAgICAgIG1pc3NpbmdSZWxheUNvdW50LS07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3QgYXV0aG9yIG9mIGF1dGhvcnNNaXNzaW5nUmVsYXlzKSB7XG4gICAgcG9vbC5wZXJtYW5lbnRBbmRDb25uZWN0ZWRSZWxheXMoKS5mb3JFYWNoKChyZWxheSkgPT4ge1xuICAgICAgY29uc3QgYXV0aG9yc0luUmVsYXkgPSByZWxheVRvQXV0aG9yc01hcC5nZXQocmVsYXkudXJsKSB8fCBbXTtcbiAgICAgIGF1dGhvcnNJblJlbGF5LnB1c2goYXV0aG9yKTtcbiAgICAgIHJlbGF5VG9BdXRob3JzTWFwLnNldChyZWxheS51cmwsIGF1dGhvcnNJblJlbGF5KTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVsYXlUb0F1dGhvcnNNYXA7XG59XG5cbi8vIHNyYy9vdXRib3gvcmVhZC93aXRoLWF1dGhvcnMudHNcbmZ1bmN0aW9uIGdldFJlbGF5c0ZvckZpbHRlcldpdGhBdXRob3JzKG5kaywgYXV0aG9ycywgcmVsYXlHb2FsUGVyQXV0aG9yID0gMikge1xuICByZXR1cm4gY2hvb3NlUmVsYXlDb21iaW5hdGlvbkZvclB1YmtleXMobmRrLCBhdXRob3JzLCBcIndyaXRlXCIsIHsgY291bnQ6IHJlbGF5R29hbFBlckF1dGhvciB9KTtcbn1cblxuLy8gc3JjL3V0aWxzL25vcm1hbGl6ZS11cmwudHNcbmZ1bmN0aW9uIHRyeU5vcm1hbGl6ZVJlbGF5VXJsKHVybCkge1xuICB0cnkge1xuICAgIHJldHVybiBub3JtYWxpemVSZWxheVVybCh1cmwpO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG59XG5mdW5jdGlvbiBub3JtYWxpemVSZWxheVVybCh1cmwpIHtcbiAgbGV0IHIgPSBub3JtYWxpemVVcmwodXJsLCB7XG4gICAgc3RyaXBBdXRoZW50aWNhdGlvbjogZmFsc2UsXG4gICAgc3RyaXBXV1c6IGZhbHNlLFxuICAgIHN0cmlwSGFzaDogdHJ1ZVxuICB9KTtcbiAgaWYgKCFyLmVuZHNXaXRoKFwiL1wiKSkge1xuICAgIHIgKz0gXCIvXCI7XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiBub3JtYWxpemUodXJscykge1xuICBjb25zdCBub3JtYWxpemVkID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgZm9yIChjb25zdCB1cmwgb2YgdXJscykge1xuICAgIHRyeSB7XG4gICAgICBub3JtYWxpemVkLmFkZChub3JtYWxpemVSZWxheVVybCh1cmwpKTtcbiAgICB9IGNhdGNoIHtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIEFycmF5LmZyb20obm9ybWFsaXplZCk7XG59XG52YXIgREFUQV9VUkxfREVGQVVMVF9NSU1FX1RZUEUgPSBcInRleHQvcGxhaW5cIjtcbnZhciBEQVRBX1VSTF9ERUZBVUxUX0NIQVJTRVQgPSBcInVzLWFzY2lpXCI7XG52YXIgdGVzdFBhcmFtZXRlciA9IChuYW1lLCBmaWx0ZXJzKSA9PiBmaWx0ZXJzLnNvbWUoKGZpbHRlcikgPT4gZmlsdGVyIGluc3RhbmNlb2YgUmVnRXhwID8gZmlsdGVyLnRlc3QobmFtZSkgOiBmaWx0ZXIgPT09IG5hbWUpO1xudmFyIHN1cHBvcnRlZFByb3RvY29scyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcImh0dHBzOlwiLCBcImh0dHA6XCIsIFwiZmlsZTpcIl0pO1xudmFyIGhhc0N1c3RvbVByb3RvY29sID0gKHVybFN0cmluZykgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHsgcHJvdG9jb2wgfSA9IG5ldyBVUkwodXJsU3RyaW5nKTtcbiAgICByZXR1cm4gcHJvdG9jb2wuZW5kc1dpdGgoXCI6XCIpICYmICFwcm90b2NvbC5pbmNsdWRlcyhcIi5cIikgJiYgIXN1cHBvcnRlZFByb3RvY29scy5oYXMocHJvdG9jb2wpO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG52YXIgbm9ybWFsaXplRGF0YVVSTCA9ICh1cmxTdHJpbmcsIHsgc3RyaXBIYXNoIH0pID0+IHtcbiAgY29uc3QgbWF0Y2ggPSAvXmRhdGE6KD88dHlwZT5bXixdKj8pLCg/PGRhdGE+W14jXSo/KSg/OiMoPzxoYXNoPi4qKSk/JC8uZXhlYyh1cmxTdHJpbmcpO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIFVSTDogJHt1cmxTdHJpbmd9YCk7XG4gIH1cbiAgbGV0IHR5cGUgPSBtYXRjaC5ncm91cHM/LnR5cGUgPz8gXCJcIjtcbiAgbGV0IGRhdGEgPSBtYXRjaC5ncm91cHM/LmRhdGEgPz8gXCJcIjtcbiAgbGV0IGhhc2ggPSBtYXRjaC5ncm91cHM/Lmhhc2ggPz8gXCJcIjtcbiAgY29uc3QgbWVkaWFUeXBlID0gdHlwZS5zcGxpdChcIjtcIik7XG4gIGhhc2ggPSBzdHJpcEhhc2ggPyBcIlwiIDogaGFzaDtcbiAgbGV0IGlzQmFzZTY0ID0gZmFsc2U7XG4gIGlmIChtZWRpYVR5cGVbbWVkaWFUeXBlLmxlbmd0aCAtIDFdID09PSBcImJhc2U2NFwiKSB7XG4gICAgbWVkaWFUeXBlLnBvcCgpO1xuICAgIGlzQmFzZTY0ID0gdHJ1ZTtcbiAgfVxuICBjb25zdCBtaW1lVHlwZSA9IG1lZGlhVHlwZS5zaGlmdCgpPy50b0xvd2VyQ2FzZSgpID8/IFwiXCI7XG4gIGNvbnN0IGF0dHJpYnV0ZXMgPSBtZWRpYVR5cGUubWFwKChhdHRyaWJ1dGUpID0+IHtcbiAgICBsZXQgW2tleSwgdmFsdWUgPSBcIlwiXSA9IGF0dHJpYnV0ZS5zcGxpdChcIj1cIikubWFwKChzdHJpbmcpID0+IHN0cmluZy50cmltKCkpO1xuICAgIGlmIChrZXkgPT09IFwiY2hhcnNldFwiKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAodmFsdWUgPT09IERBVEFfVVJMX0RFRkFVTFRfQ0hBUlNFVCkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGAke2tleX0ke3ZhbHVlID8gYD0ke3ZhbHVlfWAgOiBcIlwifWA7XG4gIH0pLmZpbHRlcihCb29sZWFuKTtcbiAgY29uc3Qgbm9ybWFsaXplZE1lZGlhVHlwZSA9IFsuLi5hdHRyaWJ1dGVzXTtcbiAgaWYgKGlzQmFzZTY0KSB7XG4gICAgbm9ybWFsaXplZE1lZGlhVHlwZS5wdXNoKFwiYmFzZTY0XCIpO1xuICB9XG4gIGlmIChub3JtYWxpemVkTWVkaWFUeXBlLmxlbmd0aCA+IDAgfHwgbWltZVR5cGUgJiYgbWltZVR5cGUgIT09IERBVEFfVVJMX0RFRkFVTFRfTUlNRV9UWVBFKSB7XG4gICAgbm9ybWFsaXplZE1lZGlhVHlwZS51bnNoaWZ0KG1pbWVUeXBlKTtcbiAgfVxuICByZXR1cm4gYGRhdGE6JHtub3JtYWxpemVkTWVkaWFUeXBlLmpvaW4oXCI7XCIpfSwke2lzQmFzZTY0ID8gZGF0YS50cmltKCkgOiBkYXRhfSR7aGFzaCA/IGAjJHtoYXNofWAgOiBcIlwifWA7XG59O1xuZnVuY3Rpb24gbm9ybWFsaXplVXJsKHVybFN0cmluZywgb3B0aW9ucyA9IHt9KSB7XG4gIG9wdGlvbnMgPSB7XG4gICAgZGVmYXVsdFByb3RvY29sOiBcImh0dHBcIixcbiAgICBub3JtYWxpemVQcm90b2NvbDogdHJ1ZSxcbiAgICBmb3JjZUh0dHA6IGZhbHNlLFxuICAgIGZvcmNlSHR0cHM6IGZhbHNlLFxuICAgIHN0cmlwQXV0aGVudGljYXRpb246IHRydWUsXG4gICAgc3RyaXBIYXNoOiBmYWxzZSxcbiAgICBzdHJpcFRleHRGcmFnbWVudDogdHJ1ZSxcbiAgICBzdHJpcFdXVzogdHJ1ZSxcbiAgICByZW1vdmVRdWVyeVBhcmFtZXRlcnM6IFsvXnV0bV9cXHcrL2ldLFxuICAgIHJlbW92ZVRyYWlsaW5nU2xhc2g6IHRydWUsXG4gICAgcmVtb3ZlU2luZ2xlU2xhc2g6IHRydWUsXG4gICAgcmVtb3ZlRGlyZWN0b3J5SW5kZXg6IGZhbHNlLFxuICAgIHJlbW92ZUV4cGxpY2l0UG9ydDogZmFsc2UsXG4gICAgc29ydFF1ZXJ5UGFyYW1ldGVyczogdHJ1ZSxcbiAgICAuLi5vcHRpb25zXG4gIH07XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5kZWZhdWx0UHJvdG9jb2wgPT09IFwic3RyaW5nXCIgJiYgIW9wdGlvbnMuZGVmYXVsdFByb3RvY29sLmVuZHNXaXRoKFwiOlwiKSkge1xuICAgIG9wdGlvbnMuZGVmYXVsdFByb3RvY29sID0gYCR7b3B0aW9ucy5kZWZhdWx0UHJvdG9jb2x9OmA7XG4gIH1cbiAgdXJsU3RyaW5nID0gdXJsU3RyaW5nLnRyaW0oKTtcbiAgaWYgKC9eZGF0YTovaS50ZXN0KHVybFN0cmluZykpIHtcbiAgICByZXR1cm4gbm9ybWFsaXplRGF0YVVSTCh1cmxTdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIGlmIChoYXNDdXN0b21Qcm90b2NvbCh1cmxTdHJpbmcpKSB7XG4gICAgcmV0dXJuIHVybFN0cmluZztcbiAgfVxuICBjb25zdCBoYXNSZWxhdGl2ZVByb3RvY29sID0gdXJsU3RyaW5nLnN0YXJ0c1dpdGgoXCIvL1wiKTtcbiAgY29uc3QgaXNSZWxhdGl2ZVVybCA9ICFoYXNSZWxhdGl2ZVByb3RvY29sICYmIC9eXFwuKlxcLy8udGVzdCh1cmxTdHJpbmcpO1xuICBpZiAoIWlzUmVsYXRpdmVVcmwpIHtcbiAgICB1cmxTdHJpbmcgPSB1cmxTdHJpbmcucmVwbGFjZSgvXig/ISg/Olxcdys6KT9cXC9cXC8pfF5cXC9cXC8vLCBvcHRpb25zLmRlZmF1bHRQcm90b2NvbCk7XG4gIH1cbiAgY29uc3QgdXJsT2JqZWN0ID0gbmV3IFVSTCh1cmxTdHJpbmcpO1xuICB1cmxPYmplY3QuaG9zdG5hbWUgPSB1cmxPYmplY3QuaG9zdG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgaWYgKG9wdGlvbnMuZm9yY2VIdHRwICYmIG9wdGlvbnMuZm9yY2VIdHRwcykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBgZm9yY2VIdHRwYCBhbmQgYGZvcmNlSHR0cHNgIG9wdGlvbnMgY2Fubm90IGJlIHVzZWQgdG9nZXRoZXJcIik7XG4gIH1cbiAgaWYgKG9wdGlvbnMuZm9yY2VIdHRwICYmIHVybE9iamVjdC5wcm90b2NvbCA9PT0gXCJodHRwczpcIikge1xuICAgIHVybE9iamVjdC5wcm90b2NvbCA9IFwiaHR0cDpcIjtcbiAgfVxuICBpZiAob3B0aW9ucy5mb3JjZUh0dHBzICYmIHVybE9iamVjdC5wcm90b2NvbCA9PT0gXCJodHRwOlwiKSB7XG4gICAgdXJsT2JqZWN0LnByb3RvY29sID0gXCJodHRwczpcIjtcbiAgfVxuICBpZiAob3B0aW9ucy5zdHJpcEF1dGhlbnRpY2F0aW9uKSB7XG4gICAgdXJsT2JqZWN0LnVzZXJuYW1lID0gXCJcIjtcbiAgICB1cmxPYmplY3QucGFzc3dvcmQgPSBcIlwiO1xuICB9XG4gIGlmIChvcHRpb25zLnN0cmlwSGFzaCkge1xuICAgIHVybE9iamVjdC5oYXNoID0gXCJcIjtcbiAgfSBlbHNlIGlmIChvcHRpb25zLnN0cmlwVGV4dEZyYWdtZW50KSB7XG4gICAgdXJsT2JqZWN0Lmhhc2ggPSB1cmxPYmplY3QuaGFzaC5yZXBsYWNlKC8jPzp+OnRleHQuKj8kL2ksIFwiXCIpO1xuICB9XG4gIGlmICh1cmxPYmplY3QucGF0aG5hbWUpIHtcbiAgICBjb25zdCBwcm90b2NvbFJlZ2V4ID0gL1xcYlthLXpdW2EtelxcZCtcXC0uXXsxLDUwfTpcXC9cXC8vZztcbiAgICBsZXQgbGFzdEluZGV4ID0gMDtcbiAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICBmb3IgKDsgOyApIHtcbiAgICAgIGNvbnN0IG1hdGNoID0gcHJvdG9jb2xSZWdleC5leGVjKHVybE9iamVjdC5wYXRobmFtZSk7XG4gICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY29uc3QgcHJvdG9jb2wgPSBtYXRjaFswXTtcbiAgICAgIGNvbnN0IHByb3RvY29sQXRJbmRleCA9IG1hdGNoLmluZGV4O1xuICAgICAgY29uc3QgaW50ZXJtZWRpYXRlID0gdXJsT2JqZWN0LnBhdGhuYW1lLnNsaWNlKGxhc3RJbmRleCwgcHJvdG9jb2xBdEluZGV4KTtcbiAgICAgIHJlc3VsdCArPSBpbnRlcm1lZGlhdGUucmVwbGFjZSgvXFwvezIsfS9nLCBcIi9cIik7XG4gICAgICByZXN1bHQgKz0gcHJvdG9jb2w7XG4gICAgICBsYXN0SW5kZXggPSBwcm90b2NvbEF0SW5kZXggKyBwcm90b2NvbC5sZW5ndGg7XG4gICAgfVxuICAgIGNvbnN0IHJlbW5hbnQgPSB1cmxPYmplY3QucGF0aG5hbWUuc2xpY2UobGFzdEluZGV4LCB1cmxPYmplY3QucGF0aG5hbWUubGVuZ3RoKTtcbiAgICByZXN1bHQgKz0gcmVtbmFudC5yZXBsYWNlKC9cXC97Mix9L2csIFwiL1wiKTtcbiAgICB1cmxPYmplY3QucGF0aG5hbWUgPSByZXN1bHQ7XG4gIH1cbiAgaWYgKHVybE9iamVjdC5wYXRobmFtZSkge1xuICAgIHRyeSB7XG4gICAgICB1cmxPYmplY3QucGF0aG5hbWUgPSBkZWNvZGVVUkkodXJsT2JqZWN0LnBhdGhuYW1lKTtcbiAgICB9IGNhdGNoIHtcbiAgICB9XG4gIH1cbiAgaWYgKG9wdGlvbnMucmVtb3ZlRGlyZWN0b3J5SW5kZXggPT09IHRydWUpIHtcbiAgICBvcHRpb25zLnJlbW92ZURpcmVjdG9yeUluZGV4ID0gWy9eaW5kZXhcXC5bYS16XSskL107XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5yZW1vdmVEaXJlY3RvcnlJbmRleCkgJiYgb3B0aW9ucy5yZW1vdmVEaXJlY3RvcnlJbmRleC5sZW5ndGggPiAwKSB7XG4gICAgbGV0IHBhdGhDb21wb25lbnRzID0gdXJsT2JqZWN0LnBhdGhuYW1lLnNwbGl0KFwiL1wiKTtcbiAgICBjb25zdCBsYXN0Q29tcG9uZW50ID0gcGF0aENvbXBvbmVudHNbcGF0aENvbXBvbmVudHMubGVuZ3RoIC0gMV07XG4gICAgaWYgKHRlc3RQYXJhbWV0ZXIobGFzdENvbXBvbmVudCwgb3B0aW9ucy5yZW1vdmVEaXJlY3RvcnlJbmRleCkpIHtcbiAgICAgIHBhdGhDb21wb25lbnRzID0gcGF0aENvbXBvbmVudHMuc2xpY2UoMCwgLTEpO1xuICAgICAgdXJsT2JqZWN0LnBhdGhuYW1lID0gcGF0aENvbXBvbmVudHMuc2xpY2UoMSkuam9pbihcIi9cIikgKyBcIi9cIjtcbiAgICB9XG4gIH1cbiAgaWYgKHVybE9iamVjdC5ob3N0bmFtZSkge1xuICAgIHVybE9iamVjdC5ob3N0bmFtZSA9IHVybE9iamVjdC5ob3N0bmFtZS5yZXBsYWNlKC9cXC4kLywgXCJcIik7XG4gICAgaWYgKG9wdGlvbnMuc3RyaXBXV1cgJiYgL153d3dcXC4oPyF3d3dcXC4pW2EtelxcLVxcZF17MSw2M31cXC5bYS16LlxcLVxcZF17Miw2M30kLy50ZXN0KHVybE9iamVjdC5ob3N0bmFtZSkpIHtcbiAgICAgIHVybE9iamVjdC5ob3N0bmFtZSA9IHVybE9iamVjdC5ob3N0bmFtZS5yZXBsYWNlKC9ed3d3XFwuLywgXCJcIik7XG4gICAgfVxuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMucmVtb3ZlUXVlcnlQYXJhbWV0ZXJzKSkge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIFsuLi51cmxPYmplY3Quc2VhcmNoUGFyYW1zLmtleXMoKV0pIHtcbiAgICAgIGlmICh0ZXN0UGFyYW1ldGVyKGtleSwgb3B0aW9ucy5yZW1vdmVRdWVyeVBhcmFtZXRlcnMpKSB7XG4gICAgICAgIHVybE9iamVjdC5zZWFyY2hQYXJhbXMuZGVsZXRlKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghQXJyYXkuaXNBcnJheShvcHRpb25zLmtlZXBRdWVyeVBhcmFtZXRlcnMpICYmIG9wdGlvbnMucmVtb3ZlUXVlcnlQYXJhbWV0ZXJzID09PSB0cnVlKSB7XG4gICAgdXJsT2JqZWN0LnNlYXJjaCA9IFwiXCI7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5rZWVwUXVlcnlQYXJhbWV0ZXJzKSAmJiBvcHRpb25zLmtlZXBRdWVyeVBhcmFtZXRlcnMubGVuZ3RoID4gMCkge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIFsuLi51cmxPYmplY3Quc2VhcmNoUGFyYW1zLmtleXMoKV0pIHtcbiAgICAgIGlmICghdGVzdFBhcmFtZXRlcihrZXksIG9wdGlvbnMua2VlcFF1ZXJ5UGFyYW1ldGVycykpIHtcbiAgICAgICAgdXJsT2JqZWN0LnNlYXJjaFBhcmFtcy5kZWxldGUoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKG9wdGlvbnMuc29ydFF1ZXJ5UGFyYW1ldGVycykge1xuICAgIHVybE9iamVjdC5zZWFyY2hQYXJhbXMuc29ydCgpO1xuICAgIHRyeSB7XG4gICAgICB1cmxPYmplY3Quc2VhcmNoID0gZGVjb2RlVVJJQ29tcG9uZW50KHVybE9iamVjdC5zZWFyY2gpO1xuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgfVxuICBpZiAob3B0aW9ucy5yZW1vdmVUcmFpbGluZ1NsYXNoKSB7XG4gICAgdXJsT2JqZWN0LnBhdGhuYW1lID0gdXJsT2JqZWN0LnBhdGhuYW1lLnJlcGxhY2UoL1xcLyQvLCBcIlwiKTtcbiAgfVxuICBpZiAob3B0aW9ucy5yZW1vdmVFeHBsaWNpdFBvcnQgJiYgdXJsT2JqZWN0LnBvcnQpIHtcbiAgICB1cmxPYmplY3QucG9ydCA9IFwiXCI7XG4gIH1cbiAgY29uc3Qgb2xkVXJsU3RyaW5nID0gdXJsU3RyaW5nO1xuICB1cmxTdHJpbmcgPSB1cmxPYmplY3QudG9TdHJpbmcoKTtcbiAgaWYgKCFvcHRpb25zLnJlbW92ZVNpbmdsZVNsYXNoICYmIHVybE9iamVjdC5wYXRobmFtZSA9PT0gXCIvXCIgJiYgIW9sZFVybFN0cmluZy5lbmRzV2l0aChcIi9cIikgJiYgdXJsT2JqZWN0Lmhhc2ggPT09IFwiXCIpIHtcbiAgICB1cmxTdHJpbmcgPSB1cmxTdHJpbmcucmVwbGFjZSgvXFwvJC8sIFwiXCIpO1xuICB9XG4gIGlmICgob3B0aW9ucy5yZW1vdmVUcmFpbGluZ1NsYXNoIHx8IHVybE9iamVjdC5wYXRobmFtZSA9PT0gXCIvXCIpICYmIHVybE9iamVjdC5oYXNoID09PSBcIlwiICYmIG9wdGlvbnMucmVtb3ZlU2luZ2xlU2xhc2gpIHtcbiAgICB1cmxTdHJpbmcgPSB1cmxTdHJpbmcucmVwbGFjZSgvXFwvJC8sIFwiXCIpO1xuICB9XG4gIGlmIChoYXNSZWxhdGl2ZVByb3RvY29sICYmICFvcHRpb25zLm5vcm1hbGl6ZVByb3RvY29sKSB7XG4gICAgdXJsU3RyaW5nID0gdXJsU3RyaW5nLnJlcGxhY2UoL15odHRwOlxcL1xcLy8sIFwiLy9cIik7XG4gIH1cbiAgaWYgKG9wdGlvbnMuc3RyaXBQcm90b2NvbCkge1xuICAgIHVybFN0cmluZyA9IHVybFN0cmluZy5yZXBsYWNlKC9eKD86aHR0cHM/Oik/XFwvXFwvLywgXCJcIik7XG4gIH1cbiAgcmV0dXJuIHVybFN0cmluZztcbn1cblxuLy8gc3JjL3JlbGF5L2luZGV4LnRzXG5pbXBvcnQgZGVidWcgZnJvbSBcImRlYnVnXCI7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tIFwidHNlZXBcIjtcblxuLy8gc3JjL3JlbGF5L2Nvbm5lY3Rpdml0eS50c1xudmFyIE1BWF9SRUNPTk5FQ1RfQVRURU1QVFMgPSA1O1xudmFyIEZMQVBQSU5HX1RIUkVTSE9MRF9NUyA9IDFlMztcbnZhciBOREtSZWxheUNvbm5lY3Rpdml0eSA9IGNsYXNzIHtcbiAgbmRrUmVsYXk7XG4gIHdzO1xuICBfc3RhdHVzO1xuICB0aW1lb3V0TXM7XG4gIGNvbm5lY3RlZEF0O1xuICBfY29ubmVjdGlvblN0YXRzID0ge1xuICAgIGF0dGVtcHRzOiAwLFxuICAgIHN1Y2Nlc3M6IDAsXG4gICAgZHVyYXRpb25zOiBbXVxuICB9O1xuICBkZWJ1ZztcbiAgbmV0RGVidWc7XG4gIGNvbm5lY3RUaW1lb3V0O1xuICByZWNvbm5lY3RUaW1lb3V0O1xuICBuZGs7XG4gIG9wZW5TdWJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgb3BlbkNvdW50UmVxdWVzdHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBvcGVuRXZlbnRQdWJsaXNoZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBzZXJpYWwgPSAwO1xuICBiYXNlRW9zZVRpbWVvdXQgPSA0NDAwO1xuICBjb25zdHJ1Y3RvcihuZGtSZWxheSwgbmRrKSB7XG4gICAgdGhpcy5uZGtSZWxheSA9IG5ka1JlbGF5O1xuICAgIHRoaXMuX3N0YXR1cyA9IDEgLyogRElTQ09OTkVDVEVEICovO1xuICAgIGNvbnN0IHJhbmQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxZTMpO1xuICAgIHRoaXMuZGVidWcgPSB0aGlzLm5ka1JlbGF5LmRlYnVnLmV4dGVuZChcImNvbm5lY3Rpdml0eVwiICsgcmFuZCk7XG4gICAgdGhpcy5uZGsgPSBuZGs7XG4gIH1cbiAgLyoqXG4gICAqIENvbm5lY3RzIHRvIHRoZSBOREsgcmVsYXkgYW5kIGhhbmRsZXMgdGhlIGNvbm5lY3Rpb24gbGlmZWN5Y2xlLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBhdHRlbXB0cyB0byBlc3RhYmxpc2ggYSBXZWJTb2NrZXQgY29ubmVjdGlvbiB0byB0aGUgTkRLIHJlbGF5IHNwZWNpZmllZCBpbiB0aGUgYG5ka1JlbGF5YCBvYmplY3QuXG4gICAqIElmIHRoZSBjb25uZWN0aW9uIGlzIHN1Y2Nlc3NmdWwsIGl0IHVwZGF0ZXMgdGhlIGNvbm5lY3Rpb24gc3RhdGlzdGljcywgc2V0cyB0aGUgY29ubmVjdGlvbiBzdGF0dXMgdG8gYENPTk5FQ1RFRGAsXG4gICAqIGFuZCBlbWl0cyBgY29ubmVjdGAgYW5kIGByZWFkeWAgZXZlbnRzIG9uIHRoZSBgbmRrUmVsYXlgIG9iamVjdC5cbiAgICpcbiAgICogSWYgdGhlIGNvbm5lY3Rpb24gYXR0ZW1wdCBmYWlscywgaXQgaGFuZGxlcyB0aGUgZXJyb3IgYnkgZWl0aGVyIGluaXRpYXRpbmcgYSByZWNvbm5lY3Rpb24gYXR0ZW1wdCBvciBlbWl0dGluZyBhXG4gICAqIGBkZWxheWVkLWNvbm5lY3RgIGV2ZW50IG9uIHRoZSBgbmRrUmVsYXlgIG9iamVjdCwgZGVwZW5kaW5nIG9uIHRoZSBgcmVjb25uZWN0YCBwYXJhbWV0ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB0aW1lb3V0TXMgLSBUaGUgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgZm9yIHRoZSBjb25uZWN0aW9uIGF0dGVtcHQuIElmIG5vdCBwcm92aWRlZCwgdGhlIGRlZmF1bHQgdGltZW91dCBmcm9tIHRoZSBgbmRrUmVsYXlgIG9iamVjdCBpcyB1c2VkLlxuICAgKiBAcGFyYW0gcmVjb25uZWN0IC0gSW5kaWNhdGVzIHdoZXRoZXIgYSByZWNvbm5lY3Rpb24gc2hvdWxkIGJlIGF0dGVtcHRlZCBpZiB0aGUgY29ubmVjdGlvbiBmYWlscy4gRGVmYXVsdHMgdG8gYHRydWVgLlxuICAgKiBAcmV0dXJucyBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBjb25uZWN0aW9uIGlzIGVzdGFibGlzaGVkLCBvciByZWplY3RzIGlmIHRoZSBjb25uZWN0aW9uIGZhaWxzLlxuICAgKi9cbiAgYXN5bmMgY29ubmVjdCh0aW1lb3V0TXMsIHJlY29ubmVjdCA9IHRydWUpIHtcbiAgICBpZiAodGhpcy5fc3RhdHVzICE9PSAyIC8qIFJFQ09OTkVDVElORyAqLyAmJiB0aGlzLl9zdGF0dXMgIT09IDEgLyogRElTQ09OTkVDVEVEICovIHx8IHRoaXMucmVjb25uZWN0VGltZW91dCkge1xuICAgICAgdGhpcy5kZWJ1ZyhcbiAgICAgICAgXCJSZWxheSByZXF1ZXN0ZWQgdG8gYmUgY29ubmVjdGVkIGJ1dCB3YXMgaW4gc3RhdGUgJXMgb3IgaXQgaGFkIGEgcmVjb25uZWN0IHRpbWVvdXRcIixcbiAgICAgICAgdGhpcy5fc3RhdHVzXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5yZWNvbm5lY3RUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5yZWNvbm5lY3RUaW1lb3V0KTtcbiAgICAgIHRoaXMucmVjb25uZWN0VGltZW91dCA9IHZvaWQgMDtcbiAgICB9XG4gICAgaWYgKHRoaXMuY29ubmVjdFRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNvbm5lY3RUaW1lb3V0KTtcbiAgICAgIHRoaXMuY29ubmVjdFRpbWVvdXQgPSB2b2lkIDA7XG4gICAgfVxuICAgIHRpbWVvdXRNcyA/Pz0gdGhpcy50aW1lb3V0TXM7XG4gICAgaWYgKCF0aGlzLnRpbWVvdXRNcyAmJiB0aW1lb3V0TXMpIHRoaXMudGltZW91dE1zID0gdGltZW91dE1zO1xuICAgIGlmICh0aGlzLnRpbWVvdXRNcylcbiAgICAgIHRoaXMuY29ubmVjdFRpbWVvdXQgPSBzZXRUaW1lb3V0KFxuICAgICAgICAoKSA9PiB0aGlzLm9uQ29ubmVjdGlvbkVycm9yKHJlY29ubmVjdCksXG4gICAgICAgIHRoaXMudGltZW91dE1zXG4gICAgICApO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnVwZGF0ZUNvbm5lY3Rpb25TdGF0cy5hdHRlbXB0KCk7XG4gICAgICBpZiAodGhpcy5fc3RhdHVzID09PSAxIC8qIERJU0NPTk5FQ1RFRCAqLylcbiAgICAgICAgdGhpcy5fc3RhdHVzID0gNCAvKiBDT05ORUNUSU5HICovO1xuICAgICAgZWxzZSB0aGlzLl9zdGF0dXMgPSAyIC8qIFJFQ09OTkVDVElORyAqLztcbiAgICAgIHRoaXMud3MgPSBuZXcgV2ViU29ja2V0KHRoaXMubmRrUmVsYXkudXJsKTtcbiAgICAgIHRoaXMud3Mub25vcGVuID0gdGhpcy5vbkNvbm5lY3QuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMud3Mub25jbG9zZSA9IHRoaXMub25EaXNjb25uZWN0LmJpbmQodGhpcyk7XG4gICAgICB0aGlzLndzLm9ubWVzc2FnZSA9IHRoaXMub25NZXNzYWdlLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLndzLm9uZXJyb3IgPSB0aGlzLm9uRXJyb3IuYmluZCh0aGlzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aGlzLmRlYnVnKGBGYWlsZWQgdG8gY29ubmVjdCB0byAke3RoaXMubmRrUmVsYXkudXJsfWAsIGUpO1xuICAgICAgdGhpcy5fc3RhdHVzID0gMSAvKiBESVNDT05ORUNURUQgKi87XG4gICAgICBpZiAocmVjb25uZWN0KSB0aGlzLmhhbmRsZVJlY29ubmVjdGlvbigpO1xuICAgICAgZWxzZSB0aGlzLm5ka1JlbGF5LmVtaXQoXCJkZWxheWVkLWNvbm5lY3RcIiwgMiAqIDI0ICogNjAgKiA2MCAqIDFlMyk7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRGlzY29ubmVjdHMgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIHRvIHRoZSBOREsgcmVsYXkuXG4gICAqIFRoaXMgbWV0aG9kIHNldHMgdGhlIGNvbm5lY3Rpb24gc3RhdHVzIHRvIGBOREtSZWxheVN0YXR1cy5ESVNDT05ORUNUSU5HYCxcbiAgICogYXR0ZW1wdHMgdG8gY2xvc2UgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uLCBhbmQgc2V0cyB0aGUgc3RhdHVzIHRvXG4gICAqIGBOREtSZWxheVN0YXR1cy5ESVNDT05ORUNURURgIGlmIHRoZSBkaXNjb25uZWN0IG9wZXJhdGlvbiBmYWlscy5cbiAgICovXG4gIGRpc2Nvbm5lY3QoKSB7XG4gICAgdGhpcy5fc3RhdHVzID0gMCAvKiBESVNDT05ORUNUSU5HICovO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLndzPy5jbG9zZSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXMuZGVidWcoXCJGYWlsZWQgdG8gZGlzY29ubmVjdFwiLCBlKTtcbiAgICAgIHRoaXMuX3N0YXR1cyA9IDEgLyogRElTQ09OTkVDVEVEICovO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogSGFuZGxlcyB0aGUgZXJyb3IgdGhhdCBvY2N1cnJlZCB3aGVuIGF0dGVtcHRpbmcgdG8gY29ubmVjdCB0byB0aGUgTkRLIHJlbGF5LlxuICAgKiBJZiBgcmVjb25uZWN0YCBpcyBgdHJ1ZWAsIHRoaXMgbWV0aG9kIHdpbGwgaW5pdGlhdGUgYSByZWNvbm5lY3Rpb24gYXR0ZW1wdC5cbiAgICogT3RoZXJ3aXNlLCBpdCB3aWxsIGVtaXQgYSBgZGVsYXllZC1jb25uZWN0YCBldmVudCBvbiB0aGUgYG5ka1JlbGF5YCBvYmplY3QsXG4gICAqIGluZGljYXRpbmcgdGhhdCBhIHJlY29ubmVjdGlvbiBzaG91bGQgYmUgYXR0ZW1wdGVkIGFmdGVyIGEgZGVsYXkuXG4gICAqXG4gICAqIEBwYXJhbSByZWNvbm5lY3QgLSBJbmRpY2F0ZXMgd2hldGhlciBhIHJlY29ubmVjdGlvbiBzaG91bGQgYmUgYXR0ZW1wdGVkLlxuICAgKi9cbiAgb25Db25uZWN0aW9uRXJyb3IocmVjb25uZWN0KSB7XG4gICAgdGhpcy5kZWJ1ZyhgRXJyb3IgY29ubmVjdGluZyB0byAke3RoaXMubmRrUmVsYXkudXJsfWAsIHRoaXMudGltZW91dE1zKTtcbiAgICBpZiAocmVjb25uZWN0ICYmICF0aGlzLnJlY29ubmVjdFRpbWVvdXQpIHtcbiAgICAgIHRoaXMuaGFuZGxlUmVjb25uZWN0aW9uKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSBjb25uZWN0aW9uIGV2ZW50IHdoZW4gdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIGlzIGVzdGFibGlzaGVkLlxuICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgd2hlbiB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gaXMgc3VjY2Vzc2Z1bGx5IG9wZW5lZC5cbiAgICogSXQgY2xlYXJzIGFueSBleGlzdGluZyBjb25uZWN0aW9uIGFuZCByZWNvbm5lY3Rpb24gdGltZW91dHMsIHVwZGF0ZXMgdGhlIGNvbm5lY3Rpb24gc3RhdGlzdGljcyxcbiAgICogc2V0cyB0aGUgY29ubmVjdGlvbiBzdGF0dXMgdG8gYENPTk5FQ1RFRGAsIGFuZCBlbWl0cyBgY29ubmVjdGAgYW5kIGByZWFkeWAgZXZlbnRzIG9uIHRoZSBgbmRrUmVsYXlgIG9iamVjdC5cbiAgICovXG4gIG9uQ29ubmVjdCgpIHtcbiAgICB0aGlzLm5ldERlYnVnPy4oXCJjb25uZWN0ZWRcIiwgdGhpcy5uZGtSZWxheSk7XG4gICAgaWYgKHRoaXMucmVjb25uZWN0VGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVjb25uZWN0VGltZW91dCk7XG4gICAgICB0aGlzLnJlY29ubmVjdFRpbWVvdXQgPSB2b2lkIDA7XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbm5lY3RUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5jb25uZWN0VGltZW91dCk7XG4gICAgICB0aGlzLmNvbm5lY3RUaW1lb3V0ID0gdm9pZCAwO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZUNvbm5lY3Rpb25TdGF0cy5jb25uZWN0ZWQoKTtcbiAgICB0aGlzLl9zdGF0dXMgPSA1IC8qIENPTk5FQ1RFRCAqLztcbiAgICB0aGlzLm5ka1JlbGF5LmVtaXQoXCJjb25uZWN0XCIpO1xuICAgIHRoaXMubmRrUmVsYXkuZW1pdChcInJlYWR5XCIpO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSBkaXNjb25uZWN0aW9uIGV2ZW50IHdoZW4gdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIGlzIGNsb3NlZC5cbiAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIHdoZW4gdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIGlzIHN1Y2Nlc3NmdWxseSBjbG9zZWQuXG4gICAqIEl0IHVwZGF0ZXMgdGhlIGNvbm5lY3Rpb24gc3RhdGlzdGljcywgc2V0cyB0aGUgY29ubmVjdGlvbiBzdGF0dXMgdG8gYERJU0NPTk5FQ1RFRGAsXG4gICAqIGluaXRpYXRlcyBhIHJlY29ubmVjdGlvbiBhdHRlbXB0IGlmIHdlIGRpZG4ndCBkaXNjb25uZWN0IG91cnNlbHZlcyxcbiAgICogYW5kIGVtaXRzIGEgYGRpc2Nvbm5lY3RgIGV2ZW50IG9uIHRoZSBgbmRrUmVsYXlgIG9iamVjdC5cbiAgICovXG4gIG9uRGlzY29ubmVjdCgpIHtcbiAgICB0aGlzLm5ldERlYnVnPy4oXCJkaXNjb25uZWN0ZWRcIiwgdGhpcy5uZGtSZWxheSk7XG4gICAgdGhpcy51cGRhdGVDb25uZWN0aW9uU3RhdHMuZGlzY29ubmVjdGVkKCk7XG4gICAgaWYgKHRoaXMuX3N0YXR1cyA9PT0gNSAvKiBDT05ORUNURUQgKi8pIHtcbiAgICAgIHRoaXMuaGFuZGxlUmVjb25uZWN0aW9uKCk7XG4gICAgfVxuICAgIHRoaXMuX3N0YXR1cyA9IDEgLyogRElTQ09OTkVDVEVEICovO1xuICAgIHRoaXMubmRrUmVsYXkuZW1pdChcImRpc2Nvbm5lY3RcIik7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZXMgaW5jb21pbmcgbWVzc2FnZXMgZnJvbSB0aGUgTkRLIHJlbGF5IFdlYlNvY2tldCBjb25uZWN0aW9uLlxuICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgd2hlbmV2ZXIgYSBtZXNzYWdlIGlzIHJlY2VpdmVkIGZyb20gdGhlIHJlbGF5LlxuICAgKiBJdCBwYXJzZXMgdGhlIG1lc3NhZ2UgZGF0YSBhbmQgZGlzcGF0Y2hlcyB0aGUgYXBwcm9wcmlhdGUgaGFuZGxpbmcgbG9naWMgYmFzZWQgb24gdGhlIG1lc3NhZ2UgdHlwZS5cbiAgICpcbiAgICogQHBhcmFtIGV2ZW50IC0gVGhlIE1lc3NhZ2VFdmVudCBjb250YWluaW5nIHRoZSByZWNlaXZlZCBtZXNzYWdlIGRhdGEuXG4gICAqL1xuICBvbk1lc3NhZ2UoZXZlbnQpIHtcbiAgICB0aGlzLm5ldERlYnVnPy4oZXZlbnQuZGF0YSwgdGhpcy5uZGtSZWxheSwgXCJyZWN2XCIpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShldmVudC5kYXRhKTtcbiAgICAgIGNvbnN0IFtjbWQsIGlkLCAuLi5yZXN0XSA9IGRhdGE7XG4gICAgICBzd2l0Y2ggKGNtZCkge1xuICAgICAgICBjYXNlIFwiRVZFTlRcIjoge1xuICAgICAgICAgIGNvbnN0IHNvID0gdGhpcy5vcGVuU3Vicy5nZXQoaWQpO1xuICAgICAgICAgIGNvbnN0IGV2ZW50MiA9IGRhdGFbMl07XG4gICAgICAgICAgaWYgKCFzbykge1xuICAgICAgICAgICAgdGhpcy5kZWJ1ZyhgUmVjZWl2ZWQgZXZlbnQgZm9yIHVua25vd24gc3Vic2NyaXB0aW9uICR7aWR9YCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHNvLm9uZXZlbnQoZXZlbnQyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIkNPVU5UXCI6IHtcbiAgICAgICAgICBjb25zdCBwYXlsb2FkID0gZGF0YVsyXTtcbiAgICAgICAgICBjb25zdCBjciA9IHRoaXMub3BlbkNvdW50UmVxdWVzdHMuZ2V0KGlkKTtcbiAgICAgICAgICBpZiAoY3IpIHtcbiAgICAgICAgICAgIGNyLnJlc29sdmUocGF5bG9hZC5jb3VudCk7XG4gICAgICAgICAgICB0aGlzLm9wZW5Db3VudFJlcXVlc3RzLmRlbGV0ZShpZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiRU9TRVwiOiB7XG4gICAgICAgICAgY29uc3Qgc28gPSB0aGlzLm9wZW5TdWJzLmdldChpZCk7XG4gICAgICAgICAgaWYgKCFzbykgcmV0dXJuO1xuICAgICAgICAgIHNvLm9uZW9zZShpZCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJPS1wiOiB7XG4gICAgICAgICAgY29uc3Qgb2sgPSBkYXRhWzJdO1xuICAgICAgICAgIGNvbnN0IHJlYXNvbiA9IGRhdGFbM107XG4gICAgICAgICAgY29uc3QgZXAgPSB0aGlzLm9wZW5FdmVudFB1Ymxpc2hlcy5nZXQoaWQpO1xuICAgICAgICAgIGNvbnN0IGZpcnN0RXAgPSBlcD8ucG9wKCk7XG4gICAgICAgICAgaWYgKCFlcCB8fCAhZmlyc3RFcCkge1xuICAgICAgICAgICAgdGhpcy5kZWJ1ZyhcIlJlY2VpdmVkIE9LIGZvciB1bmtub3duIGV2ZW50IHB1Ymxpc2hcIiwgaWQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob2spIGZpcnN0RXAucmVzb2x2ZShyZWFzb24pO1xuICAgICAgICAgIGVsc2UgZmlyc3RFcC5yZWplY3QobmV3IEVycm9yKHJlYXNvbikpO1xuICAgICAgICAgIGlmIChlcC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMub3BlbkV2ZW50UHVibGlzaGVzLmRlbGV0ZShpZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub3BlbkV2ZW50UHVibGlzaGVzLnNldChpZCwgZXApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIkNMT1NFRFwiOiB7XG4gICAgICAgICAgY29uc3Qgc28gPSB0aGlzLm9wZW5TdWJzLmdldChpZCk7XG4gICAgICAgICAgaWYgKCFzbykgcmV0dXJuO1xuICAgICAgICAgIHNvLm9uY2xvc2VkKGRhdGFbMl0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiTk9USUNFXCI6XG4gICAgICAgICAgdGhpcy5vbk5vdGljZShkYXRhWzFdKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgXCJBVVRIXCI6IHtcbiAgICAgICAgICB0aGlzLm9uQXV0aFJlcXVlc3RlZChkYXRhWzFdKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5kZWJ1ZyhcbiAgICAgICAgYEVycm9yIHBhcnNpbmcgbWVzc2FnZSBmcm9tICR7dGhpcy5uZGtSZWxheS51cmx9OiAke2Vycm9yLm1lc3NhZ2V9YCxcbiAgICAgICAgZXJyb3I/LnN0YWNrXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogSGFuZGxlcyBhbiBhdXRoZW50aWNhdGlvbiByZXF1ZXN0IGZyb20gdGhlIE5ESyByZWxheS5cbiAgICpcbiAgICogSWYgYW4gYXV0aGVudGljYXRpb24gcG9saWN5IGlzIGNvbmZpZ3VyZWQsIGl0IHdpbGwgYmUgdXNlZCB0byBhdXRoZW50aWNhdGUgdGhlIGNvbm5lY3Rpb24uXG4gICAqIE90aGVyd2lzZSwgdGhlIGBhdXRoYCBldmVudCB3aWxsIGJlIGVtaXR0ZWQgdG8gYWxsb3cgdGhlIGFwcGxpY2F0aW9uIHRvIGhhbmRsZSB0aGUgYXV0aGVudGljYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSBjaGFsbGVuZ2UgLSBUaGUgYXV0aGVudGljYXRpb24gY2hhbGxlbmdlIHByb3ZpZGVkIGJ5IHRoZSBOREsgcmVsYXkuXG4gICAqL1xuICBhc3luYyBvbkF1dGhSZXF1ZXN0ZWQoY2hhbGxlbmdlKSB7XG4gICAgY29uc3QgYXV0aFBvbGljeSA9IHRoaXMubmRrUmVsYXkuYXV0aFBvbGljeSA/PyB0aGlzLm5kaz8ucmVsYXlBdXRoRGVmYXVsdFBvbGljeTtcbiAgICB0aGlzLmRlYnVnKFwiUmVsYXkgcmVxdWVzdGVkIGF1dGhlbnRpY2F0aW9uXCIsIHtcbiAgICAgIGhhdmVQb2xpY3k6ICEhYXV0aFBvbGljeVxuICAgIH0pO1xuICAgIGlmICh0aGlzLl9zdGF0dXMgPT09IDcgLyogQVVUSEVOVElDQVRJTkcgKi8pIHtcbiAgICAgIHRoaXMuZGVidWcoXCJBbHJlYWR5IGF1dGhlbnRpY2F0aW5nLCBpZ25vcmluZ1wiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fc3RhdHVzID0gNiAvKiBBVVRIX1JFUVVFU1RFRCAqLztcbiAgICBpZiAoYXV0aFBvbGljeSkge1xuICAgICAgaWYgKHRoaXMuX3N0YXR1cyA+PSA1IC8qIENPTk5FQ1RFRCAqLykge1xuICAgICAgICB0aGlzLl9zdGF0dXMgPSA3IC8qIEFVVEhFTlRJQ0FUSU5HICovO1xuICAgICAgICBsZXQgcmVzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlcyA9IGF3YWl0IGF1dGhQb2xpY3kodGhpcy5uZGtSZWxheSwgY2hhbGxlbmdlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRoaXMuZGVidWcoXCJBdXRoZW50aWNhdGlvbiBwb2xpY3kgdGhyZXcgYW4gZXJyb3JcIiwgZSk7XG4gICAgICAgICAgcmVzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZWJ1ZyhcIkF1dGhlbnRpY2F0aW9uIHBvbGljeSByZXR1cm5lZFwiLCAhIXJlcyk7XG4gICAgICAgIGlmIChyZXMgaW5zdGFuY2VvZiBOREtFdmVudCB8fCByZXMgPT09IHRydWUpIHtcbiAgICAgICAgICBpZiAocmVzIGluc3RhbmNlb2YgTkRLRXZlbnQpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYXV0aChyZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBhdXRoZW50aWNhdGUgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhdHVzID49IDUgLyogQ09OTkVDVEVEICovICYmIHRoaXMuX3N0YXR1cyA8IDggLyogQVVUSEVOVElDQVRFRCAqLykge1xuICAgICAgICAgICAgICBjb25zdCBldmVudCA9IG5ldyBOREtFdmVudCh0aGlzLm5kayk7XG4gICAgICAgICAgICAgIGV2ZW50LmtpbmQgPSAyMjI0MiAvKiBDbGllbnRBdXRoICovO1xuICAgICAgICAgICAgICBldmVudC50YWdzID0gW1xuICAgICAgICAgICAgICAgIFtcInJlbGF5XCIsIHRoaXMubmRrUmVsYXkudXJsXSxcbiAgICAgICAgICAgICAgICBbXCJjaGFsbGVuZ2VcIiwgY2hhbGxlbmdlXVxuICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICBhd2FpdCBldmVudC5zaWduKCk7XG4gICAgICAgICAgICAgIHRoaXMuYXV0aChldmVudCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdHVzID0gOCAvKiBBVVRIRU5USUNBVEVEICovO1xuICAgICAgICAgICAgICAgIHRoaXMubmRrUmVsYXkuZW1pdChcImF1dGhlZFwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlYnVnKFwiQXV0aGVudGljYXRpb24gc3VjY2Vzc2Z1bFwiKTtcbiAgICAgICAgICAgICAgfSkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0dXMgPSA2IC8qIEFVVEhfUkVRVUVTVEVEICovO1xuICAgICAgICAgICAgICAgIHRoaXMubmRrUmVsYXkuZW1pdChcImF1dGg6ZmFpbGVkXCIsIGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVidWcoXCJBdXRoZW50aWNhdGlvbiBmYWlsZWRcIiwgZSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5kZWJ1ZyhcbiAgICAgICAgICAgICAgICBcIkF1dGhlbnRpY2F0aW9uIGZhaWxlZCwgaXQgY2hhbmdlZCBzdGF0dXMsIHN0YXR1cyBpcyAlZFwiLFxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXR1c1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKHJlcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLm5kaz8uc2lnbmVyKSB7XG4gICAgICAgICAgICAgIHRoaXMuZGVidWcoXCJObyBzaWduZXIgYXZhaWxhYmxlIGZvciBhdXRoZW50aWNhdGlvbiBsb2NhbGhvc3RcIik7XG4gICAgICAgICAgICAgIHRoaXMubmRrPy5vbmNlKFwic2lnbmVyOnJlYWR5XCIsIGF1dGhlbnRpY2F0ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhdXRoZW50aWNhdGUoKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBhdXRoZW50aWNhdGluZ1wiLCBlKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3N0YXR1cyA9IDUgLyogQ09OTkVDVEVEICovO1xuICAgICAgICAgIHRoaXMubmRrUmVsYXkuZW1pdChcImF1dGhlZFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm5ka1JlbGF5LmVtaXQoXCJhdXRoXCIsIGNoYWxsZW5nZSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBIYW5kbGVzIGVycm9ycyB0aGF0IG9jY3VyIG9uIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiB0byB0aGUgcmVsYXkuXG4gICAqIEBwYXJhbSBlcnJvciAtIFRoZSBlcnJvciBvciBldmVudCB0aGF0IG9jY3VycmVkLlxuICAgKi9cbiAgb25FcnJvcihlcnJvcikge1xuICAgIHRoaXMuZGVidWcoYFdlYlNvY2tldCBlcnJvciBvbiAke3RoaXMubmRrUmVsYXkudXJsfTpgLCBlcnJvcik7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgc3RhdHVzIG9mIHRoZSBOREsgcmVsYXkgY29ubmVjdGlvbi5cbiAgICogQHJldHVybnMge05ES1JlbGF5U3RhdHVzfSBUaGUgY3VycmVudCBzdGF0dXMgb2YgdGhlIE5ESyByZWxheSBjb25uZWN0aW9uLlxuICAgKi9cbiAgZ2V0IHN0YXR1cygpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdHVzO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIE5ESyByZWxheSBjb25uZWN0aW9uIGlzIGN1cnJlbnRseSBhdmFpbGFibGUuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHJlbGF5IGNvbm5lY3Rpb24gaXMgaW4gdGhlIGBDT05ORUNURURgIHN0YXR1cywgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAqL1xuICBpc0F2YWlsYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdHVzID09PSA1IC8qIENPTk5FQ1RFRCAqLztcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBOREsgcmVsYXkgY29ubmVjdGlvbiBpcyBmbGFwcGluZywgd2hpY2ggbWVhbnMgdGhlIGNvbm5lY3Rpb24gaXMgcmFwaWRseVxuICAgKiBkaXNjb25uZWN0aW5nIGFuZCByZWNvbm5lY3RpbmcuIFRoaXMgaXMgZGV0ZXJtaW5lZCBieSBhbmFseXppbmcgdGhlIGR1cmF0aW9ucyBvZiB0aGVcbiAgICogbGFzdCB0aHJlZSBjb25uZWN0aW9uIGF0dGVtcHRzLiBJZiB0aGUgc3RhbmRhcmQgZGV2aWF0aW9uIG9mIHRoZSBkdXJhdGlvbnMgaXMgbGVzc1xuICAgKiB0aGFuIDEwMDAgbWlsbGlzZWNvbmRzLCB0aGUgY29ubmVjdGlvbiBpcyBjb25zaWRlcmVkIHRvIGJlIGZsYXBwaW5nLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBjb25uZWN0aW9uIGlzIGZsYXBwaW5nLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICovXG4gIGlzRmxhcHBpbmcoKSB7XG4gICAgY29uc3QgZHVyYXRpb25zID0gdGhpcy5fY29ubmVjdGlvblN0YXRzLmR1cmF0aW9ucztcbiAgICBpZiAoZHVyYXRpb25zLmxlbmd0aCAlIDMgIT09IDApIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBzdW0gPSBkdXJhdGlvbnMucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCk7XG4gICAgY29uc3QgYXZnID0gc3VtIC8gZHVyYXRpb25zLmxlbmd0aDtcbiAgICBjb25zdCB2YXJpYW5jZSA9IGR1cmF0aW9ucy5tYXAoKHgpID0+IE1hdGgucG93KHggLSBhdmcsIDIpKS5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKSAvIGR1cmF0aW9ucy5sZW5ndGg7XG4gICAgY29uc3Qgc3RkRGV2ID0gTWF0aC5zcXJ0KHZhcmlhbmNlKTtcbiAgICBjb25zdCBpc0ZsYXBwaW5nID0gc3RkRGV2IDwgRkxBUFBJTkdfVEhSRVNIT0xEX01TO1xuICAgIHJldHVybiBpc0ZsYXBwaW5nO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGVzIGEgbm90aWNlIHJlY2VpdmVkIGZyb20gdGhlIE5ESyByZWxheS5cbiAgICogSWYgdGhlIG5vdGljZSBpbmRpY2F0ZXMgdGhlIHJlbGF5IGlzIGNvbXBsYWluaW5nIChlLmcuIFwidG9vIG1hbnlcIiBvciBcIm1heGltdW1cIiksXG4gICAqIHRoZSBtZXRob2QgZGlzY29ubmVjdHMgZnJvbSB0aGUgcmVsYXkgYW5kIGF0dGVtcHRzIHRvIHJlY29ubmVjdCBhZnRlciBhIDItc2Vjb25kIGRlbGF5LlxuICAgKiBBIGRlYnVnIG1lc3NhZ2UgaXMgbG9nZ2VkIHdpdGggdGhlIHJlbGF5IFVSTCBhbmQgdGhlIG5vdGljZSB0ZXh0LlxuICAgKiBUaGUgXCJub3RpY2VcIiBldmVudCBpcyBlbWl0dGVkIG9uIHRoZSBuZGtSZWxheSBpbnN0YW5jZSB3aXRoIHRoZSBub3RpY2UgdGV4dC5cbiAgICpcbiAgICogQHBhcmFtIG5vdGljZSAtIFRoZSBub3RpY2UgdGV4dCByZWNlaXZlZCBmcm9tIHRoZSBOREsgcmVsYXkuXG4gICAqL1xuICBhc3luYyBvbk5vdGljZShub3RpY2UpIHtcbiAgICB0aGlzLm5ka1JlbGF5LmVtaXQoXCJub3RpY2VcIiwgbm90aWNlKTtcbiAgfVxuICAvKipcbiAgICogQXR0ZW1wdHMgdG8gcmVjb25uZWN0IHRvIHRoZSBOREsgcmVsYXkgYWZ0ZXIgYSBjb25uZWN0aW9uIGlzIGxvc3QuXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHJlY3Vyc2l2ZWx5IHRvIGhhbmRsZSBtdWx0aXBsZSByZWNvbm5lY3Rpb24gYXR0ZW1wdHMuXG4gICAqIEl0IGNoZWNrcyBpZiB0aGUgcmVsYXkgaXMgZmxhcHBpbmcgYW5kIGVtaXRzIGEgXCJmbGFwcGluZ1wiIGV2ZW50IGlmIHNvLlxuICAgKiBJdCB0aGVuIGNhbGN1bGF0ZXMgYSBkZWxheSBiZWZvcmUgdGhlIG5leHQgcmVjb25uZWN0aW9uIGF0dGVtcHQgYmFzZWQgb24gdGhlIG51bWJlciBvZiBwcmV2aW91cyBhdHRlbXB0cy5cbiAgICogVGhlIGZ1bmN0aW9uIHNldHMgYSB0aW1lb3V0IHRvIGV4ZWN1dGUgdGhlIG5leHQgcmVjb25uZWN0aW9uIGF0dGVtcHQgYWZ0ZXIgdGhlIGNhbGN1bGF0ZWQgZGVsYXkuXG4gICAqIElmIHRoZSBtYXhpbXVtIG51bWJlciBvZiByZWNvbm5lY3Rpb24gYXR0ZW1wdHMgaXMgcmVhY2hlZCwgYSBkZWJ1ZyBtZXNzYWdlIGlzIGxvZ2dlZC5cbiAgICpcbiAgICogQHBhcmFtIGF0dGVtcHQgLSBUaGUgY3VycmVudCBhdHRlbXB0IG51bWJlciAoZGVmYXVsdCBpcyAwKS5cbiAgICovXG4gIGhhbmRsZVJlY29ubmVjdGlvbihhdHRlbXB0ID0gMCkge1xuICAgIGlmICh0aGlzLnJlY29ubmVjdFRpbWVvdXQpIHJldHVybjtcbiAgICBpZiAodGhpcy5pc0ZsYXBwaW5nKCkpIHtcbiAgICAgIHRoaXMubmRrUmVsYXkuZW1pdChcImZsYXBwaW5nXCIsIHRoaXMuX2Nvbm5lY3Rpb25TdGF0cyk7XG4gICAgICB0aGlzLl9zdGF0dXMgPSAzIC8qIEZMQVBQSU5HICovO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZWNvbm5lY3REZWxheSA9IHRoaXMuY29ubmVjdGVkQXQgPyBNYXRoLm1heCgwLCA2ZTQgLSAoRGF0ZS5ub3coKSAtIHRoaXMuY29ubmVjdGVkQXQpKSA6IDVlMyAqICh0aGlzLl9jb25uZWN0aW9uU3RhdHMuYXR0ZW1wdHMgKyAxKTtcbiAgICB0aGlzLnJlY29ubmVjdFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMucmVjb25uZWN0VGltZW91dCA9IHZvaWQgMDtcbiAgICAgIHRoaXMuX3N0YXR1cyA9IDIgLyogUkVDT05ORUNUSU5HICovO1xuICAgICAgdGhpcy5jb25uZWN0KCkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICBpZiAoYXR0ZW1wdCA8IE1BWF9SRUNPTk5FQ1RfQVRURU1QVFMpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KFxuICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLmhhbmRsZVJlY29ubmVjdGlvbihhdHRlbXB0ICsgMSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgMWUzICogKGF0dGVtcHQgKyAxKSBeIDRcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZGVidWcoXCJSZWNvbm5lY3QgZmFpbGVkXCIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LCByZWNvbm5lY3REZWxheSk7XG4gICAgdGhpcy5uZGtSZWxheS5lbWl0KFwiZGVsYXllZC1jb25uZWN0XCIsIHJlY29ubmVjdERlbGF5KTtcbiAgICB0aGlzLmRlYnVnKFwiUmVjb25uZWN0aW5nIGluXCIsIHJlY29ubmVjdERlbGF5KTtcbiAgICB0aGlzLl9jb25uZWN0aW9uU3RhdHMubmV4dFJlY29ubmVjdEF0ID0gRGF0ZS5ub3coKSArIHJlY29ubmVjdERlbGF5O1xuICB9XG4gIC8qKlxuICAgKiBTZW5kcyBhIG1lc3NhZ2UgdG8gdGhlIE5ESyByZWxheSBpZiB0aGUgY29ubmVjdGlvbiBpcyBpbiB0aGUgQ09OTkVDVEVEIHN0YXRlIGFuZCB0aGUgV2ViU29ja2V0IGlzIG9wZW4uXG4gICAqIElmIHRoZSBjb25uZWN0aW9uIGlzIG5vdCBpbiB0aGUgQ09OTkVDVEVEIHN0YXRlIG9yIHRoZSBXZWJTb2NrZXQgaXMgbm90IG9wZW4sIGxvZ3MgYSBkZWJ1ZyBtZXNzYWdlIGFuZCB0aHJvd3MgYW4gZXJyb3IuXG4gICAqXG4gICAqIEBwYXJhbSBtZXNzYWdlIC0gVGhlIG1lc3NhZ2UgdG8gc2VuZCB0byB0aGUgTkRLIHJlbGF5LlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgYXR0ZW1wdGluZyB0byBzZW5kIG9uIGEgY2xvc2VkIHJlbGF5IGNvbm5lY3Rpb24uXG4gICAqL1xuICBhc3luYyBzZW5kKG1lc3NhZ2UpIHtcbiAgICBpZiAodGhpcy5fc3RhdHVzID49IDUgLyogQ09OTkVDVEVEICovICYmIHRoaXMud3M/LnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5PUEVOKSB7XG4gICAgICB0aGlzLndzPy5zZW5kKG1lc3NhZ2UpO1xuICAgICAgdGhpcy5uZXREZWJ1Zz8uKG1lc3NhZ2UsIHRoaXMubmRrUmVsYXksIFwic2VuZFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kZWJ1ZyhcbiAgICAgICAgYE5vdCBjb25uZWN0ZWQgdG8gJHt0aGlzLm5ka1JlbGF5LnVybH0gKCVkKSwgbm90IHNlbmRpbmcgbWVzc2FnZSAke21lc3NhZ2V9YCxcbiAgICAgICAgdGhpcy5fc3RhdHVzXG4gICAgICApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQXV0aGVudGljYXRlcyB0aGUgTkRLIGV2ZW50IGJ5IHNlbmRpbmcgaXQgdG8gdGhlIE5ESyByZWxheSBhbmQgcmV0dXJuaW5nIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIHJlc3VsdC5cbiAgICpcbiAgICogQHBhcmFtIGV2ZW50IC0gVGhlIE5ESyBldmVudCB0byBhdXRoZW50aWNhdGUuXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGF1dGhlbnRpY2F0aW9uIHJlc3VsdC5cbiAgICovXG4gIGFzeW5jIGF1dGgoZXZlbnQpIHtcbiAgICBjb25zdCByZXQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCB2YWwgPSB0aGlzLm9wZW5FdmVudFB1Ymxpc2hlcy5nZXQoZXZlbnQuaWQpID8/IFtdO1xuICAgICAgdmFsLnB1c2goeyByZXNvbHZlLCByZWplY3QgfSk7XG4gICAgICB0aGlzLm9wZW5FdmVudFB1Ymxpc2hlcy5zZXQoZXZlbnQuaWQsIHZhbCk7XG4gICAgfSk7XG4gICAgdGhpcy5zZW5kKCdbXCJBVVRIXCIsJyArIEpTT04uc3RyaW5naWZ5KGV2ZW50LnJhd0V2ZW50KCkpICsgXCJdXCIpO1xuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgLyoqXG4gICAqIFB1Ymxpc2hlcyBhbiBOREsgZXZlbnQgdG8gdGhlIHJlbGF5IGFuZCByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIHJlc3VsdC5cbiAgICpcbiAgICogQHBhcmFtIGV2ZW50IC0gVGhlIE5ESyBldmVudCB0byBwdWJsaXNoLlxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSByZXN1bHQgb2YgdGhlIGV2ZW50IHB1YmxpY2F0aW9uLlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgYXR0ZW1wdGluZyB0byBwdWJsaXNoIG9uIGEgY2xvc2VkIHJlbGF5IGNvbm5lY3Rpb24uXG4gICAqL1xuICBhc3luYyBwdWJsaXNoKGV2ZW50KSB7XG4gICAgY29uc3QgcmV0ID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgdmFsID0gdGhpcy5vcGVuRXZlbnRQdWJsaXNoZXMuZ2V0KGV2ZW50LmlkKSA/PyBbXTtcbiAgICAgIGlmICh2YWwubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgXCJEdXBsaWNhdGUgZXZlbnQgcHVibGlzaGluZyBkZXRlY3RlZCwgeW91IGFyZSBwdWJsaXNoaW5nIGV2ZW50IFwiICsgZXZlbnQuaWQgKyBcIiB0d2ljZVwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB2YWwucHVzaCh7IHJlc29sdmUsIHJlamVjdCB9KTtcbiAgICAgIHRoaXMub3BlbkV2ZW50UHVibGlzaGVzLnNldChldmVudC5pZCwgdmFsKTtcbiAgICB9KTtcbiAgICB0aGlzLnNlbmQoJ1tcIkVWRU5UXCIsJyArIEpTT04uc3RyaW5naWZ5KGV2ZW50KSArIFwiXVwiKTtcbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIC8qKlxuICAgKiBDb3VudHMgdGhlIG51bWJlciBvZiBldmVudHMgdGhhdCBtYXRjaCB0aGUgcHJvdmlkZWQgZmlsdGVycy5cbiAgICpcbiAgICogQHBhcmFtIGZpbHRlcnMgLSBUaGUgZmlsdGVycyB0byBhcHBseSB0byB0aGUgY291bnQgcmVxdWVzdC5cbiAgICogQHBhcmFtIHBhcmFtcyAtIEFuIG9wdGlvbmFsIG9iamVjdCBjb250YWluaW5nIGEgY3VzdG9tIGlkIGZvciB0aGUgY291bnQgcmVxdWVzdC5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgbnVtYmVyIG9mIG1hdGNoaW5nIGV2ZW50cy5cbiAgICogQHRocm93cyB7RXJyb3J9IElmIGF0dGVtcHRpbmcgdG8gc2VuZCB0aGUgY291bnQgcmVxdWVzdCBvbiBhIGNsb3NlZCByZWxheSBjb25uZWN0aW9uLlxuICAgKi9cbiAgYXN5bmMgY291bnQoZmlsdGVycywgcGFyYW1zKSB7XG4gICAgdGhpcy5zZXJpYWwrKztcbiAgICBjb25zdCBpZCA9IHBhcmFtcz8uaWQgfHwgXCJjb3VudDpcIiArIHRoaXMuc2VyaWFsO1xuICAgIGNvbnN0IHJldCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMub3BlbkNvdW50UmVxdWVzdHMuc2V0KGlkLCB7IHJlc29sdmUsIHJlamVjdCB9KTtcbiAgICB9KTtcbiAgICB0aGlzLnNlbmQoJ1tcIkNPVU5UXCIsXCInICsgaWQgKyAnXCIsJyArIEpTT04uc3RyaW5naWZ5KGZpbHRlcnMpLnN1YnN0cmluZygxKSk7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBjbG9zZShzdWJJZCwgcmVhc29uKSB7XG4gICAgdGhpcy5zZW5kKCdbXCJDTE9TRVwiLFwiJyArIHN1YklkICsgJ1wiXScpO1xuICAgIGNvbnN0IHN1YiA9IHRoaXMub3BlblN1YnMuZ2V0KHN1YklkKTtcbiAgICB0aGlzLm9wZW5TdWJzLmRlbGV0ZShzdWJJZCk7XG4gICAgaWYgKHN1Yikgc3ViLm9uY2xvc2UocmVhc29uKTtcbiAgfVxuICAvKipcbiAgICogU3Vic2NyaWJlcyB0byB0aGUgTkRLIHJlbGF5IHdpdGggdGhlIHByb3ZpZGVkIGZpbHRlcnMgYW5kIHBhcmFtZXRlcnMuXG4gICAqXG4gICAqIEBwYXJhbSBmaWx0ZXJzIC0gVGhlIGZpbHRlcnMgdG8gYXBwbHkgdG8gdGhlIHN1YnNjcmlwdGlvbi5cbiAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBzdWJzY3JpcHRpb24gcGFyYW1ldGVycywgaW5jbHVkaW5nIGFuIG9wdGlvbmFsIGN1c3RvbSBpZC5cbiAgICogQHJldHVybnMgQSBuZXcgTkRLUmVsYXlTdWJzY3JpcHRpb24gaW5zdGFuY2UuXG4gICAqL1xuICByZXEocmVsYXlTdWIpIHtcbiAgICB0aGlzLnNlbmQoXG4gICAgICAnW1wiUkVRXCIsXCInICsgcmVsYXlTdWIuc3ViSWQgKyAnXCIsJyArIEpTT04uc3RyaW5naWZ5KHJlbGF5U3ViLmV4ZWN1dGVGaWx0ZXJzKS5zdWJzdHJpbmcoMSlcbiAgICApICsgXCJdXCI7XG4gICAgdGhpcy5vcGVuU3Vicy5zZXQocmVsYXlTdWIuc3ViSWQsIHJlbGF5U3ViKTtcbiAgfVxuICAvKipcbiAgICogVXRpbGl0eSBmdW5jdGlvbnMgdG8gdXBkYXRlIHRoZSBjb25uZWN0aW9uIHN0YXRzLlxuICAgKi9cbiAgdXBkYXRlQ29ubmVjdGlvblN0YXRzID0ge1xuICAgIGNvbm5lY3RlZDogKCkgPT4ge1xuICAgICAgdGhpcy5fY29ubmVjdGlvblN0YXRzLnN1Y2Nlc3MrKztcbiAgICAgIHRoaXMuX2Nvbm5lY3Rpb25TdGF0cy5jb25uZWN0ZWRBdCA9IERhdGUubm93KCk7XG4gICAgfSxcbiAgICBkaXNjb25uZWN0ZWQ6ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLl9jb25uZWN0aW9uU3RhdHMuY29ubmVjdGVkQXQpIHtcbiAgICAgICAgdGhpcy5fY29ubmVjdGlvblN0YXRzLmR1cmF0aW9ucy5wdXNoKFxuICAgICAgICAgIERhdGUubm93KCkgLSB0aGlzLl9jb25uZWN0aW9uU3RhdHMuY29ubmVjdGVkQXRcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHRoaXMuX2Nvbm5lY3Rpb25TdGF0cy5kdXJhdGlvbnMubGVuZ3RoID4gMTAwKSB7XG4gICAgICAgICAgdGhpcy5fY29ubmVjdGlvblN0YXRzLmR1cmF0aW9ucy5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9jb25uZWN0aW9uU3RhdHMuY29ubmVjdGVkQXQgPSB2b2lkIDA7XG4gICAgfSxcbiAgICBhdHRlbXB0OiAoKSA9PiB7XG4gICAgICB0aGlzLl9jb25uZWN0aW9uU3RhdHMuYXR0ZW1wdHMrKztcbiAgICAgIHRoaXMuX2Nvbm5lY3Rpb25TdGF0cy5jb25uZWN0ZWRBdCA9IERhdGUubm93KCk7XG4gICAgfVxuICB9O1xuICAvKiogUmV0dXJucyB0aGUgY29ubmVjdGlvbiBzdGF0cy4gKi9cbiAgZ2V0IGNvbm5lY3Rpb25TdGF0cygpIHtcbiAgICByZXR1cm4gdGhpcy5fY29ubmVjdGlvblN0YXRzO1xuICB9XG4gIC8qKiBSZXR1cm5zIHRoZSByZWxheSBVUkwgKi9cbiAgZ2V0IHVybCgpIHtcbiAgICByZXR1cm4gdGhpcy5uZGtSZWxheS51cmw7XG4gIH1cbiAgZ2V0IGNvbm5lY3RlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdHVzID49IDUgLyogQ09OTkVDVEVEICovICYmIHRoaXMud3M/LnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5PUEVOO1xuICB9XG59O1xuXG4vLyBzcmMvcmVsYXkvcHVibGlzaGVyLnRzXG52YXIgTkRLUmVsYXlQdWJsaXNoZXIgPSBjbGFzcyB7XG4gIG5ka1JlbGF5O1xuICBkZWJ1ZztcbiAgY29uc3RydWN0b3IobmRrUmVsYXkpIHtcbiAgICB0aGlzLm5ka1JlbGF5ID0gbmRrUmVsYXk7XG4gICAgdGhpcy5kZWJ1ZyA9IG5ka1JlbGF5LmRlYnVnLmV4dGVuZChcInB1Ymxpc2hlclwiKTtcbiAgfVxuICAvKipcbiAgICogUHVibGlzaGVkIGFuIGV2ZW50IHRvIHRoZSByZWxheTsgaWYgdGhlIHJlbGF5IGlzIG5vdCBjb25uZWN0ZWQsIGl0IHdpbGxcbiAgICogd2FpdCBmb3IgdGhlIHJlbGF5IHRvIGNvbm5lY3QgYmVmb3JlIHB1Ymxpc2hpbmcgdGhlIGV2ZW50LlxuICAgKlxuICAgKiBJZiB0aGUgcmVsYXkgZG9lcyBub3QgY29ubmVjdCB3aXRoaW4gdGhlIHRpbWVvdXQsIHRoZSBwdWJsaXNoIG9wZXJhdGlvblxuICAgKiB3aWxsIGZhaWwuXG4gICAqIEBwYXJhbSBldmVudCAgVGhlIGV2ZW50IHRvIHB1Ymxpc2hcbiAgICogQHBhcmFtIHRpbWVvdXRNcyAgVGhlIHRpbWVvdXQgZm9yIHRoZSBwdWJsaXNoIG9wZXJhdGlvbiBpbiBtaWxsaXNlY29uZHNcbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgZXZlbnQgaGFzIGJlZW4gcHVibGlzaGVkIG9yIHJlamVjdHMgaWYgdGhlIG9wZXJhdGlvbiB0aW1lcyBvdXRcbiAgICovXG4gIGFzeW5jIHB1Ymxpc2goZXZlbnQsIHRpbWVvdXRNcyA9IDI1MDApIHtcbiAgICBsZXQgdGltZW91dDtcbiAgICBjb25zdCBwdWJsaXNoQ29ubmVjdGVkID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLnB1Ymxpc2hFdmVudChldmVudCkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLm5ka1JlbGF5LmVtaXQoXCJwdWJsaXNoZWRcIiwgZXZlbnQpO1xuICAgICAgICAgICAgZXZlbnQuZW1pdChcInJlbGF5OnB1Ymxpc2hlZFwiLCB0aGlzLm5ka1JlbGF5KTtcbiAgICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgdGltZW91dFByb21pc2UgPSBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiB7XG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRpbWVvdXQgPSB2b2lkIDA7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJUaW1lb3V0OiBcIiArIHRpbWVvdXRNcyArIFwibXNcIikpO1xuICAgICAgfSwgdGltZW91dE1zKTtcbiAgICB9KTtcbiAgICBjb25zdCBvbkNvbm5lY3RIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgcHVibGlzaENvbm5lY3RlZCgpLnRoZW4oKHJlc3VsdCkgPT4gY29ubmVjdFJlc29sdmUocmVzdWx0KSkuY2F0Y2goKGVycikgPT4gY29ubmVjdFJlamVjdChlcnIpKTtcbiAgICB9O1xuICAgIGxldCBjb25uZWN0UmVzb2x2ZTtcbiAgICBsZXQgY29ubmVjdFJlamVjdDtcbiAgICBjb25zdCBvbkVycm9yID0gKGVycikgPT4ge1xuICAgICAgdGhpcy5uZGtSZWxheS5kZWJ1ZyhcIlB1Ymxpc2ggZmFpbGVkXCIsIGVyciwgZXZlbnQuaWQpO1xuICAgICAgdGhpcy5uZGtSZWxheS5lbWl0KFwicHVibGlzaDpmYWlsZWRcIiwgZXZlbnQsIGVycik7XG4gICAgICBldmVudC5lbWl0KFwicmVsYXk6cHVibGlzaDpmYWlsZWRcIiwgdGhpcy5uZGtSZWxheSwgZXJyKTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9O1xuICAgIGNvbnN0IG9uRmluYWxseSA9ICgpID0+IHtcbiAgICAgIGlmICh0aW1lb3V0KSBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICB0aGlzLm5ka1JlbGF5LnJlbW92ZUxpc3RlbmVyKFwiY29ubmVjdFwiLCBvbkNvbm5lY3RIYW5kbGVyKTtcbiAgICB9O1xuICAgIGlmICh0aGlzLm5ka1JlbGF5LnN0YXR1cyA+PSA1IC8qIENPTk5FQ1RFRCAqLykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmFjZShbcHVibGlzaENvbm5lY3RlZCgpLCB0aW1lb3V0UHJvbWlzZV0pLmNhdGNoKG9uRXJyb3IpLmZpbmFsbHkob25GaW5hbGx5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMubmRrUmVsYXkuc3RhdHVzIDw9IDEgLyogRElTQ09OTkVDVEVEICovKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBcIlJlbGF5IGlzIGRpc2Nvbm5lY3RlZCwgdHJ5aW5nIHRvIGNvbm5lY3QgdG8gcHVibGlzaCBhbiBldmVudFwiLFxuICAgICAgICAgIHRoaXMubmRrUmVsYXkudXJsXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMubmRrUmVsYXkuY29ubmVjdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIFwiUmVsYXkgbm90IGNvbm5lY3RlZCwgd2FpdGluZyBmb3IgY29ubmVjdGlvbiB0byBwdWJsaXNoIGFuIGV2ZW50XCIsXG4gICAgICAgICAgdGhpcy5uZGtSZWxheS51cmxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm9taXNlLnJhY2UoW1xuICAgICAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgY29ubmVjdFJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgIGNvbm5lY3RSZWplY3QgPSByZWplY3Q7XG4gICAgICAgICAgdGhpcy5uZGtSZWxheS5vbmNlKFwiY29ubmVjdFwiLCBvbkNvbm5lY3RIYW5kbGVyKTtcbiAgICAgICAgfSksXG4gICAgICAgIHRpbWVvdXRQcm9taXNlXG4gICAgICBdKS5jYXRjaChvbkVycm9yKS5maW5hbGx5KG9uRmluYWxseSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIHB1Ymxpc2hFdmVudChldmVudCkge1xuICAgIHJldHVybiB0aGlzLm5ka1JlbGF5LmNvbm5lY3Rpdml0eS5wdWJsaXNoKGV2ZW50LnJhd0V2ZW50KCkpO1xuICB9XG59O1xuXG4vLyBzcmMvc3Vic2NyaXB0aW9uL2dyb3VwaW5nLnRzXG5mdW5jdGlvbiBmaWx0ZXJGaW5nZXJwcmludChmaWx0ZXJzLCBjbG9zZU9uRW9zZSkge1xuICBjb25zdCBlbGVtZW50cyA9IFtdO1xuICBmb3IgKGNvbnN0IGZpbHRlciBvZiBmaWx0ZXJzKSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5lbnRyaWVzKGZpbHRlciB8fCB7fSkubWFwKChba2V5LCB2YWx1ZXNdKSA9PiB7XG4gICAgICBpZiAoW1wic2luY2VcIiwgXCJ1bnRpbFwiXS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgIHJldHVybiBrZXkgKyBcIjpcIiArIHZhbHVlcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgICB9XG4gICAgfSkuc29ydCgpLmpvaW4oXCItXCIpO1xuICAgIGVsZW1lbnRzLnB1c2goa2V5cyk7XG4gIH1cbiAgbGV0IGlkID0gY2xvc2VPbkVvc2UgPyBcIitcIiA6IFwiXCI7XG4gIGlkICs9IGVsZW1lbnRzLmpvaW4oXCJ8XCIpO1xuICByZXR1cm4gaWQ7XG59XG5mdW5jdGlvbiBtZXJnZUZpbHRlcnMoZmlsdGVycykge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgY29uc3QgbGFzdFJlc3VsdCA9IHt9O1xuICBmaWx0ZXJzLmZpbHRlcigoZikgPT4gISFmLmxpbWl0KS5mb3JFYWNoKChmaWx0ZXJXaXRoTGltaXQpID0+IHJlc3VsdC5wdXNoKGZpbHRlcldpdGhMaW1pdCkpO1xuICBmaWx0ZXJzID0gZmlsdGVycy5maWx0ZXIoKGYpID0+ICFmLmxpbWl0KTtcbiAgaWYgKGZpbHRlcnMubGVuZ3RoID09PSAwKSByZXR1cm4gcmVzdWx0O1xuICBmaWx0ZXJzLmZvckVhY2goKGZpbHRlcikgPT4ge1xuICAgIE9iamVjdC5lbnRyaWVzKGZpbHRlcikuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKGxhc3RSZXN1bHRba2V5XSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgbGFzdFJlc3VsdFtrZXldID0gWy4uLnZhbHVlXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsYXN0UmVzdWx0W2tleV0gPSBBcnJheS5mcm9tKC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFsuLi5sYXN0UmVzdWx0W2tleV0sIC4uLnZhbHVlXSkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYXN0UmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBbLi4ucmVzdWx0LCBsYXN0UmVzdWx0XTtcbn1cblxuLy8gc3JjL3JlbGF5L3N1YnNjcmlwdGlvbi50c1xudmFyIE5ES1JlbGF5U3Vic2NyaXB0aW9uID0gY2xhc3Mge1xuICBmaW5nZXJwcmludDtcbiAgaXRlbXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB0b3BTdWJNYW5hZ2VyO1xuICBkZWJ1ZztcbiAgLyoqXG4gICAqIFRyYWNrcyB0aGUgc3RhdHVzIG9mIHRoaXMgUkVRLlxuICAgKi9cbiAgc3RhdHVzID0gMCAvKiBJTklUSUFMICovO1xuICBvbkNsb3NlO1xuICByZWxheTtcbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhpcyBzdWJzY3JpcHRpb24gaGFzIHJlYWNoZWQgRU9TRS5cbiAgICovXG4gIGVvc2VkID0gZmFsc2U7XG4gIC8qKlxuICAgKiBUaW1lb3V0IGF0IHdoaWNoIHRoaXMgc3Vic2NyaXB0aW9uIHdpbGxcbiAgICogc3RhcnQgZXhlY3V0aW5nLlxuICAgKi9cbiAgZXhlY3V0aW9uVGltZXI7XG4gIC8qKlxuICAgKiBUcmFjayB0aGUgdGltZSBhdCB3aGljaCB0aGlzIHN1YnNjcmlwdGlvbiB3aWxsIGZpcmUuXG4gICAqL1xuICBmaXJlVGltZTtcbiAgLyoqXG4gICAqIFRoZSBkZWxheSB0eXBlIHRoYXQgdGhlIGN1cnJlbnQgZmlyZVRpbWUgd2FzIGNhbGN1bGF0ZWQgd2l0aC5cbiAgICovXG4gIGRlbGF5VHlwZTtcbiAgLyoqXG4gICAqIFRoZSBmaWx0ZXJzIHRoYXQgaGF2ZSBiZWVuIGV4ZWN1dGVkLlxuICAgKi9cbiAgZXhlY3V0ZUZpbHRlcnM7XG4gIGlkID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDcpO1xuICAvKipcbiAgICpcbiAgICogQHBhcmFtIGZpbmdlcnByaW50IFRoZSBmaW5nZXJwcmludCBvZiB0aGlzIHN1YnNjcmlwdGlvbi5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHJlbGF5LCBmaW5nZXJwcmludCwgdG9wU3ViTWFuYWdlcikge1xuICAgIHRoaXMucmVsYXkgPSByZWxheTtcbiAgICB0aGlzLnRvcFN1Yk1hbmFnZXIgPSB0b3BTdWJNYW5hZ2VyO1xuICAgIHRoaXMuZGVidWcgPSByZWxheS5kZWJ1Zy5leHRlbmQoXCJzdWJzY3JpcHRpb24tXCIgKyB0aGlzLmlkKTtcbiAgICB0aGlzLmZpbmdlcnByaW50ID0gZmluZ2VycHJpbnQgfHwgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDcpO1xuICB9XG4gIF9zdWJJZDtcbiAgZ2V0IHN1YklkKCkge1xuICAgIGlmICh0aGlzLl9zdWJJZCkgcmV0dXJuIHRoaXMuX3N1YklkO1xuICAgIHRoaXMuX3N1YklkID0gdGhpcy5maW5nZXJwcmludC5zbGljZSgwLCAxNSk7XG4gICAgcmV0dXJuIHRoaXMuX3N1YklkO1xuICB9XG4gIHN1YklkUGFydHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBhZGRTdWJJZFBhcnQocGFydCkge1xuICAgIHRoaXMuc3ViSWRQYXJ0cy5hZGQocGFydCk7XG4gIH1cbiAgYWRkSXRlbShzdWJzY3JpcHRpb24sIGZpbHRlcnMpIHtcbiAgICB0aGlzLmRlYnVnKFwiQWRkaW5nIGl0ZW1cIiwgeyBmaWx0ZXJzLCBpbnRlcm5hbElkOiBzdWJzY3JpcHRpb24uaW50ZXJuYWxJZCwgc3RhdHVzOiB0aGlzLnN0YXR1cywgZmluZ2VycHJpbnQ6IHRoaXMuZmluZ2VycHJpbnQsIGlkOiB0aGlzLnN1YklkLCBpdGVtczogdGhpcy5pdGVtcywgaXRlbXNTaXplOiB0aGlzLml0ZW1zLnNpemUgfSk7XG4gICAgaWYgKHRoaXMuaXRlbXMuaGFzKHN1YnNjcmlwdGlvbi5pbnRlcm5hbElkKSkgcmV0dXJuO1xuICAgIHN1YnNjcmlwdGlvbi5vbihcImNsb3NlXCIsIHRoaXMucmVtb3ZlSXRlbS5iaW5kKHRoaXMsIHN1YnNjcmlwdGlvbikpO1xuICAgIHRoaXMuaXRlbXMuc2V0KHN1YnNjcmlwdGlvbi5pbnRlcm5hbElkLCB7IHN1YnNjcmlwdGlvbiwgZmlsdGVycyB9KTtcbiAgICBpZiAodGhpcy5zdGF0dXMgIT09IDMgLyogUlVOTklORyAqLykge1xuICAgICAgaWYgKHN1YnNjcmlwdGlvbi5zdWJJZCAmJiAoIXRoaXMuX3N1YklkIHx8IHRoaXMuX3N1YklkLmxlbmd0aCA8IDQ4KSkge1xuICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IDAgLyogSU5JVElBTCAqLyB8fCB0aGlzLnN0YXR1cyA9PT0gMSAvKiBQRU5ESU5HICovKSB7XG4gICAgICAgICAgdGhpcy5hZGRTdWJJZFBhcnQoc3Vic2NyaXB0aW9uLnN1YklkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBzd2l0Y2ggKHRoaXMuc3RhdHVzKSB7XG4gICAgICBjYXNlIDAgLyogSU5JVElBTCAqLzpcbiAgICAgICAgdGhpcy5ldmFsdWF0ZUV4ZWN1dGlvblBsYW4oc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDMgLyogUlVOTklORyAqLzpcbiAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgXCJCVUc6IFRoaXMgc2hvdWxkIG5vdCBoYXBwZW46IFRoaXMgc3Vic2NyaXB0aW9uIG5lZWRzIHRvIGNhdGNoIHVwIHdpdGggYSBzdWJzY3JpcHRpb24gdGhhdCB3YXMgYWxyZWFkeSBydW5uaW5nXCIsXG4gICAgICAgICAgZmlsdGVyc1xuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMSAvKiBQRU5ESU5HICovOlxuICAgICAgICB0aGlzLmV2YWx1YXRlRXhlY3V0aW9uUGxhbihzdWJzY3JpcHRpb24pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNCAvKiBDTE9TRUQgKi86XG4gICAgICAgIHRoaXMuZGVidWcoXG4gICAgICAgICAgXCJTdWJzY3JpcHRpb24gaXMgY2xvc2VkLCBjYW5ub3QgYWRkIG5ldyBpdGVtcyAlbyAoJW8pXCIsXG4gICAgICAgICAgc3Vic2NyaXB0aW9uLFxuICAgICAgICAgIGZpbHRlcnNcbiAgICAgICAgKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGFkZCBuZXcgaXRlbXMgdG8gYSBjbG9zZWQgc3Vic2NyaXB0aW9uXCIpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQSBzdWJzY3JpcHRpb24gaGFzIGJlZW4gY2xvc2VkLCByZW1vdmUgaXQgZnJvbSB0aGUgbGlzdCBvZiBpdGVtcy5cbiAgICogQHBhcmFtIHN1YnNjcmlwdGlvblxuICAgKi9cbiAgcmVtb3ZlSXRlbShzdWJzY3JpcHRpb24pIHtcbiAgICB0aGlzLml0ZW1zLmRlbGV0ZShzdWJzY3JpcHRpb24uaW50ZXJuYWxJZCk7XG4gICAgaWYgKHRoaXMuaXRlbXMuc2l6ZSA9PT0gMCkge1xuICAgICAgaWYgKCF0aGlzLmVvc2VkKSByZXR1cm47XG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICB0aGlzLmNsZWFudXAoKTtcbiAgICB9XG4gIH1cbiAgY2xvc2UoKSB7XG4gICAgaWYgKHRoaXMuc3RhdHVzID09PSA0IC8qIENMT1NFRCAqLykgcmV0dXJuO1xuICAgIGNvbnN0IHByZXZTdGF0dXMgPSB0aGlzLnN0YXR1cztcbiAgICB0aGlzLnN0YXR1cyA9IDQgLyogQ0xPU0VEICovO1xuICAgIGlmIChwcmV2U3RhdHVzID09PSAzIC8qIFJVTk5JTkcgKi8pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMucmVsYXkuY2xvc2UodGhpcy5zdWJJZCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRoaXMuZGVidWcoXCJFcnJvciBjbG9zaW5nIHN1YnNjcmlwdGlvblwiLCBlLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kZWJ1ZyhcIlN1YnNjcmlwdGlvbiB3YW50ZWQgdG8gY2xvc2UgYnV0IGl0IHdhc24ndCBydW5uaW5nLCB0aGlzIGlzIHByb2JhYmx5IG9rXCIsIHtcbiAgICAgICAgc3ViSWQ6IHRoaXMuc3ViSWQsXG4gICAgICAgIHByZXZTdGF0dXMsXG4gICAgICAgIHN1YjogdGhpc1xuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuY2xlYW51cCgpO1xuICB9XG4gIGNsZWFudXAoKSB7XG4gICAgaWYgKHRoaXMuZXhlY3V0aW9uVGltZXIpIGNsZWFyVGltZW91dCh0aGlzLmV4ZWN1dGlvblRpbWVyKTtcbiAgICB0aGlzLnJlbGF5Lm9mZihcInJlYWR5XCIsIHRoaXMuZXhlY3V0ZU9uUmVsYXlSZWFkeSk7XG4gICAgdGhpcy5yZWxheS5vZmYoXCJhdXRoZWRcIiwgdGhpcy5yZUV4ZWN1dGVBZnRlckF1dGgpO1xuICAgIGlmICh0aGlzLm9uQ2xvc2UpIHRoaXMub25DbG9zZSh0aGlzKTtcbiAgfVxuICBldmFsdWF0ZUV4ZWN1dGlvblBsYW4oc3Vic2NyaXB0aW9uKSB7XG4gICAgaWYgKCFzdWJzY3JpcHRpb24uaXNHcm91cGFibGUoKSkge1xuICAgICAgdGhpcy5zdGF0dXMgPSAxIC8qIFBFTkRJTkcgKi87XG4gICAgICB0aGlzLmV4ZWN1dGUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHN1YnNjcmlwdGlvbi5maWx0ZXJzLmZpbmQoKGZpbHRlcikgPT4gISFmaWx0ZXIubGltaXQpKSB7XG4gICAgICB0aGlzLmV4ZWN1dGVGaWx0ZXJzID0gdGhpcy5jb21waWxlRmlsdGVycygpO1xuICAgICAgaWYgKHRoaXMuZXhlY3V0ZUZpbHRlcnMubGVuZ3RoID49IDEwKSB7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gMSAvKiBQRU5ESU5HICovO1xuICAgICAgICB0aGlzLmV4ZWN1dGUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBkZWxheSA9IHN1YnNjcmlwdGlvbi5ncm91cGFibGVEZWxheTtcbiAgICBjb25zdCBkZWxheVR5cGUgPSBzdWJzY3JpcHRpb24uZ3JvdXBhYmxlRGVsYXlUeXBlO1xuICAgIGlmICghZGVsYXkpIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBncm91cCBhIHN1YnNjcmlwdGlvbiB3aXRob3V0IGEgZGVsYXlcIik7XG4gICAgaWYgKHRoaXMuc3RhdHVzID09PSAwIC8qIElOSVRJQUwgKi8pIHtcbiAgICAgIHRoaXMuc2NoZWR1bGUoZGVsYXksIGRlbGF5VHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nRGVsYXlUeXBlID0gdGhpcy5kZWxheVR5cGU7XG4gICAgICBjb25zdCB0aW1lVW50aWxGaXJlID0gdGhpcy5maXJlVGltZSAtIERhdGUubm93KCk7XG4gICAgICBpZiAoZXhpc3RpbmdEZWxheVR5cGUgPT09IFwiYXQtbGVhc3RcIiAmJiBkZWxheVR5cGUgPT09IFwiYXQtbGVhc3RcIikge1xuICAgICAgICBpZiAodGltZVVudGlsRmlyZSA8IGRlbGF5KSB7XG4gICAgICAgICAgaWYgKHRoaXMuZXhlY3V0aW9uVGltZXIpIGNsZWFyVGltZW91dCh0aGlzLmV4ZWN1dGlvblRpbWVyKTtcbiAgICAgICAgICB0aGlzLnNjaGVkdWxlKGRlbGF5LCBkZWxheVR5cGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGV4aXN0aW5nRGVsYXlUeXBlID09PSBcImF0LWxlYXN0XCIgJiYgZGVsYXlUeXBlID09PSBcImF0LW1vc3RcIikge1xuICAgICAgICBpZiAodGltZVVudGlsRmlyZSA+IGRlbGF5KSB7XG4gICAgICAgICAgaWYgKHRoaXMuZXhlY3V0aW9uVGltZXIpIGNsZWFyVGltZW91dCh0aGlzLmV4ZWN1dGlvblRpbWVyKTtcbiAgICAgICAgICB0aGlzLnNjaGVkdWxlKGRlbGF5LCBkZWxheVR5cGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGV4aXN0aW5nRGVsYXlUeXBlID09PSBcImF0LW1vc3RcIiAmJiBkZWxheVR5cGUgPT09IFwiYXQtbW9zdFwiKSB7XG4gICAgICAgIGlmICh0aW1lVW50aWxGaXJlID4gZGVsYXkpIHtcbiAgICAgICAgICBpZiAodGhpcy5leGVjdXRpb25UaW1lcikgY2xlYXJUaW1lb3V0KHRoaXMuZXhlY3V0aW9uVGltZXIpO1xuICAgICAgICAgIHRoaXMuc2NoZWR1bGUoZGVsYXksIGRlbGF5VHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZXhpc3RpbmdEZWxheVR5cGUgPT09IFwiYXQtbW9zdFwiICYmIGRlbGF5VHlwZSA9PT0gXCJhdC1sZWFzdFwiKSB7XG4gICAgICAgIGlmICh0aW1lVW50aWxGaXJlID4gZGVsYXkpIHtcbiAgICAgICAgICBpZiAodGhpcy5leGVjdXRpb25UaW1lcikgY2xlYXJUaW1lb3V0KHRoaXMuZXhlY3V0aW9uVGltZXIpO1xuICAgICAgICAgIHRoaXMuc2NoZWR1bGUoZGVsYXksIGRlbGF5VHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIlVua25vd24gZGVsYXkgdHlwZSBjb21iaW5hdGlvbiBcIiArIGV4aXN0aW5nRGVsYXlUeXBlICsgXCIgXCIgKyBkZWxheVR5cGVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc2NoZWR1bGUoZGVsYXksIGRlbGF5VHlwZSkge1xuICAgIHRoaXMuc3RhdHVzID0gMSAvKiBQRU5ESU5HICovO1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICB0aGlzLmZpcmVUaW1lID0gY3VycmVudFRpbWUgKyBkZWxheTtcbiAgICB0aGlzLmRlbGF5VHlwZSA9IGRlbGF5VHlwZTtcbiAgICBjb25zdCB0aW1lciA9IHNldFRpbWVvdXQodGhpcy5leGVjdXRlLmJpbmQodGhpcyksIGRlbGF5KTtcbiAgICBpZiAoZGVsYXlUeXBlID09PSBcImF0LWxlYXN0XCIpIHtcbiAgICAgIHRoaXMuZXhlY3V0aW9uVGltZXIgPSB0aW1lcjtcbiAgICB9XG4gIH1cbiAgZXhlY3V0ZU9uUmVsYXlSZWFkeSA9ICgpID0+IHtcbiAgICBpZiAodGhpcy5zdGF0dXMgIT09IDIgLyogV0FJVElORyAqLykgcmV0dXJuO1xuICAgIGlmICh0aGlzLml0ZW1zLnNpemUgPT09IDApIHtcbiAgICAgIHRoaXMuZGVidWcoXCJObyBpdGVtcyB0byBleGVjdXRlOyB0aGlzIHJlbGF5IHdhcyBwcm9iYWJseSB0b28gc2xvdyB0byByZXNwb25kIGFuZCB0aGUgY2FsbGVyIGdhdmUgdXBcIiwgeyBzdGF0dXM6IHRoaXMuc3RhdHVzLCBmaW5nZXJwcmludDogdGhpcy5maW5nZXJwcmludCwgaXRlbXM6IHRoaXMuaXRlbXMsIGl0ZW1zU2l6ZTogdGhpcy5pdGVtcy5zaXplLCBpZDogdGhpcy5pZCwgc3ViSWQ6IHRoaXMuc3ViSWQgfSk7XG4gICAgICB0aGlzLmNsZWFudXAoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5kZWJ1ZyhcIkV4ZWN1dGluZyBvbiByZWxheSByZWFkeVwiLCB7IHN0YXR1czogdGhpcy5zdGF0dXMsIGZpbmdlcnByaW50OiB0aGlzLmZpbmdlcnByaW50LCBpdGVtczogdGhpcy5pdGVtcywgaXRlbXNTaXplOiB0aGlzLml0ZW1zLnNpemUgfSk7XG4gICAgdGhpcy5zdGF0dXMgPSAxIC8qIFBFTkRJTkcgKi87XG4gICAgdGhpcy5leGVjdXRlKCk7XG4gIH07XG4gIGZpbmFsaXplU3ViSWQoKSB7XG4gICAgaWYgKHRoaXMuc3ViSWRQYXJ0cy5zaXplID4gMCkge1xuICAgICAgdGhpcy5fc3ViSWQgPSBBcnJheS5mcm9tKHRoaXMuc3ViSWRQYXJ0cykuam9pbihcIi1cIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3N1YklkID0gdGhpcy5maW5nZXJwcmludC5zbGljZSgwLCAxNSk7XG4gICAgfVxuICAgIHRoaXMuX3N1YklkICs9IFwiLVwiICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDcpO1xuICB9XG4gIC8vIHdlIGRvIGl0IHRoaXMgd2F5IHNvIHRoYXQgd2UgY2FuIHJlbW92ZSB0aGUgbGlzdGVuZXJcbiAgcmVFeGVjdXRlQWZ0ZXJBdXRoID0gKCgpID0+IHtcbiAgICBjb25zdCBvbGRTdWJJZCA9IHRoaXMuc3ViSWQ7XG4gICAgdGhpcy5kZWJ1ZyhcIlJlLWV4ZWN1dGluZyBhZnRlciBhdXRoXCIsIHRoaXMuaXRlbXMuc2l6ZSk7XG4gICAgaWYgKHRoaXMuZW9zZWQpIHtcbiAgICAgIHRoaXMucmVsYXkuY2xvc2UodGhpcy5zdWJJZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVidWcoXG4gICAgICAgIFwiV2UgYXJlIGFiYW5kb25pbmcgYW4gb3BlbmVkIHN1YnNjcmlwdGlvbiwgb25jZSBpdCBFT1NFJ3MsIHRoZSBoYW5kbGVyIHdpbGwgY2xvc2UgaXRcIixcbiAgICAgICAgeyBvbGRTdWJJZCB9XG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLl9zdWJJZCA9IHZvaWQgMDtcbiAgICB0aGlzLnN0YXR1cyA9IDEgLyogUEVORElORyAqLztcbiAgICB0aGlzLmV4ZWN1dGUoKTtcbiAgICB0aGlzLmRlYnVnKFwiUmUtZXhlY3V0ZWQgYWZ0ZXIgYXV0aCAlcyBcXHV7MUY0NDl9ICVzXCIsIG9sZFN1YklkLCB0aGlzLnN1YklkKTtcbiAgfSkuYmluZCh0aGlzKTtcbiAgZXhlY3V0ZSgpIHtcbiAgICBpZiAodGhpcy5zdGF0dXMgIT09IDEgLyogUEVORElORyAqLykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMucmVsYXkuY29ubmVjdGVkKSB7XG4gICAgICB0aGlzLnN0YXR1cyA9IDIgLyogV0FJVElORyAqLztcbiAgICAgIHRoaXMuZGVidWcoXCJXYWl0aW5nIGZvciByZWxheSB0byBiZSByZWFkeVwiLCB7IHN0YXR1czogdGhpcy5zdGF0dXMsIGlkOiB0aGlzLnN1YklkLCBmaW5nZXJwcmludDogdGhpcy5maW5nZXJwcmludCwgaXRlbXM6IHRoaXMuaXRlbXMsIGl0ZW1zU2l6ZTogdGhpcy5pdGVtcy5zaXplIH0pO1xuICAgICAgdGhpcy5yZWxheS5vbmNlKFwicmVhZHlcIiwgdGhpcy5leGVjdXRlT25SZWxheVJlYWR5KTtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKHRoaXMucmVsYXkuc3RhdHVzIDwgOCAvKiBBVVRIRU5USUNBVEVEICovKSB7XG4gICAgICB0aGlzLnJlbGF5Lm9uY2UoXCJhdXRoZWRcIiwgdGhpcy5yZUV4ZWN1dGVBZnRlckF1dGgpO1xuICAgIH1cbiAgICB0aGlzLnN0YXR1cyA9IDMgLyogUlVOTklORyAqLztcbiAgICB0aGlzLmZpbmFsaXplU3ViSWQoKTtcbiAgICB0aGlzLmV4ZWN1dGVGaWx0ZXJzID0gdGhpcy5jb21waWxlRmlsdGVycygpO1xuICAgIHRoaXMucmVsYXkucmVxKHRoaXMpO1xuICB9XG4gIG9uc3RhcnQoKSB7XG4gIH1cbiAgb25ldmVudChldmVudCkge1xuICAgIHRoaXMudG9wU3ViTWFuYWdlci5kaXNwYXRjaEV2ZW50KGV2ZW50LCB0aGlzLnJlbGF5KTtcbiAgfVxuICBvbmVvc2Uoc3ViSWQpIHtcbiAgICB0aGlzLmVvc2VkID0gdHJ1ZTtcbiAgICBpZiAoc3ViSWQgIT09IHRoaXMuc3ViSWQpIHtcbiAgICAgIHRoaXMuZGVidWcoXCJSZWNlaXZlZCBFT1NFIGZvciBhbiBhYmFuZG9uZWQgc3Vic2NyaXB0aW9uXCIsIHN1YklkLCB0aGlzLnN1YklkKTtcbiAgICAgIHRoaXMucmVsYXkuY2xvc2Uoc3ViSWQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5pdGVtcy5zaXplID09PSAwKSB7XG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgeyBzdWJzY3JpcHRpb24gfSBvZiB0aGlzLml0ZW1zLnZhbHVlcygpKSB7XG4gICAgICBzdWJzY3JpcHRpb24uZW9zZVJlY2VpdmVkKHRoaXMucmVsYXkpO1xuICAgICAgaWYgKHN1YnNjcmlwdGlvbi5jbG9zZU9uRW9zZSkge1xuICAgICAgICB0aGlzLmRlYnVnKFwiUmVtb3ZpbmcgaXRlbSBiZWNhdXNlIG9mIEVPU0VcIiwgeyBmaWx0ZXJzOiBzdWJzY3JpcHRpb24uZmlsdGVycywgaW50ZXJuYWxJZDogc3Vic2NyaXB0aW9uLmludGVybmFsSWQsIHN0YXR1czogdGhpcy5zdGF0dXMsIGZpbmdlcnByaW50OiB0aGlzLmZpbmdlcnByaW50LCBpdGVtczogdGhpcy5pdGVtcywgaXRlbXNTaXplOiB0aGlzLml0ZW1zLnNpemUgfSk7XG4gICAgICAgIHRoaXMucmVtb3ZlSXRlbShzdWJzY3JpcHRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBvbmNsb3NlKHJlYXNvbikge1xuICAgIHRoaXMuc3RhdHVzID0gNCAvKiBDTE9TRUQgKi87XG4gIH1cbiAgb25jbG9zZWQocmVhc29uKSB7XG4gICAgaWYgKCFyZWFzb24pIHJldHVybjtcbiAgICBmb3IgKGNvbnN0IHsgc3Vic2NyaXB0aW9uIH0gb2YgdGhpcy5pdGVtcy52YWx1ZXMoKSkge1xuICAgICAgc3Vic2NyaXB0aW9uLmNsb3NlZFJlY2VpdmVkKHRoaXMucmVsYXksIHJlYXNvbik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBHcmFicyB0aGUgZmlsdGVycyBmcm9tIGFsbCB0aGUgc3Vic2NyaXB0aW9uc1xuICAgKiBhbmQgbWVyZ2VzIHRoZW0gaW50byBhIHNpbmdsZSBmaWx0ZXIuXG4gICAqL1xuICBjb21waWxlRmlsdGVycygpIHtcbiAgICBjb25zdCBtZXJnZWRGaWx0ZXJzID0gW107XG4gICAgY29uc3QgZmlsdGVycyA9IEFycmF5LmZyb20odGhpcy5pdGVtcy52YWx1ZXMoKSkubWFwKChpdGVtKSA9PiBpdGVtLmZpbHRlcnMpO1xuICAgIGlmICghZmlsdGVyc1swXSkge1xuICAgICAgdGhpcy5kZWJ1ZyhcIlxcdXsxRjQ0MH0gTm8gZmlsdGVycyB0byBtZXJnZVwiLCB0aGlzLml0ZW1zKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJCVUc6IE5vIGZpbHRlcnMgdG8gbWVyZ2UhXCIsIHRoaXMuaXRlbXMpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCBmaWx0ZXJDb3VudCA9IGZpbHRlcnNbMF0ubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlsdGVyQ291bnQ7IGkrKykge1xuICAgICAgY29uc3QgYWxsRmlsdGVyc0F0SW5kZXggPSBmaWx0ZXJzLm1hcCgoZmlsdGVyKSA9PiBmaWx0ZXJbaV0pO1xuICAgICAgbWVyZ2VkRmlsdGVycy5wdXNoKC4uLm1lcmdlRmlsdGVycyhhbGxGaWx0ZXJzQXRJbmRleCkpO1xuICAgIH1cbiAgICByZXR1cm4gbWVyZ2VkRmlsdGVycztcbiAgfVxufTtcblxuLy8gc3JjL3JlbGF5L3N1Yi1tYW5hZ2VyLnRzXG52YXIgTkRLUmVsYXlTdWJzY3JpcHRpb25NYW5hZ2VyID0gY2xhc3Mge1xuICByZWxheTtcbiAgc3Vic2NyaXB0aW9ucztcbiAgZ2VuZXJhbFN1Yk1hbmFnZXI7XG4gIC8qKlxuICAgKiBAcGFyYW0gcmVsYXkgLSBUaGUgcmVsYXkgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSBnZW5lcmFsU3ViTWFuYWdlciAtIFRoZSBzdWJzY3JpcHRpb24gbWFuYWdlciBpbnN0YW5jZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHJlbGF5LCBnZW5lcmFsU3ViTWFuYWdlcikge1xuICAgIHRoaXMucmVsYXkgPSByZWxheTtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuZ2VuZXJhbFN1Yk1hbmFnZXIgPSBnZW5lcmFsU3ViTWFuYWdlcjtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIHN1YnNjcmlwdGlvbiB0byB0aGUgbWFuYWdlci5cbiAgICovXG4gIGFkZFN1YnNjcmlwdGlvbihzdWIsIGZpbHRlcnMpIHtcbiAgICBsZXQgcmVsYXlTdWI7XG4gICAgaWYgKCFzdWIuaXNHcm91cGFibGUoKSkge1xuICAgICAgcmVsYXlTdWIgPSB0aGlzLmNyZWF0ZVN1YnNjcmlwdGlvbihzdWIsIGZpbHRlcnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBmaWx0ZXJGcCA9IGZpbHRlckZpbmdlcnByaW50KGZpbHRlcnMsIHN1Yi5jbG9zZU9uRW9zZSk7XG4gICAgICBpZiAoZmlsdGVyRnApIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdTdWJzID0gdGhpcy5zdWJzY3JpcHRpb25zLmdldChmaWx0ZXJGcCk7XG4gICAgICAgIHJlbGF5U3ViID0gKGV4aXN0aW5nU3VicyB8fCBbXSkuZmluZChcbiAgICAgICAgICAoc3ViMikgPT4gc3ViMi5zdGF0dXMgPCAzIC8qIFJVTk5JTkcgKi9cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJlbGF5U3ViID8/PSB0aGlzLmNyZWF0ZVN1YnNjcmlwdGlvbihzdWIsIGZpbHRlcnMsIGZpbHRlckZwKTtcbiAgICB9XG4gICAgcmVsYXlTdWIuYWRkSXRlbShzdWIsIGZpbHRlcnMpO1xuICB9XG4gIGNyZWF0ZVN1YnNjcmlwdGlvbihzdWIsIGZpbHRlcnMsIGZpbmdlcnByaW50KSB7XG4gICAgY29uc3QgcmVsYXlTdWIgPSBuZXcgTkRLUmVsYXlTdWJzY3JpcHRpb24odGhpcy5yZWxheSwgZmluZ2VycHJpbnQgfHwgbnVsbCwgdGhpcy5nZW5lcmFsU3ViTWFuYWdlcik7XG4gICAgcmVsYXlTdWIub25DbG9zZSA9IHRoaXMub25SZWxheVN1YnNjcmlwdGlvbkNsb3NlLmJpbmQodGhpcyk7XG4gICAgY29uc3QgY3VycmVudFZhbCA9IHRoaXMuc3Vic2NyaXB0aW9ucy5nZXQocmVsYXlTdWIuZmluZ2VycHJpbnQpID8/IFtdO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5zZXQocmVsYXlTdWIuZmluZ2VycHJpbnQsIFsuLi5jdXJyZW50VmFsLCByZWxheVN1Yl0pO1xuICAgIHJldHVybiByZWxheVN1YjtcbiAgfVxuICBvblJlbGF5U3Vic2NyaXB0aW9uQ2xvc2Uoc3ViKSB7XG4gICAgbGV0IGN1cnJlbnRWYWwgPSB0aGlzLnN1YnNjcmlwdGlvbnMuZ2V0KHN1Yi5maW5nZXJwcmludCkgPz8gW107XG4gICAgaWYgKCFjdXJyZW50VmFsKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIFwiVW5leHBlY3RlZGx5IGRpZCBub3QgZmluZCBhIHN1YnNjcmlwdGlvbiB3aXRoIGZpbmdlcnByaW50XCIsXG4gICAgICAgIHN1Yi5maW5nZXJwcmludFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnRWYWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZGVsZXRlKHN1Yi5maW5nZXJwcmludCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnRWYWwgPSBjdXJyZW50VmFsLmZpbHRlcigocykgPT4gcy5pZCAhPT0gc3ViLmlkKTtcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5zZXQoc3ViLmZpbmdlcnByaW50LCBjdXJyZW50VmFsKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9yZWxheS9pbmRleC50c1xudmFyIE5ES1JlbGF5U3RhdHVzID0gLyogQF9fUFVSRV9fICovICgoTkRLUmVsYXlTdGF0dXMyKSA9PiB7XG4gIE5ES1JlbGF5U3RhdHVzMltOREtSZWxheVN0YXR1czJbXCJESVNDT05ORUNUSU5HXCJdID0gMF0gPSBcIkRJU0NPTk5FQ1RJTkdcIjtcbiAgTkRLUmVsYXlTdGF0dXMyW05ES1JlbGF5U3RhdHVzMltcIkRJU0NPTk5FQ1RFRFwiXSA9IDFdID0gXCJESVNDT05ORUNURURcIjtcbiAgTkRLUmVsYXlTdGF0dXMyW05ES1JlbGF5U3RhdHVzMltcIlJFQ09OTkVDVElOR1wiXSA9IDJdID0gXCJSRUNPTk5FQ1RJTkdcIjtcbiAgTkRLUmVsYXlTdGF0dXMyW05ES1JlbGF5U3RhdHVzMltcIkZMQVBQSU5HXCJdID0gM10gPSBcIkZMQVBQSU5HXCI7XG4gIE5ES1JlbGF5U3RhdHVzMltOREtSZWxheVN0YXR1czJbXCJDT05ORUNUSU5HXCJdID0gNF0gPSBcIkNPTk5FQ1RJTkdcIjtcbiAgTkRLUmVsYXlTdGF0dXMyW05ES1JlbGF5U3RhdHVzMltcIkNPTk5FQ1RFRFwiXSA9IDVdID0gXCJDT05ORUNURURcIjtcbiAgTkRLUmVsYXlTdGF0dXMyW05ES1JlbGF5U3RhdHVzMltcIkFVVEhfUkVRVUVTVEVEXCJdID0gNl0gPSBcIkFVVEhfUkVRVUVTVEVEXCI7XG4gIE5ES1JlbGF5U3RhdHVzMltOREtSZWxheVN0YXR1czJbXCJBVVRIRU5USUNBVElOR1wiXSA9IDddID0gXCJBVVRIRU5USUNBVElOR1wiO1xuICBOREtSZWxheVN0YXR1czJbTkRLUmVsYXlTdGF0dXMyW1wiQVVUSEVOVElDQVRFRFwiXSA9IDhdID0gXCJBVVRIRU5USUNBVEVEXCI7XG4gIHJldHVybiBOREtSZWxheVN0YXR1czI7XG59KShOREtSZWxheVN0YXR1cyB8fCB7fSk7XG52YXIgTkRLUmVsYXkgPSBjbGFzcyBfTkRLUmVsYXkgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICB1cmw7XG4gIHNjb3JlcztcbiAgY29ubmVjdGl2aXR5O1xuICBzdWJzO1xuICBwdWJsaXNoZXI7XG4gIGF1dGhQb2xpY3k7XG4gIC8qKlxuICAgKiBUaGUgbG93ZXN0IHZhbGlkYXRpb24gcmF0aW8gdGhpcyByZWxheSBjYW4gcmVhY2guXG4gICAqL1xuICBsb3dlc3RWYWxpZGF0aW9uUmF0aW87XG4gIC8qKlxuICAgKiBDdXJyZW50IHZhbGlkYXRpb24gcmF0aW8gdGhpcyByZWxheSBpcyB0YXJnZXRpbmcuXG4gICAqL1xuICB0YXJnZXRWYWxpZGF0aW9uUmF0aW87XG4gIHZhbGlkYXRpb25SYXRpb0ZuO1xuICAvKipcbiAgICogVGhpcyB0cmFja3MgZXZlbnRzIHRoYXQgaGF2ZSBiZWVuIHNlZW4gYnkgdGhpcyByZWxheVxuICAgKiB3aXRoIGEgdmFsaWQgc2lnbmF0dXJlLlxuICAgKi9cbiAgdmFsaWRhdGVkRXZlbnRDb3VudCA9IDA7XG4gIC8qKlxuICAgKiBUaGlzIHRyYWNrcyBldmVudHMgdGhhdCBoYXZlIGJlZW4gc2VlbiBieSB0aGlzIHJlbGF5XG4gICAqIGJ1dCBoYXZlIG5vdCBiZWVuIHZhbGlkYXRlZC5cbiAgICovXG4gIG5vblZhbGlkYXRlZEV2ZW50Q291bnQgPSAwO1xuICAvKipcbiAgICogV2hldGhlciB0aGlzIHJlbGF5IGlzIHRydXN0ZWQuXG4gICAqXG4gICAqIFRydXN0ZWQgcmVsYXkncyBldmVudHMgZG8gbm90IGdldCB0aGVpciBzaWduYXR1cmUgdmVyaWZpZWQuXG4gICAqL1xuICB0cnVzdGVkID0gZmFsc2U7XG4gIGNvbXBsYWluaW5nID0gZmFsc2U7XG4gIGRlYnVnO1xuICBzdGF0aWMgZGVmYXVsdFZhbGlkYXRpb25SYXRpb1VwZGF0ZUZuID0gKHJlbGF5LCB2YWxpZGF0ZWRDb3VudCwgbm9uVmFsaWRhdGVkQ291bnQpID0+IHtcbiAgICBpZiAocmVsYXkubG93ZXN0VmFsaWRhdGlvblJhdGlvID09PSB2b2lkIDAgfHwgcmVsYXkudGFyZ2V0VmFsaWRhdGlvblJhdGlvID09PSB2b2lkIDApXG4gICAgICByZXR1cm4gMTtcbiAgICBsZXQgbmV3UmF0aW8gPSByZWxheS52YWxpZGF0aW9uUmF0aW87XG4gICAgaWYgKHJlbGF5LnZhbGlkYXRpb25SYXRpbyA+IHJlbGF5LnRhcmdldFZhbGlkYXRpb25SYXRpbykge1xuICAgICAgY29uc3QgZmFjdG9yID0gdmFsaWRhdGVkQ291bnQgLyAxMDA7XG4gICAgICBuZXdSYXRpbyA9IE1hdGgubWF4KHJlbGF5Lmxvd2VzdFZhbGlkYXRpb25SYXRpbywgcmVsYXkudmFsaWRhdGlvblJhdGlvIC0gZmFjdG9yKTtcbiAgICB9XG4gICAgaWYgKG5ld1JhdGlvIDwgcmVsYXkudmFsaWRhdGlvblJhdGlvKSB7XG4gICAgICByZXR1cm4gbmV3UmF0aW87XG4gICAgfVxuICAgIHJldHVybiByZWxheS52YWxpZGF0aW9uUmF0aW87XG4gIH07XG4gIGNvbnN0cnVjdG9yKHVybCwgYXV0aFBvbGljeSwgbmRrKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnVybCA9IG5vcm1hbGl6ZVJlbGF5VXJsKHVybCk7XG4gICAgdGhpcy5zY29yZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuZGVidWcgPSBkZWJ1ZyhgbmRrOnJlbGF5OiR7dXJsfWApO1xuICAgIHRoaXMuY29ubmVjdGl2aXR5ID0gbmV3IE5ES1JlbGF5Q29ubmVjdGl2aXR5KHRoaXMsIG5kayk7XG4gICAgdGhpcy5jb25uZWN0aXZpdHkubmV0RGVidWcgPSBuZGs/Lm5ldERlYnVnO1xuICAgIHRoaXMucmVxID0gdGhpcy5jb25uZWN0aXZpdHkucmVxLmJpbmQodGhpcy5jb25uZWN0aXZpdHkpO1xuICAgIHRoaXMuY2xvc2UgPSB0aGlzLmNvbm5lY3Rpdml0eS5jbG9zZS5iaW5kKHRoaXMuY29ubmVjdGl2aXR5KTtcbiAgICB0aGlzLnN1YnMgPSBuZXcgTkRLUmVsYXlTdWJzY3JpcHRpb25NYW5hZ2VyKHRoaXMsIG5kay5zdWJNYW5hZ2VyKTtcbiAgICB0aGlzLnB1Ymxpc2hlciA9IG5ldyBOREtSZWxheVB1Ymxpc2hlcih0aGlzKTtcbiAgICB0aGlzLmF1dGhQb2xpY3kgPSBhdXRoUG9saWN5O1xuICAgIHRoaXMudGFyZ2V0VmFsaWRhdGlvblJhdGlvID0gbmRrPy5pbml0aWFsVmFsaWRhdGlvblJhdGlvO1xuICAgIHRoaXMubG93ZXN0VmFsaWRhdGlvblJhdGlvID0gbmRrPy5sb3dlc3RWYWxpZGF0aW9uUmF0aW87XG4gICAgdGhpcy52YWxpZGF0aW9uUmF0aW9GbiA9IChuZGs/LnZhbGlkYXRpb25SYXRpb0ZuID8/IF9OREtSZWxheS5kZWZhdWx0VmFsaWRhdGlvblJhdGlvVXBkYXRlRm4pLmJpbmQodGhpcyk7XG4gICAgdGhpcy51cGRhdGVWYWxpZGF0aW9uUmF0aW8oKTtcbiAgICBpZiAoIW5kaykge1xuICAgICAgY29uc29sZS50cmFjZShcInJlbGF5IGNyZWF0ZWQgd2l0aG91dCBuZGtcIik7XG4gICAgfVxuICB9XG4gIHVwZGF0ZVZhbGlkYXRpb25SYXRpbygpIHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMudXBkYXRlVmFsaWRhdGlvblJhdGlvKCk7XG4gICAgfSwgM2U0KTtcbiAgfVxuICBnZXQgc3RhdHVzKCkge1xuICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpdml0eS5zdGF0dXM7XG4gIH1cbiAgZ2V0IGNvbm5lY3Rpb25TdGF0cygpIHtcbiAgICByZXR1cm4gdGhpcy5jb25uZWN0aXZpdHkuY29ubmVjdGlvblN0YXRzO1xuICB9XG4gIC8qKlxuICAgKiBDb25uZWN0cyB0byB0aGUgcmVsYXkuXG4gICAqL1xuICBhc3luYyBjb25uZWN0KHRpbWVvdXRNcywgcmVjb25uZWN0ID0gdHJ1ZSkge1xuICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpdml0eS5jb25uZWN0KHRpbWVvdXRNcywgcmVjb25uZWN0KTtcbiAgfVxuICAvKipcbiAgICogRGlzY29ubmVjdHMgZnJvbSB0aGUgcmVsYXkuXG4gICAqL1xuICBkaXNjb25uZWN0KCkge1xuICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gMSAvKiBESVNDT05ORUNURUQgKi8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jb25uZWN0aXZpdHkuZGlzY29ubmVjdCgpO1xuICB9XG4gIC8qKlxuICAgKiBRdWV1ZXMgb3IgZXhlY3V0ZXMgdGhlIHN1YnNjcmlwdGlvbiBvZiBhIHNwZWNpZmljIHNldCBvZiBmaWx0ZXJzXG4gICAqIHdpdGhpbiB0aGlzIHJlbGF5LlxuICAgKlxuICAgKiBAcGFyYW0gc3Vic2NyaXB0aW9uIE5ES1N1YnNjcmlwdGlvbiB0aGlzIGZpbHRlcnMgYmVsb25nIHRvLlxuICAgKiBAcGFyYW0gZmlsdGVycyBGaWx0ZXJzIHRvIGV4ZWN1dGVcbiAgICovXG4gIHN1YnNjcmliZShzdWJzY3JpcHRpb24sIGZpbHRlcnMpIHtcbiAgICB0aGlzLnN1YnMuYWRkU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbiwgZmlsdGVycyk7XG4gIH1cbiAgLyoqXG4gICAqIFB1Ymxpc2hlcyBhbiBldmVudCB0byB0aGUgcmVsYXkgd2l0aCBhbiBvcHRpb25hbCB0aW1lb3V0LlxuICAgKlxuICAgKiBJZiB0aGUgcmVsYXkgaXMgbm90IGNvbm5lY3RlZCwgdGhlIGV2ZW50IHdpbGwgYmUgcHVibGlzaGVkIHdoZW4gdGhlIHJlbGF5IGNvbm5lY3RzLFxuICAgKiB1bmxlc3MgdGhlIHRpbWVvdXQgaXMgcmVhY2hlZCBiZWZvcmUgdGhlIHJlbGF5IGNvbm5lY3RzLlxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQgVGhlIGV2ZW50IHRvIHB1Ymxpc2hcbiAgICogQHBhcmFtIHRpbWVvdXRNcyBUaGUgdGltZW91dCBmb3IgdGhlIHB1Ymxpc2ggb3BlcmF0aW9uIGluIG1pbGxpc2Vjb25kc1xuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBldmVudCBoYXMgYmVlbiBwdWJsaXNoZWQgb3IgcmVqZWN0cyBpZiB0aGUgb3BlcmF0aW9uIHRpbWVzIG91dFxuICAgKi9cbiAgYXN5bmMgcHVibGlzaChldmVudCwgdGltZW91dE1zID0gMjUwMCkge1xuICAgIHJldHVybiB0aGlzLnB1Ymxpc2hlci5wdWJsaXNoKGV2ZW50LCB0aW1lb3V0TXMpO1xuICB9XG4gIHJlZmVyZW5jZVRhZ3MoKSB7XG4gICAgcmV0dXJuIFtbXCJyXCIsIHRoaXMudXJsXV07XG4gIH1cbiAgYWRkVmFsaWRhdGVkRXZlbnQoKSB7XG4gICAgdGhpcy52YWxpZGF0ZWRFdmVudENvdW50Kys7XG4gIH1cbiAgYWRkTm9uVmFsaWRhdGVkRXZlbnQoKSB7XG4gICAgdGhpcy5ub25WYWxpZGF0ZWRFdmVudENvdW50Kys7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHZhbGlkYXRpb24gcmF0aW8gdGhpcyByZWxheSBoYXMgYWNoaWV2ZWQuXG4gICAqL1xuICBnZXQgdmFsaWRhdGlvblJhdGlvKCkge1xuICAgIGlmICh0aGlzLm5vblZhbGlkYXRlZEV2ZW50Q291bnQgPT09IDApIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy52YWxpZGF0ZWRFdmVudENvdW50IC8gKHRoaXMudmFsaWRhdGVkRXZlbnRDb3VudCArIHRoaXMubm9uVmFsaWRhdGVkRXZlbnRDb3VudCk7XG4gIH1cbiAgc2hvdWxkVmFsaWRhdGVFdmVudCgpIHtcbiAgICBpZiAodGhpcy50cnVzdGVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0aGlzLnRhcmdldFZhbGlkYXRpb25SYXRpbyA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudmFsaWRhdGlvblJhdGlvIDwgdGhpcy50YXJnZXRWYWxpZGF0aW9uUmF0aW87XG4gIH1cbiAgZ2V0IGNvbm5lY3RlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25uZWN0aXZpdHkuY29ubmVjdGVkO1xuICB9XG4gIHJlcTtcbiAgY2xvc2U7XG59O1xuXG4vLyBzcmMvcmVsYXkvc2V0cy9pbmRleC50c1xudmFyIE5ES1B1Ymxpc2hFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBlcnJvcnM7XG4gIHB1Ymxpc2hlZFRvUmVsYXlzO1xuICAvKipcbiAgICogSW50ZW5kZWQgcmVsYXkgc2V0IHdoZXJlIHRoZSBwdWJsaXNoaW5nIHdhcyBpbnRlbmRlZCB0byBoYXBwZW4uXG4gICAqL1xuICBpbnRlbmRlZFJlbGF5U2V0O1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBlcnJvcnMsIHB1Ymxpc2hlZFRvUmVsYXlzLCBpbnRlbmRlZFJlbGF5U2V0KSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgdGhpcy5wdWJsaXNoZWRUb1JlbGF5cyA9IHB1Ymxpc2hlZFRvUmVsYXlzO1xuICAgIHRoaXMuaW50ZW5kZWRSZWxheVNldCA9IGludGVuZGVkUmVsYXlTZXQ7XG4gIH1cbiAgZ2V0IHJlbGF5RXJyb3JzKCkge1xuICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgIGZvciAoY29uc3QgW3JlbGF5LCBlcnJdIG9mIHRoaXMuZXJyb3JzKSB7XG4gICAgICBlcnJvcnMucHVzaChgJHtyZWxheS51cmx9OiAke2Vycn1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9ycy5qb2luKFwiXFxuXCIpO1xuICB9XG59O1xudmFyIE5ES1JlbGF5U2V0ID0gY2xhc3MgX05ES1JlbGF5U2V0IHtcbiAgcmVsYXlzO1xuICBkZWJ1ZztcbiAgbmRrO1xuICBwb29sO1xuICBjb25zdHJ1Y3RvcihyZWxheXMsIG5kaywgcG9vbCkge1xuICAgIHRoaXMucmVsYXlzID0gcmVsYXlzO1xuICAgIHRoaXMubmRrID0gbmRrO1xuICAgIHRoaXMucG9vbCA9IHBvb2wgPz8gbmRrLnBvb2w7XG4gICAgdGhpcy5kZWJ1ZyA9IG5kay5kZWJ1Zy5leHRlbmQoXCJyZWxheXNldFwiKTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIHJlbGF5IHRvIHRoaXMgc2V0LlxuICAgKi9cbiAgYWRkUmVsYXkocmVsYXkpIHtcbiAgICB0aGlzLnJlbGF5cy5hZGQocmVsYXkpO1xuICB9XG4gIGdldCByZWxheVVybHMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5yZWxheXMpLm1hcCgocikgPT4gci51cmwpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgcmVsYXkgc2V0IGZyb20gYSBsaXN0IG9mIHJlbGF5IFVSTHMuXG4gICAqXG4gICAqIElmIG5vIGNvbm5lY3Rpb24gdG8gdGhlIHJlbGF5IGlzIGZvdW5kIGluIHRoZSBwb29sIGl0IHdpbGwgdGVtcG9yYXJpbHlcbiAgICogY29ubmVjdCB0byBpdC5cbiAgICpcbiAgICogQHBhcmFtIHJlbGF5VXJscyAtIGxpc3Qgb2YgcmVsYXkgVVJMcyB0byBpbmNsdWRlIGluIHRoaXMgc2V0XG4gICAqIEBwYXJhbSBuZGtcbiAgICogQHBhcmFtIGNvbm5lY3QgLSB3aGV0aGVyIHRvIGNvbm5lY3QgdG8gdGhlIHJlbGF5IGltbWVkaWF0ZWx5IGlmIGl0IHdhcyBhbHJlYWR5IGluIHRoZSBwb29sIGJ1dCBub3QgY29ubmVjdGVkXG4gICAqIEByZXR1cm5zIE5ES1JlbGF5U2V0XG4gICAqL1xuICBzdGF0aWMgZnJvbVJlbGF5VXJscyhyZWxheVVybHMsIG5kaywgY29ubmVjdCA9IHRydWUsIHBvb2wpIHtcbiAgICBwb29sID0gcG9vbCA/PyBuZGsucG9vbDtcbiAgICBpZiAoIXBvb2wpIHRocm93IG5ldyBFcnJvcihcIk5vIHBvb2wgcHJvdmlkZWRcIik7XG4gICAgY29uc3QgcmVsYXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBmb3IgKGNvbnN0IHVybCBvZiByZWxheVVybHMpIHtcbiAgICAgIGNvbnN0IHJlbGF5ID0gcG9vbC5yZWxheXMuZ2V0KG5vcm1hbGl6ZVJlbGF5VXJsKHVybCkpO1xuICAgICAgaWYgKHJlbGF5KSB7XG4gICAgICAgIGlmIChyZWxheS5zdGF0dXMgPCA1IC8qIENPTk5FQ1RFRCAqLyAmJiBjb25uZWN0KSB7XG4gICAgICAgICAgcmVsYXkuY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJlbGF5cy5hZGQocmVsYXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdGVtcG9yYXJ5UmVsYXkgPSBuZXcgTkRLUmVsYXkoXG4gICAgICAgICAgbm9ybWFsaXplUmVsYXlVcmwodXJsKSxcbiAgICAgICAgICBuZGs/LnJlbGF5QXV0aERlZmF1bHRQb2xpY3ksXG4gICAgICAgICAgbmRrXG4gICAgICAgICk7XG4gICAgICAgIHBvb2wudXNlVGVtcG9yYXJ5UmVsYXkoXG4gICAgICAgICAgdGVtcG9yYXJ5UmVsYXksXG4gICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgIFwicmVxdWVzdGVkIGZyb20gZnJvbVJlbGF5VXJscyBcIiArIHJlbGF5VXJsc1xuICAgICAgICApO1xuICAgICAgICByZWxheXMuYWRkKHRlbXBvcmFyeVJlbGF5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBfTkRLUmVsYXlTZXQobmV3IFNldChyZWxheXMpLCBuZGssIHBvb2wpO1xuICB9XG4gIC8qKlxuICAgKiBQdWJsaXNoIGFuIGV2ZW50IHRvIGFsbCByZWxheXMgaW4gdGhpcyBzZXQuIFJldHVybnMgdGhlIG51bWJlciBvZiByZWxheXMgdGhhdCBoYXZlIHJlY2VpdmVkIHRoZSBldmVudC5cbiAgICogQHBhcmFtIGV2ZW50XG4gICAqIEBwYXJhbSB0aW1lb3V0TXMgLSB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyBmb3IgZWFjaCBwdWJsaXNoIG9wZXJhdGlvbiBhbmQgY29ubmVjdGlvbiBvcGVyYXRpb25cbiAgICogQHJldHVybnMgQSBzZXQgd2hlcmUgdGhlIGV2ZW50IHdhcyBzdWNjZXNzZnVsbHkgcHVibGlzaGVkIHRvXG4gICAqIEB0aHJvd3MgTkRLUHVibGlzaEVycm9yIGlmIG5vIHJlbGF5IHdhcyBhYmxlIHRvIHJlY2VpdmUgdGhlIGV2ZW50XG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgZXZlbnQgPSBuZXcgTkRLRXZlbnQobmRrLCB7a2luZHM6IFtOREtLaW5kLk1lc3NhZ2VdLCBcIiNkXCI6IFtcIjEyM1wiXX0pO1xuICAgKiB0cnkge1xuICAgKiAgICBjb25zdCBwdWJsaXNoZWRUb1JlbGF5cyA9IGF3YWl0IHJlbGF5U2V0LnB1Ymxpc2goZXZlbnQpO1xuICAgKiAgICBjb25zb2xlLmxvZyhgcHVibGlzaGVkIHRvICR7cHVibGlzaGVkVG9SZWxheXMuc2l6ZX0gcmVsYXlzYClcbiAgICogfSBjYXRjaCAoZXJyb3IpIHtcbiAgICogICBjb25zb2xlLmVycm9yKFwiZXJyb3IgcHVibGlzaGluZyB0byByZWxheXNcIiwgZXJyb3IpO1xuICAgKlxuICAgKiAgIGlmIChlcnJvciBpbnN0YW5jZW9mIE5ES1B1Ymxpc2hFcnJvcikge1xuICAgKiAgICAgIGZvciAoY29uc3QgW3JlbGF5LCBlcnJdIG9mIGVycm9yLmVycm9ycykge1xuICAgKiAgICAgICAgIGNvbnNvbGUuZXJyb3IoYGVycm9yIHB1Ymxpc2hpbmcgdG8gcmVsYXkgJHtyZWxheS51cmx9YCwgZXJyKTtcbiAgICogICAgICAgfVxuICAgKiAgIH1cbiAgICogfVxuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIHB1Ymxpc2goZXZlbnQsIHRpbWVvdXRNcywgcmVxdWlyZWRSZWxheUNvdW50ID0gMSkge1xuICAgIGNvbnN0IHB1Ymxpc2hlZFRvUmVsYXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBjb25zdCBlcnJvcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGlzRXBoZW1lcmFsMiA9IGV2ZW50LmlzRXBoZW1lcmFsKCk7XG4gICAgZXZlbnQucHVibGlzaFN0YXR1cyA9IFwicGVuZGluZ1wiO1xuICAgIGNvbnN0IHByb21pc2VzID0gQXJyYXkuZnJvbSh0aGlzLnJlbGF5cykubWFwKChyZWxheSkgPT4ge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIHJlbGF5LnB1Ymxpc2goZXZlbnQsIHRpbWVvdXRNcykudGhlbigoZSkgPT4ge1xuICAgICAgICAgIHB1Ymxpc2hlZFRvUmVsYXlzLmFkZChyZWxheSk7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgaWYgKCFpc0VwaGVtZXJhbDIpIHtcbiAgICAgICAgICAgIGVycm9ycy5zZXQocmVsYXksIGVycik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgaWYgKHB1Ymxpc2hlZFRvUmVsYXlzLnNpemUgPCByZXF1aXJlZFJlbGF5Q291bnQpIHtcbiAgICAgIGlmICghaXNFcGhlbWVyYWwyKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IE5ES1B1Ymxpc2hFcnJvcihcbiAgICAgICAgICBcIk5vdCBlbm91Z2ggcmVsYXlzIHJlY2VpdmVkIHRoZSBldmVudFwiLFxuICAgICAgICAgIGVycm9ycyxcbiAgICAgICAgICBwdWJsaXNoZWRUb1JlbGF5cyxcbiAgICAgICAgICB0aGlzXG4gICAgICAgICk7XG4gICAgICAgIGV2ZW50LnB1Ymxpc2hTdGF0dXMgPSBcImVycm9yXCI7XG4gICAgICAgIGV2ZW50LnB1Ymxpc2hFcnJvciA9IGVycm9yO1xuICAgICAgICB0aGlzLm5kay5lbWl0KFwiZXZlbnQ6cHVibGlzaC1mYWlsZWRcIiwgZXZlbnQsIGVycm9yLCB0aGlzLnJlbGF5VXJscyk7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBldmVudC5lbWl0KFwicHVibGlzaGVkXCIsIHsgcmVsYXlTZXQ6IHRoaXMsIHB1Ymxpc2hlZFRvUmVsYXlzIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcHVibGlzaGVkVG9SZWxheXM7XG4gIH1cbiAgZ2V0IHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVsYXlzLnNpemU7XG4gIH1cbn07XG5cbi8vIHNyYy9yZWxheS9zZXRzL2NhbGN1bGF0ZS50c1xuaW1wb3J0IGNyZWF0ZURlYnVnIGZyb20gXCJkZWJ1Z1wiO1xudmFyIGQgPSBjcmVhdGVEZWJ1ZyhcIm5kazpvdXRib3g6Y2FsY3VsYXRlXCIpO1xuYXN5bmMgZnVuY3Rpb24gY2FsY3VsYXRlUmVsYXlTZXRGcm9tRXZlbnQobmRrLCBldmVudCkge1xuICBjb25zdCByZWxheXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBjb25zdCBhdXRob3JXcml0ZVJlbGF5cyA9IGF3YWl0IGdldFdyaXRlUmVsYXlzRm9yKG5kaywgZXZlbnQucHVia2V5KTtcbiAgaWYgKGF1dGhvcldyaXRlUmVsYXlzKSB7XG4gICAgYXV0aG9yV3JpdGVSZWxheXMuZm9yRWFjaCgocmVsYXlVcmwpID0+IHtcbiAgICAgIGNvbnN0IHJlbGF5ID0gbmRrLnBvb2w/LmdldFJlbGF5KHJlbGF5VXJsKTtcbiAgICAgIGlmIChyZWxheSkgcmVsYXlzLmFkZChyZWxheSk7XG4gICAgfSk7XG4gIH1cbiAgbGV0IHJlbGF5SGludHMgPSBldmVudC50YWdzLmZpbHRlcigodGFnKSA9PiBbXCJhXCIsIFwiZVwiXS5pbmNsdWRlcyh0YWdbMF0pKS5tYXAoKHRhZykgPT4gdGFnWzJdKS5maWx0ZXIoKHVybCkgPT4gdXJsICYmIHVybC5zdGFydHNXaXRoKFwid3NzOi8vXCIpKS5maWx0ZXIoKHVybCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBuZXcgVVJMKHVybCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pLm1hcCgodXJsKSA9PiBub3JtYWxpemVSZWxheVVybCh1cmwpKTtcbiAgcmVsYXlIaW50cyA9IEFycmF5LmZyb20obmV3IFNldChyZWxheUhpbnRzKSkuc2xpY2UoMCwgNSk7XG4gIHJlbGF5SGludHMuZm9yRWFjaCgocmVsYXlVcmwpID0+IHtcbiAgICBjb25zdCByZWxheSA9IG5kay5wb29sPy5nZXRSZWxheShyZWxheVVybCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgaWYgKHJlbGF5KSB7XG4gICAgICBkKFwiQWRkaW5nIHJlbGF5IGhpbnQgJXNcIiwgcmVsYXlVcmwpO1xuICAgICAgcmVsYXlzLmFkZChyZWxheSk7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgcFRhZ3MgPSBldmVudC5nZXRNYXRjaGluZ1RhZ3MoXCJwXCIpLm1hcCgodGFnKSA9PiB0YWdbMV0pO1xuICBpZiAocFRhZ3MubGVuZ3RoIDwgNSkge1xuICAgIGNvbnN0IHBUYWdnZWRSZWxheXMgPSBBcnJheS5mcm9tKFxuICAgICAgY2hvb3NlUmVsYXlDb21iaW5hdGlvbkZvclB1YmtleXMobmRrLCBwVGFncywgXCJyZWFkXCIsIHtcbiAgICAgICAgcHJlZmVycmVkUmVsYXlzOiBuZXcgU2V0KGF1dGhvcldyaXRlUmVsYXlzKVxuICAgICAgfSkua2V5cygpXG4gICAgKTtcbiAgICBwVGFnZ2VkUmVsYXlzLmZvckVhY2goKHJlbGF5VXJsKSA9PiB7XG4gICAgICBjb25zdCByZWxheSA9IG5kay5wb29sPy5nZXRSZWxheShyZWxheVVybCwgZmFsc2UsIHRydWUpO1xuICAgICAgaWYgKHJlbGF5KSB7XG4gICAgICAgIGQoXCJBZGRpbmcgcC10YWdnZWQgcmVsYXkgJXNcIiwgcmVsYXlVcmwpO1xuICAgICAgICByZWxheXMuYWRkKHJlbGF5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBkKFwiVG9vIG1hbnkgcC10YWdzIHRvIGNvbnNpZGVyICVkXCIsIHBUYWdzLmxlbmd0aCk7XG4gIH1cbiAgbmRrLnBvb2w/LnBlcm1hbmVudEFuZENvbm5lY3RlZFJlbGF5cygpLmZvckVhY2goKHJlbGF5KSA9PiByZWxheXMuYWRkKHJlbGF5KSk7XG4gIHJldHVybiBuZXcgTkRLUmVsYXlTZXQocmVsYXlzLCBuZGspO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlUmVsYXlTZXRzRnJvbUZpbHRlcihuZGssIGZpbHRlcnMsIHBvb2wpIHtcbiAgY29uc3QgcmVzdWx0ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgYXV0aG9ycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGZpbHRlcnMuZm9yRWFjaCgoZmlsdGVyKSA9PiB7XG4gICAgaWYgKGZpbHRlci5hdXRob3JzKSB7XG4gICAgICBmaWx0ZXIuYXV0aG9ycy5mb3JFYWNoKChhdXRob3IpID0+IGF1dGhvcnMuYWRkKGF1dGhvcikpO1xuICAgIH1cbiAgfSk7XG4gIGlmIChhdXRob3JzLnNpemUgPiAwKSB7XG4gICAgY29uc3QgYXV0aG9yVG9SZWxheXNNYXAgPSBnZXRSZWxheXNGb3JGaWx0ZXJXaXRoQXV0aG9ycyhuZGssIEFycmF5LmZyb20oYXV0aG9ycykpO1xuICAgIGZvciAoY29uc3QgcmVsYXlVcmwgb2YgYXV0aG9yVG9SZWxheXNNYXAua2V5cygpKSB7XG4gICAgICByZXN1bHQuc2V0KHJlbGF5VXJsLCBbXSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZmlsdGVyIG9mIGZpbHRlcnMpIHtcbiAgICAgIGlmIChmaWx0ZXIuYXV0aG9ycykge1xuICAgICAgICBmb3IgKGNvbnN0IFtyZWxheVVybCwgYXV0aG9yczJdIG9mIGF1dGhvclRvUmVsYXlzTWFwLmVudHJpZXMoKSkge1xuICAgICAgICAgIGNvbnN0IGF1dGhvckZpbHRlckFuZFJlbGF5UHVia2V5SW50ZXJzZWN0aW9uID0gZmlsdGVyLmF1dGhvcnMuZmlsdGVyKFxuICAgICAgICAgICAgKGF1dGhvcikgPT4gYXV0aG9yczIuaW5jbHVkZXMoYXV0aG9yKVxuICAgICAgICAgICk7XG4gICAgICAgICAgcmVzdWx0LnNldChyZWxheVVybCwgW1xuICAgICAgICAgICAgLi4ucmVzdWx0LmdldChyZWxheVVybCksXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIC4uLmZpbHRlcixcbiAgICAgICAgICAgICAgLy8gT3ZlcndyaXRlIGF1dGhvcnMgc2VudCB0byB0aGlzIHJlbGF5IHdpdGggdGhlIGF1dGhvcnMgdGhhdCB3ZXJlXG4gICAgICAgICAgICAgIC8vIHByZXNlbnQgaW4gdGhlIGZpbHRlciBhbmQgYXJlIGFsc28gcHJlc2VudCBpbiB0aGUgcmVsYXlcbiAgICAgICAgICAgICAgYXV0aG9yczogYXV0aG9yRmlsdGVyQW5kUmVsYXlQdWJrZXlJbnRlcnNlY3Rpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChjb25zdCByZWxheVVybCBvZiBhdXRob3JUb1JlbGF5c01hcC5rZXlzKCkpIHtcbiAgICAgICAgICByZXN1bHQuc2V0KHJlbGF5VXJsLCBbLi4ucmVzdWx0LmdldChyZWxheVVybCksIGZpbHRlcl0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChuZGsuZXhwbGljaXRSZWxheVVybHMpIHtcbiAgICAgIG5kay5leHBsaWNpdFJlbGF5VXJscy5mb3JFYWNoKChyZWxheVVybCkgPT4ge1xuICAgICAgICByZXN1bHQuc2V0KHJlbGF5VXJsLCBmaWx0ZXJzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAocmVzdWx0LnNpemUgPT09IDApIHtcbiAgICBwb29sLnBlcm1hbmVudEFuZENvbm5lY3RlZFJlbGF5cygpLnNsaWNlKDAsIDUpLmZvckVhY2goKHJlbGF5KSA9PiB7XG4gICAgICByZXN1bHQuc2V0KHJlbGF5LnVybCwgZmlsdGVycyk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZVJlbGF5U2V0c0Zyb21GaWx0ZXJzKG5kaywgZmlsdGVycywgcG9vbCkge1xuICBjb25zdCBhID0gY2FsY3VsYXRlUmVsYXlTZXRzRnJvbUZpbHRlcihuZGssIGZpbHRlcnMsIHBvb2wpO1xuICByZXR1cm4gYTtcbn1cblxuLy8gc3JjL2V2ZW50cy9jb250ZW50LXRhZ2dlci50c1xuaW1wb3J0IHsgbmlwMTkgfSBmcm9tIFwibm9zdHItdG9vbHNcIjtcbmZ1bmN0aW9uIG1lcmdlVGFncyh0YWdzMSwgdGFnczIpIHtcbiAgY29uc3QgdGFnTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgZ2VuZXJhdGVLZXkgPSAodGFnKSA9PiB0YWcuam9pbihcIixcIik7XG4gIGNvbnN0IGlzQ29udGFpbmVkID0gKHNtYWxsZXIsIGxhcmdlcikgPT4ge1xuICAgIHJldHVybiBzbWFsbGVyLmV2ZXJ5KCh2YWx1ZSwgaW5kZXgpID0+IHZhbHVlID09PSBsYXJnZXJbaW5kZXhdKTtcbiAgfTtcbiAgY29uc3QgcHJvY2Vzc1RhZyA9ICh0YWcpID0+IHtcbiAgICBmb3IgKGNvbnN0IFtrZXksIGV4aXN0aW5nVGFnXSBvZiB0YWdNYXApIHtcbiAgICAgIGlmIChpc0NvbnRhaW5lZChleGlzdGluZ1RhZywgdGFnKSB8fCBpc0NvbnRhaW5lZCh0YWcsIGV4aXN0aW5nVGFnKSkge1xuICAgICAgICBpZiAodGFnLmxlbmd0aCA+PSBleGlzdGluZ1RhZy5sZW5ndGgpIHtcbiAgICAgICAgICB0YWdNYXAuc2V0KGtleSwgdGFnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRhZ01hcC5zZXQoZ2VuZXJhdGVLZXkodGFnKSwgdGFnKTtcbiAgfTtcbiAgdGFnczEuY29uY2F0KHRhZ3MyKS5mb3JFYWNoKHByb2Nlc3NUYWcpO1xuICByZXR1cm4gQXJyYXkuZnJvbSh0YWdNYXAudmFsdWVzKCkpO1xufVxuZnVuY3Rpb24gdW5pcXVlVGFnKGEsIGIpIHtcbiAgY29uc3QgYUxlbmd0aCA9IGEubGVuZ3RoO1xuICBjb25zdCBiTGVuZ3RoID0gYi5sZW5ndGg7XG4gIGNvbnN0IHNhbWVMZW5ndGggPSBhTGVuZ3RoID09PSBiTGVuZ3RoO1xuICBpZiAoc2FtZUxlbmd0aCkge1xuICAgIGlmIChhLmV2ZXJ5KCh2LCBpKSA9PiB2ID09PSBiW2ldKSkge1xuICAgICAgcmV0dXJuIFthXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFthLCBiXTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYUxlbmd0aCA+IGJMZW5ndGggJiYgYS5ldmVyeSgodiwgaSkgPT4gdiA9PT0gYltpXSkpIHtcbiAgICByZXR1cm4gW2FdO1xuICB9IGVsc2UgaWYgKGJMZW5ndGggPiBhTGVuZ3RoICYmIGIuZXZlcnkoKHYsIGkpID0+IHYgPT09IGFbaV0pKSB7XG4gICAgcmV0dXJuIFtiXTtcbiAgfVxuICByZXR1cm4gW2EsIGJdO1xufVxudmFyIGhhc2h0YWdSZWdleCA9IC8oPzw9XFxzfF4pKCNbXlxccyFAIyQlXiYqKCk9Ky4vLFt7XFxdfTs6J1wiPz48XSspL2c7XG5mdW5jdGlvbiBnZW5lcmF0ZUhhc2h0YWdzKGNvbnRlbnQpIHtcbiAgY29uc3QgaGFzaHRhZ3MgPSBjb250ZW50Lm1hdGNoKGhhc2h0YWdSZWdleCk7XG4gIGNvbnN0IHRhZ0lkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0IHRhZyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGlmIChoYXNodGFncykge1xuICAgIGZvciAoY29uc3QgaGFzaHRhZyBvZiBoYXNodGFncykge1xuICAgICAgaWYgKHRhZ0lkcy5oYXMoaGFzaHRhZy5zbGljZSgxKSkpIGNvbnRpbnVlO1xuICAgICAgdGFnLmFkZChoYXNodGFnLnNsaWNlKDEpKTtcbiAgICAgIHRhZ0lkcy5hZGQoaGFzaHRhZy5zbGljZSgxKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBBcnJheS5mcm9tKHRhZyk7XG59XG5hc3luYyBmdW5jdGlvbiBnZW5lcmF0ZUNvbnRlbnRUYWdzKGNvbnRlbnQsIHRhZ3MgPSBbXSkge1xuICBjb25zdCB0YWdSZWdleCA9IC8oQHxub3N0cjopKG5wdWJ8bnByb2ZpbGV8bm90ZXxuZXZlbnR8bmFkZHIpW2EtekEtWjAtOV0rL2c7XG4gIGNvbnN0IHByb21pc2VzID0gW107XG4gIGNvbnN0IGFkZFRhZ0lmTmV3ID0gKHQpID0+IHtcbiAgICBpZiAoIXRhZ3MuZmluZCgodDIpID0+IFtcInFcIiwgdFswXV0uaW5jbHVkZXModDJbMF0pICYmIHQyWzFdID09PSB0WzFdKSkge1xuICAgICAgdGFncy5wdXNoKHQpO1xuICAgIH1cbiAgfTtcbiAgY29udGVudCA9IGNvbnRlbnQucmVwbGFjZSh0YWdSZWdleCwgKHRhZykgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBlbnRpdHkgPSB0YWcuc3BsaXQoLyhAfG5vc3RyOikvKVsyXTtcbiAgICAgIGNvbnN0IHsgdHlwZSwgZGF0YSB9ID0gbmlwMTkuZGVjb2RlKGVudGl0eSk7XG4gICAgICBsZXQgdDtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwibnB1YlwiOlxuICAgICAgICAgIHQgPSBbXCJwXCIsIGRhdGFdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibnByb2ZpbGVcIjpcbiAgICAgICAgICB0ID0gW1wicFwiLCBkYXRhLnB1YmtleV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJub3RlXCI6XG4gICAgICAgICAgcHJvbWlzZXMucHVzaChcbiAgICAgICAgICAgIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgIGFkZFRhZ0lmTmV3KFtcbiAgICAgICAgICAgICAgICBcInFcIixcbiAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgIGF3YWl0IG1heWJlR2V0RXZlbnRSZWxheVVybChlbnRpdHkpXG4gICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJuZXZlbnRcIjpcbiAgICAgICAgICBwcm9taXNlcy5wdXNoKFxuICAgICAgICAgICAgbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgeyBpZCwgYXV0aG9yIH0gPSBkYXRhO1xuICAgICAgICAgICAgICBsZXQgeyByZWxheXMgfSA9IGRhdGE7XG4gICAgICAgICAgICAgIGlmICghcmVsYXlzIHx8IHJlbGF5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZWxheXMgPSBbYXdhaXQgbWF5YmVHZXRFdmVudFJlbGF5VXJsKGVudGl0eSldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGFkZFRhZ0lmTmV3KFtcInFcIiwgaWQsIHJlbGF5c1swXV0pO1xuICAgICAgICAgICAgICBpZiAoYXV0aG9yKSBhZGRUYWdJZk5ldyhbXCJwXCIsIGF1dGhvcl0pO1xuICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJuYWRkclwiOlxuICAgICAgICAgIHByb21pc2VzLnB1c2goXG4gICAgICAgICAgICBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBpZCA9IFtkYXRhLmtpbmQsIGRhdGEucHVia2V5LCBkYXRhLmlkZW50aWZpZXJdLmpvaW4oXCI6XCIpO1xuICAgICAgICAgICAgICBsZXQgcmVsYXlzID0gZGF0YS5yZWxheXMgPz8gW107XG4gICAgICAgICAgICAgIGlmIChyZWxheXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmVsYXlzID0gW2F3YWl0IG1heWJlR2V0RXZlbnRSZWxheVVybChlbnRpdHkpXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhZGRUYWdJZk5ldyhbXCJxXCIsIGlkLCByZWxheXNbMF1dKTtcbiAgICAgICAgICAgICAgYWRkVGFnSWZOZXcoW1wicFwiLCBkYXRhLnB1YmtleV0pO1xuICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHRhZztcbiAgICAgIH1cbiAgICAgIGlmICh0KSBhZGRUYWdJZk5ldyh0KTtcbiAgICAgIHJldHVybiBgbm9zdHI6JHtlbnRpdHl9YDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIHRhZztcbiAgICB9XG4gIH0pO1xuICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gIGNvbnN0IG5ld1RhZ3MgPSBnZW5lcmF0ZUhhc2h0YWdzKGNvbnRlbnQpLm1hcCgoaGFzaHRhZykgPT4gW1widFwiLCBoYXNodGFnXSk7XG4gIHRhZ3MgPSBtZXJnZVRhZ3ModGFncywgbmV3VGFncyk7XG4gIHJldHVybiB7IGNvbnRlbnQsIHRhZ3MgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIG1heWJlR2V0RXZlbnRSZWxheVVybChuaXAxOUlkKSB7XG4gIHJldHVybiBcIlwiO1xufVxuXG4vLyBzcmMvZXZlbnRzL2tpbmQudHNcbmZ1bmN0aW9uIGlzUmVwbGFjZWFibGUoKSB7XG4gIGlmICh0aGlzLmtpbmQgPT09IHZvaWQgMCkgdGhyb3cgbmV3IEVycm9yKFwiS2luZCBub3Qgc2V0XCIpO1xuICByZXR1cm4gWzAsIDNdLmluY2x1ZGVzKHRoaXMua2luZCkgfHwgdGhpcy5raW5kID49IDFlNCAmJiB0aGlzLmtpbmQgPCAyZTQgfHwgdGhpcy5raW5kID49IDNlNCAmJiB0aGlzLmtpbmQgPCA0ZTQ7XG59XG5mdW5jdGlvbiBpc0VwaGVtZXJhbCgpIHtcbiAgaWYgKHRoaXMua2luZCA9PT0gdm9pZCAwKSB0aHJvdyBuZXcgRXJyb3IoXCJLaW5kIG5vdCBzZXRcIik7XG4gIHJldHVybiB0aGlzLmtpbmQgPj0gMmU0ICYmIHRoaXMua2luZCA8IDNlNDtcbn1cbmZ1bmN0aW9uIGlzUGFyYW1SZXBsYWNlYWJsZSgpIHtcbiAgaWYgKHRoaXMua2luZCA9PT0gdm9pZCAwKSB0aHJvdyBuZXcgRXJyb3IoXCJLaW5kIG5vdCBzZXRcIik7XG4gIHJldHVybiB0aGlzLmtpbmQgPj0gM2U0ICYmIHRoaXMua2luZCA8IDRlNDtcbn1cblxuLy8gc3JjL2V2ZW50cy9lbmNyeXB0aW9uLnRzXG5hc3luYyBmdW5jdGlvbiBlbmNyeXB0KHJlY2lwaWVudCwgc2lnbmVyLCBzY2hlbWUgPSBcIm5pcDQ0XCIpIHtcbiAgbGV0IGVuY3J5cHRlZDtcbiAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTm8gTkRLIGluc3RhbmNlIGZvdW5kIVwiKTtcbiAgaWYgKCFzaWduZXIpIHtcbiAgICB0aGlzLm5kay5hc3NlcnRTaWduZXIoKTtcbiAgICBzaWduZXIgPSB0aGlzLm5kay5zaWduZXI7XG4gIH1cbiAgaWYgKCFyZWNpcGllbnQpIHtcbiAgICBjb25zdCBwVGFncyA9IHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwicFwiKTtcbiAgICBpZiAocFRhZ3MubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiTm8gcmVjaXBpZW50IGNvdWxkIGJlIGRldGVybWluZWQgYW5kIG5vIGV4cGxpY2l0IHJlY2lwaWVudCB3YXMgcHJvdmlkZWRcIlxuICAgICAgKTtcbiAgICB9XG4gICAgcmVjaXBpZW50ID0gdGhpcy5uZGsuZ2V0VXNlcih7IHB1YmtleTogcFRhZ3NbMF1bMV0gfSk7XG4gIH1cbiAgaWYgKHNjaGVtZSA9PT0gXCJuaXA0NFwiICYmIGF3YWl0IGlzRW5jcnlwdGlvbkVuYWJsZWQoc2lnbmVyLCBcIm5pcDQ0XCIpKSB7XG4gICAgZW5jcnlwdGVkID0gYXdhaXQgc2lnbmVyPy5lbmNyeXB0KHJlY2lwaWVudCwgdGhpcy5jb250ZW50LCBcIm5pcDQ0XCIpO1xuICB9XG4gIGlmICgoIWVuY3J5cHRlZCB8fCBzY2hlbWUgPT09IFwibmlwMDRcIikgJiYgYXdhaXQgaXNFbmNyeXB0aW9uRW5hYmxlZChzaWduZXIsIFwibmlwMDRcIikpIHtcbiAgICBlbmNyeXB0ZWQgPSBhd2FpdCBzaWduZXIuZW5jcnlwdChyZWNpcGllbnQsIHRoaXMuY29udGVudCwgXCJuaXAwNFwiKTtcbiAgfVxuICBpZiAoIWVuY3J5cHRlZCkgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGVuY3J5cHQgZXZlbnQuXCIpO1xuICB0aGlzLmNvbnRlbnQgPSBlbmNyeXB0ZWQ7XG59XG5hc3luYyBmdW5jdGlvbiBkZWNyeXB0KHNlbmRlciwgc2lnbmVyLCBzY2hlbWUpIHtcbiAgbGV0IGRlY3J5cHRlZDtcbiAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTm8gTkRLIGluc3RhbmNlIGZvdW5kIVwiKTtcbiAgaWYgKCFzaWduZXIpIHtcbiAgICB0aGlzLm5kay5hc3NlcnRTaWduZXIoKTtcbiAgICBzaWduZXIgPSB0aGlzLm5kay5zaWduZXI7XG4gIH1cbiAgaWYgKCFzaWduZXIpIHRocm93IG5ldyBFcnJvcihcIm5vIE5ESyBzaWduZXJcIik7XG4gIGlmICghc2VuZGVyKSB7XG4gICAgc2VuZGVyID0gdGhpcy5hdXRob3I7XG4gIH1cbiAgaWYgKCFzY2hlbWUpIHNjaGVtZSA9IHRoaXMuY29udGVudC5tYXRjaCgvXFxcXD9pdj0vKSA/IFwibmlwMDRcIiA6IFwibmlwNDRcIjtcbiAgaWYgKChzY2hlbWUgPT09IFwibmlwMDRcIiB8fCB0aGlzLmtpbmQgPT09IDQpICYmIGF3YWl0IGlzRW5jcnlwdGlvbkVuYWJsZWQoc2lnbmVyLCBcIm5pcDA0XCIpICYmIHRoaXMuY29udGVudC5zZWFyY2goXCJcXFxcP2l2PVwiKSkge1xuICAgIGRlY3J5cHRlZCA9IGF3YWl0IHNpZ25lci5kZWNyeXB0KHNlbmRlciwgdGhpcy5jb250ZW50LCBcIm5pcDA0XCIpO1xuICB9XG4gIGlmICghZGVjcnlwdGVkICYmIHNjaGVtZSA9PT0gXCJuaXA0NFwiICYmIGF3YWl0IGlzRW5jcnlwdGlvbkVuYWJsZWQoc2lnbmVyLCBcIm5pcDQ0XCIpKSB7XG4gICAgZGVjcnlwdGVkID0gYXdhaXQgc2lnbmVyLmRlY3J5cHQoc2VuZGVyLCB0aGlzLmNvbnRlbnQsIFwibmlwNDRcIik7XG4gIH1cbiAgaWYgKCFkZWNyeXB0ZWQpIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBkZWNyeXB0IGV2ZW50LlwiKTtcbiAgdGhpcy5jb250ZW50ID0gZGVjcnlwdGVkO1xufVxuYXN5bmMgZnVuY3Rpb24gaXNFbmNyeXB0aW9uRW5hYmxlZChzaWduZXIsIHNjaGVtZSkge1xuICBpZiAoIXNpZ25lci5lbmNyeXB0aW9uRW5hYmxlZCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoIXNjaGVtZSkgcmV0dXJuIHRydWU7XG4gIHJldHVybiBCb29sZWFuKGF3YWl0IHNpZ25lci5lbmNyeXB0aW9uRW5hYmxlZChzY2hlbWUpKTtcbn1cblxuLy8gc3JjL2V2ZW50cy9uaXAxOS50c1xuaW1wb3J0IHsgbmlwMTkgYXMgbmlwMTkyIH0gZnJvbSBcIm5vc3RyLXRvb2xzXCI7XG52YXIgREVGQVVMVF9SRUxBWV9DT1VOVCA9IDI7XG5mdW5jdGlvbiBlbmNvZGUobWF4UmVsYXlDb3VudCA9IERFRkFVTFRfUkVMQVlfQ09VTlQpIHtcbiAgbGV0IHJlbGF5cyA9IFtdO1xuICBpZiAodGhpcy5vblJlbGF5cy5sZW5ndGggPiAwKSB7XG4gICAgcmVsYXlzID0gdGhpcy5vblJlbGF5cy5tYXAoKHJlbGF5KSA9PiByZWxheS51cmwpO1xuICB9IGVsc2UgaWYgKHRoaXMucmVsYXkpIHtcbiAgICByZWxheXMgPSBbdGhpcy5yZWxheS51cmxdO1xuICB9XG4gIGlmIChyZWxheXMubGVuZ3RoID4gbWF4UmVsYXlDb3VudCkge1xuICAgIHJlbGF5cyA9IHJlbGF5cy5zbGljZSgwLCBtYXhSZWxheUNvdW50KTtcbiAgfVxuICBpZiAodGhpcy5pc1BhcmFtUmVwbGFjZWFibGUoKSkge1xuICAgIHJldHVybiBuaXAxOTIubmFkZHJFbmNvZGUoe1xuICAgICAga2luZDogdGhpcy5raW5kLFxuICAgICAgcHVia2V5OiB0aGlzLnB1YmtleSxcbiAgICAgIGlkZW50aWZpZXI6IHRoaXMucmVwbGFjZWFibGVEVGFnKCksXG4gICAgICByZWxheXNcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChyZWxheXMubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBuaXAxOTIubmV2ZW50RW5jb2RlKHtcbiAgICAgIGlkOiB0aGlzLnRhZ0lkKCksXG4gICAgICByZWxheXMsXG4gICAgICBhdXRob3I6IHRoaXMucHVia2V5XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5pcDE5Mi5ub3RlRW5jb2RlKHRoaXMudGFnSWQoKSk7XG4gIH1cbn1cblxuLy8gc3JjL2V2ZW50cy9yZXBvc3QudHNcbmFzeW5jIGZ1bmN0aW9uIHJlcG9zdChwdWJsaXNoID0gdHJ1ZSwgc2lnbmVyKSB7XG4gIGlmICghc2lnbmVyICYmIHB1Ymxpc2gpIHtcbiAgICBpZiAoIXRoaXMubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBOREsgaW5zdGFuY2UgZm91bmRcIik7XG4gICAgdGhpcy5uZGsuYXNzZXJ0U2lnbmVyKCk7XG4gICAgc2lnbmVyID0gdGhpcy5uZGsuc2lnbmVyO1xuICB9XG4gIGNvbnN0IGUgPSBuZXcgTkRLRXZlbnQodGhpcy5uZGssIHtcbiAgICBraW5kOiBnZXRLaW5kKHRoaXMpXG4gIH0pO1xuICBpZiAoIXRoaXMuaXNQcm90ZWN0ZWQpXG4gICAgZS5jb250ZW50ID0gSlNPTi5zdHJpbmdpZnkodGhpcy5yYXdFdmVudCgpKTtcbiAgZS50YWcodGhpcyk7XG4gIGlmICh0aGlzLmtpbmQgIT09IDEgLyogVGV4dCAqLykge1xuICAgIGUudGFncy5wdXNoKFtcImtcIiwgYCR7dGhpcy5raW5kfWBdKTtcbiAgfVxuICBpZiAoc2lnbmVyKSBhd2FpdCBlLnNpZ24oc2lnbmVyKTtcbiAgaWYgKHB1Ymxpc2gpIGF3YWl0IGUucHVibGlzaCgpO1xuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIGdldEtpbmQoZXZlbnQpIHtcbiAgaWYgKGV2ZW50LmtpbmQgPT09IDEpIHtcbiAgICByZXR1cm4gNiAvKiBSZXBvc3QgKi87XG4gIH1cbiAgcmV0dXJuIDE2IC8qIEdlbmVyaWNSZXBvc3QgKi87XG59XG5cbi8vIHNyYy90aHJlYWQvaW5kZXgudHNcbmZ1bmN0aW9uIGV2ZW50c0J5U2FtZUF1dGhvcihvcCwgZXZlbnRzKSB7XG4gIGNvbnN0IGV2ZW50c0J5QXV0aG9yID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgZXZlbnRzQnlBdXRob3Iuc2V0KG9wLmlkLCBvcCk7XG4gIGV2ZW50cy5mb3JFYWNoKChldmVudCkgPT4ge1xuICAgIGlmIChldmVudC5wdWJrZXkgPT09IG9wLnB1YmtleSkge1xuICAgICAgZXZlbnRzQnlBdXRob3Iuc2V0KGV2ZW50LmlkLCBldmVudCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGV2ZW50c0J5QXV0aG9yO1xufVxudmFyIGhhc01hcmtlcnMgPSAoZXZlbnQsIHRhZ1R5cGUpID0+IHtcbiAgcmV0dXJuIGV2ZW50LmdldE1hdGNoaW5nVGFncyh0YWdUeXBlKS5zb21lKCh0YWcpID0+IHRhZ1szXSAmJiB0YWdbM10gIT09IFwiXCIpO1xufTtcbmZ1bmN0aW9uIGV2ZW50SXNSZXBseShvcCwgZXZlbnQsIHRocmVhZElkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksIHRhZ1R5cGUpIHtcbiAgdGFnVHlwZSA/Pz0gb3AudGFnVHlwZSgpO1xuICBjb25zdCB0YWdzID0gZXZlbnQuZ2V0TWF0Y2hpbmdUYWdzKHRhZ1R5cGUpO1xuICB0aHJlYWRJZHMuYWRkKG9wLnRhZ0lkKCkpO1xuICBpZiAodGhyZWFkSWRzLmhhcyhldmVudC50YWdJZCgpKSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBoZWVkRXhwbGljaXRSZXBseU1hcmtlciA9ICgpID0+IHtcbiAgICBsZXQgZXZlbnRJc1RhZ2dlZCA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgdGFnIG9mIHRhZ3MpIHtcbiAgICAgIGlmICh0YWdbM10gPT09IFwicmVwbHlcIikgcmV0dXJuIHRocmVhZElkcy5oYXModGFnWzFdKTtcbiAgICAgIGNvbnN0IG1hcmtlcklzRW1wdHkgPSB0YWdbM10gPT09IFwiXCIgfHwgdGFnWzNdID09PSB2b2lkIDA7XG4gICAgICBjb25zdCBtYXJrZXJJc1Jvb3QgPSB0YWdbM10gPT09IFwicm9vdFwiO1xuICAgICAgaWYgKHRhZ1sxXSA9PT0gb3AudGFnSWQoKSAmJiAobWFya2VySXNFbXB0eSB8fCBtYXJrZXJJc1Jvb3QpKSB7XG4gICAgICAgIGV2ZW50SXNUYWdnZWQgPSBtYXJrZXJJc1Jvb3QgPyBcInJvb3RcIiA6IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghZXZlbnRJc1RhZ2dlZCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChldmVudElzVGFnZ2VkID09PSBcInJvb3RcIikgcmV0dXJuIHRydWU7XG4gIH07XG4gIGNvbnN0IGV4cGxpY2l0UmVwbHlNYXJrZXIgPSBoZWVkRXhwbGljaXRSZXBseU1hcmtlcigpO1xuICBpZiAoZXhwbGljaXRSZXBseU1hcmtlciAhPT0gdm9pZCAwKSByZXR1cm4gZXhwbGljaXRSZXBseU1hcmtlcjtcbiAgaWYgKGhhc01hcmtlcnMoZXZlbnQsIHRhZ1R5cGUpKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IGV4cGVjdGVkVGFncyA9IG9wLmdldE1hdGNoaW5nVGFncyhcImVcIikubWFwKCh0YWcpID0+IHRhZ1sxXSk7XG4gIGV4cGVjdGVkVGFncy5wdXNoKG9wLmlkKTtcbiAgcmV0dXJuIGV2ZW50LmdldE1hdGNoaW5nVGFncyhcImVcIikuZXZlcnkoKHRhZykgPT4gZXhwZWN0ZWRUYWdzLmluY2x1ZGVzKHRhZ1sxXSkpO1xufVxuZnVuY3Rpb24gZXZlbnRUaHJlYWRzKG9wLCBldmVudHMpIHtcbiAgY29uc3QgZXZlbnRzQnlBdXRob3IgPSBldmVudHNCeVNhbWVBdXRob3Iob3AsIGV2ZW50cyk7XG4gIGNvbnN0IHRocmVhZEV2ZW50cyA9IGV2ZW50cy5maWx0ZXIoKGV2ZW50KSA9PiBldmVudElzUGFydE9mVGhyZWFkKG9wLCBldmVudCwgZXZlbnRzQnlBdXRob3IpKTtcbiAgcmV0dXJuIHRocmVhZEV2ZW50cy5zb3J0KChhLCBiKSA9PiBhLmNyZWF0ZWRfYXQgLSBiLmNyZWF0ZWRfYXQpO1xufVxuZnVuY3Rpb24gZ2V0RXZlbnRSZXBseUlkKGV2ZW50KSB7XG4gIGNvbnN0IHJlcGx5VGFnID0gZ2V0UmVwbHlUYWcoZXZlbnQpO1xuICBpZiAocmVwbHlUYWcpIHJldHVybiByZXBseVRhZ1sxXTtcbiAgY29uc3Qgcm9vdFRhZyA9IGdldFJvb3RUYWcoZXZlbnQpO1xuICBpZiAocm9vdFRhZykgcmV0dXJuIHJvb3RUYWdbMV07XG59XG5mdW5jdGlvbiBpc0V2ZW50T3JpZ2luYWxQb3N0KGV2ZW50KSB7XG4gIHJldHVybiBnZXRFdmVudFJlcGx5SWQoZXZlbnQpID09PSB2b2lkIDA7XG59XG5mdW5jdGlvbiBldmVudFRocmVhZElkcyhvcCwgZXZlbnRzKSB7XG4gIGNvbnN0IHRocmVhZElkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IHRocmVhZEV2ZW50cyA9IGV2ZW50VGhyZWFkcyhvcCwgZXZlbnRzKTtcbiAgdGhyZWFkRXZlbnRzLmZvckVhY2goKGV2ZW50KSA9PiB0aHJlYWRJZHMuc2V0KGV2ZW50LmlkLCBldmVudCkpO1xuICByZXR1cm4gdGhyZWFkSWRzO1xufVxuZnVuY3Rpb24gZXZlbnRSZXBsaWVzKG9wLCBldmVudHMsIHRocmVhZEV2ZW50SWRzKSB7XG4gIHRocmVhZEV2ZW50SWRzID8/PSBuZXcgU2V0KGV2ZW50VGhyZWFkSWRzKG9wLCBldmVudHMpLmtleXMoKSk7XG4gIHJldHVybiBldmVudHMuZmlsdGVyKChldmVudCkgPT4gZXZlbnRJc1JlcGx5KG9wLCBldmVudCwgdGhyZWFkRXZlbnRJZHMpKTtcbn1cbmZ1bmN0aW9uIGV2ZW50SXNQYXJ0T2ZUaHJlYWQob3AsIGV2ZW50LCBldmVudHNCeUF1dGhvcikge1xuICBpZiAob3AucHVia2V5ICE9PSBldmVudC5wdWJrZXkpIHJldHVybiBmYWxzZTtcbiAgY29uc3QgdGFnZ2VkRXZlbnRJZHMgPSBldmVudC5nZXRNYXRjaGluZ1RhZ3MoXCJlXCIpLm1hcCgodGFnKSA9PiB0YWdbMV0pO1xuICBjb25zdCBhbGxUYWdnZWRFdmVudHNBcmVCeU9yaWdpbmFsQXV0aG9yID0gdGFnZ2VkRXZlbnRJZHMuZXZlcnkoKGlkKSA9PiBldmVudHNCeUF1dGhvci5oYXMoaWQpKTtcbiAgcmV0dXJuIGFsbFRhZ2dlZEV2ZW50c0FyZUJ5T3JpZ2luYWxBdXRob3I7XG59XG5mdW5jdGlvbiBldmVudEhhc0VUYWdNYXJrZXJzKGV2ZW50KSB7XG4gIGZvciAoY29uc3QgdGFnIG9mIGV2ZW50LnRhZ3MpIHtcbiAgICBpZiAodGFnWzBdID09PSBcImVcIiAmJiAodGFnWzNdID8/IFwiXCIpLmxlbmd0aCA+IDApIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldFJvb3RFdmVudElkKGV2ZW50LCBzZWFyY2hUYWcpIHtcbiAgc2VhcmNoVGFnID8/PSBldmVudC50YWdUeXBlKCk7XG4gIGNvbnN0IHJvb3RFdmVudFRhZyA9IGdldFJvb3RUYWcoZXZlbnQsIHNlYXJjaFRhZyk7XG4gIGlmIChyb290RXZlbnRUYWcpIHJldHVybiByb290RXZlbnRUYWdbMV07XG4gIGNvbnN0IHJlcGx5VGFnID0gZ2V0UmVwbHlUYWcoZXZlbnQsIHNlYXJjaFRhZyk7XG4gIHJldHVybiByZXBseVRhZz8uWzFdO1xufVxuZnVuY3Rpb24gZ2V0Um9vdFRhZyhldmVudCwgc2VhcmNoVGFnKSB7XG4gIHNlYXJjaFRhZyA/Pz0gZXZlbnQudGFnVHlwZSgpO1xuICBjb25zdCByb290RXZlbnRUYWcgPSBldmVudC50YWdzLmZpbmQoaXNUYWdSb290VGFnKTtcbiAgaWYgKCFyb290RXZlbnRUYWcpIHtcbiAgICBpZiAoZXZlbnRIYXNFVGFnTWFya2VycyhldmVudCkpIHJldHVybjtcbiAgICBjb25zdCBtYXRjaGluZ1RhZ3MgPSBldmVudC5nZXRNYXRjaGluZ1RhZ3Moc2VhcmNoVGFnKTtcbiAgICBpZiAobWF0Y2hpbmdUYWdzLmxlbmd0aCA8IDMpIHJldHVybiBtYXRjaGluZ1RhZ3NbMF07XG4gIH1cbiAgcmV0dXJuIHJvb3RFdmVudFRhZztcbn1cbnZhciBuaXAyMlJvb3RUYWdzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wiQVwiLCBcIkVcIiwgXCJJXCJdKTtcbnZhciBuaXAyMlJlcGx5VGFncyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcImFcIiwgXCJlXCIsIFwiaVwiXSk7XG5mdW5jdGlvbiBnZXRSZXBseVRhZyhldmVudCwgc2VhcmNoVGFnKSB7XG4gIGlmIChldmVudC5raW5kID09PSAxMTExIC8qIEdlbmVyaWNSZXBseSAqLykge1xuICAgIGxldCByZXBseVRhZzI7XG4gICAgZm9yIChjb25zdCB0YWcgb2YgZXZlbnQudGFncykge1xuICAgICAgaWYgKG5pcDIyUm9vdFRhZ3MuaGFzKHRhZ1swXSkpIHJlcGx5VGFnMiA9IHRhZztcbiAgICAgIGVsc2UgaWYgKG5pcDIyUmVwbHlUYWdzLmhhcyh0YWdbMF0pKSB7XG4gICAgICAgIHJlcGx5VGFnMiA9IHRhZztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXBseVRhZzI7XG4gIH1cbiAgc2VhcmNoVGFnID8/PSBldmVudC50YWdUeXBlKCk7XG4gIGxldCBoYXNNYXJrZXJzMiA9IGZhbHNlO1xuICBsZXQgcmVwbHlUYWc7XG4gIGZvciAoY29uc3QgdGFnIG9mIGV2ZW50LnRhZ3MpIHtcbiAgICBpZiAodGFnWzBdICE9PSBzZWFyY2hUYWcpIGNvbnRpbnVlO1xuICAgIGlmICgodGFnWzNdID8/IFwiXCIpLmxlbmd0aCA+IDApIGhhc01hcmtlcnMyID0gdHJ1ZTtcbiAgICBpZiAoaGFzTWFya2VyczIgJiYgdGFnWzNdID09PSBcInJlcGx5XCIpIHJldHVybiB0YWc7XG4gICAgaWYgKGhhc01hcmtlcnMyICYmIHRhZ1szXSA9PT0gXCJyb290XCIpIHJlcGx5VGFnID0gdGFnO1xuICAgIGlmICghaGFzTWFya2VyczIpIHJlcGx5VGFnID0gdGFnO1xuICB9XG4gIHJldHVybiByZXBseVRhZztcbn1cbmZ1bmN0aW9uIGlzVGFnUm9vdFRhZyh0YWcpIHtcbiAgcmV0dXJuIHRhZ1swXSA9PT0gXCJFXCIgfHwgdGFnWzNdID09PSBcInJvb3RcIjtcbn1cblxuLy8gc3JjL2V2ZW50cy9mZXRjaC10YWdnZWQtZXZlbnQudHNcbmFzeW5jIGZ1bmN0aW9uIGZldGNoVGFnZ2VkRXZlbnQodGFnLCBtYXJrZXIpIHtcbiAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTkRLIGluc3RhbmNlIG5vdCBmb3VuZFwiKTtcbiAgY29uc3QgdCA9IHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKHRhZywgbWFya2VyKTtcbiAgaWYgKHQubGVuZ3RoID09PSAwKSByZXR1cm4gdm9pZCAwO1xuICBjb25zdCBbXywgaWQsIGhpbnRdID0gdFswXTtcbiAgbGV0IHJlbGF5O1xuICBjb25zdCBldmVudCA9IGF3YWl0IHRoaXMubmRrLmZldGNoRXZlbnQoaWQsIHt9LCByZWxheSk7XG4gIHJldHVybiBldmVudDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGZldGNoUm9vdEV2ZW50KHN1Yk9wdHMpIHtcbiAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTkRLIGluc3RhbmNlIG5vdCBmb3VuZFwiKTtcbiAgY29uc3Qgcm9vdFRhZyA9IGdldFJvb3RUYWcodGhpcyk7XG4gIGlmICghcm9vdFRhZykgcmV0dXJuIHZvaWQgMDtcbiAgcmV0dXJuIHRoaXMubmRrLmZldGNoRXZlbnRGcm9tVGFnKHJvb3RUYWcsIHRoaXMsIHN1Yk9wdHMpO1xufVxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hSZXBseUV2ZW50KHN1Yk9wdHMpIHtcbiAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTkRLIGluc3RhbmNlIG5vdCBmb3VuZFwiKTtcbiAgY29uc3QgcmVwbHlUYWcgPSBnZXRSZXBseVRhZyh0aGlzKTtcbiAgaWYgKCFyZXBseVRhZykgcmV0dXJuIHZvaWQgMDtcbiAgcmV0dXJuIHRoaXMubmRrLmZldGNoRXZlbnRGcm9tVGFnKHJlcGx5VGFnLCB0aGlzLCBzdWJPcHRzKTtcbn1cblxuLy8gc3JjL2V2ZW50cy9zZXJpYWxpemVyLnRzXG5mdW5jdGlvbiBzZXJpYWxpemUoaW5jbHVkZVNpZyA9IGZhbHNlLCBpbmNsdWRlSWQgPSBmYWxzZSkge1xuICBjb25zdCBwYXlsb2FkID0gWzAsIHRoaXMucHVia2V5LCB0aGlzLmNyZWF0ZWRfYXQsIHRoaXMua2luZCwgdGhpcy50YWdzLCB0aGlzLmNvbnRlbnRdO1xuICBpZiAoaW5jbHVkZVNpZykgcGF5bG9hZC5wdXNoKHRoaXMuc2lnKTtcbiAgaWYgKGluY2x1ZGVJZCkgcGF5bG9hZC5wdXNoKHRoaXMuaWQpO1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocGF5bG9hZCk7XG59XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZShzZXJpYWxpemVkRXZlbnQpIHtcbiAgY29uc3QgZXZlbnRBcnJheSA9IEpTT04ucGFyc2Uoc2VyaWFsaXplZEV2ZW50KTtcbiAgY29uc3QgcmV0ID0ge1xuICAgIHB1YmtleTogZXZlbnRBcnJheVsxXSxcbiAgICBjcmVhdGVkX2F0OiBldmVudEFycmF5WzJdLFxuICAgIGtpbmQ6IGV2ZW50QXJyYXlbM10sXG4gICAgdGFnczogZXZlbnRBcnJheVs0XSxcbiAgICBjb250ZW50OiBldmVudEFycmF5WzVdXG4gIH07XG4gIGlmIChldmVudEFycmF5Lmxlbmd0aCA+PSA3KSByZXQuc2lnID0gZXZlbnRBcnJheVs2XTtcbiAgaWYgKGV2ZW50QXJyYXkubGVuZ3RoID49IDgpIHJldC5pZCA9IGV2ZW50QXJyYXlbN107XG4gIHJldHVybiByZXQ7XG59XG5cbi8vIHNyYy9ldmVudHMvdmFsaWRhdGlvbi50c1xuaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvc2hhMjU2XCI7XG5pbXBvcnQgeyBieXRlc1RvSGV4IH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvdXRpbHNcIjtcbmltcG9ydCB7IHNjaG5vcnIgfSBmcm9tIFwiQG5vYmxlL2N1cnZlcy9zZWNwMjU2azFcIjtcblxuLy8gc3JjL2V2ZW50cy9zaWduYXR1cmUudHNcbnZhciB3b3JrZXI7XG52YXIgcHJvY2Vzc2luZ1F1ZXVlID0ge307XG5mdW5jdGlvbiBzaWduYXR1cmVWZXJpZmljYXRpb25Jbml0KHcpIHtcbiAgd29ya2VyID0gdztcbiAgd29ya2VyLm9ubWVzc2FnZSA9IChtc2cpID0+IHtcbiAgICBjb25zdCBbZXZlbnRJZCwgcmVzdWx0XSA9IG1zZy5kYXRhO1xuICAgIGNvbnN0IHJlY29yZCA9IHByb2Nlc3NpbmdRdWV1ZVtldmVudElkXTtcbiAgICBpZiAoIXJlY29yZCkge1xuICAgICAgY29uc29sZS5lcnJvcihcIk5vIHJlY29yZCBmb3VuZCBmb3IgZXZlbnRcIiwgZXZlbnRJZCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRlbGV0ZSBwcm9jZXNzaW5nUXVldWVbZXZlbnRJZF07XG4gICAgZm9yIChjb25zdCByZXNvbHZlIG9mIHJlY29yZC5yZXNvbHZlcykge1xuICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgIH1cbiAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHZlcmlmeVNpZ25hdHVyZUFzeW5jKGV2ZW50LCBwZXJzaXN0KSB7XG4gIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBldmVudC5zZXJpYWxpemUoKTtcbiAgICBsZXQgZW5xdWV1ZSA9IGZhbHNlO1xuICAgIGlmICghcHJvY2Vzc2luZ1F1ZXVlW2V2ZW50LmlkXSkge1xuICAgICAgcHJvY2Vzc2luZ1F1ZXVlW2V2ZW50LmlkXSA9IHsgZXZlbnQsIHJlc29sdmVzOiBbXSB9O1xuICAgICAgZW5xdWV1ZSA9IHRydWU7XG4gICAgfVxuICAgIHByb2Nlc3NpbmdRdWV1ZVtldmVudC5pZF0ucmVzb2x2ZXMucHVzaChyZXNvbHZlKTtcbiAgICBpZiAoIWVucXVldWUpIHJldHVybjtcbiAgICB3b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgc2VyaWFsaXplZCxcbiAgICAgIGlkOiBldmVudC5pZCxcbiAgICAgIHNpZzogZXZlbnQuc2lnLFxuICAgICAgcHVia2V5OiBldmVudC5wdWJrZXlcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBwcm9taXNlO1xufVxuXG4vLyBzcmMvZXZlbnRzL3ZhbGlkYXRpb24udHNcbmltcG9ydCB7IExSVUNhY2hlIH0gZnJvbSBcInR5cGVzY3JpcHQtbHJ1LWNhY2hlXCI7XG52YXIgUFVCS0VZX1JFR0VYID0gL15bYS1mMC05XXs2NH0kLztcbmZ1bmN0aW9uIHZhbGlkYXRlKCkge1xuICBpZiAodHlwZW9mIHRoaXMua2luZCAhPT0gXCJudW1iZXJcIikgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIHRoaXMuY29udGVudCAhPT0gXCJzdHJpbmdcIikgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIHRoaXMuY3JlYXRlZF9hdCAhPT0gXCJudW1iZXJcIikgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIHRoaXMucHVia2V5ICE9PSBcInN0cmluZ1wiKSByZXR1cm4gZmFsc2U7XG4gIGlmICghdGhpcy5wdWJrZXkubWF0Y2goUFVCS0VZX1JFR0VYKSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoIUFycmF5LmlzQXJyYXkodGhpcy50YWdzKSkgcmV0dXJuIGZhbHNlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudGFncy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHRhZyA9IHRoaXMudGFnc1tpXTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodGFnKSkgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGFnLmxlbmd0aDsgaisrKSB7XG4gICAgICBpZiAodHlwZW9mIHRhZ1tqXSA9PT0gXCJvYmplY3RcIikgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbnZhciB2ZXJpZmllZFNpZ25hdHVyZXMgPSBuZXcgTFJVQ2FjaGUoe1xuICBtYXhTaXplOiAxZTMsXG4gIGVudHJ5RXhwaXJhdGlvblRpbWVJbk1TOiA2ZTRcbn0pO1xuZnVuY3Rpb24gdmVyaWZ5U2lnbmF0dXJlKHBlcnNpc3QpIHtcbiAgaWYgKHR5cGVvZiB0aGlzLnNpZ25hdHVyZVZlcmlmaWVkID09PSBcImJvb2xlYW5cIikgcmV0dXJuIHRoaXMuc2lnbmF0dXJlVmVyaWZpZWQ7XG4gIGNvbnN0IHByZXZWZXJpZmljYXRpb24gPSB2ZXJpZmllZFNpZ25hdHVyZXMuZ2V0KHRoaXMuaWQpO1xuICBpZiAocHJldlZlcmlmaWNhdGlvbiAhPT0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLnNpZ25hdHVyZVZlcmlmaWVkID0gISFwcmV2VmVyaWZpY2F0aW9uO1xuICB9XG4gIHRyeSB7XG4gICAgaWYgKHRoaXMubmRrPy5hc3luY1NpZ1ZlcmlmaWNhdGlvbikge1xuICAgICAgdmVyaWZ5U2lnbmF0dXJlQXN5bmModGhpcywgcGVyc2lzdCkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgIGlmIChwZXJzaXN0KSB7XG4gICAgICAgICAgdGhpcy5zaWduYXR1cmVWZXJpZmllZCA9IHJlc3VsdDtcbiAgICAgICAgICBpZiAocmVzdWx0KSB2ZXJpZmllZFNpZ25hdHVyZXMuc2V0KHRoaXMuaWQsIHRoaXMuc2lnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgIHRoaXMubmRrLmVtaXQoXCJldmVudDppbnZhbGlkLXNpZ1wiLCB0aGlzKTtcbiAgICAgICAgICB2ZXJpZmllZFNpZ25hdHVyZXMuc2V0KHRoaXMuaWQsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGhhc2ggPSBzaGEyNTYobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHRoaXMuc2VyaWFsaXplKCkpKTtcbiAgICAgIGNvbnN0IHJlcyA9IHNjaG5vcnIudmVyaWZ5KHRoaXMuc2lnLCBoYXNoLCB0aGlzLnB1YmtleSk7XG4gICAgICBpZiAocmVzKSB2ZXJpZmllZFNpZ25hdHVyZXMuc2V0KHRoaXMuaWQsIHRoaXMuc2lnKTtcbiAgICAgIGVsc2UgdmVyaWZpZWRTaWduYXR1cmVzLnNldCh0aGlzLmlkLCBmYWxzZSk7XG4gICAgICByZXR1cm4gdGhpcy5zaWduYXR1cmVWZXJpZmllZCA9IHJlcztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiB0aGlzLnNpZ25hdHVyZVZlcmlmaWVkID0gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEV2ZW50SGFzaCgpIHtcbiAgcmV0dXJuIGdldEV2ZW50SGFzaEZyb21TZXJpYWxpemVkRXZlbnQodGhpcy5zZXJpYWxpemUoKSk7XG59XG5mdW5jdGlvbiBnZXRFdmVudEhhc2hGcm9tU2VyaWFsaXplZEV2ZW50KHNlcmlhbGl6ZWRFdmVudCkge1xuICBjb25zdCBldmVudEhhc2ggPSBzaGEyNTYobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHNlcmlhbGl6ZWRFdmVudCkpO1xuICByZXR1cm4gYnl0ZXNUb0hleChldmVudEhhc2gpO1xufVxuXG4vLyBzcmMvZXZlbnRzL2luZGV4LnRzXG52YXIgc2tpcENsaWVudFRhZ09uS2luZHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIDAgLyogTWV0YWRhdGEgKi8sXG4gIDQgLyogRW5jcnlwdGVkRGlyZWN0TWVzc2FnZSAqLyxcbiAgMTA1OSAvKiBHaWZ0V3JhcCAqLyxcbiAgMTMgLyogR2lmdFdyYXBTZWFsICovLFxuICAzIC8qIENvbnRhY3RzICovLFxuICA5NzM0IC8qIFphcFJlcXVlc3QgKi8sXG4gIDUgLyogRXZlbnREZWxldGlvbiAqL1xuXSk7XG52YXIgTkRLRXZlbnQgPSBjbGFzcyBfTkRLRXZlbnQgZXh0ZW5kcyBFdmVudEVtaXR0ZXIyIHtcbiAgbmRrO1xuICBjcmVhdGVkX2F0O1xuICBjb250ZW50ID0gXCJcIjtcbiAgdGFncyA9IFtdO1xuICBraW5kO1xuICBpZCA9IFwiXCI7XG4gIHNpZztcbiAgcHVia2V5ID0gXCJcIjtcbiAgc2lnbmF0dXJlVmVyaWZpZWQ7XG4gIF9hdXRob3IgPSB2b2lkIDA7XG4gIC8qKlxuICAgKiBUaGUgcmVsYXkgdGhhdCB0aGlzIGV2ZW50IHdhcyBmaXJzdCByZWNlaXZlZCBmcm9tLlxuICAgKi9cbiAgcmVsYXk7XG4gIC8qKlxuICAgKiBUaGUgcmVsYXlzIHRoYXQgdGhpcyBldmVudCB3YXMgcmVjZWl2ZWQgZnJvbSBhbmQvb3Igc3VjY2Vzc2Z1bGx5IHB1Ymxpc2hlZCB0by5cbiAgICovXG4gIGdldCBvblJlbGF5cygpIHtcbiAgICBsZXQgcmVzID0gW107XG4gICAgaWYgKCF0aGlzLm5kaykge1xuICAgICAgaWYgKHRoaXMucmVsYXkpIHJlcy5wdXNoKHRoaXMucmVsYXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXMgPSB0aGlzLm5kay5zdWJNYW5hZ2VyLnNlZW5FdmVudHMuZ2V0KHRoaXMuaWQpIHx8IFtdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgc3RhdHVzIG9mIHRoZSBwdWJsaXNoIG9wZXJhdGlvbi5cbiAgICovXG4gIHB1Ymxpc2hTdGF0dXMgPSBcInN1Y2Nlc3NcIjtcbiAgcHVibGlzaEVycm9yO1xuICBjb25zdHJ1Y3RvcihuZGssIGV2ZW50KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm5kayA9IG5kaztcbiAgICB0aGlzLmNyZWF0ZWRfYXQgPSBldmVudD8uY3JlYXRlZF9hdDtcbiAgICB0aGlzLmNvbnRlbnQgPSBldmVudD8uY29udGVudCB8fCBcIlwiO1xuICAgIHRoaXMudGFncyA9IGV2ZW50Py50YWdzIHx8IFtdO1xuICAgIHRoaXMuaWQgPSBldmVudD8uaWQgfHwgXCJcIjtcbiAgICB0aGlzLnNpZyA9IGV2ZW50Py5zaWc7XG4gICAgdGhpcy5wdWJrZXkgPSBldmVudD8ucHVia2V5IHx8IFwiXCI7XG4gICAgdGhpcy5raW5kID0gZXZlbnQ/LmtpbmQ7XG4gICAgaWYgKGV2ZW50IGluc3RhbmNlb2YgX05ES0V2ZW50KSB7XG4gICAgICBpZiAodGhpcy5yZWxheSkge1xuICAgICAgICB0aGlzLnJlbGF5ID0gZXZlbnQucmVsYXk7XG4gICAgICAgIHRoaXMubmRrPy5zdWJNYW5hZ2VyLnNlZW5FdmVudChldmVudC5pZCwgdGhpcy5yZWxheSk7XG4gICAgICB9XG4gICAgICB0aGlzLnB1Ymxpc2hTdGF0dXMgPSBldmVudC5wdWJsaXNoU3RhdHVzO1xuICAgICAgdGhpcy5wdWJsaXNoRXJyb3IgPSBldmVudC5wdWJsaXNoRXJyb3I7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBEZXNlcmlhbGl6ZSBhbiBOREtFdmVudCBmcm9tIGEgc2VyaWFsaXplZCBwYXlsb2FkLlxuICAgKiBAcGFyYW0gbmRrXG4gICAqIEBwYXJhbSBldmVudFxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgc3RhdGljIGRlc2VyaWFsaXplKG5kaywgZXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtFdmVudChuZGssIGRlc2VyaWFsaXplKGV2ZW50KSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGV2ZW50IGFzIGlzLlxuICAgKi9cbiAgcmF3RXZlbnQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNyZWF0ZWRfYXQ6IHRoaXMuY3JlYXRlZF9hdCxcbiAgICAgIGNvbnRlbnQ6IHRoaXMuY29udGVudCxcbiAgICAgIHRhZ3M6IHRoaXMudGFncyxcbiAgICAgIGtpbmQ6IHRoaXMua2luZCxcbiAgICAgIHB1YmtleTogdGhpcy5wdWJrZXksXG4gICAgICBpZDogdGhpcy5pZCxcbiAgICAgIHNpZzogdGhpcy5zaWdcbiAgICB9O1xuICB9XG4gIHNldCBhdXRob3IodXNlcikge1xuICAgIHRoaXMucHVia2V5ID0gdXNlci5wdWJrZXk7XG4gICAgdGhpcy5fYXV0aG9yID0gdXNlcjtcbiAgICB0aGlzLl9hdXRob3IubmRrID8/PSB0aGlzLm5kaztcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbiBOREtVc2VyIGZvciB0aGUgYXV0aG9yIG9mIHRoZSBldmVudC5cbiAgICovXG4gIGdldCBhdXRob3IoKSB7XG4gICAgaWYgKHRoaXMuX2F1dGhvcikgcmV0dXJuIHRoaXMuX2F1dGhvcjtcbiAgICBpZiAoIXRoaXMubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBOREsgaW5zdGFuY2UgZm91bmRcIik7XG4gICAgY29uc3QgdXNlciA9IHRoaXMubmRrLmdldFVzZXIoeyBwdWJrZXk6IHRoaXMucHVia2V5IH0pO1xuICAgIHRoaXMuX2F1dGhvciA9IHVzZXI7XG4gICAgcmV0dXJuIHVzZXI7XG4gIH1cbiAgLyoqXG4gICAqIE5JUC03MyB0YWdnaW5nIG9mIGV4dGVybmFsIGVudGl0aWVzXG4gICAqIEBwYXJhbSBlbnRpdHkgdG8gYmUgdGFnZ2VkXG4gICAqIEBwYXJhbSB0eXBlIG9mIHRoZSBlbnRpdHlcbiAgICogQHBhcmFtIG1hcmtlclVybCB0byBiZSB1c2VkIGFzIHRoZSBtYXJrZXIgVVJMXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogZXZlbnQudGFnRXh0ZXJuYWwoXCJodHRwczovL2V4YW1wbGUuY29tL2FydGljbGUvMTIzI25vc3RyXCIsIFwidXJsXCIpO1xuICAgKiBldmVudC50YWdzID0+IFtbXCJpXCIsIFwiaHR0cHM6Ly9leGFtcGxlLmNvbS8xMjNcIl0sIFtcImtcIiwgXCJodHRwczovL2V4YW1wbGUuY29tXCJdXVxuICAgKiBgYGBcbiAgICpcbiAgICogQGV4YW1wbGUgdGFnIGEgcG9kY2FzdDppdGVtOmd1aWRcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBldmVudC50YWdFeHRlcm5hbChcImUzMmI0ODkwLWI5ZWEtNGFlZi1hMGJmLTU0Yjc4NzgzM2RjNVwiLCBcInBvZGNhc3Q6aXRlbTpndWlkXCIpO1xuICAgKiBldmVudC50YWdzID0+IFtbXCJpXCIsIFwicG9kY2FzdDppdGVtOmd1aWQ6ZTMyYjQ4OTAtYjllYS00YWVmLWEwYmYtNTRiNzg3ODMzZGM1XCJdLCBbXCJrXCIsIFwicG9kY2FzdDppdGVtOmd1aWRcIl1dXG4gICAqIGBgYFxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ub3N0ci1wcm90b2NvbC9uaXBzL2Jsb2IvbWFzdGVyLzczLm1kXG4gICAqL1xuICB0YWdFeHRlcm5hbChlbnRpdHksIHR5cGUsIG1hcmtlclVybCkge1xuICAgIGxldCBpVGFnID0gW1wiaVwiXTtcbiAgICBsZXQga1RhZyA9IFtcImtcIl07XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFwidXJsXCI6XG4gICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoZW50aXR5KTtcbiAgICAgICAgdXJsLmhhc2ggPSBcIlwiO1xuICAgICAgICBpVGFnLnB1c2godXJsLnRvU3RyaW5nKCkpO1xuICAgICAgICBrVGFnLnB1c2goYCR7dXJsLnByb3RvY29sfS8vJHt1cmwuaG9zdH1gKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiaGFzaHRhZ1wiOlxuICAgICAgICBpVGFnLnB1c2goYCMke2VudGl0eS50b0xvd2VyQ2FzZSgpfWApO1xuICAgICAgICBrVGFnLnB1c2goXCIjXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJnZW9oYXNoXCI6XG4gICAgICAgIGlUYWcucHVzaChgZ2VvOiR7ZW50aXR5LnRvTG93ZXJDYXNlKCl9YCk7XG4gICAgICAgIGtUYWcucHVzaChcImdlb1wiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiaXNiblwiOlxuICAgICAgICBpVGFnLnB1c2goYGlzYm46JHtlbnRpdHkucmVwbGFjZSgvLS9nLCBcIlwiKX1gKTtcbiAgICAgICAga1RhZy5wdXNoKFwiaXNiblwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwicG9kY2FzdDpndWlkXCI6XG4gICAgICAgIGlUYWcucHVzaChgcG9kY2FzdDpndWlkOiR7ZW50aXR5fWApO1xuICAgICAgICBrVGFnLnB1c2goXCJwb2RjYXN0Omd1aWRcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInBvZGNhc3Q6aXRlbTpndWlkXCI6XG4gICAgICAgIGlUYWcucHVzaChgcG9kY2FzdDppdGVtOmd1aWQ6JHtlbnRpdHl9YCk7XG4gICAgICAgIGtUYWcucHVzaChcInBvZGNhc3Q6aXRlbTpndWlkXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJwb2RjYXN0OnB1Ymxpc2hlcjpndWlkXCI6XG4gICAgICAgIGlUYWcucHVzaChgcG9kY2FzdDpwdWJsaXNoZXI6Z3VpZDoke2VudGl0eX1gKTtcbiAgICAgICAga1RhZy5wdXNoKFwicG9kY2FzdDpwdWJsaXNoZXI6Z3VpZFwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiaXNhblwiOlxuICAgICAgICBpVGFnLnB1c2goYGlzYW46JHtlbnRpdHkuc3BsaXQoXCItXCIpLnNsaWNlKDAsIDQpLmpvaW4oXCItXCIpfWApO1xuICAgICAgICBrVGFnLnB1c2goXCJpc2FuXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJkb2lcIjpcbiAgICAgICAgaVRhZy5wdXNoKGBkb2k6JHtlbnRpdHkudG9Mb3dlckNhc2UoKX1gKTtcbiAgICAgICAga1RhZy5wdXNoKFwiZG9pXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgTklQLTczIGVudGl0eSB0eXBlOiAke3R5cGV9YCk7XG4gICAgfVxuICAgIGlmIChtYXJrZXJVcmwpIHtcbiAgICAgIGlUYWcucHVzaChtYXJrZXJVcmwpO1xuICAgIH1cbiAgICB0aGlzLnRhZ3MucHVzaChpVGFnKTtcbiAgICB0aGlzLnRhZ3MucHVzaChrVGFnKTtcbiAgfVxuICAvKipcbiAgICogVGFnIGEgdXNlciB3aXRoIGFuIG9wdGlvbmFsIG1hcmtlci5cbiAgICogQHBhcmFtIHRhcmdldCBXaGF0IGlzIHRvIGJlIHRhZ2dlZC4gQ2FuIGJlIGFuIE5ES1VzZXIsIE5ES0V2ZW50LCBvciBhbiBOREtUYWcuXG4gICAqIEBwYXJhbSBtYXJrZXIgVGhlIG1hcmtlciB0byB1c2UgaW4gdGhlIHRhZy5cbiAgICogQHBhcmFtIHNraXBBdXRob3JUYWcgV2hldGhlciB0byBleHBsaWNpdGx5IHNraXAgYWRkaW5nIHRoZSBhdXRob3IgdGFnIG9mIHRoZSBldmVudC5cbiAgICogQHBhcmFtIGZvcmNlVGFnIEZvcmNlIGEgc3BlY2lmaWMgdGFnIHRvIGJlIHVzZWQgaW5zdGVhZCBvZiB0aGUgZGVmYXVsdCBcImVcIiBvciBcImFcIiB0YWcuXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogcmVwbHkudGFnKG9wRXZlbnQsIFwicmVwbHlcIik7XG4gICAqIC8vIHJlcGx5LnRhZ3MgPT4gW1tcImVcIiwgPGlkPiwgPHJlbGF5PiwgXCJyZXBseVwiXV1cbiAgICogYGBgXG4gICAqL1xuICB0YWcodGFyZ2V0LCBtYXJrZXIsIHNraXBBdXRob3JUYWcsIGZvcmNlVGFnKSB7XG4gICAgbGV0IHRhZ3MgPSBbXTtcbiAgICBjb25zdCBpc05ES1VzZXIgPSB0YXJnZXQuZmV0Y2hQcm9maWxlICE9PSB2b2lkIDA7XG4gICAgaWYgKGlzTkRLVXNlcikge1xuICAgICAgZm9yY2VUYWcgPz89IFwicFwiO1xuICAgICAgY29uc3QgdGFnID0gW2ZvcmNlVGFnLCB0YXJnZXQucHVia2V5XTtcbiAgICAgIGlmIChtYXJrZXIpIHRhZy5wdXNoKC4uLltcIlwiLCBtYXJrZXJdKTtcbiAgICAgIHRhZ3MucHVzaCh0YWcpO1xuICAgIH0gZWxzZSBpZiAodGFyZ2V0IGluc3RhbmNlb2YgX05ES0V2ZW50KSB7XG4gICAgICBjb25zdCBldmVudCA9IHRhcmdldDtcbiAgICAgIHNraXBBdXRob3JUYWcgPz89IGV2ZW50Py5wdWJrZXkgPT09IHRoaXMucHVia2V5O1xuICAgICAgdGFncyA9IGV2ZW50LnJlZmVyZW5jZVRhZ3MobWFya2VyLCBza2lwQXV0aG9yVGFnLCBmb3JjZVRhZyk7XG4gICAgICBmb3IgKGNvbnN0IHBUYWcgb2YgZXZlbnQuZ2V0TWF0Y2hpbmdUYWdzKFwicFwiKSkge1xuICAgICAgICBpZiAocFRhZ1sxXSA9PT0gdGhpcy5wdWJrZXkpIGNvbnRpbnVlO1xuICAgICAgICBpZiAodGhpcy50YWdzLmZpbmQoKHQpID0+IHRbMF0gPT09IFwicFwiICYmIHRbMV0gPT09IHBUYWdbMV0pKSBjb250aW51ZTtcbiAgICAgICAgdGhpcy50YWdzLnB1c2goW1wicFwiLCBwVGFnWzFdXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkpIHtcbiAgICAgIHRhZ3MgPSBbdGFyZ2V0XTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhcmd1bWVudFwiLCB0YXJnZXQpO1xuICAgIH1cbiAgICB0aGlzLnRhZ3MgPSBtZXJnZVRhZ3ModGhpcy50YWdzLCB0YWdzKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGEgTm9zdHJFdmVudCBvYmplY3QsIHRyeWluZyB0byBmaWxsIGluIG1pc3NpbmcgZmllbGRzXG4gICAqIHdoZW4gcG9zc2libGUsIGFkZGluZyB0YWdzIHdoZW4gbmVjZXNzYXJ5LlxuICAgKiBAcGFyYW0gcHVia2V5IHtzdHJpbmd9IFRoZSBwdWJrZXkgb2YgdGhlIHVzZXIgd2hvIHRoZSBldmVudCBiZWxvbmdzIHRvLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxOb3N0ckV2ZW50Pn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBOb3N0ckV2ZW50LlxuICAgKi9cbiAgYXN5bmMgdG9Ob3N0ckV2ZW50KHB1YmtleSkge1xuICAgIGlmICghcHVia2V5ICYmIHRoaXMucHVia2V5ID09PSBcIlwiKSB7XG4gICAgICBjb25zdCB1c2VyID0gYXdhaXQgdGhpcy5uZGs/LnNpZ25lcj8udXNlcigpO1xuICAgICAgdGhpcy5wdWJrZXkgPSB1c2VyPy5wdWJrZXkgfHwgXCJcIjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmNyZWF0ZWRfYXQpIHtcbiAgICAgIHRoaXMuY3JlYXRlZF9hdCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDFlMyk7XG4gICAgfVxuICAgIGNvbnN0IHsgY29udGVudCwgdGFncyB9ID0gYXdhaXQgdGhpcy5nZW5lcmF0ZVRhZ3MoKTtcbiAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50IHx8IFwiXCI7XG4gICAgdGhpcy50YWdzID0gdGFncztcbiAgICB0cnkge1xuICAgICAgdGhpcy5pZCA9IHRoaXMuZ2V0RXZlbnRIYXNoKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yYXdFdmVudCgpO1xuICB9XG4gIHNlcmlhbGl6ZSA9IHNlcmlhbGl6ZS5iaW5kKHRoaXMpO1xuICBnZXRFdmVudEhhc2ggPSBnZXRFdmVudEhhc2guYmluZCh0aGlzKTtcbiAgdmFsaWRhdGUgPSB2YWxpZGF0ZS5iaW5kKHRoaXMpO1xuICB2ZXJpZnlTaWduYXR1cmUgPSB2ZXJpZnlTaWduYXR1cmUuYmluZCh0aGlzKTtcbiAgLyoqXG4gICAqIElzIHRoaXMgZXZlbnQgcmVwbGFjZWFibGUgKHdoZXRoZXIgcGFyYW1ldGVyaXplZCBvciBub3QpP1xuICAgKlxuICAgKiBUaGlzIHdpbGwgcmV0dXJuIHRydWUgZm9yIGtpbmQgMCwgMywgMTBrLTIwayBhbmQgMzBrLTQwa1xuICAgKi9cbiAgaXNSZXBsYWNlYWJsZSA9IGlzUmVwbGFjZWFibGUuYmluZCh0aGlzKTtcbiAgaXNFcGhlbWVyYWwgPSBpc0VwaGVtZXJhbC5iaW5kKHRoaXMpO1xuICBpc0R2bSA9ICgpID0+IHRoaXMua2luZCAmJiB0aGlzLmtpbmQgPj0gNWUzICYmIHRoaXMua2luZCA8PSA3ZTM7XG4gIC8qKlxuICAgKiBJcyB0aGlzIGV2ZW50IHBhcmFtZXRlcml6ZWQgcmVwbGFjZWFibGU/XG4gICAqXG4gICAqIFRoaXMgd2lsbCByZXR1cm4gdHJ1ZSBmb3Iga2luZCAzMGstNDBrXG4gICAqL1xuICBpc1BhcmFtUmVwbGFjZWFibGUgPSBpc1BhcmFtUmVwbGFjZWFibGUuYmluZCh0aGlzKTtcbiAgLyoqXG4gICAqIEVuY29kZXMgYSBiZWNoMzIgaWQuXG4gICAqXG4gICAqIEBwYXJhbSByZWxheXMge3N0cmluZ1tdfSBUaGUgcmVsYXlzIHRvIGVuY29kZSBpbiB0aGUgaWRcbiAgICogQHJldHVybnMge3N0cmluZ30gLSBFbmNvZGVkIG5hZGRyLCBub3RlIG9yIG5ldmVudC5cbiAgICovXG4gIGVuY29kZSA9IGVuY29kZS5iaW5kKHRoaXMpO1xuICBlbmNyeXB0ID0gZW5jcnlwdC5iaW5kKHRoaXMpO1xuICBkZWNyeXB0ID0gZGVjcnlwdC5iaW5kKHRoaXMpO1xuICAvKipcbiAgICogR2V0IGFsbCB0YWdzIHdpdGggdGhlIGdpdmVuIG5hbWVcbiAgICogQHBhcmFtIHRhZ05hbWUge3N0cmluZ30gVGhlIG5hbWUgb2YgdGhlIHRhZyB0byBzZWFyY2ggZm9yXG4gICAqIEByZXR1cm5zIHtOREtUYWdbXX0gQW4gYXJyYXkgb2YgdGhlIG1hdGNoaW5nIHRhZ3NcbiAgICovXG4gIGdldE1hdGNoaW5nVGFncyh0YWdOYW1lLCBtYXJrZXIpIHtcbiAgICBjb25zdCB0ID0gdGhpcy50YWdzLmZpbHRlcigodGFnKSA9PiB0YWdbMF0gPT09IHRhZ05hbWUpO1xuICAgIGlmIChtYXJrZXIgPT09IHZvaWQgMCkgcmV0dXJuIHQ7XG4gICAgcmV0dXJuIHQuZmlsdGVyKCh0YWcpID0+IHRhZ1szXSA9PT0gbWFya2VyKTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIGV2ZW50IGhhcyBhIHRhZyB3aXRoIHRoZSBnaXZlbiBuYW1lXG4gICAqIEBwYXJhbSB0YWdOYW1lXG4gICAqIEBwYXJhbSBtYXJrZXJcbiAgICogQHJldHVybnNcbiAgICovXG4gIGhhc1RhZyh0YWdOYW1lLCBtYXJrZXIpIHtcbiAgICByZXR1cm4gdGhpcy50YWdzLnNvbWUoKHRhZykgPT4gdGFnWzBdID09PSB0YWdOYW1lICYmICghbWFya2VyIHx8IHRhZ1szXSA9PT0gbWFya2VyKSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgZmlyc3QgdGFnIHdpdGggdGhlIGdpdmVuIG5hbWVcbiAgICogQHBhcmFtIHRhZ05hbWUgVGFnIG5hbWUgdG8gc2VhcmNoIGZvclxuICAgKiBAcmV0dXJucyBUaGUgdmFsdWUgb2YgdGhlIGZpcnN0IHRhZyB3aXRoIHRoZSBnaXZlbiBuYW1lLCBvciB1bmRlZmluZWQgaWYgbm8gc3VjaCB0YWcgZXhpc3RzXG4gICAqL1xuICB0YWdWYWx1ZSh0YWdOYW1lKSB7XG4gICAgY29uc3QgdGFncyA9IHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKHRhZ05hbWUpO1xuICAgIGlmICh0YWdzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHZvaWQgMDtcbiAgICByZXR1cm4gdGFnc1swXVsxXTtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgTklQLTMxIFwiYWx0XCIgdGFnIG9mIHRoZSBldmVudC5cbiAgICovXG4gIGdldCBhbHQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJhbHRcIik7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIE5JUC0zMSBcImFsdFwiIHRhZyBvZiB0aGUgZXZlbnQuIFVzZSB0aGlzIHRvIHNldCBhbiBhbHQgdGFnIHNvXG4gICAqIGNsaWVudHMgdGhhdCBkb24ndCBoYW5kbGUgYSBwYXJ0aWN1bGFyIGV2ZW50IGtpbmQgY2FuIGRpc3BsYXkgc29tZXRoaW5nXG4gICAqIHVzZWZ1bCBmb3IgdXNlcnMuXG4gICAqL1xuICBzZXQgYWx0KGFsdCkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwiYWx0XCIpO1xuICAgIGlmIChhbHQpIHRoaXMudGFncy5wdXNoKFtcImFsdFwiLCBhbHRdKTtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgTklQLTMzIFwiZFwiIHRhZyBvZiB0aGUgZXZlbnQuXG4gICAqL1xuICBnZXQgZFRhZygpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcImRcIik7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIE5JUC0zMyBcImRcIiB0YWcgb2YgdGhlIGV2ZW50LlxuICAgKi9cbiAgc2V0IGRUYWcodmFsdWUpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImRcIik7XG4gICAgaWYgKHZhbHVlKSB0aGlzLnRhZ3MucHVzaChbXCJkXCIsIHZhbHVlXSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSBhbGwgdGFncyB3aXRoIHRoZSBnaXZlbiBuYW1lIChlLmcuIFwiZFwiLCBcImFcIiwgXCJwXCIpXG4gICAqIEBwYXJhbSB0YWdOYW1lIFRhZyBuYW1lKHMpIHRvIHNlYXJjaCBmb3IgYW5kIHJlbW92ZVxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIHJlbW92ZVRhZyh0YWdOYW1lKSB7XG4gICAgY29uc3QgdGFnTmFtZXMgPSBBcnJheS5pc0FycmF5KHRhZ05hbWUpID8gdGFnTmFtZSA6IFt0YWdOYW1lXTtcbiAgICB0aGlzLnRhZ3MgPSB0aGlzLnRhZ3MuZmlsdGVyKCh0YWcpID0+ICF0YWdOYW1lcy5pbmNsdWRlcyh0YWdbMF0pKTtcbiAgfVxuICAvKipcbiAgICogU2lnbiB0aGUgZXZlbnQgaWYgYSBzaWduZXIgaXMgcHJlc2VudC5cbiAgICpcbiAgICogSXQgd2lsbCBnZW5lcmF0ZSB0YWdzLlxuICAgKiBSZXBsZWFjYWJsZSBldmVudHMgd2lsbCBoYXZlIHRoZWlyIGNyZWF0ZWRfYXQgZmllbGQgc2V0IHRvIHRoZSBjdXJyZW50IHRpbWUuXG4gICAqIEBwYXJhbSBzaWduZXIge05ES1NpZ25lcn0gVGhlIE5ES1NpZ25lciB0byB1c2UgdG8gc2lnbiB0aGUgZXZlbnRcbiAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHNpZ25hdHVyZSBvZiB0aGUgc2lnbmVkIGV2ZW50LlxuICAgKi9cbiAgYXN5bmMgc2lnbihzaWduZXIpIHtcbiAgICBpZiAoIXNpZ25lcikge1xuICAgICAgdGhpcy5uZGs/LmFzc2VydFNpZ25lcigpO1xuICAgICAgc2lnbmVyID0gdGhpcy5uZGsuc2lnbmVyO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmF1dGhvciA9IGF3YWl0IHNpZ25lci51c2VyKCk7XG4gICAgfVxuICAgIGNvbnN0IG5vc3RyRXZlbnQgPSBhd2FpdCB0aGlzLnRvTm9zdHJFdmVudCgpO1xuICAgIHRoaXMuc2lnID0gYXdhaXQgc2lnbmVyLnNpZ24obm9zdHJFdmVudCk7XG4gICAgcmV0dXJuIHRoaXMuc2lnO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0gcmVsYXlTZXRcbiAgICogQHBhcmFtIHRpbWVvdXRNc1xuICAgKiBAcGFyYW0gcmVxdWlyZWRSZWxheUNvdW50XG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBhc3luYyBwdWJsaXNoUmVwbGFjZWFibGUocmVsYXlTZXQsIHRpbWVvdXRNcywgcmVxdWlyZWRSZWxheUNvdW50KSB7XG4gICAgdGhpcy5pZCA9IFwiXCI7XG4gICAgdGhpcy5jcmVhdGVkX2F0ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMWUzKTtcbiAgICB0aGlzLnNpZyA9IFwiXCI7XG4gICAgcmV0dXJuIHRoaXMucHVibGlzaChyZWxheVNldCwgdGltZW91dE1zLCByZXF1aXJlZFJlbGF5Q291bnQpO1xuICB9XG4gIC8qKlxuICAgKiBBdHRlbXB0IHRvIHNpZ24gYW5kIHRoZW4gcHVibGlzaCBhbiBOREtFdmVudCB0byBhIGdpdmVuIHJlbGF5U2V0LlxuICAgKiBJZiBubyByZWxheVNldCBpcyBwcm92aWRlZCwgdGhlIHJlbGF5U2V0IHdpbGwgYmUgY2FsY3VsYXRlZCBieSBOREsuXG4gICAqIEBwYXJhbSByZWxheVNldCB7TkRLUmVsYXlTZXR9IFRoZSByZWxheVNldCB0byBwdWJsaXNoIHRoZSBldmVuIHRvLlxuICAgKiBAcGFyYW0gdGltZW91dE0ge251bWJlcn0gVGhlIHRpbWVvdXQgZm9yIHRoZSBwdWJsaXNoIG9wZXJhdGlvbiBpbiBtaWxsaXNlY29uZHMuXG4gICAqIEBwYXJhbSByZXF1aXJlZFJlbGF5Q291bnQgVGhlIG51bWJlciBvZiByZWxheXMgdGhhdCBtdXN0IHJlY2VpdmUgdGhlIGV2ZW50IGZvciB0aGUgcHVibGlzaCB0byBiZSBjb25zaWRlcmVkIHN1Y2Nlc3NmdWwuXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSByZWxheXMgdGhlIGV2ZW50IHdhcyBwdWJsaXNoZWQgdG8uXG4gICAqL1xuICBhc3luYyBwdWJsaXNoKHJlbGF5U2V0LCB0aW1lb3V0TXMsIHJlcXVpcmVkUmVsYXlDb3VudCkge1xuICAgIGlmICghdGhpcy5zaWcpIGF3YWl0IHRoaXMuc2lnbigpO1xuICAgIGlmICghdGhpcy5uZGspXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOREtFdmVudCBtdXN0IGJlIGFzc29jaWF0ZWQgd2l0aCBhbiBOREsgaW5zdGFuY2UgdG8gcHVibGlzaFwiKTtcbiAgICBpZiAoIXJlbGF5U2V0KSB7XG4gICAgICByZWxheVNldCA9IHRoaXMubmRrLmRldldyaXRlUmVsYXlTZXQgfHwgYXdhaXQgY2FsY3VsYXRlUmVsYXlTZXRGcm9tRXZlbnQodGhpcy5uZGssIHRoaXMpO1xuICAgIH1cbiAgICBpZiAodGhpcy5raW5kID09PSA1IC8qIEV2ZW50RGVsZXRpb24gKi8gJiYgdGhpcy5uZGsuY2FjaGVBZGFwdGVyPy5kZWxldGVFdmVudElkcykge1xuICAgICAgY29uc3QgZVRhZ3MgPSB0aGlzLmdldE1hdGNoaW5nVGFncyhcImVcIikubWFwKCh0YWcpID0+IHRhZ1sxXSk7XG4gICAgICB0aGlzLm5kay5jYWNoZUFkYXB0ZXIuZGVsZXRlRXZlbnRJZHMoZVRhZ3MpO1xuICAgIH1cbiAgICBjb25zdCByYXdFdmVudCA9IHRoaXMucmF3RXZlbnQoKTtcbiAgICBpZiAodGhpcy5uZGsuY2FjaGVBZGFwdGVyPy5hZGRVbnB1Ymxpc2hlZEV2ZW50ICYmIHNob3VsZFRyYWNrVW5wdWJsaXNoZWRFdmVudCh0aGlzKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5uZGsuY2FjaGVBZGFwdGVyLmFkZFVucHVibGlzaGVkRXZlbnQodGhpcywgcmVsYXlTZXQucmVsYXlVcmxzKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGFkZGluZyB1bnB1Ymxpc2hlZCBldmVudCB0byBjYWNoZVwiLCBlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMua2luZCA9PT0gNSAvKiBFdmVudERlbGV0aW9uICovICYmIHRoaXMubmRrLmNhY2hlQWRhcHRlcj8uZGVsZXRlRXZlbnRJZHMpIHtcbiAgICAgIHRoaXMubmRrLmNhY2hlQWRhcHRlci5kZWxldGVFdmVudElkcyh0aGlzLmdldE1hdGNoaW5nVGFncyhcImVcIikubWFwKCh0YWcpID0+IHRhZ1sxXSkpO1xuICAgIH1cbiAgICB0aGlzLm5kay5zdWJNYW5hZ2VyLmRpc3BhdGNoRXZlbnQocmF3RXZlbnQsIHZvaWQgMCwgdHJ1ZSk7XG4gICAgY29uc3QgcmVsYXlzID0gYXdhaXQgcmVsYXlTZXQucHVibGlzaCh0aGlzLCB0aW1lb3V0TXMsIHJlcXVpcmVkUmVsYXlDb3VudCk7XG4gICAgcmVsYXlzLmZvckVhY2goKHJlbGF5KSA9PiB0aGlzLm5kaz8uc3ViTWFuYWdlci5zZWVuRXZlbnQodGhpcy5pZCwgcmVsYXkpKTtcbiAgICByZXR1cm4gcmVsYXlzO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgdGFncyBmb3IgdXNlcnMsIG5vdGVzLCBhbmQgb3RoZXIgZXZlbnRzIHRhZ2dlZCBpbiBjb250ZW50LlxuICAgKiBXaWxsIGFsc28gZ2VuZXJhdGUgcmFuZG9tIFwiZFwiIHRhZyBmb3IgcGFyYW1ldGVyaXplZCByZXBsYWNlYWJsZSBldmVudHMgd2hlcmUgbmVlZGVkLlxuICAgKiBAcmV0dXJucyB7Q29udGVudFRhZ30gVGhlIHRhZ3MgYW5kIGNvbnRlbnQgb2YgdGhlIGV2ZW50LlxuICAgKi9cbiAgYXN5bmMgZ2VuZXJhdGVUYWdzKCkge1xuICAgIGxldCB0YWdzID0gW107XG4gICAgY29uc3QgZyA9IGF3YWl0IGdlbmVyYXRlQ29udGVudFRhZ3ModGhpcy5jb250ZW50LCB0aGlzLnRhZ3MpO1xuICAgIGNvbnN0IGNvbnRlbnQgPSBnLmNvbnRlbnQ7XG4gICAgdGFncyA9IGcudGFncztcbiAgICBpZiAodGhpcy5raW5kICYmIHRoaXMuaXNQYXJhbVJlcGxhY2VhYmxlKCkpIHtcbiAgICAgIGNvbnN0IGRUYWcgPSB0aGlzLmdldE1hdGNoaW5nVGFncyhcImRcIilbMF07XG4gICAgICBpZiAoIWRUYWcpIHtcbiAgICAgICAgY29uc3QgdGl0bGUgPSB0aGlzLnRhZ1ZhbHVlKFwidGl0bGVcIik7XG4gICAgICAgIGNvbnN0IHJhbmRMZW5ndGggPSB0aXRsZSA/IDYgOiAxNjtcbiAgICAgICAgbGV0IHN0ciA9IFsuLi5BcnJheShyYW5kTGVuZ3RoKV0ubWFwKCgpID0+IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpWzJdKS5qb2luKFwiXCIpO1xuICAgICAgICBpZiAodGl0bGUgJiYgdGl0bGUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHN0ciA9IHRpdGxlLnJlcGxhY2UoL1teYS16MC05XSsvZ2ksIFwiLVwiKS5yZXBsYWNlKC9eLXwtJC9nLCBcIlwiKSArIFwiLVwiICsgc3RyO1xuICAgICAgICB9XG4gICAgICAgIHRhZ3MucHVzaChbXCJkXCIsIHN0cl0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5zaG91bGRBZGRDbGllbnRUYWcpIHtcbiAgICAgIGNvbnN0IGNsaWVudFRhZyA9IFtcImNsaWVudFwiLCB0aGlzLm5kay5jbGllbnROYW1lID8/IFwiXCJdO1xuICAgICAgaWYgKHRoaXMubmRrLmNsaWVudE5pcDg5KSBjbGllbnRUYWcucHVzaCh0aGlzLm5kay5jbGllbnROaXA4OSk7XG4gICAgICB0YWdzLnB1c2goY2xpZW50VGFnKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc2hvdWxkU3RyaXBDbGllbnRUYWcpIHtcbiAgICAgIHRhZ3MgPSB0YWdzLmZpbHRlcigodGFnKSA9PiB0YWdbMF0gIT09IFwiY2xpZW50XCIpO1xuICAgIH1cbiAgICByZXR1cm4geyBjb250ZW50OiBjb250ZW50IHx8IFwiXCIsIHRhZ3MgfTtcbiAgfVxuICBnZXQgc2hvdWxkQWRkQ2xpZW50VGFnKCkge1xuICAgIGlmICghdGhpcy5uZGs/LmNsaWVudE5hbWUgJiYgIXRoaXMubmRrPy5jbGllbnROaXA4OSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChza2lwQ2xpZW50VGFnT25LaW5kcy5oYXModGhpcy5raW5kKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0aGlzLmlzRXBoZW1lcmFsKCkgfHwgdGhpcy5pc1JlcGxhY2VhYmxlKCkpIHJldHVybiBmYWxzZTtcbiAgICBpZiAodGhpcy5pc0R2bSgpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHRoaXMuaGFzVGFnKFwiY2xpZW50XCIpKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZ2V0IHNob3VsZFN0cmlwQ2xpZW50VGFnKCkge1xuICAgIHJldHVybiBza2lwQ2xpZW50VGFnT25LaW5kcy5oYXModGhpcy5raW5kKTtcbiAgfVxuICBtdXRlZCgpIHtcbiAgICBjb25zdCBhdXRob3JNdXRlZEVudHJ5ID0gdGhpcy5uZGs/Lm11dGVkSWRzLmdldCh0aGlzLnB1YmtleSk7XG4gICAgaWYgKGF1dGhvck11dGVkRW50cnkgJiYgYXV0aG9yTXV0ZWRFbnRyeSA9PT0gXCJwXCIpIHJldHVybiBcImF1dGhvclwiO1xuICAgIGNvbnN0IGV2ZW50VGFnUmVmZXJlbmNlID0gdGhpcy50YWdSZWZlcmVuY2UoKTtcbiAgICBjb25zdCBldmVudE11dGVkRW50cnkgPSB0aGlzLm5kaz8ubXV0ZWRJZHMuZ2V0KGV2ZW50VGFnUmVmZXJlbmNlWzFdKTtcbiAgICBpZiAoZXZlbnRNdXRlZEVudHJ5ICYmIGV2ZW50TXV0ZWRFbnRyeSA9PT0gZXZlbnRUYWdSZWZlcmVuY2VbMF0pIHJldHVybiBcImV2ZW50XCI7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIFwiZFwiIHRhZyBvZiBhIHBhcmFtZXRlcml6ZWQgcmVwbGFjZWFibGUgZXZlbnQgb3IgdGhyb3dzIGFuIGVycm9yIGlmIHRoZSBldmVudCBpc24ndFxuICAgKiBhIHBhcmFtZXRlcml6ZWQgcmVwbGFjZWFibGUgZXZlbnQuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBcImRcIiB0YWcgb2YgdGhlIGV2ZW50LlxuICAgKiBcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGBkVGFnYCBpbnN0ZWFkLlxuICAgKi9cbiAgcmVwbGFjZWFibGVEVGFnKCkge1xuICAgIGlmICh0aGlzLmtpbmQgJiYgdGhpcy5raW5kID49IDNlNCAmJiB0aGlzLmtpbmQgPD0gNGU0KSB7XG4gICAgICBjb25zdCBkVGFnID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJkXCIpWzBdO1xuICAgICAgY29uc3QgZFRhZ0lkID0gZFRhZyA/IGRUYWdbMV0gOiBcIlwiO1xuICAgICAgcmV0dXJuIGRUYWdJZDtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnQgaXMgbm90IGEgcGFyYW1ldGVyaXplZCByZXBsYWNlYWJsZSBldmVudFwiKTtcbiAgfVxuICAvKipcbiAgICogUHJvdmlkZXMgYSBkZWR1cGxpY2F0aW9uIGtleSBmb3IgdGhlIGV2ZW50LlxuICAgKlxuICAgKiBGb3Iga2luZHMgMCwgMywgMTBrLTIwayB0aGlzIHdpbGwgYmUgdGhlIGV2ZW50IDxraW5kPjo8cHVia2V5PlxuICAgKiBGb3Iga2luZHMgMzBrLTQwayB0aGlzIHdpbGwgYmUgdGhlIGV2ZW50IDxraW5kPjo8cHVia2V5Pjo8ZC10YWc+XG4gICAqIEZvciBhbGwgb3RoZXIga2luZHMgdGhpcyB3aWxsIGJlIHRoZSBldmVudCBpZFxuICAgKi9cbiAgZGVkdXBsaWNhdGlvbktleSgpIHtcbiAgICBpZiAodGhpcy5raW5kID09PSAwIHx8IHRoaXMua2luZCA9PT0gMyB8fCB0aGlzLmtpbmQgJiYgdGhpcy5raW5kID49IDFlNCAmJiB0aGlzLmtpbmQgPCAyZTQpIHtcbiAgICAgIHJldHVybiBgJHt0aGlzLmtpbmR9OiR7dGhpcy5wdWJrZXl9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMudGFnSWQoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGlkIG9mIHRoZSBldmVudCBvciwgaWYgaXQncyBhIHBhcmFtZXRlcml6ZWQgZXZlbnQsIHRoZSBnZW5lcmF0ZWQgaWQgb2YgdGhlIGV2ZW50IHVzaW5nIFwiZFwiIHRhZywgcHVia2V5LCBhbmQga2luZC5cbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGlkXG4gICAqL1xuICB0YWdJZCgpIHtcbiAgICBpZiAodGhpcy5pc1BhcmFtUmVwbGFjZWFibGUoKSkge1xuICAgICAgcmV0dXJuIHRoaXMudGFnQWRkcmVzcygpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5pZDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIHN0YWJsZSByZWZlcmVuY2UgdmFsdWUgZm9yIGEgcmVwbGFjZWFibGUgZXZlbnQuXG4gICAqIFxuICAgKiBQYXJhbSByZXBsYWNlYWJsZSBldmVudHMgYXJlIHJldHVybmVkIGluIHRoZSBleHBlY3RlZCBmb3JtYXQgb2YgYDxraW5kPjo8cHVia2V5Pjo8ZC10YWc+YC5cbiAgICogS2luZC1yZXBsYWNlYWJsZSBldmVudHMgYXJlIHJldHVybmVkIGluIHRoZSBmb3JtYXQgb2YgYDxraW5kPjo8cHVia2V5PjpgLlxuICAgKiBcbiAgICogQHJldHVybnMge3N0cmluZ30gQSBzdGFibGUgcmVmZXJlbmNlIHZhbHVlIGZvciByZXBsYWNlYWJsZSBldmVudHNcbiAgICovXG4gIHRhZ0FkZHJlc3MoKSB7XG4gICAgaWYgKHRoaXMuaXNQYXJhbVJlcGxhY2VhYmxlKCkpIHtcbiAgICAgIGNvbnN0IGRUYWdJZCA9IHRoaXMuZFRhZyA/PyBcIlwiO1xuICAgICAgcmV0dXJuIGAke3RoaXMua2luZH06JHt0aGlzLnB1YmtleX06JHtkVGFnSWR9YDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNSZXBsYWNlYWJsZSgpKSB7XG4gICAgICByZXR1cm4gYCR7dGhpcy5raW5kfToke3RoaXMucHVia2V5fTpgO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFdmVudCBpcyBub3QgYSByZXBsYWNlYWJsZSBldmVudFwiKTtcbiAgfVxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB0aGUgdHlwZSBvZiB0YWcgdGhhdCBjYW4gYmUgdXNlZCB0byByZWZlcmVuY2UgdGhpcyBldmVudCBmcm9tIGFub3RoZXIgZXZlbnQuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSB0YWcgdHlwZVxuICAgKiBAZXhhbXBsZVxuICAgKiBldmVudCA9IG5ldyBOREtFdmVudChuZGssIHsga2luZDogMzAwMDAsIHB1YmtleTogJ3B1YmtleScsIHRhZ3M6IFsgW1wiZFwiLCBcImQtY29kZVwiXSBdIH0pO1xuICAgKiBldmVudC50YWdUeXBlKCk7IC8vIFwiYVwiXG4gICAqL1xuICB0YWdUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLmlzUGFyYW1SZXBsYWNlYWJsZSgpID8gXCJhXCIgOiBcImVcIjtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSB0YWcgdGhhdCBjYW4gYmUgdXNlZCB0byByZWZlcmVuY2UgdGhpcyBldmVudCBmcm9tIGFub3RoZXIgZXZlbnQuXG4gICAqXG4gICAqIENvbnNpZGVyIHVzaW5nIHJlZmVyZW5jZVRhZ3MoKSBpbnN0ZWFkICh1bmxlc3MgeW91IGhhdmUgYSBnb29kIHJlYXNvbiB0byB1c2UgdGhpcylcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogICAgIGV2ZW50ID0gbmV3IE5ES0V2ZW50KG5kaywgeyBraW5kOiAzMDAwMCwgcHVia2V5OiAncHVia2V5JywgdGFnczogWyBbXCJkXCIsIFwiZC1jb2RlXCJdIF0gfSk7XG4gICAqICAgICBldmVudC50YWdSZWZlcmVuY2UoKTsgLy8gW1wiYVwiLCBcIjMwMDAwOnB1YmtleTpkLWNvZGVcIl1cbiAgICpcbiAgICogICAgIGV2ZW50ID0gbmV3IE5ES0V2ZW50KG5kaywgeyBraW5kOiAxLCBwdWJrZXk6ICdwdWJrZXknLCBpZDogXCJldmVudGlkXCIgfSk7XG4gICAqICAgICBldmVudC50YWdSZWZlcmVuY2UoKTsgLy8gW1wiZVwiLCBcImV2ZW50aWRcIl1cbiAgICogQHJldHVybnMge05ES1RhZ30gVGhlIE5ES1RhZyBvYmplY3QgcmVmZXJlbmNpbmcgdGhpcyBldmVudFxuICAgKi9cbiAgdGFnUmVmZXJlbmNlKG1hcmtlcikge1xuICAgIGxldCB0YWc7XG4gICAgaWYgKHRoaXMuaXNQYXJhbVJlcGxhY2VhYmxlKCkpIHtcbiAgICAgIHRhZyA9IFtcImFcIiwgdGhpcy50YWdBZGRyZXNzKCldO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YWcgPSBbXCJlXCIsIHRoaXMudGFnSWQoKV07XG4gICAgfVxuICAgIGlmICh0aGlzLnJlbGF5KSB7XG4gICAgICB0YWcucHVzaCh0aGlzLnJlbGF5LnVybCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhZy5wdXNoKFwiXCIpO1xuICAgIH1cbiAgICB0YWcucHVzaChtYXJrZXIgPz8gXCJcIik7XG4gICAgaWYgKCF0aGlzLmlzUGFyYW1SZXBsYWNlYWJsZSgpKSB7XG4gICAgICB0YWcucHVzaCh0aGlzLnB1YmtleSk7XG4gICAgfVxuICAgIHJldHVybiB0YWc7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgdGFncyB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlZmVyZW5jZSB0aGlzIGV2ZW50IGZyb20gYW5vdGhlciBldmVudFxuICAgKiBAcGFyYW0gbWFya2VyIFRoZSBtYXJrZXIgdG8gdXNlIGluIHRoZSB0YWdcbiAgICogQHBhcmFtIHNraXBBdXRob3JUYWcgV2hldGhlciB0byBleHBsaWNpdGx5IHNraXAgYWRkaW5nIHRoZSBhdXRob3IgdGFnIG9mIHRoZSBldmVudFxuICAgKiBAcGFyYW0gZm9yY2VUYWcgRm9yY2UgYSBzcGVjaWZpYyB0YWcgdG8gYmUgdXNlZCBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IFwiZVwiIG9yIFwiYVwiIHRhZ1xuICAgKiBAZXhhbXBsZVxuICAgKiAgICAgZXZlbnQgPSBuZXcgTkRLRXZlbnQobmRrLCB7IGtpbmQ6IDMwMDAwLCBwdWJrZXk6ICdwdWJrZXknLCB0YWdzOiBbIFtcImRcIiwgXCJkLWNvZGVcIl0gXSB9KTtcbiAgICogICAgIGV2ZW50LnJlZmVyZW5jZVRhZ3MoKTsgLy8gW1tcImFcIiwgXCIzMDAwMDpwdWJrZXk6ZC1jb2RlXCJdLCBbXCJlXCIsIFwicGFyZW50LWlkXCJdXVxuICAgKlxuICAgKiAgICAgZXZlbnQgPSBuZXcgTkRLRXZlbnQobmRrLCB7IGtpbmQ6IDEsIHB1YmtleTogJ3B1YmtleScsIGlkOiBcImV2ZW50aWRcIiB9KTtcbiAgICogICAgIGV2ZW50LnJlZmVyZW5jZVRhZ3MoKTsgLy8gW1tcImVcIiwgXCJwYXJlbnQtaWRcIl1dXG4gICAqIEByZXR1cm5zIHtOREtUYWd9IFRoZSBOREtUYWcgb2JqZWN0IHJlZmVyZW5jaW5nIHRoaXMgZXZlbnRcbiAgICovXG4gIHJlZmVyZW5jZVRhZ3MobWFya2VyLCBza2lwQXV0aG9yVGFnLCBmb3JjZVRhZykge1xuICAgIGxldCB0YWdzID0gW107XG4gICAgaWYgKHRoaXMuaXNQYXJhbVJlcGxhY2VhYmxlKCkpIHtcbiAgICAgIHRhZ3MgPSBbXG4gICAgICAgIFtmb3JjZVRhZyA/PyBcImFcIiwgdGhpcy50YWdBZGRyZXNzKCldLFxuICAgICAgICBbZm9yY2VUYWcgPz8gXCJlXCIsIHRoaXMuaWRdXG4gICAgICBdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YWdzID0gW1tmb3JjZVRhZyA/PyBcImVcIiwgdGhpcy5pZF1dO1xuICAgIH1cbiAgICB0YWdzID0gdGFncy5tYXAoKHRhZykgPT4ge1xuICAgICAgaWYgKHRhZ1swXSA9PT0gXCJlXCIgfHwgbWFya2VyKSB7XG4gICAgICAgIHRhZy5wdXNoKHRoaXMucmVsYXk/LnVybCA/PyBcIlwiKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5yZWxheT8udXJsKSB7XG4gICAgICAgIHRhZy5wdXNoKHRoaXMucmVsYXk/LnVybCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFnO1xuICAgIH0pO1xuICAgIHRhZ3MuZm9yRWFjaCgodGFnKSA9PiB7XG4gICAgICBpZiAodGFnWzBdID09PSBcImVcIikge1xuICAgICAgICB0YWcucHVzaChtYXJrZXIgPz8gXCJcIik7XG4gICAgICAgIHRhZy5wdXNoKHRoaXMucHVia2V5KTtcbiAgICAgIH0gZWxzZSBpZiAobWFya2VyKSB7XG4gICAgICAgIHRhZy5wdXNoKG1hcmtlcik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGFncyA9IFsuLi50YWdzLCAuLi50aGlzLmdldE1hdGNoaW5nVGFncyhcImhcIildO1xuICAgIGlmICghc2tpcEF1dGhvclRhZykgdGFncy5wdXNoKC4uLnRoaXMuYXV0aG9yLnJlZmVyZW5jZVRhZ3MoKSk7XG4gICAgcmV0dXJuIHRhZ3M7XG4gIH1cbiAgLyoqXG4gICAqIFByb3ZpZGVzIHRoZSBmaWx0ZXIgdGhhdCB3aWxsIHJldHVybiBtYXRjaGluZyBldmVudHMgZm9yIHRoaXMgZXZlbnQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICAgIGV2ZW50ID0gbmV3IE5ES0V2ZW50KG5kaywgeyBraW5kOiAzMDAwMCwgcHVia2V5OiAncHVia2V5JywgdGFnczogWyBbXCJkXCIsIFwiZC1jb2RlXCJdIF0gfSk7XG4gICAqICAgIGV2ZW50LmZpbHRlcigpOyAvLyB7IFwiI2FcIjogW1wiMzAwMDA6cHVia2V5OmQtY29kZVwiXSB9XG4gICAqIEBleGFtcGxlXG4gICAqICAgIGV2ZW50ID0gbmV3IE5ES0V2ZW50KG5kaywgeyBraW5kOiAxLCBwdWJrZXk6ICdwdWJrZXknLCBpZDogXCJldmVudGlkXCIgfSk7XG4gICAqICAgIGV2ZW50LmZpbHRlcigpOyAvLyB7IFwiI2VcIjogW1wiZXZlbnRpZFwiXSB9XG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSBmaWx0ZXIgdGhhdCB3aWxsIHJldHVybiBtYXRjaGluZyBldmVudHMgZm9yIHRoaXMgZXZlbnRcbiAgICovXG4gIGZpbHRlcigpIHtcbiAgICBpZiAodGhpcy5pc1BhcmFtUmVwbGFjZWFibGUoKSkge1xuICAgICAgcmV0dXJuIHsgXCIjYVwiOiBbdGhpcy50YWdJZCgpXSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4geyBcIiNlXCI6IFt0aGlzLnRhZ0lkKCldIH07XG4gICAgfVxuICB9XG4gIG5pcDIyRmlsdGVyKCkge1xuICAgIGlmICh0aGlzLmlzUGFyYW1SZXBsYWNlYWJsZSgpKSB7XG4gICAgICByZXR1cm4geyBcIiNBXCI6IFt0aGlzLnRhZ0lkKCldIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7IFwiI0VcIjogW3RoaXMudGFnSWQoKV0gfTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIGRlbGV0aW9uIGV2ZW50IG9mIHRoZSBjdXJyZW50IGV2ZW50XG4gICAqXG4gICAqIEBwYXJhbSByZWFzb24gVGhlIHJlYXNvbiBmb3IgdGhlIGRlbGV0aW9uXG4gICAqIEBwYXJhbSBwdWJsaXNoIFdoZXRoZXIgdG8gcHVibGlzaCB0aGUgZGVsZXRpb24gZXZlbnQgYXV0b21hdGljYWxseVxuICAgKiBAcmV0dXJucyBUaGUgZGVsZXRpb24gZXZlbnRcbiAgICovXG4gIGFzeW5jIGRlbGV0ZShyZWFzb24sIHB1Ymxpc2ggPSB0cnVlKSB7XG4gICAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTm8gTkRLIGluc3RhbmNlIGZvdW5kXCIpO1xuICAgIHRoaXMubmRrLmFzc2VydFNpZ25lcigpO1xuICAgIGNvbnN0IGUgPSBuZXcgX05ES0V2ZW50KHRoaXMubmRrLCB7XG4gICAgICBraW5kOiA1IC8qIEV2ZW50RGVsZXRpb24gKi8sXG4gICAgICBjb250ZW50OiByZWFzb24gfHwgXCJcIlxuICAgIH0pO1xuICAgIGUudGFnKHRoaXMsIHZvaWQgMCwgdHJ1ZSk7XG4gICAgZS50YWdzLnB1c2goW1wia1wiLCB0aGlzLmtpbmQudG9TdHJpbmcoKV0pO1xuICAgIGlmIChwdWJsaXNoKSB7XG4gICAgICB0aGlzLmVtaXQoXCJkZWxldGVkXCIpO1xuICAgICAgYXdhaXQgZS5wdWJsaXNoKCk7XG4gICAgfVxuICAgIHJldHVybiBlO1xuICB9XG4gIC8qKlxuICAgKiBFc3RhYmxpc2hlcyB3aGV0aGVyIHRoaXMgaXMgYSBOSVAtNzAtcHJvdGVjdGVkZSBldmVudC5cbiAgICogQEBzYXRpc2ZpZXMgTklQLTcwXG4gICAqL1xuICBzZXQgaXNQcm90ZWN0ZWQodmFsKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCItXCIpO1xuICAgIGlmICh2YWwpIHRoaXMudGFncy5wdXNoKFtcIi1cIl0pO1xuICB9XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoaXMgaXMgYSBOSVAtNzAtcHJvdGVjdGVkZSBldmVudC5cbiAgICogQEBzYXRpc2ZpZXMgTklQLTcwXG4gICAqL1xuICBnZXQgaXNQcm90ZWN0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzVGFnKFwiLVwiKTtcbiAgfVxuICAvKipcbiAgICogRmV0Y2ggYW4gZXZlbnQgdGFnZ2VkIHdpdGggdGhlIGdpdmVuIHRhZyBmb2xsb3dpbmcgcmVsYXkgaGludHMgaWYgcHJvdmlkZWQuXG4gICAqIEBwYXJhbSB0YWcgVGhlIHRhZyB0byBzZWFyY2ggZm9yXG4gICAqIEBwYXJhbSBtYXJrZXIgVGhlIG1hcmtlciB0byB1c2UgaW4gdGhlIHRhZyAoZS5nLiBcInJvb3RcIilcbiAgICogQHJldHVybnMgVGhlIGZldGNoZWQgZXZlbnQgb3IgbnVsbCBpZiBubyBldmVudCB3YXMgZm91bmQsIHVuZGVmaW5lZCBpZiBubyBtYXRjaGluZyB0YWcgd2FzIGZvdW5kIGluIHRoZSBldmVudFxuICAgKiAqIEBleGFtcGxlXG4gICAqIGNvbnN0IHJlcGx5RXZlbnQgPSBhd2FpdCBuZGsuZmV0Y2hFdmVudChcIm5ldmVudDFxcXM4eDh2bnljeWhhNzNncnYzODBnbXZsdXJ5NHd0bXgwbnI5YTVkczJkbmdxd2d1ODd3bjZncHplbWh4dWU2OXVoaHlldHZ2OXVqdXVyamQ5a2t6bXB3ZGVqaGdxM3FsMnZ5aDQ3bWsycDBxbHNrdTdoZzB2bjI5ZmFlaHk5aHkzNHlnYWNscG42NnVrcXAzYWZxejRjd2pkXCIpXG4gICAqIGNvbnN0IG9yaWdpbmFsRXZlbnQgPSBhd2FpdCByZXBseUV2ZW50LmZldGNoVGFnZ2VkRXZlbnQoXCJlXCIsIFwicmVwbHlcIik7XG4gICAqIGNvbnNvbGUubG9nKHJlcGx5RXZlbnQuZW5jb2RlKCkgKyBcIiBpcyBhIHJlcGx5IHRvIGV2ZW50IFwiICsgb3JpZ2luYWxFdmVudD8uZW5jb2RlKCkpO1xuICAgKi9cbiAgZmV0Y2hUYWdnZWRFdmVudCA9IGZldGNoVGFnZ2VkRXZlbnQuYmluZCh0aGlzKTtcbiAgLyoqXG4gICAqIEZldGNoIHRoZSByb290IGV2ZW50IG9mIHRoZSBjdXJyZW50IGV2ZW50LlxuICAgKiBAcmV0dXJucyBUaGUgZmV0Y2hlZCByb290IGV2ZW50IG9yIG51bGwgaWYgbm8gZXZlbnQgd2FzIGZvdW5kXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IHJlcGx5RXZlbnQgPSBhd2FpdCBuZGsuZmV0Y2hFdmVudChcIm5ldmVudDFxcXM4eDh2bnljeWhhNzNncnYzODBnbXZsdXJ5NHd0bXgwbnI5YTVkczJkbmdxd2d1ODd3bjZncHplbWh4dWU2OXVoaHlldHZ2OXVqdXVyamQ5a2t6bXB3ZGVqaGdxM3FsMnZ5aDQ3bWsycDBxbHNrdTdoZzB2bjI5ZmFlaHk5aHkzNHlnYWNscG42NnVrcXAzYWZxejRjd2pkXCIpXG4gICAqIGNvbnN0IHJvb3RFdmVudCA9IGF3YWl0IHJlcGx5RXZlbnQuZmV0Y2hSb290RXZlbnQoKTtcbiAgICogY29uc29sZS5sb2cocmVwbHlFdmVudC5lbmNvZGUoKSArIFwiIGlzIGEgcmVwbHkgaW4gdGhlIHRocmVhZCBcIiArIHJvb3RFdmVudD8uZW5jb2RlKCkpO1xuICAgKi9cbiAgZmV0Y2hSb290RXZlbnQgPSBmZXRjaFJvb3RFdmVudC5iaW5kKHRoaXMpO1xuICAvKipcbiAgICogRmV0Y2ggdGhlIGV2ZW50IHRoZSBjdXJyZW50IGV2ZW50IGlzIHJlcGx5aW5nIHRvLlxuICAgKiBAcmV0dXJucyBUaGUgZmV0Y2hlZCByZXBseSBldmVudCBvciBudWxsIGlmIG5vIGV2ZW50IHdhcyBmb3VuZFxuICAgKi9cbiAgZmV0Y2hSZXBseUV2ZW50ID0gZmV0Y2hSZXBseUV2ZW50LmJpbmQodGhpcyk7XG4gIC8qKlxuICAgKiBOSVAtMTggcmVwb3N0aW5nIGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0gcHVibGlzaCBXaGV0aGVyIHRvIHB1Ymxpc2ggdGhlIHJlcG9zdGVkIGV2ZW50IGF1dG9tYXRpY2FsbHkgQGRlZmF1bHQgdHJ1ZVxuICAgKiBAcGFyYW0gc2lnbmVyIFRoZSBzaWduZXIgdG8gdXNlIGZvciBzaWduaW5nIHRoZSByZXBvc3RlZCBldmVudFxuICAgKiBAcmV0dXJucyBUaGUgcmVwb3N0ZWQgZXZlbnRcbiAgICpcbiAgICogQGZ1bmN0aW9uXG4gICAqL1xuICByZXBvc3QgPSByZXBvc3QuYmluZCh0aGlzKTtcbiAgLyoqXG4gICAqIFJlYWN0IHRvIGFuIGV4aXN0aW5nIGV2ZW50XG4gICAqXG4gICAqIEBwYXJhbSBjb250ZW50IFRoZSBjb250ZW50IG9mIHRoZSByZWFjdGlvblxuICAgKi9cbiAgYXN5bmMgcmVhY3QoY29udGVudCwgcHVibGlzaCA9IHRydWUpIHtcbiAgICBpZiAoIXRoaXMubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBOREsgaW5zdGFuY2UgZm91bmRcIik7XG4gICAgdGhpcy5uZGsuYXNzZXJ0U2lnbmVyKCk7XG4gICAgY29uc3QgZSA9IG5ldyBfTkRLRXZlbnQodGhpcy5uZGssIHtcbiAgICAgIGtpbmQ6IDcgLyogUmVhY3Rpb24gKi8sXG4gICAgICBjb250ZW50XG4gICAgfSk7XG4gICAgZS50YWcodGhpcyk7XG4gICAgaWYgKHB1Ymxpc2gpIGF3YWl0IGUucHVibGlzaCgpO1xuICAgIHJldHVybiBlO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZXZlbnQgaXMgdmFsaWQgcGVyIHVuZGVybHlpbmcgTklQcy5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgbWVhbnQgdG8gYmUgb3ZlcnJpZGRlbiBieSBzdWJjbGFzc2VzIHRoYXQgaW1wbGVtZW50IHNwZWNpZmljIE5JUHNcbiAgICogdG8gYWxsb3cgdGhlIGVuZm9yY2VtZW50IG9mIE5JUC1zcGVjaWZpYyB2YWxpZGF0aW9uIHJ1bGVzLlxuICAgKlxuICAgKiBPdGhlcndpc2UsIGl0IHdpbGwgb25seSBjaGVjayBmb3IgYmFzaWMgZXZlbnQgcHJvcGVydGllcy5cbiAgICpcbiAgICovXG4gIGdldCBpc1ZhbGlkKCkge1xuICAgIHJldHVybiB0aGlzLnZhbGlkYXRlKCk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSByZXBseSBldmVudCBmb3IgdGhlIGN1cnJlbnQgZXZlbnQuXG4gICAqIFxuICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgdXNlIE5JUC0yMiB3aGVuIGFwcHJvcHJpYXRlIChpLmUuIHJlcGxpZXMgdG8gbm9uLWtpbmQ6MSBldmVudHMpLlxuICAgKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IGhhdmUgc2lkZS1lZmZlY3RzOyBpdCB3aWxsIGp1c3QgcmV0dXJuIGFuIGV2ZW50IHdpdGggdGhlIGFwcHJvcHJpYXRlIHRhZ3NcbiAgICogdG8gZ2VuZXJhdGUgdGhlIHJlcGx5IGV2ZW50OyB0aGUgY2FsbGVyIGlzIHJlc3BvbnNpYmxlIGZvciBwdWJsaXNoaW5nIHRoZSBldmVudC5cbiAgICovXG4gIHJlcGx5KCkge1xuICAgIGNvbnN0IHJlcGx5ID0gbmV3IF9OREtFdmVudCh0aGlzLm5kayk7XG4gICAgaWYgKHRoaXMua2luZCA9PT0gMSkge1xuICAgICAgcmVwbHkua2luZCA9IDE7XG4gICAgICBjb25zdCBvcEhhc0VUYWcgPSB0aGlzLmhhc1RhZyhcImVcIik7XG4gICAgICBpZiAob3BIYXNFVGFnKSB7XG4gICAgICAgIHJlcGx5LnRhZ3MgPSBbXG4gICAgICAgICAgLi4ucmVwbHkudGFncyxcbiAgICAgICAgICAuLi50aGlzLmdldE1hdGNoaW5nVGFncyhcImVcIiksXG4gICAgICAgICAgLi4udGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJwXCIpLFxuICAgICAgICAgIC4uLnRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwiYVwiKSxcbiAgICAgICAgICAuLi50aGlzLnJlZmVyZW5jZVRhZ3MoXCJyZXBseVwiKVxuICAgICAgICBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVwbHkudGFnKHRoaXMsIFwicm9vdFwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVwbHkua2luZCA9IDExMTEgLyogR2VuZXJpY1JlcGx5ICovO1xuICAgICAgY29uc3QgY2FycnlPdmVyVGFncyA9IFtcIkFcIiwgXCJFXCIsIFwiSVwiLCBcIlBcIl07XG4gICAgICBjb25zdCByb290VGFncyA9IHRoaXMudGFncy5maWx0ZXIoKHRhZykgPT4gY2FycnlPdmVyVGFncy5pbmNsdWRlcyh0YWdbMF0pKTtcbiAgICAgIGlmIChyb290VGFncy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHJvb3RLaW5kID0gdGhpcy50YWdWYWx1ZShcIktcIik7XG4gICAgICAgIHJlcGx5LnRhZ3MucHVzaCguLi5yb290VGFncyk7XG4gICAgICAgIGlmIChyb290S2luZCkgcmVwbHkudGFncy5wdXNoKFtcIktcIiwgcm9vdEtpbmRdKTtcbiAgICAgICAgY29uc3QgW3R5cGUsIGlkLCBfLCAuLi5leHRyYV0gPSB0aGlzLnRhZ1JlZmVyZW5jZSgpO1xuICAgICAgICBjb25zdCB0YWcgPSBbdHlwZSwgaWQsIC4uLmV4dHJhXTtcbiAgICAgICAgcmVwbHkudGFncy5wdXNoKHRhZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBbdHlwZSwgaWQsIF8sIHJlbGF5SGludF0gPSB0aGlzLnRhZ1JlZmVyZW5jZSgpO1xuICAgICAgICBjb25zdCB0YWcgPSBbdHlwZSwgaWQsIHJlbGF5SGludCA/PyBcIlwiXTtcbiAgICAgICAgaWYgKHR5cGUgPT09IFwiZVwiKSB0YWcucHVzaCh0aGlzLnB1YmtleSk7XG4gICAgICAgIHJlcGx5LnRhZ3MucHVzaCh0YWcpO1xuICAgICAgICBjb25zdCB1cHBlcmNhc2VUYWcgPSBbLi4udGFnXTtcbiAgICAgICAgdXBwZXJjYXNlVGFnWzBdID0gdXBwZXJjYXNlVGFnWzBdLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIHJlcGx5LnRhZ3MucHVzaCh1cHBlcmNhc2VUYWcpO1xuICAgICAgICByZXBseS50YWdzLnB1c2goW1wiS1wiLCB0aGlzLmtpbmQudG9TdHJpbmcoKV0pO1xuICAgICAgICByZXBseS50YWdzLnB1c2goW1wiUFwiLCB0aGlzLnB1YmtleV0pO1xuICAgICAgfVxuICAgICAgcmVwbHkudGFncy5wdXNoKFtcImtcIiwgdGhpcy5raW5kLnRvU3RyaW5nKCldKTtcbiAgICAgIHJlcGx5LnRhZ3MucHVzaCguLi50aGlzLmdldE1hdGNoaW5nVGFncyhcInBcIikpO1xuICAgICAgcmVwbHkudGFncy5wdXNoKFtcInBcIiwgdGhpcy5wdWJrZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcGx5O1xuICB9XG59O1xudmFyIHVudHJhY2tlZFVucHVibGlzaGVkRXZlbnRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICAyNDEzMyAvKiBOb3N0ckNvbm5lY3QgKi8sXG4gIDEzMTk0IC8qIE5vc3RyV2FsZXRDb25uZWN0SW5mbyAqLyxcbiAgMjMxOTQgLyogTm9zdHJXYWxsZXRDb25uZWN0UmVxICovLFxuICAyMzE5NSAvKiBOb3N0cldhbGxldENvbm5lY3RSZXMgKi9cbl0pO1xuZnVuY3Rpb24gc2hvdWxkVHJhY2tVbnB1Ymxpc2hlZEV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiAhdW50cmFja2VkVW5wdWJsaXNoZWRFdmVudHMuaGFzKGV2ZW50LmtpbmQpO1xufVxuXG4vLyBzcmMvcmVsYXkvcG9vbC9pbmRleC50c1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIGFzIEV2ZW50RW1pdHRlcjMgfSBmcm9tIFwidHNlZXBcIjtcbnZhciBOREtQb29sID0gY2xhc3MgZXh0ZW5kcyBFdmVudEVtaXR0ZXIzIHtcbiAgLy8gVE9ETzogVGhpcyBzaG91bGQgcHJvYmFibHkgYmUgYW4gTFJVIGNhY2hlXG4gIF9yZWxheXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBzdGF0dXMgPSBcImlkbGVcIjtcbiAgYXV0b0Nvbm5lY3RSZWxheXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBwb29sQmxhY2tsaXN0UmVsYXlVcmxzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgZGVidWc7XG4gIHRlbXBvcmFyeVJlbGF5VGltZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgZmxhcHBpbmdSZWxheXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAvLyBBIG1hcCB0byBzdG9yZSB0aW1lb3V0cyBmb3IgZWFjaCBmbGFwcGluZyByZWxheS5cbiAgYmFja29mZlRpbWVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgbmRrO1xuICBnZXQgYmxhY2tsaXN0UmVsYXlVcmxzKCkge1xuICAgIGNvbnN0IHZhbCA9IG5ldyBTZXQodGhpcy5uZGsuYmxhY2tsaXN0UmVsYXlVcmxzKTtcbiAgICB0aGlzLnBvb2xCbGFja2xpc3RSZWxheVVybHMuZm9yRWFjaCgodXJsKSA9PiB2YWwuYWRkKHVybCkpO1xuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSByZWxheVVybHMgLSBUaGUgVVJMcyBvZiB0aGUgcmVsYXlzIHRvIGNvbm5lY3QgdG8uXG4gICAqIEBwYXJhbSBibGFja2xpc3RlZFJlbGF5VXJscyAtIFVSTHMgdG8gYmxhY2tsaXN0IGZvciB0aGlzIHBvb2wgSU4gQURESVRJT04gdG8gdGhvc2UgYmxhY2tsaXN0ZWQgYXQgdGhlIG5kay1sZXZlbFxuICAgKiBAcGFyYW0gbmRrIC0gVGhlIE5ESyBpbnN0YW5jZS5cbiAgICogQHBhcmFtIG9wdHMgLSBPcHRpb25zIGZvciB0aGUgcG9vbC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHJlbGF5VXJscyA9IFtdLCBibGFja2xpc3RlZFJlbGF5VXJscyA9IFtdLCBuZGssIHsgZGVidWc6IGRlYnVnOCwgbmFtZSB9ID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZGVidWcgPSBkZWJ1ZzggPz8gbmRrLmRlYnVnLmV4dGVuZChcInBvb2xcIik7XG4gICAgaWYgKG5hbWUpIHRoaXMuX25hbWUgPSBuYW1lO1xuICAgIHRoaXMubmRrID0gbmRrO1xuICAgIHRoaXMucmVsYXlVcmxzID0gcmVsYXlVcmxzO1xuICAgIHRoaXMucG9vbEJsYWNrbGlzdFJlbGF5VXJscyA9IG5ldyBTZXQoYmxhY2tsaXN0ZWRSZWxheVVybHMpO1xuICAgIHRoaXMubmRrLnBvb2xzLnB1c2godGhpcyk7XG4gIH1cbiAgZ2V0IHJlbGF5cygpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVsYXlzO1xuICB9XG4gIHNldCByZWxheVVybHModXJscykge1xuICAgIHRoaXMuX3JlbGF5cy5jbGVhcigpO1xuICAgIGZvciAoY29uc3QgcmVsYXlVcmwgb2YgdXJscykge1xuICAgICAgY29uc3QgcmVsYXkgPSBuZXcgTkRLUmVsYXkocmVsYXlVcmwsIHZvaWQgMCwgdGhpcy5uZGspO1xuICAgICAgcmVsYXkuY29ubmVjdGl2aXR5Lm5ldERlYnVnID0gdGhpcy5uZGsubmV0RGVidWc7XG4gICAgICB0aGlzLmFkZFJlbGF5KHJlbGF5KTtcbiAgICB9XG4gIH1cbiAgX25hbWUgPSBcInVubmFtZWRcIjtcbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gIH1cbiAgc2V0IG5hbWUobmFtZSkge1xuICAgIHRoaXMuX25hbWUgPSBuYW1lO1xuICAgIHRoaXMuZGVidWcgPSB0aGlzLmRlYnVnLmV4dGVuZChuYW1lKTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIHJlbGF5IHRvIHRoZSBwb29sLCBhbmQgc2V0cyBhIHRpbWVyIHRvIHJlbW92ZSBpdCBpZiBpdCBpcyBub3QgdXNlZCB3aXRoaW4gdGhlIHNwZWNpZmllZCB0aW1lLlxuICAgKiBAcGFyYW0gcmVsYXkgLSBUaGUgcmVsYXkgdG8gYWRkIHRvIHRoZSBwb29sLlxuICAgKiBAcGFyYW0gcmVtb3ZlSWZVbnVzZWRBZnRlciAtIFRoZSB0aW1lIGluIG1pbGxpc2Vjb25kcyB0byB3YWl0IGJlZm9yZSByZW1vdmluZyB0aGUgcmVsYXkgZnJvbSB0aGUgcG9vbCBhZnRlciBpdCBpcyBubyBsb25nZXIgdXNlZC5cbiAgICovXG4gIHVzZVRlbXBvcmFyeVJlbGF5KHJlbGF5LCByZW1vdmVJZlVudXNlZEFmdGVyID0gM2U0LCBmaWx0ZXJzKSB7XG4gICAgY29uc3QgcmVsYXlBbHJlYWR5SW5Qb29sID0gdGhpcy5yZWxheXMuaGFzKHJlbGF5LnVybCk7XG4gICAgaWYgKCFyZWxheUFscmVhZHlJblBvb2wpIHtcbiAgICAgIHRoaXMuYWRkUmVsYXkocmVsYXkpO1xuICAgICAgdGhpcy5kZWJ1ZyhcIkFkZGluZyB0ZW1wb3JhcnkgcmVsYXkgJXMgZm9yIGZpbHRlcnMgJW9cIiwgcmVsYXkudXJsLCBmaWx0ZXJzKTtcbiAgICB9XG4gICAgY29uc3QgZXhpc3RpbmdUaW1lciA9IHRoaXMudGVtcG9yYXJ5UmVsYXlUaW1lcnMuZ2V0KHJlbGF5LnVybCk7XG4gICAgaWYgKGV4aXN0aW5nVGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dChleGlzdGluZ1RpbWVyKTtcbiAgICB9XG4gICAgaWYgKCFyZWxheUFscmVhZHlJblBvb2wgfHwgZXhpc3RpbmdUaW1lcikge1xuICAgICAgY29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMubmRrLmV4cGxpY2l0UmVsYXlVcmxzPy5pbmNsdWRlcyhyZWxheS51cmwpKSByZXR1cm47XG4gICAgICAgIHRoaXMucmVtb3ZlUmVsYXkocmVsYXkudXJsKTtcbiAgICAgIH0sIHJlbW92ZUlmVW51c2VkQWZ0ZXIpO1xuICAgICAgdGhpcy50ZW1wb3JhcnlSZWxheVRpbWVycy5zZXQocmVsYXkudXJsLCB0aW1lcik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBBZGRzIGEgcmVsYXkgdG8gdGhlIHBvb2wuXG4gICAqXG4gICAqIEBwYXJhbSByZWxheSAtIFRoZSByZWxheSB0byBhZGQgdG8gdGhlIHBvb2wuXG4gICAqIEBwYXJhbSBjb25uZWN0IC0gV2hldGhlciBvciBub3QgdG8gY29ubmVjdCB0byB0aGUgcmVsYXkuXG4gICAqL1xuICBhZGRSZWxheShyZWxheSwgY29ubmVjdCA9IHRydWUpIHtcbiAgICBjb25zdCBpc0FscmVhZHlJblBvb2wgPSB0aGlzLnJlbGF5cy5oYXMocmVsYXkudXJsKTtcbiAgICBjb25zdCBpc0JsYWNrbGlzdGVkID0gdGhpcy5ibGFja2xpc3RSZWxheVVybHM/LmhhcyhyZWxheS51cmwpO1xuICAgIGNvbnN0IGlzQ3VzdG9tUmVsYXlVcmwgPSByZWxheS51cmwuaW5jbHVkZXMoXCIvbnB1YjFcIik7XG4gICAgbGV0IHJlY29ubmVjdCA9IHRydWU7XG4gICAgY29uc3QgcmVsYXlVcmwgPSByZWxheS51cmw7XG4gICAgaWYgKGlzQWxyZWFkeUluUG9vbCkgcmV0dXJuO1xuICAgIGlmIChpc0JsYWNrbGlzdGVkKSB7XG4gICAgICB0aGlzLmRlYnVnKGBSZWZ1c2luZyB0byBhZGQgcmVsYXkgJHtyZWxheVVybH06IGJsYWNrbGlzdGVkYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpc0N1c3RvbVJlbGF5VXJsKSB7XG4gICAgICB0aGlzLmRlYnVnKGBSZWZ1c2luZyB0byBhZGQgcmVsYXkgJHtyZWxheVVybH06IGlzIGEgZmlsdGVyIHJlbGF5YCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLm5kay5jYWNoZUFkYXB0ZXI/LmdldFJlbGF5U3RhdHVzKSB7XG4gICAgICBjb25zdCBpbmZvID0gdGhpcy5uZGsuY2FjaGVBZGFwdGVyLmdldFJlbGF5U3RhdHVzKHJlbGF5VXJsKTtcbiAgICAgIGlmIChpbmZvICYmIGluZm8uZG9udENvbm5lY3RCZWZvcmUpIHtcbiAgICAgICAgaWYgKGluZm8uZG9udENvbm5lY3RCZWZvcmUgPiBEYXRlLm5vdygpKSB7XG4gICAgICAgICAgY29uc3QgZGVsYXkgPSBpbmZvLmRvbnRDb25uZWN0QmVmb3JlIC0gRGF0ZS5ub3coKTtcbiAgICAgICAgICB0aGlzLmRlYnVnKGBSZWZ1c2luZyB0byBhZGQgcmVsYXkgJHtyZWxheVVybH06IGRlbGF5ZWQgY29ubmVjdCBmb3IgJHtkZWxheX1tc2ApO1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hZGRSZWxheShyZWxheSwgY29ubmVjdCk7XG4gICAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWNvbm5lY3QgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBub3RpY2VIYW5kbGVyID0gKG5vdGljZSkgPT4gdGhpcy5lbWl0KFwibm90aWNlXCIsIHJlbGF5LCBub3RpY2UpO1xuICAgIGNvbnN0IGNvbm5lY3RIYW5kbGVyID0gKCkgPT4gdGhpcy5oYW5kbGVSZWxheUNvbm5lY3QocmVsYXlVcmwpO1xuICAgIGNvbnN0IHJlYWR5SGFuZGxlciA9ICgpID0+IHRoaXMuaGFuZGxlUmVsYXlSZWFkeShyZWxheSk7XG4gICAgY29uc3QgZGlzY29ubmVjdEhhbmRsZXIgPSAoKSA9PiB0aGlzLmVtaXQoXCJyZWxheTpkaXNjb25uZWN0XCIsIHJlbGF5KTtcbiAgICBjb25zdCBmbGFwcGluZ0hhbmRsZXIgPSAoKSA9PiB0aGlzLmhhbmRsZUZsYXBwaW5nKHJlbGF5KTtcbiAgICBjb25zdCBhdXRoSGFuZGxlciA9IChjaGFsbGVuZ2UpID0+IHRoaXMuZW1pdChcInJlbGF5OmF1dGhcIiwgcmVsYXksIGNoYWxsZW5nZSk7XG4gICAgY29uc3QgYXV0aGVkSGFuZGxlciA9ICgpID0+IHRoaXMuZW1pdChcInJlbGF5OmF1dGhlZFwiLCByZWxheSk7XG4gICAgcmVsYXkub2ZmKFwibm90aWNlXCIsIG5vdGljZUhhbmRsZXIpO1xuICAgIHJlbGF5Lm9mZihcImNvbm5lY3RcIiwgY29ubmVjdEhhbmRsZXIpO1xuICAgIHJlbGF5Lm9mZihcInJlYWR5XCIsIHJlYWR5SGFuZGxlcik7XG4gICAgcmVsYXkub2ZmKFwiZGlzY29ubmVjdFwiLCBkaXNjb25uZWN0SGFuZGxlcik7XG4gICAgcmVsYXkub2ZmKFwiZmxhcHBpbmdcIiwgZmxhcHBpbmdIYW5kbGVyKTtcbiAgICByZWxheS5vZmYoXCJhdXRoXCIsIGF1dGhIYW5kbGVyKTtcbiAgICByZWxheS5vZmYoXCJhdXRoZWRcIiwgYXV0aGVkSGFuZGxlcik7XG4gICAgcmVsYXkub24oXCJub3RpY2VcIiwgbm90aWNlSGFuZGxlcik7XG4gICAgcmVsYXkub24oXCJjb25uZWN0XCIsIGNvbm5lY3RIYW5kbGVyKTtcbiAgICByZWxheS5vbihcInJlYWR5XCIsIHJlYWR5SGFuZGxlcik7XG4gICAgcmVsYXkub24oXCJkaXNjb25uZWN0XCIsIGRpc2Nvbm5lY3RIYW5kbGVyKTtcbiAgICByZWxheS5vbihcImZsYXBwaW5nXCIsIGZsYXBwaW5nSGFuZGxlcik7XG4gICAgcmVsYXkub24oXCJhdXRoXCIsIGF1dGhIYW5kbGVyKTtcbiAgICByZWxheS5vbihcImF1dGhlZFwiLCBhdXRoZWRIYW5kbGVyKTtcbiAgICByZWxheS5vbihcImRlbGF5ZWQtY29ubmVjdFwiLCAoZGVsYXkpID0+IHtcbiAgICAgIGlmICh0aGlzLm5kay5jYWNoZUFkYXB0ZXI/LnVwZGF0ZVJlbGF5U3RhdHVzKSB7XG4gICAgICAgIHRoaXMubmRrLmNhY2hlQWRhcHRlci51cGRhdGVSZWxheVN0YXR1cyhyZWxheS51cmwsIHtcbiAgICAgICAgICBkb250Q29ubmVjdEJlZm9yZTogRGF0ZS5ub3coKSArIGRlbGF5XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuX3JlbGF5cy5zZXQocmVsYXlVcmwsIHJlbGF5KTtcbiAgICBpZiAoY29ubmVjdCkgdGhpcy5hdXRvQ29ubmVjdFJlbGF5cy5hZGQocmVsYXlVcmwpO1xuICAgIGlmIChjb25uZWN0ICYmIHRoaXMuc3RhdHVzID09PSBcImFjdGl2ZVwiKSB7XG4gICAgICB0aGlzLmVtaXQoXCJyZWxheTpjb25uZWN0aW5nXCIsIHJlbGF5KTtcbiAgICAgIHJlbGF5LmNvbm5lY3Qodm9pZCAwLCByZWNvbm5lY3QpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgIHRoaXMuZGVidWcoYEZhaWxlZCB0byBjb25uZWN0IHRvIHJlbGF5ICR7cmVsYXlVcmx9YCwgZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSByZWxheSBmcm9tIHRoZSBwb29sLlxuICAgKiBAcGFyYW0gcmVsYXlVcmwgLSBUaGUgVVJMIG9mIHRoZSByZWxheSB0byByZW1vdmUuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSByZWxheSB3YXMgcmVtb3ZlZCwgZmFsc2UgaWYgaXQgd2FzIG5vdCBmb3VuZC5cbiAgICovXG4gIHJlbW92ZVJlbGF5KHJlbGF5VXJsKSB7XG4gICAgY29uc3QgcmVsYXkgPSB0aGlzLnJlbGF5cy5nZXQocmVsYXlVcmwpO1xuICAgIGlmIChyZWxheSkge1xuICAgICAgcmVsYXkuZGlzY29ubmVjdCgpO1xuICAgICAgdGhpcy5yZWxheXMuZGVsZXRlKHJlbGF5VXJsKTtcbiAgICAgIHRoaXMuYXV0b0Nvbm5lY3RSZWxheXMuZGVsZXRlKHJlbGF5VXJsKTtcbiAgICAgIHRoaXMuZW1pdChcInJlbGF5OmRpc2Nvbm5lY3RcIiwgcmVsYXkpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGV4aXN0aW5nVGltZXIgPSB0aGlzLnRlbXBvcmFyeVJlbGF5VGltZXJzLmdldChyZWxheVVybCk7XG4gICAgaWYgKGV4aXN0aW5nVGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dChleGlzdGluZ1RpbWVyKTtcbiAgICAgIHRoaXMudGVtcG9yYXJ5UmVsYXlUaW1lcnMuZGVsZXRlKHJlbGF5VXJsKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBhIHJlbGF5IGlzIGFscmVhZHkgY29ubmVjdGVkIGluIHRoZSBwb29sLlxuICAgKi9cbiAgaXNSZWxheUNvbm5lY3RlZCh1cmwpIHtcbiAgICBjb25zdCBub3JtYWxpemVkVXJsID0gbm9ybWFsaXplUmVsYXlVcmwodXJsKTtcbiAgICBjb25zdCByZWxheSA9IHRoaXMucmVsYXlzLmdldChub3JtYWxpemVkVXJsKTtcbiAgICBpZiAoIXJlbGF5KSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHJlbGF5LnN0YXR1cyA9PT0gNSAvKiBDT05ORUNURUQgKi87XG4gIH1cbiAgLyoqXG4gICAqIEZldGNoZXMgYSByZWxheSBmcm9tIHRoZSBwb29sLCBvciBjcmVhdGVzIGEgbmV3IG9uZSBpZiBpdCBkb2VzIG5vdCBleGlzdC5cbiAgICpcbiAgICogTmV3IHJlbGF5cyB3aWxsIGJlIGF0dGVtcHRlZCB0byBiZSBjb25uZWN0ZWQuXG4gICAqL1xuICBnZXRSZWxheSh1cmwsIGNvbm5lY3QgPSB0cnVlLCB0ZW1wb3JhcnkgPSBmYWxzZSwgZmlsdGVycykge1xuICAgIGxldCByZWxheSA9IHRoaXMucmVsYXlzLmdldChub3JtYWxpemVSZWxheVVybCh1cmwpKTtcbiAgICBpZiAoIXJlbGF5KSB7XG4gICAgICByZWxheSA9IG5ldyBOREtSZWxheSh1cmwsIHZvaWQgMCwgdGhpcy5uZGspO1xuICAgICAgcmVsYXkuY29ubmVjdGl2aXR5Lm5ldERlYnVnID0gdGhpcy5uZGsubmV0RGVidWc7XG4gICAgICBpZiAodGVtcG9yYXJ5KSB7XG4gICAgICAgIHRoaXMudXNlVGVtcG9yYXJ5UmVsYXkocmVsYXksIDNlNCwgZmlsdGVycyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFkZFJlbGF5KHJlbGF5LCBjb25uZWN0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlbGF5O1xuICB9XG4gIGhhbmRsZVJlbGF5Q29ubmVjdChyZWxheVVybCkge1xuICAgIGNvbnN0IHJlbGF5ID0gdGhpcy5yZWxheXMuZ2V0KHJlbGF5VXJsKTtcbiAgICBpZiAoIXJlbGF5KSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiTkRLIEJVRzogcmVsYXkgbm90IGZvdW5kIGluIHBvb2xcIiwgeyByZWxheVVybCB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lbWl0KFwicmVsYXk6Y29ubmVjdFwiLCByZWxheSk7XG4gICAgaWYgKHRoaXMuc3RhdHMoKS5jb25uZWN0ZWQgPT09IHRoaXMucmVsYXlzLnNpemUpIHtcbiAgICAgIHRoaXMuZW1pdChcImNvbm5lY3RcIik7XG4gICAgfVxuICB9XG4gIGhhbmRsZVJlbGF5UmVhZHkocmVsYXkpIHtcbiAgICB0aGlzLmVtaXQoXCJyZWxheTpyZWFkeVwiLCByZWxheSk7XG4gIH1cbiAgLyoqXG4gICAqIEF0dGVtcHRzIHRvIGVzdGFibGlzaCBhIGNvbm5lY3Rpb24gdG8gZWFjaCByZWxheSBpbiB0aGUgcG9vbC5cbiAgICpcbiAgICogQGFzeW5jXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbdGltZW91dE1zXSAtIE9wdGlvbmFsIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIGZvciBlYWNoIGNvbm5lY3Rpb24gYXR0ZW1wdC5cbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gYWxsIGNvbm5lY3Rpb24gYXR0ZW1wdHMgaGF2ZSBjb21wbGV0ZWQuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBhbnkgb2YgdGhlIGNvbm5lY3Rpb24gYXR0ZW1wdHMgcmVzdWx0IGluIGFuIGVycm9yIG9yIHRpbWVvdXQuXG4gICAqL1xuICBhc3luYyBjb25uZWN0KHRpbWVvdXRNcykge1xuICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgdGhpcy5zdGF0dXMgPSBcImFjdGl2ZVwiO1xuICAgIHRoaXMuZGVidWcoXG4gICAgICBgQ29ubmVjdGluZyB0byAke3RoaXMucmVsYXlzLnNpemV9IHJlbGF5cyR7dGltZW91dE1zID8gYCwgdGltZW91dCAke3RpbWVvdXRNc30uLi5gIDogXCJcIn1gXG4gICAgKTtcbiAgICBjb25zdCByZWxheXNUb0Nvbm5lY3QgPSBuZXcgU2V0KHRoaXMuYXV0b0Nvbm5lY3RSZWxheXMua2V5cygpKTtcbiAgICBmb3IgKGNvbnN0IHJlbGF5VXJsIG9mIHJlbGF5c1RvQ29ubmVjdCkge1xuICAgICAgY29uc3QgcmVsYXkgPSB0aGlzLnJlbGF5cy5nZXQocmVsYXlVcmwpO1xuICAgICAgaWYgKCFyZWxheSkge1xuICAgICAgICBjb25zb2xlLmxvZyhgUmVsYXkgJHtyZWxheVVybH0gbm90IGZvdW5kIGluIHBvb2wgJHt0aGlzLm5hbWV9YCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgY29ubmVjdFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRoaXMuZW1pdChcInJlbGF5OmNvbm5lY3RpbmdcIiwgcmVsYXkpO1xuICAgICAgICByZXR1cm4gcmVsYXkuY29ubmVjdCh0aW1lb3V0TXMpLnRoZW4ocmVzb2x2ZSkuY2F0Y2gocmVqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHRpbWVvdXRNcykge1xuICAgICAgICBjb25zdCB0aW1lb3V0UHJvbWlzZSA9IG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHJlamVjdChgVGltZWQgb3V0IGFmdGVyICR7dGltZW91dE1zfW1zYCksIHRpbWVvdXRNcyk7XG4gICAgICAgIH0pO1xuICAgICAgICBwcm9taXNlcy5wdXNoKFxuICAgICAgICAgIFByb21pc2UucmFjZShbY29ubmVjdFByb21pc2UsIHRpbWVvdXRQcm9taXNlXSkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGVidWcoXG4gICAgICAgICAgICAgIGBGYWlsZWQgdG8gY29ubmVjdCB0byByZWxheSAke3JlbGF5LnVybH06ICR7ZSA/PyBcIk5vIHJlYXNvbiBzcGVjaWZpZWRcIn1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9taXNlcy5wdXNoKGNvbm5lY3RQcm9taXNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbWF5YmVFbWl0Q29ubmVjdCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGFsbENvbm5lY3RlZCA9IHRoaXMuc3RhdHMoKS5jb25uZWN0ZWQgPT09IHRoaXMucmVsYXlzLnNpemU7XG4gICAgICBjb25zdCBzb21lQ29ubmVjdGVkID0gdGhpcy5zdGF0cygpLmNvbm5lY3RlZCA+IDA7XG4gICAgICBpZiAoIWFsbENvbm5lY3RlZCAmJiBzb21lQ29ubmVjdGVkKSB7XG4gICAgICAgIHRoaXMuZW1pdChcImNvbm5lY3RcIik7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAodGltZW91dE1zKVxuICAgICAgc2V0VGltZW91dChtYXliZUVtaXRDb25uZWN0LCB0aW1lb3V0TXMpO1xuICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICBtYXliZUVtaXRDb25uZWN0KCk7XG4gIH1cbiAgY2hlY2tPbkZsYXBwaW5nUmVsYXlzKCkge1xuICAgIGNvbnN0IGZsYXBwaW5nUmVsYXlzQ291bnQgPSB0aGlzLmZsYXBwaW5nUmVsYXlzLnNpemU7XG4gICAgY29uc3QgdG90YWxSZWxheXMgPSB0aGlzLnJlbGF5cy5zaXplO1xuICAgIGlmIChmbGFwcGluZ1JlbGF5c0NvdW50IC8gdG90YWxSZWxheXMgPj0gMC44KSB7XG4gICAgICBmb3IgKGNvbnN0IHJlbGF5VXJsIG9mIHRoaXMuZmxhcHBpbmdSZWxheXMpIHtcbiAgICAgICAgdGhpcy5iYWNrb2ZmVGltZXMuc2V0KHJlbGF5VXJsLCAwKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaGFuZGxlRmxhcHBpbmcocmVsYXkpIHtcbiAgICB0aGlzLmRlYnVnKGBSZWxheSAke3JlbGF5LnVybH0gaXMgZmxhcHBpbmdgKTtcbiAgICBsZXQgY3VycmVudEJhY2tvZmYgPSB0aGlzLmJhY2tvZmZUaW1lcy5nZXQocmVsYXkudXJsKSB8fCA1ZTM7XG4gICAgY3VycmVudEJhY2tvZmYgPSBjdXJyZW50QmFja29mZiAqIDI7XG4gICAgdGhpcy5iYWNrb2ZmVGltZXMuc2V0KHJlbGF5LnVybCwgY3VycmVudEJhY2tvZmYpO1xuICAgIHRoaXMuZGVidWcoYEJhY2tvZmYgdGltZSBmb3IgJHtyZWxheS51cmx9IGlzICR7Y3VycmVudEJhY2tvZmZ9bXNgKTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuZGVidWcoYEF0dGVtcHRpbmcgdG8gcmVjb25uZWN0IHRvICR7cmVsYXkudXJsfWApO1xuICAgICAgdGhpcy5lbWl0KFwicmVsYXk6Y29ubmVjdGluZ1wiLCByZWxheSk7XG4gICAgICByZWxheS5jb25uZWN0KCk7XG4gICAgICB0aGlzLmNoZWNrT25GbGFwcGluZ1JlbGF5cygpO1xuICAgIH0sIGN1cnJlbnRCYWNrb2ZmKTtcbiAgICByZWxheS5kaXNjb25uZWN0KCk7XG4gICAgdGhpcy5lbWl0KFwiZmxhcHBpbmdcIiwgcmVsYXkpO1xuICB9XG4gIHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVsYXlzLnNpemU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHN0YXR1cyBvZiBlYWNoIHJlbGF5IGluIHRoZSBwb29sLlxuICAgKiBAcmV0dXJucyB7TkRLUG9vbFN0YXRzfSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgbnVtYmVyIG9mIHJlbGF5cyBpbiBlYWNoIHN0YXR1cy5cbiAgICovXG4gIHN0YXRzKCkge1xuICAgIGNvbnN0IHN0YXRzID0ge1xuICAgICAgdG90YWw6IDAsXG4gICAgICBjb25uZWN0ZWQ6IDAsXG4gICAgICBkaXNjb25uZWN0ZWQ6IDAsXG4gICAgICBjb25uZWN0aW5nOiAwXG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IHJlbGF5IG9mIHRoaXMucmVsYXlzLnZhbHVlcygpKSB7XG4gICAgICBzdGF0cy50b3RhbCsrO1xuICAgICAgaWYgKHJlbGF5LnN0YXR1cyA9PT0gNSAvKiBDT05ORUNURUQgKi8pIHtcbiAgICAgICAgc3RhdHMuY29ubmVjdGVkKys7XG4gICAgICB9IGVsc2UgaWYgKHJlbGF5LnN0YXR1cyA9PT0gMSAvKiBESVNDT05ORUNURUQgKi8pIHtcbiAgICAgICAgc3RhdHMuZGlzY29ubmVjdGVkKys7XG4gICAgICB9IGVsc2UgaWYgKHJlbGF5LnN0YXR1cyA9PT0gNCAvKiBDT05ORUNUSU5HICovKSB7XG4gICAgICAgIHN0YXRzLmNvbm5lY3RpbmcrKztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0YXRzO1xuICB9XG4gIGNvbm5lY3RlZFJlbGF5cygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnJlbGF5cy52YWx1ZXMoKSkuZmlsdGVyKFxuICAgICAgKHJlbGF5KSA9PiByZWxheS5zdGF0dXMgPj0gNSAvKiBDT05ORUNURUQgKi9cbiAgICApO1xuICB9XG4gIHBlcm1hbmVudEFuZENvbm5lY3RlZFJlbGF5cygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnJlbGF5cy52YWx1ZXMoKSkuZmlsdGVyKFxuICAgICAgKHJlbGF5KSA9PiByZWxheS5zdGF0dXMgPj0gNSAvKiBDT05ORUNURUQgKi8gJiYgIXRoaXMudGVtcG9yYXJ5UmVsYXlUaW1lcnMuaGFzKHJlbGF5LnVybClcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSBsaXN0IG9mIGFsbCByZWxheSB1cmxzIGluIHRoZSBwb29sLlxuICAgKi9cbiAgdXJscygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnJlbGF5cy5rZXlzKCkpO1xuICB9XG59O1xuXG4vLyBzcmMvdXNlci9pbmRleC50c1xuaW1wb3J0IHsgbmlwMTkgYXMgbmlwMTk1IH0gZnJvbSBcIm5vc3RyLXRvb2xzXCI7XG5cbi8vIHNyYy9zdWJzY3JpcHRpb24vaW5kZXgudHNcbmltcG9ydCB7IEV2ZW50RW1pdHRlciBhcyBFdmVudEVtaXR0ZXI0IH0gZnJvbSBcInRzZWVwXCI7XG5cbi8vIHNyYy9zdWJzY3JpcHRpb24vdXRpbHMudHNcbmltcG9ydCB7IG5pcDE5IGFzIG5pcDE5MyB9IGZyb20gXCJub3N0ci10b29sc1wiO1xudmFyIE1BWF9TVUJJRF9MRU5HVEggPSAyMDtcbmZ1bmN0aW9uIHF1ZXJ5RnVsbHlGaWxsZWQoc3Vic2NyaXB0aW9uKSB7XG4gIGlmIChmaWx0ZXJJbmNsdWRlc0lkcyhzdWJzY3JpcHRpb24uZmlsdGVyKSkge1xuICAgIGlmIChyZXN1bHRIYXNBbGxSZXF1ZXN0ZWRJZHMoc3Vic2NyaXB0aW9uKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVGaWx0ZXIoZmlsdGVyMSwgZmlsdGVyMikge1xuICBpZiAoT2JqZWN0LmtleXMoZmlsdGVyMSkubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhmaWx0ZXIyKS5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoZmlsdGVyMSkpIHtcbiAgICBjb25zdCB2YWx1ZXNJbkZpbHRlcjIgPSBmaWx0ZXIyW2tleV07XG4gICAgaWYgKCF2YWx1ZXNJbkZpbHRlcjIpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZXNJbkZpbHRlcjIpKSB7XG4gICAgICBjb25zdCB2ID0gdmFsdWU7XG4gICAgICBmb3IgKGNvbnN0IHZhbHVlSW5GaWx0ZXIyIG9mIHZhbHVlc0luRmlsdGVyMikge1xuICAgICAgICBjb25zdCB2YWwgPSB2YWx1ZUluRmlsdGVyMjtcbiAgICAgICAgaWYgKCF2LmluY2x1ZGVzKHZhbCkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHZhbHVlc0luRmlsdGVyMiAhPT0gdmFsdWUpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBmaWx0ZXJJbmNsdWRlc0lkcyhmaWx0ZXIpIHtcbiAgcmV0dXJuICEhZmlsdGVyW1wiaWRzXCJdO1xufVxuZnVuY3Rpb24gcmVzdWx0SGFzQWxsUmVxdWVzdGVkSWRzKHN1YnNjcmlwdGlvbikge1xuICBjb25zdCBpZHMgPSBzdWJzY3JpcHRpb24uZmlsdGVyW1wiaWRzXCJdO1xuICByZXR1cm4gISFpZHMgJiYgaWRzLmxlbmd0aCA9PT0gc3Vic2NyaXB0aW9uLmV2ZW50Rmlyc3RTZWVuLnNpemU7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVN1YklkKHN1YnNjcmlwdGlvbnMsIGZpbHRlcnMpIHtcbiAgY29uc3Qgc3ViSWRzID0gc3Vic2NyaXB0aW9ucy5tYXAoKHN1YikgPT4gc3ViLnN1YklkKS5maWx0ZXIoQm9vbGVhbik7XG4gIGNvbnN0IHN1YklkUGFydHMgPSBbXTtcbiAgY29uc3QgZmlsdGVyTm9uS2luZEtleXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBjb25zdCBmaWx0ZXJLaW5kcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGlmIChzdWJJZHMubGVuZ3RoID4gMCkge1xuICAgIHN1YklkUGFydHMucHVzaChBcnJheS5mcm9tKG5ldyBTZXQoc3ViSWRzKSkuam9pbihcIixcIikpO1xuICB9IGVsc2Uge1xuICAgIGZvciAoY29uc3QgZmlsdGVyIG9mIGZpbHRlcnMpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGZpbHRlcikpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gXCJraW5kc1wiKSB7XG4gICAgICAgICAgZmlsdGVyLmtpbmRzPy5mb3JFYWNoKChrKSA9PiBmaWx0ZXJLaW5kcy5hZGQoaykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZpbHRlck5vbktpbmRLZXlzLmFkZChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChmaWx0ZXJLaW5kcy5zaXplID4gMCkge1xuICAgICAgc3ViSWRQYXJ0cy5wdXNoKFwia2luZHM6XCIgKyBBcnJheS5mcm9tKGZpbHRlcktpbmRzKS5qb2luKFwiLFwiKSk7XG4gICAgfVxuICAgIGlmIChmaWx0ZXJOb25LaW5kS2V5cy5zaXplID4gMCkge1xuICAgICAgc3ViSWRQYXJ0cy5wdXNoKEFycmF5LmZyb20oZmlsdGVyTm9uS2luZEtleXMpLmpvaW4oXCIsXCIpKTtcbiAgICB9XG4gIH1cbiAgbGV0IHN1YklkID0gc3ViSWRQYXJ0cy5qb2luKFwiLVwiKTtcbiAgaWYgKHN1YklkLmxlbmd0aCA+IE1BWF9TVUJJRF9MRU5HVEgpIHN1YklkID0gc3ViSWQuc3Vic3RyaW5nKDAsIE1BWF9TVUJJRF9MRU5HVEgpO1xuICBzdWJJZCArPSBcIi1cIiArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDk5OSkudG9TdHJpbmcoKTtcbiAgcmV0dXJuIHN1YklkO1xufVxuZnVuY3Rpb24gZmlsdGVyRm9yRXZlbnRzVGFnZ2luZ0lkKGlkKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgZGVjb2RlZCA9IG5pcDE5My5kZWNvZGUoaWQpO1xuICAgIHN3aXRjaCAoZGVjb2RlZC50eXBlKSB7XG4gICAgICBjYXNlIFwibmFkZHJcIjpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBcIiNhXCI6IFtcbiAgICAgICAgICAgIGAke2RlY29kZWQuZGF0YS5raW5kfToke2RlY29kZWQuZGF0YS5wdWJrZXl9OiR7ZGVjb2RlZC5kYXRhLmlkZW50aWZpZXJ9YFxuICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgIGNhc2UgXCJuZXZlbnRcIjpcbiAgICAgICAgcmV0dXJuIHsgXCIjZVwiOiBbZGVjb2RlZC5kYXRhLmlkXSB9O1xuICAgICAgY2FzZSBcIm5vdGVcIjpcbiAgICAgICAgcmV0dXJuIHsgXCIjZVwiOiBbZGVjb2RlZC5kYXRhXSB9O1xuICAgICAgY2FzZSBcIm5wcm9maWxlXCI6XG4gICAgICAgIHJldHVybiB7IFwiI3BcIjogW2RlY29kZWQuZGF0YS5wdWJrZXldIH07XG4gICAgICBjYXNlIFwibnB1YlwiOlxuICAgICAgICByZXR1cm4geyBcIiNwXCI6IFtkZWNvZGVkLmRhdGFdIH07XG4gICAgfVxuICB9IGNhdGNoIHtcbiAgfVxufVxuZnVuY3Rpb24gZmlsdGVyQW5kUmVsYXlTZXRGcm9tQmVjaDMyKGJlY2hlMiwgbmRrKSB7XG4gIGNvbnN0IGZpbHRlciA9IGZpbHRlckZyb21JZChiZWNoZTIpO1xuICBjb25zdCByZWxheXMgPSByZWxheXNGcm9tQmVjaDMyKGJlY2hlMiwgbmRrKTtcbiAgaWYgKHJlbGF5cy5sZW5ndGggPT09IDApIHJldHVybiB7IGZpbHRlciB9O1xuICByZXR1cm4ge1xuICAgIGZpbHRlcixcbiAgICByZWxheVNldDogbmV3IE5ES1JlbGF5U2V0KG5ldyBTZXQocmVsYXlzKSwgbmRrKVxuICB9O1xufVxuZnVuY3Rpb24gZmlsdGVyRnJvbUlkKGlkKSB7XG4gIGxldCBkZWNvZGVkO1xuICBpZiAoaWQubWF0Y2goTklQMzNfQV9SRUdFWCkpIHtcbiAgICBjb25zdCBba2luZCwgcHVia2V5LCBpZGVudGlmaWVyXSA9IGlkLnNwbGl0KFwiOlwiKTtcbiAgICBjb25zdCBmaWx0ZXIgPSB7XG4gICAgICBhdXRob3JzOiBbcHVia2V5XSxcbiAgICAgIGtpbmRzOiBbcGFyc2VJbnQoa2luZCldXG4gICAgfTtcbiAgICBpZiAoaWRlbnRpZmllcikge1xuICAgICAgZmlsdGVyW1wiI2RcIl0gPSBbaWRlbnRpZmllcl07XG4gICAgfVxuICAgIHJldHVybiBmaWx0ZXI7XG4gIH1cbiAgaWYgKGlkLm1hdGNoKEJFQ0gzMl9SRUdFWCkpIHtcbiAgICB0cnkge1xuICAgICAgZGVjb2RlZCA9IG5pcDE5My5kZWNvZGUoaWQpO1xuICAgICAgc3dpdGNoIChkZWNvZGVkLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcIm5ldmVudFwiOiB7XG4gICAgICAgICAgY29uc3QgZmlsdGVyMiA9IHsgaWRzOiBbZGVjb2RlZC5kYXRhLmlkXSB9O1xuICAgICAgICAgIGlmIChkZWNvZGVkLmRhdGEuYXV0aG9yKSBmaWx0ZXIyLmF1dGhvcnMgPSBbZGVjb2RlZC5kYXRhLmF1dGhvcl07XG4gICAgICAgICAgaWYgKGRlY29kZWQuZGF0YS5raW5kKSBmaWx0ZXIyLmtpbmRzID0gW2RlY29kZWQuZGF0YS5raW5kXTtcbiAgICAgICAgICByZXR1cm4gZmlsdGVyMjtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwibm90ZVwiOlxuICAgICAgICAgIHJldHVybiB7IGlkczogW2RlY29kZWQuZGF0YV0gfTtcbiAgICAgICAgY2FzZSBcIm5hZGRyXCI6XG4gICAgICAgICAgY29uc3QgZmlsdGVyID0ge1xuICAgICAgICAgICAgYXV0aG9yczogW2RlY29kZWQuZGF0YS5wdWJrZXldLFxuICAgICAgICAgICAga2luZHM6IFtkZWNvZGVkLmRhdGEua2luZF1cbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChkZWNvZGVkLmRhdGEuaWRlbnRpZmllcikgZmlsdGVyW1wiI2RcIl0gPSBbZGVjb2RlZC5kYXRhLmlkZW50aWZpZXJdO1xuICAgICAgICAgIHJldHVybiBmaWx0ZXI7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGRlY29kaW5nXCIsIGlkLCBlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgaWRzOiBbaWRdIH07XG59XG5mdW5jdGlvbiBpc05pcDMzQVZhbHVlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5tYXRjaChOSVAzM19BX1JFR0VYKSAhPT0gbnVsbDtcbn1cbnZhciBOSVAzM19BX1JFR0VYID0gL14oXFxkKyk6KFswLTlBLUZhLWZdKykoPzo6KC4qKSk/JC87XG52YXIgQkVDSDMyX1JFR0VYID0gL15uKGV2ZW50fG90ZXxwcm9maWxlfHB1YnxhZGRyKTFbXFxkXFx3XSskLztcbmZ1bmN0aW9uIHJlbGF5c0Zyb21CZWNoMzIoYmVjaDMyMiwgbmRrKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgZGVjb2RlZCA9IG5pcDE5My5kZWNvZGUoYmVjaDMyMik7XG4gICAgaWYgKFtcIm5hZGRyXCIsIFwibmV2ZW50XCJdLmluY2x1ZGVzKGRlY29kZWQ/LnR5cGUpKSB7XG4gICAgICBjb25zdCBkYXRhID0gZGVjb2RlZC5kYXRhO1xuICAgICAgaWYgKGRhdGE/LnJlbGF5cykge1xuICAgICAgICByZXR1cm4gZGF0YS5yZWxheXMubWFwKFxuICAgICAgICAgIChyKSA9PiBuZXcgTkRLUmVsYXkociwgbmRrLnJlbGF5QXV0aERlZmF1bHRQb2xpY3ksIG5kaylcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgfVxuICByZXR1cm4gW107XG59XG5cbi8vIHNyYy9ldmVudHMva2luZHMvYXJ0aWNsZS50c1xudmFyIE5ES0FydGljbGUgPSBjbGFzcyBfTkRLQXJ0aWNsZSBleHRlbmRzIE5ES0V2ZW50IHtcbiAgc3RhdGljIGtpbmQgPSAzMDAyMyAvKiBBcnRpY2xlICovO1xuICBzdGF0aWMga2luZHMgPSBbMzAwMjMgLyogQXJ0aWNsZSAqL107XG4gIGNvbnN0cnVjdG9yKG5kaywgcmF3RXZlbnQpIHtcbiAgICBzdXBlcihuZGssIHJhd0V2ZW50KTtcbiAgICB0aGlzLmtpbmQgPz89IDMwMDIzIC8qIEFydGljbGUgKi87XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBOREtBcnRpY2xlIGZyb20gYW4gZXhpc3RpbmcgTkRLRXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSBldmVudCBOREtFdmVudCB0byBjcmVhdGUgdGhlIE5ES0FydGljbGUgZnJvbS5cbiAgICogQHJldHVybnMgTkRLQXJ0aWNsZVxuICAgKi9cbiAgc3RhdGljIGZyb20oZXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtBcnRpY2xlKGV2ZW50Lm5kaywgZXZlbnQpO1xuICB9XG4gIC8qKlxuICAgKiBHZXR0ZXIgZm9yIHRoZSBhcnRpY2xlIHRpdGxlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nIHwgdW5kZWZpbmVkfSAtIFRoZSBhcnRpY2xlIHRpdGxlIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIHVuZGVmaW5lZC5cbiAgICovXG4gIGdldCB0aXRsZSgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcInRpdGxlXCIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXR0ZXIgZm9yIHRoZSBhcnRpY2xlIHRpdGxlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gdGl0bGUgLSBUaGUgdGl0bGUgdG8gc2V0IGZvciB0aGUgYXJ0aWNsZS5cbiAgICovXG4gIHNldCB0aXRsZSh0aXRsZSkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwidGl0bGVcIik7XG4gICAgaWYgKHRpdGxlKSB0aGlzLnRhZ3MucHVzaChbXCJ0aXRsZVwiLCB0aXRsZV0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXR0ZXIgZm9yIHRoZSBhcnRpY2xlIGltYWdlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nIHwgdW5kZWZpbmVkfSAtIFRoZSBhcnRpY2xlIGltYWdlIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIHVuZGVmaW5lZC5cbiAgICovXG4gIGdldCBpbWFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcImltYWdlXCIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXR0ZXIgZm9yIHRoZSBhcnRpY2xlIGltYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gaW1hZ2UgLSBUaGUgaW1hZ2UgdG8gc2V0IGZvciB0aGUgYXJ0aWNsZS5cbiAgICovXG4gIHNldCBpbWFnZShpbWFnZSkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwiaW1hZ2VcIik7XG4gICAgaWYgKGltYWdlKSB0aGlzLnRhZ3MucHVzaChbXCJpbWFnZVwiLCBpbWFnZV0pO1xuICB9XG4gIGdldCBzdW1tYXJ5KCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwic3VtbWFyeVwiKTtcbiAgfVxuICBzZXQgc3VtbWFyeShzdW1tYXJ5KSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJzdW1tYXJ5XCIpO1xuICAgIGlmIChzdW1tYXJ5KSB0aGlzLnRhZ3MucHVzaChbXCJzdW1tYXJ5XCIsIHN1bW1hcnldKTtcbiAgfVxuICAvKipcbiAgICogR2V0dGVyIGZvciB0aGUgYXJ0aWNsZSdzIHB1YmxpY2F0aW9uIHRpbWVzdGFtcC5cbiAgICpcbiAgICogQHJldHVybnMge251bWJlciB8IHVuZGVmaW5lZH0gLSBUaGUgVW5peCB0aW1lc3RhbXAgb2Ygd2hlbiB0aGUgYXJ0aWNsZSB3YXMgcHVibGlzaGVkIG9yIHVuZGVmaW5lZC5cbiAgICovXG4gIGdldCBwdWJsaXNoZWRfYXQoKSB7XG4gICAgY29uc3QgdGFnID0gdGhpcy50YWdWYWx1ZShcInB1Ymxpc2hlZF9hdFwiKTtcbiAgICBpZiAodGFnKSB7XG4gICAgICBsZXQgdmFsID0gcGFyc2VJbnQodGFnKTtcbiAgICAgIGlmICh2YWwgPiAxZTEyKSB7XG4gICAgICAgIHZhbCA9IE1hdGguZmxvb3IodmFsIC8gMWUzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgLyoqXG4gICAqIFNldHRlciBmb3IgdGhlIGFydGljbGUncyBwdWJsaWNhdGlvbiB0aW1lc3RhbXAuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgdW5kZWZpbmVkfSB0aW1lc3RhbXAgLSBUaGUgVW5peCB0aW1lc3RhbXAgdG8gc2V0IGZvciB0aGUgYXJ0aWNsZSdzIHB1YmxpY2F0aW9uIGRhdGUuXG4gICAqL1xuICBzZXQgcHVibGlzaGVkX2F0KHRpbWVzdGFtcCkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwicHVibGlzaGVkX2F0XCIpO1xuICAgIGlmICh0aW1lc3RhbXAgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wicHVibGlzaGVkX2F0XCIsIHRpbWVzdGFtcC50b1N0cmluZygpXSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgY29udGVudCB0YWdzIGZvciB0aGUgYXJ0aWNsZS5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgZmlyc3QgY2hlY2tzIGFuZCBzZXRzIHRoZSBwdWJsaWNhdGlvbiBkYXRlIGlmIG5vdCBhdmFpbGFibGUsXG4gICAqIGFuZCB0aGVuIGdlbmVyYXRlcyBjb250ZW50IHRhZ3MgYmFzZWQgb24gdGhlIGJhc2UgTkRLRXZlbnQgY2xhc3MuXG4gICAqXG4gICAqIEByZXR1cm5zIHtDb250ZW50VGFnfSAtIFRoZSBnZW5lcmF0ZWQgY29udGVudCB0YWdzLlxuICAgKi9cbiAgYXN5bmMgZ2VuZXJhdGVUYWdzKCkge1xuICAgIHN1cGVyLmdlbmVyYXRlVGFncygpO1xuICAgIGlmICghdGhpcy5wdWJsaXNoZWRfYXQpIHtcbiAgICAgIHRoaXMucHVibGlzaGVkX2F0ID0gdGhpcy5jcmVhdGVkX2F0O1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuZ2VuZXJhdGVUYWdzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHRlciBmb3IgdGhlIGFydGljbGUncyBVUkwuXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmcgfCB1bmRlZmluZWR9IC0gVGhlIGFydGljbGUncyBVUkwgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgdW5kZWZpbmVkLlxuICAgKi9cbiAgZ2V0IHVybCgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcInVybFwiKTtcbiAgfVxuICAvKipcbiAgICogU2V0dGVyIGZvciB0aGUgYXJ0aWNsZSdzIFVSTC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IHVybCAtIFRoZSBVUkwgdG8gc2V0IGZvciB0aGUgYXJ0aWNsZS5cbiAgICovXG4gIHNldCB1cmwodXJsKSB7XG4gICAgaWYgKHVybCkge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1widXJsXCIsIHVybF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbW92ZVRhZyhcInVybFwiKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9ldmVudHMva2luZHMvY2FzaHUvdG9rZW4udHNcbmZ1bmN0aW9uIHByb29mc1RvdGFsQmFsYW5jZShwcm9vZnMpIHtcbiAgcmV0dXJuIHByb29mcy5yZWR1Y2UoKGFjYywgcHJvb2YpID0+IHtcbiAgICBpZiAocHJvb2YuYW1vdW50IDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwicHJvb2YgYW1vdW50IGlzIG5lZ2F0aXZlXCIpO1xuICAgIH1cbiAgICByZXR1cm4gYWNjICsgcHJvb2YuYW1vdW50O1xuICB9LCAwKTtcbn1cbnZhciBOREtDYXNodVRva2VuID0gY2xhc3MgX05ES0Nhc2h1VG9rZW4gZXh0ZW5kcyBOREtFdmVudCB7XG4gIF9wcm9vZnMgPSBbXTtcbiAgX21pbnQ7XG4gIHN0YXRpYyBraW5kID0gNzM3NSAvKiBDYXNodVRva2VuICovO1xuICBzdGF0aWMga2luZHMgPSBbNzM3NSAvKiBDYXNodVRva2VuICovXTtcbiAgLyoqXG4gICAqIFRva2VucyB0aGF0IHRoaXMgdG9rZW4gc3VwZXJzZWVkc1xuICAgKi9cbiAgX2RlbGV0ZXMgPSBbXTtcbiAgb3JpZ2luYWw7XG4gIGNvbnN0cnVjdG9yKG5kaywgZXZlbnQpIHtcbiAgICBzdXBlcihuZGssIGV2ZW50KTtcbiAgICB0aGlzLmtpbmQgPz89IDczNzUgLyogQ2FzaHVUb2tlbiAqLztcbiAgfVxuICBzdGF0aWMgYXN5bmMgZnJvbShldmVudCkge1xuICAgIGNvbnN0IHRva2VuID0gbmV3IF9OREtDYXNodVRva2VuKGV2ZW50Lm5kaywgZXZlbnQpO1xuICAgIHRva2VuLm9yaWdpbmFsID0gZXZlbnQ7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRva2VuLmRlY3J5cHQoKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHRva2VuLmNvbnRlbnQgPSB0b2tlbi5vcmlnaW5hbC5jb250ZW50O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgY29udGVudCA9IEpTT04ucGFyc2UodG9rZW4uY29udGVudCk7XG4gICAgICB0b2tlbi5wcm9vZnMgPSBjb250ZW50LnByb29mcztcbiAgICAgIHRva2VuLm1pbnQgPSBjb250ZW50Lm1pbnQgPz8gdG9rZW4udGFnVmFsdWUoXCJtaW50XCIpO1xuICAgICAgdG9rZW4uZGVsZXRlZFRva2VucyA9IGNvbnRlbnQuZGVsID8/IFtdO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRva2VuLnByb29mcykpIHJldHVybjtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiB0b2tlbjtcbiAgfVxuICBnZXQgcHJvb2ZzKCkge1xuICAgIHJldHVybiB0aGlzLl9wcm9vZnM7XG4gIH1cbiAgc2V0IHByb29mcyhwcm9vZnMpIHtcbiAgICBjb25zdCBjcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgdGhpcy5fcHJvb2ZzID0gcHJvb2ZzLmZpbHRlcigocHJvb2YpID0+IHtcbiAgICAgIGlmIChjcy5oYXMocHJvb2YuQykpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiUGFzc2VkIGluIHByb29mcyBoYWQgZHVwbGljYXRlcywgaWdub3JpbmdcIiwgcHJvb2YuQyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9vZi5hbW91bnQgPCAwKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIkludmFsaWQgcHJvb2Ygd2l0aCBuZWdhdGl2ZSBhbW91bnRcIiwgcHJvb2YpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjcy5hZGQocHJvb2YuQyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KS5tYXAodGhpcy5jbGVhblByb29mKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIG1pbmltYWwgcHJvb2Ygb2JqZWN0IHdpdGggb25seSBlc3NlbnRpYWwgcHJvcGVydGllc1xuICAgKi9cbiAgY2xlYW5Qcm9vZihwcm9vZikge1xuICAgIHJldHVybiB7XG4gICAgICBpZDogcHJvb2YuaWQsXG4gICAgICBhbW91bnQ6IHByb29mLmFtb3VudCxcbiAgICAgIEM6IHByb29mLkMsXG4gICAgICBzZWNyZXQ6IHByb29mLnNlY3JldFxuICAgIH07XG4gIH1cbiAgYXN5bmMgdG9Ob3N0ckV2ZW50KHB1YmtleSkge1xuICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICBwcm9vZnM6IHRoaXMucHJvb2ZzLm1hcCh0aGlzLmNsZWFuUHJvb2YpLFxuICAgICAgbWludDogdGhpcy5taW50LFxuICAgICAgZGVsOiB0aGlzLmRlbGV0ZWRUb2tlbnMgPz8gW11cbiAgICB9O1xuICAgIHRoaXMuY29udGVudCA9IEpTT04uc3RyaW5naWZ5KHBheWxvYWQpO1xuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLm5kay5zaWduZXIudXNlcigpO1xuICAgIGF3YWl0IHRoaXMuZW5jcnlwdCh1c2VyLCB2b2lkIDAsIFwibmlwNDRcIik7XG4gICAgcmV0dXJuIHN1cGVyLnRvTm9zdHJFdmVudChwdWJrZXkpO1xuICB9XG4gIHNldCBtaW50KG1pbnQpIHtcbiAgICB0aGlzLl9taW50ID0gbWludDtcbiAgfVxuICBnZXQgbWludCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWludDtcbiAgfVxuICAvKipcbiAgICogVG9rZW5zIHRoYXQgd2VyZSBkZWxldGVkIGJ5IHRoZSBjcmVhdGlvbiBvZiB0aGlzIHRva2VuLlxuICAgKi9cbiAgZ2V0IGRlbGV0ZWRUb2tlbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlbGV0ZXM7XG4gIH1cbiAgLyoqXG4gICAqIE1hcmtzIHRva2VucyB0aGF0IHdlcmUgZGVsZXRlZCBieSB0aGUgY3JlYXRpb24gb2YgdGhpcyB0b2tlbi5cbiAgICovXG4gIHNldCBkZWxldGVkVG9rZW5zKHRva2VuSWRzKSB7XG4gICAgdGhpcy5fZGVsZXRlcyA9IHRva2VuSWRzO1xuICB9XG4gIGdldCBhbW91bnQoKSB7XG4gICAgcmV0dXJuIHByb29mc1RvdGFsQmFsYW5jZSh0aGlzLnByb29mcyk7XG4gIH1cbiAgYXN5bmMgcHVibGlzaChyZWxheVNldCwgdGltZW91dE1zLCByZXF1aXJlZFJlbGF5Q291bnQpIHtcbiAgICBpZiAodGhpcy5vcmlnaW5hbCkge1xuICAgICAgcmV0dXJuIHRoaXMub3JpZ2luYWwucHVibGlzaChyZWxheVNldCwgdGltZW91dE1zLCByZXF1aXJlZFJlbGF5Q291bnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3VwZXIucHVibGlzaChyZWxheVNldCwgdGltZW91dE1zLCByZXF1aXJlZFJlbGF5Q291bnQpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2V2ZW50cy9raW5kcy9oaWdobGlnaHQudHNcbmltcG9ydCB7IG5pcDE5IGFzIG5pcDE5NCB9IGZyb20gXCJub3N0ci10b29sc1wiO1xudmFyIE5ES0hpZ2hsaWdodCA9IGNsYXNzIF9OREtIaWdobGlnaHQgZXh0ZW5kcyBOREtFdmVudCB7XG4gIF9hcnRpY2xlO1xuICBzdGF0aWMga2luZCA9IDk4MDIgLyogSGlnaGxpZ2h0ICovO1xuICBzdGF0aWMga2luZHMgPSBbOTgwMiAvKiBIaWdobGlnaHQgKi9dO1xuICBjb25zdHJ1Y3RvcihuZGssIHJhd0V2ZW50KSB7XG4gICAgc3VwZXIobmRrLCByYXdFdmVudCk7XG4gICAgdGhpcy5raW5kID8/PSA5ODAyIC8qIEhpZ2hsaWdodCAqLztcbiAgfVxuICBzdGF0aWMgZnJvbShldmVudCkge1xuICAgIHJldHVybiBuZXcgX05ES0hpZ2hsaWdodChldmVudC5uZGssIGV2ZW50KTtcbiAgfVxuICBnZXQgdXJsKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwiclwiKTtcbiAgfVxuICAvKipcbiAgICogQ29udGV4dCB0YWcuXG4gICAqL1xuICBzZXQgY29udGV4dChjb250ZXh0KSB7XG4gICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkge1xuICAgICAgdGhpcy50YWdzID0gdGhpcy50YWdzLmZpbHRlcigoW3RhZywgdmFsdWVdKSA9PiB0YWcgIT09IFwiY29udGV4dFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50YWdzID0gdGhpcy50YWdzLmZpbHRlcigoW3RhZywgdmFsdWVdKSA9PiB0YWcgIT09IFwiY29udGV4dFwiKTtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcImNvbnRleHRcIiwgY29udGV4dF0pO1xuICAgIH1cbiAgfVxuICBnZXQgY29udGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdzLmZpbmQoKFt0YWcsIHZhbHVlXSkgPT4gdGFnID09PSBcImNvbnRleHRcIik/LlsxXSA/PyB2b2lkIDA7XG4gIH1cbiAgLyoqXG4gICAqIFdpbGwgcmV0dXJuIHRoZSBhcnRpY2xlIFVSTCBvciBOREtFdmVudCBpZiB0aGV5IGhhdmUgYWxyZWFkeSBiZWVuXG4gICAqIHNldCAoaXQgd29uJ3QgYXR0ZW1wdCB0byBsb2FkIHJlbW90ZSBldmVudHMpXG4gICAqL1xuICBnZXQgYXJ0aWNsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYXJ0aWNsZTtcbiAgfVxuICAvKipcbiAgICogQXJ0aWNsZSB0aGUgaGlnaGxpZ2h0IGlzIGNvbWluZyBmcm9tLlxuICAgKlxuICAgKiBAcGFyYW0gYXJ0aWNsZSBBcnRpY2xlIFVSTCBvciBOREtFdmVudC5cbiAgICovXG4gIHNldCBhcnRpY2xlKGFydGljbGUpIHtcbiAgICB0aGlzLl9hcnRpY2xlID0gYXJ0aWNsZTtcbiAgICBpZiAodHlwZW9mIGFydGljbGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcInJcIiwgYXJ0aWNsZV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRhZyhhcnRpY2xlKTtcbiAgICB9XG4gIH1cbiAgZ2V0QXJ0aWNsZVRhZygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJhXCIpWzBdIHx8IHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwiZVwiKVswXSB8fCB0aGlzLmdldE1hdGNoaW5nVGFncyhcInJcIilbMF07XG4gIH1cbiAgYXN5bmMgZ2V0QXJ0aWNsZSgpIHtcbiAgICBpZiAodGhpcy5fYXJ0aWNsZSAhPT0gdm9pZCAwKSByZXR1cm4gdGhpcy5fYXJ0aWNsZTtcbiAgICBsZXQgdGFnZ2VkQmVjaDMyO1xuICAgIGNvbnN0IGFydGljbGVUYWcgPSB0aGlzLmdldEFydGljbGVUYWcoKTtcbiAgICBpZiAoIWFydGljbGVUYWcpIHJldHVybiB2b2lkIDA7XG4gICAgc3dpdGNoIChhcnRpY2xlVGFnWzBdKSB7XG4gICAgICBjYXNlIFwiYVwiOlxuICAgICAgICBjb25zdCBba2luZCwgcHVia2V5LCBpZGVudGlmaWVyXSA9IGFydGljbGVUYWdbMV0uc3BsaXQoXCI6XCIpO1xuICAgICAgICB0YWdnZWRCZWNoMzIgPSBuaXAxOTQubmFkZHJFbmNvZGUoeyBraW5kOiBwYXJzZUludChraW5kKSwgcHVia2V5LCBpZGVudGlmaWVyIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJlXCI6XG4gICAgICAgIHRhZ2dlZEJlY2gzMiA9IG5pcDE5NC5ub3RlRW5jb2RlKGFydGljbGVUYWdbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJyXCI6XG4gICAgICAgIHRoaXMuX2FydGljbGUgPSBhcnRpY2xlVGFnWzFdO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKHRhZ2dlZEJlY2gzMikge1xuICAgICAgbGV0IGEgPSBhd2FpdCB0aGlzLm5kaz8uZmV0Y2hFdmVudCh0YWdnZWRCZWNoMzIpO1xuICAgICAgaWYgKGEpIHtcbiAgICAgICAgaWYgKGEua2luZCA9PT0gMzAwMjMgLyogQXJ0aWNsZSAqLykge1xuICAgICAgICAgIGEgPSBOREtBcnRpY2xlLmZyb20oYSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYXJ0aWNsZSA9IGE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9hcnRpY2xlO1xuICB9XG59O1xuXG4vLyBzcmMvdXRpbHMvaW1ldGEudHNcbmZ1bmN0aW9uIG1hcEltZXRhVGFnKHRhZykge1xuICBjb25zdCBkYXRhID0ge307XG4gIGlmICh0YWcubGVuZ3RoID09PSAyKSB7XG4gICAgY29uc3QgcGFydHMgPSB0YWdbMV0uc3BsaXQoXCIgXCIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIGNvbnN0IGtleSA9IHBhcnRzW2ldO1xuICAgICAgY29uc3QgdmFsdWUgPSBwYXJ0c1tpICsgMV07XG4gICAgICBpZiAoa2V5ID09PSBcImZhbGxiYWNrXCIpIHtcbiAgICAgICAgaWYgKCFkYXRhLmZhbGxiYWNrKSBkYXRhLmZhbGxiYWNrID0gW107XG4gICAgICAgIGRhdGEuZmFsbGJhY2sucHVzaCh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCB2YWwgb2YgdGFnKSB7XG4gICAgY29uc3QgcGFydHMgPSB2YWwuc3BsaXQoXCIgXCIpO1xuICAgIGNvbnN0IGtleSA9IHBhcnRzWzBdO1xuICAgIGNvbnN0IHZhbHVlID0gcGFydHMuc2xpY2UoMSkuam9pbihcIiBcIik7XG4gICAgaWYgKGtleSA9PT0gXCJmYWxsYmFja1wiKSB7XG4gICAgICBpZiAoIWRhdGEuZmFsbGJhY2spIGRhdGEuZmFsbGJhY2sgPSBbXTtcbiAgICAgIGRhdGEuZmFsbGJhY2sucHVzaCh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGFba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cbmZ1bmN0aW9uIGltZXRhVGFnVG9UYWcoaW1ldGEpIHtcbiAgY29uc3QgdGFnID0gW1wiaW1ldGFcIl07XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGltZXRhKSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgZm9yIChjb25zdCB2IG9mIHZhbHVlKSB7XG4gICAgICAgIHRhZy5wdXNoKGtleSwgdik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgdGFnLnB1c2goa2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0YWc7XG59XG5cbi8vIHNyYy9ldmVudHMva2luZHMvaW1hZ2UudHNcbnZhciBOREtJbWFnZSA9IGNsYXNzIF9OREtJbWFnZSBleHRlbmRzIE5ES0V2ZW50IHtcbiAgc3RhdGljIGtpbmQgPSAyMCAvKiBJbWFnZSAqLztcbiAgc3RhdGljIGtpbmRzID0gWzIwIC8qIEltYWdlICovXTtcbiAgX2ltZXRhcztcbiAgY29uc3RydWN0b3IobmRrLCByYXdFdmVudCkge1xuICAgIHN1cGVyKG5kaywgcmF3RXZlbnQpO1xuICAgIHRoaXMua2luZCA/Pz0gMjAgLyogSW1hZ2UgKi87XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBOREtJbWFnZSBmcm9tIGFuIGV4aXN0aW5nIE5ES0V2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQgTkRLRXZlbnQgdG8gY3JlYXRlIHRoZSBOREtJbWFnZSBmcm9tLlxuICAgKiBAcmV0dXJucyBOREtJbWFnZVxuICAgKi9cbiAgc3RhdGljIGZyb20oZXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtJbWFnZShldmVudC5uZGssIGV2ZW50LnJhd0V2ZW50KCkpO1xuICB9XG4gIGdldCBpc1ZhbGlkKCkge1xuICAgIHJldHVybiB0aGlzLmltZXRhcy5sZW5ndGggPiAwO1xuICB9XG4gIGdldCBpbWV0YXMoKSB7XG4gICAgaWYgKHRoaXMuX2ltZXRhcykgcmV0dXJuIHRoaXMuX2ltZXRhcztcbiAgICB0aGlzLl9pbWV0YXMgPSB0aGlzLnRhZ3MuZmlsdGVyKCh0YWcpID0+IHRhZ1swXSA9PT0gXCJpbWV0YVwiKS5tYXAobWFwSW1ldGFUYWcpLmZpbHRlcigoaW1ldGEpID0+ICEhaW1ldGEudXJsKTtcbiAgICByZXR1cm4gdGhpcy5faW1ldGFzO1xuICB9XG4gIHNldCBpbWV0YXModGFncykge1xuICAgIHRoaXMuX2ltZXRhcyA9IHRhZ3M7XG4gICAgdGhpcy50YWdzID0gdGhpcy50YWdzLmZpbHRlcigodGFnKSA9PiB0YWdbMF0gIT09IFwiaW1ldGFcIik7XG4gICAgdGhpcy50YWdzLnB1c2goLi4udGFncy5tYXAoaW1ldGFUYWdUb1RhZykpO1xuICB9XG59O1xuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL2xpc3RzL2luZGV4LnRzXG52YXIgTkRLTGlzdCA9IGNsYXNzIF9OREtMaXN0IGV4dGVuZHMgTkRLRXZlbnQge1xuICBfZW5jcnlwdGVkVGFncztcbiAgc3RhdGljIGtpbmRzID0gW1xuICAgIDEwMDYzIC8qIEJsb3Nzb21MaXN0ICovLFxuICAgIDMwMDAxIC8qIENhdGVnb3JpemVkQm9va21hcmtMaXN0ICovLFxuICAgIDEwMDA0IC8qIENvbW11bml0eUxpc3QgKi8sXG4gICAgMTAwNTAgLyogRGlyZWN0TWVzc2FnZVJlY2VpdmVSZWxheUxpc3QgKi8sXG4gICAgMTAwMzAgLyogRW1vamlMaXN0ICovLFxuICAgIDEwMDE1IC8qIEludGVyZXN0TGlzdCAqLyxcbiAgICAxMDAwMSAvKiBQaW5MaXN0ICovLFxuICAgIDEwMDAyIC8qIFJlbGF5TGlzdCAqLyxcbiAgICAxMDAwNyAvKiBTZWFyY2hSZWxheUxpc3QgKi8sXG4gICAgMTAwMDYgLyogQmxvY2tSZWxheUxpc3QgKi8sXG4gICAgMTAwMDMgLyogQm9va21hcmtMaXN0ICovXG4gIF07XG4gIC8qKlxuICAgKiBTdG9yZXMgdGhlIG51bWJlciBvZiBieXRlcyB0aGUgY29udGVudCB3YXMgYmVmb3JlIGRlY3J5cHRpb25cbiAgICogdG8gZXhwaXJlIHRoZSBjYWNoZSB3aGVuIHRoZSBjb250ZW50IGNoYW5nZXMuXG4gICAqL1xuICBlbmNyeXB0ZWRUYWdzTGVuZ3RoO1xuICBjb25zdHJ1Y3RvcihuZGssIHJhd0V2ZW50KSB7XG4gICAgc3VwZXIobmRrLCByYXdFdmVudCk7XG4gICAgdGhpcy5raW5kID8/PSAzMDAwMSAvKiBDYXRlZ29yaXplZEJvb2ttYXJrTGlzdCAqLztcbiAgfVxuICAvKipcbiAgICogV3JhcCBhIE5ES0V2ZW50IGludG8gYSBOREtMaXN0XG4gICAqL1xuICBzdGF0aWMgZnJvbShuZGtFdmVudCkge1xuICAgIHJldHVybiBuZXcgX05ES0xpc3QobmRrRXZlbnQubmRrLCBuZGtFdmVudCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHRpdGxlIG9mIHRoZSBsaXN0LiBGYWxscyBiYWNrIG9uIGZldGNoaW5nIHRoZSBuYW1lIHRhZyB2YWx1ZS5cbiAgICovXG4gIGdldCB0aXRsZSgpIHtcbiAgICBjb25zdCB0aXRsZVRhZyA9IHRoaXMudGFnVmFsdWUoXCJ0aXRsZVwiKSB8fCB0aGlzLnRhZ1ZhbHVlKFwibmFtZVwiKTtcbiAgICBpZiAodGl0bGVUYWcpIHJldHVybiB0aXRsZVRhZztcbiAgICBpZiAodGhpcy5raW5kID09PSAzIC8qIENvbnRhY3RzICovKSB7XG4gICAgICByZXR1cm4gXCJDb250YWN0c1wiO1xuICAgIH0gZWxzZSBpZiAodGhpcy5raW5kID09PSAxZTQgLyogTXV0ZUxpc3QgKi8pIHtcbiAgICAgIHJldHVybiBcIk11dGVcIjtcbiAgICB9IGVsc2UgaWYgKHRoaXMua2luZCA9PT0gMTAwMDEgLyogUGluTGlzdCAqLykge1xuICAgICAgcmV0dXJuIFwiUGlubmVkIE5vdGVzXCI7XG4gICAgfSBlbHNlIGlmICh0aGlzLmtpbmQgPT09IDEwMDAyIC8qIFJlbGF5TGlzdCAqLykge1xuICAgICAgcmV0dXJuIFwiUmVsYXkgTWV0YWRhdGFcIjtcbiAgICB9IGVsc2UgaWYgKHRoaXMua2luZCA9PT0gMTAwMDMgLyogQm9va21hcmtMaXN0ICovKSB7XG4gICAgICByZXR1cm4gXCJCb29rbWFya3NcIjtcbiAgICB9IGVsc2UgaWYgKHRoaXMua2luZCA9PT0gMTAwMDQgLyogQ29tbXVuaXR5TGlzdCAqLykge1xuICAgICAgcmV0dXJuIFwiQ29tbXVuaXRpZXNcIjtcbiAgICB9IGVsc2UgaWYgKHRoaXMua2luZCA9PT0gMTAwMDUgLyogUHVibGljQ2hhdExpc3QgKi8pIHtcbiAgICAgIHJldHVybiBcIlB1YmxpYyBDaGF0c1wiO1xuICAgIH0gZWxzZSBpZiAodGhpcy5raW5kID09PSAxMDAwNiAvKiBCbG9ja1JlbGF5TGlzdCAqLykge1xuICAgICAgcmV0dXJuIFwiQmxvY2tlZCBSZWxheXNcIjtcbiAgICB9IGVsc2UgaWYgKHRoaXMua2luZCA9PT0gMTAwMDcgLyogU2VhcmNoUmVsYXlMaXN0ICovKSB7XG4gICAgICByZXR1cm4gXCJTZWFyY2ggUmVsYXlzXCI7XG4gICAgfSBlbHNlIGlmICh0aGlzLmtpbmQgPT09IDEwMDUwIC8qIERpcmVjdE1lc3NhZ2VSZWNlaXZlUmVsYXlMaXN0ICovKSB7XG4gICAgICByZXR1cm4gXCJEaXJlY3QgTWVzc2FnZSBSZWNlaXZlIFJlbGF5c1wiO1xuICAgIH0gZWxzZSBpZiAodGhpcy5raW5kID09PSAxMDAxNSAvKiBJbnRlcmVzdExpc3QgKi8pIHtcbiAgICAgIHJldHVybiBcIkludGVyZXN0c1wiO1xuICAgIH0gZWxzZSBpZiAodGhpcy5raW5kID09PSAxMDAzMCAvKiBFbW9qaUxpc3QgKi8pIHtcbiAgICAgIHJldHVybiBcIkVtb2ppc1wiO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcImRcIik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSB0aXRsZSBvZiB0aGUgbGlzdC5cbiAgICovXG4gIHNldCB0aXRsZSh0aXRsZSkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFtcInRpdGxlXCIsIFwibmFtZVwiXSk7XG4gICAgaWYgKHRpdGxlKSB0aGlzLnRhZ3MucHVzaChbXCJ0aXRsZVwiLCB0aXRsZV0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBsaXN0LlxuICAgKiBAZGVwcmVjYXRlZCBQbGVhc2UgdXNlIFwidGl0bGVcIiBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMudGl0bGU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG5hbWUgb2YgdGhlIGxpc3QuXG4gICAqIEBkZXByZWNhdGVkIFBsZWFzZSB1c2UgXCJ0aXRsZVwiIGluc3RlYWQuIFRoaXMgbWV0aG9kIHdpbGwgdXNlIHRoZSBgdGl0bGVgIHRhZyBpbnN0ZWFkLlxuICAgKi9cbiAgc2V0IG5hbWUobmFtZSkge1xuICAgIHRoaXMudGl0bGUgPSBuYW1lO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgbGlzdC5cbiAgICovXG4gIGdldCBkZXNjcmlwdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcImRlc2NyaXB0aW9uXCIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgbGlzdC5cbiAgICovXG4gIHNldCBkZXNjcmlwdGlvbihuYW1lKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJkZXNjcmlwdGlvblwiKTtcbiAgICBpZiAobmFtZSkgdGhpcy50YWdzLnB1c2goW1wiZGVzY3JpcHRpb25cIiwgbmFtZV0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbWFnZSBvZiB0aGUgbGlzdC5cbiAgICovXG4gIGdldCBpbWFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcImltYWdlXCIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBpbWFnZSBvZiB0aGUgbGlzdC5cbiAgICovXG4gIHNldCBpbWFnZShuYW1lKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJpbWFnZVwiKTtcbiAgICBpZiAobmFtZSkgdGhpcy50YWdzLnB1c2goW1wiaW1hZ2VcIiwgbmFtZV0pO1xuICB9XG4gIGlzRW5jcnlwdGVkVGFnc0NhY2hlVmFsaWQoKSB7XG4gICAgcmV0dXJuICEhKHRoaXMuX2VuY3J5cHRlZFRhZ3MgJiYgdGhpcy5lbmNyeXB0ZWRUYWdzTGVuZ3RoID09PSB0aGlzLmNvbnRlbnQubGVuZ3RoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGVjcnlwdGVkIGNvbnRlbnQgb2YgdGhlIGxpc3QuXG4gICAqL1xuICBhc3luYyBlbmNyeXB0ZWRUYWdzKHVzZUNhY2hlID0gdHJ1ZSkge1xuICAgIGlmICh1c2VDYWNoZSAmJiB0aGlzLmlzRW5jcnlwdGVkVGFnc0NhY2hlVmFsaWQoKSkgcmV0dXJuIHRoaXMuX2VuY3J5cHRlZFRhZ3M7XG4gICAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTkRLIGluc3RhbmNlIG5vdCBzZXRcIik7XG4gICAgaWYgKCF0aGlzLm5kay5zaWduZXIpIHRocm93IG5ldyBFcnJvcihcIk5ESyBzaWduZXIgbm90IHNldFwiKTtcbiAgICBjb25zdCB1c2VyID0gYXdhaXQgdGhpcy5uZGsuc2lnbmVyLnVzZXIoKTtcbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMuY29udGVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgZGVjcnlwdGVkQ29udGVudCA9IGF3YWl0IHRoaXMubmRrLnNpZ25lci5kZWNyeXB0KHVzZXIsIHRoaXMuY29udGVudCk7XG4gICAgICAgICAgY29uc3QgYSA9IEpTT04ucGFyc2UoZGVjcnlwdGVkQ29udGVudCk7XG4gICAgICAgICAgaWYgKGEgJiYgYVswXSkge1xuICAgICAgICAgICAgdGhpcy5lbmNyeXB0ZWRUYWdzTGVuZ3RoID0gdGhpcy5jb250ZW50Lmxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9lbmNyeXB0ZWRUYWdzID0gYTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5lbmNyeXB0ZWRUYWdzTGVuZ3RoID0gdGhpcy5jb250ZW50Lmxlbmd0aDtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZW5jcnlwdGVkVGFncyA9IFtdO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYGVycm9yIGRlY3J5cHRpbmcgJHt0aGlzLmNvbnRlbnR9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfVxuICAvKipcbiAgICogVGhpcyBtZXRob2QgY2FuIGJlIG92ZXJyaWRlbiB0byB2YWxpZGF0ZSB0aGF0IGEgdGFnIGlzIHZhbGlkIGZvciB0aGlzIGxpc3QuXG4gICAqXG4gICAqIChpLmUuIHRoZSBOREtQZXJzb25MaXN0IGNhbiB2YWxpZGF0ZSB0aGF0IGl0ZW1zIGFyZSBOREtVc2VyIGluc3RhbmNlcylcbiAgICovXG4gIHZhbGlkYXRlVGFnKHRhZ1ZhbHVlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZ2V0SXRlbXModHlwZSkge1xuICAgIHJldHVybiB0aGlzLnRhZ3MuZmlsdGVyKCh0YWcpID0+IHRhZ1swXSA9PT0gdHlwZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHVuZWNyeXB0ZWQgaXRlbXMgaW4gdGhpcyBsaXN0LlxuICAgKi9cbiAgZ2V0IGl0ZW1zKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ3MuZmlsdGVyKCh0KSA9PiB7XG4gICAgICByZXR1cm4gIVtcbiAgICAgICAgXCJkXCIsXG4gICAgICAgIFwiTFwiLFxuICAgICAgICBcImxcIixcbiAgICAgICAgXCJ0aXRsZVwiLFxuICAgICAgICBcIm5hbWVcIixcbiAgICAgICAgXCJkZXNjcmlwdGlvblwiLFxuICAgICAgICBcInB1Ymxpc2hlZF9hdFwiLFxuICAgICAgICBcInN1bW1hcnlcIixcbiAgICAgICAgXCJpbWFnZVwiLFxuICAgICAgICBcInRodW1iXCIsXG4gICAgICAgIFwiYWx0XCIsXG4gICAgICAgIFwiZXhwaXJhdGlvblwiLFxuICAgICAgICBcInN1YmplY3RcIixcbiAgICAgICAgXCJjbGllbnRcIlxuICAgICAgXS5pbmNsdWRlcyh0WzBdKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIG5ldyBpdGVtIHRvIHRoZSBsaXN0LlxuICAgKiBAcGFyYW0gcmVsYXkgUmVsYXkgdG8gYWRkXG4gICAqIEBwYXJhbSBtYXJrIE9wdGlvbmFsIG1hcmsgdG8gYWRkIHRvIHRoZSBpdGVtXG4gICAqIEBwYXJhbSBlbmNyeXB0ZWQgV2hldGhlciB0byBlbmNyeXB0IHRoZSBpdGVtXG4gICAqIEBwYXJhbSBwb3NpdGlvbiBXaGVyZSB0byBhZGQgdGhlIGl0ZW0gaW4gdGhlIGxpc3QgKHRvcCBvciBib3R0b20pXG4gICAqL1xuICBhc3luYyBhZGRJdGVtKGl0ZW0sIG1hcmsgPSB2b2lkIDAsIGVuY3J5cHRlZCA9IGZhbHNlLCBwb3NpdGlvbiA9IFwiYm90dG9tXCIpIHtcbiAgICBpZiAoIXRoaXMubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJOREsgaW5zdGFuY2Ugbm90IHNldFwiKTtcbiAgICBpZiAoIXRoaXMubmRrLnNpZ25lcikgdGhyb3cgbmV3IEVycm9yKFwiTkRLIHNpZ25lciBub3Qgc2V0XCIpO1xuICAgIGxldCB0YWdzO1xuICAgIGlmIChpdGVtIGluc3RhbmNlb2YgTkRLRXZlbnQpIHtcbiAgICAgIHRhZ3MgPSBbaXRlbS50YWdSZWZlcmVuY2UobWFyayldO1xuICAgIH0gZWxzZSBpZiAoaXRlbSBpbnN0YW5jZW9mIE5ES1VzZXIpIHtcbiAgICAgIHRhZ3MgPSBpdGVtLnJlZmVyZW5jZVRhZ3MoKTtcbiAgICB9IGVsc2UgaWYgKGl0ZW0gaW5zdGFuY2VvZiBOREtSZWxheSkge1xuICAgICAgdGFncyA9IGl0ZW0ucmVmZXJlbmNlVGFncygpO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgICAgdGFncyA9IFtpdGVtXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBvYmplY3QgdHlwZVwiKTtcbiAgICB9XG4gICAgaWYgKG1hcmspIHRhZ3NbMF0ucHVzaChtYXJrKTtcbiAgICBpZiAoZW5jcnlwdGVkKSB7XG4gICAgICBjb25zdCB1c2VyID0gYXdhaXQgdGhpcy5uZGsuc2lnbmVyLnVzZXIoKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRMaXN0ID0gYXdhaXQgdGhpcy5lbmNyeXB0ZWRUYWdzKCk7XG4gICAgICBpZiAocG9zaXRpb24gPT09IFwidG9wXCIpIGN1cnJlbnRMaXN0LnVuc2hpZnQoLi4udGFncyk7XG4gICAgICBlbHNlIGN1cnJlbnRMaXN0LnB1c2goLi4udGFncyk7XG4gICAgICB0aGlzLl9lbmNyeXB0ZWRUYWdzID0gY3VycmVudExpc3Q7XG4gICAgICB0aGlzLmVuY3J5cHRlZFRhZ3NMZW5ndGggPSB0aGlzLmNvbnRlbnQubGVuZ3RoO1xuICAgICAgdGhpcy5jb250ZW50ID0gSlNPTi5zdHJpbmdpZnkoY3VycmVudExpc3QpO1xuICAgICAgYXdhaXQgdGhpcy5lbmNyeXB0KHVzZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocG9zaXRpb24gPT09IFwidG9wXCIpIHRoaXMudGFncy51bnNoaWZ0KC4uLnRhZ3MpO1xuICAgICAgZWxzZSB0aGlzLnRhZ3MucHVzaCguLi50YWdzKTtcbiAgICB9XG4gICAgdGhpcy5jcmVhdGVkX2F0ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMWUzKTtcbiAgICB0aGlzLmVtaXQoXCJjaGFuZ2VcIik7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgYW4gaXRlbSBmcm9tIHRoZSBsaXN0IGZyb20gYm90aCB0aGUgZW5jcnlwdGVkIGFuZCB1bmVuY3J5cHRlZCBsaXN0cy5cbiAgICogQHBhcmFtIHZhbHVlIHZhbHVlIG9mIGl0ZW0gdG8gcmVtb3ZlIGZyb20gdGhlIGxpc3RcbiAgICogQHBhcmFtIHB1Ymxpc2ggd2hldGhlciB0byBwdWJsaXNoIHRoZSBjaGFuZ2VcbiAgICogQHJldHVybnNcbiAgICovXG4gIGFzeW5jIHJlbW92ZUl0ZW1CeVZhbHVlKHZhbHVlLCBwdWJsaXNoID0gdHJ1ZSkge1xuICAgIGlmICghdGhpcy5uZGspIHRocm93IG5ldyBFcnJvcihcIk5ESyBpbnN0YW5jZSBub3Qgc2V0XCIpO1xuICAgIGlmICghdGhpcy5uZGsuc2lnbmVyKSB0aHJvdyBuZXcgRXJyb3IoXCJOREsgc2lnbmVyIG5vdCBzZXRcIik7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLnRhZ3MuZmluZEluZGV4KCh0YWcpID0+IHRhZ1sxXSA9PT0gdmFsdWUpO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB0aGlzLnRhZ3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gICAgY29uc3QgdXNlciA9IGF3YWl0IHRoaXMubmRrLnNpZ25lci51c2VyKCk7XG4gICAgY29uc3QgZW5jcnlwdGVkVGFncyA9IGF3YWl0IHRoaXMuZW5jcnlwdGVkVGFncygpO1xuICAgIGNvbnN0IGVuY3J5cHRlZEluZGV4ID0gZW5jcnlwdGVkVGFncy5maW5kSW5kZXgoKHRhZykgPT4gdGFnWzFdID09PSB2YWx1ZSk7XG4gICAgaWYgKGVuY3J5cHRlZEluZGV4ID49IDApIHtcbiAgICAgIGVuY3J5cHRlZFRhZ3Muc3BsaWNlKGVuY3J5cHRlZEluZGV4LCAxKTtcbiAgICAgIHRoaXMuX2VuY3J5cHRlZFRhZ3MgPSBlbmNyeXB0ZWRUYWdzO1xuICAgICAgdGhpcy5lbmNyeXB0ZWRUYWdzTGVuZ3RoID0gdGhpcy5jb250ZW50Lmxlbmd0aDtcbiAgICAgIHRoaXMuY29udGVudCA9IEpTT04uc3RyaW5naWZ5KGVuY3J5cHRlZFRhZ3MpO1xuICAgICAgYXdhaXQgdGhpcy5lbmNyeXB0KHVzZXIpO1xuICAgIH1cbiAgICBpZiAocHVibGlzaCkge1xuICAgICAgcmV0dXJuIHRoaXMucHVibGlzaFJlcGxhY2VhYmxlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY3JlYXRlZF9hdCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDFlMyk7XG4gICAgfVxuICAgIHRoaXMuZW1pdChcImNoYW5nZVwiKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBhbiBpdGVtIGZyb20gdGhlIGxpc3QuXG4gICAqXG4gICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIGl0ZW0gdG8gcmVtb3ZlLlxuICAgKiBAcGFyYW0gZW5jcnlwdGVkIFdoZXRoZXIgdG8gcmVtb3ZlIGZyb20gdGhlIGVuY3J5cHRlZCBsaXN0IG9yIG5vdC5cbiAgICovXG4gIGFzeW5jIHJlbW92ZUl0ZW0oaW5kZXgsIGVuY3J5cHRlZCkge1xuICAgIGlmICghdGhpcy5uZGspIHRocm93IG5ldyBFcnJvcihcIk5ESyBpbnN0YW5jZSBub3Qgc2V0XCIpO1xuICAgIGlmICghdGhpcy5uZGsuc2lnbmVyKSB0aHJvdyBuZXcgRXJyb3IoXCJOREsgc2lnbmVyIG5vdCBzZXRcIik7XG4gICAgaWYgKGVuY3J5cHRlZCkge1xuICAgICAgY29uc3QgdXNlciA9IGF3YWl0IHRoaXMubmRrLnNpZ25lci51c2VyKCk7XG4gICAgICBjb25zdCBjdXJyZW50TGlzdCA9IGF3YWl0IHRoaXMuZW5jcnlwdGVkVGFncygpO1xuICAgICAgY3VycmVudExpc3Quc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIHRoaXMuX2VuY3J5cHRlZFRhZ3MgPSBjdXJyZW50TGlzdDtcbiAgICAgIHRoaXMuZW5jcnlwdGVkVGFnc0xlbmd0aCA9IHRoaXMuY29udGVudC5sZW5ndGg7XG4gICAgICB0aGlzLmNvbnRlbnQgPSBKU09OLnN0cmluZ2lmeShjdXJyZW50TGlzdCk7XG4gICAgICBhd2FpdCB0aGlzLmVuY3J5cHQodXNlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudGFncy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgICB0aGlzLmNyZWF0ZWRfYXQgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxZTMpO1xuICAgIHRoaXMuZW1pdChcImNoYW5nZVwiKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBoYXMoaXRlbSkge1xuICAgIHJldHVybiB0aGlzLml0ZW1zLnNvbWUoKHRhZykgPT4gdGFnWzFdID09PSBpdGVtKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIGZpbHRlciB0aGF0IHdpbGwgcmVzdWx0IGluIGZldGNoaW5nXG4gICAqIHRoZSBpdGVtcyBvZiB0aGlzIGxpc3RcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3QgbGlzdCA9IG5ldyBOREtMaXN0KC4uLik7XG4gICAqIGNvbnN0IGZpbHRlcnMgPSBsaXN0LmZpbHRlckZvckl0ZW1zKCk7XG4gICAqIGNvbnN0IGV2ZW50cyA9IGF3YWl0IG5kay5mZXRjaEV2ZW50cyhmaWx0ZXJzKTtcbiAgICovXG4gIGZpbHRlckZvckl0ZW1zKCkge1xuICAgIGNvbnN0IGlkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgY29uc3QgbmlwMzNRdWVyaWVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBjb25zdCBmaWx0ZXJzID0gW107XG4gICAgZm9yIChjb25zdCB0YWcgb2YgdGhpcy5pdGVtcykge1xuICAgICAgaWYgKHRhZ1swXSA9PT0gXCJlXCIgJiYgdGFnWzFdKSB7XG4gICAgICAgIGlkcy5hZGQodGFnWzFdKTtcbiAgICAgIH0gZWxzZSBpZiAodGFnWzBdID09PSBcImFcIiAmJiB0YWdbMV0pIHtcbiAgICAgICAgY29uc3QgW2tpbmQsIHB1YmtleSwgZFRhZ10gPSB0YWdbMV0uc3BsaXQoXCI6XCIpO1xuICAgICAgICBpZiAoIWtpbmQgfHwgIXB1YmtleSkgY29udGludWU7XG4gICAgICAgIGNvbnN0IGtleSA9IGAke2tpbmR9OiR7cHVia2V5fWA7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBuaXAzM1F1ZXJpZXMuZ2V0KGtleSkgfHwgW107XG4gICAgICAgIGl0ZW0ucHVzaChkVGFnIHx8IFwiXCIpO1xuICAgICAgICBuaXAzM1F1ZXJpZXMuc2V0KGtleSwgaXRlbSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpZHMuc2l6ZSA+IDApIHtcbiAgICAgIGZpbHRlcnMucHVzaCh7IGlkczogQXJyYXkuZnJvbShpZHMpIH0pO1xuICAgIH1cbiAgICBpZiAobmlwMzNRdWVyaWVzLnNpemUgPiAwKSB7XG4gICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlc10gb2YgbmlwMzNRdWVyaWVzLmVudHJpZXMoKSkge1xuICAgICAgICBjb25zdCBba2luZCwgcHVia2V5XSA9IGtleS5zcGxpdChcIjpcIik7XG4gICAgICAgIGZpbHRlcnMucHVzaCh7XG4gICAgICAgICAga2luZHM6IFtwYXJzZUludChraW5kKV0sXG4gICAgICAgICAgYXV0aG9yczogW3B1YmtleV0sXG4gICAgICAgICAgXCIjZFwiOiB2YWx1ZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmaWx0ZXJzO1xuICB9XG59O1xudmFyIGxpc3RzX2RlZmF1bHQgPSBOREtMaXN0O1xuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL251dHphcC9pbmRleC50c1xuaW1wb3J0IGRlYnVnMiBmcm9tIFwiZGVidWdcIjtcbnZhciBOREtOdXR6YXAgPSBjbGFzcyBfTkRLTnV0emFwIGV4dGVuZHMgTkRLRXZlbnQge1xuICBkZWJ1ZztcbiAgX3Byb29mcyA9IFtdO1xuICBzdGF0aWMga2luZCA9IDkzMjEgLyogTnV0emFwICovO1xuICBzdGF0aWMga2luZHMgPSBbX05ES051dHphcC5raW5kXTtcbiAgY29uc3RydWN0b3IobmRrLCBldmVudCkge1xuICAgIHN1cGVyKG5kaywgZXZlbnQpO1xuICAgIHRoaXMua2luZCA/Pz0gOTMyMSAvKiBOdXR6YXAgKi87XG4gICAgdGhpcy5kZWJ1ZyA9IG5kaz8uZGVidWcuZXh0ZW5kKFwibnV0emFwXCIpID8/IGRlYnVnMihcIm5kazpudXR6YXBcIik7XG4gICAgaWYgKCF0aGlzLmFsdCkgdGhpcy5hbHQgPSBcIlRoaXMgaXMgYSBudXR6YXBcIjtcbiAgfVxuICBzdGF0aWMgZnJvbShldmVudCkge1xuICAgIGNvbnN0IGUgPSBuZXcgdGhpcyhldmVudC5uZGssIGV2ZW50KTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcHJvb2ZUYWdzID0gZS5nZXRNYXRjaGluZ1RhZ3MoXCJwcm9vZlwiKTtcbiAgICAgIGlmIChwcm9vZlRhZ3MubGVuZ3RoKSB7XG4gICAgICAgIGUuX3Byb29mcyA9IHByb29mVGFncy5tYXAoKHRhZykgPT4gSlNPTi5wYXJzZSh0YWdbMV0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGUuX3Byb29mcyA9IEpTT04ucGFyc2UoZS5jb250ZW50KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFlLl9wcm9vZnMgfHwgIWUuX3Byb29mcy5sZW5ndGgpIHJldHVybjtcbiAgICByZXR1cm4gZTtcbiAgfVxuICBzZXQgY29tbWVudChjb21tZW50KSB7XG4gICAgdGhpcy5jb250ZW50ID0gY29tbWVudCA/PyBcIlwiO1xuICB9XG4gIGdldCBjb21tZW50KCkge1xuICAgIGNvbnN0IGMgPSB0aGlzLnRhZ1ZhbHVlKFwiY29tbWVudFwiKTtcbiAgICBpZiAoYykgcmV0dXJuIGM7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudDtcbiAgfVxuICBzZXQgcHJvb2ZzKHByb29mcykge1xuICAgIHRoaXMuX3Byb29mcyA9IHByb29mcztcbiAgICB0aGlzLnRhZ3MgPSB0aGlzLnRhZ3MuZmlsdGVyKCh0YWcpID0+IHRhZ1swXSAhPT0gXCJwcm9vZlwiKTtcbiAgICBmb3IgKGNvbnN0IHByb29mIG9mIHByb29mcykge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wicHJvb2ZcIiwgSlNPTi5zdHJpbmdpZnkocHJvb2YpXSk7XG4gICAgfVxuICB9XG4gIGdldCBwcm9vZnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Byb29mcztcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgcDJwayBwdWJrZXkgdGhhdCBpcyBlbWJlZGRlZCBpbiB0aGUgZmlyc3QgcHJvb2ZcbiAgICovXG4gIGdldCBwMnBrKCkge1xuICAgIGNvbnN0IGZpcnN0UHJvb2YgPSB0aGlzLnByb29mc1swXTtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc2VjcmV0ID0gSlNPTi5wYXJzZShmaXJzdFByb29mLnNlY3JldCk7XG4gICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgaWYgKHR5cGVvZiBzZWNyZXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcGF5bG9hZCA9IEpTT04ucGFyc2Uoc2VjcmV0KTtcbiAgICAgICAgdGhpcy5kZWJ1ZyhcInN0cmluZ2lmaWVkIHBheWxvYWRcIiwgZmlyc3RQcm9vZi5zZWNyZXQpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc2VjcmV0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHBheWxvYWQgPSBzZWNyZXQ7XG4gICAgICB9XG4gICAgICBjb25zdCBpc1AyUEtMb2NrZWQgPSBwYXlsb2FkWzBdID09PSBcIlAyUEtcIiAmJiBwYXlsb2FkWzFdPy5kYXRhO1xuICAgICAgaWYgKGlzUDJQS0xvY2tlZCkge1xuICAgICAgICBjb25zdCBwYWRkZWRwMnBrID0gcGF5bG9hZFsxXS5kYXRhO1xuICAgICAgICBjb25zdCBwMnBrID0gcGFkZGVkcDJway5zbGljZSgyKTtcbiAgICAgICAgaWYgKHAycGspIHJldHVybiBwMnBrO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXMuZGVidWcoXCJlcnJvciBwYXJzaW5nIHAycGsgcHVia2V5XCIsIGUsIHRoaXMucHJvb2ZzWzBdKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgbWludCB3aGVyZSB0aGlzIG51dHphcCBwcm9vZnMgZXhpc3RcbiAgICovXG4gIGdldCBtaW50KCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwidVwiKTtcbiAgfVxuICBzZXQgbWludCh2YWx1ZSkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwidVwiKTtcbiAgICB0aGlzLnRhZyhbXCJ1XCIsIHZhbHVlXSk7XG4gIH1cbiAgZ2V0IHVuaXQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJ1bml0XCIpID8/IFwic2F0XCI7XG4gIH1cbiAgc2V0IHVuaXQodmFsdWUpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInVuaXRcIik7XG4gICAgaWYgKHZhbHVlKSB0aGlzLnRhZyhbXCJ1bml0XCIsIHZhbHVlXSk7XG4gIH1cbiAgZ2V0IGFtb3VudCgpIHtcbiAgICBjb25zdCBhbW91bnQgPSB0aGlzLnByb29mcy5yZWR1Y2UoKHRvdGFsLCBwcm9vZikgPT4gdG90YWwgKyBwcm9vZi5hbW91bnQsIDApO1xuICAgIGlmICh0aGlzLnVuaXQgPT09IFwibXNhdFwiKSByZXR1cm4gYW1vdW50ICogMWUzO1xuICAgIHJldHVybiBhbW91bnQ7XG4gIH1cbiAgc2VuZGVyID0gdGhpcy5hdXRob3I7XG4gIC8qKlxuICAgKiBTZXQgdGhlIHRhcmdldCBvZiB0aGUgbnV0emFwXG4gICAqIEBwYXJhbSB0YXJnZXQgVGhlIHRhcmdldCBvZiB0aGUgbnV0emFwIChhIHVzZXIgb3IgYW4gZXZlbnQpXG4gICAqL1xuICBzZXQgdGFyZ2V0KHRhcmdldCkge1xuICAgIHRoaXMudGFncyA9IHRoaXMudGFncy5maWx0ZXIoKHQpID0+IHRbMF0gIT09IFwicFwiKTtcbiAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgTkRLRXZlbnQpIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKHRhcmdldC50YWdSZWZlcmVuY2UoKSk7XG4gICAgfVxuICB9XG4gIHNldCByZWNpcGllbnRQdWJrZXkocHVia2V5KSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJwXCIpO1xuICAgIHRoaXMudGFnKFtcInBcIiwgcHVia2V5XSk7XG4gIH1cbiAgZ2V0IHJlY2lwaWVudFB1YmtleSgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcInBcIik7XG4gIH1cbiAgZ2V0IHJlY2lwaWVudCgpIHtcbiAgICBjb25zdCBwdWJrZXkgPSB0aGlzLnJlY2lwaWVudFB1YmtleTtcbiAgICBpZiAodGhpcy5uZGspIHJldHVybiB0aGlzLm5kay5nZXRVc2VyKHsgcHVia2V5IH0pO1xuICAgIHJldHVybiBuZXcgTkRLVXNlcih7IHB1YmtleSB9KTtcbiAgfVxuICBhc3luYyB0b05vc3RyRXZlbnQoKSB7XG4gICAgaWYgKHRoaXMudW5pdCA9PT0gXCJtc2F0XCIpIHtcbiAgICAgIHRoaXMudW5pdCA9IFwic2F0XCI7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlVGFnKFwiYW1vdW50XCIpO1xuICAgIHRoaXMudGFncy5wdXNoKFtcImFtb3VudFwiLCB0aGlzLmFtb3VudC50b1N0cmluZygpXSk7XG4gICAgY29uc3QgZXZlbnQgPSBhd2FpdCBzdXBlci50b05vc3RyRXZlbnQoKTtcbiAgICBldmVudC5jb250ZW50ID0gdGhpcy5jb21tZW50O1xuICAgIHJldHVybiBldmVudDtcbiAgfVxuICAvKipcbiAgICogVmFsaWRhdGVzIHRoYXQgdGhlIG51dHphcCBjb25mb3JtcyB0byBOSVAtNjFcbiAgICovXG4gIGdldCBpc1ZhbGlkKCkge1xuICAgIGxldCBlVGFnQ291bnQgPSAwO1xuICAgIGxldCBwVGFnQ291bnQgPSAwO1xuICAgIGxldCBtaW50VGFnQ291bnQgPSAwO1xuICAgIGZvciAoY29uc3QgdGFnIG9mIHRoaXMudGFncykge1xuICAgICAgaWYgKHRhZ1swXSA9PT0gXCJlXCIpIGVUYWdDb3VudCsrO1xuICAgICAgaWYgKHRhZ1swXSA9PT0gXCJwXCIpIHBUYWdDb3VudCsrO1xuICAgICAgaWYgKHRhZ1swXSA9PT0gXCJ1XCIpIG1pbnRUYWdDb3VudCsrO1xuICAgIH1cbiAgICByZXR1cm4gKFxuICAgICAgLy8gZXhhY3RseSBvbmUgcmVjaXBpZW50IGFuZCBtaW50XG4gICAgICBwVGFnQ291bnQgPT09IDEgJiYgbWludFRhZ0NvdW50ID09PSAxICYmIC8vIG11c3QgaGF2ZSBhdCBtb3N0IG9uZSBlIHRhZ1xuICAgICAgZVRhZ0NvdW50IDw9IDEgJiYgLy8gbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBwcm9vZlxuICAgICAgdGhpcy5wcm9vZnMubGVuZ3RoID4gMFxuICAgICk7XG4gIH1cbn07XG5mdW5jdGlvbiBwcm9vZlAycGsocHJvb2YpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBzZWNyZXQgPSBKU09OLnBhcnNlKHByb29mLnNlY3JldCk7XG4gICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICBpZiAodHlwZW9mIHNlY3JldCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcGF5bG9hZCA9IEpTT04ucGFyc2Uoc2VjcmV0KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZWNyZXQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHBheWxvYWQgPSBzZWNyZXQ7XG4gICAgfVxuICAgIGNvbnN0IGlzUDJQS0xvY2tlZCA9IHBheWxvYWRbMF0gPT09IFwiUDJQS1wiICYmIHBheWxvYWRbMV0/LmRhdGE7XG4gICAgaWYgKGlzUDJQS0xvY2tlZCkge1xuICAgICAgcmV0dXJuIHBheWxvYWRbMV0uZGF0YTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiZXJyb3IgcGFyc2luZyBwMnBrIHB1YmtleVwiLCBlLCBwcm9vZik7XG4gIH1cbn1cbmZ1bmN0aW9uIHByb29mUDJwa05vc3RyKHByb29mKSB7XG4gIGNvbnN0IHAycGsgPSBwcm9vZlAycGsocHJvb2YpO1xuICBpZiAoIXAycGspIHJldHVybjtcbiAgaWYgKHAycGsuc3RhcnRzV2l0aChcIjAyXCIpICYmIHAycGsubGVuZ3RoID09PSA2NikgcmV0dXJuIHAycGsuc2xpY2UoMik7XG4gIHJldHVybiBwMnBrO1xufVxuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL251dHphcC9taW50LWxpc3QudHNcbnZhciBOREtDYXNodU1pbnRMaXN0ID0gY2xhc3MgX05ES0Nhc2h1TWludExpc3QgZXh0ZW5kcyBOREtFdmVudCB7XG4gIHN0YXRpYyBraW5kID0gMTAwMTkgLyogQ2FzaHVNaW50TGlzdCAqLztcbiAgc3RhdGljIGtpbmRzID0gWzEwMDE5IC8qIENhc2h1TWludExpc3QgKi9dO1xuICBfcDJwaztcbiAgY29uc3RydWN0b3IobmRrLCBldmVudCkge1xuICAgIHN1cGVyKG5kaywgZXZlbnQpO1xuICAgIHRoaXMua2luZCA/Pz0gMTAwMTkgLyogQ2FzaHVNaW50TGlzdCAqLztcbiAgfVxuICBzdGF0aWMgZnJvbShldmVudCkge1xuICAgIHJldHVybiBuZXcgX05ES0Nhc2h1TWludExpc3QoZXZlbnQubmRrLCBldmVudCk7XG4gIH1cbiAgc2V0IHJlbGF5cyh1cmxzKSB7XG4gICAgdGhpcy50YWdzID0gdGhpcy50YWdzLmZpbHRlcigodCkgPT4gdFswXSAhPT0gXCJyZWxheVwiKTtcbiAgICBmb3IgKGNvbnN0IHVybCBvZiB1cmxzKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJyZWxheVwiLCB1cmxdKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHJlbGF5cygpIHtcbiAgICBjb25zdCByID0gW107XG4gICAgZm9yIChjb25zdCB0YWcgb2YgdGhpcy50YWdzKSB7XG4gICAgICBpZiAodGFnWzBdID09PSBcInJlbGF5XCIpIHtcbiAgICAgICAgci5wdXNoKHRhZ1sxXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG4gIHNldCBtaW50cyh1cmxzKSB7XG4gICAgdGhpcy50YWdzID0gdGhpcy50YWdzLmZpbHRlcigodCkgPT4gdFswXSAhPT0gXCJtaW50XCIpO1xuICAgIGZvciAoY29uc3QgdXJsIG9mIHVybHMpIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcIm1pbnRcIiwgdXJsXSk7XG4gICAgfVxuICB9XG4gIGdldCBtaW50cygpIHtcbiAgICBjb25zdCByID0gW107XG4gICAgZm9yIChjb25zdCB0YWcgb2YgdGhpcy50YWdzKSB7XG4gICAgICBpZiAodGFnWzBdID09PSBcIm1pbnRcIikge1xuICAgICAgICByLnB1c2godGFnWzFdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEFycmF5LmZyb20obmV3IFNldChyKSk7XG4gIH1cbiAgZ2V0IHAycGsoKSB7XG4gICAgaWYgKHRoaXMuX3AycGspIHtcbiAgICAgIHJldHVybiB0aGlzLl9wMnBrO1xuICAgIH1cbiAgICB0aGlzLl9wMnBrID0gdGhpcy50YWdWYWx1ZShcInB1YmtleVwiKSA/PyB0aGlzLnB1YmtleTtcbiAgICByZXR1cm4gdGhpcy5fcDJwaztcbiAgfVxuICBzZXQgcDJwayhwdWJrZXkpIHtcbiAgICB0aGlzLl9wMnBrID0gcHVia2V5O1xuICAgIHRoaXMucmVtb3ZlVGFnKFwicHVia2V5XCIpO1xuICAgIGlmIChwdWJrZXkpIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcInB1YmtleVwiLCBwdWJrZXldKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHJlbGF5U2V0KCkge1xuICAgIHJldHVybiBOREtSZWxheVNldC5mcm9tUmVsYXlVcmxzKHRoaXMucmVsYXlzLCB0aGlzLm5kayk7XG4gIH1cbn07XG5cbi8vIHNyYy9ldmVudHMva2luZHMvc2ltcGxlLWdyb3VwL21lbWJlci1saXN0LnRzXG52YXIgTkRLU2ltcGxlR3JvdXBNZW1iZXJMaXN0ID0gY2xhc3MgX05ES1NpbXBsZUdyb3VwTWVtYmVyTGlzdCBleHRlbmRzIE5ES0V2ZW50IHtcbiAgcmVsYXlTZXQ7XG4gIG1lbWJlclNldCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIHN0YXRpYyBraW5kID0gMzkwMDIgLyogR3JvdXBNZW1iZXJzICovO1xuICBzdGF0aWMga2luZHMgPSBbMzkwMDIgLyogR3JvdXBNZW1iZXJzICovXTtcbiAgY29uc3RydWN0b3IobmRrLCByYXdFdmVudCkge1xuICAgIHN1cGVyKG5kaywgcmF3RXZlbnQpO1xuICAgIHRoaXMua2luZCA/Pz0gMzkwMDIgLyogR3JvdXBNZW1iZXJzICovO1xuICAgIHRoaXMubWVtYmVyU2V0ID0gbmV3IFNldCh0aGlzLm1lbWJlcnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tKGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLU2ltcGxlR3JvdXBNZW1iZXJMaXN0KGV2ZW50Lm5kaywgZXZlbnQpO1xuICB9XG4gIGdldCBtZW1iZXJzKCkge1xuICAgIHJldHVybiB0aGlzLmdldE1hdGNoaW5nVGFncyhcInBcIikubWFwKCh0YWcpID0+IHRhZ1sxXSk7XG4gIH1cbiAgaGFzTWVtYmVyKG1lbWJlcikge1xuICAgIHJldHVybiB0aGlzLm1lbWJlclNldC5oYXMobWVtYmVyKTtcbiAgfVxuICBhc3luYyBwdWJsaXNoKHJlbGF5U2V0LCB0aW1lb3V0TXMsIHJlcXVpcmVkUmVsYXlDb3VudCkge1xuICAgIHJlbGF5U2V0ID8/PSB0aGlzLnJlbGF5U2V0O1xuICAgIHJldHVybiBzdXBlci5wdWJsaXNoUmVwbGFjZWFibGUocmVsYXlTZXQsIHRpbWVvdXRNcywgcmVxdWlyZWRSZWxheUNvdW50KTtcbiAgfVxufTtcblxuLy8gc3JjL2V2ZW50cy9raW5kcy9zaW1wbGUtZ3JvdXAvbWV0YWRhdGEudHNcbnZhciBOREtTaW1wbGVHcm91cE1ldGFkYXRhID0gY2xhc3MgX05ES1NpbXBsZUdyb3VwTWV0YWRhdGEgZXh0ZW5kcyBOREtFdmVudCB7XG4gIHN0YXRpYyBraW5kID0gMzllMyAvKiBHcm91cE1ldGFkYXRhICovO1xuICBzdGF0aWMga2luZHMgPSBbMzllMyAvKiBHcm91cE1ldGFkYXRhICovXTtcbiAgY29uc3RydWN0b3IobmRrLCByYXdFdmVudCkge1xuICAgIHN1cGVyKG5kaywgcmF3RXZlbnQpO1xuICAgIHRoaXMua2luZCA/Pz0gMzllMyAvKiBHcm91cE1ldGFkYXRhICovO1xuICB9XG4gIHN0YXRpYyBmcm9tKGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLU2ltcGxlR3JvdXBNZXRhZGF0YShldmVudC5uZGssIGV2ZW50KTtcbiAgfVxuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcIm5hbWVcIik7XG4gIH1cbiAgZ2V0IHBpY3R1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJwaWN0dXJlXCIpO1xuICB9XG4gIGdldCBhYm91dCgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcImFib3V0XCIpO1xuICB9XG4gIGdldCBzY29wZSgpIHtcbiAgICBpZiAodGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJwdWJsaWNcIikubGVuZ3RoID4gMCkgcmV0dXJuIFwicHVibGljXCI7XG4gICAgaWYgKHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwicHVibGljXCIpLmxlbmd0aCA+IDApIHJldHVybiBcInByaXZhdGVcIjtcbiAgfVxuICBzZXQgc2NvcGUoc2NvcGUpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInB1YmxpY1wiKTtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInByaXZhdGVcIik7XG4gICAgaWYgKHNjb3BlID09PSBcInB1YmxpY1wiKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJwdWJsaWNcIiwgXCJcIl0pO1xuICAgIH0gZWxzZSBpZiAoc2NvcGUgPT09IFwicHJpdmF0ZVwiKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJwcml2YXRlXCIsIFwiXCJdKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGFjY2VzcygpIHtcbiAgICBpZiAodGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJvcGVuXCIpLmxlbmd0aCA+IDApIHJldHVybiBcIm9wZW5cIjtcbiAgICBpZiAodGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJjbG9zZWRcIikubGVuZ3RoID4gMCkgcmV0dXJuIFwiY2xvc2VkXCI7XG4gIH1cbiAgc2V0IGFjY2VzcyhhY2Nlc3MpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcIm9wZW5cIik7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJjbG9zZWRcIik7XG4gICAgaWYgKGFjY2VzcyA9PT0gXCJvcGVuXCIpIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcIm9wZW5cIiwgXCJcIl0pO1xuICAgIH0gZWxzZSBpZiAoYWNjZXNzID09PSBcImNsb3NlZFwiKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJjbG9zZWRcIiwgXCJcIl0pO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2V2ZW50cy9raW5kcy9zdWJzY3JpcHRpb25zL2Ftb3VudC50c1xudmFyIHBvc3NpYmxlSW50ZXJ2YWxGcmVxdWVuY2llcyA9IFtcbiAgXCJkYWlseVwiLFxuICBcIndlZWtseVwiLFxuICBcIm1vbnRobHlcIixcbiAgXCJxdWFydGVybHlcIixcbiAgXCJ5ZWFybHlcIlxuXTtcbmZ1bmN0aW9uIGNhbGN1bGF0ZVRlcm1EdXJhdGlvbkluU2Vjb25kcyh0ZXJtKSB7XG4gIHN3aXRjaCAodGVybSkge1xuICAgIGNhc2UgXCJkYWlseVwiOlxuICAgICAgcmV0dXJuIDI0ICogNjAgKiA2MDtcbiAgICBjYXNlIFwid2Vla2x5XCI6XG4gICAgICByZXR1cm4gNyAqIDI0ICogNjAgKiA2MDtcbiAgICBjYXNlIFwibW9udGhseVwiOlxuICAgICAgcmV0dXJuIDMwICogMjQgKiA2MCAqIDYwO1xuICAgIGNhc2UgXCJxdWFydGVybHlcIjpcbiAgICAgIHJldHVybiAzICogMzAgKiAyNCAqIDYwICogNjA7XG4gICAgY2FzZSBcInllYXJseVwiOlxuICAgICAgcmV0dXJuIDM2NSAqIDI0ICogNjAgKiA2MDtcbiAgfVxufVxuZnVuY3Rpb24gbmV3QW1vdW50KGFtb3VudCwgY3VycmVuY3ksIHRlcm0pIHtcbiAgcmV0dXJuIFtcImFtb3VudFwiLCBhbW91bnQudG9TdHJpbmcoKSwgY3VycmVuY3ksIHRlcm1dO1xufVxuZnVuY3Rpb24gcGFyc2VUYWdUb1N1YnNjcmlwdGlvbkFtb3VudCh0YWcpIHtcbiAgY29uc3QgYW1vdW50ID0gcGFyc2VJbnQodGFnWzFdKTtcbiAgaWYgKGlzTmFOKGFtb3VudCkgfHwgYW1vdW50ID09PSB2b2lkIDAgfHwgYW1vdW50ID09PSBudWxsIHx8IGFtb3VudCA8PSAwKSByZXR1cm4gdm9pZCAwO1xuICBjb25zdCBjdXJyZW5jeSA9IHRhZ1syXTtcbiAgaWYgKGN1cnJlbmN5ID09PSB2b2lkIDAgfHwgY3VycmVuY3kgPT09IFwiXCIpIHJldHVybiB2b2lkIDA7XG4gIGNvbnN0IHRlcm0gPSB0YWdbM107XG4gIGlmICh0ZXJtID09PSB2b2lkIDApIHJldHVybiB2b2lkIDA7XG4gIGlmICghcG9zc2libGVJbnRlcnZhbEZyZXF1ZW5jaWVzLmluY2x1ZGVzKHRlcm0pKSByZXR1cm4gdm9pZCAwO1xuICByZXR1cm4ge1xuICAgIGFtb3VudCxcbiAgICBjdXJyZW5jeSxcbiAgICB0ZXJtXG4gIH07XG59XG5cbi8vIHNyYy9ldmVudHMva2luZHMvc3Vic2NyaXB0aW9ucy90aWVyLnRzXG52YXIgTkRLU3Vic2NyaXB0aW9uVGllciA9IGNsYXNzIF9OREtTdWJzY3JpcHRpb25UaWVyIGV4dGVuZHMgTkRLQXJ0aWNsZSB7XG4gIHN0YXRpYyBraW5kID0gMzcwMDEgLyogU3Vic2NyaXB0aW9uVGllciAqLztcbiAgc3RhdGljIGtpbmRzID0gWzM3MDAxIC8qIFN1YnNjcmlwdGlvblRpZXIgKi9dO1xuICBjb25zdHJ1Y3RvcihuZGssIHJhd0V2ZW50KSB7XG4gICAgY29uc3QgayA9IHJhd0V2ZW50Py5raW5kID8/IDM3MDAxIC8qIFN1YnNjcmlwdGlvblRpZXIgKi87XG4gICAgc3VwZXIobmRrLCByYXdFdmVudCk7XG4gICAgdGhpcy5raW5kID0gaztcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBOREtTdWJzY3JpcHRpb25UaWVyIGZyb20gYW4gZXZlbnRcbiAgICogQHBhcmFtIGV2ZW50XG4gICAqIEByZXR1cm5zIE5ES1N1YnNjcmlwdGlvblRpZXJcbiAgICovXG4gIHN0YXRpYyBmcm9tKGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLU3Vic2NyaXB0aW9uVGllcihldmVudC5uZGssIGV2ZW50KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBwZXJrcyBmb3IgdGhpcyB0aWVyXG4gICAqL1xuICBnZXQgcGVya3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwicGVya1wiKS5tYXAoKHRhZykgPT4gdGFnWzFdKS5maWx0ZXIoKHBlcmspID0+IHBlcmsgIT09IHZvaWQgMCk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYSBwZXJrIHRvIHRoaXMgdGllclxuICAgKi9cbiAgYWRkUGVyayhwZXJrKSB7XG4gICAgdGhpcy50YWdzLnB1c2goW1wicGVya1wiLCBwZXJrXSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFtb3VudCBmb3IgdGhpcyB0aWVyXG4gICAqL1xuICBnZXQgYW1vdW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJhbW91bnRcIikubWFwKCh0YWcpID0+IHBhcnNlVGFnVG9TdWJzY3JpcHRpb25BbW91bnQodGFnKSkuZmlsdGVyKChhKSA9PiBhICE9PSB2b2lkIDApO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGFuIGFtb3VudCB0byB0aGlzIHRpZXJcbiAgICogQHBhcmFtIGFtb3VudCBBbW91bnQgaW4gdGhlIHNtYWxsZXN0IHVuaXQgb2YgdGhlIGN1cnJlbmN5IChlLmcuIGNlbnRzLCBtc2F0cylcbiAgICogQHBhcmFtIGN1cnJlbmN5IEN1cnJlbmN5IGNvZGUuIFVzZSBtc2F0IGZvciBtaWxsaXNhdG9zaGlzXG4gICAqIEBwYXJhbSB0ZXJtIE9uZSBvZiBkYWlseSwgd2Vla2x5LCBtb250aGx5LCBxdWFydGVybHksIHllYXJseVxuICAgKi9cbiAgYWRkQW1vdW50KGFtb3VudCwgY3VycmVuY3ksIHRlcm0pIHtcbiAgICB0aGlzLnRhZ3MucHVzaChuZXdBbW91bnQoYW1vdW50LCBjdXJyZW5jeSwgdGVybSkpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIGEgcmVsYXkgd2hlcmUgY29udGVudCByZWxhdGVkIHRvIHRoaXMgdGllciBjYW4gYmUgZm91bmRcbiAgICogQHBhcmFtIHJlbGF5VXJsIFVSTCBvZiB0aGUgcmVsYXlcbiAgICovXG4gIHNldCByZWxheVVybChyZWxheVVybCkge1xuICAgIHRoaXMudGFncy5wdXNoKFtcInJcIiwgcmVsYXlVcmxdKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVsYXkgVVJMcyBmb3IgdGhpcyB0aWVyXG4gICAqL1xuICBnZXQgcmVsYXlVcmxzKCkge1xuICAgIHJldHVybiB0aGlzLmdldE1hdGNoaW5nVGFncyhcInJcIikubWFwKCh0YWcpID0+IHRhZ1sxXSkuZmlsdGVyKChyZWxheSkgPT4gcmVsYXkgIT09IHZvaWQgMCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIHZlcmlmaWVyIHB1YmtleSBmb3IgdGhpcyB0aWVyLiBUaGlzIGlzIHRoZSBwdWJrZXkgdGhhdCB3aWxsIGdlbmVyYXRlXG4gICAqIHN1YnNjcmlwdGlvbiBwYXltZW50IHJlY2VpcHRzXG4gICAqL1xuICBnZXQgdmVyaWZpZXJQdWJrZXkoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJwXCIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSB2ZXJpZmllciBwdWJrZXkgZm9yIHRoaXMgdGllci5cbiAgICovXG4gIHNldCB2ZXJpZmllclB1YmtleShwdWJrZXkpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInBcIik7XG4gICAgaWYgKHB1YmtleSkgdGhpcy50YWdzLnB1c2goW1wicFwiLCBwdWJrZXldKTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoaXMgdGllciBpcyB2YWxpZFxuICAgKi9cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGl0bGUgIT09IHZvaWQgMCAmJiAvLyBNdXN0IGhhdmUgYSB0aXRsZVxuICAgIHRoaXMuYW1vdW50cy5sZW5ndGggPiAwO1xuICB9XG59O1xuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL3ZpZGVvLnRzXG52YXIgTkRLVmlkZW8gPSBjbGFzcyBfTkRLVmlkZW8gZXh0ZW5kcyBOREtFdmVudCB7XG4gIHN0YXRpYyBraW5kID0gMzQyMzUgLyogSG9yaXpvbnRhbFZpZGVvICovO1xuICBzdGF0aWMga2luZHMgPSBbMzQyMzUgLyogSG9yaXpvbnRhbFZpZGVvICovLCAzNDIzNiAvKiBWZXJ0aWNhbFZpZGVvICovXTtcbiAgX2ltZXRhcztcbiAgY29uc3RydWN0b3IobmRrLCByYXdFdmVudCkge1xuICAgIHN1cGVyKG5kaywgcmF3RXZlbnQpO1xuICAgIHRoaXMua2luZCA/Pz0gMzQyMzUgLyogSG9yaXpvbnRhbFZpZGVvICovO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgTkRLQXJ0aWNsZSBmcm9tIGFuIGV4aXN0aW5nIE5ES0V2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQgTkRLRXZlbnQgdG8gY3JlYXRlIHRoZSBOREtBcnRpY2xlIGZyb20uXG4gICAqIEByZXR1cm5zIE5ES0FydGljbGVcbiAgICovXG4gIHN0YXRpYyBmcm9tKGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLVmlkZW8oZXZlbnQubmRrLCBldmVudC5yYXdFdmVudCgpKTtcbiAgfVxuICAvKipcbiAgICogR2V0dGVyIGZvciB0aGUgYXJ0aWNsZSB0aXRsZS5cbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZyB8IHVuZGVmaW5lZH0gLSBUaGUgYXJ0aWNsZSB0aXRsZSBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSB1bmRlZmluZWQuXG4gICAqL1xuICBnZXQgdGl0bGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJ0aXRsZVwiKTtcbiAgfVxuICAvKipcbiAgICogU2V0dGVyIGZvciB0aGUgYXJ0aWNsZSB0aXRsZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IHRpdGxlIC0gVGhlIHRpdGxlIHRvIHNldCBmb3IgdGhlIGFydGljbGUuXG4gICAqL1xuICBzZXQgdGl0bGUodGl0bGUpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInRpdGxlXCIpO1xuICAgIGlmICh0aXRsZSkgdGhpcy50YWdzLnB1c2goW1widGl0bGVcIiwgdGl0bGVdKTtcbiAgfVxuICAvKipcbiAgICogR2V0dGVyIGZvciB0aGUgYXJ0aWNsZSB0aHVtYm5haWwuXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmcgfCB1bmRlZmluZWR9IC0gVGhlIGFydGljbGUgdGh1bWJuYWlsIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIHVuZGVmaW5lZC5cbiAgICovXG4gIGdldCB0aHVtYm5haWwoKSB7XG4gICAgbGV0IHRodW1ibmFpbDtcbiAgICBpZiAodGhpcy5pbWV0YXMgJiYgdGhpcy5pbWV0YXMubGVuZ3RoID4gMCkge1xuICAgICAgdGh1bWJuYWlsID0gdGhpcy5pbWV0YXNbMF0uaW1hZ2U/LlswXTtcbiAgICB9XG4gICAgcmV0dXJuIHRodW1ibmFpbCA/PyB0aGlzLnRhZ1ZhbHVlKFwidGh1bWJcIik7XG4gIH1cbiAgZ2V0IGltZXRhcygpIHtcbiAgICBpZiAodGhpcy5faW1ldGFzKSByZXR1cm4gdGhpcy5faW1ldGFzO1xuICAgIHRoaXMuX2ltZXRhcyA9IHRoaXMudGFncy5maWx0ZXIoKHRhZykgPT4gdGFnWzBdID09PSBcImltZXRhXCIpLm1hcChtYXBJbWV0YVRhZyk7XG4gICAgcmV0dXJuIHRoaXMuX2ltZXRhcztcbiAgfVxuICBzZXQgaW1ldGFzKHRhZ3MpIHtcbiAgICB0aGlzLl9pbWV0YXMgPSB0YWdzO1xuICAgIHRoaXMudGFncyA9IHRoaXMudGFncy5maWx0ZXIoKHRhZykgPT4gdGFnWzBdICE9PSBcImltZXRhXCIpO1xuICAgIHRoaXMudGFncy5wdXNoKC4uLnRhZ3MubWFwKGltZXRhVGFnVG9UYWcpKTtcbiAgfVxuICBnZXQgdXJsKCkge1xuICAgIGlmICh0aGlzLmltZXRhcyAmJiB0aGlzLmltZXRhcy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbWV0YXNbMF0udXJsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcInVybFwiKTtcbiAgfVxuICAvKipcbiAgICogR2V0dGVyIGZvciB0aGUgYXJ0aWNsZSdzIHB1YmxpY2F0aW9uIHRpbWVzdGFtcC5cbiAgICpcbiAgICogQHJldHVybnMge251bWJlciB8IHVuZGVmaW5lZH0gLSBUaGUgVW5peCB0aW1lc3RhbXAgb2Ygd2hlbiB0aGUgYXJ0aWNsZSB3YXMgcHVibGlzaGVkIG9yIHVuZGVmaW5lZC5cbiAgICovXG4gIGdldCBwdWJsaXNoZWRfYXQoKSB7XG4gICAgY29uc3QgdGFnID0gdGhpcy50YWdWYWx1ZShcInB1Ymxpc2hlZF9hdFwiKTtcbiAgICBpZiAodGFnKSB7XG4gICAgICByZXR1cm4gcGFyc2VJbnQodGFnKTtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICAvKipcbiAgICogU2V0dGVyIGZvciB0aGUgYXJ0aWNsZSdzIHB1YmxpY2F0aW9uIHRpbWVzdGFtcC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXIgfCB1bmRlZmluZWR9IHRpbWVzdGFtcCAtIFRoZSBVbml4IHRpbWVzdGFtcCB0byBzZXQgZm9yIHRoZSBhcnRpY2xlJ3MgcHVibGljYXRpb24gZGF0ZS5cbiAgICovXG4gIHNldCBwdWJsaXNoZWRfYXQodGltZXN0YW1wKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJwdWJsaXNoZWRfYXRcIik7XG4gICAgaWYgKHRpbWVzdGFtcCAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJwdWJsaXNoZWRfYXRcIiwgdGltZXN0YW1wLnRvU3RyaW5nKCldKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBjb250ZW50IHRhZ3MgZm9yIHRoZSBhcnRpY2xlLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBmaXJzdCBjaGVja3MgYW5kIHNldHMgdGhlIHB1YmxpY2F0aW9uIGRhdGUgaWYgbm90IGF2YWlsYWJsZSxcbiAgICogYW5kIHRoZW4gZ2VuZXJhdGVzIGNvbnRlbnQgdGFncyBiYXNlZCBvbiB0aGUgYmFzZSBOREtFdmVudCBjbGFzcy5cbiAgICpcbiAgICogQHJldHVybnMge0NvbnRlbnRUYWd9IC0gVGhlIGdlbmVyYXRlZCBjb250ZW50IHRhZ3MuXG4gICAqL1xuICBhc3luYyBnZW5lcmF0ZVRhZ3MoKSB7XG4gICAgc3VwZXIuZ2VuZXJhdGVUYWdzKCk7XG4gICAgaWYgKCF0aGlzLnB1Ymxpc2hlZF9hdCkge1xuICAgICAgdGhpcy5wdWJsaXNoZWRfYXQgPSB0aGlzLmNyZWF0ZWRfYXQ7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5nZW5lcmF0ZVRhZ3MoKTtcbiAgfVxuICBnZXQgZHVyYXRpb24oKSB7XG4gICAgY29uc3QgdGFnID0gdGhpcy50YWdWYWx1ZShcImR1cmF0aW9uXCIpO1xuICAgIGlmICh0YWcpIHtcbiAgICAgIHJldHVybiBwYXJzZUludCh0YWcpO1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIC8qKlxuICAgKiBTZXR0ZXIgZm9yIHRoZSB2aWRlbydzIGR1cmF0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgdW5kZWZpbmVkfSBkdXJhdGlvbiAtIFRoZSBkdXJhdGlvbiB0byBzZXQgZm9yIHRoZSB2aWRlbyAoaW4gc2Vjb25kcylcbiAgICovXG4gIHNldCBkdXJhdGlvbihkdXIpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImR1cmF0aW9uXCIpO1xuICAgIGlmIChkdXIgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wiZHVyYXRpb25cIiwgTWF0aC5mbG9vcihkdXIpLnRvU3RyaW5nKCldKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9ldmVudHMva2luZHMvd2lraS50c1xudmFyIE5ES1dpa2kgPSBjbGFzcyBleHRlbmRzIE5ES0FydGljbGUge1xuICBzdGF0aWMga2luZCA9IDMwODE4IC8qIFdpa2kgKi87XG4gIHN0YXRpYyBraW5kcyA9IFszMDgxOCAvKiBXaWtpICovXTtcbn07XG5cbi8vIHNyYy9ldmVudHMvd3JhcC50c1xuZnVuY3Rpb24gd3JhcEV2ZW50KGV2ZW50KSB7XG4gIGNvbnN0IGV2ZW50V3JhcHBpbmdNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBbXG4gICAgTkRLSW1hZ2UsXG4gICAgTkRLVmlkZW8sXG4gICAgTkRLQ2FzaHVNaW50TGlzdCxcbiAgICBOREtBcnRpY2xlLFxuICAgIE5ES0hpZ2hsaWdodCxcbiAgICBOREtXaWtpLFxuICAgIE5ES051dHphcCxcbiAgICBOREtTaW1wbGVHcm91cE1lbWJlckxpc3QsXG4gICAgTkRLU2ltcGxlR3JvdXBNZXRhZGF0YSxcbiAgICBOREtTdWJzY3JpcHRpb25UaWVyLFxuICAgIE5ES0Nhc2h1VG9rZW4sXG4gICAgTkRLTGlzdFxuICBdLmZvckVhY2goKGtsYXNzMikgPT4ge1xuICAgIGtsYXNzMi5raW5kcy5mb3JFYWNoKChraW5kKSA9PiB7XG4gICAgICBldmVudFdyYXBwaW5nTWFwLnNldChraW5kLCBrbGFzczIpO1xuICAgIH0pO1xuICB9KTtcbiAgY29uc3Qga2xhc3MgPSBldmVudFdyYXBwaW5nTWFwLmdldChldmVudC5raW5kKTtcbiAgaWYgKGtsYXNzKSByZXR1cm4ga2xhc3MuZnJvbShldmVudCk7XG4gIHJldHVybiBldmVudDtcbn1cblxuLy8gc3JjL3N1YnNjcmlwdGlvbi9pbmRleC50c1xudmFyIE5ES1N1YnNjcmlwdGlvbkNhY2hlVXNhZ2UgPSAvKiBAX19QVVJFX18gKi8gKChOREtTdWJzY3JpcHRpb25DYWNoZVVzYWdlMikgPT4ge1xuICBOREtTdWJzY3JpcHRpb25DYWNoZVVzYWdlMltcIk9OTFlfQ0FDSEVcIl0gPSBcIk9OTFlfQ0FDSEVcIjtcbiAgTkRLU3Vic2NyaXB0aW9uQ2FjaGVVc2FnZTJbXCJDQUNIRV9GSVJTVFwiXSA9IFwiQ0FDSEVfRklSU1RcIjtcbiAgTkRLU3Vic2NyaXB0aW9uQ2FjaGVVc2FnZTJbXCJQQVJBTExFTFwiXSA9IFwiUEFSQUxMRUxcIjtcbiAgTkRLU3Vic2NyaXB0aW9uQ2FjaGVVc2FnZTJbXCJPTkxZX1JFTEFZXCJdID0gXCJPTkxZX1JFTEFZXCI7XG4gIHJldHVybiBOREtTdWJzY3JpcHRpb25DYWNoZVVzYWdlMjtcbn0pKE5ES1N1YnNjcmlwdGlvbkNhY2hlVXNhZ2UgfHwge30pO1xudmFyIGRlZmF1bHRPcHRzID0ge1xuICBjbG9zZU9uRW9zZTogZmFsc2UsXG4gIGNhY2hlVXNhZ2U6IFwiQ0FDSEVfRklSU1RcIiAvKiBDQUNIRV9GSVJTVCAqLyxcbiAgZG9udFNhdmVUb0NhY2hlOiBmYWxzZSxcbiAgZ3JvdXBhYmxlOiB0cnVlLFxuICBncm91cGFibGVEZWxheTogMTAwLFxuICBncm91cGFibGVEZWxheVR5cGU6IFwiYXQtbW9zdFwiLFxuICBjYWNoZVVuY29uc3RyYWluRmlsdGVyOiBbXCJsaW1pdFwiLCBcInNpbmNlXCIsIFwidW50aWxcIl1cbn07XG52YXIgTkRLU3Vic2NyaXB0aW9uID0gY2xhc3MgZXh0ZW5kcyBFdmVudEVtaXR0ZXI0IHtcbiAgc3ViSWQ7XG4gIGZpbHRlcnM7XG4gIG9wdHM7XG4gIHBvb2w7XG4gIHNraXBWZXJpZmljYXRpb24gPSBmYWxzZTtcbiAgc2tpcFZhbGlkYXRpb24gPSBmYWxzZTtcbiAgLyoqXG4gICAqIFRyYWNrcyB0aGUgZmlsdGVycyBhcyB0aGV5IGFyZSBleGVjdXRlZCBvbiBlYWNoIHJlbGF5XG4gICAqL1xuICByZWxheUZpbHRlcnM7XG4gIHJlbGF5U2V0O1xuICBuZGs7XG4gIGRlYnVnO1xuICAvKipcbiAgICogRXZlbnRzIHRoYXQgaGF2ZSBiZWVuIHNlZW4gYnkgdGhlIHN1YnNjcmlwdGlvbiwgd2l0aCB0aGUgdGltZSB0aGV5IHdlcmUgZmlyc3Qgc2Vlbi5cbiAgICovXG4gIGV2ZW50Rmlyc3RTZWVuID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgLyoqXG4gICAqIFJlbGF5cyB0aGF0IGhhdmUgc2VudCBhbiBFT1NFLlxuICAgKi9cbiAgZW9zZXNTZWVuID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgLyoqXG4gICAqIFRoZSB0aW1lIHRoZSBsYXN0IGV2ZW50IHdhcyByZWNlaXZlZCBieSB0aGUgc3Vic2NyaXB0aW9uLlxuICAgKiBUaGlzIGlzIHVzZWQgdG8gY2FsY3VsYXRlIHdoZW4gRU9TRSBzaG91bGQgYmUgZW1pdHRlZC5cbiAgICovXG4gIGxhc3RFdmVudFJlY2VpdmVkQXQ7XG4gIGludGVybmFsSWQ7XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBzdWJzY3JpcHRpb24gc2hvdWxkIGNsb3NlIHdoZW4gYWxsIHJlbGF5cyBoYXZlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgZXZlbnQgc3RyZWFtLlxuICAgKi9cbiAgY2xvc2VPbkVvc2U7XG4gIC8qKlxuICAgKiBQb29sIG1vbml0b3IgY2FsbGJhY2tcbiAgICovXG4gIHBvb2xNb25pdG9yO1xuICBza2lwT3B0aW1pc3RpY1B1Ymxpc2hFdmVudCA9IGZhbHNlO1xuICAvKipcbiAgICogRmlsdGVycyB0byByZW1vdmUgd2hlbiBxdWVyeWluZyB0aGUgY2FjaGUuXG4gICAqL1xuICBjYWNoZVVuY29uc3RyYWluRmlsdGVyO1xuICBjb25zdHJ1Y3RvcihuZGssIGZpbHRlcnMsIG9wdHMsIHJlbGF5U2V0LCBzdWJJZCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5uZGsgPSBuZGs7XG4gICAgdGhpcy5wb29sID0gb3B0cz8ucG9vbCB8fCBuZGsucG9vbDtcbiAgICB0aGlzLm9wdHMgPSB7IC4uLmRlZmF1bHRPcHRzLCAuLi5vcHRzIHx8IHt9IH07XG4gICAgdGhpcy5maWx0ZXJzID0gZmlsdGVycyBpbnN0YW5jZW9mIEFycmF5ID8gZmlsdGVycyA6IFtmaWx0ZXJzXTtcbiAgICB0aGlzLnN1YklkID0gc3ViSWQgfHwgdGhpcy5vcHRzLnN1YklkO1xuICAgIHRoaXMuaW50ZXJuYWxJZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZyg3KTtcbiAgICB0aGlzLnJlbGF5U2V0ID0gcmVsYXlTZXQ7XG4gICAgdGhpcy5kZWJ1ZyA9IG5kay5kZWJ1Zy5leHRlbmQoYHN1YnNjcmlwdGlvblske3RoaXMub3B0cy5zdWJJZCA/PyB0aGlzLmludGVybmFsSWR9XWApO1xuICAgIHRoaXMuc2tpcFZlcmlmaWNhdGlvbiA9IHRoaXMub3B0cy5za2lwVmVyaWZpY2F0aW9uIHx8IGZhbHNlO1xuICAgIHRoaXMuc2tpcFZhbGlkYXRpb24gPSB0aGlzLm9wdHMuc2tpcFZhbGlkYXRpb24gfHwgZmFsc2U7XG4gICAgdGhpcy5jbG9zZU9uRW9zZSA9IHRoaXMub3B0cy5jbG9zZU9uRW9zZSB8fCBmYWxzZTtcbiAgICB0aGlzLnNraXBPcHRpbWlzdGljUHVibGlzaEV2ZW50ID0gdGhpcy5vcHRzLnNraXBPcHRpbWlzdGljUHVibGlzaEV2ZW50IHx8IGZhbHNlO1xuICAgIHRoaXMuY2FjaGVVbmNvbnN0cmFpbkZpbHRlciA9IHRoaXMub3B0cy5jYWNoZVVuY29uc3RyYWluRmlsdGVyO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByZWxheXMgdGhhdCBoYXZlIG5vdCB5ZXQgc2VudCBhbiBFT1NFLlxuICAgKi9cbiAgcmVsYXlzTWlzc2luZ0Vvc2UoKSB7XG4gICAgaWYgKCF0aGlzLnJlbGF5RmlsdGVycykgcmV0dXJuIFtdO1xuICAgIGNvbnN0IHJlbGF5c01pc3NpbmdFb3NlID0gQXJyYXkuZnJvbSh0aGlzLnJlbGF5RmlsdGVycy5rZXlzKCkpLmZpbHRlcihcbiAgICAgICh1cmwpID0+ICF0aGlzLmVvc2VzU2Vlbi5oYXModGhpcy5wb29sLmdldFJlbGF5KHVybCwgZmFsc2UsIGZhbHNlKSlcbiAgICApO1xuICAgIHJldHVybiByZWxheXNNaXNzaW5nRW9zZTtcbiAgfVxuICAvKipcbiAgICogUHJvdmlkZXMgYWNjZXNzIHRvIHRoZSBmaXJzdCBmaWx0ZXIgb2YgdGhlIHN1YnNjcmlwdGlvbiBmb3JcbiAgICogYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gICAqL1xuICBnZXQgZmlsdGVyKCkge1xuICAgIHJldHVybiB0aGlzLmZpbHRlcnNbMF07XG4gIH1cbiAgZ2V0IGdyb3VwYWJsZURlbGF5KCkge1xuICAgIGlmICghdGhpcy5pc0dyb3VwYWJsZSgpKSByZXR1cm4gdm9pZCAwO1xuICAgIHJldHVybiB0aGlzLm9wdHM/Lmdyb3VwYWJsZURlbGF5O1xuICB9XG4gIGdldCBncm91cGFibGVEZWxheVR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0cz8uZ3JvdXBhYmxlRGVsYXlUeXBlIHx8IFwiYXQtbW9zdFwiO1xuICB9XG4gIGlzR3JvdXBhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLm9wdHM/Lmdyb3VwYWJsZSB8fCBmYWxzZTtcbiAgfVxuICBzaG91bGRRdWVyeUNhY2hlKCkge1xuICAgIGlmICh0aGlzLm9wdHM/LmNhY2hlVXNhZ2UgPT09IFwiT05MWV9SRUxBWVwiIC8qIE9OTFlfUkVMQVkgKi8pIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBoYXNOb25FcGhlbWVyYWxLaW5kID0gdGhpcy5maWx0ZXJzLnNvbWUoKGYpID0+IGYua2luZHM/LnNvbWUoKGspID0+IGtpbmRJc0VwaGVtZXJhbChrKSkpO1xuICAgIGlmIChoYXNOb25FcGhlbWVyYWxLaW5kKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBzaG91bGRRdWVyeVJlbGF5cygpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRzPy5jYWNoZVVzYWdlICE9PSBcIk9OTFlfQ0FDSEVcIiAvKiBPTkxZX0NBQ0hFICovO1xuICB9XG4gIHNob3VsZFdhaXRGb3JDYWNoZSgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgLy8gTXVzdCB3YW50IHRvIGNsb3NlIG9uIEVPU0U7IHN1YnNjcmlwdGlvbnNcbiAgICAgIC8vIHRoYXQgd2FudCB0byByZWNlaXZlIGZ1cnRoZXIgdXBkYXRlcyBtdXN0XG4gICAgICAvLyBhbHdheXMgaGl0IHRoZSByZWxheVxuICAgICAgdGhpcy5vcHRzLmNsb3NlT25Fb3NlICYmIC8vIENhY2hlIGFkYXB0ZXIgbXVzdCBjbGFpbSB0byBiZSBmYXN0XG4gICAgICAhIXRoaXMubmRrLmNhY2hlQWRhcHRlcj8ubG9ja2luZyAmJiAvLyBJZiBleHBsaWNpdGx5IHRvbGQgdG8gcnVuIGluIHBhcmFsbGVsLCB0aGVuXG4gICAgICAvLyB3ZSBzaG91bGQgbm90IHdhaXQgZm9yIHRoZSBjYWNoZVxuICAgICAgdGhpcy5vcHRzLmNhY2hlVXNhZ2UgIT09IFwiUEFSQUxMRUxcIiAvKiBQQVJBTExFTCAqL1xuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIFN0YXJ0IHRoZSBzdWJzY3JpcHRpb24uIFRoaXMgaXMgdGhlIG1haW4gbWV0aG9kIHRoYXQgc2hvdWxkIGJlIGNhbGxlZFxuICAgKiBhZnRlciBjcmVhdGluZyBhIHN1YnNjcmlwdGlvbi5cbiAgICogXG4gICAqIEBwYXJhbSBlbWl0Q2FjaGVkRXZlbnRzIC0gV2hldGhlciB0byBlbWl0IGV2ZW50cyBjb21pbmcgZnJvbSBhIHN5bmNocm9ub3VzIGNhY2hlXG4gICAqIFxuICAgKiBXaGVuIHVzaW5nIGEgc3luY2hyb25vdXMgY2FjaGUsIHRoZSBldmVudHMgd2lsbCBiZSByZXR1cm5lZCBpbW1lZGlhdGVseVxuICAgKiBieSB0aGlzIGZ1bmN0aW9uLiBJZiB5b3Ugd2lsbCB1c2UgdGhvc2UgcmV0dXJuZWQgZXZlbnRzLCB5b3Ugc2hvdWxkXG4gICAqIHNldCBlbWl0Q2FjaGVkRXZlbnRzIHRvIGZhbHNlIHRvIHByZXZlbnQgc2VlaW5nIHRoZW0gYXMgZHVwbGljYXRlIGV2ZW50cy5cbiAgICovXG4gIHN0YXJ0KGVtaXRDYWNoZWRFdmVudHMgPSB0cnVlKSB7XG4gICAgbGV0IGNhY2hlUmVzdWx0O1xuICAgIGNvbnN0IHVwZGF0ZVN0YXRlRnJvbUNhY2hlUmVzdWx0cyA9IChldmVudHMpID0+IHtcbiAgICAgIGlmIChlbWl0Q2FjaGVkRXZlbnRzKSB7XG4gICAgICAgIGZvciAoY29uc3QgZXZlbnQgb2YgZXZlbnRzKSB7XG4gICAgICAgICAgdGhpcy5ldmVudFJlY2VpdmVkKGV2ZW50LCB2b2lkIDAsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FjaGVSZXN1bHQgPSBbXTtcbiAgICAgICAgZXZlbnRzLmZvckVhY2goKGV2ZW50KSA9PiB7XG4gICAgICAgICAgZXZlbnQubmRrID0gdGhpcy5uZGs7XG4gICAgICAgICAgY29uc3QgZSA9IHRoaXMub3B0cy53cmFwID8gd3JhcEV2ZW50KGV2ZW50KSA6IGV2ZW50O1xuICAgICAgICAgIGlmICghZSkgcmV0dXJuO1xuICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgZS50aGVuKCh3cmFwcGVkRXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5lbWl0RXZlbnQoZmFsc2UsIHdyYXBwZWRFdmVudCwgdm9pZCAwLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5ldmVudEZpcnN0U2Vlbi5zZXQoZS5pZCwgRGF0ZS5ub3coKSk7XG4gICAgICAgICAgY2FjaGVSZXN1bHQucHVzaChlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBsb2FkRnJvbVJlbGF5cyA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLnNob3VsZFF1ZXJ5UmVsYXlzKCkpIHtcbiAgICAgICAgdGhpcy5zdGFydFdpdGhSZWxheXMoKTtcbiAgICAgICAgdGhpcy5zdGFydFBvb2xNb25pdG9yKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVtaXQoXCJlb3NlXCIsIHRoaXMpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKHRoaXMuc2hvdWxkUXVlcnlDYWNoZSgpKSB7XG4gICAgICBjYWNoZVJlc3VsdCA9IHRoaXMuc3RhcnRXaXRoQ2FjaGUoKTtcbiAgICAgIGlmIChjYWNoZVJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkV2FpdEZvckNhY2hlKCkpIHtcbiAgICAgICAgICBjYWNoZVJlc3VsdC50aGVuKChldmVudHMpID0+IHtcbiAgICAgICAgICAgIHVwZGF0ZVN0YXRlRnJvbUNhY2hlUmVzdWx0cyhldmVudHMpO1xuICAgICAgICAgICAgaWYgKHF1ZXJ5RnVsbHlGaWxsZWQodGhpcykpIHtcbiAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZW9zZVwiLCB0aGlzKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbG9hZEZyb21SZWxheXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWNoZVJlc3VsdC50aGVuKChldmVudHMpID0+IHtcbiAgICAgICAgICAgIHVwZGF0ZVN0YXRlRnJvbUNhY2hlUmVzdWx0cyhldmVudHMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXBkYXRlU3RhdGVGcm9tQ2FjaGVSZXN1bHRzKGNhY2hlUmVzdWx0KTtcbiAgICAgICAgaWYgKHF1ZXJ5RnVsbHlGaWxsZWQodGhpcykpIHtcbiAgICAgICAgICB0aGlzLmVtaXQoXCJlb3NlXCIsIHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvYWRGcm9tUmVsYXlzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhY2hlUmVzdWx0O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsb2FkRnJvbVJlbGF5cygpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBXZSB3YW50IHRvIG1vbml0b3IgZm9yIG5ldyByZWxheXMgdGhhdCBhcmUgY29taW5nIG9ubGluZSwgaW4gY2FzZVxuICAgKiB0aGV5IHNob3VsZCBiZSBwYXJ0IG9mIHRoaXMgc3Vic2NyaXB0aW9uLlxuICAgKi9cbiAgc3RhcnRQb29sTW9uaXRvcigpIHtcbiAgICBjb25zdCBkNCA9IHRoaXMuZGVidWcuZXh0ZW5kKFwicG9vbC1tb25pdG9yXCIpO1xuICAgIHRoaXMucG9vbE1vbml0b3IgPSAocmVsYXkpID0+IHtcbiAgICAgIGlmICh0aGlzLnJlbGF5RmlsdGVycz8uaGFzKHJlbGF5LnVybCkpIHJldHVybjtcbiAgICAgIGNvbnN0IGNhbGMgPSBjYWxjdWxhdGVSZWxheVNldHNGcm9tRmlsdGVycyh0aGlzLm5kaywgdGhpcy5maWx0ZXJzLCB0aGlzLnBvb2wpO1xuICAgICAgaWYgKGNhbGMuZ2V0KHJlbGF5LnVybCkpIHtcbiAgICAgICAgdGhpcy5yZWxheUZpbHRlcnM/LnNldChyZWxheS51cmwsIHRoaXMuZmlsdGVycyk7XG4gICAgICAgIHJlbGF5LnN1YnNjcmliZSh0aGlzLCB0aGlzLmZpbHRlcnMpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5wb29sLm9uKFwicmVsYXk6Y29ubmVjdFwiLCB0aGlzLnBvb2xNb25pdG9yKTtcbiAgfVxuICBvblN0b3BwZWQ7XG4gIHN0b3AoKSB7XG4gICAgdGhpcy5lbWl0KFwiY2xvc2VcIiwgdGhpcyk7XG4gICAgdGhpcy5wb29sTW9uaXRvciAmJiB0aGlzLnBvb2wub2ZmKFwicmVsYXk6Y29ubmVjdFwiLCB0aGlzLnBvb2xNb25pdG9yKTtcbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgIHRoaXMub25TdG9wcGVkPy4oKTtcbiAgfVxuICAvKipcbiAgICogQHJldHVybnMgV2hldGhlciB0aGUgc3Vic2NyaXB0aW9uIGhhcyBhbiBhdXRob3JzIGZpbHRlci5cbiAgICovXG4gIGhhc0F1dGhvcnNGaWx0ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsdGVycy5zb21lKChmKSA9PiBmLmF1dGhvcnM/Lmxlbmd0aCk7XG4gIH1cbiAgc3RhcnRXaXRoQ2FjaGUoKSB7XG4gICAgaWYgKHRoaXMubmRrLmNhY2hlQWRhcHRlcj8ucXVlcnkpIHtcbiAgICAgIHJldHVybiB0aGlzLm5kay5jYWNoZUFkYXB0ZXIucXVlcnkodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFNlbmQgUkVRIHRvIHJlbGF5c1xuICAgKi9cbiAgc3RhcnRXaXRoUmVsYXlzKCkge1xuICAgIGlmICghdGhpcy5yZWxheVNldCB8fCB0aGlzLnJlbGF5U2V0LnJlbGF5cy5zaXplID09PSAwKSB7XG4gICAgICB0aGlzLnJlbGF5RmlsdGVycyA9IGNhbGN1bGF0ZVJlbGF5U2V0c0Zyb21GaWx0ZXJzKHRoaXMubmRrLCB0aGlzLmZpbHRlcnMsIHRoaXMucG9vbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVsYXlGaWx0ZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIGZvciAoY29uc3QgcmVsYXkgb2YgdGhpcy5yZWxheVNldC5yZWxheXMpIHtcbiAgICAgICAgdGhpcy5yZWxheUZpbHRlcnMuc2V0KHJlbGF5LnVybCwgdGhpcy5maWx0ZXJzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0aGlzLnJlbGF5RmlsdGVycyB8fCB0aGlzLnJlbGF5RmlsdGVycy5zaXplID09PSAwKSByZXR1cm47XG4gICAgZm9yIChjb25zdCBbcmVsYXlVcmwsIGZpbHRlcnNdIG9mIHRoaXMucmVsYXlGaWx0ZXJzKSB7XG4gICAgICBjb25zdCByZWxheSA9IHRoaXMucG9vbC5nZXRSZWxheShyZWxheVVybCwgdHJ1ZSwgdHJ1ZSwgZmlsdGVycyk7XG4gICAgICByZWxheS5zdWJzY3JpYmUodGhpcywgZmlsdGVycyk7XG4gICAgfVxuICB9XG4gIC8vIEVWRU5UIGhhbmRsaW5nXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBhbiBldmVudCBpcyByZWNlaXZlZCBmcm9tIGEgcmVsYXkgb3IgdGhlIGNhY2hlXG4gICAqIEBwYXJhbSBldmVudFxuICAgKiBAcGFyYW0gcmVsYXlcbiAgICogQHBhcmFtIGZyb21DYWNoZSBXaGV0aGVyIHRoZSBldmVudCB3YXMgcmVjZWl2ZWQgZnJvbSB0aGUgY2FjaGVcbiAgICogQHBhcmFtIG9wdGltaXN0aWNQdWJsaXNoIFdoZXRoZXIgdGhpcyBldmVudCBpcyBjb21pbmcgZnJvbSBhbiBvcHRpbWlzdGljIHB1Ymxpc2hcbiAgICovXG4gIGV2ZW50UmVjZWl2ZWQoZXZlbnQsIHJlbGF5LCBmcm9tQ2FjaGUgPSBmYWxzZSwgb3B0aW1pc3RpY1B1Ymxpc2ggPSBmYWxzZSkge1xuICAgIGNvbnN0IGV2ZW50SWQgPSBldmVudC5pZDtcbiAgICBjb25zdCBldmVudEFscmVhZHlTZWVuID0gdGhpcy5ldmVudEZpcnN0U2Vlbi5oYXMoZXZlbnRJZCk7XG4gICAgbGV0IG5ka0V2ZW50O1xuICAgIGlmIChldmVudCBpbnN0YW5jZW9mIE5ES0V2ZW50KSBuZGtFdmVudCA9IGV2ZW50O1xuICAgIGlmICghZXZlbnRBbHJlYWR5U2Vlbikge1xuICAgICAgbmRrRXZlbnQgPz89IG5ldyBOREtFdmVudCh0aGlzLm5kaywgZXZlbnQpO1xuICAgICAgbmRrRXZlbnQubmRrID0gdGhpcy5uZGs7XG4gICAgICBuZGtFdmVudC5yZWxheSA9IHJlbGF5O1xuICAgICAgaWYgKCFmcm9tQ2FjaGUgJiYgIW9wdGltaXN0aWNQdWJsaXNoKSB7XG4gICAgICAgIGlmICghdGhpcy5za2lwVmFsaWRhdGlvbikge1xuICAgICAgICAgIGlmICghbmRrRXZlbnQuaXNWYWxpZCkge1xuICAgICAgICAgICAgdGhpcy5kZWJ1ZyhgRXZlbnQgZmFpbGVkIHZhbGlkYXRpb24gJXMgZnJvbSByZWxheSAlc2AsIGV2ZW50SWQsIHJlbGF5Py51cmwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVsYXkpIHtcbiAgICAgICAgICBpZiAocmVsYXk/LnNob3VsZFZhbGlkYXRlRXZlbnQoKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5za2lwVmVyaWZpY2F0aW9uKSB7XG4gICAgICAgICAgICAgIGlmICghbmRrRXZlbnQudmVyaWZ5U2lnbmF0dXJlKHRydWUpICYmICF0aGlzLm5kay5hc3luY1NpZ1ZlcmlmaWNhdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVidWcoYEV2ZW50IGZhaWxlZCBzaWduYXR1cmUgdmFsaWRhdGlvbmAsIGV2ZW50KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVsYXkpIHtcbiAgICAgICAgICAgICAgICByZWxheS5hZGRWYWxpZGF0ZWRFdmVudCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbGF5LmFkZE5vblZhbGlkYXRlZEV2ZW50KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm5kay5jYWNoZUFkYXB0ZXIgJiYgIXRoaXMub3B0cy5kb250U2F2ZVRvQ2FjaGUpIHtcbiAgICAgICAgICB0aGlzLm5kay5jYWNoZUFkYXB0ZXIuc2V0RXZlbnQobmRrRXZlbnQsIHRoaXMuZmlsdGVycywgcmVsYXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIW9wdGltaXN0aWNQdWJsaXNoIHx8IHRoaXMuc2tpcE9wdGltaXN0aWNQdWJsaXNoRXZlbnQgIT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5lbWl0RXZlbnQodGhpcy5vcHRzPy53cmFwLCBuZGtFdmVudCwgcmVsYXksIGZyb21DYWNoZSwgb3B0aW1pc3RpY1B1Ymxpc2gpO1xuICAgICAgICB0aGlzLmV2ZW50Rmlyc3RTZWVuLnNldChldmVudElkLCBEYXRlLm5vdygpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdGltZVNpbmNlRmlyc3RTZWVuID0gRGF0ZS5ub3coKSAtICh0aGlzLmV2ZW50Rmlyc3RTZWVuLmdldChldmVudElkKSB8fCAwKTtcbiAgICAgIHRoaXMuZW1pdChcImV2ZW50OmR1cFwiLCBldmVudCwgcmVsYXksIHRpbWVTaW5jZUZpcnN0U2VlbiwgdGhpcywgZnJvbUNhY2hlLCBvcHRpbWlzdGljUHVibGlzaCk7XG4gICAgICBpZiAocmVsYXkpIHtcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gdmVyaWZpZWRTaWduYXR1cmVzLmdldChldmVudElkKTtcbiAgICAgICAgaWYgKHNpZ25hdHVyZSAmJiB0eXBlb2Ygc2lnbmF0dXJlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgaWYgKGV2ZW50LnNpZyA9PT0gc2lnbmF0dXJlKSB7XG4gICAgICAgICAgICByZWxheS5hZGRWYWxpZGF0ZWRFdmVudCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmxhc3RFdmVudFJlY2VpdmVkQXQgPSBEYXRlLm5vdygpO1xuICB9XG4gIC8qKlxuICAgKiBPcHRpb25hbGx5IHdyYXBzLCBzeW5jIG9yIGFzeW5jLCBhbmQgZW1pdHMgdGhlIGV2ZW50IChpZiBvbmUgY29tZXMgYmFjayBmcm9tIHRoZSB3cmFwcGVyKVxuICAgKi9cbiAgZW1pdEV2ZW50KHdyYXAgPSBmYWxzZSwgZXZ0LCByZWxheSwgZnJvbUNhY2hlLCBvcHRpbWlzdGljUHVibGlzaCkge1xuICAgIGNvbnN0IHdyYXBwZWQgPSB3cmFwID8gd3JhcEV2ZW50KGV2dCkgOiBldnQ7XG4gICAgaWYgKHdyYXBwZWQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICB3cmFwcGVkLnRoZW4oKGUpID0+IHRoaXMuZW1pdEV2ZW50KGZhbHNlLCBlLCByZWxheSwgZnJvbUNhY2hlLCBvcHRpbWlzdGljUHVibGlzaCkpO1xuICAgIH0gZWxzZSBpZiAod3JhcHBlZCkge1xuICAgICAgdGhpcy5lbWl0KFwiZXZlbnRcIiwgd3JhcHBlZCwgcmVsYXksIHRoaXMsIGZyb21DYWNoZSwgb3B0aW1pc3RpY1B1Ymxpc2gpO1xuICAgIH1cbiAgfVxuICBjbG9zZWRSZWNlaXZlZChyZWxheSwgcmVhc29uKSB7XG4gICAgdGhpcy5lbWl0KFwiY2xvc2VkXCIsIHJlbGF5LCByZWFzb24pO1xuICB9XG4gIC8vIEVPU0UgaGFuZGxpbmdcbiAgZW9zZVRpbWVvdXQ7XG4gIGVvc2VkID0gZmFsc2U7XG4gIGVvc2VSZWNlaXZlZChyZWxheSkge1xuICAgIHRoaXMuZGVidWcoXCJFT1NFIHJlY2VpdmVkIGZyb20gJXNcIiwgcmVsYXkudXJsKTtcbiAgICB0aGlzLmVvc2VzU2Vlbi5hZGQocmVsYXkpO1xuICAgIGxldCBsYXN0RXZlbnRTZWVuID0gdGhpcy5sYXN0RXZlbnRSZWNlaXZlZEF0ID8gRGF0ZS5ub3coKSAtIHRoaXMubGFzdEV2ZW50UmVjZWl2ZWRBdCA6IHZvaWQgMDtcbiAgICBjb25zdCBoYXNTZWVuQWxsRW9zZXMgPSB0aGlzLmVvc2VzU2Vlbi5zaXplID09PSB0aGlzLnJlbGF5RmlsdGVycz8uc2l6ZTtcbiAgICBjb25zdCBxdWVyeUZpbGxlZCA9IHF1ZXJ5RnVsbHlGaWxsZWQodGhpcyk7XG4gICAgY29uc3QgcGVyZm9ybUVvc2UgPSAocmVhc29uKSA9PiB7XG4gICAgICB0aGlzLmRlYnVnKFwiUGVyZm9ybWluZyBFT1NFOiAlcyAlZFwiLCByZWFzb24sIHRoaXMuZW9zZWQpO1xuICAgICAgaWYgKHRoaXMuZW9zZWQpIHJldHVybjtcbiAgICAgIGlmICh0aGlzLmVvc2VUaW1lb3V0KSBjbGVhclRpbWVvdXQodGhpcy5lb3NlVGltZW91dCk7XG4gICAgICB0aGlzLmVtaXQoXCJlb3NlXCIsIHRoaXMpO1xuICAgICAgdGhpcy5lb3NlZCA9IHRydWU7XG4gICAgfTtcbiAgICBpZiAocXVlcnlGaWxsZWQgfHwgaGFzU2VlbkFsbEVvc2VzKSB7XG4gICAgICBwZXJmb3JtRW9zZShcInF1ZXJ5IGZpbGxlZCBvciBzZWVuIGFsbFwiKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMucmVsYXlGaWx0ZXJzKSB7XG4gICAgICBsZXQgdGltZVRvV2FpdEZvck5leHRFb3NlID0gMWUzO1xuICAgICAgY29uc3QgY29ubmVjdGVkUmVsYXlzID0gbmV3IFNldCh0aGlzLnBvb2wuY29ubmVjdGVkUmVsYXlzKCkubWFwKChyKSA9PiByLnVybCkpO1xuICAgICAgY29uc3QgY29ubmVjdGVkUmVsYXlzV2l0aEZpbHRlcnMgPSBBcnJheS5mcm9tKHRoaXMucmVsYXlGaWx0ZXJzLmtleXMoKSkuZmlsdGVyKFxuICAgICAgICAodXJsKSA9PiBjb25uZWN0ZWRSZWxheXMuaGFzKHVybClcbiAgICAgICk7XG4gICAgICBpZiAoY29ubmVjdGVkUmVsYXlzV2l0aEZpbHRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBlcmNlbnRhZ2VPZlJlbGF5c1RoYXRIYXZlU2VudEVvc2UgPSB0aGlzLmVvc2VzU2Vlbi5zaXplIC8gY29ubmVjdGVkUmVsYXlzV2l0aEZpbHRlcnMubGVuZ3RoO1xuICAgICAgdGhpcy5kZWJ1ZyhcIlBlcmNlbnRhZ2Ugb2YgcmVsYXlzIHRoYXQgaGF2ZSBzZW50IEVPU0VcIiwgeyBzdWJJZDogdGhpcy5zdWJJZCwgcGVyY2VudGFnZU9mUmVsYXlzVGhhdEhhdmVTZW50RW9zZSwgc2VlbjogdGhpcy5lb3Nlc1NlZW4uc2l6ZSwgdG90YWw6IGNvbm5lY3RlZFJlbGF5c1dpdGhGaWx0ZXJzLmxlbmd0aCB9KTtcbiAgICAgIGlmICh0aGlzLmVvc2VzU2Vlbi5zaXplID49IDIgJiYgcGVyY2VudGFnZU9mUmVsYXlzVGhhdEhhdmVTZW50RW9zZSA+PSAwLjUpIHtcbiAgICAgICAgdGltZVRvV2FpdEZvck5leHRFb3NlID0gdGltZVRvV2FpdEZvck5leHRFb3NlICogKDEgLSBwZXJjZW50YWdlT2ZSZWxheXNUaGF0SGF2ZVNlbnRFb3NlKTtcbiAgICAgICAgaWYgKHRpbWVUb1dhaXRGb3JOZXh0RW9zZSA9PT0gMCkge1xuICAgICAgICAgIHBlcmZvcm1Fb3NlKFwidGltZSB0byB3YWl0IHdhcyAwXCIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5lb3NlVGltZW91dCkgY2xlYXJUaW1lb3V0KHRoaXMuZW9zZVRpbWVvdXQpO1xuICAgICAgICBjb25zdCBzZW5kRW9zZVRpbWVvdXQgPSAoKSA9PiB7XG4gICAgICAgICAgbGFzdEV2ZW50U2VlbiA9IHRoaXMubGFzdEV2ZW50UmVjZWl2ZWRBdCA/IERhdGUubm93KCkgLSB0aGlzLmxhc3RFdmVudFJlY2VpdmVkQXQgOiB2b2lkIDA7XG4gICAgICAgICAgaWYgKGxhc3RFdmVudFNlZW4gIT09IHZvaWQgMCAmJiBsYXN0RXZlbnRTZWVuIDwgMjApIHtcbiAgICAgICAgICAgIHRoaXMuZW9zZVRpbWVvdXQgPSBzZXRUaW1lb3V0KHNlbmRFb3NlVGltZW91dCwgdGltZVRvV2FpdEZvck5leHRFb3NlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVyZm9ybUVvc2UoXCJzZW5kIGVvc2UgdGltZW91dDogXCIgKyB0aW1lVG9XYWl0Rm9yTmV4dEVvc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5lb3NlVGltZW91dCA9IHNldFRpbWVvdXQoc2VuZEVvc2VUaW1lb3V0LCB0aW1lVG9XYWl0Rm9yTmV4dEVvc2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbnZhciBraW5kSXNFcGhlbWVyYWwgPSAoa2luZCkgPT4ga2luZCA+PSAyZTQgJiYga2luZCA8IDNlNDtcblxuLy8gc3JjL3VzZXIvZm9sbG93cy50c1xuYXN5bmMgZnVuY3Rpb24gZm9sbG93cyhvcHRzLCBvdXRib3gsIGtpbmQgPSAzIC8qIENvbnRhY3RzICovKSB7XG4gIGlmICghdGhpcy5uZGspIHRocm93IG5ldyBFcnJvcihcIk5ESyBub3Qgc2V0XCIpO1xuICBjb25zdCBjb250YWN0TGlzdEV2ZW50ID0gYXdhaXQgdGhpcy5uZGsuZmV0Y2hFdmVudChcbiAgICB7IGtpbmRzOiBba2luZF0sIGF1dGhvcnM6IFt0aGlzLnB1YmtleV0gfSxcbiAgICBvcHRzIHx8IHsgZ3JvdXBhYmxlOiBmYWxzZSB9XG4gICk7XG4gIGlmIChjb250YWN0TGlzdEV2ZW50KSB7XG4gICAgY29uc3QgcHVia2V5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgY29udGFjdExpc3RFdmVudC50YWdzLmZvckVhY2goKHRhZykgPT4ge1xuICAgICAgaWYgKHRhZ1swXSA9PT0gXCJwXCIpIHB1YmtleXMuYWRkKHRhZ1sxXSk7XG4gICAgfSk7XG4gICAgaWYgKG91dGJveCkge1xuICAgICAgdGhpcy5uZGs/Lm91dGJveFRyYWNrZXI/LnRyYWNrVXNlcnMoQXJyYXkuZnJvbShwdWJrZXlzKSk7XG4gICAgfVxuICAgIHJldHVybiBbLi4ucHVia2V5c10ucmVkdWNlKChhY2MsIHB1YmtleSkgPT4ge1xuICAgICAgY29uc3QgdXNlciA9IG5ldyBOREtVc2VyKHsgcHVia2V5IH0pO1xuICAgICAgdXNlci5uZGsgPSB0aGlzLm5kaztcbiAgICAgIGFjYy5hZGQodXNlcik7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xufVxuXG4vLyBzcmMvdXNlci9wcm9maWxlLnRzXG5mdW5jdGlvbiBwcm9maWxlRnJvbUV2ZW50KGV2ZW50KSB7XG4gIGNvbnN0IHByb2ZpbGUgPSB7fTtcbiAgbGV0IHBheWxvYWQ7XG4gIHRyeSB7XG4gICAgcGF5bG9hZCA9IEpTT04ucGFyc2UoZXZlbnQuY29udGVudCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcGFyc2UgcHJvZmlsZSBldmVudDogJHtlcnJvcn1gKTtcbiAgfVxuICBwcm9maWxlLmNyZWF0ZWRfYXQgPSBldmVudC5jcmVhdGVkX2F0O1xuICBwcm9maWxlLnByb2ZpbGVFdmVudCA9IEpTT04uc3RyaW5naWZ5KGV2ZW50LnJhd0V2ZW50KCkpO1xuICBPYmplY3Qua2V5cyhwYXlsb2FkKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgY2FzZSBcIm5hbWVcIjpcbiAgICAgICAgcHJvZmlsZS5uYW1lID0gcGF5bG9hZC5uYW1lO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJkaXNwbGF5X25hbWVcIjpcbiAgICAgICAgcHJvZmlsZS5kaXNwbGF5TmFtZSA9IHBheWxvYWQuZGlzcGxheV9uYW1lO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJpbWFnZVwiOlxuICAgICAgY2FzZSBcInBpY3R1cmVcIjpcbiAgICAgICAgcHJvZmlsZS5waWN0dXJlID0gcGF5bG9hZC5waWN0dXJlIHx8IHBheWxvYWQuaW1hZ2U7XG4gICAgICAgIHByb2ZpbGUuaW1hZ2UgPSBwcm9maWxlLnBpY3R1cmU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImJhbm5lclwiOlxuICAgICAgICBwcm9maWxlLmJhbm5lciA9IHBheWxvYWQuYmFubmVyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJiaW9cIjpcbiAgICAgICAgcHJvZmlsZS5iaW8gPSBwYXlsb2FkLmJpbztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibmlwMDVcIjpcbiAgICAgICAgcHJvZmlsZS5uaXAwNSA9IHBheWxvYWQubmlwMDU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImx1ZDA2XCI6XG4gICAgICAgIHByb2ZpbGUubHVkMDYgPSBwYXlsb2FkLmx1ZDA2O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJsdWQxNlwiOlxuICAgICAgICBwcm9maWxlLmx1ZDE2ID0gcGF5bG9hZC5sdWQxNjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYWJvdXRcIjpcbiAgICAgICAgcHJvZmlsZS5hYm91dCA9IHBheWxvYWQuYWJvdXQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIndlYnNpdGVcIjpcbiAgICAgICAgcHJvZmlsZS53ZWJzaXRlID0gcGF5bG9hZC53ZWJzaXRlO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHByb2ZpbGVba2V5XSA9IHBheWxvYWRba2V5XTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHByb2ZpbGU7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVQcm9maWxlKHByb2ZpbGUpIHtcbiAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgT2JqZWN0LmVudHJpZXMocHJvZmlsZSkpIHtcbiAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgY2FzZSBcInVzZXJuYW1lXCI6XG4gICAgICBjYXNlIFwibmFtZVwiOlxuICAgICAgICBwYXlsb2FkLm5hbWUgPSB2YWw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImRpc3BsYXlOYW1lXCI6XG4gICAgICAgIHBheWxvYWQuZGlzcGxheV9uYW1lID0gdmFsO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJpbWFnZVwiOlxuICAgICAgY2FzZSBcInBpY3R1cmVcIjpcbiAgICAgICAgcGF5bG9hZC5waWN0dXJlID0gdmFsO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJiaW9cIjpcbiAgICAgIGNhc2UgXCJhYm91dFwiOlxuICAgICAgICBwYXlsb2FkLmFib3V0ID0gdmFsO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHBheWxvYWRba2V5XSA9IHZhbDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShwYXlsb2FkKTtcbn1cblxuLy8gc3JjL3VzZXIvbmlwMDUudHNcbnZhciBOSVAwNV9SRUdFWCA9IC9eKD86KFtcXHcuKy1dKylAKT8oW1xcdy4tXSspJC87XG5hc3luYyBmdW5jdGlvbiBnZXROaXAwNUZvcihuZGssIGZ1bGxuYW1lLCBfZmV0Y2ggPSBmZXRjaCwgZmV0Y2hPcHRzID0ge30pIHtcbiAgcmV0dXJuIGF3YWl0IG5kay5xdWV1ZXNOaXAwNS5hZGQoe1xuICAgIGlkOiBmdWxsbmFtZSxcbiAgICBmdW5jOiBhc3luYyAoKSA9PiB7XG4gICAgICBpZiAobmRrLmNhY2hlQWRhcHRlciAmJiBuZGsuY2FjaGVBZGFwdGVyLmxvYWROaXAwNSkge1xuICAgICAgICBjb25zdCBwcm9maWxlID0gYXdhaXQgbmRrLmNhY2hlQWRhcHRlci5sb2FkTmlwMDUoZnVsbG5hbWUpO1xuICAgICAgICBpZiAocHJvZmlsZSAhPT0gXCJtaXNzaW5nXCIpIHtcbiAgICAgICAgICBpZiAocHJvZmlsZSkge1xuICAgICAgICAgICAgY29uc3QgdXNlciA9IG5ldyBOREtVc2VyKHtcbiAgICAgICAgICAgICAgcHVia2V5OiBwcm9maWxlLnB1YmtleSxcbiAgICAgICAgICAgICAgcmVsYXlVcmxzOiBwcm9maWxlLnJlbGF5cyxcbiAgICAgICAgICAgICAgbmlwNDZVcmxzOiBwcm9maWxlLm5pcDQ2XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHVzZXIubmRrID0gbmRrO1xuICAgICAgICAgICAgcmV0dXJuIHVzZXI7XG4gICAgICAgICAgfSBlbHNlIGlmIChmZXRjaE9wdHMuY2FjaGUgIT09IFwibm8tY2FjaGVcIikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBtYXRjaCA9IGZ1bGxuYW1lLm1hdGNoKE5JUDA1X1JFR0VYKTtcbiAgICAgIGlmICghbWF0Y2gpIHJldHVybiBudWxsO1xuICAgICAgY29uc3QgW18sIG5hbWUgPSBcIl9cIiwgZG9tYWluXSA9IG1hdGNoO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgX2ZldGNoKFxuICAgICAgICAgIGBodHRwczovLyR7ZG9tYWlufS8ud2VsbC1rbm93bi9ub3N0ci5qc29uP25hbWU9JHtuYW1lfWAsXG4gICAgICAgICAgZmV0Y2hPcHRzXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IHsgbmFtZXMsIHJlbGF5cywgbmlwNDYgfSA9IHBhcnNlTklQMDVSZXN1bHQoYXdhaXQgcmVzLmpzb24oKSk7XG4gICAgICAgIGNvbnN0IHB1YmtleSA9IG5hbWVzW25hbWUudG9Mb3dlckNhc2UoKV07XG4gICAgICAgIGxldCBwcm9maWxlID0gbnVsbDtcbiAgICAgICAgaWYgKHB1YmtleSkge1xuICAgICAgICAgIHByb2ZpbGUgPSB7IHB1YmtleSwgcmVsYXlzOiByZWxheXM/LltwdWJrZXldLCBuaXA0NjogbmlwNDY/LltwdWJrZXldIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5kaz8uY2FjaGVBZGFwdGVyICYmIG5kay5jYWNoZUFkYXB0ZXIuc2F2ZU5pcDA1KSB7XG4gICAgICAgICAgbmRrLmNhY2hlQWRhcHRlci5zYXZlTmlwMDUoZnVsbG5hbWUsIHByb2ZpbGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9maWxlO1xuICAgICAgfSBjYXRjaCAoX2UpIHtcbiAgICAgICAgaWYgKG5kaz8uY2FjaGVBZGFwdGVyICYmIG5kay5jYWNoZUFkYXB0ZXIuc2F2ZU5pcDA1KSB7XG4gICAgICAgICAgbmRrPy5jYWNoZUFkYXB0ZXIuc2F2ZU5pcDA1KGZ1bGxuYW1lLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGZldGNoIE5JUDA1IGZvclwiLCBmdWxsbmFtZSwgX2UpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gcGFyc2VOSVAwNVJlc3VsdChqc29uKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICBuYW1lczoge31cbiAgfTtcbiAgZm9yIChjb25zdCBbbmFtZSwgcHVia2V5XSBvZiBPYmplY3QuZW50cmllcyhqc29uLm5hbWVzKSkge1xuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgcHVia2V5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXN1bHQubmFtZXNbbmFtZS50b0xvd2VyQ2FzZSgpXSA9IHB1YmtleTtcbiAgICB9XG4gIH1cbiAgaWYgKGpzb24ucmVsYXlzKSB7XG4gICAgcmVzdWx0LnJlbGF5cyA9IHt9O1xuICAgIGZvciAoY29uc3QgW3B1YmtleSwgcmVsYXlzXSBvZiBPYmplY3QuZW50cmllcyhqc29uLnJlbGF5cykpIHtcbiAgICAgIGlmICh0eXBlb2YgcHVia2V5ID09PSBcInN0cmluZ1wiICYmIEFycmF5LmlzQXJyYXkocmVsYXlzKSkge1xuICAgICAgICByZXN1bHQucmVsYXlzW3B1YmtleV0gPSByZWxheXMuZmlsdGVyKFxuICAgICAgICAgIChyZWxheSkgPT4gdHlwZW9mIHJlbGF5ID09PSBcInN0cmluZ1wiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChqc29uLm5pcDQ2KSB7XG4gICAgcmVzdWx0Lm5pcDQ2ID0ge307XG4gICAgZm9yIChjb25zdCBbcHVia2V5LCBuaXA0Nl0gb2YgT2JqZWN0LmVudHJpZXMoanNvbi5uaXA0NikpIHtcbiAgICAgIGlmICh0eXBlb2YgcHVia2V5ID09PSBcInN0cmluZ1wiICYmIEFycmF5LmlzQXJyYXkobmlwNDYpKSB7XG4gICAgICAgIHJlc3VsdC5uaXA0NltwdWJrZXldID0gbmlwNDYuZmlsdGVyKChyZWxheSkgPT4gdHlwZW9mIHJlbGF5ID09PSBcInN0cmluZ1wiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gc3JjL3VzZXIvaW5kZXgudHNcbnZhciBOREtVc2VyID0gY2xhc3MgX05ES1VzZXIge1xuICBuZGs7XG4gIHByb2ZpbGU7XG4gIHByb2ZpbGVFdmVudDtcbiAgX25wdWI7XG4gIF9wdWJrZXk7XG4gIHJlbGF5VXJscyA9IFtdO1xuICBuaXA0NlVybHMgPSBbXTtcbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIGlmIChvcHRzLm5wdWIpIHRoaXMuX25wdWIgPSBvcHRzLm5wdWI7XG4gICAgaWYgKG9wdHMuaGV4cHVia2V5KSB0aGlzLl9wdWJrZXkgPSBvcHRzLmhleHB1YmtleTtcbiAgICBpZiAob3B0cy5wdWJrZXkpIHRoaXMuX3B1YmtleSA9IG9wdHMucHVia2V5O1xuICAgIGlmIChvcHRzLnJlbGF5VXJscykgdGhpcy5yZWxheVVybHMgPSBvcHRzLnJlbGF5VXJscztcbiAgICBpZiAob3B0cy5uaXA0NlVybHMpIHRoaXMubmlwNDZVcmxzID0gb3B0cy5uaXA0NlVybHM7XG4gIH1cbiAgZ2V0IG5wdWIoKSB7XG4gICAgaWYgKCF0aGlzLl9ucHViKSB7XG4gICAgICBpZiAoIXRoaXMuX3B1YmtleSkgdGhyb3cgbmV3IEVycm9yKFwicHVia2V5IG5vdCBzZXRcIik7XG4gICAgICB0aGlzLl9ucHViID0gbmlwMTk1Lm5wdWJFbmNvZGUodGhpcy5wdWJrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fbnB1YjtcbiAgfVxuICBnZXQgbnByb2ZpbGUoKSB7XG4gICAgY29uc3QgcmVsYXlzID0gdGhpcy5wcm9maWxlRXZlbnQ/Lm9uUmVsYXlzPy5tYXAoKHIpID0+IHIudXJsKTtcbiAgICByZXR1cm4gbmlwMTk1Lm5wcm9maWxlRW5jb2RlKHtcbiAgICAgIHB1YmtleTogdGhpcy5wdWJrZXksXG4gICAgICByZWxheXNcbiAgICB9KTtcbiAgfVxuICBzZXQgbnB1YihucHViKSB7XG4gICAgdGhpcy5fbnB1YiA9IG5wdWI7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgdXNlcidzIHB1YmtleVxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgdXNlcidzIHB1YmtleVxuICAgKi9cbiAgZ2V0IHB1YmtleSgpIHtcbiAgICBpZiAoIXRoaXMuX3B1YmtleSkge1xuICAgICAgaWYgKCF0aGlzLl9ucHViKSB0aHJvdyBuZXcgRXJyb3IoXCJucHViIG5vdCBzZXRcIik7XG4gICAgICB0aGlzLl9wdWJrZXkgPSBuaXAxOTUuZGVjb2RlKHRoaXMubnB1YikuZGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3B1YmtleTtcbiAgfVxuICAvKipcbiAgICogU2V0IHRoZSB1c2VyJ3MgcHVia2V5XG4gICAqIEBwYXJhbSBwdWJrZXkge3N0cmluZ30gVGhlIHVzZXIncyBwdWJrZXlcbiAgICovXG4gIHNldCBwdWJrZXkocHVia2V5KSB7XG4gICAgdGhpcy5fcHVia2V5ID0gcHVia2V5O1xuICB9XG4gIC8qKlxuICAgKiBFcXVpdmFsZW50IHRvIE5ES0V2ZW50LmZpbHRlcnMoKS5cbiAgICogQHJldHVybnMge05ES0ZpbHRlcn1cbiAgICovXG4gIGZpbHRlcigpIHtcbiAgICByZXR1cm4geyBcIiNwXCI6IFt0aGlzLnB1YmtleV0gfTtcbiAgfVxuICAvKipcbiAgICogR2V0cyBOSVAtNTcgYW5kIE5JUC02MSBpbmZvcm1hdGlvbiB0aGF0IHRoaXMgdXNlciBoYXMgc2lnbmFsZWRcbiAgICpcbiAgICogQHBhcmFtIGdldEFsbCB7Ym9vbGVhbn0gV2hldGhlciB0byBnZXQgYWxsIHphcCBpbmZvIG9yIGp1c3QgdGhlIGZpcnN0IG9uZVxuICAgKi9cbiAgYXN5bmMgZ2V0WmFwSW5mbyh0aW1lb3V0TXMpIHtcbiAgICBpZiAoIXRoaXMubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBOREsgaW5zdGFuY2UgZm91bmRcIik7XG4gICAgY29uc3QgcHJvbWlzZVdpdGhUaW1lb3V0ID0gYXN5bmMgKHByb21pc2UpID0+IHtcbiAgICAgIGlmICghdGltZW91dE1zKSByZXR1cm4gcHJvbWlzZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBQcm9taXNlLnJhY2UoW1xuICAgICAgICAgIHByb21pc2UsXG4gICAgICAgICAgbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4gc2V0VGltZW91dCgoKSA9PiByZWplY3QoKSwgdGltZW91dE1zKSlcbiAgICAgICAgXSk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IFt1c2VyUHJvZmlsZSwgbWludExpc3RFdmVudF0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICBwcm9taXNlV2l0aFRpbWVvdXQodGhpcy5mZXRjaFByb2ZpbGUoKSksXG4gICAgICBwcm9taXNlV2l0aFRpbWVvdXQodGhpcy5uZGsuZmV0Y2hFdmVudCh7IGtpbmRzOiBbMTAwMTkgLyogQ2FzaHVNaW50TGlzdCAqL10sIGF1dGhvcnM6IFt0aGlzLnB1YmtleV0gfSkpXG4gICAgXSk7XG4gICAgY29uc3QgcmVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBpZiAobWludExpc3RFdmVudCkge1xuICAgICAgY29uc3QgbWludExpc3QgPSBOREtDYXNodU1pbnRMaXN0LmZyb20obWludExpc3RFdmVudCk7XG4gICAgICBpZiAobWludExpc3QubWludHMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXMuc2V0KFwibmlwNjFcIiwge1xuICAgICAgICAgIG1pbnRzOiBtaW50TGlzdC5taW50cyxcbiAgICAgICAgICByZWxheXM6IG1pbnRMaXN0LnJlbGF5cyxcbiAgICAgICAgICBwMnBrOiBtaW50TGlzdC5wMnBrXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodXNlclByb2ZpbGUpIHtcbiAgICAgIGNvbnN0IHsgbHVkMDYsIGx1ZDE2IH0gPSB1c2VyUHJvZmlsZTtcbiAgICAgIHJlcy5zZXQoXCJuaXA1N1wiLCB7IGx1ZDA2LCBsdWQxNiB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICAvKipcbiAgICogSW5zdGFudGlhdGUgYW4gTkRLVXNlciBmcm9tIGEgTklQLTA1IHN0cmluZ1xuICAgKiBAcGFyYW0gbmlwMDVJZCB7c3RyaW5nfSBUaGUgdXNlcidzIE5JUC0wNVxuICAgKiBAcGFyYW0gbmRrIHtOREt9IEFuIE5ESyBpbnN0YW5jZVxuICAgKiBAcGFyYW0gc2tpcENhY2hlIHtib29sZWFufSBXaGV0aGVyIHRvIHNraXAgdGhlIGNhY2hlIG9yIG5vdFxuICAgKiBAcmV0dXJucyB7TkRLVXNlciB8IHVuZGVmaW5lZH0gQW4gTkRLVXNlciBpZiBvbmUgaXMgZm91bmQgZm9yIHRoZSBnaXZlbiBOSVAtMDUsIHVuZGVmaW5lZCBvdGhlcndpc2UuXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZnJvbU5pcDA1KG5pcDA1SWQsIG5kaywgc2tpcENhY2hlID0gZmFsc2UpIHtcbiAgICBpZiAoIW5kaykgdGhyb3cgbmV3IEVycm9yKFwiTm8gTkRLIGluc3RhbmNlIGZvdW5kXCIpO1xuICAgIGNvbnN0IG9wdHMgPSB7fTtcbiAgICBpZiAoc2tpcENhY2hlKSBvcHRzLmNhY2hlID0gXCJuby1jYWNoZVwiO1xuICAgIGNvbnN0IHByb2ZpbGUgPSBhd2FpdCBnZXROaXAwNUZvcihuZGssIG5pcDA1SWQsIG5kaz8uaHR0cEZldGNoLCBvcHRzKTtcbiAgICBpZiAocHJvZmlsZSkge1xuICAgICAgY29uc3QgdXNlciA9IG5ldyBfTkRLVXNlcih7XG4gICAgICAgIHB1YmtleTogcHJvZmlsZS5wdWJrZXksXG4gICAgICAgIHJlbGF5VXJsczogcHJvZmlsZS5yZWxheXMsXG4gICAgICAgIG5pcDQ2VXJsczogcHJvZmlsZS5uaXA0NlxuICAgICAgfSk7XG4gICAgICB1c2VyLm5kayA9IG5kaztcbiAgICAgIHJldHVybiB1c2VyO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRmV0Y2ggYSB1c2VyJ3MgcHJvZmlsZVxuICAgKiBAcGFyYW0gb3B0cyB7TkRLU3Vic2NyaXB0aW9uT3B0aW9uc30gQSBzZXQgb2YgTkRLU3Vic2NyaXB0aW9uT3B0aW9uc1xuICAgKiBAcGFyYW0gc3RvcmVQcm9maWxlRXZlbnQge2Jvb2xlYW59IFdoZXRoZXIgdG8gc3RvcmUgdGhlIHByb2ZpbGUgZXZlbnQgb3Igbm90XG4gICAqIEByZXR1cm5zIFVzZXIgUHJvZmlsZVxuICAgKi9cbiAgYXN5bmMgZmV0Y2hQcm9maWxlKG9wdHMsIHN0b3JlUHJvZmlsZUV2ZW50ID0gZmFsc2UpIHtcbiAgICBpZiAoIXRoaXMubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJOREsgbm90IHNldFwiKTtcbiAgICBpZiAoIXRoaXMucHJvZmlsZSkgdGhpcy5wcm9maWxlID0ge307XG4gICAgbGV0IHNldE1ldGFkYXRhRXZlbnQgPSBudWxsO1xuICAgIGlmICh0aGlzLm5kay5jYWNoZUFkYXB0ZXIgJiYgdGhpcy5uZGsuY2FjaGVBZGFwdGVyLmZldGNoUHJvZmlsZSAmJiBvcHRzPy5jYWNoZVVzYWdlICE9PSBcIk9OTFlfUkVMQVlcIiAvKiBPTkxZX1JFTEFZICovKSB7XG4gICAgICBjb25zdCBwcm9maWxlID0gYXdhaXQgdGhpcy5uZGsuY2FjaGVBZGFwdGVyLmZldGNoUHJvZmlsZSh0aGlzLnB1YmtleSk7XG4gICAgICBpZiAocHJvZmlsZSkge1xuICAgICAgICB0aGlzLnByb2ZpbGUgPSBwcm9maWxlO1xuICAgICAgICByZXR1cm4gcHJvZmlsZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFvcHRzICYmIC8vIGlmIG5vIG9wdGlvbnMgaGF2ZSBiZWVuIHNldFxuICAgIHRoaXMubmRrLmNhY2hlQWRhcHRlciAmJiAvLyBhbmQgd2UgaGF2ZSBhIGNhY2hlXG4gICAgdGhpcy5uZGsuY2FjaGVBZGFwdGVyLmxvY2tpbmcpIHtcbiAgICAgIHNldE1ldGFkYXRhRXZlbnQgPSBhd2FpdCB0aGlzLm5kay5mZXRjaEV2ZW50KFxuICAgICAgICB7XG4gICAgICAgICAga2luZHM6IFswXSxcbiAgICAgICAgICBhdXRob3JzOiBbdGhpcy5wdWJrZXldXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBjYWNoZVVzYWdlOiBcIk9OTFlfQ0FDSEVcIiAvKiBPTkxZX0NBQ0hFICovLFxuICAgICAgICAgIGNsb3NlT25Fb3NlOiB0cnVlLFxuICAgICAgICAgIGdyb3VwYWJsZTogZmFsc2VcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIG9wdHMgPSB7XG4gICAgICAgIGNhY2hlVXNhZ2U6IFwiT05MWV9SRUxBWVwiIC8qIE9OTFlfUkVMQVkgKi8sXG4gICAgICAgIGNsb3NlT25Fb3NlOiB0cnVlLFxuICAgICAgICBncm91cGFibGU6IHRydWUsXG4gICAgICAgIGdyb3VwYWJsZURlbGF5OiAyNTBcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICghc2V0TWV0YWRhdGFFdmVudCkge1xuICAgICAgc2V0TWV0YWRhdGFFdmVudCA9IGF3YWl0IHRoaXMubmRrLmZldGNoRXZlbnQoXG4gICAgICAgIHtcbiAgICAgICAgICBraW5kczogWzBdLFxuICAgICAgICAgIGF1dGhvcnM6IFt0aGlzLnB1YmtleV1cbiAgICAgICAgfSxcbiAgICAgICAgb3B0c1xuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKCFzZXRNZXRhZGF0YUV2ZW50KSByZXR1cm4gbnVsbDtcbiAgICB0aGlzLnByb2ZpbGUgPSBwcm9maWxlRnJvbUV2ZW50KHNldE1ldGFkYXRhRXZlbnQpO1xuICAgIGlmIChzdG9yZVByb2ZpbGVFdmVudCkge1xuICAgICAgdGhpcy5wcm9maWxlLnByb2ZpbGVFdmVudCA9IEpTT04uc3RyaW5naWZ5KHNldE1ldGFkYXRhRXZlbnQpO1xuICAgIH1cbiAgICBpZiAodGhpcy5wcm9maWxlICYmIHRoaXMubmRrLmNhY2hlQWRhcHRlciAmJiB0aGlzLm5kay5jYWNoZUFkYXB0ZXIuc2F2ZVByb2ZpbGUpIHtcbiAgICAgIHRoaXMubmRrLmNhY2hlQWRhcHRlci5zYXZlUHJvZmlsZSh0aGlzLnB1YmtleSwgdGhpcy5wcm9maWxlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucHJvZmlsZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIHNldCBvZiB1c2VycyB0aGF0IHRoaXMgdXNlciBmb2xsb3dzLlxuICAgKiBcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGZvbGxvd1NldCBpbnN0ZWFkXG4gICAqL1xuICBmb2xsb3dzID0gZm9sbG93cy5iaW5kKHRoaXMpO1xuICAvKipcbiAgICogUmV0dXJucyBhIHNldCBvZiBwdWJrZXlzIHRoYXQgdGhpcyB1c2VyIGZvbGxvd3MuXG4gICAqIFxuICAgKiBAcGFyYW0gb3B0cyAtIE5ES1N1YnNjcmlwdGlvbk9wdGlvbnNcbiAgICogQHBhcmFtIG91dGJveCAtIGJvb2xlYW5cbiAgICogQHBhcmFtIGtpbmQgLSBudW1iZXJcbiAgICovXG4gIGFzeW5jIGZvbGxvd1NldChvcHRzLCBvdXRib3gsIGtpbmQgPSAzIC8qIENvbnRhY3RzICovKSB7XG4gICAgY29uc3QgZm9sbG93czIgPSBhd2FpdCB0aGlzLmZvbGxvd3Mob3B0cywgb3V0Ym94LCBraW5kKTtcbiAgICByZXR1cm4gbmV3IFNldChBcnJheS5mcm9tKGZvbGxvd3MyKS5tYXAoKGYpID0+IGYucHVia2V5KSk7XG4gIH1cbiAgLyoqIEBkZXByZWNhdGVkIFVzZSByZWZlcmVuY2VUYWdzIGluc3RlYWQuICovXG4gIC8qKlxuICAgKiBHZXQgdGhlIHRhZyB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlZmVyZW5jZSB0aGlzIHVzZXIgaW4gYW4gZXZlbnRcbiAgICogQHJldHVybnMge05ES1RhZ30gYW4gTkRLVGFnXG4gICAqL1xuICB0YWdSZWZlcmVuY2UoKSB7XG4gICAgcmV0dXJuIFtcInBcIiwgdGhpcy5wdWJrZXldO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHRhZ3MgdGhhdCBjYW4gYmUgdXNlZCB0byByZWZlcmVuY2UgdGhpcyB1c2VyIGluIGFuIGV2ZW50XG4gICAqIEByZXR1cm5zIHtOREtUYWdbXX0gYW4gYXJyYXkgb2YgTkRLVGFnXG4gICAqL1xuICByZWZlcmVuY2VUYWdzKG1hcmtlcikge1xuICAgIGNvbnN0IHRhZyA9IFtbXCJwXCIsIHRoaXMucHVia2V5XV07XG4gICAgaWYgKCFtYXJrZXIpIHJldHVybiB0YWc7XG4gICAgdGFnWzBdLnB1c2goXCJcIiwgbWFya2VyKTtcbiAgICByZXR1cm4gdGFnO1xuICB9XG4gIC8qKlxuICAgKiBQdWJsaXNoZXMgdGhlIGN1cnJlbnQgcHJvZmlsZS5cbiAgICovXG4gIGFzeW5jIHB1Ymxpc2goKSB7XG4gICAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTm8gTkRLIGluc3RhbmNlIGZvdW5kXCIpO1xuICAgIGlmICghdGhpcy5wcm9maWxlKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBwcm9maWxlIGF2YWlsYWJsZVwiKTtcbiAgICB0aGlzLm5kay5hc3NlcnRTaWduZXIoKTtcbiAgICBjb25zdCBldmVudCA9IG5ldyBOREtFdmVudCh0aGlzLm5kaywge1xuICAgICAga2luZDogMCxcbiAgICAgIGNvbnRlbnQ6IHNlcmlhbGl6ZVByb2ZpbGUodGhpcy5wcm9maWxlKVxuICAgIH0pO1xuICAgIGF3YWl0IGV2ZW50LnB1Ymxpc2goKTtcbiAgfVxuICAvKipcbiAgICogQWRkIGEgZm9sbG93IHRvIHRoaXMgdXNlcidzIGNvbnRhY3QgbGlzdFxuICAgKlxuICAgKiBAcGFyYW0gbmV3Rm9sbG93IHtOREtVc2VyfSBUaGUgdXNlciB0byBmb2xsb3dcbiAgICogQHBhcmFtIGN1cnJlbnRGb2xsb3dMaXN0IHtTZXQ8TkRLVXNlcj59IFRoZSBjdXJyZW50IGZvbGxvdyBsaXN0XG4gICAqIEBwYXJhbSBraW5kIHtOREtLaW5kfSBUaGUga2luZCB0byB1c2UgZm9yIHRoaXMgY29udGFjdCBsaXN0IChkZWZhdWx0cyB0byBgM2ApXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fSBUcnVlIGlmIHRoZSBmb2xsb3cgd2FzIGFkZGVkLCBmYWxzZSBpZiB0aGUgZm9sbG93IGFscmVhZHkgZXhpc3RzXG4gICAqL1xuICBhc3luYyBmb2xsb3cobmV3Rm9sbG93LCBjdXJyZW50Rm9sbG93TGlzdCwga2luZCA9IDMgLyogQ29udGFjdHMgKi8pIHtcbiAgICBpZiAoIXRoaXMubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBOREsgaW5zdGFuY2UgZm91bmRcIik7XG4gICAgdGhpcy5uZGsuYXNzZXJ0U2lnbmVyKCk7XG4gICAgaWYgKCFjdXJyZW50Rm9sbG93TGlzdCkge1xuICAgICAgY3VycmVudEZvbGxvd0xpc3QgPSBhd2FpdCB0aGlzLmZvbGxvd3Modm9pZCAwLCB2b2lkIDAsIGtpbmQpO1xuICAgIH1cbiAgICBpZiAoY3VycmVudEZvbGxvd0xpc3QuaGFzKG5ld0ZvbGxvdykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY3VycmVudEZvbGxvd0xpc3QuYWRkKG5ld0ZvbGxvdyk7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgTkRLRXZlbnQodGhpcy5uZGssIHsga2luZCB9KTtcbiAgICBmb3IgKGNvbnN0IGZvbGxvdyBvZiBjdXJyZW50Rm9sbG93TGlzdCkge1xuICAgICAgZXZlbnQudGFnKGZvbGxvdyk7XG4gICAgfVxuICAgIGF3YWl0IGV2ZW50LnB1Ymxpc2goKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIGEgZm9sbG93IGZyb20gdGhpcyB1c2VyJ3MgY29udGFjdCBsaXN0XG4gICAqXG4gICAqIEBwYXJhbSB1c2VyIHtOREtVc2VyfSBUaGUgdXNlciB0byB1bmZvbGxvd1xuICAgKiBAcGFyYW0gY3VycmVudEZvbGxvd0xpc3Qge1NldDxOREtVc2VyPn0gVGhlIGN1cnJlbnQgZm9sbG93IGxpc3RcbiAgICogQHBhcmFtIGtpbmQge05ES0tpbmR9IFRoZSBraW5kIHRvIHVzZSBmb3IgdGhpcyBjb250YWN0IGxpc3QgKGRlZmF1bHRzIHRvIGAzYClcbiAgICogQHJldHVybnMgVGhlIHJlbGF5cyB3ZXJlIHRoZSBmb2xsb3cgbGlzdCB3YXMgcHVibGlzaGVkIG9yIGZhbHNlIGlmIHRoZSB1c2VyIHdhc24ndCBmb3VuZFxuICAgKi9cbiAgYXN5bmMgdW5mb2xsb3codXNlciwgY3VycmVudEZvbGxvd0xpc3QsIGtpbmQgPSAzIC8qIENvbnRhY3RzICovKSB7XG4gICAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTm8gTkRLIGluc3RhbmNlIGZvdW5kXCIpO1xuICAgIHRoaXMubmRrLmFzc2VydFNpZ25lcigpO1xuICAgIGlmICghY3VycmVudEZvbGxvd0xpc3QpIHtcbiAgICAgIGN1cnJlbnRGb2xsb3dMaXN0ID0gYXdhaXQgdGhpcy5mb2xsb3dzKHZvaWQgMCwgdm9pZCAwLCBraW5kKTtcbiAgICB9XG4gICAgY29uc3QgbmV3VXNlckZvbGxvd0xpc3QgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGxldCBmb3VuZFVzZXIgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IGZvbGxvdyBvZiBjdXJyZW50Rm9sbG93TGlzdCkge1xuICAgICAgaWYgKGZvbGxvdy5wdWJrZXkgIT09IHVzZXIucHVia2V5KSB7XG4gICAgICAgIG5ld1VzZXJGb2xsb3dMaXN0LmFkZChmb2xsb3cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm91bmRVc2VyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFmb3VuZFVzZXIpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBldmVudCA9IG5ldyBOREtFdmVudCh0aGlzLm5kaywgeyBraW5kIH0pO1xuICAgIGZvciAoY29uc3QgZm9sbG93IG9mIG5ld1VzZXJGb2xsb3dMaXN0KSB7XG4gICAgICBldmVudC50YWcoZm9sbG93KTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IGV2ZW50LnB1Ymxpc2goKTtcbiAgfVxuICAvKipcbiAgICogVmFsaWRhdGUgYSB1c2VyJ3MgTklQLTA1IGlkZW50aWZpZXIgKHVzdWFsbHkgZmV0Y2hlZCBmcm9tIHRoZWlyIGtpbmQ6MCBwcm9maWxlIGRhdGEpXG4gICAqXG4gICAqIEBwYXJhbSBuaXAwNUlkIFRoZSBOSVAtMDUgc3RyaW5nIHRvIHZhbGlkYXRlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4gfCBudWxsPn0gVHJ1ZSBpZiB0aGUgTklQLTA1IGlzIGZvdW5kIGFuZCBtYXRjaGVzIHRoaXMgdXNlcidzIHB1YmtleSxcbiAgICogRmFsc2UgaWYgdGhlIE5JUC0wNSBpcyBmb3VuZCBidXQgZG9lc24ndCBtYXRjaCB0aGlzIHVzZXIncyBwdWJrZXksXG4gICAqIG51bGwgaWYgdGhlIE5JUC0wNSBpc24ndCBmb3VuZCBvbiB0aGUgZG9tYWluIG9yIHdlJ3JlIHVuYWJsZSB0byB2ZXJpZnkgKGJlY2F1c2Ugb2YgbmV0d29yayBpc3N1ZXMsIGV0Yy4pXG4gICAqL1xuICBhc3luYyB2YWxpZGF0ZU5pcDA1KG5pcDA1SWQpIHtcbiAgICBpZiAoIXRoaXMubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBOREsgaW5zdGFuY2UgZm91bmRcIik7XG4gICAgY29uc3QgcHJvZmlsZVBvaW50ZXIgPSBhd2FpdCBnZXROaXAwNUZvcih0aGlzLm5kaywgbmlwMDVJZCk7XG4gICAgaWYgKHByb2ZpbGVQb2ludGVyID09PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gcHJvZmlsZVBvaW50ZXIucHVia2V5ID09PSB0aGlzLnB1YmtleTtcbiAgfVxufTtcblxuLy8gc3JjL3VzZXIvcGluLnRzXG5hc3luYyBmdW5jdGlvbiBwaW5FdmVudCh1c2VyLCBldmVudCwgcGluRXZlbnQyLCBwdWJsaXNoKSB7XG4gIGNvbnN0IGtpbmQgPSAxMDAwMSAvKiBQaW5MaXN0ICovO1xuICBpZiAoIXVzZXIubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBOREsgaW5zdGFuY2UgZm91bmRcIik7XG4gIHVzZXIubmRrLmFzc2VydFNpZ25lcigpO1xuICBpZiAoIXBpbkV2ZW50Mikge1xuICAgIGNvbnN0IGV2ZW50cyA9IGF3YWl0IHVzZXIubmRrLmZldGNoRXZlbnRzKFxuICAgICAgeyBraW5kczogW2tpbmRdLCBhdXRob3JzOiBbdXNlci5wdWJrZXldIH0sXG4gICAgICB7IGNhY2hlVXNhZ2U6IFwiT05MWV9SRUxBWVwiIC8qIE9OTFlfUkVMQVkgKi8gfVxuICAgICk7XG4gICAgaWYgKGV2ZW50cy5zaXplID4gMCkge1xuICAgICAgcGluRXZlbnQyID0gbGlzdHNfZGVmYXVsdC5mcm9tKEFycmF5LmZyb20oZXZlbnRzKVswXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBpbkV2ZW50MiA9IG5ldyBOREtFdmVudCh1c2VyLm5kaywge1xuICAgICAgICBraW5kXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcGluRXZlbnQyLnRhZyhldmVudCk7XG4gIGlmIChwdWJsaXNoKSB7XG4gICAgYXdhaXQgcGluRXZlbnQyLnB1Ymxpc2goKTtcbiAgfVxuICByZXR1cm4gcGluRXZlbnQyO1xufVxuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL2NsYXNzaWZpZWQudHNcbnZhciBOREtDbGFzc2lmaWVkID0gY2xhc3MgX05ES0NsYXNzaWZpZWQgZXh0ZW5kcyBOREtFdmVudCB7XG4gIGNvbnN0cnVjdG9yKG5kaywgcmF3RXZlbnQpIHtcbiAgICBzdXBlcihuZGssIHJhd0V2ZW50KTtcbiAgICB0aGlzLmtpbmQgPz89IDMwNDAyIC8qIENsYXNzaWZpZWQgKi87XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBOREtDbGFzc2lmaWVkIGZyb20gYW4gZXhpc3RpbmcgTkRLRXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSBldmVudCBOREtFdmVudCB0byBjcmVhdGUgdGhlIE5ES0NsYXNzaWZpZWQgZnJvbS5cbiAgICogQHJldHVybnMgTkRLQ2xhc3NpZmllZFxuICAgKi9cbiAgc3RhdGljIGZyb20oZXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtDbGFzc2lmaWVkKGV2ZW50Lm5kaywgZXZlbnQpO1xuICB9XG4gIC8qKlxuICAgKiBHZXR0ZXIgZm9yIHRoZSBjbGFzc2lmaWVkIHRpdGxlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nIHwgdW5kZWZpbmVkfSAtIFRoZSBjbGFzc2lmaWVkIHRpdGxlIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIHVuZGVmaW5lZC5cbiAgICovXG4gIGdldCB0aXRsZSgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcInRpdGxlXCIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXR0ZXIgZm9yIHRoZSBjbGFzc2lmaWVkIHRpdGxlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gdGl0bGUgLSBUaGUgdGl0bGUgdG8gc2V0IGZvciB0aGUgY2xhc3NpZmllZC5cbiAgICovXG4gIHNldCB0aXRsZSh0aXRsZSkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwidGl0bGVcIik7XG4gICAgaWYgKHRpdGxlKSB0aGlzLnRhZ3MucHVzaChbXCJ0aXRsZVwiLCB0aXRsZV0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXR0ZXIgZm9yIHRoZSBjbGFzc2lmaWVkIHN1bW1hcnkuXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmcgfCB1bmRlZmluZWR9IC0gVGhlIGNsYXNzaWZpZWQgc3VtbWFyeSBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSB1bmRlZmluZWQuXG4gICAqL1xuICBnZXQgc3VtbWFyeSgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcInN1bW1hcnlcIik7XG4gIH1cbiAgLyoqXG4gICAqIFNldHRlciBmb3IgdGhlIGNsYXNzaWZpZWQgc3VtbWFyeS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IHN1bW1hcnkgLSBUaGUgc3VtbWFyeSB0byBzZXQgZm9yIHRoZSBjbGFzc2lmaWVkLlxuICAgKi9cbiAgc2V0IHN1bW1hcnkoc3VtbWFyeSkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwic3VtbWFyeVwiKTtcbiAgICBpZiAoc3VtbWFyeSkgdGhpcy50YWdzLnB1c2goW1wic3VtbWFyeVwiLCBzdW1tYXJ5XSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHRlciBmb3IgdGhlIGNsYXNzaWZpZWQncyBwdWJsaWNhdGlvbiB0aW1lc3RhbXAuXG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXIgfCB1bmRlZmluZWR9IC0gVGhlIFVuaXggdGltZXN0YW1wIG9mIHdoZW4gdGhlIGNsYXNzaWZpZWQgd2FzIHB1Ymxpc2hlZCBvciB1bmRlZmluZWQuXG4gICAqL1xuICBnZXQgcHVibGlzaGVkX2F0KCkge1xuICAgIGNvbnN0IHRhZyA9IHRoaXMudGFnVmFsdWUoXCJwdWJsaXNoZWRfYXRcIik7XG4gICAgaWYgKHRhZykge1xuICAgICAgcmV0dXJuIHBhcnNlSW50KHRhZyk7XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgLyoqXG4gICAqIFNldHRlciBmb3IgdGhlIGNsYXNzaWZpZWQncyBwdWJsaWNhdGlvbiB0aW1lc3RhbXAuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgdW5kZWZpbmVkfSB0aW1lc3RhbXAgLSBUaGUgVW5peCB0aW1lc3RhbXAgdG8gc2V0IGZvciB0aGUgY2xhc3NpZmllZCdzIHB1YmxpY2F0aW9uIGRhdGUuXG4gICAqL1xuICBzZXQgcHVibGlzaGVkX2F0KHRpbWVzdGFtcCkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwicHVibGlzaGVkX2F0XCIpO1xuICAgIGlmICh0aW1lc3RhbXAgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wicHVibGlzaGVkX2F0XCIsIHRpbWVzdGFtcC50b1N0cmluZygpXSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBHZXR0ZXIgZm9yIHRoZSBjbGFzc2lmaWVkIGxvY2F0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nIHwgdW5kZWZpbmVkfSAtIFRoZSBjbGFzc2lmaWVkIGxvY2F0aW9uIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIHVuZGVmaW5lZC5cbiAgICovXG4gIGdldCBsb2NhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcImxvY2F0aW9uXCIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXR0ZXIgZm9yIHRoZSBjbGFzc2lmaWVkIGxvY2F0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gbG9jYXRpb24gLSBUaGUgbG9jYXRpb24gdG8gc2V0IGZvciB0aGUgY2xhc3NpZmllZC5cbiAgICovXG4gIHNldCBsb2NhdGlvbihsb2NhdGlvbikge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwibG9jYXRpb25cIik7XG4gICAgaWYgKGxvY2F0aW9uKSB0aGlzLnRhZ3MucHVzaChbXCJsb2NhdGlvblwiLCBsb2NhdGlvbl0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXR0ZXIgZm9yIHRoZSBjbGFzc2lmaWVkIHByaWNlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7TkRLQ2xhc3NpZmllZFByaWNlVGFnIHwgdW5kZWZpbmVkfSAtIFRoZSBjbGFzc2lmaWVkIHByaWNlIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIHVuZGVmaW5lZC5cbiAgICovXG4gIGdldCBwcmljZSgpIHtcbiAgICBjb25zdCBwcmljZVRhZyA9IHRoaXMudGFncy5maW5kKCh0YWcpID0+IHRhZ1swXSA9PT0gXCJwcmljZVwiKTtcbiAgICBpZiAocHJpY2VUYWcpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFtb3VudDogcGFyc2VGbG9hdChwcmljZVRhZ1sxXSksXG4gICAgICAgIGN1cnJlbmN5OiBwcmljZVRhZ1syXSxcbiAgICAgICAgZnJlcXVlbmN5OiBwcmljZVRhZ1szXVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFNldHRlciBmb3IgdGhlIGNsYXNzaWZpZWQgcHJpY2UuXG4gICAqXG4gICAqIEBwYXJhbSBwcmljZSAtIFRoZSBwcmljZSB0byBzZXQgZm9yIHRoZSBjbGFzc2lmaWVkLlxuICAgKi9cbiAgc2V0IHByaWNlKHByaWNlVGFnKSB7XG4gICAgaWYgKHR5cGVvZiBwcmljZVRhZyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcHJpY2VUYWcgPSB7XG4gICAgICAgIGFtb3VudDogcGFyc2VGbG9hdChwcmljZVRhZylcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChwcmljZVRhZz8uYW1vdW50KSB7XG4gICAgICBjb25zdCB0YWcgPSBbXCJwcmljZVwiLCBwcmljZVRhZy5hbW91bnQudG9TdHJpbmcoKV07XG4gICAgICBpZiAocHJpY2VUYWcuY3VycmVuY3kpIHRhZy5wdXNoKHByaWNlVGFnLmN1cnJlbmN5KTtcbiAgICAgIGlmIChwcmljZVRhZy5mcmVxdWVuY3kpIHRhZy5wdXNoKHByaWNlVGFnLmZyZXF1ZW5jeSk7XG4gICAgICB0aGlzLnRhZ3MucHVzaCh0YWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbW92ZVRhZyhcInByaWNlXCIpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGNvbnRlbnQgdGFncyBmb3IgdGhlIGNsYXNzaWZpZWQuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGZpcnN0IGNoZWNrcyBhbmQgc2V0cyB0aGUgcHVibGljYXRpb24gZGF0ZSBpZiBub3QgYXZhaWxhYmxlLFxuICAgKiBhbmQgdGhlbiBnZW5lcmF0ZXMgY29udGVudCB0YWdzIGJhc2VkIG9uIHRoZSBiYXNlIE5ES0V2ZW50IGNsYXNzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Q29udGVudFRhZ30gLSBUaGUgZ2VuZXJhdGVkIGNvbnRlbnQgdGFncy5cbiAgICovXG4gIGFzeW5jIGdlbmVyYXRlVGFncygpIHtcbiAgICBzdXBlci5nZW5lcmF0ZVRhZ3MoKTtcbiAgICBpZiAoIXRoaXMucHVibGlzaGVkX2F0KSB7XG4gICAgICB0aGlzLnB1Ymxpc2hlZF9hdCA9IHRoaXMuY3JlYXRlZF9hdDtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmdlbmVyYXRlVGFncygpO1xuICB9XG59O1xuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL2RyYWZ0cy50c1xudmFyIE5ES0RyYWZ0ID0gY2xhc3MgX05ES0RyYWZ0IGV4dGVuZHMgTkRLRXZlbnQge1xuICBfZXZlbnQ7XG4gIGNvbnN0cnVjdG9yKG5kaywgcmF3RXZlbnQpIHtcbiAgICBzdXBlcihuZGssIHJhd0V2ZW50KTtcbiAgICB0aGlzLmtpbmQgPz89IDMxMjM0IC8qIERyYWZ0ICovO1xuICB9XG4gIHN0YXRpYyBmcm9tKGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLRHJhZnQoZXZlbnQubmRrLCBldmVudCk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgYW4gaWRlbnRpZmllciAoaS5lLiBkLXRhZylcbiAgICovXG4gIHNldCBpZGVudGlmaWVyKGlkKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJkXCIpO1xuICAgIHRoaXMudGFncy5wdXNoKFtcImRcIiwgaWRdKTtcbiAgfVxuICBnZXQgaWRlbnRpZmllcigpIHtcbiAgICByZXR1cm4gdGhpcy5kVGFnO1xuICB9XG4gIC8qKlxuICAgKiBFdmVudCB0aGF0IGlzIHRvIGJlIHNhdmVkLlxuICAgKi9cbiAgc2V0IGV2ZW50KGUpIHtcbiAgICBpZiAoZSBpbnN0YW5jZW9mIE5ES0V2ZW50KSB0aGlzLl9ldmVudCA9IGUucmF3RXZlbnQoKTtcbiAgICBlbHNlIHRoaXMuX2V2ZW50ID0gZTtcbiAgICB0aGlzLnByZXBhcmVFdmVudCgpO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBldmVudC5cbiAgICogQHBhcmFtIHBhcmFtMFxuICAgKiBAcmV0dXJucyBOREtFdmVudCBvZiB0aGUgZHJhZnQgZXZlbnQgb3IgbnVsbCBpZiB0aGUgZHJhZnQgZXZlbnQgaGFzIGJlZW4gZGVsZXRlZCAoZW1wdGllZCkuXG4gICAqL1xuICBhc3luYyBnZXRFdmVudChzaWduZXIpIHtcbiAgICBpZiAodGhpcy5fZXZlbnQpIHJldHVybiBuZXcgTkRLRXZlbnQodGhpcy5uZGssIHRoaXMuX2V2ZW50KTtcbiAgICBzaWduZXIgPz89IHRoaXMubmRrPy5zaWduZXI7XG4gICAgaWYgKCFzaWduZXIpIHRocm93IG5ldyBFcnJvcihcIk5vIHNpZ25lciBhdmFpbGFibGVcIik7XG4gICAgY29uc3QgdXNlciA9IGF3YWl0IHNpZ25lci51c2VyKCk7XG4gICAgaWYgKHRoaXMuY29udGVudCAmJiB0aGlzLmNvbnRlbnQubGVuZ3RoID4gMCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5kZWNyeXB0KHVzZXIsIHNpZ25lcik7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSBKU09OLnBhcnNlKHRoaXMuY29udGVudCk7XG4gICAgICAgIHRoaXMuX2V2ZW50ID0gcGF5bG9hZDtcbiAgICAgICAgcmV0dXJuIG5ldyBOREtFdmVudCh0aGlzLm5kaywgcGF5bG9hZCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBwcmVwYXJlRXZlbnQoKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudCkgdGhyb3cgbmV3IEVycm9yKFwiTm8gZXZlbnQgaGFzIGJlZW4gcHJvdmlkZWRcIik7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJrXCIpO1xuICAgIGlmICh0aGlzLl9ldmVudC5raW5kKSB0aGlzLnRhZ3MucHVzaChbXCJrXCIsIHRoaXMuX2V2ZW50LmtpbmQudG9TdHJpbmcoKV0pO1xuICAgIHRoaXMuY29udGVudCA9IEpTT04uc3RyaW5naWZ5KHRoaXMuX2V2ZW50KTtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGRyYWZ0IGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0gc2lnbmVyOiBPcHRpb25hbCBzaWduZXIgdG8gZW5jcnlwdCB3aXRoXG4gICAqIEBwYXJhbSBwdWJsaXNoOiBXaGV0aGVyIHRvIHB1Ymxpc2gsIG9wdGlvbmFsbHkgc3BlY2lmeWluZyByZWxheVNldCB0byBwdWJsaXNoIHRvXG4gICAqL1xuICBhc3luYyBzYXZlKHtcbiAgICBzaWduZXIsXG4gICAgcHVibGlzaCxcbiAgICByZWxheVNldFxuICB9KSB7XG4gICAgc2lnbmVyID8/PSB0aGlzLm5kaz8uc2lnbmVyO1xuICAgIGlmICghc2lnbmVyKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBzaWduZXIgYXZhaWxhYmxlXCIpO1xuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBzaWduZXIudXNlcigpO1xuICAgIGF3YWl0IHRoaXMuZW5jcnlwdCh1c2VyLCBzaWduZXIpO1xuICAgIGlmIChwdWJsaXNoID09PSBmYWxzZSkgcmV0dXJuO1xuICAgIHJldHVybiB0aGlzLnB1Ymxpc2gocmVsYXlTZXQpO1xuICB9XG59O1xuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL2R2bS9mZWVkYmFjay50c1xudmFyIE5ES0R2bUpvYkZlZWRiYWNrU3RhdHVzID0gLyogQF9fUFVSRV9fICovICgoTkRLRHZtSm9iRmVlZGJhY2tTdGF0dXMyKSA9PiB7XG4gIE5ES0R2bUpvYkZlZWRiYWNrU3RhdHVzMltcIlByb2Nlc3NpbmdcIl0gPSBcInByb2Nlc3NpbmdcIjtcbiAgTkRLRHZtSm9iRmVlZGJhY2tTdGF0dXMyW1wiU3VjY2Vzc1wiXSA9IFwic3VjY2Vzc1wiO1xuICBOREtEdm1Kb2JGZWVkYmFja1N0YXR1czJbXCJTY2hlZHVsZWRcIl0gPSBcInNjaGVkdWxlZFwiO1xuICBOREtEdm1Kb2JGZWVkYmFja1N0YXR1czJbXCJQYXlSZXFcIl0gPSBcInBheW1lbnRfcmVxdWlyZWRcIjtcbiAgcmV0dXJuIE5ES0R2bUpvYkZlZWRiYWNrU3RhdHVzMjtcbn0pKE5ES0R2bUpvYkZlZWRiYWNrU3RhdHVzIHx8IHt9KTtcbnZhciBOREtEVk1Kb2JGZWVkYmFjayA9IGNsYXNzIF9OREtEVk1Kb2JGZWVkYmFjayBleHRlbmRzIE5ES0V2ZW50IHtcbiAgY29uc3RydWN0b3IobmRrLCBldmVudCkge1xuICAgIHN1cGVyKG5kaywgZXZlbnQpO1xuICAgIHRoaXMua2luZCA/Pz0gN2UzIC8qIERWTUpvYkZlZWRiYWNrICovO1xuICB9XG4gIHN0YXRpYyBhc3luYyBmcm9tKGV2ZW50KSB7XG4gICAgY29uc3QgZSA9IG5ldyBfTkRLRFZNSm9iRmVlZGJhY2soZXZlbnQubmRrLCBldmVudC5yYXdFdmVudCgpKTtcbiAgICBpZiAoZS5lbmNyeXB0ZWQpIGF3YWl0IGUuZHZtRGVjcnlwdCgpO1xuICAgIHJldHVybiBlO1xuICB9XG4gIGdldCBzdGF0dXMoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJzdGF0dXNcIik7XG4gIH1cbiAgc2V0IHN0YXR1cyhzdGF0dXMpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInN0YXR1c1wiKTtcbiAgICBpZiAoc3RhdHVzICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcInN0YXR1c1wiLCBzdGF0dXNdKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGVuY3J5cHRlZCgpIHtcbiAgICByZXR1cm4gISF0aGlzLmdldE1hdGNoaW5nVGFncyhcImVuY3J5cHRlZFwiKVswXTtcbiAgfVxuICBhc3luYyBkdm1EZWNyeXB0KCkge1xuICAgIGF3YWl0IHRoaXMuZGVjcnlwdCgpO1xuICAgIGNvbnN0IGRlY3J5cHRlZENvbnRlbnQgPSBKU09OLnBhcnNlKHRoaXMuY29udGVudCk7XG4gICAgdGhpcy50YWdzLnB1c2goLi4uZGVjcnlwdGVkQ29udGVudCk7XG4gIH1cbn07XG5cbi8vIHNyYy9ldmVudHMva2luZHMvZHZtL3JlcXVlc3QudHNcbnZhciBOREtEVk1SZXF1ZXN0ID0gY2xhc3MgX05ES0RWTVJlcXVlc3QgZXh0ZW5kcyBOREtFdmVudCB7XG4gIGNvbnN0cnVjdG9yKG5kaywgZXZlbnQpIHtcbiAgICBzdXBlcihuZGssIGV2ZW50KTtcbiAgfVxuICBzdGF0aWMgZnJvbShldmVudCkge1xuICAgIHJldHVybiBuZXcgX05ES0RWTVJlcXVlc3QoZXZlbnQubmRrLCBldmVudC5yYXdFdmVudCgpKTtcbiAgfVxuICBzZXQgYmlkKG1zYXRBbW91bnQpIHtcbiAgICBpZiAobXNhdEFtb3VudCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnJlbW92ZVRhZyhcImJpZFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wiYmlkXCIsIG1zYXRBbW91bnQudG9TdHJpbmcoKV0pO1xuICAgIH1cbiAgfVxuICBnZXQgYmlkKCkge1xuICAgIGNvbnN0IHYgPSB0aGlzLnRhZ1ZhbHVlKFwiYmlkXCIpO1xuICAgIGlmICh2ID09PSB2b2lkIDApIHJldHVybiB2b2lkIDA7XG4gICAgcmV0dXJuIHBhcnNlSW50KHYpO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGEgbmV3IGlucHV0IHRvIHRoZSBqb2JcbiAgICogQHBhcmFtIGFyZ3MgVGhlIGFyZ3VtZW50cyB0byB0aGUgaW5wdXRcbiAgICovXG4gIGFkZElucHV0KC4uLmFyZ3MpIHtcbiAgICB0aGlzLnRhZ3MucHVzaChbXCJpXCIsIC4uLmFyZ3NdKTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIG5ldyBwYXJhbWV0ZXIgdG8gdGhlIGpvYlxuICAgKi9cbiAgYWRkUGFyYW0oLi4uYXJncykge1xuICAgIHRoaXMudGFncy5wdXNoKFtcInBhcmFtXCIsIC4uLmFyZ3NdKTtcbiAgfVxuICBzZXQgb3V0cHV0KG91dHB1dCkge1xuICAgIGlmIChvdXRwdXQgPT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5yZW1vdmVUYWcoXCJvdXRwdXRcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2Ygb3V0cHV0ID09PSBcInN0cmluZ1wiKSBvdXRwdXQgPSBbb3V0cHV0XTtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcIm91dHB1dFwiLCAuLi5vdXRwdXRdKTtcbiAgICB9XG4gIH1cbiAgZ2V0IG91dHB1dCgpIHtcbiAgICBjb25zdCBvdXRwdXRUYWcgPSB0aGlzLmdldE1hdGNoaW5nVGFncyhcIm91dHB1dFwiKVswXTtcbiAgICByZXR1cm4gb3V0cHV0VGFnID8gb3V0cHV0VGFnLnNsaWNlKDEpIDogdm9pZCAwO1xuICB9XG4gIGdldCBwYXJhbXMoKSB7XG4gICAgY29uc3QgcGFyYW1UYWdzID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJwYXJhbVwiKTtcbiAgICByZXR1cm4gcGFyYW1UYWdzLm1hcCgodCkgPT4gdC5zbGljZSgxKSk7XG4gIH1cbiAgZ2V0UGFyYW0obmFtZSkge1xuICAgIGNvbnN0IHBhcmFtVGFnID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJwYXJhbVwiKS5maW5kKCh0KSA9PiB0WzFdID09PSBuYW1lKTtcbiAgICByZXR1cm4gcGFyYW1UYWcgPyBwYXJhbVRhZ1syXSA6IHZvaWQgMDtcbiAgfVxuICBjcmVhdGVGZWVkYmFjayhzdGF0dXMpIHtcbiAgICBjb25zdCBmZWVkYmFjayA9IG5ldyBOREtEVk1Kb2JGZWVkYmFjayh0aGlzLm5kayk7XG4gICAgZmVlZGJhY2sudGFnKHRoaXMsIFwiam9iXCIpO1xuICAgIGZlZWRiYWNrLnN0YXR1cyA9IHN0YXR1cztcbiAgICByZXR1cm4gZmVlZGJhY2s7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZXMgam9iIGVuY3J5cHRpb24gZm9yIHRoaXMgZXZlbnRcbiAgICogQHBhcmFtIGR2bSBEVk0gdGhhdCB3aWxsIHJlY2VpdmUgdGhlIGV2ZW50XG4gICAqIEBwYXJhbSBzaWduZXIgU2lnbmVyIHRvIHVzZSBmb3IgZW5jcnlwdGlvblxuICAgKi9cbiAgYXN5bmMgZW5jcnlwdGlvbihkdm0sIHNpZ25lcikge1xuICAgIGNvbnN0IGR2bVRhZ3MgPSBbXCJpXCIsIFwicGFyYW1cIiwgXCJvdXRwdXRcIiwgXCJyZWxheXNcIiwgXCJiaWRcIl07XG4gICAgY29uc3QgdGFncyA9IHRoaXMudGFncy5maWx0ZXIoKHQpID0+IGR2bVRhZ3MuaW5jbHVkZXModFswXSkpO1xuICAgIHRoaXMudGFncyA9IHRoaXMudGFncy5maWx0ZXIoKHQpID0+ICFkdm1UYWdzLmluY2x1ZGVzKHRbMF0pKTtcbiAgICB0aGlzLmNvbnRlbnQgPSBKU09OLnN0cmluZ2lmeSh0YWdzKTtcbiAgICB0aGlzLnRhZyhkdm0pO1xuICAgIHRoaXMudGFncy5wdXNoKFtcImVuY3J5cHRlZFwiXSk7XG4gICAgYXdhaXQgdGhpcy5lbmNyeXB0KGR2bSwgc2lnbmVyKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgRFZNIHRoYXQgd2lsbCByZWNlaXZlIHRoZSBldmVudFxuICAgKi9cbiAgc2V0IGR2bShkdm0pIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInBcIik7XG4gICAgaWYgKGR2bSkgdGhpcy50YWcoZHZtKTtcbiAgfVxufTtcblxuLy8gc3JjL2V2ZW50cy9raW5kcy9kdm0vTkRLVHJhbnNjcmlwdGlvbkRWTS50c1xudmFyIE5ES1RyYW5zY3JpcHRpb25EVk0gPSBjbGFzcyBfTkRLVHJhbnNjcmlwdGlvbkRWTSBleHRlbmRzIE5ES0RWTVJlcXVlc3Qge1xuICBjb25zdHJ1Y3RvcihuZGssIGV2ZW50KSB7XG4gICAgc3VwZXIobmRrLCBldmVudCk7XG4gICAgdGhpcy5raW5kID0gNWUzIC8qIERWTVJlcVRleHRFeHRyYWN0aW9uICovO1xuICB9XG4gIHN0YXRpYyBmcm9tKGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLVHJhbnNjcmlwdGlvbkRWTShldmVudC5uZGssIGV2ZW50LnJhd0V2ZW50KCkpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2Ugb2YgdGhlIHRyYW5zY3JpcHRpb25cbiAgICovXG4gIGdldCB1cmwoKSB7XG4gICAgY29uc3QgaW5wdXRUYWdzID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJpXCIpO1xuICAgIGlmIChpbnB1dFRhZ3MubGVuZ3RoICE9PSAxKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gaW5wdXRUYWdzWzBdWzFdO1xuICB9XG4gIC8qKlxuICAgKiBHZXR0ZXIgZm9yIHRoZSB0aXRsZSB0YWdcbiAgICovXG4gIGdldCB0aXRsZSgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcInRpdGxlXCIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXR0ZXIgZm9yIHRoZSB0aXRsZSB0YWdcbiAgICovXG4gIHNldCB0aXRsZSh2YWx1ZSkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwidGl0bGVcIik7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJ0aXRsZVwiLCB2YWx1ZV0pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogR2V0dGVyIGZvciB0aGUgaW1hZ2UgdGFnXG4gICAqL1xuICBnZXQgaW1hZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJpbWFnZVwiKTtcbiAgfVxuICAvKipcbiAgICogU2V0dGVyIGZvciB0aGUgaW1hZ2UgdGFnXG4gICAqL1xuICBzZXQgaW1hZ2UodmFsdWUpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImltYWdlXCIpO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wiaW1hZ2VcIiwgdmFsdWVdKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9ldmVudHMva2luZHMvZHZtL3Jlc3VsdC50c1xudmFyIE5ES0RWTUpvYlJlc3VsdCA9IGNsYXNzIF9OREtEVk1Kb2JSZXN1bHQgZXh0ZW5kcyBOREtFdmVudCB7XG4gIGNvbnN0cnVjdG9yKG5kaywgZXZlbnQpIHtcbiAgICBzdXBlcihuZGssIGV2ZW50KTtcbiAgfVxuICBzdGF0aWMgZnJvbShldmVudCkge1xuICAgIHJldHVybiBuZXcgX05ES0RWTUpvYlJlc3VsdChldmVudC5uZGssIGV2ZW50LnJhd0V2ZW50KCkpO1xuICB9XG4gIHNldEFtb3VudChtc2F0LCBpbnZvaWNlKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJhbW91bnRcIik7XG4gICAgY29uc3QgdGFnID0gW1wiYW1vdW50XCIsIG1zYXQudG9TdHJpbmcoKV07XG4gICAgaWYgKGludm9pY2UpIHRhZy5wdXNoKGludm9pY2UpO1xuICAgIHRoaXMudGFncy5wdXNoKHRhZyk7XG4gIH1cbiAgc2V0IHJlc3VsdChyZXN1bHQpIHtcbiAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIHtcbiAgICAgIHRoaXMuY29udGVudCA9IFwiXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29udGVudCA9IHJlc3VsdDtcbiAgICB9XG4gIH1cbiAgZ2V0IHJlc3VsdCgpIHtcbiAgICBpZiAodGhpcy5jb250ZW50ID09PSBcIlwiKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250ZW50O1xuICB9XG4gIHNldCBzdGF0dXMoc3RhdHVzKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJzdGF0dXNcIik7XG4gICAgaWYgKHN0YXR1cyAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJzdGF0dXNcIiwgc3RhdHVzXSk7XG4gICAgfVxuICB9XG4gIGdldCBzdGF0dXMoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJzdGF0dXNcIik7XG4gIH1cbiAgZ2V0IGpvYlJlcXVlc3RJZCgpIHtcbiAgICBmb3IgKGNvbnN0IGVUYWcgb2YgdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJlXCIpKSB7XG4gICAgICBpZiAoZVRhZ1syXSA9PT0gXCJqb2JcIikgcmV0dXJuIGVUYWdbMV07XG4gICAgfVxuICAgIGlmICh0aGlzLmpvYlJlcXVlc3QpIHJldHVybiB0aGlzLmpvYlJlcXVlc3QuaWQ7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJlXCIpO1xuICB9XG4gIHNldCBqb2JSZXF1ZXN0KGV2ZW50KSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJyZXF1ZXN0XCIpO1xuICAgIGlmIChldmVudCkge1xuICAgICAgdGhpcy5raW5kID0gZXZlbnQua2luZCArIDFlMztcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcInJlcXVlc3RcIiwgSlNPTi5zdHJpbmdpZnkoZXZlbnQucmF3RXZlbnQoKSldKTtcbiAgICAgIHRoaXMudGFnKGV2ZW50KTtcbiAgICB9XG4gIH1cbiAgZ2V0IGpvYlJlcXVlc3QoKSB7XG4gICAgY29uc3QgdGFnID0gdGhpcy50YWdWYWx1ZShcInJlcXVlc3RcIik7XG4gICAgaWYgKHRhZyA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE5ES0V2ZW50KHRoaXMubmRrLCBKU09OLnBhcnNlKHRhZykpO1xuICB9XG59O1xuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL2Nhc2h1L3R4LnRzXG52YXIgTUFSS0VSUyA9IHtcbiAgUkVERUVNRUQ6IFwicmVkZWVtZWRcIixcbiAgQ1JFQVRFRDogXCJjcmVhdGVkXCIsXG4gIERFU1RST1lFRDogXCJkZXN0cm95ZWRcIixcbiAgUkVTRVJWRUQ6IFwicmVzZXJ2ZWRcIlxufTtcbnZhciBOREtDYXNodVdhbGxldFR4ID0gY2xhc3MgX05ES0Nhc2h1V2FsbGV0VHggZXh0ZW5kcyBOREtFdmVudCB7XG4gIHN0YXRpYyBNQVJLRVJTID0gTUFSS0VSUztcbiAgc3RhdGljIGtpbmQgPSA3Mzc2IC8qIENhc2h1V2FsbGV0VHggKi87XG4gIHN0YXRpYyBraW5kcyA9IFs3Mzc2IC8qIENhc2h1V2FsbGV0VHggKi9dO1xuICBjb25zdHJ1Y3RvcihuZGssIGV2ZW50KSB7XG4gICAgc3VwZXIobmRrLCBldmVudCk7XG4gICAgdGhpcy5raW5kID8/PSA3Mzc2IC8qIENhc2h1V2FsbGV0VHggKi87XG4gIH1cbiAgc3RhdGljIGFzeW5jIGZyb20oZXZlbnQpIHtcbiAgICBjb25zdCB3YWxsZXRDaGFuZ2UgPSBuZXcgX05ES0Nhc2h1V2FsbGV0VHgoZXZlbnQubmRrLCBldmVudCk7XG4gICAgY29uc3QgcHJldkNvbnRlbnQgPSB3YWxsZXRDaGFuZ2UuY29udGVudDtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgd2FsbGV0Q2hhbmdlLmRlY3J5cHQoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB3YWxsZXRDaGFuZ2UuY29udGVudCA/Pz0gcHJldkNvbnRlbnQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBjb250ZW50VGFncyA9IEpTT04ucGFyc2Uod2FsbGV0Q2hhbmdlLmNvbnRlbnQpO1xuICAgICAgd2FsbGV0Q2hhbmdlLnRhZ3MgPSBbLi4uY29udGVudFRhZ3MsIC4uLndhbGxldENoYW5nZS50YWdzXTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiB3YWxsZXRDaGFuZ2U7XG4gIH1cbiAgc2V0IGRpcmVjdGlvbihkaXJlY3Rpb24pIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImRpcmVjdGlvblwiKTtcbiAgICBpZiAoZGlyZWN0aW9uKSB0aGlzLnRhZ3MucHVzaChbXCJkaXJlY3Rpb25cIiwgZGlyZWN0aW9uXSk7XG4gIH1cbiAgZ2V0IGRpcmVjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcImRpcmVjdGlvblwiKTtcbiAgfVxuICBzZXQgYW1vdW50KGFtb3VudCkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwiYW1vdW50XCIpO1xuICAgIHRoaXMudGFncy5wdXNoKFtcImFtb3VudFwiLCBhbW91bnQudG9TdHJpbmcoKV0pO1xuICB9XG4gIGdldCBhbW91bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJhbW91bnRcIik7XG4gIH1cbiAgc2V0IGZlZShmZWUpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImZlZVwiKTtcbiAgICB0aGlzLnRhZ3MucHVzaChbXCJmZWVcIiwgZmVlLnRvU3RyaW5nKCldKTtcbiAgfVxuICBnZXQgZmVlKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwiZmVlXCIpO1xuICB9XG4gIHNldCB1bml0KHVuaXQpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInVuaXRcIik7XG4gICAgaWYgKHVuaXQpIHRoaXMudGFncy5wdXNoKFtcInVuaXRcIiwgdW5pdC50b1N0cmluZygpXSk7XG4gIH1cbiAgZ2V0IHVuaXQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJ1bml0XCIpO1xuICB9XG4gIHNldCBkZXNjcmlwdGlvbihkZXNjcmlwdGlvbikge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwiZGVzY3JpcHRpb25cIik7XG4gICAgaWYgKGRlc2NyaXB0aW9uKSB0aGlzLnRhZ3MucHVzaChbXCJkZXNjcmlwdGlvblwiLCBkZXNjcmlwdGlvbi50b1N0cmluZygpXSk7XG4gIH1cbiAgZ2V0IGRlc2NyaXB0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwiZGVzY3JpcHRpb25cIik7XG4gIH1cbiAgc2V0IG1pbnQobWludCkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwibWludFwiKTtcbiAgICBpZiAobWludCkgdGhpcy50YWdzLnB1c2goW1wibWludFwiLCBtaW50LnRvU3RyaW5nKCldKTtcbiAgfVxuICBnZXQgbWludCgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcIm1pbnRcIik7XG4gIH1cbiAgLyoqXG4gICAqIFRhZ3MgdG9rZW5zIHRoYXQgd2VyZSBjcmVhdGVkIGluIHRoaXMgaGlzdG9yeSBldmVudFxuICAgKi9cbiAgc2V0IGRlc3Ryb3llZFRva2VucyhldmVudHMpIHtcbiAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIGV2ZW50cykge1xuICAgICAgdGhpcy50YWdzLnB1c2goZXZlbnQudGFnUmVmZXJlbmNlKE1BUktFUlMuREVTVFJPWUVEKSk7XG4gICAgfVxuICB9XG4gIHNldCBkZXN0cm95ZWRUb2tlbklkcyhpZHMpIHtcbiAgICBmb3IgKGNvbnN0IGlkIG9mIGlkcykge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wiZVwiLCBpZCwgXCJcIiwgTUFSS0VSUy5ERVNUUk9ZRURdKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFRhZ3MgdG9rZW5zIHRoYXQgd2VyZSBjcmVhdGVkIGluIHRoaXMgaGlzdG9yeSBldmVudFxuICAgKi9cbiAgc2V0IGNyZWF0ZWRUb2tlbnMoZXZlbnRzKSB7XG4gICAgZm9yIChjb25zdCBldmVudCBvZiBldmVudHMpIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKGV2ZW50LnRhZ1JlZmVyZW5jZShNQVJLRVJTLkNSRUFURUQpKTtcbiAgICB9XG4gIH1cbiAgc2V0IHJlc2VydmVkVG9rZW5zKGV2ZW50cykge1xuICAgIGZvciAoY29uc3QgZXZlbnQgb2YgZXZlbnRzKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChldmVudC50YWdSZWZlcmVuY2UoTUFSS0VSUy5SRVNFUlZFRCkpO1xuICAgIH1cbiAgfVxuICBhZGRSZWRlZW1lZE51dHphcChldmVudCkge1xuICAgIHRoaXMudGFnKGV2ZW50LCBNQVJLRVJTLlJFREVFTUVEKTtcbiAgfVxuICBhc3luYyB0b05vc3RyRXZlbnQocHVia2V5KSB7XG4gICAgY29uc3QgZW5jcnlwdGVkVGFncyA9IFtdO1xuICAgIGNvbnN0IHVuZW5jcnlwdGVkVGFncyA9IFtdO1xuICAgIGZvciAoY29uc3QgdGFnIG9mIHRoaXMudGFncykge1xuICAgICAgaWYgKCF0aGlzLnNob3VsZEVuY3J5cHRUYWcodGFnKSkge1xuICAgICAgICB1bmVuY3J5cHRlZFRhZ3MucHVzaCh0YWcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5jcnlwdGVkVGFncy5wdXNoKHRhZyk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudGFncyA9IHVuZW5jcnlwdGVkVGFncy5maWx0ZXIoKHQpID0+IHRbMF0gIT09IFwiY2xpZW50XCIpO1xuICAgIHRoaXMuY29udGVudCA9IEpTT04uc3RyaW5naWZ5KGVuY3J5cHRlZFRhZ3MpO1xuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLm5kay5zaWduZXIudXNlcigpO1xuICAgIGF3YWl0IHRoaXMuZW5jcnlwdCh1c2VyLCB2b2lkIDAsIFwibmlwNDRcIik7XG4gICAgcmV0dXJuIHN1cGVyLnRvTm9zdHJFdmVudChwdWJrZXkpO1xuICB9XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoaXMgZW50cnkgaW5jbHVkZXMgYSByZWRlbXB0aW9uIG9mIGEgTnV0emFwXG4gICAqL1xuICBnZXQgaGFzTnV0emFwUmVkZW1wdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJlXCIsIE1BUktFUlMuUkVERUVNRUQpLmxlbmd0aCA+IDA7XG4gIH1cbiAgc2hvdWxkRW5jcnlwdFRhZyh0YWcpIHtcbiAgICBjb25zdCB1bmVuY3J5cHRlZFRhZ05hbWVzID0gW1wiY2xpZW50XCJdO1xuICAgIGlmICh1bmVuY3J5cHRlZFRhZ05hbWVzLmluY2x1ZGVzKHRhZ1swXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRhZ1swXSA9PT0gXCJlXCIgJiYgdGFnWzNdID09PSBNQVJLRVJTLlJFREVFTUVEKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0YWdbMF0gPT09IFwicFwiKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cbi8vIHNyYy9ldmVudHMva2luZHMvTkRLUmVsYXlMaXN0LnRzXG52YXIgUkVBRF9NQVJLRVIgPSBcInJlYWRcIjtcbnZhciBXUklURV9NQVJLRVIgPSBcIndyaXRlXCI7XG52YXIgTkRLUmVsYXlMaXN0ID0gY2xhc3MgX05ES1JlbGF5TGlzdCBleHRlbmRzIE5ES0V2ZW50IHtcbiAgY29uc3RydWN0b3IobmRrLCByYXdFdmVudCkge1xuICAgIHN1cGVyKG5kaywgcmF3RXZlbnQpO1xuICAgIHRoaXMua2luZCA/Pz0gMTAwMDIgLyogUmVsYXlMaXN0ICovO1xuICB9XG4gIHN0YXRpYyBmcm9tKG5ka0V2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLUmVsYXlMaXN0KG5ka0V2ZW50Lm5kaywgbmRrRXZlbnQucmF3RXZlbnQoKSk7XG4gIH1cbiAgZ2V0IHJlYWRSZWxheVVybHMoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFncy5maWx0ZXIoKHRhZykgPT4gdGFnWzBdID09PSBcInJcIiB8fCB0YWdbMF0gPT09IFwicmVsYXlcIikuZmlsdGVyKCh0YWcpID0+ICF0YWdbMl0gfHwgdGFnWzJdICYmIHRhZ1syXSA9PT0gUkVBRF9NQVJLRVIpLm1hcCgodGFnKSA9PiB0cnlOb3JtYWxpemVSZWxheVVybCh0YWdbMV0pKS5maWx0ZXIoKHVybCkgPT4gISF1cmwpO1xuICB9XG4gIHNldCByZWFkUmVsYXlVcmxzKHJlbGF5cykge1xuICAgIGZvciAoY29uc3QgcmVsYXkgb2YgcmVsYXlzKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJyXCIsIHJlbGF5LCBSRUFEX01BUktFUl0pO1xuICAgIH1cbiAgfVxuICBnZXQgd3JpdGVSZWxheVVybHMoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFncy5maWx0ZXIoKHRhZykgPT4gdGFnWzBdID09PSBcInJcIiB8fCB0YWdbMF0gPT09IFwicmVsYXlcIikuZmlsdGVyKCh0YWcpID0+ICF0YWdbMl0gfHwgdGFnWzJdICYmIHRhZ1syXSA9PT0gV1JJVEVfTUFSS0VSKS5tYXAoKHRhZykgPT4gdHJ5Tm9ybWFsaXplUmVsYXlVcmwodGFnWzFdKSkuZmlsdGVyKCh1cmwpID0+ICEhdXJsKTtcbiAgfVxuICBzZXQgd3JpdGVSZWxheVVybHMocmVsYXlzKSB7XG4gICAgZm9yIChjb25zdCByZWxheSBvZiByZWxheXMpIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcInJcIiwgcmVsYXksIFdSSVRFX01BUktFUl0pO1xuICAgIH1cbiAgfVxuICBnZXQgYm90aFJlbGF5VXJscygpIHtcbiAgICByZXR1cm4gdGhpcy50YWdzLmZpbHRlcigodGFnKSA9PiB0YWdbMF0gPT09IFwiclwiIHx8IHRhZ1swXSA9PT0gXCJyZWxheVwiKS5maWx0ZXIoKHRhZykgPT4gIXRhZ1syXSkubWFwKCh0YWcpID0+IHRhZ1sxXSk7XG4gIH1cbiAgc2V0IGJvdGhSZWxheVVybHMocmVsYXlzKSB7XG4gICAgZm9yIChjb25zdCByZWxheSBvZiByZWxheXMpIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcInJcIiwgcmVsYXldKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHJlbGF5cygpIHtcbiAgICByZXR1cm4gdGhpcy50YWdzLmZpbHRlcigodGFnKSA9PiB0YWdbMF0gPT09IFwiclwiIHx8IHRhZ1swXSA9PT0gXCJyZWxheVwiKS5tYXAoKHRhZykgPT4gdGFnWzFdKTtcbiAgfVxuICAvKipcbiAgICogUHJvdmlkZXMgYSByZWxheVNldCBmb3IgdGhlIHJlbGF5cyBpbiB0aGlzIGxpc3QuXG4gICAqL1xuICBnZXQgcmVsYXlTZXQoKSB7XG4gICAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTkRLUmVsYXlMaXN0IGhhcyBubyBOREsgaW5zdGFuY2VcIik7XG4gICAgcmV0dXJuIG5ldyBOREtSZWxheVNldChcbiAgICAgIG5ldyBTZXQodGhpcy5yZWxheXMubWFwKCh1KSA9PiB0aGlzLm5kay5wb29sLmdldFJlbGF5KHUpKSksXG4gICAgICB0aGlzLm5ka1xuICAgICk7XG4gIH1cbn07XG5mdW5jdGlvbiByZWxheUxpc3RGcm9tS2luZDMobmRrLCBjb250YWN0TGlzdCkge1xuICB0cnkge1xuICAgIGNvbnN0IGNvbnRlbnQgPSBKU09OLnBhcnNlKGNvbnRhY3RMaXN0LmNvbnRlbnQpO1xuICAgIGNvbnN0IHJlbGF5TGlzdCA9IG5ldyBOREtSZWxheUxpc3QobmRrKTtcbiAgICBjb25zdCByZWFkUmVsYXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBjb25zdCB3cml0ZVJlbGF5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgZm9yIChsZXQgW2tleSwgY29uZmlnXSBvZiBPYmplY3QuZW50cmllcyhjb250ZW50KSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAga2V5ID0gbm9ybWFsaXplUmVsYXlVcmwoa2V5KTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICghY29uZmlnKSB7XG4gICAgICAgIHJlYWRSZWxheXMuYWRkKGtleSk7XG4gICAgICAgIHdyaXRlUmVsYXlzLmFkZChrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcmVsYXlDb25maWcgPSBjb25maWc7XG4gICAgICAgIGlmIChyZWxheUNvbmZpZy53cml0ZSkgd3JpdGVSZWxheXMuYWRkKGtleSk7XG4gICAgICAgIGlmIChyZWxheUNvbmZpZy5yZWFkKSByZWFkUmVsYXlzLmFkZChrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZWxheUxpc3QucmVhZFJlbGF5VXJscyA9IEFycmF5LmZyb20ocmVhZFJlbGF5cyk7XG4gICAgcmVsYXlMaXN0LndyaXRlUmVsYXlVcmxzID0gQXJyYXkuZnJvbSh3cml0ZVJlbGF5cyk7XG4gICAgcmV0dXJuIHJlbGF5TGlzdDtcbiAgfSBjYXRjaCB7XG4gIH1cbiAgcmV0dXJuIHZvaWQgMDtcbn1cblxuLy8gc3JjL2V2ZW50cy9raW5kcy9uaXA4OS9OREtBcHBIYW5kbGVyLnRzXG52YXIgTkRLQXBwSGFuZGxlckV2ZW50ID0gY2xhc3MgX05ES0FwcEhhbmRsZXJFdmVudCBleHRlbmRzIE5ES0V2ZW50IHtcbiAgcHJvZmlsZTtcbiAgY29uc3RydWN0b3IobmRrLCByYXdFdmVudCkge1xuICAgIHN1cGVyKG5kaywgcmF3RXZlbnQpO1xuICAgIHRoaXMua2luZCA/Pz0gMzE5OTAgLyogQXBwSGFuZGxlciAqLztcbiAgfVxuICBzdGF0aWMgZnJvbShuZGtFdmVudCkge1xuICAgIHJldHVybiBuZXcgX05ES0FwcEhhbmRsZXJFdmVudChuZGtFdmVudC5uZGssIG5ka0V2ZW50LnJhd0V2ZW50KCkpO1xuICB9XG4gIC8qKlxuICAgKiBGZXRjaGVzIGFwcCBoYW5kbGVyIGluZm9ybWF0aW9uXG4gICAqIElmIG5vIGFwcCBpbmZvcm1hdGlvbiBpcyBhdmFpbGFibGUgb24gdGhlIGtpbmQ6MzE5OTAsXG4gICAqIHdlIGZldGNoIHRoZSBldmVudCdzIGF1dGhvcidzIHByb2ZpbGUgYW5kIHJldHVybiB0aGF0IGluc3RlYWQuXG4gICAqL1xuICBhc3luYyBmZXRjaFByb2ZpbGUoKSB7XG4gICAgaWYgKHRoaXMucHJvZmlsZSA9PT0gdm9pZCAwICYmIHRoaXMuY29udGVudC5sZW5ndGggPiAwKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBwcm9maWxlID0gSlNPTi5wYXJzZSh0aGlzLmNvbnRlbnQpO1xuICAgICAgICBpZiAocHJvZmlsZSAmJiBwcm9maWxlLm5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gcHJvZmlsZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnByb2ZpbGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRoaXMucHJvZmlsZSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBhdXRob3IgPSB0aGlzLmF1dGhvcjtcbiAgICAgIGF1dGhvci5mZXRjaFByb2ZpbGUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgcmVzb2x2ZShhdXRob3IucHJvZmlsZSk7XG4gICAgICB9KS5jYXRjaChyZWplY3QpO1xuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL3JlcG9zdC50c1xudmFyIE5ES1JlcG9zdCA9IGNsYXNzIF9OREtSZXBvc3QgZXh0ZW5kcyBOREtFdmVudCB7XG4gIF9yZXBvc3RlZEV2ZW50cztcbiAgY29uc3RydWN0b3IobmRrLCByYXdFdmVudCkge1xuICAgIHN1cGVyKG5kaywgcmF3RXZlbnQpO1xuICB9XG4gIHN0YXRpYyBmcm9tKGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLUmVwb3N0KGV2ZW50Lm5kaywgZXZlbnQucmF3RXZlbnQoKSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIHJlcG9zdGVkIGV2ZW50cyBieSB0aGUgY3VycmVudCBldmVudC5cbiAgICpcbiAgICogQHBhcmFtIGtsYXNzIE9wdGlvbmFsIGNsYXNzIHRvIGNvbnZlcnQgdGhlIGV2ZW50cyB0by5cbiAgICogQHJldHVybnNcbiAgICovXG4gIGFzeW5jIHJlcG9zdGVkRXZlbnRzKGtsYXNzLCBvcHRzKSB7XG4gICAgY29uc3QgaXRlbXMgPSBbXTtcbiAgICBpZiAoIXRoaXMubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJOREsgaW5zdGFuY2Ugbm90IHNldFwiKTtcbiAgICBpZiAodGhpcy5fcmVwb3N0ZWRFdmVudHMgIT09IHZvaWQgMCkgcmV0dXJuIHRoaXMuX3JlcG9zdGVkRXZlbnRzO1xuICAgIGZvciAoY29uc3QgZXZlbnRJZCBvZiB0aGlzLnJlcG9zdGVkRXZlbnRJZHMoKSkge1xuICAgICAgY29uc3QgZmlsdGVyID0gZmlsdGVyRm9ySWQoZXZlbnRJZCk7XG4gICAgICBjb25zdCBldmVudCA9IGF3YWl0IHRoaXMubmRrLmZldGNoRXZlbnQoZmlsdGVyLCBvcHRzKTtcbiAgICAgIGlmIChldmVudCkge1xuICAgICAgICBpdGVtcy5wdXNoKGtsYXNzID8ga2xhc3MuZnJvbShldmVudCkgOiBldmVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpdGVtcztcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVwb3N0ZWQgZXZlbnQgSURzLlxuICAgKi9cbiAgcmVwb3N0ZWRFdmVudElkcygpIHtcbiAgICByZXR1cm4gdGhpcy50YWdzLmZpbHRlcigodCkgPT4gdFswXSA9PT0gXCJlXCIgfHwgdFswXSA9PT0gXCJhXCIpLm1hcCgodCkgPT4gdFsxXSk7XG4gIH1cbn07XG5mdW5jdGlvbiBmaWx0ZXJGb3JJZChpZCkge1xuICBpZiAoaWQubWF0Y2goLzovKSkge1xuICAgIGNvbnN0IFtraW5kLCBwdWJrZXksIGlkZW50aWZpZXJdID0gaWQuc3BsaXQoXCI6XCIpO1xuICAgIHJldHVybiB7XG4gICAgICBraW5kczogW3BhcnNlSW50KGtpbmQpXSxcbiAgICAgIGF1dGhvcnM6IFtwdWJrZXldLFxuICAgICAgXCIjZFwiOiBbaWRlbnRpZmllcl1cbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7IGlkczogW2lkXSB9O1xuICB9XG59XG5cbi8vIHNyYy9ldmVudHMva2luZHMvc3Vic2NyaXB0aW9ucy9yZWNlaXB0LnRzXG5pbXBvcnQgZGVidWczIGZyb20gXCJkZWJ1Z1wiO1xudmFyIE5ES1N1YnNjcmlwdGlvblJlY2VpcHQgPSBjbGFzcyBfTkRLU3Vic2NyaXB0aW9uUmVjZWlwdCBleHRlbmRzIE5ES0V2ZW50IHtcbiAgZGVidWc7XG4gIGNvbnN0cnVjdG9yKG5kaywgcmF3RXZlbnQpIHtcbiAgICBzdXBlcihuZGssIHJhd0V2ZW50KTtcbiAgICB0aGlzLmtpbmQgPz89IDcwMDMgLyogU3Vic2NyaXB0aW9uUmVjZWlwdCAqLztcbiAgICB0aGlzLmRlYnVnID0gbmRrPy5kZWJ1Zy5leHRlbmQoXCJzdWJzY3JpcHRpb24tc3RhcnRcIikgPz8gZGVidWczKFwibmRrOnN1YnNjcmlwdGlvbi1zdGFydFwiKTtcbiAgfVxuICBzdGF0aWMgZnJvbShldmVudCkge1xuICAgIHJldHVybiBuZXcgX05ES1N1YnNjcmlwdGlvblJlY2VpcHQoZXZlbnQubmRrLCBldmVudC5yYXdFdmVudCgpKTtcbiAgfVxuICAvKipcbiAgICogVGhpcyBpcyB0aGUgcGVyc29uIGJlaW5nIHN1YnNjcmliZWQgdG9cbiAgICovXG4gIGdldCByZWNpcGllbnQoKSB7XG4gICAgY29uc3QgcFRhZyA9IHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwicFwiKT8uWzBdO1xuICAgIGlmICghcFRhZykgcmV0dXJuIHZvaWQgMDtcbiAgICBjb25zdCB1c2VyID0gbmV3IE5ES1VzZXIoeyBwdWJrZXk6IHBUYWdbMV0gfSk7XG4gICAgcmV0dXJuIHVzZXI7XG4gIH1cbiAgc2V0IHJlY2lwaWVudCh1c2VyKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJwXCIpO1xuICAgIGlmICghdXNlcikgcmV0dXJuO1xuICAgIHRoaXMudGFncy5wdXNoKFtcInBcIiwgdXNlci5wdWJrZXldKTtcbiAgfVxuICAvKipcbiAgICogVGhpcyBpcyB0aGUgcGVyc29uIHN1YnNjcmliaW5nXG4gICAqL1xuICBnZXQgc3Vic2NyaWJlcigpIHtcbiAgICBjb25zdCBQVGFnID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJQXCIpPy5bMF07XG4gICAgaWYgKCFQVGFnKSByZXR1cm4gdm9pZCAwO1xuICAgIGNvbnN0IHVzZXIgPSBuZXcgTkRLVXNlcih7IHB1YmtleTogUFRhZ1sxXSB9KTtcbiAgICByZXR1cm4gdXNlcjtcbiAgfVxuICBzZXQgc3Vic2NyaWJlcih1c2VyKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJQXCIpO1xuICAgIGlmICghdXNlcikgcmV0dXJuO1xuICAgIHRoaXMudGFncy5wdXNoKFtcIlBcIiwgdXNlci5wdWJrZXldKTtcbiAgfVxuICBzZXQgc3Vic2NyaXB0aW9uU3RhcnQoZXZlbnQpIHtcbiAgICB0aGlzLmRlYnVnKGBiZWZvcmUgc2V0dGluZyBzdWJzY3JpcHRpb24gc3RhcnQ6ICR7dGhpcy5yYXdFdmVudH1gKTtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImVcIik7XG4gICAgdGhpcy50YWcoZXZlbnQsIFwic3Vic2NyaXB0aW9uXCIsIHRydWUpO1xuICAgIHRoaXMuZGVidWcoYGFmdGVyIHNldHRpbmcgc3Vic2NyaXB0aW9uIHN0YXJ0OiAke3RoaXMucmF3RXZlbnR9YCk7XG4gIH1cbiAgZ2V0IHRpZXJOYW1lKCkge1xuICAgIGNvbnN0IHRhZyA9IHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwidGllclwiKT8uWzBdO1xuICAgIHJldHVybiB0YWc/LlsxXTtcbiAgfVxuICBnZXQgaXNWYWxpZCgpIHtcbiAgICBjb25zdCBwZXJpb2QgPSB0aGlzLnZhbGlkUGVyaW9kO1xuICAgIGlmICghcGVyaW9kKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChwZXJpb2Quc3RhcnQgPiBwZXJpb2QuZW5kKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHBUYWdzID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJwXCIpO1xuICAgIGNvbnN0IFBUYWdzID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJQXCIpO1xuICAgIGlmIChwVGFncy5sZW5ndGggIT09IDEgfHwgUFRhZ3MubGVuZ3RoICE9PSAxKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGdldCB2YWxpZFBlcmlvZCgpIHtcbiAgICBjb25zdCB0YWcgPSB0aGlzLmdldE1hdGNoaW5nVGFncyhcInZhbGlkXCIpPy5bMF07XG4gICAgaWYgKCF0YWcpIHJldHVybiB2b2lkIDA7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiBuZXcgRGF0ZShwYXJzZUludCh0YWdbMV0pICogMWUzKSxcbiAgICAgICAgZW5kOiBuZXcgRGF0ZShwYXJzZUludCh0YWdbMl0pICogMWUzKVxuICAgICAgfTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICB9XG4gIHNldCB2YWxpZFBlcmlvZChwZXJpb2QpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInZhbGlkXCIpO1xuICAgIGlmICghcGVyaW9kKSByZXR1cm47XG4gICAgdGhpcy50YWdzLnB1c2goW1xuICAgICAgXCJ2YWxpZFwiLFxuICAgICAgTWF0aC5mbG9vcihwZXJpb2Quc3RhcnQuZ2V0VGltZSgpIC8gMWUzKS50b1N0cmluZygpLFxuICAgICAgTWF0aC5mbG9vcihwZXJpb2QuZW5kLmdldFRpbWUoKSAvIDFlMykudG9TdHJpbmcoKVxuICAgIF0pO1xuICB9XG4gIGdldCBzdGFydFBlcmlvZCgpIHtcbiAgICByZXR1cm4gdGhpcy52YWxpZFBlcmlvZD8uc3RhcnQ7XG4gIH1cbiAgZ2V0IGVuZFBlcmlvZCgpIHtcbiAgICByZXR1cm4gdGhpcy52YWxpZFBlcmlvZD8uZW5kO1xuICB9XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBzdWJzY3JpcHRpb24gaXMgY3VycmVudGx5IGFjdGl2ZVxuICAgKi9cbiAgaXNBY3RpdmUodGltZSkge1xuICAgIHRpbWUgPz89IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgIGNvbnN0IHBlcmlvZCA9IHRoaXMudmFsaWRQZXJpb2Q7XG4gICAgaWYgKCFwZXJpb2QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAodGltZSA8IHBlcmlvZC5zdGFydCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0aW1lID4gcGVyaW9kLmVuZCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL3N1YnNjcmlwdGlvbnMvc3Vic2NyaXB0aW9uLXN0YXJ0LnRzXG5pbXBvcnQgZGVidWc0IGZyb20gXCJkZWJ1Z1wiO1xudmFyIE5ES1N1YnNjcmlwdGlvblN0YXJ0ID0gY2xhc3MgX05ES1N1YnNjcmlwdGlvblN0YXJ0IGV4dGVuZHMgTkRLRXZlbnQge1xuICBkZWJ1ZztcbiAgY29uc3RydWN0b3IobmRrLCByYXdFdmVudCkge1xuICAgIHN1cGVyKG5kaywgcmF3RXZlbnQpO1xuICAgIHRoaXMua2luZCA/Pz0gNzAwMSAvKiBTdWJzY3JpYmUgKi87XG4gICAgdGhpcy5kZWJ1ZyA9IG5kaz8uZGVidWcuZXh0ZW5kKFwic3Vic2NyaXB0aW9uLXN0YXJ0XCIpID8/IGRlYnVnNChcIm5kazpzdWJzY3JpcHRpb24tc3RhcnRcIik7XG4gIH1cbiAgc3RhdGljIGZyb20oZXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtTdWJzY3JpcHRpb25TdGFydChldmVudC5uZGssIGV2ZW50LnJhd0V2ZW50KCkpO1xuICB9XG4gIC8qKlxuICAgKiBSZWNpcGllbnQgb2YgdGhlIHN1YnNjcmlwdGlvbi4gSS5lLiBUaGUgYXV0aG9yIG9mIHRoaXMgZXZlbnQgc3Vic2NyaWJlcyB0byB0aGlzIHVzZXIuXG4gICAqL1xuICBnZXQgcmVjaXBpZW50KCkge1xuICAgIGNvbnN0IHBUYWcgPSB0aGlzLmdldE1hdGNoaW5nVGFncyhcInBcIik/LlswXTtcbiAgICBpZiAoIXBUYWcpIHJldHVybiB2b2lkIDA7XG4gICAgY29uc3QgdXNlciA9IG5ldyBOREtVc2VyKHsgcHVia2V5OiBwVGFnWzFdIH0pO1xuICAgIHJldHVybiB1c2VyO1xuICB9XG4gIHNldCByZWNpcGllbnQodXNlcikge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwicFwiKTtcbiAgICBpZiAoIXVzZXIpIHJldHVybjtcbiAgICB0aGlzLnRhZ3MucHVzaChbXCJwXCIsIHVzZXIucHVia2V5XSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBhbW91bnQgb2YgdGhlIHN1YnNjcmlwdGlvbi5cbiAgICovXG4gIGdldCBhbW91bnQoKSB7XG4gICAgY29uc3QgYW1vdW50VGFnID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJhbW91bnRcIik/LlswXTtcbiAgICBpZiAoIWFtb3VudFRhZykgcmV0dXJuIHZvaWQgMDtcbiAgICByZXR1cm4gcGFyc2VUYWdUb1N1YnNjcmlwdGlvbkFtb3VudChhbW91bnRUYWcpO1xuICB9XG4gIHNldCBhbW91bnQoYW1vdW50KSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJhbW91bnRcIik7XG4gICAgaWYgKCFhbW91bnQpIHJldHVybjtcbiAgICB0aGlzLnRhZ3MucHVzaChuZXdBbW91bnQoYW1vdW50LmFtb3VudCwgYW1vdW50LmN1cnJlbmN5LCBhbW91bnQudGVybSkpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZXZlbnQgaWQgb3IgTklQLTMzIHRhZyBpZCBvZiB0aGUgdGllciB0aGF0IHRoZSB1c2VyIGlzIHN1YnNjcmliaW5nIHRvLlxuICAgKi9cbiAgZ2V0IHRpZXJJZCgpIHtcbiAgICBjb25zdCBlVGFnID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJlXCIpPy5bMF07XG4gICAgY29uc3QgYVRhZyA9IHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwiYVwiKT8uWzBdO1xuICAgIGlmICghZVRhZyB8fCAhYVRhZykgcmV0dXJuIHZvaWQgMDtcbiAgICByZXR1cm4gZVRhZ1sxXSA/PyBhVGFnWzFdO1xuICB9XG4gIHNldCB0aWVyKHRpZXIpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImVcIik7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJhXCIpO1xuICAgIHRoaXMucmVtb3ZlVGFnKFwiZXZlbnRcIik7XG4gICAgaWYgKCF0aWVyKSByZXR1cm47XG4gICAgdGhpcy50YWcodGllcik7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJwXCIpO1xuICAgIHRoaXMudGFncy5wdXNoKFtcInBcIiwgdGllci5wdWJrZXldKTtcbiAgICB0aGlzLnRhZ3MucHVzaChbXCJldmVudFwiLCBKU09OLnN0cmluZ2lmeSh0aWVyLnJhd0V2ZW50KCkpXSk7XG4gIH1cbiAgLyoqXG4gICAqIEZldGNoZXMgdGhlIHRpZXIgdGhhdCB0aGUgdXNlciBpcyBzdWJzY3JpYmluZyB0by5cbiAgICovXG4gIGFzeW5jIGZldGNoVGllcigpIHtcbiAgICBjb25zdCBldmVudFRhZyA9IHRoaXMudGFnVmFsdWUoXCJldmVudFwiKTtcbiAgICBpZiAoZXZlbnRUYWcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZEV2ZW50ID0gSlNPTi5wYXJzZShldmVudFRhZyk7XG4gICAgICAgIHJldHVybiBuZXcgTkRLU3Vic2NyaXB0aW9uVGllcih0aGlzLm5kaywgcGFyc2VkRXZlbnQpO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIHRoaXMuZGVidWcoXCJGYWlsZWQgdG8gcGFyc2UgZXZlbnQgdGFnXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0aWVySWQgPSB0aGlzLnRpZXJJZDtcbiAgICBpZiAoIXRpZXJJZCkgcmV0dXJuIHZvaWQgMDtcbiAgICBjb25zdCBlID0gYXdhaXQgdGhpcy5uZGs/LmZldGNoRXZlbnQodGllcklkKTtcbiAgICBpZiAoIWUpIHJldHVybiB2b2lkIDA7XG4gICAgcmV0dXJuIE5ES1N1YnNjcmlwdGlvblRpZXIuZnJvbShlKTtcbiAgfVxuICBnZXQgaXNWYWxpZCgpIHtcbiAgICBpZiAodGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJhbW91bnRcIikubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aGlzLmRlYnVnKFwiSW52YWxpZCAjIG9mIGFtb3VudCB0YWdcIik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghdGhpcy5hbW91bnQpIHtcbiAgICAgIHRoaXMuZGVidWcoXCJJbnZhbGlkIGFtb3VudCB0YWdcIik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0aGlzLmdldE1hdGNoaW5nVGFncyhcInBcIikubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aGlzLmRlYnVnKFwiSW52YWxpZCAjIG9mIHAgdGFnXCIpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIXRoaXMucmVjaXBpZW50KSB7XG4gICAgICB0aGlzLmRlYnVnKFwiSW52YWxpZCBwIHRhZ1wiKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cbi8vIHNyYy9ldmVudHMva2luZHMvc2ltcGxlLWdyb3VwL2luZGV4LnRzXG52YXIgTkRLU2ltcGxlR3JvdXAgPSBjbGFzcyBfTkRLU2ltcGxlR3JvdXAge1xuICBuZGs7XG4gIGdyb3VwSWQ7XG4gIHJlbGF5U2V0O1xuICBmZXRjaGluZ01ldGFkYXRhO1xuICBtZXRhZGF0YTtcbiAgbWVtYmVyTGlzdDtcbiAgYWRtaW5MaXN0O1xuICBjb25zdHJ1Y3RvcihuZGssIHJlbGF5U2V0LCBncm91cElkKSB7XG4gICAgdGhpcy5uZGsgPSBuZGs7XG4gICAgdGhpcy5ncm91cElkID0gZ3JvdXBJZCA/PyByYW5kb21JZCgyNCk7XG4gICAgdGhpcy5yZWxheVNldCA9IHJlbGF5U2V0O1xuICB9XG4gIGdldCBpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5ncm91cElkO1xuICB9XG4gIHJlbGF5VXJscygpIHtcbiAgICByZXR1cm4gdGhpcy5yZWxheVNldC5yZWxheVVybHM7XG4gIH1cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMubWV0YWRhdGE/Lm5hbWU7XG4gIH1cbiAgZ2V0IGFib3V0KCkge1xuICAgIHJldHVybiB0aGlzLm1ldGFkYXRhPy5hYm91dDtcbiAgfVxuICBnZXQgcGljdHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXRhZGF0YT8ucGljdHVyZTtcbiAgfVxuICBnZXQgbWVtYmVycygpIHtcbiAgICByZXR1cm4gdGhpcy5tZW1iZXJMaXN0Py5tZW1iZXJzID8/IFtdO1xuICB9XG4gIGdldCBhZG1pbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRtaW5MaXN0Py5tZW1iZXJzID8/IFtdO1xuICB9XG4gIGFzeW5jIGdldE1ldGFkYXRhKCkge1xuICAgIGF3YWl0IHRoaXMuZW5zdXJlTWV0YWRhdGFFdmVudCgpO1xuICAgIHJldHVybiB0aGlzLm1ldGFkYXRhO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIHRoZSBncm91cCBieSBwdWJsaXNoaW5nIGEga2luZDo5MDA3IGV2ZW50LlxuICAgKiBAcGFyYW0gc2lnbmVyXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBhc3luYyBjcmVhdGVHcm91cChzaWduZXIpIHtcbiAgICBzaWduZXIgPz89IHRoaXMubmRrLnNpZ25lcjtcbiAgICBpZiAoIXNpZ25lcikgdGhyb3cgbmV3IEVycm9yKFwiTm8gc2lnbmVyIGF2YWlsYWJsZVwiKTtcbiAgICBjb25zdCB1c2VyID0gYXdhaXQgc2lnbmVyLnVzZXIoKTtcbiAgICBpZiAoIXVzZXIpIHRocm93IG5ldyBFcnJvcihcIk5vIHVzZXIgYXZhaWxhYmxlXCIpO1xuICAgIGNvbnN0IGV2ZW50ID0gbmV3IE5ES0V2ZW50KHRoaXMubmRrKTtcbiAgICBldmVudC5raW5kID0gOTAwNyAvKiBHcm91cEFkbWluQ3JlYXRlR3JvdXAgKi87XG4gICAgZXZlbnQudGFncy5wdXNoKFtcImhcIiwgdGhpcy5ncm91cElkXSk7XG4gICAgYXdhaXQgZXZlbnQuc2lnbihzaWduZXIpO1xuICAgIHJldHVybiBldmVudC5wdWJsaXNoKHRoaXMucmVsYXlTZXQpO1xuICB9XG4gIGFzeW5jIHNldE1ldGFkYXRhKHtcbiAgICBuYW1lLFxuICAgIGFib3V0LFxuICAgIHBpY3R1cmVcbiAgfSkge1xuICAgIGNvbnN0IGV2ZW50ID0gbmV3IE5ES0V2ZW50KHRoaXMubmRrKTtcbiAgICBldmVudC5raW5kID0gOTAwMiAvKiBHcm91cEFkbWluRWRpdE1ldGFkYXRhICovO1xuICAgIGV2ZW50LnRhZ3MucHVzaChbXCJoXCIsIHRoaXMuZ3JvdXBJZF0pO1xuICAgIGlmIChuYW1lKSBldmVudC50YWdzLnB1c2goW1wibmFtZVwiLCBuYW1lXSk7XG4gICAgaWYgKGFib3V0KSBldmVudC50YWdzLnB1c2goW1wiYWJvdXRcIiwgYWJvdXRdKTtcbiAgICBpZiAocGljdHVyZSkgZXZlbnQudGFncy5wdXNoKFtcInBpY3R1cmVcIiwgcGljdHVyZV0pO1xuICAgIGF3YWl0IGV2ZW50LnNpZ24oKTtcbiAgICByZXR1cm4gZXZlbnQucHVibGlzaCh0aGlzLnJlbGF5U2V0KTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIHVzZXIgdG8gdGhlIGdyb3VwIHVzaW5nIGEga2luZDo5MDAwIGV2ZW50XG4gICAqIEBwYXJhbSB1c2VyIHVzZXIgdG8gYWRkXG4gICAqIEBwYXJhbSBvcHRzIG9wdGlvbnNcbiAgICovXG4gIGFzeW5jIGFkZFVzZXIodXNlcikge1xuICAgIGNvbnN0IGFkZFVzZXJFdmVudCA9IF9OREtTaW1wbGVHcm91cC5nZW5lcmF0ZUFkZFVzZXJFdmVudCh1c2VyLnB1YmtleSwgdGhpcy5ncm91cElkKTtcbiAgICBhZGRVc2VyRXZlbnQubmRrID0gdGhpcy5uZGs7XG4gICAgcmV0dXJuIGFkZFVzZXJFdmVudDtcbiAgfVxuICBhc3luYyBnZXRNZW1iZXJMaXN0RXZlbnQoKSB7XG4gICAgY29uc3QgbWVtYmVyTGlzdCA9IGF3YWl0IHRoaXMubmRrLmZldGNoRXZlbnQoXG4gICAgICB7XG4gICAgICAgIGtpbmRzOiBbMzkwMDIgLyogR3JvdXBNZW1iZXJzICovXSxcbiAgICAgICAgXCIjZFwiOiBbdGhpcy5ncm91cElkXVxuICAgICAgfSxcbiAgICAgIHZvaWQgMCxcbiAgICAgIHRoaXMucmVsYXlTZXRcbiAgICApO1xuICAgIGlmICghbWVtYmVyTGlzdCkgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIE5ES1NpbXBsZUdyb3VwTWVtYmVyTGlzdC5mcm9tKG1lbWJlckxpc3QpO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIGEgbGlzdCBvZiB1c2VycyB0aGF0IGJlbG9uZyB0byB0aGlzIGdyb3VwXG4gICAqL1xuICBhc3luYyBnZXRNZW1iZXJzKCkge1xuICAgIGNvbnN0IG1lbWJlcnMgPSBbXTtcbiAgICBjb25zdCBtZW1iZXJQdWJrZXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBjb25zdCBtZW1iZXJMaXN0RXZlbnQgPSBhd2FpdCB0aGlzLmdldE1lbWJlckxpc3RFdmVudCgpO1xuICAgIGlmICghbWVtYmVyTGlzdEV2ZW50KSByZXR1cm4gW107XG4gICAgZm9yIChjb25zdCBwVGFnIG9mIG1lbWJlckxpc3RFdmVudC5nZXRNYXRjaGluZ1RhZ3MoXCJwXCIpKSB7XG4gICAgICBjb25zdCBwdWJrZXkgPSBwVGFnWzFdO1xuICAgICAgaWYgKG1lbWJlclB1YmtleXMuaGFzKHB1YmtleSkpIGNvbnRpbnVlO1xuICAgICAgbWVtYmVyUHVia2V5cy5hZGQocHVia2V5KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIG1lbWJlcnMucHVzaCh0aGlzLm5kay5nZXRVc2VyKHsgcHVia2V5IH0pKTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWVtYmVycztcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGFuIGV2ZW50IHRoYXQgbGlzdHMgdGhlIG1lbWJlcnMgb2YgYSBncm91cC5cbiAgICogQHBhcmFtIGdyb3VwSWRcbiAgICogQHJldHVybnNcbiAgICovXG4gIHN0YXRpYyBnZW5lcmF0ZVVzZXJMaXN0RXZlbnQoZ3JvdXBJZCkge1xuICAgIGNvbnN0IGV2ZW50ID0gbmV3IE5ES0V2ZW50KHZvaWQgMCwge1xuICAgICAga2luZDogMzkwMDIgLyogR3JvdXBNZW1iZXJzICovLFxuICAgICAgdGFnczogW1xuICAgICAgICBbXCJoXCIsIGdyb3VwSWRdLFxuICAgICAgICBbXCJhbHRcIiwgXCJHcm91cCBNZW1iZXIgTGlzdFwiXVxuICAgICAgXVxuICAgIH0pO1xuICAgIHJldHVybiBldmVudDtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGFuIGV2ZW50IHRoYXQgYWRkcyBhIHVzZXIgdG8gYSBncm91cC5cbiAgICogQHBhcmFtIHVzZXJQdWJrZXkgcHVia2V5IG9mIHRoZSB1c2VyIHRvIGFkZFxuICAgKiBAcGFyYW0gZ3JvdXBJZCBncm91cCB0byBhZGQgdGhlIHVzZXIgdG9cbiAgICogQHJldHVybnNcbiAgICovXG4gIHN0YXRpYyBnZW5lcmF0ZUFkZFVzZXJFdmVudCh1c2VyUHVia2V5LCBncm91cElkKSB7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgTkRLRXZlbnQodm9pZCAwLCB7XG4gICAgICBraW5kOiA5ZTMgLyogR3JvdXBBZG1pbkFkZFVzZXIgKi8sXG4gICAgICB0YWdzOiBbW1wiaFwiLCBncm91cElkXV1cbiAgICB9KTtcbiAgICBldmVudC50YWdzLnB1c2goW1wicFwiLCB1c2VyUHVia2V5XSk7XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9XG4gIGFzeW5jIHJlcXVlc3RUb0pvaW4ocHVia2V5LCBjb250ZW50KSB7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgTkRLRXZlbnQodGhpcy5uZGssIHtcbiAgICAgIGtpbmQ6IDkwMjEgLyogR3JvdXBBZG1pblJlcXVlc3RKb2luICovLFxuICAgICAgY29udGVudDogY29udGVudCA/PyBcIlwiLFxuICAgICAgdGFnczogW1tcImhcIiwgdGhpcy5ncm91cElkXV1cbiAgICB9KTtcbiAgICByZXR1cm4gZXZlbnQucHVibGlzaCh0aGlzLnJlbGF5U2V0KTtcbiAgfVxuICAvKipcbiAgICogTWFrZXMgc3VyZSB0aGF0IGEgbWV0YWRhdGEgZXZlbnQgZXhpc3RzIGxvY2FsbHlcbiAgICovXG4gIGFzeW5jIGVuc3VyZU1ldGFkYXRhRXZlbnQoKSB7XG4gICAgaWYgKHRoaXMubWV0YWRhdGEpIHJldHVybjtcbiAgICBpZiAodGhpcy5mZXRjaGluZ01ldGFkYXRhKSByZXR1cm4gdGhpcy5mZXRjaGluZ01ldGFkYXRhO1xuICAgIHRoaXMuZmV0Y2hpbmdNZXRhZGF0YSA9IHRoaXMubmRrLmZldGNoRXZlbnQoXG4gICAgICB7XG4gICAgICAgIGtpbmRzOiBbMzllMyAvKiBHcm91cE1ldGFkYXRhICovXSxcbiAgICAgICAgXCIjZFwiOiBbdGhpcy5ncm91cElkXVxuICAgICAgfSxcbiAgICAgIHZvaWQgMCxcbiAgICAgIHRoaXMucmVsYXlTZXRcbiAgICApLnRoZW4oKGV2ZW50KSA9PiB7XG4gICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IE5ES1NpbXBsZUdyb3VwTWV0YWRhdGEuZnJvbShldmVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbmV3IE5ES1NpbXBsZUdyb3VwTWV0YWRhdGEodGhpcy5uZGspO1xuICAgICAgICB0aGlzLm1ldGFkYXRhLmRUYWcgPSB0aGlzLmdyb3VwSWQ7XG4gICAgICB9XG4gICAgfSkuZmluYWxseSgoKSA9PiB7XG4gICAgICB0aGlzLmZldGNoaW5nTWV0YWRhdGEgPSB2b2lkIDA7XG4gICAgfSkuY2F0Y2goKCkgPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGZldGNoIG1ldGFkYXRhIGZvciBncm91cCBcIiArIHRoaXMuZ3JvdXBJZCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hpbmdNZXRhZGF0YTtcbiAgfVxufTtcbmZ1bmN0aW9uIHJhbmRvbUlkKGxlbmd0aCkge1xuICBjb25zdCBjaGFycyA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODlcIjtcbiAgY29uc3QgY2hhcnNMZW5ndGggPSBjaGFycy5sZW5ndGg7XG4gIGxldCByZXN1bHQgPSBcIlwiO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgcmVzdWx0ICs9IGNoYXJzLmNoYXJBdChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjaGFyc0xlbmd0aCkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIHNyYy9hcHAtc2V0dGluZ3MvaW5kZXgudHNcbnZhciBOREtBcHBTZXR0aW5ncyA9IGNsYXNzIF9OREtBcHBTZXR0aW5ncyBleHRlbmRzIE5ES0V2ZW50IHtcbiAgYXBwTmFtZTtcbiAgc2V0dGluZ3MgPSB7fTtcbiAgY29uc3RydWN0b3IobmRrLCByYXdFdmVudCkge1xuICAgIHN1cGVyKG5kaywgcmF3RXZlbnQpO1xuICAgIHRoaXMua2luZCA/Pz0gMzAwNzggLyogQXBwU3BlY2lmaWNEYXRhICovO1xuICAgIHRoaXMuZFRhZyA/Pz0gdGhpcy5hcHBOYW1lO1xuICAgIGlmICh0aGlzLmNvbnRlbnQubGVuZ3RoID4gMCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9IEpTT04ucGFyc2UodGhpcy5jb250ZW50KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBwYXJzaW5nIGFwcCBzZXR0aW5nc1wiLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHN0YXRpYyBmcm9tKGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLQXBwU2V0dGluZ3MoZXZlbnQubmRrLCBldmVudCk7XG4gIH1cbiAgLyoqXG4gICAqIFNldCBhIHZhbHVlIGZvciBhIGdpdmVuIGtleS5cbiAgICpcbiAgICogQHBhcmFtIGtleVxuICAgKiBAcGFyYW0gdmFsdWVcbiAgICovXG4gIHNldChrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5zZXR0aW5nc1trZXldID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhIHZhbHVlIGZvciBhIGdpdmVuIGtleS5cbiAgICpcbiAgICogQHBhcmFtIGtleVxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgZ2V0KGtleSkge1xuICAgIHJldHVybiB0aGlzLnNldHRpbmdzW2tleV07XG4gIH1cbiAgYXN5bmMgcHVibGlzaFJlcGxhY2VhYmxlKHJlbGF5U2V0LCB0aW1lb3V0TXMsIHJlcXVpcmVkUmVsYXlDb3VudCkge1xuICAgIHRoaXMuY29udGVudCA9IEpTT04uc3RyaW5naWZ5KHRoaXMuc2V0dGluZ3MpO1xuICAgIHJldHVybiBzdXBlci5wdWJsaXNoUmVwbGFjZWFibGUocmVsYXlTZXQsIHRpbWVvdXRNcywgcmVxdWlyZWRSZWxheUNvdW50KTtcbiAgfVxufTtcblxuLy8gc3JjL3JlbGF5L2F1dGgtcG9saWNpZXMudHNcbmltcG9ydCBjcmVhdGVEZWJ1ZzIgZnJvbSBcImRlYnVnXCI7XG5mdW5jdGlvbiBkaXNjb25uZWN0KHBvb2wsIGRlYnVnOCkge1xuICBkZWJ1ZzggPz89IGNyZWF0ZURlYnVnMihcIm5kazpyZWxheTphdXRoLXBvbGljaWVzOmRpc2Nvbm5lY3RcIik7XG4gIHJldHVybiBhc3luYyAocmVsYXkpID0+IHtcbiAgICBkZWJ1ZzgoYFJlbGF5ICR7cmVsYXkudXJsfSByZXF1ZXN0ZWQgYXV0aGVudGljYXRpb24sIGRpc2Nvbm5lY3RpbmdgKTtcbiAgICBwb29sLnJlbW92ZVJlbGF5KHJlbGF5LnVybCk7XG4gIH07XG59XG5hc3luYyBmdW5jdGlvbiBzaWduQW5kQXV0aChldmVudCwgcmVsYXksIHNpZ25lciwgZGVidWc4LCByZXNvbHZlLCByZWplY3QpIHtcbiAgdHJ5IHtcbiAgICBhd2FpdCBldmVudC5zaWduKHNpZ25lcik7XG4gICAgcmVzb2x2ZShldmVudCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBkZWJ1ZzgoYEZhaWxlZCB0byBwdWJsaXNoIGF1dGggZXZlbnQgdG8gcmVsYXkgJHtyZWxheS51cmx9YCwgZSk7XG4gICAgcmVqZWN0KGV2ZW50KTtcbiAgfVxufVxuZnVuY3Rpb24gc2lnbkluKHsgbmRrLCBzaWduZXIsIGRlYnVnOiBkZWJ1ZzggfSA9IHt9KSB7XG4gIGRlYnVnOCA/Pz0gY3JlYXRlRGVidWcyKFwibmRrOmF1dGgtcG9saWNpZXM6c2lnbkluXCIpO1xuICByZXR1cm4gYXN5bmMgKHJlbGF5LCBjaGFsbGVuZ2UpID0+IHtcbiAgICBkZWJ1ZzgoYFJlbGF5ICR7cmVsYXkudXJsfSByZXF1ZXN0ZWQgYXV0aGVudGljYXRpb24sIHNpZ25pbmcgaW5gKTtcbiAgICBjb25zdCBldmVudCA9IG5ldyBOREtFdmVudChuZGspO1xuICAgIGV2ZW50LmtpbmQgPSAyMjI0MiAvKiBDbGllbnRBdXRoICovO1xuICAgIGV2ZW50LnRhZ3MgPSBbXG4gICAgICBbXCJyZWxheVwiLCByZWxheS51cmxdLFxuICAgICAgW1wiY2hhbGxlbmdlXCIsIGNoYWxsZW5nZV1cbiAgICBdO1xuICAgIHNpZ25lciA/Pz0gbmRrPy5zaWduZXI7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmIChzaWduZXIpIHtcbiAgICAgICAgYXdhaXQgc2lnbkFuZEF1dGgoZXZlbnQsIHJlbGF5LCBzaWduZXIsIGRlYnVnOCwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5kaz8ub25jZShcInNpZ25lcjpyZWFkeVwiLCBhc3luYyAoc2lnbmVyMikgPT4ge1xuICAgICAgICAgIGF3YWl0IHNpZ25BbmRBdXRoKGV2ZW50LCByZWxheSwgc2lnbmVyMiwgZGVidWc4LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn1cbnZhciBOREtSZWxheUF1dGhQb2xpY2llcyA9IHtcbiAgZGlzY29ubmVjdCxcbiAgc2lnbkluXG59O1xuXG4vLyBzcmMvc2lnbmVycy9uaXAwNy9pbmRleC50c1xuaW1wb3J0IGRlYnVnNSBmcm9tIFwiZGVidWdcIjtcbnZhciBOREtOaXAwN1NpZ25lciA9IGNsYXNzIHtcbiAgX3VzZXJQcm9taXNlO1xuICBlbmNyeXB0aW9uUXVldWUgPSBbXTtcbiAgZW5jcnlwdGlvblByb2Nlc3NpbmcgPSBmYWxzZTtcbiAgZGVidWc7XG4gIHdhaXRUaW1lb3V0O1xuICAvKipcbiAgICogQHBhcmFtIHdhaXRUaW1lb3V0IC0gVGhlIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIHRvIHdhaXQgZm9yIHRoZSBOSVAtMDcgdG8gYmVjb21lIGF2YWlsYWJsZVxuICAgKi9cbiAgY29uc3RydWN0b3Iod2FpdFRpbWVvdXQgPSAxZTMpIHtcbiAgICB0aGlzLmRlYnVnID0gZGVidWc1KFwibmRrOm5pcDA3XCIpO1xuICAgIHRoaXMud2FpdFRpbWVvdXQgPSB3YWl0VGltZW91dDtcbiAgfVxuICBhc3luYyBibG9ja1VudGlsUmVhZHkoKSB7XG4gICAgYXdhaXQgdGhpcy53YWl0Rm9yRXh0ZW5zaW9uKCk7XG4gICAgY29uc3QgcHVia2V5ID0gYXdhaXQgd2luZG93Lm5vc3RyLmdldFB1YmxpY0tleSgpO1xuICAgIGlmICghcHVia2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVc2VyIHJlamVjdGVkIGFjY2Vzc1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBOREtVc2VyKHsgcHVia2V5IH0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXR0ZXIgZm9yIHRoZSB1c2VyIHByb3BlcnR5LlxuICAgKiBAcmV0dXJucyBUaGUgTkRLVXNlciBpbnN0YW5jZS5cbiAgICovXG4gIGFzeW5jIHVzZXIoKSB7XG4gICAgaWYgKCF0aGlzLl91c2VyUHJvbWlzZSkge1xuICAgICAgdGhpcy5fdXNlclByb21pc2UgPSB0aGlzLmJsb2NrVW50aWxSZWFkeSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdXNlclByb21pc2U7XG4gIH1cbiAgLyoqXG4gICAqIFNpZ25zIHRoZSBnaXZlbiBOb3N0ciBldmVudC5cbiAgICogQHBhcmFtIGV2ZW50IC0gVGhlIE5vc3RyIGV2ZW50IHRvIGJlIHNpZ25lZC5cbiAgICogQHJldHVybnMgVGhlIHNpZ25hdHVyZSBvZiB0aGUgc2lnbmVkIGV2ZW50LlxuICAgKiBAdGhyb3dzIEVycm9yIGlmIHRoZSBOSVAtMDcgaXMgbm90IGF2YWlsYWJsZSBvbiB0aGUgd2luZG93IG9iamVjdC5cbiAgICovXG4gIGFzeW5jIHNpZ24oZXZlbnQpIHtcbiAgICBhd2FpdCB0aGlzLndhaXRGb3JFeHRlbnNpb24oKTtcbiAgICBjb25zdCBzaWduZWRFdmVudCA9IGF3YWl0IHdpbmRvdy5ub3N0ci5zaWduRXZlbnQoZXZlbnQpO1xuICAgIHJldHVybiBzaWduZWRFdmVudC5zaWc7XG4gIH1cbiAgYXN5bmMgcmVsYXlzKG5kaykge1xuICAgIGF3YWl0IHRoaXMud2FpdEZvckV4dGVuc2lvbigpO1xuICAgIGNvbnN0IHJlbGF5cyA9IGF3YWl0IHdpbmRvdy5ub3N0ci5nZXRSZWxheXM/LigpIHx8IHt9O1xuICAgIGNvbnN0IGFjdGl2ZVJlbGF5cyA9IFtdO1xuICAgIGZvciAoY29uc3QgdXJsIG9mIE9iamVjdC5rZXlzKHJlbGF5cykpIHtcbiAgICAgIGlmIChyZWxheXNbdXJsXS5yZWFkICYmIHJlbGF5c1t1cmxdLndyaXRlKSB7XG4gICAgICAgIGFjdGl2ZVJlbGF5cy5wdXNoKHVybCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhY3RpdmVSZWxheXMubWFwKCh1cmwpID0+IG5ldyBOREtSZWxheSh1cmwsIG5kaz8ucmVsYXlBdXRoRGVmYXVsdFBvbGljeSwgbmRrKSk7XG4gIH1cbiAgYXN5bmMgZW5jcnlwdGlvbkVuYWJsZWQobmlwKSB7XG4gICAgbGV0IGVuYWJsZWQgPSBbXTtcbiAgICBpZiAoKCFuaXAgfHwgbmlwID09IFwibmlwMDRcIikgJiYgQm9vbGVhbih3aW5kb3cubm9zdHIubmlwMDQpKSBlbmFibGVkLnB1c2goXCJuaXAwNFwiKTtcbiAgICBpZiAoKCFuaXAgfHwgbmlwID09IFwibmlwNDRcIikgJiYgQm9vbGVhbih3aW5kb3cubm9zdHIubmlwNDQpKSBlbmFibGVkLnB1c2goXCJuaXA0NFwiKTtcbiAgICByZXR1cm4gZW5hYmxlZDtcbiAgfVxuICBhc3luYyBlbmNyeXB0KHJlY2lwaWVudCwgdmFsdWUsIG5pcCA9IFwibmlwMDRcIikge1xuICAgIGlmICghYXdhaXQgdGhpcy5lbmNyeXB0aW9uRW5hYmxlZChuaXApKSB0aHJvdyBuZXcgRXJyb3IobmlwICsgXCJlbmNyeXB0aW9uIGlzIG5vdCBhdmFpbGFibGUgZnJvbSB5b3VyIGJyb3dzZXIgZXh0ZW5zaW9uXCIpO1xuICAgIGF3YWl0IHRoaXMud2FpdEZvckV4dGVuc2lvbigpO1xuICAgIGNvbnN0IHJlY2lwaWVudEhleFB1YktleSA9IHJlY2lwaWVudC5wdWJrZXk7XG4gICAgcmV0dXJuIHRoaXMucXVldWVFbmNyeXB0aW9uKG5pcCwgXCJlbmNyeXB0XCIsIHJlY2lwaWVudEhleFB1YktleSwgdmFsdWUpO1xuICB9XG4gIGFzeW5jIGRlY3J5cHQoc2VuZGVyLCB2YWx1ZSwgbmlwID0gXCJuaXAwNFwiKSB7XG4gICAgaWYgKCFhd2FpdCB0aGlzLmVuY3J5cHRpb25FbmFibGVkKG5pcCkpIHRocm93IG5ldyBFcnJvcihuaXAgKyBcImVuY3J5cHRpb24gaXMgbm90IGF2YWlsYWJsZSBmcm9tIHlvdXIgYnJvd3NlciBleHRlbnNpb25cIik7XG4gICAgYXdhaXQgdGhpcy53YWl0Rm9yRXh0ZW5zaW9uKCk7XG4gICAgY29uc3Qgc2VuZGVySGV4UHViS2V5ID0gc2VuZGVyLnB1YmtleTtcbiAgICByZXR1cm4gdGhpcy5xdWV1ZUVuY3J5cHRpb24obmlwLCBcImRlY3J5cHRcIiwgc2VuZGVySGV4UHViS2V5LCB2YWx1ZSk7XG4gIH1cbiAgYXN5bmMgcXVldWVFbmNyeXB0aW9uKHNjaGVtZSwgbWV0aG9kLCBjb3VudGVycGFydHlIZXhwdWJrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuZW5jcnlwdGlvblF1ZXVlLnB1c2goe1xuICAgICAgICBzY2hlbWUsXG4gICAgICAgIG1ldGhvZCxcbiAgICAgICAgY291bnRlcnBhcnR5SGV4cHVia2V5LFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgcmVzb2x2ZSxcbiAgICAgICAgcmVqZWN0XG4gICAgICB9KTtcbiAgICAgIGlmICghdGhpcy5lbmNyeXB0aW9uUHJvY2Vzc2luZykge1xuICAgICAgICB0aGlzLnByb2Nlc3NFbmNyeXB0aW9uUXVldWUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBhc3luYyBwcm9jZXNzRW5jcnlwdGlvblF1ZXVlKGl0ZW0sIHJldHJpZXMgPSAwKSB7XG4gICAgaWYgKCFpdGVtICYmIHRoaXMuZW5jcnlwdGlvblF1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5lbmNyeXB0aW9uUHJvY2Vzc2luZyA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmVuY3J5cHRpb25Qcm9jZXNzaW5nID0gdHJ1ZTtcbiAgICBjb25zdCB7IHNjaGVtZSwgbWV0aG9kLCBjb3VudGVycGFydHlIZXhwdWJrZXksIHZhbHVlLCByZXNvbHZlLCByZWplY3QgfSA9IGl0ZW0gfHwgdGhpcy5lbmNyeXB0aW9uUXVldWUuc2hpZnQoKTtcbiAgICB0aGlzLmRlYnVnKFwiUHJvY2Vzc2luZyBlbmNyeXB0aW9uIHF1ZXVlIGl0ZW1cIiwge1xuICAgICAgbWV0aG9kLFxuICAgICAgY291bnRlcnBhcnR5SGV4cHVia2V5LFxuICAgICAgdmFsdWVcbiAgICB9KTtcbiAgICB0cnkge1xuICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IHdpbmRvdy5ub3N0cltzY2hlbWVdW21ldGhvZF0oY291bnRlcnBhcnR5SGV4cHVia2V5LCB2YWx1ZSk7XG4gICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvci5tZXNzYWdlICYmIGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoXCJjYWxsIGFscmVhZHkgZXhlY3V0aW5nXCIpKSB7XG4gICAgICAgIGlmIChyZXRyaWVzIDwgNSkge1xuICAgICAgICAgIHRoaXMuZGVidWcoXCJSZXRyeWluZyBlbmNyeXB0aW9uIHF1ZXVlIGl0ZW1cIiwge1xuICAgICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgICAgY291bnRlcnBhcnR5SGV4cHVia2V5LFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICByZXRyaWVzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NFbmNyeXB0aW9uUXVldWUoaXRlbSwgcmV0cmllcyArIDEpO1xuICAgICAgICAgIH0sIDUwICogcmV0cmllcyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZWplY3QoZXJyb3IpO1xuICAgIH1cbiAgICB0aGlzLnByb2Nlc3NFbmNyeXB0aW9uUXVldWUoKTtcbiAgfVxuICB3YWl0Rm9yRXh0ZW5zaW9uKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAod2luZG93Lm5vc3RyKSB7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IHRpbWVySWQ7XG4gICAgICBjb25zdCBpbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICBpZiAod2luZG93Lm5vc3RyKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxJZCk7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICB9LCAxMDApO1xuICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsSWQpO1xuICAgICAgICByZWplY3QobmV3IEVycm9yKFwiTklQLTA3IGV4dGVuc2lvbiBub3QgYXZhaWxhYmxlXCIpKTtcbiAgICAgIH0sIHRoaXMud2FpdFRpbWVvdXQpO1xuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvc2lnbmVycy9wcml2YXRlLWtleS9pbmRleC50c1xuaW1wb3J0IHsgZ2VuZXJhdGVTZWNyZXRLZXksIGdldFB1YmxpY0tleSwgZmluYWxpemVFdmVudCwgbmlwMDQsIG5pcDQ0IH0gZnJvbSBcIm5vc3RyLXRvb2xzXCI7XG5pbXBvcnQgeyBieXRlc1RvSGV4IGFzIGJ5dGVzVG9IZXgyLCBoZXhUb0J5dGVzIH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvdXRpbHNcIjtcbmltcG9ydCB7IG5pcDE5IGFzIG5pcDE5NiB9IGZyb20gXCJub3N0ci10b29sc1wiO1xudmFyIE5ES1ByaXZhdGVLZXlTaWduZXIgPSBjbGFzcyBfTkRLUHJpdmF0ZUtleVNpZ25lciB7XG4gIF91c2VyO1xuICBfcHJpdmF0ZUtleTtcbiAgY29uc3RydWN0b3IocHJpdmF0ZUtleSkge1xuICAgIGlmIChwcml2YXRlS2V5KSB7XG4gICAgICBpZiAodHlwZW9mIHByaXZhdGVLZXkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKHByaXZhdGVLZXkuc3RhcnRzV2l0aChcIm5zZWMxXCIpKSB7XG4gICAgICAgICAgY29uc3QgeyB0eXBlLCBkYXRhIH0gPSBuaXAxOTYuZGVjb2RlKHByaXZhdGVLZXkpO1xuICAgICAgICAgIGlmICh0eXBlID09PSBcIm5zZWNcIikgdGhpcy5fcHJpdmF0ZUtleSA9IGRhdGE7XG4gICAgICAgIH0gZWxzZSBpZiAocHJpdmF0ZUtleS5sZW5ndGggPT09IDY0KSB7XG4gICAgICAgICAgdGhpcy5fcHJpdmF0ZUtleSA9IGhleFRvQnl0ZXMocHJpdmF0ZUtleSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwcml2YXRlIGtleSBwcm92aWRlZC5cIik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVLZXkgPSBwcml2YXRlS2V5O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3ByaXZhdGVLZXkpIHtcbiAgICAgICAgdGhpcy5fdXNlciA9IG5ldyBOREtVc2VyKHtcbiAgICAgICAgICBwdWJrZXk6IGdldFB1YmxpY0tleSh0aGlzLl9wcml2YXRlS2V5KVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0IHByaXZhdGVLZXkoKSB7XG4gICAgaWYgKCF0aGlzLl9wcml2YXRlS2V5KSByZXR1cm4gdm9pZCAwO1xuICAgIHJldHVybiBieXRlc1RvSGV4Mih0aGlzLl9wcml2YXRlS2V5KTtcbiAgfVxuICBzdGF0aWMgZ2VuZXJhdGUoKSB7XG4gICAgY29uc3QgcHJpdmF0ZUtleSA9IGdlbmVyYXRlU2VjcmV0S2V5KCk7XG4gICAgcmV0dXJuIG5ldyBfTkRLUHJpdmF0ZUtleVNpZ25lcihwcml2YXRlS2V5KTtcbiAgfVxuICBhc3luYyBibG9ja1VudGlsUmVhZHkoKSB7XG4gICAgaWYgKCF0aGlzLl91c2VyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOREtVc2VyIG5vdCBpbml0aWFsaXplZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3VzZXI7XG4gIH1cbiAgYXN5bmMgdXNlcigpIHtcbiAgICBhd2FpdCB0aGlzLmJsb2NrVW50aWxSZWFkeSgpO1xuICAgIHJldHVybiB0aGlzLl91c2VyO1xuICB9XG4gIGFzeW5jIHNpZ24oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuX3ByaXZhdGVLZXkpIHtcbiAgICAgIHRocm93IEVycm9yKFwiQXR0ZW1wdGVkIHRvIHNpZ24gd2l0aG91dCBhIHByaXZhdGUga2V5XCIpO1xuICAgIH1cbiAgICByZXR1cm4gZmluYWxpemVFdmVudChldmVudCwgdGhpcy5fcHJpdmF0ZUtleSkuc2lnO1xuICB9XG4gIGFzeW5jIGVuY3J5cHRpb25FbmFibGVkKHNjaGVtZSkge1xuICAgIGxldCBlbmFibGVkID0gW107XG4gICAgaWYgKCFzY2hlbWUgfHwgc2NoZW1lID09IFwibmlwMDRcIikgZW5hYmxlZC5wdXNoKFwibmlwMDRcIik7XG4gICAgaWYgKCFzY2hlbWUgfHwgc2NoZW1lID09IFwibmlwNDRcIikgZW5hYmxlZC5wdXNoKFwibmlwNDRcIik7XG4gICAgcmV0dXJuIGVuYWJsZWQ7XG4gIH1cbiAgYXN5bmMgZW5jcnlwdChyZWNpcGllbnQsIHZhbHVlLCBzY2hlbWUpIHtcbiAgICBpZiAoIXRoaXMuX3ByaXZhdGVLZXkgfHwgIXRoaXMucHJpdmF0ZUtleSkge1xuICAgICAgdGhyb3cgRXJyb3IoXCJBdHRlbXB0ZWQgdG8gZW5jcnlwdCB3aXRob3V0IGEgcHJpdmF0ZSBrZXlcIik7XG4gICAgfVxuICAgIGNvbnN0IHJlY2lwaWVudEhleFB1YktleSA9IHJlY2lwaWVudC5wdWJrZXk7XG4gICAgaWYgKHNjaGVtZSA9PSBcIm5pcDQ0XCIpIHtcbiAgICAgIGxldCBjb252ZXJzYXRpb25LZXkgPSBuaXA0NC52Mi51dGlscy5nZXRDb252ZXJzYXRpb25LZXkodGhpcy5fcHJpdmF0ZUtleSwgcmVjaXBpZW50SGV4UHViS2V5KTtcbiAgICAgIHJldHVybiBhd2FpdCBuaXA0NC52Mi5lbmNyeXB0KHZhbHVlLCBjb252ZXJzYXRpb25LZXkpO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgbmlwMDQuZW5jcnlwdCh0aGlzLl9wcml2YXRlS2V5LCByZWNpcGllbnRIZXhQdWJLZXksIHZhbHVlKTtcbiAgfVxuICBhc3luYyBkZWNyeXB0KHNlbmRlciwgdmFsdWUsIHNjaGVtZSkge1xuICAgIGlmICghdGhpcy5fcHJpdmF0ZUtleSB8fCAhdGhpcy5wcml2YXRlS2V5KSB7XG4gICAgICB0aHJvdyBFcnJvcihcIkF0dGVtcHRlZCB0byBkZWNyeXB0IHdpdGhvdXQgYSBwcml2YXRlIGtleVwiKTtcbiAgICB9XG4gICAgY29uc3Qgc2VuZGVySGV4UHViS2V5ID0gc2VuZGVyLnB1YmtleTtcbiAgICBpZiAoc2NoZW1lID09IFwibmlwNDRcIikge1xuICAgICAgbGV0IGNvbnZlcnNhdGlvbktleSA9IG5pcDQ0LnYyLnV0aWxzLmdldENvbnZlcnNhdGlvbktleSh0aGlzLl9wcml2YXRlS2V5LCBzZW5kZXJIZXhQdWJLZXkpO1xuICAgICAgcmV0dXJuIGF3YWl0IG5pcDQ0LnYyLmRlY3J5cHQodmFsdWUsIGNvbnZlcnNhdGlvbktleSk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCBuaXAwNC5kZWNyeXB0KHRoaXMuX3ByaXZhdGVLZXksIHNlbmRlckhleFB1YktleSwgdmFsdWUpO1xuICB9XG59O1xuXG4vLyBzcmMvc2lnbmVycy9uaXA0Ni9ycGMudHNcbmltcG9ydCB7IEV2ZW50RW1pdHRlciBhcyBFdmVudEVtaXR0ZXI1IH0gZnJvbSBcInRzZWVwXCI7XG52YXIgTkRLTm9zdHJScGMgPSBjbGFzcyBleHRlbmRzIEV2ZW50RW1pdHRlcjUge1xuICBuZGs7XG4gIHNpZ25lcjtcbiAgcmVsYXlTZXQ7XG4gIGRlYnVnO1xuICBlbmNyeXB0aW9uVHlwZSA9IFwibmlwMDRcIjtcbiAgcG9vbDtcbiAgY29uc3RydWN0b3IobmRrLCBzaWduZXIsIGRlYnVnOCwgcmVsYXlVcmxzKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm5kayA9IG5kaztcbiAgICB0aGlzLnNpZ25lciA9IHNpZ25lcjtcbiAgICBpZiAocmVsYXlVcmxzKSB7XG4gICAgICB0aGlzLnBvb2wgPSBuZXcgTkRLUG9vbChcbiAgICAgICAgcmVsYXlVcmxzLFxuICAgICAgICBbXSxcbiAgICAgICAgbmRrLFxuICAgICAgICB7XG4gICAgICAgICAgZGVidWc6IGRlYnVnOC5leHRlbmQoXCJycGMtcG9vbFwiKSxcbiAgICAgICAgICBuYW1lOiBcIk5vc3RyIFJQQ1wiXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICB0aGlzLnJlbGF5U2V0ID0gbmV3IE5ES1JlbGF5U2V0KC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksIG5kaywgdGhpcy5wb29sKTtcbiAgICAgIGZvciAoY29uc3QgdXJsIG9mIHJlbGF5VXJscykge1xuICAgICAgICBjb25zdCByZWxheSA9IHRoaXMucG9vbC5nZXRSZWxheSh1cmwsIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgIHJlbGF5LmF1dGhQb2xpY3kgPSBOREtSZWxheUF1dGhQb2xpY2llcy5zaWduSW4oeyBuZGssIHNpZ25lciwgZGVidWc6IGRlYnVnOCB9KTtcbiAgICAgICAgdGhpcy5yZWxheVNldC5hZGRSZWxheShyZWxheSk7XG4gICAgICAgIHJlbGF5LmNvbm5lY3QoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5kZWJ1ZyA9IGRlYnVnOC5leHRlbmQoXCJycGNcIik7XG4gIH1cbiAgLyoqXG4gICAqIFN1YnNjcmliZSB0byBhIGZpbHRlci4gVGhpcyBmdW5jdGlvbiB3aWxsIHJlc29sdmUgb25jZSB0aGUgc3Vic2NyaXB0aW9uIGlzIHJlYWR5LlxuICAgKi9cbiAgc3Vic2NyaWJlKGZpbHRlcikge1xuICAgIGNvbnN0IHN1YiA9IHRoaXMubmRrLnN1YnNjcmliZShcbiAgICAgIGZpbHRlcixcbiAgICAgIHtcbiAgICAgICAgY2xvc2VPbkVvc2U6IGZhbHNlLFxuICAgICAgICBncm91cGFibGU6IGZhbHNlLFxuICAgICAgICBjYWNoZVVzYWdlOiBcIk9OTFlfUkVMQVlcIiAvKiBPTkxZX1JFTEFZICovLFxuICAgICAgICBwb29sOiB0aGlzLnBvb2xcbiAgICAgIH0sXG4gICAgICB0aGlzLnJlbGF5U2V0LFxuICAgICAgZmFsc2VcbiAgICApO1xuICAgIHN1Yi5vbihcImV2ZW50XCIsIGFzeW5jIChldmVudCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcGFyc2VkRXZlbnQgPSBhd2FpdCB0aGlzLnBhcnNlRXZlbnQoZXZlbnQpO1xuICAgICAgICBpZiAocGFyc2VkRXZlbnQubWV0aG9kKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KFwicmVxdWVzdFwiLCBwYXJzZWRFdmVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5lbWl0KGByZXNwb25zZS0ke3BhcnNlZEV2ZW50LmlkfWAsIHBhcnNlZEV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLmRlYnVnKFwiZXJyb3IgcGFyc2luZyBldmVudFwiLCBlLCBldmVudC5yYXdFdmVudCgpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIHN1Yi5vbihcImVvc2VcIiwgKCkgPT4ge1xuICAgICAgICB0aGlzLmRlYnVnKFwiZW9zZWRcIik7XG4gICAgICAgIHJlc29sdmUoc3ViKTtcbiAgICAgIH0pO1xuICAgICAgc3ViLnN0YXJ0KCk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgcGFyc2VFdmVudChldmVudCkge1xuICAgIGlmICh0aGlzLmVuY3J5cHRpb25UeXBlID09PSBcIm5pcDQ0XCIgJiYgZXZlbnQuY29udGVudC5pbmNsdWRlcyhcIj9pdj1cIikpIHtcbiAgICAgIHRoaXMuZW5jcnlwdGlvblR5cGUgPSBcIm5pcDA0XCI7XG4gICAgfSBlbHNlIGlmICh0aGlzLmVuY3J5cHRpb25UeXBlID09PSBcIm5pcDA0XCIgJiYgIWV2ZW50LmNvbnRlbnQuaW5jbHVkZXMoXCI/aXY9XCIpKSB7XG4gICAgICB0aGlzLmVuY3J5cHRpb25UeXBlID0gXCJuaXA0NFwiO1xuICAgIH1cbiAgICBjb25zdCByZW1vdGVVc2VyID0gdGhpcy5uZGsuZ2V0VXNlcih7IHB1YmtleTogZXZlbnQucHVia2V5IH0pO1xuICAgIHJlbW90ZVVzZXIubmRrID0gdGhpcy5uZGs7XG4gICAgbGV0IGRlY3J5cHRlZENvbnRlbnQ7XG4gICAgdHJ5IHtcbiAgICAgIGRlY3J5cHRlZENvbnRlbnQgPSBhd2FpdCB0aGlzLnNpZ25lci5kZWNyeXB0KFxuICAgICAgICByZW1vdGVVc2VyLFxuICAgICAgICBldmVudC5jb250ZW50LFxuICAgICAgICB0aGlzLmVuY3J5cHRpb25UeXBlXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnN0IG90aGVyRW5jcnlwdGlvblR5cGUgPSB0aGlzLmVuY3J5cHRpb25UeXBlID09PSBcIm5pcDA0XCIgPyBcIm5pcDQ0XCIgOiBcIm5pcDA0XCI7XG4gICAgICBkZWNyeXB0ZWRDb250ZW50ID0gYXdhaXQgdGhpcy5zaWduZXIuZGVjcnlwdChyZW1vdGVVc2VyLCBldmVudC5jb250ZW50LCBvdGhlckVuY3J5cHRpb25UeXBlKTtcbiAgICAgIHRoaXMuZW5jcnlwdGlvblR5cGUgPSBvdGhlckVuY3J5cHRpb25UeXBlO1xuICAgIH1cbiAgICBjb25zdCBwYXJzZWRDb250ZW50ID0gSlNPTi5wYXJzZShkZWNyeXB0ZWRDb250ZW50KTtcbiAgICBjb25zdCB7IGlkLCBtZXRob2QsIHBhcmFtcywgcmVzdWx0LCBlcnJvciB9ID0gcGFyc2VkQ29udGVudDtcbiAgICBpZiAobWV0aG9kKSB7XG4gICAgICByZXR1cm4geyBpZCwgcHVia2V5OiBldmVudC5wdWJrZXksIG1ldGhvZCwgcGFyYW1zLCBldmVudCB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4geyBpZCwgcmVzdWx0LCBlcnJvciwgZXZlbnQgfTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgc2VuZFJlc3BvbnNlKGlkLCByZW1vdGVQdWJrZXksIHJlc3VsdCwga2luZCA9IDI0MTMzIC8qIE5vc3RyQ29ubmVjdCAqLywgZXJyb3IpIHtcbiAgICBjb25zdCByZXMgPSB7IGlkLCByZXN1bHQgfTtcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIHJlcy5lcnJvciA9IGVycm9yO1xuICAgIH1cbiAgICBjb25zdCBsb2NhbFVzZXIgPSBhd2FpdCB0aGlzLnNpZ25lci51c2VyKCk7XG4gICAgY29uc3QgcmVtb3RlVXNlciA9IHRoaXMubmRrLmdldFVzZXIoeyBwdWJrZXk6IHJlbW90ZVB1YmtleSB9KTtcbiAgICBjb25zdCBldmVudCA9IG5ldyBOREtFdmVudCh0aGlzLm5kaywge1xuICAgICAga2luZCxcbiAgICAgIGNvbnRlbnQ6IEpTT04uc3RyaW5naWZ5KHJlcyksXG4gICAgICB0YWdzOiBbW1wicFwiLCByZW1vdGVQdWJrZXldXSxcbiAgICAgIHB1YmtleTogbG9jYWxVc2VyLnB1YmtleVxuICAgIH0pO1xuICAgIGV2ZW50LmNvbnRlbnQgPSBhd2FpdCB0aGlzLnNpZ25lci5lbmNyeXB0KHJlbW90ZVVzZXIsIGV2ZW50LmNvbnRlbnQsIHRoaXMuZW5jcnlwdGlvblR5cGUpO1xuICAgIGF3YWl0IGV2ZW50LnNpZ24odGhpcy5zaWduZXIpO1xuICAgIGF3YWl0IGV2ZW50LnB1Ymxpc2godGhpcy5yZWxheVNldCk7XG4gIH1cbiAgLyoqXG4gICAqIFNlbmRzIGEgcmVxdWVzdC5cbiAgICogQHBhcmFtIHJlbW90ZVB1YmtleVxuICAgKiBAcGFyYW0gbWV0aG9kXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIGtpbmRcbiAgICogQHBhcmFtIGlkXG4gICAqL1xuICBhc3luYyBzZW5kUmVxdWVzdChyZW1vdGVQdWJrZXksIG1ldGhvZCwgcGFyYW1zID0gW10sIGtpbmQgPSAyNDEzMywgY2IpIHtcbiAgICBjb25zdCBpZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZyg3KTtcbiAgICBjb25zdCBsb2NhbFVzZXIgPSBhd2FpdCB0aGlzLnNpZ25lci51c2VyKCk7XG4gICAgY29uc3QgcmVtb3RlVXNlciA9IHRoaXMubmRrLmdldFVzZXIoeyBwdWJrZXk6IHJlbW90ZVB1YmtleSB9KTtcbiAgICBjb25zdCByZXF1ZXN0ID0geyBpZCwgbWV0aG9kLCBwYXJhbXMgfTtcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKCkgPT4ge1xuICAgICAgY29uc3QgcmVzcG9uc2VIYW5kbGVyID0gKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgIGlmIChyZXNwb25zZS5yZXN1bHQgPT09IFwiYXV0aF91cmxcIikge1xuICAgICAgICAgIHRoaXMub25jZShgcmVzcG9uc2UtJHtpZH1gLCByZXNwb25zZUhhbmRsZXIpO1xuICAgICAgICAgIHRoaXMuZW1pdChcImF1dGhVcmxcIiwgcmVzcG9uc2UuZXJyb3IpO1xuICAgICAgICB9IGVsc2UgaWYgKGNiKSB7XG4gICAgICAgICAgY2IocmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy5vbmNlKGByZXNwb25zZS0ke2lkfWAsIHJlc3BvbnNlSGFuZGxlcik7XG4gICAgfSk7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgTkRLRXZlbnQodGhpcy5uZGssIHtcbiAgICAgIGtpbmQsXG4gICAgICBjb250ZW50OiBKU09OLnN0cmluZ2lmeShyZXF1ZXN0KSxcbiAgICAgIHRhZ3M6IFtbXCJwXCIsIHJlbW90ZVB1YmtleV1dLFxuICAgICAgcHVia2V5OiBsb2NhbFVzZXIucHVia2V5XG4gICAgfSk7XG4gICAgZXZlbnQuY29udGVudCA9IGF3YWl0IHRoaXMuc2lnbmVyLmVuY3J5cHQocmVtb3RlVXNlciwgZXZlbnQuY29udGVudCwgdGhpcy5lbmNyeXB0aW9uVHlwZSk7XG4gICAgYXdhaXQgZXZlbnQuc2lnbih0aGlzLnNpZ25lcik7XG4gICAgYXdhaXQgZXZlbnQucHVibGlzaCh0aGlzLnJlbGF5U2V0KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxufTtcblxuLy8gc3JjL3NpZ25lcnMvbmlwNDYvYmFja2VuZC9waW5nLnRzXG52YXIgUGluZ0V2ZW50SGFuZGxpbmdTdHJhdGVneSA9IGNsYXNzIHtcbiAgYXN5bmMgaGFuZGxlKGJhY2tlbmQsIGlkLCByZW1vdGVQdWJrZXksIHBhcmFtcykge1xuICAgIGNvbnN0IGRlYnVnOCA9IGJhY2tlbmQuZGVidWcuZXh0ZW5kKFwicGluZ1wiKTtcbiAgICBkZWJ1ZzgoYHBpbmcgcmVxdWVzdCBmcm9tICR7cmVtb3RlUHVia2V5fWApO1xuICAgIGlmIChhd2FpdCBiYWNrZW5kLnB1YmtleUFsbG93ZWQoeyBpZCwgcHVia2V5OiByZW1vdGVQdWJrZXksIG1ldGhvZDogXCJwaW5nXCIgfSkpIHtcbiAgICAgIGRlYnVnOChgY29ubmVjdGlvbiByZXF1ZXN0IGZyb20gJHtyZW1vdGVQdWJrZXl9IGFsbG93ZWRgKTtcbiAgICAgIHJldHVybiBcInBvbmdcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWc4KGBjb25uZWN0aW9uIHJlcXVlc3QgZnJvbSAke3JlbW90ZVB1YmtleX0gcmVqZWN0ZWRgKTtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxufTtcblxuLy8gc3JjL3NpZ25lcnMvbmlwNDYvYmFja2VuZC9jb25uZWN0LnRzXG52YXIgQ29ubmVjdEV2ZW50SGFuZGxpbmdTdHJhdGVneSA9IGNsYXNzIHtcbiAgYXN5bmMgaGFuZGxlKGJhY2tlbmQsIGlkLCByZW1vdGVQdWJrZXksIHBhcmFtcykge1xuICAgIGNvbnN0IFtfLCB0b2tlbl0gPSBwYXJhbXM7XG4gICAgY29uc3QgZGVidWc4ID0gYmFja2VuZC5kZWJ1Zy5leHRlbmQoXCJjb25uZWN0XCIpO1xuICAgIGRlYnVnOChgY29ubmVjdGlvbiByZXF1ZXN0IGZyb20gJHtyZW1vdGVQdWJrZXl9YCk7XG4gICAgaWYgKHRva2VuICYmIGJhY2tlbmQuYXBwbHlUb2tlbikge1xuICAgICAgZGVidWc4KGBhcHBseWluZyB0b2tlbmApO1xuICAgICAgYXdhaXQgYmFja2VuZC5hcHBseVRva2VuKHJlbW90ZVB1YmtleSwgdG9rZW4pO1xuICAgIH1cbiAgICBpZiAoYXdhaXQgYmFja2VuZC5wdWJrZXlBbGxvd2VkKHtcbiAgICAgIGlkLFxuICAgICAgcHVia2V5OiByZW1vdGVQdWJrZXksXG4gICAgICBtZXRob2Q6IFwiY29ubmVjdFwiLFxuICAgICAgcGFyYW1zOiB0b2tlblxuICAgIH0pKSB7XG4gICAgICBkZWJ1ZzgoYGNvbm5lY3Rpb24gcmVxdWVzdCBmcm9tICR7cmVtb3RlUHVia2V5fSBhbGxvd2VkYCk7XG4gICAgICByZXR1cm4gXCJhY2tcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWc4KGBjb25uZWN0aW9uIHJlcXVlc3QgZnJvbSAke3JlbW90ZVB1YmtleX0gcmVqZWN0ZWRgKTtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxufTtcblxuLy8gc3JjL3NpZ25lcnMvbmlwNDYvYmFja2VuZC9nZXQtcHVibGljLWtleS50c1xudmFyIEdldFB1YmxpY0tleUhhbmRsaW5nU3RyYXRlZ3kgPSBjbGFzcyB7XG4gIGFzeW5jIGhhbmRsZShiYWNrZW5kLCBpZCwgcmVtb3RlUHVia2V5LCBwYXJhbXMpIHtcbiAgICByZXR1cm4gYmFja2VuZC5sb2NhbFVzZXI/LnB1YmtleTtcbiAgfVxufTtcblxuLy8gc3JjL3NpZ25lcnMvbmlwNDYvYmFja2VuZC9uaXAwNC1kZWNyeXB0LnRzXG52YXIgTmlwMDREZWNyeXB0SGFuZGxpbmdTdHJhdGVneSA9IGNsYXNzIHtcbiAgYXN5bmMgaGFuZGxlKGJhY2tlbmQsIGlkLCByZW1vdGVQdWJrZXksIHBhcmFtcykge1xuICAgIGNvbnN0IFtzZW5kZXJQdWJrZXksIHBheWxvYWRdID0gcGFyYW1zO1xuICAgIGNvbnN0IHNlbmRlclVzZXIgPSBuZXcgTkRLVXNlcih7IHB1YmtleTogc2VuZGVyUHVia2V5IH0pO1xuICAgIGNvbnN0IGRlY3J5cHRlZFBheWxvYWQgPSBhd2FpdCBkZWNyeXB0MihiYWNrZW5kLCBpZCwgcmVtb3RlUHVia2V5LCBzZW5kZXJVc2VyLCBwYXlsb2FkKTtcbiAgICByZXR1cm4gZGVjcnlwdGVkUGF5bG9hZDtcbiAgfVxufTtcbmFzeW5jIGZ1bmN0aW9uIGRlY3J5cHQyKGJhY2tlbmQsIGlkLCByZW1vdGVQdWJrZXksIHNlbmRlclVzZXIsIHBheWxvYWQpIHtcbiAgaWYgKCFhd2FpdCBiYWNrZW5kLnB1YmtleUFsbG93ZWQoe1xuICAgIGlkLFxuICAgIHB1YmtleTogcmVtb3RlUHVia2V5LFxuICAgIG1ldGhvZDogXCJuaXAwNF9kZWNyeXB0XCIsXG4gICAgcGFyYW1zOiBwYXlsb2FkXG4gIH0pKSB7XG4gICAgYmFja2VuZC5kZWJ1ZyhgZGVjcnlwdCByZXF1ZXN0IGZyb20gJHtyZW1vdGVQdWJrZXl9IHJlamVjdGVkYCk7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4gYXdhaXQgYmFja2VuZC5zaWduZXIuZGVjcnlwdChzZW5kZXJVc2VyLCBwYXlsb2FkLCBcIm5pcDA0XCIpO1xufVxuXG4vLyBzcmMvc2lnbmVycy9uaXA0Ni9iYWNrZW5kL25pcDA0LWVuY3J5cHQudHNcbnZhciBOaXAwNEVuY3J5cHRIYW5kbGluZ1N0cmF0ZWd5ID0gY2xhc3Mge1xuICBhc3luYyBoYW5kbGUoYmFja2VuZCwgaWQsIHJlbW90ZVB1YmtleSwgcGFyYW1zKSB7XG4gICAgY29uc3QgW3JlY2lwaWVudFB1YmtleSwgcGF5bG9hZF0gPSBwYXJhbXM7XG4gICAgY29uc3QgcmVjaXBpZW50VXNlciA9IG5ldyBOREtVc2VyKHsgcHVia2V5OiByZWNpcGllbnRQdWJrZXkgfSk7XG4gICAgY29uc3QgZW5jcnlwdGVkUGF5bG9hZCA9IGF3YWl0IGVuY3J5cHQyKGJhY2tlbmQsIGlkLCByZW1vdGVQdWJrZXksIHJlY2lwaWVudFVzZXIsIHBheWxvYWQpO1xuICAgIHJldHVybiBlbmNyeXB0ZWRQYXlsb2FkO1xuICB9XG59O1xuYXN5bmMgZnVuY3Rpb24gZW5jcnlwdDIoYmFja2VuZCwgaWQsIHJlbW90ZVB1YmtleSwgcmVjaXBpZW50VXNlciwgcGF5bG9hZCkge1xuICBpZiAoIWF3YWl0IGJhY2tlbmQucHVia2V5QWxsb3dlZCh7XG4gICAgaWQsXG4gICAgcHVia2V5OiByZW1vdGVQdWJrZXksXG4gICAgbWV0aG9kOiBcIm5pcDA0X2VuY3J5cHRcIixcbiAgICBwYXJhbXM6IHBheWxvYWRcbiAgfSkpIHtcbiAgICBiYWNrZW5kLmRlYnVnKGBlbmNyeXB0IHJlcXVlc3QgZnJvbSAke3JlbW90ZVB1YmtleX0gcmVqZWN0ZWRgKTtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHJldHVybiBhd2FpdCBiYWNrZW5kLnNpZ25lci5lbmNyeXB0KHJlY2lwaWVudFVzZXIsIHBheWxvYWQsIFwibmlwMDRcIik7XG59XG5cbi8vIHNyYy9zaWduZXJzL25pcDQ2L2JhY2tlbmQvc2lnbi1ldmVudC50c1xudmFyIFNpZ25FdmVudEhhbmRsaW5nU3RyYXRlZ3kgPSBjbGFzcyB7XG4gIGFzeW5jIGhhbmRsZShiYWNrZW5kLCBpZCwgcmVtb3RlUHVia2V5LCBwYXJhbXMpIHtcbiAgICBjb25zdCBldmVudCA9IGF3YWl0IHNpZ25FdmVudChiYWNrZW5kLCBpZCwgcmVtb3RlUHVia2V5LCBwYXJhbXMpO1xuICAgIGlmICghZXZlbnQpIHJldHVybiB2b2lkIDA7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGF3YWl0IGV2ZW50LnRvTm9zdHJFdmVudCgpKTtcbiAgfVxufTtcbmFzeW5jIGZ1bmN0aW9uIHNpZ25FdmVudChiYWNrZW5kLCBpZCwgcmVtb3RlUHVia2V5LCBwYXJhbXMpIHtcbiAgY29uc3QgW2V2ZW50U3RyaW5nXSA9IHBhcmFtcztcbiAgYmFja2VuZC5kZWJ1Zyhgc2lnbiBldmVudCByZXF1ZXN0IGZyb20gJHtyZW1vdGVQdWJrZXl9YCk7XG4gIGNvbnN0IGV2ZW50ID0gbmV3IE5ES0V2ZW50KGJhY2tlbmQubmRrLCBKU09OLnBhcnNlKGV2ZW50U3RyaW5nKSk7XG4gIGJhY2tlbmQuZGVidWcoXCJldmVudCB0byBzaWduXCIsIGV2ZW50LnJhd0V2ZW50KCkpO1xuICBpZiAoIWF3YWl0IGJhY2tlbmQucHVia2V5QWxsb3dlZCh7XG4gICAgaWQsXG4gICAgcHVia2V5OiByZW1vdGVQdWJrZXksXG4gICAgbWV0aG9kOiBcInNpZ25fZXZlbnRcIixcbiAgICBwYXJhbXM6IGV2ZW50XG4gIH0pKSB7XG4gICAgYmFja2VuZC5kZWJ1Zyhgc2lnbiBldmVudCByZXF1ZXN0IGZyb20gJHtyZW1vdGVQdWJrZXl9IHJlamVjdGVkYCk7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBiYWNrZW5kLmRlYnVnKGBzaWduIGV2ZW50IHJlcXVlc3QgZnJvbSAke3JlbW90ZVB1YmtleX0gYWxsb3dlZGApO1xuICBhd2FpdCBldmVudC5zaWduKGJhY2tlbmQuc2lnbmVyKTtcbiAgcmV0dXJuIGV2ZW50O1xufVxuXG4vLyBzcmMvc2lnbmVycy9uaXA0Ni9iYWNrZW5kL25pcDQ0LWVuY3J5cHQudHNcbnZhciBOaXAwNEVuY3J5cHRIYW5kbGluZ1N0cmF0ZWd5MiA9IGNsYXNzIHtcbiAgYXN5bmMgaGFuZGxlKGJhY2tlbmQsIGlkLCByZW1vdGVQdWJrZXksIHBhcmFtcykge1xuICAgIGNvbnN0IFtyZWNpcGllbnRQdWJrZXksIHBheWxvYWRdID0gcGFyYW1zO1xuICAgIGNvbnN0IHJlY2lwaWVudFVzZXIgPSBuZXcgTkRLVXNlcih7IHB1YmtleTogcmVjaXBpZW50UHVia2V5IH0pO1xuICAgIGNvbnN0IGVuY3J5cHRlZFBheWxvYWQgPSBhd2FpdCBlbmNyeXB0MyhiYWNrZW5kLCBpZCwgcmVtb3RlUHVia2V5LCByZWNpcGllbnRVc2VyLCBwYXlsb2FkKTtcbiAgICByZXR1cm4gZW5jcnlwdGVkUGF5bG9hZDtcbiAgfVxufTtcbmFzeW5jIGZ1bmN0aW9uIGVuY3J5cHQzKGJhY2tlbmQsIGlkLCByZW1vdGVQdWJrZXksIHJlY2lwaWVudFVzZXIsIHBheWxvYWQpIHtcbiAgaWYgKCFhd2FpdCBiYWNrZW5kLnB1YmtleUFsbG93ZWQoe1xuICAgIGlkLFxuICAgIHB1YmtleTogcmVtb3RlUHVia2V5LFxuICAgIG1ldGhvZDogXCJuaXA0NF9lbmNyeXB0XCIsXG4gICAgcGFyYW1zOiBwYXlsb2FkXG4gIH0pKSB7XG4gICAgYmFja2VuZC5kZWJ1ZyhgZW5jcnlwdCByZXF1ZXN0IGZyb20gJHtyZW1vdGVQdWJrZXl9IHJlamVjdGVkYCk7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4gYXdhaXQgYmFja2VuZC5zaWduZXIuZW5jcnlwdChyZWNpcGllbnRVc2VyLCBwYXlsb2FkLCBcIm5pcDQ0XCIpO1xufVxuXG4vLyBzcmMvc2lnbmVycy9uaXA0Ni9iYWNrZW5kL25pcDQ0LWRlY3J5cHQudHNcbnZhciBOaXAwNERlY3J5cHRIYW5kbGluZ1N0cmF0ZWd5MiA9IGNsYXNzIHtcbiAgYXN5bmMgaGFuZGxlKGJhY2tlbmQsIGlkLCByZW1vdGVQdWJrZXksIHBhcmFtcykge1xuICAgIGNvbnN0IFtzZW5kZXJQdWJrZXksIHBheWxvYWRdID0gcGFyYW1zO1xuICAgIGNvbnN0IHNlbmRlclVzZXIgPSBuZXcgTkRLVXNlcih7IHB1YmtleTogc2VuZGVyUHVia2V5IH0pO1xuICAgIGNvbnN0IGRlY3J5cHRlZFBheWxvYWQgPSBhd2FpdCBkZWNyeXB0MyhiYWNrZW5kLCBpZCwgcmVtb3RlUHVia2V5LCBzZW5kZXJVc2VyLCBwYXlsb2FkKTtcbiAgICByZXR1cm4gZGVjcnlwdGVkUGF5bG9hZDtcbiAgfVxufTtcbmFzeW5jIGZ1bmN0aW9uIGRlY3J5cHQzKGJhY2tlbmQsIGlkLCByZW1vdGVQdWJrZXksIHNlbmRlclVzZXIsIHBheWxvYWQpIHtcbiAgaWYgKCFhd2FpdCBiYWNrZW5kLnB1YmtleUFsbG93ZWQoe1xuICAgIGlkLFxuICAgIHB1YmtleTogcmVtb3RlUHVia2V5LFxuICAgIG1ldGhvZDogXCJuaXA0NF9kZWNyeXB0XCIsXG4gICAgcGFyYW1zOiBwYXlsb2FkXG4gIH0pKSB7XG4gICAgYmFja2VuZC5kZWJ1ZyhgZGVjcnlwdCByZXF1ZXN0IGZyb20gJHtyZW1vdGVQdWJrZXl9IHJlamVjdGVkYCk7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4gYXdhaXQgYmFja2VuZC5zaWduZXIuZGVjcnlwdChzZW5kZXJVc2VyLCBwYXlsb2FkLCBcIm5pcDQ0XCIpO1xufVxuXG4vLyBzcmMvc2lnbmVycy9uaXA0Ni9iYWNrZW5kL2luZGV4LnRzXG5pbXBvcnQgeyBoZXhUb0J5dGVzIGFzIGhleFRvQnl0ZXMyIH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvdXRpbHNcIjtcbnZhciBOREtOaXA0NkJhY2tlbmQgPSBjbGFzcyB7XG4gIG5kaztcbiAgc2lnbmVyO1xuICBsb2NhbFVzZXI7XG4gIGRlYnVnO1xuICBycGM7XG4gIHBlcm1pdENhbGxiYWNrO1xuICByZWxheVVybHM7XG4gIC8qKlxuICAgKiBAcGFyYW0gbmRrIFRoZSBOREsgaW5zdGFuY2UgdG8gdXNlXG4gICAqIEBwYXJhbSBwcml2YXRlS2V5T3JTaWduZXIgVGhlIHByaXZhdGUga2V5IG9yIHNpZ25lciBvZiB0aGUgbnB1YiB0aGF0IHdhbnRzIHRvIGJlIHB1Ymxpc2hlZCBhc1xuICAgKiBAcGFyYW0gcGVybWl0Q2FsbGJhY2sgQ2FsbGJhY2sgZXhlY3V0ZWQgd2hlbiBwZXJtaXNzaW9uIGlzIHJlcXVlc3RlZFxuICAgKi9cbiAgY29uc3RydWN0b3IobmRrLCBwcml2YXRlS2V5T3JTaWduZXIsIHBlcm1pdENhbGxiYWNrLCByZWxheVVybHMpIHtcbiAgICB0aGlzLm5kayA9IG5kaztcbiAgICBpZiAocHJpdmF0ZUtleU9yU2lnbmVyIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgdGhpcy5zaWduZXIgPSBuZXcgTkRLUHJpdmF0ZUtleVNpZ25lcihwcml2YXRlS2V5T3JTaWduZXIpO1xuICAgIH0gZWxzZSBpZiAocHJpdmF0ZUtleU9yU2lnbmVyIGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgICB0aGlzLnNpZ25lciA9IG5ldyBOREtQcml2YXRlS2V5U2lnbmVyKGhleFRvQnl0ZXMyKHByaXZhdGVLZXlPclNpZ25lcikpO1xuICAgIH0gZWxzZSBpZiAocHJpdmF0ZUtleU9yU2lnbmVyIGluc3RhbmNlb2YgTkRLUHJpdmF0ZUtleVNpZ25lcikge1xuICAgICAgdGhpcy5zaWduZXIgPSBwcml2YXRlS2V5T3JTaWduZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2lnbmVyXCIpO1xuICAgIH1cbiAgICB0aGlzLmRlYnVnID0gbmRrLmRlYnVnLmV4dGVuZChcIm5pcDQ2OmJhY2tlbmRcIik7XG4gICAgdGhpcy5yZWxheVVybHMgPSByZWxheVVybHMgPz8gQXJyYXkuZnJvbShuZGsucG9vbC5yZWxheXMua2V5cygpKTtcbiAgICB0aGlzLnJwYyA9IG5ldyBOREtOb3N0clJwYyhuZGssIHRoaXMuc2lnbmVyLCB0aGlzLmRlYnVnLCB0aGlzLnJlbGF5VXJscyk7XG4gICAgdGhpcy5wZXJtaXRDYWxsYmFjayA9IHBlcm1pdENhbGxiYWNrO1xuICB9XG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBzdGFydHMgdGhlIGJhY2tlbmQsIHdoaWNoIHdpbGwgc3RhcnQgbGlzdGVuaW5nIGZvciBpbmNvbWluZ1xuICAgKiByZXF1ZXN0cy5cbiAgICovXG4gIGFzeW5jIHN0YXJ0KCkge1xuICAgIHRoaXMubG9jYWxVc2VyID0gYXdhaXQgdGhpcy5zaWduZXIudXNlcigpO1xuICAgIGNvbnN0IHN1YiA9IHRoaXMubmRrLnN1YnNjcmliZShcbiAgICAgIHtcbiAgICAgICAga2luZHM6IFsyNDEzM10sXG4gICAgICAgIFwiI3BcIjogW3RoaXMubG9jYWxVc2VyLnB1YmtleV1cbiAgICAgIH0sXG4gICAgICB7IGNsb3NlT25Fb3NlOiBmYWxzZSB9XG4gICAgKTtcbiAgICBzdWIub24oXCJldmVudFwiLCAoZSkgPT4gdGhpcy5oYW5kbGVJbmNvbWluZ0V2ZW50KGUpKTtcbiAgfVxuICBoYW5kbGVycyA9IHtcbiAgICBjb25uZWN0OiBuZXcgQ29ubmVjdEV2ZW50SGFuZGxpbmdTdHJhdGVneSgpLFxuICAgIHNpZ25fZXZlbnQ6IG5ldyBTaWduRXZlbnRIYW5kbGluZ1N0cmF0ZWd5KCksXG4gICAgbmlwMDRfZW5jcnlwdDogbmV3IE5pcDA0RW5jcnlwdEhhbmRsaW5nU3RyYXRlZ3koKSxcbiAgICBuaXAwNF9kZWNyeXB0OiBuZXcgTmlwMDREZWNyeXB0SGFuZGxpbmdTdHJhdGVneSgpLFxuICAgIG5pcDQ0X2VuY3J5cHQ6IG5ldyBOaXAwNEVuY3J5cHRIYW5kbGluZ1N0cmF0ZWd5MigpLFxuICAgIG5pcDQ0X2RlY3J5cHQ6IG5ldyBOaXAwNERlY3J5cHRIYW5kbGluZ1N0cmF0ZWd5MigpLFxuICAgIGdldF9wdWJsaWNfa2V5OiBuZXcgR2V0UHVibGljS2V5SGFuZGxpbmdTdHJhdGVneSgpLFxuICAgIHBpbmc6IG5ldyBQaW5nRXZlbnRIYW5kbGluZ1N0cmF0ZWd5KClcbiAgfTtcbiAgLyoqXG4gICAqIEVuYWJsZXMgdGhlIHVzZXIgdG8gc2V0IGEgY3VzdG9tIHN0cmF0ZWd5IGZvciBoYW5kbGluZyBpbmNvbWluZyBldmVudHMuXG4gICAqIEBwYXJhbSBtZXRob2QgLSBUaGUgbWV0aG9kIHRvIHNldCB0aGUgc3RyYXRlZ3kgZm9yXG4gICAqIEBwYXJhbSBzdHJhdGVneSAtIFRoZSBzdHJhdGVneSB0byBzZXRcbiAgICovXG4gIHNldFN0cmF0ZWd5KG1ldGhvZCwgc3RyYXRlZ3kpIHtcbiAgICB0aGlzLmhhbmRsZXJzW21ldGhvZF0gPSBzdHJhdGVneTtcbiAgfVxuICAvKipcbiAgICogT3ZlcmxvYWQgdGhpcyBtZXRob2QgdG8gYXBwbHkgdG9rZW5zLCB3aGljaCBjYW5cbiAgICogd3JhcCBwZXJtaXNzaW9uIHNldHMgdG8gYmUgYXBwbGllZCB0byBhIHB1YmtleS5cbiAgICogQHBhcmFtIHB1YmtleSBwdWJsaWMga2V5IHRvIGFwcGx5IHRva2VuIHRvXG4gICAqIEBwYXJhbSB0b2tlbiB0b2tlbiB0byBhcHBseVxuICAgKi9cbiAgYXN5bmMgYXBwbHlUb2tlbihwdWJrZXksIHRva2VuKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY29ubmVjdGlvbiB0b2tlbiBub3Qgc3VwcG9ydGVkXCIpO1xuICB9XG4gIGFzeW5jIGhhbmRsZUluY29taW5nRXZlbnQoZXZlbnQpIHtcbiAgICBjb25zdCB7IGlkLCBtZXRob2QsIHBhcmFtcyB9ID0gYXdhaXQgdGhpcy5ycGMucGFyc2VFdmVudChldmVudCk7XG4gICAgY29uc3QgcmVtb3RlUHVia2V5ID0gZXZlbnQucHVia2V5O1xuICAgIGxldCByZXNwb25zZTtcbiAgICB0aGlzLmRlYnVnKFwiaW5jb21pbmcgZXZlbnRcIiwgeyBpZCwgbWV0aG9kLCBwYXJhbXMgfSk7XG4gICAgaWYgKCFldmVudC52ZXJpZnlTaWduYXR1cmUoZmFsc2UpKSB7XG4gICAgICB0aGlzLmRlYnVnKFwiaW52YWxpZCBzaWduYXR1cmVcIiwgZXZlbnQucmF3RXZlbnQoKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0cmF0ZWd5ID0gdGhpcy5oYW5kbGVyc1ttZXRob2RdO1xuICAgIGlmIChzdHJhdGVneSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCBzdHJhdGVneS5oYW5kbGUodGhpcywgaWQsIHJlbW90ZVB1YmtleSwgcGFyYW1zKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhpcy5kZWJ1ZyhcImVycm9yIGhhbmRsaW5nIGV2ZW50XCIsIGUsIHsgaWQsIG1ldGhvZCwgcGFyYW1zIH0pO1xuICAgICAgICB0aGlzLnJwYy5zZW5kUmVzcG9uc2UoaWQsIHJlbW90ZVB1YmtleSwgXCJlcnJvclwiLCB2b2lkIDAsIGUubWVzc2FnZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVidWcoXCJ1bnN1cHBvcnRlZCBtZXRob2RcIiwgeyBtZXRob2QsIHBhcmFtcyB9KTtcbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICB0aGlzLmRlYnVnKGBzZW5kaW5nIHJlc3BvbnNlIHRvICR7cmVtb3RlUHVia2V5fWAsIHJlc3BvbnNlKTtcbiAgICAgIHRoaXMucnBjLnNlbmRSZXNwb25zZShpZCwgcmVtb3RlUHVia2V5LCByZXNwb25zZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucnBjLnNlbmRSZXNwb25zZShpZCwgcmVtb3RlUHVia2V5LCBcImVycm9yXCIsIHZvaWQgMCwgXCJOb3QgYXV0aG9yaXplZFwiKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBvdmVycmlkZW4gYnkgdGhlIHVzZXIgdG8gYWxsb3cgb3IgcmVqZWN0IGluY29taW5nXG4gICAqIGNvbm5lY3Rpb25zLlxuICAgKi9cbiAgYXN5bmMgcHVia2V5QWxsb3dlZChwYXJhbXMpIHtcbiAgICByZXR1cm4gdGhpcy5wZXJtaXRDYWxsYmFjayhwYXJhbXMpO1xuICB9XG59O1xuXG4vLyBzcmMvc2lnbmVycy9uaXA0Ni9pbmRleC50c1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIGFzIEV2ZW50RW1pdHRlcjYgfSBmcm9tIFwidHNlZXBcIjtcbnZhciBOREtOaXA0NlNpZ25lciA9IGNsYXNzIGV4dGVuZHMgRXZlbnRFbWl0dGVyNiB7XG4gIG5kaztcbiAgX3VzZXI7XG4gIC8qKlxuICAgKiBUaGUgcHVia2V5IG9mIHRoZSBidW5rZXIgdGhhdCB3aWxsIGJlIHByb3ZpZGluZyBzaWduYXR1cmVzXG4gICAqL1xuICBidW5rZXJQdWJrZXk7XG4gIC8qKlxuICAgKiBUaGUgcHVia2V5IG9mIHRoZSB1c2VyIHRoYXQgZXZlbnRzIHdpbGwgYmUgcHVibGlzaGVkIGFzXG4gICAqL1xuICB1c2VyUHVia2V5O1xuICAvKipcbiAgICogQW4gb3B0aW9uYWwgc2VjcmV0IHZhbHVlIHByb3ZpZGVkIHRvIGNvbm5lY3QgdG8gdGhlIGJ1bmtlclxuICAgKi9cbiAgc2VjcmV0O1xuICBsb2NhbFNpZ25lcjtcbiAgbmlwMDU7XG4gIHJwYztcbiAgZGVidWc7XG4gIHJlbGF5VXJscztcbiAgc3Vic2NyaXB0aW9uO1xuICAvKipcbiAgICogQHBhcmFtIG5kayAtIFRoZSBOREsgaW5zdGFuY2UgdG8gdXNlXG4gICAqIEBwYXJhbSB1c2VyT3JDb25uZWN0aW9uVG9rZW4gLSBUaGUgcHVibGljIGtleSwgb3IgYSBjb25uZWN0aW9uIHRva2VuLCBvZiB0aGUgbnB1YiB0aGF0IHdhbnRzIHRvIGJlIHB1Ymxpc2hlZCBhc1xuICAgKiBAcGFyYW0gbG9jYWxTaWduZXIgLSBUaGUgc2lnbmVyIHRoYXQgd2lsbCBiZSB1c2VkIHRvIHJlcXVlc3QgZXZlbnRzIHRvIGJlIHNpZ25lZFxuICAgKi9cbiAgY29uc3RydWN0b3IobmRrLCB1c2VyT3JDb25uZWN0aW9uVG9rZW4sIGxvY2FsU2lnbmVyKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm5kayA9IG5kaztcbiAgICB0aGlzLmRlYnVnID0gbmRrLmRlYnVnLmV4dGVuZChcIm5pcDQ2OnNpZ25lclwiKTtcbiAgICBpZiAodXNlck9yQ29ubmVjdGlvblRva2VuLnN0YXJ0c1dpdGgoXCJidW5rZXI6Ly9cIikpIHtcbiAgICAgIHRoaXMuY29ubmVjdGlvblRva2VuSW5pdCh1c2VyT3JDb25uZWN0aW9uVG9rZW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm5pcDA1SW5pdCh1c2VyT3JDb25uZWN0aW9uVG9rZW4pO1xuICAgIH1cbiAgICBpZiAoIWxvY2FsU2lnbmVyKSB7XG4gICAgICB0aGlzLmxvY2FsU2lnbmVyID0gTkRLUHJpdmF0ZUtleVNpZ25lci5nZW5lcmF0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxvY2FsU2lnbmVyID0gbG9jYWxTaWduZXI7XG4gICAgfVxuICAgIHRoaXMucnBjID0gbmV3IE5ES05vc3RyUnBjKHRoaXMubmRrLCB0aGlzLmxvY2FsU2lnbmVyLCB0aGlzLmRlYnVnLCB0aGlzLnJlbGF5VXJscyk7XG4gIH1cbiAgY29ubmVjdGlvblRva2VuSW5pdChjb25uZWN0aW9uVG9rZW4pIHtcbiAgICBjb25zdCBidW5rZXJVcmwgPSBuZXcgVVJMKGNvbm5lY3Rpb25Ub2tlbik7XG4gICAgY29uc3QgYnVua2VyUHVia2V5ID0gYnVua2VyVXJsLmhvc3RuYW1lIHx8IGJ1bmtlclVybC5wYXRobmFtZS5yZXBsYWNlKC9eXFwvXFwvLywgXCJcIik7XG4gICAgY29uc3QgdXNlclB1YmtleSA9IGJ1bmtlclVybC5zZWFyY2hQYXJhbXMuZ2V0KFwicHVia2V5XCIpO1xuICAgIGNvbnN0IHJlbGF5VXJscyA9IGJ1bmtlclVybC5zZWFyY2hQYXJhbXMuZ2V0QWxsKFwicmVsYXlcIik7XG4gICAgY29uc3Qgc2VjcmV0ID0gYnVua2VyVXJsLnNlYXJjaFBhcmFtcy5nZXQoXCJzZWNyZXRcIik7XG4gICAgdGhpcy5idW5rZXJQdWJrZXkgPSBidW5rZXJQdWJrZXk7XG4gICAgdGhpcy51c2VyUHVia2V5ID0gdXNlclB1YmtleTtcbiAgICB0aGlzLnJlbGF5VXJscyA9IHJlbGF5VXJscztcbiAgICB0aGlzLnNlY3JldCA9IHNlY3JldDtcbiAgfVxuICBuaXAwNUluaXQobmlwMDUpIHtcbiAgICB0aGlzLm5pcDA1ID0gbmlwMDU7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSB1c2VyUHVia2V5IGluc3RlYWRcbiAgICovXG4gIGdldCByZW1vdGVQdWJrZXkoKSB7XG4gICAgcmV0dXJuIHRoaXMudXNlclB1YmtleTtcbiAgfVxuICAvKipcbiAgICogV2Ugc3RhcnQgbGlzdGVuaW5nIGZvciBldmVudHMgZnJvbSB0aGUgYnVua2VyXG4gICAqL1xuICBhc3luYyBzdGFydExpc3RlbmluZygpIHtcbiAgICBpZiAodGhpcy5zdWJzY3JpcHRpb24pIHJldHVybjtcbiAgICBjb25zdCBsb2NhbFVzZXIgPSBhd2FpdCB0aGlzLmxvY2FsU2lnbmVyLnVzZXIoKTtcbiAgICBpZiAoIWxvY2FsVXNlcikgdGhyb3cgbmV3IEVycm9yKFwiTG9jYWwgc2lnbmVyIG5vdCByZWFkeVwiKTtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IGF3YWl0IHRoaXMucnBjLnN1YnNjcmliZSh7XG4gICAgICBraW5kczogWzI0MTMzIC8qIE5vc3RyQ29ubmVjdCAqL10sXG4gICAgICBcIiNwXCI6IFtsb2NhbFVzZXIucHVia2V5XVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHVzZXIgdGhhdCBpcyBiZWluZyBwdWJsaXNoZWQgYXNcbiAgICovXG4gIGFzeW5jIHVzZXIoKSB7XG4gICAgaWYgKCF0aGlzLl91c2VyICYmICF0aGlzLnVzZXJQdWJrZXkpIHRocm93IG5ldyBFcnJvcihcIlJlbW90ZSB1c2VyIG5vdCByZWFkeVwiKTtcbiAgICB0aGlzLl91c2VyID8/PSBuZXcgTkRLVXNlcih7IHB1YmtleTogdGhpcy51c2VyUHVia2V5IH0pO1xuICAgIHJldHVybiB0aGlzLl91c2VyO1xuICB9XG4gIGFzeW5jIGJsb2NrVW50aWxSZWFkeSgpIHtcbiAgICBpZiAodGhpcy5uaXAwNSAmJiAhdGhpcy51c2VyUHVia2V5KSB7XG4gICAgICBjb25zdCB1c2VyID0gYXdhaXQgTkRLVXNlci5mcm9tTmlwMDUodGhpcy5uaXAwNSwgdGhpcy5uZGspO1xuICAgICAgaWYgKHVzZXIpIHtcbiAgICAgICAgdGhpcy5fdXNlciA9IHVzZXI7XG4gICAgICAgIHRoaXMudXNlclB1YmtleSA9IHVzZXIucHVia2V5O1xuICAgICAgICB0aGlzLnJlbGF5VXJscyA9IHVzZXIubmlwNDZVcmxzO1xuICAgICAgICB0aGlzLnJwYyA9IG5ldyBOREtOb3N0clJwYyh0aGlzLm5kaywgdGhpcy5sb2NhbFNpZ25lciwgdGhpcy5kZWJ1ZywgdGhpcy5yZWxheVVybHMpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRoaXMuYnVua2VyUHVia2V5ICYmIHRoaXMudXNlclB1YmtleSkge1xuICAgICAgdGhpcy5idW5rZXJQdWJrZXkgPSB0aGlzLnVzZXJQdWJrZXk7XG4gICAgfSBlbHNlIGlmICghdGhpcy5idW5rZXJQdWJrZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkJ1bmtlciBwdWJrZXkgbm90IHNldFwiKTtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5zdGFydExpc3RlbmluZygpO1xuICAgIHRoaXMucnBjLm9uKFwiYXV0aFVybFwiLCAoLi4ucHJvcHMpID0+IHtcbiAgICAgIHRoaXMuZW1pdChcImF1dGhVcmxcIiwgLi4ucHJvcHMpO1xuICAgIH0pO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBjb25uZWN0UGFyYW1zID0gW3RoaXMudXNlclB1YmtleSA/PyBcIlwiXTtcbiAgICAgIGlmICh0aGlzLnNlY3JldCkgY29ubmVjdFBhcmFtcy5wdXNoKHRoaXMuc2VjcmV0KTtcbiAgICAgIGlmICghdGhpcy5idW5rZXJQdWJrZXkpIHRocm93IG5ldyBFcnJvcihcIkJ1bmtlciBwdWJrZXkgbm90IHNldFwiKTtcbiAgICAgIHRoaXMucnBjLnNlbmRSZXF1ZXN0KFxuICAgICAgICB0aGlzLmJ1bmtlclB1YmtleSxcbiAgICAgICAgXCJjb25uZWN0XCIsXG4gICAgICAgIGNvbm5lY3RQYXJhbXMsXG4gICAgICAgIDI0MTMzLFxuICAgICAgICAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICBpZiAocmVzcG9uc2UucmVzdWx0ID09PSBcImFja1wiKSB7XG4gICAgICAgICAgICB0aGlzLmdldFB1YmxpY0tleSgpLnRoZW4oKHB1YmtleSkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLnVzZXJQdWJrZXkgPSBwdWJrZXk7XG4gICAgICAgICAgICAgIHRoaXMuX3VzZXIgPSBuZXcgTkRLVXNlcih7IHB1YmtleSB9KTtcbiAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLl91c2VyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWplY3QocmVzcG9uc2UuZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBnZXRQdWJsaWNLZXkoKSB7XG4gICAgaWYgKHRoaXMudXNlclB1YmtleSkgcmV0dXJuIHRoaXMudXNlclB1YmtleTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLmJ1bmtlclB1YmtleSkgdGhyb3cgbmV3IEVycm9yKFwiQnVua2VyIHB1YmtleSBub3Qgc2V0XCIpO1xuICAgICAgdGhpcy5ycGMuc2VuZFJlcXVlc3QoXG4gICAgICAgIHRoaXMuYnVua2VyUHVia2V5LFxuICAgICAgICBcImdldF9wdWJsaWNfa2V5XCIsXG4gICAgICAgIFtdLFxuICAgICAgICAyNDEzMyxcbiAgICAgICAgKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgcmVzb2x2ZShyZXNwb25zZS5yZXN1bHQpO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGVuY3J5cHRpb25FbmFibGVkKHNjaGVtZSkge1xuICAgIGlmIChzY2hlbWUpIHJldHVybiBbc2NoZW1lXTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFtcIm5pcDA0XCIsIFwibmlwNDRcIl0pO1xuICB9XG4gIGFzeW5jIGVuY3J5cHQocmVjaXBpZW50LCB2YWx1ZSwgc2NoZW1lID0gXCJuaXAwNFwiKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5jcnlwdGlvbihyZWNpcGllbnQsIHZhbHVlLCBzY2hlbWUsIFwiZW5jcnlwdFwiKTtcbiAgfVxuICBhc3luYyBkZWNyeXB0KHNlbmRlciwgdmFsdWUsIHNjaGVtZSA9IFwibmlwMDRcIikge1xuICAgIHJldHVybiB0aGlzLmVuY3J5cHRpb24oc2VuZGVyLCB2YWx1ZSwgc2NoZW1lLCBcImRlY3J5cHRcIik7XG4gIH1cbiAgYXN5bmMgZW5jcnlwdGlvbihwZWVyLCB2YWx1ZSwgc2NoZW1lLCBtZXRob2QpIHtcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLmJ1bmtlclB1YmtleSkgdGhyb3cgbmV3IEVycm9yKFwiQnVua2VyIHB1YmtleSBub3Qgc2V0XCIpO1xuICAgICAgdGhpcy5ycGMuc2VuZFJlcXVlc3QoXG4gICAgICAgIHRoaXMuYnVua2VyUHVia2V5LFxuICAgICAgICBgJHtzY2hlbWV9XyR7bWV0aG9kfWAsXG4gICAgICAgIFtwZWVyLnB1YmtleSwgdmFsdWVdLFxuICAgICAgICAyNDEzMyxcbiAgICAgICAgKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgaWYgKCFyZXNwb25zZS5lcnJvcikge1xuICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZS5yZXN1bHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWplY3QocmVzcG9uc2UuZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuICBhc3luYyBzaWduKGV2ZW50KSB7XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmICghdGhpcy5idW5rZXJQdWJrZXkpIHRocm93IG5ldyBFcnJvcihcIkJ1bmtlciBwdWJrZXkgbm90IHNldFwiKTtcbiAgICAgIHRoaXMucnBjLnNlbmRSZXF1ZXN0KFxuICAgICAgICB0aGlzLmJ1bmtlclB1YmtleSxcbiAgICAgICAgXCJzaWduX2V2ZW50XCIsXG4gICAgICAgIFtKU09OLnN0cmluZ2lmeShldmVudCldLFxuICAgICAgICAyNDEzMyxcbiAgICAgICAgKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgaWYgKCFyZXNwb25zZS5lcnJvcikge1xuICAgICAgICAgICAgY29uc3QganNvbiA9IEpTT04ucGFyc2UocmVzcG9uc2UucmVzdWx0KTtcbiAgICAgICAgICAgIHJlc29sdmUoanNvbi5zaWcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWplY3QocmVzcG9uc2UuZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuICAvKipcbiAgICogQWxsb3dzIGNyZWF0aW5nIGEgbmV3IGFjY291bnQgb24gdGhlIHJlbW90ZSBzZXJ2ZXIuXG4gICAqIEBwYXJhbSB1c2VybmFtZSBEZXNpcmVkIHVzZXJuYW1lIGZvciB0aGUgTklQLTA1XG4gICAqIEBwYXJhbSBkb21haW4gRGVzaXJlZCBkb21haW4gZm9yIHRoZSBOSVAtMDVcbiAgICogQHBhcmFtIGVtYWlsIEVtYWlsIGFkZHJlc3MgdG8gYXNzb2NpYXRlIHdpdGggdGhpcyBhY2NvdW50IC0tIFJlbW90ZSBzZXJ2ZXJzIG1heSB1c2UgdGhpcyBmb3IgcmVjb3ZlcnlcbiAgICogQHJldHVybnMgVGhlIHB1YmxpYyBrZXkgb2YgdGhlIG5ld2x5IGNyZWF0ZWQgYWNjb3VudFxuICAgKi9cbiAgYXN5bmMgY3JlYXRlQWNjb3VudCh1c2VybmFtZSwgZG9tYWluLCBlbWFpbCkge1xuICAgIGF3YWl0IHRoaXMuc3RhcnRMaXN0ZW5pbmcoKTtcbiAgICBjb25zdCByZXEgPSBbXTtcbiAgICBpZiAodXNlcm5hbWUpIHJlcS5wdXNoKHVzZXJuYW1lKTtcbiAgICBpZiAoZG9tYWluKSByZXEucHVzaChkb21haW4pO1xuICAgIGlmIChlbWFpbCkgcmVxLnB1c2goZW1haWwpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAoIXRoaXMuYnVua2VyUHVia2V5KSB0aHJvdyBuZXcgRXJyb3IoXCJCdW5rZXIgcHVia2V5IG5vdCBzZXRcIik7XG4gICAgICB0aGlzLnJwYy5zZW5kUmVxdWVzdChcbiAgICAgICAgdGhpcy5idW5rZXJQdWJrZXksXG4gICAgICAgIFwiY3JlYXRlX2FjY291bnRcIixcbiAgICAgICAgcmVxLFxuICAgICAgICAyNDEzMyAvKiBOb3N0ckNvbm5lY3QgKi8sXG4gICAgICAgIChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgIGlmICghcmVzcG9uc2UuZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IHB1YmtleSA9IHJlc3BvbnNlLnJlc3VsdDtcbiAgICAgICAgICAgIHJlc29sdmUocHVia2V5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KHJlc3BvbnNlLmVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIHNyYy9kdm0vc2NoZWR1bGUudHNcbmZ1bmN0aW9uIGFkZFJlbGF5cyhldmVudCwgcmVsYXlzKSB7XG4gIGNvbnN0IHRhZ3MgPSBbXTtcbiAgaWYgKCFyZWxheXMgfHwgcmVsYXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGNvbnN0IHBvb2xSZWxheXMgPSBldmVudC5uZGs/LnBvb2wucmVsYXlzO1xuICAgIHJlbGF5cyA9IHBvb2xSZWxheXMgPyBPYmplY3Qua2V5cyhwb29sUmVsYXlzKSA6IHZvaWQgMDtcbiAgfVxuICBpZiAocmVsYXlzICYmIHJlbGF5cy5sZW5ndGggPiAwKSB0YWdzLnB1c2goW1wicmVsYXlzXCIsIC4uLnJlbGF5c10pO1xuICByZXR1cm4gdGFncztcbn1cbmFzeW5jIGZ1bmN0aW9uIGR2bVNjaGVkdWxlKGV2ZW50cywgZHZtLCByZWxheXMsIGVuY3J5cHRlZCA9IHRydWUsIHdhaXRGb3JDb25maXJtYXRpb25Gb3JNcykge1xuICBpZiAoIShldmVudHMgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICBldmVudHMgPSBbZXZlbnRzXTtcbiAgfVxuICBjb25zdCBuZGsgPSBldmVudHNbMF0ubmRrO1xuICBpZiAoIW5kaykgdGhyb3cgbmV3IEVycm9yKFwiTkRLIG5vdCBzZXRcIik7XG4gIGZvciAoY29uc3QgZXZlbnQgb2YgZXZlbnRzKSB7XG4gICAgaWYgKCFldmVudC5zaWcpIHRocm93IG5ldyBFcnJvcihcIkV2ZW50IG5vdCBzaWduZWRcIik7XG4gICAgaWYgKCFldmVudC5jcmVhdGVkX2F0KSB0aHJvdyBuZXcgRXJyb3IoXCJFdmVudCBoYXMgbm8gZGF0ZVwiKTtcbiAgICBpZiAoIWR2bSkgdGhyb3cgbmV3IEVycm9yKFwiTm8gRFZNIHNwZWNpZmllZFwiKTtcbiAgICBpZiAoZXZlbnQuY3JlYXRlZF9hdCA8PSBEYXRlLm5vdygpIC8gMWUzKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnQgbmVlZHMgdG8gYmUgaW4gdGhlIGZ1dHVyZVwiKTtcbiAgfVxuICBjb25zdCBzY2hlZHVsZUV2ZW50ID0gbmV3IE5ES0RWTVJlcXVlc3QobmRrLCB7XG4gICAga2luZDogNTkwNSAvKiBEVk1FdmVudFNjaGVkdWxlICovXG4gIH0pO1xuICBmb3IgKGNvbnN0IGV2ZW50IG9mIGV2ZW50cykge1xuICAgIHNjaGVkdWxlRXZlbnQuYWRkSW5wdXQoSlNPTi5zdHJpbmdpZnkoZXZlbnQucmF3RXZlbnQoKSksIFwidGV4dFwiKTtcbiAgfVxuICBzY2hlZHVsZUV2ZW50LnRhZ3MucHVzaCguLi5hZGRSZWxheXMoZXZlbnRzWzBdLCByZWxheXMpKTtcbiAgaWYgKGVuY3J5cHRlZCkge1xuICAgIGF3YWl0IHNjaGVkdWxlRXZlbnQuZW5jcnlwdGlvbihkdm0pO1xuICB9IGVsc2Uge1xuICAgIHNjaGVkdWxlRXZlbnQuZHZtID0gZHZtO1xuICB9XG4gIGF3YWl0IHNjaGVkdWxlRXZlbnQuc2lnbigpO1xuICBsZXQgcmVzO1xuICBpZiAod2FpdEZvckNvbmZpcm1hdGlvbkZvck1zKSB7XG4gICAgcmVzID0gbmRrLnN1YnNjcmliZShcbiAgICAgIHtcbiAgICAgICAga2luZHM6IFs1OTA1IC8qIERWTUV2ZW50U2NoZWR1bGUgKi8gKyAxZTMsIDdlMyAvKiBEVk1Kb2JGZWVkYmFjayAqL10sXG4gICAgICAgIC4uLnNjaGVkdWxlRXZlbnQuZmlsdGVyKClcbiAgICAgIH0sXG4gICAgICB7IGdyb3VwYWJsZTogZmFsc2UsIGNsb3NlT25Fb3NlOiBmYWxzZSB9XG4gICAgKTtcbiAgfVxuICBjb25zdCB0aW1lb3V0UHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZWplY3QpID0+IHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHJlcz8uc3RvcCgpO1xuICAgICAgcmVqZWN0KFwiVGltZW91dCB3YWl0aW5nIGZvciBhbiBhbnN3ZXIgZnJvbSB0aGUgRFZNXCIpO1xuICAgIH0sIHdhaXRGb3JDb25maXJtYXRpb25Gb3JNcyk7XG4gIH0pO1xuICBjb25zdCBzY2hlZHVsZVByb21pc2UgPSBuZXcgUHJvbWlzZShcbiAgICAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAod2FpdEZvckNvbmZpcm1hdGlvbkZvck1zKSB7XG4gICAgICAgIHJlcz8ub24oXCJldmVudFwiLCBhc3luYyAoZSkgPT4ge1xuICAgICAgICAgIHJlcz8uc3RvcCgpO1xuICAgICAgICAgIGlmIChlLmtpbmQgPT09IDdlMyAvKiBEVk1Kb2JGZWVkYmFjayAqLykge1xuICAgICAgICAgICAgY29uc3QgZmVlZGJhY2sgPSBhd2FpdCBOREtEVk1Kb2JGZWVkYmFjay5mcm9tKGUpO1xuICAgICAgICAgICAgaWYgKGZlZWRiYWNrLnN0YXR1cyA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHN0YXR1c1RhZyA9IGZlZWRiYWNrLmdldE1hdGNoaW5nVGFncyhcInN0YXR1c1wiKTtcbiAgICAgICAgICAgICAgcmVqZWN0KHN0YXR1c1RhZz8uWzJdID8/IGZlZWRiYWNrKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc29sdmUoZmVlZGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXNvbHZlKGUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHNjaGVkdWxlRXZlbnQucHVibGlzaCgpLnRoZW4oKCkgPT4ge1xuICAgICAgICBpZiAoIXdhaXRGb3JDb25maXJtYXRpb25Gb3JNcykgcmVzb2x2ZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICApO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGlmICh3YWl0Rm9yQ29uZmlybWF0aW9uRm9yTXMpIHtcbiAgICAgIFByb21pc2UucmFjZShbdGltZW91dFByb21pc2UsIHNjaGVkdWxlUHJvbWlzZV0pLnRoZW4oKGUpID0+IHtcbiAgICAgICAgcmVzb2x2ZShlKTtcbiAgICAgIH0pLmNhdGNoKHJlamVjdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjaGVkdWxlUHJvbWlzZS50aGVuKHJlc29sdmUpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIHNyYy9uZGsvaW5kZXgudHNcbmltcG9ydCBkZWJ1ZzcgZnJvbSBcImRlYnVnXCI7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgYXMgRXZlbnRFbWl0dGVyOCB9IGZyb20gXCJ0c2VlcFwiO1xuXG4vLyBzcmMvZXZlbnRzL2RlZHVwLnRzXG5mdW5jdGlvbiBkZWR1cChldmVudDEsIGV2ZW50Mikge1xuICBpZiAoZXZlbnQxLmNyZWF0ZWRfYXQgPiBldmVudDIuY3JlYXRlZF9hdCkge1xuICAgIHJldHVybiBldmVudDE7XG4gIH1cbiAgcmV0dXJuIGV2ZW50Mjtcbn1cblxuLy8gc3JjL291dGJveC90cmFja2VyLnRzXG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgYXMgRXZlbnRFbWl0dGVyNyB9IGZyb20gXCJ0c2VlcFwiO1xuaW1wb3J0IHsgTFJVQ2FjaGUgYXMgTFJVQ2FjaGUyIH0gZnJvbSBcInR5cGVzY3JpcHQtbHJ1LWNhY2hlXCI7XG5cbi8vIHNyYy91dGlscy9nZXQtdXNlcnMtcmVsYXktbGlzdC50c1xuYXN5bmMgZnVuY3Rpb24gZ2V0UmVsYXlMaXN0Rm9yVXNlcihwdWJrZXksIG5kaykge1xuICBjb25zdCBsaXN0ID0gYXdhaXQgZ2V0UmVsYXlMaXN0Rm9yVXNlcnMoW3B1YmtleV0sIG5kayk7XG4gIHJldHVybiBsaXN0LmdldChwdWJrZXkpO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0UmVsYXlMaXN0Rm9yVXNlcnMocHVia2V5cywgbmRrLCBza2lwQ2FjaGUgPSBmYWxzZSwgdGltZW91dCA9IDFlMykge1xuICBjb25zdCBwb29sID0gbmRrLm91dGJveFBvb2wgfHwgbmRrLnBvb2w7XG4gIGNvbnN0IHNldCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGZvciAoY29uc3QgcmVsYXkgb2YgcG9vbC5yZWxheXMudmFsdWVzKCkpIHNldC5hZGQocmVsYXkpO1xuICBjb25zdCByZWxheUxpc3RzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgZnJvbUNvbnRhY3RMaXN0ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgcmVsYXlTZXQgPSBuZXcgTkRLUmVsYXlTZXQoc2V0LCBuZGspO1xuICBpZiAobmRrLmNhY2hlQWRhcHRlcj8ubG9ja2luZyAmJiAhc2tpcENhY2hlKSB7XG4gICAgY29uc3QgY2FjaGVkTGlzdCA9IGF3YWl0IG5kay5mZXRjaEV2ZW50cyhcbiAgICAgIHsga2luZHM6IFszLCAxMDAwMl0sIGF1dGhvcnM6IEFycmF5LmZyb20obmV3IFNldChwdWJrZXlzKSkgfSxcbiAgICAgIHsgY2FjaGVVc2FnZTogXCJPTkxZX0NBQ0hFXCIgLyogT05MWV9DQUNIRSAqLywgc3ViSWQ6IFwibmRrLXJlbGF5LWxpc3QtZmV0Y2hcIiB9XG4gICAgKTtcbiAgICBmb3IgKGNvbnN0IHJlbGF5TGlzdCBvZiBjYWNoZWRMaXN0KSB7XG4gICAgICBpZiAocmVsYXlMaXN0LmtpbmQgPT09IDEwMDAyKVxuICAgICAgICByZWxheUxpc3RzLnNldChyZWxheUxpc3QucHVia2V5LCBOREtSZWxheUxpc3QuZnJvbShyZWxheUxpc3QpKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCByZWxheUxpc3Qgb2YgY2FjaGVkTGlzdCkge1xuICAgICAgaWYgKHJlbGF5TGlzdC5raW5kID09PSAzKSB7XG4gICAgICAgIGlmIChyZWxheUxpc3RzLmhhcyhyZWxheUxpc3QucHVia2V5KSkgY29udGludWU7XG4gICAgICAgIGNvbnN0IGxpc3QgPSByZWxheUxpc3RGcm9tS2luZDMobmRrLCByZWxheUxpc3QpO1xuICAgICAgICBpZiAobGlzdCkgZnJvbUNvbnRhY3RMaXN0LnNldChyZWxheUxpc3QucHVia2V5LCBsaXN0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcHVia2V5cyA9IHB1YmtleXMuZmlsdGVyKFxuICAgICAgKHB1YmtleSkgPT4gIXJlbGF5TGlzdHMuaGFzKHB1YmtleSkgJiYgIWZyb21Db250YWN0TGlzdC5oYXMocHVia2V5KVxuICAgICk7XG4gIH1cbiAgaWYgKHB1YmtleXMubGVuZ3RoID09PSAwKSByZXR1cm4gcmVsYXlMaXN0cztcbiAgY29uc3QgcmVsYXlMaXN0RXZlbnRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgY29udGFjdExpc3RFdmVudHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUpID0+IHtcbiAgICBjb25zdCBzdWIgPSBuZGsuc3Vic2NyaWJlKFxuICAgICAgeyBraW5kczogWzMsIDEwMDAyXSwgYXV0aG9yczogcHVia2V5cyB9LFxuICAgICAge1xuICAgICAgICBjbG9zZU9uRW9zZTogdHJ1ZSxcbiAgICAgICAgcG9vbCxcbiAgICAgICAgZ3JvdXBhYmxlOiB0cnVlLFxuICAgICAgICBjYWNoZVVzYWdlOiBcIk9OTFlfUkVMQVlcIiAvKiBPTkxZX1JFTEFZICovLFxuICAgICAgICBzdWJJZDogXCJuZGstcmVsYXktbGlzdC1mZXRjaFwiXG4gICAgICB9LFxuICAgICAgcmVsYXlTZXQsXG4gICAgICBmYWxzZVxuICAgICk7XG4gICAgc3ViLm9uKFwiZXZlbnRcIiwgKGV2ZW50KSA9PiB7XG4gICAgICBpZiAoZXZlbnQua2luZCA9PT0gMTAwMDIgLyogUmVsYXlMaXN0ICovKSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nRXZlbnQgPSByZWxheUxpc3RFdmVudHMuZ2V0KGV2ZW50LnB1YmtleSk7XG4gICAgICAgIGlmIChleGlzdGluZ0V2ZW50ICYmIGV4aXN0aW5nRXZlbnQuY3JlYXRlZF9hdCA+IGV2ZW50LmNyZWF0ZWRfYXQpIHJldHVybjtcbiAgICAgICAgcmVsYXlMaXN0RXZlbnRzLnNldChldmVudC5wdWJrZXksIGV2ZW50KTtcbiAgICAgIH0gZWxzZSBpZiAoZXZlbnQua2luZCA9PT0gMyAvKiBDb250YWN0cyAqLykge1xuICAgICAgICBjb25zdCBleGlzdGluZ0V2ZW50ID0gY29udGFjdExpc3RFdmVudHMuZ2V0KGV2ZW50LnB1YmtleSk7XG4gICAgICAgIGlmIChleGlzdGluZ0V2ZW50ICYmIGV4aXN0aW5nRXZlbnQuY3JlYXRlZF9hdCA+IGV2ZW50LmNyZWF0ZWRfYXQpIHJldHVybjtcbiAgICAgICAgY29udGFjdExpc3RFdmVudHMuc2V0KGV2ZW50LnB1YmtleSwgZXZlbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHN1Yi5vbihcImVvc2VcIiwgKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBldmVudCBvZiByZWxheUxpc3RFdmVudHMudmFsdWVzKCkpIHtcbiAgICAgICAgcmVsYXlMaXN0cy5zZXQoZXZlbnQucHVia2V5LCBOREtSZWxheUxpc3QuZnJvbShldmVudCkpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBwdWJrZXkgb2YgcHVia2V5cykge1xuICAgICAgICBpZiAocmVsYXlMaXN0cy5oYXMocHVia2V5KSkgY29udGludWU7XG4gICAgICAgIGNvbnN0IGNvbnRhY3RMaXN0ID0gY29udGFjdExpc3RFdmVudHMuZ2V0KHB1YmtleSk7XG4gICAgICAgIGlmICghY29udGFjdExpc3QpIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBsaXN0ID0gcmVsYXlMaXN0RnJvbUtpbmQzKG5kaywgY29udGFjdExpc3QpO1xuICAgICAgICBpZiAobGlzdCkgcmVsYXlMaXN0cy5zZXQocHVia2V5LCBsaXN0KTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUocmVsYXlMaXN0cyk7XG4gICAgfSk7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICByZXNvbHZlKHJlbGF5TGlzdHMpO1xuICAgIH0sIHRpbWVvdXQpO1xuICAgIHN1Yi5zdGFydCgpO1xuICB9KTtcbn1cblxuLy8gc3JjL291dGJveC90cmFja2VyLnRzXG52YXIgT3V0Ym94SXRlbSA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIFR5cGUgb2YgaXRlbVxuICAgKi9cbiAgdHlwZTtcbiAgLyoqXG4gICAqIFRoZSByZWxheSBVUkxzIHRoYXQgYXJlIG9mIGludGVyZXN0IHRvIHRoaXMgaXRlbVxuICAgKi9cbiAgcmVsYXlVcmxTY29yZXM7XG4gIHJlYWRSZWxheXM7XG4gIHdyaXRlUmVsYXlzO1xuICBjb25zdHJ1Y3Rvcih0eXBlKSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnJlbGF5VXJsU2NvcmVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLnJlYWRSZWxheXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMud3JpdGVSZWxheXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICB9XG59O1xudmFyIE91dGJveFRyYWNrZXIgPSBjbGFzcyBleHRlbmRzIEV2ZW50RW1pdHRlcjcge1xuICBkYXRhO1xuICBuZGs7XG4gIGRlYnVnO1xuICBjb25zdHJ1Y3RvcihuZGspIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubmRrID0gbmRrO1xuICAgIHRoaXMuZGVidWcgPSBuZGsuZGVidWcuZXh0ZW5kKFwib3V0Ym94LXRyYWNrZXJcIik7XG4gICAgdGhpcy5kYXRhID0gbmV3IExSVUNhY2hlMih7XG4gICAgICBtYXhTaXplOiAxZTUsXG4gICAgICBlbnRyeUV4cGlyYXRpb25UaW1lSW5NUzogMiAqIDYwICogMWUzXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYSBsaXN0IG9mIHVzZXJzIHRvIHRoZSB0cmFja2VyLlxuICAgKiBAcGFyYW0gaXRlbXNcbiAgICogQHBhcmFtIHNraXBDYWNoZVxuICAgKi9cbiAgYXN5bmMgdHJhY2tVc2VycyhpdGVtcywgc2tpcENhY2hlID0gZmFsc2UpIHtcbiAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpICs9IDQwMCkge1xuICAgICAgY29uc3Qgc2xpY2UgPSBpdGVtcy5zbGljZShpLCBpICsgNDAwKTtcbiAgICAgIGNvbnN0IHB1YmtleXMgPSBzbGljZS5tYXAoKGl0ZW0pID0+IGdldEtleUZyb21JdGVtKGl0ZW0pKS5maWx0ZXIoKHB1YmtleSkgPT4gIXRoaXMuZGF0YS5oYXMocHVia2V5KSk7XG4gICAgICBpZiAocHVia2V5cy5sZW5ndGggPT09IDApIGNvbnRpbnVlO1xuICAgICAgZm9yIChjb25zdCBwdWJrZXkgb2YgcHVia2V5cykge1xuICAgICAgICB0aGlzLmRhdGEuc2V0KHB1YmtleSwgbmV3IE91dGJveEl0ZW0oXCJ1c2VyXCIpKTtcbiAgICAgIH1cbiAgICAgIHByb21pc2VzLnB1c2goXG4gICAgICAgIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgZ2V0UmVsYXlMaXN0Rm9yVXNlcnMocHVia2V5cywgdGhpcy5uZGssIHNraXBDYWNoZSkudGhlbigocmVsYXlMaXN0cykgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbcHVia2V5LCByZWxheUxpc3RdIG9mIHJlbGF5TGlzdHMpIHtcbiAgICAgICAgICAgICAgbGV0IG91dGJveEl0ZW0gPSB0aGlzLmRhdGEuZ2V0KHB1YmtleSk7XG4gICAgICAgICAgICAgIG91dGJveEl0ZW0gPz89IG5ldyBPdXRib3hJdGVtKFwidXNlclwiKTtcbiAgICAgICAgICAgICAgaWYgKHJlbGF5TGlzdCkge1xuICAgICAgICAgICAgICAgIG91dGJveEl0ZW0ucmVhZFJlbGF5cyA9IG5ldyBTZXQoXG4gICAgICAgICAgICAgICAgICBub3JtYWxpemUocmVsYXlMaXN0LnJlYWRSZWxheVVybHMpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBvdXRib3hJdGVtLndyaXRlUmVsYXlzID0gbmV3IFNldChcbiAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZShyZWxheUxpc3Qud3JpdGVSZWxheVVybHMpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJlbGF5VXJsIG9mIG91dGJveEl0ZW0ucmVhZFJlbGF5cykge1xuICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubmRrLnBvb2wuYmxhY2tsaXN0UmVsYXlVcmxzLmhhcyhyZWxheVVybCkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0Ym94SXRlbS5yZWFkUmVsYXlzLmRlbGV0ZShyZWxheVVybCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcmVsYXlVcmwgb2Ygb3V0Ym94SXRlbS53cml0ZVJlbGF5cykge1xuICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubmRrLnBvb2wuYmxhY2tsaXN0UmVsYXlVcmxzLmhhcyhyZWxheVVybCkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0Ym94SXRlbS53cml0ZVJlbGF5cy5kZWxldGUocmVsYXlVcmwpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEuc2V0KHB1YmtleSwgb3V0Ym94SXRlbSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KS5maW5hbGx5KHJlc29sdmUpO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIGtleVxuICAgKiBAcGFyYW0gc2NvcmVcbiAgICovXG4gIHRyYWNrKGl0ZW0sIHR5cGUsIHNraXBDYWNoZSA9IHRydWUpIHtcbiAgICBjb25zdCBrZXkgPSBnZXRLZXlGcm9tSXRlbShpdGVtKTtcbiAgICB0eXBlID8/PSBnZXRUeXBlRnJvbUl0ZW0oaXRlbSk7XG4gICAgbGV0IG91dGJveEl0ZW0gPSB0aGlzLmRhdGEuZ2V0KGtleSk7XG4gICAgaWYgKCFvdXRib3hJdGVtKSB7XG4gICAgICBvdXRib3hJdGVtID0gbmV3IE91dGJveEl0ZW0odHlwZSk7XG4gICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIE5ES1VzZXIpIHtcbiAgICAgICAgdGhpcy50cmFja1VzZXJzKFtpdGVtXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXRib3hJdGVtO1xuICB9XG59O1xuZnVuY3Rpb24gZ2V0S2V5RnJvbUl0ZW0oaXRlbSkge1xuICBpZiAoaXRlbSBpbnN0YW5jZW9mIE5ES1VzZXIpIHtcbiAgICByZXR1cm4gaXRlbS5wdWJrZXk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGl0ZW07XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFR5cGVGcm9tSXRlbShpdGVtKSB7XG4gIGlmIChpdGVtIGluc3RhbmNlb2YgTkRLVXNlcikge1xuICAgIHJldHVybiBcInVzZXJcIjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJraW5kXCI7XG4gIH1cbn1cblxuLy8gc3JjL3JlbGF5L3NldHMvdXRpbHMudHNcbmZ1bmN0aW9uIGNvcnJlY3RSZWxheVNldChyZWxheVNldCwgcG9vbCkge1xuICBjb25zdCBjb25uZWN0ZWRSZWxheXMgPSBwb29sLmNvbm5lY3RlZFJlbGF5cygpO1xuICBjb25zdCBpbmNsdWRlc0Nvbm5lY3RlZFJlbGF5ID0gQXJyYXkuZnJvbShyZWxheVNldC5yZWxheXMpLnNvbWUoKHJlbGF5KSA9PiB7XG4gICAgcmV0dXJuIGNvbm5lY3RlZFJlbGF5cy5tYXAoKHIpID0+IHIudXJsKS5pbmNsdWRlcyhyZWxheS51cmwpO1xuICB9KTtcbiAgaWYgKCFpbmNsdWRlc0Nvbm5lY3RlZFJlbGF5KSB7XG4gICAgZm9yIChjb25zdCByZWxheSBvZiBjb25uZWN0ZWRSZWxheXMpIHtcbiAgICAgIHJlbGF5U2V0LmFkZFJlbGF5KHJlbGF5KTtcbiAgICB9XG4gIH1cbiAgaWYgKGNvbm5lY3RlZFJlbGF5cy5sZW5ndGggPT09IDApIHtcbiAgICBmb3IgKGNvbnN0IHJlbGF5IG9mIHBvb2wucmVsYXlzLnZhbHVlcygpKSB7XG4gICAgICByZWxheVNldC5hZGRSZWxheShyZWxheSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZWxheVNldDtcbn1cblxuLy8gc3JjL25kay9mZXRjaC1ldmVudC1mcm9tLXRhZy50c1xuZnVuY3Rpb24gaXNWYWxpZEhpbnQoaGludCkge1xuICBpZiAoIWhpbnQgfHwgaGludCA9PT0gXCJcIikgcmV0dXJuIGZhbHNlO1xuICB0cnkge1xuICAgIG5ldyBVUkwoaGludCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGZldGNoRXZlbnRGcm9tVGFnKHRhZywgb3JpZ2luYWxFdmVudCwgc3ViT3B0cywgZmFsbGJhY2sgPSB7XG4gIHR5cGU6IFwidGltZW91dFwiXG59KSB7XG4gIGNvbnN0IGQ0ID0gdGhpcy5kZWJ1Zy5leHRlbmQoXCJmZXRjaC1ldmVudC1mcm9tLXRhZ1wiKTtcbiAgY29uc3QgW18sIGlkLCBoaW50XSA9IHRhZztcbiAgc3ViT3B0cyA9IHt9O1xuICBkNChcImZldGNoaW5nIGV2ZW50IGZyb20gdGFnXCIsIHRhZywgc3ViT3B0cywgZmFsbGJhY2spO1xuICBjb25zdCBhdXRob3JSZWxheXMgPSBnZXRSZWxheXNGb3JTeW5jKHRoaXMsIG9yaWdpbmFsRXZlbnQucHVia2V5KTtcbiAgaWYgKGF1dGhvclJlbGF5cyAmJiBhdXRob3JSZWxheXMuc2l6ZSA+IDApIHtcbiAgICBkNChcImZldGNoaW5nIGV2ZW50IGZyb20gYXV0aG9yIHJlbGF5cyAlb1wiLCBBcnJheS5mcm9tKGF1dGhvclJlbGF5cykpO1xuICAgIGNvbnN0IHJlbGF5U2V0MiA9IE5ES1JlbGF5U2V0LmZyb21SZWxheVVybHMoQXJyYXkuZnJvbShhdXRob3JSZWxheXMpLCB0aGlzKTtcbiAgICBjb25zdCBldmVudDIgPSBhd2FpdCB0aGlzLmZldGNoRXZlbnQoaWQsIHN1Yk9wdHMsIHJlbGF5U2V0Mik7XG4gICAgaWYgKGV2ZW50MikgcmV0dXJuIGV2ZW50MjtcbiAgfSBlbHNlIHtcbiAgICBkNChcIm5vIGF1dGhvciByZWxheXMgZm91bmQgZm9yICVzXCIsIG9yaWdpbmFsRXZlbnQucHVia2V5LCBvcmlnaW5hbEV2ZW50KTtcbiAgfVxuICBjb25zdCByZWxheVNldCA9IGNhbGN1bGF0ZVJlbGF5U2V0c0Zyb21GaWx0ZXJzKHRoaXMsIFt7IGlkczogW2lkXSB9XSwgdGhpcy5wb29sKTtcbiAgZDQoXCJmZXRjaGluZyBldmVudCB3aXRob3V0IHJlbGF5IGhpbnRcIiwgcmVsYXlTZXQpO1xuICBjb25zdCBldmVudCA9IGF3YWl0IHRoaXMuZmV0Y2hFdmVudChpZCwgc3ViT3B0cyk7XG4gIGlmIChldmVudCkgcmV0dXJuIGV2ZW50O1xuICBpZiAoaGludCAmJiBoaW50ICE9PSBcIlwiKSB7XG4gICAgY29uc3QgZXZlbnQyID0gYXdhaXQgdGhpcy5mZXRjaEV2ZW50KFxuICAgICAgaWQsXG4gICAgICBzdWJPcHRzLFxuICAgICAgdGhpcy5wb29sLmdldFJlbGF5KGhpbnQsIHRydWUsIHRydWUsIFt7IGlkczogW2lkXSB9XSlcbiAgICApO1xuICAgIGlmIChldmVudDIpIHJldHVybiBldmVudDI7XG4gIH1cbiAgbGV0IHJlc3VsdCA9IHZvaWQgMDtcbiAgY29uc3QgcmVsYXkgPSBpc1ZhbGlkSGludChoaW50KSA/IHRoaXMucG9vbC5nZXRSZWxheShoaW50LCBmYWxzZSwgdHJ1ZSwgW3sgaWRzOiBbaWRdIH1dKSA6IHZvaWQgMDtcbiAgY29uc3QgZmV0Y2hNYXliZVdpdGhSZWxheUhpbnQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHRoaXMuZmV0Y2hFdmVudChpZCwgc3ViT3B0cywgcmVsYXkpLnRoZW4ocmVzb2x2ZSk7XG4gIH0pO1xuICBpZiAoIWlzVmFsaWRIaW50KGhpbnQpIHx8IGZhbGxiYWNrLnR5cGUgPT09IFwibm9uZVwiKSB7XG4gICAgcmV0dXJuIGZldGNoTWF5YmVXaXRoUmVsYXlIaW50O1xuICB9XG4gIGNvbnN0IGZhbGxiYWNrRmV0Y2hQcm9taXNlID0gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUpID0+IHtcbiAgICBjb25zdCBmYWxsYmFja1JlbGF5U2V0ID0gZmFsbGJhY2sucmVsYXlTZXQ7XG4gICAgY29uc3QgdGltZW91dCA9IGZhbGxiYWNrLnRpbWVvdXQgPz8gMTUwMDtcbiAgICBjb25zdCB0aW1lb3V0UHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlMikgPT4gc2V0VGltZW91dChyZXNvbHZlMiwgdGltZW91dCkpO1xuICAgIGlmIChmYWxsYmFjay50eXBlID09PSBcInRpbWVvdXRcIikgYXdhaXQgdGltZW91dFByb21pc2U7XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkNChcImZhbGxiYWNrIGZldGNoIHRyaWdnZXJlZFwiKTtcbiAgICAgIGNvbnN0IGZhbGxiYWNrRXZlbnQgPSBhd2FpdCB0aGlzLmZldGNoRXZlbnQoaWQsIHN1Yk9wdHMsIGZhbGxiYWNrUmVsYXlTZXQpO1xuICAgICAgcmVzb2x2ZShmYWxsYmFja0V2ZW50KTtcbiAgICB9XG4gIH0pO1xuICBzd2l0Y2ggKGZhbGxiYWNrLnR5cGUpIHtcbiAgICBjYXNlIFwidGltZW91dFwiOlxuICAgICAgcmV0dXJuIFByb21pc2UucmFjZShbZmV0Y2hNYXliZVdpdGhSZWxheUhpbnQsIGZhbGxiYWNrRmV0Y2hQcm9taXNlXSk7XG4gICAgY2FzZSBcImVvc2VcIjpcbiAgICAgIHJlc3VsdCA9IGF3YWl0IGZldGNoTWF5YmVXaXRoUmVsYXlIaW50O1xuICAgICAgaWYgKHJlc3VsdCkgcmV0dXJuIHJlc3VsdDtcbiAgICAgIHJldHVybiBmYWxsYmFja0ZldGNoUHJvbWlzZTtcbiAgfVxufVxuXG4vLyBzcmMvbWVkaWEvaW5kZXgudHNcbnZhciBTUEVDX1BBVEggPSBcIi8ud2VsbC1rbm93bi9ub3N0ci9uaXA5Ni5qc29uXCI7XG52YXIgTmlwOTYgPSBjbGFzcyB7XG4gIG5kaztcbiAgc3BlYztcbiAgdXJsO1xuICBuaXA5OFJlcXVpcmVkID0gZmFsc2U7XG4gIC8qKlxuICAgKiBAcGFyYW0gZG9tYWluIGRvbWFpbiBvZiB0aGUgTklQOTYgc2VydmljZVxuICAgKi9cbiAgY29uc3RydWN0b3IoZG9tYWluLCBuZGspIHtcbiAgICB0aGlzLnVybCA9IGBodHRwczovLyR7ZG9tYWlufSR7U1BFQ19QQVRIfWA7XG4gICAgdGhpcy5uZGsgPSBuZGs7XG4gIH1cbiAgYXN5bmMgcHJlcGFyZVVwbG9hZChibG9iLCBodHRwVmVyYiA9IFwiUE9TVFwiKSB7XG4gICAgdGhpcy52YWxpZGF0ZUh0dHBGZXRjaCgpO1xuICAgIGlmICghdGhpcy5zcGVjKSBhd2FpdCB0aGlzLmZldGNoU3BlYygpO1xuICAgIGlmICghdGhpcy5zcGVjKSB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZmV0Y2ggTklQOTYgc3BlY1wiKTtcbiAgICBsZXQgaGVhZGVycyA9IHt9O1xuICAgIGlmICh0aGlzLm5pcDk4UmVxdWlyZWQpIHtcbiAgICAgIGNvbnN0IGF1dGhvcml6YXRpb25IZWFkZXIgPSBhd2FpdCB0aGlzLmdlbmVyYXRlTmlwOThIZWFkZXIoXG4gICAgICAgIHRoaXMuc3BlYy5hcGlfdXJsLFxuICAgICAgICBodHRwVmVyYixcbiAgICAgICAgYmxvYlxuICAgICAgKTtcbiAgICAgIGhlYWRlcnMgPSB7IEF1dGhvcml6YXRpb246IGF1dGhvcml6YXRpb25IZWFkZXIgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHVybDogdGhpcy5zcGVjLmFwaV91cmwsXG4gICAgICBoZWFkZXJzXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUHJvdmlkZXMgYW4gWE1MSHR0cFJlcXVlc3QtYmFzZWQgdXBsb2FkIG1ldGhvZCBmb3IgYnJvd3NlcnMuXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgKiB4aHIudXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoXCJwcm9ncmVzc1wiLCBmdW5jdGlvbihlKSB7XG4gICAqICAgIGNvbnN0IHBlcmNlbnRDb21wbGV0ZSA9IGUubG9hZGVkIC8gZS50b3RhbDtcbiAgICogICAgY29uc29sZS5sb2cocGVyY2VudENvbXBsZXRlKTtcbiAgICogfSk7XG4gICAqIGNvbnN0IG5pcDk2ID0gbmRrLmdldE5pcDk2KFwibm9zdHJjaGVjay5tZVwiKTtcbiAgICogY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtcIkhlbGxvLCB3b3JsZCFcIl0sIHsgdHlwZTogXCJ0ZXh0L3BsYWluXCIgfSk7XG4gICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgbmlwOTYueGhyVXBsb2FkKHhociwgYmxvYik7XG4gICAqIGNvbnNvbGUubG9nKHJlc3BvbnNlKTtcbiAgICogQHJldHVybnMgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSB1cGxvYWQgcmVzcG9uc2VcbiAgICovXG4gIGFzeW5jIHhoclVwbG9hZCh4aHIsIGJsb2IpIHtcbiAgICBjb25zdCBodHRwVmVyYiA9IFwiUE9TVFwiO1xuICAgIGNvbnN0IHsgdXJsLCBoZWFkZXJzIH0gPSBhd2FpdCB0aGlzLnByZXBhcmVVcGxvYWQoYmxvYiwgaHR0cFZlcmIpO1xuICAgIHhoci5vcGVuKGh0dHBWZXJiLCB1cmwsIHRydWUpO1xuICAgIGlmIChoZWFkZXJzW1wiQXV0aG9yaXphdGlvblwiXSkge1xuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoXCJBdXRob3JpemF0aW9uXCIsIGhlYWRlcnNbXCJBdXRob3JpemF0aW9uXCJdKTtcbiAgICB9XG4gICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICBmb3JtRGF0YS5hcHBlbmQoXCJmaWxlXCIsIGJsb2IpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDwgMzAwKSB7XG4gICAgICAgICAgcmVzb2x2ZShKU09OLnBhcnNlKHhoci5yZXNwb25zZVRleHQpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKHhoci5zdGF0dXNUZXh0KSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QobmV3IEVycm9yKFwiTmV0d29yayBFcnJvclwiKSk7XG4gICAgICB9O1xuICAgICAgeGhyLnNlbmQoZm9ybURhdGEpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBGZXRjaC1iYXNlZCB1cGxvYWQgbWV0aG9kLiBOb3RlIHRoYXQgdGhpcyB3aWxsIHVzZSBOREsncyBodHRwRmV0Y2hcbiAgICogQHBhcmFtIGJsb2JcbiAgICogQHJldHVybnMgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSB1cGxvYWQgcmVzcG9uc2VcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3QgbmlwOTYgPSBuZGsuZ2V0TmlwOTYoXCJub3N0cmNoZWNrLm1lXCIpO1xuICAgKiBjb25zdCBibG9iID0gbmV3IEJsb2IoW1wiSGVsbG8sIHdvcmxkIVwiXSwgeyB0eXBlOiBcInRleHQvcGxhaW5cIiB9KTtcbiAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBuaXA5Ni51cGxvYWQoYmxvYik7XG4gICAqIGNvbnNvbGUubG9nKHJlc3BvbnNlKTtcbiAgICovXG4gIGFzeW5jIHVwbG9hZChibG9iKSB7XG4gICAgY29uc3QgaHR0cFZlcmIgPSBcIlBPU1RcIjtcbiAgICBjb25zdCB7IHVybCwgaGVhZGVycyB9ID0gYXdhaXQgdGhpcy5wcmVwYXJlVXBsb2FkKGJsb2IsIGh0dHBWZXJiKTtcbiAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgIGZvcm1EYXRhLmFwcGVuZChcImZpbGVcIiwgYmxvYik7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5uZGsuaHR0cEZldGNoKHRoaXMuc3BlYy5hcGlfdXJsLCB7XG4gICAgICBtZXRob2Q6IGh0dHBWZXJiLFxuICAgICAgaGVhZGVycyxcbiAgICAgIGJvZHk6IGZvcm1EYXRhXG4gICAgfSk7XG4gICAgaWYgKHJlcy5zdGF0dXMgIT09IDIwMCkgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gdXBsb2FkIGZpbGUgdG8gJHt1cmx9YCk7XG4gICAgY29uc3QganNvbiA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgaWYgKGpzb24uc3RhdHVzICE9PSBcInN1Y2Nlc3NcIikgdGhyb3cgbmV3IEVycm9yKGpzb24ubWVzc2FnZSk7XG4gICAgcmV0dXJuIGpzb247XG4gIH1cbiAgdmFsaWRhdGVIdHRwRmV0Y2goKSB7XG4gICAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTkRLIGlzIHJlcXVpcmVkIHRvIGZldGNoIE5JUDk2IHNwZWNcIik7XG4gICAgaWYgKCF0aGlzLm5kay5odHRwRmV0Y2gpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOREsgbXVzdCBoYXZlIGFuIGh0dHBGZXRjaCBtZXRob2QgdG8gZmV0Y2ggTklQOTYgc3BlY1wiKTtcbiAgfVxuICBhc3luYyBmZXRjaFNwZWMoKSB7XG4gICAgdGhpcy52YWxpZGF0ZUh0dHBGZXRjaCgpO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMubmRrLmh0dHBGZXRjaCh0aGlzLnVybCk7XG4gICAgaWYgKHJlcy5zdGF0dXMgIT09IDIwMCkgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggTklQOTYgc3BlYyBmcm9tICR7dGhpcy51cmx9YCk7XG4gICAgY29uc3Qgc3BlYyA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgaWYgKCFzcGVjKSB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwYXJzZSBOSVA5NiBzcGVjIGZyb20gJHt0aGlzLnVybH1gKTtcbiAgICB0aGlzLnNwZWMgPSBzcGVjO1xuICAgIHRoaXMubmlwOThSZXF1aXJlZCA9IHRoaXMuc3BlYy5wbGFucy5mcmVlLmlzX25pcDk4X3JlcXVpcmVkO1xuICB9XG4gIGFzeW5jIGdlbmVyYXRlTmlwOThIZWFkZXIocmVxdWVzdFVybCwgaHR0cE1ldGhvZCwgYmxvYikge1xuICAgIGNvbnN0IGV2ZW50ID0gbmV3IE5ES0V2ZW50KHRoaXMubmRrLCB7XG4gICAgICBraW5kOiAyNzIzNSAvKiBIdHRwQXV0aCAqLyxcbiAgICAgIHRhZ3M6IFtcbiAgICAgICAgW1widVwiLCByZXF1ZXN0VXJsXSxcbiAgICAgICAgW1wibWV0aG9kXCIsIGh0dHBNZXRob2RdXG4gICAgICBdXG4gICAgfSk7XG4gICAgaWYgKFtcIlBPU1RcIiwgXCJQVVRcIiwgXCJQQVRDSFwiXS5pbmNsdWRlcyhodHRwTWV0aG9kKSkge1xuICAgICAgY29uc3Qgc2hhMjU2SGFzaCA9IGF3YWl0IHRoaXMuY2FsY3VsYXRlU2hhMjU2KGJsb2IpO1xuICAgICAgZXZlbnQudGFncy5wdXNoKFtcInBheWxvYWRcIiwgc2hhMjU2SGFzaF0pO1xuICAgIH1cbiAgICBhd2FpdCBldmVudC5zaWduKCk7XG4gICAgY29uc3QgZW5jb2RlZEV2ZW50ID0gYnRvYShKU09OLnN0cmluZ2lmeShldmVudC5yYXdFdmVudCgpKSk7XG4gICAgcmV0dXJuIGBOb3N0ciAke2VuY29kZWRFdmVudH1gO1xuICB9XG4gIGFzeW5jIGNhbGN1bGF0ZVNoYTI1NihibG9iKSB7XG4gICAgY29uc3QgYnVmZmVyID0gYXdhaXQgYmxvYi5hcnJheUJ1ZmZlcigpO1xuICAgIGNvbnN0IGhhc2hCdWZmZXIgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmRpZ2VzdChcIlNIQS0yNTZcIiwgYnVmZmVyKTtcbiAgICBjb25zdCBoYXNoQXJyYXkgPSBBcnJheS5mcm9tKG5ldyBVaW50OEFycmF5KGhhc2hCdWZmZXIpKTtcbiAgICBjb25zdCBoYXNoSGV4ID0gaGFzaEFycmF5Lm1hcCgoYikgPT4gYi50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpKS5qb2luKFwiXCIpO1xuICAgIHJldHVybiBoYXNoSGV4O1xuICB9XG59O1xuXG4vLyBzcmMvbmRrL3F1ZXVlL2luZGV4LnRzXG52YXIgUXVldWUgPSBjbGFzcyB7XG4gIHF1ZXVlID0gW107XG4gIG1heENvbmN1cnJlbmN5O1xuICBwcm9jZXNzaW5nID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgcHJvbWlzZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdHJ1Y3RvcihuYW1lLCBtYXhDb25jdXJyZW5jeSkge1xuICAgIHRoaXMubWF4Q29uY3VycmVuY3kgPSBtYXhDb25jdXJyZW5jeTtcbiAgfVxuICBhZGQoaXRlbSkge1xuICAgIGlmICh0aGlzLnByb21pc2VzLmhhcyhpdGVtLmlkKSkge1xuICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZXMuZ2V0KGl0ZW0uaWQpO1xuICAgIH0gZWxzZSB7XG4gICAgfVxuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLnF1ZXVlLnB1c2goe1xuICAgICAgICAuLi5pdGVtLFxuICAgICAgICBmdW5jOiAoKSA9PiBpdGVtLmZ1bmMoKS50aGVuKFxuICAgICAgICAgIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfSxcbiAgICAgICAgICAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgIH0pO1xuICAgICAgdGhpcy5wcm9jZXNzKCk7XG4gICAgfSk7XG4gICAgdGhpcy5wcm9taXNlcy5zZXQoaXRlbS5pZCwgcHJvbWlzZSk7XG4gICAgcHJvbWlzZS5maW5hbGx5KCgpID0+IHtcbiAgICAgIHRoaXMucHJvbWlzZXMuZGVsZXRlKGl0ZW0uaWQpO1xuICAgICAgdGhpcy5wcm9jZXNzaW5nLmRlbGV0ZShpdGVtLmlkKTtcbiAgICAgIHRoaXMucHJvY2VzcygpO1xuICAgIH0pO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG4gIHByb2Nlc3MoKSB7XG4gICAgaWYgKHRoaXMucHJvY2Vzc2luZy5zaXplID49IHRoaXMubWF4Q29uY3VycmVuY3kgfHwgdGhpcy5xdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaXRlbSA9IHRoaXMucXVldWUuc2hpZnQoKTtcbiAgICBpZiAoIWl0ZW0gfHwgdGhpcy5wcm9jZXNzaW5nLmhhcyhpdGVtLmlkKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnByb2Nlc3NpbmcuYWRkKGl0ZW0uaWQpO1xuICAgIGl0ZW0uZnVuYygpO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMucXVldWUgPSBbXTtcbiAgfVxuICBjbGVhclByb2Nlc3NpbmcoKSB7XG4gICAgdGhpcy5wcm9jZXNzaW5nLmNsZWFyKCk7XG4gIH1cbiAgY2xlYXJBbGwoKSB7XG4gICAgdGhpcy5jbGVhcigpO1xuICAgIHRoaXMuY2xlYXJQcm9jZXNzaW5nKCk7XG4gIH1cbiAgbGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXVlLmxlbmd0aDtcbiAgfVxufTtcblxuLy8gc3JjL3N1YnNjcmlwdGlvbi9tYW5hZ2VyLnRzXG5pbXBvcnQgeyBtYXRjaEZpbHRlcnMgfSBmcm9tIFwibm9zdHItdG9vbHNcIjtcbnZhciBOREtTdWJzY3JpcHRpb25NYW5hZ2VyID0gY2xhc3Mge1xuICBzdWJzY3JpcHRpb25zO1xuICBzZWVuRXZlbnRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICBhZGQoc3ViKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnNldChzdWIuaW50ZXJuYWxJZCwgc3ViKTtcbiAgICBpZiAoc3ViLm9uU3RvcHBlZCkge1xuICAgICAgY29uc29sZS5sb2coXCJTVUItTUFOQUdFUiBCVUc6IFN1YnNjcmlwdGlvbiBhbHJlYWR5IGhhZCBvblN0b3BwZWQhIFxcdXsxRjkxNH1cIiwgc3ViLmludGVybmFsSWQpO1xuICAgIH1cbiAgICBzdWIub25TdG9wcGVkID0gKCkgPT4ge1xuICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmRlbGV0ZShzdWIuaW50ZXJuYWxJZCk7XG4gICAgfTtcbiAgICBzdWIub24oXCJjbG9zZVwiLCAoKSA9PiB7XG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZGVsZXRlKHN1Yi5pbnRlcm5hbElkKTtcbiAgICB9KTtcbiAgfVxuICBzZWVuRXZlbnQoZXZlbnRJZCwgcmVsYXkpIHtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5zZWVuRXZlbnRzLmdldChldmVudElkKSB8fCBbXTtcbiAgICBjdXJyZW50LnB1c2gocmVsYXkpO1xuICAgIHRoaXMuc2VlbkV2ZW50cy5zZXQoZXZlbnRJZCwgY3VycmVudCk7XG4gIH1cbiAgLyoqXG4gICAqIFdoZW5ldmVyIGFuIGV2ZW50IGNvbWVzIGluLCB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZC5cbiAgICogVGhpcyBmdW5jdGlvbiBtYXRjaGVzIHRoZSByZWNlaXZlZCBldmVudCBhZ2FpbnN0IGFsbCB0aGVcbiAgICoga25vd24gKGkuZS4gYWN0aXZlKSBOREtTdWJzY3JpcHRpb25zLCBhbmQgaWYgaXQgbWF0Y2hlcyxcbiAgICogaXQgc2VuZHMgdGhlIGV2ZW50IHRvIHRoZSBzdWJzY3JpcHRpb24uXG4gICAqIFxuICAgKiBUaGlzIGlzIHRoZSBzaW5nbGUgcGxhY2UgaW4gdGhlIGNvZGViYXNlIHRoYXQgbWF0Y2hlc1xuICAgKiBpbmNvbWluZyBldmVudHMgd2l0aCBwYXJ0aWVzIGludGVyZXN0ZWQgaW4gdGhlIGV2ZW50LlxuICAgKiBcbiAgICogVGhpcyBpcyBhbHNvIHdoYXQgYWxsb3dzIGZvciByZWFjdGl2aXR5IGluIE5ESyBhcHBzLCBzdWNoIHRoYXRcbiAgICogd2hlbmV2ZXIgYW4gYWN0aXZlIHN1YnNjcmlwdGlvbiByZWNlaXZlcyBhbiBldmVudCB0aGF0IHNvbWVcbiAgICogb3RoZXIgYWN0aXZlIHN1YnNjcmlwdGlvbiB3b3VsZCB3YW50IHRvIHJlY2VpdmUsIGJvdGggcmVjZWl2ZSBpdC5cbiAgICogXG4gICAqIFRPRE8gVGhpcyBhbHNvIGFsbG93cyBmb3Igc3Vic2NyaXB0aW9ucyB0aGF0IG92ZXJsYXAgaW4gbWVhbmluZ1xuICAgKiB0byBiZSBjb2xsYXBzZWQgaW50byBvbmUuXG4gICAqIFxuICAgKiBJLmUuIGlmIGEgc3Vic2NyaXB0aW9uIHdpdGggZmlsdGVyOiBraW5kczogWzFdLCBhdXRob3JzOiBbYWxpY2VdXG4gICAqIGlzIGNyZWF0ZWQgYW5kIEVPU0VzLCBhbmQgdGhlbiBhIHN1YnNlcXVlbnQgc3Vic2NyaXB0aW9uIHdpdGhcbiAgICoga2luZHM6IFsxXSwgYXV0aG9yczogW2FsaWNlXSBpcyBjcmVhdGVkLCBvbmNlIHRoZSBzZWNvbmQgc3Vic2NyaXB0aW9uXG4gICAqIEVPU0VzIHdlIGNhbiBzYWZlbHkgY2xvc2UgaXQsIGluY3JlbWVudCBpdHMgcmVmQ291bnQgYW5kIGNsb3NlIGl0LFxuICAgKiBhbmQgd2hlbiB0aGUgZmlyc3Qgc3Vic2NyaXB0aW9uIHJlY2VpdmVzIGEgbmV3IGV2ZW50IGZyb20gQWxpY2UgdGhpc1xuICAgKiBjb2RlIHdpbGwgbWFrZSB0aGUgc2Vjb25kIHN1YnNjcmlwdGlvbiByZWNlaXZlIHRoZSBldmVudCBldmVuIHRob3VnaFxuICAgKiBpdCBoYXMgbm8gYWN0aXZlIHN1YnNjcmlwdGlvbiBvbiBhIHJlbGF5LlxuICAgKiBAcGFyYW0gZXZlbnQgUmF3IGV2ZW50IHJlY2VpdmVkIGZyb20gYSByZWxheVxuICAgKiBAcGFyYW0gcmVsYXkgUmVsYXkgdGhhdCBzZW50IHRoZSBldmVudFxuICAgKiBAcGFyYW0gb3B0aW1pc3RpY1B1Ymxpc2ggV2hldGhlciB0aGUgZXZlbnQgaXMgY29taW5nIGZyb20gYW4gb3B0aW1pc3RpYyBwdWJsaXNoXG4gICAqL1xuICBkaXNwYXRjaEV2ZW50KGV2ZW50LCByZWxheSwgb3B0aW1pc3RpY1B1Ymxpc2ggPSBmYWxzZSkge1xuICAgIGlmIChyZWxheSkgdGhpcy5zZWVuRXZlbnQoZXZlbnQuaWQsIHJlbGF5KTtcbiAgICBjb25zdCBzdWJzY3JpcHRpb25zID0gdGhpcy5zdWJzY3JpcHRpb25zLnZhbHVlcygpO1xuICAgIGNvbnN0IG1hdGNoaW5nU3VicyA9IFtdO1xuICAgIGZvciAoY29uc3Qgc3ViIG9mIHN1YnNjcmlwdGlvbnMpIHtcbiAgICAgIGlmIChtYXRjaEZpbHRlcnMoc3ViLmZpbHRlcnMsIGV2ZW50KSkge1xuICAgICAgICBtYXRjaGluZ1N1YnMucHVzaChzdWIpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IHN1YiBvZiBtYXRjaGluZ1N1YnMpIHtcbiAgICAgIHN1Yi5ldmVudFJlY2VpdmVkKGV2ZW50LCByZWxheSwgZmFsc2UsIG9wdGltaXN0aWNQdWJsaXNoKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9uZGsvYWN0aXZlLXVzZXIudHNcbmltcG9ydCBjcmVhdGVEZWJ1ZzMgZnJvbSBcImRlYnVnXCI7XG52YXIgZGVidWc2ID0gY3JlYXRlRGVidWczKFwibmRrOmFjdGl2ZS11c2VyXCIpO1xuYXN5bmMgZnVuY3Rpb24gZ2V0VXNlclJlbGF5TGlzdCh1c2VyKSB7XG4gIGlmICghdGhpcy5hdXRvQ29ubmVjdFVzZXJSZWxheXMpIHJldHVybjtcbiAgY29uc3QgdXNlclJlbGF5cyA9IGF3YWl0IGdldFJlbGF5TGlzdEZvclVzZXIodXNlci5wdWJrZXksIHRoaXMpO1xuICBpZiAoIXVzZXJSZWxheXMpIHJldHVybjtcbiAgZm9yIChjb25zdCB1cmwgb2YgdXNlclJlbGF5cy5yZWxheXMpIHtcbiAgICBsZXQgcmVsYXkgPSB0aGlzLnBvb2wucmVsYXlzLmdldCh1cmwpO1xuICAgIGlmICghcmVsYXkpIHtcbiAgICAgIHJlbGF5ID0gbmV3IE5ES1JlbGF5KHVybCwgdGhpcy5yZWxheUF1dGhEZWZhdWx0UG9saWN5LCB0aGlzKTtcbiAgICAgIHRoaXMucG9vbC5hZGRSZWxheShyZWxheSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB1c2VyUmVsYXlzO1xufVxuYXN5bmMgZnVuY3Rpb24gc2V0QWN0aXZlVXNlcih1c2VyKSB7XG4gIGNvbnN0IHBvb2wgPSB0aGlzLm91dGJveFBvb2wgfHwgdGhpcy5wb29sO1xuICBpZiAocG9vbC5jb25uZWN0ZWRSZWxheXMubGVuZ3RoID4gMCkge1xuICAgIHNldEFjdGl2ZVVzZXJDb25uZWN0ZWQuY2FsbCh0aGlzLCB1c2VyKTtcbiAgfSBlbHNlIHtcbiAgICBwb29sLm9uY2UoXCJjb25uZWN0XCIsICgpID0+IHtcbiAgICAgIHNldEFjdGl2ZVVzZXJDb25uZWN0ZWQuY2FsbCh0aGlzLCB1c2VyKTtcbiAgICB9KTtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gc2V0QWN0aXZlVXNlckNvbm5lY3RlZCh1c2VyKSB7XG4gIGNvbnN0IHVzZXJSZWxheXMgPSBhd2FpdCBnZXRVc2VyUmVsYXlMaXN0LmNhbGwodGhpcywgdXNlcik7XG4gIGNvbnN0IGZpbHRlcnMgPSBbXG4gICAge1xuICAgICAga2luZHM6IFsxMDAwNiAvKiBCbG9ja1JlbGF5TGlzdCAqL10sXG4gICAgICBhdXRob3JzOiBbdXNlci5wdWJrZXldXG4gICAgfVxuICBdO1xuICBpZiAodGhpcy5hdXRvRmV0Y2hVc2VyTXV0ZWxpc3QpIHtcbiAgICBmaWx0ZXJzWzBdLmtpbmRzLnB1c2goMWU0IC8qIE11dGVMaXN0ICovKTtcbiAgfVxuICBjb25zdCByZWxheVNldCA9IHVzZXJSZWxheXMgPyB1c2VyUmVsYXlzLnJlbGF5U2V0IDogdm9pZCAwO1xuICBjb25zdCBzdWIgPSB0aGlzLnN1YnNjcmliZShcbiAgICBmaWx0ZXJzLFxuICAgIHsgc3ViSWQ6IFwiYWN0aXZlLXVzZXItc2V0dGluZ3NcIiwgY2xvc2VPbkVvc2U6IHRydWUgfSxcbiAgICByZWxheVNldCxcbiAgICBmYWxzZVxuICApO1xuICBjb25zdCBldmVudHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBzdWIub24oXCJldmVudFwiLCAoZXZlbnQpID0+IHtcbiAgICBjb25zdCBwcmV2RXZlbnQgPSBldmVudHMuZ2V0KGV2ZW50LmtpbmQpO1xuICAgIGlmIChwcmV2RXZlbnQgJiYgcHJldkV2ZW50LmNyZWF0ZWRfYXQgPj0gZXZlbnQuY3JlYXRlZF9hdCkgcmV0dXJuO1xuICAgIGV2ZW50cy5zZXQoZXZlbnQua2luZCwgZXZlbnQpO1xuICB9KTtcbiAgc3ViLm9uKFwiZW9zZVwiLCAoKSA9PiB7XG4gICAgZm9yIChjb25zdCBldmVudCBvZiBldmVudHMudmFsdWVzKCkpIHtcbiAgICAgIHByb2Nlc3NFdmVudC5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICB9XG4gIH0pO1xuICBzdWIuc3RhcnQoKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NFdmVudChldmVudCkge1xuICBpZiAoZXZlbnQua2luZCA9PT0gMTAwMDYgLyogQmxvY2tSZWxheUxpc3QgKi8pIHtcbiAgICBwcm9jZXNzQmxvY2tSZWxheUxpc3QuY2FsbCh0aGlzLCBldmVudCk7XG4gIH0gZWxzZSBpZiAoZXZlbnQua2luZCA9PT0gMWU0IC8qIE11dGVMaXN0ICovKSB7XG4gICAgcHJvY2Vzc011dGVMaXN0LmNhbGwodGhpcywgZXZlbnQpO1xuICB9XG59XG5mdW5jdGlvbiBwcm9jZXNzQmxvY2tSZWxheUxpc3QoZXZlbnQpIHtcbiAgY29uc3QgbGlzdCA9IGxpc3RzX2RlZmF1bHQuZnJvbShldmVudCk7XG4gIGZvciAoY29uc3QgaXRlbSBvZiBsaXN0Lml0ZW1zKSB7XG4gICAgdGhpcy5wb29sLmJsYWNrbGlzdFJlbGF5VXJscy5hZGQoaXRlbVswXSk7XG4gIH1cbiAgZGVidWc2KFwiQWRkZWQgJWQgcmVsYXlzIHRvIHJlbGF5IGJsYWNrbGlzdFwiLCBsaXN0Lml0ZW1zLmxlbmd0aCk7XG59XG5mdW5jdGlvbiBwcm9jZXNzTXV0ZUxpc3QobXV0ZUxpc3QpIHtcbiAgY29uc3QgbGlzdCA9IGxpc3RzX2RlZmF1bHQuZnJvbShtdXRlTGlzdCk7XG4gIGZvciAoY29uc3QgaXRlbSBvZiBsaXN0Lml0ZW1zKSB7XG4gICAgdGhpcy5tdXRlZElkcy5zZXQoaXRlbVsxXSwgaXRlbVswXSk7XG4gIH1cbiAgZGVidWc2KFwiQWRkZWQgJWQgdXNlcnMgdG8gbXV0ZSBsaXN0XCIsIGxpc3QuaXRlbXMubGVuZ3RoKTtcbn1cblxuLy8gc3JjL25kay9pbmRleC50c1xudmFyIERFRkFVTFRfT1VUQk9YX1JFTEFZUyA9IFtcIndzczovL3B1cnBsZXBhZy5lcy9cIiwgXCJ3c3M6Ly9ub3MubG9sL1wiXTtcbnZhciBERUZBVUxUX0JMQUNLTElTVEVEX1JFTEFZUyA9IFtcbiAgXCJ3c3M6Ly9icmIuaW8vXCIsXG4gIC8vIEJSQlxuICBcIndzczovL25vc3RyLm11dGlueXdhbGxldC5jb20vXCJcbiAgLy8gRG9uJ3QgdHJ5IHRvIHJlYWQgZnJvbSB0aGlzIHJlbGF5IHNpbmNlIGl0J3MgYSB3cml0ZS1vbmx5IHJlbGF5XG4gIC8vIFwid3NzOi8vcHVycGxlcGFnLmVzL1wiLCAvLyBUaGlzIGlzIGEgaGFjaywgc2luY2UgdGhpcyBpcyBhIG1vc3RseSByZWFkLW9ubHkgcmVsYXksIGJ1dCBub3QgZnVsbHkuIE9uY2Ugd2UgaGF2ZSByZWxheSByb3V0aW5nIHRoaXMgY2FuIGJlIHJlbW92ZWQgc28gaXQgb25seSByZWNlaXZlcyB0aGUgc3VwcG9ydGVkIGtpbmRzXG5dO1xudmFyIE5ESyA9IGNsYXNzIGV4dGVuZHMgRXZlbnRFbWl0dGVyOCB7XG4gIF9leHBsaWNpdFJlbGF5VXJscztcbiAgYmxhY2tsaXN0UmVsYXlVcmxzO1xuICBwb29sO1xuICBvdXRib3hQb29sO1xuICBfc2lnbmVyO1xuICBfYWN0aXZlVXNlcjtcbiAgY2FjaGVBZGFwdGVyO1xuICBkZWJ1ZztcbiAgZGV2V3JpdGVSZWxheVNldDtcbiAgb3V0Ym94VHJhY2tlcjtcbiAgbXV0ZWRJZHM7XG4gIGNsaWVudE5hbWU7XG4gIGNsaWVudE5pcDg5O1xuICBxdWV1ZXNaYXBDb25maWc7XG4gIHF1ZXVlc05pcDA1O1xuICBhc3luY1NpZ1ZlcmlmaWNhdGlvbiA9IGZhbHNlO1xuICBpbml0aWFsVmFsaWRhdGlvblJhdGlvID0gMTtcbiAgbG93ZXN0VmFsaWRhdGlvblJhdGlvID0gMTtcbiAgdmFsaWRhdGlvblJhdGlvRm47XG4gIHN1Yk1hbmFnZXI7XG4gIHB1Ymxpc2hpbmdGYWlsdXJlSGFuZGxlZCA9IGZhbHNlO1xuICBwb29scyA9IFtdO1xuICAvKipcbiAgICogRGVmYXVsdCByZWxheS1hdXRoIHBvbGljeSB0aGF0IHdpbGwgYmUgdXNlZCB3aGVuIGEgcmVsYXkgcmVxdWVzdHMgYXV0aGVudGljYXRpb24sXG4gICAqIGlmIG5vIG90aGVyIHBvbGljeSBpcyBzcGVjaWZpZWQgZm9yIHRoYXQgcmVsYXkuXG4gICAqXG4gICAqIEBleGFtcGxlIERpc2Nvbm5lY3QgZnJvbSByZWxheXMgdGhhdCByZXF1ZXN0IGF1dGhlbnRpY2F0aW9uOlxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIG5kay5yZWxheUF1dGhEZWZhdWx0UG9saWN5ID0gTkRLQXV0aFBvbGljaWVzLmRpc2Nvbm5lY3QobmRrLnBvb2wpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQGV4YW1wbGUgU2lnbiBpbiB0byByZWxheXMgdGhhdCByZXF1ZXN0IGF1dGhlbnRpY2F0aW9uOlxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIG5kay5yZWxheUF1dGhEZWZhdWx0UG9saWN5ID0gTkRLQXV0aFBvbGljaWVzLnNpZ25Jbih7bmRrfSlcbiAgICogYGBgXG4gICAqXG4gICAqIEBleGFtcGxlIFNpZ24gaW4gdG8gcmVsYXlzIHRoYXQgcmVxdWVzdCBhdXRoZW50aWNhdGlvbiwgYXNraW5nIHRoZSB1c2VyIGZvciBjb25maXJtYXRpb246XG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogbmRrLnJlbGF5QXV0aERlZmF1bHRQb2xpY3kgPSAocmVsYXk6IE5ES1JlbGF5KSA9PiB7XG4gICAqICAgICBjb25zdCBzaWduSW4gPSBOREtBdXRoUG9saWNpZXMuc2lnbkluKHtuZGt9KTtcbiAgICogICAgIGlmIChjb25maXJtKGBSZWxheSAke3JlbGF5LnVybH0gaXMgcmVxdWVzdGluZyBhdXRoZW50aWNhdGlvbiwgZG8geW91IHdhbnQgdG8gc2lnbiBpbj9gKSkge1xuICAgKiAgICAgICAgc2lnbkluKHJlbGF5KTtcbiAgICogICAgIH1cbiAgICogfVxuICAgKiBgYGBcbiAgICovXG4gIHJlbGF5QXV0aERlZmF1bHRQb2xpY3k7XG4gIC8qKlxuICAgKiBGZXRjaCBmdW5jdGlvbiB0byB1c2UgZm9yIEhUVFAgcmVxdWVzdHMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogaW1wb3J0IGZldGNoIGZyb20gXCJub2RlLWZldGNoXCI7XG4gICAqXG4gICAqIG5kay5odHRwRmV0Y2ggPSBmZXRjaDtcbiAgICogYGBgXG4gICAqL1xuICBodHRwRmV0Y2g7XG4gIC8qKlxuICAgKiBQcm92aWRlIGEgY2FsbGVyIGZ1bmN0aW9uIHRvIHJlY2VpdmUgYWxsIG5ldHdvcmtpbmcgdHJhZmZpYyBmcm9tIHJlbGF5c1xuICAgKi9cbiAgbmV0RGVidWc7XG4gIGF1dG9Db25uZWN0VXNlclJlbGF5cyA9IHRydWU7XG4gIGF1dG9GZXRjaFVzZXJNdXRlbGlzdCA9IHRydWU7XG4gIHdhbGxldENvbmZpZztcbiAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmRlYnVnID0gb3B0cy5kZWJ1ZyB8fCBkZWJ1ZzcoXCJuZGtcIik7XG4gICAgdGhpcy5uZXREZWJ1ZyA9IG9wdHMubmV0RGVidWc7XG4gICAgdGhpcy5fZXhwbGljaXRSZWxheVVybHMgPSBvcHRzLmV4cGxpY2l0UmVsYXlVcmxzIHx8IFtdO1xuICAgIHRoaXMuYmxhY2tsaXN0UmVsYXlVcmxzID0gb3B0cy5ibGFja2xpc3RSZWxheVVybHMgfHwgREVGQVVMVF9CTEFDS0xJU1RFRF9SRUxBWVM7XG4gICAgdGhpcy5zdWJNYW5hZ2VyID0gbmV3IE5ES1N1YnNjcmlwdGlvbk1hbmFnZXIoKTtcbiAgICB0aGlzLnBvb2wgPSBuZXcgTkRLUG9vbChcbiAgICAgIG9wdHMuZXhwbGljaXRSZWxheVVybHMgfHwgW10sXG4gICAgICBbXSxcbiAgICAgIHRoaXNcbiAgICApO1xuICAgIHRoaXMucG9vbC5uYW1lID0gXCJNYWluXCI7XG4gICAgdGhpcy5wb29sLm9uKFwicmVsYXk6YXV0aFwiLCBhc3luYyAocmVsYXksIGNoYWxsZW5nZSkgPT4ge1xuICAgICAgaWYgKHRoaXMucmVsYXlBdXRoRGVmYXVsdFBvbGljeSkge1xuICAgICAgICBhd2FpdCB0aGlzLnJlbGF5QXV0aERlZmF1bHRQb2xpY3kocmVsYXksIGNoYWxsZW5nZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5hdXRvQ29ubmVjdFVzZXJSZWxheXMgPSBvcHRzLmF1dG9Db25uZWN0VXNlclJlbGF5cyA/PyB0cnVlO1xuICAgIHRoaXMuYXV0b0ZldGNoVXNlck11dGVsaXN0ID0gb3B0cy5hdXRvRmV0Y2hVc2VyTXV0ZWxpc3QgPz8gdHJ1ZTtcbiAgICB0aGlzLmNsaWVudE5hbWUgPSBvcHRzLmNsaWVudE5hbWU7XG4gICAgdGhpcy5jbGllbnROaXA4OSA9IG9wdHMuY2xpZW50TmlwODk7XG4gICAgdGhpcy5yZWxheUF1dGhEZWZhdWx0UG9saWN5ID0gb3B0cy5yZWxheUF1dGhEZWZhdWx0UG9saWN5O1xuICAgIGlmIChvcHRzLmVuYWJsZU91dGJveE1vZGVsKSB7XG4gICAgICB0aGlzLm91dGJveFBvb2wgPSBuZXcgTkRLUG9vbChcbiAgICAgICAgb3B0cy5vdXRib3hSZWxheVVybHMgfHwgREVGQVVMVF9PVVRCT1hfUkVMQVlTLFxuICAgICAgICBbXSxcbiAgICAgICAgdGhpcyxcbiAgICAgICAge1xuICAgICAgICAgIGRlYnVnOiB0aGlzLmRlYnVnLmV4dGVuZChcIm91dGJveC1wb29sXCIpLFxuICAgICAgICAgIG5hbWU6IFwiT3V0Ym94IFBvb2xcIlxuICAgICAgICB9XG4gICAgICApO1xuICAgICAgdGhpcy5vdXRib3hUcmFja2VyID0gbmV3IE91dGJveFRyYWNrZXIodGhpcyk7XG4gICAgfVxuICAgIHRoaXMuc2lnbmVyID0gb3B0cy5zaWduZXI7XG4gICAgdGhpcy5jYWNoZUFkYXB0ZXIgPSBvcHRzLmNhY2hlQWRhcHRlcjtcbiAgICB0aGlzLm11dGVkSWRzID0gb3B0cy5tdXRlZElkcyB8fCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGlmIChvcHRzLmRldldyaXRlUmVsYXlVcmxzKSB7XG4gICAgICB0aGlzLmRldldyaXRlUmVsYXlTZXQgPSBOREtSZWxheVNldC5mcm9tUmVsYXlVcmxzKG9wdHMuZGV2V3JpdGVSZWxheVVybHMsIHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLnF1ZXVlc1phcENvbmZpZyA9IG5ldyBRdWV1ZShcInphcHNcIiwgMyk7XG4gICAgdGhpcy5xdWV1ZXNOaXAwNSA9IG5ldyBRdWV1ZShcIm5pcDA1XCIsIDEwKTtcbiAgICB0aGlzLnNpZ25hdHVyZVZlcmlmaWNhdGlvbldvcmtlciA9IG9wdHMuc2lnbmF0dXJlVmVyaWZpY2F0aW9uV29ya2VyO1xuICAgIHRoaXMuaW5pdGlhbFZhbGlkYXRpb25SYXRpbyA9IG9wdHMuaW5pdGlhbFZhbGlkYXRpb25SYXRpbyB8fCAxO1xuICAgIHRoaXMubG93ZXN0VmFsaWRhdGlvblJhdGlvID0gb3B0cy5sb3dlc3RWYWxpZGF0aW9uUmF0aW8gfHwgMTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5odHRwRmV0Y2ggPSBmZXRjaDtcbiAgICB9IGNhdGNoIHtcbiAgICB9XG4gIH1cbiAgc2V0IGV4cGxpY2l0UmVsYXlVcmxzKHVybHMpIHtcbiAgICB0aGlzLl9leHBsaWNpdFJlbGF5VXJscyA9IHVybHM7XG4gICAgdGhpcy5wb29sLnJlbGF5VXJscyA9IHVybHM7XG4gIH1cbiAgZ2V0IGV4cGxpY2l0UmVsYXlVcmxzKCkge1xuICAgIHJldHVybiB0aGlzLl9leHBsaWNpdFJlbGF5VXJscyB8fCBbXTtcbiAgfVxuICBzZXQgc2lnbmF0dXJlVmVyaWZpY2F0aW9uV29ya2VyKHdvcmtlcjIpIHtcbiAgICB0aGlzLmFzeW5jU2lnVmVyaWZpY2F0aW9uID0gISF3b3JrZXIyO1xuICAgIGlmICh3b3JrZXIyKSB7XG4gICAgICBzaWduYXR1cmVWZXJpZmljYXRpb25Jbml0KHdvcmtlcjIpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQWRkcyBhbiBleHBsaWNpdCByZWxheSB0byB0aGUgcG9vbC5cbiAgICogQHBhcmFtIHVybFxuICAgKiBAcGFyYW0gcmVsYXlBdXRoUG9saWN5IEF1dGhlbnRpY2F0aW9uIHBvbGljeSB0byB1c2UgaWYgZGlmZmVyZW50IGZyb20gdGhlIGRlZmF1bHRcbiAgICogQHBhcmFtIGNvbm5lY3QgV2hldGhlciB0byBjb25uZWN0IHRvIHRoZSByZWxheSBhdXRvbWF0aWNhbGx5XG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBhZGRFeHBsaWNpdFJlbGF5KHVybE9yUmVsYXksIHJlbGF5QXV0aFBvbGljeSwgY29ubmVjdCA9IHRydWUpIHtcbiAgICBsZXQgcmVsYXk7XG4gICAgaWYgKHR5cGVvZiB1cmxPclJlbGF5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZWxheSA9IG5ldyBOREtSZWxheSh1cmxPclJlbGF5LCByZWxheUF1dGhQb2xpY3ksIHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWxheSA9IHVybE9yUmVsYXk7XG4gICAgfVxuICAgIHRoaXMucG9vbC5hZGRSZWxheShyZWxheSwgY29ubmVjdCk7XG4gICAgdGhpcy5leHBsaWNpdFJlbGF5VXJscy5wdXNoKHJlbGF5LnVybCk7XG4gICAgcmV0dXJuIHJlbGF5O1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4geyByZWxheUNvdW50OiB0aGlzLnBvb2wucmVsYXlzLnNpemUgfS50b1N0cmluZygpO1xuICB9XG4gIGdldCBhY3RpdmVVc2VyKCkge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmVVc2VyO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBhY3RpdmUgdXNlciBmb3IgdGhpcyBOREsgaW5zdGFuY2UsIHR5cGljYWxseSB0aGlzIHdpbGwgYmVcbiAgICogY2FsbGVkIHdoZW4gYXNzaWduaW5nIGEgc2lnbmVyIHRvIHRoZSBOREsgaW5zdGFuY2UuXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gd2lsbCBhdXRvbWF0aWNhbGx5IGNvbm5lY3QgdG8gdGhlIHVzZXIncyByZWxheXMgaWZcbiAgICogYGF1dG9Db25uZWN0VXNlclJlbGF5c2AgaXMgc2V0IHRvIHRydWUuXG4gICAqXG4gICAqIEl0IHdpbGwgYWxzbyBmZXRjaCB0aGUgdXNlcidzIG11dGVsaXN0IGlmIGBhdXRvRmV0Y2hVc2VyTXV0ZWxpc3RgIGlzIHNldCB0byB0cnVlLlxuICAgKi9cbiAgc2V0IGFjdGl2ZVVzZXIodXNlcikge1xuICAgIGNvbnN0IGRpZmZlcmVudFVzZXIgPSB0aGlzLl9hY3RpdmVVc2VyPy5wdWJrZXkgIT09IHVzZXI/LnB1YmtleTtcbiAgICB0aGlzLl9hY3RpdmVVc2VyID0gdXNlcjtcbiAgICBpZiAodXNlciAmJiBkaWZmZXJlbnRVc2VyKSB7XG4gICAgICBzZXRBY3RpdmVVc2VyLmNhbGwodGhpcywgdXNlcik7XG4gICAgfSBlbHNlIGlmICghdXNlcikge1xuICAgICAgdGhpcy5tdXRlZElkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgfVxuICB9XG4gIGdldCBzaWduZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NpZ25lcjtcbiAgfVxuICBzZXQgc2lnbmVyKG5ld1NpZ25lcikge1xuICAgIHRoaXMuX3NpZ25lciA9IG5ld1NpZ25lcjtcbiAgICBpZiAobmV3U2lnbmVyKSB0aGlzLmVtaXQoXCJzaWduZXI6cmVhZHlcIiwgbmV3U2lnbmVyKTtcbiAgICBuZXdTaWduZXI/LnVzZXIoKS50aGVuKCh1c2VyKSA9PiB7XG4gICAgICB1c2VyLm5kayA9IHRoaXM7XG4gICAgICB0aGlzLmFjdGl2ZVVzZXIgPSB1c2VyO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDb25uZWN0IHRvIHJlbGF5cyB3aXRoIG9wdGlvbmFsIHRpbWVvdXQuXG4gICAqIElmIHRoZSB0aW1lb3V0IGlzIHJlYWNoZWQsIHRoZSBjb25uZWN0aW9uIHdpbGwgYmUgY29udGludWVkIHRvIGJlIGVzdGFibGlzaGVkIGluIHRoZSBiYWNrZ3JvdW5kLlxuICAgKi9cbiAgYXN5bmMgY29ubmVjdCh0aW1lb3V0TXMpIHtcbiAgICBpZiAodGhpcy5fc2lnbmVyICYmIHRoaXMuYXV0b0Nvbm5lY3RVc2VyUmVsYXlzKSB7XG4gICAgICB0aGlzLmRlYnVnKFxuICAgICAgICBcIkF0dGVtcHRpbmcgdG8gY29ubmVjdCB0byB1c2VyIHJlbGF5cyBzcGVjaWZpZWQgYnkgc2lnbmVyICVvXCIsXG4gICAgICAgIGF3YWl0IHRoaXMuX3NpZ25lci5yZWxheXM/Lih0aGlzKVxuICAgICAgKTtcbiAgICAgIGlmICh0aGlzLl9zaWduZXIucmVsYXlzKSB7XG4gICAgICAgIGNvbnN0IHJlbGF5cyA9IGF3YWl0IHRoaXMuX3NpZ25lci5yZWxheXModGhpcyk7XG4gICAgICAgIHJlbGF5cy5mb3JFYWNoKChyZWxheSkgPT4gdGhpcy5wb29sLmFkZFJlbGF5KHJlbGF5KSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGNvbm5lY3Rpb25zID0gW3RoaXMucG9vbC5jb25uZWN0KHRpbWVvdXRNcyldO1xuICAgIGlmICh0aGlzLm91dGJveFBvb2wpIHtcbiAgICAgIGNvbm5lY3Rpb25zLnB1c2godGhpcy5vdXRib3hQb29sLmNvbm5lY3QodGltZW91dE1zKSk7XG4gICAgfVxuICAgIHRoaXMuZGVidWcoXCJDb25uZWN0aW5nIHRvIHJlbGF5cyAlb1wiLCB7IHRpbWVvdXRNcyB9KTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGxTZXR0bGVkKGNvbm5lY3Rpb25zKS50aGVuKCgpID0+IHtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogR2V0IGEgTkRLVXNlciBvYmplY3RcbiAgICpcbiAgICogQHBhcmFtIG9wdHNcbiAgICogQHJldHVybnNcbiAgICovXG4gIGdldFVzZXIob3B0cykge1xuICAgIGNvbnN0IHVzZXIgPSBuZXcgTkRLVXNlcihvcHRzKTtcbiAgICB1c2VyLm5kayA9IHRoaXM7XG4gICAgcmV0dXJuIHVzZXI7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhIE5ES1VzZXIgZnJvbSBhIE5JUDA1XG4gICAqIEBwYXJhbSBuaXAwNSBOSVAtMDUgSURcbiAgICogQHBhcmFtIHNraXBDYWNoZSBTa2lwIGNhY2hlXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBhc3luYyBnZXRVc2VyRnJvbU5pcDA1KG5pcDA1LCBza2lwQ2FjaGUgPSBmYWxzZSkge1xuICAgIHJldHVybiBOREtVc2VyLmZyb21OaXAwNShuaXAwNSwgdGhpcywgc2tpcENhY2hlKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IHN1YnNjcmlwdGlvbi4gU3Vic2NyaXB0aW9ucyBhdXRvbWF0aWNhbGx5IHN0YXJ0LCB5b3UgY2FuIG1ha2UgdGhlbSBhdXRvbWF0aWNhbGx5IGNsb3NlIHdoZW4gYWxsIHJlbGF5cyBzZW5kIGJhY2sgYW4gRU9TRSBieSBzZXR0aW5nIGBvcHRzLmNsb3NlT25Fb3NlYCB0byBgdHJ1ZWApXG4gICAqXG4gICAqIEBwYXJhbSBmaWx0ZXJzXG4gICAqIEBwYXJhbSBvcHRzXG4gICAqIEBwYXJhbSByZWxheVNldCBleHBsaWNpdCByZWxheSBzZXQgdG8gdXNlXG4gICAqIEBwYXJhbSBhdXRvU3RhcnQgYXV0b21hdGljYWxseSBzdGFydCB0aGUgc3Vic2NyaXB0aW9uIC0tIHRoaXMgY2FuIGJlIGEgYm9vbGVhbiBvciBhbiBvYmplY3Qgd2l0aCBgb25FdmVudGAgYW5kIGBvbkVvc2VgIGhhbmRsZXJzXG4gICAqIEByZXR1cm5zIE5ES1N1YnNjcmlwdGlvblxuICAgKi9cbiAgc3Vic2NyaWJlKGZpbHRlcnMsIG9wdHMsIHJlbGF5U2V0LCBhdXRvU3RhcnQgPSB0cnVlKSB7XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gbmV3IE5ES1N1YnNjcmlwdGlvbih0aGlzLCBmaWx0ZXJzLCBvcHRzLCByZWxheVNldCk7XG4gICAgdGhpcy5zdWJNYW5hZ2VyLmFkZChzdWJzY3JpcHRpb24pO1xuICAgIGNvbnN0IHBvb2wgPSBvcHRzPy5wb29sID8/IHRoaXMucG9vbDtcbiAgICBpZiAocmVsYXlTZXQpIHtcbiAgICAgIGZvciAoY29uc3QgcmVsYXkgb2YgcmVsYXlTZXQucmVsYXlzKSB7XG4gICAgICAgIHBvb2wudXNlVGVtcG9yYXJ5UmVsYXkocmVsYXksIHZvaWQgMCwgc3Vic2NyaXB0aW9uLmZpbHRlcnMpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5vdXRib3hQb29sICYmIHN1YnNjcmlwdGlvbi5oYXNBdXRob3JzRmlsdGVyKCkpIHtcbiAgICAgIGNvbnN0IGF1dGhvcnMgPSBzdWJzY3JpcHRpb24uZmlsdGVycy5maWx0ZXIoKGZpbHRlcikgPT4gZmlsdGVyLmF1dGhvcnMgJiYgZmlsdGVyLmF1dGhvcnM/Lmxlbmd0aCA+IDApLm1hcCgoZmlsdGVyKSA9PiBmaWx0ZXIuYXV0aG9ycykuZmxhdCgpO1xuICAgICAgdGhpcy5vdXRib3hUcmFja2VyPy50cmFja1VzZXJzKGF1dGhvcnMpO1xuICAgIH1cbiAgICBpZiAoYXV0b1N0YXJ0KSB7XG4gICAgICBsZXQgZXZlbnRzSGFuZGxlcjtcbiAgICAgIGlmICh0eXBlb2YgYXV0b1N0YXJ0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGlmIChhdXRvU3RhcnQub25FdmVudCkgc3Vic2NyaXB0aW9uLm9uKFwiZXZlbnRcIiwgYXV0b1N0YXJ0Lm9uRXZlbnQpO1xuICAgICAgICBpZiAoYXV0b1N0YXJ0Lm9uRW9zZSkgc3Vic2NyaXB0aW9uLm9uKFwiZW9zZVwiLCBhdXRvU3RhcnQub25Fb3NlKTtcbiAgICAgICAgaWYgKGF1dG9TdGFydC5vbkV2ZW50cykgZXZlbnRzSGFuZGxlciA9IGF1dG9TdGFydC5vbkV2ZW50cztcbiAgICAgIH1cbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjb25zdCBjYWNoZWRFdmVudHMgPSBzdWJzY3JpcHRpb24uc3RhcnQoIWV2ZW50c0hhbmRsZXIpO1xuICAgICAgICBpZiAoY2FjaGVkRXZlbnRzICYmICEhZXZlbnRzSGFuZGxlcikgZXZlbnRzSGFuZGxlcihjYWNoZWRFdmVudHMpO1xuICAgICAgfSwgMCk7XG4gICAgfVxuICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gIH1cbiAgLyoqXG4gICAqIFB1Ymxpc2ggYW4gZXZlbnQgdG8gYSByZWxheVxuICAgKiBAcGFyYW0gZXZlbnQgZXZlbnQgdG8gcHVibGlzaFxuICAgKiBAcGFyYW0gcmVsYXlTZXQgZXhwbGljaXQgcmVsYXkgc2V0IHRvIHVzZVxuICAgKiBAcGFyYW0gdGltZW91dE1zIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIHRvIHdhaXQgZm9yIHRoZSBldmVudCB0byBiZSBwdWJsaXNoZWRcbiAgICogQHJldHVybnMgVGhlIHJlbGF5cyB0aGUgZXZlbnQgd2FzIHB1Ymxpc2hlZCB0b1xuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYGV2ZW50LnB1Ymxpc2goKWAgaW5zdGVhZFxuICAgKi9cbiAgYXN5bmMgcHVibGlzaChldmVudCwgcmVsYXlTZXQsIHRpbWVvdXRNcykge1xuICAgIHRoaXMuZGVidWcoXCJEZXByZWNhdGVkOiBVc2UgYGV2ZW50LnB1Ymxpc2goKWAgaW5zdGVhZFwiKTtcbiAgICByZXR1cm4gZXZlbnQucHVibGlzaChyZWxheVNldCwgdGltZW91dE1zKTtcbiAgfVxuICAvKipcbiAgICogQXR0ZW1wdHMgdG8gZmV0Y2ggYW4gZXZlbnQgZnJvbSBhIHRhZywgZm9sbG93aW5nIHJlbGF5IGhpbnRzIGFuZFxuICAgKiBvdGhlciBiZXN0IHByYWN0aWNlcy5cbiAgICogQHBhcmFtIHRhZyBUYWcgdG8gZmV0Y2ggdGhlIGV2ZW50IGZyb21cbiAgICogQHBhcmFtIG9yaWdpbmFsRXZlbnQgRXZlbnQgd2hlcmUgdGhlIHRhZyBjYW1lIGZyb21cbiAgICogQHBhcmFtIHN1Yk9wdHMgU3Vic2NyaXB0aW9uIG9wdGlvbnMgdG8gdXNlIHdoZW4gZmV0Y2hpbmcgdGhlIGV2ZW50XG4gICAqIEBwYXJhbSBmYWxsYmFjayBGYWxsYmFjayBvcHRpb25zIHRvIHVzZSB3aGVuIHRoZSBoaW50IHJlbGF5IGRvZXNuJ3QgcmVzcG9uZFxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgZmV0Y2hFdmVudEZyb21UYWcgPSBmZXRjaEV2ZW50RnJvbVRhZy5iaW5kKHRoaXMpO1xuICAvKipcbiAgICogRmV0Y2ggYW4gZXZlbnQgZnJvbSB0aGUgY2FjaGUgc3luY2hyb25vdXNseS5cbiAgICogQHBhcmFtIGlkT3JGaWx0ZXIgZXZlbnQgaWQgaW4gYmVjaDMyIGZvcm1hdCBvciBmaWx0ZXJcbiAgICogQHJldHVybnMgZXZlbnRzIGZyb20gdGhlIGNhY2hlIG9yIG51bGwgaWYgdGhlIGNhY2hlIGlzIGVtcHR5XG4gICAqL1xuICBmZXRjaEV2ZW50U3luYyhpZE9yRmlsdGVyKSB7XG4gICAgaWYgKCF0aGlzLmNhY2hlQWRhcHRlcikgdGhyb3cgbmV3IEVycm9yKFwiQ2FjaGUgYWRhcHRlciBub3Qgc2V0XCIpO1xuICAgIGxldCBmaWx0ZXJzO1xuICAgIGlmICh0eXBlb2YgaWRPckZpbHRlciA9PT0gXCJzdHJpbmdcIikgZmlsdGVycyA9IFtmaWx0ZXJGcm9tSWQoaWRPckZpbHRlcildO1xuICAgIGVsc2UgZmlsdGVycyA9IGlkT3JGaWx0ZXI7XG4gICAgY29uc3Qgc3ViID0gbmV3IE5ES1N1YnNjcmlwdGlvbih0aGlzLCBmaWx0ZXJzKTtcbiAgICBjb25zdCBldmVudHMgPSB0aGlzLmNhY2hlQWRhcHRlci5xdWVyeShzdWIpO1xuICAgIGlmIChldmVudHMgaW5zdGFuY2VvZiBQcm9taXNlKSB0aHJvdyBuZXcgRXJyb3IoXCJDYWNoZSBhZGFwdGVyIGlzIGFzeW5jXCIpO1xuICAgIHJldHVybiBldmVudHMubWFwKChlKSA9PiB7XG4gICAgICBlLm5kayA9IHRoaXM7XG4gICAgICByZXR1cm4gZTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRmV0Y2ggYSBzaW5nbGUgZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSBpZE9yRmlsdGVyIGV2ZW50IGlkIGluIGJlY2gzMiBmb3JtYXQgb3IgZmlsdGVyXG4gICAqIEBwYXJhbSBvcHRzIHN1YnNjcmlwdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSByZWxheVNldE9yUmVsYXkgZXhwbGljaXQgcmVsYXkgc2V0IHRvIHVzZVxuICAgKi9cbiAgYXN5bmMgZmV0Y2hFdmVudChpZE9yRmlsdGVyLCBvcHRzLCByZWxheVNldE9yUmVsYXkpIHtcbiAgICBsZXQgZmlsdGVycztcbiAgICBsZXQgcmVsYXlTZXQ7XG4gICAgaWYgKHJlbGF5U2V0T3JSZWxheSBpbnN0YW5jZW9mIE5ES1JlbGF5KSB7XG4gICAgICByZWxheVNldCA9IG5ldyBOREtSZWxheVNldCgvKiBAX19QVVJFX18gKi8gbmV3IFNldChbcmVsYXlTZXRPclJlbGF5XSksIHRoaXMpO1xuICAgIH0gZWxzZSBpZiAocmVsYXlTZXRPclJlbGF5IGluc3RhbmNlb2YgTkRLUmVsYXlTZXQpIHtcbiAgICAgIHJlbGF5U2V0ID0gcmVsYXlTZXRPclJlbGF5O1xuICAgIH1cbiAgICBpZiAoIXJlbGF5U2V0T3JSZWxheSAmJiB0eXBlb2YgaWRPckZpbHRlciA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKCFpc05pcDMzQVZhbHVlKGlkT3JGaWx0ZXIpKSB7XG4gICAgICAgIGNvbnN0IHJlbGF5cyA9IHJlbGF5c0Zyb21CZWNoMzIoaWRPckZpbHRlciwgdGhpcyk7XG4gICAgICAgIGlmIChyZWxheXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHJlbGF5U2V0ID0gbmV3IE5ES1JlbGF5U2V0KG5ldyBTZXQocmVsYXlzKSwgdGhpcyk7XG4gICAgICAgICAgcmVsYXlTZXQgPSBjb3JyZWN0UmVsYXlTZXQocmVsYXlTZXQsIHRoaXMucG9vbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpZE9yRmlsdGVyID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBmaWx0ZXJzID0gW2ZpbHRlckZyb21JZChpZE9yRmlsdGVyKV07XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGlkT3JGaWx0ZXIpKSB7XG4gICAgICBmaWx0ZXJzID0gaWRPckZpbHRlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgZmlsdGVycyA9IFtpZE9yRmlsdGVyXTtcbiAgICB9XG4gICAgaWYgKGZpbHRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZmlsdGVyOiAke0pTT04uc3RyaW5naWZ5KGlkT3JGaWx0ZXIpfWApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGxldCBmZXRjaGVkRXZlbnQgPSBudWxsO1xuICAgICAgY29uc3QgcyA9IHRoaXMuc3Vic2NyaWJlKFxuICAgICAgICBmaWx0ZXJzLFxuICAgICAgICB7IC4uLm9wdHMgfHwge30sIGNsb3NlT25Fb3NlOiB0cnVlIH0sXG4gICAgICAgIHJlbGF5U2V0LFxuICAgICAgICBmYWxzZVxuICAgICAgKTtcbiAgICAgIGNvbnN0IHQyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHMuc3RvcCgpO1xuICAgICAgICByZXNvbHZlKGZldGNoZWRFdmVudCk7XG4gICAgICB9LCAxZTQpO1xuICAgICAgcy5vbihcImV2ZW50XCIsIChldmVudCkgPT4ge1xuICAgICAgICBldmVudC5uZGsgPSB0aGlzO1xuICAgICAgICBpZiAoIWV2ZW50LmlzUmVwbGFjZWFibGUoKSkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0Mik7XG4gICAgICAgICAgcmVzb2x2ZShldmVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWZldGNoZWRFdmVudCB8fCBmZXRjaGVkRXZlbnQuY3JlYXRlZF9hdCA8IGV2ZW50LmNyZWF0ZWRfYXQpIHtcbiAgICAgICAgICBmZXRjaGVkRXZlbnQgPSBldmVudDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBzLm9uKFwiZW9zZVwiLCAoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0Mik7XG4gICAgICAgIHJlc29sdmUoZmV0Y2hlZEV2ZW50KTtcbiAgICAgIH0pO1xuICAgICAgcy5zdGFydCgpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBGZXRjaCBldmVudHNcbiAgICovXG4gIGFzeW5jIGZldGNoRXZlbnRzKGZpbHRlcnMsIG9wdHMsIHJlbGF5U2V0KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBjb25zdCBldmVudHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgY29uc3QgcmVsYXlTZXRTdWJzY3JpcHRpb24gPSB0aGlzLnN1YnNjcmliZShcbiAgICAgICAgZmlsdGVycyxcbiAgICAgICAgeyAuLi5vcHRzIHx8IHt9LCBjbG9zZU9uRW9zZTogdHJ1ZSB9LFxuICAgICAgICByZWxheVNldCxcbiAgICAgICAgZmFsc2VcbiAgICAgICk7XG4gICAgICBjb25zdCBvbkV2ZW50ID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmICghKGV2ZW50IGluc3RhbmNlb2YgTkRLRXZlbnQpKSBldmVudCA9IG5ldyBOREtFdmVudCh2b2lkIDAsIGV2ZW50KTtcbiAgICAgICAgY29uc3QgZGVkdXBLZXkgPSBldmVudC5kZWR1cGxpY2F0aW9uS2V5KCk7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nRXZlbnQgPSBldmVudHMuZ2V0KGRlZHVwS2V5KTtcbiAgICAgICAgaWYgKGV4aXN0aW5nRXZlbnQpIHtcbiAgICAgICAgICBldmVudCA9IGRlZHVwKGV4aXN0aW5nRXZlbnQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBldmVudC5uZGsgPSB0aGlzO1xuICAgICAgICBldmVudHMuc2V0KGRlZHVwS2V5LCBldmVudCk7XG4gICAgICB9O1xuICAgICAgcmVsYXlTZXRTdWJzY3JpcHRpb24ub24oXCJldmVudFwiLCBvbkV2ZW50KTtcbiAgICAgIHJlbGF5U2V0U3Vic2NyaXB0aW9uLm9uKFwiZW9zZVwiLCAoKSA9PiB7XG4gICAgICAgIHJlc29sdmUobmV3IFNldChldmVudHMudmFsdWVzKCkpKTtcbiAgICAgIH0pO1xuICAgICAgcmVsYXlTZXRTdWJzY3JpcHRpb24uc3RhcnQoKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRW5zdXJlcyB0aGF0IGEgc2lnbmVyIGlzIGF2YWlsYWJsZSB0byBzaWduIGFuIGV2ZW50LlxuICAgKi9cbiAgYXNzZXJ0U2lnbmVyKCkge1xuICAgIGlmICghdGhpcy5zaWduZXIpIHtcbiAgICAgIHRoaXMuZW1pdChcInNpZ25lcjpyZXF1aXJlZFwiKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlNpZ25lciByZXF1aXJlZFwiKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgTmlwOTYgaW5zdGFuY2UgZm9yIHRoZSBnaXZlbiBkb21haW4uXG4gICAqIEBwYXJhbSBkb21haW4gRG9tYWluIHRvIHVzZSBmb3IgbmlwOTYgdXBsb2Fkc1xuICAgKiBAZXhhbXBsZSBVcGxvYWQgYSBmaWxlIHRvIGEgTklQLTk2IGVuYWJsZWQgZG9tYWluOlxuICAgKlxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbXCJIZWxsbywgd29ybGQhXCJdLCB7IHR5cGU6IFwidGV4dC9wbGFpblwiIH0pO1xuICAgKiBjb25zdCBuaXA5NiA9IG5kay5nZXROaXA5NihcIm5vc3RyY2hlY2subWVcIik7XG4gICAqIGF3YWl0IG5pcDk2LnVwbG9hZChibG9iKTtcbiAgICogYGBgXG4gICAqL1xuICBnZXROaXA5Nihkb21haW4pIHtcbiAgICByZXR1cm4gbmV3IE5pcDk2KGRvbWFpbiwgdGhpcyk7XG4gIH1cbiAgc2V0IHdhbGxldCh3YWxsZXQpIHtcbiAgICBpZiAoIXdhbGxldCkge1xuICAgICAgdGhpcy53YWxsZXRDb25maWcgPSB2b2lkIDA7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMud2FsbGV0Q29uZmlnID8/PSB7fTtcbiAgICB0aGlzLndhbGxldENvbmZpZy5sblBheSA9IHdhbGxldD8ubG5QYXk/LmJpbmQod2FsbGV0KTtcbiAgICB0aGlzLndhbGxldENvbmZpZy5jYXNodVBheSA9IHdhbGxldD8uY2FzaHVQYXk/LmJpbmQod2FsbGV0KTtcbiAgfVxufTtcblxuLy8gc3JjL3phcC9pbnZvaWNlLnRzXG5pbXBvcnQgeyBkZWNvZGUgfSBmcm9tIFwibGlnaHQtYm9sdDExLWRlY29kZXJcIjtcbmZ1bmN0aW9uIHphcEludm9pY2VGcm9tRXZlbnQoZXZlbnQpIHtcbiAgY29uc3QgZGVzY3JpcHRpb24gPSBldmVudC5nZXRNYXRjaGluZ1RhZ3MoXCJkZXNjcmlwdGlvblwiKVswXTtcbiAgY29uc3QgYm9sdDExID0gZXZlbnQuZ2V0TWF0Y2hpbmdUYWdzKFwiYm9sdDExXCIpWzBdO1xuICBsZXQgZGVjb2RlZEludm9pY2U7XG4gIGxldCB6YXBSZXF1ZXN0O1xuICBpZiAoIWRlc2NyaXB0aW9uIHx8ICFib2x0MTEgfHwgIWJvbHQxMVsxXSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHRyeSB7XG4gICAgbGV0IHphcFJlcXVlc3RQYXlsb2FkID0gZGVzY3JpcHRpb25bMV07XG4gICAgaWYgKHphcFJlcXVlc3RQYXlsb2FkLnN0YXJ0c1dpdGgoXCIlXCIpKSB7XG4gICAgICB6YXBSZXF1ZXN0UGF5bG9hZCA9IGRlY29kZVVSSUNvbXBvbmVudCh6YXBSZXF1ZXN0UGF5bG9hZCk7XG4gICAgfVxuICAgIGlmICh6YXBSZXF1ZXN0UGF5bG9hZCA9PT0gXCJcIikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHphcFJlcXVlc3QgPSBKU09OLnBhcnNlKHphcFJlcXVlc3RQYXlsb2FkKTtcbiAgICBkZWNvZGVkSW52b2ljZSA9IGRlY29kZShib2x0MTFbMV0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgYW1vdW50U2VjdGlvbiA9IGRlY29kZWRJbnZvaWNlLnNlY3Rpb25zLmZpbmQoKHMpID0+IHMubmFtZSA9PT0gXCJhbW91bnRcIik7XG4gIGlmICghYW1vdW50U2VjdGlvbikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGFtb3VudCA9IHBhcnNlSW50KGFtb3VudFNlY3Rpb24udmFsdWUpO1xuICBpZiAoIWFtb3VudCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGNvbnRlbnQgPSB6YXBSZXF1ZXN0LmNvbnRlbnQ7XG4gIGNvbnN0IHNlbmRlciA9IHphcFJlcXVlc3QucHVia2V5O1xuICBjb25zdCByZWNpcGllbnRUYWcgPSBldmVudC5nZXRNYXRjaGluZ1RhZ3MoXCJwXCIpWzBdO1xuICBjb25zdCByZWNpcGllbnQgPSByZWNpcGllbnRUYWdbMV07XG4gIGxldCB6YXBwZWRFdmVudCA9IGV2ZW50LmdldE1hdGNoaW5nVGFncyhcImVcIilbMF07XG4gIGlmICghemFwcGVkRXZlbnQpIHtcbiAgICB6YXBwZWRFdmVudCA9IGV2ZW50LmdldE1hdGNoaW5nVGFncyhcImFcIilbMF07XG4gIH1cbiAgY29uc3QgemFwcGVkRXZlbnRJZCA9IHphcHBlZEV2ZW50ID8gemFwcGVkRXZlbnRbMV0gOiB2b2lkIDA7XG4gIGNvbnN0IHphcEludm9pY2UgPSB7XG4gICAgaWQ6IGV2ZW50LmlkLFxuICAgIHphcHBlcjogZXZlbnQucHVia2V5LFxuICAgIHphcHBlZTogc2VuZGVyLFxuICAgIHphcHBlZDogcmVjaXBpZW50LFxuICAgIHphcHBlZEV2ZW50OiB6YXBwZWRFdmVudElkLFxuICAgIGFtb3VudCxcbiAgICBjb21tZW50OiBjb250ZW50XG4gIH07XG4gIHJldHVybiB6YXBJbnZvaWNlO1xufVxuXG4vLyBzcmMvemFwcGVyL2luZGV4LnRzXG5pbXBvcnQgY3JlYXRlRGVidWc1IGZyb20gXCJkZWJ1Z1wiO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIGFzIEV2ZW50RW1pdHRlcjkgfSBmcm9tIFwidHNlZXBcIjtcblxuLy8gc3JjL3phcHBlci9uaXA1Ny50c1xuaW1wb3J0IHsgbmlwNTcgfSBmcm9tIFwibm9zdHItdG9vbHNcIjtcbmFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlWmFwUmVxdWVzdCh0YXJnZXQsIG5kaywgZGF0YSwgcHVia2V5LCBhbW91bnQsIHJlbGF5cywgY29tbWVudCwgdGFncywgc2lnbmVyKSB7XG4gIGNvbnN0IHphcEVuZHBvaW50ID0gZGF0YS5jYWxsYmFjaztcbiAgY29uc3QgemFwUmVxdWVzdCA9IG5pcDU3Lm1ha2VaYXBSZXF1ZXN0KHtcbiAgICBwcm9maWxlOiBwdWJrZXksXG4gICAgLy8gc2V0IHRoZSBldmVudCB0byBudWxsIHNpbmNlIG5vc3RyLXRvb2xzIGRvZXNuJ3Qgc3VwcG9ydCBuaXAtMzMgemFwc1xuICAgIGV2ZW50OiBudWxsLFxuICAgIGFtb3VudCxcbiAgICBjb21tZW50OiBjb21tZW50IHx8IFwiXCIsXG4gICAgcmVsYXlzOiByZWxheXMuc2xpY2UoMCwgNClcbiAgfSk7XG4gIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBOREtFdmVudCkge1xuICAgIGNvbnN0IHRhZ3MyID0gdGFyZ2V0LnJlZmVyZW5jZVRhZ3MoKTtcbiAgICBjb25zdCBub25QVGFncyA9IHRhZ3MyLmZpbHRlcigodGFnKSA9PiB0YWdbMF0gIT09IFwicFwiKTtcbiAgICB6YXBSZXF1ZXN0LnRhZ3MucHVzaCguLi5ub25QVGFncyk7XG4gIH1cbiAgemFwUmVxdWVzdC50YWdzLnB1c2goW1wibG51cmxcIiwgemFwRW5kcG9pbnRdKTtcbiAgY29uc3QgZXZlbnQgPSBuZXcgTkRLRXZlbnQobmRrLCB6YXBSZXF1ZXN0KTtcbiAgaWYgKHRhZ3MpIHtcbiAgICBldmVudC50YWdzID0gZXZlbnQudGFncy5jb25jYXQodGFncyk7XG4gIH1cbiAgaWYgKGV2ZW50Lmhhc1RhZyhcImFcIikpIHtcbiAgICBldmVudC50YWdzID0gZXZlbnQudGFncy5maWx0ZXIoKHRhZykgPT4gdGFnWzBdICE9PSBcImVcIik7XG4gIH1cbiAgZXZlbnQudGFncyA9IGV2ZW50LnRhZ3MuZmlsdGVyKCh0YWcpID0+IHRhZ1swXSAhPT0gXCJwXCIpO1xuICBldmVudC50YWdzLnB1c2goW1wicFwiLCBwdWJrZXldKTtcbiAgYXdhaXQgZXZlbnQuc2lnbihzaWduZXIpO1xuICByZXR1cm4gZXZlbnQ7XG59XG5cbi8vIHNyYy96YXBwZXIvbG4udHNcbmltcG9ydCB7IGJlY2gzMiB9IGZyb20gXCJAc2N1cmUvYmFzZVwiO1xuaW1wb3J0IGNyZWF0ZURlYnVnNCBmcm9tIFwiZGVidWdcIjtcbnZhciBkMiA9IGNyZWF0ZURlYnVnNChcIm5kazp6YXBwZXI6bG5cIik7XG5hc3luYyBmdW5jdGlvbiBnZXROaXA1N1phcFNwZWNGcm9tTHVkKHsgbHVkMDYsIGx1ZDE2IH0sIG5kaykge1xuICBsZXQgemFwRW5kcG9pbnQ7XG4gIGlmIChsdWQxNiAmJiAhbHVkMTYuc3RhcnRzV2l0aChcIkxOVVJMXCIpKSB7XG4gICAgY29uc3QgW25hbWUsIGRvbWFpbl0gPSBsdWQxNi5zcGxpdChcIkBcIik7XG4gICAgemFwRW5kcG9pbnQgPSBgaHR0cHM6Ly8ke2RvbWFpbn0vLndlbGwta25vd24vbG51cmxwLyR7bmFtZX1gO1xuICB9IGVsc2UgaWYgKGx1ZDA2KSB7XG4gICAgY29uc3QgeyB3b3JkcyB9ID0gYmVjaDMyLmRlY29kZShsdWQwNiwgMWUzKTtcbiAgICBjb25zdCBkYXRhID0gYmVjaDMyLmZyb21Xb3Jkcyh3b3Jkcyk7XG4gICAgY29uc3QgdXRmOERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoXCJ1dGYtOFwiKTtcbiAgICB6YXBFbmRwb2ludCA9IHV0ZjhEZWNvZGVyLmRlY29kZShkYXRhKTtcbiAgfVxuICBpZiAoIXphcEVuZHBvaW50KSB7XG4gICAgZDIoXCJObyB6YXAgZW5kcG9pbnQgZm91bmQgJW9cIiwgeyBsdWQwNiwgbHVkMTYgfSk7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gemFwIGVuZHBvaW50IGZvdW5kXCIpO1xuICB9XG4gIHRyeSB7XG4gICAgY29uc3QgX2ZldGNoID0gbmRrLmh0dHBGZXRjaCB8fCBmZXRjaDtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IF9mZXRjaCh6YXBFbmRwb2ludCk7XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gZmV0Y2ggemFwIGVuZHBvaW50ICR7emFwRW5kcG9pbnR9OiAke3RleHR9YCk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBmZXRjaCB6YXAgZW5kcG9pbnQgJHt6YXBFbmRwb2ludH06ICR7ZX1gKTtcbiAgfVxufVxuXG4vLyBzcmMvemFwcGVyL2luZGV4LnRzXG52YXIgZDMgPSBjcmVhdGVEZWJ1ZzUoXCJuZGs6emFwcGVyXCIpO1xudmFyIE5ES1phcHBlciA9IGNsYXNzIGV4dGVuZHMgRXZlbnRFbWl0dGVyOSB7XG4gIHRhcmdldDtcbiAgbmRrO1xuICBjb21tZW50O1xuICBhbW91bnQ7XG4gIHVuaXQ7XG4gIHRhZ3M7XG4gIHNpZ25lcjtcbiAgemFwTWV0aG9kO1xuICBudXR6YXBBc0ZhbGxiYWNrO1xuICBsblBheTtcbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIGEgY2FzaHUgcGF5bWVudCBpcyB0byBiZSBtYWRlLlxuICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBzd2FwL21pbnQgcHJvb2ZzIGZvciB0aGUgcmVxdWlyZWQgYW1vdW50LCBpbiB0aGUgcmVxdWlyZWQgdW5pdCxcbiAgICogaW4gYW55IG9mIHRoZSBwcm92aWRlZCBtaW50cyBhbmQgcmV0dXJuIHRoZSBwcm9vZnMgYW5kIG1pbnQgdXNlZC5cbiAgICovXG4gIGNhc2h1UGF5O1xuICBvbkNvbXBsZXRlO1xuICBtYXhSZWxheXMgPSAzO1xuICAvKipcbiAgICogXG4gICAqIEBwYXJhbSB0YXJnZXQgVGhlIHRhcmdldCBvZiB0aGUgemFwXG4gICAqIEBwYXJhbSBhbW91bnQgVGhlIGFtb3VudCB0byBzZW5kIGluZGljYXRlZCBpbiB0aGUgdW5pdFxuICAgKiBAcGFyYW0gdW5pdCBUaGUgdW5pdCBvZiB0aGUgYW1vdW50XG4gICAqIEBwYXJhbSBvcHRzIE9wdGlvbnMgZm9yIHRoZSB6YXBcbiAgICovXG4gIGNvbnN0cnVjdG9yKHRhcmdldCwgYW1vdW50LCB1bml0ID0gXCJtc2F0XCIsIG9wdHMgPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgdGhpcy5uZGsgPSBvcHRzLm5kayB8fCB0YXJnZXQubmRrO1xuICAgIGlmICghdGhpcy5uZGspIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIE5ESyBpbnN0YW5jZSBwcm92aWRlZFwiKTtcbiAgICB9XG4gICAgdGhpcy5hbW91bnQgPSBhbW91bnQ7XG4gICAgdGhpcy5jb21tZW50ID0gb3B0cy5jb21tZW50O1xuICAgIHRoaXMudW5pdCA9IHVuaXQ7XG4gICAgdGhpcy50YWdzID0gb3B0cy50YWdzO1xuICAgIHRoaXMuc2lnbmVyID0gb3B0cy5zaWduZXI7XG4gICAgdGhpcy5udXR6YXBBc0ZhbGxiYWNrID0gb3B0cy5udXR6YXBBc0ZhbGxiYWNrID8/IGZhbHNlO1xuICAgIHRoaXMubG5QYXkgPSBvcHRzLmxuUGF5IHx8IHRoaXMubmRrLndhbGxldENvbmZpZz8ubG5QYXk7XG4gICAgdGhpcy5jYXNodVBheSA9IG9wdHMuY2FzaHVQYXkgfHwgdGhpcy5uZGsud2FsbGV0Q29uZmlnPy5jYXNodVBheTtcbiAgICB0aGlzLm9uQ29tcGxldGUgPSBvcHRzLm9uQ29tcGxldGUgfHwgdGhpcy5uZGsud2FsbGV0Q29uZmlnPy5vblBheW1lbnRDb21wbGV0ZTtcbiAgfVxuICAvKipcbiAgICogSW5pdGlhdGUgemFwcGluZyBwcm9jZXNzXG4gICAqIFxuICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgY2FsY3VsYXRlIHRoZSBzcGxpdHMgZm9yIHRoaXMgemFwIGFuZCBpbml0aWF0ZSBlYWNoIHphcCBzcGxpdC5cbiAgICovXG4gIGFzeW5jIHphcChtZXRob2RzKSB7XG4gICAgY29uc3Qgc3BsaXRzID0gdGhpcy5nZXRaYXBTcGxpdHMoKTtcbiAgICBjb25zdCByZXN1bHRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIHNwbGl0cy5tYXAoYXN5bmMgKHNwbGl0KSA9PiB7XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVzdWx0ID0gYXdhaXQgdGhpcy56YXBTcGxpdChzcGxpdCwgbWV0aG9kcyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXN1bHQgPSBuZXcgRXJyb3IoZS5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoXCJzcGxpdDpjb21wbGV0ZVwiLCBzcGxpdCwgcmVzdWx0KTtcbiAgICAgICAgcmVzdWx0cy5zZXQoc3BsaXQsIHJlc3VsdCk7XG4gICAgICB9KVxuICAgICk7XG4gICAgdGhpcy5lbWl0KFwiY29tcGxldGVcIiwgcmVzdWx0cyk7XG4gICAgaWYgKHRoaXMub25Db21wbGV0ZSkgdGhpcy5vbkNvbXBsZXRlKHJlc3VsdHMpO1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG4gIGFzeW5jIHphcE5pcDU3KHNwbGl0LCBkYXRhKSB7XG4gICAgaWYgKCF0aGlzLmxuUGF5KSB0aHJvdyBuZXcgRXJyb3IoXCJObyBsblBheSBmdW5jdGlvbiBhdmFpbGFibGVcIik7XG4gICAgY29uc3QgemFwU3BlYyA9IGF3YWl0IGdldE5pcDU3WmFwU3BlY0Zyb21MdWQoZGF0YSwgdGhpcy5uZGspO1xuICAgIGlmICghemFwU3BlYykgdGhyb3cgbmV3IEVycm9yKFwiTm8gemFwIHNwZWMgYXZhaWxhYmxlIGZvciByZWNpcGllbnRcIik7XG4gICAgY29uc3QgcmVsYXlzID0gYXdhaXQgdGhpcy5yZWxheXMoc3BsaXQucHVia2V5KTtcbiAgICBjb25zdCB6YXBSZXF1ZXN0ID0gYXdhaXQgZ2VuZXJhdGVaYXBSZXF1ZXN0KFxuICAgICAgdGhpcy50YXJnZXQsXG4gICAgICB0aGlzLm5kayxcbiAgICAgIHphcFNwZWMsXG4gICAgICBzcGxpdC5wdWJrZXksXG4gICAgICBzcGxpdC5hbW91bnQsXG4gICAgICByZWxheXMsXG4gICAgICB0aGlzLmNvbW1lbnQsXG4gICAgICB0aGlzLnRhZ3MsXG4gICAgICB0aGlzLnNpZ25lclxuICAgICk7XG4gICAgaWYgKCF6YXBSZXF1ZXN0KSB7XG4gICAgICBkMyhcIlVuYWJsZSB0byBnZW5lcmF0ZSB6YXAgcmVxdWVzdFwiKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBnZW5lcmF0ZSB6YXAgcmVxdWVzdFwiKTtcbiAgICB9XG4gICAgY29uc3QgcHIgPSBhd2FpdCB0aGlzLmdldExuSW52b2ljZSh6YXBSZXF1ZXN0LCBzcGxpdC5hbW91bnQsIHphcFNwZWMpO1xuICAgIGlmICghcHIpIHtcbiAgICAgIGQzKFwiVW5hYmxlIHRvIGdldCBwYXltZW50IHJlcXVlc3RcIik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gZ2V0IHBheW1lbnQgcmVxdWVzdFwiKTtcbiAgICB9XG4gICAgdGhpcy5lbWl0KFwibG5faW52b2ljZVwiLCB7XG4gICAgICBhbW91bnQ6IHNwbGl0LmFtb3VudCxcbiAgICAgIHJlY2lwaWVudFB1YmtleTogc3BsaXQucHVia2V5LFxuICAgICAgdW5pdDogdGhpcy51bml0LFxuICAgICAgbmlwNTdaYXBSZXF1ZXN0OiB6YXBSZXF1ZXN0LFxuICAgICAgcHIsXG4gICAgICB0eXBlOiBcIm5pcDU3XCJcbiAgICB9KTtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmxuUGF5KFxuICAgICAge1xuICAgICAgICB0YXJnZXQ6IHRoaXMudGFyZ2V0LFxuICAgICAgICByZWNpcGllbnRQdWJrZXk6IHNwbGl0LnB1YmtleSxcbiAgICAgICAgcGF5bWVudERlc2NyaXB0aW9uOiBcIk5JUC01NyBaYXBcIixcbiAgICAgICAgcHIsXG4gICAgICAgIGFtb3VudDogc3BsaXQuYW1vdW50LFxuICAgICAgICB1bml0OiB0aGlzLnVuaXQsXG4gICAgICAgIG5pcDU3WmFwUmVxdWVzdDogemFwUmVxdWVzdFxuICAgICAgfVxuICAgICk7XG4gICAgaWYgKHJlcz8ucHJlaW1hZ2UpIHtcbiAgICAgIHRoaXMuZW1pdChcImxuX3BheW1lbnRcIiwge1xuICAgICAgICBwcmVpbWFnZTogcmVzLnByZWltYWdlLFxuICAgICAgICBhbW91bnQ6IHNwbGl0LmFtb3VudCxcbiAgICAgICAgcmVjaXBpZW50UHVia2V5OiBzcGxpdC5wdWJrZXksXG4gICAgICAgIHByLFxuICAgICAgICB1bml0OiB0aGlzLnVuaXQsXG4gICAgICAgIG5pcDU3WmFwUmVxdWVzdDogemFwUmVxdWVzdCxcbiAgICAgICAgdHlwZTogXCJuaXA1N1wiXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICAvKipcbiAgICogRmV0Y2hlcyBpbmZvcm1hdGlvbiBhYm91dCBhIE5JUC02MSB6YXAgYW5kIGFza3MgdGhlIGNhbGxlciB0byBjcmVhdGUgY2FzaHUgcHJvb2ZzIGZvciB0aGUgemFwLlxuICAgKiBcbiAgICogKG5vdGUgdGhhdCB0aGUgY2FzaHVQYXkgZnVuY3Rpb24gY2FuIHVzZSBhbnkgbWV0aG9kIHRvIGNyZWF0ZSB0aGUgcHJvb2ZzLCBpbmNsdWRpbmcgdXNpbmcgbGlnaHRuaW5nXG4gICAqIHRvIG1pbnQgcHJvb2ZzIGluIHRoZSBzcGVjaWZpZWQgbWludCwgdGhlIHJlc3BvbnNpYmlsaXR5IG9mIG1pbnRpbmcgdGhlIHByb29mcyBpcyBkZWxlZ2F0ZWQgdG8gdGhlIGNhbGxlciAoZS5nLiBuZGstd2FsbGV0KSlcbiAgICovXG4gIGFzeW5jIHphcE5pcDYxKHNwbGl0LCBkYXRhKSB7XG4gICAgaWYgKCF0aGlzLmNhc2h1UGF5KSB0aHJvdyBuZXcgRXJyb3IoXCJObyBjYXNodVBheSBmdW5jdGlvbiBhdmFpbGFibGVcIik7XG4gICAgbGV0IHJldDtcbiAgICByZXQgPSBhd2FpdCB0aGlzLmNhc2h1UGF5KHtcbiAgICAgIHRhcmdldDogdGhpcy50YXJnZXQsXG4gICAgICByZWNpcGllbnRQdWJrZXk6IHNwbGl0LnB1YmtleSxcbiAgICAgIHBheW1lbnREZXNjcmlwdGlvbjogXCJOSVAtNjEgWmFwXCIsXG4gICAgICBhbW91bnQ6IHNwbGl0LmFtb3VudCxcbiAgICAgIHVuaXQ6IHRoaXMudW5pdCxcbiAgICAgIC4uLmRhdGEgPz8ge31cbiAgICB9LCAocHIpID0+IHtcbiAgICAgIHRoaXMuZW1pdChcImxuX2ludm9pY2VcIiwge1xuICAgICAgICBwcixcbiAgICAgICAgYW1vdW50OiBzcGxpdC5hbW91bnQsXG4gICAgICAgIHJlY2lwaWVudFB1YmtleTogc3BsaXQucHVia2V5LFxuICAgICAgICB1bml0OiB0aGlzLnVuaXQsXG4gICAgICAgIHR5cGU6IFwibmlwNjFcIlxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgZDMoXCJOSVAtNjEgWmFwIHJlc3VsdDogJW9cIiwgcmV0KTtcbiAgICBpZiAocmV0IGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSBlbHNlIGlmIChyZXQpIHtcbiAgICAgIGNvbnN0IHsgcHJvb2ZzLCBtaW50IH0gPSByZXQ7XG4gICAgICBpZiAoIXByb29mcyB8fCAhbWludClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiSW52YWxpZCB6YXAgY29uZmlybWF0aW9uOiBtaXNzaW5nIHByb29mcyBvciBtaW50OiBcIiArIHJldFxuICAgICAgICApO1xuICAgICAgY29uc3QgcmVsYXlzID0gYXdhaXQgdGhpcy5yZWxheXMoc3BsaXQucHVia2V5KTtcbiAgICAgIGNvbnN0IHJlbGF5U2V0ID0gTkRLUmVsYXlTZXQuZnJvbVJlbGF5VXJscyhyZWxheXMsIHRoaXMubmRrKTtcbiAgICAgIGNvbnN0IG51dHphcCA9IG5ldyBOREtOdXR6YXAodGhpcy5uZGspO1xuICAgICAgbnV0emFwLnRhZ3MgPSBbLi4ubnV0emFwLnRhZ3MsIC4uLnRoaXMudGFncyB8fCBbXV07XG4gICAgICBudXR6YXAucHJvb2ZzID0gcHJvb2ZzO1xuICAgICAgbnV0emFwLm1pbnQgPSBtaW50O1xuICAgICAgbnV0emFwLnRhcmdldCA9IHRoaXMudGFyZ2V0O1xuICAgICAgbnV0emFwLmNvbW1lbnQgPSB0aGlzLmNvbW1lbnQ7XG4gICAgICBudXR6YXAudW5pdCA9IHRoaXMudW5pdDtcbiAgICAgIG51dHphcC5yZWNpcGllbnRQdWJrZXkgPSBzcGxpdC5wdWJrZXk7XG4gICAgICBhd2FpdCBudXR6YXAuc2lnbih0aGlzLnNpZ25lcik7XG4gICAgICBudXR6YXAucHVibGlzaChyZWxheVNldCk7XG4gICAgICByZXR1cm4gbnV0emFwO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSB6YXAgbWV0aG9kcyBhdmFpbGFibGUgZm9yIHRoZSByZWNpcGllbnQgYW5kIGluaXRpYXRlcyB0aGUgemFwXG4gICAqIGluIHRoZSBkZXNpcmVkIG1ldGhvZC5cbiAgICogQHBhcmFtIHNwbGl0IFxuICAgKiBAcGFyYW0gbWV0aG9kcyAtIFRoZSBtZXRob2RzIHRvIHRyeSwgaWYgbm90IHByb3ZpZGVkLCBhbGwgbWV0aG9kcyB3aWxsIGJlIHRyaWVkLlxuICAgKiBAcmV0dXJucyBcbiAgICovXG4gIGFzeW5jIHphcFNwbGl0KHNwbGl0LCBtZXRob2RzKSB7XG4gICAgY29uc3QgcmVjaXBpZW50ID0gdGhpcy5uZGsuZ2V0VXNlcih7IHB1YmtleTogc3BsaXQucHVia2V5IH0pO1xuICAgIGxldCB6YXBNZXRob2RzID0gYXdhaXQgcmVjaXBpZW50LmdldFphcEluZm8oMjUwMCk7XG4gICAgbGV0IHJldFZhbDtcbiAgICBjb25zdCBjYW5GYWxsYmFja1RvTmlwNjEgPSB0aGlzLm51dHphcEFzRmFsbGJhY2sgJiYgdGhpcy5jYXNodVBheTtcbiAgICBpZiAoemFwTWV0aG9kcy5zaXplID09PSAwICYmICFjYW5GYWxsYmFja1RvTmlwNjEpIHRocm93IG5ldyBFcnJvcihcIk5vIHphcCBtZXRob2QgYXZhaWxhYmxlIGZvciByZWNpcGllbnQgYW5kIE5JUC02MSBmYWxsYmFjayBpcyBkaXNhYmxlZFwiKTtcbiAgICBjb25zdCBuaXA2MUZhbGxiYWNrID0gYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLm51dHphcEFzRmFsbGJhY2spIHJldHVybjtcbiAgICAgIGNvbnN0IHJlbGF5TGlzdHMgPSBhd2FpdCBnZXRSZWxheUxpc3RGb3JVc2Vycyhbc3BsaXQucHVia2V5XSwgdGhpcy5uZGspO1xuICAgICAgbGV0IHJlbGF5VXJscyA9IHJlbGF5TGlzdHMuZ2V0KHNwbGl0LnB1YmtleSk/LnJlYWRSZWxheVVybHM7XG4gICAgICByZWxheVVybHMgPSB0aGlzLm5kay5wb29sLmNvbm5lY3RlZFJlbGF5cygpLm1hcCgocikgPT4gci51cmwpO1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuemFwTmlwNjEoc3BsaXQsIHtcbiAgICAgICAgLy8gdXNlIHRoZSB1c2VyJ3MgcmVsYXkgbGlzdFxuICAgICAgICByZWxheXM6IHJlbGF5VXJscyxcbiAgICAgICAgLy8gbG9jayB0byB0aGUgdXNlcidzIGFjdHVhbCBwdWJrZXlcbiAgICAgICAgcDJwazogc3BsaXQucHVia2V5LFxuICAgICAgICAvLyBhbGxvdyBpbnRyYW1pbnQgZmFsbGJhY2tcbiAgICAgICAgYWxsb3dJbnRyYW1pbnRGYWxsYmFjazogISFjYW5GYWxsYmFja1RvTmlwNjFcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgY2FuVXNlTmlwNjEgPSAhbWV0aG9kcyB8fCBtZXRob2RzLmluY2x1ZGVzKFwibmlwNjFcIik7XG4gICAgY29uc3QgY2FuVXNlTmlwNTcgPSAhbWV0aG9kcyB8fCBtZXRob2RzLmluY2x1ZGVzKFwibmlwNTdcIik7XG4gICAgY29uc3QgbmlwNjFNZXRob2QgPSB6YXBNZXRob2RzLmdldChcIm5pcDYxXCIpO1xuICAgIGlmIChuaXA2MU1ldGhvZCAmJiBjYW5Vc2VOaXA2MSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0VmFsID0gYXdhaXQgdGhpcy56YXBOaXA2MShzcGxpdCwgbmlwNjFNZXRob2QpO1xuICAgICAgICBpZiAocmV0VmFsIGluc3RhbmNlb2YgTkRLTnV0emFwKSByZXR1cm4gcmV0VmFsO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLmVtaXQoXCJub3RpY2VcIiwgYE5JUC02MSBhdHRlbXB0IGZhaWxlZDogJHtlLm1lc3NhZ2V9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG5pcDU3TWV0aG9kID0gemFwTWV0aG9kcy5nZXQoXCJuaXA1N1wiKTtcbiAgICBpZiAobmlwNTdNZXRob2QgJiYgY2FuVXNlTmlwNTcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldFZhbCA9IGF3YWl0IHRoaXMuemFwTmlwNTcoc3BsaXQsIG5pcDU3TWV0aG9kKTtcbiAgICAgICAgaWYgKCEocmV0VmFsIGluc3RhbmNlb2YgRXJyb3IpKSByZXR1cm4gcmV0VmFsO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLmVtaXQoXCJub3RpY2VcIiwgYE5JUC01NyBhdHRlbXB0IGZhaWxlZDogJHtlLm1lc3NhZ2V9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjYW5GYWxsYmFja1RvTmlwNjEpIHtcbiAgICAgIHJldFZhbCA9IGF3YWl0IG5pcDYxRmFsbGJhY2soKTtcbiAgICAgIGlmIChyZXRWYWwgaW5zdGFuY2VvZiBFcnJvcikgdGhyb3cgcmV0VmFsO1xuICAgICAgcmV0dXJuIHJldFZhbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbWl0KFwibm90aWNlXCIsIFwiWmFwIG1ldGhvZHMgZXhoYXVzdGVkIGFuZCB0aGVyZSB3YXMgbm8gZmFsbGJhY2sgdG8gTklQLTYxXCIpO1xuICAgIH1cbiAgICBpZiAocmV0VmFsIGluc3RhbmNlb2YgRXJyb3IpIHRocm93IHJldFZhbDtcbiAgICByZXR1cm4gcmV0VmFsO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIGEgYm9sdDExIGZvciBhIG5pcDU3IHphcFxuICAgKiBAcGFyYW0gZXZlbnRcbiAgICogQHBhcmFtIGFtb3VudFxuICAgKiBAcGFyYW0gemFwRW5kcG9pbnRcbiAgICogQHJldHVybnNcbiAgICovXG4gIGFzeW5jIGdldExuSW52b2ljZSh6YXBSZXF1ZXN0LCBhbW91bnQsIGRhdGEpIHtcbiAgICBjb25zdCB6YXBFbmRwb2ludCA9IGRhdGEuY2FsbGJhY2s7XG4gICAgY29uc3QgZXZlbnRQYXlsb2FkID0gSlNPTi5zdHJpbmdpZnkoemFwUmVxdWVzdC5yYXdFdmVudCgpKTtcbiAgICBkMyhcbiAgICAgIGBGZXRjaGluZyBpbnZvaWNlIGZyb20gJHt6YXBFbmRwb2ludH0/YCArIG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgICAgICBhbW91bnQ6IGFtb3VudC50b1N0cmluZygpLFxuICAgICAgICBub3N0cjogZXZlbnRQYXlsb2FkXG4gICAgICB9KVxuICAgICk7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTCh6YXBFbmRwb2ludCk7XG4gICAgdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJhbW91bnRcIiwgYW1vdW50LnRvU3RyaW5nKCkpO1xuICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKFwibm9zdHJcIiwgZXZlbnRQYXlsb2FkKTtcbiAgICBkMyhgRmV0Y2hpbmcgaW52b2ljZSBmcm9tICR7dXJsLnRvU3RyaW5nKCl9YCk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwudG9TdHJpbmcoKSk7XG4gICAgZDMoYEdvdCByZXNwb25zZSBmcm9tIHphcCBlbmRwb2ludDogJHt6YXBFbmRwb2ludH1gLCB7IHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzIH0pO1xuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgZDMoYFJlY2VpdmVkIG5vbi0yMDAgc3RhdHVzIGZyb20gemFwIGVuZHBvaW50OiAke3phcEVuZHBvaW50fWAsIHtcbiAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIGFtb3VudCxcbiAgICAgICAgbm9zdHI6IGV2ZW50UGF5bG9hZFxuICAgICAgfSk7XG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gZmV0Y2ggemFwIGVuZHBvaW50ICR7emFwRW5kcG9pbnR9OiAke3RleHR9YCk7XG4gICAgfVxuICAgIGNvbnN0IGJvZHkgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgcmV0dXJuIGJvZHkucHI7XG4gIH1cbiAgZ2V0WmFwU3BsaXRzKCkge1xuICAgIGlmICh0aGlzLnRhcmdldCBpbnN0YW5jZW9mIE5ES1VzZXIpIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHtcbiAgICAgICAgICBwdWJrZXk6IHRoaXMudGFyZ2V0LnB1YmtleSxcbiAgICAgICAgICBhbW91bnQ6IHRoaXMuYW1vdW50XG4gICAgICAgIH1cbiAgICAgIF07XG4gICAgfVxuICAgIGNvbnN0IHphcFRhZ3MgPSB0aGlzLnRhcmdldC5nZXRNYXRjaGluZ1RhZ3MoXCJ6YXBcIik7XG4gICAgaWYgKHphcFRhZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICB7XG4gICAgICAgICAgcHVia2V5OiB0aGlzLnRhcmdldC5wdWJrZXksXG4gICAgICAgICAgYW1vdW50OiB0aGlzLmFtb3VudFxuICAgICAgICB9XG4gICAgICBdO1xuICAgIH1cbiAgICBjb25zdCBzcGxpdHMgPSBbXTtcbiAgICBjb25zdCB0b3RhbCA9IHphcFRhZ3MucmVkdWNlKChhY2MsIHRhZykgPT4gYWNjICsgcGFyc2VJbnQodGFnWzJdKSwgMCk7XG4gICAgZm9yIChjb25zdCB0YWcgb2YgemFwVGFncykge1xuICAgICAgY29uc3QgcHVia2V5ID0gdGFnWzFdO1xuICAgICAgY29uc3QgYW1vdW50ID0gTWF0aC5mbG9vcihwYXJzZUludCh0YWdbMl0pIC8gdG90YWwgKiB0aGlzLmFtb3VudCk7XG4gICAgICBzcGxpdHMucHVzaCh7IHB1YmtleSwgYW1vdW50IH0pO1xuICAgIH1cbiAgICByZXR1cm4gc3BsaXRzO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSB6YXAgbWV0aG9kIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gemFwIGEgcHViYmtleVxuICAgKiBAcGFyYW0gbmRrXG4gICAqIEBwYXJhbSBwdWJrZXlcbiAgICogQHJldHVybnNcbiAgICovXG4gIGFzeW5jIGdldFphcE1ldGhvZHMobmRrLCByZWNpcGllbnQsIHRpbWVvdXQgPSAyNTAwKSB7XG4gICAgY29uc3QgdXNlciA9IG5kay5nZXRVc2VyKHsgcHVia2V5OiByZWNpcGllbnQgfSk7XG4gICAgcmV0dXJuIGF3YWl0IHVzZXIuZ2V0WmFwSW5mbyh0aW1lb3V0KTtcbiAgfVxuICAvKipcbiAgICogQHJldHVybnMgdGhlIHJlbGF5cyB0byB1c2UgZm9yIHRoZSB6YXAgcmVxdWVzdFxuICAgKi9cbiAgYXN5bmMgcmVsYXlzKHB1YmtleSkge1xuICAgIGxldCByID0gW107XG4gICAgaWYgKHRoaXMubmRrPy5hY3RpdmVVc2VyKSB7XG4gICAgICBjb25zdCByZWxheUxpc3RzID0gYXdhaXQgZ2V0UmVsYXlMaXN0Rm9yVXNlcnMoXG4gICAgICAgIFt0aGlzLm5kay5hY3RpdmVVc2VyLnB1YmtleSwgcHVia2V5XSxcbiAgICAgICAgdGhpcy5uZGtcbiAgICAgICk7XG4gICAgICBjb25zdCByZWxheVNjb3JlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBmb3IgKGNvbnN0IHJlbGF5TGlzdCBvZiByZWxheUxpc3RzLnZhbHVlcygpKSB7XG4gICAgICAgIGZvciAoY29uc3QgdXJsIG9mIHJlbGF5TGlzdC5yZWFkUmVsYXlVcmxzKSB7XG4gICAgICAgICAgY29uc3Qgc2NvcmUgPSByZWxheVNjb3Jlcy5nZXQodXJsKSB8fCAwO1xuICAgICAgICAgIHJlbGF5U2NvcmVzLnNldCh1cmwsIHNjb3JlICsgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHIgPSBBcnJheS5mcm9tKHJlbGF5U2NvcmVzLmVudHJpZXMoKSkuc29ydCgoYSwgYikgPT4gYlsxXSAtIGFbMV0pLm1hcCgoW3VybF0pID0+IHVybCkuc2xpY2UoMCwgdGhpcy5tYXhSZWxheXMpO1xuICAgIH1cbiAgICBpZiAodGhpcy5uZGs/LnBvb2w/LnBlcm1hbmVudEFuZENvbm5lY3RlZFJlbGF5cygpLmxlbmd0aCkge1xuICAgICAgciA9IHRoaXMubmRrLnBvb2wucGVybWFuZW50QW5kQ29ubmVjdGVkUmVsYXlzKCkubWFwKChyZWxheSkgPT4gcmVsYXkudXJsKTtcbiAgICB9XG4gICAgaWYgKCFyLmxlbmd0aCkge1xuICAgICAgciA9IFtdO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL2ZpbHRlci50c1xuZnVuY3Rpb24gbWF0Y2hGaWx0ZXIoZmlsdGVyLCBldmVudCkge1xuICBpZiAoZmlsdGVyLmlkcyAmJiBmaWx0ZXIuaWRzLmluZGV4T2YoZXZlbnQuaWQpID09PSAtMSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZmlsdGVyLmtpbmRzICYmIGZpbHRlci5raW5kcy5pbmRleE9mKGV2ZW50LmtpbmQpID09PSAtMSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZmlsdGVyLmF1dGhvcnMgJiYgZmlsdGVyLmF1dGhvcnMuaW5kZXhPZihldmVudC5wdWJrZXkpID09PSAtMSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBmIGluIGZpbHRlcikge1xuICAgIGlmIChmWzBdID09PSBcIiNcIikge1xuICAgICAgbGV0IHRhZ05hbWUgPSBmLnNsaWNlKDEpO1xuICAgICAgaWYgKHRhZ05hbWUgPT09IFwidFwiKSB7XG4gICAgICAgIGxldCB2YWx1ZXMgPSBmaWx0ZXJbYCMke3RhZ05hbWV9YF0/Lm1hcCgodikgPT4gdi50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgaWYgKHZhbHVlcyAmJiAhZXZlbnQudGFncy5maW5kKChbdCwgdl0pID0+IHQgPT09IHRhZ05hbWUgJiYgdmFsdWVzLmluZGV4T2Yodi50b0xvd2VyQ2FzZSgpKSAhPT0gLTEpKSByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgdmFsdWVzID0gZmlsdGVyW2AjJHt0YWdOYW1lfWBdO1xuICAgICAgICBpZiAodmFsdWVzICYmICFldmVudC50YWdzLmZpbmQoKFt0LCB2XSkgPT4gdCA9PT0gdGFnTmFtZSAmJiB2YWx1ZXMuaW5kZXhPZih2KSAhPT0gLTEpKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChmaWx0ZXIuc2luY2UgJiYgZXZlbnQuY3JlYXRlZF9hdCA8IGZpbHRlci5zaW5jZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoZmlsdGVyLnVudGlsICYmIGV2ZW50LmNyZWF0ZWRfYXQgPiBmaWx0ZXIudW50aWwpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHRydWU7XG59XG5leHBvcnQge1xuICBCRUNIMzJfUkVHRVgsXG4gIE5ES0FwcEhhbmRsZXJFdmVudCxcbiAgTkRLQXBwU2V0dGluZ3MsXG4gIE5ES0FydGljbGUsXG4gIE5ES0Nhc2h1TWludExpc3QsXG4gIE5ES0Nhc2h1VG9rZW4sXG4gIE5ES0Nhc2h1V2FsbGV0VHgsXG4gIE5ES0NsYXNzaWZpZWQsXG4gIE5ES0RWTUpvYkZlZWRiYWNrLFxuICBOREtEVk1Kb2JSZXN1bHQsXG4gIE5ES0RWTVJlcXVlc3QsXG4gIE5ES0RyYWZ0LFxuICBOREtEdm1Kb2JGZWVkYmFja1N0YXR1cyxcbiAgTkRLRXZlbnQsXG4gIE5ES0hpZ2hsaWdodCxcbiAgTkRLSW1hZ2UsXG4gIE5ES0tpbmQsXG4gIE5ES0xpc3QsXG4gIE5ES0xpc3RLaW5kcyxcbiAgTkRLTmlwMDdTaWduZXIsXG4gIE5ES05pcDQ2QmFja2VuZCxcbiAgTkRLTmlwNDZTaWduZXIsXG4gIE5ES05vc3RyUnBjLFxuICBOREtOdXR6YXAsXG4gIE5ES1Bvb2wsXG4gIE5ES1ByaXZhdGVLZXlTaWduZXIsXG4gIE5ES1B1Ymxpc2hFcnJvcixcbiAgTkRLUmVsYXksXG4gIE5ES1JlbGF5QXV0aFBvbGljaWVzLFxuICBOREtSZWxheUxpc3QsXG4gIE5ES1JlbGF5U2V0LFxuICBOREtSZWxheVN0YXR1cyxcbiAgTkRLUmVwb3N0LFxuICBOREtTaW1wbGVHcm91cCxcbiAgTkRLU2ltcGxlR3JvdXBNZW1iZXJMaXN0LFxuICBOREtTaW1wbGVHcm91cE1ldGFkYXRhLFxuICBOREtTdWJzY3JpcHRpb24sXG4gIE5ES1N1YnNjcmlwdGlvbkNhY2hlVXNhZ2UsXG4gIE5ES1N1YnNjcmlwdGlvblJlY2VpcHQsXG4gIE5ES1N1YnNjcmlwdGlvblN0YXJ0LFxuICBOREtTdWJzY3JpcHRpb25UaWVyLFxuICBOREtUcmFuc2NyaXB0aW9uRFZNLFxuICBOREtVc2VyLFxuICBOREtWaWRlbyxcbiAgTkRLV2lraSxcbiAgTkRLWmFwcGVyLFxuICBOSVAzM19BX1JFR0VYLFxuICBjYWxjdWxhdGVSZWxheVNldEZyb21FdmVudCxcbiAgY2FsY3VsYXRlVGVybUR1cmF0aW9uSW5TZWNvbmRzLFxuICBjb21wYXJlRmlsdGVyLFxuICBOREsgYXMgZGVmYXVsdCxcbiAgZGVmYXVsdE9wdHMsXG4gIGRlc2VyaWFsaXplLFxuICBkdm1TY2hlZHVsZSxcbiAgZXZlbnRIYXNFVGFnTWFya2VycyxcbiAgZXZlbnRJc1BhcnRPZlRocmVhZCxcbiAgZXZlbnRJc1JlcGx5LFxuICBldmVudFJlcGxpZXMsXG4gIGV2ZW50VGhyZWFkSWRzLFxuICBldmVudFRocmVhZHMsXG4gIGV2ZW50c0J5U2FtZUF1dGhvcixcbiAgZmlsdGVyQW5kUmVsYXlTZXRGcm9tQmVjaDMyLFxuICBmaWx0ZXJGaW5nZXJwcmludCxcbiAgZmlsdGVyRm9yRXZlbnRzVGFnZ2luZ0lkLFxuICBmaWx0ZXJGcm9tSWQsXG4gIGdlbmVyYXRlQ29udGVudFRhZ3MsXG4gIGdlbmVyYXRlSGFzaHRhZ3MsXG4gIGdlbmVyYXRlU3ViSWQsXG4gIGdlbmVyYXRlWmFwUmVxdWVzdCxcbiAgZ2V0RXZlbnRSZXBseUlkLFxuICBnZXROaXA1N1phcFNwZWNGcm9tTHVkLFxuICBnZXRSZWxheUxpc3RGb3JVc2VyLFxuICBnZXRSZWxheUxpc3RGb3JVc2VycyxcbiAgZ2V0UmVwbHlUYWcsXG4gIGdldFJvb3RFdmVudElkLFxuICBnZXRSb290VGFnLFxuICBpbWV0YVRhZ1RvVGFnLFxuICBpc0V2ZW50T3JpZ2luYWxQb3N0LFxuICBpc05pcDMzQVZhbHVlLFxuICBtYXBJbWV0YVRhZyxcbiAgbWF0Y2hGaWx0ZXIsXG4gIG1lcmdlRmlsdGVycyxcbiAgbWVyZ2VUYWdzLFxuICBuZXdBbW91bnQsXG4gIG5vcm1hbGl6ZSxcbiAgbm9ybWFsaXplUmVsYXlVcmwsXG4gIG5vcm1hbGl6ZVVybCxcbiAgcGFyc2VUYWdUb1N1YnNjcmlwdGlvbkFtb3VudCxcbiAgcGluRXZlbnQsXG4gIHBvc3NpYmxlSW50ZXJ2YWxGcmVxdWVuY2llcyxcbiAgcHJvZmlsZUZyb21FdmVudCxcbiAgcHJvb2ZQMnBrLFxuICBwcm9vZlAycGtOb3N0cixcbiAgcHJvb2ZzVG90YWxCYWxhbmNlLFxuICBxdWVyeUZ1bGx5RmlsbGVkLFxuICByZWxheUxpc3RGcm9tS2luZDMsXG4gIHJlbGF5c0Zyb21CZWNoMzIsXG4gIHNlcmlhbGl6ZSxcbiAgc2VyaWFsaXplUHJvZmlsZSxcbiAgdHJ5Tm9ybWFsaXplUmVsYXlVcmwsXG4gIHVuaXF1ZVRhZyxcbiAgd3JhcEV2ZW50LFxuICB6YXBJbnZvaWNlRnJvbUV2ZW50XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/lib/esm/index.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/lib/esm/index.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Relay: () => (/* binding */ Relay),\n/* harmony export */   SimplePool: () => (/* binding */ SimplePool),\n/* harmony export */   finalizeEvent: () => (/* binding */ finalizeEvent),\n/* harmony export */   fj: () => (/* binding */ fakejson_exports),\n/* harmony export */   generateSecretKey: () => (/* binding */ generateSecretKey),\n/* harmony export */   getEventHash: () => (/* binding */ getEventHash),\n/* harmony export */   getFilterLimit: () => (/* binding */ getFilterLimit),\n/* harmony export */   getPublicKey: () => (/* binding */ getPublicKey),\n/* harmony export */   kinds: () => (/* binding */ kinds_exports),\n/* harmony export */   matchFilter: () => (/* binding */ matchFilter),\n/* harmony export */   matchFilters: () => (/* binding */ matchFilters),\n/* harmony export */   mergeFilters: () => (/* binding */ mergeFilters),\n/* harmony export */   nip04: () => (/* binding */ nip04_exports),\n/* harmony export */   nip05: () => (/* binding */ nip05_exports),\n/* harmony export */   nip10: () => (/* binding */ nip10_exports),\n/* harmony export */   nip11: () => (/* binding */ nip11_exports),\n/* harmony export */   nip13: () => (/* binding */ nip13_exports),\n/* harmony export */   nip18: () => (/* binding */ nip18_exports),\n/* harmony export */   nip19: () => (/* binding */ nip19_exports),\n/* harmony export */   nip21: () => (/* binding */ nip21_exports),\n/* harmony export */   nip25: () => (/* binding */ nip25_exports),\n/* harmony export */   nip27: () => (/* binding */ nip27_exports),\n/* harmony export */   nip28: () => (/* binding */ nip28_exports),\n/* harmony export */   nip30: () => (/* binding */ nip30_exports),\n/* harmony export */   nip39: () => (/* binding */ nip39_exports),\n/* harmony export */   nip42: () => (/* binding */ nip42_exports),\n/* harmony export */   nip44: () => (/* binding */ nip44_exports),\n/* harmony export */   nip47: () => (/* binding */ nip47_exports),\n/* harmony export */   nip57: () => (/* binding */ nip57_exports),\n/* harmony export */   nip59: () => (/* binding */ nip59_exports),\n/* harmony export */   nip98: () => (/* binding */ nip98_exports),\n/* harmony export */   parseReferences: () => (/* binding */ parseReferences),\n/* harmony export */   serializeEvent: () => (/* binding */ serializeEvent),\n/* harmony export */   sortEvents: () => (/* binding */ sortEvents),\n/* harmony export */   utils: () => (/* binding */ utils_exports),\n/* harmony export */   validateEvent: () => (/* binding */ validateEvent),\n/* harmony export */   verifiedSymbol: () => (/* binding */ verifiedSymbol),\n/* harmony export */   verifyEvent: () => (/* binding */ verifyEvent)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/secp256k1.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _scure_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @scure/base */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@scure/base/lib/esm/index.js\");\n/* harmony import */ var _noble_ciphers_aes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/ciphers/aes */ \"(ssr)/./node_modules/@noble/ciphers/esm/aes.js\");\n/* harmony import */ var _noble_ciphers_chacha__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @noble/ciphers/chacha */ \"(ssr)/./node_modules/@noble/ciphers/esm/chacha.js\");\n/* harmony import */ var _noble_ciphers_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @noble/ciphers/utils */ \"(ssr)/./node_modules/@noble/ciphers/esm/utils.js\");\n/* harmony import */ var _noble_hashes_hkdf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @noble/hashes/hkdf */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/hkdf.js\");\n/* harmony import */ var _noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @noble/hashes/hmac */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/hmac.js\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// pure.ts\n\n\n\n// core.ts\nvar verifiedSymbol = Symbol(\"verified\");\nvar isRecord = (obj) => obj instanceof Object;\nfunction validateEvent(event) {\n  if (!isRecord(event))\n    return false;\n  if (typeof event.kind !== \"number\")\n    return false;\n  if (typeof event.content !== \"string\")\n    return false;\n  if (typeof event.created_at !== \"number\")\n    return false;\n  if (typeof event.pubkey !== \"string\")\n    return false;\n  if (!event.pubkey.match(/^[a-f0-9]{64}$/))\n    return false;\n  if (!Array.isArray(event.tags))\n    return false;\n  for (let i2 = 0; i2 < event.tags.length; i2++) {\n    let tag = event.tags[i2];\n    if (!Array.isArray(tag))\n      return false;\n    for (let j = 0; j < tag.length; j++) {\n      if (typeof tag[j] === \"object\")\n        return false;\n    }\n  }\n  return true;\n}\nfunction sortEvents(events) {\n  return events.sort((a, b) => {\n    if (a.created_at !== b.created_at) {\n      return b.created_at - a.created_at;\n    }\n    return a.id.localeCompare(b.id);\n  });\n}\n\n// pure.ts\n\n\n// utils.ts\nvar utils_exports = {};\n__export(utils_exports, {\n  Queue: () => Queue,\n  QueueNode: () => QueueNode,\n  binarySearch: () => binarySearch,\n  insertEventIntoAscendingList: () => insertEventIntoAscendingList,\n  insertEventIntoDescendingList: () => insertEventIntoDescendingList,\n  normalizeURL: () => normalizeURL,\n  utf8Decoder: () => utf8Decoder,\n  utf8Encoder: () => utf8Encoder\n});\nvar utf8Decoder = new TextDecoder(\"utf-8\");\nvar utf8Encoder = new TextEncoder();\nfunction normalizeURL(url) {\n  if (url.indexOf(\"://\") === -1)\n    url = \"wss://\" + url;\n  let p = new URL(url);\n  p.pathname = p.pathname.replace(/\\/+/g, \"/\");\n  if (p.pathname.endsWith(\"/\"))\n    p.pathname = p.pathname.slice(0, -1);\n  if (p.port === \"80\" && p.protocol === \"ws:\" || p.port === \"443\" && p.protocol === \"wss:\")\n    p.port = \"\";\n  p.searchParams.sort();\n  p.hash = \"\";\n  return p.toString();\n}\nfunction insertEventIntoDescendingList(sortedArray, event) {\n  const [idx, found] = binarySearch(sortedArray, (b) => {\n    if (event.id === b.id)\n      return 0;\n    if (event.created_at === b.created_at)\n      return -1;\n    return b.created_at - event.created_at;\n  });\n  if (!found) {\n    sortedArray.splice(idx, 0, event);\n  }\n  return sortedArray;\n}\nfunction insertEventIntoAscendingList(sortedArray, event) {\n  const [idx, found] = binarySearch(sortedArray, (b) => {\n    if (event.id === b.id)\n      return 0;\n    if (event.created_at === b.created_at)\n      return -1;\n    return event.created_at - b.created_at;\n  });\n  if (!found) {\n    sortedArray.splice(idx, 0, event);\n  }\n  return sortedArray;\n}\nfunction binarySearch(arr, compare) {\n  let start = 0;\n  let end = arr.length - 1;\n  while (start <= end) {\n    const mid = Math.floor((start + end) / 2);\n    const cmp = compare(arr[mid]);\n    if (cmp === 0) {\n      return [mid, true];\n    }\n    if (cmp < 0) {\n      end = mid - 1;\n    } else {\n      start = mid + 1;\n    }\n  }\n  return [start, false];\n}\nvar QueueNode = class {\n  value;\n  next = null;\n  prev = null;\n  constructor(message) {\n    this.value = message;\n  }\n};\nvar Queue = class {\n  first;\n  last;\n  constructor() {\n    this.first = null;\n    this.last = null;\n  }\n  enqueue(value) {\n    const newNode = new QueueNode(value);\n    if (!this.last) {\n      this.first = newNode;\n      this.last = newNode;\n    } else if (this.last === this.first) {\n      this.last = newNode;\n      this.last.prev = this.first;\n      this.first.next = newNode;\n    } else {\n      newNode.prev = this.last;\n      this.last.next = newNode;\n      this.last = newNode;\n    }\n    return true;\n  }\n  dequeue() {\n    if (!this.first)\n      return null;\n    if (this.first === this.last) {\n      const target2 = this.first;\n      this.first = null;\n      this.last = null;\n      return target2.value;\n    }\n    const target = this.first;\n    this.first = target.next;\n    return target.value;\n  }\n};\n\n// pure.ts\nvar JS = class {\n  generateSecretKey() {\n    return _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.schnorr.utils.randomPrivateKey();\n  }\n  getPublicKey(secretKey) {\n    return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.schnorr.getPublicKey(secretKey));\n  }\n  finalizeEvent(t, secretKey) {\n    const event = t;\n    event.pubkey = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.schnorr.getPublicKey(secretKey));\n    event.id = getEventHash(event);\n    event.sig = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.schnorr.sign(getEventHash(event), secretKey));\n    event[verifiedSymbol] = true;\n    return event;\n  }\n  verifyEvent(event) {\n    if (typeof event[verifiedSymbol] === \"boolean\")\n      return event[verifiedSymbol];\n    const hash = getEventHash(event);\n    if (hash !== event.id) {\n      event[verifiedSymbol] = false;\n      return false;\n    }\n    try {\n      const valid = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.schnorr.verify(event.sig, hash, event.pubkey);\n      event[verifiedSymbol] = valid;\n      return valid;\n    } catch (err) {\n      event[verifiedSymbol] = false;\n      return false;\n    }\n  }\n};\nfunction serializeEvent(evt) {\n  if (!validateEvent(evt))\n    throw new Error(\"can't serialize event with wrong or missing properties\");\n  return JSON.stringify([0, evt.pubkey, evt.created_at, evt.kind, evt.tags, evt.content]);\n}\nfunction getEventHash(event) {\n  let eventHash = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_1__.sha256)(utf8Encoder.encode(serializeEvent(event)));\n  return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(eventHash);\n}\nvar i = new JS();\nvar generateSecretKey = i.generateSecretKey;\nvar getPublicKey = i.getPublicKey;\nvar finalizeEvent = i.finalizeEvent;\nvar verifyEvent = i.verifyEvent;\n\n// kinds.ts\nvar kinds_exports = {};\n__export(kinds_exports, {\n  Application: () => Application,\n  BadgeAward: () => BadgeAward,\n  BadgeDefinition: () => BadgeDefinition,\n  BlockedRelaysList: () => BlockedRelaysList,\n  BookmarkList: () => BookmarkList,\n  Bookmarksets: () => Bookmarksets,\n  Calendar: () => Calendar,\n  CalendarEventRSVP: () => CalendarEventRSVP,\n  ChannelCreation: () => ChannelCreation,\n  ChannelHideMessage: () => ChannelHideMessage,\n  ChannelMessage: () => ChannelMessage,\n  ChannelMetadata: () => ChannelMetadata,\n  ChannelMuteUser: () => ChannelMuteUser,\n  ClassifiedListing: () => ClassifiedListing,\n  ClientAuth: () => ClientAuth,\n  CommunitiesList: () => CommunitiesList,\n  CommunityDefinition: () => CommunityDefinition,\n  CommunityPostApproval: () => CommunityPostApproval,\n  Contacts: () => Contacts,\n  CreateOrUpdateProduct: () => CreateOrUpdateProduct,\n  CreateOrUpdateStall: () => CreateOrUpdateStall,\n  Curationsets: () => Curationsets,\n  Date: () => Date2,\n  DirectMessageRelaysList: () => DirectMessageRelaysList,\n  DraftClassifiedListing: () => DraftClassifiedListing,\n  DraftLong: () => DraftLong,\n  Emojisets: () => Emojisets,\n  EncryptedDirectMessage: () => EncryptedDirectMessage,\n  EventDeletion: () => EventDeletion,\n  FileMetadata: () => FileMetadata,\n  FileServerPreference: () => FileServerPreference,\n  Followsets: () => Followsets,\n  GenericRepost: () => GenericRepost,\n  Genericlists: () => Genericlists,\n  GiftWrap: () => GiftWrap,\n  HTTPAuth: () => HTTPAuth,\n  Handlerinformation: () => Handlerinformation,\n  Handlerrecommendation: () => Handlerrecommendation,\n  Highlights: () => Highlights,\n  InterestsList: () => InterestsList,\n  Interestsets: () => Interestsets,\n  JobFeedback: () => JobFeedback,\n  JobRequest: () => JobRequest,\n  JobResult: () => JobResult,\n  Label: () => Label,\n  LightningPubRPC: () => LightningPubRPC,\n  LiveChatMessage: () => LiveChatMessage,\n  LiveEvent: () => LiveEvent,\n  LongFormArticle: () => LongFormArticle,\n  Metadata: () => Metadata,\n  Mutelist: () => Mutelist,\n  NWCWalletInfo: () => NWCWalletInfo,\n  NWCWalletRequest: () => NWCWalletRequest,\n  NWCWalletResponse: () => NWCWalletResponse,\n  NostrConnect: () => NostrConnect,\n  OpenTimestamps: () => OpenTimestamps,\n  Pinlist: () => Pinlist,\n  PrivateDirectMessage: () => PrivateDirectMessage,\n  ProblemTracker: () => ProblemTracker,\n  ProfileBadges: () => ProfileBadges,\n  PublicChatsList: () => PublicChatsList,\n  Reaction: () => Reaction,\n  RecommendRelay: () => RecommendRelay,\n  RelayList: () => RelayList,\n  Relaysets: () => Relaysets,\n  Report: () => Report,\n  Reporting: () => Reporting,\n  Repost: () => Repost,\n  Seal: () => Seal,\n  SearchRelaysList: () => SearchRelaysList,\n  ShortTextNote: () => ShortTextNote,\n  Time: () => Time,\n  UserEmojiList: () => UserEmojiList,\n  UserStatuses: () => UserStatuses,\n  Zap: () => Zap,\n  ZapGoal: () => ZapGoal,\n  ZapRequest: () => ZapRequest,\n  classifyKind: () => classifyKind,\n  isEphemeralKind: () => isEphemeralKind,\n  isKind: () => isKind,\n  isParameterizedReplaceableKind: () => isParameterizedReplaceableKind,\n  isRegularKind: () => isRegularKind,\n  isReplaceableKind: () => isReplaceableKind\n});\nfunction isRegularKind(kind) {\n  return 1e3 <= kind && kind < 1e4 || [1, 2, 4, 5, 6, 7, 8, 16, 40, 41, 42, 43, 44].includes(kind);\n}\nfunction isReplaceableKind(kind) {\n  return [0, 3].includes(kind) || 1e4 <= kind && kind < 2e4;\n}\nfunction isEphemeralKind(kind) {\n  return 2e4 <= kind && kind < 3e4;\n}\nfunction isParameterizedReplaceableKind(kind) {\n  return 3e4 <= kind && kind < 4e4;\n}\nfunction classifyKind(kind) {\n  if (isRegularKind(kind))\n    return \"regular\";\n  if (isReplaceableKind(kind))\n    return \"replaceable\";\n  if (isEphemeralKind(kind))\n    return \"ephemeral\";\n  if (isParameterizedReplaceableKind(kind))\n    return \"parameterized\";\n  return \"unknown\";\n}\nfunction isKind(event, kind) {\n  const kindAsArray = kind instanceof Array ? kind : [kind];\n  return validateEvent(event) && kindAsArray.includes(event.kind) || false;\n}\nvar Metadata = 0;\nvar ShortTextNote = 1;\nvar RecommendRelay = 2;\nvar Contacts = 3;\nvar EncryptedDirectMessage = 4;\nvar EventDeletion = 5;\nvar Repost = 6;\nvar Reaction = 7;\nvar BadgeAward = 8;\nvar Seal = 13;\nvar PrivateDirectMessage = 14;\nvar GenericRepost = 16;\nvar ChannelCreation = 40;\nvar ChannelMetadata = 41;\nvar ChannelMessage = 42;\nvar ChannelHideMessage = 43;\nvar ChannelMuteUser = 44;\nvar OpenTimestamps = 1040;\nvar GiftWrap = 1059;\nvar FileMetadata = 1063;\nvar LiveChatMessage = 1311;\nvar ProblemTracker = 1971;\nvar Report = 1984;\nvar Reporting = 1984;\nvar Label = 1985;\nvar CommunityPostApproval = 4550;\nvar JobRequest = 5999;\nvar JobResult = 6999;\nvar JobFeedback = 7e3;\nvar ZapGoal = 9041;\nvar ZapRequest = 9734;\nvar Zap = 9735;\nvar Highlights = 9802;\nvar Mutelist = 1e4;\nvar Pinlist = 10001;\nvar RelayList = 10002;\nvar BookmarkList = 10003;\nvar CommunitiesList = 10004;\nvar PublicChatsList = 10005;\nvar BlockedRelaysList = 10006;\nvar SearchRelaysList = 10007;\nvar InterestsList = 10015;\nvar UserEmojiList = 10030;\nvar DirectMessageRelaysList = 10050;\nvar FileServerPreference = 10096;\nvar NWCWalletInfo = 13194;\nvar LightningPubRPC = 21e3;\nvar ClientAuth = 22242;\nvar NWCWalletRequest = 23194;\nvar NWCWalletResponse = 23195;\nvar NostrConnect = 24133;\nvar HTTPAuth = 27235;\nvar Followsets = 3e4;\nvar Genericlists = 30001;\nvar Relaysets = 30002;\nvar Bookmarksets = 30003;\nvar Curationsets = 30004;\nvar ProfileBadges = 30008;\nvar BadgeDefinition = 30009;\nvar Interestsets = 30015;\nvar CreateOrUpdateStall = 30017;\nvar CreateOrUpdateProduct = 30018;\nvar LongFormArticle = 30023;\nvar DraftLong = 30024;\nvar Emojisets = 30030;\nvar Application = 30078;\nvar LiveEvent = 30311;\nvar UserStatuses = 30315;\nvar ClassifiedListing = 30402;\nvar DraftClassifiedListing = 30403;\nvar Date2 = 31922;\nvar Time = 31923;\nvar Calendar = 31924;\nvar CalendarEventRSVP = 31925;\nvar Handlerrecommendation = 31989;\nvar Handlerinformation = 31990;\nvar CommunityDefinition = 34550;\n\n// filter.ts\nfunction matchFilter(filter, event) {\n  if (filter.ids && filter.ids.indexOf(event.id) === -1) {\n    return false;\n  }\n  if (filter.kinds && filter.kinds.indexOf(event.kind) === -1) {\n    return false;\n  }\n  if (filter.authors && filter.authors.indexOf(event.pubkey) === -1) {\n    return false;\n  }\n  for (let f in filter) {\n    if (f[0] === \"#\") {\n      let tagName = f.slice(1);\n      let values = filter[`#${tagName}`];\n      if (values && !event.tags.find(([t, v]) => t === f.slice(1) && values.indexOf(v) !== -1))\n        return false;\n    }\n  }\n  if (filter.since && event.created_at < filter.since)\n    return false;\n  if (filter.until && event.created_at > filter.until)\n    return false;\n  return true;\n}\nfunction matchFilters(filters, event) {\n  for (let i2 = 0; i2 < filters.length; i2++) {\n    if (matchFilter(filters[i2], event)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction mergeFilters(...filters) {\n  let result = {};\n  for (let i2 = 0; i2 < filters.length; i2++) {\n    let filter = filters[i2];\n    Object.entries(filter).forEach(([property, values]) => {\n      if (property === \"kinds\" || property === \"ids\" || property === \"authors\" || property[0] === \"#\") {\n        result[property] = result[property] || [];\n        for (let v = 0; v < values.length; v++) {\n          let value = values[v];\n          if (!result[property].includes(value))\n            result[property].push(value);\n        }\n      }\n    });\n    if (filter.limit && (!result.limit || filter.limit > result.limit))\n      result.limit = filter.limit;\n    if (filter.until && (!result.until || filter.until > result.until))\n      result.until = filter.until;\n    if (filter.since && (!result.since || filter.since < result.since))\n      result.since = filter.since;\n  }\n  return result;\n}\nfunction getFilterLimit(filter) {\n  if (filter.ids && !filter.ids.length)\n    return 0;\n  if (filter.kinds && !filter.kinds.length)\n    return 0;\n  if (filter.authors && !filter.authors.length)\n    return 0;\n  for (const [key, value] of Object.entries(filter)) {\n    if (key[0] === \"#\" && Array.isArray(value) && !value.length)\n      return 0;\n  }\n  return Math.min(\n    Math.max(0, filter.limit ?? Infinity),\n    filter.ids?.length ?? Infinity,\n    filter.authors?.length && filter.kinds?.every((kind) => isReplaceableKind(kind)) ? filter.authors.length * filter.kinds.length : Infinity,\n    filter.authors?.length && filter.kinds?.every((kind) => isParameterizedReplaceableKind(kind)) && filter[\"#d\"]?.length ? filter.authors.length * filter.kinds.length * filter[\"#d\"].length : Infinity\n  );\n}\n\n// fakejson.ts\nvar fakejson_exports = {};\n__export(fakejson_exports, {\n  getHex64: () => getHex64,\n  getInt: () => getInt,\n  getSubscriptionId: () => getSubscriptionId,\n  matchEventId: () => matchEventId,\n  matchEventKind: () => matchEventKind,\n  matchEventPubkey: () => matchEventPubkey\n});\nfunction getHex64(json, field) {\n  let len = field.length + 3;\n  let idx = json.indexOf(`\"${field}\":`) + len;\n  let s = json.slice(idx).indexOf(`\"`) + idx + 1;\n  return json.slice(s, s + 64);\n}\nfunction getInt(json, field) {\n  let len = field.length;\n  let idx = json.indexOf(`\"${field}\":`) + len + 3;\n  let sliced = json.slice(idx);\n  let end = Math.min(sliced.indexOf(\",\"), sliced.indexOf(\"}\"));\n  return parseInt(sliced.slice(0, end), 10);\n}\nfunction getSubscriptionId(json) {\n  let idx = json.slice(0, 22).indexOf(`\"EVENT\"`);\n  if (idx === -1)\n    return null;\n  let pstart = json.slice(idx + 7 + 1).indexOf(`\"`);\n  if (pstart === -1)\n    return null;\n  let start = idx + 7 + 1 + pstart;\n  let pend = json.slice(start + 1, 80).indexOf(`\"`);\n  if (pend === -1)\n    return null;\n  let end = start + 1 + pend;\n  return json.slice(start + 1, end);\n}\nfunction matchEventId(json, id) {\n  return id === getHex64(json, \"id\");\n}\nfunction matchEventPubkey(json, pubkey) {\n  return pubkey === getHex64(json, \"pubkey\");\n}\nfunction matchEventKind(json, kind) {\n  return kind === getInt(json, \"kind\");\n}\n\n// nip42.ts\nvar nip42_exports = {};\n__export(nip42_exports, {\n  makeAuthEvent: () => makeAuthEvent\n});\nfunction makeAuthEvent(relayURL, challenge) {\n  return {\n    kind: ClientAuth,\n    created_at: Math.floor(Date.now() / 1e3),\n    tags: [\n      [\"relay\", relayURL],\n      [\"challenge\", challenge]\n    ],\n    content: \"\"\n  };\n}\n\n// helpers.ts\nasync function yieldThread() {\n  return new Promise((resolve) => {\n    const ch = new MessageChannel();\n    const handler = () => {\n      ch.port1.removeEventListener(\"message\", handler);\n      resolve();\n    };\n    ch.port1.addEventListener(\"message\", handler);\n    ch.port2.postMessage(0);\n    ch.port1.start();\n  });\n}\nvar alwaysTrue = (t) => {\n  t[verifiedSymbol] = true;\n  return true;\n};\n\n// abstract-relay.ts\nvar AbstractRelay = class {\n  url;\n  _connected = false;\n  onclose = null;\n  onnotice = (msg) => console.debug(`NOTICE from ${this.url}: ${msg}`);\n  _onauth = null;\n  baseEoseTimeout = 4400;\n  connectionTimeout = 4400;\n  publishTimeout = 4400;\n  openSubs = /* @__PURE__ */ new Map();\n  connectionTimeoutHandle;\n  connectionPromise;\n  openCountRequests = /* @__PURE__ */ new Map();\n  openEventPublishes = /* @__PURE__ */ new Map();\n  ws;\n  incomingMessageQueue = new Queue();\n  queueRunning = false;\n  challenge;\n  serial = 0;\n  verifyEvent;\n  _WebSocket;\n  constructor(url, opts) {\n    this.url = normalizeURL(url);\n    this.verifyEvent = opts.verifyEvent;\n    this._WebSocket = opts.websocketImplementation || WebSocket;\n  }\n  static async connect(url, opts) {\n    const relay = new AbstractRelay(url, opts);\n    await relay.connect();\n    return relay;\n  }\n  closeAllSubscriptions(reason) {\n    for (let [_, sub] of this.openSubs) {\n      sub.close(reason);\n    }\n    this.openSubs.clear();\n    for (let [_, ep] of this.openEventPublishes) {\n      ep.reject(new Error(reason));\n    }\n    this.openEventPublishes.clear();\n    for (let [_, cr] of this.openCountRequests) {\n      cr.reject(new Error(reason));\n    }\n    this.openCountRequests.clear();\n  }\n  get connected() {\n    return this._connected;\n  }\n  async connect() {\n    if (this.connectionPromise)\n      return this.connectionPromise;\n    this.challenge = void 0;\n    this.connectionPromise = new Promise((resolve, reject) => {\n      this.connectionTimeoutHandle = setTimeout(() => {\n        reject(\"connection timed out\");\n        this.connectionPromise = void 0;\n        this.onclose?.();\n        this.closeAllSubscriptions(\"relay connection timed out\");\n      }, this.connectionTimeout);\n      try {\n        this.ws = new this._WebSocket(this.url);\n      } catch (err) {\n        reject(err);\n        return;\n      }\n      this.ws.onopen = () => {\n        clearTimeout(this.connectionTimeoutHandle);\n        this._connected = true;\n        resolve();\n      };\n      this.ws.onerror = (ev) => {\n        reject(ev.message || \"websocket error\");\n        if (this._connected) {\n          this._connected = false;\n          this.connectionPromise = void 0;\n          this.onclose?.();\n          this.closeAllSubscriptions(\"relay connection errored\");\n        }\n      };\n      this.ws.onclose = async () => {\n        if (this._connected) {\n          this._connected = false;\n          this.connectionPromise = void 0;\n          this.onclose?.();\n          this.closeAllSubscriptions(\"relay connection closed\");\n        }\n      };\n      this.ws.onmessage = this._onmessage.bind(this);\n    });\n    return this.connectionPromise;\n  }\n  async runQueue() {\n    this.queueRunning = true;\n    while (true) {\n      if (false === this.handleNext()) {\n        break;\n      }\n      await yieldThread();\n    }\n    this.queueRunning = false;\n  }\n  handleNext() {\n    const json = this.incomingMessageQueue.dequeue();\n    if (!json) {\n      return false;\n    }\n    const subid = getSubscriptionId(json);\n    if (subid) {\n      const so = this.openSubs.get(subid);\n      if (!so) {\n        return;\n      }\n      const id = getHex64(json, \"id\");\n      const alreadyHave = so.alreadyHaveEvent?.(id);\n      so.receivedEvent?.(this, id);\n      if (alreadyHave) {\n        return;\n      }\n    }\n    try {\n      let data = JSON.parse(json);\n      switch (data[0]) {\n        case \"EVENT\": {\n          const so = this.openSubs.get(data[1]);\n          const event = data[2];\n          if (this.verifyEvent(event) && matchFilters(so.filters, event)) {\n            so.onevent(event);\n          }\n          return;\n        }\n        case \"COUNT\": {\n          const id = data[1];\n          const payload = data[2];\n          const cr = this.openCountRequests.get(id);\n          if (cr) {\n            cr.resolve(payload.count);\n            this.openCountRequests.delete(id);\n          }\n          return;\n        }\n        case \"EOSE\": {\n          const so = this.openSubs.get(data[1]);\n          if (!so)\n            return;\n          so.receivedEose();\n          return;\n        }\n        case \"OK\": {\n          const id = data[1];\n          const ok = data[2];\n          const reason = data[3];\n          const ep = this.openEventPublishes.get(id);\n          if (ep) {\n            if (ok)\n              ep.resolve(reason);\n            else\n              ep.reject(new Error(reason));\n            this.openEventPublishes.delete(id);\n          }\n          return;\n        }\n        case \"CLOSED\": {\n          const id = data[1];\n          const so = this.openSubs.get(id);\n          if (!so)\n            return;\n          so.closed = true;\n          so.close(data[2]);\n          return;\n        }\n        case \"NOTICE\":\n          this.onnotice(data[1]);\n          return;\n        case \"AUTH\": {\n          this.challenge = data[1];\n          this._onauth?.(data[1]);\n          return;\n        }\n      }\n    } catch (err) {\n      return;\n    }\n  }\n  async send(message) {\n    if (!this.connectionPromise)\n      throw new Error(\"sending on closed connection\");\n    this.connectionPromise.then(() => {\n      this.ws?.send(message);\n    });\n  }\n  async auth(signAuthEvent) {\n    if (!this.challenge)\n      throw new Error(\"can't perform auth, no challenge was received\");\n    const evt = await signAuthEvent(makeAuthEvent(this.url, this.challenge));\n    const ret = new Promise((resolve, reject) => {\n      this.openEventPublishes.set(evt.id, { resolve, reject });\n    });\n    this.send('[\"AUTH\",' + JSON.stringify(evt) + \"]\");\n    return ret;\n  }\n  async publish(event) {\n    const ret = new Promise((resolve, reject) => {\n      this.openEventPublishes.set(event.id, { resolve, reject });\n    });\n    this.send('[\"EVENT\",' + JSON.stringify(event) + \"]\");\n    setTimeout(() => {\n      const ep = this.openEventPublishes.get(event.id);\n      if (ep) {\n        ep.reject(new Error(\"publish timed out\"));\n        this.openEventPublishes.delete(event.id);\n      }\n    }, this.publishTimeout);\n    return ret;\n  }\n  async count(filters, params) {\n    this.serial++;\n    const id = params?.id || \"count:\" + this.serial;\n    const ret = new Promise((resolve, reject) => {\n      this.openCountRequests.set(id, { resolve, reject });\n    });\n    this.send('[\"COUNT\",\"' + id + '\",' + JSON.stringify(filters).substring(1));\n    return ret;\n  }\n  subscribe(filters, params) {\n    const subscription = this.prepareSubscription(filters, params);\n    subscription.fire();\n    return subscription;\n  }\n  prepareSubscription(filters, params) {\n    this.serial++;\n    const id = params.id || \"sub:\" + this.serial;\n    const subscription = new Subscription(this, id, filters, params);\n    this.openSubs.set(id, subscription);\n    return subscription;\n  }\n  close() {\n    this.closeAllSubscriptions(\"relay connection closed by us\");\n    this._connected = false;\n    this.ws?.close();\n  }\n  _onmessage(ev) {\n    this.incomingMessageQueue.enqueue(ev.data);\n    if (!this.queueRunning) {\n      this.runQueue();\n    }\n  }\n};\nvar Subscription = class {\n  relay;\n  id;\n  closed = false;\n  eosed = false;\n  filters;\n  alreadyHaveEvent;\n  receivedEvent;\n  onevent;\n  oneose;\n  onclose;\n  eoseTimeout;\n  eoseTimeoutHandle;\n  constructor(relay, id, filters, params) {\n    this.relay = relay;\n    this.filters = filters;\n    this.id = id;\n    this.alreadyHaveEvent = params.alreadyHaveEvent;\n    this.receivedEvent = params.receivedEvent;\n    this.eoseTimeout = params.eoseTimeout || relay.baseEoseTimeout;\n    this.oneose = params.oneose;\n    this.onclose = params.onclose;\n    this.onevent = params.onevent || ((event) => {\n      console.warn(\n        `onevent() callback not defined for subscription '${this.id}' in relay ${this.relay.url}. event received:`,\n        event\n      );\n    });\n  }\n  fire() {\n    this.relay.send('[\"REQ\",\"' + this.id + '\",' + JSON.stringify(this.filters).substring(1));\n    this.eoseTimeoutHandle = setTimeout(this.receivedEose.bind(this), this.eoseTimeout);\n  }\n  receivedEose() {\n    if (this.eosed)\n      return;\n    clearTimeout(this.eoseTimeoutHandle);\n    this.eosed = true;\n    this.oneose?.();\n  }\n  close(reason = \"closed by caller\") {\n    if (!this.closed && this.relay.connected) {\n      this.relay.send('[\"CLOSE\",' + JSON.stringify(this.id) + \"]\");\n      this.closed = true;\n    }\n    this.relay.openSubs.delete(this.id);\n    this.onclose?.(reason);\n  }\n};\n\n// relay.ts\nvar _WebSocket;\ntry {\n  _WebSocket = WebSocket;\n} catch {\n}\nvar Relay = class extends AbstractRelay {\n  constructor(url) {\n    super(url, { verifyEvent, websocketImplementation: _WebSocket });\n  }\n  static async connect(url) {\n    const relay = new Relay(url);\n    await relay.connect();\n    return relay;\n  }\n};\n\n// abstract-pool.ts\nvar AbstractSimplePool = class {\n  relays = /* @__PURE__ */ new Map();\n  seenOn = /* @__PURE__ */ new Map();\n  trackRelays = false;\n  verifyEvent;\n  trustedRelayURLs = /* @__PURE__ */ new Set();\n  _WebSocket;\n  constructor(opts) {\n    this.verifyEvent = opts.verifyEvent;\n    this._WebSocket = opts.websocketImplementation;\n  }\n  async ensureRelay(url, params) {\n    url = normalizeURL(url);\n    let relay = this.relays.get(url);\n    if (!relay) {\n      relay = new AbstractRelay(url, {\n        verifyEvent: this.trustedRelayURLs.has(url) ? alwaysTrue : this.verifyEvent,\n        websocketImplementation: this._WebSocket\n      });\n      if (params?.connectionTimeout)\n        relay.connectionTimeout = params.connectionTimeout;\n      this.relays.set(url, relay);\n    }\n    await relay.connect();\n    return relay;\n  }\n  close(relays) {\n    relays.map(normalizeURL).forEach((url) => {\n      this.relays.get(url)?.close();\n    });\n  }\n  subscribeMany(relays, filters, params) {\n    return this.subscribeManyMap(Object.fromEntries(relays.map((url) => [url, filters])), params);\n  }\n  subscribeManyMap(requests, params) {\n    if (this.trackRelays) {\n      params.receivedEvent = (relay, id) => {\n        let set = this.seenOn.get(id);\n        if (!set) {\n          set = /* @__PURE__ */ new Set();\n          this.seenOn.set(id, set);\n        }\n        set.add(relay);\n      };\n    }\n    const _knownIds = /* @__PURE__ */ new Set();\n    const subs = [];\n    const relaysLength = Object.keys(requests).length;\n    const eosesReceived = [];\n    let handleEose = (i2) => {\n      eosesReceived[i2] = true;\n      if (eosesReceived.filter((a) => a).length === relaysLength) {\n        params.oneose?.();\n        handleEose = () => {\n        };\n      }\n    };\n    const closesReceived = [];\n    let handleClose = (i2, reason) => {\n      handleEose(i2);\n      closesReceived[i2] = reason;\n      if (closesReceived.filter((a) => a).length === relaysLength) {\n        params.onclose?.(closesReceived);\n        handleClose = () => {\n        };\n      }\n    };\n    const localAlreadyHaveEventHandler = (id) => {\n      if (params.alreadyHaveEvent?.(id)) {\n        return true;\n      }\n      const have = _knownIds.has(id);\n      _knownIds.add(id);\n      return have;\n    };\n    const allOpened = Promise.all(\n      Object.entries(requests).map(async (req, i2, arr) => {\n        if (arr.indexOf(req) !== i2) {\n          handleClose(i2, \"duplicate url\");\n          return;\n        }\n        let [url, filters] = req;\n        url = normalizeURL(url);\n        let relay;\n        try {\n          relay = await this.ensureRelay(url, {\n            connectionTimeout: params.maxWait ? Math.max(params.maxWait * 0.8, params.maxWait - 1e3) : void 0\n          });\n        } catch (err) {\n          handleClose(i2, err?.message || String(err));\n          return;\n        }\n        let subscription = relay.subscribe(filters, {\n          ...params,\n          oneose: () => handleEose(i2),\n          onclose: (reason) => handleClose(i2, reason),\n          alreadyHaveEvent: localAlreadyHaveEventHandler,\n          eoseTimeout: params.maxWait\n        });\n        subs.push(subscription);\n      })\n    );\n    return {\n      async close() {\n        await allOpened;\n        subs.forEach((sub) => {\n          sub.close();\n        });\n      }\n    };\n  }\n  subscribeManyEose(relays, filters, params) {\n    const subcloser = this.subscribeMany(relays, filters, {\n      ...params,\n      oneose() {\n        subcloser.close();\n      }\n    });\n    return subcloser;\n  }\n  async querySync(relays, filter, params) {\n    return new Promise(async (resolve) => {\n      const events = [];\n      this.subscribeManyEose(relays, [filter], {\n        ...params,\n        onevent(event) {\n          events.push(event);\n        },\n        onclose(_) {\n          resolve(events);\n        }\n      });\n    });\n  }\n  async get(relays, filter, params) {\n    filter.limit = 1;\n    const events = await this.querySync(relays, filter, params);\n    events.sort((a, b) => b.created_at - a.created_at);\n    return events[0] || null;\n  }\n  publish(relays, event) {\n    return relays.map(normalizeURL).map(async (url, i2, arr) => {\n      if (arr.indexOf(url) !== i2) {\n        return Promise.reject(\"duplicate url\");\n      }\n      let r = await this.ensureRelay(url);\n      return r.publish(event).then((reason) => {\n        if (this.trackRelays) {\n          let set = this.seenOn.get(event.id);\n          if (!set) {\n            set = /* @__PURE__ */ new Set();\n            this.seenOn.set(event.id, set);\n          }\n          set.add(r);\n        }\n        return reason;\n      });\n    });\n  }\n  listConnectionStatus() {\n    const map = /* @__PURE__ */ new Map();\n    this.relays.forEach((relay, url) => map.set(url, relay.connected));\n    return map;\n  }\n  destroy() {\n    this.relays.forEach((conn) => conn.close());\n    this.relays = /* @__PURE__ */ new Map();\n  }\n};\n\n// pool.ts\nvar _WebSocket2;\ntry {\n  _WebSocket2 = WebSocket;\n} catch {\n}\nvar SimplePool = class extends AbstractSimplePool {\n  constructor() {\n    super({ verifyEvent, websocketImplementation: _WebSocket2 });\n  }\n};\n\n// nip19.ts\nvar nip19_exports = {};\n__export(nip19_exports, {\n  BECH32_REGEX: () => BECH32_REGEX,\n  Bech32MaxSize: () => Bech32MaxSize,\n  NostrTypeGuard: () => NostrTypeGuard,\n  decode: () => decode,\n  encodeBytes: () => encodeBytes,\n  naddrEncode: () => naddrEncode,\n  neventEncode: () => neventEncode,\n  noteEncode: () => noteEncode,\n  nprofileEncode: () => nprofileEncode,\n  npubEncode: () => npubEncode,\n  nsecEncode: () => nsecEncode\n});\n\n\nvar NostrTypeGuard = {\n  isNProfile: (value) => /^nprofile1[a-z\\d]+$/.test(value || \"\"),\n  isNEvent: (value) => /^nevent1[a-z\\d]+$/.test(value || \"\"),\n  isNAddr: (value) => /^naddr1[a-z\\d]+$/.test(value || \"\"),\n  isNSec: (value) => /^nsec1[a-z\\d]{58}$/.test(value || \"\"),\n  isNPub: (value) => /^npub1[a-z\\d]{58}$/.test(value || \"\"),\n  isNote: (value) => /^note1[a-z\\d]+$/.test(value || \"\"),\n  isNcryptsec: (value) => /^ncryptsec1[a-z\\d]+$/.test(value || \"\")\n};\nvar Bech32MaxSize = 5e3;\nvar BECH32_REGEX = /[\\x21-\\x7E]{1,83}1[023456789acdefghjklmnpqrstuvwxyz]{6,}/;\nfunction integerToUint8Array(number) {\n  const uint8Array = new Uint8Array(4);\n  uint8Array[0] = number >> 24 & 255;\n  uint8Array[1] = number >> 16 & 255;\n  uint8Array[2] = number >> 8 & 255;\n  uint8Array[3] = number & 255;\n  return uint8Array;\n}\nfunction decode(nip19) {\n  let { prefix, words } = _scure_base__WEBPACK_IMPORTED_MODULE_3__.bech32.decode(nip19, Bech32MaxSize);\n  let data = new Uint8Array(_scure_base__WEBPACK_IMPORTED_MODULE_3__.bech32.fromWords(words));\n  switch (prefix) {\n    case \"nprofile\": {\n      let tlv = parseTLV(data);\n      if (!tlv[0]?.[0])\n        throw new Error(\"missing TLV 0 for nprofile\");\n      if (tlv[0][0].length !== 32)\n        throw new Error(\"TLV 0 should be 32 bytes\");\n      return {\n        type: \"nprofile\",\n        data: {\n          pubkey: (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(tlv[0][0]),\n          relays: tlv[1] ? tlv[1].map((d) => utf8Decoder.decode(d)) : []\n        }\n      };\n    }\n    case \"nevent\": {\n      let tlv = parseTLV(data);\n      if (!tlv[0]?.[0])\n        throw new Error(\"missing TLV 0 for nevent\");\n      if (tlv[0][0].length !== 32)\n        throw new Error(\"TLV 0 should be 32 bytes\");\n      if (tlv[2] && tlv[2][0].length !== 32)\n        throw new Error(\"TLV 2 should be 32 bytes\");\n      if (tlv[3] && tlv[3][0].length !== 4)\n        throw new Error(\"TLV 3 should be 4 bytes\");\n      return {\n        type: \"nevent\",\n        data: {\n          id: (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(tlv[0][0]),\n          relays: tlv[1] ? tlv[1].map((d) => utf8Decoder.decode(d)) : [],\n          author: tlv[2]?.[0] ? (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(tlv[2][0]) : void 0,\n          kind: tlv[3]?.[0] ? parseInt((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(tlv[3][0]), 16) : void 0\n        }\n      };\n    }\n    case \"naddr\": {\n      let tlv = parseTLV(data);\n      if (!tlv[0]?.[0])\n        throw new Error(\"missing TLV 0 for naddr\");\n      if (!tlv[2]?.[0])\n        throw new Error(\"missing TLV 2 for naddr\");\n      if (tlv[2][0].length !== 32)\n        throw new Error(\"TLV 2 should be 32 bytes\");\n      if (!tlv[3]?.[0])\n        throw new Error(\"missing TLV 3 for naddr\");\n      if (tlv[3][0].length !== 4)\n        throw new Error(\"TLV 3 should be 4 bytes\");\n      return {\n        type: \"naddr\",\n        data: {\n          identifier: utf8Decoder.decode(tlv[0][0]),\n          pubkey: (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(tlv[2][0]),\n          kind: parseInt((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(tlv[3][0]), 16),\n          relays: tlv[1] ? tlv[1].map((d) => utf8Decoder.decode(d)) : []\n        }\n      };\n    }\n    case \"nsec\":\n      return { type: prefix, data };\n    case \"npub\":\n    case \"note\":\n      return { type: prefix, data: (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(data) };\n    default:\n      throw new Error(`unknown prefix ${prefix}`);\n  }\n}\nfunction parseTLV(data) {\n  let result = {};\n  let rest = data;\n  while (rest.length > 0) {\n    let t = rest[0];\n    let l = rest[1];\n    let v = rest.slice(2, 2 + l);\n    rest = rest.slice(2 + l);\n    if (v.length < l)\n      throw new Error(`not enough data to read on TLV ${t}`);\n    result[t] = result[t] || [];\n    result[t].push(v);\n  }\n  return result;\n}\nfunction nsecEncode(key) {\n  return encodeBytes(\"nsec\", key);\n}\nfunction npubEncode(hex) {\n  return encodeBytes(\"npub\", (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.hexToBytes)(hex));\n}\nfunction noteEncode(hex) {\n  return encodeBytes(\"note\", (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.hexToBytes)(hex));\n}\nfunction encodeBech32(prefix, data) {\n  let words = _scure_base__WEBPACK_IMPORTED_MODULE_3__.bech32.toWords(data);\n  return _scure_base__WEBPACK_IMPORTED_MODULE_3__.bech32.encode(prefix, words, Bech32MaxSize);\n}\nfunction encodeBytes(prefix, bytes) {\n  return encodeBech32(prefix, bytes);\n}\nfunction nprofileEncode(profile) {\n  let data = encodeTLV({\n    0: [(0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.hexToBytes)(profile.pubkey)],\n    1: (profile.relays || []).map((url) => utf8Encoder.encode(url))\n  });\n  return encodeBech32(\"nprofile\", data);\n}\nfunction neventEncode(event) {\n  let kindArray;\n  if (event.kind !== void 0) {\n    kindArray = integerToUint8Array(event.kind);\n  }\n  let data = encodeTLV({\n    0: [(0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.hexToBytes)(event.id)],\n    1: (event.relays || []).map((url) => utf8Encoder.encode(url)),\n    2: event.author ? [(0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.hexToBytes)(event.author)] : [],\n    3: kindArray ? [new Uint8Array(kindArray)] : []\n  });\n  return encodeBech32(\"nevent\", data);\n}\nfunction naddrEncode(addr) {\n  let kind = new ArrayBuffer(4);\n  new DataView(kind).setUint32(0, addr.kind, false);\n  let data = encodeTLV({\n    0: [utf8Encoder.encode(addr.identifier)],\n    1: (addr.relays || []).map((url) => utf8Encoder.encode(url)),\n    2: [(0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.hexToBytes)(addr.pubkey)],\n    3: [new Uint8Array(kind)]\n  });\n  return encodeBech32(\"naddr\", data);\n}\nfunction encodeTLV(tlv) {\n  let entries = [];\n  Object.entries(tlv).reverse().forEach(([t, vs]) => {\n    vs.forEach((v) => {\n      let entry = new Uint8Array(v.length + 2);\n      entry.set([parseInt(t)], 0);\n      entry.set([v.length], 1);\n      entry.set(v, 2);\n      entries.push(entry);\n    });\n  });\n  return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...entries);\n}\n\n// references.ts\nvar mentionRegex = /\\bnostr:((note|npub|naddr|nevent|nprofile)1\\w+)\\b|#\\[(\\d+)\\]/g;\nfunction parseReferences(evt) {\n  let references = [];\n  for (let ref of evt.content.matchAll(mentionRegex)) {\n    if (ref[2]) {\n      try {\n        let { type, data } = decode(ref[1]);\n        switch (type) {\n          case \"npub\": {\n            references.push({\n              text: ref[0],\n              profile: { pubkey: data, relays: [] }\n            });\n            break;\n          }\n          case \"nprofile\": {\n            references.push({\n              text: ref[0],\n              profile: data\n            });\n            break;\n          }\n          case \"note\": {\n            references.push({\n              text: ref[0],\n              event: { id: data, relays: [] }\n            });\n            break;\n          }\n          case \"nevent\": {\n            references.push({\n              text: ref[0],\n              event: data\n            });\n            break;\n          }\n          case \"naddr\": {\n            references.push({\n              text: ref[0],\n              address: data\n            });\n            break;\n          }\n        }\n      } catch (err) {\n      }\n    } else if (ref[3]) {\n      let idx = parseInt(ref[3], 10);\n      let tag = evt.tags[idx];\n      if (!tag)\n        continue;\n      switch (tag[0]) {\n        case \"p\": {\n          references.push({\n            text: ref[0],\n            profile: { pubkey: tag[1], relays: tag[2] ? [tag[2]] : [] }\n          });\n          break;\n        }\n        case \"e\": {\n          references.push({\n            text: ref[0],\n            event: { id: tag[1], relays: tag[2] ? [tag[2]] : [] }\n          });\n          break;\n        }\n        case \"a\": {\n          try {\n            let [kind, pubkey, identifier] = tag[1].split(\":\");\n            references.push({\n              text: ref[0],\n              address: {\n                identifier,\n                pubkey,\n                kind: parseInt(kind, 10),\n                relays: tag[2] ? [tag[2]] : []\n              }\n            });\n          } catch (err) {\n          }\n          break;\n        }\n      }\n    }\n  }\n  return references;\n}\n\n// nip04.ts\nvar nip04_exports = {};\n__export(nip04_exports, {\n  decrypt: () => decrypt,\n  encrypt: () => encrypt\n});\n\n\n\n\nasync function encrypt(secretKey, pubkey, text) {\n  const privkey = secretKey instanceof Uint8Array ? (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(secretKey) : secretKey;\n  const key = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.getSharedSecret(privkey, \"02\" + pubkey);\n  const normalizedKey = getNormalizedX(key);\n  let iv = Uint8Array.from((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.randomBytes)(16));\n  let plaintext = utf8Encoder.encode(text);\n  let ciphertext = (0,_noble_ciphers_aes__WEBPACK_IMPORTED_MODULE_4__.cbc)(normalizedKey, iv).encrypt(plaintext);\n  let ctb64 = _scure_base__WEBPACK_IMPORTED_MODULE_3__.base64.encode(new Uint8Array(ciphertext));\n  let ivb64 = _scure_base__WEBPACK_IMPORTED_MODULE_3__.base64.encode(new Uint8Array(iv.buffer));\n  return `${ctb64}?iv=${ivb64}`;\n}\nasync function decrypt(secretKey, pubkey, data) {\n  const privkey = secretKey instanceof Uint8Array ? (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(secretKey) : secretKey;\n  let [ctb64, ivb64] = data.split(\"?iv=\");\n  let key = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.getSharedSecret(privkey, \"02\" + pubkey);\n  let normalizedKey = getNormalizedX(key);\n  let iv = _scure_base__WEBPACK_IMPORTED_MODULE_3__.base64.decode(ivb64);\n  let ciphertext = _scure_base__WEBPACK_IMPORTED_MODULE_3__.base64.decode(ctb64);\n  let plaintext = (0,_noble_ciphers_aes__WEBPACK_IMPORTED_MODULE_4__.cbc)(normalizedKey, iv).decrypt(ciphertext);\n  return utf8Decoder.decode(plaintext);\n}\nfunction getNormalizedX(key) {\n  return key.slice(1, 33);\n}\n\n// nip05.ts\nvar nip05_exports = {};\n__export(nip05_exports, {\n  NIP05_REGEX: () => NIP05_REGEX,\n  isNip05: () => isNip05,\n  isValid: () => isValid,\n  queryProfile: () => queryProfile,\n  searchDomain: () => searchDomain,\n  useFetchImplementation: () => useFetchImplementation\n});\nvar NIP05_REGEX = /^(?:([\\w.+-]+)@)?([\\w_-]+(\\.[\\w_-]+)+)$/;\nvar isNip05 = (value) => NIP05_REGEX.test(value || \"\");\nvar _fetch;\ntry {\n  _fetch = fetch;\n} catch (_) {\n  null;\n}\nfunction useFetchImplementation(fetchImplementation) {\n  _fetch = fetchImplementation;\n}\nasync function searchDomain(domain, query = \"\") {\n  try {\n    const url = `https://${domain}/.well-known/nostr.json?name=${query}`;\n    const res = await _fetch(url, { redirect: \"manual\" });\n    if (res.status !== 200) {\n      throw Error(\"Wrong response code\");\n    }\n    const json = await res.json();\n    return json.names;\n  } catch (_) {\n    return {};\n  }\n}\nasync function queryProfile(fullname) {\n  const match = fullname.match(NIP05_REGEX);\n  if (!match)\n    return null;\n  const [, name = \"_\", domain] = match;\n  try {\n    const url = `https://${domain}/.well-known/nostr.json?name=${name}`;\n    const res = await _fetch(url, { redirect: \"manual\" });\n    if (res.status !== 200) {\n      throw Error(\"Wrong response code\");\n    }\n    const json = await res.json();\n    const pubkey = json.names[name];\n    return pubkey ? { pubkey, relays: json.relays?.[pubkey] } : null;\n  } catch (_e) {\n    return null;\n  }\n}\nasync function isValid(pubkey, nip05) {\n  const res = await queryProfile(nip05);\n  return res ? res.pubkey === pubkey : false;\n}\n\n// nip10.ts\nvar nip10_exports = {};\n__export(nip10_exports, {\n  parse: () => parse\n});\nfunction parse(event) {\n  const result = {\n    reply: void 0,\n    root: void 0,\n    mentions: [],\n    profiles: [],\n    quotes: []\n  };\n  let maybeParent;\n  let maybeRoot;\n  for (let i2 = event.tags.length - 1; i2 >= 0; i2--) {\n    const tag = event.tags[i2];\n    if (tag[0] === \"e\" && tag[1]) {\n      const [_, eTagEventId, eTagRelayUrl, eTagMarker, eTagAuthor] = tag;\n      const eventPointer = {\n        id: eTagEventId,\n        relays: eTagRelayUrl ? [eTagRelayUrl] : [],\n        author: eTagAuthor\n      };\n      if (eTagMarker === \"root\") {\n        result.root = eventPointer;\n        continue;\n      }\n      if (eTagMarker === \"reply\") {\n        result.reply = eventPointer;\n        continue;\n      }\n      if (eTagMarker === \"mention\") {\n        result.mentions.push(eventPointer);\n        continue;\n      }\n      if (!maybeParent) {\n        maybeParent = eventPointer;\n      } else {\n        maybeRoot = eventPointer;\n      }\n      result.mentions.push(eventPointer);\n      continue;\n    }\n    if (tag[0] === \"q\" && tag[1]) {\n      const [_, eTagEventId, eTagRelayUrl] = tag;\n      result.quotes.push({\n        id: eTagEventId,\n        relays: eTagRelayUrl ? [eTagRelayUrl] : []\n      });\n    }\n    if (tag[0] === \"p\" && tag[1]) {\n      result.profiles.push({\n        pubkey: tag[1],\n        relays: tag[2] ? [tag[2]] : []\n      });\n      continue;\n    }\n  }\n  if (!result.root) {\n    result.root = maybeRoot || maybeParent || result.reply;\n  }\n  if (!result.reply) {\n    result.reply = maybeParent || result.root;\n  }\n  ;\n  [result.reply, result.root].forEach((ref) => {\n    if (!ref)\n      return;\n    let idx = result.mentions.indexOf(ref);\n    if (idx !== -1) {\n      result.mentions.splice(idx, 1);\n    }\n    if (ref.author) {\n      let author = result.profiles.find((p) => p.pubkey === ref.author);\n      if (author && author.relays) {\n        if (!ref.relays) {\n          ref.relays = [];\n        }\n        author.relays.forEach((url) => {\n          if (ref.relays?.indexOf(url) === -1)\n            ref.relays.push(url);\n        });\n        author.relays = ref.relays;\n      }\n    }\n  });\n  result.mentions.forEach((ref) => {\n    if (ref.author) {\n      let author = result.profiles.find((p) => p.pubkey === ref.author);\n      if (author && author.relays) {\n        if (!ref.relays) {\n          ref.relays = [];\n        }\n        author.relays.forEach((url) => {\n          if (ref.relays.indexOf(url) === -1)\n            ref.relays.push(url);\n        });\n        author.relays = ref.relays;\n      }\n    }\n  });\n  return result;\n}\n\n// nip11.ts\nvar nip11_exports = {};\n__export(nip11_exports, {\n  fetchRelayInformation: () => fetchRelayInformation,\n  useFetchImplementation: () => useFetchImplementation2\n});\nvar _fetch2;\ntry {\n  _fetch2 = fetch;\n} catch {\n}\nfunction useFetchImplementation2(fetchImplementation) {\n  _fetch2 = fetchImplementation;\n}\nasync function fetchRelayInformation(url) {\n  return await (await fetch(url.replace(\"ws://\", \"http://\").replace(\"wss://\", \"https://\"), {\n    headers: { Accept: \"application/nostr+json\" }\n  })).json();\n}\n\n// nip13.ts\nvar nip13_exports = {};\n__export(nip13_exports, {\n  fastEventHash: () => fastEventHash,\n  getPow: () => getPow,\n  minePow: () => minePow\n});\n\n\nfunction getPow(hex) {\n  let count = 0;\n  for (let i2 = 0; i2 < 64; i2 += 8) {\n    const nibble = parseInt(hex.substring(i2, i2 + 8), 16);\n    if (nibble === 0) {\n      count += 32;\n    } else {\n      count += Math.clz32(nibble);\n      break;\n    }\n  }\n  return count;\n}\nfunction minePow(unsigned, difficulty) {\n  let count = 0;\n  const event = unsigned;\n  const tag = [\"nonce\", count.toString(), difficulty.toString()];\n  event.tags.push(tag);\n  while (true) {\n    const now2 = Math.floor(new Date().getTime() / 1e3);\n    if (now2 !== event.created_at) {\n      count = 0;\n      event.created_at = now2;\n    }\n    tag[1] = (++count).toString();\n    event.id = fastEventHash(event);\n    if (getPow(event.id) >= difficulty) {\n      break;\n    }\n  }\n  return event;\n}\nfunction fastEventHash(evt) {\n  return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(\n    (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_1__.sha256)(utf8Encoder.encode(JSON.stringify([0, evt.pubkey, evt.created_at, evt.kind, evt.tags, evt.content])))\n  );\n}\n\n// nip18.ts\nvar nip18_exports = {};\n__export(nip18_exports, {\n  finishRepostEvent: () => finishRepostEvent,\n  getRepostedEvent: () => getRepostedEvent,\n  getRepostedEventPointer: () => getRepostedEventPointer\n});\nfunction finishRepostEvent(t, reposted, relayUrl, privateKey) {\n  return finalizeEvent(\n    {\n      kind: Repost,\n      tags: [...t.tags ?? [], [\"e\", reposted.id, relayUrl], [\"p\", reposted.pubkey]],\n      content: t.content === \"\" ? \"\" : JSON.stringify(reposted),\n      created_at: t.created_at\n    },\n    privateKey\n  );\n}\nfunction getRepostedEventPointer(event) {\n  if (event.kind !== Repost) {\n    return void 0;\n  }\n  let lastETag;\n  let lastPTag;\n  for (let i2 = event.tags.length - 1; i2 >= 0 && (lastETag === void 0 || lastPTag === void 0); i2--) {\n    const tag = event.tags[i2];\n    if (tag.length >= 2) {\n      if (tag[0] === \"e\" && lastETag === void 0) {\n        lastETag = tag;\n      } else if (tag[0] === \"p\" && lastPTag === void 0) {\n        lastPTag = tag;\n      }\n    }\n  }\n  if (lastETag === void 0) {\n    return void 0;\n  }\n  return {\n    id: lastETag[1],\n    relays: [lastETag[2], lastPTag?.[2]].filter((x) => typeof x === \"string\"),\n    author: lastPTag?.[1]\n  };\n}\nfunction getRepostedEvent(event, { skipVerification } = {}) {\n  const pointer = getRepostedEventPointer(event);\n  if (pointer === void 0 || event.content === \"\") {\n    return void 0;\n  }\n  let repostedEvent;\n  try {\n    repostedEvent = JSON.parse(event.content);\n  } catch (error) {\n    return void 0;\n  }\n  if (repostedEvent.id !== pointer.id) {\n    return void 0;\n  }\n  if (!skipVerification && !verifyEvent(repostedEvent)) {\n    return void 0;\n  }\n  return repostedEvent;\n}\n\n// nip21.ts\nvar nip21_exports = {};\n__export(nip21_exports, {\n  NOSTR_URI_REGEX: () => NOSTR_URI_REGEX,\n  parse: () => parse2,\n  test: () => test\n});\nvar NOSTR_URI_REGEX = new RegExp(`nostr:(${BECH32_REGEX.source})`);\nfunction test(value) {\n  return typeof value === \"string\" && new RegExp(`^${NOSTR_URI_REGEX.source}$`).test(value);\n}\nfunction parse2(uri) {\n  const match = uri.match(new RegExp(`^${NOSTR_URI_REGEX.source}$`));\n  if (!match)\n    throw new Error(`Invalid Nostr URI: ${uri}`);\n  return {\n    uri: match[0],\n    value: match[1],\n    decoded: decode(match[1])\n  };\n}\n\n// nip25.ts\nvar nip25_exports = {};\n__export(nip25_exports, {\n  finishReactionEvent: () => finishReactionEvent,\n  getReactedEventPointer: () => getReactedEventPointer\n});\nfunction finishReactionEvent(t, reacted, privateKey) {\n  const inheritedTags = reacted.tags.filter((tag) => tag.length >= 2 && (tag[0] === \"e\" || tag[0] === \"p\"));\n  return finalizeEvent(\n    {\n      ...t,\n      kind: Reaction,\n      tags: [...t.tags ?? [], ...inheritedTags, [\"e\", reacted.id], [\"p\", reacted.pubkey]],\n      content: t.content ?? \"+\"\n    },\n    privateKey\n  );\n}\nfunction getReactedEventPointer(event) {\n  if (event.kind !== Reaction) {\n    return void 0;\n  }\n  let lastETag;\n  let lastPTag;\n  for (let i2 = event.tags.length - 1; i2 >= 0 && (lastETag === void 0 || lastPTag === void 0); i2--) {\n    const tag = event.tags[i2];\n    if (tag.length >= 2) {\n      if (tag[0] === \"e\" && lastETag === void 0) {\n        lastETag = tag;\n      } else if (tag[0] === \"p\" && lastPTag === void 0) {\n        lastPTag = tag;\n      }\n    }\n  }\n  if (lastETag === void 0 || lastPTag === void 0) {\n    return void 0;\n  }\n  return {\n    id: lastETag[1],\n    relays: [lastETag[2], lastPTag[2]].filter((x) => x !== void 0),\n    author: lastPTag[1]\n  };\n}\n\n// nip27.ts\nvar nip27_exports = {};\n__export(nip27_exports, {\n  matchAll: () => matchAll,\n  regex: () => regex,\n  replaceAll: () => replaceAll\n});\nvar regex = () => new RegExp(`\\\\b${NOSTR_URI_REGEX.source}\\\\b`, \"g\");\nfunction* matchAll(content) {\n  const matches = content.matchAll(regex());\n  for (const match of matches) {\n    try {\n      const [uri, value] = match;\n      yield {\n        uri,\n        value,\n        decoded: decode(value),\n        start: match.index,\n        end: match.index + uri.length\n      };\n    } catch (_e) {\n    }\n  }\n}\nfunction replaceAll(content, replacer) {\n  return content.replaceAll(regex(), (uri, value) => {\n    return replacer({\n      uri,\n      value,\n      decoded: decode(value)\n    });\n  });\n}\n\n// nip28.ts\nvar nip28_exports = {};\n__export(nip28_exports, {\n  channelCreateEvent: () => channelCreateEvent,\n  channelHideMessageEvent: () => channelHideMessageEvent,\n  channelMessageEvent: () => channelMessageEvent,\n  channelMetadataEvent: () => channelMetadataEvent,\n  channelMuteUserEvent: () => channelMuteUserEvent\n});\nvar channelCreateEvent = (t, privateKey) => {\n  let content;\n  if (typeof t.content === \"object\") {\n    content = JSON.stringify(t.content);\n  } else if (typeof t.content === \"string\") {\n    content = t.content;\n  } else {\n    return void 0;\n  }\n  return finalizeEvent(\n    {\n      kind: ChannelCreation,\n      tags: [...t.tags ?? []],\n      content,\n      created_at: t.created_at\n    },\n    privateKey\n  );\n};\nvar channelMetadataEvent = (t, privateKey) => {\n  let content;\n  if (typeof t.content === \"object\") {\n    content = JSON.stringify(t.content);\n  } else if (typeof t.content === \"string\") {\n    content = t.content;\n  } else {\n    return void 0;\n  }\n  return finalizeEvent(\n    {\n      kind: ChannelMetadata,\n      tags: [[\"e\", t.channel_create_event_id], ...t.tags ?? []],\n      content,\n      created_at: t.created_at\n    },\n    privateKey\n  );\n};\nvar channelMessageEvent = (t, privateKey) => {\n  const tags = [[\"e\", t.channel_create_event_id, t.relay_url, \"root\"]];\n  if (t.reply_to_channel_message_event_id) {\n    tags.push([\"e\", t.reply_to_channel_message_event_id, t.relay_url, \"reply\"]);\n  }\n  return finalizeEvent(\n    {\n      kind: ChannelMessage,\n      tags: [...tags, ...t.tags ?? []],\n      content: t.content,\n      created_at: t.created_at\n    },\n    privateKey\n  );\n};\nvar channelHideMessageEvent = (t, privateKey) => {\n  let content;\n  if (typeof t.content === \"object\") {\n    content = JSON.stringify(t.content);\n  } else if (typeof t.content === \"string\") {\n    content = t.content;\n  } else {\n    return void 0;\n  }\n  return finalizeEvent(\n    {\n      kind: ChannelHideMessage,\n      tags: [[\"e\", t.channel_message_event_id], ...t.tags ?? []],\n      content,\n      created_at: t.created_at\n    },\n    privateKey\n  );\n};\nvar channelMuteUserEvent = (t, privateKey) => {\n  let content;\n  if (typeof t.content === \"object\") {\n    content = JSON.stringify(t.content);\n  } else if (typeof t.content === \"string\") {\n    content = t.content;\n  } else {\n    return void 0;\n  }\n  return finalizeEvent(\n    {\n      kind: ChannelMuteUser,\n      tags: [[\"p\", t.pubkey_to_mute], ...t.tags ?? []],\n      content,\n      created_at: t.created_at\n    },\n    privateKey\n  );\n};\n\n// nip30.ts\nvar nip30_exports = {};\n__export(nip30_exports, {\n  EMOJI_SHORTCODE_REGEX: () => EMOJI_SHORTCODE_REGEX,\n  matchAll: () => matchAll2,\n  regex: () => regex2,\n  replaceAll: () => replaceAll2\n});\nvar EMOJI_SHORTCODE_REGEX = /:(\\w+):/;\nvar regex2 = () => new RegExp(`\\\\B${EMOJI_SHORTCODE_REGEX.source}\\\\B`, \"g\");\nfunction* matchAll2(content) {\n  const matches = content.matchAll(regex2());\n  for (const match of matches) {\n    try {\n      const [shortcode, name] = match;\n      yield {\n        shortcode,\n        name,\n        start: match.index,\n        end: match.index + shortcode.length\n      };\n    } catch (_e) {\n    }\n  }\n}\nfunction replaceAll2(content, replacer) {\n  return content.replaceAll(regex2(), (shortcode, name) => {\n    return replacer({\n      shortcode,\n      name\n    });\n  });\n}\n\n// nip39.ts\nvar nip39_exports = {};\n__export(nip39_exports, {\n  useFetchImplementation: () => useFetchImplementation3,\n  validateGithub: () => validateGithub\n});\nvar _fetch3;\ntry {\n  _fetch3 = fetch;\n} catch {\n}\nfunction useFetchImplementation3(fetchImplementation) {\n  _fetch3 = fetchImplementation;\n}\nasync function validateGithub(pubkey, username, proof) {\n  try {\n    let res = await (await _fetch3(`https://gist.github.com/${username}/${proof}/raw`)).text();\n    return res === `Verifying that I control the following Nostr public key: ${pubkey}`;\n  } catch (_) {\n    return false;\n  }\n}\n\n// nip44.ts\nvar nip44_exports = {};\n__export(nip44_exports, {\n  decrypt: () => decrypt2,\n  encrypt: () => encrypt2,\n  getConversationKey: () => getConversationKey,\n  v2: () => v2\n});\n\n\n\n\n\n\n\n\nvar minPlaintextSize = 1;\nvar maxPlaintextSize = 65535;\nfunction getConversationKey(privkeyA, pubkeyB) {\n  const sharedX = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.getSharedSecret(privkeyA, \"02\" + pubkeyB).subarray(1, 33);\n  return (0,_noble_hashes_hkdf__WEBPACK_IMPORTED_MODULE_5__.extract)(_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_1__.sha256, sharedX, \"nip44-v2\");\n}\nfunction getMessageKeys(conversationKey, nonce) {\n  const keys = (0,_noble_hashes_hkdf__WEBPACK_IMPORTED_MODULE_5__.expand)(_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_1__.sha256, conversationKey, nonce, 76);\n  return {\n    chacha_key: keys.subarray(0, 32),\n    chacha_nonce: keys.subarray(32, 44),\n    hmac_key: keys.subarray(44, 76)\n  };\n}\nfunction calcPaddedLen(len) {\n  if (!Number.isSafeInteger(len) || len < 1)\n    throw new Error(\"expected positive integer\");\n  if (len <= 32)\n    return 32;\n  const nextPower = 1 << Math.floor(Math.log2(len - 1)) + 1;\n  const chunk = nextPower <= 256 ? 32 : nextPower / 8;\n  return chunk * (Math.floor((len - 1) / chunk) + 1);\n}\nfunction writeU16BE(num) {\n  if (!Number.isSafeInteger(num) || num < minPlaintextSize || num > maxPlaintextSize)\n    throw new Error(\"invalid plaintext size: must be between 1 and 65535 bytes\");\n  const arr = new Uint8Array(2);\n  new DataView(arr.buffer).setUint16(0, num, false);\n  return arr;\n}\nfunction pad(plaintext) {\n  const unpadded = utf8Encoder.encode(plaintext);\n  const unpaddedLen = unpadded.length;\n  const prefix = writeU16BE(unpaddedLen);\n  const suffix = new Uint8Array(calcPaddedLen(unpaddedLen) - unpaddedLen);\n  return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(prefix, unpadded, suffix);\n}\nfunction unpad(padded) {\n  const unpaddedLen = new DataView(padded.buffer).getUint16(0);\n  const unpadded = padded.subarray(2, 2 + unpaddedLen);\n  if (unpaddedLen < minPlaintextSize || unpaddedLen > maxPlaintextSize || unpadded.length !== unpaddedLen || padded.length !== 2 + calcPaddedLen(unpaddedLen))\n    throw new Error(\"invalid padding\");\n  return utf8Decoder.decode(unpadded);\n}\nfunction hmacAad(key, message, aad) {\n  if (aad.length !== 32)\n    throw new Error(\"AAD associated data must be 32 bytes\");\n  const combined = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(aad, message);\n  return (0,_noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_6__.hmac)(_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_1__.sha256, key, combined);\n}\nfunction decodePayload(payload) {\n  if (typeof payload !== \"string\")\n    throw new Error(\"payload must be a valid string\");\n  const plen = payload.length;\n  if (plen < 132 || plen > 87472)\n    throw new Error(\"invalid payload length: \" + plen);\n  if (payload[0] === \"#\")\n    throw new Error(\"unknown encryption version\");\n  let data;\n  try {\n    data = _scure_base__WEBPACK_IMPORTED_MODULE_3__.base64.decode(payload);\n  } catch (error) {\n    throw new Error(\"invalid base64: \" + error.message);\n  }\n  const dlen = data.length;\n  if (dlen < 99 || dlen > 65603)\n    throw new Error(\"invalid data length: \" + dlen);\n  const vers = data[0];\n  if (vers !== 2)\n    throw new Error(\"unknown encryption version \" + vers);\n  return {\n    nonce: data.subarray(1, 33),\n    ciphertext: data.subarray(33, -32),\n    mac: data.subarray(-32)\n  };\n}\nfunction encrypt2(plaintext, conversationKey, nonce = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.randomBytes)(32)) {\n  const { chacha_key, chacha_nonce, hmac_key } = getMessageKeys(conversationKey, nonce);\n  const padded = pad(plaintext);\n  const ciphertext = (0,_noble_ciphers_chacha__WEBPACK_IMPORTED_MODULE_7__.chacha20)(chacha_key, chacha_nonce, padded);\n  const mac = hmacAad(hmac_key, ciphertext, nonce);\n  return _scure_base__WEBPACK_IMPORTED_MODULE_3__.base64.encode((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(new Uint8Array([2]), nonce, ciphertext, mac));\n}\nfunction decrypt2(payload, conversationKey) {\n  const { nonce, ciphertext, mac } = decodePayload(payload);\n  const { chacha_key, chacha_nonce, hmac_key } = getMessageKeys(conversationKey, nonce);\n  const calculatedMac = hmacAad(hmac_key, ciphertext, nonce);\n  if (!(0,_noble_ciphers_utils__WEBPACK_IMPORTED_MODULE_8__.equalBytes)(calculatedMac, mac))\n    throw new Error(\"invalid MAC\");\n  const padded = (0,_noble_ciphers_chacha__WEBPACK_IMPORTED_MODULE_7__.chacha20)(chacha_key, chacha_nonce, ciphertext);\n  return unpad(padded);\n}\nvar v2 = {\n  utils: {\n    getConversationKey,\n    calcPaddedLen\n  },\n  encrypt: encrypt2,\n  decrypt: decrypt2\n};\n\n// nip47.ts\nvar nip47_exports = {};\n__export(nip47_exports, {\n  makeNwcRequestEvent: () => makeNwcRequestEvent,\n  parseConnectionString: () => parseConnectionString\n});\nfunction parseConnectionString(connectionString) {\n  const { pathname, searchParams } = new URL(connectionString);\n  const pubkey = pathname;\n  const relay = searchParams.get(\"relay\");\n  const secret = searchParams.get(\"secret\");\n  if (!pubkey || !relay || !secret) {\n    throw new Error(\"invalid connection string\");\n  }\n  return { pubkey, relay, secret };\n}\nasync function makeNwcRequestEvent(pubkey, secretKey, invoice) {\n  const content = {\n    method: \"pay_invoice\",\n    params: {\n      invoice\n    }\n  };\n  const encryptedContent = await encrypt(secretKey, pubkey, JSON.stringify(content));\n  const eventTemplate = {\n    kind: NWCWalletRequest,\n    created_at: Math.round(Date.now() / 1e3),\n    content: encryptedContent,\n    tags: [[\"p\", pubkey]]\n  };\n  return finalizeEvent(eventTemplate, secretKey);\n}\n\n// nip57.ts\nvar nip57_exports = {};\n__export(nip57_exports, {\n  getZapEndpoint: () => getZapEndpoint,\n  makeZapReceipt: () => makeZapReceipt,\n  makeZapRequest: () => makeZapRequest,\n  useFetchImplementation: () => useFetchImplementation4,\n  validateZapRequest: () => validateZapRequest\n});\n\nvar _fetch4;\ntry {\n  _fetch4 = fetch;\n} catch {\n}\nfunction useFetchImplementation4(fetchImplementation) {\n  _fetch4 = fetchImplementation;\n}\nasync function getZapEndpoint(metadata) {\n  try {\n    let lnurl = \"\";\n    let { lud06, lud16 } = JSON.parse(metadata.content);\n    if (lud06) {\n      let { words } = _scure_base__WEBPACK_IMPORTED_MODULE_3__.bech32.decode(lud06, 1e3);\n      let data = _scure_base__WEBPACK_IMPORTED_MODULE_3__.bech32.fromWords(words);\n      lnurl = utf8Decoder.decode(data);\n    } else if (lud16) {\n      let [name, domain] = lud16.split(\"@\");\n      lnurl = new URL(`/.well-known/lnurlp/${name}`, `https://${domain}`).toString();\n    } else {\n      return null;\n    }\n    let res = await _fetch4(lnurl);\n    let body = await res.json();\n    if (body.allowsNostr && body.nostrPubkey) {\n      return body.callback;\n    }\n  } catch (err) {\n  }\n  return null;\n}\nfunction makeZapRequest({\n  profile,\n  event,\n  amount,\n  relays,\n  comment = \"\"\n}) {\n  if (!amount)\n    throw new Error(\"amount not given\");\n  if (!profile)\n    throw new Error(\"profile not given\");\n  let zr = {\n    kind: 9734,\n    created_at: Math.round(Date.now() / 1e3),\n    content: comment,\n    tags: [\n      [\"p\", profile],\n      [\"amount\", amount.toString()],\n      [\"relays\", ...relays]\n    ]\n  };\n  if (event) {\n    zr.tags.push([\"e\", event]);\n  }\n  return zr;\n}\nfunction validateZapRequest(zapRequestString) {\n  let zapRequest;\n  try {\n    zapRequest = JSON.parse(zapRequestString);\n  } catch (err) {\n    return \"Invalid zap request JSON.\";\n  }\n  if (!validateEvent(zapRequest))\n    return \"Zap request is not a valid Nostr event.\";\n  if (!verifyEvent(zapRequest))\n    return \"Invalid signature on zap request.\";\n  let p = zapRequest.tags.find(([t, v]) => t === \"p\" && v);\n  if (!p)\n    return \"Zap request doesn't have a 'p' tag.\";\n  if (!p[1].match(/^[a-f0-9]{64}$/))\n    return \"Zap request 'p' tag is not valid hex.\";\n  let e = zapRequest.tags.find(([t, v]) => t === \"e\" && v);\n  if (e && !e[1].match(/^[a-f0-9]{64}$/))\n    return \"Zap request 'e' tag is not valid hex.\";\n  let relays = zapRequest.tags.find(([t, v]) => t === \"relays\" && v);\n  if (!relays)\n    return \"Zap request doesn't have a 'relays' tag.\";\n  return null;\n}\nfunction makeZapReceipt({\n  zapRequest,\n  preimage,\n  bolt11,\n  paidAt\n}) {\n  let zr = JSON.parse(zapRequest);\n  let tagsFromZapRequest = zr.tags.filter(([t]) => t === \"e\" || t === \"p\" || t === \"a\");\n  let zap = {\n    kind: 9735,\n    created_at: Math.round(paidAt.getTime() / 1e3),\n    content: \"\",\n    tags: [...tagsFromZapRequest, [\"P\", zr.pubkey], [\"bolt11\", bolt11], [\"description\", zapRequest]]\n  };\n  if (preimage) {\n    zap.tags.push([\"preimage\", preimage]);\n  }\n  return zap;\n}\n\n// nip59.ts\nvar nip59_exports = {};\n__export(nip59_exports, {\n  createRumor: () => createRumor,\n  createSeal: () => createSeal,\n  createWrap: () => createWrap,\n  unwrapEvent: () => unwrapEvent,\n  unwrapManyEvents: () => unwrapManyEvents,\n  wrapEvent: () => wrapEvent,\n  wrapManyEvents: () => wrapManyEvents\n});\nvar TWO_DAYS = 2 * 24 * 60 * 60;\nvar now = () => Math.round(Date.now() / 1e3);\nvar randomNow = () => Math.round(now() - Math.random() * TWO_DAYS);\nvar nip44ConversationKey = (privateKey, publicKey) => getConversationKey(privateKey, publicKey);\nvar nip44Encrypt = (data, privateKey, publicKey) => encrypt2(JSON.stringify(data), nip44ConversationKey(privateKey, publicKey));\nvar nip44Decrypt = (data, privateKey) => JSON.parse(decrypt2(data.content, nip44ConversationKey(privateKey, data.pubkey)));\nfunction createRumor(event, privateKey) {\n  const rumor = {\n    created_at: now(),\n    content: \"\",\n    tags: [],\n    ...event,\n    pubkey: getPublicKey(privateKey)\n  };\n  rumor.id = getEventHash(rumor);\n  return rumor;\n}\nfunction createSeal(rumor, privateKey, recipientPublicKey) {\n  return finalizeEvent(\n    {\n      kind: Seal,\n      content: nip44Encrypt(rumor, privateKey, recipientPublicKey),\n      created_at: randomNow(),\n      tags: []\n    },\n    privateKey\n  );\n}\nfunction createWrap(seal, recipientPublicKey) {\n  const randomKey = generateSecretKey();\n  return finalizeEvent(\n    {\n      kind: GiftWrap,\n      content: nip44Encrypt(seal, randomKey, recipientPublicKey),\n      created_at: randomNow(),\n      tags: [[\"p\", recipientPublicKey]]\n    },\n    randomKey\n  );\n}\nfunction wrapEvent(event, senderPrivateKey, recipientPublicKey) {\n  const rumor = createRumor(event, senderPrivateKey);\n  const seal = createSeal(rumor, senderPrivateKey, recipientPublicKey);\n  return createWrap(seal, recipientPublicKey);\n}\nfunction wrapManyEvents(event, senderPrivateKey, recipientsPublicKeys) {\n  if (!recipientsPublicKeys || recipientsPublicKeys.length === 0) {\n    throw new Error(\"At least one recipient is required.\");\n  }\n  const senderPublicKey = getPublicKey(senderPrivateKey);\n  const wrappeds = [wrapEvent(event, senderPrivateKey, senderPublicKey)];\n  recipientsPublicKeys.forEach((recipientPublicKey) => {\n    wrappeds.push(wrapEvent(event, senderPrivateKey, recipientPublicKey));\n  });\n  return wrappeds;\n}\nfunction unwrapEvent(wrap, recipientPrivateKey) {\n  const unwrappedSeal = nip44Decrypt(wrap, recipientPrivateKey);\n  return nip44Decrypt(unwrappedSeal, recipientPrivateKey);\n}\nfunction unwrapManyEvents(wrappedEvents, recipientPrivateKey) {\n  let unwrappedEvents = [];\n  wrappedEvents.forEach((e) => {\n    unwrappedEvents.push(unwrapEvent(e, recipientPrivateKey));\n  });\n  unwrappedEvents.sort((a, b) => a.created_at - b.created_at);\n  return unwrappedEvents;\n}\n\n// nip98.ts\nvar nip98_exports = {};\n__export(nip98_exports, {\n  getToken: () => getToken,\n  hashPayload: () => hashPayload,\n  unpackEventFromToken: () => unpackEventFromToken,\n  validateEvent: () => validateEvent2,\n  validateEventKind: () => validateEventKind,\n  validateEventMethodTag: () => validateEventMethodTag,\n  validateEventPayloadTag: () => validateEventPayloadTag,\n  validateEventTimestamp: () => validateEventTimestamp,\n  validateEventUrlTag: () => validateEventUrlTag,\n  validateToken: () => validateToken\n});\n\n\n\nvar _authorizationScheme = \"Nostr \";\nasync function getToken(loginUrl, httpMethod, sign, includeAuthorizationScheme = false, payload) {\n  const event = {\n    kind: HTTPAuth,\n    tags: [\n      [\"u\", loginUrl],\n      [\"method\", httpMethod]\n    ],\n    created_at: Math.round(new Date().getTime() / 1e3),\n    content: \"\"\n  };\n  if (payload) {\n    event.tags.push([\"payload\", hashPayload(payload)]);\n  }\n  const signedEvent = await sign(event);\n  const authorizationScheme = includeAuthorizationScheme ? _authorizationScheme : \"\";\n  return authorizationScheme + _scure_base__WEBPACK_IMPORTED_MODULE_3__.base64.encode(utf8Encoder.encode(JSON.stringify(signedEvent)));\n}\nasync function validateToken(token, url, method) {\n  const event = await unpackEventFromToken(token).catch((error) => {\n    throw error;\n  });\n  const valid = await validateEvent2(event, url, method).catch((error) => {\n    throw error;\n  });\n  return valid;\n}\nasync function unpackEventFromToken(token) {\n  if (!token) {\n    throw new Error(\"Missing token\");\n  }\n  token = token.replace(_authorizationScheme, \"\");\n  const eventB64 = utf8Decoder.decode(_scure_base__WEBPACK_IMPORTED_MODULE_3__.base64.decode(token));\n  if (!eventB64 || eventB64.length === 0 || !eventB64.startsWith(\"{\")) {\n    throw new Error(\"Invalid token\");\n  }\n  const event = JSON.parse(eventB64);\n  return event;\n}\nfunction validateEventTimestamp(event) {\n  if (!event.created_at) {\n    return false;\n  }\n  return Math.round(new Date().getTime() / 1e3) - event.created_at < 60;\n}\nfunction validateEventKind(event) {\n  return event.kind === HTTPAuth;\n}\nfunction validateEventUrlTag(event, url) {\n  const urlTag = event.tags.find((t) => t[0] === \"u\");\n  if (!urlTag) {\n    return false;\n  }\n  return urlTag.length > 0 && urlTag[1] === url;\n}\nfunction validateEventMethodTag(event, method) {\n  const methodTag = event.tags.find((t) => t[0] === \"method\");\n  if (!methodTag) {\n    return false;\n  }\n  return methodTag.length > 0 && methodTag[1].toLowerCase() === method.toLowerCase();\n}\nfunction hashPayload(payload) {\n  const hash = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_1__.sha256)(utf8Encoder.encode(JSON.stringify(payload)));\n  return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(hash);\n}\nfunction validateEventPayloadTag(event, payload) {\n  const payloadTag = event.tags.find((t) => t[0] === \"payload\");\n  if (!payloadTag) {\n    return false;\n  }\n  const payloadHash = hashPayload(payload);\n  return payloadTag.length > 0 && payloadTag[1] === payloadHash;\n}\nasync function validateEvent2(event, url, method, body) {\n  if (!verifyEvent(event)) {\n    throw new Error(\"Invalid nostr event, signature invalid\");\n  }\n  if (!validateEventKind(event)) {\n    throw new Error(\"Invalid nostr event, kind invalid\");\n  }\n  if (!validateEventTimestamp(event)) {\n    throw new Error(\"Invalid nostr event, created_at timestamp invalid\");\n  }\n  if (!validateEventUrlTag(event, url)) {\n    throw new Error(\"Invalid nostr event, url tag invalid\");\n  }\n  if (!validateEventMethodTag(event, method)) {\n    throw new Error(\"Invalid nostr event, method tag invalid\");\n  }\n  if (Boolean(body) && typeof body === \"object\" && Object.keys(body).length > 0) {\n    if (!validateEventPayloadTag(event, body)) {\n      throw new Error(\"Invalid nostr event, payload tag does not match request body hash\");\n    }\n  }\n  return true;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9saWIvZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTs7QUFFQTtBQUNrRDtBQUNEOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLEdBQUc7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHdCQUF3QjtBQUMzQztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUM4Qzs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyw0REFBTztBQUNsQjtBQUNBO0FBQ0EsV0FBVywrREFBVSxDQUFDLDREQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwrREFBVSxDQUFDLDREQUFPO0FBQ3JDO0FBQ0EsZ0JBQWdCLCtEQUFVLENBQUMsNERBQU87QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDREQUFPO0FBQzNCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw0REFBTTtBQUN4QixTQUFTLCtEQUFVO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixRQUFRO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLDZCQUE2QixNQUFNO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsTUFBTTtBQUNuQztBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFNBQVMsSUFBSSxJQUFJO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxpQkFBaUI7QUFDN0QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsaUJBQWlCO0FBQy9ELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsaUJBQWlCO0FBQ3hELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsUUFBUSxhQUFhLGVBQWU7QUFDaEc7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtEQUFrRDtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDd0Q7QUFDTztBQUNoQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwrQ0FBTztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLCtDQUFPO0FBQzdDLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw0REFBTztBQUN0QixTQUFTLCtEQUFXO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF3Q0UiLCJzb3VyY2VzIjpbIi9ob21lL2xmZy9HaXQvTWFkdHJpcHMvbm9kZV9tb2R1bGVzL0Bub3N0ci1kZXYta2l0L25kay9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbGliL2VzbS9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xuXG4vLyBwdXJlLnRzXG5pbXBvcnQgeyBzY2hub3JyIH0gZnJvbSBcIkBub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxXCI7XG5pbXBvcnQgeyBieXRlc1RvSGV4IH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvdXRpbHNcIjtcblxuLy8gY29yZS50c1xudmFyIHZlcmlmaWVkU3ltYm9sID0gU3ltYm9sKFwidmVyaWZpZWRcIik7XG52YXIgaXNSZWNvcmQgPSAob2JqKSA9PiBvYmogaW5zdGFuY2VvZiBPYmplY3Q7XG5mdW5jdGlvbiB2YWxpZGF0ZUV2ZW50KGV2ZW50KSB7XG4gIGlmICghaXNSZWNvcmQoZXZlbnQpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiBldmVudC5raW5kICE9PSBcIm51bWJlclwiKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiBldmVudC5jb250ZW50ICE9PSBcInN0cmluZ1wiKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiBldmVudC5jcmVhdGVkX2F0ICE9PSBcIm51bWJlclwiKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiBldmVudC5wdWJrZXkgIT09IFwic3RyaW5nXCIpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoIWV2ZW50LnB1YmtleS5tYXRjaCgvXlthLWYwLTldezY0fSQvKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmICghQXJyYXkuaXNBcnJheShldmVudC50YWdzKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGZvciAobGV0IGkyID0gMDsgaTIgPCBldmVudC50YWdzLmxlbmd0aDsgaTIrKykge1xuICAgIGxldCB0YWcgPSBldmVudC50YWdzW2kyXTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodGFnKSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRhZy5sZW5ndGg7IGorKykge1xuICAgICAgaWYgKHR5cGVvZiB0YWdbal0gPT09IFwib2JqZWN0XCIpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBzb3J0RXZlbnRzKGV2ZW50cykge1xuICByZXR1cm4gZXZlbnRzLnNvcnQoKGEsIGIpID0+IHtcbiAgICBpZiAoYS5jcmVhdGVkX2F0ICE9PSBiLmNyZWF0ZWRfYXQpIHtcbiAgICAgIHJldHVybiBiLmNyZWF0ZWRfYXQgLSBhLmNyZWF0ZWRfYXQ7XG4gICAgfVxuICAgIHJldHVybiBhLmlkLmxvY2FsZUNvbXBhcmUoYi5pZCk7XG4gIH0pO1xufVxuXG4vLyBwdXJlLnRzXG5pbXBvcnQgeyBzaGEyNTYgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy9zaGEyNTZcIjtcblxuLy8gdXRpbHMudHNcbnZhciB1dGlsc19leHBvcnRzID0ge307XG5fX2V4cG9ydCh1dGlsc19leHBvcnRzLCB7XG4gIFF1ZXVlOiAoKSA9PiBRdWV1ZSxcbiAgUXVldWVOb2RlOiAoKSA9PiBRdWV1ZU5vZGUsXG4gIGJpbmFyeVNlYXJjaDogKCkgPT4gYmluYXJ5U2VhcmNoLFxuICBpbnNlcnRFdmVudEludG9Bc2NlbmRpbmdMaXN0OiAoKSA9PiBpbnNlcnRFdmVudEludG9Bc2NlbmRpbmdMaXN0LFxuICBpbnNlcnRFdmVudEludG9EZXNjZW5kaW5nTGlzdDogKCkgPT4gaW5zZXJ0RXZlbnRJbnRvRGVzY2VuZGluZ0xpc3QsXG4gIG5vcm1hbGl6ZVVSTDogKCkgPT4gbm9ybWFsaXplVVJMLFxuICB1dGY4RGVjb2RlcjogKCkgPT4gdXRmOERlY29kZXIsXG4gIHV0ZjhFbmNvZGVyOiAoKSA9PiB1dGY4RW5jb2RlclxufSk7XG52YXIgdXRmOERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoXCJ1dGYtOFwiKTtcbnZhciB1dGY4RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuZnVuY3Rpb24gbm9ybWFsaXplVVJMKHVybCkge1xuICBpZiAodXJsLmluZGV4T2YoXCI6Ly9cIikgPT09IC0xKVxuICAgIHVybCA9IFwid3NzOi8vXCIgKyB1cmw7XG4gIGxldCBwID0gbmV3IFVSTCh1cmwpO1xuICBwLnBhdGhuYW1lID0gcC5wYXRobmFtZS5yZXBsYWNlKC9cXC8rL2csIFwiL1wiKTtcbiAgaWYgKHAucGF0aG5hbWUuZW5kc1dpdGgoXCIvXCIpKVxuICAgIHAucGF0aG5hbWUgPSBwLnBhdGhuYW1lLnNsaWNlKDAsIC0xKTtcbiAgaWYgKHAucG9ydCA9PT0gXCI4MFwiICYmIHAucHJvdG9jb2wgPT09IFwid3M6XCIgfHwgcC5wb3J0ID09PSBcIjQ0M1wiICYmIHAucHJvdG9jb2wgPT09IFwid3NzOlwiKVxuICAgIHAucG9ydCA9IFwiXCI7XG4gIHAuc2VhcmNoUGFyYW1zLnNvcnQoKTtcbiAgcC5oYXNoID0gXCJcIjtcbiAgcmV0dXJuIHAudG9TdHJpbmcoKTtcbn1cbmZ1bmN0aW9uIGluc2VydEV2ZW50SW50b0Rlc2NlbmRpbmdMaXN0KHNvcnRlZEFycmF5LCBldmVudCkge1xuICBjb25zdCBbaWR4LCBmb3VuZF0gPSBiaW5hcnlTZWFyY2goc29ydGVkQXJyYXksIChiKSA9PiB7XG4gICAgaWYgKGV2ZW50LmlkID09PSBiLmlkKVxuICAgICAgcmV0dXJuIDA7XG4gICAgaWYgKGV2ZW50LmNyZWF0ZWRfYXQgPT09IGIuY3JlYXRlZF9hdClcbiAgICAgIHJldHVybiAtMTtcbiAgICByZXR1cm4gYi5jcmVhdGVkX2F0IC0gZXZlbnQuY3JlYXRlZF9hdDtcbiAgfSk7XG4gIGlmICghZm91bmQpIHtcbiAgICBzb3J0ZWRBcnJheS5zcGxpY2UoaWR4LCAwLCBldmVudCk7XG4gIH1cbiAgcmV0dXJuIHNvcnRlZEFycmF5O1xufVxuZnVuY3Rpb24gaW5zZXJ0RXZlbnRJbnRvQXNjZW5kaW5nTGlzdChzb3J0ZWRBcnJheSwgZXZlbnQpIHtcbiAgY29uc3QgW2lkeCwgZm91bmRdID0gYmluYXJ5U2VhcmNoKHNvcnRlZEFycmF5LCAoYikgPT4ge1xuICAgIGlmIChldmVudC5pZCA9PT0gYi5pZClcbiAgICAgIHJldHVybiAwO1xuICAgIGlmIChldmVudC5jcmVhdGVkX2F0ID09PSBiLmNyZWF0ZWRfYXQpXG4gICAgICByZXR1cm4gLTE7XG4gICAgcmV0dXJuIGV2ZW50LmNyZWF0ZWRfYXQgLSBiLmNyZWF0ZWRfYXQ7XG4gIH0pO1xuICBpZiAoIWZvdW5kKSB7XG4gICAgc29ydGVkQXJyYXkuc3BsaWNlKGlkeCwgMCwgZXZlbnQpO1xuICB9XG4gIHJldHVybiBzb3J0ZWRBcnJheTtcbn1cbmZ1bmN0aW9uIGJpbmFyeVNlYXJjaChhcnIsIGNvbXBhcmUpIHtcbiAgbGV0IHN0YXJ0ID0gMDtcbiAgbGV0IGVuZCA9IGFyci5sZW5ndGggLSAxO1xuICB3aGlsZSAoc3RhcnQgPD0gZW5kKSB7XG4gICAgY29uc3QgbWlkID0gTWF0aC5mbG9vcigoc3RhcnQgKyBlbmQpIC8gMik7XG4gICAgY29uc3QgY21wID0gY29tcGFyZShhcnJbbWlkXSk7XG4gICAgaWYgKGNtcCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFttaWQsIHRydWVdO1xuICAgIH1cbiAgICBpZiAoY21wIDwgMCkge1xuICAgICAgZW5kID0gbWlkIC0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnQgPSBtaWQgKyAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gW3N0YXJ0LCBmYWxzZV07XG59XG52YXIgUXVldWVOb2RlID0gY2xhc3Mge1xuICB2YWx1ZTtcbiAgbmV4dCA9IG51bGw7XG4gIHByZXYgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgdGhpcy52YWx1ZSA9IG1lc3NhZ2U7XG4gIH1cbn07XG52YXIgUXVldWUgPSBjbGFzcyB7XG4gIGZpcnN0O1xuICBsYXN0O1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmZpcnN0ID0gbnVsbDtcbiAgICB0aGlzLmxhc3QgPSBudWxsO1xuICB9XG4gIGVucXVldWUodmFsdWUpIHtcbiAgICBjb25zdCBuZXdOb2RlID0gbmV3IFF1ZXVlTm9kZSh2YWx1ZSk7XG4gICAgaWYgKCF0aGlzLmxhc3QpIHtcbiAgICAgIHRoaXMuZmlyc3QgPSBuZXdOb2RlO1xuICAgICAgdGhpcy5sYXN0ID0gbmV3Tm9kZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubGFzdCA9PT0gdGhpcy5maXJzdCkge1xuICAgICAgdGhpcy5sYXN0ID0gbmV3Tm9kZTtcbiAgICAgIHRoaXMubGFzdC5wcmV2ID0gdGhpcy5maXJzdDtcbiAgICAgIHRoaXMuZmlyc3QubmV4dCA9IG5ld05vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld05vZGUucHJldiA9IHRoaXMubGFzdDtcbiAgICAgIHRoaXMubGFzdC5uZXh0ID0gbmV3Tm9kZTtcbiAgICAgIHRoaXMubGFzdCA9IG5ld05vZGU7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGRlcXVldWUoKSB7XG4gICAgaWYgKCF0aGlzLmZpcnN0KVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgaWYgKHRoaXMuZmlyc3QgPT09IHRoaXMubGFzdCkge1xuICAgICAgY29uc3QgdGFyZ2V0MiA9IHRoaXMuZmlyc3Q7XG4gICAgICB0aGlzLmZpcnN0ID0gbnVsbDtcbiAgICAgIHRoaXMubGFzdCA9IG51bGw7XG4gICAgICByZXR1cm4gdGFyZ2V0Mi52YWx1ZTtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5maXJzdDtcbiAgICB0aGlzLmZpcnN0ID0gdGFyZ2V0Lm5leHQ7XG4gICAgcmV0dXJuIHRhcmdldC52YWx1ZTtcbiAgfVxufTtcblxuLy8gcHVyZS50c1xudmFyIEpTID0gY2xhc3Mge1xuICBnZW5lcmF0ZVNlY3JldEtleSgpIHtcbiAgICByZXR1cm4gc2Nobm9yci51dGlscy5yYW5kb21Qcml2YXRlS2V5KCk7XG4gIH1cbiAgZ2V0UHVibGljS2V5KHNlY3JldEtleSkge1xuICAgIHJldHVybiBieXRlc1RvSGV4KHNjaG5vcnIuZ2V0UHVibGljS2V5KHNlY3JldEtleSkpO1xuICB9XG4gIGZpbmFsaXplRXZlbnQodCwgc2VjcmV0S2V5KSB7XG4gICAgY29uc3QgZXZlbnQgPSB0O1xuICAgIGV2ZW50LnB1YmtleSA9IGJ5dGVzVG9IZXgoc2Nobm9yci5nZXRQdWJsaWNLZXkoc2VjcmV0S2V5KSk7XG4gICAgZXZlbnQuaWQgPSBnZXRFdmVudEhhc2goZXZlbnQpO1xuICAgIGV2ZW50LnNpZyA9IGJ5dGVzVG9IZXgoc2Nobm9yci5zaWduKGdldEV2ZW50SGFzaChldmVudCksIHNlY3JldEtleSkpO1xuICAgIGV2ZW50W3ZlcmlmaWVkU3ltYm9sXSA9IHRydWU7XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9XG4gIHZlcmlmeUV2ZW50KGV2ZW50KSB7XG4gICAgaWYgKHR5cGVvZiBldmVudFt2ZXJpZmllZFN5bWJvbF0gPT09IFwiYm9vbGVhblwiKVxuICAgICAgcmV0dXJuIGV2ZW50W3ZlcmlmaWVkU3ltYm9sXTtcbiAgICBjb25zdCBoYXNoID0gZ2V0RXZlbnRIYXNoKGV2ZW50KTtcbiAgICBpZiAoaGFzaCAhPT0gZXZlbnQuaWQpIHtcbiAgICAgIGV2ZW50W3ZlcmlmaWVkU3ltYm9sXSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgdmFsaWQgPSBzY2hub3JyLnZlcmlmeShldmVudC5zaWcsIGhhc2gsIGV2ZW50LnB1YmtleSk7XG4gICAgICBldmVudFt2ZXJpZmllZFN5bWJvbF0gPSB2YWxpZDtcbiAgICAgIHJldHVybiB2YWxpZDtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGV2ZW50W3ZlcmlmaWVkU3ltYm9sXSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufTtcbmZ1bmN0aW9uIHNlcmlhbGl6ZUV2ZW50KGV2dCkge1xuICBpZiAoIXZhbGlkYXRlRXZlbnQoZXZ0KSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW4ndCBzZXJpYWxpemUgZXZlbnQgd2l0aCB3cm9uZyBvciBtaXNzaW5nIHByb3BlcnRpZXNcIik7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShbMCwgZXZ0LnB1YmtleSwgZXZ0LmNyZWF0ZWRfYXQsIGV2dC5raW5kLCBldnQudGFncywgZXZ0LmNvbnRlbnRdKTtcbn1cbmZ1bmN0aW9uIGdldEV2ZW50SGFzaChldmVudCkge1xuICBsZXQgZXZlbnRIYXNoID0gc2hhMjU2KHV0ZjhFbmNvZGVyLmVuY29kZShzZXJpYWxpemVFdmVudChldmVudCkpKTtcbiAgcmV0dXJuIGJ5dGVzVG9IZXgoZXZlbnRIYXNoKTtcbn1cbnZhciBpID0gbmV3IEpTKCk7XG52YXIgZ2VuZXJhdGVTZWNyZXRLZXkgPSBpLmdlbmVyYXRlU2VjcmV0S2V5O1xudmFyIGdldFB1YmxpY0tleSA9IGkuZ2V0UHVibGljS2V5O1xudmFyIGZpbmFsaXplRXZlbnQgPSBpLmZpbmFsaXplRXZlbnQ7XG52YXIgdmVyaWZ5RXZlbnQgPSBpLnZlcmlmeUV2ZW50O1xuXG4vLyBraW5kcy50c1xudmFyIGtpbmRzX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGtpbmRzX2V4cG9ydHMsIHtcbiAgQXBwbGljYXRpb246ICgpID0+IEFwcGxpY2F0aW9uLFxuICBCYWRnZUF3YXJkOiAoKSA9PiBCYWRnZUF3YXJkLFxuICBCYWRnZURlZmluaXRpb246ICgpID0+IEJhZGdlRGVmaW5pdGlvbixcbiAgQmxvY2tlZFJlbGF5c0xpc3Q6ICgpID0+IEJsb2NrZWRSZWxheXNMaXN0LFxuICBCb29rbWFya0xpc3Q6ICgpID0+IEJvb2ttYXJrTGlzdCxcbiAgQm9va21hcmtzZXRzOiAoKSA9PiBCb29rbWFya3NldHMsXG4gIENhbGVuZGFyOiAoKSA9PiBDYWxlbmRhcixcbiAgQ2FsZW5kYXJFdmVudFJTVlA6ICgpID0+IENhbGVuZGFyRXZlbnRSU1ZQLFxuICBDaGFubmVsQ3JlYXRpb246ICgpID0+IENoYW5uZWxDcmVhdGlvbixcbiAgQ2hhbm5lbEhpZGVNZXNzYWdlOiAoKSA9PiBDaGFubmVsSGlkZU1lc3NhZ2UsXG4gIENoYW5uZWxNZXNzYWdlOiAoKSA9PiBDaGFubmVsTWVzc2FnZSxcbiAgQ2hhbm5lbE1ldGFkYXRhOiAoKSA9PiBDaGFubmVsTWV0YWRhdGEsXG4gIENoYW5uZWxNdXRlVXNlcjogKCkgPT4gQ2hhbm5lbE11dGVVc2VyLFxuICBDbGFzc2lmaWVkTGlzdGluZzogKCkgPT4gQ2xhc3NpZmllZExpc3RpbmcsXG4gIENsaWVudEF1dGg6ICgpID0+IENsaWVudEF1dGgsXG4gIENvbW11bml0aWVzTGlzdDogKCkgPT4gQ29tbXVuaXRpZXNMaXN0LFxuICBDb21tdW5pdHlEZWZpbml0aW9uOiAoKSA9PiBDb21tdW5pdHlEZWZpbml0aW9uLFxuICBDb21tdW5pdHlQb3N0QXBwcm92YWw6ICgpID0+IENvbW11bml0eVBvc3RBcHByb3ZhbCxcbiAgQ29udGFjdHM6ICgpID0+IENvbnRhY3RzLFxuICBDcmVhdGVPclVwZGF0ZVByb2R1Y3Q6ICgpID0+IENyZWF0ZU9yVXBkYXRlUHJvZHVjdCxcbiAgQ3JlYXRlT3JVcGRhdGVTdGFsbDogKCkgPT4gQ3JlYXRlT3JVcGRhdGVTdGFsbCxcbiAgQ3VyYXRpb25zZXRzOiAoKSA9PiBDdXJhdGlvbnNldHMsXG4gIERhdGU6ICgpID0+IERhdGUyLFxuICBEaXJlY3RNZXNzYWdlUmVsYXlzTGlzdDogKCkgPT4gRGlyZWN0TWVzc2FnZVJlbGF5c0xpc3QsXG4gIERyYWZ0Q2xhc3NpZmllZExpc3Rpbmc6ICgpID0+IERyYWZ0Q2xhc3NpZmllZExpc3RpbmcsXG4gIERyYWZ0TG9uZzogKCkgPT4gRHJhZnRMb25nLFxuICBFbW9qaXNldHM6ICgpID0+IEVtb2ppc2V0cyxcbiAgRW5jcnlwdGVkRGlyZWN0TWVzc2FnZTogKCkgPT4gRW5jcnlwdGVkRGlyZWN0TWVzc2FnZSxcbiAgRXZlbnREZWxldGlvbjogKCkgPT4gRXZlbnREZWxldGlvbixcbiAgRmlsZU1ldGFkYXRhOiAoKSA9PiBGaWxlTWV0YWRhdGEsXG4gIEZpbGVTZXJ2ZXJQcmVmZXJlbmNlOiAoKSA9PiBGaWxlU2VydmVyUHJlZmVyZW5jZSxcbiAgRm9sbG93c2V0czogKCkgPT4gRm9sbG93c2V0cyxcbiAgR2VuZXJpY1JlcG9zdDogKCkgPT4gR2VuZXJpY1JlcG9zdCxcbiAgR2VuZXJpY2xpc3RzOiAoKSA9PiBHZW5lcmljbGlzdHMsXG4gIEdpZnRXcmFwOiAoKSA9PiBHaWZ0V3JhcCxcbiAgSFRUUEF1dGg6ICgpID0+IEhUVFBBdXRoLFxuICBIYW5kbGVyaW5mb3JtYXRpb246ICgpID0+IEhhbmRsZXJpbmZvcm1hdGlvbixcbiAgSGFuZGxlcnJlY29tbWVuZGF0aW9uOiAoKSA9PiBIYW5kbGVycmVjb21tZW5kYXRpb24sXG4gIEhpZ2hsaWdodHM6ICgpID0+IEhpZ2hsaWdodHMsXG4gIEludGVyZXN0c0xpc3Q6ICgpID0+IEludGVyZXN0c0xpc3QsXG4gIEludGVyZXN0c2V0czogKCkgPT4gSW50ZXJlc3RzZXRzLFxuICBKb2JGZWVkYmFjazogKCkgPT4gSm9iRmVlZGJhY2ssXG4gIEpvYlJlcXVlc3Q6ICgpID0+IEpvYlJlcXVlc3QsXG4gIEpvYlJlc3VsdDogKCkgPT4gSm9iUmVzdWx0LFxuICBMYWJlbDogKCkgPT4gTGFiZWwsXG4gIExpZ2h0bmluZ1B1YlJQQzogKCkgPT4gTGlnaHRuaW5nUHViUlBDLFxuICBMaXZlQ2hhdE1lc3NhZ2U6ICgpID0+IExpdmVDaGF0TWVzc2FnZSxcbiAgTGl2ZUV2ZW50OiAoKSA9PiBMaXZlRXZlbnQsXG4gIExvbmdGb3JtQXJ0aWNsZTogKCkgPT4gTG9uZ0Zvcm1BcnRpY2xlLFxuICBNZXRhZGF0YTogKCkgPT4gTWV0YWRhdGEsXG4gIE11dGVsaXN0OiAoKSA9PiBNdXRlbGlzdCxcbiAgTldDV2FsbGV0SW5mbzogKCkgPT4gTldDV2FsbGV0SW5mbyxcbiAgTldDV2FsbGV0UmVxdWVzdDogKCkgPT4gTldDV2FsbGV0UmVxdWVzdCxcbiAgTldDV2FsbGV0UmVzcG9uc2U6ICgpID0+IE5XQ1dhbGxldFJlc3BvbnNlLFxuICBOb3N0ckNvbm5lY3Q6ICgpID0+IE5vc3RyQ29ubmVjdCxcbiAgT3BlblRpbWVzdGFtcHM6ICgpID0+IE9wZW5UaW1lc3RhbXBzLFxuICBQaW5saXN0OiAoKSA9PiBQaW5saXN0LFxuICBQcml2YXRlRGlyZWN0TWVzc2FnZTogKCkgPT4gUHJpdmF0ZURpcmVjdE1lc3NhZ2UsXG4gIFByb2JsZW1UcmFja2VyOiAoKSA9PiBQcm9ibGVtVHJhY2tlcixcbiAgUHJvZmlsZUJhZGdlczogKCkgPT4gUHJvZmlsZUJhZGdlcyxcbiAgUHVibGljQ2hhdHNMaXN0OiAoKSA9PiBQdWJsaWNDaGF0c0xpc3QsXG4gIFJlYWN0aW9uOiAoKSA9PiBSZWFjdGlvbixcbiAgUmVjb21tZW5kUmVsYXk6ICgpID0+IFJlY29tbWVuZFJlbGF5LFxuICBSZWxheUxpc3Q6ICgpID0+IFJlbGF5TGlzdCxcbiAgUmVsYXlzZXRzOiAoKSA9PiBSZWxheXNldHMsXG4gIFJlcG9ydDogKCkgPT4gUmVwb3J0LFxuICBSZXBvcnRpbmc6ICgpID0+IFJlcG9ydGluZyxcbiAgUmVwb3N0OiAoKSA9PiBSZXBvc3QsXG4gIFNlYWw6ICgpID0+IFNlYWwsXG4gIFNlYXJjaFJlbGF5c0xpc3Q6ICgpID0+IFNlYXJjaFJlbGF5c0xpc3QsXG4gIFNob3J0VGV4dE5vdGU6ICgpID0+IFNob3J0VGV4dE5vdGUsXG4gIFRpbWU6ICgpID0+IFRpbWUsXG4gIFVzZXJFbW9qaUxpc3Q6ICgpID0+IFVzZXJFbW9qaUxpc3QsXG4gIFVzZXJTdGF0dXNlczogKCkgPT4gVXNlclN0YXR1c2VzLFxuICBaYXA6ICgpID0+IFphcCxcbiAgWmFwR29hbDogKCkgPT4gWmFwR29hbCxcbiAgWmFwUmVxdWVzdDogKCkgPT4gWmFwUmVxdWVzdCxcbiAgY2xhc3NpZnlLaW5kOiAoKSA9PiBjbGFzc2lmeUtpbmQsXG4gIGlzRXBoZW1lcmFsS2luZDogKCkgPT4gaXNFcGhlbWVyYWxLaW5kLFxuICBpc0tpbmQ6ICgpID0+IGlzS2luZCxcbiAgaXNQYXJhbWV0ZXJpemVkUmVwbGFjZWFibGVLaW5kOiAoKSA9PiBpc1BhcmFtZXRlcml6ZWRSZXBsYWNlYWJsZUtpbmQsXG4gIGlzUmVndWxhcktpbmQ6ICgpID0+IGlzUmVndWxhcktpbmQsXG4gIGlzUmVwbGFjZWFibGVLaW5kOiAoKSA9PiBpc1JlcGxhY2VhYmxlS2luZFxufSk7XG5mdW5jdGlvbiBpc1JlZ3VsYXJLaW5kKGtpbmQpIHtcbiAgcmV0dXJuIDFlMyA8PSBraW5kICYmIGtpbmQgPCAxZTQgfHwgWzEsIDIsIDQsIDUsIDYsIDcsIDgsIDE2LCA0MCwgNDEsIDQyLCA0MywgNDRdLmluY2x1ZGVzKGtpbmQpO1xufVxuZnVuY3Rpb24gaXNSZXBsYWNlYWJsZUtpbmQoa2luZCkge1xuICByZXR1cm4gWzAsIDNdLmluY2x1ZGVzKGtpbmQpIHx8IDFlNCA8PSBraW5kICYmIGtpbmQgPCAyZTQ7XG59XG5mdW5jdGlvbiBpc0VwaGVtZXJhbEtpbmQoa2luZCkge1xuICByZXR1cm4gMmU0IDw9IGtpbmQgJiYga2luZCA8IDNlNDtcbn1cbmZ1bmN0aW9uIGlzUGFyYW1ldGVyaXplZFJlcGxhY2VhYmxlS2luZChraW5kKSB7XG4gIHJldHVybiAzZTQgPD0ga2luZCAmJiBraW5kIDwgNGU0O1xufVxuZnVuY3Rpb24gY2xhc3NpZnlLaW5kKGtpbmQpIHtcbiAgaWYgKGlzUmVndWxhcktpbmQoa2luZCkpXG4gICAgcmV0dXJuIFwicmVndWxhclwiO1xuICBpZiAoaXNSZXBsYWNlYWJsZUtpbmQoa2luZCkpXG4gICAgcmV0dXJuIFwicmVwbGFjZWFibGVcIjtcbiAgaWYgKGlzRXBoZW1lcmFsS2luZChraW5kKSlcbiAgICByZXR1cm4gXCJlcGhlbWVyYWxcIjtcbiAgaWYgKGlzUGFyYW1ldGVyaXplZFJlcGxhY2VhYmxlS2luZChraW5kKSlcbiAgICByZXR1cm4gXCJwYXJhbWV0ZXJpemVkXCI7XG4gIHJldHVybiBcInVua25vd25cIjtcbn1cbmZ1bmN0aW9uIGlzS2luZChldmVudCwga2luZCkge1xuICBjb25zdCBraW5kQXNBcnJheSA9IGtpbmQgaW5zdGFuY2VvZiBBcnJheSA/IGtpbmQgOiBba2luZF07XG4gIHJldHVybiB2YWxpZGF0ZUV2ZW50KGV2ZW50KSAmJiBraW5kQXNBcnJheS5pbmNsdWRlcyhldmVudC5raW5kKSB8fCBmYWxzZTtcbn1cbnZhciBNZXRhZGF0YSA9IDA7XG52YXIgU2hvcnRUZXh0Tm90ZSA9IDE7XG52YXIgUmVjb21tZW5kUmVsYXkgPSAyO1xudmFyIENvbnRhY3RzID0gMztcbnZhciBFbmNyeXB0ZWREaXJlY3RNZXNzYWdlID0gNDtcbnZhciBFdmVudERlbGV0aW9uID0gNTtcbnZhciBSZXBvc3QgPSA2O1xudmFyIFJlYWN0aW9uID0gNztcbnZhciBCYWRnZUF3YXJkID0gODtcbnZhciBTZWFsID0gMTM7XG52YXIgUHJpdmF0ZURpcmVjdE1lc3NhZ2UgPSAxNDtcbnZhciBHZW5lcmljUmVwb3N0ID0gMTY7XG52YXIgQ2hhbm5lbENyZWF0aW9uID0gNDA7XG52YXIgQ2hhbm5lbE1ldGFkYXRhID0gNDE7XG52YXIgQ2hhbm5lbE1lc3NhZ2UgPSA0MjtcbnZhciBDaGFubmVsSGlkZU1lc3NhZ2UgPSA0MztcbnZhciBDaGFubmVsTXV0ZVVzZXIgPSA0NDtcbnZhciBPcGVuVGltZXN0YW1wcyA9IDEwNDA7XG52YXIgR2lmdFdyYXAgPSAxMDU5O1xudmFyIEZpbGVNZXRhZGF0YSA9IDEwNjM7XG52YXIgTGl2ZUNoYXRNZXNzYWdlID0gMTMxMTtcbnZhciBQcm9ibGVtVHJhY2tlciA9IDE5NzE7XG52YXIgUmVwb3J0ID0gMTk4NDtcbnZhciBSZXBvcnRpbmcgPSAxOTg0O1xudmFyIExhYmVsID0gMTk4NTtcbnZhciBDb21tdW5pdHlQb3N0QXBwcm92YWwgPSA0NTUwO1xudmFyIEpvYlJlcXVlc3QgPSA1OTk5O1xudmFyIEpvYlJlc3VsdCA9IDY5OTk7XG52YXIgSm9iRmVlZGJhY2sgPSA3ZTM7XG52YXIgWmFwR29hbCA9IDkwNDE7XG52YXIgWmFwUmVxdWVzdCA9IDk3MzQ7XG52YXIgWmFwID0gOTczNTtcbnZhciBIaWdobGlnaHRzID0gOTgwMjtcbnZhciBNdXRlbGlzdCA9IDFlNDtcbnZhciBQaW5saXN0ID0gMTAwMDE7XG52YXIgUmVsYXlMaXN0ID0gMTAwMDI7XG52YXIgQm9va21hcmtMaXN0ID0gMTAwMDM7XG52YXIgQ29tbXVuaXRpZXNMaXN0ID0gMTAwMDQ7XG52YXIgUHVibGljQ2hhdHNMaXN0ID0gMTAwMDU7XG52YXIgQmxvY2tlZFJlbGF5c0xpc3QgPSAxMDAwNjtcbnZhciBTZWFyY2hSZWxheXNMaXN0ID0gMTAwMDc7XG52YXIgSW50ZXJlc3RzTGlzdCA9IDEwMDE1O1xudmFyIFVzZXJFbW9qaUxpc3QgPSAxMDAzMDtcbnZhciBEaXJlY3RNZXNzYWdlUmVsYXlzTGlzdCA9IDEwMDUwO1xudmFyIEZpbGVTZXJ2ZXJQcmVmZXJlbmNlID0gMTAwOTY7XG52YXIgTldDV2FsbGV0SW5mbyA9IDEzMTk0O1xudmFyIExpZ2h0bmluZ1B1YlJQQyA9IDIxZTM7XG52YXIgQ2xpZW50QXV0aCA9IDIyMjQyO1xudmFyIE5XQ1dhbGxldFJlcXVlc3QgPSAyMzE5NDtcbnZhciBOV0NXYWxsZXRSZXNwb25zZSA9IDIzMTk1O1xudmFyIE5vc3RyQ29ubmVjdCA9IDI0MTMzO1xudmFyIEhUVFBBdXRoID0gMjcyMzU7XG52YXIgRm9sbG93c2V0cyA9IDNlNDtcbnZhciBHZW5lcmljbGlzdHMgPSAzMDAwMTtcbnZhciBSZWxheXNldHMgPSAzMDAwMjtcbnZhciBCb29rbWFya3NldHMgPSAzMDAwMztcbnZhciBDdXJhdGlvbnNldHMgPSAzMDAwNDtcbnZhciBQcm9maWxlQmFkZ2VzID0gMzAwMDg7XG52YXIgQmFkZ2VEZWZpbml0aW9uID0gMzAwMDk7XG52YXIgSW50ZXJlc3RzZXRzID0gMzAwMTU7XG52YXIgQ3JlYXRlT3JVcGRhdGVTdGFsbCA9IDMwMDE3O1xudmFyIENyZWF0ZU9yVXBkYXRlUHJvZHVjdCA9IDMwMDE4O1xudmFyIExvbmdGb3JtQXJ0aWNsZSA9IDMwMDIzO1xudmFyIERyYWZ0TG9uZyA9IDMwMDI0O1xudmFyIEVtb2ppc2V0cyA9IDMwMDMwO1xudmFyIEFwcGxpY2F0aW9uID0gMzAwNzg7XG52YXIgTGl2ZUV2ZW50ID0gMzAzMTE7XG52YXIgVXNlclN0YXR1c2VzID0gMzAzMTU7XG52YXIgQ2xhc3NpZmllZExpc3RpbmcgPSAzMDQwMjtcbnZhciBEcmFmdENsYXNzaWZpZWRMaXN0aW5nID0gMzA0MDM7XG52YXIgRGF0ZTIgPSAzMTkyMjtcbnZhciBUaW1lID0gMzE5MjM7XG52YXIgQ2FsZW5kYXIgPSAzMTkyNDtcbnZhciBDYWxlbmRhckV2ZW50UlNWUCA9IDMxOTI1O1xudmFyIEhhbmRsZXJyZWNvbW1lbmRhdGlvbiA9IDMxOTg5O1xudmFyIEhhbmRsZXJpbmZvcm1hdGlvbiA9IDMxOTkwO1xudmFyIENvbW11bml0eURlZmluaXRpb24gPSAzNDU1MDtcblxuLy8gZmlsdGVyLnRzXG5mdW5jdGlvbiBtYXRjaEZpbHRlcihmaWx0ZXIsIGV2ZW50KSB7XG4gIGlmIChmaWx0ZXIuaWRzICYmIGZpbHRlci5pZHMuaW5kZXhPZihldmVudC5pZCkgPT09IC0xKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChmaWx0ZXIua2luZHMgJiYgZmlsdGVyLmtpbmRzLmluZGV4T2YoZXZlbnQua2luZCkgPT09IC0xKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChmaWx0ZXIuYXV0aG9ycyAmJiBmaWx0ZXIuYXV0aG9ycy5pbmRleE9mKGV2ZW50LnB1YmtleSkgPT09IC0xKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAobGV0IGYgaW4gZmlsdGVyKSB7XG4gICAgaWYgKGZbMF0gPT09IFwiI1wiKSB7XG4gICAgICBsZXQgdGFnTmFtZSA9IGYuc2xpY2UoMSk7XG4gICAgICBsZXQgdmFsdWVzID0gZmlsdGVyW2AjJHt0YWdOYW1lfWBdO1xuICAgICAgaWYgKHZhbHVlcyAmJiAhZXZlbnQudGFncy5maW5kKChbdCwgdl0pID0+IHQgPT09IGYuc2xpY2UoMSkgJiYgdmFsdWVzLmluZGV4T2YodikgIT09IC0xKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAoZmlsdGVyLnNpbmNlICYmIGV2ZW50LmNyZWF0ZWRfYXQgPCBmaWx0ZXIuc2luY2UpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoZmlsdGVyLnVudGlsICYmIGV2ZW50LmNyZWF0ZWRfYXQgPiBmaWx0ZXIudW50aWwpXG4gICAgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIG1hdGNoRmlsdGVycyhmaWx0ZXJzLCBldmVudCkge1xuICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgZmlsdGVycy5sZW5ndGg7IGkyKyspIHtcbiAgICBpZiAobWF0Y2hGaWx0ZXIoZmlsdGVyc1tpMl0sIGV2ZW50KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIG1lcmdlRmlsdGVycyguLi5maWx0ZXJzKSB7XG4gIGxldCByZXN1bHQgPSB7fTtcbiAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IGZpbHRlcnMubGVuZ3RoOyBpMisrKSB7XG4gICAgbGV0IGZpbHRlciA9IGZpbHRlcnNbaTJdO1xuICAgIE9iamVjdC5lbnRyaWVzKGZpbHRlcikuZm9yRWFjaCgoW3Byb3BlcnR5LCB2YWx1ZXNdKSA9PiB7XG4gICAgICBpZiAocHJvcGVydHkgPT09IFwia2luZHNcIiB8fCBwcm9wZXJ0eSA9PT0gXCJpZHNcIiB8fCBwcm9wZXJ0eSA9PT0gXCJhdXRob3JzXCIgfHwgcHJvcGVydHlbMF0gPT09IFwiI1wiKSB7XG4gICAgICAgIHJlc3VsdFtwcm9wZXJ0eV0gPSByZXN1bHRbcHJvcGVydHldIHx8IFtdO1xuICAgICAgICBmb3IgKGxldCB2ID0gMDsgdiA8IHZhbHVlcy5sZW5ndGg7IHYrKykge1xuICAgICAgICAgIGxldCB2YWx1ZSA9IHZhbHVlc1t2XTtcbiAgICAgICAgICBpZiAoIXJlc3VsdFtwcm9wZXJ0eV0uaW5jbHVkZXModmFsdWUpKVxuICAgICAgICAgICAgcmVzdWx0W3Byb3BlcnR5XS5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChmaWx0ZXIubGltaXQgJiYgKCFyZXN1bHQubGltaXQgfHwgZmlsdGVyLmxpbWl0ID4gcmVzdWx0LmxpbWl0KSlcbiAgICAgIHJlc3VsdC5saW1pdCA9IGZpbHRlci5saW1pdDtcbiAgICBpZiAoZmlsdGVyLnVudGlsICYmICghcmVzdWx0LnVudGlsIHx8IGZpbHRlci51bnRpbCA+IHJlc3VsdC51bnRpbCkpXG4gICAgICByZXN1bHQudW50aWwgPSBmaWx0ZXIudW50aWw7XG4gICAgaWYgKGZpbHRlci5zaW5jZSAmJiAoIXJlc3VsdC5zaW5jZSB8fCBmaWx0ZXIuc2luY2UgPCByZXN1bHQuc2luY2UpKVxuICAgICAgcmVzdWx0LnNpbmNlID0gZmlsdGVyLnNpbmNlO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXRGaWx0ZXJMaW1pdChmaWx0ZXIpIHtcbiAgaWYgKGZpbHRlci5pZHMgJiYgIWZpbHRlci5pZHMubGVuZ3RoKVxuICAgIHJldHVybiAwO1xuICBpZiAoZmlsdGVyLmtpbmRzICYmICFmaWx0ZXIua2luZHMubGVuZ3RoKVxuICAgIHJldHVybiAwO1xuICBpZiAoZmlsdGVyLmF1dGhvcnMgJiYgIWZpbHRlci5hdXRob3JzLmxlbmd0aClcbiAgICByZXR1cm4gMDtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoZmlsdGVyKSkge1xuICAgIGlmIChrZXlbMF0gPT09IFwiI1wiICYmIEFycmF5LmlzQXJyYXkodmFsdWUpICYmICF2YWx1ZS5sZW5ndGgpXG4gICAgICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4gTWF0aC5taW4oXG4gICAgTWF0aC5tYXgoMCwgZmlsdGVyLmxpbWl0ID8/IEluZmluaXR5KSxcbiAgICBmaWx0ZXIuaWRzPy5sZW5ndGggPz8gSW5maW5pdHksXG4gICAgZmlsdGVyLmF1dGhvcnM/Lmxlbmd0aCAmJiBmaWx0ZXIua2luZHM/LmV2ZXJ5KChraW5kKSA9PiBpc1JlcGxhY2VhYmxlS2luZChraW5kKSkgPyBmaWx0ZXIuYXV0aG9ycy5sZW5ndGggKiBmaWx0ZXIua2luZHMubGVuZ3RoIDogSW5maW5pdHksXG4gICAgZmlsdGVyLmF1dGhvcnM/Lmxlbmd0aCAmJiBmaWx0ZXIua2luZHM/LmV2ZXJ5KChraW5kKSA9PiBpc1BhcmFtZXRlcml6ZWRSZXBsYWNlYWJsZUtpbmQoa2luZCkpICYmIGZpbHRlcltcIiNkXCJdPy5sZW5ndGggPyBmaWx0ZXIuYXV0aG9ycy5sZW5ndGggKiBmaWx0ZXIua2luZHMubGVuZ3RoICogZmlsdGVyW1wiI2RcIl0ubGVuZ3RoIDogSW5maW5pdHlcbiAgKTtcbn1cblxuLy8gZmFrZWpzb24udHNcbnZhciBmYWtlanNvbl9leHBvcnRzID0ge307XG5fX2V4cG9ydChmYWtlanNvbl9leHBvcnRzLCB7XG4gIGdldEhleDY0OiAoKSA9PiBnZXRIZXg2NCxcbiAgZ2V0SW50OiAoKSA9PiBnZXRJbnQsXG4gIGdldFN1YnNjcmlwdGlvbklkOiAoKSA9PiBnZXRTdWJzY3JpcHRpb25JZCxcbiAgbWF0Y2hFdmVudElkOiAoKSA9PiBtYXRjaEV2ZW50SWQsXG4gIG1hdGNoRXZlbnRLaW5kOiAoKSA9PiBtYXRjaEV2ZW50S2luZCxcbiAgbWF0Y2hFdmVudFB1YmtleTogKCkgPT4gbWF0Y2hFdmVudFB1YmtleVxufSk7XG5mdW5jdGlvbiBnZXRIZXg2NChqc29uLCBmaWVsZCkge1xuICBsZXQgbGVuID0gZmllbGQubGVuZ3RoICsgMztcbiAgbGV0IGlkeCA9IGpzb24uaW5kZXhPZihgXCIke2ZpZWxkfVwiOmApICsgbGVuO1xuICBsZXQgcyA9IGpzb24uc2xpY2UoaWR4KS5pbmRleE9mKGBcImApICsgaWR4ICsgMTtcbiAgcmV0dXJuIGpzb24uc2xpY2UocywgcyArIDY0KTtcbn1cbmZ1bmN0aW9uIGdldEludChqc29uLCBmaWVsZCkge1xuICBsZXQgbGVuID0gZmllbGQubGVuZ3RoO1xuICBsZXQgaWR4ID0ganNvbi5pbmRleE9mKGBcIiR7ZmllbGR9XCI6YCkgKyBsZW4gKyAzO1xuICBsZXQgc2xpY2VkID0ganNvbi5zbGljZShpZHgpO1xuICBsZXQgZW5kID0gTWF0aC5taW4oc2xpY2VkLmluZGV4T2YoXCIsXCIpLCBzbGljZWQuaW5kZXhPZihcIn1cIikpO1xuICByZXR1cm4gcGFyc2VJbnQoc2xpY2VkLnNsaWNlKDAsIGVuZCksIDEwKTtcbn1cbmZ1bmN0aW9uIGdldFN1YnNjcmlwdGlvbklkKGpzb24pIHtcbiAgbGV0IGlkeCA9IGpzb24uc2xpY2UoMCwgMjIpLmluZGV4T2YoYFwiRVZFTlRcImApO1xuICBpZiAoaWR4ID09PSAtMSlcbiAgICByZXR1cm4gbnVsbDtcbiAgbGV0IHBzdGFydCA9IGpzb24uc2xpY2UoaWR4ICsgNyArIDEpLmluZGV4T2YoYFwiYCk7XG4gIGlmIChwc3RhcnQgPT09IC0xKVxuICAgIHJldHVybiBudWxsO1xuICBsZXQgc3RhcnQgPSBpZHggKyA3ICsgMSArIHBzdGFydDtcbiAgbGV0IHBlbmQgPSBqc29uLnNsaWNlKHN0YXJ0ICsgMSwgODApLmluZGV4T2YoYFwiYCk7XG4gIGlmIChwZW5kID09PSAtMSlcbiAgICByZXR1cm4gbnVsbDtcbiAgbGV0IGVuZCA9IHN0YXJ0ICsgMSArIHBlbmQ7XG4gIHJldHVybiBqc29uLnNsaWNlKHN0YXJ0ICsgMSwgZW5kKTtcbn1cbmZ1bmN0aW9uIG1hdGNoRXZlbnRJZChqc29uLCBpZCkge1xuICByZXR1cm4gaWQgPT09IGdldEhleDY0KGpzb24sIFwiaWRcIik7XG59XG5mdW5jdGlvbiBtYXRjaEV2ZW50UHVia2V5KGpzb24sIHB1YmtleSkge1xuICByZXR1cm4gcHVia2V5ID09PSBnZXRIZXg2NChqc29uLCBcInB1YmtleVwiKTtcbn1cbmZ1bmN0aW9uIG1hdGNoRXZlbnRLaW5kKGpzb24sIGtpbmQpIHtcbiAgcmV0dXJuIGtpbmQgPT09IGdldEludChqc29uLCBcImtpbmRcIik7XG59XG5cbi8vIG5pcDQyLnRzXG52YXIgbmlwNDJfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobmlwNDJfZXhwb3J0cywge1xuICBtYWtlQXV0aEV2ZW50OiAoKSA9PiBtYWtlQXV0aEV2ZW50XG59KTtcbmZ1bmN0aW9uIG1ha2VBdXRoRXZlbnQocmVsYXlVUkwsIGNoYWxsZW5nZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IENsaWVudEF1dGgsXG4gICAgY3JlYXRlZF9hdDogTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMWUzKSxcbiAgICB0YWdzOiBbXG4gICAgICBbXCJyZWxheVwiLCByZWxheVVSTF0sXG4gICAgICBbXCJjaGFsbGVuZ2VcIiwgY2hhbGxlbmdlXVxuICAgIF0sXG4gICAgY29udGVudDogXCJcIlxuICB9O1xufVxuXG4vLyBoZWxwZXJzLnRzXG5hc3luYyBmdW5jdGlvbiB5aWVsZFRocmVhZCgpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgY29uc3QgY2ggPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICBjb25zdCBoYW5kbGVyID0gKCkgPT4ge1xuICAgICAgY2gucG9ydDEucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgaGFuZGxlcik7XG4gICAgICByZXNvbHZlKCk7XG4gICAgfTtcbiAgICBjaC5wb3J0MS5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBoYW5kbGVyKTtcbiAgICBjaC5wb3J0Mi5wb3N0TWVzc2FnZSgwKTtcbiAgICBjaC5wb3J0MS5zdGFydCgpO1xuICB9KTtcbn1cbnZhciBhbHdheXNUcnVlID0gKHQpID0+IHtcbiAgdFt2ZXJpZmllZFN5bWJvbF0gPSB0cnVlO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIGFic3RyYWN0LXJlbGF5LnRzXG52YXIgQWJzdHJhY3RSZWxheSA9IGNsYXNzIHtcbiAgdXJsO1xuICBfY29ubmVjdGVkID0gZmFsc2U7XG4gIG9uY2xvc2UgPSBudWxsO1xuICBvbm5vdGljZSA9IChtc2cpID0+IGNvbnNvbGUuZGVidWcoYE5PVElDRSBmcm9tICR7dGhpcy51cmx9OiAke21zZ31gKTtcbiAgX29uYXV0aCA9IG51bGw7XG4gIGJhc2VFb3NlVGltZW91dCA9IDQ0MDA7XG4gIGNvbm5lY3Rpb25UaW1lb3V0ID0gNDQwMDtcbiAgcHVibGlzaFRpbWVvdXQgPSA0NDAwO1xuICBvcGVuU3VicyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbm5lY3Rpb25UaW1lb3V0SGFuZGxlO1xuICBjb25uZWN0aW9uUHJvbWlzZTtcbiAgb3BlbkNvdW50UmVxdWVzdHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBvcGVuRXZlbnRQdWJsaXNoZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB3cztcbiAgaW5jb21pbmdNZXNzYWdlUXVldWUgPSBuZXcgUXVldWUoKTtcbiAgcXVldWVSdW5uaW5nID0gZmFsc2U7XG4gIGNoYWxsZW5nZTtcbiAgc2VyaWFsID0gMDtcbiAgdmVyaWZ5RXZlbnQ7XG4gIF9XZWJTb2NrZXQ7XG4gIGNvbnN0cnVjdG9yKHVybCwgb3B0cykge1xuICAgIHRoaXMudXJsID0gbm9ybWFsaXplVVJMKHVybCk7XG4gICAgdGhpcy52ZXJpZnlFdmVudCA9IG9wdHMudmVyaWZ5RXZlbnQ7XG4gICAgdGhpcy5fV2ViU29ja2V0ID0gb3B0cy53ZWJzb2NrZXRJbXBsZW1lbnRhdGlvbiB8fCBXZWJTb2NrZXQ7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGNvbm5lY3QodXJsLCBvcHRzKSB7XG4gICAgY29uc3QgcmVsYXkgPSBuZXcgQWJzdHJhY3RSZWxheSh1cmwsIG9wdHMpO1xuICAgIGF3YWl0IHJlbGF5LmNvbm5lY3QoKTtcbiAgICByZXR1cm4gcmVsYXk7XG4gIH1cbiAgY2xvc2VBbGxTdWJzY3JpcHRpb25zKHJlYXNvbikge1xuICAgIGZvciAobGV0IFtfLCBzdWJdIG9mIHRoaXMub3BlblN1YnMpIHtcbiAgICAgIHN1Yi5jbG9zZShyZWFzb24pO1xuICAgIH1cbiAgICB0aGlzLm9wZW5TdWJzLmNsZWFyKCk7XG4gICAgZm9yIChsZXQgW18sIGVwXSBvZiB0aGlzLm9wZW5FdmVudFB1Ymxpc2hlcykge1xuICAgICAgZXAucmVqZWN0KG5ldyBFcnJvcihyZWFzb24pKTtcbiAgICB9XG4gICAgdGhpcy5vcGVuRXZlbnRQdWJsaXNoZXMuY2xlYXIoKTtcbiAgICBmb3IgKGxldCBbXywgY3JdIG9mIHRoaXMub3BlbkNvdW50UmVxdWVzdHMpIHtcbiAgICAgIGNyLnJlamVjdChuZXcgRXJyb3IocmVhc29uKSk7XG4gICAgfVxuICAgIHRoaXMub3BlbkNvdW50UmVxdWVzdHMuY2xlYXIoKTtcbiAgfVxuICBnZXQgY29ubmVjdGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25uZWN0ZWQ7XG4gIH1cbiAgYXN5bmMgY29ubmVjdCgpIHtcbiAgICBpZiAodGhpcy5jb25uZWN0aW9uUHJvbWlzZSlcbiAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb25Qcm9taXNlO1xuICAgIHRoaXMuY2hhbGxlbmdlID0gdm9pZCAwO1xuICAgIHRoaXMuY29ubmVjdGlvblByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLmNvbm5lY3Rpb25UaW1lb3V0SGFuZGxlID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHJlamVjdChcImNvbm5lY3Rpb24gdGltZWQgb3V0XCIpO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25Qcm9taXNlID0gdm9pZCAwO1xuICAgICAgICB0aGlzLm9uY2xvc2U/LigpO1xuICAgICAgICB0aGlzLmNsb3NlQWxsU3Vic2NyaXB0aW9ucyhcInJlbGF5IGNvbm5lY3Rpb24gdGltZWQgb3V0XCIpO1xuICAgICAgfSwgdGhpcy5jb25uZWN0aW9uVGltZW91dCk7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLndzID0gbmV3IHRoaXMuX1dlYlNvY2tldCh0aGlzLnVybCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMud3Mub25vcGVuID0gKCkgPT4ge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5jb25uZWN0aW9uVGltZW91dEhhbmRsZSk7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH07XG4gICAgICB0aGlzLndzLm9uZXJyb3IgPSAoZXYpID0+IHtcbiAgICAgICAgcmVqZWN0KGV2Lm1lc3NhZ2UgfHwgXCJ3ZWJzb2NrZXQgZXJyb3JcIik7XG4gICAgICAgIGlmICh0aGlzLl9jb25uZWN0ZWQpIHtcbiAgICAgICAgICB0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25Qcm9taXNlID0gdm9pZCAwO1xuICAgICAgICAgIHRoaXMub25jbG9zZT8uKCk7XG4gICAgICAgICAgdGhpcy5jbG9zZUFsbFN1YnNjcmlwdGlvbnMoXCJyZWxheSBjb25uZWN0aW9uIGVycm9yZWRcIik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLndzLm9uY2xvc2UgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLl9jb25uZWN0ZWQpIHtcbiAgICAgICAgICB0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25Qcm9taXNlID0gdm9pZCAwO1xuICAgICAgICAgIHRoaXMub25jbG9zZT8uKCk7XG4gICAgICAgICAgdGhpcy5jbG9zZUFsbFN1YnNjcmlwdGlvbnMoXCJyZWxheSBjb25uZWN0aW9uIGNsb3NlZFwiKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHRoaXMud3Mub25tZXNzYWdlID0gdGhpcy5fb25tZXNzYWdlLmJpbmQodGhpcyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvblByb21pc2U7XG4gIH1cbiAgYXN5bmMgcnVuUXVldWUoKSB7XG4gICAgdGhpcy5xdWV1ZVJ1bm5pbmcgPSB0cnVlO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAoZmFsc2UgPT09IHRoaXMuaGFuZGxlTmV4dCgpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgYXdhaXQgeWllbGRUaHJlYWQoKTtcbiAgICB9XG4gICAgdGhpcy5xdWV1ZVJ1bm5pbmcgPSBmYWxzZTtcbiAgfVxuICBoYW5kbGVOZXh0KCkge1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLmluY29taW5nTWVzc2FnZVF1ZXVlLmRlcXVldWUoKTtcbiAgICBpZiAoIWpzb24pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qgc3ViaWQgPSBnZXRTdWJzY3JpcHRpb25JZChqc29uKTtcbiAgICBpZiAoc3ViaWQpIHtcbiAgICAgIGNvbnN0IHNvID0gdGhpcy5vcGVuU3Vicy5nZXQoc3ViaWQpO1xuICAgICAgaWYgKCFzbykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBpZCA9IGdldEhleDY0KGpzb24sIFwiaWRcIik7XG4gICAgICBjb25zdCBhbHJlYWR5SGF2ZSA9IHNvLmFscmVhZHlIYXZlRXZlbnQ/LihpZCk7XG4gICAgICBzby5yZWNlaXZlZEV2ZW50Py4odGhpcywgaWQpO1xuICAgICAgaWYgKGFscmVhZHlIYXZlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGxldCBkYXRhID0gSlNPTi5wYXJzZShqc29uKTtcbiAgICAgIHN3aXRjaCAoZGF0YVswXSkge1xuICAgICAgICBjYXNlIFwiRVZFTlRcIjoge1xuICAgICAgICAgIGNvbnN0IHNvID0gdGhpcy5vcGVuU3Vicy5nZXQoZGF0YVsxXSk7XG4gICAgICAgICAgY29uc3QgZXZlbnQgPSBkYXRhWzJdO1xuICAgICAgICAgIGlmICh0aGlzLnZlcmlmeUV2ZW50KGV2ZW50KSAmJiBtYXRjaEZpbHRlcnMoc28uZmlsdGVycywgZXZlbnQpKSB7XG4gICAgICAgICAgICBzby5vbmV2ZW50KGV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJDT1VOVFwiOiB7XG4gICAgICAgICAgY29uc3QgaWQgPSBkYXRhWzFdO1xuICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBkYXRhWzJdO1xuICAgICAgICAgIGNvbnN0IGNyID0gdGhpcy5vcGVuQ291bnRSZXF1ZXN0cy5nZXQoaWQpO1xuICAgICAgICAgIGlmIChjcikge1xuICAgICAgICAgICAgY3IucmVzb2x2ZShwYXlsb2FkLmNvdW50KTtcbiAgICAgICAgICAgIHRoaXMub3BlbkNvdW50UmVxdWVzdHMuZGVsZXRlKGlkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJFT1NFXCI6IHtcbiAgICAgICAgICBjb25zdCBzbyA9IHRoaXMub3BlblN1YnMuZ2V0KGRhdGFbMV0pO1xuICAgICAgICAgIGlmICghc28pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgc28ucmVjZWl2ZWRFb3NlKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJPS1wiOiB7XG4gICAgICAgICAgY29uc3QgaWQgPSBkYXRhWzFdO1xuICAgICAgICAgIGNvbnN0IG9rID0gZGF0YVsyXTtcbiAgICAgICAgICBjb25zdCByZWFzb24gPSBkYXRhWzNdO1xuICAgICAgICAgIGNvbnN0IGVwID0gdGhpcy5vcGVuRXZlbnRQdWJsaXNoZXMuZ2V0KGlkKTtcbiAgICAgICAgICBpZiAoZXApIHtcbiAgICAgICAgICAgIGlmIChvaylcbiAgICAgICAgICAgICAgZXAucmVzb2x2ZShyZWFzb24pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBlcC5yZWplY3QobmV3IEVycm9yKHJlYXNvbikpO1xuICAgICAgICAgICAgdGhpcy5vcGVuRXZlbnRQdWJsaXNoZXMuZGVsZXRlKGlkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJDTE9TRURcIjoge1xuICAgICAgICAgIGNvbnN0IGlkID0gZGF0YVsxXTtcbiAgICAgICAgICBjb25zdCBzbyA9IHRoaXMub3BlblN1YnMuZ2V0KGlkKTtcbiAgICAgICAgICBpZiAoIXNvKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIHNvLmNsb3NlZCA9IHRydWU7XG4gICAgICAgICAgc28uY2xvc2UoZGF0YVsyXSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJOT1RJQ0VcIjpcbiAgICAgICAgICB0aGlzLm9ubm90aWNlKGRhdGFbMV0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSBcIkFVVEhcIjoge1xuICAgICAgICAgIHRoaXMuY2hhbGxlbmdlID0gZGF0YVsxXTtcbiAgICAgICAgICB0aGlzLl9vbmF1dGg/LihkYXRhWzFdKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgYXN5bmMgc2VuZChtZXNzYWdlKSB7XG4gICAgaWYgKCF0aGlzLmNvbm5lY3Rpb25Qcm9taXNlKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2VuZGluZyBvbiBjbG9zZWQgY29ubmVjdGlvblwiKTtcbiAgICB0aGlzLmNvbm5lY3Rpb25Qcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgdGhpcy53cz8uc2VuZChtZXNzYWdlKTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBhdXRoKHNpZ25BdXRoRXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuY2hhbGxlbmdlKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2FuJ3QgcGVyZm9ybSBhdXRoLCBubyBjaGFsbGVuZ2Ugd2FzIHJlY2VpdmVkXCIpO1xuICAgIGNvbnN0IGV2dCA9IGF3YWl0IHNpZ25BdXRoRXZlbnQobWFrZUF1dGhFdmVudCh0aGlzLnVybCwgdGhpcy5jaGFsbGVuZ2UpKTtcbiAgICBjb25zdCByZXQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLm9wZW5FdmVudFB1Ymxpc2hlcy5zZXQoZXZ0LmlkLCB7IHJlc29sdmUsIHJlamVjdCB9KTtcbiAgICB9KTtcbiAgICB0aGlzLnNlbmQoJ1tcIkFVVEhcIiwnICsgSlNPTi5zdHJpbmdpZnkoZXZ0KSArIFwiXVwiKTtcbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGFzeW5jIHB1Ymxpc2goZXZlbnQpIHtcbiAgICBjb25zdCByZXQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLm9wZW5FdmVudFB1Ymxpc2hlcy5zZXQoZXZlbnQuaWQsIHsgcmVzb2x2ZSwgcmVqZWN0IH0pO1xuICAgIH0pO1xuICAgIHRoaXMuc2VuZCgnW1wiRVZFTlRcIiwnICsgSlNPTi5zdHJpbmdpZnkoZXZlbnQpICsgXCJdXCIpO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgY29uc3QgZXAgPSB0aGlzLm9wZW5FdmVudFB1Ymxpc2hlcy5nZXQoZXZlbnQuaWQpO1xuICAgICAgaWYgKGVwKSB7XG4gICAgICAgIGVwLnJlamVjdChuZXcgRXJyb3IoXCJwdWJsaXNoIHRpbWVkIG91dFwiKSk7XG4gICAgICAgIHRoaXMub3BlbkV2ZW50UHVibGlzaGVzLmRlbGV0ZShldmVudC5pZCk7XG4gICAgICB9XG4gICAgfSwgdGhpcy5wdWJsaXNoVGltZW91dCk7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBhc3luYyBjb3VudChmaWx0ZXJzLCBwYXJhbXMpIHtcbiAgICB0aGlzLnNlcmlhbCsrO1xuICAgIGNvbnN0IGlkID0gcGFyYW1zPy5pZCB8fCBcImNvdW50OlwiICsgdGhpcy5zZXJpYWw7XG4gICAgY29uc3QgcmV0ID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5vcGVuQ291bnRSZXF1ZXN0cy5zZXQoaWQsIHsgcmVzb2x2ZSwgcmVqZWN0IH0pO1xuICAgIH0pO1xuICAgIHRoaXMuc2VuZCgnW1wiQ09VTlRcIixcIicgKyBpZCArICdcIiwnICsgSlNPTi5zdHJpbmdpZnkoZmlsdGVycykuc3Vic3RyaW5nKDEpKTtcbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIHN1YnNjcmliZShmaWx0ZXJzLCBwYXJhbXMpIHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSB0aGlzLnByZXBhcmVTdWJzY3JpcHRpb24oZmlsdGVycywgcGFyYW1zKTtcbiAgICBzdWJzY3JpcHRpb24uZmlyZSgpO1xuICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gIH1cbiAgcHJlcGFyZVN1YnNjcmlwdGlvbihmaWx0ZXJzLCBwYXJhbXMpIHtcbiAgICB0aGlzLnNlcmlhbCsrO1xuICAgIGNvbnN0IGlkID0gcGFyYW1zLmlkIHx8IFwic3ViOlwiICsgdGhpcy5zZXJpYWw7XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbih0aGlzLCBpZCwgZmlsdGVycywgcGFyYW1zKTtcbiAgICB0aGlzLm9wZW5TdWJzLnNldChpZCwgc3Vic2NyaXB0aW9uKTtcbiAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xuICB9XG4gIGNsb3NlKCkge1xuICAgIHRoaXMuY2xvc2VBbGxTdWJzY3JpcHRpb25zKFwicmVsYXkgY29ubmVjdGlvbiBjbG9zZWQgYnkgdXNcIik7XG4gICAgdGhpcy5fY29ubmVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy53cz8uY2xvc2UoKTtcbiAgfVxuICBfb25tZXNzYWdlKGV2KSB7XG4gICAgdGhpcy5pbmNvbWluZ01lc3NhZ2VRdWV1ZS5lbnF1ZXVlKGV2LmRhdGEpO1xuICAgIGlmICghdGhpcy5xdWV1ZVJ1bm5pbmcpIHtcbiAgICAgIHRoaXMucnVuUXVldWUoKTtcbiAgICB9XG4gIH1cbn07XG52YXIgU3Vic2NyaXB0aW9uID0gY2xhc3Mge1xuICByZWxheTtcbiAgaWQ7XG4gIGNsb3NlZCA9IGZhbHNlO1xuICBlb3NlZCA9IGZhbHNlO1xuICBmaWx0ZXJzO1xuICBhbHJlYWR5SGF2ZUV2ZW50O1xuICByZWNlaXZlZEV2ZW50O1xuICBvbmV2ZW50O1xuICBvbmVvc2U7XG4gIG9uY2xvc2U7XG4gIGVvc2VUaW1lb3V0O1xuICBlb3NlVGltZW91dEhhbmRsZTtcbiAgY29uc3RydWN0b3IocmVsYXksIGlkLCBmaWx0ZXJzLCBwYXJhbXMpIHtcbiAgICB0aGlzLnJlbGF5ID0gcmVsYXk7XG4gICAgdGhpcy5maWx0ZXJzID0gZmlsdGVycztcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5hbHJlYWR5SGF2ZUV2ZW50ID0gcGFyYW1zLmFscmVhZHlIYXZlRXZlbnQ7XG4gICAgdGhpcy5yZWNlaXZlZEV2ZW50ID0gcGFyYW1zLnJlY2VpdmVkRXZlbnQ7XG4gICAgdGhpcy5lb3NlVGltZW91dCA9IHBhcmFtcy5lb3NlVGltZW91dCB8fCByZWxheS5iYXNlRW9zZVRpbWVvdXQ7XG4gICAgdGhpcy5vbmVvc2UgPSBwYXJhbXMub25lb3NlO1xuICAgIHRoaXMub25jbG9zZSA9IHBhcmFtcy5vbmNsb3NlO1xuICAgIHRoaXMub25ldmVudCA9IHBhcmFtcy5vbmV2ZW50IHx8ICgoZXZlbnQpID0+IHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYG9uZXZlbnQoKSBjYWxsYmFjayBub3QgZGVmaW5lZCBmb3Igc3Vic2NyaXB0aW9uICcke3RoaXMuaWR9JyBpbiByZWxheSAke3RoaXMucmVsYXkudXJsfS4gZXZlbnQgcmVjZWl2ZWQ6YCxcbiAgICAgICAgZXZlbnRcbiAgICAgICk7XG4gICAgfSk7XG4gIH1cbiAgZmlyZSgpIHtcbiAgICB0aGlzLnJlbGF5LnNlbmQoJ1tcIlJFUVwiLFwiJyArIHRoaXMuaWQgKyAnXCIsJyArIEpTT04uc3RyaW5naWZ5KHRoaXMuZmlsdGVycykuc3Vic3RyaW5nKDEpKTtcbiAgICB0aGlzLmVvc2VUaW1lb3V0SGFuZGxlID0gc2V0VGltZW91dCh0aGlzLnJlY2VpdmVkRW9zZS5iaW5kKHRoaXMpLCB0aGlzLmVvc2VUaW1lb3V0KTtcbiAgfVxuICByZWNlaXZlZEVvc2UoKSB7XG4gICAgaWYgKHRoaXMuZW9zZWQpXG4gICAgICByZXR1cm47XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuZW9zZVRpbWVvdXRIYW5kbGUpO1xuICAgIHRoaXMuZW9zZWQgPSB0cnVlO1xuICAgIHRoaXMub25lb3NlPy4oKTtcbiAgfVxuICBjbG9zZShyZWFzb24gPSBcImNsb3NlZCBieSBjYWxsZXJcIikge1xuICAgIGlmICghdGhpcy5jbG9zZWQgJiYgdGhpcy5yZWxheS5jb25uZWN0ZWQpIHtcbiAgICAgIHRoaXMucmVsYXkuc2VuZCgnW1wiQ0xPU0VcIiwnICsgSlNPTi5zdHJpbmdpZnkodGhpcy5pZCkgKyBcIl1cIik7XG4gICAgICB0aGlzLmNsb3NlZCA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMucmVsYXkub3BlblN1YnMuZGVsZXRlKHRoaXMuaWQpO1xuICAgIHRoaXMub25jbG9zZT8uKHJlYXNvbik7XG4gIH1cbn07XG5cbi8vIHJlbGF5LnRzXG52YXIgX1dlYlNvY2tldDtcbnRyeSB7XG4gIF9XZWJTb2NrZXQgPSBXZWJTb2NrZXQ7XG59IGNhdGNoIHtcbn1cbnZhciBSZWxheSA9IGNsYXNzIGV4dGVuZHMgQWJzdHJhY3RSZWxheSB7XG4gIGNvbnN0cnVjdG9yKHVybCkge1xuICAgIHN1cGVyKHVybCwgeyB2ZXJpZnlFdmVudCwgd2Vic29ja2V0SW1wbGVtZW50YXRpb246IF9XZWJTb2NrZXQgfSk7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGNvbm5lY3QodXJsKSB7XG4gICAgY29uc3QgcmVsYXkgPSBuZXcgUmVsYXkodXJsKTtcbiAgICBhd2FpdCByZWxheS5jb25uZWN0KCk7XG4gICAgcmV0dXJuIHJlbGF5O1xuICB9XG59O1xuXG4vLyBhYnN0cmFjdC1wb29sLnRzXG52YXIgQWJzdHJhY3RTaW1wbGVQb29sID0gY2xhc3Mge1xuICByZWxheXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBzZWVuT24gPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB0cmFja1JlbGF5cyA9IGZhbHNlO1xuICB2ZXJpZnlFdmVudDtcbiAgdHJ1c3RlZFJlbGF5VVJMcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIF9XZWJTb2NrZXQ7XG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICB0aGlzLnZlcmlmeUV2ZW50ID0gb3B0cy52ZXJpZnlFdmVudDtcbiAgICB0aGlzLl9XZWJTb2NrZXQgPSBvcHRzLndlYnNvY2tldEltcGxlbWVudGF0aW9uO1xuICB9XG4gIGFzeW5jIGVuc3VyZVJlbGF5KHVybCwgcGFyYW1zKSB7XG4gICAgdXJsID0gbm9ybWFsaXplVVJMKHVybCk7XG4gICAgbGV0IHJlbGF5ID0gdGhpcy5yZWxheXMuZ2V0KHVybCk7XG4gICAgaWYgKCFyZWxheSkge1xuICAgICAgcmVsYXkgPSBuZXcgQWJzdHJhY3RSZWxheSh1cmwsIHtcbiAgICAgICAgdmVyaWZ5RXZlbnQ6IHRoaXMudHJ1c3RlZFJlbGF5VVJMcy5oYXModXJsKSA/IGFsd2F5c1RydWUgOiB0aGlzLnZlcmlmeUV2ZW50LFxuICAgICAgICB3ZWJzb2NrZXRJbXBsZW1lbnRhdGlvbjogdGhpcy5fV2ViU29ja2V0XG4gICAgICB9KTtcbiAgICAgIGlmIChwYXJhbXM/LmNvbm5lY3Rpb25UaW1lb3V0KVxuICAgICAgICByZWxheS5jb25uZWN0aW9uVGltZW91dCA9IHBhcmFtcy5jb25uZWN0aW9uVGltZW91dDtcbiAgICAgIHRoaXMucmVsYXlzLnNldCh1cmwsIHJlbGF5KTtcbiAgICB9XG4gICAgYXdhaXQgcmVsYXkuY29ubmVjdCgpO1xuICAgIHJldHVybiByZWxheTtcbiAgfVxuICBjbG9zZShyZWxheXMpIHtcbiAgICByZWxheXMubWFwKG5vcm1hbGl6ZVVSTCkuZm9yRWFjaCgodXJsKSA9PiB7XG4gICAgICB0aGlzLnJlbGF5cy5nZXQodXJsKT8uY2xvc2UoKTtcbiAgICB9KTtcbiAgfVxuICBzdWJzY3JpYmVNYW55KHJlbGF5cywgZmlsdGVycywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIHRoaXMuc3Vic2NyaWJlTWFueU1hcChPYmplY3QuZnJvbUVudHJpZXMocmVsYXlzLm1hcCgodXJsKSA9PiBbdXJsLCBmaWx0ZXJzXSkpLCBwYXJhbXMpO1xuICB9XG4gIHN1YnNjcmliZU1hbnlNYXAocmVxdWVzdHMsIHBhcmFtcykge1xuICAgIGlmICh0aGlzLnRyYWNrUmVsYXlzKSB7XG4gICAgICBwYXJhbXMucmVjZWl2ZWRFdmVudCA9IChyZWxheSwgaWQpID0+IHtcbiAgICAgICAgbGV0IHNldCA9IHRoaXMuc2Vlbk9uLmdldChpZCk7XG4gICAgICAgIGlmICghc2V0KSB7XG4gICAgICAgICAgc2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgICAgICB0aGlzLnNlZW5Pbi5zZXQoaWQsIHNldCk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0LmFkZChyZWxheSk7XG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBfa25vd25JZHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGNvbnN0IHN1YnMgPSBbXTtcbiAgICBjb25zdCByZWxheXNMZW5ndGggPSBPYmplY3Qua2V5cyhyZXF1ZXN0cykubGVuZ3RoO1xuICAgIGNvbnN0IGVvc2VzUmVjZWl2ZWQgPSBbXTtcbiAgICBsZXQgaGFuZGxlRW9zZSA9IChpMikgPT4ge1xuICAgICAgZW9zZXNSZWNlaXZlZFtpMl0gPSB0cnVlO1xuICAgICAgaWYgKGVvc2VzUmVjZWl2ZWQuZmlsdGVyKChhKSA9PiBhKS5sZW5ndGggPT09IHJlbGF5c0xlbmd0aCkge1xuICAgICAgICBwYXJhbXMub25lb3NlPy4oKTtcbiAgICAgICAgaGFuZGxlRW9zZSA9ICgpID0+IHtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGNsb3Nlc1JlY2VpdmVkID0gW107XG4gICAgbGV0IGhhbmRsZUNsb3NlID0gKGkyLCByZWFzb24pID0+IHtcbiAgICAgIGhhbmRsZUVvc2UoaTIpO1xuICAgICAgY2xvc2VzUmVjZWl2ZWRbaTJdID0gcmVhc29uO1xuICAgICAgaWYgKGNsb3Nlc1JlY2VpdmVkLmZpbHRlcigoYSkgPT4gYSkubGVuZ3RoID09PSByZWxheXNMZW5ndGgpIHtcbiAgICAgICAgcGFyYW1zLm9uY2xvc2U/LihjbG9zZXNSZWNlaXZlZCk7XG4gICAgICAgIGhhbmRsZUNsb3NlID0gKCkgPT4ge1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgbG9jYWxBbHJlYWR5SGF2ZUV2ZW50SGFuZGxlciA9IChpZCkgPT4ge1xuICAgICAgaWYgKHBhcmFtcy5hbHJlYWR5SGF2ZUV2ZW50Py4oaWQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgaGF2ZSA9IF9rbm93bklkcy5oYXMoaWQpO1xuICAgICAgX2tub3duSWRzLmFkZChpZCk7XG4gICAgICByZXR1cm4gaGF2ZTtcbiAgICB9O1xuICAgIGNvbnN0IGFsbE9wZW5lZCA9IFByb21pc2UuYWxsKFxuICAgICAgT2JqZWN0LmVudHJpZXMocmVxdWVzdHMpLm1hcChhc3luYyAocmVxLCBpMiwgYXJyKSA9PiB7XG4gICAgICAgIGlmIChhcnIuaW5kZXhPZihyZXEpICE9PSBpMikge1xuICAgICAgICAgIGhhbmRsZUNsb3NlKGkyLCBcImR1cGxpY2F0ZSB1cmxcIik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBbdXJsLCBmaWx0ZXJzXSA9IHJlcTtcbiAgICAgICAgdXJsID0gbm9ybWFsaXplVVJMKHVybCk7XG4gICAgICAgIGxldCByZWxheTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZWxheSA9IGF3YWl0IHRoaXMuZW5zdXJlUmVsYXkodXJsLCB7XG4gICAgICAgICAgICBjb25uZWN0aW9uVGltZW91dDogcGFyYW1zLm1heFdhaXQgPyBNYXRoLm1heChwYXJhbXMubWF4V2FpdCAqIDAuOCwgcGFyYW1zLm1heFdhaXQgLSAxZTMpIDogdm9pZCAwXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGhhbmRsZUNsb3NlKGkyLCBlcnI/Lm1lc3NhZ2UgfHwgU3RyaW5nKGVycikpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3Vic2NyaXB0aW9uID0gcmVsYXkuc3Vic2NyaWJlKGZpbHRlcnMsIHtcbiAgICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgICAgb25lb3NlOiAoKSA9PiBoYW5kbGVFb3NlKGkyKSxcbiAgICAgICAgICBvbmNsb3NlOiAocmVhc29uKSA9PiBoYW5kbGVDbG9zZShpMiwgcmVhc29uKSxcbiAgICAgICAgICBhbHJlYWR5SGF2ZUV2ZW50OiBsb2NhbEFscmVhZHlIYXZlRXZlbnRIYW5kbGVyLFxuICAgICAgICAgIGVvc2VUaW1lb3V0OiBwYXJhbXMubWF4V2FpdFxuICAgICAgICB9KTtcbiAgICAgICAgc3Vicy5wdXNoKHN1YnNjcmlwdGlvbik7XG4gICAgICB9KVxuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFzeW5jIGNsb3NlKCkge1xuICAgICAgICBhd2FpdCBhbGxPcGVuZWQ7XG4gICAgICAgIHN1YnMuZm9yRWFjaCgoc3ViKSA9PiB7XG4gICAgICAgICAgc3ViLmNsb3NlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgc3Vic2NyaWJlTWFueUVvc2UocmVsYXlzLCBmaWx0ZXJzLCBwYXJhbXMpIHtcbiAgICBjb25zdCBzdWJjbG9zZXIgPSB0aGlzLnN1YnNjcmliZU1hbnkocmVsYXlzLCBmaWx0ZXJzLCB7XG4gICAgICAuLi5wYXJhbXMsXG4gICAgICBvbmVvc2UoKSB7XG4gICAgICAgIHN1YmNsb3Nlci5jbG9zZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzdWJjbG9zZXI7XG4gIH1cbiAgYXN5bmMgcXVlcnlTeW5jKHJlbGF5cywgZmlsdGVyLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUpID0+IHtcbiAgICAgIGNvbnN0IGV2ZW50cyA9IFtdO1xuICAgICAgdGhpcy5zdWJzY3JpYmVNYW55RW9zZShyZWxheXMsIFtmaWx0ZXJdLCB7XG4gICAgICAgIC4uLnBhcmFtcyxcbiAgICAgICAgb25ldmVudChldmVudCkge1xuICAgICAgICAgIGV2ZW50cy5wdXNoKGV2ZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25jbG9zZShfKSB7XG4gICAgICAgICAgcmVzb2x2ZShldmVudHMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBnZXQocmVsYXlzLCBmaWx0ZXIsIHBhcmFtcykge1xuICAgIGZpbHRlci5saW1pdCA9IDE7XG4gICAgY29uc3QgZXZlbnRzID0gYXdhaXQgdGhpcy5xdWVyeVN5bmMocmVsYXlzLCBmaWx0ZXIsIHBhcmFtcyk7XG4gICAgZXZlbnRzLnNvcnQoKGEsIGIpID0+IGIuY3JlYXRlZF9hdCAtIGEuY3JlYXRlZF9hdCk7XG4gICAgcmV0dXJuIGV2ZW50c1swXSB8fCBudWxsO1xuICB9XG4gIHB1Ymxpc2gocmVsYXlzLCBldmVudCkge1xuICAgIHJldHVybiByZWxheXMubWFwKG5vcm1hbGl6ZVVSTCkubWFwKGFzeW5jICh1cmwsIGkyLCBhcnIpID0+IHtcbiAgICAgIGlmIChhcnIuaW5kZXhPZih1cmwpICE9PSBpMikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXCJkdXBsaWNhdGUgdXJsXCIpO1xuICAgICAgfVxuICAgICAgbGV0IHIgPSBhd2FpdCB0aGlzLmVuc3VyZVJlbGF5KHVybCk7XG4gICAgICByZXR1cm4gci5wdWJsaXNoKGV2ZW50KS50aGVuKChyZWFzb24pID0+IHtcbiAgICAgICAgaWYgKHRoaXMudHJhY2tSZWxheXMpIHtcbiAgICAgICAgICBsZXQgc2V0ID0gdGhpcy5zZWVuT24uZ2V0KGV2ZW50LmlkKTtcbiAgICAgICAgICBpZiAoIXNldCkge1xuICAgICAgICAgICAgc2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgICAgICAgIHRoaXMuc2Vlbk9uLnNldChldmVudC5pZCwgc2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2V0LmFkZChyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVhc29uO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgbGlzdENvbm5lY3Rpb25TdGF0dXMoKSB7XG4gICAgY29uc3QgbWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLnJlbGF5cy5mb3JFYWNoKChyZWxheSwgdXJsKSA9PiBtYXAuc2V0KHVybCwgcmVsYXkuY29ubmVjdGVkKSk7XG4gICAgcmV0dXJuIG1hcDtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMucmVsYXlzLmZvckVhY2goKGNvbm4pID0+IGNvbm4uY2xvc2UoKSk7XG4gICAgdGhpcy5yZWxheXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG59O1xuXG4vLyBwb29sLnRzXG52YXIgX1dlYlNvY2tldDI7XG50cnkge1xuICBfV2ViU29ja2V0MiA9IFdlYlNvY2tldDtcbn0gY2F0Y2gge1xufVxudmFyIFNpbXBsZVBvb2wgPSBjbGFzcyBleHRlbmRzIEFic3RyYWN0U2ltcGxlUG9vbCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKHsgdmVyaWZ5RXZlbnQsIHdlYnNvY2tldEltcGxlbWVudGF0aW9uOiBfV2ViU29ja2V0MiB9KTtcbiAgfVxufTtcblxuLy8gbmlwMTkudHNcbnZhciBuaXAxOV9leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXAxOV9leHBvcnRzLCB7XG4gIEJFQ0gzMl9SRUdFWDogKCkgPT4gQkVDSDMyX1JFR0VYLFxuICBCZWNoMzJNYXhTaXplOiAoKSA9PiBCZWNoMzJNYXhTaXplLFxuICBOb3N0clR5cGVHdWFyZDogKCkgPT4gTm9zdHJUeXBlR3VhcmQsXG4gIGRlY29kZTogKCkgPT4gZGVjb2RlLFxuICBlbmNvZGVCeXRlczogKCkgPT4gZW5jb2RlQnl0ZXMsXG4gIG5hZGRyRW5jb2RlOiAoKSA9PiBuYWRkckVuY29kZSxcbiAgbmV2ZW50RW5jb2RlOiAoKSA9PiBuZXZlbnRFbmNvZGUsXG4gIG5vdGVFbmNvZGU6ICgpID0+IG5vdGVFbmNvZGUsXG4gIG5wcm9maWxlRW5jb2RlOiAoKSA9PiBucHJvZmlsZUVuY29kZSxcbiAgbnB1YkVuY29kZTogKCkgPT4gbnB1YkVuY29kZSxcbiAgbnNlY0VuY29kZTogKCkgPT4gbnNlY0VuY29kZVxufSk7XG5pbXBvcnQgeyBieXRlc1RvSGV4IGFzIGJ5dGVzVG9IZXgyLCBjb25jYXRCeXRlcywgaGV4VG9CeXRlcyB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3V0aWxzXCI7XG5pbXBvcnQgeyBiZWNoMzIgfSBmcm9tIFwiQHNjdXJlL2Jhc2VcIjtcbnZhciBOb3N0clR5cGVHdWFyZCA9IHtcbiAgaXNOUHJvZmlsZTogKHZhbHVlKSA9PiAvXm5wcm9maWxlMVthLXpcXGRdKyQvLnRlc3QodmFsdWUgfHwgXCJcIiksXG4gIGlzTkV2ZW50OiAodmFsdWUpID0+IC9ebmV2ZW50MVthLXpcXGRdKyQvLnRlc3QodmFsdWUgfHwgXCJcIiksXG4gIGlzTkFkZHI6ICh2YWx1ZSkgPT4gL15uYWRkcjFbYS16XFxkXSskLy50ZXN0KHZhbHVlIHx8IFwiXCIpLFxuICBpc05TZWM6ICh2YWx1ZSkgPT4gL15uc2VjMVthLXpcXGRdezU4fSQvLnRlc3QodmFsdWUgfHwgXCJcIiksXG4gIGlzTlB1YjogKHZhbHVlKSA9PiAvXm5wdWIxW2EtelxcZF17NTh9JC8udGVzdCh2YWx1ZSB8fCBcIlwiKSxcbiAgaXNOb3RlOiAodmFsdWUpID0+IC9ebm90ZTFbYS16XFxkXSskLy50ZXN0KHZhbHVlIHx8IFwiXCIpLFxuICBpc05jcnlwdHNlYzogKHZhbHVlKSA9PiAvXm5jcnlwdHNlYzFbYS16XFxkXSskLy50ZXN0KHZhbHVlIHx8IFwiXCIpXG59O1xudmFyIEJlY2gzMk1heFNpemUgPSA1ZTM7XG52YXIgQkVDSDMyX1JFR0VYID0gL1tcXHgyMS1cXHg3RV17MSw4M30xWzAyMzQ1Njc4OWFjZGVmZ2hqa2xtbnBxcnN0dXZ3eHl6XXs2LH0vO1xuZnVuY3Rpb24gaW50ZWdlclRvVWludDhBcnJheShudW1iZXIpIHtcbiAgY29uc3QgdWludDhBcnJheSA9IG5ldyBVaW50OEFycmF5KDQpO1xuICB1aW50OEFycmF5WzBdID0gbnVtYmVyID4+IDI0ICYgMjU1O1xuICB1aW50OEFycmF5WzFdID0gbnVtYmVyID4+IDE2ICYgMjU1O1xuICB1aW50OEFycmF5WzJdID0gbnVtYmVyID4+IDggJiAyNTU7XG4gIHVpbnQ4QXJyYXlbM10gPSBudW1iZXIgJiAyNTU7XG4gIHJldHVybiB1aW50OEFycmF5O1xufVxuZnVuY3Rpb24gZGVjb2RlKG5pcDE5KSB7XG4gIGxldCB7IHByZWZpeCwgd29yZHMgfSA9IGJlY2gzMi5kZWNvZGUobmlwMTksIEJlY2gzMk1heFNpemUpO1xuICBsZXQgZGF0YSA9IG5ldyBVaW50OEFycmF5KGJlY2gzMi5mcm9tV29yZHMod29yZHMpKTtcbiAgc3dpdGNoIChwcmVmaXgpIHtcbiAgICBjYXNlIFwibnByb2ZpbGVcIjoge1xuICAgICAgbGV0IHRsdiA9IHBhcnNlVExWKGRhdGEpO1xuICAgICAgaWYgKCF0bHZbMF0/LlswXSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBUTFYgMCBmb3IgbnByb2ZpbGVcIik7XG4gICAgICBpZiAodGx2WzBdWzBdLmxlbmd0aCAhPT0gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRMViAwIHNob3VsZCBiZSAzMiBieXRlc1wiKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwibnByb2ZpbGVcIixcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHB1YmtleTogYnl0ZXNUb0hleDIodGx2WzBdWzBdKSxcbiAgICAgICAgICByZWxheXM6IHRsdlsxXSA/IHRsdlsxXS5tYXAoKGQpID0+IHV0ZjhEZWNvZGVyLmRlY29kZShkKSkgOiBbXVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFwibmV2ZW50XCI6IHtcbiAgICAgIGxldCB0bHYgPSBwYXJzZVRMVihkYXRhKTtcbiAgICAgIGlmICghdGx2WzBdPy5bMF0pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgVExWIDAgZm9yIG5ldmVudFwiKTtcbiAgICAgIGlmICh0bHZbMF1bMF0ubGVuZ3RoICE9PSAzMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVExWIDAgc2hvdWxkIGJlIDMyIGJ5dGVzXCIpO1xuICAgICAgaWYgKHRsdlsyXSAmJiB0bHZbMl1bMF0ubGVuZ3RoICE9PSAzMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVExWIDIgc2hvdWxkIGJlIDMyIGJ5dGVzXCIpO1xuICAgICAgaWYgKHRsdlszXSAmJiB0bHZbM11bMF0ubGVuZ3RoICE9PSA0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUTFYgMyBzaG91bGQgYmUgNCBieXRlc1wiKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwibmV2ZW50XCIsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBpZDogYnl0ZXNUb0hleDIodGx2WzBdWzBdKSxcbiAgICAgICAgICByZWxheXM6IHRsdlsxXSA/IHRsdlsxXS5tYXAoKGQpID0+IHV0ZjhEZWNvZGVyLmRlY29kZShkKSkgOiBbXSxcbiAgICAgICAgICBhdXRob3I6IHRsdlsyXT8uWzBdID8gYnl0ZXNUb0hleDIodGx2WzJdWzBdKSA6IHZvaWQgMCxcbiAgICAgICAgICBraW5kOiB0bHZbM10/LlswXSA/IHBhcnNlSW50KGJ5dGVzVG9IZXgyKHRsdlszXVswXSksIDE2KSA6IHZvaWQgMFxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFwibmFkZHJcIjoge1xuICAgICAgbGV0IHRsdiA9IHBhcnNlVExWKGRhdGEpO1xuICAgICAgaWYgKCF0bHZbMF0/LlswXSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBUTFYgMCBmb3IgbmFkZHJcIik7XG4gICAgICBpZiAoIXRsdlsyXT8uWzBdKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIFRMViAyIGZvciBuYWRkclwiKTtcbiAgICAgIGlmICh0bHZbMl1bMF0ubGVuZ3RoICE9PSAzMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVExWIDIgc2hvdWxkIGJlIDMyIGJ5dGVzXCIpO1xuICAgICAgaWYgKCF0bHZbM10/LlswXSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBUTFYgMyBmb3IgbmFkZHJcIik7XG4gICAgICBpZiAodGx2WzNdWzBdLmxlbmd0aCAhPT0gNClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVExWIDMgc2hvdWxkIGJlIDQgYnl0ZXNcIik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIm5hZGRyXCIsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBpZGVudGlmaWVyOiB1dGY4RGVjb2Rlci5kZWNvZGUodGx2WzBdWzBdKSxcbiAgICAgICAgICBwdWJrZXk6IGJ5dGVzVG9IZXgyKHRsdlsyXVswXSksXG4gICAgICAgICAga2luZDogcGFyc2VJbnQoYnl0ZXNUb0hleDIodGx2WzNdWzBdKSwgMTYpLFxuICAgICAgICAgIHJlbGF5czogdGx2WzFdID8gdGx2WzFdLm1hcCgoZCkgPT4gdXRmOERlY29kZXIuZGVjb2RlKGQpKSA6IFtdXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgXCJuc2VjXCI6XG4gICAgICByZXR1cm4geyB0eXBlOiBwcmVmaXgsIGRhdGEgfTtcbiAgICBjYXNlIFwibnB1YlwiOlxuICAgIGNhc2UgXCJub3RlXCI6XG4gICAgICByZXR1cm4geyB0eXBlOiBwcmVmaXgsIGRhdGE6IGJ5dGVzVG9IZXgyKGRhdGEpIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5rbm93biBwcmVmaXggJHtwcmVmaXh9YCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnNlVExWKGRhdGEpIHtcbiAgbGV0IHJlc3VsdCA9IHt9O1xuICBsZXQgcmVzdCA9IGRhdGE7XG4gIHdoaWxlIChyZXN0Lmxlbmd0aCA+IDApIHtcbiAgICBsZXQgdCA9IHJlc3RbMF07XG4gICAgbGV0IGwgPSByZXN0WzFdO1xuICAgIGxldCB2ID0gcmVzdC5zbGljZSgyLCAyICsgbCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMiArIGwpO1xuICAgIGlmICh2Lmxlbmd0aCA8IGwpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYG5vdCBlbm91Z2ggZGF0YSB0byByZWFkIG9uIFRMViAke3R9YCk7XG4gICAgcmVzdWx0W3RdID0gcmVzdWx0W3RdIHx8IFtdO1xuICAgIHJlc3VsdFt0XS5wdXNoKHYpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBuc2VjRW5jb2RlKGtleSkge1xuICByZXR1cm4gZW5jb2RlQnl0ZXMoXCJuc2VjXCIsIGtleSk7XG59XG5mdW5jdGlvbiBucHViRW5jb2RlKGhleCkge1xuICByZXR1cm4gZW5jb2RlQnl0ZXMoXCJucHViXCIsIGhleFRvQnl0ZXMoaGV4KSk7XG59XG5mdW5jdGlvbiBub3RlRW5jb2RlKGhleCkge1xuICByZXR1cm4gZW5jb2RlQnl0ZXMoXCJub3RlXCIsIGhleFRvQnl0ZXMoaGV4KSk7XG59XG5mdW5jdGlvbiBlbmNvZGVCZWNoMzIocHJlZml4LCBkYXRhKSB7XG4gIGxldCB3b3JkcyA9IGJlY2gzMi50b1dvcmRzKGRhdGEpO1xuICByZXR1cm4gYmVjaDMyLmVuY29kZShwcmVmaXgsIHdvcmRzLCBCZWNoMzJNYXhTaXplKTtcbn1cbmZ1bmN0aW9uIGVuY29kZUJ5dGVzKHByZWZpeCwgYnl0ZXMpIHtcbiAgcmV0dXJuIGVuY29kZUJlY2gzMihwcmVmaXgsIGJ5dGVzKTtcbn1cbmZ1bmN0aW9uIG5wcm9maWxlRW5jb2RlKHByb2ZpbGUpIHtcbiAgbGV0IGRhdGEgPSBlbmNvZGVUTFYoe1xuICAgIDA6IFtoZXhUb0J5dGVzKHByb2ZpbGUucHVia2V5KV0sXG4gICAgMTogKHByb2ZpbGUucmVsYXlzIHx8IFtdKS5tYXAoKHVybCkgPT4gdXRmOEVuY29kZXIuZW5jb2RlKHVybCkpXG4gIH0pO1xuICByZXR1cm4gZW5jb2RlQmVjaDMyKFwibnByb2ZpbGVcIiwgZGF0YSk7XG59XG5mdW5jdGlvbiBuZXZlbnRFbmNvZGUoZXZlbnQpIHtcbiAgbGV0IGtpbmRBcnJheTtcbiAgaWYgKGV2ZW50LmtpbmQgIT09IHZvaWQgMCkge1xuICAgIGtpbmRBcnJheSA9IGludGVnZXJUb1VpbnQ4QXJyYXkoZXZlbnQua2luZCk7XG4gIH1cbiAgbGV0IGRhdGEgPSBlbmNvZGVUTFYoe1xuICAgIDA6IFtoZXhUb0J5dGVzKGV2ZW50LmlkKV0sXG4gICAgMTogKGV2ZW50LnJlbGF5cyB8fCBbXSkubWFwKCh1cmwpID0+IHV0ZjhFbmNvZGVyLmVuY29kZSh1cmwpKSxcbiAgICAyOiBldmVudC5hdXRob3IgPyBbaGV4VG9CeXRlcyhldmVudC5hdXRob3IpXSA6IFtdLFxuICAgIDM6IGtpbmRBcnJheSA/IFtuZXcgVWludDhBcnJheShraW5kQXJyYXkpXSA6IFtdXG4gIH0pO1xuICByZXR1cm4gZW5jb2RlQmVjaDMyKFwibmV2ZW50XCIsIGRhdGEpO1xufVxuZnVuY3Rpb24gbmFkZHJFbmNvZGUoYWRkcikge1xuICBsZXQga2luZCA9IG5ldyBBcnJheUJ1ZmZlcig0KTtcbiAgbmV3IERhdGFWaWV3KGtpbmQpLnNldFVpbnQzMigwLCBhZGRyLmtpbmQsIGZhbHNlKTtcbiAgbGV0IGRhdGEgPSBlbmNvZGVUTFYoe1xuICAgIDA6IFt1dGY4RW5jb2Rlci5lbmNvZGUoYWRkci5pZGVudGlmaWVyKV0sXG4gICAgMTogKGFkZHIucmVsYXlzIHx8IFtdKS5tYXAoKHVybCkgPT4gdXRmOEVuY29kZXIuZW5jb2RlKHVybCkpLFxuICAgIDI6IFtoZXhUb0J5dGVzKGFkZHIucHVia2V5KV0sXG4gICAgMzogW25ldyBVaW50OEFycmF5KGtpbmQpXVxuICB9KTtcbiAgcmV0dXJuIGVuY29kZUJlY2gzMihcIm5hZGRyXCIsIGRhdGEpO1xufVxuZnVuY3Rpb24gZW5jb2RlVExWKHRsdikge1xuICBsZXQgZW50cmllcyA9IFtdO1xuICBPYmplY3QuZW50cmllcyh0bHYpLnJldmVyc2UoKS5mb3JFYWNoKChbdCwgdnNdKSA9PiB7XG4gICAgdnMuZm9yRWFjaCgodikgPT4ge1xuICAgICAgbGV0IGVudHJ5ID0gbmV3IFVpbnQ4QXJyYXkodi5sZW5ndGggKyAyKTtcbiAgICAgIGVudHJ5LnNldChbcGFyc2VJbnQodCldLCAwKTtcbiAgICAgIGVudHJ5LnNldChbdi5sZW5ndGhdLCAxKTtcbiAgICAgIGVudHJ5LnNldCh2LCAyKTtcbiAgICAgIGVudHJpZXMucHVzaChlbnRyeSk7XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gY29uY2F0Qnl0ZXMoLi4uZW50cmllcyk7XG59XG5cbi8vIHJlZmVyZW5jZXMudHNcbnZhciBtZW50aW9uUmVnZXggPSAvXFxibm9zdHI6KChub3RlfG5wdWJ8bmFkZHJ8bmV2ZW50fG5wcm9maWxlKTFcXHcrKVxcYnwjXFxbKFxcZCspXFxdL2c7XG5mdW5jdGlvbiBwYXJzZVJlZmVyZW5jZXMoZXZ0KSB7XG4gIGxldCByZWZlcmVuY2VzID0gW107XG4gIGZvciAobGV0IHJlZiBvZiBldnQuY29udGVudC5tYXRjaEFsbChtZW50aW9uUmVnZXgpKSB7XG4gICAgaWYgKHJlZlsyXSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IHsgdHlwZSwgZGF0YSB9ID0gZGVjb2RlKHJlZlsxXSk7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgXCJucHViXCI6IHtcbiAgICAgICAgICAgIHJlZmVyZW5jZXMucHVzaCh7XG4gICAgICAgICAgICAgIHRleHQ6IHJlZlswXSxcbiAgICAgICAgICAgICAgcHJvZmlsZTogeyBwdWJrZXk6IGRhdGEsIHJlbGF5czogW10gfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIm5wcm9maWxlXCI6IHtcbiAgICAgICAgICAgIHJlZmVyZW5jZXMucHVzaCh7XG4gICAgICAgICAgICAgIHRleHQ6IHJlZlswXSxcbiAgICAgICAgICAgICAgcHJvZmlsZTogZGF0YVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIm5vdGVcIjoge1xuICAgICAgICAgICAgcmVmZXJlbmNlcy5wdXNoKHtcbiAgICAgICAgICAgICAgdGV4dDogcmVmWzBdLFxuICAgICAgICAgICAgICBldmVudDogeyBpZDogZGF0YSwgcmVsYXlzOiBbXSB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwibmV2ZW50XCI6IHtcbiAgICAgICAgICAgIHJlZmVyZW5jZXMucHVzaCh7XG4gICAgICAgICAgICAgIHRleHQ6IHJlZlswXSxcbiAgICAgICAgICAgICAgZXZlbnQ6IGRhdGFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJuYWRkclwiOiB7XG4gICAgICAgICAgICByZWZlcmVuY2VzLnB1c2goe1xuICAgICAgICAgICAgICB0ZXh0OiByZWZbMF0sXG4gICAgICAgICAgICAgIGFkZHJlc3M6IGRhdGFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJlZlszXSkge1xuICAgICAgbGV0IGlkeCA9IHBhcnNlSW50KHJlZlszXSwgMTApO1xuICAgICAgbGV0IHRhZyA9IGV2dC50YWdzW2lkeF07XG4gICAgICBpZiAoIXRhZylcbiAgICAgICAgY29udGludWU7XG4gICAgICBzd2l0Y2ggKHRhZ1swXSkge1xuICAgICAgICBjYXNlIFwicFwiOiB7XG4gICAgICAgICAgcmVmZXJlbmNlcy5wdXNoKHtcbiAgICAgICAgICAgIHRleHQ6IHJlZlswXSxcbiAgICAgICAgICAgIHByb2ZpbGU6IHsgcHVia2V5OiB0YWdbMV0sIHJlbGF5czogdGFnWzJdID8gW3RhZ1syXV0gOiBbXSB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImVcIjoge1xuICAgICAgICAgIHJlZmVyZW5jZXMucHVzaCh7XG4gICAgICAgICAgICB0ZXh0OiByZWZbMF0sXG4gICAgICAgICAgICBldmVudDogeyBpZDogdGFnWzFdLCByZWxheXM6IHRhZ1syXSA/IFt0YWdbMl1dIDogW10gfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJhXCI6IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IFtraW5kLCBwdWJrZXksIGlkZW50aWZpZXJdID0gdGFnWzFdLnNwbGl0KFwiOlwiKTtcbiAgICAgICAgICAgIHJlZmVyZW5jZXMucHVzaCh7XG4gICAgICAgICAgICAgIHRleHQ6IHJlZlswXSxcbiAgICAgICAgICAgICAgYWRkcmVzczoge1xuICAgICAgICAgICAgICAgIGlkZW50aWZpZXIsXG4gICAgICAgICAgICAgICAgcHVia2V5LFxuICAgICAgICAgICAgICAgIGtpbmQ6IHBhcnNlSW50KGtpbmQsIDEwKSxcbiAgICAgICAgICAgICAgICByZWxheXM6IHRhZ1syXSA/IFt0YWdbMl1dIDogW11cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZWZlcmVuY2VzO1xufVxuXG4vLyBuaXAwNC50c1xudmFyIG5pcDA0X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDA0X2V4cG9ydHMsIHtcbiAgZGVjcnlwdDogKCkgPT4gZGVjcnlwdCxcbiAgZW5jcnlwdDogKCkgPT4gZW5jcnlwdFxufSk7XG5pbXBvcnQgeyBieXRlc1RvSGV4IGFzIGJ5dGVzVG9IZXgzLCByYW5kb21CeXRlcyB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3V0aWxzXCI7XG5pbXBvcnQgeyBzZWNwMjU2azEgfSBmcm9tIFwiQG5vYmxlL2N1cnZlcy9zZWNwMjU2azFcIjtcbmltcG9ydCB7IGNiYyB9IGZyb20gXCJAbm9ibGUvY2lwaGVycy9hZXNcIjtcbmltcG9ydCB7IGJhc2U2NCB9IGZyb20gXCJAc2N1cmUvYmFzZVwiO1xuYXN5bmMgZnVuY3Rpb24gZW5jcnlwdChzZWNyZXRLZXksIHB1YmtleSwgdGV4dCkge1xuICBjb25zdCBwcml2a2V5ID0gc2VjcmV0S2V5IGluc3RhbmNlb2YgVWludDhBcnJheSA/IGJ5dGVzVG9IZXgzKHNlY3JldEtleSkgOiBzZWNyZXRLZXk7XG4gIGNvbnN0IGtleSA9IHNlY3AyNTZrMS5nZXRTaGFyZWRTZWNyZXQocHJpdmtleSwgXCIwMlwiICsgcHVia2V5KTtcbiAgY29uc3Qgbm9ybWFsaXplZEtleSA9IGdldE5vcm1hbGl6ZWRYKGtleSk7XG4gIGxldCBpdiA9IFVpbnQ4QXJyYXkuZnJvbShyYW5kb21CeXRlcygxNikpO1xuICBsZXQgcGxhaW50ZXh0ID0gdXRmOEVuY29kZXIuZW5jb2RlKHRleHQpO1xuICBsZXQgY2lwaGVydGV4dCA9IGNiYyhub3JtYWxpemVkS2V5LCBpdikuZW5jcnlwdChwbGFpbnRleHQpO1xuICBsZXQgY3RiNjQgPSBiYXNlNjQuZW5jb2RlKG5ldyBVaW50OEFycmF5KGNpcGhlcnRleHQpKTtcbiAgbGV0IGl2YjY0ID0gYmFzZTY0LmVuY29kZShuZXcgVWludDhBcnJheShpdi5idWZmZXIpKTtcbiAgcmV0dXJuIGAke2N0YjY0fT9pdj0ke2l2YjY0fWA7XG59XG5hc3luYyBmdW5jdGlvbiBkZWNyeXB0KHNlY3JldEtleSwgcHVia2V5LCBkYXRhKSB7XG4gIGNvbnN0IHByaXZrZXkgPSBzZWNyZXRLZXkgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gYnl0ZXNUb0hleDMoc2VjcmV0S2V5KSA6IHNlY3JldEtleTtcbiAgbGV0IFtjdGI2NCwgaXZiNjRdID0gZGF0YS5zcGxpdChcIj9pdj1cIik7XG4gIGxldCBrZXkgPSBzZWNwMjU2azEuZ2V0U2hhcmVkU2VjcmV0KHByaXZrZXksIFwiMDJcIiArIHB1YmtleSk7XG4gIGxldCBub3JtYWxpemVkS2V5ID0gZ2V0Tm9ybWFsaXplZFgoa2V5KTtcbiAgbGV0IGl2ID0gYmFzZTY0LmRlY29kZShpdmI2NCk7XG4gIGxldCBjaXBoZXJ0ZXh0ID0gYmFzZTY0LmRlY29kZShjdGI2NCk7XG4gIGxldCBwbGFpbnRleHQgPSBjYmMobm9ybWFsaXplZEtleSwgaXYpLmRlY3J5cHQoY2lwaGVydGV4dCk7XG4gIHJldHVybiB1dGY4RGVjb2Rlci5kZWNvZGUocGxhaW50ZXh0KTtcbn1cbmZ1bmN0aW9uIGdldE5vcm1hbGl6ZWRYKGtleSkge1xuICByZXR1cm4ga2V5LnNsaWNlKDEsIDMzKTtcbn1cblxuLy8gbmlwMDUudHNcbnZhciBuaXAwNV9leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXAwNV9leHBvcnRzLCB7XG4gIE5JUDA1X1JFR0VYOiAoKSA9PiBOSVAwNV9SRUdFWCxcbiAgaXNOaXAwNTogKCkgPT4gaXNOaXAwNSxcbiAgaXNWYWxpZDogKCkgPT4gaXNWYWxpZCxcbiAgcXVlcnlQcm9maWxlOiAoKSA9PiBxdWVyeVByb2ZpbGUsXG4gIHNlYXJjaERvbWFpbjogKCkgPT4gc2VhcmNoRG9tYWluLFxuICB1c2VGZXRjaEltcGxlbWVudGF0aW9uOiAoKSA9PiB1c2VGZXRjaEltcGxlbWVudGF0aW9uXG59KTtcbnZhciBOSVAwNV9SRUdFWCA9IC9eKD86KFtcXHcuKy1dKylAKT8oW1xcd18tXSsoXFwuW1xcd18tXSspKykkLztcbnZhciBpc05pcDA1ID0gKHZhbHVlKSA9PiBOSVAwNV9SRUdFWC50ZXN0KHZhbHVlIHx8IFwiXCIpO1xudmFyIF9mZXRjaDtcbnRyeSB7XG4gIF9mZXRjaCA9IGZldGNoO1xufSBjYXRjaCAoXykge1xuICBudWxsO1xufVxuZnVuY3Rpb24gdXNlRmV0Y2hJbXBsZW1lbnRhdGlvbihmZXRjaEltcGxlbWVudGF0aW9uKSB7XG4gIF9mZXRjaCA9IGZldGNoSW1wbGVtZW50YXRpb247XG59XG5hc3luYyBmdW5jdGlvbiBzZWFyY2hEb21haW4oZG9tYWluLCBxdWVyeSA9IFwiXCIpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCB1cmwgPSBgaHR0cHM6Ly8ke2RvbWFpbn0vLndlbGwta25vd24vbm9zdHIuanNvbj9uYW1lPSR7cXVlcnl9YDtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBfZmV0Y2godXJsLCB7IHJlZGlyZWN0OiBcIm1hbnVhbFwiIH0pO1xuICAgIGlmIChyZXMuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgIHRocm93IEVycm9yKFwiV3JvbmcgcmVzcG9uc2UgY29kZVwiKTtcbiAgICB9XG4gICAgY29uc3QganNvbiA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgcmV0dXJuIGpzb24ubmFtZXM7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4ge307XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHF1ZXJ5UHJvZmlsZShmdWxsbmFtZSkge1xuICBjb25zdCBtYXRjaCA9IGZ1bGxuYW1lLm1hdGNoKE5JUDA1X1JFR0VYKTtcbiAgaWYgKCFtYXRjaClcbiAgICByZXR1cm4gbnVsbDtcbiAgY29uc3QgWywgbmFtZSA9IFwiX1wiLCBkb21haW5dID0gbWF0Y2g7XG4gIHRyeSB7XG4gICAgY29uc3QgdXJsID0gYGh0dHBzOi8vJHtkb21haW59Ly53ZWxsLWtub3duL25vc3RyLmpzb24/bmFtZT0ke25hbWV9YDtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBfZmV0Y2godXJsLCB7IHJlZGlyZWN0OiBcIm1hbnVhbFwiIH0pO1xuICAgIGlmIChyZXMuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgIHRocm93IEVycm9yKFwiV3JvbmcgcmVzcG9uc2UgY29kZVwiKTtcbiAgICB9XG4gICAgY29uc3QganNvbiA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgY29uc3QgcHVia2V5ID0ganNvbi5uYW1lc1tuYW1lXTtcbiAgICByZXR1cm4gcHVia2V5ID8geyBwdWJrZXksIHJlbGF5czoganNvbi5yZWxheXM/LltwdWJrZXldIH0gOiBudWxsO1xuICB9IGNhdGNoIChfZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBpc1ZhbGlkKHB1YmtleSwgbmlwMDUpIHtcbiAgY29uc3QgcmVzID0gYXdhaXQgcXVlcnlQcm9maWxlKG5pcDA1KTtcbiAgcmV0dXJuIHJlcyA/IHJlcy5wdWJrZXkgPT09IHB1YmtleSA6IGZhbHNlO1xufVxuXG4vLyBuaXAxMC50c1xudmFyIG5pcDEwX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDEwX2V4cG9ydHMsIHtcbiAgcGFyc2U6ICgpID0+IHBhcnNlXG59KTtcbmZ1bmN0aW9uIHBhcnNlKGV2ZW50KSB7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICByZXBseTogdm9pZCAwLFxuICAgIHJvb3Q6IHZvaWQgMCxcbiAgICBtZW50aW9uczogW10sXG4gICAgcHJvZmlsZXM6IFtdLFxuICAgIHF1b3RlczogW11cbiAgfTtcbiAgbGV0IG1heWJlUGFyZW50O1xuICBsZXQgbWF5YmVSb290O1xuICBmb3IgKGxldCBpMiA9IGV2ZW50LnRhZ3MubGVuZ3RoIC0gMTsgaTIgPj0gMDsgaTItLSkge1xuICAgIGNvbnN0IHRhZyA9IGV2ZW50LnRhZ3NbaTJdO1xuICAgIGlmICh0YWdbMF0gPT09IFwiZVwiICYmIHRhZ1sxXSkge1xuICAgICAgY29uc3QgW18sIGVUYWdFdmVudElkLCBlVGFnUmVsYXlVcmwsIGVUYWdNYXJrZXIsIGVUYWdBdXRob3JdID0gdGFnO1xuICAgICAgY29uc3QgZXZlbnRQb2ludGVyID0ge1xuICAgICAgICBpZDogZVRhZ0V2ZW50SWQsXG4gICAgICAgIHJlbGF5czogZVRhZ1JlbGF5VXJsID8gW2VUYWdSZWxheVVybF0gOiBbXSxcbiAgICAgICAgYXV0aG9yOiBlVGFnQXV0aG9yXG4gICAgICB9O1xuICAgICAgaWYgKGVUYWdNYXJrZXIgPT09IFwicm9vdFwiKSB7XG4gICAgICAgIHJlc3VsdC5yb290ID0gZXZlbnRQb2ludGVyO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChlVGFnTWFya2VyID09PSBcInJlcGx5XCIpIHtcbiAgICAgICAgcmVzdWx0LnJlcGx5ID0gZXZlbnRQb2ludGVyO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChlVGFnTWFya2VyID09PSBcIm1lbnRpb25cIikge1xuICAgICAgICByZXN1bHQubWVudGlvbnMucHVzaChldmVudFBvaW50ZXIpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICghbWF5YmVQYXJlbnQpIHtcbiAgICAgICAgbWF5YmVQYXJlbnQgPSBldmVudFBvaW50ZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXliZVJvb3QgPSBldmVudFBvaW50ZXI7XG4gICAgICB9XG4gICAgICByZXN1bHQubWVudGlvbnMucHVzaChldmVudFBvaW50ZXIpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICh0YWdbMF0gPT09IFwicVwiICYmIHRhZ1sxXSkge1xuICAgICAgY29uc3QgW18sIGVUYWdFdmVudElkLCBlVGFnUmVsYXlVcmxdID0gdGFnO1xuICAgICAgcmVzdWx0LnF1b3Rlcy5wdXNoKHtcbiAgICAgICAgaWQ6IGVUYWdFdmVudElkLFxuICAgICAgICByZWxheXM6IGVUYWdSZWxheVVybCA/IFtlVGFnUmVsYXlVcmxdIDogW11cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodGFnWzBdID09PSBcInBcIiAmJiB0YWdbMV0pIHtcbiAgICAgIHJlc3VsdC5wcm9maWxlcy5wdXNoKHtcbiAgICAgICAgcHVia2V5OiB0YWdbMV0sXG4gICAgICAgIHJlbGF5czogdGFnWzJdID8gW3RhZ1syXV0gOiBbXVxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gIH1cbiAgaWYgKCFyZXN1bHQucm9vdCkge1xuICAgIHJlc3VsdC5yb290ID0gbWF5YmVSb290IHx8IG1heWJlUGFyZW50IHx8IHJlc3VsdC5yZXBseTtcbiAgfVxuICBpZiAoIXJlc3VsdC5yZXBseSkge1xuICAgIHJlc3VsdC5yZXBseSA9IG1heWJlUGFyZW50IHx8IHJlc3VsdC5yb290O1xuICB9XG4gIDtcbiAgW3Jlc3VsdC5yZXBseSwgcmVzdWx0LnJvb3RdLmZvckVhY2goKHJlZikgPT4ge1xuICAgIGlmICghcmVmKVxuICAgICAgcmV0dXJuO1xuICAgIGxldCBpZHggPSByZXN1bHQubWVudGlvbnMuaW5kZXhPZihyZWYpO1xuICAgIGlmIChpZHggIT09IC0xKSB7XG4gICAgICByZXN1bHQubWVudGlvbnMuc3BsaWNlKGlkeCwgMSk7XG4gICAgfVxuICAgIGlmIChyZWYuYXV0aG9yKSB7XG4gICAgICBsZXQgYXV0aG9yID0gcmVzdWx0LnByb2ZpbGVzLmZpbmQoKHApID0+IHAucHVia2V5ID09PSByZWYuYXV0aG9yKTtcbiAgICAgIGlmIChhdXRob3IgJiYgYXV0aG9yLnJlbGF5cykge1xuICAgICAgICBpZiAoIXJlZi5yZWxheXMpIHtcbiAgICAgICAgICByZWYucmVsYXlzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgYXV0aG9yLnJlbGF5cy5mb3JFYWNoKCh1cmwpID0+IHtcbiAgICAgICAgICBpZiAocmVmLnJlbGF5cz8uaW5kZXhPZih1cmwpID09PSAtMSlcbiAgICAgICAgICAgIHJlZi5yZWxheXMucHVzaCh1cmwpO1xuICAgICAgICB9KTtcbiAgICAgICAgYXV0aG9yLnJlbGF5cyA9IHJlZi5yZWxheXM7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmVzdWx0Lm1lbnRpb25zLmZvckVhY2goKHJlZikgPT4ge1xuICAgIGlmIChyZWYuYXV0aG9yKSB7XG4gICAgICBsZXQgYXV0aG9yID0gcmVzdWx0LnByb2ZpbGVzLmZpbmQoKHApID0+IHAucHVia2V5ID09PSByZWYuYXV0aG9yKTtcbiAgICAgIGlmIChhdXRob3IgJiYgYXV0aG9yLnJlbGF5cykge1xuICAgICAgICBpZiAoIXJlZi5yZWxheXMpIHtcbiAgICAgICAgICByZWYucmVsYXlzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgYXV0aG9yLnJlbGF5cy5mb3JFYWNoKCh1cmwpID0+IHtcbiAgICAgICAgICBpZiAocmVmLnJlbGF5cy5pbmRleE9mKHVybCkgPT09IC0xKVxuICAgICAgICAgICAgcmVmLnJlbGF5cy5wdXNoKHVybCk7XG4gICAgICAgIH0pO1xuICAgICAgICBhdXRob3IucmVsYXlzID0gcmVmLnJlbGF5cztcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBuaXAxMS50c1xudmFyIG5pcDExX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDExX2V4cG9ydHMsIHtcbiAgZmV0Y2hSZWxheUluZm9ybWF0aW9uOiAoKSA9PiBmZXRjaFJlbGF5SW5mb3JtYXRpb24sXG4gIHVzZUZldGNoSW1wbGVtZW50YXRpb246ICgpID0+IHVzZUZldGNoSW1wbGVtZW50YXRpb24yXG59KTtcbnZhciBfZmV0Y2gyO1xudHJ5IHtcbiAgX2ZldGNoMiA9IGZldGNoO1xufSBjYXRjaCB7XG59XG5mdW5jdGlvbiB1c2VGZXRjaEltcGxlbWVudGF0aW9uMihmZXRjaEltcGxlbWVudGF0aW9uKSB7XG4gIF9mZXRjaDIgPSBmZXRjaEltcGxlbWVudGF0aW9uO1xufVxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hSZWxheUluZm9ybWF0aW9uKHVybCkge1xuICByZXR1cm4gYXdhaXQgKGF3YWl0IGZldGNoKHVybC5yZXBsYWNlKFwid3M6Ly9cIiwgXCJodHRwOi8vXCIpLnJlcGxhY2UoXCJ3c3M6Ly9cIiwgXCJodHRwczovL1wiKSwge1xuICAgIGhlYWRlcnM6IHsgQWNjZXB0OiBcImFwcGxpY2F0aW9uL25vc3RyK2pzb25cIiB9XG4gIH0pKS5qc29uKCk7XG59XG5cbi8vIG5pcDEzLnRzXG52YXIgbmlwMTNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobmlwMTNfZXhwb3J0cywge1xuICBmYXN0RXZlbnRIYXNoOiAoKSA9PiBmYXN0RXZlbnRIYXNoLFxuICBnZXRQb3c6ICgpID0+IGdldFBvdyxcbiAgbWluZVBvdzogKCkgPT4gbWluZVBvd1xufSk7XG5pbXBvcnQgeyBieXRlc1RvSGV4IGFzIGJ5dGVzVG9IZXg0IH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvdXRpbHNcIjtcbmltcG9ydCB7IHNoYTI1NiBhcyBzaGEyNTYyIH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvc2hhMjU2XCI7XG5mdW5jdGlvbiBnZXRQb3coaGV4KSB7XG4gIGxldCBjb3VudCA9IDA7XG4gIGZvciAobGV0IGkyID0gMDsgaTIgPCA2NDsgaTIgKz0gOCkge1xuICAgIGNvbnN0IG5pYmJsZSA9IHBhcnNlSW50KGhleC5zdWJzdHJpbmcoaTIsIGkyICsgOCksIDE2KTtcbiAgICBpZiAobmliYmxlID09PSAwKSB7XG4gICAgICBjb3VudCArPSAzMjtcbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQgKz0gTWF0aC5jbHozMihuaWJibGUpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBjb3VudDtcbn1cbmZ1bmN0aW9uIG1pbmVQb3codW5zaWduZWQsIGRpZmZpY3VsdHkpIHtcbiAgbGV0IGNvdW50ID0gMDtcbiAgY29uc3QgZXZlbnQgPSB1bnNpZ25lZDtcbiAgY29uc3QgdGFnID0gW1wibm9uY2VcIiwgY291bnQudG9TdHJpbmcoKSwgZGlmZmljdWx0eS50b1N0cmluZygpXTtcbiAgZXZlbnQudGFncy5wdXNoKHRhZyk7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3Qgbm93MiA9IE1hdGguZmxvb3IobmV3IERhdGUoKS5nZXRUaW1lKCkgLyAxZTMpO1xuICAgIGlmIChub3cyICE9PSBldmVudC5jcmVhdGVkX2F0KSB7XG4gICAgICBjb3VudCA9IDA7XG4gICAgICBldmVudC5jcmVhdGVkX2F0ID0gbm93MjtcbiAgICB9XG4gICAgdGFnWzFdID0gKCsrY291bnQpLnRvU3RyaW5nKCk7XG4gICAgZXZlbnQuaWQgPSBmYXN0RXZlbnRIYXNoKGV2ZW50KTtcbiAgICBpZiAoZ2V0UG93KGV2ZW50LmlkKSA+PSBkaWZmaWN1bHR5KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGV2ZW50O1xufVxuZnVuY3Rpb24gZmFzdEV2ZW50SGFzaChldnQpIHtcbiAgcmV0dXJuIGJ5dGVzVG9IZXg0KFxuICAgIHNoYTI1NjIodXRmOEVuY29kZXIuZW5jb2RlKEpTT04uc3RyaW5naWZ5KFswLCBldnQucHVia2V5LCBldnQuY3JlYXRlZF9hdCwgZXZ0LmtpbmQsIGV2dC50YWdzLCBldnQuY29udGVudF0pKSlcbiAgKTtcbn1cblxuLy8gbmlwMTgudHNcbnZhciBuaXAxOF9leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXAxOF9leHBvcnRzLCB7XG4gIGZpbmlzaFJlcG9zdEV2ZW50OiAoKSA9PiBmaW5pc2hSZXBvc3RFdmVudCxcbiAgZ2V0UmVwb3N0ZWRFdmVudDogKCkgPT4gZ2V0UmVwb3N0ZWRFdmVudCxcbiAgZ2V0UmVwb3N0ZWRFdmVudFBvaW50ZXI6ICgpID0+IGdldFJlcG9zdGVkRXZlbnRQb2ludGVyXG59KTtcbmZ1bmN0aW9uIGZpbmlzaFJlcG9zdEV2ZW50KHQsIHJlcG9zdGVkLCByZWxheVVybCwgcHJpdmF0ZUtleSkge1xuICByZXR1cm4gZmluYWxpemVFdmVudChcbiAgICB7XG4gICAgICBraW5kOiBSZXBvc3QsXG4gICAgICB0YWdzOiBbLi4udC50YWdzID8/IFtdLCBbXCJlXCIsIHJlcG9zdGVkLmlkLCByZWxheVVybF0sIFtcInBcIiwgcmVwb3N0ZWQucHVia2V5XV0sXG4gICAgICBjb250ZW50OiB0LmNvbnRlbnQgPT09IFwiXCIgPyBcIlwiIDogSlNPTi5zdHJpbmdpZnkocmVwb3N0ZWQpLFxuICAgICAgY3JlYXRlZF9hdDogdC5jcmVhdGVkX2F0XG4gICAgfSxcbiAgICBwcml2YXRlS2V5XG4gICk7XG59XG5mdW5jdGlvbiBnZXRSZXBvc3RlZEV2ZW50UG9pbnRlcihldmVudCkge1xuICBpZiAoZXZlbnQua2luZCAhPT0gUmVwb3N0KSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBsZXQgbGFzdEVUYWc7XG4gIGxldCBsYXN0UFRhZztcbiAgZm9yIChsZXQgaTIgPSBldmVudC50YWdzLmxlbmd0aCAtIDE7IGkyID49IDAgJiYgKGxhc3RFVGFnID09PSB2b2lkIDAgfHwgbGFzdFBUYWcgPT09IHZvaWQgMCk7IGkyLS0pIHtcbiAgICBjb25zdCB0YWcgPSBldmVudC50YWdzW2kyXTtcbiAgICBpZiAodGFnLmxlbmd0aCA+PSAyKSB7XG4gICAgICBpZiAodGFnWzBdID09PSBcImVcIiAmJiBsYXN0RVRhZyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGxhc3RFVGFnID0gdGFnO1xuICAgICAgfSBlbHNlIGlmICh0YWdbMF0gPT09IFwicFwiICYmIGxhc3RQVGFnID09PSB2b2lkIDApIHtcbiAgICAgICAgbGFzdFBUYWcgPSB0YWc7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChsYXN0RVRhZyA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4ge1xuICAgIGlkOiBsYXN0RVRhZ1sxXSxcbiAgICByZWxheXM6IFtsYXN0RVRhZ1syXSwgbGFzdFBUYWc/LlsyXV0uZmlsdGVyKCh4KSA9PiB0eXBlb2YgeCA9PT0gXCJzdHJpbmdcIiksXG4gICAgYXV0aG9yOiBsYXN0UFRhZz8uWzFdXG4gIH07XG59XG5mdW5jdGlvbiBnZXRSZXBvc3RlZEV2ZW50KGV2ZW50LCB7IHNraXBWZXJpZmljYXRpb24gfSA9IHt9KSB7XG4gIGNvbnN0IHBvaW50ZXIgPSBnZXRSZXBvc3RlZEV2ZW50UG9pbnRlcihldmVudCk7XG4gIGlmIChwb2ludGVyID09PSB2b2lkIDAgfHwgZXZlbnQuY29udGVudCA9PT0gXCJcIikge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgbGV0IHJlcG9zdGVkRXZlbnQ7XG4gIHRyeSB7XG4gICAgcmVwb3N0ZWRFdmVudCA9IEpTT04ucGFyc2UoZXZlbnQuY29udGVudCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBpZiAocmVwb3N0ZWRFdmVudC5pZCAhPT0gcG9pbnRlci5pZCkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgaWYgKCFza2lwVmVyaWZpY2F0aW9uICYmICF2ZXJpZnlFdmVudChyZXBvc3RlZEV2ZW50KSkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIHJlcG9zdGVkRXZlbnQ7XG59XG5cbi8vIG5pcDIxLnRzXG52YXIgbmlwMjFfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobmlwMjFfZXhwb3J0cywge1xuICBOT1NUUl9VUklfUkVHRVg6ICgpID0+IE5PU1RSX1VSSV9SRUdFWCxcbiAgcGFyc2U6ICgpID0+IHBhcnNlMixcbiAgdGVzdDogKCkgPT4gdGVzdFxufSk7XG52YXIgTk9TVFJfVVJJX1JFR0VYID0gbmV3IFJlZ0V4cChgbm9zdHI6KCR7QkVDSDMyX1JFR0VYLnNvdXJjZX0pYCk7XG5mdW5jdGlvbiB0ZXN0KHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgbmV3IFJlZ0V4cChgXiR7Tk9TVFJfVVJJX1JFR0VYLnNvdXJjZX0kYCkudGVzdCh2YWx1ZSk7XG59XG5mdW5jdGlvbiBwYXJzZTIodXJpKSB7XG4gIGNvbnN0IG1hdGNoID0gdXJpLm1hdGNoKG5ldyBSZWdFeHAoYF4ke05PU1RSX1VSSV9SRUdFWC5zb3VyY2V9JGApKTtcbiAgaWYgKCFtYXRjaClcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgTm9zdHIgVVJJOiAke3VyaX1gKTtcbiAgcmV0dXJuIHtcbiAgICB1cmk6IG1hdGNoWzBdLFxuICAgIHZhbHVlOiBtYXRjaFsxXSxcbiAgICBkZWNvZGVkOiBkZWNvZGUobWF0Y2hbMV0pXG4gIH07XG59XG5cbi8vIG5pcDI1LnRzXG52YXIgbmlwMjVfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobmlwMjVfZXhwb3J0cywge1xuICBmaW5pc2hSZWFjdGlvbkV2ZW50OiAoKSA9PiBmaW5pc2hSZWFjdGlvbkV2ZW50LFxuICBnZXRSZWFjdGVkRXZlbnRQb2ludGVyOiAoKSA9PiBnZXRSZWFjdGVkRXZlbnRQb2ludGVyXG59KTtcbmZ1bmN0aW9uIGZpbmlzaFJlYWN0aW9uRXZlbnQodCwgcmVhY3RlZCwgcHJpdmF0ZUtleSkge1xuICBjb25zdCBpbmhlcml0ZWRUYWdzID0gcmVhY3RlZC50YWdzLmZpbHRlcigodGFnKSA9PiB0YWcubGVuZ3RoID49IDIgJiYgKHRhZ1swXSA9PT0gXCJlXCIgfHwgdGFnWzBdID09PSBcInBcIikpO1xuICByZXR1cm4gZmluYWxpemVFdmVudChcbiAgICB7XG4gICAgICAuLi50LFxuICAgICAga2luZDogUmVhY3Rpb24sXG4gICAgICB0YWdzOiBbLi4udC50YWdzID8/IFtdLCAuLi5pbmhlcml0ZWRUYWdzLCBbXCJlXCIsIHJlYWN0ZWQuaWRdLCBbXCJwXCIsIHJlYWN0ZWQucHVia2V5XV0sXG4gICAgICBjb250ZW50OiB0LmNvbnRlbnQgPz8gXCIrXCJcbiAgICB9LFxuICAgIHByaXZhdGVLZXlcbiAgKTtcbn1cbmZ1bmN0aW9uIGdldFJlYWN0ZWRFdmVudFBvaW50ZXIoZXZlbnQpIHtcbiAgaWYgKGV2ZW50LmtpbmQgIT09IFJlYWN0aW9uKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBsZXQgbGFzdEVUYWc7XG4gIGxldCBsYXN0UFRhZztcbiAgZm9yIChsZXQgaTIgPSBldmVudC50YWdzLmxlbmd0aCAtIDE7IGkyID49IDAgJiYgKGxhc3RFVGFnID09PSB2b2lkIDAgfHwgbGFzdFBUYWcgPT09IHZvaWQgMCk7IGkyLS0pIHtcbiAgICBjb25zdCB0YWcgPSBldmVudC50YWdzW2kyXTtcbiAgICBpZiAodGFnLmxlbmd0aCA+PSAyKSB7XG4gICAgICBpZiAodGFnWzBdID09PSBcImVcIiAmJiBsYXN0RVRhZyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGxhc3RFVGFnID0gdGFnO1xuICAgICAgfSBlbHNlIGlmICh0YWdbMF0gPT09IFwicFwiICYmIGxhc3RQVGFnID09PSB2b2lkIDApIHtcbiAgICAgICAgbGFzdFBUYWcgPSB0YWc7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChsYXN0RVRhZyA9PT0gdm9pZCAwIHx8IGxhc3RQVGFnID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHJldHVybiB7XG4gICAgaWQ6IGxhc3RFVGFnWzFdLFxuICAgIHJlbGF5czogW2xhc3RFVGFnWzJdLCBsYXN0UFRhZ1syXV0uZmlsdGVyKCh4KSA9PiB4ICE9PSB2b2lkIDApLFxuICAgIGF1dGhvcjogbGFzdFBUYWdbMV1cbiAgfTtcbn1cblxuLy8gbmlwMjcudHNcbnZhciBuaXAyN19leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXAyN19leHBvcnRzLCB7XG4gIG1hdGNoQWxsOiAoKSA9PiBtYXRjaEFsbCxcbiAgcmVnZXg6ICgpID0+IHJlZ2V4LFxuICByZXBsYWNlQWxsOiAoKSA9PiByZXBsYWNlQWxsXG59KTtcbnZhciByZWdleCA9ICgpID0+IG5ldyBSZWdFeHAoYFxcXFxiJHtOT1NUUl9VUklfUkVHRVguc291cmNlfVxcXFxiYCwgXCJnXCIpO1xuZnVuY3Rpb24qIG1hdGNoQWxsKGNvbnRlbnQpIHtcbiAgY29uc3QgbWF0Y2hlcyA9IGNvbnRlbnQubWF0Y2hBbGwocmVnZXgoKSk7XG4gIGZvciAoY29uc3QgbWF0Y2ggb2YgbWF0Y2hlcykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBbdXJpLCB2YWx1ZV0gPSBtYXRjaDtcbiAgICAgIHlpZWxkIHtcbiAgICAgICAgdXJpLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgZGVjb2RlZDogZGVjb2RlKHZhbHVlKSxcbiAgICAgICAgc3RhcnQ6IG1hdGNoLmluZGV4LFxuICAgICAgICBlbmQ6IG1hdGNoLmluZGV4ICsgdXJpLmxlbmd0aFxuICAgICAgfTtcbiAgICB9IGNhdGNoIChfZSkge1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcmVwbGFjZUFsbChjb250ZW50LCByZXBsYWNlcikge1xuICByZXR1cm4gY29udGVudC5yZXBsYWNlQWxsKHJlZ2V4KCksICh1cmksIHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIHJlcGxhY2VyKHtcbiAgICAgIHVyaSxcbiAgICAgIHZhbHVlLFxuICAgICAgZGVjb2RlZDogZGVjb2RlKHZhbHVlKVxuICAgIH0pO1xuICB9KTtcbn1cblxuLy8gbmlwMjgudHNcbnZhciBuaXAyOF9leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXAyOF9leHBvcnRzLCB7XG4gIGNoYW5uZWxDcmVhdGVFdmVudDogKCkgPT4gY2hhbm5lbENyZWF0ZUV2ZW50LFxuICBjaGFubmVsSGlkZU1lc3NhZ2VFdmVudDogKCkgPT4gY2hhbm5lbEhpZGVNZXNzYWdlRXZlbnQsXG4gIGNoYW5uZWxNZXNzYWdlRXZlbnQ6ICgpID0+IGNoYW5uZWxNZXNzYWdlRXZlbnQsXG4gIGNoYW5uZWxNZXRhZGF0YUV2ZW50OiAoKSA9PiBjaGFubmVsTWV0YWRhdGFFdmVudCxcbiAgY2hhbm5lbE11dGVVc2VyRXZlbnQ6ICgpID0+IGNoYW5uZWxNdXRlVXNlckV2ZW50XG59KTtcbnZhciBjaGFubmVsQ3JlYXRlRXZlbnQgPSAodCwgcHJpdmF0ZUtleSkgPT4ge1xuICBsZXQgY29udGVudDtcbiAgaWYgKHR5cGVvZiB0LmNvbnRlbnQgPT09IFwib2JqZWN0XCIpIHtcbiAgICBjb250ZW50ID0gSlNPTi5zdHJpbmdpZnkodC5jb250ZW50KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdC5jb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgY29udGVudCA9IHQuY29udGVudDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHJldHVybiBmaW5hbGl6ZUV2ZW50KFxuICAgIHtcbiAgICAgIGtpbmQ6IENoYW5uZWxDcmVhdGlvbixcbiAgICAgIHRhZ3M6IFsuLi50LnRhZ3MgPz8gW11dLFxuICAgICAgY29udGVudCxcbiAgICAgIGNyZWF0ZWRfYXQ6IHQuY3JlYXRlZF9hdFxuICAgIH0sXG4gICAgcHJpdmF0ZUtleVxuICApO1xufTtcbnZhciBjaGFubmVsTWV0YWRhdGFFdmVudCA9ICh0LCBwcml2YXRlS2V5KSA9PiB7XG4gIGxldCBjb250ZW50O1xuICBpZiAodHlwZW9mIHQuY29udGVudCA9PT0gXCJvYmplY3RcIikge1xuICAgIGNvbnRlbnQgPSBKU09OLnN0cmluZ2lmeSh0LmNvbnRlbnQpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB0LmNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICBjb250ZW50ID0gdC5jb250ZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIGZpbmFsaXplRXZlbnQoXG4gICAge1xuICAgICAga2luZDogQ2hhbm5lbE1ldGFkYXRhLFxuICAgICAgdGFnczogW1tcImVcIiwgdC5jaGFubmVsX2NyZWF0ZV9ldmVudF9pZF0sIC4uLnQudGFncyA/PyBbXV0sXG4gICAgICBjb250ZW50LFxuICAgICAgY3JlYXRlZF9hdDogdC5jcmVhdGVkX2F0XG4gICAgfSxcbiAgICBwcml2YXRlS2V5XG4gICk7XG59O1xudmFyIGNoYW5uZWxNZXNzYWdlRXZlbnQgPSAodCwgcHJpdmF0ZUtleSkgPT4ge1xuICBjb25zdCB0YWdzID0gW1tcImVcIiwgdC5jaGFubmVsX2NyZWF0ZV9ldmVudF9pZCwgdC5yZWxheV91cmwsIFwicm9vdFwiXV07XG4gIGlmICh0LnJlcGx5X3RvX2NoYW5uZWxfbWVzc2FnZV9ldmVudF9pZCkge1xuICAgIHRhZ3MucHVzaChbXCJlXCIsIHQucmVwbHlfdG9fY2hhbm5lbF9tZXNzYWdlX2V2ZW50X2lkLCB0LnJlbGF5X3VybCwgXCJyZXBseVwiXSk7XG4gIH1cbiAgcmV0dXJuIGZpbmFsaXplRXZlbnQoXG4gICAge1xuICAgICAga2luZDogQ2hhbm5lbE1lc3NhZ2UsXG4gICAgICB0YWdzOiBbLi4udGFncywgLi4udC50YWdzID8/IFtdXSxcbiAgICAgIGNvbnRlbnQ6IHQuY29udGVudCxcbiAgICAgIGNyZWF0ZWRfYXQ6IHQuY3JlYXRlZF9hdFxuICAgIH0sXG4gICAgcHJpdmF0ZUtleVxuICApO1xufTtcbnZhciBjaGFubmVsSGlkZU1lc3NhZ2VFdmVudCA9ICh0LCBwcml2YXRlS2V5KSA9PiB7XG4gIGxldCBjb250ZW50O1xuICBpZiAodHlwZW9mIHQuY29udGVudCA9PT0gXCJvYmplY3RcIikge1xuICAgIGNvbnRlbnQgPSBKU09OLnN0cmluZ2lmeSh0LmNvbnRlbnQpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB0LmNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICBjb250ZW50ID0gdC5jb250ZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIGZpbmFsaXplRXZlbnQoXG4gICAge1xuICAgICAga2luZDogQ2hhbm5lbEhpZGVNZXNzYWdlLFxuICAgICAgdGFnczogW1tcImVcIiwgdC5jaGFubmVsX21lc3NhZ2VfZXZlbnRfaWRdLCAuLi50LnRhZ3MgPz8gW11dLFxuICAgICAgY29udGVudCxcbiAgICAgIGNyZWF0ZWRfYXQ6IHQuY3JlYXRlZF9hdFxuICAgIH0sXG4gICAgcHJpdmF0ZUtleVxuICApO1xufTtcbnZhciBjaGFubmVsTXV0ZVVzZXJFdmVudCA9ICh0LCBwcml2YXRlS2V5KSA9PiB7XG4gIGxldCBjb250ZW50O1xuICBpZiAodHlwZW9mIHQuY29udGVudCA9PT0gXCJvYmplY3RcIikge1xuICAgIGNvbnRlbnQgPSBKU09OLnN0cmluZ2lmeSh0LmNvbnRlbnQpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB0LmNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICBjb250ZW50ID0gdC5jb250ZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIGZpbmFsaXplRXZlbnQoXG4gICAge1xuICAgICAga2luZDogQ2hhbm5lbE11dGVVc2VyLFxuICAgICAgdGFnczogW1tcInBcIiwgdC5wdWJrZXlfdG9fbXV0ZV0sIC4uLnQudGFncyA/PyBbXV0sXG4gICAgICBjb250ZW50LFxuICAgICAgY3JlYXRlZF9hdDogdC5jcmVhdGVkX2F0XG4gICAgfSxcbiAgICBwcml2YXRlS2V5XG4gICk7XG59O1xuXG4vLyBuaXAzMC50c1xudmFyIG5pcDMwX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDMwX2V4cG9ydHMsIHtcbiAgRU1PSklfU0hPUlRDT0RFX1JFR0VYOiAoKSA9PiBFTU9KSV9TSE9SVENPREVfUkVHRVgsXG4gIG1hdGNoQWxsOiAoKSA9PiBtYXRjaEFsbDIsXG4gIHJlZ2V4OiAoKSA9PiByZWdleDIsXG4gIHJlcGxhY2VBbGw6ICgpID0+IHJlcGxhY2VBbGwyXG59KTtcbnZhciBFTU9KSV9TSE9SVENPREVfUkVHRVggPSAvOihcXHcrKTovO1xudmFyIHJlZ2V4MiA9ICgpID0+IG5ldyBSZWdFeHAoYFxcXFxCJHtFTU9KSV9TSE9SVENPREVfUkVHRVguc291cmNlfVxcXFxCYCwgXCJnXCIpO1xuZnVuY3Rpb24qIG1hdGNoQWxsMihjb250ZW50KSB7XG4gIGNvbnN0IG1hdGNoZXMgPSBjb250ZW50Lm1hdGNoQWxsKHJlZ2V4MigpKTtcbiAgZm9yIChjb25zdCBtYXRjaCBvZiBtYXRjaGVzKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IFtzaG9ydGNvZGUsIG5hbWVdID0gbWF0Y2g7XG4gICAgICB5aWVsZCB7XG4gICAgICAgIHNob3J0Y29kZSxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgc3RhcnQ6IG1hdGNoLmluZGV4LFxuICAgICAgICBlbmQ6IG1hdGNoLmluZGV4ICsgc2hvcnRjb2RlLmxlbmd0aFxuICAgICAgfTtcbiAgICB9IGNhdGNoIChfZSkge1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcmVwbGFjZUFsbDIoY29udGVudCwgcmVwbGFjZXIpIHtcbiAgcmV0dXJuIGNvbnRlbnQucmVwbGFjZUFsbChyZWdleDIoKSwgKHNob3J0Y29kZSwgbmFtZSkgPT4ge1xuICAgIHJldHVybiByZXBsYWNlcih7XG4gICAgICBzaG9ydGNvZGUsXG4gICAgICBuYW1lXG4gICAgfSk7XG4gIH0pO1xufVxuXG4vLyBuaXAzOS50c1xudmFyIG5pcDM5X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDM5X2V4cG9ydHMsIHtcbiAgdXNlRmV0Y2hJbXBsZW1lbnRhdGlvbjogKCkgPT4gdXNlRmV0Y2hJbXBsZW1lbnRhdGlvbjMsXG4gIHZhbGlkYXRlR2l0aHViOiAoKSA9PiB2YWxpZGF0ZUdpdGh1YlxufSk7XG52YXIgX2ZldGNoMztcbnRyeSB7XG4gIF9mZXRjaDMgPSBmZXRjaDtcbn0gY2F0Y2gge1xufVxuZnVuY3Rpb24gdXNlRmV0Y2hJbXBsZW1lbnRhdGlvbjMoZmV0Y2hJbXBsZW1lbnRhdGlvbikge1xuICBfZmV0Y2gzID0gZmV0Y2hJbXBsZW1lbnRhdGlvbjtcbn1cbmFzeW5jIGZ1bmN0aW9uIHZhbGlkYXRlR2l0aHViKHB1YmtleSwgdXNlcm5hbWUsIHByb29mKSB7XG4gIHRyeSB7XG4gICAgbGV0IHJlcyA9IGF3YWl0IChhd2FpdCBfZmV0Y2gzKGBodHRwczovL2dpc3QuZ2l0aHViLmNvbS8ke3VzZXJuYW1lfS8ke3Byb29mfS9yYXdgKSkudGV4dCgpO1xuICAgIHJldHVybiByZXMgPT09IGBWZXJpZnlpbmcgdGhhdCBJIGNvbnRyb2wgdGhlIGZvbGxvd2luZyBOb3N0ciBwdWJsaWMga2V5OiAke3B1YmtleX1gO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8vIG5pcDQ0LnRzXG52YXIgbmlwNDRfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobmlwNDRfZXhwb3J0cywge1xuICBkZWNyeXB0OiAoKSA9PiBkZWNyeXB0MixcbiAgZW5jcnlwdDogKCkgPT4gZW5jcnlwdDIsXG4gIGdldENvbnZlcnNhdGlvbktleTogKCkgPT4gZ2V0Q29udmVyc2F0aW9uS2V5LFxuICB2MjogKCkgPT4gdjJcbn0pO1xuaW1wb3J0IHsgY2hhY2hhMjAgfSBmcm9tIFwiQG5vYmxlL2NpcGhlcnMvY2hhY2hhXCI7XG5pbXBvcnQgeyBlcXVhbEJ5dGVzIH0gZnJvbSBcIkBub2JsZS9jaXBoZXJzL3V0aWxzXCI7XG5pbXBvcnQgeyBzZWNwMjU2azEgYXMgc2VjcDI1NmsxMiB9IGZyb20gXCJAbm9ibGUvY3VydmVzL3NlY3AyNTZrMVwiO1xuaW1wb3J0IHsgZXh0cmFjdCBhcyBoa2RmX2V4dHJhY3QsIGV4cGFuZCBhcyBoa2RmX2V4cGFuZCB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL2hrZGZcIjtcbmltcG9ydCB7IGhtYWMgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy9obWFjXCI7XG5pbXBvcnQgeyBzaGEyNTYgYXMgc2hhMjU2MyB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3NoYTI1NlwiO1xuaW1wb3J0IHsgY29uY2F0Qnl0ZXMgYXMgY29uY2F0Qnl0ZXMyLCByYW5kb21CeXRlcyBhcyByYW5kb21CeXRlczIgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy91dGlsc1wiO1xuaW1wb3J0IHsgYmFzZTY0IGFzIGJhc2U2NDIgfSBmcm9tIFwiQHNjdXJlL2Jhc2VcIjtcbnZhciBtaW5QbGFpbnRleHRTaXplID0gMTtcbnZhciBtYXhQbGFpbnRleHRTaXplID0gNjU1MzU7XG5mdW5jdGlvbiBnZXRDb252ZXJzYXRpb25LZXkocHJpdmtleUEsIHB1YmtleUIpIHtcbiAgY29uc3Qgc2hhcmVkWCA9IHNlY3AyNTZrMTIuZ2V0U2hhcmVkU2VjcmV0KHByaXZrZXlBLCBcIjAyXCIgKyBwdWJrZXlCKS5zdWJhcnJheSgxLCAzMyk7XG4gIHJldHVybiBoa2RmX2V4dHJhY3Qoc2hhMjU2Mywgc2hhcmVkWCwgXCJuaXA0NC12MlwiKTtcbn1cbmZ1bmN0aW9uIGdldE1lc3NhZ2VLZXlzKGNvbnZlcnNhdGlvbktleSwgbm9uY2UpIHtcbiAgY29uc3Qga2V5cyA9IGhrZGZfZXhwYW5kKHNoYTI1NjMsIGNvbnZlcnNhdGlvbktleSwgbm9uY2UsIDc2KTtcbiAgcmV0dXJuIHtcbiAgICBjaGFjaGFfa2V5OiBrZXlzLnN1YmFycmF5KDAsIDMyKSxcbiAgICBjaGFjaGFfbm9uY2U6IGtleXMuc3ViYXJyYXkoMzIsIDQ0KSxcbiAgICBobWFjX2tleToga2V5cy5zdWJhcnJheSg0NCwgNzYpXG4gIH07XG59XG5mdW5jdGlvbiBjYWxjUGFkZGVkTGVuKGxlbikge1xuICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGxlbikgfHwgbGVuIDwgMSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJleHBlY3RlZCBwb3NpdGl2ZSBpbnRlZ2VyXCIpO1xuICBpZiAobGVuIDw9IDMyKVxuICAgIHJldHVybiAzMjtcbiAgY29uc3QgbmV4dFBvd2VyID0gMSA8PCBNYXRoLmZsb29yKE1hdGgubG9nMihsZW4gLSAxKSkgKyAxO1xuICBjb25zdCBjaHVuayA9IG5leHRQb3dlciA8PSAyNTYgPyAzMiA6IG5leHRQb3dlciAvIDg7XG4gIHJldHVybiBjaHVuayAqIChNYXRoLmZsb29yKChsZW4gLSAxKSAvIGNodW5rKSArIDEpO1xufVxuZnVuY3Rpb24gd3JpdGVVMTZCRShudW0pIHtcbiAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihudW0pIHx8IG51bSA8IG1pblBsYWludGV4dFNpemUgfHwgbnVtID4gbWF4UGxhaW50ZXh0U2l6ZSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBsYWludGV4dCBzaXplOiBtdXN0IGJlIGJldHdlZW4gMSBhbmQgNjU1MzUgYnl0ZXNcIik7XG4gIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KDIpO1xuICBuZXcgRGF0YVZpZXcoYXJyLmJ1ZmZlcikuc2V0VWludDE2KDAsIG51bSwgZmFsc2UpO1xuICByZXR1cm4gYXJyO1xufVxuZnVuY3Rpb24gcGFkKHBsYWludGV4dCkge1xuICBjb25zdCB1bnBhZGRlZCA9IHV0ZjhFbmNvZGVyLmVuY29kZShwbGFpbnRleHQpO1xuICBjb25zdCB1bnBhZGRlZExlbiA9IHVucGFkZGVkLmxlbmd0aDtcbiAgY29uc3QgcHJlZml4ID0gd3JpdGVVMTZCRSh1bnBhZGRlZExlbik7XG4gIGNvbnN0IHN1ZmZpeCA9IG5ldyBVaW50OEFycmF5KGNhbGNQYWRkZWRMZW4odW5wYWRkZWRMZW4pIC0gdW5wYWRkZWRMZW4pO1xuICByZXR1cm4gY29uY2F0Qnl0ZXMyKHByZWZpeCwgdW5wYWRkZWQsIHN1ZmZpeCk7XG59XG5mdW5jdGlvbiB1bnBhZChwYWRkZWQpIHtcbiAgY29uc3QgdW5wYWRkZWRMZW4gPSBuZXcgRGF0YVZpZXcocGFkZGVkLmJ1ZmZlcikuZ2V0VWludDE2KDApO1xuICBjb25zdCB1bnBhZGRlZCA9IHBhZGRlZC5zdWJhcnJheSgyLCAyICsgdW5wYWRkZWRMZW4pO1xuICBpZiAodW5wYWRkZWRMZW4gPCBtaW5QbGFpbnRleHRTaXplIHx8IHVucGFkZGVkTGVuID4gbWF4UGxhaW50ZXh0U2l6ZSB8fCB1bnBhZGRlZC5sZW5ndGggIT09IHVucGFkZGVkTGVuIHx8IHBhZGRlZC5sZW5ndGggIT09IDIgKyBjYWxjUGFkZGVkTGVuKHVucGFkZGVkTGVuKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBhZGRpbmdcIik7XG4gIHJldHVybiB1dGY4RGVjb2Rlci5kZWNvZGUodW5wYWRkZWQpO1xufVxuZnVuY3Rpb24gaG1hY0FhZChrZXksIG1lc3NhZ2UsIGFhZCkge1xuICBpZiAoYWFkLmxlbmd0aCAhPT0gMzIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQUFEIGFzc29jaWF0ZWQgZGF0YSBtdXN0IGJlIDMyIGJ5dGVzXCIpO1xuICBjb25zdCBjb21iaW5lZCA9IGNvbmNhdEJ5dGVzMihhYWQsIG1lc3NhZ2UpO1xuICByZXR1cm4gaG1hYyhzaGEyNTYzLCBrZXksIGNvbWJpbmVkKTtcbn1cbmZ1bmN0aW9uIGRlY29kZVBheWxvYWQocGF5bG9hZCkge1xuICBpZiAodHlwZW9mIHBheWxvYWQgIT09IFwic3RyaW5nXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwicGF5bG9hZCBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nXCIpO1xuICBjb25zdCBwbGVuID0gcGF5bG9hZC5sZW5ndGg7XG4gIGlmIChwbGVuIDwgMTMyIHx8IHBsZW4gPiA4NzQ3MilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBheWxvYWQgbGVuZ3RoOiBcIiArIHBsZW4pO1xuICBpZiAocGF5bG9hZFswXSA9PT0gXCIjXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biBlbmNyeXB0aW9uIHZlcnNpb25cIik7XG4gIGxldCBkYXRhO1xuICB0cnkge1xuICAgIGRhdGEgPSBiYXNlNjQyLmRlY29kZShwYXlsb2FkKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGJhc2U2NDogXCIgKyBlcnJvci5tZXNzYWdlKTtcbiAgfVxuICBjb25zdCBkbGVuID0gZGF0YS5sZW5ndGg7XG4gIGlmIChkbGVuIDwgOTkgfHwgZGxlbiA+IDY1NjAzKVxuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZGF0YSBsZW5ndGg6IFwiICsgZGxlbik7XG4gIGNvbnN0IHZlcnMgPSBkYXRhWzBdO1xuICBpZiAodmVycyAhPT0gMilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIGVuY3J5cHRpb24gdmVyc2lvbiBcIiArIHZlcnMpO1xuICByZXR1cm4ge1xuICAgIG5vbmNlOiBkYXRhLnN1YmFycmF5KDEsIDMzKSxcbiAgICBjaXBoZXJ0ZXh0OiBkYXRhLnN1YmFycmF5KDMzLCAtMzIpLFxuICAgIG1hYzogZGF0YS5zdWJhcnJheSgtMzIpXG4gIH07XG59XG5mdW5jdGlvbiBlbmNyeXB0MihwbGFpbnRleHQsIGNvbnZlcnNhdGlvbktleSwgbm9uY2UgPSByYW5kb21CeXRlczIoMzIpKSB7XG4gIGNvbnN0IHsgY2hhY2hhX2tleSwgY2hhY2hhX25vbmNlLCBobWFjX2tleSB9ID0gZ2V0TWVzc2FnZUtleXMoY29udmVyc2F0aW9uS2V5LCBub25jZSk7XG4gIGNvbnN0IHBhZGRlZCA9IHBhZChwbGFpbnRleHQpO1xuICBjb25zdCBjaXBoZXJ0ZXh0ID0gY2hhY2hhMjAoY2hhY2hhX2tleSwgY2hhY2hhX25vbmNlLCBwYWRkZWQpO1xuICBjb25zdCBtYWMgPSBobWFjQWFkKGhtYWNfa2V5LCBjaXBoZXJ0ZXh0LCBub25jZSk7XG4gIHJldHVybiBiYXNlNjQyLmVuY29kZShjb25jYXRCeXRlczIobmV3IFVpbnQ4QXJyYXkoWzJdKSwgbm9uY2UsIGNpcGhlcnRleHQsIG1hYykpO1xufVxuZnVuY3Rpb24gZGVjcnlwdDIocGF5bG9hZCwgY29udmVyc2F0aW9uS2V5KSB7XG4gIGNvbnN0IHsgbm9uY2UsIGNpcGhlcnRleHQsIG1hYyB9ID0gZGVjb2RlUGF5bG9hZChwYXlsb2FkKTtcbiAgY29uc3QgeyBjaGFjaGFfa2V5LCBjaGFjaGFfbm9uY2UsIGhtYWNfa2V5IH0gPSBnZXRNZXNzYWdlS2V5cyhjb252ZXJzYXRpb25LZXksIG5vbmNlKTtcbiAgY29uc3QgY2FsY3VsYXRlZE1hYyA9IGhtYWNBYWQoaG1hY19rZXksIGNpcGhlcnRleHQsIG5vbmNlKTtcbiAgaWYgKCFlcXVhbEJ5dGVzKGNhbGN1bGF0ZWRNYWMsIG1hYykpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBNQUNcIik7XG4gIGNvbnN0IHBhZGRlZCA9IGNoYWNoYTIwKGNoYWNoYV9rZXksIGNoYWNoYV9ub25jZSwgY2lwaGVydGV4dCk7XG4gIHJldHVybiB1bnBhZChwYWRkZWQpO1xufVxudmFyIHYyID0ge1xuICB1dGlsczoge1xuICAgIGdldENvbnZlcnNhdGlvbktleSxcbiAgICBjYWxjUGFkZGVkTGVuXG4gIH0sXG4gIGVuY3J5cHQ6IGVuY3J5cHQyLFxuICBkZWNyeXB0OiBkZWNyeXB0MlxufTtcblxuLy8gbmlwNDcudHNcbnZhciBuaXA0N19leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXA0N19leHBvcnRzLCB7XG4gIG1ha2VOd2NSZXF1ZXN0RXZlbnQ6ICgpID0+IG1ha2VOd2NSZXF1ZXN0RXZlbnQsXG4gIHBhcnNlQ29ubmVjdGlvblN0cmluZzogKCkgPT4gcGFyc2VDb25uZWN0aW9uU3RyaW5nXG59KTtcbmZ1bmN0aW9uIHBhcnNlQ29ubmVjdGlvblN0cmluZyhjb25uZWN0aW9uU3RyaW5nKSB7XG4gIGNvbnN0IHsgcGF0aG5hbWUsIHNlYXJjaFBhcmFtcyB9ID0gbmV3IFVSTChjb25uZWN0aW9uU3RyaW5nKTtcbiAgY29uc3QgcHVia2V5ID0gcGF0aG5hbWU7XG4gIGNvbnN0IHJlbGF5ID0gc2VhcmNoUGFyYW1zLmdldChcInJlbGF5XCIpO1xuICBjb25zdCBzZWNyZXQgPSBzZWFyY2hQYXJhbXMuZ2V0KFwic2VjcmV0XCIpO1xuICBpZiAoIXB1YmtleSB8fCAhcmVsYXkgfHwgIXNlY3JldCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgY29ubmVjdGlvbiBzdHJpbmdcIik7XG4gIH1cbiAgcmV0dXJuIHsgcHVia2V5LCByZWxheSwgc2VjcmV0IH07XG59XG5hc3luYyBmdW5jdGlvbiBtYWtlTndjUmVxdWVzdEV2ZW50KHB1YmtleSwgc2VjcmV0S2V5LCBpbnZvaWNlKSB7XG4gIGNvbnN0IGNvbnRlbnQgPSB7XG4gICAgbWV0aG9kOiBcInBheV9pbnZvaWNlXCIsXG4gICAgcGFyYW1zOiB7XG4gICAgICBpbnZvaWNlXG4gICAgfVxuICB9O1xuICBjb25zdCBlbmNyeXB0ZWRDb250ZW50ID0gYXdhaXQgZW5jcnlwdChzZWNyZXRLZXksIHB1YmtleSwgSlNPTi5zdHJpbmdpZnkoY29udGVudCkpO1xuICBjb25zdCBldmVudFRlbXBsYXRlID0ge1xuICAgIGtpbmQ6IE5XQ1dhbGxldFJlcXVlc3QsXG4gICAgY3JlYXRlZF9hdDogTWF0aC5yb3VuZChEYXRlLm5vdygpIC8gMWUzKSxcbiAgICBjb250ZW50OiBlbmNyeXB0ZWRDb250ZW50LFxuICAgIHRhZ3M6IFtbXCJwXCIsIHB1YmtleV1dXG4gIH07XG4gIHJldHVybiBmaW5hbGl6ZUV2ZW50KGV2ZW50VGVtcGxhdGUsIHNlY3JldEtleSk7XG59XG5cbi8vIG5pcDU3LnRzXG52YXIgbmlwNTdfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobmlwNTdfZXhwb3J0cywge1xuICBnZXRaYXBFbmRwb2ludDogKCkgPT4gZ2V0WmFwRW5kcG9pbnQsXG4gIG1ha2VaYXBSZWNlaXB0OiAoKSA9PiBtYWtlWmFwUmVjZWlwdCxcbiAgbWFrZVphcFJlcXVlc3Q6ICgpID0+IG1ha2VaYXBSZXF1ZXN0LFxuICB1c2VGZXRjaEltcGxlbWVudGF0aW9uOiAoKSA9PiB1c2VGZXRjaEltcGxlbWVudGF0aW9uNCxcbiAgdmFsaWRhdGVaYXBSZXF1ZXN0OiAoKSA9PiB2YWxpZGF0ZVphcFJlcXVlc3Rcbn0pO1xuaW1wb3J0IHsgYmVjaDMyIGFzIGJlY2gzMjIgfSBmcm9tIFwiQHNjdXJlL2Jhc2VcIjtcbnZhciBfZmV0Y2g0O1xudHJ5IHtcbiAgX2ZldGNoNCA9IGZldGNoO1xufSBjYXRjaCB7XG59XG5mdW5jdGlvbiB1c2VGZXRjaEltcGxlbWVudGF0aW9uNChmZXRjaEltcGxlbWVudGF0aW9uKSB7XG4gIF9mZXRjaDQgPSBmZXRjaEltcGxlbWVudGF0aW9uO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0WmFwRW5kcG9pbnQobWV0YWRhdGEpIHtcbiAgdHJ5IHtcbiAgICBsZXQgbG51cmwgPSBcIlwiO1xuICAgIGxldCB7IGx1ZDA2LCBsdWQxNiB9ID0gSlNPTi5wYXJzZShtZXRhZGF0YS5jb250ZW50KTtcbiAgICBpZiAobHVkMDYpIHtcbiAgICAgIGxldCB7IHdvcmRzIH0gPSBiZWNoMzIyLmRlY29kZShsdWQwNiwgMWUzKTtcbiAgICAgIGxldCBkYXRhID0gYmVjaDMyMi5mcm9tV29yZHMod29yZHMpO1xuICAgICAgbG51cmwgPSB1dGY4RGVjb2Rlci5kZWNvZGUoZGF0YSk7XG4gICAgfSBlbHNlIGlmIChsdWQxNikge1xuICAgICAgbGV0IFtuYW1lLCBkb21haW5dID0gbHVkMTYuc3BsaXQoXCJAXCIpO1xuICAgICAgbG51cmwgPSBuZXcgVVJMKGAvLndlbGwta25vd24vbG51cmxwLyR7bmFtZX1gLCBgaHR0cHM6Ly8ke2RvbWFpbn1gKS50b1N0cmluZygpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgbGV0IHJlcyA9IGF3YWl0IF9mZXRjaDQobG51cmwpO1xuICAgIGxldCBib2R5ID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICBpZiAoYm9keS5hbGxvd3NOb3N0ciAmJiBib2R5Lm5vc3RyUHVia2V5KSB7XG4gICAgICByZXR1cm4gYm9keS5jYWxsYmFjaztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gbWFrZVphcFJlcXVlc3Qoe1xuICBwcm9maWxlLFxuICBldmVudCxcbiAgYW1vdW50LFxuICByZWxheXMsXG4gIGNvbW1lbnQgPSBcIlwiXG59KSB7XG4gIGlmICghYW1vdW50KVxuICAgIHRocm93IG5ldyBFcnJvcihcImFtb3VudCBub3QgZ2l2ZW5cIik7XG4gIGlmICghcHJvZmlsZSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJwcm9maWxlIG5vdCBnaXZlblwiKTtcbiAgbGV0IHpyID0ge1xuICAgIGtpbmQ6IDk3MzQsXG4gICAgY3JlYXRlZF9hdDogTWF0aC5yb3VuZChEYXRlLm5vdygpIC8gMWUzKSxcbiAgICBjb250ZW50OiBjb21tZW50LFxuICAgIHRhZ3M6IFtcbiAgICAgIFtcInBcIiwgcHJvZmlsZV0sXG4gICAgICBbXCJhbW91bnRcIiwgYW1vdW50LnRvU3RyaW5nKCldLFxuICAgICAgW1wicmVsYXlzXCIsIC4uLnJlbGF5c11cbiAgICBdXG4gIH07XG4gIGlmIChldmVudCkge1xuICAgIHpyLnRhZ3MucHVzaChbXCJlXCIsIGV2ZW50XSk7XG4gIH1cbiAgcmV0dXJuIHpyO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVaYXBSZXF1ZXN0KHphcFJlcXVlc3RTdHJpbmcpIHtcbiAgbGV0IHphcFJlcXVlc3Q7XG4gIHRyeSB7XG4gICAgemFwUmVxdWVzdCA9IEpTT04ucGFyc2UoemFwUmVxdWVzdFN0cmluZyk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBcIkludmFsaWQgemFwIHJlcXVlc3QgSlNPTi5cIjtcbiAgfVxuICBpZiAoIXZhbGlkYXRlRXZlbnQoemFwUmVxdWVzdCkpXG4gICAgcmV0dXJuIFwiWmFwIHJlcXVlc3QgaXMgbm90IGEgdmFsaWQgTm9zdHIgZXZlbnQuXCI7XG4gIGlmICghdmVyaWZ5RXZlbnQoemFwUmVxdWVzdCkpXG4gICAgcmV0dXJuIFwiSW52YWxpZCBzaWduYXR1cmUgb24gemFwIHJlcXVlc3QuXCI7XG4gIGxldCBwID0gemFwUmVxdWVzdC50YWdzLmZpbmQoKFt0LCB2XSkgPT4gdCA9PT0gXCJwXCIgJiYgdik7XG4gIGlmICghcClcbiAgICByZXR1cm4gXCJaYXAgcmVxdWVzdCBkb2Vzbid0IGhhdmUgYSAncCcgdGFnLlwiO1xuICBpZiAoIXBbMV0ubWF0Y2goL15bYS1mMC05XXs2NH0kLykpXG4gICAgcmV0dXJuIFwiWmFwIHJlcXVlc3QgJ3AnIHRhZyBpcyBub3QgdmFsaWQgaGV4LlwiO1xuICBsZXQgZSA9IHphcFJlcXVlc3QudGFncy5maW5kKChbdCwgdl0pID0+IHQgPT09IFwiZVwiICYmIHYpO1xuICBpZiAoZSAmJiAhZVsxXS5tYXRjaCgvXlthLWYwLTldezY0fSQvKSlcbiAgICByZXR1cm4gXCJaYXAgcmVxdWVzdCAnZScgdGFnIGlzIG5vdCB2YWxpZCBoZXguXCI7XG4gIGxldCByZWxheXMgPSB6YXBSZXF1ZXN0LnRhZ3MuZmluZCgoW3QsIHZdKSA9PiB0ID09PSBcInJlbGF5c1wiICYmIHYpO1xuICBpZiAoIXJlbGF5cylcbiAgICByZXR1cm4gXCJaYXAgcmVxdWVzdCBkb2Vzbid0IGhhdmUgYSAncmVsYXlzJyB0YWcuXCI7XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gbWFrZVphcFJlY2VpcHQoe1xuICB6YXBSZXF1ZXN0LFxuICBwcmVpbWFnZSxcbiAgYm9sdDExLFxuICBwYWlkQXRcbn0pIHtcbiAgbGV0IHpyID0gSlNPTi5wYXJzZSh6YXBSZXF1ZXN0KTtcbiAgbGV0IHRhZ3NGcm9tWmFwUmVxdWVzdCA9IHpyLnRhZ3MuZmlsdGVyKChbdF0pID0+IHQgPT09IFwiZVwiIHx8IHQgPT09IFwicFwiIHx8IHQgPT09IFwiYVwiKTtcbiAgbGV0IHphcCA9IHtcbiAgICBraW5kOiA5NzM1LFxuICAgIGNyZWF0ZWRfYXQ6IE1hdGgucm91bmQocGFpZEF0LmdldFRpbWUoKSAvIDFlMyksXG4gICAgY29udGVudDogXCJcIixcbiAgICB0YWdzOiBbLi4udGFnc0Zyb21aYXBSZXF1ZXN0LCBbXCJQXCIsIHpyLnB1YmtleV0sIFtcImJvbHQxMVwiLCBib2x0MTFdLCBbXCJkZXNjcmlwdGlvblwiLCB6YXBSZXF1ZXN0XV1cbiAgfTtcbiAgaWYgKHByZWltYWdlKSB7XG4gICAgemFwLnRhZ3MucHVzaChbXCJwcmVpbWFnZVwiLCBwcmVpbWFnZV0pO1xuICB9XG4gIHJldHVybiB6YXA7XG59XG5cbi8vIG5pcDU5LnRzXG52YXIgbmlwNTlfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobmlwNTlfZXhwb3J0cywge1xuICBjcmVhdGVSdW1vcjogKCkgPT4gY3JlYXRlUnVtb3IsXG4gIGNyZWF0ZVNlYWw6ICgpID0+IGNyZWF0ZVNlYWwsXG4gIGNyZWF0ZVdyYXA6ICgpID0+IGNyZWF0ZVdyYXAsXG4gIHVud3JhcEV2ZW50OiAoKSA9PiB1bndyYXBFdmVudCxcbiAgdW53cmFwTWFueUV2ZW50czogKCkgPT4gdW53cmFwTWFueUV2ZW50cyxcbiAgd3JhcEV2ZW50OiAoKSA9PiB3cmFwRXZlbnQsXG4gIHdyYXBNYW55RXZlbnRzOiAoKSA9PiB3cmFwTWFueUV2ZW50c1xufSk7XG52YXIgVFdPX0RBWVMgPSAyICogMjQgKiA2MCAqIDYwO1xudmFyIG5vdyA9ICgpID0+IE1hdGgucm91bmQoRGF0ZS5ub3coKSAvIDFlMyk7XG52YXIgcmFuZG9tTm93ID0gKCkgPT4gTWF0aC5yb3VuZChub3coKSAtIE1hdGgucmFuZG9tKCkgKiBUV09fREFZUyk7XG52YXIgbmlwNDRDb252ZXJzYXRpb25LZXkgPSAocHJpdmF0ZUtleSwgcHVibGljS2V5KSA9PiBnZXRDb252ZXJzYXRpb25LZXkocHJpdmF0ZUtleSwgcHVibGljS2V5KTtcbnZhciBuaXA0NEVuY3J5cHQgPSAoZGF0YSwgcHJpdmF0ZUtleSwgcHVibGljS2V5KSA9PiBlbmNyeXB0MihKU09OLnN0cmluZ2lmeShkYXRhKSwgbmlwNDRDb252ZXJzYXRpb25LZXkocHJpdmF0ZUtleSwgcHVibGljS2V5KSk7XG52YXIgbmlwNDREZWNyeXB0ID0gKGRhdGEsIHByaXZhdGVLZXkpID0+IEpTT04ucGFyc2UoZGVjcnlwdDIoZGF0YS5jb250ZW50LCBuaXA0NENvbnZlcnNhdGlvbktleShwcml2YXRlS2V5LCBkYXRhLnB1YmtleSkpKTtcbmZ1bmN0aW9uIGNyZWF0ZVJ1bW9yKGV2ZW50LCBwcml2YXRlS2V5KSB7XG4gIGNvbnN0IHJ1bW9yID0ge1xuICAgIGNyZWF0ZWRfYXQ6IG5vdygpLFxuICAgIGNvbnRlbnQ6IFwiXCIsXG4gICAgdGFnczogW10sXG4gICAgLi4uZXZlbnQsXG4gICAgcHVia2V5OiBnZXRQdWJsaWNLZXkocHJpdmF0ZUtleSlcbiAgfTtcbiAgcnVtb3IuaWQgPSBnZXRFdmVudEhhc2gocnVtb3IpO1xuICByZXR1cm4gcnVtb3I7XG59XG5mdW5jdGlvbiBjcmVhdGVTZWFsKHJ1bW9yLCBwcml2YXRlS2V5LCByZWNpcGllbnRQdWJsaWNLZXkpIHtcbiAgcmV0dXJuIGZpbmFsaXplRXZlbnQoXG4gICAge1xuICAgICAga2luZDogU2VhbCxcbiAgICAgIGNvbnRlbnQ6IG5pcDQ0RW5jcnlwdChydW1vciwgcHJpdmF0ZUtleSwgcmVjaXBpZW50UHVibGljS2V5KSxcbiAgICAgIGNyZWF0ZWRfYXQ6IHJhbmRvbU5vdygpLFxuICAgICAgdGFnczogW11cbiAgICB9LFxuICAgIHByaXZhdGVLZXlcbiAgKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVdyYXAoc2VhbCwgcmVjaXBpZW50UHVibGljS2V5KSB7XG4gIGNvbnN0IHJhbmRvbUtleSA9IGdlbmVyYXRlU2VjcmV0S2V5KCk7XG4gIHJldHVybiBmaW5hbGl6ZUV2ZW50KFxuICAgIHtcbiAgICAgIGtpbmQ6IEdpZnRXcmFwLFxuICAgICAgY29udGVudDogbmlwNDRFbmNyeXB0KHNlYWwsIHJhbmRvbUtleSwgcmVjaXBpZW50UHVibGljS2V5KSxcbiAgICAgIGNyZWF0ZWRfYXQ6IHJhbmRvbU5vdygpLFxuICAgICAgdGFnczogW1tcInBcIiwgcmVjaXBpZW50UHVibGljS2V5XV1cbiAgICB9LFxuICAgIHJhbmRvbUtleVxuICApO1xufVxuZnVuY3Rpb24gd3JhcEV2ZW50KGV2ZW50LCBzZW5kZXJQcml2YXRlS2V5LCByZWNpcGllbnRQdWJsaWNLZXkpIHtcbiAgY29uc3QgcnVtb3IgPSBjcmVhdGVSdW1vcihldmVudCwgc2VuZGVyUHJpdmF0ZUtleSk7XG4gIGNvbnN0IHNlYWwgPSBjcmVhdGVTZWFsKHJ1bW9yLCBzZW5kZXJQcml2YXRlS2V5LCByZWNpcGllbnRQdWJsaWNLZXkpO1xuICByZXR1cm4gY3JlYXRlV3JhcChzZWFsLCByZWNpcGllbnRQdWJsaWNLZXkpO1xufVxuZnVuY3Rpb24gd3JhcE1hbnlFdmVudHMoZXZlbnQsIHNlbmRlclByaXZhdGVLZXksIHJlY2lwaWVudHNQdWJsaWNLZXlzKSB7XG4gIGlmICghcmVjaXBpZW50c1B1YmxpY0tleXMgfHwgcmVjaXBpZW50c1B1YmxpY0tleXMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQXQgbGVhc3Qgb25lIHJlY2lwaWVudCBpcyByZXF1aXJlZC5cIik7XG4gIH1cbiAgY29uc3Qgc2VuZGVyUHVibGljS2V5ID0gZ2V0UHVibGljS2V5KHNlbmRlclByaXZhdGVLZXkpO1xuICBjb25zdCB3cmFwcGVkcyA9IFt3cmFwRXZlbnQoZXZlbnQsIHNlbmRlclByaXZhdGVLZXksIHNlbmRlclB1YmxpY0tleSldO1xuICByZWNpcGllbnRzUHVibGljS2V5cy5mb3JFYWNoKChyZWNpcGllbnRQdWJsaWNLZXkpID0+IHtcbiAgICB3cmFwcGVkcy5wdXNoKHdyYXBFdmVudChldmVudCwgc2VuZGVyUHJpdmF0ZUtleSwgcmVjaXBpZW50UHVibGljS2V5KSk7XG4gIH0pO1xuICByZXR1cm4gd3JhcHBlZHM7XG59XG5mdW5jdGlvbiB1bndyYXBFdmVudCh3cmFwLCByZWNpcGllbnRQcml2YXRlS2V5KSB7XG4gIGNvbnN0IHVud3JhcHBlZFNlYWwgPSBuaXA0NERlY3J5cHQod3JhcCwgcmVjaXBpZW50UHJpdmF0ZUtleSk7XG4gIHJldHVybiBuaXA0NERlY3J5cHQodW53cmFwcGVkU2VhbCwgcmVjaXBpZW50UHJpdmF0ZUtleSk7XG59XG5mdW5jdGlvbiB1bndyYXBNYW55RXZlbnRzKHdyYXBwZWRFdmVudHMsIHJlY2lwaWVudFByaXZhdGVLZXkpIHtcbiAgbGV0IHVud3JhcHBlZEV2ZW50cyA9IFtdO1xuICB3cmFwcGVkRXZlbnRzLmZvckVhY2goKGUpID0+IHtcbiAgICB1bndyYXBwZWRFdmVudHMucHVzaCh1bndyYXBFdmVudChlLCByZWNpcGllbnRQcml2YXRlS2V5KSk7XG4gIH0pO1xuICB1bndyYXBwZWRFdmVudHMuc29ydCgoYSwgYikgPT4gYS5jcmVhdGVkX2F0IC0gYi5jcmVhdGVkX2F0KTtcbiAgcmV0dXJuIHVud3JhcHBlZEV2ZW50cztcbn1cblxuLy8gbmlwOTgudHNcbnZhciBuaXA5OF9leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXA5OF9leHBvcnRzLCB7XG4gIGdldFRva2VuOiAoKSA9PiBnZXRUb2tlbixcbiAgaGFzaFBheWxvYWQ6ICgpID0+IGhhc2hQYXlsb2FkLFxuICB1bnBhY2tFdmVudEZyb21Ub2tlbjogKCkgPT4gdW5wYWNrRXZlbnRGcm9tVG9rZW4sXG4gIHZhbGlkYXRlRXZlbnQ6ICgpID0+IHZhbGlkYXRlRXZlbnQyLFxuICB2YWxpZGF0ZUV2ZW50S2luZDogKCkgPT4gdmFsaWRhdGVFdmVudEtpbmQsXG4gIHZhbGlkYXRlRXZlbnRNZXRob2RUYWc6ICgpID0+IHZhbGlkYXRlRXZlbnRNZXRob2RUYWcsXG4gIHZhbGlkYXRlRXZlbnRQYXlsb2FkVGFnOiAoKSA9PiB2YWxpZGF0ZUV2ZW50UGF5bG9hZFRhZyxcbiAgdmFsaWRhdGVFdmVudFRpbWVzdGFtcDogKCkgPT4gdmFsaWRhdGVFdmVudFRpbWVzdGFtcCxcbiAgdmFsaWRhdGVFdmVudFVybFRhZzogKCkgPT4gdmFsaWRhdGVFdmVudFVybFRhZyxcbiAgdmFsaWRhdGVUb2tlbjogKCkgPT4gdmFsaWRhdGVUb2tlblxufSk7XG5pbXBvcnQgeyBzaGEyNTYgYXMgc2hhMjU2NCB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3NoYTI1NlwiO1xuaW1wb3J0IHsgYnl0ZXNUb0hleCBhcyBieXRlc1RvSGV4NSB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3V0aWxzXCI7XG5pbXBvcnQgeyBiYXNlNjQgYXMgYmFzZTY0MyB9IGZyb20gXCJAc2N1cmUvYmFzZVwiO1xudmFyIF9hdXRob3JpemF0aW9uU2NoZW1lID0gXCJOb3N0ciBcIjtcbmFzeW5jIGZ1bmN0aW9uIGdldFRva2VuKGxvZ2luVXJsLCBodHRwTWV0aG9kLCBzaWduLCBpbmNsdWRlQXV0aG9yaXphdGlvblNjaGVtZSA9IGZhbHNlLCBwYXlsb2FkKSB7XG4gIGNvbnN0IGV2ZW50ID0ge1xuICAgIGtpbmQ6IEhUVFBBdXRoLFxuICAgIHRhZ3M6IFtcbiAgICAgIFtcInVcIiwgbG9naW5VcmxdLFxuICAgICAgW1wibWV0aG9kXCIsIGh0dHBNZXRob2RdXG4gICAgXSxcbiAgICBjcmVhdGVkX2F0OiBNYXRoLnJvdW5kKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMWUzKSxcbiAgICBjb250ZW50OiBcIlwiXG4gIH07XG4gIGlmIChwYXlsb2FkKSB7XG4gICAgZXZlbnQudGFncy5wdXNoKFtcInBheWxvYWRcIiwgaGFzaFBheWxvYWQocGF5bG9hZCldKTtcbiAgfVxuICBjb25zdCBzaWduZWRFdmVudCA9IGF3YWl0IHNpZ24oZXZlbnQpO1xuICBjb25zdCBhdXRob3JpemF0aW9uU2NoZW1lID0gaW5jbHVkZUF1dGhvcml6YXRpb25TY2hlbWUgPyBfYXV0aG9yaXphdGlvblNjaGVtZSA6IFwiXCI7XG4gIHJldHVybiBhdXRob3JpemF0aW9uU2NoZW1lICsgYmFzZTY0My5lbmNvZGUodXRmOEVuY29kZXIuZW5jb2RlKEpTT04uc3RyaW5naWZ5KHNpZ25lZEV2ZW50KSkpO1xufVxuYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVUb2tlbih0b2tlbiwgdXJsLCBtZXRob2QpIHtcbiAgY29uc3QgZXZlbnQgPSBhd2FpdCB1bnBhY2tFdmVudEZyb21Ub2tlbih0b2tlbikuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH0pO1xuICBjb25zdCB2YWxpZCA9IGF3YWl0IHZhbGlkYXRlRXZlbnQyKGV2ZW50LCB1cmwsIG1ldGhvZCkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH0pO1xuICByZXR1cm4gdmFsaWQ7XG59XG5hc3luYyBmdW5jdGlvbiB1bnBhY2tFdmVudEZyb21Ub2tlbih0b2tlbikge1xuICBpZiAoIXRva2VuKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB0b2tlblwiKTtcbiAgfVxuICB0b2tlbiA9IHRva2VuLnJlcGxhY2UoX2F1dGhvcml6YXRpb25TY2hlbWUsIFwiXCIpO1xuICBjb25zdCBldmVudEI2NCA9IHV0ZjhEZWNvZGVyLmRlY29kZShiYXNlNjQzLmRlY29kZSh0b2tlbikpO1xuICBpZiAoIWV2ZW50QjY0IHx8IGV2ZW50QjY0Lmxlbmd0aCA9PT0gMCB8fCAhZXZlbnRCNjQuc3RhcnRzV2l0aChcIntcIikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHRva2VuXCIpO1xuICB9XG4gIGNvbnN0IGV2ZW50ID0gSlNPTi5wYXJzZShldmVudEI2NCk7XG4gIHJldHVybiBldmVudDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlRXZlbnRUaW1lc3RhbXAoZXZlbnQpIHtcbiAgaWYgKCFldmVudC5jcmVhdGVkX2F0KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBNYXRoLnJvdW5kKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMWUzKSAtIGV2ZW50LmNyZWF0ZWRfYXQgPCA2MDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlRXZlbnRLaW5kKGV2ZW50KSB7XG4gIHJldHVybiBldmVudC5raW5kID09PSBIVFRQQXV0aDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlRXZlbnRVcmxUYWcoZXZlbnQsIHVybCkge1xuICBjb25zdCB1cmxUYWcgPSBldmVudC50YWdzLmZpbmQoKHQpID0+IHRbMF0gPT09IFwidVwiKTtcbiAgaWYgKCF1cmxUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHVybFRhZy5sZW5ndGggPiAwICYmIHVybFRhZ1sxXSA9PT0gdXJsO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVFdmVudE1ldGhvZFRhZyhldmVudCwgbWV0aG9kKSB7XG4gIGNvbnN0IG1ldGhvZFRhZyA9IGV2ZW50LnRhZ3MuZmluZCgodCkgPT4gdFswXSA9PT0gXCJtZXRob2RcIik7XG4gIGlmICghbWV0aG9kVGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBtZXRob2RUYWcubGVuZ3RoID4gMCAmJiBtZXRob2RUYWdbMV0udG9Mb3dlckNhc2UoKSA9PT0gbWV0aG9kLnRvTG93ZXJDYXNlKCk7XG59XG5mdW5jdGlvbiBoYXNoUGF5bG9hZChwYXlsb2FkKSB7XG4gIGNvbnN0IGhhc2ggPSBzaGEyNTY0KHV0ZjhFbmNvZGVyLmVuY29kZShKU09OLnN0cmluZ2lmeShwYXlsb2FkKSkpO1xuICByZXR1cm4gYnl0ZXNUb0hleDUoaGFzaCk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUV2ZW50UGF5bG9hZFRhZyhldmVudCwgcGF5bG9hZCkge1xuICBjb25zdCBwYXlsb2FkVGFnID0gZXZlbnQudGFncy5maW5kKCh0KSA9PiB0WzBdID09PSBcInBheWxvYWRcIik7XG4gIGlmICghcGF5bG9hZFRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBwYXlsb2FkSGFzaCA9IGhhc2hQYXlsb2FkKHBheWxvYWQpO1xuICByZXR1cm4gcGF5bG9hZFRhZy5sZW5ndGggPiAwICYmIHBheWxvYWRUYWdbMV0gPT09IHBheWxvYWRIYXNoO1xufVxuYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVFdmVudDIoZXZlbnQsIHVybCwgbWV0aG9kLCBib2R5KSB7XG4gIGlmICghdmVyaWZ5RXZlbnQoZXZlbnQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBub3N0ciBldmVudCwgc2lnbmF0dXJlIGludmFsaWRcIik7XG4gIH1cbiAgaWYgKCF2YWxpZGF0ZUV2ZW50S2luZChldmVudCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG5vc3RyIGV2ZW50LCBraW5kIGludmFsaWRcIik7XG4gIH1cbiAgaWYgKCF2YWxpZGF0ZUV2ZW50VGltZXN0YW1wKGV2ZW50KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbm9zdHIgZXZlbnQsIGNyZWF0ZWRfYXQgdGltZXN0YW1wIGludmFsaWRcIik7XG4gIH1cbiAgaWYgKCF2YWxpZGF0ZUV2ZW50VXJsVGFnKGV2ZW50LCB1cmwpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBub3N0ciBldmVudCwgdXJsIHRhZyBpbnZhbGlkXCIpO1xuICB9XG4gIGlmICghdmFsaWRhdGVFdmVudE1ldGhvZFRhZyhldmVudCwgbWV0aG9kKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbm9zdHIgZXZlbnQsIG1ldGhvZCB0YWcgaW52YWxpZFwiKTtcbiAgfVxuICBpZiAoQm9vbGVhbihib2R5KSAmJiB0eXBlb2YgYm9keSA9PT0gXCJvYmplY3RcIiAmJiBPYmplY3Qua2V5cyhib2R5KS5sZW5ndGggPiAwKSB7XG4gICAgaWYgKCF2YWxpZGF0ZUV2ZW50UGF5bG9hZFRhZyhldmVudCwgYm9keSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbm9zdHIgZXZlbnQsIHBheWxvYWQgdGFnIGRvZXMgbm90IG1hdGNoIHJlcXVlc3QgYm9keSBoYXNoXCIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydCB7XG4gIFJlbGF5LFxuICBTaW1wbGVQb29sLFxuICBmaW5hbGl6ZUV2ZW50LFxuICBmYWtlanNvbl9leHBvcnRzIGFzIGZqLFxuICBnZW5lcmF0ZVNlY3JldEtleSxcbiAgZ2V0RXZlbnRIYXNoLFxuICBnZXRGaWx0ZXJMaW1pdCxcbiAgZ2V0UHVibGljS2V5LFxuICBraW5kc19leHBvcnRzIGFzIGtpbmRzLFxuICBtYXRjaEZpbHRlcixcbiAgbWF0Y2hGaWx0ZXJzLFxuICBtZXJnZUZpbHRlcnMsXG4gIG5pcDA0X2V4cG9ydHMgYXMgbmlwMDQsXG4gIG5pcDA1X2V4cG9ydHMgYXMgbmlwMDUsXG4gIG5pcDEwX2V4cG9ydHMgYXMgbmlwMTAsXG4gIG5pcDExX2V4cG9ydHMgYXMgbmlwMTEsXG4gIG5pcDEzX2V4cG9ydHMgYXMgbmlwMTMsXG4gIG5pcDE4X2V4cG9ydHMgYXMgbmlwMTgsXG4gIG5pcDE5X2V4cG9ydHMgYXMgbmlwMTksXG4gIG5pcDIxX2V4cG9ydHMgYXMgbmlwMjEsXG4gIG5pcDI1X2V4cG9ydHMgYXMgbmlwMjUsXG4gIG5pcDI3X2V4cG9ydHMgYXMgbmlwMjcsXG4gIG5pcDI4X2V4cG9ydHMgYXMgbmlwMjgsXG4gIG5pcDMwX2V4cG9ydHMgYXMgbmlwMzAsXG4gIG5pcDM5X2V4cG9ydHMgYXMgbmlwMzksXG4gIG5pcDQyX2V4cG9ydHMgYXMgbmlwNDIsXG4gIG5pcDQ0X2V4cG9ydHMgYXMgbmlwNDQsXG4gIG5pcDQ3X2V4cG9ydHMgYXMgbmlwNDcsXG4gIG5pcDU3X2V4cG9ydHMgYXMgbmlwNTcsXG4gIG5pcDU5X2V4cG9ydHMgYXMgbmlwNTksXG4gIG5pcDk4X2V4cG9ydHMgYXMgbmlwOTgsXG4gIHBhcnNlUmVmZXJlbmNlcyxcbiAgc2VyaWFsaXplRXZlbnQsXG4gIHNvcnRFdmVudHMsXG4gIHV0aWxzX2V4cG9ydHMgYXMgdXRpbHMsXG4gIHZhbGlkYXRlRXZlbnQsXG4gIHZlcmlmaWVkU3ltYm9sLFxuICB2ZXJpZnlFdmVudFxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/lib/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/_shortw_utils.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/_shortw_utils.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createCurve: () => (/* binding */ createCurve),\n/* harmony export */   getHash: () => (/* binding */ getHash)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/hmac */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/hmac.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\n\n// connects noble-curves to noble-hashes\nfunction getHash(hash) {\n    return {\n        hash,\n        hmac: (key, ...msgs) => (0,_noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__.hmac)(hash, key, (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(...msgs)),\n        randomBytes: _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.randomBytes,\n    };\n}\nfunction createCurve(curveDef, defHash) {\n    const create = (hash) => (0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__.weierstrass)({ ...curveDef, ...getHash(hash) });\n    return Object.freeze({ ...create(defHash), create });\n}\n//# sourceMappingURL=_shortw_utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vX3Nob3J0d191dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQzBDO0FBQ3FCO0FBQ1A7QUFDeEQ7QUFDTztBQUNQO0FBQ0E7QUFDQSxnQ0FBZ0Msd0RBQUksWUFBWSxnRUFBVztBQUMzRCxtQkFBbUI7QUFDbkI7QUFDQTtBQUNPO0FBQ1AsNkJBQTZCLHFFQUFXLEdBQUcsK0JBQStCO0FBQzFFLDJCQUEyQiw0QkFBNEI7QUFDdkQ7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbGZnL0dpdC9NYWR0cmlwcy9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vX3Nob3J0d191dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5pbXBvcnQgeyBobWFjIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9obWFjJztcbmltcG9ydCB7IGNvbmNhdEJ5dGVzLCByYW5kb21CeXRlcyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvdXRpbHMnO1xuaW1wb3J0IHsgd2VpZXJzdHJhc3MgfSBmcm9tICcuL2Fic3RyYWN0L3dlaWVyc3RyYXNzLmpzJztcbi8vIGNvbm5lY3RzIG5vYmxlLWN1cnZlcyB0byBub2JsZS1oYXNoZXNcbmV4cG9ydCBmdW5jdGlvbiBnZXRIYXNoKGhhc2gpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBoYXNoLFxuICAgICAgICBobWFjOiAoa2V5LCAuLi5tc2dzKSA9PiBobWFjKGhhc2gsIGtleSwgY29uY2F0Qnl0ZXMoLi4ubXNncykpLFxuICAgICAgICByYW5kb21CeXRlcyxcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUN1cnZlKGN1cnZlRGVmLCBkZWZIYXNoKSB7XG4gICAgY29uc3QgY3JlYXRlID0gKGhhc2gpID0+IHdlaWVyc3RyYXNzKHsgLi4uY3VydmVEZWYsIC4uLmdldEhhc2goaGFzaCkgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyAuLi5jcmVhdGUoZGVmSGFzaCksIGNyZWF0ZSB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9zaG9ydHdfdXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/_shortw_utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/curve.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/curve.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   validateBasic: () => (/* binding */ validateBasic),\n/* harmony export */   wNAF: () => (/* binding */ wNAF)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Abelian group utilities\n\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n// Elliptic curve multiplication of Point by scalar. Fragile.\n// Scalars should always be less than curve order: this should be checked inside of a curve itself.\n// Creates precomputation tables for fast multiplication:\n// - private scalar is split by fixed size windows of W bits\n// - every window point is collected from window's table & added to accumulator\n// - since windows are different, same point inside tables won't be accessed more than once per calc\n// - each multiplication is 'Math.ceil(CURVE_ORDER / ) + 1' point additions (fixed for any scalar)\n// - +1 window is neccessary for wNAF\n// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow\n// windows to be in different memory locations\nfunction wNAF(c, bits) {\n    const constTimeNegate = (condition, item) => {\n        const neg = item.negate();\n        return condition ? neg : item;\n    };\n    const opts = (W) => {\n        const windows = Math.ceil(bits / W) + 1; // +1, because\n        const windowSize = 2 ** (W - 1); // -1 because we skip zero\n        return { windows, windowSize };\n    };\n    return {\n        constTimeNegate,\n        // non-const time multiplication ladder\n        unsafeLadder(elm, n) {\n            let p = c.ZERO;\n            let d = elm;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(1) * (Math.ceil( / ) + 1), where:\n         * -  is the window size\n         * -  is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @returns precomputed point tables flattened to a single array\n         */\n        precomputeWindow(elm, W) {\n            const { windows, windowSize } = opts(W);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for (let window = 0; window < windows; window++) {\n                base = p;\n                points.push(base);\n                // =1, because we skip zero\n                for (let i = 1; i < windowSize; i++) {\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */\n        wNAF(W, precomputes, n) {\n            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n            // But need to carefully remove other checks before wNAF. ORDER == bits here\n            const { windows, windowSize } = opts(W);\n            let p = c.ZERO;\n            let f = c.BASE;\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for (let window = 0; window < windows; window++) {\n                const offset = window * windowSize;\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n                // there is negate now: it is possible that negated element from low value\n                // would be the same as high element, which will create carry into next window.\n                // It's not obvious how this can fail, but still worth investigating later.\n                // Check if we're onto Zero point.\n                // Add random point inside current window to f.\n                const offset1 = offset;\n                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n                const cond1 = window % 2 !== 0;\n                const cond2 = wbits < 0;\n                if (wbits === 0) {\n                    // The most important part for const-time getPublicKey\n                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n                }\n                else {\n                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n                }\n            }\n            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n            // Even if the variable is still unused, there are some checks which will\n            // throw an exception, so compiler needs to prove they won't happen, which is hard.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return { p, f };\n        },\n        wNAFCached(P, precomputesMap, n, transform) {\n            // @ts-ignore\n            const W = P._WINDOW_SIZE || 1;\n            // Calculate precomputes on a first run, reuse them after\n            let comp = precomputesMap.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1) {\n                    precomputesMap.set(P, transform(comp));\n                }\n            }\n            return this.wNAF(W, comp, n);\n        },\n    };\n}\nfunction validateBasic(curve) {\n    (0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.validateField)(curve.Fp);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject)(curve, {\n        n: 'bigint',\n        h: 'bigint',\n        Gx: 'field',\n        Gy: 'field',\n    }, {\n        nBitLength: 'isSafeInteger',\n        nByteLength: 'isSafeInteger',\n    });\n    // Set defaults\n    return Object.freeze({\n        ...(0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.nLength)(curve.n, curve.nBitLength),\n        ...curve,\n        ...{ p: curve.Fp.ORDER },\n    });\n}\n//# sourceMappingURL=curve.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvY3VydmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDc0Q7QUFDVjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCx5Q0FBeUM7QUFDekMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtCQUFrQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0JBQWdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0EsaUNBQWlDLGtCQUFrQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ087QUFDUCxJQUFJLDBEQUFhO0FBQ2pCLElBQUkseURBQWM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsV0FBVyxvREFBTztBQUNsQjtBQUNBLGFBQWEsbUJBQW1CO0FBQ2hDLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9sZmcvR2l0L01hZHRyaXBzL25vZGVfbW9kdWxlcy9Abm9zdHItZGV2LWtpdC9uZGsvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9jdXJ2ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBBYmVsaWFuIGdyb3VwIHV0aWxpdGllc1xuaW1wb3J0IHsgdmFsaWRhdGVGaWVsZCwgbkxlbmd0aCB9IGZyb20gJy4vbW9kdWxhci5qcyc7XG5pbXBvcnQgeyB2YWxpZGF0ZU9iamVjdCB9IGZyb20gJy4vdXRpbHMuanMnO1xuY29uc3QgXzBuID0gQmlnSW50KDApO1xuY29uc3QgXzFuID0gQmlnSW50KDEpO1xuLy8gRWxsaXB0aWMgY3VydmUgbXVsdGlwbGljYXRpb24gb2YgUG9pbnQgYnkgc2NhbGFyLiBGcmFnaWxlLlxuLy8gU2NhbGFycyBzaG91bGQgYWx3YXlzIGJlIGxlc3MgdGhhbiBjdXJ2ZSBvcmRlcjogdGhpcyBzaG91bGQgYmUgY2hlY2tlZCBpbnNpZGUgb2YgYSBjdXJ2ZSBpdHNlbGYuXG4vLyBDcmVhdGVzIHByZWNvbXB1dGF0aW9uIHRhYmxlcyBmb3IgZmFzdCBtdWx0aXBsaWNhdGlvbjpcbi8vIC0gcHJpdmF0ZSBzY2FsYXIgaXMgc3BsaXQgYnkgZml4ZWQgc2l6ZSB3aW5kb3dzIG9mIFcgYml0c1xuLy8gLSBldmVyeSB3aW5kb3cgcG9pbnQgaXMgY29sbGVjdGVkIGZyb20gd2luZG93J3MgdGFibGUgJiBhZGRlZCB0byBhY2N1bXVsYXRvclxuLy8gLSBzaW5jZSB3aW5kb3dzIGFyZSBkaWZmZXJlbnQsIHNhbWUgcG9pbnQgaW5zaWRlIHRhYmxlcyB3b24ndCBiZSBhY2Nlc3NlZCBtb3JlIHRoYW4gb25jZSBwZXIgY2FsY1xuLy8gLSBlYWNoIG11bHRpcGxpY2F0aW9uIGlzICdNYXRoLmNlaWwoQ1VSVkVfT1JERVIgLyDwnZGKKSArIDEnIHBvaW50IGFkZGl0aW9ucyAoZml4ZWQgZm9yIGFueSBzY2FsYXIpXG4vLyAtICsxIHdpbmRvdyBpcyBuZWNjZXNzYXJ5IGZvciB3TkFGXG4vLyAtIHdOQUYgcmVkdWNlcyB0YWJsZSBzaXplOiAyeCBsZXNzIG1lbW9yeSArIDJ4IGZhc3RlciBnZW5lcmF0aW9uLCBidXQgMTAlIHNsb3dlciBtdWx0aXBsaWNhdGlvblxuLy8gVE9ETzogUmVzZWFyY2ggcmV0dXJuaW5nIDJkIEpTIGFycmF5IG9mIHdpbmRvd3MsIGluc3RlYWQgb2YgYSBzaW5nbGUgd2luZG93LiBUaGlzIHdvdWxkIGFsbG93XG4vLyB3aW5kb3dzIHRvIGJlIGluIGRpZmZlcmVudCBtZW1vcnkgbG9jYXRpb25zXG5leHBvcnQgZnVuY3Rpb24gd05BRihjLCBiaXRzKSB7XG4gICAgY29uc3QgY29uc3RUaW1lTmVnYXRlID0gKGNvbmRpdGlvbiwgaXRlbSkgPT4ge1xuICAgICAgICBjb25zdCBuZWcgPSBpdGVtLm5lZ2F0ZSgpO1xuICAgICAgICByZXR1cm4gY29uZGl0aW9uID8gbmVnIDogaXRlbTtcbiAgICB9O1xuICAgIGNvbnN0IG9wdHMgPSAoVykgPT4ge1xuICAgICAgICBjb25zdCB3aW5kb3dzID0gTWF0aC5jZWlsKGJpdHMgLyBXKSArIDE7IC8vICsxLCBiZWNhdXNlXG4gICAgICAgIGNvbnN0IHdpbmRvd1NpemUgPSAyICoqIChXIC0gMSk7IC8vIC0xIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG4gICAgICAgIHJldHVybiB7IHdpbmRvd3MsIHdpbmRvd1NpemUgfTtcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbnN0VGltZU5lZ2F0ZSxcbiAgICAgICAgLy8gbm9uLWNvbnN0IHRpbWUgbXVsdGlwbGljYXRpb24gbGFkZGVyXG4gICAgICAgIHVuc2FmZUxhZGRlcihlbG0sIG4pIHtcbiAgICAgICAgICAgIGxldCBwID0gYy5aRVJPO1xuICAgICAgICAgICAgbGV0IGQgPSBlbG07XG4gICAgICAgICAgICB3aGlsZSAobiA+IF8wbikge1xuICAgICAgICAgICAgICAgIGlmIChuICYgXzFuKVxuICAgICAgICAgICAgICAgICAgICBwID0gcC5hZGQoZCk7XG4gICAgICAgICAgICAgICAgZCA9IGQuZG91YmxlKCk7XG4gICAgICAgICAgICAgICAgbiA+Pj0gXzFuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgd05BRiBwcmVjb21wdXRhdGlvbiB3aW5kb3cuIFVzZWQgZm9yIGNhY2hpbmcuXG4gICAgICAgICAqIERlZmF1bHQgd2luZG93IHNpemUgaXMgc2V0IGJ5IGB1dGlscy5wcmVjb21wdXRlKClgIGFuZCBpcyBlcXVhbCB0byA4LlxuICAgICAgICAgKiBOdW1iZXIgb2YgcHJlY29tcHV0ZWQgcG9pbnRzIGRlcGVuZHMgb24gdGhlIGN1cnZlIHNpemU6XG4gICAgICAgICAqIDJeKPCdkYriiJIxKSAqIChNYXRoLmNlaWwo8J2RmyAvIPCdkYopICsgMSksIHdoZXJlOlxuICAgICAgICAgKiAtIPCdkYogaXMgdGhlIHdpbmRvdyBzaXplXG4gICAgICAgICAqIC0g8J2RmyBpcyB0aGUgYml0bGVuZ3RoIG9mIHRoZSBjdXJ2ZSBvcmRlci5cbiAgICAgICAgICogRm9yIGEgMjU2LWJpdCBjdXJ2ZSBhbmQgd2luZG93IHNpemUgOCwgdGhlIG51bWJlciBvZiBwcmVjb21wdXRlZCBwb2ludHMgaXMgMTI4ICogMzMgPSA0MjI0LlxuICAgICAgICAgKiBAcmV0dXJucyBwcmVjb21wdXRlZCBwb2ludCB0YWJsZXMgZmxhdHRlbmVkIHRvIGEgc2luZ2xlIGFycmF5XG4gICAgICAgICAqL1xuICAgICAgICBwcmVjb21wdXRlV2luZG93KGVsbSwgVykge1xuICAgICAgICAgICAgY29uc3QgeyB3aW5kb3dzLCB3aW5kb3dTaXplIH0gPSBvcHRzKFcpO1xuICAgICAgICAgICAgY29uc3QgcG9pbnRzID0gW107XG4gICAgICAgICAgICBsZXQgcCA9IGVsbTtcbiAgICAgICAgICAgIGxldCBiYXNlID0gcDtcbiAgICAgICAgICAgIGZvciAobGV0IHdpbmRvdyA9IDA7IHdpbmRvdyA8IHdpbmRvd3M7IHdpbmRvdysrKSB7XG4gICAgICAgICAgICAgICAgYmFzZSA9IHA7XG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goYmFzZSk7XG4gICAgICAgICAgICAgICAgLy8gPTEsIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB3aW5kb3dTaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYmFzZSA9IGJhc2UuYWRkKHApO1xuICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChiYXNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcCA9IGJhc2UuZG91YmxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcG9pbnRzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogSW1wbGVtZW50cyBlYyBtdWx0aXBsaWNhdGlvbiB1c2luZyBwcmVjb21wdXRlZCB0YWJsZXMgYW5kIHctYXJ5IG5vbi1hZGphY2VudCBmb3JtLlxuICAgICAgICAgKiBAcGFyYW0gVyB3aW5kb3cgc2l6ZVxuICAgICAgICAgKiBAcGFyYW0gcHJlY29tcHV0ZXMgcHJlY29tcHV0ZWQgdGFibGVzXG4gICAgICAgICAqIEBwYXJhbSBuIHNjYWxhciAod2UgZG9uJ3QgY2hlY2sgaGVyZSwgYnV0IHNob3VsZCBiZSBsZXNzIHRoYW4gY3VydmUgb3JkZXIpXG4gICAgICAgICAqIEByZXR1cm5zIHJlYWwgYW5kIGZha2UgKGZvciBjb25zdC10aW1lKSBwb2ludHNcbiAgICAgICAgICovXG4gICAgICAgIHdOQUYoVywgcHJlY29tcHV0ZXMsIG4pIHtcbiAgICAgICAgICAgIC8vIFRPRE86IG1heWJlIGNoZWNrIHRoYXQgc2NhbGFyIGlzIGxlc3MgdGhhbiBncm91cCBvcmRlcj8gd05BRiBiZWhhdmlvdXMgaXMgdW5kZWZpbmVkIG90aGVyd2lzZVxuICAgICAgICAgICAgLy8gQnV0IG5lZWQgdG8gY2FyZWZ1bGx5IHJlbW92ZSBvdGhlciBjaGVja3MgYmVmb3JlIHdOQUYuIE9SREVSID09IGJpdHMgaGVyZVxuICAgICAgICAgICAgY29uc3QgeyB3aW5kb3dzLCB3aW5kb3dTaXplIH0gPSBvcHRzKFcpO1xuICAgICAgICAgICAgbGV0IHAgPSBjLlpFUk87XG4gICAgICAgICAgICBsZXQgZiA9IGMuQkFTRTtcbiAgICAgICAgICAgIGNvbnN0IG1hc2sgPSBCaWdJbnQoMiAqKiBXIC0gMSk7IC8vIENyZWF0ZSBtYXNrIHdpdGggVyBvbmVzOiAwYjExMTEgZm9yIFc9NCBldGMuXG4gICAgICAgICAgICBjb25zdCBtYXhOdW1iZXIgPSAyICoqIFc7XG4gICAgICAgICAgICBjb25zdCBzaGlmdEJ5ID0gQmlnSW50KFcpO1xuICAgICAgICAgICAgZm9yIChsZXQgd2luZG93ID0gMDsgd2luZG93IDwgd2luZG93czsgd2luZG93KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB3aW5kb3cgKiB3aW5kb3dTaXplO1xuICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgVyBiaXRzLlxuICAgICAgICAgICAgICAgIGxldCB3Yml0cyA9IE51bWJlcihuICYgbWFzayk7XG4gICAgICAgICAgICAgICAgLy8gU2hpZnQgbnVtYmVyIGJ5IFcgYml0cy5cbiAgICAgICAgICAgICAgICBuID4+PSBzaGlmdEJ5O1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBiaXRzIGFyZSBiaWdnZXIgdGhhbiBtYXggc2l6ZSwgd2UnbGwgc3BsaXQgdGhvc2UuXG4gICAgICAgICAgICAgICAgLy8gKzIyNCA9PiAyNTYgLSAzMlxuICAgICAgICAgICAgICAgIGlmICh3Yml0cyA+IHdpbmRvd1NpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgd2JpdHMgLT0gbWF4TnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICBuICs9IF8xbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBjb2RlIHdhcyBmaXJzdCB3cml0dGVuIHdpdGggYXNzdW1wdGlvbiB0aGF0ICdmJyBhbmQgJ3AnIHdpbGwgbmV2ZXIgYmUgaW5maW5pdHkgcG9pbnQ6XG4gICAgICAgICAgICAgICAgLy8gc2luY2UgZWFjaCBhZGRpdGlvbiBpcyBtdWx0aXBsaWVkIGJ5IDIgKiogVywgaXQgY2Fubm90IGNhbmNlbCBlYWNoIG90aGVyLiBIb3dldmVyLFxuICAgICAgICAgICAgICAgIC8vIHRoZXJlIGlzIG5lZ2F0ZSBub3c6IGl0IGlzIHBvc3NpYmxlIHRoYXQgbmVnYXRlZCBlbGVtZW50IGZyb20gbG93IHZhbHVlXG4gICAgICAgICAgICAgICAgLy8gd291bGQgYmUgdGhlIHNhbWUgYXMgaGlnaCBlbGVtZW50LCB3aGljaCB3aWxsIGNyZWF0ZSBjYXJyeSBpbnRvIG5leHQgd2luZG93LlxuICAgICAgICAgICAgICAgIC8vIEl0J3Mgbm90IG9idmlvdXMgaG93IHRoaXMgY2FuIGZhaWwsIGJ1dCBzdGlsbCB3b3J0aCBpbnZlc3RpZ2F0aW5nIGxhdGVyLlxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlJ3JlIG9udG8gWmVybyBwb2ludC5cbiAgICAgICAgICAgICAgICAvLyBBZGQgcmFuZG9tIHBvaW50IGluc2lkZSBjdXJyZW50IHdpbmRvdyB0byBmLlxuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldDEgPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0MiA9IG9mZnNldCArIE1hdGguYWJzKHdiaXRzKSAtIDE7IC8vIC0xIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG4gICAgICAgICAgICAgICAgY29uc3QgY29uZDEgPSB3aW5kb3cgJSAyICE9PSAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbmQyID0gd2JpdHMgPCAwO1xuICAgICAgICAgICAgICAgIGlmICh3Yml0cyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbW9zdCBpbXBvcnRhbnQgcGFydCBmb3IgY29uc3QtdGltZSBnZXRQdWJsaWNLZXlcbiAgICAgICAgICAgICAgICAgICAgZiA9IGYuYWRkKGNvbnN0VGltZU5lZ2F0ZShjb25kMSwgcHJlY29tcHV0ZXNbb2Zmc2V0MV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBwLmFkZChjb25zdFRpbWVOZWdhdGUoY29uZDIsIHByZWNvbXB1dGVzW29mZnNldDJdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSklULWNvbXBpbGVyIHNob3VsZCBub3QgZWxpbWluYXRlIGYgaGVyZSwgc2luY2UgaXQgd2lsbCBsYXRlciBiZSB1c2VkIGluIG5vcm1hbGl6ZVooKVxuICAgICAgICAgICAgLy8gRXZlbiBpZiB0aGUgdmFyaWFibGUgaXMgc3RpbGwgdW51c2VkLCB0aGVyZSBhcmUgc29tZSBjaGVja3Mgd2hpY2ggd2lsbFxuICAgICAgICAgICAgLy8gdGhyb3cgYW4gZXhjZXB0aW9uLCBzbyBjb21waWxlciBuZWVkcyB0byBwcm92ZSB0aGV5IHdvbid0IGhhcHBlbiwgd2hpY2ggaXMgaGFyZC5cbiAgICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQgdGhlcmUgaXMgYSB3YXkgdG8gRiBiZSBpbmZpbml0eS1wb2ludCBldmVuIGlmIHAgaXMgbm90LFxuICAgICAgICAgICAgLy8gd2hpY2ggbWFrZXMgaXQgbGVzcyBjb25zdC10aW1lOiBhcm91bmQgMSBiaWdpbnQgbXVsdGlwbHkuXG4gICAgICAgICAgICByZXR1cm4geyBwLCBmIH07XG4gICAgICAgIH0sXG4gICAgICAgIHdOQUZDYWNoZWQoUCwgcHJlY29tcHV0ZXNNYXAsIG4sIHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgVyA9IFAuX1dJTkRPV19TSVpFIHx8IDE7XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgcHJlY29tcHV0ZXMgb24gYSBmaXJzdCBydW4sIHJldXNlIHRoZW0gYWZ0ZXJcbiAgICAgICAgICAgIGxldCBjb21wID0gcHJlY29tcHV0ZXNNYXAuZ2V0KFApO1xuICAgICAgICAgICAgaWYgKCFjb21wKSB7XG4gICAgICAgICAgICAgICAgY29tcCA9IHRoaXMucHJlY29tcHV0ZVdpbmRvdyhQLCBXKTtcbiAgICAgICAgICAgICAgICBpZiAoVyAhPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBwcmVjb21wdXRlc01hcC5zZXQoUCwgdHJhbnNmb3JtKGNvbXApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53TkFGKFcsIGNvbXAsIG4pO1xuICAgICAgICB9LFxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVCYXNpYyhjdXJ2ZSkge1xuICAgIHZhbGlkYXRlRmllbGQoY3VydmUuRnApO1xuICAgIHZhbGlkYXRlT2JqZWN0KGN1cnZlLCB7XG4gICAgICAgIG46ICdiaWdpbnQnLFxuICAgICAgICBoOiAnYmlnaW50JyxcbiAgICAgICAgR3g6ICdmaWVsZCcsXG4gICAgICAgIEd5OiAnZmllbGQnLFxuICAgIH0sIHtcbiAgICAgICAgbkJpdExlbmd0aDogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBuQnl0ZUxlbmd0aDogJ2lzU2FmZUludGVnZXInLFxuICAgIH0pO1xuICAgIC8vIFNldCBkZWZhdWx0c1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgLi4ubkxlbmd0aChjdXJ2ZS5uLCBjdXJ2ZS5uQml0TGVuZ3RoKSxcbiAgICAgICAgLi4uY3VydmUsXG4gICAgICAgIC4uLnsgcDogY3VydmUuRnAuT1JERVIgfSxcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWN1cnZlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/curve.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/hash-to-curve.js":
/*!***************************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/hash-to-curve.js ***!
  \***************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createHasher: () => (/* binding */ createHasher),\n/* harmony export */   expand_message_xmd: () => (/* binding */ expand_message_xmd),\n/* harmony export */   expand_message_xof: () => (/* binding */ expand_message_xof),\n/* harmony export */   hash_to_field: () => (/* binding */ hash_to_field),\n/* harmony export */   isogenyMap: () => (/* binding */ isogenyMap)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/utils.js\");\n\n\nfunction validateDST(dst) {\n    if (dst instanceof Uint8Array)\n        return dst;\n    if (typeof dst === 'string')\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)(dst);\n    throw new Error('DST must be Uint8Array or string');\n}\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE;\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value, length) {\n    if (value < 0 || value >= 1 << (8 * length)) {\n        throw new Error(`bad I2OSP call: value=${value} length=${length}`);\n    }\n    const res = Array.from({ length }).fill(0);\n    for (let i = length - 1; i >= 0; i--) {\n        res[i] = value & 0xff;\n        value >>>= 8;\n    }\n    return new Uint8Array(res);\n}\nfunction strxor(a, b) {\n    const arr = new Uint8Array(a.length);\n    for (let i = 0; i < a.length; i++) {\n        arr[i] = a[i] ^ b[i];\n    }\n    return arr;\n}\nfunction isBytes(item) {\n    if (!(item instanceof Uint8Array))\n        throw new Error('Uint8Array expected');\n}\nfunction isNum(item) {\n    if (!Number.isSafeInteger(item))\n        throw new Error('number expected');\n}\n// Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1\nfunction expand_message_xmd(msg, DST, lenInBytes, H) {\n    isBytes(msg);\n    isBytes(DST);\n    isNum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    if (DST.length > 255)\n        DST = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)('H2C-OVERSIZE-DST-'), DST));\n    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n    const ell = Math.ceil(lenInBytes / b_in_bytes);\n    if (ell > 255)\n        throw new Error('Invalid xmd length');\n    const DST_prime = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(DST, i2osp(DST.length, 1));\n    const Z_pad = i2osp(0, r_in_bytes);\n    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n    const b = new Array(ell);\n    const b_0 = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n    b[0] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(b_0, i2osp(1, 1), DST_prime));\n    for (let i = 1; i <= ell; i++) {\n        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];\n        b[i] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...args));\n    }\n    const pseudo_random_bytes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...b);\n    return pseudo_random_bytes.slice(0, lenInBytes);\n}\n// Produces a uniformly random byte string using an extendable-output function (XOF) H.\n// 1. The collision resistance of H MUST be at least k bits.\n// 2. H MUST be an XOF that has been proved indifferentiable from\n//    a random oracle under a reasonable cryptographic assumption.\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2\nfunction expand_message_xof(msg, DST, lenInBytes, k, H) {\n    isBytes(msg);\n    isBytes(DST);\n    isNum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n    if (DST.length > 255) {\n        const dkLen = Math.ceil((2 * k) / 8);\n        DST = H.create({ dkLen }).update((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)('H2C-OVERSIZE-DST-')).update(DST).digest();\n    }\n    if (lenInBytes > 65535 || DST.length > 255)\n        throw new Error('expand_message_xof: invalid lenInBytes');\n    return (H.create({ dkLen: lenInBytes })\n        .update(msg)\n        .update(i2osp(lenInBytes, 2))\n        // 2. DST_prime = DST || I2OSP(len(DST), 1)\n        .update(DST)\n        .update(i2osp(DST.length, 1))\n        .digest());\n}\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F\n * https://www.rfc-editor.org/rfc/rfc9380#section-5.2\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */\nfunction hash_to_field(msg, count, options) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(options, {\n        DST: 'stringOrUint8Array',\n        p: 'bigint',\n        m: 'isSafeInteger',\n        k: 'isSafeInteger',\n        hash: 'hash',\n    });\n    const { p, k, m, hash, expand, DST: _DST } = options;\n    isBytes(msg);\n    isNum(count);\n    const DST = validateDST(_DST);\n    const log2p = p.toString(2).length;\n    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n    const len_in_bytes = count * m * L;\n    let prb; // pseudo_random_bytes\n    if (expand === 'xmd') {\n        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n    }\n    else if (expand === 'xof') {\n        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n    }\n    else if (expand === '_internal_pass') {\n        // for internal tests only\n        prb = msg;\n    }\n    else {\n        throw new Error('expand must be \"xmd\" or \"xof\"');\n    }\n    const u = new Array(count);\n    for (let i = 0; i < count; i++) {\n        const e = new Array(m);\n        for (let j = 0; j < m; j++) {\n            const elm_offset = L * (j + i * m);\n            const tv = prb.subarray(elm_offset, elm_offset + L);\n            e[j] = (0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.mod)(os2ip(tv), p);\n        }\n        u[i] = e;\n    }\n    return u;\n}\nfunction isogenyMap(field, map) {\n    // Make same order as in spec\n    const COEFF = map.map((i) => Array.from(i).reverse());\n    return (x, y) => {\n        const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));\n        x = field.div(xNum, xDen); // xNum / xDen\n        y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)\n        return { x, y };\n    };\n}\nfunction createHasher(Point, mapToCurve, def) {\n    if (typeof mapToCurve !== 'function')\n        throw new Error('mapToCurve() must be defined');\n    return {\n        // Encodes byte string to elliptic curve.\n        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        hashToCurve(msg, options) {\n            const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });\n            const u0 = Point.fromAffine(mapToCurve(u[0]));\n            const u1 = Point.fromAffine(mapToCurve(u[1]));\n            const P = u0.add(u1).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n        // Encodes byte string to elliptic curve.\n        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        encodeToCurve(msg, options) {\n            const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });\n            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n    };\n}\n//# sourceMappingURL=hash-to-curve.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvaGFzaC10by1jdXJ2ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQW1DO0FBQ29EO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxzREFBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxjQUFjLHNEQUFlO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxPQUFPLFNBQVMsT0FBTztBQUN4RTtBQUNBLDZCQUE2QixRQUFRO0FBQ3JDLDZCQUE2QixRQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzREFBVyxDQUFDLHNEQUFXO0FBQ3ZDLFlBQVksOENBQThDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzREFBVztBQUNqQztBQUNBLDRDQUE0QztBQUM1QztBQUNBLGtCQUFrQixzREFBVztBQUM3QixhQUFhLHNEQUFXO0FBQ3hCLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0EsaUJBQWlCLHNEQUFXO0FBQzVCO0FBQ0EsZ0NBQWdDLHNEQUFXO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixPQUFPLFNBQVMsc0RBQVc7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkVBQTZFO0FBQ2pHO0FBQ0E7QUFDTztBQUNQLElBQUkseURBQWM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxZQUFZLG1DQUFtQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0EsbUJBQW1CLGdEQUFHO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLGlEQUFpRDtBQUNqRCxpQkFBaUI7QUFDakI7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGtDQUFrQztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx3Q0FBd0M7QUFDdEY7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbGZnL0dpdC9NYWR0cmlwcy9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvaGFzaC10by1jdXJ2ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBtb2QgfSBmcm9tICcuL21vZHVsYXIuanMnO1xuaW1wb3J0IHsgYnl0ZXNUb051bWJlckJFLCBjb25jYXRCeXRlcywgdXRmOFRvQnl0ZXMsIHZhbGlkYXRlT2JqZWN0IH0gZnJvbSAnLi91dGlscy5qcyc7XG5mdW5jdGlvbiB2YWxpZGF0ZURTVChkc3QpIHtcbiAgICBpZiAoZHN0IGluc3RhbmNlb2YgVWludDhBcnJheSlcbiAgICAgICAgcmV0dXJuIGRzdDtcbiAgICBpZiAodHlwZW9mIGRzdCA9PT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhkc3QpO1xuICAgIHRocm93IG5ldyBFcnJvcignRFNUIG11c3QgYmUgVWludDhBcnJheSBvciBzdHJpbmcnKTtcbn1cbi8vIE9jdGV0IFN0cmVhbSB0byBJbnRlZ2VyLiBcInNwZWNcIiBpbXBsZW1lbnRhdGlvbiBvZiBvczJpcCBpcyAyLjV4IHNsb3dlciB2cyBieXRlc1RvTnVtYmVyQkUuXG5jb25zdCBvczJpcCA9IGJ5dGVzVG9OdW1iZXJCRTtcbi8vIEludGVnZXIgdG8gT2N0ZXQgU3RyZWFtIChudW1iZXJUb0J5dGVzQkUpXG5mdW5jdGlvbiBpMm9zcCh2YWx1ZSwgbGVuZ3RoKSB7XG4gICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+PSAxIDw8ICg4ICogbGVuZ3RoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJhZCBJMk9TUCBjYWxsOiB2YWx1ZT0ke3ZhbHVlfSBsZW5ndGg9JHtsZW5ndGh9YCk7XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IEFycmF5LmZyb20oeyBsZW5ndGggfSkuZmlsbCgwKTtcbiAgICBmb3IgKGxldCBpID0gbGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgcmVzW2ldID0gdmFsdWUgJiAweGZmO1xuICAgICAgICB2YWx1ZSA+Pj49IDg7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShyZXMpO1xufVxuZnVuY3Rpb24gc3RyeG9yKGEsIGIpIHtcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheShhLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycltpXSA9IGFbaV0gXiBiW2ldO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufVxuZnVuY3Rpb24gaXNCeXRlcyhpdGVtKSB7XG4gICAgaWYgKCEoaXRlbSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbn1cbmZ1bmN0aW9uIGlzTnVtKGl0ZW0pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGl0ZW0pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ251bWJlciBleHBlY3RlZCcpO1xufVxuLy8gUHJvZHVjZXMgYSB1bmlmb3JtbHkgcmFuZG9tIGJ5dGUgc3RyaW5nIHVzaW5nIGEgY3J5cHRvZ3JhcGhpYyBoYXNoIGZ1bmN0aW9uIEggdGhhdCBvdXRwdXRzIGIgYml0c1xuLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjMuMVxuZXhwb3J0IGZ1bmN0aW9uIGV4cGFuZF9tZXNzYWdlX3htZChtc2csIERTVCwgbGVuSW5CeXRlcywgSCkge1xuICAgIGlzQnl0ZXMobXNnKTtcbiAgICBpc0J5dGVzKERTVCk7XG4gICAgaXNOdW0obGVuSW5CeXRlcyk7XG4gICAgLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjMuM1xuICAgIGlmIChEU1QubGVuZ3RoID4gMjU1KVxuICAgICAgICBEU1QgPSBIKGNvbmNhdEJ5dGVzKHV0ZjhUb0J5dGVzKCdIMkMtT1ZFUlNJWkUtRFNULScpLCBEU1QpKTtcbiAgICBjb25zdCB7IG91dHB1dExlbjogYl9pbl9ieXRlcywgYmxvY2tMZW46IHJfaW5fYnl0ZXMgfSA9IEg7XG4gICAgY29uc3QgZWxsID0gTWF0aC5jZWlsKGxlbkluQnl0ZXMgLyBiX2luX2J5dGVzKTtcbiAgICBpZiAoZWxsID4gMjU1KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgeG1kIGxlbmd0aCcpO1xuICAgIGNvbnN0IERTVF9wcmltZSA9IGNvbmNhdEJ5dGVzKERTVCwgaTJvc3AoRFNULmxlbmd0aCwgMSkpO1xuICAgIGNvbnN0IFpfcGFkID0gaTJvc3AoMCwgcl9pbl9ieXRlcyk7XG4gICAgY29uc3QgbF9pX2Jfc3RyID0gaTJvc3AobGVuSW5CeXRlcywgMik7IC8vIGxlbl9pbl9ieXRlc19zdHJcbiAgICBjb25zdCBiID0gbmV3IEFycmF5KGVsbCk7XG4gICAgY29uc3QgYl8wID0gSChjb25jYXRCeXRlcyhaX3BhZCwgbXNnLCBsX2lfYl9zdHIsIGkyb3NwKDAsIDEpLCBEU1RfcHJpbWUpKTtcbiAgICBiWzBdID0gSChjb25jYXRCeXRlcyhiXzAsIGkyb3NwKDEsIDEpLCBEU1RfcHJpbWUpKTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBlbGw7IGkrKykge1xuICAgICAgICBjb25zdCBhcmdzID0gW3N0cnhvcihiXzAsIGJbaSAtIDFdKSwgaTJvc3AoaSArIDEsIDEpLCBEU1RfcHJpbWVdO1xuICAgICAgICBiW2ldID0gSChjb25jYXRCeXRlcyguLi5hcmdzKSk7XG4gICAgfVxuICAgIGNvbnN0IHBzZXVkb19yYW5kb21fYnl0ZXMgPSBjb25jYXRCeXRlcyguLi5iKTtcbiAgICByZXR1cm4gcHNldWRvX3JhbmRvbV9ieXRlcy5zbGljZSgwLCBsZW5JbkJ5dGVzKTtcbn1cbi8vIFByb2R1Y2VzIGEgdW5pZm9ybWx5IHJhbmRvbSBieXRlIHN0cmluZyB1c2luZyBhbiBleHRlbmRhYmxlLW91dHB1dCBmdW5jdGlvbiAoWE9GKSBILlxuLy8gMS4gVGhlIGNvbGxpc2lvbiByZXNpc3RhbmNlIG9mIEggTVVTVCBiZSBhdCBsZWFzdCBrIGJpdHMuXG4vLyAyLiBIIE1VU1QgYmUgYW4gWE9GIHRoYXQgaGFzIGJlZW4gcHJvdmVkIGluZGlmZmVyZW50aWFibGUgZnJvbVxuLy8gICAgYSByYW5kb20gb3JhY2xlIHVuZGVyIGEgcmVhc29uYWJsZSBjcnlwdG9ncmFwaGljIGFzc3VtcHRpb24uXG4vLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMy4yXG5leHBvcnQgZnVuY3Rpb24gZXhwYW5kX21lc3NhZ2VfeG9mKG1zZywgRFNULCBsZW5JbkJ5dGVzLCBrLCBIKSB7XG4gICAgaXNCeXRlcyhtc2cpO1xuICAgIGlzQnl0ZXMoRFNUKTtcbiAgICBpc051bShsZW5JbkJ5dGVzKTtcbiAgICAvLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMy4zXG4gICAgLy8gRFNUID0gSCgnSDJDLU9WRVJTSVpFLURTVC0nIHx8IGFfdmVyeV9sb25nX0RTVCwgTWF0aC5jZWlsKChsZW5JbkJ5dGVzICogaykgLyA4KSk7XG4gICAgaWYgKERTVC5sZW5ndGggPiAyNTUpIHtcbiAgICAgICAgY29uc3QgZGtMZW4gPSBNYXRoLmNlaWwoKDIgKiBrKSAvIDgpO1xuICAgICAgICBEU1QgPSBILmNyZWF0ZSh7IGRrTGVuIH0pLnVwZGF0ZSh1dGY4VG9CeXRlcygnSDJDLU9WRVJTSVpFLURTVC0nKSkudXBkYXRlKERTVCkuZGlnZXN0KCk7XG4gICAgfVxuICAgIGlmIChsZW5JbkJ5dGVzID4gNjU1MzUgfHwgRFNULmxlbmd0aCA+IDI1NSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBhbmRfbWVzc2FnZV94b2Y6IGludmFsaWQgbGVuSW5CeXRlcycpO1xuICAgIHJldHVybiAoSC5jcmVhdGUoeyBka0xlbjogbGVuSW5CeXRlcyB9KVxuICAgICAgICAudXBkYXRlKG1zZylcbiAgICAgICAgLnVwZGF0ZShpMm9zcChsZW5JbkJ5dGVzLCAyKSlcbiAgICAgICAgLy8gMi4gRFNUX3ByaW1lID0gRFNUIHx8IEkyT1NQKGxlbihEU1QpLCAxKVxuICAgICAgICAudXBkYXRlKERTVClcbiAgICAgICAgLnVwZGF0ZShpMm9zcChEU1QubGVuZ3RoLCAxKSlcbiAgICAgICAgLmRpZ2VzdCgpKTtcbn1cbi8qKlxuICogSGFzaGVzIGFyYml0cmFyeS1sZW5ndGggYnl0ZSBzdHJpbmdzIHRvIGEgbGlzdCBvZiBvbmUgb3IgbW9yZSBlbGVtZW50cyBvZiBhIGZpbml0ZSBmaWVsZCBGXG4gKiBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMlxuICogQHBhcmFtIG1zZyBhIGJ5dGUgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIG1lc3NhZ2UgdG8gaGFzaFxuICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgZWxlbWVudHMgb2YgRiB0byBvdXRwdXRcbiAqIEBwYXJhbSBvcHRpb25zIGB7RFNUOiBzdHJpbmcsIHA6IGJpZ2ludCwgbTogbnVtYmVyLCBrOiBudW1iZXIsIGV4cGFuZDogJ3htZCcgfCAneG9mJywgaGFzaDogSH1gLCBzZWUgYWJvdmVcbiAqIEByZXR1cm5zIFt1XzAsIC4uLiwgdV8oY291bnQgLSAxKV0sIGEgbGlzdCBvZiBmaWVsZCBlbGVtZW50cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc2hfdG9fZmllbGQobXNnLCBjb3VudCwgb3B0aW9ucykge1xuICAgIHZhbGlkYXRlT2JqZWN0KG9wdGlvbnMsIHtcbiAgICAgICAgRFNUOiAnc3RyaW5nT3JVaW50OEFycmF5JyxcbiAgICAgICAgcDogJ2JpZ2ludCcsXG4gICAgICAgIG06ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgazogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBoYXNoOiAnaGFzaCcsXG4gICAgfSk7XG4gICAgY29uc3QgeyBwLCBrLCBtLCBoYXNoLCBleHBhbmQsIERTVDogX0RTVCB9ID0gb3B0aW9ucztcbiAgICBpc0J5dGVzKG1zZyk7XG4gICAgaXNOdW0oY291bnQpO1xuICAgIGNvbnN0IERTVCA9IHZhbGlkYXRlRFNUKF9EU1QpO1xuICAgIGNvbnN0IGxvZzJwID0gcC50b1N0cmluZygyKS5sZW5ndGg7XG4gICAgY29uc3QgTCA9IE1hdGguY2VpbCgobG9nMnAgKyBrKSAvIDgpOyAvLyBzZWN0aW9uIDUuMSBvZiBpZXRmIGRyYWZ0IGxpbmsgYWJvdmVcbiAgICBjb25zdCBsZW5faW5fYnl0ZXMgPSBjb3VudCAqIG0gKiBMO1xuICAgIGxldCBwcmI7IC8vIHBzZXVkb19yYW5kb21fYnl0ZXNcbiAgICBpZiAoZXhwYW5kID09PSAneG1kJykge1xuICAgICAgICBwcmIgPSBleHBhbmRfbWVzc2FnZV94bWQobXNnLCBEU1QsIGxlbl9pbl9ieXRlcywgaGFzaCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV4cGFuZCA9PT0gJ3hvZicpIHtcbiAgICAgICAgcHJiID0gZXhwYW5kX21lc3NhZ2VfeG9mKG1zZywgRFNULCBsZW5faW5fYnl0ZXMsIGssIGhhc2gpO1xuICAgIH1cbiAgICBlbHNlIGlmIChleHBhbmQgPT09ICdfaW50ZXJuYWxfcGFzcycpIHtcbiAgICAgICAgLy8gZm9yIGludGVybmFsIHRlc3RzIG9ubHlcbiAgICAgICAgcHJiID0gbXNnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBhbmQgbXVzdCBiZSBcInhtZFwiIG9yIFwieG9mXCInKTtcbiAgICB9XG4gICAgY29uc3QgdSA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGUgPSBuZXcgQXJyYXkobSk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbTsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCBlbG1fb2Zmc2V0ID0gTCAqIChqICsgaSAqIG0pO1xuICAgICAgICAgICAgY29uc3QgdHYgPSBwcmIuc3ViYXJyYXkoZWxtX29mZnNldCwgZWxtX29mZnNldCArIEwpO1xuICAgICAgICAgICAgZVtqXSA9IG1vZChvczJpcCh0diksIHApO1xuICAgICAgICB9XG4gICAgICAgIHVbaV0gPSBlO1xuICAgIH1cbiAgICByZXR1cm4gdTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc29nZW55TWFwKGZpZWxkLCBtYXApIHtcbiAgICAvLyBNYWtlIHNhbWUgb3JkZXIgYXMgaW4gc3BlY1xuICAgIGNvbnN0IENPRUZGID0gbWFwLm1hcCgoaSkgPT4gQXJyYXkuZnJvbShpKS5yZXZlcnNlKCkpO1xuICAgIHJldHVybiAoeCwgeSkgPT4ge1xuICAgICAgICBjb25zdCBbeE51bSwgeERlbiwgeU51bSwgeURlbl0gPSBDT0VGRi5tYXAoKHZhbCkgPT4gdmFsLnJlZHVjZSgoYWNjLCBpKSA9PiBmaWVsZC5hZGQoZmllbGQubXVsKGFjYywgeCksIGkpKSk7XG4gICAgICAgIHggPSBmaWVsZC5kaXYoeE51bSwgeERlbik7IC8vIHhOdW0gLyB4RGVuXG4gICAgICAgIHkgPSBmaWVsZC5tdWwoeSwgZmllbGQuZGl2KHlOdW0sIHlEZW4pKTsgLy8geSAqICh5TnVtIC8geURldilcbiAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSGFzaGVyKFBvaW50LCBtYXBUb0N1cnZlLCBkZWYpIHtcbiAgICBpZiAodHlwZW9mIG1hcFRvQ3VydmUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWFwVG9DdXJ2ZSgpIG11c3QgYmUgZGVmaW5lZCcpO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8vIEVuY29kZXMgYnl0ZSBzdHJpbmcgdG8gZWxsaXB0aWMgY3VydmUuXG4gICAgICAgIC8vIGhhc2hfdG9fY3VydmUgZnJvbSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTNcbiAgICAgICAgaGFzaFRvQ3VydmUobXNnLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCB1ID0gaGFzaF90b19maWVsZChtc2csIDIsIHsgLi4uZGVmLCBEU1Q6IGRlZi5EU1QsIC4uLm9wdGlvbnMgfSk7XG4gICAgICAgICAgICBjb25zdCB1MCA9IFBvaW50LmZyb21BZmZpbmUobWFwVG9DdXJ2ZSh1WzBdKSk7XG4gICAgICAgICAgICBjb25zdCB1MSA9IFBvaW50LmZyb21BZmZpbmUobWFwVG9DdXJ2ZSh1WzFdKSk7XG4gICAgICAgICAgICBjb25zdCBQID0gdTAuYWRkKHUxKS5jbGVhckNvZmFjdG9yKCk7XG4gICAgICAgICAgICBQLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUDtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gRW5jb2RlcyBieXRlIHN0cmluZyB0byBlbGxpcHRpYyBjdXJ2ZS5cbiAgICAgICAgLy8gZW5jb2RlX3RvX2N1cnZlIGZyb20gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi0zXG4gICAgICAgIGVuY29kZVRvQ3VydmUobXNnLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCB1ID0gaGFzaF90b19maWVsZChtc2csIDEsIHsgLi4uZGVmLCBEU1Q6IGRlZi5lbmNvZGVEU1QsIC4uLm9wdGlvbnMgfSk7XG4gICAgICAgICAgICBjb25zdCBQID0gUG9pbnQuZnJvbUFmZmluZShtYXBUb0N1cnZlKHVbMF0pKS5jbGVhckNvZmFjdG9yKCk7XG4gICAgICAgICAgICBQLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUDtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFzaC10by1jdXJ2ZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/hash-to-curve.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/modular.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/modular.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Field: () => (/* binding */ Field),\n/* harmony export */   FpDiv: () => (/* binding */ FpDiv),\n/* harmony export */   FpInvertBatch: () => (/* binding */ FpInvertBatch),\n/* harmony export */   FpIsSquare: () => (/* binding */ FpIsSquare),\n/* harmony export */   FpPow: () => (/* binding */ FpPow),\n/* harmony export */   FpSqrt: () => (/* binding */ FpSqrt),\n/* harmony export */   FpSqrtEven: () => (/* binding */ FpSqrtEven),\n/* harmony export */   FpSqrtOdd: () => (/* binding */ FpSqrtOdd),\n/* harmony export */   getFieldBytesLength: () => (/* binding */ getFieldBytesLength),\n/* harmony export */   getMinHashLength: () => (/* binding */ getMinHashLength),\n/* harmony export */   hashToPrivateScalar: () => (/* binding */ hashToPrivateScalar),\n/* harmony export */   invert: () => (/* binding */ invert),\n/* harmony export */   isNegativeLE: () => (/* binding */ isNegativeLE),\n/* harmony export */   mapHashToField: () => (/* binding */ mapHashToField),\n/* harmony export */   mod: () => (/* binding */ mod),\n/* harmony export */   nLength: () => (/* binding */ nLength),\n/* harmony export */   pow: () => (/* binding */ pow),\n/* harmony export */   pow2: () => (/* binding */ pow2),\n/* harmony export */   tonelliShanks: () => (/* binding */ tonelliShanks),\n/* harmony export */   validateField: () => (/* binding */ validateField)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Utilities for modular arithmetics and finite fields\n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);\n// prettier-ignore\nconst _9n = BigInt(9), _16n = BigInt(16);\n// Calculates a modulo b\nfunction mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\n// TODO: use field version && remove\nfunction pow(num, power, modulo) {\n    if (modulo <= _0n || power < _0n)\n        throw new Error('Expected power/modulo > 0');\n    if (modulo === _1n)\n        return _0n;\n    let res = _1n;\n    while (power > _0n) {\n        if (power & _1n)\n            res = (res * num) % modulo;\n        num = (num * num) % modulo;\n        power >>= _1n;\n    }\n    return res;\n}\n// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)\nfunction pow2(x, power, modulo) {\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n// Inverses number over modulo\nfunction invert(number, modulo) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * Will start an infinite loop if field order P is not prime.\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nfunction tonelliShanks(P) {\n    // Legendre constant: used to calculate Legendre symbol (a | p),\n    // which denotes the value of a^((p-1)/2) (mod p).\n    // (a | p)  1    if a is a square (mod p)\n    // (a | p)  -1   if a is not a square (mod p)\n    // (a | p)  0    if a  0 (mod p)\n    const legendreC = (P - _1n) / _2n;\n    let Q, S, Z;\n    // Step 1: By factoring out powers of 2 from p - 1,\n    // find q and s such that p - 1 = q*(2^s) with q odd\n    for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)\n        ;\n    // Step 2: Select a non-square z such that (z | p)  -1 and set c  zq\n    for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++)\n        ;\n    // Fast-path\n    if (S === 1) {\n        const p1div4 = (P + _1n) / _4n;\n        return function tonelliFast(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Slow-path\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        // Step 0: Check that n is indeed a square: (n | p) should not be  -1\n        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))\n            throw new Error('Cannot find square root');\n        let r = S;\n        // TODO: will fail at Fp2/etc\n        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n        let x = Fp.pow(n, Q1div2); // first guess at the square root\n        let b = Fp.pow(n, Q); // first guess at the fudge factor\n        while (!Fp.eql(b, Fp.ONE)) {\n            if (Fp.eql(b, Fp.ZERO))\n                return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n            // Find m such b^(2^m)==1\n            let m = 1;\n            for (let t2 = Fp.sqr(b); m < r; m++) {\n                if (Fp.eql(t2, Fp.ONE))\n                    break;\n                t2 = Fp.sqr(t2); // t2 *= t2\n            }\n            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n            g = Fp.sqr(ge); // g = ge * ge\n            x = Fp.mul(x, ge); // x *= ge\n            b = Fp.mul(b, g); // b *= g\n            r = m;\n        }\n        return x;\n    };\n}\nfunction FpSqrt(P) {\n    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.\n    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n    // P  3 (mod 4)\n    // n = n^((P+1)/4)\n    if (P % _4n === _3n) {\n        // Not all roots possible!\n        // const ORDER =\n        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n        // const NUM = 72057594037927816n;\n        const p1div4 = (P + _1n) / _4n;\n        return function sqrt3mod4(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            // Throw if root**2 != n\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Atkin algorithm for q  5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n    if (P % _8n === _5n) {\n        const c1 = (P - _5n) / _8n;\n        return function sqrt5mod8(Fp, n) {\n            const n2 = Fp.mul(n, _2n);\n            const v = Fp.pow(n2, c1);\n            const nv = Fp.mul(n, v);\n            const i = Fp.mul(Fp.mul(nv, _2n), v);\n            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // P  9 (mod 16)\n    if (P % _16n === _9n) {\n        // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n        // Means we cannot use sqrt for constants at all!\n        //\n        // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n        // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n        // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n        // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n        // sqrt = (x) => {\n        //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n        //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n        //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n        //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n        //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n        //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n        //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n        //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n        //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n        //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n        // }\n    }\n    // Other cases: Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nconst isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n    'eql', 'add', 'sub', 'mul', 'pow', 'div',\n    'addN', 'subN', 'mulN', 'sqrN'\n];\nfunction validateField(field) {\n    const initial = {\n        ORDER: 'bigint',\n        MASK: 'bigint',\n        BYTES: 'isSafeInteger',\n        BITS: 'isSafeInteger',\n    };\n    const opts = FIELD_FIELDS.reduce((map, val) => {\n        map[val] = 'function';\n        return map;\n    }, initial);\n    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(field, opts);\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nfunction FpPow(f, num, power) {\n    // Should have same speed as pow for bigints\n    // TODO: benchmark!\n    if (power < _0n)\n        throw new Error('Expected power > 0');\n    if (power === _0n)\n        return f.ONE;\n    if (power === _1n)\n        return num;\n    let p = f.ONE;\n    let d = num;\n    while (power > _0n) {\n        if (power & _1n)\n            p = f.mul(p, d);\n        d = f.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * `inv(0)` will return `undefined` here: make sure to throw an error.\n */\nfunction FpInvertBatch(f, nums) {\n    const tmp = new Array(nums.length);\n    // Walk from first to last, multiply them by each other MOD p\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = acc;\n        return f.mul(acc, num);\n    }, f.ONE);\n    // Invert last element\n    const inverted = f.inv(lastMultiplied);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = f.mul(acc, tmp[i]);\n        return f.mul(acc, num);\n    }, inverted);\n    return tmp;\n}\nfunction FpDiv(f, lhs, rhs) {\n    return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\n// This function returns True whenever the value x is a square in the field F.\nfunction FpIsSquare(f) {\n    const legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic\n    return (x) => {\n        const p = f.pow(x, legendreConst);\n        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n    };\n}\n// CURVE.n lengths\nfunction nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return { nBitLength: _nBitLength, nByteLength };\n}\n/**\n * Initializes a finite field over prime. **Non-primes are not supported.**\n * Do not init in loop: slow. Very fragile: always run a benchmark on a change.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nfunction Field(ORDER, bitLen, isLE = false, redef = {}) {\n    if (ORDER <= _0n)\n        throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n    if (BYTES > 2048)\n        throw new Error('Field lengths over 2048 bytes are not supported');\n    const sqrtP = FpSqrt(ORDER);\n    const f = Object.freeze({\n        ORDER,\n        BITS,\n        BYTES,\n        MASK: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        create: (num) => mod(num, ORDER),\n        isValid: (num) => {\n            if (typeof num !== 'bigint')\n                throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num) => num === _0n,\n        isOdd: (num) => (num & _1n) === _1n,\n        neg: (num) => mod(-num, ORDER),\n        eql: (lhs, rhs) => lhs === rhs,\n        sqr: (num) => mod(num * num, ORDER),\n        add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n        pow: (num, power) => FpPow(f, num, power),\n        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num) => num * num,\n        addN: (lhs, rhs) => lhs + rhs,\n        subN: (lhs, rhs) => lhs - rhs,\n        mulN: (lhs, rhs) => lhs * rhs,\n        inv: (num) => invert(num, ORDER),\n        sqrt: redef.sqrt || ((n) => sqrtP(f, n)),\n        invertBatch: (lst) => FpInvertBatch(f, lst),\n        // TODO: do we really need constant cmov?\n        // We don't have const-time bigints anyway, so probably will be not very useful\n        cmov: (a, b, c) => (c ? b : a),\n        toBytes: (num) => (isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(num, BYTES) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(num, BYTES)),\n        fromBytes: (bytes) => {\n            if (bytes.length !== BYTES)\n                throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);\n            return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(bytes) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(bytes);\n        },\n    });\n    return Object.freeze(f);\n}\nfunction FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nfunction FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use mapKeyToField instead\n */\nfunction hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('privateHash', hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n        throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(hash) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nfunction getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== 'bigint')\n        throw new Error('field order must be bigint');\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nfunction getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nfunction mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024)\n        throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(key) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(reduced, fieldLen) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(reduced, fieldLen);\n}\n//# sourceMappingURL=modular.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvbW9kdWxhci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ3VJO0FBQ3ZJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxxRUFBcUUsUUFBUSxNQUFNLE9BQU87QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsaUJBQWlCO0FBQzlDO0FBQ0E7QUFDQSxrQkFBa0IsMkNBQTJDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDLG1DQUFtQztBQUNuQyw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBLGlDQUFpQztB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O0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTyw0QkFBNEIsSUFBSTtBQUMzRSx1QkFBdUIsMERBQWUsUUFBUSwwREFBZTtBQUM3RDtBQUNBO0FBQ0Esa0JBQWtCLDBEQUFlLHNCQUFzQiwwREFBZTtBQUN0RTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9sZmcvR2l0L01hZHRyaXBzL25vZGVfbW9kdWxlcy9Abm9zdHItZGV2LWtpdC9uZGsvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9tb2R1bGFyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIFV0aWxpdGllcyBmb3IgbW9kdWxhciBhcml0aG1ldGljcyBhbmQgZmluaXRlIGZpZWxkc1xuaW1wb3J0IHsgYml0TWFzaywgbnVtYmVyVG9CeXRlc0JFLCBudW1iZXJUb0J5dGVzTEUsIGJ5dGVzVG9OdW1iZXJCRSwgYnl0ZXNUb051bWJlckxFLCBlbnN1cmVCeXRlcywgdmFsaWRhdGVPYmplY3QsIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKSwgXzFuID0gQmlnSW50KDEpLCBfMm4gPSBCaWdJbnQoMiksIF8zbiA9IEJpZ0ludCgzKTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzRuID0gQmlnSW50KDQpLCBfNW4gPSBCaWdJbnQoNSksIF84biA9IEJpZ0ludCg4KTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzluID0gQmlnSW50KDkpLCBfMTZuID0gQmlnSW50KDE2KTtcbi8vIENhbGN1bGF0ZXMgYSBtb2R1bG8gYlxuZXhwb3J0IGZ1bmN0aW9uIG1vZChhLCBiKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYSAlIGI7XG4gICAgcmV0dXJuIHJlc3VsdCA+PSBfMG4gPyByZXN1bHQgOiBiICsgcmVzdWx0O1xufVxuLyoqXG4gKiBFZmZpY2llbnRseSByYWlzZSBudW0gdG8gcG93ZXIgYW5kIGRvIG1vZHVsYXIgZGl2aXNpb24uXG4gKiBVbnNhZmUgaW4gc29tZSBjb250ZXh0czogdXNlcyBsYWRkZXIsIHNvIGNhbiBleHBvc2UgYmlnaW50IGJpdHMuXG4gKiBAZXhhbXBsZVxuICogcG93KDJuLCA2biwgMTFuKSAvLyA2NG4gJSAxMW4gPT0gOW5cbiAqL1xuLy8gVE9ETzogdXNlIGZpZWxkIHZlcnNpb24gJiYgcmVtb3ZlXG5leHBvcnQgZnVuY3Rpb24gcG93KG51bSwgcG93ZXIsIG1vZHVsbykge1xuICAgIGlmIChtb2R1bG8gPD0gXzBuIHx8IHBvd2VyIDwgXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHBvd2VyL21vZHVsbyA+IDAnKTtcbiAgICBpZiAobW9kdWxvID09PSBfMW4pXG4gICAgICAgIHJldHVybiBfMG47XG4gICAgbGV0IHJlcyA9IF8xbjtcbiAgICB3aGlsZSAocG93ZXIgPiBfMG4pIHtcbiAgICAgICAgaWYgKHBvd2VyICYgXzFuKVxuICAgICAgICAgICAgcmVzID0gKHJlcyAqIG51bSkgJSBtb2R1bG87XG4gICAgICAgIG51bSA9IChudW0gKiBudW0pICUgbW9kdWxvO1xuICAgICAgICBwb3dlciA+Pj0gXzFuO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLy8gRG9lcyB4IF4gKDIgXiBwb3dlcikgbW9kIHAuIHBvdzIoMzAsIDQpID09IDMwIF4gKDIgXiA0KVxuZXhwb3J0IGZ1bmN0aW9uIHBvdzIoeCwgcG93ZXIsIG1vZHVsbykge1xuICAgIGxldCByZXMgPSB4O1xuICAgIHdoaWxlIChwb3dlci0tID4gXzBuKSB7XG4gICAgICAgIHJlcyAqPSByZXM7XG4gICAgICAgIHJlcyAlPSBtb2R1bG87XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vLyBJbnZlcnNlcyBudW1iZXIgb3ZlciBtb2R1bG9cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnQobnVtYmVyLCBtb2R1bG8pIHtcbiAgICBpZiAobnVtYmVyID09PSBfMG4gfHwgbW9kdWxvIDw9IF8wbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmVydDogZXhwZWN0ZWQgcG9zaXRpdmUgaW50ZWdlcnMsIGdvdCBuPSR7bnVtYmVyfSBtb2Q9JHttb2R1bG99YCk7XG4gICAgfVxuICAgIC8vIEV1Y2xpZGVhbiBHQ0QgaHR0cHM6Ly9icmlsbGlhbnQub3JnL3dpa2kvZXh0ZW5kZWQtZXVjbGlkZWFuLWFsZ29yaXRobS9cbiAgICAvLyBGZXJtYXQncyBsaXR0bGUgdGhlb3JlbSBcIkNULWxpa2VcIiB2ZXJzaW9uIGludihuKSA9IG5eKG0tMikgbW9kIG0gaXMgMzB4IHNsb3dlci5cbiAgICBsZXQgYSA9IG1vZChudW1iZXIsIG1vZHVsbyk7XG4gICAgbGV0IGIgPSBtb2R1bG87XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgbGV0IHggPSBfMG4sIHkgPSBfMW4sIHUgPSBfMW4sIHYgPSBfMG47XG4gICAgd2hpbGUgKGEgIT09IF8wbikge1xuICAgICAgICAvLyBKSVQgYXBwbGllcyBvcHRpbWl6YXRpb24gaWYgdGhvc2UgdHdvIGxpbmVzIGZvbGxvdyBlYWNoIG90aGVyXG4gICAgICAgIGNvbnN0IHEgPSBiIC8gYTtcbiAgICAgICAgY29uc3QgciA9IGIgJSBhO1xuICAgICAgICBjb25zdCBtID0geCAtIHUgKiBxO1xuICAgICAgICBjb25zdCBuID0geSAtIHYgKiBxO1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgYiA9IGEsIGEgPSByLCB4ID0gdSwgeSA9IHYsIHUgPSBtLCB2ID0gbjtcbiAgICB9XG4gICAgY29uc3QgZ2NkID0gYjtcbiAgICBpZiAoZ2NkICE9PSBfMW4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52ZXJ0OiBkb2VzIG5vdCBleGlzdCcpO1xuICAgIHJldHVybiBtb2QoeCwgbW9kdWxvKTtcbn1cbi8qKlxuICogVG9uZWxsaS1TaGFua3Mgc3F1YXJlIHJvb3Qgc2VhcmNoIGFsZ29yaXRobS5cbiAqIDEuIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTIvNjg1LnBkZiAocGFnZSAxMilcbiAqIDIuIFNxdWFyZSBSb290cyBmcm9tIDE7IDI0LCA1MSwgMTAgdG8gRGFuIFNoYW5rc1xuICogV2lsbCBzdGFydCBhbiBpbmZpbml0ZSBsb29wIGlmIGZpZWxkIG9yZGVyIFAgaXMgbm90IHByaW1lLlxuICogQHBhcmFtIFAgZmllbGQgb3JkZXJcbiAqIEByZXR1cm5zIGZ1bmN0aW9uIHRoYXQgdGFrZXMgZmllbGQgRnAgKGNyZWF0ZWQgZnJvbSBQKSBhbmQgbnVtYmVyIG5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvbmVsbGlTaGFua3MoUCkge1xuICAgIC8vIExlZ2VuZHJlIGNvbnN0YW50OiB1c2VkIHRvIGNhbGN1bGF0ZSBMZWdlbmRyZSBzeW1ib2wgKGEgfCBwKSxcbiAgICAvLyB3aGljaCBkZW5vdGVzIHRoZSB2YWx1ZSBvZiBhXigocC0xKS8yKSAobW9kIHApLlxuICAgIC8vIChhIHwgcCkg4omhIDEgICAgaWYgYSBpcyBhIHNxdWFyZSAobW9kIHApXG4gICAgLy8gKGEgfCBwKSDiiaEgLTEgICBpZiBhIGlzIG5vdCBhIHNxdWFyZSAobW9kIHApXG4gICAgLy8gKGEgfCBwKSDiiaEgMCAgICBpZiBhIOKJoSAwIChtb2QgcClcbiAgICBjb25zdCBsZWdlbmRyZUMgPSAoUCAtIF8xbikgLyBfMm47XG4gICAgbGV0IFEsIFMsIFo7XG4gICAgLy8gU3RlcCAxOiBCeSBmYWN0b3Jpbmcgb3V0IHBvd2VycyBvZiAyIGZyb20gcCAtIDEsXG4gICAgLy8gZmluZCBxIGFuZCBzIHN1Y2ggdGhhdCBwIC0gMSA9IHEqKDJecykgd2l0aCBxIG9kZFxuICAgIGZvciAoUSA9IFAgLSBfMW4sIFMgPSAwOyBRICUgXzJuID09PSBfMG47IFEgLz0gXzJuLCBTKyspXG4gICAgICAgIDtcbiAgICAvLyBTdGVwIDI6IFNlbGVjdCBhIG5vbi1zcXVhcmUgeiBzdWNoIHRoYXQgKHogfCBwKSDiiaEgLTEgYW5kIHNldCBjIOKJoSB6cVxuICAgIGZvciAoWiA9IF8ybjsgWiA8IFAgJiYgcG93KFosIGxlZ2VuZHJlQywgUCkgIT09IFAgLSBfMW47IForKylcbiAgICAgICAgO1xuICAgIC8vIEZhc3QtcGF0aFxuICAgIGlmIChTID09PSAxKSB7XG4gICAgICAgIGNvbnN0IHAxZGl2NCA9IChQICsgXzFuKSAvIF80bjtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHRvbmVsbGlGYXN0KEZwLCBuKSB7XG4gICAgICAgICAgICBjb25zdCByb290ID0gRnAucG93KG4sIHAxZGl2NCk7XG4gICAgICAgICAgICBpZiAoIUZwLmVxbChGcC5zcXIocm9vdCksIG4pKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICAgICAgICAgIHJldHVybiByb290O1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBTbG93LXBhdGhcbiAgICBjb25zdCBRMWRpdjIgPSAoUSArIF8xbikgLyBfMm47XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHRvbmVsbGlTbG93KEZwLCBuKSB7XG4gICAgICAgIC8vIFN0ZXAgMDogQ2hlY2sgdGhhdCBuIGlzIGluZGVlZCBhIHNxdWFyZTogKG4gfCBwKSBzaG91bGQgbm90IGJlIOKJoSAtMVxuICAgICAgICBpZiAoRnAucG93KG4sIGxlZ2VuZHJlQykgPT09IEZwLm5lZyhGcC5PTkUpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICBsZXQgciA9IFM7XG4gICAgICAgIC8vIFRPRE86IHdpbGwgZmFpbCBhdCBGcDIvZXRjXG4gICAgICAgIGxldCBnID0gRnAucG93KEZwLm11bChGcC5PTkUsIFopLCBRKTsgLy8gd2lsbCB1cGRhdGUgYm90aCB4IGFuZCBiXG4gICAgICAgIGxldCB4ID0gRnAucG93KG4sIFExZGl2Mik7IC8vIGZpcnN0IGd1ZXNzIGF0IHRoZSBzcXVhcmUgcm9vdFxuICAgICAgICBsZXQgYiA9IEZwLnBvdyhuLCBRKTsgLy8gZmlyc3QgZ3Vlc3MgYXQgdGhlIGZ1ZGdlIGZhY3RvclxuICAgICAgICB3aGlsZSAoIUZwLmVxbChiLCBGcC5PTkUpKSB7XG4gICAgICAgICAgICBpZiAoRnAuZXFsKGIsIEZwLlpFUk8pKVxuICAgICAgICAgICAgICAgIHJldHVybiBGcC5aRVJPOyAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Ub25lbGxpJUUyJTgwJTkzU2hhbmtzX2FsZ29yaXRobSAoNC4gSWYgdCA9IDAsIHJldHVybiByID0gMClcbiAgICAgICAgICAgIC8vIEZpbmQgbSBzdWNoIGJeKDJebSk9PTFcbiAgICAgICAgICAgIGxldCBtID0gMTtcbiAgICAgICAgICAgIGZvciAobGV0IHQyID0gRnAuc3FyKGIpOyBtIDwgcjsgbSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKEZwLmVxbCh0MiwgRnAuT05FKSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgdDIgPSBGcC5zcXIodDIpOyAvLyB0MiAqPSB0MlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTk9URTogci1tLTEgY2FuIGJlIGJpZ2dlciB0aGFuIDMyLCBuZWVkIHRvIGNvbnZlcnQgdG8gYmlnaW50IGJlZm9yZSBzaGlmdCwgb3RoZXJ3aXNlIHRoZXJlIHdpbGwgYmUgb3ZlcmZsb3dcbiAgICAgICAgICAgIGNvbnN0IGdlID0gRnAucG93KGcsIF8xbiA8PCBCaWdJbnQociAtIG0gLSAxKSk7IC8vIGdlID0gMl4oci1tLTEpXG4gICAgICAgICAgICBnID0gRnAuc3FyKGdlKTsgLy8gZyA9IGdlICogZ2VcbiAgICAgICAgICAgIHggPSBGcC5tdWwoeCwgZ2UpOyAvLyB4ICo9IGdlXG4gICAgICAgICAgICBiID0gRnAubXVsKGIsIGcpOyAvLyBiICo9IGdcbiAgICAgICAgICAgIHIgPSBtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4O1xuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gRnBTcXJ0KFApIHtcbiAgICAvLyBOT1RFOiBkaWZmZXJlbnQgYWxnb3JpdGhtcyBjYW4gZ2l2ZSBkaWZmZXJlbnQgcm9vdHMsIGl0IGlzIHVwIHRvIHVzZXIgdG8gZGVjaWRlIHdoaWNoIG9uZSB0aGV5IHdhbnQuXG4gICAgLy8gRm9yIGV4YW1wbGUgdGhlcmUgaXMgRnBTcXJ0T2RkL0ZwU3FydEV2ZW4gdG8gY2hvaWNlIHJvb3QgYmFzZWQgb24gb2RkbmVzcyAodXNlZCBmb3IgaGFzaC10by1jdXJ2ZSkuXG4gICAgLy8gUCDiiaEgMyAobW9kIDQpXG4gICAgLy8g4oiabiA9IG5eKChQKzEpLzQpXG4gICAgaWYgKFAgJSBfNG4gPT09IF8zbikge1xuICAgICAgICAvLyBOb3QgYWxsIHJvb3RzIHBvc3NpYmxlIVxuICAgICAgICAvLyBjb25zdCBPUkRFUiA9XG4gICAgICAgIC8vICAgMHgxYTAxMTFlYTM5N2ZlNjlhNGIxYmE3YjY0MzRiYWNkNzY0Nzc0Yjg0ZjM4NTEyYmY2NzMwZDJhMGY2YjBmNjI0MWVhYmZmZmViMTUzZmZmZmI5ZmVmZmZmZmZmZmFhYWJuO1xuICAgICAgICAvLyBjb25zdCBOVU0gPSA3MjA1NzU5NDAzNzkyNzgxNm47XG4gICAgICAgIGNvbnN0IHAxZGl2NCA9IChQICsgXzFuKSAvIF80bjtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNxcnQzbW9kNChGcCwgbikge1xuICAgICAgICAgICAgY29uc3Qgcm9vdCA9IEZwLnBvdyhuLCBwMWRpdjQpO1xuICAgICAgICAgICAgLy8gVGhyb3cgaWYgcm9vdCoqMiAhPSBuXG4gICAgICAgICAgICBpZiAoIUZwLmVxbChGcC5zcXIocm9vdCksIG4pKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICAgICAgICAgIHJldHVybiByb290O1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBBdGtpbiBhbGdvcml0aG0gZm9yIHEg4omhIDUgKG1vZCA4KSwgaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxMi82ODUucGRmIChwYWdlIDEwKVxuICAgIGlmIChQICUgXzhuID09PSBfNW4pIHtcbiAgICAgICAgY29uc3QgYzEgPSAoUCAtIF81bikgLyBfOG47XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBzcXJ0NW1vZDgoRnAsIG4pIHtcbiAgICAgICAgICAgIGNvbnN0IG4yID0gRnAubXVsKG4sIF8ybik7XG4gICAgICAgICAgICBjb25zdCB2ID0gRnAucG93KG4yLCBjMSk7XG4gICAgICAgICAgICBjb25zdCBudiA9IEZwLm11bChuLCB2KTtcbiAgICAgICAgICAgIGNvbnN0IGkgPSBGcC5tdWwoRnAubXVsKG52LCBfMm4pLCB2KTtcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSBGcC5tdWwobnYsIEZwLnN1YihpLCBGcC5PTkUpKTtcbiAgICAgICAgICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgbikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIFAg4omhIDkgKG1vZCAxNilcbiAgICBpZiAoUCAlIF8xNm4gPT09IF85bikge1xuICAgICAgICAvLyBOT1RFOiB0b25lbGxpIGlzIHRvbyBzbG93IGZvciBibHMtRnAyIGNhbGN1bGF0aW9ucyBldmVuIG9uIHN0YXJ0XG4gICAgICAgIC8vIE1lYW5zIHdlIGNhbm5vdCB1c2Ugc3FydCBmb3IgY29uc3RhbnRzIGF0IGFsbCFcbiAgICAgICAgLy9cbiAgICAgICAgLy8gY29uc3QgYzEgPSBGcC5zcXJ0KEZwLm5lZ2F0ZShGcC5PTkUpKTsgLy8gIDEuIGMxID0gc3FydCgtMSkgaW4gRiwgaS5lLiwgKGMxXjIpID09IC0xIGluIEZcbiAgICAgICAgLy8gY29uc3QgYzIgPSBGcC5zcXJ0KGMxKTsgICAgICAgICAgICAgICAgLy8gIDIuIGMyID0gc3FydChjMSkgaW4gRiwgaS5lLiwgKGMyXjIpID09IGMxIGluIEZcbiAgICAgICAgLy8gY29uc3QgYzMgPSBGcC5zcXJ0KEZwLm5lZ2F0ZShjMSkpOyAgICAgLy8gIDMuIGMzID0gc3FydCgtYzEpIGluIEYsIGkuZS4sIChjM14yKSA9PSAtYzEgaW4gRlxuICAgICAgICAvLyBjb25zdCBjNCA9IChQICsgXzduKSAvIF8xNm47ICAgICAgICAgICAvLyAgNC4gYzQgPSAocSArIDcpIC8gMTYgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgICAgIC8vIHNxcnQgPSAoeCkgPT4ge1xuICAgICAgICAvLyAgIGxldCB0djEgPSBGcC5wb3coeCwgYzQpOyAgICAgICAgICAgICAvLyAgMS4gdHYxID0geF5jNFxuICAgICAgICAvLyAgIGxldCB0djIgPSBGcC5tdWwoYzEsIHR2MSk7ICAgICAgICAgICAvLyAgMi4gdHYyID0gYzEgKiB0djFcbiAgICAgICAgLy8gICBjb25zdCB0djMgPSBGcC5tdWwoYzIsIHR2MSk7ICAgICAgICAgLy8gIDMuIHR2MyA9IGMyICogdHYxXG4gICAgICAgIC8vICAgbGV0IHR2NCA9IEZwLm11bChjMywgdHYxKTsgICAgICAgICAgIC8vICA0LiB0djQgPSBjMyAqIHR2MVxuICAgICAgICAvLyAgIGNvbnN0IGUxID0gRnAuZXF1YWxzKEZwLnNxdWFyZSh0djIpLCB4KTsgLy8gIDUuICBlMSA9ICh0djJeMikgPT0geFxuICAgICAgICAvLyAgIGNvbnN0IGUyID0gRnAuZXF1YWxzKEZwLnNxdWFyZSh0djMpLCB4KTsgLy8gIDYuICBlMiA9ICh0djNeMikgPT0geFxuICAgICAgICAvLyAgIHR2MSA9IEZwLmNtb3YodHYxLCB0djIsIGUxKTsgLy8gIDcuIHR2MSA9IENNT1YodHYxLCB0djIsIGUxKSAgIyBTZWxlY3QgdHYyIGlmICh0djJeMikgPT0geFxuICAgICAgICAvLyAgIHR2MiA9IEZwLmNtb3YodHY0LCB0djMsIGUyKTsgLy8gIDguIHR2MiA9IENNT1YodHY0LCB0djMsIGUyKSAgIyBTZWxlY3QgdHYzIGlmICh0djNeMikgPT0geFxuICAgICAgICAvLyAgIGNvbnN0IGUzID0gRnAuZXF1YWxzKEZwLnNxdWFyZSh0djIpLCB4KTsgLy8gIDkuICBlMyA9ICh0djJeMikgPT0geFxuICAgICAgICAvLyAgIHJldHVybiBGcC5jbW92KHR2MSwgdHYyLCBlMyk7IC8vICAxMC4gIHogPSBDTU9WKHR2MSwgdHYyLCBlMykgICMgU2VsZWN0IHRoZSBzcXJ0IGZyb20gdHYxIGFuZCB0djJcbiAgICAgICAgLy8gfVxuICAgIH1cbiAgICAvLyBPdGhlciBjYXNlczogVG9uZWxsaS1TaGFua3MgYWxnb3JpdGhtXG4gICAgcmV0dXJuIHRvbmVsbGlTaGFua3MoUCk7XG59XG4vLyBMaXR0bGUtZW5kaWFuIGNoZWNrIGZvciBmaXJzdCBMRSBiaXQgKGxhc3QgQkUgYml0KTtcbmV4cG9ydCBjb25zdCBpc05lZ2F0aXZlTEUgPSAobnVtLCBtb2R1bG8pID0+IChtb2QobnVtLCBtb2R1bG8pICYgXzFuKSA9PT0gXzFuO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBGSUVMRF9GSUVMRFMgPSBbXG4gICAgJ2NyZWF0ZScsICdpc1ZhbGlkJywgJ2lzMCcsICduZWcnLCAnaW52JywgJ3NxcnQnLCAnc3FyJyxcbiAgICAnZXFsJywgJ2FkZCcsICdzdWInLCAnbXVsJywgJ3BvdycsICdkaXYnLFxuICAgICdhZGROJywgJ3N1Yk4nLCAnbXVsTicsICdzcXJOJ1xuXTtcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUZpZWxkKGZpZWxkKSB7XG4gICAgY29uc3QgaW5pdGlhbCA9IHtcbiAgICAgICAgT1JERVI6ICdiaWdpbnQnLFxuICAgICAgICBNQVNLOiAnYmlnaW50JyxcbiAgICAgICAgQllURVM6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgQklUUzogJ2lzU2FmZUludGVnZXInLFxuICAgIH07XG4gICAgY29uc3Qgb3B0cyA9IEZJRUxEX0ZJRUxEUy5yZWR1Y2UoKG1hcCwgdmFsKSA9PiB7XG4gICAgICAgIG1hcFt2YWxdID0gJ2Z1bmN0aW9uJztcbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICB9LCBpbml0aWFsKTtcbiAgICByZXR1cm4gdmFsaWRhdGVPYmplY3QoZmllbGQsIG9wdHMpO1xufVxuLy8gR2VuZXJpYyBmaWVsZCBmdW5jdGlvbnNcbi8qKlxuICogU2FtZSBhcyBgcG93YCBidXQgZm9yIEZwOiBub24tY29uc3RhbnQtdGltZS5cbiAqIFVuc2FmZSBpbiBzb21lIGNvbnRleHRzOiB1c2VzIGxhZGRlciwgc28gY2FuIGV4cG9zZSBiaWdpbnQgYml0cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEZwUG93KGYsIG51bSwgcG93ZXIpIHtcbiAgICAvLyBTaG91bGQgaGF2ZSBzYW1lIHNwZWVkIGFzIHBvdyBmb3IgYmlnaW50c1xuICAgIC8vIFRPRE86IGJlbmNobWFyayFcbiAgICBpZiAocG93ZXIgPCBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcG93ZXIgPiAwJyk7XG4gICAgaWYgKHBvd2VyID09PSBfMG4pXG4gICAgICAgIHJldHVybiBmLk9ORTtcbiAgICBpZiAocG93ZXIgPT09IF8xbilcbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICBsZXQgcCA9IGYuT05FO1xuICAgIGxldCBkID0gbnVtO1xuICAgIHdoaWxlIChwb3dlciA+IF8wbikge1xuICAgICAgICBpZiAocG93ZXIgJiBfMW4pXG4gICAgICAgICAgICBwID0gZi5tdWwocCwgZCk7XG4gICAgICAgIGQgPSBmLnNxcihkKTtcbiAgICAgICAgcG93ZXIgPj49IF8xbjtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG59XG4vKipcbiAqIEVmZmljaWVudGx5IGludmVydCBhbiBhcnJheSBvZiBGaWVsZCBlbGVtZW50cy5cbiAqIGBpbnYoMClgIHdpbGwgcmV0dXJuIGB1bmRlZmluZWRgIGhlcmU6IG1ha2Ugc3VyZSB0byB0aHJvdyBhbiBlcnJvci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEZwSW52ZXJ0QmF0Y2goZiwgbnVtcykge1xuICAgIGNvbnN0IHRtcCA9IG5ldyBBcnJheShudW1zLmxlbmd0aCk7XG4gICAgLy8gV2FsayBmcm9tIGZpcnN0IHRvIGxhc3QsIG11bHRpcGx5IHRoZW0gYnkgZWFjaCBvdGhlciBNT0QgcFxuICAgIGNvbnN0IGxhc3RNdWx0aXBsaWVkID0gbnVtcy5yZWR1Y2UoKGFjYywgbnVtLCBpKSA9PiB7XG4gICAgICAgIGlmIChmLmlzMChudW0pKVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgdG1wW2ldID0gYWNjO1xuICAgICAgICByZXR1cm4gZi5tdWwoYWNjLCBudW0pO1xuICAgIH0sIGYuT05FKTtcbiAgICAvLyBJbnZlcnQgbGFzdCBlbGVtZW50XG4gICAgY29uc3QgaW52ZXJ0ZWQgPSBmLmludihsYXN0TXVsdGlwbGllZCk7XG4gICAgLy8gV2FsayBmcm9tIGxhc3QgdG8gZmlyc3QsIG11bHRpcGx5IHRoZW0gYnkgaW52ZXJ0ZWQgZWFjaCBvdGhlciBNT0QgcFxuICAgIG51bXMucmVkdWNlUmlnaHQoKGFjYywgbnVtLCBpKSA9PiB7XG4gICAgICAgIGlmIChmLmlzMChudW0pKVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgdG1wW2ldID0gZi5tdWwoYWNjLCB0bXBbaV0pO1xuICAgICAgICByZXR1cm4gZi5tdWwoYWNjLCBudW0pO1xuICAgIH0sIGludmVydGVkKTtcbiAgICByZXR1cm4gdG1wO1xufVxuZXhwb3J0IGZ1bmN0aW9uIEZwRGl2KGYsIGxocywgcmhzKSB7XG4gICAgcmV0dXJuIGYubXVsKGxocywgdHlwZW9mIHJocyA9PT0gJ2JpZ2ludCcgPyBpbnZlcnQocmhzLCBmLk9SREVSKSA6IGYuaW52KHJocykpO1xufVxuLy8gVGhpcyBmdW5jdGlvbiByZXR1cm5zIFRydWUgd2hlbmV2ZXIgdGhlIHZhbHVlIHggaXMgYSBzcXVhcmUgaW4gdGhlIGZpZWxkIEYuXG5leHBvcnQgZnVuY3Rpb24gRnBJc1NxdWFyZShmKSB7XG4gICAgY29uc3QgbGVnZW5kcmVDb25zdCA9IChmLk9SREVSIC0gXzFuKSAvIF8ybjsgLy8gSW50ZWdlciBhcml0aG1ldGljXG4gICAgcmV0dXJuICh4KSA9PiB7XG4gICAgICAgIGNvbnN0IHAgPSBmLnBvdyh4LCBsZWdlbmRyZUNvbnN0KTtcbiAgICAgICAgcmV0dXJuIGYuZXFsKHAsIGYuWkVSTykgfHwgZi5lcWwocCwgZi5PTkUpO1xuICAgIH07XG59XG4vLyBDVVJWRS5uIGxlbmd0aHNcbmV4cG9ydCBmdW5jdGlvbiBuTGVuZ3RoKG4sIG5CaXRMZW5ndGgpIHtcbiAgICAvLyBCaXQgc2l6ZSwgYnl0ZSBzaXplIG9mIENVUlZFLm5cbiAgICBjb25zdCBfbkJpdExlbmd0aCA9IG5CaXRMZW5ndGggIT09IHVuZGVmaW5lZCA/IG5CaXRMZW5ndGggOiBuLnRvU3RyaW5nKDIpLmxlbmd0aDtcbiAgICBjb25zdCBuQnl0ZUxlbmd0aCA9IE1hdGguY2VpbChfbkJpdExlbmd0aCAvIDgpO1xuICAgIHJldHVybiB7IG5CaXRMZW5ndGg6IF9uQml0TGVuZ3RoLCBuQnl0ZUxlbmd0aCB9O1xufVxuLyoqXG4gKiBJbml0aWFsaXplcyBhIGZpbml0ZSBmaWVsZCBvdmVyIHByaW1lLiAqKk5vbi1wcmltZXMgYXJlIG5vdCBzdXBwb3J0ZWQuKipcbiAqIERvIG5vdCBpbml0IGluIGxvb3A6IHNsb3cuIFZlcnkgZnJhZ2lsZTogYWx3YXlzIHJ1biBhIGJlbmNobWFyayBvbiBhIGNoYW5nZS5cbiAqIE1ham9yIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbnM6XG4gKiAqIGEpIGRlbm9ybWFsaXplZCBvcGVyYXRpb25zIGxpa2UgbXVsTiBpbnN0ZWFkIG9mIG11bFxuICogKiBiKSBzYW1lIG9iamVjdCBzaGFwZTogbmV2ZXIgYWRkIG9yIHJlbW92ZSBrZXlzXG4gKiAqIGMpIE9iamVjdC5mcmVlemVcbiAqIEBwYXJhbSBPUkRFUiBwcmltZSBwb3NpdGl2ZSBiaWdpbnRcbiAqIEBwYXJhbSBiaXRMZW4gaG93IG1hbnkgYml0cyB0aGUgZmllbGQgY29uc3VtZXNcbiAqIEBwYXJhbSBpc0xFIChkZWY6IGZhbHNlKSBpZiBlbmNvZGluZyAvIGRlY29kaW5nIHNob3VsZCBiZSBpbiBsaXR0bGUtZW5kaWFuXG4gKiBAcGFyYW0gcmVkZWYgb3B0aW9uYWwgZmFzdGVyIHJlZGVmaW5pdGlvbnMgb2Ygc3FydCBhbmQgb3RoZXIgbWV0aG9kc1xuICovXG5leHBvcnQgZnVuY3Rpb24gRmllbGQoT1JERVIsIGJpdExlbiwgaXNMRSA9IGZhbHNlLCByZWRlZiA9IHt9KSB7XG4gICAgaWYgKE9SREVSIDw9IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBGaWVsZCBPUkRFUiA+IDAsIGdvdCAke09SREVSfWApO1xuICAgIGNvbnN0IHsgbkJpdExlbmd0aDogQklUUywgbkJ5dGVMZW5ndGg6IEJZVEVTIH0gPSBuTGVuZ3RoKE9SREVSLCBiaXRMZW4pO1xuICAgIGlmIChCWVRFUyA+IDIwNDgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmllbGQgbGVuZ3RocyBvdmVyIDIwNDggYnl0ZXMgYXJlIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICBjb25zdCBzcXJ0UCA9IEZwU3FydChPUkRFUik7XG4gICAgY29uc3QgZiA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBPUkRFUixcbiAgICAgICAgQklUUyxcbiAgICAgICAgQllURVMsXG4gICAgICAgIE1BU0s6IGJpdE1hc2soQklUUyksXG4gICAgICAgIFpFUk86IF8wbixcbiAgICAgICAgT05FOiBfMW4sXG4gICAgICAgIGNyZWF0ZTogKG51bSkgPT4gbW9kKG51bSwgT1JERVIpLFxuICAgICAgICBpc1ZhbGlkOiAobnVtKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG51bSAhPT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGZpZWxkIGVsZW1lbnQ6IGV4cGVjdGVkIGJpZ2ludCwgZ290ICR7dHlwZW9mIG51bX1gKTtcbiAgICAgICAgICAgIHJldHVybiBfMG4gPD0gbnVtICYmIG51bSA8IE9SREVSOyAvLyAwIGlzIHZhbGlkIGVsZW1lbnQsIGJ1dCBpdCdzIG5vdCBpbnZlcnRpYmxlXG4gICAgICAgIH0sXG4gICAgICAgIGlzMDogKG51bSkgPT4gbnVtID09PSBfMG4sXG4gICAgICAgIGlzT2RkOiAobnVtKSA9PiAobnVtICYgXzFuKSA9PT0gXzFuLFxuICAgICAgICBuZWc6IChudW0pID0+IG1vZCgtbnVtLCBPUkRFUiksXG4gICAgICAgIGVxbDogKGxocywgcmhzKSA9PiBsaHMgPT09IHJocyxcbiAgICAgICAgc3FyOiAobnVtKSA9PiBtb2QobnVtICogbnVtLCBPUkRFUiksXG4gICAgICAgIGFkZDogKGxocywgcmhzKSA9PiBtb2QobGhzICsgcmhzLCBPUkRFUiksXG4gICAgICAgIHN1YjogKGxocywgcmhzKSA9PiBtb2QobGhzIC0gcmhzLCBPUkRFUiksXG4gICAgICAgIG11bDogKGxocywgcmhzKSA9PiBtb2QobGhzICogcmhzLCBPUkRFUiksXG4gICAgICAgIHBvdzogKG51bSwgcG93ZXIpID0+IEZwUG93KGYsIG51bSwgcG93ZXIpLFxuICAgICAgICBkaXY6IChsaHMsIHJocykgPT4gbW9kKGxocyAqIGludmVydChyaHMsIE9SREVSKSwgT1JERVIpLFxuICAgICAgICAvLyBTYW1lIGFzIGFib3ZlLCBidXQgZG9lc24ndCBub3JtYWxpemVcbiAgICAgICAgc3FyTjogKG51bSkgPT4gbnVtICogbnVtLFxuICAgICAgICBhZGROOiAobGhzLCByaHMpID0+IGxocyArIHJocyxcbiAgICAgICAgc3ViTjogKGxocywgcmhzKSA9PiBsaHMgLSByaHMsXG4gICAgICAgIG11bE46IChsaHMsIHJocykgPT4gbGhzICogcmhzLFxuICAgICAgICBpbnY6IChudW0pID0+IGludmVydChudW0sIE9SREVSKSxcbiAgICAgICAgc3FydDogcmVkZWYuc3FydCB8fCAoKG4pID0+IHNxcnRQKGYsIG4pKSxcbiAgICAgICAgaW52ZXJ0QmF0Y2g6IChsc3QpID0+IEZwSW52ZXJ0QmF0Y2goZiwgbHN0KSxcbiAgICAgICAgLy8gVE9ETzogZG8gd2UgcmVhbGx5IG5lZWQgY29uc3RhbnQgY21vdj9cbiAgICAgICAgLy8gV2UgZG9uJ3QgaGF2ZSBjb25zdC10aW1lIGJpZ2ludHMgYW55d2F5LCBzbyBwcm9iYWJseSB3aWxsIGJlIG5vdCB2ZXJ5IHVzZWZ1bFxuICAgICAgICBjbW92OiAoYSwgYiwgYykgPT4gKGMgPyBiIDogYSksXG4gICAgICAgIHRvQnl0ZXM6IChudW0pID0+IChpc0xFID8gbnVtYmVyVG9CeXRlc0xFKG51bSwgQllURVMpIDogbnVtYmVyVG9CeXRlc0JFKG51bSwgQllURVMpKSxcbiAgICAgICAgZnJvbUJ5dGVzOiAoYnl0ZXMpID0+IHtcbiAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggIT09IEJZVEVTKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRnAuZnJvbUJ5dGVzOiBleHBlY3RlZCAke0JZVEVTfSwgZ290ICR7Ynl0ZXMubGVuZ3RofWApO1xuICAgICAgICAgICAgcmV0dXJuIGlzTEUgPyBieXRlc1RvTnVtYmVyTEUoYnl0ZXMpIDogYnl0ZXNUb051bWJlckJFKGJ5dGVzKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShmKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBGcFNxcnRPZGQoRnAsIGVsbSkge1xuICAgIGlmICghRnAuaXNPZGQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmllbGQgZG9lc24ndCBoYXZlIGlzT2RkYCk7XG4gICAgY29uc3Qgcm9vdCA9IEZwLnNxcnQoZWxtKTtcbiAgICByZXR1cm4gRnAuaXNPZGQocm9vdCkgPyByb290IDogRnAubmVnKHJvb3QpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIEZwU3FydEV2ZW4oRnAsIGVsbSkge1xuICAgIGlmICghRnAuaXNPZGQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmllbGQgZG9lc24ndCBoYXZlIGlzT2RkYCk7XG4gICAgY29uc3Qgcm9vdCA9IEZwLnNxcnQoZWxtKTtcbiAgICByZXR1cm4gRnAuaXNPZGQocm9vdCkgPyBGcC5uZWcocm9vdCkgOiByb290O1xufVxuLyoqXG4gKiBcIkNvbnN0YW50LXRpbWVcIiBwcml2YXRlIGtleSBnZW5lcmF0aW9uIHV0aWxpdHkuXG4gKiBTYW1lIGFzIG1hcEtleVRvRmllbGQsIGJ1dCBhY2NlcHRzIGxlc3MgYnl0ZXMgKDQwIGluc3RlYWQgb2YgNDggZm9yIDMyLWJ5dGUgZmllbGQpLlxuICogV2hpY2ggbWFrZXMgaXQgc2xpZ2h0bHkgbW9yZSBiaWFzZWQsIGxlc3Mgc2VjdXJlLlxuICogQGRlcHJlY2F0ZWQgdXNlIG1hcEtleVRvRmllbGQgaW5zdGVhZFxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzaFRvUHJpdmF0ZVNjYWxhcihoYXNoLCBncm91cE9yZGVyLCBpc0xFID0gZmFsc2UpIHtcbiAgICBoYXNoID0gZW5zdXJlQnl0ZXMoJ3ByaXZhdGVIYXNoJywgaGFzaCk7XG4gICAgY29uc3QgaGFzaExlbiA9IGhhc2gubGVuZ3RoO1xuICAgIGNvbnN0IG1pbkxlbiA9IG5MZW5ndGgoZ3JvdXBPcmRlcikubkJ5dGVMZW5ndGggKyA4O1xuICAgIGlmIChtaW5MZW4gPCAyNCB8fCBoYXNoTGVuIDwgbWluTGVuIHx8IGhhc2hMZW4gPiAxMDI0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGhhc2hUb1ByaXZhdGVTY2FsYXI6IGV4cGVjdGVkICR7bWluTGVufS0xMDI0IGJ5dGVzIG9mIGlucHV0LCBnb3QgJHtoYXNoTGVufWApO1xuICAgIGNvbnN0IG51bSA9IGlzTEUgPyBieXRlc1RvTnVtYmVyTEUoaGFzaCkgOiBieXRlc1RvTnVtYmVyQkUoaGFzaCk7XG4gICAgcmV0dXJuIG1vZChudW0sIGdyb3VwT3JkZXIgLSBfMW4pICsgXzFuO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRvdGFsIG51bWJlciBvZiBieXRlcyBjb25zdW1lZCBieSB0aGUgZmllbGQgZWxlbWVudC5cbiAqIEZvciBleGFtcGxlLCAzMiBieXRlcyBmb3IgdXN1YWwgMjU2LWJpdCB3ZWllcnN0cmFzcyBjdXJ2ZS5cbiAqIEBwYXJhbSBmaWVsZE9yZGVyIG51bWJlciBvZiBmaWVsZCBlbGVtZW50cywgdXN1YWxseSBDVVJWRS5uXG4gKiBAcmV0dXJucyBieXRlIGxlbmd0aCBvZiBmaWVsZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmllbGRCeXRlc0xlbmd0aChmaWVsZE9yZGVyKSB7XG4gICAgaWYgKHR5cGVvZiBmaWVsZE9yZGVyICE9PSAnYmlnaW50JylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaWVsZCBvcmRlciBtdXN0IGJlIGJpZ2ludCcpO1xuICAgIGNvbnN0IGJpdExlbmd0aCA9IGZpZWxkT3JkZXIudG9TdHJpbmcoMikubGVuZ3RoO1xuICAgIHJldHVybiBNYXRoLmNlaWwoYml0TGVuZ3RoIC8gOCk7XG59XG4vKipcbiAqIFJldHVybnMgbWluaW1hbCBhbW91bnQgb2YgYnl0ZXMgdGhhdCBjYW4gYmUgc2FmZWx5IHJlZHVjZWRcbiAqIGJ5IGZpZWxkIG9yZGVyLlxuICogU2hvdWxkIGJlIDJeLTEyOCBmb3IgMTI4LWJpdCBjdXJ2ZSBzdWNoIGFzIFAyNTYuXG4gKiBAcGFyYW0gZmllbGRPcmRlciBudW1iZXIgb2YgZmllbGQgZWxlbWVudHMsIHVzdWFsbHkgQ1VSVkUublxuICogQHJldHVybnMgYnl0ZSBsZW5ndGggb2YgdGFyZ2V0IGhhc2hcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE1pbkhhc2hMZW5ndGgoZmllbGRPcmRlcikge1xuICAgIGNvbnN0IGxlbmd0aCA9IGdldEZpZWxkQnl0ZXNMZW5ndGgoZmllbGRPcmRlcik7XG4gICAgcmV0dXJuIGxlbmd0aCArIE1hdGguY2VpbChsZW5ndGggLyAyKTtcbn1cbi8qKlxuICogXCJDb25zdGFudC10aW1lXCIgcHJpdmF0ZSBrZXkgZ2VuZXJhdGlvbiB1dGlsaXR5LlxuICogQ2FuIHRha2UgKG4gKyBuLzIpIG9yIG1vcmUgYnl0ZXMgb2YgdW5pZm9ybSBpbnB1dCBlLmcuIGZyb20gQ1NQUk5HIG9yIEtERlxuICogYW5kIGNvbnZlcnQgdGhlbSBpbnRvIHByaXZhdGUgc2NhbGFyLCB3aXRoIHRoZSBtb2R1bG8gYmlhcyBiZWluZyBuZWdsaWdpYmxlLlxuICogTmVlZHMgYXQgbGVhc3QgNDggYnl0ZXMgb2YgaW5wdXQgZm9yIDMyLWJ5dGUgcHJpdmF0ZSBrZXkuXG4gKiBodHRwczovL3Jlc2VhcmNoLmt1ZGVsc2tpc2VjdXJpdHkuY29tLzIwMjAvMDcvMjgvdGhlLWRlZmluaXRpdmUtZ3VpZGUtdG8tbW9kdWxvLWJpYXMtYW5kLWhvdy10by1hdm9pZC1pdC9cbiAqIEZJUFMgMTg2LTUsIEEuMiBodHRwczovL2NzcmMubmlzdC5nb3YvcHVibGljYXRpb25zL2RldGFpbC9maXBzLzE4Ni81L2ZpbmFsXG4gKiBSRkMgOTM4MCwgaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01XG4gKiBAcGFyYW0gaGFzaCBoYXNoIG91dHB1dCBmcm9tIFNIQTMgb3IgYSBzaW1pbGFyIGZ1bmN0aW9uXG4gKiBAcGFyYW0gZ3JvdXBPcmRlciBzaXplIG9mIHN1Ymdyb3VwIC0gKGUuZy4gc2VjcDI1NmsxLkNVUlZFLm4pXG4gKiBAcGFyYW0gaXNMRSBpbnRlcnByZXQgaGFzaCBieXRlcyBhcyBMRSBudW1cbiAqIEByZXR1cm5zIHZhbGlkIHByaXZhdGUgc2NhbGFyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBIYXNoVG9GaWVsZChrZXksIGZpZWxkT3JkZXIsIGlzTEUgPSBmYWxzZSkge1xuICAgIGNvbnN0IGxlbiA9IGtleS5sZW5ndGg7XG4gICAgY29uc3QgZmllbGRMZW4gPSBnZXRGaWVsZEJ5dGVzTGVuZ3RoKGZpZWxkT3JkZXIpO1xuICAgIGNvbnN0IG1pbkxlbiA9IGdldE1pbkhhc2hMZW5ndGgoZmllbGRPcmRlcik7XG4gICAgLy8gTm8gc21hbGwgbnVtYmVyczogbmVlZCB0byB1bmRlcnN0YW5kIGJpYXMgc3RvcnkuIE5vIGh1Z2UgbnVtYmVyczogZWFzaWVyIHRvIGRldGVjdCBKUyB0aW1pbmdzLlxuICAgIGlmIChsZW4gPCAxNiB8fCBsZW4gPCBtaW5MZW4gfHwgbGVuID4gMTAyNClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCAke21pbkxlbn0tMTAyNCBieXRlcyBvZiBpbnB1dCwgZ290ICR7bGVufWApO1xuICAgIGNvbnN0IG51bSA9IGlzTEUgPyBieXRlc1RvTnVtYmVyQkUoa2V5KSA6IGJ5dGVzVG9OdW1iZXJMRShrZXkpO1xuICAgIC8vIGBtb2QoeCwgMTEpYCBjYW4gc29tZXRpbWVzIHByb2R1Y2UgMC4gYG1vZCh4LCAxMCkgKyAxYCBpcyB0aGUgc2FtZSwgYnV0IG5vIDBcbiAgICBjb25zdCByZWR1Y2VkID0gbW9kKG51bSwgZmllbGRPcmRlciAtIF8xbikgKyBfMW47XG4gICAgcmV0dXJuIGlzTEUgPyBudW1iZXJUb0J5dGVzTEUocmVkdWNlZCwgZmllbGRMZW4pIDogbnVtYmVyVG9CeXRlc0JFKHJlZHVjZWQsIGZpZWxkTGVuKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsYXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/modular.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/utils.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/utils.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bitGet: () => (/* binding */ bitGet),\n/* harmony export */   bitLen: () => (/* binding */ bitLen),\n/* harmony export */   bitMask: () => (/* binding */ bitMask),\n/* harmony export */   bitSet: () => (/* binding */ bitSet),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   bytesToNumberBE: () => (/* binding */ bytesToNumberBE),\n/* harmony export */   bytesToNumberLE: () => (/* binding */ bytesToNumberLE),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createHmacDrbg: () => (/* binding */ createHmacDrbg),\n/* harmony export */   ensureBytes: () => (/* binding */ ensureBytes),\n/* harmony export */   equalBytes: () => (/* binding */ equalBytes),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   hexToNumber: () => (/* binding */ hexToNumber),\n/* harmony export */   numberToBytesBE: () => (/* binding */ numberToBytesBE),\n/* harmony export */   numberToBytesLE: () => (/* binding */ numberToBytesLE),\n/* harmony export */   numberToHexUnpadded: () => (/* binding */ numberToHexUnpadded),\n/* harmony export */   numberToVarBytesBE: () => (/* binding */ numberToVarBytesBE),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   validateObject: () => (/* binding */ validateObject)\n/* harmony export */ });\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst u8a = (a) => a instanceof Uint8Array;\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    if (!u8a(bytes))\n        throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // Big Endian\n    return BigInt(hex === '' ? '0' : `0x${hex}`);\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const len = hex.length;\n    if (len % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n    const array = new Uint8Array(len / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction bytesToNumberLE(bytes) {\n    if (!u8a(bytes))\n        throw new Error('Uint8Array expected');\n    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nfunction numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nfunction numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nfunction numberToVarBytesBE(n) {\n    return hexToBytes(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nfunction ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === 'string') {\n        try {\n            res = hexToBytes(hex);\n        }\n        catch (e) {\n            throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`);\n        }\n    }\n    else if (u8a(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    }\n    else {\n        throw new Error(`${title} must be hex string or Uint8Array`);\n    }\n    const len = res.length;\n    if (typeof expectedLength === 'number' && len !== expectedLength)\n        throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);\n    return res;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n    let pad = 0; // walk through each item, ensure they have proper type\n    arrays.forEach((a) => {\n        if (!u8a(a))\n            throw new Error('Uint8Array expected');\n        r.set(a, pad);\n        pad += a.length;\n    });\n    return r;\n}\nfunction equalBytes(b1, b2) {\n    // We don't care about timing attacks here\n    if (b1.length !== b2.length)\n        return false;\n    for (let i = 0; i < b1.length; i++)\n        if (b1[i] !== b2[i])\n            return false;\n    return true;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */\nfunction bitLen(n) {\n    let len;\n    for (len = 0; n > _0n; n >>= _1n, len += 1)\n        ;\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nfunction bitGet(n, pos) {\n    return (n >> BigInt(pos)) & _1n;\n}\n/**\n * Sets single bit at position.\n */\nconst bitSet = (n, pos, value) => {\n    return n | ((value ? _1n : _0n) << BigInt(pos));\n};\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nconst bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;\n// DRBG\nconst u8n = (data) => new Uint8Array(data); // creates Uint8Array\nconst u8fr = (arr) => Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nfunction createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== 'number' || hashLen < 2)\n        throw new Error('hashLen must be a number');\n    if (typeof qByteLen !== 'number' || qByteLen < 2)\n        throw new Error('qByteLen must be a number');\n    if (typeof hmacFn !== 'function')\n        throw new Error('hmacFn must be a function');\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = () => {\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n()) => {\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0)\n            return;\n        k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = () => {\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000)\n            throw new Error('drbg: tried 1000 values');\n        let len = 0;\n        const out = [];\n        while (len < qByteLen) {\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes(...out);\n    };\n    const genUntil = (seed, pred) => {\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while (!(res = pred(gen())))\n            reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val) => typeof val === 'bigint',\n    function: (val) => typeof val === 'function',\n    boolean: (val) => typeof val === 'boolean',\n    string: (val) => typeof val === 'string',\n    stringOrUint8Array: (val) => typeof val === 'string' || val instanceof Uint8Array,\n    isSafeInteger: (val) => Number.isSafeInteger(val),\n    array: (val) => Array.isArray(val),\n    field: (val, object) => object.Fp.isValid(val),\n    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nfunction validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional) => {\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== 'function')\n            throw new Error(`Invalid validator \"${type}\", expected function`);\n        const val = object[fieldName];\n        if (isOptional && val === undefined)\n            return;\n        if (!checkVal(val, object)) {\n            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))\n        checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))\n        checkField(fieldName, type, true);\n    return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxhQUFhO0FBQ3hEO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsSUFBSTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE9BQU8saUNBQWlDLElBQUksWUFBWSxFQUFFO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTyxXQUFXLGdCQUFnQixhQUFhLElBQUk7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSw0REFBNEQsV0FBVztBQUN2RSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDRCQUE0QjtBQUNuRDtBQUNPO0FBQ1A7QUFDQSw0Q0FBNEM7QUFDNUMsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUNuRCw4REFBOEQ7QUFDckU7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELEtBQUs7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsa0JBQWtCLEdBQUcsS0FBSyxHQUFHLFdBQVcsY0FBYyxLQUFLO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsV0FBVyxXQUFXLFlBQVksSUFBSTtBQUNwRCxrQ0FBa0Msb0JBQW9CLElBQUksYUFBYSxHQUFHO0FBQzFFO0FBQ0Esa0NBQWtDLFVBQVUsSUFBSSxTQUFTO0FBQ3pELGtDQUFrQyxvQkFBb0IsSUFBSSxTQUFTO0FBQ25FLGtDQUFrQywyQkFBMkI7QUFDN0Qsa0NBQWtDLHdCQUF3QjtBQUMxRCIsInNvdXJjZXMiOlsiL2hvbWUvbGZnL0dpdC9NYWR0cmlwcy9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvdXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gMTAwIGxpbmVzIG9mIGNvZGUgaW4gdGhlIGZpbGUgYXJlIGR1cGxpY2F0ZWQgZnJvbSBub2JsZS1oYXNoZXMgKHV0aWxzKS5cbi8vIFRoaXMgaXMgT0s6IGBhYnN0cmFjdGAgZGlyZWN0b3J5IGRvZXMgbm90IHVzZSBub2JsZS1oYXNoZXMuXG4vLyBVc2VyIG1heSBvcHQtaW4gaW50byB1c2luZyBkaWZmZXJlbnQgaGFzaGluZyBsaWJyYXJ5LiBUaGlzIHdheSwgbm9ibGUtaGFzaGVzXG4vLyB3b24ndCBiZSBpbmNsdWRlZCBpbnRvIHRoZWlyIGJ1bmRsZS5cbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbmNvbnN0IF8ybiA9IEJpZ0ludCgyKTtcbmNvbnN0IHU4YSA9IChhKSA9PiBhIGluc3RhbmNlb2YgVWludDhBcnJheTtcbmNvbnN0IGhleGVzID0gLyogQF9fUFVSRV9fICovIEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoXywgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG4vKipcbiAqIEBleGFtcGxlIGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSkpIC8vICdjYWZlMDEyMydcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9IZXgoYnl0ZXMpIHtcbiAgICBpZiAoIXU4YShieXRlcykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgIC8vIHByZS1jYWNoaW5nIGltcHJvdmVzIHRoZSBzcGVlZCA2eFxuICAgIGxldCBoZXggPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhleCArPSBoZXhlc1tieXRlc1tpXV07XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59XG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9IZXhVbnBhZGRlZChudW0pIHtcbiAgICBjb25zdCBoZXggPSBudW0udG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBoZXgubGVuZ3RoICYgMSA/IGAwJHtoZXh9YCA6IGhleDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb051bWJlcihoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICAvLyBCaWcgRW5kaWFuXG4gICAgcmV0dXJuIEJpZ0ludChoZXggPT09ICcnID8gJzAnIDogYDB4JHtoZXh9YCk7XG59XG4vKipcbiAqIEBleGFtcGxlIGhleFRvQnl0ZXMoJ2NhZmUwMTIzJykgLy8gVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgY29uc3QgbGVuID0gaGV4Lmxlbmd0aDtcbiAgICBpZiAobGVuICUgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkZWQgaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IHVucGFkZGVkIGhleCBvZiBsZW5ndGggJyArIGxlbik7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShsZW4gLyAyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGogPSBpICogMjtcbiAgICAgICAgY29uc3QgaGV4Qnl0ZSA9IGhleC5zbGljZShqLCBqICsgMik7XG4gICAgICAgIGNvbnN0IGJ5dGUgPSBOdW1iZXIucGFyc2VJbnQoaGV4Qnl0ZSwgMTYpO1xuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKGJ5dGUpIHx8IGJ5dGUgPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJ5dGUgc2VxdWVuY2UnKTtcbiAgICAgICAgYXJyYXlbaV0gPSBieXRlO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG4vLyBCRTogQmlnIEVuZGlhbiwgTEU6IExpdHRsZSBFbmRpYW5cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvTnVtYmVyQkUoYnl0ZXMpIHtcbiAgICByZXR1cm4gaGV4VG9OdW1iZXIoYnl0ZXNUb0hleChieXRlcykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9OdW1iZXJMRShieXRlcykge1xuICAgIGlmICghdThhKGJ5dGVzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgcmV0dXJuIGhleFRvTnVtYmVyKGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKGJ5dGVzKS5yZXZlcnNlKCkpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb0J5dGVzQkUobiwgbGVuKSB7XG4gICAgcmV0dXJuIGhleFRvQnl0ZXMobi50b1N0cmluZygxNikucGFkU3RhcnQobGVuICogMiwgJzAnKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9CeXRlc0xFKG4sIGxlbikge1xuICAgIHJldHVybiBudW1iZXJUb0J5dGVzQkUobiwgbGVuKS5yZXZlcnNlKCk7XG59XG4vLyBVbnBhZGRlZCwgcmFyZWx5IHVzZWRcbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb1ZhckJ5dGVzQkUobikge1xuICAgIHJldHVybiBoZXhUb0J5dGVzKG51bWJlclRvSGV4VW5wYWRkZWQobikpO1xufVxuLyoqXG4gKiBUYWtlcyBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXksIGNvbnZlcnRzIHRvIFVpbnQ4QXJyYXkuXG4gKiBWYWxpZGF0ZXMgb3V0cHV0IGxlbmd0aC5cbiAqIFdpbGwgdGhyb3cgZXJyb3IgZm9yIG90aGVyIHR5cGVzLlxuICogQHBhcmFtIHRpdGxlIGRlc2NyaXB0aXZlIHRpdGxlIGZvciBhbiBlcnJvciBlLmcuICdwcml2YXRlIGtleSdcbiAqIEBwYXJhbSBoZXggaGV4IHN0cmluZyBvciBVaW50OEFycmF5XG4gKiBAcGFyYW0gZXhwZWN0ZWRMZW5ndGggb3B0aW9uYWwsIHdpbGwgY29tcGFyZSB0byByZXN1bHQgYXJyYXkncyBsZW5ndGhcbiAqIEByZXR1cm5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVCeXRlcyh0aXRsZSwgaGV4LCBleHBlY3RlZExlbmd0aCkge1xuICAgIGxldCByZXM7XG4gICAgaWYgKHR5cGVvZiBoZXggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXMgPSBoZXhUb0J5dGVzKGhleCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aXRsZX0gbXVzdCBiZSB2YWxpZCBoZXggc3RyaW5nLCBnb3QgXCIke2hleH1cIi4gQ2F1c2U6ICR7ZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh1OGEoaGV4KSkge1xuICAgICAgICAvLyBVaW50OEFycmF5LmZyb20oKSBpbnN0ZWFkIG9mIGhhc2guc2xpY2UoKSBiZWNhdXNlIG5vZGUuanMgQnVmZmVyXG4gICAgICAgIC8vIGlzIGluc3RhbmNlIG9mIFVpbnQ4QXJyYXksIGFuZCBpdHMgc2xpY2UoKSBjcmVhdGVzICoqbXV0YWJsZSoqIGNvcHlcbiAgICAgICAgcmVzID0gVWludDhBcnJheS5mcm9tKGhleCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGl0bGV9IG11c3QgYmUgaGV4IHN0cmluZyBvciBVaW50OEFycmF5YCk7XG4gICAgfVxuICAgIGNvbnN0IGxlbiA9IHJlcy5sZW5ndGg7XG4gICAgaWYgKHR5cGVvZiBleHBlY3RlZExlbmd0aCA9PT0gJ251bWJlcicgJiYgbGVuICE9PSBleHBlY3RlZExlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RpdGxlfSBleHBlY3RlZCAke2V4cGVjdGVkTGVuZ3RofSBieXRlcywgZ290ICR7bGVufWApO1xuICAgIHJldHVybiByZXM7XG59XG4vKipcbiAqIENvcGllcyBzZXZlcmFsIFVpbnQ4QXJyYXlzIGludG8gb25lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0Qnl0ZXMoLi4uYXJyYXlzKSB7XG4gICAgY29uc3QgciA9IG5ldyBVaW50OEFycmF5KGFycmF5cy5yZWR1Y2UoKHN1bSwgYSkgPT4gc3VtICsgYS5sZW5ndGgsIDApKTtcbiAgICBsZXQgcGFkID0gMDsgLy8gd2FsayB0aHJvdWdoIGVhY2ggaXRlbSwgZW5zdXJlIHRoZXkgaGF2ZSBwcm9wZXIgdHlwZVxuICAgIGFycmF5cy5mb3JFYWNoKChhKSA9PiB7XG4gICAgICAgIGlmICghdThhKGEpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgICAgIHIuc2V0KGEsIHBhZCk7XG4gICAgICAgIHBhZCArPSBhLmxlbmd0aDtcbiAgICB9KTtcbiAgICByZXR1cm4gcjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbEJ5dGVzKGIxLCBiMikge1xuICAgIC8vIFdlIGRvbid0IGNhcmUgYWJvdXQgdGltaW5nIGF0dGFja3MgaGVyZVxuICAgIGlmIChiMS5sZW5ndGggIT09IGIyLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYjEubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmIChiMVtpXSAhPT0gYjJbaV0pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIEBleGFtcGxlIHV0ZjhUb0J5dGVzKCdhYmMnKSAvLyBuZXcgVWludDhBcnJheShbOTcsIDk4LCA5OV0pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdXRmOFRvQnl0ZXMgZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygc3RyfWApO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSk7IC8vIGh0dHBzOi8vYnVnemlsLmxhLzE2ODE4MDlcbn1cbi8vIEJpdCBvcGVyYXRpb25zXG4vKipcbiAqIENhbGN1bGF0ZXMgYW1vdW50IG9mIGJpdHMgaW4gYSBiaWdpbnQuXG4gKiBTYW1lIGFzIGBuLnRvU3RyaW5nKDIpLmxlbmd0aGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpdExlbihuKSB7XG4gICAgbGV0IGxlbjtcbiAgICBmb3IgKGxlbiA9IDA7IG4gPiBfMG47IG4gPj49IF8xbiwgbGVuICs9IDEpXG4gICAgICAgIDtcbiAgICByZXR1cm4gbGVuO1xufVxuLyoqXG4gKiBHZXRzIHNpbmdsZSBiaXQgYXQgcG9zaXRpb24uXG4gKiBOT1RFOiBmaXJzdCBiaXQgcG9zaXRpb24gaXMgMCAoc2FtZSBhcyBhcnJheXMpXG4gKiBTYW1lIGFzIGAhIStBcnJheS5mcm9tKG4udG9TdHJpbmcoMikpLnJldmVyc2UoKVtwb3NdYFxuICovXG5leHBvcnQgZnVuY3Rpb24gYml0R2V0KG4sIHBvcykge1xuICAgIHJldHVybiAobiA+PiBCaWdJbnQocG9zKSkgJiBfMW47XG59XG4vKipcbiAqIFNldHMgc2luZ2xlIGJpdCBhdCBwb3NpdGlvbi5cbiAqL1xuZXhwb3J0IGNvbnN0IGJpdFNldCA9IChuLCBwb3MsIHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIG4gfCAoKHZhbHVlID8gXzFuIDogXzBuKSA8PCBCaWdJbnQocG9zKSk7XG59O1xuLyoqXG4gKiBDYWxjdWxhdGUgbWFzayBmb3IgTiBiaXRzLiBOb3QgdXNpbmcgKiogb3BlcmF0b3Igd2l0aCBiaWdpbnRzIGJlY2F1c2Ugb2Ygb2xkIGVuZ2luZXMuXG4gKiBTYW1lIGFzIEJpZ0ludChgMGIke0FycmF5KGkpLmZpbGwoJzEnKS5qb2luKCcnKX1gKVxuICovXG5leHBvcnQgY29uc3QgYml0TWFzayA9IChuKSA9PiAoXzJuIDw8IEJpZ0ludChuIC0gMSkpIC0gXzFuO1xuLy8gRFJCR1xuY29uc3QgdThuID0gKGRhdGEpID0+IG5ldyBVaW50OEFycmF5KGRhdGEpOyAvLyBjcmVhdGVzIFVpbnQ4QXJyYXlcbmNvbnN0IHU4ZnIgPSAoYXJyKSA9PiBVaW50OEFycmF5LmZyb20oYXJyKTsgLy8gYW5vdGhlciBzaG9ydGN1dFxuLyoqXG4gKiBNaW5pbWFsIEhNQUMtRFJCRyBmcm9tIE5JU1QgODAwLTkwIGZvciBSRkM2OTc5IHNpZ3MuXG4gKiBAcmV0dXJucyBmdW5jdGlvbiB0aGF0IHdpbGwgY2FsbCBEUkJHIHVudGlsIDJuZCBhcmcgcmV0dXJucyBzb21ldGhpbmcgbWVhbmluZ2Z1bFxuICogQGV4YW1wbGVcbiAqICAgY29uc3QgZHJiZyA9IGNyZWF0ZUhtYWNEUkJHPEtleT4oMzIsIDMyLCBobWFjKTtcbiAqICAgZHJiZyhzZWVkLCBieXRlc1RvS2V5KTsgLy8gYnl0ZXNUb0tleSBtdXN0IHJldHVybiBLZXkgb3IgdW5kZWZpbmVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVIbWFjRHJiZyhoYXNoTGVuLCBxQnl0ZUxlbiwgaG1hY0ZuKSB7XG4gICAgaWYgKHR5cGVvZiBoYXNoTGVuICE9PSAnbnVtYmVyJyB8fCBoYXNoTGVuIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoYXNoTGVuIG11c3QgYmUgYSBudW1iZXInKTtcbiAgICBpZiAodHlwZW9mIHFCeXRlTGVuICE9PSAnbnVtYmVyJyB8fCBxQnl0ZUxlbiA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncUJ5dGVMZW4gbXVzdCBiZSBhIG51bWJlcicpO1xuICAgIGlmICh0eXBlb2YgaG1hY0ZuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2htYWNGbiBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAvLyBTdGVwIEIsIFN0ZXAgQzogc2V0IGhhc2hMZW4gdG8gOCpjZWlsKGhsZW4vOClcbiAgICBsZXQgdiA9IHU4bihoYXNoTGVuKTsgLy8gTWluaW1hbCBub24tZnVsbC1zcGVjIEhNQUMtRFJCRyBmcm9tIE5JU1QgODAwLTkwIGZvciBSRkM2OTc5IHNpZ3MuXG4gICAgbGV0IGsgPSB1OG4oaGFzaExlbik7IC8vIFN0ZXBzIEIgYW5kIEMgb2YgUkZDNjk3OSAzLjI6IHNldCBoYXNoTGVuLCBpbiBvdXIgY2FzZSBhbHdheXMgc2FtZVxuICAgIGxldCBpID0gMDsgLy8gSXRlcmF0aW9ucyBjb3VudGVyLCB3aWxsIHRocm93IHdoZW4gb3ZlciAxMDAwXG4gICAgY29uc3QgcmVzZXQgPSAoKSA9PiB7XG4gICAgICAgIHYuZmlsbCgxKTtcbiAgICAgICAgay5maWxsKDApO1xuICAgICAgICBpID0gMDtcbiAgICB9O1xuICAgIGNvbnN0IGggPSAoLi4uYikgPT4gaG1hY0ZuKGssIHYsIC4uLmIpOyAvLyBobWFjKGspKHYsIC4uLnZhbHVlcylcbiAgICBjb25zdCByZXNlZWQgPSAoc2VlZCA9IHU4bigpKSA9PiB7XG4gICAgICAgIC8vIEhNQUMtRFJCRyByZXNlZWQoKSBmdW5jdGlvbi4gU3RlcHMgRC1HXG4gICAgICAgIGsgPSBoKHU4ZnIoWzB4MDBdKSwgc2VlZCk7IC8vIGsgPSBobWFjKGsgfHwgdiB8fCAweDAwIHx8IHNlZWQpXG4gICAgICAgIHYgPSBoKCk7IC8vIHYgPSBobWFjKGsgfHwgdilcbiAgICAgICAgaWYgKHNlZWQubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBrID0gaCh1OGZyKFsweDAxXSksIHNlZWQpOyAvLyBrID0gaG1hYyhrIHx8IHYgfHwgMHgwMSB8fCBzZWVkKVxuICAgICAgICB2ID0gaCgpOyAvLyB2ID0gaG1hYyhrIHx8IHYpXG4gICAgfTtcbiAgICBjb25zdCBnZW4gPSAoKSA9PiB7XG4gICAgICAgIC8vIEhNQUMtRFJCRyBnZW5lcmF0ZSgpIGZ1bmN0aW9uXG4gICAgICAgIGlmIChpKysgPj0gMTAwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZHJiZzogdHJpZWQgMTAwMCB2YWx1ZXMnKTtcbiAgICAgICAgbGV0IGxlbiA9IDA7XG4gICAgICAgIGNvbnN0IG91dCA9IFtdO1xuICAgICAgICB3aGlsZSAobGVuIDwgcUJ5dGVMZW4pIHtcbiAgICAgICAgICAgIHYgPSBoKCk7XG4gICAgICAgICAgICBjb25zdCBzbCA9IHYuc2xpY2UoKTtcbiAgICAgICAgICAgIG91dC5wdXNoKHNsKTtcbiAgICAgICAgICAgIGxlbiArPSB2Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uY2F0Qnl0ZXMoLi4ub3V0KTtcbiAgICB9O1xuICAgIGNvbnN0IGdlblVudGlsID0gKHNlZWQsIHByZWQpID0+IHtcbiAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgcmVzZWVkKHNlZWQpOyAvLyBTdGVwcyBELUdcbiAgICAgICAgbGV0IHJlcyA9IHVuZGVmaW5lZDsgLy8gU3RlcCBIOiBncmluZCB1bnRpbCBrIGlzIGluIFsxLi5uLTFdXG4gICAgICAgIHdoaWxlICghKHJlcyA9IHByZWQoZ2VuKCkpKSlcbiAgICAgICAgICAgIHJlc2VlZCgpO1xuICAgICAgICByZXNldCgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgcmV0dXJuIGdlblVudGlsO1xufVxuLy8gVmFsaWRhdGluZyBjdXJ2ZXMgYW5kIGZpZWxkc1xuY29uc3QgdmFsaWRhdG9yRm5zID0ge1xuICAgIGJpZ2ludDogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2JpZ2ludCcsXG4gICAgZnVuY3Rpb246ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicsXG4gICAgYm9vbGVhbjogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nLFxuICAgIHN0cmluZzogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycsXG4gICAgc3RyaW5nT3JVaW50OEFycmF5OiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyB8fCB2YWwgaW5zdGFuY2VvZiBVaW50OEFycmF5LFxuICAgIGlzU2FmZUludGVnZXI6ICh2YWwpID0+IE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbCksXG4gICAgYXJyYXk6ICh2YWwpID0+IEFycmF5LmlzQXJyYXkodmFsKSxcbiAgICBmaWVsZDogKHZhbCwgb2JqZWN0KSA9PiBvYmplY3QuRnAuaXNWYWxpZCh2YWwpLFxuICAgIGhhc2g6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicgJiYgTnVtYmVyLmlzU2FmZUludGVnZXIodmFsLm91dHB1dExlbiksXG59O1xuLy8gdHlwZSBSZWNvcmQ8SyBleHRlbmRzIHN0cmluZyB8IG51bWJlciB8IHN5bWJvbCwgVD4gPSB7IFtQIGluIEtdOiBUOyB9XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVPYmplY3Qob2JqZWN0LCB2YWxpZGF0b3JzLCBvcHRWYWxpZGF0b3JzID0ge30pIHtcbiAgICBjb25zdCBjaGVja0ZpZWxkID0gKGZpZWxkTmFtZSwgdHlwZSwgaXNPcHRpb25hbCkgPT4ge1xuICAgICAgICBjb25zdCBjaGVja1ZhbCA9IHZhbGlkYXRvckZuc1t0eXBlXTtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGVja1ZhbCAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB2YWxpZGF0b3IgXCIke3R5cGV9XCIsIGV4cGVjdGVkIGZ1bmN0aW9uYCk7XG4gICAgICAgIGNvbnN0IHZhbCA9IG9iamVjdFtmaWVsZE5hbWVdO1xuICAgICAgICBpZiAoaXNPcHRpb25hbCAmJiB2YWwgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCFjaGVja1ZhbCh2YWwsIG9iamVjdCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwYXJhbSAke1N0cmluZyhmaWVsZE5hbWUpfT0ke3ZhbH0gKCR7dHlwZW9mIHZhbH0pLCBleHBlY3RlZCAke3R5cGV9YCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZvciAoY29uc3QgW2ZpZWxkTmFtZSwgdHlwZV0gb2YgT2JqZWN0LmVudHJpZXModmFsaWRhdG9ycykpXG4gICAgICAgIGNoZWNrRmllbGQoZmllbGROYW1lLCB0eXBlLCBmYWxzZSk7XG4gICAgZm9yIChjb25zdCBbZmllbGROYW1lLCB0eXBlXSBvZiBPYmplY3QuZW50cmllcyhvcHRWYWxpZGF0b3JzKSlcbiAgICAgICAgY2hlY2tGaWVsZChmaWVsZE5hbWUsIHR5cGUsIHRydWUpO1xuICAgIHJldHVybiBvYmplY3Q7XG59XG4vLyB2YWxpZGF0ZSB0eXBlIHRlc3RzXG4vLyBjb25zdCBvOiB7IGE6IG51bWJlcjsgYjogbnVtYmVyOyBjOiBudW1iZXIgfSA9IHsgYTogMSwgYjogNSwgYzogNiB9O1xuLy8gY29uc3QgejAgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICdpc1NhZmVJbnRlZ2VyJyB9LCB7IGM6ICdiaWdpbnQnIH0pOyAvLyBPayFcbi8vIC8vIFNob3VsZCBmYWlsIHR5cGUtY2hlY2tcbi8vIGNvbnN0IHoxID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAndG1wJyB9LCB7IGM6ICd6eicgfSk7XG4vLyBjb25zdCB6MiA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ2lzU2FmZUludGVnZXInIH0sIHsgYzogJ3p6JyB9KTtcbi8vIGNvbnN0IHozID0gdmFsaWRhdGVPYmplY3QobywgeyB0ZXN0OiAnYm9vbGVhbicsIHo6ICdidWcnIH0pO1xuLy8gY29uc3QgejQgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICdib29sZWFuJywgejogJ2J1ZycgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/weierstrass.js":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/weierstrass.js ***!
  \*************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DER: () => (/* binding */ DER),\n/* harmony export */   SWUFpSqrtRatio: () => (/* binding */ SWUFpSqrtRatio),\n/* harmony export */   mapToCurveSimpleSWU: () => (/* binding */ mapToCurveSimpleSWU),\n/* harmony export */   weierstrass: () => (/* binding */ weierstrass),\n/* harmony export */   weierstrassPoints: () => (/* binding */ weierstrassPoints)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _curve_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curve.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/curve.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Short Weierstrass curve. The formula is: y = x + ax + b\n\n\n\n\nfunction validatePointOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject(opts, {\n        a: 'field',\n        b: 'field',\n    }, {\n        allowedPrivateKeyLengths: 'array',\n        wrapPrivateKey: 'boolean',\n        isTorsionFree: 'function',\n        clearCofactor: 'function',\n        allowInfinityPoint: 'boolean',\n        fromBytes: 'function',\n        toBytes: 'function',\n    });\n    const { endo, Fp, a } = opts;\n    if (endo) {\n        if (!Fp.eql(a, Fp.ZERO)) {\n            throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');\n        }\n        if (typeof endo !== 'object' ||\n            typeof endo.beta !== 'bigint' ||\n            typeof endo.splitScalar !== 'function') {\n            throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');\n        }\n    }\n    return Object.freeze({ ...opts });\n}\n// ASN.1 DER encoding utilities\nconst { bytesToNumberBE: b2n, hexToBytes: h2b } = _utils_js__WEBPACK_IMPORTED_MODULE_1__;\nconst DER = {\n    // asn.1 DER encoding utils\n    Err: class DERErr extends Error {\n        constructor(m = '') {\n            super(m);\n        }\n    },\n    _parseInt(data) {\n        const { Err: E } = DER;\n        if (data.length < 2 || data[0] !== 0x02)\n            throw new E('Invalid signature integer tag');\n        const len = data[1];\n        const res = data.subarray(2, len + 2);\n        if (!len || res.length !== len)\n            throw new E('Invalid signature integer: wrong length');\n        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n        // since we always use positive integers here. It must always be empty:\n        // - add zero byte if exists\n        // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n        if (res[0] & 0b10000000)\n            throw new E('Invalid signature integer: negative');\n        if (res[0] === 0x00 && !(res[1] & 0b10000000))\n            throw new E('Invalid signature integer: unnecessary leading zero');\n        return { d: b2n(res), l: data.subarray(len + 2) }; // d is data, l is left\n    },\n    toSig(hex) {\n        // parse DER signature\n        const { Err: E } = DER;\n        const data = typeof hex === 'string' ? h2b(hex) : hex;\n        if (!(data instanceof Uint8Array))\n            throw new Error('ui8a expected');\n        let l = data.length;\n        if (l < 2 || data[0] != 0x30)\n            throw new E('Invalid signature tag');\n        if (data[1] !== l - 2)\n            throw new E('Invalid signature: incorrect length');\n        const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));\n        const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);\n        if (rBytesLeft.length)\n            throw new E('Invalid signature: left bytes after parsing');\n        return { r, s };\n    },\n    hexFromSig(sig) {\n        // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'\n        const slice = (s) => (Number.parseInt(s[0], 16) & 0b1000 ? '00' + s : s);\n        const h = (num) => {\n            const hex = num.toString(16);\n            return hex.length & 1 ? `0${hex}` : hex;\n        };\n        const s = slice(h(sig.s));\n        const r = slice(h(sig.r));\n        const shl = s.length / 2;\n        const rhl = r.length / 2;\n        const sl = h(shl);\n        const rl = h(rhl);\n        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;\n    },\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nfunction weierstrassPoints(opts) {\n    const CURVE = validatePointOpts(opts);\n    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n    const toBytes = CURVE.toBytes ||\n        ((_c, point, _isCompressed) => {\n            const a = point.toAffine();\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n        });\n    const fromBytes = CURVE.fromBytes ||\n        ((bytes) => {\n            // const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n            return { x, y };\n        });\n    /**\n     * y = x + ax + b: Short weierstrass curve formula\n     * @returns y\n     */\n    function weierstrassEquation(x) {\n        const { a, b } = CURVE;\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x2 * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n    }\n    // Validate whether the passed curve params are valid.\n    // We check if curve equation works for generator point.\n    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\n    // ProjectivePoint class has not been initialized yet.\n    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))\n        throw new Error('bad generator point: equation left != right');\n    // Valid group elements reside in range 1..n-1\n    function isWithinCurveOrder(num) {\n        return typeof num === 'bigint' && _0n < num && num < CURVE.n;\n    }\n    function assertGE(num) {\n        if (!isWithinCurveOrder(num))\n            throw new Error('Expected valid bigint: 0 < bigint < curve.n');\n    }\n    // Validates if priv key is valid and converts it to bigint.\n    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n    function normPrivateKeyToScalar(key) {\n        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;\n        if (lengths && typeof key !== 'bigint') {\n            if (key instanceof Uint8Array)\n                key = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(key);\n            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n            if (typeof key !== 'string' || !lengths.includes(key.length))\n                throw new Error('Invalid key');\n            key = key.padStart(nByteLength * 2, '0');\n        }\n        let num;\n        try {\n            num =\n                typeof key === 'bigint'\n                    ? key\n                    : _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('private key', key, nByteLength));\n        }\n        catch (error) {\n            throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);\n        }\n        if (wrapPrivateKey)\n            num = _modular_js__WEBPACK_IMPORTED_MODULE_2__.mod(num, n); // disabled by default, enabled for BLS\n        assertGE(num); // num in range [1..N-1]\n        return num;\n    }\n    const pointPrecomputes = new Map();\n    function assertPrjPoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('ProjectivePoint expected');\n    }\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z)  (x=x/z, y=y/z)\n     * Default Point works in 2d / affine coordinates: (x, y)\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */\n    class Point {\n        constructor(px, py, pz) {\n            this.px = px;\n            this.py = py;\n            this.pz = pz;\n            if (px == null || !Fp.isValid(px))\n                throw new Error('x required');\n            if (py == null || !Fp.isValid(py))\n                throw new Error('y required');\n            if (pz == null || !Fp.isValid(pz))\n                throw new Error('z required');\n        }\n        // Does not validate if the point is on-curve.\n        // Use fromHex instead, or call assertValidity() later.\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('invalid affine point');\n            if (p instanceof Point)\n                throw new Error('projective point not allowed');\n            const is0 = (i) => Fp.eql(i, Fp.ZERO);\n            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n            if (is0(x) && is0(y))\n                return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         * Takes a bunch of Projective Points but executes only one\n         * inversion on all of them. Inversion is very slow operation,\n         * so this improves performance massively.\n         * Optimization: converts a list of projective points to a list of identical points with Z=1.\n         */\n        static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p) => p.pz));\n            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        /**\n         * Converts hash string or Uint8Array to Point.\n         * @param hex short/long ECDSA hex\n         */\n        static fromHex(hex) {\n            const P = Point.fromAffine(fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('pointHex', hex)));\n            P.assertValidity();\n            return P;\n        }\n        // Multiplies generator point by privateKey.\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            this._WINDOW_SIZE = windowSize;\n            pointPrecomputes.delete(this);\n        }\n        // A point on curve is valid if it conforms to equation.\n        assertValidity() {\n            if (this.is0()) {\n                // (0, 1, 0) aka ZERO is invalid in most contexts.\n                // In BLS, ZERO can be serialized, so we allow it.\n                // (0, 0, 0) is wrong representation of ZERO and is always invalid.\n                if (CURVE.allowInfinityPoint && !Fp.is0(this.py))\n                    return;\n                throw new Error('bad point: ZERO');\n            }\n            // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n            const { x, y } = this.toAffine();\n            // Check if x, y are valid field elements\n            if (!Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('bad point: x or y not FE');\n            const left = Fp.sqr(y); // y\n            const right = weierstrassEquation(x); // x + ax + b\n            if (!Fp.eql(left, right))\n                throw new Error('bad point: equation left != right');\n            if (!this.isTorsionFree())\n                throw new Error('bad point: not in prime-order subgroup');\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (Fp.isOdd)\n                return !Fp.isOdd(y);\n            throw new Error(\"Field doesn't support isOdd\");\n        }\n        /**\n         * Compare one point to another.\n         */\n        equals(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /**\n         * Flips point to one corresponding to (x, -y) in Affine coordinates.\n         */\n        negate() {\n            return new Point(this.px, Fp.neg(this.py), this.pz);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {\n                const toInv = Fp.invertBatch(comp.map((p) => p.pz));\n                return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n            });\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed private key e.g. sig verification, which works over *public* keys.\n         */\n        multiplyUnsafe(n) {\n            const I = Point.ZERO;\n            if (n === _0n)\n                return I;\n            assertGE(n); // Will throw on 0\n            if (n === _1n)\n                return this;\n            const { endo } = CURVE;\n            if (!endo)\n                return wnaf.unsafeLadder(this, n);\n            // Apply endomorphism\n            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n            let k1p = I;\n            let k2p = I;\n            let d = this;\n            while (k1 > _0n || k2 > _0n) {\n                if (k1 & _1n)\n                    k1p = k1p.add(d);\n                if (k2 & _1n)\n                    k2p = k2p.add(d);\n                d = d.double();\n                k1 >>= _1n;\n                k2 >>= _1n;\n            }\n            if (k1neg)\n                k1p = k1p.negate();\n            if (k2neg)\n                k2p = k2p.negate();\n            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n            return k1p.add(k2p);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */\n        multiply(scalar) {\n            assertGE(scalar);\n            let n = scalar;\n            let point, fake; // Fake point is used to const-time mult\n            const { endo } = CURVE;\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n                let { p: k1p, f: f1p } = this.wNAF(k1);\n                let { p: k2p, f: f2p } = this.wNAF(k2);\n                k1p = wnaf.constTimeNegate(k1neg, k1p);\n                k2p = wnaf.constTimeNegate(k2neg, k2p);\n                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n                point = k1p.add(k2p);\n                fake = f1p.add(f2p);\n            }\n            else {\n                const { p, f } = this.wNAF(n);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return Point.normalizeZ([point, fake])[0];\n        }\n        /**\n         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n         * Not using Strauss-Shamir trick: precomputation tables are faster.\n         * The trick could be useful if both P and Q are not G (not in our case).\n         * @returns non-zero affine point\n         */\n        multiplyAndAddUnsafe(Q, a, b) {\n            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n            const mul = (P, a // Select faster multiply() method\n            ) => (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));\n            const sum = mul(this, a).add(mul(Q, b));\n            return sum.is0() ? undefined : sum;\n        }\n        // Converts Projective point to affine (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        // (x, y, z)  (x=x/z, y=y/z)\n        toAffine(iz) {\n            const { px: x, py: y, pz: z } = this;\n            const is0 = this.is0();\n            // If invZ was 0, we return zero point. However we still want to execute\n            // all operations, so we replace invZ with a random number, 1.\n            if (iz == null)\n                iz = is0 ? Fp.ONE : Fp.inv(z);\n            const ax = Fp.mul(x, iz);\n            const ay = Fp.mul(y, iz);\n            const zz = Fp.mul(z, iz);\n            if (is0)\n                return { x: Fp.ZERO, y: Fp.ZERO };\n            if (!Fp.eql(zz, Fp.ONE))\n                throw new Error('invZ was invalid');\n            return { x: ax, y: ay };\n        }\n        isTorsionFree() {\n            const { h: cofactor, isTorsionFree } = CURVE;\n            if (cofactor === _1n)\n                return true; // No subgroups, always torsion-free\n            if (isTorsionFree)\n                return isTorsionFree(Point, this);\n            throw new Error('isTorsionFree() has not been declared for the elliptic curve');\n        }\n        clearCofactor() {\n            const { h: cofactor, clearCofactor } = CURVE;\n            if (cofactor === _1n)\n                return this; // Fast-path\n            if (clearCofactor)\n                return clearCofactor(Point, this);\n            return this.multiplyUnsafe(CURVE.h);\n        }\n        toRawBytes(isCompressed = true) {\n            this.assertValidity();\n            return toBytes(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(this.toRawBytes(isCompressed));\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n    const _bits = CURVE.nBitLength;\n    const wnaf = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n    // Validate if generator point is on curve\n    return {\n        CURVE,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar,\n        weierstrassEquation,\n        isWithinCurveOrder,\n    };\n}\nfunction validateOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject(opts, {\n        hash: 'hash',\n        hmac: 'function',\n        randomBytes: 'function',\n    }, {\n        bits2int: 'function',\n        bits2int_modN: 'function',\n        lowS: 'boolean',\n    });\n    return Object.freeze({ lowS: true, ...opts });\n}\nfunction weierstrass(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER } = CURVE;\n    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n    function isValidFieldElement(num) {\n        return _0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE\n    }\n    function modN(a) {\n        return _modular_js__WEBPACK_IMPORTED_MODULE_2__.mod(a, CURVE_ORDER);\n    }\n    function invN(a) {\n        return _modular_js__WEBPACK_IMPORTED_MODULE_2__.invert(a, CURVE_ORDER);\n    }\n    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder, } = weierstrassPoints({\n        ...CURVE,\n        toBytes(_c, point, isCompressed) {\n            const a = point.toAffine();\n            const x = Fp.toBytes(a.x);\n            const cat = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes;\n            if (isCompressed) {\n                return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);\n            }\n            else {\n                return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));\n            }\n        },\n        fromBytes(bytes) {\n            const len = bytes.length;\n            const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // this.assertValidity() is done inside of fromHex\n            if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n                const x = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(tail);\n                if (!isValidFieldElement(x))\n                    throw new Error('Point is not on curve');\n                const y2 = weierstrassEquation(x); // y = x + ax + b\n                let y = Fp.sqrt(y2); // y = y ^ (p+1)/4\n                const isYOdd = (y & _1n) === _1n;\n                // ECDSA\n                const isHeadOdd = (head & 1) === 1;\n                if (isHeadOdd !== isYOdd)\n                    y = Fp.neg(y);\n                return { x, y };\n            }\n            else if (len === uncompressedLen && head === 0x04) {\n                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n                return { x, y };\n            }\n            else {\n                throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);\n            }\n        },\n    });\n    const numToNByteStr = (num) => _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(_utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE(num, CURVE.nByteLength));\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function normalizeS(s) {\n        return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n    }\n    // slice bytes num\n    const slcNum = (b, from, to) => _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(b.slice(from, to));\n    /**\n     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n     */\n    class Signature {\n        constructor(r, s, recovery) {\n            this.r = r;\n            this.s = s;\n            this.recovery = recovery;\n            this.assertValidity();\n        }\n        // pair (bytes of r, bytes of s)\n        static fromCompact(hex) {\n            const l = CURVE.nByteLength;\n            hex = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('compactSignature', hex, l * 2);\n            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n        }\n        // DER encoded ECDSA signature\n        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n        static fromDER(hex) {\n            const { r, s } = DER.toSig((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('DER', hex));\n            return new Signature(r, s);\n        }\n        assertValidity() {\n            // can use assertGE here\n            if (!isWithinCurveOrder(this.r))\n                throw new Error('r must be 0 < r < CURVE.n');\n            if (!isWithinCurveOrder(this.s))\n                throw new Error('s must be 0 < s < CURVE.n');\n        }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(msgHash) {\n            const { r, s, recovery: rec } = this;\n            const h = bits2int_modN((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('msgHash', msgHash)); // Truncate hash\n            if (rec == null || ![0, 1, 2, 3].includes(rec))\n                throw new Error('recovery id invalid');\n            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n            if (radj >= Fp.ORDER)\n                throw new Error('recovery id 2 or 3 invalid');\n            const prefix = (rec & 1) === 0 ? '02' : '03';\n            const R = Point.fromHex(prefix + numToNByteStr(radj));\n            const ir = invN(radj); // r^-1\n            const u1 = modN(-h * ir); // -hr^-1\n            const u2 = modN(s * ir); // sr^-1\n            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n            if (!Q)\n                throw new Error('point at infinify'); // unsafe is fine: no priv data leaked\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n        }\n        // DER-encoded\n        toDERRawBytes() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.hexToBytes(this.toDERHex());\n        }\n        toDERHex() {\n            return DER.hexFromSig({ r: this.r, s: this.s });\n        }\n        // padded bytes of r, then padded bytes of s\n        toCompactRawBytes() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.hexToBytes(this.toCompactHex());\n        }\n        toCompactHex() {\n            return numToNByteStr(this.r) + numToNByteStr(this.s);\n        }\n    }\n    const utils = {\n        isValidPrivateKey(privateKey) {\n            try {\n                normPrivateKeyToScalar(privateKey);\n                return true;\n            }\n            catch (error) {\n                return false;\n            }\n        },\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\n        /**\n         * Produces cryptographically secure private key from random of size\n         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n         */\n        randomPrivateKey: () => {\n            const length = _modular_js__WEBPACK_IMPORTED_MODULE_2__.getMinHashLength(CURVE.n);\n            return _modular_js__WEBPACK_IMPORTED_MODULE_2__.mapHashToField(CURVE.randomBytes(length), CURVE.n);\n        },\n        /**\n         * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n         * Allows to massively speed-up `point.multiply(scalar)`.\n         * @returns cached point\n         * @example\n         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n         * fast.multiply(privKey); // much faster ECDH now\n         */\n        precompute(windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n            return point;\n        },\n    };\n    /**\n     * Computes public key for a private key. Checks for validity of the private key.\n     * @param privateKey private key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */\n    function getPublicKey(privateKey, isCompressed = true) {\n        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */\n    function isProbPub(item) {\n        const arr = item instanceof Uint8Array;\n        const str = typeof item === 'string';\n        const len = (arr || str) && item.length;\n        if (arr)\n            return len === compressedLen || len === uncompressedLen;\n        if (str)\n            return len === 2 * compressedLen || len === 2 * uncompressedLen;\n        if (item instanceof Point)\n            return true;\n        return false;\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from private key and public key.\n     * Checks: 1) private key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param privateA private key\n     * @param publicB different public key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */\n    function getSharedSecret(privateA, publicB, isCompressed = true) {\n        if (isProbPub(privateA))\n            throw new Error('first arg must be private key');\n        if (!isProbPub(publicB))\n            throw new Error('second arg must be public key');\n        const b = Point.fromHex(publicB); // check for being on-curve\n        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = CURVE.bits2int ||\n        function (bytes) {\n            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n            // for some cases, since bytes.length * 8 is not actual bitLength.\n            const num = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(bytes); // check for == u8 done here\n            const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n            return delta > 0 ? num >> BigInt(delta) : num;\n        };\n    const bits2int_modN = CURVE.bits2int_modN ||\n        function (bytes) {\n            return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n        };\n    // NOTE: pads output with zero as per spec\n    const ORDER_MASK = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bitMask(CURVE.nBitLength);\n    /**\n     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n     */\n    function int2octets(num) {\n        if (typeof num !== 'bigint')\n            throw new Error('bigint expected');\n        if (!(_0n <= num && num < ORDER_MASK))\n            throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);\n        // works with order, can have different size than numToField!\n        return _utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE(num, CURVE.nByteLength);\n    }\n    // Steps A, D of RFC6979 3.2\n    // Creates RFC6979 seed; converts msg/privKey to numbers.\n    // Used only in sign, not in verify.\n    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.\n    // Also it can be bigger for P224 + SHA256\n    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n        if (['recovered', 'canonical'].some((k) => k in opts))\n            throw new Error('sign() legacy options not supported');\n        const { hash, randomBytes } = CURVE;\n        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n        if (lowS == null)\n            lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('msgHash', msgHash);\n        if (prehash)\n            msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('prehashed msgHash', hash(msgHash));\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(msgHash);\n        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n        const seedArgs = [int2octets(d), int2octets(h1int)];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (ent != null) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n            seedArgs.push((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('extraEntropy', e)); // check for being bytes\n        }\n        const seed = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n            if (!isWithinCurveOrder(k))\n                return; // Important: all mod() calls here must be done over N\n            const ik = invN(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n            const r = modN(q.x); // r = q.x mod n\n            if (r === _0n)\n                return;\n            // Can use scalar blinding b^-1(bm + bdr) where b  [1,q1] according to\n            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n            const s = modN(ik * modN(m + r * d)); // Not using blinding here\n            if (s === _0n)\n                return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = normalizeS(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return { seed, k2sig };\n    }\n    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };\n    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };\n    /**\n     * Signs message hash with a private key.\n     * ```\n     * sign(m, d, k) where\n     *   (x, y) = G  k\n     *   r = x mod n\n     *   s = (m + dr)/k mod n\n     * ```\n     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n     * @param privKey private key\n     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n     * @returns signature with recovery param\n     */\n    function sign(msgHash, privKey, opts = defaultSigOpts) {\n        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n        const C = CURVE;\n        const drbg = _utils_js__WEBPACK_IMPORTED_MODULE_1__.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);\n        return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    }\n    // Enable precomputes. Slows down first publicKey computation by 20ms.\n    Point.BASE._setWindowSize(8);\n    // utils.precompute(8, ProjectivePoint.BASE)\n    /**\n     * Verifies a signature against message hash and public key.\n     * Rejects lowS signatures by default: to override,\n     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   U1 = hs^-1 mod n\n     *   U2 = rs^-1 mod n\n     *   R = U1G - U2P\n     *   mod(R.x, n) == r\n     * ```\n     */\n    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n        const sg = signature;\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('msgHash', msgHash);\n        publicKey = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('publicKey', publicKey);\n        if ('strict' in opts)\n            throw new Error('options.strict was renamed to lowS');\n        const { lowS, prehash } = opts;\n        let _sig = undefined;\n        let P;\n        try {\n            if (typeof sg === 'string' || sg instanceof Uint8Array) {\n                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n                // Since DER can also be 2*nByteLength bytes, we check for it first.\n                try {\n                    _sig = Signature.fromDER(sg);\n                }\n                catch (derError) {\n                    if (!(derError instanceof DER.Err))\n                        throw derError;\n                    _sig = Signature.fromCompact(sg);\n                }\n            }\n            else if (typeof sg === 'object' && typeof sg.r === 'bigint' && typeof sg.s === 'bigint') {\n                const { r, s } = sg;\n                _sig = new Signature(r, s);\n            }\n            else {\n                throw new Error('PARSE');\n            }\n            P = Point.fromHex(publicKey);\n        }\n        catch (error) {\n            if (error.message === 'PARSE')\n                throw new Error(`signature must be Signature instance, Uint8Array or hex string`);\n            return false;\n        }\n        if (lowS && _sig.hasHighS())\n            return false;\n        if (prehash)\n            msgHash = CURVE.hash(msgHash);\n        const { r, s } = _sig;\n        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n        const is = invN(s); // s^-1\n        const u1 = modN(h * is); // u1 = hs^-1 mod n\n        const u2 = modN(r * is); // u2 = rs^-1 mod n\n        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1G + u2P\n        if (!R)\n            return false;\n        const v = modN(R.x);\n        return v === r;\n    }\n    return {\n        CURVE,\n        getPublicKey,\n        getSharedSecret,\n        sign,\n        verify,\n        ProjectivePoint: Point,\n        Signature,\n        utils,\n    };\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nfunction SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for (let o = q - _1n; o % _2n === _0n; o /= _2n)\n        l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v) => {\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for (let i = c1; i > _1n; i--) {\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return { isValid: isQR, value: tv3 };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v) => {\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */\nfunction mapToCurveSimpleSWU(Fp, opts) {\n    _modular_js__WEBPACK_IMPORTED_MODULE_2__.validateField(Fp);\n    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))\n        throw new Error('mapToCurveSimpleSWU: invalid opts');\n    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n    if (!Fp.isOdd)\n        throw new Error('Fp.isOdd is not implemented!');\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u) => {\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        x = Fp.div(x, tv4); // 25.   x = x / tv4\n        return { x, y };\n    };\n}\n//# sourceMappingURL=weierstrass.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ29DO0FBQ0g7QUFDUTtBQUNRO0FBQ2pEO0FBQ0EsaUJBQWlCLHdEQUFhO0FBQzlCLElBQUkscURBQWlCO0FBQ3JCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBLFFBQVEsd0NBQXdDLEVBQUUsc0NBQUU7QUFDN0M7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwwQ0FBMEM7QUFDM0QsS0FBSztBQUNMO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQyxnQkFBZ0Isc0JBQXNCO0FBQ3RDO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsSUFBSTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUIsSUFBSSxHQUFHLEVBQUUsRUFBRSxJQUFJLEdBQUcsRUFBRSxFQUFFO0FBQzNELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtB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OlsiL2hvbWUvbGZnL0dpdC9NYWR0cmlwcy9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gU2hvcnQgV2VpZXJzdHJhc3MgY3VydmUuIFRoZSBmb3JtdWxhIGlzOiB5wrIgPSB4wrMgKyBheCArIGJcbmltcG9ydCAqIGFzIG1vZCBmcm9tICcuL21vZHVsYXIuanMnO1xuaW1wb3J0ICogYXMgdXQgZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgeyBlbnN1cmVCeXRlcyB9IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgd05BRiwgdmFsaWRhdGVCYXNpYyB9IGZyb20gJy4vY3VydmUuanMnO1xuZnVuY3Rpb24gdmFsaWRhdGVQb2ludE9wdHMoY3VydmUpIHtcbiAgICBjb25zdCBvcHRzID0gdmFsaWRhdGVCYXNpYyhjdXJ2ZSk7XG4gICAgdXQudmFsaWRhdGVPYmplY3Qob3B0cywge1xuICAgICAgICBhOiAnZmllbGQnLFxuICAgICAgICBiOiAnZmllbGQnLFxuICAgIH0sIHtcbiAgICAgICAgYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzOiAnYXJyYXknLFxuICAgICAgICB3cmFwUHJpdmF0ZUtleTogJ2Jvb2xlYW4nLFxuICAgICAgICBpc1RvcnNpb25GcmVlOiAnZnVuY3Rpb24nLFxuICAgICAgICBjbGVhckNvZmFjdG9yOiAnZnVuY3Rpb24nLFxuICAgICAgICBhbGxvd0luZmluaXR5UG9pbnQ6ICdib29sZWFuJyxcbiAgICAgICAgZnJvbUJ5dGVzOiAnZnVuY3Rpb24nLFxuICAgICAgICB0b0J5dGVzOiAnZnVuY3Rpb24nLFxuICAgIH0pO1xuICAgIGNvbnN0IHsgZW5kbywgRnAsIGEgfSA9IG9wdHM7XG4gICAgaWYgKGVuZG8pIHtcbiAgICAgICAgaWYgKCFGcC5lcWwoYSwgRnAuWkVSTykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRW5kb21vcnBoaXNtIGNhbiBvbmx5IGJlIGRlZmluZWQgZm9yIEtvYmxpdHogY3VydmVzIHRoYXQgaGF2ZSBhPTAnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGVuZG8gIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgICB0eXBlb2YgZW5kby5iZXRhICE9PSAnYmlnaW50JyB8fFxuICAgICAgICAgICAgdHlwZW9mIGVuZG8uc3BsaXRTY2FsYXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgZW5kb21vcnBoaXNtIHdpdGggYmV0YTogYmlnaW50IGFuZCBzcGxpdFNjYWxhcjogZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IC4uLm9wdHMgfSk7XG59XG4vLyBBU04uMSBERVIgZW5jb2RpbmcgdXRpbGl0aWVzXG5jb25zdCB7IGJ5dGVzVG9OdW1iZXJCRTogYjJuLCBoZXhUb0J5dGVzOiBoMmIgfSA9IHV0O1xuZXhwb3J0IGNvbnN0IERFUiA9IHtcbiAgICAvLyBhc24uMSBERVIgZW5jb2RpbmcgdXRpbHNcbiAgICBFcnI6IGNsYXNzIERFUkVyciBleHRlbmRzIEVycm9yIHtcbiAgICAgICAgY29uc3RydWN0b3IobSA9ICcnKSB7XG4gICAgICAgICAgICBzdXBlcihtKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgX3BhcnNlSW50KGRhdGEpIHtcbiAgICAgICAgY29uc3QgeyBFcnI6IEUgfSA9IERFUjtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoIDwgMiB8fCBkYXRhWzBdICE9PSAweDAyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlIGludGVnZXIgdGFnJyk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGFbMV07XG4gICAgICAgIGNvbnN0IHJlcyA9IGRhdGEuc3ViYXJyYXkoMiwgbGVuICsgMik7XG4gICAgICAgIGlmICghbGVuIHx8IHJlcy5sZW5ndGggIT09IGxlbilcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiB3cm9uZyBsZW5ndGgnKTtcbiAgICAgICAgLy8gaHR0cHM6Ly9jcnlwdG8uc3RhY2tleGNoYW5nZS5jb20vYS81NzczNCBMZWZ0bW9zdCBiaXQgb2YgZmlyc3QgYnl0ZSBpcyAnbmVnYXRpdmUnIGZsYWcsXG4gICAgICAgIC8vIHNpbmNlIHdlIGFsd2F5cyB1c2UgcG9zaXRpdmUgaW50ZWdlcnMgaGVyZS4gSXQgbXVzdCBhbHdheXMgYmUgZW1wdHk6XG4gICAgICAgIC8vIC0gYWRkIHplcm8gYnl0ZSBpZiBleGlzdHNcbiAgICAgICAgLy8gLSBpZiBuZXh0IGJ5dGUgZG9lc24ndCBoYXZlIGEgZmxhZywgbGVhZGluZyB6ZXJvIGlzIG5vdCBhbGxvd2VkIChtaW5pbWFsIGVuY29kaW5nKVxuICAgICAgICBpZiAocmVzWzBdICYgMGIxMDAwMDAwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiBuZWdhdGl2ZScpO1xuICAgICAgICBpZiAocmVzWzBdID09PSAweDAwICYmICEocmVzWzFdICYgMGIxMDAwMDAwMCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmUgaW50ZWdlcjogdW5uZWNlc3NhcnkgbGVhZGluZyB6ZXJvJyk7XG4gICAgICAgIHJldHVybiB7IGQ6IGIybihyZXMpLCBsOiBkYXRhLnN1YmFycmF5KGxlbiArIDIpIH07IC8vIGQgaXMgZGF0YSwgbCBpcyBsZWZ0XG4gICAgfSxcbiAgICB0b1NpZyhoZXgpIHtcbiAgICAgICAgLy8gcGFyc2UgREVSIHNpZ25hdHVyZVxuICAgICAgICBjb25zdCB7IEVycjogRSB9ID0gREVSO1xuICAgICAgICBjb25zdCBkYXRhID0gdHlwZW9mIGhleCA9PT0gJ3N0cmluZycgPyBoMmIoaGV4KSA6IGhleDtcbiAgICAgICAgaWYgKCEoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1aThhIGV4cGVjdGVkJyk7XG4gICAgICAgIGxldCBsID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGlmIChsIDwgMiB8fCBkYXRhWzBdICE9IDB4MzApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmUgdGFnJyk7XG4gICAgICAgIGlmIChkYXRhWzFdICE9PSBsIC0gMilcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZTogaW5jb3JyZWN0IGxlbmd0aCcpO1xuICAgICAgICBjb25zdCB7IGQ6IHIsIGw6IHNCeXRlcyB9ID0gREVSLl9wYXJzZUludChkYXRhLnN1YmFycmF5KDIpKTtcbiAgICAgICAgY29uc3QgeyBkOiBzLCBsOiByQnl0ZXNMZWZ0IH0gPSBERVIuX3BhcnNlSW50KHNCeXRlcyk7XG4gICAgICAgIGlmIChyQnl0ZXNMZWZ0Lmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZTogbGVmdCBieXRlcyBhZnRlciBwYXJzaW5nJyk7XG4gICAgICAgIHJldHVybiB7IHIsIHMgfTtcbiAgICB9LFxuICAgIGhleEZyb21TaWcoc2lnKSB7XG4gICAgICAgIC8vIEFkZCBsZWFkaW5nIHplcm8gaWYgZmlyc3QgYnl0ZSBoYXMgbmVnYXRpdmUgYml0IGVuYWJsZWQuIE1vcmUgZGV0YWlscyBpbiAnX3BhcnNlSW50J1xuICAgICAgICBjb25zdCBzbGljZSA9IChzKSA9PiAoTnVtYmVyLnBhcnNlSW50KHNbMF0sIDE2KSAmIDBiMTAwMCA/ICcwMCcgKyBzIDogcyk7XG4gICAgICAgIGNvbnN0IGggPSAobnVtKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBoZXggPSBudW0udG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgcmV0dXJuIGhleC5sZW5ndGggJiAxID8gYDAke2hleH1gIDogaGV4O1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzID0gc2xpY2UoaChzaWcucykpO1xuICAgICAgICBjb25zdCByID0gc2xpY2UoaChzaWcucikpO1xuICAgICAgICBjb25zdCBzaGwgPSBzLmxlbmd0aCAvIDI7XG4gICAgICAgIGNvbnN0IHJobCA9IHIubGVuZ3RoIC8gMjtcbiAgICAgICAgY29uc3Qgc2wgPSBoKHNobCk7XG4gICAgICAgIGNvbnN0IHJsID0gaChyaGwpO1xuICAgICAgICByZXR1cm4gYDMwJHtoKHJobCArIHNobCArIDQpfTAyJHtybH0ke3J9MDIke3NsfSR7c31gO1xuICAgIH0sXG59O1xuLy8gQmUgZnJpZW5kbHkgdG8gYmFkIEVDTUFTY3JpcHQgcGFyc2VycyBieSBub3QgdXNpbmcgYmlnaW50IGxpdGVyYWxzXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKSwgXzFuID0gQmlnSW50KDEpLCBfMm4gPSBCaWdJbnQoMiksIF8zbiA9IEJpZ0ludCgzKSwgXzRuID0gQmlnSW50KDQpO1xuZXhwb3J0IGZ1bmN0aW9uIHdlaWVyc3RyYXNzUG9pbnRzKG9wdHMpIHtcbiAgICBjb25zdCBDVVJWRSA9IHZhbGlkYXRlUG9pbnRPcHRzKG9wdHMpO1xuICAgIGNvbnN0IHsgRnAgfSA9IENVUlZFOyAvLyBBbGwgY3VydmVzIGhhcyBzYW1lIGZpZWxkIC8gZ3JvdXAgbGVuZ3RoIGFzIGZvciBub3csIGJ1dCB0aGV5IGNhbiBkaWZmZXJcbiAgICBjb25zdCB0b0J5dGVzID0gQ1VSVkUudG9CeXRlcyB8fFxuICAgICAgICAoKF9jLCBwb2ludCwgX2lzQ29tcHJlc3NlZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYSA9IHBvaW50LnRvQWZmaW5lKCk7XG4gICAgICAgICAgICByZXR1cm4gdXQuY29uY2F0Qnl0ZXMoVWludDhBcnJheS5mcm9tKFsweDA0XSksIEZwLnRvQnl0ZXMoYS54KSwgRnAudG9CeXRlcyhhLnkpKTtcbiAgICAgICAgfSk7XG4gICAgY29uc3QgZnJvbUJ5dGVzID0gQ1VSVkUuZnJvbUJ5dGVzIHx8XG4gICAgICAgICgoYnl0ZXMpID0+IHtcbiAgICAgICAgICAgIC8vIGNvbnN0IGhlYWQgPSBieXRlc1swXTtcbiAgICAgICAgICAgIGNvbnN0IHRhaWwgPSBieXRlcy5zdWJhcnJheSgxKTtcbiAgICAgICAgICAgIC8vIGlmIChoZWFkICE9PSAweDA0KSB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgbm9uLWNvbXByZXNzZWQgZW5jb2RpbmcgaXMgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICBjb25zdCB4ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoMCwgRnAuQllURVMpKTtcbiAgICAgICAgICAgIGNvbnN0IHkgPSBGcC5mcm9tQnl0ZXModGFpbC5zdWJhcnJheShGcC5CWVRFUywgMiAqIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgIH0pO1xuICAgIC8qKlxuICAgICAqIHnCsiA9IHjCsyArIGF4ICsgYjogU2hvcnQgd2VpZXJzdHJhc3MgY3VydmUgZm9ybXVsYVxuICAgICAqIEByZXR1cm5zIHnCslxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdlaWVyc3RyYXNzRXF1YXRpb24oeCkge1xuICAgICAgICBjb25zdCB7IGEsIGIgfSA9IENVUlZFO1xuICAgICAgICBjb25zdCB4MiA9IEZwLnNxcih4KTsgLy8geCAqIHhcbiAgICAgICAgY29uc3QgeDMgPSBGcC5tdWwoeDIsIHgpOyAvLyB4MiAqIHhcbiAgICAgICAgcmV0dXJuIEZwLmFkZChGcC5hZGQoeDMsIEZwLm11bCh4LCBhKSksIGIpOyAvLyB4MyArIGEgKiB4ICsgYlxuICAgIH1cbiAgICAvLyBWYWxpZGF0ZSB3aGV0aGVyIHRoZSBwYXNzZWQgY3VydmUgcGFyYW1zIGFyZSB2YWxpZC5cbiAgICAvLyBXZSBjaGVjayBpZiBjdXJ2ZSBlcXVhdGlvbiB3b3JrcyBmb3IgZ2VuZXJhdG9yIHBvaW50LlxuICAgIC8vIGBhc3NlcnRWYWxpZGl0eSgpYCB3b24ndCB3b3JrOiBgaXNUb3JzaW9uRnJlZSgpYCBpcyBub3QgYXZhaWxhYmxlIGF0IHRoaXMgcG9pbnQgaW4gYmxzMTItMzgxLlxuICAgIC8vIFByb2plY3RpdmVQb2ludCBjbGFzcyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0LlxuICAgIGlmICghRnAuZXFsKEZwLnNxcihDVVJWRS5HeSksIHdlaWVyc3RyYXNzRXF1YXRpb24oQ1VSVkUuR3gpKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgZ2VuZXJhdG9yIHBvaW50OiBlcXVhdGlvbiBsZWZ0ICE9IHJpZ2h0Jyk7XG4gICAgLy8gVmFsaWQgZ3JvdXAgZWxlbWVudHMgcmVzaWRlIGluIHJhbmdlIDEuLm4tMVxuICAgIGZ1bmN0aW9uIGlzV2l0aGluQ3VydmVPcmRlcihudW0pIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBudW0gPT09ICdiaWdpbnQnICYmIF8wbiA8IG51bSAmJiBudW0gPCBDVVJWRS5uO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhc3NlcnRHRShudW0pIHtcbiAgICAgICAgaWYgKCFpc1dpdGhpbkN1cnZlT3JkZXIobnVtKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdmFsaWQgYmlnaW50OiAwIDwgYmlnaW50IDwgY3VydmUubicpO1xuICAgIH1cbiAgICAvLyBWYWxpZGF0ZXMgaWYgcHJpdiBrZXkgaXMgdmFsaWQgYW5kIGNvbnZlcnRzIGl0IHRvIGJpZ2ludC5cbiAgICAvLyBTdXBwb3J0cyBvcHRpb25zIGFsbG93ZWRQcml2YXRlS2V5TGVuZ3RocyBhbmQgd3JhcFByaXZhdGVLZXkuXG4gICAgZnVuY3Rpb24gbm9ybVByaXZhdGVLZXlUb1NjYWxhcihrZXkpIHtcbiAgICAgICAgY29uc3QgeyBhbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHM6IGxlbmd0aHMsIG5CeXRlTGVuZ3RoLCB3cmFwUHJpdmF0ZUtleSwgbiB9ID0gQ1VSVkU7XG4gICAgICAgIGlmIChsZW5ndGhzICYmIHR5cGVvZiBrZXkgIT09ICdiaWdpbnQnKSB7XG4gICAgICAgICAgICBpZiAoa2V5IGluc3RhbmNlb2YgVWludDhBcnJheSlcbiAgICAgICAgICAgICAgICBrZXkgPSB1dC5ieXRlc1RvSGV4KGtleSk7XG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgdG8gaGV4IHN0cmluZywgcGFkLiBFLmcuIFA1MjEgd291bGQgbm9ybSAxMzAtMTMyIGNoYXIgaGV4IHRvIDEzMi1jaGFyIGJ5dGVzXG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycgfHwgIWxlbmd0aHMuaW5jbHVkZXMoa2V5Lmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGtleScpO1xuICAgICAgICAgICAga2V5ID0ga2V5LnBhZFN0YXJ0KG5CeXRlTGVuZ3RoICogMiwgJzAnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbnVtO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbnVtID1cbiAgICAgICAgICAgICAgICB0eXBlb2Yga2V5ID09PSAnYmlnaW50J1xuICAgICAgICAgICAgICAgICAgICA/IGtleVxuICAgICAgICAgICAgICAgICAgICA6IHV0LmJ5dGVzVG9OdW1iZXJCRShlbnN1cmVCeXRlcygncHJpdmF0ZSBrZXknLCBrZXksIG5CeXRlTGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHByaXZhdGUga2V5IG11c3QgYmUgJHtuQnl0ZUxlbmd0aH0gYnl0ZXMsIGhleCBvciBiaWdpbnQsIG5vdCAke3R5cGVvZiBrZXl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdyYXBQcml2YXRlS2V5KVxuICAgICAgICAgICAgbnVtID0gbW9kLm1vZChudW0sIG4pOyAvLyBkaXNhYmxlZCBieSBkZWZhdWx0LCBlbmFibGVkIGZvciBCTFNcbiAgICAgICAgYXNzZXJ0R0UobnVtKTsgLy8gbnVtIGluIHJhbmdlIFsxLi5OLTFdXG4gICAgICAgIHJldHVybiBudW07XG4gICAgfVxuICAgIGNvbnN0IHBvaW50UHJlY29tcHV0ZXMgPSBuZXcgTWFwKCk7XG4gICAgZnVuY3Rpb24gYXNzZXJ0UHJqUG9pbnQob3RoZXIpIHtcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBQb2ludCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb2plY3RpdmVQb2ludCBleHBlY3RlZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9qZWN0aXZlIFBvaW50IHdvcmtzIGluIDNkIC8gcHJvamVjdGl2ZSAoaG9tb2dlbmVvdXMpIGNvb3JkaW5hdGVzOiAoeCwgeSwgeikg4oiLICh4PXgveiwgeT15L3opXG4gICAgICogRGVmYXVsdCBQb2ludCB3b3JrcyBpbiAyZCAvIGFmZmluZSBjb29yZGluYXRlczogKHgsIHkpXG4gICAgICogV2UncmUgZG9pbmcgY2FsY3VsYXRpb25zIGluIHByb2plY3RpdmUsIGJlY2F1c2UgaXRzIG9wZXJhdGlvbnMgZG9uJ3QgcmVxdWlyZSBjb3N0bHkgaW52ZXJzaW9uLlxuICAgICAqL1xuICAgIGNsYXNzIFBvaW50IHtcbiAgICAgICAgY29uc3RydWN0b3IocHgsIHB5LCBweikge1xuICAgICAgICAgICAgdGhpcy5weCA9IHB4O1xuICAgICAgICAgICAgdGhpcy5weSA9IHB5O1xuICAgICAgICAgICAgdGhpcy5weiA9IHB6O1xuICAgICAgICAgICAgaWYgKHB4ID09IG51bGwgfHwgIUZwLmlzVmFsaWQocHgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneCByZXF1aXJlZCcpO1xuICAgICAgICAgICAgaWYgKHB5ID09IG51bGwgfHwgIUZwLmlzVmFsaWQocHkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneSByZXF1aXJlZCcpO1xuICAgICAgICAgICAgaWYgKHB6ID09IG51bGwgfHwgIUZwLmlzVmFsaWQocHopKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneiByZXF1aXJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvZXMgbm90IHZhbGlkYXRlIGlmIHRoZSBwb2ludCBpcyBvbi1jdXJ2ZS5cbiAgICAgICAgLy8gVXNlIGZyb21IZXggaW5zdGVhZCwgb3IgY2FsbCBhc3NlcnRWYWxpZGl0eSgpIGxhdGVyLlxuICAgICAgICBzdGF0aWMgZnJvbUFmZmluZShwKSB7XG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHAgfHwge307XG4gICAgICAgICAgICBpZiAoIXAgfHwgIUZwLmlzVmFsaWQoeCkgfHwgIUZwLmlzVmFsaWQoeSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFmZmluZSBwb2ludCcpO1xuICAgICAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBQb2ludClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2plY3RpdmUgcG9pbnQgbm90IGFsbG93ZWQnKTtcbiAgICAgICAgICAgIGNvbnN0IGlzMCA9IChpKSA9PiBGcC5lcWwoaSwgRnAuWkVSTyk7XG4gICAgICAgICAgICAvLyBmcm9tQWZmaW5lKHg6MCwgeTowKSB3b3VsZCBwcm9kdWNlICh4OjAsIHk6MCwgejoxKSwgYnV0IHdlIG5lZWQgKHg6MCwgeToxLCB6OjApXG4gICAgICAgICAgICBpZiAoaXMwKHgpICYmIGlzMCh5KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gUG9pbnQuWkVSTztcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoeCwgeSwgRnAuT05FKTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgeCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgeSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGFrZXMgYSBidW5jaCBvZiBQcm9qZWN0aXZlIFBvaW50cyBidXQgZXhlY3V0ZXMgb25seSBvbmVcbiAgICAgICAgICogaW52ZXJzaW9uIG9uIGFsbCBvZiB0aGVtLiBJbnZlcnNpb24gaXMgdmVyeSBzbG93IG9wZXJhdGlvbixcbiAgICAgICAgICogc28gdGhpcyBpbXByb3ZlcyBwZXJmb3JtYW5jZSBtYXNzaXZlbHkuXG4gICAgICAgICAqIE9wdGltaXphdGlvbjogY29udmVydHMgYSBsaXN0IG9mIHByb2plY3RpdmUgcG9pbnRzIHRvIGEgbGlzdCBvZiBpZGVudGljYWwgcG9pbnRzIHdpdGggWj0xLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIG5vcm1hbGl6ZVoocG9pbnRzKSB7XG4gICAgICAgICAgICBjb25zdCB0b0ludiA9IEZwLmludmVydEJhdGNoKHBvaW50cy5tYXAoKHApID0+IHAucHopKTtcbiAgICAgICAgICAgIHJldHVybiBwb2ludHMubWFwKChwLCBpKSA9PiBwLnRvQWZmaW5lKHRvSW52W2ldKSkubWFwKFBvaW50LmZyb21BZmZpbmUpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyBoYXNoIHN0cmluZyBvciBVaW50OEFycmF5IHRvIFBvaW50LlxuICAgICAgICAgKiBAcGFyYW0gaGV4IHNob3J0L2xvbmcgRUNEU0EgaGV4XG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZnJvbUhleChoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IFAgPSBQb2ludC5mcm9tQWZmaW5lKGZyb21CeXRlcyhlbnN1cmVCeXRlcygncG9pbnRIZXgnLCBoZXgpKSk7XG4gICAgICAgICAgICBQLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUDtcbiAgICAgICAgfVxuICAgICAgICAvLyBNdWx0aXBsaWVzIGdlbmVyYXRvciBwb2ludCBieSBwcml2YXRlS2V5LlxuICAgICAgICBzdGF0aWMgZnJvbVByaXZhdGVLZXkocHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgcmV0dXJuIFBvaW50LkJBU0UubXVsdGlwbHkobm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlS2V5KSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gXCJQcml2YXRlIG1ldGhvZFwiLCBkb24ndCB1c2UgaXQgZGlyZWN0bHlcbiAgICAgICAgX3NldFdpbmRvd1NpemUod2luZG93U2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5fV0lORE9XX1NJWkUgPSB3aW5kb3dTaXplO1xuICAgICAgICAgICAgcG9pbnRQcmVjb21wdXRlcy5kZWxldGUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQSBwb2ludCBvbiBjdXJ2ZSBpcyB2YWxpZCBpZiBpdCBjb25mb3JtcyB0byBlcXVhdGlvbi5cbiAgICAgICAgYXNzZXJ0VmFsaWRpdHkoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pczAoKSkge1xuICAgICAgICAgICAgICAgIC8vICgwLCAxLCAwKSBha2EgWkVSTyBpcyBpbnZhbGlkIGluIG1vc3QgY29udGV4dHMuXG4gICAgICAgICAgICAgICAgLy8gSW4gQkxTLCBaRVJPIGNhbiBiZSBzZXJpYWxpemVkLCBzbyB3ZSBhbGxvdyBpdC5cbiAgICAgICAgICAgICAgICAvLyAoMCwgMCwgMCkgaXMgd3JvbmcgcmVwcmVzZW50YXRpb24gb2YgWkVSTyBhbmQgaXMgYWx3YXlzIGludmFsaWQuXG4gICAgICAgICAgICAgICAgaWYgKENVUlZFLmFsbG93SW5maW5pdHlQb2ludCAmJiAhRnAuaXMwKHRoaXMucHkpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IFpFUk8nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNvbWUgM3JkLXBhcnR5IHRlc3QgdmVjdG9ycyByZXF1aXJlIGRpZmZlcmVudCB3b3JkaW5nIGJldHdlZW4gaGVyZSAmIGBmcm9tQ29tcHJlc3NlZEhleGBcbiAgICAgICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gdGhpcy50b0FmZmluZSgpO1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgeCwgeSBhcmUgdmFsaWQgZmllbGQgZWxlbWVudHNcbiAgICAgICAgICAgIGlmICghRnAuaXNWYWxpZCh4KSB8fCAhRnAuaXNWYWxpZCh5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogeCBvciB5IG5vdCBGRScpO1xuICAgICAgICAgICAgY29uc3QgbGVmdCA9IEZwLnNxcih5KTsgLy8gecKyXG4gICAgICAgICAgICBjb25zdCByaWdodCA9IHdlaWVyc3RyYXNzRXF1YXRpb24oeCk7IC8vIHjCsyArIGF4ICsgYlxuICAgICAgICAgICAgaWYgKCFGcC5lcWwobGVmdCwgcmlnaHQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBlcXVhdGlvbiBsZWZ0ICE9IHJpZ2h0Jyk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNUb3JzaW9uRnJlZSgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBub3QgaW4gcHJpbWUtb3JkZXIgc3ViZ3JvdXAnKTtcbiAgICAgICAgfVxuICAgICAgICBoYXNFdmVuWSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgeSB9ID0gdGhpcy50b0FmZmluZSgpO1xuICAgICAgICAgICAgaWYgKEZwLmlzT2RkKVxuICAgICAgICAgICAgICAgIHJldHVybiAhRnAuaXNPZGQoeSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaWVsZCBkb2Vzbid0IHN1cHBvcnQgaXNPZGRcIik7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbXBhcmUgb25lIHBvaW50IHRvIGFub3RoZXIuXG4gICAgICAgICAqL1xuICAgICAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgICAgIGFzc2VydFByalBvaW50KG90aGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgyLCBweTogWTIsIHB6OiBaMiB9ID0gb3RoZXI7XG4gICAgICAgICAgICBjb25zdCBVMSA9IEZwLmVxbChGcC5tdWwoWDEsIFoyKSwgRnAubXVsKFgyLCBaMSkpO1xuICAgICAgICAgICAgY29uc3QgVTIgPSBGcC5lcWwoRnAubXVsKFkxLCBaMiksIEZwLm11bChZMiwgWjEpKTtcbiAgICAgICAgICAgIHJldHVybiBVMSAmJiBVMjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRmxpcHMgcG9pbnQgdG8gb25lIGNvcnJlc3BvbmRpbmcgdG8gKHgsIC15KSBpbiBBZmZpbmUgY29vcmRpbmF0ZXMuXG4gICAgICAgICAqL1xuICAgICAgICBuZWdhdGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMucHgsIEZwLm5lZyh0aGlzLnB5KSwgdGhpcy5weik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVuZXMtQ29zdGVsbG8tQmF0aW5hIGV4Y2VwdGlvbi1mcmVlIGRvdWJsaW5nIGZvcm11bGEuXG4gICAgICAgIC8vIFRoZXJlIGlzIDMwJSBmYXN0ZXIgSmFjb2JpYW4gZm9ybXVsYSwgYnV0IGl0IGlzIG5vdCBjb21wbGV0ZS5cbiAgICAgICAgLy8gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxNS8xMDYwLCBhbGdvcml0aG0gM1xuICAgICAgICAvLyBDb3N0OiA4TSArIDNTICsgMyphICsgMipiMyArIDE1YWRkLlxuICAgICAgICBkb3VibGUoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGEsIGIgfSA9IENVUlZFO1xuICAgICAgICAgICAgY29uc3QgYjMgPSBGcC5tdWwoYiwgXzNuKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGxldCBYMyA9IEZwLlpFUk8sIFkzID0gRnAuWkVSTywgWjMgPSBGcC5aRVJPOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGxldCB0MCA9IEZwLm11bChYMSwgWDEpOyAvLyBzdGVwIDFcbiAgICAgICAgICAgIGxldCB0MSA9IEZwLm11bChZMSwgWTEpO1xuICAgICAgICAgICAgbGV0IHQyID0gRnAubXVsKFoxLCBaMSk7XG4gICAgICAgICAgICBsZXQgdDMgPSBGcC5tdWwoWDEsIFkxKTtcbiAgICAgICAgICAgIHQzID0gRnAuYWRkKHQzLCB0Myk7IC8vIHN0ZXAgNVxuICAgICAgICAgICAgWjMgPSBGcC5tdWwoWDEsIFoxKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCBaMyk7XG4gICAgICAgICAgICBYMyA9IEZwLm11bChhLCBaMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChiMywgdDIpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWDMsIFkzKTsgLy8gc3RlcCAxMFxuICAgICAgICAgICAgWDMgPSBGcC5zdWIodDEsIFkzKTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKHQxLCBZMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChYMywgWTMpO1xuICAgICAgICAgICAgWDMgPSBGcC5tdWwodDMsIFgzKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKGIzLCBaMyk7IC8vIHN0ZXAgMTVcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQzID0gRnAuc3ViKHQwLCB0Mik7XG4gICAgICAgICAgICB0MyA9IEZwLm11bChhLCB0Myk7XG4gICAgICAgICAgICB0MyA9IEZwLmFkZCh0MywgWjMpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQodDAsIHQwKTsgLy8gc3RlcCAyMFxuICAgICAgICAgICAgdDAgPSBGcC5hZGQoWjMsIHQwKTtcbiAgICAgICAgICAgIHQwID0gRnAuYWRkKHQwLCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MCwgdDMpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWTMsIHQwKTtcbiAgICAgICAgICAgIHQyID0gRnAubXVsKFkxLCBaMSk7IC8vIHN0ZXAgMjVcbiAgICAgICAgICAgIHQyID0gRnAuYWRkKHQyLCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MiwgdDMpO1xuICAgICAgICAgICAgWDMgPSBGcC5zdWIoWDMsIHQwKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKHQyLCB0MSk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpOyAvLyBzdGVwIDMwXG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChYMywgWTMsIFozKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW5lcy1Db3N0ZWxsby1CYXRpbmEgZXhjZXB0aW9uLWZyZWUgYWRkaXRpb24gZm9ybXVsYS5cbiAgICAgICAgLy8gVGhlcmUgaXMgMzAlIGZhc3RlciBKYWNvYmlhbiBmb3JtdWxhLCBidXQgaXQgaXMgbm90IGNvbXBsZXRlLlxuICAgICAgICAvLyBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDE1LzEwNjAsIGFsZ29yaXRobSAxXG4gICAgICAgIC8vIENvc3Q6IDEyTSArIDBTICsgMyphICsgMypiMyArIDIzYWRkLlxuICAgICAgICBhZGQob3RoZXIpIHtcbiAgICAgICAgICAgIGFzc2VydFByalBvaW50KG90aGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgyLCBweTogWTIsIHB6OiBaMiB9ID0gb3RoZXI7XG4gICAgICAgICAgICBsZXQgWDMgPSBGcC5aRVJPLCBZMyA9IEZwLlpFUk8sIFozID0gRnAuWkVSTzsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBjb25zdCBhID0gQ1VSVkUuYTtcbiAgICAgICAgICAgIGNvbnN0IGIzID0gRnAubXVsKENVUlZFLmIsIF8zbik7XG4gICAgICAgICAgICBsZXQgdDAgPSBGcC5tdWwoWDEsIFgyKTsgLy8gc3RlcCAxXG4gICAgICAgICAgICBsZXQgdDEgPSBGcC5tdWwoWTEsIFkyKTtcbiAgICAgICAgICAgIGxldCB0MiA9IEZwLm11bChaMSwgWjIpO1xuICAgICAgICAgICAgbGV0IHQzID0gRnAuYWRkKFgxLCBZMSk7XG4gICAgICAgICAgICBsZXQgdDQgPSBGcC5hZGQoWDIsIFkyKTsgLy8gc3RlcCA1XG4gICAgICAgICAgICB0MyA9IEZwLm11bCh0MywgdDQpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQodDAsIHQxKTtcbiAgICAgICAgICAgIHQzID0gRnAuc3ViKHQzLCB0NCk7XG4gICAgICAgICAgICB0NCA9IEZwLmFkZChYMSwgWjEpO1xuICAgICAgICAgICAgbGV0IHQ1ID0gRnAuYWRkKFgyLCBaMik7IC8vIHN0ZXAgMTBcbiAgICAgICAgICAgIHQ0ID0gRnAubXVsKHQ0LCB0NSk7XG4gICAgICAgICAgICB0NSA9IEZwLmFkZCh0MCwgdDIpO1xuICAgICAgICAgICAgdDQgPSBGcC5zdWIodDQsIHQ1KTtcbiAgICAgICAgICAgIHQ1ID0gRnAuYWRkKFkxLCBaMSk7XG4gICAgICAgICAgICBYMyA9IEZwLmFkZChZMiwgWjIpOyAvLyBzdGVwIDE1XG4gICAgICAgICAgICB0NSA9IEZwLm11bCh0NSwgWDMpO1xuICAgICAgICAgICAgWDMgPSBGcC5hZGQodDEsIHQyKTtcbiAgICAgICAgICAgIHQ1ID0gRnAuc3ViKHQ1LCBYMyk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bChhLCB0NCk7XG4gICAgICAgICAgICBYMyA9IEZwLm11bChiMywgdDIpOyAvLyBzdGVwIDIwXG4gICAgICAgICAgICBaMyA9IEZwLmFkZChYMywgWjMpO1xuICAgICAgICAgICAgWDMgPSBGcC5zdWIodDEsIFozKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKHQxLCBaMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChYMywgWjMpO1xuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDAsIHQwKTsgLy8gc3RlcCAyNVxuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDEsIHQwKTtcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQ0ID0gRnAubXVsKGIzLCB0NCk7XG4gICAgICAgICAgICB0MSA9IEZwLmFkZCh0MSwgdDIpO1xuICAgICAgICAgICAgdDIgPSBGcC5zdWIodDAsIHQyKTsgLy8gc3RlcCAzMFxuICAgICAgICAgICAgdDIgPSBGcC5tdWwoYSwgdDIpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQodDQsIHQyKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQxLCB0NCk7XG4gICAgICAgICAgICBZMyA9IEZwLmFkZChZMywgdDApO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDUsIHQ0KTsgLy8gc3RlcCAzNVxuICAgICAgICAgICAgWDMgPSBGcC5tdWwodDMsIFgzKTtcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKFgzLCB0MCk7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MywgdDEpO1xuICAgICAgICAgICAgWjMgPSBGcC5tdWwodDUsIFozKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCB0MCk7IC8vIHN0ZXAgNDBcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoWDMsIFkzLCBaMyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VidHJhY3Qob3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChvdGhlci5uZWdhdGUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaXMwKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXF1YWxzKFBvaW50LlpFUk8pO1xuICAgICAgICB9XG4gICAgICAgIHdOQUYobikge1xuICAgICAgICAgICAgcmV0dXJuIHduYWYud05BRkNhY2hlZCh0aGlzLCBwb2ludFByZWNvbXB1dGVzLCBuLCAoY29tcCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvSW52ID0gRnAuaW52ZXJ0QmF0Y2goY29tcC5tYXAoKHApID0+IHAucHopKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcC5tYXAoKHAsIGkpID0+IHAudG9BZmZpbmUodG9JbnZbaV0pKS5tYXAoUG9pbnQuZnJvbUFmZmluZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogTm9uLWNvbnN0YW50LXRpbWUgbXVsdGlwbGljYXRpb24uIFVzZXMgZG91YmxlLWFuZC1hZGQgYWxnb3JpdGhtLlxuICAgICAgICAgKiBJdCdzIGZhc3RlciwgYnV0IHNob3VsZCBvbmx5IGJlIHVzZWQgd2hlbiB5b3UgZG9uJ3QgY2FyZSBhYm91dFxuICAgICAgICAgKiBhbiBleHBvc2VkIHByaXZhdGUga2V5IGUuZy4gc2lnIHZlcmlmaWNhdGlvbiwgd2hpY2ggd29ya3Mgb3ZlciAqcHVibGljKiBrZXlzLlxuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGlwbHlVbnNhZmUobikge1xuICAgICAgICAgICAgY29uc3QgSSA9IFBvaW50LlpFUk87XG4gICAgICAgICAgICBpZiAobiA9PT0gXzBuKVxuICAgICAgICAgICAgICAgIHJldHVybiBJO1xuICAgICAgICAgICAgYXNzZXJ0R0Uobik7IC8vIFdpbGwgdGhyb3cgb24gMFxuICAgICAgICAgICAgaWYgKG4gPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgZW5kbyB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoIWVuZG8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHduYWYudW5zYWZlTGFkZGVyKHRoaXMsIG4pO1xuICAgICAgICAgICAgLy8gQXBwbHkgZW5kb21vcnBoaXNtXG4gICAgICAgICAgICBsZXQgeyBrMW5lZywgazEsIGsybmVnLCBrMiB9ID0gZW5kby5zcGxpdFNjYWxhcihuKTtcbiAgICAgICAgICAgIGxldCBrMXAgPSBJO1xuICAgICAgICAgICAgbGV0IGsycCA9IEk7XG4gICAgICAgICAgICBsZXQgZCA9IHRoaXM7XG4gICAgICAgICAgICB3aGlsZSAoazEgPiBfMG4gfHwgazIgPiBfMG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoazEgJiBfMW4pXG4gICAgICAgICAgICAgICAgICAgIGsxcCA9IGsxcC5hZGQoZCk7XG4gICAgICAgICAgICAgICAgaWYgKGsyICYgXzFuKVxuICAgICAgICAgICAgICAgICAgICBrMnAgPSBrMnAuYWRkKGQpO1xuICAgICAgICAgICAgICAgIGQgPSBkLmRvdWJsZSgpO1xuICAgICAgICAgICAgICAgIGsxID4+PSBfMW47XG4gICAgICAgICAgICAgICAgazIgPj49IF8xbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrMW5lZylcbiAgICAgICAgICAgICAgICBrMXAgPSBrMXAubmVnYXRlKCk7XG4gICAgICAgICAgICBpZiAoazJuZWcpXG4gICAgICAgICAgICAgICAgazJwID0gazJwLm5lZ2F0ZSgpO1xuICAgICAgICAgICAgazJwID0gbmV3IFBvaW50KEZwLm11bChrMnAucHgsIGVuZG8uYmV0YSksIGsycC5weSwgazJwLnB6KTtcbiAgICAgICAgICAgIHJldHVybiBrMXAuYWRkKGsycCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0YW50IHRpbWUgbXVsdGlwbGljYXRpb24uXG4gICAgICAgICAqIFVzZXMgd05BRiBtZXRob2QuIFdpbmRvd2VkIG1ldGhvZCBtYXkgYmUgMTAlIGZhc3RlcixcbiAgICAgICAgICogYnV0IHRha2VzIDJ4IGxvbmdlciB0byBnZW5lcmF0ZSBhbmQgY29uc3VtZXMgMnggbWVtb3J5LlxuICAgICAgICAgKiBVc2VzIHByZWNvbXB1dGVzIHdoZW4gYXZhaWxhYmxlLlxuICAgICAgICAgKiBVc2VzIGVuZG9tb3JwaGlzbSBmb3IgS29ibGl0eiBjdXJ2ZXMuXG4gICAgICAgICAqIEBwYXJhbSBzY2FsYXIgYnkgd2hpY2ggdGhlIHBvaW50IHdvdWxkIGJlIG11bHRpcGxpZWRcbiAgICAgICAgICogQHJldHVybnMgTmV3IHBvaW50XG4gICAgICAgICAqL1xuICAgICAgICBtdWx0aXBseShzY2FsYXIpIHtcbiAgICAgICAgICAgIGFzc2VydEdFKHNjYWxhcik7XG4gICAgICAgICAgICBsZXQgbiA9IHNjYWxhcjtcbiAgICAgICAgICAgIGxldCBwb2ludCwgZmFrZTsgLy8gRmFrZSBwb2ludCBpcyB1c2VkIHRvIGNvbnN0LXRpbWUgbXVsdFxuICAgICAgICAgICAgY29uc3QgeyBlbmRvIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGlmIChlbmRvKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBrMW5lZywgazEsIGsybmVnLCBrMiB9ID0gZW5kby5zcGxpdFNjYWxhcihuKTtcbiAgICAgICAgICAgICAgICBsZXQgeyBwOiBrMXAsIGY6IGYxcCB9ID0gdGhpcy53TkFGKGsxKTtcbiAgICAgICAgICAgICAgICBsZXQgeyBwOiBrMnAsIGY6IGYycCB9ID0gdGhpcy53TkFGKGsyKTtcbiAgICAgICAgICAgICAgICBrMXAgPSB3bmFmLmNvbnN0VGltZU5lZ2F0ZShrMW5lZywgazFwKTtcbiAgICAgICAgICAgICAgICBrMnAgPSB3bmFmLmNvbnN0VGltZU5lZ2F0ZShrMm5lZywgazJwKTtcbiAgICAgICAgICAgICAgICBrMnAgPSBuZXcgUG9pbnQoRnAubXVsKGsycC5weCwgZW5kby5iZXRhKSwgazJwLnB5LCBrMnAucHopO1xuICAgICAgICAgICAgICAgIHBvaW50ID0gazFwLmFkZChrMnApO1xuICAgICAgICAgICAgICAgIGZha2UgPSBmMXAuYWRkKGYycCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHAsIGYgfSA9IHRoaXMud05BRihuKTtcbiAgICAgICAgICAgICAgICBwb2ludCA9IHA7XG4gICAgICAgICAgICAgICAgZmFrZSA9IGY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgYHpgIGZvciBib3RoIHBvaW50cywgYnV0IHJldHVybiBvbmx5IHJlYWwgb25lXG4gICAgICAgICAgICByZXR1cm4gUG9pbnQubm9ybWFsaXplWihbcG9pbnQsIGZha2VdKVswXTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRWZmaWNpZW50bHkgY2FsY3VsYXRlIGBhUCArIGJRYC4gVW5zYWZlLCBjYW4gZXhwb3NlIHByaXZhdGUga2V5LCBpZiB1c2VkIGluY29ycmVjdGx5LlxuICAgICAgICAgKiBOb3QgdXNpbmcgU3RyYXVzcy1TaGFtaXIgdHJpY2s6IHByZWNvbXB1dGF0aW9uIHRhYmxlcyBhcmUgZmFzdGVyLlxuICAgICAgICAgKiBUaGUgdHJpY2sgY291bGQgYmUgdXNlZnVsIGlmIGJvdGggUCBhbmQgUSBhcmUgbm90IEcgKG5vdCBpbiBvdXIgY2FzZSkuXG4gICAgICAgICAqIEByZXR1cm5zIG5vbi16ZXJvIGFmZmluZSBwb2ludFxuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGlwbHlBbmRBZGRVbnNhZmUoUSwgYSwgYikge1xuICAgICAgICAgICAgY29uc3QgRyA9IFBvaW50LkJBU0U7IC8vIE5vIFN0cmF1c3MtU2hhbWlyIHRyaWNrOiB3ZSBoYXZlIDEwJSBmYXN0ZXIgRyBwcmVjb21wdXRlc1xuICAgICAgICAgICAgY29uc3QgbXVsID0gKFAsIGEgLy8gU2VsZWN0IGZhc3RlciBtdWx0aXBseSgpIG1ldGhvZFxuICAgICAgICAgICAgKSA9PiAoYSA9PT0gXzBuIHx8IGEgPT09IF8xbiB8fCAhUC5lcXVhbHMoRykgPyBQLm11bHRpcGx5VW5zYWZlKGEpIDogUC5tdWx0aXBseShhKSk7XG4gICAgICAgICAgICBjb25zdCBzdW0gPSBtdWwodGhpcywgYSkuYWRkKG11bChRLCBiKSk7XG4gICAgICAgICAgICByZXR1cm4gc3VtLmlzMCgpID8gdW5kZWZpbmVkIDogc3VtO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbnZlcnRzIFByb2plY3RpdmUgcG9pbnQgdG8gYWZmaW5lICh4LCB5KSBjb29yZGluYXRlcy5cbiAgICAgICAgLy8gQ2FuIGFjY2VwdCBwcmVjb21wdXRlZCBaXi0xIC0gZm9yIGV4YW1wbGUsIGZyb20gaW52ZXJ0QmF0Y2guXG4gICAgICAgIC8vICh4LCB5LCB6KSDiiIsgKHg9eC96LCB5PXkveilcbiAgICAgICAgdG9BZmZpbmUoaXopIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IHgsIHB5OiB5LCBwejogeiB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IGlzMCA9IHRoaXMuaXMwKCk7XG4gICAgICAgICAgICAvLyBJZiBpbnZaIHdhcyAwLCB3ZSByZXR1cm4gemVybyBwb2ludC4gSG93ZXZlciB3ZSBzdGlsbCB3YW50IHRvIGV4ZWN1dGVcbiAgICAgICAgICAgIC8vIGFsbCBvcGVyYXRpb25zLCBzbyB3ZSByZXBsYWNlIGludlogd2l0aCBhIHJhbmRvbSBudW1iZXIsIDEuXG4gICAgICAgICAgICBpZiAoaXogPT0gbnVsbClcbiAgICAgICAgICAgICAgICBpeiA9IGlzMCA/IEZwLk9ORSA6IEZwLmludih6KTtcbiAgICAgICAgICAgIGNvbnN0IGF4ID0gRnAubXVsKHgsIGl6KTtcbiAgICAgICAgICAgIGNvbnN0IGF5ID0gRnAubXVsKHksIGl6KTtcbiAgICAgICAgICAgIGNvbnN0IHp6ID0gRnAubXVsKHosIGl6KTtcbiAgICAgICAgICAgIGlmIChpczApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgeDogRnAuWkVSTywgeTogRnAuWkVSTyB9O1xuICAgICAgICAgICAgaWYgKCFGcC5lcWwoenosIEZwLk9ORSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZaIHdhcyBpbnZhbGlkJyk7XG4gICAgICAgICAgICByZXR1cm4geyB4OiBheCwgeTogYXkgfTtcbiAgICAgICAgfVxuICAgICAgICBpc1RvcnNpb25GcmVlKCkge1xuICAgICAgICAgICAgY29uc3QgeyBoOiBjb2ZhY3RvciwgaXNUb3JzaW9uRnJlZSB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoY29mYWN0b3IgPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gTm8gc3ViZ3JvdXBzLCBhbHdheXMgdG9yc2lvbi1mcmVlXG4gICAgICAgICAgICBpZiAoaXNUb3JzaW9uRnJlZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNUb3JzaW9uRnJlZShQb2ludCwgdGhpcyk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lzVG9yc2lvbkZyZWUoKSBoYXMgbm90IGJlZW4gZGVjbGFyZWQgZm9yIHRoZSBlbGxpcHRpYyBjdXJ2ZScpO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFyQ29mYWN0b3IoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGg6IGNvZmFjdG9yLCBjbGVhckNvZmFjdG9yIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGlmIChjb2ZhY3RvciA9PT0gXzFuKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzOyAvLyBGYXN0LXBhdGhcbiAgICAgICAgICAgIGlmIChjbGVhckNvZmFjdG9yKVxuICAgICAgICAgICAgICAgIHJldHVybiBjbGVhckNvZmFjdG9yKFBvaW50LCB0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5VW5zYWZlKENVUlZFLmgpO1xuICAgICAgICB9XG4gICAgICAgIHRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRvQnl0ZXMoUG9pbnQsIHRoaXMsIGlzQ29tcHJlc3NlZCk7XG4gICAgICAgIH1cbiAgICAgICAgdG9IZXgoaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHV0LmJ5dGVzVG9IZXgodGhpcy50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFBvaW50LkJBU0UgPSBuZXcgUG9pbnQoQ1VSVkUuR3gsIENVUlZFLkd5LCBGcC5PTkUpO1xuICAgIFBvaW50LlpFUk8gPSBuZXcgUG9pbnQoRnAuWkVSTywgRnAuT05FLCBGcC5aRVJPKTtcbiAgICBjb25zdCBfYml0cyA9IENVUlZFLm5CaXRMZW5ndGg7XG4gICAgY29uc3Qgd25hZiA9IHdOQUYoUG9pbnQsIENVUlZFLmVuZG8gPyBNYXRoLmNlaWwoX2JpdHMgLyAyKSA6IF9iaXRzKTtcbiAgICAvLyBWYWxpZGF0ZSBpZiBnZW5lcmF0b3IgcG9pbnQgaXMgb24gY3VydmVcbiAgICByZXR1cm4ge1xuICAgICAgICBDVVJWRSxcbiAgICAgICAgUHJvamVjdGl2ZVBvaW50OiBQb2ludCxcbiAgICAgICAgbm9ybVByaXZhdGVLZXlUb1NjYWxhcixcbiAgICAgICAgd2VpZXJzdHJhc3NFcXVhdGlvbixcbiAgICAgICAgaXNXaXRoaW5DdXJ2ZU9yZGVyLFxuICAgIH07XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU9wdHMoY3VydmUpIHtcbiAgICBjb25zdCBvcHRzID0gdmFsaWRhdGVCYXNpYyhjdXJ2ZSk7XG4gICAgdXQudmFsaWRhdGVPYmplY3Qob3B0cywge1xuICAgICAgICBoYXNoOiAnaGFzaCcsXG4gICAgICAgIGhtYWM6ICdmdW5jdGlvbicsXG4gICAgICAgIHJhbmRvbUJ5dGVzOiAnZnVuY3Rpb24nLFxuICAgIH0sIHtcbiAgICAgICAgYml0czJpbnQ6ICdmdW5jdGlvbicsXG4gICAgICAgIGJpdHMyaW50X21vZE46ICdmdW5jdGlvbicsXG4gICAgICAgIGxvd1M6ICdib29sZWFuJyxcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IGxvd1M6IHRydWUsIC4uLm9wdHMgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gd2VpZXJzdHJhc3MoY3VydmVEZWYpIHtcbiAgICBjb25zdCBDVVJWRSA9IHZhbGlkYXRlT3B0cyhjdXJ2ZURlZik7XG4gICAgY29uc3QgeyBGcCwgbjogQ1VSVkVfT1JERVIgfSA9IENVUlZFO1xuICAgIGNvbnN0IGNvbXByZXNzZWRMZW4gPSBGcC5CWVRFUyArIDE7IC8vIGUuZy4gMzMgZm9yIDMyXG4gICAgY29uc3QgdW5jb21wcmVzc2VkTGVuID0gMiAqIEZwLkJZVEVTICsgMTsgLy8gZS5nLiA2NSBmb3IgMzJcbiAgICBmdW5jdGlvbiBpc1ZhbGlkRmllbGRFbGVtZW50KG51bSkge1xuICAgICAgICByZXR1cm4gXzBuIDwgbnVtICYmIG51bSA8IEZwLk9SREVSOyAvLyAwIGlzIGJhbm5lZCBzaW5jZSBpdCdzIG5vdCBpbnZlcnRpYmxlIEZFXG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vZE4oYSkge1xuICAgICAgICByZXR1cm4gbW9kLm1vZChhLCBDVVJWRV9PUkRFUik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludk4oYSkge1xuICAgICAgICByZXR1cm4gbW9kLmludmVydChhLCBDVVJWRV9PUkRFUik7XG4gICAgfVxuICAgIGNvbnN0IHsgUHJvamVjdGl2ZVBvaW50OiBQb2ludCwgbm9ybVByaXZhdGVLZXlUb1NjYWxhciwgd2VpZXJzdHJhc3NFcXVhdGlvbiwgaXNXaXRoaW5DdXJ2ZU9yZGVyLCB9ID0gd2VpZXJzdHJhc3NQb2ludHMoe1xuICAgICAgICAuLi5DVVJWRSxcbiAgICAgICAgdG9CeXRlcyhfYywgcG9pbnQsIGlzQ29tcHJlc3NlZCkge1xuICAgICAgICAgICAgY29uc3QgYSA9IHBvaW50LnRvQWZmaW5lKCk7XG4gICAgICAgICAgICBjb25zdCB4ID0gRnAudG9CeXRlcyhhLngpO1xuICAgICAgICAgICAgY29uc3QgY2F0ID0gdXQuY29uY2F0Qnl0ZXM7XG4gICAgICAgICAgICBpZiAoaXNDb21wcmVzc2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhdChVaW50OEFycmF5LmZyb20oW3BvaW50Lmhhc0V2ZW5ZKCkgPyAweDAyIDogMHgwM10pLCB4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYXQoVWludDhBcnJheS5mcm9tKFsweDA0XSksIHgsIEZwLnRvQnl0ZXMoYS55KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZyb21CeXRlcyhieXRlcykge1xuICAgICAgICAgICAgY29uc3QgbGVuID0gYnl0ZXMubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgaGVhZCA9IGJ5dGVzWzBdO1xuICAgICAgICAgICAgY29uc3QgdGFpbCA9IGJ5dGVzLnN1YmFycmF5KDEpO1xuICAgICAgICAgICAgLy8gdGhpcy5hc3NlcnRWYWxpZGl0eSgpIGlzIGRvbmUgaW5zaWRlIG9mIGZyb21IZXhcbiAgICAgICAgICAgIGlmIChsZW4gPT09IGNvbXByZXNzZWRMZW4gJiYgKGhlYWQgPT09IDB4MDIgfHwgaGVhZCA9PT0gMHgwMykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gdXQuYnl0ZXNUb051bWJlckJFKHRhaWwpO1xuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZEZpZWxkRWxlbWVudCh4KSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb2ludCBpcyBub3Qgb24gY3VydmUnKTtcbiAgICAgICAgICAgICAgICBjb25zdCB5MiA9IHdlaWVyc3RyYXNzRXF1YXRpb24oeCk7IC8vIHnCsiA9IHjCsyArIGF4ICsgYlxuICAgICAgICAgICAgICAgIGxldCB5ID0gRnAuc3FydCh5Mik7IC8vIHkgPSB5wrIgXiAocCsxKS80XG4gICAgICAgICAgICAgICAgY29uc3QgaXNZT2RkID0gKHkgJiBfMW4pID09PSBfMW47XG4gICAgICAgICAgICAgICAgLy8gRUNEU0FcbiAgICAgICAgICAgICAgICBjb25zdCBpc0hlYWRPZGQgPSAoaGVhZCAmIDEpID09PSAxO1xuICAgICAgICAgICAgICAgIGlmIChpc0hlYWRPZGQgIT09IGlzWU9kZClcbiAgICAgICAgICAgICAgICAgICAgeSA9IEZwLm5lZyh5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsZW4gPT09IHVuY29tcHJlc3NlZExlbiAmJiBoZWFkID09PSAweDA0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KDAsIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KEZwLkJZVEVTLCAyICogRnAuQllURVMpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvaW50IG9mIGxlbmd0aCAke2xlbn0gd2FzIGludmFsaWQuIEV4cGVjdGVkICR7Y29tcHJlc3NlZExlbn0gY29tcHJlc3NlZCBieXRlcyBvciAke3VuY29tcHJlc3NlZExlbn0gdW5jb21wcmVzc2VkIGJ5dGVzYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgY29uc3QgbnVtVG9OQnl0ZVN0ciA9IChudW0pID0+IHV0LmJ5dGVzVG9IZXgodXQubnVtYmVyVG9CeXRlc0JFKG51bSwgQ1VSVkUubkJ5dGVMZW5ndGgpKTtcbiAgICBmdW5jdGlvbiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIobnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IEhBTEYgPSBDVVJWRV9PUkRFUiA+PiBfMW47XG4gICAgICAgIHJldHVybiBudW1iZXIgPiBIQUxGO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub3JtYWxpemVTKHMpIHtcbiAgICAgICAgcmV0dXJuIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihzKSA/IG1vZE4oLXMpIDogcztcbiAgICB9XG4gICAgLy8gc2xpY2UgYnl0ZXMgbnVtXG4gICAgY29uc3Qgc2xjTnVtID0gKGIsIGZyb20sIHRvKSA9PiB1dC5ieXRlc1RvTnVtYmVyQkUoYi5zbGljZShmcm9tLCB0bykpO1xuICAgIC8qKlxuICAgICAqIEVDRFNBIHNpZ25hdHVyZSB3aXRoIGl0cyAociwgcykgcHJvcGVydGllcy4gU3VwcG9ydHMgREVSICYgY29tcGFjdCByZXByZXNlbnRhdGlvbnMuXG4gICAgICovXG4gICAgY2xhc3MgU2lnbmF0dXJlIHtcbiAgICAgICAgY29uc3RydWN0b3IociwgcywgcmVjb3ZlcnkpIHtcbiAgICAgICAgICAgIHRoaXMuciA9IHI7XG4gICAgICAgICAgICB0aGlzLnMgPSBzO1xuICAgICAgICAgICAgdGhpcy5yZWNvdmVyeSA9IHJlY292ZXJ5O1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhaXIgKGJ5dGVzIG9mIHIsIGJ5dGVzIG9mIHMpXG4gICAgICAgIHN0YXRpYyBmcm9tQ29tcGFjdChoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IGwgPSBDVVJWRS5uQnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIGhleCA9IGVuc3VyZUJ5dGVzKCdjb21wYWN0U2lnbmF0dXJlJywgaGV4LCBsICogMik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShzbGNOdW0oaGV4LCAwLCBsKSwgc2xjTnVtKGhleCwgbCwgMiAqIGwpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBERVIgZW5jb2RlZCBFQ0RTQSBzaWduYXR1cmVcbiAgICAgICAgLy8gaHR0cHM6Ly9iaXRjb2luLnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy81NzY0NC93aGF0LWFyZS10aGUtcGFydHMtb2YtYS1iaXRjb2luLXRyYW5zYWN0aW9uLWlucHV0LXNjcmlwdFxuICAgICAgICBzdGF0aWMgZnJvbURFUihoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgciwgcyB9ID0gREVSLnRvU2lnKGVuc3VyZUJ5dGVzKCdERVInLCBoZXgpKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHIsIHMpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydFZhbGlkaXR5KCkge1xuICAgICAgICAgICAgLy8gY2FuIHVzZSBhc3NlcnRHRSBoZXJlXG4gICAgICAgICAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcih0aGlzLnIpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignciBtdXN0IGJlIDAgPCByIDwgQ1VSVkUubicpO1xuICAgICAgICAgICAgaWYgKCFpc1dpdGhpbkN1cnZlT3JkZXIodGhpcy5zKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3MgbXVzdCBiZSAwIDwgcyA8IENVUlZFLm4nKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRSZWNvdmVyeUJpdChyZWNvdmVyeSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUodGhpcy5yLCB0aGlzLnMsIHJlY292ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICByZWNvdmVyUHVibGljS2V5KG1zZ0hhc2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgciwgcywgcmVjb3Zlcnk6IHJlYyB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IGggPSBiaXRzMmludF9tb2ROKGVuc3VyZUJ5dGVzKCdtc2dIYXNoJywgbXNnSGFzaCkpOyAvLyBUcnVuY2F0ZSBoYXNoXG4gICAgICAgICAgICBpZiAocmVjID09IG51bGwgfHwgIVswLCAxLCAyLCAzXS5pbmNsdWRlcyhyZWMpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVjb3ZlcnkgaWQgaW52YWxpZCcpO1xuICAgICAgICAgICAgY29uc3QgcmFkaiA9IHJlYyA9PT0gMiB8fCByZWMgPT09IDMgPyByICsgQ1VSVkUubiA6IHI7XG4gICAgICAgICAgICBpZiAocmFkaiA+PSBGcC5PUkRFUilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlY292ZXJ5IGlkIDIgb3IgMyBpbnZhbGlkJyk7XG4gICAgICAgICAgICBjb25zdCBwcmVmaXggPSAocmVjICYgMSkgPT09IDAgPyAnMDInIDogJzAzJztcbiAgICAgICAgICAgIGNvbnN0IFIgPSBQb2ludC5mcm9tSGV4KHByZWZpeCArIG51bVRvTkJ5dGVTdHIocmFkaikpO1xuICAgICAgICAgICAgY29uc3QgaXIgPSBpbnZOKHJhZGopOyAvLyByXi0xXG4gICAgICAgICAgICBjb25zdCB1MSA9IG1vZE4oLWggKiBpcik7IC8vIC1ocl4tMVxuICAgICAgICAgICAgY29uc3QgdTIgPSBtb2ROKHMgKiBpcik7IC8vIHNyXi0xXG4gICAgICAgICAgICBjb25zdCBRID0gUG9pbnQuQkFTRS5tdWx0aXBseUFuZEFkZFVuc2FmZShSLCB1MSwgdTIpOyAvLyAoc3JeLTEpUi0oaHJeLTEpRyA9IC0oaHJeLTEpRyArIChzcl4tMSlcbiAgICAgICAgICAgIGlmICghUSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BvaW50IGF0IGluZmluaWZ5Jyk7IC8vIHVuc2FmZSBpcyBmaW5lOiBubyBwcml2IGRhdGEgbGVha2VkXG4gICAgICAgICAgICBRLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaWduYXR1cmVzIHNob3VsZCBiZSBsb3ctcywgdG8gcHJldmVudCBtYWxsZWFiaWxpdHkuXG4gICAgICAgIGhhc0hpZ2hTKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcih0aGlzLnMpO1xuICAgICAgICB9XG4gICAgICAgIG5vcm1hbGl6ZVMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYXNIaWdoUygpID8gbmV3IFNpZ25hdHVyZSh0aGlzLnIsIG1vZE4oLXRoaXMucyksIHRoaXMucmVjb3ZlcnkpIDogdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBERVItZW5jb2RlZFxuICAgICAgICB0b0RFUlJhd0J5dGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHV0LmhleFRvQnl0ZXModGhpcy50b0RFUkhleCgpKTtcbiAgICAgICAgfVxuICAgICAgICB0b0RFUkhleCgpIHtcbiAgICAgICAgICAgIHJldHVybiBERVIuaGV4RnJvbVNpZyh7IHI6IHRoaXMuciwgczogdGhpcy5zIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhZGRlZCBieXRlcyBvZiByLCB0aGVuIHBhZGRlZCBieXRlcyBvZiBzXG4gICAgICAgIHRvQ29tcGFjdFJhd0J5dGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHV0LmhleFRvQnl0ZXModGhpcy50b0NvbXBhY3RIZXgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9Db21wYWN0SGV4KCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bVRvTkJ5dGVTdHIodGhpcy5yKSArIG51bVRvTkJ5dGVTdHIodGhpcy5zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB1dGlscyA9IHtcbiAgICAgICAgaXNWYWxpZFByaXZhdGVLZXkocHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVLZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyOiBub3JtUHJpdmF0ZUtleVRvU2NhbGFyLFxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZHVjZXMgY3J5cHRvZ3JhcGhpY2FsbHkgc2VjdXJlIHByaXZhdGUga2V5IGZyb20gcmFuZG9tIG9mIHNpemVcbiAgICAgICAgICogKGdyb3VwTGVuICsgY2VpbChncm91cExlbiAvIDIpKSB3aXRoIG1vZHVsbyBiaWFzIGJlaW5nIG5lZ2xpZ2libGUuXG4gICAgICAgICAqL1xuICAgICAgICByYW5kb21Qcml2YXRlS2V5OiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBtb2QuZ2V0TWluSGFzaExlbmd0aChDVVJWRS5uKTtcbiAgICAgICAgICAgIHJldHVybiBtb2QubWFwSGFzaFRvRmllbGQoQ1VSVkUucmFuZG9tQnl0ZXMobGVuZ3RoKSwgQ1VSVkUubik7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIHByZWNvbXB1dGUgdGFibGUgZm9yIGFuIGFyYml0cmFyeSBFQyBwb2ludC4gTWFrZXMgcG9pbnQgXCJjYWNoZWRcIi5cbiAgICAgICAgICogQWxsb3dzIHRvIG1hc3NpdmVseSBzcGVlZC11cCBgcG9pbnQubXVsdGlwbHkoc2NhbGFyKWAuXG4gICAgICAgICAqIEByZXR1cm5zIGNhY2hlZCBwb2ludFxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBjb25zdCBmYXN0ID0gdXRpbHMucHJlY29tcHV0ZSg4LCBQcm9qZWN0aXZlUG9pbnQuZnJvbUhleChzb21lb25lc1B1YktleSkpO1xuICAgICAgICAgKiBmYXN0Lm11bHRpcGx5KHByaXZLZXkpOyAvLyBtdWNoIGZhc3RlciBFQ0RIIG5vd1xuICAgICAgICAgKi9cbiAgICAgICAgcHJlY29tcHV0ZSh3aW5kb3dTaXplID0gOCwgcG9pbnQgPSBQb2ludC5CQVNFKSB7XG4gICAgICAgICAgICBwb2ludC5fc2V0V2luZG93U2l6ZSh3aW5kb3dTaXplKTtcbiAgICAgICAgICAgIHBvaW50Lm11bHRpcGx5KEJpZ0ludCgzKSk7IC8vIDMgaXMgYXJiaXRyYXJ5LCBqdXN0IG5lZWQgYW55IG51bWJlciBoZXJlXG4gICAgICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBwdWJsaWMga2V5IGZvciBhIHByaXZhdGUga2V5LiBDaGVja3MgZm9yIHZhbGlkaXR5IG9mIHRoZSBwcml2YXRlIGtleS5cbiAgICAgKiBAcGFyYW0gcHJpdmF0ZUtleSBwcml2YXRlIGtleVxuICAgICAqIEBwYXJhbSBpc0NvbXByZXNzZWQgd2hldGhlciB0byByZXR1cm4gY29tcGFjdCAoZGVmYXVsdCksIG9yIGZ1bGwga2V5XG4gICAgICogQHJldHVybnMgUHVibGljIGtleSwgZnVsbCB3aGVuIGlzQ29tcHJlc3NlZD1mYWxzZTsgc2hvcnQgd2hlbiBpc0NvbXByZXNzZWQ9dHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFB1YmxpY0tleShwcml2YXRlS2V5LCBpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBQb2ludC5mcm9tUHJpdmF0ZUtleShwcml2YXRlS2V5KS50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1aWNrIGFuZCBkaXJ0eSBjaGVjayBmb3IgaXRlbSBiZWluZyBwdWJsaWMga2V5LiBEb2VzIG5vdCB2YWxpZGF0ZSBoZXgsIG9yIGJlaW5nIG9uLWN1cnZlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUHJvYlB1YihpdGVtKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IGl0ZW0gaW5zdGFuY2VvZiBVaW50OEFycmF5O1xuICAgICAgICBjb25zdCBzdHIgPSB0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZyc7XG4gICAgICAgIGNvbnN0IGxlbiA9IChhcnIgfHwgc3RyKSAmJiBpdGVtLmxlbmd0aDtcbiAgICAgICAgaWYgKGFycilcbiAgICAgICAgICAgIHJldHVybiBsZW4gPT09IGNvbXByZXNzZWRMZW4gfHwgbGVuID09PSB1bmNvbXByZXNzZWRMZW47XG4gICAgICAgIGlmIChzdHIpXG4gICAgICAgICAgICByZXR1cm4gbGVuID09PSAyICogY29tcHJlc3NlZExlbiB8fCBsZW4gPT09IDIgKiB1bmNvbXByZXNzZWRMZW47XG4gICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgUG9pbnQpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFQ0RIIChFbGxpcHRpYyBDdXJ2ZSBEaWZmaWUgSGVsbG1hbikuXG4gICAgICogQ29tcHV0ZXMgc2hhcmVkIHB1YmxpYyBrZXkgZnJvbSBwcml2YXRlIGtleSBhbmQgcHVibGljIGtleS5cbiAgICAgKiBDaGVja3M6IDEpIHByaXZhdGUga2V5IHZhbGlkaXR5IDIpIHNoYXJlZCBrZXkgaXMgb24tY3VydmUuXG4gICAgICogRG9lcyBOT1QgaGFzaCB0aGUgcmVzdWx0LlxuICAgICAqIEBwYXJhbSBwcml2YXRlQSBwcml2YXRlIGtleVxuICAgICAqIEBwYXJhbSBwdWJsaWNCIGRpZmZlcmVudCBwdWJsaWMga2V5XG4gICAgICogQHBhcmFtIGlzQ29tcHJlc3NlZCB3aGV0aGVyIHRvIHJldHVybiBjb21wYWN0IChkZWZhdWx0KSwgb3IgZnVsbCBrZXlcbiAgICAgKiBAcmV0dXJucyBzaGFyZWQgcHVibGljIGtleVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFNoYXJlZFNlY3JldChwcml2YXRlQSwgcHVibGljQiwgaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICBpZiAoaXNQcm9iUHViKHByaXZhdGVBKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZmlyc3QgYXJnIG11c3QgYmUgcHJpdmF0ZSBrZXknKTtcbiAgICAgICAgaWYgKCFpc1Byb2JQdWIocHVibGljQikpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NlY29uZCBhcmcgbXVzdCBiZSBwdWJsaWMga2V5Jyk7XG4gICAgICAgIGNvbnN0IGIgPSBQb2ludC5mcm9tSGV4KHB1YmxpY0IpOyAvLyBjaGVjayBmb3IgYmVpbmcgb24tY3VydmVcbiAgICAgICAgcmV0dXJuIGIubXVsdGlwbHkobm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlQSkpLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKTtcbiAgICB9XG4gICAgLy8gUkZDNjk3OTogZW5zdXJlIEVDRFNBIG1zZyBpcyBYIGJ5dGVzIGFuZCA8IE4uIFJGQyBzdWdnZXN0cyBvcHRpb25hbCB0cnVuY2F0aW5nIHZpYSBiaXRzMm9jdGV0cy5cbiAgICAvLyBGSVBTIDE4Ni00IDQuNiBzdWdnZXN0cyB0aGUgbGVmdG1vc3QgbWluKG5CaXRMZW4sIG91dExlbikgYml0cywgd2hpY2ggbWF0Y2hlcyBiaXRzMmludC5cbiAgICAvLyBiaXRzMmludCBjYW4gcHJvZHVjZSByZXM+Tiwgd2UgY2FuIGRvIG1vZChyZXMsIE4pIHNpbmNlIHRoZSBiaXRMZW4gaXMgdGhlIHNhbWUuXG4gICAgLy8gaW50Mm9jdGV0cyBjYW4ndCBiZSB1c2VkOyBwYWRzIHNtYWxsIG1zZ3Mgd2l0aCAwOiB1bmFjY2VwdGF0YmxlIGZvciB0cnVuYyBhcyBwZXIgUkZDIHZlY3RvcnNcbiAgICBjb25zdCBiaXRzMmludCA9IENVUlZFLmJpdHMyaW50IHx8XG4gICAgICAgIGZ1bmN0aW9uIChieXRlcykge1xuICAgICAgICAgICAgLy8gRm9yIGN1cnZlcyB3aXRoIG5CaXRMZW5ndGggJSA4ICE9PSAwOiBiaXRzMm9jdGV0cyhiaXRzMm9jdGV0cyhtKSkgIT09IGJpdHMyb2N0ZXRzKG0pXG4gICAgICAgICAgICAvLyBmb3Igc29tZSBjYXNlcywgc2luY2UgYnl0ZXMubGVuZ3RoICogOCBpcyBub3QgYWN0dWFsIGJpdExlbmd0aC5cbiAgICAgICAgICAgIGNvbnN0IG51bSA9IHV0LmJ5dGVzVG9OdW1iZXJCRShieXRlcyk7IC8vIGNoZWNrIGZvciA9PSB1OCBkb25lIGhlcmVcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gYnl0ZXMubGVuZ3RoICogOCAtIENVUlZFLm5CaXRMZW5ndGg7IC8vIHRydW5jYXRlIHRvIG5CaXRMZW5ndGggbGVmdG1vc3QgYml0c1xuICAgICAgICAgICAgcmV0dXJuIGRlbHRhID4gMCA/IG51bSA+PiBCaWdJbnQoZGVsdGEpIDogbnVtO1xuICAgICAgICB9O1xuICAgIGNvbnN0IGJpdHMyaW50X21vZE4gPSBDVVJWRS5iaXRzMmludF9tb2ROIHx8XG4gICAgICAgIGZ1bmN0aW9uIChieXRlcykge1xuICAgICAgICAgICAgcmV0dXJuIG1vZE4oYml0czJpbnQoYnl0ZXMpKTsgLy8gY2FuJ3QgdXNlIGJ5dGVzVG9OdW1iZXJCRSBoZXJlXG4gICAgICAgIH07XG4gICAgLy8gTk9URTogcGFkcyBvdXRwdXQgd2l0aCB6ZXJvIGFzIHBlciBzcGVjXG4gICAgY29uc3QgT1JERVJfTUFTSyA9IHV0LmJpdE1hc2soQ1VSVkUubkJpdExlbmd0aCk7XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdG8gYnl0ZXMuIENoZWNrcyBpZiBudW0gaW4gYFswLi5PUkRFUl9NQVNLLTFdYCBlLmcuOiBgWzAuLjJeMjU2LTFdYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnQyb2N0ZXRzKG51bSkge1xuICAgICAgICBpZiAodHlwZW9mIG51bSAhPT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JpZ2ludCBleHBlY3RlZCcpO1xuICAgICAgICBpZiAoIShfMG4gPD0gbnVtICYmIG51bSA8IE9SREVSX01BU0spKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBiaWdpbnQgZXhwZWN0ZWQgPCAyXiR7Q1VSVkUubkJpdExlbmd0aH1gKTtcbiAgICAgICAgLy8gd29ya3Mgd2l0aCBvcmRlciwgY2FuIGhhdmUgZGlmZmVyZW50IHNpemUgdGhhbiBudW1Ub0ZpZWxkIVxuICAgICAgICByZXR1cm4gdXQubnVtYmVyVG9CeXRlc0JFKG51bSwgQ1VSVkUubkJ5dGVMZW5ndGgpO1xuICAgIH1cbiAgICAvLyBTdGVwcyBBLCBEIG9mIFJGQzY5NzkgMy4yXG4gICAgLy8gQ3JlYXRlcyBSRkM2OTc5IHNlZWQ7IGNvbnZlcnRzIG1zZy9wcml2S2V5IHRvIG51bWJlcnMuXG4gICAgLy8gVXNlZCBvbmx5IGluIHNpZ24sIG5vdCBpbiB2ZXJpZnkuXG4gICAgLy8gTk9URTogd2UgY2Fubm90IGFzc3VtZSBoZXJlIHRoYXQgbXNnSGFzaCBoYXMgc2FtZSBhbW91bnQgb2YgYnl0ZXMgYXMgY3VydmUgb3JkZXIsIHRoaXMgd2lsbCBiZSB3cm9uZyBhdCBsZWFzdCBmb3IgUDUyMS5cbiAgICAvLyBBbHNvIGl0IGNhbiBiZSBiaWdnZXIgZm9yIFAyMjQgKyBTSEEyNTZcbiAgICBmdW5jdGlvbiBwcmVwU2lnKG1zZ0hhc2gsIHByaXZhdGVLZXksIG9wdHMgPSBkZWZhdWx0U2lnT3B0cykge1xuICAgICAgICBpZiAoWydyZWNvdmVyZWQnLCAnY2Fub25pY2FsJ10uc29tZSgoaykgPT4gayBpbiBvcHRzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbigpIGxlZ2FjeSBvcHRpb25zIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgY29uc3QgeyBoYXNoLCByYW5kb21CeXRlcyB9ID0gQ1VSVkU7XG4gICAgICAgIGxldCB7IGxvd1MsIHByZWhhc2gsIGV4dHJhRW50cm9weTogZW50IH0gPSBvcHRzOyAvLyBnZW5lcmF0ZXMgbG93LXMgc2lncyBieSBkZWZhdWx0XG4gICAgICAgIGlmIChsb3dTID09IG51bGwpXG4gICAgICAgICAgICBsb3dTID0gdHJ1ZTsgLy8gUkZDNjk3OSAzLjI6IHdlIHNraXAgc3RlcCBBLCBiZWNhdXNlIHdlIGFscmVhZHkgcHJvdmlkZSBoYXNoXG4gICAgICAgIG1zZ0hhc2ggPSBlbnN1cmVCeXRlcygnbXNnSGFzaCcsIG1zZ0hhc2gpO1xuICAgICAgICBpZiAocHJlaGFzaClcbiAgICAgICAgICAgIG1zZ0hhc2ggPSBlbnN1cmVCeXRlcygncHJlaGFzaGVkIG1zZ0hhc2gnLCBoYXNoKG1zZ0hhc2gpKTtcbiAgICAgICAgLy8gV2UgY2FuJ3QgbGF0ZXIgY2FsbCBiaXRzMm9jdGV0cywgc2luY2UgbmVzdGVkIGJpdHMyaW50IGlzIGJyb2tlbiBmb3IgY3VydmVzXG4gICAgICAgIC8vIHdpdGggbkJpdExlbmd0aCAlIDggIT09IDAuIEJlY2F1c2Ugb2YgdGhhdCwgd2UgdW53cmFwIGl0IGhlcmUgYXMgaW50Mm9jdGV0cyBjYWxsLlxuICAgICAgICAvLyBjb25zdCBiaXRzMm9jdGV0cyA9IChiaXRzKSA9PiBpbnQyb2N0ZXRzKGJpdHMyaW50X21vZE4oYml0cykpXG4gICAgICAgIGNvbnN0IGgxaW50ID0gYml0czJpbnRfbW9kTihtc2dIYXNoKTtcbiAgICAgICAgY29uc3QgZCA9IG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUtleSk7IC8vIHZhbGlkYXRlIHByaXZhdGUga2V5LCBjb252ZXJ0IHRvIGJpZ2ludFxuICAgICAgICBjb25zdCBzZWVkQXJncyA9IFtpbnQyb2N0ZXRzKGQpLCBpbnQyb2N0ZXRzKGgxaW50KV07XG4gICAgICAgIC8vIGV4dHJhRW50cm9weS4gUkZDNjk3OSAzLjY6IGFkZGl0aW9uYWwgaycgKG9wdGlvbmFsKS5cbiAgICAgICAgaWYgKGVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBLID0gSE1BQ19LKFYgfHwgMHgwMCB8fCBpbnQyb2N0ZXRzKHgpIHx8IGJpdHMyb2N0ZXRzKGgxKSB8fCBrJylcbiAgICAgICAgICAgIGNvbnN0IGUgPSBlbnQgPT09IHRydWUgPyByYW5kb21CeXRlcyhGcC5CWVRFUykgOiBlbnQ7IC8vIGdlbmVyYXRlIHJhbmRvbSBieXRlcyBPUiBwYXNzIGFzLWlzXG4gICAgICAgICAgICBzZWVkQXJncy5wdXNoKGVuc3VyZUJ5dGVzKCdleHRyYUVudHJvcHknLCBlKSk7IC8vIGNoZWNrIGZvciBiZWluZyBieXRlc1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlZWQgPSB1dC5jb25jYXRCeXRlcyguLi5zZWVkQXJncyk7IC8vIFN0ZXAgRCBvZiBSRkM2OTc5IDMuMlxuICAgICAgICBjb25zdCBtID0gaDFpbnQ7IC8vIE5PVEU6IG5vIG5lZWQgdG8gY2FsbCBiaXRzMmludCBzZWNvbmQgdGltZSBoZXJlLCBpdCBpcyBpbnNpZGUgdHJ1bmNhdGVIYXNoIVxuICAgICAgICAvLyBDb252ZXJ0cyBzaWduYXR1cmUgcGFyYW1zIGludG8gcG9pbnQgdyByL3MsIGNoZWNrcyByZXN1bHQgZm9yIHZhbGlkaXR5LlxuICAgICAgICBmdW5jdGlvbiBrMnNpZyhrQnl0ZXMpIHtcbiAgICAgICAgICAgIC8vIFJGQyA2OTc5IFNlY3Rpb24gMy4yLCBzdGVwIDM6IGsgPSBiaXRzMmludChUKVxuICAgICAgICAgICAgY29uc3QgayA9IGJpdHMyaW50KGtCeXRlcyk7IC8vIENhbm5vdCB1c2UgZmllbGRzIG1ldGhvZHMsIHNpbmNlIGl0IGlzIGdyb3VwIGVsZW1lbnRcbiAgICAgICAgICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKGspKVxuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gSW1wb3J0YW50OiBhbGwgbW9kKCkgY2FsbHMgaGVyZSBtdXN0IGJlIGRvbmUgb3ZlciBOXG4gICAgICAgICAgICBjb25zdCBpayA9IGludk4oayk7IC8vIGteLTEgbW9kIG5cbiAgICAgICAgICAgIGNvbnN0IHEgPSBQb2ludC5CQVNFLm11bHRpcGx5KGspLnRvQWZmaW5lKCk7IC8vIHEgPSBHa1xuICAgICAgICAgICAgY29uc3QgciA9IG1vZE4ocS54KTsgLy8gciA9IHEueCBtb2QgblxuICAgICAgICAgICAgaWYgKHIgPT09IF8wbilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBDYW4gdXNlIHNjYWxhciBibGluZGluZyBiXi0xKGJtICsgYmRyKSB3aGVyZSBiIOKIiCBbMSxx4oiSMV0gYWNjb3JkaW5nIHRvXG4gICAgICAgICAgICAvLyBodHRwczovL3RjaGVzLmlhY3Iub3JnL2luZGV4LnBocC9UQ0hFUy9hcnRpY2xlL3ZpZXcvNzMzNy82NTA5LiBXZSd2ZSBkZWNpZGVkIGFnYWluc3QgaXQ6XG4gICAgICAgICAgICAvLyBhKSBkZXBlbmRlbmN5IG9uIENTUFJORyBiKSAxNSUgc2xvd2Rvd24gYykgZG9lc24ndCByZWFsbHkgaGVscCBzaW5jZSBiaWdpbnRzIGFyZSBub3QgQ1RcbiAgICAgICAgICAgIGNvbnN0IHMgPSBtb2ROKGlrICogbW9kTihtICsgciAqIGQpKTsgLy8gTm90IHVzaW5nIGJsaW5kaW5nIGhlcmVcbiAgICAgICAgICAgIGlmIChzID09PSBfMG4pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHJlY292ZXJ5ID0gKHEueCA9PT0gciA/IDAgOiAyKSB8IE51bWJlcihxLnkgJiBfMW4pOyAvLyByZWNvdmVyeSBiaXQgKDIgb3IgMywgd2hlbiBxLnggPiBuKVxuICAgICAgICAgICAgbGV0IG5vcm1TID0gcztcbiAgICAgICAgICAgIGlmIChsb3dTICYmIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihzKSkge1xuICAgICAgICAgICAgICAgIG5vcm1TID0gbm9ybWFsaXplUyhzKTsgLy8gaWYgbG93UyB3YXMgcGFzc2VkLCBlbnN1cmUgcyBpcyBhbHdheXNcbiAgICAgICAgICAgICAgICByZWNvdmVyeSBePSAxOyAvLyAvLyBpbiB0aGUgYm90dG9tIGhhbGYgb2YgTlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUociwgbm9ybVMsIHJlY292ZXJ5KTsgLy8gdXNlIG5vcm1TLCBub3Qgc1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHNlZWQsIGsyc2lnIH07XG4gICAgfVxuICAgIGNvbnN0IGRlZmF1bHRTaWdPcHRzID0geyBsb3dTOiBDVVJWRS5sb3dTLCBwcmVoYXNoOiBmYWxzZSB9O1xuICAgIGNvbnN0IGRlZmF1bHRWZXJPcHRzID0geyBsb3dTOiBDVVJWRS5sb3dTLCBwcmVoYXNoOiBmYWxzZSB9O1xuICAgIC8qKlxuICAgICAqIFNpZ25zIG1lc3NhZ2UgaGFzaCB3aXRoIGEgcHJpdmF0ZSBrZXkuXG4gICAgICogYGBgXG4gICAgICogc2lnbihtLCBkLCBrKSB3aGVyZVxuICAgICAqICAgKHgsIHkpID0gRyDDlyBrXG4gICAgICogICByID0geCBtb2QgblxuICAgICAqICAgcyA9IChtICsgZHIpL2sgbW9kIG5cbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0gbXNnSGFzaCBOT1QgbWVzc2FnZS4gbXNnIG5lZWRzIHRvIGJlIGhhc2hlZCB0byBgbXNnSGFzaGAsIG9yIHVzZSBgcHJlaGFzaGAuXG4gICAgICogQHBhcmFtIHByaXZLZXkgcHJpdmF0ZSBrZXlcbiAgICAgKiBAcGFyYW0gb3B0cyBsb3dTIGZvciBub24tbWFsbGVhYmxlIHNpZ3MuIGV4dHJhRW50cm9weSBmb3IgbWl4aW5nIHJhbmRvbW5lc3MgaW50byBrLiBwcmVoYXNoIHdpbGwgaGFzaCBmaXJzdCBhcmcuXG4gICAgICogQHJldHVybnMgc2lnbmF0dXJlIHdpdGggcmVjb3ZlcnkgcGFyYW1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaWduKG1zZ0hhc2gsIHByaXZLZXksIG9wdHMgPSBkZWZhdWx0U2lnT3B0cykge1xuICAgICAgICBjb25zdCB7IHNlZWQsIGsyc2lnIH0gPSBwcmVwU2lnKG1zZ0hhc2gsIHByaXZLZXksIG9wdHMpOyAvLyBTdGVwcyBBLCBEIG9mIFJGQzY5NzkgMy4yLlxuICAgICAgICBjb25zdCBDID0gQ1VSVkU7XG4gICAgICAgIGNvbnN0IGRyYmcgPSB1dC5jcmVhdGVIbWFjRHJiZyhDLmhhc2gub3V0cHV0TGVuLCBDLm5CeXRlTGVuZ3RoLCBDLmhtYWMpO1xuICAgICAgICByZXR1cm4gZHJiZyhzZWVkLCBrMnNpZyk7IC8vIFN0ZXBzIEIsIEMsIEQsIEUsIEYsIEdcbiAgICB9XG4gICAgLy8gRW5hYmxlIHByZWNvbXB1dGVzLiBTbG93cyBkb3duIGZpcnN0IHB1YmxpY0tleSBjb21wdXRhdGlvbiBieSAyMG1zLlxuICAgIFBvaW50LkJBU0UuX3NldFdpbmRvd1NpemUoOCk7XG4gICAgLy8gdXRpbHMucHJlY29tcHV0ZSg4LCBQcm9qZWN0aXZlUG9pbnQuQkFTRSlcbiAgICAvKipcbiAgICAgKiBWZXJpZmllcyBhIHNpZ25hdHVyZSBhZ2FpbnN0IG1lc3NhZ2UgaGFzaCBhbmQgcHVibGljIGtleS5cbiAgICAgKiBSZWplY3RzIGxvd1Mgc2lnbmF0dXJlcyBieSBkZWZhdWx0OiB0byBvdmVycmlkZSxcbiAgICAgKiBzcGVjaWZ5IG9wdGlvbiBge2xvd1M6IGZhbHNlfWAuIEltcGxlbWVudHMgc2VjdGlvbiA0LjEuNCBmcm9tIGh0dHBzOi8vd3d3LnNlY2cub3JnL3NlYzEtdjIucGRmOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogdmVyaWZ5KHIsIHMsIGgsIFApIHdoZXJlXG4gICAgICogICBVMSA9IGhzXi0xIG1vZCBuXG4gICAgICogICBVMiA9IHJzXi0xIG1vZCBuXG4gICAgICogICBSID0gVTHii4VHIC0gVTLii4VQXG4gICAgICogICBtb2QoUi54LCBuKSA9PSByXG4gICAgICogYGBgXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmVyaWZ5KHNpZ25hdHVyZSwgbXNnSGFzaCwgcHVibGljS2V5LCBvcHRzID0gZGVmYXVsdFZlck9wdHMpIHtcbiAgICAgICAgY29uc3Qgc2cgPSBzaWduYXR1cmU7XG4gICAgICAgIG1zZ0hhc2ggPSBlbnN1cmVCeXRlcygnbXNnSGFzaCcsIG1zZ0hhc2gpO1xuICAgICAgICBwdWJsaWNLZXkgPSBlbnN1cmVCeXRlcygncHVibGljS2V5JywgcHVibGljS2V5KTtcbiAgICAgICAgaWYgKCdzdHJpY3QnIGluIG9wdHMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMuc3RyaWN0IHdhcyByZW5hbWVkIHRvIGxvd1MnKTtcbiAgICAgICAgY29uc3QgeyBsb3dTLCBwcmVoYXNoIH0gPSBvcHRzO1xuICAgICAgICBsZXQgX3NpZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IFA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNnID09PSAnc3RyaW5nJyB8fCBzZyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgICAgICAvLyBTaWduYXR1cmUgY2FuIGJlIHJlcHJlc2VudGVkIGluIDIgd2F5czogY29tcGFjdCAoMipuQnl0ZUxlbmd0aCkgJiBERVIgKHZhcmlhYmxlLWxlbmd0aCkuXG4gICAgICAgICAgICAgICAgLy8gU2luY2UgREVSIGNhbiBhbHNvIGJlIDIqbkJ5dGVMZW5ndGggYnl0ZXMsIHdlIGNoZWNrIGZvciBpdCBmaXJzdC5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBfc2lnID0gU2lnbmF0dXJlLmZyb21ERVIoc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZGVyRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoZGVyRXJyb3IgaW5zdGFuY2VvZiBERVIuRXJyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGRlckVycm9yO1xuICAgICAgICAgICAgICAgICAgICBfc2lnID0gU2lnbmF0dXJlLmZyb21Db21wYWN0KHNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc2cgPT09ICdvYmplY3QnICYmIHR5cGVvZiBzZy5yID09PSAnYmlnaW50JyAmJiB0eXBlb2Ygc2cucyA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHIsIHMgfSA9IHNnO1xuICAgICAgICAgICAgICAgIF9zaWcgPSBuZXcgU2lnbmF0dXJlKHIsIHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQQVJTRScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUCA9IFBvaW50LmZyb21IZXgocHVibGljS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlID09PSAnUEFSU0UnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgc2lnbmF0dXJlIG11c3QgYmUgU2lnbmF0dXJlIGluc3RhbmNlLCBVaW50OEFycmF5IG9yIGhleCBzdHJpbmdgKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG93UyAmJiBfc2lnLmhhc0hpZ2hTKCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChwcmVoYXNoKVxuICAgICAgICAgICAgbXNnSGFzaCA9IENVUlZFLmhhc2gobXNnSGFzaCk7XG4gICAgICAgIGNvbnN0IHsgciwgcyB9ID0gX3NpZztcbiAgICAgICAgY29uc3QgaCA9IGJpdHMyaW50X21vZE4obXNnSGFzaCk7IC8vIENhbm5vdCB1c2UgZmllbGRzIG1ldGhvZHMsIHNpbmNlIGl0IGlzIGdyb3VwIGVsZW1lbnRcbiAgICAgICAgY29uc3QgaXMgPSBpbnZOKHMpOyAvLyBzXi0xXG4gICAgICAgIGNvbnN0IHUxID0gbW9kTihoICogaXMpOyAvLyB1MSA9IGhzXi0xIG1vZCBuXG4gICAgICAgIGNvbnN0IHUyID0gbW9kTihyICogaXMpOyAvLyB1MiA9IHJzXi0xIG1vZCBuXG4gICAgICAgIGNvbnN0IFIgPSBQb2ludC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKFAsIHUxLCB1Mik/LnRvQWZmaW5lKCk7IC8vIFIgPSB1MeKLhUcgKyB1MuKLhVBcbiAgICAgICAgaWYgKCFSKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCB2ID0gbW9kTihSLngpO1xuICAgICAgICByZXR1cm4gdiA9PT0gcjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgQ1VSVkUsXG4gICAgICAgIGdldFB1YmxpY0tleSxcbiAgICAgICAgZ2V0U2hhcmVkU2VjcmV0LFxuICAgICAgICBzaWduLFxuICAgICAgICB2ZXJpZnksXG4gICAgICAgIFByb2plY3RpdmVQb2ludDogUG9pbnQsXG4gICAgICAgIFNpZ25hdHVyZSxcbiAgICAgICAgdXRpbHMsXG4gICAgfTtcbn1cbi8qKlxuICogSW1wbGVtZW50YXRpb24gb2YgdGhlIFNoYWxsdWUgYW5kIHZhbiBkZSBXb2VzdGlqbmUgbWV0aG9kIGZvciBhbnkgd2VpZXJzdHJhc3MgY3VydmUuXG4gKiBUT0RPOiBjaGVjayBpZiB0aGVyZSBpcyBhIHdheSB0byBtZXJnZSB0aGlzIHdpdGggdXZSYXRpbyBpbiBFZHdhcmRzOyBtb3ZlIHRvIG1vZHVsYXIuXG4gKiBiID0gVHJ1ZSBhbmQgeSA9IHNxcnQodSAvIHYpIGlmICh1IC8gdikgaXMgc3F1YXJlIGluIEYsIGFuZFxuICogYiA9IEZhbHNlIGFuZCB5ID0gc3FydChaICogKHUgLyB2KSkgb3RoZXJ3aXNlLlxuICogQHBhcmFtIEZwXG4gKiBAcGFyYW0gWlxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFNXVUZwU3FydFJhdGlvKEZwLCBaKSB7XG4gICAgLy8gR2VuZXJpYyBpbXBsZW1lbnRhdGlvblxuICAgIGNvbnN0IHEgPSBGcC5PUkRFUjtcbiAgICBsZXQgbCA9IF8wbjtcbiAgICBmb3IgKGxldCBvID0gcSAtIF8xbjsgbyAlIF8ybiA9PT0gXzBuOyBvIC89IF8ybilcbiAgICAgICAgbCArPSBfMW47XG4gICAgY29uc3QgYzEgPSBsOyAvLyAxLiBjMSwgdGhlIGxhcmdlc3QgaW50ZWdlciBzdWNoIHRoYXQgMl5jMSBkaXZpZGVzIHEgLSAxLlxuICAgIC8vIFdlIG5lZWQgMm4gKiogYzEgYW5kIDJuICoqIChjMS0xKS4gV2UgY2FuJ3QgdXNlICoqOyBidXQgd2UgY2FuIHVzZSA8PC5cbiAgICAvLyAybiAqKiBjMSA9PSAybiA8PCAoYzEtMSlcbiAgICBjb25zdCBfMm5fcG93X2MxXzEgPSBfMm4gPDwgKGMxIC0gXzFuIC0gXzFuKTtcbiAgICBjb25zdCBfMm5fcG93X2MxID0gXzJuX3Bvd19jMV8xICogXzJuO1xuICAgIGNvbnN0IGMyID0gKHEgLSBfMW4pIC8gXzJuX3Bvd19jMTsgLy8gMi4gYzIgPSAocSAtIDEpIC8gKDJeYzEpICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGMzID0gKGMyIC0gXzFuKSAvIF8ybjsgLy8gMy4gYzMgPSAoYzIgLSAxKSAvIDIgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM0ID0gXzJuX3Bvd19jMSAtIF8xbjsgLy8gNC4gYzQgPSAyXmMxIC0gMSAgICAgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM1ID0gXzJuX3Bvd19jMV8xOyAvLyA1LiBjNSA9IDJeKGMxIC0gMSkgICAgICAgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM2ID0gRnAucG93KFosIGMyKTsgLy8gNi4gYzYgPSBaXmMyXG4gICAgY29uc3QgYzcgPSBGcC5wb3coWiwgKGMyICsgXzFuKSAvIF8ybik7IC8vIDcuIGM3ID0gWl4oKGMyICsgMSkgLyAyKVxuICAgIGxldCBzcXJ0UmF0aW8gPSAodSwgdikgPT4ge1xuICAgICAgICBsZXQgdHYxID0gYzY7IC8vIDEuIHR2MSA9IGM2XG4gICAgICAgIGxldCB0djIgPSBGcC5wb3codiwgYzQpOyAvLyAyLiB0djIgPSB2XmM0XG4gICAgICAgIGxldCB0djMgPSBGcC5zcXIodHYyKTsgLy8gMy4gdHYzID0gdHYyXjJcbiAgICAgICAgdHYzID0gRnAubXVsKHR2Mywgdik7IC8vIDQuIHR2MyA9IHR2MyAqIHZcbiAgICAgICAgbGV0IHR2NSA9IEZwLm11bCh1LCB0djMpOyAvLyA1LiB0djUgPSB1ICogdHYzXG4gICAgICAgIHR2NSA9IEZwLnBvdyh0djUsIGMzKTsgLy8gNi4gdHY1ID0gdHY1XmMzXG4gICAgICAgIHR2NSA9IEZwLm11bCh0djUsIHR2Mik7IC8vIDcuIHR2NSA9IHR2NSAqIHR2MlxuICAgICAgICB0djIgPSBGcC5tdWwodHY1LCB2KTsgLy8gOC4gdHYyID0gdHY1ICogdlxuICAgICAgICB0djMgPSBGcC5tdWwodHY1LCB1KTsgLy8gOS4gdHYzID0gdHY1ICogdVxuICAgICAgICBsZXQgdHY0ID0gRnAubXVsKHR2MywgdHYyKTsgLy8gMTAuIHR2NCA9IHR2MyAqIHR2MlxuICAgICAgICB0djUgPSBGcC5wb3codHY0LCBjNSk7IC8vIDExLiB0djUgPSB0djReYzVcbiAgICAgICAgbGV0IGlzUVIgPSBGcC5lcWwodHY1LCBGcC5PTkUpOyAvLyAxMi4gaXNRUiA9IHR2NSA9PSAxXG4gICAgICAgIHR2MiA9IEZwLm11bCh0djMsIGM3KTsgLy8gMTMuIHR2MiA9IHR2MyAqIGM3XG4gICAgICAgIHR2NSA9IEZwLm11bCh0djQsIHR2MSk7IC8vIDE0LiB0djUgPSB0djQgKiB0djFcbiAgICAgICAgdHYzID0gRnAuY21vdih0djIsIHR2MywgaXNRUik7IC8vIDE1LiB0djMgPSBDTU9WKHR2MiwgdHYzLCBpc1FSKVxuICAgICAgICB0djQgPSBGcC5jbW92KHR2NSwgdHY0LCBpc1FSKTsgLy8gMTYuIHR2NCA9IENNT1YodHY1LCB0djQsIGlzUVIpXG4gICAgICAgIC8vIDE3LiBmb3IgaSBpbiAoYzEsIGMxIC0gMSwgLi4uLCAyKTpcbiAgICAgICAgZm9yIChsZXQgaSA9IGMxOyBpID4gXzFuOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCB0djUgPSBpIC0gXzJuOyAvLyAxOC4gICAgdHY1ID0gaSAtIDJcbiAgICAgICAgICAgIHR2NSA9IF8ybiA8PCAodHY1IC0gXzFuKTsgLy8gMTkuICAgIHR2NSA9IDJedHY1XG4gICAgICAgICAgICBsZXQgdHZ2NSA9IEZwLnBvdyh0djQsIHR2NSk7IC8vIDIwLiAgICB0djUgPSB0djRedHY1XG4gICAgICAgICAgICBjb25zdCBlMSA9IEZwLmVxbCh0dnY1LCBGcC5PTkUpOyAvLyAyMS4gICAgZTEgPSB0djUgPT0gMVxuICAgICAgICAgICAgdHYyID0gRnAubXVsKHR2MywgdHYxKTsgLy8gMjIuICAgIHR2MiA9IHR2MyAqIHR2MVxuICAgICAgICAgICAgdHYxID0gRnAubXVsKHR2MSwgdHYxKTsgLy8gMjMuICAgIHR2MSA9IHR2MSAqIHR2MVxuICAgICAgICAgICAgdHZ2NSA9IEZwLm11bCh0djQsIHR2MSk7IC8vIDI0LiAgICB0djUgPSB0djQgKiB0djFcbiAgICAgICAgICAgIHR2MyA9IEZwLmNtb3YodHYyLCB0djMsIGUxKTsgLy8gMjUuICAgIHR2MyA9IENNT1YodHYyLCB0djMsIGUxKVxuICAgICAgICAgICAgdHY0ID0gRnAuY21vdih0dnY1LCB0djQsIGUxKTsgLy8gMjYuICAgIHR2NCA9IENNT1YodHY1LCB0djQsIGUxKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGlzUVIsIHZhbHVlOiB0djMgfTtcbiAgICB9O1xuICAgIGlmIChGcC5PUkRFUiAlIF80biA9PT0gXzNuKSB7XG4gICAgICAgIC8vIHNxcnRfcmF0aW9fM21vZDQodSwgdilcbiAgICAgICAgY29uc3QgYzEgPSAoRnAuT1JERVIgLSBfM24pIC8gXzRuOyAvLyAxLiBjMSA9IChxIC0gMykgLyA0ICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgICAgICBjb25zdCBjMiA9IEZwLnNxcnQoRnAubmVnKFopKTsgLy8gMi4gYzIgPSBzcXJ0KC1aKVxuICAgICAgICBzcXJ0UmF0aW8gPSAodSwgdikgPT4ge1xuICAgICAgICAgICAgbGV0IHR2MSA9IEZwLnNxcih2KTsgLy8gMS4gdHYxID0gdl4yXG4gICAgICAgICAgICBjb25zdCB0djIgPSBGcC5tdWwodSwgdik7IC8vIDIuIHR2MiA9IHUgKiB2XG4gICAgICAgICAgICB0djEgPSBGcC5tdWwodHYxLCB0djIpOyAvLyAzLiB0djEgPSB0djEgKiB0djJcbiAgICAgICAgICAgIGxldCB5MSA9IEZwLnBvdyh0djEsIGMxKTsgLy8gNC4geTEgPSB0djFeYzFcbiAgICAgICAgICAgIHkxID0gRnAubXVsKHkxLCB0djIpOyAvLyA1LiB5MSA9IHkxICogdHYyXG4gICAgICAgICAgICBjb25zdCB5MiA9IEZwLm11bCh5MSwgYzIpOyAvLyA2LiB5MiA9IHkxICogYzJcbiAgICAgICAgICAgIGNvbnN0IHR2MyA9IEZwLm11bChGcC5zcXIoeTEpLCB2KTsgLy8gNy4gdHYzID0geTFeMjsgOC4gdHYzID0gdHYzICogdlxuICAgICAgICAgICAgY29uc3QgaXNRUiA9IEZwLmVxbCh0djMsIHUpOyAvLyA5LiBpc1FSID0gdHYzID09IHVcbiAgICAgICAgICAgIGxldCB5ID0gRnAuY21vdih5MiwgeTEsIGlzUVIpOyAvLyAxMC4geSA9IENNT1YoeTIsIHkxLCBpc1FSKVxuICAgICAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogaXNRUiwgdmFsdWU6IHkgfTsgLy8gMTEuIHJldHVybiAoaXNRUiwgeSkgaXNRUiA/IHkgOiB5KmMyXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIE5vIGN1cnZlcyB1c2VzIHRoYXRcbiAgICAvLyBpZiAoRnAuT1JERVIgJSBfOG4gPT09IF81bikgLy8gc3FydF9yYXRpb181bW9kOFxuICAgIHJldHVybiBzcXJ0UmF0aW87XG59XG4vKipcbiAqIFNpbXBsaWZpZWQgU2hhbGx1ZS12YW4gZGUgV29lc3Rpam5lLVVsYXMgTWV0aG9kXG4gKiBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTYuNi4yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBUb0N1cnZlU2ltcGxlU1dVKEZwLCBvcHRzKSB7XG4gICAgbW9kLnZhbGlkYXRlRmllbGQoRnApO1xuICAgIGlmICghRnAuaXNWYWxpZChvcHRzLkEpIHx8ICFGcC5pc1ZhbGlkKG9wdHMuQikgfHwgIUZwLmlzVmFsaWQob3B0cy5aKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXBUb0N1cnZlU2ltcGxlU1dVOiBpbnZhbGlkIG9wdHMnKTtcbiAgICBjb25zdCBzcXJ0UmF0aW8gPSBTV1VGcFNxcnRSYXRpbyhGcCwgb3B0cy5aKTtcbiAgICBpZiAoIUZwLmlzT2RkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZwLmlzT2RkIGlzIG5vdCBpbXBsZW1lbnRlZCEnKTtcbiAgICAvLyBJbnB1dDogdSwgYW4gZWxlbWVudCBvZiBGLlxuICAgIC8vIE91dHB1dDogKHgsIHkpLCBhIHBvaW50IG9uIEUuXG4gICAgcmV0dXJuICh1KSA9PiB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBsZXQgdHYxLCB0djIsIHR2MywgdHY0LCB0djUsIHR2NiwgeCwgeTtcbiAgICAgICAgdHYxID0gRnAuc3FyKHUpOyAvLyAxLiAgdHYxID0gdV4yXG4gICAgICAgIHR2MSA9IEZwLm11bCh0djEsIG9wdHMuWik7IC8vIDIuICB0djEgPSBaICogdHYxXG4gICAgICAgIHR2MiA9IEZwLnNxcih0djEpOyAvLyAzLiAgdHYyID0gdHYxXjJcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHYxKTsgLy8gNC4gIHR2MiA9IHR2MiArIHR2MVxuICAgICAgICB0djMgPSBGcC5hZGQodHYyLCBGcC5PTkUpOyAvLyA1LiAgdHYzID0gdHYyICsgMVxuICAgICAgICB0djMgPSBGcC5tdWwodHYzLCBvcHRzLkIpOyAvLyA2LiAgdHYzID0gQiAqIHR2M1xuICAgICAgICB0djQgPSBGcC5jbW92KG9wdHMuWiwgRnAubmVnKHR2MiksICFGcC5lcWwodHYyLCBGcC5aRVJPKSk7IC8vIDcuICB0djQgPSBDTU9WKFosIC10djIsIHR2MiAhPSAwKVxuICAgICAgICB0djQgPSBGcC5tdWwodHY0LCBvcHRzLkEpOyAvLyA4LiAgdHY0ID0gQSAqIHR2NFxuICAgICAgICB0djIgPSBGcC5zcXIodHYzKTsgLy8gOS4gIHR2MiA9IHR2M14yXG4gICAgICAgIHR2NiA9IEZwLnNxcih0djQpOyAvLyAxMC4gdHY2ID0gdHY0XjJcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2Niwgb3B0cy5BKTsgLy8gMTEuIHR2NSA9IEEgKiB0djZcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHY1KTsgLy8gMTIuIHR2MiA9IHR2MiArIHR2NVxuICAgICAgICB0djIgPSBGcC5tdWwodHYyLCB0djMpOyAvLyAxMy4gdHYyID0gdHYyICogdHYzXG4gICAgICAgIHR2NiA9IEZwLm11bCh0djYsIHR2NCk7IC8vIDE0LiB0djYgPSB0djYgKiB0djRcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2Niwgb3B0cy5CKTsgLy8gMTUuIHR2NSA9IEIgKiB0djZcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHY1KTsgLy8gMTYuIHR2MiA9IHR2MiArIHR2NVxuICAgICAgICB4ID0gRnAubXVsKHR2MSwgdHYzKTsgLy8gMTcuICAgeCA9IHR2MSAqIHR2M1xuICAgICAgICBjb25zdCB7IGlzVmFsaWQsIHZhbHVlIH0gPSBzcXJ0UmF0aW8odHYyLCB0djYpOyAvLyAxOC4gKGlzX2d4MV9zcXVhcmUsIHkxKSA9IHNxcnRfcmF0aW8odHYyLCB0djYpXG4gICAgICAgIHkgPSBGcC5tdWwodHYxLCB1KTsgLy8gMTkuICAgeSA9IHR2MSAqIHUgIC0+IFogKiB1XjMgKiB5MVxuICAgICAgICB5ID0gRnAubXVsKHksIHZhbHVlKTsgLy8gMjAuICAgeSA9IHkgKiB5MVxuICAgICAgICB4ID0gRnAuY21vdih4LCB0djMsIGlzVmFsaWQpOyAvLyAyMS4gICB4ID0gQ01PVih4LCB0djMsIGlzX2d4MV9zcXVhcmUpXG4gICAgICAgIHkgPSBGcC5jbW92KHksIHZhbHVlLCBpc1ZhbGlkKTsgLy8gMjIuICAgeSA9IENNT1YoeSwgeTEsIGlzX2d4MV9zcXVhcmUpXG4gICAgICAgIGNvbnN0IGUxID0gRnAuaXNPZGQodSkgPT09IEZwLmlzT2RkKHkpOyAvLyAyMy4gIGUxID0gc2duMCh1KSA9PSBzZ24wKHkpXG4gICAgICAgIHkgPSBGcC5jbW92KEZwLm5lZyh5KSwgeSwgZTEpOyAvLyAyNC4gICB5ID0gQ01PVigteSwgeSwgZTEpXG4gICAgICAgIHggPSBGcC5kaXYoeCwgdHY0KTsgLy8gMjUuICAgeCA9IHggLyB0djRcbiAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13ZWllcnN0cmFzcy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/weierstrass.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/secp256k1.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/secp256k1.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encodeToCurve: () => (/* binding */ encodeToCurve),\n/* harmony export */   hashToCurve: () => (/* binding */ hashToCurve),\n/* harmony export */   schnorr: () => (/* binding */ schnorr),\n/* harmony export */   secp256k1: () => (/* binding */ secp256k1)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract/modular.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/* harmony import */ var _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./abstract/utils.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./abstract/hash-to-curve.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/hash-to-curve.js\");\n/* harmony import */ var _shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_shortw_utils.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/_shortw_utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\n\n\n\n\n\nconst secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');\nconst secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst divNearest = (a, b) => (a + b / _2n) / b;\n/**\n * n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */\nfunction sqrtMod(y) {\n    const P = secp256k1P;\n    // prettier-ignore\n    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n    // prettier-ignore\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n    const b2 = (y * y * y) % P; // x^3, 11\n    const b3 = (b2 * b2 * y) % P; // x^7\n    const b6 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b3, _3n, P) * b3) % P;\n    const b9 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b6, _3n, P) * b3) % P;\n    const b11 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b9, _2n, P) * b2) % P;\n    const b22 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b11, _11n, P) * b11) % P;\n    const b44 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b22, _22n, P) * b22) % P;\n    const b88 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b44, _44n, P) * b44) % P;\n    const b176 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b88, _88n, P) * b88) % P;\n    const b220 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b176, _44n, P) * b44) % P;\n    const b223 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b220, _3n, P) * b3) % P;\n    const t1 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b223, _23n, P) * b22) % P;\n    const t2 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(t1, _6n, P) * b2) % P;\n    const root = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(t2, _2n, P);\n    if (!Fp.eql(Fp.sqr(root), y))\n        throw new Error('Cannot find square root');\n    return root;\n}\nconst Fp = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field)(secp256k1P, undefined, undefined, { sqrt: sqrtMod });\nconst secp256k1 = (0,_shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__.createCurve)({\n    a: BigInt(0),\n    b: BigInt(7),\n    Fp,\n    n: secp256k1N,\n    // Base point (x, y) aka generator point\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    h: BigInt(1),\n    lowS: true,\n    /**\n     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066\n     */\n    endo: {\n        beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n        splitScalar: (k) => {\n            const n = secp256k1N;\n            const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n            const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n            const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n            const b2 = a1;\n            const POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)\n            const c1 = divNearest(b2 * k, n);\n            const c2 = divNearest(-b1 * k, n);\n            let k1 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(k - c1 * a1 - c2 * a2, n);\n            let k2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(-c1 * b1 - c2 * b2, n);\n            const k1neg = k1 > POW_2_128;\n            const k2neg = k2 > POW_2_128;\n            if (k1neg)\n                k1 = n - k1;\n            if (k2neg)\n                k2 = n - k2;\n            if (k1 > POW_2_128 || k2 > POW_2_128) {\n                throw new Error('splitScalar: Endomorphism failed, k=' + k);\n            }\n            return { k1neg, k1, k2neg, k2 };\n        },\n    },\n}, _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256);\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\nconst _0n = BigInt(0);\nconst fe = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1P;\nconst ge = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1N;\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\nconst TAGGED_HASH_PREFIXES = {};\nfunction taggedHash(tag, ...messages) {\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n        const tagH = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256)(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n        tagP = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(tagH, tagH);\n        TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    return (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256)((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(tagP, ...messages));\n}\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point) => point.toRawBytes(true).slice(1);\nconst numTo32b = (n) => (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.numberToBytesBE)(n, 32);\nconst modP = (x) => (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x, secp256k1P);\nconst modN = (x) => (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x, secp256k1N);\nconst Point = secp256k1.ProjectivePoint;\nconst GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv) {\n    let d_ = secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\n    let p = Point.fromPrivateKey(d_); // P = d'G; 0 < d' < n check is done inside\n    const scalar = p.hasEvenY() ? d_ : modN(-d_);\n    return { scalar: scalar, bytes: pointToBytes(p) };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */\nfunction lift_x(x) {\n    if (!fe(x))\n        throw new Error('bad x: need 0 < x < p'); // Fail if x  p.\n    const xx = modP(x * x);\n    const c = modP(xx * x + BigInt(7)); // Let c = x + 7 mod p.\n    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n    if (y % _2n !== _0n)\n        y = modP(-y); // Return the unique point P such that x(P) = x and\n    const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n    p.assertValidity();\n    return p;\n}\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */\nfunction challenge(...args) {\n    return modN((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(taggedHash('BIP0340/challenge', ...args)));\n}\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */\nfunction schnorrGetPublicKey(privateKey) {\n    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'n. Ret bytes(d'G)\n}\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */\nfunction schnorrSign(message, privateKey, auxRand = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__.randomBytes)(32)) {\n    const m = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('message', message);\n    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\n    const a = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array\n    const t = numTo32b(d ^ (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n    const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n    const k_ = modN((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(rand)); // Let k' = int(rand) mod n\n    if (k_ === _0n)\n        throw new Error('sign failed: k is zero'); // Fail if k' = 0.\n    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'G.\n    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n    sig.set(rx, 0);\n    sig.set(numTo32b(modN(k + e * d)), 32);\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n    if (!schnorrVerify(sig, m, px))\n        throw new Error('sign: Invalid signature produced');\n    return sig;\n}\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */\nfunction schnorrVerify(signature, message, publicKey) {\n    const sig = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('signature', signature, 64);\n    const m = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('message', message);\n    const pub = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('publicKey', publicKey, 32);\n    try {\n        const P = lift_x((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(pub)); // P = lift_x(int(pk)); fail if that fails\n        const r = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r  p.\n        if (!fe(r))\n            return false;\n        const s = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s  n.\n        if (!ge(s))\n            return false;\n        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n        const R = GmulAdd(P, s, modN(-e)); // R = sG - eP\n        if (!R || !R.hasEvenY() || R.toAffine().x !== r)\n            return false; // -eP == (n-e)P\n        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R)  r.\n    }\n    catch (error) {\n        return false;\n    }\n}\nconst schnorr = /* @__PURE__ */ (() => ({\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n    utils: {\n        randomPrivateKey: secp256k1.utils.randomPrivateKey,\n        lift_x,\n        pointToBytes,\n        numberToBytesBE: _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.numberToBytesBE,\n        bytesToNumberBE: _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE,\n        taggedHash,\n        mod: _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod,\n    },\n}))();\nconst isoMap = /* @__PURE__ */ (() => (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.isogenyMap)(Fp, [\n    // xNum\n    [\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',\n        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',\n        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',\n    ],\n    // xDen\n    [\n        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',\n        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n    // yNum\n    [\n        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',\n        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',\n        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',\n        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',\n    ],\n    // yDen\n    [\n        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',\n        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',\n        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n].map((i) => i.map((j) => BigInt(j)))))();\nconst mapSWU = /* @__PURE__ */ (() => (0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_6__.mapToCurveSimpleSWU)(Fp, {\n    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),\n    B: BigInt('1771'),\n    Z: Fp.create(BigInt('-11')),\n}))();\nconst htf = /* @__PURE__ */ (() => (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.createHasher)(secp256k1.ProjectivePoint, (scalars) => {\n    const { x, y } = mapSWU(Fp.create(scalars[0]));\n    return isoMap(x, y);\n}, {\n    DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',\n    encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',\n    p: Fp.ORDER,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256,\n}))();\nconst hashToCurve = /* @__PURE__ */ (() => htf.hashToCurve)();\nconst encodeToCurve = /* @__PURE__ */ (() => htf.encodeToCurve)();\n//# sourceMappingURL=secp256k1.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vc2VjcDI1NmsxLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDOEM7QUFDSTtBQUNPO0FBQ087QUFDaUM7QUFDMUI7QUFDdEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLGtDQUFrQztBQUNsQyxnQkFBZ0IsMERBQUk7QUFDcEIsZ0JBQWdCLDBEQUFJO0FBQ3BCLGlCQUFpQiwwREFBSTtBQUNyQixpQkFBaUIsMERBQUk7QUFDckIsaUJBQWlCLDBEQUFJO0FBQ3JCLGlCQUFpQiwwREFBSTtBQUNyQixrQkFBa0IsMERBQUk7QUFDdEIsa0JBQWtCLDBEQUFJO0FBQ3RCLGtCQUFrQiwwREFBSTtBQUN0QixnQkFBZ0IsMERBQUk7QUFDcEIsZ0JBQWdCLDBEQUFJO0FBQ3BCLGlCQUFpQiwwREFBSTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMkRBQUsscUNBQXFDLGVBQWU7QUFDN0Qsa0JBQWtCLDZEQUFXO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBLHFCQUFxQix5REFBRztBQUN4QixxQkFBcUIseURBQUc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFNBQVM7QUFDVCxLQUFLO0FBQ0wsQ0FBQyxFQUFFLHdEQUFNO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNERBQU07QUFDM0IsZUFBZSwrREFBVztBQUMxQjtBQUNBO0FBQ0EsV0FBVyw0REFBTSxDQUFDLCtEQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtRUFBZTtBQUN2QyxvQkFBb0IseURBQUc7QUFDdkIsb0JBQW9CLHlEQUFHO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELHNDQUFzQyxhQUFhO0FBQ25EO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0Esd0NBQXdDO0FBQ3hDLHdCQUF3QjtBQUN4QjtBQUNBLHNCQUFzQjtBQUN0QixvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGdFQUFXO0FBQy9ELGNBQWMsK0RBQVc7QUFDekIsWUFBWSx1QkFBdUIsbUNBQW1DO0FBQ3RFLGNBQWMsK0RBQVcsMEJBQTBCO0FBQ25ELDJCQUEyQixtRUFBZSxpQ0FBaUM7QUFDM0Usd0RBQXdEO0FBQ3hELG9CQUFvQixtRUFBZSxTQUFTO0FBQzVDO0FBQ0EsbURBQW1EO0FBQ25ELFlBQVksdUJBQXVCLDJCQUEyQjtBQUM5RCxvQ0FBb0M7QUFDcEMsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrREFBVztBQUMzQixjQUFjLCtEQUFXO0FBQ3pCLGdCQUFnQiwrREFBVztBQUMzQjtBQUNBLHlCQUF5QixtRUFBZSxRQUFRLHdCQUF3QjtBQUN4RSxrQkFBa0IsbUVBQWUsdUJBQXVCLDJCQUEyQjtBQUNuRjtBQUNBO0FBQ0Esa0JBQWtCLG1FQUFlLHdCQUF3Qiw0QkFBNEI7QUFDckY7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RCwyQ0FBMkM7QUFDM0M7QUFDQSwwQkFBMEI7QUFDMUIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLHVCQUF1QjtBQUN2QjtBQUNBLFdBQVc7QUFDWCxLQUFLO0FBQ0wsQ0FBQztBQUNELHNDQUFzQyxzRUFBVTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyw2RUFBbUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG1DQUFtQyx3RUFBWTtBQUMvQyxZQUFZLE9BQU87QUFDbkI7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx3REFBTTtBQUNoQixDQUFDO0FBQ007QUFDQTtBQUNQIiwic291cmNlcyI6WyIvaG9tZS9sZmcvR2l0L01hZHRyaXBzL25vZGVfbW9kdWxlcy9Abm9zdHItZGV2LWtpdC9uZGsvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9zZWNwMjU2azEuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9zaGEyNTYnO1xuaW1wb3J0IHsgcmFuZG9tQnl0ZXMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3V0aWxzJztcbmltcG9ydCB7IEZpZWxkLCBtb2QsIHBvdzIgfSBmcm9tICcuL2Fic3RyYWN0L21vZHVsYXIuanMnO1xuaW1wb3J0IHsgbWFwVG9DdXJ2ZVNpbXBsZVNXVSB9IGZyb20gJy4vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanMnO1xuaW1wb3J0IHsgYnl0ZXNUb051bWJlckJFLCBjb25jYXRCeXRlcywgZW5zdXJlQnl0ZXMsIG51bWJlclRvQnl0ZXNCRSB9IGZyb20gJy4vYWJzdHJhY3QvdXRpbHMuanMnO1xuaW1wb3J0IHsgY3JlYXRlSGFzaGVyLCBpc29nZW55TWFwIH0gZnJvbSAnLi9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzJztcbmltcG9ydCB7IGNyZWF0ZUN1cnZlIH0gZnJvbSAnLi9fc2hvcnR3X3V0aWxzLmpzJztcbmNvbnN0IHNlY3AyNTZrMVAgPSBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmVmZmZmZmMyZicpO1xuY29uc3Qgc2VjcDI1NmsxTiA9IEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWJhYWVkY2U2YWY0OGEwM2JiZmQyNWU4Y2QwMzY0MTQxJyk7XG5jb25zdCBfMW4gPSBCaWdJbnQoMSk7XG5jb25zdCBfMm4gPSBCaWdJbnQoMik7XG5jb25zdCBkaXZOZWFyZXN0ID0gKGEsIGIpID0+IChhICsgYiAvIF8ybikgLyBiO1xuLyoqXG4gKiDiiJpuID0gbl4oKHArMSkvNCkgZm9yIGZpZWxkcyBwID0gMyBtb2QgNC4gV2UgdW53cmFwIHRoZSBsb29wIGFuZCBtdWx0aXBseSBiaXQtYnktYml0LlxuICogKFArMW4vNG4pLnRvU3RyaW5nKDIpIHdvdWxkIHByb2R1Y2UgYml0cyBbMjIzeCAxLCAwLCAyMnggMSwgNHggMCwgMTEsIDAwXVxuICovXG5mdW5jdGlvbiBzcXJ0TW9kKHkpIHtcbiAgICBjb25zdCBQID0gc2VjcDI1NmsxUDtcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBjb25zdCBfM24gPSBCaWdJbnQoMyksIF82biA9IEJpZ0ludCg2KSwgXzExbiA9IEJpZ0ludCgxMSksIF8yMm4gPSBCaWdJbnQoMjIpO1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGNvbnN0IF8yM24gPSBCaWdJbnQoMjMpLCBfNDRuID0gQmlnSW50KDQ0KSwgXzg4biA9IEJpZ0ludCg4OCk7XG4gICAgY29uc3QgYjIgPSAoeSAqIHkgKiB5KSAlIFA7IC8vIHheMywgMTFcbiAgICBjb25zdCBiMyA9IChiMiAqIGIyICogeSkgJSBQOyAvLyB4XjdcbiAgICBjb25zdCBiNiA9IChwb3cyKGIzLCBfM24sIFApICogYjMpICUgUDtcbiAgICBjb25zdCBiOSA9IChwb3cyKGI2LCBfM24sIFApICogYjMpICUgUDtcbiAgICBjb25zdCBiMTEgPSAocG93MihiOSwgXzJuLCBQKSAqIGIyKSAlIFA7XG4gICAgY29uc3QgYjIyID0gKHBvdzIoYjExLCBfMTFuLCBQKSAqIGIxMSkgJSBQO1xuICAgIGNvbnN0IGI0NCA9IChwb3cyKGIyMiwgXzIybiwgUCkgKiBiMjIpICUgUDtcbiAgICBjb25zdCBiODggPSAocG93MihiNDQsIF80NG4sIFApICogYjQ0KSAlIFA7XG4gICAgY29uc3QgYjE3NiA9IChwb3cyKGI4OCwgXzg4biwgUCkgKiBiODgpICUgUDtcbiAgICBjb25zdCBiMjIwID0gKHBvdzIoYjE3NiwgXzQ0biwgUCkgKiBiNDQpICUgUDtcbiAgICBjb25zdCBiMjIzID0gKHBvdzIoYjIyMCwgXzNuLCBQKSAqIGIzKSAlIFA7XG4gICAgY29uc3QgdDEgPSAocG93MihiMjIzLCBfMjNuLCBQKSAqIGIyMikgJSBQO1xuICAgIGNvbnN0IHQyID0gKHBvdzIodDEsIF82biwgUCkgKiBiMikgJSBQO1xuICAgIGNvbnN0IHJvb3QgPSBwb3cyKHQyLCBfMm4sIFApO1xuICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgeSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICByZXR1cm4gcm9vdDtcbn1cbmNvbnN0IEZwID0gRmllbGQoc2VjcDI1NmsxUCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHsgc3FydDogc3FydE1vZCB9KTtcbmV4cG9ydCBjb25zdCBzZWNwMjU2azEgPSBjcmVhdGVDdXJ2ZSh7XG4gICAgYTogQmlnSW50KDApLFxuICAgIGI6IEJpZ0ludCg3KSxcbiAgICBGcCxcbiAgICBuOiBzZWNwMjU2azFOLFxuICAgIC8vIEJhc2UgcG9pbnQgKHgsIHkpIGFrYSBnZW5lcmF0b3IgcG9pbnRcbiAgICBHeDogQmlnSW50KCc1NTA2NjI2MzAyMjI3NzM0MzY2OTU3ODcxODg5NTE2ODUzNDMyNjI1MDYwMzQ1Mzc3NzU5NDE3NTUwMDE4NzM2MDM4OTExNjcyOTI0MCcpLFxuICAgIEd5OiBCaWdJbnQoJzMyNjcwNTEwMDIwNzU4ODE2OTc4MDgzMDg1MTMwNTA3MDQzMTg0NDcxMjczMzgwNjU5MjQzMjc1OTM4OTA0MzM1NzU3MzM3NDgyNDI0JyksXG4gICAgaDogQmlnSW50KDEpLFxuICAgIGxvd1M6IHRydWUsXG4gICAgLyoqXG4gICAgICogc2VjcDI1NmsxIGJlbG9uZ3MgdG8gS29ibGl0eiBjdXJ2ZXM6IGl0IGhhcyBlZmZpY2llbnRseSBjb21wdXRhYmxlIGVuZG9tb3JwaGlzbS5cbiAgICAgKiBFbmRvbW9ycGhpc20gdXNlcyAyeCBsZXNzIFJBTSwgc3BlZWRzIHVwIHByZWNvbXB1dGF0aW9uIGJ5IDJ4IGFuZCBFQ0RIIC8ga2V5IHJlY292ZXJ5IGJ5IDIwJS5cbiAgICAgKiBGb3IgcHJlY29tcHV0ZWQgd05BRiBpdCB0cmFkZXMgb2ZmIDEvMiBpbml0IHRpbWUgJiAxLzMgcmFtIGZvciAyMCUgcGVyZiBoaXQuXG4gICAgICogRXhwbGFuYXRpb246IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3BhdWxtaWxsci9lYjY3MDgwNjc5M2U4NGRmNjI4YTdjNDM0YTg3MzA2NlxuICAgICAqL1xuICAgIGVuZG86IHtcbiAgICAgICAgYmV0YTogQmlnSW50KCcweDdhZTk2YTJiNjU3YzA3MTA2ZTY0NDc5ZWFjMzQzNGU5OWNmMDQ5NzUxMmY1ODk5NWMxMzk2YzI4NzE5NTAxZWUnKSxcbiAgICAgICAgc3BsaXRTY2FsYXI6IChrKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuID0gc2VjcDI1NmsxTjtcbiAgICAgICAgICAgIGNvbnN0IGExID0gQmlnSW50KCcweDMwODZkMjIxYTdkNDZiY2RlODZjOTBlNDkyODRlYjE1Jyk7XG4gICAgICAgICAgICBjb25zdCBiMSA9IC1fMW4gKiBCaWdJbnQoJzB4ZTQ0MzdlZDYwMTBlODgyODZmNTQ3ZmE5MGFiZmU0YzMnKTtcbiAgICAgICAgICAgIGNvbnN0IGEyID0gQmlnSW50KCcweDExNGNhNTBmN2E4ZTJmM2Y2NTdjMTEwOGQ5ZDQ0Y2ZkOCcpO1xuICAgICAgICAgICAgY29uc3QgYjIgPSBhMTtcbiAgICAgICAgICAgIGNvbnN0IFBPV18yXzEyOCA9IEJpZ0ludCgnMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnKTsgLy8gKDJuKioxMjhuKS50b1N0cmluZygxNilcbiAgICAgICAgICAgIGNvbnN0IGMxID0gZGl2TmVhcmVzdChiMiAqIGssIG4pO1xuICAgICAgICAgICAgY29uc3QgYzIgPSBkaXZOZWFyZXN0KC1iMSAqIGssIG4pO1xuICAgICAgICAgICAgbGV0IGsxID0gbW9kKGsgLSBjMSAqIGExIC0gYzIgKiBhMiwgbik7XG4gICAgICAgICAgICBsZXQgazIgPSBtb2QoLWMxICogYjEgLSBjMiAqIGIyLCBuKTtcbiAgICAgICAgICAgIGNvbnN0IGsxbmVnID0gazEgPiBQT1dfMl8xMjg7XG4gICAgICAgICAgICBjb25zdCBrMm5lZyA9IGsyID4gUE9XXzJfMTI4O1xuICAgICAgICAgICAgaWYgKGsxbmVnKVxuICAgICAgICAgICAgICAgIGsxID0gbiAtIGsxO1xuICAgICAgICAgICAgaWYgKGsybmVnKVxuICAgICAgICAgICAgICAgIGsyID0gbiAtIGsyO1xuICAgICAgICAgICAgaWYgKGsxID4gUE9XXzJfMTI4IHx8IGsyID4gUE9XXzJfMTI4KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzcGxpdFNjYWxhcjogRW5kb21vcnBoaXNtIGZhaWxlZCwgaz0nICsgayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBrMW5lZywgazEsIGsybmVnLCBrMiB9O1xuICAgICAgICB9LFxuICAgIH0sXG59LCBzaGEyNTYpO1xuLy8gU2Nobm9yciBzaWduYXR1cmVzIGFyZSBzdXBlcmlvciB0byBFQ0RTQSBmcm9tIGFib3ZlLiBCZWxvdyBpcyBTY2hub3JyLXNwZWNpZmljIEJJUDAzNDAgY29kZS5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpcHMvYmxvYi9tYXN0ZXIvYmlwLTAzNDAubWVkaWF3aWtpXG5jb25zdCBfMG4gPSBCaWdJbnQoMCk7XG5jb25zdCBmZSA9ICh4KSA9PiB0eXBlb2YgeCA9PT0gJ2JpZ2ludCcgJiYgXzBuIDwgeCAmJiB4IDwgc2VjcDI1NmsxUDtcbmNvbnN0IGdlID0gKHgpID0+IHR5cGVvZiB4ID09PSAnYmlnaW50JyAmJiBfMG4gPCB4ICYmIHggPCBzZWNwMjU2azFOO1xuLyoqIEFuIG9iamVjdCBtYXBwaW5nIHRhZ3MgdG8gdGhlaXIgdGFnZ2VkIGhhc2ggcHJlZml4IG9mIFtTSEEyNTYodGFnKSB8IFNIQTI1Nih0YWcpXSAqL1xuY29uc3QgVEFHR0VEX0hBU0hfUFJFRklYRVMgPSB7fTtcbmZ1bmN0aW9uIHRhZ2dlZEhhc2godGFnLCAuLi5tZXNzYWdlcykge1xuICAgIGxldCB0YWdQID0gVEFHR0VEX0hBU0hfUFJFRklYRVNbdGFnXTtcbiAgICBpZiAodGFnUCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHRhZ0ggPSBzaGEyNTYoVWludDhBcnJheS5mcm9tKHRhZywgKGMpID0+IGMuY2hhckNvZGVBdCgwKSkpO1xuICAgICAgICB0YWdQID0gY29uY2F0Qnl0ZXModGFnSCwgdGFnSCk7XG4gICAgICAgIFRBR0dFRF9IQVNIX1BSRUZJWEVTW3RhZ10gPSB0YWdQO1xuICAgIH1cbiAgICByZXR1cm4gc2hhMjU2KGNvbmNhdEJ5dGVzKHRhZ1AsIC4uLm1lc3NhZ2VzKSk7XG59XG4vLyBFQ0RTQSBjb21wYWN0IHBvaW50cyBhcmUgMzMtYnl0ZS4gU2Nobm9yciBpcyAzMjogd2Ugc3RyaXAgZmlyc3QgYnl0ZSAweDAyIG9yIDB4MDNcbmNvbnN0IHBvaW50VG9CeXRlcyA9IChwb2ludCkgPT4gcG9pbnQudG9SYXdCeXRlcyh0cnVlKS5zbGljZSgxKTtcbmNvbnN0IG51bVRvMzJiID0gKG4pID0+IG51bWJlclRvQnl0ZXNCRShuLCAzMik7XG5jb25zdCBtb2RQID0gKHgpID0+IG1vZCh4LCBzZWNwMjU2azFQKTtcbmNvbnN0IG1vZE4gPSAoeCkgPT4gbW9kKHgsIHNlY3AyNTZrMU4pO1xuY29uc3QgUG9pbnQgPSBzZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50O1xuY29uc3QgR211bEFkZCA9IChRLCBhLCBiKSA9PiBQb2ludC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKFEsIGEsIGIpO1xuLy8gQ2FsY3VsYXRlIHBvaW50LCBzY2FsYXIgYW5kIGJ5dGVzXG5mdW5jdGlvbiBzY2hub3JyR2V0RXh0UHViS2V5KHByaXYpIHtcbiAgICBsZXQgZF8gPSBzZWNwMjU2azEudXRpbHMubm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2KTsgLy8gc2FtZSBtZXRob2QgZXhlY3V0ZWQgaW4gZnJvbVByaXZhdGVLZXlcbiAgICBsZXQgcCA9IFBvaW50LmZyb21Qcml2YXRlS2V5KGRfKTsgLy8gUCA9IGQn4ouFRzsgMCA8IGQnIDwgbiBjaGVjayBpcyBkb25lIGluc2lkZVxuICAgIGNvbnN0IHNjYWxhciA9IHAuaGFzRXZlblkoKSA/IGRfIDogbW9kTigtZF8pO1xuICAgIHJldHVybiB7IHNjYWxhcjogc2NhbGFyLCBieXRlczogcG9pbnRUb0J5dGVzKHApIH07XG59XG4vKipcbiAqIGxpZnRfeCBmcm9tIEJJUDM0MC4gQ29udmVydCAzMi1ieXRlIHggY29vcmRpbmF0ZSB0byBlbGxpcHRpYyBjdXJ2ZSBwb2ludC5cbiAqIEByZXR1cm5zIHZhbGlkIHBvaW50IGNoZWNrZWQgZm9yIGJlaW5nIG9uLWN1cnZlXG4gKi9cbmZ1bmN0aW9uIGxpZnRfeCh4KSB7XG4gICAgaWYgKCFmZSh4KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgeDogbmVlZCAwIDwgeCA8IHAnKTsgLy8gRmFpbCBpZiB4IOKJpSBwLlxuICAgIGNvbnN0IHh4ID0gbW9kUCh4ICogeCk7XG4gICAgY29uc3QgYyA9IG1vZFAoeHggKiB4ICsgQmlnSW50KDcpKTsgLy8gTGV0IGMgPSB4wrMgKyA3IG1vZCBwLlxuICAgIGxldCB5ID0gc3FydE1vZChjKTsgLy8gTGV0IHkgPSBjXihwKzEpLzQgbW9kIHAuXG4gICAgaWYgKHkgJSBfMm4gIT09IF8wbilcbiAgICAgICAgeSA9IG1vZFAoLXkpOyAvLyBSZXR1cm4gdGhlIHVuaXF1ZSBwb2ludCBQIHN1Y2ggdGhhdCB4KFApID0geCBhbmRcbiAgICBjb25zdCBwID0gbmV3IFBvaW50KHgsIHksIF8xbik7IC8vIHkoUCkgPSB5IGlmIHkgbW9kIDIgPSAwIG9yIHkoUCkgPSBwLXkgb3RoZXJ3aXNlLlxuICAgIHAuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICByZXR1cm4gcDtcbn1cbi8qKlxuICogQ3JlYXRlIHRhZ2dlZCBoYXNoLCBjb252ZXJ0IGl0IHRvIGJpZ2ludCwgcmVkdWNlIG1vZHVsby1uLlxuICovXG5mdW5jdGlvbiBjaGFsbGVuZ2UoLi4uYXJncykge1xuICAgIHJldHVybiBtb2ROKGJ5dGVzVG9OdW1iZXJCRSh0YWdnZWRIYXNoKCdCSVAwMzQwL2NoYWxsZW5nZScsIC4uLmFyZ3MpKSk7XG59XG4vKipcbiAqIFNjaG5vcnIgcHVibGljIGtleSBpcyBqdXN0IGB4YCBjb29yZGluYXRlIG9mIFBvaW50IGFzIHBlciBCSVAzNDAuXG4gKi9cbmZ1bmN0aW9uIHNjaG5vcnJHZXRQdWJsaWNLZXkocHJpdmF0ZUtleSkge1xuICAgIHJldHVybiBzY2hub3JyR2V0RXh0UHViS2V5KHByaXZhdGVLZXkpLmJ5dGVzOyAvLyBkJz1pbnQoc2spLiBGYWlsIGlmIGQnPTAgb3IgZCfiiaVuLiBSZXQgYnl0ZXMoZCfii4VHKVxufVxuLyoqXG4gKiBDcmVhdGVzIFNjaG5vcnIgc2lnbmF0dXJlIGFzIHBlciBCSVAzNDAuIFZlcmlmaWVzIGl0c2VsZiBiZWZvcmUgcmV0dXJuaW5nIGFueXRoaW5nLlxuICogYXV4UmFuZCBpcyBvcHRpb25hbCBhbmQgaXMgbm90IHRoZSBzb2xlIHNvdXJjZSBvZiBrIGdlbmVyYXRpb246IGJhZCBDU1BSTkcgd29uJ3QgYmUgZGFuZ2Vyb3VzLlxuICovXG5mdW5jdGlvbiBzY2hub3JyU2lnbihtZXNzYWdlLCBwcml2YXRlS2V5LCBhdXhSYW5kID0gcmFuZG9tQnl0ZXMoMzIpKSB7XG4gICAgY29uc3QgbSA9IGVuc3VyZUJ5dGVzKCdtZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgY29uc3QgeyBieXRlczogcHgsIHNjYWxhcjogZCB9ID0gc2Nobm9yckdldEV4dFB1YktleShwcml2YXRlS2V5KTsgLy8gY2hlY2tzIGZvciBpc1dpdGhpbkN1cnZlT3JkZXJcbiAgICBjb25zdCBhID0gZW5zdXJlQnl0ZXMoJ2F1eFJhbmQnLCBhdXhSYW5kLCAzMik7IC8vIEF1eGlsaWFyeSByYW5kb20gZGF0YSBhOiBhIDMyLWJ5dGUgYXJyYXlcbiAgICBjb25zdCB0ID0gbnVtVG8zMmIoZCBeIGJ5dGVzVG9OdW1iZXJCRSh0YWdnZWRIYXNoKCdCSVAwMzQwL2F1eCcsIGEpKSk7IC8vIExldCB0IGJlIHRoZSBieXRlLXdpc2UgeG9yIG9mIGJ5dGVzKGQpIGFuZCBoYXNoL2F1eChhKVxuICAgIGNvbnN0IHJhbmQgPSB0YWdnZWRIYXNoKCdCSVAwMzQwL25vbmNlJywgdCwgcHgsIG0pOyAvLyBMZXQgcmFuZCA9IGhhc2gvbm9uY2UodCB8fCBieXRlcyhQKSB8fCBtKVxuICAgIGNvbnN0IGtfID0gbW9kTihieXRlc1RvTnVtYmVyQkUocmFuZCkpOyAvLyBMZXQgaycgPSBpbnQocmFuZCkgbW9kIG5cbiAgICBpZiAoa18gPT09IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduIGZhaWxlZDogayBpcyB6ZXJvJyk7IC8vIEZhaWwgaWYgaycgPSAwLlxuICAgIGNvbnN0IHsgYnl0ZXM6IHJ4LCBzY2FsYXI6IGsgfSA9IHNjaG5vcnJHZXRFeHRQdWJLZXkoa18pOyAvLyBMZXQgUiA9IGsn4ouFRy5cbiAgICBjb25zdCBlID0gY2hhbGxlbmdlKHJ4LCBweCwgbSk7IC8vIExldCBlID0gaW50KGhhc2gvY2hhbGxlbmdlKGJ5dGVzKFIpIHx8IGJ5dGVzKFApIHx8IG0pKSBtb2Qgbi5cbiAgICBjb25zdCBzaWcgPSBuZXcgVWludDhBcnJheSg2NCk7IC8vIExldCBzaWcgPSBieXRlcyhSKSB8fCBieXRlcygoayArIGVkKSBtb2QgbikuXG4gICAgc2lnLnNldChyeCwgMCk7XG4gICAgc2lnLnNldChudW1UbzMyYihtb2ROKGsgKyBlICogZCkpLCAzMik7XG4gICAgLy8gSWYgVmVyaWZ5KGJ5dGVzKFApLCBtLCBzaWcpIChzZWUgYmVsb3cpIHJldHVybnMgZmFpbHVyZSwgYWJvcnRcbiAgICBpZiAoIXNjaG5vcnJWZXJpZnkoc2lnLCBtLCBweCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbjogSW52YWxpZCBzaWduYXR1cmUgcHJvZHVjZWQnKTtcbiAgICByZXR1cm4gc2lnO1xufVxuLyoqXG4gKiBWZXJpZmllcyBTY2hub3JyIHNpZ25hdHVyZS5cbiAqIFdpbGwgc3dhbGxvdyBlcnJvcnMgJiByZXR1cm4gZmFsc2UgZXhjZXB0IGZvciBpbml0aWFsIHR5cGUgdmFsaWRhdGlvbiBvZiBhcmd1bWVudHMuXG4gKi9cbmZ1bmN0aW9uIHNjaG5vcnJWZXJpZnkoc2lnbmF0dXJlLCBtZXNzYWdlLCBwdWJsaWNLZXkpIHtcbiAgICBjb25zdCBzaWcgPSBlbnN1cmVCeXRlcygnc2lnbmF0dXJlJywgc2lnbmF0dXJlLCA2NCk7XG4gICAgY29uc3QgbSA9IGVuc3VyZUJ5dGVzKCdtZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgY29uc3QgcHViID0gZW5zdXJlQnl0ZXMoJ3B1YmxpY0tleScsIHB1YmxpY0tleSwgMzIpO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IFAgPSBsaWZ0X3goYnl0ZXNUb051bWJlckJFKHB1YikpOyAvLyBQID0gbGlmdF94KGludChwaykpOyBmYWlsIGlmIHRoYXQgZmFpbHNcbiAgICAgICAgY29uc3QgciA9IGJ5dGVzVG9OdW1iZXJCRShzaWcuc3ViYXJyYXkoMCwgMzIpKTsgLy8gTGV0IHIgPSBpbnQoc2lnWzA6MzJdKTsgZmFpbCBpZiByIOKJpSBwLlxuICAgICAgICBpZiAoIWZlKHIpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBzID0gYnl0ZXNUb051bWJlckJFKHNpZy5zdWJhcnJheSgzMiwgNjQpKTsgLy8gTGV0IHMgPSBpbnQoc2lnWzMyOjY0XSk7IGZhaWwgaWYgcyDiiaUgbi5cbiAgICAgICAgaWYgKCFnZShzKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgZSA9IGNoYWxsZW5nZShudW1UbzMyYihyKSwgcG9pbnRUb0J5dGVzKFApLCBtKTsgLy8gaW50KGNoYWxsZW5nZShieXRlcyhyKXx8Ynl0ZXMoUCl8fG0pKSVuXG4gICAgICAgIGNvbnN0IFIgPSBHbXVsQWRkKFAsIHMsIG1vZE4oLWUpKTsgLy8gUiA9IHPii4VHIC0gZeKLhVBcbiAgICAgICAgaWYgKCFSIHx8ICFSLmhhc0V2ZW5ZKCkgfHwgUi50b0FmZmluZSgpLnggIT09IHIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIC1lUCA9PSAobi1lKVBcbiAgICAgICAgcmV0dXJuIHRydWU7IC8vIEZhaWwgaWYgaXNfaW5maW5pdGUoUikgLyBub3QgaGFzX2V2ZW5feShSKSAvIHgoUikg4omgIHIuXG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IHNjaG5vcnIgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+ICh7XG4gICAgZ2V0UHVibGljS2V5OiBzY2hub3JyR2V0UHVibGljS2V5LFxuICAgIHNpZ246IHNjaG5vcnJTaWduLFxuICAgIHZlcmlmeTogc2Nobm9yclZlcmlmeSxcbiAgICB1dGlsczoge1xuICAgICAgICByYW5kb21Qcml2YXRlS2V5OiBzZWNwMjU2azEudXRpbHMucmFuZG9tUHJpdmF0ZUtleSxcbiAgICAgICAgbGlmdF94LFxuICAgICAgICBwb2ludFRvQnl0ZXMsXG4gICAgICAgIG51bWJlclRvQnl0ZXNCRSxcbiAgICAgICAgYnl0ZXNUb051bWJlckJFLFxuICAgICAgICB0YWdnZWRIYXNoLFxuICAgICAgICBtb2QsXG4gICAgfSxcbn0pKSgpO1xuY29uc3QgaXNvTWFwID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBpc29nZW55TWFwKEZwLCBbXG4gICAgLy8geE51bVxuICAgIFtcbiAgICAgICAgJzB4OGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGRhYWFhYThjNycsXG4gICAgICAgICcweDdkM2Q0YzgwYmMzMjFkNWI5ZjMxNWNlYTdmZDQ0YzVkNTk1ZDJmYzBiZjYzYjkyZGZmZjEwNDRmMTdjNjU4MScsXG4gICAgICAgICcweDUzNGMzMjhkMjNmMjM0ZTZlMmE0MTNkZWNhMjVjYWVjZTQ1MDYxNDQwMzdjNDAzMTRlY2JkMGI1M2Q5ZGQyNjInLFxuICAgICAgICAnMHg4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZGFhYWFhODhjJyxcbiAgICBdLFxuICAgIC8vIHhEZW5cbiAgICBbXG4gICAgICAgICcweGQzNTc3MTE5M2Q5NDkxOGE5Y2EzNGNjYmI3YjY0MGRkODZjZDQwOTU0MmY4NDg3ZDlmZTZiNzQ1NzgxZWI0OWInLFxuICAgICAgICAnMHhlZGFkYzZmNjQzODNkYzFkZjdjNGIyZDUxYjU0MjI1NDA2ZDM2YjY0MWY1ZTQxYmJjNTJhNTY2MTJhOGM2ZDE0JyxcbiAgICAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsIC8vIExBU1QgMVxuICAgIF0sXG4gICAgLy8geU51bVxuICAgIFtcbiAgICAgICAgJzB4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGI4ZTM4ZTIzYycsXG4gICAgICAgICcweGM3NWUwYzMyZDVjYjdjMGZhOWQwYTU0YjEyYTBhNmQ1NjQ3YWIwNDZkNjg2ZGE2ZmRmZmM5MGZjMjAxZDcxYTMnLFxuICAgICAgICAnMHgyOWE2MTk0NjkxZjkxYTczNzE1MjA5ZWY2NTEyZTU3NjcyMjgzMGEyMDFiZTIwMThhNzY1ZTg1YTllY2VlOTMxJyxcbiAgICAgICAgJzB4MmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmYzOGUzOGQ4NCcsXG4gICAgXSxcbiAgICAvLyB5RGVuXG4gICAgW1xuICAgICAgICAnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWZmZmZmOTNiJyxcbiAgICAgICAgJzB4N2EwNjUzNGJiOGJkYjQ5ZmQ1ZTllNjYzMjcyMmMyOTg5NDY3YzFiZmM4ZThkOTc4ZGZiNDI1ZDI2ODVjMjU3MycsXG4gICAgICAgICcweDY0ODRhYTcxNjU0NWNhMmNmM2E3MGMzZmE4ZmUzMzdlMGEzZDIxMTYyZjBkNjI5OWE3YmY4MTkyYmZkMmE3NmYnLFxuICAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJywgLy8gTEFTVCAxXG4gICAgXSxcbl0ubWFwKChpKSA9PiBpLm1hcCgoaikgPT4gQmlnSW50KGopKSkpKSgpO1xuY29uc3QgbWFwU1dVID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBtYXBUb0N1cnZlU2ltcGxlU1dVKEZwLCB7XG4gICAgQTogQmlnSW50KCcweDNmODczMWFiZGQ2NjFhZGNhMDhhNTU1OGYwZjVkMjcyZTk1M2QzNjNjYjZmMGU1ZDQwNTQ0N2MwMWE0NDQ1MzMnKSxcbiAgICBCOiBCaWdJbnQoJzE3NzEnKSxcbiAgICBaOiBGcC5jcmVhdGUoQmlnSW50KCctMTEnKSksXG59KSkoKTtcbmNvbnN0IGh0ZiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gY3JlYXRlSGFzaGVyKHNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQsIChzY2FsYXJzKSA9PiB7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBtYXBTV1UoRnAuY3JlYXRlKHNjYWxhcnNbMF0pKTtcbiAgICByZXR1cm4gaXNvTWFwKHgsIHkpO1xufSwge1xuICAgIERTVDogJ3NlY3AyNTZrMV9YTUQ6U0hBLTI1Nl9TU1dVX1JPXycsXG4gICAgZW5jb2RlRFNUOiAnc2VjcDI1NmsxX1hNRDpTSEEtMjU2X1NTV1VfTlVfJyxcbiAgICBwOiBGcC5PUkRFUixcbiAgICBtOiAxLFxuICAgIGs6IDEyOCxcbiAgICBleHBhbmQ6ICd4bWQnLFxuICAgIGhhc2g6IHNoYTI1Nixcbn0pKSgpO1xuZXhwb3J0IGNvbnN0IGhhc2hUb0N1cnZlID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBodGYuaGFzaFRvQ3VydmUpKCk7XG5leHBvcnQgY29uc3QgZW5jb2RlVG9DdXJ2ZSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gaHRmLmVuY29kZVRvQ3VydmUpKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZWNwMjU2azEuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/secp256k1.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js":
/*!***************************************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js ***!
  \***************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bool: () => (/* binding */ bool),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   exists: () => (/* binding */ exists),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   output: () => (/* binding */ output)\n/* harmony export */ });\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`Wrong positive integer: ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`Expected boolean, not ${b}`);\n}\nfunction bytes(b, ...lengths) {\n    if (!(b instanceof Uint8Array))\n        throw new Error('Expected Uint8Array');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(hash) {\n    if (typeof hash !== 'function' || typeof hash.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(hash.outputLen);\n    number(hash.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\n\nconst assert = { number, bool, bytes, hash, exists, output };\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (assert);\n//# sourceMappingURL=_assert.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX2Fzc2VydC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBLG1EQUFtRCxFQUFFO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxFQUFFO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsUUFBUSxrQkFBa0IsU0FBUztBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLElBQUk7QUFDckY7QUFDQTtBQUNxRDtBQUNyRCxpQkFBaUI7QUFDakIsaUVBQWUsTUFBTSxFQUFDO0FBQ3RCIiwic291cmNlcyI6WyIvaG9tZS9sZmcvR2l0L01hZHRyaXBzL25vZGVfbW9kdWxlcy9Abm9zdHItZGV2LWtpdC9uZGsvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fYXNzZXJ0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIG51bWJlcihuKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSB8fCBuIDwgMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXcm9uZyBwb3NpdGl2ZSBpbnRlZ2VyOiAke259YCk7XG59XG5mdW5jdGlvbiBib29sKGIpIHtcbiAgICBpZiAodHlwZW9mIGIgIT09ICdib29sZWFuJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBib29sZWFuLCBub3QgJHtifWApO1xufVxuZnVuY3Rpb24gYnl0ZXMoYiwgLi4ubGVuZ3Rocykge1xuICAgIGlmICghKGIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBVaW50OEFycmF5Jyk7XG4gICAgaWYgKGxlbmd0aHMubGVuZ3RoID4gMCAmJiAhbGVuZ3Rocy5pbmNsdWRlcyhiLmxlbmd0aCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgVWludDhBcnJheSBvZiBsZW5ndGggJHtsZW5ndGhzfSwgbm90IG9mIGxlbmd0aD0ke2IubGVuZ3RofWApO1xufVxuZnVuY3Rpb24gaGFzaChoYXNoKSB7XG4gICAgaWYgKHR5cGVvZiBoYXNoICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBoYXNoLmNyZWF0ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIHNob3VsZCBiZSB3cmFwcGVkIGJ5IHV0aWxzLndyYXBDb25zdHJ1Y3RvcicpO1xuICAgIG51bWJlcihoYXNoLm91dHB1dExlbik7XG4gICAgbnVtYmVyKGhhc2guYmxvY2tMZW4pO1xufVxuZnVuY3Rpb24gZXhpc3RzKGluc3RhbmNlLCBjaGVja0ZpbmlzaGVkID0gdHJ1ZSkge1xuICAgIGlmIChpbnN0YW5jZS5kZXN0cm95ZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWQnKTtcbiAgICBpZiAoY2hlY2tGaW5pc2hlZCAmJiBpbnN0YW5jZS5maW5pc2hlZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoI2RpZ2VzdCgpIGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkJyk7XG59XG5mdW5jdGlvbiBvdXRwdXQob3V0LCBpbnN0YW5jZSkge1xuICAgIGJ5dGVzKG91dCk7XG4gICAgY29uc3QgbWluID0gaW5zdGFuY2Uub3V0cHV0TGVuO1xuICAgIGlmIChvdXQubGVuZ3RoIDwgbWluKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZGlnZXN0SW50bygpIGV4cGVjdHMgb3V0cHV0IGJ1ZmZlciBvZiBsZW5ndGggYXQgbGVhc3QgJHttaW59YCk7XG4gICAgfVxufVxuZXhwb3J0IHsgbnVtYmVyLCBib29sLCBieXRlcywgaGFzaCwgZXhpc3RzLCBvdXRwdXQgfTtcbmNvbnN0IGFzc2VydCA9IHsgbnVtYmVyLCBib29sLCBieXRlcywgaGFzaCwgZXhpc3RzLCBvdXRwdXQgfTtcbmV4cG9ydCBkZWZhdWx0IGFzc2VydDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9hc3NlcnQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/_sha2.js":
/*!*************************************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/_sha2.js ***!
  \*************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHA2: () => (/* binding */ SHA2)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nclass SHA2 extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(this.buffer);\n    }\n    update(data) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        const { view, buffer, blockLen } = this;\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.output)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n//# sourceMappingURL=_sha2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX3NoYTIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQThDO0FBQ1M7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLG1CQUFtQiwyQ0FBSTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFEQUFVO0FBQzlCO0FBQ0E7QUFDQSxRQUFRLGtEQUFNO0FBQ2QsZ0JBQWdCLHlCQUF5QjtBQUN6QyxlQUFlLGtEQUFPO0FBQ3RCO0FBQ0EsMEJBQTBCLFVBQVU7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHFEQUFVO0FBQzNDLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFNO0FBQ2QsUUFBUSxrREFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtCQUErQjtBQUMvQyxjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGNBQWM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFEQUFVO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscURBQXFEO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9sZmcvR2l0L01hZHRyaXBzL25vZGVfbW9kdWxlcy9Abm9zdHItZGV2LWtpdC9uZGsvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fc2hhMi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBleGlzdHMsIG91dHB1dCB9IGZyb20gJy4vX2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBIYXNoLCBjcmVhdGVWaWV3LCB0b0J5dGVzIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBQb2x5ZmlsbCBmb3IgU2FmYXJpIDE0XG5mdW5jdGlvbiBzZXRCaWdVaW50NjQodmlldywgYnl0ZU9mZnNldCwgdmFsdWUsIGlzTEUpIHtcbiAgICBpZiAodHlwZW9mIHZpZXcuc2V0QmlnVWludDY0ID09PSAnZnVuY3Rpb24nKVxuICAgICAgICByZXR1cm4gdmlldy5zZXRCaWdVaW50NjQoYnl0ZU9mZnNldCwgdmFsdWUsIGlzTEUpO1xuICAgIGNvbnN0IF8zMm4gPSBCaWdJbnQoMzIpO1xuICAgIGNvbnN0IF91MzJfbWF4ID0gQmlnSW50KDB4ZmZmZmZmZmYpO1xuICAgIGNvbnN0IHdoID0gTnVtYmVyKCh2YWx1ZSA+PiBfMzJuKSAmIF91MzJfbWF4KTtcbiAgICBjb25zdCB3bCA9IE51bWJlcih2YWx1ZSAmIF91MzJfbWF4KTtcbiAgICBjb25zdCBoID0gaXNMRSA/IDQgOiAwO1xuICAgIGNvbnN0IGwgPSBpc0xFID8gMCA6IDQ7XG4gICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGgsIHdoLCBpc0xFKTtcbiAgICB2aWV3LnNldFVpbnQzMihieXRlT2Zmc2V0ICsgbCwgd2wsIGlzTEUpO1xufVxuLy8gQmFzZSBTSEEyIGNsYXNzIChSRkMgNjIzNClcbmV4cG9ydCBjbGFzcyBTSEEyIGV4dGVuZHMgSGFzaCB7XG4gICAgY29uc3RydWN0b3IoYmxvY2tMZW4sIG91dHB1dExlbiwgcGFkT2Zmc2V0LCBpc0xFKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRoaXMucGFkT2Zmc2V0ID0gcGFkT2Zmc2V0O1xuICAgICAgICB0aGlzLmlzTEUgPSBpc0xFO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGJsb2NrTGVuKTtcbiAgICAgICAgdGhpcy52aWV3ID0gY3JlYXRlVmlldyh0aGlzLmJ1ZmZlcik7XG4gICAgfVxuICAgIHVwZGF0ZShkYXRhKSB7XG4gICAgICAgIGV4aXN0cyh0aGlzKTtcbiAgICAgICAgY29uc3QgeyB2aWV3LCBidWZmZXIsIGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICBkYXRhID0gdG9CeXRlcyhkYXRhKTtcbiAgICAgICAgY29uc3QgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDA7IHBvcyA8IGxlbjspIHtcbiAgICAgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihibG9ja0xlbiAtIHRoaXMucG9zLCBsZW4gLSBwb3MpO1xuICAgICAgICAgICAgLy8gRmFzdCBwYXRoOiB3ZSBoYXZlIGF0IGxlYXN0IG9uZSBibG9jayBpbiBpbnB1dCwgY2FzdCBpdCB0byB2aWV3IGFuZCBwcm9jZXNzXG4gICAgICAgICAgICBpZiAodGFrZSA9PT0gYmxvY2tMZW4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhVmlldyA9IGNyZWF0ZVZpZXcoZGF0YSk7XG4gICAgICAgICAgICAgICAgZm9yICg7IGJsb2NrTGVuIDw9IGxlbiAtIHBvczsgcG9zICs9IGJsb2NrTGVuKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3MoZGF0YVZpZXcsIHBvcyk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXIuc2V0KGRhdGEuc3ViYXJyYXkocG9zLCBwb3MgKyB0YWtlKSwgdGhpcy5wb3MpO1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gdGFrZTtcbiAgICAgICAgICAgIHBvcyArPSB0YWtlO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZW5ndGggKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgIHRoaXMucm91bmRDbGVhbigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgZXhpc3RzKHRoaXMpO1xuICAgICAgICBvdXRwdXQob3V0LCB0aGlzKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIC8vIFBhZGRpbmdcbiAgICAgICAgLy8gV2UgY2FuIGF2b2lkIGFsbG9jYXRpb24gb2YgYnVmZmVyIGZvciBwYWRkaW5nIGNvbXBsZXRlbHkgaWYgaXRcbiAgICAgICAgLy8gd2FzIHByZXZpb3VzbHkgbm90IGFsbG9jYXRlZCBoZXJlLiBCdXQgaXQgd29uJ3QgY2hhbmdlIHBlcmZvcm1hbmNlLlxuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgdmlldywgYmxvY2tMZW4sIGlzTEUgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IHBvcyB9ID0gdGhpcztcbiAgICAgICAgLy8gYXBwZW5kIHRoZSBiaXQgJzEnIHRvIHRoZSBtZXNzYWdlXG4gICAgICAgIGJ1ZmZlcltwb3MrK10gPSAwYjEwMDAwMDAwO1xuICAgICAgICB0aGlzLmJ1ZmZlci5zdWJhcnJheShwb3MpLmZpbGwoMCk7XG4gICAgICAgIC8vIHdlIGhhdmUgbGVzcyB0aGFuIHBhZE9mZnNldCBsZWZ0IGluIGJ1ZmZlciwgc28gd2UgY2Fubm90IHB1dCBsZW5ndGggaW4gY3VycmVudCBibG9jaywgbmVlZCBwcm9jZXNzIGl0IGFuZCBwYWQgYWdhaW5cbiAgICAgICAgaWYgKHRoaXMucGFkT2Zmc2V0ID4gYmxvY2tMZW4gLSBwb3MpIHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgICAgIHBvcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUGFkIHVudGlsIGZ1bGwgYmxvY2sgYnl0ZSB3aXRoIHplcm9zXG4gICAgICAgIGZvciAobGV0IGkgPSBwb3M7IGkgPCBibG9ja0xlbjsgaSsrKVxuICAgICAgICAgICAgYnVmZmVyW2ldID0gMDtcbiAgICAgICAgLy8gTm90ZTogc2hhNTEyIHJlcXVpcmVzIGxlbmd0aCB0byBiZSAxMjhiaXQgaW50ZWdlciwgYnV0IGxlbmd0aCBpbiBKUyB3aWxsIG92ZXJmbG93IGJlZm9yZSB0aGF0XG4gICAgICAgIC8vIFlvdSBuZWVkIHRvIHdyaXRlIGFyb3VuZCAyIGV4YWJ5dGVzICh1NjRfbWF4IC8gOCAvICgxMDI0Kio2KSkgZm9yIHRoaXMgdG8gaGFwcGVuLlxuICAgICAgICAvLyBTbyB3ZSBqdXN0IHdyaXRlIGxvd2VzdCA2NCBiaXRzIG9mIHRoYXQgdmFsdWUuXG4gICAgICAgIHNldEJpZ1VpbnQ2NCh2aWV3LCBibG9ja0xlbiAtIDgsIEJpZ0ludCh0aGlzLmxlbmd0aCAqIDgpLCBpc0xFKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICBjb25zdCBvdmlldyA9IGNyZWF0ZVZpZXcob3V0KTtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5vdXRwdXRMZW47XG4gICAgICAgIC8vIE5PVEU6IHdlIGRvIGRpdmlzaW9uIGJ5IDQgbGF0ZXIsIHdoaWNoIHNob3VsZCBiZSBmdXNlZCBpbiBzaW5nbGUgb3Agd2l0aCBtb2R1bG8gYnkgSklUXG4gICAgICAgIGlmIChsZW4gJSA0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfc2hhMjogb3V0cHV0TGVuIHNob3VsZCBiZSBhbGlnbmVkIHRvIDMyYml0Jyk7XG4gICAgICAgIGNvbnN0IG91dExlbiA9IGxlbiAvIDQ7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXQoKTtcbiAgICAgICAgaWYgKG91dExlbiA+IHN0YXRlLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX3NoYTI6IG91dHB1dExlbiBiaWdnZXIgdGhhbiBzdGF0ZScpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dExlbjsgaSsrKVxuICAgICAgICAgICAgb3ZpZXcuc2V0VWludDMyKDQgKiBpLCBzdGF0ZVtpXSwgaXNMRSk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3QgeyBidWZmZXIsIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5kaWdlc3RJbnRvKGJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IHJlcyA9IGJ1ZmZlci5zbGljZSgwLCBvdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICB0byB8fCAodG8gPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpKTtcbiAgICAgICAgdG8uc2V0KC4uLnRoaXMuZ2V0KCkpO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBidWZmZXIsIGxlbmd0aCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgcG9zIH0gPSB0aGlzO1xuICAgICAgICB0by5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRvLnBvcyA9IHBvcztcbiAgICAgICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gZGVzdHJveWVkO1xuICAgICAgICBpZiAobGVuZ3RoICUgYmxvY2tMZW4pXG4gICAgICAgICAgICB0by5idWZmZXIuc2V0KGJ1ZmZlcik7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fc2hhMi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/_sha2.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/cryptoNode.js":
/*!******************************************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/cryptoNode.js ***!
  \******************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   crypto: () => (/* binding */ crypto)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// See utils.ts for details.\n// The file will throw on node.js 14 and earlier.\n// @ts-ignore\n\nconst crypto = /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) && typeof /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) === 'object' && \"webcrypto\" in /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) ? node_crypto__WEBPACK_IMPORTED_MODULE_0__.webcrypto : undefined;\n//# sourceMappingURL=cryptoNode.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vY3J5cHRvTm9kZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNrQztBQUMzQixlQUFlLDJNQUFFLFdBQVcsMk1BQUUsaUJBQWlCLDBOQUFpQixHQUFHLGtEQUFZO0FBQ3RGIiwic291cmNlcyI6WyIvaG9tZS9sZmcvR2l0L01hZHRyaXBzL25vZGVfbW9kdWxlcy9Abm9zdHItZGV2LWtpdC9uZGsvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9jcnlwdG9Ob2RlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFdlIHVzZSBXZWJDcnlwdG8gYWthIGdsb2JhbFRoaXMuY3J5cHRvLCB3aGljaCBleGlzdHMgaW4gYnJvd3NlcnMgYW5kIG5vZGUuanMgMTYrLlxuLy8gU2VlIHV0aWxzLnRzIGZvciBkZXRhaWxzLlxuLy8gVGhlIGZpbGUgd2lsbCB0aHJvdyBvbiBub2RlLmpzIDE0IGFuZCBlYXJsaWVyLlxuLy8gQHRzLWlnbm9yZVxuaW1wb3J0ICogYXMgbmMgZnJvbSAnbm9kZTpjcnlwdG8nO1xuZXhwb3J0IGNvbnN0IGNyeXB0byA9IG5jICYmIHR5cGVvZiBuYyA9PT0gJ29iamVjdCcgJiYgJ3dlYmNyeXB0bycgaW4gbmMgPyBuYy53ZWJjcnlwdG8gOiB1bmRlZmluZWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcnlwdG9Ob2RlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/cryptoNode.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/hmac.js":
/*!************************************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/hmac.js ***!
  \************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HMAC: () => (/* binding */ HMAC),\n/* harmony export */   hmac: () => (/* binding */ hmac)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// HMAC (RFC 2104)\nclass HMAC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.hash)(hash);\n        const key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.bytes)(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */\nconst hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key) => new HMAC(hash, key);\n//# sourceMappingURL=hmac.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vaG1hYy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWdHO0FBQ3JEO0FBQzNDO0FBQ08sbUJBQW1CLDJDQUFJO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnREFBVTtBQUNsQixvQkFBb0Isa0RBQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBWTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQVk7QUFDcEIsUUFBUSxpREFBVztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRSxnQkFBZ0IseURBQXlEO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbGZnL0dpdC9NYWR0cmlwcy9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vaG1hYy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBoYXNoIGFzIGFzc2VydEhhc2gsIGJ5dGVzIGFzIGFzc2VydEJ5dGVzLCBleGlzdHMgYXMgYXNzZXJ0RXhpc3RzIH0gZnJvbSAnLi9fYXNzZXJ0LmpzJztcbmltcG9ydCB7IEhhc2gsIHRvQnl0ZXMgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIEhNQUMgKFJGQyAyMTA0KVxuZXhwb3J0IGNsYXNzIEhNQUMgZXh0ZW5kcyBIYXNoIHtcbiAgICBjb25zdHJ1Y3RvcihoYXNoLCBfa2V5KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgYXNzZXJ0SGFzaChoYXNoKTtcbiAgICAgICAgY29uc3Qga2V5ID0gdG9CeXRlcyhfa2V5KTtcbiAgICAgICAgdGhpcy5pSGFzaCA9IGhhc2guY3JlYXRlKCk7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5pSGFzaC51cGRhdGUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGluc3RhbmNlIG9mIGNsYXNzIHdoaWNoIGV4dGVuZHMgdXRpbHMuSGFzaCcpO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gdGhpcy5pSGFzaC5ibG9ja0xlbjtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSB0aGlzLmlIYXNoLm91dHB1dExlbjtcbiAgICAgICAgY29uc3QgYmxvY2tMZW4gPSB0aGlzLmJsb2NrTGVuO1xuICAgICAgICBjb25zdCBwYWQgPSBuZXcgVWludDhBcnJheShibG9ja0xlbik7XG4gICAgICAgIC8vIGJsb2NrTGVuIGNhbiBiZSBiaWdnZXIgdGhhbiBvdXRwdXRMZW5cbiAgICAgICAgcGFkLnNldChrZXkubGVuZ3RoID4gYmxvY2tMZW4gPyBoYXNoLmNyZWF0ZSgpLnVwZGF0ZShrZXkpLmRpZ2VzdCgpIDoga2V5KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBwYWRbaV0gXj0gMHgzNjtcbiAgICAgICAgdGhpcy5pSGFzaC51cGRhdGUocGFkKTtcbiAgICAgICAgLy8gQnkgZG9pbmcgdXBkYXRlIChwcm9jZXNzaW5nIG9mIGZpcnN0IGJsb2NrKSBvZiBvdXRlciBoYXNoIGhlcmUgd2UgY2FuIHJlLXVzZSBpdCBiZXR3ZWVuIG11bHRpcGxlIGNhbGxzIHZpYSBjbG9uZVxuICAgICAgICB0aGlzLm9IYXNoID0gaGFzaC5jcmVhdGUoKTtcbiAgICAgICAgLy8gVW5kbyBpbnRlcm5hbCBYT1IgJiYgYXBwbHkgb3V0ZXIgWE9SXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcGFkW2ldIF49IDB4MzYgXiAweDVjO1xuICAgICAgICB0aGlzLm9IYXNoLnVwZGF0ZShwYWQpO1xuICAgICAgICBwYWQuZmlsbCgwKTtcbiAgICB9XG4gICAgdXBkYXRlKGJ1Zikge1xuICAgICAgICBhc3NlcnRFeGlzdHModGhpcyk7XG4gICAgICAgIHRoaXMuaUhhc2gudXBkYXRlKGJ1Zik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBhc3NlcnRFeGlzdHModGhpcyk7XG4gICAgICAgIGFzc2VydEJ5dGVzKG91dCwgdGhpcy5vdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pSGFzaC5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHRoaXMub0hhc2gudXBkYXRlKG91dCk7XG4gICAgICAgIHRoaXMub0hhc2guZGlnZXN0SW50byhvdXQpO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICBjb25zdCBvdXQgPSBuZXcgVWludDhBcnJheSh0aGlzLm9IYXNoLm91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZGlnZXN0SW50byhvdXQpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIC8vIENyZWF0ZSBuZXcgaW5zdGFuY2Ugd2l0aG91dCBjYWxsaW5nIGNvbnN0cnVjdG9yIHNpbmNlIGtleSBhbHJlYWR5IGluIHN0YXRlIGFuZCB3ZSBkb24ndCBrbm93IGl0LlxuICAgICAgICB0byB8fCAodG8gPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSwge30pKTtcbiAgICAgICAgY29uc3QgeyBvSGFzaCwgaUhhc2gsIGZpbmlzaGVkLCBkZXN0cm95ZWQsIGJsb2NrTGVuLCBvdXRwdXRMZW4gfSA9IHRoaXM7XG4gICAgICAgIHRvID0gdG87XG4gICAgICAgIHRvLmZpbmlzaGVkID0gZmluaXNoZWQ7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IGRlc3Ryb3llZDtcbiAgICAgICAgdG8uYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdG8ub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0by5vSGFzaCA9IG9IYXNoLl9jbG9uZUludG8odG8ub0hhc2gpO1xuICAgICAgICB0by5pSGFzaCA9IGlIYXNoLl9jbG9uZUludG8odG8uaUhhc2gpO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vSGFzaC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuaUhhc2guZGVzdHJveSgpO1xuICAgIH1cbn1cbi8qKlxuICogSE1BQzogUkZDMjEwNCBtZXNzYWdlIGF1dGhlbnRpY2F0aW9uIGNvZGUuXG4gKiBAcGFyYW0gaGFzaCAtIGZ1bmN0aW9uIHRoYXQgd291bGQgYmUgdXNlZCBlLmcuIHNoYTI1NlxuICogQHBhcmFtIGtleSAtIG1lc3NhZ2Uga2V5XG4gKiBAcGFyYW0gbWVzc2FnZSAtIG1lc3NhZ2UgZGF0YVxuICovXG5leHBvcnQgY29uc3QgaG1hYyA9IChoYXNoLCBrZXksIG1lc3NhZ2UpID0+IG5ldyBITUFDKGhhc2gsIGtleSkudXBkYXRlKG1lc3NhZ2UpLmRpZ2VzdCgpO1xuaG1hYy5jcmVhdGUgPSAoaGFzaCwga2V5KSA9PiBuZXcgSE1BQyhoYXNoLCBrZXkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aG1hYy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/hmac.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/sha256.js":
/*!**************************************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/sha256.js ***!
  \**************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sha224: () => (/* binding */ sha224),\n/* harmony export */   sha256: () => (/* binding */ sha256)\n/* harmony export */ });\n/* harmony import */ var _sha2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_sha2.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/_sha2.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n// Choice: a ? b : c\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends _sha2_js__WEBPACK_IMPORTED_MODULE_0__.SHA2 {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = IV[0] | 0;\n        this.B = IV[1] | 0;\n        this.C = IV[2] | 0;\n        this.D = IV[3] | 0;\n        this.E = IV[4] | 0;\n        this.F = IV[5] | 0;\n        this.G = IV[6] | 0;\n        this.H = IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 7) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 18) ^ (W15 >>> 3);\n            const s1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 17) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 6) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 11) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 2) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 13) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nconst sha256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA256());\nconst sha224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA224());\n//# sourceMappingURL=sha256.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vc2hhMjU2LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBa0M7QUFDaUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDBDQUFJO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseUJBQXlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBLHVCQUF1QiwrQ0FBSSxXQUFXLCtDQUFJO0FBQzFDLHVCQUF1QiwrQ0FBSSxXQUFXLCtDQUFJO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLGNBQWMseUJBQXlCO0FBQ3ZDLHdCQUF3QixRQUFRO0FBQ2hDLDJCQUEyQiwrQ0FBSSxTQUFTLCtDQUFJLFVBQVUsK0NBQUk7QUFDMUQ7QUFDQSwyQkFBMkIsK0NBQUksU0FBUywrQ0FBSSxVQUFVLCtDQUFJO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLCtCQUErQiwwREFBZTtBQUM5QywrQkFBK0IsMERBQWU7QUFDckQiLCJzb3VyY2VzIjpbIi9ob21lL2xmZy9HaXQvTWFkdHJpcHMvbm9kZV9tb2R1bGVzL0Bub3N0ci1kZXYta2l0L25kay9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTI1Ni5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTSEEyIH0gZnJvbSAnLi9fc2hhMi5qcyc7XG5pbXBvcnQgeyByb3RyLCB3cmFwQ29uc3RydWN0b3IgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIFNIQTItMjU2IG5lZWQgdG8gdHJ5IDJeMTI4IGhhc2hlcyB0byBleGVjdXRlIGJpcnRoZGF5IGF0dGFjay5cbi8vIEJUQyBuZXR3b3JrIGlzIGRvaW5nIDJeNjcgaGFzaGVzL3NlYyBhcyBwZXIgZWFybHkgMjAyMy5cbi8vIENob2ljZTogYSA/IGIgOiBjXG5jb25zdCBDaGkgPSAoYSwgYiwgYykgPT4gKGEgJiBiKSBeICh+YSAmIGMpO1xuLy8gTWFqb3JpdHkgZnVuY3Rpb24sIHRydWUgaWYgYW55IHR3byBpbnB1c3QgaXMgdHJ1ZVxuY29uc3QgTWFqID0gKGEsIGIsIGMpID0+IChhICYgYikgXiAoYSAmIGMpIF4gKGIgJiBjKTtcbi8vIFJvdW5kIGNvbnN0YW50czpcbi8vIGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIGN1YmUgcm9vdHMgb2YgdGhlIGZpcnN0IDY0IHByaW1lcyAyLi4zMTEpXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IFNIQTI1Nl9LID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheShbXG4gICAgMHg0MjhhMmY5OCwgMHg3MTM3NDQ5MSwgMHhiNWMwZmJjZiwgMHhlOWI1ZGJhNSwgMHgzOTU2YzI1YiwgMHg1OWYxMTFmMSwgMHg5MjNmODJhNCwgMHhhYjFjNWVkNSxcbiAgICAweGQ4MDdhYTk4LCAweDEyODM1YjAxLCAweDI0MzE4NWJlLCAweDU1MGM3ZGMzLCAweDcyYmU1ZDc0LCAweDgwZGViMWZlLCAweDliZGMwNmE3LCAweGMxOWJmMTc0LFxuICAgIDB4ZTQ5YjY5YzEsIDB4ZWZiZTQ3ODYsIDB4MGZjMTlkYzYsIDB4MjQwY2ExY2MsIDB4MmRlOTJjNmYsIDB4NGE3NDg0YWEsIDB4NWNiMGE5ZGMsIDB4NzZmOTg4ZGEsXG4gICAgMHg5ODNlNTE1MiwgMHhhODMxYzY2ZCwgMHhiMDAzMjdjOCwgMHhiZjU5N2ZjNywgMHhjNmUwMGJmMywgMHhkNWE3OTE0NywgMHgwNmNhNjM1MSwgMHgxNDI5Mjk2NyxcbiAgICAweDI3YjcwYTg1LCAweDJlMWIyMTM4LCAweDRkMmM2ZGZjLCAweDUzMzgwZDEzLCAweDY1MGE3MzU0LCAweDc2NmEwYWJiLCAweDgxYzJjOTJlLCAweDkyNzIyYzg1LFxuICAgIDB4YTJiZmU4YTEsIDB4YTgxYTY2NGIsIDB4YzI0YjhiNzAsIDB4Yzc2YzUxYTMsIDB4ZDE5MmU4MTksIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsXG4gICAgMHgxOWE0YzExNiwgMHgxZTM3NmMwOCwgMHgyNzQ4Nzc0YywgMHgzNGIwYmNiNSwgMHgzOTFjMGNiMywgMHg0ZWQ4YWE0YSwgMHg1YjljY2E0ZiwgMHg2ODJlNmZmMyxcbiAgICAweDc0OGY4MmVlLCAweDc4YTU2MzZmLCAweDg0Yzg3ODE0LCAweDhjYzcwMjA4LCAweDkwYmVmZmZhLCAweGE0NTA2Y2ViLCAweGJlZjlhM2Y3LCAweGM2NzE3OGYyXG5dKTtcbi8vIEluaXRpYWwgc3RhdGUgKGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIHNxdWFyZSByb290cyBvZiB0aGUgZmlyc3QgOCBwcmltZXMgMi4uMTkpOlxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBJViA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoW1xuICAgIDB4NmEwOWU2NjcsIDB4YmI2N2FlODUsIDB4M2M2ZWYzNzIsIDB4YTU0ZmY1M2EsIDB4NTEwZTUyN2YsIDB4OWIwNTY4OGMsIDB4MWY4M2Q5YWIsIDB4NWJlMGNkMTlcbl0pO1xuLy8gVGVtcG9yYXJ5IGJ1ZmZlciwgbm90IHVzZWQgdG8gc3RvcmUgYW55dGhpbmcgYmV0d2VlbiBydW5zXG4vLyBOYW1lZCB0aGlzIHdheSBiZWNhdXNlIGl0IG1hdGNoZXMgc3BlY2lmaWNhdGlvbi5cbmNvbnN0IFNIQTI1Nl9XID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheSg2NCk7XG5jbGFzcyBTSEEyNTYgZXh0ZW5kcyBTSEEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoNjQsIDMyLCA4LCBmYWxzZSk7XG4gICAgICAgIC8vIFdlIGNhbm5vdCB1c2UgYXJyYXkgaGVyZSBzaW5jZSBhcnJheSBhbGxvd3MgaW5kZXhpbmcgYnkgdmFyaWFibGVcbiAgICAgICAgLy8gd2hpY2ggbWVhbnMgb3B0aW1pemVyL2NvbXBpbGVyIGNhbm5vdCB1c2UgcmVnaXN0ZXJzLlxuICAgICAgICB0aGlzLkEgPSBJVlswXSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IElWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5DID0gSVZbMl0gfCAwO1xuICAgICAgICB0aGlzLkQgPSBJVlszXSB8IDA7XG4gICAgICAgIHRoaXMuRSA9IElWWzRdIHwgMDtcbiAgICAgICAgdGhpcy5GID0gSVZbNV0gfCAwO1xuICAgICAgICB0aGlzLkcgPSBJVls2XSB8IDA7XG4gICAgICAgIHRoaXMuSCA9IElWWzddIHwgMDtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbQSwgQiwgQywgRCwgRSwgRiwgRywgSF07XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIHNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKSB7XG4gICAgICAgIHRoaXMuQSA9IEEgfCAwO1xuICAgICAgICB0aGlzLkIgPSBCIHwgMDtcbiAgICAgICAgdGhpcy5DID0gQyB8IDA7XG4gICAgICAgIHRoaXMuRCA9IEQgfCAwO1xuICAgICAgICB0aGlzLkUgPSBFIHwgMDtcbiAgICAgICAgdGhpcy5GID0gRiB8IDA7XG4gICAgICAgIHRoaXMuRyA9IEcgfCAwO1xuICAgICAgICB0aGlzLkggPSBIIHwgMDtcbiAgICB9XG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgLy8gRXh0ZW5kIHRoZSBmaXJzdCAxNiB3b3JkcyBpbnRvIHRoZSByZW1haW5pbmcgNDggd29yZHMgd1sxNi4uNjNdIG9mIHRoZSBtZXNzYWdlIHNjaGVkdWxlIGFycmF5XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpXG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCwgZmFsc2UpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA2NDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBXMTUgPSBTSEEyNTZfV1tpIC0gMTVdO1xuICAgICAgICAgICAgY29uc3QgVzIgPSBTSEEyNTZfV1tpIC0gMl07XG4gICAgICAgICAgICBjb25zdCBzMCA9IHJvdHIoVzE1LCA3KSBeIHJvdHIoVzE1LCAxOCkgXiAoVzE1ID4+PiAzKTtcbiAgICAgICAgICAgIGNvbnN0IHMxID0gcm90cihXMiwgMTcpIF4gcm90cihXMiwgMTkpIF4gKFcyID4+PiAxMCk7XG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IChzMSArIFNIQTI1Nl9XW2kgLSA3XSArIHMwICsgU0hBMjU2X1dbaSAtIDE2XSkgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXByZXNzaW9uIGZ1bmN0aW9uIG1haW4gbG9vcCwgNjQgcm91bmRzXG4gICAgICAgIGxldCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc2lnbWExID0gcm90cihFLCA2KSBeIHJvdHIoRSwgMTEpIF4gcm90cihFLCAyNSk7XG4gICAgICAgICAgICBjb25zdCBUMSA9IChIICsgc2lnbWExICsgQ2hpKEUsIEYsIEcpICsgU0hBMjU2X0tbaV0gKyBTSEEyNTZfV1tpXSkgfCAwO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWEwID0gcm90cihBLCAyKSBeIHJvdHIoQSwgMTMpIF4gcm90cihBLCAyMik7XG4gICAgICAgICAgICBjb25zdCBUMiA9IChzaWdtYTAgKyBNYWooQSwgQiwgQykpIHwgMDtcbiAgICAgICAgICAgIEggPSBHO1xuICAgICAgICAgICAgRyA9IEY7XG4gICAgICAgICAgICBGID0gRTtcbiAgICAgICAgICAgIEUgPSAoRCArIFQxKSB8IDA7XG4gICAgICAgICAgICBEID0gQztcbiAgICAgICAgICAgIEMgPSBCO1xuICAgICAgICAgICAgQiA9IEE7XG4gICAgICAgICAgICBBID0gKFQxICsgVDIpIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICBBID0gKEEgKyB0aGlzLkEpIHwgMDtcbiAgICAgICAgQiA9IChCICsgdGhpcy5CKSB8IDA7XG4gICAgICAgIEMgPSAoQyArIHRoaXMuQykgfCAwO1xuICAgICAgICBEID0gKEQgKyB0aGlzLkQpIHwgMDtcbiAgICAgICAgRSA9IChFICsgdGhpcy5FKSB8IDA7XG4gICAgICAgIEYgPSAoRiArIHRoaXMuRikgfCAwO1xuICAgICAgICBHID0gKEcgKyB0aGlzLkcpIHwgMDtcbiAgICAgICAgSCA9IChIICsgdGhpcy5IKSB8IDA7XG4gICAgICAgIHRoaXMuc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpO1xuICAgIH1cbiAgICByb3VuZENsZWFuKCkge1xuICAgICAgICBTSEEyNTZfVy5maWxsKDApO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICAgICAgdGhpcy5idWZmZXIuZmlsbCgwKTtcbiAgICB9XG59XG4vLyBDb25zdGFudHMgZnJvbSBodHRwczovL252bHB1YnMubmlzdC5nb3YvbmlzdHB1YnMvRklQUy9OSVNULkZJUFMuMTgwLTQucGRmXG5jbGFzcyBTSEEyMjQgZXh0ZW5kcyBTSEEyNTYge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLkEgPSAweGMxMDU5ZWQ4IHwgMDtcbiAgICAgICAgdGhpcy5CID0gMHgzNjdjZDUwNyB8IDA7XG4gICAgICAgIHRoaXMuQyA9IDB4MzA3MGRkMTcgfCAwO1xuICAgICAgICB0aGlzLkQgPSAweGY3MGU1OTM5IHwgMDtcbiAgICAgICAgdGhpcy5FID0gMHhmZmMwMGIzMSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IDB4Njg1ODE1MTEgfCAwO1xuICAgICAgICB0aGlzLkcgPSAweDY0Zjk4ZmE3IHwgMDtcbiAgICAgICAgdGhpcy5IID0gMHhiZWZhNGZhNCB8IDA7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gMjg7XG4gICAgfVxufVxuLyoqXG4gKiBTSEEyLTI1NiBoYXNoIGZ1bmN0aW9uXG4gKiBAcGFyYW0gbWVzc2FnZSAtIGRhdGEgdGhhdCB3b3VsZCBiZSBoYXNoZWRcbiAqL1xuZXhwb3J0IGNvbnN0IHNoYTI1NiA9IC8qIEBfX1BVUkVfXyAqLyB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTI1NigpKTtcbmV4cG9ydCBjb25zdCBzaGEyMjQgPSAvKiBAX19QVVJFX18gKi8gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBTSEEyMjQoKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGEyNTYuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/sha256.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js":
/*!*************************************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js ***!
  \*************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hash: () => (/* binding */ Hash),\n/* harmony export */   asyncLoop: () => (/* binding */ asyncLoop),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   checkOpts: () => (/* binding */ checkOpts),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createView: () => (/* binding */ createView),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   isLE: () => (/* binding */ isLE),\n/* harmony export */   nextTick: () => (/* binding */ nextTick),\n/* harmony export */   randomBytes: () => (/* binding */ randomBytes),\n/* harmony export */   rotr: () => (/* binding */ rotr),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   u32: () => (/* binding */ u32),\n/* harmony export */   u8: () => (/* binding */ u8),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   wrapConstructor: () => (/* binding */ wrapConstructor),\n/* harmony export */   wrapConstructorWithOpts: () => (/* binding */ wrapConstructorWithOpts),\n/* harmony export */   wrapXOFConstructorWithOpts: () => (/* binding */ wrapXOFConstructorWithOpts)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/crypto */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/cryptoNode.js\");\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated, we can just drop the import.\n\nconst u8a = (a) => a instanceof Uint8Array;\n// Cast array to different type\nconst u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nconst u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nconst createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\nconst isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE)\n    throw new Error('Non little-endian hardware is not supported');\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    if (!u8a(bytes))\n        throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const len = hex.length;\n    if (len % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n    const array = new Uint8Array(len / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    if (!u8a(data))\n        throw new Error(`expected Uint8Array, got ${typeof data}`);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n    let pad = 0; // walk through each item, ensure they have proper type\n    arrays.forEach((a) => {\n        if (!u8a(a))\n            throw new Error('Uint8Array expected');\n        r.set(a, pad);\n        pad += a.length;\n    });\n    return r;\n}\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nconst toStr = {}.toString;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nfunction wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nfunction randomBytes(bytesLength = 32) {\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues === 'function') {\n        return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzhDO0FBQzlDO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsMkNBQTJDLGFBQWE7QUFDeEQ7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsNERBQTRELFdBQVc7QUFDdkUsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFlBQVk7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDVDtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxRQUFRLHdEQUFNLFdBQVcsd0RBQU07QUFDL0IsZUFBZSx3REFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbGZnL0dpdC9NYWR0cmlwcy9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vdXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWhhc2hlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gV2UgdXNlIFdlYkNyeXB0byBha2EgZ2xvYmFsVGhpcy5jcnlwdG8sIHdoaWNoIGV4aXN0cyBpbiBicm93c2VycyBhbmQgbm9kZS5qcyAxNisuXG4vLyBub2RlLmpzIHZlcnNpb25zIGVhcmxpZXIgdGhhbiB2MTkgZG9uJ3QgZGVjbGFyZSBpdCBpbiBnbG9iYWwgc2NvcGUuXG4vLyBGb3Igbm9kZS5qcywgcGFja2FnZS5qc29uI2V4cG9ydHMgZmllbGQgbWFwcGluZyByZXdyaXRlcyBpbXBvcnRcbi8vIGZyb20gYGNyeXB0b2AgdG8gYGNyeXB0b05vZGVgLCB3aGljaCBpbXBvcnRzIG5hdGl2ZSBtb2R1bGUuXG4vLyBNYWtlcyB0aGUgdXRpbHMgdW4taW1wb3J0YWJsZSBpbiBicm93c2VycyB3aXRob3V0IGEgYnVuZGxlci5cbi8vIE9uY2Ugbm9kZS5qcyAxOCBpcyBkZXByZWNhdGVkLCB3ZSBjYW4ganVzdCBkcm9wIHRoZSBpbXBvcnQuXG5pbXBvcnQgeyBjcnlwdG8gfSBmcm9tICdAbm9ibGUvaGFzaGVzL2NyeXB0byc7XG5jb25zdCB1OGEgPSAoYSkgPT4gYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XG4vLyBDYXN0IGFycmF5IHRvIGRpZmZlcmVudCB0eXBlXG5leHBvcnQgY29uc3QgdTggPSAoYXJyKSA9PiBuZXcgVWludDhBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xuZXhwb3J0IGNvbnN0IHUzMiA9IChhcnIpID0+IG5ldyBVaW50MzJBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgTWF0aC5mbG9vcihhcnIuYnl0ZUxlbmd0aCAvIDQpKTtcbi8vIENhc3QgYXJyYXkgdG8gdmlld1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVZpZXcgPSAoYXJyKSA9PiBuZXcgRGF0YVZpZXcoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbi8vIFRoZSByb3RhdGUgcmlnaHQgKGNpcmN1bGFyIHJpZ2h0IHNoaWZ0KSBvcGVyYXRpb24gZm9yIHVpbnQzMlxuZXhwb3J0IGNvbnN0IHJvdHIgPSAod29yZCwgc2hpZnQpID0+ICh3b3JkIDw8ICgzMiAtIHNoaWZ0KSkgfCAod29yZCA+Pj4gc2hpZnQpO1xuLy8gYmlnLWVuZGlhbiBoYXJkd2FyZSBpcyByYXJlLiBKdXN0IGluIGNhc2Ugc29tZW9uZSBzdGlsbCBkZWNpZGVzIHRvIHJ1biBoYXNoZXM6XG4vLyBlYXJseS10aHJvdyBhbiBlcnJvciBiZWNhdXNlIHdlIGRvbid0IHN1cHBvcnQgQkUgeWV0LlxuZXhwb3J0IGNvbnN0IGlzTEUgPSBuZXcgVWludDhBcnJheShuZXcgVWludDMyQXJyYXkoWzB4MTEyMjMzNDRdKS5idWZmZXIpWzBdID09PSAweDQ0O1xuaWYgKCFpc0xFKVxuICAgIHRocm93IG5ldyBFcnJvcignTm9uIGxpdHRsZS1lbmRpYW4gaGFyZHdhcmUgaXMgbm90IHN1cHBvcnRlZCcpO1xuY29uc3QgaGV4ZXMgPSAvKiBAX19QVVJFX18gKi8gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sIChfLCBpKSA9PiBpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbi8qKlxuICogQGV4YW1wbGUgYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKSkgLy8gJ2NhZmUwMTIzJ1xuICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuICAgIGlmICghdThhKGJ5dGVzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgLy8gcHJlLWNhY2hpbmcgaW1wcm92ZXMgdGhlIHNwZWVkIDZ4XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IGhleGVzW2J5dGVzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbi8qKlxuICogQGV4YW1wbGUgaGV4VG9CeXRlcygnY2FmZTAxMjMnKSAvLyBVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGV4VG9CeXRlcyhoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICBjb25zdCBsZW4gPSBoZXgubGVuZ3RoO1xuICAgIGlmIChsZW4gJSAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRlZCBoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgdW5wYWRkZWQgaGV4IG9mIGxlbmd0aCAnICsgbGVuKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGxlbiAvIDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaiA9IGkgKiAyO1xuICAgICAgICBjb25zdCBoZXhCeXRlID0gaGV4LnNsaWNlKGosIGogKyAyKTtcbiAgICAgICAgY29uc3QgYnl0ZSA9IE51bWJlci5wYXJzZUludChoZXhCeXRlLCAxNik7XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4oYnl0ZSkgfHwgYnl0ZSA8IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYnl0ZSBzZXF1ZW5jZScpO1xuICAgICAgICBhcnJheVtpXSA9IGJ5dGU7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbi8vIFRoZXJlIGlzIG5vIHNldEltbWVkaWF0ZSBpbiBicm93c2VyIGFuZCBzZXRUaW1lb3V0IGlzIHNsb3cuXG4vLyBjYWxsIG9mIGFzeW5jIGZuIHdpbGwgcmV0dXJuIFByb21pc2UsIHdoaWNoIHdpbGwgYmUgZnVsbGZpbGVkIG9ubHkgb25cbi8vIG5leHQgc2NoZWR1bGVyIHF1ZXVlIHByb2Nlc3Npbmcgc3RlcCBhbmQgdGhpcyBpcyBleGFjdGx5IHdoYXQgd2UgbmVlZC5cbmV4cG9ydCBjb25zdCBuZXh0VGljayA9IGFzeW5jICgpID0+IHsgfTtcbi8vIFJldHVybnMgY29udHJvbCB0byB0aHJlYWQgZWFjaCAndGljaycgbXMgdG8gYXZvaWQgYmxvY2tpbmdcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhc3luY0xvb3AoaXRlcnMsIHRpY2ssIGNiKSB7XG4gICAgbGV0IHRzID0gRGF0ZS5ub3coKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJzOyBpKyspIHtcbiAgICAgICAgY2IoaSk7XG4gICAgICAgIC8vIERhdGUubm93KCkgaXMgbm90IG1vbm90b25pYywgc28gaW4gY2FzZSBpZiBjbG9jayBnb2VzIGJhY2t3YXJkcyB3ZSByZXR1cm4gcmV0dXJuIGNvbnRyb2wgdG9vXG4gICAgICAgIGNvbnN0IGRpZmYgPSBEYXRlLm5vdygpIC0gdHM7XG4gICAgICAgIGlmIChkaWZmID49IDAgJiYgZGlmZiA8IHRpY2spXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgYXdhaXQgbmV4dFRpY2soKTtcbiAgICAgICAgdHMgKz0gZGlmZjtcbiAgICB9XG59XG4vKipcbiAqIEBleGFtcGxlIHV0ZjhUb0J5dGVzKCdhYmMnKSAvLyBuZXcgVWludDhBcnJheShbOTcsIDk4LCA5OV0pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdXRmOFRvQnl0ZXMgZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygc3RyfWApO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSk7IC8vIGh0dHBzOi8vYnVnemlsLmxhLzE2ODE4MDlcbn1cbi8qKlxuICogTm9ybWFsaXplcyAobm9uLWhleCkgc3RyaW5nIG9yIFVpbnQ4QXJyYXkgdG8gVWludDhBcnJheS5cbiAqIFdhcm5pbmc6IHdoZW4gVWludDhBcnJheSBpcyBwYXNzZWQsIGl0IHdvdWxkIE5PVCBnZXQgY29waWVkLlxuICogS2VlcCBpbiBtaW5kIGZvciBmdXR1cmUgbXV0YWJsZSBvcGVyYXRpb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9CeXRlcyhkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJylcbiAgICAgICAgZGF0YSA9IHV0ZjhUb0J5dGVzKGRhdGEpO1xuICAgIGlmICghdThhKGRhdGEpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkIFVpbnQ4QXJyYXksIGdvdCAke3R5cGVvZiBkYXRhfWApO1xuICAgIHJldHVybiBkYXRhO1xufVxuLyoqXG4gKiBDb3BpZXMgc2V2ZXJhbCBVaW50OEFycmF5cyBpbnRvIG9uZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5cykge1xuICAgIGNvbnN0IHIgPSBuZXcgVWludDhBcnJheShhcnJheXMucmVkdWNlKChzdW0sIGEpID0+IHN1bSArIGEubGVuZ3RoLCAwKSk7XG4gICAgbGV0IHBhZCA9IDA7IC8vIHdhbGsgdGhyb3VnaCBlYWNoIGl0ZW0sIGVuc3VyZSB0aGV5IGhhdmUgcHJvcGVyIHR5cGVcbiAgICBhcnJheXMuZm9yRWFjaCgoYSkgPT4ge1xuICAgICAgICBpZiAoIXU4YShhKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgICAgICByLnNldChhLCBwYWQpO1xuICAgICAgICBwYWQgKz0gYS5sZW5ndGg7XG4gICAgfSk7XG4gICAgcmV0dXJuIHI7XG59XG4vLyBGb3IgcnVudGltZSBjaGVjayBpZiBjbGFzcyBpbXBsZW1lbnRzIGludGVyZmFjZVxuZXhwb3J0IGNsYXNzIEhhc2gge1xuICAgIC8vIFNhZmUgdmVyc2lvbiB0aGF0IGNsb25lcyBpbnRlcm5hbCBzdGF0ZVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvbmVJbnRvKCk7XG4gICAgfVxufVxuY29uc3QgdG9TdHIgPSB7fS50b1N0cmluZztcbmV4cG9ydCBmdW5jdGlvbiBjaGVja09wdHMoZGVmYXVsdHMsIG9wdHMpIHtcbiAgICBpZiAob3B0cyAhPT0gdW5kZWZpbmVkICYmIHRvU3RyLmNhbGwob3B0cykgIT09ICdbb2JqZWN0IE9iamVjdF0nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09wdGlvbnMgc2hvdWxkIGJlIG9iamVjdCBvciB1bmRlZmluZWQnKTtcbiAgICBjb25zdCBtZXJnZWQgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRzLCBvcHRzKTtcbiAgICByZXR1cm4gbWVyZ2VkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBDb25zdHJ1Y3RvcihoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZykgPT4gaGFzaENvbnMoKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucygpO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKCkgPT4gaGFzaENvbnMoKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnQgZnVuY3Rpb24gd3JhcENvbnN0cnVjdG9yV2l0aE9wdHMoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIG9wdHMpID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKHt9KTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9IChvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnQgZnVuY3Rpb24gd3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIG9wdHMpID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKHt9KTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9IChvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG4vKipcbiAqIFNlY3VyZSBQUk5HLiBVc2VzIGBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzYCwgd2hpY2ggZGVmZXJzIHRvIE9TLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tQnl0ZXMoYnl0ZXNMZW5ndGggPSAzMikge1xuICAgIGlmIChjcnlwdG8gJiYgdHlwZW9mIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoYnl0ZXNMZW5ndGgpKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIG11c3QgYmUgZGVmaW5lZCcpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/_assert.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/_assert.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bool: () => (/* binding */ bool),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   exists: () => (/* binding */ exists),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   output: () => (/* binding */ output)\n/* harmony export */ });\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`Wrong positive integer: ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`Expected boolean, not ${b}`);\n}\nfunction bytes(b, ...lengths) {\n    if (!(b instanceof Uint8Array))\n        throw new Error('Expected Uint8Array');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(hash) {\n    if (typeof hash !== 'function' || typeof hash.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(hash.outputLen);\n    number(hash.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\nconst assert = {\n    number,\n    bool,\n    bytes,\n    hash,\n    exists,\n    output,\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (assert);\n//# sourceMappingURL=_assert.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX2Fzc2VydC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQU87QUFDUDtBQUNBLG1EQUFtRCxFQUFFO0FBQ3JEO0FBQ087QUFDUDtBQUNBLGlEQUFpRCxFQUFFO0FBQ25EO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsUUFBUSxrQkFBa0IsU0FBUztBQUM1RjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLElBQUk7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBZSxNQUFNLEVBQUM7QUFDdEIiLCJzb3VyY2VzIjpbIi9ob21lL2xmZy9HaXQvTWFkdHJpcHMvbm9kZV9tb2R1bGVzL0Bub3N0ci1kZXYta2l0L25kay9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19hc3NlcnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIG51bWJlcihuKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSB8fCBuIDwgMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXcm9uZyBwb3NpdGl2ZSBpbnRlZ2VyOiAke259YCk7XG59XG5leHBvcnQgZnVuY3Rpb24gYm9vbChiKSB7XG4gICAgaWYgKHR5cGVvZiBiICE9PSAnYm9vbGVhbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYm9vbGVhbiwgbm90ICR7Yn1gKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBieXRlcyhiLCAuLi5sZW5ndGhzKSB7XG4gICAgaWYgKCEoYiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIFVpbnQ4QXJyYXknKTtcbiAgICBpZiAobGVuZ3Rocy5sZW5ndGggPiAwICYmICFsZW5ndGhzLmluY2x1ZGVzKGIubGVuZ3RoKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBVaW50OEFycmF5IG9mIGxlbmd0aCAke2xlbmd0aHN9LCBub3Qgb2YgbGVuZ3RoPSR7Yi5sZW5ndGh9YCk7XG59XG5leHBvcnQgZnVuY3Rpb24gaGFzaChoYXNoKSB7XG4gICAgaWYgKHR5cGVvZiBoYXNoICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBoYXNoLmNyZWF0ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIHNob3VsZCBiZSB3cmFwcGVkIGJ5IHV0aWxzLndyYXBDb25zdHJ1Y3RvcicpO1xuICAgIG51bWJlcihoYXNoLm91dHB1dExlbik7XG4gICAgbnVtYmVyKGhhc2guYmxvY2tMZW4pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGV4aXN0cyhpbnN0YW5jZSwgY2hlY2tGaW5pc2hlZCA9IHRydWUpIHtcbiAgICBpZiAoaW5zdGFuY2UuZGVzdHJveWVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkJyk7XG4gICAgaWYgKGNoZWNrRmluaXNoZWQgJiYgaW5zdGFuY2UuZmluaXNoZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCNkaWdlc3QoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZCcpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG91dHB1dChvdXQsIGluc3RhbmNlKSB7XG4gICAgYnl0ZXMob3V0KTtcbiAgICBjb25zdCBtaW4gPSBpbnN0YW5jZS5vdXRwdXRMZW47XG4gICAgaWYgKG91dC5sZW5ndGggPCBtaW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkaWdlc3RJbnRvKCkgZXhwZWN0cyBvdXRwdXQgYnVmZmVyIG9mIGxlbmd0aCBhdCBsZWFzdCAke21pbn1gKTtcbiAgICB9XG59XG5jb25zdCBhc3NlcnQgPSB7XG4gICAgbnVtYmVyLFxuICAgIGJvb2wsXG4gICAgYnl0ZXMsXG4gICAgaGFzaCxcbiAgICBleGlzdHMsXG4gICAgb3V0cHV0LFxufTtcbmV4cG9ydCBkZWZhdWx0IGFzc2VydDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9hc3NlcnQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/_assert.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/_sha2.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/_sha2.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHA2: () => (/* binding */ SHA2)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nclass SHA2 extends _utils_js__WEBPACK_IMPORTED_MODULE_1__.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createView)(this.buffer);\n    }\n    update(data) {\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].exists(this);\n        const { view, buffer, blockLen } = this;\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createView)(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].exists(this);\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].output(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n//# sourceMappingURL=_sha2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX3NoYTIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWtDO0FBQ3FCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxtQkFBbUIsMkNBQUk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxREFBVTtBQUM5QjtBQUNBO0FBQ0EsUUFBUSx5REFBYTtBQUNyQixnQkFBZ0IseUJBQXlCO0FBQ3pDLGVBQWUsa0RBQU87QUFDdEI7QUFDQSwwQkFBMEIsVUFBVTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMscURBQVU7QUFDM0MsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEseURBQWE7QUFDckIsUUFBUSx5REFBYTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQkFBK0I7QUFDL0MsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxREFBVTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFEQUFxRDtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbGZnL0dpdC9NYWR0cmlwcy9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX3NoYTIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGFzc2VydCBmcm9tICcuL19hc3NlcnQuanMnO1xuaW1wb3J0IHsgSGFzaCwgY3JlYXRlVmlldywgdG9CeXRlcyB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gUG9seWZpbGwgZm9yIFNhZmFyaSAxNFxuZnVuY3Rpb24gc2V0QmlnVWludDY0KHZpZXcsIGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKSB7XG4gICAgaWYgKHR5cGVvZiB2aWV3LnNldEJpZ1VpbnQ2NCA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgcmV0dXJuIHZpZXcuc2V0QmlnVWludDY0KGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKTtcbiAgICBjb25zdCBfMzJuID0gQmlnSW50KDMyKTtcbiAgICBjb25zdCBfdTMyX21heCA9IEJpZ0ludCgweGZmZmZmZmZmKTtcbiAgICBjb25zdCB3aCA9IE51bWJlcigodmFsdWUgPj4gXzMybikgJiBfdTMyX21heCk7XG4gICAgY29uc3Qgd2wgPSBOdW1iZXIodmFsdWUgJiBfdTMyX21heCk7XG4gICAgY29uc3QgaCA9IGlzTEUgPyA0IDogMDtcbiAgICBjb25zdCBsID0gaXNMRSA/IDAgOiA0O1xuICAgIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBoLCB3aCwgaXNMRSk7XG4gICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGwsIHdsLCBpc0xFKTtcbn1cbi8vIEJhc2UgU0hBMiBjbGFzcyAoUkZDIDYyMzQpXG5leHBvcnQgY2xhc3MgU0hBMiBleHRlbmRzIEhhc2gge1xuICAgIGNvbnN0cnVjdG9yKGJsb2NrTGVuLCBvdXRwdXRMZW4sIHBhZE9mZnNldCwgaXNMRSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0aGlzLnBhZE9mZnNldCA9IHBhZE9mZnNldDtcbiAgICAgICAgdGhpcy5pc0xFID0gaXNMRTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgVWludDhBcnJheShibG9ja0xlbik7XG4gICAgICAgIHRoaXMudmlldyA9IGNyZWF0ZVZpZXcodGhpcy5idWZmZXIpO1xuICAgIH1cbiAgICB1cGRhdGUoZGF0YSkge1xuICAgICAgICBhc3NlcnQuZXhpc3RzKHRoaXMpO1xuICAgICAgICBjb25zdCB7IHZpZXcsIGJ1ZmZlciwgYmxvY2tMZW4gfSA9IHRoaXM7XG4gICAgICAgIGRhdGEgPSB0b0J5dGVzKGRhdGEpO1xuICAgICAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3MsIGxlbiAtIHBvcyk7XG4gICAgICAgICAgICAvLyBGYXN0IHBhdGg6IHdlIGhhdmUgYXQgbGVhc3Qgb25lIGJsb2NrIGluIGlucHV0LCBjYXN0IGl0IHRvIHZpZXcgYW5kIHByb2Nlc3NcbiAgICAgICAgICAgIGlmICh0YWtlID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFWaWV3ID0gY3JlYXRlVmlldyhkYXRhKTtcbiAgICAgICAgICAgICAgICBmb3IgKDsgYmxvY2tMZW4gPD0gbGVuIC0gcG9zOyBwb3MgKz0gYmxvY2tMZW4pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2VzcyhkYXRhVmlldywgcG9zKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlci5zZXQoZGF0YS5zdWJhcnJheShwb3MsIHBvcyArIHRha2UpLCB0aGlzLnBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSB0YWtlO1xuICAgICAgICAgICAgcG9zICs9IHRha2U7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxlbmd0aCArPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgdGhpcy5yb3VuZENsZWFuKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBhc3NlcnQuZXhpc3RzKHRoaXMpO1xuICAgICAgICBhc3NlcnQub3V0cHV0KG91dCwgdGhpcyk7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAvLyBQYWRkaW5nXG4gICAgICAgIC8vIFdlIGNhbiBhdm9pZCBhbGxvY2F0aW9uIG9mIGJ1ZmZlciBmb3IgcGFkZGluZyBjb21wbGV0ZWx5IGlmIGl0XG4gICAgICAgIC8vIHdhcyBwcmV2aW91c2x5IG5vdCBhbGxvY2F0ZWQgaGVyZS4gQnV0IGl0IHdvbid0IGNoYW5nZSBwZXJmb3JtYW5jZS5cbiAgICAgICAgY29uc3QgeyBidWZmZXIsIHZpZXcsIGJsb2NrTGVuLCBpc0xFIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBwb3MgfSA9IHRoaXM7XG4gICAgICAgIC8vIGFwcGVuZCB0aGUgYml0ICcxJyB0byB0aGUgbWVzc2FnZVxuICAgICAgICBidWZmZXJbcG9zKytdID0gMGIxMDAwMDAwMDtcbiAgICAgICAgdGhpcy5idWZmZXIuc3ViYXJyYXkocG9zKS5maWxsKDApO1xuICAgICAgICAvLyB3ZSBoYXZlIGxlc3MgdGhhbiBwYWRPZmZzZXQgbGVmdCBpbiBidWZmZXIsIHNvIHdlIGNhbm5vdCBwdXQgbGVuZ3RoIGluIGN1cnJlbnQgYmxvY2ssIG5lZWQgcHJvY2VzcyBpdCBhbmQgcGFkIGFnYWluXG4gICAgICAgIGlmICh0aGlzLnBhZE9mZnNldCA+IGJsb2NrTGVuIC0gcG9zKSB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgICAgICBwb3MgPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBhZCB1bnRpbCBmdWxsIGJsb2NrIGJ5dGUgd2l0aCB6ZXJvc1xuICAgICAgICBmb3IgKGxldCBpID0gcG9zOyBpIDwgYmxvY2tMZW47IGkrKylcbiAgICAgICAgICAgIGJ1ZmZlcltpXSA9IDA7XG4gICAgICAgIC8vIE5vdGU6IHNoYTUxMiByZXF1aXJlcyBsZW5ndGggdG8gYmUgMTI4Yml0IGludGVnZXIsIGJ1dCBsZW5ndGggaW4gSlMgd2lsbCBvdmVyZmxvdyBiZWZvcmUgdGhhdFxuICAgICAgICAvLyBZb3UgbmVlZCB0byB3cml0ZSBhcm91bmQgMiBleGFieXRlcyAodTY0X21heCAvIDggLyAoMTAyNCoqNikpIGZvciB0aGlzIHRvIGhhcHBlbi5cbiAgICAgICAgLy8gU28gd2UganVzdCB3cml0ZSBsb3dlc3QgNjQgYml0cyBvZiB0aGF0IHZhbHVlLlxuICAgICAgICBzZXRCaWdVaW50NjQodmlldywgYmxvY2tMZW4gLSA4LCBCaWdJbnQodGhpcy5sZW5ndGggKiA4KSwgaXNMRSk7XG4gICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgY29uc3Qgb3ZpZXcgPSBjcmVhdGVWaWV3KG91dCk7XG4gICAgICAgIGNvbnN0IGxlbiA9IHRoaXMub3V0cHV0TGVuO1xuICAgICAgICAvLyBOT1RFOiB3ZSBkbyBkaXZpc2lvbiBieSA0IGxhdGVyLCB3aGljaCBzaG91bGQgYmUgZnVzZWQgaW4gc2luZ2xlIG9wIHdpdGggbW9kdWxvIGJ5IEpJVFxuICAgICAgICBpZiAobGVuICUgNClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX3NoYTI6IG91dHB1dExlbiBzaG91bGQgYmUgYWxpZ25lZCB0byAzMmJpdCcpO1xuICAgICAgICBjb25zdCBvdXRMZW4gPSBsZW4gLyA0O1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0KCk7XG4gICAgICAgIGlmIChvdXRMZW4gPiBzdGF0ZS5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ19zaGEyOiBvdXRwdXRMZW4gYmlnZ2VyIHRoYW4gc3RhdGUnKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRMZW47IGkrKylcbiAgICAgICAgICAgIG92aWV3LnNldFVpbnQzMig0ICogaSwgc3RhdGVbaV0sIGlzTEUpO1xuICAgIH1cbiAgICBkaWdlc3QoKSB7XG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCBvdXRwdXRMZW4gfSA9IHRoaXM7XG4gICAgICAgIHRoaXMuZGlnZXN0SW50byhidWZmZXIpO1xuICAgICAgICBjb25zdCByZXMgPSBidWZmZXIuc2xpY2UoMCwgb3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIF9jbG9uZUludG8odG8pIHtcbiAgICAgICAgdG8gfHwgKHRvID0gbmV3IHRoaXMuY29uc3RydWN0b3IoKSk7XG4gICAgICAgIHRvLnNldCguLi50aGlzLmdldCgpKTtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiwgYnVmZmVyLCBsZW5ndGgsIGZpbmlzaGVkLCBkZXN0cm95ZWQsIHBvcyB9ID0gdGhpcztcbiAgICAgICAgdG8ubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0by5wb3MgPSBwb3M7XG4gICAgICAgIHRvLmZpbmlzaGVkID0gZmluaXNoZWQ7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IGRlc3Ryb3llZDtcbiAgICAgICAgaWYgKGxlbmd0aCAlIGJsb2NrTGVuKVxuICAgICAgICAgICAgdG8uYnVmZmVyLnNldChidWZmZXIpO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3NoYTIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/_sha2.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/cryptoNode.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/cryptoNode.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   crypto: () => (/* binding */ crypto)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// See utils.ts for details.\n// The file will throw on node.js 14 and earlier.\n// @ts-ignore\n\nconst crypto = /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) && typeof /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) === 'object' && \"webcrypto\" in /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) ? node_crypto__WEBPACK_IMPORTED_MODULE_0__.webcrypto : undefined;\n//# sourceMappingURL=cryptoNode.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vY3J5cHRvTm9kZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNrQztBQUMzQixlQUFlLDJNQUFFLFdBQVcsMk1BQUUsaUJBQWlCLDBOQUFpQixHQUFHLGtEQUFZO0FBQ3RGIiwic291cmNlcyI6WyIvaG9tZS9sZmcvR2l0L01hZHRyaXBzL25vZGVfbW9kdWxlcy9Abm9zdHItZGV2LWtpdC9uZGsvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9jcnlwdG9Ob2RlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFdlIHVzZSBXZWJDcnlwdG8gYWthIGdsb2JhbFRoaXMuY3J5cHRvLCB3aGljaCBleGlzdHMgaW4gYnJvd3NlcnMgYW5kIG5vZGUuanMgMTYrLlxuLy8gU2VlIHV0aWxzLnRzIGZvciBkZXRhaWxzLlxuLy8gVGhlIGZpbGUgd2lsbCB0aHJvdyBvbiBub2RlLmpzIDE0IGFuZCBlYXJsaWVyLlxuLy8gQHRzLWlnbm9yZVxuaW1wb3J0ICogYXMgbmMgZnJvbSAnbm9kZTpjcnlwdG8nO1xuZXhwb3J0IGNvbnN0IGNyeXB0byA9IG5jICYmIHR5cGVvZiBuYyA9PT0gJ29iamVjdCcgJiYgJ3dlYmNyeXB0bycgaW4gbmMgPyBuYy53ZWJjcnlwdG8gOiB1bmRlZmluZWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcnlwdG9Ob2RlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/cryptoNode.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/hkdf.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/hkdf.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   expand: () => (/* binding */ expand),\n/* harmony export */   extract: () => (/* binding */ extract),\n/* harmony export */   hkdf: () => (/* binding */ hkdf)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _hmac_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./hmac.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/hmac.js\");\n\n\n\n// HKDF (RFC 5869)\n// https://soatok.blog/2021/11/17/understanding-hkdf/\n/**\n * HKDF-Extract(IKM, salt) -> PRK\n * Arguments position differs from spec (IKM is first one, since it is not optional)\n * @param hash\n * @param ikm\n * @param salt\n * @returns\n */\nfunction extract(hash, ikm, salt) {\n    _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].hash(hash);\n    // NOTE: some libraries treat zero-length array as 'not provided';\n    // we don't, since we have undefined as 'not provided'\n    // https://github.com/RustCrypto/KDFs/issues/15\n    if (salt === undefined)\n        salt = new Uint8Array(hash.outputLen); // if not provided, it is set to a string of HashLen zeros\n    return (0,_hmac_js__WEBPACK_IMPORTED_MODULE_2__.hmac)(hash, (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(salt), (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(ikm));\n}\n// HKDF-Expand(PRK, info, L) -> OKM\nconst HKDF_COUNTER = new Uint8Array([0]);\nconst EMPTY_BUFFER = new Uint8Array();\n/**\n * HKDF-expand from the spec.\n * @param prk - a pseudorandom key of at least HashLen octets (usually, the output from the extract step)\n * @param info - optional context and application specific information (can be a zero-length string)\n * @param length - length of output keying material in octets\n */\nfunction expand(hash, prk, info, length = 32) {\n    _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].hash(hash);\n    _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].number(length);\n    if (length > 255 * hash.outputLen)\n        throw new Error('Length should be <= 255*HashLen');\n    const blocks = Math.ceil(length / hash.outputLen);\n    if (info === undefined)\n        info = EMPTY_BUFFER;\n    // first L(ength) octets of T\n    const okm = new Uint8Array(blocks * hash.outputLen);\n    // Re-use HMAC instance between blocks\n    const HMAC = _hmac_js__WEBPACK_IMPORTED_MODULE_2__.hmac.create(hash, prk);\n    const HMACTmp = HMAC._cloneInto();\n    const T = new Uint8Array(HMAC.outputLen);\n    for (let counter = 0; counter < blocks; counter++) {\n        HKDF_COUNTER[0] = counter + 1;\n        // T(0) = empty string (zero length)\n        // T(N) = HMAC-Hash(PRK, T(N-1) | info | N)\n        HMACTmp.update(counter === 0 ? EMPTY_BUFFER : T)\n            .update(info)\n            .update(HKDF_COUNTER)\n            .digestInto(T);\n        okm.set(T, hash.outputLen * counter);\n        HMAC._cloneInto(HMACTmp);\n    }\n    HMAC.destroy();\n    HMACTmp.destroy();\n    T.fill(0);\n    HKDF_COUNTER.fill(0);\n    return okm.slice(0, length);\n}\n/**\n * HKDF (RFC 5869): extract + expand in one step.\n * @param hash - hash function that would be used (e.g. sha256)\n * @param ikm - input keying material, the initial key\n * @param salt - optional salt value (a non-secret random value)\n * @param info - optional context and application specific information\n * @param length - length of output keying material in octets\n */\nconst hkdf = (hash, ikm, salt, info, length) => expand(hash, extract(hash, ikm, salt), info, length);\n//# sourceMappingURL=hkdf.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vaGtkZi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBa0M7QUFDRztBQUNKO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxJQUFJLHVEQUFXO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0MsV0FBVyw4Q0FBSSxPQUFPLGtEQUFPLFFBQVEsa0RBQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLElBQUksdURBQVc7QUFDZixJQUFJLHlEQUFhO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMENBQUk7QUFDckI7QUFDQTtBQUNBLDBCQUEwQixrQkFBa0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCIsInNvdXJjZXMiOlsiL2hvbWUvbGZnL0dpdC9NYWR0cmlwcy9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vaGtkZi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYXNzZXJ0IGZyb20gJy4vX2Fzc2VydC5qcyc7XG5pbXBvcnQgeyB0b0J5dGVzIH0gZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgeyBobWFjIH0gZnJvbSAnLi9obWFjLmpzJztcbi8vIEhLREYgKFJGQyA1ODY5KVxuLy8gaHR0cHM6Ly9zb2F0b2suYmxvZy8yMDIxLzExLzE3L3VuZGVyc3RhbmRpbmctaGtkZi9cbi8qKlxuICogSEtERi1FeHRyYWN0KElLTSwgc2FsdCkgLT4gUFJLXG4gKiBBcmd1bWVudHMgcG9zaXRpb24gZGlmZmVycyBmcm9tIHNwZWMgKElLTSBpcyBmaXJzdCBvbmUsIHNpbmNlIGl0IGlzIG5vdCBvcHRpb25hbClcbiAqIEBwYXJhbSBoYXNoXG4gKiBAcGFyYW0gaWttXG4gKiBAcGFyYW0gc2FsdFxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3QoaGFzaCwgaWttLCBzYWx0KSB7XG4gICAgYXNzZXJ0Lmhhc2goaGFzaCk7XG4gICAgLy8gTk9URTogc29tZSBsaWJyYXJpZXMgdHJlYXQgemVyby1sZW5ndGggYXJyYXkgYXMgJ25vdCBwcm92aWRlZCc7XG4gICAgLy8gd2UgZG9uJ3QsIHNpbmNlIHdlIGhhdmUgdW5kZWZpbmVkIGFzICdub3QgcHJvdmlkZWQnXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL1J1c3RDcnlwdG8vS0RGcy9pc3N1ZXMvMTVcbiAgICBpZiAoc2FsdCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICBzYWx0ID0gbmV3IFVpbnQ4QXJyYXkoaGFzaC5vdXRwdXRMZW4pOyAvLyBpZiBub3QgcHJvdmlkZWQsIGl0IGlzIHNldCB0byBhIHN0cmluZyBvZiBIYXNoTGVuIHplcm9zXG4gICAgcmV0dXJuIGhtYWMoaGFzaCwgdG9CeXRlcyhzYWx0KSwgdG9CeXRlcyhpa20pKTtcbn1cbi8vIEhLREYtRXhwYW5kKFBSSywgaW5mbywgTCkgLT4gT0tNXG5jb25zdCBIS0RGX0NPVU5URVIgPSBuZXcgVWludDhBcnJheShbMF0pO1xuY29uc3QgRU1QVFlfQlVGRkVSID0gbmV3IFVpbnQ4QXJyYXkoKTtcbi8qKlxuICogSEtERi1leHBhbmQgZnJvbSB0aGUgc3BlYy5cbiAqIEBwYXJhbSBwcmsgLSBhIHBzZXVkb3JhbmRvbSBrZXkgb2YgYXQgbGVhc3QgSGFzaExlbiBvY3RldHMgKHVzdWFsbHksIHRoZSBvdXRwdXQgZnJvbSB0aGUgZXh0cmFjdCBzdGVwKVxuICogQHBhcmFtIGluZm8gLSBvcHRpb25hbCBjb250ZXh0IGFuZCBhcHBsaWNhdGlvbiBzcGVjaWZpYyBpbmZvcm1hdGlvbiAoY2FuIGJlIGEgemVyby1sZW5ndGggc3RyaW5nKVxuICogQHBhcmFtIGxlbmd0aCAtIGxlbmd0aCBvZiBvdXRwdXQga2V5aW5nIG1hdGVyaWFsIGluIG9jdGV0c1xuICovXG5leHBvcnQgZnVuY3Rpb24gZXhwYW5kKGhhc2gsIHByaywgaW5mbywgbGVuZ3RoID0gMzIpIHtcbiAgICBhc3NlcnQuaGFzaChoYXNoKTtcbiAgICBhc3NlcnQubnVtYmVyKGxlbmd0aCk7XG4gICAgaWYgKGxlbmd0aCA+IDI1NSAqIGhhc2gub3V0cHV0TGVuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xlbmd0aCBzaG91bGQgYmUgPD0gMjU1Kkhhc2hMZW4nKTtcbiAgICBjb25zdCBibG9ja3MgPSBNYXRoLmNlaWwobGVuZ3RoIC8gaGFzaC5vdXRwdXRMZW4pO1xuICAgIGlmIChpbmZvID09PSB1bmRlZmluZWQpXG4gICAgICAgIGluZm8gPSBFTVBUWV9CVUZGRVI7XG4gICAgLy8gZmlyc3QgTChlbmd0aCkgb2N0ZXRzIG9mIFRcbiAgICBjb25zdCBva20gPSBuZXcgVWludDhBcnJheShibG9ja3MgKiBoYXNoLm91dHB1dExlbik7XG4gICAgLy8gUmUtdXNlIEhNQUMgaW5zdGFuY2UgYmV0d2VlbiBibG9ja3NcbiAgICBjb25zdCBITUFDID0gaG1hYy5jcmVhdGUoaGFzaCwgcHJrKTtcbiAgICBjb25zdCBITUFDVG1wID0gSE1BQy5fY2xvbmVJbnRvKCk7XG4gICAgY29uc3QgVCA9IG5ldyBVaW50OEFycmF5KEhNQUMub3V0cHV0TGVuKTtcbiAgICBmb3IgKGxldCBjb3VudGVyID0gMDsgY291bnRlciA8IGJsb2NrczsgY291bnRlcisrKSB7XG4gICAgICAgIEhLREZfQ09VTlRFUlswXSA9IGNvdW50ZXIgKyAxO1xuICAgICAgICAvLyBUKDApID0gZW1wdHkgc3RyaW5nICh6ZXJvIGxlbmd0aClcbiAgICAgICAgLy8gVChOKSA9IEhNQUMtSGFzaChQUkssIFQoTi0xKSB8IGluZm8gfCBOKVxuICAgICAgICBITUFDVG1wLnVwZGF0ZShjb3VudGVyID09PSAwID8gRU1QVFlfQlVGRkVSIDogVClcbiAgICAgICAgICAgIC51cGRhdGUoaW5mbylcbiAgICAgICAgICAgIC51cGRhdGUoSEtERl9DT1VOVEVSKVxuICAgICAgICAgICAgLmRpZ2VzdEludG8oVCk7XG4gICAgICAgIG9rbS5zZXQoVCwgaGFzaC5vdXRwdXRMZW4gKiBjb3VudGVyKTtcbiAgICAgICAgSE1BQy5fY2xvbmVJbnRvKEhNQUNUbXApO1xuICAgIH1cbiAgICBITUFDLmRlc3Ryb3koKTtcbiAgICBITUFDVG1wLmRlc3Ryb3koKTtcbiAgICBULmZpbGwoMCk7XG4gICAgSEtERl9DT1VOVEVSLmZpbGwoMCk7XG4gICAgcmV0dXJuIG9rbS5zbGljZSgwLCBsZW5ndGgpO1xufVxuLyoqXG4gKiBIS0RGIChSRkMgNTg2OSk6IGV4dHJhY3QgKyBleHBhbmQgaW4gb25lIHN0ZXAuXG4gKiBAcGFyYW0gaGFzaCAtIGhhc2ggZnVuY3Rpb24gdGhhdCB3b3VsZCBiZSB1c2VkIChlLmcuIHNoYTI1NilcbiAqIEBwYXJhbSBpa20gLSBpbnB1dCBrZXlpbmcgbWF0ZXJpYWwsIHRoZSBpbml0aWFsIGtleVxuICogQHBhcmFtIHNhbHQgLSBvcHRpb25hbCBzYWx0IHZhbHVlIChhIG5vbi1zZWNyZXQgcmFuZG9tIHZhbHVlKVxuICogQHBhcmFtIGluZm8gLSBvcHRpb25hbCBjb250ZXh0IGFuZCBhcHBsaWNhdGlvbiBzcGVjaWZpYyBpbmZvcm1hdGlvblxuICogQHBhcmFtIGxlbmd0aCAtIGxlbmd0aCBvZiBvdXRwdXQga2V5aW5nIG1hdGVyaWFsIGluIG9jdGV0c1xuICovXG5leHBvcnQgY29uc3QgaGtkZiA9IChoYXNoLCBpa20sIHNhbHQsIGluZm8sIGxlbmd0aCkgPT4gZXhwYW5kKGhhc2gsIGV4dHJhY3QoaGFzaCwgaWttLCBzYWx0KSwgaW5mbywgbGVuZ3RoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhrZGYuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/hkdf.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/hmac.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/hmac.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HMAC: () => (/* binding */ HMAC),\n/* harmony export */   hmac: () => (/* binding */ hmac)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// HMAC (RFC 2104)\nclass HMAC extends _utils_js__WEBPACK_IMPORTED_MODULE_1__.Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].hash(hash);\n        const key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].exists(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].exists(this);\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].bytes(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */\nconst hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key) => new HMAC(hash, key);\n//# sourceMappingURL=hmac.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vaG1hYy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWtDO0FBQ1M7QUFDM0M7QUFDTyxtQkFBbUIsMkNBQUk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFXO0FBQ25CLG9CQUFvQixrREFBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlEQUFhO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx5REFBYTtBQUNyQixRQUFRLHdEQUFZO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFLGdCQUFnQix5REFBeUQ7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9sZmcvR2l0L01hZHRyaXBzL25vZGVfbW9kdWxlcy9Abm9zdHItZGV2LWtpdC9uZGsvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9obWFjLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBhc3NlcnQgZnJvbSAnLi9fYXNzZXJ0LmpzJztcbmltcG9ydCB7IEhhc2gsIHRvQnl0ZXMgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIEhNQUMgKFJGQyAyMTA0KVxuZXhwb3J0IGNsYXNzIEhNQUMgZXh0ZW5kcyBIYXNoIHtcbiAgICBjb25zdHJ1Y3RvcihoYXNoLCBfa2V5KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgYXNzZXJ0Lmhhc2goaGFzaCk7XG4gICAgICAgIGNvbnN0IGtleSA9IHRvQnl0ZXMoX2tleSk7XG4gICAgICAgIHRoaXMuaUhhc2ggPSBoYXNoLmNyZWF0ZSgpO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuaUhhc2gudXBkYXRlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBpbnN0YW5jZSBvZiBjbGFzcyB3aGljaCBleHRlbmRzIHV0aWxzLkhhc2gnKTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IHRoaXMuaUhhc2guYmxvY2tMZW47XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gdGhpcy5pSGFzaC5vdXRwdXRMZW47XG4gICAgICAgIGNvbnN0IGJsb2NrTGVuID0gdGhpcy5ibG9ja0xlbjtcbiAgICAgICAgY29uc3QgcGFkID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tMZW4pO1xuICAgICAgICAvLyBibG9ja0xlbiBjYW4gYmUgYmlnZ2VyIHRoYW4gb3V0cHV0TGVuXG4gICAgICAgIHBhZC5zZXQoa2V5Lmxlbmd0aCA+IGJsb2NrTGVuID8gaGFzaC5jcmVhdGUoKS51cGRhdGUoa2V5KS5kaWdlc3QoKSA6IGtleSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcGFkW2ldIF49IDB4MzY7XG4gICAgICAgIHRoaXMuaUhhc2gudXBkYXRlKHBhZCk7XG4gICAgICAgIC8vIEJ5IGRvaW5nIHVwZGF0ZSAocHJvY2Vzc2luZyBvZiBmaXJzdCBibG9jaykgb2Ygb3V0ZXIgaGFzaCBoZXJlIHdlIGNhbiByZS11c2UgaXQgYmV0d2VlbiBtdWx0aXBsZSBjYWxscyB2aWEgY2xvbmVcbiAgICAgICAgdGhpcy5vSGFzaCA9IGhhc2guY3JlYXRlKCk7XG4gICAgICAgIC8vIFVuZG8gaW50ZXJuYWwgWE9SICYmIGFwcGx5IG91dGVyIFhPUlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHBhZFtpXSBePSAweDM2IF4gMHg1YztcbiAgICAgICAgdGhpcy5vSGFzaC51cGRhdGUocGFkKTtcbiAgICAgICAgcGFkLmZpbGwoMCk7XG4gICAgfVxuICAgIHVwZGF0ZShidWYpIHtcbiAgICAgICAgYXNzZXJ0LmV4aXN0cyh0aGlzKTtcbiAgICAgICAgdGhpcy5pSGFzaC51cGRhdGUoYnVmKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgIGFzc2VydC5leGlzdHModGhpcyk7XG4gICAgICAgIGFzc2VydC5ieXRlcyhvdXQsIHRoaXMub3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuaUhhc2guZGlnZXN0SW50byhvdXQpO1xuICAgICAgICB0aGlzLm9IYXNoLnVwZGF0ZShvdXQpO1xuICAgICAgICB0aGlzLm9IYXNoLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3Qgb3V0ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5vSGFzaC5vdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICAvLyBDcmVhdGUgbmV3IGluc3RhbmNlIHdpdGhvdXQgY2FsbGluZyBjb25zdHJ1Y3RvciBzaW5jZSBrZXkgYWxyZWFkeSBpbiBzdGF0ZSBhbmQgd2UgZG9uJ3Qga25vdyBpdC5cbiAgICAgICAgdG8gfHwgKHRvID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyksIHt9KSk7XG4gICAgICAgIGNvbnN0IHsgb0hhc2gsIGlIYXNoLCBmaW5pc2hlZCwgZGVzdHJveWVkLCBibG9ja0xlbiwgb3V0cHV0TGVuIH0gPSB0aGlzO1xuICAgICAgICB0byA9IHRvO1xuICAgICAgICB0by5maW5pc2hlZCA9IGZpbmlzaGVkO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSBkZXN0cm95ZWQ7XG4gICAgICAgIHRvLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRvLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdG8ub0hhc2ggPSBvSGFzaC5fY2xvbmVJbnRvKHRvLm9IYXNoKTtcbiAgICAgICAgdG8uaUhhc2ggPSBpSGFzaC5fY2xvbmVJbnRvKHRvLmlIYXNoKTtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIHRoaXMub0hhc2guZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmlIYXNoLmRlc3Ryb3koKTtcbiAgICB9XG59XG4vKipcbiAqIEhNQUM6IFJGQzIxMDQgbWVzc2FnZSBhdXRoZW50aWNhdGlvbiBjb2RlLlxuICogQHBhcmFtIGhhc2ggLSBmdW5jdGlvbiB0aGF0IHdvdWxkIGJlIHVzZWQgZS5nLiBzaGEyNTZcbiAqIEBwYXJhbSBrZXkgLSBtZXNzYWdlIGtleVxuICogQHBhcmFtIG1lc3NhZ2UgLSBtZXNzYWdlIGRhdGFcbiAqL1xuZXhwb3J0IGNvbnN0IGhtYWMgPSAoaGFzaCwga2V5LCBtZXNzYWdlKSA9PiBuZXcgSE1BQyhoYXNoLCBrZXkpLnVwZGF0ZShtZXNzYWdlKS5kaWdlc3QoKTtcbmhtYWMuY3JlYXRlID0gKGhhc2gsIGtleSkgPT4gbmV3IEhNQUMoaGFzaCwga2V5KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhtYWMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/hmac.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/sha256.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/sha256.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sha224: () => (/* binding */ sha224),\n/* harmony export */   sha256: () => (/* binding */ sha256)\n/* harmony export */ });\n/* harmony import */ var _sha2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_sha2.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/_sha2.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// Choice: a ? b : c\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = new Uint32Array(64);\nclass SHA256 extends _sha2_js__WEBPACK_IMPORTED_MODULE_0__.SHA2 {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = IV[0] | 0;\n        this.B = IV[1] | 0;\n        this.C = IV[2] | 0;\n        this.D = IV[3] | 0;\n        this.E = IV[4] | 0;\n        this.F = IV[5] | 0;\n        this.G = IV[6] | 0;\n        this.H = IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 7) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 18) ^ (W15 >>> 3);\n            const s1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 17) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 6) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 11) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 2) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 13) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nconst sha256 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA256());\nconst sha224 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA224());\n//# sourceMappingURL=sha256.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vc2hhMjU2LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBa0M7QUFDaUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMENBQUk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5QkFBeUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0EsdUJBQXVCLCtDQUFJLFdBQVcsK0NBQUk7QUFDMUMsdUJBQXVCLCtDQUFJLFdBQVcsK0NBQUk7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsY0FBYyx5QkFBeUI7QUFDdkMsd0JBQXdCLFFBQVE7QUFDaEMsMkJBQTJCLCtDQUFJLFNBQVMsK0NBQUksVUFBVSwrQ0FBSTtBQUMxRDtBQUNBLDJCQUEyQiwrQ0FBSSxTQUFTLCtDQUFJLFVBQVUsK0NBQUk7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sZUFBZSwwREFBZTtBQUM5QixlQUFlLDBEQUFlO0FBQ3JDIiwic291cmNlcyI6WyIvaG9tZS9sZmcvR2l0L01hZHRyaXBzL25vZGVfbW9kdWxlcy9Abm9zdHItZGV2LWtpdC9uZGsvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGEyNTYuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU0hBMiB9IGZyb20gJy4vX3NoYTIuanMnO1xuaW1wb3J0IHsgcm90ciwgd3JhcENvbnN0cnVjdG9yIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBDaG9pY2U6IGEgPyBiIDogY1xuY29uc3QgQ2hpID0gKGEsIGIsIGMpID0+IChhICYgYikgXiAofmEgJiBjKTtcbi8vIE1ham9yaXR5IGZ1bmN0aW9uLCB0cnVlIGlmIGFueSB0d28gaW5wdXN0IGlzIHRydWVcbmNvbnN0IE1haiA9IChhLCBiLCBjKSA9PiAoYSAmIGIpIF4gKGEgJiBjKSBeIChiICYgYyk7XG4vLyBSb3VuZCBjb25zdGFudHM6XG4vLyBmaXJzdCAzMiBiaXRzIG9mIHRoZSBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBjdWJlIHJvb3RzIG9mIHRoZSBmaXJzdCA2NCBwcmltZXMgMi4uMzExKVxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBTSEEyNTZfSyA9IG5ldyBVaW50MzJBcnJheShbXG4gICAgMHg0MjhhMmY5OCwgMHg3MTM3NDQ5MSwgMHhiNWMwZmJjZiwgMHhlOWI1ZGJhNSwgMHgzOTU2YzI1YiwgMHg1OWYxMTFmMSwgMHg5MjNmODJhNCwgMHhhYjFjNWVkNSxcbiAgICAweGQ4MDdhYTk4LCAweDEyODM1YjAxLCAweDI0MzE4NWJlLCAweDU1MGM3ZGMzLCAweDcyYmU1ZDc0LCAweDgwZGViMWZlLCAweDliZGMwNmE3LCAweGMxOWJmMTc0LFxuICAgIDB4ZTQ5YjY5YzEsIDB4ZWZiZTQ3ODYsIDB4MGZjMTlkYzYsIDB4MjQwY2ExY2MsIDB4MmRlOTJjNmYsIDB4NGE3NDg0YWEsIDB4NWNiMGE5ZGMsIDB4NzZmOTg4ZGEsXG4gICAgMHg5ODNlNTE1MiwgMHhhODMxYzY2ZCwgMHhiMDAzMjdjOCwgMHhiZjU5N2ZjNywgMHhjNmUwMGJmMywgMHhkNWE3OTE0NywgMHgwNmNhNjM1MSwgMHgxNDI5Mjk2NyxcbiAgICAweDI3YjcwYTg1LCAweDJlMWIyMTM4LCAweDRkMmM2ZGZjLCAweDUzMzgwZDEzLCAweDY1MGE3MzU0LCAweDc2NmEwYWJiLCAweDgxYzJjOTJlLCAweDkyNzIyYzg1LFxuICAgIDB4YTJiZmU4YTEsIDB4YTgxYTY2NGIsIDB4YzI0YjhiNzAsIDB4Yzc2YzUxYTMsIDB4ZDE5MmU4MTksIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsXG4gICAgMHgxOWE0YzExNiwgMHgxZTM3NmMwOCwgMHgyNzQ4Nzc0YywgMHgzNGIwYmNiNSwgMHgzOTFjMGNiMywgMHg0ZWQ4YWE0YSwgMHg1YjljY2E0ZiwgMHg2ODJlNmZmMyxcbiAgICAweDc0OGY4MmVlLCAweDc4YTU2MzZmLCAweDg0Yzg3ODE0LCAweDhjYzcwMjA4LCAweDkwYmVmZmZhLCAweGE0NTA2Y2ViLCAweGJlZjlhM2Y3LCAweGM2NzE3OGYyXG5dKTtcbi8vIEluaXRpYWwgc3RhdGUgKGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIHNxdWFyZSByb290cyBvZiB0aGUgZmlyc3QgOCBwcmltZXMgMi4uMTkpOlxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBJViA9IG5ldyBVaW50MzJBcnJheShbXG4gICAgMHg2YTA5ZTY2NywgMHhiYjY3YWU4NSwgMHgzYzZlZjM3MiwgMHhhNTRmZjUzYSwgMHg1MTBlNTI3ZiwgMHg5YjA1Njg4YywgMHgxZjgzZDlhYiwgMHg1YmUwY2QxOVxuXSk7XG4vLyBUZW1wb3JhcnkgYnVmZmVyLCBub3QgdXNlZCB0byBzdG9yZSBhbnl0aGluZyBiZXR3ZWVuIHJ1bnNcbi8vIE5hbWVkIHRoaXMgd2F5IGJlY2F1c2UgaXQgbWF0Y2hlcyBzcGVjaWZpY2F0aW9uLlxuY29uc3QgU0hBMjU2X1cgPSBuZXcgVWludDMyQXJyYXkoNjQpO1xuY2xhc3MgU0hBMjU2IGV4dGVuZHMgU0hBMiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDY0LCAzMiwgOCwgZmFsc2UpO1xuICAgICAgICAvLyBXZSBjYW5ub3QgdXNlIGFycmF5IGhlcmUgc2luY2UgYXJyYXkgYWxsb3dzIGluZGV4aW5nIGJ5IHZhcmlhYmxlXG4gICAgICAgIC8vIHdoaWNoIG1lYW5zIG9wdGltaXplci9jb21waWxlciBjYW5ub3QgdXNlIHJlZ2lzdGVycy5cbiAgICAgICAgdGhpcy5BID0gSVZbMF0gfCAwO1xuICAgICAgICB0aGlzLkIgPSBJVlsxXSB8IDA7XG4gICAgICAgIHRoaXMuQyA9IElWWzJdIHwgMDtcbiAgICAgICAgdGhpcy5EID0gSVZbM10gfCAwO1xuICAgICAgICB0aGlzLkUgPSBJVls0XSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IElWWzVdIHwgMDtcbiAgICAgICAgdGhpcy5HID0gSVZbNl0gfCAwO1xuICAgICAgICB0aGlzLkggPSBJVls3XSB8IDA7XG4gICAgfVxuICAgIGdldCgpIHtcbiAgICAgICAgY29uc3QgeyBBLCBCLCBDLCBELCBFLCBGLCBHLCBIIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW0EsIEIsIEMsIEQsIEUsIEYsIEcsIEhdO1xuICAgIH1cbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBzZXQoQSwgQiwgQywgRCwgRSwgRiwgRywgSCkge1xuICAgICAgICB0aGlzLkEgPSBBIHwgMDtcbiAgICAgICAgdGhpcy5CID0gQiB8IDA7XG4gICAgICAgIHRoaXMuQyA9IEMgfCAwO1xuICAgICAgICB0aGlzLkQgPSBEIHwgMDtcbiAgICAgICAgdGhpcy5FID0gRSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IEYgfCAwO1xuICAgICAgICB0aGlzLkcgPSBHIHwgMDtcbiAgICAgICAgdGhpcy5IID0gSCB8IDA7XG4gICAgfVxuICAgIHByb2Nlc3Modmlldywgb2Zmc2V0KSB7XG4gICAgICAgIC8vIEV4dGVuZCB0aGUgZmlyc3QgMTYgd29yZHMgaW50byB0aGUgcmVtYWluaW5nIDQ4IHdvcmRzIHdbMTYuLjYzXSBvZiB0aGUgbWVzc2FnZSBzY2hlZHVsZSBhcnJheVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyssIG9mZnNldCArPSA0KVxuICAgICAgICAgICAgU0hBMjU2X1dbaV0gPSB2aWV3LmdldFVpbnQzMihvZmZzZXQsIGZhbHNlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE2OyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgVzE1ID0gU0hBMjU2X1dbaSAtIDE1XTtcbiAgICAgICAgICAgIGNvbnN0IFcyID0gU0hBMjU2X1dbaSAtIDJdO1xuICAgICAgICAgICAgY29uc3QgczAgPSByb3RyKFcxNSwgNykgXiByb3RyKFcxNSwgMTgpIF4gKFcxNSA+Pj4gMyk7XG4gICAgICAgICAgICBjb25zdCBzMSA9IHJvdHIoVzIsIDE3KSBeIHJvdHIoVzIsIDE5KSBeIChXMiA+Pj4gMTApO1xuICAgICAgICAgICAgU0hBMjU2X1dbaV0gPSAoczEgKyBTSEEyNTZfV1tpIC0gN10gKyBzMCArIFNIQTI1Nl9XW2kgLSAxNl0pIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wcmVzc2lvbiBmdW5jdGlvbiBtYWluIGxvb3AsIDY0IHJvdW5kc1xuICAgICAgICBsZXQgeyBBLCBCLCBDLCBELCBFLCBGLCBHLCBIIH0gPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY0OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMSA9IHJvdHIoRSwgNikgXiByb3RyKEUsIDExKSBeIHJvdHIoRSwgMjUpO1xuICAgICAgICAgICAgY29uc3QgVDEgPSAoSCArIHNpZ21hMSArIENoaShFLCBGLCBHKSArIFNIQTI1Nl9LW2ldICsgU0hBMjU2X1dbaV0pIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMCA9IHJvdHIoQSwgMikgXiByb3RyKEEsIDEzKSBeIHJvdHIoQSwgMjIpO1xuICAgICAgICAgICAgY29uc3QgVDIgPSAoc2lnbWEwICsgTWFqKEEsIEIsIEMpKSB8IDA7XG4gICAgICAgICAgICBIID0gRztcbiAgICAgICAgICAgIEcgPSBGO1xuICAgICAgICAgICAgRiA9IEU7XG4gICAgICAgICAgICBFID0gKEQgKyBUMSkgfCAwO1xuICAgICAgICAgICAgRCA9IEM7XG4gICAgICAgICAgICBDID0gQjtcbiAgICAgICAgICAgIEIgPSBBO1xuICAgICAgICAgICAgQSA9IChUMSArIFQyKSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBjb21wcmVzc2VkIGNodW5rIHRvIHRoZSBjdXJyZW50IGhhc2ggdmFsdWVcbiAgICAgICAgQSA9IChBICsgdGhpcy5BKSB8IDA7XG4gICAgICAgIEIgPSAoQiArIHRoaXMuQikgfCAwO1xuICAgICAgICBDID0gKEMgKyB0aGlzLkMpIHwgMDtcbiAgICAgICAgRCA9IChEICsgdGhpcy5EKSB8IDA7XG4gICAgICAgIEUgPSAoRSArIHRoaXMuRSkgfCAwO1xuICAgICAgICBGID0gKEYgKyB0aGlzLkYpIHwgMDtcbiAgICAgICAgRyA9IChHICsgdGhpcy5HKSB8IDA7XG4gICAgICAgIEggPSAoSCArIHRoaXMuSCkgfCAwO1xuICAgICAgICB0aGlzLnNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKTtcbiAgICB9XG4gICAgcm91bmRDbGVhbigpIHtcbiAgICAgICAgU0hBMjU2X1cuZmlsbCgwKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgICAgIHRoaXMuYnVmZmVyLmZpbGwoMCk7XG4gICAgfVxufVxuLy8gQ29uc3RhbnRzIGZyb20gaHR0cHM6Ly9udmxwdWJzLm5pc3QuZ292L25pc3RwdWJzL0ZJUFMvTklTVC5GSVBTLjE4MC00LnBkZlxuY2xhc3MgU0hBMjI0IGV4dGVuZHMgU0hBMjU2IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5BID0gMHhjMTA1OWVkOCB8IDA7XG4gICAgICAgIHRoaXMuQiA9IDB4MzY3Y2Q1MDcgfCAwO1xuICAgICAgICB0aGlzLkMgPSAweDMwNzBkZDE3IHwgMDtcbiAgICAgICAgdGhpcy5EID0gMHhmNzBlNTkzOSB8IDA7XG4gICAgICAgIHRoaXMuRSA9IDB4ZmZjMDBiMzEgfCAwO1xuICAgICAgICB0aGlzLkYgPSAweDY4NTgxNTExIHwgMDtcbiAgICAgICAgdGhpcy5HID0gMHg2NGY5OGZhNyB8IDA7XG4gICAgICAgIHRoaXMuSCA9IDB4YmVmYTRmYTQgfCAwO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IDI4O1xuICAgIH1cbn1cbi8qKlxuICogU0hBMi0yNTYgaGFzaCBmdW5jdGlvblxuICogQHBhcmFtIG1lc3NhZ2UgLSBkYXRhIHRoYXQgd291bGQgYmUgaGFzaGVkXG4gKi9cbmV4cG9ydCBjb25zdCBzaGEyNTYgPSB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTI1NigpKTtcbmV4cG9ydCBjb25zdCBzaGEyMjQgPSB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTIyNCgpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYTI1Ni5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/sha256.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/utils.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/utils.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hash: () => (/* binding */ Hash),\n/* harmony export */   asyncLoop: () => (/* binding */ asyncLoop),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   checkOpts: () => (/* binding */ checkOpts),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createView: () => (/* binding */ createView),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   isLE: () => (/* binding */ isLE),\n/* harmony export */   nextTick: () => (/* binding */ nextTick),\n/* harmony export */   randomBytes: () => (/* binding */ randomBytes),\n/* harmony export */   rotr: () => (/* binding */ rotr),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   u32: () => (/* binding */ u32),\n/* harmony export */   u8: () => (/* binding */ u8),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   wrapConstructor: () => (/* binding */ wrapConstructor),\n/* harmony export */   wrapConstructorWithOpts: () => (/* binding */ wrapConstructorWithOpts),\n/* harmony export */   wrapXOFConstructorWithOpts: () => (/* binding */ wrapXOFConstructorWithOpts)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/crypto */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/cryptoNode.js\");\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated, we can just drop the import.\n\nconst u8a = (a) => a instanceof Uint8Array;\n// Cast array to different type\nconst u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nconst u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nconst createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\nconst isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE)\n    throw new Error('Non little-endian hardware is not supported');\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    if (!u8a(bytes))\n        throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const len = hex.length;\n    if (len % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n    const array = new Uint8Array(len / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    if (!u8a(data))\n        throw new Error(`expected Uint8Array, got ${typeof data}`);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n    let pad = 0; // walk through each item, ensure they have proper type\n    arrays.forEach((a) => {\n        if (!u8a(a))\n            throw new Error('Uint8Array expected');\n        r.set(a, pad);\n        pad += a.length;\n    });\n    return r;\n}\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\n// Check if object doens't have custom constructor (like Uint8Array/Array)\nconst isPlainObject = (obj) => Object.prototype.toString.call(obj) === '[object Object]' && obj.constructor === Object;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && (typeof opts !== 'object' || !isPlainObject(opts)))\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nfunction wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nfunction randomBytes(bytesLength = 32) {\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues === 'function') {\n        return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzhDO0FBQzlDO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsNERBQTRELFdBQVc7QUFDdkUsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFlBQVk7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsUUFBUSx3REFBTSxXQUFXLHdEQUFNO0FBQy9CLGVBQWUsd0RBQU07QUFDckI7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2xmZy9HaXQvTWFkdHJpcHMvbm9kZV9tb2R1bGVzL0Bub3N0ci1kZXYta2l0L25kay9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3V0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1oYXNoZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIFdlIHVzZSBXZWJDcnlwdG8gYWthIGdsb2JhbFRoaXMuY3J5cHRvLCB3aGljaCBleGlzdHMgaW4gYnJvd3NlcnMgYW5kIG5vZGUuanMgMTYrLlxuLy8gbm9kZS5qcyB2ZXJzaW9ucyBlYXJsaWVyIHRoYW4gdjE5IGRvbid0IGRlY2xhcmUgaXQgaW4gZ2xvYmFsIHNjb3BlLlxuLy8gRm9yIG5vZGUuanMsIHBhY2thZ2UuanNvbiNleHBvcnRzIGZpZWxkIG1hcHBpbmcgcmV3cml0ZXMgaW1wb3J0XG4vLyBmcm9tIGBjcnlwdG9gIHRvIGBjcnlwdG9Ob2RlYCwgd2hpY2ggaW1wb3J0cyBuYXRpdmUgbW9kdWxlLlxuLy8gTWFrZXMgdGhlIHV0aWxzIHVuLWltcG9ydGFibGUgaW4gYnJvd3NlcnMgd2l0aG91dCBhIGJ1bmRsZXIuXG4vLyBPbmNlIG5vZGUuanMgMTggaXMgZGVwcmVjYXRlZCwgd2UgY2FuIGp1c3QgZHJvcCB0aGUgaW1wb3J0LlxuaW1wb3J0IHsgY3J5cHRvIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9jcnlwdG8nO1xuY29uc3QgdThhID0gKGEpID0+IGEgaW5zdGFuY2VvZiBVaW50OEFycmF5O1xuLy8gQ2FzdCBhcnJheSB0byBkaWZmZXJlbnQgdHlwZVxuZXhwb3J0IGNvbnN0IHU4ID0gKGFycikgPT4gbmV3IFVpbnQ4QXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbmV4cG9ydCBjb25zdCB1MzIgPSAoYXJyKSA9PiBuZXcgVWludDMyQXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIE1hdGguZmxvb3IoYXJyLmJ5dGVMZW5ndGggLyA0KSk7XG4vLyBDYXN0IGFycmF5IHRvIHZpZXdcbmV4cG9ydCBjb25zdCBjcmVhdGVWaWV3ID0gKGFycikgPT4gbmV3IERhdGFWaWV3KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG4vLyBUaGUgcm90YXRlIHJpZ2h0IChjaXJjdWxhciByaWdodCBzaGlmdCkgb3BlcmF0aW9uIGZvciB1aW50MzJcbmV4cG9ydCBjb25zdCByb3RyID0gKHdvcmQsIHNoaWZ0KSA9PiAod29yZCA8PCAoMzIgLSBzaGlmdCkpIHwgKHdvcmQgPj4+IHNoaWZ0KTtcbi8vIGJpZy1lbmRpYW4gaGFyZHdhcmUgaXMgcmFyZS4gSnVzdCBpbiBjYXNlIHNvbWVvbmUgc3RpbGwgZGVjaWRlcyB0byBydW4gaGFzaGVzOlxuLy8gZWFybHktdGhyb3cgYW4gZXJyb3IgYmVjYXVzZSB3ZSBkb24ndCBzdXBwb3J0IEJFIHlldC5cbmV4cG9ydCBjb25zdCBpc0xFID0gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQzMkFycmF5KFsweDExMjIzMzQ0XSkuYnVmZmVyKVswXSA9PT0gMHg0NDtcbmlmICghaXNMRSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbiBsaXR0bGUtZW5kaWFuIGhhcmR3YXJlIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbmNvbnN0IGhleGVzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sICh2LCBpKSA9PiBpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbi8qKlxuICogQGV4YW1wbGUgYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKSkgLy8gJ2NhZmUwMTIzJ1xuICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuICAgIGlmICghdThhKGJ5dGVzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgLy8gcHJlLWNhY2hpbmcgaW1wcm92ZXMgdGhlIHNwZWVkIDZ4XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IGhleGVzW2J5dGVzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbi8qKlxuICogQGV4YW1wbGUgaGV4VG9CeXRlcygnY2FmZTAxMjMnKSAvLyBVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGV4VG9CeXRlcyhoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICBjb25zdCBsZW4gPSBoZXgubGVuZ3RoO1xuICAgIGlmIChsZW4gJSAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRlZCBoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgdW5wYWRkZWQgaGV4IG9mIGxlbmd0aCAnICsgbGVuKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGxlbiAvIDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaiA9IGkgKiAyO1xuICAgICAgICBjb25zdCBoZXhCeXRlID0gaGV4LnNsaWNlKGosIGogKyAyKTtcbiAgICAgICAgY29uc3QgYnl0ZSA9IE51bWJlci5wYXJzZUludChoZXhCeXRlLCAxNik7XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4oYnl0ZSkgfHwgYnl0ZSA8IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYnl0ZSBzZXF1ZW5jZScpO1xuICAgICAgICBhcnJheVtpXSA9IGJ5dGU7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbi8vIFRoZXJlIGlzIG5vIHNldEltbWVkaWF0ZSBpbiBicm93c2VyIGFuZCBzZXRUaW1lb3V0IGlzIHNsb3cuXG4vLyBjYWxsIG9mIGFzeW5jIGZuIHdpbGwgcmV0dXJuIFByb21pc2UsIHdoaWNoIHdpbGwgYmUgZnVsbGZpbGVkIG9ubHkgb25cbi8vIG5leHQgc2NoZWR1bGVyIHF1ZXVlIHByb2Nlc3Npbmcgc3RlcCBhbmQgdGhpcyBpcyBleGFjdGx5IHdoYXQgd2UgbmVlZC5cbmV4cG9ydCBjb25zdCBuZXh0VGljayA9IGFzeW5jICgpID0+IHsgfTtcbi8vIFJldHVybnMgY29udHJvbCB0byB0aHJlYWQgZWFjaCAndGljaycgbXMgdG8gYXZvaWQgYmxvY2tpbmdcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhc3luY0xvb3AoaXRlcnMsIHRpY2ssIGNiKSB7XG4gICAgbGV0IHRzID0gRGF0ZS5ub3coKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJzOyBpKyspIHtcbiAgICAgICAgY2IoaSk7XG4gICAgICAgIC8vIERhdGUubm93KCkgaXMgbm90IG1vbm90b25pYywgc28gaW4gY2FzZSBpZiBjbG9jayBnb2VzIGJhY2t3YXJkcyB3ZSByZXR1cm4gcmV0dXJuIGNvbnRyb2wgdG9vXG4gICAgICAgIGNvbnN0IGRpZmYgPSBEYXRlLm5vdygpIC0gdHM7XG4gICAgICAgIGlmIChkaWZmID49IDAgJiYgZGlmZiA8IHRpY2spXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgYXdhaXQgbmV4dFRpY2soKTtcbiAgICAgICAgdHMgKz0gZGlmZjtcbiAgICB9XG59XG4vKipcbiAqIEBleGFtcGxlIHV0ZjhUb0J5dGVzKCdhYmMnKSAvLyBuZXcgVWludDhBcnJheShbOTcsIDk4LCA5OV0pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdXRmOFRvQnl0ZXMgZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygc3RyfWApO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSk7IC8vIGh0dHBzOi8vYnVnemlsLmxhLzE2ODE4MDlcbn1cbi8qKlxuICogTm9ybWFsaXplcyAobm9uLWhleCkgc3RyaW5nIG9yIFVpbnQ4QXJyYXkgdG8gVWludDhBcnJheS5cbiAqIFdhcm5pbmc6IHdoZW4gVWludDhBcnJheSBpcyBwYXNzZWQsIGl0IHdvdWxkIE5PVCBnZXQgY29waWVkLlxuICogS2VlcCBpbiBtaW5kIGZvciBmdXR1cmUgbXV0YWJsZSBvcGVyYXRpb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9CeXRlcyhkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJylcbiAgICAgICAgZGF0YSA9IHV0ZjhUb0J5dGVzKGRhdGEpO1xuICAgIGlmICghdThhKGRhdGEpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkIFVpbnQ4QXJyYXksIGdvdCAke3R5cGVvZiBkYXRhfWApO1xuICAgIHJldHVybiBkYXRhO1xufVxuLyoqXG4gKiBDb3BpZXMgc2V2ZXJhbCBVaW50OEFycmF5cyBpbnRvIG9uZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5cykge1xuICAgIGNvbnN0IHIgPSBuZXcgVWludDhBcnJheShhcnJheXMucmVkdWNlKChzdW0sIGEpID0+IHN1bSArIGEubGVuZ3RoLCAwKSk7XG4gICAgbGV0IHBhZCA9IDA7IC8vIHdhbGsgdGhyb3VnaCBlYWNoIGl0ZW0sIGVuc3VyZSB0aGV5IGhhdmUgcHJvcGVyIHR5cGVcbiAgICBhcnJheXMuZm9yRWFjaCgoYSkgPT4ge1xuICAgICAgICBpZiAoIXU4YShhKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgICAgICByLnNldChhLCBwYWQpO1xuICAgICAgICBwYWQgKz0gYS5sZW5ndGg7XG4gICAgfSk7XG4gICAgcmV0dXJuIHI7XG59XG4vLyBGb3IgcnVudGltZSBjaGVjayBpZiBjbGFzcyBpbXBsZW1lbnRzIGludGVyZmFjZVxuZXhwb3J0IGNsYXNzIEhhc2gge1xuICAgIC8vIFNhZmUgdmVyc2lvbiB0aGF0IGNsb25lcyBpbnRlcm5hbCBzdGF0ZVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvbmVJbnRvKCk7XG4gICAgfVxufVxuLy8gQ2hlY2sgaWYgb2JqZWN0IGRvZW5zJ3QgaGF2ZSBjdXN0b20gY29uc3RydWN0b3IgKGxpa2UgVWludDhBcnJheS9BcnJheSlcbmNvbnN0IGlzUGxhaW5PYmplY3QgPSAob2JqKSA9PiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG5leHBvcnQgZnVuY3Rpb24gY2hlY2tPcHRzKGRlZmF1bHRzLCBvcHRzKSB7XG4gICAgaWYgKG9wdHMgIT09IHVuZGVmaW5lZCAmJiAodHlwZW9mIG9wdHMgIT09ICdvYmplY3QnIHx8ICFpc1BsYWluT2JqZWN0KG9wdHMpKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcHRpb25zIHNob3VsZCBiZSBvYmplY3Qgb3IgdW5kZWZpbmVkJyk7XG4gICAgY29uc3QgbWVyZ2VkID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0cywgb3B0cyk7XG4gICAgcmV0dXJuIG1lcmdlZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiB3cmFwQ29uc3RydWN0b3IoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2cpID0+IGhhc2hDb25zKCkudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoKTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9ICgpID0+IGhhc2hDb25zKCk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBDb25zdHJ1Y3RvcldpdGhPcHRzKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnLCBvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucyh7fSk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAob3B0cykgPT4gaGFzaENvbnMob3B0cyk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnLCBvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucyh7fSk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAob3B0cykgPT4gaGFzaENvbnMob3B0cyk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuLyoqXG4gKiBTZWN1cmUgUFJORy4gVXNlcyBgY3J5cHRvLmdldFJhbmRvbVZhbHVlc2AsIHdoaWNoIGRlZmVycyB0byBPUy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbUJ5dGVzKGJ5dGVzTGVuZ3RoID0gMzIpIHtcbiAgICBpZiAoY3J5cHRvICYmIHR5cGVvZiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KGJ5dGVzTGVuZ3RoKSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignY3J5cHRvLmdldFJhbmRvbVZhbHVlcyBtdXN0IGJlIGRlZmluZWQnKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@scure/base/lib/esm/index.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@scure/base/lib/esm/index.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertNumber: () => (/* binding */ assertNumber),\n/* harmony export */   base16: () => (/* binding */ base16),\n/* harmony export */   base32: () => (/* binding */ base32),\n/* harmony export */   base32crockford: () => (/* binding */ base32crockford),\n/* harmony export */   base32hex: () => (/* binding */ base32hex),\n/* harmony export */   base58: () => (/* binding */ base58),\n/* harmony export */   base58check: () => (/* binding */ base58check),\n/* harmony export */   base58flickr: () => (/* binding */ base58flickr),\n/* harmony export */   base58xmr: () => (/* binding */ base58xmr),\n/* harmony export */   base58xrp: () => (/* binding */ base58xrp),\n/* harmony export */   base64: () => (/* binding */ base64),\n/* harmony export */   base64url: () => (/* binding */ base64url),\n/* harmony export */   bech32: () => (/* binding */ bech32),\n/* harmony export */   bech32m: () => (/* binding */ bech32m),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   bytesToString: () => (/* binding */ bytesToString),\n/* harmony export */   hex: () => (/* binding */ hex),\n/* harmony export */   str: () => (/* binding */ str),\n/* harmony export */   stringToBytes: () => (/* binding */ stringToBytes),\n/* harmony export */   utf8: () => (/* binding */ utf8),\n/* harmony export */   utils: () => (/* binding */ utils)\n/* harmony export */ });\n/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nfunction assertNumber(n) {\n    if (!Number.isSafeInteger(n))\n        throw new Error(`Wrong integer: ${n}`);\n}\nfunction chain(...args) {\n    const wrap = (a, b) => (c) => a(b(c));\n    const encode = Array.from(args)\n        .reverse()\n        .reduce((acc, i) => (acc ? wrap(acc, i.encode) : i.encode), undefined);\n    const decode = args.reduce((acc, i) => (acc ? wrap(acc, i.decode) : i.decode), undefined);\n    return { encode, decode };\n}\nfunction alphabet(alphabet) {\n    return {\n        encode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('alphabet.encode input should be an array of numbers');\n            return digits.map((i) => {\n                assertNumber(i);\n                if (i < 0 || i >= alphabet.length)\n                    throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet.length})`);\n                return alphabet[i];\n            });\n        },\n        decode: (input) => {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('alphabet.decode input should be array of strings');\n            return input.map((letter) => {\n                if (typeof letter !== 'string')\n                    throw new Error(`alphabet.decode: not string element=${letter}`);\n                const index = alphabet.indexOf(letter);\n                if (index === -1)\n                    throw new Error(`Unknown letter: \"${letter}\". Allowed: ${alphabet}`);\n                return index;\n            });\n        },\n    };\n}\nfunction join(separator = '') {\n    if (typeof separator !== 'string')\n        throw new Error('join separator should be string');\n    return {\n        encode: (from) => {\n            if (!Array.isArray(from) || (from.length && typeof from[0] !== 'string'))\n                throw new Error('join.encode input should be array of strings');\n            for (let i of from)\n                if (typeof i !== 'string')\n                    throw new Error(`join.encode: non-string input=${i}`);\n            return from.join(separator);\n        },\n        decode: (to) => {\n            if (typeof to !== 'string')\n                throw new Error('join.decode input should be string');\n            return to.split(separator);\n        },\n    };\n}\nfunction padding(bits, chr = '=') {\n    assertNumber(bits);\n    if (typeof chr !== 'string')\n        throw new Error('padding chr should be string');\n    return {\n        encode(data) {\n            if (!Array.isArray(data) || (data.length && typeof data[0] !== 'string'))\n                throw new Error('padding.encode input should be array of strings');\n            for (let i of data)\n                if (typeof i !== 'string')\n                    throw new Error(`padding.encode: non-string input=${i}`);\n            while ((data.length * bits) % 8)\n                data.push(chr);\n            return data;\n        },\n        decode(input) {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('padding.encode input should be array of strings');\n            for (let i of input)\n                if (typeof i !== 'string')\n                    throw new Error(`padding.decode: non-string input=${i}`);\n            let end = input.length;\n            if ((end * bits) % 8)\n                throw new Error('Invalid padding: string should have whole number of bytes');\n            for (; end > 0 && input[end - 1] === chr; end--) {\n                if (!(((end - 1) * bits) % 8))\n                    throw new Error('Invalid padding: string has too much padding');\n            }\n            return input.slice(0, end);\n        },\n    };\n}\nfunction normalize(fn) {\n    if (typeof fn !== 'function')\n        throw new Error('normalize fn should be function');\n    return { encode: (from) => from, decode: (to) => fn(to) };\n}\nfunction convertRadix(data, from, to) {\n    if (from < 2)\n        throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);\n    if (to < 2)\n        throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);\n    if (!Array.isArray(data))\n        throw new Error('convertRadix: data should be array');\n    if (!data.length)\n        return [];\n    let pos = 0;\n    const res = [];\n    const digits = Array.from(data);\n    digits.forEach((d) => {\n        assertNumber(d);\n        if (d < 0 || d >= from)\n            throw new Error(`Wrong integer: ${d}`);\n    });\n    while (true) {\n        let carry = 0;\n        let done = true;\n        for (let i = pos; i < digits.length; i++) {\n            const digit = digits[i];\n            const digitBase = from * carry + digit;\n            if (!Number.isSafeInteger(digitBase) ||\n                (from * carry) / from !== carry ||\n                digitBase - digit !== from * carry) {\n                throw new Error('convertRadix: carry overflow');\n            }\n            carry = digitBase % to;\n            digits[i] = Math.floor(digitBase / to);\n            if (!Number.isSafeInteger(digits[i]) || digits[i] * to + carry !== digitBase)\n                throw new Error('convertRadix: carry overflow');\n            if (!done)\n                continue;\n            else if (!digits[i])\n                pos = i;\n            else\n                done = false;\n        }\n        res.push(carry);\n        if (done)\n            break;\n    }\n    for (let i = 0; i < data.length - 1 && data[i] === 0; i++)\n        res.push(0);\n    return res.reverse();\n}\nconst gcd = (a, b) => (!b ? a : gcd(b, a % b));\nconst radix2carry = (from, to) => from + (to - gcd(from, to));\nfunction convertRadix2(data, from, to, padding) {\n    if (!Array.isArray(data))\n        throw new Error('convertRadix2: data should be array');\n    if (from <= 0 || from > 32)\n        throw new Error(`convertRadix2: wrong from=${from}`);\n    if (to <= 0 || to > 32)\n        throw new Error(`convertRadix2: wrong to=${to}`);\n    if (radix2carry(from, to) > 32) {\n        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);\n    }\n    let carry = 0;\n    let pos = 0;\n    const mask = 2 ** to - 1;\n    const res = [];\n    for (const n of data) {\n        assertNumber(n);\n        if (n >= 2 ** from)\n            throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n        carry = (carry << from) | n;\n        if (pos + from > 32)\n            throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n        pos += from;\n        for (; pos >= to; pos -= to)\n            res.push(((carry >> (pos - to)) & mask) >>> 0);\n        carry &= 2 ** pos - 1;\n    }\n    carry = (carry << (to - pos)) & mask;\n    if (!padding && pos >= from)\n        throw new Error('Excess padding');\n    if (!padding && carry)\n        throw new Error(`Non-zero padding: ${carry}`);\n    if (padding && pos > 0)\n        res.push(carry >>> 0);\n    return res;\n}\nfunction radix(num) {\n    assertNumber(num);\n    return {\n        encode: (bytes) => {\n            if (!(bytes instanceof Uint8Array))\n                throw new Error('radix.encode input should be Uint8Array');\n            return convertRadix(Array.from(bytes), 2 ** 8, num);\n        },\n        decode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('radix.decode input should be array of strings');\n            return Uint8Array.from(convertRadix(digits, num, 2 ** 8));\n        },\n    };\n}\nfunction radix2(bits, revPadding = false) {\n    assertNumber(bits);\n    if (bits <= 0 || bits > 32)\n        throw new Error('radix2: bits should be in (0..32]');\n    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)\n        throw new Error('radix2: carry overflow');\n    return {\n        encode: (bytes) => {\n            if (!(bytes instanceof Uint8Array))\n                throw new Error('radix2.encode input should be Uint8Array');\n            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n        },\n        decode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('radix2.decode input should be array of strings');\n            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n        },\n    };\n}\nfunction unsafeWrapper(fn) {\n    if (typeof fn !== 'function')\n        throw new Error('unsafeWrapper fn should be function');\n    return function (...args) {\n        try {\n            return fn.apply(null, args);\n        }\n        catch (e) { }\n    };\n}\nfunction checksum(len, fn) {\n    assertNumber(len);\n    if (typeof fn !== 'function')\n        throw new Error('checksum fn should be function');\n    return {\n        encode(data) {\n            if (!(data instanceof Uint8Array))\n                throw new Error('checksum.encode: input should be Uint8Array');\n            const checksum = fn(data).slice(0, len);\n            const res = new Uint8Array(data.length + len);\n            res.set(data);\n            res.set(checksum, data.length);\n            return res;\n        },\n        decode(data) {\n            if (!(data instanceof Uint8Array))\n                throw new Error('checksum.decode: input should be Uint8Array');\n            const payload = data.slice(0, -len);\n            const newChecksum = fn(payload).slice(0, len);\n            const oldChecksum = data.slice(-len);\n            for (let i = 0; i < len; i++)\n                if (newChecksum[i] !== oldChecksum[i])\n                    throw new Error('Invalid checksum');\n            return payload;\n        },\n    };\n}\nconst utils = { alphabet, chain, checksum, radix, radix2, join, padding };\nconst base16 = chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));\nconst base32 = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));\nconst base32hex = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));\nconst base32crockford = chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize((s) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')));\nconst base64 = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));\nconst base64url = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));\nconst genBase58 = (abc) => chain(radix(58), alphabet(abc), join(''));\nconst base58 = genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');\nconst base58flickr = genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');\nconst base58xrp = genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');\nconst XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\nconst base58xmr = {\n    encode(data) {\n        let res = '';\n        for (let i = 0; i < data.length; i += 8) {\n            const block = data.subarray(i, i + 8);\n            res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');\n        }\n        return res;\n    },\n    decode(str) {\n        let res = [];\n        for (let i = 0; i < str.length; i += 11) {\n            const slice = str.slice(i, i + 11);\n            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n            const block = base58.decode(slice);\n            for (let j = 0; j < block.length - blockLen; j++) {\n                if (block[j] !== 0)\n                    throw new Error('base58xmr: wrong padding');\n            }\n            res = res.concat(Array.from(block.slice(block.length - blockLen)));\n        }\n        return Uint8Array.from(res);\n    },\n};\nconst base58check = (sha256) => chain(checksum(4, (data) => sha256(sha256(data))), base58);\nconst BECH_ALPHABET = chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));\nconst POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\nfunction bech32Polymod(pre) {\n    const b = pre >> 25;\n    let chk = (pre & 0x1ffffff) << 5;\n    for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {\n        if (((b >> i) & 1) === 1)\n            chk ^= POLYMOD_GENERATORS[i];\n    }\n    return chk;\n}\nfunction bechChecksum(prefix, words, encodingConst = 1) {\n    const len = prefix.length;\n    let chk = 1;\n    for (let i = 0; i < len; i++) {\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126)\n            throw new Error(`Invalid prefix (${prefix})`);\n        chk = bech32Polymod(chk) ^ (c >> 5);\n    }\n    chk = bech32Polymod(chk);\n    for (let i = 0; i < len; i++)\n        chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);\n    for (let v of words)\n        chk = bech32Polymod(chk) ^ v;\n    for (let i = 0; i < 6; i++)\n        chk = bech32Polymod(chk);\n    chk ^= encodingConst;\n    return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));\n}\nfunction genBech32(encoding) {\n    const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n    const _words = radix2(5);\n    const fromWords = _words.decode;\n    const toWords = _words.encode;\n    const fromWordsUnsafe = unsafeWrapper(fromWords);\n    function encode(prefix, words, limit = 90) {\n        if (typeof prefix !== 'string')\n            throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);\n        if (!Array.isArray(words) || (words.length && typeof words[0] !== 'number'))\n            throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);\n        const actualLength = prefix.length + 7 + words.length;\n        if (limit !== false && actualLength > limit)\n            throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n        prefix = prefix.toLowerCase();\n        return `${prefix}1${BECH_ALPHABET.encode(words)}${bechChecksum(prefix, words, ENCODING_CONST)}`;\n    }\n    function decode(str, limit = 90) {\n        if (typeof str !== 'string')\n            throw new Error(`bech32.decode input should be string, not ${typeof str}`);\n        if (str.length < 8 || (limit !== false && str.length > limit))\n            throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);\n        const lowered = str.toLowerCase();\n        if (str !== lowered && str !== str.toUpperCase())\n            throw new Error(`String must be lowercase or uppercase`);\n        str = lowered;\n        const sepIndex = str.lastIndexOf('1');\n        if (sepIndex === 0 || sepIndex === -1)\n            throw new Error(`Letter \"1\" must be present between prefix and data only`);\n        const prefix = str.slice(0, sepIndex);\n        const _words = str.slice(sepIndex + 1);\n        if (_words.length < 6)\n            throw new Error('Data must be at least 6 characters long');\n        const words = BECH_ALPHABET.decode(_words).slice(0, -6);\n        const sum = bechChecksum(prefix, words, ENCODING_CONST);\n        if (!_words.endsWith(sum))\n            throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n        return { prefix, words };\n    }\n    const decodeUnsafe = unsafeWrapper(decode);\n    function decodeToBytes(str) {\n        const { prefix, words } = decode(str, false);\n        return { prefix, words, bytes: fromWords(words) };\n    }\n    return { encode, decode, decodeToBytes, decodeUnsafe, fromWords, fromWordsUnsafe, toWords };\n}\nconst bech32 = genBech32('bech32');\nconst bech32m = genBech32('bech32m');\nconst utf8 = {\n    encode: (data) => new TextDecoder().decode(data),\n    decode: (str) => new TextEncoder().encode(str),\n};\nconst hex = chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize((s) => {\n    if (typeof s !== 'string' || s.length % 2)\n        throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);\n    return s.toLowerCase();\n}));\nconst CODERS = {\n    utf8, hex, base16, base32, base64, base64url, base58, base58xmr\n};\nconst coderTypeError = `Invalid encoding type. Available types: ${Object.keys(CODERS).join(', ')}`;\nconst bytesToString = (type, bytes) => {\n    if (typeof type !== 'string' || !CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (!(bytes instanceof Uint8Array))\n        throw new TypeError('bytesToString() expects Uint8Array');\n    return CODERS[type].encode(bytes);\n};\nconst str = bytesToString;\nconst stringToBytes = (type, str) => {\n    if (!CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (typeof str !== 'string')\n        throw new TypeError('stringToBytes() expects string');\n    return CODERS[type].decode(str);\n};\nconst bytes = stringToBytes;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQHNjdXJlL2Jhc2UvbGliL2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNPO0FBQ1A7QUFDQSwwQ0FBMEMsRUFBRTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsR0FBRyxhQUFhLGdCQUFnQjtBQUNyRztBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxPQUFPO0FBQ2xGO0FBQ0E7QUFDQSx3REFBd0QsT0FBTyxjQUFjLFNBQVM7QUFDdEY7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsRUFBRTtBQUN2RTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsRUFBRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxFQUFFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQ0FBbUM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsS0FBSztBQUN6RDtBQUNBLGtEQUFrRCxHQUFHO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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aEMsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ087QUFDQTtBQUNBO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGdFQUFnRSxVQUFVLGNBQWMsU0FBUztBQUNqRztBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsK0JBQStCO0FBQzFGO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPIiwic291cmNlcyI6WyIvaG9tZS9sZmcvR2l0L01hZHRyaXBzL25vZGVfbW9kdWxlcy9Abm9zdHItZGV2LWtpdC9uZGsvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Ac2N1cmUvYmFzZS9saWIvZXNtL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBzY3VyZS1iYXNlIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0TnVtYmVyKG4pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG4pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdyb25nIGludGVnZXI6ICR7bn1gKTtcbn1cbmZ1bmN0aW9uIGNoYWluKC4uLmFyZ3MpIHtcbiAgICBjb25zdCB3cmFwID0gKGEsIGIpID0+IChjKSA9PiBhKGIoYykpO1xuICAgIGNvbnN0IGVuY29kZSA9IEFycmF5LmZyb20oYXJncylcbiAgICAgICAgLnJldmVyc2UoKVxuICAgICAgICAucmVkdWNlKChhY2MsIGkpID0+IChhY2MgPyB3cmFwKGFjYywgaS5lbmNvZGUpIDogaS5lbmNvZGUpLCB1bmRlZmluZWQpO1xuICAgIGNvbnN0IGRlY29kZSA9IGFyZ3MucmVkdWNlKChhY2MsIGkpID0+IChhY2MgPyB3cmFwKGFjYywgaS5kZWNvZGUpIDogaS5kZWNvZGUpLCB1bmRlZmluZWQpO1xuICAgIHJldHVybiB7IGVuY29kZSwgZGVjb2RlIH07XG59XG5mdW5jdGlvbiBhbHBoYWJldChhbHBoYWJldCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZTogKGRpZ2l0cykgPT4ge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRpZ2l0cykgfHwgKGRpZ2l0cy5sZW5ndGggJiYgdHlwZW9mIGRpZ2l0c1swXSAhPT0gJ251bWJlcicpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYWxwaGFiZXQuZW5jb2RlIGlucHV0IHNob3VsZCBiZSBhbiBhcnJheSBvZiBudW1iZXJzJyk7XG4gICAgICAgICAgICByZXR1cm4gZGlnaXRzLm1hcCgoaSkgPT4ge1xuICAgICAgICAgICAgICAgIGFzc2VydE51bWJlcihpKTtcbiAgICAgICAgICAgICAgICBpZiAoaSA8IDAgfHwgaSA+PSBhbHBoYWJldC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRGlnaXQgaW5kZXggb3V0c2lkZSBhbHBoYWJldDogJHtpfSAoYWxwaGFiZXQ6ICR7YWxwaGFiZXQubGVuZ3RofSlgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWxwaGFiZXRbaV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlOiAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkgfHwgKGlucHV0Lmxlbmd0aCAmJiB0eXBlb2YgaW5wdXRbMF0gIT09ICdzdHJpbmcnKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FscGhhYmV0LmRlY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2Ygc3RyaW5ncycpO1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0Lm1hcCgobGV0dGVyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsZXR0ZXIgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGFscGhhYmV0LmRlY29kZTogbm90IHN0cmluZyBlbGVtZW50PSR7bGV0dGVyfWApO1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gYWxwaGFiZXQuaW5kZXhPZihsZXR0ZXIpO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBsZXR0ZXI6IFwiJHtsZXR0ZXJ9XCIuIEFsbG93ZWQ6ICR7YWxwaGFiZXR9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGpvaW4oc2VwYXJhdG9yID0gJycpIHtcbiAgICBpZiAodHlwZW9mIHNlcGFyYXRvciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignam9pbiBzZXBhcmF0b3Igc2hvdWxkIGJlIHN0cmluZycpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZTogKGZyb20pID0+IHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShmcm9tKSB8fCAoZnJvbS5sZW5ndGggJiYgdHlwZW9mIGZyb21bMF0gIT09ICdzdHJpbmcnKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2pvaW4uZW5jb2RlIGlucHV0IHNob3VsZCBiZSBhcnJheSBvZiBzdHJpbmdzJyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpIG9mIGZyb20pXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBqb2luLmVuY29kZTogbm9uLXN0cmluZyBpbnB1dD0ke2l9YCk7XG4gICAgICAgICAgICByZXR1cm4gZnJvbS5qb2luKHNlcGFyYXRvcik7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZTogKHRvKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRvICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2pvaW4uZGVjb2RlIGlucHV0IHNob3VsZCBiZSBzdHJpbmcnKTtcbiAgICAgICAgICAgIHJldHVybiB0by5zcGxpdChzZXBhcmF0b3IpO1xuICAgICAgICB9LFxuICAgIH07XG59XG5mdW5jdGlvbiBwYWRkaW5nKGJpdHMsIGNociA9ICc9Jykge1xuICAgIGFzc2VydE51bWJlcihiaXRzKTtcbiAgICBpZiAodHlwZW9mIGNociAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGluZyBjaHIgc2hvdWxkIGJlIHN0cmluZycpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZShkYXRhKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkgfHwgKGRhdGEubGVuZ3RoICYmIHR5cGVvZiBkYXRhWzBdICE9PSAnc3RyaW5nJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkaW5nLmVuY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2Ygc3RyaW5ncycpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSBvZiBkYXRhKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaSAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcGFkZGluZy5lbmNvZGU6IG5vbi1zdHJpbmcgaW5wdXQ9JHtpfWApO1xuICAgICAgICAgICAgd2hpbGUgKChkYXRhLmxlbmd0aCAqIGJpdHMpICUgOClcbiAgICAgICAgICAgICAgICBkYXRhLnB1c2goY2hyKTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGUoaW5wdXQpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkgfHwgKGlucHV0Lmxlbmd0aCAmJiB0eXBlb2YgaW5wdXRbMF0gIT09ICdzdHJpbmcnKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRpbmcuZW5jb2RlIGlucHV0IHNob3VsZCBiZSBhcnJheSBvZiBzdHJpbmdzJyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpIG9mIGlucHV0KVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaSAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcGFkZGluZy5kZWNvZGU6IG5vbi1zdHJpbmcgaW5wdXQ9JHtpfWApO1xuICAgICAgICAgICAgbGV0IGVuZCA9IGlucHV0Lmxlbmd0aDtcbiAgICAgICAgICAgIGlmICgoZW5kICogYml0cykgJSA4KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwYWRkaW5nOiBzdHJpbmcgc2hvdWxkIGhhdmUgd2hvbGUgbnVtYmVyIG9mIGJ5dGVzJyk7XG4gICAgICAgICAgICBmb3IgKDsgZW5kID4gMCAmJiBpbnB1dFtlbmQgLSAxXSA9PT0gY2hyOyBlbmQtLSkge1xuICAgICAgICAgICAgICAgIGlmICghKCgoZW5kIC0gMSkgKiBiaXRzKSAlIDgpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcGFkZGluZzogc3RyaW5nIGhhcyB0b28gbXVjaCBwYWRkaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQuc2xpY2UoMCwgZW5kKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplKGZuKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3JtYWxpemUgZm4gc2hvdWxkIGJlIGZ1bmN0aW9uJyk7XG4gICAgcmV0dXJuIHsgZW5jb2RlOiAoZnJvbSkgPT4gZnJvbSwgZGVjb2RlOiAodG8pID0+IGZuKHRvKSB9O1xufVxuZnVuY3Rpb24gY29udmVydFJhZGl4KGRhdGEsIGZyb20sIHRvKSB7XG4gICAgaWYgKGZyb20gPCAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDogd3JvbmcgZnJvbT0ke2Zyb219LCBiYXNlIGNhbm5vdCBiZSBsZXNzIHRoYW4gMmApO1xuICAgIGlmICh0byA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4OiB3cm9uZyB0bz0ke3RvfSwgYmFzZSBjYW5ub3QgYmUgbGVzcyB0aGFuIDJgKTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY29udmVydFJhZGl4OiBkYXRhIHNob3VsZCBiZSBhcnJheScpO1xuICAgIGlmICghZGF0YS5sZW5ndGgpXG4gICAgICAgIHJldHVybiBbXTtcbiAgICBsZXQgcG9zID0gMDtcbiAgICBjb25zdCByZXMgPSBbXTtcbiAgICBjb25zdCBkaWdpdHMgPSBBcnJheS5mcm9tKGRhdGEpO1xuICAgIGRpZ2l0cy5mb3JFYWNoKChkKSA9PiB7XG4gICAgICAgIGFzc2VydE51bWJlcihkKTtcbiAgICAgICAgaWYgKGQgPCAwIHx8IGQgPj0gZnJvbSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgV3JvbmcgaW50ZWdlcjogJHtkfWApO1xuICAgIH0pO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGxldCBjYXJyeSA9IDA7XG4gICAgICAgIGxldCBkb25lID0gdHJ1ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHBvczsgaSA8IGRpZ2l0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZGlnaXQgPSBkaWdpdHNbaV07XG4gICAgICAgICAgICBjb25zdCBkaWdpdEJhc2UgPSBmcm9tICogY2FycnkgKyBkaWdpdDtcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoZGlnaXRCYXNlKSB8fFxuICAgICAgICAgICAgICAgIChmcm9tICogY2FycnkpIC8gZnJvbSAhPT0gY2FycnkgfHxcbiAgICAgICAgICAgICAgICBkaWdpdEJhc2UgLSBkaWdpdCAhPT0gZnJvbSAqIGNhcnJ5KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb252ZXJ0UmFkaXg6IGNhcnJ5IG92ZXJmbG93Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXJyeSA9IGRpZ2l0QmFzZSAlIHRvO1xuICAgICAgICAgICAgZGlnaXRzW2ldID0gTWF0aC5mbG9vcihkaWdpdEJhc2UgLyB0byk7XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGRpZ2l0c1tpXSkgfHwgZGlnaXRzW2ldICogdG8gKyBjYXJyeSAhPT0gZGlnaXRCYXNlKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY29udmVydFJhZGl4OiBjYXJyeSBvdmVyZmxvdycpO1xuICAgICAgICAgICAgaWYgKCFkb25lKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgZWxzZSBpZiAoIWRpZ2l0c1tpXSlcbiAgICAgICAgICAgICAgICBwb3MgPSBpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGRvbmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXMucHVzaChjYXJyeSk7XG4gICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGggLSAxICYmIGRhdGFbaV0gPT09IDA7IGkrKylcbiAgICAgICAgcmVzLnB1c2goMCk7XG4gICAgcmV0dXJuIHJlcy5yZXZlcnNlKCk7XG59XG5jb25zdCBnY2QgPSAoYSwgYikgPT4gKCFiID8gYSA6IGdjZChiLCBhICUgYikpO1xuY29uc3QgcmFkaXgyY2FycnkgPSAoZnJvbSwgdG8pID0+IGZyb20gKyAodG8gLSBnY2QoZnJvbSwgdG8pKTtcbmZ1bmN0aW9uIGNvbnZlcnRSYWRpeDIoZGF0YSwgZnJvbSwgdG8sIHBhZGRpbmcpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY29udmVydFJhZGl4MjogZGF0YSBzaG91bGQgYmUgYXJyYXknKTtcbiAgICBpZiAoZnJvbSA8PSAwIHx8IGZyb20gPiAzMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXgyOiB3cm9uZyBmcm9tPSR7ZnJvbX1gKTtcbiAgICBpZiAodG8gPD0gMCB8fCB0byA+IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDI6IHdyb25nIHRvPSR7dG99YCk7XG4gICAgaWYgKHJhZGl4MmNhcnJ5KGZyb20sIHRvKSA+IDMyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4MjogY2Fycnkgb3ZlcmZsb3cgZnJvbT0ke2Zyb219IHRvPSR7dG99IGNhcnJ5Qml0cz0ke3JhZGl4MmNhcnJ5KGZyb20sIHRvKX1gKTtcbiAgICB9XG4gICAgbGV0IGNhcnJ5ID0gMDtcbiAgICBsZXQgcG9zID0gMDtcbiAgICBjb25zdCBtYXNrID0gMiAqKiB0byAtIDE7XG4gICAgY29uc3QgcmVzID0gW107XG4gICAgZm9yIChjb25zdCBuIG9mIGRhdGEpIHtcbiAgICAgICAgYXNzZXJ0TnVtYmVyKG4pO1xuICAgICAgICBpZiAobiA+PSAyICoqIGZyb20pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDI6IGludmFsaWQgZGF0YSB3b3JkPSR7bn0gZnJvbT0ke2Zyb219YCk7XG4gICAgICAgIGNhcnJ5ID0gKGNhcnJ5IDw8IGZyb20pIHwgbjtcbiAgICAgICAgaWYgKHBvcyArIGZyb20gPiAzMilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4MjogY2Fycnkgb3ZlcmZsb3cgcG9zPSR7cG9zfSBmcm9tPSR7ZnJvbX1gKTtcbiAgICAgICAgcG9zICs9IGZyb207XG4gICAgICAgIGZvciAoOyBwb3MgPj0gdG87IHBvcyAtPSB0bylcbiAgICAgICAgICAgIHJlcy5wdXNoKCgoY2FycnkgPj4gKHBvcyAtIHRvKSkgJiBtYXNrKSA+Pj4gMCk7XG4gICAgICAgIGNhcnJ5ICY9IDIgKiogcG9zIC0gMTtcbiAgICB9XG4gICAgY2FycnkgPSAoY2FycnkgPDwgKHRvIC0gcG9zKSkgJiBtYXNrO1xuICAgIGlmICghcGFkZGluZyAmJiBwb3MgPj0gZnJvbSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeGNlc3MgcGFkZGluZycpO1xuICAgIGlmICghcGFkZGluZyAmJiBjYXJyeSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb24temVybyBwYWRkaW5nOiAke2NhcnJ5fWApO1xuICAgIGlmIChwYWRkaW5nICYmIHBvcyA+IDApXG4gICAgICAgIHJlcy5wdXNoKGNhcnJ5ID4+PiAwKTtcbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gcmFkaXgobnVtKSB7XG4gICAgYXNzZXJ0TnVtYmVyKG51bSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlOiAoYnl0ZXMpID0+IHtcbiAgICAgICAgICAgIGlmICghKGJ5dGVzIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpeC5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIFVpbnQ4QXJyYXknKTtcbiAgICAgICAgICAgIHJldHVybiBjb252ZXJ0UmFkaXgoQXJyYXkuZnJvbShieXRlcyksIDIgKiogOCwgbnVtKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlOiAoZGlnaXRzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGlnaXRzKSB8fCAoZGlnaXRzLmxlbmd0aCAmJiB0eXBlb2YgZGlnaXRzWzBdICE9PSAnbnVtYmVyJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpeC5kZWNvZGUgaW5wdXQgc2hvdWxkIGJlIGFycmF5IG9mIHN0cmluZ3MnKTtcbiAgICAgICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oY29udmVydFJhZGl4KGRpZ2l0cywgbnVtLCAyICoqIDgpKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gcmFkaXgyKGJpdHMsIHJldlBhZGRpbmcgPSBmYWxzZSkge1xuICAgIGFzc2VydE51bWJlcihiaXRzKTtcbiAgICBpZiAoYml0cyA8PSAwIHx8IGJpdHMgPiAzMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpeDI6IGJpdHMgc2hvdWxkIGJlIGluICgwLi4zMl0nKTtcbiAgICBpZiAocmFkaXgyY2FycnkoOCwgYml0cykgPiAzMiB8fCByYWRpeDJjYXJyeShiaXRzLCA4KSA+IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4MjogY2Fycnkgb3ZlcmZsb3cnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGU6IChieXRlcykgPT4ge1xuICAgICAgICAgICAgaWYgKCEoYnl0ZXMgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4Mi5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIFVpbnQ4QXJyYXknKTtcbiAgICAgICAgICAgIHJldHVybiBjb252ZXJ0UmFkaXgyKEFycmF5LmZyb20oYnl0ZXMpLCA4LCBiaXRzLCAhcmV2UGFkZGluZyk7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZTogKGRpZ2l0cykgPT4ge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRpZ2l0cykgfHwgKGRpZ2l0cy5sZW5ndGggJiYgdHlwZW9mIGRpZ2l0c1swXSAhPT0gJ251bWJlcicpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmFkaXgyLmRlY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2Ygc3RyaW5ncycpO1xuICAgICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShjb252ZXJ0UmFkaXgyKGRpZ2l0cywgYml0cywgOCwgcmV2UGFkZGluZykpO1xuICAgICAgICB9LFxuICAgIH07XG59XG5mdW5jdGlvbiB1bnNhZmVXcmFwcGVyKGZuKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnNhZmVXcmFwcGVyIGZuIHNob3VsZCBiZSBmdW5jdGlvbicpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICB9O1xufVxuZnVuY3Rpb24gY2hlY2tzdW0obGVuLCBmbikge1xuICAgIGFzc2VydE51bWJlcihsZW4pO1xuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY2hlY2tzdW0gZm4gc2hvdWxkIGJlIGZ1bmN0aW9uJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlKGRhdGEpIHtcbiAgICAgICAgICAgIGlmICghKGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NoZWNrc3VtLmVuY29kZTogaW5wdXQgc2hvdWxkIGJlIFVpbnQ4QXJyYXknKTtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrc3VtID0gZm4oZGF0YSkuc2xpY2UoMCwgbGVuKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KGRhdGEubGVuZ3RoICsgbGVuKTtcbiAgICAgICAgICAgIHJlcy5zZXQoZGF0YSk7XG4gICAgICAgICAgICByZXMuc2V0KGNoZWNrc3VtLCBkYXRhLmxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGUoZGF0YSkge1xuICAgICAgICAgICAgaWYgKCEoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2hlY2tzdW0uZGVjb2RlOiBpbnB1dCBzaG91bGQgYmUgVWludDhBcnJheScpO1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IGRhdGEuc2xpY2UoMCwgLWxlbik7XG4gICAgICAgICAgICBjb25zdCBuZXdDaGVja3N1bSA9IGZuKHBheWxvYWQpLnNsaWNlKDAsIGxlbik7XG4gICAgICAgICAgICBjb25zdCBvbGRDaGVja3N1bSA9IGRhdGEuc2xpY2UoLWxlbik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgICAgICAgICAgIGlmIChuZXdDaGVja3N1bVtpXSAhPT0gb2xkQ2hlY2tzdW1baV0pXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjaGVja3N1bScpO1xuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmV4cG9ydCBjb25zdCB1dGlscyA9IHsgYWxwaGFiZXQsIGNoYWluLCBjaGVja3N1bSwgcmFkaXgsIHJhZGl4Miwgam9pbiwgcGFkZGluZyB9O1xuZXhwb3J0IGNvbnN0IGJhc2UxNiA9IGNoYWluKHJhZGl4Mig0KSwgYWxwaGFiZXQoJzAxMjM0NTY3ODlBQkNERUYnKSwgam9pbignJykpO1xuZXhwb3J0IGNvbnN0IGJhc2UzMiA9IGNoYWluKHJhZGl4Mig1KSwgYWxwaGFiZXQoJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaMjM0NTY3JyksIHBhZGRpbmcoNSksIGpvaW4oJycpKTtcbmV4cG9ydCBjb25zdCBiYXNlMzJoZXggPSBjaGFpbihyYWRpeDIoNSksIGFscGhhYmV0KCcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVicpLCBwYWRkaW5nKDUpLCBqb2luKCcnKSk7XG5leHBvcnQgY29uc3QgYmFzZTMyY3JvY2tmb3JkID0gY2hhaW4ocmFkaXgyKDUpLCBhbHBoYWJldCgnMDEyMzQ1Njc4OUFCQ0RFRkdISktNTlBRUlNUVldYWVonKSwgam9pbignJyksIG5vcm1hbGl6ZSgocykgPT4gcy50b1VwcGVyQ2FzZSgpLnJlcGxhY2UoL08vZywgJzAnKS5yZXBsYWNlKC9bSUxdL2csICcxJykpKTtcbmV4cG9ydCBjb25zdCBiYXNlNjQgPSBjaGFpbihyYWRpeDIoNiksIGFscGhhYmV0KCdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJyksIHBhZGRpbmcoNiksIGpvaW4oJycpKTtcbmV4cG9ydCBjb25zdCBiYXNlNjR1cmwgPSBjaGFpbihyYWRpeDIoNiksIGFscGhhYmV0KCdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1fJyksIHBhZGRpbmcoNiksIGpvaW4oJycpKTtcbmNvbnN0IGdlbkJhc2U1OCA9IChhYmMpID0+IGNoYWluKHJhZGl4KDU4KSwgYWxwaGFiZXQoYWJjKSwgam9pbignJykpO1xuZXhwb3J0IGNvbnN0IGJhc2U1OCA9IGdlbkJhc2U1OCgnMTIzNDU2Nzg5QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaYWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5eicpO1xuZXhwb3J0IGNvbnN0IGJhc2U1OGZsaWNrciA9IGdlbkJhc2U1OCgnMTIzNDU2Nzg5YWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5ekFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWicpO1xuZXhwb3J0IGNvbnN0IGJhc2U1OHhycCA9IGdlbkJhc2U1OCgncnBzaG5hZjM5d0JVRE5FR0hKS0xNNFBRUlNUN1ZXWFlaMmJjZGVDZzY1amttOG9GcWkxdHV2QXh5eicpO1xuY29uc3QgWE1SX0JMT0NLX0xFTiA9IFswLCAyLCAzLCA1LCA2LCA3LCA5LCAxMCwgMTFdO1xuZXhwb3J0IGNvbnN0IGJhc2U1OHhtciA9IHtcbiAgICBlbmNvZGUoZGF0YSkge1xuICAgICAgICBsZXQgcmVzID0gJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gOCkge1xuICAgICAgICAgICAgY29uc3QgYmxvY2sgPSBkYXRhLnN1YmFycmF5KGksIGkgKyA4KTtcbiAgICAgICAgICAgIHJlcyArPSBiYXNlNTguZW5jb2RlKGJsb2NrKS5wYWRTdGFydChYTVJfQkxPQ0tfTEVOW2Jsb2NrLmxlbmd0aF0sICcxJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9LFxuICAgIGRlY29kZShzdHIpIHtcbiAgICAgICAgbGV0IHJlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkgKz0gMTEpIHtcbiAgICAgICAgICAgIGNvbnN0IHNsaWNlID0gc3RyLnNsaWNlKGksIGkgKyAxMSk7XG4gICAgICAgICAgICBjb25zdCBibG9ja0xlbiA9IFhNUl9CTE9DS19MRU4uaW5kZXhPZihzbGljZS5sZW5ndGgpO1xuICAgICAgICAgICAgY29uc3QgYmxvY2sgPSBiYXNlNTguZGVjb2RlKHNsaWNlKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYmxvY2subGVuZ3RoIC0gYmxvY2tMZW47IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChibG9ja1tqXSAhPT0gMClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYXNlNTh4bXI6IHdyb25nIHBhZGRpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcyA9IHJlcy5jb25jYXQoQXJyYXkuZnJvbShibG9jay5zbGljZShibG9jay5sZW5ndGggLSBibG9ja0xlbikpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKHJlcyk7XG4gICAgfSxcbn07XG5leHBvcnQgY29uc3QgYmFzZTU4Y2hlY2sgPSAoc2hhMjU2KSA9PiBjaGFpbihjaGVja3N1bSg0LCAoZGF0YSkgPT4gc2hhMjU2KHNoYTI1NihkYXRhKSkpLCBiYXNlNTgpO1xuY29uc3QgQkVDSF9BTFBIQUJFVCA9IGNoYWluKGFscGhhYmV0KCdxcHpyeTl4OGdmMnR2ZHcwczNqbjU0a2hjZTZtdWE3bCcpLCBqb2luKCcnKSk7XG5jb25zdCBQT0xZTU9EX0dFTkVSQVRPUlMgPSBbMHgzYjZhNTdiMiwgMHgyNjUwOGU2ZCwgMHgxZWExMTlmYSwgMHgzZDQyMzNkZCwgMHgyYTE0NjJiM107XG5mdW5jdGlvbiBiZWNoMzJQb2x5bW9kKHByZSkge1xuICAgIGNvbnN0IGIgPSBwcmUgPj4gMjU7XG4gICAgbGV0IGNoayA9IChwcmUgJiAweDFmZmZmZmYpIDw8IDU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBQT0xZTU9EX0dFTkVSQVRPUlMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCgoYiA+PiBpKSAmIDEpID09PSAxKVxuICAgICAgICAgICAgY2hrIF49IFBPTFlNT0RfR0VORVJBVE9SU1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIGNoaztcbn1cbmZ1bmN0aW9uIGJlY2hDaGVja3N1bShwcmVmaXgsIHdvcmRzLCBlbmNvZGluZ0NvbnN0ID0gMSkge1xuICAgIGNvbnN0IGxlbiA9IHByZWZpeC5sZW5ndGg7XG4gICAgbGV0IGNoayA9IDE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjb25zdCBjID0gcHJlZml4LmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjIDwgMzMgfHwgYyA+IDEyNilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwcmVmaXggKCR7cHJlZml4fSlgKTtcbiAgICAgICAgY2hrID0gYmVjaDMyUG9seW1vZChjaGspIF4gKGMgPj4gNSk7XG4gICAgfVxuICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgICBjaGsgPSBiZWNoMzJQb2x5bW9kKGNoaykgXiAocHJlZml4LmNoYXJDb2RlQXQoaSkgJiAweDFmKTtcbiAgICBmb3IgKGxldCB2IG9mIHdvcmRzKVxuICAgICAgICBjaGsgPSBiZWNoMzJQb2x5bW9kKGNoaykgXiB2O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKVxuICAgICAgICBjaGsgPSBiZWNoMzJQb2x5bW9kKGNoayk7XG4gICAgY2hrIF49IGVuY29kaW5nQ29uc3Q7XG4gICAgcmV0dXJuIEJFQ0hfQUxQSEFCRVQuZW5jb2RlKGNvbnZlcnRSYWRpeDIoW2NoayAlIDIgKiogMzBdLCAzMCwgNSwgZmFsc2UpKTtcbn1cbmZ1bmN0aW9uIGdlbkJlY2gzMihlbmNvZGluZykge1xuICAgIGNvbnN0IEVOQ09ESU5HX0NPTlNUID0gZW5jb2RpbmcgPT09ICdiZWNoMzInID8gMSA6IDB4MmJjODMwYTM7XG4gICAgY29uc3QgX3dvcmRzID0gcmFkaXgyKDUpO1xuICAgIGNvbnN0IGZyb21Xb3JkcyA9IF93b3Jkcy5kZWNvZGU7XG4gICAgY29uc3QgdG9Xb3JkcyA9IF93b3Jkcy5lbmNvZGU7XG4gICAgY29uc3QgZnJvbVdvcmRzVW5zYWZlID0gdW5zYWZlV3JhcHBlcihmcm9tV29yZHMpO1xuICAgIGZ1bmN0aW9uIGVuY29kZShwcmVmaXgsIHdvcmRzLCBsaW1pdCA9IDkwKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcHJlZml4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYmVjaDMyLmVuY29kZSBwcmVmaXggc2hvdWxkIGJlIHN0cmluZywgbm90ICR7dHlwZW9mIHByZWZpeH1gKTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHdvcmRzKSB8fCAod29yZHMubGVuZ3RoICYmIHR5cGVvZiB3b3Jkc1swXSAhPT0gJ251bWJlcicpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBiZWNoMzIuZW5jb2RlIHdvcmRzIHNob3VsZCBiZSBhcnJheSBvZiBudW1iZXJzLCBub3QgJHt0eXBlb2Ygd29yZHN9YCk7XG4gICAgICAgIGNvbnN0IGFjdHVhbExlbmd0aCA9IHByZWZpeC5sZW5ndGggKyA3ICsgd29yZHMubGVuZ3RoO1xuICAgICAgICBpZiAobGltaXQgIT09IGZhbHNlICYmIGFjdHVhbExlbmd0aCA+IGxpbWl0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTGVuZ3RoICR7YWN0dWFsTGVuZ3RofSBleGNlZWRzIGxpbWl0ICR7bGltaXR9YCk7XG4gICAgICAgIHByZWZpeCA9IHByZWZpeC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXR1cm4gYCR7cHJlZml4fTEke0JFQ0hfQUxQSEFCRVQuZW5jb2RlKHdvcmRzKX0ke2JlY2hDaGVja3N1bShwcmVmaXgsIHdvcmRzLCBFTkNPRElOR19DT05TVCl9YDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVjb2RlKHN0ciwgbGltaXQgPSA5MCkge1xuICAgICAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJlY2gzMi5kZWNvZGUgaW5wdXQgc2hvdWxkIGJlIHN0cmluZywgbm90ICR7dHlwZW9mIHN0cn1gKTtcbiAgICAgICAgaWYgKHN0ci5sZW5ndGggPCA4IHx8IChsaW1pdCAhPT0gZmFsc2UgJiYgc3RyLmxlbmd0aCA+IGxpbWl0KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFdyb25nIHN0cmluZyBsZW5ndGg6ICR7c3RyLmxlbmd0aH0gKCR7c3RyfSkuIEV4cGVjdGVkICg4Li4ke2xpbWl0fSlgKTtcbiAgICAgICAgY29uc3QgbG93ZXJlZCA9IHN0ci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoc3RyICE9PSBsb3dlcmVkICYmIHN0ciAhPT0gc3RyLnRvVXBwZXJDYXNlKCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFN0cmluZyBtdXN0IGJlIGxvd2VyY2FzZSBvciB1cHBlcmNhc2VgKTtcbiAgICAgICAgc3RyID0gbG93ZXJlZDtcbiAgICAgICAgY29uc3Qgc2VwSW5kZXggPSBzdHIubGFzdEluZGV4T2YoJzEnKTtcbiAgICAgICAgaWYgKHNlcEluZGV4ID09PSAwIHx8IHNlcEluZGV4ID09PSAtMSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTGV0dGVyIFwiMVwiIG11c3QgYmUgcHJlc2VudCBiZXR3ZWVuIHByZWZpeCBhbmQgZGF0YSBvbmx5YCk7XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IHN0ci5zbGljZSgwLCBzZXBJbmRleCk7XG4gICAgICAgIGNvbnN0IF93b3JkcyA9IHN0ci5zbGljZShzZXBJbmRleCArIDEpO1xuICAgICAgICBpZiAoX3dvcmRzLmxlbmd0aCA8IDYpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgbXVzdCBiZSBhdCBsZWFzdCA2IGNoYXJhY3RlcnMgbG9uZycpO1xuICAgICAgICBjb25zdCB3b3JkcyA9IEJFQ0hfQUxQSEFCRVQuZGVjb2RlKF93b3Jkcykuc2xpY2UoMCwgLTYpO1xuICAgICAgICBjb25zdCBzdW0gPSBiZWNoQ2hlY2tzdW0ocHJlZml4LCB3b3JkcywgRU5DT0RJTkdfQ09OU1QpO1xuICAgICAgICBpZiAoIV93b3Jkcy5lbmRzV2l0aChzdW0pKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNoZWNrc3VtIGluICR7c3RyfTogZXhwZWN0ZWQgXCIke3N1bX1cImApO1xuICAgICAgICByZXR1cm4geyBwcmVmaXgsIHdvcmRzIH07XG4gICAgfVxuICAgIGNvbnN0IGRlY29kZVVuc2FmZSA9IHVuc2FmZVdyYXBwZXIoZGVjb2RlKTtcbiAgICBmdW5jdGlvbiBkZWNvZGVUb0J5dGVzKHN0cikge1xuICAgICAgICBjb25zdCB7IHByZWZpeCwgd29yZHMgfSA9IGRlY29kZShzdHIsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHsgcHJlZml4LCB3b3JkcywgYnl0ZXM6IGZyb21Xb3Jkcyh3b3JkcykgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgZW5jb2RlLCBkZWNvZGUsIGRlY29kZVRvQnl0ZXMsIGRlY29kZVVuc2FmZSwgZnJvbVdvcmRzLCBmcm9tV29yZHNVbnNhZmUsIHRvV29yZHMgfTtcbn1cbmV4cG9ydCBjb25zdCBiZWNoMzIgPSBnZW5CZWNoMzIoJ2JlY2gzMicpO1xuZXhwb3J0IGNvbnN0IGJlY2gzMm0gPSBnZW5CZWNoMzIoJ2JlY2gzMm0nKTtcbmV4cG9ydCBjb25zdCB1dGY4ID0ge1xuICAgIGVuY29kZTogKGRhdGEpID0+IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShkYXRhKSxcbiAgICBkZWNvZGU6IChzdHIpID0+IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpLFxufTtcbmV4cG9ydCBjb25zdCBoZXggPSBjaGFpbihyYWRpeDIoNCksIGFscGhhYmV0KCcwMTIzNDU2Nzg5YWJjZGVmJyksIGpvaW4oJycpLCBub3JtYWxpemUoKHMpID0+IHtcbiAgICBpZiAodHlwZW9mIHMgIT09ICdzdHJpbmcnIHx8IHMubGVuZ3RoICUgMilcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgaGV4LmRlY29kZTogZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygc30gd2l0aCBsZW5ndGggJHtzLmxlbmd0aH1gKTtcbiAgICByZXR1cm4gcy50b0xvd2VyQ2FzZSgpO1xufSkpO1xuY29uc3QgQ09ERVJTID0ge1xuICAgIHV0ZjgsIGhleCwgYmFzZTE2LCBiYXNlMzIsIGJhc2U2NCwgYmFzZTY0dXJsLCBiYXNlNTgsIGJhc2U1OHhtclxufTtcbmNvbnN0IGNvZGVyVHlwZUVycm9yID0gYEludmFsaWQgZW5jb2RpbmcgdHlwZS4gQXZhaWxhYmxlIHR5cGVzOiAke09iamVjdC5rZXlzKENPREVSUykuam9pbignLCAnKX1gO1xuZXhwb3J0IGNvbnN0IGJ5dGVzVG9TdHJpbmcgPSAodHlwZSwgYnl0ZXMpID0+IHtcbiAgICBpZiAodHlwZW9mIHR5cGUgIT09ICdzdHJpbmcnIHx8ICFDT0RFUlMuaGFzT3duUHJvcGVydHkodHlwZSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoY29kZXJUeXBlRXJyb3IpO1xuICAgIGlmICghKGJ5dGVzIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2J5dGVzVG9TdHJpbmcoKSBleHBlY3RzIFVpbnQ4QXJyYXknKTtcbiAgICByZXR1cm4gQ09ERVJTW3R5cGVdLmVuY29kZShieXRlcyk7XG59O1xuZXhwb3J0IGNvbnN0IHN0ciA9IGJ5dGVzVG9TdHJpbmc7XG5leHBvcnQgY29uc3Qgc3RyaW5nVG9CeXRlcyA9ICh0eXBlLCBzdHIpID0+IHtcbiAgICBpZiAoIUNPREVSUy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihjb2RlclR5cGVFcnJvcik7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzdHJpbmdUb0J5dGVzKCkgZXhwZWN0cyBzdHJpbmcnKTtcbiAgICByZXR1cm4gQ09ERVJTW3R5cGVdLmRlY29kZShzdHIpO1xufTtcbmV4cG9ydCBjb25zdCBieXRlcyA9IHN0cmluZ1RvQnl0ZXM7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@scure/base/lib/esm/index.js\n");

/***/ })

};
;