"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@nostr-dev-kit";
exports.ids = ["vendor-chunks/@nostr-dev-kit"];
exports.modules = {

/***/ "(rsc)/./node_modules/@nostr-dev-kit/ndk-react/dist/ndk-react.es.js":
/*!********************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk-react/dist/ndk-react.es.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   INVOICE: () => (/* binding */ Ha),\n/* harmony export */   LINK: () => (/* binding */ xi),\n/* harmony export */   NDKProvider: () => (/* binding */ Pp),\n/* harmony export */   NEWLINE: () => (/* binding */ Op),\n/* harmony export */   NOSTR_NADDR: () => (/* binding */ Up),\n/* harmony export */   NOSTR_NEVENT: () => (/* binding */ $p),\n/* harmony export */   NOSTR_NOTE: () => (/* binding */ Lp),\n/* harmony export */   NOSTR_NPROFILE: () => (/* binding */ Np),\n/* harmony export */   NOSTR_NPUB: () => (/* binding */ qp),\n/* harmony export */   TEXT: () => (/* binding */ Hn),\n/* harmony export */   TOPIC: () => (/* binding */ ja),\n/* harmony export */   fromNostrURI: () => (/* binding */ Ap),\n/* harmony export */   getLinks: () => (/* binding */ Mp),\n/* harmony export */   parseContent: () => (/* binding */ jp),\n/* harmony export */   truncateContent: () => (/* binding */ Hp),\n/* harmony export */   urlIsMedia: () => (/* binding */ Cp),\n/* harmony export */   useNDK: () => (/* binding */ Bp)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(rsc)/./node_modules/next/dist/server/route-modules/app-page/vendored/rsc/react.js\");\nvar ac = Object.defineProperty;\nvar cc = (t, e, r) => e in t ? ac(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r;\nvar I = (t, e, r) => (cc(t, typeof e != \"symbol\" ? e + \"\" : e, r), r);\n\nvar S = typeof globalThis < \"u\" ? globalThis : typeof window < \"u\" ? window : typeof global < \"u\" ? global : typeof self < \"u\" ? self : {};\nfunction Et(t) {\n  var e = t.default;\n  if (typeof e == \"function\") {\n    var r = function() {\n      return e.apply(this, arguments);\n    };\n    r.prototype = e.prototype;\n  } else\n    r = {};\n  return Object.defineProperty(r, \"__esModule\", { value: !0 }), Object.keys(t).forEach(function(n) {\n    var i = Object.getOwnPropertyDescriptor(t, n);\n    Object.defineProperty(r, n, i.get ? i : {\n      enumerable: !0,\n      get: function() {\n        return t[n];\n      }\n    });\n  }), r;\n}\nvar On = { exports: {} }, en, qi;\nfunction hc() {\n  if (qi)\n    return en;\n  qi = 1;\n  var t = 1e3, e = t * 60, r = e * 60, n = r * 24, i = n * 7, s = n * 365.25;\n  en = function(f, u) {\n    u = u || {};\n    var h = typeof f;\n    if (h === \"string\" && f.length > 0)\n      return o(f);\n    if (h === \"number\" && isFinite(f))\n      return u.long ? c(f) : a(f);\n    throw new Error(\n      \"val is not a non-empty string or a valid number. val=\" + JSON.stringify(f)\n    );\n  };\n  function o(f) {\n    if (f = String(f), !(f.length > 100)) {\n      var u = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n        f\n      );\n      if (!!u) {\n        var h = parseFloat(u[1]), d = (u[2] || \"ms\").toLowerCase();\n        switch (d) {\n          case \"years\":\n          case \"year\":\n          case \"yrs\":\n          case \"yr\":\n          case \"y\":\n            return h * s;\n          case \"weeks\":\n          case \"week\":\n          case \"w\":\n            return h * i;\n          case \"days\":\n          case \"day\":\n          case \"d\":\n            return h * n;\n          case \"hours\":\n          case \"hour\":\n          case \"hrs\":\n          case \"hr\":\n          case \"h\":\n            return h * r;\n          case \"minutes\":\n          case \"minute\":\n          case \"mins\":\n          case \"min\":\n          case \"m\":\n            return h * e;\n          case \"seconds\":\n          case \"second\":\n          case \"secs\":\n          case \"sec\":\n          case \"s\":\n            return h * t;\n          case \"milliseconds\":\n          case \"millisecond\":\n          case \"msecs\":\n          case \"msec\":\n          case \"ms\":\n            return h;\n          default:\n            return;\n        }\n      }\n    }\n  }\n  function a(f) {\n    var u = Math.abs(f);\n    return u >= n ? Math.round(f / n) + \"d\" : u >= r ? Math.round(f / r) + \"h\" : u >= e ? Math.round(f / e) + \"m\" : u >= t ? Math.round(f / t) + \"s\" : f + \"ms\";\n  }\n  function c(f) {\n    var u = Math.abs(f);\n    return u >= n ? l(f, u, n, \"day\") : u >= r ? l(f, u, r, \"hour\") : u >= e ? l(f, u, e, \"minute\") : u >= t ? l(f, u, t, \"second\") : f + \" ms\";\n  }\n  function l(f, u, h, d) {\n    var p = u >= h * 1.5;\n    return Math.round(f / h) + \" \" + d + (p ? \"s\" : \"\");\n  }\n  return en;\n}\nfunction dc(t) {\n  r.debug = r, r.default = r, r.coerce = c, r.disable = s, r.enable = i, r.enabled = o, r.humanize = hc(), r.destroy = l, Object.keys(t).forEach((f) => {\n    r[f] = t[f];\n  }), r.names = [], r.skips = [], r.formatters = {};\n  function e(f) {\n    let u = 0;\n    for (let h = 0; h < f.length; h++)\n      u = (u << 5) - u + f.charCodeAt(h), u |= 0;\n    return r.colors[Math.abs(u) % r.colors.length];\n  }\n  r.selectColor = e;\n  function r(f) {\n    let u, h = null, d, p;\n    function y(...g) {\n      if (!y.enabled)\n        return;\n      const v = y, _ = Number(new Date()), m = _ - (u || _);\n      v.diff = m, v.prev = u, v.curr = _, u = _, g[0] = r.coerce(g[0]), typeof g[0] != \"string\" && g.unshift(\"%O\");\n      let C = 0;\n      g[0] = g[0].replace(/%([a-zA-Z%])/g, (w, x) => {\n        if (w === \"%%\")\n          return \"%\";\n        C++;\n        const A = r.formatters[x];\n        if (typeof A == \"function\") {\n          const B = g[C];\n          w = A.call(v, B), g.splice(C, 1), C--;\n        }\n        return w;\n      }), r.formatArgs.call(v, g), (v.log || r.log).apply(v, g);\n    }\n    return y.namespace = f, y.useColors = r.useColors(), y.color = r.selectColor(f), y.extend = n, y.destroy = r.destroy, Object.defineProperty(y, \"enabled\", {\n      enumerable: !0,\n      configurable: !1,\n      get: () => h !== null ? h : (d !== r.namespaces && (d = r.namespaces, p = r.enabled(f)), p),\n      set: (g) => {\n        h = g;\n      }\n    }), typeof r.init == \"function\" && r.init(y), y;\n  }\n  function n(f, u) {\n    const h = r(this.namespace + (typeof u > \"u\" ? \":\" : u) + f);\n    return h.log = this.log, h;\n  }\n  function i(f) {\n    r.save(f), r.namespaces = f, r.names = [], r.skips = [];\n    let u;\n    const h = (typeof f == \"string\" ? f : \"\").split(/[\\s,]+/), d = h.length;\n    for (u = 0; u < d; u++)\n      !h[u] || (f = h[u].replace(/\\*/g, \".*?\"), f[0] === \"-\" ? r.skips.push(new RegExp(\"^\" + f.slice(1) + \"$\")) : r.names.push(new RegExp(\"^\" + f + \"$\")));\n  }\n  function s() {\n    const f = [\n      ...r.names.map(a),\n      ...r.skips.map(a).map((u) => \"-\" + u)\n    ].join(\",\");\n    return r.enable(\"\"), f;\n  }\n  function o(f) {\n    if (f[f.length - 1] === \"*\")\n      return !0;\n    let u, h;\n    for (u = 0, h = r.skips.length; u < h; u++)\n      if (r.skips[u].test(f))\n        return !1;\n    for (u = 0, h = r.names.length; u < h; u++)\n      if (r.names[u].test(f))\n        return !0;\n    return !1;\n  }\n  function a(f) {\n    return f.toString().substring(2, f.toString().length - 2).replace(/\\.\\*\\?$/, \"*\");\n  }\n  function c(f) {\n    return f instanceof Error ? f.stack || f.message : f;\n  }\n  function l() {\n    console.warn(\"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\");\n  }\n  return r.enable(r.load()), r;\n}\nvar pc = dc;\n(function(t, e) {\n  e.formatArgs = n, e.save = i, e.load = s, e.useColors = r, e.storage = o(), e.destroy = (() => {\n    let c = !1;\n    return () => {\n      c || (c = !0, console.warn(\"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\"));\n    };\n  })(), e.colors = [\n    \"#0000CC\",\n    \"#0000FF\",\n    \"#0033CC\",\n    \"#0033FF\",\n    \"#0066CC\",\n    \"#0066FF\",\n    \"#0099CC\",\n    \"#0099FF\",\n    \"#00CC00\",\n    \"#00CC33\",\n    \"#00CC66\",\n    \"#00CC99\",\n    \"#00CCCC\",\n    \"#00CCFF\",\n    \"#3300CC\",\n    \"#3300FF\",\n    \"#3333CC\",\n    \"#3333FF\",\n    \"#3366CC\",\n    \"#3366FF\",\n    \"#3399CC\",\n    \"#3399FF\",\n    \"#33CC00\",\n    \"#33CC33\",\n    \"#33CC66\",\n    \"#33CC99\",\n    \"#33CCCC\",\n    \"#33CCFF\",\n    \"#6600CC\",\n    \"#6600FF\",\n    \"#6633CC\",\n    \"#6633FF\",\n    \"#66CC00\",\n    \"#66CC33\",\n    \"#9900CC\",\n    \"#9900FF\",\n    \"#9933CC\",\n    \"#9933FF\",\n    \"#99CC00\",\n    \"#99CC33\",\n    \"#CC0000\",\n    \"#CC0033\",\n    \"#CC0066\",\n    \"#CC0099\",\n    \"#CC00CC\",\n    \"#CC00FF\",\n    \"#CC3300\",\n    \"#CC3333\",\n    \"#CC3366\",\n    \"#CC3399\",\n    \"#CC33CC\",\n    \"#CC33FF\",\n    \"#CC6600\",\n    \"#CC6633\",\n    \"#CC9900\",\n    \"#CC9933\",\n    \"#CCCC00\",\n    \"#CCCC33\",\n    \"#FF0000\",\n    \"#FF0033\",\n    \"#FF0066\",\n    \"#FF0099\",\n    \"#FF00CC\",\n    \"#FF00FF\",\n    \"#FF3300\",\n    \"#FF3333\",\n    \"#FF3366\",\n    \"#FF3399\",\n    \"#FF33CC\",\n    \"#FF33FF\",\n    \"#FF6600\",\n    \"#FF6633\",\n    \"#FF9900\",\n    \"#FF9933\",\n    \"#FFCC00\",\n    \"#FFCC33\"\n  ];\n  function r() {\n    return typeof window < \"u\" && window.process && (window.process.type === \"renderer\" || window.process.__nwjs) ? !0 : typeof navigator < \"u\" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/) ? !1 : typeof document < \"u\" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window < \"u\" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator < \"u\" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator < \"u\" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/);\n  }\n  function n(c) {\n    if (c[0] = (this.useColors ? \"%c\" : \"\") + this.namespace + (this.useColors ? \" %c\" : \" \") + c[0] + (this.useColors ? \"%c \" : \" \") + \"+\" + t.exports.humanize(this.diff), !this.useColors)\n      return;\n    const l = \"color: \" + this.color;\n    c.splice(1, 0, l, \"color: inherit\");\n    let f = 0, u = 0;\n    c[0].replace(/%[a-zA-Z%]/g, (h) => {\n      h !== \"%%\" && (f++, h === \"%c\" && (u = f));\n    }), c.splice(u, 0, l);\n  }\n  e.log = console.debug || console.log || (() => {\n  });\n  function i(c) {\n    try {\n      c ? e.storage.setItem(\"debug\", c) : e.storage.removeItem(\"debug\");\n    } catch {\n    }\n  }\n  function s() {\n    let c;\n    try {\n      c = e.storage.getItem(\"debug\");\n    } catch {\n    }\n    return !c && typeof process < \"u\" && \"env\" in process && (c = process.env.DEBUG), c;\n  }\n  function o() {\n    try {\n      return localStorage;\n    } catch {\n    }\n  }\n  t.exports = pc(e);\n  const { formatters: a } = t.exports;\n  a.j = function(c) {\n    try {\n      return JSON.stringify(c);\n    } catch (l) {\n      return \"[UnexpectedJSONParseError]: \" + l.message;\n    }\n  };\n})(On, On.exports);\nconst Mn = On.exports;\nvar Zo = { exports: {} };\n(function(t) {\n  var e = Object.prototype.hasOwnProperty, r = \"~\";\n  function n() {\n  }\n  Object.create && (n.prototype = /* @__PURE__ */ Object.create(null), new n().__proto__ || (r = !1));\n  function i(c, l, f) {\n    this.fn = c, this.context = l, this.once = f || !1;\n  }\n  function s(c, l, f, u, h) {\n    if (typeof f != \"function\")\n      throw new TypeError(\"The listener must be a function\");\n    var d = new i(f, u || c, h), p = r ? r + l : l;\n    return c._events[p] ? c._events[p].fn ? c._events[p] = [c._events[p], d] : c._events[p].push(d) : (c._events[p] = d, c._eventsCount++), c;\n  }\n  function o(c, l) {\n    --c._eventsCount === 0 ? c._events = new n() : delete c._events[l];\n  }\n  function a() {\n    this._events = new n(), this._eventsCount = 0;\n  }\n  a.prototype.eventNames = function() {\n    var l = [], f, u;\n    if (this._eventsCount === 0)\n      return l;\n    for (u in f = this._events)\n      e.call(f, u) && l.push(r ? u.slice(1) : u);\n    return Object.getOwnPropertySymbols ? l.concat(Object.getOwnPropertySymbols(f)) : l;\n  }, a.prototype.listeners = function(l) {\n    var f = r ? r + l : l, u = this._events[f];\n    if (!u)\n      return [];\n    if (u.fn)\n      return [u.fn];\n    for (var h = 0, d = u.length, p = new Array(d); h < d; h++)\n      p[h] = u[h].fn;\n    return p;\n  }, a.prototype.listenerCount = function(l) {\n    var f = r ? r + l : l, u = this._events[f];\n    return u ? u.fn ? 1 : u.length : 0;\n  }, a.prototype.emit = function(l, f, u, h, d, p) {\n    var y = r ? r + l : l;\n    if (!this._events[y])\n      return !1;\n    var g = this._events[y], v = arguments.length, _, m;\n    if (g.fn) {\n      switch (g.once && this.removeListener(l, g.fn, void 0, !0), v) {\n        case 1:\n          return g.fn.call(g.context), !0;\n        case 2:\n          return g.fn.call(g.context, f), !0;\n        case 3:\n          return g.fn.call(g.context, f, u), !0;\n        case 4:\n          return g.fn.call(g.context, f, u, h), !0;\n        case 5:\n          return g.fn.call(g.context, f, u, h, d), !0;\n        case 6:\n          return g.fn.call(g.context, f, u, h, d, p), !0;\n      }\n      for (m = 1, _ = new Array(v - 1); m < v; m++)\n        _[m - 1] = arguments[m];\n      g.fn.apply(g.context, _);\n    } else {\n      var C = g.length, O;\n      for (m = 0; m < C; m++)\n        switch (g[m].once && this.removeListener(l, g[m].fn, void 0, !0), v) {\n          case 1:\n            g[m].fn.call(g[m].context);\n            break;\n          case 2:\n            g[m].fn.call(g[m].context, f);\n            break;\n          case 3:\n            g[m].fn.call(g[m].context, f, u);\n            break;\n          case 4:\n            g[m].fn.call(g[m].context, f, u, h);\n            break;\n          default:\n            if (!_)\n              for (O = 1, _ = new Array(v - 1); O < v; O++)\n                _[O - 1] = arguments[O];\n            g[m].fn.apply(g[m].context, _);\n        }\n    }\n    return !0;\n  }, a.prototype.on = function(l, f, u) {\n    return s(this, l, f, u, !1);\n  }, a.prototype.once = function(l, f, u) {\n    return s(this, l, f, u, !0);\n  }, a.prototype.removeListener = function(l, f, u, h) {\n    var d = r ? r + l : l;\n    if (!this._events[d])\n      return this;\n    if (!f)\n      return o(this, d), this;\n    var p = this._events[d];\n    if (p.fn)\n      p.fn === f && (!h || p.once) && (!u || p.context === u) && o(this, d);\n    else {\n      for (var y = 0, g = [], v = p.length; y < v; y++)\n        (p[y].fn !== f || h && !p[y].once || u && p[y].context !== u) && g.push(p[y]);\n      g.length ? this._events[d] = g.length === 1 ? g[0] : g : o(this, d);\n    }\n    return this;\n  }, a.prototype.removeAllListeners = function(l) {\n    var f;\n    return l ? (f = r ? r + l : l, this._events[f] && o(this, f)) : (this._events = new n(), this._eventsCount = 0), this;\n  }, a.prototype.off = a.prototype.removeListener, a.prototype.addListener = a.prototype.on, a.prefixed = r, a.EventEmitter = a, t.exports = a;\n})(Zo);\nconst dt = Zo.exports;\nfunction An(t) {\n  if (!Number.isSafeInteger(t) || t < 0)\n    throw new Error(`Wrong positive integer: ${t}`);\n}\nfunction yc(t) {\n  if (typeof t != \"boolean\")\n    throw new Error(`Expected boolean, not ${t}`);\n}\nfunction Yo(t, ...e) {\n  if (!(t instanceof Uint8Array))\n    throw new TypeError(\"Expected Uint8Array\");\n  if (e.length > 0 && !e.includes(t.length))\n    throw new TypeError(`Expected Uint8Array of length ${e}, not of length=${t.length}`);\n}\nfunction gc(t) {\n  if (typeof t != \"function\" || typeof t.create != \"function\")\n    throw new Error(\"Hash should be wrapped by utils.wrapConstructor\");\n  An(t.outputLen), An(t.blockLen);\n}\nfunction bc(t, e = !0) {\n  if (t.destroyed)\n    throw new Error(\"Hash instance has been destroyed\");\n  if (e && t.finished)\n    throw new Error(\"Hash#digest() has already been called\");\n}\nfunction vc(t, e) {\n  Yo(t);\n  const r = e.outputLen;\n  if (t.length < r)\n    throw new Error(`digestInto() expects output buffer of length at least ${r}`);\n}\nconst ut = {\n  number: An,\n  bool: yc,\n  bytes: Yo,\n  hash: gc,\n  exists: bc,\n  output: vc\n}, tn = typeof globalThis == \"object\" && \"crypto\" in globalThis ? globalThis.crypto : void 0;\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst rn = (t) => new DataView(t.buffer, t.byteOffset, t.byteLength), Ae = (t, e) => t << 32 - e | t >>> e, wc = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;\nif (!wc)\n  throw new Error(\"Non little-endian hardware is not supported\");\nArray.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, \"0\"));\nfunction _c(t) {\n  if (typeof t != \"string\")\n    throw new TypeError(`utf8ToBytes expected string, got ${typeof t}`);\n  return new TextEncoder().encode(t);\n}\nfunction Dn(t) {\n  if (typeof t == \"string\" && (t = _c(t)), !(t instanceof Uint8Array))\n    throw new TypeError(`Expected input type is Uint8Array (got ${typeof t})`);\n  return t;\n}\nfunction mc(...t) {\n  if (!t.every((n) => n instanceof Uint8Array))\n    throw new Error(\"Uint8Array list expected\");\n  if (t.length === 1)\n    return t[0];\n  const e = t.reduce((n, i) => n + i.length, 0), r = new Uint8Array(e);\n  for (let n = 0, i = 0; n < t.length; n++) {\n    const s = t[n];\n    r.set(s, i), i += s.length;\n  }\n  return r;\n}\nclass Jo {\n  clone() {\n    return this._cloneInto();\n  }\n}\nfunction Xo(t) {\n  const e = (n) => t().update(Dn(n)).digest(), r = t();\n  return e.outputLen = r.outputLen, e.blockLen = r.blockLen, e.create = () => t(), e;\n}\nfunction Qo(t = 32) {\n  if (tn && typeof tn.getRandomValues == \"function\")\n    return tn.getRandomValues(new Uint8Array(t));\n  throw new Error(\"crypto.getRandomValues must be defined\");\n}\nfunction xc(t, e, r, n) {\n  if (typeof t.setBigUint64 == \"function\")\n    return t.setBigUint64(e, r, n);\n  const i = BigInt(32), s = BigInt(4294967295), o = Number(r >> i & s), a = Number(r & s), c = n ? 4 : 0, l = n ? 0 : 4;\n  t.setUint32(e + c, o, n), t.setUint32(e + l, a, n);\n}\nclass Ec extends Jo {\n  constructor(e, r, n, i) {\n    super(), this.blockLen = e, this.outputLen = r, this.padOffset = n, this.isLE = i, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = rn(this.buffer);\n  }\n  update(e) {\n    ut.exists(this);\n    const { view: r, buffer: n, blockLen: i } = this;\n    e = Dn(e);\n    const s = e.length;\n    for (let o = 0; o < s; ) {\n      const a = Math.min(i - this.pos, s - o);\n      if (a === i) {\n        const c = rn(e);\n        for (; i <= s - o; o += i)\n          this.process(c, o);\n        continue;\n      }\n      n.set(e.subarray(o, o + a), this.pos), this.pos += a, o += a, this.pos === i && (this.process(r, 0), this.pos = 0);\n    }\n    return this.length += e.length, this.roundClean(), this;\n  }\n  digestInto(e) {\n    ut.exists(this), ut.output(e, this), this.finished = !0;\n    const { buffer: r, view: n, blockLen: i, isLE: s } = this;\n    let { pos: o } = this;\n    r[o++] = 128, this.buffer.subarray(o).fill(0), this.padOffset > i - o && (this.process(n, 0), o = 0);\n    for (let u = o; u < i; u++)\n      r[u] = 0;\n    xc(n, i - 8, BigInt(this.length * 8), s), this.process(n, 0);\n    const a = rn(e), c = this.outputLen;\n    if (c % 4)\n      throw new Error(\"_sha2: outputLen should be aligned to 32bit\");\n    const l = c / 4, f = this.get();\n    if (l > f.length)\n      throw new Error(\"_sha2: outputLen bigger than state\");\n    for (let u = 0; u < l; u++)\n      a.setUint32(4 * u, f[u], s);\n  }\n  digest() {\n    const { buffer: e, outputLen: r } = this;\n    this.digestInto(e);\n    const n = e.slice(0, r);\n    return this.destroy(), n;\n  }\n  _cloneInto(e) {\n    e || (e = new this.constructor()), e.set(...this.get());\n    const { blockLen: r, buffer: n, length: i, finished: s, destroyed: o, pos: a } = this;\n    return e.length = i, e.pos = a, e.finished = s, e.destroyed = o, i % r && e.buffer.set(n), e;\n  }\n}\nconst kc = (t, e, r) => t & e ^ ~t & r, Sc = (t, e, r) => t & e ^ t & r ^ e & r, Oc = new Uint32Array([\n  1116352408,\n  1899447441,\n  3049323471,\n  3921009573,\n  961987163,\n  1508970993,\n  2453635748,\n  2870763221,\n  3624381080,\n  310598401,\n  607225278,\n  1426881987,\n  1925078388,\n  2162078206,\n  2614888103,\n  3248222580,\n  3835390401,\n  4022224774,\n  264347078,\n  604807628,\n  770255983,\n  1249150122,\n  1555081692,\n  1996064986,\n  2554220882,\n  2821834349,\n  2952996808,\n  3210313671,\n  3336571891,\n  3584528711,\n  113926993,\n  338241895,\n  666307205,\n  773529912,\n  1294757372,\n  1396182291,\n  1695183700,\n  1986661051,\n  2177026350,\n  2456956037,\n  2730485921,\n  2820302411,\n  3259730800,\n  3345764771,\n  3516065817,\n  3600352804,\n  4094571909,\n  275423344,\n  430227734,\n  506948616,\n  659060556,\n  883997877,\n  958139571,\n  1322822218,\n  1537002063,\n  1747873779,\n  1955562222,\n  2024104815,\n  2227730452,\n  2361852424,\n  2428436474,\n  2756734187,\n  3204031479,\n  3329325298\n]), Me = new Uint32Array([\n  1779033703,\n  3144134277,\n  1013904242,\n  2773480762,\n  1359893119,\n  2600822924,\n  528734635,\n  1541459225\n]), De = new Uint32Array(64);\nclass es extends Ec {\n  constructor() {\n    super(64, 32, 8, !1), this.A = Me[0] | 0, this.B = Me[1] | 0, this.C = Me[2] | 0, this.D = Me[3] | 0, this.E = Me[4] | 0, this.F = Me[5] | 0, this.G = Me[6] | 0, this.H = Me[7] | 0;\n  }\n  get() {\n    const { A: e, B: r, C: n, D: i, E: s, F: o, G: a, H: c } = this;\n    return [e, r, n, i, s, o, a, c];\n  }\n  set(e, r, n, i, s, o, a, c) {\n    this.A = e | 0, this.B = r | 0, this.C = n | 0, this.D = i | 0, this.E = s | 0, this.F = o | 0, this.G = a | 0, this.H = c | 0;\n  }\n  process(e, r) {\n    for (let u = 0; u < 16; u++, r += 4)\n      De[u] = e.getUint32(r, !1);\n    for (let u = 16; u < 64; u++) {\n      const h = De[u - 15], d = De[u - 2], p = Ae(h, 7) ^ Ae(h, 18) ^ h >>> 3, y = Ae(d, 17) ^ Ae(d, 19) ^ d >>> 10;\n      De[u] = y + De[u - 7] + p + De[u - 16] | 0;\n    }\n    let { A: n, B: i, C: s, D: o, E: a, F: c, G: l, H: f } = this;\n    for (let u = 0; u < 64; u++) {\n      const h = Ae(a, 6) ^ Ae(a, 11) ^ Ae(a, 25), d = f + h + kc(a, c, l) + Oc[u] + De[u] | 0, y = (Ae(n, 2) ^ Ae(n, 13) ^ Ae(n, 22)) + Sc(n, i, s) | 0;\n      f = l, l = c, c = a, a = o + d | 0, o = s, s = i, i = n, n = d + y | 0;\n    }\n    n = n + this.A | 0, i = i + this.B | 0, s = s + this.C | 0, o = o + this.D | 0, a = a + this.E | 0, c = c + this.F | 0, l = l + this.G | 0, f = f + this.H | 0, this.set(n, i, s, o, a, c, l, f);\n  }\n  roundClean() {\n    De.fill(0);\n  }\n  destroy() {\n    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);\n  }\n}\nclass Ac extends es {\n  constructor() {\n    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;\n  }\n}\nconst Or = Xo(() => new es());\nXo(() => new Ac());\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst ts = BigInt(0), Lr = BigInt(1), Cc = BigInt(2), $r = (t) => t instanceof Uint8Array, Ic = Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, \"0\"));\nfunction vt(t) {\n  if (!$r(t))\n    throw new Error(\"Uint8Array expected\");\n  let e = \"\";\n  for (let r = 0; r < t.length; r++)\n    e += Ic[t[r]];\n  return e;\n}\nfunction rs(t) {\n  const e = t.toString(16);\n  return e.length & 1 ? `0${e}` : e;\n}\nfunction zn(t) {\n  if (typeof t != \"string\")\n    throw new Error(\"hex string expected, got \" + typeof t);\n  return BigInt(t === \"\" ? \"0\" : `0x${t}`);\n}\nfunction wt(t) {\n  if (typeof t != \"string\")\n    throw new Error(\"hex string expected, got \" + typeof t);\n  if (t.length % 2)\n    throw new Error(\"hex string is invalid: unpadded \" + t.length);\n  const e = new Uint8Array(t.length / 2);\n  for (let r = 0; r < e.length; r++) {\n    const n = r * 2, i = t.slice(n, n + 2), s = Number.parseInt(i, 16);\n    if (Number.isNaN(s) || s < 0)\n      throw new Error(\"invalid byte sequence\");\n    e[r] = s;\n  }\n  return e;\n}\nfunction le(t) {\n  return zn(vt(t));\n}\nfunction Fn(t) {\n  if (!$r(t))\n    throw new Error(\"Uint8Array expected\");\n  return zn(vt(Uint8Array.from(t).reverse()));\n}\nconst et = (t, e) => wt(t.toString(16).padStart(e * 2, \"0\")), ns = (t, e) => et(t, e).reverse(), Rc = (t) => wt(rs(t));\nfunction ee(t, e, r) {\n  let n;\n  if (typeof e == \"string\")\n    try {\n      n = wt(e);\n    } catch (s) {\n      throw new Error(`${t} must be valid hex string, got \"${e}\". Cause: ${s}`);\n    }\n  else if ($r(e))\n    n = Uint8Array.from(e);\n  else\n    throw new Error(`${t} must be hex string or Uint8Array`);\n  const i = n.length;\n  if (typeof r == \"number\" && i !== r)\n    throw new Error(`${t} expected ${r} bytes, got ${i}`);\n  return n;\n}\nfunction he(...t) {\n  const e = new Uint8Array(t.reduce((n, i) => n + i.length, 0));\n  let r = 0;\n  return t.forEach((n) => {\n    if (!$r(n))\n      throw new Error(\"Uint8Array expected\");\n    e.set(n, r), r += n.length;\n  }), e;\n}\nfunction Tc(t, e) {\n  if (t.length !== e.length)\n    return !1;\n  for (let r = 0; r < t.length; r++)\n    if (t[r] !== e[r])\n      return !1;\n  return !0;\n}\nfunction qr(t) {\n  if (typeof t != \"string\")\n    throw new Error(`utf8ToBytes expected string, got ${typeof t}`);\n  return new TextEncoder().encode(t);\n}\nfunction Pc(t) {\n  let e;\n  for (e = 0; t > ts; t >>= Lr, e += 1)\n    ;\n  return e;\n}\nconst Bc = (t, e) => t >> BigInt(e) & Lr, Lc = (t, e, r) => t | (r ? Lr : ts) << BigInt(e), Kn = (t) => (Cc << BigInt(t - 1)) - Lr, nn = (t) => new Uint8Array(t), Ni = (t) => Uint8Array.from(t);\nfunction is(t, e, r) {\n  if (typeof t != \"number\" || t < 2)\n    throw new Error(\"hashLen must be a number\");\n  if (typeof e != \"number\" || e < 2)\n    throw new Error(\"qByteLen must be a number\");\n  if (typeof r != \"function\")\n    throw new Error(\"hmacFn must be a function\");\n  let n = nn(t), i = nn(t), s = 0;\n  const o = () => {\n    n.fill(1), i.fill(0), s = 0;\n  }, a = (...u) => r(i, n, ...u), c = (u = nn()) => {\n    i = a(Ni([0]), u), n = a(), u.length !== 0 && (i = a(Ni([1]), u), n = a());\n  }, l = () => {\n    if (s++ >= 1e3)\n      throw new Error(\"drbg: tried 1000 values\");\n    let u = 0;\n    const h = [];\n    for (; u < e; ) {\n      n = a();\n      const d = n.slice();\n      h.push(d), u += n.length;\n    }\n    return he(...h);\n  };\n  return (u, h) => {\n    o(), c(u);\n    let d;\n    for (; !(d = h(l())); )\n      c();\n    return o(), d;\n  };\n}\nconst $c = {\n  bigint: (t) => typeof t == \"bigint\",\n  function: (t) => typeof t == \"function\",\n  boolean: (t) => typeof t == \"boolean\",\n  string: (t) => typeof t == \"string\",\n  isSafeInteger: (t) => Number.isSafeInteger(t),\n  array: (t) => Array.isArray(t),\n  field: (t, e) => e.Fp.isValid(t),\n  hash: (t) => typeof t == \"function\" && Number.isSafeInteger(t.outputLen)\n};\nfunction kt(t, e, r = {}) {\n  const n = (i, s, o) => {\n    const a = $c[s];\n    if (typeof a != \"function\")\n      throw new Error(`Invalid validator \"${s}\", expected function`);\n    const c = t[i];\n    if (!(o && c === void 0) && !a(c, t))\n      throw new Error(`Invalid param ${String(i)}=${c} (${typeof c}), expected ${s}`);\n  };\n  for (const [i, s] of Object.entries(e))\n    n(i, s, !1);\n  for (const [i, s] of Object.entries(r))\n    n(i, s, !0);\n  return t;\n}\nconst qc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  bytesToHex: vt,\n  numberToHexUnpadded: rs,\n  hexToNumber: zn,\n  hexToBytes: wt,\n  bytesToNumberBE: le,\n  bytesToNumberLE: Fn,\n  numberToBytesBE: et,\n  numberToBytesLE: ns,\n  numberToVarBytesBE: Rc,\n  ensureBytes: ee,\n  concatBytes: he,\n  equalBytes: Tc,\n  utf8ToBytes: qr,\n  bitLen: Pc,\n  bitGet: Bc,\n  bitSet: Lc,\n  bitMask: Kn,\n  createHmacDrbg: is,\n  validateObject: kt\n}, Symbol.toStringTag, { value: \"Module\" }));\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst Q = BigInt(0), V = BigInt(1), at = BigInt(2), Nc = BigInt(3), Cn = BigInt(4), Ui = BigInt(5), ji = BigInt(8);\nBigInt(9);\nBigInt(16);\nfunction J(t, e) {\n  const r = t % e;\n  return r >= Q ? r : e + r;\n}\nfunction Uc(t, e, r) {\n  if (r <= Q || e < Q)\n    throw new Error(\"Expected power/modulo > 0\");\n  if (r === V)\n    return Q;\n  let n = V;\n  for (; e > Q; )\n    e & V && (n = n * t % r), t = t * t % r, e >>= V;\n  return n;\n}\nfunction be(t, e, r) {\n  let n = t;\n  for (; e-- > Q; )\n    n *= n, n %= r;\n  return n;\n}\nfunction In(t, e) {\n  if (t === Q || e <= Q)\n    throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);\n  let r = J(t, e), n = e, i = Q, s = V;\n  for (; r !== Q; ) {\n    const a = n / r, c = n % r, l = i - s * a;\n    n = r, r = c, i = s, s = l;\n  }\n  if (n !== V)\n    throw new Error(\"invert: does not exist\");\n  return J(i, e);\n}\nfunction jc(t) {\n  const e = (t - V) / at;\n  let r, n, i;\n  for (r = t - V, n = 0; r % at === Q; r /= at, n++)\n    ;\n  for (i = at; i < t && Uc(i, e, t) !== t - V; i++)\n    ;\n  if (n === 1) {\n    const o = (t + V) / Cn;\n    return function(c, l) {\n      const f = c.pow(l, o);\n      if (!c.eql(c.sqr(f), l))\n        throw new Error(\"Cannot find square root\");\n      return f;\n    };\n  }\n  const s = (r + V) / at;\n  return function(a, c) {\n    if (a.pow(c, e) === a.neg(a.ONE))\n      throw new Error(\"Cannot find square root\");\n    let l = n, f = a.pow(a.mul(a.ONE, i), r), u = a.pow(c, s), h = a.pow(c, r);\n    for (; !a.eql(h, a.ONE); ) {\n      if (a.eql(h, a.ZERO))\n        return a.ZERO;\n      let d = 1;\n      for (let y = a.sqr(h); d < l && !a.eql(y, a.ONE); d++)\n        y = a.sqr(y);\n      const p = a.pow(f, V << BigInt(l - d - 1));\n      f = a.sqr(p), u = a.mul(u, p), h = a.mul(h, f), l = d;\n    }\n    return u;\n  };\n}\nfunction Hc(t) {\n  if (t % Cn === Nc) {\n    const e = (t + V) / Cn;\n    return function(n, i) {\n      const s = n.pow(i, e);\n      if (!n.eql(n.sqr(s), i))\n        throw new Error(\"Cannot find square root\");\n      return s;\n    };\n  }\n  if (t % ji === Ui) {\n    const e = (t - Ui) / ji;\n    return function(n, i) {\n      const s = n.mul(i, at), o = n.pow(s, e), a = n.mul(i, o), c = n.mul(n.mul(a, at), o), l = n.mul(a, n.sub(c, n.ONE));\n      if (!n.eql(n.sqr(l), i))\n        throw new Error(\"Cannot find square root\");\n      return l;\n    };\n  }\n  return jc(t);\n}\nconst Mc = [\n  \"create\",\n  \"isValid\",\n  \"is0\",\n  \"neg\",\n  \"inv\",\n  \"sqrt\",\n  \"sqr\",\n  \"eql\",\n  \"add\",\n  \"sub\",\n  \"mul\",\n  \"pow\",\n  \"div\",\n  \"addN\",\n  \"subN\",\n  \"mulN\",\n  \"sqrN\"\n];\nfunction os(t) {\n  const e = {\n    ORDER: \"bigint\",\n    MASK: \"bigint\",\n    BYTES: \"isSafeInteger\",\n    BITS: \"isSafeInteger\"\n  }, r = Mc.reduce((n, i) => (n[i] = \"function\", n), e);\n  return kt(t, r);\n}\nfunction Dc(t, e, r) {\n  if (r < Q)\n    throw new Error(\"Expected power > 0\");\n  if (r === Q)\n    return t.ONE;\n  if (r === V)\n    return e;\n  let n = t.ONE, i = e;\n  for (; r > Q; )\n    r & V && (n = t.mul(n, i)), i = t.sqr(i), r >>= V;\n  return n;\n}\nfunction zc(t, e) {\n  const r = new Array(e.length), n = e.reduce((s, o, a) => t.is0(o) ? s : (r[a] = s, t.mul(s, o)), t.ONE), i = t.inv(n);\n  return e.reduceRight((s, o, a) => t.is0(o) ? s : (r[a] = t.mul(s, r[a]), t.mul(s, o)), i), r;\n}\nfunction Wn(t, e) {\n  const r = e !== void 0 ? e : t.toString(2).length, n = Math.ceil(r / 8);\n  return { nBitLength: r, nByteLength: n };\n}\nfunction Fc(t, e, r = !1, n = {}) {\n  if (t <= Q)\n    throw new Error(`Expected Fp ORDER > 0, got ${t}`);\n  const { nBitLength: i, nByteLength: s } = Wn(t, e);\n  if (s > 2048)\n    throw new Error(\"Field lengths over 2048 bytes are not supported\");\n  const o = Hc(t), a = Object.freeze({\n    ORDER: t,\n    BITS: i,\n    BYTES: s,\n    MASK: Kn(i),\n    ZERO: Q,\n    ONE: V,\n    create: (c) => J(c, t),\n    isValid: (c) => {\n      if (typeof c != \"bigint\")\n        throw new Error(`Invalid field element: expected bigint, got ${typeof c}`);\n      return Q <= c && c < t;\n    },\n    is0: (c) => c === Q,\n    isOdd: (c) => (c & V) === V,\n    neg: (c) => J(-c, t),\n    eql: (c, l) => c === l,\n    sqr: (c) => J(c * c, t),\n    add: (c, l) => J(c + l, t),\n    sub: (c, l) => J(c - l, t),\n    mul: (c, l) => J(c * l, t),\n    pow: (c, l) => Dc(a, c, l),\n    div: (c, l) => J(c * In(l, t), t),\n    sqrN: (c) => c * c,\n    addN: (c, l) => c + l,\n    subN: (c, l) => c - l,\n    mulN: (c, l) => c * l,\n    inv: (c) => In(c, t),\n    sqrt: n.sqrt || ((c) => o(a, c)),\n    invertBatch: (c) => zc(a, c),\n    cmov: (c, l, f) => f ? l : c,\n    toBytes: (c) => r ? ns(c, s) : et(c, s),\n    fromBytes: (c) => {\n      if (c.length !== s)\n        throw new Error(`Fp.fromBytes: expected ${s}, got ${c.length}`);\n      return r ? Fn(c) : le(c);\n    }\n  });\n  return Object.freeze(a);\n}\nfunction Kc(t, e, r = !1) {\n  t = ee(\"privateHash\", t);\n  const n = t.length, i = Wn(e).nByteLength + 8;\n  if (i < 24 || n < i || n > 1024)\n    throw new Error(`hashToPrivateScalar: expected ${i}-1024 bytes of input, got ${n}`);\n  const s = r ? Fn(t) : le(t);\n  return J(s, e - V) + V;\n}\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst Wc = BigInt(0), on = BigInt(1);\nfunction Vc(t, e) {\n  const r = (i, s) => {\n    const o = s.negate();\n    return i ? o : s;\n  }, n = (i) => {\n    const s = Math.ceil(e / i) + 1, o = 2 ** (i - 1);\n    return { windows: s, windowSize: o };\n  };\n  return {\n    constTimeNegate: r,\n    unsafeLadder(i, s) {\n      let o = t.ZERO, a = i;\n      for (; s > Wc; )\n        s & on && (o = o.add(a)), a = a.double(), s >>= on;\n      return o;\n    },\n    precomputeWindow(i, s) {\n      const { windows: o, windowSize: a } = n(s), c = [];\n      let l = i, f = l;\n      for (let u = 0; u < o; u++) {\n        f = l, c.push(f);\n        for (let h = 1; h < a; h++)\n          f = f.add(l), c.push(f);\n        l = f.double();\n      }\n      return c;\n    },\n    wNAF(i, s, o) {\n      const { windows: a, windowSize: c } = n(i);\n      let l = t.ZERO, f = t.BASE;\n      const u = BigInt(2 ** i - 1), h = 2 ** i, d = BigInt(i);\n      for (let p = 0; p < a; p++) {\n        const y = p * c;\n        let g = Number(o & u);\n        o >>= d, g > c && (g -= h, o += on);\n        const v = y, _ = y + Math.abs(g) - 1, m = p % 2 !== 0, C = g < 0;\n        g === 0 ? f = f.add(r(m, s[v])) : l = l.add(r(C, s[_]));\n      }\n      return { p: l, f };\n    },\n    wNAFCached(i, s, o, a) {\n      const c = i._WINDOW_SIZE || 1;\n      let l = s.get(i);\n      return l || (l = this.precomputeWindow(i, c), c !== 1 && s.set(i, a(l))), this.wNAF(c, l, o);\n    }\n  };\n}\nfunction ss(t) {\n  return os(t.Fp), kt(t, {\n    n: \"bigint\",\n    h: \"bigint\",\n    Gx: \"field\",\n    Gy: \"field\"\n  }, {\n    nBitLength: \"isSafeInteger\",\n    nByteLength: \"isSafeInteger\"\n  }), Object.freeze({\n    ...Wn(t.n, t.nBitLength),\n    ...t,\n    p: t.Fp.ORDER\n  });\n}\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nfunction Gc(t) {\n  const e = ss(t);\n  kt(e, {\n    a: \"field\",\n    b: \"field\"\n  }, {\n    allowedPrivateKeyLengths: \"array\",\n    wrapPrivateKey: \"boolean\",\n    isTorsionFree: \"function\",\n    clearCofactor: \"function\",\n    allowInfinityPoint: \"boolean\",\n    fromBytes: \"function\",\n    toBytes: \"function\"\n  });\n  const { endo: r, Fp: n, a: i } = e;\n  if (r) {\n    if (!n.eql(i, n.ZERO))\n      throw new Error(\"Endomorphism can only be defined for Koblitz curves that have a=0\");\n    if (typeof r != \"object\" || typeof r.beta != \"bigint\" || typeof r.splitScalar != \"function\")\n      throw new Error(\"Expected endomorphism with beta: bigint and splitScalar: function\");\n  }\n  return Object.freeze({ ...e });\n}\nconst { bytesToNumberBE: Zc, hexToBytes: Yc } = qc, lt = {\n  Err: class extends Error {\n    constructor(e = \"\") {\n      super(e);\n    }\n  },\n  _parseInt(t) {\n    const { Err: e } = lt;\n    if (t.length < 2 || t[0] !== 2)\n      throw new e(\"Invalid signature integer tag\");\n    const r = t[1], n = t.subarray(2, r + 2);\n    if (!r || n.length !== r)\n      throw new e(\"Invalid signature integer: wrong length\");\n    if (n[0] & 128)\n      throw new e(\"Invalid signature integer: negative\");\n    if (n[0] === 0 && !(n[1] & 128))\n      throw new e(\"Invalid signature integer: unnecessary leading zero\");\n    return { d: Zc(n), l: t.subarray(r + 2) };\n  },\n  toSig(t) {\n    const { Err: e } = lt, r = typeof t == \"string\" ? Yc(t) : t;\n    if (!(r instanceof Uint8Array))\n      throw new Error(\"ui8a expected\");\n    let n = r.length;\n    if (n < 2 || r[0] != 48)\n      throw new e(\"Invalid signature tag\");\n    if (r[1] !== n - 2)\n      throw new e(\"Invalid signature: incorrect length\");\n    const { d: i, l: s } = lt._parseInt(r.subarray(2)), { d: o, l: a } = lt._parseInt(s);\n    if (a.length)\n      throw new e(\"Invalid signature: left bytes after parsing\");\n    return { r: i, s: o };\n  },\n  hexFromSig(t) {\n    const e = (l) => Number.parseInt(l[0], 16) & 8 ? \"00\" + l : l, r = (l) => {\n      const f = l.toString(16);\n      return f.length & 1 ? `0${f}` : f;\n    }, n = e(r(t.s)), i = e(r(t.r)), s = n.length / 2, o = i.length / 2, a = r(s), c = r(o);\n    return `30${r(o + s + 4)}02${c}${i}02${a}${n}`;\n  }\n}, ke = BigInt(0), Y = BigInt(1), $e = BigInt(2), Ar = BigInt(3), Hi = BigInt(4);\nfunction Jc(t) {\n  const e = Gc(t), { Fp: r } = e, n = e.toBytes || ((p, y, g) => {\n    const v = y.toAffine();\n    return he(Uint8Array.from([4]), r.toBytes(v.x), r.toBytes(v.y));\n  }), i = e.fromBytes || ((p) => {\n    const y = p.subarray(1), g = r.fromBytes(y.subarray(0, r.BYTES)), v = r.fromBytes(y.subarray(r.BYTES, 2 * r.BYTES));\n    return { x: g, y: v };\n  });\n  function s(p) {\n    const { a: y, b: g } = e, v = r.sqr(p), _ = r.mul(v, p);\n    return r.add(r.add(_, r.mul(p, y)), g);\n  }\n  if (!r.eql(r.sqr(e.Gy), s(e.Gx)))\n    throw new Error(\"bad generator point: equation left != right\");\n  function o(p) {\n    return typeof p == \"bigint\" && ke < p && p < e.n;\n  }\n  function a(p) {\n    if (!o(p))\n      throw new Error(\"Expected valid bigint: 0 < bigint < curve.n\");\n  }\n  function c(p) {\n    const { allowedPrivateKeyLengths: y, nByteLength: g, wrapPrivateKey: v, n: _ } = e;\n    if (y && typeof p != \"bigint\") {\n      if (p instanceof Uint8Array && (p = vt(p)), typeof p != \"string\" || !y.includes(p.length))\n        throw new Error(\"Invalid key\");\n      p = p.padStart(g * 2, \"0\");\n    }\n    let m;\n    try {\n      m = typeof p == \"bigint\" ? p : le(ee(\"private key\", p, g));\n    } catch {\n      throw new Error(`private key must be ${g} bytes, hex or bigint, not ${typeof p}`);\n    }\n    return v && (m = J(m, _)), a(m), m;\n  }\n  const l = /* @__PURE__ */ new Map();\n  function f(p) {\n    if (!(p instanceof u))\n      throw new Error(\"ProjectivePoint expected\");\n  }\n  class u {\n    constructor(y, g, v) {\n      if (this.px = y, this.py = g, this.pz = v, y == null || !r.isValid(y))\n        throw new Error(\"x required\");\n      if (g == null || !r.isValid(g))\n        throw new Error(\"y required\");\n      if (v == null || !r.isValid(v))\n        throw new Error(\"z required\");\n    }\n    static fromAffine(y) {\n      const { x: g, y: v } = y || {};\n      if (!y || !r.isValid(g) || !r.isValid(v))\n        throw new Error(\"invalid affine point\");\n      if (y instanceof u)\n        throw new Error(\"projective point not allowed\");\n      const _ = (m) => r.eql(m, r.ZERO);\n      return _(g) && _(v) ? u.ZERO : new u(g, v, r.ONE);\n    }\n    get x() {\n      return this.toAffine().x;\n    }\n    get y() {\n      return this.toAffine().y;\n    }\n    static normalizeZ(y) {\n      const g = r.invertBatch(y.map((v) => v.pz));\n      return y.map((v, _) => v.toAffine(g[_])).map(u.fromAffine);\n    }\n    static fromHex(y) {\n      const g = u.fromAffine(i(ee(\"pointHex\", y)));\n      return g.assertValidity(), g;\n    }\n    static fromPrivateKey(y) {\n      return u.BASE.multiply(c(y));\n    }\n    _setWindowSize(y) {\n      this._WINDOW_SIZE = y, l.delete(this);\n    }\n    assertValidity() {\n      if (this.is0()) {\n        if (e.allowInfinityPoint)\n          return;\n        throw new Error(\"bad point: ZERO\");\n      }\n      const { x: y, y: g } = this.toAffine();\n      if (!r.isValid(y) || !r.isValid(g))\n        throw new Error(\"bad point: x or y not FE\");\n      const v = r.sqr(g), _ = s(y);\n      if (!r.eql(v, _))\n        throw new Error(\"bad point: equation left != right\");\n      if (!this.isTorsionFree())\n        throw new Error(\"bad point: not in prime-order subgroup\");\n    }\n    hasEvenY() {\n      const { y } = this.toAffine();\n      if (r.isOdd)\n        return !r.isOdd(y);\n      throw new Error(\"Field doesn't support isOdd\");\n    }\n    equals(y) {\n      f(y);\n      const { px: g, py: v, pz: _ } = this, { px: m, py: C, pz: O } = y, w = r.eql(r.mul(g, O), r.mul(m, _)), x = r.eql(r.mul(v, O), r.mul(C, _));\n      return w && x;\n    }\n    negate() {\n      return new u(this.px, r.neg(this.py), this.pz);\n    }\n    double() {\n      const { a: y, b: g } = e, v = r.mul(g, Ar), { px: _, py: m, pz: C } = this;\n      let O = r.ZERO, w = r.ZERO, x = r.ZERO, A = r.mul(_, _), B = r.mul(m, m), L = r.mul(C, C), P = r.mul(_, m);\n      return P = r.add(P, P), x = r.mul(_, C), x = r.add(x, x), O = r.mul(y, x), w = r.mul(v, L), w = r.add(O, w), O = r.sub(B, w), w = r.add(B, w), w = r.mul(O, w), O = r.mul(P, O), x = r.mul(v, x), L = r.mul(y, L), P = r.sub(A, L), P = r.mul(y, P), P = r.add(P, x), x = r.add(A, A), A = r.add(x, A), A = r.add(A, L), A = r.mul(A, P), w = r.add(w, A), L = r.mul(m, C), L = r.add(L, L), A = r.mul(L, P), O = r.sub(O, A), x = r.mul(L, B), x = r.add(x, x), x = r.add(x, x), new u(O, w, x);\n    }\n    add(y) {\n      f(y);\n      const { px: g, py: v, pz: _ } = this, { px: m, py: C, pz: O } = y;\n      let w = r.ZERO, x = r.ZERO, A = r.ZERO;\n      const B = e.a, L = r.mul(e.b, Ar);\n      let P = r.mul(g, m), F = r.mul(v, C), z = r.mul(_, O), G = r.add(g, v), E = r.add(m, C);\n      G = r.mul(G, E), E = r.add(P, F), G = r.sub(G, E), E = r.add(g, _);\n      let R = r.add(m, O);\n      return E = r.mul(E, R), R = r.add(P, z), E = r.sub(E, R), R = r.add(v, _), w = r.add(C, O), R = r.mul(R, w), w = r.add(F, z), R = r.sub(R, w), A = r.mul(B, E), w = r.mul(L, z), A = r.add(w, A), w = r.sub(F, A), A = r.add(F, A), x = r.mul(w, A), F = r.add(P, P), F = r.add(F, P), z = r.mul(B, z), E = r.mul(L, E), F = r.add(F, z), z = r.sub(P, z), z = r.mul(B, z), E = r.add(E, z), P = r.mul(F, E), x = r.add(x, P), P = r.mul(R, E), w = r.mul(G, w), w = r.sub(w, P), P = r.mul(G, F), A = r.mul(R, A), A = r.add(A, P), new u(w, x, A);\n    }\n    subtract(y) {\n      return this.add(y.negate());\n    }\n    is0() {\n      return this.equals(u.ZERO);\n    }\n    wNAF(y) {\n      return d.wNAFCached(this, l, y, (g) => {\n        const v = r.invertBatch(g.map((_) => _.pz));\n        return g.map((_, m) => _.toAffine(v[m])).map(u.fromAffine);\n      });\n    }\n    multiplyUnsafe(y) {\n      const g = u.ZERO;\n      if (y === ke)\n        return g;\n      if (a(y), y === Y)\n        return this;\n      const { endo: v } = e;\n      if (!v)\n        return d.unsafeLadder(this, y);\n      let { k1neg: _, k1: m, k2neg: C, k2: O } = v.splitScalar(y), w = g, x = g, A = this;\n      for (; m > ke || O > ke; )\n        m & Y && (w = w.add(A)), O & Y && (x = x.add(A)), A = A.double(), m >>= Y, O >>= Y;\n      return _ && (w = w.negate()), C && (x = x.negate()), x = new u(r.mul(x.px, v.beta), x.py, x.pz), w.add(x);\n    }\n    multiply(y) {\n      a(y);\n      let g = y, v, _;\n      const { endo: m } = e;\n      if (m) {\n        const { k1neg: C, k1: O, k2neg: w, k2: x } = m.splitScalar(g);\n        let { p: A, f: B } = this.wNAF(O), { p: L, f: P } = this.wNAF(x);\n        A = d.constTimeNegate(C, A), L = d.constTimeNegate(w, L), L = new u(r.mul(L.px, m.beta), L.py, L.pz), v = A.add(L), _ = B.add(P);\n      } else {\n        const { p: C, f: O } = this.wNAF(g);\n        v = C, _ = O;\n      }\n      return u.normalizeZ([v, _])[0];\n    }\n    multiplyAndAddUnsafe(y, g, v) {\n      const _ = u.BASE, m = (O, w) => w === ke || w === Y || !O.equals(_) ? O.multiplyUnsafe(w) : O.multiply(w), C = m(this, g).add(m(y, v));\n      return C.is0() ? void 0 : C;\n    }\n    toAffine(y) {\n      const { px: g, py: v, pz: _ } = this, m = this.is0();\n      y == null && (y = m ? r.ONE : r.inv(_));\n      const C = r.mul(g, y), O = r.mul(v, y), w = r.mul(_, y);\n      if (m)\n        return { x: r.ZERO, y: r.ZERO };\n      if (!r.eql(w, r.ONE))\n        throw new Error(\"invZ was invalid\");\n      return { x: C, y: O };\n    }\n    isTorsionFree() {\n      const { h: y, isTorsionFree: g } = e;\n      if (y === Y)\n        return !0;\n      if (g)\n        return g(u, this);\n      throw new Error(\"isTorsionFree() has not been declared for the elliptic curve\");\n    }\n    clearCofactor() {\n      const { h: y, clearCofactor: g } = e;\n      return y === Y ? this : g ? g(u, this) : this.multiplyUnsafe(e.h);\n    }\n    toRawBytes(y = !0) {\n      return this.assertValidity(), n(u, this, y);\n    }\n    toHex(y = !0) {\n      return vt(this.toRawBytes(y));\n    }\n  }\n  u.BASE = new u(e.Gx, e.Gy, r.ONE), u.ZERO = new u(r.ZERO, r.ONE, r.ZERO);\n  const h = e.nBitLength, d = Vc(u, e.endo ? Math.ceil(h / 2) : h);\n  return {\n    CURVE: e,\n    ProjectivePoint: u,\n    normPrivateKeyToScalar: c,\n    weierstrassEquation: s,\n    isWithinCurveOrder: o\n  };\n}\nfunction Xc(t) {\n  const e = ss(t);\n  return kt(e, {\n    hash: \"hash\",\n    hmac: \"function\",\n    randomBytes: \"function\"\n  }, {\n    bits2int: \"function\",\n    bits2int_modN: \"function\",\n    lowS: \"boolean\"\n  }), Object.freeze({ lowS: !0, ...e });\n}\nfunction Qc(t) {\n  const e = Xc(t), { Fp: r, n } = e, i = r.BYTES + 1, s = 2 * r.BYTES + 1;\n  function o(E) {\n    return ke < E && E < r.ORDER;\n  }\n  function a(E) {\n    return J(E, n);\n  }\n  function c(E) {\n    return In(E, n);\n  }\n  const { ProjectivePoint: l, normPrivateKeyToScalar: f, weierstrassEquation: u, isWithinCurveOrder: h } = Jc({\n    ...e,\n    toBytes(E, R, q) {\n      const H = R.toAffine(), D = r.toBytes(H.x), X = he;\n      return q ? X(Uint8Array.from([R.hasEvenY() ? 2 : 3]), D) : X(Uint8Array.from([4]), D, r.toBytes(H.y));\n    },\n    fromBytes(E) {\n      const R = E.length, q = E[0], H = E.subarray(1);\n      if (R === i && (q === 2 || q === 3)) {\n        const D = le(H);\n        if (!o(D))\n          throw new Error(\"Point is not on curve\");\n        const X = u(D);\n        let oe = r.sqrt(X);\n        const re = (oe & Y) === Y;\n        return (q & 1) === 1 !== re && (oe = r.neg(oe)), { x: D, y: oe };\n      } else if (R === s && q === 4) {\n        const D = r.fromBytes(H.subarray(0, r.BYTES)), X = r.fromBytes(H.subarray(r.BYTES, 2 * r.BYTES));\n        return { x: D, y: X };\n      } else\n        throw new Error(`Point of length ${R} was invalid. Expected ${i} compressed bytes or ${s} uncompressed bytes`);\n    }\n  }), d = (E) => vt(et(E, e.nByteLength));\n  function p(E) {\n    const R = n >> Y;\n    return E > R;\n  }\n  function y(E) {\n    return p(E) ? a(-E) : E;\n  }\n  const g = (E, R, q) => le(E.slice(R, q));\n  class v {\n    constructor(R, q, H) {\n      this.r = R, this.s = q, this.recovery = H, this.assertValidity();\n    }\n    static fromCompact(R) {\n      const q = e.nByteLength;\n      return R = ee(\"compactSignature\", R, q * 2), new v(g(R, 0, q), g(R, q, 2 * q));\n    }\n    static fromDER(R) {\n      const { r: q, s: H } = lt.toSig(ee(\"DER\", R));\n      return new v(q, H);\n    }\n    assertValidity() {\n      if (!h(this.r))\n        throw new Error(\"r must be 0 < r < CURVE.n\");\n      if (!h(this.s))\n        throw new Error(\"s must be 0 < s < CURVE.n\");\n    }\n    addRecoveryBit(R) {\n      return new v(this.r, this.s, R);\n    }\n    recoverPublicKey(R) {\n      const { r: q, s: H, recovery: D } = this, X = x(ee(\"msgHash\", R));\n      if (D == null || ![0, 1, 2, 3].includes(D))\n        throw new Error(\"recovery id invalid\");\n      const oe = D === 2 || D === 3 ? q + e.n : q;\n      if (oe >= r.ORDER)\n        throw new Error(\"recovery id 2 or 3 invalid\");\n      const re = (D & 1) === 0 ? \"02\" : \"03\", _e = l.fromHex(re + d(oe)), Oe = c(oe), Ue = a(-X * Oe), Pe = a(H * Oe), ye = l.BASE.multiplyAndAddUnsafe(_e, Ue, Pe);\n      if (!ye)\n        throw new Error(\"point at infinify\");\n      return ye.assertValidity(), ye;\n    }\n    hasHighS() {\n      return p(this.s);\n    }\n    normalizeS() {\n      return this.hasHighS() ? new v(this.r, a(-this.s), this.recovery) : this;\n    }\n    toDERRawBytes() {\n      return wt(this.toDERHex());\n    }\n    toDERHex() {\n      return lt.hexFromSig({ r: this.r, s: this.s });\n    }\n    toCompactRawBytes() {\n      return wt(this.toCompactHex());\n    }\n    toCompactHex() {\n      return d(this.r) + d(this.s);\n    }\n  }\n  const _ = {\n    isValidPrivateKey(E) {\n      try {\n        return f(E), !0;\n      } catch {\n        return !1;\n      }\n    },\n    normPrivateKeyToScalar: f,\n    randomPrivateKey: () => {\n      const E = e.randomBytes(r.BYTES + 8), R = Kc(E, n);\n      return et(R, e.nByteLength);\n    },\n    precompute(E = 8, R = l.BASE) {\n      return R._setWindowSize(E), R.multiply(BigInt(3)), R;\n    }\n  };\n  function m(E, R = !0) {\n    return l.fromPrivateKey(E).toRawBytes(R);\n  }\n  function C(E) {\n    const R = E instanceof Uint8Array, q = typeof E == \"string\", H = (R || q) && E.length;\n    return R ? H === i || H === s : q ? H === 2 * i || H === 2 * s : E instanceof l;\n  }\n  function O(E, R, q = !0) {\n    if (C(E))\n      throw new Error(\"first arg must be private key\");\n    if (!C(R))\n      throw new Error(\"second arg must be public key\");\n    return l.fromHex(R).multiply(f(E)).toRawBytes(q);\n  }\n  const w = e.bits2int || function(E) {\n    const R = le(E), q = E.length * 8 - e.nBitLength;\n    return q > 0 ? R >> BigInt(q) : R;\n  }, x = e.bits2int_modN || function(E) {\n    return a(w(E));\n  }, A = Kn(e.nBitLength);\n  function B(E) {\n    if (typeof E != \"bigint\")\n      throw new Error(\"bigint expected\");\n    if (!(ke <= E && E < A))\n      throw new Error(`bigint expected < 2^${e.nBitLength}`);\n    return et(E, e.nByteLength);\n  }\n  function L(E, R, q = P) {\n    if ([\"recovered\", \"canonical\"].some((me) => me in q))\n      throw new Error(\"sign() legacy options not supported\");\n    const { hash: H, randomBytes: D } = e;\n    let { lowS: X, prehash: oe, extraEntropy: re } = q;\n    X == null && (X = !0), E = ee(\"msgHash\", E), oe && (E = ee(\"prehashed msgHash\", H(E)));\n    const _e = x(E), Oe = f(R), Ue = [B(Oe), B(_e)];\n    if (re != null) {\n      const me = re === !0 ? D(r.BYTES) : re;\n      Ue.push(ee(\"extraEntropy\", me, r.BYTES));\n    }\n    const Pe = he(...Ue), ye = _e;\n    function je(me) {\n      const xe = w(me);\n      if (!h(xe))\n        return;\n      const lr = c(xe), Be = l.BASE.multiply(xe).toAffine(), fe = a(Be.x);\n      if (fe === ke)\n        return;\n      const He = a(lr * a(ye + fe * Oe));\n      if (He === ke)\n        return;\n      let it = (Be.x === fe ? 0 : 2) | Number(Be.y & Y), ot = He;\n      return X && p(He) && (ot = y(He), it ^= 1), new v(fe, ot, it);\n    }\n    return { seed: Pe, k2sig: je };\n  }\n  const P = { lowS: e.lowS, prehash: !1 }, F = { lowS: e.lowS, prehash: !1 };\n  function z(E, R, q = P) {\n    const { seed: H, k2sig: D } = L(E, R, q);\n    return is(e.hash.outputLen, e.nByteLength, e.hmac)(H, D);\n  }\n  l.BASE._setWindowSize(8);\n  function G(E, R, q, H = F) {\n    var Be;\n    const D = E;\n    if (R = ee(\"msgHash\", R), q = ee(\"publicKey\", q), \"strict\" in H)\n      throw new Error(\"options.strict was renamed to lowS\");\n    const { lowS: X, prehash: oe } = H;\n    let re, _e;\n    try {\n      if (typeof D == \"string\" || D instanceof Uint8Array)\n        try {\n          re = v.fromDER(D);\n        } catch (fe) {\n          if (!(fe instanceof lt.Err))\n            throw fe;\n          re = v.fromCompact(D);\n        }\n      else if (typeof D == \"object\" && typeof D.r == \"bigint\" && typeof D.s == \"bigint\") {\n        const { r: fe, s: He } = D;\n        re = new v(fe, He);\n      } else\n        throw new Error(\"PARSE\");\n      _e = l.fromHex(q);\n    } catch (fe) {\n      if (fe.message === \"PARSE\")\n        throw new Error(\"signature must be Signature instance, Uint8Array or hex string\");\n      return !1;\n    }\n    if (X && re.hasHighS())\n      return !1;\n    oe && (R = e.hash(R));\n    const { r: Oe, s: Ue } = re, Pe = x(R), ye = c(Ue), je = a(Pe * ye), me = a(Oe * ye), xe = (Be = l.BASE.multiplyAndAddUnsafe(_e, je, me)) == null ? void 0 : Be.toAffine();\n    return xe ? a(xe.x) === Oe : !1;\n  }\n  return {\n    CURVE: e,\n    getPublicKey: m,\n    getSharedSecret: O,\n    sign: z,\n    verify: G,\n    ProjectivePoint: l,\n    Signature: v,\n    utils: _\n  };\n}\nfunction eu(t, e) {\n  const r = t.ORDER;\n  let n = ke;\n  for (let h = r - Y; h % $e === ke; h /= $e)\n    n += Y;\n  const i = n, s = (r - Y) / $e ** i, o = (s - Y) / $e, a = $e ** i - Y, c = $e ** (i - Y), l = t.pow(e, s), f = t.pow(e, (s + Y) / $e);\n  let u = (h, d) => {\n    let p = l, y = t.pow(d, a), g = t.sqr(y);\n    g = t.mul(g, d);\n    let v = t.mul(h, g);\n    v = t.pow(v, o), v = t.mul(v, y), y = t.mul(v, d), g = t.mul(v, h);\n    let _ = t.mul(g, y);\n    v = t.pow(_, c);\n    let m = t.eql(v, t.ONE);\n    y = t.mul(g, f), v = t.mul(_, p), g = t.cmov(y, g, m), _ = t.cmov(v, _, m);\n    for (let C = i; C > Y; C--) {\n      let O = $e ** (C - $e), w = t.pow(_, O);\n      const x = t.eql(w, t.ONE);\n      y = t.mul(g, p), p = t.mul(p, p), w = t.mul(_, p), g = t.cmov(y, g, x), _ = t.cmov(w, _, x);\n    }\n    return { isValid: m, value: g };\n  };\n  if (t.ORDER % Hi === Ar) {\n    const h = (t.ORDER - Ar) / Hi, d = t.sqrt(t.neg(e));\n    u = (p, y) => {\n      let g = t.sqr(y);\n      const v = t.mul(p, y);\n      g = t.mul(g, v);\n      let _ = t.pow(g, h);\n      _ = t.mul(_, v);\n      const m = t.mul(_, d), C = t.mul(t.sqr(_), y), O = t.eql(C, p);\n      let w = t.cmov(m, _, O);\n      return { isValid: O, value: w };\n    };\n  }\n  return u;\n}\nfunction tu(t, e) {\n  if (os(t), !t.isValid(e.A) || !t.isValid(e.B) || !t.isValid(e.Z))\n    throw new Error(\"mapToCurveSimpleSWU: invalid opts\");\n  const r = eu(t, e.Z);\n  if (!t.isOdd)\n    throw new Error(\"Fp.isOdd is not implemented!\");\n  return (n) => {\n    let i, s, o, a, c, l, f, u;\n    i = t.sqr(n), i = t.mul(i, e.Z), s = t.sqr(i), s = t.add(s, i), o = t.add(s, t.ONE), o = t.mul(o, e.B), a = t.cmov(e.Z, t.neg(s), !t.eql(s, t.ZERO)), a = t.mul(a, e.A), s = t.sqr(o), l = t.sqr(a), c = t.mul(l, e.A), s = t.add(s, c), s = t.mul(s, o), l = t.mul(l, a), c = t.mul(l, e.B), s = t.add(s, c), f = t.mul(i, o);\n    const { isValid: h, value: d } = r(s, l);\n    u = t.mul(i, n), u = t.mul(u, d), f = t.cmov(f, o, h), u = t.cmov(u, d, h);\n    const p = t.isOdd(n) === t.isOdd(u);\n    return u = t.cmov(t.neg(u), u, p), f = t.div(f, a), { x: f, y: u };\n  };\n}\nfunction ru(t) {\n  if (t instanceof Uint8Array)\n    return t;\n  if (typeof t == \"string\")\n    return qr(t);\n  throw new Error(\"DST must be Uint8Array or string\");\n}\nconst nu = le;\nfunction Ze(t, e) {\n  if (t < 0 || t >= 1 << 8 * e)\n    throw new Error(`bad I2OSP call: value=${t} length=${e}`);\n  const r = Array.from({ length: e }).fill(0);\n  for (let n = e - 1; n >= 0; n--)\n    r[n] = t & 255, t >>>= 8;\n  return new Uint8Array(r);\n}\nfunction iu(t, e) {\n  const r = new Uint8Array(t.length);\n  for (let n = 0; n < t.length; n++)\n    r[n] = t[n] ^ e[n];\n  return r;\n}\nfunction tr(t) {\n  if (!(t instanceof Uint8Array))\n    throw new Error(\"Uint8Array expected\");\n}\nfunction Vn(t) {\n  if (!Number.isSafeInteger(t))\n    throw new Error(\"number expected\");\n}\nfunction ou(t, e, r, n) {\n  tr(t), tr(e), Vn(r), e.length > 255 && (e = n(he(qr(\"H2C-OVERSIZE-DST-\"), e)));\n  const { outputLen: i, blockLen: s } = n, o = Math.ceil(r / i);\n  if (o > 255)\n    throw new Error(\"Invalid xmd length\");\n  const a = he(e, Ze(e.length, 1)), c = Ze(0, s), l = Ze(r, 2), f = new Array(o), u = n(he(c, t, l, Ze(0, 1), a));\n  f[0] = n(he(u, Ze(1, 1), a));\n  for (let d = 1; d <= o; d++) {\n    const p = [iu(u, f[d - 1]), Ze(d + 1, 1), a];\n    f[d] = n(he(...p));\n  }\n  return he(...f).slice(0, r);\n}\nfunction su(t, e, r, n, i) {\n  if (tr(t), tr(e), Vn(r), e.length > 255) {\n    const s = Math.ceil(2 * n / 8);\n    e = i.create({ dkLen: s }).update(qr(\"H2C-OVERSIZE-DST-\")).update(e).digest();\n  }\n  if (r > 65535 || e.length > 255)\n    throw new Error(\"expand_message_xof: invalid lenInBytes\");\n  return i.create({ dkLen: r }).update(t).update(Ze(r, 2)).update(e).update(Ze(e.length, 1)).digest();\n}\nfunction Mi(t, e, r) {\n  kt(r, {\n    DST: \"string\",\n    p: \"bigint\",\n    m: \"isSafeInteger\",\n    k: \"isSafeInteger\",\n    hash: \"hash\"\n  });\n  const { p: n, k: i, m: s, hash: o, expand: a, DST: c } = r;\n  tr(t), Vn(e);\n  const l = ru(c), f = n.toString(2).length, u = Math.ceil((f + i) / 8), h = e * s * u;\n  let d;\n  if (a === \"xmd\")\n    d = ou(t, l, h, o);\n  else if (a === \"xof\")\n    d = su(t, l, h, i, o);\n  else if (a === \"_internal_pass\")\n    d = t;\n  else\n    throw new Error('expand must be \"xmd\" or \"xof\"');\n  const p = new Array(e);\n  for (let y = 0; y < e; y++) {\n    const g = new Array(s);\n    for (let v = 0; v < s; v++) {\n      const _ = u * (v + y * s), m = d.subarray(_, _ + u);\n      g[v] = J(nu(m), n);\n    }\n    p[y] = g;\n  }\n  return p;\n}\nfunction au(t, e) {\n  const r = e.map((n) => Array.from(n).reverse());\n  return (n, i) => {\n    const [s, o, a, c] = r.map((l) => l.reduce((f, u) => t.add(t.mul(f, n), u)));\n    return n = t.div(s, o), i = t.mul(i, t.div(a, c)), { x: n, y: i };\n  };\n}\nfunction cu(t, e, r) {\n  if (typeof e != \"function\")\n    throw new Error(\"mapToCurve() must be defined\");\n  return {\n    hashToCurve(n, i) {\n      const s = Mi(n, 2, { ...r, DST: r.DST, ...i }), o = t.fromAffine(e(s[0])), a = t.fromAffine(e(s[1])), c = o.add(a).clearCofactor();\n      return c.assertValidity(), c;\n    },\n    encodeToCurve(n, i) {\n      const s = Mi(n, 1, { ...r, DST: r.encodeDST, ...i }), o = t.fromAffine(e(s[0])).clearCofactor();\n      return o.assertValidity(), o;\n    }\n  };\n}\nclass as extends Jo {\n  constructor(e, r) {\n    super(), this.finished = !1, this.destroyed = !1, ut.hash(e);\n    const n = Dn(r);\n    if (this.iHash = e.create(), typeof this.iHash.update != \"function\")\n      throw new TypeError(\"Expected instance of class which extends utils.Hash\");\n    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;\n    const i = this.blockLen, s = new Uint8Array(i);\n    s.set(n.length > i ? e.create().update(n).digest() : n);\n    for (let o = 0; o < s.length; o++)\n      s[o] ^= 54;\n    this.iHash.update(s), this.oHash = e.create();\n    for (let o = 0; o < s.length; o++)\n      s[o] ^= 106;\n    this.oHash.update(s), s.fill(0);\n  }\n  update(e) {\n    return ut.exists(this), this.iHash.update(e), this;\n  }\n  digestInto(e) {\n    ut.exists(this), ut.bytes(e, this.outputLen), this.finished = !0, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy();\n  }\n  digest() {\n    const e = new Uint8Array(this.oHash.outputLen);\n    return this.digestInto(e), e;\n  }\n  _cloneInto(e) {\n    e || (e = Object.create(Object.getPrototypeOf(this), {}));\n    const { oHash: r, iHash: n, finished: i, destroyed: s, blockLen: o, outputLen: a } = this;\n    return e = e, e.finished = i, e.destroyed = s, e.blockLen = o, e.outputLen = a, e.oHash = r._cloneInto(e.oHash), e.iHash = n._cloneInto(e.iHash), e;\n  }\n  destroy() {\n    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();\n  }\n}\nconst cs = (t, e, r) => new as(t, e).update(r).digest();\ncs.create = (t, e) => new as(t, e);\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nfunction uu(t) {\n  return {\n    hash: t,\n    hmac: (e, ...r) => cs(t, e, mc(...r)),\n    randomBytes: Qo\n  };\n}\nfunction lu(t, e) {\n  const r = (n) => Qc({ ...t, ...uu(n) });\n  return Object.freeze({ ...r(e), create: r });\n}\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst Nr = BigInt(\"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f\"), Cr = BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\"), us = BigInt(1), Ir = BigInt(2), Di = (t, e) => (t + e / Ir) / e;\nfunction ls(t) {\n  const e = Nr, r = BigInt(3), n = BigInt(6), i = BigInt(11), s = BigInt(22), o = BigInt(23), a = BigInt(44), c = BigInt(88), l = t * t * t % e, f = l * l * t % e, u = be(f, r, e) * f % e, h = be(u, r, e) * f % e, d = be(h, Ir, e) * l % e, p = be(d, i, e) * d % e, y = be(p, s, e) * p % e, g = be(y, a, e) * y % e, v = be(g, c, e) * g % e, _ = be(v, a, e) * y % e, m = be(_, r, e) * f % e, C = be(m, o, e) * p % e, O = be(C, n, e) * l % e, w = be(O, Ir, e);\n  if (!tt.eql(tt.sqr(w), t))\n    throw new Error(\"Cannot find square root\");\n  return w;\n}\nconst tt = Fc(Nr, void 0, void 0, { sqrt: ls }), ue = lu({\n  a: BigInt(0),\n  b: BigInt(7),\n  Fp: tt,\n  n: Cr,\n  Gx: BigInt(\"55066263022277343669578718895168534326250603453777594175500187360389116729240\"),\n  Gy: BigInt(\"32670510020758816978083085130507043184471273380659243275938904335757337482424\"),\n  h: BigInt(1),\n  lowS: !0,\n  endo: {\n    beta: BigInt(\"0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\"),\n    splitScalar: (t) => {\n      const e = Cr, r = BigInt(\"0x3086d221a7d46bcde86c90e49284eb15\"), n = -us * BigInt(\"0xe4437ed6010e88286f547fa90abfe4c3\"), i = BigInt(\"0x114ca50f7a8e2f3f657c1108d9d44cfd8\"), s = r, o = BigInt(\"0x100000000000000000000000000000000\"), a = Di(s * t, e), c = Di(-n * t, e);\n      let l = J(t - a * r - c * i, e), f = J(-a * n - c * s, e);\n      const u = l > o, h = f > o;\n      if (u && (l = e - l), h && (f = e - f), l > o || f > o)\n        throw new Error(\"splitScalar: Endomorphism failed, k=\" + t);\n      return { k1neg: u, k1: l, k2neg: h, k2: f };\n    }\n  }\n}, Or), Ur = BigInt(0), fs = (t) => typeof t == \"bigint\" && Ur < t && t < Nr, fu = (t) => typeof t == \"bigint\" && Ur < t && t < Cr, zi = {};\nfunction Rr(t, ...e) {\n  let r = zi[t];\n  if (r === void 0) {\n    const n = Or(Uint8Array.from(t, (i) => i.charCodeAt(0)));\n    r = he(n, n), zi[t] = r;\n  }\n  return Or(he(r, ...e));\n}\nconst Gn = (t) => t.toRawBytes(!0).slice(1), Rn = (t) => et(t, 32), sn = (t) => J(t, Nr), rr = (t) => J(t, Cr), Zn = ue.ProjectivePoint, hu = (t, e, r) => Zn.BASE.multiplyAndAddUnsafe(t, e, r);\nfunction Tn(t) {\n  let e = ue.utils.normPrivateKeyToScalar(t), r = Zn.fromPrivateKey(e);\n  return { scalar: r.hasEvenY() ? e : rr(-e), bytes: Gn(r) };\n}\nfunction hs(t) {\n  if (!fs(t))\n    throw new Error(\"bad x: need 0 < x < p\");\n  const e = sn(t * t), r = sn(e * t + BigInt(7));\n  let n = ls(r);\n  n % Ir !== Ur && (n = sn(-n));\n  const i = new Zn(t, n, us);\n  return i.assertValidity(), i;\n}\nfunction ds(...t) {\n  return rr(le(Rr(\"BIP0340/challenge\", ...t)));\n}\nfunction du(t) {\n  return Tn(t).bytes;\n}\nfunction pu(t, e, r = Qo(32)) {\n  const n = ee(\"message\", t), { bytes: i, scalar: s } = Tn(e), o = ee(\"auxRand\", r, 32), a = Rn(s ^ le(Rr(\"BIP0340/aux\", o))), c = Rr(\"BIP0340/nonce\", a, i, n), l = rr(le(c));\n  if (l === Ur)\n    throw new Error(\"sign failed: k is zero\");\n  const { bytes: f, scalar: u } = Tn(l), h = ds(f, i, n), d = new Uint8Array(64);\n  if (d.set(f, 0), d.set(Rn(rr(u + h * s)), 32), !ps(d, n, i))\n    throw new Error(\"sign: Invalid signature produced\");\n  return d;\n}\nfunction ps(t, e, r) {\n  const n = ee(\"signature\", t, 64), i = ee(\"message\", e), s = ee(\"publicKey\", r, 32);\n  try {\n    const o = hs(le(s)), a = le(n.subarray(0, 32));\n    if (!fs(a))\n      return !1;\n    const c = le(n.subarray(32, 64));\n    if (!fu(c))\n      return !1;\n    const l = ds(Rn(a), Gn(o), i), f = hu(o, c, rr(-l));\n    return !(!f || !f.hasEvenY() || f.toAffine().x !== a);\n  } catch {\n    return !1;\n  }\n}\nconst St = {\n  getPublicKey: du,\n  sign: pu,\n  verify: ps,\n  utils: {\n    randomPrivateKey: ue.utils.randomPrivateKey,\n    lift_x: hs,\n    pointToBytes: Gn,\n    numberToBytesBE: et,\n    bytesToNumberBE: le,\n    taggedHash: Rr,\n    mod: J\n  }\n}, yu = au(tt, [\n  [\n    \"0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7\",\n    \"0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581\",\n    \"0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262\",\n    \"0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c\"\n  ],\n  [\n    \"0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b\",\n    \"0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14\",\n    \"0x0000000000000000000000000000000000000000000000000000000000000001\"\n  ],\n  [\n    \"0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c\",\n    \"0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3\",\n    \"0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931\",\n    \"0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84\"\n  ],\n  [\n    \"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b\",\n    \"0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573\",\n    \"0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f\",\n    \"0x0000000000000000000000000000000000000000000000000000000000000001\"\n  ]\n].map((t) => t.map((e) => BigInt(e)))), gu = tu(tt, {\n  A: BigInt(\"0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533\"),\n  B: BigInt(\"1771\"),\n  Z: tt.create(BigInt(\"-11\"))\n});\ncu(ue.ProjectivePoint, (t) => {\n  const { x: e, y: r } = gu(tt.create(t[0]));\n  return yu(e, r);\n}, {\n  DST: \"secp256k1_XMD:SHA-256_SSWU_RO_\",\n  encodeDST: \"secp256k1_XMD:SHA-256_SSWU_NU_\",\n  p: tt.ORDER,\n  m: 1,\n  k: 128,\n  expand: \"xmd\",\n  hash: Or\n});\nconst an = typeof globalThis == \"object\" && \"crypto\" in globalThis ? globalThis.crypto : void 0;\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst cn = (t) => new DataView(t.buffer, t.byteOffset, t.byteLength), Ce = (t, e) => t << 32 - e | t >>> e, bu = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;\nif (!bu)\n  throw new Error(\"Non little-endian hardware is not supported\");\nconst vu = Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, \"0\"));\nfunction ve(t) {\n  if (!(t instanceof Uint8Array))\n    throw new Error(\"Uint8Array expected\");\n  let e = \"\";\n  for (let r = 0; r < t.length; r++)\n    e += vu[t[r]];\n  return e;\n}\nfunction _t(t) {\n  if (typeof t != \"string\")\n    throw new TypeError(\"hexToBytes: expected string, got \" + typeof t);\n  if (t.length % 2)\n    throw new Error(\"hexToBytes: received invalid unpadded hex\");\n  const e = new Uint8Array(t.length / 2);\n  for (let r = 0; r < e.length; r++) {\n    const n = r * 2, i = t.slice(n, n + 2), s = Number.parseInt(i, 16);\n    if (Number.isNaN(s) || s < 0)\n      throw new Error(\"Invalid byte sequence\");\n    e[r] = s;\n  }\n  return e;\n}\nfunction wu(t) {\n  if (typeof t != \"string\")\n    throw new TypeError(`utf8ToBytes expected string, got ${typeof t}`);\n  return new TextEncoder().encode(t);\n}\nfunction ys(t) {\n  if (typeof t == \"string\" && (t = wu(t)), !(t instanceof Uint8Array))\n    throw new TypeError(`Expected input type is Uint8Array (got ${typeof t})`);\n  return t;\n}\nfunction _u(...t) {\n  if (!t.every((n) => n instanceof Uint8Array))\n    throw new Error(\"Uint8Array list expected\");\n  if (t.length === 1)\n    return t[0];\n  const e = t.reduce((n, i) => n + i.length, 0), r = new Uint8Array(e);\n  for (let n = 0, i = 0; n < t.length; n++) {\n    const s = t[n];\n    r.set(s, i), i += s.length;\n  }\n  return r;\n}\nclass mu {\n  clone() {\n    return this._cloneInto();\n  }\n}\nfunction gs(t) {\n  const e = (n) => t().update(ys(n)).digest(), r = t();\n  return e.outputLen = r.outputLen, e.blockLen = r.blockLen, e.create = () => t(), e;\n}\nfunction xu(t = 32) {\n  if (an && typeof an.getRandomValues == \"function\")\n    return an.getRandomValues(new Uint8Array(t));\n  throw new Error(\"crypto.getRandomValues must be defined\");\n}\nfunction Pn(t) {\n  if (!Number.isSafeInteger(t) || t < 0)\n    throw new Error(`Wrong positive integer: ${t}`);\n}\nfunction Eu(t) {\n  if (typeof t != \"boolean\")\n    throw new Error(`Expected boolean, not ${t}`);\n}\nfunction bs(t, ...e) {\n  if (!(t instanceof Uint8Array))\n    throw new TypeError(\"Expected Uint8Array\");\n  if (e.length > 0 && !e.includes(t.length))\n    throw new TypeError(`Expected Uint8Array of length ${e}, not of length=${t.length}`);\n}\nfunction ku(t) {\n  if (typeof t != \"function\" || typeof t.create != \"function\")\n    throw new Error(\"Hash should be wrapped by utils.wrapConstructor\");\n  Pn(t.outputLen), Pn(t.blockLen);\n}\nfunction Su(t, e = !0) {\n  if (t.destroyed)\n    throw new Error(\"Hash instance has been destroyed\");\n  if (e && t.finished)\n    throw new Error(\"Hash#digest() has already been called\");\n}\nfunction Ou(t, e) {\n  bs(t);\n  const r = e.outputLen;\n  if (t.length < r)\n    throw new Error(`digestInto() expects output buffer of length at least ${r}`);\n}\nconst un = {\n  number: Pn,\n  bool: Eu,\n  bytes: bs,\n  hash: ku,\n  exists: Su,\n  output: Ou\n};\nfunction Au(t, e, r, n) {\n  if (typeof t.setBigUint64 == \"function\")\n    return t.setBigUint64(e, r, n);\n  const i = BigInt(32), s = BigInt(4294967295), o = Number(r >> i & s), a = Number(r & s), c = n ? 4 : 0, l = n ? 0 : 4;\n  t.setUint32(e + c, o, n), t.setUint32(e + l, a, n);\n}\nclass Cu extends mu {\n  constructor(e, r, n, i) {\n    super(), this.blockLen = e, this.outputLen = r, this.padOffset = n, this.isLE = i, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = cn(this.buffer);\n  }\n  update(e) {\n    un.exists(this);\n    const { view: r, buffer: n, blockLen: i } = this;\n    e = ys(e);\n    const s = e.length;\n    for (let o = 0; o < s; ) {\n      const a = Math.min(i - this.pos, s - o);\n      if (a === i) {\n        const c = cn(e);\n        for (; i <= s - o; o += i)\n          this.process(c, o);\n        continue;\n      }\n      n.set(e.subarray(o, o + a), this.pos), this.pos += a, o += a, this.pos === i && (this.process(r, 0), this.pos = 0);\n    }\n    return this.length += e.length, this.roundClean(), this;\n  }\n  digestInto(e) {\n    un.exists(this), un.output(e, this), this.finished = !0;\n    const { buffer: r, view: n, blockLen: i, isLE: s } = this;\n    let { pos: o } = this;\n    r[o++] = 128, this.buffer.subarray(o).fill(0), this.padOffset > i - o && (this.process(n, 0), o = 0);\n    for (let u = o; u < i; u++)\n      r[u] = 0;\n    Au(n, i - 8, BigInt(this.length * 8), s), this.process(n, 0);\n    const a = cn(e), c = this.outputLen;\n    if (c % 4)\n      throw new Error(\"_sha2: outputLen should be aligned to 32bit\");\n    const l = c / 4, f = this.get();\n    if (l > f.length)\n      throw new Error(\"_sha2: outputLen bigger than state\");\n    for (let u = 0; u < l; u++)\n      a.setUint32(4 * u, f[u], s);\n  }\n  digest() {\n    const { buffer: e, outputLen: r } = this;\n    this.digestInto(e);\n    const n = e.slice(0, r);\n    return this.destroy(), n;\n  }\n  _cloneInto(e) {\n    e || (e = new this.constructor()), e.set(...this.get());\n    const { blockLen: r, buffer: n, length: i, finished: s, destroyed: o, pos: a } = this;\n    return e.length = i, e.pos = a, e.finished = s, e.destroyed = o, i % r && e.buffer.set(n), e;\n  }\n}\nconst Iu = (t, e, r) => t & e ^ ~t & r, Ru = (t, e, r) => t & e ^ t & r ^ e & r, Tu = new Uint32Array([\n  1116352408,\n  1899447441,\n  3049323471,\n  3921009573,\n  961987163,\n  1508970993,\n  2453635748,\n  2870763221,\n  3624381080,\n  310598401,\n  607225278,\n  1426881987,\n  1925078388,\n  2162078206,\n  2614888103,\n  3248222580,\n  3835390401,\n  4022224774,\n  264347078,\n  604807628,\n  770255983,\n  1249150122,\n  1555081692,\n  1996064986,\n  2554220882,\n  2821834349,\n  2952996808,\n  3210313671,\n  3336571891,\n  3584528711,\n  113926993,\n  338241895,\n  666307205,\n  773529912,\n  1294757372,\n  1396182291,\n  1695183700,\n  1986661051,\n  2177026350,\n  2456956037,\n  2730485921,\n  2820302411,\n  3259730800,\n  3345764771,\n  3516065817,\n  3600352804,\n  4094571909,\n  275423344,\n  430227734,\n  506948616,\n  659060556,\n  883997877,\n  958139571,\n  1322822218,\n  1537002063,\n  1747873779,\n  1955562222,\n  2024104815,\n  2227730452,\n  2361852424,\n  2428436474,\n  2756734187,\n  3204031479,\n  3329325298\n]), ze = new Uint32Array([\n  1779033703,\n  3144134277,\n  1013904242,\n  2773480762,\n  1359893119,\n  2600822924,\n  528734635,\n  1541459225\n]), Fe = new Uint32Array(64);\nclass vs extends Cu {\n  constructor() {\n    super(64, 32, 8, !1), this.A = ze[0] | 0, this.B = ze[1] | 0, this.C = ze[2] | 0, this.D = ze[3] | 0, this.E = ze[4] | 0, this.F = ze[5] | 0, this.G = ze[6] | 0, this.H = ze[7] | 0;\n  }\n  get() {\n    const { A: e, B: r, C: n, D: i, E: s, F: o, G: a, H: c } = this;\n    return [e, r, n, i, s, o, a, c];\n  }\n  set(e, r, n, i, s, o, a, c) {\n    this.A = e | 0, this.B = r | 0, this.C = n | 0, this.D = i | 0, this.E = s | 0, this.F = o | 0, this.G = a | 0, this.H = c | 0;\n  }\n  process(e, r) {\n    for (let u = 0; u < 16; u++, r += 4)\n      Fe[u] = e.getUint32(r, !1);\n    for (let u = 16; u < 64; u++) {\n      const h = Fe[u - 15], d = Fe[u - 2], p = Ce(h, 7) ^ Ce(h, 18) ^ h >>> 3, y = Ce(d, 17) ^ Ce(d, 19) ^ d >>> 10;\n      Fe[u] = y + Fe[u - 7] + p + Fe[u - 16] | 0;\n    }\n    let { A: n, B: i, C: s, D: o, E: a, F: c, G: l, H: f } = this;\n    for (let u = 0; u < 64; u++) {\n      const h = Ce(a, 6) ^ Ce(a, 11) ^ Ce(a, 25), d = f + h + Iu(a, c, l) + Tu[u] + Fe[u] | 0, y = (Ce(n, 2) ^ Ce(n, 13) ^ Ce(n, 22)) + Ru(n, i, s) | 0;\n      f = l, l = c, c = a, a = o + d | 0, o = s, s = i, i = n, n = d + y | 0;\n    }\n    n = n + this.A | 0, i = i + this.B | 0, s = s + this.C | 0, o = o + this.D | 0, a = a + this.E | 0, c = c + this.F | 0, l = l + this.G | 0, f = f + this.H | 0, this.set(n, i, s, o, a, c, l, f);\n  }\n  roundClean() {\n    Fe.fill(0);\n  }\n  destroy() {\n    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);\n  }\n}\nclass Pu extends vs {\n  constructor() {\n    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;\n  }\n}\nconst Yn = gs(() => new vs());\ngs(() => new Pu());\n/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nfunction rt(t) {\n  if (!Number.isSafeInteger(t))\n    throw new Error(`Wrong integer: ${t}`);\n}\nfunction Se(...t) {\n  const e = (i, s) => (o) => i(s(o)), r = Array.from(t).reverse().reduce((i, s) => i ? e(i, s.encode) : s.encode, void 0), n = t.reduce((i, s) => i ? e(i, s.decode) : s.decode, void 0);\n  return { encode: r, decode: n };\n}\nfunction Re(t) {\n  return {\n    encode: (e) => {\n      if (!Array.isArray(e) || e.length && typeof e[0] != \"number\")\n        throw new Error(\"alphabet.encode input should be an array of numbers\");\n      return e.map((r) => {\n        if (rt(r), r < 0 || r >= t.length)\n          throw new Error(`Digit index outside alphabet: ${r} (alphabet: ${t.length})`);\n        return t[r];\n      });\n    },\n    decode: (e) => {\n      if (!Array.isArray(e) || e.length && typeof e[0] != \"string\")\n        throw new Error(\"alphabet.decode input should be array of strings\");\n      return e.map((r) => {\n        if (typeof r != \"string\")\n          throw new Error(`alphabet.decode: not string element=${r}`);\n        const n = t.indexOf(r);\n        if (n === -1)\n          throw new Error(`Unknown letter: \"${r}\". Allowed: ${t}`);\n        return n;\n      });\n    }\n  };\n}\nfunction Te(t = \"\") {\n  if (typeof t != \"string\")\n    throw new Error(\"join separator should be string\");\n  return {\n    encode: (e) => {\n      if (!Array.isArray(e) || e.length && typeof e[0] != \"string\")\n        throw new Error(\"join.encode input should be array of strings\");\n      for (let r of e)\n        if (typeof r != \"string\")\n          throw new Error(`join.encode: non-string input=${r}`);\n      return e.join(t);\n    },\n    decode: (e) => {\n      if (typeof e != \"string\")\n        throw new Error(\"join.decode input should be string\");\n      return e.split(t);\n    }\n  };\n}\nfunction sr(t, e = \"=\") {\n  if (rt(t), typeof e != \"string\")\n    throw new Error(\"padding chr should be string\");\n  return {\n    encode(r) {\n      if (!Array.isArray(r) || r.length && typeof r[0] != \"string\")\n        throw new Error(\"padding.encode input should be array of strings\");\n      for (let n of r)\n        if (typeof n != \"string\")\n          throw new Error(`padding.encode: non-string input=${n}`);\n      for (; r.length * t % 8; )\n        r.push(e);\n      return r;\n    },\n    decode(r) {\n      if (!Array.isArray(r) || r.length && typeof r[0] != \"string\")\n        throw new Error(\"padding.encode input should be array of strings\");\n      for (let i of r)\n        if (typeof i != \"string\")\n          throw new Error(`padding.decode: non-string input=${i}`);\n      let n = r.length;\n      if (n * t % 8)\n        throw new Error(\"Invalid padding: string should have whole number of bytes\");\n      for (; n > 0 && r[n - 1] === e; n--)\n        if (!((n - 1) * t % 8))\n          throw new Error(\"Invalid padding: string has too much padding\");\n      return r.slice(0, n);\n    }\n  };\n}\nfunction ws(t) {\n  if (typeof t != \"function\")\n    throw new Error(\"normalize fn should be function\");\n  return { encode: (e) => e, decode: (e) => t(e) };\n}\nfunction Fi(t, e, r) {\n  if (e < 2)\n    throw new Error(`convertRadix: wrong from=${e}, base cannot be less than 2`);\n  if (r < 2)\n    throw new Error(`convertRadix: wrong to=${r}, base cannot be less than 2`);\n  if (!Array.isArray(t))\n    throw new Error(\"convertRadix: data should be array\");\n  if (!t.length)\n    return [];\n  let n = 0;\n  const i = [], s = Array.from(t);\n  for (s.forEach((o) => {\n    if (rt(o), o < 0 || o >= e)\n      throw new Error(`Wrong integer: ${o}`);\n  }); ; ) {\n    let o = 0, a = !0;\n    for (let c = n; c < s.length; c++) {\n      const l = s[c], f = e * o + l;\n      if (!Number.isSafeInteger(f) || e * o / e !== o || f - l !== e * o)\n        throw new Error(\"convertRadix: carry overflow\");\n      if (o = f % r, s[c] = Math.floor(f / r), !Number.isSafeInteger(s[c]) || s[c] * r + o !== f)\n        throw new Error(\"convertRadix: carry overflow\");\n      if (a)\n        s[c] ? a = !1 : n = c;\n      else\n        continue;\n    }\n    if (i.push(o), a)\n      break;\n  }\n  for (let o = 0; o < t.length - 1 && t[o] === 0; o++)\n    i.push(0);\n  return i.reverse();\n}\nconst _s = (t, e) => e ? _s(e, t % e) : t, Tr = (t, e) => t + (e - _s(t, e));\nfunction Bn(t, e, r, n) {\n  if (!Array.isArray(t))\n    throw new Error(\"convertRadix2: data should be array\");\n  if (e <= 0 || e > 32)\n    throw new Error(`convertRadix2: wrong from=${e}`);\n  if (r <= 0 || r > 32)\n    throw new Error(`convertRadix2: wrong to=${r}`);\n  if (Tr(e, r) > 32)\n    throw new Error(`convertRadix2: carry overflow from=${e} to=${r} carryBits=${Tr(e, r)}`);\n  let i = 0, s = 0;\n  const o = 2 ** r - 1, a = [];\n  for (const c of t) {\n    if (rt(c), c >= 2 ** e)\n      throw new Error(`convertRadix2: invalid data word=${c} from=${e}`);\n    if (i = i << e | c, s + e > 32)\n      throw new Error(`convertRadix2: carry overflow pos=${s} from=${e}`);\n    for (s += e; s >= r; s -= r)\n      a.push((i >> s - r & o) >>> 0);\n    i &= 2 ** s - 1;\n  }\n  if (i = i << r - s & o, !n && s >= e)\n    throw new Error(\"Excess padding\");\n  if (!n && i)\n    throw new Error(`Non-zero padding: ${i}`);\n  return n && s > 0 && a.push(i >>> 0), a;\n}\nfunction ms(t) {\n  return rt(t), {\n    encode: (e) => {\n      if (!(e instanceof Uint8Array))\n        throw new Error(\"radix.encode input should be Uint8Array\");\n      return Fi(Array.from(e), 2 ** 8, t);\n    },\n    decode: (e) => {\n      if (!Array.isArray(e) || e.length && typeof e[0] != \"number\")\n        throw new Error(\"radix.decode input should be array of strings\");\n      return Uint8Array.from(Fi(e, t, 2 ** 8));\n    }\n  };\n}\nfunction Ne(t, e = !1) {\n  if (rt(t), t <= 0 || t > 32)\n    throw new Error(\"radix2: bits should be in (0..32]\");\n  if (Tr(8, t) > 32 || Tr(t, 8) > 32)\n    throw new Error(\"radix2: carry overflow\");\n  return {\n    encode: (r) => {\n      if (!(r instanceof Uint8Array))\n        throw new Error(\"radix2.encode input should be Uint8Array\");\n      return Bn(Array.from(r), 8, t, !e);\n    },\n    decode: (r) => {\n      if (!Array.isArray(r) || r.length && typeof r[0] != \"number\")\n        throw new Error(\"radix2.decode input should be array of strings\");\n      return Uint8Array.from(Bn(r, t, 8, e));\n    }\n  };\n}\nfunction Ki(t) {\n  if (typeof t != \"function\")\n    throw new Error(\"unsafeWrapper fn should be function\");\n  return function(...e) {\n    try {\n      return t.apply(null, e);\n    } catch {\n    }\n  };\n}\nfunction xs(t, e) {\n  if (rt(t), typeof e != \"function\")\n    throw new Error(\"checksum fn should be function\");\n  return {\n    encode(r) {\n      if (!(r instanceof Uint8Array))\n        throw new Error(\"checksum.encode: input should be Uint8Array\");\n      const n = e(r).slice(0, t), i = new Uint8Array(r.length + t);\n      return i.set(r), i.set(n, r.length), i;\n    },\n    decode(r) {\n      if (!(r instanceof Uint8Array))\n        throw new Error(\"checksum.decode: input should be Uint8Array\");\n      const n = r.slice(0, -t), i = e(n).slice(0, t), s = r.slice(-t);\n      for (let o = 0; o < t; o++)\n        if (i[o] !== s[o])\n          throw new Error(\"Invalid checksum\");\n      return n;\n    }\n  };\n}\nconst Bu = { alphabet: Re, chain: Se, checksum: xs, radix: ms, radix2: Ne, join: Te, padding: sr }, Es = Se(Ne(4), Re(\"0123456789ABCDEF\"), Te(\"\")), ks = Se(Ne(5), Re(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\"), sr(5), Te(\"\")), Lu = Se(Ne(5), Re(\"0123456789ABCDEFGHIJKLMNOPQRSTUV\"), sr(5), Te(\"\")), $u = Se(Ne(5), Re(\"0123456789ABCDEFGHJKMNPQRSTVWXYZ\"), Te(\"\"), ws((t) => t.toUpperCase().replace(/O/g, \"0\").replace(/[IL]/g, \"1\"))), mt = Se(Ne(6), Re(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"), sr(6), Te(\"\")), Ss = Se(Ne(6), Re(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\"), sr(6), Te(\"\")), Jn = (t) => Se(ms(58), Re(t), Te(\"\")), nr = Jn(\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"), qu = Jn(\"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ\"), Nu = Jn(\"rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz\"), Wi = [0, 2, 3, 5, 6, 7, 9, 10, 11], Os = {\n  encode(t) {\n    let e = \"\";\n    for (let r = 0; r < t.length; r += 8) {\n      const n = t.subarray(r, r + 8);\n      e += nr.encode(n).padStart(Wi[n.length], \"1\");\n    }\n    return e;\n  },\n  decode(t) {\n    let e = [];\n    for (let r = 0; r < t.length; r += 11) {\n      const n = t.slice(r, r + 11), i = Wi.indexOf(n.length), s = nr.decode(n);\n      for (let o = 0; o < s.length - i; o++)\n        if (s[o] !== 0)\n          throw new Error(\"base58xmr: wrong padding\");\n      e = e.concat(Array.from(s.slice(s.length - i)));\n    }\n    return Uint8Array.from(e);\n  }\n}, As = (t) => Se(xs(4, (e) => t(t(e))), nr), Ln = Se(Re(\"qpzry9x8gf2tvdw0s3jn54khce6mua7l\"), Te(\"\")), Vi = [996825010, 642813549, 513874426, 1027748829, 705979059];\nfunction It(t) {\n  const e = t >> 25;\n  let r = (t & 33554431) << 5;\n  for (let n = 0; n < Vi.length; n++)\n    (e >> n & 1) === 1 && (r ^= Vi[n]);\n  return r;\n}\nfunction Gi(t, e, r = 1) {\n  const n = t.length;\n  let i = 1;\n  for (let s = 0; s < n; s++) {\n    const o = t.charCodeAt(s);\n    if (o < 33 || o > 126)\n      throw new Error(`Invalid prefix (${t})`);\n    i = It(i) ^ o >> 5;\n  }\n  i = It(i);\n  for (let s = 0; s < n; s++)\n    i = It(i) ^ t.charCodeAt(s) & 31;\n  for (let s of e)\n    i = It(i) ^ s;\n  for (let s = 0; s < 6; s++)\n    i = It(i);\n  return i ^= r, Ln.encode(Bn([i % 2 ** 30], 30, 5, !1));\n}\nfunction Cs(t) {\n  const e = t === \"bech32\" ? 1 : 734539939, r = Ne(5), n = r.decode, i = r.encode, s = Ki(n);\n  function o(f, u, h = 90) {\n    if (typeof f != \"string\")\n      throw new Error(`bech32.encode prefix should be string, not ${typeof f}`);\n    if (!Array.isArray(u) || u.length && typeof u[0] != \"number\")\n      throw new Error(`bech32.encode words should be array of numbers, not ${typeof u}`);\n    const d = f.length + 7 + u.length;\n    if (h !== !1 && d > h)\n      throw new TypeError(`Length ${d} exceeds limit ${h}`);\n    return f = f.toLowerCase(), `${f}1${Ln.encode(u)}${Gi(f, u, e)}`;\n  }\n  function a(f, u = 90) {\n    if (typeof f != \"string\")\n      throw new Error(`bech32.decode input should be string, not ${typeof f}`);\n    if (f.length < 8 || u !== !1 && f.length > u)\n      throw new TypeError(`Wrong string length: ${f.length} (${f}). Expected (8..${u})`);\n    const h = f.toLowerCase();\n    if (f !== h && f !== f.toUpperCase())\n      throw new Error(\"String must be lowercase or uppercase\");\n    f = h;\n    const d = f.lastIndexOf(\"1\");\n    if (d === 0 || d === -1)\n      throw new Error('Letter \"1\" must be present between prefix and data only');\n    const p = f.slice(0, d), y = f.slice(d + 1);\n    if (y.length < 6)\n      throw new Error(\"Data must be at least 6 characters long\");\n    const g = Ln.decode(y).slice(0, -6), v = Gi(p, g, e);\n    if (!y.endsWith(v))\n      throw new Error(`Invalid checksum in ${f}: expected \"${v}\"`);\n    return { prefix: p, words: g };\n  }\n  const c = Ki(a);\n  function l(f) {\n    const { prefix: u, words: h } = a(f, !1);\n    return { prefix: u, words: h, bytes: n(h) };\n  }\n  return { encode: o, decode: a, decodeToBytes: l, decodeUnsafe: c, fromWords: n, fromWordsUnsafe: s, toWords: i };\n}\nconst te = Cs(\"bech32\"), Uu = Cs(\"bech32m\"), Is = {\n  encode: (t) => new TextDecoder().decode(t),\n  decode: (t) => new TextEncoder().encode(t)\n}, Rs = Se(Ne(4), Re(\"0123456789abcdef\"), Te(\"\"), ws((t) => {\n  if (typeof t != \"string\" || t.length % 2)\n    throw new TypeError(`hex.decode: expected string, got ${typeof t} with length ${t.length}`);\n  return t.toLowerCase();\n})), ir = {\n  utf8: Is,\n  hex: Rs,\n  base16: Es,\n  base32: ks,\n  base64: mt,\n  base64url: Ss,\n  base58: nr,\n  base58xmr: Os\n}, Ts = `Invalid encoding type. Available types: ${Object.keys(ir).join(\", \")}`, Ps = (t, e) => {\n  if (typeof t != \"string\" || !ir.hasOwnProperty(t))\n    throw new TypeError(Ts);\n  if (!(e instanceof Uint8Array))\n    throw new TypeError(\"bytesToString() expects Uint8Array\");\n  return ir[t].encode(e);\n}, ju = Ps, Bs = (t, e) => {\n  if (!ir.hasOwnProperty(t))\n    throw new TypeError(Ts);\n  if (typeof e != \"string\")\n    throw new TypeError(\"stringToBytes() expects string\");\n  return ir[t].decode(e);\n}, Hu = Bs, Mu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  assertNumber: rt,\n  utils: Bu,\n  base16: Es,\n  base32: ks,\n  base32hex: Lu,\n  base32crockford: $u,\n  base64: mt,\n  base64url: Ss,\n  base58: nr,\n  base58flickr: qu,\n  base58xrp: Nu,\n  base58xmr: Os,\n  base58check: As,\n  bech32: te,\n  bech32m: Uu,\n  utf8: Is,\n  hex: Rs,\n  bytesToString: Ps,\n  str: ju,\n  stringToBytes: Bs,\n  bytes: Hu\n}, Symbol.toStringTag, { value: \"Module\" }));\nvar Xn = {};\nObject.defineProperty(Xn, \"__esModule\", { value: !0 });\nvar Qn = Xn.wordlist = void 0;\nQn = Xn.wordlist = `abandon\nability\nable\nabout\nabove\nabsent\nabsorb\nabstract\nabsurd\nabuse\naccess\naccident\naccount\naccuse\nachieve\nacid\nacoustic\nacquire\nacross\nact\naction\nactor\nactress\nactual\nadapt\nadd\naddict\naddress\nadjust\nadmit\nadult\nadvance\nadvice\naerobic\naffair\nafford\nafraid\nagain\nage\nagent\nagree\nahead\naim\nair\nairport\naisle\nalarm\nalbum\nalcohol\nalert\nalien\nall\nalley\nallow\nalmost\nalone\nalpha\nalready\nalso\nalter\nalways\namateur\namazing\namong\namount\namused\nanalyst\nanchor\nancient\nanger\nangle\nangry\nanimal\nankle\nannounce\nannual\nanother\nanswer\nantenna\nantique\nanxiety\nany\napart\napology\nappear\napple\napprove\napril\narch\narctic\narea\narena\nargue\narm\narmed\narmor\narmy\naround\narrange\narrest\narrive\narrow\nart\nartefact\nartist\nartwork\nask\naspect\nassault\nasset\nassist\nassume\nasthma\nathlete\natom\nattack\nattend\nattitude\nattract\nauction\naudit\naugust\naunt\nauthor\nauto\nautumn\naverage\navocado\navoid\nawake\naware\naway\nawesome\nawful\nawkward\naxis\nbaby\nbachelor\nbacon\nbadge\nbag\nbalance\nbalcony\nball\nbamboo\nbanana\nbanner\nbar\nbarely\nbargain\nbarrel\nbase\nbasic\nbasket\nbattle\nbeach\nbean\nbeauty\nbecause\nbecome\nbeef\nbefore\nbegin\nbehave\nbehind\nbelieve\nbelow\nbelt\nbench\nbenefit\nbest\nbetray\nbetter\nbetween\nbeyond\nbicycle\nbid\nbike\nbind\nbiology\nbird\nbirth\nbitter\nblack\nblade\nblame\nblanket\nblast\nbleak\nbless\nblind\nblood\nblossom\nblouse\nblue\nblur\nblush\nboard\nboat\nbody\nboil\nbomb\nbone\nbonus\nbook\nboost\nborder\nboring\nborrow\nboss\nbottom\nbounce\nbox\nboy\nbracket\nbrain\nbrand\nbrass\nbrave\nbread\nbreeze\nbrick\nbridge\nbrief\nbright\nbring\nbrisk\nbroccoli\nbroken\nbronze\nbroom\nbrother\nbrown\nbrush\nbubble\nbuddy\nbudget\nbuffalo\nbuild\nbulb\nbulk\nbullet\nbundle\nbunker\nburden\nburger\nburst\nbus\nbusiness\nbusy\nbutter\nbuyer\nbuzz\ncabbage\ncabin\ncable\ncactus\ncage\ncake\ncall\ncalm\ncamera\ncamp\ncan\ncanal\ncancel\ncandy\ncannon\ncanoe\ncanvas\ncanyon\ncapable\ncapital\ncaptain\ncar\ncarbon\ncard\ncargo\ncarpet\ncarry\ncart\ncase\ncash\ncasino\ncastle\ncasual\ncat\ncatalog\ncatch\ncategory\ncattle\ncaught\ncause\ncaution\ncave\nceiling\ncelery\ncement\ncensus\ncentury\ncereal\ncertain\nchair\nchalk\nchampion\nchange\nchaos\nchapter\ncharge\nchase\nchat\ncheap\ncheck\ncheese\nchef\ncherry\nchest\nchicken\nchief\nchild\nchimney\nchoice\nchoose\nchronic\nchuckle\nchunk\nchurn\ncigar\ncinnamon\ncircle\ncitizen\ncity\ncivil\nclaim\nclap\nclarify\nclaw\nclay\nclean\nclerk\nclever\nclick\nclient\ncliff\nclimb\nclinic\nclip\nclock\nclog\nclose\ncloth\ncloud\nclown\nclub\nclump\ncluster\nclutch\ncoach\ncoast\ncoconut\ncode\ncoffee\ncoil\ncoin\ncollect\ncolor\ncolumn\ncombine\ncome\ncomfort\ncomic\ncommon\ncompany\nconcert\nconduct\nconfirm\ncongress\nconnect\nconsider\ncontrol\nconvince\ncook\ncool\ncopper\ncopy\ncoral\ncore\ncorn\ncorrect\ncost\ncotton\ncouch\ncountry\ncouple\ncourse\ncousin\ncover\ncoyote\ncrack\ncradle\ncraft\ncram\ncrane\ncrash\ncrater\ncrawl\ncrazy\ncream\ncredit\ncreek\ncrew\ncricket\ncrime\ncrisp\ncritic\ncrop\ncross\ncrouch\ncrowd\ncrucial\ncruel\ncruise\ncrumble\ncrunch\ncrush\ncry\ncrystal\ncube\nculture\ncup\ncupboard\ncurious\ncurrent\ncurtain\ncurve\ncushion\ncustom\ncute\ncycle\ndad\ndamage\ndamp\ndance\ndanger\ndaring\ndash\ndaughter\ndawn\nday\ndeal\ndebate\ndebris\ndecade\ndecember\ndecide\ndecline\ndecorate\ndecrease\ndeer\ndefense\ndefine\ndefy\ndegree\ndelay\ndeliver\ndemand\ndemise\ndenial\ndentist\ndeny\ndepart\ndepend\ndeposit\ndepth\ndeputy\nderive\ndescribe\ndesert\ndesign\ndesk\ndespair\ndestroy\ndetail\ndetect\ndevelop\ndevice\ndevote\ndiagram\ndial\ndiamond\ndiary\ndice\ndiesel\ndiet\ndiffer\ndigital\ndignity\ndilemma\ndinner\ndinosaur\ndirect\ndirt\ndisagree\ndiscover\ndisease\ndish\ndismiss\ndisorder\ndisplay\ndistance\ndivert\ndivide\ndivorce\ndizzy\ndoctor\ndocument\ndog\ndoll\ndolphin\ndomain\ndonate\ndonkey\ndonor\ndoor\ndose\ndouble\ndove\ndraft\ndragon\ndrama\ndrastic\ndraw\ndream\ndress\ndrift\ndrill\ndrink\ndrip\ndrive\ndrop\ndrum\ndry\nduck\ndumb\ndune\nduring\ndust\ndutch\nduty\ndwarf\ndynamic\neager\neagle\nearly\nearn\nearth\neasily\neast\neasy\necho\necology\neconomy\nedge\nedit\neducate\neffort\negg\neight\neither\nelbow\nelder\nelectric\nelegant\nelement\nelephant\nelevator\nelite\nelse\nembark\nembody\nembrace\nemerge\nemotion\nemploy\nempower\nempty\nenable\nenact\nend\nendless\nendorse\nenemy\nenergy\nenforce\nengage\nengine\nenhance\nenjoy\nenlist\nenough\nenrich\nenroll\nensure\nenter\nentire\nentry\nenvelope\nepisode\nequal\nequip\nera\nerase\nerode\nerosion\nerror\nerupt\nescape\nessay\nessence\nestate\neternal\nethics\nevidence\nevil\nevoke\nevolve\nexact\nexample\nexcess\nexchange\nexcite\nexclude\nexcuse\nexecute\nexercise\nexhaust\nexhibit\nexile\nexist\nexit\nexotic\nexpand\nexpect\nexpire\nexplain\nexpose\nexpress\nextend\nextra\neye\neyebrow\nfabric\nface\nfaculty\nfade\nfaint\nfaith\nfall\nfalse\nfame\nfamily\nfamous\nfan\nfancy\nfantasy\nfarm\nfashion\nfat\nfatal\nfather\nfatigue\nfault\nfavorite\nfeature\nfebruary\nfederal\nfee\nfeed\nfeel\nfemale\nfence\nfestival\nfetch\nfever\nfew\nfiber\nfiction\nfield\nfigure\nfile\nfilm\nfilter\nfinal\nfind\nfine\nfinger\nfinish\nfire\nfirm\nfirst\nfiscal\nfish\nfit\nfitness\nfix\nflag\nflame\nflash\nflat\nflavor\nflee\nflight\nflip\nfloat\nflock\nfloor\nflower\nfluid\nflush\nfly\nfoam\nfocus\nfog\nfoil\nfold\nfollow\nfood\nfoot\nforce\nforest\nforget\nfork\nfortune\nforum\nforward\nfossil\nfoster\nfound\nfox\nfragile\nframe\nfrequent\nfresh\nfriend\nfringe\nfrog\nfront\nfrost\nfrown\nfrozen\nfruit\nfuel\nfun\nfunny\nfurnace\nfury\nfuture\ngadget\ngain\ngalaxy\ngallery\ngame\ngap\ngarage\ngarbage\ngarden\ngarlic\ngarment\ngas\ngasp\ngate\ngather\ngauge\ngaze\ngeneral\ngenius\ngenre\ngentle\ngenuine\ngesture\nghost\ngiant\ngift\ngiggle\nginger\ngiraffe\ngirl\ngive\nglad\nglance\nglare\nglass\nglide\nglimpse\nglobe\ngloom\nglory\nglove\nglow\nglue\ngoat\ngoddess\ngold\ngood\ngoose\ngorilla\ngospel\ngossip\ngovern\ngown\ngrab\ngrace\ngrain\ngrant\ngrape\ngrass\ngravity\ngreat\ngreen\ngrid\ngrief\ngrit\ngrocery\ngroup\ngrow\ngrunt\nguard\nguess\nguide\nguilt\nguitar\ngun\ngym\nhabit\nhair\nhalf\nhammer\nhamster\nhand\nhappy\nharbor\nhard\nharsh\nharvest\nhat\nhave\nhawk\nhazard\nhead\nhealth\nheart\nheavy\nhedgehog\nheight\nhello\nhelmet\nhelp\nhen\nhero\nhidden\nhigh\nhill\nhint\nhip\nhire\nhistory\nhobby\nhockey\nhold\nhole\nholiday\nhollow\nhome\nhoney\nhood\nhope\nhorn\nhorror\nhorse\nhospital\nhost\nhotel\nhour\nhover\nhub\nhuge\nhuman\nhumble\nhumor\nhundred\nhungry\nhunt\nhurdle\nhurry\nhurt\nhusband\nhybrid\nice\nicon\nidea\nidentify\nidle\nignore\nill\nillegal\nillness\nimage\nimitate\nimmense\nimmune\nimpact\nimpose\nimprove\nimpulse\ninch\ninclude\nincome\nincrease\nindex\nindicate\nindoor\nindustry\ninfant\ninflict\ninform\ninhale\ninherit\ninitial\ninject\ninjury\ninmate\ninner\ninnocent\ninput\ninquiry\ninsane\ninsect\ninside\ninspire\ninstall\nintact\ninterest\ninto\ninvest\ninvite\ninvolve\niron\nisland\nisolate\nissue\nitem\nivory\njacket\njaguar\njar\njazz\njealous\njeans\njelly\njewel\njob\njoin\njoke\njourney\njoy\njudge\njuice\njump\njungle\njunior\njunk\njust\nkangaroo\nkeen\nkeep\nketchup\nkey\nkick\nkid\nkidney\nkind\nkingdom\nkiss\nkit\nkitchen\nkite\nkitten\nkiwi\nknee\nknife\nknock\nknow\nlab\nlabel\nlabor\nladder\nlady\nlake\nlamp\nlanguage\nlaptop\nlarge\nlater\nlatin\nlaugh\nlaundry\nlava\nlaw\nlawn\nlawsuit\nlayer\nlazy\nleader\nleaf\nlearn\nleave\nlecture\nleft\nleg\nlegal\nlegend\nleisure\nlemon\nlend\nlength\nlens\nleopard\nlesson\nletter\nlevel\nliar\nliberty\nlibrary\nlicense\nlife\nlift\nlight\nlike\nlimb\nlimit\nlink\nlion\nliquid\nlist\nlittle\nlive\nlizard\nload\nloan\nlobster\nlocal\nlock\nlogic\nlonely\nlong\nloop\nlottery\nloud\nlounge\nlove\nloyal\nlucky\nluggage\nlumber\nlunar\nlunch\nluxury\nlyrics\nmachine\nmad\nmagic\nmagnet\nmaid\nmail\nmain\nmajor\nmake\nmammal\nman\nmanage\nmandate\nmango\nmansion\nmanual\nmaple\nmarble\nmarch\nmargin\nmarine\nmarket\nmarriage\nmask\nmass\nmaster\nmatch\nmaterial\nmath\nmatrix\nmatter\nmaximum\nmaze\nmeadow\nmean\nmeasure\nmeat\nmechanic\nmedal\nmedia\nmelody\nmelt\nmember\nmemory\nmention\nmenu\nmercy\nmerge\nmerit\nmerry\nmesh\nmessage\nmetal\nmethod\nmiddle\nmidnight\nmilk\nmillion\nmimic\nmind\nminimum\nminor\nminute\nmiracle\nmirror\nmisery\nmiss\nmistake\nmix\nmixed\nmixture\nmobile\nmodel\nmodify\nmom\nmoment\nmonitor\nmonkey\nmonster\nmonth\nmoon\nmoral\nmore\nmorning\nmosquito\nmother\nmotion\nmotor\nmountain\nmouse\nmove\nmovie\nmuch\nmuffin\nmule\nmultiply\nmuscle\nmuseum\nmushroom\nmusic\nmust\nmutual\nmyself\nmystery\nmyth\nnaive\nname\nnapkin\nnarrow\nnasty\nnation\nnature\nnear\nneck\nneed\nnegative\nneglect\nneither\nnephew\nnerve\nnest\nnet\nnetwork\nneutral\nnever\nnews\nnext\nnice\nnight\nnoble\nnoise\nnominee\nnoodle\nnormal\nnorth\nnose\nnotable\nnote\nnothing\nnotice\nnovel\nnow\nnuclear\nnumber\nnurse\nnut\noak\nobey\nobject\noblige\nobscure\nobserve\nobtain\nobvious\noccur\nocean\noctober\nodor\noff\noffer\noffice\noften\noil\nokay\nold\nolive\nolympic\nomit\nonce\none\nonion\nonline\nonly\nopen\nopera\nopinion\noppose\noption\norange\norbit\norchard\norder\nordinary\norgan\norient\noriginal\norphan\nostrich\nother\noutdoor\nouter\noutput\noutside\noval\noven\nover\nown\nowner\noxygen\noyster\nozone\npact\npaddle\npage\npair\npalace\npalm\npanda\npanel\npanic\npanther\npaper\nparade\nparent\npark\nparrot\nparty\npass\npatch\npath\npatient\npatrol\npattern\npause\npave\npayment\npeace\npeanut\npear\npeasant\npelican\npen\npenalty\npencil\npeople\npepper\nperfect\npermit\nperson\npet\nphone\nphoto\nphrase\nphysical\npiano\npicnic\npicture\npiece\npig\npigeon\npill\npilot\npink\npioneer\npipe\npistol\npitch\npizza\nplace\nplanet\nplastic\nplate\nplay\nplease\npledge\npluck\nplug\nplunge\npoem\npoet\npoint\npolar\npole\npolice\npond\npony\npool\npopular\nportion\nposition\npossible\npost\npotato\npottery\npoverty\npowder\npower\npractice\npraise\npredict\nprefer\nprepare\npresent\npretty\nprevent\nprice\npride\nprimary\nprint\npriority\nprison\nprivate\nprize\nproblem\nprocess\nproduce\nprofit\nprogram\nproject\npromote\nproof\nproperty\nprosper\nprotect\nproud\nprovide\npublic\npudding\npull\npulp\npulse\npumpkin\npunch\npupil\npuppy\npurchase\npurity\npurpose\npurse\npush\nput\npuzzle\npyramid\nquality\nquantum\nquarter\nquestion\nquick\nquit\nquiz\nquote\nrabbit\nraccoon\nrace\nrack\nradar\nradio\nrail\nrain\nraise\nrally\nramp\nranch\nrandom\nrange\nrapid\nrare\nrate\nrather\nraven\nraw\nrazor\nready\nreal\nreason\nrebel\nrebuild\nrecall\nreceive\nrecipe\nrecord\nrecycle\nreduce\nreflect\nreform\nrefuse\nregion\nregret\nregular\nreject\nrelax\nrelease\nrelief\nrely\nremain\nremember\nremind\nremove\nrender\nrenew\nrent\nreopen\nrepair\nrepeat\nreplace\nreport\nrequire\nrescue\nresemble\nresist\nresource\nresponse\nresult\nretire\nretreat\nreturn\nreunion\nreveal\nreview\nreward\nrhythm\nrib\nribbon\nrice\nrich\nride\nridge\nrifle\nright\nrigid\nring\nriot\nripple\nrisk\nritual\nrival\nriver\nroad\nroast\nrobot\nrobust\nrocket\nromance\nroof\nrookie\nroom\nrose\nrotate\nrough\nround\nroute\nroyal\nrubber\nrude\nrug\nrule\nrun\nrunway\nrural\nsad\nsaddle\nsadness\nsafe\nsail\nsalad\nsalmon\nsalon\nsalt\nsalute\nsame\nsample\nsand\nsatisfy\nsatoshi\nsauce\nsausage\nsave\nsay\nscale\nscan\nscare\nscatter\nscene\nscheme\nschool\nscience\nscissors\nscorpion\nscout\nscrap\nscreen\nscript\nscrub\nsea\nsearch\nseason\nseat\nsecond\nsecret\nsection\nsecurity\nseed\nseek\nsegment\nselect\nsell\nseminar\nsenior\nsense\nsentence\nseries\nservice\nsession\nsettle\nsetup\nseven\nshadow\nshaft\nshallow\nshare\nshed\nshell\nsheriff\nshield\nshift\nshine\nship\nshiver\nshock\nshoe\nshoot\nshop\nshort\nshoulder\nshove\nshrimp\nshrug\nshuffle\nshy\nsibling\nsick\nside\nsiege\nsight\nsign\nsilent\nsilk\nsilly\nsilver\nsimilar\nsimple\nsince\nsing\nsiren\nsister\nsituate\nsix\nsize\nskate\nsketch\nski\nskill\nskin\nskirt\nskull\nslab\nslam\nsleep\nslender\nslice\nslide\nslight\nslim\nslogan\nslot\nslow\nslush\nsmall\nsmart\nsmile\nsmoke\nsmooth\nsnack\nsnake\nsnap\nsniff\nsnow\nsoap\nsoccer\nsocial\nsock\nsoda\nsoft\nsolar\nsoldier\nsolid\nsolution\nsolve\nsomeone\nsong\nsoon\nsorry\nsort\nsoul\nsound\nsoup\nsource\nsouth\nspace\nspare\nspatial\nspawn\nspeak\nspecial\nspeed\nspell\nspend\nsphere\nspice\nspider\nspike\nspin\nspirit\nsplit\nspoil\nsponsor\nspoon\nsport\nspot\nspray\nspread\nspring\nspy\nsquare\nsqueeze\nsquirrel\nstable\nstadium\nstaff\nstage\nstairs\nstamp\nstand\nstart\nstate\nstay\nsteak\nsteel\nstem\nstep\nstereo\nstick\nstill\nsting\nstock\nstomach\nstone\nstool\nstory\nstove\nstrategy\nstreet\nstrike\nstrong\nstruggle\nstudent\nstuff\nstumble\nstyle\nsubject\nsubmit\nsubway\nsuccess\nsuch\nsudden\nsuffer\nsugar\nsuggest\nsuit\nsummer\nsun\nsunny\nsunset\nsuper\nsupply\nsupreme\nsure\nsurface\nsurge\nsurprise\nsurround\nsurvey\nsuspect\nsustain\nswallow\nswamp\nswap\nswarm\nswear\nsweet\nswift\nswim\nswing\nswitch\nsword\nsymbol\nsymptom\nsyrup\nsystem\ntable\ntackle\ntag\ntail\ntalent\ntalk\ntank\ntape\ntarget\ntask\ntaste\ntattoo\ntaxi\nteach\nteam\ntell\nten\ntenant\ntennis\ntent\nterm\ntest\ntext\nthank\nthat\ntheme\nthen\ntheory\nthere\nthey\nthing\nthis\nthought\nthree\nthrive\nthrow\nthumb\nthunder\nticket\ntide\ntiger\ntilt\ntimber\ntime\ntiny\ntip\ntired\ntissue\ntitle\ntoast\ntobacco\ntoday\ntoddler\ntoe\ntogether\ntoilet\ntoken\ntomato\ntomorrow\ntone\ntongue\ntonight\ntool\ntooth\ntop\ntopic\ntopple\ntorch\ntornado\ntortoise\ntoss\ntotal\ntourist\ntoward\ntower\ntown\ntoy\ntrack\ntrade\ntraffic\ntragic\ntrain\ntransfer\ntrap\ntrash\ntravel\ntray\ntreat\ntree\ntrend\ntrial\ntribe\ntrick\ntrigger\ntrim\ntrip\ntrophy\ntrouble\ntruck\ntrue\ntruly\ntrumpet\ntrust\ntruth\ntry\ntube\ntuition\ntumble\ntuna\ntunnel\nturkey\nturn\nturtle\ntwelve\ntwenty\ntwice\ntwin\ntwist\ntwo\ntype\ntypical\nugly\numbrella\nunable\nunaware\nuncle\nuncover\nunder\nundo\nunfair\nunfold\nunhappy\nuniform\nunique\nunit\nuniverse\nunknown\nunlock\nuntil\nunusual\nunveil\nupdate\nupgrade\nuphold\nupon\nupper\nupset\nurban\nurge\nusage\nuse\nused\nuseful\nuseless\nusual\nutility\nvacant\nvacuum\nvague\nvalid\nvalley\nvalve\nvan\nvanish\nvapor\nvarious\nvast\nvault\nvehicle\nvelvet\nvendor\nventure\nvenue\nverb\nverify\nversion\nvery\nvessel\nveteran\nviable\nvibrant\nvicious\nvictory\nvideo\nview\nvillage\nvintage\nviolin\nvirtual\nvirus\nvisa\nvisit\nvisual\nvital\nvivid\nvocal\nvoice\nvoid\nvolcano\nvolume\nvote\nvoyage\nwage\nwagon\nwait\nwalk\nwall\nwalnut\nwant\nwarfare\nwarm\nwarrior\nwash\nwasp\nwaste\nwater\nwave\nway\nwealth\nweapon\nwear\nweasel\nweather\nweb\nwedding\nweekend\nweird\nwelcome\nwest\nwet\nwhale\nwhat\nwheat\nwheel\nwhen\nwhere\nwhip\nwhisper\nwide\nwidth\nwife\nwild\nwill\nwin\nwindow\nwine\nwing\nwink\nwinner\nwinter\nwire\nwisdom\nwise\nwish\nwitness\nwolf\nwoman\nwonder\nwood\nwool\nword\nwork\nworld\nworry\nworth\nwrap\nwreck\nwrestle\nwrist\nwrite\nwrong\nyard\nyear\nyellow\nyou\nyoung\nyouth\nzebra\nzero\nzone\nzoo`.split(`\n`);\nvar de = {};\nfunction Pr(t) {\n  if (!Number.isSafeInteger(t) || t < 0)\n    throw new Error(`Wrong positive integer: ${t}`);\n}\nfunction Ls(t) {\n  if (typeof t != \"boolean\")\n    throw new Error(`Expected boolean, not ${t}`);\n}\nfunction Ye(t, ...e) {\n  if (!(t instanceof Uint8Array))\n    throw new Error(\"Expected Uint8Array\");\n  if (e.length > 0 && !e.includes(t.length))\n    throw new Error(`Expected Uint8Array of length ${e}, not of length=${t.length}`);\n}\nfunction $s(t) {\n  if (typeof t != \"function\" || typeof t.create != \"function\")\n    throw new Error(\"Hash should be wrapped by utils.wrapConstructor\");\n  Pr(t.outputLen), Pr(t.blockLen);\n}\nfunction qs(t, e = !0) {\n  if (t.destroyed)\n    throw new Error(\"Hash instance has been destroyed\");\n  if (e && t.finished)\n    throw new Error(\"Hash#digest() has already been called\");\n}\nfunction Ns(t, e) {\n  Ye(t);\n  const r = e.outputLen;\n  if (t.length < r)\n    throw new Error(`digestInto() expects output buffer of length at least ${r}`);\n}\nconst Qe = {\n  number: Pr,\n  bool: Ls,\n  bytes: Ye,\n  hash: $s,\n  exists: qs,\n  output: Ns\n}, Du = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  number: Pr,\n  bool: Ls,\n  bytes: Ye,\n  hash: $s,\n  exists: qs,\n  output: Ns,\n  default: Qe\n}, Symbol.toStringTag, { value: \"Module\" })), zu = /* @__PURE__ */ Et(Du);\nvar xt = {}, ne = {};\nObject.defineProperty(ne, \"__esModule\", { value: !0 });\nne.output = ne.exists = ne.hash = ne.bytes = ne.bool = ne.number = void 0;\nfunction Br(t) {\n  if (!Number.isSafeInteger(t) || t < 0)\n    throw new Error(`Wrong positive integer: ${t}`);\n}\nne.number = Br;\nfunction Us(t) {\n  if (typeof t != \"boolean\")\n    throw new Error(`Expected boolean, not ${t}`);\n}\nne.bool = Us;\nfunction ei(t, ...e) {\n  if (!(t instanceof Uint8Array))\n    throw new Error(\"Expected Uint8Array\");\n  if (e.length > 0 && !e.includes(t.length))\n    throw new Error(`Expected Uint8Array of length ${e}, not of length=${t.length}`);\n}\nne.bytes = ei;\nfunction js(t) {\n  if (typeof t != \"function\" || typeof t.create != \"function\")\n    throw new Error(\"Hash should be wrapped by utils.wrapConstructor\");\n  Br(t.outputLen), Br(t.blockLen);\n}\nne.hash = js;\nfunction Hs(t, e = !0) {\n  if (t.destroyed)\n    throw new Error(\"Hash instance has been destroyed\");\n  if (e && t.finished)\n    throw new Error(\"Hash#digest() has already been called\");\n}\nne.exists = Hs;\nfunction Ms(t, e) {\n  ei(t);\n  const r = e.outputLen;\n  if (t.length < r)\n    throw new Error(`digestInto() expects output buffer of length at least ${r}`);\n}\nne.output = Ms;\nconst Fu = {\n  number: Br,\n  bool: Us,\n  bytes: ei,\n  hash: js,\n  exists: Hs,\n  output: Ms\n};\nne.default = Fu;\nvar Ds = {}, ti = {};\nconst Sr = typeof globalThis == \"object\" && \"crypto\" in globalThis ? globalThis.crypto : void 0, Ku = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  crypto: Sr\n}, Symbol.toStringTag, { value: \"Module\" })), Wu = /* @__PURE__ */ Et(Ku);\n(function(t) {\n  /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n  Object.defineProperty(t, \"__esModule\", { value: !0 }), t.randomBytes = t.wrapXOFConstructorWithOpts = t.wrapConstructorWithOpts = t.wrapConstructor = t.checkOpts = t.Hash = t.concatBytes = t.toBytes = t.utf8ToBytes = t.asyncLoop = t.nextTick = t.hexToBytes = t.bytesToHex = t.isLE = t.rotr = t.createView = t.u32 = t.u8 = void 0;\n  const e = Wu, r = (w) => w instanceof Uint8Array, n = (w) => new Uint8Array(w.buffer, w.byteOffset, w.byteLength);\n  t.u8 = n;\n  const i = (w) => new Uint32Array(w.buffer, w.byteOffset, Math.floor(w.byteLength / 4));\n  t.u32 = i;\n  const s = (w) => new DataView(w.buffer, w.byteOffset, w.byteLength);\n  t.createView = s;\n  const o = (w, x) => w << 32 - x | w >>> x;\n  if (t.rotr = o, t.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68, !t.isLE)\n    throw new Error(\"Non little-endian hardware is not supported\");\n  const a = Array.from({ length: 256 }, (w, x) => x.toString(16).padStart(2, \"0\"));\n  function c(w) {\n    if (!r(w))\n      throw new Error(\"Uint8Array expected\");\n    let x = \"\";\n    for (let A = 0; A < w.length; A++)\n      x += a[w[A]];\n    return x;\n  }\n  t.bytesToHex = c;\n  function l(w) {\n    if (typeof w != \"string\")\n      throw new Error(\"hex string expected, got \" + typeof w);\n    const x = w.length;\n    if (x % 2)\n      throw new Error(\"padded hex string expected, got unpadded hex of length \" + x);\n    const A = new Uint8Array(x / 2);\n    for (let B = 0; B < A.length; B++) {\n      const L = B * 2, P = w.slice(L, L + 2), F = Number.parseInt(P, 16);\n      if (Number.isNaN(F) || F < 0)\n        throw new Error(\"Invalid byte sequence\");\n      A[B] = F;\n    }\n    return A;\n  }\n  t.hexToBytes = l;\n  const f = async () => {\n  };\n  t.nextTick = f;\n  async function u(w, x, A) {\n    let B = Date.now();\n    for (let L = 0; L < w; L++) {\n      A(L);\n      const P = Date.now() - B;\n      P >= 0 && P < x || (await (0, t.nextTick)(), B += P);\n    }\n  }\n  t.asyncLoop = u;\n  function h(w) {\n    if (typeof w != \"string\")\n      throw new Error(`utf8ToBytes expected string, got ${typeof w}`);\n    return new Uint8Array(new TextEncoder().encode(w));\n  }\n  t.utf8ToBytes = h;\n  function d(w) {\n    if (typeof w == \"string\" && (w = h(w)), !r(w))\n      throw new Error(`expected Uint8Array, got ${typeof w}`);\n    return w;\n  }\n  t.toBytes = d;\n  function p(...w) {\n    const x = new Uint8Array(w.reduce((B, L) => B + L.length, 0));\n    let A = 0;\n    return w.forEach((B) => {\n      if (!r(B))\n        throw new Error(\"Uint8Array expected\");\n      x.set(B, A), A += B.length;\n    }), x;\n  }\n  t.concatBytes = p;\n  class y {\n    clone() {\n      return this._cloneInto();\n    }\n  }\n  t.Hash = y;\n  const g = (w) => Object.prototype.toString.call(w) === \"[object Object]\" && w.constructor === Object;\n  function v(w, x) {\n    if (x !== void 0 && (typeof x != \"object\" || !g(x)))\n      throw new Error(\"Options should be object or undefined\");\n    return Object.assign(w, x);\n  }\n  t.checkOpts = v;\n  function _(w) {\n    const x = (B) => w().update(d(B)).digest(), A = w();\n    return x.outputLen = A.outputLen, x.blockLen = A.blockLen, x.create = () => w(), x;\n  }\n  t.wrapConstructor = _;\n  function m(w) {\n    const x = (B, L) => w(L).update(d(B)).digest(), A = w({});\n    return x.outputLen = A.outputLen, x.blockLen = A.blockLen, x.create = (B) => w(B), x;\n  }\n  t.wrapConstructorWithOpts = m;\n  function C(w) {\n    const x = (B, L) => w(L).update(d(B)).digest(), A = w({});\n    return x.outputLen = A.outputLen, x.blockLen = A.blockLen, x.create = (B) => w(B), x;\n  }\n  t.wrapXOFConstructorWithOpts = C;\n  function O(w = 32) {\n    if (e.crypto && typeof e.crypto.getRandomValues == \"function\")\n      return e.crypto.getRandomValues(new Uint8Array(w));\n    throw new Error(\"crypto.getRandomValues must be defined\");\n  }\n  t.randomBytes = O;\n})(ti);\n(function(t) {\n  Object.defineProperty(t, \"__esModule\", { value: !0 }), t.hmac = t.HMAC = void 0;\n  const e = ne, r = ti;\n  class n extends r.Hash {\n    constructor(o, a) {\n      super(), this.finished = !1, this.destroyed = !1, e.default.hash(o);\n      const c = (0, r.toBytes)(a);\n      if (this.iHash = o.create(), typeof this.iHash.update != \"function\")\n        throw new Error(\"Expected instance of class which extends utils.Hash\");\n      this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;\n      const l = this.blockLen, f = new Uint8Array(l);\n      f.set(c.length > l ? o.create().update(c).digest() : c);\n      for (let u = 0; u < f.length; u++)\n        f[u] ^= 54;\n      this.iHash.update(f), this.oHash = o.create();\n      for (let u = 0; u < f.length; u++)\n        f[u] ^= 106;\n      this.oHash.update(f), f.fill(0);\n    }\n    update(o) {\n      return e.default.exists(this), this.iHash.update(o), this;\n    }\n    digestInto(o) {\n      e.default.exists(this), e.default.bytes(o, this.outputLen), this.finished = !0, this.iHash.digestInto(o), this.oHash.update(o), this.oHash.digestInto(o), this.destroy();\n    }\n    digest() {\n      const o = new Uint8Array(this.oHash.outputLen);\n      return this.digestInto(o), o;\n    }\n    _cloneInto(o) {\n      o || (o = Object.create(Object.getPrototypeOf(this), {}));\n      const { oHash: a, iHash: c, finished: l, destroyed: f, blockLen: u, outputLen: h } = this;\n      return o = o, o.finished = l, o.destroyed = f, o.blockLen = u, o.outputLen = h, o.oHash = a._cloneInto(o.oHash), o.iHash = c._cloneInto(o.iHash), o;\n    }\n    destroy() {\n      this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();\n    }\n  }\n  t.HMAC = n;\n  const i = (s, o, a) => new n(s, o).update(a).digest();\n  t.hmac = i, t.hmac.create = (s, o) => new n(s, o);\n})(Ds);\nObject.defineProperty(xt, \"__esModule\", { value: !0 });\nxt.pbkdf2Async = xt.pbkdf2 = void 0;\nconst hr = ne, Vu = Ds, bt = ti;\nfunction zs(t, e, r, n) {\n  hr.default.hash(t);\n  const i = (0, bt.checkOpts)({ dkLen: 32, asyncTick: 10 }, n), { c: s, dkLen: o, asyncTick: a } = i;\n  if (hr.default.number(s), hr.default.number(o), hr.default.number(a), s < 1)\n    throw new Error(\"PBKDF2: iterations (c) should be >= 1\");\n  const c = (0, bt.toBytes)(e), l = (0, bt.toBytes)(r), f = new Uint8Array(o), u = Vu.hmac.create(t, c), h = u._cloneInto().update(l);\n  return { c: s, dkLen: o, asyncTick: a, DK: f, PRF: u, PRFSalt: h };\n}\nfunction Fs(t, e, r, n, i) {\n  return t.destroy(), e.destroy(), n && n.destroy(), i.fill(0), r;\n}\nfunction Gu(t, e, r, n) {\n  const { c: i, dkLen: s, DK: o, PRF: a, PRFSalt: c } = zs(t, e, r, n);\n  let l;\n  const f = new Uint8Array(4), u = (0, bt.createView)(f), h = new Uint8Array(a.outputLen);\n  for (let d = 1, p = 0; p < s; d++, p += a.outputLen) {\n    const y = o.subarray(p, p + a.outputLen);\n    u.setInt32(0, d, !1), (l = c._cloneInto(l)).update(f).digestInto(h), y.set(h.subarray(0, y.length));\n    for (let g = 1; g < i; g++) {\n      a._cloneInto(l).update(h).digestInto(h);\n      for (let v = 0; v < y.length; v++)\n        y[v] ^= h[v];\n    }\n  }\n  return Fs(a, c, o, l, h);\n}\nxt.pbkdf2 = Gu;\nasync function Zu(t, e, r, n) {\n  const { c: i, dkLen: s, asyncTick: o, DK: a, PRF: c, PRFSalt: l } = zs(t, e, r, n);\n  let f;\n  const u = new Uint8Array(4), h = (0, bt.createView)(u), d = new Uint8Array(c.outputLen);\n  for (let p = 1, y = 0; y < s; p++, y += c.outputLen) {\n    const g = a.subarray(y, y + c.outputLen);\n    h.setInt32(0, p, !1), (f = l._cloneInto(f)).update(u).digestInto(d), g.set(d.subarray(0, g.length)), await (0, bt.asyncLoop)(i - 1, o, (v) => {\n      c._cloneInto(f).update(d).digestInto(d);\n      for (let _ = 0; _ < g.length; _++)\n        g[_] ^= d[_];\n    });\n  }\n  return Fs(c, l, a, f, d);\n}\nxt.pbkdf2Async = Zu;\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst ri = (t) => t instanceof Uint8Array, Yu = (t) => new Uint8Array(t.buffer, t.byteOffset, t.byteLength), Ju = (t) => new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4)), ft = (t) => new DataView(t.buffer, t.byteOffset, t.byteLength), Ee = (t, e) => t << 32 - e | t >>> e, Ks = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;\nif (!Ks)\n  throw new Error(\"Non little-endian hardware is not supported\");\nconst Xu = Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, \"0\"));\nfunction ni(t) {\n  if (!ri(t))\n    throw new Error(\"Uint8Array expected\");\n  let e = \"\";\n  for (let r = 0; r < t.length; r++)\n    e += Xu[t[r]];\n  return e;\n}\nfunction Ws(t) {\n  if (typeof t != \"string\")\n    throw new Error(\"hex string expected, got \" + typeof t);\n  const e = t.length;\n  if (e % 2)\n    throw new Error(\"padded hex string expected, got unpadded hex of length \" + e);\n  const r = new Uint8Array(e / 2);\n  for (let n = 0; n < r.length; n++) {\n    const i = n * 2, s = t.slice(i, i + 2), o = Number.parseInt(s, 16);\n    if (Number.isNaN(o) || o < 0)\n      throw new Error(\"Invalid byte sequence\");\n    r[n] = o;\n  }\n  return r;\n}\nconst Vs = async () => {\n};\nasync function Qu(t, e, r) {\n  let n = Date.now();\n  for (let i = 0; i < t; i++) {\n    r(i);\n    const s = Date.now() - n;\n    s >= 0 && s < e || (await Vs(), n += s);\n  }\n}\nfunction ii(t) {\n  if (typeof t != \"string\")\n    throw new Error(`utf8ToBytes expected string, got ${typeof t}`);\n  return new Uint8Array(new TextEncoder().encode(t));\n}\nfunction Ot(t) {\n  if (typeof t == \"string\" && (t = ii(t)), !ri(t))\n    throw new Error(`expected Uint8Array, got ${typeof t}`);\n  return t;\n}\nfunction er(...t) {\n  const e = new Uint8Array(t.reduce((n, i) => n + i.length, 0));\n  let r = 0;\n  return t.forEach((n) => {\n    if (!ri(n))\n      throw new Error(\"Uint8Array expected\");\n    e.set(n, r), r += n.length;\n  }), e;\n}\nclass oi {\n  clone() {\n    return this._cloneInto();\n  }\n}\nconst el = (t) => Object.prototype.toString.call(t) === \"[object Object]\" && t.constructor === Object;\nfunction tl(t, e) {\n  if (e !== void 0 && (typeof e != \"object\" || !el(e)))\n    throw new Error(\"Options should be object or undefined\");\n  return Object.assign(t, e);\n}\nfunction nt(t) {\n  const e = (n) => t().update(Ot(n)).digest(), r = t();\n  return e.outputLen = r.outputLen, e.blockLen = r.blockLen, e.create = () => t(), e;\n}\nfunction rl(t) {\n  const e = (n, i) => t(i).update(Ot(n)).digest(), r = t({});\n  return e.outputLen = r.outputLen, e.blockLen = r.blockLen, e.create = (n) => t(n), e;\n}\nfunction nl(t) {\n  const e = (n, i) => t(i).update(Ot(n)).digest(), r = t({});\n  return e.outputLen = r.outputLen, e.blockLen = r.blockLen, e.create = (n) => t(n), e;\n}\nfunction il(t = 32) {\n  if (Sr && typeof Sr.getRandomValues == \"function\")\n    return Sr.getRandomValues(new Uint8Array(t));\n  throw new Error(\"crypto.getRandomValues must be defined\");\n}\nconst ol = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  u8: Yu,\n  u32: Ju,\n  createView: ft,\n  rotr: Ee,\n  isLE: Ks,\n  bytesToHex: ni,\n  hexToBytes: Ws,\n  nextTick: Vs,\n  asyncLoop: Qu,\n  utf8ToBytes: ii,\n  toBytes: Ot,\n  concatBytes: er,\n  Hash: oi,\n  checkOpts: tl,\n  wrapConstructor: nt,\n  wrapConstructorWithOpts: rl,\n  wrapXOFConstructorWithOpts: nl,\n  randomBytes: il\n}, Symbol.toStringTag, { value: \"Module\" }));\nfunction sl(t, e, r, n) {\n  if (typeof t.setBigUint64 == \"function\")\n    return t.setBigUint64(e, r, n);\n  const i = BigInt(32), s = BigInt(4294967295), o = Number(r >> i & s), a = Number(r & s), c = n ? 4 : 0, l = n ? 0 : 4;\n  t.setUint32(e + c, o, n), t.setUint32(e + l, a, n);\n}\nclass si extends oi {\n  constructor(e, r, n, i) {\n    super(), this.blockLen = e, this.outputLen = r, this.padOffset = n, this.isLE = i, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = ft(this.buffer);\n  }\n  update(e) {\n    Qe.exists(this);\n    const { view: r, buffer: n, blockLen: i } = this;\n    e = Ot(e);\n    const s = e.length;\n    for (let o = 0; o < s; ) {\n      const a = Math.min(i - this.pos, s - o);\n      if (a === i) {\n        const c = ft(e);\n        for (; i <= s - o; o += i)\n          this.process(c, o);\n        continue;\n      }\n      n.set(e.subarray(o, o + a), this.pos), this.pos += a, o += a, this.pos === i && (this.process(r, 0), this.pos = 0);\n    }\n    return this.length += e.length, this.roundClean(), this;\n  }\n  digestInto(e) {\n    Qe.exists(this), Qe.output(e, this), this.finished = !0;\n    const { buffer: r, view: n, blockLen: i, isLE: s } = this;\n    let { pos: o } = this;\n    r[o++] = 128, this.buffer.subarray(o).fill(0), this.padOffset > i - o && (this.process(n, 0), o = 0);\n    for (let u = o; u < i; u++)\n      r[u] = 0;\n    sl(n, i - 8, BigInt(this.length * 8), s), this.process(n, 0);\n    const a = ft(e), c = this.outputLen;\n    if (c % 4)\n      throw new Error(\"_sha2: outputLen should be aligned to 32bit\");\n    const l = c / 4, f = this.get();\n    if (l > f.length)\n      throw new Error(\"_sha2: outputLen bigger than state\");\n    for (let u = 0; u < l; u++)\n      a.setUint32(4 * u, f[u], s);\n  }\n  digest() {\n    const { buffer: e, outputLen: r } = this;\n    this.digestInto(e);\n    const n = e.slice(0, r);\n    return this.destroy(), n;\n  }\n  _cloneInto(e) {\n    e || (e = new this.constructor()), e.set(...this.get());\n    const { blockLen: r, buffer: n, length: i, finished: s, destroyed: o, pos: a } = this;\n    return e.length = i, e.pos = a, e.finished = s, e.destroyed = o, i % r && e.buffer.set(n), e;\n  }\n}\nconst al = (t, e, r) => t & e ^ ~t & r, cl = (t, e, r) => t & e ^ t & r ^ e & r, ul = new Uint32Array([\n  1116352408,\n  1899447441,\n  3049323471,\n  3921009573,\n  961987163,\n  1508970993,\n  2453635748,\n  2870763221,\n  3624381080,\n  310598401,\n  607225278,\n  1426881987,\n  1925078388,\n  2162078206,\n  2614888103,\n  3248222580,\n  3835390401,\n  4022224774,\n  264347078,\n  604807628,\n  770255983,\n  1249150122,\n  1555081692,\n  1996064986,\n  2554220882,\n  2821834349,\n  2952996808,\n  3210313671,\n  3336571891,\n  3584528711,\n  113926993,\n  338241895,\n  666307205,\n  773529912,\n  1294757372,\n  1396182291,\n  1695183700,\n  1986661051,\n  2177026350,\n  2456956037,\n  2730485921,\n  2820302411,\n  3259730800,\n  3345764771,\n  3516065817,\n  3600352804,\n  4094571909,\n  275423344,\n  430227734,\n  506948616,\n  659060556,\n  883997877,\n  958139571,\n  1322822218,\n  1537002063,\n  1747873779,\n  1955562222,\n  2024104815,\n  2227730452,\n  2361852424,\n  2428436474,\n  2756734187,\n  3204031479,\n  3329325298\n]), Ke = new Uint32Array([\n  1779033703,\n  3144134277,\n  1013904242,\n  2773480762,\n  1359893119,\n  2600822924,\n  528734635,\n  1541459225\n]), We = new Uint32Array(64);\nclass Gs extends si {\n  constructor() {\n    super(64, 32, 8, !1), this.A = Ke[0] | 0, this.B = Ke[1] | 0, this.C = Ke[2] | 0, this.D = Ke[3] | 0, this.E = Ke[4] | 0, this.F = Ke[5] | 0, this.G = Ke[6] | 0, this.H = Ke[7] | 0;\n  }\n  get() {\n    const { A: e, B: r, C: n, D: i, E: s, F: o, G: a, H: c } = this;\n    return [e, r, n, i, s, o, a, c];\n  }\n  set(e, r, n, i, s, o, a, c) {\n    this.A = e | 0, this.B = r | 0, this.C = n | 0, this.D = i | 0, this.E = s | 0, this.F = o | 0, this.G = a | 0, this.H = c | 0;\n  }\n  process(e, r) {\n    for (let u = 0; u < 16; u++, r += 4)\n      We[u] = e.getUint32(r, !1);\n    for (let u = 16; u < 64; u++) {\n      const h = We[u - 15], d = We[u - 2], p = Ee(h, 7) ^ Ee(h, 18) ^ h >>> 3, y = Ee(d, 17) ^ Ee(d, 19) ^ d >>> 10;\n      We[u] = y + We[u - 7] + p + We[u - 16] | 0;\n    }\n    let { A: n, B: i, C: s, D: o, E: a, F: c, G: l, H: f } = this;\n    for (let u = 0; u < 64; u++) {\n      const h = Ee(a, 6) ^ Ee(a, 11) ^ Ee(a, 25), d = f + h + al(a, c, l) + ul[u] + We[u] | 0, y = (Ee(n, 2) ^ Ee(n, 13) ^ Ee(n, 22)) + cl(n, i, s) | 0;\n      f = l, l = c, c = a, a = o + d | 0, o = s, s = i, i = n, n = d + y | 0;\n    }\n    n = n + this.A | 0, i = i + this.B | 0, s = s + this.C | 0, o = o + this.D | 0, a = a + this.E | 0, c = c + this.F | 0, l = l + this.G | 0, f = f + this.H | 0, this.set(n, i, s, o, a, c, l, f);\n  }\n  roundClean() {\n    We.fill(0);\n  }\n  destroy() {\n    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);\n  }\n}\nclass ll extends Gs {\n  constructor() {\n    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;\n  }\n}\nconst jr = nt(() => new Gs()), fl = nt(() => new ll()), hl = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  sha256: jr,\n  sha224: fl\n}, Symbol.toStringTag, { value: \"Module\" })), dl = /* @__PURE__ */ Et(hl), dr = BigInt(2 ** 32 - 1), $n = BigInt(32);\nfunction Zs(t, e = !1) {\n  return e ? { h: Number(t & dr), l: Number(t >> $n & dr) } : { h: Number(t >> $n & dr) | 0, l: Number(t & dr) | 0 };\n}\nfunction pl(t, e = !1) {\n  let r = new Uint32Array(t.length), n = new Uint32Array(t.length);\n  for (let i = 0; i < t.length; i++) {\n    const { h: s, l: o } = Zs(t[i], e);\n    [r[i], n[i]] = [s, o];\n  }\n  return [r, n];\n}\nconst yl = (t, e) => BigInt(t >>> 0) << $n | BigInt(e >>> 0), gl = (t, e, r) => t >>> r, bl = (t, e, r) => t << 32 - r | e >>> r, vl = (t, e, r) => t >>> r | e << 32 - r, wl = (t, e, r) => t << 32 - r | e >>> r, _l = (t, e, r) => t << 64 - r | e >>> r - 32, ml = (t, e, r) => t >>> r - 32 | e << 64 - r, xl = (t, e) => e, El = (t, e) => t, kl = (t, e, r) => t << r | e >>> 32 - r, Sl = (t, e, r) => e << r | t >>> 32 - r, Ol = (t, e, r) => e << r - 32 | t >>> 64 - r, Al = (t, e, r) => t << r - 32 | e >>> 64 - r;\nfunction Cl(t, e, r, n) {\n  const i = (e >>> 0) + (n >>> 0);\n  return { h: t + r + (i / 2 ** 32 | 0) | 0, l: i | 0 };\n}\nconst Il = (t, e, r) => (t >>> 0) + (e >>> 0) + (r >>> 0), Rl = (t, e, r, n) => e + r + n + (t / 2 ** 32 | 0) | 0, Tl = (t, e, r, n) => (t >>> 0) + (e >>> 0) + (r >>> 0) + (n >>> 0), Pl = (t, e, r, n, i) => e + r + n + i + (t / 2 ** 32 | 0) | 0, Bl = (t, e, r, n, i) => (t >>> 0) + (e >>> 0) + (r >>> 0) + (n >>> 0) + (i >>> 0), Ll = (t, e, r, n, i, s) => e + r + n + i + s + (t / 2 ** 32 | 0) | 0, N = {\n  fromBig: Zs,\n  split: pl,\n  toBig: yl,\n  shrSH: gl,\n  shrSL: bl,\n  rotrSH: vl,\n  rotrSL: wl,\n  rotrBH: _l,\n  rotrBL: ml,\n  rotr32H: xl,\n  rotr32L: El,\n  rotlSH: kl,\n  rotlSL: Sl,\n  rotlBH: Ol,\n  rotlBL: Al,\n  add: Cl,\n  add3L: Il,\n  add3H: Rl,\n  add4L: Tl,\n  add4H: Pl,\n  add5H: Ll,\n  add5L: Bl\n}, [$l, ql] = N.split([\n  \"0x428a2f98d728ae22\",\n  \"0x7137449123ef65cd\",\n  \"0xb5c0fbcfec4d3b2f\",\n  \"0xe9b5dba58189dbbc\",\n  \"0x3956c25bf348b538\",\n  \"0x59f111f1b605d019\",\n  \"0x923f82a4af194f9b\",\n  \"0xab1c5ed5da6d8118\",\n  \"0xd807aa98a3030242\",\n  \"0x12835b0145706fbe\",\n  \"0x243185be4ee4b28c\",\n  \"0x550c7dc3d5ffb4e2\",\n  \"0x72be5d74f27b896f\",\n  \"0x80deb1fe3b1696b1\",\n  \"0x9bdc06a725c71235\",\n  \"0xc19bf174cf692694\",\n  \"0xe49b69c19ef14ad2\",\n  \"0xefbe4786384f25e3\",\n  \"0x0fc19dc68b8cd5b5\",\n  \"0x240ca1cc77ac9c65\",\n  \"0x2de92c6f592b0275\",\n  \"0x4a7484aa6ea6e483\",\n  \"0x5cb0a9dcbd41fbd4\",\n  \"0x76f988da831153b5\",\n  \"0x983e5152ee66dfab\",\n  \"0xa831c66d2db43210\",\n  \"0xb00327c898fb213f\",\n  \"0xbf597fc7beef0ee4\",\n  \"0xc6e00bf33da88fc2\",\n  \"0xd5a79147930aa725\",\n  \"0x06ca6351e003826f\",\n  \"0x142929670a0e6e70\",\n  \"0x27b70a8546d22ffc\",\n  \"0x2e1b21385c26c926\",\n  \"0x4d2c6dfc5ac42aed\",\n  \"0x53380d139d95b3df\",\n  \"0x650a73548baf63de\",\n  \"0x766a0abb3c77b2a8\",\n  \"0x81c2c92e47edaee6\",\n  \"0x92722c851482353b\",\n  \"0xa2bfe8a14cf10364\",\n  \"0xa81a664bbc423001\",\n  \"0xc24b8b70d0f89791\",\n  \"0xc76c51a30654be30\",\n  \"0xd192e819d6ef5218\",\n  \"0xd69906245565a910\",\n  \"0xf40e35855771202a\",\n  \"0x106aa07032bbd1b8\",\n  \"0x19a4c116b8d2d0c8\",\n  \"0x1e376c085141ab53\",\n  \"0x2748774cdf8eeb99\",\n  \"0x34b0bcb5e19b48a8\",\n  \"0x391c0cb3c5c95a63\",\n  \"0x4ed8aa4ae3418acb\",\n  \"0x5b9cca4f7763e373\",\n  \"0x682e6ff3d6b2b8a3\",\n  \"0x748f82ee5defb2fc\",\n  \"0x78a5636f43172f60\",\n  \"0x84c87814a1f0ab72\",\n  \"0x8cc702081a6439ec\",\n  \"0x90befffa23631e28\",\n  \"0xa4506cebde82bde9\",\n  \"0xbef9a3f7b2c67915\",\n  \"0xc67178f2e372532b\",\n  \"0xca273eceea26619c\",\n  \"0xd186b8c721c0c207\",\n  \"0xeada7dd6cde0eb1e\",\n  \"0xf57d4f7fee6ed178\",\n  \"0x06f067aa72176fba\",\n  \"0x0a637dc5a2c898a6\",\n  \"0x113f9804bef90dae\",\n  \"0x1b710b35131c471b\",\n  \"0x28db77f523047d84\",\n  \"0x32caab7b40c72493\",\n  \"0x3c9ebe0a15c9bebc\",\n  \"0x431d67c49c100d4c\",\n  \"0x4cc5d4becb3e42b6\",\n  \"0x597f299cfc657e2a\",\n  \"0x5fcb6fab3ad6faec\",\n  \"0x6c44198c4a475817\"\n].map((t) => BigInt(t))), Ve = new Uint32Array(80), Ge = new Uint32Array(80);\nclass ar extends si {\n  constructor() {\n    super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;\n  }\n  get() {\n    const { Ah: e, Al: r, Bh: n, Bl: i, Ch: s, Cl: o, Dh: a, Dl: c, Eh: l, El: f, Fh: u, Fl: h, Gh: d, Gl: p, Hh: y, Hl: g } = this;\n    return [e, r, n, i, s, o, a, c, l, f, u, h, d, p, y, g];\n  }\n  set(e, r, n, i, s, o, a, c, l, f, u, h, d, p, y, g) {\n    this.Ah = e | 0, this.Al = r | 0, this.Bh = n | 0, this.Bl = i | 0, this.Ch = s | 0, this.Cl = o | 0, this.Dh = a | 0, this.Dl = c | 0, this.Eh = l | 0, this.El = f | 0, this.Fh = u | 0, this.Fl = h | 0, this.Gh = d | 0, this.Gl = p | 0, this.Hh = y | 0, this.Hl = g | 0;\n  }\n  process(e, r) {\n    for (let m = 0; m < 16; m++, r += 4)\n      Ve[m] = e.getUint32(r), Ge[m] = e.getUint32(r += 4);\n    for (let m = 16; m < 80; m++) {\n      const C = Ve[m - 15] | 0, O = Ge[m - 15] | 0, w = N.rotrSH(C, O, 1) ^ N.rotrSH(C, O, 8) ^ N.shrSH(C, O, 7), x = N.rotrSL(C, O, 1) ^ N.rotrSL(C, O, 8) ^ N.shrSL(C, O, 7), A = Ve[m - 2] | 0, B = Ge[m - 2] | 0, L = N.rotrSH(A, B, 19) ^ N.rotrBH(A, B, 61) ^ N.shrSH(A, B, 6), P = N.rotrSL(A, B, 19) ^ N.rotrBL(A, B, 61) ^ N.shrSL(A, B, 6), F = N.add4L(x, P, Ge[m - 7], Ge[m - 16]), z = N.add4H(F, w, L, Ve[m - 7], Ve[m - 16]);\n      Ve[m] = z | 0, Ge[m] = F | 0;\n    }\n    let { Ah: n, Al: i, Bh: s, Bl: o, Ch: a, Cl: c, Dh: l, Dl: f, Eh: u, El: h, Fh: d, Fl: p, Gh: y, Gl: g, Hh: v, Hl: _ } = this;\n    for (let m = 0; m < 80; m++) {\n      const C = N.rotrSH(u, h, 14) ^ N.rotrSH(u, h, 18) ^ N.rotrBH(u, h, 41), O = N.rotrSL(u, h, 14) ^ N.rotrSL(u, h, 18) ^ N.rotrBL(u, h, 41), w = u & d ^ ~u & y, x = h & p ^ ~h & g, A = N.add5L(_, O, x, ql[m], Ge[m]), B = N.add5H(A, v, C, w, $l[m], Ve[m]), L = A | 0, P = N.rotrSH(n, i, 28) ^ N.rotrBH(n, i, 34) ^ N.rotrBH(n, i, 39), F = N.rotrSL(n, i, 28) ^ N.rotrBL(n, i, 34) ^ N.rotrBL(n, i, 39), z = n & s ^ n & a ^ s & a, G = i & o ^ i & c ^ o & c;\n      v = y | 0, _ = g | 0, y = d | 0, g = p | 0, d = u | 0, p = h | 0, { h: u, l: h } = N.add(l | 0, f | 0, B | 0, L | 0), l = a | 0, f = c | 0, a = s | 0, c = o | 0, s = n | 0, o = i | 0;\n      const E = N.add3L(L, F, G);\n      n = N.add3H(E, B, P, z), i = E | 0;\n    }\n    ({ h: n, l: i } = N.add(this.Ah | 0, this.Al | 0, n | 0, i | 0)), { h: s, l: o } = N.add(this.Bh | 0, this.Bl | 0, s | 0, o | 0), { h: a, l: c } = N.add(this.Ch | 0, this.Cl | 0, a | 0, c | 0), { h: l, l: f } = N.add(this.Dh | 0, this.Dl | 0, l | 0, f | 0), { h: u, l: h } = N.add(this.Eh | 0, this.El | 0, u | 0, h | 0), { h: d, l: p } = N.add(this.Fh | 0, this.Fl | 0, d | 0, p | 0), { h: y, l: g } = N.add(this.Gh | 0, this.Gl | 0, y | 0, g | 0), { h: v, l: _ } = N.add(this.Hh | 0, this.Hl | 0, v | 0, _ | 0), this.set(n, i, s, o, a, c, l, f, u, h, d, p, y, g, v, _);\n  }\n  roundClean() {\n    Ve.fill(0), Ge.fill(0);\n  }\n  destroy() {\n    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n  }\n}\nclass Nl extends ar {\n  constructor() {\n    super(), this.Ah = -1942145080, this.Al = 424955298, this.Bh = 1944164710, this.Bl = -1982016298, this.Ch = 502970286, this.Cl = 855612546, this.Dh = 1738396948, this.Dl = 1479516111, this.Eh = 258812777, this.El = 2077511080, this.Fh = 2011393907, this.Fl = 79989058, this.Gh = 1067287976, this.Gl = 1780299464, this.Hh = 286451373, this.Hl = -1848208735, this.outputLen = 28;\n  }\n}\nclass Ul extends ar {\n  constructor() {\n    super(), this.Ah = 573645204, this.Al = -64227540, this.Bh = -1621794909, this.Bl = -934517566, this.Ch = 596883563, this.Cl = 1867755857, this.Dh = -1774684391, this.Dl = 1497426621, this.Eh = -1775747358, this.El = -1467023389, this.Fh = -1101128155, this.Fl = 1401305490, this.Gh = 721525244, this.Gl = 746961066, this.Hh = 246885852, this.Hl = -2117784414, this.outputLen = 32;\n  }\n}\nclass jl extends ar {\n  constructor() {\n    super(), this.Ah = -876896931, this.Al = -1056596264, this.Bh = 1654270250, this.Bl = 914150663, this.Ch = -1856437926, this.Cl = 812702999, this.Dh = 355462360, this.Dl = -150054599, this.Eh = 1731405415, this.El = -4191439, this.Fh = -1900787065, this.Fl = 1750603025, this.Gh = -619958771, this.Gl = 1694076839, this.Hh = 1203062813, this.Hl = -1090891868, this.outputLen = 48;\n  }\n}\nconst qn = nt(() => new ar()), Hl = nt(() => new Nl()), Ml = nt(() => new Ul()), Dl = nt(() => new jl()), zl = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  SHA512: ar,\n  sha512: qn,\n  sha512_224: Hl,\n  sha512_256: Ml,\n  sha384: Dl\n}, Symbol.toStringTag, { value: \"Module\" })), Fl = /* @__PURE__ */ Et(zl), Kl = /* @__PURE__ */ Et(ol), Wl = /* @__PURE__ */ Et(Mu);\nObject.defineProperty(de, \"__esModule\", { value: !0 });\nvar Ys = de.mnemonicToSeedSync = de.mnemonicToSeed = sa = de.validateMnemonic = de.entropyToMnemonic = de.mnemonicToEntropy = ra = de.generateMnemonic = void 0;\n/*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */\nconst Js = zu, Xs = xt, Vl = dl, Qs = Fl, Gl = Kl, pr = Wl, Zl = (t) => t[0] === \"\\u3042\\u3044\\u3053\\u304F\\u3057\\u3093\";\nfunction ea(t) {\n  if (typeof t != \"string\")\n    throw new TypeError(`Invalid mnemonic type: ${typeof t}`);\n  return t.normalize(\"NFKD\");\n}\nfunction ai(t) {\n  const e = ea(t), r = e.split(\" \");\n  if (![12, 15, 18, 21, 24].includes(r.length))\n    throw new Error(\"Invalid mnemonic\");\n  return { nfkd: e, words: r };\n}\nfunction ta(t) {\n  Js.default.bytes(t, 16, 20, 24, 28, 32);\n}\nfunction Yl(t, e = 128) {\n  if (Js.default.number(e), e % 32 !== 0 || e > 256)\n    throw new TypeError(\"Invalid entropy\");\n  return oa((0, Gl.randomBytes)(e / 8), t);\n}\nvar ra = de.generateMnemonic = Yl;\nconst Jl = (t) => {\n  const e = 8 - t.length / 4;\n  return new Uint8Array([(0, Vl.sha256)(t)[0] >> e << e]);\n};\nfunction na(t) {\n  if (!Array.isArray(t) || t.length !== 2048 || typeof t[0] != \"string\")\n    throw new Error(\"Worlist: expected array of 2048 strings\");\n  return t.forEach((e) => {\n    if (typeof e != \"string\")\n      throw new Error(`Wordlist: non-string element: ${e}`);\n  }), pr.utils.chain(pr.utils.checksum(1, Jl), pr.utils.radix2(11, !0), pr.utils.alphabet(t));\n}\nfunction ia(t, e) {\n  const { words: r } = ai(t), n = na(e).decode(r);\n  return ta(n), n;\n}\nde.mnemonicToEntropy = ia;\nfunction oa(t, e) {\n  return ta(t), na(e).encode(t).join(Zl(e) ? \"\\u3000\" : \" \");\n}\nde.entropyToMnemonic = oa;\nfunction Xl(t, e) {\n  try {\n    ia(t, e);\n  } catch {\n    return !1;\n  }\n  return !0;\n}\nvar sa = de.validateMnemonic = Xl;\nconst aa = (t) => ea(`mnemonic${t}`);\nfunction Ql(t, e = \"\") {\n  return (0, Xs.pbkdf2Async)(Qs.sha512, ai(t).nfkd, aa(e), { c: 2048, dkLen: 64 });\n}\nde.mnemonicToSeed = Ql;\nfunction ef(t, e = \"\") {\n  return (0, Xs.pbkdf2)(Qs.sha512, ai(t).nfkd, aa(e), { c: 2048, dkLen: 64 });\n}\nYs = de.mnemonicToSeedSync = ef;\nclass ca extends oi {\n  constructor(e, r) {\n    super(), this.finished = !1, this.destroyed = !1, Qe.hash(e);\n    const n = Ot(r);\n    if (this.iHash = e.create(), typeof this.iHash.update != \"function\")\n      throw new Error(\"Expected instance of class which extends utils.Hash\");\n    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;\n    const i = this.blockLen, s = new Uint8Array(i);\n    s.set(n.length > i ? e.create().update(n).digest() : n);\n    for (let o = 0; o < s.length; o++)\n      s[o] ^= 54;\n    this.iHash.update(s), this.oHash = e.create();\n    for (let o = 0; o < s.length; o++)\n      s[o] ^= 106;\n    this.oHash.update(s), s.fill(0);\n  }\n  update(e) {\n    return Qe.exists(this), this.iHash.update(e), this;\n  }\n  digestInto(e) {\n    Qe.exists(this), Qe.bytes(e, this.outputLen), this.finished = !0, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy();\n  }\n  digest() {\n    const e = new Uint8Array(this.oHash.outputLen);\n    return this.digestInto(e), e;\n  }\n  _cloneInto(e) {\n    e || (e = Object.create(Object.getPrototypeOf(this), {}));\n    const { oHash: r, iHash: n, finished: i, destroyed: s, blockLen: o, outputLen: a } = this;\n    return e = e, e.finished = i, e.destroyed = s, e.blockLen = o, e.outputLen = a, e.oHash = r._cloneInto(e.oHash), e.iHash = n._cloneInto(e.iHash), e;\n  }\n  destroy() {\n    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();\n  }\n}\nconst Nn = (t, e, r) => new ca(t, e).update(r).digest();\nNn.create = (t, e) => new ca(t, e);\nconst tf = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]), ua = Uint8Array.from({ length: 16 }, (t, e) => e), rf = ua.map((t) => (9 * t + 5) % 16);\nlet ci = [ua], ui = [rf];\nfor (let t = 0; t < 4; t++)\n  for (let e of [ci, ui])\n    e.push(e[t].map((r) => tf[r]));\nconst la = [\n  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],\n  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],\n  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],\n  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],\n  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]\n].map((t) => new Uint8Array(t)), nf = ci.map((t, e) => t.map((r) => la[e][r])), of = ui.map((t, e) => t.map((r) => la[e][r])), sf = new Uint32Array([0, 1518500249, 1859775393, 2400959708, 2840853838]), af = new Uint32Array([1352829926, 1548603684, 1836072691, 2053994217, 0]), yr = (t, e) => t << e | t >>> 32 - e;\nfunction Zi(t, e, r, n) {\n  return t === 0 ? e ^ r ^ n : t === 1 ? e & r | ~e & n : t === 2 ? (e | ~r) ^ n : t === 3 ? e & n | r & ~n : e ^ (r | ~n);\n}\nconst gr = new Uint32Array(16);\nclass cf extends si {\n  constructor() {\n    super(64, 20, 8, !0), this.h0 = 1732584193, this.h1 = -271733879, this.h2 = -1732584194, this.h3 = 271733878, this.h4 = -1009589776;\n  }\n  get() {\n    const { h0: e, h1: r, h2: n, h3: i, h4: s } = this;\n    return [e, r, n, i, s];\n  }\n  set(e, r, n, i, s) {\n    this.h0 = e | 0, this.h1 = r | 0, this.h2 = n | 0, this.h3 = i | 0, this.h4 = s | 0;\n  }\n  process(e, r) {\n    for (let d = 0; d < 16; d++, r += 4)\n      gr[d] = e.getUint32(r, !0);\n    let n = this.h0 | 0, i = n, s = this.h1 | 0, o = s, a = this.h2 | 0, c = a, l = this.h3 | 0, f = l, u = this.h4 | 0, h = u;\n    for (let d = 0; d < 5; d++) {\n      const p = 4 - d, y = sf[d], g = af[d], v = ci[d], _ = ui[d], m = nf[d], C = of[d];\n      for (let O = 0; O < 16; O++) {\n        const w = yr(n + Zi(d, s, a, l) + gr[v[O]] + y, m[O]) + u | 0;\n        n = u, u = l, l = yr(a, 10) | 0, a = s, s = w;\n      }\n      for (let O = 0; O < 16; O++) {\n        const w = yr(i + Zi(p, o, c, f) + gr[_[O]] + g, C[O]) + h | 0;\n        i = h, h = f, f = yr(c, 10) | 0, c = o, o = w;\n      }\n    }\n    this.set(this.h1 + a + f | 0, this.h2 + l + h | 0, this.h3 + u + i | 0, this.h4 + n + o | 0, this.h0 + s + c | 0);\n  }\n  roundClean() {\n    gr.fill(0);\n  }\n  destroy() {\n    this.destroyed = !0, this.buffer.fill(0), this.set(0, 0, 0, 0, 0);\n  }\n}\nconst uf = nt(() => new cf()), br = ue.ProjectivePoint, ln = As(jr);\nfunction Yi(t) {\n  return BigInt(`0x${ni(t)}`);\n}\nfunction lf(t) {\n  return Ws(t.toString(16).padStart(64, \"0\"));\n}\nconst ff = ii(\"Bitcoin seed\"), fn = { private: 76066276, public: 76067358 }, hn = 2147483648, hf = (t) => uf(jr(t)), df = (t) => ft(t).getUint32(0, !1), vr = (t) => {\n  if (!Number.isSafeInteger(t) || t < 0 || t > 2 ** 32 - 1)\n    throw new Error(`Invalid number=${t}. Should be from 0 to 2 ** 32 - 1`);\n  const e = new Uint8Array(4);\n  return ft(e).setUint32(0, t, !1), e;\n};\nclass ct {\n  get fingerprint() {\n    if (!this.pubHash)\n      throw new Error(\"No publicKey set!\");\n    return df(this.pubHash);\n  }\n  get identifier() {\n    return this.pubHash;\n  }\n  get pubKeyHash() {\n    return this.pubHash;\n  }\n  get privateKey() {\n    return this.privKeyBytes || null;\n  }\n  get publicKey() {\n    return this.pubKey || null;\n  }\n  get privateExtendedKey() {\n    const e = this.privateKey;\n    if (!e)\n      throw new Error(\"No private key\");\n    return ln.encode(this.serialize(this.versions.private, er(new Uint8Array([0]), e)));\n  }\n  get publicExtendedKey() {\n    if (!this.pubKey)\n      throw new Error(\"No public key\");\n    return ln.encode(this.serialize(this.versions.public, this.pubKey));\n  }\n  static fromMasterSeed(e, r = fn) {\n    if (Ye(e), 8 * e.length < 128 || 8 * e.length > 512)\n      throw new Error(`HDKey: wrong seed length=${e.length}. Should be between 128 and 512 bits; 256 bits is advised)`);\n    const n = Nn(qn, ff, e);\n    return new ct({\n      versions: r,\n      chainCode: n.slice(32),\n      privateKey: n.slice(0, 32)\n    });\n  }\n  static fromExtendedKey(e, r = fn) {\n    const n = ln.decode(e), i = ft(n), s = i.getUint32(0, !1), o = {\n      versions: r,\n      depth: n[4],\n      parentFingerprint: i.getUint32(5, !1),\n      index: i.getUint32(9, !1),\n      chainCode: n.slice(13, 45)\n    }, a = n.slice(45), c = a[0] === 0;\n    if (s !== r[c ? \"private\" : \"public\"])\n      throw new Error(\"Version mismatch\");\n    return c ? new ct({ ...o, privateKey: a.slice(1) }) : new ct({ ...o, publicKey: a });\n  }\n  static fromJSON(e) {\n    return ct.fromExtendedKey(e.xpriv);\n  }\n  constructor(e) {\n    if (this.depth = 0, this.index = 0, this.chainCode = null, this.parentFingerprint = 0, !e || typeof e != \"object\")\n      throw new Error(\"HDKey.constructor must not be called directly\");\n    if (this.versions = e.versions || fn, this.depth = e.depth || 0, this.chainCode = e.chainCode, this.index = e.index || 0, this.parentFingerprint = e.parentFingerprint || 0, !this.depth && (this.parentFingerprint || this.index))\n      throw new Error(\"HDKey: zero depth with non-zero index/parent fingerprint\");\n    if (e.publicKey && e.privateKey)\n      throw new Error(\"HDKey: publicKey and privateKey at same time.\");\n    if (e.privateKey) {\n      if (!ue.utils.isValidPrivateKey(e.privateKey))\n        throw new Error(\"Invalid private key\");\n      this.privKey = typeof e.privateKey == \"bigint\" ? e.privateKey : Yi(e.privateKey), this.privKeyBytes = lf(this.privKey), this.pubKey = ue.getPublicKey(e.privateKey, !0);\n    } else if (e.publicKey)\n      this.pubKey = br.fromHex(e.publicKey).toRawBytes(!0);\n    else\n      throw new Error(\"HDKey: no public or private key provided\");\n    this.pubHash = hf(this.pubKey);\n  }\n  derive(e) {\n    if (!/^[mM]'?/.test(e))\n      throw new Error('Path must start with \"m\" or \"M\"');\n    if (/^[mM]'?$/.test(e))\n      return this;\n    const r = e.replace(/^[mM]'?\\//, \"\").split(\"/\");\n    let n = this;\n    for (const i of r) {\n      const s = /^(\\d+)('?)$/.exec(i);\n      if (!s || s.length !== 3)\n        throw new Error(`Invalid child index: ${i}`);\n      let o = +s[1];\n      if (!Number.isSafeInteger(o) || o >= hn)\n        throw new Error(\"Invalid index\");\n      s[2] === \"'\" && (o += hn), n = n.deriveChild(o);\n    }\n    return n;\n  }\n  deriveChild(e) {\n    if (!this.pubKey || !this.chainCode)\n      throw new Error(\"No publicKey or chainCode set\");\n    let r = vr(e);\n    if (e >= hn) {\n      const a = this.privateKey;\n      if (!a)\n        throw new Error(\"Could not derive hardened child key\");\n      r = er(new Uint8Array([0]), a, r);\n    } else\n      r = er(this.pubKey, r);\n    const n = Nn(qn, this.chainCode, r), i = Yi(n.slice(0, 32)), s = n.slice(32);\n    if (!ue.utils.isValidPrivateKey(i))\n      throw new Error(\"Tweak bigger than curve order\");\n    const o = {\n      versions: this.versions,\n      chainCode: s,\n      depth: this.depth + 1,\n      parentFingerprint: this.fingerprint,\n      index: e\n    };\n    try {\n      if (this.privateKey) {\n        const a = J(this.privKey + i, ue.CURVE.n);\n        if (!ue.utils.isValidPrivateKey(a))\n          throw new Error(\"The tweak was out of range or the resulted private key is invalid\");\n        o.privateKey = a;\n      } else {\n        const a = br.fromHex(this.pubKey).add(br.fromPrivateKey(i));\n        if (a.equals(br.ZERO))\n          throw new Error(\"The tweak was equal to negative P, which made the result key invalid\");\n        o.publicKey = a.toRawBytes(!0);\n      }\n      return new ct(o);\n    } catch {\n      return this.deriveChild(e + 1);\n    }\n  }\n  sign(e) {\n    if (!this.privateKey)\n      throw new Error(\"No privateKey set!\");\n    return Ye(e, 32), ue.sign(e, this.privKey).toCompactRawBytes();\n  }\n  verify(e, r) {\n    if (Ye(e, 32), Ye(r, 64), !this.publicKey)\n      throw new Error(\"No publicKey set!\");\n    let n;\n    try {\n      n = ue.Signature.fromCompact(r);\n    } catch {\n      return !1;\n    }\n    return ue.verify(n, e, this.publicKey);\n  }\n  wipePrivateData() {\n    return this.privKey = void 0, this.privKeyBytes && (this.privKeyBytes.fill(0), this.privKeyBytes = void 0), this;\n  }\n  toJSON() {\n    return {\n      xpriv: this.privateExtendedKey,\n      xpub: this.publicExtendedKey\n    };\n  }\n  serialize(e, r) {\n    if (!this.chainCode)\n      throw new Error(\"No chainCode set\");\n    return Ye(r, 33), er(vr(e), new Uint8Array([this.depth]), vr(this.parentFingerprint), vr(this.index), this.chainCode, r);\n  }\n}\nvar pf = Object.defineProperty, ie = (t, e) => {\n  for (var r in e)\n    pf(t, r, { get: e[r], enumerable: !0 });\n};\nfunction yf() {\n  return ve(St.utils.randomPrivateKey());\n}\nfunction li(t) {\n  return ve(St.getPublicKey(t));\n}\nvar gf = {};\nie(gf, {\n  MessageNode: () => fa,\n  MessageQueue: () => ha,\n  insertEventIntoAscendingList: () => wf,\n  insertEventIntoDescendingList: () => vf,\n  normalizeURL: () => bf,\n  utf8Decoder: () => Je,\n  utf8Encoder: () => Ie\n});\nvar Je = new TextDecoder(\"utf-8\"), Ie = new TextEncoder();\nfunction bf(t) {\n  let e = new URL(t);\n  return e.pathname = e.pathname.replace(/\\/+/g, \"/\"), e.pathname.endsWith(\"/\") && (e.pathname = e.pathname.slice(0, -1)), (e.port === \"80\" && e.protocol === \"ws:\" || e.port === \"443\" && e.protocol === \"wss:\") && (e.port = \"\"), e.searchParams.sort(), e.hash = \"\", e.toString();\n}\nfunction vf(t, e) {\n  var o;\n  let r = 0, n = t.length - 1, i, s = r;\n  if (n < 0)\n    s = 0;\n  else if (e.created_at < t[n].created_at)\n    s = n + 1;\n  else if (e.created_at >= t[r].created_at)\n    s = r;\n  else\n    for (; ; ) {\n      if (n <= r + 1) {\n        s = n;\n        break;\n      }\n      if (i = Math.floor(r + (n - r) / 2), t[i].created_at > e.created_at)\n        r = i;\n      else if (t[i].created_at < e.created_at)\n        n = i;\n      else {\n        s = i;\n        break;\n      }\n    }\n  return ((o = t[s]) == null ? void 0 : o.id) !== e.id ? [\n    ...t.slice(0, s),\n    e,\n    ...t.slice(s)\n  ] : t;\n}\nfunction wf(t, e) {\n  var o;\n  let r = 0, n = t.length - 1, i, s = r;\n  if (n < 0)\n    s = 0;\n  else if (e.created_at > t[n].created_at)\n    s = n + 1;\n  else if (e.created_at <= t[r].created_at)\n    s = r;\n  else\n    for (; ; ) {\n      if (n <= r + 1) {\n        s = n;\n        break;\n      }\n      if (i = Math.floor(r + (n - r) / 2), t[i].created_at < e.created_at)\n        r = i;\n      else if (t[i].created_at > e.created_at)\n        n = i;\n      else {\n        s = i;\n        break;\n      }\n    }\n  return ((o = t[s]) == null ? void 0 : o.id) !== e.id ? [\n    ...t.slice(0, s),\n    e,\n    ...t.slice(s)\n  ] : t;\n}\nvar fa = class {\n  constructor(t) {\n    I(this, \"_value\");\n    I(this, \"_next\");\n    this._value = t, this._next = null;\n  }\n  get value() {\n    return this._value;\n  }\n  set value(t) {\n    this._value = t;\n  }\n  get next() {\n    return this._next;\n  }\n  set next(t) {\n    this._next = t;\n  }\n}, ha = class {\n  constructor() {\n    I(this, \"_first\");\n    I(this, \"_last\");\n    I(this, \"_size\");\n    this._first = null, this._last = null, this._size = 0;\n  }\n  get first() {\n    return this._first;\n  }\n  set first(t) {\n    this._first = t;\n  }\n  get last() {\n    return this._last;\n  }\n  set last(t) {\n    this._last = t;\n  }\n  get size() {\n    return this._size;\n  }\n  set size(t) {\n    this._size = t;\n  }\n  enqueue(t) {\n    const e = new fa(t);\n    return this._size === 0 || !this._last ? (this._first = e, this._last = e) : (this._last.next = e, this._last = e), this._size++, !0;\n  }\n  dequeue() {\n    if (this._size === 0 || !this._first)\n      return null;\n    let t = this._first;\n    return this._first = t.next, t.next = null, this._size--, t.value;\n  }\n};\nfunction da(t, e) {\n  let r = t;\n  return r.pubkey = li(e), r.id = Hr(r), r.sig = pa(r, e), r;\n}\nfunction _f(t) {\n  if (!fi(t))\n    throw new Error(\"can't serialize event with wrong or missing properties\");\n  return JSON.stringify([\n    0,\n    t.pubkey,\n    t.created_at,\n    t.kind,\n    t.tags,\n    t.content\n  ]);\n}\nfunction Hr(t) {\n  let e = Yn(Ie.encode(_f(t)));\n  return ve(e);\n}\nvar mf = (t) => t instanceof Object;\nfunction fi(t) {\n  if (!mf(t) || typeof t.kind != \"number\" || typeof t.content != \"string\" || typeof t.created_at != \"number\" || typeof t.pubkey != \"string\" || !t.pubkey.match(/^[a-f0-9]{64}$/) || !Array.isArray(t.tags))\n    return !1;\n  for (let e = 0; e < t.tags.length; e++) {\n    let r = t.tags[e];\n    if (!Array.isArray(r))\n      return !1;\n    for (let n = 0; n < r.length; n++)\n      if (typeof r[n] == \"object\")\n        return !1;\n  }\n  return !0;\n}\nfunction hi(t) {\n  try {\n    return St.verify(t.sig, Hr(t), t.pubkey);\n  } catch {\n    return !1;\n  }\n}\nfunction pa(t, e) {\n  return ve(St.sign(Hr(t), e));\n}\nfunction ya(t, e) {\n  if (t.ids && t.ids.indexOf(e.id) === -1 && !t.ids.some((r) => e.id.startsWith(r)) || t.kinds && t.kinds.indexOf(e.kind) === -1 || t.authors && t.authors.indexOf(e.pubkey) === -1 && !t.authors.some((r) => e.pubkey.startsWith(r)))\n    return !1;\n  for (let r in t)\n    if (r[0] === \"#\") {\n      let n = r.slice(1), i = t[`#${n}`];\n      if (i && !e.tags.find(\n        ([s, o]) => s === r.slice(1) && i.indexOf(o) !== -1\n      ))\n        return !1;\n    }\n  return !(t.since && e.created_at < t.since || t.until && e.created_at >= t.until);\n}\nfunction xf(t, e) {\n  for (let r = 0; r < t.length; r++)\n    if (ya(t[r], e))\n      return !0;\n  return !1;\n}\nvar Ef = {};\nie(Ef, {\n  getHex64: () => Mr,\n  getInt: () => ga,\n  getSubscriptionId: () => ba,\n  matchEventId: () => kf,\n  matchEventKind: () => Of,\n  matchEventPubkey: () => Sf\n});\nfunction Mr(t, e) {\n  let r = e.length + 3, n = t.indexOf(`\"${e}\":`) + r, i = t.slice(n).indexOf('\"') + n + 1;\n  return t.slice(i, i + 64);\n}\nfunction ga(t, e) {\n  let r = e.length, n = t.indexOf(`\"${e}\":`) + r + 3, i = t.slice(n), s = Math.min(i.indexOf(\",\"), i.indexOf(\"}\"));\n  return parseInt(i.slice(0, s), 10);\n}\nfunction ba(t) {\n  let e = t.slice(0, 22).indexOf('\"EVENT\"');\n  if (e === -1)\n    return null;\n  let r = t.slice(e + 7 + 1).indexOf('\"');\n  if (r === -1)\n    return null;\n  let n = e + 7 + 1 + r, i = t.slice(n + 1, 80).indexOf('\"');\n  if (i === -1)\n    return null;\n  let s = n + 1 + i;\n  return t.slice(n + 1, s);\n}\nfunction kf(t, e) {\n  return e === Mr(t, \"id\");\n}\nfunction Sf(t, e) {\n  return e === Mr(t, \"pubkey\");\n}\nfunction Of(t, e) {\n  return e === ga(t, \"kind\");\n}\nvar Ji = () => ({\n  connect: [],\n  disconnect: [],\n  error: [],\n  notice: [],\n  auth: []\n});\nfunction Af(t, e = {}) {\n  let { listTimeout: r = 3e3, getTimeout: n = 3e3, countTimeout: i = 3e3 } = e;\n  var s, o = {}, a = Ji(), c = {}, l = {}, f;\n  async function u() {\n    return f || (f = new Promise((v, _) => {\n      try {\n        s = new WebSocket(t);\n      } catch (w) {\n        _(w);\n      }\n      s.onopen = () => {\n        a.connect.forEach((w) => w()), v();\n      }, s.onerror = () => {\n        f = void 0, a.error.forEach((w) => w()), _();\n      }, s.onclose = async () => {\n        f = void 0, a.disconnect.forEach((w) => w());\n      };\n      let m = new ha(), C;\n      s.onmessage = (w) => {\n        m.enqueue(w.data), C || (C = setInterval(O, 0));\n      };\n      function O() {\n        var A, B, L;\n        if (m.size === 0) {\n          clearInterval(C), C = null;\n          return;\n        }\n        var w = m.dequeue();\n        if (!w)\n          return;\n        let x = ba(w);\n        if (x) {\n          let P = o[x];\n          if (P && P.alreadyHaveEvent && P.alreadyHaveEvent(Mr(w, \"id\"), t))\n            return;\n        }\n        try {\n          let P = JSON.parse(w);\n          switch (P[0]) {\n            case \"EVENT\": {\n              let E = P[1], R = P[2];\n              fi(R) && o[E] && (o[E].skipVerification || hi(R)) && xf(o[E].filters, R) && (o[E], (((A = c[E]) == null ? void 0 : A.event) || []).forEach((q) => q(R)));\n              return;\n            }\n            case \"COUNT\":\n              let F = P[1], z = P[2];\n              o[F] && (((B = c[F]) == null ? void 0 : B.count) || []).forEach((E) => E(z));\n              return;\n            case \"EOSE\": {\n              let E = P[1];\n              E in c && (c[E].eose.forEach((R) => R()), c[E].eose = []);\n              return;\n            }\n            case \"OK\": {\n              let E = P[1], R = P[2], q = P[3] || \"\";\n              E in l && (R ? l[E].ok.forEach((H) => H()) : l[E].failed.forEach((H) => H(q)), l[E].ok = [], l[E].failed = []);\n              return;\n            }\n            case \"NOTICE\":\n              let G = P[1];\n              a.notice.forEach((E) => E(G));\n              return;\n            case \"AUTH\": {\n              let E = P[1];\n              (L = a.auth) == null || L.forEach((R) => R(E));\n              return;\n            }\n          }\n        } catch {\n          return;\n        }\n      }\n    }), f);\n  }\n  function h() {\n    return (s == null ? void 0 : s.readyState) === 1;\n  }\n  async function d() {\n    h() || await u();\n  }\n  async function p(v) {\n    let _ = JSON.stringify(v);\n    if (!(!h() && (await new Promise((m) => setTimeout(m, 1e3)), !h())))\n      try {\n        s.send(_);\n      } catch (m) {\n        console.log(m);\n      }\n  }\n  const y = (v, {\n    verb: _ = \"REQ\",\n    skipVerification: m = !1,\n    alreadyHaveEvent: C = null,\n    id: O = Math.random().toString().slice(2)\n  } = {}) => {\n    let w = O;\n    return o[w] = {\n      id: w,\n      filters: v,\n      skipVerification: m,\n      alreadyHaveEvent: C\n    }, p([_, w, ...v]), {\n      sub: (x, A = {}) => y(x || v, {\n        skipVerification: A.skipVerification || m,\n        alreadyHaveEvent: A.alreadyHaveEvent || C,\n        id: w\n      }),\n      unsub: () => {\n        delete o[w], delete c[w], p([\"CLOSE\", w]);\n      },\n      on: (x, A) => {\n        c[w] = c[w] || {\n          event: [],\n          count: [],\n          eose: []\n        }, c[w][x].push(A);\n      },\n      off: (x, A) => {\n        let B = c[w], L = B[x].indexOf(A);\n        L >= 0 && B[x].splice(L, 1);\n      }\n    };\n  };\n  function g(v, _) {\n    if (!v.id)\n      throw new Error(`event ${v} has no id`);\n    let m = v.id;\n    return p([_, v]), {\n      on: (C, O) => {\n        l[m] = l[m] || {\n          ok: [],\n          failed: []\n        }, l[m][C].push(O);\n      },\n      off: (C, O) => {\n        let w = l[m];\n        if (!w)\n          return;\n        let x = w[C].indexOf(O);\n        x >= 0 && w[C].splice(x, 1);\n      }\n    };\n  }\n  return {\n    url: t,\n    sub: y,\n    on: (v, _) => {\n      a[v].push(_), v === \"connect\" && (s == null ? void 0 : s.readyState) === 1 && _();\n    },\n    off: (v, _) => {\n      let m = a[v].indexOf(_);\n      m !== -1 && a[v].splice(m, 1);\n    },\n    list: (v, _) => new Promise((m) => {\n      let C = y(v, _), O = [], w = setTimeout(() => {\n        C.unsub(), m(O);\n      }, r);\n      C.on(\"eose\", () => {\n        C.unsub(), clearTimeout(w), m(O);\n      }), C.on(\"event\", (x) => {\n        O.push(x);\n      });\n    }),\n    get: (v, _) => new Promise((m) => {\n      let C = y([v], _), O = setTimeout(() => {\n        C.unsub(), m(null);\n      }, n);\n      C.on(\"event\", (w) => {\n        C.unsub(), clearTimeout(O), m(w);\n      });\n    }),\n    count: (v) => new Promise((_) => {\n      let m = y(v, { ...y, verb: \"COUNT\" }), C = setTimeout(() => {\n        m.unsub(), _(null);\n      }, i);\n      m.on(\"count\", (O) => {\n        m.unsub(), clearTimeout(C), _(O);\n      });\n    }),\n    publish(v) {\n      return g(v, \"EVENT\");\n    },\n    auth(v) {\n      return g(v, \"AUTH\");\n    },\n    connect: d,\n    close() {\n      a = Ji(), c = {}, l = {}, s.readyState === WebSocket.OPEN && (s == null || s.close());\n    },\n    get status() {\n      var v;\n      return (v = s == null ? void 0 : s.readyState) != null ? v : 3;\n    }\n  };\n}\nvar we = {};\nie(we, {\n  BECH32_REGEX: () => va,\n  decode: () => Dr,\n  naddrEncode: () => Bf,\n  neventEncode: () => Pf,\n  noteEncode: () => Rf,\n  nprofileEncode: () => Tf,\n  npubEncode: () => If,\n  nrelayEncode: () => Lf,\n  nsecEncode: () => Cf\n});\nvar At = 5e3, va = /[\\x21-\\x7E]{1,83}1[023456789acdefghjklmnpqrstuvwxyz]{6,}/;\nfunction Dr(t) {\n  var i, s, o, a, c, l, f;\n  let { prefix: e, words: r } = te.decode(t, At), n = new Uint8Array(te.fromWords(r));\n  switch (e) {\n    case \"nprofile\": {\n      let u = wr(n);\n      if (!((i = u[0]) != null && i[0]))\n        throw new Error(\"missing TLV 0 for nprofile\");\n      if (u[0][0].length !== 32)\n        throw new Error(\"TLV 0 should be 32 bytes\");\n      return {\n        type: \"nprofile\",\n        data: {\n          pubkey: ve(u[0][0]),\n          relays: u[1] ? u[1].map((h) => Je.decode(h)) : []\n        }\n      };\n    }\n    case \"nevent\": {\n      let u = wr(n);\n      if (!((s = u[0]) != null && s[0]))\n        throw new Error(\"missing TLV 0 for nevent\");\n      if (u[0][0].length !== 32)\n        throw new Error(\"TLV 0 should be 32 bytes\");\n      if (u[2] && u[2][0].length !== 32)\n        throw new Error(\"TLV 2 should be 32 bytes\");\n      return {\n        type: \"nevent\",\n        data: {\n          id: ve(u[0][0]),\n          relays: u[1] ? u[1].map((h) => Je.decode(h)) : [],\n          author: (o = u[2]) != null && o[0] ? ve(u[2][0]) : void 0\n        }\n      };\n    }\n    case \"naddr\": {\n      let u = wr(n);\n      if (!((a = u[0]) != null && a[0]))\n        throw new Error(\"missing TLV 0 for naddr\");\n      if (!((c = u[2]) != null && c[0]))\n        throw new Error(\"missing TLV 2 for naddr\");\n      if (u[2][0].length !== 32)\n        throw new Error(\"TLV 2 should be 32 bytes\");\n      if (!((l = u[3]) != null && l[0]))\n        throw new Error(\"missing TLV 3 for naddr\");\n      if (u[3][0].length !== 4)\n        throw new Error(\"TLV 3 should be 4 bytes\");\n      return {\n        type: \"naddr\",\n        data: {\n          identifier: Je.decode(u[0][0]),\n          pubkey: ve(u[2][0]),\n          kind: parseInt(ve(u[3][0]), 16),\n          relays: u[1] ? u[1].map((h) => Je.decode(h)) : []\n        }\n      };\n    }\n    case \"nrelay\": {\n      let u = wr(n);\n      if (!((f = u[0]) != null && f[0]))\n        throw new Error(\"missing TLV 0 for nrelay\");\n      return {\n        type: \"nrelay\",\n        data: Je.decode(u[0][0])\n      };\n    }\n    case \"nsec\":\n    case \"npub\":\n    case \"note\":\n      return { type: e, data: ve(n) };\n    default:\n      throw new Error(`unknown prefix ${e}`);\n  }\n}\nfunction wr(t) {\n  let e = {}, r = t;\n  for (; r.length > 0; ) {\n    let n = r[0], i = r[1];\n    if (!i)\n      throw new Error(`malformed TLV ${n}`);\n    let s = r.slice(2, 2 + i);\n    if (r = r.slice(2 + i), s.length < i)\n      throw new Error(`not enough data to read on TLV ${n}`);\n    e[n] = e[n] || [], e[n].push(s);\n  }\n  return e;\n}\nfunction Cf(t) {\n  return di(\"nsec\", t);\n}\nfunction If(t) {\n  return di(\"npub\", t);\n}\nfunction Rf(t) {\n  return di(\"note\", t);\n}\nfunction di(t, e) {\n  let r = _t(e), n = te.toWords(r);\n  return te.encode(t, n, At);\n}\nfunction Tf(t) {\n  let e = zr({\n    0: [_t(t.pubkey)],\n    1: (t.relays || []).map((n) => Ie.encode(n))\n  }), r = te.toWords(e);\n  return te.encode(\"nprofile\", r, At);\n}\nfunction Pf(t) {\n  let e = zr({\n    0: [_t(t.id)],\n    1: (t.relays || []).map((n) => Ie.encode(n)),\n    2: t.author ? [_t(t.author)] : []\n  }), r = te.toWords(e);\n  return te.encode(\"nevent\", r, At);\n}\nfunction Bf(t) {\n  let e = new ArrayBuffer(4);\n  new DataView(e).setUint32(0, t.kind, !1);\n  let r = zr({\n    0: [Ie.encode(t.identifier)],\n    1: (t.relays || []).map((i) => Ie.encode(i)),\n    2: [_t(t.pubkey)],\n    3: [new Uint8Array(e)]\n  }), n = te.toWords(r);\n  return te.encode(\"naddr\", n, At);\n}\nfunction Lf(t) {\n  let e = zr({\n    0: [Ie.encode(t)]\n  }), r = te.toWords(e);\n  return te.encode(\"nrelay\", r, At);\n}\nfunction zr(t) {\n  let e = [];\n  return Object.entries(t).forEach(([r, n]) => {\n    n.forEach((i) => {\n      let s = new Uint8Array(i.length + 2);\n      s.set([parseInt(r)], 0), s.set([i.length], 1), s.set(i, 2), e.push(s);\n    });\n  }), _u(...e);\n}\nvar Un = {};\nie(Un, {\n  decrypt: () => qf,\n  encrypt: () => $f\n});\ntypeof crypto < \"u\" && !crypto.subtle && crypto.webcrypto && (crypto.subtle = crypto.webcrypto.subtle);\nasync function $f(t, e, r) {\n  const n = ue.getSharedSecret(t, \"02\" + e), i = wa(n);\n  let s = Uint8Array.from(xu(16)), o = Ie.encode(r), a = await crypto.subtle.importKey(\n    \"raw\",\n    i,\n    { name: \"AES-CBC\" },\n    !1,\n    [\"encrypt\"]\n  ), c = await crypto.subtle.encrypt(\n    { name: \"AES-CBC\", iv: s },\n    a,\n    o\n  ), l = mt.encode(new Uint8Array(c)), f = mt.encode(new Uint8Array(s.buffer));\n  return `${l}?iv=${f}`;\n}\nasync function qf(t, e, r) {\n  let [n, i] = r.split(\"?iv=\"), s = ue.getSharedSecret(t, \"02\" + e), o = wa(s), a = await crypto.subtle.importKey(\n    \"raw\",\n    o,\n    { name: \"AES-CBC\" },\n    !1,\n    [\"decrypt\"]\n  ), c = mt.decode(n), l = mt.decode(i), f = await crypto.subtle.decrypt(\n    { name: \"AES-CBC\", iv: l },\n    a,\n    c\n  );\n  return Je.decode(f);\n}\nfunction wa(t) {\n  return t.slice(1, 33);\n}\nvar _a = {};\nie(_a, {\n  NIP05_REGEX: () => ma,\n  queryProfile: () => jf,\n  searchDomain: () => Uf,\n  useFetchImplementation: () => Nf\n});\nvar ma = /^(?:([\\w.+-]+)@)?([\\w.-]+)$/, Fr;\ntry {\n  Fr = fetch;\n} catch {\n}\nfunction Nf(t) {\n  Fr = t;\n}\nasync function Uf(t, e = \"\") {\n  try {\n    return (await (await Fr(`https://${t}/.well-known/nostr.json?name=${e}`)).json()).names;\n  } catch {\n    return {};\n  }\n}\nasync function jf(t) {\n  const e = t.match(ma);\n  if (!e)\n    return null;\n  const [r, n = \"_\", i] = e;\n  try {\n    const s = await Fr(`https://${i}/.well-known/nostr.json?name=${n}`), { names: o, relays: a } = Hf(await s.json()), c = o[n];\n    return c ? { pubkey: c, relays: a == null ? void 0 : a[c] } : null;\n  } catch {\n    return null;\n  }\n}\nfunction Hf(t) {\n  const e = {\n    names: {}\n  };\n  for (const [r, n] of Object.entries(t.names))\n    typeof r == \"string\" && typeof n == \"string\" && (e.names[r] = n);\n  if (t.relays) {\n    e.relays = {};\n    for (const [r, n] of Object.entries(t.relays))\n      typeof r == \"string\" && Array.isArray(n) && (e.relays[r] = n.filter((i) => typeof i == \"string\"));\n  }\n  return e;\n}\nvar Mf = {};\nie(Mf, {\n  generateSeedWords: () => zf,\n  privateKeyFromSeedWords: () => Df,\n  validateWords: () => Ff\n});\nfunction Df(t, e) {\n  let n = ct.fromMasterSeed(Ys(t, e)).derive(\"m/44'/1237'/0'/0/0\").privateKey;\n  if (!n)\n    throw new Error(\"could not derive private key\");\n  return ve(n);\n}\nfunction zf() {\n  return ra(Qn);\n}\nfunction Ff(t) {\n  return sa(t, Qn);\n}\nvar Kf = {};\nie(Kf, {\n  parse: () => Wf\n});\nfunction Wf(t) {\n  const e = {\n    reply: void 0,\n    root: void 0,\n    mentions: [],\n    profiles: []\n  }, r = [];\n  for (const n of t.tags)\n    n[0] === \"e\" && n[1] && r.push(n), n[0] === \"p\" && n[1] && e.profiles.push({\n      pubkey: n[1],\n      relays: n[2] ? [n[2]] : []\n    });\n  for (let n = 0; n < r.length; n++) {\n    const i = r[n], [s, o, a, c] = i, l = {\n      id: o,\n      relays: a ? [a] : []\n    }, f = n === 0, u = n === r.length - 1;\n    if (c === \"root\") {\n      e.root = l;\n      continue;\n    }\n    if (c === \"reply\") {\n      e.reply = l;\n      continue;\n    }\n    if (c === \"mention\") {\n      e.mentions.push(l);\n      continue;\n    }\n    if (f) {\n      e.root = l;\n      continue;\n    }\n    if (u) {\n      e.reply = l;\n      continue;\n    }\n    e.mentions.push(l);\n  }\n  return e;\n}\nvar Vf = {};\nie(Vf, {\n  getPow: () => Gf\n});\nfunction Gf(t) {\n  return Zf(_t(t));\n}\nfunction Zf(t) {\n  let e, r, n;\n  for (r = 0, e = 0; r < t.length && (n = Yf(t[r]), e += n, n === 8); r++)\n    ;\n  return e;\n}\nfunction Yf(t) {\n  let e = 0;\n  if (t === 0)\n    return 8;\n  for (; t >>= 1; )\n    e++;\n  return 7 - e;\n}\nvar Jf = {};\nie(Jf, {\n  finishRepostEvent: () => Xf,\n  getRepostedEvent: () => Qf,\n  getRepostedEventPointer: () => xa\n});\nfunction Xf(t, e, r, n) {\n  var i;\n  return da({\n    kind: 6,\n    tags: [\n      ...(i = t.tags) != null ? i : [],\n      [\"e\", e.id, r],\n      [\"p\", e.pubkey]\n    ],\n    content: t.content === \"\" ? \"\" : JSON.stringify(e),\n    created_at: t.created_at\n  }, n);\n}\nfunction xa(t) {\n  if (t.kind !== 6)\n    return;\n  let e, r;\n  for (let n = t.tags.length - 1; n >= 0 && (e === void 0 || r === void 0); n--) {\n    const i = t.tags[n];\n    i.length >= 2 && (i[0] === \"e\" && e === void 0 ? e = i : i[0] === \"p\" && r === void 0 && (r = i));\n  }\n  if (e !== void 0)\n    return {\n      id: e[1],\n      relays: [e[2], r == null ? void 0 : r[2]].filter((n) => typeof n == \"string\"),\n      author: r == null ? void 0 : r[1]\n    };\n}\nfunction Qf(t, { skipVerification: e } = {}) {\n  const r = xa(t);\n  if (r === void 0 || t.content === \"\")\n    return;\n  let n;\n  try {\n    n = JSON.parse(t.content);\n  } catch {\n    return;\n  }\n  if (n.id === r.id && !(!e && !hi(n)))\n    return n;\n}\nvar eh = {};\nie(eh, {\n  NOSTR_URI_REGEX: () => Kr,\n  parse: () => rh,\n  test: () => th\n});\nvar Kr = new RegExp(`nostr:(${va.source})`);\nfunction th(t) {\n  return typeof t == \"string\" && new RegExp(`^${Kr.source}$`).test(t);\n}\nfunction rh(t) {\n  const e = t.match(new RegExp(`^${Kr.source}$`));\n  if (!e)\n    throw new Error(`Invalid Nostr URI: ${t}`);\n  return {\n    uri: e[0],\n    value: e[1],\n    decoded: Dr(e[1])\n  };\n}\nvar nh = {};\nie(nh, {\n  finishReactionEvent: () => ih,\n  getReactedEventPointer: () => oh\n});\nfunction ih(t, e, r) {\n  var i, s;\n  const n = e.tags.filter(\n    (o) => o.length >= 2 && (o[0] === \"e\" || o[0] === \"p\")\n  );\n  return da({\n    ...t,\n    kind: 7,\n    tags: [\n      ...(i = t.tags) != null ? i : [],\n      ...n,\n      [\"e\", e.id],\n      [\"p\", e.pubkey]\n    ],\n    content: (s = t.content) != null ? s : \"+\"\n  }, r);\n}\nfunction oh(t) {\n  if (t.kind !== 7)\n    return;\n  let e, r;\n  for (let n = t.tags.length - 1; n >= 0 && (e === void 0 || r === void 0); n--) {\n    const i = t.tags[n];\n    i.length >= 2 && (i[0] === \"e\" && e === void 0 ? e = i : i[0] === \"p\" && r === void 0 && (r = i));\n  }\n  if (!(e === void 0 || r === void 0))\n    return {\n      id: e[1],\n      relays: [e[2], r[2]].filter((n) => n !== void 0),\n      author: r[1]\n    };\n}\nvar sh = {};\nie(sh, {\n  createDelegation: () => ah,\n  getDelegator: () => ch\n});\nfunction ah(t, e) {\n  let r = [];\n  (e.kind || -1) >= 0 && r.push(`kind=${e.kind}`), e.until && r.push(`created_at<${e.until}`), e.since && r.push(`created_at>${e.since}`);\n  let n = r.join(\"&\");\n  if (n === \"\")\n    throw new Error(\"refusing to create a delegation without any conditions\");\n  let i = Yn(\n    Ie.encode(`nostr:delegation:${e.pubkey}:${n}`)\n  ), s = ve(\n    St.sign(i, t)\n  );\n  return {\n    from: li(t),\n    to: e.pubkey,\n    cond: n,\n    sig: s\n  };\n}\nfunction ch(t) {\n  let e = t.tags.find((a) => a[0] === \"delegation\" && a.length >= 4);\n  if (!e)\n    return null;\n  let r = e[1], n = e[2], i = e[3], s = n.split(\"&\");\n  for (let a = 0; a < s.length; a++) {\n    let [c, l, f] = s[a].split(/\\b/);\n    if (!(c === \"kind\" && l === \"=\" && t.kind === parseInt(f))) {\n      if (c === \"created_at\" && l === \"<\" && t.created_at < parseInt(f))\n        continue;\n      if (c === \"created_at\" && l === \">\" && t.created_at > parseInt(f))\n        continue;\n      return null;\n    }\n  }\n  let o = Yn(\n    Ie.encode(`nostr:delegation:${t.pubkey}:${n}`)\n  );\n  return St.verify(i, o, r) ? r : null;\n}\nvar uh = {};\nie(uh, {\n  matchAll: () => lh,\n  regex: () => pi,\n  replaceAll: () => fh\n});\nvar pi = () => new RegExp(`\\\\b${Kr.source}\\\\b`, \"g\");\nfunction* lh(t) {\n  const e = t.matchAll(pi());\n  for (const r of e) {\n    const [n, i] = r;\n    yield {\n      uri: n,\n      value: i,\n      decoded: Dr(i),\n      start: r.index,\n      end: r.index + n.length\n    };\n  }\n}\nfunction fh(t, e) {\n  return t.replaceAll(pi(), (r, n) => e({\n    uri: r,\n    value: n,\n    decoded: Dr(n)\n  }));\n}\nvar hh = {};\nie(hh, {\n  useFetchImplementation: () => dh,\n  validateGithub: () => ph\n});\nvar yi;\ntry {\n  yi = fetch;\n} catch {\n}\nfunction dh(t) {\n  yi = t;\n}\nasync function ph(t, e, r) {\n  try {\n    return await (await yi(`https://gist.github.com/${e}/${r}/raw`)).text() === `Verifying that I control the following Nostr public key: ${t}`;\n  } catch {\n    return !1;\n  }\n}\nvar yh = {};\nie(yh, {\n  authenticate: () => gh\n});\nvar gh = async ({\n  challenge: t,\n  relay: e,\n  sign: r\n}) => {\n  const n = {\n    kind: 22242,\n    created_at: Math.floor(Date.now() / 1e3),\n    tags: [\n      [\"relay\", e.url],\n      [\"challenge\", t]\n    ],\n    content: \"\"\n  }, i = e.auth(await r(n));\n  return new Promise((s, o) => {\n    i.on(\"ok\", function a() {\n      i.off(\"ok\", a), s();\n    }), i.on(\"failed\", function a(c) {\n      i.off(\"failed\", a), o(c);\n    });\n  });\n}, Ea = {};\nie(Ea, {\n  getZapEndpoint: () => vh,\n  makeZapReceipt: () => mh,\n  makeZapRequest: () => wh,\n  useFetchImplementation: () => bh,\n  validateZapRequest: () => _h\n});\nvar gi;\ntry {\n  gi = fetch;\n} catch {\n}\nfunction bh(t) {\n  gi = t;\n}\nasync function vh(t) {\n  try {\n    let e = \"\", { lud06: r, lud16: n } = JSON.parse(t.content);\n    if (r) {\n      let { words: o } = te.decode(r, 1e3), a = te.fromWords(o);\n      e = Je.decode(a);\n    } else if (n) {\n      let [o, a] = n.split(\"@\");\n      e = `https://${a}/.well-known/lnurlp/${o}`;\n    } else\n      return null;\n    let s = await (await gi(e)).json();\n    if (s.allowsNostr && s.nostrPubkey)\n      return s.callback;\n  } catch {\n  }\n  return null;\n}\nfunction wh({\n  profile: t,\n  event: e,\n  amount: r,\n  relays: n,\n  comment: i = \"\"\n}) {\n  if (!r)\n    throw new Error(\"amount not given\");\n  if (!t)\n    throw new Error(\"profile not given\");\n  let s = {\n    kind: 9734,\n    created_at: Math.round(Date.now() / 1e3),\n    content: i,\n    tags: [\n      [\"p\", t],\n      [\"amount\", r.toString()],\n      [\"relays\", ...n]\n    ]\n  };\n  return e && s.tags.push([\"e\", e]), s;\n}\nfunction _h(t) {\n  let e;\n  try {\n    e = JSON.parse(t);\n  } catch {\n    return \"Invalid zap request JSON.\";\n  }\n  if (!fi(e))\n    return \"Zap request is not a valid Nostr event.\";\n  if (!hi(e))\n    return \"Invalid signature on zap request.\";\n  let r = e.tags.find(([s, o]) => s === \"p\" && o);\n  if (!r)\n    return \"Zap request doesn't have a 'p' tag.\";\n  if (!r[1].match(/^[a-f0-9]{64}$/))\n    return \"Zap request 'p' tag is not valid hex.\";\n  let n = e.tags.find(([s, o]) => s === \"e\" && o);\n  return n && !n[1].match(/^[a-f0-9]{64}$/) ? \"Zap request 'e' tag is not valid hex.\" : e.tags.find(([s, o]) => s === \"relays\" && o) ? null : \"Zap request doesn't have a 'relays' tag.\";\n}\nfunction mh({\n  zapRequest: t,\n  preimage: e,\n  bolt11: r,\n  paidAt: n\n}) {\n  let s = JSON.parse(t).tags.filter(\n    ([a]) => a === \"e\" || a === \"p\" || a === \"a\"\n  ), o = {\n    kind: 9735,\n    created_at: Math.round(n.getTime() / 1e3),\n    content: \"\",\n    tags: [\n      ...s,\n      [\"bolt11\", r],\n      [\"description\", t]\n    ]\n  };\n  return e && o.tags.push([\"preimage\", e]), o;\n}\nvar cr = {};\nObject.defineProperty(cr, \"__esModule\", { value: !0 });\ncr.is_node = void 0;\nvar dn = null;\nfunction xh() {\n  return dn === null && (dn = typeof S == \"object\" && typeof S.process == \"object\" && typeof S.process.versions == \"object\" && typeof S.process.versions.node < \"u\"), dn;\n}\ncr.is_node = xh;\nvar pn = {}, yn, Xi;\nfunction Eh() {\n  if (Xi)\n    return yn;\n  Xi = 1;\n  var t = function() {\n    if (typeof self == \"object\" && self)\n      return self;\n    if (typeof window == \"object\" && window)\n      return window;\n    throw new Error(\"Unable to resolve global `this`\");\n  };\n  return yn = function() {\n    if (this)\n      return this;\n    if (typeof globalThis == \"object\" && globalThis)\n      return globalThis;\n    try {\n      Object.defineProperty(Object.prototype, \"__global__\", {\n        get: function() {\n          return this;\n        },\n        configurable: !0\n      });\n    } catch {\n      return t();\n    }\n    try {\n      return __global__ || t();\n    } finally {\n      delete Object.prototype.__global__;\n    }\n  }(), yn;\n}\nconst kh = \"websocket\", Sh = \"Websocket Client & Server Library implementing the WebSocket protocol as specified in RFC 6455.\", Oh = [\n  \"websocket\",\n  \"websockets\",\n  \"socket\",\n  \"networking\",\n  \"comet\",\n  \"push\",\n  \"RFC-6455\",\n  \"realtime\",\n  \"server\",\n  \"client\"\n], Ah = \"Brian McKelvey <theturtle32@gmail.com> (https://github.com/theturtle32)\", Ch = [\n  \"I\\xF1aki Baz Castillo <ibc@aliax.net> (http://dev.sipdoc.net)\"\n], Ih = \"1.0.34\", Rh = {\n  type: \"git\",\n  url: \"https://github.com/theturtle32/WebSocket-Node.git\"\n}, Th = \"https://github.com/theturtle32/WebSocket-Node\", Ph = {\n  node: \">=4.0.0\"\n}, Bh = {\n  bufferutil: \"^4.0.1\",\n  debug: \"^2.2.0\",\n  \"es5-ext\": \"^0.10.50\",\n  \"typedarray-to-buffer\": \"^3.1.5\",\n  \"utf-8-validate\": \"^5.0.2\",\n  yaeti: \"^0.0.6\"\n}, Lh = {\n  \"buffer-equal\": \"^1.0.0\",\n  gulp: \"^4.0.2\",\n  \"gulp-jshint\": \"^2.0.4\",\n  \"jshint-stylish\": \"^2.2.1\",\n  jshint: \"^2.0.0\",\n  tape: \"^4.9.1\"\n}, $h = {\n  verbose: !1\n}, qh = {\n  test: \"tape test/unit/*.js\",\n  gulp: \"gulp\"\n}, Nh = \"index\", Uh = {\n  lib: \"./lib\"\n}, jh = \"lib/browser.js\", Hh = \"Apache-2.0\", Mh = {\n  name: kh,\n  description: Sh,\n  keywords: Oh,\n  author: Ah,\n  contributors: Ch,\n  version: Ih,\n  repository: Rh,\n  homepage: Th,\n  engines: Ph,\n  dependencies: Bh,\n  devDependencies: Lh,\n  config: $h,\n  scripts: qh,\n  main: Nh,\n  directories: Uh,\n  browser: jh,\n  license: Hh\n};\nvar gn, Qi;\nfunction Dh() {\n  return Qi || (Qi = 1, gn = Mh.version), gn;\n}\nvar bn, eo;\nfunction zh() {\n  if (eo)\n    return bn;\n  eo = 1;\n  var t;\n  if (typeof globalThis == \"object\")\n    t = globalThis;\n  else\n    try {\n      t = Eh();\n    } catch {\n    } finally {\n      if (!t && typeof window < \"u\" && (t = window), !t)\n        throw new Error(\"Could not determine global this\");\n    }\n  var e = t.WebSocket || t.MozWebSocket, r = Dh();\n  function n(i, s) {\n    var o;\n    return s ? o = new e(i, s) : o = new e(i), o;\n  }\n  return e && [\"CONNECTING\", \"OPEN\", \"CLOSING\", \"CLOSED\"].forEach(function(i) {\n    Object.defineProperty(n, i, {\n      get: function() {\n        return e[i];\n      }\n    });\n  }), bn = {\n    w3cwebsocket: e ? n : null,\n    version: r\n  }, bn;\n}\nvar _r = {}, vn = {}, Rt = {}, Tt = {}, Pt = {}, Bt = {}, to;\nfunction Fh() {\n  if (to)\n    return Bt;\n  to = 1, Object.defineProperty(Bt, \"__esModule\", { value: !0 }), Bt.ForOfAdaptor = void 0;\n  var t = function() {\n    function e(r, n) {\n      this.it_ = r, this.last_ = n;\n    }\n    return e.prototype.next = function() {\n      if (this.it_.equals(this.last_))\n        return {\n          done: !0,\n          value: void 0\n        };\n      var r = this.it_;\n      return this.it_ = this.it_.next(), {\n        done: !1,\n        value: r.value\n      };\n    }, e.prototype[Symbol.iterator] = function() {\n      return this;\n    }, e;\n  }();\n  return Bt.ForOfAdaptor = t, Bt;\n}\nvar ro;\nfunction bi() {\n  if (ro)\n    return Pt;\n  ro = 1;\n  var t = S && S.__values || function(n) {\n    var i = typeof Symbol == \"function\" && Symbol.iterator, s = i && n[i], o = 0;\n    if (s)\n      return s.call(n);\n    if (n && typeof n.length == \"number\")\n      return {\n        next: function() {\n          return n && o >= n.length && (n = void 0), { value: n && n[o++], done: !n };\n        }\n      };\n    throw new TypeError(i ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n  };\n  Object.defineProperty(Pt, \"__esModule\", { value: !0 }), Pt.Container = void 0;\n  var e = Fh(), r = function() {\n    function n() {\n    }\n    return n.prototype.empty = function() {\n      return this.size() === 0;\n    }, n.prototype.rbegin = function() {\n      return this.end().reverse();\n    }, n.prototype.rend = function() {\n      return this.begin().reverse();\n    }, n.prototype[Symbol.iterator] = function() {\n      return new e.ForOfAdaptor(this.begin(), this.end());\n    }, n.prototype.toJSON = function() {\n      var i, s, o = [];\n      try {\n        for (var a = t(this), c = a.next(); !c.done; c = a.next()) {\n          var l = c.value;\n          o.push(l);\n        }\n      } catch (f) {\n        i = { error: f };\n      } finally {\n        try {\n          c && !c.done && (s = a.return) && s.call(a);\n        } finally {\n          if (i)\n            throw i.error;\n        }\n      }\n      return o;\n    }, n;\n  }();\n  return Pt.Container = r, Pt;\n}\nvar Lt = {}, no;\nfunction vi() {\n  if (no)\n    return Lt;\n  no = 1;\n  var t = S && S.__read || function(r, n) {\n    var i = typeof Symbol == \"function\" && r[Symbol.iterator];\n    if (!i)\n      return r;\n    var s = i.call(r), o, a = [], c;\n    try {\n      for (; (n === void 0 || n-- > 0) && !(o = s.next()).done; )\n        a.push(o.value);\n    } catch (l) {\n      c = { error: l };\n    } finally {\n      try {\n        o && !o.done && (i = s.return) && i.call(s);\n      } finally {\n        if (c)\n          throw c.error;\n      }\n    }\n    return a;\n  };\n  Object.defineProperty(Lt, \"__esModule\", { value: !0 }), Lt.NativeArrayIterator = void 0;\n  var e = function() {\n    function r(n, i) {\n      this.data_ = n, this.index_ = i;\n    }\n    return r.prototype.index = function() {\n      return this.index_;\n    }, Object.defineProperty(r.prototype, \"value\", {\n      get: function() {\n        return this.data_[this.index_];\n      },\n      enumerable: !1,\n      configurable: !0\n    }), r.prototype.prev = function() {\n      return --this.index_, this;\n    }, r.prototype.next = function() {\n      return ++this.index_, this;\n    }, r.prototype.advance = function(n) {\n      return this.index_ += n, this;\n    }, r.prototype.equals = function(n) {\n      return this.data_ === n.data_ && this.index_ === n.index_;\n    }, r.prototype.swap = function(n) {\n      var i, s;\n      i = t([n.data_, this.data_], 2), this.data_ = i[0], n.data_ = i[1], s = t([n.index_, this.index_], 2), this.index_ = s[0], n.index_ = s[1];\n    }, r;\n  }();\n  return Lt.NativeArrayIterator = e, Lt;\n}\nvar io;\nfunction Kh() {\n  if (io)\n    return Tt;\n  io = 1;\n  var t = S && S.__extends || function() {\n    var i = function(s, o) {\n      return i = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(a, c) {\n        a.__proto__ = c;\n      } || function(a, c) {\n        for (var l in c)\n          Object.prototype.hasOwnProperty.call(c, l) && (a[l] = c[l]);\n      }, i(s, o);\n    };\n    return function(s, o) {\n      if (typeof o != \"function\" && o !== null)\n        throw new TypeError(\"Class extends value \" + String(o) + \" is not a constructor or null\");\n      i(s, o);\n      function a() {\n        this.constructor = s;\n      }\n      s.prototype = o === null ? Object.create(o) : (a.prototype = o.prototype, new a());\n    };\n  }();\n  Object.defineProperty(Tt, \"__esModule\", { value: !0 }), Tt.SetContainer = void 0;\n  var e = bi(), r = vi(), n = function(i) {\n    t(s, i);\n    function s(o) {\n      var a = i.call(this) || this;\n      return a.data_ = o(a), a;\n    }\n    return s.prototype.assign = function(o, a) {\n      this.clear(), this.insert(o, a);\n    }, s.prototype.clear = function() {\n      this.data_.clear();\n    }, s.prototype.begin = function() {\n      return this.data_.begin();\n    }, s.prototype.end = function() {\n      return this.data_.end();\n    }, s.prototype.has = function(o) {\n      return !this.find(o).equals(this.end());\n    }, s.prototype.size = function() {\n      return this.data_.size();\n    }, s.prototype.push = function() {\n      for (var o = [], a = 0; a < arguments.length; a++)\n        o[a] = arguments[a];\n      if (o.length === 0)\n        return this.size();\n      var c = new r.NativeArrayIterator(o, 0), l = new r.NativeArrayIterator(o, o.length);\n      return this._Insert_by_range(c, l), this.size();\n    }, s.prototype.insert = function() {\n      for (var o = [], a = 0; a < arguments.length; a++)\n        o[a] = arguments[a];\n      return o.length === 1 ? this._Insert_by_key(o[0]) : o[0].next instanceof Function && o[1].next instanceof Function ? this._Insert_by_range(o[0], o[1]) : this._Insert_by_hint(o[0], o[1]);\n    }, s.prototype.erase = function() {\n      for (var o = [], a = 0; a < arguments.length; a++)\n        o[a] = arguments[a];\n      return o.length === 1 && !(o[0] instanceof this.end().constructor && o[0].source() === this) ? this._Erase_by_val(o[0]) : o.length === 1 ? this._Erase_by_range(o[0]) : this._Erase_by_range(o[0], o[1]);\n    }, s.prototype._Erase_by_range = function(o, a) {\n      a === void 0 && (a = o.next());\n      var c = this.data_.erase(o, a);\n      return this._Handle_erase(o, a), c;\n    }, s;\n  }(e.Container);\n  return Tt.SetContainer = n, Tt;\n}\nvar wn = {}, $t = {}, qt = {}, Nt = {}, oo;\nfunction Wh() {\n  if (oo)\n    return Nt;\n  oo = 1;\n  var t = S && S.__extends || function() {\n    var r = function(n, i) {\n      return r = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(s, o) {\n        s.__proto__ = o;\n      } || function(s, o) {\n        for (var a in o)\n          Object.prototype.hasOwnProperty.call(o, a) && (s[a] = o[a]);\n      }, r(n, i);\n    };\n    return function(n, i) {\n      if (typeof i != \"function\" && i !== null)\n        throw new TypeError(\"Class extends value \" + String(i) + \" is not a constructor or null\");\n      r(n, i);\n      function s() {\n        this.constructor = n;\n      }\n      n.prototype = i === null ? Object.create(i) : (s.prototype = i.prototype, new s());\n    };\n  }();\n  Object.defineProperty(Nt, \"__esModule\", { value: !0 }), Nt.Exception = void 0;\n  var e = function(r) {\n    t(n, r);\n    function n(i) {\n      var s = this.constructor, o = r.call(this, i) || this, a = s.prototype;\n      return Object.setPrototypeOf ? Object.setPrototypeOf(o, a) : o.__proto__ = a, o;\n    }\n    return Object.defineProperty(n.prototype, \"name\", {\n      get: function() {\n        return this.constructor.name;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), n.prototype.what = function() {\n      return this.message;\n    }, n.prototype.toJSON = function() {\n      return {\n        name: this.name,\n        message: this.message,\n        stack: this.stack\n      };\n    }, n;\n  }(Error);\n  return Nt.Exception = e, Nt;\n}\nvar so;\nfunction ka() {\n  if (so)\n    return qt;\n  so = 1;\n  var t = S && S.__extends || function() {\n    var n = function(i, s) {\n      return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(o, a) {\n        o.__proto__ = a;\n      } || function(o, a) {\n        for (var c in a)\n          Object.prototype.hasOwnProperty.call(a, c) && (o[c] = a[c]);\n      }, n(i, s);\n    };\n    return function(i, s) {\n      if (typeof s != \"function\" && s !== null)\n        throw new TypeError(\"Class extends value \" + String(s) + \" is not a constructor or null\");\n      n(i, s);\n      function o() {\n        this.constructor = i;\n      }\n      i.prototype = s === null ? Object.create(s) : (o.prototype = s.prototype, new o());\n    };\n  }();\n  Object.defineProperty(qt, \"__esModule\", { value: !0 }), qt.LogicError = void 0;\n  var e = Wh(), r = function(n) {\n    t(i, n);\n    function i(s) {\n      return n.call(this, s) || this;\n    }\n    return i;\n  }(e.Exception);\n  return qt.LogicError = r, qt;\n}\nvar ao;\nfunction Sa() {\n  if (ao)\n    return $t;\n  ao = 1;\n  var t = S && S.__extends || function() {\n    var n = function(i, s) {\n      return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(o, a) {\n        o.__proto__ = a;\n      } || function(o, a) {\n        for (var c in a)\n          Object.prototype.hasOwnProperty.call(a, c) && (o[c] = a[c]);\n      }, n(i, s);\n    };\n    return function(i, s) {\n      if (typeof s != \"function\" && s !== null)\n        throw new TypeError(\"Class extends value \" + String(s) + \" is not a constructor or null\");\n      n(i, s);\n      function o() {\n        this.constructor = i;\n      }\n      i.prototype = s === null ? Object.create(s) : (o.prototype = s.prototype, new o());\n    };\n  }();\n  Object.defineProperty($t, \"__esModule\", { value: !0 }), $t.InvalidArgument = void 0;\n  var e = ka(), r = function(n) {\n    t(i, n);\n    function i(s) {\n      return n.call(this, s) || this;\n    }\n    return i;\n  }(e.LogicError);\n  return $t.InvalidArgument = r, $t;\n}\nvar Ut = {}, co;\nfunction Vh() {\n  if (co)\n    return Ut;\n  co = 1;\n  var t = S && S.__extends || function() {\n    var n = function(i, s) {\n      return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(o, a) {\n        o.__proto__ = a;\n      } || function(o, a) {\n        for (var c in a)\n          Object.prototype.hasOwnProperty.call(a, c) && (o[c] = a[c]);\n      }, n(i, s);\n    };\n    return function(i, s) {\n      if (typeof s != \"function\" && s !== null)\n        throw new TypeError(\"Class extends value \" + String(s) + \" is not a constructor or null\");\n      n(i, s);\n      function o() {\n        this.constructor = i;\n      }\n      i.prototype = s === null ? Object.create(s) : (o.prototype = s.prototype, new o());\n    };\n  }();\n  Object.defineProperty(Ut, \"__esModule\", { value: !0 }), Ut.OutOfRange = void 0;\n  var e = ka(), r = function(n) {\n    t(i, n);\n    function i(s) {\n      return n.call(this, s) || this;\n    }\n    return i;\n  }(e.LogicError);\n  return Ut.OutOfRange = r, Ut;\n}\nvar uo;\nfunction Wr() {\n  return uo || (uo = 1, function(t) {\n    Object.defineProperty(t, \"__esModule\", { value: !0 }), t.ErrorGenerator = void 0;\n    var e = Sa(), r = Vh();\n    (function(n) {\n      function i(d) {\n        if (typeof d == \"string\")\n          return d;\n        var p = d.constructor.name;\n        return d.constructor.__MODULE && (p = \"\".concat(d.constructor.__MODULE, \".\").concat(p)), \"std.\".concat(p);\n      }\n      n.get_class_name = i;\n      function s(d, p) {\n        return new r.OutOfRange(\"Error on \".concat(i(d), \".\").concat(p, \"(): it's empty container.\"));\n      }\n      n.empty = s;\n      function o(d, p, y) {\n        return new r.OutOfRange(\"Error on \".concat(i(d), \".\").concat(p, \"(): parametric index is negative -> (index = \").concat(y, \").\"));\n      }\n      n.negative_index = o;\n      function a(d, p, y, g) {\n        return new r.OutOfRange(\"Error on \".concat(i(d), \".\").concat(p, \"(): parametric index is equal or greater than size -> (index = \").concat(y, \", size: \").concat(g, \").\"));\n      }\n      n.excessive_index = a;\n      function c(d, p) {\n        return new e.InvalidArgument(\"Error on \".concat(i(d), \".\").concat(p, \"(): parametric iterator is not this container's own.\"));\n      }\n      n.not_my_iterator = c;\n      function l(d, p) {\n        return new e.InvalidArgument(\"Error on \".concat(i(d), \".\").concat(p, \"(): parametric iterator, it already has been erased.\"));\n      }\n      n.erased_iterator = l;\n      function f(d, p, y) {\n        return new r.OutOfRange(\"Error on \".concat(i(d), \".\").concat(p, \"(): parametric iterator is directing negative position -> (index = \").concat(y, \").\"));\n      }\n      n.negative_iterator = f;\n      function u(d, p) {\n        p === void 0 && (p = \"end\");\n        var y = i(d);\n        return new r.OutOfRange(\"Error on \".concat(y, \".Iterator.value: cannot access to the \").concat(y, \".\").concat(p, \"().value.\"));\n      }\n      n.iterator_end_value = u;\n      function h(d, p, y) {\n        throw new r.OutOfRange(\"Error on \".concat(i(d), \".\").concat(p, \"(): unable to find the matched key -> \").concat(y));\n      }\n      n.key_nout_found = h;\n    })(t.ErrorGenerator || (t.ErrorGenerator = {}));\n  }(wn)), wn;\n}\nvar lo;\nfunction Gh() {\n  if (lo)\n    return Rt;\n  lo = 1;\n  var t = S && S.__extends || function() {\n    var o = function(a, c) {\n      return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(l, f) {\n        l.__proto__ = f;\n      } || function(l, f) {\n        for (var u in f)\n          Object.prototype.hasOwnProperty.call(f, u) && (l[u] = f[u]);\n      }, o(a, c);\n    };\n    return function(a, c) {\n      if (typeof c != \"function\" && c !== null)\n        throw new TypeError(\"Class extends value \" + String(c) + \" is not a constructor or null\");\n      o(a, c);\n      function l() {\n        this.constructor = a;\n      }\n      a.prototype = c === null ? Object.create(c) : (l.prototype = c.prototype, new l());\n    };\n  }(), e = S && S.__read || function(o, a) {\n    var c = typeof Symbol == \"function\" && o[Symbol.iterator];\n    if (!c)\n      return o;\n    var l = c.call(o), f, u = [], h;\n    try {\n      for (; (a === void 0 || a-- > 0) && !(f = l.next()).done; )\n        u.push(f.value);\n    } catch (d) {\n      h = { error: d };\n    } finally {\n      try {\n        f && !f.done && (c = l.return) && c.call(l);\n      } finally {\n        if (h)\n          throw h.error;\n      }\n    }\n    return u;\n  }, r = S && S.__spreadArray || function(o, a, c) {\n    if (c || arguments.length === 2)\n      for (var l = 0, f = a.length, u; l < f; l++)\n        (u || !(l in a)) && (u || (u = Array.prototype.slice.call(a, 0, l)), u[l] = a[l]);\n    return o.concat(u || Array.prototype.slice.call(a));\n  };\n  Object.defineProperty(Rt, \"__esModule\", { value: !0 }), Rt.UniqueSet = void 0;\n  var n = Kh(), i = Wr(), s = function(o) {\n    t(a, o);\n    function a() {\n      return o !== null && o.apply(this, arguments) || this;\n    }\n    return a.prototype.count = function(c) {\n      return this.find(c).equals(this.end()) ? 0 : 1;\n    }, a.prototype.insert = function() {\n      for (var c = [], l = 0; l < arguments.length; l++)\n        c[l] = arguments[l];\n      return o.prototype.insert.apply(this, r([], e(c), !1));\n    }, a.prototype._Insert_by_range = function(c, l) {\n      for (; !c.equals(l); c = c.next())\n        this._Insert_by_key(c.value);\n    }, a.prototype.extract = function(c) {\n      return c instanceof this.end().constructor ? this._Extract_by_iterator(c) : this._Extract_by_val(c);\n    }, a.prototype._Extract_by_val = function(c) {\n      var l = this.find(c);\n      if (l.equals(this.end()) === !0)\n        throw i.ErrorGenerator.key_nout_found(this, \"extract\", c);\n      return this._Erase_by_range(l), c;\n    }, a.prototype._Extract_by_iterator = function(c) {\n      return c.equals(this.end()) === !0 || this.has(c.value) === !1 ? this.end() : (this._Erase_by_range(c), c);\n    }, a.prototype._Erase_by_val = function(c) {\n      var l = this.find(c);\n      return l.equals(this.end()) === !0 ? 0 : (this._Erase_by_range(l), 1);\n    }, a.prototype.merge = function(c) {\n      for (var l = c.begin(); !l.equals(c.end()); )\n        this.has(l.value) === !1 ? (this.insert(l.value), l = c.erase(l)) : l = l.next();\n    }, a;\n  }(n.SetContainer);\n  return Rt.UniqueSet = s, Rt;\n}\nvar _n = {}, mn = {}, fo;\nfunction Zh() {\n  return fo || (fo = 1, function(t) {\n    var e = S && S.__read || function(n, i) {\n      var s = typeof Symbol == \"function\" && n[Symbol.iterator];\n      if (!s)\n        return n;\n      var o = s.call(n), a, c = [], l;\n      try {\n        for (; (i === void 0 || i-- > 0) && !(a = o.next()).done; )\n          c.push(a.value);\n      } catch (f) {\n        l = { error: f };\n      } finally {\n        try {\n          a && !a.done && (s = o.return) && s.call(o);\n        } finally {\n          if (l)\n            throw l.error;\n        }\n      }\n      return c;\n    }, r = S && S.__spreadArray || function(n, i, s) {\n      if (s || arguments.length === 2)\n        for (var o = 0, a = i.length, c; o < a; o++)\n          (c || !(o in i)) && (c || (c = Array.prototype.slice.call(i, 0, o)), c[o] = i[o]);\n      return n.concat(c || Array.prototype.slice.call(i));\n    };\n    Object.defineProperty(t, \"__esModule\", { value: !0 }), t.IAssociativeContainer = void 0, function(n) {\n      function i(s) {\n        for (var o = [], a = 1; a < arguments.length; a++)\n          o[a - 1] = arguments[a];\n        var c, l;\n        return o.length >= 1 && o[0] instanceof Array ? (c = function() {\n          var f = o[0];\n          s.push.apply(s, r([], e(f), !1));\n        }, l = o.slice(1)) : o.length >= 2 && o[0].next instanceof Function && o[1].next instanceof Function ? (c = function() {\n          var f = o[0], u = o[1];\n          s.assign(f, u);\n        }, l = o.slice(2)) : (c = null, l = o), { ramda: c, tail: l };\n      }\n      n.construct = i;\n    }(t.IAssociativeContainer || (t.IAssociativeContainer = {}));\n  }(mn)), mn;\n}\nvar jt = {}, Ht = {}, Mt = {}, ho;\nfunction Yh() {\n  if (ho)\n    return Mt;\n  ho = 1, Object.defineProperty(Mt, \"__esModule\", { value: !0 }), Mt._Get_root = void 0;\n  var t = cr;\n  function e() {\n    return r === null && (r = (0, t.is_node)() ? S : self, r.__s_iUID === void 0 && (r.__s_iUID = 0)), r;\n  }\n  Mt._Get_root = e;\n  var r = null;\n  return Mt;\n}\nvar po;\nfunction Oa() {\n  if (po)\n    return Ht;\n  po = 1, Object.defineProperty(Ht, \"__esModule\", { value: !0 }), Ht.get_uid = void 0;\n  var t = Yh();\n  function e(r) {\n    if (r instanceof Object) {\n      if (r.hasOwnProperty(\"__get_m_iUID\") === !1) {\n        var n = ++(0, t._Get_root)().__s_iUID;\n        Object.defineProperty(r, \"__get_m_iUID\", {\n          value: function() {\n            return n;\n          }\n        });\n      }\n      return r.__get_m_iUID();\n    } else\n      return r === void 0 ? -1 : 0;\n  }\n  return Ht.get_uid = e, Ht;\n}\nvar yo;\nfunction wi() {\n  if (yo)\n    return jt;\n  yo = 1;\n  var t = S && S.__values || function(c) {\n    var l = typeof Symbol == \"function\" && Symbol.iterator, f = l && c[l], u = 0;\n    if (f)\n      return f.call(c);\n    if (c && typeof c.length == \"number\")\n      return {\n        next: function() {\n          return c && u >= c.length && (c = void 0), { value: c && c[u++], done: !c };\n        }\n      };\n    throw new TypeError(l ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n  };\n  Object.defineProperty(jt, \"__esModule\", { value: !0 }), jt.hash = void 0;\n  var e = Oa();\n  function r() {\n    for (var c, l, f = [], u = 0; u < arguments.length; u++)\n      f[u] = arguments[u];\n    var h = o;\n    try {\n      for (var d = t(f), p = d.next(); !p.done; p = d.next()) {\n        var y = p.value;\n        y = y && y.valueOf();\n        var g = typeof y;\n        if (g === \"boolean\")\n          h = n(y, h);\n        else if (g === \"number\" || g === \"bigint\")\n          h = i(y, h);\n        else if (g === \"string\")\n          h = s(y, h);\n        else if (y instanceof Object && y.hashCode instanceof Function) {\n          var v = y.hashCode();\n          if (f.length === 1)\n            return v;\n          h = h ^ v, h *= a;\n        } else\n          h = i((0, e.get_uid)(y), h);\n      }\n    } catch (_) {\n      c = { error: _ };\n    } finally {\n      try {\n        p && !p.done && (l = d.return) && l.call(d);\n      } finally {\n        if (c)\n          throw c.error;\n      }\n    }\n    return Math.abs(h);\n  }\n  jt.hash = r;\n  function n(c, l) {\n    return l ^= c ? 1 : 0, l *= a, l;\n  }\n  function i(c, l) {\n    return s(c.toString(), l);\n  }\n  function s(c, l) {\n    for (var f = 0; f < c.length; ++f)\n      l ^= c.charCodeAt(f), l *= a;\n    return Math.abs(l);\n  }\n  var o = 2166136261, a = 16777619;\n  return jt;\n}\nvar ae = {}, go;\nfunction _i() {\n  if (go)\n    return ae;\n  go = 1, Object.defineProperty(ae, \"__esModule\", { value: !0 }), ae.greater_equal = ae.greater = ae.less_equal = ae.less = ae.not_equal_to = ae.equal_to = void 0;\n  var t = Oa();\n  function e(a, c) {\n    return a = a && a.valueOf(), c = c && c.valueOf(), a instanceof Object && a.equals instanceof Function ? a.equals(c) : a === c;\n  }\n  ae.equal_to = e;\n  function r(a, c) {\n    return !e(a, c);\n  }\n  ae.not_equal_to = r;\n  function n(a, c) {\n    return a = a.valueOf(), c = c.valueOf(), a instanceof Object ? a.less instanceof Function ? a.less(c) : (0, t.get_uid)(a) < (0, t.get_uid)(c) : a < c;\n  }\n  ae.less = n;\n  function i(a, c) {\n    return n(a, c) || e(a, c);\n  }\n  ae.less_equal = i;\n  function s(a, c) {\n    return !i(a, c);\n  }\n  ae.greater = s;\n  function o(a, c) {\n    return !n(a, c);\n  }\n  return ae.greater_equal = o, ae;\n}\nvar bo;\nfunction Aa() {\n  return bo || (bo = 1, function(t) {\n    var e = S && S.__read || function(o, a) {\n      var c = typeof Symbol == \"function\" && o[Symbol.iterator];\n      if (!c)\n        return o;\n      var l = c.call(o), f, u = [], h;\n      try {\n        for (; (a === void 0 || a-- > 0) && !(f = l.next()).done; )\n          u.push(f.value);\n      } catch (d) {\n        h = { error: d };\n      } finally {\n        try {\n          f && !f.done && (c = l.return) && c.call(l);\n        } finally {\n          if (h)\n            throw h.error;\n        }\n      }\n      return u;\n    }, r = S && S.__spreadArray || function(o, a, c) {\n      if (c || arguments.length === 2)\n        for (var l = 0, f = a.length, u; l < f; l++)\n          (u || !(l in a)) && (u || (u = Array.prototype.slice.call(a, 0, l)), u[l] = a[l]);\n      return o.concat(u || Array.prototype.slice.call(a));\n    };\n    Object.defineProperty(t, \"__esModule\", { value: !0 }), t.IHashContainer = void 0;\n    var n = Zh(), i = wi(), s = _i();\n    (function(o) {\n      function a(c, l, f) {\n        for (var u = [], h = 3; h < arguments.length; h++)\n          u[h - 3] = arguments[h];\n        var d = null, p = i.hash, y = s.equal_to;\n        if (u.length === 1 && u[0] instanceof l) {\n          var g = u[0];\n          p = g.hash_function(), y = g.key_eq(), d = function() {\n            var _ = g.begin(), m = g.end();\n            c.assign(_, m);\n          };\n        } else {\n          var v = n.IAssociativeContainer.construct.apply(n.IAssociativeContainer, r([c], e(u), !1));\n          d = v.ramda, v.tail.length >= 1 && (p = v.tail[0]), v.tail.length >= 2 && (y = v.tail[1]);\n        }\n        f(p, y), d !== null && d();\n      }\n      o.construct = a;\n    })(t.IHashContainer || (t.IHashContainer = {}));\n  }(_n)), _n;\n}\nvar xn = {}, Dt = {}, zt = {}, vo;\nfunction mi() {\n  if (vo)\n    return zt;\n  vo = 1, Object.defineProperty(zt, \"__esModule\", { value: !0 }), zt.ListIterator = void 0;\n  var t = Wr(), e = function() {\n    function r(n, i, s) {\n      this.prev_ = n, this.next_ = i, this.value_ = s;\n    }\n    return r._Set_prev = function(n, i) {\n      n.prev_ = i;\n    }, r._Set_next = function(n, i) {\n      n.next_ = i;\n    }, r.prototype.prev = function() {\n      return this.prev_;\n    }, r.prototype.next = function() {\n      return this.next_;\n    }, Object.defineProperty(r.prototype, \"value\", {\n      get: function() {\n        return this._Try_value(), this.value_;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), r.prototype._Try_value = function() {\n      if (this.value_ === void 0 && this.equals(this.source().end()) === !0)\n        throw t.ErrorGenerator.iterator_end_value(this.source());\n    }, r.prototype.equals = function(n) {\n      return this === n;\n    }, r;\n  }();\n  return zt.ListIterator = e, zt;\n}\nvar Ft = {}, wo;\nfunction Jh() {\n  if (wo)\n    return Ft;\n  wo = 1, Object.defineProperty(Ft, \"__esModule\", { value: !0 }), Ft.Repeater = void 0;\n  var t = function() {\n    function e(r, n) {\n      this.index_ = r, this.value_ = n;\n    }\n    return e.prototype.index = function() {\n      return this.index_;\n    }, Object.defineProperty(e.prototype, \"value\", {\n      get: function() {\n        return this.value_;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), e.prototype.next = function() {\n      return ++this.index_, this;\n    }, e.prototype.equals = function(r) {\n      return this.index_ === r.index_;\n    }, e;\n  }();\n  return Ft.Repeater = t, Ft;\n}\nvar ce = {}, _o;\nfunction Xh() {\n  if (_o)\n    return ce;\n  _o = 1, Object.defineProperty(ce, \"__esModule\", { value: !0 }), ce.next = ce.prev = ce.advance = ce.distance = ce.size = ce.empty = void 0;\n  var t = Sa();\n  function e(c) {\n    return c instanceof Array ? c.length !== 0 : c.empty();\n  }\n  ce.empty = e;\n  function r(c) {\n    return c instanceof Array ? c.length : c.size();\n  }\n  ce.size = r;\n  function n(c, l) {\n    if (c.index instanceof Function)\n      return i(c, l);\n    for (var f = 0; !c.equals(l); c = c.next())\n      ++f;\n    return f;\n  }\n  ce.distance = n;\n  function i(c, l) {\n    var f = c.index(), u = l.index();\n    return c.base instanceof Function ? f - u : u - f;\n  }\n  function s(c, l) {\n    if (l === 0)\n      return c;\n    if (c.advance instanceof Function)\n      return c.advance(l);\n    var f;\n    if (l < 0) {\n      if (!(c.prev instanceof Function))\n        throw new t.InvalidArgument(\"Error on std.advance(): parametric iterator is not a bi-directional iterator, thus advancing to negative direction is not possible.\");\n      f = function(u) {\n        return u.prev();\n      }, l = -l;\n    } else\n      f = function(u) {\n        return u.next();\n      };\n    for (; l-- > 0; )\n      c = f(c);\n    return c;\n  }\n  ce.advance = s;\n  function o(c, l) {\n    return l === void 0 && (l = 1), l === 1 ? c.prev() : s(c, -l);\n  }\n  ce.prev = o;\n  function a(c, l) {\n    return l === void 0 && (l = 1), l === 1 ? c.next() : s(c, l);\n  }\n  return ce.next = a, ce;\n}\nvar mo;\nfunction Ca() {\n  if (mo)\n    return Dt;\n  mo = 1;\n  var t = S && S.__extends || function() {\n    var l = function(f, u) {\n      return l = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(h, d) {\n        h.__proto__ = d;\n      } || function(h, d) {\n        for (var p in d)\n          Object.prototype.hasOwnProperty.call(d, p) && (h[p] = d[p]);\n      }, l(f, u);\n    };\n    return function(f, u) {\n      if (typeof u != \"function\" && u !== null)\n        throw new TypeError(\"Class extends value \" + String(u) + \" is not a constructor or null\");\n      l(f, u);\n      function h() {\n        this.constructor = f;\n      }\n      f.prototype = u === null ? Object.create(u) : (h.prototype = u.prototype, new h());\n    };\n  }(), e = S && S.__read || function(l, f) {\n    var u = typeof Symbol == \"function\" && l[Symbol.iterator];\n    if (!u)\n      return l;\n    var h = u.call(l), d, p = [], y;\n    try {\n      for (; (f === void 0 || f-- > 0) && !(d = h.next()).done; )\n        p.push(d.value);\n    } catch (g) {\n      y = { error: g };\n    } finally {\n      try {\n        d && !d.done && (u = h.return) && u.call(h);\n      } finally {\n        if (y)\n          throw y.error;\n      }\n    }\n    return p;\n  };\n  Object.defineProperty(Dt, \"__esModule\", { value: !0 }), Dt.ListContainer = void 0;\n  var r = bi(), n = mi(), i = Jh(), s = vi(), o = Xh(), a = Wr(), c = function(l) {\n    t(f, l);\n    function f() {\n      var u = l.call(this) || this;\n      return u.end_ = u._Create_iterator(null, null), u.clear(), u;\n    }\n    return f.prototype.assign = function(u, h) {\n      this.clear(), this.insert(this.end(), u, h);\n    }, f.prototype.clear = function() {\n      n.ListIterator._Set_prev(this.end_, this.end_), n.ListIterator._Set_next(this.end_, this.end_), this.begin_ = this.end_, this.size_ = 0;\n    }, f.prototype.resize = function(u) {\n      var h = u - this.size();\n      h > 0 ? this.insert(this.end(), h, void 0) : h < 0 && this.erase((0, o.advance)(this.end(), -h), this.end());\n    }, f.prototype.begin = function() {\n      return this.begin_;\n    }, f.prototype.end = function() {\n      return this.end_;\n    }, f.prototype.size = function() {\n      return this.size_;\n    }, f.prototype.push_front = function(u) {\n      this.insert(this.begin_, u);\n    }, f.prototype.push_back = function(u) {\n      this.insert(this.end_, u);\n    }, f.prototype.pop_front = function() {\n      if (this.empty() === !0)\n        throw a.ErrorGenerator.empty(this.end_.source().constructor.name, \"pop_front\");\n      this.erase(this.begin_);\n    }, f.prototype.pop_back = function() {\n      if (this.empty() === !0)\n        throw a.ErrorGenerator.empty(this.end_.source().constructor.name, \"pop_back\");\n      this.erase(this.end_.prev());\n    }, f.prototype.push = function() {\n      for (var u = [], h = 0; h < arguments.length; h++)\n        u[h] = arguments[h];\n      if (u.length === 0)\n        return this.size();\n      var d = new s.NativeArrayIterator(u, 0), p = new s.NativeArrayIterator(u, u.length);\n      return this._Insert_by_range(this.end(), d, p), this.size();\n    }, f.prototype.insert = function(u) {\n      for (var h = [], d = 1; d < arguments.length; d++)\n        h[d - 1] = arguments[d];\n      if (u.source() !== this.end_.source())\n        throw a.ErrorGenerator.not_my_iterator(this.end_.source(), \"insert\");\n      if (u.erased_ === !0)\n        throw a.ErrorGenerator.erased_iterator(this.end_.source(), \"insert\");\n      return h.length === 1 ? this._Insert_by_repeating_val(u, 1, h[0]) : h.length === 2 && typeof h[0] == \"number\" ? this._Insert_by_repeating_val(u, h[0], h[1]) : this._Insert_by_range(u, h[0], h[1]);\n    }, f.prototype._Insert_by_repeating_val = function(u, h, d) {\n      var p = new i.Repeater(0, d), y = new i.Repeater(h);\n      return this._Insert_by_range(u, p, y);\n    }, f.prototype._Insert_by_range = function(u, h, d) {\n      for (var p = u.prev(), y = null, g = 0, v = h; v.equals(d) === !1; v = v.next()) {\n        var _ = this._Create_iterator(p, null, v.value);\n        g === 0 && (y = _), n.ListIterator._Set_next(p, _), p = _, ++g;\n      }\n      return u.equals(this.begin()) === !0 && (this.begin_ = y), n.ListIterator._Set_next(p, u), n.ListIterator._Set_prev(u, p), this.size_ += g, y;\n    }, f.prototype.erase = function(u, h) {\n      return h === void 0 && (h = u.next()), this._Erase_by_range(u, h);\n    }, f.prototype._Erase_by_range = function(u, h) {\n      if (u.source() !== this.end_.source())\n        throw a.ErrorGenerator.not_my_iterator(this.end_.source(), \"insert\");\n      if (u.erased_ === !0)\n        throw a.ErrorGenerator.erased_iterator(this.end_.source(), \"insert\");\n      if (u.equals(this.end_))\n        return this.end_;\n      var d = u.prev();\n      n.ListIterator._Set_next(d, h), n.ListIterator._Set_prev(h, d);\n      for (var p = u; !p.equals(h); p = p.next())\n        p.erased_ = !0, --this.size_;\n      return u.equals(this.begin_) && (this.begin_ = h), h;\n    }, f.prototype.swap = function(u) {\n      var h, d, p;\n      h = e([u.begin_, this.begin_], 2), this.begin_ = h[0], u.begin_ = h[1], d = e([u.end_, this.end_], 2), this.end_ = d[0], u.end_ = d[1], p = e([u.size_, this.size_], 2), this.size_ = p[0], u.size_ = p[1];\n    }, f;\n  }(r.Container);\n  return Dt.ListContainer = c, Dt;\n}\nvar Kt = {}, xo;\nfunction Ia() {\n  if (xo)\n    return Kt;\n  xo = 1, Object.defineProperty(Kt, \"__esModule\", { value: !0 }), Kt.ReverseIterator = void 0;\n  var t = function() {\n    function e(r) {\n      this.base_ = r.prev();\n    }\n    return e.prototype.source = function() {\n      return this.base_.source();\n    }, e.prototype.base = function() {\n      return this.base_.next();\n    }, Object.defineProperty(e.prototype, \"value\", {\n      get: function() {\n        return this.base_.value;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), e.prototype.prev = function() {\n      return this._Create_neighbor(this.base().next());\n    }, e.prototype.next = function() {\n      return this._Create_neighbor(this.base_);\n    }, e.prototype.equals = function(r) {\n      return this.base_.equals(r.base_);\n    }, e;\n  }();\n  return Kt.ReverseIterator = t, Kt;\n}\nvar Eo;\nfunction Qh() {\n  return Eo || (Eo = 1, function(t) {\n    var e = S && S.__extends || function() {\n      var a = function(c, l) {\n        return a = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(f, u) {\n          f.__proto__ = u;\n        } || function(f, u) {\n          for (var h in u)\n            Object.prototype.hasOwnProperty.call(u, h) && (f[h] = u[h]);\n        }, a(c, l);\n      };\n      return function(c, l) {\n        if (typeof l != \"function\" && l !== null)\n          throw new TypeError(\"Class extends value \" + String(l) + \" is not a constructor or null\");\n        a(c, l);\n        function f() {\n          this.constructor = c;\n        }\n        c.prototype = l === null ? Object.create(l) : (f.prototype = l.prototype, new f());\n      };\n    }(), r = S && S.__read || function(a, c) {\n      var l = typeof Symbol == \"function\" && a[Symbol.iterator];\n      if (!l)\n        return a;\n      var f = l.call(a), u, h = [], d;\n      try {\n        for (; (c === void 0 || c-- > 0) && !(u = f.next()).done; )\n          h.push(u.value);\n      } catch (p) {\n        d = { error: p };\n      } finally {\n        try {\n          u && !u.done && (l = f.return) && l.call(f);\n        } finally {\n          if (d)\n            throw d.error;\n        }\n      }\n      return h;\n    };\n    Object.defineProperty(t, \"__esModule\", { value: !0 }), t.SetElementList = void 0;\n    var n = Ca(), i = mi(), s = Ia(), o = function(a) {\n      e(c, a);\n      function c(l) {\n        var f = a.call(this) || this;\n        return f.associative_ = l, f;\n      }\n      return c.prototype._Create_iterator = function(l, f, u) {\n        return c.Iterator.create(this, l, f, u);\n      }, c._Swap_associative = function(l, f) {\n        var u;\n        u = r([f.associative_, l.associative_], 2), l.associative_ = u[0], f.associative_ = u[1];\n      }, c.prototype.associative = function() {\n        return this.associative_;\n      }, c;\n    }(n.ListContainer);\n    t.SetElementList = o, function(a) {\n      var c = function(f) {\n        e(u, f);\n        function u(h, d, p, y) {\n          var g = f.call(this, d, p, y) || this;\n          return g.source_ = h, g;\n        }\n        return u.create = function(h, d, p, y) {\n          return new u(h, d, p, y);\n        }, u.prototype.reverse = function() {\n          return new l(this);\n        }, u.prototype.source = function() {\n          return this.source_.associative();\n        }, u;\n      }(i.ListIterator);\n      a.Iterator = c;\n      var l = function(f) {\n        e(u, f);\n        function u() {\n          return f !== null && f.apply(this, arguments) || this;\n        }\n        return u.prototype._Create_neighbor = function(h) {\n          return new u(h);\n        }, u;\n      }(s.ReverseIterator);\n      a.ReverseIterator = l;\n    }(o = t.SetElementList || (t.SetElementList = {})), t.SetElementList = o;\n  }(xn)), xn;\n}\nvar Wt = {}, Vt = {}, ko;\nfunction Ra() {\n  if (ko)\n    return Vt;\n  ko = 1;\n  var t = S && S.__values || function(i) {\n    var s = typeof Symbol == \"function\" && Symbol.iterator, o = s && i[s], a = 0;\n    if (o)\n      return o.call(i);\n    if (i && typeof i.length == \"number\")\n      return {\n        next: function() {\n          return i && a >= i.length && (i = void 0), { value: i && i[a++], done: !i };\n        }\n      };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n  };\n  Object.defineProperty(Vt, \"__esModule\", { value: !0 }), Vt.HashBuckets = void 0;\n  var e = function() {\n    function i(s, o) {\n      this.fetcher_ = s, this.hasher_ = o, this.max_load_factor_ = n, this.data_ = [], this.size_ = 0, this.initialize();\n    }\n    return i.prototype.clear = function() {\n      this.data_ = [], this.size_ = 0, this.initialize();\n    }, i.prototype.rehash = function(s) {\n      var o, a, c, l;\n      s = Math.max(s, r);\n      for (var f = [], u = 0; u < s; ++u)\n        f.push([]);\n      try {\n        for (var h = t(this.data_), d = h.next(); !d.done; d = h.next()) {\n          var p = d.value;\n          try {\n            for (var y = (c = void 0, t(p)), g = y.next(); !g.done; g = y.next()) {\n              var v = g.value, _ = this.hasher_(this.fetcher_(v)) % f.length;\n              f[_].push(v);\n            }\n          } catch (m) {\n            c = { error: m };\n          } finally {\n            try {\n              g && !g.done && (l = y.return) && l.call(y);\n            } finally {\n              if (c)\n                throw c.error;\n            }\n          }\n        }\n      } catch (m) {\n        o = { error: m };\n      } finally {\n        try {\n          d && !d.done && (a = h.return) && a.call(h);\n        } finally {\n          if (o)\n            throw o.error;\n        }\n      }\n      this.data_ = f;\n    }, i.prototype.reserve = function(s) {\n      s > this.capacity() && (s = Math.floor(s / this.max_load_factor_), this.rehash(s));\n    }, i.prototype.initialize = function() {\n      for (var s = 0; s < r; ++s)\n        this.data_.push([]);\n    }, i.prototype.length = function() {\n      return this.data_.length;\n    }, i.prototype.capacity = function() {\n      return this.data_.length * this.max_load_factor_;\n    }, i.prototype.at = function(s) {\n      return this.data_[s];\n    }, i.prototype.load_factor = function() {\n      return this.size_ / this.length();\n    }, i.prototype.max_load_factor = function(s) {\n      if (s === void 0 && (s = null), s === null)\n        return this.max_load_factor_;\n      this.max_load_factor_ = s;\n    }, i.prototype.hash_function = function() {\n      return this.hasher_;\n    }, i.prototype.index = function(s) {\n      return this.hasher_(this.fetcher_(s)) % this.length();\n    }, i.prototype.insert = function(s) {\n      var o = this.capacity();\n      ++this.size_ > o && this.reserve(o * 2);\n      var a = this.index(s);\n      this.data_[a].push(s);\n    }, i.prototype.erase = function(s) {\n      for (var o = this.index(s), a = this.data_[o], c = 0; c < a.length; ++c)\n        if (a[c] === s) {\n          a.splice(c, 1), --this.size_;\n          break;\n        }\n    }, i;\n  }();\n  Vt.HashBuckets = e;\n  var r = 10, n = 1;\n  return Vt;\n}\nvar So;\nfunction ed() {\n  if (So)\n    return Wt;\n  So = 1;\n  var t = S && S.__extends || function() {\n    var o = function(a, c) {\n      return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(l, f) {\n        l.__proto__ = f;\n      } || function(l, f) {\n        for (var u in f)\n          Object.prototype.hasOwnProperty.call(f, u) && (l[u] = f[u]);\n      }, o(a, c);\n    };\n    return function(a, c) {\n      if (typeof c != \"function\" && c !== null)\n        throw new TypeError(\"Class extends value \" + String(c) + \" is not a constructor or null\");\n      o(a, c);\n      function l() {\n        this.constructor = a;\n      }\n      a.prototype = c === null ? Object.create(c) : (l.prototype = c.prototype, new l());\n    };\n  }(), e = S && S.__read || function(o, a) {\n    var c = typeof Symbol == \"function\" && o[Symbol.iterator];\n    if (!c)\n      return o;\n    var l = c.call(o), f, u = [], h;\n    try {\n      for (; (a === void 0 || a-- > 0) && !(f = l.next()).done; )\n        u.push(f.value);\n    } catch (d) {\n      h = { error: d };\n    } finally {\n      try {\n        f && !f.done && (c = l.return) && c.call(l);\n      } finally {\n        if (h)\n          throw h.error;\n      }\n    }\n    return u;\n  }, r = S && S.__values || function(o) {\n    var a = typeof Symbol == \"function\" && Symbol.iterator, c = a && o[a], l = 0;\n    if (c)\n      return c.call(o);\n    if (o && typeof o.length == \"number\")\n      return {\n        next: function() {\n          return o && l >= o.length && (o = void 0), { value: o && o[l++], done: !o };\n        }\n      };\n    throw new TypeError(a ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n  };\n  Object.defineProperty(Wt, \"__esModule\", { value: !0 }), Wt.SetHashBuckets = void 0;\n  var n = Ra(), i = function(o) {\n    t(a, o);\n    function a(c, l, f) {\n      var u = o.call(this, s, l) || this;\n      return u.source_ = c, u.key_eq_ = f, u;\n    }\n    return a._Swap_source = function(c, l) {\n      var f;\n      f = e([l.source_, c.source_], 2), c.source_ = f[0], l.source_ = f[1];\n    }, a.prototype.key_eq = function() {\n      return this.key_eq_;\n    }, a.prototype.find = function(c) {\n      var l, f, u = this.hash_function()(c) % this.length(), h = this.at(u);\n      try {\n        for (var d = r(h), p = d.next(); !p.done; p = d.next()) {\n          var y = p.value;\n          if (this.key_eq_(y.value, c))\n            return y;\n        }\n      } catch (g) {\n        l = { error: g };\n      } finally {\n        try {\n          p && !p.done && (f = d.return) && f.call(d);\n        } finally {\n          if (l)\n            throw l.error;\n        }\n      }\n      return this.source_.end();\n    }, a;\n  }(n.HashBuckets);\n  Wt.SetHashBuckets = i;\n  function s(o) {\n    return o.value;\n  }\n  return Wt;\n}\nvar st = {}, Oo;\nfunction Ta() {\n  if (Oo)\n    return st;\n  Oo = 1, Object.defineProperty(st, \"__esModule\", { value: !0 }), st.make_pair = st.Pair = void 0;\n  var t = wi(), e = _i(), r = function() {\n    function i(s, o) {\n      this.first = s, this.second = o;\n    }\n    return i.prototype.equals = function(s) {\n      return (0, e.equal_to)(this.first, s.first) && (0, e.equal_to)(this.second, s.second);\n    }, i.prototype.less = function(s) {\n      return (0, e.equal_to)(this.first, s.first) === !1 ? (0, e.less)(this.first, s.first) : (0, e.less)(this.second, s.second);\n    }, i.prototype.hashCode = function() {\n      return (0, t.hash)(this.first, this.second);\n    }, i;\n  }();\n  st.Pair = r;\n  function n(i, s) {\n    return new r(i, s);\n  }\n  return st.make_pair = n, st;\n}\nvar Ao;\nfunction td() {\n  return Ao || (Ao = 1, function(t) {\n    var e = S && S.__extends || function() {\n      var f = function(u, h) {\n        return f = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, p) {\n          d.__proto__ = p;\n        } || function(d, p) {\n          for (var y in p)\n            Object.prototype.hasOwnProperty.call(p, y) && (d[y] = p[y]);\n        }, f(u, h);\n      };\n      return function(u, h) {\n        if (typeof h != \"function\" && h !== null)\n          throw new TypeError(\"Class extends value \" + String(h) + \" is not a constructor or null\");\n        f(u, h);\n        function d() {\n          this.constructor = u;\n        }\n        u.prototype = h === null ? Object.create(h) : (d.prototype = h.prototype, new d());\n      };\n    }(), r = S && S.__read || function(f, u) {\n      var h = typeof Symbol == \"function\" && f[Symbol.iterator];\n      if (!h)\n        return f;\n      var d = h.call(f), p, y = [], g;\n      try {\n        for (; (u === void 0 || u-- > 0) && !(p = d.next()).done; )\n          y.push(p.value);\n      } catch (v) {\n        g = { error: v };\n      } finally {\n        try {\n          p && !p.done && (h = d.return) && h.call(d);\n        } finally {\n          if (g)\n            throw g.error;\n        }\n      }\n      return y;\n    }, n = S && S.__spreadArray || function(f, u, h) {\n      if (h || arguments.length === 2)\n        for (var d = 0, p = u.length, y; d < p; d++)\n          (y || !(d in u)) && (y || (y = Array.prototype.slice.call(u, 0, d)), y[d] = u[d]);\n      return f.concat(y || Array.prototype.slice.call(u));\n    };\n    Object.defineProperty(t, \"__esModule\", { value: !0 }), t.HashSet = void 0;\n    var i = Gh(), s = Aa(), o = Qh(), a = ed(), c = Ta(), l = function(f) {\n      e(u, f);\n      function u() {\n        for (var h = [], d = 0; d < arguments.length; d++)\n          h[d] = arguments[d];\n        var p = f.call(this, function(y) {\n          return new o.SetElementList(y);\n        }) || this;\n        return s.IHashContainer.construct.apply(s.IHashContainer, n([\n          p,\n          u,\n          function(y, g) {\n            p.buckets_ = new a.SetHashBuckets(p, y, g);\n          }\n        ], r(h), !1)), p;\n      }\n      return u.prototype.clear = function() {\n        this.buckets_.clear(), f.prototype.clear.call(this);\n      }, u.prototype.swap = function(h) {\n        var d, p;\n        d = r([h.data_, this.data_], 2), this.data_ = d[0], h.data_ = d[1], o.SetElementList._Swap_associative(this.data_, h.data_), a.SetHashBuckets._Swap_source(this.buckets_, h.buckets_), p = r([h.buckets_, this.buckets_], 2), this.buckets_ = p[0], h.buckets_ = p[1];\n      }, u.prototype.find = function(h) {\n        return this.buckets_.find(h);\n      }, u.prototype.begin = function(h) {\n        return h === void 0 && (h = null), h === null ? f.prototype.begin.call(this) : this.buckets_.at(h)[0];\n      }, u.prototype.end = function(h) {\n        if (h === void 0 && (h = null), h === null)\n          return f.prototype.end.call(this);\n        var d = this.buckets_.at(h);\n        return d[d.length - 1].next();\n      }, u.prototype.rbegin = function(h) {\n        return h === void 0 && (h = null), this.end(h).reverse();\n      }, u.prototype.rend = function(h) {\n        return h === void 0 && (h = null), this.begin(h).reverse();\n      }, u.prototype.bucket_count = function() {\n        return this.buckets_.length();\n      }, u.prototype.bucket_size = function(h) {\n        return this.buckets_.at(h).length;\n      }, u.prototype.load_factor = function() {\n        return this.buckets_.load_factor();\n      }, u.prototype.hash_function = function() {\n        return this.buckets_.hash_function();\n      }, u.prototype.key_eq = function() {\n        return this.buckets_.key_eq();\n      }, u.prototype.bucket = function(h) {\n        return this.hash_function()(h) % this.buckets_.length();\n      }, u.prototype.max_load_factor = function(h) {\n        return h === void 0 && (h = null), this.buckets_.max_load_factor(h);\n      }, u.prototype.reserve = function(h) {\n        this.buckets_.reserve(h);\n      }, u.prototype.rehash = function(h) {\n        this.buckets_.rehash(h);\n      }, u.prototype._Insert_by_key = function(h) {\n        var d = this.find(h);\n        return d.equals(this.end()) === !1 ? new c.Pair(d, !1) : (this.data_.push(h), d = d.prev(), this._Handle_insert(d, d.next()), new c.Pair(d, !0));\n      }, u.prototype._Insert_by_hint = function(h, d) {\n        var p = this.find(d);\n        return p.equals(this.end()) === !0 && (p = this.data_.insert(h, d), this._Handle_insert(p, p.next())), p;\n      }, u.prototype._Handle_insert = function(h, d) {\n        for (; !h.equals(d); h = h.next())\n          this.buckets_.insert(h);\n      }, u.prototype._Handle_erase = function(h, d) {\n        for (; !h.equals(d); h = h.next())\n          this.buckets_.erase(h);\n      }, u;\n    }(i.UniqueSet);\n    t.HashSet = l, function(f) {\n      f.Iterator = o.SetElementList.Iterator, f.ReverseIterator = o.SetElementList.ReverseIterator;\n    }(l = t.HashSet || (t.HashSet = {})), t.HashSet = l;\n  }(vn)), vn;\n}\nvar En = {}, Gt = {}, Zt = {}, Co;\nfunction rd() {\n  if (Co)\n    return Zt;\n  Co = 1;\n  var t = S && S.__extends || function() {\n    var i = function(s, o) {\n      return i = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(a, c) {\n        a.__proto__ = c;\n      } || function(a, c) {\n        for (var l in c)\n          Object.prototype.hasOwnProperty.call(c, l) && (a[l] = c[l]);\n      }, i(s, o);\n    };\n    return function(s, o) {\n      if (typeof o != \"function\" && o !== null)\n        throw new TypeError(\"Class extends value \" + String(o) + \" is not a constructor or null\");\n      i(s, o);\n      function a() {\n        this.constructor = s;\n      }\n      s.prototype = o === null ? Object.create(o) : (a.prototype = o.prototype, new a());\n    };\n  }();\n  Object.defineProperty(Zt, \"__esModule\", { value: !0 }), Zt.MapContainer = void 0;\n  var e = bi(), r = vi(), n = function(i) {\n    t(s, i);\n    function s(o) {\n      var a = i.call(this) || this;\n      return a.data_ = o(a), a;\n    }\n    return s.prototype.assign = function(o, a) {\n      this.clear(), this.insert(o, a);\n    }, s.prototype.clear = function() {\n      this.data_.clear();\n    }, s.prototype.begin = function() {\n      return this.data_.begin();\n    }, s.prototype.end = function() {\n      return this.data_.end();\n    }, s.prototype.has = function(o) {\n      return !this.find(o).equals(this.end());\n    }, s.prototype.size = function() {\n      return this.data_.size();\n    }, s.prototype.push = function() {\n      for (var o = [], a = 0; a < arguments.length; a++)\n        o[a] = arguments[a];\n      var c = new r.NativeArrayIterator(o, 0), l = new r.NativeArrayIterator(o, o.length);\n      return this.insert(c, l), this.size();\n    }, s.prototype.insert = function() {\n      for (var o = [], a = 0; a < arguments.length; a++)\n        o[a] = arguments[a];\n      return o.length === 1 ? this.emplace(o[0].first, o[0].second) : o[0].next instanceof Function && o[1].next instanceof Function ? this._Insert_by_range(o[0], o[1]) : this.emplace_hint(o[0], o[1].first, o[1].second);\n    }, s.prototype.erase = function() {\n      for (var o = [], a = 0; a < arguments.length; a++)\n        o[a] = arguments[a];\n      return o.length === 1 && (!(o[0] instanceof this.end().constructor) || o[0].source() !== this) ? this._Erase_by_key(o[0]) : o.length === 1 ? this._Erase_by_range(o[0]) : this._Erase_by_range(o[0], o[1]);\n    }, s.prototype._Erase_by_range = function(o, a) {\n      a === void 0 && (a = o.next());\n      var c = this.data_.erase(o, a);\n      return this._Handle_erase(o, a), c;\n    }, s;\n  }(e.Container);\n  return Zt.MapContainer = n, Zt;\n}\nvar Io;\nfunction nd() {\n  if (Io)\n    return Gt;\n  Io = 1;\n  var t = S && S.__extends || function() {\n    var o = function(a, c) {\n      return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(l, f) {\n        l.__proto__ = f;\n      } || function(l, f) {\n        for (var u in f)\n          Object.prototype.hasOwnProperty.call(f, u) && (l[u] = f[u]);\n      }, o(a, c);\n    };\n    return function(a, c) {\n      if (typeof c != \"function\" && c !== null)\n        throw new TypeError(\"Class extends value \" + String(c) + \" is not a constructor or null\");\n      o(a, c);\n      function l() {\n        this.constructor = a;\n      }\n      a.prototype = c === null ? Object.create(c) : (l.prototype = c.prototype, new l());\n    };\n  }(), e = S && S.__read || function(o, a) {\n    var c = typeof Symbol == \"function\" && o[Symbol.iterator];\n    if (!c)\n      return o;\n    var l = c.call(o), f, u = [], h;\n    try {\n      for (; (a === void 0 || a-- > 0) && !(f = l.next()).done; )\n        u.push(f.value);\n    } catch (d) {\n      h = { error: d };\n    } finally {\n      try {\n        f && !f.done && (c = l.return) && c.call(l);\n      } finally {\n        if (h)\n          throw h.error;\n      }\n    }\n    return u;\n  }, r = S && S.__spreadArray || function(o, a, c) {\n    if (c || arguments.length === 2)\n      for (var l = 0, f = a.length, u; l < f; l++)\n        (u || !(l in a)) && (u || (u = Array.prototype.slice.call(a, 0, l)), u[l] = a[l]);\n    return o.concat(u || Array.prototype.slice.call(a));\n  };\n  Object.defineProperty(Gt, \"__esModule\", { value: !0 }), Gt.UniqueMap = void 0;\n  var n = rd(), i = Wr(), s = function(o) {\n    t(a, o);\n    function a() {\n      return o !== null && o.apply(this, arguments) || this;\n    }\n    return a.prototype.count = function(c) {\n      return this.find(c).equals(this.end()) ? 0 : 1;\n    }, a.prototype.get = function(c) {\n      var l = this.find(c);\n      if (l.equals(this.end()) === !0)\n        throw i.ErrorGenerator.key_nout_found(this, \"get\", c);\n      return l.second;\n    }, a.prototype.take = function(c, l) {\n      var f = this.find(c);\n      return f.equals(this.end()) ? this.emplace(c, l()).first.second : f.second;\n    }, a.prototype.set = function(c, l) {\n      this.insert_or_assign(c, l);\n    }, a.prototype.insert = function() {\n      for (var c = [], l = 0; l < arguments.length; l++)\n        c[l] = arguments[l];\n      return o.prototype.insert.apply(this, r([], e(c), !1));\n    }, a.prototype._Insert_by_range = function(c, l) {\n      for (var f = c; !f.equals(l); f = f.next())\n        this.emplace(f.value.first, f.value.second);\n    }, a.prototype.insert_or_assign = function() {\n      for (var c = [], l = 0; l < arguments.length; l++)\n        c[l] = arguments[l];\n      if (c.length === 2)\n        return this._Insert_or_assign_with_key_value(c[0], c[1]);\n      if (c.length === 3)\n        return this._Insert_or_assign_with_hint(c[0], c[1], c[2]);\n    }, a.prototype._Insert_or_assign_with_key_value = function(c, l) {\n      var f = this.emplace(c, l);\n      return f.second === !1 && (f.first.second = l), f;\n    }, a.prototype._Insert_or_assign_with_hint = function(c, l, f) {\n      var u = this.emplace_hint(c, l, f);\n      return u.second !== f && (u.second = f), u;\n    }, a.prototype.extract = function(c) {\n      return c instanceof this.end().constructor ? this._Extract_by_iterator(c) : this._Extract_by_key(c);\n    }, a.prototype._Extract_by_key = function(c) {\n      var l = this.find(c);\n      if (l.equals(this.end()) === !0)\n        throw i.ErrorGenerator.key_nout_found(this, \"extract\", c);\n      var f = l.value;\n      return this._Erase_by_range(l), f;\n    }, a.prototype._Extract_by_iterator = function(c) {\n      return c.equals(this.end()) === !0 ? this.end() : (this._Erase_by_range(c), c);\n    }, a.prototype._Erase_by_key = function(c) {\n      var l = this.find(c);\n      return l.equals(this.end()) === !0 ? 0 : (this._Erase_by_range(l), 1);\n    }, a.prototype.merge = function(c) {\n      for (var l = c.begin(); !l.equals(c.end()); )\n        this.has(l.first) === !1 ? (this.insert(l.value), l = c.erase(l)) : l = l.next();\n    }, a;\n  }(n.MapContainer);\n  return Gt.UniqueMap = s, Gt;\n}\nvar kn = {}, Ro;\nfunction id() {\n  return Ro || (Ro = 1, function(t) {\n    var e = S && S.__extends || function() {\n      var a = function(c, l) {\n        return a = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(f, u) {\n          f.__proto__ = u;\n        } || function(f, u) {\n          for (var h in u)\n            Object.prototype.hasOwnProperty.call(u, h) && (f[h] = u[h]);\n        }, a(c, l);\n      };\n      return function(c, l) {\n        if (typeof l != \"function\" && l !== null)\n          throw new TypeError(\"Class extends value \" + String(l) + \" is not a constructor or null\");\n        a(c, l);\n        function f() {\n          this.constructor = c;\n        }\n        c.prototype = l === null ? Object.create(l) : (f.prototype = l.prototype, new f());\n      };\n    }(), r = S && S.__read || function(a, c) {\n      var l = typeof Symbol == \"function\" && a[Symbol.iterator];\n      if (!l)\n        return a;\n      var f = l.call(a), u, h = [], d;\n      try {\n        for (; (c === void 0 || c-- > 0) && !(u = f.next()).done; )\n          h.push(u.value);\n      } catch (p) {\n        d = { error: p };\n      } finally {\n        try {\n          u && !u.done && (l = f.return) && l.call(f);\n        } finally {\n          if (d)\n            throw d.error;\n        }\n      }\n      return h;\n    };\n    Object.defineProperty(t, \"__esModule\", { value: !0 }), t.MapElementList = void 0;\n    var n = Ca(), i = mi(), s = Ia(), o = function(a) {\n      e(c, a);\n      function c(l) {\n        var f = a.call(this) || this;\n        return f.associative_ = l, f;\n      }\n      return c.prototype._Create_iterator = function(l, f, u) {\n        return c.Iterator.create(this, l, f, u);\n      }, c._Swap_associative = function(l, f) {\n        var u;\n        u = r([f.associative_, l.associative_], 2), l.associative_ = u[0], f.associative_ = u[1];\n      }, c.prototype.associative = function() {\n        return this.associative_;\n      }, c;\n    }(n.ListContainer);\n    t.MapElementList = o, function(a) {\n      var c = function(f) {\n        e(u, f);\n        function u(h, d, p, y) {\n          var g = f.call(this, d, p, y) || this;\n          return g.list_ = h, g;\n        }\n        return u.create = function(h, d, p, y) {\n          return new u(h, d, p, y);\n        }, u.prototype.reverse = function() {\n          return new l(this);\n        }, u.prototype.source = function() {\n          return this.list_.associative();\n        }, Object.defineProperty(u.prototype, \"first\", {\n          get: function() {\n            return this.value.first;\n          },\n          enumerable: !1,\n          configurable: !0\n        }), Object.defineProperty(u.prototype, \"second\", {\n          get: function() {\n            return this.value.second;\n          },\n          set: function(h) {\n            this.value.second = h;\n          },\n          enumerable: !1,\n          configurable: !0\n        }), u;\n      }(i.ListIterator);\n      a.Iterator = c;\n      var l = function(f) {\n        e(u, f);\n        function u() {\n          return f !== null && f.apply(this, arguments) || this;\n        }\n        return u.prototype._Create_neighbor = function(h) {\n          return new u(h);\n        }, Object.defineProperty(u.prototype, \"first\", {\n          get: function() {\n            return this.base_.first;\n          },\n          enumerable: !1,\n          configurable: !0\n        }), Object.defineProperty(u.prototype, \"second\", {\n          get: function() {\n            return this.base_.second;\n          },\n          set: function(h) {\n            this.base_.second = h;\n          },\n          enumerable: !1,\n          configurable: !0\n        }), u;\n      }(s.ReverseIterator);\n      a.ReverseIterator = l;\n    }(o = t.MapElementList || (t.MapElementList = {})), t.MapElementList = o;\n  }(kn)), kn;\n}\nvar Yt = {}, To;\nfunction od() {\n  if (To)\n    return Yt;\n  To = 1;\n  var t = S && S.__extends || function() {\n    var o = function(a, c) {\n      return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(l, f) {\n        l.__proto__ = f;\n      } || function(l, f) {\n        for (var u in f)\n          Object.prototype.hasOwnProperty.call(f, u) && (l[u] = f[u]);\n      }, o(a, c);\n    };\n    return function(a, c) {\n      if (typeof c != \"function\" && c !== null)\n        throw new TypeError(\"Class extends value \" + String(c) + \" is not a constructor or null\");\n      o(a, c);\n      function l() {\n        this.constructor = a;\n      }\n      a.prototype = c === null ? Object.create(c) : (l.prototype = c.prototype, new l());\n    };\n  }(), e = S && S.__read || function(o, a) {\n    var c = typeof Symbol == \"function\" && o[Symbol.iterator];\n    if (!c)\n      return o;\n    var l = c.call(o), f, u = [], h;\n    try {\n      for (; (a === void 0 || a-- > 0) && !(f = l.next()).done; )\n        u.push(f.value);\n    } catch (d) {\n      h = { error: d };\n    } finally {\n      try {\n        f && !f.done && (c = l.return) && c.call(l);\n      } finally {\n        if (h)\n          throw h.error;\n      }\n    }\n    return u;\n  }, r = S && S.__values || function(o) {\n    var a = typeof Symbol == \"function\" && Symbol.iterator, c = a && o[a], l = 0;\n    if (c)\n      return c.call(o);\n    if (o && typeof o.length == \"number\")\n      return {\n        next: function() {\n          return o && l >= o.length && (o = void 0), { value: o && o[l++], done: !o };\n        }\n      };\n    throw new TypeError(a ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n  };\n  Object.defineProperty(Yt, \"__esModule\", { value: !0 }), Yt.MapHashBuckets = void 0;\n  var n = Ra(), i = function(o) {\n    t(a, o);\n    function a(c, l, f) {\n      var u = o.call(this, s, l) || this;\n      return u.source_ = c, u.key_eq_ = f, u;\n    }\n    return a._Swap_source = function(c, l) {\n      var f;\n      f = e([l.source_, c.source_], 2), c.source_ = f[0], l.source_ = f[1];\n    }, a.prototype.key_eq = function() {\n      return this.key_eq_;\n    }, a.prototype.find = function(c) {\n      var l, f, u = this.hash_function()(c) % this.length(), h = this.at(u);\n      try {\n        for (var d = r(h), p = d.next(); !p.done; p = d.next()) {\n          var y = p.value;\n          if (this.key_eq_(y.first, c))\n            return y;\n        }\n      } catch (g) {\n        l = { error: g };\n      } finally {\n        try {\n          p && !p.done && (f = d.return) && f.call(d);\n        } finally {\n          if (l)\n            throw l.error;\n        }\n      }\n      return this.source_.end();\n    }, a;\n  }(n.HashBuckets);\n  Yt.MapHashBuckets = i;\n  function s(o) {\n    return o.first;\n  }\n  return Yt;\n}\nvar Jt = {}, Po;\nfunction sd() {\n  if (Po)\n    return Jt;\n  Po = 1, Object.defineProperty(Jt, \"__esModule\", { value: !0 }), Jt.Entry = void 0;\n  var t = wi(), e = _i(), r = function() {\n    function n(i, s) {\n      this.first = i, this.second = s;\n    }\n    return n.prototype.equals = function(i) {\n      return (0, e.equal_to)(this.first, i.first);\n    }, n.prototype.less = function(i) {\n      return (0, e.less)(this.first, i.first);\n    }, n.prototype.hashCode = function() {\n      return (0, t.hash)(this.first);\n    }, n;\n  }();\n  return Jt.Entry = r, Jt;\n}\nvar Bo;\nfunction ad() {\n  return Bo || (Bo = 1, function(t) {\n    var e = S && S.__extends || function() {\n      var u = function(h, d) {\n        return u = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(p, y) {\n          p.__proto__ = y;\n        } || function(p, y) {\n          for (var g in y)\n            Object.prototype.hasOwnProperty.call(y, g) && (p[g] = y[g]);\n        }, u(h, d);\n      };\n      return function(h, d) {\n        if (typeof d != \"function\" && d !== null)\n          throw new TypeError(\"Class extends value \" + String(d) + \" is not a constructor or null\");\n        u(h, d);\n        function p() {\n          this.constructor = h;\n        }\n        h.prototype = d === null ? Object.create(d) : (p.prototype = d.prototype, new p());\n      };\n    }(), r = S && S.__read || function(u, h) {\n      var d = typeof Symbol == \"function\" && u[Symbol.iterator];\n      if (!d)\n        return u;\n      var p = d.call(u), y, g = [], v;\n      try {\n        for (; (h === void 0 || h-- > 0) && !(y = p.next()).done; )\n          g.push(y.value);\n      } catch (_) {\n        v = { error: _ };\n      } finally {\n        try {\n          y && !y.done && (d = p.return) && d.call(p);\n        } finally {\n          if (v)\n            throw v.error;\n        }\n      }\n      return g;\n    }, n = S && S.__spreadArray || function(u, h, d) {\n      if (d || arguments.length === 2)\n        for (var p = 0, y = h.length, g; p < y; p++)\n          (g || !(p in h)) && (g || (g = Array.prototype.slice.call(h, 0, p)), g[p] = h[p]);\n      return u.concat(g || Array.prototype.slice.call(h));\n    };\n    Object.defineProperty(t, \"__esModule\", { value: !0 }), t.HashMap = void 0;\n    var i = nd(), s = Aa(), o = id(), a = od(), c = sd(), l = Ta(), f = function(u) {\n      e(h, u);\n      function h() {\n        for (var d = [], p = 0; p < arguments.length; p++)\n          d[p] = arguments[p];\n        var y = u.call(this, function(g) {\n          return new o.MapElementList(g);\n        }) || this;\n        return s.IHashContainer.construct.apply(s.IHashContainer, n([\n          y,\n          h,\n          function(g, v) {\n            y.buckets_ = new a.MapHashBuckets(y, g, v);\n          }\n        ], r(d), !1)), y;\n      }\n      return h.prototype.clear = function() {\n        this.buckets_.clear(), u.prototype.clear.call(this);\n      }, h.prototype.swap = function(d) {\n        var p, y;\n        p = r([d.data_, this.data_], 2), this.data_ = p[0], d.data_ = p[1], o.MapElementList._Swap_associative(this.data_, d.data_), a.MapHashBuckets._Swap_source(this.buckets_, d.buckets_), y = r([d.buckets_, this.buckets_], 2), this.buckets_ = y[0], d.buckets_ = y[1];\n      }, h.prototype.find = function(d) {\n        return this.buckets_.find(d);\n      }, h.prototype.begin = function(d) {\n        return d === void 0 && (d = null), d === null ? u.prototype.begin.call(this) : this.buckets_.at(d)[0];\n      }, h.prototype.end = function(d) {\n        if (d === void 0 && (d = null), d === null)\n          return u.prototype.end.call(this);\n        var p = this.buckets_.at(d);\n        return p[p.length - 1].next();\n      }, h.prototype.rbegin = function(d) {\n        return d === void 0 && (d = null), this.end(d).reverse();\n      }, h.prototype.rend = function(d) {\n        return d === void 0 && (d = null), this.begin(d).reverse();\n      }, h.prototype.bucket_count = function() {\n        return this.buckets_.length();\n      }, h.prototype.bucket_size = function(d) {\n        return this.buckets_.at(d).length;\n      }, h.prototype.load_factor = function() {\n        return this.buckets_.load_factor();\n      }, h.prototype.hash_function = function() {\n        return this.buckets_.hash_function();\n      }, h.prototype.key_eq = function() {\n        return this.buckets_.key_eq();\n      }, h.prototype.bucket = function(d) {\n        return this.hash_function()(d) % this.buckets_.length();\n      }, h.prototype.max_load_factor = function(d) {\n        return d === void 0 && (d = null), this.buckets_.max_load_factor(d);\n      }, h.prototype.reserve = function(d) {\n        this.buckets_.reserve(d);\n      }, h.prototype.rehash = function(d) {\n        this.buckets_.rehash(d);\n      }, h.prototype.emplace = function(d, p) {\n        var y = this.find(d);\n        return y.equals(this.end()) === !1 ? new l.Pair(y, !1) : (this.data_.push(new c.Entry(d, p)), y = y.prev(), this._Handle_insert(y, y.next()), new l.Pair(y, !0));\n      }, h.prototype.emplace_hint = function(d, p, y) {\n        var g = this.find(p);\n        return g.equals(this.end()) === !0 && (g = this.data_.insert(d, new c.Entry(p, y)), this._Handle_insert(g, g.next())), g;\n      }, h.prototype._Handle_insert = function(d, p) {\n        for (; !d.equals(p); d = d.next())\n          this.buckets_.insert(d);\n      }, h.prototype._Handle_erase = function(d, p) {\n        for (; !d.equals(p); d = d.next())\n          this.buckets_.erase(d);\n      }, h;\n    }(i.UniqueMap);\n    t.HashMap = f, function(u) {\n      u.Iterator = o.MapElementList.Iterator, u.ReverseIterator = o.MapElementList.ReverseIterator;\n    }(f = t.HashMap || (t.HashMap = {})), t.HashMap = f;\n  }(En)), En;\n}\nvar Lo;\nfunction cd() {\n  if (Lo)\n    return _r;\n  Lo = 1;\n  var t = S && S.__values || function(i) {\n    var s = typeof Symbol == \"function\" && i[Symbol.iterator], o = 0;\n    return s ? s.call(i) : {\n      next: function() {\n        return i && o >= i.length && (i = void 0), { value: i && i[o++], done: !i };\n      }\n    };\n  };\n  Object.defineProperty(_r, \"__esModule\", { value: !0 });\n  var e = td(), r = ad(), n = function() {\n    function i() {\n      this.listeners_ = new r.HashMap(), this.created_at_ = new Date();\n    }\n    return i.prototype.dispatchEvent = function(s) {\n      var o, a, c = this.listeners_.find(s.type);\n      if (!c.equals(this.listeners_.end())) {\n        s.target = this, s.timeStamp = new Date().getTime() - this.created_at_.getTime();\n        try {\n          for (var l = t(c.second), f = l.next(); !f.done; f = l.next()) {\n            var u = f.value;\n            u(s);\n          }\n        } catch (h) {\n          o = { error: h };\n        } finally {\n          try {\n            f && !f.done && (a = l.return) && a.call(l);\n          } finally {\n            if (o)\n              throw o.error;\n          }\n        }\n      }\n    }, i.prototype.addEventListener = function(s, o) {\n      var a = this.listeners_.find(s);\n      a.equals(this.listeners_.end()) && (a = this.listeners_.emplace(s, new e.HashSet()).first), a.second.insert(o);\n    }, i.prototype.removeEventListener = function(s, o) {\n      var a = this.listeners_.find(s);\n      a.equals(this.listeners_.end()) || (a.second.erase(o), a.second.empty() && this.listeners_.erase(a));\n    }, i;\n  }();\n  return _r.EventTarget = n, _r;\n}\nvar mr = {}, $o;\nfunction Vr() {\n  if ($o)\n    return mr;\n  $o = 1, Object.defineProperty(mr, \"__esModule\", { value: !0 });\n  var t = function() {\n    function e(r, n) {\n      this.type = r, n && Object.assign(this, n);\n    }\n    return e;\n  }();\n  return mr.Event = t, mr;\n}\nvar xr = {}, qo;\nfunction ud() {\n  if (qo)\n    return xr;\n  qo = 1;\n  var t = S && S.__extends || function() {\n    var n = function(i, s) {\n      return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(o, a) {\n        o.__proto__ = a;\n      } || function(o, a) {\n        for (var c in a)\n          a.hasOwnProperty(c) && (o[c] = a[c]);\n      }, n(i, s);\n    };\n    return function(i, s) {\n      n(i, s);\n      function o() {\n        this.constructor = i;\n      }\n      i.prototype = s === null ? Object.create(s) : (o.prototype = s.prototype, new o());\n    };\n  }();\n  Object.defineProperty(xr, \"__esModule\", { value: !0 });\n  var e = Vr(), r = function(n) {\n    t(i, n);\n    function i(s, o) {\n      return n.call(this, s, o) || this;\n    }\n    return i;\n  }(e.Event);\n  return xr.CloseEvent = r, xr;\n}\nvar Er = {}, No;\nfunction ld() {\n  if (No)\n    return Er;\n  No = 1;\n  var t = S && S.__extends || function() {\n    var n = function(i, s) {\n      return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(o, a) {\n        o.__proto__ = a;\n      } || function(o, a) {\n        for (var c in a)\n          a.hasOwnProperty(c) && (o[c] = a[c]);\n      }, n(i, s);\n    };\n    return function(i, s) {\n      n(i, s);\n      function o() {\n        this.constructor = i;\n      }\n      i.prototype = s === null ? Object.create(s) : (o.prototype = s.prototype, new o());\n    };\n  }();\n  Object.defineProperty(Er, \"__esModule\", { value: !0 });\n  var e = Vr(), r = function(n) {\n    t(i, n);\n    function i(s, o) {\n      return n.call(this, s, o) || this;\n    }\n    return i;\n  }(e.Event);\n  return Er.MessageEvent = r, Er;\n}\nvar kr = {}, Uo;\nfunction fd() {\n  if (Uo)\n    return kr;\n  Uo = 1;\n  var t = S && S.__extends || function() {\n    var n = function(i, s) {\n      return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(o, a) {\n        o.__proto__ = a;\n      } || function(o, a) {\n        for (var c in a)\n          a.hasOwnProperty(c) && (o[c] = a[c]);\n      }, n(i, s);\n    };\n    return function(i, s) {\n      n(i, s);\n      function o() {\n        this.constructor = i;\n      }\n      i.prototype = s === null ? Object.create(s) : (o.prototype = s.prototype, new o());\n    };\n  }();\n  Object.defineProperty(kr, \"__esModule\", { value: !0 });\n  var e = Vr(), r = function(n) {\n    t(i, n);\n    function i(s, o) {\n      return n.call(this, s, o) || this;\n    }\n    return i;\n  }(e.Event);\n  return kr.ErrorEvent = r, kr;\n}\nvar jo;\nfunction hd() {\n  return jo || (jo = 1, function(t) {\n    var e = S && S.__extends || function() {\n      var u = function(h, d) {\n        return u = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(p, y) {\n          p.__proto__ = y;\n        } || function(p, y) {\n          for (var g in y)\n            y.hasOwnProperty(g) && (p[g] = y[g]);\n        }, u(h, d);\n      };\n      return function(h, d) {\n        u(h, d);\n        function p() {\n          this.constructor = h;\n        }\n        h.prototype = d === null ? Object.create(d) : (p.prototype = d.prototype, new p());\n      };\n    }(), r = S && S.__assign || function() {\n      return r = Object.assign || function(u) {\n        for (var h, d = 1, p = arguments.length; d < p; d++) {\n          h = arguments[d];\n          for (var y in h)\n            Object.prototype.hasOwnProperty.call(h, y) && (u[y] = h[y]);\n        }\n        return u;\n      }, r.apply(this, arguments);\n    };\n    Object.defineProperty(t, \"__esModule\", { value: !0 });\n    var n = zh(), i = cd(), s = Vr(), o = ud(), a = ld(), c = fd(), l = function(u) {\n      e(h, u);\n      function h(d, p) {\n        var y = u.call(this) || this;\n        return y.on_ = {}, y.state_ = h.CONNECTING, y.client_ = new n.client(), y.client_.on(\"connect\", y._Handle_connect.bind(y)), y.client_.on(\"connectFailed\", y._Handle_error.bind(y)), typeof p == \"string\" && (p = [p]), y.client_.connect(d, p), y;\n      }\n      return h.prototype.close = function(d, p) {\n        this.state_ = h.CLOSING, d === void 0 ? this.connection_.sendCloseFrame() : this.connection_.sendCloseFrame(d, p, !0);\n      }, h.prototype.send = function(d) {\n        if (typeof d.valueOf() == \"string\")\n          this.connection_.sendUTF(d);\n        else {\n          var p = void 0;\n          d instanceof Buffer ? p = d : d instanceof Blob ? p = new Buffer(d, \"blob\") : d.buffer ? p = new Buffer(d.buffer) : p = new Buffer(d), this.connection_.sendBytes(p);\n        }\n      }, Object.defineProperty(h.prototype, \"url\", {\n        get: function() {\n          return this.client_.url.href;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(h.prototype, \"protocol\", {\n        get: function() {\n          return this.client_.protocols ? this.client_.protocols[0] : \"\";\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(h.prototype, \"extensions\", {\n        get: function() {\n          return this.connection_ && this.connection_.extensions ? this.connection_.extensions[0].name : \"\";\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(h.prototype, \"readyState\", {\n        get: function() {\n          return this.state_;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(h.prototype, \"bufferedAmount\", {\n        get: function() {\n          return this.connection_.bytesWaitingToFlush;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(h.prototype, \"binaryType\", {\n        get: function() {\n          return \"arraybuffer\";\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(h.prototype, \"onopen\", {\n        get: function() {\n          return this.on_.open;\n        },\n        set: function(d) {\n          this._Set_on(\"open\", d);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(h.prototype, \"onclose\", {\n        get: function() {\n          return this.on_.close;\n        },\n        set: function(d) {\n          this._Set_on(\"close\", d);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(h.prototype, \"onmessage\", {\n        get: function() {\n          return this.on_.message;\n        },\n        set: function(d) {\n          this._Set_on(\"message\", d);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(h.prototype, \"onerror\", {\n        get: function() {\n          return this.on_.error;\n        },\n        set: function(d) {\n          this._Set_on(\"error\", d);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), h.prototype._Set_on = function(d, p) {\n        this.on_[d] && this.removeEventListener(d, this.on_[d]), this.addEventListener(d, p), this.on_[d] = p;\n      }, h.prototype._Handle_connect = function(d) {\n        this.connection_ = d, this.state_ = h.OPEN, this.connection_.on(\"message\", this._Handle_message.bind(this)), this.connection_.on(\"error\", this._Handle_error.bind(this)), this.connection_.on(\"close\", this._Handle_close.bind(this));\n        var p = new s.Event(\"open\", f);\n        this.dispatchEvent(p);\n      }, h.prototype._Handle_close = function(d, p) {\n        var y = new o.CloseEvent(\"close\", r({}, f, { code: d, reason: p }));\n        this.state_ = h.CLOSED, this.dispatchEvent(y);\n      }, h.prototype._Handle_message = function(d) {\n        var p = new a.MessageEvent(\"message\", r({}, f, { data: d.binaryData ? d.binaryData : d.utf8Data }));\n        this.dispatchEvent(p);\n      }, h.prototype._Handle_error = function(d) {\n        var p = new c.ErrorEvent(\"error\", r({}, f, { error: d, message: d.message }));\n        this.state_ === h.CONNECTING && (this.state_ = h.CLOSED), this.dispatchEvent(p);\n      }, h;\n    }(i.EventTarget);\n    t.WebSocket = l, function(u) {\n      u.CONNECTING = 0, u.OPEN = 1, u.CLOSING = 2, u.CLOSED = 3;\n    }(l = t.WebSocket || (t.WebSocket = {})), t.WebSocket = l;\n    var f = {\n      bubbles: !1,\n      cancelable: !1\n    };\n  }(pn)), pn;\n}\nvar dd = cr;\ndd.is_node() && (S.WebSocket = hd().WebSocket);\nBigInt(1e3), BigInt(1e6), BigInt(1e9), BigInt(1e12);\nBigInt(\"2100000000000000000\");\nBigInt(1e11);\nconst Ho = {\n  payment_hash: 1,\n  payment_secret: 16,\n  description: 13,\n  payee: 19,\n  description_hash: 23,\n  expiry: 6,\n  min_final_cltv_expiry: 24,\n  fallback_address: 9,\n  route_hint: 3,\n  feature_bits: 5,\n  metadata: 27\n};\nfor (let t = 0, e = Object.keys(Ho); t < e.length; t++)\n  e[t], Ho[e[t]].toString();\nfunction pd(t, e) {\n  return t.created_at > e.created_at ? t : e;\n}\nvar yd = [\n  \"wss://nos.lol\",\n  \"wss://relay.nostr.band\",\n  \"wss://relay.f7z.io\",\n  \"wss://relay.damus.io\",\n  \"wss://nostr.mom\",\n  \"wss://no.str.cr\"\n], gd = class extends dt {\n  constructor(e) {\n    super();\n    I(this, \"ndk\");\n    I(this, \"zappedEvent\");\n    I(this, \"zappedUser\");\n    this.ndk = e.ndk, this.zappedEvent = e.zappedEvent, this.zappedUser = e.zappedUser || this.ndk.getUser({ hexpubkey: this.zappedEvent.pubkey });\n  }\n  async getZapEndpoint() {\n    let e, r, n, i;\n    if (this.zappedEvent) {\n      const a = (await this.zappedEvent.getMatchingTags(\"zap\"))[0];\n      if (a)\n        switch (a[2]) {\n          case \"lud06\":\n            e = a[1];\n            break;\n          case \"lud16\":\n            r = a[1];\n            break;\n          default:\n            throw new Error(`Unknown zap tag ${a}`);\n        }\n    }\n    if (this.zappedUser && !e && !r && (this.zappedUser.profile || await this.zappedUser.fetchProfile(), e = (this.zappedUser.profile || {}).lud06, r = (this.zappedUser.profile || {}).lud16), r) {\n      const [a, c] = r.split(\"@\");\n      n = `https://${c}/.well-known/lnurlp/${a}`;\n    } else if (e) {\n      const { words: a } = te.decode(e, 1e3), c = te.fromWords(a);\n      n = new TextDecoder(\"utf-8\").decode(c);\n    }\n    if (!n)\n      throw new Error(\"No zap endpoint found\");\n    const o = await (await fetch(n)).json();\n    return (o == null ? void 0 : o.allowsNostr) && ((o == null ? void 0 : o.nostrPubkey) || (o == null ? void 0 : o.nostrPubKey)) && (i = o.callback), i;\n  }\n  async createZapRequest(e, r, n, i) {\n    const s = await this.getZapEndpoint();\n    if (!s)\n      throw new Error(\"No zap endpoint found\");\n    if (!this.zappedEvent)\n      throw new Error(\"No zapped event found\");\n    const o = Ea.makeZapRequest({\n      profile: this.zappedUser.hexpubkey(),\n      event: null,\n      amount: e,\n      comment: r || \"\",\n      relays: i != null ? i : this.relays()\n    });\n    if (this.zappedEvent) {\n      const u = this.zappedEvent.tagReference();\n      u && o.tags.push(u);\n    }\n    o.tags.push([\"lnurl\", s]);\n    const a = new qe(this.ndk, o);\n    n && (a.tags = a.tags.concat(n)), await a.sign();\n    const c = await a.toNostrEvent();\n    return (await (await fetch(\n      `${s}?` + new URLSearchParams({\n        amount: e.toString(),\n        nostr: JSON.stringify(c)\n      })\n    )).json()).pr;\n  }\n  relays() {\n    var r, n;\n    let e = [];\n    return (n = (r = this.ndk) == null ? void 0 : r.pool) != null && n.relays && (e = this.ndk.pool.urls()), e.length || (e = yd), e;\n  }\n};\nfunction bd(t, e = []) {\n  const r = /(@|nostr:)(npub|nprofile|note|nevent)[a-zA-Z0-9]+/g;\n  return t = t.replace(r, (n) => {\n    try {\n      const i = n.split(/(@|nostr:)/)[2], { type: s, data: o } = we.decode(i);\n      let a;\n      switch (s) {\n        case \"npub\":\n          a = [\"p\", o];\n          break;\n        case \"nprofile\":\n          a = [\"p\", o.pubkey];\n          break;\n        case \"nevent\":\n          a = [\"e\", o.id];\n          break;\n        case \"note\":\n          a = [\"e\", o];\n          break;\n        default:\n          return n;\n      }\n      return e.find((c) => c[0] === a[0] && c[1] === a[1]) || e.push(a), `nostr:${i}`;\n    } catch {\n      return n;\n    }\n  }), { content: t, tags: e };\n}\nfunction vd() {\n  if (this.kind === void 0)\n    throw new Error(\"Kind not set\");\n  return this.kind >= 1e4 && this.kind < 2e4;\n}\nfunction wd() {\n  if (this.kind === void 0)\n    throw new Error(\"Kind not set\");\n  return this.kind >= 3e4 && this.kind < 4e4;\n}\nasync function _d() {\n  if (!this.ndk)\n    throw new Error(\"NDK not set\");\n  const t = await this.ndk.fetchEvents({\n    kinds: [3],\n    authors: [this.hexpubkey()]\n  });\n  if (t) {\n    const e = /* @__PURE__ */ new Set();\n    return t.forEach((r) => {\n      r.tags.forEach((n) => {\n        if (n[0] === \"p\")\n          try {\n            const i = we.npubEncode(n[1]);\n            e.add(i);\n          } catch {\n          }\n      });\n    }), [...e].reduce((r, n) => {\n      const i = new pe({ npub: n });\n      return i.ndk = this.ndk, r.add(i), r;\n    }, /* @__PURE__ */ new Set());\n  }\n  return /* @__PURE__ */ new Set();\n}\nfunction md(t, e) {\n  const r = JSON.parse(t.content);\n  return Object.keys(r).forEach((n) => {\n    switch (n) {\n      case \"name\":\n        e.name = r.name;\n        break;\n      case \"display_name\":\n      case \"displayName\":\n        e.displayName = r.displayName || r.display_name;\n        break;\n      case \"image\":\n      case \"picture\":\n        e.image = r.image || r.picture;\n        break;\n      case \"banner\":\n        e.banner = r.banner;\n        break;\n      case \"bio\":\n        e.bio = r.bio;\n        break;\n      case \"nip05\":\n        e.nip05 = r.nip05;\n        break;\n      case \"lud06\":\n        e.lud06 = r.lud06;\n        break;\n      case \"lud16\":\n        e.lud16 = r.lud16;\n        break;\n      case \"about\":\n        e.about = r.about;\n        break;\n      case \"zapService\":\n        e.zapService = r.zapService;\n        break;\n      case \"website\":\n        e.website = r.website;\n        break;\n      default:\n        e[n] = r[n];\n        break;\n    }\n  }), e;\n}\nvar pe = class {\n  constructor(t) {\n    I(this, \"ndk\");\n    I(this, \"profile\");\n    I(this, \"npub\", \"\");\n    I(this, \"relayUrls\", []);\n    I(this, \"follows\", _d.bind(this));\n    t.npub && (this.npub = t.npub), t.hexpubkey && (this.npub = we.npubEncode(t.hexpubkey)), t.relayUrls && (this.relayUrls = t.relayUrls);\n  }\n  static async fromNip05(t) {\n    const e = await _a.queryProfile(t);\n    if (e)\n      return new pe({\n        hexpubkey: e.pubkey,\n        relayUrls: e.relays\n      });\n  }\n  hexpubkey() {\n    return we.decode(this.npub).data;\n  }\n  async fetchProfile(t) {\n    if (!this.ndk)\n      throw new Error(\"NDK not set\");\n    this.profile || (this.profile = {});\n    const e = await this.ndk.fetchEvents(\n      {\n        kinds: [0],\n        authors: [this.hexpubkey()]\n      },\n      t\n    );\n    return e && Array.from(e).sort(\n      (n, i) => n.created_at - i.created_at\n    ).forEach((n) => {\n      try {\n        this.profile = md(n, this.profile);\n      } catch {\n      }\n    }), e;\n  }\n  async relayList() {\n    if (!this.ndk)\n      throw new Error(\"NDK not set\");\n    const t = await this.ndk.fetchEvents({\n      kinds: [10002],\n      authors: [this.hexpubkey()]\n    });\n    return t || /* @__PURE__ */ new Set();\n  }\n  tagReference() {\n    return [\"p\", this.hexpubkey()];\n  }\n  async publish() {\n    if (!this.ndk)\n      throw new Error(\"No NDK instance found\");\n    this.ndk.assertSigner(), await new qe(this.ndk, {\n      kind: 0,\n      content: JSON.stringify(this.profile)\n    }).publish();\n  }\n  async follow(t, e) {\n    if (!this.ndk)\n      throw new Error(\"No NDK instance found\");\n    if (this.ndk.assertSigner(), e || (e = await this.follows()), e.has(t))\n      return !1;\n    e.add(t);\n    const r = new qe(this.ndk, { kind: 3 });\n    for (const n of e)\n      r.tag(n);\n    return await r.publish(), !0;\n  }\n};\nasync function xd(t, e) {\n  if (!e) {\n    if (!this.ndk)\n      throw new Error(\"No signer available\");\n    await this.ndk.assertSigner(), e = this.ndk.signer;\n  }\n  if (!t) {\n    const r = this.getMatchingTags(\"p\");\n    if (r.length !== 1)\n      throw new Error(\"No recipient could be determined and no explicit recipient was provided\");\n    t = new pe({ hexpubkey: r[0][1] }), t.ndk = this.ndk;\n  }\n  this.content = await e.encrypt(t, this.content);\n}\nasync function Ed(t, e) {\n  if (!e) {\n    if (!this.ndk)\n      throw new Error(\"No signer available\");\n    await this.ndk.assertSigner(), e = this.ndk.signer;\n  }\n  t || (t = this.author), this.content = await e.decrypt(t, this.content);\n}\nfunction kd() {\n  return this.isParamReplaceable() ? we.naddrEncode({\n    kind: this.kind,\n    pubkey: this.pubkey,\n    identifier: this.replaceableDTag()\n  }) : we.noteEncode(this.tagId());\n}\nasync function Sd(t = !0, e) {\n  if (!e) {\n    if (!this.ndk)\n      throw new Error(\"No NDK instance found\");\n    this.ndk.assertSigner(), e = this.ndk.signer;\n  }\n  if (!e)\n    throw new Error(\"No signer available\");\n  const r = await e.user(), n = new qe(this.ndk, {\n    kind: Od(this),\n    content: \"\",\n    pubkey: r.hexpubkey()\n  });\n  return n.tag(this), n.kind === 16 && n.tags.push([\"k\", `${this.kind}`]), await n.sign(e), t && await n.publish(), n;\n}\nfunction Od(t) {\n  return t.kind === 1 ? 6 : 16;\n}\nvar qe = class extends dt {\n  constructor(e, r) {\n    super();\n    I(this, \"ndk\");\n    I(this, \"created_at\");\n    I(this, \"content\", \"\");\n    I(this, \"tags\", []);\n    I(this, \"kind\");\n    I(this, \"id\", \"\");\n    I(this, \"sig\");\n    I(this, \"pubkey\", \"\");\n    I(this, \"relay\");\n    I(this, \"isReplaceable\", vd.bind(this));\n    I(this, \"isParamReplaceable\", wd.bind(this));\n    I(this, \"encode\", kd.bind(this));\n    I(this, \"encrypt\", xd.bind(this));\n    I(this, \"decrypt\", Ed.bind(this));\n    I(this, \"repost\", Sd.bind(this));\n    this.ndk = e, this.created_at = r == null ? void 0 : r.created_at, this.content = (r == null ? void 0 : r.content) || \"\", this.tags = (r == null ? void 0 : r.tags) || [], this.id = (r == null ? void 0 : r.id) || \"\", this.sig = r == null ? void 0 : r.sig, this.pubkey = (r == null ? void 0 : r.pubkey) || \"\", this.kind = r == null ? void 0 : r.kind;\n  }\n  rawEvent() {\n    return {\n      created_at: this.created_at,\n      content: this.content,\n      tags: this.tags,\n      kind: this.kind,\n      pubkey: this.pubkey,\n      id: this.id,\n      sig: this.sig\n    };\n  }\n  set author(e) {\n    this.pubkey = e.hexpubkey();\n  }\n  get author() {\n    const e = new pe({ hexpubkey: this.pubkey });\n    return e.ndk = this.ndk, e;\n  }\n  tag(e, r) {\n    const n = e.tagReference();\n    if (r && n.push(r), this.tags.push(n), e instanceof qe) {\n      const i = e.author;\n      i && this.pubkey !== i.hexpubkey() && this.tag(i);\n      for (const s of e.getMatchingTags(\"p\"))\n        s[1] !== this.pubkey && (this.tags.find((o) => o[0] === \"p\" && o[1] === s[1]) || this.tags.push([\"p\", s[1]]));\n    }\n  }\n  async toNostrEvent(e) {\n    var s, o;\n    if (!e && this.pubkey === \"\") {\n      const a = await ((o = (s = this.ndk) == null ? void 0 : s.signer) == null ? void 0 : o.user());\n      this.pubkey = (a == null ? void 0 : a.hexpubkey()) || \"\";\n    }\n    this.created_at || (this.created_at = Math.floor(Date.now() / 1e3));\n    const r = this.rawEvent(), { content: n, tags: i } = this.generateTags();\n    r.content = n || \"\", r.tags = i;\n    try {\n      this.id = Hr(r);\n    } catch {\n    }\n    return this.id && (r.id = this.id), this.sig && (r.sig = this.sig), r;\n  }\n  getMatchingTags(e) {\n    return this.tags.filter((r) => r[0] === e);\n  }\n  tagValue(e) {\n    const r = this.getMatchingTags(e);\n    if (r.length !== 0)\n      return r[0][1];\n  }\n  removeTag(e) {\n    this.tags = this.tags.filter((r) => r[0] !== e);\n  }\n  async sign(e) {\n    var n;\n    e || ((n = this.ndk) == null || n.assertSigner(), e = this.ndk.signer), await this.generateTags(), this.isReplaceable() && (this.created_at = Math.floor(Date.now() / 1e3));\n    const r = await this.toNostrEvent();\n    return this.sig = await e.sign(r), this.sig;\n  }\n  async publish(e, r) {\n    if (this.sig || await this.sign(), !this.ndk)\n      throw new Error(\"NDKEvent must be associated with an NDK instance to publish\");\n    return this.ndk.publish(this, e, r);\n  }\n  generateTags() {\n    let e = [];\n    const r = bd(this.content, this.tags), n = r.content;\n    if (e = r.tags, this.kind && this.kind >= 3e4 && this.kind <= 4e4 && !this.getMatchingTags(\"d\")[0]) {\n      const s = [...Array(16)].map(() => Math.random().toString(36)[2]).join(\"\");\n      e.push([\"d\", s]);\n    }\n    return { content: n || \"\", tags: e };\n  }\n  replaceableDTag() {\n    if (this.kind && this.kind >= 3e4 && this.kind <= 4e4) {\n      const e = this.getMatchingTags(\"d\")[0];\n      return e ? e[1] : \"\";\n    }\n    throw new Error(\"Event is not a parameterized replaceable event\");\n  }\n  tagId() {\n    if (this.kind && this.kind >= 3e4 && this.kind <= 4e4) {\n      const e = this.replaceableDTag();\n      return `${this.kind}:${this.pubkey}:${e}`;\n    }\n    return this.id;\n  }\n  tagReference() {\n    return this.isParamReplaceable() ? [\"a\", this.tagId()] : [\"e\", this.tagId()];\n  }\n  filter() {\n    return this.isParamReplaceable() ? { \"#a\": [this.tagId()] } : { \"#e\": [this.tagId()] };\n  }\n  async zap(e, r, n) {\n    if (!this.ndk)\n      throw new Error(\"No NDK instance found\");\n    return this.ndk.assertSigner(), await new gd({\n      ndk: this.ndk,\n      zappedEvent: this\n    }).createZapRequest(e, r, n);\n  }\n  async delete(e) {\n    if (!this.ndk)\n      throw new Error(\"No NDK instance found\");\n    this.ndk.assertSigner();\n    const r = new qe(this.ndk, {\n      kind: 5,\n      content: e || \"\"\n    });\n    return r.tag(this), await r.publish(), r;\n  }\n}, Ad = class extends dt {\n  constructor(e) {\n    super();\n    I(this, \"url\");\n    I(this, \"scores\");\n    I(this, \"relay\");\n    I(this, \"_status\");\n    I(this, \"connectedAt\");\n    I(this, \"_connectionStats\", { attempts: 0, success: 0, durations: [] });\n    I(this, \"complaining\", !1);\n    I(this, \"debug\");\n    I(this, \"activeSubscriptions\", /* @__PURE__ */ new Set());\n    I(this, \"updateConnectionStats\", {\n      connected: () => {\n        this._connectionStats.success++, this._connectionStats.connectedAt = Date.now();\n      },\n      disconnected: () => {\n        this._connectionStats.connectedAt && (this._connectionStats.durations.push(\n          Date.now() - this._connectionStats.connectedAt\n        ), this._connectionStats.durations.length > 100 && this._connectionStats.durations.shift()), this._connectionStats.connectedAt = void 0;\n      },\n      attempt: () => {\n        this._connectionStats.attempts++;\n      }\n    });\n    this.url = e, this.relay = Af(e), this.scores = /* @__PURE__ */ new Map(), this._status = 3, this.debug = Mn(`ndk:relay:${e}`), this.relay.on(\"connect\", () => {\n      this.updateConnectionStats.connected(), this._status = 1, this.emit(\"connect\");\n    }), this.relay.on(\"disconnect\", () => {\n      this.updateConnectionStats.disconnected(), this._status === 1 && (this._status = 3, this.handleReconnection()), this.emit(\"disconnect\");\n    }), this.relay.on(\"notice\", (r) => this.handleNotice(r));\n  }\n  isFlapping() {\n    const e = this._connectionStats.durations;\n    if (e.length < 10)\n      return !1;\n    const n = e.reduce((a, c) => a + c, 0) / e.length, i = e.map((a) => Math.pow(a - n, 2)).reduce((a, c) => a + c, 0) / e.length;\n    return Math.sqrt(i) < 1e3;\n  }\n  handleReconnection() {\n    this.isFlapping() && (this.emit(\"flapping\", this, this._connectionStats), this._status = 5), this.connectedAt && Date.now() - this.connectedAt < 5e3 ? setTimeout(() => this.connect(), 6e4) : this.connect();\n  }\n  get status() {\n    return this._status;\n  }\n  async connect() {\n    try {\n      this.updateConnectionStats.attempt(), this._status = 0, await this.relay.connect();\n    } catch (e) {\n      throw this.debug(\"Failed to connect\", e), this._status = 3, e;\n    }\n  }\n  disconnect() {\n    this._status = 2, this.relay.close();\n  }\n  async handleNotice(e) {\n    (e.includes(\"oo many\") || e.includes(\"aximum\")) && (this.disconnect(), setTimeout(() => this.connect(), 2e3), this.debug(this.relay.url, \"Relay complaining?\", e)), this.emit(\"notice\", this, e);\n  }\n  subscribe(e) {\n    const { filter: r } = e, n = this.relay.sub([r], {\n      id: e.subId\n    });\n    this.debug(`Subscribed to ${JSON.stringify(r)}`), n.on(\"event\", (s) => {\n      const o = new qe(void 0, s);\n      o.relay = this, e.eventReceived(o, this);\n    }), n.on(\"eose\", () => {\n      e.eoseReceived(this);\n    });\n    const i = n.unsub;\n    return n.unsub = () => {\n      this.debug(`Unsubscribing from ${JSON.stringify(r)}`), this.activeSubscriptions.delete(e), i();\n    }, this.activeSubscriptions.add(e), e.on(\"close\", () => {\n      this.activeSubscriptions.delete(e);\n    }), n;\n  }\n  async publish(e, r = 2500) {\n    return this.status === 1 ? this.publishEvent(e, r) : (this.once(\"connect\", () => {\n      this.publishEvent(e, r);\n    }), !0);\n  }\n  async publishEvent(e, r) {\n    const n = await e.toNostrEvent(), i = this.relay.publish(n);\n    let s;\n    const o = new Promise((c, l) => {\n      i.on(\"failed\", (f) => {\n        clearTimeout(s), this.debug(\"Publish failed\", f, e.id), this.emit(\"publish:failed\", e, f), l(f);\n      }), i.on(\"ok\", () => {\n        clearTimeout(s), this.emit(\"published\", e), c(!0);\n      });\n    });\n    if (!r)\n      return o;\n    const a = new Promise((c, l) => {\n      s = setTimeout(() => {\n        this.debug(\"Publish timed out\", e.rawEvent()), this.emit(\"publish:failed\", e, \"Timeout\"), l(new Error(\"Publish operation timed out\"));\n      }, r);\n    });\n    return Promise.race([o, a]);\n  }\n  scoreSlowerEvent(e) {\n  }\n  get connectionStats() {\n    return this._connectionStats;\n  }\n  tagReference(e) {\n    const r = [\"r\", this.relay.url];\n    return e && r.push(e), r;\n  }\n}, Cd = class extends dt {\n  constructor(e = [], r) {\n    super();\n    I(this, \"relays\", /* @__PURE__ */ new Map());\n    I(this, \"debug\");\n    this.debug = r.debug.extend(\"pool\");\n    for (const n of e) {\n      const i = new Ad(n);\n      i.on(\"notice\", (s, o) => this.emit(\"notice\", s, o)), i.on(\"connect\", () => this.handleRelayConnect(n)), i.on(\"disconnect\", () => this.emit(\"relay:disconnect\", i)), i.on(\"flapping\", () => this.handleFlapping(i)), this.relays.set(n, i);\n    }\n  }\n  handleRelayConnect(e) {\n    this.debug(`Relay ${e} connected`), this.emit(\"relay:connect\", this.relays.get(e)), this.stats().connected === this.relays.size && this.emit(\"connect\");\n  }\n  async connect(e) {\n    const r = [];\n    this.debug(\n      `Connecting to ${this.relays.size} relays${e ? `, timeout ${e}...` : \"\"}`\n    );\n    for (const n of this.relays.values())\n      if (e) {\n        const i = new Promise((s, o) => {\n          setTimeout(() => o(`Timed out after ${e}ms`), e);\n        });\n        r.push(\n          Promise.race([n.connect(), i]).catch((s) => {\n            this.debug(`Failed to connect to relay ${n.url}: ${s}`);\n          })\n        );\n      } else\n        r.push(n.connect());\n    e && setTimeout(() => {\n      const n = this.stats().connected === this.relays.size, i = this.stats().connected > 0;\n      !n && i && this.emit(\"connect\");\n    }, e), await Promise.all(r);\n  }\n  handleFlapping(e) {\n    this.debug(`Relay ${e.url} is flapping`), this.relays.delete(e.url), this.emit(\"flapping\", e);\n  }\n  size() {\n    return this.relays.size;\n  }\n  stats() {\n    const e = {\n      total: 0,\n      connected: 0,\n      disconnected: 0,\n      connecting: 0\n    };\n    for (const r of this.relays.values())\n      e.total++, r.status === 1 ? e.connected++ : r.status === 3 ? e.disconnected++ : r.status === 0 && e.connecting++;\n    return e;\n  }\n  urls() {\n    return Array.from(this.relays.keys());\n  }\n};\nfunction Id(t) {\n  return !!(Rd(t.filter) && Td(t));\n}\nfunction Rd(t) {\n  return !!t.ids;\n}\nfunction Td(t) {\n  const e = t.filter.ids;\n  return !!e && e.length === t.eventFirstSeen.size;\n}\nvar Pd = {\n  closeOnEose: !0,\n  cacheUsage: \"CACHE_FIRST\",\n  groupable: !0,\n  groupableDelay: 100\n}, Pa = class extends dt {\n  constructor(e, r, n, i, s) {\n    super();\n    I(this, \"subId\");\n    I(this, \"filter\");\n    I(this, \"opts\");\n    I(this, \"relaySet\");\n    I(this, \"ndk\");\n    I(this, \"relaySubscriptions\");\n    I(this, \"debug\");\n    I(this, \"eventFirstSeen\", /* @__PURE__ */ new Map());\n    I(this, \"eosesSeen\", /* @__PURE__ */ new Set());\n    I(this, \"eventsPerRelay\", /* @__PURE__ */ new Map());\n    I(this, \"eoseTimeout\");\n    if (this.ndk = e, this.opts = { ...Pd, ...n || {} }, this.subId = s || (n == null ? void 0 : n.subId) || qd(r), this.filter = r, this.relaySet = i, this.relaySubscriptions = /* @__PURE__ */ new Map(), this.debug = e.debug.extend(`subscription:${this.subId}`), this.opts.cacheUsage === \"ONLY_CACHE\" && !this.opts.closeOnEose)\n      throw new Error(\"Cannot use cache-only options with a persistent subscription\");\n  }\n  groupableId() {\n    var i, s;\n    if (!((i = this.opts) != null && i.groupable))\n      return null;\n    const e = (((s = this.filter.kinds) == null ? void 0 : s.length) || 0) > 0, r = !this.filter.since && !this.filter.until, n = !this.filter.limit;\n    if (e && r && n) {\n      let o = this.filter.kinds.join(\",\");\n      const a = Object.keys(this.filter || {}).sort().join(\"-\");\n      return o += `-${a}`, o;\n    }\n    return null;\n  }\n  shouldQueryCache() {\n    var e;\n    return ((e = this.opts) == null ? void 0 : e.cacheUsage) !== \"ONLY_RELAY\";\n  }\n  shouldQueryRelays() {\n    var e;\n    return ((e = this.opts) == null ? void 0 : e.cacheUsage) !== \"ONLY_CACHE\";\n  }\n  shouldWaitForCache() {\n    var e;\n    return this.opts.closeOnEose && !!((e = this.ndk.cacheAdapter) != null && e.locking) && this.shouldQueryRelays() && this.opts.cacheUsage !== \"PARALLEL\";\n  }\n  async start() {\n    let e;\n    if (this.shouldQueryCache() && (e = this.startWithCache(), this.shouldWaitForCache() && (await e, Id(this)))) {\n      this.debug(\"cache hit, fully filled: skipping relay query\"), this.emit(\"eose\", this);\n      return;\n    }\n    this.shouldQueryRelays() && this.startWithRelaySet();\n  }\n  stop() {\n    this.relaySubscriptions.forEach((e) => e.unsub()), this.relaySubscriptions.clear(), this.emit(\"close\", this);\n  }\n  async startWithCache() {\n    var e;\n    if ((e = this.ndk.cacheAdapter) != null && e.query) {\n      const r = this.ndk.cacheAdapter.query(this);\n      this.ndk.cacheAdapter.locking && await r;\n    }\n  }\n  startWithRelaySet() {\n    this.relaySet || (this.relaySet = Ud(this.ndk, this.filter)), this.relaySet && this.relaySet.subscribe(this);\n  }\n  eventReceived(e, r, n = !1) {\n    if (!n && r) {\n      let i = this.eventsPerRelay.get(r);\n      if (i || (i = /* @__PURE__ */ new Set(), this.eventsPerRelay.set(r, i)), i.add(e.id), this.eventFirstSeen.has(e.id)) {\n        const o = Date.now() - (this.eventFirstSeen.get(e.id) || 0);\n        r.scoreSlowerEvent(o), this.emit(\"event:dup\", e, r, o, this);\n        return;\n      }\n      this.ndk.cacheAdapter && this.ndk.cacheAdapter.setEvent(e, this.filter), this.eventFirstSeen.set(`${e.id}`, Date.now());\n    } else\n      this.eventFirstSeen.set(`${e.id}`, 0);\n    this.emit(\"event\", e, r, this);\n  }\n  eoseReceived(e) {\n    var n, i, s;\n    (n = this.opts) != null && n.closeOnEose && ((i = this.relaySubscriptions.get(e)) == null || i.unsub(), this.relaySubscriptions.delete(e), this.relaySubscriptions.size === 0 && this.emit(\"close\", this)), this.eosesSeen.add(e), this.eosesSeen.size === ((s = this.relaySet) == null ? void 0 : s.size()) ? this.emit(\"eose\") : (this.eoseTimeout && clearTimeout(this.eoseTimeout), this.eoseTimeout = setTimeout(() => {\n      this.emit(\"eose\");\n    }, 500));\n  }\n}, Bd = class extends Pa {\n  constructor(e, r) {\n    const n = e.debug.extend(\"subscription-group\"), i = Ld(r.map((s) => s.filter));\n    super(\n      e,\n      i,\n      r[0].opts,\n      r[0].relaySet\n    );\n    I(this, \"subscriptions\");\n    this.subscriptions = r, n(\"merged filters\", {\n      count: r.length,\n      mergedFilters: this.filter\n    }), this.on(\"event\", this.forwardEvent), this.on(\"event:dup\", this.forwardEventDup), this.on(\"eose\", this.forwardEose), this.on(\"close\", this.forwardClose);\n  }\n  isEventForSubscription(e, r) {\n    const { filter: n } = r;\n    return n ? ya(n, e.rawEvent()) : !1;\n  }\n  forwardEvent(e, r) {\n    for (const n of this.subscriptions)\n      !this.isEventForSubscription(e, n) || n.emit(\"event\", e, r, n);\n  }\n  forwardEventDup(e, r, n) {\n    for (const i of this.subscriptions)\n      !this.isEventForSubscription(e, i) || i.emit(\"event:dup\", e, r, n, i);\n  }\n  forwardEose() {\n    for (const e of this.subscriptions)\n      e.emit(\"eose\", e);\n  }\n  forwardClose() {\n    for (const e of this.subscriptions)\n      e.emit(\"close\", e);\n  }\n};\nfunction Ld(t) {\n  const e = {};\n  return t.forEach((r) => {\n    Object.entries(r).forEach(([n, i]) => {\n      Array.isArray(i) ? e[n] === void 0 ? e[n] = [...i] : e[n] = Array.from(/* @__PURE__ */ new Set([...e[n], ...i])) : e[n] = i;\n    });\n  }), e;\n}\nfunction $d(t) {\n  let e;\n  try {\n    switch (e = we.decode(t), e.type) {\n      case \"nevent\":\n        return { ids: [e.data.id] };\n      case \"note\":\n        return { ids: [e.data] };\n      case \"naddr\":\n        return {\n          authors: [e.data.pubkey],\n          \"#d\": [e.data.identifier],\n          kinds: [e.data.kind]\n        };\n    }\n  } catch {\n  }\n  return { ids: [t] };\n}\nfunction qd(t) {\n  const e = Object.keys(t) || [], r = [];\n  for (const n of e)\n    if (n === \"kinds\") {\n      const i = [n, t.kinds.join(\",\")];\n      r.push(i.join(\":\"));\n    } else\n      r.push(n);\n  return r.push(Math.floor(Math.random() * 999999999).toString()), r.join(\"-\");\n}\nvar Gr = class {\n  constructor(t, e) {\n    I(this, \"relays\");\n    I(this, \"debug\");\n    I(this, \"ndk\");\n    this.relays = t, this.ndk = e, this.debug = e.debug.extend(\"relayset\");\n  }\n  static fromRelayUrls(t, e) {\n    const r = /* @__PURE__ */ new Set();\n    for (const n of t) {\n      const i = e.pool.relays.get(n);\n      i && r.add(i);\n    }\n    return new Gr(new Set(r), e);\n  }\n  subscribeOnRelay(t, e) {\n    const r = t.subscribe(e);\n    e.relaySubscriptions.set(t, r);\n  }\n  getId() {\n    const e = Array.from(this.relays).map((r) => r.url).sort().join(\",\");\n    return ni(jr(e));\n  }\n  subscribe(t) {\n    const e = t.groupableId(), r = `${this.getId()}:${e}`;\n    if (!e)\n      return this.executeSubscription(t), t;\n    const n = this.ndk.delayedSubscriptions.get(r);\n    return n ? n.push(t) : (setTimeout(() => {\n      this.executeDelayedSubscription(r);\n    }, t.opts.groupableDelay), this.ndk.delayedSubscriptions.set(r, [t])), t;\n  }\n  executeDelayedSubscription(t) {\n    const e = this.ndk.delayedSubscriptions.get(t);\n    this.ndk.delayedSubscriptions.delete(t), e && (e.length > 1 ? this.executeSubscriptions(e) : this.executeSubscription(e[0]));\n  }\n  executeSubscriptions(t) {\n    const e = t[0].ndk, r = new Bd(e, t);\n    this.executeSubscription(r);\n  }\n  executeSubscription(t) {\n    this.debug(\"subscribing\", { filter: t.filter });\n    for (const e of this.relays)\n      if (e.status === 1)\n        this.subscribeOnRelay(e, t);\n      else {\n        const r = () => {\n          this.debug(\"new relay coming online for active subscription\", {\n            relay: e.url,\n            filter: t.filter\n          }), this.subscribeOnRelay(e, t);\n        };\n        e.once(\"connect\", r), t.once(\"close\", () => {\n          e.removeListener(\"connect\", r);\n        });\n      }\n    return t;\n  }\n  async publish(t, e) {\n    const r = /* @__PURE__ */ new Set(), n = Array.from(this.relays).map((i) => new Promise((s) => {\n      i.publish(t, e).then(() => {\n        r.add(i), s();\n      }).catch((o) => {\n        this.debug(\"error publishing to relay\", { relay: i.url, err: o }), s();\n      });\n    }));\n    if (await Promise.all(n), r.size === 0)\n      throw new Error(\"No relay was able to receive the event\");\n    return r;\n  }\n  size() {\n    return this.relays.size;\n  }\n};\nfunction Nd(t, e) {\n  var n;\n  const r = /* @__PURE__ */ new Set();\n  return (n = t.pool) == null || n.relays.forEach((i) => r.add(i)), new Gr(r, t);\n}\nfunction Ud(t, e) {\n  var n;\n  const r = /* @__PURE__ */ new Set();\n  return (n = t.pool) == null || n.relays.forEach((i) => {\n    i.complaining ? t.debug(`Relay ${i.url} is complaining, not adding to set`) : r.add(i);\n  }), new Gr(r, t);\n}\nvar jd = class {\n  constructor() {\n    I(this, \"_userPromise\");\n    I(this, \"nip04Queue\", []);\n    I(this, \"nip04Processing\", !1);\n    I(this, \"debug\");\n    if (!window.nostr)\n      throw new Error(\"NIP-07 extension not available\");\n    this.debug = Mn(\"ndk:nip07\");\n  }\n  async blockUntilReady() {\n    var e;\n    const t = await ((e = window.nostr) == null ? void 0 : e.getPublicKey());\n    if (!t)\n      throw new Error(\"User rejected access\");\n    return new pe({ hexpubkey: t });\n  }\n  async user() {\n    return this._userPromise || (this._userPromise = this.blockUntilReady()), this._userPromise;\n  }\n  async sign(t) {\n    if (!window.nostr)\n      throw new Error(\"NIP-07 extension not available\");\n    return (await window.nostr.signEvent(t)).sig;\n  }\n  async encrypt(t, e) {\n    if (!window.nostr)\n      throw new Error(\"NIP-07 extension not available\");\n    const r = t.hexpubkey();\n    return this.queueNip04(\"encrypt\", r, e);\n  }\n  async decrypt(t, e) {\n    if (!window.nostr)\n      throw new Error(\"NIP-07 extension not available\");\n    const r = t.hexpubkey();\n    return this.queueNip04(\"decrypt\", r, e);\n  }\n  async queueNip04(t, e, r) {\n    return new Promise((n, i) => {\n      this.nip04Queue.push({ type: t, counterpartyHexpubkey: e, value: r, resolve: n, reject: i }), this.nip04Processing || this.processNip04Queue();\n    });\n  }\n  async processNip04Queue(t, e = 0) {\n    if (!t && this.nip04Queue.length === 0) {\n      this.nip04Processing = !1;\n      return;\n    }\n    this.nip04Processing = !0;\n    const { type: r, counterpartyHexpubkey: n, value: i, resolve: s, reject: o } = t || this.nip04Queue.shift();\n    this.debug(\"Processing encryption queue item\", { type: r, counterpartyHexpubkey: n, value: i });\n    try {\n      let a;\n      r === \"encrypt\" ? a = await window.nostr.nip04.encrypt(n, i) : a = await window.nostr.nip04.decrypt(n, i), s(a);\n    } catch (a) {\n      if (a.message && a.message.includes(\"call already executing\") && e < 5) {\n        this.debug(\"Retrying encryption queue item\", { type: r, counterpartyHexpubkey: n, value: i, retries: e }), setTimeout(() => {\n          this.processNip04Queue(t, e + 1);\n        }, 50 * e);\n        return;\n      }\n      o(a);\n    }\n    this.processNip04Queue();\n  }\n}, Hd = class extends dt {\n  constructor(e, r, n) {\n    super();\n    I(this, \"ndk\");\n    I(this, \"signer\");\n    I(this, \"debug\");\n    this.ndk = e, this.signer = r, this.debug = n.extend(\"rpc\");\n  }\n  async subscribe(e) {\n    const r = this.ndk.subscribe(e, { closeOnEose: !1 });\n    return r.on(\"event\", async (n) => {\n      try {\n        const i = await this.parseEvent(n);\n        i.method ? this.emit(\"request\", i) : this.emit(`response-${i.id}`, i);\n      } catch (i) {\n        this.debug(\"error parsing event\", i, n);\n      }\n    }), new Promise((n, i) => {\n      r.on(\"eose\", () => n(r));\n    });\n  }\n  async parseEvent(e) {\n    const r = this.ndk.getUser({ hexpubkey: e.pubkey });\n    r.ndk = this.ndk;\n    const n = await this.signer.decrypt(r, e.content), i = JSON.parse(n), { id: s, method: o, params: a, result: c, error: l } = i;\n    return o ? { id: s, pubkey: e.pubkey, method: o, params: a, event: e } : { id: s, result: c, error: l, event: e };\n  }\n  async sendResponse(e, r, n, i = 24133, s) {\n    const o = { id: e, result: n };\n    s && (o.error = s);\n    const a = await this.signer.user(), c = this.ndk.getUser({ hexpubkey: r }), l = new qe(this.ndk, {\n      kind: i,\n      content: JSON.stringify(o),\n      tags: [[\"p\", r]],\n      pubkey: a.hexpubkey()\n    });\n    l.content = await this.signer.encrypt(c, l.content), await l.sign(this.signer), await this.ndk.publish(l);\n  }\n  async sendRequest(e, r, n = [], i = 24133, s) {\n    const o = Math.random().toString(36).substring(7), a = await this.signer.user(), c = this.ndk.getUser({ hexpubkey: e }), l = { id: o, method: r, params: n }, f = new Promise((h) => {\n      s && this.once(`response-${o}`, s);\n    }), u = new qe(this.ndk, {\n      kind: i,\n      content: JSON.stringify(l),\n      tags: [[\"p\", e]],\n      pubkey: a.hexpubkey()\n    });\n    return u.content = await this.signer.encrypt(c, u.content), await u.sign(this.signer), this.debug(\"sending request to\", e), await this.ndk.publish(u), f;\n  }\n}, Md = class {\n  constructor(t, e, r) {\n    I(this, \"ndk\");\n    I(this, \"remoteUser\");\n    I(this, \"remotePubkey\");\n    I(this, \"token\");\n    I(this, \"localSigner\");\n    I(this, \"rpc\");\n    I(this, \"debug\");\n    let n, i;\n    if (e.includes(\"#\")) {\n      const s = e.split(\"#\");\n      n = new pe({ npub: s[0] }).hexpubkey(), i = s[1];\n    } else\n      e.startsWith(\"npub\") ? n = new pe({ npub: e }).hexpubkey() : n = e;\n    this.ndk = t, this.remotePubkey = n, this.token = i, this.debug = t.debug.extend(\"nip46:signer\"), this.remoteUser = new pe({ hexpubkey: n }), r ? this.localSigner = r : this.localSigner = or.generate(), this.rpc = new Hd(t, this.localSigner, this.debug);\n  }\n  async user() {\n    return this.remoteUser;\n  }\n  async blockUntilReady() {\n    const t = await this.localSigner.user(), e = this.ndk.getUser({ npub: t.npub });\n    return await this.rpc.subscribe({\n      kinds: [24133],\n      \"#p\": [t.hexpubkey()]\n    }), new Promise((r, n) => {\n      setTimeout(() => {\n        const i = [t.hexpubkey()];\n        this.token && i.push(this.token), this.rpc.sendRequest(\n          this.remotePubkey,\n          \"connect\",\n          i,\n          24133,\n          (s) => {\n            s.result === \"ack\" ? r(e) : n(s.error);\n          }\n        );\n      }, 100);\n    });\n  }\n  async encrypt(t, e) {\n    return this.debug(\"asking for encryption\"), new Promise((n, i) => {\n      this.rpc.sendRequest(\n        this.remotePubkey,\n        \"nip04_encrypt\",\n        [t.hexpubkey(), e],\n        24133,\n        (s) => {\n          s.error ? i(s.error) : n(s.result);\n        }\n      );\n    });\n  }\n  async decrypt(t, e) {\n    return this.debug(\"asking for decryption\"), new Promise((n, i) => {\n      this.rpc.sendRequest(\n        this.remotePubkey,\n        \"nip04_decrypt\",\n        [t.hexpubkey(), e],\n        24133,\n        (s) => {\n          if (s.error)\n            i(s.error);\n          else {\n            const o = JSON.parse(s.result);\n            n(o[0]);\n          }\n        }\n      );\n    });\n  }\n  async sign(t) {\n    return this.debug(\"asking for a signature\"), new Promise((r, n) => {\n      this.rpc.sendRequest(\n        this.remotePubkey,\n        \"sign_event\",\n        [JSON.stringify(t)],\n        24133,\n        (i) => {\n          if (this.debug(\"got a response\", i), i.error)\n            n(i.error);\n          else {\n            const s = JSON.parse(i.result);\n            r(s.sig);\n          }\n        }\n      );\n    });\n  }\n}, or = class {\n  constructor(t) {\n    I(this, \"_user\");\n    I(this, \"privateKey\");\n    t && (this.privateKey = t, this._user = new pe({ hexpubkey: li(this.privateKey) }));\n  }\n  static generate() {\n    const t = yf();\n    return new or(t);\n  }\n  async blockUntilReady() {\n    if (!this._user)\n      throw new Error(\"NDKUser not initialized\");\n    return this._user;\n  }\n  async user() {\n    return await this.blockUntilReady(), this._user;\n  }\n  async sign(t) {\n    if (!this.privateKey)\n      throw Error(\"Attempted to sign without a private key\");\n    return pa(t, this.privateKey);\n  }\n  async encrypt(t, e) {\n    if (!this.privateKey)\n      throw Error(\"Attempted to encrypt without a private key\");\n    const r = t.hexpubkey();\n    return await Un.encrypt(this.privateKey, r, e);\n  }\n  async decrypt(t, e) {\n    if (!this.privateKey)\n      throw Error(\"Attempted to decrypt without a private key\");\n    const r = t.hexpubkey();\n    return await Un.decrypt(this.privateKey, r, e);\n  }\n}, Dd = class extends dt {\n  constructor(e = {}) {\n    super();\n    I(this, \"pool\");\n    I(this, \"signer\");\n    I(this, \"cacheAdapter\");\n    I(this, \"debug\");\n    I(this, \"devWriteRelaySet\");\n    I(this, \"delayedSubscriptions\");\n    this.debug = e.debug || Mn(\"ndk\"), this.pool = new Cd(e.explicitRelayUrls || [], this), this.signer = e.signer, this.cacheAdapter = e.cacheAdapter, this.delayedSubscriptions = /* @__PURE__ */ new Map(), e.devWriteRelayUrls && (this.devWriteRelaySet = Gr.fromRelayUrls(e.devWriteRelayUrls, this));\n  }\n  toJSON() {\n    return { relayCount: this.pool.relays.size }.toString();\n  }\n  async connect(e) {\n    return this.debug(\"Connecting to relays\", { timeoutMs: e }), this.pool.connect(e);\n  }\n  getUser(e) {\n    const r = new pe(e);\n    return r.ndk = this, r;\n  }\n  subscribe(e, r, n, i = !0) {\n    const s = new Pa(this, e, r, n);\n    return i && s.start(), s;\n  }\n  async publish(e, r, n) {\n    return r || (r = this.devWriteRelaySet || Nd(this)), r.publish(e, n);\n  }\n  async fetchEvent(e, r = {}, n) {\n    let i;\n    if (typeof e == \"string\" ? i = $d(e) : i = e, !i)\n      throw new Error(`Invalid filter: ${JSON.stringify(e)}`);\n    return new Promise((s) => {\n      const o = this.subscribe(i, { ...r, closeOnEose: !0 }, n, !1);\n      o.on(\"event\", (a) => {\n        a.ndk = this, s(a);\n      }), o.on(\"eose\", () => {\n        s(null);\n      }), o.start();\n    });\n  }\n  async fetchEvents(e, r = {}, n) {\n    return new Promise((i) => {\n      const s = /* @__PURE__ */ new Map(), o = this.subscribe(e, { ...r, closeOnEose: !0 }, n, !1);\n      o.on(\"event\", (a) => {\n        const c = s.get(a.tagId());\n        c && (a = pd(c, a)), a.ndk = this, s.set(a.tagId(), a);\n      }), o.on(\"eose\", () => {\n        i(new Set(s.values()));\n      }), o.start();\n    });\n  }\n  async assertSigner() {\n    if (!this.signer)\n      throw this.emit(\"signerRequired\"), new Error(\"Signer required\");\n  }\n};\nfunction zd(t) {\n  const e = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(!1), [r, n] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0), [i, s] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    async function f() {\n      r === void 0 && e.current === !1 && (e.current = !0, await o(t));\n    }\n    f();\n  }, []);\n  async function o(f, u) {\n    const h = new Dd({ explicitRelayUrls: f, signer: u });\n    u && s(u);\n    try {\n      await h.connect(), n(h);\n    } catch (d) {\n      console.error(\"ERROR loading NDK NDKInstance\", d);\n    }\n  }\n  async function a(f) {\n    o(t, f);\n  }\n  async function c(f) {\n    return r === void 0 ? [] : new Promise((u) => {\n      const h = /* @__PURE__ */ new Map(), d = r.subscribe(f, {\n        closeOnEose: !0\n      });\n      d.on(\"event\", (p) => {\n        p.ndk = r, h.set(p.tagId(), p);\n      }), d.on(\"eose\", () => {\n        setTimeout(() => u(Array.from(new Set(h.values()))), 3e3);\n      });\n    });\n  }\n  async function l(f, u = {\n    repost: !1,\n    publish: !0\n  }) {\n    if (r !== void 0)\n      return f.ndk = r, u.repost ? await f.repost() : await f.sign(), u.publish && await f.publish(), f;\n  }\n  return {\n    ndk: r,\n    signer: i,\n    loadNdk: o,\n    setSigner: a,\n    fetchEvents: c,\n    signPublishEvent: l\n  };\n}\nasync function Fd(t) {\n  try {\n    let e = t;\n    e.substring(0, 4) === \"nsec\" && (e = we.decode(e).data);\n    const r = new or(e);\n    return r.user().then(async (n) => {\n      if (n.npub)\n        return {\n          user: n,\n          npub: n.npub,\n          sk: e,\n          signer: r\n        };\n    });\n  } catch (e) {\n    throw e;\n  }\n}\nasync function Kd(t, e, r) {\n  try {\n    let n = or.generate();\n    r && (n = new or(r));\n    const i = new Md(t, e, n);\n    return i.user().then(async (s) => {\n      if (s.npub)\n        return await i.blockUntilReady(), {\n          user: s,\n          npub: (await i.user()).npub,\n          sk: n.privateKey,\n          token: e,\n          remoteSigner: i,\n          localSigner: n\n        };\n    });\n  } catch (n) {\n    throw n;\n  }\n}\nasync function Wd() {\n  try {\n    const t = new jd();\n    return t.user().then(async (e) => {\n      if (e.npub)\n        return { user: e, npub: e.npub, signer: t };\n    });\n  } catch (t) {\n    throw t;\n  }\n}\nconst Vd = (t) => {\n  const [e, r] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({}), n = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({});\n  async function i(a) {\n    if (t == null || n.current[a])\n      return;\n    n.current = {\n      ...n.current,\n      [a]: pe.prototype\n    };\n    let c;\n    a.startsWith(\"npub\") ? c = t.getUser({\n      npub: a\n    }) : c = t.getUser({\n      hexpubkey: a\n    }), await c.fetchProfile(), c.profile && (n.current = {\n      ...n.current,\n      [a]: c\n    }, r(n.current));\n  }\n  function s(a) {\n    return e[a] ? e[a] : (i(a), pe.prototype);\n  }\n  function o(a) {\n    return e[a] ? e[a].profile : (i(a), {});\n  }\n  return {\n    getUser: s,\n    getProfile: o\n  };\n};\nvar Ba = { exports: {} }, Xt = {};\n/**\n * @license React\n * react-jsx-runtime.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar Mo;\nfunction Gd() {\n  if (Mo)\n    return Xt;\n  Mo = 1;\n  var t = react__WEBPACK_IMPORTED_MODULE_0__, e = Symbol.for(\"react.element\"), r = Symbol.for(\"react.fragment\"), n = Object.prototype.hasOwnProperty, i = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, s = { key: !0, ref: !0, __self: !0, __source: !0 };\n  function o(a, c, l) {\n    var f, u = {}, h = null, d = null;\n    l !== void 0 && (h = \"\" + l), c.key !== void 0 && (h = \"\" + c.key), c.ref !== void 0 && (d = c.ref);\n    for (f in c)\n      n.call(c, f) && !s.hasOwnProperty(f) && (u[f] = c[f]);\n    if (a && a.defaultProps)\n      for (f in c = a.defaultProps, c)\n        u[f] === void 0 && (u[f] = c[f]);\n    return { $$typeof: e, type: a, key: h, ref: d, props: u, _owner: i.current };\n  }\n  return Xt.Fragment = r, Xt.jsx = o, Xt.jsxs = o, Xt;\n}\nvar Qt = {};\n/**\n * @license React\n * react-jsx-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar Do;\nfunction Zd() {\n  return Do || (Do = 1,  true && function() {\n    var t = react__WEBPACK_IMPORTED_MODULE_0__, e = Symbol.for(\"react.element\"), r = Symbol.for(\"react.portal\"), n = Symbol.for(\"react.fragment\"), i = Symbol.for(\"react.strict_mode\"), s = Symbol.for(\"react.profiler\"), o = Symbol.for(\"react.provider\"), a = Symbol.for(\"react.context\"), c = Symbol.for(\"react.forward_ref\"), l = Symbol.for(\"react.suspense\"), f = Symbol.for(\"react.suspense_list\"), u = Symbol.for(\"react.memo\"), h = Symbol.for(\"react.lazy\"), d = Symbol.for(\"react.offscreen\"), p = Symbol.iterator, y = \"@@iterator\";\n    function g(b) {\n      if (b === null || typeof b != \"object\")\n        return null;\n      var k = p && b[p] || b[y];\n      return typeof k == \"function\" ? k : null;\n    }\n    var v = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n    function _(b) {\n      {\n        for (var k = arguments.length, T = new Array(k > 1 ? k - 1 : 0), $ = 1; $ < k; $++)\n          T[$ - 1] = arguments[$];\n        m(\"error\", b, T);\n      }\n    }\n    function m(b, k, T) {\n      {\n        var $ = v.ReactDebugCurrentFrame, M = $.getStackAddendum();\n        M !== \"\" && (k += \"%s\", T = T.concat([M]));\n        var K = T.map(function(j) {\n          return String(j);\n        });\n        K.unshift(\"Warning: \" + k), Function.prototype.apply.call(console[b], console, K);\n      }\n    }\n    var C = !1, O = !1, w = !1, x = !1, A = !1, B;\n    B = Symbol.for(\"react.module.reference\");\n    function L(b) {\n      return !!(typeof b == \"string\" || typeof b == \"function\" || b === n || b === s || A || b === i || b === l || b === f || x || b === d || C || O || w || typeof b == \"object\" && b !== null && (b.$$typeof === h || b.$$typeof === u || b.$$typeof === o || b.$$typeof === a || b.$$typeof === c || b.$$typeof === B || b.getModuleId !== void 0));\n    }\n    function P(b, k, T) {\n      var $ = b.displayName;\n      if ($)\n        return $;\n      var M = k.displayName || k.name || \"\";\n      return M !== \"\" ? T + \"(\" + M + \")\" : T;\n    }\n    function F(b) {\n      return b.displayName || \"Context\";\n    }\n    function z(b) {\n      if (b == null)\n        return null;\n      if (typeof b.tag == \"number\" && _(\"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"), typeof b == \"function\")\n        return b.displayName || b.name || null;\n      if (typeof b == \"string\")\n        return b;\n      switch (b) {\n        case n:\n          return \"Fragment\";\n        case r:\n          return \"Portal\";\n        case s:\n          return \"Profiler\";\n        case i:\n          return \"StrictMode\";\n        case l:\n          return \"Suspense\";\n        case f:\n          return \"SuspenseList\";\n      }\n      if (typeof b == \"object\")\n        switch (b.$$typeof) {\n          case a:\n            var k = b;\n            return F(k) + \".Consumer\";\n          case o:\n            var T = b;\n            return F(T._context) + \".Provider\";\n          case c:\n            return P(b, b.render, \"ForwardRef\");\n          case u:\n            var $ = b.displayName || null;\n            return $ !== null ? $ : z(b.type) || \"Memo\";\n          case h: {\n            var M = b, K = M._payload, j = M._init;\n            try {\n              return z(j(K));\n            } catch {\n              return null;\n            }\n          }\n        }\n      return null;\n    }\n    var G = Object.assign, E = 0, R, q, H, D, X, oe, re;\n    function _e() {\n    }\n    _e.__reactDisabledLog = !0;\n    function Oe() {\n      {\n        if (E === 0) {\n          R = console.log, q = console.info, H = console.warn, D = console.error, X = console.group, oe = console.groupCollapsed, re = console.groupEnd;\n          var b = {\n            configurable: !0,\n            enumerable: !0,\n            value: _e,\n            writable: !0\n          };\n          Object.defineProperties(console, {\n            info: b,\n            log: b,\n            warn: b,\n            error: b,\n            group: b,\n            groupCollapsed: b,\n            groupEnd: b\n          });\n        }\n        E++;\n      }\n    }\n    function Ue() {\n      {\n        if (E--, E === 0) {\n          var b = {\n            configurable: !0,\n            enumerable: !0,\n            writable: !0\n          };\n          Object.defineProperties(console, {\n            log: G({}, b, {\n              value: R\n            }),\n            info: G({}, b, {\n              value: q\n            }),\n            warn: G({}, b, {\n              value: H\n            }),\n            error: G({}, b, {\n              value: D\n            }),\n            group: G({}, b, {\n              value: X\n            }),\n            groupCollapsed: G({}, b, {\n              value: oe\n            }),\n            groupEnd: G({}, b, {\n              value: re\n            })\n          });\n        }\n        E < 0 && _(\"disabledDepth fell below zero. This is a bug in React. Please file an issue.\");\n      }\n    }\n    var Pe = v.ReactCurrentDispatcher, ye;\n    function je(b, k, T) {\n      {\n        if (ye === void 0)\n          try {\n            throw Error();\n          } catch (M) {\n            var $ = M.stack.trim().match(/\\n( *(at )?)/);\n            ye = $ && $[1] || \"\";\n          }\n        return `\n` + ye + b;\n      }\n    }\n    var me = !1, xe;\n    {\n      var lr = typeof WeakMap == \"function\" ? WeakMap : Map;\n      xe = new lr();\n    }\n    function Be(b, k) {\n      if (!b || me)\n        return \"\";\n      {\n        var T = xe.get(b);\n        if (T !== void 0)\n          return T;\n      }\n      var $;\n      me = !0;\n      var M = Error.prepareStackTrace;\n      Error.prepareStackTrace = void 0;\n      var K;\n      K = Pe.current, Pe.current = null, Oe();\n      try {\n        if (k) {\n          var j = function() {\n            throw Error();\n          };\n          if (Object.defineProperty(j.prototype, \"props\", {\n            set: function() {\n              throw Error();\n            }\n          }), typeof Reflect == \"object\" && Reflect.construct) {\n            try {\n              Reflect.construct(j, []);\n            } catch (Le) {\n              $ = Le;\n            }\n            Reflect.construct(b, [], j);\n          } else {\n            try {\n              j.call();\n            } catch (Le) {\n              $ = Le;\n            }\n            b.call(j.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (Le) {\n            $ = Le;\n          }\n          b();\n        }\n      } catch (Le) {\n        if (Le && $ && typeof Le.stack == \"string\") {\n          for (var U = Le.stack.split(`\n`), se = $.stack.split(`\n`), W = U.length - 1, Z = se.length - 1; W >= 1 && Z >= 0 && U[W] !== se[Z]; )\n            Z--;\n          for (; W >= 1 && Z >= 0; W--, Z--)\n            if (U[W] !== se[Z]) {\n              if (W !== 1 || Z !== 1)\n                do\n                  if (W--, Z--, Z < 0 || U[W] !== se[Z]) {\n                    var ge = `\n` + U[W].replace(\" at new \", \" at \");\n                    return b.displayName && ge.includes(\"<anonymous>\") && (ge = ge.replace(\"<anonymous>\", b.displayName)), typeof b == \"function\" && xe.set(b, ge), ge;\n                  }\n                while (W >= 1 && Z >= 0);\n              break;\n            }\n        }\n      } finally {\n        me = !1, Pe.current = K, Ue(), Error.prepareStackTrace = M;\n      }\n      var yt = b ? b.displayName || b.name : \"\", $i = yt ? je(yt) : \"\";\n      return typeof b == \"function\" && xe.set(b, $i), $i;\n    }\n    function fe(b, k, T) {\n      return Be(b, !1);\n    }\n    function He(b) {\n      var k = b.prototype;\n      return !!(k && k.isReactComponent);\n    }\n    function it(b, k, T) {\n      if (b == null)\n        return \"\";\n      if (typeof b == \"function\")\n        return Be(b, He(b));\n      if (typeof b == \"string\")\n        return je(b);\n      switch (b) {\n        case l:\n          return je(\"Suspense\");\n        case f:\n          return je(\"SuspenseList\");\n      }\n      if (typeof b == \"object\")\n        switch (b.$$typeof) {\n          case c:\n            return fe(b.render);\n          case u:\n            return it(b.type, k, T);\n          case h: {\n            var $ = b, M = $._payload, K = $._init;\n            try {\n              return it(K(M), k, T);\n            } catch {\n            }\n          }\n        }\n      return \"\";\n    }\n    var ot = Object.prototype.hasOwnProperty, Ei = {}, ki = v.ReactDebugCurrentFrame;\n    function fr(b) {\n      if (b) {\n        var k = b._owner, T = it(b.type, b._source, k ? k.type : null);\n        ki.setExtraStackFrame(T);\n      } else\n        ki.setExtraStackFrame(null);\n    }\n    function Ma(b, k, T, $, M) {\n      {\n        var K = Function.call.bind(ot);\n        for (var j in b)\n          if (K(b, j)) {\n            var U = void 0;\n            try {\n              if (typeof b[j] != \"function\") {\n                var se = Error(($ || \"React class\") + \": \" + T + \" type `\" + j + \"` is invalid; it must be a function, usually from the `prop-types` package, but received `\" + typeof b[j] + \"`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                throw se.name = \"Invariant Violation\", se;\n              }\n              U = b[j](k, j, $, T, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n            } catch (W) {\n              U = W;\n            }\n            U && !(U instanceof Error) && (fr(M), _(\"%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).\", $ || \"React class\", T, j, typeof U), fr(null)), U instanceof Error && !(U.message in Ei) && (Ei[U.message] = !0, fr(M), _(\"Failed %s type: %s\", T, U.message), fr(null));\n          }\n      }\n    }\n    var Da = Array.isArray;\n    function Zr(b) {\n      return Da(b);\n    }\n    function za(b) {\n      {\n        var k = typeof Symbol == \"function\" && Symbol.toStringTag, T = k && b[Symbol.toStringTag] || b.constructor.name || \"Object\";\n        return T;\n      }\n    }\n    function Fa(b) {\n      try {\n        return Si(b), !1;\n      } catch {\n        return !0;\n      }\n    }\n    function Si(b) {\n      return \"\" + b;\n    }\n    function Oi(b) {\n      if (Fa(b))\n        return _(\"The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.\", za(b)), Si(b);\n    }\n    var Ct = v.ReactCurrentOwner, Ka = {\n      key: !0,\n      ref: !0,\n      __self: !0,\n      __source: !0\n    }, Ai, Ci, Yr;\n    Yr = {};\n    function Wa(b) {\n      if (ot.call(b, \"ref\")) {\n        var k = Object.getOwnPropertyDescriptor(b, \"ref\").get;\n        if (k && k.isReactWarning)\n          return !1;\n      }\n      return b.ref !== void 0;\n    }\n    function Va(b) {\n      if (ot.call(b, \"key\")) {\n        var k = Object.getOwnPropertyDescriptor(b, \"key\").get;\n        if (k && k.isReactWarning)\n          return !1;\n      }\n      return b.key !== void 0;\n    }\n    function Ga(b, k) {\n      if (typeof b.ref == \"string\" && Ct.current && k && Ct.current.stateNode !== k) {\n        var T = z(Ct.current.type);\n        Yr[T] || (_('Component \"%s\" contains the string ref \"%s\". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', z(Ct.current.type), b.ref), Yr[T] = !0);\n      }\n    }\n    function Za(b, k) {\n      {\n        var T = function() {\n          Ai || (Ai = !0, _(\"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", k));\n        };\n        T.isReactWarning = !0, Object.defineProperty(b, \"key\", {\n          get: T,\n          configurable: !0\n        });\n      }\n    }\n    function Ya(b, k) {\n      {\n        var T = function() {\n          Ci || (Ci = !0, _(\"%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", k));\n        };\n        T.isReactWarning = !0, Object.defineProperty(b, \"ref\", {\n          get: T,\n          configurable: !0\n        });\n      }\n    }\n    var Ja = function(b, k, T, $, M, K, j) {\n      var U = {\n        $$typeof: e,\n        type: b,\n        key: k,\n        ref: T,\n        props: j,\n        _owner: K\n      };\n      return U._store = {}, Object.defineProperty(U._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: !1\n      }), Object.defineProperty(U, \"_self\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !1,\n        value: $\n      }), Object.defineProperty(U, \"_source\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !1,\n        value: M\n      }), Object.freeze && (Object.freeze(U.props), Object.freeze(U)), U;\n    };\n    function Xa(b, k, T, $, M) {\n      {\n        var K, j = {}, U = null, se = null;\n        T !== void 0 && (Oi(T), U = \"\" + T), Va(k) && (Oi(k.key), U = \"\" + k.key), Wa(k) && (se = k.ref, Ga(k, M));\n        for (K in k)\n          ot.call(k, K) && !Ka.hasOwnProperty(K) && (j[K] = k[K]);\n        if (b && b.defaultProps) {\n          var W = b.defaultProps;\n          for (K in W)\n            j[K] === void 0 && (j[K] = W[K]);\n        }\n        if (U || se) {\n          var Z = typeof b == \"function\" ? b.displayName || b.name || \"Unknown\" : b;\n          U && Za(j, Z), se && Ya(j, Z);\n        }\n        return Ja(b, U, se, M, $, Ct.current, j);\n      }\n    }\n    var Jr = v.ReactCurrentOwner, Ii = v.ReactDebugCurrentFrame;\n    function pt(b) {\n      if (b) {\n        var k = b._owner, T = it(b.type, b._source, k ? k.type : null);\n        Ii.setExtraStackFrame(T);\n      } else\n        Ii.setExtraStackFrame(null);\n    }\n    var Xr;\n    Xr = !1;\n    function Qr(b) {\n      return typeof b == \"object\" && b !== null && b.$$typeof === e;\n    }\n    function Ri() {\n      {\n        if (Jr.current) {\n          var b = z(Jr.current.type);\n          if (b)\n            return `\n\nCheck the render method of \\`` + b + \"`.\";\n        }\n        return \"\";\n      }\n    }\n    function Qa(b) {\n      {\n        if (b !== void 0) {\n          var k = b.fileName.replace(/^.*[\\\\\\/]/, \"\"), T = b.lineNumber;\n          return `\n\nCheck your code at ` + k + \":\" + T + \".\";\n        }\n        return \"\";\n      }\n    }\n    var Ti = {};\n    function ec(b) {\n      {\n        var k = Ri();\n        if (!k) {\n          var T = typeof b == \"string\" ? b : b.displayName || b.name;\n          T && (k = `\n\nCheck the top-level render call using <` + T + \">.\");\n        }\n        return k;\n      }\n    }\n    function Pi(b, k) {\n      {\n        if (!b._store || b._store.validated || b.key != null)\n          return;\n        b._store.validated = !0;\n        var T = ec(k);\n        if (Ti[T])\n          return;\n        Ti[T] = !0;\n        var $ = \"\";\n        b && b._owner && b._owner !== Jr.current && ($ = \" It was passed a child from \" + z(b._owner.type) + \".\"), pt(b), _('Each child in a list should have a unique \"key\" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', T, $), pt(null);\n      }\n    }\n    function Bi(b, k) {\n      {\n        if (typeof b != \"object\")\n          return;\n        if (Zr(b))\n          for (var T = 0; T < b.length; T++) {\n            var $ = b[T];\n            Qr($) && Pi($, k);\n          }\n        else if (Qr(b))\n          b._store && (b._store.validated = !0);\n        else if (b) {\n          var M = g(b);\n          if (typeof M == \"function\" && M !== b.entries)\n            for (var K = M.call(b), j; !(j = K.next()).done; )\n              Qr(j.value) && Pi(j.value, k);\n        }\n      }\n    }\n    function tc(b) {\n      {\n        var k = b.type;\n        if (k == null || typeof k == \"string\")\n          return;\n        var T;\n        if (typeof k == \"function\")\n          T = k.propTypes;\n        else if (typeof k == \"object\" && (k.$$typeof === c || k.$$typeof === u))\n          T = k.propTypes;\n        else\n          return;\n        if (T) {\n          var $ = z(k);\n          Ma(T, b.props, \"prop\", $, b);\n        } else if (k.PropTypes !== void 0 && !Xr) {\n          Xr = !0;\n          var M = z(k);\n          _(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", M || \"Unknown\");\n        }\n        typeof k.getDefaultProps == \"function\" && !k.getDefaultProps.isReactClassApproved && _(\"getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.\");\n      }\n    }\n    function rc(b) {\n      {\n        for (var k = Object.keys(b.props), T = 0; T < k.length; T++) {\n          var $ = k[T];\n          if ($ !== \"children\" && $ !== \"key\") {\n            pt(b), _(\"Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.\", $), pt(null);\n            break;\n          }\n        }\n        b.ref !== null && (pt(b), _(\"Invalid attribute `ref` supplied to `React.Fragment`.\"), pt(null));\n      }\n    }\n    function Li(b, k, T, $, M, K) {\n      {\n        var j = L(b);\n        if (!j) {\n          var U = \"\";\n          (b === void 0 || typeof b == \"object\" && b !== null && Object.keys(b).length === 0) && (U += \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\");\n          var se = Qa(M);\n          se ? U += se : U += Ri();\n          var W;\n          b === null ? W = \"null\" : Zr(b) ? W = \"array\" : b !== void 0 && b.$$typeof === e ? (W = \"<\" + (z(b.type) || \"Unknown\") + \" />\", U = \" Did you accidentally export a JSX literal instead of a component?\") : W = typeof b, _(\"React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s\", W, U);\n        }\n        var Z = Xa(b, k, T, M, K);\n        if (Z == null)\n          return Z;\n        if (j) {\n          var ge = k.children;\n          if (ge !== void 0)\n            if ($)\n              if (Zr(ge)) {\n                for (var yt = 0; yt < ge.length; yt++)\n                  Bi(ge[yt], b);\n                Object.freeze && Object.freeze(ge);\n              } else\n                _(\"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\");\n            else\n              Bi(ge, b);\n        }\n        return b === n ? rc(Z) : tc(Z), Z;\n      }\n    }\n    function nc(b, k, T) {\n      return Li(b, k, T, !0);\n    }\n    function ic(b, k, T) {\n      return Li(b, k, T, !1);\n    }\n    var oc = ic, sc = nc;\n    Qt.Fragment = n, Qt.jsx = oc, Qt.jsxs = sc;\n  }()), Qt;\n}\n(function(t) {\n   false ? 0 : t.exports = Zd();\n})(Ba);\nconst Yd = Ba.exports.jsx, La = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n  ndk: void 0,\n  signer: void 0,\n  fetchEvents: (t) => Promise.resolve([]),\n  loginWithNip46: (t, e) => Promise.resolve(void 0),\n  loginWithSecret: (t) => Promise.resolve(void 0),\n  loginWithNip07: () => Promise.resolve(void 0),\n  signPublishEvent: (t, e) => Promise.resolve(void 0),\n  getUser: (t) => pe.prototype,\n  getProfile: (t) => ({})\n}), Pp = ({\n  children: t,\n  relayUrls: e\n}) => {\n  const {\n    ndk: r,\n    signer: n,\n    setSigner: i,\n    fetchEvents: s,\n    signPublishEvent: o\n  } = zd(e), {\n    getUser: a,\n    getProfile: c\n  } = Vd(r);\n  async function l(h, d) {\n    if (r === void 0)\n      return;\n    const p = await Kd(r, h, d);\n    if (p)\n      return await i(p.remoteSigner), p;\n  }\n  async function f(h) {\n    const d = await Fd(h);\n    if (d) {\n      const {\n        signer: p\n      } = d;\n      return await i(p), d;\n    }\n  }\n  async function u() {\n    const h = await Wd();\n    if (h) {\n      const {\n        signer: d\n      } = h;\n      return await i(d), h;\n    }\n  }\n  return /* @__PURE__ */ Yd(La.Provider, {\n    value: {\n      ndk: r,\n      signer: n,\n      fetchEvents: s,\n      loginWithNip07: u,\n      loginWithNip46: l,\n      loginWithSecret: f,\n      signPublishEvent: o,\n      getUser: a,\n      getProfile: c\n    },\n    children: t\n  });\n}, Bp = () => {\n  const t = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(La);\n  if (t === void 0)\n    throw new Error(\"import NDKProvider to use useNDK\");\n  return t;\n};\nfunction Xe(t) {\n  return t != null && typeof t == \"object\" && t[\"@@functional/placeholder\"] === !0;\n}\nfunction ht(t) {\n  return function e(r) {\n    return arguments.length === 0 || Xe(r) ? e : t.apply(this, arguments);\n  };\n}\nfunction ur(t) {\n  return function e(r, n) {\n    switch (arguments.length) {\n      case 0:\n        return e;\n      case 1:\n        return Xe(r) ? e : ht(function(i) {\n          return t(r, i);\n        });\n      default:\n        return Xe(r) && Xe(n) ? e : Xe(r) ? ht(function(i) {\n          return t(i, n);\n        }) : Xe(n) ? ht(function(i) {\n          return t(r, i);\n        }) : t(r, n);\n    }\n  };\n}\nfunction $a(t, e) {\n  switch (t) {\n    case 0:\n      return function() {\n        return e.apply(this, arguments);\n      };\n    case 1:\n      return function(r) {\n        return e.apply(this, arguments);\n      };\n    case 2:\n      return function(r, n) {\n        return e.apply(this, arguments);\n      };\n    case 3:\n      return function(r, n, i) {\n        return e.apply(this, arguments);\n      };\n    case 4:\n      return function(r, n, i, s) {\n        return e.apply(this, arguments);\n      };\n    case 5:\n      return function(r, n, i, s, o) {\n        return e.apply(this, arguments);\n      };\n    case 6:\n      return function(r, n, i, s, o, a) {\n        return e.apply(this, arguments);\n      };\n    case 7:\n      return function(r, n, i, s, o, a, c) {\n        return e.apply(this, arguments);\n      };\n    case 8:\n      return function(r, n, i, s, o, a, c, l) {\n        return e.apply(this, arguments);\n      };\n    case 9:\n      return function(r, n, i, s, o, a, c, l, f) {\n        return e.apply(this, arguments);\n      };\n    case 10:\n      return function(r, n, i, s, o, a, c, l, f, u) {\n        return e.apply(this, arguments);\n      };\n    default:\n      throw new Error(\"First argument to _arity must be a non-negative integer no greater than ten\");\n  }\n}\nfunction qa(t, e, r) {\n  return function() {\n    for (var n = [], i = 0, s = t, o = 0; o < e.length || i < arguments.length; ) {\n      var a;\n      o < e.length && (!Xe(e[o]) || i >= arguments.length) ? a = e[o] : (a = arguments[i], i += 1), n[o] = a, Xe(a) || (s -= 1), o += 1;\n    }\n    return s <= 0 ? r.apply(this, n) : $a(s, qa(t, n, r));\n  };\n}\nvar Jd = /* @__PURE__ */ ur(function(e, r) {\n  return e === 1 ? ht(r) : $a(e, qa(e, [], r));\n});\nconst Xd = Jd, Qd = Array.isArray || function(e) {\n  return e != null && e.length >= 0 && Object.prototype.toString.call(e) === \"[object Array]\";\n};\nfunction ep(t) {\n  return t != null && typeof t[\"@@transducer/step\"] == \"function\";\n}\nfunction tp(t, e, r) {\n  return function() {\n    if (arguments.length === 0)\n      return r();\n    var n = arguments[arguments.length - 1];\n    if (!Qd(n)) {\n      for (var i = 0; i < t.length; ) {\n        if (typeof n[t[i]] == \"function\")\n          return n[t[i]].apply(n, Array.prototype.slice.call(arguments, 0, -1));\n        i += 1;\n      }\n      if (ep(n)) {\n        var s = e.apply(null, Array.prototype.slice.call(arguments, 0, -1));\n        return s(n);\n      }\n    }\n    return r.apply(this, arguments);\n  };\n}\nconst zo = {\n  init: function() {\n    return this.xf[\"@@transducer/init\"]();\n  },\n  result: function(t) {\n    return this.xf[\"@@transducer/result\"](t);\n  }\n};\nfunction jn(t, e) {\n  return Object.prototype.hasOwnProperty.call(e, t);\n}\nvar Fo = Object.prototype.toString, rp = /* @__PURE__ */ function() {\n  return Fo.call(arguments) === \"[object Arguments]\" ? function(e) {\n    return Fo.call(e) === \"[object Arguments]\";\n  } : function(e) {\n    return jn(\"callee\", e);\n  };\n}();\nconst np = rp;\nvar ip = !/* @__PURE__ */ {\n  toString: null\n}.propertyIsEnumerable(\"toString\"), Ko = [\"constructor\", \"valueOf\", \"isPrototypeOf\", \"toString\", \"propertyIsEnumerable\", \"hasOwnProperty\", \"toLocaleString\"], Wo = /* @__PURE__ */ function() {\n  return arguments.propertyIsEnumerable(\"length\");\n}(), op = function(e, r) {\n  for (var n = 0; n < e.length; ) {\n    if (e[n] === r)\n      return !0;\n    n += 1;\n  }\n  return !1;\n}, sp = /* @__PURE__ */ ht(typeof Object.keys == \"function\" && !Wo ? function(e) {\n  return Object(e) !== e ? [] : Object.keys(e);\n} : function(e) {\n  if (Object(e) !== e)\n    return [];\n  var r, n, i = [], s = Wo && np(e);\n  for (r in e)\n    jn(r, e) && (!s || r !== \"length\") && (i[i.length] = r);\n  if (ip)\n    for (n = Ko.length - 1; n >= 0; )\n      r = Ko[n], jn(r, e) && !op(i, r) && (i[i.length] = r), n -= 1;\n  return i;\n});\nconst ap = sp;\nfunction cp(t, e) {\n  for (var r = 0, n = e.length, i = Array(n); r < n; )\n    i[r] = t(e[r]), r += 1;\n  return i;\n}\nfunction up(t, e, r) {\n  for (var n = 0, i = r.length; n < i; )\n    e = t(e, r[n]), n += 1;\n  return e;\n}\nvar lp = /* @__PURE__ */ function() {\n  function t(e, r) {\n    this.xf = r, this.f = e;\n  }\n  return t.prototype[\"@@transducer/init\"] = zo.init, t.prototype[\"@@transducer/result\"] = zo.result, t.prototype[\"@@transducer/step\"] = function(e, r) {\n    return this.xf[\"@@transducer/step\"](e, this.f(r));\n  }, t;\n}(), fp = function(e) {\n  return function(r) {\n    return new lp(e, r);\n  };\n};\nconst hp = fp;\nvar dp = /* @__PURE__ */ ur(\n  /* @__PURE__ */ tp([\"fantasy-land/map\", \"map\"], hp, function(e, r) {\n    switch (Object.prototype.toString.call(r)) {\n      case \"[object Function]\":\n        return Xd(r.length, function() {\n          return e.call(this, r.apply(this, arguments));\n        });\n      case \"[object Object]\":\n        return up(function(n, i) {\n          return n[i] = e(r[i]), n;\n        }, {}, ap(r));\n      default:\n        return cp(e, r);\n    }\n  })\n);\nconst pp = dp, yp = Number.isInteger || function(e) {\n  return e << 0 === e;\n};\nfunction gp(t) {\n  return Object.prototype.toString.call(t) === \"[object String]\";\n}\nvar bp = /* @__PURE__ */ ur(function(e, r) {\n  var n = e < 0 ? r.length + e : e;\n  return gp(r) ? r.charAt(n) : r[n];\n});\nconst Na = bp;\nvar vp = /* @__PURE__ */ ur(function(e, r) {\n  if (r != null)\n    return yp(e) ? Na(e, r) : r[e];\n});\nconst wp = vp;\nvar _p = /* @__PURE__ */ ur(function(e, r) {\n  return pp(wp(e), r);\n});\nconst mp = _p;\nfunction xp(t) {\n  return t;\n}\nvar Ep = /* @__PURE__ */ ht(xp);\nconst kp = Ep;\nvar Sp = /* @__PURE__ */ Na(-1);\nconst Ua = Sp, Op = \"newline\", Hn = \"text\", ja = \"topic\", xi = \"link\", Ha = \"invoice\", Lp = \"nostr:note\", $p = \"nostr:nevent\", qp = \"nostr:npub\", Np = \"nostr:nprofile\", Up = \"nostr:naddr\";\nfunction gt(t) {\n  return t ? t[0] : void 0;\n}\nconst Ap = (t) => t.replace(/^[\\w\\+]+:\\/?\\/?/, \"\"), Cp = (t) => !t.match(/\\.(apk|docx|xlsx|csv|dmg)/) && Ua(t.split(\"://\")).includes(\"/\"), jp = ({\n  content: t,\n  tags: e = []\n}) => {\n  const r = [];\n  let n = t.trim(), i = \"\";\n  const s = () => {\n    const u = gt(n.match(/^\\n+/));\n    if (u)\n      return [Op, u, u];\n  }, o = () => {\n    const u = n.match(/^#\\[(\\d+)\\]/i);\n    if (u) {\n      const h = parseInt(u[1]);\n      if (e[h]) {\n        const [d, p, y] = e[h], g = [y].filter(kp);\n        let v, _, m;\n        return d === \"p\" ? (v = \"nprofile\", _ = { pubkey: p, relays: g }, m = we.nprofileEncode(_)) : (v = \"nevent\", _ = { id: p, relays: g, pubkey: null }, m = we.neventEncode(_)), [`nostr:${v}`, u[0], { ..._, entity: m }];\n      }\n    }\n  }, a = () => {\n    const u = gt(n.match(/^#\\w+/i));\n    if (u && !u.match(/^#\\d+$/))\n      return [ja, u, u.slice(1)];\n  }, c = () => {\n    const u = gt(\n      n.match(\n        /^(web\\+)?(nostr:)?\\/?\\/?n(event|ote|profile|pub|addr)1[\\d\\w]+/i\n      )\n    );\n    if (u)\n      try {\n        const h = Ap(u), { type: d, data: p } = we.decode(h);\n        let y = p;\n        return d === \"note\" ? y = { id: p } : d === \"npub\" && (y = { pubkey: p }), [`nostr:${d}`, u, { ...y, entity: h }];\n      } catch (h) {\n        console.log(h);\n      }\n  }, l = () => {\n    const u = gt(n.match(/^ln(bc|url)[\\d\\w]{50,1000}/i));\n    if (u)\n      return [Ha, u, u];\n  }, f = () => {\n    const u = gt(\n      n.match(/^([a-z\\+:]{2,30}:\\/\\/)?[^\\s]+\\.[a-z]{2,6}[^\\s]*[^\\.!?,:\\s]/gi)\n    );\n    if (u) {\n      const h = Ua(r);\n      if ((h == null ? void 0 : h.type) === \"text\" && h.value.endsWith(\"/\"))\n        return;\n      let d = u;\n      return d.match(/\\.\\./) ? void 0 : (d.match(\"://\") || (d = \"https://\" + d), [xi, u, { url: d, isMedia: Cp(d) }]);\n    }\n  };\n  for (; n; ) {\n    const u = s() || o() || a() || c() || f() || l();\n    if (u) {\n      i && (r.push({ type: \"text\", value: i }), i = \"\");\n      const [h, d, p] = u;\n      r.push({ type: h, value: p }), n = n.slice(d.length);\n    } else {\n      const h = gt(n.match(/^[\\w\\d]+ ?/i)) || n[0];\n      i += h, n = n.slice(h.length);\n    }\n  }\n  return i && r.push({ type: Hn, value: i }), r;\n}, Hp = (t, { showEntire: e, maxLength: r, showMedia: n = !1 }) => {\n  if (e)\n    return t;\n  let i = 0;\n  const s = [], o = r * 0.6;\n  return t.every((a, c) => {\n    const l = [ja, Hn].includes(a.type) || a.type === xi && !a.value.isMedia, f = a.type === Ha || a.type.startsWith(\"nostr:\") || a.value.isMedia;\n    return l && (i += a.value.length), f && (i += n ? r / 3 : a.value.length), s.push(a), i > o && c < t.length - 1 ? ((l || f && !n) && s.push({ type: Hn, value: \"...\" }), !1) : !0;\n  }), s;\n}, Mp = (t) => mp(\n  \"value\",\n  t.filter((e) => e.type === xi && e.isMedia)\n);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrLXJlYWN0L2Rpc3QvbmRrLXJlYWN0LmVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0EsMENBQTBDLDBEQUEwRDtBQUNwRztBQUNpSDtBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0Esa0RBQWtELFdBQVc7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBLFdBQVcsYUFBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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QUFDL0QsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0JBQXNCO0FBQ2xDLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDREQUE0RCxVQUFVLGNBQWMsU0FBUztBQUM3RjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrREFBa0QsMkJBQTJCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCLGlCQUFpQjtBQUMxQztBQUNBLDBDQUEwQyxXQUFXO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLEVBQUU7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLEVBQUU7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxFQUFFLGtC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QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsRUFBRTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMkJBQTJCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBLQUEwSyxHQUFHO0FBQzdLO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsRUFBRTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLEVBQUU7QUFDNUM7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLEVBQUUsdUVBQXVFO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxxQkFBcUI7QUFDckIsUUFBUSxtRUFBbUU7QUFDM0UsZUFBZSxrQkFBa0IsUUFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBSTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixHQUFHO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLHFCQUFxQixxQkFBcUI7QUFDMUM7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUTtBQUM5QixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxnQ0FBZ0MsS0FBSyxvQ0FBb0MsR0FBRztBQUM1RTtBQUNBO0FBQ0EsUUFBUSxzQkFBc0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0Esd0NBQXdDLEVBQUU7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLFNBQVMsY0FBYztBQUN2QjtBQUNBO0FBQ0EsdUNBQXVDLEVBQUU7QUFDekM7QUFDQTtBQUNBLHdEQUF3RCxFQUFFO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxpQkFBaUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsTUFBTSx3QkFBd0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsWUFBWSxFQUFFLE1BQU0sRUFBRTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxpQkFBaUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsTUFBTSx3QkFBd0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLEVBQUUsK0JBQStCLEVBQUU7QUFDMUUsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxFQUFFLCtCQUErQixFQUFFLE1BQU0sc0JBQXNCO0FBQ2pHLGlCQUFpQiwrQ0FBK0M7QUFDaEUsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpREFBaUQ7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLFNBQVM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsMENBQTBDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHNCQUFzQixJQUFJO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCw4QkFBOEIsVUFBVTtBQUN4QztBQUNBLGdEQUFnRCxVQUFVO0FBQzFEO0FBQ0E7QUFDQSxtQ0FBbUMsVUFBVTtBQUM3QztBQUNBLDBDQUEwQyxFQUFFO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDBDQUEwQztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTyxvQ0FBb0MsUUFBUSxvQ0FBb0MsUUFBUTtBQUN2STtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxTQUFTLEdBQUcsRUFBRTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxTQUFTLEdBQUcsRUFBRTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGdDQUFnQyxVQUFVO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsRUFBRSxHQUFHLEVBQUUsK0VBQStFLEVBQUU7QUFDOUksSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBLE1BQU07QUFDTjtBQUNBLHFCQUFxQixFQUFFLHNCQUFzQixFQUFFO0FBQy9DLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsR0FBRztBQUNoQztBQUNBO0FBQ0EscUNBQXFDLEdBQUc7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxXQUFXO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxXQUFXLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUztBQUN4RDtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsV0FBVztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFB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QUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEVBQUU7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxtQkFBbUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRixFQUFFO0FBQ3BGLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRyxLQUFLO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCx5QkFBeUIsU0FBUztBQUNsQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFNBQVM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCw0REFBNEQsVUFBVTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsd0JBQXdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxzQkFBc0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEdBQTBHLEtBQUs7QUFDL0csTUFBTTtBQUNOLGlDQUFpQyxLQUFLO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsYUFBYSxHQUFHLEVBQUU7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsc0JBQXNCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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LHVCQUF1QixvQkFBb0I7QUFDM0MsQ0FBQyxhQUFhLGdEQUFnRDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrSkFBa0osd0JBQXdCO0FBQzFLLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBbUJFIiwic291cmNlcyI6WyIvaG9tZS9sZmcvR2l0L01hZHRyaXBzL25vZGVfbW9kdWxlcy9Abm9zdHItZGV2LWtpdC9uZGstcmVhY3QvZGlzdC9uZGstcmVhY3QuZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGFjID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIGNjID0gKHQsIGUsIHIpID0+IGUgaW4gdCA/IGFjKHQsIGUsIHsgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCwgdmFsdWU6IHIgfSkgOiB0W2VdID0gcjtcbnZhciBJID0gKHQsIGUsIHIpID0+IChjYyh0LCB0eXBlb2YgZSAhPSBcInN5bWJvbFwiID8gZSArIFwiXCIgOiBlLCByKSwgcik7XG5pbXBvcnQgVm8sIHsgdXNlUmVmIGFzIEdvLCB1c2VTdGF0ZSBhcyBTbiwgdXNlRWZmZWN0IGFzIHVjLCBjcmVhdGVDb250ZXh0IGFzIGxjLCB1c2VDb250ZXh0IGFzIGZjIH0gZnJvbSBcInJlYWN0XCI7XG52YXIgUyA9IHR5cGVvZiBnbG9iYWxUaGlzIDwgXCJ1XCIgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyA8IFwidVwiID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCA8IFwidVwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgPCBcInVcIiA/IHNlbGYgOiB7fTtcbmZ1bmN0aW9uIEV0KHQpIHtcbiAgdmFyIGUgPSB0LmRlZmF1bHQ7XG4gIGlmICh0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB2YXIgciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIHIucHJvdG90eXBlID0gZS5wcm90b3R5cGU7XG4gIH0gZWxzZVxuICAgIHIgPSB7fTtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIE9iamVjdC5rZXlzKHQpLmZvckVhY2goZnVuY3Rpb24obikge1xuICAgIHZhciBpID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCBuKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkociwgbiwgaS5nZXQgPyBpIDoge1xuICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdFtuXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSksIHI7XG59XG52YXIgT24gPSB7IGV4cG9ydHM6IHt9IH0sIGVuLCBxaTtcbmZ1bmN0aW9uIGhjKCkge1xuICBpZiAocWkpXG4gICAgcmV0dXJuIGVuO1xuICBxaSA9IDE7XG4gIHZhciB0ID0gMWUzLCBlID0gdCAqIDYwLCByID0gZSAqIDYwLCBuID0gciAqIDI0LCBpID0gbiAqIDcsIHMgPSBuICogMzY1LjI1O1xuICBlbiA9IGZ1bmN0aW9uKGYsIHUpIHtcbiAgICB1ID0gdSB8fCB7fTtcbiAgICB2YXIgaCA9IHR5cGVvZiBmO1xuICAgIGlmIChoID09PSBcInN0cmluZ1wiICYmIGYubGVuZ3RoID4gMClcbiAgICAgIHJldHVybiBvKGYpO1xuICAgIGlmIChoID09PSBcIm51bWJlclwiICYmIGlzRmluaXRlKGYpKVxuICAgICAgcmV0dXJuIHUubG9uZyA/IGMoZikgOiBhKGYpO1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwidmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSB2YWxpZCBudW1iZXIuIHZhbD1cIiArIEpTT04uc3RyaW5naWZ5KGYpXG4gICAgKTtcbiAgfTtcbiAgZnVuY3Rpb24gbyhmKSB7XG4gICAgaWYgKGYgPSBTdHJpbmcoZiksICEoZi5sZW5ndGggPiAxMDApKSB7XG4gICAgICB2YXIgdSA9IC9eKC0/KD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx3ZWVrcz98d3x5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhcbiAgICAgICAgZlxuICAgICAgKTtcbiAgICAgIGlmICghIXUpIHtcbiAgICAgICAgdmFyIGggPSBwYXJzZUZsb2F0KHVbMV0pLCBkID0gKHVbMl0gfHwgXCJtc1wiKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBzd2l0Y2ggKGQpIHtcbiAgICAgICAgICBjYXNlIFwieWVhcnNcIjpcbiAgICAgICAgICBjYXNlIFwieWVhclwiOlxuICAgICAgICAgIGNhc2UgXCJ5cnNcIjpcbiAgICAgICAgICBjYXNlIFwieXJcIjpcbiAgICAgICAgICBjYXNlIFwieVwiOlxuICAgICAgICAgICAgcmV0dXJuIGggKiBzO1xuICAgICAgICAgIGNhc2UgXCJ3ZWVrc1wiOlxuICAgICAgICAgIGNhc2UgXCJ3ZWVrXCI6XG4gICAgICAgICAgY2FzZSBcIndcIjpcbiAgICAgICAgICAgIHJldHVybiBoICogaTtcbiAgICAgICAgICBjYXNlIFwiZGF5c1wiOlxuICAgICAgICAgIGNhc2UgXCJkYXlcIjpcbiAgICAgICAgICBjYXNlIFwiZFwiOlxuICAgICAgICAgICAgcmV0dXJuIGggKiBuO1xuICAgICAgICAgIGNhc2UgXCJob3Vyc1wiOlxuICAgICAgICAgIGNhc2UgXCJob3VyXCI6XG4gICAgICAgICAgY2FzZSBcImhyc1wiOlxuICAgICAgICAgIGNhc2UgXCJoclwiOlxuICAgICAgICAgIGNhc2UgXCJoXCI6XG4gICAgICAgICAgICByZXR1cm4gaCAqIHI7XG4gICAgICAgICAgY2FzZSBcIm1pbnV0ZXNcIjpcbiAgICAgICAgICBjYXNlIFwibWludXRlXCI6XG4gICAgICAgICAgY2FzZSBcIm1pbnNcIjpcbiAgICAgICAgICBjYXNlIFwibWluXCI6XG4gICAgICAgICAgY2FzZSBcIm1cIjpcbiAgICAgICAgICAgIHJldHVybiBoICogZTtcbiAgICAgICAgICBjYXNlIFwic2Vjb25kc1wiOlxuICAgICAgICAgIGNhc2UgXCJzZWNvbmRcIjpcbiAgICAgICAgICBjYXNlIFwic2Vjc1wiOlxuICAgICAgICAgIGNhc2UgXCJzZWNcIjpcbiAgICAgICAgICBjYXNlIFwic1wiOlxuICAgICAgICAgICAgcmV0dXJuIGggKiB0O1xuICAgICAgICAgIGNhc2UgXCJtaWxsaXNlY29uZHNcIjpcbiAgICAgICAgICBjYXNlIFwibWlsbGlzZWNvbmRcIjpcbiAgICAgICAgICBjYXNlIFwibXNlY3NcIjpcbiAgICAgICAgICBjYXNlIFwibXNlY1wiOlxuICAgICAgICAgIGNhc2UgXCJtc1wiOlxuICAgICAgICAgICAgcmV0dXJuIGg7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBhKGYpIHtcbiAgICB2YXIgdSA9IE1hdGguYWJzKGYpO1xuICAgIHJldHVybiB1ID49IG4gPyBNYXRoLnJvdW5kKGYgLyBuKSArIFwiZFwiIDogdSA+PSByID8gTWF0aC5yb3VuZChmIC8gcikgKyBcImhcIiA6IHUgPj0gZSA/IE1hdGgucm91bmQoZiAvIGUpICsgXCJtXCIgOiB1ID49IHQgPyBNYXRoLnJvdW5kKGYgLyB0KSArIFwic1wiIDogZiArIFwibXNcIjtcbiAgfVxuICBmdW5jdGlvbiBjKGYpIHtcbiAgICB2YXIgdSA9IE1hdGguYWJzKGYpO1xuICAgIHJldHVybiB1ID49IG4gPyBsKGYsIHUsIG4sIFwiZGF5XCIpIDogdSA+PSByID8gbChmLCB1LCByLCBcImhvdXJcIikgOiB1ID49IGUgPyBsKGYsIHUsIGUsIFwibWludXRlXCIpIDogdSA+PSB0ID8gbChmLCB1LCB0LCBcInNlY29uZFwiKSA6IGYgKyBcIiBtc1wiO1xuICB9XG4gIGZ1bmN0aW9uIGwoZiwgdSwgaCwgZCkge1xuICAgIHZhciBwID0gdSA+PSBoICogMS41O1xuICAgIHJldHVybiBNYXRoLnJvdW5kKGYgLyBoKSArIFwiIFwiICsgZCArIChwID8gXCJzXCIgOiBcIlwiKTtcbiAgfVxuICByZXR1cm4gZW47XG59XG5mdW5jdGlvbiBkYyh0KSB7XG4gIHIuZGVidWcgPSByLCByLmRlZmF1bHQgPSByLCByLmNvZXJjZSA9IGMsIHIuZGlzYWJsZSA9IHMsIHIuZW5hYmxlID0gaSwgci5lbmFibGVkID0gbywgci5odW1hbml6ZSA9IGhjKCksIHIuZGVzdHJveSA9IGwsIE9iamVjdC5rZXlzKHQpLmZvckVhY2goKGYpID0+IHtcbiAgICByW2ZdID0gdFtmXTtcbiAgfSksIHIubmFtZXMgPSBbXSwgci5za2lwcyA9IFtdLCByLmZvcm1hdHRlcnMgPSB7fTtcbiAgZnVuY3Rpb24gZShmKSB7XG4gICAgbGV0IHUgPSAwO1xuICAgIGZvciAobGV0IGggPSAwOyBoIDwgZi5sZW5ndGg7IGgrKylcbiAgICAgIHUgPSAodSA8PCA1KSAtIHUgKyBmLmNoYXJDb2RlQXQoaCksIHUgfD0gMDtcbiAgICByZXR1cm4gci5jb2xvcnNbTWF0aC5hYnModSkgJSByLmNvbG9ycy5sZW5ndGhdO1xuICB9XG4gIHIuc2VsZWN0Q29sb3IgPSBlO1xuICBmdW5jdGlvbiByKGYpIHtcbiAgICBsZXQgdSwgaCA9IG51bGwsIGQsIHA7XG4gICAgZnVuY3Rpb24geSguLi5nKSB7XG4gICAgICBpZiAoIXkuZW5hYmxlZClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgdiA9IHksIF8gPSBOdW1iZXIobmV3IERhdGUoKSksIG0gPSBfIC0gKHUgfHwgXyk7XG4gICAgICB2LmRpZmYgPSBtLCB2LnByZXYgPSB1LCB2LmN1cnIgPSBfLCB1ID0gXywgZ1swXSA9IHIuY29lcmNlKGdbMF0pLCB0eXBlb2YgZ1swXSAhPSBcInN0cmluZ1wiICYmIGcudW5zaGlmdChcIiVPXCIpO1xuICAgICAgbGV0IEMgPSAwO1xuICAgICAgZ1swXSA9IGdbMF0ucmVwbGFjZSgvJShbYS16QS1aJV0pL2csICh3LCB4KSA9PiB7XG4gICAgICAgIGlmICh3ID09PSBcIiUlXCIpXG4gICAgICAgICAgcmV0dXJuIFwiJVwiO1xuICAgICAgICBDKys7XG4gICAgICAgIGNvbnN0IEEgPSByLmZvcm1hdHRlcnNbeF07XG4gICAgICAgIGlmICh0eXBlb2YgQSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBjb25zdCBCID0gZ1tDXTtcbiAgICAgICAgICB3ID0gQS5jYWxsKHYsIEIpLCBnLnNwbGljZShDLCAxKSwgQy0tO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3O1xuICAgICAgfSksIHIuZm9ybWF0QXJncy5jYWxsKHYsIGcpLCAodi5sb2cgfHwgci5sb2cpLmFwcGx5KHYsIGcpO1xuICAgIH1cbiAgICByZXR1cm4geS5uYW1lc3BhY2UgPSBmLCB5LnVzZUNvbG9ycyA9IHIudXNlQ29sb3JzKCksIHkuY29sb3IgPSByLnNlbGVjdENvbG9yKGYpLCB5LmV4dGVuZCA9IG4sIHkuZGVzdHJveSA9IHIuZGVzdHJveSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHksIFwiZW5hYmxlZFwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICBnZXQ6ICgpID0+IGggIT09IG51bGwgPyBoIDogKGQgIT09IHIubmFtZXNwYWNlcyAmJiAoZCA9IHIubmFtZXNwYWNlcywgcCA9IHIuZW5hYmxlZChmKSksIHApLFxuICAgICAgc2V0OiAoZykgPT4ge1xuICAgICAgICBoID0gZztcbiAgICAgIH1cbiAgICB9KSwgdHlwZW9mIHIuaW5pdCA9PSBcImZ1bmN0aW9uXCIgJiYgci5pbml0KHkpLCB5O1xuICB9XG4gIGZ1bmN0aW9uIG4oZiwgdSkge1xuICAgIGNvbnN0IGggPSByKHRoaXMubmFtZXNwYWNlICsgKHR5cGVvZiB1ID4gXCJ1XCIgPyBcIjpcIiA6IHUpICsgZik7XG4gICAgcmV0dXJuIGgubG9nID0gdGhpcy5sb2csIGg7XG4gIH1cbiAgZnVuY3Rpb24gaShmKSB7XG4gICAgci5zYXZlKGYpLCByLm5hbWVzcGFjZXMgPSBmLCByLm5hbWVzID0gW10sIHIuc2tpcHMgPSBbXTtcbiAgICBsZXQgdTtcbiAgICBjb25zdCBoID0gKHR5cGVvZiBmID09IFwic3RyaW5nXCIgPyBmIDogXCJcIikuc3BsaXQoL1tcXHMsXSsvKSwgZCA9IGgubGVuZ3RoO1xuICAgIGZvciAodSA9IDA7IHUgPCBkOyB1KyspXG4gICAgICAhaFt1XSB8fCAoZiA9IGhbdV0ucmVwbGFjZSgvXFwqL2csIFwiLio/XCIpLCBmWzBdID09PSBcIi1cIiA/IHIuc2tpcHMucHVzaChuZXcgUmVnRXhwKFwiXlwiICsgZi5zbGljZSgxKSArIFwiJFwiKSkgOiByLm5hbWVzLnB1c2gobmV3IFJlZ0V4cChcIl5cIiArIGYgKyBcIiRcIikpKTtcbiAgfVxuICBmdW5jdGlvbiBzKCkge1xuICAgIGNvbnN0IGYgPSBbXG4gICAgICAuLi5yLm5hbWVzLm1hcChhKSxcbiAgICAgIC4uLnIuc2tpcHMubWFwKGEpLm1hcCgodSkgPT4gXCItXCIgKyB1KVxuICAgIF0uam9pbihcIixcIik7XG4gICAgcmV0dXJuIHIuZW5hYmxlKFwiXCIpLCBmO1xuICB9XG4gIGZ1bmN0aW9uIG8oZikge1xuICAgIGlmIChmW2YubGVuZ3RoIC0gMV0gPT09IFwiKlwiKVxuICAgICAgcmV0dXJuICEwO1xuICAgIGxldCB1LCBoO1xuICAgIGZvciAodSA9IDAsIGggPSByLnNraXBzLmxlbmd0aDsgdSA8IGg7IHUrKylcbiAgICAgIGlmIChyLnNraXBzW3VdLnRlc3QoZikpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICBmb3IgKHUgPSAwLCBoID0gci5uYW1lcy5sZW5ndGg7IHUgPCBoOyB1KyspXG4gICAgICBpZiAoci5uYW1lc1t1XS50ZXN0KGYpKVxuICAgICAgICByZXR1cm4gITA7XG4gICAgcmV0dXJuICExO1xuICB9XG4gIGZ1bmN0aW9uIGEoZikge1xuICAgIHJldHVybiBmLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIsIGYudG9TdHJpbmcoKS5sZW5ndGggLSAyKS5yZXBsYWNlKC9cXC5cXCpcXD8kLywgXCIqXCIpO1xuICB9XG4gIGZ1bmN0aW9uIGMoZikge1xuICAgIHJldHVybiBmIGluc3RhbmNlb2YgRXJyb3IgPyBmLnN0YWNrIHx8IGYubWVzc2FnZSA6IGY7XG4gIH1cbiAgZnVuY3Rpb24gbCgpIHtcbiAgICBjb25zb2xlLndhcm4oXCJJbnN0YW5jZSBtZXRob2QgYGRlYnVnLmRlc3Ryb3koKWAgaXMgZGVwcmVjYXRlZCBhbmQgbm8gbG9uZ2VyIGRvZXMgYW55dGhpbmcuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIG9mIGBkZWJ1Z2AuXCIpO1xuICB9XG4gIHJldHVybiByLmVuYWJsZShyLmxvYWQoKSksIHI7XG59XG52YXIgcGMgPSBkYztcbihmdW5jdGlvbih0LCBlKSB7XG4gIGUuZm9ybWF0QXJncyA9IG4sIGUuc2F2ZSA9IGksIGUubG9hZCA9IHMsIGUudXNlQ29sb3JzID0gciwgZS5zdG9yYWdlID0gbygpLCBlLmRlc3Ryb3kgPSAoKCkgPT4ge1xuICAgIGxldCBjID0gITE7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGMgfHwgKGMgPSAhMCwgY29uc29sZS53YXJuKFwiSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLlwiKSk7XG4gICAgfTtcbiAgfSkoKSwgZS5jb2xvcnMgPSBbXG4gICAgXCIjMDAwMENDXCIsXG4gICAgXCIjMDAwMEZGXCIsXG4gICAgXCIjMDAzM0NDXCIsXG4gICAgXCIjMDAzM0ZGXCIsXG4gICAgXCIjMDA2NkNDXCIsXG4gICAgXCIjMDA2NkZGXCIsXG4gICAgXCIjMDA5OUNDXCIsXG4gICAgXCIjMDA5OUZGXCIsXG4gICAgXCIjMDBDQzAwXCIsXG4gICAgXCIjMDBDQzMzXCIsXG4gICAgXCIjMDBDQzY2XCIsXG4gICAgXCIjMDBDQzk5XCIsXG4gICAgXCIjMDBDQ0NDXCIsXG4gICAgXCIjMDBDQ0ZGXCIsXG4gICAgXCIjMzMwMENDXCIsXG4gICAgXCIjMzMwMEZGXCIsXG4gICAgXCIjMzMzM0NDXCIsXG4gICAgXCIjMzMzM0ZGXCIsXG4gICAgXCIjMzM2NkNDXCIsXG4gICAgXCIjMzM2NkZGXCIsXG4gICAgXCIjMzM5OUNDXCIsXG4gICAgXCIjMzM5OUZGXCIsXG4gICAgXCIjMzNDQzAwXCIsXG4gICAgXCIjMzNDQzMzXCIsXG4gICAgXCIjMzNDQzY2XCIsXG4gICAgXCIjMzNDQzk5XCIsXG4gICAgXCIjMzNDQ0NDXCIsXG4gICAgXCIjMzNDQ0ZGXCIsXG4gICAgXCIjNjYwMENDXCIsXG4gICAgXCIjNjYwMEZGXCIsXG4gICAgXCIjNjYzM0NDXCIsXG4gICAgXCIjNjYzM0ZGXCIsXG4gICAgXCIjNjZDQzAwXCIsXG4gICAgXCIjNjZDQzMzXCIsXG4gICAgXCIjOTkwMENDXCIsXG4gICAgXCIjOTkwMEZGXCIsXG4gICAgXCIjOTkzM0NDXCIsXG4gICAgXCIjOTkzM0ZGXCIsXG4gICAgXCIjOTlDQzAwXCIsXG4gICAgXCIjOTlDQzMzXCIsXG4gICAgXCIjQ0MwMDAwXCIsXG4gICAgXCIjQ0MwMDMzXCIsXG4gICAgXCIjQ0MwMDY2XCIsXG4gICAgXCIjQ0MwMDk5XCIsXG4gICAgXCIjQ0MwMENDXCIsXG4gICAgXCIjQ0MwMEZGXCIsXG4gICAgXCIjQ0MzMzAwXCIsXG4gICAgXCIjQ0MzMzMzXCIsXG4gICAgXCIjQ0MzMzY2XCIsXG4gICAgXCIjQ0MzMzk5XCIsXG4gICAgXCIjQ0MzM0NDXCIsXG4gICAgXCIjQ0MzM0ZGXCIsXG4gICAgXCIjQ0M2NjAwXCIsXG4gICAgXCIjQ0M2NjMzXCIsXG4gICAgXCIjQ0M5OTAwXCIsXG4gICAgXCIjQ0M5OTMzXCIsXG4gICAgXCIjQ0NDQzAwXCIsXG4gICAgXCIjQ0NDQzMzXCIsXG4gICAgXCIjRkYwMDAwXCIsXG4gICAgXCIjRkYwMDMzXCIsXG4gICAgXCIjRkYwMDY2XCIsXG4gICAgXCIjRkYwMDk5XCIsXG4gICAgXCIjRkYwMENDXCIsXG4gICAgXCIjRkYwMEZGXCIsXG4gICAgXCIjRkYzMzAwXCIsXG4gICAgXCIjRkYzMzMzXCIsXG4gICAgXCIjRkYzMzY2XCIsXG4gICAgXCIjRkYzMzk5XCIsXG4gICAgXCIjRkYzM0NDXCIsXG4gICAgXCIjRkYzM0ZGXCIsXG4gICAgXCIjRkY2NjAwXCIsXG4gICAgXCIjRkY2NjMzXCIsXG4gICAgXCIjRkY5OTAwXCIsXG4gICAgXCIjRkY5OTMzXCIsXG4gICAgXCIjRkZDQzAwXCIsXG4gICAgXCIjRkZDQzMzXCJcbiAgXTtcbiAgZnVuY3Rpb24gcigpIHtcbiAgICByZXR1cm4gdHlwZW9mIHdpbmRvdyA8IFwidVwiICYmIHdpbmRvdy5wcm9jZXNzICYmICh3aW5kb3cucHJvY2Vzcy50eXBlID09PSBcInJlbmRlcmVyXCIgfHwgd2luZG93LnByb2Nlc3MuX19ud2pzKSA/ICEwIDogdHlwZW9mIG5hdmlnYXRvciA8IFwidVwiICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC8oZWRnZXx0cmlkZW50KVxcLyhcXGQrKS8pID8gITEgOiB0eXBlb2YgZG9jdW1lbnQgPCBcInVcIiAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlIHx8IHR5cGVvZiB3aW5kb3cgPCBcInVcIiAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCB3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpIHx8IHR5cGVvZiBuYXZpZ2F0b3IgPCBcInVcIiAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pICYmIHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApID49IDMxIHx8IHR5cGVvZiBuYXZpZ2F0b3IgPCBcInVcIiAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKTtcbiAgfVxuICBmdW5jdGlvbiBuKGMpIHtcbiAgICBpZiAoY1swXSA9ICh0aGlzLnVzZUNvbG9ycyA/IFwiJWNcIiA6IFwiXCIpICsgdGhpcy5uYW1lc3BhY2UgKyAodGhpcy51c2VDb2xvcnMgPyBcIiAlY1wiIDogXCIgXCIpICsgY1swXSArICh0aGlzLnVzZUNvbG9ycyA/IFwiJWMgXCIgOiBcIiBcIikgKyBcIitcIiArIHQuZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpLCAhdGhpcy51c2VDb2xvcnMpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbCA9IFwiY29sb3I6IFwiICsgdGhpcy5jb2xvcjtcbiAgICBjLnNwbGljZSgxLCAwLCBsLCBcImNvbG9yOiBpbmhlcml0XCIpO1xuICAgIGxldCBmID0gMCwgdSA9IDA7XG4gICAgY1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIChoKSA9PiB7XG4gICAgICBoICE9PSBcIiUlXCIgJiYgKGYrKywgaCA9PT0gXCIlY1wiICYmICh1ID0gZikpO1xuICAgIH0pLCBjLnNwbGljZSh1LCAwLCBsKTtcbiAgfVxuICBlLmxvZyA9IGNvbnNvbGUuZGVidWcgfHwgY29uc29sZS5sb2cgfHwgKCgpID0+IHtcbiAgfSk7XG4gIGZ1bmN0aW9uIGkoYykge1xuICAgIHRyeSB7XG4gICAgICBjID8gZS5zdG9yYWdlLnNldEl0ZW0oXCJkZWJ1Z1wiLCBjKSA6IGUuc3RvcmFnZS5yZW1vdmVJdGVtKFwiZGVidWdcIik7XG4gICAgfSBjYXRjaCB7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHMoKSB7XG4gICAgbGV0IGM7XG4gICAgdHJ5IHtcbiAgICAgIGMgPSBlLnN0b3JhZ2UuZ2V0SXRlbShcImRlYnVnXCIpO1xuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgICByZXR1cm4gIWMgJiYgdHlwZW9mIHByb2Nlc3MgPCBcInVcIiAmJiBcImVudlwiIGluIHByb2Nlc3MgJiYgKGMgPSBwcm9jZXNzLmVudi5ERUJVRyksIGM7XG4gIH1cbiAgZnVuY3Rpb24gbygpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGxvY2FsU3RvcmFnZTtcbiAgICB9IGNhdGNoIHtcbiAgICB9XG4gIH1cbiAgdC5leHBvcnRzID0gcGMoZSk7XG4gIGNvbnN0IHsgZm9ybWF0dGVyczogYSB9ID0gdC5leHBvcnRzO1xuICBhLmogPSBmdW5jdGlvbihjKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShjKTtcbiAgICB9IGNhdGNoIChsKSB7XG4gICAgICByZXR1cm4gXCJbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogXCIgKyBsLm1lc3NhZ2U7XG4gICAgfVxuICB9O1xufSkoT24sIE9uLmV4cG9ydHMpO1xuY29uc3QgTW4gPSBPbi5leHBvcnRzO1xudmFyIFpvID0geyBleHBvcnRzOiB7fSB9O1xuKGZ1bmN0aW9uKHQpIHtcbiAgdmFyIGUgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LCByID0gXCJ+XCI7XG4gIGZ1bmN0aW9uIG4oKSB7XG4gIH1cbiAgT2JqZWN0LmNyZWF0ZSAmJiAobi5wcm90b3R5cGUgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSwgbmV3IG4oKS5fX3Byb3RvX18gfHwgKHIgPSAhMSkpO1xuICBmdW5jdGlvbiBpKGMsIGwsIGYpIHtcbiAgICB0aGlzLmZuID0gYywgdGhpcy5jb250ZXh0ID0gbCwgdGhpcy5vbmNlID0gZiB8fCAhMTtcbiAgfVxuICBmdW5jdGlvbiBzKGMsIGwsIGYsIHUsIGgpIHtcbiAgICBpZiAodHlwZW9mIGYgIT0gXCJmdW5jdGlvblwiKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gICAgdmFyIGQgPSBuZXcgaShmLCB1IHx8IGMsIGgpLCBwID0gciA/IHIgKyBsIDogbDtcbiAgICByZXR1cm4gYy5fZXZlbnRzW3BdID8gYy5fZXZlbnRzW3BdLmZuID8gYy5fZXZlbnRzW3BdID0gW2MuX2V2ZW50c1twXSwgZF0gOiBjLl9ldmVudHNbcF0ucHVzaChkKSA6IChjLl9ldmVudHNbcF0gPSBkLCBjLl9ldmVudHNDb3VudCsrKSwgYztcbiAgfVxuICBmdW5jdGlvbiBvKGMsIGwpIHtcbiAgICAtLWMuX2V2ZW50c0NvdW50ID09PSAwID8gYy5fZXZlbnRzID0gbmV3IG4oKSA6IGRlbGV0ZSBjLl9ldmVudHNbbF07XG4gIH1cbiAgZnVuY3Rpb24gYSgpIHtcbiAgICB0aGlzLl9ldmVudHMgPSBuZXcgbigpLCB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cbiAgYS5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBsID0gW10sIGYsIHU7XG4gICAgaWYgKHRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgcmV0dXJuIGw7XG4gICAgZm9yICh1IGluIGYgPSB0aGlzLl9ldmVudHMpXG4gICAgICBlLmNhbGwoZiwgdSkgJiYgbC5wdXNoKHIgPyB1LnNsaWNlKDEpIDogdSk7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBsLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGYpKSA6IGw7XG4gIH0sIGEucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKGwpIHtcbiAgICB2YXIgZiA9IHIgPyByICsgbCA6IGwsIHUgPSB0aGlzLl9ldmVudHNbZl07XG4gICAgaWYgKCF1KVxuICAgICAgcmV0dXJuIFtdO1xuICAgIGlmICh1LmZuKVxuICAgICAgcmV0dXJuIFt1LmZuXTtcbiAgICBmb3IgKHZhciBoID0gMCwgZCA9IHUubGVuZ3RoLCBwID0gbmV3IEFycmF5KGQpOyBoIDwgZDsgaCsrKVxuICAgICAgcFtoXSA9IHVbaF0uZm47XG4gICAgcmV0dXJuIHA7XG4gIH0sIGEucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihsKSB7XG4gICAgdmFyIGYgPSByID8gciArIGwgOiBsLCB1ID0gdGhpcy5fZXZlbnRzW2ZdO1xuICAgIHJldHVybiB1ID8gdS5mbiA/IDEgOiB1Lmxlbmd0aCA6IDA7XG4gIH0sIGEucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihsLCBmLCB1LCBoLCBkLCBwKSB7XG4gICAgdmFyIHkgPSByID8gciArIGwgOiBsO1xuICAgIGlmICghdGhpcy5fZXZlbnRzW3ldKVxuICAgICAgcmV0dXJuICExO1xuICAgIHZhciBnID0gdGhpcy5fZXZlbnRzW3ldLCB2ID0gYXJndW1lbnRzLmxlbmd0aCwgXywgbTtcbiAgICBpZiAoZy5mbikge1xuICAgICAgc3dpdGNoIChnLm9uY2UgJiYgdGhpcy5yZW1vdmVMaXN0ZW5lcihsLCBnLmZuLCB2b2lkIDAsICEwKSwgdikge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcmV0dXJuIGcuZm4uY2FsbChnLmNvbnRleHQpLCAhMDtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHJldHVybiBnLmZuLmNhbGwoZy5jb250ZXh0LCBmKSwgITA7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICByZXR1cm4gZy5mbi5jYWxsKGcuY29udGV4dCwgZiwgdSksICEwO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgcmV0dXJuIGcuZm4uY2FsbChnLmNvbnRleHQsIGYsIHUsIGgpLCAhMDtcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHJldHVybiBnLmZuLmNhbGwoZy5jb250ZXh0LCBmLCB1LCBoLCBkKSwgITA7XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgICByZXR1cm4gZy5mbi5jYWxsKGcuY29udGV4dCwgZiwgdSwgaCwgZCwgcCksICEwO1xuICAgICAgfVxuICAgICAgZm9yIChtID0gMSwgXyA9IG5ldyBBcnJheSh2IC0gMSk7IG0gPCB2OyBtKyspXG4gICAgICAgIF9bbSAtIDFdID0gYXJndW1lbnRzW21dO1xuICAgICAgZy5mbi5hcHBseShnLmNvbnRleHQsIF8pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgQyA9IGcubGVuZ3RoLCBPO1xuICAgICAgZm9yIChtID0gMDsgbSA8IEM7IG0rKylcbiAgICAgICAgc3dpdGNoIChnW21dLm9uY2UgJiYgdGhpcy5yZW1vdmVMaXN0ZW5lcihsLCBnW21dLmZuLCB2b2lkIDAsICEwKSwgdikge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGdbbV0uZm4uY2FsbChnW21dLmNvbnRleHQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgZ1ttXS5mbi5jYWxsKGdbbV0uY29udGV4dCwgZik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBnW21dLmZuLmNhbGwoZ1ttXS5jb250ZXh0LCBmLCB1KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIGdbbV0uZm4uY2FsbChnW21dLmNvbnRleHQsIGYsIHUsIGgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmICghXylcbiAgICAgICAgICAgICAgZm9yIChPID0gMSwgXyA9IG5ldyBBcnJheSh2IC0gMSk7IE8gPCB2OyBPKyspXG4gICAgICAgICAgICAgICAgX1tPIC0gMV0gPSBhcmd1bWVudHNbT107XG4gICAgICAgICAgICBnW21dLmZuLmFwcGx5KGdbbV0uY29udGV4dCwgXyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICEwO1xuICB9LCBhLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKGwsIGYsIHUpIHtcbiAgICByZXR1cm4gcyh0aGlzLCBsLCBmLCB1LCAhMSk7XG4gIH0sIGEucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbihsLCBmLCB1KSB7XG4gICAgcmV0dXJuIHModGhpcywgbCwgZiwgdSwgITApO1xuICB9LCBhLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKGwsIGYsIHUsIGgpIHtcbiAgICB2YXIgZCA9IHIgPyByICsgbCA6IGw7XG4gICAgaWYgKCF0aGlzLl9ldmVudHNbZF0pXG4gICAgICByZXR1cm4gdGhpcztcbiAgICBpZiAoIWYpXG4gICAgICByZXR1cm4gbyh0aGlzLCBkKSwgdGhpcztcbiAgICB2YXIgcCA9IHRoaXMuX2V2ZW50c1tkXTtcbiAgICBpZiAocC5mbilcbiAgICAgIHAuZm4gPT09IGYgJiYgKCFoIHx8IHAub25jZSkgJiYgKCF1IHx8IHAuY29udGV4dCA9PT0gdSkgJiYgbyh0aGlzLCBkKTtcbiAgICBlbHNlIHtcbiAgICAgIGZvciAodmFyIHkgPSAwLCBnID0gW10sIHYgPSBwLmxlbmd0aDsgeSA8IHY7IHkrKylcbiAgICAgICAgKHBbeV0uZm4gIT09IGYgfHwgaCAmJiAhcFt5XS5vbmNlIHx8IHUgJiYgcFt5XS5jb250ZXh0ICE9PSB1KSAmJiBnLnB1c2gocFt5XSk7XG4gICAgICBnLmxlbmd0aCA/IHRoaXMuX2V2ZW50c1tkXSA9IGcubGVuZ3RoID09PSAxID8gZ1swXSA6IGcgOiBvKHRoaXMsIGQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSwgYS5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24obCkge1xuICAgIHZhciBmO1xuICAgIHJldHVybiBsID8gKGYgPSByID8gciArIGwgOiBsLCB0aGlzLl9ldmVudHNbZl0gJiYgbyh0aGlzLCBmKSkgOiAodGhpcy5fZXZlbnRzID0gbmV3IG4oKSwgdGhpcy5fZXZlbnRzQ291bnQgPSAwKSwgdGhpcztcbiAgfSwgYS5wcm90b3R5cGUub2ZmID0gYS5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIsIGEucHJvdG90eXBlLmFkZExpc3RlbmVyID0gYS5wcm90b3R5cGUub24sIGEucHJlZml4ZWQgPSByLCBhLkV2ZW50RW1pdHRlciA9IGEsIHQuZXhwb3J0cyA9IGE7XG59KShabyk7XG5jb25zdCBkdCA9IFpvLmV4cG9ydHM7XG5mdW5jdGlvbiBBbih0KSB7XG4gIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIodCkgfHwgdCA8IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKGBXcm9uZyBwb3NpdGl2ZSBpbnRlZ2VyOiAke3R9YCk7XG59XG5mdW5jdGlvbiB5Yyh0KSB7XG4gIGlmICh0eXBlb2YgdCAhPSBcImJvb2xlYW5cIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGJvb2xlYW4sIG5vdCAke3R9YCk7XG59XG5mdW5jdGlvbiBZbyh0LCAuLi5lKSB7XG4gIGlmICghKHQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgVWludDhBcnJheVwiKTtcbiAgaWYgKGUubGVuZ3RoID4gMCAmJiAhZS5pbmNsdWRlcyh0Lmxlbmd0aCkpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgVWludDhBcnJheSBvZiBsZW5ndGggJHtlfSwgbm90IG9mIGxlbmd0aD0ke3QubGVuZ3RofWApO1xufVxuZnVuY3Rpb24gZ2ModCkge1xuICBpZiAodHlwZW9mIHQgIT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiB0LmNyZWF0ZSAhPSBcImZ1bmN0aW9uXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSGFzaCBzaG91bGQgYmUgd3JhcHBlZCBieSB1dGlscy53cmFwQ29uc3RydWN0b3JcIik7XG4gIEFuKHQub3V0cHV0TGVuKSwgQW4odC5ibG9ja0xlbik7XG59XG5mdW5jdGlvbiBiYyh0LCBlID0gITApIHtcbiAgaWYgKHQuZGVzdHJveWVkKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkhhc2ggaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkXCIpO1xuICBpZiAoZSAmJiB0LmZpbmlzaGVkKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkhhc2gjZGlnZXN0KCkgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWRcIik7XG59XG5mdW5jdGlvbiB2Yyh0LCBlKSB7XG4gIFlvKHQpO1xuICBjb25zdCByID0gZS5vdXRwdXRMZW47XG4gIGlmICh0Lmxlbmd0aCA8IHIpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBkaWdlc3RJbnRvKCkgZXhwZWN0cyBvdXRwdXQgYnVmZmVyIG9mIGxlbmd0aCBhdCBsZWFzdCAke3J9YCk7XG59XG5jb25zdCB1dCA9IHtcbiAgbnVtYmVyOiBBbixcbiAgYm9vbDogeWMsXG4gIGJ5dGVzOiBZbyxcbiAgaGFzaDogZ2MsXG4gIGV4aXN0czogYmMsXG4gIG91dHB1dDogdmNcbn0sIHRuID0gdHlwZW9mIGdsb2JhbFRoaXMgPT0gXCJvYmplY3RcIiAmJiBcImNyeXB0b1wiIGluIGdsb2JhbFRoaXMgPyBnbG9iYWxUaGlzLmNyeXB0byA6IHZvaWQgMDtcbi8qISBub2JsZS1oYXNoZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmNvbnN0IHJuID0gKHQpID0+IG5ldyBEYXRhVmlldyh0LmJ1ZmZlciwgdC5ieXRlT2Zmc2V0LCB0LmJ5dGVMZW5ndGgpLCBBZSA9ICh0LCBlKSA9PiB0IDw8IDMyIC0gZSB8IHQgPj4+IGUsIHdjID0gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQzMkFycmF5KFsyODc0NTQwMjBdKS5idWZmZXIpWzBdID09PSA2ODtcbmlmICghd2MpXG4gIHRocm93IG5ldyBFcnJvcihcIk5vbiBsaXR0bGUtZW5kaWFuIGhhcmR3YXJlIGlzIG5vdCBzdXBwb3J0ZWRcIik7XG5BcnJheS5mcm9tKHsgbGVuZ3RoOiAyNTYgfSwgKHQsIGUpID0+IGUudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKSk7XG5mdW5jdGlvbiBfYyh0KSB7XG4gIGlmICh0eXBlb2YgdCAhPSBcInN0cmluZ1wiKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHV0ZjhUb0J5dGVzIGV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIHR9YCk7XG4gIHJldHVybiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUodCk7XG59XG5mdW5jdGlvbiBEbih0KSB7XG4gIGlmICh0eXBlb2YgdCA9PSBcInN0cmluZ1wiICYmICh0ID0gX2ModCkpLCAhKHQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBpbnB1dCB0eXBlIGlzIFVpbnQ4QXJyYXkgKGdvdCAke3R5cGVvZiB0fSlgKTtcbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBtYyguLi50KSB7XG4gIGlmICghdC5ldmVyeSgobikgPT4gbiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgIHRocm93IG5ldyBFcnJvcihcIlVpbnQ4QXJyYXkgbGlzdCBleHBlY3RlZFwiKTtcbiAgaWYgKHQubGVuZ3RoID09PSAxKVxuICAgIHJldHVybiB0WzBdO1xuICBjb25zdCBlID0gdC5yZWR1Y2UoKG4sIGkpID0+IG4gKyBpLmxlbmd0aCwgMCksIHIgPSBuZXcgVWludDhBcnJheShlKTtcbiAgZm9yIChsZXQgbiA9IDAsIGkgPSAwOyBuIDwgdC5sZW5ndGg7IG4rKykge1xuICAgIGNvbnN0IHMgPSB0W25dO1xuICAgIHIuc2V0KHMsIGkpLCBpICs9IHMubGVuZ3RoO1xuICB9XG4gIHJldHVybiByO1xufVxuY2xhc3MgSm8ge1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2xvbmVJbnRvKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIFhvKHQpIHtcbiAgY29uc3QgZSA9IChuKSA9PiB0KCkudXBkYXRlKERuKG4pKS5kaWdlc3QoKSwgciA9IHQoKTtcbiAgcmV0dXJuIGUub3V0cHV0TGVuID0gci5vdXRwdXRMZW4sIGUuYmxvY2tMZW4gPSByLmJsb2NrTGVuLCBlLmNyZWF0ZSA9ICgpID0+IHQoKSwgZTtcbn1cbmZ1bmN0aW9uIFFvKHQgPSAzMikge1xuICBpZiAodG4gJiYgdHlwZW9mIHRuLmdldFJhbmRvbVZhbHVlcyA9PSBcImZ1bmN0aW9uXCIpXG4gICAgcmV0dXJuIHRuLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheSh0KSk7XG4gIHRocm93IG5ldyBFcnJvcihcImNyeXB0by5nZXRSYW5kb21WYWx1ZXMgbXVzdCBiZSBkZWZpbmVkXCIpO1xufVxuZnVuY3Rpb24geGModCwgZSwgciwgbikge1xuICBpZiAodHlwZW9mIHQuc2V0QmlnVWludDY0ID09IFwiZnVuY3Rpb25cIilcbiAgICByZXR1cm4gdC5zZXRCaWdVaW50NjQoZSwgciwgbik7XG4gIGNvbnN0IGkgPSBCaWdJbnQoMzIpLCBzID0gQmlnSW50KDQyOTQ5NjcyOTUpLCBvID0gTnVtYmVyKHIgPj4gaSAmIHMpLCBhID0gTnVtYmVyKHIgJiBzKSwgYyA9IG4gPyA0IDogMCwgbCA9IG4gPyAwIDogNDtcbiAgdC5zZXRVaW50MzIoZSArIGMsIG8sIG4pLCB0LnNldFVpbnQzMihlICsgbCwgYSwgbik7XG59XG5jbGFzcyBFYyBleHRlbmRzIEpvIHtcbiAgY29uc3RydWN0b3IoZSwgciwgbiwgaSkge1xuICAgIHN1cGVyKCksIHRoaXMuYmxvY2tMZW4gPSBlLCB0aGlzLm91dHB1dExlbiA9IHIsIHRoaXMucGFkT2Zmc2V0ID0gbiwgdGhpcy5pc0xFID0gaSwgdGhpcy5maW5pc2hlZCA9ICExLCB0aGlzLmxlbmd0aCA9IDAsIHRoaXMucG9zID0gMCwgdGhpcy5kZXN0cm95ZWQgPSAhMSwgdGhpcy5idWZmZXIgPSBuZXcgVWludDhBcnJheShlKSwgdGhpcy52aWV3ID0gcm4odGhpcy5idWZmZXIpO1xuICB9XG4gIHVwZGF0ZShlKSB7XG4gICAgdXQuZXhpc3RzKHRoaXMpO1xuICAgIGNvbnN0IHsgdmlldzogciwgYnVmZmVyOiBuLCBibG9ja0xlbjogaSB9ID0gdGhpcztcbiAgICBlID0gRG4oZSk7XG4gICAgY29uc3QgcyA9IGUubGVuZ3RoO1xuICAgIGZvciAobGV0IG8gPSAwOyBvIDwgczsgKSB7XG4gICAgICBjb25zdCBhID0gTWF0aC5taW4oaSAtIHRoaXMucG9zLCBzIC0gbyk7XG4gICAgICBpZiAoYSA9PT0gaSkge1xuICAgICAgICBjb25zdCBjID0gcm4oZSk7XG4gICAgICAgIGZvciAoOyBpIDw9IHMgLSBvOyBvICs9IGkpXG4gICAgICAgICAgdGhpcy5wcm9jZXNzKGMsIG8pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIG4uc2V0KGUuc3ViYXJyYXkobywgbyArIGEpLCB0aGlzLnBvcyksIHRoaXMucG9zICs9IGEsIG8gKz0gYSwgdGhpcy5wb3MgPT09IGkgJiYgKHRoaXMucHJvY2VzcyhyLCAwKSwgdGhpcy5wb3MgPSAwKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubGVuZ3RoICs9IGUubGVuZ3RoLCB0aGlzLnJvdW5kQ2xlYW4oKSwgdGhpcztcbiAgfVxuICBkaWdlc3RJbnRvKGUpIHtcbiAgICB1dC5leGlzdHModGhpcyksIHV0Lm91dHB1dChlLCB0aGlzKSwgdGhpcy5maW5pc2hlZCA9ICEwO1xuICAgIGNvbnN0IHsgYnVmZmVyOiByLCB2aWV3OiBuLCBibG9ja0xlbjogaSwgaXNMRTogcyB9ID0gdGhpcztcbiAgICBsZXQgeyBwb3M6IG8gfSA9IHRoaXM7XG4gICAgcltvKytdID0gMTI4LCB0aGlzLmJ1ZmZlci5zdWJhcnJheShvKS5maWxsKDApLCB0aGlzLnBhZE9mZnNldCA+IGkgLSBvICYmICh0aGlzLnByb2Nlc3MobiwgMCksIG8gPSAwKTtcbiAgICBmb3IgKGxldCB1ID0gbzsgdSA8IGk7IHUrKylcbiAgICAgIHJbdV0gPSAwO1xuICAgIHhjKG4sIGkgLSA4LCBCaWdJbnQodGhpcy5sZW5ndGggKiA4KSwgcyksIHRoaXMucHJvY2VzcyhuLCAwKTtcbiAgICBjb25zdCBhID0gcm4oZSksIGMgPSB0aGlzLm91dHB1dExlbjtcbiAgICBpZiAoYyAlIDQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJfc2hhMjogb3V0cHV0TGVuIHNob3VsZCBiZSBhbGlnbmVkIHRvIDMyYml0XCIpO1xuICAgIGNvbnN0IGwgPSBjIC8gNCwgZiA9IHRoaXMuZ2V0KCk7XG4gICAgaWYgKGwgPiBmLmxlbmd0aClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIl9zaGEyOiBvdXRwdXRMZW4gYmlnZ2VyIHRoYW4gc3RhdGVcIik7XG4gICAgZm9yIChsZXQgdSA9IDA7IHUgPCBsOyB1KyspXG4gICAgICBhLnNldFVpbnQzMig0ICogdSwgZlt1XSwgcyk7XG4gIH1cbiAgZGlnZXN0KCkge1xuICAgIGNvbnN0IHsgYnVmZmVyOiBlLCBvdXRwdXRMZW46IHIgfSA9IHRoaXM7XG4gICAgdGhpcy5kaWdlc3RJbnRvKGUpO1xuICAgIGNvbnN0IG4gPSBlLnNsaWNlKDAsIHIpO1xuICAgIHJldHVybiB0aGlzLmRlc3Ryb3koKSwgbjtcbiAgfVxuICBfY2xvbmVJbnRvKGUpIHtcbiAgICBlIHx8IChlID0gbmV3IHRoaXMuY29uc3RydWN0b3IoKSksIGUuc2V0KC4uLnRoaXMuZ2V0KCkpO1xuICAgIGNvbnN0IHsgYmxvY2tMZW46IHIsIGJ1ZmZlcjogbiwgbGVuZ3RoOiBpLCBmaW5pc2hlZDogcywgZGVzdHJveWVkOiBvLCBwb3M6IGEgfSA9IHRoaXM7XG4gICAgcmV0dXJuIGUubGVuZ3RoID0gaSwgZS5wb3MgPSBhLCBlLmZpbmlzaGVkID0gcywgZS5kZXN0cm95ZWQgPSBvLCBpICUgciAmJiBlLmJ1ZmZlci5zZXQobiksIGU7XG4gIH1cbn1cbmNvbnN0IGtjID0gKHQsIGUsIHIpID0+IHQgJiBlIF4gfnQgJiByLCBTYyA9ICh0LCBlLCByKSA9PiB0ICYgZSBeIHQgJiByIF4gZSAmIHIsIE9jID0gbmV3IFVpbnQzMkFycmF5KFtcbiAgMTExNjM1MjQwOCxcbiAgMTg5OTQ0NzQ0MSxcbiAgMzA0OTMyMzQ3MSxcbiAgMzkyMTAwOTU3MyxcbiAgOTYxOTg3MTYzLFxuICAxNTA4OTcwOTkzLFxuICAyNDUzNjM1NzQ4LFxuICAyODcwNzYzMjIxLFxuICAzNjI0MzgxMDgwLFxuICAzMTA1OTg0MDEsXG4gIDYwNzIyNTI3OCxcbiAgMTQyNjg4MTk4NyxcbiAgMTkyNTA3ODM4OCxcbiAgMjE2MjA3ODIwNixcbiAgMjYxNDg4ODEwMyxcbiAgMzI0ODIyMjU4MCxcbiAgMzgzNTM5MDQwMSxcbiAgNDAyMjIyNDc3NCxcbiAgMjY0MzQ3MDc4LFxuICA2MDQ4MDc2MjgsXG4gIDc3MDI1NTk4MyxcbiAgMTI0OTE1MDEyMixcbiAgMTU1NTA4MTY5MixcbiAgMTk5NjA2NDk4NixcbiAgMjU1NDIyMDg4MixcbiAgMjgyMTgzNDM0OSxcbiAgMjk1Mjk5NjgwOCxcbiAgMzIxMDMxMzY3MSxcbiAgMzMzNjU3MTg5MSxcbiAgMzU4NDUyODcxMSxcbiAgMTEzOTI2OTkzLFxuICAzMzgyNDE4OTUsXG4gIDY2NjMwNzIwNSxcbiAgNzczNTI5OTEyLFxuICAxMjk0NzU3MzcyLFxuICAxMzk2MTgyMjkxLFxuICAxNjk1MTgzNzAwLFxuICAxOTg2NjYxMDUxLFxuICAyMTc3MDI2MzUwLFxuICAyNDU2OTU2MDM3LFxuICAyNzMwNDg1OTIxLFxuICAyODIwMzAyNDExLFxuICAzMjU5NzMwODAwLFxuICAzMzQ1NzY0NzcxLFxuICAzNTE2MDY1ODE3LFxuICAzNjAwMzUyODA0LFxuICA0MDk0NTcxOTA5LFxuICAyNzU0MjMzNDQsXG4gIDQzMDIyNzczNCxcbiAgNTA2OTQ4NjE2LFxuICA2NTkwNjA1NTYsXG4gIDg4Mzk5Nzg3NyxcbiAgOTU4MTM5NTcxLFxuICAxMzIyODIyMjE4LFxuICAxNTM3MDAyMDYzLFxuICAxNzQ3ODczNzc5LFxuICAxOTU1NTYyMjIyLFxuICAyMDI0MTA0ODE1LFxuICAyMjI3NzMwNDUyLFxuICAyMzYxODUyNDI0LFxuICAyNDI4NDM2NDc0LFxuICAyNzU2NzM0MTg3LFxuICAzMjA0MDMxNDc5LFxuICAzMzI5MzI1Mjk4XG5dKSwgTWUgPSBuZXcgVWludDMyQXJyYXkoW1xuICAxNzc5MDMzNzAzLFxuICAzMTQ0MTM0Mjc3LFxuICAxMDEzOTA0MjQyLFxuICAyNzczNDgwNzYyLFxuICAxMzU5ODkzMTE5LFxuICAyNjAwODIyOTI0LFxuICA1Mjg3MzQ2MzUsXG4gIDE1NDE0NTkyMjVcbl0pLCBEZSA9IG5ldyBVaW50MzJBcnJheSg2NCk7XG5jbGFzcyBlcyBleHRlbmRzIEVjIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoNjQsIDMyLCA4LCAhMSksIHRoaXMuQSA9IE1lWzBdIHwgMCwgdGhpcy5CID0gTWVbMV0gfCAwLCB0aGlzLkMgPSBNZVsyXSB8IDAsIHRoaXMuRCA9IE1lWzNdIHwgMCwgdGhpcy5FID0gTWVbNF0gfCAwLCB0aGlzLkYgPSBNZVs1XSB8IDAsIHRoaXMuRyA9IE1lWzZdIHwgMCwgdGhpcy5IID0gTWVbN10gfCAwO1xuICB9XG4gIGdldCgpIHtcbiAgICBjb25zdCB7IEE6IGUsIEI6IHIsIEM6IG4sIEQ6IGksIEU6IHMsIEY6IG8sIEc6IGEsIEg6IGMgfSA9IHRoaXM7XG4gICAgcmV0dXJuIFtlLCByLCBuLCBpLCBzLCBvLCBhLCBjXTtcbiAgfVxuICBzZXQoZSwgciwgbiwgaSwgcywgbywgYSwgYykge1xuICAgIHRoaXMuQSA9IGUgfCAwLCB0aGlzLkIgPSByIHwgMCwgdGhpcy5DID0gbiB8IDAsIHRoaXMuRCA9IGkgfCAwLCB0aGlzLkUgPSBzIHwgMCwgdGhpcy5GID0gbyB8IDAsIHRoaXMuRyA9IGEgfCAwLCB0aGlzLkggPSBjIHwgMDtcbiAgfVxuICBwcm9jZXNzKGUsIHIpIHtcbiAgICBmb3IgKGxldCB1ID0gMDsgdSA8IDE2OyB1KyssIHIgKz0gNClcbiAgICAgIERlW3VdID0gZS5nZXRVaW50MzIociwgITEpO1xuICAgIGZvciAobGV0IHUgPSAxNjsgdSA8IDY0OyB1KyspIHtcbiAgICAgIGNvbnN0IGggPSBEZVt1IC0gMTVdLCBkID0gRGVbdSAtIDJdLCBwID0gQWUoaCwgNykgXiBBZShoLCAxOCkgXiBoID4+PiAzLCB5ID0gQWUoZCwgMTcpIF4gQWUoZCwgMTkpIF4gZCA+Pj4gMTA7XG4gICAgICBEZVt1XSA9IHkgKyBEZVt1IC0gN10gKyBwICsgRGVbdSAtIDE2XSB8IDA7XG4gICAgfVxuICAgIGxldCB7IEE6IG4sIEI6IGksIEM6IHMsIEQ6IG8sIEU6IGEsIEY6IGMsIEc6IGwsIEg6IGYgfSA9IHRoaXM7XG4gICAgZm9yIChsZXQgdSA9IDA7IHUgPCA2NDsgdSsrKSB7XG4gICAgICBjb25zdCBoID0gQWUoYSwgNikgXiBBZShhLCAxMSkgXiBBZShhLCAyNSksIGQgPSBmICsgaCArIGtjKGEsIGMsIGwpICsgT2NbdV0gKyBEZVt1XSB8IDAsIHkgPSAoQWUobiwgMikgXiBBZShuLCAxMykgXiBBZShuLCAyMikpICsgU2MobiwgaSwgcykgfCAwO1xuICAgICAgZiA9IGwsIGwgPSBjLCBjID0gYSwgYSA9IG8gKyBkIHwgMCwgbyA9IHMsIHMgPSBpLCBpID0gbiwgbiA9IGQgKyB5IHwgMDtcbiAgICB9XG4gICAgbiA9IG4gKyB0aGlzLkEgfCAwLCBpID0gaSArIHRoaXMuQiB8IDAsIHMgPSBzICsgdGhpcy5DIHwgMCwgbyA9IG8gKyB0aGlzLkQgfCAwLCBhID0gYSArIHRoaXMuRSB8IDAsIGMgPSBjICsgdGhpcy5GIHwgMCwgbCA9IGwgKyB0aGlzLkcgfCAwLCBmID0gZiArIHRoaXMuSCB8IDAsIHRoaXMuc2V0KG4sIGksIHMsIG8sIGEsIGMsIGwsIGYpO1xuICB9XG4gIHJvdW5kQ2xlYW4oKSB7XG4gICAgRGUuZmlsbCgwKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApLCB0aGlzLmJ1ZmZlci5maWxsKDApO1xuICB9XG59XG5jbGFzcyBBYyBleHRlbmRzIGVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKSwgdGhpcy5BID0gLTEwNTY1OTYyNjQsIHRoaXMuQiA9IDkxNDE1MDY2MywgdGhpcy5DID0gODEyNzAyOTk5LCB0aGlzLkQgPSAtMTUwMDU0NTk5LCB0aGlzLkUgPSAtNDE5MTQzOSwgdGhpcy5GID0gMTc1MDYwMzAyNSwgdGhpcy5HID0gMTY5NDA3NjgzOSwgdGhpcy5IID0gLTEwOTA4OTE4NjgsIHRoaXMub3V0cHV0TGVuID0gMjg7XG4gIH1cbn1cbmNvbnN0IE9yID0gWG8oKCkgPT4gbmV3IGVzKCkpO1xuWG8oKCkgPT4gbmV3IEFjKCkpO1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuY29uc3QgdHMgPSBCaWdJbnQoMCksIExyID0gQmlnSW50KDEpLCBDYyA9IEJpZ0ludCgyKSwgJHIgPSAodCkgPT4gdCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXksIEljID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sICh0LCBlKSA9PiBlLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIikpO1xuZnVuY3Rpb24gdnQodCkge1xuICBpZiAoISRyKHQpKVxuICAgIHRocm93IG5ldyBFcnJvcihcIlVpbnQ4QXJyYXkgZXhwZWN0ZWRcIik7XG4gIGxldCBlID0gXCJcIjtcbiAgZm9yIChsZXQgciA9IDA7IHIgPCB0Lmxlbmd0aDsgcisrKVxuICAgIGUgKz0gSWNbdFtyXV07XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gcnModCkge1xuICBjb25zdCBlID0gdC50b1N0cmluZygxNik7XG4gIHJldHVybiBlLmxlbmd0aCAmIDEgPyBgMCR7ZX1gIDogZTtcbn1cbmZ1bmN0aW9uIHpuKHQpIHtcbiAgaWYgKHR5cGVvZiB0ICE9IFwic3RyaW5nXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IFwiICsgdHlwZW9mIHQpO1xuICByZXR1cm4gQmlnSW50KHQgPT09IFwiXCIgPyBcIjBcIiA6IGAweCR7dH1gKTtcbn1cbmZ1bmN0aW9uIHd0KHQpIHtcbiAgaWYgKHR5cGVvZiB0ICE9IFwic3RyaW5nXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IFwiICsgdHlwZW9mIHQpO1xuICBpZiAodC5sZW5ndGggJSAyKVxuICAgIHRocm93IG5ldyBFcnJvcihcImhleCBzdHJpbmcgaXMgaW52YWxpZDogdW5wYWRkZWQgXCIgKyB0Lmxlbmd0aCk7XG4gIGNvbnN0IGUgPSBuZXcgVWludDhBcnJheSh0Lmxlbmd0aCAvIDIpO1xuICBmb3IgKGxldCByID0gMDsgciA8IGUubGVuZ3RoOyByKyspIHtcbiAgICBjb25zdCBuID0gciAqIDIsIGkgPSB0LnNsaWNlKG4sIG4gKyAyKSwgcyA9IE51bWJlci5wYXJzZUludChpLCAxNik7XG4gICAgaWYgKE51bWJlci5pc05hTihzKSB8fCBzIDwgMClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYnl0ZSBzZXF1ZW5jZVwiKTtcbiAgICBlW3JdID0gcztcbiAgfVxuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIGxlKHQpIHtcbiAgcmV0dXJuIHpuKHZ0KHQpKTtcbn1cbmZ1bmN0aW9uIEZuKHQpIHtcbiAgaWYgKCEkcih0KSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVaW50OEFycmF5IGV4cGVjdGVkXCIpO1xuICByZXR1cm4gem4odnQoVWludDhBcnJheS5mcm9tKHQpLnJldmVyc2UoKSkpO1xufVxuY29uc3QgZXQgPSAodCwgZSkgPT4gd3QodC50b1N0cmluZygxNikucGFkU3RhcnQoZSAqIDIsIFwiMFwiKSksIG5zID0gKHQsIGUpID0+IGV0KHQsIGUpLnJldmVyc2UoKSwgUmMgPSAodCkgPT4gd3QocnModCkpO1xuZnVuY3Rpb24gZWUodCwgZSwgcikge1xuICBsZXQgbjtcbiAgaWYgKHR5cGVvZiBlID09IFwic3RyaW5nXCIpXG4gICAgdHJ5IHtcbiAgICAgIG4gPSB3dChlKTtcbiAgICB9IGNhdGNoIChzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dH0gbXVzdCBiZSB2YWxpZCBoZXggc3RyaW5nLCBnb3QgXCIke2V9XCIuIENhdXNlOiAke3N9YCk7XG4gICAgfVxuICBlbHNlIGlmICgkcihlKSlcbiAgICBuID0gVWludDhBcnJheS5mcm9tKGUpO1xuICBlbHNlXG4gICAgdGhyb3cgbmV3IEVycm9yKGAke3R9IG11c3QgYmUgaGV4IHN0cmluZyBvciBVaW50OEFycmF5YCk7XG4gIGNvbnN0IGkgPSBuLmxlbmd0aDtcbiAgaWYgKHR5cGVvZiByID09IFwibnVtYmVyXCIgJiYgaSAhPT0gcilcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dH0gZXhwZWN0ZWQgJHtyfSBieXRlcywgZ290ICR7aX1gKTtcbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBoZSguLi50KSB7XG4gIGNvbnN0IGUgPSBuZXcgVWludDhBcnJheSh0LnJlZHVjZSgobiwgaSkgPT4gbiArIGkubGVuZ3RoLCAwKSk7XG4gIGxldCByID0gMDtcbiAgcmV0dXJuIHQuZm9yRWFjaCgobikgPT4ge1xuICAgIGlmICghJHIobikpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVaW50OEFycmF5IGV4cGVjdGVkXCIpO1xuICAgIGUuc2V0KG4sIHIpLCByICs9IG4ubGVuZ3RoO1xuICB9KSwgZTtcbn1cbmZ1bmN0aW9uIFRjKHQsIGUpIHtcbiAgaWYgKHQubGVuZ3RoICE9PSBlLmxlbmd0aClcbiAgICByZXR1cm4gITE7XG4gIGZvciAobGV0IHIgPSAwOyByIDwgdC5sZW5ndGg7IHIrKylcbiAgICBpZiAodFtyXSAhPT0gZVtyXSlcbiAgICAgIHJldHVybiAhMTtcbiAgcmV0dXJuICEwO1xufVxuZnVuY3Rpb24gcXIodCkge1xuICBpZiAodHlwZW9mIHQgIT0gXCJzdHJpbmdcIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHV0ZjhUb0J5dGVzIGV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIHR9YCk7XG4gIHJldHVybiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUodCk7XG59XG5mdW5jdGlvbiBQYyh0KSB7XG4gIGxldCBlO1xuICBmb3IgKGUgPSAwOyB0ID4gdHM7IHQgPj49IExyLCBlICs9IDEpXG4gICAgO1xuICByZXR1cm4gZTtcbn1cbmNvbnN0IEJjID0gKHQsIGUpID0+IHQgPj4gQmlnSW50KGUpICYgTHIsIExjID0gKHQsIGUsIHIpID0+IHQgfCAociA/IExyIDogdHMpIDw8IEJpZ0ludChlKSwgS24gPSAodCkgPT4gKENjIDw8IEJpZ0ludCh0IC0gMSkpIC0gTHIsIG5uID0gKHQpID0+IG5ldyBVaW50OEFycmF5KHQpLCBOaSA9ICh0KSA9PiBVaW50OEFycmF5LmZyb20odCk7XG5mdW5jdGlvbiBpcyh0LCBlLCByKSB7XG4gIGlmICh0eXBlb2YgdCAhPSBcIm51bWJlclwiIHx8IHQgPCAyKVxuICAgIHRocm93IG5ldyBFcnJvcihcImhhc2hMZW4gbXVzdCBiZSBhIG51bWJlclwiKTtcbiAgaWYgKHR5cGVvZiBlICE9IFwibnVtYmVyXCIgfHwgZSA8IDIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwicUJ5dGVMZW4gbXVzdCBiZSBhIG51bWJlclwiKTtcbiAgaWYgKHR5cGVvZiByICE9IFwiZnVuY3Rpb25cIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJobWFjRm4gbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICBsZXQgbiA9IG5uKHQpLCBpID0gbm4odCksIHMgPSAwO1xuICBjb25zdCBvID0gKCkgPT4ge1xuICAgIG4uZmlsbCgxKSwgaS5maWxsKDApLCBzID0gMDtcbiAgfSwgYSA9ICguLi51KSA9PiByKGksIG4sIC4uLnUpLCBjID0gKHUgPSBubigpKSA9PiB7XG4gICAgaSA9IGEoTmkoWzBdKSwgdSksIG4gPSBhKCksIHUubGVuZ3RoICE9PSAwICYmIChpID0gYShOaShbMV0pLCB1KSwgbiA9IGEoKSk7XG4gIH0sIGwgPSAoKSA9PiB7XG4gICAgaWYgKHMrKyA+PSAxZTMpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkcmJnOiB0cmllZCAxMDAwIHZhbHVlc1wiKTtcbiAgICBsZXQgdSA9IDA7XG4gICAgY29uc3QgaCA9IFtdO1xuICAgIGZvciAoOyB1IDwgZTsgKSB7XG4gICAgICBuID0gYSgpO1xuICAgICAgY29uc3QgZCA9IG4uc2xpY2UoKTtcbiAgICAgIGgucHVzaChkKSwgdSArPSBuLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIGhlKC4uLmgpO1xuICB9O1xuICByZXR1cm4gKHUsIGgpID0+IHtcbiAgICBvKCksIGModSk7XG4gICAgbGV0IGQ7XG4gICAgZm9yICg7ICEoZCA9IGgobCgpKSk7IClcbiAgICAgIGMoKTtcbiAgICByZXR1cm4gbygpLCBkO1xuICB9O1xufVxuY29uc3QgJGMgPSB7XG4gIGJpZ2ludDogKHQpID0+IHR5cGVvZiB0ID09IFwiYmlnaW50XCIsXG4gIGZ1bmN0aW9uOiAodCkgPT4gdHlwZW9mIHQgPT0gXCJmdW5jdGlvblwiLFxuICBib29sZWFuOiAodCkgPT4gdHlwZW9mIHQgPT0gXCJib29sZWFuXCIsXG4gIHN0cmluZzogKHQpID0+IHR5cGVvZiB0ID09IFwic3RyaW5nXCIsXG4gIGlzU2FmZUludGVnZXI6ICh0KSA9PiBOdW1iZXIuaXNTYWZlSW50ZWdlcih0KSxcbiAgYXJyYXk6ICh0KSA9PiBBcnJheS5pc0FycmF5KHQpLFxuICBmaWVsZDogKHQsIGUpID0+IGUuRnAuaXNWYWxpZCh0KSxcbiAgaGFzaDogKHQpID0+IHR5cGVvZiB0ID09IFwiZnVuY3Rpb25cIiAmJiBOdW1iZXIuaXNTYWZlSW50ZWdlcih0Lm91dHB1dExlbilcbn07XG5mdW5jdGlvbiBrdCh0LCBlLCByID0ge30pIHtcbiAgY29uc3QgbiA9IChpLCBzLCBvKSA9PiB7XG4gICAgY29uc3QgYSA9ICRjW3NdO1xuICAgIGlmICh0eXBlb2YgYSAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdmFsaWRhdG9yIFwiJHtzfVwiLCBleHBlY3RlZCBmdW5jdGlvbmApO1xuICAgIGNvbnN0IGMgPSB0W2ldO1xuICAgIGlmICghKG8gJiYgYyA9PT0gdm9pZCAwKSAmJiAhYShjLCB0KSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwYXJhbSAke1N0cmluZyhpKX09JHtjfSAoJHt0eXBlb2YgY30pLCBleHBlY3RlZCAke3N9YCk7XG4gIH07XG4gIGZvciAoY29uc3QgW2ksIHNdIG9mIE9iamVjdC5lbnRyaWVzKGUpKVxuICAgIG4oaSwgcywgITEpO1xuICBmb3IgKGNvbnN0IFtpLCBzXSBvZiBPYmplY3QuZW50cmllcyhyKSlcbiAgICBuKGksIHMsICEwKTtcbiAgcmV0dXJuIHQ7XG59XG5jb25zdCBxYyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGJ5dGVzVG9IZXg6IHZ0LFxuICBudW1iZXJUb0hleFVucGFkZGVkOiBycyxcbiAgaGV4VG9OdW1iZXI6IHpuLFxuICBoZXhUb0J5dGVzOiB3dCxcbiAgYnl0ZXNUb051bWJlckJFOiBsZSxcbiAgYnl0ZXNUb051bWJlckxFOiBGbixcbiAgbnVtYmVyVG9CeXRlc0JFOiBldCxcbiAgbnVtYmVyVG9CeXRlc0xFOiBucyxcbiAgbnVtYmVyVG9WYXJCeXRlc0JFOiBSYyxcbiAgZW5zdXJlQnl0ZXM6IGVlLFxuICBjb25jYXRCeXRlczogaGUsXG4gIGVxdWFsQnl0ZXM6IFRjLFxuICB1dGY4VG9CeXRlczogcXIsXG4gIGJpdExlbjogUGMsXG4gIGJpdEdldDogQmMsXG4gIGJpdFNldDogTGMsXG4gIGJpdE1hc2s6IEtuLFxuICBjcmVhdGVIbWFjRHJiZzogaXMsXG4gIHZhbGlkYXRlT2JqZWN0OiBrdFxufSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pKTtcbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmNvbnN0IFEgPSBCaWdJbnQoMCksIFYgPSBCaWdJbnQoMSksIGF0ID0gQmlnSW50KDIpLCBOYyA9IEJpZ0ludCgzKSwgQ24gPSBCaWdJbnQoNCksIFVpID0gQmlnSW50KDUpLCBqaSA9IEJpZ0ludCg4KTtcbkJpZ0ludCg5KTtcbkJpZ0ludCgxNik7XG5mdW5jdGlvbiBKKHQsIGUpIHtcbiAgY29uc3QgciA9IHQgJSBlO1xuICByZXR1cm4gciA+PSBRID8gciA6IGUgKyByO1xufVxuZnVuY3Rpb24gVWModCwgZSwgcikge1xuICBpZiAociA8PSBRIHx8IGUgPCBRKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIHBvd2VyL21vZHVsbyA+IDBcIik7XG4gIGlmIChyID09PSBWKVxuICAgIHJldHVybiBRO1xuICBsZXQgbiA9IFY7XG4gIGZvciAoOyBlID4gUTsgKVxuICAgIGUgJiBWICYmIChuID0gbiAqIHQgJSByKSwgdCA9IHQgKiB0ICUgciwgZSA+Pj0gVjtcbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBiZSh0LCBlLCByKSB7XG4gIGxldCBuID0gdDtcbiAgZm9yICg7IGUtLSA+IFE7IClcbiAgICBuICo9IG4sIG4gJT0gcjtcbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBJbih0LCBlKSB7XG4gIGlmICh0ID09PSBRIHx8IGUgPD0gUSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGludmVydDogZXhwZWN0ZWQgcG9zaXRpdmUgaW50ZWdlcnMsIGdvdCBuPSR7dH0gbW9kPSR7ZX1gKTtcbiAgbGV0IHIgPSBKKHQsIGUpLCBuID0gZSwgaSA9IFEsIHMgPSBWO1xuICBmb3IgKDsgciAhPT0gUTsgKSB7XG4gICAgY29uc3QgYSA9IG4gLyByLCBjID0gbiAlIHIsIGwgPSBpIC0gcyAqIGE7XG4gICAgbiA9IHIsIHIgPSBjLCBpID0gcywgcyA9IGw7XG4gIH1cbiAgaWYgKG4gIT09IFYpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52ZXJ0OiBkb2VzIG5vdCBleGlzdFwiKTtcbiAgcmV0dXJuIEooaSwgZSk7XG59XG5mdW5jdGlvbiBqYyh0KSB7XG4gIGNvbnN0IGUgPSAodCAtIFYpIC8gYXQ7XG4gIGxldCByLCBuLCBpO1xuICBmb3IgKHIgPSB0IC0gViwgbiA9IDA7IHIgJSBhdCA9PT0gUTsgciAvPSBhdCwgbisrKVxuICAgIDtcbiAgZm9yIChpID0gYXQ7IGkgPCB0ICYmIFVjKGksIGUsIHQpICE9PSB0IC0gVjsgaSsrKVxuICAgIDtcbiAgaWYgKG4gPT09IDEpIHtcbiAgICBjb25zdCBvID0gKHQgKyBWKSAvIENuO1xuICAgIHJldHVybiBmdW5jdGlvbihjLCBsKSB7XG4gICAgICBjb25zdCBmID0gYy5wb3cobCwgbyk7XG4gICAgICBpZiAoIWMuZXFsKGMuc3FyKGYpLCBsKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3RcIik7XG4gICAgICByZXR1cm4gZjtcbiAgICB9O1xuICB9XG4gIGNvbnN0IHMgPSAociArIFYpIC8gYXQ7XG4gIHJldHVybiBmdW5jdGlvbihhLCBjKSB7XG4gICAgaWYgKGEucG93KGMsIGUpID09PSBhLm5lZyhhLk9ORSkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBzcXVhcmUgcm9vdFwiKTtcbiAgICBsZXQgbCA9IG4sIGYgPSBhLnBvdyhhLm11bChhLk9ORSwgaSksIHIpLCB1ID0gYS5wb3coYywgcyksIGggPSBhLnBvdyhjLCByKTtcbiAgICBmb3IgKDsgIWEuZXFsKGgsIGEuT05FKTsgKSB7XG4gICAgICBpZiAoYS5lcWwoaCwgYS5aRVJPKSlcbiAgICAgICAgcmV0dXJuIGEuWkVSTztcbiAgICAgIGxldCBkID0gMTtcbiAgICAgIGZvciAobGV0IHkgPSBhLnNxcihoKTsgZCA8IGwgJiYgIWEuZXFsKHksIGEuT05FKTsgZCsrKVxuICAgICAgICB5ID0gYS5zcXIoeSk7XG4gICAgICBjb25zdCBwID0gYS5wb3coZiwgViA8PCBCaWdJbnQobCAtIGQgLSAxKSk7XG4gICAgICBmID0gYS5zcXIocCksIHUgPSBhLm11bCh1LCBwKSwgaCA9IGEubXVsKGgsIGYpLCBsID0gZDtcbiAgICB9XG4gICAgcmV0dXJuIHU7XG4gIH07XG59XG5mdW5jdGlvbiBIYyh0KSB7XG4gIGlmICh0ICUgQ24gPT09IE5jKSB7XG4gICAgY29uc3QgZSA9ICh0ICsgVikgLyBDbjtcbiAgICByZXR1cm4gZnVuY3Rpb24obiwgaSkge1xuICAgICAgY29uc3QgcyA9IG4ucG93KGksIGUpO1xuICAgICAgaWYgKCFuLmVxbChuLnNxcihzKSwgaSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIHNxdWFyZSByb290XCIpO1xuICAgICAgcmV0dXJuIHM7XG4gICAgfTtcbiAgfVxuICBpZiAodCAlIGppID09PSBVaSkge1xuICAgIGNvbnN0IGUgPSAodCAtIFVpKSAvIGppO1xuICAgIHJldHVybiBmdW5jdGlvbihuLCBpKSB7XG4gICAgICBjb25zdCBzID0gbi5tdWwoaSwgYXQpLCBvID0gbi5wb3cocywgZSksIGEgPSBuLm11bChpLCBvKSwgYyA9IG4ubXVsKG4ubXVsKGEsIGF0KSwgbyksIGwgPSBuLm11bChhLCBuLnN1YihjLCBuLk9ORSkpO1xuICAgICAgaWYgKCFuLmVxbChuLnNxcihsKSwgaSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIHNxdWFyZSByb290XCIpO1xuICAgICAgcmV0dXJuIGw7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gamModCk7XG59XG5jb25zdCBNYyA9IFtcbiAgXCJjcmVhdGVcIixcbiAgXCJpc1ZhbGlkXCIsXG4gIFwiaXMwXCIsXG4gIFwibmVnXCIsXG4gIFwiaW52XCIsXG4gIFwic3FydFwiLFxuICBcInNxclwiLFxuICBcImVxbFwiLFxuICBcImFkZFwiLFxuICBcInN1YlwiLFxuICBcIm11bFwiLFxuICBcInBvd1wiLFxuICBcImRpdlwiLFxuICBcImFkZE5cIixcbiAgXCJzdWJOXCIsXG4gIFwibXVsTlwiLFxuICBcInNxck5cIlxuXTtcbmZ1bmN0aW9uIG9zKHQpIHtcbiAgY29uc3QgZSA9IHtcbiAgICBPUkRFUjogXCJiaWdpbnRcIixcbiAgICBNQVNLOiBcImJpZ2ludFwiLFxuICAgIEJZVEVTOiBcImlzU2FmZUludGVnZXJcIixcbiAgICBCSVRTOiBcImlzU2FmZUludGVnZXJcIlxuICB9LCByID0gTWMucmVkdWNlKChuLCBpKSA9PiAobltpXSA9IFwiZnVuY3Rpb25cIiwgbiksIGUpO1xuICByZXR1cm4ga3QodCwgcik7XG59XG5mdW5jdGlvbiBEYyh0LCBlLCByKSB7XG4gIGlmIChyIDwgUSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBwb3dlciA+IDBcIik7XG4gIGlmIChyID09PSBRKVxuICAgIHJldHVybiB0Lk9ORTtcbiAgaWYgKHIgPT09IFYpXG4gICAgcmV0dXJuIGU7XG4gIGxldCBuID0gdC5PTkUsIGkgPSBlO1xuICBmb3IgKDsgciA+IFE7IClcbiAgICByICYgViAmJiAobiA9IHQubXVsKG4sIGkpKSwgaSA9IHQuc3FyKGkpLCByID4+PSBWO1xuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIHpjKHQsIGUpIHtcbiAgY29uc3QgciA9IG5ldyBBcnJheShlLmxlbmd0aCksIG4gPSBlLnJlZHVjZSgocywgbywgYSkgPT4gdC5pczAobykgPyBzIDogKHJbYV0gPSBzLCB0Lm11bChzLCBvKSksIHQuT05FKSwgaSA9IHQuaW52KG4pO1xuICByZXR1cm4gZS5yZWR1Y2VSaWdodCgocywgbywgYSkgPT4gdC5pczAobykgPyBzIDogKHJbYV0gPSB0Lm11bChzLCByW2FdKSwgdC5tdWwocywgbykpLCBpKSwgcjtcbn1cbmZ1bmN0aW9uIFduKHQsIGUpIHtcbiAgY29uc3QgciA9IGUgIT09IHZvaWQgMCA/IGUgOiB0LnRvU3RyaW5nKDIpLmxlbmd0aCwgbiA9IE1hdGguY2VpbChyIC8gOCk7XG4gIHJldHVybiB7IG5CaXRMZW5ndGg6IHIsIG5CeXRlTGVuZ3RoOiBuIH07XG59XG5mdW5jdGlvbiBGYyh0LCBlLCByID0gITEsIG4gPSB7fSkge1xuICBpZiAodCA8PSBRKVxuICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgRnAgT1JERVIgPiAwLCBnb3QgJHt0fWApO1xuICBjb25zdCB7IG5CaXRMZW5ndGg6IGksIG5CeXRlTGVuZ3RoOiBzIH0gPSBXbih0LCBlKTtcbiAgaWYgKHMgPiAyMDQ4KVxuICAgIHRocm93IG5ldyBFcnJvcihcIkZpZWxkIGxlbmd0aHMgb3ZlciAyMDQ4IGJ5dGVzIGFyZSBub3Qgc3VwcG9ydGVkXCIpO1xuICBjb25zdCBvID0gSGModCksIGEgPSBPYmplY3QuZnJlZXplKHtcbiAgICBPUkRFUjogdCxcbiAgICBCSVRTOiBpLFxuICAgIEJZVEVTOiBzLFxuICAgIE1BU0s6IEtuKGkpLFxuICAgIFpFUk86IFEsXG4gICAgT05FOiBWLFxuICAgIGNyZWF0ZTogKGMpID0+IEooYywgdCksXG4gICAgaXNWYWxpZDogKGMpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgYyAhPSBcImJpZ2ludFwiKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZmllbGQgZWxlbWVudDogZXhwZWN0ZWQgYmlnaW50LCBnb3QgJHt0eXBlb2YgY31gKTtcbiAgICAgIHJldHVybiBRIDw9IGMgJiYgYyA8IHQ7XG4gICAgfSxcbiAgICBpczA6IChjKSA9PiBjID09PSBRLFxuICAgIGlzT2RkOiAoYykgPT4gKGMgJiBWKSA9PT0gVixcbiAgICBuZWc6IChjKSA9PiBKKC1jLCB0KSxcbiAgICBlcWw6IChjLCBsKSA9PiBjID09PSBsLFxuICAgIHNxcjogKGMpID0+IEooYyAqIGMsIHQpLFxuICAgIGFkZDogKGMsIGwpID0+IEooYyArIGwsIHQpLFxuICAgIHN1YjogKGMsIGwpID0+IEooYyAtIGwsIHQpLFxuICAgIG11bDogKGMsIGwpID0+IEooYyAqIGwsIHQpLFxuICAgIHBvdzogKGMsIGwpID0+IERjKGEsIGMsIGwpLFxuICAgIGRpdjogKGMsIGwpID0+IEooYyAqIEluKGwsIHQpLCB0KSxcbiAgICBzcXJOOiAoYykgPT4gYyAqIGMsXG4gICAgYWRkTjogKGMsIGwpID0+IGMgKyBsLFxuICAgIHN1Yk46IChjLCBsKSA9PiBjIC0gbCxcbiAgICBtdWxOOiAoYywgbCkgPT4gYyAqIGwsXG4gICAgaW52OiAoYykgPT4gSW4oYywgdCksXG4gICAgc3FydDogbi5zcXJ0IHx8ICgoYykgPT4gbyhhLCBjKSksXG4gICAgaW52ZXJ0QmF0Y2g6IChjKSA9PiB6YyhhLCBjKSxcbiAgICBjbW92OiAoYywgbCwgZikgPT4gZiA/IGwgOiBjLFxuICAgIHRvQnl0ZXM6IChjKSA9PiByID8gbnMoYywgcykgOiBldChjLCBzKSxcbiAgICBmcm9tQnl0ZXM6IChjKSA9PiB7XG4gICAgICBpZiAoYy5sZW5ndGggIT09IHMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRnAuZnJvbUJ5dGVzOiBleHBlY3RlZCAke3N9LCBnb3QgJHtjLmxlbmd0aH1gKTtcbiAgICAgIHJldHVybiByID8gRm4oYykgOiBsZShjKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShhKTtcbn1cbmZ1bmN0aW9uIEtjKHQsIGUsIHIgPSAhMSkge1xuICB0ID0gZWUoXCJwcml2YXRlSGFzaFwiLCB0KTtcbiAgY29uc3QgbiA9IHQubGVuZ3RoLCBpID0gV24oZSkubkJ5dGVMZW5ndGggKyA4O1xuICBpZiAoaSA8IDI0IHx8IG4gPCBpIHx8IG4gPiAxMDI0KVxuICAgIHRocm93IG5ldyBFcnJvcihgaGFzaFRvUHJpdmF0ZVNjYWxhcjogZXhwZWN0ZWQgJHtpfS0xMDI0IGJ5dGVzIG9mIGlucHV0LCBnb3QgJHtufWApO1xuICBjb25zdCBzID0gciA/IEZuKHQpIDogbGUodCk7XG4gIHJldHVybiBKKHMsIGUgLSBWKSArIFY7XG59XG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5jb25zdCBXYyA9IEJpZ0ludCgwKSwgb24gPSBCaWdJbnQoMSk7XG5mdW5jdGlvbiBWYyh0LCBlKSB7XG4gIGNvbnN0IHIgPSAoaSwgcykgPT4ge1xuICAgIGNvbnN0IG8gPSBzLm5lZ2F0ZSgpO1xuICAgIHJldHVybiBpID8gbyA6IHM7XG4gIH0sIG4gPSAoaSkgPT4ge1xuICAgIGNvbnN0IHMgPSBNYXRoLmNlaWwoZSAvIGkpICsgMSwgbyA9IDIgKiogKGkgLSAxKTtcbiAgICByZXR1cm4geyB3aW5kb3dzOiBzLCB3aW5kb3dTaXplOiBvIH07XG4gIH07XG4gIHJldHVybiB7XG4gICAgY29uc3RUaW1lTmVnYXRlOiByLFxuICAgIHVuc2FmZUxhZGRlcihpLCBzKSB7XG4gICAgICBsZXQgbyA9IHQuWkVSTywgYSA9IGk7XG4gICAgICBmb3IgKDsgcyA+IFdjOyApXG4gICAgICAgIHMgJiBvbiAmJiAobyA9IG8uYWRkKGEpKSwgYSA9IGEuZG91YmxlKCksIHMgPj49IG9uO1xuICAgICAgcmV0dXJuIG87XG4gICAgfSxcbiAgICBwcmVjb21wdXRlV2luZG93KGksIHMpIHtcbiAgICAgIGNvbnN0IHsgd2luZG93czogbywgd2luZG93U2l6ZTogYSB9ID0gbihzKSwgYyA9IFtdO1xuICAgICAgbGV0IGwgPSBpLCBmID0gbDtcbiAgICAgIGZvciAobGV0IHUgPSAwOyB1IDwgbzsgdSsrKSB7XG4gICAgICAgIGYgPSBsLCBjLnB1c2goZik7XG4gICAgICAgIGZvciAobGV0IGggPSAxOyBoIDwgYTsgaCsrKVxuICAgICAgICAgIGYgPSBmLmFkZChsKSwgYy5wdXNoKGYpO1xuICAgICAgICBsID0gZi5kb3VibGUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjO1xuICAgIH0sXG4gICAgd05BRihpLCBzLCBvKSB7XG4gICAgICBjb25zdCB7IHdpbmRvd3M6IGEsIHdpbmRvd1NpemU6IGMgfSA9IG4oaSk7XG4gICAgICBsZXQgbCA9IHQuWkVSTywgZiA9IHQuQkFTRTtcbiAgICAgIGNvbnN0IHUgPSBCaWdJbnQoMiAqKiBpIC0gMSksIGggPSAyICoqIGksIGQgPSBCaWdJbnQoaSk7XG4gICAgICBmb3IgKGxldCBwID0gMDsgcCA8IGE7IHArKykge1xuICAgICAgICBjb25zdCB5ID0gcCAqIGM7XG4gICAgICAgIGxldCBnID0gTnVtYmVyKG8gJiB1KTtcbiAgICAgICAgbyA+Pj0gZCwgZyA+IGMgJiYgKGcgLT0gaCwgbyArPSBvbik7XG4gICAgICAgIGNvbnN0IHYgPSB5LCBfID0geSArIE1hdGguYWJzKGcpIC0gMSwgbSA9IHAgJSAyICE9PSAwLCBDID0gZyA8IDA7XG4gICAgICAgIGcgPT09IDAgPyBmID0gZi5hZGQocihtLCBzW3ZdKSkgOiBsID0gbC5hZGQocihDLCBzW19dKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBwOiBsLCBmIH07XG4gICAgfSxcbiAgICB3TkFGQ2FjaGVkKGksIHMsIG8sIGEpIHtcbiAgICAgIGNvbnN0IGMgPSBpLl9XSU5ET1dfU0laRSB8fCAxO1xuICAgICAgbGV0IGwgPSBzLmdldChpKTtcbiAgICAgIHJldHVybiBsIHx8IChsID0gdGhpcy5wcmVjb21wdXRlV2luZG93KGksIGMpLCBjICE9PSAxICYmIHMuc2V0KGksIGEobCkpKSwgdGhpcy53TkFGKGMsIGwsIG8pO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHNzKHQpIHtcbiAgcmV0dXJuIG9zKHQuRnApLCBrdCh0LCB7XG4gICAgbjogXCJiaWdpbnRcIixcbiAgICBoOiBcImJpZ2ludFwiLFxuICAgIEd4OiBcImZpZWxkXCIsXG4gICAgR3k6IFwiZmllbGRcIlxuICB9LCB7XG4gICAgbkJpdExlbmd0aDogXCJpc1NhZmVJbnRlZ2VyXCIsXG4gICAgbkJ5dGVMZW5ndGg6IFwiaXNTYWZlSW50ZWdlclwiXG4gIH0pLCBPYmplY3QuZnJlZXplKHtcbiAgICAuLi5Xbih0Lm4sIHQubkJpdExlbmd0aCksXG4gICAgLi4udCxcbiAgICBwOiB0LkZwLk9SREVSXG4gIH0pO1xufVxuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuZnVuY3Rpb24gR2ModCkge1xuICBjb25zdCBlID0gc3ModCk7XG4gIGt0KGUsIHtcbiAgICBhOiBcImZpZWxkXCIsXG4gICAgYjogXCJmaWVsZFwiXG4gIH0sIHtcbiAgICBhbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHM6IFwiYXJyYXlcIixcbiAgICB3cmFwUHJpdmF0ZUtleTogXCJib29sZWFuXCIsXG4gICAgaXNUb3JzaW9uRnJlZTogXCJmdW5jdGlvblwiLFxuICAgIGNsZWFyQ29mYWN0b3I6IFwiZnVuY3Rpb25cIixcbiAgICBhbGxvd0luZmluaXR5UG9pbnQ6IFwiYm9vbGVhblwiLFxuICAgIGZyb21CeXRlczogXCJmdW5jdGlvblwiLFxuICAgIHRvQnl0ZXM6IFwiZnVuY3Rpb25cIlxuICB9KTtcbiAgY29uc3QgeyBlbmRvOiByLCBGcDogbiwgYTogaSB9ID0gZTtcbiAgaWYgKHIpIHtcbiAgICBpZiAoIW4uZXFsKGksIG4uWkVSTykpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbmRvbW9ycGhpc20gY2FuIG9ubHkgYmUgZGVmaW5lZCBmb3IgS29ibGl0eiBjdXJ2ZXMgdGhhdCBoYXZlIGE9MFwiKTtcbiAgICBpZiAodHlwZW9mIHIgIT0gXCJvYmplY3RcIiB8fCB0eXBlb2Ygci5iZXRhICE9IFwiYmlnaW50XCIgfHwgdHlwZW9mIHIuc3BsaXRTY2FsYXIgIT0gXCJmdW5jdGlvblwiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgZW5kb21vcnBoaXNtIHdpdGggYmV0YTogYmlnaW50IGFuZCBzcGxpdFNjYWxhcjogZnVuY3Rpb25cIik7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyAuLi5lIH0pO1xufVxuY29uc3QgeyBieXRlc1RvTnVtYmVyQkU6IFpjLCBoZXhUb0J5dGVzOiBZYyB9ID0gcWMsIGx0ID0ge1xuICBFcnI6IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGUgPSBcIlwiKSB7XG4gICAgICBzdXBlcihlKTtcbiAgICB9XG4gIH0sXG4gIF9wYXJzZUludCh0KSB7XG4gICAgY29uc3QgeyBFcnI6IGUgfSA9IGx0O1xuICAgIGlmICh0Lmxlbmd0aCA8IDIgfHwgdFswXSAhPT0gMilcbiAgICAgIHRocm93IG5ldyBlKFwiSW52YWxpZCBzaWduYXR1cmUgaW50ZWdlciB0YWdcIik7XG4gICAgY29uc3QgciA9IHRbMV0sIG4gPSB0LnN1YmFycmF5KDIsIHIgKyAyKTtcbiAgICBpZiAoIXIgfHwgbi5sZW5ndGggIT09IHIpXG4gICAgICB0aHJvdyBuZXcgZShcIkludmFsaWQgc2lnbmF0dXJlIGludGVnZXI6IHdyb25nIGxlbmd0aFwiKTtcbiAgICBpZiAoblswXSAmIDEyOClcbiAgICAgIHRocm93IG5ldyBlKFwiSW52YWxpZCBzaWduYXR1cmUgaW50ZWdlcjogbmVnYXRpdmVcIik7XG4gICAgaWYgKG5bMF0gPT09IDAgJiYgIShuWzFdICYgMTI4KSlcbiAgICAgIHRocm93IG5ldyBlKFwiSW52YWxpZCBzaWduYXR1cmUgaW50ZWdlcjogdW5uZWNlc3NhcnkgbGVhZGluZyB6ZXJvXCIpO1xuICAgIHJldHVybiB7IGQ6IFpjKG4pLCBsOiB0LnN1YmFycmF5KHIgKyAyKSB9O1xuICB9LFxuICB0b1NpZyh0KSB7XG4gICAgY29uc3QgeyBFcnI6IGUgfSA9IGx0LCByID0gdHlwZW9mIHQgPT0gXCJzdHJpbmdcIiA/IFljKHQpIDogdDtcbiAgICBpZiAoIShyIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1aThhIGV4cGVjdGVkXCIpO1xuICAgIGxldCBuID0gci5sZW5ndGg7XG4gICAgaWYgKG4gPCAyIHx8IHJbMF0gIT0gNDgpXG4gICAgICB0aHJvdyBuZXcgZShcIkludmFsaWQgc2lnbmF0dXJlIHRhZ1wiKTtcbiAgICBpZiAoclsxXSAhPT0gbiAtIDIpXG4gICAgICB0aHJvdyBuZXcgZShcIkludmFsaWQgc2lnbmF0dXJlOiBpbmNvcnJlY3QgbGVuZ3RoXCIpO1xuICAgIGNvbnN0IHsgZDogaSwgbDogcyB9ID0gbHQuX3BhcnNlSW50KHIuc3ViYXJyYXkoMikpLCB7IGQ6IG8sIGw6IGEgfSA9IGx0Ll9wYXJzZUludChzKTtcbiAgICBpZiAoYS5sZW5ndGgpXG4gICAgICB0aHJvdyBuZXcgZShcIkludmFsaWQgc2lnbmF0dXJlOiBsZWZ0IGJ5dGVzIGFmdGVyIHBhcnNpbmdcIik7XG4gICAgcmV0dXJuIHsgcjogaSwgczogbyB9O1xuICB9LFxuICBoZXhGcm9tU2lnKHQpIHtcbiAgICBjb25zdCBlID0gKGwpID0+IE51bWJlci5wYXJzZUludChsWzBdLCAxNikgJiA4ID8gXCIwMFwiICsgbCA6IGwsIHIgPSAobCkgPT4ge1xuICAgICAgY29uc3QgZiA9IGwudG9TdHJpbmcoMTYpO1xuICAgICAgcmV0dXJuIGYubGVuZ3RoICYgMSA/IGAwJHtmfWAgOiBmO1xuICAgIH0sIG4gPSBlKHIodC5zKSksIGkgPSBlKHIodC5yKSksIHMgPSBuLmxlbmd0aCAvIDIsIG8gPSBpLmxlbmd0aCAvIDIsIGEgPSByKHMpLCBjID0gcihvKTtcbiAgICByZXR1cm4gYDMwJHtyKG8gKyBzICsgNCl9MDIke2N9JHtpfTAyJHthfSR7bn1gO1xuICB9XG59LCBrZSA9IEJpZ0ludCgwKSwgWSA9IEJpZ0ludCgxKSwgJGUgPSBCaWdJbnQoMiksIEFyID0gQmlnSW50KDMpLCBIaSA9IEJpZ0ludCg0KTtcbmZ1bmN0aW9uIEpjKHQpIHtcbiAgY29uc3QgZSA9IEdjKHQpLCB7IEZwOiByIH0gPSBlLCBuID0gZS50b0J5dGVzIHx8ICgocCwgeSwgZykgPT4ge1xuICAgIGNvbnN0IHYgPSB5LnRvQWZmaW5lKCk7XG4gICAgcmV0dXJuIGhlKFVpbnQ4QXJyYXkuZnJvbShbNF0pLCByLnRvQnl0ZXModi54KSwgci50b0J5dGVzKHYueSkpO1xuICB9KSwgaSA9IGUuZnJvbUJ5dGVzIHx8ICgocCkgPT4ge1xuICAgIGNvbnN0IHkgPSBwLnN1YmFycmF5KDEpLCBnID0gci5mcm9tQnl0ZXMoeS5zdWJhcnJheSgwLCByLkJZVEVTKSksIHYgPSByLmZyb21CeXRlcyh5LnN1YmFycmF5KHIuQllURVMsIDIgKiByLkJZVEVTKSk7XG4gICAgcmV0dXJuIHsgeDogZywgeTogdiB9O1xuICB9KTtcbiAgZnVuY3Rpb24gcyhwKSB7XG4gICAgY29uc3QgeyBhOiB5LCBiOiBnIH0gPSBlLCB2ID0gci5zcXIocCksIF8gPSByLm11bCh2LCBwKTtcbiAgICByZXR1cm4gci5hZGQoci5hZGQoXywgci5tdWwocCwgeSkpLCBnKTtcbiAgfVxuICBpZiAoIXIuZXFsKHIuc3FyKGUuR3kpLCBzKGUuR3gpKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgZ2VuZXJhdG9yIHBvaW50OiBlcXVhdGlvbiBsZWZ0ICE9IHJpZ2h0XCIpO1xuICBmdW5jdGlvbiBvKHApIHtcbiAgICByZXR1cm4gdHlwZW9mIHAgPT0gXCJiaWdpbnRcIiAmJiBrZSA8IHAgJiYgcCA8IGUubjtcbiAgfVxuICBmdW5jdGlvbiBhKHApIHtcbiAgICBpZiAoIW8ocCkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCB2YWxpZCBiaWdpbnQ6IDAgPCBiaWdpbnQgPCBjdXJ2ZS5uXCIpO1xuICB9XG4gIGZ1bmN0aW9uIGMocCkge1xuICAgIGNvbnN0IHsgYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzOiB5LCBuQnl0ZUxlbmd0aDogZywgd3JhcFByaXZhdGVLZXk6IHYsIG46IF8gfSA9IGU7XG4gICAgaWYgKHkgJiYgdHlwZW9mIHAgIT0gXCJiaWdpbnRcIikge1xuICAgICAgaWYgKHAgaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmIChwID0gdnQocCkpLCB0eXBlb2YgcCAhPSBcInN0cmluZ1wiIHx8ICF5LmluY2x1ZGVzKHAubGVuZ3RoKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBrZXlcIik7XG4gICAgICBwID0gcC5wYWRTdGFydChnICogMiwgXCIwXCIpO1xuICAgIH1cbiAgICBsZXQgbTtcbiAgICB0cnkge1xuICAgICAgbSA9IHR5cGVvZiBwID09IFwiYmlnaW50XCIgPyBwIDogbGUoZWUoXCJwcml2YXRlIGtleVwiLCBwLCBnKSk7XG4gICAgfSBjYXRjaCB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHByaXZhdGUga2V5IG11c3QgYmUgJHtnfSBieXRlcywgaGV4IG9yIGJpZ2ludCwgbm90ICR7dHlwZW9mIHB9YCk7XG4gICAgfVxuICAgIHJldHVybiB2ICYmIChtID0gSihtLCBfKSksIGEobSksIG07XG4gIH1cbiAgY29uc3QgbCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGZ1bmN0aW9uIGYocCkge1xuICAgIGlmICghKHAgaW5zdGFuY2VvZiB1KSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb2plY3RpdmVQb2ludCBleHBlY3RlZFwiKTtcbiAgfVxuICBjbGFzcyB1IHtcbiAgICBjb25zdHJ1Y3Rvcih5LCBnLCB2KSB7XG4gICAgICBpZiAodGhpcy5weCA9IHksIHRoaXMucHkgPSBnLCB0aGlzLnB6ID0gdiwgeSA9PSBudWxsIHx8ICFyLmlzVmFsaWQoeSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInggcmVxdWlyZWRcIik7XG4gICAgICBpZiAoZyA9PSBudWxsIHx8ICFyLmlzVmFsaWQoZykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInkgcmVxdWlyZWRcIik7XG4gICAgICBpZiAodiA9PSBudWxsIHx8ICFyLmlzVmFsaWQodikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInogcmVxdWlyZWRcIik7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQWZmaW5lKHkpIHtcbiAgICAgIGNvbnN0IHsgeDogZywgeTogdiB9ID0geSB8fCB7fTtcbiAgICAgIGlmICgheSB8fCAhci5pc1ZhbGlkKGcpIHx8ICFyLmlzVmFsaWQodikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYWZmaW5lIHBvaW50XCIpO1xuICAgICAgaWYgKHkgaW5zdGFuY2VvZiB1KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwcm9qZWN0aXZlIHBvaW50IG5vdCBhbGxvd2VkXCIpO1xuICAgICAgY29uc3QgXyA9IChtKSA9PiByLmVxbChtLCByLlpFUk8pO1xuICAgICAgcmV0dXJuIF8oZykgJiYgXyh2KSA/IHUuWkVSTyA6IG5ldyB1KGcsIHYsIHIuT05FKTtcbiAgICB9XG4gICAgZ2V0IHgoKSB7XG4gICAgICByZXR1cm4gdGhpcy50b0FmZmluZSgpLng7XG4gICAgfVxuICAgIGdldCB5KCkge1xuICAgICAgcmV0dXJuIHRoaXMudG9BZmZpbmUoKS55O1xuICAgIH1cbiAgICBzdGF0aWMgbm9ybWFsaXplWih5KSB7XG4gICAgICBjb25zdCBnID0gci5pbnZlcnRCYXRjaCh5Lm1hcCgodikgPT4gdi5weikpO1xuICAgICAgcmV0dXJuIHkubWFwKCh2LCBfKSA9PiB2LnRvQWZmaW5lKGdbX10pKS5tYXAodS5mcm9tQWZmaW5lKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21IZXgoeSkge1xuICAgICAgY29uc3QgZyA9IHUuZnJvbUFmZmluZShpKGVlKFwicG9pbnRIZXhcIiwgeSkpKTtcbiAgICAgIHJldHVybiBnLmFzc2VydFZhbGlkaXR5KCksIGc7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tUHJpdmF0ZUtleSh5KSB7XG4gICAgICByZXR1cm4gdS5CQVNFLm11bHRpcGx5KGMoeSkpO1xuICAgIH1cbiAgICBfc2V0V2luZG93U2l6ZSh5KSB7XG4gICAgICB0aGlzLl9XSU5ET1dfU0laRSA9IHksIGwuZGVsZXRlKHRoaXMpO1xuICAgIH1cbiAgICBhc3NlcnRWYWxpZGl0eSgpIHtcbiAgICAgIGlmICh0aGlzLmlzMCgpKSB7XG4gICAgICAgIGlmIChlLmFsbG93SW5maW5pdHlQb2ludClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImJhZCBwb2ludDogWkVST1wiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgeDogeSwgeTogZyB9ID0gdGhpcy50b0FmZmluZSgpO1xuICAgICAgaWYgKCFyLmlzVmFsaWQoeSkgfHwgIXIuaXNWYWxpZChnKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmFkIHBvaW50OiB4IG9yIHkgbm90IEZFXCIpO1xuICAgICAgY29uc3QgdiA9IHIuc3FyKGcpLCBfID0gcyh5KTtcbiAgICAgIGlmICghci5lcWwodiwgXykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImJhZCBwb2ludDogZXF1YXRpb24gbGVmdCAhPSByaWdodFwiKTtcbiAgICAgIGlmICghdGhpcy5pc1RvcnNpb25GcmVlKCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImJhZCBwb2ludDogbm90IGluIHByaW1lLW9yZGVyIHN1Ymdyb3VwXCIpO1xuICAgIH1cbiAgICBoYXNFdmVuWSgpIHtcbiAgICAgIGNvbnN0IHsgeSB9ID0gdGhpcy50b0FmZmluZSgpO1xuICAgICAgaWYgKHIuaXNPZGQpXG4gICAgICAgIHJldHVybiAhci5pc09kZCh5KTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkZpZWxkIGRvZXNuJ3Qgc3VwcG9ydCBpc09kZFwiKTtcbiAgICB9XG4gICAgZXF1YWxzKHkpIHtcbiAgICAgIGYoeSk7XG4gICAgICBjb25zdCB7IHB4OiBnLCBweTogdiwgcHo6IF8gfSA9IHRoaXMsIHsgcHg6IG0sIHB5OiBDLCBwejogTyB9ID0geSwgdyA9IHIuZXFsKHIubXVsKGcsIE8pLCByLm11bChtLCBfKSksIHggPSByLmVxbChyLm11bCh2LCBPKSwgci5tdWwoQywgXykpO1xuICAgICAgcmV0dXJuIHcgJiYgeDtcbiAgICB9XG4gICAgbmVnYXRlKCkge1xuICAgICAgcmV0dXJuIG5ldyB1KHRoaXMucHgsIHIubmVnKHRoaXMucHkpLCB0aGlzLnB6KTtcbiAgICB9XG4gICAgZG91YmxlKCkge1xuICAgICAgY29uc3QgeyBhOiB5LCBiOiBnIH0gPSBlLCB2ID0gci5tdWwoZywgQXIpLCB7IHB4OiBfLCBweTogbSwgcHo6IEMgfSA9IHRoaXM7XG4gICAgICBsZXQgTyA9IHIuWkVSTywgdyA9IHIuWkVSTywgeCA9IHIuWkVSTywgQSA9IHIubXVsKF8sIF8pLCBCID0gci5tdWwobSwgbSksIEwgPSByLm11bChDLCBDKSwgUCA9IHIubXVsKF8sIG0pO1xuICAgICAgcmV0dXJuIFAgPSByLmFkZChQLCBQKSwgeCA9IHIubXVsKF8sIEMpLCB4ID0gci5hZGQoeCwgeCksIE8gPSByLm11bCh5LCB4KSwgdyA9IHIubXVsKHYsIEwpLCB3ID0gci5hZGQoTywgdyksIE8gPSByLnN1YihCLCB3KSwgdyA9IHIuYWRkKEIsIHcpLCB3ID0gci5tdWwoTywgdyksIE8gPSByLm11bChQLCBPKSwgeCA9IHIubXVsKHYsIHgpLCBMID0gci5tdWwoeSwgTCksIFAgPSByLnN1YihBLCBMKSwgUCA9IHIubXVsKHksIFApLCBQID0gci5hZGQoUCwgeCksIHggPSByLmFkZChBLCBBKSwgQSA9IHIuYWRkKHgsIEEpLCBBID0gci5hZGQoQSwgTCksIEEgPSByLm11bChBLCBQKSwgdyA9IHIuYWRkKHcsIEEpLCBMID0gci5tdWwobSwgQyksIEwgPSByLmFkZChMLCBMKSwgQSA9IHIubXVsKEwsIFApLCBPID0gci5zdWIoTywgQSksIHggPSByLm11bChMLCBCKSwgeCA9IHIuYWRkKHgsIHgpLCB4ID0gci5hZGQoeCwgeCksIG5ldyB1KE8sIHcsIHgpO1xuICAgIH1cbiAgICBhZGQoeSkge1xuICAgICAgZih5KTtcbiAgICAgIGNvbnN0IHsgcHg6IGcsIHB5OiB2LCBwejogXyB9ID0gdGhpcywgeyBweDogbSwgcHk6IEMsIHB6OiBPIH0gPSB5O1xuICAgICAgbGV0IHcgPSByLlpFUk8sIHggPSByLlpFUk8sIEEgPSByLlpFUk87XG4gICAgICBjb25zdCBCID0gZS5hLCBMID0gci5tdWwoZS5iLCBBcik7XG4gICAgICBsZXQgUCA9IHIubXVsKGcsIG0pLCBGID0gci5tdWwodiwgQyksIHogPSByLm11bChfLCBPKSwgRyA9IHIuYWRkKGcsIHYpLCBFID0gci5hZGQobSwgQyk7XG4gICAgICBHID0gci5tdWwoRywgRSksIEUgPSByLmFkZChQLCBGKSwgRyA9IHIuc3ViKEcsIEUpLCBFID0gci5hZGQoZywgXyk7XG4gICAgICBsZXQgUiA9IHIuYWRkKG0sIE8pO1xuICAgICAgcmV0dXJuIEUgPSByLm11bChFLCBSKSwgUiA9IHIuYWRkKFAsIHopLCBFID0gci5zdWIoRSwgUiksIFIgPSByLmFkZCh2LCBfKSwgdyA9IHIuYWRkKEMsIE8pLCBSID0gci5tdWwoUiwgdyksIHcgPSByLmFkZChGLCB6KSwgUiA9IHIuc3ViKFIsIHcpLCBBID0gci5tdWwoQiwgRSksIHcgPSByLm11bChMLCB6KSwgQSA9IHIuYWRkKHcsIEEpLCB3ID0gci5zdWIoRiwgQSksIEEgPSByLmFkZChGLCBBKSwgeCA9IHIubXVsKHcsIEEpLCBGID0gci5hZGQoUCwgUCksIEYgPSByLmFkZChGLCBQKSwgeiA9IHIubXVsKEIsIHopLCBFID0gci5tdWwoTCwgRSksIEYgPSByLmFkZChGLCB6KSwgeiA9IHIuc3ViKFAsIHopLCB6ID0gci5tdWwoQiwgeiksIEUgPSByLmFkZChFLCB6KSwgUCA9IHIubXVsKEYsIEUpLCB4ID0gci5hZGQoeCwgUCksIFAgPSByLm11bChSLCBFKSwgdyA9IHIubXVsKEcsIHcpLCB3ID0gci5zdWIodywgUCksIFAgPSByLm11bChHLCBGKSwgQSA9IHIubXVsKFIsIEEpLCBBID0gci5hZGQoQSwgUCksIG5ldyB1KHcsIHgsIEEpO1xuICAgIH1cbiAgICBzdWJ0cmFjdCh5KSB7XG4gICAgICByZXR1cm4gdGhpcy5hZGQoeS5uZWdhdGUoKSk7XG4gICAgfVxuICAgIGlzMCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmVxdWFscyh1LlpFUk8pO1xuICAgIH1cbiAgICB3TkFGKHkpIHtcbiAgICAgIHJldHVybiBkLndOQUZDYWNoZWQodGhpcywgbCwgeSwgKGcpID0+IHtcbiAgICAgICAgY29uc3QgdiA9IHIuaW52ZXJ0QmF0Y2goZy5tYXAoKF8pID0+IF8ucHopKTtcbiAgICAgICAgcmV0dXJuIGcubWFwKChfLCBtKSA9PiBfLnRvQWZmaW5lKHZbbV0pKS5tYXAodS5mcm9tQWZmaW5lKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBtdWx0aXBseVVuc2FmZSh5KSB7XG4gICAgICBjb25zdCBnID0gdS5aRVJPO1xuICAgICAgaWYgKHkgPT09IGtlKVxuICAgICAgICByZXR1cm4gZztcbiAgICAgIGlmIChhKHkpLCB5ID09PSBZKVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIGNvbnN0IHsgZW5kbzogdiB9ID0gZTtcbiAgICAgIGlmICghdilcbiAgICAgICAgcmV0dXJuIGQudW5zYWZlTGFkZGVyKHRoaXMsIHkpO1xuICAgICAgbGV0IHsgazFuZWc6IF8sIGsxOiBtLCBrMm5lZzogQywgazI6IE8gfSA9IHYuc3BsaXRTY2FsYXIoeSksIHcgPSBnLCB4ID0gZywgQSA9IHRoaXM7XG4gICAgICBmb3IgKDsgbSA+IGtlIHx8IE8gPiBrZTsgKVxuICAgICAgICBtICYgWSAmJiAodyA9IHcuYWRkKEEpKSwgTyAmIFkgJiYgKHggPSB4LmFkZChBKSksIEEgPSBBLmRvdWJsZSgpLCBtID4+PSBZLCBPID4+PSBZO1xuICAgICAgcmV0dXJuIF8gJiYgKHcgPSB3Lm5lZ2F0ZSgpKSwgQyAmJiAoeCA9IHgubmVnYXRlKCkpLCB4ID0gbmV3IHUoci5tdWwoeC5weCwgdi5iZXRhKSwgeC5weSwgeC5weiksIHcuYWRkKHgpO1xuICAgIH1cbiAgICBtdWx0aXBseSh5KSB7XG4gICAgICBhKHkpO1xuICAgICAgbGV0IGcgPSB5LCB2LCBfO1xuICAgICAgY29uc3QgeyBlbmRvOiBtIH0gPSBlO1xuICAgICAgaWYgKG0pIHtcbiAgICAgICAgY29uc3QgeyBrMW5lZzogQywgazE6IE8sIGsybmVnOiB3LCBrMjogeCB9ID0gbS5zcGxpdFNjYWxhcihnKTtcbiAgICAgICAgbGV0IHsgcDogQSwgZjogQiB9ID0gdGhpcy53TkFGKE8pLCB7IHA6IEwsIGY6IFAgfSA9IHRoaXMud05BRih4KTtcbiAgICAgICAgQSA9IGQuY29uc3RUaW1lTmVnYXRlKEMsIEEpLCBMID0gZC5jb25zdFRpbWVOZWdhdGUodywgTCksIEwgPSBuZXcgdShyLm11bChMLnB4LCBtLmJldGEpLCBMLnB5LCBMLnB6KSwgdiA9IEEuYWRkKEwpLCBfID0gQi5hZGQoUCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB7IHA6IEMsIGY6IE8gfSA9IHRoaXMud05BRihnKTtcbiAgICAgICAgdiA9IEMsIF8gPSBPO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHUubm9ybWFsaXplWihbdiwgX10pWzBdO1xuICAgIH1cbiAgICBtdWx0aXBseUFuZEFkZFVuc2FmZSh5LCBnLCB2KSB7XG4gICAgICBjb25zdCBfID0gdS5CQVNFLCBtID0gKE8sIHcpID0+IHcgPT09IGtlIHx8IHcgPT09IFkgfHwgIU8uZXF1YWxzKF8pID8gTy5tdWx0aXBseVVuc2FmZSh3KSA6IE8ubXVsdGlwbHkodyksIEMgPSBtKHRoaXMsIGcpLmFkZChtKHksIHYpKTtcbiAgICAgIHJldHVybiBDLmlzMCgpID8gdm9pZCAwIDogQztcbiAgICB9XG4gICAgdG9BZmZpbmUoeSkge1xuICAgICAgY29uc3QgeyBweDogZywgcHk6IHYsIHB6OiBfIH0gPSB0aGlzLCBtID0gdGhpcy5pczAoKTtcbiAgICAgIHkgPT0gbnVsbCAmJiAoeSA9IG0gPyByLk9ORSA6IHIuaW52KF8pKTtcbiAgICAgIGNvbnN0IEMgPSByLm11bChnLCB5KSwgTyA9IHIubXVsKHYsIHkpLCB3ID0gci5tdWwoXywgeSk7XG4gICAgICBpZiAobSlcbiAgICAgICAgcmV0dXJuIHsgeDogci5aRVJPLCB5OiByLlpFUk8gfTtcbiAgICAgIGlmICghci5lcWwodywgci5PTkUpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZaIHdhcyBpbnZhbGlkXCIpO1xuICAgICAgcmV0dXJuIHsgeDogQywgeTogTyB9O1xuICAgIH1cbiAgICBpc1RvcnNpb25GcmVlKCkge1xuICAgICAgY29uc3QgeyBoOiB5LCBpc1RvcnNpb25GcmVlOiBnIH0gPSBlO1xuICAgICAgaWYgKHkgPT09IFkpXG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIGlmIChnKVxuICAgICAgICByZXR1cm4gZyh1LCB0aGlzKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlzVG9yc2lvbkZyZWUoKSBoYXMgbm90IGJlZW4gZGVjbGFyZWQgZm9yIHRoZSBlbGxpcHRpYyBjdXJ2ZVwiKTtcbiAgICB9XG4gICAgY2xlYXJDb2ZhY3RvcigpIHtcbiAgICAgIGNvbnN0IHsgaDogeSwgY2xlYXJDb2ZhY3RvcjogZyB9ID0gZTtcbiAgICAgIHJldHVybiB5ID09PSBZID8gdGhpcyA6IGcgPyBnKHUsIHRoaXMpIDogdGhpcy5tdWx0aXBseVVuc2FmZShlLmgpO1xuICAgIH1cbiAgICB0b1Jhd0J5dGVzKHkgPSAhMCkge1xuICAgICAgcmV0dXJuIHRoaXMuYXNzZXJ0VmFsaWRpdHkoKSwgbih1LCB0aGlzLCB5KTtcbiAgICB9XG4gICAgdG9IZXgoeSA9ICEwKSB7XG4gICAgICByZXR1cm4gdnQodGhpcy50b1Jhd0J5dGVzKHkpKTtcbiAgICB9XG4gIH1cbiAgdS5CQVNFID0gbmV3IHUoZS5HeCwgZS5HeSwgci5PTkUpLCB1LlpFUk8gPSBuZXcgdShyLlpFUk8sIHIuT05FLCByLlpFUk8pO1xuICBjb25zdCBoID0gZS5uQml0TGVuZ3RoLCBkID0gVmModSwgZS5lbmRvID8gTWF0aC5jZWlsKGggLyAyKSA6IGgpO1xuICByZXR1cm4ge1xuICAgIENVUlZFOiBlLFxuICAgIFByb2plY3RpdmVQb2ludDogdSxcbiAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyOiBjLFxuICAgIHdlaWVyc3RyYXNzRXF1YXRpb246IHMsXG4gICAgaXNXaXRoaW5DdXJ2ZU9yZGVyOiBvXG4gIH07XG59XG5mdW5jdGlvbiBYYyh0KSB7XG4gIGNvbnN0IGUgPSBzcyh0KTtcbiAgcmV0dXJuIGt0KGUsIHtcbiAgICBoYXNoOiBcImhhc2hcIixcbiAgICBobWFjOiBcImZ1bmN0aW9uXCIsXG4gICAgcmFuZG9tQnl0ZXM6IFwiZnVuY3Rpb25cIlxuICB9LCB7XG4gICAgYml0czJpbnQ6IFwiZnVuY3Rpb25cIixcbiAgICBiaXRzMmludF9tb2ROOiBcImZ1bmN0aW9uXCIsXG4gICAgbG93UzogXCJib29sZWFuXCJcbiAgfSksIE9iamVjdC5mcmVlemUoeyBsb3dTOiAhMCwgLi4uZSB9KTtcbn1cbmZ1bmN0aW9uIFFjKHQpIHtcbiAgY29uc3QgZSA9IFhjKHQpLCB7IEZwOiByLCBuIH0gPSBlLCBpID0gci5CWVRFUyArIDEsIHMgPSAyICogci5CWVRFUyArIDE7XG4gIGZ1bmN0aW9uIG8oRSkge1xuICAgIHJldHVybiBrZSA8IEUgJiYgRSA8IHIuT1JERVI7XG4gIH1cbiAgZnVuY3Rpb24gYShFKSB7XG4gICAgcmV0dXJuIEooRSwgbik7XG4gIH1cbiAgZnVuY3Rpb24gYyhFKSB7XG4gICAgcmV0dXJuIEluKEUsIG4pO1xuICB9XG4gIGNvbnN0IHsgUHJvamVjdGl2ZVBvaW50OiBsLCBub3JtUHJpdmF0ZUtleVRvU2NhbGFyOiBmLCB3ZWllcnN0cmFzc0VxdWF0aW9uOiB1LCBpc1dpdGhpbkN1cnZlT3JkZXI6IGggfSA9IEpjKHtcbiAgICAuLi5lLFxuICAgIHRvQnl0ZXMoRSwgUiwgcSkge1xuICAgICAgY29uc3QgSCA9IFIudG9BZmZpbmUoKSwgRCA9IHIudG9CeXRlcyhILngpLCBYID0gaGU7XG4gICAgICByZXR1cm4gcSA/IFgoVWludDhBcnJheS5mcm9tKFtSLmhhc0V2ZW5ZKCkgPyAyIDogM10pLCBEKSA6IFgoVWludDhBcnJheS5mcm9tKFs0XSksIEQsIHIudG9CeXRlcyhILnkpKTtcbiAgICB9LFxuICAgIGZyb21CeXRlcyhFKSB7XG4gICAgICBjb25zdCBSID0gRS5sZW5ndGgsIHEgPSBFWzBdLCBIID0gRS5zdWJhcnJheSgxKTtcbiAgICAgIGlmIChSID09PSBpICYmIChxID09PSAyIHx8IHEgPT09IDMpKSB7XG4gICAgICAgIGNvbnN0IEQgPSBsZShIKTtcbiAgICAgICAgaWYgKCFvKEQpKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBvaW50IGlzIG5vdCBvbiBjdXJ2ZVwiKTtcbiAgICAgICAgY29uc3QgWCA9IHUoRCk7XG4gICAgICAgIGxldCBvZSA9IHIuc3FydChYKTtcbiAgICAgICAgY29uc3QgcmUgPSAob2UgJiBZKSA9PT0gWTtcbiAgICAgICAgcmV0dXJuIChxICYgMSkgPT09IDEgIT09IHJlICYmIChvZSA9IHIubmVnKG9lKSksIHsgeDogRCwgeTogb2UgfTtcbiAgICAgIH0gZWxzZSBpZiAoUiA9PT0gcyAmJiBxID09PSA0KSB7XG4gICAgICAgIGNvbnN0IEQgPSByLmZyb21CeXRlcyhILnN1YmFycmF5KDAsIHIuQllURVMpKSwgWCA9IHIuZnJvbUJ5dGVzKEguc3ViYXJyYXkoci5CWVRFUywgMiAqIHIuQllURVMpKTtcbiAgICAgICAgcmV0dXJuIHsgeDogRCwgeTogWCB9O1xuICAgICAgfSBlbHNlXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9pbnQgb2YgbGVuZ3RoICR7Un0gd2FzIGludmFsaWQuIEV4cGVjdGVkICR7aX0gY29tcHJlc3NlZCBieXRlcyBvciAke3N9IHVuY29tcHJlc3NlZCBieXRlc2ApO1xuICAgIH1cbiAgfSksIGQgPSAoRSkgPT4gdnQoZXQoRSwgZS5uQnl0ZUxlbmd0aCkpO1xuICBmdW5jdGlvbiBwKEUpIHtcbiAgICBjb25zdCBSID0gbiA+PiBZO1xuICAgIHJldHVybiBFID4gUjtcbiAgfVxuICBmdW5jdGlvbiB5KEUpIHtcbiAgICByZXR1cm4gcChFKSA/IGEoLUUpIDogRTtcbiAgfVxuICBjb25zdCBnID0gKEUsIFIsIHEpID0+IGxlKEUuc2xpY2UoUiwgcSkpO1xuICBjbGFzcyB2IHtcbiAgICBjb25zdHJ1Y3RvcihSLCBxLCBIKSB7XG4gICAgICB0aGlzLnIgPSBSLCB0aGlzLnMgPSBxLCB0aGlzLnJlY292ZXJ5ID0gSCwgdGhpcy5hc3NlcnRWYWxpZGl0eSgpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUNvbXBhY3QoUikge1xuICAgICAgY29uc3QgcSA9IGUubkJ5dGVMZW5ndGg7XG4gICAgICByZXR1cm4gUiA9IGVlKFwiY29tcGFjdFNpZ25hdHVyZVwiLCBSLCBxICogMiksIG5ldyB2KGcoUiwgMCwgcSksIGcoUiwgcSwgMiAqIHEpKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21ERVIoUikge1xuICAgICAgY29uc3QgeyByOiBxLCBzOiBIIH0gPSBsdC50b1NpZyhlZShcIkRFUlwiLCBSKSk7XG4gICAgICByZXR1cm4gbmV3IHYocSwgSCk7XG4gICAgfVxuICAgIGFzc2VydFZhbGlkaXR5KCkge1xuICAgICAgaWYgKCFoKHRoaXMucikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInIgbXVzdCBiZSAwIDwgciA8IENVUlZFLm5cIik7XG4gICAgICBpZiAoIWgodGhpcy5zKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicyBtdXN0IGJlIDAgPCBzIDwgQ1VSVkUublwiKTtcbiAgICB9XG4gICAgYWRkUmVjb3ZlcnlCaXQoUikge1xuICAgICAgcmV0dXJuIG5ldyB2KHRoaXMuciwgdGhpcy5zLCBSKTtcbiAgICB9XG4gICAgcmVjb3ZlclB1YmxpY0tleShSKSB7XG4gICAgICBjb25zdCB7IHI6IHEsIHM6IEgsIHJlY292ZXJ5OiBEIH0gPSB0aGlzLCBYID0geChlZShcIm1zZ0hhc2hcIiwgUikpO1xuICAgICAgaWYgKEQgPT0gbnVsbCB8fCAhWzAsIDEsIDIsIDNdLmluY2x1ZGVzKEQpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZWNvdmVyeSBpZCBpbnZhbGlkXCIpO1xuICAgICAgY29uc3Qgb2UgPSBEID09PSAyIHx8IEQgPT09IDMgPyBxICsgZS5uIDogcTtcbiAgICAgIGlmIChvZSA+PSByLk9SREVSKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZWNvdmVyeSBpZCAyIG9yIDMgaW52YWxpZFwiKTtcbiAgICAgIGNvbnN0IHJlID0gKEQgJiAxKSA9PT0gMCA/IFwiMDJcIiA6IFwiMDNcIiwgX2UgPSBsLmZyb21IZXgocmUgKyBkKG9lKSksIE9lID0gYyhvZSksIFVlID0gYSgtWCAqIE9lKSwgUGUgPSBhKEggKiBPZSksIHllID0gbC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKF9lLCBVZSwgUGUpO1xuICAgICAgaWYgKCF5ZSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicG9pbnQgYXQgaW5maW5pZnlcIik7XG4gICAgICByZXR1cm4geWUuYXNzZXJ0VmFsaWRpdHkoKSwgeWU7XG4gICAgfVxuICAgIGhhc0hpZ2hTKCkge1xuICAgICAgcmV0dXJuIHAodGhpcy5zKTtcbiAgICB9XG4gICAgbm9ybWFsaXplUygpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhc0hpZ2hTKCkgPyBuZXcgdih0aGlzLnIsIGEoLXRoaXMucyksIHRoaXMucmVjb3ZlcnkpIDogdGhpcztcbiAgICB9XG4gICAgdG9ERVJSYXdCeXRlcygpIHtcbiAgICAgIHJldHVybiB3dCh0aGlzLnRvREVSSGV4KCkpO1xuICAgIH1cbiAgICB0b0RFUkhleCgpIHtcbiAgICAgIHJldHVybiBsdC5oZXhGcm9tU2lnKHsgcjogdGhpcy5yLCBzOiB0aGlzLnMgfSk7XG4gICAgfVxuICAgIHRvQ29tcGFjdFJhd0J5dGVzKCkge1xuICAgICAgcmV0dXJuIHd0KHRoaXMudG9Db21wYWN0SGV4KCkpO1xuICAgIH1cbiAgICB0b0NvbXBhY3RIZXgoKSB7XG4gICAgICByZXR1cm4gZCh0aGlzLnIpICsgZCh0aGlzLnMpO1xuICAgIH1cbiAgfVxuICBjb25zdCBfID0ge1xuICAgIGlzVmFsaWRQcml2YXRlS2V5KEUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBmKEUpLCAhMDtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICByZXR1cm4gITE7XG4gICAgICB9XG4gICAgfSxcbiAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyOiBmLFxuICAgIHJhbmRvbVByaXZhdGVLZXk6ICgpID0+IHtcbiAgICAgIGNvbnN0IEUgPSBlLnJhbmRvbUJ5dGVzKHIuQllURVMgKyA4KSwgUiA9IEtjKEUsIG4pO1xuICAgICAgcmV0dXJuIGV0KFIsIGUubkJ5dGVMZW5ndGgpO1xuICAgIH0sXG4gICAgcHJlY29tcHV0ZShFID0gOCwgUiA9IGwuQkFTRSkge1xuICAgICAgcmV0dXJuIFIuX3NldFdpbmRvd1NpemUoRSksIFIubXVsdGlwbHkoQmlnSW50KDMpKSwgUjtcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIG0oRSwgUiA9ICEwKSB7XG4gICAgcmV0dXJuIGwuZnJvbVByaXZhdGVLZXkoRSkudG9SYXdCeXRlcyhSKTtcbiAgfVxuICBmdW5jdGlvbiBDKEUpIHtcbiAgICBjb25zdCBSID0gRSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXksIHEgPSB0eXBlb2YgRSA9PSBcInN0cmluZ1wiLCBIID0gKFIgfHwgcSkgJiYgRS5sZW5ndGg7XG4gICAgcmV0dXJuIFIgPyBIID09PSBpIHx8IEggPT09IHMgOiBxID8gSCA9PT0gMiAqIGkgfHwgSCA9PT0gMiAqIHMgOiBFIGluc3RhbmNlb2YgbDtcbiAgfVxuICBmdW5jdGlvbiBPKEUsIFIsIHEgPSAhMCkge1xuICAgIGlmIChDKEUpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZmlyc3QgYXJnIG11c3QgYmUgcHJpdmF0ZSBrZXlcIik7XG4gICAgaWYgKCFDKFIpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2Vjb25kIGFyZyBtdXN0IGJlIHB1YmxpYyBrZXlcIik7XG4gICAgcmV0dXJuIGwuZnJvbUhleChSKS5tdWx0aXBseShmKEUpKS50b1Jhd0J5dGVzKHEpO1xuICB9XG4gIGNvbnN0IHcgPSBlLmJpdHMyaW50IHx8IGZ1bmN0aW9uKEUpIHtcbiAgICBjb25zdCBSID0gbGUoRSksIHEgPSBFLmxlbmd0aCAqIDggLSBlLm5CaXRMZW5ndGg7XG4gICAgcmV0dXJuIHEgPiAwID8gUiA+PiBCaWdJbnQocSkgOiBSO1xuICB9LCB4ID0gZS5iaXRzMmludF9tb2ROIHx8IGZ1bmN0aW9uKEUpIHtcbiAgICByZXR1cm4gYSh3KEUpKTtcbiAgfSwgQSA9IEtuKGUubkJpdExlbmd0aCk7XG4gIGZ1bmN0aW9uIEIoRSkge1xuICAgIGlmICh0eXBlb2YgRSAhPSBcImJpZ2ludFwiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmlnaW50IGV4cGVjdGVkXCIpO1xuICAgIGlmICghKGtlIDw9IEUgJiYgRSA8IEEpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBiaWdpbnQgZXhwZWN0ZWQgPCAyXiR7ZS5uQml0TGVuZ3RofWApO1xuICAgIHJldHVybiBldChFLCBlLm5CeXRlTGVuZ3RoKTtcbiAgfVxuICBmdW5jdGlvbiBMKEUsIFIsIHEgPSBQKSB7XG4gICAgaWYgKFtcInJlY292ZXJlZFwiLCBcImNhbm9uaWNhbFwiXS5zb21lKChtZSkgPT4gbWUgaW4gcSkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzaWduKCkgbGVnYWN5IG9wdGlvbnMgbm90IHN1cHBvcnRlZFwiKTtcbiAgICBjb25zdCB7IGhhc2g6IEgsIHJhbmRvbUJ5dGVzOiBEIH0gPSBlO1xuICAgIGxldCB7IGxvd1M6IFgsIHByZWhhc2g6IG9lLCBleHRyYUVudHJvcHk6IHJlIH0gPSBxO1xuICAgIFggPT0gbnVsbCAmJiAoWCA9ICEwKSwgRSA9IGVlKFwibXNnSGFzaFwiLCBFKSwgb2UgJiYgKEUgPSBlZShcInByZWhhc2hlZCBtc2dIYXNoXCIsIEgoRSkpKTtcbiAgICBjb25zdCBfZSA9IHgoRSksIE9lID0gZihSKSwgVWUgPSBbQihPZSksIEIoX2UpXTtcbiAgICBpZiAocmUgIT0gbnVsbCkge1xuICAgICAgY29uc3QgbWUgPSByZSA9PT0gITAgPyBEKHIuQllURVMpIDogcmU7XG4gICAgICBVZS5wdXNoKGVlKFwiZXh0cmFFbnRyb3B5XCIsIG1lLCByLkJZVEVTKSk7XG4gICAgfVxuICAgIGNvbnN0IFBlID0gaGUoLi4uVWUpLCB5ZSA9IF9lO1xuICAgIGZ1bmN0aW9uIGplKG1lKSB7XG4gICAgICBjb25zdCB4ZSA9IHcobWUpO1xuICAgICAgaWYgKCFoKHhlKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgbHIgPSBjKHhlKSwgQmUgPSBsLkJBU0UubXVsdGlwbHkoeGUpLnRvQWZmaW5lKCksIGZlID0gYShCZS54KTtcbiAgICAgIGlmIChmZSA9PT0ga2UpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IEhlID0gYShsciAqIGEoeWUgKyBmZSAqIE9lKSk7XG4gICAgICBpZiAoSGUgPT09IGtlKVxuICAgICAgICByZXR1cm47XG4gICAgICBsZXQgaXQgPSAoQmUueCA9PT0gZmUgPyAwIDogMikgfCBOdW1iZXIoQmUueSAmIFkpLCBvdCA9IEhlO1xuICAgICAgcmV0dXJuIFggJiYgcChIZSkgJiYgKG90ID0geShIZSksIGl0IF49IDEpLCBuZXcgdihmZSwgb3QsIGl0KTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc2VlZDogUGUsIGsyc2lnOiBqZSB9O1xuICB9XG4gIGNvbnN0IFAgPSB7IGxvd1M6IGUubG93UywgcHJlaGFzaDogITEgfSwgRiA9IHsgbG93UzogZS5sb3dTLCBwcmVoYXNoOiAhMSB9O1xuICBmdW5jdGlvbiB6KEUsIFIsIHEgPSBQKSB7XG4gICAgY29uc3QgeyBzZWVkOiBILCBrMnNpZzogRCB9ID0gTChFLCBSLCBxKTtcbiAgICByZXR1cm4gaXMoZS5oYXNoLm91dHB1dExlbiwgZS5uQnl0ZUxlbmd0aCwgZS5obWFjKShILCBEKTtcbiAgfVxuICBsLkJBU0UuX3NldFdpbmRvd1NpemUoOCk7XG4gIGZ1bmN0aW9uIEcoRSwgUiwgcSwgSCA9IEYpIHtcbiAgICB2YXIgQmU7XG4gICAgY29uc3QgRCA9IEU7XG4gICAgaWYgKFIgPSBlZShcIm1zZ0hhc2hcIiwgUiksIHEgPSBlZShcInB1YmxpY0tleVwiLCBxKSwgXCJzdHJpY3RcIiBpbiBIKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwib3B0aW9ucy5zdHJpY3Qgd2FzIHJlbmFtZWQgdG8gbG93U1wiKTtcbiAgICBjb25zdCB7IGxvd1M6IFgsIHByZWhhc2g6IG9lIH0gPSBIO1xuICAgIGxldCByZSwgX2U7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2YgRCA9PSBcInN0cmluZ1wiIHx8IEQgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlID0gdi5mcm9tREVSKEQpO1xuICAgICAgICB9IGNhdGNoIChmZSkge1xuICAgICAgICAgIGlmICghKGZlIGluc3RhbmNlb2YgbHQuRXJyKSlcbiAgICAgICAgICAgIHRocm93IGZlO1xuICAgICAgICAgIHJlID0gdi5mcm9tQ29tcGFjdChEKTtcbiAgICAgICAgfVxuICAgICAgZWxzZSBpZiAodHlwZW9mIEQgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgRC5yID09IFwiYmlnaW50XCIgJiYgdHlwZW9mIEQucyA9PSBcImJpZ2ludFwiKSB7XG4gICAgICAgIGNvbnN0IHsgcjogZmUsIHM6IEhlIH0gPSBEO1xuICAgICAgICByZSA9IG5ldyB2KGZlLCBIZSk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUEFSU0VcIik7XG4gICAgICBfZSA9IGwuZnJvbUhleChxKTtcbiAgICB9IGNhdGNoIChmZSkge1xuICAgICAgaWYgKGZlLm1lc3NhZ2UgPT09IFwiUEFSU0VcIilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2lnbmF0dXJlIG11c3QgYmUgU2lnbmF0dXJlIGluc3RhbmNlLCBVaW50OEFycmF5IG9yIGhleCBzdHJpbmdcIik7XG4gICAgICByZXR1cm4gITE7XG4gICAgfVxuICAgIGlmIChYICYmIHJlLmhhc0hpZ2hTKCkpXG4gICAgICByZXR1cm4gITE7XG4gICAgb2UgJiYgKFIgPSBlLmhhc2goUikpO1xuICAgIGNvbnN0IHsgcjogT2UsIHM6IFVlIH0gPSByZSwgUGUgPSB4KFIpLCB5ZSA9IGMoVWUpLCBqZSA9IGEoUGUgKiB5ZSksIG1lID0gYShPZSAqIHllKSwgeGUgPSAoQmUgPSBsLkJBU0UubXVsdGlwbHlBbmRBZGRVbnNhZmUoX2UsIGplLCBtZSkpID09IG51bGwgPyB2b2lkIDAgOiBCZS50b0FmZmluZSgpO1xuICAgIHJldHVybiB4ZSA/IGEoeGUueCkgPT09IE9lIDogITE7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBDVVJWRTogZSxcbiAgICBnZXRQdWJsaWNLZXk6IG0sXG4gICAgZ2V0U2hhcmVkU2VjcmV0OiBPLFxuICAgIHNpZ246IHosXG4gICAgdmVyaWZ5OiBHLFxuICAgIFByb2plY3RpdmVQb2ludDogbCxcbiAgICBTaWduYXR1cmU6IHYsXG4gICAgdXRpbHM6IF9cbiAgfTtcbn1cbmZ1bmN0aW9uIGV1KHQsIGUpIHtcbiAgY29uc3QgciA9IHQuT1JERVI7XG4gIGxldCBuID0ga2U7XG4gIGZvciAobGV0IGggPSByIC0gWTsgaCAlICRlID09PSBrZTsgaCAvPSAkZSlcbiAgICBuICs9IFk7XG4gIGNvbnN0IGkgPSBuLCBzID0gKHIgLSBZKSAvICRlICoqIGksIG8gPSAocyAtIFkpIC8gJGUsIGEgPSAkZSAqKiBpIC0gWSwgYyA9ICRlICoqIChpIC0gWSksIGwgPSB0LnBvdyhlLCBzKSwgZiA9IHQucG93KGUsIChzICsgWSkgLyAkZSk7XG4gIGxldCB1ID0gKGgsIGQpID0+IHtcbiAgICBsZXQgcCA9IGwsIHkgPSB0LnBvdyhkLCBhKSwgZyA9IHQuc3FyKHkpO1xuICAgIGcgPSB0Lm11bChnLCBkKTtcbiAgICBsZXQgdiA9IHQubXVsKGgsIGcpO1xuICAgIHYgPSB0LnBvdyh2LCBvKSwgdiA9IHQubXVsKHYsIHkpLCB5ID0gdC5tdWwodiwgZCksIGcgPSB0Lm11bCh2LCBoKTtcbiAgICBsZXQgXyA9IHQubXVsKGcsIHkpO1xuICAgIHYgPSB0LnBvdyhfLCBjKTtcbiAgICBsZXQgbSA9IHQuZXFsKHYsIHQuT05FKTtcbiAgICB5ID0gdC5tdWwoZywgZiksIHYgPSB0Lm11bChfLCBwKSwgZyA9IHQuY21vdih5LCBnLCBtKSwgXyA9IHQuY21vdih2LCBfLCBtKTtcbiAgICBmb3IgKGxldCBDID0gaTsgQyA+IFk7IEMtLSkge1xuICAgICAgbGV0IE8gPSAkZSAqKiAoQyAtICRlKSwgdyA9IHQucG93KF8sIE8pO1xuICAgICAgY29uc3QgeCA9IHQuZXFsKHcsIHQuT05FKTtcbiAgICAgIHkgPSB0Lm11bChnLCBwKSwgcCA9IHQubXVsKHAsIHApLCB3ID0gdC5tdWwoXywgcCksIGcgPSB0LmNtb3YoeSwgZywgeCksIF8gPSB0LmNtb3YodywgXywgeCk7XG4gICAgfVxuICAgIHJldHVybiB7IGlzVmFsaWQ6IG0sIHZhbHVlOiBnIH07XG4gIH07XG4gIGlmICh0Lk9SREVSICUgSGkgPT09IEFyKSB7XG4gICAgY29uc3QgaCA9ICh0Lk9SREVSIC0gQXIpIC8gSGksIGQgPSB0LnNxcnQodC5uZWcoZSkpO1xuICAgIHUgPSAocCwgeSkgPT4ge1xuICAgICAgbGV0IGcgPSB0LnNxcih5KTtcbiAgICAgIGNvbnN0IHYgPSB0Lm11bChwLCB5KTtcbiAgICAgIGcgPSB0Lm11bChnLCB2KTtcbiAgICAgIGxldCBfID0gdC5wb3coZywgaCk7XG4gICAgICBfID0gdC5tdWwoXywgdik7XG4gICAgICBjb25zdCBtID0gdC5tdWwoXywgZCksIEMgPSB0Lm11bCh0LnNxcihfKSwgeSksIE8gPSB0LmVxbChDLCBwKTtcbiAgICAgIGxldCB3ID0gdC5jbW92KG0sIF8sIE8pO1xuICAgICAgcmV0dXJuIHsgaXNWYWxpZDogTywgdmFsdWU6IHcgfTtcbiAgICB9O1xuICB9XG4gIHJldHVybiB1O1xufVxuZnVuY3Rpb24gdHUodCwgZSkge1xuICBpZiAob3ModCksICF0LmlzVmFsaWQoZS5BKSB8fCAhdC5pc1ZhbGlkKGUuQikgfHwgIXQuaXNWYWxpZChlLlopKVxuICAgIHRocm93IG5ldyBFcnJvcihcIm1hcFRvQ3VydmVTaW1wbGVTV1U6IGludmFsaWQgb3B0c1wiKTtcbiAgY29uc3QgciA9IGV1KHQsIGUuWik7XG4gIGlmICghdC5pc09kZClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJGcC5pc09kZCBpcyBub3QgaW1wbGVtZW50ZWQhXCIpO1xuICByZXR1cm4gKG4pID0+IHtcbiAgICBsZXQgaSwgcywgbywgYSwgYywgbCwgZiwgdTtcbiAgICBpID0gdC5zcXIobiksIGkgPSB0Lm11bChpLCBlLlopLCBzID0gdC5zcXIoaSksIHMgPSB0LmFkZChzLCBpKSwgbyA9IHQuYWRkKHMsIHQuT05FKSwgbyA9IHQubXVsKG8sIGUuQiksIGEgPSB0LmNtb3YoZS5aLCB0Lm5lZyhzKSwgIXQuZXFsKHMsIHQuWkVSTykpLCBhID0gdC5tdWwoYSwgZS5BKSwgcyA9IHQuc3FyKG8pLCBsID0gdC5zcXIoYSksIGMgPSB0Lm11bChsLCBlLkEpLCBzID0gdC5hZGQocywgYyksIHMgPSB0Lm11bChzLCBvKSwgbCA9IHQubXVsKGwsIGEpLCBjID0gdC5tdWwobCwgZS5CKSwgcyA9IHQuYWRkKHMsIGMpLCBmID0gdC5tdWwoaSwgbyk7XG4gICAgY29uc3QgeyBpc1ZhbGlkOiBoLCB2YWx1ZTogZCB9ID0gcihzLCBsKTtcbiAgICB1ID0gdC5tdWwoaSwgbiksIHUgPSB0Lm11bCh1LCBkKSwgZiA9IHQuY21vdihmLCBvLCBoKSwgdSA9IHQuY21vdih1LCBkLCBoKTtcbiAgICBjb25zdCBwID0gdC5pc09kZChuKSA9PT0gdC5pc09kZCh1KTtcbiAgICByZXR1cm4gdSA9IHQuY21vdih0Lm5lZyh1KSwgdSwgcCksIGYgPSB0LmRpdihmLCBhKSwgeyB4OiBmLCB5OiB1IH07XG4gIH07XG59XG5mdW5jdGlvbiBydSh0KSB7XG4gIGlmICh0IGluc3RhbmNlb2YgVWludDhBcnJheSlcbiAgICByZXR1cm4gdDtcbiAgaWYgKHR5cGVvZiB0ID09IFwic3RyaW5nXCIpXG4gICAgcmV0dXJuIHFyKHQpO1xuICB0aHJvdyBuZXcgRXJyb3IoXCJEU1QgbXVzdCBiZSBVaW50OEFycmF5IG9yIHN0cmluZ1wiKTtcbn1cbmNvbnN0IG51ID0gbGU7XG5mdW5jdGlvbiBaZSh0LCBlKSB7XG4gIGlmICh0IDwgMCB8fCB0ID49IDEgPDwgOCAqIGUpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBiYWQgSTJPU1AgY2FsbDogdmFsdWU9JHt0fSBsZW5ndGg9JHtlfWApO1xuICBjb25zdCByID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogZSB9KS5maWxsKDApO1xuICBmb3IgKGxldCBuID0gZSAtIDE7IG4gPj0gMDsgbi0tKVxuICAgIHJbbl0gPSB0ICYgMjU1LCB0ID4+Pj0gODtcbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHIpO1xufVxuZnVuY3Rpb24gaXUodCwgZSkge1xuICBjb25zdCByID0gbmV3IFVpbnQ4QXJyYXkodC5sZW5ndGgpO1xuICBmb3IgKGxldCBuID0gMDsgbiA8IHQubGVuZ3RoOyBuKyspXG4gICAgcltuXSA9IHRbbl0gXiBlW25dO1xuICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIHRyKHQpIHtcbiAgaWYgKCEodCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgIHRocm93IG5ldyBFcnJvcihcIlVpbnQ4QXJyYXkgZXhwZWN0ZWRcIik7XG59XG5mdW5jdGlvbiBWbih0KSB7XG4gIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIodCkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwibnVtYmVyIGV4cGVjdGVkXCIpO1xufVxuZnVuY3Rpb24gb3UodCwgZSwgciwgbikge1xuICB0cih0KSwgdHIoZSksIFZuKHIpLCBlLmxlbmd0aCA+IDI1NSAmJiAoZSA9IG4oaGUocXIoXCJIMkMtT1ZFUlNJWkUtRFNULVwiKSwgZSkpKTtcbiAgY29uc3QgeyBvdXRwdXRMZW46IGksIGJsb2NrTGVuOiBzIH0gPSBuLCBvID0gTWF0aC5jZWlsKHIgLyBpKTtcbiAgaWYgKG8gPiAyNTUpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB4bWQgbGVuZ3RoXCIpO1xuICBjb25zdCBhID0gaGUoZSwgWmUoZS5sZW5ndGgsIDEpKSwgYyA9IFplKDAsIHMpLCBsID0gWmUociwgMiksIGYgPSBuZXcgQXJyYXkobyksIHUgPSBuKGhlKGMsIHQsIGwsIFplKDAsIDEpLCBhKSk7XG4gIGZbMF0gPSBuKGhlKHUsIFplKDEsIDEpLCBhKSk7XG4gIGZvciAobGV0IGQgPSAxOyBkIDw9IG87IGQrKykge1xuICAgIGNvbnN0IHAgPSBbaXUodSwgZltkIC0gMV0pLCBaZShkICsgMSwgMSksIGFdO1xuICAgIGZbZF0gPSBuKGhlKC4uLnApKTtcbiAgfVxuICByZXR1cm4gaGUoLi4uZikuc2xpY2UoMCwgcik7XG59XG5mdW5jdGlvbiBzdSh0LCBlLCByLCBuLCBpKSB7XG4gIGlmICh0cih0KSwgdHIoZSksIFZuKHIpLCBlLmxlbmd0aCA+IDI1NSkge1xuICAgIGNvbnN0IHMgPSBNYXRoLmNlaWwoMiAqIG4gLyA4KTtcbiAgICBlID0gaS5jcmVhdGUoeyBka0xlbjogcyB9KS51cGRhdGUocXIoXCJIMkMtT1ZFUlNJWkUtRFNULVwiKSkudXBkYXRlKGUpLmRpZ2VzdCgpO1xuICB9XG4gIGlmIChyID4gNjU1MzUgfHwgZS5sZW5ndGggPiAyNTUpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZXhwYW5kX21lc3NhZ2VfeG9mOiBpbnZhbGlkIGxlbkluQnl0ZXNcIik7XG4gIHJldHVybiBpLmNyZWF0ZSh7IGRrTGVuOiByIH0pLnVwZGF0ZSh0KS51cGRhdGUoWmUociwgMikpLnVwZGF0ZShlKS51cGRhdGUoWmUoZS5sZW5ndGgsIDEpKS5kaWdlc3QoKTtcbn1cbmZ1bmN0aW9uIE1pKHQsIGUsIHIpIHtcbiAga3Qociwge1xuICAgIERTVDogXCJzdHJpbmdcIixcbiAgICBwOiBcImJpZ2ludFwiLFxuICAgIG06IFwiaXNTYWZlSW50ZWdlclwiLFxuICAgIGs6IFwiaXNTYWZlSW50ZWdlclwiLFxuICAgIGhhc2g6IFwiaGFzaFwiXG4gIH0pO1xuICBjb25zdCB7IHA6IG4sIGs6IGksIG06IHMsIGhhc2g6IG8sIGV4cGFuZDogYSwgRFNUOiBjIH0gPSByO1xuICB0cih0KSwgVm4oZSk7XG4gIGNvbnN0IGwgPSBydShjKSwgZiA9IG4udG9TdHJpbmcoMikubGVuZ3RoLCB1ID0gTWF0aC5jZWlsKChmICsgaSkgLyA4KSwgaCA9IGUgKiBzICogdTtcbiAgbGV0IGQ7XG4gIGlmIChhID09PSBcInhtZFwiKVxuICAgIGQgPSBvdSh0LCBsLCBoLCBvKTtcbiAgZWxzZSBpZiAoYSA9PT0gXCJ4b2ZcIilcbiAgICBkID0gc3UodCwgbCwgaCwgaSwgbyk7XG4gIGVsc2UgaWYgKGEgPT09IFwiX2ludGVybmFsX3Bhc3NcIilcbiAgICBkID0gdDtcbiAgZWxzZVxuICAgIHRocm93IG5ldyBFcnJvcignZXhwYW5kIG11c3QgYmUgXCJ4bWRcIiBvciBcInhvZlwiJyk7XG4gIGNvbnN0IHAgPSBuZXcgQXJyYXkoZSk7XG4gIGZvciAobGV0IHkgPSAwOyB5IDwgZTsgeSsrKSB7XG4gICAgY29uc3QgZyA9IG5ldyBBcnJheShzKTtcbiAgICBmb3IgKGxldCB2ID0gMDsgdiA8IHM7IHYrKykge1xuICAgICAgY29uc3QgXyA9IHUgKiAodiArIHkgKiBzKSwgbSA9IGQuc3ViYXJyYXkoXywgXyArIHUpO1xuICAgICAgZ1t2XSA9IEoobnUobSksIG4pO1xuICAgIH1cbiAgICBwW3ldID0gZztcbiAgfVxuICByZXR1cm4gcDtcbn1cbmZ1bmN0aW9uIGF1KHQsIGUpIHtcbiAgY29uc3QgciA9IGUubWFwKChuKSA9PiBBcnJheS5mcm9tKG4pLnJldmVyc2UoKSk7XG4gIHJldHVybiAobiwgaSkgPT4ge1xuICAgIGNvbnN0IFtzLCBvLCBhLCBjXSA9IHIubWFwKChsKSA9PiBsLnJlZHVjZSgoZiwgdSkgPT4gdC5hZGQodC5tdWwoZiwgbiksIHUpKSk7XG4gICAgcmV0dXJuIG4gPSB0LmRpdihzLCBvKSwgaSA9IHQubXVsKGksIHQuZGl2KGEsIGMpKSwgeyB4OiBuLCB5OiBpIH07XG4gIH07XG59XG5mdW5jdGlvbiBjdSh0LCBlLCByKSB7XG4gIGlmICh0eXBlb2YgZSAhPSBcImZ1bmN0aW9uXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwibWFwVG9DdXJ2ZSgpIG11c3QgYmUgZGVmaW5lZFwiKTtcbiAgcmV0dXJuIHtcbiAgICBoYXNoVG9DdXJ2ZShuLCBpKSB7XG4gICAgICBjb25zdCBzID0gTWkobiwgMiwgeyAuLi5yLCBEU1Q6IHIuRFNULCAuLi5pIH0pLCBvID0gdC5mcm9tQWZmaW5lKGUoc1swXSkpLCBhID0gdC5mcm9tQWZmaW5lKGUoc1sxXSkpLCBjID0gby5hZGQoYSkuY2xlYXJDb2ZhY3RvcigpO1xuICAgICAgcmV0dXJuIGMuYXNzZXJ0VmFsaWRpdHkoKSwgYztcbiAgICB9LFxuICAgIGVuY29kZVRvQ3VydmUobiwgaSkge1xuICAgICAgY29uc3QgcyA9IE1pKG4sIDEsIHsgLi4uciwgRFNUOiByLmVuY29kZURTVCwgLi4uaSB9KSwgbyA9IHQuZnJvbUFmZmluZShlKHNbMF0pKS5jbGVhckNvZmFjdG9yKCk7XG4gICAgICByZXR1cm4gby5hc3NlcnRWYWxpZGl0eSgpLCBvO1xuICAgIH1cbiAgfTtcbn1cbmNsYXNzIGFzIGV4dGVuZHMgSm8ge1xuICBjb25zdHJ1Y3RvcihlLCByKSB7XG4gICAgc3VwZXIoKSwgdGhpcy5maW5pc2hlZCA9ICExLCB0aGlzLmRlc3Ryb3llZCA9ICExLCB1dC5oYXNoKGUpO1xuICAgIGNvbnN0IG4gPSBEbihyKTtcbiAgICBpZiAodGhpcy5pSGFzaCA9IGUuY3JlYXRlKCksIHR5cGVvZiB0aGlzLmlIYXNoLnVwZGF0ZSAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgaW5zdGFuY2Ugb2YgY2xhc3Mgd2hpY2ggZXh0ZW5kcyB1dGlscy5IYXNoXCIpO1xuICAgIHRoaXMuYmxvY2tMZW4gPSB0aGlzLmlIYXNoLmJsb2NrTGVuLCB0aGlzLm91dHB1dExlbiA9IHRoaXMuaUhhc2gub3V0cHV0TGVuO1xuICAgIGNvbnN0IGkgPSB0aGlzLmJsb2NrTGVuLCBzID0gbmV3IFVpbnQ4QXJyYXkoaSk7XG4gICAgcy5zZXQobi5sZW5ndGggPiBpID8gZS5jcmVhdGUoKS51cGRhdGUobikuZGlnZXN0KCkgOiBuKTtcbiAgICBmb3IgKGxldCBvID0gMDsgbyA8IHMubGVuZ3RoOyBvKyspXG4gICAgICBzW29dIF49IDU0O1xuICAgIHRoaXMuaUhhc2gudXBkYXRlKHMpLCB0aGlzLm9IYXNoID0gZS5jcmVhdGUoKTtcbiAgICBmb3IgKGxldCBvID0gMDsgbyA8IHMubGVuZ3RoOyBvKyspXG4gICAgICBzW29dIF49IDEwNjtcbiAgICB0aGlzLm9IYXNoLnVwZGF0ZShzKSwgcy5maWxsKDApO1xuICB9XG4gIHVwZGF0ZShlKSB7XG4gICAgcmV0dXJuIHV0LmV4aXN0cyh0aGlzKSwgdGhpcy5pSGFzaC51cGRhdGUoZSksIHRoaXM7XG4gIH1cbiAgZGlnZXN0SW50byhlKSB7XG4gICAgdXQuZXhpc3RzKHRoaXMpLCB1dC5ieXRlcyhlLCB0aGlzLm91dHB1dExlbiksIHRoaXMuZmluaXNoZWQgPSAhMCwgdGhpcy5pSGFzaC5kaWdlc3RJbnRvKGUpLCB0aGlzLm9IYXNoLnVwZGF0ZShlKSwgdGhpcy5vSGFzaC5kaWdlc3RJbnRvKGUpLCB0aGlzLmRlc3Ryb3koKTtcbiAgfVxuICBkaWdlc3QoKSB7XG4gICAgY29uc3QgZSA9IG5ldyBVaW50OEFycmF5KHRoaXMub0hhc2gub3V0cHV0TGVuKTtcbiAgICByZXR1cm4gdGhpcy5kaWdlc3RJbnRvKGUpLCBlO1xuICB9XG4gIF9jbG9uZUludG8oZSkge1xuICAgIGUgfHwgKGUgPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSwge30pKTtcbiAgICBjb25zdCB7IG9IYXNoOiByLCBpSGFzaDogbiwgZmluaXNoZWQ6IGksIGRlc3Ryb3llZDogcywgYmxvY2tMZW46IG8sIG91dHB1dExlbjogYSB9ID0gdGhpcztcbiAgICByZXR1cm4gZSA9IGUsIGUuZmluaXNoZWQgPSBpLCBlLmRlc3Ryb3llZCA9IHMsIGUuYmxvY2tMZW4gPSBvLCBlLm91dHB1dExlbiA9IGEsIGUub0hhc2ggPSByLl9jbG9uZUludG8oZS5vSGFzaCksIGUuaUhhc2ggPSBuLl9jbG9uZUludG8oZS5pSGFzaCksIGU7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRlc3Ryb3llZCA9ICEwLCB0aGlzLm9IYXNoLmRlc3Ryb3koKSwgdGhpcy5pSGFzaC5kZXN0cm95KCk7XG4gIH1cbn1cbmNvbnN0IGNzID0gKHQsIGUsIHIpID0+IG5ldyBhcyh0LCBlKS51cGRhdGUocikuZGlnZXN0KCk7XG5jcy5jcmVhdGUgPSAodCwgZSkgPT4gbmV3IGFzKHQsIGUpO1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuZnVuY3Rpb24gdXUodCkge1xuICByZXR1cm4ge1xuICAgIGhhc2g6IHQsXG4gICAgaG1hYzogKGUsIC4uLnIpID0+IGNzKHQsIGUsIG1jKC4uLnIpKSxcbiAgICByYW5kb21CeXRlczogUW9cbiAgfTtcbn1cbmZ1bmN0aW9uIGx1KHQsIGUpIHtcbiAgY29uc3QgciA9IChuKSA9PiBRYyh7IC4uLnQsIC4uLnV1KG4pIH0pO1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IC4uLnIoZSksIGNyZWF0ZTogciB9KTtcbn1cbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmNvbnN0IE5yID0gQmlnSW50KFwiMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWZmZmZmYzJmXCIpLCBDciA9IEJpZ0ludChcIjB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmViYWFlZGNlNmFmNDhhMDNiYmZkMjVlOGNkMDM2NDE0MVwiKSwgdXMgPSBCaWdJbnQoMSksIElyID0gQmlnSW50KDIpLCBEaSA9ICh0LCBlKSA9PiAodCArIGUgLyBJcikgLyBlO1xuZnVuY3Rpb24gbHModCkge1xuICBjb25zdCBlID0gTnIsIHIgPSBCaWdJbnQoMyksIG4gPSBCaWdJbnQoNiksIGkgPSBCaWdJbnQoMTEpLCBzID0gQmlnSW50KDIyKSwgbyA9IEJpZ0ludCgyMyksIGEgPSBCaWdJbnQoNDQpLCBjID0gQmlnSW50KDg4KSwgbCA9IHQgKiB0ICogdCAlIGUsIGYgPSBsICogbCAqIHQgJSBlLCB1ID0gYmUoZiwgciwgZSkgKiBmICUgZSwgaCA9IGJlKHUsIHIsIGUpICogZiAlIGUsIGQgPSBiZShoLCBJciwgZSkgKiBsICUgZSwgcCA9IGJlKGQsIGksIGUpICogZCAlIGUsIHkgPSBiZShwLCBzLCBlKSAqIHAgJSBlLCBnID0gYmUoeSwgYSwgZSkgKiB5ICUgZSwgdiA9IGJlKGcsIGMsIGUpICogZyAlIGUsIF8gPSBiZSh2LCBhLCBlKSAqIHkgJSBlLCBtID0gYmUoXywgciwgZSkgKiBmICUgZSwgQyA9IGJlKG0sIG8sIGUpICogcCAlIGUsIE8gPSBiZShDLCBuLCBlKSAqIGwgJSBlLCB3ID0gYmUoTywgSXIsIGUpO1xuICBpZiAoIXR0LmVxbCh0dC5zcXIodyksIHQpKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIHNxdWFyZSByb290XCIpO1xuICByZXR1cm4gdztcbn1cbmNvbnN0IHR0ID0gRmMoTnIsIHZvaWQgMCwgdm9pZCAwLCB7IHNxcnQ6IGxzIH0pLCB1ZSA9IGx1KHtcbiAgYTogQmlnSW50KDApLFxuICBiOiBCaWdJbnQoNyksXG4gIEZwOiB0dCxcbiAgbjogQ3IsXG4gIEd4OiBCaWdJbnQoXCI1NTA2NjI2MzAyMjI3NzM0MzY2OTU3ODcxODg5NTE2ODUzNDMyNjI1MDYwMzQ1Mzc3NzU5NDE3NTUwMDE4NzM2MDM4OTExNjcyOTI0MFwiKSxcbiAgR3k6IEJpZ0ludChcIjMyNjcwNTEwMDIwNzU4ODE2OTc4MDgzMDg1MTMwNTA3MDQzMTg0NDcxMjczMzgwNjU5MjQzMjc1OTM4OTA0MzM1NzU3MzM3NDgyNDI0XCIpLFxuICBoOiBCaWdJbnQoMSksXG4gIGxvd1M6ICEwLFxuICBlbmRvOiB7XG4gICAgYmV0YTogQmlnSW50KFwiMHg3YWU5NmEyYjY1N2MwNzEwNmU2NDQ3OWVhYzM0MzRlOTljZjA0OTc1MTJmNTg5OTVjMTM5NmMyODcxOTUwMWVlXCIpLFxuICAgIHNwbGl0U2NhbGFyOiAodCkgPT4ge1xuICAgICAgY29uc3QgZSA9IENyLCByID0gQmlnSW50KFwiMHgzMDg2ZDIyMWE3ZDQ2YmNkZTg2YzkwZTQ5Mjg0ZWIxNVwiKSwgbiA9IC11cyAqIEJpZ0ludChcIjB4ZTQ0MzdlZDYwMTBlODgyODZmNTQ3ZmE5MGFiZmU0YzNcIiksIGkgPSBCaWdJbnQoXCIweDExNGNhNTBmN2E4ZTJmM2Y2NTdjMTEwOGQ5ZDQ0Y2ZkOFwiKSwgcyA9IHIsIG8gPSBCaWdJbnQoXCIweDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiKSwgYSA9IERpKHMgKiB0LCBlKSwgYyA9IERpKC1uICogdCwgZSk7XG4gICAgICBsZXQgbCA9IEoodCAtIGEgKiByIC0gYyAqIGksIGUpLCBmID0gSigtYSAqIG4gLSBjICogcywgZSk7XG4gICAgICBjb25zdCB1ID0gbCA+IG8sIGggPSBmID4gbztcbiAgICAgIGlmICh1ICYmIChsID0gZSAtIGwpLCBoICYmIChmID0gZSAtIGYpLCBsID4gbyB8fCBmID4gbylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic3BsaXRTY2FsYXI6IEVuZG9tb3JwaGlzbSBmYWlsZWQsIGs9XCIgKyB0KTtcbiAgICAgIHJldHVybiB7IGsxbmVnOiB1LCBrMTogbCwgazJuZWc6IGgsIGsyOiBmIH07XG4gICAgfVxuICB9XG59LCBPciksIFVyID0gQmlnSW50KDApLCBmcyA9ICh0KSA9PiB0eXBlb2YgdCA9PSBcImJpZ2ludFwiICYmIFVyIDwgdCAmJiB0IDwgTnIsIGZ1ID0gKHQpID0+IHR5cGVvZiB0ID09IFwiYmlnaW50XCIgJiYgVXIgPCB0ICYmIHQgPCBDciwgemkgPSB7fTtcbmZ1bmN0aW9uIFJyKHQsIC4uLmUpIHtcbiAgbGV0IHIgPSB6aVt0XTtcbiAgaWYgKHIgPT09IHZvaWQgMCkge1xuICAgIGNvbnN0IG4gPSBPcihVaW50OEFycmF5LmZyb20odCwgKGkpID0+IGkuY2hhckNvZGVBdCgwKSkpO1xuICAgIHIgPSBoZShuLCBuKSwgemlbdF0gPSByO1xuICB9XG4gIHJldHVybiBPcihoZShyLCAuLi5lKSk7XG59XG5jb25zdCBHbiA9ICh0KSA9PiB0LnRvUmF3Qnl0ZXMoITApLnNsaWNlKDEpLCBSbiA9ICh0KSA9PiBldCh0LCAzMiksIHNuID0gKHQpID0+IEoodCwgTnIpLCByciA9ICh0KSA9PiBKKHQsIENyKSwgWm4gPSB1ZS5Qcm9qZWN0aXZlUG9pbnQsIGh1ID0gKHQsIGUsIHIpID0+IFpuLkJBU0UubXVsdGlwbHlBbmRBZGRVbnNhZmUodCwgZSwgcik7XG5mdW5jdGlvbiBUbih0KSB7XG4gIGxldCBlID0gdWUudXRpbHMubm9ybVByaXZhdGVLZXlUb1NjYWxhcih0KSwgciA9IFpuLmZyb21Qcml2YXRlS2V5KGUpO1xuICByZXR1cm4geyBzY2FsYXI6IHIuaGFzRXZlblkoKSA/IGUgOiBycigtZSksIGJ5dGVzOiBHbihyKSB9O1xufVxuZnVuY3Rpb24gaHModCkge1xuICBpZiAoIWZzKHQpKVxuICAgIHRocm93IG5ldyBFcnJvcihcImJhZCB4OiBuZWVkIDAgPCB4IDwgcFwiKTtcbiAgY29uc3QgZSA9IHNuKHQgKiB0KSwgciA9IHNuKGUgKiB0ICsgQmlnSW50KDcpKTtcbiAgbGV0IG4gPSBscyhyKTtcbiAgbiAlIElyICE9PSBVciAmJiAobiA9IHNuKC1uKSk7XG4gIGNvbnN0IGkgPSBuZXcgWm4odCwgbiwgdXMpO1xuICByZXR1cm4gaS5hc3NlcnRWYWxpZGl0eSgpLCBpO1xufVxuZnVuY3Rpb24gZHMoLi4udCkge1xuICByZXR1cm4gcnIobGUoUnIoXCJCSVAwMzQwL2NoYWxsZW5nZVwiLCAuLi50KSkpO1xufVxuZnVuY3Rpb24gZHUodCkge1xuICByZXR1cm4gVG4odCkuYnl0ZXM7XG59XG5mdW5jdGlvbiBwdSh0LCBlLCByID0gUW8oMzIpKSB7XG4gIGNvbnN0IG4gPSBlZShcIm1lc3NhZ2VcIiwgdCksIHsgYnl0ZXM6IGksIHNjYWxhcjogcyB9ID0gVG4oZSksIG8gPSBlZShcImF1eFJhbmRcIiwgciwgMzIpLCBhID0gUm4ocyBeIGxlKFJyKFwiQklQMDM0MC9hdXhcIiwgbykpKSwgYyA9IFJyKFwiQklQMDM0MC9ub25jZVwiLCBhLCBpLCBuKSwgbCA9IHJyKGxlKGMpKTtcbiAgaWYgKGwgPT09IFVyKVxuICAgIHRocm93IG5ldyBFcnJvcihcInNpZ24gZmFpbGVkOiBrIGlzIHplcm9cIik7XG4gIGNvbnN0IHsgYnl0ZXM6IGYsIHNjYWxhcjogdSB9ID0gVG4obCksIGggPSBkcyhmLCBpLCBuKSwgZCA9IG5ldyBVaW50OEFycmF5KDY0KTtcbiAgaWYgKGQuc2V0KGYsIDApLCBkLnNldChSbihycih1ICsgaCAqIHMpKSwgMzIpLCAhcHMoZCwgbiwgaSkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwic2lnbjogSW52YWxpZCBzaWduYXR1cmUgcHJvZHVjZWRcIik7XG4gIHJldHVybiBkO1xufVxuZnVuY3Rpb24gcHModCwgZSwgcikge1xuICBjb25zdCBuID0gZWUoXCJzaWduYXR1cmVcIiwgdCwgNjQpLCBpID0gZWUoXCJtZXNzYWdlXCIsIGUpLCBzID0gZWUoXCJwdWJsaWNLZXlcIiwgciwgMzIpO1xuICB0cnkge1xuICAgIGNvbnN0IG8gPSBocyhsZShzKSksIGEgPSBsZShuLnN1YmFycmF5KDAsIDMyKSk7XG4gICAgaWYgKCFmcyhhKSlcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCBjID0gbGUobi5zdWJhcnJheSgzMiwgNjQpKTtcbiAgICBpZiAoIWZ1KGMpKVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IGwgPSBkcyhSbihhKSwgR24obyksIGkpLCBmID0gaHUobywgYywgcnIoLWwpKTtcbiAgICByZXR1cm4gISghZiB8fCAhZi5oYXNFdmVuWSgpIHx8IGYudG9BZmZpbmUoKS54ICE9PSBhKTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuICExO1xuICB9XG59XG5jb25zdCBTdCA9IHtcbiAgZ2V0UHVibGljS2V5OiBkdSxcbiAgc2lnbjogcHUsXG4gIHZlcmlmeTogcHMsXG4gIHV0aWxzOiB7XG4gICAgcmFuZG9tUHJpdmF0ZUtleTogdWUudXRpbHMucmFuZG9tUHJpdmF0ZUtleSxcbiAgICBsaWZ0X3g6IGhzLFxuICAgIHBvaW50VG9CeXRlczogR24sXG4gICAgbnVtYmVyVG9CeXRlc0JFOiBldCxcbiAgICBieXRlc1RvTnVtYmVyQkU6IGxlLFxuICAgIHRhZ2dlZEhhc2g6IFJyLFxuICAgIG1vZDogSlxuICB9XG59LCB5dSA9IGF1KHR0LCBbXG4gIFtcbiAgICBcIjB4OGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGRhYWFhYThjN1wiLFxuICAgIFwiMHg3ZDNkNGM4MGJjMzIxZDViOWYzMTVjZWE3ZmQ0NGM1ZDU5NWQyZmMwYmY2M2I5MmRmZmYxMDQ0ZjE3YzY1ODFcIixcbiAgICBcIjB4NTM0YzMyOGQyM2YyMzRlNmUyYTQxM2RlY2EyNWNhZWNlNDUwNjE0NDAzN2M0MDMxNGVjYmQwYjUzZDlkZDI2MlwiLFxuICAgIFwiMHg4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZGFhYWFhODhjXCJcbiAgXSxcbiAgW1xuICAgIFwiMHhkMzU3NzExOTNkOTQ5MThhOWNhMzRjY2JiN2I2NDBkZDg2Y2Q0MDk1NDJmODQ4N2Q5ZmU2Yjc0NTc4MWViNDliXCIsXG4gICAgXCIweGVkYWRjNmY2NDM4M2RjMWRmN2M0YjJkNTFiNTQyMjU0MDZkMzZiNjQxZjVlNDFiYmM1MmE1NjYxMmE4YzZkMTRcIixcbiAgICBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMVwiXG4gIF0sXG4gIFtcbiAgICBcIjB4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGI4ZTM4ZTIzY1wiLFxuICAgIFwiMHhjNzVlMGMzMmQ1Y2I3YzBmYTlkMGE1NGIxMmEwYTZkNTY0N2FiMDQ2ZDY4NmRhNmZkZmZjOTBmYzIwMWQ3MWEzXCIsXG4gICAgXCIweDI5YTYxOTQ2OTFmOTFhNzM3MTUyMDllZjY1MTJlNTc2NzIyODMwYTIwMWJlMjAxOGE3NjVlODVhOWVjZWU5MzFcIixcbiAgICBcIjB4MmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmYzOGUzOGQ4NFwiXG4gIF0sXG4gIFtcbiAgICBcIjB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmVmZmZmZjkzYlwiLFxuICAgIFwiMHg3YTA2NTM0YmI4YmRiNDlmZDVlOWU2NjMyNzIyYzI5ODk0NjdjMWJmYzhlOGQ5NzhkZmI0MjVkMjY4NWMyNTczXCIsXG4gICAgXCIweDY0ODRhYTcxNjU0NWNhMmNmM2E3MGMzZmE4ZmUzMzdlMGEzZDIxMTYyZjBkNjI5OWE3YmY4MTkyYmZkMmE3NmZcIixcbiAgICBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMVwiXG4gIF1cbl0ubWFwKCh0KSA9PiB0Lm1hcCgoZSkgPT4gQmlnSW50KGUpKSkpLCBndSA9IHR1KHR0LCB7XG4gIEE6IEJpZ0ludChcIjB4M2Y4NzMxYWJkZDY2MWFkY2EwOGE1NTU4ZjBmNWQyNzJlOTUzZDM2M2NiNmYwZTVkNDA1NDQ3YzAxYTQ0NDUzM1wiKSxcbiAgQjogQmlnSW50KFwiMTc3MVwiKSxcbiAgWjogdHQuY3JlYXRlKEJpZ0ludChcIi0xMVwiKSlcbn0pO1xuY3UodWUuUHJvamVjdGl2ZVBvaW50LCAodCkgPT4ge1xuICBjb25zdCB7IHg6IGUsIHk6IHIgfSA9IGd1KHR0LmNyZWF0ZSh0WzBdKSk7XG4gIHJldHVybiB5dShlLCByKTtcbn0sIHtcbiAgRFNUOiBcInNlY3AyNTZrMV9YTUQ6U0hBLTI1Nl9TU1dVX1JPX1wiLFxuICBlbmNvZGVEU1Q6IFwic2VjcDI1NmsxX1hNRDpTSEEtMjU2X1NTV1VfTlVfXCIsXG4gIHA6IHR0Lk9SREVSLFxuICBtOiAxLFxuICBrOiAxMjgsXG4gIGV4cGFuZDogXCJ4bWRcIixcbiAgaGFzaDogT3Jcbn0pO1xuY29uc3QgYW4gPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PSBcIm9iamVjdFwiICYmIFwiY3J5cHRvXCIgaW4gZ2xvYmFsVGhpcyA/IGdsb2JhbFRoaXMuY3J5cHRvIDogdm9pZCAwO1xuLyohIG5vYmxlLWhhc2hlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuY29uc3QgY24gPSAodCkgPT4gbmV3IERhdGFWaWV3KHQuYnVmZmVyLCB0LmJ5dGVPZmZzZXQsIHQuYnl0ZUxlbmd0aCksIENlID0gKHQsIGUpID0+IHQgPDwgMzIgLSBlIHwgdCA+Pj4gZSwgYnUgPSBuZXcgVWludDhBcnJheShuZXcgVWludDMyQXJyYXkoWzI4NzQ1NDAyMF0pLmJ1ZmZlcilbMF0gPT09IDY4O1xuaWYgKCFidSlcbiAgdGhyb3cgbmV3IEVycm9yKFwiTm9uIGxpdHRsZS1lbmRpYW4gaGFyZHdhcmUgaXMgbm90IHN1cHBvcnRlZFwiKTtcbmNvbnN0IHZ1ID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sICh0LCBlKSA9PiBlLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIikpO1xuZnVuY3Rpb24gdmUodCkge1xuICBpZiAoISh0IGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVWludDhBcnJheSBleHBlY3RlZFwiKTtcbiAgbGV0IGUgPSBcIlwiO1xuICBmb3IgKGxldCByID0gMDsgciA8IHQubGVuZ3RoOyByKyspXG4gICAgZSArPSB2dVt0W3JdXTtcbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBfdCh0KSB7XG4gIGlmICh0eXBlb2YgdCAhPSBcInN0cmluZ1wiKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJoZXhUb0J5dGVzOiBleHBlY3RlZCBzdHJpbmcsIGdvdCBcIiArIHR5cGVvZiB0KTtcbiAgaWYgKHQubGVuZ3RoICUgMilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJoZXhUb0J5dGVzOiByZWNlaXZlZCBpbnZhbGlkIHVucGFkZGVkIGhleFwiKTtcbiAgY29uc3QgZSA9IG5ldyBVaW50OEFycmF5KHQubGVuZ3RoIC8gMik7XG4gIGZvciAobGV0IHIgPSAwOyByIDwgZS5sZW5ndGg7IHIrKykge1xuICAgIGNvbnN0IG4gPSByICogMiwgaSA9IHQuc2xpY2UobiwgbiArIDIpLCBzID0gTnVtYmVyLnBhcnNlSW50KGksIDE2KTtcbiAgICBpZiAoTnVtYmVyLmlzTmFOKHMpIHx8IHMgPCAwKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBieXRlIHNlcXVlbmNlXCIpO1xuICAgIGVbcl0gPSBzO1xuICB9XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gd3UodCkge1xuICBpZiAodHlwZW9mIHQgIT0gXCJzdHJpbmdcIilcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB1dGY4VG9CeXRlcyBleHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiB0fWApO1xuICByZXR1cm4gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHQpO1xufVxuZnVuY3Rpb24geXModCkge1xuICBpZiAodHlwZW9mIHQgPT0gXCJzdHJpbmdcIiAmJiAodCA9IHd1KHQpKSwgISh0IGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgaW5wdXQgdHlwZSBpcyBVaW50OEFycmF5IChnb3QgJHt0eXBlb2YgdH0pYCk7XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gX3UoLi4udCkge1xuICBpZiAoIXQuZXZlcnkoKG4pID0+IG4gaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVaW50OEFycmF5IGxpc3QgZXhwZWN0ZWRcIik7XG4gIGlmICh0Lmxlbmd0aCA9PT0gMSlcbiAgICByZXR1cm4gdFswXTtcbiAgY29uc3QgZSA9IHQucmVkdWNlKChuLCBpKSA9PiBuICsgaS5sZW5ndGgsIDApLCByID0gbmV3IFVpbnQ4QXJyYXkoZSk7XG4gIGZvciAobGV0IG4gPSAwLCBpID0gMDsgbiA8IHQubGVuZ3RoOyBuKyspIHtcbiAgICBjb25zdCBzID0gdFtuXTtcbiAgICByLnNldChzLCBpKSwgaSArPSBzLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gcjtcbn1cbmNsYXNzIG11IHtcbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nsb25lSW50bygpO1xuICB9XG59XG5mdW5jdGlvbiBncyh0KSB7XG4gIGNvbnN0IGUgPSAobikgPT4gdCgpLnVwZGF0ZSh5cyhuKSkuZGlnZXN0KCksIHIgPSB0KCk7XG4gIHJldHVybiBlLm91dHB1dExlbiA9IHIub3V0cHV0TGVuLCBlLmJsb2NrTGVuID0gci5ibG9ja0xlbiwgZS5jcmVhdGUgPSAoKSA9PiB0KCksIGU7XG59XG5mdW5jdGlvbiB4dSh0ID0gMzIpIHtcbiAgaWYgKGFuICYmIHR5cGVvZiBhbi5nZXRSYW5kb21WYWx1ZXMgPT0gXCJmdW5jdGlvblwiKVxuICAgIHJldHVybiBhbi5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkodCkpO1xuICB0aHJvdyBuZXcgRXJyb3IoXCJjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIG11c3QgYmUgZGVmaW5lZFwiKTtcbn1cbmZ1bmN0aW9uIFBuKHQpIHtcbiAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcih0KSB8fCB0IDwgMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFdyb25nIHBvc2l0aXZlIGludGVnZXI6ICR7dH1gKTtcbn1cbmZ1bmN0aW9uIEV1KHQpIHtcbiAgaWYgKHR5cGVvZiB0ICE9IFwiYm9vbGVhblwiKVxuICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYm9vbGVhbiwgbm90ICR7dH1gKTtcbn1cbmZ1bmN0aW9uIGJzKHQsIC4uLmUpIHtcbiAgaWYgKCEodCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBVaW50OEFycmF5XCIpO1xuICBpZiAoZS5sZW5ndGggPiAwICYmICFlLmluY2x1ZGVzKHQubGVuZ3RoKSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBVaW50OEFycmF5IG9mIGxlbmd0aCAke2V9LCBub3Qgb2YgbGVuZ3RoPSR7dC5sZW5ndGh9YCk7XG59XG5mdW5jdGlvbiBrdSh0KSB7XG4gIGlmICh0eXBlb2YgdCAhPSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIHQuY3JlYXRlICE9IFwiZnVuY3Rpb25cIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJIYXNoIHNob3VsZCBiZSB3cmFwcGVkIGJ5IHV0aWxzLndyYXBDb25zdHJ1Y3RvclwiKTtcbiAgUG4odC5vdXRwdXRMZW4pLCBQbih0LmJsb2NrTGVuKTtcbn1cbmZ1bmN0aW9uIFN1KHQsIGUgPSAhMCkge1xuICBpZiAodC5kZXN0cm95ZWQpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSGFzaCBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWRcIik7XG4gIGlmIChlICYmIHQuZmluaXNoZWQpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSGFzaCNkaWdlc3QoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZFwiKTtcbn1cbmZ1bmN0aW9uIE91KHQsIGUpIHtcbiAgYnModCk7XG4gIGNvbnN0IHIgPSBlLm91dHB1dExlbjtcbiAgaWYgKHQubGVuZ3RoIDwgcilcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGRpZ2VzdEludG8oKSBleHBlY3RzIG91dHB1dCBidWZmZXIgb2YgbGVuZ3RoIGF0IGxlYXN0ICR7cn1gKTtcbn1cbmNvbnN0IHVuID0ge1xuICBudW1iZXI6IFBuLFxuICBib29sOiBFdSxcbiAgYnl0ZXM6IGJzLFxuICBoYXNoOiBrdSxcbiAgZXhpc3RzOiBTdSxcbiAgb3V0cHV0OiBPdVxufTtcbmZ1bmN0aW9uIEF1KHQsIGUsIHIsIG4pIHtcbiAgaWYgKHR5cGVvZiB0LnNldEJpZ1VpbnQ2NCA9PSBcImZ1bmN0aW9uXCIpXG4gICAgcmV0dXJuIHQuc2V0QmlnVWludDY0KGUsIHIsIG4pO1xuICBjb25zdCBpID0gQmlnSW50KDMyKSwgcyA9IEJpZ0ludCg0Mjk0OTY3Mjk1KSwgbyA9IE51bWJlcihyID4+IGkgJiBzKSwgYSA9IE51bWJlcihyICYgcyksIGMgPSBuID8gNCA6IDAsIGwgPSBuID8gMCA6IDQ7XG4gIHQuc2V0VWludDMyKGUgKyBjLCBvLCBuKSwgdC5zZXRVaW50MzIoZSArIGwsIGEsIG4pO1xufVxuY2xhc3MgQ3UgZXh0ZW5kcyBtdSB7XG4gIGNvbnN0cnVjdG9yKGUsIHIsIG4sIGkpIHtcbiAgICBzdXBlcigpLCB0aGlzLmJsb2NrTGVuID0gZSwgdGhpcy5vdXRwdXRMZW4gPSByLCB0aGlzLnBhZE9mZnNldCA9IG4sIHRoaXMuaXNMRSA9IGksIHRoaXMuZmluaXNoZWQgPSAhMSwgdGhpcy5sZW5ndGggPSAwLCB0aGlzLnBvcyA9IDAsIHRoaXMuZGVzdHJveWVkID0gITEsIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoZSksIHRoaXMudmlldyA9IGNuKHRoaXMuYnVmZmVyKTtcbiAgfVxuICB1cGRhdGUoZSkge1xuICAgIHVuLmV4aXN0cyh0aGlzKTtcbiAgICBjb25zdCB7IHZpZXc6IHIsIGJ1ZmZlcjogbiwgYmxvY2tMZW46IGkgfSA9IHRoaXM7XG4gICAgZSA9IHlzKGUpO1xuICAgIGNvbnN0IHMgPSBlLmxlbmd0aDtcbiAgICBmb3IgKGxldCBvID0gMDsgbyA8IHM7ICkge1xuICAgICAgY29uc3QgYSA9IE1hdGgubWluKGkgLSB0aGlzLnBvcywgcyAtIG8pO1xuICAgICAgaWYgKGEgPT09IGkpIHtcbiAgICAgICAgY29uc3QgYyA9IGNuKGUpO1xuICAgICAgICBmb3IgKDsgaSA8PSBzIC0gbzsgbyArPSBpKVxuICAgICAgICAgIHRoaXMucHJvY2VzcyhjLCBvKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBuLnNldChlLnN1YmFycmF5KG8sIG8gKyBhKSwgdGhpcy5wb3MpLCB0aGlzLnBvcyArPSBhLCBvICs9IGEsIHRoaXMucG9zID09PSBpICYmICh0aGlzLnByb2Nlc3MociwgMCksIHRoaXMucG9zID0gMCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxlbmd0aCArPSBlLmxlbmd0aCwgdGhpcy5yb3VuZENsZWFuKCksIHRoaXM7XG4gIH1cbiAgZGlnZXN0SW50byhlKSB7XG4gICAgdW4uZXhpc3RzKHRoaXMpLCB1bi5vdXRwdXQoZSwgdGhpcyksIHRoaXMuZmluaXNoZWQgPSAhMDtcbiAgICBjb25zdCB7IGJ1ZmZlcjogciwgdmlldzogbiwgYmxvY2tMZW46IGksIGlzTEU6IHMgfSA9IHRoaXM7XG4gICAgbGV0IHsgcG9zOiBvIH0gPSB0aGlzO1xuICAgIHJbbysrXSA9IDEyOCwgdGhpcy5idWZmZXIuc3ViYXJyYXkobykuZmlsbCgwKSwgdGhpcy5wYWRPZmZzZXQgPiBpIC0gbyAmJiAodGhpcy5wcm9jZXNzKG4sIDApLCBvID0gMCk7XG4gICAgZm9yIChsZXQgdSA9IG87IHUgPCBpOyB1KyspXG4gICAgICByW3VdID0gMDtcbiAgICBBdShuLCBpIC0gOCwgQmlnSW50KHRoaXMubGVuZ3RoICogOCksIHMpLCB0aGlzLnByb2Nlc3MobiwgMCk7XG4gICAgY29uc3QgYSA9IGNuKGUpLCBjID0gdGhpcy5vdXRwdXRMZW47XG4gICAgaWYgKGMgJSA0KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiX3NoYTI6IG91dHB1dExlbiBzaG91bGQgYmUgYWxpZ25lZCB0byAzMmJpdFwiKTtcbiAgICBjb25zdCBsID0gYyAvIDQsIGYgPSB0aGlzLmdldCgpO1xuICAgIGlmIChsID4gZi5sZW5ndGgpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJfc2hhMjogb3V0cHV0TGVuIGJpZ2dlciB0aGFuIHN0YXRlXCIpO1xuICAgIGZvciAobGV0IHUgPSAwOyB1IDwgbDsgdSsrKVxuICAgICAgYS5zZXRVaW50MzIoNCAqIHUsIGZbdV0sIHMpO1xuICB9XG4gIGRpZ2VzdCgpIHtcbiAgICBjb25zdCB7IGJ1ZmZlcjogZSwgb3V0cHV0TGVuOiByIH0gPSB0aGlzO1xuICAgIHRoaXMuZGlnZXN0SW50byhlKTtcbiAgICBjb25zdCBuID0gZS5zbGljZSgwLCByKTtcbiAgICByZXR1cm4gdGhpcy5kZXN0cm95KCksIG47XG4gIH1cbiAgX2Nsb25lSW50byhlKSB7XG4gICAgZSB8fCAoZSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkpLCBlLnNldCguLi50aGlzLmdldCgpKTtcbiAgICBjb25zdCB7IGJsb2NrTGVuOiByLCBidWZmZXI6IG4sIGxlbmd0aDogaSwgZmluaXNoZWQ6IHMsIGRlc3Ryb3llZDogbywgcG9zOiBhIH0gPSB0aGlzO1xuICAgIHJldHVybiBlLmxlbmd0aCA9IGksIGUucG9zID0gYSwgZS5maW5pc2hlZCA9IHMsIGUuZGVzdHJveWVkID0gbywgaSAlIHIgJiYgZS5idWZmZXIuc2V0KG4pLCBlO1xuICB9XG59XG5jb25zdCBJdSA9ICh0LCBlLCByKSA9PiB0ICYgZSBeIH50ICYgciwgUnUgPSAodCwgZSwgcikgPT4gdCAmIGUgXiB0ICYgciBeIGUgJiByLCBUdSA9IG5ldyBVaW50MzJBcnJheShbXG4gIDExMTYzNTI0MDgsXG4gIDE4OTk0NDc0NDEsXG4gIDMwNDkzMjM0NzEsXG4gIDM5MjEwMDk1NzMsXG4gIDk2MTk4NzE2MyxcbiAgMTUwODk3MDk5MyxcbiAgMjQ1MzYzNTc0OCxcbiAgMjg3MDc2MzIyMSxcbiAgMzYyNDM4MTA4MCxcbiAgMzEwNTk4NDAxLFxuICA2MDcyMjUyNzgsXG4gIDE0MjY4ODE5ODcsXG4gIDE5MjUwNzgzODgsXG4gIDIxNjIwNzgyMDYsXG4gIDI2MTQ4ODgxMDMsXG4gIDMyNDgyMjI1ODAsXG4gIDM4MzUzOTA0MDEsXG4gIDQwMjIyMjQ3NzQsXG4gIDI2NDM0NzA3OCxcbiAgNjA0ODA3NjI4LFxuICA3NzAyNTU5ODMsXG4gIDEyNDkxNTAxMjIsXG4gIDE1NTUwODE2OTIsXG4gIDE5OTYwNjQ5ODYsXG4gIDI1NTQyMjA4ODIsXG4gIDI4MjE4MzQzNDksXG4gIDI5NTI5OTY4MDgsXG4gIDMyMTAzMTM2NzEsXG4gIDMzMzY1NzE4OTEsXG4gIDM1ODQ1Mjg3MTEsXG4gIDExMzkyNjk5MyxcbiAgMzM4MjQxODk1LFxuICA2NjYzMDcyMDUsXG4gIDc3MzUyOTkxMixcbiAgMTI5NDc1NzM3MixcbiAgMTM5NjE4MjI5MSxcbiAgMTY5NTE4MzcwMCxcbiAgMTk4NjY2MTA1MSxcbiAgMjE3NzAyNjM1MCxcbiAgMjQ1Njk1NjAzNyxcbiAgMjczMDQ4NTkyMSxcbiAgMjgyMDMwMjQxMSxcbiAgMzI1OTczMDgwMCxcbiAgMzM0NTc2NDc3MSxcbiAgMzUxNjA2NTgxNyxcbiAgMzYwMDM1MjgwNCxcbiAgNDA5NDU3MTkwOSxcbiAgMjc1NDIzMzQ0LFxuICA0MzAyMjc3MzQsXG4gIDUwNjk0ODYxNixcbiAgNjU5MDYwNTU2LFxuICA4ODM5OTc4NzcsXG4gIDk1ODEzOTU3MSxcbiAgMTMyMjgyMjIxOCxcbiAgMTUzNzAwMjA2MyxcbiAgMTc0Nzg3Mzc3OSxcbiAgMTk1NTU2MjIyMixcbiAgMjAyNDEwNDgxNSxcbiAgMjIyNzczMDQ1MixcbiAgMjM2MTg1MjQyNCxcbiAgMjQyODQzNjQ3NCxcbiAgMjc1NjczNDE4NyxcbiAgMzIwNDAzMTQ3OSxcbiAgMzMyOTMyNTI5OFxuXSksIHplID0gbmV3IFVpbnQzMkFycmF5KFtcbiAgMTc3OTAzMzcwMyxcbiAgMzE0NDEzNDI3NyxcbiAgMTAxMzkwNDI0MixcbiAgMjc3MzQ4MDc2MixcbiAgMTM1OTg5MzExOSxcbiAgMjYwMDgyMjkyNCxcbiAgNTI4NzM0NjM1LFxuICAxNTQxNDU5MjI1XG5dKSwgRmUgPSBuZXcgVWludDMyQXJyYXkoNjQpO1xuY2xhc3MgdnMgZXh0ZW5kcyBDdSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKDY0LCAzMiwgOCwgITEpLCB0aGlzLkEgPSB6ZVswXSB8IDAsIHRoaXMuQiA9IHplWzFdIHwgMCwgdGhpcy5DID0gemVbMl0gfCAwLCB0aGlzLkQgPSB6ZVszXSB8IDAsIHRoaXMuRSA9IHplWzRdIHwgMCwgdGhpcy5GID0gemVbNV0gfCAwLCB0aGlzLkcgPSB6ZVs2XSB8IDAsIHRoaXMuSCA9IHplWzddIHwgMDtcbiAgfVxuICBnZXQoKSB7XG4gICAgY29uc3QgeyBBOiBlLCBCOiByLCBDOiBuLCBEOiBpLCBFOiBzLCBGOiBvLCBHOiBhLCBIOiBjIH0gPSB0aGlzO1xuICAgIHJldHVybiBbZSwgciwgbiwgaSwgcywgbywgYSwgY107XG4gIH1cbiAgc2V0KGUsIHIsIG4sIGksIHMsIG8sIGEsIGMpIHtcbiAgICB0aGlzLkEgPSBlIHwgMCwgdGhpcy5CID0gciB8IDAsIHRoaXMuQyA9IG4gfCAwLCB0aGlzLkQgPSBpIHwgMCwgdGhpcy5FID0gcyB8IDAsIHRoaXMuRiA9IG8gfCAwLCB0aGlzLkcgPSBhIHwgMCwgdGhpcy5IID0gYyB8IDA7XG4gIH1cbiAgcHJvY2VzcyhlLCByKSB7XG4gICAgZm9yIChsZXQgdSA9IDA7IHUgPCAxNjsgdSsrLCByICs9IDQpXG4gICAgICBGZVt1XSA9IGUuZ2V0VWludDMyKHIsICExKTtcbiAgICBmb3IgKGxldCB1ID0gMTY7IHUgPCA2NDsgdSsrKSB7XG4gICAgICBjb25zdCBoID0gRmVbdSAtIDE1XSwgZCA9IEZlW3UgLSAyXSwgcCA9IENlKGgsIDcpIF4gQ2UoaCwgMTgpIF4gaCA+Pj4gMywgeSA9IENlKGQsIDE3KSBeIENlKGQsIDE5KSBeIGQgPj4+IDEwO1xuICAgICAgRmVbdV0gPSB5ICsgRmVbdSAtIDddICsgcCArIEZlW3UgLSAxNl0gfCAwO1xuICAgIH1cbiAgICBsZXQgeyBBOiBuLCBCOiBpLCBDOiBzLCBEOiBvLCBFOiBhLCBGOiBjLCBHOiBsLCBIOiBmIH0gPSB0aGlzO1xuICAgIGZvciAobGV0IHUgPSAwOyB1IDwgNjQ7IHUrKykge1xuICAgICAgY29uc3QgaCA9IENlKGEsIDYpIF4gQ2UoYSwgMTEpIF4gQ2UoYSwgMjUpLCBkID0gZiArIGggKyBJdShhLCBjLCBsKSArIFR1W3VdICsgRmVbdV0gfCAwLCB5ID0gKENlKG4sIDIpIF4gQ2UobiwgMTMpIF4gQ2UobiwgMjIpKSArIFJ1KG4sIGksIHMpIHwgMDtcbiAgICAgIGYgPSBsLCBsID0gYywgYyA9IGEsIGEgPSBvICsgZCB8IDAsIG8gPSBzLCBzID0gaSwgaSA9IG4sIG4gPSBkICsgeSB8IDA7XG4gICAgfVxuICAgIG4gPSBuICsgdGhpcy5BIHwgMCwgaSA9IGkgKyB0aGlzLkIgfCAwLCBzID0gcyArIHRoaXMuQyB8IDAsIG8gPSBvICsgdGhpcy5EIHwgMCwgYSA9IGEgKyB0aGlzLkUgfCAwLCBjID0gYyArIHRoaXMuRiB8IDAsIGwgPSBsICsgdGhpcy5HIHwgMCwgZiA9IGYgKyB0aGlzLkggfCAwLCB0aGlzLnNldChuLCBpLCBzLCBvLCBhLCBjLCBsLCBmKTtcbiAgfVxuICByb3VuZENsZWFuKCkge1xuICAgIEZlLmZpbGwoMCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKSwgdGhpcy5idWZmZXIuZmlsbCgwKTtcbiAgfVxufVxuY2xhc3MgUHUgZXh0ZW5kcyB2cyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCksIHRoaXMuQSA9IC0xMDU2NTk2MjY0LCB0aGlzLkIgPSA5MTQxNTA2NjMsIHRoaXMuQyA9IDgxMjcwMjk5OSwgdGhpcy5EID0gLTE1MDA1NDU5OSwgdGhpcy5FID0gLTQxOTE0MzksIHRoaXMuRiA9IDE3NTA2MDMwMjUsIHRoaXMuRyA9IDE2OTQwNzY4MzksIHRoaXMuSCA9IC0xMDkwODkxODY4LCB0aGlzLm91dHB1dExlbiA9IDI4O1xuICB9XG59XG5jb25zdCBZbiA9IGdzKCgpID0+IG5ldyB2cygpKTtcbmdzKCgpID0+IG5ldyBQdSgpKTtcbi8qISBzY3VyZS1iYXNlIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5mdW5jdGlvbiBydCh0KSB7XG4gIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIodCkpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBXcm9uZyBpbnRlZ2VyOiAke3R9YCk7XG59XG5mdW5jdGlvbiBTZSguLi50KSB7XG4gIGNvbnN0IGUgPSAoaSwgcykgPT4gKG8pID0+IGkocyhvKSksIHIgPSBBcnJheS5mcm9tKHQpLnJldmVyc2UoKS5yZWR1Y2UoKGksIHMpID0+IGkgPyBlKGksIHMuZW5jb2RlKSA6IHMuZW5jb2RlLCB2b2lkIDApLCBuID0gdC5yZWR1Y2UoKGksIHMpID0+IGkgPyBlKGksIHMuZGVjb2RlKSA6IHMuZGVjb2RlLCB2b2lkIDApO1xuICByZXR1cm4geyBlbmNvZGU6IHIsIGRlY29kZTogbiB9O1xufVxuZnVuY3Rpb24gUmUodCkge1xuICByZXR1cm4ge1xuICAgIGVuY29kZTogKGUpID0+IHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShlKSB8fCBlLmxlbmd0aCAmJiB0eXBlb2YgZVswXSAhPSBcIm51bWJlclwiKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhbHBoYWJldC5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIGFuIGFycmF5IG9mIG51bWJlcnNcIik7XG4gICAgICByZXR1cm4gZS5tYXAoKHIpID0+IHtcbiAgICAgICAgaWYgKHJ0KHIpLCByIDwgMCB8fCByID49IHQubGVuZ3RoKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRGlnaXQgaW5kZXggb3V0c2lkZSBhbHBoYWJldDogJHtyfSAoYWxwaGFiZXQ6ICR7dC5sZW5ndGh9KWApO1xuICAgICAgICByZXR1cm4gdFtyXTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZGVjb2RlOiAoZSkgPT4ge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGUpIHx8IGUubGVuZ3RoICYmIHR5cGVvZiBlWzBdICE9IFwic3RyaW5nXCIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImFscGhhYmV0LmRlY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2Ygc3RyaW5nc1wiKTtcbiAgICAgIHJldHVybiBlLm1hcCgocikgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHIgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGFscGhhYmV0LmRlY29kZTogbm90IHN0cmluZyBlbGVtZW50PSR7cn1gKTtcbiAgICAgICAgY29uc3QgbiA9IHQuaW5kZXhPZihyKTtcbiAgICAgICAgaWYgKG4gPT09IC0xKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBsZXR0ZXI6IFwiJHtyfVwiLiBBbGxvd2VkOiAke3R9YCk7XG4gICAgICAgIHJldHVybiBuO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gVGUodCA9IFwiXCIpIHtcbiAgaWYgKHR5cGVvZiB0ICE9IFwic3RyaW5nXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiam9pbiBzZXBhcmF0b3Igc2hvdWxkIGJlIHN0cmluZ1wiKTtcbiAgcmV0dXJuIHtcbiAgICBlbmNvZGU6IChlKSA9PiB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZSkgfHwgZS5sZW5ndGggJiYgdHlwZW9mIGVbMF0gIT0gXCJzdHJpbmdcIilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiam9pbi5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIGFycmF5IG9mIHN0cmluZ3NcIik7XG4gICAgICBmb3IgKGxldCByIG9mIGUpXG4gICAgICAgIGlmICh0eXBlb2YgciAhPSBcInN0cmluZ1wiKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgam9pbi5lbmNvZGU6IG5vbi1zdHJpbmcgaW5wdXQ9JHtyfWApO1xuICAgICAgcmV0dXJuIGUuam9pbih0KTtcbiAgICB9LFxuICAgIGRlY29kZTogKGUpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgZSAhPSBcInN0cmluZ1wiKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJqb2luLmRlY29kZSBpbnB1dCBzaG91bGQgYmUgc3RyaW5nXCIpO1xuICAgICAgcmV0dXJuIGUuc3BsaXQodCk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gc3IodCwgZSA9IFwiPVwiKSB7XG4gIGlmIChydCh0KSwgdHlwZW9mIGUgIT0gXCJzdHJpbmdcIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJwYWRkaW5nIGNociBzaG91bGQgYmUgc3RyaW5nXCIpO1xuICByZXR1cm4ge1xuICAgIGVuY29kZShyKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocikgfHwgci5sZW5ndGggJiYgdHlwZW9mIHJbMF0gIT0gXCJzdHJpbmdcIilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicGFkZGluZy5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIGFycmF5IG9mIHN0cmluZ3NcIik7XG4gICAgICBmb3IgKGxldCBuIG9mIHIpXG4gICAgICAgIGlmICh0eXBlb2YgbiAhPSBcInN0cmluZ1wiKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcGFkZGluZy5lbmNvZGU6IG5vbi1zdHJpbmcgaW5wdXQ9JHtufWApO1xuICAgICAgZm9yICg7IHIubGVuZ3RoICogdCAlIDg7IClcbiAgICAgICAgci5wdXNoKGUpO1xuICAgICAgcmV0dXJuIHI7XG4gICAgfSxcbiAgICBkZWNvZGUocikge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHIpIHx8IHIubGVuZ3RoICYmIHR5cGVvZiByWzBdICE9IFwic3RyaW5nXCIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInBhZGRpbmcuZW5jb2RlIGlucHV0IHNob3VsZCBiZSBhcnJheSBvZiBzdHJpbmdzXCIpO1xuICAgICAgZm9yIChsZXQgaSBvZiByKVxuICAgICAgICBpZiAodHlwZW9mIGkgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHBhZGRpbmcuZGVjb2RlOiBub24tc3RyaW5nIGlucHV0PSR7aX1gKTtcbiAgICAgIGxldCBuID0gci5sZW5ndGg7XG4gICAgICBpZiAobiAqIHQgJSA4KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHBhZGRpbmc6IHN0cmluZyBzaG91bGQgaGF2ZSB3aG9sZSBudW1iZXIgb2YgYnl0ZXNcIik7XG4gICAgICBmb3IgKDsgbiA+IDAgJiYgcltuIC0gMV0gPT09IGU7IG4tLSlcbiAgICAgICAgaWYgKCEoKG4gLSAxKSAqIHQgJSA4KSlcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHBhZGRpbmc6IHN0cmluZyBoYXMgdG9vIG11Y2ggcGFkZGluZ1wiKTtcbiAgICAgIHJldHVybiByLnNsaWNlKDAsIG4pO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHdzKHQpIHtcbiAgaWYgKHR5cGVvZiB0ICE9IFwiZnVuY3Rpb25cIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3JtYWxpemUgZm4gc2hvdWxkIGJlIGZ1bmN0aW9uXCIpO1xuICByZXR1cm4geyBlbmNvZGU6IChlKSA9PiBlLCBkZWNvZGU6IChlKSA9PiB0KGUpIH07XG59XG5mdW5jdGlvbiBGaSh0LCBlLCByKSB7XG4gIGlmIChlIDwgMilcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDogd3JvbmcgZnJvbT0ke2V9LCBiYXNlIGNhbm5vdCBiZSBsZXNzIHRoYW4gMmApO1xuICBpZiAociA8IDIpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXg6IHdyb25nIHRvPSR7cn0sIGJhc2UgY2Fubm90IGJlIGxlc3MgdGhhbiAyYCk7XG4gIGlmICghQXJyYXkuaXNBcnJheSh0KSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb252ZXJ0UmFkaXg6IGRhdGEgc2hvdWxkIGJlIGFycmF5XCIpO1xuICBpZiAoIXQubGVuZ3RoKVxuICAgIHJldHVybiBbXTtcbiAgbGV0IG4gPSAwO1xuICBjb25zdCBpID0gW10sIHMgPSBBcnJheS5mcm9tKHQpO1xuICBmb3IgKHMuZm9yRWFjaCgobykgPT4ge1xuICAgIGlmIChydChvKSwgbyA8IDAgfHwgbyA+PSBlKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBXcm9uZyBpbnRlZ2VyOiAke299YCk7XG4gIH0pOyA7ICkge1xuICAgIGxldCBvID0gMCwgYSA9ICEwO1xuICAgIGZvciAobGV0IGMgPSBuOyBjIDwgcy5sZW5ndGg7IGMrKykge1xuICAgICAgY29uc3QgbCA9IHNbY10sIGYgPSBlICogbyArIGw7XG4gICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGYpIHx8IGUgKiBvIC8gZSAhPT0gbyB8fCBmIC0gbCAhPT0gZSAqIG8pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNvbnZlcnRSYWRpeDogY2Fycnkgb3ZlcmZsb3dcIik7XG4gICAgICBpZiAobyA9IGYgJSByLCBzW2NdID0gTWF0aC5mbG9vcihmIC8gciksICFOdW1iZXIuaXNTYWZlSW50ZWdlcihzW2NdKSB8fCBzW2NdICogciArIG8gIT09IGYpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNvbnZlcnRSYWRpeDogY2Fycnkgb3ZlcmZsb3dcIik7XG4gICAgICBpZiAoYSlcbiAgICAgICAgc1tjXSA/IGEgPSAhMSA6IG4gPSBjO1xuICAgICAgZWxzZVxuICAgICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGkucHVzaChvKSwgYSlcbiAgICAgIGJyZWFrO1xuICB9XG4gIGZvciAobGV0IG8gPSAwOyBvIDwgdC5sZW5ndGggLSAxICYmIHRbb10gPT09IDA7IG8rKylcbiAgICBpLnB1c2goMCk7XG4gIHJldHVybiBpLnJldmVyc2UoKTtcbn1cbmNvbnN0IF9zID0gKHQsIGUpID0+IGUgPyBfcyhlLCB0ICUgZSkgOiB0LCBUciA9ICh0LCBlKSA9PiB0ICsgKGUgLSBfcyh0LCBlKSk7XG5mdW5jdGlvbiBCbih0LCBlLCByLCBuKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheSh0KSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb252ZXJ0UmFkaXgyOiBkYXRhIHNob3VsZCBiZSBhcnJheVwiKTtcbiAgaWYgKGUgPD0gMCB8fCBlID4gMzIpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXgyOiB3cm9uZyBmcm9tPSR7ZX1gKTtcbiAgaWYgKHIgPD0gMCB8fCByID4gMzIpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXgyOiB3cm9uZyB0bz0ke3J9YCk7XG4gIGlmIChUcihlLCByKSA+IDMyKVxuICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4MjogY2Fycnkgb3ZlcmZsb3cgZnJvbT0ke2V9IHRvPSR7cn0gY2FycnlCaXRzPSR7VHIoZSwgcil9YCk7XG4gIGxldCBpID0gMCwgcyA9IDA7XG4gIGNvbnN0IG8gPSAyICoqIHIgLSAxLCBhID0gW107XG4gIGZvciAoY29uc3QgYyBvZiB0KSB7XG4gICAgaWYgKHJ0KGMpLCBjID49IDIgKiogZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4MjogaW52YWxpZCBkYXRhIHdvcmQ9JHtjfSBmcm9tPSR7ZX1gKTtcbiAgICBpZiAoaSA9IGkgPDwgZSB8IGMsIHMgKyBlID4gMzIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDI6IGNhcnJ5IG92ZXJmbG93IHBvcz0ke3N9IGZyb209JHtlfWApO1xuICAgIGZvciAocyArPSBlOyBzID49IHI7IHMgLT0gcilcbiAgICAgIGEucHVzaCgoaSA+PiBzIC0gciAmIG8pID4+PiAwKTtcbiAgICBpICY9IDIgKiogcyAtIDE7XG4gIH1cbiAgaWYgKGkgPSBpIDw8IHIgLSBzICYgbywgIW4gJiYgcyA+PSBlKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkV4Y2VzcyBwYWRkaW5nXCIpO1xuICBpZiAoIW4gJiYgaSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE5vbi16ZXJvIHBhZGRpbmc6ICR7aX1gKTtcbiAgcmV0dXJuIG4gJiYgcyA+IDAgJiYgYS5wdXNoKGkgPj4+IDApLCBhO1xufVxuZnVuY3Rpb24gbXModCkge1xuICByZXR1cm4gcnQodCksIHtcbiAgICBlbmNvZGU6IChlKSA9PiB7XG4gICAgICBpZiAoIShlIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInJhZGl4LmVuY29kZSBpbnB1dCBzaG91bGQgYmUgVWludDhBcnJheVwiKTtcbiAgICAgIHJldHVybiBGaShBcnJheS5mcm9tKGUpLCAyICoqIDgsIHQpO1xuICAgIH0sXG4gICAgZGVjb2RlOiAoZSkgPT4ge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGUpIHx8IGUubGVuZ3RoICYmIHR5cGVvZiBlWzBdICE9IFwibnVtYmVyXCIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInJhZGl4LmRlY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2Ygc3RyaW5nc1wiKTtcbiAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oRmkoZSwgdCwgMiAqKiA4KSk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gTmUodCwgZSA9ICExKSB7XG4gIGlmIChydCh0KSwgdCA8PSAwIHx8IHQgPiAzMilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJyYWRpeDI6IGJpdHMgc2hvdWxkIGJlIGluICgwLi4zMl1cIik7XG4gIGlmIChUcig4LCB0KSA+IDMyIHx8IFRyKHQsIDgpID4gMzIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwicmFkaXgyOiBjYXJyeSBvdmVyZmxvd1wiKTtcbiAgcmV0dXJuIHtcbiAgICBlbmNvZGU6IChyKSA9PiB7XG4gICAgICBpZiAoIShyIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInJhZGl4Mi5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIFVpbnQ4QXJyYXlcIik7XG4gICAgICByZXR1cm4gQm4oQXJyYXkuZnJvbShyKSwgOCwgdCwgIWUpO1xuICAgIH0sXG4gICAgZGVjb2RlOiAocikgPT4ge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHIpIHx8IHIubGVuZ3RoICYmIHR5cGVvZiByWzBdICE9IFwibnVtYmVyXCIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInJhZGl4Mi5kZWNvZGUgaW5wdXQgc2hvdWxkIGJlIGFycmF5IG9mIHN0cmluZ3NcIik7XG4gICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKEJuKHIsIHQsIDgsIGUpKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBLaSh0KSB7XG4gIGlmICh0eXBlb2YgdCAhPSBcImZ1bmN0aW9uXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwidW5zYWZlV3JhcHBlciBmbiBzaG91bGQgYmUgZnVuY3Rpb25cIik7XG4gIHJldHVybiBmdW5jdGlvbiguLi5lKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0LmFwcGx5KG51bGwsIGUpO1xuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHhzKHQsIGUpIHtcbiAgaWYgKHJ0KHQpLCB0eXBlb2YgZSAhPSBcImZ1bmN0aW9uXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY2hlY2tzdW0gZm4gc2hvdWxkIGJlIGZ1bmN0aW9uXCIpO1xuICByZXR1cm4ge1xuICAgIGVuY29kZShyKSB7XG4gICAgICBpZiAoIShyIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNoZWNrc3VtLmVuY29kZTogaW5wdXQgc2hvdWxkIGJlIFVpbnQ4QXJyYXlcIik7XG4gICAgICBjb25zdCBuID0gZShyKS5zbGljZSgwLCB0KSwgaSA9IG5ldyBVaW50OEFycmF5KHIubGVuZ3RoICsgdCk7XG4gICAgICByZXR1cm4gaS5zZXQociksIGkuc2V0KG4sIHIubGVuZ3RoKSwgaTtcbiAgICB9LFxuICAgIGRlY29kZShyKSB7XG4gICAgICBpZiAoIShyIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNoZWNrc3VtLmRlY29kZTogaW5wdXQgc2hvdWxkIGJlIFVpbnQ4QXJyYXlcIik7XG4gICAgICBjb25zdCBuID0gci5zbGljZSgwLCAtdCksIGkgPSBlKG4pLnNsaWNlKDAsIHQpLCBzID0gci5zbGljZSgtdCk7XG4gICAgICBmb3IgKGxldCBvID0gMDsgbyA8IHQ7IG8rKylcbiAgICAgICAgaWYgKGlbb10gIT09IHNbb10pXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjaGVja3N1bVwiKTtcbiAgICAgIHJldHVybiBuO1xuICAgIH1cbiAgfTtcbn1cbmNvbnN0IEJ1ID0geyBhbHBoYWJldDogUmUsIGNoYWluOiBTZSwgY2hlY2tzdW06IHhzLCByYWRpeDogbXMsIHJhZGl4MjogTmUsIGpvaW46IFRlLCBwYWRkaW5nOiBzciB9LCBFcyA9IFNlKE5lKDQpLCBSZShcIjAxMjM0NTY3ODlBQkNERUZcIiksIFRlKFwiXCIpKSwga3MgPSBTZShOZSg1KSwgUmUoXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjIzNDU2N1wiKSwgc3IoNSksIFRlKFwiXCIpKSwgTHUgPSBTZShOZSg1KSwgUmUoXCIwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVlwiKSwgc3IoNSksIFRlKFwiXCIpKSwgJHUgPSBTZShOZSg1KSwgUmUoXCIwMTIzNDU2Nzg5QUJDREVGR0hKS01OUFFSU1RWV1hZWlwiKSwgVGUoXCJcIiksIHdzKCh0KSA9PiB0LnRvVXBwZXJDYXNlKCkucmVwbGFjZSgvTy9nLCBcIjBcIikucmVwbGFjZSgvW0lMXS9nLCBcIjFcIikpKSwgbXQgPSBTZShOZSg2KSwgUmUoXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCIpLCBzcig2KSwgVGUoXCJcIikpLCBTcyA9IFNlKE5lKDYpLCBSZShcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5LV9cIiksIHNyKDYpLCBUZShcIlwiKSksIEpuID0gKHQpID0+IFNlKG1zKDU4KSwgUmUodCksIFRlKFwiXCIpKSwgbnIgPSBKbihcIjEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXpcIiksIHF1ID0gSm4oXCIxMjM0NTY3ODlhYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaXCIpLCBOdSA9IEpuKFwicnBzaG5hZjM5d0JVRE5FR0hKS0xNNFBRUlNUN1ZXWFlaMmJjZGVDZzY1amttOG9GcWkxdHV2QXh5elwiKSwgV2kgPSBbMCwgMiwgMywgNSwgNiwgNywgOSwgMTAsIDExXSwgT3MgPSB7XG4gIGVuY29kZSh0KSB7XG4gICAgbGV0IGUgPSBcIlwiO1xuICAgIGZvciAobGV0IHIgPSAwOyByIDwgdC5sZW5ndGg7IHIgKz0gOCkge1xuICAgICAgY29uc3QgbiA9IHQuc3ViYXJyYXkociwgciArIDgpO1xuICAgICAgZSArPSBuci5lbmNvZGUobikucGFkU3RhcnQoV2lbbi5sZW5ndGhdLCBcIjFcIik7XG4gICAgfVxuICAgIHJldHVybiBlO1xuICB9LFxuICBkZWNvZGUodCkge1xuICAgIGxldCBlID0gW107XG4gICAgZm9yIChsZXQgciA9IDA7IHIgPCB0Lmxlbmd0aDsgciArPSAxMSkge1xuICAgICAgY29uc3QgbiA9IHQuc2xpY2UociwgciArIDExKSwgaSA9IFdpLmluZGV4T2Yobi5sZW5ndGgpLCBzID0gbnIuZGVjb2RlKG4pO1xuICAgICAgZm9yIChsZXQgbyA9IDA7IG8gPCBzLmxlbmd0aCAtIGk7IG8rKylcbiAgICAgICAgaWYgKHNbb10gIT09IDApXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmFzZTU4eG1yOiB3cm9uZyBwYWRkaW5nXCIpO1xuICAgICAgZSA9IGUuY29uY2F0KEFycmF5LmZyb20ocy5zbGljZShzLmxlbmd0aCAtIGkpKSk7XG4gICAgfVxuICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oZSk7XG4gIH1cbn0sIEFzID0gKHQpID0+IFNlKHhzKDQsIChlKSA9PiB0KHQoZSkpKSwgbnIpLCBMbiA9IFNlKFJlKFwicXB6cnk5eDhnZjJ0dmR3MHMzam41NGtoY2U2bXVhN2xcIiksIFRlKFwiXCIpKSwgVmkgPSBbOTk2ODI1MDEwLCA2NDI4MTM1NDksIDUxMzg3NDQyNiwgMTAyNzc0ODgyOSwgNzA1OTc5MDU5XTtcbmZ1bmN0aW9uIEl0KHQpIHtcbiAgY29uc3QgZSA9IHQgPj4gMjU7XG4gIGxldCByID0gKHQgJiAzMzU1NDQzMSkgPDwgNTtcbiAgZm9yIChsZXQgbiA9IDA7IG4gPCBWaS5sZW5ndGg7IG4rKylcbiAgICAoZSA+PiBuICYgMSkgPT09IDEgJiYgKHIgXj0gVmlbbl0pO1xuICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIEdpKHQsIGUsIHIgPSAxKSB7XG4gIGNvbnN0IG4gPSB0Lmxlbmd0aDtcbiAgbGV0IGkgPSAxO1xuICBmb3IgKGxldCBzID0gMDsgcyA8IG47IHMrKykge1xuICAgIGNvbnN0IG8gPSB0LmNoYXJDb2RlQXQocyk7XG4gICAgaWYgKG8gPCAzMyB8fCBvID4gMTI2KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHByZWZpeCAoJHt0fSlgKTtcbiAgICBpID0gSXQoaSkgXiBvID4+IDU7XG4gIH1cbiAgaSA9IEl0KGkpO1xuICBmb3IgKGxldCBzID0gMDsgcyA8IG47IHMrKylcbiAgICBpID0gSXQoaSkgXiB0LmNoYXJDb2RlQXQocykgJiAzMTtcbiAgZm9yIChsZXQgcyBvZiBlKVxuICAgIGkgPSBJdChpKSBeIHM7XG4gIGZvciAobGV0IHMgPSAwOyBzIDwgNjsgcysrKVxuICAgIGkgPSBJdChpKTtcbiAgcmV0dXJuIGkgXj0gciwgTG4uZW5jb2RlKEJuKFtpICUgMiAqKiAzMF0sIDMwLCA1LCAhMSkpO1xufVxuZnVuY3Rpb24gQ3ModCkge1xuICBjb25zdCBlID0gdCA9PT0gXCJiZWNoMzJcIiA/IDEgOiA3MzQ1Mzk5MzksIHIgPSBOZSg1KSwgbiA9IHIuZGVjb2RlLCBpID0gci5lbmNvZGUsIHMgPSBLaShuKTtcbiAgZnVuY3Rpb24gbyhmLCB1LCBoID0gOTApIHtcbiAgICBpZiAodHlwZW9mIGYgIT0gXCJzdHJpbmdcIilcbiAgICAgIHRocm93IG5ldyBFcnJvcihgYmVjaDMyLmVuY29kZSBwcmVmaXggc2hvdWxkIGJlIHN0cmluZywgbm90ICR7dHlwZW9mIGZ9YCk7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHUpIHx8IHUubGVuZ3RoICYmIHR5cGVvZiB1WzBdICE9IFwibnVtYmVyXCIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGJlY2gzMi5lbmNvZGUgd29yZHMgc2hvdWxkIGJlIGFycmF5IG9mIG51bWJlcnMsIG5vdCAke3R5cGVvZiB1fWApO1xuICAgIGNvbnN0IGQgPSBmLmxlbmd0aCArIDcgKyB1Lmxlbmd0aDtcbiAgICBpZiAoaCAhPT0gITEgJiYgZCA+IGgpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBMZW5ndGggJHtkfSBleGNlZWRzIGxpbWl0ICR7aH1gKTtcbiAgICByZXR1cm4gZiA9IGYudG9Mb3dlckNhc2UoKSwgYCR7Zn0xJHtMbi5lbmNvZGUodSl9JHtHaShmLCB1LCBlKX1gO1xuICB9XG4gIGZ1bmN0aW9uIGEoZiwgdSA9IDkwKSB7XG4gICAgaWYgKHR5cGVvZiBmICE9IFwic3RyaW5nXCIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGJlY2gzMi5kZWNvZGUgaW5wdXQgc2hvdWxkIGJlIHN0cmluZywgbm90ICR7dHlwZW9mIGZ9YCk7XG4gICAgaWYgKGYubGVuZ3RoIDwgOCB8fCB1ICE9PSAhMSAmJiBmLmxlbmd0aCA+IHUpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBXcm9uZyBzdHJpbmcgbGVuZ3RoOiAke2YubGVuZ3RofSAoJHtmfSkuIEV4cGVjdGVkICg4Li4ke3V9KWApO1xuICAgIGNvbnN0IGggPSBmLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGYgIT09IGggJiYgZiAhPT0gZi50b1VwcGVyQ2FzZSgpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RyaW5nIG11c3QgYmUgbG93ZXJjYXNlIG9yIHVwcGVyY2FzZVwiKTtcbiAgICBmID0gaDtcbiAgICBjb25zdCBkID0gZi5sYXN0SW5kZXhPZihcIjFcIik7XG4gICAgaWYgKGQgPT09IDAgfHwgZCA9PT0gLTEpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xldHRlciBcIjFcIiBtdXN0IGJlIHByZXNlbnQgYmV0d2VlbiBwcmVmaXggYW5kIGRhdGEgb25seScpO1xuICAgIGNvbnN0IHAgPSBmLnNsaWNlKDAsIGQpLCB5ID0gZi5zbGljZShkICsgMSk7XG4gICAgaWYgKHkubGVuZ3RoIDwgNilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGEgbXVzdCBiZSBhdCBsZWFzdCA2IGNoYXJhY3RlcnMgbG9uZ1wiKTtcbiAgICBjb25zdCBnID0gTG4uZGVjb2RlKHkpLnNsaWNlKDAsIC02KSwgdiA9IEdpKHAsIGcsIGUpO1xuICAgIGlmICgheS5lbmRzV2l0aCh2KSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjaGVja3N1bSBpbiAke2Z9OiBleHBlY3RlZCBcIiR7dn1cImApO1xuICAgIHJldHVybiB7IHByZWZpeDogcCwgd29yZHM6IGcgfTtcbiAgfVxuICBjb25zdCBjID0gS2koYSk7XG4gIGZ1bmN0aW9uIGwoZikge1xuICAgIGNvbnN0IHsgcHJlZml4OiB1LCB3b3JkczogaCB9ID0gYShmLCAhMSk7XG4gICAgcmV0dXJuIHsgcHJlZml4OiB1LCB3b3JkczogaCwgYnl0ZXM6IG4oaCkgfTtcbiAgfVxuICByZXR1cm4geyBlbmNvZGU6IG8sIGRlY29kZTogYSwgZGVjb2RlVG9CeXRlczogbCwgZGVjb2RlVW5zYWZlOiBjLCBmcm9tV29yZHM6IG4sIGZyb21Xb3Jkc1Vuc2FmZTogcywgdG9Xb3JkczogaSB9O1xufVxuY29uc3QgdGUgPSBDcyhcImJlY2gzMlwiKSwgVXUgPSBDcyhcImJlY2gzMm1cIiksIElzID0ge1xuICBlbmNvZGU6ICh0KSA9PiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUodCksXG4gIGRlY29kZTogKHQpID0+IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh0KVxufSwgUnMgPSBTZShOZSg0KSwgUmUoXCIwMTIzNDU2Nzg5YWJjZGVmXCIpLCBUZShcIlwiKSwgd3MoKHQpID0+IHtcbiAgaWYgKHR5cGVvZiB0ICE9IFwic3RyaW5nXCIgfHwgdC5sZW5ndGggJSAyKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGhleC5kZWNvZGU6IGV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIHR9IHdpdGggbGVuZ3RoICR7dC5sZW5ndGh9YCk7XG4gIHJldHVybiB0LnRvTG93ZXJDYXNlKCk7XG59KSksIGlyID0ge1xuICB1dGY4OiBJcyxcbiAgaGV4OiBScyxcbiAgYmFzZTE2OiBFcyxcbiAgYmFzZTMyOiBrcyxcbiAgYmFzZTY0OiBtdCxcbiAgYmFzZTY0dXJsOiBTcyxcbiAgYmFzZTU4OiBucixcbiAgYmFzZTU4eG1yOiBPc1xufSwgVHMgPSBgSW52YWxpZCBlbmNvZGluZyB0eXBlLiBBdmFpbGFibGUgdHlwZXM6ICR7T2JqZWN0LmtleXMoaXIpLmpvaW4oXCIsIFwiKX1gLCBQcyA9ICh0LCBlKSA9PiB7XG4gIGlmICh0eXBlb2YgdCAhPSBcInN0cmluZ1wiIHx8ICFpci5oYXNPd25Qcm9wZXJ0eSh0KSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFRzKTtcbiAgaWYgKCEoZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJieXRlc1RvU3RyaW5nKCkgZXhwZWN0cyBVaW50OEFycmF5XCIpO1xuICByZXR1cm4gaXJbdF0uZW5jb2RlKGUpO1xufSwganUgPSBQcywgQnMgPSAodCwgZSkgPT4ge1xuICBpZiAoIWlyLmhhc093blByb3BlcnR5KHQpKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoVHMpO1xuICBpZiAodHlwZW9mIGUgIT0gXCJzdHJpbmdcIilcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwic3RyaW5nVG9CeXRlcygpIGV4cGVjdHMgc3RyaW5nXCIpO1xuICByZXR1cm4gaXJbdF0uZGVjb2RlKGUpO1xufSwgSHUgPSBCcywgTXUgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgX19wcm90b19fOiBudWxsLFxuICBhc3NlcnROdW1iZXI6IHJ0LFxuICB1dGlsczogQnUsXG4gIGJhc2UxNjogRXMsXG4gIGJhc2UzMjoga3MsXG4gIGJhc2UzMmhleDogTHUsXG4gIGJhc2UzMmNyb2NrZm9yZDogJHUsXG4gIGJhc2U2NDogbXQsXG4gIGJhc2U2NHVybDogU3MsXG4gIGJhc2U1ODogbnIsXG4gIGJhc2U1OGZsaWNrcjogcXUsXG4gIGJhc2U1OHhycDogTnUsXG4gIGJhc2U1OHhtcjogT3MsXG4gIGJhc2U1OGNoZWNrOiBBcyxcbiAgYmVjaDMyOiB0ZSxcbiAgYmVjaDMybTogVXUsXG4gIHV0Zjg6IElzLFxuICBoZXg6IFJzLFxuICBieXRlc1RvU3RyaW5nOiBQcyxcbiAgc3RyOiBqdSxcbiAgc3RyaW5nVG9CeXRlczogQnMsXG4gIGJ5dGVzOiBIdVxufSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pKTtcbnZhciBYbiA9IHt9O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFhuLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG52YXIgUW4gPSBYbi53b3JkbGlzdCA9IHZvaWQgMDtcblFuID0gWG4ud29yZGxpc3QgPSBgYWJhbmRvblxuYWJpbGl0eVxuYWJsZVxuYWJvdXRcbmFib3ZlXG5hYnNlbnRcbmFic29yYlxuYWJzdHJhY3RcbmFic3VyZFxuYWJ1c2VcbmFjY2Vzc1xuYWNjaWRlbnRcbmFjY291bnRcbmFjY3VzZVxuYWNoaWV2ZVxuYWNpZFxuYWNvdXN0aWNcbmFjcXVpcmVcbmFjcm9zc1xuYWN0XG5hY3Rpb25cbmFjdG9yXG5hY3RyZXNzXG5hY3R1YWxcbmFkYXB0XG5hZGRcbmFkZGljdFxuYWRkcmVzc1xuYWRqdXN0XG5hZG1pdFxuYWR1bHRcbmFkdmFuY2VcbmFkdmljZVxuYWVyb2JpY1xuYWZmYWlyXG5hZmZvcmRcbmFmcmFpZFxuYWdhaW5cbmFnZVxuYWdlbnRcbmFncmVlXG5haGVhZFxuYWltXG5haXJcbmFpcnBvcnRcbmFpc2xlXG5hbGFybVxuYWxidW1cbmFsY29ob2xcbmFsZXJ0XG5hbGllblxuYWxsXG5hbGxleVxuYWxsb3dcbmFsbW9zdFxuYWxvbmVcbmFscGhhXG5hbHJlYWR5XG5hbHNvXG5hbHRlclxuYWx3YXlzXG5hbWF0ZXVyXG5hbWF6aW5nXG5hbW9uZ1xuYW1vdW50XG5hbXVzZWRcbmFuYWx5c3RcbmFuY2hvclxuYW5jaWVudFxuYW5nZXJcbmFuZ2xlXG5hbmdyeVxuYW5pbWFsXG5hbmtsZVxuYW5ub3VuY2VcbmFubnVhbFxuYW5vdGhlclxuYW5zd2VyXG5hbnRlbm5hXG5hbnRpcXVlXG5hbnhpZXR5XG5hbnlcbmFwYXJ0XG5hcG9sb2d5XG5hcHBlYXJcbmFwcGxlXG5hcHByb3ZlXG5hcHJpbFxuYXJjaFxuYXJjdGljXG5hcmVhXG5hcmVuYVxuYXJndWVcbmFybVxuYXJtZWRcbmFybW9yXG5hcm15XG5hcm91bmRcbmFycmFuZ2VcbmFycmVzdFxuYXJyaXZlXG5hcnJvd1xuYXJ0XG5hcnRlZmFjdFxuYXJ0aXN0XG5hcnR3b3JrXG5hc2tcbmFzcGVjdFxuYXNzYXVsdFxuYXNzZXRcbmFzc2lzdFxuYXNzdW1lXG5hc3RobWFcbmF0aGxldGVcbmF0b21cbmF0dGFja1xuYXR0ZW5kXG5hdHRpdHVkZVxuYXR0cmFjdFxuYXVjdGlvblxuYXVkaXRcbmF1Z3VzdFxuYXVudFxuYXV0aG9yXG5hdXRvXG5hdXR1bW5cbmF2ZXJhZ2VcbmF2b2NhZG9cbmF2b2lkXG5hd2FrZVxuYXdhcmVcbmF3YXlcbmF3ZXNvbWVcbmF3ZnVsXG5hd2t3YXJkXG5heGlzXG5iYWJ5XG5iYWNoZWxvclxuYmFjb25cbmJhZGdlXG5iYWdcbmJhbGFuY2VcbmJhbGNvbnlcbmJhbGxcbmJhbWJvb1xuYmFuYW5hXG5iYW5uZXJcbmJhclxuYmFyZWx5XG5iYXJnYWluXG5iYXJyZWxcbmJhc2VcbmJhc2ljXG5iYXNrZXRcbmJhdHRsZVxuYmVhY2hcbmJlYW5cbmJlYXV0eVxuYmVjYXVzZVxuYmVjb21lXG5iZWVmXG5iZWZvcmVcbmJlZ2luXG5iZWhhdmVcbmJlaGluZFxuYmVsaWV2ZVxuYmVsb3dcbmJlbHRcbmJlbmNoXG5iZW5lZml0XG5iZXN0XG5iZXRyYXlcbmJldHRlclxuYmV0d2VlblxuYmV5b25kXG5iaWN5Y2xlXG5iaWRcbmJpa2VcbmJpbmRcbmJpb2xvZ3lcbmJpcmRcbmJpcnRoXG5iaXR0ZXJcbmJsYWNrXG5ibGFkZVxuYmxhbWVcbmJsYW5rZXRcbmJsYXN0XG5ibGVha1xuYmxlc3NcbmJsaW5kXG5ibG9vZFxuYmxvc3NvbVxuYmxvdXNlXG5ibHVlXG5ibHVyXG5ibHVzaFxuYm9hcmRcbmJvYXRcbmJvZHlcbmJvaWxcbmJvbWJcbmJvbmVcbmJvbnVzXG5ib29rXG5ib29zdFxuYm9yZGVyXG5ib3JpbmdcbmJvcnJvd1xuYm9zc1xuYm90dG9tXG5ib3VuY2VcbmJveFxuYm95XG5icmFja2V0XG5icmFpblxuYnJhbmRcbmJyYXNzXG5icmF2ZVxuYnJlYWRcbmJyZWV6ZVxuYnJpY2tcbmJyaWRnZVxuYnJpZWZcbmJyaWdodFxuYnJpbmdcbmJyaXNrXG5icm9jY29saVxuYnJva2VuXG5icm9uemVcbmJyb29tXG5icm90aGVyXG5icm93blxuYnJ1c2hcbmJ1YmJsZVxuYnVkZHlcbmJ1ZGdldFxuYnVmZmFsb1xuYnVpbGRcbmJ1bGJcbmJ1bGtcbmJ1bGxldFxuYnVuZGxlXG5idW5rZXJcbmJ1cmRlblxuYnVyZ2VyXG5idXJzdFxuYnVzXG5idXNpbmVzc1xuYnVzeVxuYnV0dGVyXG5idXllclxuYnV6elxuY2FiYmFnZVxuY2FiaW5cbmNhYmxlXG5jYWN0dXNcbmNhZ2VcbmNha2VcbmNhbGxcbmNhbG1cbmNhbWVyYVxuY2FtcFxuY2FuXG5jYW5hbFxuY2FuY2VsXG5jYW5keVxuY2Fubm9uXG5jYW5vZVxuY2FudmFzXG5jYW55b25cbmNhcGFibGVcbmNhcGl0YWxcbmNhcHRhaW5cbmNhclxuY2FyYm9uXG5jYXJkXG5jYXJnb1xuY2FycGV0XG5jYXJyeVxuY2FydFxuY2FzZVxuY2FzaFxuY2FzaW5vXG5jYXN0bGVcbmNhc3VhbFxuY2F0XG5jYXRhbG9nXG5jYXRjaFxuY2F0ZWdvcnlcbmNhdHRsZVxuY2F1Z2h0XG5jYXVzZVxuY2F1dGlvblxuY2F2ZVxuY2VpbGluZ1xuY2VsZXJ5XG5jZW1lbnRcbmNlbnN1c1xuY2VudHVyeVxuY2VyZWFsXG5jZXJ0YWluXG5jaGFpclxuY2hhbGtcbmNoYW1waW9uXG5jaGFuZ2VcbmNoYW9zXG5jaGFwdGVyXG5jaGFyZ2VcbmNoYXNlXG5jaGF0XG5jaGVhcFxuY2hlY2tcbmNoZWVzZVxuY2hlZlxuY2hlcnJ5XG5jaGVzdFxuY2hpY2tlblxuY2hpZWZcbmNoaWxkXG5jaGltbmV5XG5jaG9pY2VcbmNob29zZVxuY2hyb25pY1xuY2h1Y2tsZVxuY2h1bmtcbmNodXJuXG5jaWdhclxuY2lubmFtb25cbmNpcmNsZVxuY2l0aXplblxuY2l0eVxuY2l2aWxcbmNsYWltXG5jbGFwXG5jbGFyaWZ5XG5jbGF3XG5jbGF5XG5jbGVhblxuY2xlcmtcbmNsZXZlclxuY2xpY2tcbmNsaWVudFxuY2xpZmZcbmNsaW1iXG5jbGluaWNcbmNsaXBcbmNsb2NrXG5jbG9nXG5jbG9zZVxuY2xvdGhcbmNsb3VkXG5jbG93blxuY2x1YlxuY2x1bXBcbmNsdXN0ZXJcbmNsdXRjaFxuY29hY2hcbmNvYXN0XG5jb2NvbnV0XG5jb2RlXG5jb2ZmZWVcbmNvaWxcbmNvaW5cbmNvbGxlY3RcbmNvbG9yXG5jb2x1bW5cbmNvbWJpbmVcbmNvbWVcbmNvbWZvcnRcbmNvbWljXG5jb21tb25cbmNvbXBhbnlcbmNvbmNlcnRcbmNvbmR1Y3RcbmNvbmZpcm1cbmNvbmdyZXNzXG5jb25uZWN0XG5jb25zaWRlclxuY29udHJvbFxuY29udmluY2VcbmNvb2tcbmNvb2xcbmNvcHBlclxuY29weVxuY29yYWxcbmNvcmVcbmNvcm5cbmNvcnJlY3RcbmNvc3RcbmNvdHRvblxuY291Y2hcbmNvdW50cnlcbmNvdXBsZVxuY291cnNlXG5jb3VzaW5cbmNvdmVyXG5jb3lvdGVcbmNyYWNrXG5jcmFkbGVcbmNyYWZ0XG5jcmFtXG5jcmFuZVxuY3Jhc2hcbmNyYXRlclxuY3Jhd2xcbmNyYXp5XG5jcmVhbVxuY3JlZGl0XG5jcmVla1xuY3Jld1xuY3JpY2tldFxuY3JpbWVcbmNyaXNwXG5jcml0aWNcbmNyb3BcbmNyb3NzXG5jcm91Y2hcbmNyb3dkXG5jcnVjaWFsXG5jcnVlbFxuY3J1aXNlXG5jcnVtYmxlXG5jcnVuY2hcbmNydXNoXG5jcnlcbmNyeXN0YWxcbmN1YmVcbmN1bHR1cmVcbmN1cFxuY3VwYm9hcmRcbmN1cmlvdXNcbmN1cnJlbnRcbmN1cnRhaW5cbmN1cnZlXG5jdXNoaW9uXG5jdXN0b21cbmN1dGVcbmN5Y2xlXG5kYWRcbmRhbWFnZVxuZGFtcFxuZGFuY2VcbmRhbmdlclxuZGFyaW5nXG5kYXNoXG5kYXVnaHRlclxuZGF3blxuZGF5XG5kZWFsXG5kZWJhdGVcbmRlYnJpc1xuZGVjYWRlXG5kZWNlbWJlclxuZGVjaWRlXG5kZWNsaW5lXG5kZWNvcmF0ZVxuZGVjcmVhc2VcbmRlZXJcbmRlZmVuc2VcbmRlZmluZVxuZGVmeVxuZGVncmVlXG5kZWxheVxuZGVsaXZlclxuZGVtYW5kXG5kZW1pc2VcbmRlbmlhbFxuZGVudGlzdFxuZGVueVxuZGVwYXJ0XG5kZXBlbmRcbmRlcG9zaXRcbmRlcHRoXG5kZXB1dHlcbmRlcml2ZVxuZGVzY3JpYmVcbmRlc2VydFxuZGVzaWduXG5kZXNrXG5kZXNwYWlyXG5kZXN0cm95XG5kZXRhaWxcbmRldGVjdFxuZGV2ZWxvcFxuZGV2aWNlXG5kZXZvdGVcbmRpYWdyYW1cbmRpYWxcbmRpYW1vbmRcbmRpYXJ5XG5kaWNlXG5kaWVzZWxcbmRpZXRcbmRpZmZlclxuZGlnaXRhbFxuZGlnbml0eVxuZGlsZW1tYVxuZGlubmVyXG5kaW5vc2F1clxuZGlyZWN0XG5kaXJ0XG5kaXNhZ3JlZVxuZGlzY292ZXJcbmRpc2Vhc2VcbmRpc2hcbmRpc21pc3NcbmRpc29yZGVyXG5kaXNwbGF5XG5kaXN0YW5jZVxuZGl2ZXJ0XG5kaXZpZGVcbmRpdm9yY2VcbmRpenp5XG5kb2N0b3JcbmRvY3VtZW50XG5kb2dcbmRvbGxcbmRvbHBoaW5cbmRvbWFpblxuZG9uYXRlXG5kb25rZXlcbmRvbm9yXG5kb29yXG5kb3NlXG5kb3VibGVcbmRvdmVcbmRyYWZ0XG5kcmFnb25cbmRyYW1hXG5kcmFzdGljXG5kcmF3XG5kcmVhbVxuZHJlc3NcbmRyaWZ0XG5kcmlsbFxuZHJpbmtcbmRyaXBcbmRyaXZlXG5kcm9wXG5kcnVtXG5kcnlcbmR1Y2tcbmR1bWJcbmR1bmVcbmR1cmluZ1xuZHVzdFxuZHV0Y2hcbmR1dHlcbmR3YXJmXG5keW5hbWljXG5lYWdlclxuZWFnbGVcbmVhcmx5XG5lYXJuXG5lYXJ0aFxuZWFzaWx5XG5lYXN0XG5lYXN5XG5lY2hvXG5lY29sb2d5XG5lY29ub215XG5lZGdlXG5lZGl0XG5lZHVjYXRlXG5lZmZvcnRcbmVnZ1xuZWlnaHRcbmVpdGhlclxuZWxib3dcbmVsZGVyXG5lbGVjdHJpY1xuZWxlZ2FudFxuZWxlbWVudFxuZWxlcGhhbnRcbmVsZXZhdG9yXG5lbGl0ZVxuZWxzZVxuZW1iYXJrXG5lbWJvZHlcbmVtYnJhY2VcbmVtZXJnZVxuZW1vdGlvblxuZW1wbG95XG5lbXBvd2VyXG5lbXB0eVxuZW5hYmxlXG5lbmFjdFxuZW5kXG5lbmRsZXNzXG5lbmRvcnNlXG5lbmVteVxuZW5lcmd5XG5lbmZvcmNlXG5lbmdhZ2VcbmVuZ2luZVxuZW5oYW5jZVxuZW5qb3lcbmVubGlzdFxuZW5vdWdoXG5lbnJpY2hcbmVucm9sbFxuZW5zdXJlXG5lbnRlclxuZW50aXJlXG5lbnRyeVxuZW52ZWxvcGVcbmVwaXNvZGVcbmVxdWFsXG5lcXVpcFxuZXJhXG5lcmFzZVxuZXJvZGVcbmVyb3Npb25cbmVycm9yXG5lcnVwdFxuZXNjYXBlXG5lc3NheVxuZXNzZW5jZVxuZXN0YXRlXG5ldGVybmFsXG5ldGhpY3NcbmV2aWRlbmNlXG5ldmlsXG5ldm9rZVxuZXZvbHZlXG5leGFjdFxuZXhhbXBsZVxuZXhjZXNzXG5leGNoYW5nZVxuZXhjaXRlXG5leGNsdWRlXG5leGN1c2VcbmV4ZWN1dGVcbmV4ZXJjaXNlXG5leGhhdXN0XG5leGhpYml0XG5leGlsZVxuZXhpc3RcbmV4aXRcbmV4b3RpY1xuZXhwYW5kXG5leHBlY3RcbmV4cGlyZVxuZXhwbGFpblxuZXhwb3NlXG5leHByZXNzXG5leHRlbmRcbmV4dHJhXG5leWVcbmV5ZWJyb3dcbmZhYnJpY1xuZmFjZVxuZmFjdWx0eVxuZmFkZVxuZmFpbnRcbmZhaXRoXG5mYWxsXG5mYWxzZVxuZmFtZVxuZmFtaWx5XG5mYW1vdXNcbmZhblxuZmFuY3lcbmZhbnRhc3lcbmZhcm1cbmZhc2hpb25cbmZhdFxuZmF0YWxcbmZhdGhlclxuZmF0aWd1ZVxuZmF1bHRcbmZhdm9yaXRlXG5mZWF0dXJlXG5mZWJydWFyeVxuZmVkZXJhbFxuZmVlXG5mZWVkXG5mZWVsXG5mZW1hbGVcbmZlbmNlXG5mZXN0aXZhbFxuZmV0Y2hcbmZldmVyXG5mZXdcbmZpYmVyXG5maWN0aW9uXG5maWVsZFxuZmlndXJlXG5maWxlXG5maWxtXG5maWx0ZXJcbmZpbmFsXG5maW5kXG5maW5lXG5maW5nZXJcbmZpbmlzaFxuZmlyZVxuZmlybVxuZmlyc3RcbmZpc2NhbFxuZmlzaFxuZml0XG5maXRuZXNzXG5maXhcbmZsYWdcbmZsYW1lXG5mbGFzaFxuZmxhdFxuZmxhdm9yXG5mbGVlXG5mbGlnaHRcbmZsaXBcbmZsb2F0XG5mbG9ja1xuZmxvb3JcbmZsb3dlclxuZmx1aWRcbmZsdXNoXG5mbHlcbmZvYW1cbmZvY3VzXG5mb2dcbmZvaWxcbmZvbGRcbmZvbGxvd1xuZm9vZFxuZm9vdFxuZm9yY2VcbmZvcmVzdFxuZm9yZ2V0XG5mb3JrXG5mb3J0dW5lXG5mb3J1bVxuZm9yd2FyZFxuZm9zc2lsXG5mb3N0ZXJcbmZvdW5kXG5mb3hcbmZyYWdpbGVcbmZyYW1lXG5mcmVxdWVudFxuZnJlc2hcbmZyaWVuZFxuZnJpbmdlXG5mcm9nXG5mcm9udFxuZnJvc3RcbmZyb3duXG5mcm96ZW5cbmZydWl0XG5mdWVsXG5mdW5cbmZ1bm55XG5mdXJuYWNlXG5mdXJ5XG5mdXR1cmVcbmdhZGdldFxuZ2FpblxuZ2FsYXh5XG5nYWxsZXJ5XG5nYW1lXG5nYXBcbmdhcmFnZVxuZ2FyYmFnZVxuZ2FyZGVuXG5nYXJsaWNcbmdhcm1lbnRcbmdhc1xuZ2FzcFxuZ2F0ZVxuZ2F0aGVyXG5nYXVnZVxuZ2F6ZVxuZ2VuZXJhbFxuZ2VuaXVzXG5nZW5yZVxuZ2VudGxlXG5nZW51aW5lXG5nZXN0dXJlXG5naG9zdFxuZ2lhbnRcbmdpZnRcbmdpZ2dsZVxuZ2luZ2VyXG5naXJhZmZlXG5naXJsXG5naXZlXG5nbGFkXG5nbGFuY2VcbmdsYXJlXG5nbGFzc1xuZ2xpZGVcbmdsaW1wc2Vcbmdsb2JlXG5nbG9vbVxuZ2xvcnlcbmdsb3ZlXG5nbG93XG5nbHVlXG5nb2F0XG5nb2RkZXNzXG5nb2xkXG5nb29kXG5nb29zZVxuZ29yaWxsYVxuZ29zcGVsXG5nb3NzaXBcbmdvdmVyblxuZ293blxuZ3JhYlxuZ3JhY2VcbmdyYWluXG5ncmFudFxuZ3JhcGVcbmdyYXNzXG5ncmF2aXR5XG5ncmVhdFxuZ3JlZW5cbmdyaWRcbmdyaWVmXG5ncml0XG5ncm9jZXJ5XG5ncm91cFxuZ3Jvd1xuZ3J1bnRcbmd1YXJkXG5ndWVzc1xuZ3VpZGVcbmd1aWx0XG5ndWl0YXJcbmd1blxuZ3ltXG5oYWJpdFxuaGFpclxuaGFsZlxuaGFtbWVyXG5oYW1zdGVyXG5oYW5kXG5oYXBweVxuaGFyYm9yXG5oYXJkXG5oYXJzaFxuaGFydmVzdFxuaGF0XG5oYXZlXG5oYXdrXG5oYXphcmRcbmhlYWRcbmhlYWx0aFxuaGVhcnRcbmhlYXZ5XG5oZWRnZWhvZ1xuaGVpZ2h0XG5oZWxsb1xuaGVsbWV0XG5oZWxwXG5oZW5cbmhlcm9cbmhpZGRlblxuaGlnaFxuaGlsbFxuaGludFxuaGlwXG5oaXJlXG5oaXN0b3J5XG5ob2JieVxuaG9ja2V5XG5ob2xkXG5ob2xlXG5ob2xpZGF5XG5ob2xsb3dcbmhvbWVcbmhvbmV5XG5ob29kXG5ob3BlXG5ob3JuXG5ob3Jyb3JcbmhvcnNlXG5ob3NwaXRhbFxuaG9zdFxuaG90ZWxcbmhvdXJcbmhvdmVyXG5odWJcbmh1Z2Vcbmh1bWFuXG5odW1ibGVcbmh1bW9yXG5odW5kcmVkXG5odW5ncnlcbmh1bnRcbmh1cmRsZVxuaHVycnlcbmh1cnRcbmh1c2JhbmRcbmh5YnJpZFxuaWNlXG5pY29uXG5pZGVhXG5pZGVudGlmeVxuaWRsZVxuaWdub3JlXG5pbGxcbmlsbGVnYWxcbmlsbG5lc3NcbmltYWdlXG5pbWl0YXRlXG5pbW1lbnNlXG5pbW11bmVcbmltcGFjdFxuaW1wb3NlXG5pbXByb3ZlXG5pbXB1bHNlXG5pbmNoXG5pbmNsdWRlXG5pbmNvbWVcbmluY3JlYXNlXG5pbmRleFxuaW5kaWNhdGVcbmluZG9vclxuaW5kdXN0cnlcbmluZmFudFxuaW5mbGljdFxuaW5mb3JtXG5pbmhhbGVcbmluaGVyaXRcbmluaXRpYWxcbmluamVjdFxuaW5qdXJ5XG5pbm1hdGVcbmlubmVyXG5pbm5vY2VudFxuaW5wdXRcbmlucXVpcnlcbmluc2FuZVxuaW5zZWN0XG5pbnNpZGVcbmluc3BpcmVcbmluc3RhbGxcbmludGFjdFxuaW50ZXJlc3RcbmludG9cbmludmVzdFxuaW52aXRlXG5pbnZvbHZlXG5pcm9uXG5pc2xhbmRcbmlzb2xhdGVcbmlzc3VlXG5pdGVtXG5pdm9yeVxuamFja2V0XG5qYWd1YXJcbmphclxuamF6elxuamVhbG91c1xuamVhbnNcbmplbGx5XG5qZXdlbFxuam9iXG5qb2luXG5qb2tlXG5qb3VybmV5XG5qb3lcbmp1ZGdlXG5qdWljZVxuanVtcFxuanVuZ2xlXG5qdW5pb3Jcbmp1bmtcbmp1c3Rcbmthbmdhcm9vXG5rZWVuXG5rZWVwXG5rZXRjaHVwXG5rZXlcbmtpY2tcbmtpZFxua2lkbmV5XG5raW5kXG5raW5nZG9tXG5raXNzXG5raXRcbmtpdGNoZW5cbmtpdGVcbmtpdHRlblxua2l3aVxua25lZVxua25pZmVcbmtub2NrXG5rbm93XG5sYWJcbmxhYmVsXG5sYWJvclxubGFkZGVyXG5sYWR5XG5sYWtlXG5sYW1wXG5sYW5ndWFnZVxubGFwdG9wXG5sYXJnZVxubGF0ZXJcbmxhdGluXG5sYXVnaFxubGF1bmRyeVxubGF2YVxubGF3XG5sYXduXG5sYXdzdWl0XG5sYXllclxubGF6eVxubGVhZGVyXG5sZWFmXG5sZWFyblxubGVhdmVcbmxlY3R1cmVcbmxlZnRcbmxlZ1xubGVnYWxcbmxlZ2VuZFxubGVpc3VyZVxubGVtb25cbmxlbmRcbmxlbmd0aFxubGVuc1xubGVvcGFyZFxubGVzc29uXG5sZXR0ZXJcbmxldmVsXG5saWFyXG5saWJlcnR5XG5saWJyYXJ5XG5saWNlbnNlXG5saWZlXG5saWZ0XG5saWdodFxubGlrZVxubGltYlxubGltaXRcbmxpbmtcbmxpb25cbmxpcXVpZFxubGlzdFxubGl0dGxlXG5saXZlXG5saXphcmRcbmxvYWRcbmxvYW5cbmxvYnN0ZXJcbmxvY2FsXG5sb2NrXG5sb2dpY1xubG9uZWx5XG5sb25nXG5sb29wXG5sb3R0ZXJ5XG5sb3VkXG5sb3VuZ2VcbmxvdmVcbmxveWFsXG5sdWNreVxubHVnZ2FnZVxubHVtYmVyXG5sdW5hclxubHVuY2hcbmx1eHVyeVxubHlyaWNzXG5tYWNoaW5lXG5tYWRcbm1hZ2ljXG5tYWduZXRcbm1haWRcbm1haWxcbm1haW5cbm1ham9yXG5tYWtlXG5tYW1tYWxcbm1hblxubWFuYWdlXG5tYW5kYXRlXG5tYW5nb1xubWFuc2lvblxubWFudWFsXG5tYXBsZVxubWFyYmxlXG5tYXJjaFxubWFyZ2luXG5tYXJpbmVcbm1hcmtldFxubWFycmlhZ2Vcbm1hc2tcbm1hc3Ncbm1hc3RlclxubWF0Y2hcbm1hdGVyaWFsXG5tYXRoXG5tYXRyaXhcbm1hdHRlclxubWF4aW11bVxubWF6ZVxubWVhZG93XG5tZWFuXG5tZWFzdXJlXG5tZWF0XG5tZWNoYW5pY1xubWVkYWxcbm1lZGlhXG5tZWxvZHlcbm1lbHRcbm1lbWJlclxubWVtb3J5XG5tZW50aW9uXG5tZW51XG5tZXJjeVxubWVyZ2Vcbm1lcml0XG5tZXJyeVxubWVzaFxubWVzc2FnZVxubWV0YWxcbm1ldGhvZFxubWlkZGxlXG5taWRuaWdodFxubWlsa1xubWlsbGlvblxubWltaWNcbm1pbmRcbm1pbmltdW1cbm1pbm9yXG5taW51dGVcbm1pcmFjbGVcbm1pcnJvclxubWlzZXJ5XG5taXNzXG5taXN0YWtlXG5taXhcbm1peGVkXG5taXh0dXJlXG5tb2JpbGVcbm1vZGVsXG5tb2RpZnlcbm1vbVxubW9tZW50XG5tb25pdG9yXG5tb25rZXlcbm1vbnN0ZXJcbm1vbnRoXG5tb29uXG5tb3JhbFxubW9yZVxubW9ybmluZ1xubW9zcXVpdG9cbm1vdGhlclxubW90aW9uXG5tb3RvclxubW91bnRhaW5cbm1vdXNlXG5tb3ZlXG5tb3ZpZVxubXVjaFxubXVmZmluXG5tdWxlXG5tdWx0aXBseVxubXVzY2xlXG5tdXNldW1cbm11c2hyb29tXG5tdXNpY1xubXVzdFxubXV0dWFsXG5teXNlbGZcbm15c3Rlcnlcbm15dGhcbm5haXZlXG5uYW1lXG5uYXBraW5cbm5hcnJvd1xubmFzdHlcbm5hdGlvblxubmF0dXJlXG5uZWFyXG5uZWNrXG5uZWVkXG5uZWdhdGl2ZVxubmVnbGVjdFxubmVpdGhlclxubmVwaGV3XG5uZXJ2ZVxubmVzdFxubmV0XG5uZXR3b3JrXG5uZXV0cmFsXG5uZXZlclxubmV3c1xubmV4dFxubmljZVxubmlnaHRcbm5vYmxlXG5ub2lzZVxubm9taW5lZVxubm9vZGxlXG5ub3JtYWxcbm5vcnRoXG5ub3NlXG5ub3RhYmxlXG5ub3RlXG5ub3RoaW5nXG5ub3RpY2Vcbm5vdmVsXG5ub3dcbm51Y2xlYXJcbm51bWJlclxubnVyc2Vcbm51dFxub2FrXG5vYmV5XG5vYmplY3Rcbm9ibGlnZVxub2JzY3VyZVxub2JzZXJ2ZVxub2J0YWluXG5vYnZpb3VzXG5vY2N1clxub2NlYW5cbm9jdG9iZXJcbm9kb3Jcbm9mZlxub2ZmZXJcbm9mZmljZVxub2Z0ZW5cbm9pbFxub2theVxub2xkXG5vbGl2ZVxub2x5bXBpY1xub21pdFxub25jZVxub25lXG5vbmlvblxub25saW5lXG5vbmx5XG5vcGVuXG5vcGVyYVxub3Bpbmlvblxub3Bwb3NlXG5vcHRpb25cbm9yYW5nZVxub3JiaXRcbm9yY2hhcmRcbm9yZGVyXG5vcmRpbmFyeVxub3JnYW5cbm9yaWVudFxub3JpZ2luYWxcbm9ycGhhblxub3N0cmljaFxub3RoZXJcbm91dGRvb3Jcbm91dGVyXG5vdXRwdXRcbm91dHNpZGVcbm92YWxcbm92ZW5cbm92ZXJcbm93blxub3duZXJcbm94eWdlblxub3lzdGVyXG5vem9uZVxucGFjdFxucGFkZGxlXG5wYWdlXG5wYWlyXG5wYWxhY2VcbnBhbG1cbnBhbmRhXG5wYW5lbFxucGFuaWNcbnBhbnRoZXJcbnBhcGVyXG5wYXJhZGVcbnBhcmVudFxucGFya1xucGFycm90XG5wYXJ0eVxucGFzc1xucGF0Y2hcbnBhdGhcbnBhdGllbnRcbnBhdHJvbFxucGF0dGVyblxucGF1c2VcbnBhdmVcbnBheW1lbnRcbnBlYWNlXG5wZWFudXRcbnBlYXJcbnBlYXNhbnRcbnBlbGljYW5cbnBlblxucGVuYWx0eVxucGVuY2lsXG5wZW9wbGVcbnBlcHBlclxucGVyZmVjdFxucGVybWl0XG5wZXJzb25cbnBldFxucGhvbmVcbnBob3RvXG5waHJhc2VcbnBoeXNpY2FsXG5waWFub1xucGljbmljXG5waWN0dXJlXG5waWVjZVxucGlnXG5waWdlb25cbnBpbGxcbnBpbG90XG5waW5rXG5waW9uZWVyXG5waXBlXG5waXN0b2xcbnBpdGNoXG5waXp6YVxucGxhY2VcbnBsYW5ldFxucGxhc3RpY1xucGxhdGVcbnBsYXlcbnBsZWFzZVxucGxlZGdlXG5wbHVja1xucGx1Z1xucGx1bmdlXG5wb2VtXG5wb2V0XG5wb2ludFxucG9sYXJcbnBvbGVcbnBvbGljZVxucG9uZFxucG9ueVxucG9vbFxucG9wdWxhclxucG9ydGlvblxucG9zaXRpb25cbnBvc3NpYmxlXG5wb3N0XG5wb3RhdG9cbnBvdHRlcnlcbnBvdmVydHlcbnBvd2RlclxucG93ZXJcbnByYWN0aWNlXG5wcmFpc2VcbnByZWRpY3RcbnByZWZlclxucHJlcGFyZVxucHJlc2VudFxucHJldHR5XG5wcmV2ZW50XG5wcmljZVxucHJpZGVcbnByaW1hcnlcbnByaW50XG5wcmlvcml0eVxucHJpc29uXG5wcml2YXRlXG5wcml6ZVxucHJvYmxlbVxucHJvY2Vzc1xucHJvZHVjZVxucHJvZml0XG5wcm9ncmFtXG5wcm9qZWN0XG5wcm9tb3RlXG5wcm9vZlxucHJvcGVydHlcbnByb3NwZXJcbnByb3RlY3RcbnByb3VkXG5wcm92aWRlXG5wdWJsaWNcbnB1ZGRpbmdcbnB1bGxcbnB1bHBcbnB1bHNlXG5wdW1wa2luXG5wdW5jaFxucHVwaWxcbnB1cHB5XG5wdXJjaGFzZVxucHVyaXR5XG5wdXJwb3NlXG5wdXJzZVxucHVzaFxucHV0XG5wdXp6bGVcbnB5cmFtaWRcbnF1YWxpdHlcbnF1YW50dW1cbnF1YXJ0ZXJcbnF1ZXN0aW9uXG5xdWlja1xucXVpdFxucXVpelxucXVvdGVcbnJhYmJpdFxucmFjY29vblxucmFjZVxucmFja1xucmFkYXJcbnJhZGlvXG5yYWlsXG5yYWluXG5yYWlzZVxucmFsbHlcbnJhbXBcbnJhbmNoXG5yYW5kb21cbnJhbmdlXG5yYXBpZFxucmFyZVxucmF0ZVxucmF0aGVyXG5yYXZlblxucmF3XG5yYXpvclxucmVhZHlcbnJlYWxcbnJlYXNvblxucmViZWxcbnJlYnVpbGRcbnJlY2FsbFxucmVjZWl2ZVxucmVjaXBlXG5yZWNvcmRcbnJlY3ljbGVcbnJlZHVjZVxucmVmbGVjdFxucmVmb3JtXG5yZWZ1c2VcbnJlZ2lvblxucmVncmV0XG5yZWd1bGFyXG5yZWplY3RcbnJlbGF4XG5yZWxlYXNlXG5yZWxpZWZcbnJlbHlcbnJlbWFpblxucmVtZW1iZXJcbnJlbWluZFxucmVtb3ZlXG5yZW5kZXJcbnJlbmV3XG5yZW50XG5yZW9wZW5cbnJlcGFpclxucmVwZWF0XG5yZXBsYWNlXG5yZXBvcnRcbnJlcXVpcmVcbnJlc2N1ZVxucmVzZW1ibGVcbnJlc2lzdFxucmVzb3VyY2VcbnJlc3BvbnNlXG5yZXN1bHRcbnJldGlyZVxucmV0cmVhdFxucmV0dXJuXG5yZXVuaW9uXG5yZXZlYWxcbnJldmlld1xucmV3YXJkXG5yaHl0aG1cbnJpYlxucmliYm9uXG5yaWNlXG5yaWNoXG5yaWRlXG5yaWRnZVxucmlmbGVcbnJpZ2h0XG5yaWdpZFxucmluZ1xucmlvdFxucmlwcGxlXG5yaXNrXG5yaXR1YWxcbnJpdmFsXG5yaXZlclxucm9hZFxucm9hc3RcbnJvYm90XG5yb2J1c3RcbnJvY2tldFxucm9tYW5jZVxucm9vZlxucm9va2llXG5yb29tXG5yb3NlXG5yb3RhdGVcbnJvdWdoXG5yb3VuZFxucm91dGVcbnJveWFsXG5ydWJiZXJcbnJ1ZGVcbnJ1Z1xucnVsZVxucnVuXG5ydW53YXlcbnJ1cmFsXG5zYWRcbnNhZGRsZVxuc2FkbmVzc1xuc2FmZVxuc2FpbFxuc2FsYWRcbnNhbG1vblxuc2Fsb25cbnNhbHRcbnNhbHV0ZVxuc2FtZVxuc2FtcGxlXG5zYW5kXG5zYXRpc2Z5XG5zYXRvc2hpXG5zYXVjZVxuc2F1c2FnZVxuc2F2ZVxuc2F5XG5zY2FsZVxuc2Nhblxuc2NhcmVcbnNjYXR0ZXJcbnNjZW5lXG5zY2hlbWVcbnNjaG9vbFxuc2NpZW5jZVxuc2Npc3NvcnNcbnNjb3JwaW9uXG5zY291dFxuc2NyYXBcbnNjcmVlblxuc2NyaXB0XG5zY3J1Ylxuc2VhXG5zZWFyY2hcbnNlYXNvblxuc2VhdFxuc2Vjb25kXG5zZWNyZXRcbnNlY3Rpb25cbnNlY3VyaXR5XG5zZWVkXG5zZWVrXG5zZWdtZW50XG5zZWxlY3RcbnNlbGxcbnNlbWluYXJcbnNlbmlvclxuc2Vuc2VcbnNlbnRlbmNlXG5zZXJpZXNcbnNlcnZpY2VcbnNlc3Npb25cbnNldHRsZVxuc2V0dXBcbnNldmVuXG5zaGFkb3dcbnNoYWZ0XG5zaGFsbG93XG5zaGFyZVxuc2hlZFxuc2hlbGxcbnNoZXJpZmZcbnNoaWVsZFxuc2hpZnRcbnNoaW5lXG5zaGlwXG5zaGl2ZXJcbnNob2NrXG5zaG9lXG5zaG9vdFxuc2hvcFxuc2hvcnRcbnNob3VsZGVyXG5zaG92ZVxuc2hyaW1wXG5zaHJ1Z1xuc2h1ZmZsZVxuc2h5XG5zaWJsaW5nXG5zaWNrXG5zaWRlXG5zaWVnZVxuc2lnaHRcbnNpZ25cbnNpbGVudFxuc2lsa1xuc2lsbHlcbnNpbHZlclxuc2ltaWxhclxuc2ltcGxlXG5zaW5jZVxuc2luZ1xuc2lyZW5cbnNpc3Rlclxuc2l0dWF0ZVxuc2l4XG5zaXplXG5za2F0ZVxuc2tldGNoXG5za2lcbnNraWxsXG5za2luXG5za2lydFxuc2t1bGxcbnNsYWJcbnNsYW1cbnNsZWVwXG5zbGVuZGVyXG5zbGljZVxuc2xpZGVcbnNsaWdodFxuc2xpbVxuc2xvZ2FuXG5zbG90XG5zbG93XG5zbHVzaFxuc21hbGxcbnNtYXJ0XG5zbWlsZVxuc21va2VcbnNtb290aFxuc25hY2tcbnNuYWtlXG5zbmFwXG5zbmlmZlxuc25vd1xuc29hcFxuc29jY2VyXG5zb2NpYWxcbnNvY2tcbnNvZGFcbnNvZnRcbnNvbGFyXG5zb2xkaWVyXG5zb2xpZFxuc29sdXRpb25cbnNvbHZlXG5zb21lb25lXG5zb25nXG5zb29uXG5zb3JyeVxuc29ydFxuc291bFxuc291bmRcbnNvdXBcbnNvdXJjZVxuc291dGhcbnNwYWNlXG5zcGFyZVxuc3BhdGlhbFxuc3Bhd25cbnNwZWFrXG5zcGVjaWFsXG5zcGVlZFxuc3BlbGxcbnNwZW5kXG5zcGhlcmVcbnNwaWNlXG5zcGlkZXJcbnNwaWtlXG5zcGluXG5zcGlyaXRcbnNwbGl0XG5zcG9pbFxuc3BvbnNvclxuc3Bvb25cbnNwb3J0XG5zcG90XG5zcHJheVxuc3ByZWFkXG5zcHJpbmdcbnNweVxuc3F1YXJlXG5zcXVlZXplXG5zcXVpcnJlbFxuc3RhYmxlXG5zdGFkaXVtXG5zdGFmZlxuc3RhZ2VcbnN0YWlyc1xuc3RhbXBcbnN0YW5kXG5zdGFydFxuc3RhdGVcbnN0YXlcbnN0ZWFrXG5zdGVlbFxuc3RlbVxuc3RlcFxuc3RlcmVvXG5zdGlja1xuc3RpbGxcbnN0aW5nXG5zdG9ja1xuc3RvbWFjaFxuc3RvbmVcbnN0b29sXG5zdG9yeVxuc3RvdmVcbnN0cmF0ZWd5XG5zdHJlZXRcbnN0cmlrZVxuc3Ryb25nXG5zdHJ1Z2dsZVxuc3R1ZGVudFxuc3R1ZmZcbnN0dW1ibGVcbnN0eWxlXG5zdWJqZWN0XG5zdWJtaXRcbnN1YndheVxuc3VjY2Vzc1xuc3VjaFxuc3VkZGVuXG5zdWZmZXJcbnN1Z2FyXG5zdWdnZXN0XG5zdWl0XG5zdW1tZXJcbnN1blxuc3VubnlcbnN1bnNldFxuc3VwZXJcbnN1cHBseVxuc3VwcmVtZVxuc3VyZVxuc3VyZmFjZVxuc3VyZ2VcbnN1cnByaXNlXG5zdXJyb3VuZFxuc3VydmV5XG5zdXNwZWN0XG5zdXN0YWluXG5zd2FsbG93XG5zd2FtcFxuc3dhcFxuc3dhcm1cbnN3ZWFyXG5zd2VldFxuc3dpZnRcbnN3aW1cbnN3aW5nXG5zd2l0Y2hcbnN3b3JkXG5zeW1ib2xcbnN5bXB0b21cbnN5cnVwXG5zeXN0ZW1cbnRhYmxlXG50YWNrbGVcbnRhZ1xudGFpbFxudGFsZW50XG50YWxrXG50YW5rXG50YXBlXG50YXJnZXRcbnRhc2tcbnRhc3RlXG50YXR0b29cbnRheGlcbnRlYWNoXG50ZWFtXG50ZWxsXG50ZW5cbnRlbmFudFxudGVubmlzXG50ZW50XG50ZXJtXG50ZXN0XG50ZXh0XG50aGFua1xudGhhdFxudGhlbWVcbnRoZW5cbnRoZW9yeVxudGhlcmVcbnRoZXlcbnRoaW5nXG50aGlzXG50aG91Z2h0XG50aHJlZVxudGhyaXZlXG50aHJvd1xudGh1bWJcbnRodW5kZXJcbnRpY2tldFxudGlkZVxudGlnZXJcbnRpbHRcbnRpbWJlclxudGltZVxudGlueVxudGlwXG50aXJlZFxudGlzc3VlXG50aXRsZVxudG9hc3RcbnRvYmFjY29cbnRvZGF5XG50b2RkbGVyXG50b2VcbnRvZ2V0aGVyXG50b2lsZXRcbnRva2VuXG50b21hdG9cbnRvbW9ycm93XG50b25lXG50b25ndWVcbnRvbmlnaHRcbnRvb2xcbnRvb3RoXG50b3BcbnRvcGljXG50b3BwbGVcbnRvcmNoXG50b3JuYWRvXG50b3J0b2lzZVxudG9zc1xudG90YWxcbnRvdXJpc3RcbnRvd2FyZFxudG93ZXJcbnRvd25cbnRveVxudHJhY2tcbnRyYWRlXG50cmFmZmljXG50cmFnaWNcbnRyYWluXG50cmFuc2ZlclxudHJhcFxudHJhc2hcbnRyYXZlbFxudHJheVxudHJlYXRcbnRyZWVcbnRyZW5kXG50cmlhbFxudHJpYmVcbnRyaWNrXG50cmlnZ2VyXG50cmltXG50cmlwXG50cm9waHlcbnRyb3VibGVcbnRydWNrXG50cnVlXG50cnVseVxudHJ1bXBldFxudHJ1c3RcbnRydXRoXG50cnlcbnR1YmVcbnR1aXRpb25cbnR1bWJsZVxudHVuYVxudHVubmVsXG50dXJrZXlcbnR1cm5cbnR1cnRsZVxudHdlbHZlXG50d2VudHlcbnR3aWNlXG50d2luXG50d2lzdFxudHdvXG50eXBlXG50eXBpY2FsXG51Z2x5XG51bWJyZWxsYVxudW5hYmxlXG51bmF3YXJlXG51bmNsZVxudW5jb3ZlclxudW5kZXJcbnVuZG9cbnVuZmFpclxudW5mb2xkXG51bmhhcHB5XG51bmlmb3JtXG51bmlxdWVcbnVuaXRcbnVuaXZlcnNlXG51bmtub3duXG51bmxvY2tcbnVudGlsXG51bnVzdWFsXG51bnZlaWxcbnVwZGF0ZVxudXBncmFkZVxudXBob2xkXG51cG9uXG51cHBlclxudXBzZXRcbnVyYmFuXG51cmdlXG51c2FnZVxudXNlXG51c2VkXG51c2VmdWxcbnVzZWxlc3NcbnVzdWFsXG51dGlsaXR5XG52YWNhbnRcbnZhY3V1bVxudmFndWVcbnZhbGlkXG52YWxsZXlcbnZhbHZlXG52YW5cbnZhbmlzaFxudmFwb3JcbnZhcmlvdXNcbnZhc3RcbnZhdWx0XG52ZWhpY2xlXG52ZWx2ZXRcbnZlbmRvclxudmVudHVyZVxudmVudWVcbnZlcmJcbnZlcmlmeVxudmVyc2lvblxudmVyeVxudmVzc2VsXG52ZXRlcmFuXG52aWFibGVcbnZpYnJhbnRcbnZpY2lvdXNcbnZpY3RvcnlcbnZpZGVvXG52aWV3XG52aWxsYWdlXG52aW50YWdlXG52aW9saW5cbnZpcnR1YWxcbnZpcnVzXG52aXNhXG52aXNpdFxudmlzdWFsXG52aXRhbFxudml2aWRcbnZvY2FsXG52b2ljZVxudm9pZFxudm9sY2Fub1xudm9sdW1lXG52b3RlXG52b3lhZ2VcbndhZ2VcbndhZ29uXG53YWl0XG53YWxrXG53YWxsXG53YWxudXRcbndhbnRcbndhcmZhcmVcbndhcm1cbndhcnJpb3Jcbndhc2hcbndhc3Bcbndhc3RlXG53YXRlclxud2F2ZVxud2F5XG53ZWFsdGhcbndlYXBvblxud2Vhclxud2Vhc2VsXG53ZWF0aGVyXG53ZWJcbndlZGRpbmdcbndlZWtlbmRcbndlaXJkXG53ZWxjb21lXG53ZXN0XG53ZXRcbndoYWxlXG53aGF0XG53aGVhdFxud2hlZWxcbndoZW5cbndoZXJlXG53aGlwXG53aGlzcGVyXG53aWRlXG53aWR0aFxud2lmZVxud2lsZFxud2lsbFxud2luXG53aW5kb3dcbndpbmVcbndpbmdcbndpbmtcbndpbm5lclxud2ludGVyXG53aXJlXG53aXNkb21cbndpc2Vcbndpc2hcbndpdG5lc3NcbndvbGZcbndvbWFuXG53b25kZXJcbndvb2Rcbndvb2xcbndvcmRcbndvcmtcbndvcmxkXG53b3JyeVxud29ydGhcbndyYXBcbndyZWNrXG53cmVzdGxlXG53cmlzdFxud3JpdGVcbndyb25nXG55YXJkXG55ZWFyXG55ZWxsb3dcbnlvdVxueW91bmdcbnlvdXRoXG56ZWJyYVxuemVyb1xuem9uZVxuem9vYC5zcGxpdChgXG5gKTtcbnZhciBkZSA9IHt9O1xuZnVuY3Rpb24gUHIodCkge1xuICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKHQpIHx8IHQgPCAwKVxuICAgIHRocm93IG5ldyBFcnJvcihgV3JvbmcgcG9zaXRpdmUgaW50ZWdlcjogJHt0fWApO1xufVxuZnVuY3Rpb24gTHModCkge1xuICBpZiAodHlwZW9mIHQgIT0gXCJib29sZWFuXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBib29sZWFuLCBub3QgJHt0fWApO1xufVxuZnVuY3Rpb24gWWUodCwgLi4uZSkge1xuICBpZiAoISh0IGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgVWludDhBcnJheVwiKTtcbiAgaWYgKGUubGVuZ3RoID4gMCAmJiAhZS5pbmNsdWRlcyh0Lmxlbmd0aCkpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBVaW50OEFycmF5IG9mIGxlbmd0aCAke2V9LCBub3Qgb2YgbGVuZ3RoPSR7dC5sZW5ndGh9YCk7XG59XG5mdW5jdGlvbiAkcyh0KSB7XG4gIGlmICh0eXBlb2YgdCAhPSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIHQuY3JlYXRlICE9IFwiZnVuY3Rpb25cIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJIYXNoIHNob3VsZCBiZSB3cmFwcGVkIGJ5IHV0aWxzLndyYXBDb25zdHJ1Y3RvclwiKTtcbiAgUHIodC5vdXRwdXRMZW4pLCBQcih0LmJsb2NrTGVuKTtcbn1cbmZ1bmN0aW9uIHFzKHQsIGUgPSAhMCkge1xuICBpZiAodC5kZXN0cm95ZWQpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSGFzaCBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWRcIik7XG4gIGlmIChlICYmIHQuZmluaXNoZWQpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSGFzaCNkaWdlc3QoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZFwiKTtcbn1cbmZ1bmN0aW9uIE5zKHQsIGUpIHtcbiAgWWUodCk7XG4gIGNvbnN0IHIgPSBlLm91dHB1dExlbjtcbiAgaWYgKHQubGVuZ3RoIDwgcilcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGRpZ2VzdEludG8oKSBleHBlY3RzIG91dHB1dCBidWZmZXIgb2YgbGVuZ3RoIGF0IGxlYXN0ICR7cn1gKTtcbn1cbmNvbnN0IFFlID0ge1xuICBudW1iZXI6IFByLFxuICBib29sOiBMcyxcbiAgYnl0ZXM6IFllLFxuICBoYXNoOiAkcyxcbiAgZXhpc3RzOiBxcyxcbiAgb3V0cHV0OiBOc1xufSwgRHUgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgX19wcm90b19fOiBudWxsLFxuICBudW1iZXI6IFByLFxuICBib29sOiBMcyxcbiAgYnl0ZXM6IFllLFxuICBoYXNoOiAkcyxcbiAgZXhpc3RzOiBxcyxcbiAgb3V0cHV0OiBOcyxcbiAgZGVmYXVsdDogUWVcbn0sIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KSksIHp1ID0gLyogQF9fUFVSRV9fICovIEV0KER1KTtcbnZhciB4dCA9IHt9LCBuZSA9IHt9O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KG5lLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG5uZS5vdXRwdXQgPSBuZS5leGlzdHMgPSBuZS5oYXNoID0gbmUuYnl0ZXMgPSBuZS5ib29sID0gbmUubnVtYmVyID0gdm9pZCAwO1xuZnVuY3Rpb24gQnIodCkge1xuICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKHQpIHx8IHQgPCAwKVxuICAgIHRocm93IG5ldyBFcnJvcihgV3JvbmcgcG9zaXRpdmUgaW50ZWdlcjogJHt0fWApO1xufVxubmUubnVtYmVyID0gQnI7XG5mdW5jdGlvbiBVcyh0KSB7XG4gIGlmICh0eXBlb2YgdCAhPSBcImJvb2xlYW5cIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGJvb2xlYW4sIG5vdCAke3R9YCk7XG59XG5uZS5ib29sID0gVXM7XG5mdW5jdGlvbiBlaSh0LCAuLi5lKSB7XG4gIGlmICghKHQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBVaW50OEFycmF5XCIpO1xuICBpZiAoZS5sZW5ndGggPiAwICYmICFlLmluY2x1ZGVzKHQubGVuZ3RoKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIFVpbnQ4QXJyYXkgb2YgbGVuZ3RoICR7ZX0sIG5vdCBvZiBsZW5ndGg9JHt0Lmxlbmd0aH1gKTtcbn1cbm5lLmJ5dGVzID0gZWk7XG5mdW5jdGlvbiBqcyh0KSB7XG4gIGlmICh0eXBlb2YgdCAhPSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIHQuY3JlYXRlICE9IFwiZnVuY3Rpb25cIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJIYXNoIHNob3VsZCBiZSB3cmFwcGVkIGJ5IHV0aWxzLndyYXBDb25zdHJ1Y3RvclwiKTtcbiAgQnIodC5vdXRwdXRMZW4pLCBCcih0LmJsb2NrTGVuKTtcbn1cbm5lLmhhc2ggPSBqcztcbmZ1bmN0aW9uIEhzKHQsIGUgPSAhMCkge1xuICBpZiAodC5kZXN0cm95ZWQpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSGFzaCBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWRcIik7XG4gIGlmIChlICYmIHQuZmluaXNoZWQpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSGFzaCNkaWdlc3QoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZFwiKTtcbn1cbm5lLmV4aXN0cyA9IEhzO1xuZnVuY3Rpb24gTXModCwgZSkge1xuICBlaSh0KTtcbiAgY29uc3QgciA9IGUub3V0cHV0TGVuO1xuICBpZiAodC5sZW5ndGggPCByKVxuICAgIHRocm93IG5ldyBFcnJvcihgZGlnZXN0SW50bygpIGV4cGVjdHMgb3V0cHV0IGJ1ZmZlciBvZiBsZW5ndGggYXQgbGVhc3QgJHtyfWApO1xufVxubmUub3V0cHV0ID0gTXM7XG5jb25zdCBGdSA9IHtcbiAgbnVtYmVyOiBCcixcbiAgYm9vbDogVXMsXG4gIGJ5dGVzOiBlaSxcbiAgaGFzaDoganMsXG4gIGV4aXN0czogSHMsXG4gIG91dHB1dDogTXNcbn07XG5uZS5kZWZhdWx0ID0gRnU7XG52YXIgRHMgPSB7fSwgdGkgPSB7fTtcbmNvbnN0IFNyID0gdHlwZW9mIGdsb2JhbFRoaXMgPT0gXCJvYmplY3RcIiAmJiBcImNyeXB0b1wiIGluIGdsb2JhbFRoaXMgPyBnbG9iYWxUaGlzLmNyeXB0byA6IHZvaWQgMCwgS3UgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgX19wcm90b19fOiBudWxsLFxuICBjcnlwdG86IFNyXG59LCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSkpLCBXdSA9IC8qIEBfX1BVUkVfXyAqLyBFdChLdSk7XG4oZnVuY3Rpb24odCkge1xuICAvKiEgbm9ibGUtaGFzaGVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIHQucmFuZG9tQnl0ZXMgPSB0LndyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzID0gdC53cmFwQ29uc3RydWN0b3JXaXRoT3B0cyA9IHQud3JhcENvbnN0cnVjdG9yID0gdC5jaGVja09wdHMgPSB0Lkhhc2ggPSB0LmNvbmNhdEJ5dGVzID0gdC50b0J5dGVzID0gdC51dGY4VG9CeXRlcyA9IHQuYXN5bmNMb29wID0gdC5uZXh0VGljayA9IHQuaGV4VG9CeXRlcyA9IHQuYnl0ZXNUb0hleCA9IHQuaXNMRSA9IHQucm90ciA9IHQuY3JlYXRlVmlldyA9IHQudTMyID0gdC51OCA9IHZvaWQgMDtcbiAgY29uc3QgZSA9IFd1LCByID0gKHcpID0+IHcgaW5zdGFuY2VvZiBVaW50OEFycmF5LCBuID0gKHcpID0+IG5ldyBVaW50OEFycmF5KHcuYnVmZmVyLCB3LmJ5dGVPZmZzZXQsIHcuYnl0ZUxlbmd0aCk7XG4gIHQudTggPSBuO1xuICBjb25zdCBpID0gKHcpID0+IG5ldyBVaW50MzJBcnJheSh3LmJ1ZmZlciwgdy5ieXRlT2Zmc2V0LCBNYXRoLmZsb29yKHcuYnl0ZUxlbmd0aCAvIDQpKTtcbiAgdC51MzIgPSBpO1xuICBjb25zdCBzID0gKHcpID0+IG5ldyBEYXRhVmlldyh3LmJ1ZmZlciwgdy5ieXRlT2Zmc2V0LCB3LmJ5dGVMZW5ndGgpO1xuICB0LmNyZWF0ZVZpZXcgPSBzO1xuICBjb25zdCBvID0gKHcsIHgpID0+IHcgPDwgMzIgLSB4IHwgdyA+Pj4geDtcbiAgaWYgKHQucm90ciA9IG8sIHQuaXNMRSA9IG5ldyBVaW50OEFycmF5KG5ldyBVaW50MzJBcnJheShbMjg3NDU0MDIwXSkuYnVmZmVyKVswXSA9PT0gNjgsICF0LmlzTEUpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm9uIGxpdHRsZS1lbmRpYW4gaGFyZHdhcmUgaXMgbm90IHN1cHBvcnRlZFwiKTtcbiAgY29uc3QgYSA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAodywgeCkgPT4geC50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpKTtcbiAgZnVuY3Rpb24gYyh3KSB7XG4gICAgaWYgKCFyKHcpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVWludDhBcnJheSBleHBlY3RlZFwiKTtcbiAgICBsZXQgeCA9IFwiXCI7XG4gICAgZm9yIChsZXQgQSA9IDA7IEEgPCB3Lmxlbmd0aDsgQSsrKVxuICAgICAgeCArPSBhW3dbQV1dO1xuICAgIHJldHVybiB4O1xuICB9XG4gIHQuYnl0ZXNUb0hleCA9IGM7XG4gIGZ1bmN0aW9uIGwodykge1xuICAgIGlmICh0eXBlb2YgdyAhPSBcInN0cmluZ1wiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IFwiICsgdHlwZW9mIHcpO1xuICAgIGNvbnN0IHggPSB3Lmxlbmd0aDtcbiAgICBpZiAoeCAlIDIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwYWRkZWQgaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IHVucGFkZGVkIGhleCBvZiBsZW5ndGggXCIgKyB4KTtcbiAgICBjb25zdCBBID0gbmV3IFVpbnQ4QXJyYXkoeCAvIDIpO1xuICAgIGZvciAobGV0IEIgPSAwOyBCIDwgQS5sZW5ndGg7IEIrKykge1xuICAgICAgY29uc3QgTCA9IEIgKiAyLCBQID0gdy5zbGljZShMLCBMICsgMiksIEYgPSBOdW1iZXIucGFyc2VJbnQoUCwgMTYpO1xuICAgICAgaWYgKE51bWJlci5pc05hTihGKSB8fCBGIDwgMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBieXRlIHNlcXVlbmNlXCIpO1xuICAgICAgQVtCXSA9IEY7XG4gICAgfVxuICAgIHJldHVybiBBO1xuICB9XG4gIHQuaGV4VG9CeXRlcyA9IGw7XG4gIGNvbnN0IGYgPSBhc3luYyAoKSA9PiB7XG4gIH07XG4gIHQubmV4dFRpY2sgPSBmO1xuICBhc3luYyBmdW5jdGlvbiB1KHcsIHgsIEEpIHtcbiAgICBsZXQgQiA9IERhdGUubm93KCk7XG4gICAgZm9yIChsZXQgTCA9IDA7IEwgPCB3OyBMKyspIHtcbiAgICAgIEEoTCk7XG4gICAgICBjb25zdCBQID0gRGF0ZS5ub3coKSAtIEI7XG4gICAgICBQID49IDAgJiYgUCA8IHggfHwgKGF3YWl0ICgwLCB0Lm5leHRUaWNrKSgpLCBCICs9IFApO1xuICAgIH1cbiAgfVxuICB0LmFzeW5jTG9vcCA9IHU7XG4gIGZ1bmN0aW9uIGgodykge1xuICAgIGlmICh0eXBlb2YgdyAhPSBcInN0cmluZ1wiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1dGY4VG9CeXRlcyBleHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiB3fWApO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUodykpO1xuICB9XG4gIHQudXRmOFRvQnl0ZXMgPSBoO1xuICBmdW5jdGlvbiBkKHcpIHtcbiAgICBpZiAodHlwZW9mIHcgPT0gXCJzdHJpbmdcIiAmJiAodyA9IGgodykpLCAhcih3KSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgVWludDhBcnJheSwgZ290ICR7dHlwZW9mIHd9YCk7XG4gICAgcmV0dXJuIHc7XG4gIH1cbiAgdC50b0J5dGVzID0gZDtcbiAgZnVuY3Rpb24gcCguLi53KSB7XG4gICAgY29uc3QgeCA9IG5ldyBVaW50OEFycmF5KHcucmVkdWNlKChCLCBMKSA9PiBCICsgTC5sZW5ndGgsIDApKTtcbiAgICBsZXQgQSA9IDA7XG4gICAgcmV0dXJuIHcuZm9yRWFjaCgoQikgPT4ge1xuICAgICAgaWYgKCFyKEIpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVaW50OEFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgeC5zZXQoQiwgQSksIEEgKz0gQi5sZW5ndGg7XG4gICAgfSksIHg7XG4gIH1cbiAgdC5jb25jYXRCeXRlcyA9IHA7XG4gIGNsYXNzIHkge1xuICAgIGNsb25lKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Nsb25lSW50bygpO1xuICAgIH1cbiAgfVxuICB0Lkhhc2ggPSB5O1xuICBjb25zdCBnID0gKHcpID0+IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh3KSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIiAmJiB3LmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG4gIGZ1bmN0aW9uIHYodywgeCkge1xuICAgIGlmICh4ICE9PSB2b2lkIDAgJiYgKHR5cGVvZiB4ICE9IFwib2JqZWN0XCIgfHwgIWcoeCkpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT3B0aW9ucyBzaG91bGQgYmUgb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih3LCB4KTtcbiAgfVxuICB0LmNoZWNrT3B0cyA9IHY7XG4gIGZ1bmN0aW9uIF8odykge1xuICAgIGNvbnN0IHggPSAoQikgPT4gdygpLnVwZGF0ZShkKEIpKS5kaWdlc3QoKSwgQSA9IHcoKTtcbiAgICByZXR1cm4geC5vdXRwdXRMZW4gPSBBLm91dHB1dExlbiwgeC5ibG9ja0xlbiA9IEEuYmxvY2tMZW4sIHguY3JlYXRlID0gKCkgPT4gdygpLCB4O1xuICB9XG4gIHQud3JhcENvbnN0cnVjdG9yID0gXztcbiAgZnVuY3Rpb24gbSh3KSB7XG4gICAgY29uc3QgeCA9IChCLCBMKSA9PiB3KEwpLnVwZGF0ZShkKEIpKS5kaWdlc3QoKSwgQSA9IHcoe30pO1xuICAgIHJldHVybiB4Lm91dHB1dExlbiA9IEEub3V0cHV0TGVuLCB4LmJsb2NrTGVuID0gQS5ibG9ja0xlbiwgeC5jcmVhdGUgPSAoQikgPT4gdyhCKSwgeDtcbiAgfVxuICB0LndyYXBDb25zdHJ1Y3RvcldpdGhPcHRzID0gbTtcbiAgZnVuY3Rpb24gQyh3KSB7XG4gICAgY29uc3QgeCA9IChCLCBMKSA9PiB3KEwpLnVwZGF0ZShkKEIpKS5kaWdlc3QoKSwgQSA9IHcoe30pO1xuICAgIHJldHVybiB4Lm91dHB1dExlbiA9IEEub3V0cHV0TGVuLCB4LmJsb2NrTGVuID0gQS5ibG9ja0xlbiwgeC5jcmVhdGUgPSAoQikgPT4gdyhCKSwgeDtcbiAgfVxuICB0LndyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzID0gQztcbiAgZnVuY3Rpb24gTyh3ID0gMzIpIHtcbiAgICBpZiAoZS5jcnlwdG8gJiYgdHlwZW9mIGUuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICByZXR1cm4gZS5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KHcpKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIG11c3QgYmUgZGVmaW5lZFwiKTtcbiAgfVxuICB0LnJhbmRvbUJ5dGVzID0gTztcbn0pKHRpKTtcbihmdW5jdGlvbih0KSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIHQuaG1hYyA9IHQuSE1BQyA9IHZvaWQgMDtcbiAgY29uc3QgZSA9IG5lLCByID0gdGk7XG4gIGNsYXNzIG4gZXh0ZW5kcyByLkhhc2gge1xuICAgIGNvbnN0cnVjdG9yKG8sIGEpIHtcbiAgICAgIHN1cGVyKCksIHRoaXMuZmluaXNoZWQgPSAhMSwgdGhpcy5kZXN0cm95ZWQgPSAhMSwgZS5kZWZhdWx0Lmhhc2gobyk7XG4gICAgICBjb25zdCBjID0gKDAsIHIudG9CeXRlcykoYSk7XG4gICAgICBpZiAodGhpcy5pSGFzaCA9IG8uY3JlYXRlKCksIHR5cGVvZiB0aGlzLmlIYXNoLnVwZGF0ZSAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIGluc3RhbmNlIG9mIGNsYXNzIHdoaWNoIGV4dGVuZHMgdXRpbHMuSGFzaFwiKTtcbiAgICAgIHRoaXMuYmxvY2tMZW4gPSB0aGlzLmlIYXNoLmJsb2NrTGVuLCB0aGlzLm91dHB1dExlbiA9IHRoaXMuaUhhc2gub3V0cHV0TGVuO1xuICAgICAgY29uc3QgbCA9IHRoaXMuYmxvY2tMZW4sIGYgPSBuZXcgVWludDhBcnJheShsKTtcbiAgICAgIGYuc2V0KGMubGVuZ3RoID4gbCA/IG8uY3JlYXRlKCkudXBkYXRlKGMpLmRpZ2VzdCgpIDogYyk7XG4gICAgICBmb3IgKGxldCB1ID0gMDsgdSA8IGYubGVuZ3RoOyB1KyspXG4gICAgICAgIGZbdV0gXj0gNTQ7XG4gICAgICB0aGlzLmlIYXNoLnVwZGF0ZShmKSwgdGhpcy5vSGFzaCA9IG8uY3JlYXRlKCk7XG4gICAgICBmb3IgKGxldCB1ID0gMDsgdSA8IGYubGVuZ3RoOyB1KyspXG4gICAgICAgIGZbdV0gXj0gMTA2O1xuICAgICAgdGhpcy5vSGFzaC51cGRhdGUoZiksIGYuZmlsbCgwKTtcbiAgICB9XG4gICAgdXBkYXRlKG8pIHtcbiAgICAgIHJldHVybiBlLmRlZmF1bHQuZXhpc3RzKHRoaXMpLCB0aGlzLmlIYXNoLnVwZGF0ZShvKSwgdGhpcztcbiAgICB9XG4gICAgZGlnZXN0SW50byhvKSB7XG4gICAgICBlLmRlZmF1bHQuZXhpc3RzKHRoaXMpLCBlLmRlZmF1bHQuYnl0ZXMobywgdGhpcy5vdXRwdXRMZW4pLCB0aGlzLmZpbmlzaGVkID0gITAsIHRoaXMuaUhhc2guZGlnZXN0SW50byhvKSwgdGhpcy5vSGFzaC51cGRhdGUobyksIHRoaXMub0hhc2guZGlnZXN0SW50byhvKSwgdGhpcy5kZXN0cm95KCk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgIGNvbnN0IG8gPSBuZXcgVWludDhBcnJheSh0aGlzLm9IYXNoLm91dHB1dExlbik7XG4gICAgICByZXR1cm4gdGhpcy5kaWdlc3RJbnRvKG8pLCBvO1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKG8pIHtcbiAgICAgIG8gfHwgKG8gPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSwge30pKTtcbiAgICAgIGNvbnN0IHsgb0hhc2g6IGEsIGlIYXNoOiBjLCBmaW5pc2hlZDogbCwgZGVzdHJveWVkOiBmLCBibG9ja0xlbjogdSwgb3V0cHV0TGVuOiBoIH0gPSB0aGlzO1xuICAgICAgcmV0dXJuIG8gPSBvLCBvLmZpbmlzaGVkID0gbCwgby5kZXN0cm95ZWQgPSBmLCBvLmJsb2NrTGVuID0gdSwgby5vdXRwdXRMZW4gPSBoLCBvLm9IYXNoID0gYS5fY2xvbmVJbnRvKG8ub0hhc2gpLCBvLmlIYXNoID0gYy5fY2xvbmVJbnRvKG8uaUhhc2gpLCBvO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgdGhpcy5kZXN0cm95ZWQgPSAhMCwgdGhpcy5vSGFzaC5kZXN0cm95KCksIHRoaXMuaUhhc2guZGVzdHJveSgpO1xuICAgIH1cbiAgfVxuICB0LkhNQUMgPSBuO1xuICBjb25zdCBpID0gKHMsIG8sIGEpID0+IG5ldyBuKHMsIG8pLnVwZGF0ZShhKS5kaWdlc3QoKTtcbiAgdC5obWFjID0gaSwgdC5obWFjLmNyZWF0ZSA9IChzLCBvKSA9PiBuZXcgbihzLCBvKTtcbn0pKERzKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh4dCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xueHQucGJrZGYyQXN5bmMgPSB4dC5wYmtkZjIgPSB2b2lkIDA7XG5jb25zdCBociA9IG5lLCBWdSA9IERzLCBidCA9IHRpO1xuZnVuY3Rpb24genModCwgZSwgciwgbikge1xuICBoci5kZWZhdWx0Lmhhc2godCk7XG4gIGNvbnN0IGkgPSAoMCwgYnQuY2hlY2tPcHRzKSh7IGRrTGVuOiAzMiwgYXN5bmNUaWNrOiAxMCB9LCBuKSwgeyBjOiBzLCBka0xlbjogbywgYXN5bmNUaWNrOiBhIH0gPSBpO1xuICBpZiAoaHIuZGVmYXVsdC5udW1iZXIocyksIGhyLmRlZmF1bHQubnVtYmVyKG8pLCBoci5kZWZhdWx0Lm51bWJlcihhKSwgcyA8IDEpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUEJLREYyOiBpdGVyYXRpb25zIChjKSBzaG91bGQgYmUgPj0gMVwiKTtcbiAgY29uc3QgYyA9ICgwLCBidC50b0J5dGVzKShlKSwgbCA9ICgwLCBidC50b0J5dGVzKShyKSwgZiA9IG5ldyBVaW50OEFycmF5KG8pLCB1ID0gVnUuaG1hYy5jcmVhdGUodCwgYyksIGggPSB1Ll9jbG9uZUludG8oKS51cGRhdGUobCk7XG4gIHJldHVybiB7IGM6IHMsIGRrTGVuOiBvLCBhc3luY1RpY2s6IGEsIERLOiBmLCBQUkY6IHUsIFBSRlNhbHQ6IGggfTtcbn1cbmZ1bmN0aW9uIEZzKHQsIGUsIHIsIG4sIGkpIHtcbiAgcmV0dXJuIHQuZGVzdHJveSgpLCBlLmRlc3Ryb3koKSwgbiAmJiBuLmRlc3Ryb3koKSwgaS5maWxsKDApLCByO1xufVxuZnVuY3Rpb24gR3UodCwgZSwgciwgbikge1xuICBjb25zdCB7IGM6IGksIGRrTGVuOiBzLCBESzogbywgUFJGOiBhLCBQUkZTYWx0OiBjIH0gPSB6cyh0LCBlLCByLCBuKTtcbiAgbGV0IGw7XG4gIGNvbnN0IGYgPSBuZXcgVWludDhBcnJheSg0KSwgdSA9ICgwLCBidC5jcmVhdGVWaWV3KShmKSwgaCA9IG5ldyBVaW50OEFycmF5KGEub3V0cHV0TGVuKTtcbiAgZm9yIChsZXQgZCA9IDEsIHAgPSAwOyBwIDwgczsgZCsrLCBwICs9IGEub3V0cHV0TGVuKSB7XG4gICAgY29uc3QgeSA9IG8uc3ViYXJyYXkocCwgcCArIGEub3V0cHV0TGVuKTtcbiAgICB1LnNldEludDMyKDAsIGQsICExKSwgKGwgPSBjLl9jbG9uZUludG8obCkpLnVwZGF0ZShmKS5kaWdlc3RJbnRvKGgpLCB5LnNldChoLnN1YmFycmF5KDAsIHkubGVuZ3RoKSk7XG4gICAgZm9yIChsZXQgZyA9IDE7IGcgPCBpOyBnKyspIHtcbiAgICAgIGEuX2Nsb25lSW50byhsKS51cGRhdGUoaCkuZGlnZXN0SW50byhoKTtcbiAgICAgIGZvciAobGV0IHYgPSAwOyB2IDwgeS5sZW5ndGg7IHYrKylcbiAgICAgICAgeVt2XSBePSBoW3ZdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gRnMoYSwgYywgbywgbCwgaCk7XG59XG54dC5wYmtkZjIgPSBHdTtcbmFzeW5jIGZ1bmN0aW9uIFp1KHQsIGUsIHIsIG4pIHtcbiAgY29uc3QgeyBjOiBpLCBka0xlbjogcywgYXN5bmNUaWNrOiBvLCBESzogYSwgUFJGOiBjLCBQUkZTYWx0OiBsIH0gPSB6cyh0LCBlLCByLCBuKTtcbiAgbGV0IGY7XG4gIGNvbnN0IHUgPSBuZXcgVWludDhBcnJheSg0KSwgaCA9ICgwLCBidC5jcmVhdGVWaWV3KSh1KSwgZCA9IG5ldyBVaW50OEFycmF5KGMub3V0cHV0TGVuKTtcbiAgZm9yIChsZXQgcCA9IDEsIHkgPSAwOyB5IDwgczsgcCsrLCB5ICs9IGMub3V0cHV0TGVuKSB7XG4gICAgY29uc3QgZyA9IGEuc3ViYXJyYXkoeSwgeSArIGMub3V0cHV0TGVuKTtcbiAgICBoLnNldEludDMyKDAsIHAsICExKSwgKGYgPSBsLl9jbG9uZUludG8oZikpLnVwZGF0ZSh1KS5kaWdlc3RJbnRvKGQpLCBnLnNldChkLnN1YmFycmF5KDAsIGcubGVuZ3RoKSksIGF3YWl0ICgwLCBidC5hc3luY0xvb3ApKGkgLSAxLCBvLCAodikgPT4ge1xuICAgICAgYy5fY2xvbmVJbnRvKGYpLnVwZGF0ZShkKS5kaWdlc3RJbnRvKGQpO1xuICAgICAgZm9yIChsZXQgXyA9IDA7IF8gPCBnLmxlbmd0aDsgXysrKVxuICAgICAgICBnW19dIF49IGRbX107XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIEZzKGMsIGwsIGEsIGYsIGQpO1xufVxueHQucGJrZGYyQXN5bmMgPSBadTtcbi8qISBub2JsZS1oYXNoZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmNvbnN0IHJpID0gKHQpID0+IHQgaW5zdGFuY2VvZiBVaW50OEFycmF5LCBZdSA9ICh0KSA9PiBuZXcgVWludDhBcnJheSh0LmJ1ZmZlciwgdC5ieXRlT2Zmc2V0LCB0LmJ5dGVMZW5ndGgpLCBKdSA9ICh0KSA9PiBuZXcgVWludDMyQXJyYXkodC5idWZmZXIsIHQuYnl0ZU9mZnNldCwgTWF0aC5mbG9vcih0LmJ5dGVMZW5ndGggLyA0KSksIGZ0ID0gKHQpID0+IG5ldyBEYXRhVmlldyh0LmJ1ZmZlciwgdC5ieXRlT2Zmc2V0LCB0LmJ5dGVMZW5ndGgpLCBFZSA9ICh0LCBlKSA9PiB0IDw8IDMyIC0gZSB8IHQgPj4+IGUsIEtzID0gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQzMkFycmF5KFsyODc0NTQwMjBdKS5idWZmZXIpWzBdID09PSA2ODtcbmlmICghS3MpXG4gIHRocm93IG5ldyBFcnJvcihcIk5vbiBsaXR0bGUtZW5kaWFuIGhhcmR3YXJlIGlzIG5vdCBzdXBwb3J0ZWRcIik7XG5jb25zdCBYdSA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAodCwgZSkgPT4gZS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpKTtcbmZ1bmN0aW9uIG5pKHQpIHtcbiAgaWYgKCFyaSh0KSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVaW50OEFycmF5IGV4cGVjdGVkXCIpO1xuICBsZXQgZSA9IFwiXCI7XG4gIGZvciAobGV0IHIgPSAwOyByIDwgdC5sZW5ndGg7IHIrKylcbiAgICBlICs9IFh1W3Rbcl1dO1xuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIFdzKHQpIHtcbiAgaWYgKHR5cGVvZiB0ICE9IFwic3RyaW5nXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IFwiICsgdHlwZW9mIHQpO1xuICBjb25zdCBlID0gdC5sZW5ndGg7XG4gIGlmIChlICUgMilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJwYWRkZWQgaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IHVucGFkZGVkIGhleCBvZiBsZW5ndGggXCIgKyBlKTtcbiAgY29uc3QgciA9IG5ldyBVaW50OEFycmF5KGUgLyAyKTtcbiAgZm9yIChsZXQgbiA9IDA7IG4gPCByLmxlbmd0aDsgbisrKSB7XG4gICAgY29uc3QgaSA9IG4gKiAyLCBzID0gdC5zbGljZShpLCBpICsgMiksIG8gPSBOdW1iZXIucGFyc2VJbnQocywgMTYpO1xuICAgIGlmIChOdW1iZXIuaXNOYU4obykgfHwgbyA8IDApXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGJ5dGUgc2VxdWVuY2VcIik7XG4gICAgcltuXSA9IG87XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5jb25zdCBWcyA9IGFzeW5jICgpID0+IHtcbn07XG5hc3luYyBmdW5jdGlvbiBRdSh0LCBlLCByKSB7XG4gIGxldCBuID0gRGF0ZS5ub3coKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0OyBpKyspIHtcbiAgICByKGkpO1xuICAgIGNvbnN0IHMgPSBEYXRlLm5vdygpIC0gbjtcbiAgICBzID49IDAgJiYgcyA8IGUgfHwgKGF3YWl0IFZzKCksIG4gKz0gcyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlpKHQpIHtcbiAgaWYgKHR5cGVvZiB0ICE9IFwic3RyaW5nXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKGB1dGY4VG9CeXRlcyBleHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiB0fWApO1xuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHQpKTtcbn1cbmZ1bmN0aW9uIE90KHQpIHtcbiAgaWYgKHR5cGVvZiB0ID09IFwic3RyaW5nXCIgJiYgKHQgPSBpaSh0KSksICFyaSh0KSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkIFVpbnQ4QXJyYXksIGdvdCAke3R5cGVvZiB0fWApO1xuICByZXR1cm4gdDtcbn1cbmZ1bmN0aW9uIGVyKC4uLnQpIHtcbiAgY29uc3QgZSA9IG5ldyBVaW50OEFycmF5KHQucmVkdWNlKChuLCBpKSA9PiBuICsgaS5sZW5ndGgsIDApKTtcbiAgbGV0IHIgPSAwO1xuICByZXR1cm4gdC5mb3JFYWNoKChuKSA9PiB7XG4gICAgaWYgKCFyaShuKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVpbnQ4QXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgZS5zZXQobiwgciksIHIgKz0gbi5sZW5ndGg7XG4gIH0pLCBlO1xufVxuY2xhc3Mgb2kge1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2xvbmVJbnRvKCk7XG4gIH1cbn1cbmNvbnN0IGVsID0gKHQpID0+IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIiAmJiB0LmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG5mdW5jdGlvbiB0bCh0LCBlKSB7XG4gIGlmIChlICE9PSB2b2lkIDAgJiYgKHR5cGVvZiBlICE9IFwib2JqZWN0XCIgfHwgIWVsKGUpKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJPcHRpb25zIHNob3VsZCBiZSBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpO1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih0LCBlKTtcbn1cbmZ1bmN0aW9uIG50KHQpIHtcbiAgY29uc3QgZSA9IChuKSA9PiB0KCkudXBkYXRlKE90KG4pKS5kaWdlc3QoKSwgciA9IHQoKTtcbiAgcmV0dXJuIGUub3V0cHV0TGVuID0gci5vdXRwdXRMZW4sIGUuYmxvY2tMZW4gPSByLmJsb2NrTGVuLCBlLmNyZWF0ZSA9ICgpID0+IHQoKSwgZTtcbn1cbmZ1bmN0aW9uIHJsKHQpIHtcbiAgY29uc3QgZSA9IChuLCBpKSA9PiB0KGkpLnVwZGF0ZShPdChuKSkuZGlnZXN0KCksIHIgPSB0KHt9KTtcbiAgcmV0dXJuIGUub3V0cHV0TGVuID0gci5vdXRwdXRMZW4sIGUuYmxvY2tMZW4gPSByLmJsb2NrTGVuLCBlLmNyZWF0ZSA9IChuKSA9PiB0KG4pLCBlO1xufVxuZnVuY3Rpb24gbmwodCkge1xuICBjb25zdCBlID0gKG4sIGkpID0+IHQoaSkudXBkYXRlKE90KG4pKS5kaWdlc3QoKSwgciA9IHQoe30pO1xuICByZXR1cm4gZS5vdXRwdXRMZW4gPSByLm91dHB1dExlbiwgZS5ibG9ja0xlbiA9IHIuYmxvY2tMZW4sIGUuY3JlYXRlID0gKG4pID0+IHQobiksIGU7XG59XG5mdW5jdGlvbiBpbCh0ID0gMzIpIHtcbiAgaWYgKFNyICYmIHR5cGVvZiBTci5nZXRSYW5kb21WYWx1ZXMgPT0gXCJmdW5jdGlvblwiKVxuICAgIHJldHVybiBTci5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkodCkpO1xuICB0aHJvdyBuZXcgRXJyb3IoXCJjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIG11c3QgYmUgZGVmaW5lZFwiKTtcbn1cbmNvbnN0IG9sID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoLyogQF9fUFVSRV9fICovIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgdTg6IFl1LFxuICB1MzI6IEp1LFxuICBjcmVhdGVWaWV3OiBmdCxcbiAgcm90cjogRWUsXG4gIGlzTEU6IEtzLFxuICBieXRlc1RvSGV4OiBuaSxcbiAgaGV4VG9CeXRlczogV3MsXG4gIG5leHRUaWNrOiBWcyxcbiAgYXN5bmNMb29wOiBRdSxcbiAgdXRmOFRvQnl0ZXM6IGlpLFxuICB0b0J5dGVzOiBPdCxcbiAgY29uY2F0Qnl0ZXM6IGVyLFxuICBIYXNoOiBvaSxcbiAgY2hlY2tPcHRzOiB0bCxcbiAgd3JhcENvbnN0cnVjdG9yOiBudCxcbiAgd3JhcENvbnN0cnVjdG9yV2l0aE9wdHM6IHJsLFxuICB3cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0czogbmwsXG4gIHJhbmRvbUJ5dGVzOiBpbFxufSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pKTtcbmZ1bmN0aW9uIHNsKHQsIGUsIHIsIG4pIHtcbiAgaWYgKHR5cGVvZiB0LnNldEJpZ1VpbnQ2NCA9PSBcImZ1bmN0aW9uXCIpXG4gICAgcmV0dXJuIHQuc2V0QmlnVWludDY0KGUsIHIsIG4pO1xuICBjb25zdCBpID0gQmlnSW50KDMyKSwgcyA9IEJpZ0ludCg0Mjk0OTY3Mjk1KSwgbyA9IE51bWJlcihyID4+IGkgJiBzKSwgYSA9IE51bWJlcihyICYgcyksIGMgPSBuID8gNCA6IDAsIGwgPSBuID8gMCA6IDQ7XG4gIHQuc2V0VWludDMyKGUgKyBjLCBvLCBuKSwgdC5zZXRVaW50MzIoZSArIGwsIGEsIG4pO1xufVxuY2xhc3Mgc2kgZXh0ZW5kcyBvaSB7XG4gIGNvbnN0cnVjdG9yKGUsIHIsIG4sIGkpIHtcbiAgICBzdXBlcigpLCB0aGlzLmJsb2NrTGVuID0gZSwgdGhpcy5vdXRwdXRMZW4gPSByLCB0aGlzLnBhZE9mZnNldCA9IG4sIHRoaXMuaXNMRSA9IGksIHRoaXMuZmluaXNoZWQgPSAhMSwgdGhpcy5sZW5ndGggPSAwLCB0aGlzLnBvcyA9IDAsIHRoaXMuZGVzdHJveWVkID0gITEsIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoZSksIHRoaXMudmlldyA9IGZ0KHRoaXMuYnVmZmVyKTtcbiAgfVxuICB1cGRhdGUoZSkge1xuICAgIFFlLmV4aXN0cyh0aGlzKTtcbiAgICBjb25zdCB7IHZpZXc6IHIsIGJ1ZmZlcjogbiwgYmxvY2tMZW46IGkgfSA9IHRoaXM7XG4gICAgZSA9IE90KGUpO1xuICAgIGNvbnN0IHMgPSBlLmxlbmd0aDtcbiAgICBmb3IgKGxldCBvID0gMDsgbyA8IHM7ICkge1xuICAgICAgY29uc3QgYSA9IE1hdGgubWluKGkgLSB0aGlzLnBvcywgcyAtIG8pO1xuICAgICAgaWYgKGEgPT09IGkpIHtcbiAgICAgICAgY29uc3QgYyA9IGZ0KGUpO1xuICAgICAgICBmb3IgKDsgaSA8PSBzIC0gbzsgbyArPSBpKVxuICAgICAgICAgIHRoaXMucHJvY2VzcyhjLCBvKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBuLnNldChlLnN1YmFycmF5KG8sIG8gKyBhKSwgdGhpcy5wb3MpLCB0aGlzLnBvcyArPSBhLCBvICs9IGEsIHRoaXMucG9zID09PSBpICYmICh0aGlzLnByb2Nlc3MociwgMCksIHRoaXMucG9zID0gMCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxlbmd0aCArPSBlLmxlbmd0aCwgdGhpcy5yb3VuZENsZWFuKCksIHRoaXM7XG4gIH1cbiAgZGlnZXN0SW50byhlKSB7XG4gICAgUWUuZXhpc3RzKHRoaXMpLCBRZS5vdXRwdXQoZSwgdGhpcyksIHRoaXMuZmluaXNoZWQgPSAhMDtcbiAgICBjb25zdCB7IGJ1ZmZlcjogciwgdmlldzogbiwgYmxvY2tMZW46IGksIGlzTEU6IHMgfSA9IHRoaXM7XG4gICAgbGV0IHsgcG9zOiBvIH0gPSB0aGlzO1xuICAgIHJbbysrXSA9IDEyOCwgdGhpcy5idWZmZXIuc3ViYXJyYXkobykuZmlsbCgwKSwgdGhpcy5wYWRPZmZzZXQgPiBpIC0gbyAmJiAodGhpcy5wcm9jZXNzKG4sIDApLCBvID0gMCk7XG4gICAgZm9yIChsZXQgdSA9IG87IHUgPCBpOyB1KyspXG4gICAgICByW3VdID0gMDtcbiAgICBzbChuLCBpIC0gOCwgQmlnSW50KHRoaXMubGVuZ3RoICogOCksIHMpLCB0aGlzLnByb2Nlc3MobiwgMCk7XG4gICAgY29uc3QgYSA9IGZ0KGUpLCBjID0gdGhpcy5vdXRwdXRMZW47XG4gICAgaWYgKGMgJSA0KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiX3NoYTI6IG91dHB1dExlbiBzaG91bGQgYmUgYWxpZ25lZCB0byAzMmJpdFwiKTtcbiAgICBjb25zdCBsID0gYyAvIDQsIGYgPSB0aGlzLmdldCgpO1xuICAgIGlmIChsID4gZi5sZW5ndGgpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJfc2hhMjogb3V0cHV0TGVuIGJpZ2dlciB0aGFuIHN0YXRlXCIpO1xuICAgIGZvciAobGV0IHUgPSAwOyB1IDwgbDsgdSsrKVxuICAgICAgYS5zZXRVaW50MzIoNCAqIHUsIGZbdV0sIHMpO1xuICB9XG4gIGRpZ2VzdCgpIHtcbiAgICBjb25zdCB7IGJ1ZmZlcjogZSwgb3V0cHV0TGVuOiByIH0gPSB0aGlzO1xuICAgIHRoaXMuZGlnZXN0SW50byhlKTtcbiAgICBjb25zdCBuID0gZS5zbGljZSgwLCByKTtcbiAgICByZXR1cm4gdGhpcy5kZXN0cm95KCksIG47XG4gIH1cbiAgX2Nsb25lSW50byhlKSB7XG4gICAgZSB8fCAoZSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkpLCBlLnNldCguLi50aGlzLmdldCgpKTtcbiAgICBjb25zdCB7IGJsb2NrTGVuOiByLCBidWZmZXI6IG4sIGxlbmd0aDogaSwgZmluaXNoZWQ6IHMsIGRlc3Ryb3llZDogbywgcG9zOiBhIH0gPSB0aGlzO1xuICAgIHJldHVybiBlLmxlbmd0aCA9IGksIGUucG9zID0gYSwgZS5maW5pc2hlZCA9IHMsIGUuZGVzdHJveWVkID0gbywgaSAlIHIgJiYgZS5idWZmZXIuc2V0KG4pLCBlO1xuICB9XG59XG5jb25zdCBhbCA9ICh0LCBlLCByKSA9PiB0ICYgZSBeIH50ICYgciwgY2wgPSAodCwgZSwgcikgPT4gdCAmIGUgXiB0ICYgciBeIGUgJiByLCB1bCA9IG5ldyBVaW50MzJBcnJheShbXG4gIDExMTYzNTI0MDgsXG4gIDE4OTk0NDc0NDEsXG4gIDMwNDkzMjM0NzEsXG4gIDM5MjEwMDk1NzMsXG4gIDk2MTk4NzE2MyxcbiAgMTUwODk3MDk5MyxcbiAgMjQ1MzYzNTc0OCxcbiAgMjg3MDc2MzIyMSxcbiAgMzYyNDM4MTA4MCxcbiAgMzEwNTk4NDAxLFxuICA2MDcyMjUyNzgsXG4gIDE0MjY4ODE5ODcsXG4gIDE5MjUwNzgzODgsXG4gIDIxNjIwNzgyMDYsXG4gIDI2MTQ4ODgxMDMsXG4gIDMyNDgyMjI1ODAsXG4gIDM4MzUzOTA0MDEsXG4gIDQwMjIyMjQ3NzQsXG4gIDI2NDM0NzA3OCxcbiAgNjA0ODA3NjI4LFxuICA3NzAyNTU5ODMsXG4gIDEyNDkxNTAxMjIsXG4gIDE1NTUwODE2OTIsXG4gIDE5OTYwNjQ5ODYsXG4gIDI1NTQyMjA4ODIsXG4gIDI4MjE4MzQzNDksXG4gIDI5NTI5OTY4MDgsXG4gIDMyMTAzMTM2NzEsXG4gIDMzMzY1NzE4OTEsXG4gIDM1ODQ1Mjg3MTEsXG4gIDExMzkyNjk5MyxcbiAgMzM4MjQxODk1LFxuICA2NjYzMDcyMDUsXG4gIDc3MzUyOTkxMixcbiAgMTI5NDc1NzM3MixcbiAgMTM5NjE4MjI5MSxcbiAgMTY5NTE4MzcwMCxcbiAgMTk4NjY2MTA1MSxcbiAgMjE3NzAyNjM1MCxcbiAgMjQ1Njk1NjAzNyxcbiAgMjczMDQ4NTkyMSxcbiAgMjgyMDMwMjQxMSxcbiAgMzI1OTczMDgwMCxcbiAgMzM0NTc2NDc3MSxcbiAgMzUxNjA2NTgxNyxcbiAgMzYwMDM1MjgwNCxcbiAgNDA5NDU3MTkwOSxcbiAgMjc1NDIzMzQ0LFxuICA0MzAyMjc3MzQsXG4gIDUwNjk0ODYxNixcbiAgNjU5MDYwNTU2LFxuICA4ODM5OTc4NzcsXG4gIDk1ODEzOTU3MSxcbiAgMTMyMjgyMjIxOCxcbiAgMTUzNzAwMjA2MyxcbiAgMTc0Nzg3Mzc3OSxcbiAgMTk1NTU2MjIyMixcbiAgMjAyNDEwNDgxNSxcbiAgMjIyNzczMDQ1MixcbiAgMjM2MTg1MjQyNCxcbiAgMjQyODQzNjQ3NCxcbiAgMjc1NjczNDE4NyxcbiAgMzIwNDAzMTQ3OSxcbiAgMzMyOTMyNTI5OFxuXSksIEtlID0gbmV3IFVpbnQzMkFycmF5KFtcbiAgMTc3OTAzMzcwMyxcbiAgMzE0NDEzNDI3NyxcbiAgMTAxMzkwNDI0MixcbiAgMjc3MzQ4MDc2MixcbiAgMTM1OTg5MzExOSxcbiAgMjYwMDgyMjkyNCxcbiAgNTI4NzM0NjM1LFxuICAxNTQxNDU5MjI1XG5dKSwgV2UgPSBuZXcgVWludDMyQXJyYXkoNjQpO1xuY2xhc3MgR3MgZXh0ZW5kcyBzaSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKDY0LCAzMiwgOCwgITEpLCB0aGlzLkEgPSBLZVswXSB8IDAsIHRoaXMuQiA9IEtlWzFdIHwgMCwgdGhpcy5DID0gS2VbMl0gfCAwLCB0aGlzLkQgPSBLZVszXSB8IDAsIHRoaXMuRSA9IEtlWzRdIHwgMCwgdGhpcy5GID0gS2VbNV0gfCAwLCB0aGlzLkcgPSBLZVs2XSB8IDAsIHRoaXMuSCA9IEtlWzddIHwgMDtcbiAgfVxuICBnZXQoKSB7XG4gICAgY29uc3QgeyBBOiBlLCBCOiByLCBDOiBuLCBEOiBpLCBFOiBzLCBGOiBvLCBHOiBhLCBIOiBjIH0gPSB0aGlzO1xuICAgIHJldHVybiBbZSwgciwgbiwgaSwgcywgbywgYSwgY107XG4gIH1cbiAgc2V0KGUsIHIsIG4sIGksIHMsIG8sIGEsIGMpIHtcbiAgICB0aGlzLkEgPSBlIHwgMCwgdGhpcy5CID0gciB8IDAsIHRoaXMuQyA9IG4gfCAwLCB0aGlzLkQgPSBpIHwgMCwgdGhpcy5FID0gcyB8IDAsIHRoaXMuRiA9IG8gfCAwLCB0aGlzLkcgPSBhIHwgMCwgdGhpcy5IID0gYyB8IDA7XG4gIH1cbiAgcHJvY2VzcyhlLCByKSB7XG4gICAgZm9yIChsZXQgdSA9IDA7IHUgPCAxNjsgdSsrLCByICs9IDQpXG4gICAgICBXZVt1XSA9IGUuZ2V0VWludDMyKHIsICExKTtcbiAgICBmb3IgKGxldCB1ID0gMTY7IHUgPCA2NDsgdSsrKSB7XG4gICAgICBjb25zdCBoID0gV2VbdSAtIDE1XSwgZCA9IFdlW3UgLSAyXSwgcCA9IEVlKGgsIDcpIF4gRWUoaCwgMTgpIF4gaCA+Pj4gMywgeSA9IEVlKGQsIDE3KSBeIEVlKGQsIDE5KSBeIGQgPj4+IDEwO1xuICAgICAgV2VbdV0gPSB5ICsgV2VbdSAtIDddICsgcCArIFdlW3UgLSAxNl0gfCAwO1xuICAgIH1cbiAgICBsZXQgeyBBOiBuLCBCOiBpLCBDOiBzLCBEOiBvLCBFOiBhLCBGOiBjLCBHOiBsLCBIOiBmIH0gPSB0aGlzO1xuICAgIGZvciAobGV0IHUgPSAwOyB1IDwgNjQ7IHUrKykge1xuICAgICAgY29uc3QgaCA9IEVlKGEsIDYpIF4gRWUoYSwgMTEpIF4gRWUoYSwgMjUpLCBkID0gZiArIGggKyBhbChhLCBjLCBsKSArIHVsW3VdICsgV2VbdV0gfCAwLCB5ID0gKEVlKG4sIDIpIF4gRWUobiwgMTMpIF4gRWUobiwgMjIpKSArIGNsKG4sIGksIHMpIHwgMDtcbiAgICAgIGYgPSBsLCBsID0gYywgYyA9IGEsIGEgPSBvICsgZCB8IDAsIG8gPSBzLCBzID0gaSwgaSA9IG4sIG4gPSBkICsgeSB8IDA7XG4gICAgfVxuICAgIG4gPSBuICsgdGhpcy5BIHwgMCwgaSA9IGkgKyB0aGlzLkIgfCAwLCBzID0gcyArIHRoaXMuQyB8IDAsIG8gPSBvICsgdGhpcy5EIHwgMCwgYSA9IGEgKyB0aGlzLkUgfCAwLCBjID0gYyArIHRoaXMuRiB8IDAsIGwgPSBsICsgdGhpcy5HIHwgMCwgZiA9IGYgKyB0aGlzLkggfCAwLCB0aGlzLnNldChuLCBpLCBzLCBvLCBhLCBjLCBsLCBmKTtcbiAgfVxuICByb3VuZENsZWFuKCkge1xuICAgIFdlLmZpbGwoMCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKSwgdGhpcy5idWZmZXIuZmlsbCgwKTtcbiAgfVxufVxuY2xhc3MgbGwgZXh0ZW5kcyBHcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCksIHRoaXMuQSA9IC0xMDU2NTk2MjY0LCB0aGlzLkIgPSA5MTQxNTA2NjMsIHRoaXMuQyA9IDgxMjcwMjk5OSwgdGhpcy5EID0gLTE1MDA1NDU5OSwgdGhpcy5FID0gLTQxOTE0MzksIHRoaXMuRiA9IDE3NTA2MDMwMjUsIHRoaXMuRyA9IDE2OTQwNzY4MzksIHRoaXMuSCA9IC0xMDkwODkxODY4LCB0aGlzLm91dHB1dExlbiA9IDI4O1xuICB9XG59XG5jb25zdCBqciA9IG50KCgpID0+IG5ldyBHcygpKSwgZmwgPSBudCgoKSA9PiBuZXcgbGwoKSksIGhsID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoLyogQF9fUFVSRV9fICovIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgc2hhMjU2OiBqcixcbiAgc2hhMjI0OiBmbFxufSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pKSwgZGwgPSAvKiBAX19QVVJFX18gKi8gRXQoaGwpLCBkciA9IEJpZ0ludCgyICoqIDMyIC0gMSksICRuID0gQmlnSW50KDMyKTtcbmZ1bmN0aW9uIFpzKHQsIGUgPSAhMSkge1xuICByZXR1cm4gZSA/IHsgaDogTnVtYmVyKHQgJiBkciksIGw6IE51bWJlcih0ID4+ICRuICYgZHIpIH0gOiB7IGg6IE51bWJlcih0ID4+ICRuICYgZHIpIHwgMCwgbDogTnVtYmVyKHQgJiBkcikgfCAwIH07XG59XG5mdW5jdGlvbiBwbCh0LCBlID0gITEpIHtcbiAgbGV0IHIgPSBuZXcgVWludDMyQXJyYXkodC5sZW5ndGgpLCBuID0gbmV3IFVpbnQzMkFycmF5KHQubGVuZ3RoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgeyBoOiBzLCBsOiBvIH0gPSBacyh0W2ldLCBlKTtcbiAgICBbcltpXSwgbltpXV0gPSBbcywgb107XG4gIH1cbiAgcmV0dXJuIFtyLCBuXTtcbn1cbmNvbnN0IHlsID0gKHQsIGUpID0+IEJpZ0ludCh0ID4+PiAwKSA8PCAkbiB8IEJpZ0ludChlID4+PiAwKSwgZ2wgPSAodCwgZSwgcikgPT4gdCA+Pj4gciwgYmwgPSAodCwgZSwgcikgPT4gdCA8PCAzMiAtIHIgfCBlID4+PiByLCB2bCA9ICh0LCBlLCByKSA9PiB0ID4+PiByIHwgZSA8PCAzMiAtIHIsIHdsID0gKHQsIGUsIHIpID0+IHQgPDwgMzIgLSByIHwgZSA+Pj4gciwgX2wgPSAodCwgZSwgcikgPT4gdCA8PCA2NCAtIHIgfCBlID4+PiByIC0gMzIsIG1sID0gKHQsIGUsIHIpID0+IHQgPj4+IHIgLSAzMiB8IGUgPDwgNjQgLSByLCB4bCA9ICh0LCBlKSA9PiBlLCBFbCA9ICh0LCBlKSA9PiB0LCBrbCA9ICh0LCBlLCByKSA9PiB0IDw8IHIgfCBlID4+PiAzMiAtIHIsIFNsID0gKHQsIGUsIHIpID0+IGUgPDwgciB8IHQgPj4+IDMyIC0gciwgT2wgPSAodCwgZSwgcikgPT4gZSA8PCByIC0gMzIgfCB0ID4+PiA2NCAtIHIsIEFsID0gKHQsIGUsIHIpID0+IHQgPDwgciAtIDMyIHwgZSA+Pj4gNjQgLSByO1xuZnVuY3Rpb24gQ2wodCwgZSwgciwgbikge1xuICBjb25zdCBpID0gKGUgPj4+IDApICsgKG4gPj4+IDApO1xuICByZXR1cm4geyBoOiB0ICsgciArIChpIC8gMiAqKiAzMiB8IDApIHwgMCwgbDogaSB8IDAgfTtcbn1cbmNvbnN0IElsID0gKHQsIGUsIHIpID0+ICh0ID4+PiAwKSArIChlID4+PiAwKSArIChyID4+PiAwKSwgUmwgPSAodCwgZSwgciwgbikgPT4gZSArIHIgKyBuICsgKHQgLyAyICoqIDMyIHwgMCkgfCAwLCBUbCA9ICh0LCBlLCByLCBuKSA9PiAodCA+Pj4gMCkgKyAoZSA+Pj4gMCkgKyAociA+Pj4gMCkgKyAobiA+Pj4gMCksIFBsID0gKHQsIGUsIHIsIG4sIGkpID0+IGUgKyByICsgbiArIGkgKyAodCAvIDIgKiogMzIgfCAwKSB8IDAsIEJsID0gKHQsIGUsIHIsIG4sIGkpID0+ICh0ID4+PiAwKSArIChlID4+PiAwKSArIChyID4+PiAwKSArIChuID4+PiAwKSArIChpID4+PiAwKSwgTGwgPSAodCwgZSwgciwgbiwgaSwgcykgPT4gZSArIHIgKyBuICsgaSArIHMgKyAodCAvIDIgKiogMzIgfCAwKSB8IDAsIE4gPSB7XG4gIGZyb21CaWc6IFpzLFxuICBzcGxpdDogcGwsXG4gIHRvQmlnOiB5bCxcbiAgc2hyU0g6IGdsLFxuICBzaHJTTDogYmwsXG4gIHJvdHJTSDogdmwsXG4gIHJvdHJTTDogd2wsXG4gIHJvdHJCSDogX2wsXG4gIHJvdHJCTDogbWwsXG4gIHJvdHIzMkg6IHhsLFxuICByb3RyMzJMOiBFbCxcbiAgcm90bFNIOiBrbCxcbiAgcm90bFNMOiBTbCxcbiAgcm90bEJIOiBPbCxcbiAgcm90bEJMOiBBbCxcbiAgYWRkOiBDbCxcbiAgYWRkM0w6IElsLFxuICBhZGQzSDogUmwsXG4gIGFkZDRMOiBUbCxcbiAgYWRkNEg6IFBsLFxuICBhZGQ1SDogTGwsXG4gIGFkZDVMOiBCbFxufSwgWyRsLCBxbF0gPSBOLnNwbGl0KFtcbiAgXCIweDQyOGEyZjk4ZDcyOGFlMjJcIixcbiAgXCIweDcxMzc0NDkxMjNlZjY1Y2RcIixcbiAgXCIweGI1YzBmYmNmZWM0ZDNiMmZcIixcbiAgXCIweGU5YjVkYmE1ODE4OWRiYmNcIixcbiAgXCIweDM5NTZjMjViZjM0OGI1MzhcIixcbiAgXCIweDU5ZjExMWYxYjYwNWQwMTlcIixcbiAgXCIweDkyM2Y4MmE0YWYxOTRmOWJcIixcbiAgXCIweGFiMWM1ZWQ1ZGE2ZDgxMThcIixcbiAgXCIweGQ4MDdhYTk4YTMwMzAyNDJcIixcbiAgXCIweDEyODM1YjAxNDU3MDZmYmVcIixcbiAgXCIweDI0MzE4NWJlNGVlNGIyOGNcIixcbiAgXCIweDU1MGM3ZGMzZDVmZmI0ZTJcIixcbiAgXCIweDcyYmU1ZDc0ZjI3Yjg5NmZcIixcbiAgXCIweDgwZGViMWZlM2IxNjk2YjFcIixcbiAgXCIweDliZGMwNmE3MjVjNzEyMzVcIixcbiAgXCIweGMxOWJmMTc0Y2Y2OTI2OTRcIixcbiAgXCIweGU0OWI2OWMxOWVmMTRhZDJcIixcbiAgXCIweGVmYmU0Nzg2Mzg0ZjI1ZTNcIixcbiAgXCIweDBmYzE5ZGM2OGI4Y2Q1YjVcIixcbiAgXCIweDI0MGNhMWNjNzdhYzljNjVcIixcbiAgXCIweDJkZTkyYzZmNTkyYjAyNzVcIixcbiAgXCIweDRhNzQ4NGFhNmVhNmU0ODNcIixcbiAgXCIweDVjYjBhOWRjYmQ0MWZiZDRcIixcbiAgXCIweDc2Zjk4OGRhODMxMTUzYjVcIixcbiAgXCIweDk4M2U1MTUyZWU2NmRmYWJcIixcbiAgXCIweGE4MzFjNjZkMmRiNDMyMTBcIixcbiAgXCIweGIwMDMyN2M4OThmYjIxM2ZcIixcbiAgXCIweGJmNTk3ZmM3YmVlZjBlZTRcIixcbiAgXCIweGM2ZTAwYmYzM2RhODhmYzJcIixcbiAgXCIweGQ1YTc5MTQ3OTMwYWE3MjVcIixcbiAgXCIweDA2Y2E2MzUxZTAwMzgyNmZcIixcbiAgXCIweDE0MjkyOTY3MGEwZTZlNzBcIixcbiAgXCIweDI3YjcwYTg1NDZkMjJmZmNcIixcbiAgXCIweDJlMWIyMTM4NWMyNmM5MjZcIixcbiAgXCIweDRkMmM2ZGZjNWFjNDJhZWRcIixcbiAgXCIweDUzMzgwZDEzOWQ5NWIzZGZcIixcbiAgXCIweDY1MGE3MzU0OGJhZjYzZGVcIixcbiAgXCIweDc2NmEwYWJiM2M3N2IyYThcIixcbiAgXCIweDgxYzJjOTJlNDdlZGFlZTZcIixcbiAgXCIweDkyNzIyYzg1MTQ4MjM1M2JcIixcbiAgXCIweGEyYmZlOGExNGNmMTAzNjRcIixcbiAgXCIweGE4MWE2NjRiYmM0MjMwMDFcIixcbiAgXCIweGMyNGI4YjcwZDBmODk3OTFcIixcbiAgXCIweGM3NmM1MWEzMDY1NGJlMzBcIixcbiAgXCIweGQxOTJlODE5ZDZlZjUyMThcIixcbiAgXCIweGQ2OTkwNjI0NTU2NWE5MTBcIixcbiAgXCIweGY0MGUzNTg1NTc3MTIwMmFcIixcbiAgXCIweDEwNmFhMDcwMzJiYmQxYjhcIixcbiAgXCIweDE5YTRjMTE2YjhkMmQwYzhcIixcbiAgXCIweDFlMzc2YzA4NTE0MWFiNTNcIixcbiAgXCIweDI3NDg3NzRjZGY4ZWViOTlcIixcbiAgXCIweDM0YjBiY2I1ZTE5YjQ4YThcIixcbiAgXCIweDM5MWMwY2IzYzVjOTVhNjNcIixcbiAgXCIweDRlZDhhYTRhZTM0MThhY2JcIixcbiAgXCIweDViOWNjYTRmNzc2M2UzNzNcIixcbiAgXCIweDY4MmU2ZmYzZDZiMmI4YTNcIixcbiAgXCIweDc0OGY4MmVlNWRlZmIyZmNcIixcbiAgXCIweDc4YTU2MzZmNDMxNzJmNjBcIixcbiAgXCIweDg0Yzg3ODE0YTFmMGFiNzJcIixcbiAgXCIweDhjYzcwMjA4MWE2NDM5ZWNcIixcbiAgXCIweDkwYmVmZmZhMjM2MzFlMjhcIixcbiAgXCIweGE0NTA2Y2ViZGU4MmJkZTlcIixcbiAgXCIweGJlZjlhM2Y3YjJjNjc5MTVcIixcbiAgXCIweGM2NzE3OGYyZTM3MjUzMmJcIixcbiAgXCIweGNhMjczZWNlZWEyNjYxOWNcIixcbiAgXCIweGQxODZiOGM3MjFjMGMyMDdcIixcbiAgXCIweGVhZGE3ZGQ2Y2RlMGViMWVcIixcbiAgXCIweGY1N2Q0ZjdmZWU2ZWQxNzhcIixcbiAgXCIweDA2ZjA2N2FhNzIxNzZmYmFcIixcbiAgXCIweDBhNjM3ZGM1YTJjODk4YTZcIixcbiAgXCIweDExM2Y5ODA0YmVmOTBkYWVcIixcbiAgXCIweDFiNzEwYjM1MTMxYzQ3MWJcIixcbiAgXCIweDI4ZGI3N2Y1MjMwNDdkODRcIixcbiAgXCIweDMyY2FhYjdiNDBjNzI0OTNcIixcbiAgXCIweDNjOWViZTBhMTVjOWJlYmNcIixcbiAgXCIweDQzMWQ2N2M0OWMxMDBkNGNcIixcbiAgXCIweDRjYzVkNGJlY2IzZTQyYjZcIixcbiAgXCIweDU5N2YyOTljZmM2NTdlMmFcIixcbiAgXCIweDVmY2I2ZmFiM2FkNmZhZWNcIixcbiAgXCIweDZjNDQxOThjNGE0NzU4MTdcIlxuXS5tYXAoKHQpID0+IEJpZ0ludCh0KSkpLCBWZSA9IG5ldyBVaW50MzJBcnJheSg4MCksIEdlID0gbmV3IFVpbnQzMkFycmF5KDgwKTtcbmNsYXNzIGFyIGV4dGVuZHMgc2kge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigxMjgsIDY0LCAxNiwgITEpLCB0aGlzLkFoID0gMTc3OTAzMzcwMywgdGhpcy5BbCA9IC0yMDU3MzE1NzYsIHRoaXMuQmggPSAtMTE1MDgzMzAxOSwgdGhpcy5CbCA9IC0yMDY3MDkzNzAxLCB0aGlzLkNoID0gMTAxMzkwNDI0MiwgdGhpcy5DbCA9IC0yMzc5MTU3MywgdGhpcy5EaCA9IC0xNTIxNDg2NTM0LCB0aGlzLkRsID0gMTU5NTc1MDEyOSwgdGhpcy5FaCA9IDEzNTk4OTMxMTksIHRoaXMuRWwgPSAtMTM3NzQwMjE1OSwgdGhpcy5GaCA9IC0xNjk0MTQ0MzcyLCB0aGlzLkZsID0gNzI1NTExMTk5LCB0aGlzLkdoID0gNTI4NzM0NjM1LCB0aGlzLkdsID0gLTc5NTc3NzQ5LCB0aGlzLkhoID0gMTU0MTQ1OTIyNSwgdGhpcy5IbCA9IDMyNzAzMzIwOTtcbiAgfVxuICBnZXQoKSB7XG4gICAgY29uc3QgeyBBaDogZSwgQWw6IHIsIEJoOiBuLCBCbDogaSwgQ2g6IHMsIENsOiBvLCBEaDogYSwgRGw6IGMsIEVoOiBsLCBFbDogZiwgRmg6IHUsIEZsOiBoLCBHaDogZCwgR2w6IHAsIEhoOiB5LCBIbDogZyB9ID0gdGhpcztcbiAgICByZXR1cm4gW2UsIHIsIG4sIGksIHMsIG8sIGEsIGMsIGwsIGYsIHUsIGgsIGQsIHAsIHksIGddO1xuICB9XG4gIHNldChlLCByLCBuLCBpLCBzLCBvLCBhLCBjLCBsLCBmLCB1LCBoLCBkLCBwLCB5LCBnKSB7XG4gICAgdGhpcy5BaCA9IGUgfCAwLCB0aGlzLkFsID0gciB8IDAsIHRoaXMuQmggPSBuIHwgMCwgdGhpcy5CbCA9IGkgfCAwLCB0aGlzLkNoID0gcyB8IDAsIHRoaXMuQ2wgPSBvIHwgMCwgdGhpcy5EaCA9IGEgfCAwLCB0aGlzLkRsID0gYyB8IDAsIHRoaXMuRWggPSBsIHwgMCwgdGhpcy5FbCA9IGYgfCAwLCB0aGlzLkZoID0gdSB8IDAsIHRoaXMuRmwgPSBoIHwgMCwgdGhpcy5HaCA9IGQgfCAwLCB0aGlzLkdsID0gcCB8IDAsIHRoaXMuSGggPSB5IHwgMCwgdGhpcy5IbCA9IGcgfCAwO1xuICB9XG4gIHByb2Nlc3MoZSwgcikge1xuICAgIGZvciAobGV0IG0gPSAwOyBtIDwgMTY7IG0rKywgciArPSA0KVxuICAgICAgVmVbbV0gPSBlLmdldFVpbnQzMihyKSwgR2VbbV0gPSBlLmdldFVpbnQzMihyICs9IDQpO1xuICAgIGZvciAobGV0IG0gPSAxNjsgbSA8IDgwOyBtKyspIHtcbiAgICAgIGNvbnN0IEMgPSBWZVttIC0gMTVdIHwgMCwgTyA9IEdlW20gLSAxNV0gfCAwLCB3ID0gTi5yb3RyU0goQywgTywgMSkgXiBOLnJvdHJTSChDLCBPLCA4KSBeIE4uc2hyU0goQywgTywgNyksIHggPSBOLnJvdHJTTChDLCBPLCAxKSBeIE4ucm90clNMKEMsIE8sIDgpIF4gTi5zaHJTTChDLCBPLCA3KSwgQSA9IFZlW20gLSAyXSB8IDAsIEIgPSBHZVttIC0gMl0gfCAwLCBMID0gTi5yb3RyU0goQSwgQiwgMTkpIF4gTi5yb3RyQkgoQSwgQiwgNjEpIF4gTi5zaHJTSChBLCBCLCA2KSwgUCA9IE4ucm90clNMKEEsIEIsIDE5KSBeIE4ucm90ckJMKEEsIEIsIDYxKSBeIE4uc2hyU0woQSwgQiwgNiksIEYgPSBOLmFkZDRMKHgsIFAsIEdlW20gLSA3XSwgR2VbbSAtIDE2XSksIHogPSBOLmFkZDRIKEYsIHcsIEwsIFZlW20gLSA3XSwgVmVbbSAtIDE2XSk7XG4gICAgICBWZVttXSA9IHogfCAwLCBHZVttXSA9IEYgfCAwO1xuICAgIH1cbiAgICBsZXQgeyBBaDogbiwgQWw6IGksIEJoOiBzLCBCbDogbywgQ2g6IGEsIENsOiBjLCBEaDogbCwgRGw6IGYsIEVoOiB1LCBFbDogaCwgRmg6IGQsIEZsOiBwLCBHaDogeSwgR2w6IGcsIEhoOiB2LCBIbDogXyB9ID0gdGhpcztcbiAgICBmb3IgKGxldCBtID0gMDsgbSA8IDgwOyBtKyspIHtcbiAgICAgIGNvbnN0IEMgPSBOLnJvdHJTSCh1LCBoLCAxNCkgXiBOLnJvdHJTSCh1LCBoLCAxOCkgXiBOLnJvdHJCSCh1LCBoLCA0MSksIE8gPSBOLnJvdHJTTCh1LCBoLCAxNCkgXiBOLnJvdHJTTCh1LCBoLCAxOCkgXiBOLnJvdHJCTCh1LCBoLCA0MSksIHcgPSB1ICYgZCBeIH51ICYgeSwgeCA9IGggJiBwIF4gfmggJiBnLCBBID0gTi5hZGQ1TChfLCBPLCB4LCBxbFttXSwgR2VbbV0pLCBCID0gTi5hZGQ1SChBLCB2LCBDLCB3LCAkbFttXSwgVmVbbV0pLCBMID0gQSB8IDAsIFAgPSBOLnJvdHJTSChuLCBpLCAyOCkgXiBOLnJvdHJCSChuLCBpLCAzNCkgXiBOLnJvdHJCSChuLCBpLCAzOSksIEYgPSBOLnJvdHJTTChuLCBpLCAyOCkgXiBOLnJvdHJCTChuLCBpLCAzNCkgXiBOLnJvdHJCTChuLCBpLCAzOSksIHogPSBuICYgcyBeIG4gJiBhIF4gcyAmIGEsIEcgPSBpICYgbyBeIGkgJiBjIF4gbyAmIGM7XG4gICAgICB2ID0geSB8IDAsIF8gPSBnIHwgMCwgeSA9IGQgfCAwLCBnID0gcCB8IDAsIGQgPSB1IHwgMCwgcCA9IGggfCAwLCB7IGg6IHUsIGw6IGggfSA9IE4uYWRkKGwgfCAwLCBmIHwgMCwgQiB8IDAsIEwgfCAwKSwgbCA9IGEgfCAwLCBmID0gYyB8IDAsIGEgPSBzIHwgMCwgYyA9IG8gfCAwLCBzID0gbiB8IDAsIG8gPSBpIHwgMDtcbiAgICAgIGNvbnN0IEUgPSBOLmFkZDNMKEwsIEYsIEcpO1xuICAgICAgbiA9IE4uYWRkM0goRSwgQiwgUCwgeiksIGkgPSBFIHwgMDtcbiAgICB9XG4gICAgKHsgaDogbiwgbDogaSB9ID0gTi5hZGQodGhpcy5BaCB8IDAsIHRoaXMuQWwgfCAwLCBuIHwgMCwgaSB8IDApKSwgeyBoOiBzLCBsOiBvIH0gPSBOLmFkZCh0aGlzLkJoIHwgMCwgdGhpcy5CbCB8IDAsIHMgfCAwLCBvIHwgMCksIHsgaDogYSwgbDogYyB9ID0gTi5hZGQodGhpcy5DaCB8IDAsIHRoaXMuQ2wgfCAwLCBhIHwgMCwgYyB8IDApLCB7IGg6IGwsIGw6IGYgfSA9IE4uYWRkKHRoaXMuRGggfCAwLCB0aGlzLkRsIHwgMCwgbCB8IDAsIGYgfCAwKSwgeyBoOiB1LCBsOiBoIH0gPSBOLmFkZCh0aGlzLkVoIHwgMCwgdGhpcy5FbCB8IDAsIHUgfCAwLCBoIHwgMCksIHsgaDogZCwgbDogcCB9ID0gTi5hZGQodGhpcy5GaCB8IDAsIHRoaXMuRmwgfCAwLCBkIHwgMCwgcCB8IDApLCB7IGg6IHksIGw6IGcgfSA9IE4uYWRkKHRoaXMuR2ggfCAwLCB0aGlzLkdsIHwgMCwgeSB8IDAsIGcgfCAwKSwgeyBoOiB2LCBsOiBfIH0gPSBOLmFkZCh0aGlzLkhoIHwgMCwgdGhpcy5IbCB8IDAsIHYgfCAwLCBfIHwgMCksIHRoaXMuc2V0KG4sIGksIHMsIG8sIGEsIGMsIGwsIGYsIHUsIGgsIGQsIHAsIHksIGcsIHYsIF8pO1xuICB9XG4gIHJvdW5kQ2xlYW4oKSB7XG4gICAgVmUuZmlsbCgwKSwgR2UuZmlsbCgwKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuYnVmZmVyLmZpbGwoMCksIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuICB9XG59XG5jbGFzcyBObCBleHRlbmRzIGFyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKSwgdGhpcy5BaCA9IC0xOTQyMTQ1MDgwLCB0aGlzLkFsID0gNDI0OTU1Mjk4LCB0aGlzLkJoID0gMTk0NDE2NDcxMCwgdGhpcy5CbCA9IC0xOTgyMDE2Mjk4LCB0aGlzLkNoID0gNTAyOTcwMjg2LCB0aGlzLkNsID0gODU1NjEyNTQ2LCB0aGlzLkRoID0gMTczODM5Njk0OCwgdGhpcy5EbCA9IDE0Nzk1MTYxMTEsIHRoaXMuRWggPSAyNTg4MTI3NzcsIHRoaXMuRWwgPSAyMDc3NTExMDgwLCB0aGlzLkZoID0gMjAxMTM5MzkwNywgdGhpcy5GbCA9IDc5OTg5MDU4LCB0aGlzLkdoID0gMTA2NzI4Nzk3NiwgdGhpcy5HbCA9IDE3ODAyOTk0NjQsIHRoaXMuSGggPSAyODY0NTEzNzMsIHRoaXMuSGwgPSAtMTg0ODIwODczNSwgdGhpcy5vdXRwdXRMZW4gPSAyODtcbiAgfVxufVxuY2xhc3MgVWwgZXh0ZW5kcyBhciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCksIHRoaXMuQWggPSA1NzM2NDUyMDQsIHRoaXMuQWwgPSAtNjQyMjc1NDAsIHRoaXMuQmggPSAtMTYyMTc5NDkwOSwgdGhpcy5CbCA9IC05MzQ1MTc1NjYsIHRoaXMuQ2ggPSA1OTY4ODM1NjMsIHRoaXMuQ2wgPSAxODY3NzU1ODU3LCB0aGlzLkRoID0gLTE3NzQ2ODQzOTEsIHRoaXMuRGwgPSAxNDk3NDI2NjIxLCB0aGlzLkVoID0gLTE3NzU3NDczNTgsIHRoaXMuRWwgPSAtMTQ2NzAyMzM4OSwgdGhpcy5GaCA9IC0xMTAxMTI4MTU1LCB0aGlzLkZsID0gMTQwMTMwNTQ5MCwgdGhpcy5HaCA9IDcyMTUyNTI0NCwgdGhpcy5HbCA9IDc0Njk2MTA2NiwgdGhpcy5IaCA9IDI0Njg4NTg1MiwgdGhpcy5IbCA9IC0yMTE3Nzg0NDE0LCB0aGlzLm91dHB1dExlbiA9IDMyO1xuICB9XG59XG5jbGFzcyBqbCBleHRlbmRzIGFyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKSwgdGhpcy5BaCA9IC04NzY4OTY5MzEsIHRoaXMuQWwgPSAtMTA1NjU5NjI2NCwgdGhpcy5CaCA9IDE2NTQyNzAyNTAsIHRoaXMuQmwgPSA5MTQxNTA2NjMsIHRoaXMuQ2ggPSAtMTg1NjQzNzkyNiwgdGhpcy5DbCA9IDgxMjcwMjk5OSwgdGhpcy5EaCA9IDM1NTQ2MjM2MCwgdGhpcy5EbCA9IC0xNTAwNTQ1OTksIHRoaXMuRWggPSAxNzMxNDA1NDE1LCB0aGlzLkVsID0gLTQxOTE0MzksIHRoaXMuRmggPSAtMTkwMDc4NzA2NSwgdGhpcy5GbCA9IDE3NTA2MDMwMjUsIHRoaXMuR2ggPSAtNjE5OTU4NzcxLCB0aGlzLkdsID0gMTY5NDA3NjgzOSwgdGhpcy5IaCA9IDEyMDMwNjI4MTMsIHRoaXMuSGwgPSAtMTA5MDg5MTg2OCwgdGhpcy5vdXRwdXRMZW4gPSA0ODtcbiAgfVxufVxuY29uc3QgcW4gPSBudCgoKSA9PiBuZXcgYXIoKSksIEhsID0gbnQoKCkgPT4gbmV3IE5sKCkpLCBNbCA9IG50KCgpID0+IG5ldyBVbCgpKSwgRGwgPSBudCgoKSA9PiBuZXcgamwoKSksIHpsID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoLyogQF9fUFVSRV9fICovIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgU0hBNTEyOiBhcixcbiAgc2hhNTEyOiBxbixcbiAgc2hhNTEyXzIyNDogSGwsXG4gIHNoYTUxMl8yNTY6IE1sLFxuICBzaGEzODQ6IERsXG59LCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSkpLCBGbCA9IC8qIEBfX1BVUkVfXyAqLyBFdCh6bCksIEtsID0gLyogQF9fUFVSRV9fICovIEV0KG9sKSwgV2wgPSAvKiBAX19QVVJFX18gKi8gRXQoTXUpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGRlLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG52YXIgWXMgPSBkZS5tbmVtb25pY1RvU2VlZFN5bmMgPSBkZS5tbmVtb25pY1RvU2VlZCA9IHNhID0gZGUudmFsaWRhdGVNbmVtb25pYyA9IGRlLmVudHJvcHlUb01uZW1vbmljID0gZGUubW5lbW9uaWNUb0VudHJvcHkgPSByYSA9IGRlLmdlbmVyYXRlTW5lbW9uaWMgPSB2b2lkIDA7XG4vKiEgc2N1cmUtYmlwMzkgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXRyaWNpbyBQYWxsYWRpbm8sIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuY29uc3QgSnMgPSB6dSwgWHMgPSB4dCwgVmwgPSBkbCwgUXMgPSBGbCwgR2wgPSBLbCwgcHIgPSBXbCwgWmwgPSAodCkgPT4gdFswXSA9PT0gXCJcXHUzMDQyXFx1MzA0NFxcdTMwNTNcXHUzMDRGXFx1MzA1N1xcdTMwOTNcIjtcbmZ1bmN0aW9uIGVhKHQpIHtcbiAgaWYgKHR5cGVvZiB0ICE9IFwic3RyaW5nXCIpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBtbmVtb25pYyB0eXBlOiAke3R5cGVvZiB0fWApO1xuICByZXR1cm4gdC5ub3JtYWxpemUoXCJORktEXCIpO1xufVxuZnVuY3Rpb24gYWkodCkge1xuICBjb25zdCBlID0gZWEodCksIHIgPSBlLnNwbGl0KFwiIFwiKTtcbiAgaWYgKCFbMTIsIDE1LCAxOCwgMjEsIDI0XS5pbmNsdWRlcyhyLmxlbmd0aCkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBtbmVtb25pY1wiKTtcbiAgcmV0dXJuIHsgbmZrZDogZSwgd29yZHM6IHIgfTtcbn1cbmZ1bmN0aW9uIHRhKHQpIHtcbiAgSnMuZGVmYXVsdC5ieXRlcyh0LCAxNiwgMjAsIDI0LCAyOCwgMzIpO1xufVxuZnVuY3Rpb24gWWwodCwgZSA9IDEyOCkge1xuICBpZiAoSnMuZGVmYXVsdC5udW1iZXIoZSksIGUgJSAzMiAhPT0gMCB8fCBlID4gMjU2KVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGVudHJvcHlcIik7XG4gIHJldHVybiBvYSgoMCwgR2wucmFuZG9tQnl0ZXMpKGUgLyA4KSwgdCk7XG59XG52YXIgcmEgPSBkZS5nZW5lcmF0ZU1uZW1vbmljID0gWWw7XG5jb25zdCBKbCA9ICh0KSA9PiB7XG4gIGNvbnN0IGUgPSA4IC0gdC5sZW5ndGggLyA0O1xuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWygwLCBWbC5zaGEyNTYpKHQpWzBdID4+IGUgPDwgZV0pO1xufTtcbmZ1bmN0aW9uIG5hKHQpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHQpIHx8IHQubGVuZ3RoICE9PSAyMDQ4IHx8IHR5cGVvZiB0WzBdICE9IFwic3RyaW5nXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiV29ybGlzdDogZXhwZWN0ZWQgYXJyYXkgb2YgMjA0OCBzdHJpbmdzXCIpO1xuICByZXR1cm4gdC5mb3JFYWNoKChlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBlICE9IFwic3RyaW5nXCIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFdvcmRsaXN0OiBub24tc3RyaW5nIGVsZW1lbnQ6ICR7ZX1gKTtcbiAgfSksIHByLnV0aWxzLmNoYWluKHByLnV0aWxzLmNoZWNrc3VtKDEsIEpsKSwgcHIudXRpbHMucmFkaXgyKDExLCAhMCksIHByLnV0aWxzLmFscGhhYmV0KHQpKTtcbn1cbmZ1bmN0aW9uIGlhKHQsIGUpIHtcbiAgY29uc3QgeyB3b3JkczogciB9ID0gYWkodCksIG4gPSBuYShlKS5kZWNvZGUocik7XG4gIHJldHVybiB0YShuKSwgbjtcbn1cbmRlLm1uZW1vbmljVG9FbnRyb3B5ID0gaWE7XG5mdW5jdGlvbiBvYSh0LCBlKSB7XG4gIHJldHVybiB0YSh0KSwgbmEoZSkuZW5jb2RlKHQpLmpvaW4oWmwoZSkgPyBcIlxcdTMwMDBcIiA6IFwiIFwiKTtcbn1cbmRlLmVudHJvcHlUb01uZW1vbmljID0gb2E7XG5mdW5jdGlvbiBYbCh0LCBlKSB7XG4gIHRyeSB7XG4gICAgaWEodCwgZSk7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiAhMTtcbiAgfVxuICByZXR1cm4gITA7XG59XG52YXIgc2EgPSBkZS52YWxpZGF0ZU1uZW1vbmljID0gWGw7XG5jb25zdCBhYSA9ICh0KSA9PiBlYShgbW5lbW9uaWMke3R9YCk7XG5mdW5jdGlvbiBRbCh0LCBlID0gXCJcIikge1xuICByZXR1cm4gKDAsIFhzLnBia2RmMkFzeW5jKShRcy5zaGE1MTIsIGFpKHQpLm5ma2QsIGFhKGUpLCB7IGM6IDIwNDgsIGRrTGVuOiA2NCB9KTtcbn1cbmRlLm1uZW1vbmljVG9TZWVkID0gUWw7XG5mdW5jdGlvbiBlZih0LCBlID0gXCJcIikge1xuICByZXR1cm4gKDAsIFhzLnBia2RmMikoUXMuc2hhNTEyLCBhaSh0KS5uZmtkLCBhYShlKSwgeyBjOiAyMDQ4LCBka0xlbjogNjQgfSk7XG59XG5ZcyA9IGRlLm1uZW1vbmljVG9TZWVkU3luYyA9IGVmO1xuY2xhc3MgY2EgZXh0ZW5kcyBvaSB7XG4gIGNvbnN0cnVjdG9yKGUsIHIpIHtcbiAgICBzdXBlcigpLCB0aGlzLmZpbmlzaGVkID0gITEsIHRoaXMuZGVzdHJveWVkID0gITEsIFFlLmhhc2goZSk7XG4gICAgY29uc3QgbiA9IE90KHIpO1xuICAgIGlmICh0aGlzLmlIYXNoID0gZS5jcmVhdGUoKSwgdHlwZW9mIHRoaXMuaUhhc2gudXBkYXRlICE9IFwiZnVuY3Rpb25cIilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIGluc3RhbmNlIG9mIGNsYXNzIHdoaWNoIGV4dGVuZHMgdXRpbHMuSGFzaFwiKTtcbiAgICB0aGlzLmJsb2NrTGVuID0gdGhpcy5pSGFzaC5ibG9ja0xlbiwgdGhpcy5vdXRwdXRMZW4gPSB0aGlzLmlIYXNoLm91dHB1dExlbjtcbiAgICBjb25zdCBpID0gdGhpcy5ibG9ja0xlbiwgcyA9IG5ldyBVaW50OEFycmF5KGkpO1xuICAgIHMuc2V0KG4ubGVuZ3RoID4gaSA/IGUuY3JlYXRlKCkudXBkYXRlKG4pLmRpZ2VzdCgpIDogbik7XG4gICAgZm9yIChsZXQgbyA9IDA7IG8gPCBzLmxlbmd0aDsgbysrKVxuICAgICAgc1tvXSBePSA1NDtcbiAgICB0aGlzLmlIYXNoLnVwZGF0ZShzKSwgdGhpcy5vSGFzaCA9IGUuY3JlYXRlKCk7XG4gICAgZm9yIChsZXQgbyA9IDA7IG8gPCBzLmxlbmd0aDsgbysrKVxuICAgICAgc1tvXSBePSAxMDY7XG4gICAgdGhpcy5vSGFzaC51cGRhdGUocyksIHMuZmlsbCgwKTtcbiAgfVxuICB1cGRhdGUoZSkge1xuICAgIHJldHVybiBRZS5leGlzdHModGhpcyksIHRoaXMuaUhhc2gudXBkYXRlKGUpLCB0aGlzO1xuICB9XG4gIGRpZ2VzdEludG8oZSkge1xuICAgIFFlLmV4aXN0cyh0aGlzKSwgUWUuYnl0ZXMoZSwgdGhpcy5vdXRwdXRMZW4pLCB0aGlzLmZpbmlzaGVkID0gITAsIHRoaXMuaUhhc2guZGlnZXN0SW50byhlKSwgdGhpcy5vSGFzaC51cGRhdGUoZSksIHRoaXMub0hhc2guZGlnZXN0SW50byhlKSwgdGhpcy5kZXN0cm95KCk7XG4gIH1cbiAgZGlnZXN0KCkge1xuICAgIGNvbnN0IGUgPSBuZXcgVWludDhBcnJheSh0aGlzLm9IYXNoLm91dHB1dExlbik7XG4gICAgcmV0dXJuIHRoaXMuZGlnZXN0SW50byhlKSwgZTtcbiAgfVxuICBfY2xvbmVJbnRvKGUpIHtcbiAgICBlIHx8IChlID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyksIHt9KSk7XG4gICAgY29uc3QgeyBvSGFzaDogciwgaUhhc2g6IG4sIGZpbmlzaGVkOiBpLCBkZXN0cm95ZWQ6IHMsIGJsb2NrTGVuOiBvLCBvdXRwdXRMZW46IGEgfSA9IHRoaXM7XG4gICAgcmV0dXJuIGUgPSBlLCBlLmZpbmlzaGVkID0gaSwgZS5kZXN0cm95ZWQgPSBzLCBlLmJsb2NrTGVuID0gbywgZS5vdXRwdXRMZW4gPSBhLCBlLm9IYXNoID0gci5fY2xvbmVJbnRvKGUub0hhc2gpLCBlLmlIYXNoID0gbi5fY2xvbmVJbnRvKGUuaUhhc2gpLCBlO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSAhMCwgdGhpcy5vSGFzaC5kZXN0cm95KCksIHRoaXMuaUhhc2guZGVzdHJveSgpO1xuICB9XG59XG5jb25zdCBObiA9ICh0LCBlLCByKSA9PiBuZXcgY2EodCwgZSkudXBkYXRlKHIpLmRpZ2VzdCgpO1xuTm4uY3JlYXRlID0gKHQsIGUpID0+IG5ldyBjYSh0LCBlKTtcbmNvbnN0IHRmID0gbmV3IFVpbnQ4QXJyYXkoWzcsIDQsIDEzLCAxLCAxMCwgNiwgMTUsIDMsIDEyLCAwLCA5LCA1LCAyLCAxNCwgMTEsIDhdKSwgdWEgPSBVaW50OEFycmF5LmZyb20oeyBsZW5ndGg6IDE2IH0sICh0LCBlKSA9PiBlKSwgcmYgPSB1YS5tYXAoKHQpID0+ICg5ICogdCArIDUpICUgMTYpO1xubGV0IGNpID0gW3VhXSwgdWkgPSBbcmZdO1xuZm9yIChsZXQgdCA9IDA7IHQgPCA0OyB0KyspXG4gIGZvciAobGV0IGUgb2YgW2NpLCB1aV0pXG4gICAgZS5wdXNoKGVbdF0ubWFwKChyKSA9PiB0ZltyXSkpO1xuY29uc3QgbGEgPSBbXG4gIFsxMSwgMTQsIDE1LCAxMiwgNSwgOCwgNywgOSwgMTEsIDEzLCAxNCwgMTUsIDYsIDcsIDksIDhdLFxuICBbMTIsIDEzLCAxMSwgMTUsIDYsIDksIDksIDcsIDEyLCAxNSwgMTEsIDEzLCA3LCA4LCA3LCA3XSxcbiAgWzEzLCAxNSwgMTQsIDExLCA3LCA3LCA2LCA4LCAxMywgMTQsIDEzLCAxMiwgNSwgNSwgNiwgOV0sXG4gIFsxNCwgMTEsIDEyLCAxNCwgOCwgNiwgNSwgNSwgMTUsIDEyLCAxNSwgMTQsIDksIDksIDgsIDZdLFxuICBbMTUsIDEyLCAxMywgMTMsIDksIDUsIDgsIDYsIDE0LCAxMSwgMTIsIDExLCA4LCA2LCA1LCA1XVxuXS5tYXAoKHQpID0+IG5ldyBVaW50OEFycmF5KHQpKSwgbmYgPSBjaS5tYXAoKHQsIGUpID0+IHQubWFwKChyKSA9PiBsYVtlXVtyXSkpLCBvZiA9IHVpLm1hcCgodCwgZSkgPT4gdC5tYXAoKHIpID0+IGxhW2VdW3JdKSksIHNmID0gbmV3IFVpbnQzMkFycmF5KFswLCAxNTE4NTAwMjQ5LCAxODU5Nzc1MzkzLCAyNDAwOTU5NzA4LCAyODQwODUzODM4XSksIGFmID0gbmV3IFVpbnQzMkFycmF5KFsxMzUyODI5OTI2LCAxNTQ4NjAzNjg0LCAxODM2MDcyNjkxLCAyMDUzOTk0MjE3LCAwXSksIHlyID0gKHQsIGUpID0+IHQgPDwgZSB8IHQgPj4+IDMyIC0gZTtcbmZ1bmN0aW9uIFppKHQsIGUsIHIsIG4pIHtcbiAgcmV0dXJuIHQgPT09IDAgPyBlIF4gciBeIG4gOiB0ID09PSAxID8gZSAmIHIgfCB+ZSAmIG4gOiB0ID09PSAyID8gKGUgfCB+cikgXiBuIDogdCA9PT0gMyA/IGUgJiBuIHwgciAmIH5uIDogZSBeIChyIHwgfm4pO1xufVxuY29uc3QgZ3IgPSBuZXcgVWludDMyQXJyYXkoMTYpO1xuY2xhc3MgY2YgZXh0ZW5kcyBzaSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKDY0LCAyMCwgOCwgITApLCB0aGlzLmgwID0gMTczMjU4NDE5MywgdGhpcy5oMSA9IC0yNzE3MzM4NzksIHRoaXMuaDIgPSAtMTczMjU4NDE5NCwgdGhpcy5oMyA9IDI3MTczMzg3OCwgdGhpcy5oNCA9IC0xMDA5NTg5Nzc2O1xuICB9XG4gIGdldCgpIHtcbiAgICBjb25zdCB7IGgwOiBlLCBoMTogciwgaDI6IG4sIGgzOiBpLCBoNDogcyB9ID0gdGhpcztcbiAgICByZXR1cm4gW2UsIHIsIG4sIGksIHNdO1xuICB9XG4gIHNldChlLCByLCBuLCBpLCBzKSB7XG4gICAgdGhpcy5oMCA9IGUgfCAwLCB0aGlzLmgxID0gciB8IDAsIHRoaXMuaDIgPSBuIHwgMCwgdGhpcy5oMyA9IGkgfCAwLCB0aGlzLmg0ID0gcyB8IDA7XG4gIH1cbiAgcHJvY2VzcyhlLCByKSB7XG4gICAgZm9yIChsZXQgZCA9IDA7IGQgPCAxNjsgZCsrLCByICs9IDQpXG4gICAgICBncltkXSA9IGUuZ2V0VWludDMyKHIsICEwKTtcbiAgICBsZXQgbiA9IHRoaXMuaDAgfCAwLCBpID0gbiwgcyA9IHRoaXMuaDEgfCAwLCBvID0gcywgYSA9IHRoaXMuaDIgfCAwLCBjID0gYSwgbCA9IHRoaXMuaDMgfCAwLCBmID0gbCwgdSA9IHRoaXMuaDQgfCAwLCBoID0gdTtcbiAgICBmb3IgKGxldCBkID0gMDsgZCA8IDU7IGQrKykge1xuICAgICAgY29uc3QgcCA9IDQgLSBkLCB5ID0gc2ZbZF0sIGcgPSBhZltkXSwgdiA9IGNpW2RdLCBfID0gdWlbZF0sIG0gPSBuZltkXSwgQyA9IG9mW2RdO1xuICAgICAgZm9yIChsZXQgTyA9IDA7IE8gPCAxNjsgTysrKSB7XG4gICAgICAgIGNvbnN0IHcgPSB5cihuICsgWmkoZCwgcywgYSwgbCkgKyBnclt2W09dXSArIHksIG1bT10pICsgdSB8IDA7XG4gICAgICAgIG4gPSB1LCB1ID0gbCwgbCA9IHlyKGEsIDEwKSB8IDAsIGEgPSBzLCBzID0gdztcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IE8gPSAwOyBPIDwgMTY7IE8rKykge1xuICAgICAgICBjb25zdCB3ID0geXIoaSArIFppKHAsIG8sIGMsIGYpICsgZ3JbX1tPXV0gKyBnLCBDW09dKSArIGggfCAwO1xuICAgICAgICBpID0gaCwgaCA9IGYsIGYgPSB5cihjLCAxMCkgfCAwLCBjID0gbywgbyA9IHc7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuc2V0KHRoaXMuaDEgKyBhICsgZiB8IDAsIHRoaXMuaDIgKyBsICsgaCB8IDAsIHRoaXMuaDMgKyB1ICsgaSB8IDAsIHRoaXMuaDQgKyBuICsgbyB8IDAsIHRoaXMuaDAgKyBzICsgYyB8IDApO1xuICB9XG4gIHJvdW5kQ2xlYW4oKSB7XG4gICAgZ3IuZmlsbCgwKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZGVzdHJveWVkID0gITAsIHRoaXMuYnVmZmVyLmZpbGwoMCksIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDApO1xuICB9XG59XG5jb25zdCB1ZiA9IG50KCgpID0+IG5ldyBjZigpKSwgYnIgPSB1ZS5Qcm9qZWN0aXZlUG9pbnQsIGxuID0gQXMoanIpO1xuZnVuY3Rpb24gWWkodCkge1xuICByZXR1cm4gQmlnSW50KGAweCR7bmkodCl9YCk7XG59XG5mdW5jdGlvbiBsZih0KSB7XG4gIHJldHVybiBXcyh0LnRvU3RyaW5nKDE2KS5wYWRTdGFydCg2NCwgXCIwXCIpKTtcbn1cbmNvbnN0IGZmID0gaWkoXCJCaXRjb2luIHNlZWRcIiksIGZuID0geyBwcml2YXRlOiA3NjA2NjI3NiwgcHVibGljOiA3NjA2NzM1OCB9LCBobiA9IDIxNDc0ODM2NDgsIGhmID0gKHQpID0+IHVmKGpyKHQpKSwgZGYgPSAodCkgPT4gZnQodCkuZ2V0VWludDMyKDAsICExKSwgdnIgPSAodCkgPT4ge1xuICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKHQpIHx8IHQgPCAwIHx8IHQgPiAyICoqIDMyIC0gMSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbnVtYmVyPSR7dH0uIFNob3VsZCBiZSBmcm9tIDAgdG8gMiAqKiAzMiAtIDFgKTtcbiAgY29uc3QgZSA9IG5ldyBVaW50OEFycmF5KDQpO1xuICByZXR1cm4gZnQoZSkuc2V0VWludDMyKDAsIHQsICExKSwgZTtcbn07XG5jbGFzcyBjdCB7XG4gIGdldCBmaW5nZXJwcmludCgpIHtcbiAgICBpZiAoIXRoaXMucHViSGFzaClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHB1YmxpY0tleSBzZXQhXCIpO1xuICAgIHJldHVybiBkZih0aGlzLnB1Ykhhc2gpO1xuICB9XG4gIGdldCBpZGVudGlmaWVyKCkge1xuICAgIHJldHVybiB0aGlzLnB1Ykhhc2g7XG4gIH1cbiAgZ2V0IHB1YktleUhhc2goKSB7XG4gICAgcmV0dXJuIHRoaXMucHViSGFzaDtcbiAgfVxuICBnZXQgcHJpdmF0ZUtleSgpIHtcbiAgICByZXR1cm4gdGhpcy5wcml2S2V5Qnl0ZXMgfHwgbnVsbDtcbiAgfVxuICBnZXQgcHVibGljS2V5KCkge1xuICAgIHJldHVybiB0aGlzLnB1YktleSB8fCBudWxsO1xuICB9XG4gIGdldCBwcml2YXRlRXh0ZW5kZWRLZXkoKSB7XG4gICAgY29uc3QgZSA9IHRoaXMucHJpdmF0ZUtleTtcbiAgICBpZiAoIWUpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBwcml2YXRlIGtleVwiKTtcbiAgICByZXR1cm4gbG4uZW5jb2RlKHRoaXMuc2VyaWFsaXplKHRoaXMudmVyc2lvbnMucHJpdmF0ZSwgZXIobmV3IFVpbnQ4QXJyYXkoWzBdKSwgZSkpKTtcbiAgfVxuICBnZXQgcHVibGljRXh0ZW5kZWRLZXkoKSB7XG4gICAgaWYgKCF0aGlzLnB1YktleSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHB1YmxpYyBrZXlcIik7XG4gICAgcmV0dXJuIGxuLmVuY29kZSh0aGlzLnNlcmlhbGl6ZSh0aGlzLnZlcnNpb25zLnB1YmxpYywgdGhpcy5wdWJLZXkpKTtcbiAgfVxuICBzdGF0aWMgZnJvbU1hc3RlclNlZWQoZSwgciA9IGZuKSB7XG4gICAgaWYgKFllKGUpLCA4ICogZS5sZW5ndGggPCAxMjggfHwgOCAqIGUubGVuZ3RoID4gNTEyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBIREtleTogd3Jvbmcgc2VlZCBsZW5ndGg9JHtlLmxlbmd0aH0uIFNob3VsZCBiZSBiZXR3ZWVuIDEyOCBhbmQgNTEyIGJpdHM7IDI1NiBiaXRzIGlzIGFkdmlzZWQpYCk7XG4gICAgY29uc3QgbiA9IE5uKHFuLCBmZiwgZSk7XG4gICAgcmV0dXJuIG5ldyBjdCh7XG4gICAgICB2ZXJzaW9uczogcixcbiAgICAgIGNoYWluQ29kZTogbi5zbGljZSgzMiksXG4gICAgICBwcml2YXRlS2V5OiBuLnNsaWNlKDAsIDMyKVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBmcm9tRXh0ZW5kZWRLZXkoZSwgciA9IGZuKSB7XG4gICAgY29uc3QgbiA9IGxuLmRlY29kZShlKSwgaSA9IGZ0KG4pLCBzID0gaS5nZXRVaW50MzIoMCwgITEpLCBvID0ge1xuICAgICAgdmVyc2lvbnM6IHIsXG4gICAgICBkZXB0aDogbls0XSxcbiAgICAgIHBhcmVudEZpbmdlcnByaW50OiBpLmdldFVpbnQzMig1LCAhMSksXG4gICAgICBpbmRleDogaS5nZXRVaW50MzIoOSwgITEpLFxuICAgICAgY2hhaW5Db2RlOiBuLnNsaWNlKDEzLCA0NSlcbiAgICB9LCBhID0gbi5zbGljZSg0NSksIGMgPSBhWzBdID09PSAwO1xuICAgIGlmIChzICE9PSByW2MgPyBcInByaXZhdGVcIiA6IFwicHVibGljXCJdKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmVyc2lvbiBtaXNtYXRjaFwiKTtcbiAgICByZXR1cm4gYyA/IG5ldyBjdCh7IC4uLm8sIHByaXZhdGVLZXk6IGEuc2xpY2UoMSkgfSkgOiBuZXcgY3QoeyAuLi5vLCBwdWJsaWNLZXk6IGEgfSk7XG4gIH1cbiAgc3RhdGljIGZyb21KU09OKGUpIHtcbiAgICByZXR1cm4gY3QuZnJvbUV4dGVuZGVkS2V5KGUueHByaXYpO1xuICB9XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBpZiAodGhpcy5kZXB0aCA9IDAsIHRoaXMuaW5kZXggPSAwLCB0aGlzLmNoYWluQ29kZSA9IG51bGwsIHRoaXMucGFyZW50RmluZ2VycHJpbnQgPSAwLCAhZSB8fCB0eXBlb2YgZSAhPSBcIm9iamVjdFwiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSERLZXkuY29uc3RydWN0b3IgbXVzdCBub3QgYmUgY2FsbGVkIGRpcmVjdGx5XCIpO1xuICAgIGlmICh0aGlzLnZlcnNpb25zID0gZS52ZXJzaW9ucyB8fCBmbiwgdGhpcy5kZXB0aCA9IGUuZGVwdGggfHwgMCwgdGhpcy5jaGFpbkNvZGUgPSBlLmNoYWluQ29kZSwgdGhpcy5pbmRleCA9IGUuaW5kZXggfHwgMCwgdGhpcy5wYXJlbnRGaW5nZXJwcmludCA9IGUucGFyZW50RmluZ2VycHJpbnQgfHwgMCwgIXRoaXMuZGVwdGggJiYgKHRoaXMucGFyZW50RmluZ2VycHJpbnQgfHwgdGhpcy5pbmRleCkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJIREtleTogemVybyBkZXB0aCB3aXRoIG5vbi16ZXJvIGluZGV4L3BhcmVudCBmaW5nZXJwcmludFwiKTtcbiAgICBpZiAoZS5wdWJsaWNLZXkgJiYgZS5wcml2YXRlS2V5KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSERLZXk6IHB1YmxpY0tleSBhbmQgcHJpdmF0ZUtleSBhdCBzYW1lIHRpbWUuXCIpO1xuICAgIGlmIChlLnByaXZhdGVLZXkpIHtcbiAgICAgIGlmICghdWUudXRpbHMuaXNWYWxpZFByaXZhdGVLZXkoZS5wcml2YXRlS2V5KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwcml2YXRlIGtleVwiKTtcbiAgICAgIHRoaXMucHJpdktleSA9IHR5cGVvZiBlLnByaXZhdGVLZXkgPT0gXCJiaWdpbnRcIiA/IGUucHJpdmF0ZUtleSA6IFlpKGUucHJpdmF0ZUtleSksIHRoaXMucHJpdktleUJ5dGVzID0gbGYodGhpcy5wcml2S2V5KSwgdGhpcy5wdWJLZXkgPSB1ZS5nZXRQdWJsaWNLZXkoZS5wcml2YXRlS2V5LCAhMCk7XG4gICAgfSBlbHNlIGlmIChlLnB1YmxpY0tleSlcbiAgICAgIHRoaXMucHViS2V5ID0gYnIuZnJvbUhleChlLnB1YmxpY0tleSkudG9SYXdCeXRlcyghMCk7XG4gICAgZWxzZVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSERLZXk6IG5vIHB1YmxpYyBvciBwcml2YXRlIGtleSBwcm92aWRlZFwiKTtcbiAgICB0aGlzLnB1Ykhhc2ggPSBoZih0aGlzLnB1YktleSk7XG4gIH1cbiAgZGVyaXZlKGUpIHtcbiAgICBpZiAoIS9eW21NXSc/Ly50ZXN0KGUpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXRoIG11c3Qgc3RhcnQgd2l0aCBcIm1cIiBvciBcIk1cIicpO1xuICAgIGlmICgvXlttTV0nPyQvLnRlc3QoZSkpXG4gICAgICByZXR1cm4gdGhpcztcbiAgICBjb25zdCByID0gZS5yZXBsYWNlKC9eW21NXSc/XFwvLywgXCJcIikuc3BsaXQoXCIvXCIpO1xuICAgIGxldCBuID0gdGhpcztcbiAgICBmb3IgKGNvbnN0IGkgb2Ygcikge1xuICAgICAgY29uc3QgcyA9IC9eKFxcZCspKCc/KSQvLmV4ZWMoaSk7XG4gICAgICBpZiAoIXMgfHwgcy5sZW5ndGggIT09IDMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjaGlsZCBpbmRleDogJHtpfWApO1xuICAgICAgbGV0IG8gPSArc1sxXTtcbiAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobykgfHwgbyA+PSBobilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbmRleFwiKTtcbiAgICAgIHNbMl0gPT09IFwiJ1wiICYmIChvICs9IGhuKSwgbiA9IG4uZGVyaXZlQ2hpbGQobyk7XG4gICAgfVxuICAgIHJldHVybiBuO1xuICB9XG4gIGRlcml2ZUNoaWxkKGUpIHtcbiAgICBpZiAoIXRoaXMucHViS2V5IHx8ICF0aGlzLmNoYWluQ29kZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHB1YmxpY0tleSBvciBjaGFpbkNvZGUgc2V0XCIpO1xuICAgIGxldCByID0gdnIoZSk7XG4gICAgaWYgKGUgPj0gaG4pIHtcbiAgICAgIGNvbnN0IGEgPSB0aGlzLnByaXZhdGVLZXk7XG4gICAgICBpZiAoIWEpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBkZXJpdmUgaGFyZGVuZWQgY2hpbGQga2V5XCIpO1xuICAgICAgciA9IGVyKG5ldyBVaW50OEFycmF5KFswXSksIGEsIHIpO1xuICAgIH0gZWxzZVxuICAgICAgciA9IGVyKHRoaXMucHViS2V5LCByKTtcbiAgICBjb25zdCBuID0gTm4ocW4sIHRoaXMuY2hhaW5Db2RlLCByKSwgaSA9IFlpKG4uc2xpY2UoMCwgMzIpKSwgcyA9IG4uc2xpY2UoMzIpO1xuICAgIGlmICghdWUudXRpbHMuaXNWYWxpZFByaXZhdGVLZXkoaSkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUd2VhayBiaWdnZXIgdGhhbiBjdXJ2ZSBvcmRlclwiKTtcbiAgICBjb25zdCBvID0ge1xuICAgICAgdmVyc2lvbnM6IHRoaXMudmVyc2lvbnMsXG4gICAgICBjaGFpbkNvZGU6IHMsXG4gICAgICBkZXB0aDogdGhpcy5kZXB0aCArIDEsXG4gICAgICBwYXJlbnRGaW5nZXJwcmludDogdGhpcy5maW5nZXJwcmludCxcbiAgICAgIGluZGV4OiBlXG4gICAgfTtcbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMucHJpdmF0ZUtleSkge1xuICAgICAgICBjb25zdCBhID0gSih0aGlzLnByaXZLZXkgKyBpLCB1ZS5DVVJWRS5uKTtcbiAgICAgICAgaWYgKCF1ZS51dGlscy5pc1ZhbGlkUHJpdmF0ZUtleShhKSlcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgdHdlYWsgd2FzIG91dCBvZiByYW5nZSBvciB0aGUgcmVzdWx0ZWQgcHJpdmF0ZSBrZXkgaXMgaW52YWxpZFwiKTtcbiAgICAgICAgby5wcml2YXRlS2V5ID0gYTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGEgPSBici5mcm9tSGV4KHRoaXMucHViS2V5KS5hZGQoYnIuZnJvbVByaXZhdGVLZXkoaSkpO1xuICAgICAgICBpZiAoYS5lcXVhbHMoYnIuWkVSTykpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHR3ZWFrIHdhcyBlcXVhbCB0byBuZWdhdGl2ZSBQLCB3aGljaCBtYWRlIHRoZSByZXN1bHQga2V5IGludmFsaWRcIik7XG4gICAgICAgIG8ucHVibGljS2V5ID0gYS50b1Jhd0J5dGVzKCEwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgY3Qobyk7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gdGhpcy5kZXJpdmVDaGlsZChlICsgMSk7XG4gICAgfVxuICB9XG4gIHNpZ24oZSkge1xuICAgIGlmICghdGhpcy5wcml2YXRlS2V5KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gcHJpdmF0ZUtleSBzZXQhXCIpO1xuICAgIHJldHVybiBZZShlLCAzMiksIHVlLnNpZ24oZSwgdGhpcy5wcml2S2V5KS50b0NvbXBhY3RSYXdCeXRlcygpO1xuICB9XG4gIHZlcmlmeShlLCByKSB7XG4gICAgaWYgKFllKGUsIDMyKSwgWWUociwgNjQpLCAhdGhpcy5wdWJsaWNLZXkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBwdWJsaWNLZXkgc2V0IVwiKTtcbiAgICBsZXQgbjtcbiAgICB0cnkge1xuICAgICAgbiA9IHVlLlNpZ25hdHVyZS5mcm9tQ29tcGFjdChyKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gICAgcmV0dXJuIHVlLnZlcmlmeShuLCBlLCB0aGlzLnB1YmxpY0tleSk7XG4gIH1cbiAgd2lwZVByaXZhdGVEYXRhKCkge1xuICAgIHJldHVybiB0aGlzLnByaXZLZXkgPSB2b2lkIDAsIHRoaXMucHJpdktleUJ5dGVzICYmICh0aGlzLnByaXZLZXlCeXRlcy5maWxsKDApLCB0aGlzLnByaXZLZXlCeXRlcyA9IHZvaWQgMCksIHRoaXM7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICB4cHJpdjogdGhpcy5wcml2YXRlRXh0ZW5kZWRLZXksXG4gICAgICB4cHViOiB0aGlzLnB1YmxpY0V4dGVuZGVkS2V5XG4gICAgfTtcbiAgfVxuICBzZXJpYWxpemUoZSwgcikge1xuICAgIGlmICghdGhpcy5jaGFpbkNvZGUpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBjaGFpbkNvZGUgc2V0XCIpO1xuICAgIHJldHVybiBZZShyLCAzMyksIGVyKHZyKGUpLCBuZXcgVWludDhBcnJheShbdGhpcy5kZXB0aF0pLCB2cih0aGlzLnBhcmVudEZpbmdlcnByaW50KSwgdnIodGhpcy5pbmRleCksIHRoaXMuY2hhaW5Db2RlLCByKTtcbiAgfVxufVxudmFyIHBmID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LCBpZSA9ICh0LCBlKSA9PiB7XG4gIGZvciAodmFyIHIgaW4gZSlcbiAgICBwZih0LCByLCB7IGdldDogZVtyXSwgZW51bWVyYWJsZTogITAgfSk7XG59O1xuZnVuY3Rpb24geWYoKSB7XG4gIHJldHVybiB2ZShTdC51dGlscy5yYW5kb21Qcml2YXRlS2V5KCkpO1xufVxuZnVuY3Rpb24gbGkodCkge1xuICByZXR1cm4gdmUoU3QuZ2V0UHVibGljS2V5KHQpKTtcbn1cbnZhciBnZiA9IHt9O1xuaWUoZ2YsIHtcbiAgTWVzc2FnZU5vZGU6ICgpID0+IGZhLFxuICBNZXNzYWdlUXVldWU6ICgpID0+IGhhLFxuICBpbnNlcnRFdmVudEludG9Bc2NlbmRpbmdMaXN0OiAoKSA9PiB3ZixcbiAgaW5zZXJ0RXZlbnRJbnRvRGVzY2VuZGluZ0xpc3Q6ICgpID0+IHZmLFxuICBub3JtYWxpemVVUkw6ICgpID0+IGJmLFxuICB1dGY4RGVjb2RlcjogKCkgPT4gSmUsXG4gIHV0ZjhFbmNvZGVyOiAoKSA9PiBJZVxufSk7XG52YXIgSmUgPSBuZXcgVGV4dERlY29kZXIoXCJ1dGYtOFwiKSwgSWUgPSBuZXcgVGV4dEVuY29kZXIoKTtcbmZ1bmN0aW9uIGJmKHQpIHtcbiAgbGV0IGUgPSBuZXcgVVJMKHQpO1xuICByZXR1cm4gZS5wYXRobmFtZSA9IGUucGF0aG5hbWUucmVwbGFjZSgvXFwvKy9nLCBcIi9cIiksIGUucGF0aG5hbWUuZW5kc1dpdGgoXCIvXCIpICYmIChlLnBhdGhuYW1lID0gZS5wYXRobmFtZS5zbGljZSgwLCAtMSkpLCAoZS5wb3J0ID09PSBcIjgwXCIgJiYgZS5wcm90b2NvbCA9PT0gXCJ3czpcIiB8fCBlLnBvcnQgPT09IFwiNDQzXCIgJiYgZS5wcm90b2NvbCA9PT0gXCJ3c3M6XCIpICYmIChlLnBvcnQgPSBcIlwiKSwgZS5zZWFyY2hQYXJhbXMuc29ydCgpLCBlLmhhc2ggPSBcIlwiLCBlLnRvU3RyaW5nKCk7XG59XG5mdW5jdGlvbiB2Zih0LCBlKSB7XG4gIHZhciBvO1xuICBsZXQgciA9IDAsIG4gPSB0Lmxlbmd0aCAtIDEsIGksIHMgPSByO1xuICBpZiAobiA8IDApXG4gICAgcyA9IDA7XG4gIGVsc2UgaWYgKGUuY3JlYXRlZF9hdCA8IHRbbl0uY3JlYXRlZF9hdClcbiAgICBzID0gbiArIDE7XG4gIGVsc2UgaWYgKGUuY3JlYXRlZF9hdCA+PSB0W3JdLmNyZWF0ZWRfYXQpXG4gICAgcyA9IHI7XG4gIGVsc2VcbiAgICBmb3IgKDsgOyApIHtcbiAgICAgIGlmIChuIDw9IHIgKyAxKSB7XG4gICAgICAgIHMgPSBuO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChpID0gTWF0aC5mbG9vcihyICsgKG4gLSByKSAvIDIpLCB0W2ldLmNyZWF0ZWRfYXQgPiBlLmNyZWF0ZWRfYXQpXG4gICAgICAgIHIgPSBpO1xuICAgICAgZWxzZSBpZiAodFtpXS5jcmVhdGVkX2F0IDwgZS5jcmVhdGVkX2F0KVxuICAgICAgICBuID0gaTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBzID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICByZXR1cm4gKChvID0gdFtzXSkgPT0gbnVsbCA/IHZvaWQgMCA6IG8uaWQpICE9PSBlLmlkID8gW1xuICAgIC4uLnQuc2xpY2UoMCwgcyksXG4gICAgZSxcbiAgICAuLi50LnNsaWNlKHMpXG4gIF0gOiB0O1xufVxuZnVuY3Rpb24gd2YodCwgZSkge1xuICB2YXIgbztcbiAgbGV0IHIgPSAwLCBuID0gdC5sZW5ndGggLSAxLCBpLCBzID0gcjtcbiAgaWYgKG4gPCAwKVxuICAgIHMgPSAwO1xuICBlbHNlIGlmIChlLmNyZWF0ZWRfYXQgPiB0W25dLmNyZWF0ZWRfYXQpXG4gICAgcyA9IG4gKyAxO1xuICBlbHNlIGlmIChlLmNyZWF0ZWRfYXQgPD0gdFtyXS5jcmVhdGVkX2F0KVxuICAgIHMgPSByO1xuICBlbHNlXG4gICAgZm9yICg7IDsgKSB7XG4gICAgICBpZiAobiA8PSByICsgMSkge1xuICAgICAgICBzID0gbjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoaSA9IE1hdGguZmxvb3IociArIChuIC0gcikgLyAyKSwgdFtpXS5jcmVhdGVkX2F0IDwgZS5jcmVhdGVkX2F0KVxuICAgICAgICByID0gaTtcbiAgICAgIGVsc2UgaWYgKHRbaV0uY3JlYXRlZF9hdCA+IGUuY3JlYXRlZF9hdClcbiAgICAgICAgbiA9IGk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgcyA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgcmV0dXJuICgobyA9IHRbc10pID09IG51bGwgPyB2b2lkIDAgOiBvLmlkKSAhPT0gZS5pZCA/IFtcbiAgICAuLi50LnNsaWNlKDAsIHMpLFxuICAgIGUsXG4gICAgLi4udC5zbGljZShzKVxuICBdIDogdDtcbn1cbnZhciBmYSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IodCkge1xuICAgIEkodGhpcywgXCJfdmFsdWVcIik7XG4gICAgSSh0aGlzLCBcIl9uZXh0XCIpO1xuICAgIHRoaXMuX3ZhbHVlID0gdCwgdGhpcy5fbmV4dCA9IG51bGw7XG4gIH1cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgfVxuICBzZXQgdmFsdWUodCkge1xuICAgIHRoaXMuX3ZhbHVlID0gdDtcbiAgfVxuICBnZXQgbmV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbmV4dDtcbiAgfVxuICBzZXQgbmV4dCh0KSB7XG4gICAgdGhpcy5fbmV4dCA9IHQ7XG4gIH1cbn0sIGhhID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBJKHRoaXMsIFwiX2ZpcnN0XCIpO1xuICAgIEkodGhpcywgXCJfbGFzdFwiKTtcbiAgICBJKHRoaXMsIFwiX3NpemVcIik7XG4gICAgdGhpcy5fZmlyc3QgPSBudWxsLCB0aGlzLl9sYXN0ID0gbnVsbCwgdGhpcy5fc2l6ZSA9IDA7XG4gIH1cbiAgZ2V0IGZpcnN0KCkge1xuICAgIHJldHVybiB0aGlzLl9maXJzdDtcbiAgfVxuICBzZXQgZmlyc3QodCkge1xuICAgIHRoaXMuX2ZpcnN0ID0gdDtcbiAgfVxuICBnZXQgbGFzdCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbGFzdDtcbiAgfVxuICBzZXQgbGFzdCh0KSB7XG4gICAgdGhpcy5fbGFzdCA9IHQ7XG4gIH1cbiAgZ2V0IHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NpemU7XG4gIH1cbiAgc2V0IHNpemUodCkge1xuICAgIHRoaXMuX3NpemUgPSB0O1xuICB9XG4gIGVucXVldWUodCkge1xuICAgIGNvbnN0IGUgPSBuZXcgZmEodCk7XG4gICAgcmV0dXJuIHRoaXMuX3NpemUgPT09IDAgfHwgIXRoaXMuX2xhc3QgPyAodGhpcy5fZmlyc3QgPSBlLCB0aGlzLl9sYXN0ID0gZSkgOiAodGhpcy5fbGFzdC5uZXh0ID0gZSwgdGhpcy5fbGFzdCA9IGUpLCB0aGlzLl9zaXplKyssICEwO1xuICB9XG4gIGRlcXVldWUoKSB7XG4gICAgaWYgKHRoaXMuX3NpemUgPT09IDAgfHwgIXRoaXMuX2ZpcnN0KVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHQgPSB0aGlzLl9maXJzdDtcbiAgICByZXR1cm4gdGhpcy5fZmlyc3QgPSB0Lm5leHQsIHQubmV4dCA9IG51bGwsIHRoaXMuX3NpemUtLSwgdC52YWx1ZTtcbiAgfVxufTtcbmZ1bmN0aW9uIGRhKHQsIGUpIHtcbiAgbGV0IHIgPSB0O1xuICByZXR1cm4gci5wdWJrZXkgPSBsaShlKSwgci5pZCA9IEhyKHIpLCByLnNpZyA9IHBhKHIsIGUpLCByO1xufVxuZnVuY3Rpb24gX2YodCkge1xuICBpZiAoIWZpKHQpKVxuICAgIHRocm93IG5ldyBFcnJvcihcImNhbid0IHNlcmlhbGl6ZSBldmVudCB3aXRoIHdyb25nIG9yIG1pc3NpbmcgcHJvcGVydGllc1wiKTtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KFtcbiAgICAwLFxuICAgIHQucHVia2V5LFxuICAgIHQuY3JlYXRlZF9hdCxcbiAgICB0LmtpbmQsXG4gICAgdC50YWdzLFxuICAgIHQuY29udGVudFxuICBdKTtcbn1cbmZ1bmN0aW9uIEhyKHQpIHtcbiAgbGV0IGUgPSBZbihJZS5lbmNvZGUoX2YodCkpKTtcbiAgcmV0dXJuIHZlKGUpO1xufVxudmFyIG1mID0gKHQpID0+IHQgaW5zdGFuY2VvZiBPYmplY3Q7XG5mdW5jdGlvbiBmaSh0KSB7XG4gIGlmICghbWYodCkgfHwgdHlwZW9mIHQua2luZCAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiB0LmNvbnRlbnQgIT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdC5jcmVhdGVkX2F0ICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIHQucHVia2V5ICE9IFwic3RyaW5nXCIgfHwgIXQucHVia2V5Lm1hdGNoKC9eW2EtZjAtOV17NjR9JC8pIHx8ICFBcnJheS5pc0FycmF5KHQudGFncykpXG4gICAgcmV0dXJuICExO1xuICBmb3IgKGxldCBlID0gMDsgZSA8IHQudGFncy5sZW5ndGg7IGUrKykge1xuICAgIGxldCByID0gdC50YWdzW2VdO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShyKSlcbiAgICAgIHJldHVybiAhMTtcbiAgICBmb3IgKGxldCBuID0gMDsgbiA8IHIubGVuZ3RoOyBuKyspXG4gICAgICBpZiAodHlwZW9mIHJbbl0gPT0gXCJvYmplY3RcIilcbiAgICAgICAgcmV0dXJuICExO1xuICB9XG4gIHJldHVybiAhMDtcbn1cbmZ1bmN0aW9uIGhpKHQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gU3QudmVyaWZ5KHQuc2lnLCBIcih0KSwgdC5wdWJrZXkpO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gITE7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhKHQsIGUpIHtcbiAgcmV0dXJuIHZlKFN0LnNpZ24oSHIodCksIGUpKTtcbn1cbmZ1bmN0aW9uIHlhKHQsIGUpIHtcbiAgaWYgKHQuaWRzICYmIHQuaWRzLmluZGV4T2YoZS5pZCkgPT09IC0xICYmICF0Lmlkcy5zb21lKChyKSA9PiBlLmlkLnN0YXJ0c1dpdGgocikpIHx8IHQua2luZHMgJiYgdC5raW5kcy5pbmRleE9mKGUua2luZCkgPT09IC0xIHx8IHQuYXV0aG9ycyAmJiB0LmF1dGhvcnMuaW5kZXhPZihlLnB1YmtleSkgPT09IC0xICYmICF0LmF1dGhvcnMuc29tZSgocikgPT4gZS5wdWJrZXkuc3RhcnRzV2l0aChyKSkpXG4gICAgcmV0dXJuICExO1xuICBmb3IgKGxldCByIGluIHQpXG4gICAgaWYgKHJbMF0gPT09IFwiI1wiKSB7XG4gICAgICBsZXQgbiA9IHIuc2xpY2UoMSksIGkgPSB0W2AjJHtufWBdO1xuICAgICAgaWYgKGkgJiYgIWUudGFncy5maW5kKFxuICAgICAgICAoW3MsIG9dKSA9PiBzID09PSByLnNsaWNlKDEpICYmIGkuaW5kZXhPZihvKSAhPT0gLTFcbiAgICAgICkpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gIHJldHVybiAhKHQuc2luY2UgJiYgZS5jcmVhdGVkX2F0IDwgdC5zaW5jZSB8fCB0LnVudGlsICYmIGUuY3JlYXRlZF9hdCA+PSB0LnVudGlsKTtcbn1cbmZ1bmN0aW9uIHhmKHQsIGUpIHtcbiAgZm9yIChsZXQgciA9IDA7IHIgPCB0Lmxlbmd0aDsgcisrKVxuICAgIGlmICh5YSh0W3JdLCBlKSlcbiAgICAgIHJldHVybiAhMDtcbiAgcmV0dXJuICExO1xufVxudmFyIEVmID0ge307XG5pZShFZiwge1xuICBnZXRIZXg2NDogKCkgPT4gTXIsXG4gIGdldEludDogKCkgPT4gZ2EsXG4gIGdldFN1YnNjcmlwdGlvbklkOiAoKSA9PiBiYSxcbiAgbWF0Y2hFdmVudElkOiAoKSA9PiBrZixcbiAgbWF0Y2hFdmVudEtpbmQ6ICgpID0+IE9mLFxuICBtYXRjaEV2ZW50UHVia2V5OiAoKSA9PiBTZlxufSk7XG5mdW5jdGlvbiBNcih0LCBlKSB7XG4gIGxldCByID0gZS5sZW5ndGggKyAzLCBuID0gdC5pbmRleE9mKGBcIiR7ZX1cIjpgKSArIHIsIGkgPSB0LnNsaWNlKG4pLmluZGV4T2YoJ1wiJykgKyBuICsgMTtcbiAgcmV0dXJuIHQuc2xpY2UoaSwgaSArIDY0KTtcbn1cbmZ1bmN0aW9uIGdhKHQsIGUpIHtcbiAgbGV0IHIgPSBlLmxlbmd0aCwgbiA9IHQuaW5kZXhPZihgXCIke2V9XCI6YCkgKyByICsgMywgaSA9IHQuc2xpY2UobiksIHMgPSBNYXRoLm1pbihpLmluZGV4T2YoXCIsXCIpLCBpLmluZGV4T2YoXCJ9XCIpKTtcbiAgcmV0dXJuIHBhcnNlSW50KGkuc2xpY2UoMCwgcyksIDEwKTtcbn1cbmZ1bmN0aW9uIGJhKHQpIHtcbiAgbGV0IGUgPSB0LnNsaWNlKDAsIDIyKS5pbmRleE9mKCdcIkVWRU5UXCInKTtcbiAgaWYgKGUgPT09IC0xKVxuICAgIHJldHVybiBudWxsO1xuICBsZXQgciA9IHQuc2xpY2UoZSArIDcgKyAxKS5pbmRleE9mKCdcIicpO1xuICBpZiAociA9PT0gLTEpXG4gICAgcmV0dXJuIG51bGw7XG4gIGxldCBuID0gZSArIDcgKyAxICsgciwgaSA9IHQuc2xpY2UobiArIDEsIDgwKS5pbmRleE9mKCdcIicpO1xuICBpZiAoaSA9PT0gLTEpXG4gICAgcmV0dXJuIG51bGw7XG4gIGxldCBzID0gbiArIDEgKyBpO1xuICByZXR1cm4gdC5zbGljZShuICsgMSwgcyk7XG59XG5mdW5jdGlvbiBrZih0LCBlKSB7XG4gIHJldHVybiBlID09PSBNcih0LCBcImlkXCIpO1xufVxuZnVuY3Rpb24gU2YodCwgZSkge1xuICByZXR1cm4gZSA9PT0gTXIodCwgXCJwdWJrZXlcIik7XG59XG5mdW5jdGlvbiBPZih0LCBlKSB7XG4gIHJldHVybiBlID09PSBnYSh0LCBcImtpbmRcIik7XG59XG52YXIgSmkgPSAoKSA9PiAoe1xuICBjb25uZWN0OiBbXSxcbiAgZGlzY29ubmVjdDogW10sXG4gIGVycm9yOiBbXSxcbiAgbm90aWNlOiBbXSxcbiAgYXV0aDogW11cbn0pO1xuZnVuY3Rpb24gQWYodCwgZSA9IHt9KSB7XG4gIGxldCB7IGxpc3RUaW1lb3V0OiByID0gM2UzLCBnZXRUaW1lb3V0OiBuID0gM2UzLCBjb3VudFRpbWVvdXQ6IGkgPSAzZTMgfSA9IGU7XG4gIHZhciBzLCBvID0ge30sIGEgPSBKaSgpLCBjID0ge30sIGwgPSB7fSwgZjtcbiAgYXN5bmMgZnVuY3Rpb24gdSgpIHtcbiAgICByZXR1cm4gZiB8fCAoZiA9IG5ldyBQcm9taXNlKCh2LCBfKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBzID0gbmV3IFdlYlNvY2tldCh0KTtcbiAgICAgIH0gY2F0Y2ggKHcpIHtcbiAgICAgICAgXyh3KTtcbiAgICAgIH1cbiAgICAgIHMub25vcGVuID0gKCkgPT4ge1xuICAgICAgICBhLmNvbm5lY3QuZm9yRWFjaCgodykgPT4gdygpKSwgdigpO1xuICAgICAgfSwgcy5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICBmID0gdm9pZCAwLCBhLmVycm9yLmZvckVhY2goKHcpID0+IHcoKSksIF8oKTtcbiAgICAgIH0sIHMub25jbG9zZSA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgZiA9IHZvaWQgMCwgYS5kaXNjb25uZWN0LmZvckVhY2goKHcpID0+IHcoKSk7XG4gICAgICB9O1xuICAgICAgbGV0IG0gPSBuZXcgaGEoKSwgQztcbiAgICAgIHMub25tZXNzYWdlID0gKHcpID0+IHtcbiAgICAgICAgbS5lbnF1ZXVlKHcuZGF0YSksIEMgfHwgKEMgPSBzZXRJbnRlcnZhbChPLCAwKSk7XG4gICAgICB9O1xuICAgICAgZnVuY3Rpb24gTygpIHtcbiAgICAgICAgdmFyIEEsIEIsIEw7XG4gICAgICAgIGlmIChtLnNpemUgPT09IDApIHtcbiAgICAgICAgICBjbGVhckludGVydmFsKEMpLCBDID0gbnVsbDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHcgPSBtLmRlcXVldWUoKTtcbiAgICAgICAgaWYgKCF3KVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IHggPSBiYSh3KTtcbiAgICAgICAgaWYgKHgpIHtcbiAgICAgICAgICBsZXQgUCA9IG9beF07XG4gICAgICAgICAgaWYgKFAgJiYgUC5hbHJlYWR5SGF2ZUV2ZW50ICYmIFAuYWxyZWFkeUhhdmVFdmVudChNcih3LCBcImlkXCIpLCB0KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGxldCBQID0gSlNPTi5wYXJzZSh3KTtcbiAgICAgICAgICBzd2l0Y2ggKFBbMF0pIHtcbiAgICAgICAgICAgIGNhc2UgXCJFVkVOVFwiOiB7XG4gICAgICAgICAgICAgIGxldCBFID0gUFsxXSwgUiA9IFBbMl07XG4gICAgICAgICAgICAgIGZpKFIpICYmIG9bRV0gJiYgKG9bRV0uc2tpcFZlcmlmaWNhdGlvbiB8fCBoaShSKSkgJiYgeGYob1tFXS5maWx0ZXJzLCBSKSAmJiAob1tFXSwgKCgoQSA9IGNbRV0pID09IG51bGwgPyB2b2lkIDAgOiBBLmV2ZW50KSB8fCBbXSkuZm9yRWFjaCgocSkgPT4gcShSKSkpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiQ09VTlRcIjpcbiAgICAgICAgICAgICAgbGV0IEYgPSBQWzFdLCB6ID0gUFsyXTtcbiAgICAgICAgICAgICAgb1tGXSAmJiAoKChCID0gY1tGXSkgPT0gbnVsbCA/IHZvaWQgMCA6IEIuY291bnQpIHx8IFtdKS5mb3JFYWNoKChFKSA9PiBFKHopKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSBcIkVPU0VcIjoge1xuICAgICAgICAgICAgICBsZXQgRSA9IFBbMV07XG4gICAgICAgICAgICAgIEUgaW4gYyAmJiAoY1tFXS5lb3NlLmZvckVhY2goKFIpID0+IFIoKSksIGNbRV0uZW9zZSA9IFtdKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcIk9LXCI6IHtcbiAgICAgICAgICAgICAgbGV0IEUgPSBQWzFdLCBSID0gUFsyXSwgcSA9IFBbM10gfHwgXCJcIjtcbiAgICAgICAgICAgICAgRSBpbiBsICYmIChSID8gbFtFXS5vay5mb3JFYWNoKChIKSA9PiBIKCkpIDogbFtFXS5mYWlsZWQuZm9yRWFjaCgoSCkgPT4gSChxKSksIGxbRV0ub2sgPSBbXSwgbFtFXS5mYWlsZWQgPSBbXSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJOT1RJQ0VcIjpcbiAgICAgICAgICAgICAgbGV0IEcgPSBQWzFdO1xuICAgICAgICAgICAgICBhLm5vdGljZS5mb3JFYWNoKChFKSA9PiBFKEcpKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSBcIkFVVEhcIjoge1xuICAgICAgICAgICAgICBsZXQgRSA9IFBbMV07XG4gICAgICAgICAgICAgIChMID0gYS5hdXRoKSA9PSBudWxsIHx8IEwuZm9yRWFjaCgoUikgPT4gUihFKSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pLCBmKTtcbiAgfVxuICBmdW5jdGlvbiBoKCkge1xuICAgIHJldHVybiAocyA9PSBudWxsID8gdm9pZCAwIDogcy5yZWFkeVN0YXRlKSA9PT0gMTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBkKCkge1xuICAgIGgoKSB8fCBhd2FpdCB1KCk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gcCh2KSB7XG4gICAgbGV0IF8gPSBKU09OLnN0cmluZ2lmeSh2KTtcbiAgICBpZiAoISghaCgpICYmIChhd2FpdCBuZXcgUHJvbWlzZSgobSkgPT4gc2V0VGltZW91dChtLCAxZTMpKSwgIWgoKSkpKVxuICAgICAgdHJ5IHtcbiAgICAgICAgcy5zZW5kKF8pO1xuICAgICAgfSBjYXRjaCAobSkge1xuICAgICAgICBjb25zb2xlLmxvZyhtKTtcbiAgICAgIH1cbiAgfVxuICBjb25zdCB5ID0gKHYsIHtcbiAgICB2ZXJiOiBfID0gXCJSRVFcIixcbiAgICBza2lwVmVyaWZpY2F0aW9uOiBtID0gITEsXG4gICAgYWxyZWFkeUhhdmVFdmVudDogQyA9IG51bGwsXG4gICAgaWQ6IE8gPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKCkuc2xpY2UoMilcbiAgfSA9IHt9KSA9PiB7XG4gICAgbGV0IHcgPSBPO1xuICAgIHJldHVybiBvW3ddID0ge1xuICAgICAgaWQ6IHcsXG4gICAgICBmaWx0ZXJzOiB2LFxuICAgICAgc2tpcFZlcmlmaWNhdGlvbjogbSxcbiAgICAgIGFscmVhZHlIYXZlRXZlbnQ6IENcbiAgICB9LCBwKFtfLCB3LCAuLi52XSksIHtcbiAgICAgIHN1YjogKHgsIEEgPSB7fSkgPT4geSh4IHx8IHYsIHtcbiAgICAgICAgc2tpcFZlcmlmaWNhdGlvbjogQS5za2lwVmVyaWZpY2F0aW9uIHx8IG0sXG4gICAgICAgIGFscmVhZHlIYXZlRXZlbnQ6IEEuYWxyZWFkeUhhdmVFdmVudCB8fCBDLFxuICAgICAgICBpZDogd1xuICAgICAgfSksXG4gICAgICB1bnN1YjogKCkgPT4ge1xuICAgICAgICBkZWxldGUgb1t3XSwgZGVsZXRlIGNbd10sIHAoW1wiQ0xPU0VcIiwgd10pO1xuICAgICAgfSxcbiAgICAgIG9uOiAoeCwgQSkgPT4ge1xuICAgICAgICBjW3ddID0gY1t3XSB8fCB7XG4gICAgICAgICAgZXZlbnQ6IFtdLFxuICAgICAgICAgIGNvdW50OiBbXSxcbiAgICAgICAgICBlb3NlOiBbXVxuICAgICAgICB9LCBjW3ddW3hdLnB1c2goQSk7XG4gICAgICB9LFxuICAgICAgb2ZmOiAoeCwgQSkgPT4ge1xuICAgICAgICBsZXQgQiA9IGNbd10sIEwgPSBCW3hdLmluZGV4T2YoQSk7XG4gICAgICAgIEwgPj0gMCAmJiBCW3hdLnNwbGljZShMLCAxKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuICBmdW5jdGlvbiBnKHYsIF8pIHtcbiAgICBpZiAoIXYuaWQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGV2ZW50ICR7dn0gaGFzIG5vIGlkYCk7XG4gICAgbGV0IG0gPSB2LmlkO1xuICAgIHJldHVybiBwKFtfLCB2XSksIHtcbiAgICAgIG9uOiAoQywgTykgPT4ge1xuICAgICAgICBsW21dID0gbFttXSB8fCB7XG4gICAgICAgICAgb2s6IFtdLFxuICAgICAgICAgIGZhaWxlZDogW11cbiAgICAgICAgfSwgbFttXVtDXS5wdXNoKE8pO1xuICAgICAgfSxcbiAgICAgIG9mZjogKEMsIE8pID0+IHtcbiAgICAgICAgbGV0IHcgPSBsW21dO1xuICAgICAgICBpZiAoIXcpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgeCA9IHdbQ10uaW5kZXhPZihPKTtcbiAgICAgICAgeCA+PSAwICYmIHdbQ10uc3BsaWNlKHgsIDEpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB1cmw6IHQsXG4gICAgc3ViOiB5LFxuICAgIG9uOiAodiwgXykgPT4ge1xuICAgICAgYVt2XS5wdXNoKF8pLCB2ID09PSBcImNvbm5lY3RcIiAmJiAocyA9PSBudWxsID8gdm9pZCAwIDogcy5yZWFkeVN0YXRlKSA9PT0gMSAmJiBfKCk7XG4gICAgfSxcbiAgICBvZmY6ICh2LCBfKSA9PiB7XG4gICAgICBsZXQgbSA9IGFbdl0uaW5kZXhPZihfKTtcbiAgICAgIG0gIT09IC0xICYmIGFbdl0uc3BsaWNlKG0sIDEpO1xuICAgIH0sXG4gICAgbGlzdDogKHYsIF8pID0+IG5ldyBQcm9taXNlKChtKSA9PiB7XG4gICAgICBsZXQgQyA9IHkodiwgXyksIE8gPSBbXSwgdyA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBDLnVuc3ViKCksIG0oTyk7XG4gICAgICB9LCByKTtcbiAgICAgIEMub24oXCJlb3NlXCIsICgpID0+IHtcbiAgICAgICAgQy51bnN1YigpLCBjbGVhclRpbWVvdXQodyksIG0oTyk7XG4gICAgICB9KSwgQy5vbihcImV2ZW50XCIsICh4KSA9PiB7XG4gICAgICAgIE8ucHVzaCh4KTtcbiAgICAgIH0pO1xuICAgIH0pLFxuICAgIGdldDogKHYsIF8pID0+IG5ldyBQcm9taXNlKChtKSA9PiB7XG4gICAgICBsZXQgQyA9IHkoW3ZdLCBfKSwgTyA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBDLnVuc3ViKCksIG0obnVsbCk7XG4gICAgICB9LCBuKTtcbiAgICAgIEMub24oXCJldmVudFwiLCAodykgPT4ge1xuICAgICAgICBDLnVuc3ViKCksIGNsZWFyVGltZW91dChPKSwgbSh3KTtcbiAgICAgIH0pO1xuICAgIH0pLFxuICAgIGNvdW50OiAodikgPT4gbmV3IFByb21pc2UoKF8pID0+IHtcbiAgICAgIGxldCBtID0geSh2LCB7IC4uLnksIHZlcmI6IFwiQ09VTlRcIiB9KSwgQyA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBtLnVuc3ViKCksIF8obnVsbCk7XG4gICAgICB9LCBpKTtcbiAgICAgIG0ub24oXCJjb3VudFwiLCAoTykgPT4ge1xuICAgICAgICBtLnVuc3ViKCksIGNsZWFyVGltZW91dChDKSwgXyhPKTtcbiAgICAgIH0pO1xuICAgIH0pLFxuICAgIHB1Ymxpc2godikge1xuICAgICAgcmV0dXJuIGcodiwgXCJFVkVOVFwiKTtcbiAgICB9LFxuICAgIGF1dGgodikge1xuICAgICAgcmV0dXJuIGcodiwgXCJBVVRIXCIpO1xuICAgIH0sXG4gICAgY29ubmVjdDogZCxcbiAgICBjbG9zZSgpIHtcbiAgICAgIGEgPSBKaSgpLCBjID0ge30sIGwgPSB7fSwgcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuT1BFTiAmJiAocyA9PSBudWxsIHx8IHMuY2xvc2UoKSk7XG4gICAgfSxcbiAgICBnZXQgc3RhdHVzKCkge1xuICAgICAgdmFyIHY7XG4gICAgICByZXR1cm4gKHYgPSBzID09IG51bGwgPyB2b2lkIDAgOiBzLnJlYWR5U3RhdGUpICE9IG51bGwgPyB2IDogMztcbiAgICB9XG4gIH07XG59XG52YXIgd2UgPSB7fTtcbmllKHdlLCB7XG4gIEJFQ0gzMl9SRUdFWDogKCkgPT4gdmEsXG4gIGRlY29kZTogKCkgPT4gRHIsXG4gIG5hZGRyRW5jb2RlOiAoKSA9PiBCZixcbiAgbmV2ZW50RW5jb2RlOiAoKSA9PiBQZixcbiAgbm90ZUVuY29kZTogKCkgPT4gUmYsXG4gIG5wcm9maWxlRW5jb2RlOiAoKSA9PiBUZixcbiAgbnB1YkVuY29kZTogKCkgPT4gSWYsXG4gIG5yZWxheUVuY29kZTogKCkgPT4gTGYsXG4gIG5zZWNFbmNvZGU6ICgpID0+IENmXG59KTtcbnZhciBBdCA9IDVlMywgdmEgPSAvW1xceDIxLVxceDdFXXsxLDgzfTFbMDIzNDU2Nzg5YWNkZWZnaGprbG1ucHFyc3R1dnd4eXpdezYsfS87XG5mdW5jdGlvbiBEcih0KSB7XG4gIHZhciBpLCBzLCBvLCBhLCBjLCBsLCBmO1xuICBsZXQgeyBwcmVmaXg6IGUsIHdvcmRzOiByIH0gPSB0ZS5kZWNvZGUodCwgQXQpLCBuID0gbmV3IFVpbnQ4QXJyYXkodGUuZnJvbVdvcmRzKHIpKTtcbiAgc3dpdGNoIChlKSB7XG4gICAgY2FzZSBcIm5wcm9maWxlXCI6IHtcbiAgICAgIGxldCB1ID0gd3Iobik7XG4gICAgICBpZiAoISgoaSA9IHVbMF0pICE9IG51bGwgJiYgaVswXSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgVExWIDAgZm9yIG5wcm9maWxlXCIpO1xuICAgICAgaWYgKHVbMF1bMF0ubGVuZ3RoICE9PSAzMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVExWIDAgc2hvdWxkIGJlIDMyIGJ5dGVzXCIpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJucHJvZmlsZVwiLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgcHVia2V5OiB2ZSh1WzBdWzBdKSxcbiAgICAgICAgICByZWxheXM6IHVbMV0gPyB1WzFdLm1hcCgoaCkgPT4gSmUuZGVjb2RlKGgpKSA6IFtdXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgXCJuZXZlbnRcIjoge1xuICAgICAgbGV0IHUgPSB3cihuKTtcbiAgICAgIGlmICghKChzID0gdVswXSkgIT0gbnVsbCAmJiBzWzBdKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBUTFYgMCBmb3IgbmV2ZW50XCIpO1xuICAgICAgaWYgKHVbMF1bMF0ubGVuZ3RoICE9PSAzMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVExWIDAgc2hvdWxkIGJlIDMyIGJ5dGVzXCIpO1xuICAgICAgaWYgKHVbMl0gJiYgdVsyXVswXS5sZW5ndGggIT09IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUTFYgMiBzaG91bGQgYmUgMzIgYnl0ZXNcIik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIm5ldmVudFwiLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgaWQ6IHZlKHVbMF1bMF0pLFxuICAgICAgICAgIHJlbGF5czogdVsxXSA/IHVbMV0ubWFwKChoKSA9PiBKZS5kZWNvZGUoaCkpIDogW10sXG4gICAgICAgICAgYXV0aG9yOiAobyA9IHVbMl0pICE9IG51bGwgJiYgb1swXSA/IHZlKHVbMl1bMF0pIDogdm9pZCAwXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgXCJuYWRkclwiOiB7XG4gICAgICBsZXQgdSA9IHdyKG4pO1xuICAgICAgaWYgKCEoKGEgPSB1WzBdKSAhPSBudWxsICYmIGFbMF0pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIFRMViAwIGZvciBuYWRkclwiKTtcbiAgICAgIGlmICghKChjID0gdVsyXSkgIT0gbnVsbCAmJiBjWzBdKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBUTFYgMiBmb3IgbmFkZHJcIik7XG4gICAgICBpZiAodVsyXVswXS5sZW5ndGggIT09IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUTFYgMiBzaG91bGQgYmUgMzIgYnl0ZXNcIik7XG4gICAgICBpZiAoISgobCA9IHVbM10pICE9IG51bGwgJiYgbFswXSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgVExWIDMgZm9yIG5hZGRyXCIpO1xuICAgICAgaWYgKHVbM11bMF0ubGVuZ3RoICE9PSA0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUTFYgMyBzaG91bGQgYmUgNCBieXRlc1wiKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwibmFkZHJcIixcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGlkZW50aWZpZXI6IEplLmRlY29kZSh1WzBdWzBdKSxcbiAgICAgICAgICBwdWJrZXk6IHZlKHVbMl1bMF0pLFxuICAgICAgICAgIGtpbmQ6IHBhcnNlSW50KHZlKHVbM11bMF0pLCAxNiksXG4gICAgICAgICAgcmVsYXlzOiB1WzFdID8gdVsxXS5tYXAoKGgpID0+IEplLmRlY29kZShoKSkgOiBbXVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFwibnJlbGF5XCI6IHtcbiAgICAgIGxldCB1ID0gd3Iobik7XG4gICAgICBpZiAoISgoZiA9IHVbMF0pICE9IG51bGwgJiYgZlswXSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgVExWIDAgZm9yIG5yZWxheVwiKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwibnJlbGF5XCIsXG4gICAgICAgIGRhdGE6IEplLmRlY29kZSh1WzBdWzBdKVxuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBcIm5zZWNcIjpcbiAgICBjYXNlIFwibnB1YlwiOlxuICAgIGNhc2UgXCJub3RlXCI6XG4gICAgICByZXR1cm4geyB0eXBlOiBlLCBkYXRhOiB2ZShuKSB9O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gcHJlZml4ICR7ZX1gKTtcbiAgfVxufVxuZnVuY3Rpb24gd3IodCkge1xuICBsZXQgZSA9IHt9LCByID0gdDtcbiAgZm9yICg7IHIubGVuZ3RoID4gMDsgKSB7XG4gICAgbGV0IG4gPSByWzBdLCBpID0gclsxXTtcbiAgICBpZiAoIWkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYG1hbGZvcm1lZCBUTFYgJHtufWApO1xuICAgIGxldCBzID0gci5zbGljZSgyLCAyICsgaSk7XG4gICAgaWYgKHIgPSByLnNsaWNlKDIgKyBpKSwgcy5sZW5ndGggPCBpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBub3QgZW5vdWdoIGRhdGEgdG8gcmVhZCBvbiBUTFYgJHtufWApO1xuICAgIGVbbl0gPSBlW25dIHx8IFtdLCBlW25dLnB1c2gocyk7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBDZih0KSB7XG4gIHJldHVybiBkaShcIm5zZWNcIiwgdCk7XG59XG5mdW5jdGlvbiBJZih0KSB7XG4gIHJldHVybiBkaShcIm5wdWJcIiwgdCk7XG59XG5mdW5jdGlvbiBSZih0KSB7XG4gIHJldHVybiBkaShcIm5vdGVcIiwgdCk7XG59XG5mdW5jdGlvbiBkaSh0LCBlKSB7XG4gIGxldCByID0gX3QoZSksIG4gPSB0ZS50b1dvcmRzKHIpO1xuICByZXR1cm4gdGUuZW5jb2RlKHQsIG4sIEF0KTtcbn1cbmZ1bmN0aW9uIFRmKHQpIHtcbiAgbGV0IGUgPSB6cih7XG4gICAgMDogW190KHQucHVia2V5KV0sXG4gICAgMTogKHQucmVsYXlzIHx8IFtdKS5tYXAoKG4pID0+IEllLmVuY29kZShuKSlcbiAgfSksIHIgPSB0ZS50b1dvcmRzKGUpO1xuICByZXR1cm4gdGUuZW5jb2RlKFwibnByb2ZpbGVcIiwgciwgQXQpO1xufVxuZnVuY3Rpb24gUGYodCkge1xuICBsZXQgZSA9IHpyKHtcbiAgICAwOiBbX3QodC5pZCldLFxuICAgIDE6ICh0LnJlbGF5cyB8fCBbXSkubWFwKChuKSA9PiBJZS5lbmNvZGUobikpLFxuICAgIDI6IHQuYXV0aG9yID8gW190KHQuYXV0aG9yKV0gOiBbXVxuICB9KSwgciA9IHRlLnRvV29yZHMoZSk7XG4gIHJldHVybiB0ZS5lbmNvZGUoXCJuZXZlbnRcIiwgciwgQXQpO1xufVxuZnVuY3Rpb24gQmYodCkge1xuICBsZXQgZSA9IG5ldyBBcnJheUJ1ZmZlcig0KTtcbiAgbmV3IERhdGFWaWV3KGUpLnNldFVpbnQzMigwLCB0LmtpbmQsICExKTtcbiAgbGV0IHIgPSB6cih7XG4gICAgMDogW0llLmVuY29kZSh0LmlkZW50aWZpZXIpXSxcbiAgICAxOiAodC5yZWxheXMgfHwgW10pLm1hcCgoaSkgPT4gSWUuZW5jb2RlKGkpKSxcbiAgICAyOiBbX3QodC5wdWJrZXkpXSxcbiAgICAzOiBbbmV3IFVpbnQ4QXJyYXkoZSldXG4gIH0pLCBuID0gdGUudG9Xb3JkcyhyKTtcbiAgcmV0dXJuIHRlLmVuY29kZShcIm5hZGRyXCIsIG4sIEF0KTtcbn1cbmZ1bmN0aW9uIExmKHQpIHtcbiAgbGV0IGUgPSB6cih7XG4gICAgMDogW0llLmVuY29kZSh0KV1cbiAgfSksIHIgPSB0ZS50b1dvcmRzKGUpO1xuICByZXR1cm4gdGUuZW5jb2RlKFwibnJlbGF5XCIsIHIsIEF0KTtcbn1cbmZ1bmN0aW9uIHpyKHQpIHtcbiAgbGV0IGUgPSBbXTtcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHQpLmZvckVhY2goKFtyLCBuXSkgPT4ge1xuICAgIG4uZm9yRWFjaCgoaSkgPT4ge1xuICAgICAgbGV0IHMgPSBuZXcgVWludDhBcnJheShpLmxlbmd0aCArIDIpO1xuICAgICAgcy5zZXQoW3BhcnNlSW50KHIpXSwgMCksIHMuc2V0KFtpLmxlbmd0aF0sIDEpLCBzLnNldChpLCAyKSwgZS5wdXNoKHMpO1xuICAgIH0pO1xuICB9KSwgX3UoLi4uZSk7XG59XG52YXIgVW4gPSB7fTtcbmllKFVuLCB7XG4gIGRlY3J5cHQ6ICgpID0+IHFmLFxuICBlbmNyeXB0OiAoKSA9PiAkZlxufSk7XG50eXBlb2YgY3J5cHRvIDwgXCJ1XCIgJiYgIWNyeXB0by5zdWJ0bGUgJiYgY3J5cHRvLndlYmNyeXB0byAmJiAoY3J5cHRvLnN1YnRsZSA9IGNyeXB0by53ZWJjcnlwdG8uc3VidGxlKTtcbmFzeW5jIGZ1bmN0aW9uICRmKHQsIGUsIHIpIHtcbiAgY29uc3QgbiA9IHVlLmdldFNoYXJlZFNlY3JldCh0LCBcIjAyXCIgKyBlKSwgaSA9IHdhKG4pO1xuICBsZXQgcyA9IFVpbnQ4QXJyYXkuZnJvbSh4dSgxNikpLCBvID0gSWUuZW5jb2RlKHIpLCBhID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoXG4gICAgXCJyYXdcIixcbiAgICBpLFxuICAgIHsgbmFtZTogXCJBRVMtQ0JDXCIgfSxcbiAgICAhMSxcbiAgICBbXCJlbmNyeXB0XCJdXG4gICksIGMgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmVuY3J5cHQoXG4gICAgeyBuYW1lOiBcIkFFUy1DQkNcIiwgaXY6IHMgfSxcbiAgICBhLFxuICAgIG9cbiAgKSwgbCA9IG10LmVuY29kZShuZXcgVWludDhBcnJheShjKSksIGYgPSBtdC5lbmNvZGUobmV3IFVpbnQ4QXJyYXkocy5idWZmZXIpKTtcbiAgcmV0dXJuIGAke2x9P2l2PSR7Zn1gO1xufVxuYXN5bmMgZnVuY3Rpb24gcWYodCwgZSwgcikge1xuICBsZXQgW24sIGldID0gci5zcGxpdChcIj9pdj1cIiksIHMgPSB1ZS5nZXRTaGFyZWRTZWNyZXQodCwgXCIwMlwiICsgZSksIG8gPSB3YShzKSwgYSA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KFxuICAgIFwicmF3XCIsXG4gICAgbyxcbiAgICB7IG5hbWU6IFwiQUVTLUNCQ1wiIH0sXG4gICAgITEsXG4gICAgW1wiZGVjcnlwdFwiXVxuICApLCBjID0gbXQuZGVjb2RlKG4pLCBsID0gbXQuZGVjb2RlKGkpLCBmID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5kZWNyeXB0KFxuICAgIHsgbmFtZTogXCJBRVMtQ0JDXCIsIGl2OiBsIH0sXG4gICAgYSxcbiAgICBjXG4gICk7XG4gIHJldHVybiBKZS5kZWNvZGUoZik7XG59XG5mdW5jdGlvbiB3YSh0KSB7XG4gIHJldHVybiB0LnNsaWNlKDEsIDMzKTtcbn1cbnZhciBfYSA9IHt9O1xuaWUoX2EsIHtcbiAgTklQMDVfUkVHRVg6ICgpID0+IG1hLFxuICBxdWVyeVByb2ZpbGU6ICgpID0+IGpmLFxuICBzZWFyY2hEb21haW46ICgpID0+IFVmLFxuICB1c2VGZXRjaEltcGxlbWVudGF0aW9uOiAoKSA9PiBOZlxufSk7XG52YXIgbWEgPSAvXig/OihbXFx3ListXSspQCk/KFtcXHcuLV0rKSQvLCBGcjtcbnRyeSB7XG4gIEZyID0gZmV0Y2g7XG59IGNhdGNoIHtcbn1cbmZ1bmN0aW9uIE5mKHQpIHtcbiAgRnIgPSB0O1xufVxuYXN5bmMgZnVuY3Rpb24gVWYodCwgZSA9IFwiXCIpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gKGF3YWl0IChhd2FpdCBGcihgaHR0cHM6Ly8ke3R9Ly53ZWxsLWtub3duL25vc3RyLmpzb24/bmFtZT0ke2V9YCkpLmpzb24oKSkubmFtZXM7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiB7fTtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gamYodCkge1xuICBjb25zdCBlID0gdC5tYXRjaChtYSk7XG4gIGlmICghZSlcbiAgICByZXR1cm4gbnVsbDtcbiAgY29uc3QgW3IsIG4gPSBcIl9cIiwgaV0gPSBlO1xuICB0cnkge1xuICAgIGNvbnN0IHMgPSBhd2FpdCBGcihgaHR0cHM6Ly8ke2l9Ly53ZWxsLWtub3duL25vc3RyLmpzb24/bmFtZT0ke259YCksIHsgbmFtZXM6IG8sIHJlbGF5czogYSB9ID0gSGYoYXdhaXQgcy5qc29uKCkpLCBjID0gb1tuXTtcbiAgICByZXR1cm4gYyA/IHsgcHVia2V5OiBjLCByZWxheXM6IGEgPT0gbnVsbCA/IHZvaWQgMCA6IGFbY10gfSA6IG51bGw7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5mdW5jdGlvbiBIZih0KSB7XG4gIGNvbnN0IGUgPSB7XG4gICAgbmFtZXM6IHt9XG4gIH07XG4gIGZvciAoY29uc3QgW3IsIG5dIG9mIE9iamVjdC5lbnRyaWVzKHQubmFtZXMpKVxuICAgIHR5cGVvZiByID09IFwic3RyaW5nXCIgJiYgdHlwZW9mIG4gPT0gXCJzdHJpbmdcIiAmJiAoZS5uYW1lc1tyXSA9IG4pO1xuICBpZiAodC5yZWxheXMpIHtcbiAgICBlLnJlbGF5cyA9IHt9O1xuICAgIGZvciAoY29uc3QgW3IsIG5dIG9mIE9iamVjdC5lbnRyaWVzKHQucmVsYXlzKSlcbiAgICAgIHR5cGVvZiByID09IFwic3RyaW5nXCIgJiYgQXJyYXkuaXNBcnJheShuKSAmJiAoZS5yZWxheXNbcl0gPSBuLmZpbHRlcigoaSkgPT4gdHlwZW9mIGkgPT0gXCJzdHJpbmdcIikpO1xuICB9XG4gIHJldHVybiBlO1xufVxudmFyIE1mID0ge307XG5pZShNZiwge1xuICBnZW5lcmF0ZVNlZWRXb3JkczogKCkgPT4gemYsXG4gIHByaXZhdGVLZXlGcm9tU2VlZFdvcmRzOiAoKSA9PiBEZixcbiAgdmFsaWRhdGVXb3JkczogKCkgPT4gRmZcbn0pO1xuZnVuY3Rpb24gRGYodCwgZSkge1xuICBsZXQgbiA9IGN0LmZyb21NYXN0ZXJTZWVkKFlzKHQsIGUpKS5kZXJpdmUoXCJtLzQ0Jy8xMjM3Jy8wJy8wLzBcIikucHJpdmF0ZUtleTtcbiAgaWYgKCFuKVxuICAgIHRocm93IG5ldyBFcnJvcihcImNvdWxkIG5vdCBkZXJpdmUgcHJpdmF0ZSBrZXlcIik7XG4gIHJldHVybiB2ZShuKTtcbn1cbmZ1bmN0aW9uIHpmKCkge1xuICByZXR1cm4gcmEoUW4pO1xufVxuZnVuY3Rpb24gRmYodCkge1xuICByZXR1cm4gc2EodCwgUW4pO1xufVxudmFyIEtmID0ge307XG5pZShLZiwge1xuICBwYXJzZTogKCkgPT4gV2Zcbn0pO1xuZnVuY3Rpb24gV2YodCkge1xuICBjb25zdCBlID0ge1xuICAgIHJlcGx5OiB2b2lkIDAsXG4gICAgcm9vdDogdm9pZCAwLFxuICAgIG1lbnRpb25zOiBbXSxcbiAgICBwcm9maWxlczogW11cbiAgfSwgciA9IFtdO1xuICBmb3IgKGNvbnN0IG4gb2YgdC50YWdzKVxuICAgIG5bMF0gPT09IFwiZVwiICYmIG5bMV0gJiYgci5wdXNoKG4pLCBuWzBdID09PSBcInBcIiAmJiBuWzFdICYmIGUucHJvZmlsZXMucHVzaCh7XG4gICAgICBwdWJrZXk6IG5bMV0sXG4gICAgICByZWxheXM6IG5bMl0gPyBbblsyXV0gOiBbXVxuICAgIH0pO1xuICBmb3IgKGxldCBuID0gMDsgbiA8IHIubGVuZ3RoOyBuKyspIHtcbiAgICBjb25zdCBpID0gcltuXSwgW3MsIG8sIGEsIGNdID0gaSwgbCA9IHtcbiAgICAgIGlkOiBvLFxuICAgICAgcmVsYXlzOiBhID8gW2FdIDogW11cbiAgICB9LCBmID0gbiA9PT0gMCwgdSA9IG4gPT09IHIubGVuZ3RoIC0gMTtcbiAgICBpZiAoYyA9PT0gXCJyb290XCIpIHtcbiAgICAgIGUucm9vdCA9IGw7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGMgPT09IFwicmVwbHlcIikge1xuICAgICAgZS5yZXBseSA9IGw7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGMgPT09IFwibWVudGlvblwiKSB7XG4gICAgICBlLm1lbnRpb25zLnB1c2gobCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGYpIHtcbiAgICAgIGUucm9vdCA9IGw7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHUpIHtcbiAgICAgIGUucmVwbHkgPSBsO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGUubWVudGlvbnMucHVzaChsKTtcbiAgfVxuICByZXR1cm4gZTtcbn1cbnZhciBWZiA9IHt9O1xuaWUoVmYsIHtcbiAgZ2V0UG93OiAoKSA9PiBHZlxufSk7XG5mdW5jdGlvbiBHZih0KSB7XG4gIHJldHVybiBaZihfdCh0KSk7XG59XG5mdW5jdGlvbiBaZih0KSB7XG4gIGxldCBlLCByLCBuO1xuICBmb3IgKHIgPSAwLCBlID0gMDsgciA8IHQubGVuZ3RoICYmIChuID0gWWYodFtyXSksIGUgKz0gbiwgbiA9PT0gOCk7IHIrKylcbiAgICA7XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gWWYodCkge1xuICBsZXQgZSA9IDA7XG4gIGlmICh0ID09PSAwKVxuICAgIHJldHVybiA4O1xuICBmb3IgKDsgdCA+Pj0gMTsgKVxuICAgIGUrKztcbiAgcmV0dXJuIDcgLSBlO1xufVxudmFyIEpmID0ge307XG5pZShKZiwge1xuICBmaW5pc2hSZXBvc3RFdmVudDogKCkgPT4gWGYsXG4gIGdldFJlcG9zdGVkRXZlbnQ6ICgpID0+IFFmLFxuICBnZXRSZXBvc3RlZEV2ZW50UG9pbnRlcjogKCkgPT4geGFcbn0pO1xuZnVuY3Rpb24gWGYodCwgZSwgciwgbikge1xuICB2YXIgaTtcbiAgcmV0dXJuIGRhKHtcbiAgICBraW5kOiA2LFxuICAgIHRhZ3M6IFtcbiAgICAgIC4uLihpID0gdC50YWdzKSAhPSBudWxsID8gaSA6IFtdLFxuICAgICAgW1wiZVwiLCBlLmlkLCByXSxcbiAgICAgIFtcInBcIiwgZS5wdWJrZXldXG4gICAgXSxcbiAgICBjb250ZW50OiB0LmNvbnRlbnQgPT09IFwiXCIgPyBcIlwiIDogSlNPTi5zdHJpbmdpZnkoZSksXG4gICAgY3JlYXRlZF9hdDogdC5jcmVhdGVkX2F0XG4gIH0sIG4pO1xufVxuZnVuY3Rpb24geGEodCkge1xuICBpZiAodC5raW5kICE9PSA2KVxuICAgIHJldHVybjtcbiAgbGV0IGUsIHI7XG4gIGZvciAobGV0IG4gPSB0LnRhZ3MubGVuZ3RoIC0gMTsgbiA+PSAwICYmIChlID09PSB2b2lkIDAgfHwgciA9PT0gdm9pZCAwKTsgbi0tKSB7XG4gICAgY29uc3QgaSA9IHQudGFnc1tuXTtcbiAgICBpLmxlbmd0aCA+PSAyICYmIChpWzBdID09PSBcImVcIiAmJiBlID09PSB2b2lkIDAgPyBlID0gaSA6IGlbMF0gPT09IFwicFwiICYmIHIgPT09IHZvaWQgMCAmJiAociA9IGkpKTtcbiAgfVxuICBpZiAoZSAhPT0gdm9pZCAwKVxuICAgIHJldHVybiB7XG4gICAgICBpZDogZVsxXSxcbiAgICAgIHJlbGF5czogW2VbMl0sIHIgPT0gbnVsbCA/IHZvaWQgMCA6IHJbMl1dLmZpbHRlcigobikgPT4gdHlwZW9mIG4gPT0gXCJzdHJpbmdcIiksXG4gICAgICBhdXRob3I6IHIgPT0gbnVsbCA/IHZvaWQgMCA6IHJbMV1cbiAgICB9O1xufVxuZnVuY3Rpb24gUWYodCwgeyBza2lwVmVyaWZpY2F0aW9uOiBlIH0gPSB7fSkge1xuICBjb25zdCByID0geGEodCk7XG4gIGlmIChyID09PSB2b2lkIDAgfHwgdC5jb250ZW50ID09PSBcIlwiKVxuICAgIHJldHVybjtcbiAgbGV0IG47XG4gIHRyeSB7XG4gICAgbiA9IEpTT04ucGFyc2UodC5jb250ZW50KTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChuLmlkID09PSByLmlkICYmICEoIWUgJiYgIWhpKG4pKSlcbiAgICByZXR1cm4gbjtcbn1cbnZhciBlaCA9IHt9O1xuaWUoZWgsIHtcbiAgTk9TVFJfVVJJX1JFR0VYOiAoKSA9PiBLcixcbiAgcGFyc2U6ICgpID0+IHJoLFxuICB0ZXN0OiAoKSA9PiB0aFxufSk7XG52YXIgS3IgPSBuZXcgUmVnRXhwKGBub3N0cjooJHt2YS5zb3VyY2V9KWApO1xuZnVuY3Rpb24gdGgodCkge1xuICByZXR1cm4gdHlwZW9mIHQgPT0gXCJzdHJpbmdcIiAmJiBuZXcgUmVnRXhwKGBeJHtLci5zb3VyY2V9JGApLnRlc3QodCk7XG59XG5mdW5jdGlvbiByaCh0KSB7XG4gIGNvbnN0IGUgPSB0Lm1hdGNoKG5ldyBSZWdFeHAoYF4ke0tyLnNvdXJjZX0kYCkpO1xuICBpZiAoIWUpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIE5vc3RyIFVSSTogJHt0fWApO1xuICByZXR1cm4ge1xuICAgIHVyaTogZVswXSxcbiAgICB2YWx1ZTogZVsxXSxcbiAgICBkZWNvZGVkOiBEcihlWzFdKVxuICB9O1xufVxudmFyIG5oID0ge307XG5pZShuaCwge1xuICBmaW5pc2hSZWFjdGlvbkV2ZW50OiAoKSA9PiBpaCxcbiAgZ2V0UmVhY3RlZEV2ZW50UG9pbnRlcjogKCkgPT4gb2hcbn0pO1xuZnVuY3Rpb24gaWgodCwgZSwgcikge1xuICB2YXIgaSwgcztcbiAgY29uc3QgbiA9IGUudGFncy5maWx0ZXIoXG4gICAgKG8pID0+IG8ubGVuZ3RoID49IDIgJiYgKG9bMF0gPT09IFwiZVwiIHx8IG9bMF0gPT09IFwicFwiKVxuICApO1xuICByZXR1cm4gZGEoe1xuICAgIC4uLnQsXG4gICAga2luZDogNyxcbiAgICB0YWdzOiBbXG4gICAgICAuLi4oaSA9IHQudGFncykgIT0gbnVsbCA/IGkgOiBbXSxcbiAgICAgIC4uLm4sXG4gICAgICBbXCJlXCIsIGUuaWRdLFxuICAgICAgW1wicFwiLCBlLnB1YmtleV1cbiAgICBdLFxuICAgIGNvbnRlbnQ6IChzID0gdC5jb250ZW50KSAhPSBudWxsID8gcyA6IFwiK1wiXG4gIH0sIHIpO1xufVxuZnVuY3Rpb24gb2godCkge1xuICBpZiAodC5raW5kICE9PSA3KVxuICAgIHJldHVybjtcbiAgbGV0IGUsIHI7XG4gIGZvciAobGV0IG4gPSB0LnRhZ3MubGVuZ3RoIC0gMTsgbiA+PSAwICYmIChlID09PSB2b2lkIDAgfHwgciA9PT0gdm9pZCAwKTsgbi0tKSB7XG4gICAgY29uc3QgaSA9IHQudGFnc1tuXTtcbiAgICBpLmxlbmd0aCA+PSAyICYmIChpWzBdID09PSBcImVcIiAmJiBlID09PSB2b2lkIDAgPyBlID0gaSA6IGlbMF0gPT09IFwicFwiICYmIHIgPT09IHZvaWQgMCAmJiAociA9IGkpKTtcbiAgfVxuICBpZiAoIShlID09PSB2b2lkIDAgfHwgciA9PT0gdm9pZCAwKSlcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IGVbMV0sXG4gICAgICByZWxheXM6IFtlWzJdLCByWzJdXS5maWx0ZXIoKG4pID0+IG4gIT09IHZvaWQgMCksXG4gICAgICBhdXRob3I6IHJbMV1cbiAgICB9O1xufVxudmFyIHNoID0ge307XG5pZShzaCwge1xuICBjcmVhdGVEZWxlZ2F0aW9uOiAoKSA9PiBhaCxcbiAgZ2V0RGVsZWdhdG9yOiAoKSA9PiBjaFxufSk7XG5mdW5jdGlvbiBhaCh0LCBlKSB7XG4gIGxldCByID0gW107XG4gIChlLmtpbmQgfHwgLTEpID49IDAgJiYgci5wdXNoKGBraW5kPSR7ZS5raW5kfWApLCBlLnVudGlsICYmIHIucHVzaChgY3JlYXRlZF9hdDwke2UudW50aWx9YCksIGUuc2luY2UgJiYgci5wdXNoKGBjcmVhdGVkX2F0PiR7ZS5zaW5jZX1gKTtcbiAgbGV0IG4gPSByLmpvaW4oXCImXCIpO1xuICBpZiAobiA9PT0gXCJcIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZWZ1c2luZyB0byBjcmVhdGUgYSBkZWxlZ2F0aW9uIHdpdGhvdXQgYW55IGNvbmRpdGlvbnNcIik7XG4gIGxldCBpID0gWW4oXG4gICAgSWUuZW5jb2RlKGBub3N0cjpkZWxlZ2F0aW9uOiR7ZS5wdWJrZXl9OiR7bn1gKVxuICApLCBzID0gdmUoXG4gICAgU3Quc2lnbihpLCB0KVxuICApO1xuICByZXR1cm4ge1xuICAgIGZyb206IGxpKHQpLFxuICAgIHRvOiBlLnB1YmtleSxcbiAgICBjb25kOiBuLFxuICAgIHNpZzogc1xuICB9O1xufVxuZnVuY3Rpb24gY2godCkge1xuICBsZXQgZSA9IHQudGFncy5maW5kKChhKSA9PiBhWzBdID09PSBcImRlbGVnYXRpb25cIiAmJiBhLmxlbmd0aCA+PSA0KTtcbiAgaWYgKCFlKVxuICAgIHJldHVybiBudWxsO1xuICBsZXQgciA9IGVbMV0sIG4gPSBlWzJdLCBpID0gZVszXSwgcyA9IG4uc3BsaXQoXCImXCIpO1xuICBmb3IgKGxldCBhID0gMDsgYSA8IHMubGVuZ3RoOyBhKyspIHtcbiAgICBsZXQgW2MsIGwsIGZdID0gc1thXS5zcGxpdCgvXFxiLyk7XG4gICAgaWYgKCEoYyA9PT0gXCJraW5kXCIgJiYgbCA9PT0gXCI9XCIgJiYgdC5raW5kID09PSBwYXJzZUludChmKSkpIHtcbiAgICAgIGlmIChjID09PSBcImNyZWF0ZWRfYXRcIiAmJiBsID09PSBcIjxcIiAmJiB0LmNyZWF0ZWRfYXQgPCBwYXJzZUludChmKSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBpZiAoYyA9PT0gXCJjcmVhdGVkX2F0XCIgJiYgbCA9PT0gXCI+XCIgJiYgdC5jcmVhdGVkX2F0ID4gcGFyc2VJbnQoZikpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIGxldCBvID0gWW4oXG4gICAgSWUuZW5jb2RlKGBub3N0cjpkZWxlZ2F0aW9uOiR7dC5wdWJrZXl9OiR7bn1gKVxuICApO1xuICByZXR1cm4gU3QudmVyaWZ5KGksIG8sIHIpID8gciA6IG51bGw7XG59XG52YXIgdWggPSB7fTtcbmllKHVoLCB7XG4gIG1hdGNoQWxsOiAoKSA9PiBsaCxcbiAgcmVnZXg6ICgpID0+IHBpLFxuICByZXBsYWNlQWxsOiAoKSA9PiBmaFxufSk7XG52YXIgcGkgPSAoKSA9PiBuZXcgUmVnRXhwKGBcXFxcYiR7S3Iuc291cmNlfVxcXFxiYCwgXCJnXCIpO1xuZnVuY3Rpb24qIGxoKHQpIHtcbiAgY29uc3QgZSA9IHQubWF0Y2hBbGwocGkoKSk7XG4gIGZvciAoY29uc3QgciBvZiBlKSB7XG4gICAgY29uc3QgW24sIGldID0gcjtcbiAgICB5aWVsZCB7XG4gICAgICB1cmk6IG4sXG4gICAgICB2YWx1ZTogaSxcbiAgICAgIGRlY29kZWQ6IERyKGkpLFxuICAgICAgc3RhcnQ6IHIuaW5kZXgsXG4gICAgICBlbmQ6IHIuaW5kZXggKyBuLmxlbmd0aFxuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIGZoKHQsIGUpIHtcbiAgcmV0dXJuIHQucmVwbGFjZUFsbChwaSgpLCAociwgbikgPT4gZSh7XG4gICAgdXJpOiByLFxuICAgIHZhbHVlOiBuLFxuICAgIGRlY29kZWQ6IERyKG4pXG4gIH0pKTtcbn1cbnZhciBoaCA9IHt9O1xuaWUoaGgsIHtcbiAgdXNlRmV0Y2hJbXBsZW1lbnRhdGlvbjogKCkgPT4gZGgsXG4gIHZhbGlkYXRlR2l0aHViOiAoKSA9PiBwaFxufSk7XG52YXIgeWk7XG50cnkge1xuICB5aSA9IGZldGNoO1xufSBjYXRjaCB7XG59XG5mdW5jdGlvbiBkaCh0KSB7XG4gIHlpID0gdDtcbn1cbmFzeW5jIGZ1bmN0aW9uIHBoKHQsIGUsIHIpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgKGF3YWl0IHlpKGBodHRwczovL2dpc3QuZ2l0aHViLmNvbS8ke2V9LyR7cn0vcmF3YCkpLnRleHQoKSA9PT0gYFZlcmlmeWluZyB0aGF0IEkgY29udHJvbCB0aGUgZm9sbG93aW5nIE5vc3RyIHB1YmxpYyBrZXk6ICR7dH1gO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gITE7XG4gIH1cbn1cbnZhciB5aCA9IHt9O1xuaWUoeWgsIHtcbiAgYXV0aGVudGljYXRlOiAoKSA9PiBnaFxufSk7XG52YXIgZ2ggPSBhc3luYyAoe1xuICBjaGFsbGVuZ2U6IHQsXG4gIHJlbGF5OiBlLFxuICBzaWduOiByXG59KSA9PiB7XG4gIGNvbnN0IG4gPSB7XG4gICAga2luZDogMjIyNDIsXG4gICAgY3JlYXRlZF9hdDogTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMWUzKSxcbiAgICB0YWdzOiBbXG4gICAgICBbXCJyZWxheVwiLCBlLnVybF0sXG4gICAgICBbXCJjaGFsbGVuZ2VcIiwgdF1cbiAgICBdLFxuICAgIGNvbnRlbnQ6IFwiXCJcbiAgfSwgaSA9IGUuYXV0aChhd2FpdCByKG4pKTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChzLCBvKSA9PiB7XG4gICAgaS5vbihcIm9rXCIsIGZ1bmN0aW9uIGEoKSB7XG4gICAgICBpLm9mZihcIm9rXCIsIGEpLCBzKCk7XG4gICAgfSksIGkub24oXCJmYWlsZWRcIiwgZnVuY3Rpb24gYShjKSB7XG4gICAgICBpLm9mZihcImZhaWxlZFwiLCBhKSwgbyhjKTtcbiAgICB9KTtcbiAgfSk7XG59LCBFYSA9IHt9O1xuaWUoRWEsIHtcbiAgZ2V0WmFwRW5kcG9pbnQ6ICgpID0+IHZoLFxuICBtYWtlWmFwUmVjZWlwdDogKCkgPT4gbWgsXG4gIG1ha2VaYXBSZXF1ZXN0OiAoKSA9PiB3aCxcbiAgdXNlRmV0Y2hJbXBsZW1lbnRhdGlvbjogKCkgPT4gYmgsXG4gIHZhbGlkYXRlWmFwUmVxdWVzdDogKCkgPT4gX2hcbn0pO1xudmFyIGdpO1xudHJ5IHtcbiAgZ2kgPSBmZXRjaDtcbn0gY2F0Y2gge1xufVxuZnVuY3Rpb24gYmgodCkge1xuICBnaSA9IHQ7XG59XG5hc3luYyBmdW5jdGlvbiB2aCh0KSB7XG4gIHRyeSB7XG4gICAgbGV0IGUgPSBcIlwiLCB7IGx1ZDA2OiByLCBsdWQxNjogbiB9ID0gSlNPTi5wYXJzZSh0LmNvbnRlbnQpO1xuICAgIGlmIChyKSB7XG4gICAgICBsZXQgeyB3b3JkczogbyB9ID0gdGUuZGVjb2RlKHIsIDFlMyksIGEgPSB0ZS5mcm9tV29yZHMobyk7XG4gICAgICBlID0gSmUuZGVjb2RlKGEpO1xuICAgIH0gZWxzZSBpZiAobikge1xuICAgICAgbGV0IFtvLCBhXSA9IG4uc3BsaXQoXCJAXCIpO1xuICAgICAgZSA9IGBodHRwczovLyR7YX0vLndlbGwta25vd24vbG51cmxwLyR7b31gO1xuICAgIH0gZWxzZVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHMgPSBhd2FpdCAoYXdhaXQgZ2koZSkpLmpzb24oKTtcbiAgICBpZiAocy5hbGxvd3NOb3N0ciAmJiBzLm5vc3RyUHVia2V5KVxuICAgICAgcmV0dXJuIHMuY2FsbGJhY2s7XG4gIH0gY2F0Y2gge1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gd2goe1xuICBwcm9maWxlOiB0LFxuICBldmVudDogZSxcbiAgYW1vdW50OiByLFxuICByZWxheXM6IG4sXG4gIGNvbW1lbnQ6IGkgPSBcIlwiXG59KSB7XG4gIGlmICghcilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJhbW91bnQgbm90IGdpdmVuXCIpO1xuICBpZiAoIXQpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwicHJvZmlsZSBub3QgZ2l2ZW5cIik7XG4gIGxldCBzID0ge1xuICAgIGtpbmQ6IDk3MzQsXG4gICAgY3JlYXRlZF9hdDogTWF0aC5yb3VuZChEYXRlLm5vdygpIC8gMWUzKSxcbiAgICBjb250ZW50OiBpLFxuICAgIHRhZ3M6IFtcbiAgICAgIFtcInBcIiwgdF0sXG4gICAgICBbXCJhbW91bnRcIiwgci50b1N0cmluZygpXSxcbiAgICAgIFtcInJlbGF5c1wiLCAuLi5uXVxuICAgIF1cbiAgfTtcbiAgcmV0dXJuIGUgJiYgcy50YWdzLnB1c2goW1wiZVwiLCBlXSksIHM7XG59XG5mdW5jdGlvbiBfaCh0KSB7XG4gIGxldCBlO1xuICB0cnkge1xuICAgIGUgPSBKU09OLnBhcnNlKHQpO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gXCJJbnZhbGlkIHphcCByZXF1ZXN0IEpTT04uXCI7XG4gIH1cbiAgaWYgKCFmaShlKSlcbiAgICByZXR1cm4gXCJaYXAgcmVxdWVzdCBpcyBub3QgYSB2YWxpZCBOb3N0ciBldmVudC5cIjtcbiAgaWYgKCFoaShlKSlcbiAgICByZXR1cm4gXCJJbnZhbGlkIHNpZ25hdHVyZSBvbiB6YXAgcmVxdWVzdC5cIjtcbiAgbGV0IHIgPSBlLnRhZ3MuZmluZCgoW3MsIG9dKSA9PiBzID09PSBcInBcIiAmJiBvKTtcbiAgaWYgKCFyKVxuICAgIHJldHVybiBcIlphcCByZXF1ZXN0IGRvZXNuJ3QgaGF2ZSBhICdwJyB0YWcuXCI7XG4gIGlmICghclsxXS5tYXRjaCgvXlthLWYwLTldezY0fSQvKSlcbiAgICByZXR1cm4gXCJaYXAgcmVxdWVzdCAncCcgdGFnIGlzIG5vdCB2YWxpZCBoZXguXCI7XG4gIGxldCBuID0gZS50YWdzLmZpbmQoKFtzLCBvXSkgPT4gcyA9PT0gXCJlXCIgJiYgbyk7XG4gIHJldHVybiBuICYmICFuWzFdLm1hdGNoKC9eW2EtZjAtOV17NjR9JC8pID8gXCJaYXAgcmVxdWVzdCAnZScgdGFnIGlzIG5vdCB2YWxpZCBoZXguXCIgOiBlLnRhZ3MuZmluZCgoW3MsIG9dKSA9PiBzID09PSBcInJlbGF5c1wiICYmIG8pID8gbnVsbCA6IFwiWmFwIHJlcXVlc3QgZG9lc24ndCBoYXZlIGEgJ3JlbGF5cycgdGFnLlwiO1xufVxuZnVuY3Rpb24gbWgoe1xuICB6YXBSZXF1ZXN0OiB0LFxuICBwcmVpbWFnZTogZSxcbiAgYm9sdDExOiByLFxuICBwYWlkQXQ6IG5cbn0pIHtcbiAgbGV0IHMgPSBKU09OLnBhcnNlKHQpLnRhZ3MuZmlsdGVyKFxuICAgIChbYV0pID0+IGEgPT09IFwiZVwiIHx8IGEgPT09IFwicFwiIHx8IGEgPT09IFwiYVwiXG4gICksIG8gPSB7XG4gICAga2luZDogOTczNSxcbiAgICBjcmVhdGVkX2F0OiBNYXRoLnJvdW5kKG4uZ2V0VGltZSgpIC8gMWUzKSxcbiAgICBjb250ZW50OiBcIlwiLFxuICAgIHRhZ3M6IFtcbiAgICAgIC4uLnMsXG4gICAgICBbXCJib2x0MTFcIiwgcl0sXG4gICAgICBbXCJkZXNjcmlwdGlvblwiLCB0XVxuICAgIF1cbiAgfTtcbiAgcmV0dXJuIGUgJiYgby50YWdzLnB1c2goW1wicHJlaW1hZ2VcIiwgZV0pLCBvO1xufVxudmFyIGNyID0ge307XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoY3IsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbmNyLmlzX25vZGUgPSB2b2lkIDA7XG52YXIgZG4gPSBudWxsO1xuZnVuY3Rpb24geGgoKSB7XG4gIHJldHVybiBkbiA9PT0gbnVsbCAmJiAoZG4gPSB0eXBlb2YgUyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBTLnByb2Nlc3MgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUy5wcm9jZXNzLnZlcnNpb25zID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFMucHJvY2Vzcy52ZXJzaW9ucy5ub2RlIDwgXCJ1XCIpLCBkbjtcbn1cbmNyLmlzX25vZGUgPSB4aDtcbnZhciBwbiA9IHt9LCB5biwgWGk7XG5mdW5jdGlvbiBFaCgpIHtcbiAgaWYgKFhpKVxuICAgIHJldHVybiB5bjtcbiAgWGkgPSAxO1xuICB2YXIgdCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0eXBlb2Ygc2VsZiA9PSBcIm9iamVjdFwiICYmIHNlbGYpXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PSBcIm9iamVjdFwiICYmIHdpbmRvdylcbiAgICAgIHJldHVybiB3aW5kb3c7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIHJlc29sdmUgZ2xvYmFsIGB0aGlzYFwiKTtcbiAgfTtcbiAgcmV0dXJuIHluID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMpXG4gICAgICByZXR1cm4gdGhpcztcbiAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT0gXCJvYmplY3RcIiAmJiBnbG9iYWxUaGlzKVxuICAgICAgcmV0dXJuIGdsb2JhbFRoaXM7XG4gICAgdHJ5IHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3QucHJvdG90eXBlLCBcIl9fZ2xvYmFsX19cIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiB0KCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gX19nbG9iYWxfXyB8fCB0KCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGRlbGV0ZSBPYmplY3QucHJvdG90eXBlLl9fZ2xvYmFsX187XG4gICAgfVxuICB9KCksIHluO1xufVxuY29uc3Qga2ggPSBcIndlYnNvY2tldFwiLCBTaCA9IFwiV2Vic29ja2V0IENsaWVudCAmIFNlcnZlciBMaWJyYXJ5IGltcGxlbWVudGluZyB0aGUgV2ViU29ja2V0IHByb3RvY29sIGFzIHNwZWNpZmllZCBpbiBSRkMgNjQ1NS5cIiwgT2ggPSBbXG4gIFwid2Vic29ja2V0XCIsXG4gIFwid2Vic29ja2V0c1wiLFxuICBcInNvY2tldFwiLFxuICBcIm5ldHdvcmtpbmdcIixcbiAgXCJjb21ldFwiLFxuICBcInB1c2hcIixcbiAgXCJSRkMtNjQ1NVwiLFxuICBcInJlYWx0aW1lXCIsXG4gIFwic2VydmVyXCIsXG4gIFwiY2xpZW50XCJcbl0sIEFoID0gXCJCcmlhbiBNY0tlbHZleSA8dGhldHVydGxlMzJAZ21haWwuY29tPiAoaHR0cHM6Ly9naXRodWIuY29tL3RoZXR1cnRsZTMyKVwiLCBDaCA9IFtcbiAgXCJJXFx4RjFha2kgQmF6IENhc3RpbGxvIDxpYmNAYWxpYXgubmV0PiAoaHR0cDovL2Rldi5zaXBkb2MubmV0KVwiXG5dLCBJaCA9IFwiMS4wLjM0XCIsIFJoID0ge1xuICB0eXBlOiBcImdpdFwiLFxuICB1cmw6IFwiaHR0cHM6Ly9naXRodWIuY29tL3RoZXR1cnRsZTMyL1dlYlNvY2tldC1Ob2RlLmdpdFwiXG59LCBUaCA9IFwiaHR0cHM6Ly9naXRodWIuY29tL3RoZXR1cnRsZTMyL1dlYlNvY2tldC1Ob2RlXCIsIFBoID0ge1xuICBub2RlOiBcIj49NC4wLjBcIlxufSwgQmggPSB7XG4gIGJ1ZmZlcnV0aWw6IFwiXjQuMC4xXCIsXG4gIGRlYnVnOiBcIl4yLjIuMFwiLFxuICBcImVzNS1leHRcIjogXCJeMC4xMC41MFwiLFxuICBcInR5cGVkYXJyYXktdG8tYnVmZmVyXCI6IFwiXjMuMS41XCIsXG4gIFwidXRmLTgtdmFsaWRhdGVcIjogXCJeNS4wLjJcIixcbiAgeWFldGk6IFwiXjAuMC42XCJcbn0sIExoID0ge1xuICBcImJ1ZmZlci1lcXVhbFwiOiBcIl4xLjAuMFwiLFxuICBndWxwOiBcIl40LjAuMlwiLFxuICBcImd1bHAtanNoaW50XCI6IFwiXjIuMC40XCIsXG4gIFwianNoaW50LXN0eWxpc2hcIjogXCJeMi4yLjFcIixcbiAganNoaW50OiBcIl4yLjAuMFwiLFxuICB0YXBlOiBcIl40LjkuMVwiXG59LCAkaCA9IHtcbiAgdmVyYm9zZTogITFcbn0sIHFoID0ge1xuICB0ZXN0OiBcInRhcGUgdGVzdC91bml0LyouanNcIixcbiAgZ3VscDogXCJndWxwXCJcbn0sIE5oID0gXCJpbmRleFwiLCBVaCA9IHtcbiAgbGliOiBcIi4vbGliXCJcbn0sIGpoID0gXCJsaWIvYnJvd3Nlci5qc1wiLCBIaCA9IFwiQXBhY2hlLTIuMFwiLCBNaCA9IHtcbiAgbmFtZToga2gsXG4gIGRlc2NyaXB0aW9uOiBTaCxcbiAga2V5d29yZHM6IE9oLFxuICBhdXRob3I6IEFoLFxuICBjb250cmlidXRvcnM6IENoLFxuICB2ZXJzaW9uOiBJaCxcbiAgcmVwb3NpdG9yeTogUmgsXG4gIGhvbWVwYWdlOiBUaCxcbiAgZW5naW5lczogUGgsXG4gIGRlcGVuZGVuY2llczogQmgsXG4gIGRldkRlcGVuZGVuY2llczogTGgsXG4gIGNvbmZpZzogJGgsXG4gIHNjcmlwdHM6IHFoLFxuICBtYWluOiBOaCxcbiAgZGlyZWN0b3JpZXM6IFVoLFxuICBicm93c2VyOiBqaCxcbiAgbGljZW5zZTogSGhcbn07XG52YXIgZ24sIFFpO1xuZnVuY3Rpb24gRGgoKSB7XG4gIHJldHVybiBRaSB8fCAoUWkgPSAxLCBnbiA9IE1oLnZlcnNpb24pLCBnbjtcbn1cbnZhciBibiwgZW87XG5mdW5jdGlvbiB6aCgpIHtcbiAgaWYgKGVvKVxuICAgIHJldHVybiBibjtcbiAgZW8gPSAxO1xuICB2YXIgdDtcbiAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzID09IFwib2JqZWN0XCIpXG4gICAgdCA9IGdsb2JhbFRoaXM7XG4gIGVsc2VcbiAgICB0cnkge1xuICAgICAgdCA9IEVoKCk7XG4gICAgfSBjYXRjaCB7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmICghdCAmJiB0eXBlb2Ygd2luZG93IDwgXCJ1XCIgJiYgKHQgPSB3aW5kb3cpLCAhdClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGRldGVybWluZSBnbG9iYWwgdGhpc1wiKTtcbiAgICB9XG4gIHZhciBlID0gdC5XZWJTb2NrZXQgfHwgdC5Nb3pXZWJTb2NrZXQsIHIgPSBEaCgpO1xuICBmdW5jdGlvbiBuKGksIHMpIHtcbiAgICB2YXIgbztcbiAgICByZXR1cm4gcyA/IG8gPSBuZXcgZShpLCBzKSA6IG8gPSBuZXcgZShpKSwgbztcbiAgfVxuICByZXR1cm4gZSAmJiBbXCJDT05ORUNUSU5HXCIsIFwiT1BFTlwiLCBcIkNMT1NJTkdcIiwgXCJDTE9TRURcIl0uZm9yRWFjaChmdW5jdGlvbihpKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIGksIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBlW2ldO1xuICAgICAgfVxuICAgIH0pO1xuICB9KSwgYm4gPSB7XG4gICAgdzNjd2Vic29ja2V0OiBlID8gbiA6IG51bGwsXG4gICAgdmVyc2lvbjogclxuICB9LCBibjtcbn1cbnZhciBfciA9IHt9LCB2biA9IHt9LCBSdCA9IHt9LCBUdCA9IHt9LCBQdCA9IHt9LCBCdCA9IHt9LCB0bztcbmZ1bmN0aW9uIEZoKCkge1xuICBpZiAodG8pXG4gICAgcmV0dXJuIEJ0O1xuICB0byA9IDEsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBCdC5Gb3JPZkFkYXB0b3IgPSB2b2lkIDA7XG4gIHZhciB0ID0gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gZShyLCBuKSB7XG4gICAgICB0aGlzLml0XyA9IHIsIHRoaXMubGFzdF8gPSBuO1xuICAgIH1cbiAgICByZXR1cm4gZS5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuaXRfLmVxdWFscyh0aGlzLmxhc3RfKSlcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkb25lOiAhMCxcbiAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH07XG4gICAgICB2YXIgciA9IHRoaXMuaXRfO1xuICAgICAgcmV0dXJuIHRoaXMuaXRfID0gdGhpcy5pdF8ubmV4dCgpLCB7XG4gICAgICAgIGRvbmU6ICExLFxuICAgICAgICB2YWx1ZTogci52YWx1ZVxuICAgICAgfTtcbiAgICB9LCBlLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LCBlO1xuICB9KCk7XG4gIHJldHVybiBCdC5Gb3JPZkFkYXB0b3IgPSB0LCBCdDtcbn1cbnZhciBybztcbmZ1bmN0aW9uIGJpKCkge1xuICBpZiAocm8pXG4gICAgcmV0dXJuIFB0O1xuICBybyA9IDE7XG4gIHZhciB0ID0gUyAmJiBTLl9fdmFsdWVzIHx8IGZ1bmN0aW9uKG4pIHtcbiAgICB2YXIgaSA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgcyA9IGkgJiYgbltpXSwgbyA9IDA7XG4gICAgaWYgKHMpXG4gICAgICByZXR1cm4gcy5jYWxsKG4pO1xuICAgIGlmIChuICYmIHR5cGVvZiBuLmxlbmd0aCA9PSBcIm51bWJlclwiKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIG4gJiYgbyA+PSBuLmxlbmd0aCAmJiAobiA9IHZvaWQgMCksIHsgdmFsdWU6IG4gJiYgbltvKytdLCBkb25lOiAhbiB9O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoaSA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFB0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIFB0LkNvbnRhaW5lciA9IHZvaWQgMDtcbiAgdmFyIGUgPSBGaCgpLCByID0gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gbigpIHtcbiAgICB9XG4gICAgcmV0dXJuIG4ucHJvdG90eXBlLmVtcHR5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5zaXplKCkgPT09IDA7XG4gICAgfSwgbi5wcm90b3R5cGUucmJlZ2luID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmQoKS5yZXZlcnNlKCk7XG4gICAgfSwgbi5wcm90b3R5cGUucmVuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYmVnaW4oKS5yZXZlcnNlKCk7XG4gICAgfSwgbi5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBlLkZvck9mQWRhcHRvcih0aGlzLmJlZ2luKCksIHRoaXMuZW5kKCkpO1xuICAgIH0sIG4ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGksIHMsIG8gPSBbXTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIGEgPSB0KHRoaXMpLCBjID0gYS5uZXh0KCk7ICFjLmRvbmU7IGMgPSBhLm5leHQoKSkge1xuICAgICAgICAgIHZhciBsID0gYy52YWx1ZTtcbiAgICAgICAgICBvLnB1c2gobCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGYpIHtcbiAgICAgICAgaSA9IHsgZXJyb3I6IGYgfTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYyAmJiAhYy5kb25lICYmIChzID0gYS5yZXR1cm4pICYmIHMuY2FsbChhKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoaSlcbiAgICAgICAgICAgIHRocm93IGkuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvO1xuICAgIH0sIG47XG4gIH0oKTtcbiAgcmV0dXJuIFB0LkNvbnRhaW5lciA9IHIsIFB0O1xufVxudmFyIEx0ID0ge30sIG5vO1xuZnVuY3Rpb24gdmkoKSB7XG4gIGlmIChubylcbiAgICByZXR1cm4gTHQ7XG4gIG5vID0gMTtcbiAgdmFyIHQgPSBTICYmIFMuX19yZWFkIHx8IGZ1bmN0aW9uKHIsIG4pIHtcbiAgICB2YXIgaSA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIHJbU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIWkpXG4gICAgICByZXR1cm4gcjtcbiAgICB2YXIgcyA9IGkuY2FsbChyKSwgbywgYSA9IFtdLCBjO1xuICAgIHRyeSB7XG4gICAgICBmb3IgKDsgKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKG8gPSBzLm5leHQoKSkuZG9uZTsgKVxuICAgICAgICBhLnB1c2goby52YWx1ZSk7XG4gICAgfSBjYXRjaCAobCkge1xuICAgICAgYyA9IHsgZXJyb3I6IGwgfTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbyAmJiAhby5kb25lICYmIChpID0gcy5yZXR1cm4pICYmIGkuY2FsbChzKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChjKVxuICAgICAgICAgIHRocm93IGMuZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTHQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgTHQuTmF0aXZlQXJyYXlJdGVyYXRvciA9IHZvaWQgMDtcbiAgdmFyIGUgPSBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiByKG4sIGkpIHtcbiAgICAgIHRoaXMuZGF0YV8gPSBuLCB0aGlzLmluZGV4XyA9IGk7XG4gICAgfVxuICAgIHJldHVybiByLnByb3RvdHlwZS5pbmRleCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW5kZXhfO1xuICAgIH0sIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhX1t0aGlzLmluZGV4X107XG4gICAgICB9LFxuICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgfSksIHIucHJvdG90eXBlLnByZXYgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAtLXRoaXMuaW5kZXhfLCB0aGlzO1xuICAgIH0sIHIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiArK3RoaXMuaW5kZXhfLCB0aGlzO1xuICAgIH0sIHIucHJvdG90eXBlLmFkdmFuY2UgPSBmdW5jdGlvbihuKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbmRleF8gKz0gbiwgdGhpcztcbiAgICB9LCByLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbihuKSB7XG4gICAgICByZXR1cm4gdGhpcy5kYXRhXyA9PT0gbi5kYXRhXyAmJiB0aGlzLmluZGV4XyA9PT0gbi5pbmRleF87XG4gICAgfSwgci5wcm90b3R5cGUuc3dhcCA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgIHZhciBpLCBzO1xuICAgICAgaSA9IHQoW24uZGF0YV8sIHRoaXMuZGF0YV9dLCAyKSwgdGhpcy5kYXRhXyA9IGlbMF0sIG4uZGF0YV8gPSBpWzFdLCBzID0gdChbbi5pbmRleF8sIHRoaXMuaW5kZXhfXSwgMiksIHRoaXMuaW5kZXhfID0gc1swXSwgbi5pbmRleF8gPSBzWzFdO1xuICAgIH0sIHI7XG4gIH0oKTtcbiAgcmV0dXJuIEx0Lk5hdGl2ZUFycmF5SXRlcmF0b3IgPSBlLCBMdDtcbn1cbnZhciBpbztcbmZ1bmN0aW9uIEtoKCkge1xuICBpZiAoaW8pXG4gICAgcmV0dXJuIFR0O1xuICBpbyA9IDE7XG4gIHZhciB0ID0gUyAmJiBTLl9fZXh0ZW5kcyB8fCBmdW5jdGlvbigpIHtcbiAgICB2YXIgaSA9IGZ1bmN0aW9uKHMsIG8pIHtcbiAgICAgIHJldHVybiBpID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24oYSwgYykge1xuICAgICAgICBhLl9fcHJvdG9fXyA9IGM7XG4gICAgICB9IHx8IGZ1bmN0aW9uKGEsIGMpIHtcbiAgICAgICAgZm9yICh2YXIgbCBpbiBjKVxuICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjLCBsKSAmJiAoYVtsXSA9IGNbbF0pO1xuICAgICAgfSwgaShzLCBvKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbihzLCBvKSB7XG4gICAgICBpZiAodHlwZW9mIG8gIT0gXCJmdW5jdGlvblwiICYmIG8gIT09IG51bGwpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKG8pICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgIGkocywgbyk7XG4gICAgICBmdW5jdGlvbiBhKCkge1xuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yID0gcztcbiAgICAgIH1cbiAgICAgIHMucHJvdG90eXBlID0gbyA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUobykgOiAoYS5wcm90b3R5cGUgPSBvLnByb3RvdHlwZSwgbmV3IGEoKSk7XG4gICAgfTtcbiAgfSgpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVHQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgVHQuU2V0Q29udGFpbmVyID0gdm9pZCAwO1xuICB2YXIgZSA9IGJpKCksIHIgPSB2aSgpLCBuID0gZnVuY3Rpb24oaSkge1xuICAgIHQocywgaSk7XG4gICAgZnVuY3Rpb24gcyhvKSB7XG4gICAgICB2YXIgYSA9IGkuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgcmV0dXJuIGEuZGF0YV8gPSBvKGEpLCBhO1xuICAgIH1cbiAgICByZXR1cm4gcy5wcm90b3R5cGUuYXNzaWduID0gZnVuY3Rpb24obywgYSkge1xuICAgICAgdGhpcy5jbGVhcigpLCB0aGlzLmluc2VydChvLCBhKTtcbiAgICB9LCBzLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kYXRhXy5jbGVhcigpO1xuICAgIH0sIHMucHJvdG90eXBlLmJlZ2luID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5kYXRhXy5iZWdpbigpO1xuICAgIH0sIHMucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGF0YV8uZW5kKCk7XG4gICAgfSwgcy5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24obykge1xuICAgICAgcmV0dXJuICF0aGlzLmZpbmQobykuZXF1YWxzKHRoaXMuZW5kKCkpO1xuICAgIH0sIHMucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmRhdGFfLnNpemUoKTtcbiAgICB9LCBzLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oKSB7XG4gICAgICBmb3IgKHZhciBvID0gW10sIGEgPSAwOyBhIDwgYXJndW1lbnRzLmxlbmd0aDsgYSsrKVxuICAgICAgICBvW2FdID0gYXJndW1lbnRzW2FdO1xuICAgICAgaWYgKG8ubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gdGhpcy5zaXplKCk7XG4gICAgICB2YXIgYyA9IG5ldyByLk5hdGl2ZUFycmF5SXRlcmF0b3IobywgMCksIGwgPSBuZXcgci5OYXRpdmVBcnJheUl0ZXJhdG9yKG8sIG8ubGVuZ3RoKTtcbiAgICAgIHJldHVybiB0aGlzLl9JbnNlcnRfYnlfcmFuZ2UoYywgbCksIHRoaXMuc2l6ZSgpO1xuICAgIH0sIHMucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgZm9yICh2YXIgbyA9IFtdLCBhID0gMDsgYSA8IGFyZ3VtZW50cy5sZW5ndGg7IGErKylcbiAgICAgICAgb1thXSA9IGFyZ3VtZW50c1thXTtcbiAgICAgIHJldHVybiBvLmxlbmd0aCA9PT0gMSA/IHRoaXMuX0luc2VydF9ieV9rZXkob1swXSkgOiBvWzBdLm5leHQgaW5zdGFuY2VvZiBGdW5jdGlvbiAmJiBvWzFdLm5leHQgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IHRoaXMuX0luc2VydF9ieV9yYW5nZShvWzBdLCBvWzFdKSA6IHRoaXMuX0luc2VydF9ieV9oaW50KG9bMF0sIG9bMV0pO1xuICAgIH0sIHMucHJvdG90eXBlLmVyYXNlID0gZnVuY3Rpb24oKSB7XG4gICAgICBmb3IgKHZhciBvID0gW10sIGEgPSAwOyBhIDwgYXJndW1lbnRzLmxlbmd0aDsgYSsrKVxuICAgICAgICBvW2FdID0gYXJndW1lbnRzW2FdO1xuICAgICAgcmV0dXJuIG8ubGVuZ3RoID09PSAxICYmICEob1swXSBpbnN0YW5jZW9mIHRoaXMuZW5kKCkuY29uc3RydWN0b3IgJiYgb1swXS5zb3VyY2UoKSA9PT0gdGhpcykgPyB0aGlzLl9FcmFzZV9ieV92YWwob1swXSkgOiBvLmxlbmd0aCA9PT0gMSA/IHRoaXMuX0VyYXNlX2J5X3JhbmdlKG9bMF0pIDogdGhpcy5fRXJhc2VfYnlfcmFuZ2Uob1swXSwgb1sxXSk7XG4gICAgfSwgcy5wcm90b3R5cGUuX0VyYXNlX2J5X3JhbmdlID0gZnVuY3Rpb24obywgYSkge1xuICAgICAgYSA9PT0gdm9pZCAwICYmIChhID0gby5uZXh0KCkpO1xuICAgICAgdmFyIGMgPSB0aGlzLmRhdGFfLmVyYXNlKG8sIGEpO1xuICAgICAgcmV0dXJuIHRoaXMuX0hhbmRsZV9lcmFzZShvLCBhKSwgYztcbiAgICB9LCBzO1xuICB9KGUuQ29udGFpbmVyKTtcbiAgcmV0dXJuIFR0LlNldENvbnRhaW5lciA9IG4sIFR0O1xufVxudmFyIHduID0ge30sICR0ID0ge30sIHF0ID0ge30sIE50ID0ge30sIG9vO1xuZnVuY3Rpb24gV2goKSB7XG4gIGlmIChvbylcbiAgICByZXR1cm4gTnQ7XG4gIG9vID0gMTtcbiAgdmFyIHQgPSBTICYmIFMuX19leHRlbmRzIHx8IGZ1bmN0aW9uKCkge1xuICAgIHZhciByID0gZnVuY3Rpb24obiwgaSkge1xuICAgICAgcmV0dXJuIHIgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbihzLCBvKSB7XG4gICAgICAgIHMuX19wcm90b19fID0gbztcbiAgICAgIH0gfHwgZnVuY3Rpb24ocywgbykge1xuICAgICAgICBmb3IgKHZhciBhIGluIG8pXG4gICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIGEpICYmIChzW2FdID0gb1thXSk7XG4gICAgICB9LCByKG4sIGkpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG4sIGkpIHtcbiAgICAgIGlmICh0eXBlb2YgaSAhPSBcImZ1bmN0aW9uXCIgJiYgaSAhPT0gbnVsbClcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoaSkgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgcihuLCBpKTtcbiAgICAgIGZ1bmN0aW9uIHMoKSB7XG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IgPSBuO1xuICAgICAgfVxuICAgICAgbi5wcm90b3R5cGUgPSBpID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShpKSA6IChzLnByb3RvdHlwZSA9IGkucHJvdG90eXBlLCBuZXcgcygpKTtcbiAgICB9O1xuICB9KCk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOdCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBOdC5FeGNlcHRpb24gPSB2b2lkIDA7XG4gIHZhciBlID0gZnVuY3Rpb24ocikge1xuICAgIHQobiwgcik7XG4gICAgZnVuY3Rpb24gbihpKSB7XG4gICAgICB2YXIgcyA9IHRoaXMuY29uc3RydWN0b3IsIG8gPSByLmNhbGwodGhpcywgaSkgfHwgdGhpcywgYSA9IHMucHJvdG90eXBlO1xuICAgICAgcmV0dXJuIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihvLCBhKSA6IG8uX19wcm90b19fID0gYSwgbztcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICB9LFxuICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgfSksIG4ucHJvdG90eXBlLndoYXQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2U7XG4gICAgfSwgbi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgICAgc3RhY2s6IHRoaXMuc3RhY2tcbiAgICAgIH07XG4gICAgfSwgbjtcbiAgfShFcnJvcik7XG4gIHJldHVybiBOdC5FeGNlcHRpb24gPSBlLCBOdDtcbn1cbnZhciBzbztcbmZ1bmN0aW9uIGthKCkge1xuICBpZiAoc28pXG4gICAgcmV0dXJuIHF0O1xuICBzbyA9IDE7XG4gIHZhciB0ID0gUyAmJiBTLl9fZXh0ZW5kcyB8fCBmdW5jdGlvbigpIHtcbiAgICB2YXIgbiA9IGZ1bmN0aW9uKGksIHMpIHtcbiAgICAgIHJldHVybiBuID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24obywgYSkge1xuICAgICAgICBvLl9fcHJvdG9fXyA9IGE7XG4gICAgICB9IHx8IGZ1bmN0aW9uKG8sIGEpIHtcbiAgICAgICAgZm9yICh2YXIgYyBpbiBhKVxuICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhLCBjKSAmJiAob1tjXSA9IGFbY10pO1xuICAgICAgfSwgbihpLCBzKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbihpLCBzKSB7XG4gICAgICBpZiAodHlwZW9mIHMgIT0gXCJmdW5jdGlvblwiICYmIHMgIT09IG51bGwpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKHMpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgIG4oaSwgcyk7XG4gICAgICBmdW5jdGlvbiBvKCkge1xuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yID0gaTtcbiAgICAgIH1cbiAgICAgIGkucHJvdG90eXBlID0gcyA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUocykgOiAoby5wcm90b3R5cGUgPSBzLnByb3RvdHlwZSwgbmV3IG8oKSk7XG4gICAgfTtcbiAgfSgpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocXQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgcXQuTG9naWNFcnJvciA9IHZvaWQgMDtcbiAgdmFyIGUgPSBXaCgpLCByID0gZnVuY3Rpb24obikge1xuICAgIHQoaSwgbik7XG4gICAgZnVuY3Rpb24gaShzKSB7XG4gICAgICByZXR1cm4gbi5jYWxsKHRoaXMsIHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBpO1xuICB9KGUuRXhjZXB0aW9uKTtcbiAgcmV0dXJuIHF0LkxvZ2ljRXJyb3IgPSByLCBxdDtcbn1cbnZhciBhbztcbmZ1bmN0aW9uIFNhKCkge1xuICBpZiAoYW8pXG4gICAgcmV0dXJuICR0O1xuICBhbyA9IDE7XG4gIHZhciB0ID0gUyAmJiBTLl9fZXh0ZW5kcyB8fCBmdW5jdGlvbigpIHtcbiAgICB2YXIgbiA9IGZ1bmN0aW9uKGksIHMpIHtcbiAgICAgIHJldHVybiBuID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24obywgYSkge1xuICAgICAgICBvLl9fcHJvdG9fXyA9IGE7XG4gICAgICB9IHx8IGZ1bmN0aW9uKG8sIGEpIHtcbiAgICAgICAgZm9yICh2YXIgYyBpbiBhKVxuICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhLCBjKSAmJiAob1tjXSA9IGFbY10pO1xuICAgICAgfSwgbihpLCBzKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbihpLCBzKSB7XG4gICAgICBpZiAodHlwZW9mIHMgIT0gXCJmdW5jdGlvblwiICYmIHMgIT09IG51bGwpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKHMpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgIG4oaSwgcyk7XG4gICAgICBmdW5jdGlvbiBvKCkge1xuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yID0gaTtcbiAgICAgIH1cbiAgICAgIGkucHJvdG90eXBlID0gcyA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUocykgOiAoby5wcm90b3R5cGUgPSBzLnByb3RvdHlwZSwgbmV3IG8oKSk7XG4gICAgfTtcbiAgfSgpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoJHQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgJHQuSW52YWxpZEFyZ3VtZW50ID0gdm9pZCAwO1xuICB2YXIgZSA9IGthKCksIHIgPSBmdW5jdGlvbihuKSB7XG4gICAgdChpLCBuKTtcbiAgICBmdW5jdGlvbiBpKHMpIHtcbiAgICAgIHJldHVybiBuLmNhbGwodGhpcywgcykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIGk7XG4gIH0oZS5Mb2dpY0Vycm9yKTtcbiAgcmV0dXJuICR0LkludmFsaWRBcmd1bWVudCA9IHIsICR0O1xufVxudmFyIFV0ID0ge30sIGNvO1xuZnVuY3Rpb24gVmgoKSB7XG4gIGlmIChjbylcbiAgICByZXR1cm4gVXQ7XG4gIGNvID0gMTtcbiAgdmFyIHQgPSBTICYmIFMuX19leHRlbmRzIHx8IGZ1bmN0aW9uKCkge1xuICAgIHZhciBuID0gZnVuY3Rpb24oaSwgcykge1xuICAgICAgcmV0dXJuIG4gPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbihvLCBhKSB7XG4gICAgICAgIG8uX19wcm90b19fID0gYTtcbiAgICAgIH0gfHwgZnVuY3Rpb24obywgYSkge1xuICAgICAgICBmb3IgKHZhciBjIGluIGEpXG4gICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGEsIGMpICYmIChvW2NdID0gYVtjXSk7XG4gICAgICB9LCBuKGksIHMpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGksIHMpIHtcbiAgICAgIGlmICh0eXBlb2YgcyAhPSBcImZ1bmN0aW9uXCIgJiYgcyAhPT0gbnVsbClcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcocykgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgbihpLCBzKTtcbiAgICAgIGZ1bmN0aW9uIG8oKSB7XG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IgPSBpO1xuICAgICAgfVxuICAgICAgaS5wcm90b3R5cGUgPSBzID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShzKSA6IChvLnByb3RvdHlwZSA9IHMucHJvdG90eXBlLCBuZXcgbygpKTtcbiAgICB9O1xuICB9KCk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVdCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBVdC5PdXRPZlJhbmdlID0gdm9pZCAwO1xuICB2YXIgZSA9IGthKCksIHIgPSBmdW5jdGlvbihuKSB7XG4gICAgdChpLCBuKTtcbiAgICBmdW5jdGlvbiBpKHMpIHtcbiAgICAgIHJldHVybiBuLmNhbGwodGhpcywgcykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIGk7XG4gIH0oZS5Mb2dpY0Vycm9yKTtcbiAgcmV0dXJuIFV0Lk91dE9mUmFuZ2UgPSByLCBVdDtcbn1cbnZhciB1bztcbmZ1bmN0aW9uIFdyKCkge1xuICByZXR1cm4gdW8gfHwgKHVvID0gMSwgZnVuY3Rpb24odCkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIHQuRXJyb3JHZW5lcmF0b3IgPSB2b2lkIDA7XG4gICAgdmFyIGUgPSBTYSgpLCByID0gVmgoKTtcbiAgICAoZnVuY3Rpb24obikge1xuICAgICAgZnVuY3Rpb24gaShkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZCA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICB2YXIgcCA9IGQuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgcmV0dXJuIGQuY29uc3RydWN0b3IuX19NT0RVTEUgJiYgKHAgPSBcIlwiLmNvbmNhdChkLmNvbnN0cnVjdG9yLl9fTU9EVUxFLCBcIi5cIikuY29uY2F0KHApKSwgXCJzdGQuXCIuY29uY2F0KHApO1xuICAgICAgfVxuICAgICAgbi5nZXRfY2xhc3NfbmFtZSA9IGk7XG4gICAgICBmdW5jdGlvbiBzKGQsIHApIHtcbiAgICAgICAgcmV0dXJuIG5ldyByLk91dE9mUmFuZ2UoXCJFcnJvciBvbiBcIi5jb25jYXQoaShkKSwgXCIuXCIpLmNvbmNhdChwLCBcIigpOiBpdCdzIGVtcHR5IGNvbnRhaW5lci5cIikpO1xuICAgICAgfVxuICAgICAgbi5lbXB0eSA9IHM7XG4gICAgICBmdW5jdGlvbiBvKGQsIHAsIHkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyByLk91dE9mUmFuZ2UoXCJFcnJvciBvbiBcIi5jb25jYXQoaShkKSwgXCIuXCIpLmNvbmNhdChwLCBcIigpOiBwYXJhbWV0cmljIGluZGV4IGlzIG5lZ2F0aXZlIC0+IChpbmRleCA9IFwiKS5jb25jYXQoeSwgXCIpLlwiKSk7XG4gICAgICB9XG4gICAgICBuLm5lZ2F0aXZlX2luZGV4ID0gbztcbiAgICAgIGZ1bmN0aW9uIGEoZCwgcCwgeSwgZykge1xuICAgICAgICByZXR1cm4gbmV3IHIuT3V0T2ZSYW5nZShcIkVycm9yIG9uIFwiLmNvbmNhdChpKGQpLCBcIi5cIikuY29uY2F0KHAsIFwiKCk6IHBhcmFtZXRyaWMgaW5kZXggaXMgZXF1YWwgb3IgZ3JlYXRlciB0aGFuIHNpemUgLT4gKGluZGV4ID0gXCIpLmNvbmNhdCh5LCBcIiwgc2l6ZTogXCIpLmNvbmNhdChnLCBcIikuXCIpKTtcbiAgICAgIH1cbiAgICAgIG4uZXhjZXNzaXZlX2luZGV4ID0gYTtcbiAgICAgIGZ1bmN0aW9uIGMoZCwgcCkge1xuICAgICAgICByZXR1cm4gbmV3IGUuSW52YWxpZEFyZ3VtZW50KFwiRXJyb3Igb24gXCIuY29uY2F0KGkoZCksIFwiLlwiKS5jb25jYXQocCwgXCIoKTogcGFyYW1ldHJpYyBpdGVyYXRvciBpcyBub3QgdGhpcyBjb250YWluZXIncyBvd24uXCIpKTtcbiAgICAgIH1cbiAgICAgIG4ubm90X215X2l0ZXJhdG9yID0gYztcbiAgICAgIGZ1bmN0aW9uIGwoZCwgcCkge1xuICAgICAgICByZXR1cm4gbmV3IGUuSW52YWxpZEFyZ3VtZW50KFwiRXJyb3Igb24gXCIuY29uY2F0KGkoZCksIFwiLlwiKS5jb25jYXQocCwgXCIoKTogcGFyYW1ldHJpYyBpdGVyYXRvciwgaXQgYWxyZWFkeSBoYXMgYmVlbiBlcmFzZWQuXCIpKTtcbiAgICAgIH1cbiAgICAgIG4uZXJhc2VkX2l0ZXJhdG9yID0gbDtcbiAgICAgIGZ1bmN0aW9uIGYoZCwgcCwgeSkge1xuICAgICAgICByZXR1cm4gbmV3IHIuT3V0T2ZSYW5nZShcIkVycm9yIG9uIFwiLmNvbmNhdChpKGQpLCBcIi5cIikuY29uY2F0KHAsIFwiKCk6IHBhcmFtZXRyaWMgaXRlcmF0b3IgaXMgZGlyZWN0aW5nIG5lZ2F0aXZlIHBvc2l0aW9uIC0+IChpbmRleCA9IFwiKS5jb25jYXQoeSwgXCIpLlwiKSk7XG4gICAgICB9XG4gICAgICBuLm5lZ2F0aXZlX2l0ZXJhdG9yID0gZjtcbiAgICAgIGZ1bmN0aW9uIHUoZCwgcCkge1xuICAgICAgICBwID09PSB2b2lkIDAgJiYgKHAgPSBcImVuZFwiKTtcbiAgICAgICAgdmFyIHkgPSBpKGQpO1xuICAgICAgICByZXR1cm4gbmV3IHIuT3V0T2ZSYW5nZShcIkVycm9yIG9uIFwiLmNvbmNhdCh5LCBcIi5JdGVyYXRvci52YWx1ZTogY2Fubm90IGFjY2VzcyB0byB0aGUgXCIpLmNvbmNhdCh5LCBcIi5cIikuY29uY2F0KHAsIFwiKCkudmFsdWUuXCIpKTtcbiAgICAgIH1cbiAgICAgIG4uaXRlcmF0b3JfZW5kX3ZhbHVlID0gdTtcbiAgICAgIGZ1bmN0aW9uIGgoZCwgcCwgeSkge1xuICAgICAgICB0aHJvdyBuZXcgci5PdXRPZlJhbmdlKFwiRXJyb3Igb24gXCIuY29uY2F0KGkoZCksIFwiLlwiKS5jb25jYXQocCwgXCIoKTogdW5hYmxlIHRvIGZpbmQgdGhlIG1hdGNoZWQga2V5IC0+IFwiKS5jb25jYXQoeSkpO1xuICAgICAgfVxuICAgICAgbi5rZXlfbm91dF9mb3VuZCA9IGg7XG4gICAgfSkodC5FcnJvckdlbmVyYXRvciB8fCAodC5FcnJvckdlbmVyYXRvciA9IHt9KSk7XG4gIH0od24pKSwgd247XG59XG52YXIgbG87XG5mdW5jdGlvbiBHaCgpIHtcbiAgaWYgKGxvKVxuICAgIHJldHVybiBSdDtcbiAgbG8gPSAxO1xuICB2YXIgdCA9IFMgJiYgUy5fX2V4dGVuZHMgfHwgZnVuY3Rpb24oKSB7XG4gICAgdmFyIG8gPSBmdW5jdGlvbihhLCBjKSB7XG4gICAgICByZXR1cm4gbyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uKGwsIGYpIHtcbiAgICAgICAgbC5fX3Byb3RvX18gPSBmO1xuICAgICAgfSB8fCBmdW5jdGlvbihsLCBmKSB7XG4gICAgICAgIGZvciAodmFyIHUgaW4gZilcbiAgICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZiwgdSkgJiYgKGxbdV0gPSBmW3VdKTtcbiAgICAgIH0sIG8oYSwgYyk7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24oYSwgYykge1xuICAgICAgaWYgKHR5cGVvZiBjICE9IFwiZnVuY3Rpb25cIiAmJiBjICE9PSBudWxsKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhjKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICBvKGEsIGMpO1xuICAgICAgZnVuY3Rpb24gbCgpIHtcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IGE7XG4gICAgICB9XG4gICAgICBhLnByb3RvdHlwZSA9IGMgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGMpIDogKGwucHJvdG90eXBlID0gYy5wcm90b3R5cGUsIG5ldyBsKCkpO1xuICAgIH07XG4gIH0oKSwgZSA9IFMgJiYgUy5fX3JlYWQgfHwgZnVuY3Rpb24obywgYSkge1xuICAgIHZhciBjID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghYylcbiAgICAgIHJldHVybiBvO1xuICAgIHZhciBsID0gYy5jYWxsKG8pLCBmLCB1ID0gW10sIGg7XG4gICAgdHJ5IHtcbiAgICAgIGZvciAoOyAoYSA9PT0gdm9pZCAwIHx8IGEtLSA+IDApICYmICEoZiA9IGwubmV4dCgpKS5kb25lOyApXG4gICAgICAgIHUucHVzaChmLnZhbHVlKTtcbiAgICB9IGNhdGNoIChkKSB7XG4gICAgICBoID0geyBlcnJvcjogZCB9O1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBmICYmICFmLmRvbmUgJiYgKGMgPSBsLnJldHVybikgJiYgYy5jYWxsKGwpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGgpXG4gICAgICAgICAgdGhyb3cgaC5lcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHU7XG4gIH0sIHIgPSBTICYmIFMuX19zcHJlYWRBcnJheSB8fCBmdW5jdGlvbihvLCBhLCBjKSB7XG4gICAgaWYgKGMgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMilcbiAgICAgIGZvciAodmFyIGwgPSAwLCBmID0gYS5sZW5ndGgsIHU7IGwgPCBmOyBsKyspXG4gICAgICAgICh1IHx8ICEobCBpbiBhKSkgJiYgKHUgfHwgKHUgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhLCAwLCBsKSksIHVbbF0gPSBhW2xdKTtcbiAgICByZXR1cm4gby5jb25jYXQodSB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhKSk7XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSdCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBSdC5VbmlxdWVTZXQgPSB2b2lkIDA7XG4gIHZhciBuID0gS2goKSwgaSA9IFdyKCksIHMgPSBmdW5jdGlvbihvKSB7XG4gICAgdChhLCBvKTtcbiAgICBmdW5jdGlvbiBhKCkge1xuICAgICAgcmV0dXJuIG8gIT09IG51bGwgJiYgby5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBhLnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbmQoYykuZXF1YWxzKHRoaXMuZW5kKCkpID8gMCA6IDE7XG4gICAgfSwgYS5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICBmb3IgKHZhciBjID0gW10sIGwgPSAwOyBsIDwgYXJndW1lbnRzLmxlbmd0aDsgbCsrKVxuICAgICAgICBjW2xdID0gYXJndW1lbnRzW2xdO1xuICAgICAgcmV0dXJuIG8ucHJvdG90eXBlLmluc2VydC5hcHBseSh0aGlzLCByKFtdLCBlKGMpLCAhMSkpO1xuICAgIH0sIGEucHJvdG90eXBlLl9JbnNlcnRfYnlfcmFuZ2UgPSBmdW5jdGlvbihjLCBsKSB7XG4gICAgICBmb3IgKDsgIWMuZXF1YWxzKGwpOyBjID0gYy5uZXh0KCkpXG4gICAgICAgIHRoaXMuX0luc2VydF9ieV9rZXkoYy52YWx1ZSk7XG4gICAgfSwgYS5wcm90b3R5cGUuZXh0cmFjdCA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgIHJldHVybiBjIGluc3RhbmNlb2YgdGhpcy5lbmQoKS5jb25zdHJ1Y3RvciA/IHRoaXMuX0V4dHJhY3RfYnlfaXRlcmF0b3IoYykgOiB0aGlzLl9FeHRyYWN0X2J5X3ZhbChjKTtcbiAgICB9LCBhLnByb3RvdHlwZS5fRXh0cmFjdF9ieV92YWwgPSBmdW5jdGlvbihjKSB7XG4gICAgICB2YXIgbCA9IHRoaXMuZmluZChjKTtcbiAgICAgIGlmIChsLmVxdWFscyh0aGlzLmVuZCgpKSA9PT0gITApXG4gICAgICAgIHRocm93IGkuRXJyb3JHZW5lcmF0b3Iua2V5X25vdXRfZm91bmQodGhpcywgXCJleHRyYWN0XCIsIGMpO1xuICAgICAgcmV0dXJuIHRoaXMuX0VyYXNlX2J5X3JhbmdlKGwpLCBjO1xuICAgIH0sIGEucHJvdG90eXBlLl9FeHRyYWN0X2J5X2l0ZXJhdG9yID0gZnVuY3Rpb24oYykge1xuICAgICAgcmV0dXJuIGMuZXF1YWxzKHRoaXMuZW5kKCkpID09PSAhMCB8fCB0aGlzLmhhcyhjLnZhbHVlKSA9PT0gITEgPyB0aGlzLmVuZCgpIDogKHRoaXMuX0VyYXNlX2J5X3JhbmdlKGMpLCBjKTtcbiAgICB9LCBhLnByb3RvdHlwZS5fRXJhc2VfYnlfdmFsID0gZnVuY3Rpb24oYykge1xuICAgICAgdmFyIGwgPSB0aGlzLmZpbmQoYyk7XG4gICAgICByZXR1cm4gbC5lcXVhbHModGhpcy5lbmQoKSkgPT09ICEwID8gMCA6ICh0aGlzLl9FcmFzZV9ieV9yYW5nZShsKSwgMSk7XG4gICAgfSwgYS5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbihjKSB7XG4gICAgICBmb3IgKHZhciBsID0gYy5iZWdpbigpOyAhbC5lcXVhbHMoYy5lbmQoKSk7IClcbiAgICAgICAgdGhpcy5oYXMobC52YWx1ZSkgPT09ICExID8gKHRoaXMuaW5zZXJ0KGwudmFsdWUpLCBsID0gYy5lcmFzZShsKSkgOiBsID0gbC5uZXh0KCk7XG4gICAgfSwgYTtcbiAgfShuLlNldENvbnRhaW5lcik7XG4gIHJldHVybiBSdC5VbmlxdWVTZXQgPSBzLCBSdDtcbn1cbnZhciBfbiA9IHt9LCBtbiA9IHt9LCBmbztcbmZ1bmN0aW9uIFpoKCkge1xuICByZXR1cm4gZm8gfHwgKGZvID0gMSwgZnVuY3Rpb24odCkge1xuICAgIHZhciBlID0gUyAmJiBTLl9fcmVhZCB8fCBmdW5jdGlvbihuLCBpKSB7XG4gICAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIG5bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICAgIGlmICghcylcbiAgICAgICAgcmV0dXJuIG47XG4gICAgICB2YXIgbyA9IHMuY2FsbChuKSwgYSwgYyA9IFtdLCBsO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICg7IChpID09PSB2b2lkIDAgfHwgaS0tID4gMCkgJiYgIShhID0gby5uZXh0KCkpLmRvbmU7IClcbiAgICAgICAgICBjLnB1c2goYS52YWx1ZSk7XG4gICAgICB9IGNhdGNoIChmKSB7XG4gICAgICAgIGwgPSB7IGVycm9yOiBmIH07XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGEgJiYgIWEuZG9uZSAmJiAocyA9IG8ucmV0dXJuKSAmJiBzLmNhbGwobyk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKGwpXG4gICAgICAgICAgICB0aHJvdyBsLmVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYztcbiAgICB9LCByID0gUyAmJiBTLl9fc3ByZWFkQXJyYXkgfHwgZnVuY3Rpb24obiwgaSwgcykge1xuICAgICAgaWYgKHMgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMilcbiAgICAgICAgZm9yICh2YXIgbyA9IDAsIGEgPSBpLmxlbmd0aCwgYzsgbyA8IGE7IG8rKylcbiAgICAgICAgICAoYyB8fCAhKG8gaW4gaSkpICYmIChjIHx8IChjID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoaSwgMCwgbykpLCBjW29dID0gaVtvXSk7XG4gICAgICByZXR1cm4gbi5jb25jYXQoYyB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChpKSk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCB0LklBc3NvY2lhdGl2ZUNvbnRhaW5lciA9IHZvaWQgMCwgZnVuY3Rpb24obikge1xuICAgICAgZnVuY3Rpb24gaShzKSB7XG4gICAgICAgIGZvciAodmFyIG8gPSBbXSwgYSA9IDE7IGEgPCBhcmd1bWVudHMubGVuZ3RoOyBhKyspXG4gICAgICAgICAgb1thIC0gMV0gPSBhcmd1bWVudHNbYV07XG4gICAgICAgIHZhciBjLCBsO1xuICAgICAgICByZXR1cm4gby5sZW5ndGggPj0gMSAmJiBvWzBdIGluc3RhbmNlb2YgQXJyYXkgPyAoYyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBmID0gb1swXTtcbiAgICAgICAgICBzLnB1c2guYXBwbHkocywgcihbXSwgZShmKSwgITEpKTtcbiAgICAgICAgfSwgbCA9IG8uc2xpY2UoMSkpIDogby5sZW5ndGggPj0gMiAmJiBvWzBdLm5leHQgaW5zdGFuY2VvZiBGdW5jdGlvbiAmJiBvWzFdLm5leHQgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IChjID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGYgPSBvWzBdLCB1ID0gb1sxXTtcbiAgICAgICAgICBzLmFzc2lnbihmLCB1KTtcbiAgICAgICAgfSwgbCA9IG8uc2xpY2UoMikpIDogKGMgPSBudWxsLCBsID0gbyksIHsgcmFtZGE6IGMsIHRhaWw6IGwgfTtcbiAgICAgIH1cbiAgICAgIG4uY29uc3RydWN0ID0gaTtcbiAgICB9KHQuSUFzc29jaWF0aXZlQ29udGFpbmVyIHx8ICh0LklBc3NvY2lhdGl2ZUNvbnRhaW5lciA9IHt9KSk7XG4gIH0obW4pKSwgbW47XG59XG52YXIganQgPSB7fSwgSHQgPSB7fSwgTXQgPSB7fSwgaG87XG5mdW5jdGlvbiBZaCgpIHtcbiAgaWYgKGhvKVxuICAgIHJldHVybiBNdDtcbiAgaG8gPSAxLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoTXQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgTXQuX0dldF9yb290ID0gdm9pZCAwO1xuICB2YXIgdCA9IGNyO1xuICBmdW5jdGlvbiBlKCkge1xuICAgIHJldHVybiByID09PSBudWxsICYmIChyID0gKDAsIHQuaXNfbm9kZSkoKSA/IFMgOiBzZWxmLCByLl9fc19pVUlEID09PSB2b2lkIDAgJiYgKHIuX19zX2lVSUQgPSAwKSksIHI7XG4gIH1cbiAgTXQuX0dldF9yb290ID0gZTtcbiAgdmFyIHIgPSBudWxsO1xuICByZXR1cm4gTXQ7XG59XG52YXIgcG87XG5mdW5jdGlvbiBPYSgpIHtcbiAgaWYgKHBvKVxuICAgIHJldHVybiBIdDtcbiAgcG8gPSAxLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoSHQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgSHQuZ2V0X3VpZCA9IHZvaWQgMDtcbiAgdmFyIHQgPSBZaCgpO1xuICBmdW5jdGlvbiBlKHIpIHtcbiAgICBpZiAociBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgaWYgKHIuaGFzT3duUHJvcGVydHkoXCJfX2dldF9tX2lVSURcIikgPT09ICExKSB7XG4gICAgICAgIHZhciBuID0gKysoMCwgdC5fR2V0X3Jvb3QpKCkuX19zX2lVSUQ7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLCBcIl9fZ2V0X21faVVJRFwiLCB7XG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByLl9fZ2V0X21faVVJRCgpO1xuICAgIH0gZWxzZVxuICAgICAgcmV0dXJuIHIgPT09IHZvaWQgMCA/IC0xIDogMDtcbiAgfVxuICByZXR1cm4gSHQuZ2V0X3VpZCA9IGUsIEh0O1xufVxudmFyIHlvO1xuZnVuY3Rpb24gd2koKSB7XG4gIGlmICh5bylcbiAgICByZXR1cm4ganQ7XG4gIHlvID0gMTtcbiAgdmFyIHQgPSBTICYmIFMuX192YWx1ZXMgfHwgZnVuY3Rpb24oYykge1xuICAgIHZhciBsID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBmID0gbCAmJiBjW2xdLCB1ID0gMDtcbiAgICBpZiAoZilcbiAgICAgIHJldHVybiBmLmNhbGwoYyk7XG4gICAgaWYgKGMgJiYgdHlwZW9mIGMubGVuZ3RoID09IFwibnVtYmVyXCIpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gYyAmJiB1ID49IGMubGVuZ3RoICYmIChjID0gdm9pZCAwKSwgeyB2YWx1ZTogYyAmJiBjW3UrK10sIGRvbmU6ICFjIH07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihsID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoanQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwganQuaGFzaCA9IHZvaWQgMDtcbiAgdmFyIGUgPSBPYSgpO1xuICBmdW5jdGlvbiByKCkge1xuICAgIGZvciAodmFyIGMsIGwsIGYgPSBbXSwgdSA9IDA7IHUgPCBhcmd1bWVudHMubGVuZ3RoOyB1KyspXG4gICAgICBmW3VdID0gYXJndW1lbnRzW3VdO1xuICAgIHZhciBoID0gbztcbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgZCA9IHQoZiksIHAgPSBkLm5leHQoKTsgIXAuZG9uZTsgcCA9IGQubmV4dCgpKSB7XG4gICAgICAgIHZhciB5ID0gcC52YWx1ZTtcbiAgICAgICAgeSA9IHkgJiYgeS52YWx1ZU9mKCk7XG4gICAgICAgIHZhciBnID0gdHlwZW9mIHk7XG4gICAgICAgIGlmIChnID09PSBcImJvb2xlYW5cIilcbiAgICAgICAgICBoID0gbih5LCBoKTtcbiAgICAgICAgZWxzZSBpZiAoZyA9PT0gXCJudW1iZXJcIiB8fCBnID09PSBcImJpZ2ludFwiKVxuICAgICAgICAgIGggPSBpKHksIGgpO1xuICAgICAgICBlbHNlIGlmIChnID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgIGggPSBzKHksIGgpO1xuICAgICAgICBlbHNlIGlmICh5IGluc3RhbmNlb2YgT2JqZWN0ICYmIHkuaGFzaENvZGUgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgIHZhciB2ID0geS5oYXNoQ29kZSgpO1xuICAgICAgICAgIGlmIChmLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgIGggPSBoIF4gdiwgaCAqPSBhO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICBoID0gaSgoMCwgZS5nZXRfdWlkKSh5KSwgaCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgYyA9IHsgZXJyb3I6IF8gfTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcCAmJiAhcC5kb25lICYmIChsID0gZC5yZXR1cm4pICYmIGwuY2FsbChkKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChjKVxuICAgICAgICAgIHRocm93IGMuZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBNYXRoLmFicyhoKTtcbiAgfVxuICBqdC5oYXNoID0gcjtcbiAgZnVuY3Rpb24gbihjLCBsKSB7XG4gICAgcmV0dXJuIGwgXj0gYyA/IDEgOiAwLCBsICo9IGEsIGw7XG4gIH1cbiAgZnVuY3Rpb24gaShjLCBsKSB7XG4gICAgcmV0dXJuIHMoYy50b1N0cmluZygpLCBsKTtcbiAgfVxuICBmdW5jdGlvbiBzKGMsIGwpIHtcbiAgICBmb3IgKHZhciBmID0gMDsgZiA8IGMubGVuZ3RoOyArK2YpXG4gICAgICBsIF49IGMuY2hhckNvZGVBdChmKSwgbCAqPSBhO1xuICAgIHJldHVybiBNYXRoLmFicyhsKTtcbiAgfVxuICB2YXIgbyA9IDIxNjYxMzYyNjEsIGEgPSAxNjc3NzYxOTtcbiAgcmV0dXJuIGp0O1xufVxudmFyIGFlID0ge30sIGdvO1xuZnVuY3Rpb24gX2koKSB7XG4gIGlmIChnbylcbiAgICByZXR1cm4gYWU7XG4gIGdvID0gMSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFlLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIGFlLmdyZWF0ZXJfZXF1YWwgPSBhZS5ncmVhdGVyID0gYWUubGVzc19lcXVhbCA9IGFlLmxlc3MgPSBhZS5ub3RfZXF1YWxfdG8gPSBhZS5lcXVhbF90byA9IHZvaWQgMDtcbiAgdmFyIHQgPSBPYSgpO1xuICBmdW5jdGlvbiBlKGEsIGMpIHtcbiAgICByZXR1cm4gYSA9IGEgJiYgYS52YWx1ZU9mKCksIGMgPSBjICYmIGMudmFsdWVPZigpLCBhIGluc3RhbmNlb2YgT2JqZWN0ICYmIGEuZXF1YWxzIGluc3RhbmNlb2YgRnVuY3Rpb24gPyBhLmVxdWFscyhjKSA6IGEgPT09IGM7XG4gIH1cbiAgYWUuZXF1YWxfdG8gPSBlO1xuICBmdW5jdGlvbiByKGEsIGMpIHtcbiAgICByZXR1cm4gIWUoYSwgYyk7XG4gIH1cbiAgYWUubm90X2VxdWFsX3RvID0gcjtcbiAgZnVuY3Rpb24gbihhLCBjKSB7XG4gICAgcmV0dXJuIGEgPSBhLnZhbHVlT2YoKSwgYyA9IGMudmFsdWVPZigpLCBhIGluc3RhbmNlb2YgT2JqZWN0ID8gYS5sZXNzIGluc3RhbmNlb2YgRnVuY3Rpb24gPyBhLmxlc3MoYykgOiAoMCwgdC5nZXRfdWlkKShhKSA8ICgwLCB0LmdldF91aWQpKGMpIDogYSA8IGM7XG4gIH1cbiAgYWUubGVzcyA9IG47XG4gIGZ1bmN0aW9uIGkoYSwgYykge1xuICAgIHJldHVybiBuKGEsIGMpIHx8IGUoYSwgYyk7XG4gIH1cbiAgYWUubGVzc19lcXVhbCA9IGk7XG4gIGZ1bmN0aW9uIHMoYSwgYykge1xuICAgIHJldHVybiAhaShhLCBjKTtcbiAgfVxuICBhZS5ncmVhdGVyID0gcztcbiAgZnVuY3Rpb24gbyhhLCBjKSB7XG4gICAgcmV0dXJuICFuKGEsIGMpO1xuICB9XG4gIHJldHVybiBhZS5ncmVhdGVyX2VxdWFsID0gbywgYWU7XG59XG52YXIgYm87XG5mdW5jdGlvbiBBYSgpIHtcbiAgcmV0dXJuIGJvIHx8IChibyA9IDEsIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSA9IFMgJiYgUy5fX3JlYWQgfHwgZnVuY3Rpb24obywgYSkge1xuICAgICAgdmFyIGMgPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgICBpZiAoIWMpXG4gICAgICAgIHJldHVybiBvO1xuICAgICAgdmFyIGwgPSBjLmNhbGwobyksIGYsIHUgPSBbXSwgaDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoOyAoYSA9PT0gdm9pZCAwIHx8IGEtLSA+IDApICYmICEoZiA9IGwubmV4dCgpKS5kb25lOyApXG4gICAgICAgICAgdS5wdXNoKGYudmFsdWUpO1xuICAgICAgfSBjYXRjaCAoZCkge1xuICAgICAgICBoID0geyBlcnJvcjogZCB9O1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmICYmICFmLmRvbmUgJiYgKGMgPSBsLnJldHVybikgJiYgYy5jYWxsKGwpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChoKVxuICAgICAgICAgICAgdGhyb3cgaC5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHU7XG4gICAgfSwgciA9IFMgJiYgUy5fX3NwcmVhZEFycmF5IHx8IGZ1bmN0aW9uKG8sIGEsIGMpIHtcbiAgICAgIGlmIChjIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpXG4gICAgICAgIGZvciAodmFyIGwgPSAwLCBmID0gYS5sZW5ndGgsIHU7IGwgPCBmOyBsKyspXG4gICAgICAgICAgKHUgfHwgIShsIGluIGEpKSAmJiAodSB8fCAodSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGEsIDAsIGwpKSwgdVtsXSA9IGFbbF0pO1xuICAgICAgcmV0dXJuIG8uY29uY2F0KHUgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYSkpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgdC5JSGFzaENvbnRhaW5lciA9IHZvaWQgMDtcbiAgICB2YXIgbiA9IFpoKCksIGkgPSB3aSgpLCBzID0gX2koKTtcbiAgICAoZnVuY3Rpb24obykge1xuICAgICAgZnVuY3Rpb24gYShjLCBsLCBmKSB7XG4gICAgICAgIGZvciAodmFyIHUgPSBbXSwgaCA9IDM7IGggPCBhcmd1bWVudHMubGVuZ3RoOyBoKyspXG4gICAgICAgICAgdVtoIC0gM10gPSBhcmd1bWVudHNbaF07XG4gICAgICAgIHZhciBkID0gbnVsbCwgcCA9IGkuaGFzaCwgeSA9IHMuZXF1YWxfdG87XG4gICAgICAgIGlmICh1Lmxlbmd0aCA9PT0gMSAmJiB1WzBdIGluc3RhbmNlb2YgbCkge1xuICAgICAgICAgIHZhciBnID0gdVswXTtcbiAgICAgICAgICBwID0gZy5oYXNoX2Z1bmN0aW9uKCksIHkgPSBnLmtleV9lcSgpLCBkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgXyA9IGcuYmVnaW4oKSwgbSA9IGcuZW5kKCk7XG4gICAgICAgICAgICBjLmFzc2lnbihfLCBtKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB2ID0gbi5JQXNzb2NpYXRpdmVDb250YWluZXIuY29uc3RydWN0LmFwcGx5KG4uSUFzc29jaWF0aXZlQ29udGFpbmVyLCByKFtjXSwgZSh1KSwgITEpKTtcbiAgICAgICAgICBkID0gdi5yYW1kYSwgdi50YWlsLmxlbmd0aCA+PSAxICYmIChwID0gdi50YWlsWzBdKSwgdi50YWlsLmxlbmd0aCA+PSAyICYmICh5ID0gdi50YWlsWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBmKHAsIHkpLCBkICE9PSBudWxsICYmIGQoKTtcbiAgICAgIH1cbiAgICAgIG8uY29uc3RydWN0ID0gYTtcbiAgICB9KSh0LklIYXNoQ29udGFpbmVyIHx8ICh0LklIYXNoQ29udGFpbmVyID0ge30pKTtcbiAgfShfbikpLCBfbjtcbn1cbnZhciB4biA9IHt9LCBEdCA9IHt9LCB6dCA9IHt9LCB2bztcbmZ1bmN0aW9uIG1pKCkge1xuICBpZiAodm8pXG4gICAgcmV0dXJuIHp0O1xuICB2byA9IDEsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh6dCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCB6dC5MaXN0SXRlcmF0b3IgPSB2b2lkIDA7XG4gIHZhciB0ID0gV3IoKSwgZSA9IGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIHIobiwgaSwgcykge1xuICAgICAgdGhpcy5wcmV2XyA9IG4sIHRoaXMubmV4dF8gPSBpLCB0aGlzLnZhbHVlXyA9IHM7XG4gICAgfVxuICAgIHJldHVybiByLl9TZXRfcHJldiA9IGZ1bmN0aW9uKG4sIGkpIHtcbiAgICAgIG4ucHJldl8gPSBpO1xuICAgIH0sIHIuX1NldF9uZXh0ID0gZnVuY3Rpb24obiwgaSkge1xuICAgICAgbi5uZXh0XyA9IGk7XG4gICAgfSwgci5wcm90b3R5cGUucHJldiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMucHJldl87XG4gICAgfSwgci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubmV4dF87XG4gICAgfSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHIucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9UcnlfdmFsdWUoKSwgdGhpcy52YWx1ZV87XG4gICAgICB9LFxuICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgfSksIHIucHJvdG90eXBlLl9UcnlfdmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnZhbHVlXyA9PT0gdm9pZCAwICYmIHRoaXMuZXF1YWxzKHRoaXMuc291cmNlKCkuZW5kKCkpID09PSAhMClcbiAgICAgICAgdGhyb3cgdC5FcnJvckdlbmVyYXRvci5pdGVyYXRvcl9lbmRfdmFsdWUodGhpcy5zb3VyY2UoKSk7XG4gICAgfSwgci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24obikge1xuICAgICAgcmV0dXJuIHRoaXMgPT09IG47XG4gICAgfSwgcjtcbiAgfSgpO1xuICByZXR1cm4genQuTGlzdEl0ZXJhdG9yID0gZSwgenQ7XG59XG52YXIgRnQgPSB7fSwgd287XG5mdW5jdGlvbiBKaCgpIHtcbiAgaWYgKHdvKVxuICAgIHJldHVybiBGdDtcbiAgd28gPSAxLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoRnQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgRnQuUmVwZWF0ZXIgPSB2b2lkIDA7XG4gIHZhciB0ID0gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gZShyLCBuKSB7XG4gICAgICB0aGlzLmluZGV4XyA9IHIsIHRoaXMudmFsdWVfID0gbjtcbiAgICB9XG4gICAgcmV0dXJuIGUucHJvdG90eXBlLmluZGV4ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbmRleF87XG4gICAgfSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlXztcbiAgICAgIH0sXG4gICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICB9KSwgZS5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICsrdGhpcy5pbmRleF8sIHRoaXM7XG4gICAgfSwgZS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24ocikge1xuICAgICAgcmV0dXJuIHRoaXMuaW5kZXhfID09PSByLmluZGV4XztcbiAgICB9LCBlO1xuICB9KCk7XG4gIHJldHVybiBGdC5SZXBlYXRlciA9IHQsIEZ0O1xufVxudmFyIGNlID0ge30sIF9vO1xuZnVuY3Rpb24gWGgoKSB7XG4gIGlmIChfbylcbiAgICByZXR1cm4gY2U7XG4gIF9vID0gMSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNlLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIGNlLm5leHQgPSBjZS5wcmV2ID0gY2UuYWR2YW5jZSA9IGNlLmRpc3RhbmNlID0gY2Uuc2l6ZSA9IGNlLmVtcHR5ID0gdm9pZCAwO1xuICB2YXIgdCA9IFNhKCk7XG4gIGZ1bmN0aW9uIGUoYykge1xuICAgIHJldHVybiBjIGluc3RhbmNlb2YgQXJyYXkgPyBjLmxlbmd0aCAhPT0gMCA6IGMuZW1wdHkoKTtcbiAgfVxuICBjZS5lbXB0eSA9IGU7XG4gIGZ1bmN0aW9uIHIoYykge1xuICAgIHJldHVybiBjIGluc3RhbmNlb2YgQXJyYXkgPyBjLmxlbmd0aCA6IGMuc2l6ZSgpO1xuICB9XG4gIGNlLnNpemUgPSByO1xuICBmdW5jdGlvbiBuKGMsIGwpIHtcbiAgICBpZiAoYy5pbmRleCBpbnN0YW5jZW9mIEZ1bmN0aW9uKVxuICAgICAgcmV0dXJuIGkoYywgbCk7XG4gICAgZm9yICh2YXIgZiA9IDA7ICFjLmVxdWFscyhsKTsgYyA9IGMubmV4dCgpKVxuICAgICAgKytmO1xuICAgIHJldHVybiBmO1xuICB9XG4gIGNlLmRpc3RhbmNlID0gbjtcbiAgZnVuY3Rpb24gaShjLCBsKSB7XG4gICAgdmFyIGYgPSBjLmluZGV4KCksIHUgPSBsLmluZGV4KCk7XG4gICAgcmV0dXJuIGMuYmFzZSBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gZiAtIHUgOiB1IC0gZjtcbiAgfVxuICBmdW5jdGlvbiBzKGMsIGwpIHtcbiAgICBpZiAobCA9PT0gMClcbiAgICAgIHJldHVybiBjO1xuICAgIGlmIChjLmFkdmFuY2UgaW5zdGFuY2VvZiBGdW5jdGlvbilcbiAgICAgIHJldHVybiBjLmFkdmFuY2UobCk7XG4gICAgdmFyIGY7XG4gICAgaWYgKGwgPCAwKSB7XG4gICAgICBpZiAoIShjLnByZXYgaW5zdGFuY2VvZiBGdW5jdGlvbikpXG4gICAgICAgIHRocm93IG5ldyB0LkludmFsaWRBcmd1bWVudChcIkVycm9yIG9uIHN0ZC5hZHZhbmNlKCk6IHBhcmFtZXRyaWMgaXRlcmF0b3IgaXMgbm90IGEgYmktZGlyZWN0aW9uYWwgaXRlcmF0b3IsIHRodXMgYWR2YW5jaW5nIHRvIG5lZ2F0aXZlIGRpcmVjdGlvbiBpcyBub3QgcG9zc2libGUuXCIpO1xuICAgICAgZiA9IGZ1bmN0aW9uKHUpIHtcbiAgICAgICAgcmV0dXJuIHUucHJldigpO1xuICAgICAgfSwgbCA9IC1sO1xuICAgIH0gZWxzZVxuICAgICAgZiA9IGZ1bmN0aW9uKHUpIHtcbiAgICAgICAgcmV0dXJuIHUubmV4dCgpO1xuICAgICAgfTtcbiAgICBmb3IgKDsgbC0tID4gMDsgKVxuICAgICAgYyA9IGYoYyk7XG4gICAgcmV0dXJuIGM7XG4gIH1cbiAgY2UuYWR2YW5jZSA9IHM7XG4gIGZ1bmN0aW9uIG8oYywgbCkge1xuICAgIHJldHVybiBsID09PSB2b2lkIDAgJiYgKGwgPSAxKSwgbCA9PT0gMSA/IGMucHJldigpIDogcyhjLCAtbCk7XG4gIH1cbiAgY2UucHJldiA9IG87XG4gIGZ1bmN0aW9uIGEoYywgbCkge1xuICAgIHJldHVybiBsID09PSB2b2lkIDAgJiYgKGwgPSAxKSwgbCA9PT0gMSA/IGMubmV4dCgpIDogcyhjLCBsKTtcbiAgfVxuICByZXR1cm4gY2UubmV4dCA9IGEsIGNlO1xufVxudmFyIG1vO1xuZnVuY3Rpb24gQ2EoKSB7XG4gIGlmIChtbylcbiAgICByZXR1cm4gRHQ7XG4gIG1vID0gMTtcbiAgdmFyIHQgPSBTICYmIFMuX19leHRlbmRzIHx8IGZ1bmN0aW9uKCkge1xuICAgIHZhciBsID0gZnVuY3Rpb24oZiwgdSkge1xuICAgICAgcmV0dXJuIGwgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbihoLCBkKSB7XG4gICAgICAgIGguX19wcm90b19fID0gZDtcbiAgICAgIH0gfHwgZnVuY3Rpb24oaCwgZCkge1xuICAgICAgICBmb3IgKHZhciBwIGluIGQpXG4gICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGQsIHApICYmIChoW3BdID0gZFtwXSk7XG4gICAgICB9LCBsKGYsIHUpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGYsIHUpIHtcbiAgICAgIGlmICh0eXBlb2YgdSAhPSBcImZ1bmN0aW9uXCIgJiYgdSAhPT0gbnVsbClcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcodSkgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgbChmLCB1KTtcbiAgICAgIGZ1bmN0aW9uIGgoKSB7XG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IgPSBmO1xuICAgICAgfVxuICAgICAgZi5wcm90b3R5cGUgPSB1ID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZSh1KSA6IChoLnByb3RvdHlwZSA9IHUucHJvdG90eXBlLCBuZXcgaCgpKTtcbiAgICB9O1xuICB9KCksIGUgPSBTICYmIFMuX19yZWFkIHx8IGZ1bmN0aW9uKGwsIGYpIHtcbiAgICB2YXIgdSA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIGxbU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIXUpXG4gICAgICByZXR1cm4gbDtcbiAgICB2YXIgaCA9IHUuY2FsbChsKSwgZCwgcCA9IFtdLCB5O1xuICAgIHRyeSB7XG4gICAgICBmb3IgKDsgKGYgPT09IHZvaWQgMCB8fCBmLS0gPiAwKSAmJiAhKGQgPSBoLm5leHQoKSkuZG9uZTsgKVxuICAgICAgICBwLnB1c2goZC52YWx1ZSk7XG4gICAgfSBjYXRjaCAoZykge1xuICAgICAgeSA9IHsgZXJyb3I6IGcgfTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZCAmJiAhZC5kb25lICYmICh1ID0gaC5yZXR1cm4pICYmIHUuY2FsbChoKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmICh5KVxuICAgICAgICAgIHRocm93IHkuZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRHQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgRHQuTGlzdENvbnRhaW5lciA9IHZvaWQgMDtcbiAgdmFyIHIgPSBiaSgpLCBuID0gbWkoKSwgaSA9IEpoKCksIHMgPSB2aSgpLCBvID0gWGgoKSwgYSA9IFdyKCksIGMgPSBmdW5jdGlvbihsKSB7XG4gICAgdChmLCBsKTtcbiAgICBmdW5jdGlvbiBmKCkge1xuICAgICAgdmFyIHUgPSBsLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgIHJldHVybiB1LmVuZF8gPSB1Ll9DcmVhdGVfaXRlcmF0b3IobnVsbCwgbnVsbCksIHUuY2xlYXIoKSwgdTtcbiAgICB9XG4gICAgcmV0dXJuIGYucHJvdG90eXBlLmFzc2lnbiA9IGZ1bmN0aW9uKHUsIGgpIHtcbiAgICAgIHRoaXMuY2xlYXIoKSwgdGhpcy5pbnNlcnQodGhpcy5lbmQoKSwgdSwgaCk7XG4gICAgfSwgZi5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIG4uTGlzdEl0ZXJhdG9yLl9TZXRfcHJldih0aGlzLmVuZF8sIHRoaXMuZW5kXyksIG4uTGlzdEl0ZXJhdG9yLl9TZXRfbmV4dCh0aGlzLmVuZF8sIHRoaXMuZW5kXyksIHRoaXMuYmVnaW5fID0gdGhpcy5lbmRfLCB0aGlzLnNpemVfID0gMDtcbiAgICB9LCBmLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbih1KSB7XG4gICAgICB2YXIgaCA9IHUgLSB0aGlzLnNpemUoKTtcbiAgICAgIGggPiAwID8gdGhpcy5pbnNlcnQodGhpcy5lbmQoKSwgaCwgdm9pZCAwKSA6IGggPCAwICYmIHRoaXMuZXJhc2UoKDAsIG8uYWR2YW5jZSkodGhpcy5lbmQoKSwgLWgpLCB0aGlzLmVuZCgpKTtcbiAgICB9LCBmLnByb3RvdHlwZS5iZWdpbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYmVnaW5fO1xuICAgIH0sIGYucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZW5kXztcbiAgICB9LCBmLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5zaXplXztcbiAgICB9LCBmLnByb3RvdHlwZS5wdXNoX2Zyb250ID0gZnVuY3Rpb24odSkge1xuICAgICAgdGhpcy5pbnNlcnQodGhpcy5iZWdpbl8sIHUpO1xuICAgIH0sIGYucHJvdG90eXBlLnB1c2hfYmFjayA9IGZ1bmN0aW9uKHUpIHtcbiAgICAgIHRoaXMuaW5zZXJ0KHRoaXMuZW5kXywgdSk7XG4gICAgfSwgZi5wcm90b3R5cGUucG9wX2Zyb250ID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5lbXB0eSgpID09PSAhMClcbiAgICAgICAgdGhyb3cgYS5FcnJvckdlbmVyYXRvci5lbXB0eSh0aGlzLmVuZF8uc291cmNlKCkuY29uc3RydWN0b3IubmFtZSwgXCJwb3BfZnJvbnRcIik7XG4gICAgICB0aGlzLmVyYXNlKHRoaXMuYmVnaW5fKTtcbiAgICB9LCBmLnByb3RvdHlwZS5wb3BfYmFjayA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuZW1wdHkoKSA9PT0gITApXG4gICAgICAgIHRocm93IGEuRXJyb3JHZW5lcmF0b3IuZW1wdHkodGhpcy5lbmRfLnNvdXJjZSgpLmNvbnN0cnVjdG9yLm5hbWUsIFwicG9wX2JhY2tcIik7XG4gICAgICB0aGlzLmVyYXNlKHRoaXMuZW5kXy5wcmV2KCkpO1xuICAgIH0sIGYucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbigpIHtcbiAgICAgIGZvciAodmFyIHUgPSBbXSwgaCA9IDA7IGggPCBhcmd1bWVudHMubGVuZ3RoOyBoKyspXG4gICAgICAgIHVbaF0gPSBhcmd1bWVudHNbaF07XG4gICAgICBpZiAodS5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiB0aGlzLnNpemUoKTtcbiAgICAgIHZhciBkID0gbmV3IHMuTmF0aXZlQXJyYXlJdGVyYXRvcih1LCAwKSwgcCA9IG5ldyBzLk5hdGl2ZUFycmF5SXRlcmF0b3IodSwgdS5sZW5ndGgpO1xuICAgICAgcmV0dXJuIHRoaXMuX0luc2VydF9ieV9yYW5nZSh0aGlzLmVuZCgpLCBkLCBwKSwgdGhpcy5zaXplKCk7XG4gICAgfSwgZi5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24odSkge1xuICAgICAgZm9yICh2YXIgaCA9IFtdLCBkID0gMTsgZCA8IGFyZ3VtZW50cy5sZW5ndGg7IGQrKylcbiAgICAgICAgaFtkIC0gMV0gPSBhcmd1bWVudHNbZF07XG4gICAgICBpZiAodS5zb3VyY2UoKSAhPT0gdGhpcy5lbmRfLnNvdXJjZSgpKVxuICAgICAgICB0aHJvdyBhLkVycm9yR2VuZXJhdG9yLm5vdF9teV9pdGVyYXRvcih0aGlzLmVuZF8uc291cmNlKCksIFwiaW5zZXJ0XCIpO1xuICAgICAgaWYgKHUuZXJhc2VkXyA9PT0gITApXG4gICAgICAgIHRocm93IGEuRXJyb3JHZW5lcmF0b3IuZXJhc2VkX2l0ZXJhdG9yKHRoaXMuZW5kXy5zb3VyY2UoKSwgXCJpbnNlcnRcIik7XG4gICAgICByZXR1cm4gaC5sZW5ndGggPT09IDEgPyB0aGlzLl9JbnNlcnRfYnlfcmVwZWF0aW5nX3ZhbCh1LCAxLCBoWzBdKSA6IGgubGVuZ3RoID09PSAyICYmIHR5cGVvZiBoWzBdID09IFwibnVtYmVyXCIgPyB0aGlzLl9JbnNlcnRfYnlfcmVwZWF0aW5nX3ZhbCh1LCBoWzBdLCBoWzFdKSA6IHRoaXMuX0luc2VydF9ieV9yYW5nZSh1LCBoWzBdLCBoWzFdKTtcbiAgICB9LCBmLnByb3RvdHlwZS5fSW5zZXJ0X2J5X3JlcGVhdGluZ192YWwgPSBmdW5jdGlvbih1LCBoLCBkKSB7XG4gICAgICB2YXIgcCA9IG5ldyBpLlJlcGVhdGVyKDAsIGQpLCB5ID0gbmV3IGkuUmVwZWF0ZXIoaCk7XG4gICAgICByZXR1cm4gdGhpcy5fSW5zZXJ0X2J5X3JhbmdlKHUsIHAsIHkpO1xuICAgIH0sIGYucHJvdG90eXBlLl9JbnNlcnRfYnlfcmFuZ2UgPSBmdW5jdGlvbih1LCBoLCBkKSB7XG4gICAgICBmb3IgKHZhciBwID0gdS5wcmV2KCksIHkgPSBudWxsLCBnID0gMCwgdiA9IGg7IHYuZXF1YWxzKGQpID09PSAhMTsgdiA9IHYubmV4dCgpKSB7XG4gICAgICAgIHZhciBfID0gdGhpcy5fQ3JlYXRlX2l0ZXJhdG9yKHAsIG51bGwsIHYudmFsdWUpO1xuICAgICAgICBnID09PSAwICYmICh5ID0gXyksIG4uTGlzdEl0ZXJhdG9yLl9TZXRfbmV4dChwLCBfKSwgcCA9IF8sICsrZztcbiAgICAgIH1cbiAgICAgIHJldHVybiB1LmVxdWFscyh0aGlzLmJlZ2luKCkpID09PSAhMCAmJiAodGhpcy5iZWdpbl8gPSB5KSwgbi5MaXN0SXRlcmF0b3IuX1NldF9uZXh0KHAsIHUpLCBuLkxpc3RJdGVyYXRvci5fU2V0X3ByZXYodSwgcCksIHRoaXMuc2l6ZV8gKz0gZywgeTtcbiAgICB9LCBmLnByb3RvdHlwZS5lcmFzZSA9IGZ1bmN0aW9uKHUsIGgpIHtcbiAgICAgIHJldHVybiBoID09PSB2b2lkIDAgJiYgKGggPSB1Lm5leHQoKSksIHRoaXMuX0VyYXNlX2J5X3JhbmdlKHUsIGgpO1xuICAgIH0sIGYucHJvdG90eXBlLl9FcmFzZV9ieV9yYW5nZSA9IGZ1bmN0aW9uKHUsIGgpIHtcbiAgICAgIGlmICh1LnNvdXJjZSgpICE9PSB0aGlzLmVuZF8uc291cmNlKCkpXG4gICAgICAgIHRocm93IGEuRXJyb3JHZW5lcmF0b3Iubm90X215X2l0ZXJhdG9yKHRoaXMuZW5kXy5zb3VyY2UoKSwgXCJpbnNlcnRcIik7XG4gICAgICBpZiAodS5lcmFzZWRfID09PSAhMClcbiAgICAgICAgdGhyb3cgYS5FcnJvckdlbmVyYXRvci5lcmFzZWRfaXRlcmF0b3IodGhpcy5lbmRfLnNvdXJjZSgpLCBcImluc2VydFwiKTtcbiAgICAgIGlmICh1LmVxdWFscyh0aGlzLmVuZF8pKVxuICAgICAgICByZXR1cm4gdGhpcy5lbmRfO1xuICAgICAgdmFyIGQgPSB1LnByZXYoKTtcbiAgICAgIG4uTGlzdEl0ZXJhdG9yLl9TZXRfbmV4dChkLCBoKSwgbi5MaXN0SXRlcmF0b3IuX1NldF9wcmV2KGgsIGQpO1xuICAgICAgZm9yICh2YXIgcCA9IHU7ICFwLmVxdWFscyhoKTsgcCA9IHAubmV4dCgpKVxuICAgICAgICBwLmVyYXNlZF8gPSAhMCwgLS10aGlzLnNpemVfO1xuICAgICAgcmV0dXJuIHUuZXF1YWxzKHRoaXMuYmVnaW5fKSAmJiAodGhpcy5iZWdpbl8gPSBoKSwgaDtcbiAgICB9LCBmLnByb3RvdHlwZS5zd2FwID0gZnVuY3Rpb24odSkge1xuICAgICAgdmFyIGgsIGQsIHA7XG4gICAgICBoID0gZShbdS5iZWdpbl8sIHRoaXMuYmVnaW5fXSwgMiksIHRoaXMuYmVnaW5fID0gaFswXSwgdS5iZWdpbl8gPSBoWzFdLCBkID0gZShbdS5lbmRfLCB0aGlzLmVuZF9dLCAyKSwgdGhpcy5lbmRfID0gZFswXSwgdS5lbmRfID0gZFsxXSwgcCA9IGUoW3Uuc2l6ZV8sIHRoaXMuc2l6ZV9dLCAyKSwgdGhpcy5zaXplXyA9IHBbMF0sIHUuc2l6ZV8gPSBwWzFdO1xuICAgIH0sIGY7XG4gIH0oci5Db250YWluZXIpO1xuICByZXR1cm4gRHQuTGlzdENvbnRhaW5lciA9IGMsIER0O1xufVxudmFyIEt0ID0ge30sIHhvO1xuZnVuY3Rpb24gSWEoKSB7XG4gIGlmICh4bylcbiAgICByZXR1cm4gS3Q7XG4gIHhvID0gMSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KEt0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIEt0LlJldmVyc2VJdGVyYXRvciA9IHZvaWQgMDtcbiAgdmFyIHQgPSBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBlKHIpIHtcbiAgICAgIHRoaXMuYmFzZV8gPSByLnByZXYoKTtcbiAgICB9XG4gICAgcmV0dXJuIGUucHJvdG90eXBlLnNvdXJjZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYmFzZV8uc291cmNlKCk7XG4gICAgfSwgZS5wcm90b3R5cGUuYmFzZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYmFzZV8ubmV4dCgpO1xuICAgIH0sIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iYXNlXy52YWx1ZTtcbiAgICAgIH0sXG4gICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICB9KSwgZS5wcm90b3R5cGUucHJldiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX0NyZWF0ZV9uZWlnaGJvcih0aGlzLmJhc2UoKS5uZXh0KCkpO1xuICAgIH0sIGUucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9DcmVhdGVfbmVpZ2hib3IodGhpcy5iYXNlXyk7XG4gICAgfSwgZS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24ocikge1xuICAgICAgcmV0dXJuIHRoaXMuYmFzZV8uZXF1YWxzKHIuYmFzZV8pO1xuICAgIH0sIGU7XG4gIH0oKTtcbiAgcmV0dXJuIEt0LlJldmVyc2VJdGVyYXRvciA9IHQsIEt0O1xufVxudmFyIEVvO1xuZnVuY3Rpb24gUWgoKSB7XG4gIHJldHVybiBFbyB8fCAoRW8gPSAxLCBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGUgPSBTICYmIFMuX19leHRlbmRzIHx8IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGEgPSBmdW5jdGlvbihjLCBsKSB7XG4gICAgICAgIHJldHVybiBhID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24oZiwgdSkge1xuICAgICAgICAgIGYuX19wcm90b19fID0gdTtcbiAgICAgICAgfSB8fCBmdW5jdGlvbihmLCB1KSB7XG4gICAgICAgICAgZm9yICh2YXIgaCBpbiB1KVxuICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHUsIGgpICYmIChmW2hdID0gdVtoXSk7XG4gICAgICAgIH0sIGEoYywgbCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGMsIGwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBsICE9IFwiZnVuY3Rpb25cIiAmJiBsICE9PSBudWxsKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGwpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgYShjLCBsKTtcbiAgICAgICAgZnVuY3Rpb24gZigpIHtcbiAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yID0gYztcbiAgICAgICAgfVxuICAgICAgICBjLnByb3RvdHlwZSA9IGwgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGwpIDogKGYucHJvdG90eXBlID0gbC5wcm90b3R5cGUsIG5ldyBmKCkpO1xuICAgICAgfTtcbiAgICB9KCksIHIgPSBTICYmIFMuX19yZWFkIHx8IGZ1bmN0aW9uKGEsIGMpIHtcbiAgICAgIHZhciBsID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgYVtTeW1ib2wuaXRlcmF0b3JdO1xuICAgICAgaWYgKCFsKVxuICAgICAgICByZXR1cm4gYTtcbiAgICAgIHZhciBmID0gbC5jYWxsKGEpLCB1LCBoID0gW10sIGQ7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKDsgKGMgPT09IHZvaWQgMCB8fCBjLS0gPiAwKSAmJiAhKHUgPSBmLm5leHQoKSkuZG9uZTsgKVxuICAgICAgICAgIGgucHVzaCh1LnZhbHVlKTtcbiAgICAgIH0gY2F0Y2ggKHApIHtcbiAgICAgICAgZCA9IHsgZXJyb3I6IHAgfTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdSAmJiAhdS5kb25lICYmIChsID0gZi5yZXR1cm4pICYmIGwuY2FsbChmKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoZClcbiAgICAgICAgICAgIHRocm93IGQuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBoO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgdC5TZXRFbGVtZW50TGlzdCA9IHZvaWQgMDtcbiAgICB2YXIgbiA9IENhKCksIGkgPSBtaSgpLCBzID0gSWEoKSwgbyA9IGZ1bmN0aW9uKGEpIHtcbiAgICAgIGUoYywgYSk7XG4gICAgICBmdW5jdGlvbiBjKGwpIHtcbiAgICAgICAgdmFyIGYgPSBhLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgcmV0dXJuIGYuYXNzb2NpYXRpdmVfID0gbCwgZjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjLnByb3RvdHlwZS5fQ3JlYXRlX2l0ZXJhdG9yID0gZnVuY3Rpb24obCwgZiwgdSkge1xuICAgICAgICByZXR1cm4gYy5JdGVyYXRvci5jcmVhdGUodGhpcywgbCwgZiwgdSk7XG4gICAgICB9LCBjLl9Td2FwX2Fzc29jaWF0aXZlID0gZnVuY3Rpb24obCwgZikge1xuICAgICAgICB2YXIgdTtcbiAgICAgICAgdSA9IHIoW2YuYXNzb2NpYXRpdmVfLCBsLmFzc29jaWF0aXZlX10sIDIpLCBsLmFzc29jaWF0aXZlXyA9IHVbMF0sIGYuYXNzb2NpYXRpdmVfID0gdVsxXTtcbiAgICAgIH0sIGMucHJvdG90eXBlLmFzc29jaWF0aXZlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFzc29jaWF0aXZlXztcbiAgICAgIH0sIGM7XG4gICAgfShuLkxpc3RDb250YWluZXIpO1xuICAgIHQuU2V0RWxlbWVudExpc3QgPSBvLCBmdW5jdGlvbihhKSB7XG4gICAgICB2YXIgYyA9IGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgZSh1LCBmKTtcbiAgICAgICAgZnVuY3Rpb24gdShoLCBkLCBwLCB5KSB7XG4gICAgICAgICAgdmFyIGcgPSBmLmNhbGwodGhpcywgZCwgcCwgeSkgfHwgdGhpcztcbiAgICAgICAgICByZXR1cm4gZy5zb3VyY2VfID0gaCwgZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdS5jcmVhdGUgPSBmdW5jdGlvbihoLCBkLCBwLCB5KSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyB1KGgsIGQsIHAsIHkpO1xuICAgICAgICB9LCB1LnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBsKHRoaXMpO1xuICAgICAgICB9LCB1LnByb3RvdHlwZS5zb3VyY2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VfLmFzc29jaWF0aXZlKCk7XG4gICAgICAgIH0sIHU7XG4gICAgICB9KGkuTGlzdEl0ZXJhdG9yKTtcbiAgICAgIGEuSXRlcmF0b3IgPSBjO1xuICAgICAgdmFyIGwgPSBmdW5jdGlvbihmKSB7XG4gICAgICAgIGUodSwgZik7XG4gICAgICAgIGZ1bmN0aW9uIHUoKSB7XG4gICAgICAgICAgcmV0dXJuIGYgIT09IG51bGwgJiYgZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHUucHJvdG90eXBlLl9DcmVhdGVfbmVpZ2hib3IgPSBmdW5jdGlvbihoKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyB1KGgpO1xuICAgICAgICB9LCB1O1xuICAgICAgfShzLlJldmVyc2VJdGVyYXRvcik7XG4gICAgICBhLlJldmVyc2VJdGVyYXRvciA9IGw7XG4gICAgfShvID0gdC5TZXRFbGVtZW50TGlzdCB8fCAodC5TZXRFbGVtZW50TGlzdCA9IHt9KSksIHQuU2V0RWxlbWVudExpc3QgPSBvO1xuICB9KHhuKSksIHhuO1xufVxudmFyIFd0ID0ge30sIFZ0ID0ge30sIGtvO1xuZnVuY3Rpb24gUmEoKSB7XG4gIGlmIChrbylcbiAgICByZXR1cm4gVnQ7XG4gIGtvID0gMTtcbiAgdmFyIHQgPSBTICYmIFMuX192YWx1ZXMgfHwgZnVuY3Rpb24oaSkge1xuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBvID0gcyAmJiBpW3NdLCBhID0gMDtcbiAgICBpZiAobylcbiAgICAgIHJldHVybiBvLmNhbGwoaSk7XG4gICAgaWYgKGkgJiYgdHlwZW9mIGkubGVuZ3RoID09IFwibnVtYmVyXCIpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gaSAmJiBhID49IGkubGVuZ3RoICYmIChpID0gdm9pZCAwKSwgeyB2YWx1ZTogaSAmJiBpW2ErK10sIGRvbmU6ICFpIH07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgVnQuSGFzaEJ1Y2tldHMgPSB2b2lkIDA7XG4gIHZhciBlID0gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gaShzLCBvKSB7XG4gICAgICB0aGlzLmZldGNoZXJfID0gcywgdGhpcy5oYXNoZXJfID0gbywgdGhpcy5tYXhfbG9hZF9mYWN0b3JfID0gbiwgdGhpcy5kYXRhXyA9IFtdLCB0aGlzLnNpemVfID0gMCwgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgfVxuICAgIHJldHVybiBpLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kYXRhXyA9IFtdLCB0aGlzLnNpemVfID0gMCwgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgfSwgaS5wcm90b3R5cGUucmVoYXNoID0gZnVuY3Rpb24ocykge1xuICAgICAgdmFyIG8sIGEsIGMsIGw7XG4gICAgICBzID0gTWF0aC5tYXgocywgcik7XG4gICAgICBmb3IgKHZhciBmID0gW10sIHUgPSAwOyB1IDwgczsgKyt1KVxuICAgICAgICBmLnB1c2goW10pO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgaCA9IHQodGhpcy5kYXRhXyksIGQgPSBoLm5leHQoKTsgIWQuZG9uZTsgZCA9IGgubmV4dCgpKSB7XG4gICAgICAgICAgdmFyIHAgPSBkLnZhbHVlO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciB5ID0gKGMgPSB2b2lkIDAsIHQocCkpLCBnID0geS5uZXh0KCk7ICFnLmRvbmU7IGcgPSB5Lm5leHQoKSkge1xuICAgICAgICAgICAgICB2YXIgdiA9IGcudmFsdWUsIF8gPSB0aGlzLmhhc2hlcl8odGhpcy5mZXRjaGVyXyh2KSkgJSBmLmxlbmd0aDtcbiAgICAgICAgICAgICAgZltfXS5wdXNoKHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKG0pIHtcbiAgICAgICAgICAgIGMgPSB7IGVycm9yOiBtIH07XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGcgJiYgIWcuZG9uZSAmJiAobCA9IHkucmV0dXJuKSAmJiBsLmNhbGwoeSk7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICBpZiAoYylcbiAgICAgICAgICAgICAgICB0aHJvdyBjLmVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAobSkge1xuICAgICAgICBvID0geyBlcnJvcjogbSB9O1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBkICYmICFkLmRvbmUgJiYgKGEgPSBoLnJldHVybikgJiYgYS5jYWxsKGgpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChvKVxuICAgICAgICAgICAgdGhyb3cgby5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5kYXRhXyA9IGY7XG4gICAgfSwgaS5wcm90b3R5cGUucmVzZXJ2ZSA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgIHMgPiB0aGlzLmNhcGFjaXR5KCkgJiYgKHMgPSBNYXRoLmZsb29yKHMgLyB0aGlzLm1heF9sb2FkX2ZhY3Rvcl8pLCB0aGlzLnJlaGFzaChzKSk7XG4gICAgfSwgaS5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgZm9yICh2YXIgcyA9IDA7IHMgPCByOyArK3MpXG4gICAgICAgIHRoaXMuZGF0YV8ucHVzaChbXSk7XG4gICAgfSwgaS5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5kYXRhXy5sZW5ndGg7XG4gICAgfSwgaS5wcm90b3R5cGUuY2FwYWNpdHkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmRhdGFfLmxlbmd0aCAqIHRoaXMubWF4X2xvYWRfZmFjdG9yXztcbiAgICB9LCBpLnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgIHJldHVybiB0aGlzLmRhdGFfW3NdO1xuICAgIH0sIGkucHJvdG90eXBlLmxvYWRfZmFjdG9yID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5zaXplXyAvIHRoaXMubGVuZ3RoKCk7XG4gICAgfSwgaS5wcm90b3R5cGUubWF4X2xvYWRfZmFjdG9yID0gZnVuY3Rpb24ocykge1xuICAgICAgaWYgKHMgPT09IHZvaWQgMCAmJiAocyA9IG51bGwpLCBzID09PSBudWxsKVxuICAgICAgICByZXR1cm4gdGhpcy5tYXhfbG9hZF9mYWN0b3JfO1xuICAgICAgdGhpcy5tYXhfbG9hZF9mYWN0b3JfID0gcztcbiAgICB9LCBpLnByb3RvdHlwZS5oYXNoX2Z1bmN0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYXNoZXJfO1xuICAgIH0sIGkucHJvdG90eXBlLmluZGV4ID0gZnVuY3Rpb24ocykge1xuICAgICAgcmV0dXJuIHRoaXMuaGFzaGVyXyh0aGlzLmZldGNoZXJfKHMpKSAlIHRoaXMubGVuZ3RoKCk7XG4gICAgfSwgaS5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24ocykge1xuICAgICAgdmFyIG8gPSB0aGlzLmNhcGFjaXR5KCk7XG4gICAgICArK3RoaXMuc2l6ZV8gPiBvICYmIHRoaXMucmVzZXJ2ZShvICogMik7XG4gICAgICB2YXIgYSA9IHRoaXMuaW5kZXgocyk7XG4gICAgICB0aGlzLmRhdGFfW2FdLnB1c2gocyk7XG4gICAgfSwgaS5wcm90b3R5cGUuZXJhc2UgPSBmdW5jdGlvbihzKSB7XG4gICAgICBmb3IgKHZhciBvID0gdGhpcy5pbmRleChzKSwgYSA9IHRoaXMuZGF0YV9bb10sIGMgPSAwOyBjIDwgYS5sZW5ndGg7ICsrYylcbiAgICAgICAgaWYgKGFbY10gPT09IHMpIHtcbiAgICAgICAgICBhLnNwbGljZShjLCAxKSwgLS10aGlzLnNpemVfO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfSwgaTtcbiAgfSgpO1xuICBWdC5IYXNoQnVja2V0cyA9IGU7XG4gIHZhciByID0gMTAsIG4gPSAxO1xuICByZXR1cm4gVnQ7XG59XG52YXIgU287XG5mdW5jdGlvbiBlZCgpIHtcbiAgaWYgKFNvKVxuICAgIHJldHVybiBXdDtcbiAgU28gPSAxO1xuICB2YXIgdCA9IFMgJiYgUy5fX2V4dGVuZHMgfHwgZnVuY3Rpb24oKSB7XG4gICAgdmFyIG8gPSBmdW5jdGlvbihhLCBjKSB7XG4gICAgICByZXR1cm4gbyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uKGwsIGYpIHtcbiAgICAgICAgbC5fX3Byb3RvX18gPSBmO1xuICAgICAgfSB8fCBmdW5jdGlvbihsLCBmKSB7XG4gICAgICAgIGZvciAodmFyIHUgaW4gZilcbiAgICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZiwgdSkgJiYgKGxbdV0gPSBmW3VdKTtcbiAgICAgIH0sIG8oYSwgYyk7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24oYSwgYykge1xuICAgICAgaWYgKHR5cGVvZiBjICE9IFwiZnVuY3Rpb25cIiAmJiBjICE9PSBudWxsKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhjKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICBvKGEsIGMpO1xuICAgICAgZnVuY3Rpb24gbCgpIHtcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IGE7XG4gICAgICB9XG4gICAgICBhLnByb3RvdHlwZSA9IGMgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGMpIDogKGwucHJvdG90eXBlID0gYy5wcm90b3R5cGUsIG5ldyBsKCkpO1xuICAgIH07XG4gIH0oKSwgZSA9IFMgJiYgUy5fX3JlYWQgfHwgZnVuY3Rpb24obywgYSkge1xuICAgIHZhciBjID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghYylcbiAgICAgIHJldHVybiBvO1xuICAgIHZhciBsID0gYy5jYWxsKG8pLCBmLCB1ID0gW10sIGg7XG4gICAgdHJ5IHtcbiAgICAgIGZvciAoOyAoYSA9PT0gdm9pZCAwIHx8IGEtLSA+IDApICYmICEoZiA9IGwubmV4dCgpKS5kb25lOyApXG4gICAgICAgIHUucHVzaChmLnZhbHVlKTtcbiAgICB9IGNhdGNoIChkKSB7XG4gICAgICBoID0geyBlcnJvcjogZCB9O1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBmICYmICFmLmRvbmUgJiYgKGMgPSBsLnJldHVybikgJiYgYy5jYWxsKGwpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGgpXG4gICAgICAgICAgdGhyb3cgaC5lcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHU7XG4gIH0sIHIgPSBTICYmIFMuX192YWx1ZXMgfHwgZnVuY3Rpb24obykge1xuICAgIHZhciBhID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBjID0gYSAmJiBvW2FdLCBsID0gMDtcbiAgICBpZiAoYylcbiAgICAgIHJldHVybiBjLmNhbGwobyk7XG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09IFwibnVtYmVyXCIpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gbyAmJiBsID49IG8ubGVuZ3RoICYmIChvID0gdm9pZCAwKSwgeyB2YWx1ZTogbyAmJiBvW2wrK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihhID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3QsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgV3QuU2V0SGFzaEJ1Y2tldHMgPSB2b2lkIDA7XG4gIHZhciBuID0gUmEoKSwgaSA9IGZ1bmN0aW9uKG8pIHtcbiAgICB0KGEsIG8pO1xuICAgIGZ1bmN0aW9uIGEoYywgbCwgZikge1xuICAgICAgdmFyIHUgPSBvLmNhbGwodGhpcywgcywgbCkgfHwgdGhpcztcbiAgICAgIHJldHVybiB1LnNvdXJjZV8gPSBjLCB1LmtleV9lcV8gPSBmLCB1O1xuICAgIH1cbiAgICByZXR1cm4gYS5fU3dhcF9zb3VyY2UgPSBmdW5jdGlvbihjLCBsKSB7XG4gICAgICB2YXIgZjtcbiAgICAgIGYgPSBlKFtsLnNvdXJjZV8sIGMuc291cmNlX10sIDIpLCBjLnNvdXJjZV8gPSBmWzBdLCBsLnNvdXJjZV8gPSBmWzFdO1xuICAgIH0sIGEucHJvdG90eXBlLmtleV9lcSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMua2V5X2VxXztcbiAgICB9LCBhLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24oYykge1xuICAgICAgdmFyIGwsIGYsIHUgPSB0aGlzLmhhc2hfZnVuY3Rpb24oKShjKSAlIHRoaXMubGVuZ3RoKCksIGggPSB0aGlzLmF0KHUpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgZCA9IHIoaCksIHAgPSBkLm5leHQoKTsgIXAuZG9uZTsgcCA9IGQubmV4dCgpKSB7XG4gICAgICAgICAgdmFyIHkgPSBwLnZhbHVlO1xuICAgICAgICAgIGlmICh0aGlzLmtleV9lcV8oeS52YWx1ZSwgYykpXG4gICAgICAgICAgICByZXR1cm4geTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZykge1xuICAgICAgICBsID0geyBlcnJvcjogZyB9O1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBwICYmICFwLmRvbmUgJiYgKGYgPSBkLnJldHVybikgJiYgZi5jYWxsKGQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChsKVxuICAgICAgICAgICAgdGhyb3cgbC5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuc291cmNlXy5lbmQoKTtcbiAgICB9LCBhO1xuICB9KG4uSGFzaEJ1Y2tldHMpO1xuICBXdC5TZXRIYXNoQnVja2V0cyA9IGk7XG4gIGZ1bmN0aW9uIHMobykge1xuICAgIHJldHVybiBvLnZhbHVlO1xuICB9XG4gIHJldHVybiBXdDtcbn1cbnZhciBzdCA9IHt9LCBPbztcbmZ1bmN0aW9uIFRhKCkge1xuICBpZiAoT28pXG4gICAgcmV0dXJuIHN0O1xuICBPbyA9IDEsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBzdC5tYWtlX3BhaXIgPSBzdC5QYWlyID0gdm9pZCAwO1xuICB2YXIgdCA9IHdpKCksIGUgPSBfaSgpLCByID0gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gaShzLCBvKSB7XG4gICAgICB0aGlzLmZpcnN0ID0gcywgdGhpcy5zZWNvbmQgPSBvO1xuICAgIH1cbiAgICByZXR1cm4gaS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24ocykge1xuICAgICAgcmV0dXJuICgwLCBlLmVxdWFsX3RvKSh0aGlzLmZpcnN0LCBzLmZpcnN0KSAmJiAoMCwgZS5lcXVhbF90bykodGhpcy5zZWNvbmQsIHMuc2Vjb25kKTtcbiAgICB9LCBpLnByb3RvdHlwZS5sZXNzID0gZnVuY3Rpb24ocykge1xuICAgICAgcmV0dXJuICgwLCBlLmVxdWFsX3RvKSh0aGlzLmZpcnN0LCBzLmZpcnN0KSA9PT0gITEgPyAoMCwgZS5sZXNzKSh0aGlzLmZpcnN0LCBzLmZpcnN0KSA6ICgwLCBlLmxlc3MpKHRoaXMuc2Vjb25kLCBzLnNlY29uZCk7XG4gICAgfSwgaS5wcm90b3R5cGUuaGFzaENvZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAoMCwgdC5oYXNoKSh0aGlzLmZpcnN0LCB0aGlzLnNlY29uZCk7XG4gICAgfSwgaTtcbiAgfSgpO1xuICBzdC5QYWlyID0gcjtcbiAgZnVuY3Rpb24gbihpLCBzKSB7XG4gICAgcmV0dXJuIG5ldyByKGksIHMpO1xuICB9XG4gIHJldHVybiBzdC5tYWtlX3BhaXIgPSBuLCBzdDtcbn1cbnZhciBBbztcbmZ1bmN0aW9uIHRkKCkge1xuICByZXR1cm4gQW8gfHwgKEFvID0gMSwgZnVuY3Rpb24odCkge1xuICAgIHZhciBlID0gUyAmJiBTLl9fZXh0ZW5kcyB8fCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBmID0gZnVuY3Rpb24odSwgaCkge1xuICAgICAgICByZXR1cm4gZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uKGQsIHApIHtcbiAgICAgICAgICBkLl9fcHJvdG9fXyA9IHA7XG4gICAgICAgIH0gfHwgZnVuY3Rpb24oZCwgcCkge1xuICAgICAgICAgIGZvciAodmFyIHkgaW4gcClcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwLCB5KSAmJiAoZFt5XSA9IHBbeV0pO1xuICAgICAgICB9LCBmKHUsIGgpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBmdW5jdGlvbih1LCBoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaCAhPSBcImZ1bmN0aW9uXCIgJiYgaCAhPT0gbnVsbClcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhoKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGYodSwgaCk7XG4gICAgICAgIGZ1bmN0aW9uIGQoKSB7XG4gICAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IHU7XG4gICAgICAgIH1cbiAgICAgICAgdS5wcm90b3R5cGUgPSBoID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShoKSA6IChkLnByb3RvdHlwZSA9IGgucHJvdG90eXBlLCBuZXcgZCgpKTtcbiAgICAgIH07XG4gICAgfSgpLCByID0gUyAmJiBTLl9fcmVhZCB8fCBmdW5jdGlvbihmLCB1KSB7XG4gICAgICB2YXIgaCA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIGZbU3ltYm9sLml0ZXJhdG9yXTtcbiAgICAgIGlmICghaClcbiAgICAgICAgcmV0dXJuIGY7XG4gICAgICB2YXIgZCA9IGguY2FsbChmKSwgcCwgeSA9IFtdLCBnO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICg7ICh1ID09PSB2b2lkIDAgfHwgdS0tID4gMCkgJiYgIShwID0gZC5uZXh0KCkpLmRvbmU7IClcbiAgICAgICAgICB5LnB1c2gocC52YWx1ZSk7XG4gICAgICB9IGNhdGNoICh2KSB7XG4gICAgICAgIGcgPSB7IGVycm9yOiB2IH07XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHAgJiYgIXAuZG9uZSAmJiAoaCA9IGQucmV0dXJuKSAmJiBoLmNhbGwoZCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKGcpXG4gICAgICAgICAgICB0aHJvdyBnLmVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4geTtcbiAgICB9LCBuID0gUyAmJiBTLl9fc3ByZWFkQXJyYXkgfHwgZnVuY3Rpb24oZiwgdSwgaCkge1xuICAgICAgaWYgKGggfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMilcbiAgICAgICAgZm9yICh2YXIgZCA9IDAsIHAgPSB1Lmxlbmd0aCwgeTsgZCA8IHA7IGQrKylcbiAgICAgICAgICAoeSB8fCAhKGQgaW4gdSkpICYmICh5IHx8ICh5ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodSwgMCwgZCkpLCB5W2RdID0gdVtkXSk7XG4gICAgICByZXR1cm4gZi5jb25jYXQoeSB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh1KSk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCB0Lkhhc2hTZXQgPSB2b2lkIDA7XG4gICAgdmFyIGkgPSBHaCgpLCBzID0gQWEoKSwgbyA9IFFoKCksIGEgPSBlZCgpLCBjID0gVGEoKSwgbCA9IGZ1bmN0aW9uKGYpIHtcbiAgICAgIGUodSwgZik7XG4gICAgICBmdW5jdGlvbiB1KCkge1xuICAgICAgICBmb3IgKHZhciBoID0gW10sIGQgPSAwOyBkIDwgYXJndW1lbnRzLmxlbmd0aDsgZCsrKVxuICAgICAgICAgIGhbZF0gPSBhcmd1bWVudHNbZF07XG4gICAgICAgIHZhciBwID0gZi5jYWxsKHRoaXMsIGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IG8uU2V0RWxlbWVudExpc3QoeSk7XG4gICAgICAgIH0pIHx8IHRoaXM7XG4gICAgICAgIHJldHVybiBzLklIYXNoQ29udGFpbmVyLmNvbnN0cnVjdC5hcHBseShzLklIYXNoQ29udGFpbmVyLCBuKFtcbiAgICAgICAgICBwLFxuICAgICAgICAgIHUsXG4gICAgICAgICAgZnVuY3Rpb24oeSwgZykge1xuICAgICAgICAgICAgcC5idWNrZXRzXyA9IG5ldyBhLlNldEhhc2hCdWNrZXRzKHAsIHksIGcpO1xuICAgICAgICAgIH1cbiAgICAgICAgXSwgcihoKSwgITEpKSwgcDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmJ1Y2tldHNfLmNsZWFyKCksIGYucHJvdG90eXBlLmNsZWFyLmNhbGwodGhpcyk7XG4gICAgICB9LCB1LnByb3RvdHlwZS5zd2FwID0gZnVuY3Rpb24oaCkge1xuICAgICAgICB2YXIgZCwgcDtcbiAgICAgICAgZCA9IHIoW2guZGF0YV8sIHRoaXMuZGF0YV9dLCAyKSwgdGhpcy5kYXRhXyA9IGRbMF0sIGguZGF0YV8gPSBkWzFdLCBvLlNldEVsZW1lbnRMaXN0Ll9Td2FwX2Fzc29jaWF0aXZlKHRoaXMuZGF0YV8sIGguZGF0YV8pLCBhLlNldEhhc2hCdWNrZXRzLl9Td2FwX3NvdXJjZSh0aGlzLmJ1Y2tldHNfLCBoLmJ1Y2tldHNfKSwgcCA9IHIoW2guYnVja2V0c18sIHRoaXMuYnVja2V0c19dLCAyKSwgdGhpcy5idWNrZXRzXyA9IHBbMF0sIGguYnVja2V0c18gPSBwWzFdO1xuICAgICAgfSwgdS5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVja2V0c18uZmluZChoKTtcbiAgICAgIH0sIHUucHJvdG90eXBlLmJlZ2luID0gZnVuY3Rpb24oaCkge1xuICAgICAgICByZXR1cm4gaCA9PT0gdm9pZCAwICYmIChoID0gbnVsbCksIGggPT09IG51bGwgPyBmLnByb3RvdHlwZS5iZWdpbi5jYWxsKHRoaXMpIDogdGhpcy5idWNrZXRzXy5hdChoKVswXTtcbiAgICAgIH0sIHUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgaWYgKGggPT09IHZvaWQgMCAmJiAoaCA9IG51bGwpLCBoID09PSBudWxsKVxuICAgICAgICAgIHJldHVybiBmLnByb3RvdHlwZS5lbmQuY2FsbCh0aGlzKTtcbiAgICAgICAgdmFyIGQgPSB0aGlzLmJ1Y2tldHNfLmF0KGgpO1xuICAgICAgICByZXR1cm4gZFtkLmxlbmd0aCAtIDFdLm5leHQoKTtcbiAgICAgIH0sIHUucHJvdG90eXBlLnJiZWdpbiA9IGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgcmV0dXJuIGggPT09IHZvaWQgMCAmJiAoaCA9IG51bGwpLCB0aGlzLmVuZChoKS5yZXZlcnNlKCk7XG4gICAgICB9LCB1LnByb3RvdHlwZS5yZW5kID0gZnVuY3Rpb24oaCkge1xuICAgICAgICByZXR1cm4gaCA9PT0gdm9pZCAwICYmIChoID0gbnVsbCksIHRoaXMuYmVnaW4oaCkucmV2ZXJzZSgpO1xuICAgICAgfSwgdS5wcm90b3R5cGUuYnVja2V0X2NvdW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1Y2tldHNfLmxlbmd0aCgpO1xuICAgICAgfSwgdS5wcm90b3R5cGUuYnVja2V0X3NpemUgPSBmdW5jdGlvbihoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1Y2tldHNfLmF0KGgpLmxlbmd0aDtcbiAgICAgIH0sIHUucHJvdG90eXBlLmxvYWRfZmFjdG9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1Y2tldHNfLmxvYWRfZmFjdG9yKCk7XG4gICAgICB9LCB1LnByb3RvdHlwZS5oYXNoX2Z1bmN0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1Y2tldHNfLmhhc2hfZnVuY3Rpb24oKTtcbiAgICAgIH0sIHUucHJvdG90eXBlLmtleV9lcSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWNrZXRzXy5rZXlfZXEoKTtcbiAgICAgIH0sIHUucHJvdG90eXBlLmJ1Y2tldCA9IGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzaF9mdW5jdGlvbigpKGgpICUgdGhpcy5idWNrZXRzXy5sZW5ndGgoKTtcbiAgICAgIH0sIHUucHJvdG90eXBlLm1heF9sb2FkX2ZhY3RvciA9IGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgcmV0dXJuIGggPT09IHZvaWQgMCAmJiAoaCA9IG51bGwpLCB0aGlzLmJ1Y2tldHNfLm1heF9sb2FkX2ZhY3RvcihoKTtcbiAgICAgIH0sIHUucHJvdG90eXBlLnJlc2VydmUgPSBmdW5jdGlvbihoKSB7XG4gICAgICAgIHRoaXMuYnVja2V0c18ucmVzZXJ2ZShoKTtcbiAgICAgIH0sIHUucHJvdG90eXBlLnJlaGFzaCA9IGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgdGhpcy5idWNrZXRzXy5yZWhhc2goaCk7XG4gICAgICB9LCB1LnByb3RvdHlwZS5fSW5zZXJ0X2J5X2tleSA9IGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgdmFyIGQgPSB0aGlzLmZpbmQoaCk7XG4gICAgICAgIHJldHVybiBkLmVxdWFscyh0aGlzLmVuZCgpKSA9PT0gITEgPyBuZXcgYy5QYWlyKGQsICExKSA6ICh0aGlzLmRhdGFfLnB1c2goaCksIGQgPSBkLnByZXYoKSwgdGhpcy5fSGFuZGxlX2luc2VydChkLCBkLm5leHQoKSksIG5ldyBjLlBhaXIoZCwgITApKTtcbiAgICAgIH0sIHUucHJvdG90eXBlLl9JbnNlcnRfYnlfaGludCA9IGZ1bmN0aW9uKGgsIGQpIHtcbiAgICAgICAgdmFyIHAgPSB0aGlzLmZpbmQoZCk7XG4gICAgICAgIHJldHVybiBwLmVxdWFscyh0aGlzLmVuZCgpKSA9PT0gITAgJiYgKHAgPSB0aGlzLmRhdGFfLmluc2VydChoLCBkKSwgdGhpcy5fSGFuZGxlX2luc2VydChwLCBwLm5leHQoKSkpLCBwO1xuICAgICAgfSwgdS5wcm90b3R5cGUuX0hhbmRsZV9pbnNlcnQgPSBmdW5jdGlvbihoLCBkKSB7XG4gICAgICAgIGZvciAoOyAhaC5lcXVhbHMoZCk7IGggPSBoLm5leHQoKSlcbiAgICAgICAgICB0aGlzLmJ1Y2tldHNfLmluc2VydChoKTtcbiAgICAgIH0sIHUucHJvdG90eXBlLl9IYW5kbGVfZXJhc2UgPSBmdW5jdGlvbihoLCBkKSB7XG4gICAgICAgIGZvciAoOyAhaC5lcXVhbHMoZCk7IGggPSBoLm5leHQoKSlcbiAgICAgICAgICB0aGlzLmJ1Y2tldHNfLmVyYXNlKGgpO1xuICAgICAgfSwgdTtcbiAgICB9KGkuVW5pcXVlU2V0KTtcbiAgICB0Lkhhc2hTZXQgPSBsLCBmdW5jdGlvbihmKSB7XG4gICAgICBmLkl0ZXJhdG9yID0gby5TZXRFbGVtZW50TGlzdC5JdGVyYXRvciwgZi5SZXZlcnNlSXRlcmF0b3IgPSBvLlNldEVsZW1lbnRMaXN0LlJldmVyc2VJdGVyYXRvcjtcbiAgICB9KGwgPSB0Lkhhc2hTZXQgfHwgKHQuSGFzaFNldCA9IHt9KSksIHQuSGFzaFNldCA9IGw7XG4gIH0odm4pKSwgdm47XG59XG52YXIgRW4gPSB7fSwgR3QgPSB7fSwgWnQgPSB7fSwgQ287XG5mdW5jdGlvbiByZCgpIHtcbiAgaWYgKENvKVxuICAgIHJldHVybiBadDtcbiAgQ28gPSAxO1xuICB2YXIgdCA9IFMgJiYgUy5fX2V4dGVuZHMgfHwgZnVuY3Rpb24oKSB7XG4gICAgdmFyIGkgPSBmdW5jdGlvbihzLCBvKSB7XG4gICAgICByZXR1cm4gaSA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uKGEsIGMpIHtcbiAgICAgICAgYS5fX3Byb3RvX18gPSBjO1xuICAgICAgfSB8fCBmdW5jdGlvbihhLCBjKSB7XG4gICAgICAgIGZvciAodmFyIGwgaW4gYylcbiAgICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYywgbCkgJiYgKGFbbF0gPSBjW2xdKTtcbiAgICAgIH0sIGkocywgbyk7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24ocywgbykge1xuICAgICAgaWYgKHR5cGVvZiBvICE9IFwiZnVuY3Rpb25cIiAmJiBvICE9PSBudWxsKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhvKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICBpKHMsIG8pO1xuICAgICAgZnVuY3Rpb24gYSgpIHtcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IHM7XG4gICAgICB9XG4gICAgICBzLnByb3RvdHlwZSA9IG8gPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKG8pIDogKGEucHJvdG90eXBlID0gby5wcm90b3R5cGUsIG5ldyBhKCkpO1xuICAgIH07XG4gIH0oKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFp0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIFp0Lk1hcENvbnRhaW5lciA9IHZvaWQgMDtcbiAgdmFyIGUgPSBiaSgpLCByID0gdmkoKSwgbiA9IGZ1bmN0aW9uKGkpIHtcbiAgICB0KHMsIGkpO1xuICAgIGZ1bmN0aW9uIHMobykge1xuICAgICAgdmFyIGEgPSBpLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgIHJldHVybiBhLmRhdGFfID0gbyhhKSwgYTtcbiAgICB9XG4gICAgcmV0dXJuIHMucHJvdG90eXBlLmFzc2lnbiA9IGZ1bmN0aW9uKG8sIGEpIHtcbiAgICAgIHRoaXMuY2xlYXIoKSwgdGhpcy5pbnNlcnQobywgYSk7XG4gICAgfSwgcy5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZGF0YV8uY2xlYXIoKTtcbiAgICB9LCBzLnByb3RvdHlwZS5iZWdpbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGF0YV8uYmVnaW4oKTtcbiAgICB9LCBzLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmRhdGFfLmVuZCgpO1xuICAgIH0sIHMucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgIHJldHVybiAhdGhpcy5maW5kKG8pLmVxdWFscyh0aGlzLmVuZCgpKTtcbiAgICB9LCBzLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5kYXRhXy5zaXplKCk7XG4gICAgfSwgcy5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgZm9yICh2YXIgbyA9IFtdLCBhID0gMDsgYSA8IGFyZ3VtZW50cy5sZW5ndGg7IGErKylcbiAgICAgICAgb1thXSA9IGFyZ3VtZW50c1thXTtcbiAgICAgIHZhciBjID0gbmV3IHIuTmF0aXZlQXJyYXlJdGVyYXRvcihvLCAwKSwgbCA9IG5ldyByLk5hdGl2ZUFycmF5SXRlcmF0b3Iobywgby5sZW5ndGgpO1xuICAgICAgcmV0dXJuIHRoaXMuaW5zZXJ0KGMsIGwpLCB0aGlzLnNpemUoKTtcbiAgICB9LCBzLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGZvciAodmFyIG8gPSBbXSwgYSA9IDA7IGEgPCBhcmd1bWVudHMubGVuZ3RoOyBhKyspXG4gICAgICAgIG9bYV0gPSBhcmd1bWVudHNbYV07XG4gICAgICByZXR1cm4gby5sZW5ndGggPT09IDEgPyB0aGlzLmVtcGxhY2Uob1swXS5maXJzdCwgb1swXS5zZWNvbmQpIDogb1swXS5uZXh0IGluc3RhbmNlb2YgRnVuY3Rpb24gJiYgb1sxXS5uZXh0IGluc3RhbmNlb2YgRnVuY3Rpb24gPyB0aGlzLl9JbnNlcnRfYnlfcmFuZ2Uob1swXSwgb1sxXSkgOiB0aGlzLmVtcGxhY2VfaGludChvWzBdLCBvWzFdLmZpcnN0LCBvWzFdLnNlY29uZCk7XG4gICAgfSwgcy5wcm90b3R5cGUuZXJhc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIGZvciAodmFyIG8gPSBbXSwgYSA9IDA7IGEgPCBhcmd1bWVudHMubGVuZ3RoOyBhKyspXG4gICAgICAgIG9bYV0gPSBhcmd1bWVudHNbYV07XG4gICAgICByZXR1cm4gby5sZW5ndGggPT09IDEgJiYgKCEob1swXSBpbnN0YW5jZW9mIHRoaXMuZW5kKCkuY29uc3RydWN0b3IpIHx8IG9bMF0uc291cmNlKCkgIT09IHRoaXMpID8gdGhpcy5fRXJhc2VfYnlfa2V5KG9bMF0pIDogby5sZW5ndGggPT09IDEgPyB0aGlzLl9FcmFzZV9ieV9yYW5nZShvWzBdKSA6IHRoaXMuX0VyYXNlX2J5X3JhbmdlKG9bMF0sIG9bMV0pO1xuICAgIH0sIHMucHJvdG90eXBlLl9FcmFzZV9ieV9yYW5nZSA9IGZ1bmN0aW9uKG8sIGEpIHtcbiAgICAgIGEgPT09IHZvaWQgMCAmJiAoYSA9IG8ubmV4dCgpKTtcbiAgICAgIHZhciBjID0gdGhpcy5kYXRhXy5lcmFzZShvLCBhKTtcbiAgICAgIHJldHVybiB0aGlzLl9IYW5kbGVfZXJhc2UobywgYSksIGM7XG4gICAgfSwgcztcbiAgfShlLkNvbnRhaW5lcik7XG4gIHJldHVybiBadC5NYXBDb250YWluZXIgPSBuLCBadDtcbn1cbnZhciBJbztcbmZ1bmN0aW9uIG5kKCkge1xuICBpZiAoSW8pXG4gICAgcmV0dXJuIEd0O1xuICBJbyA9IDE7XG4gIHZhciB0ID0gUyAmJiBTLl9fZXh0ZW5kcyB8fCBmdW5jdGlvbigpIHtcbiAgICB2YXIgbyA9IGZ1bmN0aW9uKGEsIGMpIHtcbiAgICAgIHJldHVybiBvID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24obCwgZikge1xuICAgICAgICBsLl9fcHJvdG9fXyA9IGY7XG4gICAgICB9IHx8IGZ1bmN0aW9uKGwsIGYpIHtcbiAgICAgICAgZm9yICh2YXIgdSBpbiBmKVxuICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChmLCB1KSAmJiAobFt1XSA9IGZbdV0pO1xuICAgICAgfSwgbyhhLCBjKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbihhLCBjKSB7XG4gICAgICBpZiAodHlwZW9mIGMgIT0gXCJmdW5jdGlvblwiICYmIGMgIT09IG51bGwpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGMpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgIG8oYSwgYyk7XG4gICAgICBmdW5jdGlvbiBsKCkge1xuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yID0gYTtcbiAgICAgIH1cbiAgICAgIGEucHJvdG90eXBlID0gYyA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYykgOiAobC5wcm90b3R5cGUgPSBjLnByb3RvdHlwZSwgbmV3IGwoKSk7XG4gICAgfTtcbiAgfSgpLCBlID0gUyAmJiBTLl9fcmVhZCB8fCBmdW5jdGlvbihvLCBhKSB7XG4gICAgdmFyIGMgPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFjKVxuICAgICAgcmV0dXJuIG87XG4gICAgdmFyIGwgPSBjLmNhbGwobyksIGYsIHUgPSBbXSwgaDtcbiAgICB0cnkge1xuICAgICAgZm9yICg7IChhID09PSB2b2lkIDAgfHwgYS0tID4gMCkgJiYgIShmID0gbC5uZXh0KCkpLmRvbmU7IClcbiAgICAgICAgdS5wdXNoKGYudmFsdWUpO1xuICAgIH0gY2F0Y2ggKGQpIHtcbiAgICAgIGggPSB7IGVycm9yOiBkIH07XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGYgJiYgIWYuZG9uZSAmJiAoYyA9IGwucmV0dXJuKSAmJiBjLmNhbGwobCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoaClcbiAgICAgICAgICB0aHJvdyBoLmVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdTtcbiAgfSwgciA9IFMgJiYgUy5fX3NwcmVhZEFycmF5IHx8IGZ1bmN0aW9uKG8sIGEsIGMpIHtcbiAgICBpZiAoYyB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKVxuICAgICAgZm9yICh2YXIgbCA9IDAsIGYgPSBhLmxlbmd0aCwgdTsgbCA8IGY7IGwrKylcbiAgICAgICAgKHUgfHwgIShsIGluIGEpKSAmJiAodSB8fCAodSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGEsIDAsIGwpKSwgdVtsXSA9IGFbbF0pO1xuICAgIHJldHVybiBvLmNvbmNhdCh1IHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGEpKTtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEd0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIEd0LlVuaXF1ZU1hcCA9IHZvaWQgMDtcbiAgdmFyIG4gPSByZCgpLCBpID0gV3IoKSwgcyA9IGZ1bmN0aW9uKG8pIHtcbiAgICB0KGEsIG8pO1xuICAgIGZ1bmN0aW9uIGEoKSB7XG4gICAgICByZXR1cm4gbyAhPT0gbnVsbCAmJiBvLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIGEucHJvdG90eXBlLmNvdW50ID0gZnVuY3Rpb24oYykge1xuICAgICAgcmV0dXJuIHRoaXMuZmluZChjKS5lcXVhbHModGhpcy5lbmQoKSkgPyAwIDogMTtcbiAgICB9LCBhLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihjKSB7XG4gICAgICB2YXIgbCA9IHRoaXMuZmluZChjKTtcbiAgICAgIGlmIChsLmVxdWFscyh0aGlzLmVuZCgpKSA9PT0gITApXG4gICAgICAgIHRocm93IGkuRXJyb3JHZW5lcmF0b3Iua2V5X25vdXRfZm91bmQodGhpcywgXCJnZXRcIiwgYyk7XG4gICAgICByZXR1cm4gbC5zZWNvbmQ7XG4gICAgfSwgYS5wcm90b3R5cGUudGFrZSA9IGZ1bmN0aW9uKGMsIGwpIHtcbiAgICAgIHZhciBmID0gdGhpcy5maW5kKGMpO1xuICAgICAgcmV0dXJuIGYuZXF1YWxzKHRoaXMuZW5kKCkpID8gdGhpcy5lbXBsYWNlKGMsIGwoKSkuZmlyc3Quc2Vjb25kIDogZi5zZWNvbmQ7XG4gICAgfSwgYS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oYywgbCkge1xuICAgICAgdGhpcy5pbnNlcnRfb3JfYXNzaWduKGMsIGwpO1xuICAgIH0sIGEucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgZm9yICh2YXIgYyA9IFtdLCBsID0gMDsgbCA8IGFyZ3VtZW50cy5sZW5ndGg7IGwrKylcbiAgICAgICAgY1tsXSA9IGFyZ3VtZW50c1tsXTtcbiAgICAgIHJldHVybiBvLnByb3RvdHlwZS5pbnNlcnQuYXBwbHkodGhpcywgcihbXSwgZShjKSwgITEpKTtcbiAgICB9LCBhLnByb3RvdHlwZS5fSW5zZXJ0X2J5X3JhbmdlID0gZnVuY3Rpb24oYywgbCkge1xuICAgICAgZm9yICh2YXIgZiA9IGM7ICFmLmVxdWFscyhsKTsgZiA9IGYubmV4dCgpKVxuICAgICAgICB0aGlzLmVtcGxhY2UoZi52YWx1ZS5maXJzdCwgZi52YWx1ZS5zZWNvbmQpO1xuICAgIH0sIGEucHJvdG90eXBlLmluc2VydF9vcl9hc3NpZ24gPSBmdW5jdGlvbigpIHtcbiAgICAgIGZvciAodmFyIGMgPSBbXSwgbCA9IDA7IGwgPCBhcmd1bWVudHMubGVuZ3RoOyBsKyspXG4gICAgICAgIGNbbF0gPSBhcmd1bWVudHNbbF07XG4gICAgICBpZiAoYy5sZW5ndGggPT09IDIpXG4gICAgICAgIHJldHVybiB0aGlzLl9JbnNlcnRfb3JfYXNzaWduX3dpdGhfa2V5X3ZhbHVlKGNbMF0sIGNbMV0pO1xuICAgICAgaWYgKGMubGVuZ3RoID09PSAzKVxuICAgICAgICByZXR1cm4gdGhpcy5fSW5zZXJ0X29yX2Fzc2lnbl93aXRoX2hpbnQoY1swXSwgY1sxXSwgY1syXSk7XG4gICAgfSwgYS5wcm90b3R5cGUuX0luc2VydF9vcl9hc3NpZ25fd2l0aF9rZXlfdmFsdWUgPSBmdW5jdGlvbihjLCBsKSB7XG4gICAgICB2YXIgZiA9IHRoaXMuZW1wbGFjZShjLCBsKTtcbiAgICAgIHJldHVybiBmLnNlY29uZCA9PT0gITEgJiYgKGYuZmlyc3Quc2Vjb25kID0gbCksIGY7XG4gICAgfSwgYS5wcm90b3R5cGUuX0luc2VydF9vcl9hc3NpZ25fd2l0aF9oaW50ID0gZnVuY3Rpb24oYywgbCwgZikge1xuICAgICAgdmFyIHUgPSB0aGlzLmVtcGxhY2VfaGludChjLCBsLCBmKTtcbiAgICAgIHJldHVybiB1LnNlY29uZCAhPT0gZiAmJiAodS5zZWNvbmQgPSBmKSwgdTtcbiAgICB9LCBhLnByb3RvdHlwZS5leHRyYWN0ID0gZnVuY3Rpb24oYykge1xuICAgICAgcmV0dXJuIGMgaW5zdGFuY2VvZiB0aGlzLmVuZCgpLmNvbnN0cnVjdG9yID8gdGhpcy5fRXh0cmFjdF9ieV9pdGVyYXRvcihjKSA6IHRoaXMuX0V4dHJhY3RfYnlfa2V5KGMpO1xuICAgIH0sIGEucHJvdG90eXBlLl9FeHRyYWN0X2J5X2tleSA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgIHZhciBsID0gdGhpcy5maW5kKGMpO1xuICAgICAgaWYgKGwuZXF1YWxzKHRoaXMuZW5kKCkpID09PSAhMClcbiAgICAgICAgdGhyb3cgaS5FcnJvckdlbmVyYXRvci5rZXlfbm91dF9mb3VuZCh0aGlzLCBcImV4dHJhY3RcIiwgYyk7XG4gICAgICB2YXIgZiA9IGwudmFsdWU7XG4gICAgICByZXR1cm4gdGhpcy5fRXJhc2VfYnlfcmFuZ2UobCksIGY7XG4gICAgfSwgYS5wcm90b3R5cGUuX0V4dHJhY3RfYnlfaXRlcmF0b3IgPSBmdW5jdGlvbihjKSB7XG4gICAgICByZXR1cm4gYy5lcXVhbHModGhpcy5lbmQoKSkgPT09ICEwID8gdGhpcy5lbmQoKSA6ICh0aGlzLl9FcmFzZV9ieV9yYW5nZShjKSwgYyk7XG4gICAgfSwgYS5wcm90b3R5cGUuX0VyYXNlX2J5X2tleSA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgIHZhciBsID0gdGhpcy5maW5kKGMpO1xuICAgICAgcmV0dXJuIGwuZXF1YWxzKHRoaXMuZW5kKCkpID09PSAhMCA/IDAgOiAodGhpcy5fRXJhc2VfYnlfcmFuZ2UobCksIDEpO1xuICAgIH0sIGEucHJvdG90eXBlLm1lcmdlID0gZnVuY3Rpb24oYykge1xuICAgICAgZm9yICh2YXIgbCA9IGMuYmVnaW4oKTsgIWwuZXF1YWxzKGMuZW5kKCkpOyApXG4gICAgICAgIHRoaXMuaGFzKGwuZmlyc3QpID09PSAhMSA/ICh0aGlzLmluc2VydChsLnZhbHVlKSwgbCA9IGMuZXJhc2UobCkpIDogbCA9IGwubmV4dCgpO1xuICAgIH0sIGE7XG4gIH0obi5NYXBDb250YWluZXIpO1xuICByZXR1cm4gR3QuVW5pcXVlTWFwID0gcywgR3Q7XG59XG52YXIga24gPSB7fSwgUm87XG5mdW5jdGlvbiBpZCgpIHtcbiAgcmV0dXJuIFJvIHx8IChSbyA9IDEsIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSA9IFMgJiYgUy5fX2V4dGVuZHMgfHwgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYSA9IGZ1bmN0aW9uKGMsIGwpIHtcbiAgICAgICAgcmV0dXJuIGEgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbihmLCB1KSB7XG4gICAgICAgICAgZi5fX3Byb3RvX18gPSB1O1xuICAgICAgICB9IHx8IGZ1bmN0aW9uKGYsIHUpIHtcbiAgICAgICAgICBmb3IgKHZhciBoIGluIHUpXG4gICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodSwgaCkgJiYgKGZbaF0gPSB1W2hdKTtcbiAgICAgICAgfSwgYShjLCBsKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gZnVuY3Rpb24oYywgbCkge1xuICAgICAgICBpZiAodHlwZW9mIGwgIT0gXCJmdW5jdGlvblwiICYmIGwgIT09IG51bGwpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcobCkgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBhKGMsIGwpO1xuICAgICAgICBmdW5jdGlvbiBmKCkge1xuICAgICAgICAgIHRoaXMuY29uc3RydWN0b3IgPSBjO1xuICAgICAgICB9XG4gICAgICAgIGMucHJvdG90eXBlID0gbCA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUobCkgOiAoZi5wcm90b3R5cGUgPSBsLnByb3RvdHlwZSwgbmV3IGYoKSk7XG4gICAgICB9O1xuICAgIH0oKSwgciA9IFMgJiYgUy5fX3JlYWQgfHwgZnVuY3Rpb24oYSwgYykge1xuICAgICAgdmFyIGwgPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBhW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgICBpZiAoIWwpXG4gICAgICAgIHJldHVybiBhO1xuICAgICAgdmFyIGYgPSBsLmNhbGwoYSksIHUsIGggPSBbXSwgZDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoOyAoYyA9PT0gdm9pZCAwIHx8IGMtLSA+IDApICYmICEodSA9IGYubmV4dCgpKS5kb25lOyApXG4gICAgICAgICAgaC5wdXNoKHUudmFsdWUpO1xuICAgICAgfSBjYXRjaCAocCkge1xuICAgICAgICBkID0geyBlcnJvcjogcCB9O1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB1ICYmICF1LmRvbmUgJiYgKGwgPSBmLnJldHVybikgJiYgbC5jYWxsKGYpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChkKVxuICAgICAgICAgICAgdGhyb3cgZC5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGg7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCB0Lk1hcEVsZW1lbnRMaXN0ID0gdm9pZCAwO1xuICAgIHZhciBuID0gQ2EoKSwgaSA9IG1pKCksIHMgPSBJYSgpLCBvID0gZnVuY3Rpb24oYSkge1xuICAgICAgZShjLCBhKTtcbiAgICAgIGZ1bmN0aW9uIGMobCkge1xuICAgICAgICB2YXIgZiA9IGEuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICByZXR1cm4gZi5hc3NvY2lhdGl2ZV8gPSBsLCBmO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGMucHJvdG90eXBlLl9DcmVhdGVfaXRlcmF0b3IgPSBmdW5jdGlvbihsLCBmLCB1KSB7XG4gICAgICAgIHJldHVybiBjLkl0ZXJhdG9yLmNyZWF0ZSh0aGlzLCBsLCBmLCB1KTtcbiAgICAgIH0sIGMuX1N3YXBfYXNzb2NpYXRpdmUgPSBmdW5jdGlvbihsLCBmKSB7XG4gICAgICAgIHZhciB1O1xuICAgICAgICB1ID0gcihbZi5hc3NvY2lhdGl2ZV8sIGwuYXNzb2NpYXRpdmVfXSwgMiksIGwuYXNzb2NpYXRpdmVfID0gdVswXSwgZi5hc3NvY2lhdGl2ZV8gPSB1WzFdO1xuICAgICAgfSwgYy5wcm90b3R5cGUuYXNzb2NpYXRpdmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXNzb2NpYXRpdmVfO1xuICAgICAgfSwgYztcbiAgICB9KG4uTGlzdENvbnRhaW5lcik7XG4gICAgdC5NYXBFbGVtZW50TGlzdCA9IG8sIGZ1bmN0aW9uKGEpIHtcbiAgICAgIHZhciBjID0gZnVuY3Rpb24oZikge1xuICAgICAgICBlKHUsIGYpO1xuICAgICAgICBmdW5jdGlvbiB1KGgsIGQsIHAsIHkpIHtcbiAgICAgICAgICB2YXIgZyA9IGYuY2FsbCh0aGlzLCBkLCBwLCB5KSB8fCB0aGlzO1xuICAgICAgICAgIHJldHVybiBnLmxpc3RfID0gaCwgZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdS5jcmVhdGUgPSBmdW5jdGlvbihoLCBkLCBwLCB5KSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyB1KGgsIGQsIHAsIHkpO1xuICAgICAgICB9LCB1LnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBsKHRoaXMpO1xuICAgICAgICB9LCB1LnByb3RvdHlwZS5zb3VyY2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5saXN0Xy5hc3NvY2lhdGl2ZSgpO1xuICAgICAgICB9LCBPYmplY3QuZGVmaW5lUHJvcGVydHkodS5wcm90b3R5cGUsIFwiZmlyc3RcIiwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZS5maXJzdDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh1LnByb3RvdHlwZSwgXCJzZWNvbmRcIiwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZS5zZWNvbmQ7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUuc2Vjb25kID0gaDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSksIHU7XG4gICAgICB9KGkuTGlzdEl0ZXJhdG9yKTtcbiAgICAgIGEuSXRlcmF0b3IgPSBjO1xuICAgICAgdmFyIGwgPSBmdW5jdGlvbihmKSB7XG4gICAgICAgIGUodSwgZik7XG4gICAgICAgIGZ1bmN0aW9uIHUoKSB7XG4gICAgICAgICAgcmV0dXJuIGYgIT09IG51bGwgJiYgZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHUucHJvdG90eXBlLl9DcmVhdGVfbmVpZ2hib3IgPSBmdW5jdGlvbihoKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyB1KGgpO1xuICAgICAgICB9LCBPYmplY3QuZGVmaW5lUHJvcGVydHkodS5wcm90b3R5cGUsIFwiZmlyc3RcIiwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iYXNlXy5maXJzdDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh1LnByb3RvdHlwZSwgXCJzZWNvbmRcIiwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iYXNlXy5zZWNvbmQ7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZV8uc2Vjb25kID0gaDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSksIHU7XG4gICAgICB9KHMuUmV2ZXJzZUl0ZXJhdG9yKTtcbiAgICAgIGEuUmV2ZXJzZUl0ZXJhdG9yID0gbDtcbiAgICB9KG8gPSB0Lk1hcEVsZW1lbnRMaXN0IHx8ICh0Lk1hcEVsZW1lbnRMaXN0ID0ge30pKSwgdC5NYXBFbGVtZW50TGlzdCA9IG87XG4gIH0oa24pKSwga247XG59XG52YXIgWXQgPSB7fSwgVG87XG5mdW5jdGlvbiBvZCgpIHtcbiAgaWYgKFRvKVxuICAgIHJldHVybiBZdDtcbiAgVG8gPSAxO1xuICB2YXIgdCA9IFMgJiYgUy5fX2V4dGVuZHMgfHwgZnVuY3Rpb24oKSB7XG4gICAgdmFyIG8gPSBmdW5jdGlvbihhLCBjKSB7XG4gICAgICByZXR1cm4gbyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uKGwsIGYpIHtcbiAgICAgICAgbC5fX3Byb3RvX18gPSBmO1xuICAgICAgfSB8fCBmdW5jdGlvbihsLCBmKSB7XG4gICAgICAgIGZvciAodmFyIHUgaW4gZilcbiAgICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZiwgdSkgJiYgKGxbdV0gPSBmW3VdKTtcbiAgICAgIH0sIG8oYSwgYyk7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24oYSwgYykge1xuICAgICAgaWYgKHR5cGVvZiBjICE9IFwiZnVuY3Rpb25cIiAmJiBjICE9PSBudWxsKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhjKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICBvKGEsIGMpO1xuICAgICAgZnVuY3Rpb24gbCgpIHtcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IGE7XG4gICAgICB9XG4gICAgICBhLnByb3RvdHlwZSA9IGMgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGMpIDogKGwucHJvdG90eXBlID0gYy5wcm90b3R5cGUsIG5ldyBsKCkpO1xuICAgIH07XG4gIH0oKSwgZSA9IFMgJiYgUy5fX3JlYWQgfHwgZnVuY3Rpb24obywgYSkge1xuICAgIHZhciBjID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghYylcbiAgICAgIHJldHVybiBvO1xuICAgIHZhciBsID0gYy5jYWxsKG8pLCBmLCB1ID0gW10sIGg7XG4gICAgdHJ5IHtcbiAgICAgIGZvciAoOyAoYSA9PT0gdm9pZCAwIHx8IGEtLSA+IDApICYmICEoZiA9IGwubmV4dCgpKS5kb25lOyApXG4gICAgICAgIHUucHVzaChmLnZhbHVlKTtcbiAgICB9IGNhdGNoIChkKSB7XG4gICAgICBoID0geyBlcnJvcjogZCB9O1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBmICYmICFmLmRvbmUgJiYgKGMgPSBsLnJldHVybikgJiYgYy5jYWxsKGwpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGgpXG4gICAgICAgICAgdGhyb3cgaC5lcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHU7XG4gIH0sIHIgPSBTICYmIFMuX192YWx1ZXMgfHwgZnVuY3Rpb24obykge1xuICAgIHZhciBhID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBjID0gYSAmJiBvW2FdLCBsID0gMDtcbiAgICBpZiAoYylcbiAgICAgIHJldHVybiBjLmNhbGwobyk7XG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09IFwibnVtYmVyXCIpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gbyAmJiBsID49IG8ubGVuZ3RoICYmIChvID0gdm9pZCAwKSwgeyB2YWx1ZTogbyAmJiBvW2wrK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihhID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoWXQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgWXQuTWFwSGFzaEJ1Y2tldHMgPSB2b2lkIDA7XG4gIHZhciBuID0gUmEoKSwgaSA9IGZ1bmN0aW9uKG8pIHtcbiAgICB0KGEsIG8pO1xuICAgIGZ1bmN0aW9uIGEoYywgbCwgZikge1xuICAgICAgdmFyIHUgPSBvLmNhbGwodGhpcywgcywgbCkgfHwgdGhpcztcbiAgICAgIHJldHVybiB1LnNvdXJjZV8gPSBjLCB1LmtleV9lcV8gPSBmLCB1O1xuICAgIH1cbiAgICByZXR1cm4gYS5fU3dhcF9zb3VyY2UgPSBmdW5jdGlvbihjLCBsKSB7XG4gICAgICB2YXIgZjtcbiAgICAgIGYgPSBlKFtsLnNvdXJjZV8sIGMuc291cmNlX10sIDIpLCBjLnNvdXJjZV8gPSBmWzBdLCBsLnNvdXJjZV8gPSBmWzFdO1xuICAgIH0sIGEucHJvdG90eXBlLmtleV9lcSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMua2V5X2VxXztcbiAgICB9LCBhLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24oYykge1xuICAgICAgdmFyIGwsIGYsIHUgPSB0aGlzLmhhc2hfZnVuY3Rpb24oKShjKSAlIHRoaXMubGVuZ3RoKCksIGggPSB0aGlzLmF0KHUpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgZCA9IHIoaCksIHAgPSBkLm5leHQoKTsgIXAuZG9uZTsgcCA9IGQubmV4dCgpKSB7XG4gICAgICAgICAgdmFyIHkgPSBwLnZhbHVlO1xuICAgICAgICAgIGlmICh0aGlzLmtleV9lcV8oeS5maXJzdCwgYykpXG4gICAgICAgICAgICByZXR1cm4geTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZykge1xuICAgICAgICBsID0geyBlcnJvcjogZyB9O1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBwICYmICFwLmRvbmUgJiYgKGYgPSBkLnJldHVybikgJiYgZi5jYWxsKGQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChsKVxuICAgICAgICAgICAgdGhyb3cgbC5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuc291cmNlXy5lbmQoKTtcbiAgICB9LCBhO1xuICB9KG4uSGFzaEJ1Y2tldHMpO1xuICBZdC5NYXBIYXNoQnVja2V0cyA9IGk7XG4gIGZ1bmN0aW9uIHMobykge1xuICAgIHJldHVybiBvLmZpcnN0O1xuICB9XG4gIHJldHVybiBZdDtcbn1cbnZhciBKdCA9IHt9LCBQbztcbmZ1bmN0aW9uIHNkKCkge1xuICBpZiAoUG8pXG4gICAgcmV0dXJuIEp0O1xuICBQbyA9IDEsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShKdCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBKdC5FbnRyeSA9IHZvaWQgMDtcbiAgdmFyIHQgPSB3aSgpLCBlID0gX2koKSwgciA9IGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIG4oaSwgcykge1xuICAgICAgdGhpcy5maXJzdCA9IGksIHRoaXMuc2Vjb25kID0gcztcbiAgICB9XG4gICAgcmV0dXJuIG4ucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiAoMCwgZS5lcXVhbF90bykodGhpcy5maXJzdCwgaS5maXJzdCk7XG4gICAgfSwgbi5wcm90b3R5cGUubGVzcyA9IGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiAoMCwgZS5sZXNzKSh0aGlzLmZpcnN0LCBpLmZpcnN0KTtcbiAgICB9LCBuLnByb3RvdHlwZS5oYXNoQ29kZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICgwLCB0Lmhhc2gpKHRoaXMuZmlyc3QpO1xuICAgIH0sIG47XG4gIH0oKTtcbiAgcmV0dXJuIEp0LkVudHJ5ID0gciwgSnQ7XG59XG52YXIgQm87XG5mdW5jdGlvbiBhZCgpIHtcbiAgcmV0dXJuIEJvIHx8IChCbyA9IDEsIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSA9IFMgJiYgUy5fX2V4dGVuZHMgfHwgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdSA9IGZ1bmN0aW9uKGgsIGQpIHtcbiAgICAgICAgcmV0dXJuIHUgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbihwLCB5KSB7XG4gICAgICAgICAgcC5fX3Byb3RvX18gPSB5O1xuICAgICAgICB9IHx8IGZ1bmN0aW9uKHAsIHkpIHtcbiAgICAgICAgICBmb3IgKHZhciBnIGluIHkpXG4gICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeSwgZykgJiYgKHBbZ10gPSB5W2ddKTtcbiAgICAgICAgfSwgdShoLCBkKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gZnVuY3Rpb24oaCwgZCkge1xuICAgICAgICBpZiAodHlwZW9mIGQgIT0gXCJmdW5jdGlvblwiICYmIGQgIT09IG51bGwpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoZCkgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICB1KGgsIGQpO1xuICAgICAgICBmdW5jdGlvbiBwKCkge1xuICAgICAgICAgIHRoaXMuY29uc3RydWN0b3IgPSBoO1xuICAgICAgICB9XG4gICAgICAgIGgucHJvdG90eXBlID0gZCA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoZCkgOiAocC5wcm90b3R5cGUgPSBkLnByb3RvdHlwZSwgbmV3IHAoKSk7XG4gICAgICB9O1xuICAgIH0oKSwgciA9IFMgJiYgUy5fX3JlYWQgfHwgZnVuY3Rpb24odSwgaCkge1xuICAgICAgdmFyIGQgPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiB1W1N5bWJvbC5pdGVyYXRvcl07XG4gICAgICBpZiAoIWQpXG4gICAgICAgIHJldHVybiB1O1xuICAgICAgdmFyIHAgPSBkLmNhbGwodSksIHksIGcgPSBbXSwgdjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoOyAoaCA9PT0gdm9pZCAwIHx8IGgtLSA+IDApICYmICEoeSA9IHAubmV4dCgpKS5kb25lOyApXG4gICAgICAgICAgZy5wdXNoKHkudmFsdWUpO1xuICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICB2ID0geyBlcnJvcjogXyB9O1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB5ICYmICF5LmRvbmUgJiYgKGQgPSBwLnJldHVybikgJiYgZC5jYWxsKHApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmICh2KVxuICAgICAgICAgICAgdGhyb3cgdi5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGc7XG4gICAgfSwgbiA9IFMgJiYgUy5fX3NwcmVhZEFycmF5IHx8IGZ1bmN0aW9uKHUsIGgsIGQpIHtcbiAgICAgIGlmIChkIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpXG4gICAgICAgIGZvciAodmFyIHAgPSAwLCB5ID0gaC5sZW5ndGgsIGc7IHAgPCB5OyBwKyspXG4gICAgICAgICAgKGcgfHwgIShwIGluIGgpKSAmJiAoZyB8fCAoZyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGgsIDAsIHApKSwgZ1twXSA9IGhbcF0pO1xuICAgICAgcmV0dXJuIHUuY29uY2F0KGcgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoaCkpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgdC5IYXNoTWFwID0gdm9pZCAwO1xuICAgIHZhciBpID0gbmQoKSwgcyA9IEFhKCksIG8gPSBpZCgpLCBhID0gb2QoKSwgYyA9IHNkKCksIGwgPSBUYSgpLCBmID0gZnVuY3Rpb24odSkge1xuICAgICAgZShoLCB1KTtcbiAgICAgIGZ1bmN0aW9uIGgoKSB7XG4gICAgICAgIGZvciAodmFyIGQgPSBbXSwgcCA9IDA7IHAgPCBhcmd1bWVudHMubGVuZ3RoOyBwKyspXG4gICAgICAgICAgZFtwXSA9IGFyZ3VtZW50c1twXTtcbiAgICAgICAgdmFyIHkgPSB1LmNhbGwodGhpcywgZnVuY3Rpb24oZykge1xuICAgICAgICAgIHJldHVybiBuZXcgby5NYXBFbGVtZW50TGlzdChnKTtcbiAgICAgICAgfSkgfHwgdGhpcztcbiAgICAgICAgcmV0dXJuIHMuSUhhc2hDb250YWluZXIuY29uc3RydWN0LmFwcGx5KHMuSUhhc2hDb250YWluZXIsIG4oW1xuICAgICAgICAgIHksXG4gICAgICAgICAgaCxcbiAgICAgICAgICBmdW5jdGlvbihnLCB2KSB7XG4gICAgICAgICAgICB5LmJ1Y2tldHNfID0gbmV3IGEuTWFwSGFzaEJ1Y2tldHMoeSwgZywgdik7XG4gICAgICAgICAgfVxuICAgICAgICBdLCByKGQpLCAhMSkpLCB5O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGgucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuYnVja2V0c18uY2xlYXIoKSwgdS5wcm90b3R5cGUuY2xlYXIuY2FsbCh0aGlzKTtcbiAgICAgIH0sIGgucHJvdG90eXBlLnN3YXAgPSBmdW5jdGlvbihkKSB7XG4gICAgICAgIHZhciBwLCB5O1xuICAgICAgICBwID0gcihbZC5kYXRhXywgdGhpcy5kYXRhX10sIDIpLCB0aGlzLmRhdGFfID0gcFswXSwgZC5kYXRhXyA9IHBbMV0sIG8uTWFwRWxlbWVudExpc3QuX1N3YXBfYXNzb2NpYXRpdmUodGhpcy5kYXRhXywgZC5kYXRhXyksIGEuTWFwSGFzaEJ1Y2tldHMuX1N3YXBfc291cmNlKHRoaXMuYnVja2V0c18sIGQuYnVja2V0c18pLCB5ID0gcihbZC5idWNrZXRzXywgdGhpcy5idWNrZXRzX10sIDIpLCB0aGlzLmJ1Y2tldHNfID0geVswXSwgZC5idWNrZXRzXyA9IHlbMV07XG4gICAgICB9LCBoLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWNrZXRzXy5maW5kKGQpO1xuICAgICAgfSwgaC5wcm90b3R5cGUuYmVnaW4gPSBmdW5jdGlvbihkKSB7XG4gICAgICAgIHJldHVybiBkID09PSB2b2lkIDAgJiYgKGQgPSBudWxsKSwgZCA9PT0gbnVsbCA/IHUucHJvdG90eXBlLmJlZ2luLmNhbGwodGhpcykgOiB0aGlzLmJ1Y2tldHNfLmF0KGQpWzBdO1xuICAgICAgfSwgaC5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oZCkge1xuICAgICAgICBpZiAoZCA9PT0gdm9pZCAwICYmIChkID0gbnVsbCksIGQgPT09IG51bGwpXG4gICAgICAgICAgcmV0dXJuIHUucHJvdG90eXBlLmVuZC5jYWxsKHRoaXMpO1xuICAgICAgICB2YXIgcCA9IHRoaXMuYnVja2V0c18uYXQoZCk7XG4gICAgICAgIHJldHVybiBwW3AubGVuZ3RoIC0gMV0ubmV4dCgpO1xuICAgICAgfSwgaC5wcm90b3R5cGUucmJlZ2luID0gZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4gZCA9PT0gdm9pZCAwICYmIChkID0gbnVsbCksIHRoaXMuZW5kKGQpLnJldmVyc2UoKTtcbiAgICAgIH0sIGgucHJvdG90eXBlLnJlbmQgPSBmdW5jdGlvbihkKSB7XG4gICAgICAgIHJldHVybiBkID09PSB2b2lkIDAgJiYgKGQgPSBudWxsKSwgdGhpcy5iZWdpbihkKS5yZXZlcnNlKCk7XG4gICAgICB9LCBoLnByb3RvdHlwZS5idWNrZXRfY291bnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVja2V0c18ubGVuZ3RoKCk7XG4gICAgICB9LCBoLnByb3RvdHlwZS5idWNrZXRfc2l6ZSA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVja2V0c18uYXQoZCkubGVuZ3RoO1xuICAgICAgfSwgaC5wcm90b3R5cGUubG9hZF9mYWN0b3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVja2V0c18ubG9hZF9mYWN0b3IoKTtcbiAgICAgIH0sIGgucHJvdG90eXBlLmhhc2hfZnVuY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVja2V0c18uaGFzaF9mdW5jdGlvbigpO1xuICAgICAgfSwgaC5wcm90b3R5cGUua2V5X2VxID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1Y2tldHNfLmtleV9lcSgpO1xuICAgICAgfSwgaC5wcm90b3R5cGUuYnVja2V0ID0gZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNoX2Z1bmN0aW9uKCkoZCkgJSB0aGlzLmJ1Y2tldHNfLmxlbmd0aCgpO1xuICAgICAgfSwgaC5wcm90b3R5cGUubWF4X2xvYWRfZmFjdG9yID0gZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4gZCA9PT0gdm9pZCAwICYmIChkID0gbnVsbCksIHRoaXMuYnVja2V0c18ubWF4X2xvYWRfZmFjdG9yKGQpO1xuICAgICAgfSwgaC5wcm90b3R5cGUucmVzZXJ2ZSA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgdGhpcy5idWNrZXRzXy5yZXNlcnZlKGQpO1xuICAgICAgfSwgaC5wcm90b3R5cGUucmVoYXNoID0gZnVuY3Rpb24oZCkge1xuICAgICAgICB0aGlzLmJ1Y2tldHNfLnJlaGFzaChkKTtcbiAgICAgIH0sIGgucHJvdG90eXBlLmVtcGxhY2UgPSBmdW5jdGlvbihkLCBwKSB7XG4gICAgICAgIHZhciB5ID0gdGhpcy5maW5kKGQpO1xuICAgICAgICByZXR1cm4geS5lcXVhbHModGhpcy5lbmQoKSkgPT09ICExID8gbmV3IGwuUGFpcih5LCAhMSkgOiAodGhpcy5kYXRhXy5wdXNoKG5ldyBjLkVudHJ5KGQsIHApKSwgeSA9IHkucHJldigpLCB0aGlzLl9IYW5kbGVfaW5zZXJ0KHksIHkubmV4dCgpKSwgbmV3IGwuUGFpcih5LCAhMCkpO1xuICAgICAgfSwgaC5wcm90b3R5cGUuZW1wbGFjZV9oaW50ID0gZnVuY3Rpb24oZCwgcCwgeSkge1xuICAgICAgICB2YXIgZyA9IHRoaXMuZmluZChwKTtcbiAgICAgICAgcmV0dXJuIGcuZXF1YWxzKHRoaXMuZW5kKCkpID09PSAhMCAmJiAoZyA9IHRoaXMuZGF0YV8uaW5zZXJ0KGQsIG5ldyBjLkVudHJ5KHAsIHkpKSwgdGhpcy5fSGFuZGxlX2luc2VydChnLCBnLm5leHQoKSkpLCBnO1xuICAgICAgfSwgaC5wcm90b3R5cGUuX0hhbmRsZV9pbnNlcnQgPSBmdW5jdGlvbihkLCBwKSB7XG4gICAgICAgIGZvciAoOyAhZC5lcXVhbHMocCk7IGQgPSBkLm5leHQoKSlcbiAgICAgICAgICB0aGlzLmJ1Y2tldHNfLmluc2VydChkKTtcbiAgICAgIH0sIGgucHJvdG90eXBlLl9IYW5kbGVfZXJhc2UgPSBmdW5jdGlvbihkLCBwKSB7XG4gICAgICAgIGZvciAoOyAhZC5lcXVhbHMocCk7IGQgPSBkLm5leHQoKSlcbiAgICAgICAgICB0aGlzLmJ1Y2tldHNfLmVyYXNlKGQpO1xuICAgICAgfSwgaDtcbiAgICB9KGkuVW5pcXVlTWFwKTtcbiAgICB0Lkhhc2hNYXAgPSBmLCBmdW5jdGlvbih1KSB7XG4gICAgICB1Lkl0ZXJhdG9yID0gby5NYXBFbGVtZW50TGlzdC5JdGVyYXRvciwgdS5SZXZlcnNlSXRlcmF0b3IgPSBvLk1hcEVsZW1lbnRMaXN0LlJldmVyc2VJdGVyYXRvcjtcbiAgICB9KGYgPSB0Lkhhc2hNYXAgfHwgKHQuSGFzaE1hcCA9IHt9KSksIHQuSGFzaE1hcCA9IGY7XG4gIH0oRW4pKSwgRW47XG59XG52YXIgTG87XG5mdW5jdGlvbiBjZCgpIHtcbiAgaWYgKExvKVxuICAgIHJldHVybiBfcjtcbiAgTG8gPSAxO1xuICB2YXIgdCA9IFMgJiYgUy5fX3ZhbHVlcyB8fCBmdW5jdGlvbihpKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBpW1N5bWJvbC5pdGVyYXRvcl0sIG8gPSAwO1xuICAgIHJldHVybiBzID8gcy5jYWxsKGkpIDoge1xuICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBpICYmIG8gPj0gaS5sZW5ndGggJiYgKGkgPSB2b2lkIDApLCB7IHZhbHVlOiBpICYmIGlbbysrXSwgZG9uZTogIWkgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3IsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbiAgdmFyIGUgPSB0ZCgpLCByID0gYWQoKSwgbiA9IGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIGkoKSB7XG4gICAgICB0aGlzLmxpc3RlbmVyc18gPSBuZXcgci5IYXNoTWFwKCksIHRoaXMuY3JlYXRlZF9hdF8gPSBuZXcgRGF0ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gaS5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgIHZhciBvLCBhLCBjID0gdGhpcy5saXN0ZW5lcnNfLmZpbmQocy50eXBlKTtcbiAgICAgIGlmICghYy5lcXVhbHModGhpcy5saXN0ZW5lcnNfLmVuZCgpKSkge1xuICAgICAgICBzLnRhcmdldCA9IHRoaXMsIHMudGltZVN0YW1wID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSB0aGlzLmNyZWF0ZWRfYXRfLmdldFRpbWUoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKHZhciBsID0gdChjLnNlY29uZCksIGYgPSBsLm5leHQoKTsgIWYuZG9uZTsgZiA9IGwubmV4dCgpKSB7XG4gICAgICAgICAgICB2YXIgdSA9IGYudmFsdWU7XG4gICAgICAgICAgICB1KHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoaCkge1xuICAgICAgICAgIG8gPSB7IGVycm9yOiBoIH07XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGYgJiYgIWYuZG9uZSAmJiAoYSA9IGwucmV0dXJuKSAmJiBhLmNhbGwobCk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChvKVxuICAgICAgICAgICAgICB0aHJvdyBvLmVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIGkucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihzLCBvKSB7XG4gICAgICB2YXIgYSA9IHRoaXMubGlzdGVuZXJzXy5maW5kKHMpO1xuICAgICAgYS5lcXVhbHModGhpcy5saXN0ZW5lcnNfLmVuZCgpKSAmJiAoYSA9IHRoaXMubGlzdGVuZXJzXy5lbXBsYWNlKHMsIG5ldyBlLkhhc2hTZXQoKSkuZmlyc3QpLCBhLnNlY29uZC5pbnNlcnQobyk7XG4gICAgfSwgaS5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKHMsIG8pIHtcbiAgICAgIHZhciBhID0gdGhpcy5saXN0ZW5lcnNfLmZpbmQocyk7XG4gICAgICBhLmVxdWFscyh0aGlzLmxpc3RlbmVyc18uZW5kKCkpIHx8IChhLnNlY29uZC5lcmFzZShvKSwgYS5zZWNvbmQuZW1wdHkoKSAmJiB0aGlzLmxpc3RlbmVyc18uZXJhc2UoYSkpO1xuICAgIH0sIGk7XG4gIH0oKTtcbiAgcmV0dXJuIF9yLkV2ZW50VGFyZ2V0ID0gbiwgX3I7XG59XG52YXIgbXIgPSB7fSwgJG87XG5mdW5jdGlvbiBWcigpIHtcbiAgaWYgKCRvKVxuICAgIHJldHVybiBtcjtcbiAgJG8gPSAxLCBPYmplY3QuZGVmaW5lUHJvcGVydHkobXIsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbiAgdmFyIHQgPSBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBlKHIsIG4pIHtcbiAgICAgIHRoaXMudHlwZSA9IHIsIG4gJiYgT2JqZWN0LmFzc2lnbih0aGlzLCBuKTtcbiAgICB9XG4gICAgcmV0dXJuIGU7XG4gIH0oKTtcbiAgcmV0dXJuIG1yLkV2ZW50ID0gdCwgbXI7XG59XG52YXIgeHIgPSB7fSwgcW87XG5mdW5jdGlvbiB1ZCgpIHtcbiAgaWYgKHFvKVxuICAgIHJldHVybiB4cjtcbiAgcW8gPSAxO1xuICB2YXIgdCA9IFMgJiYgUy5fX2V4dGVuZHMgfHwgZnVuY3Rpb24oKSB7XG4gICAgdmFyIG4gPSBmdW5jdGlvbihpLCBzKSB7XG4gICAgICByZXR1cm4gbiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uKG8sIGEpIHtcbiAgICAgICAgby5fX3Byb3RvX18gPSBhO1xuICAgICAgfSB8fCBmdW5jdGlvbihvLCBhKSB7XG4gICAgICAgIGZvciAodmFyIGMgaW4gYSlcbiAgICAgICAgICBhLmhhc093blByb3BlcnR5KGMpICYmIChvW2NdID0gYVtjXSk7XG4gICAgICB9LCBuKGksIHMpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGksIHMpIHtcbiAgICAgIG4oaSwgcyk7XG4gICAgICBmdW5jdGlvbiBvKCkge1xuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yID0gaTtcbiAgICAgIH1cbiAgICAgIGkucHJvdG90eXBlID0gcyA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUocykgOiAoby5wcm90b3R5cGUgPSBzLnByb3RvdHlwZSwgbmV3IG8oKSk7XG4gICAgfTtcbiAgfSgpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoeHIsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbiAgdmFyIGUgPSBWcigpLCByID0gZnVuY3Rpb24obikge1xuICAgIHQoaSwgbik7XG4gICAgZnVuY3Rpb24gaShzLCBvKSB7XG4gICAgICByZXR1cm4gbi5jYWxsKHRoaXMsIHMsIG8pIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBpO1xuICB9KGUuRXZlbnQpO1xuICByZXR1cm4geHIuQ2xvc2VFdmVudCA9IHIsIHhyO1xufVxudmFyIEVyID0ge30sIE5vO1xuZnVuY3Rpb24gbGQoKSB7XG4gIGlmIChObylcbiAgICByZXR1cm4gRXI7XG4gIE5vID0gMTtcbiAgdmFyIHQgPSBTICYmIFMuX19leHRlbmRzIHx8IGZ1bmN0aW9uKCkge1xuICAgIHZhciBuID0gZnVuY3Rpb24oaSwgcykge1xuICAgICAgcmV0dXJuIG4gPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbihvLCBhKSB7XG4gICAgICAgIG8uX19wcm90b19fID0gYTtcbiAgICAgIH0gfHwgZnVuY3Rpb24obywgYSkge1xuICAgICAgICBmb3IgKHZhciBjIGluIGEpXG4gICAgICAgICAgYS5oYXNPd25Qcm9wZXJ0eShjKSAmJiAob1tjXSA9IGFbY10pO1xuICAgICAgfSwgbihpLCBzKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbihpLCBzKSB7XG4gICAgICBuKGksIHMpO1xuICAgICAgZnVuY3Rpb24gbygpIHtcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IGk7XG4gICAgICB9XG4gICAgICBpLnByb3RvdHlwZSA9IHMgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKHMpIDogKG8ucHJvdG90eXBlID0gcy5wcm90b3R5cGUsIG5ldyBvKCkpO1xuICAgIH07XG4gIH0oKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEVyLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG4gIHZhciBlID0gVnIoKSwgciA9IGZ1bmN0aW9uKG4pIHtcbiAgICB0KGksIG4pO1xuICAgIGZ1bmN0aW9uIGkocywgbykge1xuICAgICAgcmV0dXJuIG4uY2FsbCh0aGlzLCBzLCBvKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gaTtcbiAgfShlLkV2ZW50KTtcbiAgcmV0dXJuIEVyLk1lc3NhZ2VFdmVudCA9IHIsIEVyO1xufVxudmFyIGtyID0ge30sIFVvO1xuZnVuY3Rpb24gZmQoKSB7XG4gIGlmIChVbylcbiAgICByZXR1cm4ga3I7XG4gIFVvID0gMTtcbiAgdmFyIHQgPSBTICYmIFMuX19leHRlbmRzIHx8IGZ1bmN0aW9uKCkge1xuICAgIHZhciBuID0gZnVuY3Rpb24oaSwgcykge1xuICAgICAgcmV0dXJuIG4gPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbihvLCBhKSB7XG4gICAgICAgIG8uX19wcm90b19fID0gYTtcbiAgICAgIH0gfHwgZnVuY3Rpb24obywgYSkge1xuICAgICAgICBmb3IgKHZhciBjIGluIGEpXG4gICAgICAgICAgYS5oYXNPd25Qcm9wZXJ0eShjKSAmJiAob1tjXSA9IGFbY10pO1xuICAgICAgfSwgbihpLCBzKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbihpLCBzKSB7XG4gICAgICBuKGksIHMpO1xuICAgICAgZnVuY3Rpb24gbygpIHtcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IGk7XG4gICAgICB9XG4gICAgICBpLnByb3RvdHlwZSA9IHMgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKHMpIDogKG8ucHJvdG90eXBlID0gcy5wcm90b3R5cGUsIG5ldyBvKCkpO1xuICAgIH07XG4gIH0oKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGtyLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG4gIHZhciBlID0gVnIoKSwgciA9IGZ1bmN0aW9uKG4pIHtcbiAgICB0KGksIG4pO1xuICAgIGZ1bmN0aW9uIGkocywgbykge1xuICAgICAgcmV0dXJuIG4uY2FsbCh0aGlzLCBzLCBvKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gaTtcbiAgfShlLkV2ZW50KTtcbiAgcmV0dXJuIGtyLkVycm9yRXZlbnQgPSByLCBrcjtcbn1cbnZhciBqbztcbmZ1bmN0aW9uIGhkKCkge1xuICByZXR1cm4gam8gfHwgKGpvID0gMSwgZnVuY3Rpb24odCkge1xuICAgIHZhciBlID0gUyAmJiBTLl9fZXh0ZW5kcyB8fCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB1ID0gZnVuY3Rpb24oaCwgZCkge1xuICAgICAgICByZXR1cm4gdSA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uKHAsIHkpIHtcbiAgICAgICAgICBwLl9fcHJvdG9fXyA9IHk7XG4gICAgICAgIH0gfHwgZnVuY3Rpb24ocCwgeSkge1xuICAgICAgICAgIGZvciAodmFyIGcgaW4geSlcbiAgICAgICAgICAgIHkuaGFzT3duUHJvcGVydHkoZykgJiYgKHBbZ10gPSB5W2ddKTtcbiAgICAgICAgfSwgdShoLCBkKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gZnVuY3Rpb24oaCwgZCkge1xuICAgICAgICB1KGgsIGQpO1xuICAgICAgICBmdW5jdGlvbiBwKCkge1xuICAgICAgICAgIHRoaXMuY29uc3RydWN0b3IgPSBoO1xuICAgICAgICB9XG4gICAgICAgIGgucHJvdG90eXBlID0gZCA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoZCkgOiAocC5wcm90b3R5cGUgPSBkLnByb3RvdHlwZSwgbmV3IHAoKSk7XG4gICAgICB9O1xuICAgIH0oKSwgciA9IFMgJiYgUy5fX2Fzc2lnbiB8fCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiByID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih1KSB7XG4gICAgICAgIGZvciAodmFyIGgsIGQgPSAxLCBwID0gYXJndW1lbnRzLmxlbmd0aDsgZCA8IHA7IGQrKykge1xuICAgICAgICAgIGggPSBhcmd1bWVudHNbZF07XG4gICAgICAgICAgZm9yICh2YXIgeSBpbiBoKVxuICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGgsIHkpICYmICh1W3ldID0gaFt5XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHU7XG4gICAgICB9LCByLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuICAgIHZhciBuID0gemgoKSwgaSA9IGNkKCksIHMgPSBWcigpLCBvID0gdWQoKSwgYSA9IGxkKCksIGMgPSBmZCgpLCBsID0gZnVuY3Rpb24odSkge1xuICAgICAgZShoLCB1KTtcbiAgICAgIGZ1bmN0aW9uIGgoZCwgcCkge1xuICAgICAgICB2YXIgeSA9IHUuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICByZXR1cm4geS5vbl8gPSB7fSwgeS5zdGF0ZV8gPSBoLkNPTk5FQ1RJTkcsIHkuY2xpZW50XyA9IG5ldyBuLmNsaWVudCgpLCB5LmNsaWVudF8ub24oXCJjb25uZWN0XCIsIHkuX0hhbmRsZV9jb25uZWN0LmJpbmQoeSkpLCB5LmNsaWVudF8ub24oXCJjb25uZWN0RmFpbGVkXCIsIHkuX0hhbmRsZV9lcnJvci5iaW5kKHkpKSwgdHlwZW9mIHAgPT0gXCJzdHJpbmdcIiAmJiAocCA9IFtwXSksIHkuY2xpZW50Xy5jb25uZWN0KGQsIHApLCB5O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGgucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oZCwgcCkge1xuICAgICAgICB0aGlzLnN0YXRlXyA9IGguQ0xPU0lORywgZCA9PT0gdm9pZCAwID8gdGhpcy5jb25uZWN0aW9uXy5zZW5kQ2xvc2VGcmFtZSgpIDogdGhpcy5jb25uZWN0aW9uXy5zZW5kQ2xvc2VGcmFtZShkLCBwLCAhMCk7XG4gICAgICB9LCBoLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24oZCkge1xuICAgICAgICBpZiAodHlwZW9mIGQudmFsdWVPZigpID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgdGhpcy5jb25uZWN0aW9uXy5zZW5kVVRGKGQpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgcCA9IHZvaWQgMDtcbiAgICAgICAgICBkIGluc3RhbmNlb2YgQnVmZmVyID8gcCA9IGQgOiBkIGluc3RhbmNlb2YgQmxvYiA/IHAgPSBuZXcgQnVmZmVyKGQsIFwiYmxvYlwiKSA6IGQuYnVmZmVyID8gcCA9IG5ldyBCdWZmZXIoZC5idWZmZXIpIDogcCA9IG5ldyBCdWZmZXIoZCksIHRoaXMuY29ubmVjdGlvbl8uc2VuZEJ5dGVzKHApO1xuICAgICAgICB9XG4gICAgICB9LCBPYmplY3QuZGVmaW5lUHJvcGVydHkoaC5wcm90b3R5cGUsIFwidXJsXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jbGllbnRfLnVybC5ocmVmO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShoLnByb3RvdHlwZSwgXCJwcm90b2NvbFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50Xy5wcm90b2NvbHMgPyB0aGlzLmNsaWVudF8ucHJvdG9jb2xzWzBdIDogXCJcIjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoaC5wcm90b3R5cGUsIFwiZXh0ZW5zaW9uc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbl8gJiYgdGhpcy5jb25uZWN0aW9uXy5leHRlbnNpb25zID8gdGhpcy5jb25uZWN0aW9uXy5leHRlbnNpb25zWzBdLm5hbWUgOiBcIlwiO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShoLnByb3RvdHlwZSwgXCJyZWFkeVN0YXRlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZV87XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGgucHJvdG90eXBlLCBcImJ1ZmZlcmVkQW1vdW50XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uXy5ieXRlc1dhaXRpbmdUb0ZsdXNoO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShoLnByb3RvdHlwZSwgXCJiaW5hcnlUeXBlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gXCJhcnJheWJ1ZmZlclwiO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShoLnByb3RvdHlwZSwgXCJvbm9wZW5cIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLm9uXy5vcGVuO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICB0aGlzLl9TZXRfb24oXCJvcGVuXCIsIGQpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShoLnByb3RvdHlwZSwgXCJvbmNsb3NlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5vbl8uY2xvc2U7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24oZCkge1xuICAgICAgICAgIHRoaXMuX1NldF9vbihcImNsb3NlXCIsIGQpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShoLnByb3RvdHlwZSwgXCJvbm1lc3NhZ2VcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLm9uXy5tZXNzYWdlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICB0aGlzLl9TZXRfb24oXCJtZXNzYWdlXCIsIGQpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShoLnByb3RvdHlwZSwgXCJvbmVycm9yXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5vbl8uZXJyb3I7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24oZCkge1xuICAgICAgICAgIHRoaXMuX1NldF9vbihcImVycm9yXCIsIGQpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgfSksIGgucHJvdG90eXBlLl9TZXRfb24gPSBmdW5jdGlvbihkLCBwKSB7XG4gICAgICAgIHRoaXMub25fW2RdICYmIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihkLCB0aGlzLm9uX1tkXSksIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihkLCBwKSwgdGhpcy5vbl9bZF0gPSBwO1xuICAgICAgfSwgaC5wcm90b3R5cGUuX0hhbmRsZV9jb25uZWN0ID0gZnVuY3Rpb24oZCkge1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25fID0gZCwgdGhpcy5zdGF0ZV8gPSBoLk9QRU4sIHRoaXMuY29ubmVjdGlvbl8ub24oXCJtZXNzYWdlXCIsIHRoaXMuX0hhbmRsZV9tZXNzYWdlLmJpbmQodGhpcykpLCB0aGlzLmNvbm5lY3Rpb25fLm9uKFwiZXJyb3JcIiwgdGhpcy5fSGFuZGxlX2Vycm9yLmJpbmQodGhpcykpLCB0aGlzLmNvbm5lY3Rpb25fLm9uKFwiY2xvc2VcIiwgdGhpcy5fSGFuZGxlX2Nsb3NlLmJpbmQodGhpcykpO1xuICAgICAgICB2YXIgcCA9IG5ldyBzLkV2ZW50KFwib3BlblwiLCBmKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHApO1xuICAgICAgfSwgaC5wcm90b3R5cGUuX0hhbmRsZV9jbG9zZSA9IGZ1bmN0aW9uKGQsIHApIHtcbiAgICAgICAgdmFyIHkgPSBuZXcgby5DbG9zZUV2ZW50KFwiY2xvc2VcIiwgcih7fSwgZiwgeyBjb2RlOiBkLCByZWFzb246IHAgfSkpO1xuICAgICAgICB0aGlzLnN0YXRlXyA9IGguQ0xPU0VELCB0aGlzLmRpc3BhdGNoRXZlbnQoeSk7XG4gICAgICB9LCBoLnByb3RvdHlwZS5fSGFuZGxlX21lc3NhZ2UgPSBmdW5jdGlvbihkKSB7XG4gICAgICAgIHZhciBwID0gbmV3IGEuTWVzc2FnZUV2ZW50KFwibWVzc2FnZVwiLCByKHt9LCBmLCB7IGRhdGE6IGQuYmluYXJ5RGF0YSA/IGQuYmluYXJ5RGF0YSA6IGQudXRmOERhdGEgfSkpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQocCk7XG4gICAgICB9LCBoLnByb3RvdHlwZS5fSGFuZGxlX2Vycm9yID0gZnVuY3Rpb24oZCkge1xuICAgICAgICB2YXIgcCA9IG5ldyBjLkVycm9yRXZlbnQoXCJlcnJvclwiLCByKHt9LCBmLCB7IGVycm9yOiBkLCBtZXNzYWdlOiBkLm1lc3NhZ2UgfSkpO1xuICAgICAgICB0aGlzLnN0YXRlXyA9PT0gaC5DT05ORUNUSU5HICYmICh0aGlzLnN0YXRlXyA9IGguQ0xPU0VEKSwgdGhpcy5kaXNwYXRjaEV2ZW50KHApO1xuICAgICAgfSwgaDtcbiAgICB9KGkuRXZlbnRUYXJnZXQpO1xuICAgIHQuV2ViU29ja2V0ID0gbCwgZnVuY3Rpb24odSkge1xuICAgICAgdS5DT05ORUNUSU5HID0gMCwgdS5PUEVOID0gMSwgdS5DTE9TSU5HID0gMiwgdS5DTE9TRUQgPSAzO1xuICAgIH0obCA9IHQuV2ViU29ja2V0IHx8ICh0LldlYlNvY2tldCA9IHt9KSksIHQuV2ViU29ja2V0ID0gbDtcbiAgICB2YXIgZiA9IHtcbiAgICAgIGJ1YmJsZXM6ICExLFxuICAgICAgY2FuY2VsYWJsZTogITFcbiAgICB9O1xuICB9KHBuKSksIHBuO1xufVxudmFyIGRkID0gY3I7XG5kZC5pc19ub2RlKCkgJiYgKFMuV2ViU29ja2V0ID0gaGQoKS5XZWJTb2NrZXQpO1xuQmlnSW50KDFlMyksIEJpZ0ludCgxZTYpLCBCaWdJbnQoMWU5KSwgQmlnSW50KDFlMTIpO1xuQmlnSW50KFwiMjEwMDAwMDAwMDAwMDAwMDAwMFwiKTtcbkJpZ0ludCgxZTExKTtcbmNvbnN0IEhvID0ge1xuICBwYXltZW50X2hhc2g6IDEsXG4gIHBheW1lbnRfc2VjcmV0OiAxNixcbiAgZGVzY3JpcHRpb246IDEzLFxuICBwYXllZTogMTksXG4gIGRlc2NyaXB0aW9uX2hhc2g6IDIzLFxuICBleHBpcnk6IDYsXG4gIG1pbl9maW5hbF9jbHR2X2V4cGlyeTogMjQsXG4gIGZhbGxiYWNrX2FkZHJlc3M6IDksXG4gIHJvdXRlX2hpbnQ6IDMsXG4gIGZlYXR1cmVfYml0czogNSxcbiAgbWV0YWRhdGE6IDI3XG59O1xuZm9yIChsZXQgdCA9IDAsIGUgPSBPYmplY3Qua2V5cyhIbyk7IHQgPCBlLmxlbmd0aDsgdCsrKVxuICBlW3RdLCBIb1tlW3RdXS50b1N0cmluZygpO1xuZnVuY3Rpb24gcGQodCwgZSkge1xuICByZXR1cm4gdC5jcmVhdGVkX2F0ID4gZS5jcmVhdGVkX2F0ID8gdCA6IGU7XG59XG52YXIgeWQgPSBbXG4gIFwid3NzOi8vbm9zLmxvbFwiLFxuICBcIndzczovL3JlbGF5Lm5vc3RyLmJhbmRcIixcbiAgXCJ3c3M6Ly9yZWxheS5mN3ouaW9cIixcbiAgXCJ3c3M6Ly9yZWxheS5kYW11cy5pb1wiLFxuICBcIndzczovL25vc3RyLm1vbVwiLFxuICBcIndzczovL25vLnN0ci5jclwiXG5dLCBnZCA9IGNsYXNzIGV4dGVuZHMgZHQge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgc3VwZXIoKTtcbiAgICBJKHRoaXMsIFwibmRrXCIpO1xuICAgIEkodGhpcywgXCJ6YXBwZWRFdmVudFwiKTtcbiAgICBJKHRoaXMsIFwiemFwcGVkVXNlclwiKTtcbiAgICB0aGlzLm5kayA9IGUubmRrLCB0aGlzLnphcHBlZEV2ZW50ID0gZS56YXBwZWRFdmVudCwgdGhpcy56YXBwZWRVc2VyID0gZS56YXBwZWRVc2VyIHx8IHRoaXMubmRrLmdldFVzZXIoeyBoZXhwdWJrZXk6IHRoaXMuemFwcGVkRXZlbnQucHVia2V5IH0pO1xuICB9XG4gIGFzeW5jIGdldFphcEVuZHBvaW50KCkge1xuICAgIGxldCBlLCByLCBuLCBpO1xuICAgIGlmICh0aGlzLnphcHBlZEV2ZW50KSB7XG4gICAgICBjb25zdCBhID0gKGF3YWl0IHRoaXMuemFwcGVkRXZlbnQuZ2V0TWF0Y2hpbmdUYWdzKFwiemFwXCIpKVswXTtcbiAgICAgIGlmIChhKVxuICAgICAgICBzd2l0Y2ggKGFbMl0pIHtcbiAgICAgICAgICBjYXNlIFwibHVkMDZcIjpcbiAgICAgICAgICAgIGUgPSBhWzFdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImx1ZDE2XCI6XG4gICAgICAgICAgICByID0gYVsxXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gemFwIHRhZyAke2F9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuemFwcGVkVXNlciAmJiAhZSAmJiAhciAmJiAodGhpcy56YXBwZWRVc2VyLnByb2ZpbGUgfHwgYXdhaXQgdGhpcy56YXBwZWRVc2VyLmZldGNoUHJvZmlsZSgpLCBlID0gKHRoaXMuemFwcGVkVXNlci5wcm9maWxlIHx8IHt9KS5sdWQwNiwgciA9ICh0aGlzLnphcHBlZFVzZXIucHJvZmlsZSB8fCB7fSkubHVkMTYpLCByKSB7XG4gICAgICBjb25zdCBbYSwgY10gPSByLnNwbGl0KFwiQFwiKTtcbiAgICAgIG4gPSBgaHR0cHM6Ly8ke2N9Ly53ZWxsLWtub3duL2xudXJscC8ke2F9YDtcbiAgICB9IGVsc2UgaWYgKGUpIHtcbiAgICAgIGNvbnN0IHsgd29yZHM6IGEgfSA9IHRlLmRlY29kZShlLCAxZTMpLCBjID0gdGUuZnJvbVdvcmRzKGEpO1xuICAgICAgbiA9IG5ldyBUZXh0RGVjb2RlcihcInV0Zi04XCIpLmRlY29kZShjKTtcbiAgICB9XG4gICAgaWYgKCFuKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gemFwIGVuZHBvaW50IGZvdW5kXCIpO1xuICAgIGNvbnN0IG8gPSBhd2FpdCAoYXdhaXQgZmV0Y2gobikpLmpzb24oKTtcbiAgICByZXR1cm4gKG8gPT0gbnVsbCA/IHZvaWQgMCA6IG8uYWxsb3dzTm9zdHIpICYmICgobyA9PSBudWxsID8gdm9pZCAwIDogby5ub3N0clB1YmtleSkgfHwgKG8gPT0gbnVsbCA/IHZvaWQgMCA6IG8ubm9zdHJQdWJLZXkpKSAmJiAoaSA9IG8uY2FsbGJhY2spLCBpO1xuICB9XG4gIGFzeW5jIGNyZWF0ZVphcFJlcXVlc3QoZSwgciwgbiwgaSkge1xuICAgIGNvbnN0IHMgPSBhd2FpdCB0aGlzLmdldFphcEVuZHBvaW50KCk7XG4gICAgaWYgKCFzKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gemFwIGVuZHBvaW50IGZvdW5kXCIpO1xuICAgIGlmICghdGhpcy56YXBwZWRFdmVudClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHphcHBlZCBldmVudCBmb3VuZFwiKTtcbiAgICBjb25zdCBvID0gRWEubWFrZVphcFJlcXVlc3Qoe1xuICAgICAgcHJvZmlsZTogdGhpcy56YXBwZWRVc2VyLmhleHB1YmtleSgpLFxuICAgICAgZXZlbnQ6IG51bGwsXG4gICAgICBhbW91bnQ6IGUsXG4gICAgICBjb21tZW50OiByIHx8IFwiXCIsXG4gICAgICByZWxheXM6IGkgIT0gbnVsbCA/IGkgOiB0aGlzLnJlbGF5cygpXG4gICAgfSk7XG4gICAgaWYgKHRoaXMuemFwcGVkRXZlbnQpIHtcbiAgICAgIGNvbnN0IHUgPSB0aGlzLnphcHBlZEV2ZW50LnRhZ1JlZmVyZW5jZSgpO1xuICAgICAgdSAmJiBvLnRhZ3MucHVzaCh1KTtcbiAgICB9XG4gICAgby50YWdzLnB1c2goW1wibG51cmxcIiwgc10pO1xuICAgIGNvbnN0IGEgPSBuZXcgcWUodGhpcy5uZGssIG8pO1xuICAgIG4gJiYgKGEudGFncyA9IGEudGFncy5jb25jYXQobikpLCBhd2FpdCBhLnNpZ24oKTtcbiAgICBjb25zdCBjID0gYXdhaXQgYS50b05vc3RyRXZlbnQoKTtcbiAgICByZXR1cm4gKGF3YWl0IChhd2FpdCBmZXRjaChcbiAgICAgIGAke3N9P2AgKyBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgYW1vdW50OiBlLnRvU3RyaW5nKCksXG4gICAgICAgIG5vc3RyOiBKU09OLnN0cmluZ2lmeShjKVxuICAgICAgfSlcbiAgICApKS5qc29uKCkpLnByO1xuICB9XG4gIHJlbGF5cygpIHtcbiAgICB2YXIgciwgbjtcbiAgICBsZXQgZSA9IFtdO1xuICAgIHJldHVybiAobiA9IChyID0gdGhpcy5uZGspID09IG51bGwgPyB2b2lkIDAgOiByLnBvb2wpICE9IG51bGwgJiYgbi5yZWxheXMgJiYgKGUgPSB0aGlzLm5kay5wb29sLnVybHMoKSksIGUubGVuZ3RoIHx8IChlID0geWQpLCBlO1xuICB9XG59O1xuZnVuY3Rpb24gYmQodCwgZSA9IFtdKSB7XG4gIGNvbnN0IHIgPSAvKEB8bm9zdHI6KShucHVifG5wcm9maWxlfG5vdGV8bmV2ZW50KVthLXpBLVowLTldKy9nO1xuICByZXR1cm4gdCA9IHQucmVwbGFjZShyLCAobikgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBpID0gbi5zcGxpdCgvKEB8bm9zdHI6KS8pWzJdLCB7IHR5cGU6IHMsIGRhdGE6IG8gfSA9IHdlLmRlY29kZShpKTtcbiAgICAgIGxldCBhO1xuICAgICAgc3dpdGNoIChzKSB7XG4gICAgICAgIGNhc2UgXCJucHViXCI6XG4gICAgICAgICAgYSA9IFtcInBcIiwgb107XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJucHJvZmlsZVwiOlxuICAgICAgICAgIGEgPSBbXCJwXCIsIG8ucHVia2V5XTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm5ldmVudFwiOlxuICAgICAgICAgIGEgPSBbXCJlXCIsIG8uaWRdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibm90ZVwiOlxuICAgICAgICAgIGEgPSBbXCJlXCIsIG9dO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGUuZmluZCgoYykgPT4gY1swXSA9PT0gYVswXSAmJiBjWzFdID09PSBhWzFdKSB8fCBlLnB1c2goYSksIGBub3N0cjoke2l9YDtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBuO1xuICAgIH1cbiAgfSksIHsgY29udGVudDogdCwgdGFnczogZSB9O1xufVxuZnVuY3Rpb24gdmQoKSB7XG4gIGlmICh0aGlzLmtpbmQgPT09IHZvaWQgMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJLaW5kIG5vdCBzZXRcIik7XG4gIHJldHVybiB0aGlzLmtpbmQgPj0gMWU0ICYmIHRoaXMua2luZCA8IDJlNDtcbn1cbmZ1bmN0aW9uIHdkKCkge1xuICBpZiAodGhpcy5raW5kID09PSB2b2lkIDApXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiS2luZCBub3Qgc2V0XCIpO1xuICByZXR1cm4gdGhpcy5raW5kID49IDNlNCAmJiB0aGlzLmtpbmQgPCA0ZTQ7XG59XG5hc3luYyBmdW5jdGlvbiBfZCgpIHtcbiAgaWYgKCF0aGlzLm5kaylcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJOREsgbm90IHNldFwiKTtcbiAgY29uc3QgdCA9IGF3YWl0IHRoaXMubmRrLmZldGNoRXZlbnRzKHtcbiAgICBraW5kczogWzNdLFxuICAgIGF1dGhvcnM6IFt0aGlzLmhleHB1YmtleSgpXVxuICB9KTtcbiAgaWYgKHQpIHtcbiAgICBjb25zdCBlID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICByZXR1cm4gdC5mb3JFYWNoKChyKSA9PiB7XG4gICAgICByLnRhZ3MuZm9yRWFjaCgobikgPT4ge1xuICAgICAgICBpZiAoblswXSA9PT0gXCJwXCIpXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGkgPSB3ZS5ucHViRW5jb2RlKG5bMV0pO1xuICAgICAgICAgICAgZS5hZGQoaSk7XG4gICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSksIFsuLi5lXS5yZWR1Y2UoKHIsIG4pID0+IHtcbiAgICAgIGNvbnN0IGkgPSBuZXcgcGUoeyBucHViOiBuIH0pO1xuICAgICAgcmV0dXJuIGkubmRrID0gdGhpcy5uZGssIHIuYWRkKGkpLCByO1xuICAgIH0sIC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xufVxuZnVuY3Rpb24gbWQodCwgZSkge1xuICBjb25zdCByID0gSlNPTi5wYXJzZSh0LmNvbnRlbnQpO1xuICByZXR1cm4gT2JqZWN0LmtleXMocikuZm9yRWFjaCgobikgPT4ge1xuICAgIHN3aXRjaCAobikge1xuICAgICAgY2FzZSBcIm5hbWVcIjpcbiAgICAgICAgZS5uYW1lID0gci5uYW1lO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJkaXNwbGF5X25hbWVcIjpcbiAgICAgIGNhc2UgXCJkaXNwbGF5TmFtZVwiOlxuICAgICAgICBlLmRpc3BsYXlOYW1lID0gci5kaXNwbGF5TmFtZSB8fCByLmRpc3BsYXlfbmFtZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiaW1hZ2VcIjpcbiAgICAgIGNhc2UgXCJwaWN0dXJlXCI6XG4gICAgICAgIGUuaW1hZ2UgPSByLmltYWdlIHx8IHIucGljdHVyZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYmFubmVyXCI6XG4gICAgICAgIGUuYmFubmVyID0gci5iYW5uZXI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImJpb1wiOlxuICAgICAgICBlLmJpbyA9IHIuYmlvO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJuaXAwNVwiOlxuICAgICAgICBlLm5pcDA1ID0gci5uaXAwNTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibHVkMDZcIjpcbiAgICAgICAgZS5sdWQwNiA9IHIubHVkMDY7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImx1ZDE2XCI6XG4gICAgICAgIGUubHVkMTYgPSByLmx1ZDE2O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJhYm91dFwiOlxuICAgICAgICBlLmFib3V0ID0gci5hYm91dDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiemFwU2VydmljZVwiOlxuICAgICAgICBlLnphcFNlcnZpY2UgPSByLnphcFNlcnZpY2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIndlYnNpdGVcIjpcbiAgICAgICAgZS53ZWJzaXRlID0gci53ZWJzaXRlO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGVbbl0gPSByW25dO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0pLCBlO1xufVxudmFyIHBlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgSSh0aGlzLCBcIm5ka1wiKTtcbiAgICBJKHRoaXMsIFwicHJvZmlsZVwiKTtcbiAgICBJKHRoaXMsIFwibnB1YlwiLCBcIlwiKTtcbiAgICBJKHRoaXMsIFwicmVsYXlVcmxzXCIsIFtdKTtcbiAgICBJKHRoaXMsIFwiZm9sbG93c1wiLCBfZC5iaW5kKHRoaXMpKTtcbiAgICB0Lm5wdWIgJiYgKHRoaXMubnB1YiA9IHQubnB1YiksIHQuaGV4cHVia2V5ICYmICh0aGlzLm5wdWIgPSB3ZS5ucHViRW5jb2RlKHQuaGV4cHVia2V5KSksIHQucmVsYXlVcmxzICYmICh0aGlzLnJlbGF5VXJscyA9IHQucmVsYXlVcmxzKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZnJvbU5pcDA1KHQpIHtcbiAgICBjb25zdCBlID0gYXdhaXQgX2EucXVlcnlQcm9maWxlKHQpO1xuICAgIGlmIChlKVxuICAgICAgcmV0dXJuIG5ldyBwZSh7XG4gICAgICAgIGhleHB1YmtleTogZS5wdWJrZXksXG4gICAgICAgIHJlbGF5VXJsczogZS5yZWxheXNcbiAgICAgIH0pO1xuICB9XG4gIGhleHB1YmtleSgpIHtcbiAgICByZXR1cm4gd2UuZGVjb2RlKHRoaXMubnB1YikuZGF0YTtcbiAgfVxuICBhc3luYyBmZXRjaFByb2ZpbGUodCkge1xuICAgIGlmICghdGhpcy5uZGspXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOREsgbm90IHNldFwiKTtcbiAgICB0aGlzLnByb2ZpbGUgfHwgKHRoaXMucHJvZmlsZSA9IHt9KTtcbiAgICBjb25zdCBlID0gYXdhaXQgdGhpcy5uZGsuZmV0Y2hFdmVudHMoXG4gICAgICB7XG4gICAgICAgIGtpbmRzOiBbMF0sXG4gICAgICAgIGF1dGhvcnM6IFt0aGlzLmhleHB1YmtleSgpXVxuICAgICAgfSxcbiAgICAgIHRcbiAgICApO1xuICAgIHJldHVybiBlICYmIEFycmF5LmZyb20oZSkuc29ydChcbiAgICAgIChuLCBpKSA9PiBuLmNyZWF0ZWRfYXQgLSBpLmNyZWF0ZWRfYXRcbiAgICApLmZvckVhY2goKG4pID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMucHJvZmlsZSA9IG1kKG4sIHRoaXMucHJvZmlsZSk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgIH1cbiAgICB9KSwgZTtcbiAgfVxuICBhc3luYyByZWxheUxpc3QoKSB7XG4gICAgaWYgKCF0aGlzLm5kaylcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5ESyBub3Qgc2V0XCIpO1xuICAgIGNvbnN0IHQgPSBhd2FpdCB0aGlzLm5kay5mZXRjaEV2ZW50cyh7XG4gICAgICBraW5kczogWzEwMDAyXSxcbiAgICAgIGF1dGhvcnM6IFt0aGlzLmhleHB1YmtleSgpXVxuICAgIH0pO1xuICAgIHJldHVybiB0IHx8IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIH1cbiAgdGFnUmVmZXJlbmNlKCkge1xuICAgIHJldHVybiBbXCJwXCIsIHRoaXMuaGV4cHVia2V5KCldO1xuICB9XG4gIGFzeW5jIHB1Ymxpc2goKSB7XG4gICAgaWYgKCF0aGlzLm5kaylcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIE5ESyBpbnN0YW5jZSBmb3VuZFwiKTtcbiAgICB0aGlzLm5kay5hc3NlcnRTaWduZXIoKSwgYXdhaXQgbmV3IHFlKHRoaXMubmRrLCB7XG4gICAgICBraW5kOiAwLFxuICAgICAgY29udGVudDogSlNPTi5zdHJpbmdpZnkodGhpcy5wcm9maWxlKVxuICAgIH0pLnB1Ymxpc2goKTtcbiAgfVxuICBhc3luYyBmb2xsb3codCwgZSkge1xuICAgIGlmICghdGhpcy5uZGspXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBOREsgaW5zdGFuY2UgZm91bmRcIik7XG4gICAgaWYgKHRoaXMubmRrLmFzc2VydFNpZ25lcigpLCBlIHx8IChlID0gYXdhaXQgdGhpcy5mb2xsb3dzKCkpLCBlLmhhcyh0KSlcbiAgICAgIHJldHVybiAhMTtcbiAgICBlLmFkZCh0KTtcbiAgICBjb25zdCByID0gbmV3IHFlKHRoaXMubmRrLCB7IGtpbmQ6IDMgfSk7XG4gICAgZm9yIChjb25zdCBuIG9mIGUpXG4gICAgICByLnRhZyhuKTtcbiAgICByZXR1cm4gYXdhaXQgci5wdWJsaXNoKCksICEwO1xuICB9XG59O1xuYXN5bmMgZnVuY3Rpb24geGQodCwgZSkge1xuICBpZiAoIWUpIHtcbiAgICBpZiAoIXRoaXMubmRrKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc2lnbmVyIGF2YWlsYWJsZVwiKTtcbiAgICBhd2FpdCB0aGlzLm5kay5hc3NlcnRTaWduZXIoKSwgZSA9IHRoaXMubmRrLnNpZ25lcjtcbiAgfVxuICBpZiAoIXQpIHtcbiAgICBjb25zdCByID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJwXCIpO1xuICAgIGlmIChyLmxlbmd0aCAhPT0gMSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHJlY2lwaWVudCBjb3VsZCBiZSBkZXRlcm1pbmVkIGFuZCBubyBleHBsaWNpdCByZWNpcGllbnQgd2FzIHByb3ZpZGVkXCIpO1xuICAgIHQgPSBuZXcgcGUoeyBoZXhwdWJrZXk6IHJbMF1bMV0gfSksIHQubmRrID0gdGhpcy5uZGs7XG4gIH1cbiAgdGhpcy5jb250ZW50ID0gYXdhaXQgZS5lbmNyeXB0KHQsIHRoaXMuY29udGVudCk7XG59XG5hc3luYyBmdW5jdGlvbiBFZCh0LCBlKSB7XG4gIGlmICghZSkge1xuICAgIGlmICghdGhpcy5uZGspXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBzaWduZXIgYXZhaWxhYmxlXCIpO1xuICAgIGF3YWl0IHRoaXMubmRrLmFzc2VydFNpZ25lcigpLCBlID0gdGhpcy5uZGsuc2lnbmVyO1xuICB9XG4gIHQgfHwgKHQgPSB0aGlzLmF1dGhvciksIHRoaXMuY29udGVudCA9IGF3YWl0IGUuZGVjcnlwdCh0LCB0aGlzLmNvbnRlbnQpO1xufVxuZnVuY3Rpb24ga2QoKSB7XG4gIHJldHVybiB0aGlzLmlzUGFyYW1SZXBsYWNlYWJsZSgpID8gd2UubmFkZHJFbmNvZGUoe1xuICAgIGtpbmQ6IHRoaXMua2luZCxcbiAgICBwdWJrZXk6IHRoaXMucHVia2V5LFxuICAgIGlkZW50aWZpZXI6IHRoaXMucmVwbGFjZWFibGVEVGFnKClcbiAgfSkgOiB3ZS5ub3RlRW5jb2RlKHRoaXMudGFnSWQoKSk7XG59XG5hc3luYyBmdW5jdGlvbiBTZCh0ID0gITAsIGUpIHtcbiAgaWYgKCFlKSB7XG4gICAgaWYgKCF0aGlzLm5kaylcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIE5ESyBpbnN0YW5jZSBmb3VuZFwiKTtcbiAgICB0aGlzLm5kay5hc3NlcnRTaWduZXIoKSwgZSA9IHRoaXMubmRrLnNpZ25lcjtcbiAgfVxuICBpZiAoIWUpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc2lnbmVyIGF2YWlsYWJsZVwiKTtcbiAgY29uc3QgciA9IGF3YWl0IGUudXNlcigpLCBuID0gbmV3IHFlKHRoaXMubmRrLCB7XG4gICAga2luZDogT2QodGhpcyksXG4gICAgY29udGVudDogXCJcIixcbiAgICBwdWJrZXk6IHIuaGV4cHVia2V5KClcbiAgfSk7XG4gIHJldHVybiBuLnRhZyh0aGlzKSwgbi5raW5kID09PSAxNiAmJiBuLnRhZ3MucHVzaChbXCJrXCIsIGAke3RoaXMua2luZH1gXSksIGF3YWl0IG4uc2lnbihlKSwgdCAmJiBhd2FpdCBuLnB1Ymxpc2goKSwgbjtcbn1cbmZ1bmN0aW9uIE9kKHQpIHtcbiAgcmV0dXJuIHQua2luZCA9PT0gMSA/IDYgOiAxNjtcbn1cbnZhciBxZSA9IGNsYXNzIGV4dGVuZHMgZHQge1xuICBjb25zdHJ1Y3RvcihlLCByKSB7XG4gICAgc3VwZXIoKTtcbiAgICBJKHRoaXMsIFwibmRrXCIpO1xuICAgIEkodGhpcywgXCJjcmVhdGVkX2F0XCIpO1xuICAgIEkodGhpcywgXCJjb250ZW50XCIsIFwiXCIpO1xuICAgIEkodGhpcywgXCJ0YWdzXCIsIFtdKTtcbiAgICBJKHRoaXMsIFwia2luZFwiKTtcbiAgICBJKHRoaXMsIFwiaWRcIiwgXCJcIik7XG4gICAgSSh0aGlzLCBcInNpZ1wiKTtcbiAgICBJKHRoaXMsIFwicHVia2V5XCIsIFwiXCIpO1xuICAgIEkodGhpcywgXCJyZWxheVwiKTtcbiAgICBJKHRoaXMsIFwiaXNSZXBsYWNlYWJsZVwiLCB2ZC5iaW5kKHRoaXMpKTtcbiAgICBJKHRoaXMsIFwiaXNQYXJhbVJlcGxhY2VhYmxlXCIsIHdkLmJpbmQodGhpcykpO1xuICAgIEkodGhpcywgXCJlbmNvZGVcIiwga2QuYmluZCh0aGlzKSk7XG4gICAgSSh0aGlzLCBcImVuY3J5cHRcIiwgeGQuYmluZCh0aGlzKSk7XG4gICAgSSh0aGlzLCBcImRlY3J5cHRcIiwgRWQuYmluZCh0aGlzKSk7XG4gICAgSSh0aGlzLCBcInJlcG9zdFwiLCBTZC5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLm5kayA9IGUsIHRoaXMuY3JlYXRlZF9hdCA9IHIgPT0gbnVsbCA/IHZvaWQgMCA6IHIuY3JlYXRlZF9hdCwgdGhpcy5jb250ZW50ID0gKHIgPT0gbnVsbCA/IHZvaWQgMCA6IHIuY29udGVudCkgfHwgXCJcIiwgdGhpcy50YWdzID0gKHIgPT0gbnVsbCA/IHZvaWQgMCA6IHIudGFncykgfHwgW10sIHRoaXMuaWQgPSAociA9PSBudWxsID8gdm9pZCAwIDogci5pZCkgfHwgXCJcIiwgdGhpcy5zaWcgPSByID09IG51bGwgPyB2b2lkIDAgOiByLnNpZywgdGhpcy5wdWJrZXkgPSAociA9PSBudWxsID8gdm9pZCAwIDogci5wdWJrZXkpIHx8IFwiXCIsIHRoaXMua2luZCA9IHIgPT0gbnVsbCA/IHZvaWQgMCA6IHIua2luZDtcbiAgfVxuICByYXdFdmVudCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY3JlYXRlZF9hdDogdGhpcy5jcmVhdGVkX2F0LFxuICAgICAgY29udGVudDogdGhpcy5jb250ZW50LFxuICAgICAgdGFnczogdGhpcy50YWdzLFxuICAgICAga2luZDogdGhpcy5raW5kLFxuICAgICAgcHVia2V5OiB0aGlzLnB1YmtleSxcbiAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgc2lnOiB0aGlzLnNpZ1xuICAgIH07XG4gIH1cbiAgc2V0IGF1dGhvcihlKSB7XG4gICAgdGhpcy5wdWJrZXkgPSBlLmhleHB1YmtleSgpO1xuICB9XG4gIGdldCBhdXRob3IoKSB7XG4gICAgY29uc3QgZSA9IG5ldyBwZSh7IGhleHB1YmtleTogdGhpcy5wdWJrZXkgfSk7XG4gICAgcmV0dXJuIGUubmRrID0gdGhpcy5uZGssIGU7XG4gIH1cbiAgdGFnKGUsIHIpIHtcbiAgICBjb25zdCBuID0gZS50YWdSZWZlcmVuY2UoKTtcbiAgICBpZiAociAmJiBuLnB1c2gociksIHRoaXMudGFncy5wdXNoKG4pLCBlIGluc3RhbmNlb2YgcWUpIHtcbiAgICAgIGNvbnN0IGkgPSBlLmF1dGhvcjtcbiAgICAgIGkgJiYgdGhpcy5wdWJrZXkgIT09IGkuaGV4cHVia2V5KCkgJiYgdGhpcy50YWcoaSk7XG4gICAgICBmb3IgKGNvbnN0IHMgb2YgZS5nZXRNYXRjaGluZ1RhZ3MoXCJwXCIpKVxuICAgICAgICBzWzFdICE9PSB0aGlzLnB1YmtleSAmJiAodGhpcy50YWdzLmZpbmQoKG8pID0+IG9bMF0gPT09IFwicFwiICYmIG9bMV0gPT09IHNbMV0pIHx8IHRoaXMudGFncy5wdXNoKFtcInBcIiwgc1sxXV0pKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgdG9Ob3N0ckV2ZW50KGUpIHtcbiAgICB2YXIgcywgbztcbiAgICBpZiAoIWUgJiYgdGhpcy5wdWJrZXkgPT09IFwiXCIpIHtcbiAgICAgIGNvbnN0IGEgPSBhd2FpdCAoKG8gPSAocyA9IHRoaXMubmRrKSA9PSBudWxsID8gdm9pZCAwIDogcy5zaWduZXIpID09IG51bGwgPyB2b2lkIDAgOiBvLnVzZXIoKSk7XG4gICAgICB0aGlzLnB1YmtleSA9IChhID09IG51bGwgPyB2b2lkIDAgOiBhLmhleHB1YmtleSgpKSB8fCBcIlwiO1xuICAgIH1cbiAgICB0aGlzLmNyZWF0ZWRfYXQgfHwgKHRoaXMuY3JlYXRlZF9hdCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDFlMykpO1xuICAgIGNvbnN0IHIgPSB0aGlzLnJhd0V2ZW50KCksIHsgY29udGVudDogbiwgdGFnczogaSB9ID0gdGhpcy5nZW5lcmF0ZVRhZ3MoKTtcbiAgICByLmNvbnRlbnQgPSBuIHx8IFwiXCIsIHIudGFncyA9IGk7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuaWQgPSBIcihyKTtcbiAgICB9IGNhdGNoIHtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaWQgJiYgKHIuaWQgPSB0aGlzLmlkKSwgdGhpcy5zaWcgJiYgKHIuc2lnID0gdGhpcy5zaWcpLCByO1xuICB9XG4gIGdldE1hdGNoaW5nVGFncyhlKSB7XG4gICAgcmV0dXJuIHRoaXMudGFncy5maWx0ZXIoKHIpID0+IHJbMF0gPT09IGUpO1xuICB9XG4gIHRhZ1ZhbHVlKGUpIHtcbiAgICBjb25zdCByID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoZSk7XG4gICAgaWYgKHIubGVuZ3RoICE9PSAwKVxuICAgICAgcmV0dXJuIHJbMF1bMV07XG4gIH1cbiAgcmVtb3ZlVGFnKGUpIHtcbiAgICB0aGlzLnRhZ3MgPSB0aGlzLnRhZ3MuZmlsdGVyKChyKSA9PiByWzBdICE9PSBlKTtcbiAgfVxuICBhc3luYyBzaWduKGUpIHtcbiAgICB2YXIgbjtcbiAgICBlIHx8ICgobiA9IHRoaXMubmRrKSA9PSBudWxsIHx8IG4uYXNzZXJ0U2lnbmVyKCksIGUgPSB0aGlzLm5kay5zaWduZXIpLCBhd2FpdCB0aGlzLmdlbmVyYXRlVGFncygpLCB0aGlzLmlzUmVwbGFjZWFibGUoKSAmJiAodGhpcy5jcmVhdGVkX2F0ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMWUzKSk7XG4gICAgY29uc3QgciA9IGF3YWl0IHRoaXMudG9Ob3N0ckV2ZW50KCk7XG4gICAgcmV0dXJuIHRoaXMuc2lnID0gYXdhaXQgZS5zaWduKHIpLCB0aGlzLnNpZztcbiAgfVxuICBhc3luYyBwdWJsaXNoKGUsIHIpIHtcbiAgICBpZiAodGhpcy5zaWcgfHwgYXdhaXQgdGhpcy5zaWduKCksICF0aGlzLm5kaylcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5ES0V2ZW50IG11c3QgYmUgYXNzb2NpYXRlZCB3aXRoIGFuIE5ESyBpbnN0YW5jZSB0byBwdWJsaXNoXCIpO1xuICAgIHJldHVybiB0aGlzLm5kay5wdWJsaXNoKHRoaXMsIGUsIHIpO1xuICB9XG4gIGdlbmVyYXRlVGFncygpIHtcbiAgICBsZXQgZSA9IFtdO1xuICAgIGNvbnN0IHIgPSBiZCh0aGlzLmNvbnRlbnQsIHRoaXMudGFncyksIG4gPSByLmNvbnRlbnQ7XG4gICAgaWYgKGUgPSByLnRhZ3MsIHRoaXMua2luZCAmJiB0aGlzLmtpbmQgPj0gM2U0ICYmIHRoaXMua2luZCA8PSA0ZTQgJiYgIXRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwiZFwiKVswXSkge1xuICAgICAgY29uc3QgcyA9IFsuLi5BcnJheSgxNildLm1hcCgoKSA9PiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KVsyXSkuam9pbihcIlwiKTtcbiAgICAgIGUucHVzaChbXCJkXCIsIHNdKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgY29udGVudDogbiB8fCBcIlwiLCB0YWdzOiBlIH07XG4gIH1cbiAgcmVwbGFjZWFibGVEVGFnKCkge1xuICAgIGlmICh0aGlzLmtpbmQgJiYgdGhpcy5raW5kID49IDNlNCAmJiB0aGlzLmtpbmQgPD0gNGU0KSB7XG4gICAgICBjb25zdCBlID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJkXCIpWzBdO1xuICAgICAgcmV0dXJuIGUgPyBlWzFdIDogXCJcIjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnQgaXMgbm90IGEgcGFyYW1ldGVyaXplZCByZXBsYWNlYWJsZSBldmVudFwiKTtcbiAgfVxuICB0YWdJZCgpIHtcbiAgICBpZiAodGhpcy5raW5kICYmIHRoaXMua2luZCA+PSAzZTQgJiYgdGhpcy5raW5kIDw9IDRlNCkge1xuICAgICAgY29uc3QgZSA9IHRoaXMucmVwbGFjZWFibGVEVGFnKCk7XG4gICAgICByZXR1cm4gYCR7dGhpcy5raW5kfToke3RoaXMucHVia2V5fToke2V9YDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaWQ7XG4gIH1cbiAgdGFnUmVmZXJlbmNlKCkge1xuICAgIHJldHVybiB0aGlzLmlzUGFyYW1SZXBsYWNlYWJsZSgpID8gW1wiYVwiLCB0aGlzLnRhZ0lkKCldIDogW1wiZVwiLCB0aGlzLnRhZ0lkKCldO1xuICB9XG4gIGZpbHRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1BhcmFtUmVwbGFjZWFibGUoKSA/IHsgXCIjYVwiOiBbdGhpcy50YWdJZCgpXSB9IDogeyBcIiNlXCI6IFt0aGlzLnRhZ0lkKCldIH07XG4gIH1cbiAgYXN5bmMgemFwKGUsIHIsIG4pIHtcbiAgICBpZiAoIXRoaXMubmRrKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gTkRLIGluc3RhbmNlIGZvdW5kXCIpO1xuICAgIHJldHVybiB0aGlzLm5kay5hc3NlcnRTaWduZXIoKSwgYXdhaXQgbmV3IGdkKHtcbiAgICAgIG5kazogdGhpcy5uZGssXG4gICAgICB6YXBwZWRFdmVudDogdGhpc1xuICAgIH0pLmNyZWF0ZVphcFJlcXVlc3QoZSwgciwgbik7XG4gIH1cbiAgYXN5bmMgZGVsZXRlKGUpIHtcbiAgICBpZiAoIXRoaXMubmRrKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gTkRLIGluc3RhbmNlIGZvdW5kXCIpO1xuICAgIHRoaXMubmRrLmFzc2VydFNpZ25lcigpO1xuICAgIGNvbnN0IHIgPSBuZXcgcWUodGhpcy5uZGssIHtcbiAgICAgIGtpbmQ6IDUsXG4gICAgICBjb250ZW50OiBlIHx8IFwiXCJcbiAgICB9KTtcbiAgICByZXR1cm4gci50YWcodGhpcyksIGF3YWl0IHIucHVibGlzaCgpLCByO1xuICB9XG59LCBBZCA9IGNsYXNzIGV4dGVuZHMgZHQge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgc3VwZXIoKTtcbiAgICBJKHRoaXMsIFwidXJsXCIpO1xuICAgIEkodGhpcywgXCJzY29yZXNcIik7XG4gICAgSSh0aGlzLCBcInJlbGF5XCIpO1xuICAgIEkodGhpcywgXCJfc3RhdHVzXCIpO1xuICAgIEkodGhpcywgXCJjb25uZWN0ZWRBdFwiKTtcbiAgICBJKHRoaXMsIFwiX2Nvbm5lY3Rpb25TdGF0c1wiLCB7IGF0dGVtcHRzOiAwLCBzdWNjZXNzOiAwLCBkdXJhdGlvbnM6IFtdIH0pO1xuICAgIEkodGhpcywgXCJjb21wbGFpbmluZ1wiLCAhMSk7XG4gICAgSSh0aGlzLCBcImRlYnVnXCIpO1xuICAgIEkodGhpcywgXCJhY3RpdmVTdWJzY3JpcHRpb25zXCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpO1xuICAgIEkodGhpcywgXCJ1cGRhdGVDb25uZWN0aW9uU3RhdHNcIiwge1xuICAgICAgY29ubmVjdGVkOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3Rpb25TdGF0cy5zdWNjZXNzKyssIHRoaXMuX2Nvbm5lY3Rpb25TdGF0cy5jb25uZWN0ZWRBdCA9IERhdGUubm93KCk7XG4gICAgICB9LFxuICAgICAgZGlzY29ubmVjdGVkOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3Rpb25TdGF0cy5jb25uZWN0ZWRBdCAmJiAodGhpcy5fY29ubmVjdGlvblN0YXRzLmR1cmF0aW9ucy5wdXNoKFxuICAgICAgICAgIERhdGUubm93KCkgLSB0aGlzLl9jb25uZWN0aW9uU3RhdHMuY29ubmVjdGVkQXRcbiAgICAgICAgKSwgdGhpcy5fY29ubmVjdGlvblN0YXRzLmR1cmF0aW9ucy5sZW5ndGggPiAxMDAgJiYgdGhpcy5fY29ubmVjdGlvblN0YXRzLmR1cmF0aW9ucy5zaGlmdCgpKSwgdGhpcy5fY29ubmVjdGlvblN0YXRzLmNvbm5lY3RlZEF0ID0gdm9pZCAwO1xuICAgICAgfSxcbiAgICAgIGF0dGVtcHQ6ICgpID0+IHtcbiAgICAgICAgdGhpcy5fY29ubmVjdGlvblN0YXRzLmF0dGVtcHRzKys7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy51cmwgPSBlLCB0aGlzLnJlbGF5ID0gQWYoZSksIHRoaXMuc2NvcmVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgdGhpcy5fc3RhdHVzID0gMywgdGhpcy5kZWJ1ZyA9IE1uKGBuZGs6cmVsYXk6JHtlfWApLCB0aGlzLnJlbGF5Lm9uKFwiY29ubmVjdFwiLCAoKSA9PiB7XG4gICAgICB0aGlzLnVwZGF0ZUNvbm5lY3Rpb25TdGF0cy5jb25uZWN0ZWQoKSwgdGhpcy5fc3RhdHVzID0gMSwgdGhpcy5lbWl0KFwiY29ubmVjdFwiKTtcbiAgICB9KSwgdGhpcy5yZWxheS5vbihcImRpc2Nvbm5lY3RcIiwgKCkgPT4ge1xuICAgICAgdGhpcy51cGRhdGVDb25uZWN0aW9uU3RhdHMuZGlzY29ubmVjdGVkKCksIHRoaXMuX3N0YXR1cyA9PT0gMSAmJiAodGhpcy5fc3RhdHVzID0gMywgdGhpcy5oYW5kbGVSZWNvbm5lY3Rpb24oKSksIHRoaXMuZW1pdChcImRpc2Nvbm5lY3RcIik7XG4gICAgfSksIHRoaXMucmVsYXkub24oXCJub3RpY2VcIiwgKHIpID0+IHRoaXMuaGFuZGxlTm90aWNlKHIpKTtcbiAgfVxuICBpc0ZsYXBwaW5nKCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLl9jb25uZWN0aW9uU3RhdHMuZHVyYXRpb25zO1xuICAgIGlmIChlLmxlbmd0aCA8IDEwKVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IG4gPSBlLnJlZHVjZSgoYSwgYykgPT4gYSArIGMsIDApIC8gZS5sZW5ndGgsIGkgPSBlLm1hcCgoYSkgPT4gTWF0aC5wb3coYSAtIG4sIDIpKS5yZWR1Y2UoKGEsIGMpID0+IGEgKyBjLCAwKSAvIGUubGVuZ3RoO1xuICAgIHJldHVybiBNYXRoLnNxcnQoaSkgPCAxZTM7XG4gIH1cbiAgaGFuZGxlUmVjb25uZWN0aW9uKCkge1xuICAgIHRoaXMuaXNGbGFwcGluZygpICYmICh0aGlzLmVtaXQoXCJmbGFwcGluZ1wiLCB0aGlzLCB0aGlzLl9jb25uZWN0aW9uU3RhdHMpLCB0aGlzLl9zdGF0dXMgPSA1KSwgdGhpcy5jb25uZWN0ZWRBdCAmJiBEYXRlLm5vdygpIC0gdGhpcy5jb25uZWN0ZWRBdCA8IDVlMyA/IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5jb25uZWN0KCksIDZlNCkgOiB0aGlzLmNvbm5lY3QoKTtcbiAgfVxuICBnZXQgc3RhdHVzKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0dXM7XG4gIH1cbiAgYXN5bmMgY29ubmVjdCgpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy51cGRhdGVDb25uZWN0aW9uU3RhdHMuYXR0ZW1wdCgpLCB0aGlzLl9zdGF0dXMgPSAwLCBhd2FpdCB0aGlzLnJlbGF5LmNvbm5lY3QoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyB0aGlzLmRlYnVnKFwiRmFpbGVkIHRvIGNvbm5lY3RcIiwgZSksIHRoaXMuX3N0YXR1cyA9IDMsIGU7XG4gICAgfVxuICB9XG4gIGRpc2Nvbm5lY3QoKSB7XG4gICAgdGhpcy5fc3RhdHVzID0gMiwgdGhpcy5yZWxheS5jbG9zZSgpO1xuICB9XG4gIGFzeW5jIGhhbmRsZU5vdGljZShlKSB7XG4gICAgKGUuaW5jbHVkZXMoXCJvbyBtYW55XCIpIHx8IGUuaW5jbHVkZXMoXCJheGltdW1cIikpICYmICh0aGlzLmRpc2Nvbm5lY3QoKSwgc2V0VGltZW91dCgoKSA9PiB0aGlzLmNvbm5lY3QoKSwgMmUzKSwgdGhpcy5kZWJ1Zyh0aGlzLnJlbGF5LnVybCwgXCJSZWxheSBjb21wbGFpbmluZz9cIiwgZSkpLCB0aGlzLmVtaXQoXCJub3RpY2VcIiwgdGhpcywgZSk7XG4gIH1cbiAgc3Vic2NyaWJlKGUpIHtcbiAgICBjb25zdCB7IGZpbHRlcjogciB9ID0gZSwgbiA9IHRoaXMucmVsYXkuc3ViKFtyXSwge1xuICAgICAgaWQ6IGUuc3ViSWRcbiAgICB9KTtcbiAgICB0aGlzLmRlYnVnKGBTdWJzY3JpYmVkIHRvICR7SlNPTi5zdHJpbmdpZnkocil9YCksIG4ub24oXCJldmVudFwiLCAocykgPT4ge1xuICAgICAgY29uc3QgbyA9IG5ldyBxZSh2b2lkIDAsIHMpO1xuICAgICAgby5yZWxheSA9IHRoaXMsIGUuZXZlbnRSZWNlaXZlZChvLCB0aGlzKTtcbiAgICB9KSwgbi5vbihcImVvc2VcIiwgKCkgPT4ge1xuICAgICAgZS5lb3NlUmVjZWl2ZWQodGhpcyk7XG4gICAgfSk7XG4gICAgY29uc3QgaSA9IG4udW5zdWI7XG4gICAgcmV0dXJuIG4udW5zdWIgPSAoKSA9PiB7XG4gICAgICB0aGlzLmRlYnVnKGBVbnN1YnNjcmliaW5nIGZyb20gJHtKU09OLnN0cmluZ2lmeShyKX1gKSwgdGhpcy5hY3RpdmVTdWJzY3JpcHRpb25zLmRlbGV0ZShlKSwgaSgpO1xuICAgIH0sIHRoaXMuYWN0aXZlU3Vic2NyaXB0aW9ucy5hZGQoZSksIGUub24oXCJjbG9zZVwiLCAoKSA9PiB7XG4gICAgICB0aGlzLmFjdGl2ZVN1YnNjcmlwdGlvbnMuZGVsZXRlKGUpO1xuICAgIH0pLCBuO1xuICB9XG4gIGFzeW5jIHB1Ymxpc2goZSwgciA9IDI1MDApIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09IDEgPyB0aGlzLnB1Ymxpc2hFdmVudChlLCByKSA6ICh0aGlzLm9uY2UoXCJjb25uZWN0XCIsICgpID0+IHtcbiAgICAgIHRoaXMucHVibGlzaEV2ZW50KGUsIHIpO1xuICAgIH0pLCAhMCk7XG4gIH1cbiAgYXN5bmMgcHVibGlzaEV2ZW50KGUsIHIpIHtcbiAgICBjb25zdCBuID0gYXdhaXQgZS50b05vc3RyRXZlbnQoKSwgaSA9IHRoaXMucmVsYXkucHVibGlzaChuKTtcbiAgICBsZXQgcztcbiAgICBjb25zdCBvID0gbmV3IFByb21pc2UoKGMsIGwpID0+IHtcbiAgICAgIGkub24oXCJmYWlsZWRcIiwgKGYpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHMpLCB0aGlzLmRlYnVnKFwiUHVibGlzaCBmYWlsZWRcIiwgZiwgZS5pZCksIHRoaXMuZW1pdChcInB1Ymxpc2g6ZmFpbGVkXCIsIGUsIGYpLCBsKGYpO1xuICAgICAgfSksIGkub24oXCJva1wiLCAoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dChzKSwgdGhpcy5lbWl0KFwicHVibGlzaGVkXCIsIGUpLCBjKCEwKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmICghcilcbiAgICAgIHJldHVybiBvO1xuICAgIGNvbnN0IGEgPSBuZXcgUHJvbWlzZSgoYywgbCkgPT4ge1xuICAgICAgcyA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLmRlYnVnKFwiUHVibGlzaCB0aW1lZCBvdXRcIiwgZS5yYXdFdmVudCgpKSwgdGhpcy5lbWl0KFwicHVibGlzaDpmYWlsZWRcIiwgZSwgXCJUaW1lb3V0XCIpLCBsKG5ldyBFcnJvcihcIlB1Ymxpc2ggb3BlcmF0aW9uIHRpbWVkIG91dFwiKSk7XG4gICAgICB9LCByKTtcbiAgICB9KTtcbiAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtvLCBhXSk7XG4gIH1cbiAgc2NvcmVTbG93ZXJFdmVudChlKSB7XG4gIH1cbiAgZ2V0IGNvbm5lY3Rpb25TdGF0cygpIHtcbiAgICByZXR1cm4gdGhpcy5fY29ubmVjdGlvblN0YXRzO1xuICB9XG4gIHRhZ1JlZmVyZW5jZShlKSB7XG4gICAgY29uc3QgciA9IFtcInJcIiwgdGhpcy5yZWxheS51cmxdO1xuICAgIHJldHVybiBlICYmIHIucHVzaChlKSwgcjtcbiAgfVxufSwgQ2QgPSBjbGFzcyBleHRlbmRzIGR0IHtcbiAgY29uc3RydWN0b3IoZSA9IFtdLCByKSB7XG4gICAgc3VwZXIoKTtcbiAgICBJKHRoaXMsIFwicmVsYXlzXCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICAgIEkodGhpcywgXCJkZWJ1Z1wiKTtcbiAgICB0aGlzLmRlYnVnID0gci5kZWJ1Zy5leHRlbmQoXCJwb29sXCIpO1xuICAgIGZvciAoY29uc3QgbiBvZiBlKSB7XG4gICAgICBjb25zdCBpID0gbmV3IEFkKG4pO1xuICAgICAgaS5vbihcIm5vdGljZVwiLCAocywgbykgPT4gdGhpcy5lbWl0KFwibm90aWNlXCIsIHMsIG8pKSwgaS5vbihcImNvbm5lY3RcIiwgKCkgPT4gdGhpcy5oYW5kbGVSZWxheUNvbm5lY3QobikpLCBpLm9uKFwiZGlzY29ubmVjdFwiLCAoKSA9PiB0aGlzLmVtaXQoXCJyZWxheTpkaXNjb25uZWN0XCIsIGkpKSwgaS5vbihcImZsYXBwaW5nXCIsICgpID0+IHRoaXMuaGFuZGxlRmxhcHBpbmcoaSkpLCB0aGlzLnJlbGF5cy5zZXQobiwgaSk7XG4gICAgfVxuICB9XG4gIGhhbmRsZVJlbGF5Q29ubmVjdChlKSB7XG4gICAgdGhpcy5kZWJ1ZyhgUmVsYXkgJHtlfSBjb25uZWN0ZWRgKSwgdGhpcy5lbWl0KFwicmVsYXk6Y29ubmVjdFwiLCB0aGlzLnJlbGF5cy5nZXQoZSkpLCB0aGlzLnN0YXRzKCkuY29ubmVjdGVkID09PSB0aGlzLnJlbGF5cy5zaXplICYmIHRoaXMuZW1pdChcImNvbm5lY3RcIik7XG4gIH1cbiAgYXN5bmMgY29ubmVjdChlKSB7XG4gICAgY29uc3QgciA9IFtdO1xuICAgIHRoaXMuZGVidWcoXG4gICAgICBgQ29ubmVjdGluZyB0byAke3RoaXMucmVsYXlzLnNpemV9IHJlbGF5cyR7ZSA/IGAsIHRpbWVvdXQgJHtlfS4uLmAgOiBcIlwifWBcbiAgICApO1xuICAgIGZvciAoY29uc3QgbiBvZiB0aGlzLnJlbGF5cy52YWx1ZXMoKSlcbiAgICAgIGlmIChlKSB7XG4gICAgICAgIGNvbnN0IGkgPSBuZXcgUHJvbWlzZSgocywgbykgPT4ge1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gbyhgVGltZWQgb3V0IGFmdGVyICR7ZX1tc2ApLCBlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHIucHVzaChcbiAgICAgICAgICBQcm9taXNlLnJhY2UoW24uY29ubmVjdCgpLCBpXSkuY2F0Y2goKHMpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGVidWcoYEZhaWxlZCB0byBjb25uZWN0IHRvIHJlbGF5ICR7bi51cmx9OiAke3N9YCk7XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICByLnB1c2gobi5jb25uZWN0KCkpO1xuICAgIGUgJiYgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBjb25zdCBuID0gdGhpcy5zdGF0cygpLmNvbm5lY3RlZCA9PT0gdGhpcy5yZWxheXMuc2l6ZSwgaSA9IHRoaXMuc3RhdHMoKS5jb25uZWN0ZWQgPiAwO1xuICAgICAgIW4gJiYgaSAmJiB0aGlzLmVtaXQoXCJjb25uZWN0XCIpO1xuICAgIH0sIGUpLCBhd2FpdCBQcm9taXNlLmFsbChyKTtcbiAgfVxuICBoYW5kbGVGbGFwcGluZyhlKSB7XG4gICAgdGhpcy5kZWJ1ZyhgUmVsYXkgJHtlLnVybH0gaXMgZmxhcHBpbmdgKSwgdGhpcy5yZWxheXMuZGVsZXRlKGUudXJsKSwgdGhpcy5lbWl0KFwiZmxhcHBpbmdcIiwgZSk7XG4gIH1cbiAgc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWxheXMuc2l6ZTtcbiAgfVxuICBzdGF0cygpIHtcbiAgICBjb25zdCBlID0ge1xuICAgICAgdG90YWw6IDAsXG4gICAgICBjb25uZWN0ZWQ6IDAsXG4gICAgICBkaXNjb25uZWN0ZWQ6IDAsXG4gICAgICBjb25uZWN0aW5nOiAwXG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IHIgb2YgdGhpcy5yZWxheXMudmFsdWVzKCkpXG4gICAgICBlLnRvdGFsKyssIHIuc3RhdHVzID09PSAxID8gZS5jb25uZWN0ZWQrKyA6IHIuc3RhdHVzID09PSAzID8gZS5kaXNjb25uZWN0ZWQrKyA6IHIuc3RhdHVzID09PSAwICYmIGUuY29ubmVjdGluZysrO1xuICAgIHJldHVybiBlO1xuICB9XG4gIHVybHMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5yZWxheXMua2V5cygpKTtcbiAgfVxufTtcbmZ1bmN0aW9uIElkKHQpIHtcbiAgcmV0dXJuICEhKFJkKHQuZmlsdGVyKSAmJiBUZCh0KSk7XG59XG5mdW5jdGlvbiBSZCh0KSB7XG4gIHJldHVybiAhIXQuaWRzO1xufVxuZnVuY3Rpb24gVGQodCkge1xuICBjb25zdCBlID0gdC5maWx0ZXIuaWRzO1xuICByZXR1cm4gISFlICYmIGUubGVuZ3RoID09PSB0LmV2ZW50Rmlyc3RTZWVuLnNpemU7XG59XG52YXIgUGQgPSB7XG4gIGNsb3NlT25Fb3NlOiAhMCxcbiAgY2FjaGVVc2FnZTogXCJDQUNIRV9GSVJTVFwiLFxuICBncm91cGFibGU6ICEwLFxuICBncm91cGFibGVEZWxheTogMTAwXG59LCBQYSA9IGNsYXNzIGV4dGVuZHMgZHQge1xuICBjb25zdHJ1Y3RvcihlLCByLCBuLCBpLCBzKSB7XG4gICAgc3VwZXIoKTtcbiAgICBJKHRoaXMsIFwic3ViSWRcIik7XG4gICAgSSh0aGlzLCBcImZpbHRlclwiKTtcbiAgICBJKHRoaXMsIFwib3B0c1wiKTtcbiAgICBJKHRoaXMsIFwicmVsYXlTZXRcIik7XG4gICAgSSh0aGlzLCBcIm5ka1wiKTtcbiAgICBJKHRoaXMsIFwicmVsYXlTdWJzY3JpcHRpb25zXCIpO1xuICAgIEkodGhpcywgXCJkZWJ1Z1wiKTtcbiAgICBJKHRoaXMsIFwiZXZlbnRGaXJzdFNlZW5cIiwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gICAgSSh0aGlzLCBcImVvc2VzU2VlblwiLCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKTtcbiAgICBJKHRoaXMsIFwiZXZlbnRzUGVyUmVsYXlcIiwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gICAgSSh0aGlzLCBcImVvc2VUaW1lb3V0XCIpO1xuICAgIGlmICh0aGlzLm5kayA9IGUsIHRoaXMub3B0cyA9IHsgLi4uUGQsIC4uLm4gfHwge30gfSwgdGhpcy5zdWJJZCA9IHMgfHwgKG4gPT0gbnVsbCA/IHZvaWQgMCA6IG4uc3ViSWQpIHx8IHFkKHIpLCB0aGlzLmZpbHRlciA9IHIsIHRoaXMucmVsYXlTZXQgPSBpLCB0aGlzLnJlbGF5U3Vic2NyaXB0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIHRoaXMuZGVidWcgPSBlLmRlYnVnLmV4dGVuZChgc3Vic2NyaXB0aW9uOiR7dGhpcy5zdWJJZH1gKSwgdGhpcy5vcHRzLmNhY2hlVXNhZ2UgPT09IFwiT05MWV9DQUNIRVwiICYmICF0aGlzLm9wdHMuY2xvc2VPbkVvc2UpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgdXNlIGNhY2hlLW9ubHkgb3B0aW9ucyB3aXRoIGEgcGVyc2lzdGVudCBzdWJzY3JpcHRpb25cIik7XG4gIH1cbiAgZ3JvdXBhYmxlSWQoKSB7XG4gICAgdmFyIGksIHM7XG4gICAgaWYgKCEoKGkgPSB0aGlzLm9wdHMpICE9IG51bGwgJiYgaS5ncm91cGFibGUpKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgZSA9ICgoKHMgPSB0aGlzLmZpbHRlci5raW5kcykgPT0gbnVsbCA/IHZvaWQgMCA6IHMubGVuZ3RoKSB8fCAwKSA+IDAsIHIgPSAhdGhpcy5maWx0ZXIuc2luY2UgJiYgIXRoaXMuZmlsdGVyLnVudGlsLCBuID0gIXRoaXMuZmlsdGVyLmxpbWl0O1xuICAgIGlmIChlICYmIHIgJiYgbikge1xuICAgICAgbGV0IG8gPSB0aGlzLmZpbHRlci5raW5kcy5qb2luKFwiLFwiKTtcbiAgICAgIGNvbnN0IGEgPSBPYmplY3Qua2V5cyh0aGlzLmZpbHRlciB8fCB7fSkuc29ydCgpLmpvaW4oXCItXCIpO1xuICAgICAgcmV0dXJuIG8gKz0gYC0ke2F9YCwgbztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgc2hvdWxkUXVlcnlDYWNoZSgpIHtcbiAgICB2YXIgZTtcbiAgICByZXR1cm4gKChlID0gdGhpcy5vcHRzKSA9PSBudWxsID8gdm9pZCAwIDogZS5jYWNoZVVzYWdlKSAhPT0gXCJPTkxZX1JFTEFZXCI7XG4gIH1cbiAgc2hvdWxkUXVlcnlSZWxheXMoKSB7XG4gICAgdmFyIGU7XG4gICAgcmV0dXJuICgoZSA9IHRoaXMub3B0cykgPT0gbnVsbCA/IHZvaWQgMCA6IGUuY2FjaGVVc2FnZSkgIT09IFwiT05MWV9DQUNIRVwiO1xuICB9XG4gIHNob3VsZFdhaXRGb3JDYWNoZSgpIHtcbiAgICB2YXIgZTtcbiAgICByZXR1cm4gdGhpcy5vcHRzLmNsb3NlT25Fb3NlICYmICEhKChlID0gdGhpcy5uZGsuY2FjaGVBZGFwdGVyKSAhPSBudWxsICYmIGUubG9ja2luZykgJiYgdGhpcy5zaG91bGRRdWVyeVJlbGF5cygpICYmIHRoaXMub3B0cy5jYWNoZVVzYWdlICE9PSBcIlBBUkFMTEVMXCI7XG4gIH1cbiAgYXN5bmMgc3RhcnQoKSB7XG4gICAgbGV0IGU7XG4gICAgaWYgKHRoaXMuc2hvdWxkUXVlcnlDYWNoZSgpICYmIChlID0gdGhpcy5zdGFydFdpdGhDYWNoZSgpLCB0aGlzLnNob3VsZFdhaXRGb3JDYWNoZSgpICYmIChhd2FpdCBlLCBJZCh0aGlzKSkpKSB7XG4gICAgICB0aGlzLmRlYnVnKFwiY2FjaGUgaGl0LCBmdWxseSBmaWxsZWQ6IHNraXBwaW5nIHJlbGF5IHF1ZXJ5XCIpLCB0aGlzLmVtaXQoXCJlb3NlXCIsIHRoaXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNob3VsZFF1ZXJ5UmVsYXlzKCkgJiYgdGhpcy5zdGFydFdpdGhSZWxheVNldCgpO1xuICB9XG4gIHN0b3AoKSB7XG4gICAgdGhpcy5yZWxheVN1YnNjcmlwdGlvbnMuZm9yRWFjaCgoZSkgPT4gZS51bnN1YigpKSwgdGhpcy5yZWxheVN1YnNjcmlwdGlvbnMuY2xlYXIoKSwgdGhpcy5lbWl0KFwiY2xvc2VcIiwgdGhpcyk7XG4gIH1cbiAgYXN5bmMgc3RhcnRXaXRoQ2FjaGUoKSB7XG4gICAgdmFyIGU7XG4gICAgaWYgKChlID0gdGhpcy5uZGsuY2FjaGVBZGFwdGVyKSAhPSBudWxsICYmIGUucXVlcnkpIHtcbiAgICAgIGNvbnN0IHIgPSB0aGlzLm5kay5jYWNoZUFkYXB0ZXIucXVlcnkodGhpcyk7XG4gICAgICB0aGlzLm5kay5jYWNoZUFkYXB0ZXIubG9ja2luZyAmJiBhd2FpdCByO1xuICAgIH1cbiAgfVxuICBzdGFydFdpdGhSZWxheVNldCgpIHtcbiAgICB0aGlzLnJlbGF5U2V0IHx8ICh0aGlzLnJlbGF5U2V0ID0gVWQodGhpcy5uZGssIHRoaXMuZmlsdGVyKSksIHRoaXMucmVsYXlTZXQgJiYgdGhpcy5yZWxheVNldC5zdWJzY3JpYmUodGhpcyk7XG4gIH1cbiAgZXZlbnRSZWNlaXZlZChlLCByLCBuID0gITEpIHtcbiAgICBpZiAoIW4gJiYgcikge1xuICAgICAgbGV0IGkgPSB0aGlzLmV2ZW50c1BlclJlbGF5LmdldChyKTtcbiAgICAgIGlmIChpIHx8IChpID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSwgdGhpcy5ldmVudHNQZXJSZWxheS5zZXQociwgaSkpLCBpLmFkZChlLmlkKSwgdGhpcy5ldmVudEZpcnN0U2Vlbi5oYXMoZS5pZCkpIHtcbiAgICAgICAgY29uc3QgbyA9IERhdGUubm93KCkgLSAodGhpcy5ldmVudEZpcnN0U2Vlbi5nZXQoZS5pZCkgfHwgMCk7XG4gICAgICAgIHIuc2NvcmVTbG93ZXJFdmVudChvKSwgdGhpcy5lbWl0KFwiZXZlbnQ6ZHVwXCIsIGUsIHIsIG8sIHRoaXMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLm5kay5jYWNoZUFkYXB0ZXIgJiYgdGhpcy5uZGsuY2FjaGVBZGFwdGVyLnNldEV2ZW50KGUsIHRoaXMuZmlsdGVyKSwgdGhpcy5ldmVudEZpcnN0U2Vlbi5zZXQoYCR7ZS5pZH1gLCBEYXRlLm5vdygpKTtcbiAgICB9IGVsc2VcbiAgICAgIHRoaXMuZXZlbnRGaXJzdFNlZW4uc2V0KGAke2UuaWR9YCwgMCk7XG4gICAgdGhpcy5lbWl0KFwiZXZlbnRcIiwgZSwgciwgdGhpcyk7XG4gIH1cbiAgZW9zZVJlY2VpdmVkKGUpIHtcbiAgICB2YXIgbiwgaSwgcztcbiAgICAobiA9IHRoaXMub3B0cykgIT0gbnVsbCAmJiBuLmNsb3NlT25Fb3NlICYmICgoaSA9IHRoaXMucmVsYXlTdWJzY3JpcHRpb25zLmdldChlKSkgPT0gbnVsbCB8fCBpLnVuc3ViKCksIHRoaXMucmVsYXlTdWJzY3JpcHRpb25zLmRlbGV0ZShlKSwgdGhpcy5yZWxheVN1YnNjcmlwdGlvbnMuc2l6ZSA9PT0gMCAmJiB0aGlzLmVtaXQoXCJjbG9zZVwiLCB0aGlzKSksIHRoaXMuZW9zZXNTZWVuLmFkZChlKSwgdGhpcy5lb3Nlc1NlZW4uc2l6ZSA9PT0gKChzID0gdGhpcy5yZWxheVNldCkgPT0gbnVsbCA/IHZvaWQgMCA6IHMuc2l6ZSgpKSA/IHRoaXMuZW1pdChcImVvc2VcIikgOiAodGhpcy5lb3NlVGltZW91dCAmJiBjbGVhclRpbWVvdXQodGhpcy5lb3NlVGltZW91dCksIHRoaXMuZW9zZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuZW1pdChcImVvc2VcIik7XG4gICAgfSwgNTAwKSk7XG4gIH1cbn0sIEJkID0gY2xhc3MgZXh0ZW5kcyBQYSB7XG4gIGNvbnN0cnVjdG9yKGUsIHIpIHtcbiAgICBjb25zdCBuID0gZS5kZWJ1Zy5leHRlbmQoXCJzdWJzY3JpcHRpb24tZ3JvdXBcIiksIGkgPSBMZChyLm1hcCgocykgPT4gcy5maWx0ZXIpKTtcbiAgICBzdXBlcihcbiAgICAgIGUsXG4gICAgICBpLFxuICAgICAgclswXS5vcHRzLFxuICAgICAgclswXS5yZWxheVNldFxuICAgICk7XG4gICAgSSh0aGlzLCBcInN1YnNjcmlwdGlvbnNcIik7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zID0gciwgbihcIm1lcmdlZCBmaWx0ZXJzXCIsIHtcbiAgICAgIGNvdW50OiByLmxlbmd0aCxcbiAgICAgIG1lcmdlZEZpbHRlcnM6IHRoaXMuZmlsdGVyXG4gICAgfSksIHRoaXMub24oXCJldmVudFwiLCB0aGlzLmZvcndhcmRFdmVudCksIHRoaXMub24oXCJldmVudDpkdXBcIiwgdGhpcy5mb3J3YXJkRXZlbnREdXApLCB0aGlzLm9uKFwiZW9zZVwiLCB0aGlzLmZvcndhcmRFb3NlKSwgdGhpcy5vbihcImNsb3NlXCIsIHRoaXMuZm9yd2FyZENsb3NlKTtcbiAgfVxuICBpc0V2ZW50Rm9yU3Vic2NyaXB0aW9uKGUsIHIpIHtcbiAgICBjb25zdCB7IGZpbHRlcjogbiB9ID0gcjtcbiAgICByZXR1cm4gbiA/IHlhKG4sIGUucmF3RXZlbnQoKSkgOiAhMTtcbiAgfVxuICBmb3J3YXJkRXZlbnQoZSwgcikge1xuICAgIGZvciAoY29uc3QgbiBvZiB0aGlzLnN1YnNjcmlwdGlvbnMpXG4gICAgICAhdGhpcy5pc0V2ZW50Rm9yU3Vic2NyaXB0aW9uKGUsIG4pIHx8IG4uZW1pdChcImV2ZW50XCIsIGUsIHIsIG4pO1xuICB9XG4gIGZvcndhcmRFdmVudER1cChlLCByLCBuKSB7XG4gICAgZm9yIChjb25zdCBpIG9mIHRoaXMuc3Vic2NyaXB0aW9ucylcbiAgICAgICF0aGlzLmlzRXZlbnRGb3JTdWJzY3JpcHRpb24oZSwgaSkgfHwgaS5lbWl0KFwiZXZlbnQ6ZHVwXCIsIGUsIHIsIG4sIGkpO1xuICB9XG4gIGZvcndhcmRFb3NlKCkge1xuICAgIGZvciAoY29uc3QgZSBvZiB0aGlzLnN1YnNjcmlwdGlvbnMpXG4gICAgICBlLmVtaXQoXCJlb3NlXCIsIGUpO1xuICB9XG4gIGZvcndhcmRDbG9zZSgpIHtcbiAgICBmb3IgKGNvbnN0IGUgb2YgdGhpcy5zdWJzY3JpcHRpb25zKVxuICAgICAgZS5lbWl0KFwiY2xvc2VcIiwgZSk7XG4gIH1cbn07XG5mdW5jdGlvbiBMZCh0KSB7XG4gIGNvbnN0IGUgPSB7fTtcbiAgcmV0dXJuIHQuZm9yRWFjaCgocikgPT4ge1xuICAgIE9iamVjdC5lbnRyaWVzKHIpLmZvckVhY2goKFtuLCBpXSkgPT4ge1xuICAgICAgQXJyYXkuaXNBcnJheShpKSA/IGVbbl0gPT09IHZvaWQgMCA/IGVbbl0gPSBbLi4uaV0gOiBlW25dID0gQXJyYXkuZnJvbSgvKiBAX19QVVJFX18gKi8gbmV3IFNldChbLi4uZVtuXSwgLi4uaV0pKSA6IGVbbl0gPSBpO1xuICAgIH0pO1xuICB9KSwgZTtcbn1cbmZ1bmN0aW9uICRkKHQpIHtcbiAgbGV0IGU7XG4gIHRyeSB7XG4gICAgc3dpdGNoIChlID0gd2UuZGVjb2RlKHQpLCBlLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJuZXZlbnRcIjpcbiAgICAgICAgcmV0dXJuIHsgaWRzOiBbZS5kYXRhLmlkXSB9O1xuICAgICAgY2FzZSBcIm5vdGVcIjpcbiAgICAgICAgcmV0dXJuIHsgaWRzOiBbZS5kYXRhXSB9O1xuICAgICAgY2FzZSBcIm5hZGRyXCI6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYXV0aG9yczogW2UuZGF0YS5wdWJrZXldLFxuICAgICAgICAgIFwiI2RcIjogW2UuZGF0YS5pZGVudGlmaWVyXSxcbiAgICAgICAgICBraW5kczogW2UuZGF0YS5raW5kXVxuICAgICAgICB9O1xuICAgIH1cbiAgfSBjYXRjaCB7XG4gIH1cbiAgcmV0dXJuIHsgaWRzOiBbdF0gfTtcbn1cbmZ1bmN0aW9uIHFkKHQpIHtcbiAgY29uc3QgZSA9IE9iamVjdC5rZXlzKHQpIHx8IFtdLCByID0gW107XG4gIGZvciAoY29uc3QgbiBvZiBlKVxuICAgIGlmIChuID09PSBcImtpbmRzXCIpIHtcbiAgICAgIGNvbnN0IGkgPSBbbiwgdC5raW5kcy5qb2luKFwiLFwiKV07XG4gICAgICByLnB1c2goaS5qb2luKFwiOlwiKSk7XG4gICAgfSBlbHNlXG4gICAgICByLnB1c2gobik7XG4gIHJldHVybiByLnB1c2goTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogOTk5OTk5OTk5KS50b1N0cmluZygpKSwgci5qb2luKFwiLVwiKTtcbn1cbnZhciBHciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IodCwgZSkge1xuICAgIEkodGhpcywgXCJyZWxheXNcIik7XG4gICAgSSh0aGlzLCBcImRlYnVnXCIpO1xuICAgIEkodGhpcywgXCJuZGtcIik7XG4gICAgdGhpcy5yZWxheXMgPSB0LCB0aGlzLm5kayA9IGUsIHRoaXMuZGVidWcgPSBlLmRlYnVnLmV4dGVuZChcInJlbGF5c2V0XCIpO1xuICB9XG4gIHN0YXRpYyBmcm9tUmVsYXlVcmxzKHQsIGUpIHtcbiAgICBjb25zdCByID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBmb3IgKGNvbnN0IG4gb2YgdCkge1xuICAgICAgY29uc3QgaSA9IGUucG9vbC5yZWxheXMuZ2V0KG4pO1xuICAgICAgaSAmJiByLmFkZChpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBHcihuZXcgU2V0KHIpLCBlKTtcbiAgfVxuICBzdWJzY3JpYmVPblJlbGF5KHQsIGUpIHtcbiAgICBjb25zdCByID0gdC5zdWJzY3JpYmUoZSk7XG4gICAgZS5yZWxheVN1YnNjcmlwdGlvbnMuc2V0KHQsIHIpO1xuICB9XG4gIGdldElkKCkge1xuICAgIGNvbnN0IGUgPSBBcnJheS5mcm9tKHRoaXMucmVsYXlzKS5tYXAoKHIpID0+IHIudXJsKS5zb3J0KCkuam9pbihcIixcIik7XG4gICAgcmV0dXJuIG5pKGpyKGUpKTtcbiAgfVxuICBzdWJzY3JpYmUodCkge1xuICAgIGNvbnN0IGUgPSB0Lmdyb3VwYWJsZUlkKCksIHIgPSBgJHt0aGlzLmdldElkKCl9OiR7ZX1gO1xuICAgIGlmICghZSlcbiAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVTdWJzY3JpcHRpb24odCksIHQ7XG4gICAgY29uc3QgbiA9IHRoaXMubmRrLmRlbGF5ZWRTdWJzY3JpcHRpb25zLmdldChyKTtcbiAgICByZXR1cm4gbiA/IG4ucHVzaCh0KSA6IChzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuZXhlY3V0ZURlbGF5ZWRTdWJzY3JpcHRpb24ocik7XG4gICAgfSwgdC5vcHRzLmdyb3VwYWJsZURlbGF5KSwgdGhpcy5uZGsuZGVsYXllZFN1YnNjcmlwdGlvbnMuc2V0KHIsIFt0XSkpLCB0O1xuICB9XG4gIGV4ZWN1dGVEZWxheWVkU3Vic2NyaXB0aW9uKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5uZGsuZGVsYXllZFN1YnNjcmlwdGlvbnMuZ2V0KHQpO1xuICAgIHRoaXMubmRrLmRlbGF5ZWRTdWJzY3JpcHRpb25zLmRlbGV0ZSh0KSwgZSAmJiAoZS5sZW5ndGggPiAxID8gdGhpcy5leGVjdXRlU3Vic2NyaXB0aW9ucyhlKSA6IHRoaXMuZXhlY3V0ZVN1YnNjcmlwdGlvbihlWzBdKSk7XG4gIH1cbiAgZXhlY3V0ZVN1YnNjcmlwdGlvbnModCkge1xuICAgIGNvbnN0IGUgPSB0WzBdLm5kaywgciA9IG5ldyBCZChlLCB0KTtcbiAgICB0aGlzLmV4ZWN1dGVTdWJzY3JpcHRpb24ocik7XG4gIH1cbiAgZXhlY3V0ZVN1YnNjcmlwdGlvbih0KSB7XG4gICAgdGhpcy5kZWJ1ZyhcInN1YnNjcmliaW5nXCIsIHsgZmlsdGVyOiB0LmZpbHRlciB9KTtcbiAgICBmb3IgKGNvbnN0IGUgb2YgdGhpcy5yZWxheXMpXG4gICAgICBpZiAoZS5zdGF0dXMgPT09IDEpXG4gICAgICAgIHRoaXMuc3Vic2NyaWJlT25SZWxheShlLCB0KTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBjb25zdCByID0gKCkgPT4ge1xuICAgICAgICAgIHRoaXMuZGVidWcoXCJuZXcgcmVsYXkgY29taW5nIG9ubGluZSBmb3IgYWN0aXZlIHN1YnNjcmlwdGlvblwiLCB7XG4gICAgICAgICAgICByZWxheTogZS51cmwsXG4gICAgICAgICAgICBmaWx0ZXI6IHQuZmlsdGVyXG4gICAgICAgICAgfSksIHRoaXMuc3Vic2NyaWJlT25SZWxheShlLCB0KTtcbiAgICAgICAgfTtcbiAgICAgICAgZS5vbmNlKFwiY29ubmVjdFwiLCByKSwgdC5vbmNlKFwiY2xvc2VcIiwgKCkgPT4ge1xuICAgICAgICAgIGUucmVtb3ZlTGlzdGVuZXIoXCJjb25uZWN0XCIsIHIpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICByZXR1cm4gdDtcbiAgfVxuICBhc3luYyBwdWJsaXNoKHQsIGUpIHtcbiAgICBjb25zdCByID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSwgbiA9IEFycmF5LmZyb20odGhpcy5yZWxheXMpLm1hcCgoaSkgPT4gbmV3IFByb21pc2UoKHMpID0+IHtcbiAgICAgIGkucHVibGlzaCh0LCBlKS50aGVuKCgpID0+IHtcbiAgICAgICAgci5hZGQoaSksIHMoKTtcbiAgICAgIH0pLmNhdGNoKChvKSA9PiB7XG4gICAgICAgIHRoaXMuZGVidWcoXCJlcnJvciBwdWJsaXNoaW5nIHRvIHJlbGF5XCIsIHsgcmVsYXk6IGkudXJsLCBlcnI6IG8gfSksIHMoKTtcbiAgICAgIH0pO1xuICAgIH0pKTtcbiAgICBpZiAoYXdhaXQgUHJvbWlzZS5hbGwobiksIHIuc2l6ZSA9PT0gMClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHJlbGF5IHdhcyBhYmxlIHRvIHJlY2VpdmUgdGhlIGV2ZW50XCIpO1xuICAgIHJldHVybiByO1xuICB9XG4gIHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVsYXlzLnNpemU7XG4gIH1cbn07XG5mdW5jdGlvbiBOZCh0LCBlKSB7XG4gIHZhciBuO1xuICBjb25zdCByID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgcmV0dXJuIChuID0gdC5wb29sKSA9PSBudWxsIHx8IG4ucmVsYXlzLmZvckVhY2goKGkpID0+IHIuYWRkKGkpKSwgbmV3IEdyKHIsIHQpO1xufVxuZnVuY3Rpb24gVWQodCwgZSkge1xuICB2YXIgbjtcbiAgY29uc3QgciA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIHJldHVybiAobiA9IHQucG9vbCkgPT0gbnVsbCB8fCBuLnJlbGF5cy5mb3JFYWNoKChpKSA9PiB7XG4gICAgaS5jb21wbGFpbmluZyA/IHQuZGVidWcoYFJlbGF5ICR7aS51cmx9IGlzIGNvbXBsYWluaW5nLCBub3QgYWRkaW5nIHRvIHNldGApIDogci5hZGQoaSk7XG4gIH0pLCBuZXcgR3IociwgdCk7XG59XG52YXIgamQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIEkodGhpcywgXCJfdXNlclByb21pc2VcIik7XG4gICAgSSh0aGlzLCBcIm5pcDA0UXVldWVcIiwgW10pO1xuICAgIEkodGhpcywgXCJuaXAwNFByb2Nlc3NpbmdcIiwgITEpO1xuICAgIEkodGhpcywgXCJkZWJ1Z1wiKTtcbiAgICBpZiAoIXdpbmRvdy5ub3N0cilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5JUC0wNyBleHRlbnNpb24gbm90IGF2YWlsYWJsZVwiKTtcbiAgICB0aGlzLmRlYnVnID0gTW4oXCJuZGs6bmlwMDdcIik7XG4gIH1cbiAgYXN5bmMgYmxvY2tVbnRpbFJlYWR5KCkge1xuICAgIHZhciBlO1xuICAgIGNvbnN0IHQgPSBhd2FpdCAoKGUgPSB3aW5kb3cubm9zdHIpID09IG51bGwgPyB2b2lkIDAgOiBlLmdldFB1YmxpY0tleSgpKTtcbiAgICBpZiAoIXQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVc2VyIHJlamVjdGVkIGFjY2Vzc1wiKTtcbiAgICByZXR1cm4gbmV3IHBlKHsgaGV4cHVia2V5OiB0IH0pO1xuICB9XG4gIGFzeW5jIHVzZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VzZXJQcm9taXNlIHx8ICh0aGlzLl91c2VyUHJvbWlzZSA9IHRoaXMuYmxvY2tVbnRpbFJlYWR5KCkpLCB0aGlzLl91c2VyUHJvbWlzZTtcbiAgfVxuICBhc3luYyBzaWduKHQpIHtcbiAgICBpZiAoIXdpbmRvdy5ub3N0cilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5JUC0wNyBleHRlbnNpb24gbm90IGF2YWlsYWJsZVwiKTtcbiAgICByZXR1cm4gKGF3YWl0IHdpbmRvdy5ub3N0ci5zaWduRXZlbnQodCkpLnNpZztcbiAgfVxuICBhc3luYyBlbmNyeXB0KHQsIGUpIHtcbiAgICBpZiAoIXdpbmRvdy5ub3N0cilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5JUC0wNyBleHRlbnNpb24gbm90IGF2YWlsYWJsZVwiKTtcbiAgICBjb25zdCByID0gdC5oZXhwdWJrZXkoKTtcbiAgICByZXR1cm4gdGhpcy5xdWV1ZU5pcDA0KFwiZW5jcnlwdFwiLCByLCBlKTtcbiAgfVxuICBhc3luYyBkZWNyeXB0KHQsIGUpIHtcbiAgICBpZiAoIXdpbmRvdy5ub3N0cilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5JUC0wNyBleHRlbnNpb24gbm90IGF2YWlsYWJsZVwiKTtcbiAgICBjb25zdCByID0gdC5oZXhwdWJrZXkoKTtcbiAgICByZXR1cm4gdGhpcy5xdWV1ZU5pcDA0KFwiZGVjcnlwdFwiLCByLCBlKTtcbiAgfVxuICBhc3luYyBxdWV1ZU5pcDA0KHQsIGUsIHIpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKG4sIGkpID0+IHtcbiAgICAgIHRoaXMubmlwMDRRdWV1ZS5wdXNoKHsgdHlwZTogdCwgY291bnRlcnBhcnR5SGV4cHVia2V5OiBlLCB2YWx1ZTogciwgcmVzb2x2ZTogbiwgcmVqZWN0OiBpIH0pLCB0aGlzLm5pcDA0UHJvY2Vzc2luZyB8fCB0aGlzLnByb2Nlc3NOaXAwNFF1ZXVlKCk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgcHJvY2Vzc05pcDA0UXVldWUodCwgZSA9IDApIHtcbiAgICBpZiAoIXQgJiYgdGhpcy5uaXAwNFF1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5uaXAwNFByb2Nlc3NpbmcgPSAhMTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5uaXAwNFByb2Nlc3NpbmcgPSAhMDtcbiAgICBjb25zdCB7IHR5cGU6IHIsIGNvdW50ZXJwYXJ0eUhleHB1YmtleTogbiwgdmFsdWU6IGksIHJlc29sdmU6IHMsIHJlamVjdDogbyB9ID0gdCB8fCB0aGlzLm5pcDA0UXVldWUuc2hpZnQoKTtcbiAgICB0aGlzLmRlYnVnKFwiUHJvY2Vzc2luZyBlbmNyeXB0aW9uIHF1ZXVlIGl0ZW1cIiwgeyB0eXBlOiByLCBjb3VudGVycGFydHlIZXhwdWJrZXk6IG4sIHZhbHVlOiBpIH0pO1xuICAgIHRyeSB7XG4gICAgICBsZXQgYTtcbiAgICAgIHIgPT09IFwiZW5jcnlwdFwiID8gYSA9IGF3YWl0IHdpbmRvdy5ub3N0ci5uaXAwNC5lbmNyeXB0KG4sIGkpIDogYSA9IGF3YWl0IHdpbmRvdy5ub3N0ci5uaXAwNC5kZWNyeXB0KG4sIGkpLCBzKGEpO1xuICAgIH0gY2F0Y2ggKGEpIHtcbiAgICAgIGlmIChhLm1lc3NhZ2UgJiYgYS5tZXNzYWdlLmluY2x1ZGVzKFwiY2FsbCBhbHJlYWR5IGV4ZWN1dGluZ1wiKSAmJiBlIDwgNSkge1xuICAgICAgICB0aGlzLmRlYnVnKFwiUmV0cnlpbmcgZW5jcnlwdGlvbiBxdWV1ZSBpdGVtXCIsIHsgdHlwZTogciwgY291bnRlcnBhcnR5SGV4cHVia2V5OiBuLCB2YWx1ZTogaSwgcmV0cmllczogZSB9KSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5wcm9jZXNzTmlwMDRRdWV1ZSh0LCBlICsgMSk7XG4gICAgICAgIH0sIDUwICogZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG8oYSk7XG4gICAgfVxuICAgIHRoaXMucHJvY2Vzc05pcDA0UXVldWUoKTtcbiAgfVxufSwgSGQgPSBjbGFzcyBleHRlbmRzIGR0IHtcbiAgY29uc3RydWN0b3IoZSwgciwgbikge1xuICAgIHN1cGVyKCk7XG4gICAgSSh0aGlzLCBcIm5ka1wiKTtcbiAgICBJKHRoaXMsIFwic2lnbmVyXCIpO1xuICAgIEkodGhpcywgXCJkZWJ1Z1wiKTtcbiAgICB0aGlzLm5kayA9IGUsIHRoaXMuc2lnbmVyID0gciwgdGhpcy5kZWJ1ZyA9IG4uZXh0ZW5kKFwicnBjXCIpO1xuICB9XG4gIGFzeW5jIHN1YnNjcmliZShlKSB7XG4gICAgY29uc3QgciA9IHRoaXMubmRrLnN1YnNjcmliZShlLCB7IGNsb3NlT25Fb3NlOiAhMSB9KTtcbiAgICByZXR1cm4gci5vbihcImV2ZW50XCIsIGFzeW5jIChuKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBpID0gYXdhaXQgdGhpcy5wYXJzZUV2ZW50KG4pO1xuICAgICAgICBpLm1ldGhvZCA/IHRoaXMuZW1pdChcInJlcXVlc3RcIiwgaSkgOiB0aGlzLmVtaXQoYHJlc3BvbnNlLSR7aS5pZH1gLCBpKTtcbiAgICAgIH0gY2F0Y2ggKGkpIHtcbiAgICAgICAgdGhpcy5kZWJ1ZyhcImVycm9yIHBhcnNpbmcgZXZlbnRcIiwgaSwgbik7XG4gICAgICB9XG4gICAgfSksIG5ldyBQcm9taXNlKChuLCBpKSA9PiB7XG4gICAgICByLm9uKFwiZW9zZVwiLCAoKSA9PiBuKHIpKTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBwYXJzZUV2ZW50KGUpIHtcbiAgICBjb25zdCByID0gdGhpcy5uZGsuZ2V0VXNlcih7IGhleHB1YmtleTogZS5wdWJrZXkgfSk7XG4gICAgci5uZGsgPSB0aGlzLm5kaztcbiAgICBjb25zdCBuID0gYXdhaXQgdGhpcy5zaWduZXIuZGVjcnlwdChyLCBlLmNvbnRlbnQpLCBpID0gSlNPTi5wYXJzZShuKSwgeyBpZDogcywgbWV0aG9kOiBvLCBwYXJhbXM6IGEsIHJlc3VsdDogYywgZXJyb3I6IGwgfSA9IGk7XG4gICAgcmV0dXJuIG8gPyB7IGlkOiBzLCBwdWJrZXk6IGUucHVia2V5LCBtZXRob2Q6IG8sIHBhcmFtczogYSwgZXZlbnQ6IGUgfSA6IHsgaWQ6IHMsIHJlc3VsdDogYywgZXJyb3I6IGwsIGV2ZW50OiBlIH07XG4gIH1cbiAgYXN5bmMgc2VuZFJlc3BvbnNlKGUsIHIsIG4sIGkgPSAyNDEzMywgcykge1xuICAgIGNvbnN0IG8gPSB7IGlkOiBlLCByZXN1bHQ6IG4gfTtcbiAgICBzICYmIChvLmVycm9yID0gcyk7XG4gICAgY29uc3QgYSA9IGF3YWl0IHRoaXMuc2lnbmVyLnVzZXIoKSwgYyA9IHRoaXMubmRrLmdldFVzZXIoeyBoZXhwdWJrZXk6IHIgfSksIGwgPSBuZXcgcWUodGhpcy5uZGssIHtcbiAgICAgIGtpbmQ6IGksXG4gICAgICBjb250ZW50OiBKU09OLnN0cmluZ2lmeShvKSxcbiAgICAgIHRhZ3M6IFtbXCJwXCIsIHJdXSxcbiAgICAgIHB1YmtleTogYS5oZXhwdWJrZXkoKVxuICAgIH0pO1xuICAgIGwuY29udGVudCA9IGF3YWl0IHRoaXMuc2lnbmVyLmVuY3J5cHQoYywgbC5jb250ZW50KSwgYXdhaXQgbC5zaWduKHRoaXMuc2lnbmVyKSwgYXdhaXQgdGhpcy5uZGsucHVibGlzaChsKTtcbiAgfVxuICBhc3luYyBzZW5kUmVxdWVzdChlLCByLCBuID0gW10sIGkgPSAyNDEzMywgcykge1xuICAgIGNvbnN0IG8gPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoNyksIGEgPSBhd2FpdCB0aGlzLnNpZ25lci51c2VyKCksIGMgPSB0aGlzLm5kay5nZXRVc2VyKHsgaGV4cHVia2V5OiBlIH0pLCBsID0geyBpZDogbywgbWV0aG9kOiByLCBwYXJhbXM6IG4gfSwgZiA9IG5ldyBQcm9taXNlKChoKSA9PiB7XG4gICAgICBzICYmIHRoaXMub25jZShgcmVzcG9uc2UtJHtvfWAsIHMpO1xuICAgIH0pLCB1ID0gbmV3IHFlKHRoaXMubmRrLCB7XG4gICAgICBraW5kOiBpLFxuICAgICAgY29udGVudDogSlNPTi5zdHJpbmdpZnkobCksXG4gICAgICB0YWdzOiBbW1wicFwiLCBlXV0sXG4gICAgICBwdWJrZXk6IGEuaGV4cHVia2V5KClcbiAgICB9KTtcbiAgICByZXR1cm4gdS5jb250ZW50ID0gYXdhaXQgdGhpcy5zaWduZXIuZW5jcnlwdChjLCB1LmNvbnRlbnQpLCBhd2FpdCB1LnNpZ24odGhpcy5zaWduZXIpLCB0aGlzLmRlYnVnKFwic2VuZGluZyByZXF1ZXN0IHRvXCIsIGUpLCBhd2FpdCB0aGlzLm5kay5wdWJsaXNoKHUpLCBmO1xuICB9XG59LCBNZCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IodCwgZSwgcikge1xuICAgIEkodGhpcywgXCJuZGtcIik7XG4gICAgSSh0aGlzLCBcInJlbW90ZVVzZXJcIik7XG4gICAgSSh0aGlzLCBcInJlbW90ZVB1YmtleVwiKTtcbiAgICBJKHRoaXMsIFwidG9rZW5cIik7XG4gICAgSSh0aGlzLCBcImxvY2FsU2lnbmVyXCIpO1xuICAgIEkodGhpcywgXCJycGNcIik7XG4gICAgSSh0aGlzLCBcImRlYnVnXCIpO1xuICAgIGxldCBuLCBpO1xuICAgIGlmIChlLmluY2x1ZGVzKFwiI1wiKSkge1xuICAgICAgY29uc3QgcyA9IGUuc3BsaXQoXCIjXCIpO1xuICAgICAgbiA9IG5ldyBwZSh7IG5wdWI6IHNbMF0gfSkuaGV4cHVia2V5KCksIGkgPSBzWzFdO1xuICAgIH0gZWxzZVxuICAgICAgZS5zdGFydHNXaXRoKFwibnB1YlwiKSA/IG4gPSBuZXcgcGUoeyBucHViOiBlIH0pLmhleHB1YmtleSgpIDogbiA9IGU7XG4gICAgdGhpcy5uZGsgPSB0LCB0aGlzLnJlbW90ZVB1YmtleSA9IG4sIHRoaXMudG9rZW4gPSBpLCB0aGlzLmRlYnVnID0gdC5kZWJ1Zy5leHRlbmQoXCJuaXA0NjpzaWduZXJcIiksIHRoaXMucmVtb3RlVXNlciA9IG5ldyBwZSh7IGhleHB1YmtleTogbiB9KSwgciA/IHRoaXMubG9jYWxTaWduZXIgPSByIDogdGhpcy5sb2NhbFNpZ25lciA9IG9yLmdlbmVyYXRlKCksIHRoaXMucnBjID0gbmV3IEhkKHQsIHRoaXMubG9jYWxTaWduZXIsIHRoaXMuZGVidWcpO1xuICB9XG4gIGFzeW5jIHVzZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVtb3RlVXNlcjtcbiAgfVxuICBhc3luYyBibG9ja1VudGlsUmVhZHkoKSB7XG4gICAgY29uc3QgdCA9IGF3YWl0IHRoaXMubG9jYWxTaWduZXIudXNlcigpLCBlID0gdGhpcy5uZGsuZ2V0VXNlcih7IG5wdWI6IHQubnB1YiB9KTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5ycGMuc3Vic2NyaWJlKHtcbiAgICAgIGtpbmRzOiBbMjQxMzNdLFxuICAgICAgXCIjcFwiOiBbdC5oZXhwdWJrZXkoKV1cbiAgICB9KSwgbmV3IFByb21pc2UoKHIsIG4pID0+IHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjb25zdCBpID0gW3QuaGV4cHVia2V5KCldO1xuICAgICAgICB0aGlzLnRva2VuICYmIGkucHVzaCh0aGlzLnRva2VuKSwgdGhpcy5ycGMuc2VuZFJlcXVlc3QoXG4gICAgICAgICAgdGhpcy5yZW1vdGVQdWJrZXksXG4gICAgICAgICAgXCJjb25uZWN0XCIsXG4gICAgICAgICAgaSxcbiAgICAgICAgICAyNDEzMyxcbiAgICAgICAgICAocykgPT4ge1xuICAgICAgICAgICAgcy5yZXN1bHQgPT09IFwiYWNrXCIgPyByKGUpIDogbihzLmVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICB9LCAxMDApO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGVuY3J5cHQodCwgZSkge1xuICAgIHJldHVybiB0aGlzLmRlYnVnKFwiYXNraW5nIGZvciBlbmNyeXB0aW9uXCIpLCBuZXcgUHJvbWlzZSgobiwgaSkgPT4ge1xuICAgICAgdGhpcy5ycGMuc2VuZFJlcXVlc3QoXG4gICAgICAgIHRoaXMucmVtb3RlUHVia2V5LFxuICAgICAgICBcIm5pcDA0X2VuY3J5cHRcIixcbiAgICAgICAgW3QuaGV4cHVia2V5KCksIGVdLFxuICAgICAgICAyNDEzMyxcbiAgICAgICAgKHMpID0+IHtcbiAgICAgICAgICBzLmVycm9yID8gaShzLmVycm9yKSA6IG4ocy5yZXN1bHQpO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGRlY3J5cHQodCwgZSkge1xuICAgIHJldHVybiB0aGlzLmRlYnVnKFwiYXNraW5nIGZvciBkZWNyeXB0aW9uXCIpLCBuZXcgUHJvbWlzZSgobiwgaSkgPT4ge1xuICAgICAgdGhpcy5ycGMuc2VuZFJlcXVlc3QoXG4gICAgICAgIHRoaXMucmVtb3RlUHVia2V5LFxuICAgICAgICBcIm5pcDA0X2RlY3J5cHRcIixcbiAgICAgICAgW3QuaGV4cHVia2V5KCksIGVdLFxuICAgICAgICAyNDEzMyxcbiAgICAgICAgKHMpID0+IHtcbiAgICAgICAgICBpZiAocy5lcnJvcilcbiAgICAgICAgICAgIGkocy5lcnJvcik7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBvID0gSlNPTi5wYXJzZShzLnJlc3VsdCk7XG4gICAgICAgICAgICBuKG9bMF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBzaWduKHQpIHtcbiAgICByZXR1cm4gdGhpcy5kZWJ1ZyhcImFza2luZyBmb3IgYSBzaWduYXR1cmVcIiksIG5ldyBQcm9taXNlKChyLCBuKSA9PiB7XG4gICAgICB0aGlzLnJwYy5zZW5kUmVxdWVzdChcbiAgICAgICAgdGhpcy5yZW1vdGVQdWJrZXksXG4gICAgICAgIFwic2lnbl9ldmVudFwiLFxuICAgICAgICBbSlNPTi5zdHJpbmdpZnkodCldLFxuICAgICAgICAyNDEzMyxcbiAgICAgICAgKGkpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5kZWJ1ZyhcImdvdCBhIHJlc3BvbnNlXCIsIGkpLCBpLmVycm9yKVxuICAgICAgICAgICAgbihpLmVycm9yKTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHMgPSBKU09OLnBhcnNlKGkucmVzdWx0KTtcbiAgICAgICAgICAgIHIocy5zaWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxufSwgb3IgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHQpIHtcbiAgICBJKHRoaXMsIFwiX3VzZXJcIik7XG4gICAgSSh0aGlzLCBcInByaXZhdGVLZXlcIik7XG4gICAgdCAmJiAodGhpcy5wcml2YXRlS2V5ID0gdCwgdGhpcy5fdXNlciA9IG5ldyBwZSh7IGhleHB1YmtleTogbGkodGhpcy5wcml2YXRlS2V5KSB9KSk7XG4gIH1cbiAgc3RhdGljIGdlbmVyYXRlKCkge1xuICAgIGNvbnN0IHQgPSB5ZigpO1xuICAgIHJldHVybiBuZXcgb3IodCk7XG4gIH1cbiAgYXN5bmMgYmxvY2tVbnRpbFJlYWR5KCkge1xuICAgIGlmICghdGhpcy5fdXNlcilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5ES1VzZXIgbm90IGluaXRpYWxpemVkXCIpO1xuICAgIHJldHVybiB0aGlzLl91c2VyO1xuICB9XG4gIGFzeW5jIHVzZXIoKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuYmxvY2tVbnRpbFJlYWR5KCksIHRoaXMuX3VzZXI7XG4gIH1cbiAgYXN5bmMgc2lnbih0KSB7XG4gICAgaWYgKCF0aGlzLnByaXZhdGVLZXkpXG4gICAgICB0aHJvdyBFcnJvcihcIkF0dGVtcHRlZCB0byBzaWduIHdpdGhvdXQgYSBwcml2YXRlIGtleVwiKTtcbiAgICByZXR1cm4gcGEodCwgdGhpcy5wcml2YXRlS2V5KTtcbiAgfVxuICBhc3luYyBlbmNyeXB0KHQsIGUpIHtcbiAgICBpZiAoIXRoaXMucHJpdmF0ZUtleSlcbiAgICAgIHRocm93IEVycm9yKFwiQXR0ZW1wdGVkIHRvIGVuY3J5cHQgd2l0aG91dCBhIHByaXZhdGUga2V5XCIpO1xuICAgIGNvbnN0IHIgPSB0LmhleHB1YmtleSgpO1xuICAgIHJldHVybiBhd2FpdCBVbi5lbmNyeXB0KHRoaXMucHJpdmF0ZUtleSwgciwgZSk7XG4gIH1cbiAgYXN5bmMgZGVjcnlwdCh0LCBlKSB7XG4gICAgaWYgKCF0aGlzLnByaXZhdGVLZXkpXG4gICAgICB0aHJvdyBFcnJvcihcIkF0dGVtcHRlZCB0byBkZWNyeXB0IHdpdGhvdXQgYSBwcml2YXRlIGtleVwiKTtcbiAgICBjb25zdCByID0gdC5oZXhwdWJrZXkoKTtcbiAgICByZXR1cm4gYXdhaXQgVW4uZGVjcnlwdCh0aGlzLnByaXZhdGVLZXksIHIsIGUpO1xuICB9XG59LCBEZCA9IGNsYXNzIGV4dGVuZHMgZHQge1xuICBjb25zdHJ1Y3RvcihlID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIEkodGhpcywgXCJwb29sXCIpO1xuICAgIEkodGhpcywgXCJzaWduZXJcIik7XG4gICAgSSh0aGlzLCBcImNhY2hlQWRhcHRlclwiKTtcbiAgICBJKHRoaXMsIFwiZGVidWdcIik7XG4gICAgSSh0aGlzLCBcImRldldyaXRlUmVsYXlTZXRcIik7XG4gICAgSSh0aGlzLCBcImRlbGF5ZWRTdWJzY3JpcHRpb25zXCIpO1xuICAgIHRoaXMuZGVidWcgPSBlLmRlYnVnIHx8IE1uKFwibmRrXCIpLCB0aGlzLnBvb2wgPSBuZXcgQ2QoZS5leHBsaWNpdFJlbGF5VXJscyB8fCBbXSwgdGhpcyksIHRoaXMuc2lnbmVyID0gZS5zaWduZXIsIHRoaXMuY2FjaGVBZGFwdGVyID0gZS5jYWNoZUFkYXB0ZXIsIHRoaXMuZGVsYXllZFN1YnNjcmlwdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCBlLmRldldyaXRlUmVsYXlVcmxzICYmICh0aGlzLmRldldyaXRlUmVsYXlTZXQgPSBHci5mcm9tUmVsYXlVcmxzKGUuZGV2V3JpdGVSZWxheVVybHMsIHRoaXMpKTtcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHsgcmVsYXlDb3VudDogdGhpcy5wb29sLnJlbGF5cy5zaXplIH0udG9TdHJpbmcoKTtcbiAgfVxuICBhc3luYyBjb25uZWN0KGUpIHtcbiAgICByZXR1cm4gdGhpcy5kZWJ1ZyhcIkNvbm5lY3RpbmcgdG8gcmVsYXlzXCIsIHsgdGltZW91dE1zOiBlIH0pLCB0aGlzLnBvb2wuY29ubmVjdChlKTtcbiAgfVxuICBnZXRVc2VyKGUpIHtcbiAgICBjb25zdCByID0gbmV3IHBlKGUpO1xuICAgIHJldHVybiByLm5kayA9IHRoaXMsIHI7XG4gIH1cbiAgc3Vic2NyaWJlKGUsIHIsIG4sIGkgPSAhMCkge1xuICAgIGNvbnN0IHMgPSBuZXcgUGEodGhpcywgZSwgciwgbik7XG4gICAgcmV0dXJuIGkgJiYgcy5zdGFydCgpLCBzO1xuICB9XG4gIGFzeW5jIHB1Ymxpc2goZSwgciwgbikge1xuICAgIHJldHVybiByIHx8IChyID0gdGhpcy5kZXZXcml0ZVJlbGF5U2V0IHx8IE5kKHRoaXMpKSwgci5wdWJsaXNoKGUsIG4pO1xuICB9XG4gIGFzeW5jIGZldGNoRXZlbnQoZSwgciA9IHt9LCBuKSB7XG4gICAgbGV0IGk7XG4gICAgaWYgKHR5cGVvZiBlID09IFwic3RyaW5nXCIgPyBpID0gJGQoZSkgOiBpID0gZSwgIWkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZmlsdGVyOiAke0pTT04uc3RyaW5naWZ5KGUpfWApO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocykgPT4ge1xuICAgICAgY29uc3QgbyA9IHRoaXMuc3Vic2NyaWJlKGksIHsgLi4uciwgY2xvc2VPbkVvc2U6ICEwIH0sIG4sICExKTtcbiAgICAgIG8ub24oXCJldmVudFwiLCAoYSkgPT4ge1xuICAgICAgICBhLm5kayA9IHRoaXMsIHMoYSk7XG4gICAgICB9KSwgby5vbihcImVvc2VcIiwgKCkgPT4ge1xuICAgICAgICBzKG51bGwpO1xuICAgICAgfSksIG8uc3RhcnQoKTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBmZXRjaEV2ZW50cyhlLCByID0ge30sIG4pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKGkpID0+IHtcbiAgICAgIGNvbnN0IHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCBvID0gdGhpcy5zdWJzY3JpYmUoZSwgeyAuLi5yLCBjbG9zZU9uRW9zZTogITAgfSwgbiwgITEpO1xuICAgICAgby5vbihcImV2ZW50XCIsIChhKSA9PiB7XG4gICAgICAgIGNvbnN0IGMgPSBzLmdldChhLnRhZ0lkKCkpO1xuICAgICAgICBjICYmIChhID0gcGQoYywgYSkpLCBhLm5kayA9IHRoaXMsIHMuc2V0KGEudGFnSWQoKSwgYSk7XG4gICAgICB9KSwgby5vbihcImVvc2VcIiwgKCkgPT4ge1xuICAgICAgICBpKG5ldyBTZXQocy52YWx1ZXMoKSkpO1xuICAgICAgfSksIG8uc3RhcnQoKTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBhc3NlcnRTaWduZXIoKSB7XG4gICAgaWYgKCF0aGlzLnNpZ25lcilcbiAgICAgIHRocm93IHRoaXMuZW1pdChcInNpZ25lclJlcXVpcmVkXCIpLCBuZXcgRXJyb3IoXCJTaWduZXIgcmVxdWlyZWRcIik7XG4gIH1cbn07XG5mdW5jdGlvbiB6ZCh0KSB7XG4gIGNvbnN0IGUgPSBHbyghMSksIFtyLCBuXSA9IFNuKHZvaWQgMCksIFtpLCBzXSA9IFNuKHZvaWQgMCk7XG4gIHVjKCgpID0+IHtcbiAgICBhc3luYyBmdW5jdGlvbiBmKCkge1xuICAgICAgciA9PT0gdm9pZCAwICYmIGUuY3VycmVudCA9PT0gITEgJiYgKGUuY3VycmVudCA9ICEwLCBhd2FpdCBvKHQpKTtcbiAgICB9XG4gICAgZigpO1xuICB9LCBbXSk7XG4gIGFzeW5jIGZ1bmN0aW9uIG8oZiwgdSkge1xuICAgIGNvbnN0IGggPSBuZXcgRGQoeyBleHBsaWNpdFJlbGF5VXJsczogZiwgc2lnbmVyOiB1IH0pO1xuICAgIHUgJiYgcyh1KTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgaC5jb25uZWN0KCksIG4oaCk7XG4gICAgfSBjYXRjaCAoZCkge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVSUk9SIGxvYWRpbmcgTkRLIE5ES0luc3RhbmNlXCIsIGQpO1xuICAgIH1cbiAgfVxuICBhc3luYyBmdW5jdGlvbiBhKGYpIHtcbiAgICBvKHQsIGYpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGMoZikge1xuICAgIHJldHVybiByID09PSB2b2lkIDAgPyBbXSA6IG5ldyBQcm9taXNlKCh1KSA9PiB7XG4gICAgICBjb25zdCBoID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgZCA9IHIuc3Vic2NyaWJlKGYsIHtcbiAgICAgICAgY2xvc2VPbkVvc2U6ICEwXG4gICAgICB9KTtcbiAgICAgIGQub24oXCJldmVudFwiLCAocCkgPT4ge1xuICAgICAgICBwLm5kayA9IHIsIGguc2V0KHAudGFnSWQoKSwgcCk7XG4gICAgICB9KSwgZC5vbihcImVvc2VcIiwgKCkgPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHUoQXJyYXkuZnJvbShuZXcgU2V0KGgudmFsdWVzKCkpKSksIDNlMyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBsKGYsIHUgPSB7XG4gICAgcmVwb3N0OiAhMSxcbiAgICBwdWJsaXNoOiAhMFxuICB9KSB7XG4gICAgaWYgKHIgIT09IHZvaWQgMClcbiAgICAgIHJldHVybiBmLm5kayA9IHIsIHUucmVwb3N0ID8gYXdhaXQgZi5yZXBvc3QoKSA6IGF3YWl0IGYuc2lnbigpLCB1LnB1Ymxpc2ggJiYgYXdhaXQgZi5wdWJsaXNoKCksIGY7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuZGs6IHIsXG4gICAgc2lnbmVyOiBpLFxuICAgIGxvYWROZGs6IG8sXG4gICAgc2V0U2lnbmVyOiBhLFxuICAgIGZldGNoRXZlbnRzOiBjLFxuICAgIHNpZ25QdWJsaXNoRXZlbnQ6IGxcbiAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIEZkKHQpIHtcbiAgdHJ5IHtcbiAgICBsZXQgZSA9IHQ7XG4gICAgZS5zdWJzdHJpbmcoMCwgNCkgPT09IFwibnNlY1wiICYmIChlID0gd2UuZGVjb2RlKGUpLmRhdGEpO1xuICAgIGNvbnN0IHIgPSBuZXcgb3IoZSk7XG4gICAgcmV0dXJuIHIudXNlcigpLnRoZW4oYXN5bmMgKG4pID0+IHtcbiAgICAgIGlmIChuLm5wdWIpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdXNlcjogbixcbiAgICAgICAgICBucHViOiBuLm5wdWIsXG4gICAgICAgICAgc2s6IGUsXG4gICAgICAgICAgc2lnbmVyOiByXG4gICAgICAgIH07XG4gICAgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBlO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBLZCh0LCBlLCByKSB7XG4gIHRyeSB7XG4gICAgbGV0IG4gPSBvci5nZW5lcmF0ZSgpO1xuICAgIHIgJiYgKG4gPSBuZXcgb3IocikpO1xuICAgIGNvbnN0IGkgPSBuZXcgTWQodCwgZSwgbik7XG4gICAgcmV0dXJuIGkudXNlcigpLnRoZW4oYXN5bmMgKHMpID0+IHtcbiAgICAgIGlmIChzLm5wdWIpXG4gICAgICAgIHJldHVybiBhd2FpdCBpLmJsb2NrVW50aWxSZWFkeSgpLCB7XG4gICAgICAgICAgdXNlcjogcyxcbiAgICAgICAgICBucHViOiAoYXdhaXQgaS51c2VyKCkpLm5wdWIsXG4gICAgICAgICAgc2s6IG4ucHJpdmF0ZUtleSxcbiAgICAgICAgICB0b2tlbjogZSxcbiAgICAgICAgICByZW1vdGVTaWduZXI6IGksXG4gICAgICAgICAgbG9jYWxTaWduZXI6IG5cbiAgICAgICAgfTtcbiAgICB9KTtcbiAgfSBjYXRjaCAobikge1xuICAgIHRocm93IG47XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIFdkKCkge1xuICB0cnkge1xuICAgIGNvbnN0IHQgPSBuZXcgamQoKTtcbiAgICByZXR1cm4gdC51c2VyKCkudGhlbihhc3luYyAoZSkgPT4ge1xuICAgICAgaWYgKGUubnB1YilcbiAgICAgICAgcmV0dXJuIHsgdXNlcjogZSwgbnB1YjogZS5ucHViLCBzaWduZXI6IHQgfTtcbiAgICB9KTtcbiAgfSBjYXRjaCAodCkge1xuICAgIHRocm93IHQ7XG4gIH1cbn1cbmNvbnN0IFZkID0gKHQpID0+IHtcbiAgY29uc3QgW2UsIHJdID0gU24oe30pLCBuID0gR28oe30pO1xuICBhc3luYyBmdW5jdGlvbiBpKGEpIHtcbiAgICBpZiAodCA9PSBudWxsIHx8IG4uY3VycmVudFthXSlcbiAgICAgIHJldHVybjtcbiAgICBuLmN1cnJlbnQgPSB7XG4gICAgICAuLi5uLmN1cnJlbnQsXG4gICAgICBbYV06IHBlLnByb3RvdHlwZVxuICAgIH07XG4gICAgbGV0IGM7XG4gICAgYS5zdGFydHNXaXRoKFwibnB1YlwiKSA/IGMgPSB0LmdldFVzZXIoe1xuICAgICAgbnB1YjogYVxuICAgIH0pIDogYyA9IHQuZ2V0VXNlcih7XG4gICAgICBoZXhwdWJrZXk6IGFcbiAgICB9KSwgYXdhaXQgYy5mZXRjaFByb2ZpbGUoKSwgYy5wcm9maWxlICYmIChuLmN1cnJlbnQgPSB7XG4gICAgICAuLi5uLmN1cnJlbnQsXG4gICAgICBbYV06IGNcbiAgICB9LCByKG4uY3VycmVudCkpO1xuICB9XG4gIGZ1bmN0aW9uIHMoYSkge1xuICAgIHJldHVybiBlW2FdID8gZVthXSA6IChpKGEpLCBwZS5wcm90b3R5cGUpO1xuICB9XG4gIGZ1bmN0aW9uIG8oYSkge1xuICAgIHJldHVybiBlW2FdID8gZVthXS5wcm9maWxlIDogKGkoYSksIHt9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGdldFVzZXI6IHMsXG4gICAgZ2V0UHJvZmlsZTogb1xuICB9O1xufTtcbnZhciBCYSA9IHsgZXhwb3J0czoge30gfSwgWHQgPSB7fTtcbi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbnZhciBNbztcbmZ1bmN0aW9uIEdkKCkge1xuICBpZiAoTW8pXG4gICAgcmV0dXJuIFh0O1xuICBNbyA9IDE7XG4gIHZhciB0ID0gVm8sIGUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZWxlbWVudFwiKSwgciA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSwgbiA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksIGkgPSB0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVELlJlYWN0Q3VycmVudE93bmVyLCBzID0geyBrZXk6ICEwLCByZWY6ICEwLCBfX3NlbGY6ICEwLCBfX3NvdXJjZTogITAgfTtcbiAgZnVuY3Rpb24gbyhhLCBjLCBsKSB7XG4gICAgdmFyIGYsIHUgPSB7fSwgaCA9IG51bGwsIGQgPSBudWxsO1xuICAgIGwgIT09IHZvaWQgMCAmJiAoaCA9IFwiXCIgKyBsKSwgYy5rZXkgIT09IHZvaWQgMCAmJiAoaCA9IFwiXCIgKyBjLmtleSksIGMucmVmICE9PSB2b2lkIDAgJiYgKGQgPSBjLnJlZik7XG4gICAgZm9yIChmIGluIGMpXG4gICAgICBuLmNhbGwoYywgZikgJiYgIXMuaGFzT3duUHJvcGVydHkoZikgJiYgKHVbZl0gPSBjW2ZdKTtcbiAgICBpZiAoYSAmJiBhLmRlZmF1bHRQcm9wcylcbiAgICAgIGZvciAoZiBpbiBjID0gYS5kZWZhdWx0UHJvcHMsIGMpXG4gICAgICAgIHVbZl0gPT09IHZvaWQgMCAmJiAodVtmXSA9IGNbZl0pO1xuICAgIHJldHVybiB7ICQkdHlwZW9mOiBlLCB0eXBlOiBhLCBrZXk6IGgsIHJlZjogZCwgcHJvcHM6IHUsIF9vd25lcjogaS5jdXJyZW50IH07XG4gIH1cbiAgcmV0dXJuIFh0LkZyYWdtZW50ID0gciwgWHQuanN4ID0gbywgWHQuanN4cyA9IG8sIFh0O1xufVxudmFyIFF0ID0ge307XG4vKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG52YXIgRG87XG5mdW5jdGlvbiBaZCgpIHtcbiAgcmV0dXJuIERvIHx8IChEbyA9IDEsIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdCA9IFZvLCBlID0gU3ltYm9sLmZvcihcInJlYWN0LmVsZW1lbnRcIiksIHIgPSBTeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpLCBuID0gU3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpLCBpID0gU3ltYm9sLmZvcihcInJlYWN0LnN0cmljdF9tb2RlXCIpLCBzID0gU3ltYm9sLmZvcihcInJlYWN0LnByb2ZpbGVyXCIpLCBvID0gU3ltYm9sLmZvcihcInJlYWN0LnByb3ZpZGVyXCIpLCBhID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnRleHRcIiksIGMgPSBTeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIiksIGwgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIiksIGYgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VfbGlzdFwiKSwgdSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vXCIpLCBoID0gU3ltYm9sLmZvcihcInJlYWN0LmxhenlcIiksIGQgPSBTeW1ib2wuZm9yKFwicmVhY3Qub2Zmc2NyZWVuXCIpLCBwID0gU3ltYm9sLml0ZXJhdG9yLCB5ID0gXCJAQGl0ZXJhdG9yXCI7XG4gICAgZnVuY3Rpb24gZyhiKSB7XG4gICAgICBpZiAoYiA9PT0gbnVsbCB8fCB0eXBlb2YgYiAhPSBcIm9iamVjdFwiKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBrID0gcCAmJiBiW3BdIHx8IGJbeV07XG4gICAgICByZXR1cm4gdHlwZW9mIGsgPT0gXCJmdW5jdGlvblwiID8gayA6IG51bGw7XG4gICAgfVxuICAgIHZhciB2ID0gdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcbiAgICBmdW5jdGlvbiBfKGIpIHtcbiAgICAgIHtcbiAgICAgICAgZm9yICh2YXIgayA9IGFyZ3VtZW50cy5sZW5ndGgsIFQgPSBuZXcgQXJyYXkoayA+IDEgPyBrIC0gMSA6IDApLCAkID0gMTsgJCA8IGs7ICQrKylcbiAgICAgICAgICBUWyQgLSAxXSA9IGFyZ3VtZW50c1skXTtcbiAgICAgICAgbShcImVycm9yXCIsIGIsIFQpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBtKGIsIGssIFQpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyICQgPSB2LlJlYWN0RGVidWdDdXJyZW50RnJhbWUsIE0gPSAkLmdldFN0YWNrQWRkZW5kdW0oKTtcbiAgICAgICAgTSAhPT0gXCJcIiAmJiAoayArPSBcIiVzXCIsIFQgPSBULmNvbmNhdChbTV0pKTtcbiAgICAgICAgdmFyIEsgPSBULm1hcChmdW5jdGlvbihqKSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyhqKTtcbiAgICAgICAgfSk7XG4gICAgICAgIEsudW5zaGlmdChcIldhcm5pbmc6IFwiICsgayksIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbYl0sIGNvbnNvbGUsIEspO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgQyA9ICExLCBPID0gITEsIHcgPSAhMSwgeCA9ICExLCBBID0gITEsIEI7XG4gICAgQiA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tb2R1bGUucmVmZXJlbmNlXCIpO1xuICAgIGZ1bmN0aW9uIEwoYikge1xuICAgICAgcmV0dXJuICEhKHR5cGVvZiBiID09IFwic3RyaW5nXCIgfHwgdHlwZW9mIGIgPT0gXCJmdW5jdGlvblwiIHx8IGIgPT09IG4gfHwgYiA9PT0gcyB8fCBBIHx8IGIgPT09IGkgfHwgYiA9PT0gbCB8fCBiID09PSBmIHx8IHggfHwgYiA9PT0gZCB8fCBDIHx8IE8gfHwgdyB8fCB0eXBlb2YgYiA9PSBcIm9iamVjdFwiICYmIGIgIT09IG51bGwgJiYgKGIuJCR0eXBlb2YgPT09IGggfHwgYi4kJHR5cGVvZiA9PT0gdSB8fCBiLiQkdHlwZW9mID09PSBvIHx8IGIuJCR0eXBlb2YgPT09IGEgfHwgYi4kJHR5cGVvZiA9PT0gYyB8fCBiLiQkdHlwZW9mID09PSBCIHx8IGIuZ2V0TW9kdWxlSWQgIT09IHZvaWQgMCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBQKGIsIGssIFQpIHtcbiAgICAgIHZhciAkID0gYi5kaXNwbGF5TmFtZTtcbiAgICAgIGlmICgkKVxuICAgICAgICByZXR1cm4gJDtcbiAgICAgIHZhciBNID0gay5kaXNwbGF5TmFtZSB8fCBrLm5hbWUgfHwgXCJcIjtcbiAgICAgIHJldHVybiBNICE9PSBcIlwiID8gVCArIFwiKFwiICsgTSArIFwiKVwiIDogVDtcbiAgICB9XG4gICAgZnVuY3Rpb24gRihiKSB7XG4gICAgICByZXR1cm4gYi5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24geihiKSB7XG4gICAgICBpZiAoYiA9PSBudWxsKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGlmICh0eXBlb2YgYi50YWcgPT0gXCJudW1iZXJcIiAmJiBfKFwiUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiksIHR5cGVvZiBiID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgcmV0dXJuIGIuZGlzcGxheU5hbWUgfHwgYi5uYW1lIHx8IG51bGw7XG4gICAgICBpZiAodHlwZW9mIGIgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgICBzd2l0Y2ggKGIpIHtcbiAgICAgICAgY2FzZSBuOlxuICAgICAgICAgIHJldHVybiBcIkZyYWdtZW50XCI7XG4gICAgICAgIGNhc2UgcjpcbiAgICAgICAgICByZXR1cm4gXCJQb3J0YWxcIjtcbiAgICAgICAgY2FzZSBzOlxuICAgICAgICAgIHJldHVybiBcIlByb2ZpbGVyXCI7XG4gICAgICAgIGNhc2UgaTpcbiAgICAgICAgICByZXR1cm4gXCJTdHJpY3RNb2RlXCI7XG4gICAgICAgIGNhc2UgbDpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZVwiO1xuICAgICAgICBjYXNlIGY6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VMaXN0XCI7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGIgPT0gXCJvYmplY3RcIilcbiAgICAgICAgc3dpdGNoIChiLiQkdHlwZW9mKSB7XG4gICAgICAgICAgY2FzZSBhOlxuICAgICAgICAgICAgdmFyIGsgPSBiO1xuICAgICAgICAgICAgcmV0dXJuIEYoaykgKyBcIi5Db25zdW1lclwiO1xuICAgICAgICAgIGNhc2UgbzpcbiAgICAgICAgICAgIHZhciBUID0gYjtcbiAgICAgICAgICAgIHJldHVybiBGKFQuX2NvbnRleHQpICsgXCIuUHJvdmlkZXJcIjtcbiAgICAgICAgICBjYXNlIGM6XG4gICAgICAgICAgICByZXR1cm4gUChiLCBiLnJlbmRlciwgXCJGb3J3YXJkUmVmXCIpO1xuICAgICAgICAgIGNhc2UgdTpcbiAgICAgICAgICAgIHZhciAkID0gYi5kaXNwbGF5TmFtZSB8fCBudWxsO1xuICAgICAgICAgICAgcmV0dXJuICQgIT09IG51bGwgPyAkIDogeihiLnR5cGUpIHx8IFwiTWVtb1wiO1xuICAgICAgICAgIGNhc2UgaDoge1xuICAgICAgICAgICAgdmFyIE0gPSBiLCBLID0gTS5fcGF5bG9hZCwgaiA9IE0uX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4geihqKEspKTtcbiAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgRyA9IE9iamVjdC5hc3NpZ24sIEUgPSAwLCBSLCBxLCBILCBELCBYLCBvZSwgcmU7XG4gICAgZnVuY3Rpb24gX2UoKSB7XG4gICAgfVxuICAgIF9lLl9fcmVhY3REaXNhYmxlZExvZyA9ICEwO1xuICAgIGZ1bmN0aW9uIE9lKCkge1xuICAgICAge1xuICAgICAgICBpZiAoRSA9PT0gMCkge1xuICAgICAgICAgIFIgPSBjb25zb2xlLmxvZywgcSA9IGNvbnNvbGUuaW5mbywgSCA9IGNvbnNvbGUud2FybiwgRCA9IGNvbnNvbGUuZXJyb3IsIFggPSBjb25zb2xlLmdyb3VwLCBvZSA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQsIHJlID0gY29uc29sZS5ncm91cEVuZDtcbiAgICAgICAgICB2YXIgYiA9IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgIHZhbHVlOiBfZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiAhMFxuICAgICAgICAgIH07XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICAgICAgaW5mbzogYixcbiAgICAgICAgICAgIGxvZzogYixcbiAgICAgICAgICAgIHdhcm46IGIsXG4gICAgICAgICAgICBlcnJvcjogYixcbiAgICAgICAgICAgIGdyb3VwOiBiLFxuICAgICAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IGIsXG4gICAgICAgICAgICBncm91cEVuZDogYlxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIEUrKztcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gVWUoKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChFLS0sIEUgPT09IDApIHtcbiAgICAgICAgICB2YXIgYiA9IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgIHdyaXRhYmxlOiAhMFxuICAgICAgICAgIH07XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICAgICAgbG9nOiBHKHt9LCBiLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBSXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGluZm86IEcoe30sIGIsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IHFcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgd2FybjogRyh7fSwgYiwge1xuICAgICAgICAgICAgICB2YWx1ZTogSFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBlcnJvcjogRyh7fSwgYiwge1xuICAgICAgICAgICAgICB2YWx1ZTogRFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBncm91cDogRyh7fSwgYiwge1xuICAgICAgICAgICAgICB2YWx1ZTogWFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBncm91cENvbGxhcHNlZDogRyh7fSwgYiwge1xuICAgICAgICAgICAgICB2YWx1ZTogb2VcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZ3JvdXBFbmQ6IEcoe30sIGIsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IHJlXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIEUgPCAwICYmIF8oXCJkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgUGUgPSB2LlJlYWN0Q3VycmVudERpc3BhdGNoZXIsIHllO1xuICAgIGZ1bmN0aW9uIGplKGIsIGssIFQpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKHllID09PSB2b2lkIDApXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfSBjYXRjaCAoTSkge1xuICAgICAgICAgICAgdmFyICQgPSBNLnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICAgICAgeWUgPSAkICYmICRbMV0gfHwgXCJcIjtcbiAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBgXG5gICsgeWUgKyBiO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgbWUgPSAhMSwgeGU7XG4gICAge1xuICAgICAgdmFyIGxyID0gdHlwZW9mIFdlYWtNYXAgPT0gXCJmdW5jdGlvblwiID8gV2Vha01hcCA6IE1hcDtcbiAgICAgIHhlID0gbmV3IGxyKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEJlKGIsIGspIHtcbiAgICAgIGlmICghYiB8fCBtZSlcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB7XG4gICAgICAgIHZhciBUID0geGUuZ2V0KGIpO1xuICAgICAgICBpZiAoVCAhPT0gdm9pZCAwKVxuICAgICAgICAgIHJldHVybiBUO1xuICAgICAgfVxuICAgICAgdmFyICQ7XG4gICAgICBtZSA9ICEwO1xuICAgICAgdmFyIE0gPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTtcbiAgICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdm9pZCAwO1xuICAgICAgdmFyIEs7XG4gICAgICBLID0gUGUuY3VycmVudCwgUGUuY3VycmVudCA9IG51bGwsIE9lKCk7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoaykge1xuICAgICAgICAgIHZhciBqID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eShqLnByb3RvdHlwZSwgXCJwcm9wc1wiLCB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLCB0eXBlb2YgUmVmbGVjdCA9PSBcIm9iamVjdFwiICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChqLCBbXSk7XG4gICAgICAgICAgICB9IGNhdGNoIChMZSkge1xuICAgICAgICAgICAgICAkID0gTGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChiLCBbXSwgaik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGouY2FsbCgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoTGUpIHtcbiAgICAgICAgICAgICAgJCA9IExlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYi5jYWxsKGoucHJvdG90eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfSBjYXRjaCAoTGUpIHtcbiAgICAgICAgICAgICQgPSBMZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYigpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChMZSkge1xuICAgICAgICBpZiAoTGUgJiYgJCAmJiB0eXBlb2YgTGUuc3RhY2sgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGZvciAodmFyIFUgPSBMZS5zdGFjay5zcGxpdChgXG5gKSwgc2UgPSAkLnN0YWNrLnNwbGl0KGBcbmApLCBXID0gVS5sZW5ndGggLSAxLCBaID0gc2UubGVuZ3RoIC0gMTsgVyA+PSAxICYmIFogPj0gMCAmJiBVW1ddICE9PSBzZVtaXTsgKVxuICAgICAgICAgICAgWi0tO1xuICAgICAgICAgIGZvciAoOyBXID49IDEgJiYgWiA+PSAwOyBXLS0sIFotLSlcbiAgICAgICAgICAgIGlmIChVW1ddICE9PSBzZVtaXSkge1xuICAgICAgICAgICAgICBpZiAoVyAhPT0gMSB8fCBaICE9PSAxKVxuICAgICAgICAgICAgICAgIGRvXG4gICAgICAgICAgICAgICAgICBpZiAoVy0tLCBaLS0sIFogPCAwIHx8IFVbV10gIT09IHNlW1pdKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBnZSA9IGBcbmAgKyBVW1ddLnJlcGxhY2UoXCIgYXQgbmV3IFwiLCBcIiBhdCBcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiLmRpc3BsYXlOYW1lICYmIGdlLmluY2x1ZGVzKFwiPGFub255bW91cz5cIikgJiYgKGdlID0gZ2UucmVwbGFjZShcIjxhbm9ueW1vdXM+XCIsIGIuZGlzcGxheU5hbWUpKSwgdHlwZW9mIGIgPT0gXCJmdW5jdGlvblwiICYmIHhlLnNldChiLCBnZSksIGdlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChXID49IDEgJiYgWiA+PSAwKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIG1lID0gITEsIFBlLmN1cnJlbnQgPSBLLCBVZSgpLCBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IE07XG4gICAgICB9XG4gICAgICB2YXIgeXQgPSBiID8gYi5kaXNwbGF5TmFtZSB8fCBiLm5hbWUgOiBcIlwiLCAkaSA9IHl0ID8gamUoeXQpIDogXCJcIjtcbiAgICAgIHJldHVybiB0eXBlb2YgYiA9PSBcImZ1bmN0aW9uXCIgJiYgeGUuc2V0KGIsICRpKSwgJGk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZlKGIsIGssIFQpIHtcbiAgICAgIHJldHVybiBCZShiLCAhMSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEhlKGIpIHtcbiAgICAgIHZhciBrID0gYi5wcm90b3R5cGU7XG4gICAgICByZXR1cm4gISEoayAmJiBrLmlzUmVhY3RDb21wb25lbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpdChiLCBrLCBUKSB7XG4gICAgICBpZiAoYiA9PSBudWxsKVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIGlmICh0eXBlb2YgYiA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHJldHVybiBCZShiLCBIZShiKSk7XG4gICAgICBpZiAodHlwZW9mIGIgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmV0dXJuIGplKGIpO1xuICAgICAgc3dpdGNoIChiKSB7XG4gICAgICAgIGNhc2UgbDpcbiAgICAgICAgICByZXR1cm4gamUoXCJTdXNwZW5zZVwiKTtcbiAgICAgICAgY2FzZSBmOlxuICAgICAgICAgIHJldHVybiBqZShcIlN1c3BlbnNlTGlzdFwiKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgYiA9PSBcIm9iamVjdFwiKVxuICAgICAgICBzd2l0Y2ggKGIuJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIGM6XG4gICAgICAgICAgICByZXR1cm4gZmUoYi5yZW5kZXIpO1xuICAgICAgICAgIGNhc2UgdTpcbiAgICAgICAgICAgIHJldHVybiBpdChiLnR5cGUsIGssIFQpO1xuICAgICAgICAgIGNhc2UgaDoge1xuICAgICAgICAgICAgdmFyICQgPSBiLCBNID0gJC5fcGF5bG9hZCwgSyA9ICQuX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gaXQoSyhNKSwgaywgVCk7XG4gICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICB2YXIgb3QgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LCBFaSA9IHt9LCBraSA9IHYuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICBmdW5jdGlvbiBmcihiKSB7XG4gICAgICBpZiAoYikge1xuICAgICAgICB2YXIgayA9IGIuX293bmVyLCBUID0gaXQoYi50eXBlLCBiLl9zb3VyY2UsIGsgPyBrLnR5cGUgOiBudWxsKTtcbiAgICAgICAga2kuc2V0RXh0cmFTdGFja0ZyYW1lKFQpO1xuICAgICAgfSBlbHNlXG4gICAgICAgIGtpLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gTWEoYiwgaywgVCwgJCwgTSkge1xuICAgICAge1xuICAgICAgICB2YXIgSyA9IEZ1bmN0aW9uLmNhbGwuYmluZChvdCk7XG4gICAgICAgIGZvciAodmFyIGogaW4gYilcbiAgICAgICAgICBpZiAoSyhiLCBqKSkge1xuICAgICAgICAgICAgdmFyIFUgPSB2b2lkIDA7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGJbal0gIT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlID0gRXJyb3IoKCQgfHwgXCJSZWFjdCBjbGFzc1wiKSArIFwiOiBcIiArIFQgKyBcIiB0eXBlIGBcIiArIGogKyBcImAgaXMgaW52YWxpZDsgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYFwiICsgdHlwZW9mIGJbal0gKyBcImAuVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuXCIpO1xuICAgICAgICAgICAgICAgIHRocm93IHNlLm5hbWUgPSBcIkludmFyaWFudCBWaW9sYXRpb25cIiwgc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgVSA9IGJbal0oaywgaiwgJCwgVCwgbnVsbCwgXCJTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRFwiKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKFcpIHtcbiAgICAgICAgICAgICAgVSA9IFc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBVICYmICEoVSBpbnN0YW5jZW9mIEVycm9yKSAmJiAoZnIoTSksIF8oXCIlczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciBmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCBzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuXCIsICQgfHwgXCJSZWFjdCBjbGFzc1wiLCBULCBqLCB0eXBlb2YgVSksIGZyKG51bGwpKSwgVSBpbnN0YW5jZW9mIEVycm9yICYmICEoVS5tZXNzYWdlIGluIEVpKSAmJiAoRWlbVS5tZXNzYWdlXSA9ICEwLCBmcihNKSwgXyhcIkZhaWxlZCAlcyB0eXBlOiAlc1wiLCBULCBVLm1lc3NhZ2UpLCBmcihudWxsKSk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgRGEgPSBBcnJheS5pc0FycmF5O1xuICAgIGZ1bmN0aW9uIFpyKGIpIHtcbiAgICAgIHJldHVybiBEYShiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gemEoYikge1xuICAgICAge1xuICAgICAgICB2YXIgayA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC50b1N0cmluZ1RhZywgVCA9IGsgJiYgYltTeW1ib2wudG9TdHJpbmdUYWddIHx8IGIuY29uc3RydWN0b3IubmFtZSB8fCBcIk9iamVjdFwiO1xuICAgICAgICByZXR1cm4gVDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gRmEoYikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIFNpKGIpLCAhMTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICByZXR1cm4gITA7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFNpKGIpIHtcbiAgICAgIHJldHVybiBcIlwiICsgYjtcbiAgICB9XG4gICAgZnVuY3Rpb24gT2koYikge1xuICAgICAgaWYgKEZhKGIpKVxuICAgICAgICByZXR1cm4gXyhcIlRoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4gVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIGJlZm9yZSB1c2luZyBpdCBoZXJlLlwiLCB6YShiKSksIFNpKGIpO1xuICAgIH1cbiAgICB2YXIgQ3QgPSB2LlJlYWN0Q3VycmVudE93bmVyLCBLYSA9IHtcbiAgICAgIGtleTogITAsXG4gICAgICByZWY6ICEwLFxuICAgICAgX19zZWxmOiAhMCxcbiAgICAgIF9fc291cmNlOiAhMFxuICAgIH0sIEFpLCBDaSwgWXI7XG4gICAgWXIgPSB7fTtcbiAgICBmdW5jdGlvbiBXYShiKSB7XG4gICAgICBpZiAob3QuY2FsbChiLCBcInJlZlwiKSkge1xuICAgICAgICB2YXIgayA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYiwgXCJyZWZcIikuZ2V0O1xuICAgICAgICBpZiAoayAmJiBrLmlzUmVhY3RXYXJuaW5nKVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiLnJlZiAhPT0gdm9pZCAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBWYShiKSB7XG4gICAgICBpZiAob3QuY2FsbChiLCBcImtleVwiKSkge1xuICAgICAgICB2YXIgayA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYiwgXCJrZXlcIikuZ2V0O1xuICAgICAgICBpZiAoayAmJiBrLmlzUmVhY3RXYXJuaW5nKVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiLmtleSAhPT0gdm9pZCAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBHYShiLCBrKSB7XG4gICAgICBpZiAodHlwZW9mIGIucmVmID09IFwic3RyaW5nXCIgJiYgQ3QuY3VycmVudCAmJiBrICYmIEN0LmN1cnJlbnQuc3RhdGVOb2RlICE9PSBrKSB7XG4gICAgICAgIHZhciBUID0geihDdC5jdXJyZW50LnR5cGUpO1xuICAgICAgICBZcltUXSB8fCAoXygnQ29tcG9uZW50IFwiJXNcIiBjb250YWlucyB0aGUgc3RyaW5nIHJlZiBcIiVzXCIuIFN1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiBXZSBhc2sgeW91IHRvIG1hbnVhbGx5IGZpeCB0aGlzIGNhc2UgYnkgdXNpbmcgdXNlUmVmKCkgb3IgY3JlYXRlUmVmKCkgaW5zdGVhZC4gTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIHooQ3QuY3VycmVudC50eXBlKSwgYi5yZWYpLCBZcltUXSA9ICEwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gWmEoYiwgaykge1xuICAgICAge1xuICAgICAgICB2YXIgVCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIEFpIHx8IChBaSA9ICEwLCBfKFwiJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSB2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50IHByb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcylcIiwgaykpO1xuICAgICAgICB9O1xuICAgICAgICBULmlzUmVhY3RXYXJuaW5nID0gITAsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiLCBcImtleVwiLCB7XG4gICAgICAgICAgZ2V0OiBULFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFlhKGIsIGspIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIFQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBDaSB8fCAoQ2kgPSAhMCwgXyhcIiVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgdmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCBwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpXCIsIGspKTtcbiAgICAgICAgfTtcbiAgICAgICAgVC5pc1JlYWN0V2FybmluZyA9ICEwLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoYiwgXCJyZWZcIiwge1xuICAgICAgICAgIGdldDogVCxcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgSmEgPSBmdW5jdGlvbihiLCBrLCBULCAkLCBNLCBLLCBqKSB7XG4gICAgICB2YXIgVSA9IHtcbiAgICAgICAgJCR0eXBlb2Y6IGUsXG4gICAgICAgIHR5cGU6IGIsXG4gICAgICAgIGtleTogayxcbiAgICAgICAgcmVmOiBULFxuICAgICAgICBwcm9wczogaixcbiAgICAgICAgX293bmVyOiBLXG4gICAgICB9O1xuICAgICAgcmV0dXJuIFUuX3N0b3JlID0ge30sIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVLl9zdG9yZSwgXCJ2YWxpZGF0ZWRcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICB2YWx1ZTogITFcbiAgICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoVSwgXCJfc2VsZlwiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITEsXG4gICAgICAgIHZhbHVlOiAkXG4gICAgICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KFUsIFwiX3NvdXJjZVwiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITEsXG4gICAgICAgIHZhbHVlOiBNXG4gICAgICB9KSwgT2JqZWN0LmZyZWV6ZSAmJiAoT2JqZWN0LmZyZWV6ZShVLnByb3BzKSwgT2JqZWN0LmZyZWV6ZShVKSksIFU7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBYYShiLCBrLCBULCAkLCBNKSB7XG4gICAgICB7XG4gICAgICAgIHZhciBLLCBqID0ge30sIFUgPSBudWxsLCBzZSA9IG51bGw7XG4gICAgICAgIFQgIT09IHZvaWQgMCAmJiAoT2koVCksIFUgPSBcIlwiICsgVCksIFZhKGspICYmIChPaShrLmtleSksIFUgPSBcIlwiICsgay5rZXkpLCBXYShrKSAmJiAoc2UgPSBrLnJlZiwgR2EoaywgTSkpO1xuICAgICAgICBmb3IgKEsgaW4gaylcbiAgICAgICAgICBvdC5jYWxsKGssIEspICYmICFLYS5oYXNPd25Qcm9wZXJ0eShLKSAmJiAoaltLXSA9IGtbS10pO1xuICAgICAgICBpZiAoYiAmJiBiLmRlZmF1bHRQcm9wcykge1xuICAgICAgICAgIHZhciBXID0gYi5kZWZhdWx0UHJvcHM7XG4gICAgICAgICAgZm9yIChLIGluIFcpXG4gICAgICAgICAgICBqW0tdID09PSB2b2lkIDAgJiYgKGpbS10gPSBXW0tdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoVSB8fCBzZSkge1xuICAgICAgICAgIHZhciBaID0gdHlwZW9mIGIgPT0gXCJmdW5jdGlvblwiID8gYi5kaXNwbGF5TmFtZSB8fCBiLm5hbWUgfHwgXCJVbmtub3duXCIgOiBiO1xuICAgICAgICAgIFUgJiYgWmEoaiwgWiksIHNlICYmIFlhKGosIFopO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBKYShiLCBVLCBzZSwgTSwgJCwgQ3QuY3VycmVudCwgaik7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBKciA9IHYuUmVhY3RDdXJyZW50T3duZXIsIElpID0gdi5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIGZ1bmN0aW9uIHB0KGIpIHtcbiAgICAgIGlmIChiKSB7XG4gICAgICAgIHZhciBrID0gYi5fb3duZXIsIFQgPSBpdChiLnR5cGUsIGIuX3NvdXJjZSwgayA/IGsudHlwZSA6IG51bGwpO1xuICAgICAgICBJaS5zZXRFeHRyYVN0YWNrRnJhbWUoVCk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgSWkuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgICB2YXIgWHI7XG4gICAgWHIgPSAhMTtcbiAgICBmdW5jdGlvbiBRcihiKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIGIgPT0gXCJvYmplY3RcIiAmJiBiICE9PSBudWxsICYmIGIuJCR0eXBlb2YgPT09IGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJpKCkge1xuICAgICAge1xuICAgICAgICBpZiAoSnIuY3VycmVudCkge1xuICAgICAgICAgIHZhciBiID0geihKci5jdXJyZW50LnR5cGUpO1xuICAgICAgICAgIGlmIChiKVxuICAgICAgICAgICAgcmV0dXJuIGBcblxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgXFxgYCArIGIgKyBcImAuXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFFhKGIpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKGIgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHZhciBrID0gYi5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCBcIlwiKSwgVCA9IGIubGluZU51bWJlcjtcbiAgICAgICAgICByZXR1cm4gYFxuXG5DaGVjayB5b3VyIGNvZGUgYXQgYCArIGsgKyBcIjpcIiArIFQgKyBcIi5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIFRpID0ge307XG4gICAgZnVuY3Rpb24gZWMoYikge1xuICAgICAge1xuICAgICAgICB2YXIgayA9IFJpKCk7XG4gICAgICAgIGlmICghaykge1xuICAgICAgICAgIHZhciBUID0gdHlwZW9mIGIgPT0gXCJzdHJpbmdcIiA/IGIgOiBiLmRpc3BsYXlOYW1lIHx8IGIubmFtZTtcbiAgICAgICAgICBUICYmIChrID0gYFxuXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxgICsgVCArIFwiPi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGs7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFBpKGIsIGspIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKCFiLl9zdG9yZSB8fCBiLl9zdG9yZS52YWxpZGF0ZWQgfHwgYi5rZXkgIT0gbnVsbClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGIuX3N0b3JlLnZhbGlkYXRlZCA9ICEwO1xuICAgICAgICB2YXIgVCA9IGVjKGspO1xuICAgICAgICBpZiAoVGlbVF0pXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBUaVtUXSA9ICEwO1xuICAgICAgICB2YXIgJCA9IFwiXCI7XG4gICAgICAgIGIgJiYgYi5fb3duZXIgJiYgYi5fb3duZXIgIT09IEpyLmN1cnJlbnQgJiYgKCQgPSBcIiBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSBcIiArIHooYi5fb3duZXIudHlwZSkgKyBcIi5cIiksIHB0KGIpLCBfKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3dhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCBULCAkKSwgcHQobnVsbCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIEJpKGIsIGspIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9IFwib2JqZWN0XCIpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoWnIoYikpXG4gICAgICAgICAgZm9yICh2YXIgVCA9IDA7IFQgPCBiLmxlbmd0aDsgVCsrKSB7XG4gICAgICAgICAgICB2YXIgJCA9IGJbVF07XG4gICAgICAgICAgICBRcigkKSAmJiBQaSgkLCBrKTtcbiAgICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFFyKGIpKVxuICAgICAgICAgIGIuX3N0b3JlICYmIChiLl9zdG9yZS52YWxpZGF0ZWQgPSAhMCk7XG4gICAgICAgIGVsc2UgaWYgKGIpIHtcbiAgICAgICAgICB2YXIgTSA9IGcoYik7XG4gICAgICAgICAgaWYgKHR5cGVvZiBNID09IFwiZnVuY3Rpb25cIiAmJiBNICE9PSBiLmVudHJpZXMpXG4gICAgICAgICAgICBmb3IgKHZhciBLID0gTS5jYWxsKGIpLCBqOyAhKGogPSBLLm5leHQoKSkuZG9uZTsgKVxuICAgICAgICAgICAgICBRcihqLnZhbHVlKSAmJiBQaShqLnZhbHVlLCBrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0YyhiKSB7XG4gICAgICB7XG4gICAgICAgIHZhciBrID0gYi50eXBlO1xuICAgICAgICBpZiAoayA9PSBudWxsIHx8IHR5cGVvZiBrID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgVDtcbiAgICAgICAgaWYgKHR5cGVvZiBrID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICBUID0gay5wcm9wVHlwZXM7XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBrID09IFwib2JqZWN0XCIgJiYgKGsuJCR0eXBlb2YgPT09IGMgfHwgay4kJHR5cGVvZiA9PT0gdSkpXG4gICAgICAgICAgVCA9IGsucHJvcFR5cGVzO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoVCkge1xuICAgICAgICAgIHZhciAkID0geihrKTtcbiAgICAgICAgICBNYShULCBiLnByb3BzLCBcInByb3BcIiwgJCwgYik7XG4gICAgICAgIH0gZWxzZSBpZiAoay5Qcm9wVHlwZXMgIT09IHZvaWQgMCAmJiAhWHIpIHtcbiAgICAgICAgICBYciA9ICEwO1xuICAgICAgICAgIHZhciBNID0geihrKTtcbiAgICAgICAgICBfKFwiQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/XCIsIE0gfHwgXCJVbmtub3duXCIpO1xuICAgICAgICB9XG4gICAgICAgIHR5cGVvZiBrLmdldERlZmF1bHRQcm9wcyA9PSBcImZ1bmN0aW9uXCIgJiYgIWsuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkICYmIF8oXCJnZXREZWZhdWx0UHJvcHMgaXMgb25seSB1c2VkIG9uIGNsYXNzaWMgUmVhY3QuY3JlYXRlQ2xhc3MgZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLlwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmMoYikge1xuICAgICAge1xuICAgICAgICBmb3IgKHZhciBrID0gT2JqZWN0LmtleXMoYi5wcm9wcyksIFQgPSAwOyBUIDwgay5sZW5ndGg7IFQrKykge1xuICAgICAgICAgIHZhciAkID0ga1tUXTtcbiAgICAgICAgICBpZiAoJCAhPT0gXCJjaGlsZHJlblwiICYmICQgIT09IFwia2V5XCIpIHtcbiAgICAgICAgICAgIHB0KGIpLCBfKFwiSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gUmVhY3QuRnJhZ21lbnQgY2FuIG9ubHkgaGF2ZSBga2V5YCBhbmQgYGNoaWxkcmVuYCBwcm9wcy5cIiwgJCksIHB0KG51bGwpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGIucmVmICE9PSBudWxsICYmIChwdChiKSwgXyhcIkludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuXCIpLCBwdChudWxsKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIExpKGIsIGssIFQsICQsIE0sIEspIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIGogPSBMKGIpO1xuICAgICAgICBpZiAoIWopIHtcbiAgICAgICAgICB2YXIgVSA9IFwiXCI7XG4gICAgICAgICAgKGIgPT09IHZvaWQgMCB8fCB0eXBlb2YgYiA9PSBcIm9iamVjdFwiICYmIGIgIT09IG51bGwgJiYgT2JqZWN0LmtleXMoYikubGVuZ3RoID09PSAwKSAmJiAoVSArPSBcIiBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSBpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCIpO1xuICAgICAgICAgIHZhciBzZSA9IFFhKE0pO1xuICAgICAgICAgIHNlID8gVSArPSBzZSA6IFUgKz0gUmkoKTtcbiAgICAgICAgICB2YXIgVztcbiAgICAgICAgICBiID09PSBudWxsID8gVyA9IFwibnVsbFwiIDogWnIoYikgPyBXID0gXCJhcnJheVwiIDogYiAhPT0gdm9pZCAwICYmIGIuJCR0eXBlb2YgPT09IGUgPyAoVyA9IFwiPFwiICsgKHooYi50eXBlKSB8fCBcIlVua25vd25cIikgKyBcIiAvPlwiLCBVID0gXCIgRGlkIHlvdSBhY2NpZGVudGFsbHkgZXhwb3J0IGEgSlNYIGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNvbXBvbmVudD9cIikgOiBXID0gdHlwZW9mIGIsIF8oXCJSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yIGJ1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXNcIiwgVywgVSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIFogPSBYYShiLCBrLCBULCBNLCBLKTtcbiAgICAgICAgaWYgKFogPT0gbnVsbClcbiAgICAgICAgICByZXR1cm4gWjtcbiAgICAgICAgaWYgKGopIHtcbiAgICAgICAgICB2YXIgZ2UgPSBrLmNoaWxkcmVuO1xuICAgICAgICAgIGlmIChnZSAhPT0gdm9pZCAwKVxuICAgICAgICAgICAgaWYgKCQpXG4gICAgICAgICAgICAgIGlmIChacihnZSkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB5dCA9IDA7IHl0IDwgZ2UubGVuZ3RoOyB5dCsrKVxuICAgICAgICAgICAgICAgICAgQmkoZ2VbeXRdLCBiKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuZnJlZXplICYmIE9iamVjdC5mcmVlemUoZ2UpO1xuICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICBfKFwiUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiBVc2UgdGhlIEJhYmVsIHRyYW5zZm9ybSBpbnN0ZWFkLlwiKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgQmkoZ2UsIGIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiID09PSBuID8gcmMoWikgOiB0YyhaKSwgWjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbmMoYiwgaywgVCkge1xuICAgICAgcmV0dXJuIExpKGIsIGssIFQsICEwKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaWMoYiwgaywgVCkge1xuICAgICAgcmV0dXJuIExpKGIsIGssIFQsICExKTtcbiAgICB9XG4gICAgdmFyIG9jID0gaWMsIHNjID0gbmM7XG4gICAgUXQuRnJhZ21lbnQgPSBuLCBRdC5qc3ggPSBvYywgUXQuanN4cyA9IHNjO1xuICB9KCkpLCBRdDtcbn1cbihmdW5jdGlvbih0KSB7XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IHQuZXhwb3J0cyA9IEdkKCkgOiB0LmV4cG9ydHMgPSBaZCgpO1xufSkoQmEpO1xuY29uc3QgWWQgPSBCYS5leHBvcnRzLmpzeCwgTGEgPSBsYyh7XG4gIG5kazogdm9pZCAwLFxuICBzaWduZXI6IHZvaWQgMCxcbiAgZmV0Y2hFdmVudHM6ICh0KSA9PiBQcm9taXNlLnJlc29sdmUoW10pLFxuICBsb2dpbldpdGhOaXA0NjogKHQsIGUpID0+IFByb21pc2UucmVzb2x2ZSh2b2lkIDApLFxuICBsb2dpbldpdGhTZWNyZXQ6ICh0KSA9PiBQcm9taXNlLnJlc29sdmUodm9pZCAwKSxcbiAgbG9naW5XaXRoTmlwMDc6ICgpID0+IFByb21pc2UucmVzb2x2ZSh2b2lkIDApLFxuICBzaWduUHVibGlzaEV2ZW50OiAodCwgZSkgPT4gUHJvbWlzZS5yZXNvbHZlKHZvaWQgMCksXG4gIGdldFVzZXI6ICh0KSA9PiBwZS5wcm90b3R5cGUsXG4gIGdldFByb2ZpbGU6ICh0KSA9PiAoe30pXG59KSwgUHAgPSAoe1xuICBjaGlsZHJlbjogdCxcbiAgcmVsYXlVcmxzOiBlXG59KSA9PiB7XG4gIGNvbnN0IHtcbiAgICBuZGs6IHIsXG4gICAgc2lnbmVyOiBuLFxuICAgIHNldFNpZ25lcjogaSxcbiAgICBmZXRjaEV2ZW50czogcyxcbiAgICBzaWduUHVibGlzaEV2ZW50OiBvXG4gIH0gPSB6ZChlKSwge1xuICAgIGdldFVzZXI6IGEsXG4gICAgZ2V0UHJvZmlsZTogY1xuICB9ID0gVmQocik7XG4gIGFzeW5jIGZ1bmN0aW9uIGwoaCwgZCkge1xuICAgIGlmIChyID09PSB2b2lkIDApXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgcCA9IGF3YWl0IEtkKHIsIGgsIGQpO1xuICAgIGlmIChwKVxuICAgICAgcmV0dXJuIGF3YWl0IGkocC5yZW1vdGVTaWduZXIpLCBwO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGYoaCkge1xuICAgIGNvbnN0IGQgPSBhd2FpdCBGZChoKTtcbiAgICBpZiAoZCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzaWduZXI6IHBcbiAgICAgIH0gPSBkO1xuICAgICAgcmV0dXJuIGF3YWl0IGkocCksIGQ7XG4gICAgfVxuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHUoKSB7XG4gICAgY29uc3QgaCA9IGF3YWl0IFdkKCk7XG4gICAgaWYgKGgpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc2lnbmVyOiBkXG4gICAgICB9ID0gaDtcbiAgICAgIHJldHVybiBhd2FpdCBpKGQpLCBoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFlkKExhLlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHtcbiAgICAgIG5kazogcixcbiAgICAgIHNpZ25lcjogbixcbiAgICAgIGZldGNoRXZlbnRzOiBzLFxuICAgICAgbG9naW5XaXRoTmlwMDc6IHUsXG4gICAgICBsb2dpbldpdGhOaXA0NjogbCxcbiAgICAgIGxvZ2luV2l0aFNlY3JldDogZixcbiAgICAgIHNpZ25QdWJsaXNoRXZlbnQ6IG8sXG4gICAgICBnZXRVc2VyOiBhLFxuICAgICAgZ2V0UHJvZmlsZTogY1xuICAgIH0sXG4gICAgY2hpbGRyZW46IHRcbiAgfSk7XG59LCBCcCA9ICgpID0+IHtcbiAgY29uc3QgdCA9IGZjKExhKTtcbiAgaWYgKHQgPT09IHZvaWQgMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbXBvcnQgTkRLUHJvdmlkZXIgdG8gdXNlIHVzZU5ES1wiKTtcbiAgcmV0dXJuIHQ7XG59O1xuZnVuY3Rpb24gWGUodCkge1xuICByZXR1cm4gdCAhPSBudWxsICYmIHR5cGVvZiB0ID09IFwib2JqZWN0XCIgJiYgdFtcIkBAZnVuY3Rpb25hbC9wbGFjZWhvbGRlclwiXSA9PT0gITA7XG59XG5mdW5jdGlvbiBodCh0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBlKHIpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMCB8fCBYZShyKSA/IGUgOiB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5mdW5jdGlvbiB1cih0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBlKHIsIG4pIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiBYZShyKSA/IGUgOiBodChmdW5jdGlvbihpKSB7XG4gICAgICAgICAgcmV0dXJuIHQociwgaSk7XG4gICAgICAgIH0pO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFhlKHIpICYmIFhlKG4pID8gZSA6IFhlKHIpID8gaHQoZnVuY3Rpb24oaSkge1xuICAgICAgICAgIHJldHVybiB0KGksIG4pO1xuICAgICAgICB9KSA6IFhlKG4pID8gaHQoZnVuY3Rpb24oaSkge1xuICAgICAgICAgIHJldHVybiB0KHIsIGkpO1xuICAgICAgICB9KSA6IHQociwgbik7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gJGEodCwgZSkge1xuICBzd2l0Y2ggKHQpIHtcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiBmdW5jdGlvbihyKSB7XG4gICAgICAgIHJldHVybiBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiBmdW5jdGlvbihyLCBuKSB7XG4gICAgICAgIHJldHVybiBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiBmdW5jdGlvbihyLCBuLCBpKSB7XG4gICAgICAgIHJldHVybiBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIGNhc2UgNDpcbiAgICAgIHJldHVybiBmdW5jdGlvbihyLCBuLCBpLCBzKSB7XG4gICAgICAgIHJldHVybiBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIGNhc2UgNTpcbiAgICAgIHJldHVybiBmdW5jdGlvbihyLCBuLCBpLCBzLCBvKSB7XG4gICAgICAgIHJldHVybiBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIGNhc2UgNjpcbiAgICAgIHJldHVybiBmdW5jdGlvbihyLCBuLCBpLCBzLCBvLCBhKSB7XG4gICAgICAgIHJldHVybiBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIGNhc2UgNzpcbiAgICAgIHJldHVybiBmdW5jdGlvbihyLCBuLCBpLCBzLCBvLCBhLCBjKSB7XG4gICAgICAgIHJldHVybiBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIGNhc2UgODpcbiAgICAgIHJldHVybiBmdW5jdGlvbihyLCBuLCBpLCBzLCBvLCBhLCBjLCBsKSB7XG4gICAgICAgIHJldHVybiBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIGNhc2UgOTpcbiAgICAgIHJldHVybiBmdW5jdGlvbihyLCBuLCBpLCBzLCBvLCBhLCBjLCBsLCBmKSB7XG4gICAgICAgIHJldHVybiBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIGNhc2UgMTA6XG4gICAgICByZXR1cm4gZnVuY3Rpb24ociwgbiwgaSwgcywgbywgYSwgYywgbCwgZiwgdSkge1xuICAgICAgICByZXR1cm4gZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmlyc3QgYXJndW1lbnQgdG8gX2FyaXR5IG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlciBubyBncmVhdGVyIHRoYW4gdGVuXCIpO1xuICB9XG59XG5mdW5jdGlvbiBxYSh0LCBlLCByKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBuID0gW10sIGkgPSAwLCBzID0gdCwgbyA9IDA7IG8gPCBlLmxlbmd0aCB8fCBpIDwgYXJndW1lbnRzLmxlbmd0aDsgKSB7XG4gICAgICB2YXIgYTtcbiAgICAgIG8gPCBlLmxlbmd0aCAmJiAoIVhlKGVbb10pIHx8IGkgPj0gYXJndW1lbnRzLmxlbmd0aCkgPyBhID0gZVtvXSA6IChhID0gYXJndW1lbnRzW2ldLCBpICs9IDEpLCBuW29dID0gYSwgWGUoYSkgfHwgKHMgLT0gMSksIG8gKz0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHMgPD0gMCA/IHIuYXBwbHkodGhpcywgbikgOiAkYShzLCBxYSh0LCBuLCByKSk7XG4gIH07XG59XG52YXIgSmQgPSAvKiBAX19QVVJFX18gKi8gdXIoZnVuY3Rpb24oZSwgcikge1xuICByZXR1cm4gZSA9PT0gMSA/IGh0KHIpIDogJGEoZSwgcWEoZSwgW10sIHIpKTtcbn0pO1xuY29uc3QgWGQgPSBKZCwgUWQgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uKGUpIHtcbiAgcmV0dXJuIGUgIT0gbnVsbCAmJiBlLmxlbmd0aCA+PSAwICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiO1xufTtcbmZ1bmN0aW9uIGVwKHQpIHtcbiAgcmV0dXJuIHQgIT0gbnVsbCAmJiB0eXBlb2YgdFtcIkBAdHJhbnNkdWNlci9zdGVwXCJdID09IFwiZnVuY3Rpb25cIjtcbn1cbmZ1bmN0aW9uIHRwKHQsIGUsIHIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIHIoKTtcbiAgICB2YXIgbiA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV07XG4gICAgaWYgKCFRZChuKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0Lmxlbmd0aDsgKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygblt0W2ldXSA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgcmV0dXJuIG5bdFtpXV0uYXBwbHkobiwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwLCAtMSkpO1xuICAgICAgICBpICs9IDE7XG4gICAgICB9XG4gICAgICBpZiAoZXAobikpIHtcbiAgICAgICAgdmFyIHMgPSBlLmFwcGx5KG51bGwsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCwgLTEpKTtcbiAgICAgICAgcmV0dXJuIHMobik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5jb25zdCB6byA9IHtcbiAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMueGZbXCJAQHRyYW5zZHVjZXIvaW5pdFwiXSgpO1xuICB9LFxuICByZXN1bHQ6IGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdGhpcy54ZltcIkBAdHJhbnNkdWNlci9yZXN1bHRcIl0odCk7XG4gIH1cbn07XG5mdW5jdGlvbiBqbih0LCBlKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSwgdCk7XG59XG52YXIgRm8gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLCBycCA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIEZvLmNhbGwoYXJndW1lbnRzKSA9PT0gXCJbb2JqZWN0IEFyZ3VtZW50c11cIiA/IGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gRm8uY2FsbChlKSA9PT0gXCJbb2JqZWN0IEFyZ3VtZW50c11cIjtcbiAgfSA6IGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gam4oXCJjYWxsZWVcIiwgZSk7XG4gIH07XG59KCk7XG5jb25zdCBucCA9IHJwO1xudmFyIGlwID0gIS8qIEBfX1BVUkVfXyAqLyB7XG4gIHRvU3RyaW5nOiBudWxsXG59LnByb3BlcnR5SXNFbnVtZXJhYmxlKFwidG9TdHJpbmdcIiksIEtvID0gW1wiY29uc3RydWN0b3JcIiwgXCJ2YWx1ZU9mXCIsIFwiaXNQcm90b3R5cGVPZlwiLCBcInRvU3RyaW5nXCIsIFwicHJvcGVydHlJc0VudW1lcmFibGVcIiwgXCJoYXNPd25Qcm9wZXJ0eVwiLCBcInRvTG9jYWxlU3RyaW5nXCJdLCBXbyA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5wcm9wZXJ0eUlzRW51bWVyYWJsZShcImxlbmd0aFwiKTtcbn0oKSwgb3AgPSBmdW5jdGlvbihlLCByKSB7XG4gIGZvciAodmFyIG4gPSAwOyBuIDwgZS5sZW5ndGg7ICkge1xuICAgIGlmIChlW25dID09PSByKVxuICAgICAgcmV0dXJuICEwO1xuICAgIG4gKz0gMTtcbiAgfVxuICByZXR1cm4gITE7XG59LCBzcCA9IC8qIEBfX1BVUkVfXyAqLyBodCh0eXBlb2YgT2JqZWN0LmtleXMgPT0gXCJmdW5jdGlvblwiICYmICFXbyA/IGZ1bmN0aW9uKGUpIHtcbiAgcmV0dXJuIE9iamVjdChlKSAhPT0gZSA/IFtdIDogT2JqZWN0LmtleXMoZSk7XG59IDogZnVuY3Rpb24oZSkge1xuICBpZiAoT2JqZWN0KGUpICE9PSBlKVxuICAgIHJldHVybiBbXTtcbiAgdmFyIHIsIG4sIGkgPSBbXSwgcyA9IFdvICYmIG5wKGUpO1xuICBmb3IgKHIgaW4gZSlcbiAgICBqbihyLCBlKSAmJiAoIXMgfHwgciAhPT0gXCJsZW5ndGhcIikgJiYgKGlbaS5sZW5ndGhdID0gcik7XG4gIGlmIChpcClcbiAgICBmb3IgKG4gPSBLby5sZW5ndGggLSAxOyBuID49IDA7IClcbiAgICAgIHIgPSBLb1tuXSwgam4ociwgZSkgJiYgIW9wKGksIHIpICYmIChpW2kubGVuZ3RoXSA9IHIpLCBuIC09IDE7XG4gIHJldHVybiBpO1xufSk7XG5jb25zdCBhcCA9IHNwO1xuZnVuY3Rpb24gY3AodCwgZSkge1xuICBmb3IgKHZhciByID0gMCwgbiA9IGUubGVuZ3RoLCBpID0gQXJyYXkobik7IHIgPCBuOyApXG4gICAgaVtyXSA9IHQoZVtyXSksIHIgKz0gMTtcbiAgcmV0dXJuIGk7XG59XG5mdW5jdGlvbiB1cCh0LCBlLCByKSB7XG4gIGZvciAodmFyIG4gPSAwLCBpID0gci5sZW5ndGg7IG4gPCBpOyApXG4gICAgZSA9IHQoZSwgcltuXSksIG4gKz0gMTtcbiAgcmV0dXJuIGU7XG59XG52YXIgbHAgPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIHQoZSwgcikge1xuICAgIHRoaXMueGYgPSByLCB0aGlzLmYgPSBlO1xuICB9XG4gIHJldHVybiB0LnByb3RvdHlwZVtcIkBAdHJhbnNkdWNlci9pbml0XCJdID0gem8uaW5pdCwgdC5wcm90b3R5cGVbXCJAQHRyYW5zZHVjZXIvcmVzdWx0XCJdID0gem8ucmVzdWx0LCB0LnByb3RvdHlwZVtcIkBAdHJhbnNkdWNlci9zdGVwXCJdID0gZnVuY3Rpb24oZSwgcikge1xuICAgIHJldHVybiB0aGlzLnhmW1wiQEB0cmFuc2R1Y2VyL3N0ZXBcIl0oZSwgdGhpcy5mKHIpKTtcbiAgfSwgdDtcbn0oKSwgZnAgPSBmdW5jdGlvbihlKSB7XG4gIHJldHVybiBmdW5jdGlvbihyKSB7XG4gICAgcmV0dXJuIG5ldyBscChlLCByKTtcbiAgfTtcbn07XG5jb25zdCBocCA9IGZwO1xudmFyIGRwID0gLyogQF9fUFVSRV9fICovIHVyKFxuICAvKiBAX19QVVJFX18gKi8gdHAoW1wiZmFudGFzeS1sYW5kL21hcFwiLCBcIm1hcFwiXSwgaHAsIGZ1bmN0aW9uKGUsIHIpIHtcbiAgICBzd2l0Y2ggKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChyKSkge1xuICAgICAgY2FzZSBcIltvYmplY3QgRnVuY3Rpb25dXCI6XG4gICAgICAgIHJldHVybiBYZChyLmxlbmd0aCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGUuY2FsbCh0aGlzLCByLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICAgICB9KTtcbiAgICAgIGNhc2UgXCJbb2JqZWN0IE9iamVjdF1cIjpcbiAgICAgICAgcmV0dXJuIHVwKGZ1bmN0aW9uKG4sIGkpIHtcbiAgICAgICAgICByZXR1cm4gbltpXSA9IGUocltpXSksIG47XG4gICAgICAgIH0sIHt9LCBhcChyKSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gY3AoZSwgcik7XG4gICAgfVxuICB9KVxuKTtcbmNvbnN0IHBwID0gZHAsIHlwID0gTnVtYmVyLmlzSW50ZWdlciB8fCBmdW5jdGlvbihlKSB7XG4gIHJldHVybiBlIDw8IDAgPT09IGU7XG59O1xuZnVuY3Rpb24gZ3AodCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQpID09PSBcIltvYmplY3QgU3RyaW5nXVwiO1xufVxudmFyIGJwID0gLyogQF9fUFVSRV9fICovIHVyKGZ1bmN0aW9uKGUsIHIpIHtcbiAgdmFyIG4gPSBlIDwgMCA/IHIubGVuZ3RoICsgZSA6IGU7XG4gIHJldHVybiBncChyKSA/IHIuY2hhckF0KG4pIDogcltuXTtcbn0pO1xuY29uc3QgTmEgPSBicDtcbnZhciB2cCA9IC8qIEBfX1BVUkVfXyAqLyB1cihmdW5jdGlvbihlLCByKSB7XG4gIGlmIChyICE9IG51bGwpXG4gICAgcmV0dXJuIHlwKGUpID8gTmEoZSwgcikgOiByW2VdO1xufSk7XG5jb25zdCB3cCA9IHZwO1xudmFyIF9wID0gLyogQF9fUFVSRV9fICovIHVyKGZ1bmN0aW9uKGUsIHIpIHtcbiAgcmV0dXJuIHBwKHdwKGUpLCByKTtcbn0pO1xuY29uc3QgbXAgPSBfcDtcbmZ1bmN0aW9uIHhwKHQpIHtcbiAgcmV0dXJuIHQ7XG59XG52YXIgRXAgPSAvKiBAX19QVVJFX18gKi8gaHQoeHApO1xuY29uc3Qga3AgPSBFcDtcbnZhciBTcCA9IC8qIEBfX1BVUkVfXyAqLyBOYSgtMSk7XG5jb25zdCBVYSA9IFNwLCBPcCA9IFwibmV3bGluZVwiLCBIbiA9IFwidGV4dFwiLCBqYSA9IFwidG9waWNcIiwgeGkgPSBcImxpbmtcIiwgSGEgPSBcImludm9pY2VcIiwgTHAgPSBcIm5vc3RyOm5vdGVcIiwgJHAgPSBcIm5vc3RyOm5ldmVudFwiLCBxcCA9IFwibm9zdHI6bnB1YlwiLCBOcCA9IFwibm9zdHI6bnByb2ZpbGVcIiwgVXAgPSBcIm5vc3RyOm5hZGRyXCI7XG5mdW5jdGlvbiBndCh0KSB7XG4gIHJldHVybiB0ID8gdFswXSA6IHZvaWQgMDtcbn1cbmNvbnN0IEFwID0gKHQpID0+IHQucmVwbGFjZSgvXltcXHdcXCtdKzpcXC8/XFwvPy8sIFwiXCIpLCBDcCA9ICh0KSA9PiAhdC5tYXRjaCgvXFwuKGFwa3xkb2N4fHhsc3h8Y3N2fGRtZykvKSAmJiBVYSh0LnNwbGl0KFwiOi8vXCIpKS5pbmNsdWRlcyhcIi9cIiksIGpwID0gKHtcbiAgY29udGVudDogdCxcbiAgdGFnczogZSA9IFtdXG59KSA9PiB7XG4gIGNvbnN0IHIgPSBbXTtcbiAgbGV0IG4gPSB0LnRyaW0oKSwgaSA9IFwiXCI7XG4gIGNvbnN0IHMgPSAoKSA9PiB7XG4gICAgY29uc3QgdSA9IGd0KG4ubWF0Y2goL15cXG4rLykpO1xuICAgIGlmICh1KVxuICAgICAgcmV0dXJuIFtPcCwgdSwgdV07XG4gIH0sIG8gPSAoKSA9PiB7XG4gICAgY29uc3QgdSA9IG4ubWF0Y2goL14jXFxbKFxcZCspXFxdL2kpO1xuICAgIGlmICh1KSB7XG4gICAgICBjb25zdCBoID0gcGFyc2VJbnQodVsxXSk7XG4gICAgICBpZiAoZVtoXSkge1xuICAgICAgICBjb25zdCBbZCwgcCwgeV0gPSBlW2hdLCBnID0gW3ldLmZpbHRlcihrcCk7XG4gICAgICAgIGxldCB2LCBfLCBtO1xuICAgICAgICByZXR1cm4gZCA9PT0gXCJwXCIgPyAodiA9IFwibnByb2ZpbGVcIiwgXyA9IHsgcHVia2V5OiBwLCByZWxheXM6IGcgfSwgbSA9IHdlLm5wcm9maWxlRW5jb2RlKF8pKSA6ICh2ID0gXCJuZXZlbnRcIiwgXyA9IHsgaWQ6IHAsIHJlbGF5czogZywgcHVia2V5OiBudWxsIH0sIG0gPSB3ZS5uZXZlbnRFbmNvZGUoXykpLCBbYG5vc3RyOiR7dn1gLCB1WzBdLCB7IC4uLl8sIGVudGl0eTogbSB9XTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIGEgPSAoKSA9PiB7XG4gICAgY29uc3QgdSA9IGd0KG4ubWF0Y2goL14jXFx3Ky9pKSk7XG4gICAgaWYgKHUgJiYgIXUubWF0Y2goL14jXFxkKyQvKSlcbiAgICAgIHJldHVybiBbamEsIHUsIHUuc2xpY2UoMSldO1xuICB9LCBjID0gKCkgPT4ge1xuICAgIGNvbnN0IHUgPSBndChcbiAgICAgIG4ubWF0Y2goXG4gICAgICAgIC9eKHdlYlxcKyk/KG5vc3RyOik/XFwvP1xcLz9uKGV2ZW50fG90ZXxwcm9maWxlfHB1YnxhZGRyKTFbXFxkXFx3XSsvaVxuICAgICAgKVxuICAgICk7XG4gICAgaWYgKHUpXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBoID0gQXAodSksIHsgdHlwZTogZCwgZGF0YTogcCB9ID0gd2UuZGVjb2RlKGgpO1xuICAgICAgICBsZXQgeSA9IHA7XG4gICAgICAgIHJldHVybiBkID09PSBcIm5vdGVcIiA/IHkgPSB7IGlkOiBwIH0gOiBkID09PSBcIm5wdWJcIiAmJiAoeSA9IHsgcHVia2V5OiBwIH0pLCBbYG5vc3RyOiR7ZH1gLCB1LCB7IC4uLnksIGVudGl0eTogaCB9XTtcbiAgICAgIH0gY2F0Y2ggKGgpIHtcbiAgICAgICAgY29uc29sZS5sb2coaCk7XG4gICAgICB9XG4gIH0sIGwgPSAoKSA9PiB7XG4gICAgY29uc3QgdSA9IGd0KG4ubWF0Y2goL15sbihiY3x1cmwpW1xcZFxcd117NTAsMTAwMH0vaSkpO1xuICAgIGlmICh1KVxuICAgICAgcmV0dXJuIFtIYSwgdSwgdV07XG4gIH0sIGYgPSAoKSA9PiB7XG4gICAgY29uc3QgdSA9IGd0KFxuICAgICAgbi5tYXRjaCgvXihbYS16XFwrOl17MiwzMH06XFwvXFwvKT9bXlxcc10rXFwuW2Etel17Miw2fVteXFxzXSpbXlxcLiE/LDpcXHNdL2dpKVxuICAgICk7XG4gICAgaWYgKHUpIHtcbiAgICAgIGNvbnN0IGggPSBVYShyKTtcbiAgICAgIGlmICgoaCA9PSBudWxsID8gdm9pZCAwIDogaC50eXBlKSA9PT0gXCJ0ZXh0XCIgJiYgaC52YWx1ZS5lbmRzV2l0aChcIi9cIikpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGxldCBkID0gdTtcbiAgICAgIHJldHVybiBkLm1hdGNoKC9cXC5cXC4vKSA/IHZvaWQgMCA6IChkLm1hdGNoKFwiOi8vXCIpIHx8IChkID0gXCJodHRwczovL1wiICsgZCksIFt4aSwgdSwgeyB1cmw6IGQsIGlzTWVkaWE6IENwKGQpIH1dKTtcbiAgICB9XG4gIH07XG4gIGZvciAoOyBuOyApIHtcbiAgICBjb25zdCB1ID0gcygpIHx8IG8oKSB8fCBhKCkgfHwgYygpIHx8IGYoKSB8fCBsKCk7XG4gICAgaWYgKHUpIHtcbiAgICAgIGkgJiYgKHIucHVzaCh7IHR5cGU6IFwidGV4dFwiLCB2YWx1ZTogaSB9KSwgaSA9IFwiXCIpO1xuICAgICAgY29uc3QgW2gsIGQsIHBdID0gdTtcbiAgICAgIHIucHVzaCh7IHR5cGU6IGgsIHZhbHVlOiBwIH0pLCBuID0gbi5zbGljZShkLmxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGggPSBndChuLm1hdGNoKC9eW1xcd1xcZF0rID8vaSkpIHx8IG5bMF07XG4gICAgICBpICs9IGgsIG4gPSBuLnNsaWNlKGgubGVuZ3RoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGkgJiYgci5wdXNoKHsgdHlwZTogSG4sIHZhbHVlOiBpIH0pLCByO1xufSwgSHAgPSAodCwgeyBzaG93RW50aXJlOiBlLCBtYXhMZW5ndGg6IHIsIHNob3dNZWRpYTogbiA9ICExIH0pID0+IHtcbiAgaWYgKGUpXG4gICAgcmV0dXJuIHQ7XG4gIGxldCBpID0gMDtcbiAgY29uc3QgcyA9IFtdLCBvID0gciAqIDAuNjtcbiAgcmV0dXJuIHQuZXZlcnkoKGEsIGMpID0+IHtcbiAgICBjb25zdCBsID0gW2phLCBIbl0uaW5jbHVkZXMoYS50eXBlKSB8fCBhLnR5cGUgPT09IHhpICYmICFhLnZhbHVlLmlzTWVkaWEsIGYgPSBhLnR5cGUgPT09IEhhIHx8IGEudHlwZS5zdGFydHNXaXRoKFwibm9zdHI6XCIpIHx8IGEudmFsdWUuaXNNZWRpYTtcbiAgICByZXR1cm4gbCAmJiAoaSArPSBhLnZhbHVlLmxlbmd0aCksIGYgJiYgKGkgKz0gbiA/IHIgLyAzIDogYS52YWx1ZS5sZW5ndGgpLCBzLnB1c2goYSksIGkgPiBvICYmIGMgPCB0Lmxlbmd0aCAtIDEgPyAoKGwgfHwgZiAmJiAhbikgJiYgcy5wdXNoKHsgdHlwZTogSG4sIHZhbHVlOiBcIi4uLlwiIH0pLCAhMSkgOiAhMDtcbiAgfSksIHM7XG59LCBNcCA9ICh0KSA9PiBtcChcbiAgXCJ2YWx1ZVwiLFxuICB0LmZpbHRlcigoZSkgPT4gZS50eXBlID09PSB4aSAmJiBlLmlzTWVkaWEpXG4pO1xuZXhwb3J0IHtcbiAgSGEgYXMgSU5WT0lDRSxcbiAgeGkgYXMgTElOSyxcbiAgUHAgYXMgTkRLUHJvdmlkZXIsXG4gIE9wIGFzIE5FV0xJTkUsXG4gIFVwIGFzIE5PU1RSX05BRERSLFxuICAkcCBhcyBOT1NUUl9ORVZFTlQsXG4gIExwIGFzIE5PU1RSX05PVEUsXG4gIE5wIGFzIE5PU1RSX05QUk9GSUxFLFxuICBxcCBhcyBOT1NUUl9OUFVCLFxuICBIbiBhcyBURVhULFxuICBqYSBhcyBUT1BJQyxcbiAgQXAgYXMgZnJvbU5vc3RyVVJJLFxuICBNcCBhcyBnZXRMaW5rcyxcbiAganAgYXMgcGFyc2VDb250ZW50LFxuICBIcCBhcyB0cnVuY2F0ZUNvbnRlbnQsXG4gIENwIGFzIHVybElzTWVkaWEsXG4gIEJwIGFzIHVzZU5ES1xufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@nostr-dev-kit/ndk-react/dist/ndk-react.es.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk-react/dist/ndk-react.es.js":
/*!********************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk-react/dist/ndk-react.es.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   INVOICE: () => (/* binding */ Ha),\n/* harmony export */   LINK: () => (/* binding */ xi),\n/* harmony export */   NDKProvider: () => (/* binding */ Pp),\n/* harmony export */   NEWLINE: () => (/* binding */ Op),\n/* harmony export */   NOSTR_NADDR: () => (/* binding */ Up),\n/* harmony export */   NOSTR_NEVENT: () => (/* binding */ $p),\n/* harmony export */   NOSTR_NOTE: () => (/* binding */ Lp),\n/* harmony export */   NOSTR_NPROFILE: () => (/* binding */ Np),\n/* harmony export */   NOSTR_NPUB: () => (/* binding */ qp),\n/* harmony export */   TEXT: () => (/* binding */ Hn),\n/* harmony export */   TOPIC: () => (/* binding */ ja),\n/* harmony export */   fromNostrURI: () => (/* binding */ Ap),\n/* harmony export */   getLinks: () => (/* binding */ Mp),\n/* harmony export */   parseContent: () => (/* binding */ jp),\n/* harmony export */   truncateContent: () => (/* binding */ Hp),\n/* harmony export */   urlIsMedia: () => (/* binding */ Cp),\n/* harmony export */   useNDK: () => (/* binding */ Bp)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\nvar ac = Object.defineProperty;\nvar cc = (t, e, r) => e in t ? ac(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r;\nvar I = (t, e, r) => (cc(t, typeof e != \"symbol\" ? e + \"\" : e, r), r);\n\nvar S = typeof globalThis < \"u\" ? globalThis : typeof window < \"u\" ? window : typeof global < \"u\" ? global : typeof self < \"u\" ? self : {};\nfunction Et(t) {\n  var e = t.default;\n  if (typeof e == \"function\") {\n    var r = function() {\n      return e.apply(this, arguments);\n    };\n    r.prototype = e.prototype;\n  } else\n    r = {};\n  return Object.defineProperty(r, \"__esModule\", { value: !0 }), Object.keys(t).forEach(function(n) {\n    var i = Object.getOwnPropertyDescriptor(t, n);\n    Object.defineProperty(r, n, i.get ? i : {\n      enumerable: !0,\n      get: function() {\n        return t[n];\n      }\n    });\n  }), r;\n}\nvar On = { exports: {} }, en, qi;\nfunction hc() {\n  if (qi)\n    return en;\n  qi = 1;\n  var t = 1e3, e = t * 60, r = e * 60, n = r * 24, i = n * 7, s = n * 365.25;\n  en = function(f, u) {\n    u = u || {};\n    var h = typeof f;\n    if (h === \"string\" && f.length > 0)\n      return o(f);\n    if (h === \"number\" && isFinite(f))\n      return u.long ? c(f) : a(f);\n    throw new Error(\n      \"val is not a non-empty string or a valid number. val=\" + JSON.stringify(f)\n    );\n  };\n  function o(f) {\n    if (f = String(f), !(f.length > 100)) {\n      var u = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n        f\n      );\n      if (!!u) {\n        var h = parseFloat(u[1]), d = (u[2] || \"ms\").toLowerCase();\n        switch (d) {\n          case \"years\":\n          case \"year\":\n          case \"yrs\":\n          case \"yr\":\n          case \"y\":\n            return h * s;\n          case \"weeks\":\n          case \"week\":\n          case \"w\":\n            return h * i;\n          case \"days\":\n          case \"day\":\n          case \"d\":\n            return h * n;\n          case \"hours\":\n          case \"hour\":\n          case \"hrs\":\n          case \"hr\":\n          case \"h\":\n            return h * r;\n          case \"minutes\":\n          case \"minute\":\n          case \"mins\":\n          case \"min\":\n          case \"m\":\n            return h * e;\n          case \"seconds\":\n          case \"second\":\n          case \"secs\":\n          case \"sec\":\n          case \"s\":\n            return h * t;\n          case \"milliseconds\":\n          case \"millisecond\":\n          case \"msecs\":\n          case \"msec\":\n          case \"ms\":\n            return h;\n          default:\n            return;\n        }\n      }\n    }\n  }\n  function a(f) {\n    var u = Math.abs(f);\n    return u >= n ? Math.round(f / n) + \"d\" : u >= r ? Math.round(f / r) + \"h\" : u >= e ? Math.round(f / e) + \"m\" : u >= t ? Math.round(f / t) + \"s\" : f + \"ms\";\n  }\n  function c(f) {\n    var u = Math.abs(f);\n    return u >= n ? l(f, u, n, \"day\") : u >= r ? l(f, u, r, \"hour\") : u >= e ? l(f, u, e, \"minute\") : u >= t ? l(f, u, t, \"second\") : f + \" ms\";\n  }\n  function l(f, u, h, d) {\n    var p = u >= h * 1.5;\n    return Math.round(f / h) + \" \" + d + (p ? \"s\" : \"\");\n  }\n  return en;\n}\nfunction dc(t) {\n  r.debug = r, r.default = r, r.coerce = c, r.disable = s, r.enable = i, r.enabled = o, r.humanize = hc(), r.destroy = l, Object.keys(t).forEach((f) => {\n    r[f] = t[f];\n  }), r.names = [], r.skips = [], r.formatters = {};\n  function e(f) {\n    let u = 0;\n    for (let h = 0; h < f.length; h++)\n      u = (u << 5) - u + f.charCodeAt(h), u |= 0;\n    return r.colors[Math.abs(u) % r.colors.length];\n  }\n  r.selectColor = e;\n  function r(f) {\n    let u, h = null, d, p;\n    function y(...g) {\n      if (!y.enabled)\n        return;\n      const v = y, _ = Number(new Date()), m = _ - (u || _);\n      v.diff = m, v.prev = u, v.curr = _, u = _, g[0] = r.coerce(g[0]), typeof g[0] != \"string\" && g.unshift(\"%O\");\n      let C = 0;\n      g[0] = g[0].replace(/%([a-zA-Z%])/g, (w, x) => {\n        if (w === \"%%\")\n          return \"%\";\n        C++;\n        const A = r.formatters[x];\n        if (typeof A == \"function\") {\n          const B = g[C];\n          w = A.call(v, B), g.splice(C, 1), C--;\n        }\n        return w;\n      }), r.formatArgs.call(v, g), (v.log || r.log).apply(v, g);\n    }\n    return y.namespace = f, y.useColors = r.useColors(), y.color = r.selectColor(f), y.extend = n, y.destroy = r.destroy, Object.defineProperty(y, \"enabled\", {\n      enumerable: !0,\n      configurable: !1,\n      get: () => h !== null ? h : (d !== r.namespaces && (d = r.namespaces, p = r.enabled(f)), p),\n      set: (g) => {\n        h = g;\n      }\n    }), typeof r.init == \"function\" && r.init(y), y;\n  }\n  function n(f, u) {\n    const h = r(this.namespace + (typeof u > \"u\" ? \":\" : u) + f);\n    return h.log = this.log, h;\n  }\n  function i(f) {\n    r.save(f), r.namespaces = f, r.names = [], r.skips = [];\n    let u;\n    const h = (typeof f == \"string\" ? f : \"\").split(/[\\s,]+/), d = h.length;\n    for (u = 0; u < d; u++)\n      !h[u] || (f = h[u].replace(/\\*/g, \".*?\"), f[0] === \"-\" ? r.skips.push(new RegExp(\"^\" + f.slice(1) + \"$\")) : r.names.push(new RegExp(\"^\" + f + \"$\")));\n  }\n  function s() {\n    const f = [\n      ...r.names.map(a),\n      ...r.skips.map(a).map((u) => \"-\" + u)\n    ].join(\",\");\n    return r.enable(\"\"), f;\n  }\n  function o(f) {\n    if (f[f.length - 1] === \"*\")\n      return !0;\n    let u, h;\n    for (u = 0, h = r.skips.length; u < h; u++)\n      if (r.skips[u].test(f))\n        return !1;\n    for (u = 0, h = r.names.length; u < h; u++)\n      if (r.names[u].test(f))\n        return !0;\n    return !1;\n  }\n  function a(f) {\n    return f.toString().substring(2, f.toString().length - 2).replace(/\\.\\*\\?$/, \"*\");\n  }\n  function c(f) {\n    return f instanceof Error ? f.stack || f.message : f;\n  }\n  function l() {\n    console.warn(\"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\");\n  }\n  return r.enable(r.load()), r;\n}\nvar pc = dc;\n(function(t, e) {\n  e.formatArgs = n, e.save = i, e.load = s, e.useColors = r, e.storage = o(), e.destroy = (() => {\n    let c = !1;\n    return () => {\n      c || (c = !0, console.warn(\"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.\"));\n    };\n  })(), e.colors = [\n    \"#0000CC\",\n    \"#0000FF\",\n    \"#0033CC\",\n    \"#0033FF\",\n    \"#0066CC\",\n    \"#0066FF\",\n    \"#0099CC\",\n    \"#0099FF\",\n    \"#00CC00\",\n    \"#00CC33\",\n    \"#00CC66\",\n    \"#00CC99\",\n    \"#00CCCC\",\n    \"#00CCFF\",\n    \"#3300CC\",\n    \"#3300FF\",\n    \"#3333CC\",\n    \"#3333FF\",\n    \"#3366CC\",\n    \"#3366FF\",\n    \"#3399CC\",\n    \"#3399FF\",\n    \"#33CC00\",\n    \"#33CC33\",\n    \"#33CC66\",\n    \"#33CC99\",\n    \"#33CCCC\",\n    \"#33CCFF\",\n    \"#6600CC\",\n    \"#6600FF\",\n    \"#6633CC\",\n    \"#6633FF\",\n    \"#66CC00\",\n    \"#66CC33\",\n    \"#9900CC\",\n    \"#9900FF\",\n    \"#9933CC\",\n    \"#9933FF\",\n    \"#99CC00\",\n    \"#99CC33\",\n    \"#CC0000\",\n    \"#CC0033\",\n    \"#CC0066\",\n    \"#CC0099\",\n    \"#CC00CC\",\n    \"#CC00FF\",\n    \"#CC3300\",\n    \"#CC3333\",\n    \"#CC3366\",\n    \"#CC3399\",\n    \"#CC33CC\",\n    \"#CC33FF\",\n    \"#CC6600\",\n    \"#CC6633\",\n    \"#CC9900\",\n    \"#CC9933\",\n    \"#CCCC00\",\n    \"#CCCC33\",\n    \"#FF0000\",\n    \"#FF0033\",\n    \"#FF0066\",\n    \"#FF0099\",\n    \"#FF00CC\",\n    \"#FF00FF\",\n    \"#FF3300\",\n    \"#FF3333\",\n    \"#FF3366\",\n    \"#FF3399\",\n    \"#FF33CC\",\n    \"#FF33FF\",\n    \"#FF6600\",\n    \"#FF6633\",\n    \"#FF9900\",\n    \"#FF9933\",\n    \"#FFCC00\",\n    \"#FFCC33\"\n  ];\n  function r() {\n    return typeof window < \"u\" && window.process && (window.process.type === \"renderer\" || window.process.__nwjs) ? !0 : typeof navigator < \"u\" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/) ? !1 : typeof document < \"u\" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window < \"u\" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator < \"u\" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator < \"u\" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/);\n  }\n  function n(c) {\n    if (c[0] = (this.useColors ? \"%c\" : \"\") + this.namespace + (this.useColors ? \" %c\" : \" \") + c[0] + (this.useColors ? \"%c \" : \" \") + \"+\" + t.exports.humanize(this.diff), !this.useColors)\n      return;\n    const l = \"color: \" + this.color;\n    c.splice(1, 0, l, \"color: inherit\");\n    let f = 0, u = 0;\n    c[0].replace(/%[a-zA-Z%]/g, (h) => {\n      h !== \"%%\" && (f++, h === \"%c\" && (u = f));\n    }), c.splice(u, 0, l);\n  }\n  e.log = console.debug || console.log || (() => {\n  });\n  function i(c) {\n    try {\n      c ? e.storage.setItem(\"debug\", c) : e.storage.removeItem(\"debug\");\n    } catch {\n    }\n  }\n  function s() {\n    let c;\n    try {\n      c = e.storage.getItem(\"debug\");\n    } catch {\n    }\n    return !c && typeof process < \"u\" && \"env\" in process && (c = process.env.DEBUG), c;\n  }\n  function o() {\n    try {\n      return localStorage;\n    } catch {\n    }\n  }\n  t.exports = pc(e);\n  const { formatters: a } = t.exports;\n  a.j = function(c) {\n    try {\n      return JSON.stringify(c);\n    } catch (l) {\n      return \"[UnexpectedJSONParseError]: \" + l.message;\n    }\n  };\n})(On, On.exports);\nconst Mn = On.exports;\nvar Zo = { exports: {} };\n(function(t) {\n  var e = Object.prototype.hasOwnProperty, r = \"~\";\n  function n() {\n  }\n  Object.create && (n.prototype = /* @__PURE__ */ Object.create(null), new n().__proto__ || (r = !1));\n  function i(c, l, f) {\n    this.fn = c, this.context = l, this.once = f || !1;\n  }\n  function s(c, l, f, u, h) {\n    if (typeof f != \"function\")\n      throw new TypeError(\"The listener must be a function\");\n    var d = new i(f, u || c, h), p = r ? r + l : l;\n    return c._events[p] ? c._events[p].fn ? c._events[p] = [c._events[p], d] : c._events[p].push(d) : (c._events[p] = d, c._eventsCount++), c;\n  }\n  function o(c, l) {\n    --c._eventsCount === 0 ? c._events = new n() : delete c._events[l];\n  }\n  function a() {\n    this._events = new n(), this._eventsCount = 0;\n  }\n  a.prototype.eventNames = function() {\n    var l = [], f, u;\n    if (this._eventsCount === 0)\n      return l;\n    for (u in f = this._events)\n      e.call(f, u) && l.push(r ? u.slice(1) : u);\n    return Object.getOwnPropertySymbols ? l.concat(Object.getOwnPropertySymbols(f)) : l;\n  }, a.prototype.listeners = function(l) {\n    var f = r ? r + l : l, u = this._events[f];\n    if (!u)\n      return [];\n    if (u.fn)\n      return [u.fn];\n    for (var h = 0, d = u.length, p = new Array(d); h < d; h++)\n      p[h] = u[h].fn;\n    return p;\n  }, a.prototype.listenerCount = function(l) {\n    var f = r ? r + l : l, u = this._events[f];\n    return u ? u.fn ? 1 : u.length : 0;\n  }, a.prototype.emit = function(l, f, u, h, d, p) {\n    var y = r ? r + l : l;\n    if (!this._events[y])\n      return !1;\n    var g = this._events[y], v = arguments.length, _, m;\n    if (g.fn) {\n      switch (g.once && this.removeListener(l, g.fn, void 0, !0), v) {\n        case 1:\n          return g.fn.call(g.context), !0;\n        case 2:\n          return g.fn.call(g.context, f), !0;\n        case 3:\n          return g.fn.call(g.context, f, u), !0;\n        case 4:\n          return g.fn.call(g.context, f, u, h), !0;\n        case 5:\n          return g.fn.call(g.context, f, u, h, d), !0;\n        case 6:\n          return g.fn.call(g.context, f, u, h, d, p), !0;\n      }\n      for (m = 1, _ = new Array(v - 1); m < v; m++)\n        _[m - 1] = arguments[m];\n      g.fn.apply(g.context, _);\n    } else {\n      var C = g.length, O;\n      for (m = 0; m < C; m++)\n        switch (g[m].once && this.removeListener(l, g[m].fn, void 0, !0), v) {\n          case 1:\n            g[m].fn.call(g[m].context);\n            break;\n          case 2:\n            g[m].fn.call(g[m].context, f);\n            break;\n          case 3:\n            g[m].fn.call(g[m].context, f, u);\n            break;\n          case 4:\n            g[m].fn.call(g[m].context, f, u, h);\n            break;\n          default:\n            if (!_)\n              for (O = 1, _ = new Array(v - 1); O < v; O++)\n                _[O - 1] = arguments[O];\n            g[m].fn.apply(g[m].context, _);\n        }\n    }\n    return !0;\n  }, a.prototype.on = function(l, f, u) {\n    return s(this, l, f, u, !1);\n  }, a.prototype.once = function(l, f, u) {\n    return s(this, l, f, u, !0);\n  }, a.prototype.removeListener = function(l, f, u, h) {\n    var d = r ? r + l : l;\n    if (!this._events[d])\n      return this;\n    if (!f)\n      return o(this, d), this;\n    var p = this._events[d];\n    if (p.fn)\n      p.fn === f && (!h || p.once) && (!u || p.context === u) && o(this, d);\n    else {\n      for (var y = 0, g = [], v = p.length; y < v; y++)\n        (p[y].fn !== f || h && !p[y].once || u && p[y].context !== u) && g.push(p[y]);\n      g.length ? this._events[d] = g.length === 1 ? g[0] : g : o(this, d);\n    }\n    return this;\n  }, a.prototype.removeAllListeners = function(l) {\n    var f;\n    return l ? (f = r ? r + l : l, this._events[f] && o(this, f)) : (this._events = new n(), this._eventsCount = 0), this;\n  }, a.prototype.off = a.prototype.removeListener, a.prototype.addListener = a.prototype.on, a.prefixed = r, a.EventEmitter = a, t.exports = a;\n})(Zo);\nconst dt = Zo.exports;\nfunction An(t) {\n  if (!Number.isSafeInteger(t) || t < 0)\n    throw new Error(`Wrong positive integer: ${t}`);\n}\nfunction yc(t) {\n  if (typeof t != \"boolean\")\n    throw new Error(`Expected boolean, not ${t}`);\n}\nfunction Yo(t, ...e) {\n  if (!(t instanceof Uint8Array))\n    throw new TypeError(\"Expected Uint8Array\");\n  if (e.length > 0 && !e.includes(t.length))\n    throw new TypeError(`Expected Uint8Array of length ${e}, not of length=${t.length}`);\n}\nfunction gc(t) {\n  if (typeof t != \"function\" || typeof t.create != \"function\")\n    throw new Error(\"Hash should be wrapped by utils.wrapConstructor\");\n  An(t.outputLen), An(t.blockLen);\n}\nfunction bc(t, e = !0) {\n  if (t.destroyed)\n    throw new Error(\"Hash instance has been destroyed\");\n  if (e && t.finished)\n    throw new Error(\"Hash#digest() has already been called\");\n}\nfunction vc(t, e) {\n  Yo(t);\n  const r = e.outputLen;\n  if (t.length < r)\n    throw new Error(`digestInto() expects output buffer of length at least ${r}`);\n}\nconst ut = {\n  number: An,\n  bool: yc,\n  bytes: Yo,\n  hash: gc,\n  exists: bc,\n  output: vc\n}, tn = typeof globalThis == \"object\" && \"crypto\" in globalThis ? globalThis.crypto : void 0;\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst rn = (t) => new DataView(t.buffer, t.byteOffset, t.byteLength), Ae = (t, e) => t << 32 - e | t >>> e, wc = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;\nif (!wc)\n  throw new Error(\"Non little-endian hardware is not supported\");\nArray.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, \"0\"));\nfunction _c(t) {\n  if (typeof t != \"string\")\n    throw new TypeError(`utf8ToBytes expected string, got ${typeof t}`);\n  return new TextEncoder().encode(t);\n}\nfunction Dn(t) {\n  if (typeof t == \"string\" && (t = _c(t)), !(t instanceof Uint8Array))\n    throw new TypeError(`Expected input type is Uint8Array (got ${typeof t})`);\n  return t;\n}\nfunction mc(...t) {\n  if (!t.every((n) => n instanceof Uint8Array))\n    throw new Error(\"Uint8Array list expected\");\n  if (t.length === 1)\n    return t[0];\n  const e = t.reduce((n, i) => n + i.length, 0), r = new Uint8Array(e);\n  for (let n = 0, i = 0; n < t.length; n++) {\n    const s = t[n];\n    r.set(s, i), i += s.length;\n  }\n  return r;\n}\nclass Jo {\n  clone() {\n    return this._cloneInto();\n  }\n}\nfunction Xo(t) {\n  const e = (n) => t().update(Dn(n)).digest(), r = t();\n  return e.outputLen = r.outputLen, e.blockLen = r.blockLen, e.create = () => t(), e;\n}\nfunction Qo(t = 32) {\n  if (tn && typeof tn.getRandomValues == \"function\")\n    return tn.getRandomValues(new Uint8Array(t));\n  throw new Error(\"crypto.getRandomValues must be defined\");\n}\nfunction xc(t, e, r, n) {\n  if (typeof t.setBigUint64 == \"function\")\n    return t.setBigUint64(e, r, n);\n  const i = BigInt(32), s = BigInt(4294967295), o = Number(r >> i & s), a = Number(r & s), c = n ? 4 : 0, l = n ? 0 : 4;\n  t.setUint32(e + c, o, n), t.setUint32(e + l, a, n);\n}\nclass Ec extends Jo {\n  constructor(e, r, n, i) {\n    super(), this.blockLen = e, this.outputLen = r, this.padOffset = n, this.isLE = i, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = rn(this.buffer);\n  }\n  update(e) {\n    ut.exists(this);\n    const { view: r, buffer: n, blockLen: i } = this;\n    e = Dn(e);\n    const s = e.length;\n    for (let o = 0; o < s; ) {\n      const a = Math.min(i - this.pos, s - o);\n      if (a === i) {\n        const c = rn(e);\n        for (; i <= s - o; o += i)\n          this.process(c, o);\n        continue;\n      }\n      n.set(e.subarray(o, o + a), this.pos), this.pos += a, o += a, this.pos === i && (this.process(r, 0), this.pos = 0);\n    }\n    return this.length += e.length, this.roundClean(), this;\n  }\n  digestInto(e) {\n    ut.exists(this), ut.output(e, this), this.finished = !0;\n    const { buffer: r, view: n, blockLen: i, isLE: s } = this;\n    let { pos: o } = this;\n    r[o++] = 128, this.buffer.subarray(o).fill(0), this.padOffset > i - o && (this.process(n, 0), o = 0);\n    for (let u = o; u < i; u++)\n      r[u] = 0;\n    xc(n, i - 8, BigInt(this.length * 8), s), this.process(n, 0);\n    const a = rn(e), c = this.outputLen;\n    if (c % 4)\n      throw new Error(\"_sha2: outputLen should be aligned to 32bit\");\n    const l = c / 4, f = this.get();\n    if (l > f.length)\n      throw new Error(\"_sha2: outputLen bigger than state\");\n    for (let u = 0; u < l; u++)\n      a.setUint32(4 * u, f[u], s);\n  }\n  digest() {\n    const { buffer: e, outputLen: r } = this;\n    this.digestInto(e);\n    const n = e.slice(0, r);\n    return this.destroy(), n;\n  }\n  _cloneInto(e) {\n    e || (e = new this.constructor()), e.set(...this.get());\n    const { blockLen: r, buffer: n, length: i, finished: s, destroyed: o, pos: a } = this;\n    return e.length = i, e.pos = a, e.finished = s, e.destroyed = o, i % r && e.buffer.set(n), e;\n  }\n}\nconst kc = (t, e, r) => t & e ^ ~t & r, Sc = (t, e, r) => t & e ^ t & r ^ e & r, Oc = new Uint32Array([\n  1116352408,\n  1899447441,\n  3049323471,\n  3921009573,\n  961987163,\n  1508970993,\n  2453635748,\n  2870763221,\n  3624381080,\n  310598401,\n  607225278,\n  1426881987,\n  1925078388,\n  2162078206,\n  2614888103,\n  3248222580,\n  3835390401,\n  4022224774,\n  264347078,\n  604807628,\n  770255983,\n  1249150122,\n  1555081692,\n  1996064986,\n  2554220882,\n  2821834349,\n  2952996808,\n  3210313671,\n  3336571891,\n  3584528711,\n  113926993,\n  338241895,\n  666307205,\n  773529912,\n  1294757372,\n  1396182291,\n  1695183700,\n  1986661051,\n  2177026350,\n  2456956037,\n  2730485921,\n  2820302411,\n  3259730800,\n  3345764771,\n  3516065817,\n  3600352804,\n  4094571909,\n  275423344,\n  430227734,\n  506948616,\n  659060556,\n  883997877,\n  958139571,\n  1322822218,\n  1537002063,\n  1747873779,\n  1955562222,\n  2024104815,\n  2227730452,\n  2361852424,\n  2428436474,\n  2756734187,\n  3204031479,\n  3329325298\n]), Me = new Uint32Array([\n  1779033703,\n  3144134277,\n  1013904242,\n  2773480762,\n  1359893119,\n  2600822924,\n  528734635,\n  1541459225\n]), De = new Uint32Array(64);\nclass es extends Ec {\n  constructor() {\n    super(64, 32, 8, !1), this.A = Me[0] | 0, this.B = Me[1] | 0, this.C = Me[2] | 0, this.D = Me[3] | 0, this.E = Me[4] | 0, this.F = Me[5] | 0, this.G = Me[6] | 0, this.H = Me[7] | 0;\n  }\n  get() {\n    const { A: e, B: r, C: n, D: i, E: s, F: o, G: a, H: c } = this;\n    return [e, r, n, i, s, o, a, c];\n  }\n  set(e, r, n, i, s, o, a, c) {\n    this.A = e | 0, this.B = r | 0, this.C = n | 0, this.D = i | 0, this.E = s | 0, this.F = o | 0, this.G = a | 0, this.H = c | 0;\n  }\n  process(e, r) {\n    for (let u = 0; u < 16; u++, r += 4)\n      De[u] = e.getUint32(r, !1);\n    for (let u = 16; u < 64; u++) {\n      const h = De[u - 15], d = De[u - 2], p = Ae(h, 7) ^ Ae(h, 18) ^ h >>> 3, y = Ae(d, 17) ^ Ae(d, 19) ^ d >>> 10;\n      De[u] = y + De[u - 7] + p + De[u - 16] | 0;\n    }\n    let { A: n, B: i, C: s, D: o, E: a, F: c, G: l, H: f } = this;\n    for (let u = 0; u < 64; u++) {\n      const h = Ae(a, 6) ^ Ae(a, 11) ^ Ae(a, 25), d = f + h + kc(a, c, l) + Oc[u] + De[u] | 0, y = (Ae(n, 2) ^ Ae(n, 13) ^ Ae(n, 22)) + Sc(n, i, s) | 0;\n      f = l, l = c, c = a, a = o + d | 0, o = s, s = i, i = n, n = d + y | 0;\n    }\n    n = n + this.A | 0, i = i + this.B | 0, s = s + this.C | 0, o = o + this.D | 0, a = a + this.E | 0, c = c + this.F | 0, l = l + this.G | 0, f = f + this.H | 0, this.set(n, i, s, o, a, c, l, f);\n  }\n  roundClean() {\n    De.fill(0);\n  }\n  destroy() {\n    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);\n  }\n}\nclass Ac extends es {\n  constructor() {\n    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;\n  }\n}\nconst Or = Xo(() => new es());\nXo(() => new Ac());\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst ts = BigInt(0), Lr = BigInt(1), Cc = BigInt(2), $r = (t) => t instanceof Uint8Array, Ic = Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, \"0\"));\nfunction vt(t) {\n  if (!$r(t))\n    throw new Error(\"Uint8Array expected\");\n  let e = \"\";\n  for (let r = 0; r < t.length; r++)\n    e += Ic[t[r]];\n  return e;\n}\nfunction rs(t) {\n  const e = t.toString(16);\n  return e.length & 1 ? `0${e}` : e;\n}\nfunction zn(t) {\n  if (typeof t != \"string\")\n    throw new Error(\"hex string expected, got \" + typeof t);\n  return BigInt(t === \"\" ? \"0\" : `0x${t}`);\n}\nfunction wt(t) {\n  if (typeof t != \"string\")\n    throw new Error(\"hex string expected, got \" + typeof t);\n  if (t.length % 2)\n    throw new Error(\"hex string is invalid: unpadded \" + t.length);\n  const e = new Uint8Array(t.length / 2);\n  for (let r = 0; r < e.length; r++) {\n    const n = r * 2, i = t.slice(n, n + 2), s = Number.parseInt(i, 16);\n    if (Number.isNaN(s) || s < 0)\n      throw new Error(\"invalid byte sequence\");\n    e[r] = s;\n  }\n  return e;\n}\nfunction le(t) {\n  return zn(vt(t));\n}\nfunction Fn(t) {\n  if (!$r(t))\n    throw new Error(\"Uint8Array expected\");\n  return zn(vt(Uint8Array.from(t).reverse()));\n}\nconst et = (t, e) => wt(t.toString(16).padStart(e * 2, \"0\")), ns = (t, e) => et(t, e).reverse(), Rc = (t) => wt(rs(t));\nfunction ee(t, e, r) {\n  let n;\n  if (typeof e == \"string\")\n    try {\n      n = wt(e);\n    } catch (s) {\n      throw new Error(`${t} must be valid hex string, got \"${e}\". Cause: ${s}`);\n    }\n  else if ($r(e))\n    n = Uint8Array.from(e);\n  else\n    throw new Error(`${t} must be hex string or Uint8Array`);\n  const i = n.length;\n  if (typeof r == \"number\" && i !== r)\n    throw new Error(`${t} expected ${r} bytes, got ${i}`);\n  return n;\n}\nfunction he(...t) {\n  const e = new Uint8Array(t.reduce((n, i) => n + i.length, 0));\n  let r = 0;\n  return t.forEach((n) => {\n    if (!$r(n))\n      throw new Error(\"Uint8Array expected\");\n    e.set(n, r), r += n.length;\n  }), e;\n}\nfunction Tc(t, e) {\n  if (t.length !== e.length)\n    return !1;\n  for (let r = 0; r < t.length; r++)\n    if (t[r] !== e[r])\n      return !1;\n  return !0;\n}\nfunction qr(t) {\n  if (typeof t != \"string\")\n    throw new Error(`utf8ToBytes expected string, got ${typeof t}`);\n  return new TextEncoder().encode(t);\n}\nfunction Pc(t) {\n  let e;\n  for (e = 0; t > ts; t >>= Lr, e += 1)\n    ;\n  return e;\n}\nconst Bc = (t, e) => t >> BigInt(e) & Lr, Lc = (t, e, r) => t | (r ? Lr : ts) << BigInt(e), Kn = (t) => (Cc << BigInt(t - 1)) - Lr, nn = (t) => new Uint8Array(t), Ni = (t) => Uint8Array.from(t);\nfunction is(t, e, r) {\n  if (typeof t != \"number\" || t < 2)\n    throw new Error(\"hashLen must be a number\");\n  if (typeof e != \"number\" || e < 2)\n    throw new Error(\"qByteLen must be a number\");\n  if (typeof r != \"function\")\n    throw new Error(\"hmacFn must be a function\");\n  let n = nn(t), i = nn(t), s = 0;\n  const o = () => {\n    n.fill(1), i.fill(0), s = 0;\n  }, a = (...u) => r(i, n, ...u), c = (u = nn()) => {\n    i = a(Ni([0]), u), n = a(), u.length !== 0 && (i = a(Ni([1]), u), n = a());\n  }, l = () => {\n    if (s++ >= 1e3)\n      throw new Error(\"drbg: tried 1000 values\");\n    let u = 0;\n    const h = [];\n    for (; u < e; ) {\n      n = a();\n      const d = n.slice();\n      h.push(d), u += n.length;\n    }\n    return he(...h);\n  };\n  return (u, h) => {\n    o(), c(u);\n    let d;\n    for (; !(d = h(l())); )\n      c();\n    return o(), d;\n  };\n}\nconst $c = {\n  bigint: (t) => typeof t == \"bigint\",\n  function: (t) => typeof t == \"function\",\n  boolean: (t) => typeof t == \"boolean\",\n  string: (t) => typeof t == \"string\",\n  isSafeInteger: (t) => Number.isSafeInteger(t),\n  array: (t) => Array.isArray(t),\n  field: (t, e) => e.Fp.isValid(t),\n  hash: (t) => typeof t == \"function\" && Number.isSafeInteger(t.outputLen)\n};\nfunction kt(t, e, r = {}) {\n  const n = (i, s, o) => {\n    const a = $c[s];\n    if (typeof a != \"function\")\n      throw new Error(`Invalid validator \"${s}\", expected function`);\n    const c = t[i];\n    if (!(o && c === void 0) && !a(c, t))\n      throw new Error(`Invalid param ${String(i)}=${c} (${typeof c}), expected ${s}`);\n  };\n  for (const [i, s] of Object.entries(e))\n    n(i, s, !1);\n  for (const [i, s] of Object.entries(r))\n    n(i, s, !0);\n  return t;\n}\nconst qc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  bytesToHex: vt,\n  numberToHexUnpadded: rs,\n  hexToNumber: zn,\n  hexToBytes: wt,\n  bytesToNumberBE: le,\n  bytesToNumberLE: Fn,\n  numberToBytesBE: et,\n  numberToBytesLE: ns,\n  numberToVarBytesBE: Rc,\n  ensureBytes: ee,\n  concatBytes: he,\n  equalBytes: Tc,\n  utf8ToBytes: qr,\n  bitLen: Pc,\n  bitGet: Bc,\n  bitSet: Lc,\n  bitMask: Kn,\n  createHmacDrbg: is,\n  validateObject: kt\n}, Symbol.toStringTag, { value: \"Module\" }));\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst Q = BigInt(0), V = BigInt(1), at = BigInt(2), Nc = BigInt(3), Cn = BigInt(4), Ui = BigInt(5), ji = BigInt(8);\nBigInt(9);\nBigInt(16);\nfunction J(t, e) {\n  const r = t % e;\n  return r >= Q ? r : e + r;\n}\nfunction Uc(t, e, r) {\n  if (r <= Q || e < Q)\n    throw new Error(\"Expected power/modulo > 0\");\n  if (r === V)\n    return Q;\n  let n = V;\n  for (; e > Q; )\n    e & V && (n = n * t % r), t = t * t % r, e >>= V;\n  return n;\n}\nfunction be(t, e, r) {\n  let n = t;\n  for (; e-- > Q; )\n    n *= n, n %= r;\n  return n;\n}\nfunction In(t, e) {\n  if (t === Q || e <= Q)\n    throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);\n  let r = J(t, e), n = e, i = Q, s = V;\n  for (; r !== Q; ) {\n    const a = n / r, c = n % r, l = i - s * a;\n    n = r, r = c, i = s, s = l;\n  }\n  if (n !== V)\n    throw new Error(\"invert: does not exist\");\n  return J(i, e);\n}\nfunction jc(t) {\n  const e = (t - V) / at;\n  let r, n, i;\n  for (r = t - V, n = 0; r % at === Q; r /= at, n++)\n    ;\n  for (i = at; i < t && Uc(i, e, t) !== t - V; i++)\n    ;\n  if (n === 1) {\n    const o = (t + V) / Cn;\n    return function(c, l) {\n      const f = c.pow(l, o);\n      if (!c.eql(c.sqr(f), l))\n        throw new Error(\"Cannot find square root\");\n      return f;\n    };\n  }\n  const s = (r + V) / at;\n  return function(a, c) {\n    if (a.pow(c, e) === a.neg(a.ONE))\n      throw new Error(\"Cannot find square root\");\n    let l = n, f = a.pow(a.mul(a.ONE, i), r), u = a.pow(c, s), h = a.pow(c, r);\n    for (; !a.eql(h, a.ONE); ) {\n      if (a.eql(h, a.ZERO))\n        return a.ZERO;\n      let d = 1;\n      for (let y = a.sqr(h); d < l && !a.eql(y, a.ONE); d++)\n        y = a.sqr(y);\n      const p = a.pow(f, V << BigInt(l - d - 1));\n      f = a.sqr(p), u = a.mul(u, p), h = a.mul(h, f), l = d;\n    }\n    return u;\n  };\n}\nfunction Hc(t) {\n  if (t % Cn === Nc) {\n    const e = (t + V) / Cn;\n    return function(n, i) {\n      const s = n.pow(i, e);\n      if (!n.eql(n.sqr(s), i))\n        throw new Error(\"Cannot find square root\");\n      return s;\n    };\n  }\n  if (t % ji === Ui) {\n    const e = (t - Ui) / ji;\n    return function(n, i) {\n      const s = n.mul(i, at), o = n.pow(s, e), a = n.mul(i, o), c = n.mul(n.mul(a, at), o), l = n.mul(a, n.sub(c, n.ONE));\n      if (!n.eql(n.sqr(l), i))\n        throw new Error(\"Cannot find square root\");\n      return l;\n    };\n  }\n  return jc(t);\n}\nconst Mc = [\n  \"create\",\n  \"isValid\",\n  \"is0\",\n  \"neg\",\n  \"inv\",\n  \"sqrt\",\n  \"sqr\",\n  \"eql\",\n  \"add\",\n  \"sub\",\n  \"mul\",\n  \"pow\",\n  \"div\",\n  \"addN\",\n  \"subN\",\n  \"mulN\",\n  \"sqrN\"\n];\nfunction os(t) {\n  const e = {\n    ORDER: \"bigint\",\n    MASK: \"bigint\",\n    BYTES: \"isSafeInteger\",\n    BITS: \"isSafeInteger\"\n  }, r = Mc.reduce((n, i) => (n[i] = \"function\", n), e);\n  return kt(t, r);\n}\nfunction Dc(t, e, r) {\n  if (r < Q)\n    throw new Error(\"Expected power > 0\");\n  if (r === Q)\n    return t.ONE;\n  if (r === V)\n    return e;\n  let n = t.ONE, i = e;\n  for (; r > Q; )\n    r & V && (n = t.mul(n, i)), i = t.sqr(i), r >>= V;\n  return n;\n}\nfunction zc(t, e) {\n  const r = new Array(e.length), n = e.reduce((s, o, a) => t.is0(o) ? s : (r[a] = s, t.mul(s, o)), t.ONE), i = t.inv(n);\n  return e.reduceRight((s, o, a) => t.is0(o) ? s : (r[a] = t.mul(s, r[a]), t.mul(s, o)), i), r;\n}\nfunction Wn(t, e) {\n  const r = e !== void 0 ? e : t.toString(2).length, n = Math.ceil(r / 8);\n  return { nBitLength: r, nByteLength: n };\n}\nfunction Fc(t, e, r = !1, n = {}) {\n  if (t <= Q)\n    throw new Error(`Expected Fp ORDER > 0, got ${t}`);\n  const { nBitLength: i, nByteLength: s } = Wn(t, e);\n  if (s > 2048)\n    throw new Error(\"Field lengths over 2048 bytes are not supported\");\n  const o = Hc(t), a = Object.freeze({\n    ORDER: t,\n    BITS: i,\n    BYTES: s,\n    MASK: Kn(i),\n    ZERO: Q,\n    ONE: V,\n    create: (c) => J(c, t),\n    isValid: (c) => {\n      if (typeof c != \"bigint\")\n        throw new Error(`Invalid field element: expected bigint, got ${typeof c}`);\n      return Q <= c && c < t;\n    },\n    is0: (c) => c === Q,\n    isOdd: (c) => (c & V) === V,\n    neg: (c) => J(-c, t),\n    eql: (c, l) => c === l,\n    sqr: (c) => J(c * c, t),\n    add: (c, l) => J(c + l, t),\n    sub: (c, l) => J(c - l, t),\n    mul: (c, l) => J(c * l, t),\n    pow: (c, l) => Dc(a, c, l),\n    div: (c, l) => J(c * In(l, t), t),\n    sqrN: (c) => c * c,\n    addN: (c, l) => c + l,\n    subN: (c, l) => c - l,\n    mulN: (c, l) => c * l,\n    inv: (c) => In(c, t),\n    sqrt: n.sqrt || ((c) => o(a, c)),\n    invertBatch: (c) => zc(a, c),\n    cmov: (c, l, f) => f ? l : c,\n    toBytes: (c) => r ? ns(c, s) : et(c, s),\n    fromBytes: (c) => {\n      if (c.length !== s)\n        throw new Error(`Fp.fromBytes: expected ${s}, got ${c.length}`);\n      return r ? Fn(c) : le(c);\n    }\n  });\n  return Object.freeze(a);\n}\nfunction Kc(t, e, r = !1) {\n  t = ee(\"privateHash\", t);\n  const n = t.length, i = Wn(e).nByteLength + 8;\n  if (i < 24 || n < i || n > 1024)\n    throw new Error(`hashToPrivateScalar: expected ${i}-1024 bytes of input, got ${n}`);\n  const s = r ? Fn(t) : le(t);\n  return J(s, e - V) + V;\n}\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst Wc = BigInt(0), on = BigInt(1);\nfunction Vc(t, e) {\n  const r = (i, s) => {\n    const o = s.negate();\n    return i ? o : s;\n  }, n = (i) => {\n    const s = Math.ceil(e / i) + 1, o = 2 ** (i - 1);\n    return { windows: s, windowSize: o };\n  };\n  return {\n    constTimeNegate: r,\n    unsafeLadder(i, s) {\n      let o = t.ZERO, a = i;\n      for (; s > Wc; )\n        s & on && (o = o.add(a)), a = a.double(), s >>= on;\n      return o;\n    },\n    precomputeWindow(i, s) {\n      const { windows: o, windowSize: a } = n(s), c = [];\n      let l = i, f = l;\n      for (let u = 0; u < o; u++) {\n        f = l, c.push(f);\n        for (let h = 1; h < a; h++)\n          f = f.add(l), c.push(f);\n        l = f.double();\n      }\n      return c;\n    },\n    wNAF(i, s, o) {\n      const { windows: a, windowSize: c } = n(i);\n      let l = t.ZERO, f = t.BASE;\n      const u = BigInt(2 ** i - 1), h = 2 ** i, d = BigInt(i);\n      for (let p = 0; p < a; p++) {\n        const y = p * c;\n        let g = Number(o & u);\n        o >>= d, g > c && (g -= h, o += on);\n        const v = y, _ = y + Math.abs(g) - 1, m = p % 2 !== 0, C = g < 0;\n        g === 0 ? f = f.add(r(m, s[v])) : l = l.add(r(C, s[_]));\n      }\n      return { p: l, f };\n    },\n    wNAFCached(i, s, o, a) {\n      const c = i._WINDOW_SIZE || 1;\n      let l = s.get(i);\n      return l || (l = this.precomputeWindow(i, c), c !== 1 && s.set(i, a(l))), this.wNAF(c, l, o);\n    }\n  };\n}\nfunction ss(t) {\n  return os(t.Fp), kt(t, {\n    n: \"bigint\",\n    h: \"bigint\",\n    Gx: \"field\",\n    Gy: \"field\"\n  }, {\n    nBitLength: \"isSafeInteger\",\n    nByteLength: \"isSafeInteger\"\n  }), Object.freeze({\n    ...Wn(t.n, t.nBitLength),\n    ...t,\n    p: t.Fp.ORDER\n  });\n}\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nfunction Gc(t) {\n  const e = ss(t);\n  kt(e, {\n    a: \"field\",\n    b: \"field\"\n  }, {\n    allowedPrivateKeyLengths: \"array\",\n    wrapPrivateKey: \"boolean\",\n    isTorsionFree: \"function\",\n    clearCofactor: \"function\",\n    allowInfinityPoint: \"boolean\",\n    fromBytes: \"function\",\n    toBytes: \"function\"\n  });\n  const { endo: r, Fp: n, a: i } = e;\n  if (r) {\n    if (!n.eql(i, n.ZERO))\n      throw new Error(\"Endomorphism can only be defined for Koblitz curves that have a=0\");\n    if (typeof r != \"object\" || typeof r.beta != \"bigint\" || typeof r.splitScalar != \"function\")\n      throw new Error(\"Expected endomorphism with beta: bigint and splitScalar: function\");\n  }\n  return Object.freeze({ ...e });\n}\nconst { bytesToNumberBE: Zc, hexToBytes: Yc } = qc, lt = {\n  Err: class extends Error {\n    constructor(e = \"\") {\n      super(e);\n    }\n  },\n  _parseInt(t) {\n    const { Err: e } = lt;\n    if (t.length < 2 || t[0] !== 2)\n      throw new e(\"Invalid signature integer tag\");\n    const r = t[1], n = t.subarray(2, r + 2);\n    if (!r || n.length !== r)\n      throw new e(\"Invalid signature integer: wrong length\");\n    if (n[0] & 128)\n      throw new e(\"Invalid signature integer: negative\");\n    if (n[0] === 0 && !(n[1] & 128))\n      throw new e(\"Invalid signature integer: unnecessary leading zero\");\n    return { d: Zc(n), l: t.subarray(r + 2) };\n  },\n  toSig(t) {\n    const { Err: e } = lt, r = typeof t == \"string\" ? Yc(t) : t;\n    if (!(r instanceof Uint8Array))\n      throw new Error(\"ui8a expected\");\n    let n = r.length;\n    if (n < 2 || r[0] != 48)\n      throw new e(\"Invalid signature tag\");\n    if (r[1] !== n - 2)\n      throw new e(\"Invalid signature: incorrect length\");\n    const { d: i, l: s } = lt._parseInt(r.subarray(2)), { d: o, l: a } = lt._parseInt(s);\n    if (a.length)\n      throw new e(\"Invalid signature: left bytes after parsing\");\n    return { r: i, s: o };\n  },\n  hexFromSig(t) {\n    const e = (l) => Number.parseInt(l[0], 16) & 8 ? \"00\" + l : l, r = (l) => {\n      const f = l.toString(16);\n      return f.length & 1 ? `0${f}` : f;\n    }, n = e(r(t.s)), i = e(r(t.r)), s = n.length / 2, o = i.length / 2, a = r(s), c = r(o);\n    return `30${r(o + s + 4)}02${c}${i}02${a}${n}`;\n  }\n}, ke = BigInt(0), Y = BigInt(1), $e = BigInt(2), Ar = BigInt(3), Hi = BigInt(4);\nfunction Jc(t) {\n  const e = Gc(t), { Fp: r } = e, n = e.toBytes || ((p, y, g) => {\n    const v = y.toAffine();\n    return he(Uint8Array.from([4]), r.toBytes(v.x), r.toBytes(v.y));\n  }), i = e.fromBytes || ((p) => {\n    const y = p.subarray(1), g = r.fromBytes(y.subarray(0, r.BYTES)), v = r.fromBytes(y.subarray(r.BYTES, 2 * r.BYTES));\n    return { x: g, y: v };\n  });\n  function s(p) {\n    const { a: y, b: g } = e, v = r.sqr(p), _ = r.mul(v, p);\n    return r.add(r.add(_, r.mul(p, y)), g);\n  }\n  if (!r.eql(r.sqr(e.Gy), s(e.Gx)))\n    throw new Error(\"bad generator point: equation left != right\");\n  function o(p) {\n    return typeof p == \"bigint\" && ke < p && p < e.n;\n  }\n  function a(p) {\n    if (!o(p))\n      throw new Error(\"Expected valid bigint: 0 < bigint < curve.n\");\n  }\n  function c(p) {\n    const { allowedPrivateKeyLengths: y, nByteLength: g, wrapPrivateKey: v, n: _ } = e;\n    if (y && typeof p != \"bigint\") {\n      if (p instanceof Uint8Array && (p = vt(p)), typeof p != \"string\" || !y.includes(p.length))\n        throw new Error(\"Invalid key\");\n      p = p.padStart(g * 2, \"0\");\n    }\n    let m;\n    try {\n      m = typeof p == \"bigint\" ? p : le(ee(\"private key\", p, g));\n    } catch {\n      throw new Error(`private key must be ${g} bytes, hex or bigint, not ${typeof p}`);\n    }\n    return v && (m = J(m, _)), a(m), m;\n  }\n  const l = /* @__PURE__ */ new Map();\n  function f(p) {\n    if (!(p instanceof u))\n      throw new Error(\"ProjectivePoint expected\");\n  }\n  class u {\n    constructor(y, g, v) {\n      if (this.px = y, this.py = g, this.pz = v, y == null || !r.isValid(y))\n        throw new Error(\"x required\");\n      if (g == null || !r.isValid(g))\n        throw new Error(\"y required\");\n      if (v == null || !r.isValid(v))\n        throw new Error(\"z required\");\n    }\n    static fromAffine(y) {\n      const { x: g, y: v } = y || {};\n      if (!y || !r.isValid(g) || !r.isValid(v))\n        throw new Error(\"invalid affine point\");\n      if (y instanceof u)\n        throw new Error(\"projective point not allowed\");\n      const _ = (m) => r.eql(m, r.ZERO);\n      return _(g) && _(v) ? u.ZERO : new u(g, v, r.ONE);\n    }\n    get x() {\n      return this.toAffine().x;\n    }\n    get y() {\n      return this.toAffine().y;\n    }\n    static normalizeZ(y) {\n      const g = r.invertBatch(y.map((v) => v.pz));\n      return y.map((v, _) => v.toAffine(g[_])).map(u.fromAffine);\n    }\n    static fromHex(y) {\n      const g = u.fromAffine(i(ee(\"pointHex\", y)));\n      return g.assertValidity(), g;\n    }\n    static fromPrivateKey(y) {\n      return u.BASE.multiply(c(y));\n    }\n    _setWindowSize(y) {\n      this._WINDOW_SIZE = y, l.delete(this);\n    }\n    assertValidity() {\n      if (this.is0()) {\n        if (e.allowInfinityPoint)\n          return;\n        throw new Error(\"bad point: ZERO\");\n      }\n      const { x: y, y: g } = this.toAffine();\n      if (!r.isValid(y) || !r.isValid(g))\n        throw new Error(\"bad point: x or y not FE\");\n      const v = r.sqr(g), _ = s(y);\n      if (!r.eql(v, _))\n        throw new Error(\"bad point: equation left != right\");\n      if (!this.isTorsionFree())\n        throw new Error(\"bad point: not in prime-order subgroup\");\n    }\n    hasEvenY() {\n      const { y } = this.toAffine();\n      if (r.isOdd)\n        return !r.isOdd(y);\n      throw new Error(\"Field doesn't support isOdd\");\n    }\n    equals(y) {\n      f(y);\n      const { px: g, py: v, pz: _ } = this, { px: m, py: C, pz: O } = y, w = r.eql(r.mul(g, O), r.mul(m, _)), x = r.eql(r.mul(v, O), r.mul(C, _));\n      return w && x;\n    }\n    negate() {\n      return new u(this.px, r.neg(this.py), this.pz);\n    }\n    double() {\n      const { a: y, b: g } = e, v = r.mul(g, Ar), { px: _, py: m, pz: C } = this;\n      let O = r.ZERO, w = r.ZERO, x = r.ZERO, A = r.mul(_, _), B = r.mul(m, m), L = r.mul(C, C), P = r.mul(_, m);\n      return P = r.add(P, P), x = r.mul(_, C), x = r.add(x, x), O = r.mul(y, x), w = r.mul(v, L), w = r.add(O, w), O = r.sub(B, w), w = r.add(B, w), w = r.mul(O, w), O = r.mul(P, O), x = r.mul(v, x), L = r.mul(y, L), P = r.sub(A, L), P = r.mul(y, P), P = r.add(P, x), x = r.add(A, A), A = r.add(x, A), A = r.add(A, L), A = r.mul(A, P), w = r.add(w, A), L = r.mul(m, C), L = r.add(L, L), A = r.mul(L, P), O = r.sub(O, A), x = r.mul(L, B), x = r.add(x, x), x = r.add(x, x), new u(O, w, x);\n    }\n    add(y) {\n      f(y);\n      const { px: g, py: v, pz: _ } = this, { px: m, py: C, pz: O } = y;\n      let w = r.ZERO, x = r.ZERO, A = r.ZERO;\n      const B = e.a, L = r.mul(e.b, Ar);\n      let P = r.mul(g, m), F = r.mul(v, C), z = r.mul(_, O), G = r.add(g, v), E = r.add(m, C);\n      G = r.mul(G, E), E = r.add(P, F), G = r.sub(G, E), E = r.add(g, _);\n      let R = r.add(m, O);\n      return E = r.mul(E, R), R = r.add(P, z), E = r.sub(E, R), R = r.add(v, _), w = r.add(C, O), R = r.mul(R, w), w = r.add(F, z), R = r.sub(R, w), A = r.mul(B, E), w = r.mul(L, z), A = r.add(w, A), w = r.sub(F, A), A = r.add(F, A), x = r.mul(w, A), F = r.add(P, P), F = r.add(F, P), z = r.mul(B, z), E = r.mul(L, E), F = r.add(F, z), z = r.sub(P, z), z = r.mul(B, z), E = r.add(E, z), P = r.mul(F, E), x = r.add(x, P), P = r.mul(R, E), w = r.mul(G, w), w = r.sub(w, P), P = r.mul(G, F), A = r.mul(R, A), A = r.add(A, P), new u(w, x, A);\n    }\n    subtract(y) {\n      return this.add(y.negate());\n    }\n    is0() {\n      return this.equals(u.ZERO);\n    }\n    wNAF(y) {\n      return d.wNAFCached(this, l, y, (g) => {\n        const v = r.invertBatch(g.map((_) => _.pz));\n        return g.map((_, m) => _.toAffine(v[m])).map(u.fromAffine);\n      });\n    }\n    multiplyUnsafe(y) {\n      const g = u.ZERO;\n      if (y === ke)\n        return g;\n      if (a(y), y === Y)\n        return this;\n      const { endo: v } = e;\n      if (!v)\n        return d.unsafeLadder(this, y);\n      let { k1neg: _, k1: m, k2neg: C, k2: O } = v.splitScalar(y), w = g, x = g, A = this;\n      for (; m > ke || O > ke; )\n        m & Y && (w = w.add(A)), O & Y && (x = x.add(A)), A = A.double(), m >>= Y, O >>= Y;\n      return _ && (w = w.negate()), C && (x = x.negate()), x = new u(r.mul(x.px, v.beta), x.py, x.pz), w.add(x);\n    }\n    multiply(y) {\n      a(y);\n      let g = y, v, _;\n      const { endo: m } = e;\n      if (m) {\n        const { k1neg: C, k1: O, k2neg: w, k2: x } = m.splitScalar(g);\n        let { p: A, f: B } = this.wNAF(O), { p: L, f: P } = this.wNAF(x);\n        A = d.constTimeNegate(C, A), L = d.constTimeNegate(w, L), L = new u(r.mul(L.px, m.beta), L.py, L.pz), v = A.add(L), _ = B.add(P);\n      } else {\n        const { p: C, f: O } = this.wNAF(g);\n        v = C, _ = O;\n      }\n      return u.normalizeZ([v, _])[0];\n    }\n    multiplyAndAddUnsafe(y, g, v) {\n      const _ = u.BASE, m = (O, w) => w === ke || w === Y || !O.equals(_) ? O.multiplyUnsafe(w) : O.multiply(w), C = m(this, g).add(m(y, v));\n      return C.is0() ? void 0 : C;\n    }\n    toAffine(y) {\n      const { px: g, py: v, pz: _ } = this, m = this.is0();\n      y == null && (y = m ? r.ONE : r.inv(_));\n      const C = r.mul(g, y), O = r.mul(v, y), w = r.mul(_, y);\n      if (m)\n        return { x: r.ZERO, y: r.ZERO };\n      if (!r.eql(w, r.ONE))\n        throw new Error(\"invZ was invalid\");\n      return { x: C, y: O };\n    }\n    isTorsionFree() {\n      const { h: y, isTorsionFree: g } = e;\n      if (y === Y)\n        return !0;\n      if (g)\n        return g(u, this);\n      throw new Error(\"isTorsionFree() has not been declared for the elliptic curve\");\n    }\n    clearCofactor() {\n      const { h: y, clearCofactor: g } = e;\n      return y === Y ? this : g ? g(u, this) : this.multiplyUnsafe(e.h);\n    }\n    toRawBytes(y = !0) {\n      return this.assertValidity(), n(u, this, y);\n    }\n    toHex(y = !0) {\n      return vt(this.toRawBytes(y));\n    }\n  }\n  u.BASE = new u(e.Gx, e.Gy, r.ONE), u.ZERO = new u(r.ZERO, r.ONE, r.ZERO);\n  const h = e.nBitLength, d = Vc(u, e.endo ? Math.ceil(h / 2) : h);\n  return {\n    CURVE: e,\n    ProjectivePoint: u,\n    normPrivateKeyToScalar: c,\n    weierstrassEquation: s,\n    isWithinCurveOrder: o\n  };\n}\nfunction Xc(t) {\n  const e = ss(t);\n  return kt(e, {\n    hash: \"hash\",\n    hmac: \"function\",\n    randomBytes: \"function\"\n  }, {\n    bits2int: \"function\",\n    bits2int_modN: \"function\",\n    lowS: \"boolean\"\n  }), Object.freeze({ lowS: !0, ...e });\n}\nfunction Qc(t) {\n  const e = Xc(t), { Fp: r, n } = e, i = r.BYTES + 1, s = 2 * r.BYTES + 1;\n  function o(E) {\n    return ke < E && E < r.ORDER;\n  }\n  function a(E) {\n    return J(E, n);\n  }\n  function c(E) {\n    return In(E, n);\n  }\n  const { ProjectivePoint: l, normPrivateKeyToScalar: f, weierstrassEquation: u, isWithinCurveOrder: h } = Jc({\n    ...e,\n    toBytes(E, R, q) {\n      const H = R.toAffine(), D = r.toBytes(H.x), X = he;\n      return q ? X(Uint8Array.from([R.hasEvenY() ? 2 : 3]), D) : X(Uint8Array.from([4]), D, r.toBytes(H.y));\n    },\n    fromBytes(E) {\n      const R = E.length, q = E[0], H = E.subarray(1);\n      if (R === i && (q === 2 || q === 3)) {\n        const D = le(H);\n        if (!o(D))\n          throw new Error(\"Point is not on curve\");\n        const X = u(D);\n        let oe = r.sqrt(X);\n        const re = (oe & Y) === Y;\n        return (q & 1) === 1 !== re && (oe = r.neg(oe)), { x: D, y: oe };\n      } else if (R === s && q === 4) {\n        const D = r.fromBytes(H.subarray(0, r.BYTES)), X = r.fromBytes(H.subarray(r.BYTES, 2 * r.BYTES));\n        return { x: D, y: X };\n      } else\n        throw new Error(`Point of length ${R} was invalid. Expected ${i} compressed bytes or ${s} uncompressed bytes`);\n    }\n  }), d = (E) => vt(et(E, e.nByteLength));\n  function p(E) {\n    const R = n >> Y;\n    return E > R;\n  }\n  function y(E) {\n    return p(E) ? a(-E) : E;\n  }\n  const g = (E, R, q) => le(E.slice(R, q));\n  class v {\n    constructor(R, q, H) {\n      this.r = R, this.s = q, this.recovery = H, this.assertValidity();\n    }\n    static fromCompact(R) {\n      const q = e.nByteLength;\n      return R = ee(\"compactSignature\", R, q * 2), new v(g(R, 0, q), g(R, q, 2 * q));\n    }\n    static fromDER(R) {\n      const { r: q, s: H } = lt.toSig(ee(\"DER\", R));\n      return new v(q, H);\n    }\n    assertValidity() {\n      if (!h(this.r))\n        throw new Error(\"r must be 0 < r < CURVE.n\");\n      if (!h(this.s))\n        throw new Error(\"s must be 0 < s < CURVE.n\");\n    }\n    addRecoveryBit(R) {\n      return new v(this.r, this.s, R);\n    }\n    recoverPublicKey(R) {\n      const { r: q, s: H, recovery: D } = this, X = x(ee(\"msgHash\", R));\n      if (D == null || ![0, 1, 2, 3].includes(D))\n        throw new Error(\"recovery id invalid\");\n      const oe = D === 2 || D === 3 ? q + e.n : q;\n      if (oe >= r.ORDER)\n        throw new Error(\"recovery id 2 or 3 invalid\");\n      const re = (D & 1) === 0 ? \"02\" : \"03\", _e = l.fromHex(re + d(oe)), Oe = c(oe), Ue = a(-X * Oe), Pe = a(H * Oe), ye = l.BASE.multiplyAndAddUnsafe(_e, Ue, Pe);\n      if (!ye)\n        throw new Error(\"point at infinify\");\n      return ye.assertValidity(), ye;\n    }\n    hasHighS() {\n      return p(this.s);\n    }\n    normalizeS() {\n      return this.hasHighS() ? new v(this.r, a(-this.s), this.recovery) : this;\n    }\n    toDERRawBytes() {\n      return wt(this.toDERHex());\n    }\n    toDERHex() {\n      return lt.hexFromSig({ r: this.r, s: this.s });\n    }\n    toCompactRawBytes() {\n      return wt(this.toCompactHex());\n    }\n    toCompactHex() {\n      return d(this.r) + d(this.s);\n    }\n  }\n  const _ = {\n    isValidPrivateKey(E) {\n      try {\n        return f(E), !0;\n      } catch {\n        return !1;\n      }\n    },\n    normPrivateKeyToScalar: f,\n    randomPrivateKey: () => {\n      const E = e.randomBytes(r.BYTES + 8), R = Kc(E, n);\n      return et(R, e.nByteLength);\n    },\n    precompute(E = 8, R = l.BASE) {\n      return R._setWindowSize(E), R.multiply(BigInt(3)), R;\n    }\n  };\n  function m(E, R = !0) {\n    return l.fromPrivateKey(E).toRawBytes(R);\n  }\n  function C(E) {\n    const R = E instanceof Uint8Array, q = typeof E == \"string\", H = (R || q) && E.length;\n    return R ? H === i || H === s : q ? H === 2 * i || H === 2 * s : E instanceof l;\n  }\n  function O(E, R, q = !0) {\n    if (C(E))\n      throw new Error(\"first arg must be private key\");\n    if (!C(R))\n      throw new Error(\"second arg must be public key\");\n    return l.fromHex(R).multiply(f(E)).toRawBytes(q);\n  }\n  const w = e.bits2int || function(E) {\n    const R = le(E), q = E.length * 8 - e.nBitLength;\n    return q > 0 ? R >> BigInt(q) : R;\n  }, x = e.bits2int_modN || function(E) {\n    return a(w(E));\n  }, A = Kn(e.nBitLength);\n  function B(E) {\n    if (typeof E != \"bigint\")\n      throw new Error(\"bigint expected\");\n    if (!(ke <= E && E < A))\n      throw new Error(`bigint expected < 2^${e.nBitLength}`);\n    return et(E, e.nByteLength);\n  }\n  function L(E, R, q = P) {\n    if ([\"recovered\", \"canonical\"].some((me) => me in q))\n      throw new Error(\"sign() legacy options not supported\");\n    const { hash: H, randomBytes: D } = e;\n    let { lowS: X, prehash: oe, extraEntropy: re } = q;\n    X == null && (X = !0), E = ee(\"msgHash\", E), oe && (E = ee(\"prehashed msgHash\", H(E)));\n    const _e = x(E), Oe = f(R), Ue = [B(Oe), B(_e)];\n    if (re != null) {\n      const me = re === !0 ? D(r.BYTES) : re;\n      Ue.push(ee(\"extraEntropy\", me, r.BYTES));\n    }\n    const Pe = he(...Ue), ye = _e;\n    function je(me) {\n      const xe = w(me);\n      if (!h(xe))\n        return;\n      const lr = c(xe), Be = l.BASE.multiply(xe).toAffine(), fe = a(Be.x);\n      if (fe === ke)\n        return;\n      const He = a(lr * a(ye + fe * Oe));\n      if (He === ke)\n        return;\n      let it = (Be.x === fe ? 0 : 2) | Number(Be.y & Y), ot = He;\n      return X && p(He) && (ot = y(He), it ^= 1), new v(fe, ot, it);\n    }\n    return { seed: Pe, k2sig: je };\n  }\n  const P = { lowS: e.lowS, prehash: !1 }, F = { lowS: e.lowS, prehash: !1 };\n  function z(E, R, q = P) {\n    const { seed: H, k2sig: D } = L(E, R, q);\n    return is(e.hash.outputLen, e.nByteLength, e.hmac)(H, D);\n  }\n  l.BASE._setWindowSize(8);\n  function G(E, R, q, H = F) {\n    var Be;\n    const D = E;\n    if (R = ee(\"msgHash\", R), q = ee(\"publicKey\", q), \"strict\" in H)\n      throw new Error(\"options.strict was renamed to lowS\");\n    const { lowS: X, prehash: oe } = H;\n    let re, _e;\n    try {\n      if (typeof D == \"string\" || D instanceof Uint8Array)\n        try {\n          re = v.fromDER(D);\n        } catch (fe) {\n          if (!(fe instanceof lt.Err))\n            throw fe;\n          re = v.fromCompact(D);\n        }\n      else if (typeof D == \"object\" && typeof D.r == \"bigint\" && typeof D.s == \"bigint\") {\n        const { r: fe, s: He } = D;\n        re = new v(fe, He);\n      } else\n        throw new Error(\"PARSE\");\n      _e = l.fromHex(q);\n    } catch (fe) {\n      if (fe.message === \"PARSE\")\n        throw new Error(\"signature must be Signature instance, Uint8Array or hex string\");\n      return !1;\n    }\n    if (X && re.hasHighS())\n      return !1;\n    oe && (R = e.hash(R));\n    const { r: Oe, s: Ue } = re, Pe = x(R), ye = c(Ue), je = a(Pe * ye), me = a(Oe * ye), xe = (Be = l.BASE.multiplyAndAddUnsafe(_e, je, me)) == null ? void 0 : Be.toAffine();\n    return xe ? a(xe.x) === Oe : !1;\n  }\n  return {\n    CURVE: e,\n    getPublicKey: m,\n    getSharedSecret: O,\n    sign: z,\n    verify: G,\n    ProjectivePoint: l,\n    Signature: v,\n    utils: _\n  };\n}\nfunction eu(t, e) {\n  const r = t.ORDER;\n  let n = ke;\n  for (let h = r - Y; h % $e === ke; h /= $e)\n    n += Y;\n  const i = n, s = (r - Y) / $e ** i, o = (s - Y) / $e, a = $e ** i - Y, c = $e ** (i - Y), l = t.pow(e, s), f = t.pow(e, (s + Y) / $e);\n  let u = (h, d) => {\n    let p = l, y = t.pow(d, a), g = t.sqr(y);\n    g = t.mul(g, d);\n    let v = t.mul(h, g);\n    v = t.pow(v, o), v = t.mul(v, y), y = t.mul(v, d), g = t.mul(v, h);\n    let _ = t.mul(g, y);\n    v = t.pow(_, c);\n    let m = t.eql(v, t.ONE);\n    y = t.mul(g, f), v = t.mul(_, p), g = t.cmov(y, g, m), _ = t.cmov(v, _, m);\n    for (let C = i; C > Y; C--) {\n      let O = $e ** (C - $e), w = t.pow(_, O);\n      const x = t.eql(w, t.ONE);\n      y = t.mul(g, p), p = t.mul(p, p), w = t.mul(_, p), g = t.cmov(y, g, x), _ = t.cmov(w, _, x);\n    }\n    return { isValid: m, value: g };\n  };\n  if (t.ORDER % Hi === Ar) {\n    const h = (t.ORDER - Ar) / Hi, d = t.sqrt(t.neg(e));\n    u = (p, y) => {\n      let g = t.sqr(y);\n      const v = t.mul(p, y);\n      g = t.mul(g, v);\n      let _ = t.pow(g, h);\n      _ = t.mul(_, v);\n      const m = t.mul(_, d), C = t.mul(t.sqr(_), y), O = t.eql(C, p);\n      let w = t.cmov(m, _, O);\n      return { isValid: O, value: w };\n    };\n  }\n  return u;\n}\nfunction tu(t, e) {\n  if (os(t), !t.isValid(e.A) || !t.isValid(e.B) || !t.isValid(e.Z))\n    throw new Error(\"mapToCurveSimpleSWU: invalid opts\");\n  const r = eu(t, e.Z);\n  if (!t.isOdd)\n    throw new Error(\"Fp.isOdd is not implemented!\");\n  return (n) => {\n    let i, s, o, a, c, l, f, u;\n    i = t.sqr(n), i = t.mul(i, e.Z), s = t.sqr(i), s = t.add(s, i), o = t.add(s, t.ONE), o = t.mul(o, e.B), a = t.cmov(e.Z, t.neg(s), !t.eql(s, t.ZERO)), a = t.mul(a, e.A), s = t.sqr(o), l = t.sqr(a), c = t.mul(l, e.A), s = t.add(s, c), s = t.mul(s, o), l = t.mul(l, a), c = t.mul(l, e.B), s = t.add(s, c), f = t.mul(i, o);\n    const { isValid: h, value: d } = r(s, l);\n    u = t.mul(i, n), u = t.mul(u, d), f = t.cmov(f, o, h), u = t.cmov(u, d, h);\n    const p = t.isOdd(n) === t.isOdd(u);\n    return u = t.cmov(t.neg(u), u, p), f = t.div(f, a), { x: f, y: u };\n  };\n}\nfunction ru(t) {\n  if (t instanceof Uint8Array)\n    return t;\n  if (typeof t == \"string\")\n    return qr(t);\n  throw new Error(\"DST must be Uint8Array or string\");\n}\nconst nu = le;\nfunction Ze(t, e) {\n  if (t < 0 || t >= 1 << 8 * e)\n    throw new Error(`bad I2OSP call: value=${t} length=${e}`);\n  const r = Array.from({ length: e }).fill(0);\n  for (let n = e - 1; n >= 0; n--)\n    r[n] = t & 255, t >>>= 8;\n  return new Uint8Array(r);\n}\nfunction iu(t, e) {\n  const r = new Uint8Array(t.length);\n  for (let n = 0; n < t.length; n++)\n    r[n] = t[n] ^ e[n];\n  return r;\n}\nfunction tr(t) {\n  if (!(t instanceof Uint8Array))\n    throw new Error(\"Uint8Array expected\");\n}\nfunction Vn(t) {\n  if (!Number.isSafeInteger(t))\n    throw new Error(\"number expected\");\n}\nfunction ou(t, e, r, n) {\n  tr(t), tr(e), Vn(r), e.length > 255 && (e = n(he(qr(\"H2C-OVERSIZE-DST-\"), e)));\n  const { outputLen: i, blockLen: s } = n, o = Math.ceil(r / i);\n  if (o > 255)\n    throw new Error(\"Invalid xmd length\");\n  const a = he(e, Ze(e.length, 1)), c = Ze(0, s), l = Ze(r, 2), f = new Array(o), u = n(he(c, t, l, Ze(0, 1), a));\n  f[0] = n(he(u, Ze(1, 1), a));\n  for (let d = 1; d <= o; d++) {\n    const p = [iu(u, f[d - 1]), Ze(d + 1, 1), a];\n    f[d] = n(he(...p));\n  }\n  return he(...f).slice(0, r);\n}\nfunction su(t, e, r, n, i) {\n  if (tr(t), tr(e), Vn(r), e.length > 255) {\n    const s = Math.ceil(2 * n / 8);\n    e = i.create({ dkLen: s }).update(qr(\"H2C-OVERSIZE-DST-\")).update(e).digest();\n  }\n  if (r > 65535 || e.length > 255)\n    throw new Error(\"expand_message_xof: invalid lenInBytes\");\n  return i.create({ dkLen: r }).update(t).update(Ze(r, 2)).update(e).update(Ze(e.length, 1)).digest();\n}\nfunction Mi(t, e, r) {\n  kt(r, {\n    DST: \"string\",\n    p: \"bigint\",\n    m: \"isSafeInteger\",\n    k: \"isSafeInteger\",\n    hash: \"hash\"\n  });\n  const { p: n, k: i, m: s, hash: o, expand: a, DST: c } = r;\n  tr(t), Vn(e);\n  const l = ru(c), f = n.toString(2).length, u = Math.ceil((f + i) / 8), h = e * s * u;\n  let d;\n  if (a === \"xmd\")\n    d = ou(t, l, h, o);\n  else if (a === \"xof\")\n    d = su(t, l, h, i, o);\n  else if (a === \"_internal_pass\")\n    d = t;\n  else\n    throw new Error('expand must be \"xmd\" or \"xof\"');\n  const p = new Array(e);\n  for (let y = 0; y < e; y++) {\n    const g = new Array(s);\n    for (let v = 0; v < s; v++) {\n      const _ = u * (v + y * s), m = d.subarray(_, _ + u);\n      g[v] = J(nu(m), n);\n    }\n    p[y] = g;\n  }\n  return p;\n}\nfunction au(t, e) {\n  const r = e.map((n) => Array.from(n).reverse());\n  return (n, i) => {\n    const [s, o, a, c] = r.map((l) => l.reduce((f, u) => t.add(t.mul(f, n), u)));\n    return n = t.div(s, o), i = t.mul(i, t.div(a, c)), { x: n, y: i };\n  };\n}\nfunction cu(t, e, r) {\n  if (typeof e != \"function\")\n    throw new Error(\"mapToCurve() must be defined\");\n  return {\n    hashToCurve(n, i) {\n      const s = Mi(n, 2, { ...r, DST: r.DST, ...i }), o = t.fromAffine(e(s[0])), a = t.fromAffine(e(s[1])), c = o.add(a).clearCofactor();\n      return c.assertValidity(), c;\n    },\n    encodeToCurve(n, i) {\n      const s = Mi(n, 1, { ...r, DST: r.encodeDST, ...i }), o = t.fromAffine(e(s[0])).clearCofactor();\n      return o.assertValidity(), o;\n    }\n  };\n}\nclass as extends Jo {\n  constructor(e, r) {\n    super(), this.finished = !1, this.destroyed = !1, ut.hash(e);\n    const n = Dn(r);\n    if (this.iHash = e.create(), typeof this.iHash.update != \"function\")\n      throw new TypeError(\"Expected instance of class which extends utils.Hash\");\n    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;\n    const i = this.blockLen, s = new Uint8Array(i);\n    s.set(n.length > i ? e.create().update(n).digest() : n);\n    for (let o = 0; o < s.length; o++)\n      s[o] ^= 54;\n    this.iHash.update(s), this.oHash = e.create();\n    for (let o = 0; o < s.length; o++)\n      s[o] ^= 106;\n    this.oHash.update(s), s.fill(0);\n  }\n  update(e) {\n    return ut.exists(this), this.iHash.update(e), this;\n  }\n  digestInto(e) {\n    ut.exists(this), ut.bytes(e, this.outputLen), this.finished = !0, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy();\n  }\n  digest() {\n    const e = new Uint8Array(this.oHash.outputLen);\n    return this.digestInto(e), e;\n  }\n  _cloneInto(e) {\n    e || (e = Object.create(Object.getPrototypeOf(this), {}));\n    const { oHash: r, iHash: n, finished: i, destroyed: s, blockLen: o, outputLen: a } = this;\n    return e = e, e.finished = i, e.destroyed = s, e.blockLen = o, e.outputLen = a, e.oHash = r._cloneInto(e.oHash), e.iHash = n._cloneInto(e.iHash), e;\n  }\n  destroy() {\n    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();\n  }\n}\nconst cs = (t, e, r) => new as(t, e).update(r).digest();\ncs.create = (t, e) => new as(t, e);\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nfunction uu(t) {\n  return {\n    hash: t,\n    hmac: (e, ...r) => cs(t, e, mc(...r)),\n    randomBytes: Qo\n  };\n}\nfunction lu(t, e) {\n  const r = (n) => Qc({ ...t, ...uu(n) });\n  return Object.freeze({ ...r(e), create: r });\n}\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst Nr = BigInt(\"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f\"), Cr = BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\"), us = BigInt(1), Ir = BigInt(2), Di = (t, e) => (t + e / Ir) / e;\nfunction ls(t) {\n  const e = Nr, r = BigInt(3), n = BigInt(6), i = BigInt(11), s = BigInt(22), o = BigInt(23), a = BigInt(44), c = BigInt(88), l = t * t * t % e, f = l * l * t % e, u = be(f, r, e) * f % e, h = be(u, r, e) * f % e, d = be(h, Ir, e) * l % e, p = be(d, i, e) * d % e, y = be(p, s, e) * p % e, g = be(y, a, e) * y % e, v = be(g, c, e) * g % e, _ = be(v, a, e) * y % e, m = be(_, r, e) * f % e, C = be(m, o, e) * p % e, O = be(C, n, e) * l % e, w = be(O, Ir, e);\n  if (!tt.eql(tt.sqr(w), t))\n    throw new Error(\"Cannot find square root\");\n  return w;\n}\nconst tt = Fc(Nr, void 0, void 0, { sqrt: ls }), ue = lu({\n  a: BigInt(0),\n  b: BigInt(7),\n  Fp: tt,\n  n: Cr,\n  Gx: BigInt(\"55066263022277343669578718895168534326250603453777594175500187360389116729240\"),\n  Gy: BigInt(\"32670510020758816978083085130507043184471273380659243275938904335757337482424\"),\n  h: BigInt(1),\n  lowS: !0,\n  endo: {\n    beta: BigInt(\"0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\"),\n    splitScalar: (t) => {\n      const e = Cr, r = BigInt(\"0x3086d221a7d46bcde86c90e49284eb15\"), n = -us * BigInt(\"0xe4437ed6010e88286f547fa90abfe4c3\"), i = BigInt(\"0x114ca50f7a8e2f3f657c1108d9d44cfd8\"), s = r, o = BigInt(\"0x100000000000000000000000000000000\"), a = Di(s * t, e), c = Di(-n * t, e);\n      let l = J(t - a * r - c * i, e), f = J(-a * n - c * s, e);\n      const u = l > o, h = f > o;\n      if (u && (l = e - l), h && (f = e - f), l > o || f > o)\n        throw new Error(\"splitScalar: Endomorphism failed, k=\" + t);\n      return { k1neg: u, k1: l, k2neg: h, k2: f };\n    }\n  }\n}, Or), Ur = BigInt(0), fs = (t) => typeof t == \"bigint\" && Ur < t && t < Nr, fu = (t) => typeof t == \"bigint\" && Ur < t && t < Cr, zi = {};\nfunction Rr(t, ...e) {\n  let r = zi[t];\n  if (r === void 0) {\n    const n = Or(Uint8Array.from(t, (i) => i.charCodeAt(0)));\n    r = he(n, n), zi[t] = r;\n  }\n  return Or(he(r, ...e));\n}\nconst Gn = (t) => t.toRawBytes(!0).slice(1), Rn = (t) => et(t, 32), sn = (t) => J(t, Nr), rr = (t) => J(t, Cr), Zn = ue.ProjectivePoint, hu = (t, e, r) => Zn.BASE.multiplyAndAddUnsafe(t, e, r);\nfunction Tn(t) {\n  let e = ue.utils.normPrivateKeyToScalar(t), r = Zn.fromPrivateKey(e);\n  return { scalar: r.hasEvenY() ? e : rr(-e), bytes: Gn(r) };\n}\nfunction hs(t) {\n  if (!fs(t))\n    throw new Error(\"bad x: need 0 < x < p\");\n  const e = sn(t * t), r = sn(e * t + BigInt(7));\n  let n = ls(r);\n  n % Ir !== Ur && (n = sn(-n));\n  const i = new Zn(t, n, us);\n  return i.assertValidity(), i;\n}\nfunction ds(...t) {\n  return rr(le(Rr(\"BIP0340/challenge\", ...t)));\n}\nfunction du(t) {\n  return Tn(t).bytes;\n}\nfunction pu(t, e, r = Qo(32)) {\n  const n = ee(\"message\", t), { bytes: i, scalar: s } = Tn(e), o = ee(\"auxRand\", r, 32), a = Rn(s ^ le(Rr(\"BIP0340/aux\", o))), c = Rr(\"BIP0340/nonce\", a, i, n), l = rr(le(c));\n  if (l === Ur)\n    throw new Error(\"sign failed: k is zero\");\n  const { bytes: f, scalar: u } = Tn(l), h = ds(f, i, n), d = new Uint8Array(64);\n  if (d.set(f, 0), d.set(Rn(rr(u + h * s)), 32), !ps(d, n, i))\n    throw new Error(\"sign: Invalid signature produced\");\n  return d;\n}\nfunction ps(t, e, r) {\n  const n = ee(\"signature\", t, 64), i = ee(\"message\", e), s = ee(\"publicKey\", r, 32);\n  try {\n    const o = hs(le(s)), a = le(n.subarray(0, 32));\n    if (!fs(a))\n      return !1;\n    const c = le(n.subarray(32, 64));\n    if (!fu(c))\n      return !1;\n    const l = ds(Rn(a), Gn(o), i), f = hu(o, c, rr(-l));\n    return !(!f || !f.hasEvenY() || f.toAffine().x !== a);\n  } catch {\n    return !1;\n  }\n}\nconst St = {\n  getPublicKey: du,\n  sign: pu,\n  verify: ps,\n  utils: {\n    randomPrivateKey: ue.utils.randomPrivateKey,\n    lift_x: hs,\n    pointToBytes: Gn,\n    numberToBytesBE: et,\n    bytesToNumberBE: le,\n    taggedHash: Rr,\n    mod: J\n  }\n}, yu = au(tt, [\n  [\n    \"0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7\",\n    \"0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581\",\n    \"0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262\",\n    \"0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c\"\n  ],\n  [\n    \"0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b\",\n    \"0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14\",\n    \"0x0000000000000000000000000000000000000000000000000000000000000001\"\n  ],\n  [\n    \"0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c\",\n    \"0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3\",\n    \"0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931\",\n    \"0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84\"\n  ],\n  [\n    \"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b\",\n    \"0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573\",\n    \"0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f\",\n    \"0x0000000000000000000000000000000000000000000000000000000000000001\"\n  ]\n].map((t) => t.map((e) => BigInt(e)))), gu = tu(tt, {\n  A: BigInt(\"0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533\"),\n  B: BigInt(\"1771\"),\n  Z: tt.create(BigInt(\"-11\"))\n});\ncu(ue.ProjectivePoint, (t) => {\n  const { x: e, y: r } = gu(tt.create(t[0]));\n  return yu(e, r);\n}, {\n  DST: \"secp256k1_XMD:SHA-256_SSWU_RO_\",\n  encodeDST: \"secp256k1_XMD:SHA-256_SSWU_NU_\",\n  p: tt.ORDER,\n  m: 1,\n  k: 128,\n  expand: \"xmd\",\n  hash: Or\n});\nconst an = typeof globalThis == \"object\" && \"crypto\" in globalThis ? globalThis.crypto : void 0;\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst cn = (t) => new DataView(t.buffer, t.byteOffset, t.byteLength), Ce = (t, e) => t << 32 - e | t >>> e, bu = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;\nif (!bu)\n  throw new Error(\"Non little-endian hardware is not supported\");\nconst vu = Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, \"0\"));\nfunction ve(t) {\n  if (!(t instanceof Uint8Array))\n    throw new Error(\"Uint8Array expected\");\n  let e = \"\";\n  for (let r = 0; r < t.length; r++)\n    e += vu[t[r]];\n  return e;\n}\nfunction _t(t) {\n  if (typeof t != \"string\")\n    throw new TypeError(\"hexToBytes: expected string, got \" + typeof t);\n  if (t.length % 2)\n    throw new Error(\"hexToBytes: received invalid unpadded hex\");\n  const e = new Uint8Array(t.length / 2);\n  for (let r = 0; r < e.length; r++) {\n    const n = r * 2, i = t.slice(n, n + 2), s = Number.parseInt(i, 16);\n    if (Number.isNaN(s) || s < 0)\n      throw new Error(\"Invalid byte sequence\");\n    e[r] = s;\n  }\n  return e;\n}\nfunction wu(t) {\n  if (typeof t != \"string\")\n    throw new TypeError(`utf8ToBytes expected string, got ${typeof t}`);\n  return new TextEncoder().encode(t);\n}\nfunction ys(t) {\n  if (typeof t == \"string\" && (t = wu(t)), !(t instanceof Uint8Array))\n    throw new TypeError(`Expected input type is Uint8Array (got ${typeof t})`);\n  return t;\n}\nfunction _u(...t) {\n  if (!t.every((n) => n instanceof Uint8Array))\n    throw new Error(\"Uint8Array list expected\");\n  if (t.length === 1)\n    return t[0];\n  const e = t.reduce((n, i) => n + i.length, 0), r = new Uint8Array(e);\n  for (let n = 0, i = 0; n < t.length; n++) {\n    const s = t[n];\n    r.set(s, i), i += s.length;\n  }\n  return r;\n}\nclass mu {\n  clone() {\n    return this._cloneInto();\n  }\n}\nfunction gs(t) {\n  const e = (n) => t().update(ys(n)).digest(), r = t();\n  return e.outputLen = r.outputLen, e.blockLen = r.blockLen, e.create = () => t(), e;\n}\nfunction xu(t = 32) {\n  if (an && typeof an.getRandomValues == \"function\")\n    return an.getRandomValues(new Uint8Array(t));\n  throw new Error(\"crypto.getRandomValues must be defined\");\n}\nfunction Pn(t) {\n  if (!Number.isSafeInteger(t) || t < 0)\n    throw new Error(`Wrong positive integer: ${t}`);\n}\nfunction Eu(t) {\n  if (typeof t != \"boolean\")\n    throw new Error(`Expected boolean, not ${t}`);\n}\nfunction bs(t, ...e) {\n  if (!(t instanceof Uint8Array))\n    throw new TypeError(\"Expected Uint8Array\");\n  if (e.length > 0 && !e.includes(t.length))\n    throw new TypeError(`Expected Uint8Array of length ${e}, not of length=${t.length}`);\n}\nfunction ku(t) {\n  if (typeof t != \"function\" || typeof t.create != \"function\")\n    throw new Error(\"Hash should be wrapped by utils.wrapConstructor\");\n  Pn(t.outputLen), Pn(t.blockLen);\n}\nfunction Su(t, e = !0) {\n  if (t.destroyed)\n    throw new Error(\"Hash instance has been destroyed\");\n  if (e && t.finished)\n    throw new Error(\"Hash#digest() has already been called\");\n}\nfunction Ou(t, e) {\n  bs(t);\n  const r = e.outputLen;\n  if (t.length < r)\n    throw new Error(`digestInto() expects output buffer of length at least ${r}`);\n}\nconst un = {\n  number: Pn,\n  bool: Eu,\n  bytes: bs,\n  hash: ku,\n  exists: Su,\n  output: Ou\n};\nfunction Au(t, e, r, n) {\n  if (typeof t.setBigUint64 == \"function\")\n    return t.setBigUint64(e, r, n);\n  const i = BigInt(32), s = BigInt(4294967295), o = Number(r >> i & s), a = Number(r & s), c = n ? 4 : 0, l = n ? 0 : 4;\n  t.setUint32(e + c, o, n), t.setUint32(e + l, a, n);\n}\nclass Cu extends mu {\n  constructor(e, r, n, i) {\n    super(), this.blockLen = e, this.outputLen = r, this.padOffset = n, this.isLE = i, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = cn(this.buffer);\n  }\n  update(e) {\n    un.exists(this);\n    const { view: r, buffer: n, blockLen: i } = this;\n    e = ys(e);\n    const s = e.length;\n    for (let o = 0; o < s; ) {\n      const a = Math.min(i - this.pos, s - o);\n      if (a === i) {\n        const c = cn(e);\n        for (; i <= s - o; o += i)\n          this.process(c, o);\n        continue;\n      }\n      n.set(e.subarray(o, o + a), this.pos), this.pos += a, o += a, this.pos === i && (this.process(r, 0), this.pos = 0);\n    }\n    return this.length += e.length, this.roundClean(), this;\n  }\n  digestInto(e) {\n    un.exists(this), un.output(e, this), this.finished = !0;\n    const { buffer: r, view: n, blockLen: i, isLE: s } = this;\n    let { pos: o } = this;\n    r[o++] = 128, this.buffer.subarray(o).fill(0), this.padOffset > i - o && (this.process(n, 0), o = 0);\n    for (let u = o; u < i; u++)\n      r[u] = 0;\n    Au(n, i - 8, BigInt(this.length * 8), s), this.process(n, 0);\n    const a = cn(e), c = this.outputLen;\n    if (c % 4)\n      throw new Error(\"_sha2: outputLen should be aligned to 32bit\");\n    const l = c / 4, f = this.get();\n    if (l > f.length)\n      throw new Error(\"_sha2: outputLen bigger than state\");\n    for (let u = 0; u < l; u++)\n      a.setUint32(4 * u, f[u], s);\n  }\n  digest() {\n    const { buffer: e, outputLen: r } = this;\n    this.digestInto(e);\n    const n = e.slice(0, r);\n    return this.destroy(), n;\n  }\n  _cloneInto(e) {\n    e || (e = new this.constructor()), e.set(...this.get());\n    const { blockLen: r, buffer: n, length: i, finished: s, destroyed: o, pos: a } = this;\n    return e.length = i, e.pos = a, e.finished = s, e.destroyed = o, i % r && e.buffer.set(n), e;\n  }\n}\nconst Iu = (t, e, r) => t & e ^ ~t & r, Ru = (t, e, r) => t & e ^ t & r ^ e & r, Tu = new Uint32Array([\n  1116352408,\n  1899447441,\n  3049323471,\n  3921009573,\n  961987163,\n  1508970993,\n  2453635748,\n  2870763221,\n  3624381080,\n  310598401,\n  607225278,\n  1426881987,\n  1925078388,\n  2162078206,\n  2614888103,\n  3248222580,\n  3835390401,\n  4022224774,\n  264347078,\n  604807628,\n  770255983,\n  1249150122,\n  1555081692,\n  1996064986,\n  2554220882,\n  2821834349,\n  2952996808,\n  3210313671,\n  3336571891,\n  3584528711,\n  113926993,\n  338241895,\n  666307205,\n  773529912,\n  1294757372,\n  1396182291,\n  1695183700,\n  1986661051,\n  2177026350,\n  2456956037,\n  2730485921,\n  2820302411,\n  3259730800,\n  3345764771,\n  3516065817,\n  3600352804,\n  4094571909,\n  275423344,\n  430227734,\n  506948616,\n  659060556,\n  883997877,\n  958139571,\n  1322822218,\n  1537002063,\n  1747873779,\n  1955562222,\n  2024104815,\n  2227730452,\n  2361852424,\n  2428436474,\n  2756734187,\n  3204031479,\n  3329325298\n]), ze = new Uint32Array([\n  1779033703,\n  3144134277,\n  1013904242,\n  2773480762,\n  1359893119,\n  2600822924,\n  528734635,\n  1541459225\n]), Fe = new Uint32Array(64);\nclass vs extends Cu {\n  constructor() {\n    super(64, 32, 8, !1), this.A = ze[0] | 0, this.B = ze[1] | 0, this.C = ze[2] | 0, this.D = ze[3] | 0, this.E = ze[4] | 0, this.F = ze[5] | 0, this.G = ze[6] | 0, this.H = ze[7] | 0;\n  }\n  get() {\n    const { A: e, B: r, C: n, D: i, E: s, F: o, G: a, H: c } = this;\n    return [e, r, n, i, s, o, a, c];\n  }\n  set(e, r, n, i, s, o, a, c) {\n    this.A = e | 0, this.B = r | 0, this.C = n | 0, this.D = i | 0, this.E = s | 0, this.F = o | 0, this.G = a | 0, this.H = c | 0;\n  }\n  process(e, r) {\n    for (let u = 0; u < 16; u++, r += 4)\n      Fe[u] = e.getUint32(r, !1);\n    for (let u = 16; u < 64; u++) {\n      const h = Fe[u - 15], d = Fe[u - 2], p = Ce(h, 7) ^ Ce(h, 18) ^ h >>> 3, y = Ce(d, 17) ^ Ce(d, 19) ^ d >>> 10;\n      Fe[u] = y + Fe[u - 7] + p + Fe[u - 16] | 0;\n    }\n    let { A: n, B: i, C: s, D: o, E: a, F: c, G: l, H: f } = this;\n    for (let u = 0; u < 64; u++) {\n      const h = Ce(a, 6) ^ Ce(a, 11) ^ Ce(a, 25), d = f + h + Iu(a, c, l) + Tu[u] + Fe[u] | 0, y = (Ce(n, 2) ^ Ce(n, 13) ^ Ce(n, 22)) + Ru(n, i, s) | 0;\n      f = l, l = c, c = a, a = o + d | 0, o = s, s = i, i = n, n = d + y | 0;\n    }\n    n = n + this.A | 0, i = i + this.B | 0, s = s + this.C | 0, o = o + this.D | 0, a = a + this.E | 0, c = c + this.F | 0, l = l + this.G | 0, f = f + this.H | 0, this.set(n, i, s, o, a, c, l, f);\n  }\n  roundClean() {\n    Fe.fill(0);\n  }\n  destroy() {\n    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);\n  }\n}\nclass Pu extends vs {\n  constructor() {\n    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;\n  }\n}\nconst Yn = gs(() => new vs());\ngs(() => new Pu());\n/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nfunction rt(t) {\n  if (!Number.isSafeInteger(t))\n    throw new Error(`Wrong integer: ${t}`);\n}\nfunction Se(...t) {\n  const e = (i, s) => (o) => i(s(o)), r = Array.from(t).reverse().reduce((i, s) => i ? e(i, s.encode) : s.encode, void 0), n = t.reduce((i, s) => i ? e(i, s.decode) : s.decode, void 0);\n  return { encode: r, decode: n };\n}\nfunction Re(t) {\n  return {\n    encode: (e) => {\n      if (!Array.isArray(e) || e.length && typeof e[0] != \"number\")\n        throw new Error(\"alphabet.encode input should be an array of numbers\");\n      return e.map((r) => {\n        if (rt(r), r < 0 || r >= t.length)\n          throw new Error(`Digit index outside alphabet: ${r} (alphabet: ${t.length})`);\n        return t[r];\n      });\n    },\n    decode: (e) => {\n      if (!Array.isArray(e) || e.length && typeof e[0] != \"string\")\n        throw new Error(\"alphabet.decode input should be array of strings\");\n      return e.map((r) => {\n        if (typeof r != \"string\")\n          throw new Error(`alphabet.decode: not string element=${r}`);\n        const n = t.indexOf(r);\n        if (n === -1)\n          throw new Error(`Unknown letter: \"${r}\". Allowed: ${t}`);\n        return n;\n      });\n    }\n  };\n}\nfunction Te(t = \"\") {\n  if (typeof t != \"string\")\n    throw new Error(\"join separator should be string\");\n  return {\n    encode: (e) => {\n      if (!Array.isArray(e) || e.length && typeof e[0] != \"string\")\n        throw new Error(\"join.encode input should be array of strings\");\n      for (let r of e)\n        if (typeof r != \"string\")\n          throw new Error(`join.encode: non-string input=${r}`);\n      return e.join(t);\n    },\n    decode: (e) => {\n      if (typeof e != \"string\")\n        throw new Error(\"join.decode input should be string\");\n      return e.split(t);\n    }\n  };\n}\nfunction sr(t, e = \"=\") {\n  if (rt(t), typeof e != \"string\")\n    throw new Error(\"padding chr should be string\");\n  return {\n    encode(r) {\n      if (!Array.isArray(r) || r.length && typeof r[0] != \"string\")\n        throw new Error(\"padding.encode input should be array of strings\");\n      for (let n of r)\n        if (typeof n != \"string\")\n          throw new Error(`padding.encode: non-string input=${n}`);\n      for (; r.length * t % 8; )\n        r.push(e);\n      return r;\n    },\n    decode(r) {\n      if (!Array.isArray(r) || r.length && typeof r[0] != \"string\")\n        throw new Error(\"padding.encode input should be array of strings\");\n      for (let i of r)\n        if (typeof i != \"string\")\n          throw new Error(`padding.decode: non-string input=${i}`);\n      let n = r.length;\n      if (n * t % 8)\n        throw new Error(\"Invalid padding: string should have whole number of bytes\");\n      for (; n > 0 && r[n - 1] === e; n--)\n        if (!((n - 1) * t % 8))\n          throw new Error(\"Invalid padding: string has too much padding\");\n      return r.slice(0, n);\n    }\n  };\n}\nfunction ws(t) {\n  if (typeof t != \"function\")\n    throw new Error(\"normalize fn should be function\");\n  return { encode: (e) => e, decode: (e) => t(e) };\n}\nfunction Fi(t, e, r) {\n  if (e < 2)\n    throw new Error(`convertRadix: wrong from=${e}, base cannot be less than 2`);\n  if (r < 2)\n    throw new Error(`convertRadix: wrong to=${r}, base cannot be less than 2`);\n  if (!Array.isArray(t))\n    throw new Error(\"convertRadix: data should be array\");\n  if (!t.length)\n    return [];\n  let n = 0;\n  const i = [], s = Array.from(t);\n  for (s.forEach((o) => {\n    if (rt(o), o < 0 || o >= e)\n      throw new Error(`Wrong integer: ${o}`);\n  }); ; ) {\n    let o = 0, a = !0;\n    for (let c = n; c < s.length; c++) {\n      const l = s[c], f = e * o + l;\n      if (!Number.isSafeInteger(f) || e * o / e !== o || f - l !== e * o)\n        throw new Error(\"convertRadix: carry overflow\");\n      if (o = f % r, s[c] = Math.floor(f / r), !Number.isSafeInteger(s[c]) || s[c] * r + o !== f)\n        throw new Error(\"convertRadix: carry overflow\");\n      if (a)\n        s[c] ? a = !1 : n = c;\n      else\n        continue;\n    }\n    if (i.push(o), a)\n      break;\n  }\n  for (let o = 0; o < t.length - 1 && t[o] === 0; o++)\n    i.push(0);\n  return i.reverse();\n}\nconst _s = (t, e) => e ? _s(e, t % e) : t, Tr = (t, e) => t + (e - _s(t, e));\nfunction Bn(t, e, r, n) {\n  if (!Array.isArray(t))\n    throw new Error(\"convertRadix2: data should be array\");\n  if (e <= 0 || e > 32)\n    throw new Error(`convertRadix2: wrong from=${e}`);\n  if (r <= 0 || r > 32)\n    throw new Error(`convertRadix2: wrong to=${r}`);\n  if (Tr(e, r) > 32)\n    throw new Error(`convertRadix2: carry overflow from=${e} to=${r} carryBits=${Tr(e, r)}`);\n  let i = 0, s = 0;\n  const o = 2 ** r - 1, a = [];\n  for (const c of t) {\n    if (rt(c), c >= 2 ** e)\n      throw new Error(`convertRadix2: invalid data word=${c} from=${e}`);\n    if (i = i << e | c, s + e > 32)\n      throw new Error(`convertRadix2: carry overflow pos=${s} from=${e}`);\n    for (s += e; s >= r; s -= r)\n      a.push((i >> s - r & o) >>> 0);\n    i &= 2 ** s - 1;\n  }\n  if (i = i << r - s & o, !n && s >= e)\n    throw new Error(\"Excess padding\");\n  if (!n && i)\n    throw new Error(`Non-zero padding: ${i}`);\n  return n && s > 0 && a.push(i >>> 0), a;\n}\nfunction ms(t) {\n  return rt(t), {\n    encode: (e) => {\n      if (!(e instanceof Uint8Array))\n        throw new Error(\"radix.encode input should be Uint8Array\");\n      return Fi(Array.from(e), 2 ** 8, t);\n    },\n    decode: (e) => {\n      if (!Array.isArray(e) || e.length && typeof e[0] != \"number\")\n        throw new Error(\"radix.decode input should be array of strings\");\n      return Uint8Array.from(Fi(e, t, 2 ** 8));\n    }\n  };\n}\nfunction Ne(t, e = !1) {\n  if (rt(t), t <= 0 || t > 32)\n    throw new Error(\"radix2: bits should be in (0..32]\");\n  if (Tr(8, t) > 32 || Tr(t, 8) > 32)\n    throw new Error(\"radix2: carry overflow\");\n  return {\n    encode: (r) => {\n      if (!(r instanceof Uint8Array))\n        throw new Error(\"radix2.encode input should be Uint8Array\");\n      return Bn(Array.from(r), 8, t, !e);\n    },\n    decode: (r) => {\n      if (!Array.isArray(r) || r.length && typeof r[0] != \"number\")\n        throw new Error(\"radix2.decode input should be array of strings\");\n      return Uint8Array.from(Bn(r, t, 8, e));\n    }\n  };\n}\nfunction Ki(t) {\n  if (typeof t != \"function\")\n    throw new Error(\"unsafeWrapper fn should be function\");\n  return function(...e) {\n    try {\n      return t.apply(null, e);\n    } catch {\n    }\n  };\n}\nfunction xs(t, e) {\n  if (rt(t), typeof e != \"function\")\n    throw new Error(\"checksum fn should be function\");\n  return {\n    encode(r) {\n      if (!(r instanceof Uint8Array))\n        throw new Error(\"checksum.encode: input should be Uint8Array\");\n      const n = e(r).slice(0, t), i = new Uint8Array(r.length + t);\n      return i.set(r), i.set(n, r.length), i;\n    },\n    decode(r) {\n      if (!(r instanceof Uint8Array))\n        throw new Error(\"checksum.decode: input should be Uint8Array\");\n      const n = r.slice(0, -t), i = e(n).slice(0, t), s = r.slice(-t);\n      for (let o = 0; o < t; o++)\n        if (i[o] !== s[o])\n          throw new Error(\"Invalid checksum\");\n      return n;\n    }\n  };\n}\nconst Bu = { alphabet: Re, chain: Se, checksum: xs, radix: ms, radix2: Ne, join: Te, padding: sr }, Es = Se(Ne(4), Re(\"0123456789ABCDEF\"), Te(\"\")), ks = Se(Ne(5), Re(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\"), sr(5), Te(\"\")), Lu = Se(Ne(5), Re(\"0123456789ABCDEFGHIJKLMNOPQRSTUV\"), sr(5), Te(\"\")), $u = Se(Ne(5), Re(\"0123456789ABCDEFGHJKMNPQRSTVWXYZ\"), Te(\"\"), ws((t) => t.toUpperCase().replace(/O/g, \"0\").replace(/[IL]/g, \"1\"))), mt = Se(Ne(6), Re(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"), sr(6), Te(\"\")), Ss = Se(Ne(6), Re(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\"), sr(6), Te(\"\")), Jn = (t) => Se(ms(58), Re(t), Te(\"\")), nr = Jn(\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"), qu = Jn(\"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ\"), Nu = Jn(\"rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz\"), Wi = [0, 2, 3, 5, 6, 7, 9, 10, 11], Os = {\n  encode(t) {\n    let e = \"\";\n    for (let r = 0; r < t.length; r += 8) {\n      const n = t.subarray(r, r + 8);\n      e += nr.encode(n).padStart(Wi[n.length], \"1\");\n    }\n    return e;\n  },\n  decode(t) {\n    let e = [];\n    for (let r = 0; r < t.length; r += 11) {\n      const n = t.slice(r, r + 11), i = Wi.indexOf(n.length), s = nr.decode(n);\n      for (let o = 0; o < s.length - i; o++)\n        if (s[o] !== 0)\n          throw new Error(\"base58xmr: wrong padding\");\n      e = e.concat(Array.from(s.slice(s.length - i)));\n    }\n    return Uint8Array.from(e);\n  }\n}, As = (t) => Se(xs(4, (e) => t(t(e))), nr), Ln = Se(Re(\"qpzry9x8gf2tvdw0s3jn54khce6mua7l\"), Te(\"\")), Vi = [996825010, 642813549, 513874426, 1027748829, 705979059];\nfunction It(t) {\n  const e = t >> 25;\n  let r = (t & 33554431) << 5;\n  for (let n = 0; n < Vi.length; n++)\n    (e >> n & 1) === 1 && (r ^= Vi[n]);\n  return r;\n}\nfunction Gi(t, e, r = 1) {\n  const n = t.length;\n  let i = 1;\n  for (let s = 0; s < n; s++) {\n    const o = t.charCodeAt(s);\n    if (o < 33 || o > 126)\n      throw new Error(`Invalid prefix (${t})`);\n    i = It(i) ^ o >> 5;\n  }\n  i = It(i);\n  for (let s = 0; s < n; s++)\n    i = It(i) ^ t.charCodeAt(s) & 31;\n  for (let s of e)\n    i = It(i) ^ s;\n  for (let s = 0; s < 6; s++)\n    i = It(i);\n  return i ^= r, Ln.encode(Bn([i % 2 ** 30], 30, 5, !1));\n}\nfunction Cs(t) {\n  const e = t === \"bech32\" ? 1 : 734539939, r = Ne(5), n = r.decode, i = r.encode, s = Ki(n);\n  function o(f, u, h = 90) {\n    if (typeof f != \"string\")\n      throw new Error(`bech32.encode prefix should be string, not ${typeof f}`);\n    if (!Array.isArray(u) || u.length && typeof u[0] != \"number\")\n      throw new Error(`bech32.encode words should be array of numbers, not ${typeof u}`);\n    const d = f.length + 7 + u.length;\n    if (h !== !1 && d > h)\n      throw new TypeError(`Length ${d} exceeds limit ${h}`);\n    return f = f.toLowerCase(), `${f}1${Ln.encode(u)}${Gi(f, u, e)}`;\n  }\n  function a(f, u = 90) {\n    if (typeof f != \"string\")\n      throw new Error(`bech32.decode input should be string, not ${typeof f}`);\n    if (f.length < 8 || u !== !1 && f.length > u)\n      throw new TypeError(`Wrong string length: ${f.length} (${f}). Expected (8..${u})`);\n    const h = f.toLowerCase();\n    if (f !== h && f !== f.toUpperCase())\n      throw new Error(\"String must be lowercase or uppercase\");\n    f = h;\n    const d = f.lastIndexOf(\"1\");\n    if (d === 0 || d === -1)\n      throw new Error('Letter \"1\" must be present between prefix and data only');\n    const p = f.slice(0, d), y = f.slice(d + 1);\n    if (y.length < 6)\n      throw new Error(\"Data must be at least 6 characters long\");\n    const g = Ln.decode(y).slice(0, -6), v = Gi(p, g, e);\n    if (!y.endsWith(v))\n      throw new Error(`Invalid checksum in ${f}: expected \"${v}\"`);\n    return { prefix: p, words: g };\n  }\n  const c = Ki(a);\n  function l(f) {\n    const { prefix: u, words: h } = a(f, !1);\n    return { prefix: u, words: h, bytes: n(h) };\n  }\n  return { encode: o, decode: a, decodeToBytes: l, decodeUnsafe: c, fromWords: n, fromWordsUnsafe: s, toWords: i };\n}\nconst te = Cs(\"bech32\"), Uu = Cs(\"bech32m\"), Is = {\n  encode: (t) => new TextDecoder().decode(t),\n  decode: (t) => new TextEncoder().encode(t)\n}, Rs = Se(Ne(4), Re(\"0123456789abcdef\"), Te(\"\"), ws((t) => {\n  if (typeof t != \"string\" || t.length % 2)\n    throw new TypeError(`hex.decode: expected string, got ${typeof t} with length ${t.length}`);\n  return t.toLowerCase();\n})), ir = {\n  utf8: Is,\n  hex: Rs,\n  base16: Es,\n  base32: ks,\n  base64: mt,\n  base64url: Ss,\n  base58: nr,\n  base58xmr: Os\n}, Ts = `Invalid encoding type. Available types: ${Object.keys(ir).join(\", \")}`, Ps = (t, e) => {\n  if (typeof t != \"string\" || !ir.hasOwnProperty(t))\n    throw new TypeError(Ts);\n  if (!(e instanceof Uint8Array))\n    throw new TypeError(\"bytesToString() expects Uint8Array\");\n  return ir[t].encode(e);\n}, ju = Ps, Bs = (t, e) => {\n  if (!ir.hasOwnProperty(t))\n    throw new TypeError(Ts);\n  if (typeof e != \"string\")\n    throw new TypeError(\"stringToBytes() expects string\");\n  return ir[t].decode(e);\n}, Hu = Bs, Mu = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  assertNumber: rt,\n  utils: Bu,\n  base16: Es,\n  base32: ks,\n  base32hex: Lu,\n  base32crockford: $u,\n  base64: mt,\n  base64url: Ss,\n  base58: nr,\n  base58flickr: qu,\n  base58xrp: Nu,\n  base58xmr: Os,\n  base58check: As,\n  bech32: te,\n  bech32m: Uu,\n  utf8: Is,\n  hex: Rs,\n  bytesToString: Ps,\n  str: ju,\n  stringToBytes: Bs,\n  bytes: Hu\n}, Symbol.toStringTag, { value: \"Module\" }));\nvar Xn = {};\nObject.defineProperty(Xn, \"__esModule\", { value: !0 });\nvar Qn = Xn.wordlist = void 0;\nQn = Xn.wordlist = `abandon\nability\nable\nabout\nabove\nabsent\nabsorb\nabstract\nabsurd\nabuse\naccess\naccident\naccount\naccuse\nachieve\nacid\nacoustic\nacquire\nacross\nact\naction\nactor\nactress\nactual\nadapt\nadd\naddict\naddress\nadjust\nadmit\nadult\nadvance\nadvice\naerobic\naffair\nafford\nafraid\nagain\nage\nagent\nagree\nahead\naim\nair\nairport\naisle\nalarm\nalbum\nalcohol\nalert\nalien\nall\nalley\nallow\nalmost\nalone\nalpha\nalready\nalso\nalter\nalways\namateur\namazing\namong\namount\namused\nanalyst\nanchor\nancient\nanger\nangle\nangry\nanimal\nankle\nannounce\nannual\nanother\nanswer\nantenna\nantique\nanxiety\nany\napart\napology\nappear\napple\napprove\napril\narch\narctic\narea\narena\nargue\narm\narmed\narmor\narmy\naround\narrange\narrest\narrive\narrow\nart\nartefact\nartist\nartwork\nask\naspect\nassault\nasset\nassist\nassume\nasthma\nathlete\natom\nattack\nattend\nattitude\nattract\nauction\naudit\naugust\naunt\nauthor\nauto\nautumn\naverage\navocado\navoid\nawake\naware\naway\nawesome\nawful\nawkward\naxis\nbaby\nbachelor\nbacon\nbadge\nbag\nbalance\nbalcony\nball\nbamboo\nbanana\nbanner\nbar\nbarely\nbargain\nbarrel\nbase\nbasic\nbasket\nbattle\nbeach\nbean\nbeauty\nbecause\nbecome\nbeef\nbefore\nbegin\nbehave\nbehind\nbelieve\nbelow\nbelt\nbench\nbenefit\nbest\nbetray\nbetter\nbetween\nbeyond\nbicycle\nbid\nbike\nbind\nbiology\nbird\nbirth\nbitter\nblack\nblade\nblame\nblanket\nblast\nbleak\nbless\nblind\nblood\nblossom\nblouse\nblue\nblur\nblush\nboard\nboat\nbody\nboil\nbomb\nbone\nbonus\nbook\nboost\nborder\nboring\nborrow\nboss\nbottom\nbounce\nbox\nboy\nbracket\nbrain\nbrand\nbrass\nbrave\nbread\nbreeze\nbrick\nbridge\nbrief\nbright\nbring\nbrisk\nbroccoli\nbroken\nbronze\nbroom\nbrother\nbrown\nbrush\nbubble\nbuddy\nbudget\nbuffalo\nbuild\nbulb\nbulk\nbullet\nbundle\nbunker\nburden\nburger\nburst\nbus\nbusiness\nbusy\nbutter\nbuyer\nbuzz\ncabbage\ncabin\ncable\ncactus\ncage\ncake\ncall\ncalm\ncamera\ncamp\ncan\ncanal\ncancel\ncandy\ncannon\ncanoe\ncanvas\ncanyon\ncapable\ncapital\ncaptain\ncar\ncarbon\ncard\ncargo\ncarpet\ncarry\ncart\ncase\ncash\ncasino\ncastle\ncasual\ncat\ncatalog\ncatch\ncategory\ncattle\ncaught\ncause\ncaution\ncave\nceiling\ncelery\ncement\ncensus\ncentury\ncereal\ncertain\nchair\nchalk\nchampion\nchange\nchaos\nchapter\ncharge\nchase\nchat\ncheap\ncheck\ncheese\nchef\ncherry\nchest\nchicken\nchief\nchild\nchimney\nchoice\nchoose\nchronic\nchuckle\nchunk\nchurn\ncigar\ncinnamon\ncircle\ncitizen\ncity\ncivil\nclaim\nclap\nclarify\nclaw\nclay\nclean\nclerk\nclever\nclick\nclient\ncliff\nclimb\nclinic\nclip\nclock\nclog\nclose\ncloth\ncloud\nclown\nclub\nclump\ncluster\nclutch\ncoach\ncoast\ncoconut\ncode\ncoffee\ncoil\ncoin\ncollect\ncolor\ncolumn\ncombine\ncome\ncomfort\ncomic\ncommon\ncompany\nconcert\nconduct\nconfirm\ncongress\nconnect\nconsider\ncontrol\nconvince\ncook\ncool\ncopper\ncopy\ncoral\ncore\ncorn\ncorrect\ncost\ncotton\ncouch\ncountry\ncouple\ncourse\ncousin\ncover\ncoyote\ncrack\ncradle\ncraft\ncram\ncrane\ncrash\ncrater\ncrawl\ncrazy\ncream\ncredit\ncreek\ncrew\ncricket\ncrime\ncrisp\ncritic\ncrop\ncross\ncrouch\ncrowd\ncrucial\ncruel\ncruise\ncrumble\ncrunch\ncrush\ncry\ncrystal\ncube\nculture\ncup\ncupboard\ncurious\ncurrent\ncurtain\ncurve\ncushion\ncustom\ncute\ncycle\ndad\ndamage\ndamp\ndance\ndanger\ndaring\ndash\ndaughter\ndawn\nday\ndeal\ndebate\ndebris\ndecade\ndecember\ndecide\ndecline\ndecorate\ndecrease\ndeer\ndefense\ndefine\ndefy\ndegree\ndelay\ndeliver\ndemand\ndemise\ndenial\ndentist\ndeny\ndepart\ndepend\ndeposit\ndepth\ndeputy\nderive\ndescribe\ndesert\ndesign\ndesk\ndespair\ndestroy\ndetail\ndetect\ndevelop\ndevice\ndevote\ndiagram\ndial\ndiamond\ndiary\ndice\ndiesel\ndiet\ndiffer\ndigital\ndignity\ndilemma\ndinner\ndinosaur\ndirect\ndirt\ndisagree\ndiscover\ndisease\ndish\ndismiss\ndisorder\ndisplay\ndistance\ndivert\ndivide\ndivorce\ndizzy\ndoctor\ndocument\ndog\ndoll\ndolphin\ndomain\ndonate\ndonkey\ndonor\ndoor\ndose\ndouble\ndove\ndraft\ndragon\ndrama\ndrastic\ndraw\ndream\ndress\ndrift\ndrill\ndrink\ndrip\ndrive\ndrop\ndrum\ndry\nduck\ndumb\ndune\nduring\ndust\ndutch\nduty\ndwarf\ndynamic\neager\neagle\nearly\nearn\nearth\neasily\neast\neasy\necho\necology\neconomy\nedge\nedit\neducate\neffort\negg\neight\neither\nelbow\nelder\nelectric\nelegant\nelement\nelephant\nelevator\nelite\nelse\nembark\nembody\nembrace\nemerge\nemotion\nemploy\nempower\nempty\nenable\nenact\nend\nendless\nendorse\nenemy\nenergy\nenforce\nengage\nengine\nenhance\nenjoy\nenlist\nenough\nenrich\nenroll\nensure\nenter\nentire\nentry\nenvelope\nepisode\nequal\nequip\nera\nerase\nerode\nerosion\nerror\nerupt\nescape\nessay\nessence\nestate\neternal\nethics\nevidence\nevil\nevoke\nevolve\nexact\nexample\nexcess\nexchange\nexcite\nexclude\nexcuse\nexecute\nexercise\nexhaust\nexhibit\nexile\nexist\nexit\nexotic\nexpand\nexpect\nexpire\nexplain\nexpose\nexpress\nextend\nextra\neye\neyebrow\nfabric\nface\nfaculty\nfade\nfaint\nfaith\nfall\nfalse\nfame\nfamily\nfamous\nfan\nfancy\nfantasy\nfarm\nfashion\nfat\nfatal\nfather\nfatigue\nfault\nfavorite\nfeature\nfebruary\nfederal\nfee\nfeed\nfeel\nfemale\nfence\nfestival\nfetch\nfever\nfew\nfiber\nfiction\nfield\nfigure\nfile\nfilm\nfilter\nfinal\nfind\nfine\nfinger\nfinish\nfire\nfirm\nfirst\nfiscal\nfish\nfit\nfitness\nfix\nflag\nflame\nflash\nflat\nflavor\nflee\nflight\nflip\nfloat\nflock\nfloor\nflower\nfluid\nflush\nfly\nfoam\nfocus\nfog\nfoil\nfold\nfollow\nfood\nfoot\nforce\nforest\nforget\nfork\nfortune\nforum\nforward\nfossil\nfoster\nfound\nfox\nfragile\nframe\nfrequent\nfresh\nfriend\nfringe\nfrog\nfront\nfrost\nfrown\nfrozen\nfruit\nfuel\nfun\nfunny\nfurnace\nfury\nfuture\ngadget\ngain\ngalaxy\ngallery\ngame\ngap\ngarage\ngarbage\ngarden\ngarlic\ngarment\ngas\ngasp\ngate\ngather\ngauge\ngaze\ngeneral\ngenius\ngenre\ngentle\ngenuine\ngesture\nghost\ngiant\ngift\ngiggle\nginger\ngiraffe\ngirl\ngive\nglad\nglance\nglare\nglass\nglide\nglimpse\nglobe\ngloom\nglory\nglove\nglow\nglue\ngoat\ngoddess\ngold\ngood\ngoose\ngorilla\ngospel\ngossip\ngovern\ngown\ngrab\ngrace\ngrain\ngrant\ngrape\ngrass\ngravity\ngreat\ngreen\ngrid\ngrief\ngrit\ngrocery\ngroup\ngrow\ngrunt\nguard\nguess\nguide\nguilt\nguitar\ngun\ngym\nhabit\nhair\nhalf\nhammer\nhamster\nhand\nhappy\nharbor\nhard\nharsh\nharvest\nhat\nhave\nhawk\nhazard\nhead\nhealth\nheart\nheavy\nhedgehog\nheight\nhello\nhelmet\nhelp\nhen\nhero\nhidden\nhigh\nhill\nhint\nhip\nhire\nhistory\nhobby\nhockey\nhold\nhole\nholiday\nhollow\nhome\nhoney\nhood\nhope\nhorn\nhorror\nhorse\nhospital\nhost\nhotel\nhour\nhover\nhub\nhuge\nhuman\nhumble\nhumor\nhundred\nhungry\nhunt\nhurdle\nhurry\nhurt\nhusband\nhybrid\nice\nicon\nidea\nidentify\nidle\nignore\nill\nillegal\nillness\nimage\nimitate\nimmense\nimmune\nimpact\nimpose\nimprove\nimpulse\ninch\ninclude\nincome\nincrease\nindex\nindicate\nindoor\nindustry\ninfant\ninflict\ninform\ninhale\ninherit\ninitial\ninject\ninjury\ninmate\ninner\ninnocent\ninput\ninquiry\ninsane\ninsect\ninside\ninspire\ninstall\nintact\ninterest\ninto\ninvest\ninvite\ninvolve\niron\nisland\nisolate\nissue\nitem\nivory\njacket\njaguar\njar\njazz\njealous\njeans\njelly\njewel\njob\njoin\njoke\njourney\njoy\njudge\njuice\njump\njungle\njunior\njunk\njust\nkangaroo\nkeen\nkeep\nketchup\nkey\nkick\nkid\nkidney\nkind\nkingdom\nkiss\nkit\nkitchen\nkite\nkitten\nkiwi\nknee\nknife\nknock\nknow\nlab\nlabel\nlabor\nladder\nlady\nlake\nlamp\nlanguage\nlaptop\nlarge\nlater\nlatin\nlaugh\nlaundry\nlava\nlaw\nlawn\nlawsuit\nlayer\nlazy\nleader\nleaf\nlearn\nleave\nlecture\nleft\nleg\nlegal\nlegend\nleisure\nlemon\nlend\nlength\nlens\nleopard\nlesson\nletter\nlevel\nliar\nliberty\nlibrary\nlicense\nlife\nlift\nlight\nlike\nlimb\nlimit\nlink\nlion\nliquid\nlist\nlittle\nlive\nlizard\nload\nloan\nlobster\nlocal\nlock\nlogic\nlonely\nlong\nloop\nlottery\nloud\nlounge\nlove\nloyal\nlucky\nluggage\nlumber\nlunar\nlunch\nluxury\nlyrics\nmachine\nmad\nmagic\nmagnet\nmaid\nmail\nmain\nmajor\nmake\nmammal\nman\nmanage\nmandate\nmango\nmansion\nmanual\nmaple\nmarble\nmarch\nmargin\nmarine\nmarket\nmarriage\nmask\nmass\nmaster\nmatch\nmaterial\nmath\nmatrix\nmatter\nmaximum\nmaze\nmeadow\nmean\nmeasure\nmeat\nmechanic\nmedal\nmedia\nmelody\nmelt\nmember\nmemory\nmention\nmenu\nmercy\nmerge\nmerit\nmerry\nmesh\nmessage\nmetal\nmethod\nmiddle\nmidnight\nmilk\nmillion\nmimic\nmind\nminimum\nminor\nminute\nmiracle\nmirror\nmisery\nmiss\nmistake\nmix\nmixed\nmixture\nmobile\nmodel\nmodify\nmom\nmoment\nmonitor\nmonkey\nmonster\nmonth\nmoon\nmoral\nmore\nmorning\nmosquito\nmother\nmotion\nmotor\nmountain\nmouse\nmove\nmovie\nmuch\nmuffin\nmule\nmultiply\nmuscle\nmuseum\nmushroom\nmusic\nmust\nmutual\nmyself\nmystery\nmyth\nnaive\nname\nnapkin\nnarrow\nnasty\nnation\nnature\nnear\nneck\nneed\nnegative\nneglect\nneither\nnephew\nnerve\nnest\nnet\nnetwork\nneutral\nnever\nnews\nnext\nnice\nnight\nnoble\nnoise\nnominee\nnoodle\nnormal\nnorth\nnose\nnotable\nnote\nnothing\nnotice\nnovel\nnow\nnuclear\nnumber\nnurse\nnut\noak\nobey\nobject\noblige\nobscure\nobserve\nobtain\nobvious\noccur\nocean\noctober\nodor\noff\noffer\noffice\noften\noil\nokay\nold\nolive\nolympic\nomit\nonce\none\nonion\nonline\nonly\nopen\nopera\nopinion\noppose\noption\norange\norbit\norchard\norder\nordinary\norgan\norient\noriginal\norphan\nostrich\nother\noutdoor\nouter\noutput\noutside\noval\noven\nover\nown\nowner\noxygen\noyster\nozone\npact\npaddle\npage\npair\npalace\npalm\npanda\npanel\npanic\npanther\npaper\nparade\nparent\npark\nparrot\nparty\npass\npatch\npath\npatient\npatrol\npattern\npause\npave\npayment\npeace\npeanut\npear\npeasant\npelican\npen\npenalty\npencil\npeople\npepper\nperfect\npermit\nperson\npet\nphone\nphoto\nphrase\nphysical\npiano\npicnic\npicture\npiece\npig\npigeon\npill\npilot\npink\npioneer\npipe\npistol\npitch\npizza\nplace\nplanet\nplastic\nplate\nplay\nplease\npledge\npluck\nplug\nplunge\npoem\npoet\npoint\npolar\npole\npolice\npond\npony\npool\npopular\nportion\nposition\npossible\npost\npotato\npottery\npoverty\npowder\npower\npractice\npraise\npredict\nprefer\nprepare\npresent\npretty\nprevent\nprice\npride\nprimary\nprint\npriority\nprison\nprivate\nprize\nproblem\nprocess\nproduce\nprofit\nprogram\nproject\npromote\nproof\nproperty\nprosper\nprotect\nproud\nprovide\npublic\npudding\npull\npulp\npulse\npumpkin\npunch\npupil\npuppy\npurchase\npurity\npurpose\npurse\npush\nput\npuzzle\npyramid\nquality\nquantum\nquarter\nquestion\nquick\nquit\nquiz\nquote\nrabbit\nraccoon\nrace\nrack\nradar\nradio\nrail\nrain\nraise\nrally\nramp\nranch\nrandom\nrange\nrapid\nrare\nrate\nrather\nraven\nraw\nrazor\nready\nreal\nreason\nrebel\nrebuild\nrecall\nreceive\nrecipe\nrecord\nrecycle\nreduce\nreflect\nreform\nrefuse\nregion\nregret\nregular\nreject\nrelax\nrelease\nrelief\nrely\nremain\nremember\nremind\nremove\nrender\nrenew\nrent\nreopen\nrepair\nrepeat\nreplace\nreport\nrequire\nrescue\nresemble\nresist\nresource\nresponse\nresult\nretire\nretreat\nreturn\nreunion\nreveal\nreview\nreward\nrhythm\nrib\nribbon\nrice\nrich\nride\nridge\nrifle\nright\nrigid\nring\nriot\nripple\nrisk\nritual\nrival\nriver\nroad\nroast\nrobot\nrobust\nrocket\nromance\nroof\nrookie\nroom\nrose\nrotate\nrough\nround\nroute\nroyal\nrubber\nrude\nrug\nrule\nrun\nrunway\nrural\nsad\nsaddle\nsadness\nsafe\nsail\nsalad\nsalmon\nsalon\nsalt\nsalute\nsame\nsample\nsand\nsatisfy\nsatoshi\nsauce\nsausage\nsave\nsay\nscale\nscan\nscare\nscatter\nscene\nscheme\nschool\nscience\nscissors\nscorpion\nscout\nscrap\nscreen\nscript\nscrub\nsea\nsearch\nseason\nseat\nsecond\nsecret\nsection\nsecurity\nseed\nseek\nsegment\nselect\nsell\nseminar\nsenior\nsense\nsentence\nseries\nservice\nsession\nsettle\nsetup\nseven\nshadow\nshaft\nshallow\nshare\nshed\nshell\nsheriff\nshield\nshift\nshine\nship\nshiver\nshock\nshoe\nshoot\nshop\nshort\nshoulder\nshove\nshrimp\nshrug\nshuffle\nshy\nsibling\nsick\nside\nsiege\nsight\nsign\nsilent\nsilk\nsilly\nsilver\nsimilar\nsimple\nsince\nsing\nsiren\nsister\nsituate\nsix\nsize\nskate\nsketch\nski\nskill\nskin\nskirt\nskull\nslab\nslam\nsleep\nslender\nslice\nslide\nslight\nslim\nslogan\nslot\nslow\nslush\nsmall\nsmart\nsmile\nsmoke\nsmooth\nsnack\nsnake\nsnap\nsniff\nsnow\nsoap\nsoccer\nsocial\nsock\nsoda\nsoft\nsolar\nsoldier\nsolid\nsolution\nsolve\nsomeone\nsong\nsoon\nsorry\nsort\nsoul\nsound\nsoup\nsource\nsouth\nspace\nspare\nspatial\nspawn\nspeak\nspecial\nspeed\nspell\nspend\nsphere\nspice\nspider\nspike\nspin\nspirit\nsplit\nspoil\nsponsor\nspoon\nsport\nspot\nspray\nspread\nspring\nspy\nsquare\nsqueeze\nsquirrel\nstable\nstadium\nstaff\nstage\nstairs\nstamp\nstand\nstart\nstate\nstay\nsteak\nsteel\nstem\nstep\nstereo\nstick\nstill\nsting\nstock\nstomach\nstone\nstool\nstory\nstove\nstrategy\nstreet\nstrike\nstrong\nstruggle\nstudent\nstuff\nstumble\nstyle\nsubject\nsubmit\nsubway\nsuccess\nsuch\nsudden\nsuffer\nsugar\nsuggest\nsuit\nsummer\nsun\nsunny\nsunset\nsuper\nsupply\nsupreme\nsure\nsurface\nsurge\nsurprise\nsurround\nsurvey\nsuspect\nsustain\nswallow\nswamp\nswap\nswarm\nswear\nsweet\nswift\nswim\nswing\nswitch\nsword\nsymbol\nsymptom\nsyrup\nsystem\ntable\ntackle\ntag\ntail\ntalent\ntalk\ntank\ntape\ntarget\ntask\ntaste\ntattoo\ntaxi\nteach\nteam\ntell\nten\ntenant\ntennis\ntent\nterm\ntest\ntext\nthank\nthat\ntheme\nthen\ntheory\nthere\nthey\nthing\nthis\nthought\nthree\nthrive\nthrow\nthumb\nthunder\nticket\ntide\ntiger\ntilt\ntimber\ntime\ntiny\ntip\ntired\ntissue\ntitle\ntoast\ntobacco\ntoday\ntoddler\ntoe\ntogether\ntoilet\ntoken\ntomato\ntomorrow\ntone\ntongue\ntonight\ntool\ntooth\ntop\ntopic\ntopple\ntorch\ntornado\ntortoise\ntoss\ntotal\ntourist\ntoward\ntower\ntown\ntoy\ntrack\ntrade\ntraffic\ntragic\ntrain\ntransfer\ntrap\ntrash\ntravel\ntray\ntreat\ntree\ntrend\ntrial\ntribe\ntrick\ntrigger\ntrim\ntrip\ntrophy\ntrouble\ntruck\ntrue\ntruly\ntrumpet\ntrust\ntruth\ntry\ntube\ntuition\ntumble\ntuna\ntunnel\nturkey\nturn\nturtle\ntwelve\ntwenty\ntwice\ntwin\ntwist\ntwo\ntype\ntypical\nugly\numbrella\nunable\nunaware\nuncle\nuncover\nunder\nundo\nunfair\nunfold\nunhappy\nuniform\nunique\nunit\nuniverse\nunknown\nunlock\nuntil\nunusual\nunveil\nupdate\nupgrade\nuphold\nupon\nupper\nupset\nurban\nurge\nusage\nuse\nused\nuseful\nuseless\nusual\nutility\nvacant\nvacuum\nvague\nvalid\nvalley\nvalve\nvan\nvanish\nvapor\nvarious\nvast\nvault\nvehicle\nvelvet\nvendor\nventure\nvenue\nverb\nverify\nversion\nvery\nvessel\nveteran\nviable\nvibrant\nvicious\nvictory\nvideo\nview\nvillage\nvintage\nviolin\nvirtual\nvirus\nvisa\nvisit\nvisual\nvital\nvivid\nvocal\nvoice\nvoid\nvolcano\nvolume\nvote\nvoyage\nwage\nwagon\nwait\nwalk\nwall\nwalnut\nwant\nwarfare\nwarm\nwarrior\nwash\nwasp\nwaste\nwater\nwave\nway\nwealth\nweapon\nwear\nweasel\nweather\nweb\nwedding\nweekend\nweird\nwelcome\nwest\nwet\nwhale\nwhat\nwheat\nwheel\nwhen\nwhere\nwhip\nwhisper\nwide\nwidth\nwife\nwild\nwill\nwin\nwindow\nwine\nwing\nwink\nwinner\nwinter\nwire\nwisdom\nwise\nwish\nwitness\nwolf\nwoman\nwonder\nwood\nwool\nword\nwork\nworld\nworry\nworth\nwrap\nwreck\nwrestle\nwrist\nwrite\nwrong\nyard\nyear\nyellow\nyou\nyoung\nyouth\nzebra\nzero\nzone\nzoo`.split(`\n`);\nvar de = {};\nfunction Pr(t) {\n  if (!Number.isSafeInteger(t) || t < 0)\n    throw new Error(`Wrong positive integer: ${t}`);\n}\nfunction Ls(t) {\n  if (typeof t != \"boolean\")\n    throw new Error(`Expected boolean, not ${t}`);\n}\nfunction Ye(t, ...e) {\n  if (!(t instanceof Uint8Array))\n    throw new Error(\"Expected Uint8Array\");\n  if (e.length > 0 && !e.includes(t.length))\n    throw new Error(`Expected Uint8Array of length ${e}, not of length=${t.length}`);\n}\nfunction $s(t) {\n  if (typeof t != \"function\" || typeof t.create != \"function\")\n    throw new Error(\"Hash should be wrapped by utils.wrapConstructor\");\n  Pr(t.outputLen), Pr(t.blockLen);\n}\nfunction qs(t, e = !0) {\n  if (t.destroyed)\n    throw new Error(\"Hash instance has been destroyed\");\n  if (e && t.finished)\n    throw new Error(\"Hash#digest() has already been called\");\n}\nfunction Ns(t, e) {\n  Ye(t);\n  const r = e.outputLen;\n  if (t.length < r)\n    throw new Error(`digestInto() expects output buffer of length at least ${r}`);\n}\nconst Qe = {\n  number: Pr,\n  bool: Ls,\n  bytes: Ye,\n  hash: $s,\n  exists: qs,\n  output: Ns\n}, Du = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  number: Pr,\n  bool: Ls,\n  bytes: Ye,\n  hash: $s,\n  exists: qs,\n  output: Ns,\n  default: Qe\n}, Symbol.toStringTag, { value: \"Module\" })), zu = /* @__PURE__ */ Et(Du);\nvar xt = {}, ne = {};\nObject.defineProperty(ne, \"__esModule\", { value: !0 });\nne.output = ne.exists = ne.hash = ne.bytes = ne.bool = ne.number = void 0;\nfunction Br(t) {\n  if (!Number.isSafeInteger(t) || t < 0)\n    throw new Error(`Wrong positive integer: ${t}`);\n}\nne.number = Br;\nfunction Us(t) {\n  if (typeof t != \"boolean\")\n    throw new Error(`Expected boolean, not ${t}`);\n}\nne.bool = Us;\nfunction ei(t, ...e) {\n  if (!(t instanceof Uint8Array))\n    throw new Error(\"Expected Uint8Array\");\n  if (e.length > 0 && !e.includes(t.length))\n    throw new Error(`Expected Uint8Array of length ${e}, not of length=${t.length}`);\n}\nne.bytes = ei;\nfunction js(t) {\n  if (typeof t != \"function\" || typeof t.create != \"function\")\n    throw new Error(\"Hash should be wrapped by utils.wrapConstructor\");\n  Br(t.outputLen), Br(t.blockLen);\n}\nne.hash = js;\nfunction Hs(t, e = !0) {\n  if (t.destroyed)\n    throw new Error(\"Hash instance has been destroyed\");\n  if (e && t.finished)\n    throw new Error(\"Hash#digest() has already been called\");\n}\nne.exists = Hs;\nfunction Ms(t, e) {\n  ei(t);\n  const r = e.outputLen;\n  if (t.length < r)\n    throw new Error(`digestInto() expects output buffer of length at least ${r}`);\n}\nne.output = Ms;\nconst Fu = {\n  number: Br,\n  bool: Us,\n  bytes: ei,\n  hash: js,\n  exists: Hs,\n  output: Ms\n};\nne.default = Fu;\nvar Ds = {}, ti = {};\nconst Sr = typeof globalThis == \"object\" && \"crypto\" in globalThis ? globalThis.crypto : void 0, Ku = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  crypto: Sr\n}, Symbol.toStringTag, { value: \"Module\" })), Wu = /* @__PURE__ */ Et(Ku);\n(function(t) {\n  /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n  Object.defineProperty(t, \"__esModule\", { value: !0 }), t.randomBytes = t.wrapXOFConstructorWithOpts = t.wrapConstructorWithOpts = t.wrapConstructor = t.checkOpts = t.Hash = t.concatBytes = t.toBytes = t.utf8ToBytes = t.asyncLoop = t.nextTick = t.hexToBytes = t.bytesToHex = t.isLE = t.rotr = t.createView = t.u32 = t.u8 = void 0;\n  const e = Wu, r = (w) => w instanceof Uint8Array, n = (w) => new Uint8Array(w.buffer, w.byteOffset, w.byteLength);\n  t.u8 = n;\n  const i = (w) => new Uint32Array(w.buffer, w.byteOffset, Math.floor(w.byteLength / 4));\n  t.u32 = i;\n  const s = (w) => new DataView(w.buffer, w.byteOffset, w.byteLength);\n  t.createView = s;\n  const o = (w, x) => w << 32 - x | w >>> x;\n  if (t.rotr = o, t.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68, !t.isLE)\n    throw new Error(\"Non little-endian hardware is not supported\");\n  const a = Array.from({ length: 256 }, (w, x) => x.toString(16).padStart(2, \"0\"));\n  function c(w) {\n    if (!r(w))\n      throw new Error(\"Uint8Array expected\");\n    let x = \"\";\n    for (let A = 0; A < w.length; A++)\n      x += a[w[A]];\n    return x;\n  }\n  t.bytesToHex = c;\n  function l(w) {\n    if (typeof w != \"string\")\n      throw new Error(\"hex string expected, got \" + typeof w);\n    const x = w.length;\n    if (x % 2)\n      throw new Error(\"padded hex string expected, got unpadded hex of length \" + x);\n    const A = new Uint8Array(x / 2);\n    for (let B = 0; B < A.length; B++) {\n      const L = B * 2, P = w.slice(L, L + 2), F = Number.parseInt(P, 16);\n      if (Number.isNaN(F) || F < 0)\n        throw new Error(\"Invalid byte sequence\");\n      A[B] = F;\n    }\n    return A;\n  }\n  t.hexToBytes = l;\n  const f = async () => {\n  };\n  t.nextTick = f;\n  async function u(w, x, A) {\n    let B = Date.now();\n    for (let L = 0; L < w; L++) {\n      A(L);\n      const P = Date.now() - B;\n      P >= 0 && P < x || (await (0, t.nextTick)(), B += P);\n    }\n  }\n  t.asyncLoop = u;\n  function h(w) {\n    if (typeof w != \"string\")\n      throw new Error(`utf8ToBytes expected string, got ${typeof w}`);\n    return new Uint8Array(new TextEncoder().encode(w));\n  }\n  t.utf8ToBytes = h;\n  function d(w) {\n    if (typeof w == \"string\" && (w = h(w)), !r(w))\n      throw new Error(`expected Uint8Array, got ${typeof w}`);\n    return w;\n  }\n  t.toBytes = d;\n  function p(...w) {\n    const x = new Uint8Array(w.reduce((B, L) => B + L.length, 0));\n    let A = 0;\n    return w.forEach((B) => {\n      if (!r(B))\n        throw new Error(\"Uint8Array expected\");\n      x.set(B, A), A += B.length;\n    }), x;\n  }\n  t.concatBytes = p;\n  class y {\n    clone() {\n      return this._cloneInto();\n    }\n  }\n  t.Hash = y;\n  const g = (w) => Object.prototype.toString.call(w) === \"[object Object]\" && w.constructor === Object;\n  function v(w, x) {\n    if (x !== void 0 && (typeof x != \"object\" || !g(x)))\n      throw new Error(\"Options should be object or undefined\");\n    return Object.assign(w, x);\n  }\n  t.checkOpts = v;\n  function _(w) {\n    const x = (B) => w().update(d(B)).digest(), A = w();\n    return x.outputLen = A.outputLen, x.blockLen = A.blockLen, x.create = () => w(), x;\n  }\n  t.wrapConstructor = _;\n  function m(w) {\n    const x = (B, L) => w(L).update(d(B)).digest(), A = w({});\n    return x.outputLen = A.outputLen, x.blockLen = A.blockLen, x.create = (B) => w(B), x;\n  }\n  t.wrapConstructorWithOpts = m;\n  function C(w) {\n    const x = (B, L) => w(L).update(d(B)).digest(), A = w({});\n    return x.outputLen = A.outputLen, x.blockLen = A.blockLen, x.create = (B) => w(B), x;\n  }\n  t.wrapXOFConstructorWithOpts = C;\n  function O(w = 32) {\n    if (e.crypto && typeof e.crypto.getRandomValues == \"function\")\n      return e.crypto.getRandomValues(new Uint8Array(w));\n    throw new Error(\"crypto.getRandomValues must be defined\");\n  }\n  t.randomBytes = O;\n})(ti);\n(function(t) {\n  Object.defineProperty(t, \"__esModule\", { value: !0 }), t.hmac = t.HMAC = void 0;\n  const e = ne, r = ti;\n  class n extends r.Hash {\n    constructor(o, a) {\n      super(), this.finished = !1, this.destroyed = !1, e.default.hash(o);\n      const c = (0, r.toBytes)(a);\n      if (this.iHash = o.create(), typeof this.iHash.update != \"function\")\n        throw new Error(\"Expected instance of class which extends utils.Hash\");\n      this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;\n      const l = this.blockLen, f = new Uint8Array(l);\n      f.set(c.length > l ? o.create().update(c).digest() : c);\n      for (let u = 0; u < f.length; u++)\n        f[u] ^= 54;\n      this.iHash.update(f), this.oHash = o.create();\n      for (let u = 0; u < f.length; u++)\n        f[u] ^= 106;\n      this.oHash.update(f), f.fill(0);\n    }\n    update(o) {\n      return e.default.exists(this), this.iHash.update(o), this;\n    }\n    digestInto(o) {\n      e.default.exists(this), e.default.bytes(o, this.outputLen), this.finished = !0, this.iHash.digestInto(o), this.oHash.update(o), this.oHash.digestInto(o), this.destroy();\n    }\n    digest() {\n      const o = new Uint8Array(this.oHash.outputLen);\n      return this.digestInto(o), o;\n    }\n    _cloneInto(o) {\n      o || (o = Object.create(Object.getPrototypeOf(this), {}));\n      const { oHash: a, iHash: c, finished: l, destroyed: f, blockLen: u, outputLen: h } = this;\n      return o = o, o.finished = l, o.destroyed = f, o.blockLen = u, o.outputLen = h, o.oHash = a._cloneInto(o.oHash), o.iHash = c._cloneInto(o.iHash), o;\n    }\n    destroy() {\n      this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();\n    }\n  }\n  t.HMAC = n;\n  const i = (s, o, a) => new n(s, o).update(a).digest();\n  t.hmac = i, t.hmac.create = (s, o) => new n(s, o);\n})(Ds);\nObject.defineProperty(xt, \"__esModule\", { value: !0 });\nxt.pbkdf2Async = xt.pbkdf2 = void 0;\nconst hr = ne, Vu = Ds, bt = ti;\nfunction zs(t, e, r, n) {\n  hr.default.hash(t);\n  const i = (0, bt.checkOpts)({ dkLen: 32, asyncTick: 10 }, n), { c: s, dkLen: o, asyncTick: a } = i;\n  if (hr.default.number(s), hr.default.number(o), hr.default.number(a), s < 1)\n    throw new Error(\"PBKDF2: iterations (c) should be >= 1\");\n  const c = (0, bt.toBytes)(e), l = (0, bt.toBytes)(r), f = new Uint8Array(o), u = Vu.hmac.create(t, c), h = u._cloneInto().update(l);\n  return { c: s, dkLen: o, asyncTick: a, DK: f, PRF: u, PRFSalt: h };\n}\nfunction Fs(t, e, r, n, i) {\n  return t.destroy(), e.destroy(), n && n.destroy(), i.fill(0), r;\n}\nfunction Gu(t, e, r, n) {\n  const { c: i, dkLen: s, DK: o, PRF: a, PRFSalt: c } = zs(t, e, r, n);\n  let l;\n  const f = new Uint8Array(4), u = (0, bt.createView)(f), h = new Uint8Array(a.outputLen);\n  for (let d = 1, p = 0; p < s; d++, p += a.outputLen) {\n    const y = o.subarray(p, p + a.outputLen);\n    u.setInt32(0, d, !1), (l = c._cloneInto(l)).update(f).digestInto(h), y.set(h.subarray(0, y.length));\n    for (let g = 1; g < i; g++) {\n      a._cloneInto(l).update(h).digestInto(h);\n      for (let v = 0; v < y.length; v++)\n        y[v] ^= h[v];\n    }\n  }\n  return Fs(a, c, o, l, h);\n}\nxt.pbkdf2 = Gu;\nasync function Zu(t, e, r, n) {\n  const { c: i, dkLen: s, asyncTick: o, DK: a, PRF: c, PRFSalt: l } = zs(t, e, r, n);\n  let f;\n  const u = new Uint8Array(4), h = (0, bt.createView)(u), d = new Uint8Array(c.outputLen);\n  for (let p = 1, y = 0; y < s; p++, y += c.outputLen) {\n    const g = a.subarray(y, y + c.outputLen);\n    h.setInt32(0, p, !1), (f = l._cloneInto(f)).update(u).digestInto(d), g.set(d.subarray(0, g.length)), await (0, bt.asyncLoop)(i - 1, o, (v) => {\n      c._cloneInto(f).update(d).digestInto(d);\n      for (let _ = 0; _ < g.length; _++)\n        g[_] ^= d[_];\n    });\n  }\n  return Fs(c, l, a, f, d);\n}\nxt.pbkdf2Async = Zu;\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst ri = (t) => t instanceof Uint8Array, Yu = (t) => new Uint8Array(t.buffer, t.byteOffset, t.byteLength), Ju = (t) => new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4)), ft = (t) => new DataView(t.buffer, t.byteOffset, t.byteLength), Ee = (t, e) => t << 32 - e | t >>> e, Ks = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;\nif (!Ks)\n  throw new Error(\"Non little-endian hardware is not supported\");\nconst Xu = Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, \"0\"));\nfunction ni(t) {\n  if (!ri(t))\n    throw new Error(\"Uint8Array expected\");\n  let e = \"\";\n  for (let r = 0; r < t.length; r++)\n    e += Xu[t[r]];\n  return e;\n}\nfunction Ws(t) {\n  if (typeof t != \"string\")\n    throw new Error(\"hex string expected, got \" + typeof t);\n  const e = t.length;\n  if (e % 2)\n    throw new Error(\"padded hex string expected, got unpadded hex of length \" + e);\n  const r = new Uint8Array(e / 2);\n  for (let n = 0; n < r.length; n++) {\n    const i = n * 2, s = t.slice(i, i + 2), o = Number.parseInt(s, 16);\n    if (Number.isNaN(o) || o < 0)\n      throw new Error(\"Invalid byte sequence\");\n    r[n] = o;\n  }\n  return r;\n}\nconst Vs = async () => {\n};\nasync function Qu(t, e, r) {\n  let n = Date.now();\n  for (let i = 0; i < t; i++) {\n    r(i);\n    const s = Date.now() - n;\n    s >= 0 && s < e || (await Vs(), n += s);\n  }\n}\nfunction ii(t) {\n  if (typeof t != \"string\")\n    throw new Error(`utf8ToBytes expected string, got ${typeof t}`);\n  return new Uint8Array(new TextEncoder().encode(t));\n}\nfunction Ot(t) {\n  if (typeof t == \"string\" && (t = ii(t)), !ri(t))\n    throw new Error(`expected Uint8Array, got ${typeof t}`);\n  return t;\n}\nfunction er(...t) {\n  const e = new Uint8Array(t.reduce((n, i) => n + i.length, 0));\n  let r = 0;\n  return t.forEach((n) => {\n    if (!ri(n))\n      throw new Error(\"Uint8Array expected\");\n    e.set(n, r), r += n.length;\n  }), e;\n}\nclass oi {\n  clone() {\n    return this._cloneInto();\n  }\n}\nconst el = (t) => Object.prototype.toString.call(t) === \"[object Object]\" && t.constructor === Object;\nfunction tl(t, e) {\n  if (e !== void 0 && (typeof e != \"object\" || !el(e)))\n    throw new Error(\"Options should be object or undefined\");\n  return Object.assign(t, e);\n}\nfunction nt(t) {\n  const e = (n) => t().update(Ot(n)).digest(), r = t();\n  return e.outputLen = r.outputLen, e.blockLen = r.blockLen, e.create = () => t(), e;\n}\nfunction rl(t) {\n  const e = (n, i) => t(i).update(Ot(n)).digest(), r = t({});\n  return e.outputLen = r.outputLen, e.blockLen = r.blockLen, e.create = (n) => t(n), e;\n}\nfunction nl(t) {\n  const e = (n, i) => t(i).update(Ot(n)).digest(), r = t({});\n  return e.outputLen = r.outputLen, e.blockLen = r.blockLen, e.create = (n) => t(n), e;\n}\nfunction il(t = 32) {\n  if (Sr && typeof Sr.getRandomValues == \"function\")\n    return Sr.getRandomValues(new Uint8Array(t));\n  throw new Error(\"crypto.getRandomValues must be defined\");\n}\nconst ol = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  u8: Yu,\n  u32: Ju,\n  createView: ft,\n  rotr: Ee,\n  isLE: Ks,\n  bytesToHex: ni,\n  hexToBytes: Ws,\n  nextTick: Vs,\n  asyncLoop: Qu,\n  utf8ToBytes: ii,\n  toBytes: Ot,\n  concatBytes: er,\n  Hash: oi,\n  checkOpts: tl,\n  wrapConstructor: nt,\n  wrapConstructorWithOpts: rl,\n  wrapXOFConstructorWithOpts: nl,\n  randomBytes: il\n}, Symbol.toStringTag, { value: \"Module\" }));\nfunction sl(t, e, r, n) {\n  if (typeof t.setBigUint64 == \"function\")\n    return t.setBigUint64(e, r, n);\n  const i = BigInt(32), s = BigInt(4294967295), o = Number(r >> i & s), a = Number(r & s), c = n ? 4 : 0, l = n ? 0 : 4;\n  t.setUint32(e + c, o, n), t.setUint32(e + l, a, n);\n}\nclass si extends oi {\n  constructor(e, r, n, i) {\n    super(), this.blockLen = e, this.outputLen = r, this.padOffset = n, this.isLE = i, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = ft(this.buffer);\n  }\n  update(e) {\n    Qe.exists(this);\n    const { view: r, buffer: n, blockLen: i } = this;\n    e = Ot(e);\n    const s = e.length;\n    for (let o = 0; o < s; ) {\n      const a = Math.min(i - this.pos, s - o);\n      if (a === i) {\n        const c = ft(e);\n        for (; i <= s - o; o += i)\n          this.process(c, o);\n        continue;\n      }\n      n.set(e.subarray(o, o + a), this.pos), this.pos += a, o += a, this.pos === i && (this.process(r, 0), this.pos = 0);\n    }\n    return this.length += e.length, this.roundClean(), this;\n  }\n  digestInto(e) {\n    Qe.exists(this), Qe.output(e, this), this.finished = !0;\n    const { buffer: r, view: n, blockLen: i, isLE: s } = this;\n    let { pos: o } = this;\n    r[o++] = 128, this.buffer.subarray(o).fill(0), this.padOffset > i - o && (this.process(n, 0), o = 0);\n    for (let u = o; u < i; u++)\n      r[u] = 0;\n    sl(n, i - 8, BigInt(this.length * 8), s), this.process(n, 0);\n    const a = ft(e), c = this.outputLen;\n    if (c % 4)\n      throw new Error(\"_sha2: outputLen should be aligned to 32bit\");\n    const l = c / 4, f = this.get();\n    if (l > f.length)\n      throw new Error(\"_sha2: outputLen bigger than state\");\n    for (let u = 0; u < l; u++)\n      a.setUint32(4 * u, f[u], s);\n  }\n  digest() {\n    const { buffer: e, outputLen: r } = this;\n    this.digestInto(e);\n    const n = e.slice(0, r);\n    return this.destroy(), n;\n  }\n  _cloneInto(e) {\n    e || (e = new this.constructor()), e.set(...this.get());\n    const { blockLen: r, buffer: n, length: i, finished: s, destroyed: o, pos: a } = this;\n    return e.length = i, e.pos = a, e.finished = s, e.destroyed = o, i % r && e.buffer.set(n), e;\n  }\n}\nconst al = (t, e, r) => t & e ^ ~t & r, cl = (t, e, r) => t & e ^ t & r ^ e & r, ul = new Uint32Array([\n  1116352408,\n  1899447441,\n  3049323471,\n  3921009573,\n  961987163,\n  1508970993,\n  2453635748,\n  2870763221,\n  3624381080,\n  310598401,\n  607225278,\n  1426881987,\n  1925078388,\n  2162078206,\n  2614888103,\n  3248222580,\n  3835390401,\n  4022224774,\n  264347078,\n  604807628,\n  770255983,\n  1249150122,\n  1555081692,\n  1996064986,\n  2554220882,\n  2821834349,\n  2952996808,\n  3210313671,\n  3336571891,\n  3584528711,\n  113926993,\n  338241895,\n  666307205,\n  773529912,\n  1294757372,\n  1396182291,\n  1695183700,\n  1986661051,\n  2177026350,\n  2456956037,\n  2730485921,\n  2820302411,\n  3259730800,\n  3345764771,\n  3516065817,\n  3600352804,\n  4094571909,\n  275423344,\n  430227734,\n  506948616,\n  659060556,\n  883997877,\n  958139571,\n  1322822218,\n  1537002063,\n  1747873779,\n  1955562222,\n  2024104815,\n  2227730452,\n  2361852424,\n  2428436474,\n  2756734187,\n  3204031479,\n  3329325298\n]), Ke = new Uint32Array([\n  1779033703,\n  3144134277,\n  1013904242,\n  2773480762,\n  1359893119,\n  2600822924,\n  528734635,\n  1541459225\n]), We = new Uint32Array(64);\nclass Gs extends si {\n  constructor() {\n    super(64, 32, 8, !1), this.A = Ke[0] | 0, this.B = Ke[1] | 0, this.C = Ke[2] | 0, this.D = Ke[3] | 0, this.E = Ke[4] | 0, this.F = Ke[5] | 0, this.G = Ke[6] | 0, this.H = Ke[7] | 0;\n  }\n  get() {\n    const { A: e, B: r, C: n, D: i, E: s, F: o, G: a, H: c } = this;\n    return [e, r, n, i, s, o, a, c];\n  }\n  set(e, r, n, i, s, o, a, c) {\n    this.A = e | 0, this.B = r | 0, this.C = n | 0, this.D = i | 0, this.E = s | 0, this.F = o | 0, this.G = a | 0, this.H = c | 0;\n  }\n  process(e, r) {\n    for (let u = 0; u < 16; u++, r += 4)\n      We[u] = e.getUint32(r, !1);\n    for (let u = 16; u < 64; u++) {\n      const h = We[u - 15], d = We[u - 2], p = Ee(h, 7) ^ Ee(h, 18) ^ h >>> 3, y = Ee(d, 17) ^ Ee(d, 19) ^ d >>> 10;\n      We[u] = y + We[u - 7] + p + We[u - 16] | 0;\n    }\n    let { A: n, B: i, C: s, D: o, E: a, F: c, G: l, H: f } = this;\n    for (let u = 0; u < 64; u++) {\n      const h = Ee(a, 6) ^ Ee(a, 11) ^ Ee(a, 25), d = f + h + al(a, c, l) + ul[u] + We[u] | 0, y = (Ee(n, 2) ^ Ee(n, 13) ^ Ee(n, 22)) + cl(n, i, s) | 0;\n      f = l, l = c, c = a, a = o + d | 0, o = s, s = i, i = n, n = d + y | 0;\n    }\n    n = n + this.A | 0, i = i + this.B | 0, s = s + this.C | 0, o = o + this.D | 0, a = a + this.E | 0, c = c + this.F | 0, l = l + this.G | 0, f = f + this.H | 0, this.set(n, i, s, o, a, c, l, f);\n  }\n  roundClean() {\n    We.fill(0);\n  }\n  destroy() {\n    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);\n  }\n}\nclass ll extends Gs {\n  constructor() {\n    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;\n  }\n}\nconst jr = nt(() => new Gs()), fl = nt(() => new ll()), hl = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  sha256: jr,\n  sha224: fl\n}, Symbol.toStringTag, { value: \"Module\" })), dl = /* @__PURE__ */ Et(hl), dr = BigInt(2 ** 32 - 1), $n = BigInt(32);\nfunction Zs(t, e = !1) {\n  return e ? { h: Number(t & dr), l: Number(t >> $n & dr) } : { h: Number(t >> $n & dr) | 0, l: Number(t & dr) | 0 };\n}\nfunction pl(t, e = !1) {\n  let r = new Uint32Array(t.length), n = new Uint32Array(t.length);\n  for (let i = 0; i < t.length; i++) {\n    const { h: s, l: o } = Zs(t[i], e);\n    [r[i], n[i]] = [s, o];\n  }\n  return [r, n];\n}\nconst yl = (t, e) => BigInt(t >>> 0) << $n | BigInt(e >>> 0), gl = (t, e, r) => t >>> r, bl = (t, e, r) => t << 32 - r | e >>> r, vl = (t, e, r) => t >>> r | e << 32 - r, wl = (t, e, r) => t << 32 - r | e >>> r, _l = (t, e, r) => t << 64 - r | e >>> r - 32, ml = (t, e, r) => t >>> r - 32 | e << 64 - r, xl = (t, e) => e, El = (t, e) => t, kl = (t, e, r) => t << r | e >>> 32 - r, Sl = (t, e, r) => e << r | t >>> 32 - r, Ol = (t, e, r) => e << r - 32 | t >>> 64 - r, Al = (t, e, r) => t << r - 32 | e >>> 64 - r;\nfunction Cl(t, e, r, n) {\n  const i = (e >>> 0) + (n >>> 0);\n  return { h: t + r + (i / 2 ** 32 | 0) | 0, l: i | 0 };\n}\nconst Il = (t, e, r) => (t >>> 0) + (e >>> 0) + (r >>> 0), Rl = (t, e, r, n) => e + r + n + (t / 2 ** 32 | 0) | 0, Tl = (t, e, r, n) => (t >>> 0) + (e >>> 0) + (r >>> 0) + (n >>> 0), Pl = (t, e, r, n, i) => e + r + n + i + (t / 2 ** 32 | 0) | 0, Bl = (t, e, r, n, i) => (t >>> 0) + (e >>> 0) + (r >>> 0) + (n >>> 0) + (i >>> 0), Ll = (t, e, r, n, i, s) => e + r + n + i + s + (t / 2 ** 32 | 0) | 0, N = {\n  fromBig: Zs,\n  split: pl,\n  toBig: yl,\n  shrSH: gl,\n  shrSL: bl,\n  rotrSH: vl,\n  rotrSL: wl,\n  rotrBH: _l,\n  rotrBL: ml,\n  rotr32H: xl,\n  rotr32L: El,\n  rotlSH: kl,\n  rotlSL: Sl,\n  rotlBH: Ol,\n  rotlBL: Al,\n  add: Cl,\n  add3L: Il,\n  add3H: Rl,\n  add4L: Tl,\n  add4H: Pl,\n  add5H: Ll,\n  add5L: Bl\n}, [$l, ql] = N.split([\n  \"0x428a2f98d728ae22\",\n  \"0x7137449123ef65cd\",\n  \"0xb5c0fbcfec4d3b2f\",\n  \"0xe9b5dba58189dbbc\",\n  \"0x3956c25bf348b538\",\n  \"0x59f111f1b605d019\",\n  \"0x923f82a4af194f9b\",\n  \"0xab1c5ed5da6d8118\",\n  \"0xd807aa98a3030242\",\n  \"0x12835b0145706fbe\",\n  \"0x243185be4ee4b28c\",\n  \"0x550c7dc3d5ffb4e2\",\n  \"0x72be5d74f27b896f\",\n  \"0x80deb1fe3b1696b1\",\n  \"0x9bdc06a725c71235\",\n  \"0xc19bf174cf692694\",\n  \"0xe49b69c19ef14ad2\",\n  \"0xefbe4786384f25e3\",\n  \"0x0fc19dc68b8cd5b5\",\n  \"0x240ca1cc77ac9c65\",\n  \"0x2de92c6f592b0275\",\n  \"0x4a7484aa6ea6e483\",\n  \"0x5cb0a9dcbd41fbd4\",\n  \"0x76f988da831153b5\",\n  \"0x983e5152ee66dfab\",\n  \"0xa831c66d2db43210\",\n  \"0xb00327c898fb213f\",\n  \"0xbf597fc7beef0ee4\",\n  \"0xc6e00bf33da88fc2\",\n  \"0xd5a79147930aa725\",\n  \"0x06ca6351e003826f\",\n  \"0x142929670a0e6e70\",\n  \"0x27b70a8546d22ffc\",\n  \"0x2e1b21385c26c926\",\n  \"0x4d2c6dfc5ac42aed\",\n  \"0x53380d139d95b3df\",\n  \"0x650a73548baf63de\",\n  \"0x766a0abb3c77b2a8\",\n  \"0x81c2c92e47edaee6\",\n  \"0x92722c851482353b\",\n  \"0xa2bfe8a14cf10364\",\n  \"0xa81a664bbc423001\",\n  \"0xc24b8b70d0f89791\",\n  \"0xc76c51a30654be30\",\n  \"0xd192e819d6ef5218\",\n  \"0xd69906245565a910\",\n  \"0xf40e35855771202a\",\n  \"0x106aa07032bbd1b8\",\n  \"0x19a4c116b8d2d0c8\",\n  \"0x1e376c085141ab53\",\n  \"0x2748774cdf8eeb99\",\n  \"0x34b0bcb5e19b48a8\",\n  \"0x391c0cb3c5c95a63\",\n  \"0x4ed8aa4ae3418acb\",\n  \"0x5b9cca4f7763e373\",\n  \"0x682e6ff3d6b2b8a3\",\n  \"0x748f82ee5defb2fc\",\n  \"0x78a5636f43172f60\",\n  \"0x84c87814a1f0ab72\",\n  \"0x8cc702081a6439ec\",\n  \"0x90befffa23631e28\",\n  \"0xa4506cebde82bde9\",\n  \"0xbef9a3f7b2c67915\",\n  \"0xc67178f2e372532b\",\n  \"0xca273eceea26619c\",\n  \"0xd186b8c721c0c207\",\n  \"0xeada7dd6cde0eb1e\",\n  \"0xf57d4f7fee6ed178\",\n  \"0x06f067aa72176fba\",\n  \"0x0a637dc5a2c898a6\",\n  \"0x113f9804bef90dae\",\n  \"0x1b710b35131c471b\",\n  \"0x28db77f523047d84\",\n  \"0x32caab7b40c72493\",\n  \"0x3c9ebe0a15c9bebc\",\n  \"0x431d67c49c100d4c\",\n  \"0x4cc5d4becb3e42b6\",\n  \"0x597f299cfc657e2a\",\n  \"0x5fcb6fab3ad6faec\",\n  \"0x6c44198c4a475817\"\n].map((t) => BigInt(t))), Ve = new Uint32Array(80), Ge = new Uint32Array(80);\nclass ar extends si {\n  constructor() {\n    super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;\n  }\n  get() {\n    const { Ah: e, Al: r, Bh: n, Bl: i, Ch: s, Cl: o, Dh: a, Dl: c, Eh: l, El: f, Fh: u, Fl: h, Gh: d, Gl: p, Hh: y, Hl: g } = this;\n    return [e, r, n, i, s, o, a, c, l, f, u, h, d, p, y, g];\n  }\n  set(e, r, n, i, s, o, a, c, l, f, u, h, d, p, y, g) {\n    this.Ah = e | 0, this.Al = r | 0, this.Bh = n | 0, this.Bl = i | 0, this.Ch = s | 0, this.Cl = o | 0, this.Dh = a | 0, this.Dl = c | 0, this.Eh = l | 0, this.El = f | 0, this.Fh = u | 0, this.Fl = h | 0, this.Gh = d | 0, this.Gl = p | 0, this.Hh = y | 0, this.Hl = g | 0;\n  }\n  process(e, r) {\n    for (let m = 0; m < 16; m++, r += 4)\n      Ve[m] = e.getUint32(r), Ge[m] = e.getUint32(r += 4);\n    for (let m = 16; m < 80; m++) {\n      const C = Ve[m - 15] | 0, O = Ge[m - 15] | 0, w = N.rotrSH(C, O, 1) ^ N.rotrSH(C, O, 8) ^ N.shrSH(C, O, 7), x = N.rotrSL(C, O, 1) ^ N.rotrSL(C, O, 8) ^ N.shrSL(C, O, 7), A = Ve[m - 2] | 0, B = Ge[m - 2] | 0, L = N.rotrSH(A, B, 19) ^ N.rotrBH(A, B, 61) ^ N.shrSH(A, B, 6), P = N.rotrSL(A, B, 19) ^ N.rotrBL(A, B, 61) ^ N.shrSL(A, B, 6), F = N.add4L(x, P, Ge[m - 7], Ge[m - 16]), z = N.add4H(F, w, L, Ve[m - 7], Ve[m - 16]);\n      Ve[m] = z | 0, Ge[m] = F | 0;\n    }\n    let { Ah: n, Al: i, Bh: s, Bl: o, Ch: a, Cl: c, Dh: l, Dl: f, Eh: u, El: h, Fh: d, Fl: p, Gh: y, Gl: g, Hh: v, Hl: _ } = this;\n    for (let m = 0; m < 80; m++) {\n      const C = N.rotrSH(u, h, 14) ^ N.rotrSH(u, h, 18) ^ N.rotrBH(u, h, 41), O = N.rotrSL(u, h, 14) ^ N.rotrSL(u, h, 18) ^ N.rotrBL(u, h, 41), w = u & d ^ ~u & y, x = h & p ^ ~h & g, A = N.add5L(_, O, x, ql[m], Ge[m]), B = N.add5H(A, v, C, w, $l[m], Ve[m]), L = A | 0, P = N.rotrSH(n, i, 28) ^ N.rotrBH(n, i, 34) ^ N.rotrBH(n, i, 39), F = N.rotrSL(n, i, 28) ^ N.rotrBL(n, i, 34) ^ N.rotrBL(n, i, 39), z = n & s ^ n & a ^ s & a, G = i & o ^ i & c ^ o & c;\n      v = y | 0, _ = g | 0, y = d | 0, g = p | 0, d = u | 0, p = h | 0, { h: u, l: h } = N.add(l | 0, f | 0, B | 0, L | 0), l = a | 0, f = c | 0, a = s | 0, c = o | 0, s = n | 0, o = i | 0;\n      const E = N.add3L(L, F, G);\n      n = N.add3H(E, B, P, z), i = E | 0;\n    }\n    ({ h: n, l: i } = N.add(this.Ah | 0, this.Al | 0, n | 0, i | 0)), { h: s, l: o } = N.add(this.Bh | 0, this.Bl | 0, s | 0, o | 0), { h: a, l: c } = N.add(this.Ch | 0, this.Cl | 0, a | 0, c | 0), { h: l, l: f } = N.add(this.Dh | 0, this.Dl | 0, l | 0, f | 0), { h: u, l: h } = N.add(this.Eh | 0, this.El | 0, u | 0, h | 0), { h: d, l: p } = N.add(this.Fh | 0, this.Fl | 0, d | 0, p | 0), { h: y, l: g } = N.add(this.Gh | 0, this.Gl | 0, y | 0, g | 0), { h: v, l: _ } = N.add(this.Hh | 0, this.Hl | 0, v | 0, _ | 0), this.set(n, i, s, o, a, c, l, f, u, h, d, p, y, g, v, _);\n  }\n  roundClean() {\n    Ve.fill(0), Ge.fill(0);\n  }\n  destroy() {\n    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n  }\n}\nclass Nl extends ar {\n  constructor() {\n    super(), this.Ah = -1942145080, this.Al = 424955298, this.Bh = 1944164710, this.Bl = -1982016298, this.Ch = 502970286, this.Cl = 855612546, this.Dh = 1738396948, this.Dl = 1479516111, this.Eh = 258812777, this.El = 2077511080, this.Fh = 2011393907, this.Fl = 79989058, this.Gh = 1067287976, this.Gl = 1780299464, this.Hh = 286451373, this.Hl = -1848208735, this.outputLen = 28;\n  }\n}\nclass Ul extends ar {\n  constructor() {\n    super(), this.Ah = 573645204, this.Al = -64227540, this.Bh = -1621794909, this.Bl = -934517566, this.Ch = 596883563, this.Cl = 1867755857, this.Dh = -1774684391, this.Dl = 1497426621, this.Eh = -1775747358, this.El = -1467023389, this.Fh = -1101128155, this.Fl = 1401305490, this.Gh = 721525244, this.Gl = 746961066, this.Hh = 246885852, this.Hl = -2117784414, this.outputLen = 32;\n  }\n}\nclass jl extends ar {\n  constructor() {\n    super(), this.Ah = -876896931, this.Al = -1056596264, this.Bh = 1654270250, this.Bl = 914150663, this.Ch = -1856437926, this.Cl = 812702999, this.Dh = 355462360, this.Dl = -150054599, this.Eh = 1731405415, this.El = -4191439, this.Fh = -1900787065, this.Fl = 1750603025, this.Gh = -619958771, this.Gl = 1694076839, this.Hh = 1203062813, this.Hl = -1090891868, this.outputLen = 48;\n  }\n}\nconst qn = nt(() => new ar()), Hl = nt(() => new Nl()), Ml = nt(() => new Ul()), Dl = nt(() => new jl()), zl = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  SHA512: ar,\n  sha512: qn,\n  sha512_224: Hl,\n  sha512_256: Ml,\n  sha384: Dl\n}, Symbol.toStringTag, { value: \"Module\" })), Fl = /* @__PURE__ */ Et(zl), Kl = /* @__PURE__ */ Et(ol), Wl = /* @__PURE__ */ Et(Mu);\nObject.defineProperty(de, \"__esModule\", { value: !0 });\nvar Ys = de.mnemonicToSeedSync = de.mnemonicToSeed = sa = de.validateMnemonic = de.entropyToMnemonic = de.mnemonicToEntropy = ra = de.generateMnemonic = void 0;\n/*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */\nconst Js = zu, Xs = xt, Vl = dl, Qs = Fl, Gl = Kl, pr = Wl, Zl = (t) => t[0] === \"\\u3042\\u3044\\u3053\\u304F\\u3057\\u3093\";\nfunction ea(t) {\n  if (typeof t != \"string\")\n    throw new TypeError(`Invalid mnemonic type: ${typeof t}`);\n  return t.normalize(\"NFKD\");\n}\nfunction ai(t) {\n  const e = ea(t), r = e.split(\" \");\n  if (![12, 15, 18, 21, 24].includes(r.length))\n    throw new Error(\"Invalid mnemonic\");\n  return { nfkd: e, words: r };\n}\nfunction ta(t) {\n  Js.default.bytes(t, 16, 20, 24, 28, 32);\n}\nfunction Yl(t, e = 128) {\n  if (Js.default.number(e), e % 32 !== 0 || e > 256)\n    throw new TypeError(\"Invalid entropy\");\n  return oa((0, Gl.randomBytes)(e / 8), t);\n}\nvar ra = de.generateMnemonic = Yl;\nconst Jl = (t) => {\n  const e = 8 - t.length / 4;\n  return new Uint8Array([(0, Vl.sha256)(t)[0] >> e << e]);\n};\nfunction na(t) {\n  if (!Array.isArray(t) || t.length !== 2048 || typeof t[0] != \"string\")\n    throw new Error(\"Worlist: expected array of 2048 strings\");\n  return t.forEach((e) => {\n    if (typeof e != \"string\")\n      throw new Error(`Wordlist: non-string element: ${e}`);\n  }), pr.utils.chain(pr.utils.checksum(1, Jl), pr.utils.radix2(11, !0), pr.utils.alphabet(t));\n}\nfunction ia(t, e) {\n  const { words: r } = ai(t), n = na(e).decode(r);\n  return ta(n), n;\n}\nde.mnemonicToEntropy = ia;\nfunction oa(t, e) {\n  return ta(t), na(e).encode(t).join(Zl(e) ? \"\\u3000\" : \" \");\n}\nde.entropyToMnemonic = oa;\nfunction Xl(t, e) {\n  try {\n    ia(t, e);\n  } catch {\n    return !1;\n  }\n  return !0;\n}\nvar sa = de.validateMnemonic = Xl;\nconst aa = (t) => ea(`mnemonic${t}`);\nfunction Ql(t, e = \"\") {\n  return (0, Xs.pbkdf2Async)(Qs.sha512, ai(t).nfkd, aa(e), { c: 2048, dkLen: 64 });\n}\nde.mnemonicToSeed = Ql;\nfunction ef(t, e = \"\") {\n  return (0, Xs.pbkdf2)(Qs.sha512, ai(t).nfkd, aa(e), { c: 2048, dkLen: 64 });\n}\nYs = de.mnemonicToSeedSync = ef;\nclass ca extends oi {\n  constructor(e, r) {\n    super(), this.finished = !1, this.destroyed = !1, Qe.hash(e);\n    const n = Ot(r);\n    if (this.iHash = e.create(), typeof this.iHash.update != \"function\")\n      throw new Error(\"Expected instance of class which extends utils.Hash\");\n    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;\n    const i = this.blockLen, s = new Uint8Array(i);\n    s.set(n.length > i ? e.create().update(n).digest() : n);\n    for (let o = 0; o < s.length; o++)\n      s[o] ^= 54;\n    this.iHash.update(s), this.oHash = e.create();\n    for (let o = 0; o < s.length; o++)\n      s[o] ^= 106;\n    this.oHash.update(s), s.fill(0);\n  }\n  update(e) {\n    return Qe.exists(this), this.iHash.update(e), this;\n  }\n  digestInto(e) {\n    Qe.exists(this), Qe.bytes(e, this.outputLen), this.finished = !0, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy();\n  }\n  digest() {\n    const e = new Uint8Array(this.oHash.outputLen);\n    return this.digestInto(e), e;\n  }\n  _cloneInto(e) {\n    e || (e = Object.create(Object.getPrototypeOf(this), {}));\n    const { oHash: r, iHash: n, finished: i, destroyed: s, blockLen: o, outputLen: a } = this;\n    return e = e, e.finished = i, e.destroyed = s, e.blockLen = o, e.outputLen = a, e.oHash = r._cloneInto(e.oHash), e.iHash = n._cloneInto(e.iHash), e;\n  }\n  destroy() {\n    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();\n  }\n}\nconst Nn = (t, e, r) => new ca(t, e).update(r).digest();\nNn.create = (t, e) => new ca(t, e);\nconst tf = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]), ua = Uint8Array.from({ length: 16 }, (t, e) => e), rf = ua.map((t) => (9 * t + 5) % 16);\nlet ci = [ua], ui = [rf];\nfor (let t = 0; t < 4; t++)\n  for (let e of [ci, ui])\n    e.push(e[t].map((r) => tf[r]));\nconst la = [\n  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],\n  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],\n  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],\n  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],\n  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]\n].map((t) => new Uint8Array(t)), nf = ci.map((t, e) => t.map((r) => la[e][r])), of = ui.map((t, e) => t.map((r) => la[e][r])), sf = new Uint32Array([0, 1518500249, 1859775393, 2400959708, 2840853838]), af = new Uint32Array([1352829926, 1548603684, 1836072691, 2053994217, 0]), yr = (t, e) => t << e | t >>> 32 - e;\nfunction Zi(t, e, r, n) {\n  return t === 0 ? e ^ r ^ n : t === 1 ? e & r | ~e & n : t === 2 ? (e | ~r) ^ n : t === 3 ? e & n | r & ~n : e ^ (r | ~n);\n}\nconst gr = new Uint32Array(16);\nclass cf extends si {\n  constructor() {\n    super(64, 20, 8, !0), this.h0 = 1732584193, this.h1 = -271733879, this.h2 = -1732584194, this.h3 = 271733878, this.h4 = -1009589776;\n  }\n  get() {\n    const { h0: e, h1: r, h2: n, h3: i, h4: s } = this;\n    return [e, r, n, i, s];\n  }\n  set(e, r, n, i, s) {\n    this.h0 = e | 0, this.h1 = r | 0, this.h2 = n | 0, this.h3 = i | 0, this.h4 = s | 0;\n  }\n  process(e, r) {\n    for (let d = 0; d < 16; d++, r += 4)\n      gr[d] = e.getUint32(r, !0);\n    let n = this.h0 | 0, i = n, s = this.h1 | 0, o = s, a = this.h2 | 0, c = a, l = this.h3 | 0, f = l, u = this.h4 | 0, h = u;\n    for (let d = 0; d < 5; d++) {\n      const p = 4 - d, y = sf[d], g = af[d], v = ci[d], _ = ui[d], m = nf[d], C = of[d];\n      for (let O = 0; O < 16; O++) {\n        const w = yr(n + Zi(d, s, a, l) + gr[v[O]] + y, m[O]) + u | 0;\n        n = u, u = l, l = yr(a, 10) | 0, a = s, s = w;\n      }\n      for (let O = 0; O < 16; O++) {\n        const w = yr(i + Zi(p, o, c, f) + gr[_[O]] + g, C[O]) + h | 0;\n        i = h, h = f, f = yr(c, 10) | 0, c = o, o = w;\n      }\n    }\n    this.set(this.h1 + a + f | 0, this.h2 + l + h | 0, this.h3 + u + i | 0, this.h4 + n + o | 0, this.h0 + s + c | 0);\n  }\n  roundClean() {\n    gr.fill(0);\n  }\n  destroy() {\n    this.destroyed = !0, this.buffer.fill(0), this.set(0, 0, 0, 0, 0);\n  }\n}\nconst uf = nt(() => new cf()), br = ue.ProjectivePoint, ln = As(jr);\nfunction Yi(t) {\n  return BigInt(`0x${ni(t)}`);\n}\nfunction lf(t) {\n  return Ws(t.toString(16).padStart(64, \"0\"));\n}\nconst ff = ii(\"Bitcoin seed\"), fn = { private: 76066276, public: 76067358 }, hn = 2147483648, hf = (t) => uf(jr(t)), df = (t) => ft(t).getUint32(0, !1), vr = (t) => {\n  if (!Number.isSafeInteger(t) || t < 0 || t > 2 ** 32 - 1)\n    throw new Error(`Invalid number=${t}. Should be from 0 to 2 ** 32 - 1`);\n  const e = new Uint8Array(4);\n  return ft(e).setUint32(0, t, !1), e;\n};\nclass ct {\n  get fingerprint() {\n    if (!this.pubHash)\n      throw new Error(\"No publicKey set!\");\n    return df(this.pubHash);\n  }\n  get identifier() {\n    return this.pubHash;\n  }\n  get pubKeyHash() {\n    return this.pubHash;\n  }\n  get privateKey() {\n    return this.privKeyBytes || null;\n  }\n  get publicKey() {\n    return this.pubKey || null;\n  }\n  get privateExtendedKey() {\n    const e = this.privateKey;\n    if (!e)\n      throw new Error(\"No private key\");\n    return ln.encode(this.serialize(this.versions.private, er(new Uint8Array([0]), e)));\n  }\n  get publicExtendedKey() {\n    if (!this.pubKey)\n      throw new Error(\"No public key\");\n    return ln.encode(this.serialize(this.versions.public, this.pubKey));\n  }\n  static fromMasterSeed(e, r = fn) {\n    if (Ye(e), 8 * e.length < 128 || 8 * e.length > 512)\n      throw new Error(`HDKey: wrong seed length=${e.length}. Should be between 128 and 512 bits; 256 bits is advised)`);\n    const n = Nn(qn, ff, e);\n    return new ct({\n      versions: r,\n      chainCode: n.slice(32),\n      privateKey: n.slice(0, 32)\n    });\n  }\n  static fromExtendedKey(e, r = fn) {\n    const n = ln.decode(e), i = ft(n), s = i.getUint32(0, !1), o = {\n      versions: r,\n      depth: n[4],\n      parentFingerprint: i.getUint32(5, !1),\n      index: i.getUint32(9, !1),\n      chainCode: n.slice(13, 45)\n    }, a = n.slice(45), c = a[0] === 0;\n    if (s !== r[c ? \"private\" : \"public\"])\n      throw new Error(\"Version mismatch\");\n    return c ? new ct({ ...o, privateKey: a.slice(1) }) : new ct({ ...o, publicKey: a });\n  }\n  static fromJSON(e) {\n    return ct.fromExtendedKey(e.xpriv);\n  }\n  constructor(e) {\n    if (this.depth = 0, this.index = 0, this.chainCode = null, this.parentFingerprint = 0, !e || typeof e != \"object\")\n      throw new Error(\"HDKey.constructor must not be called directly\");\n    if (this.versions = e.versions || fn, this.depth = e.depth || 0, this.chainCode = e.chainCode, this.index = e.index || 0, this.parentFingerprint = e.parentFingerprint || 0, !this.depth && (this.parentFingerprint || this.index))\n      throw new Error(\"HDKey: zero depth with non-zero index/parent fingerprint\");\n    if (e.publicKey && e.privateKey)\n      throw new Error(\"HDKey: publicKey and privateKey at same time.\");\n    if (e.privateKey) {\n      if (!ue.utils.isValidPrivateKey(e.privateKey))\n        throw new Error(\"Invalid private key\");\n      this.privKey = typeof e.privateKey == \"bigint\" ? e.privateKey : Yi(e.privateKey), this.privKeyBytes = lf(this.privKey), this.pubKey = ue.getPublicKey(e.privateKey, !0);\n    } else if (e.publicKey)\n      this.pubKey = br.fromHex(e.publicKey).toRawBytes(!0);\n    else\n      throw new Error(\"HDKey: no public or private key provided\");\n    this.pubHash = hf(this.pubKey);\n  }\n  derive(e) {\n    if (!/^[mM]'?/.test(e))\n      throw new Error('Path must start with \"m\" or \"M\"');\n    if (/^[mM]'?$/.test(e))\n      return this;\n    const r = e.replace(/^[mM]'?\\//, \"\").split(\"/\");\n    let n = this;\n    for (const i of r) {\n      const s = /^(\\d+)('?)$/.exec(i);\n      if (!s || s.length !== 3)\n        throw new Error(`Invalid child index: ${i}`);\n      let o = +s[1];\n      if (!Number.isSafeInteger(o) || o >= hn)\n        throw new Error(\"Invalid index\");\n      s[2] === \"'\" && (o += hn), n = n.deriveChild(o);\n    }\n    return n;\n  }\n  deriveChild(e) {\n    if (!this.pubKey || !this.chainCode)\n      throw new Error(\"No publicKey or chainCode set\");\n    let r = vr(e);\n    if (e >= hn) {\n      const a = this.privateKey;\n      if (!a)\n        throw new Error(\"Could not derive hardened child key\");\n      r = er(new Uint8Array([0]), a, r);\n    } else\n      r = er(this.pubKey, r);\n    const n = Nn(qn, this.chainCode, r), i = Yi(n.slice(0, 32)), s = n.slice(32);\n    if (!ue.utils.isValidPrivateKey(i))\n      throw new Error(\"Tweak bigger than curve order\");\n    const o = {\n      versions: this.versions,\n      chainCode: s,\n      depth: this.depth + 1,\n      parentFingerprint: this.fingerprint,\n      index: e\n    };\n    try {\n      if (this.privateKey) {\n        const a = J(this.privKey + i, ue.CURVE.n);\n        if (!ue.utils.isValidPrivateKey(a))\n          throw new Error(\"The tweak was out of range or the resulted private key is invalid\");\n        o.privateKey = a;\n      } else {\n        const a = br.fromHex(this.pubKey).add(br.fromPrivateKey(i));\n        if (a.equals(br.ZERO))\n          throw new Error(\"The tweak was equal to negative P, which made the result key invalid\");\n        o.publicKey = a.toRawBytes(!0);\n      }\n      return new ct(o);\n    } catch {\n      return this.deriveChild(e + 1);\n    }\n  }\n  sign(e) {\n    if (!this.privateKey)\n      throw new Error(\"No privateKey set!\");\n    return Ye(e, 32), ue.sign(e, this.privKey).toCompactRawBytes();\n  }\n  verify(e, r) {\n    if (Ye(e, 32), Ye(r, 64), !this.publicKey)\n      throw new Error(\"No publicKey set!\");\n    let n;\n    try {\n      n = ue.Signature.fromCompact(r);\n    } catch {\n      return !1;\n    }\n    return ue.verify(n, e, this.publicKey);\n  }\n  wipePrivateData() {\n    return this.privKey = void 0, this.privKeyBytes && (this.privKeyBytes.fill(0), this.privKeyBytes = void 0), this;\n  }\n  toJSON() {\n    return {\n      xpriv: this.privateExtendedKey,\n      xpub: this.publicExtendedKey\n    };\n  }\n  serialize(e, r) {\n    if (!this.chainCode)\n      throw new Error(\"No chainCode set\");\n    return Ye(r, 33), er(vr(e), new Uint8Array([this.depth]), vr(this.parentFingerprint), vr(this.index), this.chainCode, r);\n  }\n}\nvar pf = Object.defineProperty, ie = (t, e) => {\n  for (var r in e)\n    pf(t, r, { get: e[r], enumerable: !0 });\n};\nfunction yf() {\n  return ve(St.utils.randomPrivateKey());\n}\nfunction li(t) {\n  return ve(St.getPublicKey(t));\n}\nvar gf = {};\nie(gf, {\n  MessageNode: () => fa,\n  MessageQueue: () => ha,\n  insertEventIntoAscendingList: () => wf,\n  insertEventIntoDescendingList: () => vf,\n  normalizeURL: () => bf,\n  utf8Decoder: () => Je,\n  utf8Encoder: () => Ie\n});\nvar Je = new TextDecoder(\"utf-8\"), Ie = new TextEncoder();\nfunction bf(t) {\n  let e = new URL(t);\n  return e.pathname = e.pathname.replace(/\\/+/g, \"/\"), e.pathname.endsWith(\"/\") && (e.pathname = e.pathname.slice(0, -1)), (e.port === \"80\" && e.protocol === \"ws:\" || e.port === \"443\" && e.protocol === \"wss:\") && (e.port = \"\"), e.searchParams.sort(), e.hash = \"\", e.toString();\n}\nfunction vf(t, e) {\n  var o;\n  let r = 0, n = t.length - 1, i, s = r;\n  if (n < 0)\n    s = 0;\n  else if (e.created_at < t[n].created_at)\n    s = n + 1;\n  else if (e.created_at >= t[r].created_at)\n    s = r;\n  else\n    for (; ; ) {\n      if (n <= r + 1) {\n        s = n;\n        break;\n      }\n      if (i = Math.floor(r + (n - r) / 2), t[i].created_at > e.created_at)\n        r = i;\n      else if (t[i].created_at < e.created_at)\n        n = i;\n      else {\n        s = i;\n        break;\n      }\n    }\n  return ((o = t[s]) == null ? void 0 : o.id) !== e.id ? [\n    ...t.slice(0, s),\n    e,\n    ...t.slice(s)\n  ] : t;\n}\nfunction wf(t, e) {\n  var o;\n  let r = 0, n = t.length - 1, i, s = r;\n  if (n < 0)\n    s = 0;\n  else if (e.created_at > t[n].created_at)\n    s = n + 1;\n  else if (e.created_at <= t[r].created_at)\n    s = r;\n  else\n    for (; ; ) {\n      if (n <= r + 1) {\n        s = n;\n        break;\n      }\n      if (i = Math.floor(r + (n - r) / 2), t[i].created_at < e.created_at)\n        r = i;\n      else if (t[i].created_at > e.created_at)\n        n = i;\n      else {\n        s = i;\n        break;\n      }\n    }\n  return ((o = t[s]) == null ? void 0 : o.id) !== e.id ? [\n    ...t.slice(0, s),\n    e,\n    ...t.slice(s)\n  ] : t;\n}\nvar fa = class {\n  constructor(t) {\n    I(this, \"_value\");\n    I(this, \"_next\");\n    this._value = t, this._next = null;\n  }\n  get value() {\n    return this._value;\n  }\n  set value(t) {\n    this._value = t;\n  }\n  get next() {\n    return this._next;\n  }\n  set next(t) {\n    this._next = t;\n  }\n}, ha = class {\n  constructor() {\n    I(this, \"_first\");\n    I(this, \"_last\");\n    I(this, \"_size\");\n    this._first = null, this._last = null, this._size = 0;\n  }\n  get first() {\n    return this._first;\n  }\n  set first(t) {\n    this._first = t;\n  }\n  get last() {\n    return this._last;\n  }\n  set last(t) {\n    this._last = t;\n  }\n  get size() {\n    return this._size;\n  }\n  set size(t) {\n    this._size = t;\n  }\n  enqueue(t) {\n    const e = new fa(t);\n    return this._size === 0 || !this._last ? (this._first = e, this._last = e) : (this._last.next = e, this._last = e), this._size++, !0;\n  }\n  dequeue() {\n    if (this._size === 0 || !this._first)\n      return null;\n    let t = this._first;\n    return this._first = t.next, t.next = null, this._size--, t.value;\n  }\n};\nfunction da(t, e) {\n  let r = t;\n  return r.pubkey = li(e), r.id = Hr(r), r.sig = pa(r, e), r;\n}\nfunction _f(t) {\n  if (!fi(t))\n    throw new Error(\"can't serialize event with wrong or missing properties\");\n  return JSON.stringify([\n    0,\n    t.pubkey,\n    t.created_at,\n    t.kind,\n    t.tags,\n    t.content\n  ]);\n}\nfunction Hr(t) {\n  let e = Yn(Ie.encode(_f(t)));\n  return ve(e);\n}\nvar mf = (t) => t instanceof Object;\nfunction fi(t) {\n  if (!mf(t) || typeof t.kind != \"number\" || typeof t.content != \"string\" || typeof t.created_at != \"number\" || typeof t.pubkey != \"string\" || !t.pubkey.match(/^[a-f0-9]{64}$/) || !Array.isArray(t.tags))\n    return !1;\n  for (let e = 0; e < t.tags.length; e++) {\n    let r = t.tags[e];\n    if (!Array.isArray(r))\n      return !1;\n    for (let n = 0; n < r.length; n++)\n      if (typeof r[n] == \"object\")\n        return !1;\n  }\n  return !0;\n}\nfunction hi(t) {\n  try {\n    return St.verify(t.sig, Hr(t), t.pubkey);\n  } catch {\n    return !1;\n  }\n}\nfunction pa(t, e) {\n  return ve(St.sign(Hr(t), e));\n}\nfunction ya(t, e) {\n  if (t.ids && t.ids.indexOf(e.id) === -1 && !t.ids.some((r) => e.id.startsWith(r)) || t.kinds && t.kinds.indexOf(e.kind) === -1 || t.authors && t.authors.indexOf(e.pubkey) === -1 && !t.authors.some((r) => e.pubkey.startsWith(r)))\n    return !1;\n  for (let r in t)\n    if (r[0] === \"#\") {\n      let n = r.slice(1), i = t[`#${n}`];\n      if (i && !e.tags.find(\n        ([s, o]) => s === r.slice(1) && i.indexOf(o) !== -1\n      ))\n        return !1;\n    }\n  return !(t.since && e.created_at < t.since || t.until && e.created_at >= t.until);\n}\nfunction xf(t, e) {\n  for (let r = 0; r < t.length; r++)\n    if (ya(t[r], e))\n      return !0;\n  return !1;\n}\nvar Ef = {};\nie(Ef, {\n  getHex64: () => Mr,\n  getInt: () => ga,\n  getSubscriptionId: () => ba,\n  matchEventId: () => kf,\n  matchEventKind: () => Of,\n  matchEventPubkey: () => Sf\n});\nfunction Mr(t, e) {\n  let r = e.length + 3, n = t.indexOf(`\"${e}\":`) + r, i = t.slice(n).indexOf('\"') + n + 1;\n  return t.slice(i, i + 64);\n}\nfunction ga(t, e) {\n  let r = e.length, n = t.indexOf(`\"${e}\":`) + r + 3, i = t.slice(n), s = Math.min(i.indexOf(\",\"), i.indexOf(\"}\"));\n  return parseInt(i.slice(0, s), 10);\n}\nfunction ba(t) {\n  let e = t.slice(0, 22).indexOf('\"EVENT\"');\n  if (e === -1)\n    return null;\n  let r = t.slice(e + 7 + 1).indexOf('\"');\n  if (r === -1)\n    return null;\n  let n = e + 7 + 1 + r, i = t.slice(n + 1, 80).indexOf('\"');\n  if (i === -1)\n    return null;\n  let s = n + 1 + i;\n  return t.slice(n + 1, s);\n}\nfunction kf(t, e) {\n  return e === Mr(t, \"id\");\n}\nfunction Sf(t, e) {\n  return e === Mr(t, \"pubkey\");\n}\nfunction Of(t, e) {\n  return e === ga(t, \"kind\");\n}\nvar Ji = () => ({\n  connect: [],\n  disconnect: [],\n  error: [],\n  notice: [],\n  auth: []\n});\nfunction Af(t, e = {}) {\n  let { listTimeout: r = 3e3, getTimeout: n = 3e3, countTimeout: i = 3e3 } = e;\n  var s, o = {}, a = Ji(), c = {}, l = {}, f;\n  async function u() {\n    return f || (f = new Promise((v, _) => {\n      try {\n        s = new WebSocket(t);\n      } catch (w) {\n        _(w);\n      }\n      s.onopen = () => {\n        a.connect.forEach((w) => w()), v();\n      }, s.onerror = () => {\n        f = void 0, a.error.forEach((w) => w()), _();\n      }, s.onclose = async () => {\n        f = void 0, a.disconnect.forEach((w) => w());\n      };\n      let m = new ha(), C;\n      s.onmessage = (w) => {\n        m.enqueue(w.data), C || (C = setInterval(O, 0));\n      };\n      function O() {\n        var A, B, L;\n        if (m.size === 0) {\n          clearInterval(C), C = null;\n          return;\n        }\n        var w = m.dequeue();\n        if (!w)\n          return;\n        let x = ba(w);\n        if (x) {\n          let P = o[x];\n          if (P && P.alreadyHaveEvent && P.alreadyHaveEvent(Mr(w, \"id\"), t))\n            return;\n        }\n        try {\n          let P = JSON.parse(w);\n          switch (P[0]) {\n            case \"EVENT\": {\n              let E = P[1], R = P[2];\n              fi(R) && o[E] && (o[E].skipVerification || hi(R)) && xf(o[E].filters, R) && (o[E], (((A = c[E]) == null ? void 0 : A.event) || []).forEach((q) => q(R)));\n              return;\n            }\n            case \"COUNT\":\n              let F = P[1], z = P[2];\n              o[F] && (((B = c[F]) == null ? void 0 : B.count) || []).forEach((E) => E(z));\n              return;\n            case \"EOSE\": {\n              let E = P[1];\n              E in c && (c[E].eose.forEach((R) => R()), c[E].eose = []);\n              return;\n            }\n            case \"OK\": {\n              let E = P[1], R = P[2], q = P[3] || \"\";\n              E in l && (R ? l[E].ok.forEach((H) => H()) : l[E].failed.forEach((H) => H(q)), l[E].ok = [], l[E].failed = []);\n              return;\n            }\n            case \"NOTICE\":\n              let G = P[1];\n              a.notice.forEach((E) => E(G));\n              return;\n            case \"AUTH\": {\n              let E = P[1];\n              (L = a.auth) == null || L.forEach((R) => R(E));\n              return;\n            }\n          }\n        } catch {\n          return;\n        }\n      }\n    }), f);\n  }\n  function h() {\n    return (s == null ? void 0 : s.readyState) === 1;\n  }\n  async function d() {\n    h() || await u();\n  }\n  async function p(v) {\n    let _ = JSON.stringify(v);\n    if (!(!h() && (await new Promise((m) => setTimeout(m, 1e3)), !h())))\n      try {\n        s.send(_);\n      } catch (m) {\n        console.log(m);\n      }\n  }\n  const y = (v, {\n    verb: _ = \"REQ\",\n    skipVerification: m = !1,\n    alreadyHaveEvent: C = null,\n    id: O = Math.random().toString().slice(2)\n  } = {}) => {\n    let w = O;\n    return o[w] = {\n      id: w,\n      filters: v,\n      skipVerification: m,\n      alreadyHaveEvent: C\n    }, p([_, w, ...v]), {\n      sub: (x, A = {}) => y(x || v, {\n        skipVerification: A.skipVerification || m,\n        alreadyHaveEvent: A.alreadyHaveEvent || C,\n        id: w\n      }),\n      unsub: () => {\n        delete o[w], delete c[w], p([\"CLOSE\", w]);\n      },\n      on: (x, A) => {\n        c[w] = c[w] || {\n          event: [],\n          count: [],\n          eose: []\n        }, c[w][x].push(A);\n      },\n      off: (x, A) => {\n        let B = c[w], L = B[x].indexOf(A);\n        L >= 0 && B[x].splice(L, 1);\n      }\n    };\n  };\n  function g(v, _) {\n    if (!v.id)\n      throw new Error(`event ${v} has no id`);\n    let m = v.id;\n    return p([_, v]), {\n      on: (C, O) => {\n        l[m] = l[m] || {\n          ok: [],\n          failed: []\n        }, l[m][C].push(O);\n      },\n      off: (C, O) => {\n        let w = l[m];\n        if (!w)\n          return;\n        let x = w[C].indexOf(O);\n        x >= 0 && w[C].splice(x, 1);\n      }\n    };\n  }\n  return {\n    url: t,\n    sub: y,\n    on: (v, _) => {\n      a[v].push(_), v === \"connect\" && (s == null ? void 0 : s.readyState) === 1 && _();\n    },\n    off: (v, _) => {\n      let m = a[v].indexOf(_);\n      m !== -1 && a[v].splice(m, 1);\n    },\n    list: (v, _) => new Promise((m) => {\n      let C = y(v, _), O = [], w = setTimeout(() => {\n        C.unsub(), m(O);\n      }, r);\n      C.on(\"eose\", () => {\n        C.unsub(), clearTimeout(w), m(O);\n      }), C.on(\"event\", (x) => {\n        O.push(x);\n      });\n    }),\n    get: (v, _) => new Promise((m) => {\n      let C = y([v], _), O = setTimeout(() => {\n        C.unsub(), m(null);\n      }, n);\n      C.on(\"event\", (w) => {\n        C.unsub(), clearTimeout(O), m(w);\n      });\n    }),\n    count: (v) => new Promise((_) => {\n      let m = y(v, { ...y, verb: \"COUNT\" }), C = setTimeout(() => {\n        m.unsub(), _(null);\n      }, i);\n      m.on(\"count\", (O) => {\n        m.unsub(), clearTimeout(C), _(O);\n      });\n    }),\n    publish(v) {\n      return g(v, \"EVENT\");\n    },\n    auth(v) {\n      return g(v, \"AUTH\");\n    },\n    connect: d,\n    close() {\n      a = Ji(), c = {}, l = {}, s.readyState === WebSocket.OPEN && (s == null || s.close());\n    },\n    get status() {\n      var v;\n      return (v = s == null ? void 0 : s.readyState) != null ? v : 3;\n    }\n  };\n}\nvar we = {};\nie(we, {\n  BECH32_REGEX: () => va,\n  decode: () => Dr,\n  naddrEncode: () => Bf,\n  neventEncode: () => Pf,\n  noteEncode: () => Rf,\n  nprofileEncode: () => Tf,\n  npubEncode: () => If,\n  nrelayEncode: () => Lf,\n  nsecEncode: () => Cf\n});\nvar At = 5e3, va = /[\\x21-\\x7E]{1,83}1[023456789acdefghjklmnpqrstuvwxyz]{6,}/;\nfunction Dr(t) {\n  var i, s, o, a, c, l, f;\n  let { prefix: e, words: r } = te.decode(t, At), n = new Uint8Array(te.fromWords(r));\n  switch (e) {\n    case \"nprofile\": {\n      let u = wr(n);\n      if (!((i = u[0]) != null && i[0]))\n        throw new Error(\"missing TLV 0 for nprofile\");\n      if (u[0][0].length !== 32)\n        throw new Error(\"TLV 0 should be 32 bytes\");\n      return {\n        type: \"nprofile\",\n        data: {\n          pubkey: ve(u[0][0]),\n          relays: u[1] ? u[1].map((h) => Je.decode(h)) : []\n        }\n      };\n    }\n    case \"nevent\": {\n      let u = wr(n);\n      if (!((s = u[0]) != null && s[0]))\n        throw new Error(\"missing TLV 0 for nevent\");\n      if (u[0][0].length !== 32)\n        throw new Error(\"TLV 0 should be 32 bytes\");\n      if (u[2] && u[2][0].length !== 32)\n        throw new Error(\"TLV 2 should be 32 bytes\");\n      return {\n        type: \"nevent\",\n        data: {\n          id: ve(u[0][0]),\n          relays: u[1] ? u[1].map((h) => Je.decode(h)) : [],\n          author: (o = u[2]) != null && o[0] ? ve(u[2][0]) : void 0\n        }\n      };\n    }\n    case \"naddr\": {\n      let u = wr(n);\n      if (!((a = u[0]) != null && a[0]))\n        throw new Error(\"missing TLV 0 for naddr\");\n      if (!((c = u[2]) != null && c[0]))\n        throw new Error(\"missing TLV 2 for naddr\");\n      if (u[2][0].length !== 32)\n        throw new Error(\"TLV 2 should be 32 bytes\");\n      if (!((l = u[3]) != null && l[0]))\n        throw new Error(\"missing TLV 3 for naddr\");\n      if (u[3][0].length !== 4)\n        throw new Error(\"TLV 3 should be 4 bytes\");\n      return {\n        type: \"naddr\",\n        data: {\n          identifier: Je.decode(u[0][0]),\n          pubkey: ve(u[2][0]),\n          kind: parseInt(ve(u[3][0]), 16),\n          relays: u[1] ? u[1].map((h) => Je.decode(h)) : []\n        }\n      };\n    }\n    case \"nrelay\": {\n      let u = wr(n);\n      if (!((f = u[0]) != null && f[0]))\n        throw new Error(\"missing TLV 0 for nrelay\");\n      return {\n        type: \"nrelay\",\n        data: Je.decode(u[0][0])\n      };\n    }\n    case \"nsec\":\n    case \"npub\":\n    case \"note\":\n      return { type: e, data: ve(n) };\n    default:\n      throw new Error(`unknown prefix ${e}`);\n  }\n}\nfunction wr(t) {\n  let e = {}, r = t;\n  for (; r.length > 0; ) {\n    let n = r[0], i = r[1];\n    if (!i)\n      throw new Error(`malformed TLV ${n}`);\n    let s = r.slice(2, 2 + i);\n    if (r = r.slice(2 + i), s.length < i)\n      throw new Error(`not enough data to read on TLV ${n}`);\n    e[n] = e[n] || [], e[n].push(s);\n  }\n  return e;\n}\nfunction Cf(t) {\n  return di(\"nsec\", t);\n}\nfunction If(t) {\n  return di(\"npub\", t);\n}\nfunction Rf(t) {\n  return di(\"note\", t);\n}\nfunction di(t, e) {\n  let r = _t(e), n = te.toWords(r);\n  return te.encode(t, n, At);\n}\nfunction Tf(t) {\n  let e = zr({\n    0: [_t(t.pubkey)],\n    1: (t.relays || []).map((n) => Ie.encode(n))\n  }), r = te.toWords(e);\n  return te.encode(\"nprofile\", r, At);\n}\nfunction Pf(t) {\n  let e = zr({\n    0: [_t(t.id)],\n    1: (t.relays || []).map((n) => Ie.encode(n)),\n    2: t.author ? [_t(t.author)] : []\n  }), r = te.toWords(e);\n  return te.encode(\"nevent\", r, At);\n}\nfunction Bf(t) {\n  let e = new ArrayBuffer(4);\n  new DataView(e).setUint32(0, t.kind, !1);\n  let r = zr({\n    0: [Ie.encode(t.identifier)],\n    1: (t.relays || []).map((i) => Ie.encode(i)),\n    2: [_t(t.pubkey)],\n    3: [new Uint8Array(e)]\n  }), n = te.toWords(r);\n  return te.encode(\"naddr\", n, At);\n}\nfunction Lf(t) {\n  let e = zr({\n    0: [Ie.encode(t)]\n  }), r = te.toWords(e);\n  return te.encode(\"nrelay\", r, At);\n}\nfunction zr(t) {\n  let e = [];\n  return Object.entries(t).forEach(([r, n]) => {\n    n.forEach((i) => {\n      let s = new Uint8Array(i.length + 2);\n      s.set([parseInt(r)], 0), s.set([i.length], 1), s.set(i, 2), e.push(s);\n    });\n  }), _u(...e);\n}\nvar Un = {};\nie(Un, {\n  decrypt: () => qf,\n  encrypt: () => $f\n});\ntypeof crypto < \"u\" && !crypto.subtle && crypto.webcrypto && (crypto.subtle = crypto.webcrypto.subtle);\nasync function $f(t, e, r) {\n  const n = ue.getSharedSecret(t, \"02\" + e), i = wa(n);\n  let s = Uint8Array.from(xu(16)), o = Ie.encode(r), a = await crypto.subtle.importKey(\n    \"raw\",\n    i,\n    { name: \"AES-CBC\" },\n    !1,\n    [\"encrypt\"]\n  ), c = await crypto.subtle.encrypt(\n    { name: \"AES-CBC\", iv: s },\n    a,\n    o\n  ), l = mt.encode(new Uint8Array(c)), f = mt.encode(new Uint8Array(s.buffer));\n  return `${l}?iv=${f}`;\n}\nasync function qf(t, e, r) {\n  let [n, i] = r.split(\"?iv=\"), s = ue.getSharedSecret(t, \"02\" + e), o = wa(s), a = await crypto.subtle.importKey(\n    \"raw\",\n    o,\n    { name: \"AES-CBC\" },\n    !1,\n    [\"decrypt\"]\n  ), c = mt.decode(n), l = mt.decode(i), f = await crypto.subtle.decrypt(\n    { name: \"AES-CBC\", iv: l },\n    a,\n    c\n  );\n  return Je.decode(f);\n}\nfunction wa(t) {\n  return t.slice(1, 33);\n}\nvar _a = {};\nie(_a, {\n  NIP05_REGEX: () => ma,\n  queryProfile: () => jf,\n  searchDomain: () => Uf,\n  useFetchImplementation: () => Nf\n});\nvar ma = /^(?:([\\w.+-]+)@)?([\\w.-]+)$/, Fr;\ntry {\n  Fr = fetch;\n} catch {\n}\nfunction Nf(t) {\n  Fr = t;\n}\nasync function Uf(t, e = \"\") {\n  try {\n    return (await (await Fr(`https://${t}/.well-known/nostr.json?name=${e}`)).json()).names;\n  } catch {\n    return {};\n  }\n}\nasync function jf(t) {\n  const e = t.match(ma);\n  if (!e)\n    return null;\n  const [r, n = \"_\", i] = e;\n  try {\n    const s = await Fr(`https://${i}/.well-known/nostr.json?name=${n}`), { names: o, relays: a } = Hf(await s.json()), c = o[n];\n    return c ? { pubkey: c, relays: a == null ? void 0 : a[c] } : null;\n  } catch {\n    return null;\n  }\n}\nfunction Hf(t) {\n  const e = {\n    names: {}\n  };\n  for (const [r, n] of Object.entries(t.names))\n    typeof r == \"string\" && typeof n == \"string\" && (e.names[r] = n);\n  if (t.relays) {\n    e.relays = {};\n    for (const [r, n] of Object.entries(t.relays))\n      typeof r == \"string\" && Array.isArray(n) && (e.relays[r] = n.filter((i) => typeof i == \"string\"));\n  }\n  return e;\n}\nvar Mf = {};\nie(Mf, {\n  generateSeedWords: () => zf,\n  privateKeyFromSeedWords: () => Df,\n  validateWords: () => Ff\n});\nfunction Df(t, e) {\n  let n = ct.fromMasterSeed(Ys(t, e)).derive(\"m/44'/1237'/0'/0/0\").privateKey;\n  if (!n)\n    throw new Error(\"could not derive private key\");\n  return ve(n);\n}\nfunction zf() {\n  return ra(Qn);\n}\nfunction Ff(t) {\n  return sa(t, Qn);\n}\nvar Kf = {};\nie(Kf, {\n  parse: () => Wf\n});\nfunction Wf(t) {\n  const e = {\n    reply: void 0,\n    root: void 0,\n    mentions: [],\n    profiles: []\n  }, r = [];\n  for (const n of t.tags)\n    n[0] === \"e\" && n[1] && r.push(n), n[0] === \"p\" && n[1] && e.profiles.push({\n      pubkey: n[1],\n      relays: n[2] ? [n[2]] : []\n    });\n  for (let n = 0; n < r.length; n++) {\n    const i = r[n], [s, o, a, c] = i, l = {\n      id: o,\n      relays: a ? [a] : []\n    }, f = n === 0, u = n === r.length - 1;\n    if (c === \"root\") {\n      e.root = l;\n      continue;\n    }\n    if (c === \"reply\") {\n      e.reply = l;\n      continue;\n    }\n    if (c === \"mention\") {\n      e.mentions.push(l);\n      continue;\n    }\n    if (f) {\n      e.root = l;\n      continue;\n    }\n    if (u) {\n      e.reply = l;\n      continue;\n    }\n    e.mentions.push(l);\n  }\n  return e;\n}\nvar Vf = {};\nie(Vf, {\n  getPow: () => Gf\n});\nfunction Gf(t) {\n  return Zf(_t(t));\n}\nfunction Zf(t) {\n  let e, r, n;\n  for (r = 0, e = 0; r < t.length && (n = Yf(t[r]), e += n, n === 8); r++)\n    ;\n  return e;\n}\nfunction Yf(t) {\n  let e = 0;\n  if (t === 0)\n    return 8;\n  for (; t >>= 1; )\n    e++;\n  return 7 - e;\n}\nvar Jf = {};\nie(Jf, {\n  finishRepostEvent: () => Xf,\n  getRepostedEvent: () => Qf,\n  getRepostedEventPointer: () => xa\n});\nfunction Xf(t, e, r, n) {\n  var i;\n  return da({\n    kind: 6,\n    tags: [\n      ...(i = t.tags) != null ? i : [],\n      [\"e\", e.id, r],\n      [\"p\", e.pubkey]\n    ],\n    content: t.content === \"\" ? \"\" : JSON.stringify(e),\n    created_at: t.created_at\n  }, n);\n}\nfunction xa(t) {\n  if (t.kind !== 6)\n    return;\n  let e, r;\n  for (let n = t.tags.length - 1; n >= 0 && (e === void 0 || r === void 0); n--) {\n    const i = t.tags[n];\n    i.length >= 2 && (i[0] === \"e\" && e === void 0 ? e = i : i[0] === \"p\" && r === void 0 && (r = i));\n  }\n  if (e !== void 0)\n    return {\n      id: e[1],\n      relays: [e[2], r == null ? void 0 : r[2]].filter((n) => typeof n == \"string\"),\n      author: r == null ? void 0 : r[1]\n    };\n}\nfunction Qf(t, { skipVerification: e } = {}) {\n  const r = xa(t);\n  if (r === void 0 || t.content === \"\")\n    return;\n  let n;\n  try {\n    n = JSON.parse(t.content);\n  } catch {\n    return;\n  }\n  if (n.id === r.id && !(!e && !hi(n)))\n    return n;\n}\nvar eh = {};\nie(eh, {\n  NOSTR_URI_REGEX: () => Kr,\n  parse: () => rh,\n  test: () => th\n});\nvar Kr = new RegExp(`nostr:(${va.source})`);\nfunction th(t) {\n  return typeof t == \"string\" && new RegExp(`^${Kr.source}$`).test(t);\n}\nfunction rh(t) {\n  const e = t.match(new RegExp(`^${Kr.source}$`));\n  if (!e)\n    throw new Error(`Invalid Nostr URI: ${t}`);\n  return {\n    uri: e[0],\n    value: e[1],\n    decoded: Dr(e[1])\n  };\n}\nvar nh = {};\nie(nh, {\n  finishReactionEvent: () => ih,\n  getReactedEventPointer: () => oh\n});\nfunction ih(t, e, r) {\n  var i, s;\n  const n = e.tags.filter(\n    (o) => o.length >= 2 && (o[0] === \"e\" || o[0] === \"p\")\n  );\n  return da({\n    ...t,\n    kind: 7,\n    tags: [\n      ...(i = t.tags) != null ? i : [],\n      ...n,\n      [\"e\", e.id],\n      [\"p\", e.pubkey]\n    ],\n    content: (s = t.content) != null ? s : \"+\"\n  }, r);\n}\nfunction oh(t) {\n  if (t.kind !== 7)\n    return;\n  let e, r;\n  for (let n = t.tags.length - 1; n >= 0 && (e === void 0 || r === void 0); n--) {\n    const i = t.tags[n];\n    i.length >= 2 && (i[0] === \"e\" && e === void 0 ? e = i : i[0] === \"p\" && r === void 0 && (r = i));\n  }\n  if (!(e === void 0 || r === void 0))\n    return {\n      id: e[1],\n      relays: [e[2], r[2]].filter((n) => n !== void 0),\n      author: r[1]\n    };\n}\nvar sh = {};\nie(sh, {\n  createDelegation: () => ah,\n  getDelegator: () => ch\n});\nfunction ah(t, e) {\n  let r = [];\n  (e.kind || -1) >= 0 && r.push(`kind=${e.kind}`), e.until && r.push(`created_at<${e.until}`), e.since && r.push(`created_at>${e.since}`);\n  let n = r.join(\"&\");\n  if (n === \"\")\n    throw new Error(\"refusing to create a delegation without any conditions\");\n  let i = Yn(\n    Ie.encode(`nostr:delegation:${e.pubkey}:${n}`)\n  ), s = ve(\n    St.sign(i, t)\n  );\n  return {\n    from: li(t),\n    to: e.pubkey,\n    cond: n,\n    sig: s\n  };\n}\nfunction ch(t) {\n  let e = t.tags.find((a) => a[0] === \"delegation\" && a.length >= 4);\n  if (!e)\n    return null;\n  let r = e[1], n = e[2], i = e[3], s = n.split(\"&\");\n  for (let a = 0; a < s.length; a++) {\n    let [c, l, f] = s[a].split(/\\b/);\n    if (!(c === \"kind\" && l === \"=\" && t.kind === parseInt(f))) {\n      if (c === \"created_at\" && l === \"<\" && t.created_at < parseInt(f))\n        continue;\n      if (c === \"created_at\" && l === \">\" && t.created_at > parseInt(f))\n        continue;\n      return null;\n    }\n  }\n  let o = Yn(\n    Ie.encode(`nostr:delegation:${t.pubkey}:${n}`)\n  );\n  return St.verify(i, o, r) ? r : null;\n}\nvar uh = {};\nie(uh, {\n  matchAll: () => lh,\n  regex: () => pi,\n  replaceAll: () => fh\n});\nvar pi = () => new RegExp(`\\\\b${Kr.source}\\\\b`, \"g\");\nfunction* lh(t) {\n  const e = t.matchAll(pi());\n  for (const r of e) {\n    const [n, i] = r;\n    yield {\n      uri: n,\n      value: i,\n      decoded: Dr(i),\n      start: r.index,\n      end: r.index + n.length\n    };\n  }\n}\nfunction fh(t, e) {\n  return t.replaceAll(pi(), (r, n) => e({\n    uri: r,\n    value: n,\n    decoded: Dr(n)\n  }));\n}\nvar hh = {};\nie(hh, {\n  useFetchImplementation: () => dh,\n  validateGithub: () => ph\n});\nvar yi;\ntry {\n  yi = fetch;\n} catch {\n}\nfunction dh(t) {\n  yi = t;\n}\nasync function ph(t, e, r) {\n  try {\n    return await (await yi(`https://gist.github.com/${e}/${r}/raw`)).text() === `Verifying that I control the following Nostr public key: ${t}`;\n  } catch {\n    return !1;\n  }\n}\nvar yh = {};\nie(yh, {\n  authenticate: () => gh\n});\nvar gh = async ({\n  challenge: t,\n  relay: e,\n  sign: r\n}) => {\n  const n = {\n    kind: 22242,\n    created_at: Math.floor(Date.now() / 1e3),\n    tags: [\n      [\"relay\", e.url],\n      [\"challenge\", t]\n    ],\n    content: \"\"\n  }, i = e.auth(await r(n));\n  return new Promise((s, o) => {\n    i.on(\"ok\", function a() {\n      i.off(\"ok\", a), s();\n    }), i.on(\"failed\", function a(c) {\n      i.off(\"failed\", a), o(c);\n    });\n  });\n}, Ea = {};\nie(Ea, {\n  getZapEndpoint: () => vh,\n  makeZapReceipt: () => mh,\n  makeZapRequest: () => wh,\n  useFetchImplementation: () => bh,\n  validateZapRequest: () => _h\n});\nvar gi;\ntry {\n  gi = fetch;\n} catch {\n}\nfunction bh(t) {\n  gi = t;\n}\nasync function vh(t) {\n  try {\n    let e = \"\", { lud06: r, lud16: n } = JSON.parse(t.content);\n    if (r) {\n      let { words: o } = te.decode(r, 1e3), a = te.fromWords(o);\n      e = Je.decode(a);\n    } else if (n) {\n      let [o, a] = n.split(\"@\");\n      e = `https://${a}/.well-known/lnurlp/${o}`;\n    } else\n      return null;\n    let s = await (await gi(e)).json();\n    if (s.allowsNostr && s.nostrPubkey)\n      return s.callback;\n  } catch {\n  }\n  return null;\n}\nfunction wh({\n  profile: t,\n  event: e,\n  amount: r,\n  relays: n,\n  comment: i = \"\"\n}) {\n  if (!r)\n    throw new Error(\"amount not given\");\n  if (!t)\n    throw new Error(\"profile not given\");\n  let s = {\n    kind: 9734,\n    created_at: Math.round(Date.now() / 1e3),\n    content: i,\n    tags: [\n      [\"p\", t],\n      [\"amount\", r.toString()],\n      [\"relays\", ...n]\n    ]\n  };\n  return e && s.tags.push([\"e\", e]), s;\n}\nfunction _h(t) {\n  let e;\n  try {\n    e = JSON.parse(t);\n  } catch {\n    return \"Invalid zap request JSON.\";\n  }\n  if (!fi(e))\n    return \"Zap request is not a valid Nostr event.\";\n  if (!hi(e))\n    return \"Invalid signature on zap request.\";\n  let r = e.tags.find(([s, o]) => s === \"p\" && o);\n  if (!r)\n    return \"Zap request doesn't have a 'p' tag.\";\n  if (!r[1].match(/^[a-f0-9]{64}$/))\n    return \"Zap request 'p' tag is not valid hex.\";\n  let n = e.tags.find(([s, o]) => s === \"e\" && o);\n  return n && !n[1].match(/^[a-f0-9]{64}$/) ? \"Zap request 'e' tag is not valid hex.\" : e.tags.find(([s, o]) => s === \"relays\" && o) ? null : \"Zap request doesn't have a 'relays' tag.\";\n}\nfunction mh({\n  zapRequest: t,\n  preimage: e,\n  bolt11: r,\n  paidAt: n\n}) {\n  let s = JSON.parse(t).tags.filter(\n    ([a]) => a === \"e\" || a === \"p\" || a === \"a\"\n  ), o = {\n    kind: 9735,\n    created_at: Math.round(n.getTime() / 1e3),\n    content: \"\",\n    tags: [\n      ...s,\n      [\"bolt11\", r],\n      [\"description\", t]\n    ]\n  };\n  return e && o.tags.push([\"preimage\", e]), o;\n}\nvar cr = {};\nObject.defineProperty(cr, \"__esModule\", { value: !0 });\ncr.is_node = void 0;\nvar dn = null;\nfunction xh() {\n  return dn === null && (dn = typeof S == \"object\" && typeof S.process == \"object\" && typeof S.process.versions == \"object\" && typeof S.process.versions.node < \"u\"), dn;\n}\ncr.is_node = xh;\nvar pn = {}, yn, Xi;\nfunction Eh() {\n  if (Xi)\n    return yn;\n  Xi = 1;\n  var t = function() {\n    if (typeof self == \"object\" && self)\n      return self;\n    if (typeof window == \"object\" && window)\n      return window;\n    throw new Error(\"Unable to resolve global `this`\");\n  };\n  return yn = function() {\n    if (this)\n      return this;\n    if (typeof globalThis == \"object\" && globalThis)\n      return globalThis;\n    try {\n      Object.defineProperty(Object.prototype, \"__global__\", {\n        get: function() {\n          return this;\n        },\n        configurable: !0\n      });\n    } catch {\n      return t();\n    }\n    try {\n      return __global__ || t();\n    } finally {\n      delete Object.prototype.__global__;\n    }\n  }(), yn;\n}\nconst kh = \"websocket\", Sh = \"Websocket Client & Server Library implementing the WebSocket protocol as specified in RFC 6455.\", Oh = [\n  \"websocket\",\n  \"websockets\",\n  \"socket\",\n  \"networking\",\n  \"comet\",\n  \"push\",\n  \"RFC-6455\",\n  \"realtime\",\n  \"server\",\n  \"client\"\n], Ah = \"Brian McKelvey <theturtle32@gmail.com> (https://github.com/theturtle32)\", Ch = [\n  \"I\\xF1aki Baz Castillo <ibc@aliax.net> (http://dev.sipdoc.net)\"\n], Ih = \"1.0.34\", Rh = {\n  type: \"git\",\n  url: \"https://github.com/theturtle32/WebSocket-Node.git\"\n}, Th = \"https://github.com/theturtle32/WebSocket-Node\", Ph = {\n  node: \">=4.0.0\"\n}, Bh = {\n  bufferutil: \"^4.0.1\",\n  debug: \"^2.2.0\",\n  \"es5-ext\": \"^0.10.50\",\n  \"typedarray-to-buffer\": \"^3.1.5\",\n  \"utf-8-validate\": \"^5.0.2\",\n  yaeti: \"^0.0.6\"\n}, Lh = {\n  \"buffer-equal\": \"^1.0.0\",\n  gulp: \"^4.0.2\",\n  \"gulp-jshint\": \"^2.0.4\",\n  \"jshint-stylish\": \"^2.2.1\",\n  jshint: \"^2.0.0\",\n  tape: \"^4.9.1\"\n}, $h = {\n  verbose: !1\n}, qh = {\n  test: \"tape test/unit/*.js\",\n  gulp: \"gulp\"\n}, Nh = \"index\", Uh = {\n  lib: \"./lib\"\n}, jh = \"lib/browser.js\", Hh = \"Apache-2.0\", Mh = {\n  name: kh,\n  description: Sh,\n  keywords: Oh,\n  author: Ah,\n  contributors: Ch,\n  version: Ih,\n  repository: Rh,\n  homepage: Th,\n  engines: Ph,\n  dependencies: Bh,\n  devDependencies: Lh,\n  config: $h,\n  scripts: qh,\n  main: Nh,\n  directories: Uh,\n  browser: jh,\n  license: Hh\n};\nvar gn, Qi;\nfunction Dh() {\n  return Qi || (Qi = 1, gn = Mh.version), gn;\n}\nvar bn, eo;\nfunction zh() {\n  if (eo)\n    return bn;\n  eo = 1;\n  var t;\n  if (typeof globalThis == \"object\")\n    t = globalThis;\n  else\n    try {\n      t = Eh();\n    } catch {\n    } finally {\n      if (!t && typeof window < \"u\" && (t = window), !t)\n        throw new Error(\"Could not determine global this\");\n    }\n  var e = t.WebSocket || t.MozWebSocket, r = Dh();\n  function n(i, s) {\n    var o;\n    return s ? o = new e(i, s) : o = new e(i), o;\n  }\n  return e && [\"CONNECTING\", \"OPEN\", \"CLOSING\", \"CLOSED\"].forEach(function(i) {\n    Object.defineProperty(n, i, {\n      get: function() {\n        return e[i];\n      }\n    });\n  }), bn = {\n    w3cwebsocket: e ? n : null,\n    version: r\n  }, bn;\n}\nvar _r = {}, vn = {}, Rt = {}, Tt = {}, Pt = {}, Bt = {}, to;\nfunction Fh() {\n  if (to)\n    return Bt;\n  to = 1, Object.defineProperty(Bt, \"__esModule\", { value: !0 }), Bt.ForOfAdaptor = void 0;\n  var t = function() {\n    function e(r, n) {\n      this.it_ = r, this.last_ = n;\n    }\n    return e.prototype.next = function() {\n      if (this.it_.equals(this.last_))\n        return {\n          done: !0,\n          value: void 0\n        };\n      var r = this.it_;\n      return this.it_ = this.it_.next(), {\n        done: !1,\n        value: r.value\n      };\n    }, e.prototype[Symbol.iterator] = function() {\n      return this;\n    }, e;\n  }();\n  return Bt.ForOfAdaptor = t, Bt;\n}\nvar ro;\nfunction bi() {\n  if (ro)\n    return Pt;\n  ro = 1;\n  var t = S && S.__values || function(n) {\n    var i = typeof Symbol == \"function\" && Symbol.iterator, s = i && n[i], o = 0;\n    if (s)\n      return s.call(n);\n    if (n && typeof n.length == \"number\")\n      return {\n        next: function() {\n          return n && o >= n.length && (n = void 0), { value: n && n[o++], done: !n };\n        }\n      };\n    throw new TypeError(i ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n  };\n  Object.defineProperty(Pt, \"__esModule\", { value: !0 }), Pt.Container = void 0;\n  var e = Fh(), r = function() {\n    function n() {\n    }\n    return n.prototype.empty = function() {\n      return this.size() === 0;\n    }, n.prototype.rbegin = function() {\n      return this.end().reverse();\n    }, n.prototype.rend = function() {\n      return this.begin().reverse();\n    }, n.prototype[Symbol.iterator] = function() {\n      return new e.ForOfAdaptor(this.begin(), this.end());\n    }, n.prototype.toJSON = function() {\n      var i, s, o = [];\n      try {\n        for (var a = t(this), c = a.next(); !c.done; c = a.next()) {\n          var l = c.value;\n          o.push(l);\n        }\n      } catch (f) {\n        i = { error: f };\n      } finally {\n        try {\n          c && !c.done && (s = a.return) && s.call(a);\n        } finally {\n          if (i)\n            throw i.error;\n        }\n      }\n      return o;\n    }, n;\n  }();\n  return Pt.Container = r, Pt;\n}\nvar Lt = {}, no;\nfunction vi() {\n  if (no)\n    return Lt;\n  no = 1;\n  var t = S && S.__read || function(r, n) {\n    var i = typeof Symbol == \"function\" && r[Symbol.iterator];\n    if (!i)\n      return r;\n    var s = i.call(r), o, a = [], c;\n    try {\n      for (; (n === void 0 || n-- > 0) && !(o = s.next()).done; )\n        a.push(o.value);\n    } catch (l) {\n      c = { error: l };\n    } finally {\n      try {\n        o && !o.done && (i = s.return) && i.call(s);\n      } finally {\n        if (c)\n          throw c.error;\n      }\n    }\n    return a;\n  };\n  Object.defineProperty(Lt, \"__esModule\", { value: !0 }), Lt.NativeArrayIterator = void 0;\n  var e = function() {\n    function r(n, i) {\n      this.data_ = n, this.index_ = i;\n    }\n    return r.prototype.index = function() {\n      return this.index_;\n    }, Object.defineProperty(r.prototype, \"value\", {\n      get: function() {\n        return this.data_[this.index_];\n      },\n      enumerable: !1,\n      configurable: !0\n    }), r.prototype.prev = function() {\n      return --this.index_, this;\n    }, r.prototype.next = function() {\n      return ++this.index_, this;\n    }, r.prototype.advance = function(n) {\n      return this.index_ += n, this;\n    }, r.prototype.equals = function(n) {\n      return this.data_ === n.data_ && this.index_ === n.index_;\n    }, r.prototype.swap = function(n) {\n      var i, s;\n      i = t([n.data_, this.data_], 2), this.data_ = i[0], n.data_ = i[1], s = t([n.index_, this.index_], 2), this.index_ = s[0], n.index_ = s[1];\n    }, r;\n  }();\n  return Lt.NativeArrayIterator = e, Lt;\n}\nvar io;\nfunction Kh() {\n  if (io)\n    return Tt;\n  io = 1;\n  var t = S && S.__extends || function() {\n    var i = function(s, o) {\n      return i = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(a, c) {\n        a.__proto__ = c;\n      } || function(a, c) {\n        for (var l in c)\n          Object.prototype.hasOwnProperty.call(c, l) && (a[l] = c[l]);\n      }, i(s, o);\n    };\n    return function(s, o) {\n      if (typeof o != \"function\" && o !== null)\n        throw new TypeError(\"Class extends value \" + String(o) + \" is not a constructor or null\");\n      i(s, o);\n      function a() {\n        this.constructor = s;\n      }\n      s.prototype = o === null ? Object.create(o) : (a.prototype = o.prototype, new a());\n    };\n  }();\n  Object.defineProperty(Tt, \"__esModule\", { value: !0 }), Tt.SetContainer = void 0;\n  var e = bi(), r = vi(), n = function(i) {\n    t(s, i);\n    function s(o) {\n      var a = i.call(this) || this;\n      return a.data_ = o(a), a;\n    }\n    return s.prototype.assign = function(o, a) {\n      this.clear(), this.insert(o, a);\n    }, s.prototype.clear = function() {\n      this.data_.clear();\n    }, s.prototype.begin = function() {\n      return this.data_.begin();\n    }, s.prototype.end = function() {\n      return this.data_.end();\n    }, s.prototype.has = function(o) {\n      return !this.find(o).equals(this.end());\n    }, s.prototype.size = function() {\n      return this.data_.size();\n    }, s.prototype.push = function() {\n      for (var o = [], a = 0; a < arguments.length; a++)\n        o[a] = arguments[a];\n      if (o.length === 0)\n        return this.size();\n      var c = new r.NativeArrayIterator(o, 0), l = new r.NativeArrayIterator(o, o.length);\n      return this._Insert_by_range(c, l), this.size();\n    }, s.prototype.insert = function() {\n      for (var o = [], a = 0; a < arguments.length; a++)\n        o[a] = arguments[a];\n      return o.length === 1 ? this._Insert_by_key(o[0]) : o[0].next instanceof Function && o[1].next instanceof Function ? this._Insert_by_range(o[0], o[1]) : this._Insert_by_hint(o[0], o[1]);\n    }, s.prototype.erase = function() {\n      for (var o = [], a = 0; a < arguments.length; a++)\n        o[a] = arguments[a];\n      return o.length === 1 && !(o[0] instanceof this.end().constructor && o[0].source() === this) ? this._Erase_by_val(o[0]) : o.length === 1 ? this._Erase_by_range(o[0]) : this._Erase_by_range(o[0], o[1]);\n    }, s.prototype._Erase_by_range = function(o, a) {\n      a === void 0 && (a = o.next());\n      var c = this.data_.erase(o, a);\n      return this._Handle_erase(o, a), c;\n    }, s;\n  }(e.Container);\n  return Tt.SetContainer = n, Tt;\n}\nvar wn = {}, $t = {}, qt = {}, Nt = {}, oo;\nfunction Wh() {\n  if (oo)\n    return Nt;\n  oo = 1;\n  var t = S && S.__extends || function() {\n    var r = function(n, i) {\n      return r = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(s, o) {\n        s.__proto__ = o;\n      } || function(s, o) {\n        for (var a in o)\n          Object.prototype.hasOwnProperty.call(o, a) && (s[a] = o[a]);\n      }, r(n, i);\n    };\n    return function(n, i) {\n      if (typeof i != \"function\" && i !== null)\n        throw new TypeError(\"Class extends value \" + String(i) + \" is not a constructor or null\");\n      r(n, i);\n      function s() {\n        this.constructor = n;\n      }\n      n.prototype = i === null ? Object.create(i) : (s.prototype = i.prototype, new s());\n    };\n  }();\n  Object.defineProperty(Nt, \"__esModule\", { value: !0 }), Nt.Exception = void 0;\n  var e = function(r) {\n    t(n, r);\n    function n(i) {\n      var s = this.constructor, o = r.call(this, i) || this, a = s.prototype;\n      return Object.setPrototypeOf ? Object.setPrototypeOf(o, a) : o.__proto__ = a, o;\n    }\n    return Object.defineProperty(n.prototype, \"name\", {\n      get: function() {\n        return this.constructor.name;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), n.prototype.what = function() {\n      return this.message;\n    }, n.prototype.toJSON = function() {\n      return {\n        name: this.name,\n        message: this.message,\n        stack: this.stack\n      };\n    }, n;\n  }(Error);\n  return Nt.Exception = e, Nt;\n}\nvar so;\nfunction ka() {\n  if (so)\n    return qt;\n  so = 1;\n  var t = S && S.__extends || function() {\n    var n = function(i, s) {\n      return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(o, a) {\n        o.__proto__ = a;\n      } || function(o, a) {\n        for (var c in a)\n          Object.prototype.hasOwnProperty.call(a, c) && (o[c] = a[c]);\n      }, n(i, s);\n    };\n    return function(i, s) {\n      if (typeof s != \"function\" && s !== null)\n        throw new TypeError(\"Class extends value \" + String(s) + \" is not a constructor or null\");\n      n(i, s);\n      function o() {\n        this.constructor = i;\n      }\n      i.prototype = s === null ? Object.create(s) : (o.prototype = s.prototype, new o());\n    };\n  }();\n  Object.defineProperty(qt, \"__esModule\", { value: !0 }), qt.LogicError = void 0;\n  var e = Wh(), r = function(n) {\n    t(i, n);\n    function i(s) {\n      return n.call(this, s) || this;\n    }\n    return i;\n  }(e.Exception);\n  return qt.LogicError = r, qt;\n}\nvar ao;\nfunction Sa() {\n  if (ao)\n    return $t;\n  ao = 1;\n  var t = S && S.__extends || function() {\n    var n = function(i, s) {\n      return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(o, a) {\n        o.__proto__ = a;\n      } || function(o, a) {\n        for (var c in a)\n          Object.prototype.hasOwnProperty.call(a, c) && (o[c] = a[c]);\n      }, n(i, s);\n    };\n    return function(i, s) {\n      if (typeof s != \"function\" && s !== null)\n        throw new TypeError(\"Class extends value \" + String(s) + \" is not a constructor or null\");\n      n(i, s);\n      function o() {\n        this.constructor = i;\n      }\n      i.prototype = s === null ? Object.create(s) : (o.prototype = s.prototype, new o());\n    };\n  }();\n  Object.defineProperty($t, \"__esModule\", { value: !0 }), $t.InvalidArgument = void 0;\n  var e = ka(), r = function(n) {\n    t(i, n);\n    function i(s) {\n      return n.call(this, s) || this;\n    }\n    return i;\n  }(e.LogicError);\n  return $t.InvalidArgument = r, $t;\n}\nvar Ut = {}, co;\nfunction Vh() {\n  if (co)\n    return Ut;\n  co = 1;\n  var t = S && S.__extends || function() {\n    var n = function(i, s) {\n      return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(o, a) {\n        o.__proto__ = a;\n      } || function(o, a) {\n        for (var c in a)\n          Object.prototype.hasOwnProperty.call(a, c) && (o[c] = a[c]);\n      }, n(i, s);\n    };\n    return function(i, s) {\n      if (typeof s != \"function\" && s !== null)\n        throw new TypeError(\"Class extends value \" + String(s) + \" is not a constructor or null\");\n      n(i, s);\n      function o() {\n        this.constructor = i;\n      }\n      i.prototype = s === null ? Object.create(s) : (o.prototype = s.prototype, new o());\n    };\n  }();\n  Object.defineProperty(Ut, \"__esModule\", { value: !0 }), Ut.OutOfRange = void 0;\n  var e = ka(), r = function(n) {\n    t(i, n);\n    function i(s) {\n      return n.call(this, s) || this;\n    }\n    return i;\n  }(e.LogicError);\n  return Ut.OutOfRange = r, Ut;\n}\nvar uo;\nfunction Wr() {\n  return uo || (uo = 1, function(t) {\n    Object.defineProperty(t, \"__esModule\", { value: !0 }), t.ErrorGenerator = void 0;\n    var e = Sa(), r = Vh();\n    (function(n) {\n      function i(d) {\n        if (typeof d == \"string\")\n          return d;\n        var p = d.constructor.name;\n        return d.constructor.__MODULE && (p = \"\".concat(d.constructor.__MODULE, \".\").concat(p)), \"std.\".concat(p);\n      }\n      n.get_class_name = i;\n      function s(d, p) {\n        return new r.OutOfRange(\"Error on \".concat(i(d), \".\").concat(p, \"(): it's empty container.\"));\n      }\n      n.empty = s;\n      function o(d, p, y) {\n        return new r.OutOfRange(\"Error on \".concat(i(d), \".\").concat(p, \"(): parametric index is negative -> (index = \").concat(y, \").\"));\n      }\n      n.negative_index = o;\n      function a(d, p, y, g) {\n        return new r.OutOfRange(\"Error on \".concat(i(d), \".\").concat(p, \"(): parametric index is equal or greater than size -> (index = \").concat(y, \", size: \").concat(g, \").\"));\n      }\n      n.excessive_index = a;\n      function c(d, p) {\n        return new e.InvalidArgument(\"Error on \".concat(i(d), \".\").concat(p, \"(): parametric iterator is not this container's own.\"));\n      }\n      n.not_my_iterator = c;\n      function l(d, p) {\n        return new e.InvalidArgument(\"Error on \".concat(i(d), \".\").concat(p, \"(): parametric iterator, it already has been erased.\"));\n      }\n      n.erased_iterator = l;\n      function f(d, p, y) {\n        return new r.OutOfRange(\"Error on \".concat(i(d), \".\").concat(p, \"(): parametric iterator is directing negative position -> (index = \").concat(y, \").\"));\n      }\n      n.negative_iterator = f;\n      function u(d, p) {\n        p === void 0 && (p = \"end\");\n        var y = i(d);\n        return new r.OutOfRange(\"Error on \".concat(y, \".Iterator.value: cannot access to the \").concat(y, \".\").concat(p, \"().value.\"));\n      }\n      n.iterator_end_value = u;\n      function h(d, p, y) {\n        throw new r.OutOfRange(\"Error on \".concat(i(d), \".\").concat(p, \"(): unable to find the matched key -> \").concat(y));\n      }\n      n.key_nout_found = h;\n    })(t.ErrorGenerator || (t.ErrorGenerator = {}));\n  }(wn)), wn;\n}\nvar lo;\nfunction Gh() {\n  if (lo)\n    return Rt;\n  lo = 1;\n  var t = S && S.__extends || function() {\n    var o = function(a, c) {\n      return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(l, f) {\n        l.__proto__ = f;\n      } || function(l, f) {\n        for (var u in f)\n          Object.prototype.hasOwnProperty.call(f, u) && (l[u] = f[u]);\n      }, o(a, c);\n    };\n    return function(a, c) {\n      if (typeof c != \"function\" && c !== null)\n        throw new TypeError(\"Class extends value \" + String(c) + \" is not a constructor or null\");\n      o(a, c);\n      function l() {\n        this.constructor = a;\n      }\n      a.prototype = c === null ? Object.create(c) : (l.prototype = c.prototype, new l());\n    };\n  }(), e = S && S.__read || function(o, a) {\n    var c = typeof Symbol == \"function\" && o[Symbol.iterator];\n    if (!c)\n      return o;\n    var l = c.call(o), f, u = [], h;\n    try {\n      for (; (a === void 0 || a-- > 0) && !(f = l.next()).done; )\n        u.push(f.value);\n    } catch (d) {\n      h = { error: d };\n    } finally {\n      try {\n        f && !f.done && (c = l.return) && c.call(l);\n      } finally {\n        if (h)\n          throw h.error;\n      }\n    }\n    return u;\n  }, r = S && S.__spreadArray || function(o, a, c) {\n    if (c || arguments.length === 2)\n      for (var l = 0, f = a.length, u; l < f; l++)\n        (u || !(l in a)) && (u || (u = Array.prototype.slice.call(a, 0, l)), u[l] = a[l]);\n    return o.concat(u || Array.prototype.slice.call(a));\n  };\n  Object.defineProperty(Rt, \"__esModule\", { value: !0 }), Rt.UniqueSet = void 0;\n  var n = Kh(), i = Wr(), s = function(o) {\n    t(a, o);\n    function a() {\n      return o !== null && o.apply(this, arguments) || this;\n    }\n    return a.prototype.count = function(c) {\n      return this.find(c).equals(this.end()) ? 0 : 1;\n    }, a.prototype.insert = function() {\n      for (var c = [], l = 0; l < arguments.length; l++)\n        c[l] = arguments[l];\n      return o.prototype.insert.apply(this, r([], e(c), !1));\n    }, a.prototype._Insert_by_range = function(c, l) {\n      for (; !c.equals(l); c = c.next())\n        this._Insert_by_key(c.value);\n    }, a.prototype.extract = function(c) {\n      return c instanceof this.end().constructor ? this._Extract_by_iterator(c) : this._Extract_by_val(c);\n    }, a.prototype._Extract_by_val = function(c) {\n      var l = this.find(c);\n      if (l.equals(this.end()) === !0)\n        throw i.ErrorGenerator.key_nout_found(this, \"extract\", c);\n      return this._Erase_by_range(l), c;\n    }, a.prototype._Extract_by_iterator = function(c) {\n      return c.equals(this.end()) === !0 || this.has(c.value) === !1 ? this.end() : (this._Erase_by_range(c), c);\n    }, a.prototype._Erase_by_val = function(c) {\n      var l = this.find(c);\n      return l.equals(this.end()) === !0 ? 0 : (this._Erase_by_range(l), 1);\n    }, a.prototype.merge = function(c) {\n      for (var l = c.begin(); !l.equals(c.end()); )\n        this.has(l.value) === !1 ? (this.insert(l.value), l = c.erase(l)) : l = l.next();\n    }, a;\n  }(n.SetContainer);\n  return Rt.UniqueSet = s, Rt;\n}\nvar _n = {}, mn = {}, fo;\nfunction Zh() {\n  return fo || (fo = 1, function(t) {\n    var e = S && S.__read || function(n, i) {\n      var s = typeof Symbol == \"function\" && n[Symbol.iterator];\n      if (!s)\n        return n;\n      var o = s.call(n), a, c = [], l;\n      try {\n        for (; (i === void 0 || i-- > 0) && !(a = o.next()).done; )\n          c.push(a.value);\n      } catch (f) {\n        l = { error: f };\n      } finally {\n        try {\n          a && !a.done && (s = o.return) && s.call(o);\n        } finally {\n          if (l)\n            throw l.error;\n        }\n      }\n      return c;\n    }, r = S && S.__spreadArray || function(n, i, s) {\n      if (s || arguments.length === 2)\n        for (var o = 0, a = i.length, c; o < a; o++)\n          (c || !(o in i)) && (c || (c = Array.prototype.slice.call(i, 0, o)), c[o] = i[o]);\n      return n.concat(c || Array.prototype.slice.call(i));\n    };\n    Object.defineProperty(t, \"__esModule\", { value: !0 }), t.IAssociativeContainer = void 0, function(n) {\n      function i(s) {\n        for (var o = [], a = 1; a < arguments.length; a++)\n          o[a - 1] = arguments[a];\n        var c, l;\n        return o.length >= 1 && o[0] instanceof Array ? (c = function() {\n          var f = o[0];\n          s.push.apply(s, r([], e(f), !1));\n        }, l = o.slice(1)) : o.length >= 2 && o[0].next instanceof Function && o[1].next instanceof Function ? (c = function() {\n          var f = o[0], u = o[1];\n          s.assign(f, u);\n        }, l = o.slice(2)) : (c = null, l = o), { ramda: c, tail: l };\n      }\n      n.construct = i;\n    }(t.IAssociativeContainer || (t.IAssociativeContainer = {}));\n  }(mn)), mn;\n}\nvar jt = {}, Ht = {}, Mt = {}, ho;\nfunction Yh() {\n  if (ho)\n    return Mt;\n  ho = 1, Object.defineProperty(Mt, \"__esModule\", { value: !0 }), Mt._Get_root = void 0;\n  var t = cr;\n  function e() {\n    return r === null && (r = (0, t.is_node)() ? S : self, r.__s_iUID === void 0 && (r.__s_iUID = 0)), r;\n  }\n  Mt._Get_root = e;\n  var r = null;\n  return Mt;\n}\nvar po;\nfunction Oa() {\n  if (po)\n    return Ht;\n  po = 1, Object.defineProperty(Ht, \"__esModule\", { value: !0 }), Ht.get_uid = void 0;\n  var t = Yh();\n  function e(r) {\n    if (r instanceof Object) {\n      if (r.hasOwnProperty(\"__get_m_iUID\") === !1) {\n        var n = ++(0, t._Get_root)().__s_iUID;\n        Object.defineProperty(r, \"__get_m_iUID\", {\n          value: function() {\n            return n;\n          }\n        });\n      }\n      return r.__get_m_iUID();\n    } else\n      return r === void 0 ? -1 : 0;\n  }\n  return Ht.get_uid = e, Ht;\n}\nvar yo;\nfunction wi() {\n  if (yo)\n    return jt;\n  yo = 1;\n  var t = S && S.__values || function(c) {\n    var l = typeof Symbol == \"function\" && Symbol.iterator, f = l && c[l], u = 0;\n    if (f)\n      return f.call(c);\n    if (c && typeof c.length == \"number\")\n      return {\n        next: function() {\n          return c && u >= c.length && (c = void 0), { value: c && c[u++], done: !c };\n        }\n      };\n    throw new TypeError(l ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n  };\n  Object.defineProperty(jt, \"__esModule\", { value: !0 }), jt.hash = void 0;\n  var e = Oa();\n  function r() {\n    for (var c, l, f = [], u = 0; u < arguments.length; u++)\n      f[u] = arguments[u];\n    var h = o;\n    try {\n      for (var d = t(f), p = d.next(); !p.done; p = d.next()) {\n        var y = p.value;\n        y = y && y.valueOf();\n        var g = typeof y;\n        if (g === \"boolean\")\n          h = n(y, h);\n        else if (g === \"number\" || g === \"bigint\")\n          h = i(y, h);\n        else if (g === \"string\")\n          h = s(y, h);\n        else if (y instanceof Object && y.hashCode instanceof Function) {\n          var v = y.hashCode();\n          if (f.length === 1)\n            return v;\n          h = h ^ v, h *= a;\n        } else\n          h = i((0, e.get_uid)(y), h);\n      }\n    } catch (_) {\n      c = { error: _ };\n    } finally {\n      try {\n        p && !p.done && (l = d.return) && l.call(d);\n      } finally {\n        if (c)\n          throw c.error;\n      }\n    }\n    return Math.abs(h);\n  }\n  jt.hash = r;\n  function n(c, l) {\n    return l ^= c ? 1 : 0, l *= a, l;\n  }\n  function i(c, l) {\n    return s(c.toString(), l);\n  }\n  function s(c, l) {\n    for (var f = 0; f < c.length; ++f)\n      l ^= c.charCodeAt(f), l *= a;\n    return Math.abs(l);\n  }\n  var o = 2166136261, a = 16777619;\n  return jt;\n}\nvar ae = {}, go;\nfunction _i() {\n  if (go)\n    return ae;\n  go = 1, Object.defineProperty(ae, \"__esModule\", { value: !0 }), ae.greater_equal = ae.greater = ae.less_equal = ae.less = ae.not_equal_to = ae.equal_to = void 0;\n  var t = Oa();\n  function e(a, c) {\n    return a = a && a.valueOf(), c = c && c.valueOf(), a instanceof Object && a.equals instanceof Function ? a.equals(c) : a === c;\n  }\n  ae.equal_to = e;\n  function r(a, c) {\n    return !e(a, c);\n  }\n  ae.not_equal_to = r;\n  function n(a, c) {\n    return a = a.valueOf(), c = c.valueOf(), a instanceof Object ? a.less instanceof Function ? a.less(c) : (0, t.get_uid)(a) < (0, t.get_uid)(c) : a < c;\n  }\n  ae.less = n;\n  function i(a, c) {\n    return n(a, c) || e(a, c);\n  }\n  ae.less_equal = i;\n  function s(a, c) {\n    return !i(a, c);\n  }\n  ae.greater = s;\n  function o(a, c) {\n    return !n(a, c);\n  }\n  return ae.greater_equal = o, ae;\n}\nvar bo;\nfunction Aa() {\n  return bo || (bo = 1, function(t) {\n    var e = S && S.__read || function(o, a) {\n      var c = typeof Symbol == \"function\" && o[Symbol.iterator];\n      if (!c)\n        return o;\n      var l = c.call(o), f, u = [], h;\n      try {\n        for (; (a === void 0 || a-- > 0) && !(f = l.next()).done; )\n          u.push(f.value);\n      } catch (d) {\n        h = { error: d };\n      } finally {\n        try {\n          f && !f.done && (c = l.return) && c.call(l);\n        } finally {\n          if (h)\n            throw h.error;\n        }\n      }\n      return u;\n    }, r = S && S.__spreadArray || function(o, a, c) {\n      if (c || arguments.length === 2)\n        for (var l = 0, f = a.length, u; l < f; l++)\n          (u || !(l in a)) && (u || (u = Array.prototype.slice.call(a, 0, l)), u[l] = a[l]);\n      return o.concat(u || Array.prototype.slice.call(a));\n    };\n    Object.defineProperty(t, \"__esModule\", { value: !0 }), t.IHashContainer = void 0;\n    var n = Zh(), i = wi(), s = _i();\n    (function(o) {\n      function a(c, l, f) {\n        for (var u = [], h = 3; h < arguments.length; h++)\n          u[h - 3] = arguments[h];\n        var d = null, p = i.hash, y = s.equal_to;\n        if (u.length === 1 && u[0] instanceof l) {\n          var g = u[0];\n          p = g.hash_function(), y = g.key_eq(), d = function() {\n            var _ = g.begin(), m = g.end();\n            c.assign(_, m);\n          };\n        } else {\n          var v = n.IAssociativeContainer.construct.apply(n.IAssociativeContainer, r([c], e(u), !1));\n          d = v.ramda, v.tail.length >= 1 && (p = v.tail[0]), v.tail.length >= 2 && (y = v.tail[1]);\n        }\n        f(p, y), d !== null && d();\n      }\n      o.construct = a;\n    })(t.IHashContainer || (t.IHashContainer = {}));\n  }(_n)), _n;\n}\nvar xn = {}, Dt = {}, zt = {}, vo;\nfunction mi() {\n  if (vo)\n    return zt;\n  vo = 1, Object.defineProperty(zt, \"__esModule\", { value: !0 }), zt.ListIterator = void 0;\n  var t = Wr(), e = function() {\n    function r(n, i, s) {\n      this.prev_ = n, this.next_ = i, this.value_ = s;\n    }\n    return r._Set_prev = function(n, i) {\n      n.prev_ = i;\n    }, r._Set_next = function(n, i) {\n      n.next_ = i;\n    }, r.prototype.prev = function() {\n      return this.prev_;\n    }, r.prototype.next = function() {\n      return this.next_;\n    }, Object.defineProperty(r.prototype, \"value\", {\n      get: function() {\n        return this._Try_value(), this.value_;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), r.prototype._Try_value = function() {\n      if (this.value_ === void 0 && this.equals(this.source().end()) === !0)\n        throw t.ErrorGenerator.iterator_end_value(this.source());\n    }, r.prototype.equals = function(n) {\n      return this === n;\n    }, r;\n  }();\n  return zt.ListIterator = e, zt;\n}\nvar Ft = {}, wo;\nfunction Jh() {\n  if (wo)\n    return Ft;\n  wo = 1, Object.defineProperty(Ft, \"__esModule\", { value: !0 }), Ft.Repeater = void 0;\n  var t = function() {\n    function e(r, n) {\n      this.index_ = r, this.value_ = n;\n    }\n    return e.prototype.index = function() {\n      return this.index_;\n    }, Object.defineProperty(e.prototype, \"value\", {\n      get: function() {\n        return this.value_;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), e.prototype.next = function() {\n      return ++this.index_, this;\n    }, e.prototype.equals = function(r) {\n      return this.index_ === r.index_;\n    }, e;\n  }();\n  return Ft.Repeater = t, Ft;\n}\nvar ce = {}, _o;\nfunction Xh() {\n  if (_o)\n    return ce;\n  _o = 1, Object.defineProperty(ce, \"__esModule\", { value: !0 }), ce.next = ce.prev = ce.advance = ce.distance = ce.size = ce.empty = void 0;\n  var t = Sa();\n  function e(c) {\n    return c instanceof Array ? c.length !== 0 : c.empty();\n  }\n  ce.empty = e;\n  function r(c) {\n    return c instanceof Array ? c.length : c.size();\n  }\n  ce.size = r;\n  function n(c, l) {\n    if (c.index instanceof Function)\n      return i(c, l);\n    for (var f = 0; !c.equals(l); c = c.next())\n      ++f;\n    return f;\n  }\n  ce.distance = n;\n  function i(c, l) {\n    var f = c.index(), u = l.index();\n    return c.base instanceof Function ? f - u : u - f;\n  }\n  function s(c, l) {\n    if (l === 0)\n      return c;\n    if (c.advance instanceof Function)\n      return c.advance(l);\n    var f;\n    if (l < 0) {\n      if (!(c.prev instanceof Function))\n        throw new t.InvalidArgument(\"Error on std.advance(): parametric iterator is not a bi-directional iterator, thus advancing to negative direction is not possible.\");\n      f = function(u) {\n        return u.prev();\n      }, l = -l;\n    } else\n      f = function(u) {\n        return u.next();\n      };\n    for (; l-- > 0; )\n      c = f(c);\n    return c;\n  }\n  ce.advance = s;\n  function o(c, l) {\n    return l === void 0 && (l = 1), l === 1 ? c.prev() : s(c, -l);\n  }\n  ce.prev = o;\n  function a(c, l) {\n    return l === void 0 && (l = 1), l === 1 ? c.next() : s(c, l);\n  }\n  return ce.next = a, ce;\n}\nvar mo;\nfunction Ca() {\n  if (mo)\n    return Dt;\n  mo = 1;\n  var t = S && S.__extends || function() {\n    var l = function(f, u) {\n      return l = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(h, d) {\n        h.__proto__ = d;\n      } || function(h, d) {\n        for (var p in d)\n          Object.prototype.hasOwnProperty.call(d, p) && (h[p] = d[p]);\n      }, l(f, u);\n    };\n    return function(f, u) {\n      if (typeof u != \"function\" && u !== null)\n        throw new TypeError(\"Class extends value \" + String(u) + \" is not a constructor or null\");\n      l(f, u);\n      function h() {\n        this.constructor = f;\n      }\n      f.prototype = u === null ? Object.create(u) : (h.prototype = u.prototype, new h());\n    };\n  }(), e = S && S.__read || function(l, f) {\n    var u = typeof Symbol == \"function\" && l[Symbol.iterator];\n    if (!u)\n      return l;\n    var h = u.call(l), d, p = [], y;\n    try {\n      for (; (f === void 0 || f-- > 0) && !(d = h.next()).done; )\n        p.push(d.value);\n    } catch (g) {\n      y = { error: g };\n    } finally {\n      try {\n        d && !d.done && (u = h.return) && u.call(h);\n      } finally {\n        if (y)\n          throw y.error;\n      }\n    }\n    return p;\n  };\n  Object.defineProperty(Dt, \"__esModule\", { value: !0 }), Dt.ListContainer = void 0;\n  var r = bi(), n = mi(), i = Jh(), s = vi(), o = Xh(), a = Wr(), c = function(l) {\n    t(f, l);\n    function f() {\n      var u = l.call(this) || this;\n      return u.end_ = u._Create_iterator(null, null), u.clear(), u;\n    }\n    return f.prototype.assign = function(u, h) {\n      this.clear(), this.insert(this.end(), u, h);\n    }, f.prototype.clear = function() {\n      n.ListIterator._Set_prev(this.end_, this.end_), n.ListIterator._Set_next(this.end_, this.end_), this.begin_ = this.end_, this.size_ = 0;\n    }, f.prototype.resize = function(u) {\n      var h = u - this.size();\n      h > 0 ? this.insert(this.end(), h, void 0) : h < 0 && this.erase((0, o.advance)(this.end(), -h), this.end());\n    }, f.prototype.begin = function() {\n      return this.begin_;\n    }, f.prototype.end = function() {\n      return this.end_;\n    }, f.prototype.size = function() {\n      return this.size_;\n    }, f.prototype.push_front = function(u) {\n      this.insert(this.begin_, u);\n    }, f.prototype.push_back = function(u) {\n      this.insert(this.end_, u);\n    }, f.prototype.pop_front = function() {\n      if (this.empty() === !0)\n        throw a.ErrorGenerator.empty(this.end_.source().constructor.name, \"pop_front\");\n      this.erase(this.begin_);\n    }, f.prototype.pop_back = function() {\n      if (this.empty() === !0)\n        throw a.ErrorGenerator.empty(this.end_.source().constructor.name, \"pop_back\");\n      this.erase(this.end_.prev());\n    }, f.prototype.push = function() {\n      for (var u = [], h = 0; h < arguments.length; h++)\n        u[h] = arguments[h];\n      if (u.length === 0)\n        return this.size();\n      var d = new s.NativeArrayIterator(u, 0), p = new s.NativeArrayIterator(u, u.length);\n      return this._Insert_by_range(this.end(), d, p), this.size();\n    }, f.prototype.insert = function(u) {\n      for (var h = [], d = 1; d < arguments.length; d++)\n        h[d - 1] = arguments[d];\n      if (u.source() !== this.end_.source())\n        throw a.ErrorGenerator.not_my_iterator(this.end_.source(), \"insert\");\n      if (u.erased_ === !0)\n        throw a.ErrorGenerator.erased_iterator(this.end_.source(), \"insert\");\n      return h.length === 1 ? this._Insert_by_repeating_val(u, 1, h[0]) : h.length === 2 && typeof h[0] == \"number\" ? this._Insert_by_repeating_val(u, h[0], h[1]) : this._Insert_by_range(u, h[0], h[1]);\n    }, f.prototype._Insert_by_repeating_val = function(u, h, d) {\n      var p = new i.Repeater(0, d), y = new i.Repeater(h);\n      return this._Insert_by_range(u, p, y);\n    }, f.prototype._Insert_by_range = function(u, h, d) {\n      for (var p = u.prev(), y = null, g = 0, v = h; v.equals(d) === !1; v = v.next()) {\n        var _ = this._Create_iterator(p, null, v.value);\n        g === 0 && (y = _), n.ListIterator._Set_next(p, _), p = _, ++g;\n      }\n      return u.equals(this.begin()) === !0 && (this.begin_ = y), n.ListIterator._Set_next(p, u), n.ListIterator._Set_prev(u, p), this.size_ += g, y;\n    }, f.prototype.erase = function(u, h) {\n      return h === void 0 && (h = u.next()), this._Erase_by_range(u, h);\n    }, f.prototype._Erase_by_range = function(u, h) {\n      if (u.source() !== this.end_.source())\n        throw a.ErrorGenerator.not_my_iterator(this.end_.source(), \"insert\");\n      if (u.erased_ === !0)\n        throw a.ErrorGenerator.erased_iterator(this.end_.source(), \"insert\");\n      if (u.equals(this.end_))\n        return this.end_;\n      var d = u.prev();\n      n.ListIterator._Set_next(d, h), n.ListIterator._Set_prev(h, d);\n      for (var p = u; !p.equals(h); p = p.next())\n        p.erased_ = !0, --this.size_;\n      return u.equals(this.begin_) && (this.begin_ = h), h;\n    }, f.prototype.swap = function(u) {\n      var h, d, p;\n      h = e([u.begin_, this.begin_], 2), this.begin_ = h[0], u.begin_ = h[1], d = e([u.end_, this.end_], 2), this.end_ = d[0], u.end_ = d[1], p = e([u.size_, this.size_], 2), this.size_ = p[0], u.size_ = p[1];\n    }, f;\n  }(r.Container);\n  return Dt.ListContainer = c, Dt;\n}\nvar Kt = {}, xo;\nfunction Ia() {\n  if (xo)\n    return Kt;\n  xo = 1, Object.defineProperty(Kt, \"__esModule\", { value: !0 }), Kt.ReverseIterator = void 0;\n  var t = function() {\n    function e(r) {\n      this.base_ = r.prev();\n    }\n    return e.prototype.source = function() {\n      return this.base_.source();\n    }, e.prototype.base = function() {\n      return this.base_.next();\n    }, Object.defineProperty(e.prototype, \"value\", {\n      get: function() {\n        return this.base_.value;\n      },\n      enumerable: !1,\n      configurable: !0\n    }), e.prototype.prev = function() {\n      return this._Create_neighbor(this.base().next());\n    }, e.prototype.next = function() {\n      return this._Create_neighbor(this.base_);\n    }, e.prototype.equals = function(r) {\n      return this.base_.equals(r.base_);\n    }, e;\n  }();\n  return Kt.ReverseIterator = t, Kt;\n}\nvar Eo;\nfunction Qh() {\n  return Eo || (Eo = 1, function(t) {\n    var e = S && S.__extends || function() {\n      var a = function(c, l) {\n        return a = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(f, u) {\n          f.__proto__ = u;\n        } || function(f, u) {\n          for (var h in u)\n            Object.prototype.hasOwnProperty.call(u, h) && (f[h] = u[h]);\n        }, a(c, l);\n      };\n      return function(c, l) {\n        if (typeof l != \"function\" && l !== null)\n          throw new TypeError(\"Class extends value \" + String(l) + \" is not a constructor or null\");\n        a(c, l);\n        function f() {\n          this.constructor = c;\n        }\n        c.prototype = l === null ? Object.create(l) : (f.prototype = l.prototype, new f());\n      };\n    }(), r = S && S.__read || function(a, c) {\n      var l = typeof Symbol == \"function\" && a[Symbol.iterator];\n      if (!l)\n        return a;\n      var f = l.call(a), u, h = [], d;\n      try {\n        for (; (c === void 0 || c-- > 0) && !(u = f.next()).done; )\n          h.push(u.value);\n      } catch (p) {\n        d = { error: p };\n      } finally {\n        try {\n          u && !u.done && (l = f.return) && l.call(f);\n        } finally {\n          if (d)\n            throw d.error;\n        }\n      }\n      return h;\n    };\n    Object.defineProperty(t, \"__esModule\", { value: !0 }), t.SetElementList = void 0;\n    var n = Ca(), i = mi(), s = Ia(), o = function(a) {\n      e(c, a);\n      function c(l) {\n        var f = a.call(this) || this;\n        return f.associative_ = l, f;\n      }\n      return c.prototype._Create_iterator = function(l, f, u) {\n        return c.Iterator.create(this, l, f, u);\n      }, c._Swap_associative = function(l, f) {\n        var u;\n        u = r([f.associative_, l.associative_], 2), l.associative_ = u[0], f.associative_ = u[1];\n      }, c.prototype.associative = function() {\n        return this.associative_;\n      }, c;\n    }(n.ListContainer);\n    t.SetElementList = o, function(a) {\n      var c = function(f) {\n        e(u, f);\n        function u(h, d, p, y) {\n          var g = f.call(this, d, p, y) || this;\n          return g.source_ = h, g;\n        }\n        return u.create = function(h, d, p, y) {\n          return new u(h, d, p, y);\n        }, u.prototype.reverse = function() {\n          return new l(this);\n        }, u.prototype.source = function() {\n          return this.source_.associative();\n        }, u;\n      }(i.ListIterator);\n      a.Iterator = c;\n      var l = function(f) {\n        e(u, f);\n        function u() {\n          return f !== null && f.apply(this, arguments) || this;\n        }\n        return u.prototype._Create_neighbor = function(h) {\n          return new u(h);\n        }, u;\n      }(s.ReverseIterator);\n      a.ReverseIterator = l;\n    }(o = t.SetElementList || (t.SetElementList = {})), t.SetElementList = o;\n  }(xn)), xn;\n}\nvar Wt = {}, Vt = {}, ko;\nfunction Ra() {\n  if (ko)\n    return Vt;\n  ko = 1;\n  var t = S && S.__values || function(i) {\n    var s = typeof Symbol == \"function\" && Symbol.iterator, o = s && i[s], a = 0;\n    if (o)\n      return o.call(i);\n    if (i && typeof i.length == \"number\")\n      return {\n        next: function() {\n          return i && a >= i.length && (i = void 0), { value: i && i[a++], done: !i };\n        }\n      };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n  };\n  Object.defineProperty(Vt, \"__esModule\", { value: !0 }), Vt.HashBuckets = void 0;\n  var e = function() {\n    function i(s, o) {\n      this.fetcher_ = s, this.hasher_ = o, this.max_load_factor_ = n, this.data_ = [], this.size_ = 0, this.initialize();\n    }\n    return i.prototype.clear = function() {\n      this.data_ = [], this.size_ = 0, this.initialize();\n    }, i.prototype.rehash = function(s) {\n      var o, a, c, l;\n      s = Math.max(s, r);\n      for (var f = [], u = 0; u < s; ++u)\n        f.push([]);\n      try {\n        for (var h = t(this.data_), d = h.next(); !d.done; d = h.next()) {\n          var p = d.value;\n          try {\n            for (var y = (c = void 0, t(p)), g = y.next(); !g.done; g = y.next()) {\n              var v = g.value, _ = this.hasher_(this.fetcher_(v)) % f.length;\n              f[_].push(v);\n            }\n          } catch (m) {\n            c = { error: m };\n          } finally {\n            try {\n              g && !g.done && (l = y.return) && l.call(y);\n            } finally {\n              if (c)\n                throw c.error;\n            }\n          }\n        }\n      } catch (m) {\n        o = { error: m };\n      } finally {\n        try {\n          d && !d.done && (a = h.return) && a.call(h);\n        } finally {\n          if (o)\n            throw o.error;\n        }\n      }\n      this.data_ = f;\n    }, i.prototype.reserve = function(s) {\n      s > this.capacity() && (s = Math.floor(s / this.max_load_factor_), this.rehash(s));\n    }, i.prototype.initialize = function() {\n      for (var s = 0; s < r; ++s)\n        this.data_.push([]);\n    }, i.prototype.length = function() {\n      return this.data_.length;\n    }, i.prototype.capacity = function() {\n      return this.data_.length * this.max_load_factor_;\n    }, i.prototype.at = function(s) {\n      return this.data_[s];\n    }, i.prototype.load_factor = function() {\n      return this.size_ / this.length();\n    }, i.prototype.max_load_factor = function(s) {\n      if (s === void 0 && (s = null), s === null)\n        return this.max_load_factor_;\n      this.max_load_factor_ = s;\n    }, i.prototype.hash_function = function() {\n      return this.hasher_;\n    }, i.prototype.index = function(s) {\n      return this.hasher_(this.fetcher_(s)) % this.length();\n    }, i.prototype.insert = function(s) {\n      var o = this.capacity();\n      ++this.size_ > o && this.reserve(o * 2);\n      var a = this.index(s);\n      this.data_[a].push(s);\n    }, i.prototype.erase = function(s) {\n      for (var o = this.index(s), a = this.data_[o], c = 0; c < a.length; ++c)\n        if (a[c] === s) {\n          a.splice(c, 1), --this.size_;\n          break;\n        }\n    }, i;\n  }();\n  Vt.HashBuckets = e;\n  var r = 10, n = 1;\n  return Vt;\n}\nvar So;\nfunction ed() {\n  if (So)\n    return Wt;\n  So = 1;\n  var t = S && S.__extends || function() {\n    var o = function(a, c) {\n      return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(l, f) {\n        l.__proto__ = f;\n      } || function(l, f) {\n        for (var u in f)\n          Object.prototype.hasOwnProperty.call(f, u) && (l[u] = f[u]);\n      }, o(a, c);\n    };\n    return function(a, c) {\n      if (typeof c != \"function\" && c !== null)\n        throw new TypeError(\"Class extends value \" + String(c) + \" is not a constructor or null\");\n      o(a, c);\n      function l() {\n        this.constructor = a;\n      }\n      a.prototype = c === null ? Object.create(c) : (l.prototype = c.prototype, new l());\n    };\n  }(), e = S && S.__read || function(o, a) {\n    var c = typeof Symbol == \"function\" && o[Symbol.iterator];\n    if (!c)\n      return o;\n    var l = c.call(o), f, u = [], h;\n    try {\n      for (; (a === void 0 || a-- > 0) && !(f = l.next()).done; )\n        u.push(f.value);\n    } catch (d) {\n      h = { error: d };\n    } finally {\n      try {\n        f && !f.done && (c = l.return) && c.call(l);\n      } finally {\n        if (h)\n          throw h.error;\n      }\n    }\n    return u;\n  }, r = S && S.__values || function(o) {\n    var a = typeof Symbol == \"function\" && Symbol.iterator, c = a && o[a], l = 0;\n    if (c)\n      return c.call(o);\n    if (o && typeof o.length == \"number\")\n      return {\n        next: function() {\n          return o && l >= o.length && (o = void 0), { value: o && o[l++], done: !o };\n        }\n      };\n    throw new TypeError(a ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n  };\n  Object.defineProperty(Wt, \"__esModule\", { value: !0 }), Wt.SetHashBuckets = void 0;\n  var n = Ra(), i = function(o) {\n    t(a, o);\n    function a(c, l, f) {\n      var u = o.call(this, s, l) || this;\n      return u.source_ = c, u.key_eq_ = f, u;\n    }\n    return a._Swap_source = function(c, l) {\n      var f;\n      f = e([l.source_, c.source_], 2), c.source_ = f[0], l.source_ = f[1];\n    }, a.prototype.key_eq = function() {\n      return this.key_eq_;\n    }, a.prototype.find = function(c) {\n      var l, f, u = this.hash_function()(c) % this.length(), h = this.at(u);\n      try {\n        for (var d = r(h), p = d.next(); !p.done; p = d.next()) {\n          var y = p.value;\n          if (this.key_eq_(y.value, c))\n            return y;\n        }\n      } catch (g) {\n        l = { error: g };\n      } finally {\n        try {\n          p && !p.done && (f = d.return) && f.call(d);\n        } finally {\n          if (l)\n            throw l.error;\n        }\n      }\n      return this.source_.end();\n    }, a;\n  }(n.HashBuckets);\n  Wt.SetHashBuckets = i;\n  function s(o) {\n    return o.value;\n  }\n  return Wt;\n}\nvar st = {}, Oo;\nfunction Ta() {\n  if (Oo)\n    return st;\n  Oo = 1, Object.defineProperty(st, \"__esModule\", { value: !0 }), st.make_pair = st.Pair = void 0;\n  var t = wi(), e = _i(), r = function() {\n    function i(s, o) {\n      this.first = s, this.second = o;\n    }\n    return i.prototype.equals = function(s) {\n      return (0, e.equal_to)(this.first, s.first) && (0, e.equal_to)(this.second, s.second);\n    }, i.prototype.less = function(s) {\n      return (0, e.equal_to)(this.first, s.first) === !1 ? (0, e.less)(this.first, s.first) : (0, e.less)(this.second, s.second);\n    }, i.prototype.hashCode = function() {\n      return (0, t.hash)(this.first, this.second);\n    }, i;\n  }();\n  st.Pair = r;\n  function n(i, s) {\n    return new r(i, s);\n  }\n  return st.make_pair = n, st;\n}\nvar Ao;\nfunction td() {\n  return Ao || (Ao = 1, function(t) {\n    var e = S && S.__extends || function() {\n      var f = function(u, h) {\n        return f = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, p) {\n          d.__proto__ = p;\n        } || function(d, p) {\n          for (var y in p)\n            Object.prototype.hasOwnProperty.call(p, y) && (d[y] = p[y]);\n        }, f(u, h);\n      };\n      return function(u, h) {\n        if (typeof h != \"function\" && h !== null)\n          throw new TypeError(\"Class extends value \" + String(h) + \" is not a constructor or null\");\n        f(u, h);\n        function d() {\n          this.constructor = u;\n        }\n        u.prototype = h === null ? Object.create(h) : (d.prototype = h.prototype, new d());\n      };\n    }(), r = S && S.__read || function(f, u) {\n      var h = typeof Symbol == \"function\" && f[Symbol.iterator];\n      if (!h)\n        return f;\n      var d = h.call(f), p, y = [], g;\n      try {\n        for (; (u === void 0 || u-- > 0) && !(p = d.next()).done; )\n          y.push(p.value);\n      } catch (v) {\n        g = { error: v };\n      } finally {\n        try {\n          p && !p.done && (h = d.return) && h.call(d);\n        } finally {\n          if (g)\n            throw g.error;\n        }\n      }\n      return y;\n    }, n = S && S.__spreadArray || function(f, u, h) {\n      if (h || arguments.length === 2)\n        for (var d = 0, p = u.length, y; d < p; d++)\n          (y || !(d in u)) && (y || (y = Array.prototype.slice.call(u, 0, d)), y[d] = u[d]);\n      return f.concat(y || Array.prototype.slice.call(u));\n    };\n    Object.defineProperty(t, \"__esModule\", { value: !0 }), t.HashSet = void 0;\n    var i = Gh(), s = Aa(), o = Qh(), a = ed(), c = Ta(), l = function(f) {\n      e(u, f);\n      function u() {\n        for (var h = [], d = 0; d < arguments.length; d++)\n          h[d] = arguments[d];\n        var p = f.call(this, function(y) {\n          return new o.SetElementList(y);\n        }) || this;\n        return s.IHashContainer.construct.apply(s.IHashContainer, n([\n          p,\n          u,\n          function(y, g) {\n            p.buckets_ = new a.SetHashBuckets(p, y, g);\n          }\n        ], r(h), !1)), p;\n      }\n      return u.prototype.clear = function() {\n        this.buckets_.clear(), f.prototype.clear.call(this);\n      }, u.prototype.swap = function(h) {\n        var d, p;\n        d = r([h.data_, this.data_], 2), this.data_ = d[0], h.data_ = d[1], o.SetElementList._Swap_associative(this.data_, h.data_), a.SetHashBuckets._Swap_source(this.buckets_, h.buckets_), p = r([h.buckets_, this.buckets_], 2), this.buckets_ = p[0], h.buckets_ = p[1];\n      }, u.prototype.find = function(h) {\n        return this.buckets_.find(h);\n      }, u.prototype.begin = function(h) {\n        return h === void 0 && (h = null), h === null ? f.prototype.begin.call(this) : this.buckets_.at(h)[0];\n      }, u.prototype.end = function(h) {\n        if (h === void 0 && (h = null), h === null)\n          return f.prototype.end.call(this);\n        var d = this.buckets_.at(h);\n        return d[d.length - 1].next();\n      }, u.prototype.rbegin = function(h) {\n        return h === void 0 && (h = null), this.end(h).reverse();\n      }, u.prototype.rend = function(h) {\n        return h === void 0 && (h = null), this.begin(h).reverse();\n      }, u.prototype.bucket_count = function() {\n        return this.buckets_.length();\n      }, u.prototype.bucket_size = function(h) {\n        return this.buckets_.at(h).length;\n      }, u.prototype.load_factor = function() {\n        return this.buckets_.load_factor();\n      }, u.prototype.hash_function = function() {\n        return this.buckets_.hash_function();\n      }, u.prototype.key_eq = function() {\n        return this.buckets_.key_eq();\n      }, u.prototype.bucket = function(h) {\n        return this.hash_function()(h) % this.buckets_.length();\n      }, u.prototype.max_load_factor = function(h) {\n        return h === void 0 && (h = null), this.buckets_.max_load_factor(h);\n      }, u.prototype.reserve = function(h) {\n        this.buckets_.reserve(h);\n      }, u.prototype.rehash = function(h) {\n        this.buckets_.rehash(h);\n      }, u.prototype._Insert_by_key = function(h) {\n        var d = this.find(h);\n        return d.equals(this.end()) === !1 ? new c.Pair(d, !1) : (this.data_.push(h), d = d.prev(), this._Handle_insert(d, d.next()), new c.Pair(d, !0));\n      }, u.prototype._Insert_by_hint = function(h, d) {\n        var p = this.find(d);\n        return p.equals(this.end()) === !0 && (p = this.data_.insert(h, d), this._Handle_insert(p, p.next())), p;\n      }, u.prototype._Handle_insert = function(h, d) {\n        for (; !h.equals(d); h = h.next())\n          this.buckets_.insert(h);\n      }, u.prototype._Handle_erase = function(h, d) {\n        for (; !h.equals(d); h = h.next())\n          this.buckets_.erase(h);\n      }, u;\n    }(i.UniqueSet);\n    t.HashSet = l, function(f) {\n      f.Iterator = o.SetElementList.Iterator, f.ReverseIterator = o.SetElementList.ReverseIterator;\n    }(l = t.HashSet || (t.HashSet = {})), t.HashSet = l;\n  }(vn)), vn;\n}\nvar En = {}, Gt = {}, Zt = {}, Co;\nfunction rd() {\n  if (Co)\n    return Zt;\n  Co = 1;\n  var t = S && S.__extends || function() {\n    var i = function(s, o) {\n      return i = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(a, c) {\n        a.__proto__ = c;\n      } || function(a, c) {\n        for (var l in c)\n          Object.prototype.hasOwnProperty.call(c, l) && (a[l] = c[l]);\n      }, i(s, o);\n    };\n    return function(s, o) {\n      if (typeof o != \"function\" && o !== null)\n        throw new TypeError(\"Class extends value \" + String(o) + \" is not a constructor or null\");\n      i(s, o);\n      function a() {\n        this.constructor = s;\n      }\n      s.prototype = o === null ? Object.create(o) : (a.prototype = o.prototype, new a());\n    };\n  }();\n  Object.defineProperty(Zt, \"__esModule\", { value: !0 }), Zt.MapContainer = void 0;\n  var e = bi(), r = vi(), n = function(i) {\n    t(s, i);\n    function s(o) {\n      var a = i.call(this) || this;\n      return a.data_ = o(a), a;\n    }\n    return s.prototype.assign = function(o, a) {\n      this.clear(), this.insert(o, a);\n    }, s.prototype.clear = function() {\n      this.data_.clear();\n    }, s.prototype.begin = function() {\n      return this.data_.begin();\n    }, s.prototype.end = function() {\n      return this.data_.end();\n    }, s.prototype.has = function(o) {\n      return !this.find(o).equals(this.end());\n    }, s.prototype.size = function() {\n      return this.data_.size();\n    }, s.prototype.push = function() {\n      for (var o = [], a = 0; a < arguments.length; a++)\n        o[a] = arguments[a];\n      var c = new r.NativeArrayIterator(o, 0), l = new r.NativeArrayIterator(o, o.length);\n      return this.insert(c, l), this.size();\n    }, s.prototype.insert = function() {\n      for (var o = [], a = 0; a < arguments.length; a++)\n        o[a] = arguments[a];\n      return o.length === 1 ? this.emplace(o[0].first, o[0].second) : o[0].next instanceof Function && o[1].next instanceof Function ? this._Insert_by_range(o[0], o[1]) : this.emplace_hint(o[0], o[1].first, o[1].second);\n    }, s.prototype.erase = function() {\n      for (var o = [], a = 0; a < arguments.length; a++)\n        o[a] = arguments[a];\n      return o.length === 1 && (!(o[0] instanceof this.end().constructor) || o[0].source() !== this) ? this._Erase_by_key(o[0]) : o.length === 1 ? this._Erase_by_range(o[0]) : this._Erase_by_range(o[0], o[1]);\n    }, s.prototype._Erase_by_range = function(o, a) {\n      a === void 0 && (a = o.next());\n      var c = this.data_.erase(o, a);\n      return this._Handle_erase(o, a), c;\n    }, s;\n  }(e.Container);\n  return Zt.MapContainer = n, Zt;\n}\nvar Io;\nfunction nd() {\n  if (Io)\n    return Gt;\n  Io = 1;\n  var t = S && S.__extends || function() {\n    var o = function(a, c) {\n      return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(l, f) {\n        l.__proto__ = f;\n      } || function(l, f) {\n        for (var u in f)\n          Object.prototype.hasOwnProperty.call(f, u) && (l[u] = f[u]);\n      }, o(a, c);\n    };\n    return function(a, c) {\n      if (typeof c != \"function\" && c !== null)\n        throw new TypeError(\"Class extends value \" + String(c) + \" is not a constructor or null\");\n      o(a, c);\n      function l() {\n        this.constructor = a;\n      }\n      a.prototype = c === null ? Object.create(c) : (l.prototype = c.prototype, new l());\n    };\n  }(), e = S && S.__read || function(o, a) {\n    var c = typeof Symbol == \"function\" && o[Symbol.iterator];\n    if (!c)\n      return o;\n    var l = c.call(o), f, u = [], h;\n    try {\n      for (; (a === void 0 || a-- > 0) && !(f = l.next()).done; )\n        u.push(f.value);\n    } catch (d) {\n      h = { error: d };\n    } finally {\n      try {\n        f && !f.done && (c = l.return) && c.call(l);\n      } finally {\n        if (h)\n          throw h.error;\n      }\n    }\n    return u;\n  }, r = S && S.__spreadArray || function(o, a, c) {\n    if (c || arguments.length === 2)\n      for (var l = 0, f = a.length, u; l < f; l++)\n        (u || !(l in a)) && (u || (u = Array.prototype.slice.call(a, 0, l)), u[l] = a[l]);\n    return o.concat(u || Array.prototype.slice.call(a));\n  };\n  Object.defineProperty(Gt, \"__esModule\", { value: !0 }), Gt.UniqueMap = void 0;\n  var n = rd(), i = Wr(), s = function(o) {\n    t(a, o);\n    function a() {\n      return o !== null && o.apply(this, arguments) || this;\n    }\n    return a.prototype.count = function(c) {\n      return this.find(c).equals(this.end()) ? 0 : 1;\n    }, a.prototype.get = function(c) {\n      var l = this.find(c);\n      if (l.equals(this.end()) === !0)\n        throw i.ErrorGenerator.key_nout_found(this, \"get\", c);\n      return l.second;\n    }, a.prototype.take = function(c, l) {\n      var f = this.find(c);\n      return f.equals(this.end()) ? this.emplace(c, l()).first.second : f.second;\n    }, a.prototype.set = function(c, l) {\n      this.insert_or_assign(c, l);\n    }, a.prototype.insert = function() {\n      for (var c = [], l = 0; l < arguments.length; l++)\n        c[l] = arguments[l];\n      return o.prototype.insert.apply(this, r([], e(c), !1));\n    }, a.prototype._Insert_by_range = function(c, l) {\n      for (var f = c; !f.equals(l); f = f.next())\n        this.emplace(f.value.first, f.value.second);\n    }, a.prototype.insert_or_assign = function() {\n      for (var c = [], l = 0; l < arguments.length; l++)\n        c[l] = arguments[l];\n      if (c.length === 2)\n        return this._Insert_or_assign_with_key_value(c[0], c[1]);\n      if (c.length === 3)\n        return this._Insert_or_assign_with_hint(c[0], c[1], c[2]);\n    }, a.prototype._Insert_or_assign_with_key_value = function(c, l) {\n      var f = this.emplace(c, l);\n      return f.second === !1 && (f.first.second = l), f;\n    }, a.prototype._Insert_or_assign_with_hint = function(c, l, f) {\n      var u = this.emplace_hint(c, l, f);\n      return u.second !== f && (u.second = f), u;\n    }, a.prototype.extract = function(c) {\n      return c instanceof this.end().constructor ? this._Extract_by_iterator(c) : this._Extract_by_key(c);\n    }, a.prototype._Extract_by_key = function(c) {\n      var l = this.find(c);\n      if (l.equals(this.end()) === !0)\n        throw i.ErrorGenerator.key_nout_found(this, \"extract\", c);\n      var f = l.value;\n      return this._Erase_by_range(l), f;\n    }, a.prototype._Extract_by_iterator = function(c) {\n      return c.equals(this.end()) === !0 ? this.end() : (this._Erase_by_range(c), c);\n    }, a.prototype._Erase_by_key = function(c) {\n      var l = this.find(c);\n      return l.equals(this.end()) === !0 ? 0 : (this._Erase_by_range(l), 1);\n    }, a.prototype.merge = function(c) {\n      for (var l = c.begin(); !l.equals(c.end()); )\n        this.has(l.first) === !1 ? (this.insert(l.value), l = c.erase(l)) : l = l.next();\n    }, a;\n  }(n.MapContainer);\n  return Gt.UniqueMap = s, Gt;\n}\nvar kn = {}, Ro;\nfunction id() {\n  return Ro || (Ro = 1, function(t) {\n    var e = S && S.__extends || function() {\n      var a = function(c, l) {\n        return a = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(f, u) {\n          f.__proto__ = u;\n        } || function(f, u) {\n          for (var h in u)\n            Object.prototype.hasOwnProperty.call(u, h) && (f[h] = u[h]);\n        }, a(c, l);\n      };\n      return function(c, l) {\n        if (typeof l != \"function\" && l !== null)\n          throw new TypeError(\"Class extends value \" + String(l) + \" is not a constructor or null\");\n        a(c, l);\n        function f() {\n          this.constructor = c;\n        }\n        c.prototype = l === null ? Object.create(l) : (f.prototype = l.prototype, new f());\n      };\n    }(), r = S && S.__read || function(a, c) {\n      var l = typeof Symbol == \"function\" && a[Symbol.iterator];\n      if (!l)\n        return a;\n      var f = l.call(a), u, h = [], d;\n      try {\n        for (; (c === void 0 || c-- > 0) && !(u = f.next()).done; )\n          h.push(u.value);\n      } catch (p) {\n        d = { error: p };\n      } finally {\n        try {\n          u && !u.done && (l = f.return) && l.call(f);\n        } finally {\n          if (d)\n            throw d.error;\n        }\n      }\n      return h;\n    };\n    Object.defineProperty(t, \"__esModule\", { value: !0 }), t.MapElementList = void 0;\n    var n = Ca(), i = mi(), s = Ia(), o = function(a) {\n      e(c, a);\n      function c(l) {\n        var f = a.call(this) || this;\n        return f.associative_ = l, f;\n      }\n      return c.prototype._Create_iterator = function(l, f, u) {\n        return c.Iterator.create(this, l, f, u);\n      }, c._Swap_associative = function(l, f) {\n        var u;\n        u = r([f.associative_, l.associative_], 2), l.associative_ = u[0], f.associative_ = u[1];\n      }, c.prototype.associative = function() {\n        return this.associative_;\n      }, c;\n    }(n.ListContainer);\n    t.MapElementList = o, function(a) {\n      var c = function(f) {\n        e(u, f);\n        function u(h, d, p, y) {\n          var g = f.call(this, d, p, y) || this;\n          return g.list_ = h, g;\n        }\n        return u.create = function(h, d, p, y) {\n          return new u(h, d, p, y);\n        }, u.prototype.reverse = function() {\n          return new l(this);\n        }, u.prototype.source = function() {\n          return this.list_.associative();\n        }, Object.defineProperty(u.prototype, \"first\", {\n          get: function() {\n            return this.value.first;\n          },\n          enumerable: !1,\n          configurable: !0\n        }), Object.defineProperty(u.prototype, \"second\", {\n          get: function() {\n            return this.value.second;\n          },\n          set: function(h) {\n            this.value.second = h;\n          },\n          enumerable: !1,\n          configurable: !0\n        }), u;\n      }(i.ListIterator);\n      a.Iterator = c;\n      var l = function(f) {\n        e(u, f);\n        function u() {\n          return f !== null && f.apply(this, arguments) || this;\n        }\n        return u.prototype._Create_neighbor = function(h) {\n          return new u(h);\n        }, Object.defineProperty(u.prototype, \"first\", {\n          get: function() {\n            return this.base_.first;\n          },\n          enumerable: !1,\n          configurable: !0\n        }), Object.defineProperty(u.prototype, \"second\", {\n          get: function() {\n            return this.base_.second;\n          },\n          set: function(h) {\n            this.base_.second = h;\n          },\n          enumerable: !1,\n          configurable: !0\n        }), u;\n      }(s.ReverseIterator);\n      a.ReverseIterator = l;\n    }(o = t.MapElementList || (t.MapElementList = {})), t.MapElementList = o;\n  }(kn)), kn;\n}\nvar Yt = {}, To;\nfunction od() {\n  if (To)\n    return Yt;\n  To = 1;\n  var t = S && S.__extends || function() {\n    var o = function(a, c) {\n      return o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(l, f) {\n        l.__proto__ = f;\n      } || function(l, f) {\n        for (var u in f)\n          Object.prototype.hasOwnProperty.call(f, u) && (l[u] = f[u]);\n      }, o(a, c);\n    };\n    return function(a, c) {\n      if (typeof c != \"function\" && c !== null)\n        throw new TypeError(\"Class extends value \" + String(c) + \" is not a constructor or null\");\n      o(a, c);\n      function l() {\n        this.constructor = a;\n      }\n      a.prototype = c === null ? Object.create(c) : (l.prototype = c.prototype, new l());\n    };\n  }(), e = S && S.__read || function(o, a) {\n    var c = typeof Symbol == \"function\" && o[Symbol.iterator];\n    if (!c)\n      return o;\n    var l = c.call(o), f, u = [], h;\n    try {\n      for (; (a === void 0 || a-- > 0) && !(f = l.next()).done; )\n        u.push(f.value);\n    } catch (d) {\n      h = { error: d };\n    } finally {\n      try {\n        f && !f.done && (c = l.return) && c.call(l);\n      } finally {\n        if (h)\n          throw h.error;\n      }\n    }\n    return u;\n  }, r = S && S.__values || function(o) {\n    var a = typeof Symbol == \"function\" && Symbol.iterator, c = a && o[a], l = 0;\n    if (c)\n      return c.call(o);\n    if (o && typeof o.length == \"number\")\n      return {\n        next: function() {\n          return o && l >= o.length && (o = void 0), { value: o && o[l++], done: !o };\n        }\n      };\n    throw new TypeError(a ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n  };\n  Object.defineProperty(Yt, \"__esModule\", { value: !0 }), Yt.MapHashBuckets = void 0;\n  var n = Ra(), i = function(o) {\n    t(a, o);\n    function a(c, l, f) {\n      var u = o.call(this, s, l) || this;\n      return u.source_ = c, u.key_eq_ = f, u;\n    }\n    return a._Swap_source = function(c, l) {\n      var f;\n      f = e([l.source_, c.source_], 2), c.source_ = f[0], l.source_ = f[1];\n    }, a.prototype.key_eq = function() {\n      return this.key_eq_;\n    }, a.prototype.find = function(c) {\n      var l, f, u = this.hash_function()(c) % this.length(), h = this.at(u);\n      try {\n        for (var d = r(h), p = d.next(); !p.done; p = d.next()) {\n          var y = p.value;\n          if (this.key_eq_(y.first, c))\n            return y;\n        }\n      } catch (g) {\n        l = { error: g };\n      } finally {\n        try {\n          p && !p.done && (f = d.return) && f.call(d);\n        } finally {\n          if (l)\n            throw l.error;\n        }\n      }\n      return this.source_.end();\n    }, a;\n  }(n.HashBuckets);\n  Yt.MapHashBuckets = i;\n  function s(o) {\n    return o.first;\n  }\n  return Yt;\n}\nvar Jt = {}, Po;\nfunction sd() {\n  if (Po)\n    return Jt;\n  Po = 1, Object.defineProperty(Jt, \"__esModule\", { value: !0 }), Jt.Entry = void 0;\n  var t = wi(), e = _i(), r = function() {\n    function n(i, s) {\n      this.first = i, this.second = s;\n    }\n    return n.prototype.equals = function(i) {\n      return (0, e.equal_to)(this.first, i.first);\n    }, n.prototype.less = function(i) {\n      return (0, e.less)(this.first, i.first);\n    }, n.prototype.hashCode = function() {\n      return (0, t.hash)(this.first);\n    }, n;\n  }();\n  return Jt.Entry = r, Jt;\n}\nvar Bo;\nfunction ad() {\n  return Bo || (Bo = 1, function(t) {\n    var e = S && S.__extends || function() {\n      var u = function(h, d) {\n        return u = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(p, y) {\n          p.__proto__ = y;\n        } || function(p, y) {\n          for (var g in y)\n            Object.prototype.hasOwnProperty.call(y, g) && (p[g] = y[g]);\n        }, u(h, d);\n      };\n      return function(h, d) {\n        if (typeof d != \"function\" && d !== null)\n          throw new TypeError(\"Class extends value \" + String(d) + \" is not a constructor or null\");\n        u(h, d);\n        function p() {\n          this.constructor = h;\n        }\n        h.prototype = d === null ? Object.create(d) : (p.prototype = d.prototype, new p());\n      };\n    }(), r = S && S.__read || function(u, h) {\n      var d = typeof Symbol == \"function\" && u[Symbol.iterator];\n      if (!d)\n        return u;\n      var p = d.call(u), y, g = [], v;\n      try {\n        for (; (h === void 0 || h-- > 0) && !(y = p.next()).done; )\n          g.push(y.value);\n      } catch (_) {\n        v = { error: _ };\n      } finally {\n        try {\n          y && !y.done && (d = p.return) && d.call(p);\n        } finally {\n          if (v)\n            throw v.error;\n        }\n      }\n      return g;\n    }, n = S && S.__spreadArray || function(u, h, d) {\n      if (d || arguments.length === 2)\n        for (var p = 0, y = h.length, g; p < y; p++)\n          (g || !(p in h)) && (g || (g = Array.prototype.slice.call(h, 0, p)), g[p] = h[p]);\n      return u.concat(g || Array.prototype.slice.call(h));\n    };\n    Object.defineProperty(t, \"__esModule\", { value: !0 }), t.HashMap = void 0;\n    var i = nd(), s = Aa(), o = id(), a = od(), c = sd(), l = Ta(), f = function(u) {\n      e(h, u);\n      function h() {\n        for (var d = [], p = 0; p < arguments.length; p++)\n          d[p] = arguments[p];\n        var y = u.call(this, function(g) {\n          return new o.MapElementList(g);\n        }) || this;\n        return s.IHashContainer.construct.apply(s.IHashContainer, n([\n          y,\n          h,\n          function(g, v) {\n            y.buckets_ = new a.MapHashBuckets(y, g, v);\n          }\n        ], r(d), !1)), y;\n      }\n      return h.prototype.clear = function() {\n        this.buckets_.clear(), u.prototype.clear.call(this);\n      }, h.prototype.swap = function(d) {\n        var p, y;\n        p = r([d.data_, this.data_], 2), this.data_ = p[0], d.data_ = p[1], o.MapElementList._Swap_associative(this.data_, d.data_), a.MapHashBuckets._Swap_source(this.buckets_, d.buckets_), y = r([d.buckets_, this.buckets_], 2), this.buckets_ = y[0], d.buckets_ = y[1];\n      }, h.prototype.find = function(d) {\n        return this.buckets_.find(d);\n      }, h.prototype.begin = function(d) {\n        return d === void 0 && (d = null), d === null ? u.prototype.begin.call(this) : this.buckets_.at(d)[0];\n      }, h.prototype.end = function(d) {\n        if (d === void 0 && (d = null), d === null)\n          return u.prototype.end.call(this);\n        var p = this.buckets_.at(d);\n        return p[p.length - 1].next();\n      }, h.prototype.rbegin = function(d) {\n        return d === void 0 && (d = null), this.end(d).reverse();\n      }, h.prototype.rend = function(d) {\n        return d === void 0 && (d = null), this.begin(d).reverse();\n      }, h.prototype.bucket_count = function() {\n        return this.buckets_.length();\n      }, h.prototype.bucket_size = function(d) {\n        return this.buckets_.at(d).length;\n      }, h.prototype.load_factor = function() {\n        return this.buckets_.load_factor();\n      }, h.prototype.hash_function = function() {\n        return this.buckets_.hash_function();\n      }, h.prototype.key_eq = function() {\n        return this.buckets_.key_eq();\n      }, h.prototype.bucket = function(d) {\n        return this.hash_function()(d) % this.buckets_.length();\n      }, h.prototype.max_load_factor = function(d) {\n        return d === void 0 && (d = null), this.buckets_.max_load_factor(d);\n      }, h.prototype.reserve = function(d) {\n        this.buckets_.reserve(d);\n      }, h.prototype.rehash = function(d) {\n        this.buckets_.rehash(d);\n      }, h.prototype.emplace = function(d, p) {\n        var y = this.find(d);\n        return y.equals(this.end()) === !1 ? new l.Pair(y, !1) : (this.data_.push(new c.Entry(d, p)), y = y.prev(), this._Handle_insert(y, y.next()), new l.Pair(y, !0));\n      }, h.prototype.emplace_hint = function(d, p, y) {\n        var g = this.find(p);\n        return g.equals(this.end()) === !0 && (g = this.data_.insert(d, new c.Entry(p, y)), this._Handle_insert(g, g.next())), g;\n      }, h.prototype._Handle_insert = function(d, p) {\n        for (; !d.equals(p); d = d.next())\n          this.buckets_.insert(d);\n      }, h.prototype._Handle_erase = function(d, p) {\n        for (; !d.equals(p); d = d.next())\n          this.buckets_.erase(d);\n      }, h;\n    }(i.UniqueMap);\n    t.HashMap = f, function(u) {\n      u.Iterator = o.MapElementList.Iterator, u.ReverseIterator = o.MapElementList.ReverseIterator;\n    }(f = t.HashMap || (t.HashMap = {})), t.HashMap = f;\n  }(En)), En;\n}\nvar Lo;\nfunction cd() {\n  if (Lo)\n    return _r;\n  Lo = 1;\n  var t = S && S.__values || function(i) {\n    var s = typeof Symbol == \"function\" && i[Symbol.iterator], o = 0;\n    return s ? s.call(i) : {\n      next: function() {\n        return i && o >= i.length && (i = void 0), { value: i && i[o++], done: !i };\n      }\n    };\n  };\n  Object.defineProperty(_r, \"__esModule\", { value: !0 });\n  var e = td(), r = ad(), n = function() {\n    function i() {\n      this.listeners_ = new r.HashMap(), this.created_at_ = new Date();\n    }\n    return i.prototype.dispatchEvent = function(s) {\n      var o, a, c = this.listeners_.find(s.type);\n      if (!c.equals(this.listeners_.end())) {\n        s.target = this, s.timeStamp = new Date().getTime() - this.created_at_.getTime();\n        try {\n          for (var l = t(c.second), f = l.next(); !f.done; f = l.next()) {\n            var u = f.value;\n            u(s);\n          }\n        } catch (h) {\n          o = { error: h };\n        } finally {\n          try {\n            f && !f.done && (a = l.return) && a.call(l);\n          } finally {\n            if (o)\n              throw o.error;\n          }\n        }\n      }\n    }, i.prototype.addEventListener = function(s, o) {\n      var a = this.listeners_.find(s);\n      a.equals(this.listeners_.end()) && (a = this.listeners_.emplace(s, new e.HashSet()).first), a.second.insert(o);\n    }, i.prototype.removeEventListener = function(s, o) {\n      var a = this.listeners_.find(s);\n      a.equals(this.listeners_.end()) || (a.second.erase(o), a.second.empty() && this.listeners_.erase(a));\n    }, i;\n  }();\n  return _r.EventTarget = n, _r;\n}\nvar mr = {}, $o;\nfunction Vr() {\n  if ($o)\n    return mr;\n  $o = 1, Object.defineProperty(mr, \"__esModule\", { value: !0 });\n  var t = function() {\n    function e(r, n) {\n      this.type = r, n && Object.assign(this, n);\n    }\n    return e;\n  }();\n  return mr.Event = t, mr;\n}\nvar xr = {}, qo;\nfunction ud() {\n  if (qo)\n    return xr;\n  qo = 1;\n  var t = S && S.__extends || function() {\n    var n = function(i, s) {\n      return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(o, a) {\n        o.__proto__ = a;\n      } || function(o, a) {\n        for (var c in a)\n          a.hasOwnProperty(c) && (o[c] = a[c]);\n      }, n(i, s);\n    };\n    return function(i, s) {\n      n(i, s);\n      function o() {\n        this.constructor = i;\n      }\n      i.prototype = s === null ? Object.create(s) : (o.prototype = s.prototype, new o());\n    };\n  }();\n  Object.defineProperty(xr, \"__esModule\", { value: !0 });\n  var e = Vr(), r = function(n) {\n    t(i, n);\n    function i(s, o) {\n      return n.call(this, s, o) || this;\n    }\n    return i;\n  }(e.Event);\n  return xr.CloseEvent = r, xr;\n}\nvar Er = {}, No;\nfunction ld() {\n  if (No)\n    return Er;\n  No = 1;\n  var t = S && S.__extends || function() {\n    var n = function(i, s) {\n      return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(o, a) {\n        o.__proto__ = a;\n      } || function(o, a) {\n        for (var c in a)\n          a.hasOwnProperty(c) && (o[c] = a[c]);\n      }, n(i, s);\n    };\n    return function(i, s) {\n      n(i, s);\n      function o() {\n        this.constructor = i;\n      }\n      i.prototype = s === null ? Object.create(s) : (o.prototype = s.prototype, new o());\n    };\n  }();\n  Object.defineProperty(Er, \"__esModule\", { value: !0 });\n  var e = Vr(), r = function(n) {\n    t(i, n);\n    function i(s, o) {\n      return n.call(this, s, o) || this;\n    }\n    return i;\n  }(e.Event);\n  return Er.MessageEvent = r, Er;\n}\nvar kr = {}, Uo;\nfunction fd() {\n  if (Uo)\n    return kr;\n  Uo = 1;\n  var t = S && S.__extends || function() {\n    var n = function(i, s) {\n      return n = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(o, a) {\n        o.__proto__ = a;\n      } || function(o, a) {\n        for (var c in a)\n          a.hasOwnProperty(c) && (o[c] = a[c]);\n      }, n(i, s);\n    };\n    return function(i, s) {\n      n(i, s);\n      function o() {\n        this.constructor = i;\n      }\n      i.prototype = s === null ? Object.create(s) : (o.prototype = s.prototype, new o());\n    };\n  }();\n  Object.defineProperty(kr, \"__esModule\", { value: !0 });\n  var e = Vr(), r = function(n) {\n    t(i, n);\n    function i(s, o) {\n      return n.call(this, s, o) || this;\n    }\n    return i;\n  }(e.Event);\n  return kr.ErrorEvent = r, kr;\n}\nvar jo;\nfunction hd() {\n  return jo || (jo = 1, function(t) {\n    var e = S && S.__extends || function() {\n      var u = function(h, d) {\n        return u = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(p, y) {\n          p.__proto__ = y;\n        } || function(p, y) {\n          for (var g in y)\n            y.hasOwnProperty(g) && (p[g] = y[g]);\n        }, u(h, d);\n      };\n      return function(h, d) {\n        u(h, d);\n        function p() {\n          this.constructor = h;\n        }\n        h.prototype = d === null ? Object.create(d) : (p.prototype = d.prototype, new p());\n      };\n    }(), r = S && S.__assign || function() {\n      return r = Object.assign || function(u) {\n        for (var h, d = 1, p = arguments.length; d < p; d++) {\n          h = arguments[d];\n          for (var y in h)\n            Object.prototype.hasOwnProperty.call(h, y) && (u[y] = h[y]);\n        }\n        return u;\n      }, r.apply(this, arguments);\n    };\n    Object.defineProperty(t, \"__esModule\", { value: !0 });\n    var n = zh(), i = cd(), s = Vr(), o = ud(), a = ld(), c = fd(), l = function(u) {\n      e(h, u);\n      function h(d, p) {\n        var y = u.call(this) || this;\n        return y.on_ = {}, y.state_ = h.CONNECTING, y.client_ = new n.client(), y.client_.on(\"connect\", y._Handle_connect.bind(y)), y.client_.on(\"connectFailed\", y._Handle_error.bind(y)), typeof p == \"string\" && (p = [p]), y.client_.connect(d, p), y;\n      }\n      return h.prototype.close = function(d, p) {\n        this.state_ = h.CLOSING, d === void 0 ? this.connection_.sendCloseFrame() : this.connection_.sendCloseFrame(d, p, !0);\n      }, h.prototype.send = function(d) {\n        if (typeof d.valueOf() == \"string\")\n          this.connection_.sendUTF(d);\n        else {\n          var p = void 0;\n          d instanceof Buffer ? p = d : d instanceof Blob ? p = new Buffer(d, \"blob\") : d.buffer ? p = new Buffer(d.buffer) : p = new Buffer(d), this.connection_.sendBytes(p);\n        }\n      }, Object.defineProperty(h.prototype, \"url\", {\n        get: function() {\n          return this.client_.url.href;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(h.prototype, \"protocol\", {\n        get: function() {\n          return this.client_.protocols ? this.client_.protocols[0] : \"\";\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(h.prototype, \"extensions\", {\n        get: function() {\n          return this.connection_ && this.connection_.extensions ? this.connection_.extensions[0].name : \"\";\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(h.prototype, \"readyState\", {\n        get: function() {\n          return this.state_;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(h.prototype, \"bufferedAmount\", {\n        get: function() {\n          return this.connection_.bytesWaitingToFlush;\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(h.prototype, \"binaryType\", {\n        get: function() {\n          return \"arraybuffer\";\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(h.prototype, \"onopen\", {\n        get: function() {\n          return this.on_.open;\n        },\n        set: function(d) {\n          this._Set_on(\"open\", d);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(h.prototype, \"onclose\", {\n        get: function() {\n          return this.on_.close;\n        },\n        set: function(d) {\n          this._Set_on(\"close\", d);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(h.prototype, \"onmessage\", {\n        get: function() {\n          return this.on_.message;\n        },\n        set: function(d) {\n          this._Set_on(\"message\", d);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), Object.defineProperty(h.prototype, \"onerror\", {\n        get: function() {\n          return this.on_.error;\n        },\n        set: function(d) {\n          this._Set_on(\"error\", d);\n        },\n        enumerable: !0,\n        configurable: !0\n      }), h.prototype._Set_on = function(d, p) {\n        this.on_[d] && this.removeEventListener(d, this.on_[d]), this.addEventListener(d, p), this.on_[d] = p;\n      }, h.prototype._Handle_connect = function(d) {\n        this.connection_ = d, this.state_ = h.OPEN, this.connection_.on(\"message\", this._Handle_message.bind(this)), this.connection_.on(\"error\", this._Handle_error.bind(this)), this.connection_.on(\"close\", this._Handle_close.bind(this));\n        var p = new s.Event(\"open\", f);\n        this.dispatchEvent(p);\n      }, h.prototype._Handle_close = function(d, p) {\n        var y = new o.CloseEvent(\"close\", r({}, f, { code: d, reason: p }));\n        this.state_ = h.CLOSED, this.dispatchEvent(y);\n      }, h.prototype._Handle_message = function(d) {\n        var p = new a.MessageEvent(\"message\", r({}, f, { data: d.binaryData ? d.binaryData : d.utf8Data }));\n        this.dispatchEvent(p);\n      }, h.prototype._Handle_error = function(d) {\n        var p = new c.ErrorEvent(\"error\", r({}, f, { error: d, message: d.message }));\n        this.state_ === h.CONNECTING && (this.state_ = h.CLOSED), this.dispatchEvent(p);\n      }, h;\n    }(i.EventTarget);\n    t.WebSocket = l, function(u) {\n      u.CONNECTING = 0, u.OPEN = 1, u.CLOSING = 2, u.CLOSED = 3;\n    }(l = t.WebSocket || (t.WebSocket = {})), t.WebSocket = l;\n    var f = {\n      bubbles: !1,\n      cancelable: !1\n    };\n  }(pn)), pn;\n}\nvar dd = cr;\ndd.is_node() && (S.WebSocket = hd().WebSocket);\nBigInt(1e3), BigInt(1e6), BigInt(1e9), BigInt(1e12);\nBigInt(\"2100000000000000000\");\nBigInt(1e11);\nconst Ho = {\n  payment_hash: 1,\n  payment_secret: 16,\n  description: 13,\n  payee: 19,\n  description_hash: 23,\n  expiry: 6,\n  min_final_cltv_expiry: 24,\n  fallback_address: 9,\n  route_hint: 3,\n  feature_bits: 5,\n  metadata: 27\n};\nfor (let t = 0, e = Object.keys(Ho); t < e.length; t++)\n  e[t], Ho[e[t]].toString();\nfunction pd(t, e) {\n  return t.created_at > e.created_at ? t : e;\n}\nvar yd = [\n  \"wss://nos.lol\",\n  \"wss://relay.nostr.band\",\n  \"wss://relay.f7z.io\",\n  \"wss://relay.damus.io\",\n  \"wss://nostr.mom\",\n  \"wss://no.str.cr\"\n], gd = class extends dt {\n  constructor(e) {\n    super();\n    I(this, \"ndk\");\n    I(this, \"zappedEvent\");\n    I(this, \"zappedUser\");\n    this.ndk = e.ndk, this.zappedEvent = e.zappedEvent, this.zappedUser = e.zappedUser || this.ndk.getUser({ hexpubkey: this.zappedEvent.pubkey });\n  }\n  async getZapEndpoint() {\n    let e, r, n, i;\n    if (this.zappedEvent) {\n      const a = (await this.zappedEvent.getMatchingTags(\"zap\"))[0];\n      if (a)\n        switch (a[2]) {\n          case \"lud06\":\n            e = a[1];\n            break;\n          case \"lud16\":\n            r = a[1];\n            break;\n          default:\n            throw new Error(`Unknown zap tag ${a}`);\n        }\n    }\n    if (this.zappedUser && !e && !r && (this.zappedUser.profile || await this.zappedUser.fetchProfile(), e = (this.zappedUser.profile || {}).lud06, r = (this.zappedUser.profile || {}).lud16), r) {\n      const [a, c] = r.split(\"@\");\n      n = `https://${c}/.well-known/lnurlp/${a}`;\n    } else if (e) {\n      const { words: a } = te.decode(e, 1e3), c = te.fromWords(a);\n      n = new TextDecoder(\"utf-8\").decode(c);\n    }\n    if (!n)\n      throw new Error(\"No zap endpoint found\");\n    const o = await (await fetch(n)).json();\n    return (o == null ? void 0 : o.allowsNostr) && ((o == null ? void 0 : o.nostrPubkey) || (o == null ? void 0 : o.nostrPubKey)) && (i = o.callback), i;\n  }\n  async createZapRequest(e, r, n, i) {\n    const s = await this.getZapEndpoint();\n    if (!s)\n      throw new Error(\"No zap endpoint found\");\n    if (!this.zappedEvent)\n      throw new Error(\"No zapped event found\");\n    const o = Ea.makeZapRequest({\n      profile: this.zappedUser.hexpubkey(),\n      event: null,\n      amount: e,\n      comment: r || \"\",\n      relays: i != null ? i : this.relays()\n    });\n    if (this.zappedEvent) {\n      const u = this.zappedEvent.tagReference();\n      u && o.tags.push(u);\n    }\n    o.tags.push([\"lnurl\", s]);\n    const a = new qe(this.ndk, o);\n    n && (a.tags = a.tags.concat(n)), await a.sign();\n    const c = await a.toNostrEvent();\n    return (await (await fetch(\n      `${s}?` + new URLSearchParams({\n        amount: e.toString(),\n        nostr: JSON.stringify(c)\n      })\n    )).json()).pr;\n  }\n  relays() {\n    var r, n;\n    let e = [];\n    return (n = (r = this.ndk) == null ? void 0 : r.pool) != null && n.relays && (e = this.ndk.pool.urls()), e.length || (e = yd), e;\n  }\n};\nfunction bd(t, e = []) {\n  const r = /(@|nostr:)(npub|nprofile|note|nevent)[a-zA-Z0-9]+/g;\n  return t = t.replace(r, (n) => {\n    try {\n      const i = n.split(/(@|nostr:)/)[2], { type: s, data: o } = we.decode(i);\n      let a;\n      switch (s) {\n        case \"npub\":\n          a = [\"p\", o];\n          break;\n        case \"nprofile\":\n          a = [\"p\", o.pubkey];\n          break;\n        case \"nevent\":\n          a = [\"e\", o.id];\n          break;\n        case \"note\":\n          a = [\"e\", o];\n          break;\n        default:\n          return n;\n      }\n      return e.find((c) => c[0] === a[0] && c[1] === a[1]) || e.push(a), `nostr:${i}`;\n    } catch {\n      return n;\n    }\n  }), { content: t, tags: e };\n}\nfunction vd() {\n  if (this.kind === void 0)\n    throw new Error(\"Kind not set\");\n  return this.kind >= 1e4 && this.kind < 2e4;\n}\nfunction wd() {\n  if (this.kind === void 0)\n    throw new Error(\"Kind not set\");\n  return this.kind >= 3e4 && this.kind < 4e4;\n}\nasync function _d() {\n  if (!this.ndk)\n    throw new Error(\"NDK not set\");\n  const t = await this.ndk.fetchEvents({\n    kinds: [3],\n    authors: [this.hexpubkey()]\n  });\n  if (t) {\n    const e = /* @__PURE__ */ new Set();\n    return t.forEach((r) => {\n      r.tags.forEach((n) => {\n        if (n[0] === \"p\")\n          try {\n            const i = we.npubEncode(n[1]);\n            e.add(i);\n          } catch {\n          }\n      });\n    }), [...e].reduce((r, n) => {\n      const i = new pe({ npub: n });\n      return i.ndk = this.ndk, r.add(i), r;\n    }, /* @__PURE__ */ new Set());\n  }\n  return /* @__PURE__ */ new Set();\n}\nfunction md(t, e) {\n  const r = JSON.parse(t.content);\n  return Object.keys(r).forEach((n) => {\n    switch (n) {\n      case \"name\":\n        e.name = r.name;\n        break;\n      case \"display_name\":\n      case \"displayName\":\n        e.displayName = r.displayName || r.display_name;\n        break;\n      case \"image\":\n      case \"picture\":\n        e.image = r.image || r.picture;\n        break;\n      case \"banner\":\n        e.banner = r.banner;\n        break;\n      case \"bio\":\n        e.bio = r.bio;\n        break;\n      case \"nip05\":\n        e.nip05 = r.nip05;\n        break;\n      case \"lud06\":\n        e.lud06 = r.lud06;\n        break;\n      case \"lud16\":\n        e.lud16 = r.lud16;\n        break;\n      case \"about\":\n        e.about = r.about;\n        break;\n      case \"zapService\":\n        e.zapService = r.zapService;\n        break;\n      case \"website\":\n        e.website = r.website;\n        break;\n      default:\n        e[n] = r[n];\n        break;\n    }\n  }), e;\n}\nvar pe = class {\n  constructor(t) {\n    I(this, \"ndk\");\n    I(this, \"profile\");\n    I(this, \"npub\", \"\");\n    I(this, \"relayUrls\", []);\n    I(this, \"follows\", _d.bind(this));\n    t.npub && (this.npub = t.npub), t.hexpubkey && (this.npub = we.npubEncode(t.hexpubkey)), t.relayUrls && (this.relayUrls = t.relayUrls);\n  }\n  static async fromNip05(t) {\n    const e = await _a.queryProfile(t);\n    if (e)\n      return new pe({\n        hexpubkey: e.pubkey,\n        relayUrls: e.relays\n      });\n  }\n  hexpubkey() {\n    return we.decode(this.npub).data;\n  }\n  async fetchProfile(t) {\n    if (!this.ndk)\n      throw new Error(\"NDK not set\");\n    this.profile || (this.profile = {});\n    const e = await this.ndk.fetchEvents(\n      {\n        kinds: [0],\n        authors: [this.hexpubkey()]\n      },\n      t\n    );\n    return e && Array.from(e).sort(\n      (n, i) => n.created_at - i.created_at\n    ).forEach((n) => {\n      try {\n        this.profile = md(n, this.profile);\n      } catch {\n      }\n    }), e;\n  }\n  async relayList() {\n    if (!this.ndk)\n      throw new Error(\"NDK not set\");\n    const t = await this.ndk.fetchEvents({\n      kinds: [10002],\n      authors: [this.hexpubkey()]\n    });\n    return t || /* @__PURE__ */ new Set();\n  }\n  tagReference() {\n    return [\"p\", this.hexpubkey()];\n  }\n  async publish() {\n    if (!this.ndk)\n      throw new Error(\"No NDK instance found\");\n    this.ndk.assertSigner(), await new qe(this.ndk, {\n      kind: 0,\n      content: JSON.stringify(this.profile)\n    }).publish();\n  }\n  async follow(t, e) {\n    if (!this.ndk)\n      throw new Error(\"No NDK instance found\");\n    if (this.ndk.assertSigner(), e || (e = await this.follows()), e.has(t))\n      return !1;\n    e.add(t);\n    const r = new qe(this.ndk, { kind: 3 });\n    for (const n of e)\n      r.tag(n);\n    return await r.publish(), !0;\n  }\n};\nasync function xd(t, e) {\n  if (!e) {\n    if (!this.ndk)\n      throw new Error(\"No signer available\");\n    await this.ndk.assertSigner(), e = this.ndk.signer;\n  }\n  if (!t) {\n    const r = this.getMatchingTags(\"p\");\n    if (r.length !== 1)\n      throw new Error(\"No recipient could be determined and no explicit recipient was provided\");\n    t = new pe({ hexpubkey: r[0][1] }), t.ndk = this.ndk;\n  }\n  this.content = await e.encrypt(t, this.content);\n}\nasync function Ed(t, e) {\n  if (!e) {\n    if (!this.ndk)\n      throw new Error(\"No signer available\");\n    await this.ndk.assertSigner(), e = this.ndk.signer;\n  }\n  t || (t = this.author), this.content = await e.decrypt(t, this.content);\n}\nfunction kd() {\n  return this.isParamReplaceable() ? we.naddrEncode({\n    kind: this.kind,\n    pubkey: this.pubkey,\n    identifier: this.replaceableDTag()\n  }) : we.noteEncode(this.tagId());\n}\nasync function Sd(t = !0, e) {\n  if (!e) {\n    if (!this.ndk)\n      throw new Error(\"No NDK instance found\");\n    this.ndk.assertSigner(), e = this.ndk.signer;\n  }\n  if (!e)\n    throw new Error(\"No signer available\");\n  const r = await e.user(), n = new qe(this.ndk, {\n    kind: Od(this),\n    content: \"\",\n    pubkey: r.hexpubkey()\n  });\n  return n.tag(this), n.kind === 16 && n.tags.push([\"k\", `${this.kind}`]), await n.sign(e), t && await n.publish(), n;\n}\nfunction Od(t) {\n  return t.kind === 1 ? 6 : 16;\n}\nvar qe = class extends dt {\n  constructor(e, r) {\n    super();\n    I(this, \"ndk\");\n    I(this, \"created_at\");\n    I(this, \"content\", \"\");\n    I(this, \"tags\", []);\n    I(this, \"kind\");\n    I(this, \"id\", \"\");\n    I(this, \"sig\");\n    I(this, \"pubkey\", \"\");\n    I(this, \"relay\");\n    I(this, \"isReplaceable\", vd.bind(this));\n    I(this, \"isParamReplaceable\", wd.bind(this));\n    I(this, \"encode\", kd.bind(this));\n    I(this, \"encrypt\", xd.bind(this));\n    I(this, \"decrypt\", Ed.bind(this));\n    I(this, \"repost\", Sd.bind(this));\n    this.ndk = e, this.created_at = r == null ? void 0 : r.created_at, this.content = (r == null ? void 0 : r.content) || \"\", this.tags = (r == null ? void 0 : r.tags) || [], this.id = (r == null ? void 0 : r.id) || \"\", this.sig = r == null ? void 0 : r.sig, this.pubkey = (r == null ? void 0 : r.pubkey) || \"\", this.kind = r == null ? void 0 : r.kind;\n  }\n  rawEvent() {\n    return {\n      created_at: this.created_at,\n      content: this.content,\n      tags: this.tags,\n      kind: this.kind,\n      pubkey: this.pubkey,\n      id: this.id,\n      sig: this.sig\n    };\n  }\n  set author(e) {\n    this.pubkey = e.hexpubkey();\n  }\n  get author() {\n    const e = new pe({ hexpubkey: this.pubkey });\n    return e.ndk = this.ndk, e;\n  }\n  tag(e, r) {\n    const n = e.tagReference();\n    if (r && n.push(r), this.tags.push(n), e instanceof qe) {\n      const i = e.author;\n      i && this.pubkey !== i.hexpubkey() && this.tag(i);\n      for (const s of e.getMatchingTags(\"p\"))\n        s[1] !== this.pubkey && (this.tags.find((o) => o[0] === \"p\" && o[1] === s[1]) || this.tags.push([\"p\", s[1]]));\n    }\n  }\n  async toNostrEvent(e) {\n    var s, o;\n    if (!e && this.pubkey === \"\") {\n      const a = await ((o = (s = this.ndk) == null ? void 0 : s.signer) == null ? void 0 : o.user());\n      this.pubkey = (a == null ? void 0 : a.hexpubkey()) || \"\";\n    }\n    this.created_at || (this.created_at = Math.floor(Date.now() / 1e3));\n    const r = this.rawEvent(), { content: n, tags: i } = this.generateTags();\n    r.content = n || \"\", r.tags = i;\n    try {\n      this.id = Hr(r);\n    } catch {\n    }\n    return this.id && (r.id = this.id), this.sig && (r.sig = this.sig), r;\n  }\n  getMatchingTags(e) {\n    return this.tags.filter((r) => r[0] === e);\n  }\n  tagValue(e) {\n    const r = this.getMatchingTags(e);\n    if (r.length !== 0)\n      return r[0][1];\n  }\n  removeTag(e) {\n    this.tags = this.tags.filter((r) => r[0] !== e);\n  }\n  async sign(e) {\n    var n;\n    e || ((n = this.ndk) == null || n.assertSigner(), e = this.ndk.signer), await this.generateTags(), this.isReplaceable() && (this.created_at = Math.floor(Date.now() / 1e3));\n    const r = await this.toNostrEvent();\n    return this.sig = await e.sign(r), this.sig;\n  }\n  async publish(e, r) {\n    if (this.sig || await this.sign(), !this.ndk)\n      throw new Error(\"NDKEvent must be associated with an NDK instance to publish\");\n    return this.ndk.publish(this, e, r);\n  }\n  generateTags() {\n    let e = [];\n    const r = bd(this.content, this.tags), n = r.content;\n    if (e = r.tags, this.kind && this.kind >= 3e4 && this.kind <= 4e4 && !this.getMatchingTags(\"d\")[0]) {\n      const s = [...Array(16)].map(() => Math.random().toString(36)[2]).join(\"\");\n      e.push([\"d\", s]);\n    }\n    return { content: n || \"\", tags: e };\n  }\n  replaceableDTag() {\n    if (this.kind && this.kind >= 3e4 && this.kind <= 4e4) {\n      const e = this.getMatchingTags(\"d\")[0];\n      return e ? e[1] : \"\";\n    }\n    throw new Error(\"Event is not a parameterized replaceable event\");\n  }\n  tagId() {\n    if (this.kind && this.kind >= 3e4 && this.kind <= 4e4) {\n      const e = this.replaceableDTag();\n      return `${this.kind}:${this.pubkey}:${e}`;\n    }\n    return this.id;\n  }\n  tagReference() {\n    return this.isParamReplaceable() ? [\"a\", this.tagId()] : [\"e\", this.tagId()];\n  }\n  filter() {\n    return this.isParamReplaceable() ? { \"#a\": [this.tagId()] } : { \"#e\": [this.tagId()] };\n  }\n  async zap(e, r, n) {\n    if (!this.ndk)\n      throw new Error(\"No NDK instance found\");\n    return this.ndk.assertSigner(), await new gd({\n      ndk: this.ndk,\n      zappedEvent: this\n    }).createZapRequest(e, r, n);\n  }\n  async delete(e) {\n    if (!this.ndk)\n      throw new Error(\"No NDK instance found\");\n    this.ndk.assertSigner();\n    const r = new qe(this.ndk, {\n      kind: 5,\n      content: e || \"\"\n    });\n    return r.tag(this), await r.publish(), r;\n  }\n}, Ad = class extends dt {\n  constructor(e) {\n    super();\n    I(this, \"url\");\n    I(this, \"scores\");\n    I(this, \"relay\");\n    I(this, \"_status\");\n    I(this, \"connectedAt\");\n    I(this, \"_connectionStats\", { attempts: 0, success: 0, durations: [] });\n    I(this, \"complaining\", !1);\n    I(this, \"debug\");\n    I(this, \"activeSubscriptions\", /* @__PURE__ */ new Set());\n    I(this, \"updateConnectionStats\", {\n      connected: () => {\n        this._connectionStats.success++, this._connectionStats.connectedAt = Date.now();\n      },\n      disconnected: () => {\n        this._connectionStats.connectedAt && (this._connectionStats.durations.push(\n          Date.now() - this._connectionStats.connectedAt\n        ), this._connectionStats.durations.length > 100 && this._connectionStats.durations.shift()), this._connectionStats.connectedAt = void 0;\n      },\n      attempt: () => {\n        this._connectionStats.attempts++;\n      }\n    });\n    this.url = e, this.relay = Af(e), this.scores = /* @__PURE__ */ new Map(), this._status = 3, this.debug = Mn(`ndk:relay:${e}`), this.relay.on(\"connect\", () => {\n      this.updateConnectionStats.connected(), this._status = 1, this.emit(\"connect\");\n    }), this.relay.on(\"disconnect\", () => {\n      this.updateConnectionStats.disconnected(), this._status === 1 && (this._status = 3, this.handleReconnection()), this.emit(\"disconnect\");\n    }), this.relay.on(\"notice\", (r) => this.handleNotice(r));\n  }\n  isFlapping() {\n    const e = this._connectionStats.durations;\n    if (e.length < 10)\n      return !1;\n    const n = e.reduce((a, c) => a + c, 0) / e.length, i = e.map((a) => Math.pow(a - n, 2)).reduce((a, c) => a + c, 0) / e.length;\n    return Math.sqrt(i) < 1e3;\n  }\n  handleReconnection() {\n    this.isFlapping() && (this.emit(\"flapping\", this, this._connectionStats), this._status = 5), this.connectedAt && Date.now() - this.connectedAt < 5e3 ? setTimeout(() => this.connect(), 6e4) : this.connect();\n  }\n  get status() {\n    return this._status;\n  }\n  async connect() {\n    try {\n      this.updateConnectionStats.attempt(), this._status = 0, await this.relay.connect();\n    } catch (e) {\n      throw this.debug(\"Failed to connect\", e), this._status = 3, e;\n    }\n  }\n  disconnect() {\n    this._status = 2, this.relay.close();\n  }\n  async handleNotice(e) {\n    (e.includes(\"oo many\") || e.includes(\"aximum\")) && (this.disconnect(), setTimeout(() => this.connect(), 2e3), this.debug(this.relay.url, \"Relay complaining?\", e)), this.emit(\"notice\", this, e);\n  }\n  subscribe(e) {\n    const { filter: r } = e, n = this.relay.sub([r], {\n      id: e.subId\n    });\n    this.debug(`Subscribed to ${JSON.stringify(r)}`), n.on(\"event\", (s) => {\n      const o = new qe(void 0, s);\n      o.relay = this, e.eventReceived(o, this);\n    }), n.on(\"eose\", () => {\n      e.eoseReceived(this);\n    });\n    const i = n.unsub;\n    return n.unsub = () => {\n      this.debug(`Unsubscribing from ${JSON.stringify(r)}`), this.activeSubscriptions.delete(e), i();\n    }, this.activeSubscriptions.add(e), e.on(\"close\", () => {\n      this.activeSubscriptions.delete(e);\n    }), n;\n  }\n  async publish(e, r = 2500) {\n    return this.status === 1 ? this.publishEvent(e, r) : (this.once(\"connect\", () => {\n      this.publishEvent(e, r);\n    }), !0);\n  }\n  async publishEvent(e, r) {\n    const n = await e.toNostrEvent(), i = this.relay.publish(n);\n    let s;\n    const o = new Promise((c, l) => {\n      i.on(\"failed\", (f) => {\n        clearTimeout(s), this.debug(\"Publish failed\", f, e.id), this.emit(\"publish:failed\", e, f), l(f);\n      }), i.on(\"ok\", () => {\n        clearTimeout(s), this.emit(\"published\", e), c(!0);\n      });\n    });\n    if (!r)\n      return o;\n    const a = new Promise((c, l) => {\n      s = setTimeout(() => {\n        this.debug(\"Publish timed out\", e.rawEvent()), this.emit(\"publish:failed\", e, \"Timeout\"), l(new Error(\"Publish operation timed out\"));\n      }, r);\n    });\n    return Promise.race([o, a]);\n  }\n  scoreSlowerEvent(e) {\n  }\n  get connectionStats() {\n    return this._connectionStats;\n  }\n  tagReference(e) {\n    const r = [\"r\", this.relay.url];\n    return e && r.push(e), r;\n  }\n}, Cd = class extends dt {\n  constructor(e = [], r) {\n    super();\n    I(this, \"relays\", /* @__PURE__ */ new Map());\n    I(this, \"debug\");\n    this.debug = r.debug.extend(\"pool\");\n    for (const n of e) {\n      const i = new Ad(n);\n      i.on(\"notice\", (s, o) => this.emit(\"notice\", s, o)), i.on(\"connect\", () => this.handleRelayConnect(n)), i.on(\"disconnect\", () => this.emit(\"relay:disconnect\", i)), i.on(\"flapping\", () => this.handleFlapping(i)), this.relays.set(n, i);\n    }\n  }\n  handleRelayConnect(e) {\n    this.debug(`Relay ${e} connected`), this.emit(\"relay:connect\", this.relays.get(e)), this.stats().connected === this.relays.size && this.emit(\"connect\");\n  }\n  async connect(e) {\n    const r = [];\n    this.debug(\n      `Connecting to ${this.relays.size} relays${e ? `, timeout ${e}...` : \"\"}`\n    );\n    for (const n of this.relays.values())\n      if (e) {\n        const i = new Promise((s, o) => {\n          setTimeout(() => o(`Timed out after ${e}ms`), e);\n        });\n        r.push(\n          Promise.race([n.connect(), i]).catch((s) => {\n            this.debug(`Failed to connect to relay ${n.url}: ${s}`);\n          })\n        );\n      } else\n        r.push(n.connect());\n    e && setTimeout(() => {\n      const n = this.stats().connected === this.relays.size, i = this.stats().connected > 0;\n      !n && i && this.emit(\"connect\");\n    }, e), await Promise.all(r);\n  }\n  handleFlapping(e) {\n    this.debug(`Relay ${e.url} is flapping`), this.relays.delete(e.url), this.emit(\"flapping\", e);\n  }\n  size() {\n    return this.relays.size;\n  }\n  stats() {\n    const e = {\n      total: 0,\n      connected: 0,\n      disconnected: 0,\n      connecting: 0\n    };\n    for (const r of this.relays.values())\n      e.total++, r.status === 1 ? e.connected++ : r.status === 3 ? e.disconnected++ : r.status === 0 && e.connecting++;\n    return e;\n  }\n  urls() {\n    return Array.from(this.relays.keys());\n  }\n};\nfunction Id(t) {\n  return !!(Rd(t.filter) && Td(t));\n}\nfunction Rd(t) {\n  return !!t.ids;\n}\nfunction Td(t) {\n  const e = t.filter.ids;\n  return !!e && e.length === t.eventFirstSeen.size;\n}\nvar Pd = {\n  closeOnEose: !0,\n  cacheUsage: \"CACHE_FIRST\",\n  groupable: !0,\n  groupableDelay: 100\n}, Pa = class extends dt {\n  constructor(e, r, n, i, s) {\n    super();\n    I(this, \"subId\");\n    I(this, \"filter\");\n    I(this, \"opts\");\n    I(this, \"relaySet\");\n    I(this, \"ndk\");\n    I(this, \"relaySubscriptions\");\n    I(this, \"debug\");\n    I(this, \"eventFirstSeen\", /* @__PURE__ */ new Map());\n    I(this, \"eosesSeen\", /* @__PURE__ */ new Set());\n    I(this, \"eventsPerRelay\", /* @__PURE__ */ new Map());\n    I(this, \"eoseTimeout\");\n    if (this.ndk = e, this.opts = { ...Pd, ...n || {} }, this.subId = s || (n == null ? void 0 : n.subId) || qd(r), this.filter = r, this.relaySet = i, this.relaySubscriptions = /* @__PURE__ */ new Map(), this.debug = e.debug.extend(`subscription:${this.subId}`), this.opts.cacheUsage === \"ONLY_CACHE\" && !this.opts.closeOnEose)\n      throw new Error(\"Cannot use cache-only options with a persistent subscription\");\n  }\n  groupableId() {\n    var i, s;\n    if (!((i = this.opts) != null && i.groupable))\n      return null;\n    const e = (((s = this.filter.kinds) == null ? void 0 : s.length) || 0) > 0, r = !this.filter.since && !this.filter.until, n = !this.filter.limit;\n    if (e && r && n) {\n      let o = this.filter.kinds.join(\",\");\n      const a = Object.keys(this.filter || {}).sort().join(\"-\");\n      return o += `-${a}`, o;\n    }\n    return null;\n  }\n  shouldQueryCache() {\n    var e;\n    return ((e = this.opts) == null ? void 0 : e.cacheUsage) !== \"ONLY_RELAY\";\n  }\n  shouldQueryRelays() {\n    var e;\n    return ((e = this.opts) == null ? void 0 : e.cacheUsage) !== \"ONLY_CACHE\";\n  }\n  shouldWaitForCache() {\n    var e;\n    return this.opts.closeOnEose && !!((e = this.ndk.cacheAdapter) != null && e.locking) && this.shouldQueryRelays() && this.opts.cacheUsage !== \"PARALLEL\";\n  }\n  async start() {\n    let e;\n    if (this.shouldQueryCache() && (e = this.startWithCache(), this.shouldWaitForCache() && (await e, Id(this)))) {\n      this.debug(\"cache hit, fully filled: skipping relay query\"), this.emit(\"eose\", this);\n      return;\n    }\n    this.shouldQueryRelays() && this.startWithRelaySet();\n  }\n  stop() {\n    this.relaySubscriptions.forEach((e) => e.unsub()), this.relaySubscriptions.clear(), this.emit(\"close\", this);\n  }\n  async startWithCache() {\n    var e;\n    if ((e = this.ndk.cacheAdapter) != null && e.query) {\n      const r = this.ndk.cacheAdapter.query(this);\n      this.ndk.cacheAdapter.locking && await r;\n    }\n  }\n  startWithRelaySet() {\n    this.relaySet || (this.relaySet = Ud(this.ndk, this.filter)), this.relaySet && this.relaySet.subscribe(this);\n  }\n  eventReceived(e, r, n = !1) {\n    if (!n && r) {\n      let i = this.eventsPerRelay.get(r);\n      if (i || (i = /* @__PURE__ */ new Set(), this.eventsPerRelay.set(r, i)), i.add(e.id), this.eventFirstSeen.has(e.id)) {\n        const o = Date.now() - (this.eventFirstSeen.get(e.id) || 0);\n        r.scoreSlowerEvent(o), this.emit(\"event:dup\", e, r, o, this);\n        return;\n      }\n      this.ndk.cacheAdapter && this.ndk.cacheAdapter.setEvent(e, this.filter), this.eventFirstSeen.set(`${e.id}`, Date.now());\n    } else\n      this.eventFirstSeen.set(`${e.id}`, 0);\n    this.emit(\"event\", e, r, this);\n  }\n  eoseReceived(e) {\n    var n, i, s;\n    (n = this.opts) != null && n.closeOnEose && ((i = this.relaySubscriptions.get(e)) == null || i.unsub(), this.relaySubscriptions.delete(e), this.relaySubscriptions.size === 0 && this.emit(\"close\", this)), this.eosesSeen.add(e), this.eosesSeen.size === ((s = this.relaySet) == null ? void 0 : s.size()) ? this.emit(\"eose\") : (this.eoseTimeout && clearTimeout(this.eoseTimeout), this.eoseTimeout = setTimeout(() => {\n      this.emit(\"eose\");\n    }, 500));\n  }\n}, Bd = class extends Pa {\n  constructor(e, r) {\n    const n = e.debug.extend(\"subscription-group\"), i = Ld(r.map((s) => s.filter));\n    super(\n      e,\n      i,\n      r[0].opts,\n      r[0].relaySet\n    );\n    I(this, \"subscriptions\");\n    this.subscriptions = r, n(\"merged filters\", {\n      count: r.length,\n      mergedFilters: this.filter\n    }), this.on(\"event\", this.forwardEvent), this.on(\"event:dup\", this.forwardEventDup), this.on(\"eose\", this.forwardEose), this.on(\"close\", this.forwardClose);\n  }\n  isEventForSubscription(e, r) {\n    const { filter: n } = r;\n    return n ? ya(n, e.rawEvent()) : !1;\n  }\n  forwardEvent(e, r) {\n    for (const n of this.subscriptions)\n      !this.isEventForSubscription(e, n) || n.emit(\"event\", e, r, n);\n  }\n  forwardEventDup(e, r, n) {\n    for (const i of this.subscriptions)\n      !this.isEventForSubscription(e, i) || i.emit(\"event:dup\", e, r, n, i);\n  }\n  forwardEose() {\n    for (const e of this.subscriptions)\n      e.emit(\"eose\", e);\n  }\n  forwardClose() {\n    for (const e of this.subscriptions)\n      e.emit(\"close\", e);\n  }\n};\nfunction Ld(t) {\n  const e = {};\n  return t.forEach((r) => {\n    Object.entries(r).forEach(([n, i]) => {\n      Array.isArray(i) ? e[n] === void 0 ? e[n] = [...i] : e[n] = Array.from(/* @__PURE__ */ new Set([...e[n], ...i])) : e[n] = i;\n    });\n  }), e;\n}\nfunction $d(t) {\n  let e;\n  try {\n    switch (e = we.decode(t), e.type) {\n      case \"nevent\":\n        return { ids: [e.data.id] };\n      case \"note\":\n        return { ids: [e.data] };\n      case \"naddr\":\n        return {\n          authors: [e.data.pubkey],\n          \"#d\": [e.data.identifier],\n          kinds: [e.data.kind]\n        };\n    }\n  } catch {\n  }\n  return { ids: [t] };\n}\nfunction qd(t) {\n  const e = Object.keys(t) || [], r = [];\n  for (const n of e)\n    if (n === \"kinds\") {\n      const i = [n, t.kinds.join(\",\")];\n      r.push(i.join(\":\"));\n    } else\n      r.push(n);\n  return r.push(Math.floor(Math.random() * 999999999).toString()), r.join(\"-\");\n}\nvar Gr = class {\n  constructor(t, e) {\n    I(this, \"relays\");\n    I(this, \"debug\");\n    I(this, \"ndk\");\n    this.relays = t, this.ndk = e, this.debug = e.debug.extend(\"relayset\");\n  }\n  static fromRelayUrls(t, e) {\n    const r = /* @__PURE__ */ new Set();\n    for (const n of t) {\n      const i = e.pool.relays.get(n);\n      i && r.add(i);\n    }\n    return new Gr(new Set(r), e);\n  }\n  subscribeOnRelay(t, e) {\n    const r = t.subscribe(e);\n    e.relaySubscriptions.set(t, r);\n  }\n  getId() {\n    const e = Array.from(this.relays).map((r) => r.url).sort().join(\",\");\n    return ni(jr(e));\n  }\n  subscribe(t) {\n    const e = t.groupableId(), r = `${this.getId()}:${e}`;\n    if (!e)\n      return this.executeSubscription(t), t;\n    const n = this.ndk.delayedSubscriptions.get(r);\n    return n ? n.push(t) : (setTimeout(() => {\n      this.executeDelayedSubscription(r);\n    }, t.opts.groupableDelay), this.ndk.delayedSubscriptions.set(r, [t])), t;\n  }\n  executeDelayedSubscription(t) {\n    const e = this.ndk.delayedSubscriptions.get(t);\n    this.ndk.delayedSubscriptions.delete(t), e && (e.length > 1 ? this.executeSubscriptions(e) : this.executeSubscription(e[0]));\n  }\n  executeSubscriptions(t) {\n    const e = t[0].ndk, r = new Bd(e, t);\n    this.executeSubscription(r);\n  }\n  executeSubscription(t) {\n    this.debug(\"subscribing\", { filter: t.filter });\n    for (const e of this.relays)\n      if (e.status === 1)\n        this.subscribeOnRelay(e, t);\n      else {\n        const r = () => {\n          this.debug(\"new relay coming online for active subscription\", {\n            relay: e.url,\n            filter: t.filter\n          }), this.subscribeOnRelay(e, t);\n        };\n        e.once(\"connect\", r), t.once(\"close\", () => {\n          e.removeListener(\"connect\", r);\n        });\n      }\n    return t;\n  }\n  async publish(t, e) {\n    const r = /* @__PURE__ */ new Set(), n = Array.from(this.relays).map((i) => new Promise((s) => {\n      i.publish(t, e).then(() => {\n        r.add(i), s();\n      }).catch((o) => {\n        this.debug(\"error publishing to relay\", { relay: i.url, err: o }), s();\n      });\n    }));\n    if (await Promise.all(n), r.size === 0)\n      throw new Error(\"No relay was able to receive the event\");\n    return r;\n  }\n  size() {\n    return this.relays.size;\n  }\n};\nfunction Nd(t, e) {\n  var n;\n  const r = /* @__PURE__ */ new Set();\n  return (n = t.pool) == null || n.relays.forEach((i) => r.add(i)), new Gr(r, t);\n}\nfunction Ud(t, e) {\n  var n;\n  const r = /* @__PURE__ */ new Set();\n  return (n = t.pool) == null || n.relays.forEach((i) => {\n    i.complaining ? t.debug(`Relay ${i.url} is complaining, not adding to set`) : r.add(i);\n  }), new Gr(r, t);\n}\nvar jd = class {\n  constructor() {\n    I(this, \"_userPromise\");\n    I(this, \"nip04Queue\", []);\n    I(this, \"nip04Processing\", !1);\n    I(this, \"debug\");\n    if (!window.nostr)\n      throw new Error(\"NIP-07 extension not available\");\n    this.debug = Mn(\"ndk:nip07\");\n  }\n  async blockUntilReady() {\n    var e;\n    const t = await ((e = window.nostr) == null ? void 0 : e.getPublicKey());\n    if (!t)\n      throw new Error(\"User rejected access\");\n    return new pe({ hexpubkey: t });\n  }\n  async user() {\n    return this._userPromise || (this._userPromise = this.blockUntilReady()), this._userPromise;\n  }\n  async sign(t) {\n    if (!window.nostr)\n      throw new Error(\"NIP-07 extension not available\");\n    return (await window.nostr.signEvent(t)).sig;\n  }\n  async encrypt(t, e) {\n    if (!window.nostr)\n      throw new Error(\"NIP-07 extension not available\");\n    const r = t.hexpubkey();\n    return this.queueNip04(\"encrypt\", r, e);\n  }\n  async decrypt(t, e) {\n    if (!window.nostr)\n      throw new Error(\"NIP-07 extension not available\");\n    const r = t.hexpubkey();\n    return this.queueNip04(\"decrypt\", r, e);\n  }\n  async queueNip04(t, e, r) {\n    return new Promise((n, i) => {\n      this.nip04Queue.push({ type: t, counterpartyHexpubkey: e, value: r, resolve: n, reject: i }), this.nip04Processing || this.processNip04Queue();\n    });\n  }\n  async processNip04Queue(t, e = 0) {\n    if (!t && this.nip04Queue.length === 0) {\n      this.nip04Processing = !1;\n      return;\n    }\n    this.nip04Processing = !0;\n    const { type: r, counterpartyHexpubkey: n, value: i, resolve: s, reject: o } = t || this.nip04Queue.shift();\n    this.debug(\"Processing encryption queue item\", { type: r, counterpartyHexpubkey: n, value: i });\n    try {\n      let a;\n      r === \"encrypt\" ? a = await window.nostr.nip04.encrypt(n, i) : a = await window.nostr.nip04.decrypt(n, i), s(a);\n    } catch (a) {\n      if (a.message && a.message.includes(\"call already executing\") && e < 5) {\n        this.debug(\"Retrying encryption queue item\", { type: r, counterpartyHexpubkey: n, value: i, retries: e }), setTimeout(() => {\n          this.processNip04Queue(t, e + 1);\n        }, 50 * e);\n        return;\n      }\n      o(a);\n    }\n    this.processNip04Queue();\n  }\n}, Hd = class extends dt {\n  constructor(e, r, n) {\n    super();\n    I(this, \"ndk\");\n    I(this, \"signer\");\n    I(this, \"debug\");\n    this.ndk = e, this.signer = r, this.debug = n.extend(\"rpc\");\n  }\n  async subscribe(e) {\n    const r = this.ndk.subscribe(e, { closeOnEose: !1 });\n    return r.on(\"event\", async (n) => {\n      try {\n        const i = await this.parseEvent(n);\n        i.method ? this.emit(\"request\", i) : this.emit(`response-${i.id}`, i);\n      } catch (i) {\n        this.debug(\"error parsing event\", i, n);\n      }\n    }), new Promise((n, i) => {\n      r.on(\"eose\", () => n(r));\n    });\n  }\n  async parseEvent(e) {\n    const r = this.ndk.getUser({ hexpubkey: e.pubkey });\n    r.ndk = this.ndk;\n    const n = await this.signer.decrypt(r, e.content), i = JSON.parse(n), { id: s, method: o, params: a, result: c, error: l } = i;\n    return o ? { id: s, pubkey: e.pubkey, method: o, params: a, event: e } : { id: s, result: c, error: l, event: e };\n  }\n  async sendResponse(e, r, n, i = 24133, s) {\n    const o = { id: e, result: n };\n    s && (o.error = s);\n    const a = await this.signer.user(), c = this.ndk.getUser({ hexpubkey: r }), l = new qe(this.ndk, {\n      kind: i,\n      content: JSON.stringify(o),\n      tags: [[\"p\", r]],\n      pubkey: a.hexpubkey()\n    });\n    l.content = await this.signer.encrypt(c, l.content), await l.sign(this.signer), await this.ndk.publish(l);\n  }\n  async sendRequest(e, r, n = [], i = 24133, s) {\n    const o = Math.random().toString(36).substring(7), a = await this.signer.user(), c = this.ndk.getUser({ hexpubkey: e }), l = { id: o, method: r, params: n }, f = new Promise((h) => {\n      s && this.once(`response-${o}`, s);\n    }), u = new qe(this.ndk, {\n      kind: i,\n      content: JSON.stringify(l),\n      tags: [[\"p\", e]],\n      pubkey: a.hexpubkey()\n    });\n    return u.content = await this.signer.encrypt(c, u.content), await u.sign(this.signer), this.debug(\"sending request to\", e), await this.ndk.publish(u), f;\n  }\n}, Md = class {\n  constructor(t, e, r) {\n    I(this, \"ndk\");\n    I(this, \"remoteUser\");\n    I(this, \"remotePubkey\");\n    I(this, \"token\");\n    I(this, \"localSigner\");\n    I(this, \"rpc\");\n    I(this, \"debug\");\n    let n, i;\n    if (e.includes(\"#\")) {\n      const s = e.split(\"#\");\n      n = new pe({ npub: s[0] }).hexpubkey(), i = s[1];\n    } else\n      e.startsWith(\"npub\") ? n = new pe({ npub: e }).hexpubkey() : n = e;\n    this.ndk = t, this.remotePubkey = n, this.token = i, this.debug = t.debug.extend(\"nip46:signer\"), this.remoteUser = new pe({ hexpubkey: n }), r ? this.localSigner = r : this.localSigner = or.generate(), this.rpc = new Hd(t, this.localSigner, this.debug);\n  }\n  async user() {\n    return this.remoteUser;\n  }\n  async blockUntilReady() {\n    const t = await this.localSigner.user(), e = this.ndk.getUser({ npub: t.npub });\n    return await this.rpc.subscribe({\n      kinds: [24133],\n      \"#p\": [t.hexpubkey()]\n    }), new Promise((r, n) => {\n      setTimeout(() => {\n        const i = [t.hexpubkey()];\n        this.token && i.push(this.token), this.rpc.sendRequest(\n          this.remotePubkey,\n          \"connect\",\n          i,\n          24133,\n          (s) => {\n            s.result === \"ack\" ? r(e) : n(s.error);\n          }\n        );\n      }, 100);\n    });\n  }\n  async encrypt(t, e) {\n    return this.debug(\"asking for encryption\"), new Promise((n, i) => {\n      this.rpc.sendRequest(\n        this.remotePubkey,\n        \"nip04_encrypt\",\n        [t.hexpubkey(), e],\n        24133,\n        (s) => {\n          s.error ? i(s.error) : n(s.result);\n        }\n      );\n    });\n  }\n  async decrypt(t, e) {\n    return this.debug(\"asking for decryption\"), new Promise((n, i) => {\n      this.rpc.sendRequest(\n        this.remotePubkey,\n        \"nip04_decrypt\",\n        [t.hexpubkey(), e],\n        24133,\n        (s) => {\n          if (s.error)\n            i(s.error);\n          else {\n            const o = JSON.parse(s.result);\n            n(o[0]);\n          }\n        }\n      );\n    });\n  }\n  async sign(t) {\n    return this.debug(\"asking for a signature\"), new Promise((r, n) => {\n      this.rpc.sendRequest(\n        this.remotePubkey,\n        \"sign_event\",\n        [JSON.stringify(t)],\n        24133,\n        (i) => {\n          if (this.debug(\"got a response\", i), i.error)\n            n(i.error);\n          else {\n            const s = JSON.parse(i.result);\n            r(s.sig);\n          }\n        }\n      );\n    });\n  }\n}, or = class {\n  constructor(t) {\n    I(this, \"_user\");\n    I(this, \"privateKey\");\n    t && (this.privateKey = t, this._user = new pe({ hexpubkey: li(this.privateKey) }));\n  }\n  static generate() {\n    const t = yf();\n    return new or(t);\n  }\n  async blockUntilReady() {\n    if (!this._user)\n      throw new Error(\"NDKUser not initialized\");\n    return this._user;\n  }\n  async user() {\n    return await this.blockUntilReady(), this._user;\n  }\n  async sign(t) {\n    if (!this.privateKey)\n      throw Error(\"Attempted to sign without a private key\");\n    return pa(t, this.privateKey);\n  }\n  async encrypt(t, e) {\n    if (!this.privateKey)\n      throw Error(\"Attempted to encrypt without a private key\");\n    const r = t.hexpubkey();\n    return await Un.encrypt(this.privateKey, r, e);\n  }\n  async decrypt(t, e) {\n    if (!this.privateKey)\n      throw Error(\"Attempted to decrypt without a private key\");\n    const r = t.hexpubkey();\n    return await Un.decrypt(this.privateKey, r, e);\n  }\n}, Dd = class extends dt {\n  constructor(e = {}) {\n    super();\n    I(this, \"pool\");\n    I(this, \"signer\");\n    I(this, \"cacheAdapter\");\n    I(this, \"debug\");\n    I(this, \"devWriteRelaySet\");\n    I(this, \"delayedSubscriptions\");\n    this.debug = e.debug || Mn(\"ndk\"), this.pool = new Cd(e.explicitRelayUrls || [], this), this.signer = e.signer, this.cacheAdapter = e.cacheAdapter, this.delayedSubscriptions = /* @__PURE__ */ new Map(), e.devWriteRelayUrls && (this.devWriteRelaySet = Gr.fromRelayUrls(e.devWriteRelayUrls, this));\n  }\n  toJSON() {\n    return { relayCount: this.pool.relays.size }.toString();\n  }\n  async connect(e) {\n    return this.debug(\"Connecting to relays\", { timeoutMs: e }), this.pool.connect(e);\n  }\n  getUser(e) {\n    const r = new pe(e);\n    return r.ndk = this, r;\n  }\n  subscribe(e, r, n, i = !0) {\n    const s = new Pa(this, e, r, n);\n    return i && s.start(), s;\n  }\n  async publish(e, r, n) {\n    return r || (r = this.devWriteRelaySet || Nd(this)), r.publish(e, n);\n  }\n  async fetchEvent(e, r = {}, n) {\n    let i;\n    if (typeof e == \"string\" ? i = $d(e) : i = e, !i)\n      throw new Error(`Invalid filter: ${JSON.stringify(e)}`);\n    return new Promise((s) => {\n      const o = this.subscribe(i, { ...r, closeOnEose: !0 }, n, !1);\n      o.on(\"event\", (a) => {\n        a.ndk = this, s(a);\n      }), o.on(\"eose\", () => {\n        s(null);\n      }), o.start();\n    });\n  }\n  async fetchEvents(e, r = {}, n) {\n    return new Promise((i) => {\n      const s = /* @__PURE__ */ new Map(), o = this.subscribe(e, { ...r, closeOnEose: !0 }, n, !1);\n      o.on(\"event\", (a) => {\n        const c = s.get(a.tagId());\n        c && (a = pd(c, a)), a.ndk = this, s.set(a.tagId(), a);\n      }), o.on(\"eose\", () => {\n        i(new Set(s.values()));\n      }), o.start();\n    });\n  }\n  async assertSigner() {\n    if (!this.signer)\n      throw this.emit(\"signerRequired\"), new Error(\"Signer required\");\n  }\n};\nfunction zd(t) {\n  const e = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(!1), [r, n] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0), [i, s] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    async function f() {\n      r === void 0 && e.current === !1 && (e.current = !0, await o(t));\n    }\n    f();\n  }, []);\n  async function o(f, u) {\n    const h = new Dd({ explicitRelayUrls: f, signer: u });\n    u && s(u);\n    try {\n      await h.connect(), n(h);\n    } catch (d) {\n      console.error(\"ERROR loading NDK NDKInstance\", d);\n    }\n  }\n  async function a(f) {\n    o(t, f);\n  }\n  async function c(f) {\n    return r === void 0 ? [] : new Promise((u) => {\n      const h = /* @__PURE__ */ new Map(), d = r.subscribe(f, {\n        closeOnEose: !0\n      });\n      d.on(\"event\", (p) => {\n        p.ndk = r, h.set(p.tagId(), p);\n      }), d.on(\"eose\", () => {\n        setTimeout(() => u(Array.from(new Set(h.values()))), 3e3);\n      });\n    });\n  }\n  async function l(f, u = {\n    repost: !1,\n    publish: !0\n  }) {\n    if (r !== void 0)\n      return f.ndk = r, u.repost ? await f.repost() : await f.sign(), u.publish && await f.publish(), f;\n  }\n  return {\n    ndk: r,\n    signer: i,\n    loadNdk: o,\n    setSigner: a,\n    fetchEvents: c,\n    signPublishEvent: l\n  };\n}\nasync function Fd(t) {\n  try {\n    let e = t;\n    e.substring(0, 4) === \"nsec\" && (e = we.decode(e).data);\n    const r = new or(e);\n    return r.user().then(async (n) => {\n      if (n.npub)\n        return {\n          user: n,\n          npub: n.npub,\n          sk: e,\n          signer: r\n        };\n    });\n  } catch (e) {\n    throw e;\n  }\n}\nasync function Kd(t, e, r) {\n  try {\n    let n = or.generate();\n    r && (n = new or(r));\n    const i = new Md(t, e, n);\n    return i.user().then(async (s) => {\n      if (s.npub)\n        return await i.blockUntilReady(), {\n          user: s,\n          npub: (await i.user()).npub,\n          sk: n.privateKey,\n          token: e,\n          remoteSigner: i,\n          localSigner: n\n        };\n    });\n  } catch (n) {\n    throw n;\n  }\n}\nasync function Wd() {\n  try {\n    const t = new jd();\n    return t.user().then(async (e) => {\n      if (e.npub)\n        return { user: e, npub: e.npub, signer: t };\n    });\n  } catch (t) {\n    throw t;\n  }\n}\nconst Vd = (t) => {\n  const [e, r] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({}), n = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({});\n  async function i(a) {\n    if (t == null || n.current[a])\n      return;\n    n.current = {\n      ...n.current,\n      [a]: pe.prototype\n    };\n    let c;\n    a.startsWith(\"npub\") ? c = t.getUser({\n      npub: a\n    }) : c = t.getUser({\n      hexpubkey: a\n    }), await c.fetchProfile(), c.profile && (n.current = {\n      ...n.current,\n      [a]: c\n    }, r(n.current));\n  }\n  function s(a) {\n    return e[a] ? e[a] : (i(a), pe.prototype);\n  }\n  function o(a) {\n    return e[a] ? e[a].profile : (i(a), {});\n  }\n  return {\n    getUser: s,\n    getProfile: o\n  };\n};\nvar Ba = { exports: {} }, Xt = {};\n/**\n * @license React\n * react-jsx-runtime.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar Mo;\nfunction Gd() {\n  if (Mo)\n    return Xt;\n  Mo = 1;\n  var t = react__WEBPACK_IMPORTED_MODULE_0__, e = Symbol.for(\"react.element\"), r = Symbol.for(\"react.fragment\"), n = Object.prototype.hasOwnProperty, i = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, s = { key: !0, ref: !0, __self: !0, __source: !0 };\n  function o(a, c, l) {\n    var f, u = {}, h = null, d = null;\n    l !== void 0 && (h = \"\" + l), c.key !== void 0 && (h = \"\" + c.key), c.ref !== void 0 && (d = c.ref);\n    for (f in c)\n      n.call(c, f) && !s.hasOwnProperty(f) && (u[f] = c[f]);\n    if (a && a.defaultProps)\n      for (f in c = a.defaultProps, c)\n        u[f] === void 0 && (u[f] = c[f]);\n    return { $$typeof: e, type: a, key: h, ref: d, props: u, _owner: i.current };\n  }\n  return Xt.Fragment = r, Xt.jsx = o, Xt.jsxs = o, Xt;\n}\nvar Qt = {};\n/**\n * @license React\n * react-jsx-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar Do;\nfunction Zd() {\n  return Do || (Do = 1,  true && function() {\n    var t = react__WEBPACK_IMPORTED_MODULE_0__, e = Symbol.for(\"react.element\"), r = Symbol.for(\"react.portal\"), n = Symbol.for(\"react.fragment\"), i = Symbol.for(\"react.strict_mode\"), s = Symbol.for(\"react.profiler\"), o = Symbol.for(\"react.provider\"), a = Symbol.for(\"react.context\"), c = Symbol.for(\"react.forward_ref\"), l = Symbol.for(\"react.suspense\"), f = Symbol.for(\"react.suspense_list\"), u = Symbol.for(\"react.memo\"), h = Symbol.for(\"react.lazy\"), d = Symbol.for(\"react.offscreen\"), p = Symbol.iterator, y = \"@@iterator\";\n    function g(b) {\n      if (b === null || typeof b != \"object\")\n        return null;\n      var k = p && b[p] || b[y];\n      return typeof k == \"function\" ? k : null;\n    }\n    var v = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n    function _(b) {\n      {\n        for (var k = arguments.length, T = new Array(k > 1 ? k - 1 : 0), $ = 1; $ < k; $++)\n          T[$ - 1] = arguments[$];\n        m(\"error\", b, T);\n      }\n    }\n    function m(b, k, T) {\n      {\n        var $ = v.ReactDebugCurrentFrame, M = $.getStackAddendum();\n        M !== \"\" && (k += \"%s\", T = T.concat([M]));\n        var K = T.map(function(j) {\n          return String(j);\n        });\n        K.unshift(\"Warning: \" + k), Function.prototype.apply.call(console[b], console, K);\n      }\n    }\n    var C = !1, O = !1, w = !1, x = !1, A = !1, B;\n    B = Symbol.for(\"react.module.reference\");\n    function L(b) {\n      return !!(typeof b == \"string\" || typeof b == \"function\" || b === n || b === s || A || b === i || b === l || b === f || x || b === d || C || O || w || typeof b == \"object\" && b !== null && (b.$$typeof === h || b.$$typeof === u || b.$$typeof === o || b.$$typeof === a || b.$$typeof === c || b.$$typeof === B || b.getModuleId !== void 0));\n    }\n    function P(b, k, T) {\n      var $ = b.displayName;\n      if ($)\n        return $;\n      var M = k.displayName || k.name || \"\";\n      return M !== \"\" ? T + \"(\" + M + \")\" : T;\n    }\n    function F(b) {\n      return b.displayName || \"Context\";\n    }\n    function z(b) {\n      if (b == null)\n        return null;\n      if (typeof b.tag == \"number\" && _(\"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"), typeof b == \"function\")\n        return b.displayName || b.name || null;\n      if (typeof b == \"string\")\n        return b;\n      switch (b) {\n        case n:\n          return \"Fragment\";\n        case r:\n          return \"Portal\";\n        case s:\n          return \"Profiler\";\n        case i:\n          return \"StrictMode\";\n        case l:\n          return \"Suspense\";\n        case f:\n          return \"SuspenseList\";\n      }\n      if (typeof b == \"object\")\n        switch (b.$$typeof) {\n          case a:\n            var k = b;\n            return F(k) + \".Consumer\";\n          case o:\n            var T = b;\n            return F(T._context) + \".Provider\";\n          case c:\n            return P(b, b.render, \"ForwardRef\");\n          case u:\n            var $ = b.displayName || null;\n            return $ !== null ? $ : z(b.type) || \"Memo\";\n          case h: {\n            var M = b, K = M._payload, j = M._init;\n            try {\n              return z(j(K));\n            } catch {\n              return null;\n            }\n          }\n        }\n      return null;\n    }\n    var G = Object.assign, E = 0, R, q, H, D, X, oe, re;\n    function _e() {\n    }\n    _e.__reactDisabledLog = !0;\n    function Oe() {\n      {\n        if (E === 0) {\n          R = console.log, q = console.info, H = console.warn, D = console.error, X = console.group, oe = console.groupCollapsed, re = console.groupEnd;\n          var b = {\n            configurable: !0,\n            enumerable: !0,\n            value: _e,\n            writable: !0\n          };\n          Object.defineProperties(console, {\n            info: b,\n            log: b,\n            warn: b,\n            error: b,\n            group: b,\n            groupCollapsed: b,\n            groupEnd: b\n          });\n        }\n        E++;\n      }\n    }\n    function Ue() {\n      {\n        if (E--, E === 0) {\n          var b = {\n            configurable: !0,\n            enumerable: !0,\n            writable: !0\n          };\n          Object.defineProperties(console, {\n            log: G({}, b, {\n              value: R\n            }),\n            info: G({}, b, {\n              value: q\n            }),\n            warn: G({}, b, {\n              value: H\n            }),\n            error: G({}, b, {\n              value: D\n            }),\n            group: G({}, b, {\n              value: X\n            }),\n            groupCollapsed: G({}, b, {\n              value: oe\n            }),\n            groupEnd: G({}, b, {\n              value: re\n            })\n          });\n        }\n        E < 0 && _(\"disabledDepth fell below zero. This is a bug in React. Please file an issue.\");\n      }\n    }\n    var Pe = v.ReactCurrentDispatcher, ye;\n    function je(b, k, T) {\n      {\n        if (ye === void 0)\n          try {\n            throw Error();\n          } catch (M) {\n            var $ = M.stack.trim().match(/\\n( *(at )?)/);\n            ye = $ && $[1] || \"\";\n          }\n        return `\n` + ye + b;\n      }\n    }\n    var me = !1, xe;\n    {\n      var lr = typeof WeakMap == \"function\" ? WeakMap : Map;\n      xe = new lr();\n    }\n    function Be(b, k) {\n      if (!b || me)\n        return \"\";\n      {\n        var T = xe.get(b);\n        if (T !== void 0)\n          return T;\n      }\n      var $;\n      me = !0;\n      var M = Error.prepareStackTrace;\n      Error.prepareStackTrace = void 0;\n      var K;\n      K = Pe.current, Pe.current = null, Oe();\n      try {\n        if (k) {\n          var j = function() {\n            throw Error();\n          };\n          if (Object.defineProperty(j.prototype, \"props\", {\n            set: function() {\n              throw Error();\n            }\n          }), typeof Reflect == \"object\" && Reflect.construct) {\n            try {\n              Reflect.construct(j, []);\n            } catch (Le) {\n              $ = Le;\n            }\n            Reflect.construct(b, [], j);\n          } else {\n            try {\n              j.call();\n            } catch (Le) {\n              $ = Le;\n            }\n            b.call(j.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (Le) {\n            $ = Le;\n          }\n          b();\n        }\n      } catch (Le) {\n        if (Le && $ && typeof Le.stack == \"string\") {\n          for (var U = Le.stack.split(`\n`), se = $.stack.split(`\n`), W = U.length - 1, Z = se.length - 1; W >= 1 && Z >= 0 && U[W] !== se[Z]; )\n            Z--;\n          for (; W >= 1 && Z >= 0; W--, Z--)\n            if (U[W] !== se[Z]) {\n              if (W !== 1 || Z !== 1)\n                do\n                  if (W--, Z--, Z < 0 || U[W] !== se[Z]) {\n                    var ge = `\n` + U[W].replace(\" at new \", \" at \");\n                    return b.displayName && ge.includes(\"<anonymous>\") && (ge = ge.replace(\"<anonymous>\", b.displayName)), typeof b == \"function\" && xe.set(b, ge), ge;\n                  }\n                while (W >= 1 && Z >= 0);\n              break;\n            }\n        }\n      } finally {\n        me = !1, Pe.current = K, Ue(), Error.prepareStackTrace = M;\n      }\n      var yt = b ? b.displayName || b.name : \"\", $i = yt ? je(yt) : \"\";\n      return typeof b == \"function\" && xe.set(b, $i), $i;\n    }\n    function fe(b, k, T) {\n      return Be(b, !1);\n    }\n    function He(b) {\n      var k = b.prototype;\n      return !!(k && k.isReactComponent);\n    }\n    function it(b, k, T) {\n      if (b == null)\n        return \"\";\n      if (typeof b == \"function\")\n        return Be(b, He(b));\n      if (typeof b == \"string\")\n        return je(b);\n      switch (b) {\n        case l:\n          return je(\"Suspense\");\n        case f:\n          return je(\"SuspenseList\");\n      }\n      if (typeof b == \"object\")\n        switch (b.$$typeof) {\n          case c:\n            return fe(b.render);\n          case u:\n            return it(b.type, k, T);\n          case h: {\n            var $ = b, M = $._payload, K = $._init;\n            try {\n              return it(K(M), k, T);\n            } catch {\n            }\n          }\n        }\n      return \"\";\n    }\n    var ot = Object.prototype.hasOwnProperty, Ei = {}, ki = v.ReactDebugCurrentFrame;\n    function fr(b) {\n      if (b) {\n        var k = b._owner, T = it(b.type, b._source, k ? k.type : null);\n        ki.setExtraStackFrame(T);\n      } else\n        ki.setExtraStackFrame(null);\n    }\n    function Ma(b, k, T, $, M) {\n      {\n        var K = Function.call.bind(ot);\n        for (var j in b)\n          if (K(b, j)) {\n            var U = void 0;\n            try {\n              if (typeof b[j] != \"function\") {\n                var se = Error(($ || \"React class\") + \": \" + T + \" type `\" + j + \"` is invalid; it must be a function, usually from the `prop-types` package, but received `\" + typeof b[j] + \"`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                throw se.name = \"Invariant Violation\", se;\n              }\n              U = b[j](k, j, $, T, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n            } catch (W) {\n              U = W;\n            }\n            U && !(U instanceof Error) && (fr(M), _(\"%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).\", $ || \"React class\", T, j, typeof U), fr(null)), U instanceof Error && !(U.message in Ei) && (Ei[U.message] = !0, fr(M), _(\"Failed %s type: %s\", T, U.message), fr(null));\n          }\n      }\n    }\n    var Da = Array.isArray;\n    function Zr(b) {\n      return Da(b);\n    }\n    function za(b) {\n      {\n        var k = typeof Symbol == \"function\" && Symbol.toStringTag, T = k && b[Symbol.toStringTag] || b.constructor.name || \"Object\";\n        return T;\n      }\n    }\n    function Fa(b) {\n      try {\n        return Si(b), !1;\n      } catch {\n        return !0;\n      }\n    }\n    function Si(b) {\n      return \"\" + b;\n    }\n    function Oi(b) {\n      if (Fa(b))\n        return _(\"The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.\", za(b)), Si(b);\n    }\n    var Ct = v.ReactCurrentOwner, Ka = {\n      key: !0,\n      ref: !0,\n      __self: !0,\n      __source: !0\n    }, Ai, Ci, Yr;\n    Yr = {};\n    function Wa(b) {\n      if (ot.call(b, \"ref\")) {\n        var k = Object.getOwnPropertyDescriptor(b, \"ref\").get;\n        if (k && k.isReactWarning)\n          return !1;\n      }\n      return b.ref !== void 0;\n    }\n    function Va(b) {\n      if (ot.call(b, \"key\")) {\n        var k = Object.getOwnPropertyDescriptor(b, \"key\").get;\n        if (k && k.isReactWarning)\n          return !1;\n      }\n      return b.key !== void 0;\n    }\n    function Ga(b, k) {\n      if (typeof b.ref == \"string\" && Ct.current && k && Ct.current.stateNode !== k) {\n        var T = z(Ct.current.type);\n        Yr[T] || (_('Component \"%s\" contains the string ref \"%s\". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', z(Ct.current.type), b.ref), Yr[T] = !0);\n      }\n    }\n    function Za(b, k) {\n      {\n        var T = function() {\n          Ai || (Ai = !0, _(\"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", k));\n        };\n        T.isReactWarning = !0, Object.defineProperty(b, \"key\", {\n          get: T,\n          configurable: !0\n        });\n      }\n    }\n    function Ya(b, k) {\n      {\n        var T = function() {\n          Ci || (Ci = !0, _(\"%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", k));\n        };\n        T.isReactWarning = !0, Object.defineProperty(b, \"ref\", {\n          get: T,\n          configurable: !0\n        });\n      }\n    }\n    var Ja = function(b, k, T, $, M, K, j) {\n      var U = {\n        $$typeof: e,\n        type: b,\n        key: k,\n        ref: T,\n        props: j,\n        _owner: K\n      };\n      return U._store = {}, Object.defineProperty(U._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: !1\n      }), Object.defineProperty(U, \"_self\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !1,\n        value: $\n      }), Object.defineProperty(U, \"_source\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !1,\n        value: M\n      }), Object.freeze && (Object.freeze(U.props), Object.freeze(U)), U;\n    };\n    function Xa(b, k, T, $, M) {\n      {\n        var K, j = {}, U = null, se = null;\n        T !== void 0 && (Oi(T), U = \"\" + T), Va(k) && (Oi(k.key), U = \"\" + k.key), Wa(k) && (se = k.ref, Ga(k, M));\n        for (K in k)\n          ot.call(k, K) && !Ka.hasOwnProperty(K) && (j[K] = k[K]);\n        if (b && b.defaultProps) {\n          var W = b.defaultProps;\n          for (K in W)\n            j[K] === void 0 && (j[K] = W[K]);\n        }\n        if (U || se) {\n          var Z = typeof b == \"function\" ? b.displayName || b.name || \"Unknown\" : b;\n          U && Za(j, Z), se && Ya(j, Z);\n        }\n        return Ja(b, U, se, M, $, Ct.current, j);\n      }\n    }\n    var Jr = v.ReactCurrentOwner, Ii = v.ReactDebugCurrentFrame;\n    function pt(b) {\n      if (b) {\n        var k = b._owner, T = it(b.type, b._source, k ? k.type : null);\n        Ii.setExtraStackFrame(T);\n      } else\n        Ii.setExtraStackFrame(null);\n    }\n    var Xr;\n    Xr = !1;\n    function Qr(b) {\n      return typeof b == \"object\" && b !== null && b.$$typeof === e;\n    }\n    function Ri() {\n      {\n        if (Jr.current) {\n          var b = z(Jr.current.type);\n          if (b)\n            return `\n\nCheck the render method of \\`` + b + \"`.\";\n        }\n        return \"\";\n      }\n    }\n    function Qa(b) {\n      {\n        if (b !== void 0) {\n          var k = b.fileName.replace(/^.*[\\\\\\/]/, \"\"), T = b.lineNumber;\n          return `\n\nCheck your code at ` + k + \":\" + T + \".\";\n        }\n        return \"\";\n      }\n    }\n    var Ti = {};\n    function ec(b) {\n      {\n        var k = Ri();\n        if (!k) {\n          var T = typeof b == \"string\" ? b : b.displayName || b.name;\n          T && (k = `\n\nCheck the top-level render call using <` + T + \">.\");\n        }\n        return k;\n      }\n    }\n    function Pi(b, k) {\n      {\n        if (!b._store || b._store.validated || b.key != null)\n          return;\n        b._store.validated = !0;\n        var T = ec(k);\n        if (Ti[T])\n          return;\n        Ti[T] = !0;\n        var $ = \"\";\n        b && b._owner && b._owner !== Jr.current && ($ = \" It was passed a child from \" + z(b._owner.type) + \".\"), pt(b), _('Each child in a list should have a unique \"key\" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', T, $), pt(null);\n      }\n    }\n    function Bi(b, k) {\n      {\n        if (typeof b != \"object\")\n          return;\n        if (Zr(b))\n          for (var T = 0; T < b.length; T++) {\n            var $ = b[T];\n            Qr($) && Pi($, k);\n          }\n        else if (Qr(b))\n          b._store && (b._store.validated = !0);\n        else if (b) {\n          var M = g(b);\n          if (typeof M == \"function\" && M !== b.entries)\n            for (var K = M.call(b), j; !(j = K.next()).done; )\n              Qr(j.value) && Pi(j.value, k);\n        }\n      }\n    }\n    function tc(b) {\n      {\n        var k = b.type;\n        if (k == null || typeof k == \"string\")\n          return;\n        var T;\n        if (typeof k == \"function\")\n          T = k.propTypes;\n        else if (typeof k == \"object\" && (k.$$typeof === c || k.$$typeof === u))\n          T = k.propTypes;\n        else\n          return;\n        if (T) {\n          var $ = z(k);\n          Ma(T, b.props, \"prop\", $, b);\n        } else if (k.PropTypes !== void 0 && !Xr) {\n          Xr = !0;\n          var M = z(k);\n          _(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", M || \"Unknown\");\n        }\n        typeof k.getDefaultProps == \"function\" && !k.getDefaultProps.isReactClassApproved && _(\"getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.\");\n      }\n    }\n    function rc(b) {\n      {\n        for (var k = Object.keys(b.props), T = 0; T < k.length; T++) {\n          var $ = k[T];\n          if ($ !== \"children\" && $ !== \"key\") {\n            pt(b), _(\"Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.\", $), pt(null);\n            break;\n          }\n        }\n        b.ref !== null && (pt(b), _(\"Invalid attribute `ref` supplied to `React.Fragment`.\"), pt(null));\n      }\n    }\n    function Li(b, k, T, $, M, K) {\n      {\n        var j = L(b);\n        if (!j) {\n          var U = \"\";\n          (b === void 0 || typeof b == \"object\" && b !== null && Object.keys(b).length === 0) && (U += \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\");\n          var se = Qa(M);\n          se ? U += se : U += Ri();\n          var W;\n          b === null ? W = \"null\" : Zr(b) ? W = \"array\" : b !== void 0 && b.$$typeof === e ? (W = \"<\" + (z(b.type) || \"Unknown\") + \" />\", U = \" Did you accidentally export a JSX literal instead of a component?\") : W = typeof b, _(\"React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s\", W, U);\n        }\n        var Z = Xa(b, k, T, M, K);\n        if (Z == null)\n          return Z;\n        if (j) {\n          var ge = k.children;\n          if (ge !== void 0)\n            if ($)\n              if (Zr(ge)) {\n                for (var yt = 0; yt < ge.length; yt++)\n                  Bi(ge[yt], b);\n                Object.freeze && Object.freeze(ge);\n              } else\n                _(\"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\");\n            else\n              Bi(ge, b);\n        }\n        return b === n ? rc(Z) : tc(Z), Z;\n      }\n    }\n    function nc(b, k, T) {\n      return Li(b, k, T, !0);\n    }\n    function ic(b, k, T) {\n      return Li(b, k, T, !1);\n    }\n    var oc = ic, sc = nc;\n    Qt.Fragment = n, Qt.jsx = oc, Qt.jsxs = sc;\n  }()), Qt;\n}\n(function(t) {\n   false ? 0 : t.exports = Zd();\n})(Ba);\nconst Yd = Ba.exports.jsx, La = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n  ndk: void 0,\n  signer: void 0,\n  fetchEvents: (t) => Promise.resolve([]),\n  loginWithNip46: (t, e) => Promise.resolve(void 0),\n  loginWithSecret: (t) => Promise.resolve(void 0),\n  loginWithNip07: () => Promise.resolve(void 0),\n  signPublishEvent: (t, e) => Promise.resolve(void 0),\n  getUser: (t) => pe.prototype,\n  getProfile: (t) => ({})\n}), Pp = ({\n  children: t,\n  relayUrls: e\n}) => {\n  const {\n    ndk: r,\n    signer: n,\n    setSigner: i,\n    fetchEvents: s,\n    signPublishEvent: o\n  } = zd(e), {\n    getUser: a,\n    getProfile: c\n  } = Vd(r);\n  async function l(h, d) {\n    if (r === void 0)\n      return;\n    const p = await Kd(r, h, d);\n    if (p)\n      return await i(p.remoteSigner), p;\n  }\n  async function f(h) {\n    const d = await Fd(h);\n    if (d) {\n      const {\n        signer: p\n      } = d;\n      return await i(p), d;\n    }\n  }\n  async function u() {\n    const h = await Wd();\n    if (h) {\n      const {\n        signer: d\n      } = h;\n      return await i(d), h;\n    }\n  }\n  return /* @__PURE__ */ Yd(La.Provider, {\n    value: {\n      ndk: r,\n      signer: n,\n      fetchEvents: s,\n      loginWithNip07: u,\n      loginWithNip46: l,\n      loginWithSecret: f,\n      signPublishEvent: o,\n      getUser: a,\n      getProfile: c\n    },\n    children: t\n  });\n}, Bp = () => {\n  const t = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(La);\n  if (t === void 0)\n    throw new Error(\"import NDKProvider to use useNDK\");\n  return t;\n};\nfunction Xe(t) {\n  return t != null && typeof t == \"object\" && t[\"@@functional/placeholder\"] === !0;\n}\nfunction ht(t) {\n  return function e(r) {\n    return arguments.length === 0 || Xe(r) ? e : t.apply(this, arguments);\n  };\n}\nfunction ur(t) {\n  return function e(r, n) {\n    switch (arguments.length) {\n      case 0:\n        return e;\n      case 1:\n        return Xe(r) ? e : ht(function(i) {\n          return t(r, i);\n        });\n      default:\n        return Xe(r) && Xe(n) ? e : Xe(r) ? ht(function(i) {\n          return t(i, n);\n        }) : Xe(n) ? ht(function(i) {\n          return t(r, i);\n        }) : t(r, n);\n    }\n  };\n}\nfunction $a(t, e) {\n  switch (t) {\n    case 0:\n      return function() {\n        return e.apply(this, arguments);\n      };\n    case 1:\n      return function(r) {\n        return e.apply(this, arguments);\n      };\n    case 2:\n      return function(r, n) {\n        return e.apply(this, arguments);\n      };\n    case 3:\n      return function(r, n, i) {\n        return e.apply(this, arguments);\n      };\n    case 4:\n      return function(r, n, i, s) {\n        return e.apply(this, arguments);\n      };\n    case 5:\n      return function(r, n, i, s, o) {\n        return e.apply(this, arguments);\n      };\n    case 6:\n      return function(r, n, i, s, o, a) {\n        return e.apply(this, arguments);\n      };\n    case 7:\n      return function(r, n, i, s, o, a, c) {\n        return e.apply(this, arguments);\n      };\n    case 8:\n      return function(r, n, i, s, o, a, c, l) {\n        return e.apply(this, arguments);\n      };\n    case 9:\n      return function(r, n, i, s, o, a, c, l, f) {\n        return e.apply(this, arguments);\n      };\n    case 10:\n      return function(r, n, i, s, o, a, c, l, f, u) {\n        return e.apply(this, arguments);\n      };\n    default:\n      throw new Error(\"First argument to _arity must be a non-negative integer no greater than ten\");\n  }\n}\nfunction qa(t, e, r) {\n  return function() {\n    for (var n = [], i = 0, s = t, o = 0; o < e.length || i < arguments.length; ) {\n      var a;\n      o < e.length && (!Xe(e[o]) || i >= arguments.length) ? a = e[o] : (a = arguments[i], i += 1), n[o] = a, Xe(a) || (s -= 1), o += 1;\n    }\n    return s <= 0 ? r.apply(this, n) : $a(s, qa(t, n, r));\n  };\n}\nvar Jd = /* @__PURE__ */ ur(function(e, r) {\n  return e === 1 ? ht(r) : $a(e, qa(e, [], r));\n});\nconst Xd = Jd, Qd = Array.isArray || function(e) {\n  return e != null && e.length >= 0 && Object.prototype.toString.call(e) === \"[object Array]\";\n};\nfunction ep(t) {\n  return t != null && typeof t[\"@@transducer/step\"] == \"function\";\n}\nfunction tp(t, e, r) {\n  return function() {\n    if (arguments.length === 0)\n      return r();\n    var n = arguments[arguments.length - 1];\n    if (!Qd(n)) {\n      for (var i = 0; i < t.length; ) {\n        if (typeof n[t[i]] == \"function\")\n          return n[t[i]].apply(n, Array.prototype.slice.call(arguments, 0, -1));\n        i += 1;\n      }\n      if (ep(n)) {\n        var s = e.apply(null, Array.prototype.slice.call(arguments, 0, -1));\n        return s(n);\n      }\n    }\n    return r.apply(this, arguments);\n  };\n}\nconst zo = {\n  init: function() {\n    return this.xf[\"@@transducer/init\"]();\n  },\n  result: function(t) {\n    return this.xf[\"@@transducer/result\"](t);\n  }\n};\nfunction jn(t, e) {\n  return Object.prototype.hasOwnProperty.call(e, t);\n}\nvar Fo = Object.prototype.toString, rp = /* @__PURE__ */ function() {\n  return Fo.call(arguments) === \"[object Arguments]\" ? function(e) {\n    return Fo.call(e) === \"[object Arguments]\";\n  } : function(e) {\n    return jn(\"callee\", e);\n  };\n}();\nconst np = rp;\nvar ip = !/* @__PURE__ */ {\n  toString: null\n}.propertyIsEnumerable(\"toString\"), Ko = [\"constructor\", \"valueOf\", \"isPrototypeOf\", \"toString\", \"propertyIsEnumerable\", \"hasOwnProperty\", \"toLocaleString\"], Wo = /* @__PURE__ */ function() {\n  return arguments.propertyIsEnumerable(\"length\");\n}(), op = function(e, r) {\n  for (var n = 0; n < e.length; ) {\n    if (e[n] === r)\n      return !0;\n    n += 1;\n  }\n  return !1;\n}, sp = /* @__PURE__ */ ht(typeof Object.keys == \"function\" && !Wo ? function(e) {\n  return Object(e) !== e ? [] : Object.keys(e);\n} : function(e) {\n  if (Object(e) !== e)\n    return [];\n  var r, n, i = [], s = Wo && np(e);\n  for (r in e)\n    jn(r, e) && (!s || r !== \"length\") && (i[i.length] = r);\n  if (ip)\n    for (n = Ko.length - 1; n >= 0; )\n      r = Ko[n], jn(r, e) && !op(i, r) && (i[i.length] = r), n -= 1;\n  return i;\n});\nconst ap = sp;\nfunction cp(t, e) {\n  for (var r = 0, n = e.length, i = Array(n); r < n; )\n    i[r] = t(e[r]), r += 1;\n  return i;\n}\nfunction up(t, e, r) {\n  for (var n = 0, i = r.length; n < i; )\n    e = t(e, r[n]), n += 1;\n  return e;\n}\nvar lp = /* @__PURE__ */ function() {\n  function t(e, r) {\n    this.xf = r, this.f = e;\n  }\n  return t.prototype[\"@@transducer/init\"] = zo.init, t.prototype[\"@@transducer/result\"] = zo.result, t.prototype[\"@@transducer/step\"] = function(e, r) {\n    return this.xf[\"@@transducer/step\"](e, this.f(r));\n  }, t;\n}(), fp = function(e) {\n  return function(r) {\n    return new lp(e, r);\n  };\n};\nconst hp = fp;\nvar dp = /* @__PURE__ */ ur(\n  /* @__PURE__ */ tp([\"fantasy-land/map\", \"map\"], hp, function(e, r) {\n    switch (Object.prototype.toString.call(r)) {\n      case \"[object Function]\":\n        return Xd(r.length, function() {\n          return e.call(this, r.apply(this, arguments));\n        });\n      case \"[object Object]\":\n        return up(function(n, i) {\n          return n[i] = e(r[i]), n;\n        }, {}, ap(r));\n      default:\n        return cp(e, r);\n    }\n  })\n);\nconst pp = dp, yp = Number.isInteger || function(e) {\n  return e << 0 === e;\n};\nfunction gp(t) {\n  return Object.prototype.toString.call(t) === \"[object String]\";\n}\nvar bp = /* @__PURE__ */ ur(function(e, r) {\n  var n = e < 0 ? r.length + e : e;\n  return gp(r) ? r.charAt(n) : r[n];\n});\nconst Na = bp;\nvar vp = /* @__PURE__ */ ur(function(e, r) {\n  if (r != null)\n    return yp(e) ? Na(e, r) : r[e];\n});\nconst wp = vp;\nvar _p = /* @__PURE__ */ ur(function(e, r) {\n  return pp(wp(e), r);\n});\nconst mp = _p;\nfunction xp(t) {\n  return t;\n}\nvar Ep = /* @__PURE__ */ ht(xp);\nconst kp = Ep;\nvar Sp = /* @__PURE__ */ Na(-1);\nconst Ua = Sp, Op = \"newline\", Hn = \"text\", ja = \"topic\", xi = \"link\", Ha = \"invoice\", Lp = \"nostr:note\", $p = \"nostr:nevent\", qp = \"nostr:npub\", Np = \"nostr:nprofile\", Up = \"nostr:naddr\";\nfunction gt(t) {\n  return t ? t[0] : void 0;\n}\nconst Ap = (t) => t.replace(/^[\\w\\+]+:\\/?\\/?/, \"\"), Cp = (t) => !t.match(/\\.(apk|docx|xlsx|csv|dmg)/) && Ua(t.split(\"://\")).includes(\"/\"), jp = ({\n  content: t,\n  tags: e = []\n}) => {\n  const r = [];\n  let n = t.trim(), i = \"\";\n  const s = () => {\n    const u = gt(n.match(/^\\n+/));\n    if (u)\n      return [Op, u, u];\n  }, o = () => {\n    const u = n.match(/^#\\[(\\d+)\\]/i);\n    if (u) {\n      const h = parseInt(u[1]);\n      if (e[h]) {\n        const [d, p, y] = e[h], g = [y].filter(kp);\n        let v, _, m;\n        return d === \"p\" ? (v = \"nprofile\", _ = { pubkey: p, relays: g }, m = we.nprofileEncode(_)) : (v = \"nevent\", _ = { id: p, relays: g, pubkey: null }, m = we.neventEncode(_)), [`nostr:${v}`, u[0], { ..._, entity: m }];\n      }\n    }\n  }, a = () => {\n    const u = gt(n.match(/^#\\w+/i));\n    if (u && !u.match(/^#\\d+$/))\n      return [ja, u, u.slice(1)];\n  }, c = () => {\n    const u = gt(\n      n.match(\n        /^(web\\+)?(nostr:)?\\/?\\/?n(event|ote|profile|pub|addr)1[\\d\\w]+/i\n      )\n    );\n    if (u)\n      try {\n        const h = Ap(u), { type: d, data: p } = we.decode(h);\n        let y = p;\n        return d === \"note\" ? y = { id: p } : d === \"npub\" && (y = { pubkey: p }), [`nostr:${d}`, u, { ...y, entity: h }];\n      } catch (h) {\n        console.log(h);\n      }\n  }, l = () => {\n    const u = gt(n.match(/^ln(bc|url)[\\d\\w]{50,1000}/i));\n    if (u)\n      return [Ha, u, u];\n  }, f = () => {\n    const u = gt(\n      n.match(/^([a-z\\+:]{2,30}:\\/\\/)?[^\\s]+\\.[a-z]{2,6}[^\\s]*[^\\.!?,:\\s]/gi)\n    );\n    if (u) {\n      const h = Ua(r);\n      if ((h == null ? void 0 : h.type) === \"text\" && h.value.endsWith(\"/\"))\n        return;\n      let d = u;\n      return d.match(/\\.\\./) ? void 0 : (d.match(\"://\") || (d = \"https://\" + d), [xi, u, { url: d, isMedia: Cp(d) }]);\n    }\n  };\n  for (; n; ) {\n    const u = s() || o() || a() || c() || f() || l();\n    if (u) {\n      i && (r.push({ type: \"text\", value: i }), i = \"\");\n      const [h, d, p] = u;\n      r.push({ type: h, value: p }), n = n.slice(d.length);\n    } else {\n      const h = gt(n.match(/^[\\w\\d]+ ?/i)) || n[0];\n      i += h, n = n.slice(h.length);\n    }\n  }\n  return i && r.push({ type: Hn, value: i }), r;\n}, Hp = (t, { showEntire: e, maxLength: r, showMedia: n = !1 }) => {\n  if (e)\n    return t;\n  let i = 0;\n  const s = [], o = r * 0.6;\n  return t.every((a, c) => {\n    const l = [ja, Hn].includes(a.type) || a.type === xi && !a.value.isMedia, f = a.type === Ha || a.type.startsWith(\"nostr:\") || a.value.isMedia;\n    return l && (i += a.value.length), f && (i += n ? r / 3 : a.value.length), s.push(a), i > o && c < t.length - 1 ? ((l || f && !n) && s.push({ type: Hn, value: \"...\" }), !1) : !0;\n  }), s;\n}, Mp = (t) => mp(\n  \"value\",\n  t.filter((e) => e.type === xi && e.isMedia)\n);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrLXJlYWN0L2Rpc3QvbmRrLXJlYWN0LmVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0EsMENBQTBDLDBEQUEwRDtBQUNwRztBQUNpSDtBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0Esa0RBQWtELFdBQVc7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBLFdBQVcsYUFBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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QUFDL0QsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0JBQXNCO0FBQ2xDLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDREQUE0RCxVQUFVLGNBQWMsU0FBUztBQUM3RjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrREFBa0QsMkJBQTJCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCLGlCQUFpQjtBQUMxQztBQUNBLDBDQUEwQyxXQUFXO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLEVBQUU7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLEVBQUU7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxFQUFFLGtC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QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsRUFBRTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMkJBQTJCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxXQUFXLFNBQVMsU0FBUyxTQUFTLFNBQVMsU0FBUztBQUN4RDtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsV0FBVztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFB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QUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEVBQUU7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxtQkFBbUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRixFQUFFO0FBQ3BGLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRyxLQUFLO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCx5QkFBeUIsU0FBUztBQUNsQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFNBQVM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCw0REFBNEQsVUFBVTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsd0JBQXdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxzQkFBc0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEdBQTBHLEtBQUs7QUFDL0csTUFBTTtBQUNOLGlDQUFpQyxLQUFLO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsYUFBYSxHQUFHLEVBQUU7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxrQkFBa0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1Asa0RBQWtELHNCQUFzQjtBQUN4RSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QyxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLG9FQUFvRTtBQUNqRyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFFQUFxRTtBQUNqRixxREFBcUQsNkNBQTZDO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLHVEQUF1RCx5REFBeUQ7QUFDaEg7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsaUJBQWlCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxLQUFLO0FBQ3hFLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxpQ0FBaUMscUJBQXFCO0FBQ3REO0FBQ0EsNEVBQTRFLG1EQUFtRDtBQUMvSCxpQkFBaUIsMERBQTBELElBQUk7QUFDL0U7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLCtEQUErRCxjQUFjO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDRHQUE0RyxjQUFjLFNBQVMsNkJBQTZCO0FBQ2hLLGlDQUFpQyxFQUFFO0FBQ25DLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsWUFBWTtBQUMvQixNQUFNO0FBQ04sMENBQTBDLFNBQVM7QUFDbkQsaUlBQWlJLGNBQWM7QUFDL0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxjQUFjO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxnQ0FBZ0M7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUNBQW1DO0FBQ2hEO0FBQ0E7QUFDQSxnREFBZ0QsY0FBYztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLHlDQUF5QyxrQkFBa0I7QUFDM0Q7QUFDQSxvQ0FBb0MsdUJBQXVCO0FBQzNEO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsbUVBQW1FLHVCQUF1QjtBQUMxRjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw2Q0FBRSxlQUFlLCtDQUFFLG1CQUFtQiwrQ0FBRTtBQUNwRCxFQUFFLGdEQUFFO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSx1QkFBdUIsaUNBQWlDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsK0NBQUUsR0FBRyxPQUFPLDZDQUFFLEdBQUc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxrQ0FBRSw0TEFBNEw7QUFDeE07QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixLQUFxQztBQUM3RCxZQUFZLGtDQUFFO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLE9BQU87QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYixzQkFBc0I7QUFDdEI7QUFDQSxhQUFhO0FBQ2Isc0JBQXNCO0FBQ3RCO0FBQ0EsYUFBYTtBQUNiLHVCQUF1QjtBQUN2QjtBQUNBLGFBQWE7QUFDYix1QkFBdUI7QUFDdkI7QUFDQSxhQUFhO0FBQ2IsZ0NBQWdDO0FBQ2hDO0FBQ0EsYUFBYTtBQUNiLDBCQUEwQjtBQUMxQjtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLG9DQUFvQztBQUM3RTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdHQUFnRztBQUNoRztBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLG1HQUFtRztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsc0JBQXNCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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LHVCQUF1QixvQkFBb0I7QUFDM0MsQ0FBQyxhQUFhLGdEQUFnRDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrSkFBa0osd0JBQXdCO0FBQzFLLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBbUJFIiwic291cmNlcyI6WyIvaG9tZS9sZmcvR2l0L01hZHRyaXBzL25vZGVfbW9kdWxlcy9Abm9zdHItZGV2LWtpdC9uZGstcmVhY3QvZGlzdC9uZGstcmVhY3QuZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGFjID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIGNjID0gKHQsIGUsIHIpID0+IGUgaW4gdCA/IGFjKHQsIGUsIHsgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCwgdmFsdWU6IHIgfSkgOiB0W2VdID0gcjtcbnZhciBJID0gKHQsIGUsIHIpID0+IChjYyh0LCB0eXBlb2YgZSAhPSBcInN5bWJvbFwiID8gZSArIFwiXCIgOiBlLCByKSwgcik7XG5pbXBvcnQgVm8sIHsgdXNlUmVmIGFzIEdvLCB1c2VTdGF0ZSBhcyBTbiwgdXNlRWZmZWN0IGFzIHVjLCBjcmVhdGVDb250ZXh0IGFzIGxjLCB1c2VDb250ZXh0IGFzIGZjIH0gZnJvbSBcInJlYWN0XCI7XG52YXIgUyA9IHR5cGVvZiBnbG9iYWxUaGlzIDwgXCJ1XCIgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyA8IFwidVwiID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCA8IFwidVwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgPCBcInVcIiA/IHNlbGYgOiB7fTtcbmZ1bmN0aW9uIEV0KHQpIHtcbiAgdmFyIGUgPSB0LmRlZmF1bHQ7XG4gIGlmICh0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB2YXIgciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIHIucHJvdG90eXBlID0gZS5wcm90b3R5cGU7XG4gIH0gZWxzZVxuICAgIHIgPSB7fTtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIE9iamVjdC5rZXlzKHQpLmZvckVhY2goZnVuY3Rpb24obikge1xuICAgIHZhciBpID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCBuKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkociwgbiwgaS5nZXQgPyBpIDoge1xuICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdFtuXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSksIHI7XG59XG52YXIgT24gPSB7IGV4cG9ydHM6IHt9IH0sIGVuLCBxaTtcbmZ1bmN0aW9uIGhjKCkge1xuICBpZiAocWkpXG4gICAgcmV0dXJuIGVuO1xuICBxaSA9IDE7XG4gIHZhciB0ID0gMWUzLCBlID0gdCAqIDYwLCByID0gZSAqIDYwLCBuID0gciAqIDI0LCBpID0gbiAqIDcsIHMgPSBuICogMzY1LjI1O1xuICBlbiA9IGZ1bmN0aW9uKGYsIHUpIHtcbiAgICB1ID0gdSB8fCB7fTtcbiAgICB2YXIgaCA9IHR5cGVvZiBmO1xuICAgIGlmIChoID09PSBcInN0cmluZ1wiICYmIGYubGVuZ3RoID4gMClcbiAgICAgIHJldHVybiBvKGYpO1xuICAgIGlmIChoID09PSBcIm51bWJlclwiICYmIGlzRmluaXRlKGYpKVxuICAgICAgcmV0dXJuIHUubG9uZyA/IGMoZikgOiBhKGYpO1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwidmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSB2YWxpZCBudW1iZXIuIHZhbD1cIiArIEpTT04uc3RyaW5naWZ5KGYpXG4gICAgKTtcbiAgfTtcbiAgZnVuY3Rpb24gbyhmKSB7XG4gICAgaWYgKGYgPSBTdHJpbmcoZiksICEoZi5sZW5ndGggPiAxMDApKSB7XG4gICAgICB2YXIgdSA9IC9eKC0/KD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx3ZWVrcz98d3x5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhcbiAgICAgICAgZlxuICAgICAgKTtcbiAgICAgIGlmICghIXUpIHtcbiAgICAgICAgdmFyIGggPSBwYXJzZUZsb2F0KHVbMV0pLCBkID0gKHVbMl0gfHwgXCJtc1wiKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBzd2l0Y2ggKGQpIHtcbiAgICAgICAgICBjYXNlIFwieWVhcnNcIjpcbiAgICAgICAgICBjYXNlIFwieWVhclwiOlxuICAgICAgICAgIGNhc2UgXCJ5cnNcIjpcbiAgICAgICAgICBjYXNlIFwieXJcIjpcbiAgICAgICAgICBjYXNlIFwieVwiOlxuICAgICAgICAgICAgcmV0dXJuIGggKiBzO1xuICAgICAgICAgIGNhc2UgXCJ3ZWVrc1wiOlxuICAgICAgICAgIGNhc2UgXCJ3ZWVrXCI6XG4gICAgICAgICAgY2FzZSBcIndcIjpcbiAgICAgICAgICAgIHJldHVybiBoICogaTtcbiAgICAgICAgICBjYXNlIFwiZGF5c1wiOlxuICAgICAgICAgIGNhc2UgXCJkYXlcIjpcbiAgICAgICAgICBjYXNlIFwiZFwiOlxuICAgICAgICAgICAgcmV0dXJuIGggKiBuO1xuICAgICAgICAgIGNhc2UgXCJob3Vyc1wiOlxuICAgICAgICAgIGNhc2UgXCJob3VyXCI6XG4gICAgICAgICAgY2FzZSBcImhyc1wiOlxuICAgICAgICAgIGNhc2UgXCJoclwiOlxuICAgICAgICAgIGNhc2UgXCJoXCI6XG4gICAgICAgICAgICByZXR1cm4gaCAqIHI7XG4gICAgICAgICAgY2FzZSBcIm1pbnV0ZXNcIjpcbiAgICAgICAgICBjYXNlIFwibWludXRlXCI6XG4gICAgICAgICAgY2FzZSBcIm1pbnNcIjpcbiAgICAgICAgICBjYXNlIFwibWluXCI6XG4gICAgICAgICAgY2FzZSBcIm1cIjpcbiAgICAgICAgICAgIHJldHVybiBoICogZTtcbiAgICAgICAgICBjYXNlIFwic2Vjb25kc1wiOlxuICAgICAgICAgIGNhc2UgXCJzZWNvbmRcIjpcbiAgICAgICAgICBjYXNlIFwic2Vjc1wiOlxuICAgICAgICAgIGNhc2UgXCJzZWNcIjpcbiAgICAgICAgICBjYXNlIFwic1wiOlxuICAgICAgICAgICAgcmV0dXJuIGggKiB0O1xuICAgICAgICAgIGNhc2UgXCJtaWxsaXNlY29uZHNcIjpcbiAgICAgICAgICBjYXNlIFwibWlsbGlzZWNvbmRcIjpcbiAgICAgICAgICBjYXNlIFwibXNlY3NcIjpcbiAgICAgICAgICBjYXNlIFwibXNlY1wiOlxuICAgICAgICAgIGNhc2UgXCJtc1wiOlxuICAgICAgICAgICAgcmV0dXJuIGg7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBhKGYpIHtcbiAgICB2YXIgdSA9IE1hdGguYWJzKGYpO1xuICAgIHJldHVybiB1ID49IG4gPyBNYXRoLnJvdW5kKGYgLyBuKSArIFwiZFwiIDogdSA+PSByID8gTWF0aC5yb3VuZChmIC8gcikgKyBcImhcIiA6IHUgPj0gZSA/IE1hdGgucm91bmQoZiAvIGUpICsgXCJtXCIgOiB1ID49IHQgPyBNYXRoLnJvdW5kKGYgLyB0KSArIFwic1wiIDogZiArIFwibXNcIjtcbiAgfVxuICBmdW5jdGlvbiBjKGYpIHtcbiAgICB2YXIgdSA9IE1hdGguYWJzKGYpO1xuICAgIHJldHVybiB1ID49IG4gPyBsKGYsIHUsIG4sIFwiZGF5XCIpIDogdSA+PSByID8gbChmLCB1LCByLCBcImhvdXJcIikgOiB1ID49IGUgPyBsKGYsIHUsIGUsIFwibWludXRlXCIpIDogdSA+PSB0ID8gbChmLCB1LCB0LCBcInNlY29uZFwiKSA6IGYgKyBcIiBtc1wiO1xuICB9XG4gIGZ1bmN0aW9uIGwoZiwgdSwgaCwgZCkge1xuICAgIHZhciBwID0gdSA+PSBoICogMS41O1xuICAgIHJldHVybiBNYXRoLnJvdW5kKGYgLyBoKSArIFwiIFwiICsgZCArIChwID8gXCJzXCIgOiBcIlwiKTtcbiAgfVxuICByZXR1cm4gZW47XG59XG5mdW5jdGlvbiBkYyh0KSB7XG4gIHIuZGVidWcgPSByLCByLmRlZmF1bHQgPSByLCByLmNvZXJjZSA9IGMsIHIuZGlzYWJsZSA9IHMsIHIuZW5hYmxlID0gaSwgci5lbmFibGVkID0gbywgci5odW1hbml6ZSA9IGhjKCksIHIuZGVzdHJveSA9IGwsIE9iamVjdC5rZXlzKHQpLmZvckVhY2goKGYpID0+IHtcbiAgICByW2ZdID0gdFtmXTtcbiAgfSksIHIubmFtZXMgPSBbXSwgci5za2lwcyA9IFtdLCByLmZvcm1hdHRlcnMgPSB7fTtcbiAgZnVuY3Rpb24gZShmKSB7XG4gICAgbGV0IHUgPSAwO1xuICAgIGZvciAobGV0IGggPSAwOyBoIDwgZi5sZW5ndGg7IGgrKylcbiAgICAgIHUgPSAodSA8PCA1KSAtIHUgKyBmLmNoYXJDb2RlQXQoaCksIHUgfD0gMDtcbiAgICByZXR1cm4gci5jb2xvcnNbTWF0aC5hYnModSkgJSByLmNvbG9ycy5sZW5ndGhdO1xuICB9XG4gIHIuc2VsZWN0Q29sb3IgPSBlO1xuICBmdW5jdGlvbiByKGYpIHtcbiAgICBsZXQgdSwgaCA9IG51bGwsIGQsIHA7XG4gICAgZnVuY3Rpb24geSguLi5nKSB7XG4gICAgICBpZiAoIXkuZW5hYmxlZClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgdiA9IHksIF8gPSBOdW1iZXIobmV3IERhdGUoKSksIG0gPSBfIC0gKHUgfHwgXyk7XG4gICAgICB2LmRpZmYgPSBtLCB2LnByZXYgPSB1LCB2LmN1cnIgPSBfLCB1ID0gXywgZ1swXSA9IHIuY29lcmNlKGdbMF0pLCB0eXBlb2YgZ1swXSAhPSBcInN0cmluZ1wiICYmIGcudW5zaGlmdChcIiVPXCIpO1xuICAgICAgbGV0IEMgPSAwO1xuICAgICAgZ1swXSA9IGdbMF0ucmVwbGFjZSgvJShbYS16QS1aJV0pL2csICh3LCB4KSA9PiB7XG4gICAgICAgIGlmICh3ID09PSBcIiUlXCIpXG4gICAgICAgICAgcmV0dXJuIFwiJVwiO1xuICAgICAgICBDKys7XG4gICAgICAgIGNvbnN0IEEgPSByLmZvcm1hdHRlcnNbeF07XG4gICAgICAgIGlmICh0eXBlb2YgQSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBjb25zdCBCID0gZ1tDXTtcbiAgICAgICAgICB3ID0gQS5jYWxsKHYsIEIpLCBnLnNwbGljZShDLCAxKSwgQy0tO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3O1xuICAgICAgfSksIHIuZm9ybWF0QXJncy5jYWxsKHYsIGcpLCAodi5sb2cgfHwgci5sb2cpLmFwcGx5KHYsIGcpO1xuICAgIH1cbiAgICByZXR1cm4geS5uYW1lc3BhY2UgPSBmLCB5LnVzZUNvbG9ycyA9IHIudXNlQ29sb3JzKCksIHkuY29sb3IgPSByLnNlbGVjdENvbG9yKGYpLCB5LmV4dGVuZCA9IG4sIHkuZGVzdHJveSA9IHIuZGVzdHJveSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHksIFwiZW5hYmxlZFwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICBnZXQ6ICgpID0+IGggIT09IG51bGwgPyBoIDogKGQgIT09IHIubmFtZXNwYWNlcyAmJiAoZCA9IHIubmFtZXNwYWNlcywgcCA9IHIuZW5hYmxlZChmKSksIHApLFxuICAgICAgc2V0OiAoZykgPT4ge1xuICAgICAgICBoID0gZztcbiAgICAgIH1cbiAgICB9KSwgdHlwZW9mIHIuaW5pdCA9PSBcImZ1bmN0aW9uXCIgJiYgci5pbml0KHkpLCB5O1xuICB9XG4gIGZ1bmN0aW9uIG4oZiwgdSkge1xuICAgIGNvbnN0IGggPSByKHRoaXMubmFtZXNwYWNlICsgKHR5cGVvZiB1ID4gXCJ1XCIgPyBcIjpcIiA6IHUpICsgZik7XG4gICAgcmV0dXJuIGgubG9nID0gdGhpcy5sb2csIGg7XG4gIH1cbiAgZnVuY3Rpb24gaShmKSB7XG4gICAgci5zYXZlKGYpLCByLm5hbWVzcGFjZXMgPSBmLCByLm5hbWVzID0gW10sIHIuc2tpcHMgPSBbXTtcbiAgICBsZXQgdTtcbiAgICBjb25zdCBoID0gKHR5cGVvZiBmID09IFwic3RyaW5nXCIgPyBmIDogXCJcIikuc3BsaXQoL1tcXHMsXSsvKSwgZCA9IGgubGVuZ3RoO1xuICAgIGZvciAodSA9IDA7IHUgPCBkOyB1KyspXG4gICAgICAhaFt1XSB8fCAoZiA9IGhbdV0ucmVwbGFjZSgvXFwqL2csIFwiLio/XCIpLCBmWzBdID09PSBcIi1cIiA/IHIuc2tpcHMucHVzaChuZXcgUmVnRXhwKFwiXlwiICsgZi5zbGljZSgxKSArIFwiJFwiKSkgOiByLm5hbWVzLnB1c2gobmV3IFJlZ0V4cChcIl5cIiArIGYgKyBcIiRcIikpKTtcbiAgfVxuICBmdW5jdGlvbiBzKCkge1xuICAgIGNvbnN0IGYgPSBbXG4gICAgICAuLi5yLm5hbWVzLm1hcChhKSxcbiAgICAgIC4uLnIuc2tpcHMubWFwKGEpLm1hcCgodSkgPT4gXCItXCIgKyB1KVxuICAgIF0uam9pbihcIixcIik7XG4gICAgcmV0dXJuIHIuZW5hYmxlKFwiXCIpLCBmO1xuICB9XG4gIGZ1bmN0aW9uIG8oZikge1xuICAgIGlmIChmW2YubGVuZ3RoIC0gMV0gPT09IFwiKlwiKVxuICAgICAgcmV0dXJuICEwO1xuICAgIGxldCB1LCBoO1xuICAgIGZvciAodSA9IDAsIGggPSByLnNraXBzLmxlbmd0aDsgdSA8IGg7IHUrKylcbiAgICAgIGlmIChyLnNraXBzW3VdLnRlc3QoZikpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICBmb3IgKHUgPSAwLCBoID0gci5uYW1lcy5sZW5ndGg7IHUgPCBoOyB1KyspXG4gICAgICBpZiAoci5uYW1lc1t1XS50ZXN0KGYpKVxuICAgICAgICByZXR1cm4gITA7XG4gICAgcmV0dXJuICExO1xuICB9XG4gIGZ1bmN0aW9uIGEoZikge1xuICAgIHJldHVybiBmLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIsIGYudG9TdHJpbmcoKS5sZW5ndGggLSAyKS5yZXBsYWNlKC9cXC5cXCpcXD8kLywgXCIqXCIpO1xuICB9XG4gIGZ1bmN0aW9uIGMoZikge1xuICAgIHJldHVybiBmIGluc3RhbmNlb2YgRXJyb3IgPyBmLnN0YWNrIHx8IGYubWVzc2FnZSA6IGY7XG4gIH1cbiAgZnVuY3Rpb24gbCgpIHtcbiAgICBjb25zb2xlLndhcm4oXCJJbnN0YW5jZSBtZXRob2QgYGRlYnVnLmRlc3Ryb3koKWAgaXMgZGVwcmVjYXRlZCBhbmQgbm8gbG9uZ2VyIGRvZXMgYW55dGhpbmcuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIG9mIGBkZWJ1Z2AuXCIpO1xuICB9XG4gIHJldHVybiByLmVuYWJsZShyLmxvYWQoKSksIHI7XG59XG52YXIgcGMgPSBkYztcbihmdW5jdGlvbih0LCBlKSB7XG4gIGUuZm9ybWF0QXJncyA9IG4sIGUuc2F2ZSA9IGksIGUubG9hZCA9IHMsIGUudXNlQ29sb3JzID0gciwgZS5zdG9yYWdlID0gbygpLCBlLmRlc3Ryb3kgPSAoKCkgPT4ge1xuICAgIGxldCBjID0gITE7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGMgfHwgKGMgPSAhMCwgY29uc29sZS53YXJuKFwiSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLlwiKSk7XG4gICAgfTtcbiAgfSkoKSwgZS5jb2xvcnMgPSBbXG4gICAgXCIjMDAwMENDXCIsXG4gICAgXCIjMDAwMEZGXCIsXG4gICAgXCIjMDAzM0NDXCIsXG4gICAgXCIjMDAzM0ZGXCIsXG4gICAgXCIjMDA2NkNDXCIsXG4gICAgXCIjMDA2NkZGXCIsXG4gICAgXCIjMDA5OUNDXCIsXG4gICAgXCIjMDA5OUZGXCIsXG4gICAgXCIjMDBDQzAwXCIsXG4gICAgXCIjMDBDQzMzXCIsXG4gICAgXCIjMDBDQzY2XCIsXG4gICAgXCIjMDBDQzk5XCIsXG4gICAgXCIjMDBDQ0NDXCIsXG4gICAgXCIjMDBDQ0ZGXCIsXG4gICAgXCIjMzMwMENDXCIsXG4gICAgXCIjMzMwMEZGXCIsXG4gICAgXCIjMzMzM0NDXCIsXG4gICAgXCIjMzMzM0ZGXCIsXG4gICAgXCIjMzM2NkNDXCIsXG4gICAgXCIjMzM2NkZGXCIsXG4gICAgXCIjMzM5OUNDXCIsXG4gICAgXCIjMzM5OUZGXCIsXG4gICAgXCIjMzNDQzAwXCIsXG4gICAgXCIjMzNDQzMzXCIsXG4gICAgXCIjMzNDQzY2XCIsXG4gICAgXCIjMzNDQzk5XCIsXG4gICAgXCIjMzNDQ0NDXCIsXG4gICAgXCIjMzNDQ0ZGXCIsXG4gICAgXCIjNjYwMENDXCIsXG4gICAgXCIjNjYwMEZGXCIsXG4gICAgXCIjNjYzM0NDXCIsXG4gICAgXCIjNjYzM0ZGXCIsXG4gICAgXCIjNjZDQzAwXCIsXG4gICAgXCIjNjZDQzMzXCIsXG4gICAgXCIjOTkwMENDXCIsXG4gICAgXCIjOTkwMEZGXCIsXG4gICAgXCIjOTkzM0NDXCIsXG4gICAgXCIjOTkzM0ZGXCIsXG4gICAgXCIjOTlDQzAwXCIsXG4gICAgXCIjOTlDQzMzXCIsXG4gICAgXCIjQ0MwMDAwXCIsXG4gICAgXCIjQ0MwMDMzXCIsXG4gICAgXCIjQ0MwMDY2XCIsXG4gICAgXCIjQ0MwMDk5XCIsXG4gICAgXCIjQ0MwMENDXCIsXG4gICAgXCIjQ0MwMEZGXCIsXG4gICAgXCIjQ0MzMzAwXCIsXG4gICAgXCIjQ0MzMzMzXCIsXG4gICAgXCIjQ0MzMzY2XCIsXG4gICAgXCIjQ0MzMzk5XCIsXG4gICAgXCIjQ0MzM0NDXCIsXG4gICAgXCIjQ0MzM0ZGXCIsXG4gICAgXCIjQ0M2NjAwXCIsXG4gICAgXCIjQ0M2NjMzXCIsXG4gICAgXCIjQ0M5OTAwXCIsXG4gICAgXCIjQ0M5OTMzXCIsXG4gICAgXCIjQ0NDQzAwXCIsXG4gICAgXCIjQ0NDQzMzXCIsXG4gICAgXCIjRkYwMDAwXCIsXG4gICAgXCIjRkYwMDMzXCIsXG4gICAgXCIjRkYwMDY2XCIsXG4gICAgXCIjRkYwMDk5XCIsXG4gICAgXCIjRkYwMENDXCIsXG4gICAgXCIjRkYwMEZGXCIsXG4gICAgXCIjRkYzMzAwXCIsXG4gICAgXCIjRkYzMzMzXCIsXG4gICAgXCIjRkYzMzY2XCIsXG4gICAgXCIjRkYzMzk5XCIsXG4gICAgXCIjRkYzM0NDXCIsXG4gICAgXCIjRkYzM0ZGXCIsXG4gICAgXCIjRkY2NjAwXCIsXG4gICAgXCIjRkY2NjMzXCIsXG4gICAgXCIjRkY5OTAwXCIsXG4gICAgXCIjRkY5OTMzXCIsXG4gICAgXCIjRkZDQzAwXCIsXG4gICAgXCIjRkZDQzMzXCJcbiAgXTtcbiAgZnVuY3Rpb24gcigpIHtcbiAgICByZXR1cm4gdHlwZW9mIHdpbmRvdyA8IFwidVwiICYmIHdpbmRvdy5wcm9jZXNzICYmICh3aW5kb3cucHJvY2Vzcy50eXBlID09PSBcInJlbmRlcmVyXCIgfHwgd2luZG93LnByb2Nlc3MuX19ud2pzKSA/ICEwIDogdHlwZW9mIG5hdmlnYXRvciA8IFwidVwiICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC8oZWRnZXx0cmlkZW50KVxcLyhcXGQrKS8pID8gITEgOiB0eXBlb2YgZG9jdW1lbnQgPCBcInVcIiAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlIHx8IHR5cGVvZiB3aW5kb3cgPCBcInVcIiAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCB3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpIHx8IHR5cGVvZiBuYXZpZ2F0b3IgPCBcInVcIiAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pICYmIHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApID49IDMxIHx8IHR5cGVvZiBuYXZpZ2F0b3IgPCBcInVcIiAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKTtcbiAgfVxuICBmdW5jdGlvbiBuKGMpIHtcbiAgICBpZiAoY1swXSA9ICh0aGlzLnVzZUNvbG9ycyA/IFwiJWNcIiA6IFwiXCIpICsgdGhpcy5uYW1lc3BhY2UgKyAodGhpcy51c2VDb2xvcnMgPyBcIiAlY1wiIDogXCIgXCIpICsgY1swXSArICh0aGlzLnVzZUNvbG9ycyA/IFwiJWMgXCIgOiBcIiBcIikgKyBcIitcIiArIHQuZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpLCAhdGhpcy51c2VDb2xvcnMpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbCA9IFwiY29sb3I6IFwiICsgdGhpcy5jb2xvcjtcbiAgICBjLnNwbGljZSgxLCAwLCBsLCBcImNvbG9yOiBpbmhlcml0XCIpO1xuICAgIGxldCBmID0gMCwgdSA9IDA7XG4gICAgY1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIChoKSA9PiB7XG4gICAgICBoICE9PSBcIiUlXCIgJiYgKGYrKywgaCA9PT0gXCIlY1wiICYmICh1ID0gZikpO1xuICAgIH0pLCBjLnNwbGljZSh1LCAwLCBsKTtcbiAgfVxuICBlLmxvZyA9IGNvbnNvbGUuZGVidWcgfHwgY29uc29sZS5sb2cgfHwgKCgpID0+IHtcbiAgfSk7XG4gIGZ1bmN0aW9uIGkoYykge1xuICAgIHRyeSB7XG4gICAgICBjID8gZS5zdG9yYWdlLnNldEl0ZW0oXCJkZWJ1Z1wiLCBjKSA6IGUuc3RvcmFnZS5yZW1vdmVJdGVtKFwiZGVidWdcIik7XG4gICAgfSBjYXRjaCB7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHMoKSB7XG4gICAgbGV0IGM7XG4gICAgdHJ5IHtcbiAgICAgIGMgPSBlLnN0b3JhZ2UuZ2V0SXRlbShcImRlYnVnXCIpO1xuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgICByZXR1cm4gIWMgJiYgdHlwZW9mIHByb2Nlc3MgPCBcInVcIiAmJiBcImVudlwiIGluIHByb2Nlc3MgJiYgKGMgPSBwcm9jZXNzLmVudi5ERUJVRyksIGM7XG4gIH1cbiAgZnVuY3Rpb24gbygpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGxvY2FsU3RvcmFnZTtcbiAgICB9IGNhdGNoIHtcbiAgICB9XG4gIH1cbiAgdC5leHBvcnRzID0gcGMoZSk7XG4gIGNvbnN0IHsgZm9ybWF0dGVyczogYSB9ID0gdC5leHBvcnRzO1xuICBhLmogPSBmdW5jdGlvbihjKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShjKTtcbiAgICB9IGNhdGNoIChsKSB7XG4gICAgICByZXR1cm4gXCJbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogXCIgKyBsLm1lc3NhZ2U7XG4gICAgfVxuICB9O1xufSkoT24sIE9uLmV4cG9ydHMpO1xuY29uc3QgTW4gPSBPbi5leHBvcnRzO1xudmFyIFpvID0geyBleHBvcnRzOiB7fSB9O1xuKGZ1bmN0aW9uKHQpIHtcbiAgdmFyIGUgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LCByID0gXCJ+XCI7XG4gIGZ1bmN0aW9uIG4oKSB7XG4gIH1cbiAgT2JqZWN0LmNyZWF0ZSAmJiAobi5wcm90b3R5cGUgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSwgbmV3IG4oKS5fX3Byb3RvX18gfHwgKHIgPSAhMSkpO1xuICBmdW5jdGlvbiBpKGMsIGwsIGYpIHtcbiAgICB0aGlzLmZuID0gYywgdGhpcy5jb250ZXh0ID0gbCwgdGhpcy5vbmNlID0gZiB8fCAhMTtcbiAgfVxuICBmdW5jdGlvbiBzKGMsIGwsIGYsIHUsIGgpIHtcbiAgICBpZiAodHlwZW9mIGYgIT0gXCJmdW5jdGlvblwiKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gICAgdmFyIGQgPSBuZXcgaShmLCB1IHx8IGMsIGgpLCBwID0gciA/IHIgKyBsIDogbDtcbiAgICByZXR1cm4gYy5fZXZlbnRzW3BdID8gYy5fZXZlbnRzW3BdLmZuID8gYy5fZXZlbnRzW3BdID0gW2MuX2V2ZW50c1twXSwgZF0gOiBjLl9ldmVudHNbcF0ucHVzaChkKSA6IChjLl9ldmVudHNbcF0gPSBkLCBjLl9ldmVudHNDb3VudCsrKSwgYztcbiAgfVxuICBmdW5jdGlvbiBvKGMsIGwpIHtcbiAgICAtLWMuX2V2ZW50c0NvdW50ID09PSAwID8gYy5fZXZlbnRzID0gbmV3IG4oKSA6IGRlbGV0ZSBjLl9ldmVudHNbbF07XG4gIH1cbiAgZnVuY3Rpb24gYSgpIHtcbiAgICB0aGlzLl9ldmVudHMgPSBuZXcgbigpLCB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cbiAgYS5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBsID0gW10sIGYsIHU7XG4gICAgaWYgKHRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgcmV0dXJuIGw7XG4gICAgZm9yICh1IGluIGYgPSB0aGlzLl9ldmVudHMpXG4gICAgICBlLmNhbGwoZiwgdSkgJiYgbC5wdXNoKHIgPyB1LnNsaWNlKDEpIDogdSk7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBsLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGYpKSA6IGw7XG4gIH0sIGEucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKGwpIHtcbiAgICB2YXIgZiA9IHIgPyByICsgbCA6IGwsIHUgPSB0aGlzLl9ldmVudHNbZl07XG4gICAgaWYgKCF1KVxuICAgICAgcmV0dXJuIFtdO1xuICAgIGlmICh1LmZuKVxuICAgICAgcmV0dXJuIFt1LmZuXTtcbiAgICBmb3IgKHZhciBoID0gMCwgZCA9IHUubGVuZ3RoLCBwID0gbmV3IEFycmF5KGQpOyBoIDwgZDsgaCsrKVxuICAgICAgcFtoXSA9IHVbaF0uZm47XG4gICAgcmV0dXJuIHA7XG4gIH0sIGEucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihsKSB7XG4gICAgdmFyIGYgPSByID8gciArIGwgOiBsLCB1ID0gdGhpcy5fZXZlbnRzW2ZdO1xuICAgIHJldHVybiB1ID8gdS5mbiA/IDEgOiB1Lmxlbmd0aCA6IDA7XG4gIH0sIGEucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihsLCBmLCB1LCBoLCBkLCBwKSB7XG4gICAgdmFyIHkgPSByID8gciArIGwgOiBsO1xuICAgIGlmICghdGhpcy5fZXZlbnRzW3ldKVxuICAgICAgcmV0dXJuICExO1xuICAgIHZhciBnID0gdGhpcy5fZXZlbnRzW3ldLCB2ID0gYXJndW1lbnRzLmxlbmd0aCwgXywgbTtcbiAgICBpZiAoZy5mbikge1xuICAgICAgc3dpdGNoIChnLm9uY2UgJiYgdGhpcy5yZW1vdmVMaXN0ZW5lcihsLCBnLmZuLCB2b2lkIDAsICEwKSwgdikge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcmV0dXJuIGcuZm4uY2FsbChnLmNvbnRleHQpLCAhMDtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHJldHVybiBnLmZuLmNhbGwoZy5jb250ZXh0LCBmKSwgITA7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICByZXR1cm4gZy5mbi5jYWxsKGcuY29udGV4dCwgZiwgdSksICEwO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgcmV0dXJuIGcuZm4uY2FsbChnLmNvbnRleHQsIGYsIHUsIGgpLCAhMDtcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHJldHVybiBnLmZuLmNhbGwoZy5jb250ZXh0LCBmLCB1LCBoLCBkKSwgITA7XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgICByZXR1cm4gZy5mbi5jYWxsKGcuY29udGV4dCwgZiwgdSwgaCwgZCwgcCksICEwO1xuICAgICAgfVxuICAgICAgZm9yIChtID0gMSwgXyA9IG5ldyBBcnJheSh2IC0gMSk7IG0gPCB2OyBtKyspXG4gICAgICAgIF9bbSAtIDFdID0gYXJndW1lbnRzW21dO1xuICAgICAgZy5mbi5hcHBseShnLmNvbnRleHQsIF8pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgQyA9IGcubGVuZ3RoLCBPO1xuICAgICAgZm9yIChtID0gMDsgbSA8IEM7IG0rKylcbiAgICAgICAgc3dpdGNoIChnW21dLm9uY2UgJiYgdGhpcy5yZW1vdmVMaXN0ZW5lcihsLCBnW21dLmZuLCB2b2lkIDAsICEwKSwgdikge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGdbbV0uZm4uY2FsbChnW21dLmNvbnRleHQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgZ1ttXS5mbi5jYWxsKGdbbV0uY29udGV4dCwgZik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBnW21dLmZuLmNhbGwoZ1ttXS5jb250ZXh0LCBmLCB1KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIGdbbV0uZm4uY2FsbChnW21dLmNvbnRleHQsIGYsIHUsIGgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmICghXylcbiAgICAgICAgICAgICAgZm9yIChPID0gMSwgXyA9IG5ldyBBcnJheSh2IC0gMSk7IE8gPCB2OyBPKyspXG4gICAgICAgICAgICAgICAgX1tPIC0gMV0gPSBhcmd1bWVudHNbT107XG4gICAgICAgICAgICBnW21dLmZuLmFwcGx5KGdbbV0uY29udGV4dCwgXyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICEwO1xuICB9LCBhLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKGwsIGYsIHUpIHtcbiAgICByZXR1cm4gcyh0aGlzLCBsLCBmLCB1LCAhMSk7XG4gIH0sIGEucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbihsLCBmLCB1KSB7XG4gICAgcmV0dXJuIHModGhpcywgbCwgZiwgdSwgITApO1xuICB9LCBhLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKGwsIGYsIHUsIGgpIHtcbiAgICB2YXIgZCA9IHIgPyByICsgbCA6IGw7XG4gICAgaWYgKCF0aGlzLl9ldmVudHNbZF0pXG4gICAgICByZXR1cm4gdGhpcztcbiAgICBpZiAoIWYpXG4gICAgICByZXR1cm4gbyh0aGlzLCBkKSwgdGhpcztcbiAgICB2YXIgcCA9IHRoaXMuX2V2ZW50c1tkXTtcbiAgICBpZiAocC5mbilcbiAgICAgIHAuZm4gPT09IGYgJiYgKCFoIHx8IHAub25jZSkgJiYgKCF1IHx8IHAuY29udGV4dCA9PT0gdSkgJiYgbyh0aGlzLCBkKTtcbiAgICBlbHNlIHtcbiAgICAgIGZvciAodmFyIHkgPSAwLCBnID0gW10sIHYgPSBwLmxlbmd0aDsgeSA8IHY7IHkrKylcbiAgICAgICAgKHBbeV0uZm4gIT09IGYgfHwgaCAmJiAhcFt5XS5vbmNlIHx8IHUgJiYgcFt5XS5jb250ZXh0ICE9PSB1KSAmJiBnLnB1c2gocFt5XSk7XG4gICAgICBnLmxlbmd0aCA/IHRoaXMuX2V2ZW50c1tkXSA9IGcubGVuZ3RoID09PSAxID8gZ1swXSA6IGcgOiBvKHRoaXMsIGQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSwgYS5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24obCkge1xuICAgIHZhciBmO1xuICAgIHJldHVybiBsID8gKGYgPSByID8gciArIGwgOiBsLCB0aGlzLl9ldmVudHNbZl0gJiYgbyh0aGlzLCBmKSkgOiAodGhpcy5fZXZlbnRzID0gbmV3IG4oKSwgdGhpcy5fZXZlbnRzQ291bnQgPSAwKSwgdGhpcztcbiAgfSwgYS5wcm90b3R5cGUub2ZmID0gYS5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIsIGEucHJvdG90eXBlLmFkZExpc3RlbmVyID0gYS5wcm90b3R5cGUub24sIGEucHJlZml4ZWQgPSByLCBhLkV2ZW50RW1pdHRlciA9IGEsIHQuZXhwb3J0cyA9IGE7XG59KShabyk7XG5jb25zdCBkdCA9IFpvLmV4cG9ydHM7XG5mdW5jdGlvbiBBbih0KSB7XG4gIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIodCkgfHwgdCA8IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKGBXcm9uZyBwb3NpdGl2ZSBpbnRlZ2VyOiAke3R9YCk7XG59XG5mdW5jdGlvbiB5Yyh0KSB7XG4gIGlmICh0eXBlb2YgdCAhPSBcImJvb2xlYW5cIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGJvb2xlYW4sIG5vdCAke3R9YCk7XG59XG5mdW5jdGlvbiBZbyh0LCAuLi5lKSB7XG4gIGlmICghKHQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgVWludDhBcnJheVwiKTtcbiAgaWYgKGUubGVuZ3RoID4gMCAmJiAhZS5pbmNsdWRlcyh0Lmxlbmd0aCkpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgVWludDhBcnJheSBvZiBsZW5ndGggJHtlfSwgbm90IG9mIGxlbmd0aD0ke3QubGVuZ3RofWApO1xufVxuZnVuY3Rpb24gZ2ModCkge1xuICBpZiAodHlwZW9mIHQgIT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiB0LmNyZWF0ZSAhPSBcImZ1bmN0aW9uXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSGFzaCBzaG91bGQgYmUgd3JhcHBlZCBieSB1dGlscy53cmFwQ29uc3RydWN0b3JcIik7XG4gIEFuKHQub3V0cHV0TGVuKSwgQW4odC5ibG9ja0xlbik7XG59XG5mdW5jdGlvbiBiYyh0LCBlID0gITApIHtcbiAgaWYgKHQuZGVzdHJveWVkKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkhhc2ggaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkXCIpO1xuICBpZiAoZSAmJiB0LmZpbmlzaGVkKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkhhc2gjZGlnZXN0KCkgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWRcIik7XG59XG5mdW5jdGlvbiB2Yyh0LCBlKSB7XG4gIFlvKHQpO1xuICBjb25zdCByID0gZS5vdXRwdXRMZW47XG4gIGlmICh0Lmxlbmd0aCA8IHIpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBkaWdlc3RJbnRvKCkgZXhwZWN0cyBvdXRwdXQgYnVmZmVyIG9mIGxlbmd0aCBhdCBsZWFzdCAke3J9YCk7XG59XG5jb25zdCB1dCA9IHtcbiAgbnVtYmVyOiBBbixcbiAgYm9vbDogeWMsXG4gIGJ5dGVzOiBZbyxcbiAgaGFzaDogZ2MsXG4gIGV4aXN0czogYmMsXG4gIG91dHB1dDogdmNcbn0sIHRuID0gdHlwZW9mIGdsb2JhbFRoaXMgPT0gXCJvYmplY3RcIiAmJiBcImNyeXB0b1wiIGluIGdsb2JhbFRoaXMgPyBnbG9iYWxUaGlzLmNyeXB0byA6IHZvaWQgMDtcbi8qISBub2JsZS1oYXNoZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmNvbnN0IHJuID0gKHQpID0+IG5ldyBEYXRhVmlldyh0LmJ1ZmZlciwgdC5ieXRlT2Zmc2V0LCB0LmJ5dGVMZW5ndGgpLCBBZSA9ICh0LCBlKSA9PiB0IDw8IDMyIC0gZSB8IHQgPj4+IGUsIHdjID0gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQzMkFycmF5KFsyODc0NTQwMjBdKS5idWZmZXIpWzBdID09PSA2ODtcbmlmICghd2MpXG4gIHRocm93IG5ldyBFcnJvcihcIk5vbiBsaXR0bGUtZW5kaWFuIGhhcmR3YXJlIGlzIG5vdCBzdXBwb3J0ZWRcIik7XG5BcnJheS5mcm9tKHsgbGVuZ3RoOiAyNTYgfSwgKHQsIGUpID0+IGUudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKSk7XG5mdW5jdGlvbiBfYyh0KSB7XG4gIGlmICh0eXBlb2YgdCAhPSBcInN0cmluZ1wiKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHV0ZjhUb0J5dGVzIGV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIHR9YCk7XG4gIHJldHVybiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUodCk7XG59XG5mdW5jdGlvbiBEbih0KSB7XG4gIGlmICh0eXBlb2YgdCA9PSBcInN0cmluZ1wiICYmICh0ID0gX2ModCkpLCAhKHQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBpbnB1dCB0eXBlIGlzIFVpbnQ4QXJyYXkgKGdvdCAke3R5cGVvZiB0fSlgKTtcbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBtYyguLi50KSB7XG4gIGlmICghdC5ldmVyeSgobikgPT4gbiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgIHRocm93IG5ldyBFcnJvcihcIlVpbnQ4QXJyYXkgbGlzdCBleHBlY3RlZFwiKTtcbiAgaWYgKHQubGVuZ3RoID09PSAxKVxuICAgIHJldHVybiB0WzBdO1xuICBjb25zdCBlID0gdC5yZWR1Y2UoKG4sIGkpID0+IG4gKyBpLmxlbmd0aCwgMCksIHIgPSBuZXcgVWludDhBcnJheShlKTtcbiAgZm9yIChsZXQgbiA9IDAsIGkgPSAwOyBuIDwgdC5sZW5ndGg7IG4rKykge1xuICAgIGNvbnN0IHMgPSB0W25dO1xuICAgIHIuc2V0KHMsIGkpLCBpICs9IHMubGVuZ3RoO1xuICB9XG4gIHJldHVybiByO1xufVxuY2xhc3MgSm8ge1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2xvbmVJbnRvKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIFhvKHQpIHtcbiAgY29uc3QgZSA9IChuKSA9PiB0KCkudXBkYXRlKERuKG4pKS5kaWdlc3QoKSwgciA9IHQoKTtcbiAgcmV0dXJuIGUub3V0cHV0TGVuID0gci5vdXRwdXRMZW4sIGUuYmxvY2tMZW4gPSByLmJsb2NrTGVuLCBlLmNyZWF0ZSA9ICgpID0+IHQoKSwgZTtcbn1cbmZ1bmN0aW9uIFFvKHQgPSAzMikge1xuICBpZiAodG4gJiYgdHlwZW9mIHRuLmdldFJhbmRvbVZhbHVlcyA9PSBcImZ1bmN0aW9uXCIpXG4gICAgcmV0dXJuIHRuLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheSh0KSk7XG4gIHRocm93IG5ldyBFcnJvcihcImNyeXB0by5nZXRSYW5kb21WYWx1ZXMgbXVzdCBiZSBkZWZpbmVkXCIpO1xufVxuZnVuY3Rpb24geGModCwgZSwgciwgbikge1xuICBpZiAodHlwZW9mIHQuc2V0QmlnVWludDY0ID09IFwiZnVuY3Rpb25cIilcbiAgICByZXR1cm4gdC5zZXRCaWdVaW50NjQoZSwgciwgbik7XG4gIGNvbnN0IGkgPSBCaWdJbnQoMzIpLCBzID0gQmlnSW50KDQyOTQ5NjcyOTUpLCBvID0gTnVtYmVyKHIgPj4gaSAmIHMpLCBhID0gTnVtYmVyKHIgJiBzKSwgYyA9IG4gPyA0IDogMCwgbCA9IG4gPyAwIDogNDtcbiAgdC5zZXRVaW50MzIoZSArIGMsIG8sIG4pLCB0LnNldFVpbnQzMihlICsgbCwgYSwgbik7XG59XG5jbGFzcyBFYyBleHRlbmRzIEpvIHtcbiAgY29uc3RydWN0b3IoZSwgciwgbiwgaSkge1xuICAgIHN1cGVyKCksIHRoaXMuYmxvY2tMZW4gPSBlLCB0aGlzLm91dHB1dExlbiA9IHIsIHRoaXMucGFkT2Zmc2V0ID0gbiwgdGhpcy5pc0xFID0gaSwgdGhpcy5maW5pc2hlZCA9ICExLCB0aGlzLmxlbmd0aCA9IDAsIHRoaXMucG9zID0gMCwgdGhpcy5kZXN0cm95ZWQgPSAhMSwgdGhpcy5idWZmZXIgPSBuZXcgVWludDhBcnJheShlKSwgdGhpcy52aWV3ID0gcm4odGhpcy5idWZmZXIpO1xuICB9XG4gIHVwZGF0ZShlKSB7XG4gICAgdXQuZXhpc3RzKHRoaXMpO1xuICAgIGNvbnN0IHsgdmlldzogciwgYnVmZmVyOiBuLCBibG9ja0xlbjogaSB9ID0gdGhpcztcbiAgICBlID0gRG4oZSk7XG4gICAgY29uc3QgcyA9IGUubGVuZ3RoO1xuICAgIGZvciAobGV0IG8gPSAwOyBvIDwgczsgKSB7XG4gICAgICBjb25zdCBhID0gTWF0aC5taW4oaSAtIHRoaXMucG9zLCBzIC0gbyk7XG4gICAgICBpZiAoYSA9PT0gaSkge1xuICAgICAgICBjb25zdCBjID0gcm4oZSk7XG4gICAgICAgIGZvciAoOyBpIDw9IHMgLSBvOyBvICs9IGkpXG4gICAgICAgICAgdGhpcy5wcm9jZXNzKGMsIG8pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIG4uc2V0KGUuc3ViYXJyYXkobywgbyArIGEpLCB0aGlzLnBvcyksIHRoaXMucG9zICs9IGEsIG8gKz0gYSwgdGhpcy5wb3MgPT09IGkgJiYgKHRoaXMucHJvY2VzcyhyLCAwKSwgdGhpcy5wb3MgPSAwKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubGVuZ3RoICs9IGUubGVuZ3RoLCB0aGlzLnJvdW5kQ2xlYW4oKSwgdGhpcztcbiAgfVxuICBkaWdlc3RJbnRvKGUpIHtcbiAgICB1dC5leGlzdHModGhpcyksIHV0Lm91dHB1dChlLCB0aGlzKSwgdGhpcy5maW5pc2hlZCA9ICEwO1xuICAgIGNvbnN0IHsgYnVmZmVyOiByLCB2aWV3OiBuLCBibG9ja0xlbjogaSwgaXNMRTogcyB9ID0gdGhpcztcbiAgICBsZXQgeyBwb3M6IG8gfSA9IHRoaXM7XG4gICAgcltvKytdID0gMTI4LCB0aGlzLmJ1ZmZlci5zdWJhcnJheShvKS5maWxsKDApLCB0aGlzLnBhZE9mZnNldCA+IGkgLSBvICYmICh0aGlzLnByb2Nlc3MobiwgMCksIG8gPSAwKTtcbiAgICBmb3IgKGxldCB1ID0gbzsgdSA8IGk7IHUrKylcbiAgICAgIHJbdV0gPSAwO1xuICAgIHhjKG4sIGkgLSA4LCBCaWdJbnQodGhpcy5sZW5ndGggKiA4KSwgcyksIHRoaXMucHJvY2VzcyhuLCAwKTtcbiAgICBjb25zdCBhID0gcm4oZSksIGMgPSB0aGlzLm91dHB1dExlbjtcbiAgICBpZiAoYyAlIDQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJfc2hhMjogb3V0cHV0TGVuIHNob3VsZCBiZSBhbGlnbmVkIHRvIDMyYml0XCIpO1xuICAgIGNvbnN0IGwgPSBjIC8gNCwgZiA9IHRoaXMuZ2V0KCk7XG4gICAgaWYgKGwgPiBmLmxlbmd0aClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIl9zaGEyOiBvdXRwdXRMZW4gYmlnZ2VyIHRoYW4gc3RhdGVcIik7XG4gICAgZm9yIChsZXQgdSA9IDA7IHUgPCBsOyB1KyspXG4gICAgICBhLnNldFVpbnQzMig0ICogdSwgZlt1XSwgcyk7XG4gIH1cbiAgZGlnZXN0KCkge1xuICAgIGNvbnN0IHsgYnVmZmVyOiBlLCBvdXRwdXRMZW46IHIgfSA9IHRoaXM7XG4gICAgdGhpcy5kaWdlc3RJbnRvKGUpO1xuICAgIGNvbnN0IG4gPSBlLnNsaWNlKDAsIHIpO1xuICAgIHJldHVybiB0aGlzLmRlc3Ryb3koKSwgbjtcbiAgfVxuICBfY2xvbmVJbnRvKGUpIHtcbiAgICBlIHx8IChlID0gbmV3IHRoaXMuY29uc3RydWN0b3IoKSksIGUuc2V0KC4uLnRoaXMuZ2V0KCkpO1xuICAgIGNvbnN0IHsgYmxvY2tMZW46IHIsIGJ1ZmZlcjogbiwgbGVuZ3RoOiBpLCBmaW5pc2hlZDogcywgZGVzdHJveWVkOiBvLCBwb3M6IGEgfSA9IHRoaXM7XG4gICAgcmV0dXJuIGUubGVuZ3RoID0gaSwgZS5wb3MgPSBhLCBlLmZpbmlzaGVkID0gcywgZS5kZXN0cm95ZWQgPSBvLCBpICUgciAmJiBlLmJ1ZmZlci5zZXQobiksIGU7XG4gIH1cbn1cbmNvbnN0IGtjID0gKHQsIGUsIHIpID0+IHQgJiBlIF4gfnQgJiByLCBTYyA9ICh0LCBlLCByKSA9PiB0ICYgZSBeIHQgJiByIF4gZSAmIHIsIE9jID0gbmV3IFVpbnQzMkFycmF5KFtcbiAgMTExNjM1MjQwOCxcbiAgMTg5OTQ0NzQ0MSxcbiAgMzA0OTMyMzQ3MSxcbiAgMzkyMTAwOTU3MyxcbiAgOTYxOTg3MTYzLFxuICAxNTA4OTcwOTkzLFxuICAyNDUzNjM1NzQ4LFxuICAyODcwNzYzMjIxLFxuICAzNjI0MzgxMDgwLFxuICAzMTA1OTg0MDEsXG4gIDYwNzIyNTI3OCxcbiAgMTQyNjg4MTk4NyxcbiAgMTkyNTA3ODM4OCxcbiAgMjE2MjA3ODIwNixcbiAgMjYxNDg4ODEwMyxcbiAgMzI0ODIyMjU4MCxcbiAgMzgzNTM5MDQwMSxcbiAgNDAyMjIyNDc3NCxcbiAgMjY0MzQ3MDc4LFxuICA2MDQ4MDc2MjgsXG4gIDc3MDI1NTk4MyxcbiAgMTI0OTE1MDEyMixcbiAgMTU1NTA4MTY5MixcbiAgMTk5NjA2NDk4NixcbiAgMjU1NDIyMDg4MixcbiAgMjgyMTgzNDM0OSxcbiAgMjk1Mjk5NjgwOCxcbiAgMzIxMDMxMzY3MSxcbiAgMzMzNjU3MTg5MSxcbiAgMzU4NDUyODcxMSxcbiAgMTEzOTI2OTkzLFxuICAzMzgyNDE4OTUsXG4gIDY2NjMwNzIwNSxcbiAgNzczNTI5OTEyLFxuICAxMjk0NzU3MzcyLFxuICAxMzk2MTgyMjkxLFxuICAxNjk1MTgzNzAwLFxuICAxOTg2NjYxMDUxLFxuICAyMTc3MDI2MzUwLFxuICAyNDU2OTU2MDM3LFxuICAyNzMwNDg1OTIxLFxuICAyODIwMzAyNDExLFxuICAzMjU5NzMwODAwLFxuICAzMzQ1NzY0NzcxLFxuICAzNTE2MDY1ODE3LFxuICAzNjAwMzUyODA0LFxuICA0MDk0NTcxOTA5LFxuICAyNzU0MjMzNDQsXG4gIDQzMDIyNzczNCxcbiAgNTA2OTQ4NjE2LFxuICA2NTkwNjA1NTYsXG4gIDg4Mzk5Nzg3NyxcbiAgOTU4MTM5NTcxLFxuICAxMzIyODIyMjE4LFxuICAxNTM3MDAyMDYzLFxuICAxNzQ3ODczNzc5LFxuICAxOTU1NTYyMjIyLFxuICAyMDI0MTA0ODE1LFxuICAyMjI3NzMwNDUyLFxuICAyMzYxODUyNDI0LFxuICAyNDI4NDM2NDc0LFxuICAyNzU2NzM0MTg3LFxuICAzMjA0MDMxNDc5LFxuICAzMzI5MzI1Mjk4XG5dKSwgTWUgPSBuZXcgVWludDMyQXJyYXkoW1xuICAxNzc5MDMzNzAzLFxuICAzMTQ0MTM0Mjc3LFxuICAxMDEzOTA0MjQyLFxuICAyNzczNDgwNzYyLFxuICAxMzU5ODkzMTE5LFxuICAyNjAwODIyOTI0LFxuICA1Mjg3MzQ2MzUsXG4gIDE1NDE0NTkyMjVcbl0pLCBEZSA9IG5ldyBVaW50MzJBcnJheSg2NCk7XG5jbGFzcyBlcyBleHRlbmRzIEVjIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoNjQsIDMyLCA4LCAhMSksIHRoaXMuQSA9IE1lWzBdIHwgMCwgdGhpcy5CID0gTWVbMV0gfCAwLCB0aGlzLkMgPSBNZVsyXSB8IDAsIHRoaXMuRCA9IE1lWzNdIHwgMCwgdGhpcy5FID0gTWVbNF0gfCAwLCB0aGlzLkYgPSBNZVs1XSB8IDAsIHRoaXMuRyA9IE1lWzZdIHwgMCwgdGhpcy5IID0gTWVbN10gfCAwO1xuICB9XG4gIGdldCgpIHtcbiAgICBjb25zdCB7IEE6IGUsIEI6IHIsIEM6IG4sIEQ6IGksIEU6IHMsIEY6IG8sIEc6IGEsIEg6IGMgfSA9IHRoaXM7XG4gICAgcmV0dXJuIFtlLCByLCBuLCBpLCBzLCBvLCBhLCBjXTtcbiAgfVxuICBzZXQoZSwgciwgbiwgaSwgcywgbywgYSwgYykge1xuICAgIHRoaXMuQSA9IGUgfCAwLCB0aGlzLkIgPSByIHwgMCwgdGhpcy5DID0gbiB8IDAsIHRoaXMuRCA9IGkgfCAwLCB0aGlzLkUgPSBzIHwgMCwgdGhpcy5GID0gbyB8IDAsIHRoaXMuRyA9IGEgfCAwLCB0aGlzLkggPSBjIHwgMDtcbiAgfVxuICBwcm9jZXNzKGUsIHIpIHtcbiAgICBmb3IgKGxldCB1ID0gMDsgdSA8IDE2OyB1KyssIHIgKz0gNClcbiAgICAgIERlW3VdID0gZS5nZXRVaW50MzIociwgITEpO1xuICAgIGZvciAobGV0IHUgPSAxNjsgdSA8IDY0OyB1KyspIHtcbiAgICAgIGNvbnN0IGggPSBEZVt1IC0gMTVdLCBkID0gRGVbdSAtIDJdLCBwID0gQWUoaCwgNykgXiBBZShoLCAxOCkgXiBoID4+PiAzLCB5ID0gQWUoZCwgMTcpIF4gQWUoZCwgMTkpIF4gZCA+Pj4gMTA7XG4gICAgICBEZVt1XSA9IHkgKyBEZVt1IC0gN10gKyBwICsgRGVbdSAtIDE2XSB8IDA7XG4gICAgfVxuICAgIGxldCB7IEE6IG4sIEI6IGksIEM6IHMsIEQ6IG8sIEU6IGEsIEY6IGMsIEc6IGwsIEg6IGYgfSA9IHRoaXM7XG4gICAgZm9yIChsZXQgdSA9IDA7IHUgPCA2NDsgdSsrKSB7XG4gICAgICBjb25zdCBoID0gQWUoYSwgNikgXiBBZShhLCAxMSkgXiBBZShhLCAyNSksIGQgPSBmICsgaCArIGtjKGEsIGMsIGwpICsgT2NbdV0gKyBEZVt1XSB8IDAsIHkgPSAoQWUobiwgMikgXiBBZShuLCAxMykgXiBBZShuLCAyMikpICsgU2MobiwgaSwgcykgfCAwO1xuICAgICAgZiA9IGwsIGwgPSBjLCBjID0gYSwgYSA9IG8gKyBkIHwgMCwgbyA9IHMsIHMgPSBpLCBpID0gbiwgbiA9IGQgKyB5IHwgMDtcbiAgICB9XG4gICAgbiA9IG4gKyB0aGlzLkEgfCAwLCBpID0gaSArIHRoaXMuQiB8IDAsIHMgPSBzICsgdGhpcy5DIHwgMCwgbyA9IG8gKyB0aGlzLkQgfCAwLCBhID0gYSArIHRoaXMuRSB8IDAsIGMgPSBjICsgdGhpcy5GIHwgMCwgbCA9IGwgKyB0aGlzLkcgfCAwLCBmID0gZiArIHRoaXMuSCB8IDAsIHRoaXMuc2V0KG4sIGksIHMsIG8sIGEsIGMsIGwsIGYpO1xuICB9XG4gIHJvdW5kQ2xlYW4oKSB7XG4gICAgRGUuZmlsbCgwKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApLCB0aGlzLmJ1ZmZlci5maWxsKDApO1xuICB9XG59XG5jbGFzcyBBYyBleHRlbmRzIGVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKSwgdGhpcy5BID0gLTEwNTY1OTYyNjQsIHRoaXMuQiA9IDkxNDE1MDY2MywgdGhpcy5DID0gODEyNzAyOTk5LCB0aGlzLkQgPSAtMTUwMDU0NTk5LCB0aGlzLkUgPSAtNDE5MTQzOSwgdGhpcy5GID0gMTc1MDYwMzAyNSwgdGhpcy5HID0gMTY5NDA3NjgzOSwgdGhpcy5IID0gLTEwOTA4OTE4NjgsIHRoaXMub3V0cHV0TGVuID0gMjg7XG4gIH1cbn1cbmNvbnN0IE9yID0gWG8oKCkgPT4gbmV3IGVzKCkpO1xuWG8oKCkgPT4gbmV3IEFjKCkpO1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuY29uc3QgdHMgPSBCaWdJbnQoMCksIExyID0gQmlnSW50KDEpLCBDYyA9IEJpZ0ludCgyKSwgJHIgPSAodCkgPT4gdCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXksIEljID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sICh0LCBlKSA9PiBlLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIikpO1xuZnVuY3Rpb24gdnQodCkge1xuICBpZiAoISRyKHQpKVxuICAgIHRocm93IG5ldyBFcnJvcihcIlVpbnQ4QXJyYXkgZXhwZWN0ZWRcIik7XG4gIGxldCBlID0gXCJcIjtcbiAgZm9yIChsZXQgciA9IDA7IHIgPCB0Lmxlbmd0aDsgcisrKVxuICAgIGUgKz0gSWNbdFtyXV07XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gcnModCkge1xuICBjb25zdCBlID0gdC50b1N0cmluZygxNik7XG4gIHJldHVybiBlLmxlbmd0aCAmIDEgPyBgMCR7ZX1gIDogZTtcbn1cbmZ1bmN0aW9uIHpuKHQpIHtcbiAgaWYgKHR5cGVvZiB0ICE9IFwic3RyaW5nXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IFwiICsgdHlwZW9mIHQpO1xuICByZXR1cm4gQmlnSW50KHQgPT09IFwiXCIgPyBcIjBcIiA6IGAweCR7dH1gKTtcbn1cbmZ1bmN0aW9uIHd0KHQpIHtcbiAgaWYgKHR5cGVvZiB0ICE9IFwic3RyaW5nXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IFwiICsgdHlwZW9mIHQpO1xuICBpZiAodC5sZW5ndGggJSAyKVxuICAgIHRocm93IG5ldyBFcnJvcihcImhleCBzdHJpbmcgaXMgaW52YWxpZDogdW5wYWRkZWQgXCIgKyB0Lmxlbmd0aCk7XG4gIGNvbnN0IGUgPSBuZXcgVWludDhBcnJheSh0Lmxlbmd0aCAvIDIpO1xuICBmb3IgKGxldCByID0gMDsgciA8IGUubGVuZ3RoOyByKyspIHtcbiAgICBjb25zdCBuID0gciAqIDIsIGkgPSB0LnNsaWNlKG4sIG4gKyAyKSwgcyA9IE51bWJlci5wYXJzZUludChpLCAxNik7XG4gICAgaWYgKE51bWJlci5pc05hTihzKSB8fCBzIDwgMClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYnl0ZSBzZXF1ZW5jZVwiKTtcbiAgICBlW3JdID0gcztcbiAgfVxuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIGxlKHQpIHtcbiAgcmV0dXJuIHpuKHZ0KHQpKTtcbn1cbmZ1bmN0aW9uIEZuKHQpIHtcbiAgaWYgKCEkcih0KSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVaW50OEFycmF5IGV4cGVjdGVkXCIpO1xuICByZXR1cm4gem4odnQoVWludDhBcnJheS5mcm9tKHQpLnJldmVyc2UoKSkpO1xufVxuY29uc3QgZXQgPSAodCwgZSkgPT4gd3QodC50b1N0cmluZygxNikucGFkU3RhcnQoZSAqIDIsIFwiMFwiKSksIG5zID0gKHQsIGUpID0+IGV0KHQsIGUpLnJldmVyc2UoKSwgUmMgPSAodCkgPT4gd3QocnModCkpO1xuZnVuY3Rpb24gZWUodCwgZSwgcikge1xuICBsZXQgbjtcbiAgaWYgKHR5cGVvZiBlID09IFwic3RyaW5nXCIpXG4gICAgdHJ5IHtcbiAgICAgIG4gPSB3dChlKTtcbiAgICB9IGNhdGNoIChzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dH0gbXVzdCBiZSB2YWxpZCBoZXggc3RyaW5nLCBnb3QgXCIke2V9XCIuIENhdXNlOiAke3N9YCk7XG4gICAgfVxuICBlbHNlIGlmICgkcihlKSlcbiAgICBuID0gVWludDhBcnJheS5mcm9tKGUpO1xuICBlbHNlXG4gICAgdGhyb3cgbmV3IEVycm9yKGAke3R9IG11c3QgYmUgaGV4IHN0cmluZyBvciBVaW50OEFycmF5YCk7XG4gIGNvbnN0IGkgPSBuLmxlbmd0aDtcbiAgaWYgKHR5cGVvZiByID09IFwibnVtYmVyXCIgJiYgaSAhPT0gcilcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dH0gZXhwZWN0ZWQgJHtyfSBieXRlcywgZ290ICR7aX1gKTtcbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBoZSguLi50KSB7XG4gIGNvbnN0IGUgPSBuZXcgVWludDhBcnJheSh0LnJlZHVjZSgobiwgaSkgPT4gbiArIGkubGVuZ3RoLCAwKSk7XG4gIGxldCByID0gMDtcbiAgcmV0dXJuIHQuZm9yRWFjaCgobikgPT4ge1xuICAgIGlmICghJHIobikpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVaW50OEFycmF5IGV4cGVjdGVkXCIpO1xuICAgIGUuc2V0KG4sIHIpLCByICs9IG4ubGVuZ3RoO1xuICB9KSwgZTtcbn1cbmZ1bmN0aW9uIFRjKHQsIGUpIHtcbiAgaWYgKHQubGVuZ3RoICE9PSBlLmxlbmd0aClcbiAgICByZXR1cm4gITE7XG4gIGZvciAobGV0IHIgPSAwOyByIDwgdC5sZW5ndGg7IHIrKylcbiAgICBpZiAodFtyXSAhPT0gZVtyXSlcbiAgICAgIHJldHVybiAhMTtcbiAgcmV0dXJuICEwO1xufVxuZnVuY3Rpb24gcXIodCkge1xuICBpZiAodHlwZW9mIHQgIT0gXCJzdHJpbmdcIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHV0ZjhUb0J5dGVzIGV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIHR9YCk7XG4gIHJldHVybiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUodCk7XG59XG5mdW5jdGlvbiBQYyh0KSB7XG4gIGxldCBlO1xuICBmb3IgKGUgPSAwOyB0ID4gdHM7IHQgPj49IExyLCBlICs9IDEpXG4gICAgO1xuICByZXR1cm4gZTtcbn1cbmNvbnN0IEJjID0gKHQsIGUpID0+IHQgPj4gQmlnSW50KGUpICYgTHIsIExjID0gKHQsIGUsIHIpID0+IHQgfCAociA/IExyIDogdHMpIDw8IEJpZ0ludChlKSwgS24gPSAodCkgPT4gKENjIDw8IEJpZ0ludCh0IC0gMSkpIC0gTHIsIG5uID0gKHQpID0+IG5ldyBVaW50OEFycmF5KHQpLCBOaSA9ICh0KSA9PiBVaW50OEFycmF5LmZyb20odCk7XG5mdW5jdGlvbiBpcyh0LCBlLCByKSB7XG4gIGlmICh0eXBlb2YgdCAhPSBcIm51bWJlclwiIHx8IHQgPCAyKVxuICAgIHRocm93IG5ldyBFcnJvcihcImhhc2hMZW4gbXVzdCBiZSBhIG51bWJlclwiKTtcbiAgaWYgKHR5cGVvZiBlICE9IFwibnVtYmVyXCIgfHwgZSA8IDIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwicUJ5dGVMZW4gbXVzdCBiZSBhIG51bWJlclwiKTtcbiAgaWYgKHR5cGVvZiByICE9IFwiZnVuY3Rpb25cIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJobWFjRm4gbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICBsZXQgbiA9IG5uKHQpLCBpID0gbm4odCksIHMgPSAwO1xuICBjb25zdCBvID0gKCkgPT4ge1xuICAgIG4uZmlsbCgxKSwgaS5maWxsKDApLCBzID0gMDtcbiAgfSwgYSA9ICguLi51KSA9PiByKGksIG4sIC4uLnUpLCBjID0gKHUgPSBubigpKSA9PiB7XG4gICAgaSA9IGEoTmkoWzBdKSwgdSksIG4gPSBhKCksIHUubGVuZ3RoICE9PSAwICYmIChpID0gYShOaShbMV0pLCB1KSwgbiA9IGEoKSk7XG4gIH0sIGwgPSAoKSA9PiB7XG4gICAgaWYgKHMrKyA+PSAxZTMpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkcmJnOiB0cmllZCAxMDAwIHZhbHVlc1wiKTtcbiAgICBsZXQgdSA9IDA7XG4gICAgY29uc3QgaCA9IFtdO1xuICAgIGZvciAoOyB1IDwgZTsgKSB7XG4gICAgICBuID0gYSgpO1xuICAgICAgY29uc3QgZCA9IG4uc2xpY2UoKTtcbiAgICAgIGgucHVzaChkKSwgdSArPSBuLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIGhlKC4uLmgpO1xuICB9O1xuICByZXR1cm4gKHUsIGgpID0+IHtcbiAgICBvKCksIGModSk7XG4gICAgbGV0IGQ7XG4gICAgZm9yICg7ICEoZCA9IGgobCgpKSk7IClcbiAgICAgIGMoKTtcbiAgICByZXR1cm4gbygpLCBkO1xuICB9O1xufVxuY29uc3QgJGMgPSB7XG4gIGJpZ2ludDogKHQpID0+IHR5cGVvZiB0ID09IFwiYmlnaW50XCIsXG4gIGZ1bmN0aW9uOiAodCkgPT4gdHlwZW9mIHQgPT0gXCJmdW5jdGlvblwiLFxuICBib29sZWFuOiAodCkgPT4gdHlwZW9mIHQgPT0gXCJib29sZWFuXCIsXG4gIHN0cmluZzogKHQpID0+IHR5cGVvZiB0ID09IFwic3RyaW5nXCIsXG4gIGlzU2FmZUludGVnZXI6ICh0KSA9PiBOdW1iZXIuaXNTYWZlSW50ZWdlcih0KSxcbiAgYXJyYXk6ICh0KSA9PiBBcnJheS5pc0FycmF5KHQpLFxuICBmaWVsZDogKHQsIGUpID0+IGUuRnAuaXNWYWxpZCh0KSxcbiAgaGFzaDogKHQpID0+IHR5cGVvZiB0ID09IFwiZnVuY3Rpb25cIiAmJiBOdW1iZXIuaXNTYWZlSW50ZWdlcih0Lm91dHB1dExlbilcbn07XG5mdW5jdGlvbiBrdCh0LCBlLCByID0ge30pIHtcbiAgY29uc3QgbiA9IChpLCBzLCBvKSA9PiB7XG4gICAgY29uc3QgYSA9ICRjW3NdO1xuICAgIGlmICh0eXBlb2YgYSAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdmFsaWRhdG9yIFwiJHtzfVwiLCBleHBlY3RlZCBmdW5jdGlvbmApO1xuICAgIGNvbnN0IGMgPSB0W2ldO1xuICAgIGlmICghKG8gJiYgYyA9PT0gdm9pZCAwKSAmJiAhYShjLCB0KSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwYXJhbSAke1N0cmluZyhpKX09JHtjfSAoJHt0eXBlb2YgY30pLCBleHBlY3RlZCAke3N9YCk7XG4gIH07XG4gIGZvciAoY29uc3QgW2ksIHNdIG9mIE9iamVjdC5lbnRyaWVzKGUpKVxuICAgIG4oaSwgcywgITEpO1xuICBmb3IgKGNvbnN0IFtpLCBzXSBvZiBPYmplY3QuZW50cmllcyhyKSlcbiAgICBuKGksIHMsICEwKTtcbiAgcmV0dXJuIHQ7XG59XG5jb25zdCBxYyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGJ5dGVzVG9IZXg6IHZ0LFxuICBudW1iZXJUb0hleFVucGFkZGVkOiBycyxcbiAgaGV4VG9OdW1iZXI6IHpuLFxuICBoZXhUb0J5dGVzOiB3dCxcbiAgYnl0ZXNUb051bWJlckJFOiBsZSxcbiAgYnl0ZXNUb051bWJlckxFOiBGbixcbiAgbnVtYmVyVG9CeXRlc0JFOiBldCxcbiAgbnVtYmVyVG9CeXRlc0xFOiBucyxcbiAgbnVtYmVyVG9WYXJCeXRlc0JFOiBSYyxcbiAgZW5zdXJlQnl0ZXM6IGVlLFxuICBjb25jYXRCeXRlczogaGUsXG4gIGVxdWFsQnl0ZXM6IFRjLFxuICB1dGY4VG9CeXRlczogcXIsXG4gIGJpdExlbjogUGMsXG4gIGJpdEdldDogQmMsXG4gIGJpdFNldDogTGMsXG4gIGJpdE1hc2s6IEtuLFxuICBjcmVhdGVIbWFjRHJiZzogaXMsXG4gIHZhbGlkYXRlT2JqZWN0OiBrdFxufSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pKTtcbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmNvbnN0IFEgPSBCaWdJbnQoMCksIFYgPSBCaWdJbnQoMSksIGF0ID0gQmlnSW50KDIpLCBOYyA9IEJpZ0ludCgzKSwgQ24gPSBCaWdJbnQoNCksIFVpID0gQmlnSW50KDUpLCBqaSA9IEJpZ0ludCg4KTtcbkJpZ0ludCg5KTtcbkJpZ0ludCgxNik7XG5mdW5jdGlvbiBKKHQsIGUpIHtcbiAgY29uc3QgciA9IHQgJSBlO1xuICByZXR1cm4gciA+PSBRID8gciA6IGUgKyByO1xufVxuZnVuY3Rpb24gVWModCwgZSwgcikge1xuICBpZiAociA8PSBRIHx8IGUgPCBRKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIHBvd2VyL21vZHVsbyA+IDBcIik7XG4gIGlmIChyID09PSBWKVxuICAgIHJldHVybiBRO1xuICBsZXQgbiA9IFY7XG4gIGZvciAoOyBlID4gUTsgKVxuICAgIGUgJiBWICYmIChuID0gbiAqIHQgJSByKSwgdCA9IHQgKiB0ICUgciwgZSA+Pj0gVjtcbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBiZSh0LCBlLCByKSB7XG4gIGxldCBuID0gdDtcbiAgZm9yICg7IGUtLSA+IFE7IClcbiAgICBuICo9IG4sIG4gJT0gcjtcbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBJbih0LCBlKSB7XG4gIGlmICh0ID09PSBRIHx8IGUgPD0gUSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGludmVydDogZXhwZWN0ZWQgcG9zaXRpdmUgaW50ZWdlcnMsIGdvdCBuPSR7dH0gbW9kPSR7ZX1gKTtcbiAgbGV0IHIgPSBKKHQsIGUpLCBuID0gZSwgaSA9IFEsIHMgPSBWO1xuICBmb3IgKDsgciAhPT0gUTsgKSB7XG4gICAgY29uc3QgYSA9IG4gLyByLCBjID0gbiAlIHIsIGwgPSBpIC0gcyAqIGE7XG4gICAgbiA9IHIsIHIgPSBjLCBpID0gcywgcyA9IGw7XG4gIH1cbiAgaWYgKG4gIT09IFYpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52ZXJ0OiBkb2VzIG5vdCBleGlzdFwiKTtcbiAgcmV0dXJuIEooaSwgZSk7XG59XG5mdW5jdGlvbiBqYyh0KSB7XG4gIGNvbnN0IGUgPSAodCAtIFYpIC8gYXQ7XG4gIGxldCByLCBuLCBpO1xuICBmb3IgKHIgPSB0IC0gViwgbiA9IDA7IHIgJSBhdCA9PT0gUTsgciAvPSBhdCwgbisrKVxuICAgIDtcbiAgZm9yIChpID0gYXQ7IGkgPCB0ICYmIFVjKGksIGUsIHQpICE9PSB0IC0gVjsgaSsrKVxuICAgIDtcbiAgaWYgKG4gPT09IDEpIHtcbiAgICBjb25zdCBvID0gKHQgKyBWKSAvIENuO1xuICAgIHJldHVybiBmdW5jdGlvbihjLCBsKSB7XG4gICAgICBjb25zdCBmID0gYy5wb3cobCwgbyk7XG4gICAgICBpZiAoIWMuZXFsKGMuc3FyKGYpLCBsKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3RcIik7XG4gICAgICByZXR1cm4gZjtcbiAgICB9O1xuICB9XG4gIGNvbnN0IHMgPSAociArIFYpIC8gYXQ7XG4gIHJldHVybiBmdW5jdGlvbihhLCBjKSB7XG4gICAgaWYgKGEucG93KGMsIGUpID09PSBhLm5lZyhhLk9ORSkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBzcXVhcmUgcm9vdFwiKTtcbiAgICBsZXQgbCA9IG4sIGYgPSBhLnBvdyhhLm11bChhLk9ORSwgaSksIHIpLCB1ID0gYS5wb3coYywgcyksIGggPSBhLnBvdyhjLCByKTtcbiAgICBmb3IgKDsgIWEuZXFsKGgsIGEuT05FKTsgKSB7XG4gICAgICBpZiAoYS5lcWwoaCwgYS5aRVJPKSlcbiAgICAgICAgcmV0dXJuIGEuWkVSTztcbiAgICAgIGxldCBkID0gMTtcbiAgICAgIGZvciAobGV0IHkgPSBhLnNxcihoKTsgZCA8IGwgJiYgIWEuZXFsKHksIGEuT05FKTsgZCsrKVxuICAgICAgICB5ID0gYS5zcXIoeSk7XG4gICAgICBjb25zdCBwID0gYS5wb3coZiwgViA8PCBCaWdJbnQobCAtIGQgLSAxKSk7XG4gICAgICBmID0gYS5zcXIocCksIHUgPSBhLm11bCh1LCBwKSwgaCA9IGEubXVsKGgsIGYpLCBsID0gZDtcbiAgICB9XG4gICAgcmV0dXJuIHU7XG4gIH07XG59XG5mdW5jdGlvbiBIYyh0KSB7XG4gIGlmICh0ICUgQ24gPT09IE5jKSB7XG4gICAgY29uc3QgZSA9ICh0ICsgVikgLyBDbjtcbiAgICByZXR1cm4gZnVuY3Rpb24obiwgaSkge1xuICAgICAgY29uc3QgcyA9IG4ucG93KGksIGUpO1xuICAgICAgaWYgKCFuLmVxbChuLnNxcihzKSwgaSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIHNxdWFyZSByb290XCIpO1xuICAgICAgcmV0dXJuIHM7XG4gICAgfTtcbiAgfVxuICBpZiAodCAlIGppID09PSBVaSkge1xuICAgIGNvbnN0IGUgPSAodCAtIFVpKSAvIGppO1xuICAgIHJldHVybiBmdW5jdGlvbihuLCBpKSB7XG4gICAgICBjb25zdCBzID0gbi5tdWwoaSwgYXQpLCBvID0gbi5wb3cocywgZSksIGEgPSBuLm11bChpLCBvKSwgYyA9IG4ubXVsKG4ubXVsKGEsIGF0KSwgbyksIGwgPSBuLm11bChhLCBuLnN1YihjLCBuLk9ORSkpO1xuICAgICAgaWYgKCFuLmVxbChuLnNxcihsKSwgaSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIHNxdWFyZSByb290XCIpO1xuICAgICAgcmV0dXJuIGw7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gamModCk7XG59XG5jb25zdCBNYyA9IFtcbiAgXCJjcmVhdGVcIixcbiAgXCJpc1ZhbGlkXCIsXG4gIFwiaXMwXCIsXG4gIFwibmVnXCIsXG4gIFwiaW52XCIsXG4gIFwic3FydFwiLFxuICBcInNxclwiLFxuICBcImVxbFwiLFxuICBcImFkZFwiLFxuICBcInN1YlwiLFxuICBcIm11bFwiLFxuICBcInBvd1wiLFxuICBcImRpdlwiLFxuICBcImFkZE5cIixcbiAgXCJzdWJOXCIsXG4gIFwibXVsTlwiLFxuICBcInNxck5cIlxuXTtcbmZ1bmN0aW9uIG9zKHQpIHtcbiAgY29uc3QgZSA9IHtcbiAgICBPUkRFUjogXCJiaWdpbnRcIixcbiAgICBNQVNLOiBcImJpZ2ludFwiLFxuICAgIEJZVEVTOiBcImlzU2FmZUludGVnZXJcIixcbiAgICBCSVRTOiBcImlzU2FmZUludGVnZXJcIlxuICB9LCByID0gTWMucmVkdWNlKChuLCBpKSA9PiAobltpXSA9IFwiZnVuY3Rpb25cIiwgbiksIGUpO1xuICByZXR1cm4ga3QodCwgcik7XG59XG5mdW5jdGlvbiBEYyh0LCBlLCByKSB7XG4gIGlmIChyIDwgUSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBwb3dlciA+IDBcIik7XG4gIGlmIChyID09PSBRKVxuICAgIHJldHVybiB0Lk9ORTtcbiAgaWYgKHIgPT09IFYpXG4gICAgcmV0dXJuIGU7XG4gIGxldCBuID0gdC5PTkUsIGkgPSBlO1xuICBmb3IgKDsgciA+IFE7IClcbiAgICByICYgViAmJiAobiA9IHQubXVsKG4sIGkpKSwgaSA9IHQuc3FyKGkpLCByID4+PSBWO1xuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIHpjKHQsIGUpIHtcbiAgY29uc3QgciA9IG5ldyBBcnJheShlLmxlbmd0aCksIG4gPSBlLnJlZHVjZSgocywgbywgYSkgPT4gdC5pczAobykgPyBzIDogKHJbYV0gPSBzLCB0Lm11bChzLCBvKSksIHQuT05FKSwgaSA9IHQuaW52KG4pO1xuICByZXR1cm4gZS5yZWR1Y2VSaWdodCgocywgbywgYSkgPT4gdC5pczAobykgPyBzIDogKHJbYV0gPSB0Lm11bChzLCByW2FdKSwgdC5tdWwocywgbykpLCBpKSwgcjtcbn1cbmZ1bmN0aW9uIFduKHQsIGUpIHtcbiAgY29uc3QgciA9IGUgIT09IHZvaWQgMCA/IGUgOiB0LnRvU3RyaW5nKDIpLmxlbmd0aCwgbiA9IE1hdGguY2VpbChyIC8gOCk7XG4gIHJldHVybiB7IG5CaXRMZW5ndGg6IHIsIG5CeXRlTGVuZ3RoOiBuIH07XG59XG5mdW5jdGlvbiBGYyh0LCBlLCByID0gITEsIG4gPSB7fSkge1xuICBpZiAodCA8PSBRKVxuICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgRnAgT1JERVIgPiAwLCBnb3QgJHt0fWApO1xuICBjb25zdCB7IG5CaXRMZW5ndGg6IGksIG5CeXRlTGVuZ3RoOiBzIH0gPSBXbih0LCBlKTtcbiAgaWYgKHMgPiAyMDQ4KVxuICAgIHRocm93IG5ldyBFcnJvcihcIkZpZWxkIGxlbmd0aHMgb3ZlciAyMDQ4IGJ5dGVzIGFyZSBub3Qgc3VwcG9ydGVkXCIpO1xuICBjb25zdCBvID0gSGModCksIGEgPSBPYmplY3QuZnJlZXplKHtcbiAgICBPUkRFUjogdCxcbiAgICBCSVRTOiBpLFxuICAgIEJZVEVTOiBzLFxuICAgIE1BU0s6IEtuKGkpLFxuICAgIFpFUk86IFEsXG4gICAgT05FOiBWLFxuICAgIGNyZWF0ZTogKGMpID0+IEooYywgdCksXG4gICAgaXNWYWxpZDogKGMpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgYyAhPSBcImJpZ2ludFwiKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZmllbGQgZWxlbWVudDogZXhwZWN0ZWQgYmlnaW50LCBnb3QgJHt0eXBlb2YgY31gKTtcbiAgICAgIHJldHVybiBRIDw9IGMgJiYgYyA8IHQ7XG4gICAgfSxcbiAgICBpczA6IChjKSA9PiBjID09PSBRLFxuICAgIGlzT2RkOiAoYykgPT4gKGMgJiBWKSA9PT0gVixcbiAgICBuZWc6IChjKSA9PiBKKC1jLCB0KSxcbiAgICBlcWw6IChjLCBsKSA9PiBjID09PSBsLFxuICAgIHNxcjogKGMpID0+IEooYyAqIGMsIHQpLFxuICAgIGFkZDogKGMsIGwpID0+IEooYyArIGwsIHQpLFxuICAgIHN1YjogKGMsIGwpID0+IEooYyAtIGwsIHQpLFxuICAgIG11bDogKGMsIGwpID0+IEooYyAqIGwsIHQpLFxuICAgIHBvdzogKGMsIGwpID0+IERjKGEsIGMsIGwpLFxuICAgIGRpdjogKGMsIGwpID0+IEooYyAqIEluKGwsIHQpLCB0KSxcbiAgICBzcXJOOiAoYykgPT4gYyAqIGMsXG4gICAgYWRkTjogKGMsIGwpID0+IGMgKyBsLFxuICAgIHN1Yk46IChjLCBsKSA9PiBjIC0gbCxcbiAgICBtdWxOOiAoYywgbCkgPT4gYyAqIGwsXG4gICAgaW52OiAoYykgPT4gSW4oYywgdCksXG4gICAgc3FydDogbi5zcXJ0IHx8ICgoYykgPT4gbyhhLCBjKSksXG4gICAgaW52ZXJ0QmF0Y2g6IChjKSA9PiB6YyhhLCBjKSxcbiAgICBjbW92OiAoYywgbCwgZikgPT4gZiA/IGwgOiBjLFxuICAgIHRvQnl0ZXM6IChjKSA9PiByID8gbnMoYywgcykgOiBldChjLCBzKSxcbiAgICBmcm9tQnl0ZXM6IChjKSA9PiB7XG4gICAgICBpZiAoYy5sZW5ndGggIT09IHMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRnAuZnJvbUJ5dGVzOiBleHBlY3RlZCAke3N9LCBnb3QgJHtjLmxlbmd0aH1gKTtcbiAgICAgIHJldHVybiByID8gRm4oYykgOiBsZShjKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShhKTtcbn1cbmZ1bmN0aW9uIEtjKHQsIGUsIHIgPSAhMSkge1xuICB0ID0gZWUoXCJwcml2YXRlSGFzaFwiLCB0KTtcbiAgY29uc3QgbiA9IHQubGVuZ3RoLCBpID0gV24oZSkubkJ5dGVMZW5ndGggKyA4O1xuICBpZiAoaSA8IDI0IHx8IG4gPCBpIHx8IG4gPiAxMDI0KVxuICAgIHRocm93IG5ldyBFcnJvcihgaGFzaFRvUHJpdmF0ZVNjYWxhcjogZXhwZWN0ZWQgJHtpfS0xMDI0IGJ5dGVzIG9mIGlucHV0LCBnb3QgJHtufWApO1xuICBjb25zdCBzID0gciA/IEZuKHQpIDogbGUodCk7XG4gIHJldHVybiBKKHMsIGUgLSBWKSArIFY7XG59XG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5jb25zdCBXYyA9IEJpZ0ludCgwKSwgb24gPSBCaWdJbnQoMSk7XG5mdW5jdGlvbiBWYyh0LCBlKSB7XG4gIGNvbnN0IHIgPSAoaSwgcykgPT4ge1xuICAgIGNvbnN0IG8gPSBzLm5lZ2F0ZSgpO1xuICAgIHJldHVybiBpID8gbyA6IHM7XG4gIH0sIG4gPSAoaSkgPT4ge1xuICAgIGNvbnN0IHMgPSBNYXRoLmNlaWwoZSAvIGkpICsgMSwgbyA9IDIgKiogKGkgLSAxKTtcbiAgICByZXR1cm4geyB3aW5kb3dzOiBzLCB3aW5kb3dTaXplOiBvIH07XG4gIH07XG4gIHJldHVybiB7XG4gICAgY29uc3RUaW1lTmVnYXRlOiByLFxuICAgIHVuc2FmZUxhZGRlcihpLCBzKSB7XG4gICAgICBsZXQgbyA9IHQuWkVSTywgYSA9IGk7XG4gICAgICBmb3IgKDsgcyA+IFdjOyApXG4gICAgICAgIHMgJiBvbiAmJiAobyA9IG8uYWRkKGEpKSwgYSA9IGEuZG91YmxlKCksIHMgPj49IG9uO1xuICAgICAgcmV0dXJuIG87XG4gICAgfSxcbiAgICBwcmVjb21wdXRlV2luZG93KGksIHMpIHtcbiAgICAgIGNvbnN0IHsgd2luZG93czogbywgd2luZG93U2l6ZTogYSB9ID0gbihzKSwgYyA9IFtdO1xuICAgICAgbGV0IGwgPSBpLCBmID0gbDtcbiAgICAgIGZvciAobGV0IHUgPSAwOyB1IDwgbzsgdSsrKSB7XG4gICAgICAgIGYgPSBsLCBjLnB1c2goZik7XG4gICAgICAgIGZvciAobGV0IGggPSAxOyBoIDwgYTsgaCsrKVxuICAgICAgICAgIGYgPSBmLmFkZChsKSwgYy5wdXNoKGYpO1xuICAgICAgICBsID0gZi5kb3VibGUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjO1xuICAgIH0sXG4gICAgd05BRihpLCBzLCBvKSB7XG4gICAgICBjb25zdCB7IHdpbmRvd3M6IGEsIHdpbmRvd1NpemU6IGMgfSA9IG4oaSk7XG4gICAgICBsZXQgbCA9IHQuWkVSTywgZiA9IHQuQkFTRTtcbiAgICAgIGNvbnN0IHUgPSBCaWdJbnQoMiAqKiBpIC0gMSksIGggPSAyICoqIGksIGQgPSBCaWdJbnQoaSk7XG4gICAgICBmb3IgKGxldCBwID0gMDsgcCA8IGE7IHArKykge1xuICAgICAgICBjb25zdCB5ID0gcCAqIGM7XG4gICAgICAgIGxldCBnID0gTnVtYmVyKG8gJiB1KTtcbiAgICAgICAgbyA+Pj0gZCwgZyA+IGMgJiYgKGcgLT0gaCwgbyArPSBvbik7XG4gICAgICAgIGNvbnN0IHYgPSB5LCBfID0geSArIE1hdGguYWJzKGcpIC0gMSwgbSA9IHAgJSAyICE9PSAwLCBDID0gZyA8IDA7XG4gICAgICAgIGcgPT09IDAgPyBmID0gZi5hZGQocihtLCBzW3ZdKSkgOiBsID0gbC5hZGQocihDLCBzW19dKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBwOiBsLCBmIH07XG4gICAgfSxcbiAgICB3TkFGQ2FjaGVkKGksIHMsIG8sIGEpIHtcbiAgICAgIGNvbnN0IGMgPSBpLl9XSU5ET1dfU0laRSB8fCAxO1xuICAgICAgbGV0IGwgPSBzLmdldChpKTtcbiAgICAgIHJldHVybiBsIHx8IChsID0gdGhpcy5wcmVjb21wdXRlV2luZG93KGksIGMpLCBjICE9PSAxICYmIHMuc2V0KGksIGEobCkpKSwgdGhpcy53TkFGKGMsIGwsIG8pO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHNzKHQpIHtcbiAgcmV0dXJuIG9zKHQuRnApLCBrdCh0LCB7XG4gICAgbjogXCJiaWdpbnRcIixcbiAgICBoOiBcImJpZ2ludFwiLFxuICAgIEd4OiBcImZpZWxkXCIsXG4gICAgR3k6IFwiZmllbGRcIlxuICB9LCB7XG4gICAgbkJpdExlbmd0aDogXCJpc1NhZmVJbnRlZ2VyXCIsXG4gICAgbkJ5dGVMZW5ndGg6IFwiaXNTYWZlSW50ZWdlclwiXG4gIH0pLCBPYmplY3QuZnJlZXplKHtcbiAgICAuLi5Xbih0Lm4sIHQubkJpdExlbmd0aCksXG4gICAgLi4udCxcbiAgICBwOiB0LkZwLk9SREVSXG4gIH0pO1xufVxuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuZnVuY3Rpb24gR2ModCkge1xuICBjb25zdCBlID0gc3ModCk7XG4gIGt0KGUsIHtcbiAgICBhOiBcImZpZWxkXCIsXG4gICAgYjogXCJmaWVsZFwiXG4gIH0sIHtcbiAgICBhbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHM6IFwiYXJyYXlcIixcbiAgICB3cmFwUHJpdmF0ZUtleTogXCJib29sZWFuXCIsXG4gICAgaXNUb3JzaW9uRnJlZTogXCJmdW5jdGlvblwiLFxuICAgIGNsZWFyQ29mYWN0b3I6IFwiZnVuY3Rpb25cIixcbiAgICBhbGxvd0luZmluaXR5UG9pbnQ6IFwiYm9vbGVhblwiLFxuICAgIGZyb21CeXRlczogXCJmdW5jdGlvblwiLFxuICAgIHRvQnl0ZXM6IFwiZnVuY3Rpb25cIlxuICB9KTtcbiAgY29uc3QgeyBlbmRvOiByLCBGcDogbiwgYTogaSB9ID0gZTtcbiAgaWYgKHIpIHtcbiAgICBpZiAoIW4uZXFsKGksIG4uWkVSTykpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbmRvbW9ycGhpc20gY2FuIG9ubHkgYmUgZGVmaW5lZCBmb3IgS29ibGl0eiBjdXJ2ZXMgdGhhdCBoYXZlIGE9MFwiKTtcbiAgICBpZiAodHlwZW9mIHIgIT0gXCJvYmplY3RcIiB8fCB0eXBlb2Ygci5iZXRhICE9IFwiYmlnaW50XCIgfHwgdHlwZW9mIHIuc3BsaXRTY2FsYXIgIT0gXCJmdW5jdGlvblwiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgZW5kb21vcnBoaXNtIHdpdGggYmV0YTogYmlnaW50IGFuZCBzcGxpdFNjYWxhcjogZnVuY3Rpb25cIik7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyAuLi5lIH0pO1xufVxuY29uc3QgeyBieXRlc1RvTnVtYmVyQkU6IFpjLCBoZXhUb0J5dGVzOiBZYyB9ID0gcWMsIGx0ID0ge1xuICBFcnI6IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGUgPSBcIlwiKSB7XG4gICAgICBzdXBlcihlKTtcbiAgICB9XG4gIH0sXG4gIF9wYXJzZUludCh0KSB7XG4gICAgY29uc3QgeyBFcnI6IGUgfSA9IGx0O1xuICAgIGlmICh0Lmxlbmd0aCA8IDIgfHwgdFswXSAhPT0gMilcbiAgICAgIHRocm93IG5ldyBlKFwiSW52YWxpZCBzaWduYXR1cmUgaW50ZWdlciB0YWdcIik7XG4gICAgY29uc3QgciA9IHRbMV0sIG4gPSB0LnN1YmFycmF5KDIsIHIgKyAyKTtcbiAgICBpZiAoIXIgfHwgbi5sZW5ndGggIT09IHIpXG4gICAgICB0aHJvdyBuZXcgZShcIkludmFsaWQgc2lnbmF0dXJlIGludGVnZXI6IHdyb25nIGxlbmd0aFwiKTtcbiAgICBpZiAoblswXSAmIDEyOClcbiAgICAgIHRocm93IG5ldyBlKFwiSW52YWxpZCBzaWduYXR1cmUgaW50ZWdlcjogbmVnYXRpdmVcIik7XG4gICAgaWYgKG5bMF0gPT09IDAgJiYgIShuWzFdICYgMTI4KSlcbiAgICAgIHRocm93IG5ldyBlKFwiSW52YWxpZCBzaWduYXR1cmUgaW50ZWdlcjogdW5uZWNlc3NhcnkgbGVhZGluZyB6ZXJvXCIpO1xuICAgIHJldHVybiB7IGQ6IFpjKG4pLCBsOiB0LnN1YmFycmF5KHIgKyAyKSB9O1xuICB9LFxuICB0b1NpZyh0KSB7XG4gICAgY29uc3QgeyBFcnI6IGUgfSA9IGx0LCByID0gdHlwZW9mIHQgPT0gXCJzdHJpbmdcIiA/IFljKHQpIDogdDtcbiAgICBpZiAoIShyIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1aThhIGV4cGVjdGVkXCIpO1xuICAgIGxldCBuID0gci5sZW5ndGg7XG4gICAgaWYgKG4gPCAyIHx8IHJbMF0gIT0gNDgpXG4gICAgICB0aHJvdyBuZXcgZShcIkludmFsaWQgc2lnbmF0dXJlIHRhZ1wiKTtcbiAgICBpZiAoclsxXSAhPT0gbiAtIDIpXG4gICAgICB0aHJvdyBuZXcgZShcIkludmFsaWQgc2lnbmF0dXJlOiBpbmNvcnJlY3QgbGVuZ3RoXCIpO1xuICAgIGNvbnN0IHsgZDogaSwgbDogcyB9ID0gbHQuX3BhcnNlSW50KHIuc3ViYXJyYXkoMikpLCB7IGQ6IG8sIGw6IGEgfSA9IGx0Ll9wYXJzZUludChzKTtcbiAgICBpZiAoYS5sZW5ndGgpXG4gICAgICB0aHJvdyBuZXcgZShcIkludmFsaWQgc2lnbmF0dXJlOiBsZWZ0IGJ5dGVzIGFmdGVyIHBhcnNpbmdcIik7XG4gICAgcmV0dXJuIHsgcjogaSwgczogbyB9O1xuICB9LFxuICBoZXhGcm9tU2lnKHQpIHtcbiAgICBjb25zdCBlID0gKGwpID0+IE51bWJlci5wYXJzZUludChsWzBdLCAxNikgJiA4ID8gXCIwMFwiICsgbCA6IGwsIHIgPSAobCkgPT4ge1xuICAgICAgY29uc3QgZiA9IGwudG9TdHJpbmcoMTYpO1xuICAgICAgcmV0dXJuIGYubGVuZ3RoICYgMSA/IGAwJHtmfWAgOiBmO1xuICAgIH0sIG4gPSBlKHIodC5zKSksIGkgPSBlKHIodC5yKSksIHMgPSBuLmxlbmd0aCAvIDIsIG8gPSBpLmxlbmd0aCAvIDIsIGEgPSByKHMpLCBjID0gcihvKTtcbiAgICByZXR1cm4gYDMwJHtyKG8gKyBzICsgNCl9MDIke2N9JHtpfTAyJHthfSR7bn1gO1xuICB9XG59LCBrZSA9IEJpZ0ludCgwKSwgWSA9IEJpZ0ludCgxKSwgJGUgPSBCaWdJbnQoMiksIEFyID0gQmlnSW50KDMpLCBIaSA9IEJpZ0ludCg0KTtcbmZ1bmN0aW9uIEpjKHQpIHtcbiAgY29uc3QgZSA9IEdjKHQpLCB7IEZwOiByIH0gPSBlLCBuID0gZS50b0J5dGVzIHx8ICgocCwgeSwgZykgPT4ge1xuICAgIGNvbnN0IHYgPSB5LnRvQWZmaW5lKCk7XG4gICAgcmV0dXJuIGhlKFVpbnQ4QXJyYXkuZnJvbShbNF0pLCByLnRvQnl0ZXModi54KSwgci50b0J5dGVzKHYueSkpO1xuICB9KSwgaSA9IGUuZnJvbUJ5dGVzIHx8ICgocCkgPT4ge1xuICAgIGNvbnN0IHkgPSBwLnN1YmFycmF5KDEpLCBnID0gci5mcm9tQnl0ZXMoeS5zdWJhcnJheSgwLCByLkJZVEVTKSksIHYgPSByLmZyb21CeXRlcyh5LnN1YmFycmF5KHIuQllURVMsIDIgKiByLkJZVEVTKSk7XG4gICAgcmV0dXJuIHsgeDogZywgeTogdiB9O1xuICB9KTtcbiAgZnVuY3Rpb24gcyhwKSB7XG4gICAgY29uc3QgeyBhOiB5LCBiOiBnIH0gPSBlLCB2ID0gci5zcXIocCksIF8gPSByLm11bCh2LCBwKTtcbiAgICByZXR1cm4gci5hZGQoci5hZGQoXywgci5tdWwocCwgeSkpLCBnKTtcbiAgfVxuICBpZiAoIXIuZXFsKHIuc3FyKGUuR3kpLCBzKGUuR3gpKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgZ2VuZXJhdG9yIHBvaW50OiBlcXVhdGlvbiBsZWZ0ICE9IHJpZ2h0XCIpO1xuICBmdW5jdGlvbiBvKHApIHtcbiAgICByZXR1cm4gdHlwZW9mIHAgPT0gXCJiaWdpbnRcIiAmJiBrZSA8IHAgJiYgcCA8IGUubjtcbiAgfVxuICBmdW5jdGlvbiBhKHApIHtcbiAgICBpZiAoIW8ocCkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCB2YWxpZCBiaWdpbnQ6IDAgPCBiaWdpbnQgPCBjdXJ2ZS5uXCIpO1xuICB9XG4gIGZ1bmN0aW9uIGMocCkge1xuICAgIGNvbnN0IHsgYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzOiB5LCBuQnl0ZUxlbmd0aDogZywgd3JhcFByaXZhdGVLZXk6IHYsIG46IF8gfSA9IGU7XG4gICAgaWYgKHkgJiYgdHlwZW9mIHAgIT0gXCJiaWdpbnRcIikge1xuICAgICAgaWYgKHAgaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmIChwID0gdnQocCkpLCB0eXBlb2YgcCAhPSBcInN0cmluZ1wiIHx8ICF5LmluY2x1ZGVzKHAubGVuZ3RoKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBrZXlcIik7XG4gICAgICBwID0gcC5wYWRTdGFydChnICogMiwgXCIwXCIpO1xuICAgIH1cbiAgICBsZXQgbTtcbiAgICB0cnkge1xuICAgICAgbSA9IHR5cGVvZiBwID09IFwiYmlnaW50XCIgPyBwIDogbGUoZWUoXCJwcml2YXRlIGtleVwiLCBwLCBnKSk7XG4gICAgfSBjYXRjaCB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHByaXZhdGUga2V5IG11c3QgYmUgJHtnfSBieXRlcywgaGV4IG9yIGJpZ2ludCwgbm90ICR7dHlwZW9mIHB9YCk7XG4gICAgfVxuICAgIHJldHVybiB2ICYmIChtID0gSihtLCBfKSksIGEobSksIG07XG4gIH1cbiAgY29uc3QgbCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGZ1bmN0aW9uIGYocCkge1xuICAgIGlmICghKHAgaW5zdGFuY2VvZiB1KSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb2plY3RpdmVQb2ludCBleHBlY3RlZFwiKTtcbiAgfVxuICBjbGFzcyB1IHtcbiAgICBjb25zdHJ1Y3Rvcih5LCBnLCB2KSB7XG4gICAgICBpZiAodGhpcy5weCA9IHksIHRoaXMucHkgPSBnLCB0aGlzLnB6ID0gdiwgeSA9PSBudWxsIHx8ICFyLmlzVmFsaWQoeSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInggcmVxdWlyZWRcIik7XG4gICAgICBpZiAoZyA9PSBudWxsIHx8ICFyLmlzVmFsaWQoZykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInkgcmVxdWlyZWRcIik7XG4gICAgICBpZiAodiA9PSBudWxsIHx8ICFyLmlzVmFsaWQodikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInogcmVxdWlyZWRcIik7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQWZmaW5lKHkpIHtcbiAgICAgIGNvbnN0IHsgeDogZywgeTogdiB9ID0geSB8fCB7fTtcbiAgICAgIGlmICgheSB8fCAhci5pc1ZhbGlkKGcpIHx8ICFyLmlzVmFsaWQodikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYWZmaW5lIHBvaW50XCIpO1xuICAgICAgaWYgKHkgaW5zdGFuY2VvZiB1KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwcm9qZWN0aXZlIHBvaW50IG5vdCBhbGxvd2VkXCIpO1xuICAgICAgY29uc3QgXyA9IChtKSA9PiByLmVxbChtLCByLlpFUk8pO1xuICAgICAgcmV0dXJuIF8oZykgJiYgXyh2KSA/IHUuWkVSTyA6IG5ldyB1KGcsIHYsIHIuT05FKTtcbiAgICB9XG4gICAgZ2V0IHgoKSB7XG4gICAgICByZXR1cm4gdGhpcy50b0FmZmluZSgpLng7XG4gICAgfVxuICAgIGdldCB5KCkge1xuICAgICAgcmV0dXJuIHRoaXMudG9BZmZpbmUoKS55O1xuICAgIH1cbiAgICBzdGF0aWMgbm9ybWFsaXplWih5KSB7XG4gICAgICBjb25zdCBnID0gci5pbnZlcnRCYXRjaCh5Lm1hcCgodikgPT4gdi5weikpO1xuICAgICAgcmV0dXJuIHkubWFwKCh2LCBfKSA9PiB2LnRvQWZmaW5lKGdbX10pKS5tYXAodS5mcm9tQWZmaW5lKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21IZXgoeSkge1xuICAgICAgY29uc3QgZyA9IHUuZnJvbUFmZmluZShpKGVlKFwicG9pbnRIZXhcIiwgeSkpKTtcbiAgICAgIHJldHVybiBnLmFzc2VydFZhbGlkaXR5KCksIGc7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tUHJpdmF0ZUtleSh5KSB7XG4gICAgICByZXR1cm4gdS5CQVNFLm11bHRpcGx5KGMoeSkpO1xuICAgIH1cbiAgICBfc2V0V2luZG93U2l6ZSh5KSB7XG4gICAgICB0aGlzLl9XSU5ET1dfU0laRSA9IHksIGwuZGVsZXRlKHRoaXMpO1xuICAgIH1cbiAgICBhc3NlcnRWYWxpZGl0eSgpIHtcbiAgICAgIGlmICh0aGlzLmlzMCgpKSB7XG4gICAgICAgIGlmIChlLmFsbG93SW5maW5pdHlQb2ludClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImJhZCBwb2ludDogWkVST1wiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgeDogeSwgeTogZyB9ID0gdGhpcy50b0FmZmluZSgpO1xuICAgICAgaWYgKCFyLmlzVmFsaWQoeSkgfHwgIXIuaXNWYWxpZChnKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmFkIHBvaW50OiB4IG9yIHkgbm90IEZFXCIpO1xuICAgICAgY29uc3QgdiA9IHIuc3FyKGcpLCBfID0gcyh5KTtcbiAgICAgIGlmICghci5lcWwodiwgXykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImJhZCBwb2ludDogZXF1YXRpb24gbGVmdCAhPSByaWdodFwiKTtcbiAgICAgIGlmICghdGhpcy5pc1RvcnNpb25GcmVlKCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImJhZCBwb2ludDogbm90IGluIHByaW1lLW9yZGVyIHN1Ymdyb3VwXCIpO1xuICAgIH1cbiAgICBoYXNFdmVuWSgpIHtcbiAgICAgIGNvbnN0IHsgeSB9ID0gdGhpcy50b0FmZmluZSgpO1xuICAgICAgaWYgKHIuaXNPZGQpXG4gICAgICAgIHJldHVybiAhci5pc09kZCh5KTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkZpZWxkIGRvZXNuJ3Qgc3VwcG9ydCBpc09kZFwiKTtcbiAgICB9XG4gICAgZXF1YWxzKHkpIHtcbiAgICAgIGYoeSk7XG4gICAgICBjb25zdCB7IHB4OiBnLCBweTogdiwgcHo6IF8gfSA9IHRoaXMsIHsgcHg6IG0sIHB5OiBDLCBwejogTyB9ID0geSwgdyA9IHIuZXFsKHIubXVsKGcsIE8pLCByLm11bChtLCBfKSksIHggPSByLmVxbChyLm11bCh2LCBPKSwgci5tdWwoQywgXykpO1xuICAgICAgcmV0dXJuIHcgJiYgeDtcbiAgICB9XG4gICAgbmVnYXRlKCkge1xuICAgICAgcmV0dXJuIG5ldyB1KHRoaXMucHgsIHIubmVnKHRoaXMucHkpLCB0aGlzLnB6KTtcbiAgICB9XG4gICAgZG91YmxlKCkge1xuICAgICAgY29uc3QgeyBhOiB5LCBiOiBnIH0gPSBlLCB2ID0gci5tdWwoZywgQXIpLCB7IHB4OiBfLCBweTogbSwgcHo6IEMgfSA9IHRoaXM7XG4gICAgICBsZXQgTyA9IHIuWkVSTywgdyA9IHIuWkVSTywgeCA9IHIuWkVSTywgQSA9IHIubXVsKF8sIF8pLCBCID0gci5tdWwobSwgbSksIEwgPSByLm11bChDLCBDKSwgUCA9IHIubXVsKF8sIG0pO1xuICAgICAgcmV0dXJuIFAgPSByLmFkZChQLCBQKSwgeCA9IHIubXVsKF8sIEMpLCB4ID0gci5hZGQoeCwgeCksIE8gPSByLm11bCh5LCB4KSwgdyA9IHIubXVsKHYsIEwpLCB3ID0gci5hZGQoTywgdyksIE8gPSByLnN1YihCLCB3KSwgdyA9IHIuYWRkKEIsIHcpLCB3ID0gci5tdWwoTywgdyksIE8gPSByLm11bChQLCBPKSwgeCA9IHIubXVsKHYsIHgpLCBMID0gci5tdWwoeSwgTCksIFAgPSByLnN1YihBLCBMKSwgUCA9IHIubXVsKHksIFApLCBQID0gci5hZGQoUCwgeCksIHggPSByLmFkZChBLCBBKSwgQSA9IHIuYWRkKHgsIEEpLCBBID0gci5hZGQoQSwgTCksIEEgPSByLm11bChBLCBQKSwgdyA9IHIuYWRkKHcsIEEpLCBMID0gci5tdWwobSwgQyksIEwgPSByLmFkZChMLCBMKSwgQSA9IHIubXVsKEwsIFApLCBPID0gci5zdWIoTywgQSksIHggPSByLm11bChMLCBCKSwgeCA9IHIuYWRkKHgsIHgpLCB4ID0gci5hZGQoeCwgeCksIG5ldyB1KE8sIHcsIHgpO1xuICAgIH1cbiAgICBhZGQoeSkge1xuICAgICAgZih5KTtcbiAgICAgIGNvbnN0IHsgcHg6IGcsIHB5OiB2LCBwejogXyB9ID0gdGhpcywgeyBweDogbSwgcHk6IEMsIHB6OiBPIH0gPSB5O1xuICAgICAgbGV0IHcgPSByLlpFUk8sIHggPSByLlpFUk8sIEEgPSByLlpFUk87XG4gICAgICBjb25zdCBCID0gZS5hLCBMID0gci5tdWwoZS5iLCBBcik7XG4gICAgICBsZXQgUCA9IHIubXVsKGcsIG0pLCBGID0gci5tdWwodiwgQyksIHogPSByLm11bChfLCBPKSwgRyA9IHIuYWRkKGcsIHYpLCBFID0gci5hZGQobSwgQyk7XG4gICAgICBHID0gci5tdWwoRywgRSksIEUgPSByLmFkZChQLCBGKSwgRyA9IHIuc3ViKEcsIEUpLCBFID0gci5hZGQoZywgXyk7XG4gICAgICBsZXQgUiA9IHIuYWRkKG0sIE8pO1xuICAgICAgcmV0dXJuIEUgPSByLm11bChFLCBSKSwgUiA9IHIuYWRkKFAsIHopLCBFID0gci5zdWIoRSwgUiksIFIgPSByLmFkZCh2LCBfKSwgdyA9IHIuYWRkKEMsIE8pLCBSID0gci5tdWwoUiwgdyksIHcgPSByLmFkZChGLCB6KSwgUiA9IHIuc3ViKFIsIHcpLCBBID0gci5tdWwoQiwgRSksIHcgPSByLm11bChMLCB6KSwgQSA9IHIuYWRkKHcsIEEpLCB3ID0gci5zdWIoRiwgQSksIEEgPSByLmFkZChGLCBBKSwgeCA9IHIubXVsKHcsIEEpLCBGID0gci5hZGQoUCwgUCksIEYgPSByLmFkZChGLCBQKSwgeiA9IHIubXVsKEIsIHopLCBFID0gci5tdWwoTCwgRSksIEYgPSByLmFkZChGLCB6KSwgeiA9IHIuc3ViKFAsIHopLCB6ID0gci5tdWwoQiwgeiksIEUgPSByLmFkZChFLCB6KSwgUCA9IHIubXVsKEYsIEUpLCB4ID0gci5hZGQoeCwgUCksIFAgPSByLm11bChSLCBFKSwgdyA9IHIubXVsKEcsIHcpLCB3ID0gci5zdWIodywgUCksIFAgPSByLm11bChHLCBGKSwgQSA9IHIubXVsKFIsIEEpLCBBID0gci5hZGQoQSwgUCksIG5ldyB1KHcsIHgsIEEpO1xuICAgIH1cbiAgICBzdWJ0cmFjdCh5KSB7XG4gICAgICByZXR1cm4gdGhpcy5hZGQoeS5uZWdhdGUoKSk7XG4gICAgfVxuICAgIGlzMCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmVxdWFscyh1LlpFUk8pO1xuICAgIH1cbiAgICB3TkFGKHkpIHtcbiAgICAgIHJldHVybiBkLndOQUZDYWNoZWQodGhpcywgbCwgeSwgKGcpID0+IHtcbiAgICAgICAgY29uc3QgdiA9IHIuaW52ZXJ0QmF0Y2goZy5tYXAoKF8pID0+IF8ucHopKTtcbiAgICAgICAgcmV0dXJuIGcubWFwKChfLCBtKSA9PiBfLnRvQWZmaW5lKHZbbV0pKS5tYXAodS5mcm9tQWZmaW5lKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBtdWx0aXBseVVuc2FmZSh5KSB7XG4gICAgICBjb25zdCBnID0gdS5aRVJPO1xuICAgICAgaWYgKHkgPT09IGtlKVxuICAgICAgICByZXR1cm4gZztcbiAgICAgIGlmIChhKHkpLCB5ID09PSBZKVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIGNvbnN0IHsgZW5kbzogdiB9ID0gZTtcbiAgICAgIGlmICghdilcbiAgICAgICAgcmV0dXJuIGQudW5zYWZlTGFkZGVyKHRoaXMsIHkpO1xuICAgICAgbGV0IHsgazFuZWc6IF8sIGsxOiBtLCBrMm5lZzogQywgazI6IE8gfSA9IHYuc3BsaXRTY2FsYXIoeSksIHcgPSBnLCB4ID0gZywgQSA9IHRoaXM7XG4gICAgICBmb3IgKDsgbSA+IGtlIHx8IE8gPiBrZTsgKVxuICAgICAgICBtICYgWSAmJiAodyA9IHcuYWRkKEEpKSwgTyAmIFkgJiYgKHggPSB4LmFkZChBKSksIEEgPSBBLmRvdWJsZSgpLCBtID4+PSBZLCBPID4+PSBZO1xuICAgICAgcmV0dXJuIF8gJiYgKHcgPSB3Lm5lZ2F0ZSgpKSwgQyAmJiAoeCA9IHgubmVnYXRlKCkpLCB4ID0gbmV3IHUoci5tdWwoeC5weCwgdi5iZXRhKSwgeC5weSwgeC5weiksIHcuYWRkKHgpO1xuICAgIH1cbiAgICBtdWx0aXBseSh5KSB7XG4gICAgICBhKHkpO1xuICAgICAgbGV0IGcgPSB5LCB2LCBfO1xuICAgICAgY29uc3QgeyBlbmRvOiBtIH0gPSBlO1xuICAgICAgaWYgKG0pIHtcbiAgICAgICAgY29uc3QgeyBrMW5lZzogQywgazE6IE8sIGsybmVnOiB3LCBrMjogeCB9ID0gbS5zcGxpdFNjYWxhcihnKTtcbiAgICAgICAgbGV0IHsgcDogQSwgZjogQiB9ID0gdGhpcy53TkFGKE8pLCB7IHA6IEwsIGY6IFAgfSA9IHRoaXMud05BRih4KTtcbiAgICAgICAgQSA9IGQuY29uc3RUaW1lTmVnYXRlKEMsIEEpLCBMID0gZC5jb25zdFRpbWVOZWdhdGUodywgTCksIEwgPSBuZXcgdShyLm11bChMLnB4LCBtLmJldGEpLCBMLnB5LCBMLnB6KSwgdiA9IEEuYWRkKEwpLCBfID0gQi5hZGQoUCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB7IHA6IEMsIGY6IE8gfSA9IHRoaXMud05BRihnKTtcbiAgICAgICAgdiA9IEMsIF8gPSBPO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHUubm9ybWFsaXplWihbdiwgX10pWzBdO1xuICAgIH1cbiAgICBtdWx0aXBseUFuZEFkZFVuc2FmZSh5LCBnLCB2KSB7XG4gICAgICBjb25zdCBfID0gdS5CQVNFLCBtID0gKE8sIHcpID0+IHcgPT09IGtlIHx8IHcgPT09IFkgfHwgIU8uZXF1YWxzKF8pID8gTy5tdWx0aXBseVVuc2FmZSh3KSA6IE8ubXVsdGlwbHkodyksIEMgPSBtKHRoaXMsIGcpLmFkZChtKHksIHYpKTtcbiAgICAgIHJldHVybiBDLmlzMCgpID8gdm9pZCAwIDogQztcbiAgICB9XG4gICAgdG9BZmZpbmUoeSkge1xuICAgICAgY29uc3QgeyBweDogZywgcHk6IHYsIHB6OiBfIH0gPSB0aGlzLCBtID0gdGhpcy5pczAoKTtcbiAgICAgIHkgPT0gbnVsbCAmJiAoeSA9IG0gPyByLk9ORSA6IHIuaW52KF8pKTtcbiAgICAgIGNvbnN0IEMgPSByLm11bChnLCB5KSwgTyA9IHIubXVsKHYsIHkpLCB3ID0gci5tdWwoXywgeSk7XG4gICAgICBpZiAobSlcbiAgICAgICAgcmV0dXJuIHsgeDogci5aRVJPLCB5OiByLlpFUk8gfTtcbiAgICAgIGlmICghci5lcWwodywgci5PTkUpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZaIHdhcyBpbnZhbGlkXCIpO1xuICAgICAgcmV0dXJuIHsgeDogQywgeTogTyB9O1xuICAgIH1cbiAgICBpc1RvcnNpb25GcmVlKCkge1xuICAgICAgY29uc3QgeyBoOiB5LCBpc1RvcnNpb25GcmVlOiBnIH0gPSBlO1xuICAgICAgaWYgKHkgPT09IFkpXG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIGlmIChnKVxuICAgICAgICByZXR1cm4gZyh1LCB0aGlzKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlzVG9yc2lvbkZyZWUoKSBoYXMgbm90IGJlZW4gZGVjbGFyZWQgZm9yIHRoZSBlbGxpcHRpYyBjdXJ2ZVwiKTtcbiAgICB9XG4gICAgY2xlYXJDb2ZhY3RvcigpIHtcbiAgICAgIGNvbnN0IHsgaDogeSwgY2xlYXJDb2ZhY3RvcjogZyB9ID0gZTtcbiAgICAgIHJldHVybiB5ID09PSBZID8gdGhpcyA6IGcgPyBnKHUsIHRoaXMpIDogdGhpcy5tdWx0aXBseVVuc2FmZShlLmgpO1xuICAgIH1cbiAgICB0b1Jhd0J5dGVzKHkgPSAhMCkge1xuICAgICAgcmV0dXJuIHRoaXMuYXNzZXJ0VmFsaWRpdHkoKSwgbih1LCB0aGlzLCB5KTtcbiAgICB9XG4gICAgdG9IZXgoeSA9ICEwKSB7XG4gICAgICByZXR1cm4gdnQodGhpcy50b1Jhd0J5dGVzKHkpKTtcbiAgICB9XG4gIH1cbiAgdS5CQVNFID0gbmV3IHUoZS5HeCwgZS5HeSwgci5PTkUpLCB1LlpFUk8gPSBuZXcgdShyLlpFUk8sIHIuT05FLCByLlpFUk8pO1xuICBjb25zdCBoID0gZS5uQml0TGVuZ3RoLCBkID0gVmModSwgZS5lbmRvID8gTWF0aC5jZWlsKGggLyAyKSA6IGgpO1xuICByZXR1cm4ge1xuICAgIENVUlZFOiBlLFxuICAgIFByb2plY3RpdmVQb2ludDogdSxcbiAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyOiBjLFxuICAgIHdlaWVyc3RyYXNzRXF1YXRpb246IHMsXG4gICAgaXNXaXRoaW5DdXJ2ZU9yZGVyOiBvXG4gIH07XG59XG5mdW5jdGlvbiBYYyh0KSB7XG4gIGNvbnN0IGUgPSBzcyh0KTtcbiAgcmV0dXJuIGt0KGUsIHtcbiAgICBoYXNoOiBcImhhc2hcIixcbiAgICBobWFjOiBcImZ1bmN0aW9uXCIsXG4gICAgcmFuZG9tQnl0ZXM6IFwiZnVuY3Rpb25cIlxuICB9LCB7XG4gICAgYml0czJpbnQ6IFwiZnVuY3Rpb25cIixcbiAgICBiaXRzMmludF9tb2ROOiBcImZ1bmN0aW9uXCIsXG4gICAgbG93UzogXCJib29sZWFuXCJcbiAgfSksIE9iamVjdC5mcmVlemUoeyBsb3dTOiAhMCwgLi4uZSB9KTtcbn1cbmZ1bmN0aW9uIFFjKHQpIHtcbiAgY29uc3QgZSA9IFhjKHQpLCB7IEZwOiByLCBuIH0gPSBlLCBpID0gci5CWVRFUyArIDEsIHMgPSAyICogci5CWVRFUyArIDE7XG4gIGZ1bmN0aW9uIG8oRSkge1xuICAgIHJldHVybiBrZSA8IEUgJiYgRSA8IHIuT1JERVI7XG4gIH1cbiAgZnVuY3Rpb24gYShFKSB7XG4gICAgcmV0dXJuIEooRSwgbik7XG4gIH1cbiAgZnVuY3Rpb24gYyhFKSB7XG4gICAgcmV0dXJuIEluKEUsIG4pO1xuICB9XG4gIGNvbnN0IHsgUHJvamVjdGl2ZVBvaW50OiBsLCBub3JtUHJpdmF0ZUtleVRvU2NhbGFyOiBmLCB3ZWllcnN0cmFzc0VxdWF0aW9uOiB1LCBpc1dpdGhpbkN1cnZlT3JkZXI6IGggfSA9IEpjKHtcbiAgICAuLi5lLFxuICAgIHRvQnl0ZXMoRSwgUiwgcSkge1xuICAgICAgY29uc3QgSCA9IFIudG9BZmZpbmUoKSwgRCA9IHIudG9CeXRlcyhILngpLCBYID0gaGU7XG4gICAgICByZXR1cm4gcSA/IFgoVWludDhBcnJheS5mcm9tKFtSLmhhc0V2ZW5ZKCkgPyAyIDogM10pLCBEKSA6IFgoVWludDhBcnJheS5mcm9tKFs0XSksIEQsIHIudG9CeXRlcyhILnkpKTtcbiAgICB9LFxuICAgIGZyb21CeXRlcyhFKSB7XG4gICAgICBjb25zdCBSID0gRS5sZW5ndGgsIHEgPSBFWzBdLCBIID0gRS5zdWJhcnJheSgxKTtcbiAgICAgIGlmIChSID09PSBpICYmIChxID09PSAyIHx8IHEgPT09IDMpKSB7XG4gICAgICAgIGNvbnN0IEQgPSBsZShIKTtcbiAgICAgICAgaWYgKCFvKEQpKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBvaW50IGlzIG5vdCBvbiBjdXJ2ZVwiKTtcbiAgICAgICAgY29uc3QgWCA9IHUoRCk7XG4gICAgICAgIGxldCBvZSA9IHIuc3FydChYKTtcbiAgICAgICAgY29uc3QgcmUgPSAob2UgJiBZKSA9PT0gWTtcbiAgICAgICAgcmV0dXJuIChxICYgMSkgPT09IDEgIT09IHJlICYmIChvZSA9IHIubmVnKG9lKSksIHsgeDogRCwgeTogb2UgfTtcbiAgICAgIH0gZWxzZSBpZiAoUiA9PT0gcyAmJiBxID09PSA0KSB7XG4gICAgICAgIGNvbnN0IEQgPSByLmZyb21CeXRlcyhILnN1YmFycmF5KDAsIHIuQllURVMpKSwgWCA9IHIuZnJvbUJ5dGVzKEguc3ViYXJyYXkoci5CWVRFUywgMiAqIHIuQllURVMpKTtcbiAgICAgICAgcmV0dXJuIHsgeDogRCwgeTogWCB9O1xuICAgICAgfSBlbHNlXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9pbnQgb2YgbGVuZ3RoICR7Un0gd2FzIGludmFsaWQuIEV4cGVjdGVkICR7aX0gY29tcHJlc3NlZCBieXRlcyBvciAke3N9IHVuY29tcHJlc3NlZCBieXRlc2ApO1xuICAgIH1cbiAgfSksIGQgPSAoRSkgPT4gdnQoZXQoRSwgZS5uQnl0ZUxlbmd0aCkpO1xuICBmdW5jdGlvbiBwKEUpIHtcbiAgICBjb25zdCBSID0gbiA+PiBZO1xuICAgIHJldHVybiBFID4gUjtcbiAgfVxuICBmdW5jdGlvbiB5KEUpIHtcbiAgICByZXR1cm4gcChFKSA/IGEoLUUpIDogRTtcbiAgfVxuICBjb25zdCBnID0gKEUsIFIsIHEpID0+IGxlKEUuc2xpY2UoUiwgcSkpO1xuICBjbGFzcyB2IHtcbiAgICBjb25zdHJ1Y3RvcihSLCBxLCBIKSB7XG4gICAgICB0aGlzLnIgPSBSLCB0aGlzLnMgPSBxLCB0aGlzLnJlY292ZXJ5ID0gSCwgdGhpcy5hc3NlcnRWYWxpZGl0eSgpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUNvbXBhY3QoUikge1xuICAgICAgY29uc3QgcSA9IGUubkJ5dGVMZW5ndGg7XG4gICAgICByZXR1cm4gUiA9IGVlKFwiY29tcGFjdFNpZ25hdHVyZVwiLCBSLCBxICogMiksIG5ldyB2KGcoUiwgMCwgcSksIGcoUiwgcSwgMiAqIHEpKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21ERVIoUikge1xuICAgICAgY29uc3QgeyByOiBxLCBzOiBIIH0gPSBsdC50b1NpZyhlZShcIkRFUlwiLCBSKSk7XG4gICAgICByZXR1cm4gbmV3IHYocSwgSCk7XG4gICAgfVxuICAgIGFzc2VydFZhbGlkaXR5KCkge1xuICAgICAgaWYgKCFoKHRoaXMucikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInIgbXVzdCBiZSAwIDwgciA8IENVUlZFLm5cIik7XG4gICAgICBpZiAoIWgodGhpcy5zKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicyBtdXN0IGJlIDAgPCBzIDwgQ1VSVkUublwiKTtcbiAgICB9XG4gICAgYWRkUmVjb3ZlcnlCaXQoUikge1xuICAgICAgcmV0dXJuIG5ldyB2KHRoaXMuciwgdGhpcy5zLCBSKTtcbiAgICB9XG4gICAgcmVjb3ZlclB1YmxpY0tleShSKSB7XG4gICAgICBjb25zdCB7IHI6IHEsIHM6IEgsIHJlY292ZXJ5OiBEIH0gPSB0aGlzLCBYID0geChlZShcIm1zZ0hhc2hcIiwgUikpO1xuICAgICAgaWYgKEQgPT0gbnVsbCB8fCAhWzAsIDEsIDIsIDNdLmluY2x1ZGVzKEQpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZWNvdmVyeSBpZCBpbnZhbGlkXCIpO1xuICAgICAgY29uc3Qgb2UgPSBEID09PSAyIHx8IEQgPT09IDMgPyBxICsgZS5uIDogcTtcbiAgICAgIGlmIChvZSA+PSByLk9SREVSKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZWNvdmVyeSBpZCAyIG9yIDMgaW52YWxpZFwiKTtcbiAgICAgIGNvbnN0IHJlID0gKEQgJiAxKSA9PT0gMCA/IFwiMDJcIiA6IFwiMDNcIiwgX2UgPSBsLmZyb21IZXgocmUgKyBkKG9lKSksIE9lID0gYyhvZSksIFVlID0gYSgtWCAqIE9lKSwgUGUgPSBhKEggKiBPZSksIHllID0gbC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKF9lLCBVZSwgUGUpO1xuICAgICAgaWYgKCF5ZSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicG9pbnQgYXQgaW5maW5pZnlcIik7XG4gICAgICByZXR1cm4geWUuYXNzZXJ0VmFsaWRpdHkoKSwgeWU7XG4gICAgfVxuICAgIGhhc0hpZ2hTKCkge1xuICAgICAgcmV0dXJuIHAodGhpcy5zKTtcbiAgICB9XG4gICAgbm9ybWFsaXplUygpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhc0hpZ2hTKCkgPyBuZXcgdih0aGlzLnIsIGEoLXRoaXMucyksIHRoaXMucmVjb3ZlcnkpIDogdGhpcztcbiAgICB9XG4gICAgdG9ERVJSYXdCeXRlcygpIHtcbiAgICAgIHJldHVybiB3dCh0aGlzLnRvREVSSGV4KCkpO1xuICAgIH1cbiAgICB0b0RFUkhleCgpIHtcbiAgICAgIHJldHVybiBsdC5oZXhGcm9tU2lnKHsgcjogdGhpcy5yLCBzOiB0aGlzLnMgfSk7XG4gICAgfVxuICAgIHRvQ29tcGFjdFJhd0J5dGVzKCkge1xuICAgICAgcmV0dXJuIHd0KHRoaXMudG9Db21wYWN0SGV4KCkpO1xuICAgIH1cbiAgICB0b0NvbXBhY3RIZXgoKSB7XG4gICAgICByZXR1cm4gZCh0aGlzLnIpICsgZCh0aGlzLnMpO1xuICAgIH1cbiAgfVxuICBjb25zdCBfID0ge1xuICAgIGlzVmFsaWRQcml2YXRlS2V5KEUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBmKEUpLCAhMDtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICByZXR1cm4gITE7XG4gICAgICB9XG4gICAgfSxcbiAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyOiBmLFxuICAgIHJhbmRvbVByaXZhdGVLZXk6ICgpID0+IHtcbiAgICAgIGNvbnN0IEUgPSBlLnJhbmRvbUJ5dGVzKHIuQllURVMgKyA4KSwgUiA9IEtjKEUsIG4pO1xuICAgICAgcmV0dXJuIGV0KFIsIGUubkJ5dGVMZW5ndGgpO1xuICAgIH0sXG4gICAgcHJlY29tcHV0ZShFID0gOCwgUiA9IGwuQkFTRSkge1xuICAgICAgcmV0dXJuIFIuX3NldFdpbmRvd1NpemUoRSksIFIubXVsdGlwbHkoQmlnSW50KDMpKSwgUjtcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIG0oRSwgUiA9ICEwKSB7XG4gICAgcmV0dXJuIGwuZnJvbVByaXZhdGVLZXkoRSkudG9SYXdCeXRlcyhSKTtcbiAgfVxuICBmdW5jdGlvbiBDKEUpIHtcbiAgICBjb25zdCBSID0gRSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXksIHEgPSB0eXBlb2YgRSA9PSBcInN0cmluZ1wiLCBIID0gKFIgfHwgcSkgJiYgRS5sZW5ndGg7XG4gICAgcmV0dXJuIFIgPyBIID09PSBpIHx8IEggPT09IHMgOiBxID8gSCA9PT0gMiAqIGkgfHwgSCA9PT0gMiAqIHMgOiBFIGluc3RhbmNlb2YgbDtcbiAgfVxuICBmdW5jdGlvbiBPKEUsIFIsIHEgPSAhMCkge1xuICAgIGlmIChDKEUpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZmlyc3QgYXJnIG11c3QgYmUgcHJpdmF0ZSBrZXlcIik7XG4gICAgaWYgKCFDKFIpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2Vjb25kIGFyZyBtdXN0IGJlIHB1YmxpYyBrZXlcIik7XG4gICAgcmV0dXJuIGwuZnJvbUhleChSKS5tdWx0aXBseShmKEUpKS50b1Jhd0J5dGVzKHEpO1xuICB9XG4gIGNvbnN0IHcgPSBlLmJpdHMyaW50IHx8IGZ1bmN0aW9uKEUpIHtcbiAgICBjb25zdCBSID0gbGUoRSksIHEgPSBFLmxlbmd0aCAqIDggLSBlLm5CaXRMZW5ndGg7XG4gICAgcmV0dXJuIHEgPiAwID8gUiA+PiBCaWdJbnQocSkgOiBSO1xuICB9LCB4ID0gZS5iaXRzMmludF9tb2ROIHx8IGZ1bmN0aW9uKEUpIHtcbiAgICByZXR1cm4gYSh3KEUpKTtcbiAgfSwgQSA9IEtuKGUubkJpdExlbmd0aCk7XG4gIGZ1bmN0aW9uIEIoRSkge1xuICAgIGlmICh0eXBlb2YgRSAhPSBcImJpZ2ludFwiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmlnaW50IGV4cGVjdGVkXCIpO1xuICAgIGlmICghKGtlIDw9IEUgJiYgRSA8IEEpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBiaWdpbnQgZXhwZWN0ZWQgPCAyXiR7ZS5uQml0TGVuZ3RofWApO1xuICAgIHJldHVybiBldChFLCBlLm5CeXRlTGVuZ3RoKTtcbiAgfVxuICBmdW5jdGlvbiBMKEUsIFIsIHEgPSBQKSB7XG4gICAgaWYgKFtcInJlY292ZXJlZFwiLCBcImNhbm9uaWNhbFwiXS5zb21lKChtZSkgPT4gbWUgaW4gcSkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzaWduKCkgbGVnYWN5IG9wdGlvbnMgbm90IHN1cHBvcnRlZFwiKTtcbiAgICBjb25zdCB7IGhhc2g6IEgsIHJhbmRvbUJ5dGVzOiBEIH0gPSBlO1xuICAgIGxldCB7IGxvd1M6IFgsIHByZWhhc2g6IG9lLCBleHRyYUVudHJvcHk6IHJlIH0gPSBxO1xuICAgIFggPT0gbnVsbCAmJiAoWCA9ICEwKSwgRSA9IGVlKFwibXNnSGFzaFwiLCBFKSwgb2UgJiYgKEUgPSBlZShcInByZWhhc2hlZCBtc2dIYXNoXCIsIEgoRSkpKTtcbiAgICBjb25zdCBfZSA9IHgoRSksIE9lID0gZihSKSwgVWUgPSBbQihPZSksIEIoX2UpXTtcbiAgICBpZiAocmUgIT0gbnVsbCkge1xuICAgICAgY29uc3QgbWUgPSByZSA9PT0gITAgPyBEKHIuQllURVMpIDogcmU7XG4gICAgICBVZS5wdXNoKGVlKFwiZXh0cmFFbnRyb3B5XCIsIG1lLCByLkJZVEVTKSk7XG4gICAgfVxuICAgIGNvbnN0IFBlID0gaGUoLi4uVWUpLCB5ZSA9IF9lO1xuICAgIGZ1bmN0aW9uIGplKG1lKSB7XG4gICAgICBjb25zdCB4ZSA9IHcobWUpO1xuICAgICAgaWYgKCFoKHhlKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgbHIgPSBjKHhlKSwgQmUgPSBsLkJBU0UubXVsdGlwbHkoeGUpLnRvQWZmaW5lKCksIGZlID0gYShCZS54KTtcbiAgICAgIGlmIChmZSA9PT0ga2UpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IEhlID0gYShsciAqIGEoeWUgKyBmZSAqIE9lKSk7XG4gICAgICBpZiAoSGUgPT09IGtlKVxuICAgICAgICByZXR1cm47XG4gICAgICBsZXQgaXQgPSAoQmUueCA9PT0gZmUgPyAwIDogMikgfCBOdW1iZXIoQmUueSAmIFkpLCBvdCA9IEhlO1xuICAgICAgcmV0dXJuIFggJiYgcChIZSkgJiYgKG90ID0geShIZSksIGl0IF49IDEpLCBuZXcgdihmZSwgb3QsIGl0KTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc2VlZDogUGUsIGsyc2lnOiBqZSB9O1xuICB9XG4gIGNvbnN0IFAgPSB7IGxvd1M6IGUubG93UywgcHJlaGFzaDogITEgfSwgRiA9IHsgbG93UzogZS5sb3dTLCBwcmVoYXNoOiAhMSB9O1xuICBmdW5jdGlvbiB6KEUsIFIsIHEgPSBQKSB7XG4gICAgY29uc3QgeyBzZWVkOiBILCBrMnNpZzogRCB9ID0gTChFLCBSLCBxKTtcbiAgICByZXR1cm4gaXMoZS5oYXNoLm91dHB1dExlbiwgZS5uQnl0ZUxlbmd0aCwgZS5obWFjKShILCBEKTtcbiAgfVxuICBsLkJBU0UuX3NldFdpbmRvd1NpemUoOCk7XG4gIGZ1bmN0aW9uIEcoRSwgUiwgcSwgSCA9IEYpIHtcbiAgICB2YXIgQmU7XG4gICAgY29uc3QgRCA9IEU7XG4gICAgaWYgKFIgPSBlZShcIm1zZ0hhc2hcIiwgUiksIHEgPSBlZShcInB1YmxpY0tleVwiLCBxKSwgXCJzdHJpY3RcIiBpbiBIKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwib3B0aW9ucy5zdHJpY3Qgd2FzIHJlbmFtZWQgdG8gbG93U1wiKTtcbiAgICBjb25zdCB7IGxvd1M6IFgsIHByZWhhc2g6IG9lIH0gPSBIO1xuICAgIGxldCByZSwgX2U7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2YgRCA9PSBcInN0cmluZ1wiIHx8IEQgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlID0gdi5mcm9tREVSKEQpO1xuICAgICAgICB9IGNhdGNoIChmZSkge1xuICAgICAgICAgIGlmICghKGZlIGluc3RhbmNlb2YgbHQuRXJyKSlcbiAgICAgICAgICAgIHRocm93IGZlO1xuICAgICAgICAgIHJlID0gdi5mcm9tQ29tcGFjdChEKTtcbiAgICAgICAgfVxuICAgICAgZWxzZSBpZiAodHlwZW9mIEQgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgRC5yID09IFwiYmlnaW50XCIgJiYgdHlwZW9mIEQucyA9PSBcImJpZ2ludFwiKSB7XG4gICAgICAgIGNvbnN0IHsgcjogZmUsIHM6IEhlIH0gPSBEO1xuICAgICAgICByZSA9IG5ldyB2KGZlLCBIZSk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUEFSU0VcIik7XG4gICAgICBfZSA9IGwuZnJvbUhleChxKTtcbiAgICB9IGNhdGNoIChmZSkge1xuICAgICAgaWYgKGZlLm1lc3NhZ2UgPT09IFwiUEFSU0VcIilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2lnbmF0dXJlIG11c3QgYmUgU2lnbmF0dXJlIGluc3RhbmNlLCBVaW50OEFycmF5IG9yIGhleCBzdHJpbmdcIik7XG4gICAgICByZXR1cm4gITE7XG4gICAgfVxuICAgIGlmIChYICYmIHJlLmhhc0hpZ2hTKCkpXG4gICAgICByZXR1cm4gITE7XG4gICAgb2UgJiYgKFIgPSBlLmhhc2goUikpO1xuICAgIGNvbnN0IHsgcjogT2UsIHM6IFVlIH0gPSByZSwgUGUgPSB4KFIpLCB5ZSA9IGMoVWUpLCBqZSA9IGEoUGUgKiB5ZSksIG1lID0gYShPZSAqIHllKSwgeGUgPSAoQmUgPSBsLkJBU0UubXVsdGlwbHlBbmRBZGRVbnNhZmUoX2UsIGplLCBtZSkpID09IG51bGwgPyB2b2lkIDAgOiBCZS50b0FmZmluZSgpO1xuICAgIHJldHVybiB4ZSA/IGEoeGUueCkgPT09IE9lIDogITE7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBDVVJWRTogZSxcbiAgICBnZXRQdWJsaWNLZXk6IG0sXG4gICAgZ2V0U2hhcmVkU2VjcmV0OiBPLFxuICAgIHNpZ246IHosXG4gICAgdmVyaWZ5OiBHLFxuICAgIFByb2plY3RpdmVQb2ludDogbCxcbiAgICBTaWduYXR1cmU6IHYsXG4gICAgdXRpbHM6IF9cbiAgfTtcbn1cbmZ1bmN0aW9uIGV1KHQsIGUpIHtcbiAgY29uc3QgciA9IHQuT1JERVI7XG4gIGxldCBuID0ga2U7XG4gIGZvciAobGV0IGggPSByIC0gWTsgaCAlICRlID09PSBrZTsgaCAvPSAkZSlcbiAgICBuICs9IFk7XG4gIGNvbnN0IGkgPSBuLCBzID0gKHIgLSBZKSAvICRlICoqIGksIG8gPSAocyAtIFkpIC8gJGUsIGEgPSAkZSAqKiBpIC0gWSwgYyA9ICRlICoqIChpIC0gWSksIGwgPSB0LnBvdyhlLCBzKSwgZiA9IHQucG93KGUsIChzICsgWSkgLyAkZSk7XG4gIGxldCB1ID0gKGgsIGQpID0+IHtcbiAgICBsZXQgcCA9IGwsIHkgPSB0LnBvdyhkLCBhKSwgZyA9IHQuc3FyKHkpO1xuICAgIGcgPSB0Lm11bChnLCBkKTtcbiAgICBsZXQgdiA9IHQubXVsKGgsIGcpO1xuICAgIHYgPSB0LnBvdyh2LCBvKSwgdiA9IHQubXVsKHYsIHkpLCB5ID0gdC5tdWwodiwgZCksIGcgPSB0Lm11bCh2LCBoKTtcbiAgICBsZXQgXyA9IHQubXVsKGcsIHkpO1xuICAgIHYgPSB0LnBvdyhfLCBjKTtcbiAgICBsZXQgbSA9IHQuZXFsKHYsIHQuT05FKTtcbiAgICB5ID0gdC5tdWwoZywgZiksIHYgPSB0Lm11bChfLCBwKSwgZyA9IHQuY21vdih5LCBnLCBtKSwgXyA9IHQuY21vdih2LCBfLCBtKTtcbiAgICBmb3IgKGxldCBDID0gaTsgQyA+IFk7IEMtLSkge1xuICAgICAgbGV0IE8gPSAkZSAqKiAoQyAtICRlKSwgdyA9IHQucG93KF8sIE8pO1xuICAgICAgY29uc3QgeCA9IHQuZXFsKHcsIHQuT05FKTtcbiAgICAgIHkgPSB0Lm11bChnLCBwKSwgcCA9IHQubXVsKHAsIHApLCB3ID0gdC5tdWwoXywgcCksIGcgPSB0LmNtb3YoeSwgZywgeCksIF8gPSB0LmNtb3YodywgXywgeCk7XG4gICAgfVxuICAgIHJldHVybiB7IGlzVmFsaWQ6IG0sIHZhbHVlOiBnIH07XG4gIH07XG4gIGlmICh0Lk9SREVSICUgSGkgPT09IEFyKSB7XG4gICAgY29uc3QgaCA9ICh0Lk9SREVSIC0gQXIpIC8gSGksIGQgPSB0LnNxcnQodC5uZWcoZSkpO1xuICAgIHUgPSAocCwgeSkgPT4ge1xuICAgICAgbGV0IGcgPSB0LnNxcih5KTtcbiAgICAgIGNvbnN0IHYgPSB0Lm11bChwLCB5KTtcbiAgICAgIGcgPSB0Lm11bChnLCB2KTtcbiAgICAgIGxldCBfID0gdC5wb3coZywgaCk7XG4gICAgICBfID0gdC5tdWwoXywgdik7XG4gICAgICBjb25zdCBtID0gdC5tdWwoXywgZCksIEMgPSB0Lm11bCh0LnNxcihfKSwgeSksIE8gPSB0LmVxbChDLCBwKTtcbiAgICAgIGxldCB3ID0gdC5jbW92KG0sIF8sIE8pO1xuICAgICAgcmV0dXJuIHsgaXNWYWxpZDogTywgdmFsdWU6IHcgfTtcbiAgICB9O1xuICB9XG4gIHJldHVybiB1O1xufVxuZnVuY3Rpb24gdHUodCwgZSkge1xuICBpZiAob3ModCksICF0LmlzVmFsaWQoZS5BKSB8fCAhdC5pc1ZhbGlkKGUuQikgfHwgIXQuaXNWYWxpZChlLlopKVxuICAgIHRocm93IG5ldyBFcnJvcihcIm1hcFRvQ3VydmVTaW1wbGVTV1U6IGludmFsaWQgb3B0c1wiKTtcbiAgY29uc3QgciA9IGV1KHQsIGUuWik7XG4gIGlmICghdC5pc09kZClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJGcC5pc09kZCBpcyBub3QgaW1wbGVtZW50ZWQhXCIpO1xuICByZXR1cm4gKG4pID0+IHtcbiAgICBsZXQgaSwgcywgbywgYSwgYywgbCwgZiwgdTtcbiAgICBpID0gdC5zcXIobiksIGkgPSB0Lm11bChpLCBlLlopLCBzID0gdC5zcXIoaSksIHMgPSB0LmFkZChzLCBpKSwgbyA9IHQuYWRkKHMsIHQuT05FKSwgbyA9IHQubXVsKG8sIGUuQiksIGEgPSB0LmNtb3YoZS5aLCB0Lm5lZyhzKSwgIXQuZXFsKHMsIHQuWkVSTykpLCBhID0gdC5tdWwoYSwgZS5BKSwgcyA9IHQuc3FyKG8pLCBsID0gdC5zcXIoYSksIGMgPSB0Lm11bChsLCBlLkEpLCBzID0gdC5hZGQocywgYyksIHMgPSB0Lm11bChzLCBvKSwgbCA9IHQubXVsKGwsIGEpLCBjID0gdC5tdWwobCwgZS5CKSwgcyA9IHQuYWRkKHMsIGMpLCBmID0gdC5tdWwoaSwgbyk7XG4gICAgY29uc3QgeyBpc1ZhbGlkOiBoLCB2YWx1ZTogZCB9ID0gcihzLCBsKTtcbiAgICB1ID0gdC5tdWwoaSwgbiksIHUgPSB0Lm11bCh1LCBkKSwgZiA9IHQuY21vdihmLCBvLCBoKSwgdSA9IHQuY21vdih1LCBkLCBoKTtcbiAgICBjb25zdCBwID0gdC5pc09kZChuKSA9PT0gdC5pc09kZCh1KTtcbiAgICByZXR1cm4gdSA9IHQuY21vdih0Lm5lZyh1KSwgdSwgcCksIGYgPSB0LmRpdihmLCBhKSwgeyB4OiBmLCB5OiB1IH07XG4gIH07XG59XG5mdW5jdGlvbiBydSh0KSB7XG4gIGlmICh0IGluc3RhbmNlb2YgVWludDhBcnJheSlcbiAgICByZXR1cm4gdDtcbiAgaWYgKHR5cGVvZiB0ID09IFwic3RyaW5nXCIpXG4gICAgcmV0dXJuIHFyKHQpO1xuICB0aHJvdyBuZXcgRXJyb3IoXCJEU1QgbXVzdCBiZSBVaW50OEFycmF5IG9yIHN0cmluZ1wiKTtcbn1cbmNvbnN0IG51ID0gbGU7XG5mdW5jdGlvbiBaZSh0LCBlKSB7XG4gIGlmICh0IDwgMCB8fCB0ID49IDEgPDwgOCAqIGUpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBiYWQgSTJPU1AgY2FsbDogdmFsdWU9JHt0fSBsZW5ndGg9JHtlfWApO1xuICBjb25zdCByID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogZSB9KS5maWxsKDApO1xuICBmb3IgKGxldCBuID0gZSAtIDE7IG4gPj0gMDsgbi0tKVxuICAgIHJbbl0gPSB0ICYgMjU1LCB0ID4+Pj0gODtcbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHIpO1xufVxuZnVuY3Rpb24gaXUodCwgZSkge1xuICBjb25zdCByID0gbmV3IFVpbnQ4QXJyYXkodC5sZW5ndGgpO1xuICBmb3IgKGxldCBuID0gMDsgbiA8IHQubGVuZ3RoOyBuKyspXG4gICAgcltuXSA9IHRbbl0gXiBlW25dO1xuICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIHRyKHQpIHtcbiAgaWYgKCEodCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgIHRocm93IG5ldyBFcnJvcihcIlVpbnQ4QXJyYXkgZXhwZWN0ZWRcIik7XG59XG5mdW5jdGlvbiBWbih0KSB7XG4gIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIodCkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwibnVtYmVyIGV4cGVjdGVkXCIpO1xufVxuZnVuY3Rpb24gb3UodCwgZSwgciwgbikge1xuICB0cih0KSwgdHIoZSksIFZuKHIpLCBlLmxlbmd0aCA+IDI1NSAmJiAoZSA9IG4oaGUocXIoXCJIMkMtT1ZFUlNJWkUtRFNULVwiKSwgZSkpKTtcbiAgY29uc3QgeyBvdXRwdXRMZW46IGksIGJsb2NrTGVuOiBzIH0gPSBuLCBvID0gTWF0aC5jZWlsKHIgLyBpKTtcbiAgaWYgKG8gPiAyNTUpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB4bWQgbGVuZ3RoXCIpO1xuICBjb25zdCBhID0gaGUoZSwgWmUoZS5sZW5ndGgsIDEpKSwgYyA9IFplKDAsIHMpLCBsID0gWmUociwgMiksIGYgPSBuZXcgQXJyYXkobyksIHUgPSBuKGhlKGMsIHQsIGwsIFplKDAsIDEpLCBhKSk7XG4gIGZbMF0gPSBuKGhlKHUsIFplKDEsIDEpLCBhKSk7XG4gIGZvciAobGV0IGQgPSAxOyBkIDw9IG87IGQrKykge1xuICAgIGNvbnN0IHAgPSBbaXUodSwgZltkIC0gMV0pLCBaZShkICsgMSwgMSksIGFdO1xuICAgIGZbZF0gPSBuKGhlKC4uLnApKTtcbiAgfVxuICByZXR1cm4gaGUoLi4uZikuc2xpY2UoMCwgcik7XG59XG5mdW5jdGlvbiBzdSh0LCBlLCByLCBuLCBpKSB7XG4gIGlmICh0cih0KSwgdHIoZSksIFZuKHIpLCBlLmxlbmd0aCA+IDI1NSkge1xuICAgIGNvbnN0IHMgPSBNYXRoLmNlaWwoMiAqIG4gLyA4KTtcbiAgICBlID0gaS5jcmVhdGUoeyBka0xlbjogcyB9KS51cGRhdGUocXIoXCJIMkMtT1ZFUlNJWkUtRFNULVwiKSkudXBkYXRlKGUpLmRpZ2VzdCgpO1xuICB9XG4gIGlmIChyID4gNjU1MzUgfHwgZS5sZW5ndGggPiAyNTUpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZXhwYW5kX21lc3NhZ2VfeG9mOiBpbnZhbGlkIGxlbkluQnl0ZXNcIik7XG4gIHJldHVybiBpLmNyZWF0ZSh7IGRrTGVuOiByIH0pLnVwZGF0ZSh0KS51cGRhdGUoWmUociwgMikpLnVwZGF0ZShlKS51cGRhdGUoWmUoZS5sZW5ndGgsIDEpKS5kaWdlc3QoKTtcbn1cbmZ1bmN0aW9uIE1pKHQsIGUsIHIpIHtcbiAga3Qociwge1xuICAgIERTVDogXCJzdHJpbmdcIixcbiAgICBwOiBcImJpZ2ludFwiLFxuICAgIG06IFwiaXNTYWZlSW50ZWdlclwiLFxuICAgIGs6IFwiaXNTYWZlSW50ZWdlclwiLFxuICAgIGhhc2g6IFwiaGFzaFwiXG4gIH0pO1xuICBjb25zdCB7IHA6IG4sIGs6IGksIG06IHMsIGhhc2g6IG8sIGV4cGFuZDogYSwgRFNUOiBjIH0gPSByO1xuICB0cih0KSwgVm4oZSk7XG4gIGNvbnN0IGwgPSBydShjKSwgZiA9IG4udG9TdHJpbmcoMikubGVuZ3RoLCB1ID0gTWF0aC5jZWlsKChmICsgaSkgLyA4KSwgaCA9IGUgKiBzICogdTtcbiAgbGV0IGQ7XG4gIGlmIChhID09PSBcInhtZFwiKVxuICAgIGQgPSBvdSh0LCBsLCBoLCBvKTtcbiAgZWxzZSBpZiAoYSA9PT0gXCJ4b2ZcIilcbiAgICBkID0gc3UodCwgbCwgaCwgaSwgbyk7XG4gIGVsc2UgaWYgKGEgPT09IFwiX2ludGVybmFsX3Bhc3NcIilcbiAgICBkID0gdDtcbiAgZWxzZVxuICAgIHRocm93IG5ldyBFcnJvcignZXhwYW5kIG11c3QgYmUgXCJ4bWRcIiBvciBcInhvZlwiJyk7XG4gIGNvbnN0IHAgPSBuZXcgQXJyYXkoZSk7XG4gIGZvciAobGV0IHkgPSAwOyB5IDwgZTsgeSsrKSB7XG4gICAgY29uc3QgZyA9IG5ldyBBcnJheShzKTtcbiAgICBmb3IgKGxldCB2ID0gMDsgdiA8IHM7IHYrKykge1xuICAgICAgY29uc3QgXyA9IHUgKiAodiArIHkgKiBzKSwgbSA9IGQuc3ViYXJyYXkoXywgXyArIHUpO1xuICAgICAgZ1t2XSA9IEoobnUobSksIG4pO1xuICAgIH1cbiAgICBwW3ldID0gZztcbiAgfVxuICByZXR1cm4gcDtcbn1cbmZ1bmN0aW9uIGF1KHQsIGUpIHtcbiAgY29uc3QgciA9IGUubWFwKChuKSA9PiBBcnJheS5mcm9tKG4pLnJldmVyc2UoKSk7XG4gIHJldHVybiAobiwgaSkgPT4ge1xuICAgIGNvbnN0IFtzLCBvLCBhLCBjXSA9IHIubWFwKChsKSA9PiBsLnJlZHVjZSgoZiwgdSkgPT4gdC5hZGQodC5tdWwoZiwgbiksIHUpKSk7XG4gICAgcmV0dXJuIG4gPSB0LmRpdihzLCBvKSwgaSA9IHQubXVsKGksIHQuZGl2KGEsIGMpKSwgeyB4OiBuLCB5OiBpIH07XG4gIH07XG59XG5mdW5jdGlvbiBjdSh0LCBlLCByKSB7XG4gIGlmICh0eXBlb2YgZSAhPSBcImZ1bmN0aW9uXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwibWFwVG9DdXJ2ZSgpIG11c3QgYmUgZGVmaW5lZFwiKTtcbiAgcmV0dXJuIHtcbiAgICBoYXNoVG9DdXJ2ZShuLCBpKSB7XG4gICAgICBjb25zdCBzID0gTWkobiwgMiwgeyAuLi5yLCBEU1Q6IHIuRFNULCAuLi5pIH0pLCBvID0gdC5mcm9tQWZmaW5lKGUoc1swXSkpLCBhID0gdC5mcm9tQWZmaW5lKGUoc1sxXSkpLCBjID0gby5hZGQoYSkuY2xlYXJDb2ZhY3RvcigpO1xuICAgICAgcmV0dXJuIGMuYXNzZXJ0VmFsaWRpdHkoKSwgYztcbiAgICB9LFxuICAgIGVuY29kZVRvQ3VydmUobiwgaSkge1xuICAgICAgY29uc3QgcyA9IE1pKG4sIDEsIHsgLi4uciwgRFNUOiByLmVuY29kZURTVCwgLi4uaSB9KSwgbyA9IHQuZnJvbUFmZmluZShlKHNbMF0pKS5jbGVhckNvZmFjdG9yKCk7XG4gICAgICByZXR1cm4gby5hc3NlcnRWYWxpZGl0eSgpLCBvO1xuICAgIH1cbiAgfTtcbn1cbmNsYXNzIGFzIGV4dGVuZHMgSm8ge1xuICBjb25zdHJ1Y3RvcihlLCByKSB7XG4gICAgc3VwZXIoKSwgdGhpcy5maW5pc2hlZCA9ICExLCB0aGlzLmRlc3Ryb3llZCA9ICExLCB1dC5oYXNoKGUpO1xuICAgIGNvbnN0IG4gPSBEbihyKTtcbiAgICBpZiAodGhpcy5pSGFzaCA9IGUuY3JlYXRlKCksIHR5cGVvZiB0aGlzLmlIYXNoLnVwZGF0ZSAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgaW5zdGFuY2Ugb2YgY2xhc3Mgd2hpY2ggZXh0ZW5kcyB1dGlscy5IYXNoXCIpO1xuICAgIHRoaXMuYmxvY2tMZW4gPSB0aGlzLmlIYXNoLmJsb2NrTGVuLCB0aGlzLm91dHB1dExlbiA9IHRoaXMuaUhhc2gub3V0cHV0TGVuO1xuICAgIGNvbnN0IGkgPSB0aGlzLmJsb2NrTGVuLCBzID0gbmV3IFVpbnQ4QXJyYXkoaSk7XG4gICAgcy5zZXQobi5sZW5ndGggPiBpID8gZS5jcmVhdGUoKS51cGRhdGUobikuZGlnZXN0KCkgOiBuKTtcbiAgICBmb3IgKGxldCBvID0gMDsgbyA8IHMubGVuZ3RoOyBvKyspXG4gICAgICBzW29dIF49IDU0O1xuICAgIHRoaXMuaUhhc2gudXBkYXRlKHMpLCB0aGlzLm9IYXNoID0gZS5jcmVhdGUoKTtcbiAgICBmb3IgKGxldCBvID0gMDsgbyA8IHMubGVuZ3RoOyBvKyspXG4gICAgICBzW29dIF49IDEwNjtcbiAgICB0aGlzLm9IYXNoLnVwZGF0ZShzKSwgcy5maWxsKDApO1xuICB9XG4gIHVwZGF0ZShlKSB7XG4gICAgcmV0dXJuIHV0LmV4aXN0cyh0aGlzKSwgdGhpcy5pSGFzaC51cGRhdGUoZSksIHRoaXM7XG4gIH1cbiAgZGlnZXN0SW50byhlKSB7XG4gICAgdXQuZXhpc3RzKHRoaXMpLCB1dC5ieXRlcyhlLCB0aGlzLm91dHB1dExlbiksIHRoaXMuZmluaXNoZWQgPSAhMCwgdGhpcy5pSGFzaC5kaWdlc3RJbnRvKGUpLCB0aGlzLm9IYXNoLnVwZGF0ZShlKSwgdGhpcy5vSGFzaC5kaWdlc3RJbnRvKGUpLCB0aGlzLmRlc3Ryb3koKTtcbiAgfVxuICBkaWdlc3QoKSB7XG4gICAgY29uc3QgZSA9IG5ldyBVaW50OEFycmF5KHRoaXMub0hhc2gub3V0cHV0TGVuKTtcbiAgICByZXR1cm4gdGhpcy5kaWdlc3RJbnRvKGUpLCBlO1xuICB9XG4gIF9jbG9uZUludG8oZSkge1xuICAgIGUgfHwgKGUgPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSwge30pKTtcbiAgICBjb25zdCB7IG9IYXNoOiByLCBpSGFzaDogbiwgZmluaXNoZWQ6IGksIGRlc3Ryb3llZDogcywgYmxvY2tMZW46IG8sIG91dHB1dExlbjogYSB9ID0gdGhpcztcbiAgICByZXR1cm4gZSA9IGUsIGUuZmluaXNoZWQgPSBpLCBlLmRlc3Ryb3llZCA9IHMsIGUuYmxvY2tMZW4gPSBvLCBlLm91dHB1dExlbiA9IGEsIGUub0hhc2ggPSByLl9jbG9uZUludG8oZS5vSGFzaCksIGUuaUhhc2ggPSBuLl9jbG9uZUludG8oZS5pSGFzaCksIGU7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRlc3Ryb3llZCA9ICEwLCB0aGlzLm9IYXNoLmRlc3Ryb3koKSwgdGhpcy5pSGFzaC5kZXN0cm95KCk7XG4gIH1cbn1cbmNvbnN0IGNzID0gKHQsIGUsIHIpID0+IG5ldyBhcyh0LCBlKS51cGRhdGUocikuZGlnZXN0KCk7XG5jcy5jcmVhdGUgPSAodCwgZSkgPT4gbmV3IGFzKHQsIGUpO1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuZnVuY3Rpb24gdXUodCkge1xuICByZXR1cm4ge1xuICAgIGhhc2g6IHQsXG4gICAgaG1hYzogKGUsIC4uLnIpID0+IGNzKHQsIGUsIG1jKC4uLnIpKSxcbiAgICByYW5kb21CeXRlczogUW9cbiAgfTtcbn1cbmZ1bmN0aW9uIGx1KHQsIGUpIHtcbiAgY29uc3QgciA9IChuKSA9PiBRYyh7IC4uLnQsIC4uLnV1KG4pIH0pO1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IC4uLnIoZSksIGNyZWF0ZTogciB9KTtcbn1cbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmNvbnN0IE5yID0gQmlnSW50KFwiMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWZmZmZmYzJmXCIpLCBDciA9IEJpZ0ludChcIjB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmViYWFlZGNlNmFmNDhhMDNiYmZkMjVlOGNkMDM2NDE0MVwiKSwgdXMgPSBCaWdJbnQoMSksIElyID0gQmlnSW50KDIpLCBEaSA9ICh0LCBlKSA9PiAodCArIGUgLyBJcikgLyBlO1xuZnVuY3Rpb24gbHModCkge1xuICBjb25zdCBlID0gTnIsIHIgPSBCaWdJbnQoMyksIG4gPSBCaWdJbnQoNiksIGkgPSBCaWdJbnQoMTEpLCBzID0gQmlnSW50KDIyKSwgbyA9IEJpZ0ludCgyMyksIGEgPSBCaWdJbnQoNDQpLCBjID0gQmlnSW50KDg4KSwgbCA9IHQgKiB0ICogdCAlIGUsIGYgPSBsICogbCAqIHQgJSBlLCB1ID0gYmUoZiwgciwgZSkgKiBmICUgZSwgaCA9IGJlKHUsIHIsIGUpICogZiAlIGUsIGQgPSBiZShoLCBJciwgZSkgKiBsICUgZSwgcCA9IGJlKGQsIGksIGUpICogZCAlIGUsIHkgPSBiZShwLCBzLCBlKSAqIHAgJSBlLCBnID0gYmUoeSwgYSwgZSkgKiB5ICUgZSwgdiA9IGJlKGcsIGMsIGUpICogZyAlIGUsIF8gPSBiZSh2LCBhLCBlKSAqIHkgJSBlLCBtID0gYmUoXywgciwgZSkgKiBmICUgZSwgQyA9IGJlKG0sIG8sIGUpICogcCAlIGUsIE8gPSBiZShDLCBuLCBlKSAqIGwgJSBlLCB3ID0gYmUoTywgSXIsIGUpO1xuICBpZiAoIXR0LmVxbCh0dC5zcXIodyksIHQpKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIHNxdWFyZSByb290XCIpO1xuICByZXR1cm4gdztcbn1cbmNvbnN0IHR0ID0gRmMoTnIsIHZvaWQgMCwgdm9pZCAwLCB7IHNxcnQ6IGxzIH0pLCB1ZSA9IGx1KHtcbiAgYTogQmlnSW50KDApLFxuICBiOiBCaWdJbnQoNyksXG4gIEZwOiB0dCxcbiAgbjogQ3IsXG4gIEd4OiBCaWdJbnQoXCI1NTA2NjI2MzAyMjI3NzM0MzY2OTU3ODcxODg5NTE2ODUzNDMyNjI1MDYwMzQ1Mzc3NzU5NDE3NTUwMDE4NzM2MDM4OTExNjcyOTI0MFwiKSxcbiAgR3k6IEJpZ0ludChcIjMyNjcwNTEwMDIwNzU4ODE2OTc4MDgzMDg1MTMwNTA3MDQzMTg0NDcxMjczMzgwNjU5MjQzMjc1OTM4OTA0MzM1NzU3MzM3NDgyNDI0XCIpLFxuICBoOiBCaWdJbnQoMSksXG4gIGxvd1M6ICEwLFxuICBlbmRvOiB7XG4gICAgYmV0YTogQmlnSW50KFwiMHg3YWU5NmEyYjY1N2MwNzEwNmU2NDQ3OWVhYzM0MzRlOTljZjA0OTc1MTJmNTg5OTVjMTM5NmMyODcxOTUwMWVlXCIpLFxuICAgIHNwbGl0U2NhbGFyOiAodCkgPT4ge1xuICAgICAgY29uc3QgZSA9IENyLCByID0gQmlnSW50KFwiMHgzMDg2ZDIyMWE3ZDQ2YmNkZTg2YzkwZTQ5Mjg0ZWIxNVwiKSwgbiA9IC11cyAqIEJpZ0ludChcIjB4ZTQ0MzdlZDYwMTBlODgyODZmNTQ3ZmE5MGFiZmU0YzNcIiksIGkgPSBCaWdJbnQoXCIweDExNGNhNTBmN2E4ZTJmM2Y2NTdjMTEwOGQ5ZDQ0Y2ZkOFwiKSwgcyA9IHIsIG8gPSBCaWdJbnQoXCIweDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiKSwgYSA9IERpKHMgKiB0LCBlKSwgYyA9IERpKC1uICogdCwgZSk7XG4gICAgICBsZXQgbCA9IEoodCAtIGEgKiByIC0gYyAqIGksIGUpLCBmID0gSigtYSAqIG4gLSBjICogcywgZSk7XG4gICAgICBjb25zdCB1ID0gbCA+IG8sIGggPSBmID4gbztcbiAgICAgIGlmICh1ICYmIChsID0gZSAtIGwpLCBoICYmIChmID0gZSAtIGYpLCBsID4gbyB8fCBmID4gbylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic3BsaXRTY2FsYXI6IEVuZG9tb3JwaGlzbSBmYWlsZWQsIGs9XCIgKyB0KTtcbiAgICAgIHJldHVybiB7IGsxbmVnOiB1LCBrMTogbCwgazJuZWc6IGgsIGsyOiBmIH07XG4gICAgfVxuICB9XG59LCBPciksIFVyID0gQmlnSW50KDApLCBmcyA9ICh0KSA9PiB0eXBlb2YgdCA9PSBcImJpZ2ludFwiICYmIFVyIDwgdCAmJiB0IDwgTnIsIGZ1ID0gKHQpID0+IHR5cGVvZiB0ID09IFwiYmlnaW50XCIgJiYgVXIgPCB0ICYmIHQgPCBDciwgemkgPSB7fTtcbmZ1bmN0aW9uIFJyKHQsIC4uLmUpIHtcbiAgbGV0IHIgPSB6aVt0XTtcbiAgaWYgKHIgPT09IHZvaWQgMCkge1xuICAgIGNvbnN0IG4gPSBPcihVaW50OEFycmF5LmZyb20odCwgKGkpID0+IGkuY2hhckNvZGVBdCgwKSkpO1xuICAgIHIgPSBoZShuLCBuKSwgemlbdF0gPSByO1xuICB9XG4gIHJldHVybiBPcihoZShyLCAuLi5lKSk7XG59XG5jb25zdCBHbiA9ICh0KSA9PiB0LnRvUmF3Qnl0ZXMoITApLnNsaWNlKDEpLCBSbiA9ICh0KSA9PiBldCh0LCAzMiksIHNuID0gKHQpID0+IEoodCwgTnIpLCByciA9ICh0KSA9PiBKKHQsIENyKSwgWm4gPSB1ZS5Qcm9qZWN0aXZlUG9pbnQsIGh1ID0gKHQsIGUsIHIpID0+IFpuLkJBU0UubXVsdGlwbHlBbmRBZGRVbnNhZmUodCwgZSwgcik7XG5mdW5jdGlvbiBUbih0KSB7XG4gIGxldCBlID0gdWUudXRpbHMubm9ybVByaXZhdGVLZXlUb1NjYWxhcih0KSwgciA9IFpuLmZyb21Qcml2YXRlS2V5KGUpO1xuICByZXR1cm4geyBzY2FsYXI6IHIuaGFzRXZlblkoKSA/IGUgOiBycigtZSksIGJ5dGVzOiBHbihyKSB9O1xufVxuZnVuY3Rpb24gaHModCkge1xuICBpZiAoIWZzKHQpKVxuICAgIHRocm93IG5ldyBFcnJvcihcImJhZCB4OiBuZWVkIDAgPCB4IDwgcFwiKTtcbiAgY29uc3QgZSA9IHNuKHQgKiB0KSwgciA9IHNuKGUgKiB0ICsgQmlnSW50KDcpKTtcbiAgbGV0IG4gPSBscyhyKTtcbiAgbiAlIElyICE9PSBVciAmJiAobiA9IHNuKC1uKSk7XG4gIGNvbnN0IGkgPSBuZXcgWm4odCwgbiwgdXMpO1xuICByZXR1cm4gaS5hc3NlcnRWYWxpZGl0eSgpLCBpO1xufVxuZnVuY3Rpb24gZHMoLi4udCkge1xuICByZXR1cm4gcnIobGUoUnIoXCJCSVAwMzQwL2NoYWxsZW5nZVwiLCAuLi50KSkpO1xufVxuZnVuY3Rpb24gZHUodCkge1xuICByZXR1cm4gVG4odCkuYnl0ZXM7XG59XG5mdW5jdGlvbiBwdSh0LCBlLCByID0gUW8oMzIpKSB7XG4gIGNvbnN0IG4gPSBlZShcIm1lc3NhZ2VcIiwgdCksIHsgYnl0ZXM6IGksIHNjYWxhcjogcyB9ID0gVG4oZSksIG8gPSBlZShcImF1eFJhbmRcIiwgciwgMzIpLCBhID0gUm4ocyBeIGxlKFJyKFwiQklQMDM0MC9hdXhcIiwgbykpKSwgYyA9IFJyKFwiQklQMDM0MC9ub25jZVwiLCBhLCBpLCBuKSwgbCA9IHJyKGxlKGMpKTtcbiAgaWYgKGwgPT09IFVyKVxuICAgIHRocm93IG5ldyBFcnJvcihcInNpZ24gZmFpbGVkOiBrIGlzIHplcm9cIik7XG4gIGNvbnN0IHsgYnl0ZXM6IGYsIHNjYWxhcjogdSB9ID0gVG4obCksIGggPSBkcyhmLCBpLCBuKSwgZCA9IG5ldyBVaW50OEFycmF5KDY0KTtcbiAgaWYgKGQuc2V0KGYsIDApLCBkLnNldChSbihycih1ICsgaCAqIHMpKSwgMzIpLCAhcHMoZCwgbiwgaSkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwic2lnbjogSW52YWxpZCBzaWduYXR1cmUgcHJvZHVjZWRcIik7XG4gIHJldHVybiBkO1xufVxuZnVuY3Rpb24gcHModCwgZSwgcikge1xuICBjb25zdCBuID0gZWUoXCJzaWduYXR1cmVcIiwgdCwgNjQpLCBpID0gZWUoXCJtZXNzYWdlXCIsIGUpLCBzID0gZWUoXCJwdWJsaWNLZXlcIiwgciwgMzIpO1xuICB0cnkge1xuICAgIGNvbnN0IG8gPSBocyhsZShzKSksIGEgPSBsZShuLnN1YmFycmF5KDAsIDMyKSk7XG4gICAgaWYgKCFmcyhhKSlcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCBjID0gbGUobi5zdWJhcnJheSgzMiwgNjQpKTtcbiAgICBpZiAoIWZ1KGMpKVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IGwgPSBkcyhSbihhKSwgR24obyksIGkpLCBmID0gaHUobywgYywgcnIoLWwpKTtcbiAgICByZXR1cm4gISghZiB8fCAhZi5oYXNFdmVuWSgpIHx8IGYudG9BZmZpbmUoKS54ICE9PSBhKTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuICExO1xuICB9XG59XG5jb25zdCBTdCA9IHtcbiAgZ2V0UHVibGljS2V5OiBkdSxcbiAgc2lnbjogcHUsXG4gIHZlcmlmeTogcHMsXG4gIHV0aWxzOiB7XG4gICAgcmFuZG9tUHJpdmF0ZUtleTogdWUudXRpbHMucmFuZG9tUHJpdmF0ZUtleSxcbiAgICBsaWZ0X3g6IGhzLFxuICAgIHBvaW50VG9CeXRlczogR24sXG4gICAgbnVtYmVyVG9CeXRlc0JFOiBldCxcbiAgICBieXRlc1RvTnVtYmVyQkU6IGxlLFxuICAgIHRhZ2dlZEhhc2g6IFJyLFxuICAgIG1vZDogSlxuICB9XG59LCB5dSA9IGF1KHR0LCBbXG4gIFtcbiAgICBcIjB4OGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGRhYWFhYThjN1wiLFxuICAgIFwiMHg3ZDNkNGM4MGJjMzIxZDViOWYzMTVjZWE3ZmQ0NGM1ZDU5NWQyZmMwYmY2M2I5MmRmZmYxMDQ0ZjE3YzY1ODFcIixcbiAgICBcIjB4NTM0YzMyOGQyM2YyMzRlNmUyYTQxM2RlY2EyNWNhZWNlNDUwNjE0NDAzN2M0MDMxNGVjYmQwYjUzZDlkZDI2MlwiLFxuICAgIFwiMHg4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZGFhYWFhODhjXCJcbiAgXSxcbiAgW1xuICAgIFwiMHhkMzU3NzExOTNkOTQ5MThhOWNhMzRjY2JiN2I2NDBkZDg2Y2Q0MDk1NDJmODQ4N2Q5ZmU2Yjc0NTc4MWViNDliXCIsXG4gICAgXCIweGVkYWRjNmY2NDM4M2RjMWRmN2M0YjJkNTFiNTQyMjU0MDZkMzZiNjQxZjVlNDFiYmM1MmE1NjYxMmE4YzZkMTRcIixcbiAgICBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMVwiXG4gIF0sXG4gIFtcbiAgICBcIjB4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGI4ZTM4ZTIzY1wiLFxuICAgIFwiMHhjNzVlMGMzMmQ1Y2I3YzBmYTlkMGE1NGIxMmEwYTZkNTY0N2FiMDQ2ZDY4NmRhNmZkZmZjOTBmYzIwMWQ3MWEzXCIsXG4gICAgXCIweDI5YTYxOTQ2OTFmOTFhNzM3MTUyMDllZjY1MTJlNTc2NzIyODMwYTIwMWJlMjAxOGE3NjVlODVhOWVjZWU5MzFcIixcbiAgICBcIjB4MmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmYzOGUzOGQ4NFwiXG4gIF0sXG4gIFtcbiAgICBcIjB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmVmZmZmZjkzYlwiLFxuICAgIFwiMHg3YTA2NTM0YmI4YmRiNDlmZDVlOWU2NjMyNzIyYzI5ODk0NjdjMWJmYzhlOGQ5NzhkZmI0MjVkMjY4NWMyNTczXCIsXG4gICAgXCIweDY0ODRhYTcxNjU0NWNhMmNmM2E3MGMzZmE4ZmUzMzdlMGEzZDIxMTYyZjBkNjI5OWE3YmY4MTkyYmZkMmE3NmZcIixcbiAgICBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMVwiXG4gIF1cbl0ubWFwKCh0KSA9PiB0Lm1hcCgoZSkgPT4gQmlnSW50KGUpKSkpLCBndSA9IHR1KHR0LCB7XG4gIEE6IEJpZ0ludChcIjB4M2Y4NzMxYWJkZDY2MWFkY2EwOGE1NTU4ZjBmNWQyNzJlOTUzZDM2M2NiNmYwZTVkNDA1NDQ3YzAxYTQ0NDUzM1wiKSxcbiAgQjogQmlnSW50KFwiMTc3MVwiKSxcbiAgWjogdHQuY3JlYXRlKEJpZ0ludChcIi0xMVwiKSlcbn0pO1xuY3UodWUuUHJvamVjdGl2ZVBvaW50LCAodCkgPT4ge1xuICBjb25zdCB7IHg6IGUsIHk6IHIgfSA9IGd1KHR0LmNyZWF0ZSh0WzBdKSk7XG4gIHJldHVybiB5dShlLCByKTtcbn0sIHtcbiAgRFNUOiBcInNlY3AyNTZrMV9YTUQ6U0hBLTI1Nl9TU1dVX1JPX1wiLFxuICBlbmNvZGVEU1Q6IFwic2VjcDI1NmsxX1hNRDpTSEEtMjU2X1NTV1VfTlVfXCIsXG4gIHA6IHR0Lk9SREVSLFxuICBtOiAxLFxuICBrOiAxMjgsXG4gIGV4cGFuZDogXCJ4bWRcIixcbiAgaGFzaDogT3Jcbn0pO1xuY29uc3QgYW4gPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PSBcIm9iamVjdFwiICYmIFwiY3J5cHRvXCIgaW4gZ2xvYmFsVGhpcyA/IGdsb2JhbFRoaXMuY3J5cHRvIDogdm9pZCAwO1xuLyohIG5vYmxlLWhhc2hlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuY29uc3QgY24gPSAodCkgPT4gbmV3IERhdGFWaWV3KHQuYnVmZmVyLCB0LmJ5dGVPZmZzZXQsIHQuYnl0ZUxlbmd0aCksIENlID0gKHQsIGUpID0+IHQgPDwgMzIgLSBlIHwgdCA+Pj4gZSwgYnUgPSBuZXcgVWludDhBcnJheShuZXcgVWludDMyQXJyYXkoWzI4NzQ1NDAyMF0pLmJ1ZmZlcilbMF0gPT09IDY4O1xuaWYgKCFidSlcbiAgdGhyb3cgbmV3IEVycm9yKFwiTm9uIGxpdHRsZS1lbmRpYW4gaGFyZHdhcmUgaXMgbm90IHN1cHBvcnRlZFwiKTtcbmNvbnN0IHZ1ID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sICh0LCBlKSA9PiBlLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIikpO1xuZnVuY3Rpb24gdmUodCkge1xuICBpZiAoISh0IGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVWludDhBcnJheSBleHBlY3RlZFwiKTtcbiAgbGV0IGUgPSBcIlwiO1xuICBmb3IgKGxldCByID0gMDsgciA8IHQubGVuZ3RoOyByKyspXG4gICAgZSArPSB2dVt0W3JdXTtcbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBfdCh0KSB7XG4gIGlmICh0eXBlb2YgdCAhPSBcInN0cmluZ1wiKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJoZXhUb0J5dGVzOiBleHBlY3RlZCBzdHJpbmcsIGdvdCBcIiArIHR5cGVvZiB0KTtcbiAgaWYgKHQubGVuZ3RoICUgMilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJoZXhUb0J5dGVzOiByZWNlaXZlZCBpbnZhbGlkIHVucGFkZGVkIGhleFwiKTtcbiAgY29uc3QgZSA9IG5ldyBVaW50OEFycmF5KHQubGVuZ3RoIC8gMik7XG4gIGZvciAobGV0IHIgPSAwOyByIDwgZS5sZW5ndGg7IHIrKykge1xuICAgIGNvbnN0IG4gPSByICogMiwgaSA9IHQuc2xpY2UobiwgbiArIDIpLCBzID0gTnVtYmVyLnBhcnNlSW50KGksIDE2KTtcbiAgICBpZiAoTnVtYmVyLmlzTmFOKHMpIHx8IHMgPCAwKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBieXRlIHNlcXVlbmNlXCIpO1xuICAgIGVbcl0gPSBzO1xuICB9XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gd3UodCkge1xuICBpZiAodHlwZW9mIHQgIT0gXCJzdHJpbmdcIilcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB1dGY4VG9CeXRlcyBleHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiB0fWApO1xuICByZXR1cm4gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHQpO1xufVxuZnVuY3Rpb24geXModCkge1xuICBpZiAodHlwZW9mIHQgPT0gXCJzdHJpbmdcIiAmJiAodCA9IHd1KHQpKSwgISh0IGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgaW5wdXQgdHlwZSBpcyBVaW50OEFycmF5IChnb3QgJHt0eXBlb2YgdH0pYCk7XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gX3UoLi4udCkge1xuICBpZiAoIXQuZXZlcnkoKG4pID0+IG4gaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVaW50OEFycmF5IGxpc3QgZXhwZWN0ZWRcIik7XG4gIGlmICh0Lmxlbmd0aCA9PT0gMSlcbiAgICByZXR1cm4gdFswXTtcbiAgY29uc3QgZSA9IHQucmVkdWNlKChuLCBpKSA9PiBuICsgaS5sZW5ndGgsIDApLCByID0gbmV3IFVpbnQ4QXJyYXkoZSk7XG4gIGZvciAobGV0IG4gPSAwLCBpID0gMDsgbiA8IHQubGVuZ3RoOyBuKyspIHtcbiAgICBjb25zdCBzID0gdFtuXTtcbiAgICByLnNldChzLCBpKSwgaSArPSBzLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gcjtcbn1cbmNsYXNzIG11IHtcbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nsb25lSW50bygpO1xuICB9XG59XG5mdW5jdGlvbiBncyh0KSB7XG4gIGNvbnN0IGUgPSAobikgPT4gdCgpLnVwZGF0ZSh5cyhuKSkuZGlnZXN0KCksIHIgPSB0KCk7XG4gIHJldHVybiBlLm91dHB1dExlbiA9IHIub3V0cHV0TGVuLCBlLmJsb2NrTGVuID0gci5ibG9ja0xlbiwgZS5jcmVhdGUgPSAoKSA9PiB0KCksIGU7XG59XG5mdW5jdGlvbiB4dSh0ID0gMzIpIHtcbiAgaWYgKGFuICYmIHR5cGVvZiBhbi5nZXRSYW5kb21WYWx1ZXMgPT0gXCJmdW5jdGlvblwiKVxuICAgIHJldHVybiBhbi5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkodCkpO1xuICB0aHJvdyBuZXcgRXJyb3IoXCJjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIG11c3QgYmUgZGVmaW5lZFwiKTtcbn1cbmZ1bmN0aW9uIFBuKHQpIHtcbiAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcih0KSB8fCB0IDwgMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFdyb25nIHBvc2l0aXZlIGludGVnZXI6ICR7dH1gKTtcbn1cbmZ1bmN0aW9uIEV1KHQpIHtcbiAgaWYgKHR5cGVvZiB0ICE9IFwiYm9vbGVhblwiKVxuICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYm9vbGVhbiwgbm90ICR7dH1gKTtcbn1cbmZ1bmN0aW9uIGJzKHQsIC4uLmUpIHtcbiAgaWYgKCEodCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBVaW50OEFycmF5XCIpO1xuICBpZiAoZS5sZW5ndGggPiAwICYmICFlLmluY2x1ZGVzKHQubGVuZ3RoKSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBVaW50OEFycmF5IG9mIGxlbmd0aCAke2V9LCBub3Qgb2YgbGVuZ3RoPSR7dC5sZW5ndGh9YCk7XG59XG5mdW5jdGlvbiBrdSh0KSB7XG4gIGlmICh0eXBlb2YgdCAhPSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIHQuY3JlYXRlICE9IFwiZnVuY3Rpb25cIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJIYXNoIHNob3VsZCBiZSB3cmFwcGVkIGJ5IHV0aWxzLndyYXBDb25zdHJ1Y3RvclwiKTtcbiAgUG4odC5vdXRwdXRMZW4pLCBQbih0LmJsb2NrTGVuKTtcbn1cbmZ1bmN0aW9uIFN1KHQsIGUgPSAhMCkge1xuICBpZiAodC5kZXN0cm95ZWQpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSGFzaCBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWRcIik7XG4gIGlmIChlICYmIHQuZmluaXNoZWQpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSGFzaCNkaWdlc3QoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZFwiKTtcbn1cbmZ1bmN0aW9uIE91KHQsIGUpIHtcbiAgYnModCk7XG4gIGNvbnN0IHIgPSBlLm91dHB1dExlbjtcbiAgaWYgKHQubGVuZ3RoIDwgcilcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGRpZ2VzdEludG8oKSBleHBlY3RzIG91dHB1dCBidWZmZXIgb2YgbGVuZ3RoIGF0IGxlYXN0ICR7cn1gKTtcbn1cbmNvbnN0IHVuID0ge1xuICBudW1iZXI6IFBuLFxuICBib29sOiBFdSxcbiAgYnl0ZXM6IGJzLFxuICBoYXNoOiBrdSxcbiAgZXhpc3RzOiBTdSxcbiAgb3V0cHV0OiBPdVxufTtcbmZ1bmN0aW9uIEF1KHQsIGUsIHIsIG4pIHtcbiAgaWYgKHR5cGVvZiB0LnNldEJpZ1VpbnQ2NCA9PSBcImZ1bmN0aW9uXCIpXG4gICAgcmV0dXJuIHQuc2V0QmlnVWludDY0KGUsIHIsIG4pO1xuICBjb25zdCBpID0gQmlnSW50KDMyKSwgcyA9IEJpZ0ludCg0Mjk0OTY3Mjk1KSwgbyA9IE51bWJlcihyID4+IGkgJiBzKSwgYSA9IE51bWJlcihyICYgcyksIGMgPSBuID8gNCA6IDAsIGwgPSBuID8gMCA6IDQ7XG4gIHQuc2V0VWludDMyKGUgKyBjLCBvLCBuKSwgdC5zZXRVaW50MzIoZSArIGwsIGEsIG4pO1xufVxuY2xhc3MgQ3UgZXh0ZW5kcyBtdSB7XG4gIGNvbnN0cnVjdG9yKGUsIHIsIG4sIGkpIHtcbiAgICBzdXBlcigpLCB0aGlzLmJsb2NrTGVuID0gZSwgdGhpcy5vdXRwdXRMZW4gPSByLCB0aGlzLnBhZE9mZnNldCA9IG4sIHRoaXMuaXNMRSA9IGksIHRoaXMuZmluaXNoZWQgPSAhMSwgdGhpcy5sZW5ndGggPSAwLCB0aGlzLnBvcyA9IDAsIHRoaXMuZGVzdHJveWVkID0gITEsIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoZSksIHRoaXMudmlldyA9IGNuKHRoaXMuYnVmZmVyKTtcbiAgfVxuICB1cGRhdGUoZSkge1xuICAgIHVuLmV4aXN0cyh0aGlzKTtcbiAgICBjb25zdCB7IHZpZXc6IHIsIGJ1ZmZlcjogbiwgYmxvY2tMZW46IGkgfSA9IHRoaXM7XG4gICAgZSA9IHlzKGUpO1xuICAgIGNvbnN0IHMgPSBlLmxlbmd0aDtcbiAgICBmb3IgKGxldCBvID0gMDsgbyA8IHM7ICkge1xuICAgICAgY29uc3QgYSA9IE1hdGgubWluKGkgLSB0aGlzLnBvcywgcyAtIG8pO1xuICAgICAgaWYgKGEgPT09IGkpIHtcbiAgICAgICAgY29uc3QgYyA9IGNuKGUpO1xuICAgICAgICBmb3IgKDsgaSA8PSBzIC0gbzsgbyArPSBpKVxuICAgICAgICAgIHRoaXMucHJvY2VzcyhjLCBvKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBuLnNldChlLnN1YmFycmF5KG8sIG8gKyBhKSwgdGhpcy5wb3MpLCB0aGlzLnBvcyArPSBhLCBvICs9IGEsIHRoaXMucG9zID09PSBpICYmICh0aGlzLnByb2Nlc3MociwgMCksIHRoaXMucG9zID0gMCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxlbmd0aCArPSBlLmxlbmd0aCwgdGhpcy5yb3VuZENsZWFuKCksIHRoaXM7XG4gIH1cbiAgZGlnZXN0SW50byhlKSB7XG4gICAgdW4uZXhpc3RzKHRoaXMpLCB1bi5vdXRwdXQoZSwgdGhpcyksIHRoaXMuZmluaXNoZWQgPSAhMDtcbiAgICBjb25zdCB7IGJ1ZmZlcjogciwgdmlldzogbiwgYmxvY2tMZW46IGksIGlzTEU6IHMgfSA9IHRoaXM7XG4gICAgbGV0IHsgcG9zOiBvIH0gPSB0aGlzO1xuICAgIHJbbysrXSA9IDEyOCwgdGhpcy5idWZmZXIuc3ViYXJyYXkobykuZmlsbCgwKSwgdGhpcy5wYWRPZmZzZXQgPiBpIC0gbyAmJiAodGhpcy5wcm9jZXNzKG4sIDApLCBvID0gMCk7XG4gICAgZm9yIChsZXQgdSA9IG87IHUgPCBpOyB1KyspXG4gICAgICByW3VdID0gMDtcbiAgICBBdShuLCBpIC0gOCwgQmlnSW50KHRoaXMubGVuZ3RoICogOCksIHMpLCB0aGlzLnByb2Nlc3MobiwgMCk7XG4gICAgY29uc3QgYSA9IGNuKGUpLCBjID0gdGhpcy5vdXRwdXRMZW47XG4gICAgaWYgKGMgJSA0KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiX3NoYTI6IG91dHB1dExlbiBzaG91bGQgYmUgYWxpZ25lZCB0byAzMmJpdFwiKTtcbiAgICBjb25zdCBsID0gYyAvIDQsIGYgPSB0aGlzLmdldCgpO1xuICAgIGlmIChsID4gZi5sZW5ndGgpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJfc2hhMjogb3V0cHV0TGVuIGJpZ2dlciB0aGFuIHN0YXRlXCIpO1xuICAgIGZvciAobGV0IHUgPSAwOyB1IDwgbDsgdSsrKVxuICAgICAgYS5zZXRVaW50MzIoNCAqIHUsIGZbdV0sIHMpO1xuICB9XG4gIGRpZ2VzdCgpIHtcbiAgICBjb25zdCB7IGJ1ZmZlcjogZSwgb3V0cHV0TGVuOiByIH0gPSB0aGlzO1xuICAgIHRoaXMuZGlnZXN0SW50byhlKTtcbiAgICBjb25zdCBuID0gZS5zbGljZSgwLCByKTtcbiAgICByZXR1cm4gdGhpcy5kZXN0cm95KCksIG47XG4gIH1cbiAgX2Nsb25lSW50byhlKSB7XG4gICAgZSB8fCAoZSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkpLCBlLnNldCguLi50aGlzLmdldCgpKTtcbiAgICBjb25zdCB7IGJsb2NrTGVuOiByLCBidWZmZXI6IG4sIGxlbmd0aDogaSwgZmluaXNoZWQ6IHMsIGRlc3Ryb3llZDogbywgcG9zOiBhIH0gPSB0aGlzO1xuICAgIHJldHVybiBlLmxlbmd0aCA9IGksIGUucG9zID0gYSwgZS5maW5pc2hlZCA9IHMsIGUuZGVzdHJveWVkID0gbywgaSAlIHIgJiYgZS5idWZmZXIuc2V0KG4pLCBlO1xuICB9XG59XG5jb25zdCBJdSA9ICh0LCBlLCByKSA9PiB0ICYgZSBeIH50ICYgciwgUnUgPSAodCwgZSwgcikgPT4gdCAmIGUgXiB0ICYgciBeIGUgJiByLCBUdSA9IG5ldyBVaW50MzJBcnJheShbXG4gIDExMTYzNTI0MDgsXG4gIDE4OTk0NDc0NDEsXG4gIDMwNDkzMjM0NzEsXG4gIDM5MjEwMDk1NzMsXG4gIDk2MTk4NzE2MyxcbiAgMTUwODk3MDk5MyxcbiAgMjQ1MzYzNTc0OCxcbiAgMjg3MDc2MzIyMSxcbiAgMzYyNDM4MTA4MCxcbiAgMzEwNTk4NDAxLFxuICA2MDcyMjUyNzgsXG4gIDE0MjY4ODE5ODcsXG4gIDE5MjUwNzgzODgsXG4gIDIxNjIwNzgyMDYsXG4gIDI2MTQ4ODgxMDMsXG4gIDMyNDgyMjI1ODAsXG4gIDM4MzUzOTA0MDEsXG4gIDQwMjIyMjQ3NzQsXG4gIDI2NDM0NzA3OCxcbiAgNjA0ODA3NjI4LFxuICA3NzAyNTU5ODMsXG4gIDEyNDkxNTAxMjIsXG4gIDE1NTUwODE2OTIsXG4gIDE5OTYwNjQ5ODYsXG4gIDI1NTQyMjA4ODIsXG4gIDI4MjE4MzQzNDksXG4gIDI5NTI5OTY4MDgsXG4gIDMyMTAzMTM2NzEsXG4gIDMzMzY1NzE4OTEsXG4gIDM1ODQ1Mjg3MTEsXG4gIDExMzkyNjk5MyxcbiAgMzM4MjQxODk1LFxuICA2NjYzMDcyMDUsXG4gIDc3MzUyOTkxMixcbiAgMTI5NDc1NzM3MixcbiAgMTM5NjE4MjI5MSxcbiAgMTY5NTE4MzcwMCxcbiAgMTk4NjY2MTA1MSxcbiAgMjE3NzAyNjM1MCxcbiAgMjQ1Njk1NjAzNyxcbiAgMjczMDQ4NTkyMSxcbiAgMjgyMDMwMjQxMSxcbiAgMzI1OTczMDgwMCxcbiAgMzM0NTc2NDc3MSxcbiAgMzUxNjA2NTgxNyxcbiAgMzYwMDM1MjgwNCxcbiAgNDA5NDU3MTkwOSxcbiAgMjc1NDIzMzQ0LFxuICA0MzAyMjc3MzQsXG4gIDUwNjk0ODYxNixcbiAgNjU5MDYwNTU2LFxuICA4ODM5OTc4NzcsXG4gIDk1ODEzOTU3MSxcbiAgMTMyMjgyMjIxOCxcbiAgMTUzNzAwMjA2MyxcbiAgMTc0Nzg3Mzc3OSxcbiAgMTk1NTU2MjIyMixcbiAgMjAyNDEwNDgxNSxcbiAgMjIyNzczMDQ1MixcbiAgMjM2MTg1MjQyNCxcbiAgMjQyODQzNjQ3NCxcbiAgMjc1NjczNDE4NyxcbiAgMzIwNDAzMTQ3OSxcbiAgMzMyOTMyNTI5OFxuXSksIHplID0gbmV3IFVpbnQzMkFycmF5KFtcbiAgMTc3OTAzMzcwMyxcbiAgMzE0NDEzNDI3NyxcbiAgMTAxMzkwNDI0MixcbiAgMjc3MzQ4MDc2MixcbiAgMTM1OTg5MzExOSxcbiAgMjYwMDgyMjkyNCxcbiAgNTI4NzM0NjM1LFxuICAxNTQxNDU5MjI1XG5dKSwgRmUgPSBuZXcgVWludDMyQXJyYXkoNjQpO1xuY2xhc3MgdnMgZXh0ZW5kcyBDdSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKDY0LCAzMiwgOCwgITEpLCB0aGlzLkEgPSB6ZVswXSB8IDAsIHRoaXMuQiA9IHplWzFdIHwgMCwgdGhpcy5DID0gemVbMl0gfCAwLCB0aGlzLkQgPSB6ZVszXSB8IDAsIHRoaXMuRSA9IHplWzRdIHwgMCwgdGhpcy5GID0gemVbNV0gfCAwLCB0aGlzLkcgPSB6ZVs2XSB8IDAsIHRoaXMuSCA9IHplWzddIHwgMDtcbiAgfVxuICBnZXQoKSB7XG4gICAgY29uc3QgeyBBOiBlLCBCOiByLCBDOiBuLCBEOiBpLCBFOiBzLCBGOiBvLCBHOiBhLCBIOiBjIH0gPSB0aGlzO1xuICAgIHJldHVybiBbZSwgciwgbiwgaSwgcywgbywgYSwgY107XG4gIH1cbiAgc2V0KGUsIHIsIG4sIGksIHMsIG8sIGEsIGMpIHtcbiAgICB0aGlzLkEgPSBlIHwgMCwgdGhpcy5CID0gciB8IDAsIHRoaXMuQyA9IG4gfCAwLCB0aGlzLkQgPSBpIHwgMCwgdGhpcy5FID0gcyB8IDAsIHRoaXMuRiA9IG8gfCAwLCB0aGlzLkcgPSBhIHwgMCwgdGhpcy5IID0gYyB8IDA7XG4gIH1cbiAgcHJvY2VzcyhlLCByKSB7XG4gICAgZm9yIChsZXQgdSA9IDA7IHUgPCAxNjsgdSsrLCByICs9IDQpXG4gICAgICBGZVt1XSA9IGUuZ2V0VWludDMyKHIsICExKTtcbiAgICBmb3IgKGxldCB1ID0gMTY7IHUgPCA2NDsgdSsrKSB7XG4gICAgICBjb25zdCBoID0gRmVbdSAtIDE1XSwgZCA9IEZlW3UgLSAyXSwgcCA9IENlKGgsIDcpIF4gQ2UoaCwgMTgpIF4gaCA+Pj4gMywgeSA9IENlKGQsIDE3KSBeIENlKGQsIDE5KSBeIGQgPj4+IDEwO1xuICAgICAgRmVbdV0gPSB5ICsgRmVbdSAtIDddICsgcCArIEZlW3UgLSAxNl0gfCAwO1xuICAgIH1cbiAgICBsZXQgeyBBOiBuLCBCOiBpLCBDOiBzLCBEOiBvLCBFOiBhLCBGOiBjLCBHOiBsLCBIOiBmIH0gPSB0aGlzO1xuICAgIGZvciAobGV0IHUgPSAwOyB1IDwgNjQ7IHUrKykge1xuICAgICAgY29uc3QgaCA9IENlKGEsIDYpIF4gQ2UoYSwgMTEpIF4gQ2UoYSwgMjUpLCBkID0gZiArIGggKyBJdShhLCBjLCBsKSArIFR1W3VdICsgRmVbdV0gfCAwLCB5ID0gKENlKG4sIDIpIF4gQ2UobiwgMTMpIF4gQ2UobiwgMjIpKSArIFJ1KG4sIGksIHMpIHwgMDtcbiAgICAgIGYgPSBsLCBsID0gYywgYyA9IGEsIGEgPSBvICsgZCB8IDAsIG8gPSBzLCBzID0gaSwgaSA9IG4sIG4gPSBkICsgeSB8IDA7XG4gICAgfVxuICAgIG4gPSBuICsgdGhpcy5BIHwgMCwgaSA9IGkgKyB0aGlzLkIgfCAwLCBzID0gcyArIHRoaXMuQyB8IDAsIG8gPSBvICsgdGhpcy5EIHwgMCwgYSA9IGEgKyB0aGlzLkUgfCAwLCBjID0gYyArIHRoaXMuRiB8IDAsIGwgPSBsICsgdGhpcy5HIHwgMCwgZiA9IGYgKyB0aGlzLkggfCAwLCB0aGlzLnNldChuLCBpLCBzLCBvLCBhLCBjLCBsLCBmKTtcbiAgfVxuICByb3VuZENsZWFuKCkge1xuICAgIEZlLmZpbGwoMCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKSwgdGhpcy5idWZmZXIuZmlsbCgwKTtcbiAgfVxufVxuY2xhc3MgUHUgZXh0ZW5kcyB2cyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCksIHRoaXMuQSA9IC0xMDU2NTk2MjY0LCB0aGlzLkIgPSA5MTQxNTA2NjMsIHRoaXMuQyA9IDgxMjcwMjk5OSwgdGhpcy5EID0gLTE1MDA1NDU5OSwgdGhpcy5FID0gLTQxOTE0MzksIHRoaXMuRiA9IDE3NTA2MDMwMjUsIHRoaXMuRyA9IDE2OTQwNzY4MzksIHRoaXMuSCA9IC0xMDkwODkxODY4LCB0aGlzLm91dHB1dExlbiA9IDI4O1xuICB9XG59XG5jb25zdCBZbiA9IGdzKCgpID0+IG5ldyB2cygpKTtcbmdzKCgpID0+IG5ldyBQdSgpKTtcbi8qISBzY3VyZS1iYXNlIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5mdW5jdGlvbiBydCh0KSB7XG4gIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIodCkpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBXcm9uZyBpbnRlZ2VyOiAke3R9YCk7XG59XG5mdW5jdGlvbiBTZSguLi50KSB7XG4gIGNvbnN0IGUgPSAoaSwgcykgPT4gKG8pID0+IGkocyhvKSksIHIgPSBBcnJheS5mcm9tKHQpLnJldmVyc2UoKS5yZWR1Y2UoKGksIHMpID0+IGkgPyBlKGksIHMuZW5jb2RlKSA6IHMuZW5jb2RlLCB2b2lkIDApLCBuID0gdC5yZWR1Y2UoKGksIHMpID0+IGkgPyBlKGksIHMuZGVjb2RlKSA6IHMuZGVjb2RlLCB2b2lkIDApO1xuICByZXR1cm4geyBlbmNvZGU6IHIsIGRlY29kZTogbiB9O1xufVxuZnVuY3Rpb24gUmUodCkge1xuICByZXR1cm4ge1xuICAgIGVuY29kZTogKGUpID0+IHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShlKSB8fCBlLmxlbmd0aCAmJiB0eXBlb2YgZVswXSAhPSBcIm51bWJlclwiKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhbHBoYWJldC5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIGFuIGFycmF5IG9mIG51bWJlcnNcIik7XG4gICAgICByZXR1cm4gZS5tYXAoKHIpID0+IHtcbiAgICAgICAgaWYgKHJ0KHIpLCByIDwgMCB8fCByID49IHQubGVuZ3RoKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRGlnaXQgaW5kZXggb3V0c2lkZSBhbHBoYWJldDogJHtyfSAoYWxwaGFiZXQ6ICR7dC5sZW5ndGh9KWApO1xuICAgICAgICByZXR1cm4gdFtyXTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZGVjb2RlOiAoZSkgPT4ge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGUpIHx8IGUubGVuZ3RoICYmIHR5cGVvZiBlWzBdICE9IFwic3RyaW5nXCIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImFscGhhYmV0LmRlY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2Ygc3RyaW5nc1wiKTtcbiAgICAgIHJldHVybiBlLm1hcCgocikgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHIgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGFscGhhYmV0LmRlY29kZTogbm90IHN0cmluZyBlbGVtZW50PSR7cn1gKTtcbiAgICAgICAgY29uc3QgbiA9IHQuaW5kZXhPZihyKTtcbiAgICAgICAgaWYgKG4gPT09IC0xKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBsZXR0ZXI6IFwiJHtyfVwiLiBBbGxvd2VkOiAke3R9YCk7XG4gICAgICAgIHJldHVybiBuO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gVGUodCA9IFwiXCIpIHtcbiAgaWYgKHR5cGVvZiB0ICE9IFwic3RyaW5nXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiam9pbiBzZXBhcmF0b3Igc2hvdWxkIGJlIHN0cmluZ1wiKTtcbiAgcmV0dXJuIHtcbiAgICBlbmNvZGU6IChlKSA9PiB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZSkgfHwgZS5sZW5ndGggJiYgdHlwZW9mIGVbMF0gIT0gXCJzdHJpbmdcIilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiam9pbi5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIGFycmF5IG9mIHN0cmluZ3NcIik7XG4gICAgICBmb3IgKGxldCByIG9mIGUpXG4gICAgICAgIGlmICh0eXBlb2YgciAhPSBcInN0cmluZ1wiKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgam9pbi5lbmNvZGU6IG5vbi1zdHJpbmcgaW5wdXQ9JHtyfWApO1xuICAgICAgcmV0dXJuIGUuam9pbih0KTtcbiAgICB9LFxuICAgIGRlY29kZTogKGUpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgZSAhPSBcInN0cmluZ1wiKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJqb2luLmRlY29kZSBpbnB1dCBzaG91bGQgYmUgc3RyaW5nXCIpO1xuICAgICAgcmV0dXJuIGUuc3BsaXQodCk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gc3IodCwgZSA9IFwiPVwiKSB7XG4gIGlmIChydCh0KSwgdHlwZW9mIGUgIT0gXCJzdHJpbmdcIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJwYWRkaW5nIGNociBzaG91bGQgYmUgc3RyaW5nXCIpO1xuICByZXR1cm4ge1xuICAgIGVuY29kZShyKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocikgfHwgci5sZW5ndGggJiYgdHlwZW9mIHJbMF0gIT0gXCJzdHJpbmdcIilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicGFkZGluZy5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIGFycmF5IG9mIHN0cmluZ3NcIik7XG4gICAgICBmb3IgKGxldCBuIG9mIHIpXG4gICAgICAgIGlmICh0eXBlb2YgbiAhPSBcInN0cmluZ1wiKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcGFkZGluZy5lbmNvZGU6IG5vbi1zdHJpbmcgaW5wdXQ9JHtufWApO1xuICAgICAgZm9yICg7IHIubGVuZ3RoICogdCAlIDg7IClcbiAgICAgICAgci5wdXNoKGUpO1xuICAgICAgcmV0dXJuIHI7XG4gICAgfSxcbiAgICBkZWNvZGUocikge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHIpIHx8IHIubGVuZ3RoICYmIHR5cGVvZiByWzBdICE9IFwic3RyaW5nXCIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInBhZGRpbmcuZW5jb2RlIGlucHV0IHNob3VsZCBiZSBhcnJheSBvZiBzdHJpbmdzXCIpO1xuICAgICAgZm9yIChsZXQgaSBvZiByKVxuICAgICAgICBpZiAodHlwZW9mIGkgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHBhZGRpbmcuZGVjb2RlOiBub24tc3RyaW5nIGlucHV0PSR7aX1gKTtcbiAgICAgIGxldCBuID0gci5sZW5ndGg7XG4gICAgICBpZiAobiAqIHQgJSA4KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHBhZGRpbmc6IHN0cmluZyBzaG91bGQgaGF2ZSB3aG9sZSBudW1iZXIgb2YgYnl0ZXNcIik7XG4gICAgICBmb3IgKDsgbiA+IDAgJiYgcltuIC0gMV0gPT09IGU7IG4tLSlcbiAgICAgICAgaWYgKCEoKG4gLSAxKSAqIHQgJSA4KSlcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHBhZGRpbmc6IHN0cmluZyBoYXMgdG9vIG11Y2ggcGFkZGluZ1wiKTtcbiAgICAgIHJldHVybiByLnNsaWNlKDAsIG4pO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHdzKHQpIHtcbiAgaWYgKHR5cGVvZiB0ICE9IFwiZnVuY3Rpb25cIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3JtYWxpemUgZm4gc2hvdWxkIGJlIGZ1bmN0aW9uXCIpO1xuICByZXR1cm4geyBlbmNvZGU6IChlKSA9PiBlLCBkZWNvZGU6IChlKSA9PiB0KGUpIH07XG59XG5mdW5jdGlvbiBGaSh0LCBlLCByKSB7XG4gIGlmIChlIDwgMilcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDogd3JvbmcgZnJvbT0ke2V9LCBiYXNlIGNhbm5vdCBiZSBsZXNzIHRoYW4gMmApO1xuICBpZiAociA8IDIpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXg6IHdyb25nIHRvPSR7cn0sIGJhc2UgY2Fubm90IGJlIGxlc3MgdGhhbiAyYCk7XG4gIGlmICghQXJyYXkuaXNBcnJheSh0KSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb252ZXJ0UmFkaXg6IGRhdGEgc2hvdWxkIGJlIGFycmF5XCIpO1xuICBpZiAoIXQubGVuZ3RoKVxuICAgIHJldHVybiBbXTtcbiAgbGV0IG4gPSAwO1xuICBjb25zdCBpID0gW10sIHMgPSBBcnJheS5mcm9tKHQpO1xuICBmb3IgKHMuZm9yRWFjaCgobykgPT4ge1xuICAgIGlmIChydChvKSwgbyA8IDAgfHwgbyA+PSBlKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBXcm9uZyBpbnRlZ2VyOiAke299YCk7XG4gIH0pOyA7ICkge1xuICAgIGxldCBvID0gMCwgYSA9ICEwO1xuICAgIGZvciAobGV0IGMgPSBuOyBjIDwgcy5sZW5ndGg7IGMrKykge1xuICAgICAgY29uc3QgbCA9IHNbY10sIGYgPSBlICogbyArIGw7XG4gICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGYpIHx8IGUgKiBvIC8gZSAhPT0gbyB8fCBmIC0gbCAhPT0gZSAqIG8pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNvbnZlcnRSYWRpeDogY2Fycnkgb3ZlcmZsb3dcIik7XG4gICAgICBpZiAobyA9IGYgJSByLCBzW2NdID0gTWF0aC5mbG9vcihmIC8gciksICFOdW1iZXIuaXNTYWZlSW50ZWdlcihzW2NdKSB8fCBzW2NdICogciArIG8gIT09IGYpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNvbnZlcnRSYWRpeDogY2Fycnkgb3ZlcmZsb3dcIik7XG4gICAgICBpZiAoYSlcbiAgICAgICAgc1tjXSA/IGEgPSAhMSA6IG4gPSBjO1xuICAgICAgZWxzZVxuICAgICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGkucHVzaChvKSwgYSlcbiAgICAgIGJyZWFrO1xuICB9XG4gIGZvciAobGV0IG8gPSAwOyBvIDwgdC5sZW5ndGggLSAxICYmIHRbb10gPT09IDA7IG8rKylcbiAgICBpLnB1c2goMCk7XG4gIHJldHVybiBpLnJldmVyc2UoKTtcbn1cbmNvbnN0IF9zID0gKHQsIGUpID0+IGUgPyBfcyhlLCB0ICUgZSkgOiB0LCBUciA9ICh0LCBlKSA9PiB0ICsgKGUgLSBfcyh0LCBlKSk7XG5mdW5jdGlvbiBCbih0LCBlLCByLCBuKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheSh0KSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb252ZXJ0UmFkaXgyOiBkYXRhIHNob3VsZCBiZSBhcnJheVwiKTtcbiAgaWYgKGUgPD0gMCB8fCBlID4gMzIpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXgyOiB3cm9uZyBmcm9tPSR7ZX1gKTtcbiAgaWYgKHIgPD0gMCB8fCByID4gMzIpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXgyOiB3cm9uZyB0bz0ke3J9YCk7XG4gIGlmIChUcihlLCByKSA+IDMyKVxuICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4MjogY2Fycnkgb3ZlcmZsb3cgZnJvbT0ke2V9IHRvPSR7cn0gY2FycnlCaXRzPSR7VHIoZSwgcil9YCk7XG4gIGxldCBpID0gMCwgcyA9IDA7XG4gIGNvbnN0IG8gPSAyICoqIHIgLSAxLCBhID0gW107XG4gIGZvciAoY29uc3QgYyBvZiB0KSB7XG4gICAgaWYgKHJ0KGMpLCBjID49IDIgKiogZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4MjogaW52YWxpZCBkYXRhIHdvcmQ9JHtjfSBmcm9tPSR7ZX1gKTtcbiAgICBpZiAoaSA9IGkgPDwgZSB8IGMsIHMgKyBlID4gMzIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDI6IGNhcnJ5IG92ZXJmbG93IHBvcz0ke3N9IGZyb209JHtlfWApO1xuICAgIGZvciAocyArPSBlOyBzID49IHI7IHMgLT0gcilcbiAgICAgIGEucHVzaCgoaSA+PiBzIC0gciAmIG8pID4+PiAwKTtcbiAgICBpICY9IDIgKiogcyAtIDE7XG4gIH1cbiAgaWYgKGkgPSBpIDw8IHIgLSBzICYgbywgIW4gJiYgcyA+PSBlKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkV4Y2VzcyBwYWRkaW5nXCIpO1xuICBpZiAoIW4gJiYgaSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE5vbi16ZXJvIHBhZGRpbmc6ICR7aX1gKTtcbiAgcmV0dXJuIG4gJiYgcyA+IDAgJiYgYS5wdXNoKGkgPj4+IDApLCBhO1xufVxuZnVuY3Rpb24gbXModCkge1xuICByZXR1cm4gcnQodCksIHtcbiAgICBlbmNvZGU6IChlKSA9PiB7XG4gICAgICBpZiAoIShlIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInJhZGl4LmVuY29kZSBpbnB1dCBzaG91bGQgYmUgVWludDhBcnJheVwiKTtcbiAgICAgIHJldHVybiBGaShBcnJheS5mcm9tKGUpLCAyICoqIDgsIHQpO1xuICAgIH0sXG4gICAgZGVjb2RlOiAoZSkgPT4ge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGUpIHx8IGUubGVuZ3RoICYmIHR5cGVvZiBlWzBdICE9IFwibnVtYmVyXCIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInJhZGl4LmRlY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2Ygc3RyaW5nc1wiKTtcbiAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oRmkoZSwgdCwgMiAqKiA4KSk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gTmUodCwgZSA9ICExKSB7XG4gIGlmIChydCh0KSwgdCA8PSAwIHx8IHQgPiAzMilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJyYWRpeDI6IGJpdHMgc2hvdWxkIGJlIGluICgwLi4zMl1cIik7XG4gIGlmIChUcig4LCB0KSA+IDMyIHx8IFRyKHQsIDgpID4gMzIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwicmFkaXgyOiBjYXJyeSBvdmVyZmxvd1wiKTtcbiAgcmV0dXJuIHtcbiAgICBlbmNvZGU6IChyKSA9PiB7XG4gICAgICBpZiAoIShyIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInJhZGl4Mi5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIFVpbnQ4QXJyYXlcIik7XG4gICAgICByZXR1cm4gQm4oQXJyYXkuZnJvbShyKSwgOCwgdCwgIWUpO1xuICAgIH0sXG4gICAgZGVjb2RlOiAocikgPT4ge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHIpIHx8IHIubGVuZ3RoICYmIHR5cGVvZiByWzBdICE9IFwibnVtYmVyXCIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInJhZGl4Mi5kZWNvZGUgaW5wdXQgc2hvdWxkIGJlIGFycmF5IG9mIHN0cmluZ3NcIik7XG4gICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKEJuKHIsIHQsIDgsIGUpKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBLaSh0KSB7XG4gIGlmICh0eXBlb2YgdCAhPSBcImZ1bmN0aW9uXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwidW5zYWZlV3JhcHBlciBmbiBzaG91bGQgYmUgZnVuY3Rpb25cIik7XG4gIHJldHVybiBmdW5jdGlvbiguLi5lKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0LmFwcGx5KG51bGwsIGUpO1xuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHhzKHQsIGUpIHtcbiAgaWYgKHJ0KHQpLCB0eXBlb2YgZSAhPSBcImZ1bmN0aW9uXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY2hlY2tzdW0gZm4gc2hvdWxkIGJlIGZ1bmN0aW9uXCIpO1xuICByZXR1cm4ge1xuICAgIGVuY29kZShyKSB7XG4gICAgICBpZiAoIShyIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNoZWNrc3VtLmVuY29kZTogaW5wdXQgc2hvdWxkIGJlIFVpbnQ4QXJyYXlcIik7XG4gICAgICBjb25zdCBuID0gZShyKS5zbGljZSgwLCB0KSwgaSA9IG5ldyBVaW50OEFycmF5KHIubGVuZ3RoICsgdCk7XG4gICAgICByZXR1cm4gaS5zZXQociksIGkuc2V0KG4sIHIubGVuZ3RoKSwgaTtcbiAgICB9LFxuICAgIGRlY29kZShyKSB7XG4gICAgICBpZiAoIShyIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNoZWNrc3VtLmRlY29kZTogaW5wdXQgc2hvdWxkIGJlIFVpbnQ4QXJyYXlcIik7XG4gICAgICBjb25zdCBuID0gci5zbGljZSgwLCAtdCksIGkgPSBlKG4pLnNsaWNlKDAsIHQpLCBzID0gci5zbGljZSgtdCk7XG4gICAgICBmb3IgKGxldCBvID0gMDsgbyA8IHQ7IG8rKylcbiAgICAgICAgaWYgKGlbb10gIT09IHNbb10pXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjaGVja3N1bVwiKTtcbiAgICAgIHJldHVybiBuO1xuICAgIH1cbiAgfTtcbn1cbmNvbnN0IEJ1ID0geyBhbHBoYWJldDogUmUsIGNoYWluOiBTZSwgY2hlY2tzdW06IHhzLCByYWRpeDogbXMsIHJhZGl4MjogTmUsIGpvaW46IFRlLCBwYWRkaW5nOiBzciB9LCBFcyA9IFNlKE5lKDQpLCBSZShcIjAxMjM0NTY3ODlBQkNERUZcIiksIFRlKFwiXCIpKSwga3MgPSBTZShOZSg1KSwgUmUoXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjIzNDU2N1wiKSwgc3IoNSksIFRlKFwiXCIpKSwgTHUgPSBTZShOZSg1KSwgUmUoXCIwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVlwiKSwgc3IoNSksIFRlKFwiXCIpKSwgJHUgPSBTZShOZSg1KSwgUmUoXCIwMTIzNDU2Nzg5QUJDREVGR0hKS01OUFFSU1RWV1hZWlwiKSwgVGUoXCJcIiksIHdzKCh0KSA9PiB0LnRvVXBwZXJDYXNlKCkucmVwbGFjZSgvTy9nLCBcIjBcIikucmVwbGFjZSgvW0lMXS9nLCBcIjFcIikpKSwgbXQgPSBTZShOZSg2KSwgUmUoXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCIpLCBzcig2KSwgVGUoXCJcIikpLCBTcyA9IFNlKE5lKDYpLCBSZShcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5LV9cIiksIHNyKDYpLCBUZShcIlwiKSksIEpuID0gKHQpID0+IFNlKG1zKDU4KSwgUmUodCksIFRlKFwiXCIpKSwgbnIgPSBKbihcIjEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXpcIiksIHF1ID0gSm4oXCIxMjM0NTY3ODlhYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaXCIpLCBOdSA9IEpuKFwicnBzaG5hZjM5d0JVRE5FR0hKS0xNNFBRUlNUN1ZXWFlaMmJjZGVDZzY1amttOG9GcWkxdHV2QXh5elwiKSwgV2kgPSBbMCwgMiwgMywgNSwgNiwgNywgOSwgMTAsIDExXSwgT3MgPSB7XG4gIGVuY29kZSh0KSB7XG4gICAgbGV0IGUgPSBcIlwiO1xuICAgIGZvciAobGV0IHIgPSAwOyByIDwgdC5sZW5ndGg7IHIgKz0gOCkge1xuICAgICAgY29uc3QgbiA9IHQuc3ViYXJyYXkociwgciArIDgpO1xuICAgICAgZSArPSBuci5lbmNvZGUobikucGFkU3RhcnQoV2lbbi5sZW5ndGhdLCBcIjFcIik7XG4gICAgfVxuICAgIHJldHVybiBlO1xuICB9LFxuICBkZWNvZGUodCkge1xuICAgIGxldCBlID0gW107XG4gICAgZm9yIChsZXQgciA9IDA7IHIgPCB0Lmxlbmd0aDsgciArPSAxMSkge1xuICAgICAgY29uc3QgbiA9IHQuc2xpY2UociwgciArIDExKSwgaSA9IFdpLmluZGV4T2Yobi5sZW5ndGgpLCBzID0gbnIuZGVjb2RlKG4pO1xuICAgICAgZm9yIChsZXQgbyA9IDA7IG8gPCBzLmxlbmd0aCAtIGk7IG8rKylcbiAgICAgICAgaWYgKHNbb10gIT09IDApXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmFzZTU4eG1yOiB3cm9uZyBwYWRkaW5nXCIpO1xuICAgICAgZSA9IGUuY29uY2F0KEFycmF5LmZyb20ocy5zbGljZShzLmxlbmd0aCAtIGkpKSk7XG4gICAgfVxuICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oZSk7XG4gIH1cbn0sIEFzID0gKHQpID0+IFNlKHhzKDQsIChlKSA9PiB0KHQoZSkpKSwgbnIpLCBMbiA9IFNlKFJlKFwicXB6cnk5eDhnZjJ0dmR3MHMzam41NGtoY2U2bXVhN2xcIiksIFRlKFwiXCIpKSwgVmkgPSBbOTk2ODI1MDEwLCA2NDI4MTM1NDksIDUxMzg3NDQyNiwgMTAyNzc0ODgyOSwgNzA1OTc5MDU5XTtcbmZ1bmN0aW9uIEl0KHQpIHtcbiAgY29uc3QgZSA9IHQgPj4gMjU7XG4gIGxldCByID0gKHQgJiAzMzU1NDQzMSkgPDwgNTtcbiAgZm9yIChsZXQgbiA9IDA7IG4gPCBWaS5sZW5ndGg7IG4rKylcbiAgICAoZSA+PiBuICYgMSkgPT09IDEgJiYgKHIgXj0gVmlbbl0pO1xuICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIEdpKHQsIGUsIHIgPSAxKSB7XG4gIGNvbnN0IG4gPSB0Lmxlbmd0aDtcbiAgbGV0IGkgPSAxO1xuICBmb3IgKGxldCBzID0gMDsgcyA8IG47IHMrKykge1xuICAgIGNvbnN0IG8gPSB0LmNoYXJDb2RlQXQocyk7XG4gICAgaWYgKG8gPCAzMyB8fCBvID4gMTI2KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHByZWZpeCAoJHt0fSlgKTtcbiAgICBpID0gSXQoaSkgXiBvID4+IDU7XG4gIH1cbiAgaSA9IEl0KGkpO1xuICBmb3IgKGxldCBzID0gMDsgcyA8IG47IHMrKylcbiAgICBpID0gSXQoaSkgXiB0LmNoYXJDb2RlQXQocykgJiAzMTtcbiAgZm9yIChsZXQgcyBvZiBlKVxuICAgIGkgPSBJdChpKSBeIHM7XG4gIGZvciAobGV0IHMgPSAwOyBzIDwgNjsgcysrKVxuICAgIGkgPSBJdChpKTtcbiAgcmV0dXJuIGkgXj0gciwgTG4uZW5jb2RlKEJuKFtpICUgMiAqKiAzMF0sIDMwLCA1LCAhMSkpO1xufVxuZnVuY3Rpb24gQ3ModCkge1xuICBjb25zdCBlID0gdCA9PT0gXCJiZWNoMzJcIiA/IDEgOiA3MzQ1Mzk5MzksIHIgPSBOZSg1KSwgbiA9IHIuZGVjb2RlLCBpID0gci5lbmNvZGUsIHMgPSBLaShuKTtcbiAgZnVuY3Rpb24gbyhmLCB1LCBoID0gOTApIHtcbiAgICBpZiAodHlwZW9mIGYgIT0gXCJzdHJpbmdcIilcbiAgICAgIHRocm93IG5ldyBFcnJvcihgYmVjaDMyLmVuY29kZSBwcmVmaXggc2hvdWxkIGJlIHN0cmluZywgbm90ICR7dHlwZW9mIGZ9YCk7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHUpIHx8IHUubGVuZ3RoICYmIHR5cGVvZiB1WzBdICE9IFwibnVtYmVyXCIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGJlY2gzMi5lbmNvZGUgd29yZHMgc2hvdWxkIGJlIGFycmF5IG9mIG51bWJlcnMsIG5vdCAke3R5cGVvZiB1fWApO1xuICAgIGNvbnN0IGQgPSBmLmxlbmd0aCArIDcgKyB1Lmxlbmd0aDtcbiAgICBpZiAoaCAhPT0gITEgJiYgZCA+IGgpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBMZW5ndGggJHtkfSBleGNlZWRzIGxpbWl0ICR7aH1gKTtcbiAgICByZXR1cm4gZiA9IGYudG9Mb3dlckNhc2UoKSwgYCR7Zn0xJHtMbi5lbmNvZGUodSl9JHtHaShmLCB1LCBlKX1gO1xuICB9XG4gIGZ1bmN0aW9uIGEoZiwgdSA9IDkwKSB7XG4gICAgaWYgKHR5cGVvZiBmICE9IFwic3RyaW5nXCIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGJlY2gzMi5kZWNvZGUgaW5wdXQgc2hvdWxkIGJlIHN0cmluZywgbm90ICR7dHlwZW9mIGZ9YCk7XG4gICAgaWYgKGYubGVuZ3RoIDwgOCB8fCB1ICE9PSAhMSAmJiBmLmxlbmd0aCA+IHUpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBXcm9uZyBzdHJpbmcgbGVuZ3RoOiAke2YubGVuZ3RofSAoJHtmfSkuIEV4cGVjdGVkICg4Li4ke3V9KWApO1xuICAgIGNvbnN0IGggPSBmLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGYgIT09IGggJiYgZiAhPT0gZi50b1VwcGVyQ2FzZSgpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RyaW5nIG11c3QgYmUgbG93ZXJjYXNlIG9yIHVwcGVyY2FzZVwiKTtcbiAgICBmID0gaDtcbiAgICBjb25zdCBkID0gZi5sYXN0SW5kZXhPZihcIjFcIik7XG4gICAgaWYgKGQgPT09IDAgfHwgZCA9PT0gLTEpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xldHRlciBcIjFcIiBtdXN0IGJlIHByZXNlbnQgYmV0d2VlbiBwcmVmaXggYW5kIGRhdGEgb25seScpO1xuICAgIGNvbnN0IHAgPSBmLnNsaWNlKDAsIGQpLCB5ID0gZi5zbGljZShkICsgMSk7XG4gICAgaWYgKHkubGVuZ3RoIDwgNilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGEgbXVzdCBiZSBhdCBsZWFzdCA2IGNoYXJhY3RlcnMgbG9uZ1wiKTtcbiAgICBjb25zdCBnID0gTG4uZGVjb2RlKHkpLnNsaWNlKDAsIC02KSwgdiA9IEdpKHAsIGcsIGUpO1xuICAgIGlmICgheS5lbmRzV2l0aCh2KSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjaGVja3N1bSBpbiAke2Z9OiBleHBlY3RlZCBcIiR7dn1cImApO1xuICAgIHJldHVybiB7IHByZWZpeDogcCwgd29yZHM6IGcgfTtcbiAgfVxuICBjb25zdCBjID0gS2koYSk7XG4gIGZ1bmN0aW9uIGwoZikge1xuICAgIGNvbnN0IHsgcHJlZml4OiB1LCB3b3JkczogaCB9ID0gYShmLCAhMSk7XG4gICAgcmV0dXJuIHsgcHJlZml4OiB1LCB3b3JkczogaCwgYnl0ZXM6IG4oaCkgfTtcbiAgfVxuICByZXR1cm4geyBlbmNvZGU6IG8sIGRlY29kZTogYSwgZGVjb2RlVG9CeXRlczogbCwgZGVjb2RlVW5zYWZlOiBjLCBmcm9tV29yZHM6IG4sIGZyb21Xb3Jkc1Vuc2FmZTogcywgdG9Xb3JkczogaSB9O1xufVxuY29uc3QgdGUgPSBDcyhcImJlY2gzMlwiKSwgVXUgPSBDcyhcImJlY2gzMm1cIiksIElzID0ge1xuICBlbmNvZGU6ICh0KSA9PiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUodCksXG4gIGRlY29kZTogKHQpID0+IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh0KVxufSwgUnMgPSBTZShOZSg0KSwgUmUoXCIwMTIzNDU2Nzg5YWJjZGVmXCIpLCBUZShcIlwiKSwgd3MoKHQpID0+IHtcbiAgaWYgKHR5cGVvZiB0ICE9IFwic3RyaW5nXCIgfHwgdC5sZW5ndGggJSAyKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGhleC5kZWNvZGU6IGV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIHR9IHdpdGggbGVuZ3RoICR7dC5sZW5ndGh9YCk7XG4gIHJldHVybiB0LnRvTG93ZXJDYXNlKCk7XG59KSksIGlyID0ge1xuICB1dGY4OiBJcyxcbiAgaGV4OiBScyxcbiAgYmFzZTE2OiBFcyxcbiAgYmFzZTMyOiBrcyxcbiAgYmFzZTY0OiBtdCxcbiAgYmFzZTY0dXJsOiBTcyxcbiAgYmFzZTU4OiBucixcbiAgYmFzZTU4eG1yOiBPc1xufSwgVHMgPSBgSW52YWxpZCBlbmNvZGluZyB0eXBlLiBBdmFpbGFibGUgdHlwZXM6ICR7T2JqZWN0LmtleXMoaXIpLmpvaW4oXCIsIFwiKX1gLCBQcyA9ICh0LCBlKSA9PiB7XG4gIGlmICh0eXBlb2YgdCAhPSBcInN0cmluZ1wiIHx8ICFpci5oYXNPd25Qcm9wZXJ0eSh0KSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFRzKTtcbiAgaWYgKCEoZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJieXRlc1RvU3RyaW5nKCkgZXhwZWN0cyBVaW50OEFycmF5XCIpO1xuICByZXR1cm4gaXJbdF0uZW5jb2RlKGUpO1xufSwganUgPSBQcywgQnMgPSAodCwgZSkgPT4ge1xuICBpZiAoIWlyLmhhc093blByb3BlcnR5KHQpKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoVHMpO1xuICBpZiAodHlwZW9mIGUgIT0gXCJzdHJpbmdcIilcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwic3RyaW5nVG9CeXRlcygpIGV4cGVjdHMgc3RyaW5nXCIpO1xuICByZXR1cm4gaXJbdF0uZGVjb2RlKGUpO1xufSwgSHUgPSBCcywgTXUgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgX19wcm90b19fOiBudWxsLFxuICBhc3NlcnROdW1iZXI6IHJ0LFxuICB1dGlsczogQnUsXG4gIGJhc2UxNjogRXMsXG4gIGJhc2UzMjoga3MsXG4gIGJhc2UzMmhleDogTHUsXG4gIGJhc2UzMmNyb2NrZm9yZDogJHUsXG4gIGJhc2U2NDogbXQsXG4gIGJhc2U2NHVybDogU3MsXG4gIGJhc2U1ODogbnIsXG4gIGJhc2U1OGZsaWNrcjogcXUsXG4gIGJhc2U1OHhycDogTnUsXG4gIGJhc2U1OHhtcjogT3MsXG4gIGJhc2U1OGNoZWNrOiBBcyxcbiAgYmVjaDMyOiB0ZSxcbiAgYmVjaDMybTogVXUsXG4gIHV0Zjg6IElzLFxuICBoZXg6IFJzLFxuICBieXRlc1RvU3RyaW5nOiBQcyxcbiAgc3RyOiBqdSxcbiAgc3RyaW5nVG9CeXRlczogQnMsXG4gIGJ5dGVzOiBIdVxufSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pKTtcbnZhciBYbiA9IHt9O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFhuLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG52YXIgUW4gPSBYbi53b3JkbGlzdCA9IHZvaWQgMDtcblFuID0gWG4ud29yZGxpc3QgPSBgYWJhbmRvblxuYWJpbGl0eVxuYWJsZVxuYWJvdXRcbmFib3ZlXG5hYnNlbnRcbmFic29yYlxuYWJzdHJhY3RcbmFic3VyZFxuYWJ1c2VcbmFjY2Vzc1xuYWNjaWRlbnRcbmFjY291bnRcbmFjY3VzZVxuYWNoaWV2ZVxuYWNpZFxuYWNvdXN0aWNcbmFjcXVpcmVcbmFjcm9zc1xuYWN0XG5hY3Rpb25cbmFjdG9yXG5hY3RyZXNzXG5hY3R1YWxcbmFkYXB0XG5hZGRcbmFkZGljdFxuYWRkcmVzc1xuYWRqdXN0XG5hZG1pdFxuYWR1bHRcbmFkdmFuY2VcbmFkdmljZVxuYWVyb2JpY1xuYWZmYWlyXG5hZmZvcmRcbmFmcmFpZFxuYWdhaW5cbmFnZVxuYWdlbnRcbmFncmVlXG5haGVhZFxuYWltXG5haXJcbmFpcnBvcnRcbmFpc2xlXG5hbGFybVxuYWxidW1cbmFsY29ob2xcbmFsZXJ0XG5hbGllblxuYWxsXG5hbGxleVxuYWxsb3dcbmFsbW9zdFxuYWxvbmVcbmFscGhhXG5hbHJlYWR5XG5hbHNvXG5hbHRlclxuYWx3YXlzXG5hbWF0ZXVyXG5hbWF6aW5nXG5hbW9uZ1xuYW1vdW50XG5hbXVzZWRcbmFuYWx5c3RcbmFuY2hvclxuYW5jaWVudFxuYW5nZXJcbmFuZ2xlXG5hbmdyeVxuYW5pbWFsXG5hbmtsZVxuYW5ub3VuY2VcbmFubnVhbFxuYW5vdGhlclxuYW5zd2VyXG5hbnRlbm5hXG5hbnRpcXVlXG5hbnhpZXR5XG5hbnlcbmFwYXJ0XG5hcG9sb2d5XG5hcHBlYXJcbmFwcGxlXG5hcHByb3ZlXG5hcHJpbFxuYXJjaFxuYXJjdGljXG5hcmVhXG5hcmVuYVxuYXJndWVcbmFybVxuYXJtZWRcbmFybW9yXG5hcm15XG5hcm91bmRcbmFycmFuZ2VcbmFycmVzdFxuYXJyaXZlXG5hcnJvd1xuYXJ0XG5hcnRlZmFjdFxuYXJ0aXN0XG5hcnR3b3JrXG5hc2tcbmFzcGVjdFxuYXNzYXVsdFxuYXNzZXRcbmFzc2lzdFxuYXNzdW1lXG5hc3RobWFcbmF0aGxldGVcbmF0b21cbmF0dGFja1xuYXR0ZW5kXG5hdHRpdHVkZVxuYXR0cmFjdFxuYXVjdGlvblxuYXVkaXRcbmF1Z3VzdFxuYXVudFxuYXV0aG9yXG5hdXRvXG5hdXR1bW5cbmF2ZXJhZ2VcbmF2b2NhZG9cbmF2b2lkXG5hd2FrZVxuYXdhcmVcbmF3YXlcbmF3ZXNvbWVcbmF3ZnVsXG5hd2t3YXJkXG5heGlzXG5iYWJ5XG5iYWNoZWxvclxuYmFjb25cbmJhZGdlXG5iYWdcbmJhbGFuY2VcbmJhbGNvbnlcbmJhbGxcbmJhbWJvb1xuYmFuYW5hXG5iYW5uZXJcbmJhclxuYmFyZWx5XG5iYXJnYWluXG5iYXJyZWxcbmJhc2VcbmJhc2ljXG5iYXNrZXRcbmJhdHRsZVxuYmVhY2hcbmJlYW5cbmJlYXV0eVxuYmVjYXVzZVxuYmVjb21lXG5iZWVmXG5iZWZvcmVcbmJlZ2luXG5iZWhhdmVcbmJlaGluZFxuYmVsaWV2ZVxuYmVsb3dcbmJlbHRcbmJlbmNoXG5iZW5lZml0XG5iZXN0XG5iZXRyYXlcbmJldHRlclxuYmV0d2VlblxuYmV5b25kXG5iaWN5Y2xlXG5iaWRcbmJpa2VcbmJpbmRcbmJpb2xvZ3lcbmJpcmRcbmJpcnRoXG5iaXR0ZXJcbmJsYWNrXG5ibGFkZVxuYmxhbWVcbmJsYW5rZXRcbmJsYXN0XG5ibGVha1xuYmxlc3NcbmJsaW5kXG5ibG9vZFxuYmxvc3NvbVxuYmxvdXNlXG5ibHVlXG5ibHVyXG5ibHVzaFxuYm9hcmRcbmJvYXRcbmJvZHlcbmJvaWxcbmJvbWJcbmJvbmVcbmJvbnVzXG5ib29rXG5ib29zdFxuYm9yZGVyXG5ib3JpbmdcbmJvcnJvd1xuYm9zc1xuYm90dG9tXG5ib3VuY2VcbmJveFxuYm95XG5icmFja2V0XG5icmFpblxuYnJhbmRcbmJyYXNzXG5icmF2ZVxuYnJlYWRcbmJyZWV6ZVxuYnJpY2tcbmJyaWRnZVxuYnJpZWZcbmJyaWdodFxuYnJpbmdcbmJyaXNrXG5icm9jY29saVxuYnJva2VuXG5icm9uemVcbmJyb29tXG5icm90aGVyXG5icm93blxuYnJ1c2hcbmJ1YmJsZVxuYnVkZHlcbmJ1ZGdldFxuYnVmZmFsb1xuYnVpbGRcbmJ1bGJcbmJ1bGtcbmJ1bGxldFxuYnVuZGxlXG5idW5rZXJcbmJ1cmRlblxuYnVyZ2VyXG5idXJzdFxuYnVzXG5idXNpbmVzc1xuYnVzeVxuYnV0dGVyXG5idXllclxuYnV6elxuY2FiYmFnZVxuY2FiaW5cbmNhYmxlXG5jYWN0dXNcbmNhZ2VcbmNha2VcbmNhbGxcbmNhbG1cbmNhbWVyYVxuY2FtcFxuY2FuXG5jYW5hbFxuY2FuY2VsXG5jYW5keVxuY2Fubm9uXG5jYW5vZVxuY2FudmFzXG5jYW55b25cbmNhcGFibGVcbmNhcGl0YWxcbmNhcHRhaW5cbmNhclxuY2FyYm9uXG5jYXJkXG5jYXJnb1xuY2FycGV0XG5jYXJyeVxuY2FydFxuY2FzZVxuY2FzaFxuY2FzaW5vXG5jYXN0bGVcbmNhc3VhbFxuY2F0XG5jYXRhbG9nXG5jYXRjaFxuY2F0ZWdvcnlcbmNhdHRsZVxuY2F1Z2h0XG5jYXVzZVxuY2F1dGlvblxuY2F2ZVxuY2VpbGluZ1xuY2VsZXJ5XG5jZW1lbnRcbmNlbnN1c1xuY2VudHVyeVxuY2VyZWFsXG5jZXJ0YWluXG5jaGFpclxuY2hhbGtcbmNoYW1waW9uXG5jaGFuZ2VcbmNoYW9zXG5jaGFwdGVyXG5jaGFyZ2VcbmNoYXNlXG5jaGF0XG5jaGVhcFxuY2hlY2tcbmNoZWVzZVxuY2hlZlxuY2hlcnJ5XG5jaGVzdFxuY2hpY2tlblxuY2hpZWZcbmNoaWxkXG5jaGltbmV5XG5jaG9pY2VcbmNob29zZVxuY2hyb25pY1xuY2h1Y2tsZVxuY2h1bmtcbmNodXJuXG5jaWdhclxuY2lubmFtb25cbmNpcmNsZVxuY2l0aXplblxuY2l0eVxuY2l2aWxcbmNsYWltXG5jbGFwXG5jbGFyaWZ5XG5jbGF3XG5jbGF5XG5jbGVhblxuY2xlcmtcbmNsZXZlclxuY2xpY2tcbmNsaWVudFxuY2xpZmZcbmNsaW1iXG5jbGluaWNcbmNsaXBcbmNsb2NrXG5jbG9nXG5jbG9zZVxuY2xvdGhcbmNsb3VkXG5jbG93blxuY2x1YlxuY2x1bXBcbmNsdXN0ZXJcbmNsdXRjaFxuY29hY2hcbmNvYXN0XG5jb2NvbnV0XG5jb2RlXG5jb2ZmZWVcbmNvaWxcbmNvaW5cbmNvbGxlY3RcbmNvbG9yXG5jb2x1bW5cbmNvbWJpbmVcbmNvbWVcbmNvbWZvcnRcbmNvbWljXG5jb21tb25cbmNvbXBhbnlcbmNvbmNlcnRcbmNvbmR1Y3RcbmNvbmZpcm1cbmNvbmdyZXNzXG5jb25uZWN0XG5jb25zaWRlclxuY29udHJvbFxuY29udmluY2VcbmNvb2tcbmNvb2xcbmNvcHBlclxuY29weVxuY29yYWxcbmNvcmVcbmNvcm5cbmNvcnJlY3RcbmNvc3RcbmNvdHRvblxuY291Y2hcbmNvdW50cnlcbmNvdXBsZVxuY291cnNlXG5jb3VzaW5cbmNvdmVyXG5jb3lvdGVcbmNyYWNrXG5jcmFkbGVcbmNyYWZ0XG5jcmFtXG5jcmFuZVxuY3Jhc2hcbmNyYXRlclxuY3Jhd2xcbmNyYXp5XG5jcmVhbVxuY3JlZGl0XG5jcmVla1xuY3Jld1xuY3JpY2tldFxuY3JpbWVcbmNyaXNwXG5jcml0aWNcbmNyb3BcbmNyb3NzXG5jcm91Y2hcbmNyb3dkXG5jcnVjaWFsXG5jcnVlbFxuY3J1aXNlXG5jcnVtYmxlXG5jcnVuY2hcbmNydXNoXG5jcnlcbmNyeXN0YWxcbmN1YmVcbmN1bHR1cmVcbmN1cFxuY3VwYm9hcmRcbmN1cmlvdXNcbmN1cnJlbnRcbmN1cnRhaW5cbmN1cnZlXG5jdXNoaW9uXG5jdXN0b21cbmN1dGVcbmN5Y2xlXG5kYWRcbmRhbWFnZVxuZGFtcFxuZGFuY2VcbmRhbmdlclxuZGFyaW5nXG5kYXNoXG5kYXVnaHRlclxuZGF3blxuZGF5XG5kZWFsXG5kZWJhdGVcbmRlYnJpc1xuZGVjYWRlXG5kZWNlbWJlclxuZGVjaWRlXG5kZWNsaW5lXG5kZWNvcmF0ZVxuZGVjcmVhc2VcbmRlZXJcbmRlZmVuc2VcbmRlZmluZVxuZGVmeVxuZGVncmVlXG5kZWxheVxuZGVsaXZlclxuZGVtYW5kXG5kZW1pc2VcbmRlbmlhbFxuZGVudGlzdFxuZGVueVxuZGVwYXJ0XG5kZXBlbmRcbmRlcG9zaXRcbmRlcHRoXG5kZXB1dHlcbmRlcml2ZVxuZGVzY3JpYmVcbmRlc2VydFxuZGVzaWduXG5kZXNrXG5kZXNwYWlyXG5kZXN0cm95XG5kZXRhaWxcbmRldGVjdFxuZGV2ZWxvcFxuZGV2aWNlXG5kZXZvdGVcbmRpYWdyYW1cbmRpYWxcbmRpYW1vbmRcbmRpYXJ5XG5kaWNlXG5kaWVzZWxcbmRpZXRcbmRpZmZlclxuZGlnaXRhbFxuZGlnbml0eVxuZGlsZW1tYVxuZGlubmVyXG5kaW5vc2F1clxuZGlyZWN0XG5kaXJ0XG5kaXNhZ3JlZVxuZGlzY292ZXJcbmRpc2Vhc2VcbmRpc2hcbmRpc21pc3NcbmRpc29yZGVyXG5kaXNwbGF5XG5kaXN0YW5jZVxuZGl2ZXJ0XG5kaXZpZGVcbmRpdm9yY2VcbmRpenp5XG5kb2N0b3JcbmRvY3VtZW50XG5kb2dcbmRvbGxcbmRvbHBoaW5cbmRvbWFpblxuZG9uYXRlXG5kb25rZXlcbmRvbm9yXG5kb29yXG5kb3NlXG5kb3VibGVcbmRvdmVcbmRyYWZ0XG5kcmFnb25cbmRyYW1hXG5kcmFzdGljXG5kcmF3XG5kcmVhbVxuZHJlc3NcbmRyaWZ0XG5kcmlsbFxuZHJpbmtcbmRyaXBcbmRyaXZlXG5kcm9wXG5kcnVtXG5kcnlcbmR1Y2tcbmR1bWJcbmR1bmVcbmR1cmluZ1xuZHVzdFxuZHV0Y2hcbmR1dHlcbmR3YXJmXG5keW5hbWljXG5lYWdlclxuZWFnbGVcbmVhcmx5XG5lYXJuXG5lYXJ0aFxuZWFzaWx5XG5lYXN0XG5lYXN5XG5lY2hvXG5lY29sb2d5XG5lY29ub215XG5lZGdlXG5lZGl0XG5lZHVjYXRlXG5lZmZvcnRcbmVnZ1xuZWlnaHRcbmVpdGhlclxuZWxib3dcbmVsZGVyXG5lbGVjdHJpY1xuZWxlZ2FudFxuZWxlbWVudFxuZWxlcGhhbnRcbmVsZXZhdG9yXG5lbGl0ZVxuZWxzZVxuZW1iYXJrXG5lbWJvZHlcbmVtYnJhY2VcbmVtZXJnZVxuZW1vdGlvblxuZW1wbG95XG5lbXBvd2VyXG5lbXB0eVxuZW5hYmxlXG5lbmFjdFxuZW5kXG5lbmRsZXNzXG5lbmRvcnNlXG5lbmVteVxuZW5lcmd5XG5lbmZvcmNlXG5lbmdhZ2VcbmVuZ2luZVxuZW5oYW5jZVxuZW5qb3lcbmVubGlzdFxuZW5vdWdoXG5lbnJpY2hcbmVucm9sbFxuZW5zdXJlXG5lbnRlclxuZW50aXJlXG5lbnRyeVxuZW52ZWxvcGVcbmVwaXNvZGVcbmVxdWFsXG5lcXVpcFxuZXJhXG5lcmFzZVxuZXJvZGVcbmVyb3Npb25cbmVycm9yXG5lcnVwdFxuZXNjYXBlXG5lc3NheVxuZXNzZW5jZVxuZXN0YXRlXG5ldGVybmFsXG5ldGhpY3NcbmV2aWRlbmNlXG5ldmlsXG5ldm9rZVxuZXZvbHZlXG5leGFjdFxuZXhhbXBsZVxuZXhjZXNzXG5leGNoYW5nZVxuZXhjaXRlXG5leGNsdWRlXG5leGN1c2VcbmV4ZWN1dGVcbmV4ZXJjaXNlXG5leGhhdXN0XG5leGhpYml0XG5leGlsZVxuZXhpc3RcbmV4aXRcbmV4b3RpY1xuZXhwYW5kXG5leHBlY3RcbmV4cGlyZVxuZXhwbGFpblxuZXhwb3NlXG5leHByZXNzXG5leHRlbmRcbmV4dHJhXG5leWVcbmV5ZWJyb3dcbmZhYnJpY1xuZmFjZVxuZmFjdWx0eVxuZmFkZVxuZmFpbnRcbmZhaXRoXG5mYWxsXG5mYWxzZVxuZmFtZVxuZmFtaWx5XG5mYW1vdXNcbmZhblxuZmFuY3lcbmZhbnRhc3lcbmZhcm1cbmZhc2hpb25cbmZhdFxuZmF0YWxcbmZhdGhlclxuZmF0aWd1ZVxuZmF1bHRcbmZhdm9yaXRlXG5mZWF0dXJlXG5mZWJydWFyeVxuZmVkZXJhbFxuZmVlXG5mZWVkXG5mZWVsXG5mZW1hbGVcbmZlbmNlXG5mZXN0aXZhbFxuZmV0Y2hcbmZldmVyXG5mZXdcbmZpYmVyXG5maWN0aW9uXG5maWVsZFxuZmlndXJlXG5maWxlXG5maWxtXG5maWx0ZXJcbmZpbmFsXG5maW5kXG5maW5lXG5maW5nZXJcbmZpbmlzaFxuZmlyZVxuZmlybVxuZmlyc3RcbmZpc2NhbFxuZmlzaFxuZml0XG5maXRuZXNzXG5maXhcbmZsYWdcbmZsYW1lXG5mbGFzaFxuZmxhdFxuZmxhdm9yXG5mbGVlXG5mbGlnaHRcbmZsaXBcbmZsb2F0XG5mbG9ja1xuZmxvb3JcbmZsb3dlclxuZmx1aWRcbmZsdXNoXG5mbHlcbmZvYW1cbmZvY3VzXG5mb2dcbmZvaWxcbmZvbGRcbmZvbGxvd1xuZm9vZFxuZm9vdFxuZm9yY2VcbmZvcmVzdFxuZm9yZ2V0XG5mb3JrXG5mb3J0dW5lXG5mb3J1bVxuZm9yd2FyZFxuZm9zc2lsXG5mb3N0ZXJcbmZvdW5kXG5mb3hcbmZyYWdpbGVcbmZyYW1lXG5mcmVxdWVudFxuZnJlc2hcbmZyaWVuZFxuZnJpbmdlXG5mcm9nXG5mcm9udFxuZnJvc3RcbmZyb3duXG5mcm96ZW5cbmZydWl0XG5mdWVsXG5mdW5cbmZ1bm55XG5mdXJuYWNlXG5mdXJ5XG5mdXR1cmVcbmdhZGdldFxuZ2FpblxuZ2FsYXh5XG5nYWxsZXJ5XG5nYW1lXG5nYXBcbmdhcmFnZVxuZ2FyYmFnZVxuZ2FyZGVuXG5nYXJsaWNcbmdhcm1lbnRcbmdhc1xuZ2FzcFxuZ2F0ZVxuZ2F0aGVyXG5nYXVnZVxuZ2F6ZVxuZ2VuZXJhbFxuZ2VuaXVzXG5nZW5yZVxuZ2VudGxlXG5nZW51aW5lXG5nZXN0dXJlXG5naG9zdFxuZ2lhbnRcbmdpZnRcbmdpZ2dsZVxuZ2luZ2VyXG5naXJhZmZlXG5naXJsXG5naXZlXG5nbGFkXG5nbGFuY2VcbmdsYXJlXG5nbGFzc1xuZ2xpZGVcbmdsaW1wc2Vcbmdsb2JlXG5nbG9vbVxuZ2xvcnlcbmdsb3ZlXG5nbG93XG5nbHVlXG5nb2F0XG5nb2RkZXNzXG5nb2xkXG5nb29kXG5nb29zZVxuZ29yaWxsYVxuZ29zcGVsXG5nb3NzaXBcbmdvdmVyblxuZ293blxuZ3JhYlxuZ3JhY2VcbmdyYWluXG5ncmFudFxuZ3JhcGVcbmdyYXNzXG5ncmF2aXR5XG5ncmVhdFxuZ3JlZW5cbmdyaWRcbmdyaWVmXG5ncml0XG5ncm9jZXJ5XG5ncm91cFxuZ3Jvd1xuZ3J1bnRcbmd1YXJkXG5ndWVzc1xuZ3VpZGVcbmd1aWx0XG5ndWl0YXJcbmd1blxuZ3ltXG5oYWJpdFxuaGFpclxuaGFsZlxuaGFtbWVyXG5oYW1zdGVyXG5oYW5kXG5oYXBweVxuaGFyYm9yXG5oYXJkXG5oYXJzaFxuaGFydmVzdFxuaGF0XG5oYXZlXG5oYXdrXG5oYXphcmRcbmhlYWRcbmhlYWx0aFxuaGVhcnRcbmhlYXZ5XG5oZWRnZWhvZ1xuaGVpZ2h0XG5oZWxsb1xuaGVsbWV0XG5oZWxwXG5oZW5cbmhlcm9cbmhpZGRlblxuaGlnaFxuaGlsbFxuaGludFxuaGlwXG5oaXJlXG5oaXN0b3J5XG5ob2JieVxuaG9ja2V5XG5ob2xkXG5ob2xlXG5ob2xpZGF5XG5ob2xsb3dcbmhvbWVcbmhvbmV5XG5ob29kXG5ob3BlXG5ob3JuXG5ob3Jyb3JcbmhvcnNlXG5ob3NwaXRhbFxuaG9zdFxuaG90ZWxcbmhvdXJcbmhvdmVyXG5odWJcbmh1Z2Vcbmh1bWFuXG5odW1ibGVcbmh1bW9yXG5odW5kcmVkXG5odW5ncnlcbmh1bnRcbmh1cmRsZVxuaHVycnlcbmh1cnRcbmh1c2JhbmRcbmh5YnJpZFxuaWNlXG5pY29uXG5pZGVhXG5pZGVudGlmeVxuaWRsZVxuaWdub3JlXG5pbGxcbmlsbGVnYWxcbmlsbG5lc3NcbmltYWdlXG5pbWl0YXRlXG5pbW1lbnNlXG5pbW11bmVcbmltcGFjdFxuaW1wb3NlXG5pbXByb3ZlXG5pbXB1bHNlXG5pbmNoXG5pbmNsdWRlXG5pbmNvbWVcbmluY3JlYXNlXG5pbmRleFxuaW5kaWNhdGVcbmluZG9vclxuaW5kdXN0cnlcbmluZmFudFxuaW5mbGljdFxuaW5mb3JtXG5pbmhhbGVcbmluaGVyaXRcbmluaXRpYWxcbmluamVjdFxuaW5qdXJ5XG5pbm1hdGVcbmlubmVyXG5pbm5vY2VudFxuaW5wdXRcbmlucXVpcnlcbmluc2FuZVxuaW5zZWN0XG5pbnNpZGVcbmluc3BpcmVcbmluc3RhbGxcbmludGFjdFxuaW50ZXJlc3RcbmludG9cbmludmVzdFxuaW52aXRlXG5pbnZvbHZlXG5pcm9uXG5pc2xhbmRcbmlzb2xhdGVcbmlzc3VlXG5pdGVtXG5pdm9yeVxuamFja2V0XG5qYWd1YXJcbmphclxuamF6elxuamVhbG91c1xuamVhbnNcbmplbGx5XG5qZXdlbFxuam9iXG5qb2luXG5qb2tlXG5qb3VybmV5XG5qb3lcbmp1ZGdlXG5qdWljZVxuanVtcFxuanVuZ2xlXG5qdW5pb3Jcbmp1bmtcbmp1c3Rcbmthbmdhcm9vXG5rZWVuXG5rZWVwXG5rZXRjaHVwXG5rZXlcbmtpY2tcbmtpZFxua2lkbmV5XG5raW5kXG5raW5nZG9tXG5raXNzXG5raXRcbmtpdGNoZW5cbmtpdGVcbmtpdHRlblxua2l3aVxua25lZVxua25pZmVcbmtub2NrXG5rbm93XG5sYWJcbmxhYmVsXG5sYWJvclxubGFkZGVyXG5sYWR5XG5sYWtlXG5sYW1wXG5sYW5ndWFnZVxubGFwdG9wXG5sYXJnZVxubGF0ZXJcbmxhdGluXG5sYXVnaFxubGF1bmRyeVxubGF2YVxubGF3XG5sYXduXG5sYXdzdWl0XG5sYXllclxubGF6eVxubGVhZGVyXG5sZWFmXG5sZWFyblxubGVhdmVcbmxlY3R1cmVcbmxlZnRcbmxlZ1xubGVnYWxcbmxlZ2VuZFxubGVpc3VyZVxubGVtb25cbmxlbmRcbmxlbmd0aFxubGVuc1xubGVvcGFyZFxubGVzc29uXG5sZXR0ZXJcbmxldmVsXG5saWFyXG5saWJlcnR5XG5saWJyYXJ5XG5saWNlbnNlXG5saWZlXG5saWZ0XG5saWdodFxubGlrZVxubGltYlxubGltaXRcbmxpbmtcbmxpb25cbmxpcXVpZFxubGlzdFxubGl0dGxlXG5saXZlXG5saXphcmRcbmxvYWRcbmxvYW5cbmxvYnN0ZXJcbmxvY2FsXG5sb2NrXG5sb2dpY1xubG9uZWx5XG5sb25nXG5sb29wXG5sb3R0ZXJ5XG5sb3VkXG5sb3VuZ2VcbmxvdmVcbmxveWFsXG5sdWNreVxubHVnZ2FnZVxubHVtYmVyXG5sdW5hclxubHVuY2hcbmx1eHVyeVxubHlyaWNzXG5tYWNoaW5lXG5tYWRcbm1hZ2ljXG5tYWduZXRcbm1haWRcbm1haWxcbm1haW5cbm1ham9yXG5tYWtlXG5tYW1tYWxcbm1hblxubWFuYWdlXG5tYW5kYXRlXG5tYW5nb1xubWFuc2lvblxubWFudWFsXG5tYXBsZVxubWFyYmxlXG5tYXJjaFxubWFyZ2luXG5tYXJpbmVcbm1hcmtldFxubWFycmlhZ2Vcbm1hc2tcbm1hc3Ncbm1hc3RlclxubWF0Y2hcbm1hdGVyaWFsXG5tYXRoXG5tYXRyaXhcbm1hdHRlclxubWF4aW11bVxubWF6ZVxubWVhZG93XG5tZWFuXG5tZWFzdXJlXG5tZWF0XG5tZWNoYW5pY1xubWVkYWxcbm1lZGlhXG5tZWxvZHlcbm1lbHRcbm1lbWJlclxubWVtb3J5XG5tZW50aW9uXG5tZW51XG5tZXJjeVxubWVyZ2Vcbm1lcml0XG5tZXJyeVxubWVzaFxubWVzc2FnZVxubWV0YWxcbm1ldGhvZFxubWlkZGxlXG5taWRuaWdodFxubWlsa1xubWlsbGlvblxubWltaWNcbm1pbmRcbm1pbmltdW1cbm1pbm9yXG5taW51dGVcbm1pcmFjbGVcbm1pcnJvclxubWlzZXJ5XG5taXNzXG5taXN0YWtlXG5taXhcbm1peGVkXG5taXh0dXJlXG5tb2JpbGVcbm1vZGVsXG5tb2RpZnlcbm1vbVxubW9tZW50XG5tb25pdG9yXG5tb25rZXlcbm1vbnN0ZXJcbm1vbnRoXG5tb29uXG5tb3JhbFxubW9yZVxubW9ybmluZ1xubW9zcXVpdG9cbm1vdGhlclxubW90aW9uXG5tb3RvclxubW91bnRhaW5cbm1vdXNlXG5tb3ZlXG5tb3ZpZVxubXVjaFxubXVmZmluXG5tdWxlXG5tdWx0aXBseVxubXVzY2xlXG5tdXNldW1cbm11c2hyb29tXG5tdXNpY1xubXVzdFxubXV0dWFsXG5teXNlbGZcbm15c3Rlcnlcbm15dGhcbm5haXZlXG5uYW1lXG5uYXBraW5cbm5hcnJvd1xubmFzdHlcbm5hdGlvblxubmF0dXJlXG5uZWFyXG5uZWNrXG5uZWVkXG5uZWdhdGl2ZVxubmVnbGVjdFxubmVpdGhlclxubmVwaGV3XG5uZXJ2ZVxubmVzdFxubmV0XG5uZXR3b3JrXG5uZXV0cmFsXG5uZXZlclxubmV3c1xubmV4dFxubmljZVxubmlnaHRcbm5vYmxlXG5ub2lzZVxubm9taW5lZVxubm9vZGxlXG5ub3JtYWxcbm5vcnRoXG5ub3NlXG5ub3RhYmxlXG5ub3RlXG5ub3RoaW5nXG5ub3RpY2Vcbm5vdmVsXG5ub3dcbm51Y2xlYXJcbm51bWJlclxubnVyc2Vcbm51dFxub2FrXG5vYmV5XG5vYmplY3Rcbm9ibGlnZVxub2JzY3VyZVxub2JzZXJ2ZVxub2J0YWluXG5vYnZpb3VzXG5vY2N1clxub2NlYW5cbm9jdG9iZXJcbm9kb3Jcbm9mZlxub2ZmZXJcbm9mZmljZVxub2Z0ZW5cbm9pbFxub2theVxub2xkXG5vbGl2ZVxub2x5bXBpY1xub21pdFxub25jZVxub25lXG5vbmlvblxub25saW5lXG5vbmx5XG5vcGVuXG5vcGVyYVxub3Bpbmlvblxub3Bwb3NlXG5vcHRpb25cbm9yYW5nZVxub3JiaXRcbm9yY2hhcmRcbm9yZGVyXG5vcmRpbmFyeVxub3JnYW5cbm9yaWVudFxub3JpZ2luYWxcbm9ycGhhblxub3N0cmljaFxub3RoZXJcbm91dGRvb3Jcbm91dGVyXG5vdXRwdXRcbm91dHNpZGVcbm92YWxcbm92ZW5cbm92ZXJcbm93blxub3duZXJcbm94eWdlblxub3lzdGVyXG5vem9uZVxucGFjdFxucGFkZGxlXG5wYWdlXG5wYWlyXG5wYWxhY2VcbnBhbG1cbnBhbmRhXG5wYW5lbFxucGFuaWNcbnBhbnRoZXJcbnBhcGVyXG5wYXJhZGVcbnBhcmVudFxucGFya1xucGFycm90XG5wYXJ0eVxucGFzc1xucGF0Y2hcbnBhdGhcbnBhdGllbnRcbnBhdHJvbFxucGF0dGVyblxucGF1c2VcbnBhdmVcbnBheW1lbnRcbnBlYWNlXG5wZWFudXRcbnBlYXJcbnBlYXNhbnRcbnBlbGljYW5cbnBlblxucGVuYWx0eVxucGVuY2lsXG5wZW9wbGVcbnBlcHBlclxucGVyZmVjdFxucGVybWl0XG5wZXJzb25cbnBldFxucGhvbmVcbnBob3RvXG5waHJhc2VcbnBoeXNpY2FsXG5waWFub1xucGljbmljXG5waWN0dXJlXG5waWVjZVxucGlnXG5waWdlb25cbnBpbGxcbnBpbG90XG5waW5rXG5waW9uZWVyXG5waXBlXG5waXN0b2xcbnBpdGNoXG5waXp6YVxucGxhY2VcbnBsYW5ldFxucGxhc3RpY1xucGxhdGVcbnBsYXlcbnBsZWFzZVxucGxlZGdlXG5wbHVja1xucGx1Z1xucGx1bmdlXG5wb2VtXG5wb2V0XG5wb2ludFxucG9sYXJcbnBvbGVcbnBvbGljZVxucG9uZFxucG9ueVxucG9vbFxucG9wdWxhclxucG9ydGlvblxucG9zaXRpb25cbnBvc3NpYmxlXG5wb3N0XG5wb3RhdG9cbnBvdHRlcnlcbnBvdmVydHlcbnBvd2RlclxucG93ZXJcbnByYWN0aWNlXG5wcmFpc2VcbnByZWRpY3RcbnByZWZlclxucHJlcGFyZVxucHJlc2VudFxucHJldHR5XG5wcmV2ZW50XG5wcmljZVxucHJpZGVcbnByaW1hcnlcbnByaW50XG5wcmlvcml0eVxucHJpc29uXG5wcml2YXRlXG5wcml6ZVxucHJvYmxlbVxucHJvY2Vzc1xucHJvZHVjZVxucHJvZml0XG5wcm9ncmFtXG5wcm9qZWN0XG5wcm9tb3RlXG5wcm9vZlxucHJvcGVydHlcbnByb3NwZXJcbnByb3RlY3RcbnByb3VkXG5wcm92aWRlXG5wdWJsaWNcbnB1ZGRpbmdcbnB1bGxcbnB1bHBcbnB1bHNlXG5wdW1wa2luXG5wdW5jaFxucHVwaWxcbnB1cHB5XG5wdXJjaGFzZVxucHVyaXR5XG5wdXJwb3NlXG5wdXJzZVxucHVzaFxucHV0XG5wdXp6bGVcbnB5cmFtaWRcbnF1YWxpdHlcbnF1YW50dW1cbnF1YXJ0ZXJcbnF1ZXN0aW9uXG5xdWlja1xucXVpdFxucXVpelxucXVvdGVcbnJhYmJpdFxucmFjY29vblxucmFjZVxucmFja1xucmFkYXJcbnJhZGlvXG5yYWlsXG5yYWluXG5yYWlzZVxucmFsbHlcbnJhbXBcbnJhbmNoXG5yYW5kb21cbnJhbmdlXG5yYXBpZFxucmFyZVxucmF0ZVxucmF0aGVyXG5yYXZlblxucmF3XG5yYXpvclxucmVhZHlcbnJlYWxcbnJlYXNvblxucmViZWxcbnJlYnVpbGRcbnJlY2FsbFxucmVjZWl2ZVxucmVjaXBlXG5yZWNvcmRcbnJlY3ljbGVcbnJlZHVjZVxucmVmbGVjdFxucmVmb3JtXG5yZWZ1c2VcbnJlZ2lvblxucmVncmV0XG5yZWd1bGFyXG5yZWplY3RcbnJlbGF4XG5yZWxlYXNlXG5yZWxpZWZcbnJlbHlcbnJlbWFpblxucmVtZW1iZXJcbnJlbWluZFxucmVtb3ZlXG5yZW5kZXJcbnJlbmV3XG5yZW50XG5yZW9wZW5cbnJlcGFpclxucmVwZWF0XG5yZXBsYWNlXG5yZXBvcnRcbnJlcXVpcmVcbnJlc2N1ZVxucmVzZW1ibGVcbnJlc2lzdFxucmVzb3VyY2VcbnJlc3BvbnNlXG5yZXN1bHRcbnJldGlyZVxucmV0cmVhdFxucmV0dXJuXG5yZXVuaW9uXG5yZXZlYWxcbnJldmlld1xucmV3YXJkXG5yaHl0aG1cbnJpYlxucmliYm9uXG5yaWNlXG5yaWNoXG5yaWRlXG5yaWRnZVxucmlmbGVcbnJpZ2h0XG5yaWdpZFxucmluZ1xucmlvdFxucmlwcGxlXG5yaXNrXG5yaXR1YWxcbnJpdmFsXG5yaXZlclxucm9hZFxucm9hc3RcbnJvYm90XG5yb2J1c3RcbnJvY2tldFxucm9tYW5jZVxucm9vZlxucm9va2llXG5yb29tXG5yb3NlXG5yb3RhdGVcbnJvdWdoXG5yb3VuZFxucm91dGVcbnJveWFsXG5ydWJiZXJcbnJ1ZGVcbnJ1Z1xucnVsZVxucnVuXG5ydW53YXlcbnJ1cmFsXG5zYWRcbnNhZGRsZVxuc2FkbmVzc1xuc2FmZVxuc2FpbFxuc2FsYWRcbnNhbG1vblxuc2Fsb25cbnNhbHRcbnNhbHV0ZVxuc2FtZVxuc2FtcGxlXG5zYW5kXG5zYXRpc2Z5XG5zYXRvc2hpXG5zYXVjZVxuc2F1c2FnZVxuc2F2ZVxuc2F5XG5zY2FsZVxuc2Nhblxuc2NhcmVcbnNjYXR0ZXJcbnNjZW5lXG5zY2hlbWVcbnNjaG9vbFxuc2NpZW5jZVxuc2Npc3NvcnNcbnNjb3JwaW9uXG5zY291dFxuc2NyYXBcbnNjcmVlblxuc2NyaXB0XG5zY3J1Ylxuc2VhXG5zZWFyY2hcbnNlYXNvblxuc2VhdFxuc2Vjb25kXG5zZWNyZXRcbnNlY3Rpb25cbnNlY3VyaXR5XG5zZWVkXG5zZWVrXG5zZWdtZW50XG5zZWxlY3RcbnNlbGxcbnNlbWluYXJcbnNlbmlvclxuc2Vuc2VcbnNlbnRlbmNlXG5zZXJpZXNcbnNlcnZpY2VcbnNlc3Npb25cbnNldHRsZVxuc2V0dXBcbnNldmVuXG5zaGFkb3dcbnNoYWZ0XG5zaGFsbG93XG5zaGFyZVxuc2hlZFxuc2hlbGxcbnNoZXJpZmZcbnNoaWVsZFxuc2hpZnRcbnNoaW5lXG5zaGlwXG5zaGl2ZXJcbnNob2NrXG5zaG9lXG5zaG9vdFxuc2hvcFxuc2hvcnRcbnNob3VsZGVyXG5zaG92ZVxuc2hyaW1wXG5zaHJ1Z1xuc2h1ZmZsZVxuc2h5XG5zaWJsaW5nXG5zaWNrXG5zaWRlXG5zaWVnZVxuc2lnaHRcbnNpZ25cbnNpbGVudFxuc2lsa1xuc2lsbHlcbnNpbHZlclxuc2ltaWxhclxuc2ltcGxlXG5zaW5jZVxuc2luZ1xuc2lyZW5cbnNpc3Rlclxuc2l0dWF0ZVxuc2l4XG5zaXplXG5za2F0ZVxuc2tldGNoXG5za2lcbnNraWxsXG5za2luXG5za2lydFxuc2t1bGxcbnNsYWJcbnNsYW1cbnNsZWVwXG5zbGVuZGVyXG5zbGljZVxuc2xpZGVcbnNsaWdodFxuc2xpbVxuc2xvZ2FuXG5zbG90XG5zbG93XG5zbHVzaFxuc21hbGxcbnNtYXJ0XG5zbWlsZVxuc21va2VcbnNtb290aFxuc25hY2tcbnNuYWtlXG5zbmFwXG5zbmlmZlxuc25vd1xuc29hcFxuc29jY2VyXG5zb2NpYWxcbnNvY2tcbnNvZGFcbnNvZnRcbnNvbGFyXG5zb2xkaWVyXG5zb2xpZFxuc29sdXRpb25cbnNvbHZlXG5zb21lb25lXG5zb25nXG5zb29uXG5zb3JyeVxuc29ydFxuc291bFxuc291bmRcbnNvdXBcbnNvdXJjZVxuc291dGhcbnNwYWNlXG5zcGFyZVxuc3BhdGlhbFxuc3Bhd25cbnNwZWFrXG5zcGVjaWFsXG5zcGVlZFxuc3BlbGxcbnNwZW5kXG5zcGhlcmVcbnNwaWNlXG5zcGlkZXJcbnNwaWtlXG5zcGluXG5zcGlyaXRcbnNwbGl0XG5zcG9pbFxuc3BvbnNvclxuc3Bvb25cbnNwb3J0XG5zcG90XG5zcHJheVxuc3ByZWFkXG5zcHJpbmdcbnNweVxuc3F1YXJlXG5zcXVlZXplXG5zcXVpcnJlbFxuc3RhYmxlXG5zdGFkaXVtXG5zdGFmZlxuc3RhZ2VcbnN0YWlyc1xuc3RhbXBcbnN0YW5kXG5zdGFydFxuc3RhdGVcbnN0YXlcbnN0ZWFrXG5zdGVlbFxuc3RlbVxuc3RlcFxuc3RlcmVvXG5zdGlja1xuc3RpbGxcbnN0aW5nXG5zdG9ja1xuc3RvbWFjaFxuc3RvbmVcbnN0b29sXG5zdG9yeVxuc3RvdmVcbnN0cmF0ZWd5XG5zdHJlZXRcbnN0cmlrZVxuc3Ryb25nXG5zdHJ1Z2dsZVxuc3R1ZGVudFxuc3R1ZmZcbnN0dW1ibGVcbnN0eWxlXG5zdWJqZWN0XG5zdWJtaXRcbnN1YndheVxuc3VjY2Vzc1xuc3VjaFxuc3VkZGVuXG5zdWZmZXJcbnN1Z2FyXG5zdWdnZXN0XG5zdWl0XG5zdW1tZXJcbnN1blxuc3VubnlcbnN1bnNldFxuc3VwZXJcbnN1cHBseVxuc3VwcmVtZVxuc3VyZVxuc3VyZmFjZVxuc3VyZ2VcbnN1cnByaXNlXG5zdXJyb3VuZFxuc3VydmV5XG5zdXNwZWN0XG5zdXN0YWluXG5zd2FsbG93XG5zd2FtcFxuc3dhcFxuc3dhcm1cbnN3ZWFyXG5zd2VldFxuc3dpZnRcbnN3aW1cbnN3aW5nXG5zd2l0Y2hcbnN3b3JkXG5zeW1ib2xcbnN5bXB0b21cbnN5cnVwXG5zeXN0ZW1cbnRhYmxlXG50YWNrbGVcbnRhZ1xudGFpbFxudGFsZW50XG50YWxrXG50YW5rXG50YXBlXG50YXJnZXRcbnRhc2tcbnRhc3RlXG50YXR0b29cbnRheGlcbnRlYWNoXG50ZWFtXG50ZWxsXG50ZW5cbnRlbmFudFxudGVubmlzXG50ZW50XG50ZXJtXG50ZXN0XG50ZXh0XG50aGFua1xudGhhdFxudGhlbWVcbnRoZW5cbnRoZW9yeVxudGhlcmVcbnRoZXlcbnRoaW5nXG50aGlzXG50aG91Z2h0XG50aHJlZVxudGhyaXZlXG50aHJvd1xudGh1bWJcbnRodW5kZXJcbnRpY2tldFxudGlkZVxudGlnZXJcbnRpbHRcbnRpbWJlclxudGltZVxudGlueVxudGlwXG50aXJlZFxudGlzc3VlXG50aXRsZVxudG9hc3RcbnRvYmFjY29cbnRvZGF5XG50b2RkbGVyXG50b2VcbnRvZ2V0aGVyXG50b2lsZXRcbnRva2VuXG50b21hdG9cbnRvbW9ycm93XG50b25lXG50b25ndWVcbnRvbmlnaHRcbnRvb2xcbnRvb3RoXG50b3BcbnRvcGljXG50b3BwbGVcbnRvcmNoXG50b3JuYWRvXG50b3J0b2lzZVxudG9zc1xudG90YWxcbnRvdXJpc3RcbnRvd2FyZFxudG93ZXJcbnRvd25cbnRveVxudHJhY2tcbnRyYWRlXG50cmFmZmljXG50cmFnaWNcbnRyYWluXG50cmFuc2ZlclxudHJhcFxudHJhc2hcbnRyYXZlbFxudHJheVxudHJlYXRcbnRyZWVcbnRyZW5kXG50cmlhbFxudHJpYmVcbnRyaWNrXG50cmlnZ2VyXG50cmltXG50cmlwXG50cm9waHlcbnRyb3VibGVcbnRydWNrXG50cnVlXG50cnVseVxudHJ1bXBldFxudHJ1c3RcbnRydXRoXG50cnlcbnR1YmVcbnR1aXRpb25cbnR1bWJsZVxudHVuYVxudHVubmVsXG50dXJrZXlcbnR1cm5cbnR1cnRsZVxudHdlbHZlXG50d2VudHlcbnR3aWNlXG50d2luXG50d2lzdFxudHdvXG50eXBlXG50eXBpY2FsXG51Z2x5XG51bWJyZWxsYVxudW5hYmxlXG51bmF3YXJlXG51bmNsZVxudW5jb3ZlclxudW5kZXJcbnVuZG9cbnVuZmFpclxudW5mb2xkXG51bmhhcHB5XG51bmlmb3JtXG51bmlxdWVcbnVuaXRcbnVuaXZlcnNlXG51bmtub3duXG51bmxvY2tcbnVudGlsXG51bnVzdWFsXG51bnZlaWxcbnVwZGF0ZVxudXBncmFkZVxudXBob2xkXG51cG9uXG51cHBlclxudXBzZXRcbnVyYmFuXG51cmdlXG51c2FnZVxudXNlXG51c2VkXG51c2VmdWxcbnVzZWxlc3NcbnVzdWFsXG51dGlsaXR5XG52YWNhbnRcbnZhY3V1bVxudmFndWVcbnZhbGlkXG52YWxsZXlcbnZhbHZlXG52YW5cbnZhbmlzaFxudmFwb3JcbnZhcmlvdXNcbnZhc3RcbnZhdWx0XG52ZWhpY2xlXG52ZWx2ZXRcbnZlbmRvclxudmVudHVyZVxudmVudWVcbnZlcmJcbnZlcmlmeVxudmVyc2lvblxudmVyeVxudmVzc2VsXG52ZXRlcmFuXG52aWFibGVcbnZpYnJhbnRcbnZpY2lvdXNcbnZpY3RvcnlcbnZpZGVvXG52aWV3XG52aWxsYWdlXG52aW50YWdlXG52aW9saW5cbnZpcnR1YWxcbnZpcnVzXG52aXNhXG52aXNpdFxudmlzdWFsXG52aXRhbFxudml2aWRcbnZvY2FsXG52b2ljZVxudm9pZFxudm9sY2Fub1xudm9sdW1lXG52b3RlXG52b3lhZ2VcbndhZ2VcbndhZ29uXG53YWl0XG53YWxrXG53YWxsXG53YWxudXRcbndhbnRcbndhcmZhcmVcbndhcm1cbndhcnJpb3Jcbndhc2hcbndhc3Bcbndhc3RlXG53YXRlclxud2F2ZVxud2F5XG53ZWFsdGhcbndlYXBvblxud2Vhclxud2Vhc2VsXG53ZWF0aGVyXG53ZWJcbndlZGRpbmdcbndlZWtlbmRcbndlaXJkXG53ZWxjb21lXG53ZXN0XG53ZXRcbndoYWxlXG53aGF0XG53aGVhdFxud2hlZWxcbndoZW5cbndoZXJlXG53aGlwXG53aGlzcGVyXG53aWRlXG53aWR0aFxud2lmZVxud2lsZFxud2lsbFxud2luXG53aW5kb3dcbndpbmVcbndpbmdcbndpbmtcbndpbm5lclxud2ludGVyXG53aXJlXG53aXNkb21cbndpc2Vcbndpc2hcbndpdG5lc3NcbndvbGZcbndvbWFuXG53b25kZXJcbndvb2Rcbndvb2xcbndvcmRcbndvcmtcbndvcmxkXG53b3JyeVxud29ydGhcbndyYXBcbndyZWNrXG53cmVzdGxlXG53cmlzdFxud3JpdGVcbndyb25nXG55YXJkXG55ZWFyXG55ZWxsb3dcbnlvdVxueW91bmdcbnlvdXRoXG56ZWJyYVxuemVyb1xuem9uZVxuem9vYC5zcGxpdChgXG5gKTtcbnZhciBkZSA9IHt9O1xuZnVuY3Rpb24gUHIodCkge1xuICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKHQpIHx8IHQgPCAwKVxuICAgIHRocm93IG5ldyBFcnJvcihgV3JvbmcgcG9zaXRpdmUgaW50ZWdlcjogJHt0fWApO1xufVxuZnVuY3Rpb24gTHModCkge1xuICBpZiAodHlwZW9mIHQgIT0gXCJib29sZWFuXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBib29sZWFuLCBub3QgJHt0fWApO1xufVxuZnVuY3Rpb24gWWUodCwgLi4uZSkge1xuICBpZiAoISh0IGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgVWludDhBcnJheVwiKTtcbiAgaWYgKGUubGVuZ3RoID4gMCAmJiAhZS5pbmNsdWRlcyh0Lmxlbmd0aCkpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBVaW50OEFycmF5IG9mIGxlbmd0aCAke2V9LCBub3Qgb2YgbGVuZ3RoPSR7dC5sZW5ndGh9YCk7XG59XG5mdW5jdGlvbiAkcyh0KSB7XG4gIGlmICh0eXBlb2YgdCAhPSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIHQuY3JlYXRlICE9IFwiZnVuY3Rpb25cIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJIYXNoIHNob3VsZCBiZSB3cmFwcGVkIGJ5IHV0aWxzLndyYXBDb25zdHJ1Y3RvclwiKTtcbiAgUHIodC5vdXRwdXRMZW4pLCBQcih0LmJsb2NrTGVuKTtcbn1cbmZ1bmN0aW9uIHFzKHQsIGUgPSAhMCkge1xuICBpZiAodC5kZXN0cm95ZWQpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSGFzaCBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWRcIik7XG4gIGlmIChlICYmIHQuZmluaXNoZWQpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSGFzaCNkaWdlc3QoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZFwiKTtcbn1cbmZ1bmN0aW9uIE5zKHQsIGUpIHtcbiAgWWUodCk7XG4gIGNvbnN0IHIgPSBlLm91dHB1dExlbjtcbiAgaWYgKHQubGVuZ3RoIDwgcilcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGRpZ2VzdEludG8oKSBleHBlY3RzIG91dHB1dCBidWZmZXIgb2YgbGVuZ3RoIGF0IGxlYXN0ICR7cn1gKTtcbn1cbmNvbnN0IFFlID0ge1xuICBudW1iZXI6IFByLFxuICBib29sOiBMcyxcbiAgYnl0ZXM6IFllLFxuICBoYXNoOiAkcyxcbiAgZXhpc3RzOiBxcyxcbiAgb3V0cHV0OiBOc1xufSwgRHUgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgX19wcm90b19fOiBudWxsLFxuICBudW1iZXI6IFByLFxuICBib29sOiBMcyxcbiAgYnl0ZXM6IFllLFxuICBoYXNoOiAkcyxcbiAgZXhpc3RzOiBxcyxcbiAgb3V0cHV0OiBOcyxcbiAgZGVmYXVsdDogUWVcbn0sIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KSksIHp1ID0gLyogQF9fUFVSRV9fICovIEV0KER1KTtcbnZhciB4dCA9IHt9LCBuZSA9IHt9O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KG5lLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG5uZS5vdXRwdXQgPSBuZS5leGlzdHMgPSBuZS5oYXNoID0gbmUuYnl0ZXMgPSBuZS5ib29sID0gbmUubnVtYmVyID0gdm9pZCAwO1xuZnVuY3Rpb24gQnIodCkge1xuICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKHQpIHx8IHQgPCAwKVxuICAgIHRocm93IG5ldyBFcnJvcihgV3JvbmcgcG9zaXRpdmUgaW50ZWdlcjogJHt0fWApO1xufVxubmUubnVtYmVyID0gQnI7XG5mdW5jdGlvbiBVcyh0KSB7XG4gIGlmICh0eXBlb2YgdCAhPSBcImJvb2xlYW5cIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGJvb2xlYW4sIG5vdCAke3R9YCk7XG59XG5uZS5ib29sID0gVXM7XG5mdW5jdGlvbiBlaSh0LCAuLi5lKSB7XG4gIGlmICghKHQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBVaW50OEFycmF5XCIpO1xuICBpZiAoZS5sZW5ndGggPiAwICYmICFlLmluY2x1ZGVzKHQubGVuZ3RoKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIFVpbnQ4QXJyYXkgb2YgbGVuZ3RoICR7ZX0sIG5vdCBvZiBsZW5ndGg9JHt0Lmxlbmd0aH1gKTtcbn1cbm5lLmJ5dGVzID0gZWk7XG5mdW5jdGlvbiBqcyh0KSB7XG4gIGlmICh0eXBlb2YgdCAhPSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIHQuY3JlYXRlICE9IFwiZnVuY3Rpb25cIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJIYXNoIHNob3VsZCBiZSB3cmFwcGVkIGJ5IHV0aWxzLndyYXBDb25zdHJ1Y3RvclwiKTtcbiAgQnIodC5vdXRwdXRMZW4pLCBCcih0LmJsb2NrTGVuKTtcbn1cbm5lLmhhc2ggPSBqcztcbmZ1bmN0aW9uIEhzKHQsIGUgPSAhMCkge1xuICBpZiAodC5kZXN0cm95ZWQpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSGFzaCBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWRcIik7XG4gIGlmIChlICYmIHQuZmluaXNoZWQpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSGFzaCNkaWdlc3QoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZFwiKTtcbn1cbm5lLmV4aXN0cyA9IEhzO1xuZnVuY3Rpb24gTXModCwgZSkge1xuICBlaSh0KTtcbiAgY29uc3QgciA9IGUub3V0cHV0TGVuO1xuICBpZiAodC5sZW5ndGggPCByKVxuICAgIHRocm93IG5ldyBFcnJvcihgZGlnZXN0SW50bygpIGV4cGVjdHMgb3V0cHV0IGJ1ZmZlciBvZiBsZW5ndGggYXQgbGVhc3QgJHtyfWApO1xufVxubmUub3V0cHV0ID0gTXM7XG5jb25zdCBGdSA9IHtcbiAgbnVtYmVyOiBCcixcbiAgYm9vbDogVXMsXG4gIGJ5dGVzOiBlaSxcbiAgaGFzaDoganMsXG4gIGV4aXN0czogSHMsXG4gIG91dHB1dDogTXNcbn07XG5uZS5kZWZhdWx0ID0gRnU7XG52YXIgRHMgPSB7fSwgdGkgPSB7fTtcbmNvbnN0IFNyID0gdHlwZW9mIGdsb2JhbFRoaXMgPT0gXCJvYmplY3RcIiAmJiBcImNyeXB0b1wiIGluIGdsb2JhbFRoaXMgPyBnbG9iYWxUaGlzLmNyeXB0byA6IHZvaWQgMCwgS3UgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgX19wcm90b19fOiBudWxsLFxuICBjcnlwdG86IFNyXG59LCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSkpLCBXdSA9IC8qIEBfX1BVUkVfXyAqLyBFdChLdSk7XG4oZnVuY3Rpb24odCkge1xuICAvKiEgbm9ibGUtaGFzaGVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIHQucmFuZG9tQnl0ZXMgPSB0LndyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzID0gdC53cmFwQ29uc3RydWN0b3JXaXRoT3B0cyA9IHQud3JhcENvbnN0cnVjdG9yID0gdC5jaGVja09wdHMgPSB0Lkhhc2ggPSB0LmNvbmNhdEJ5dGVzID0gdC50b0J5dGVzID0gdC51dGY4VG9CeXRlcyA9IHQuYXN5bmNMb29wID0gdC5uZXh0VGljayA9IHQuaGV4VG9CeXRlcyA9IHQuYnl0ZXNUb0hleCA9IHQuaXNMRSA9IHQucm90ciA9IHQuY3JlYXRlVmlldyA9IHQudTMyID0gdC51OCA9IHZvaWQgMDtcbiAgY29uc3QgZSA9IFd1LCByID0gKHcpID0+IHcgaW5zdGFuY2VvZiBVaW50OEFycmF5LCBuID0gKHcpID0+IG5ldyBVaW50OEFycmF5KHcuYnVmZmVyLCB3LmJ5dGVPZmZzZXQsIHcuYnl0ZUxlbmd0aCk7XG4gIHQudTggPSBuO1xuICBjb25zdCBpID0gKHcpID0+IG5ldyBVaW50MzJBcnJheSh3LmJ1ZmZlciwgdy5ieXRlT2Zmc2V0LCBNYXRoLmZsb29yKHcuYnl0ZUxlbmd0aCAvIDQpKTtcbiAgdC51MzIgPSBpO1xuICBjb25zdCBzID0gKHcpID0+IG5ldyBEYXRhVmlldyh3LmJ1ZmZlciwgdy5ieXRlT2Zmc2V0LCB3LmJ5dGVMZW5ndGgpO1xuICB0LmNyZWF0ZVZpZXcgPSBzO1xuICBjb25zdCBvID0gKHcsIHgpID0+IHcgPDwgMzIgLSB4IHwgdyA+Pj4geDtcbiAgaWYgKHQucm90ciA9IG8sIHQuaXNMRSA9IG5ldyBVaW50OEFycmF5KG5ldyBVaW50MzJBcnJheShbMjg3NDU0MDIwXSkuYnVmZmVyKVswXSA9PT0gNjgsICF0LmlzTEUpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm9uIGxpdHRsZS1lbmRpYW4gaGFyZHdhcmUgaXMgbm90IHN1cHBvcnRlZFwiKTtcbiAgY29uc3QgYSA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAodywgeCkgPT4geC50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpKTtcbiAgZnVuY3Rpb24gYyh3KSB7XG4gICAgaWYgKCFyKHcpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVWludDhBcnJheSBleHBlY3RlZFwiKTtcbiAgICBsZXQgeCA9IFwiXCI7XG4gICAgZm9yIChsZXQgQSA9IDA7IEEgPCB3Lmxlbmd0aDsgQSsrKVxuICAgICAgeCArPSBhW3dbQV1dO1xuICAgIHJldHVybiB4O1xuICB9XG4gIHQuYnl0ZXNUb0hleCA9IGM7XG4gIGZ1bmN0aW9uIGwodykge1xuICAgIGlmICh0eXBlb2YgdyAhPSBcInN0cmluZ1wiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IFwiICsgdHlwZW9mIHcpO1xuICAgIGNvbnN0IHggPSB3Lmxlbmd0aDtcbiAgICBpZiAoeCAlIDIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwYWRkZWQgaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IHVucGFkZGVkIGhleCBvZiBsZW5ndGggXCIgKyB4KTtcbiAgICBjb25zdCBBID0gbmV3IFVpbnQ4QXJyYXkoeCAvIDIpO1xuICAgIGZvciAobGV0IEIgPSAwOyBCIDwgQS5sZW5ndGg7IEIrKykge1xuICAgICAgY29uc3QgTCA9IEIgKiAyLCBQID0gdy5zbGljZShMLCBMICsgMiksIEYgPSBOdW1iZXIucGFyc2VJbnQoUCwgMTYpO1xuICAgICAgaWYgKE51bWJlci5pc05hTihGKSB8fCBGIDwgMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBieXRlIHNlcXVlbmNlXCIpO1xuICAgICAgQVtCXSA9IEY7XG4gICAgfVxuICAgIHJldHVybiBBO1xuICB9XG4gIHQuaGV4VG9CeXRlcyA9IGw7XG4gIGNvbnN0IGYgPSBhc3luYyAoKSA9PiB7XG4gIH07XG4gIHQubmV4dFRpY2sgPSBmO1xuICBhc3luYyBmdW5jdGlvbiB1KHcsIHgsIEEpIHtcbiAgICBsZXQgQiA9IERhdGUubm93KCk7XG4gICAgZm9yIChsZXQgTCA9IDA7IEwgPCB3OyBMKyspIHtcbiAgICAgIEEoTCk7XG4gICAgICBjb25zdCBQID0gRGF0ZS5ub3coKSAtIEI7XG4gICAgICBQID49IDAgJiYgUCA8IHggfHwgKGF3YWl0ICgwLCB0Lm5leHRUaWNrKSgpLCBCICs9IFApO1xuICAgIH1cbiAgfVxuICB0LmFzeW5jTG9vcCA9IHU7XG4gIGZ1bmN0aW9uIGgodykge1xuICAgIGlmICh0eXBlb2YgdyAhPSBcInN0cmluZ1wiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1dGY4VG9CeXRlcyBleHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiB3fWApO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUodykpO1xuICB9XG4gIHQudXRmOFRvQnl0ZXMgPSBoO1xuICBmdW5jdGlvbiBkKHcpIHtcbiAgICBpZiAodHlwZW9mIHcgPT0gXCJzdHJpbmdcIiAmJiAodyA9IGgodykpLCAhcih3KSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgVWludDhBcnJheSwgZ290ICR7dHlwZW9mIHd9YCk7XG4gICAgcmV0dXJuIHc7XG4gIH1cbiAgdC50b0J5dGVzID0gZDtcbiAgZnVuY3Rpb24gcCguLi53KSB7XG4gICAgY29uc3QgeCA9IG5ldyBVaW50OEFycmF5KHcucmVkdWNlKChCLCBMKSA9PiBCICsgTC5sZW5ndGgsIDApKTtcbiAgICBsZXQgQSA9IDA7XG4gICAgcmV0dXJuIHcuZm9yRWFjaCgoQikgPT4ge1xuICAgICAgaWYgKCFyKEIpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVaW50OEFycmF5IGV4cGVjdGVkXCIpO1xuICAgICAgeC5zZXQoQiwgQSksIEEgKz0gQi5sZW5ndGg7XG4gICAgfSksIHg7XG4gIH1cbiAgdC5jb25jYXRCeXRlcyA9IHA7XG4gIGNsYXNzIHkge1xuICAgIGNsb25lKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Nsb25lSW50bygpO1xuICAgIH1cbiAgfVxuICB0Lkhhc2ggPSB5O1xuICBjb25zdCBnID0gKHcpID0+IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh3KSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIiAmJiB3LmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG4gIGZ1bmN0aW9uIHYodywgeCkge1xuICAgIGlmICh4ICE9PSB2b2lkIDAgJiYgKHR5cGVvZiB4ICE9IFwib2JqZWN0XCIgfHwgIWcoeCkpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT3B0aW9ucyBzaG91bGQgYmUgb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih3LCB4KTtcbiAgfVxuICB0LmNoZWNrT3B0cyA9IHY7XG4gIGZ1bmN0aW9uIF8odykge1xuICAgIGNvbnN0IHggPSAoQikgPT4gdygpLnVwZGF0ZShkKEIpKS5kaWdlc3QoKSwgQSA9IHcoKTtcbiAgICByZXR1cm4geC5vdXRwdXRMZW4gPSBBLm91dHB1dExlbiwgeC5ibG9ja0xlbiA9IEEuYmxvY2tMZW4sIHguY3JlYXRlID0gKCkgPT4gdygpLCB4O1xuICB9XG4gIHQud3JhcENvbnN0cnVjdG9yID0gXztcbiAgZnVuY3Rpb24gbSh3KSB7XG4gICAgY29uc3QgeCA9IChCLCBMKSA9PiB3KEwpLnVwZGF0ZShkKEIpKS5kaWdlc3QoKSwgQSA9IHcoe30pO1xuICAgIHJldHVybiB4Lm91dHB1dExlbiA9IEEub3V0cHV0TGVuLCB4LmJsb2NrTGVuID0gQS5ibG9ja0xlbiwgeC5jcmVhdGUgPSAoQikgPT4gdyhCKSwgeDtcbiAgfVxuICB0LndyYXBDb25zdHJ1Y3RvcldpdGhPcHRzID0gbTtcbiAgZnVuY3Rpb24gQyh3KSB7XG4gICAgY29uc3QgeCA9IChCLCBMKSA9PiB3KEwpLnVwZGF0ZShkKEIpKS5kaWdlc3QoKSwgQSA9IHcoe30pO1xuICAgIHJldHVybiB4Lm91dHB1dExlbiA9IEEub3V0cHV0TGVuLCB4LmJsb2NrTGVuID0gQS5ibG9ja0xlbiwgeC5jcmVhdGUgPSAoQikgPT4gdyhCKSwgeDtcbiAgfVxuICB0LndyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzID0gQztcbiAgZnVuY3Rpb24gTyh3ID0gMzIpIHtcbiAgICBpZiAoZS5jcnlwdG8gJiYgdHlwZW9mIGUuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICByZXR1cm4gZS5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KHcpKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIG11c3QgYmUgZGVmaW5lZFwiKTtcbiAgfVxuICB0LnJhbmRvbUJ5dGVzID0gTztcbn0pKHRpKTtcbihmdW5jdGlvbih0KSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIHQuaG1hYyA9IHQuSE1BQyA9IHZvaWQgMDtcbiAgY29uc3QgZSA9IG5lLCByID0gdGk7XG4gIGNsYXNzIG4gZXh0ZW5kcyByLkhhc2gge1xuICAgIGNvbnN0cnVjdG9yKG8sIGEpIHtcbiAgICAgIHN1cGVyKCksIHRoaXMuZmluaXNoZWQgPSAhMSwgdGhpcy5kZXN0cm95ZWQgPSAhMSwgZS5kZWZhdWx0Lmhhc2gobyk7XG4gICAgICBjb25zdCBjID0gKDAsIHIudG9CeXRlcykoYSk7XG4gICAgICBpZiAodGhpcy5pSGFzaCA9IG8uY3JlYXRlKCksIHR5cGVvZiB0aGlzLmlIYXNoLnVwZGF0ZSAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIGluc3RhbmNlIG9mIGNsYXNzIHdoaWNoIGV4dGVuZHMgdXRpbHMuSGFzaFwiKTtcbiAgICAgIHRoaXMuYmxvY2tMZW4gPSB0aGlzLmlIYXNoLmJsb2NrTGVuLCB0aGlzLm91dHB1dExlbiA9IHRoaXMuaUhhc2gub3V0cHV0TGVuO1xuICAgICAgY29uc3QgbCA9IHRoaXMuYmxvY2tMZW4sIGYgPSBuZXcgVWludDhBcnJheShsKTtcbiAgICAgIGYuc2V0KGMubGVuZ3RoID4gbCA/IG8uY3JlYXRlKCkudXBkYXRlKGMpLmRpZ2VzdCgpIDogYyk7XG4gICAgICBmb3IgKGxldCB1ID0gMDsgdSA8IGYubGVuZ3RoOyB1KyspXG4gICAgICAgIGZbdV0gXj0gNTQ7XG4gICAgICB0aGlzLmlIYXNoLnVwZGF0ZShmKSwgdGhpcy5vSGFzaCA9IG8uY3JlYXRlKCk7XG4gICAgICBmb3IgKGxldCB1ID0gMDsgdSA8IGYubGVuZ3RoOyB1KyspXG4gICAgICAgIGZbdV0gXj0gMTA2O1xuICAgICAgdGhpcy5vSGFzaC51cGRhdGUoZiksIGYuZmlsbCgwKTtcbiAgICB9XG4gICAgdXBkYXRlKG8pIHtcbiAgICAgIHJldHVybiBlLmRlZmF1bHQuZXhpc3RzKHRoaXMpLCB0aGlzLmlIYXNoLnVwZGF0ZShvKSwgdGhpcztcbiAgICB9XG4gICAgZGlnZXN0SW50byhvKSB7XG4gICAgICBlLmRlZmF1bHQuZXhpc3RzKHRoaXMpLCBlLmRlZmF1bHQuYnl0ZXMobywgdGhpcy5vdXRwdXRMZW4pLCB0aGlzLmZpbmlzaGVkID0gITAsIHRoaXMuaUhhc2guZGlnZXN0SW50byhvKSwgdGhpcy5vSGFzaC51cGRhdGUobyksIHRoaXMub0hhc2guZGlnZXN0SW50byhvKSwgdGhpcy5kZXN0cm95KCk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgIGNvbnN0IG8gPSBuZXcgVWludDhBcnJheSh0aGlzLm9IYXNoLm91dHB1dExlbik7XG4gICAgICByZXR1cm4gdGhpcy5kaWdlc3RJbnRvKG8pLCBvO1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKG8pIHtcbiAgICAgIG8gfHwgKG8gPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSwge30pKTtcbiAgICAgIGNvbnN0IHsgb0hhc2g6IGEsIGlIYXNoOiBjLCBmaW5pc2hlZDogbCwgZGVzdHJveWVkOiBmLCBibG9ja0xlbjogdSwgb3V0cHV0TGVuOiBoIH0gPSB0aGlzO1xuICAgICAgcmV0dXJuIG8gPSBvLCBvLmZpbmlzaGVkID0gbCwgby5kZXN0cm95ZWQgPSBmLCBvLmJsb2NrTGVuID0gdSwgby5vdXRwdXRMZW4gPSBoLCBvLm9IYXNoID0gYS5fY2xvbmVJbnRvKG8ub0hhc2gpLCBvLmlIYXNoID0gYy5fY2xvbmVJbnRvKG8uaUhhc2gpLCBvO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgdGhpcy5kZXN0cm95ZWQgPSAhMCwgdGhpcy5vSGFzaC5kZXN0cm95KCksIHRoaXMuaUhhc2guZGVzdHJveSgpO1xuICAgIH1cbiAgfVxuICB0LkhNQUMgPSBuO1xuICBjb25zdCBpID0gKHMsIG8sIGEpID0+IG5ldyBuKHMsIG8pLnVwZGF0ZShhKS5kaWdlc3QoKTtcbiAgdC5obWFjID0gaSwgdC5obWFjLmNyZWF0ZSA9IChzLCBvKSA9PiBuZXcgbihzLCBvKTtcbn0pKERzKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh4dCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xueHQucGJrZGYyQXN5bmMgPSB4dC5wYmtkZjIgPSB2b2lkIDA7XG5jb25zdCBociA9IG5lLCBWdSA9IERzLCBidCA9IHRpO1xuZnVuY3Rpb24genModCwgZSwgciwgbikge1xuICBoci5kZWZhdWx0Lmhhc2godCk7XG4gIGNvbnN0IGkgPSAoMCwgYnQuY2hlY2tPcHRzKSh7IGRrTGVuOiAzMiwgYXN5bmNUaWNrOiAxMCB9LCBuKSwgeyBjOiBzLCBka0xlbjogbywgYXN5bmNUaWNrOiBhIH0gPSBpO1xuICBpZiAoaHIuZGVmYXVsdC5udW1iZXIocyksIGhyLmRlZmF1bHQubnVtYmVyKG8pLCBoci5kZWZhdWx0Lm51bWJlcihhKSwgcyA8IDEpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUEJLREYyOiBpdGVyYXRpb25zIChjKSBzaG91bGQgYmUgPj0gMVwiKTtcbiAgY29uc3QgYyA9ICgwLCBidC50b0J5dGVzKShlKSwgbCA9ICgwLCBidC50b0J5dGVzKShyKSwgZiA9IG5ldyBVaW50OEFycmF5KG8pLCB1ID0gVnUuaG1hYy5jcmVhdGUodCwgYyksIGggPSB1Ll9jbG9uZUludG8oKS51cGRhdGUobCk7XG4gIHJldHVybiB7IGM6IHMsIGRrTGVuOiBvLCBhc3luY1RpY2s6IGEsIERLOiBmLCBQUkY6IHUsIFBSRlNhbHQ6IGggfTtcbn1cbmZ1bmN0aW9uIEZzKHQsIGUsIHIsIG4sIGkpIHtcbiAgcmV0dXJuIHQuZGVzdHJveSgpLCBlLmRlc3Ryb3koKSwgbiAmJiBuLmRlc3Ryb3koKSwgaS5maWxsKDApLCByO1xufVxuZnVuY3Rpb24gR3UodCwgZSwgciwgbikge1xuICBjb25zdCB7IGM6IGksIGRrTGVuOiBzLCBESzogbywgUFJGOiBhLCBQUkZTYWx0OiBjIH0gPSB6cyh0LCBlLCByLCBuKTtcbiAgbGV0IGw7XG4gIGNvbnN0IGYgPSBuZXcgVWludDhBcnJheSg0KSwgdSA9ICgwLCBidC5jcmVhdGVWaWV3KShmKSwgaCA9IG5ldyBVaW50OEFycmF5KGEub3V0cHV0TGVuKTtcbiAgZm9yIChsZXQgZCA9IDEsIHAgPSAwOyBwIDwgczsgZCsrLCBwICs9IGEub3V0cHV0TGVuKSB7XG4gICAgY29uc3QgeSA9IG8uc3ViYXJyYXkocCwgcCArIGEub3V0cHV0TGVuKTtcbiAgICB1LnNldEludDMyKDAsIGQsICExKSwgKGwgPSBjLl9jbG9uZUludG8obCkpLnVwZGF0ZShmKS5kaWdlc3RJbnRvKGgpLCB5LnNldChoLnN1YmFycmF5KDAsIHkubGVuZ3RoKSk7XG4gICAgZm9yIChsZXQgZyA9IDE7IGcgPCBpOyBnKyspIHtcbiAgICAgIGEuX2Nsb25lSW50byhsKS51cGRhdGUoaCkuZGlnZXN0SW50byhoKTtcbiAgICAgIGZvciAobGV0IHYgPSAwOyB2IDwgeS5sZW5ndGg7IHYrKylcbiAgICAgICAgeVt2XSBePSBoW3ZdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gRnMoYSwgYywgbywgbCwgaCk7XG59XG54dC5wYmtkZjIgPSBHdTtcbmFzeW5jIGZ1bmN0aW9uIFp1KHQsIGUsIHIsIG4pIHtcbiAgY29uc3QgeyBjOiBpLCBka0xlbjogcywgYXN5bmNUaWNrOiBvLCBESzogYSwgUFJGOiBjLCBQUkZTYWx0OiBsIH0gPSB6cyh0LCBlLCByLCBuKTtcbiAgbGV0IGY7XG4gIGNvbnN0IHUgPSBuZXcgVWludDhBcnJheSg0KSwgaCA9ICgwLCBidC5jcmVhdGVWaWV3KSh1KSwgZCA9IG5ldyBVaW50OEFycmF5KGMub3V0cHV0TGVuKTtcbiAgZm9yIChsZXQgcCA9IDEsIHkgPSAwOyB5IDwgczsgcCsrLCB5ICs9IGMub3V0cHV0TGVuKSB7XG4gICAgY29uc3QgZyA9IGEuc3ViYXJyYXkoeSwgeSArIGMub3V0cHV0TGVuKTtcbiAgICBoLnNldEludDMyKDAsIHAsICExKSwgKGYgPSBsLl9jbG9uZUludG8oZikpLnVwZGF0ZSh1KS5kaWdlc3RJbnRvKGQpLCBnLnNldChkLnN1YmFycmF5KDAsIGcubGVuZ3RoKSksIGF3YWl0ICgwLCBidC5hc3luY0xvb3ApKGkgLSAxLCBvLCAodikgPT4ge1xuICAgICAgYy5fY2xvbmVJbnRvKGYpLnVwZGF0ZShkKS5kaWdlc3RJbnRvKGQpO1xuICAgICAgZm9yIChsZXQgXyA9IDA7IF8gPCBnLmxlbmd0aDsgXysrKVxuICAgICAgICBnW19dIF49IGRbX107XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIEZzKGMsIGwsIGEsIGYsIGQpO1xufVxueHQucGJrZGYyQXN5bmMgPSBadTtcbi8qISBub2JsZS1oYXNoZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmNvbnN0IHJpID0gKHQpID0+IHQgaW5zdGFuY2VvZiBVaW50OEFycmF5LCBZdSA9ICh0KSA9PiBuZXcgVWludDhBcnJheSh0LmJ1ZmZlciwgdC5ieXRlT2Zmc2V0LCB0LmJ5dGVMZW5ndGgpLCBKdSA9ICh0KSA9PiBuZXcgVWludDMyQXJyYXkodC5idWZmZXIsIHQuYnl0ZU9mZnNldCwgTWF0aC5mbG9vcih0LmJ5dGVMZW5ndGggLyA0KSksIGZ0ID0gKHQpID0+IG5ldyBEYXRhVmlldyh0LmJ1ZmZlciwgdC5ieXRlT2Zmc2V0LCB0LmJ5dGVMZW5ndGgpLCBFZSA9ICh0LCBlKSA9PiB0IDw8IDMyIC0gZSB8IHQgPj4+IGUsIEtzID0gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQzMkFycmF5KFsyODc0NTQwMjBdKS5idWZmZXIpWzBdID09PSA2ODtcbmlmICghS3MpXG4gIHRocm93IG5ldyBFcnJvcihcIk5vbiBsaXR0bGUtZW5kaWFuIGhhcmR3YXJlIGlzIG5vdCBzdXBwb3J0ZWRcIik7XG5jb25zdCBYdSA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAodCwgZSkgPT4gZS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpKTtcbmZ1bmN0aW9uIG5pKHQpIHtcbiAgaWYgKCFyaSh0KSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVaW50OEFycmF5IGV4cGVjdGVkXCIpO1xuICBsZXQgZSA9IFwiXCI7XG4gIGZvciAobGV0IHIgPSAwOyByIDwgdC5sZW5ndGg7IHIrKylcbiAgICBlICs9IFh1W3Rbcl1dO1xuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIFdzKHQpIHtcbiAgaWYgKHR5cGVvZiB0ICE9IFwic3RyaW5nXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IFwiICsgdHlwZW9mIHQpO1xuICBjb25zdCBlID0gdC5sZW5ndGg7XG4gIGlmIChlICUgMilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJwYWRkZWQgaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IHVucGFkZGVkIGhleCBvZiBsZW5ndGggXCIgKyBlKTtcbiAgY29uc3QgciA9IG5ldyBVaW50OEFycmF5KGUgLyAyKTtcbiAgZm9yIChsZXQgbiA9IDA7IG4gPCByLmxlbmd0aDsgbisrKSB7XG4gICAgY29uc3QgaSA9IG4gKiAyLCBzID0gdC5zbGljZShpLCBpICsgMiksIG8gPSBOdW1iZXIucGFyc2VJbnQocywgMTYpO1xuICAgIGlmIChOdW1iZXIuaXNOYU4obykgfHwgbyA8IDApXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGJ5dGUgc2VxdWVuY2VcIik7XG4gICAgcltuXSA9IG87XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5jb25zdCBWcyA9IGFzeW5jICgpID0+IHtcbn07XG5hc3luYyBmdW5jdGlvbiBRdSh0LCBlLCByKSB7XG4gIGxldCBuID0gRGF0ZS5ub3coKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0OyBpKyspIHtcbiAgICByKGkpO1xuICAgIGNvbnN0IHMgPSBEYXRlLm5vdygpIC0gbjtcbiAgICBzID49IDAgJiYgcyA8IGUgfHwgKGF3YWl0IFZzKCksIG4gKz0gcyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlpKHQpIHtcbiAgaWYgKHR5cGVvZiB0ICE9IFwic3RyaW5nXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKGB1dGY4VG9CeXRlcyBleHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiB0fWApO1xuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHQpKTtcbn1cbmZ1bmN0aW9uIE90KHQpIHtcbiAgaWYgKHR5cGVvZiB0ID09IFwic3RyaW5nXCIgJiYgKHQgPSBpaSh0KSksICFyaSh0KSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkIFVpbnQ4QXJyYXksIGdvdCAke3R5cGVvZiB0fWApO1xuICByZXR1cm4gdDtcbn1cbmZ1bmN0aW9uIGVyKC4uLnQpIHtcbiAgY29uc3QgZSA9IG5ldyBVaW50OEFycmF5KHQucmVkdWNlKChuLCBpKSA9PiBuICsgaS5sZW5ndGgsIDApKTtcbiAgbGV0IHIgPSAwO1xuICByZXR1cm4gdC5mb3JFYWNoKChuKSA9PiB7XG4gICAgaWYgKCFyaShuKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVpbnQ4QXJyYXkgZXhwZWN0ZWRcIik7XG4gICAgZS5zZXQobiwgciksIHIgKz0gbi5sZW5ndGg7XG4gIH0pLCBlO1xufVxuY2xhc3Mgb2kge1xuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2xvbmVJbnRvKCk7XG4gIH1cbn1cbmNvbnN0IGVsID0gKHQpID0+IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIiAmJiB0LmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG5mdW5jdGlvbiB0bCh0LCBlKSB7XG4gIGlmIChlICE9PSB2b2lkIDAgJiYgKHR5cGVvZiBlICE9IFwib2JqZWN0XCIgfHwgIWVsKGUpKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJPcHRpb25zIHNob3VsZCBiZSBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpO1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih0LCBlKTtcbn1cbmZ1bmN0aW9uIG50KHQpIHtcbiAgY29uc3QgZSA9IChuKSA9PiB0KCkudXBkYXRlKE90KG4pKS5kaWdlc3QoKSwgciA9IHQoKTtcbiAgcmV0dXJuIGUub3V0cHV0TGVuID0gci5vdXRwdXRMZW4sIGUuYmxvY2tMZW4gPSByLmJsb2NrTGVuLCBlLmNyZWF0ZSA9ICgpID0+IHQoKSwgZTtcbn1cbmZ1bmN0aW9uIHJsKHQpIHtcbiAgY29uc3QgZSA9IChuLCBpKSA9PiB0KGkpLnVwZGF0ZShPdChuKSkuZGlnZXN0KCksIHIgPSB0KHt9KTtcbiAgcmV0dXJuIGUub3V0cHV0TGVuID0gci5vdXRwdXRMZW4sIGUuYmxvY2tMZW4gPSByLmJsb2NrTGVuLCBlLmNyZWF0ZSA9IChuKSA9PiB0KG4pLCBlO1xufVxuZnVuY3Rpb24gbmwodCkge1xuICBjb25zdCBlID0gKG4sIGkpID0+IHQoaSkudXBkYXRlKE90KG4pKS5kaWdlc3QoKSwgciA9IHQoe30pO1xuICByZXR1cm4gZS5vdXRwdXRMZW4gPSByLm91dHB1dExlbiwgZS5ibG9ja0xlbiA9IHIuYmxvY2tMZW4sIGUuY3JlYXRlID0gKG4pID0+IHQobiksIGU7XG59XG5mdW5jdGlvbiBpbCh0ID0gMzIpIHtcbiAgaWYgKFNyICYmIHR5cGVvZiBTci5nZXRSYW5kb21WYWx1ZXMgPT0gXCJmdW5jdGlvblwiKVxuICAgIHJldHVybiBTci5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkodCkpO1xuICB0aHJvdyBuZXcgRXJyb3IoXCJjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIG11c3QgYmUgZGVmaW5lZFwiKTtcbn1cbmNvbnN0IG9sID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoLyogQF9fUFVSRV9fICovIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgdTg6IFl1LFxuICB1MzI6IEp1LFxuICBjcmVhdGVWaWV3OiBmdCxcbiAgcm90cjogRWUsXG4gIGlzTEU6IEtzLFxuICBieXRlc1RvSGV4OiBuaSxcbiAgaGV4VG9CeXRlczogV3MsXG4gIG5leHRUaWNrOiBWcyxcbiAgYXN5bmNMb29wOiBRdSxcbiAgdXRmOFRvQnl0ZXM6IGlpLFxuICB0b0J5dGVzOiBPdCxcbiAgY29uY2F0Qnl0ZXM6IGVyLFxuICBIYXNoOiBvaSxcbiAgY2hlY2tPcHRzOiB0bCxcbiAgd3JhcENvbnN0cnVjdG9yOiBudCxcbiAgd3JhcENvbnN0cnVjdG9yV2l0aE9wdHM6IHJsLFxuICB3cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0czogbmwsXG4gIHJhbmRvbUJ5dGVzOiBpbFxufSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pKTtcbmZ1bmN0aW9uIHNsKHQsIGUsIHIsIG4pIHtcbiAgaWYgKHR5cGVvZiB0LnNldEJpZ1VpbnQ2NCA9PSBcImZ1bmN0aW9uXCIpXG4gICAgcmV0dXJuIHQuc2V0QmlnVWludDY0KGUsIHIsIG4pO1xuICBjb25zdCBpID0gQmlnSW50KDMyKSwgcyA9IEJpZ0ludCg0Mjk0OTY3Mjk1KSwgbyA9IE51bWJlcihyID4+IGkgJiBzKSwgYSA9IE51bWJlcihyICYgcyksIGMgPSBuID8gNCA6IDAsIGwgPSBuID8gMCA6IDQ7XG4gIHQuc2V0VWludDMyKGUgKyBjLCBvLCBuKSwgdC5zZXRVaW50MzIoZSArIGwsIGEsIG4pO1xufVxuY2xhc3Mgc2kgZXh0ZW5kcyBvaSB7XG4gIGNvbnN0cnVjdG9yKGUsIHIsIG4sIGkpIHtcbiAgICBzdXBlcigpLCB0aGlzLmJsb2NrTGVuID0gZSwgdGhpcy5vdXRwdXRMZW4gPSByLCB0aGlzLnBhZE9mZnNldCA9IG4sIHRoaXMuaXNMRSA9IGksIHRoaXMuZmluaXNoZWQgPSAhMSwgdGhpcy5sZW5ndGggPSAwLCB0aGlzLnBvcyA9IDAsIHRoaXMuZGVzdHJveWVkID0gITEsIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoZSksIHRoaXMudmlldyA9IGZ0KHRoaXMuYnVmZmVyKTtcbiAgfVxuICB1cGRhdGUoZSkge1xuICAgIFFlLmV4aXN0cyh0aGlzKTtcbiAgICBjb25zdCB7IHZpZXc6IHIsIGJ1ZmZlcjogbiwgYmxvY2tMZW46IGkgfSA9IHRoaXM7XG4gICAgZSA9IE90KGUpO1xuICAgIGNvbnN0IHMgPSBlLmxlbmd0aDtcbiAgICBmb3IgKGxldCBvID0gMDsgbyA8IHM7ICkge1xuICAgICAgY29uc3QgYSA9IE1hdGgubWluKGkgLSB0aGlzLnBvcywgcyAtIG8pO1xuICAgICAgaWYgKGEgPT09IGkpIHtcbiAgICAgICAgY29uc3QgYyA9IGZ0KGUpO1xuICAgICAgICBmb3IgKDsgaSA8PSBzIC0gbzsgbyArPSBpKVxuICAgICAgICAgIHRoaXMucHJvY2VzcyhjLCBvKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBuLnNldChlLnN1YmFycmF5KG8sIG8gKyBhKSwgdGhpcy5wb3MpLCB0aGlzLnBvcyArPSBhLCBvICs9IGEsIHRoaXMucG9zID09PSBpICYmICh0aGlzLnByb2Nlc3MociwgMCksIHRoaXMucG9zID0gMCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxlbmd0aCArPSBlLmxlbmd0aCwgdGhpcy5yb3VuZENsZWFuKCksIHRoaXM7XG4gIH1cbiAgZGlnZXN0SW50byhlKSB7XG4gICAgUWUuZXhpc3RzKHRoaXMpLCBRZS5vdXRwdXQoZSwgdGhpcyksIHRoaXMuZmluaXNoZWQgPSAhMDtcbiAgICBjb25zdCB7IGJ1ZmZlcjogciwgdmlldzogbiwgYmxvY2tMZW46IGksIGlzTEU6IHMgfSA9IHRoaXM7XG4gICAgbGV0IHsgcG9zOiBvIH0gPSB0aGlzO1xuICAgIHJbbysrXSA9IDEyOCwgdGhpcy5idWZmZXIuc3ViYXJyYXkobykuZmlsbCgwKSwgdGhpcy5wYWRPZmZzZXQgPiBpIC0gbyAmJiAodGhpcy5wcm9jZXNzKG4sIDApLCBvID0gMCk7XG4gICAgZm9yIChsZXQgdSA9IG87IHUgPCBpOyB1KyspXG4gICAgICByW3VdID0gMDtcbiAgICBzbChuLCBpIC0gOCwgQmlnSW50KHRoaXMubGVuZ3RoICogOCksIHMpLCB0aGlzLnByb2Nlc3MobiwgMCk7XG4gICAgY29uc3QgYSA9IGZ0KGUpLCBjID0gdGhpcy5vdXRwdXRMZW47XG4gICAgaWYgKGMgJSA0KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiX3NoYTI6IG91dHB1dExlbiBzaG91bGQgYmUgYWxpZ25lZCB0byAzMmJpdFwiKTtcbiAgICBjb25zdCBsID0gYyAvIDQsIGYgPSB0aGlzLmdldCgpO1xuICAgIGlmIChsID4gZi5sZW5ndGgpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJfc2hhMjogb3V0cHV0TGVuIGJpZ2dlciB0aGFuIHN0YXRlXCIpO1xuICAgIGZvciAobGV0IHUgPSAwOyB1IDwgbDsgdSsrKVxuICAgICAgYS5zZXRVaW50MzIoNCAqIHUsIGZbdV0sIHMpO1xuICB9XG4gIGRpZ2VzdCgpIHtcbiAgICBjb25zdCB7IGJ1ZmZlcjogZSwgb3V0cHV0TGVuOiByIH0gPSB0aGlzO1xuICAgIHRoaXMuZGlnZXN0SW50byhlKTtcbiAgICBjb25zdCBuID0gZS5zbGljZSgwLCByKTtcbiAgICByZXR1cm4gdGhpcy5kZXN0cm95KCksIG47XG4gIH1cbiAgX2Nsb25lSW50byhlKSB7XG4gICAgZSB8fCAoZSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkpLCBlLnNldCguLi50aGlzLmdldCgpKTtcbiAgICBjb25zdCB7IGJsb2NrTGVuOiByLCBidWZmZXI6IG4sIGxlbmd0aDogaSwgZmluaXNoZWQ6IHMsIGRlc3Ryb3llZDogbywgcG9zOiBhIH0gPSB0aGlzO1xuICAgIHJldHVybiBlLmxlbmd0aCA9IGksIGUucG9zID0gYSwgZS5maW5pc2hlZCA9IHMsIGUuZGVzdHJveWVkID0gbywgaSAlIHIgJiYgZS5idWZmZXIuc2V0KG4pLCBlO1xuICB9XG59XG5jb25zdCBhbCA9ICh0LCBlLCByKSA9PiB0ICYgZSBeIH50ICYgciwgY2wgPSAodCwgZSwgcikgPT4gdCAmIGUgXiB0ICYgciBeIGUgJiByLCB1bCA9IG5ldyBVaW50MzJBcnJheShbXG4gIDExMTYzNTI0MDgsXG4gIDE4OTk0NDc0NDEsXG4gIDMwNDkzMjM0NzEsXG4gIDM5MjEwMDk1NzMsXG4gIDk2MTk4NzE2MyxcbiAgMTUwODk3MDk5MyxcbiAgMjQ1MzYzNTc0OCxcbiAgMjg3MDc2MzIyMSxcbiAgMzYyNDM4MTA4MCxcbiAgMzEwNTk4NDAxLFxuICA2MDcyMjUyNzgsXG4gIDE0MjY4ODE5ODcsXG4gIDE5MjUwNzgzODgsXG4gIDIxNjIwNzgyMDYsXG4gIDI2MTQ4ODgxMDMsXG4gIDMyNDgyMjI1ODAsXG4gIDM4MzUzOTA0MDEsXG4gIDQwMjIyMjQ3NzQsXG4gIDI2NDM0NzA3OCxcbiAgNjA0ODA3NjI4LFxuICA3NzAyNTU5ODMsXG4gIDEyNDkxNTAxMjIsXG4gIDE1NTUwODE2OTIsXG4gIDE5OTYwNjQ5ODYsXG4gIDI1NTQyMjA4ODIsXG4gIDI4MjE4MzQzNDksXG4gIDI5NTI5OTY4MDgsXG4gIDMyMTAzMTM2NzEsXG4gIDMzMzY1NzE4OTEsXG4gIDM1ODQ1Mjg3MTEsXG4gIDExMzkyNjk5MyxcbiAgMzM4MjQxODk1LFxuICA2NjYzMDcyMDUsXG4gIDc3MzUyOTkxMixcbiAgMTI5NDc1NzM3MixcbiAgMTM5NjE4MjI5MSxcbiAgMTY5NTE4MzcwMCxcbiAgMTk4NjY2MTA1MSxcbiAgMjE3NzAyNjM1MCxcbiAgMjQ1Njk1NjAzNyxcbiAgMjczMDQ4NTkyMSxcbiAgMjgyMDMwMjQxMSxcbiAgMzI1OTczMDgwMCxcbiAgMzM0NTc2NDc3MSxcbiAgMzUxNjA2NTgxNyxcbiAgMzYwMDM1MjgwNCxcbiAgNDA5NDU3MTkwOSxcbiAgMjc1NDIzMzQ0LFxuICA0MzAyMjc3MzQsXG4gIDUwNjk0ODYxNixcbiAgNjU5MDYwNTU2LFxuICA4ODM5OTc4NzcsXG4gIDk1ODEzOTU3MSxcbiAgMTMyMjgyMjIxOCxcbiAgMTUzNzAwMjA2MyxcbiAgMTc0Nzg3Mzc3OSxcbiAgMTk1NTU2MjIyMixcbiAgMjAyNDEwNDgxNSxcbiAgMjIyNzczMDQ1MixcbiAgMjM2MTg1MjQyNCxcbiAgMjQyODQzNjQ3NCxcbiAgMjc1NjczNDE4NyxcbiAgMzIwNDAzMTQ3OSxcbiAgMzMyOTMyNTI5OFxuXSksIEtlID0gbmV3IFVpbnQzMkFycmF5KFtcbiAgMTc3OTAzMzcwMyxcbiAgMzE0NDEzNDI3NyxcbiAgMTAxMzkwNDI0MixcbiAgMjc3MzQ4MDc2MixcbiAgMTM1OTg5MzExOSxcbiAgMjYwMDgyMjkyNCxcbiAgNTI4NzM0NjM1LFxuICAxNTQxNDU5MjI1XG5dKSwgV2UgPSBuZXcgVWludDMyQXJyYXkoNjQpO1xuY2xhc3MgR3MgZXh0ZW5kcyBzaSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKDY0LCAzMiwgOCwgITEpLCB0aGlzLkEgPSBLZVswXSB8IDAsIHRoaXMuQiA9IEtlWzFdIHwgMCwgdGhpcy5DID0gS2VbMl0gfCAwLCB0aGlzLkQgPSBLZVszXSB8IDAsIHRoaXMuRSA9IEtlWzRdIHwgMCwgdGhpcy5GID0gS2VbNV0gfCAwLCB0aGlzLkcgPSBLZVs2XSB8IDAsIHRoaXMuSCA9IEtlWzddIHwgMDtcbiAgfVxuICBnZXQoKSB7XG4gICAgY29uc3QgeyBBOiBlLCBCOiByLCBDOiBuLCBEOiBpLCBFOiBzLCBGOiBvLCBHOiBhLCBIOiBjIH0gPSB0aGlzO1xuICAgIHJldHVybiBbZSwgciwgbiwgaSwgcywgbywgYSwgY107XG4gIH1cbiAgc2V0KGUsIHIsIG4sIGksIHMsIG8sIGEsIGMpIHtcbiAgICB0aGlzLkEgPSBlIHwgMCwgdGhpcy5CID0gciB8IDAsIHRoaXMuQyA9IG4gfCAwLCB0aGlzLkQgPSBpIHwgMCwgdGhpcy5FID0gcyB8IDAsIHRoaXMuRiA9IG8gfCAwLCB0aGlzLkcgPSBhIHwgMCwgdGhpcy5IID0gYyB8IDA7XG4gIH1cbiAgcHJvY2VzcyhlLCByKSB7XG4gICAgZm9yIChsZXQgdSA9IDA7IHUgPCAxNjsgdSsrLCByICs9IDQpXG4gICAgICBXZVt1XSA9IGUuZ2V0VWludDMyKHIsICExKTtcbiAgICBmb3IgKGxldCB1ID0gMTY7IHUgPCA2NDsgdSsrKSB7XG4gICAgICBjb25zdCBoID0gV2VbdSAtIDE1XSwgZCA9IFdlW3UgLSAyXSwgcCA9IEVlKGgsIDcpIF4gRWUoaCwgMTgpIF4gaCA+Pj4gMywgeSA9IEVlKGQsIDE3KSBeIEVlKGQsIDE5KSBeIGQgPj4+IDEwO1xuICAgICAgV2VbdV0gPSB5ICsgV2VbdSAtIDddICsgcCArIFdlW3UgLSAxNl0gfCAwO1xuICAgIH1cbiAgICBsZXQgeyBBOiBuLCBCOiBpLCBDOiBzLCBEOiBvLCBFOiBhLCBGOiBjLCBHOiBsLCBIOiBmIH0gPSB0aGlzO1xuICAgIGZvciAobGV0IHUgPSAwOyB1IDwgNjQ7IHUrKykge1xuICAgICAgY29uc3QgaCA9IEVlKGEsIDYpIF4gRWUoYSwgMTEpIF4gRWUoYSwgMjUpLCBkID0gZiArIGggKyBhbChhLCBjLCBsKSArIHVsW3VdICsgV2VbdV0gfCAwLCB5ID0gKEVlKG4sIDIpIF4gRWUobiwgMTMpIF4gRWUobiwgMjIpKSArIGNsKG4sIGksIHMpIHwgMDtcbiAgICAgIGYgPSBsLCBsID0gYywgYyA9IGEsIGEgPSBvICsgZCB8IDAsIG8gPSBzLCBzID0gaSwgaSA9IG4sIG4gPSBkICsgeSB8IDA7XG4gICAgfVxuICAgIG4gPSBuICsgdGhpcy5BIHwgMCwgaSA9IGkgKyB0aGlzLkIgfCAwLCBzID0gcyArIHRoaXMuQyB8IDAsIG8gPSBvICsgdGhpcy5EIHwgMCwgYSA9IGEgKyB0aGlzLkUgfCAwLCBjID0gYyArIHRoaXMuRiB8IDAsIGwgPSBsICsgdGhpcy5HIHwgMCwgZiA9IGYgKyB0aGlzLkggfCAwLCB0aGlzLnNldChuLCBpLCBzLCBvLCBhLCBjLCBsLCBmKTtcbiAgfVxuICByb3VuZENsZWFuKCkge1xuICAgIFdlLmZpbGwoMCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKSwgdGhpcy5idWZmZXIuZmlsbCgwKTtcbiAgfVxufVxuY2xhc3MgbGwgZXh0ZW5kcyBHcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCksIHRoaXMuQSA9IC0xMDU2NTk2MjY0LCB0aGlzLkIgPSA5MTQxNTA2NjMsIHRoaXMuQyA9IDgxMjcwMjk5OSwgdGhpcy5EID0gLTE1MDA1NDU5OSwgdGhpcy5FID0gLTQxOTE0MzksIHRoaXMuRiA9IDE3NTA2MDMwMjUsIHRoaXMuRyA9IDE2OTQwNzY4MzksIHRoaXMuSCA9IC0xMDkwODkxODY4LCB0aGlzLm91dHB1dExlbiA9IDI4O1xuICB9XG59XG5jb25zdCBqciA9IG50KCgpID0+IG5ldyBHcygpKSwgZmwgPSBudCgoKSA9PiBuZXcgbGwoKSksIGhsID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoLyogQF9fUFVSRV9fICovIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgc2hhMjU2OiBqcixcbiAgc2hhMjI0OiBmbFxufSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pKSwgZGwgPSAvKiBAX19QVVJFX18gKi8gRXQoaGwpLCBkciA9IEJpZ0ludCgyICoqIDMyIC0gMSksICRuID0gQmlnSW50KDMyKTtcbmZ1bmN0aW9uIFpzKHQsIGUgPSAhMSkge1xuICByZXR1cm4gZSA/IHsgaDogTnVtYmVyKHQgJiBkciksIGw6IE51bWJlcih0ID4+ICRuICYgZHIpIH0gOiB7IGg6IE51bWJlcih0ID4+ICRuICYgZHIpIHwgMCwgbDogTnVtYmVyKHQgJiBkcikgfCAwIH07XG59XG5mdW5jdGlvbiBwbCh0LCBlID0gITEpIHtcbiAgbGV0IHIgPSBuZXcgVWludDMyQXJyYXkodC5sZW5ndGgpLCBuID0gbmV3IFVpbnQzMkFycmF5KHQubGVuZ3RoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgeyBoOiBzLCBsOiBvIH0gPSBacyh0W2ldLCBlKTtcbiAgICBbcltpXSwgbltpXV0gPSBbcywgb107XG4gIH1cbiAgcmV0dXJuIFtyLCBuXTtcbn1cbmNvbnN0IHlsID0gKHQsIGUpID0+IEJpZ0ludCh0ID4+PiAwKSA8PCAkbiB8IEJpZ0ludChlID4+PiAwKSwgZ2wgPSAodCwgZSwgcikgPT4gdCA+Pj4gciwgYmwgPSAodCwgZSwgcikgPT4gdCA8PCAzMiAtIHIgfCBlID4+PiByLCB2bCA9ICh0LCBlLCByKSA9PiB0ID4+PiByIHwgZSA8PCAzMiAtIHIsIHdsID0gKHQsIGUsIHIpID0+IHQgPDwgMzIgLSByIHwgZSA+Pj4gciwgX2wgPSAodCwgZSwgcikgPT4gdCA8PCA2NCAtIHIgfCBlID4+PiByIC0gMzIsIG1sID0gKHQsIGUsIHIpID0+IHQgPj4+IHIgLSAzMiB8IGUgPDwgNjQgLSByLCB4bCA9ICh0LCBlKSA9PiBlLCBFbCA9ICh0LCBlKSA9PiB0LCBrbCA9ICh0LCBlLCByKSA9PiB0IDw8IHIgfCBlID4+PiAzMiAtIHIsIFNsID0gKHQsIGUsIHIpID0+IGUgPDwgciB8IHQgPj4+IDMyIC0gciwgT2wgPSAodCwgZSwgcikgPT4gZSA8PCByIC0gMzIgfCB0ID4+PiA2NCAtIHIsIEFsID0gKHQsIGUsIHIpID0+IHQgPDwgciAtIDMyIHwgZSA+Pj4gNjQgLSByO1xuZnVuY3Rpb24gQ2wodCwgZSwgciwgbikge1xuICBjb25zdCBpID0gKGUgPj4+IDApICsgKG4gPj4+IDApO1xuICByZXR1cm4geyBoOiB0ICsgciArIChpIC8gMiAqKiAzMiB8IDApIHwgMCwgbDogaSB8IDAgfTtcbn1cbmNvbnN0IElsID0gKHQsIGUsIHIpID0+ICh0ID4+PiAwKSArIChlID4+PiAwKSArIChyID4+PiAwKSwgUmwgPSAodCwgZSwgciwgbikgPT4gZSArIHIgKyBuICsgKHQgLyAyICoqIDMyIHwgMCkgfCAwLCBUbCA9ICh0LCBlLCByLCBuKSA9PiAodCA+Pj4gMCkgKyAoZSA+Pj4gMCkgKyAociA+Pj4gMCkgKyAobiA+Pj4gMCksIFBsID0gKHQsIGUsIHIsIG4sIGkpID0+IGUgKyByICsgbiArIGkgKyAodCAvIDIgKiogMzIgfCAwKSB8IDAsIEJsID0gKHQsIGUsIHIsIG4sIGkpID0+ICh0ID4+PiAwKSArIChlID4+PiAwKSArIChyID4+PiAwKSArIChuID4+PiAwKSArIChpID4+PiAwKSwgTGwgPSAodCwgZSwgciwgbiwgaSwgcykgPT4gZSArIHIgKyBuICsgaSArIHMgKyAodCAvIDIgKiogMzIgfCAwKSB8IDAsIE4gPSB7XG4gIGZyb21CaWc6IFpzLFxuICBzcGxpdDogcGwsXG4gIHRvQmlnOiB5bCxcbiAgc2hyU0g6IGdsLFxuICBzaHJTTDogYmwsXG4gIHJvdHJTSDogdmwsXG4gIHJvdHJTTDogd2wsXG4gIHJvdHJCSDogX2wsXG4gIHJvdHJCTDogbWwsXG4gIHJvdHIzMkg6IHhsLFxuICByb3RyMzJMOiBFbCxcbiAgcm90bFNIOiBrbCxcbiAgcm90bFNMOiBTbCxcbiAgcm90bEJIOiBPbCxcbiAgcm90bEJMOiBBbCxcbiAgYWRkOiBDbCxcbiAgYWRkM0w6IElsLFxuICBhZGQzSDogUmwsXG4gIGFkZDRMOiBUbCxcbiAgYWRkNEg6IFBsLFxuICBhZGQ1SDogTGwsXG4gIGFkZDVMOiBCbFxufSwgWyRsLCBxbF0gPSBOLnNwbGl0KFtcbiAgXCIweDQyOGEyZjk4ZDcyOGFlMjJcIixcbiAgXCIweDcxMzc0NDkxMjNlZjY1Y2RcIixcbiAgXCIweGI1YzBmYmNmZWM0ZDNiMmZcIixcbiAgXCIweGU5YjVkYmE1ODE4OWRiYmNcIixcbiAgXCIweDM5NTZjMjViZjM0OGI1MzhcIixcbiAgXCIweDU5ZjExMWYxYjYwNWQwMTlcIixcbiAgXCIweDkyM2Y4MmE0YWYxOTRmOWJcIixcbiAgXCIweGFiMWM1ZWQ1ZGE2ZDgxMThcIixcbiAgXCIweGQ4MDdhYTk4YTMwMzAyNDJcIixcbiAgXCIweDEyODM1YjAxNDU3MDZmYmVcIixcbiAgXCIweDI0MzE4NWJlNGVlNGIyOGNcIixcbiAgXCIweDU1MGM3ZGMzZDVmZmI0ZTJcIixcbiAgXCIweDcyYmU1ZDc0ZjI3Yjg5NmZcIixcbiAgXCIweDgwZGViMWZlM2IxNjk2YjFcIixcbiAgXCIweDliZGMwNmE3MjVjNzEyMzVcIixcbiAgXCIweGMxOWJmMTc0Y2Y2OTI2OTRcIixcbiAgXCIweGU0OWI2OWMxOWVmMTRhZDJcIixcbiAgXCIweGVmYmU0Nzg2Mzg0ZjI1ZTNcIixcbiAgXCIweDBmYzE5ZGM2OGI4Y2Q1YjVcIixcbiAgXCIweDI0MGNhMWNjNzdhYzljNjVcIixcbiAgXCIweDJkZTkyYzZmNTkyYjAyNzVcIixcbiAgXCIweDRhNzQ4NGFhNmVhNmU0ODNcIixcbiAgXCIweDVjYjBhOWRjYmQ0MWZiZDRcIixcbiAgXCIweDc2Zjk4OGRhODMxMTUzYjVcIixcbiAgXCIweDk4M2U1MTUyZWU2NmRmYWJcIixcbiAgXCIweGE4MzFjNjZkMmRiNDMyMTBcIixcbiAgXCIweGIwMDMyN2M4OThmYjIxM2ZcIixcbiAgXCIweGJmNTk3ZmM3YmVlZjBlZTRcIixcbiAgXCIweGM2ZTAwYmYzM2RhODhmYzJcIixcbiAgXCIweGQ1YTc5MTQ3OTMwYWE3MjVcIixcbiAgXCIweDA2Y2E2MzUxZTAwMzgyNmZcIixcbiAgXCIweDE0MjkyOTY3MGEwZTZlNzBcIixcbiAgXCIweDI3YjcwYTg1NDZkMjJmZmNcIixcbiAgXCIweDJlMWIyMTM4NWMyNmM5MjZcIixcbiAgXCIweDRkMmM2ZGZjNWFjNDJhZWRcIixcbiAgXCIweDUzMzgwZDEzOWQ5NWIzZGZcIixcbiAgXCIweDY1MGE3MzU0OGJhZjYzZGVcIixcbiAgXCIweDc2NmEwYWJiM2M3N2IyYThcIixcbiAgXCIweDgxYzJjOTJlNDdlZGFlZTZcIixcbiAgXCIweDkyNzIyYzg1MTQ4MjM1M2JcIixcbiAgXCIweGEyYmZlOGExNGNmMTAzNjRcIixcbiAgXCIweGE4MWE2NjRiYmM0MjMwMDFcIixcbiAgXCIweGMyNGI4YjcwZDBmODk3OTFcIixcbiAgXCIweGM3NmM1MWEzMDY1NGJlMzBcIixcbiAgXCIweGQxOTJlODE5ZDZlZjUyMThcIixcbiAgXCIweGQ2OTkwNjI0NTU2NWE5MTBcIixcbiAgXCIweGY0MGUzNTg1NTc3MTIwMmFcIixcbiAgXCIweDEwNmFhMDcwMzJiYmQxYjhcIixcbiAgXCIweDE5YTRjMTE2YjhkMmQwYzhcIixcbiAgXCIweDFlMzc2YzA4NTE0MWFiNTNcIixcbiAgXCIweDI3NDg3NzRjZGY4ZWViOTlcIixcbiAgXCIweDM0YjBiY2I1ZTE5YjQ4YThcIixcbiAgXCIweDM5MWMwY2IzYzVjOTVhNjNcIixcbiAgXCIweDRlZDhhYTRhZTM0MThhY2JcIixcbiAgXCIweDViOWNjYTRmNzc2M2UzNzNcIixcbiAgXCIweDY4MmU2ZmYzZDZiMmI4YTNcIixcbiAgXCIweDc0OGY4MmVlNWRlZmIyZmNcIixcbiAgXCIweDc4YTU2MzZmNDMxNzJmNjBcIixcbiAgXCIweDg0Yzg3ODE0YTFmMGFiNzJcIixcbiAgXCIweDhjYzcwMjA4MWE2NDM5ZWNcIixcbiAgXCIweDkwYmVmZmZhMjM2MzFlMjhcIixcbiAgXCIweGE0NTA2Y2ViZGU4MmJkZTlcIixcbiAgXCIweGJlZjlhM2Y3YjJjNjc5MTVcIixcbiAgXCIweGM2NzE3OGYyZTM3MjUzMmJcIixcbiAgXCIweGNhMjczZWNlZWEyNjYxOWNcIixcbiAgXCIweGQxODZiOGM3MjFjMGMyMDdcIixcbiAgXCIweGVhZGE3ZGQ2Y2RlMGViMWVcIixcbiAgXCIweGY1N2Q0ZjdmZWU2ZWQxNzhcIixcbiAgXCIweDA2ZjA2N2FhNzIxNzZmYmFcIixcbiAgXCIweDBhNjM3ZGM1YTJjODk4YTZcIixcbiAgXCIweDExM2Y5ODA0YmVmOTBkYWVcIixcbiAgXCIweDFiNzEwYjM1MTMxYzQ3MWJcIixcbiAgXCIweDI4ZGI3N2Y1MjMwNDdkODRcIixcbiAgXCIweDMyY2FhYjdiNDBjNzI0OTNcIixcbiAgXCIweDNjOWViZTBhMTVjOWJlYmNcIixcbiAgXCIweDQzMWQ2N2M0OWMxMDBkNGNcIixcbiAgXCIweDRjYzVkNGJlY2IzZTQyYjZcIixcbiAgXCIweDU5N2YyOTljZmM2NTdlMmFcIixcbiAgXCIweDVmY2I2ZmFiM2FkNmZhZWNcIixcbiAgXCIweDZjNDQxOThjNGE0NzU4MTdcIlxuXS5tYXAoKHQpID0+IEJpZ0ludCh0KSkpLCBWZSA9IG5ldyBVaW50MzJBcnJheSg4MCksIEdlID0gbmV3IFVpbnQzMkFycmF5KDgwKTtcbmNsYXNzIGFyIGV4dGVuZHMgc2kge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigxMjgsIDY0LCAxNiwgITEpLCB0aGlzLkFoID0gMTc3OTAzMzcwMywgdGhpcy5BbCA9IC0yMDU3MzE1NzYsIHRoaXMuQmggPSAtMTE1MDgzMzAxOSwgdGhpcy5CbCA9IC0yMDY3MDkzNzAxLCB0aGlzLkNoID0gMTAxMzkwNDI0MiwgdGhpcy5DbCA9IC0yMzc5MTU3MywgdGhpcy5EaCA9IC0xNTIxNDg2NTM0LCB0aGlzLkRsID0gMTU5NTc1MDEyOSwgdGhpcy5FaCA9IDEzNTk4OTMxMTksIHRoaXMuRWwgPSAtMTM3NzQwMjE1OSwgdGhpcy5GaCA9IC0xNjk0MTQ0MzcyLCB0aGlzLkZsID0gNzI1NTExMTk5LCB0aGlzLkdoID0gNTI4NzM0NjM1LCB0aGlzLkdsID0gLTc5NTc3NzQ5LCB0aGlzLkhoID0gMTU0MTQ1OTIyNSwgdGhpcy5IbCA9IDMyNzAzMzIwOTtcbiAgfVxuICBnZXQoKSB7XG4gICAgY29uc3QgeyBBaDogZSwgQWw6IHIsIEJoOiBuLCBCbDogaSwgQ2g6IHMsIENsOiBvLCBEaDogYSwgRGw6IGMsIEVoOiBsLCBFbDogZiwgRmg6IHUsIEZsOiBoLCBHaDogZCwgR2w6IHAsIEhoOiB5LCBIbDogZyB9ID0gdGhpcztcbiAgICByZXR1cm4gW2UsIHIsIG4sIGksIHMsIG8sIGEsIGMsIGwsIGYsIHUsIGgsIGQsIHAsIHksIGddO1xuICB9XG4gIHNldChlLCByLCBuLCBpLCBzLCBvLCBhLCBjLCBsLCBmLCB1LCBoLCBkLCBwLCB5LCBnKSB7XG4gICAgdGhpcy5BaCA9IGUgfCAwLCB0aGlzLkFsID0gciB8IDAsIHRoaXMuQmggPSBuIHwgMCwgdGhpcy5CbCA9IGkgfCAwLCB0aGlzLkNoID0gcyB8IDAsIHRoaXMuQ2wgPSBvIHwgMCwgdGhpcy5EaCA9IGEgfCAwLCB0aGlzLkRsID0gYyB8IDAsIHRoaXMuRWggPSBsIHwgMCwgdGhpcy5FbCA9IGYgfCAwLCB0aGlzLkZoID0gdSB8IDAsIHRoaXMuRmwgPSBoIHwgMCwgdGhpcy5HaCA9IGQgfCAwLCB0aGlzLkdsID0gcCB8IDAsIHRoaXMuSGggPSB5IHwgMCwgdGhpcy5IbCA9IGcgfCAwO1xuICB9XG4gIHByb2Nlc3MoZSwgcikge1xuICAgIGZvciAobGV0IG0gPSAwOyBtIDwgMTY7IG0rKywgciArPSA0KVxuICAgICAgVmVbbV0gPSBlLmdldFVpbnQzMihyKSwgR2VbbV0gPSBlLmdldFVpbnQzMihyICs9IDQpO1xuICAgIGZvciAobGV0IG0gPSAxNjsgbSA8IDgwOyBtKyspIHtcbiAgICAgIGNvbnN0IEMgPSBWZVttIC0gMTVdIHwgMCwgTyA9IEdlW20gLSAxNV0gfCAwLCB3ID0gTi5yb3RyU0goQywgTywgMSkgXiBOLnJvdHJTSChDLCBPLCA4KSBeIE4uc2hyU0goQywgTywgNyksIHggPSBOLnJvdHJTTChDLCBPLCAxKSBeIE4ucm90clNMKEMsIE8sIDgpIF4gTi5zaHJTTChDLCBPLCA3KSwgQSA9IFZlW20gLSAyXSB8IDAsIEIgPSBHZVttIC0gMl0gfCAwLCBMID0gTi5yb3RyU0goQSwgQiwgMTkpIF4gTi5yb3RyQkgoQSwgQiwgNjEpIF4gTi5zaHJTSChBLCBCLCA2KSwgUCA9IE4ucm90clNMKEEsIEIsIDE5KSBeIE4ucm90ckJMKEEsIEIsIDYxKSBeIE4uc2hyU0woQSwgQiwgNiksIEYgPSBOLmFkZDRMKHgsIFAsIEdlW20gLSA3XSwgR2VbbSAtIDE2XSksIHogPSBOLmFkZDRIKEYsIHcsIEwsIFZlW20gLSA3XSwgVmVbbSAtIDE2XSk7XG4gICAgICBWZVttXSA9IHogfCAwLCBHZVttXSA9IEYgfCAwO1xuICAgIH1cbiAgICBsZXQgeyBBaDogbiwgQWw6IGksIEJoOiBzLCBCbDogbywgQ2g6IGEsIENsOiBjLCBEaDogbCwgRGw6IGYsIEVoOiB1LCBFbDogaCwgRmg6IGQsIEZsOiBwLCBHaDogeSwgR2w6IGcsIEhoOiB2LCBIbDogXyB9ID0gdGhpcztcbiAgICBmb3IgKGxldCBtID0gMDsgbSA8IDgwOyBtKyspIHtcbiAgICAgIGNvbnN0IEMgPSBOLnJvdHJTSCh1LCBoLCAxNCkgXiBOLnJvdHJTSCh1LCBoLCAxOCkgXiBOLnJvdHJCSCh1LCBoLCA0MSksIE8gPSBOLnJvdHJTTCh1LCBoLCAxNCkgXiBOLnJvdHJTTCh1LCBoLCAxOCkgXiBOLnJvdHJCTCh1LCBoLCA0MSksIHcgPSB1ICYgZCBeIH51ICYgeSwgeCA9IGggJiBwIF4gfmggJiBnLCBBID0gTi5hZGQ1TChfLCBPLCB4LCBxbFttXSwgR2VbbV0pLCBCID0gTi5hZGQ1SChBLCB2LCBDLCB3LCAkbFttXSwgVmVbbV0pLCBMID0gQSB8IDAsIFAgPSBOLnJvdHJTSChuLCBpLCAyOCkgXiBOLnJvdHJCSChuLCBpLCAzNCkgXiBOLnJvdHJCSChuLCBpLCAzOSksIEYgPSBOLnJvdHJTTChuLCBpLCAyOCkgXiBOLnJvdHJCTChuLCBpLCAzNCkgXiBOLnJvdHJCTChuLCBpLCAzOSksIHogPSBuICYgcyBeIG4gJiBhIF4gcyAmIGEsIEcgPSBpICYgbyBeIGkgJiBjIF4gbyAmIGM7XG4gICAgICB2ID0geSB8IDAsIF8gPSBnIHwgMCwgeSA9IGQgfCAwLCBnID0gcCB8IDAsIGQgPSB1IHwgMCwgcCA9IGggfCAwLCB7IGg6IHUsIGw6IGggfSA9IE4uYWRkKGwgfCAwLCBmIHwgMCwgQiB8IDAsIEwgfCAwKSwgbCA9IGEgfCAwLCBmID0gYyB8IDAsIGEgPSBzIHwgMCwgYyA9IG8gfCAwLCBzID0gbiB8IDAsIG8gPSBpIHwgMDtcbiAgICAgIGNvbnN0IEUgPSBOLmFkZDNMKEwsIEYsIEcpO1xuICAgICAgbiA9IE4uYWRkM0goRSwgQiwgUCwgeiksIGkgPSBFIHwgMDtcbiAgICB9XG4gICAgKHsgaDogbiwgbDogaSB9ID0gTi5hZGQodGhpcy5BaCB8IDAsIHRoaXMuQWwgfCAwLCBuIHwgMCwgaSB8IDApKSwgeyBoOiBzLCBsOiBvIH0gPSBOLmFkZCh0aGlzLkJoIHwgMCwgdGhpcy5CbCB8IDAsIHMgfCAwLCBvIHwgMCksIHsgaDogYSwgbDogYyB9ID0gTi5hZGQodGhpcy5DaCB8IDAsIHRoaXMuQ2wgfCAwLCBhIHwgMCwgYyB8IDApLCB7IGg6IGwsIGw6IGYgfSA9IE4uYWRkKHRoaXMuRGggfCAwLCB0aGlzLkRsIHwgMCwgbCB8IDAsIGYgfCAwKSwgeyBoOiB1LCBsOiBoIH0gPSBOLmFkZCh0aGlzLkVoIHwgMCwgdGhpcy5FbCB8IDAsIHUgfCAwLCBoIHwgMCksIHsgaDogZCwgbDogcCB9ID0gTi5hZGQodGhpcy5GaCB8IDAsIHRoaXMuRmwgfCAwLCBkIHwgMCwgcCB8IDApLCB7IGg6IHksIGw6IGcgfSA9IE4uYWRkKHRoaXMuR2ggfCAwLCB0aGlzLkdsIHwgMCwgeSB8IDAsIGcgfCAwKSwgeyBoOiB2LCBsOiBfIH0gPSBOLmFkZCh0aGlzLkhoIHwgMCwgdGhpcy5IbCB8IDAsIHYgfCAwLCBfIHwgMCksIHRoaXMuc2V0KG4sIGksIHMsIG8sIGEsIGMsIGwsIGYsIHUsIGgsIGQsIHAsIHksIGcsIHYsIF8pO1xuICB9XG4gIHJvdW5kQ2xlYW4oKSB7XG4gICAgVmUuZmlsbCgwKSwgR2UuZmlsbCgwKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuYnVmZmVyLmZpbGwoMCksIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuICB9XG59XG5jbGFzcyBObCBleHRlbmRzIGFyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKSwgdGhpcy5BaCA9IC0xOTQyMTQ1MDgwLCB0aGlzLkFsID0gNDI0OTU1Mjk4LCB0aGlzLkJoID0gMTk0NDE2NDcxMCwgdGhpcy5CbCA9IC0xOTgyMDE2Mjk4LCB0aGlzLkNoID0gNTAyOTcwMjg2LCB0aGlzLkNsID0gODU1NjEyNTQ2LCB0aGlzLkRoID0gMTczODM5Njk0OCwgdGhpcy5EbCA9IDE0Nzk1MTYxMTEsIHRoaXMuRWggPSAyNTg4MTI3NzcsIHRoaXMuRWwgPSAyMDc3NTExMDgwLCB0aGlzLkZoID0gMjAxMTM5MzkwNywgdGhpcy5GbCA9IDc5OTg5MDU4LCB0aGlzLkdoID0gMTA2NzI4Nzk3NiwgdGhpcy5HbCA9IDE3ODAyOTk0NjQsIHRoaXMuSGggPSAyODY0NTEzNzMsIHRoaXMuSGwgPSAtMTg0ODIwODczNSwgdGhpcy5vdXRwdXRMZW4gPSAyODtcbiAgfVxufVxuY2xhc3MgVWwgZXh0ZW5kcyBhciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCksIHRoaXMuQWggPSA1NzM2NDUyMDQsIHRoaXMuQWwgPSAtNjQyMjc1NDAsIHRoaXMuQmggPSAtMTYyMTc5NDkwOSwgdGhpcy5CbCA9IC05MzQ1MTc1NjYsIHRoaXMuQ2ggPSA1OTY4ODM1NjMsIHRoaXMuQ2wgPSAxODY3NzU1ODU3LCB0aGlzLkRoID0gLTE3NzQ2ODQzOTEsIHRoaXMuRGwgPSAxNDk3NDI2NjIxLCB0aGlzLkVoID0gLTE3NzU3NDczNTgsIHRoaXMuRWwgPSAtMTQ2NzAyMzM4OSwgdGhpcy5GaCA9IC0xMTAxMTI4MTU1LCB0aGlzLkZsID0gMTQwMTMwNTQ5MCwgdGhpcy5HaCA9IDcyMTUyNTI0NCwgdGhpcy5HbCA9IDc0Njk2MTA2NiwgdGhpcy5IaCA9IDI0Njg4NTg1MiwgdGhpcy5IbCA9IC0yMTE3Nzg0NDE0LCB0aGlzLm91dHB1dExlbiA9IDMyO1xuICB9XG59XG5jbGFzcyBqbCBleHRlbmRzIGFyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKSwgdGhpcy5BaCA9IC04NzY4OTY5MzEsIHRoaXMuQWwgPSAtMTA1NjU5NjI2NCwgdGhpcy5CaCA9IDE2NTQyNzAyNTAsIHRoaXMuQmwgPSA5MTQxNTA2NjMsIHRoaXMuQ2ggPSAtMTg1NjQzNzkyNiwgdGhpcy5DbCA9IDgxMjcwMjk5OSwgdGhpcy5EaCA9IDM1NTQ2MjM2MCwgdGhpcy5EbCA9IC0xNTAwNTQ1OTksIHRoaXMuRWggPSAxNzMxNDA1NDE1LCB0aGlzLkVsID0gLTQxOTE0MzksIHRoaXMuRmggPSAtMTkwMDc4NzA2NSwgdGhpcy5GbCA9IDE3NTA2MDMwMjUsIHRoaXMuR2ggPSAtNjE5OTU4NzcxLCB0aGlzLkdsID0gMTY5NDA3NjgzOSwgdGhpcy5IaCA9IDEyMDMwNjI4MTMsIHRoaXMuSGwgPSAtMTA5MDg5MTg2OCwgdGhpcy5vdXRwdXRMZW4gPSA0ODtcbiAgfVxufVxuY29uc3QgcW4gPSBudCgoKSA9PiBuZXcgYXIoKSksIEhsID0gbnQoKCkgPT4gbmV3IE5sKCkpLCBNbCA9IG50KCgpID0+IG5ldyBVbCgpKSwgRGwgPSBudCgoKSA9PiBuZXcgamwoKSksIHpsID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoLyogQF9fUFVSRV9fICovIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgU0hBNTEyOiBhcixcbiAgc2hhNTEyOiBxbixcbiAgc2hhNTEyXzIyNDogSGwsXG4gIHNoYTUxMl8yNTY6IE1sLFxuICBzaGEzODQ6IERsXG59LCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSkpLCBGbCA9IC8qIEBfX1BVUkVfXyAqLyBFdCh6bCksIEtsID0gLyogQF9fUFVSRV9fICovIEV0KG9sKSwgV2wgPSAvKiBAX19QVVJFX18gKi8gRXQoTXUpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGRlLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG52YXIgWXMgPSBkZS5tbmVtb25pY1RvU2VlZFN5bmMgPSBkZS5tbmVtb25pY1RvU2VlZCA9IHNhID0gZGUudmFsaWRhdGVNbmVtb25pYyA9IGRlLmVudHJvcHlUb01uZW1vbmljID0gZGUubW5lbW9uaWNUb0VudHJvcHkgPSByYSA9IGRlLmdlbmVyYXRlTW5lbW9uaWMgPSB2b2lkIDA7XG4vKiEgc2N1cmUtYmlwMzkgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXRyaWNpbyBQYWxsYWRpbm8sIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuY29uc3QgSnMgPSB6dSwgWHMgPSB4dCwgVmwgPSBkbCwgUXMgPSBGbCwgR2wgPSBLbCwgcHIgPSBXbCwgWmwgPSAodCkgPT4gdFswXSA9PT0gXCJcXHUzMDQyXFx1MzA0NFxcdTMwNTNcXHUzMDRGXFx1MzA1N1xcdTMwOTNcIjtcbmZ1bmN0aW9uIGVhKHQpIHtcbiAgaWYgKHR5cGVvZiB0ICE9IFwic3RyaW5nXCIpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBtbmVtb25pYyB0eXBlOiAke3R5cGVvZiB0fWApO1xuICByZXR1cm4gdC5ub3JtYWxpemUoXCJORktEXCIpO1xufVxuZnVuY3Rpb24gYWkodCkge1xuICBjb25zdCBlID0gZWEodCksIHIgPSBlLnNwbGl0KFwiIFwiKTtcbiAgaWYgKCFbMTIsIDE1LCAxOCwgMjEsIDI0XS5pbmNsdWRlcyhyLmxlbmd0aCkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBtbmVtb25pY1wiKTtcbiAgcmV0dXJuIHsgbmZrZDogZSwgd29yZHM6IHIgfTtcbn1cbmZ1bmN0aW9uIHRhKHQpIHtcbiAgSnMuZGVmYXVsdC5ieXRlcyh0LCAxNiwgMjAsIDI0LCAyOCwgMzIpO1xufVxuZnVuY3Rpb24gWWwodCwgZSA9IDEyOCkge1xuICBpZiAoSnMuZGVmYXVsdC5udW1iZXIoZSksIGUgJSAzMiAhPT0gMCB8fCBlID4gMjU2KVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGVudHJvcHlcIik7XG4gIHJldHVybiBvYSgoMCwgR2wucmFuZG9tQnl0ZXMpKGUgLyA4KSwgdCk7XG59XG52YXIgcmEgPSBkZS5nZW5lcmF0ZU1uZW1vbmljID0gWWw7XG5jb25zdCBKbCA9ICh0KSA9PiB7XG4gIGNvbnN0IGUgPSA4IC0gdC5sZW5ndGggLyA0O1xuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWygwLCBWbC5zaGEyNTYpKHQpWzBdID4+IGUgPDwgZV0pO1xufTtcbmZ1bmN0aW9uIG5hKHQpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHQpIHx8IHQubGVuZ3RoICE9PSAyMDQ4IHx8IHR5cGVvZiB0WzBdICE9IFwic3RyaW5nXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiV29ybGlzdDogZXhwZWN0ZWQgYXJyYXkgb2YgMjA0OCBzdHJpbmdzXCIpO1xuICByZXR1cm4gdC5mb3JFYWNoKChlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBlICE9IFwic3RyaW5nXCIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFdvcmRsaXN0OiBub24tc3RyaW5nIGVsZW1lbnQ6ICR7ZX1gKTtcbiAgfSksIHByLnV0aWxzLmNoYWluKHByLnV0aWxzLmNoZWNrc3VtKDEsIEpsKSwgcHIudXRpbHMucmFkaXgyKDExLCAhMCksIHByLnV0aWxzLmFscGhhYmV0KHQpKTtcbn1cbmZ1bmN0aW9uIGlhKHQsIGUpIHtcbiAgY29uc3QgeyB3b3JkczogciB9ID0gYWkodCksIG4gPSBuYShlKS5kZWNvZGUocik7XG4gIHJldHVybiB0YShuKSwgbjtcbn1cbmRlLm1uZW1vbmljVG9FbnRyb3B5ID0gaWE7XG5mdW5jdGlvbiBvYSh0LCBlKSB7XG4gIHJldHVybiB0YSh0KSwgbmEoZSkuZW5jb2RlKHQpLmpvaW4oWmwoZSkgPyBcIlxcdTMwMDBcIiA6IFwiIFwiKTtcbn1cbmRlLmVudHJvcHlUb01uZW1vbmljID0gb2E7XG5mdW5jdGlvbiBYbCh0LCBlKSB7XG4gIHRyeSB7XG4gICAgaWEodCwgZSk7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiAhMTtcbiAgfVxuICByZXR1cm4gITA7XG59XG52YXIgc2EgPSBkZS52YWxpZGF0ZU1uZW1vbmljID0gWGw7XG5jb25zdCBhYSA9ICh0KSA9PiBlYShgbW5lbW9uaWMke3R9YCk7XG5mdW5jdGlvbiBRbCh0LCBlID0gXCJcIikge1xuICByZXR1cm4gKDAsIFhzLnBia2RmMkFzeW5jKShRcy5zaGE1MTIsIGFpKHQpLm5ma2QsIGFhKGUpLCB7IGM6IDIwNDgsIGRrTGVuOiA2NCB9KTtcbn1cbmRlLm1uZW1vbmljVG9TZWVkID0gUWw7XG5mdW5jdGlvbiBlZih0LCBlID0gXCJcIikge1xuICByZXR1cm4gKDAsIFhzLnBia2RmMikoUXMuc2hhNTEyLCBhaSh0KS5uZmtkLCBhYShlKSwgeyBjOiAyMDQ4LCBka0xlbjogNjQgfSk7XG59XG5ZcyA9IGRlLm1uZW1vbmljVG9TZWVkU3luYyA9IGVmO1xuY2xhc3MgY2EgZXh0ZW5kcyBvaSB7XG4gIGNvbnN0cnVjdG9yKGUsIHIpIHtcbiAgICBzdXBlcigpLCB0aGlzLmZpbmlzaGVkID0gITEsIHRoaXMuZGVzdHJveWVkID0gITEsIFFlLmhhc2goZSk7XG4gICAgY29uc3QgbiA9IE90KHIpO1xuICAgIGlmICh0aGlzLmlIYXNoID0gZS5jcmVhdGUoKSwgdHlwZW9mIHRoaXMuaUhhc2gudXBkYXRlICE9IFwiZnVuY3Rpb25cIilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIGluc3RhbmNlIG9mIGNsYXNzIHdoaWNoIGV4dGVuZHMgdXRpbHMuSGFzaFwiKTtcbiAgICB0aGlzLmJsb2NrTGVuID0gdGhpcy5pSGFzaC5ibG9ja0xlbiwgdGhpcy5vdXRwdXRMZW4gPSB0aGlzLmlIYXNoLm91dHB1dExlbjtcbiAgICBjb25zdCBpID0gdGhpcy5ibG9ja0xlbiwgcyA9IG5ldyBVaW50OEFycmF5KGkpO1xuICAgIHMuc2V0KG4ubGVuZ3RoID4gaSA/IGUuY3JlYXRlKCkudXBkYXRlKG4pLmRpZ2VzdCgpIDogbik7XG4gICAgZm9yIChsZXQgbyA9IDA7IG8gPCBzLmxlbmd0aDsgbysrKVxuICAgICAgc1tvXSBePSA1NDtcbiAgICB0aGlzLmlIYXNoLnVwZGF0ZShzKSwgdGhpcy5vSGFzaCA9IGUuY3JlYXRlKCk7XG4gICAgZm9yIChsZXQgbyA9IDA7IG8gPCBzLmxlbmd0aDsgbysrKVxuICAgICAgc1tvXSBePSAxMDY7XG4gICAgdGhpcy5vSGFzaC51cGRhdGUocyksIHMuZmlsbCgwKTtcbiAgfVxuICB1cGRhdGUoZSkge1xuICAgIHJldHVybiBRZS5leGlzdHModGhpcyksIHRoaXMuaUhhc2gudXBkYXRlKGUpLCB0aGlzO1xuICB9XG4gIGRpZ2VzdEludG8oZSkge1xuICAgIFFlLmV4aXN0cyh0aGlzKSwgUWUuYnl0ZXMoZSwgdGhpcy5vdXRwdXRMZW4pLCB0aGlzLmZpbmlzaGVkID0gITAsIHRoaXMuaUhhc2guZGlnZXN0SW50byhlKSwgdGhpcy5vSGFzaC51cGRhdGUoZSksIHRoaXMub0hhc2guZGlnZXN0SW50byhlKSwgdGhpcy5kZXN0cm95KCk7XG4gIH1cbiAgZGlnZXN0KCkge1xuICAgIGNvbnN0IGUgPSBuZXcgVWludDhBcnJheSh0aGlzLm9IYXNoLm91dHB1dExlbik7XG4gICAgcmV0dXJuIHRoaXMuZGlnZXN0SW50byhlKSwgZTtcbiAgfVxuICBfY2xvbmVJbnRvKGUpIHtcbiAgICBlIHx8IChlID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyksIHt9KSk7XG4gICAgY29uc3QgeyBvSGFzaDogciwgaUhhc2g6IG4sIGZpbmlzaGVkOiBpLCBkZXN0cm95ZWQ6IHMsIGJsb2NrTGVuOiBvLCBvdXRwdXRMZW46IGEgfSA9IHRoaXM7XG4gICAgcmV0dXJuIGUgPSBlLCBlLmZpbmlzaGVkID0gaSwgZS5kZXN0cm95ZWQgPSBzLCBlLmJsb2NrTGVuID0gbywgZS5vdXRwdXRMZW4gPSBhLCBlLm9IYXNoID0gci5fY2xvbmVJbnRvKGUub0hhc2gpLCBlLmlIYXNoID0gbi5fY2xvbmVJbnRvKGUuaUhhc2gpLCBlO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSAhMCwgdGhpcy5vSGFzaC5kZXN0cm95KCksIHRoaXMuaUhhc2guZGVzdHJveSgpO1xuICB9XG59XG5jb25zdCBObiA9ICh0LCBlLCByKSA9PiBuZXcgY2EodCwgZSkudXBkYXRlKHIpLmRpZ2VzdCgpO1xuTm4uY3JlYXRlID0gKHQsIGUpID0+IG5ldyBjYSh0LCBlKTtcbmNvbnN0IHRmID0gbmV3IFVpbnQ4QXJyYXkoWzcsIDQsIDEzLCAxLCAxMCwgNiwgMTUsIDMsIDEyLCAwLCA5LCA1LCAyLCAxNCwgMTEsIDhdKSwgdWEgPSBVaW50OEFycmF5LmZyb20oeyBsZW5ndGg6IDE2IH0sICh0LCBlKSA9PiBlKSwgcmYgPSB1YS5tYXAoKHQpID0+ICg5ICogdCArIDUpICUgMTYpO1xubGV0IGNpID0gW3VhXSwgdWkgPSBbcmZdO1xuZm9yIChsZXQgdCA9IDA7IHQgPCA0OyB0KyspXG4gIGZvciAobGV0IGUgb2YgW2NpLCB1aV0pXG4gICAgZS5wdXNoKGVbdF0ubWFwKChyKSA9PiB0ZltyXSkpO1xuY29uc3QgbGEgPSBbXG4gIFsxMSwgMTQsIDE1LCAxMiwgNSwgOCwgNywgOSwgMTEsIDEzLCAxNCwgMTUsIDYsIDcsIDksIDhdLFxuICBbMTIsIDEzLCAxMSwgMTUsIDYsIDksIDksIDcsIDEyLCAxNSwgMTEsIDEzLCA3LCA4LCA3LCA3XSxcbiAgWzEzLCAxNSwgMTQsIDExLCA3LCA3LCA2LCA4LCAxMywgMTQsIDEzLCAxMiwgNSwgNSwgNiwgOV0sXG4gIFsxNCwgMTEsIDEyLCAxNCwgOCwgNiwgNSwgNSwgMTUsIDEyLCAxNSwgMTQsIDksIDksIDgsIDZdLFxuICBbMTUsIDEyLCAxMywgMTMsIDksIDUsIDgsIDYsIDE0LCAxMSwgMTIsIDExLCA4LCA2LCA1LCA1XVxuXS5tYXAoKHQpID0+IG5ldyBVaW50OEFycmF5KHQpKSwgbmYgPSBjaS5tYXAoKHQsIGUpID0+IHQubWFwKChyKSA9PiBsYVtlXVtyXSkpLCBvZiA9IHVpLm1hcCgodCwgZSkgPT4gdC5tYXAoKHIpID0+IGxhW2VdW3JdKSksIHNmID0gbmV3IFVpbnQzMkFycmF5KFswLCAxNTE4NTAwMjQ5LCAxODU5Nzc1MzkzLCAyNDAwOTU5NzA4LCAyODQwODUzODM4XSksIGFmID0gbmV3IFVpbnQzMkFycmF5KFsxMzUyODI5OTI2LCAxNTQ4NjAzNjg0LCAxODM2MDcyNjkxLCAyMDUzOTk0MjE3LCAwXSksIHlyID0gKHQsIGUpID0+IHQgPDwgZSB8IHQgPj4+IDMyIC0gZTtcbmZ1bmN0aW9uIFppKHQsIGUsIHIsIG4pIHtcbiAgcmV0dXJuIHQgPT09IDAgPyBlIF4gciBeIG4gOiB0ID09PSAxID8gZSAmIHIgfCB+ZSAmIG4gOiB0ID09PSAyID8gKGUgfCB+cikgXiBuIDogdCA9PT0gMyA/IGUgJiBuIHwgciAmIH5uIDogZSBeIChyIHwgfm4pO1xufVxuY29uc3QgZ3IgPSBuZXcgVWludDMyQXJyYXkoMTYpO1xuY2xhc3MgY2YgZXh0ZW5kcyBzaSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKDY0LCAyMCwgOCwgITApLCB0aGlzLmgwID0gMTczMjU4NDE5MywgdGhpcy5oMSA9IC0yNzE3MzM4NzksIHRoaXMuaDIgPSAtMTczMjU4NDE5NCwgdGhpcy5oMyA9IDI3MTczMzg3OCwgdGhpcy5oNCA9IC0xMDA5NTg5Nzc2O1xuICB9XG4gIGdldCgpIHtcbiAgICBjb25zdCB7IGgwOiBlLCBoMTogciwgaDI6IG4sIGgzOiBpLCBoNDogcyB9ID0gdGhpcztcbiAgICByZXR1cm4gW2UsIHIsIG4sIGksIHNdO1xuICB9XG4gIHNldChlLCByLCBuLCBpLCBzKSB7XG4gICAgdGhpcy5oMCA9IGUgfCAwLCB0aGlzLmgxID0gciB8IDAsIHRoaXMuaDIgPSBuIHwgMCwgdGhpcy5oMyA9IGkgfCAwLCB0aGlzLmg0ID0gcyB8IDA7XG4gIH1cbiAgcHJvY2VzcyhlLCByKSB7XG4gICAgZm9yIChsZXQgZCA9IDA7IGQgPCAxNjsgZCsrLCByICs9IDQpXG4gICAgICBncltkXSA9IGUuZ2V0VWludDMyKHIsICEwKTtcbiAgICBsZXQgbiA9IHRoaXMuaDAgfCAwLCBpID0gbiwgcyA9IHRoaXMuaDEgfCAwLCBvID0gcywgYSA9IHRoaXMuaDIgfCAwLCBjID0gYSwgbCA9IHRoaXMuaDMgfCAwLCBmID0gbCwgdSA9IHRoaXMuaDQgfCAwLCBoID0gdTtcbiAgICBmb3IgKGxldCBkID0gMDsgZCA8IDU7IGQrKykge1xuICAgICAgY29uc3QgcCA9IDQgLSBkLCB5ID0gc2ZbZF0sIGcgPSBhZltkXSwgdiA9IGNpW2RdLCBfID0gdWlbZF0sIG0gPSBuZltkXSwgQyA9IG9mW2RdO1xuICAgICAgZm9yIChsZXQgTyA9IDA7IE8gPCAxNjsgTysrKSB7XG4gICAgICAgIGNvbnN0IHcgPSB5cihuICsgWmkoZCwgcywgYSwgbCkgKyBnclt2W09dXSArIHksIG1bT10pICsgdSB8IDA7XG4gICAgICAgIG4gPSB1LCB1ID0gbCwgbCA9IHlyKGEsIDEwKSB8IDAsIGEgPSBzLCBzID0gdztcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IE8gPSAwOyBPIDwgMTY7IE8rKykge1xuICAgICAgICBjb25zdCB3ID0geXIoaSArIFppKHAsIG8sIGMsIGYpICsgZ3JbX1tPXV0gKyBnLCBDW09dKSArIGggfCAwO1xuICAgICAgICBpID0gaCwgaCA9IGYsIGYgPSB5cihjLCAxMCkgfCAwLCBjID0gbywgbyA9IHc7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuc2V0KHRoaXMuaDEgKyBhICsgZiB8IDAsIHRoaXMuaDIgKyBsICsgaCB8IDAsIHRoaXMuaDMgKyB1ICsgaSB8IDAsIHRoaXMuaDQgKyBuICsgbyB8IDAsIHRoaXMuaDAgKyBzICsgYyB8IDApO1xuICB9XG4gIHJvdW5kQ2xlYW4oKSB7XG4gICAgZ3IuZmlsbCgwKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZGVzdHJveWVkID0gITAsIHRoaXMuYnVmZmVyLmZpbGwoMCksIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDApO1xuICB9XG59XG5jb25zdCB1ZiA9IG50KCgpID0+IG5ldyBjZigpKSwgYnIgPSB1ZS5Qcm9qZWN0aXZlUG9pbnQsIGxuID0gQXMoanIpO1xuZnVuY3Rpb24gWWkodCkge1xuICByZXR1cm4gQmlnSW50KGAweCR7bmkodCl9YCk7XG59XG5mdW5jdGlvbiBsZih0KSB7XG4gIHJldHVybiBXcyh0LnRvU3RyaW5nKDE2KS5wYWRTdGFydCg2NCwgXCIwXCIpKTtcbn1cbmNvbnN0IGZmID0gaWkoXCJCaXRjb2luIHNlZWRcIiksIGZuID0geyBwcml2YXRlOiA3NjA2NjI3NiwgcHVibGljOiA3NjA2NzM1OCB9LCBobiA9IDIxNDc0ODM2NDgsIGhmID0gKHQpID0+IHVmKGpyKHQpKSwgZGYgPSAodCkgPT4gZnQodCkuZ2V0VWludDMyKDAsICExKSwgdnIgPSAodCkgPT4ge1xuICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKHQpIHx8IHQgPCAwIHx8IHQgPiAyICoqIDMyIC0gMSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbnVtYmVyPSR7dH0uIFNob3VsZCBiZSBmcm9tIDAgdG8gMiAqKiAzMiAtIDFgKTtcbiAgY29uc3QgZSA9IG5ldyBVaW50OEFycmF5KDQpO1xuICByZXR1cm4gZnQoZSkuc2V0VWludDMyKDAsIHQsICExKSwgZTtcbn07XG5jbGFzcyBjdCB7XG4gIGdldCBmaW5nZXJwcmludCgpIHtcbiAgICBpZiAoIXRoaXMucHViSGFzaClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHB1YmxpY0tleSBzZXQhXCIpO1xuICAgIHJldHVybiBkZih0aGlzLnB1Ykhhc2gpO1xuICB9XG4gIGdldCBpZGVudGlmaWVyKCkge1xuICAgIHJldHVybiB0aGlzLnB1Ykhhc2g7XG4gIH1cbiAgZ2V0IHB1YktleUhhc2goKSB7XG4gICAgcmV0dXJuIHRoaXMucHViSGFzaDtcbiAgfVxuICBnZXQgcHJpdmF0ZUtleSgpIHtcbiAgICByZXR1cm4gdGhpcy5wcml2S2V5Qnl0ZXMgfHwgbnVsbDtcbiAgfVxuICBnZXQgcHVibGljS2V5KCkge1xuICAgIHJldHVybiB0aGlzLnB1YktleSB8fCBudWxsO1xuICB9XG4gIGdldCBwcml2YXRlRXh0ZW5kZWRLZXkoKSB7XG4gICAgY29uc3QgZSA9IHRoaXMucHJpdmF0ZUtleTtcbiAgICBpZiAoIWUpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBwcml2YXRlIGtleVwiKTtcbiAgICByZXR1cm4gbG4uZW5jb2RlKHRoaXMuc2VyaWFsaXplKHRoaXMudmVyc2lvbnMucHJpdmF0ZSwgZXIobmV3IFVpbnQ4QXJyYXkoWzBdKSwgZSkpKTtcbiAgfVxuICBnZXQgcHVibGljRXh0ZW5kZWRLZXkoKSB7XG4gICAgaWYgKCF0aGlzLnB1YktleSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHB1YmxpYyBrZXlcIik7XG4gICAgcmV0dXJuIGxuLmVuY29kZSh0aGlzLnNlcmlhbGl6ZSh0aGlzLnZlcnNpb25zLnB1YmxpYywgdGhpcy5wdWJLZXkpKTtcbiAgfVxuICBzdGF0aWMgZnJvbU1hc3RlclNlZWQoZSwgciA9IGZuKSB7XG4gICAgaWYgKFllKGUpLCA4ICogZS5sZW5ndGggPCAxMjggfHwgOCAqIGUubGVuZ3RoID4gNTEyKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBIREtleTogd3Jvbmcgc2VlZCBsZW5ndGg9JHtlLmxlbmd0aH0uIFNob3VsZCBiZSBiZXR3ZWVuIDEyOCBhbmQgNTEyIGJpdHM7IDI1NiBiaXRzIGlzIGFkdmlzZWQpYCk7XG4gICAgY29uc3QgbiA9IE5uKHFuLCBmZiwgZSk7XG4gICAgcmV0dXJuIG5ldyBjdCh7XG4gICAgICB2ZXJzaW9uczogcixcbiAgICAgIGNoYWluQ29kZTogbi5zbGljZSgzMiksXG4gICAgICBwcml2YXRlS2V5OiBuLnNsaWNlKDAsIDMyKVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBmcm9tRXh0ZW5kZWRLZXkoZSwgciA9IGZuKSB7XG4gICAgY29uc3QgbiA9IGxuLmRlY29kZShlKSwgaSA9IGZ0KG4pLCBzID0gaS5nZXRVaW50MzIoMCwgITEpLCBvID0ge1xuICAgICAgdmVyc2lvbnM6IHIsXG4gICAgICBkZXB0aDogbls0XSxcbiAgICAgIHBhcmVudEZpbmdlcnByaW50OiBpLmdldFVpbnQzMig1LCAhMSksXG4gICAgICBpbmRleDogaS5nZXRVaW50MzIoOSwgITEpLFxuICAgICAgY2hhaW5Db2RlOiBuLnNsaWNlKDEzLCA0NSlcbiAgICB9LCBhID0gbi5zbGljZSg0NSksIGMgPSBhWzBdID09PSAwO1xuICAgIGlmIChzICE9PSByW2MgPyBcInByaXZhdGVcIiA6IFwicHVibGljXCJdKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmVyc2lvbiBtaXNtYXRjaFwiKTtcbiAgICByZXR1cm4gYyA/IG5ldyBjdCh7IC4uLm8sIHByaXZhdGVLZXk6IGEuc2xpY2UoMSkgfSkgOiBuZXcgY3QoeyAuLi5vLCBwdWJsaWNLZXk6IGEgfSk7XG4gIH1cbiAgc3RhdGljIGZyb21KU09OKGUpIHtcbiAgICByZXR1cm4gY3QuZnJvbUV4dGVuZGVkS2V5KGUueHByaXYpO1xuICB9XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBpZiAodGhpcy5kZXB0aCA9IDAsIHRoaXMuaW5kZXggPSAwLCB0aGlzLmNoYWluQ29kZSA9IG51bGwsIHRoaXMucGFyZW50RmluZ2VycHJpbnQgPSAwLCAhZSB8fCB0eXBlb2YgZSAhPSBcIm9iamVjdFwiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSERLZXkuY29uc3RydWN0b3IgbXVzdCBub3QgYmUgY2FsbGVkIGRpcmVjdGx5XCIpO1xuICAgIGlmICh0aGlzLnZlcnNpb25zID0gZS52ZXJzaW9ucyB8fCBmbiwgdGhpcy5kZXB0aCA9IGUuZGVwdGggfHwgMCwgdGhpcy5jaGFpbkNvZGUgPSBlLmNoYWluQ29kZSwgdGhpcy5pbmRleCA9IGUuaW5kZXggfHwgMCwgdGhpcy5wYXJlbnRGaW5nZXJwcmludCA9IGUucGFyZW50RmluZ2VycHJpbnQgfHwgMCwgIXRoaXMuZGVwdGggJiYgKHRoaXMucGFyZW50RmluZ2VycHJpbnQgfHwgdGhpcy5pbmRleCkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJIREtleTogemVybyBkZXB0aCB3aXRoIG5vbi16ZXJvIGluZGV4L3BhcmVudCBmaW5nZXJwcmludFwiKTtcbiAgICBpZiAoZS5wdWJsaWNLZXkgJiYgZS5wcml2YXRlS2V5KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSERLZXk6IHB1YmxpY0tleSBhbmQgcHJpdmF0ZUtleSBhdCBzYW1lIHRpbWUuXCIpO1xuICAgIGlmIChlLnByaXZhdGVLZXkpIHtcbiAgICAgIGlmICghdWUudXRpbHMuaXNWYWxpZFByaXZhdGVLZXkoZS5wcml2YXRlS2V5KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwcml2YXRlIGtleVwiKTtcbiAgICAgIHRoaXMucHJpdktleSA9IHR5cGVvZiBlLnByaXZhdGVLZXkgPT0gXCJiaWdpbnRcIiA/IGUucHJpdmF0ZUtleSA6IFlpKGUucHJpdmF0ZUtleSksIHRoaXMucHJpdktleUJ5dGVzID0gbGYodGhpcy5wcml2S2V5KSwgdGhpcy5wdWJLZXkgPSB1ZS5nZXRQdWJsaWNLZXkoZS5wcml2YXRlS2V5LCAhMCk7XG4gICAgfSBlbHNlIGlmIChlLnB1YmxpY0tleSlcbiAgICAgIHRoaXMucHViS2V5ID0gYnIuZnJvbUhleChlLnB1YmxpY0tleSkudG9SYXdCeXRlcyghMCk7XG4gICAgZWxzZVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSERLZXk6IG5vIHB1YmxpYyBvciBwcml2YXRlIGtleSBwcm92aWRlZFwiKTtcbiAgICB0aGlzLnB1Ykhhc2ggPSBoZih0aGlzLnB1YktleSk7XG4gIH1cbiAgZGVyaXZlKGUpIHtcbiAgICBpZiAoIS9eW21NXSc/Ly50ZXN0KGUpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXRoIG11c3Qgc3RhcnQgd2l0aCBcIm1cIiBvciBcIk1cIicpO1xuICAgIGlmICgvXlttTV0nPyQvLnRlc3QoZSkpXG4gICAgICByZXR1cm4gdGhpcztcbiAgICBjb25zdCByID0gZS5yZXBsYWNlKC9eW21NXSc/XFwvLywgXCJcIikuc3BsaXQoXCIvXCIpO1xuICAgIGxldCBuID0gdGhpcztcbiAgICBmb3IgKGNvbnN0IGkgb2Ygcikge1xuICAgICAgY29uc3QgcyA9IC9eKFxcZCspKCc/KSQvLmV4ZWMoaSk7XG4gICAgICBpZiAoIXMgfHwgcy5sZW5ndGggIT09IDMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjaGlsZCBpbmRleDogJHtpfWApO1xuICAgICAgbGV0IG8gPSArc1sxXTtcbiAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobykgfHwgbyA+PSBobilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbmRleFwiKTtcbiAgICAgIHNbMl0gPT09IFwiJ1wiICYmIChvICs9IGhuKSwgbiA9IG4uZGVyaXZlQ2hpbGQobyk7XG4gICAgfVxuICAgIHJldHVybiBuO1xuICB9XG4gIGRlcml2ZUNoaWxkKGUpIHtcbiAgICBpZiAoIXRoaXMucHViS2V5IHx8ICF0aGlzLmNoYWluQ29kZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHB1YmxpY0tleSBvciBjaGFpbkNvZGUgc2V0XCIpO1xuICAgIGxldCByID0gdnIoZSk7XG4gICAgaWYgKGUgPj0gaG4pIHtcbiAgICAgIGNvbnN0IGEgPSB0aGlzLnByaXZhdGVLZXk7XG4gICAgICBpZiAoIWEpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBkZXJpdmUgaGFyZGVuZWQgY2hpbGQga2V5XCIpO1xuICAgICAgciA9IGVyKG5ldyBVaW50OEFycmF5KFswXSksIGEsIHIpO1xuICAgIH0gZWxzZVxuICAgICAgciA9IGVyKHRoaXMucHViS2V5LCByKTtcbiAgICBjb25zdCBuID0gTm4ocW4sIHRoaXMuY2hhaW5Db2RlLCByKSwgaSA9IFlpKG4uc2xpY2UoMCwgMzIpKSwgcyA9IG4uc2xpY2UoMzIpO1xuICAgIGlmICghdWUudXRpbHMuaXNWYWxpZFByaXZhdGVLZXkoaSkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUd2VhayBiaWdnZXIgdGhhbiBjdXJ2ZSBvcmRlclwiKTtcbiAgICBjb25zdCBvID0ge1xuICAgICAgdmVyc2lvbnM6IHRoaXMudmVyc2lvbnMsXG4gICAgICBjaGFpbkNvZGU6IHMsXG4gICAgICBkZXB0aDogdGhpcy5kZXB0aCArIDEsXG4gICAgICBwYXJlbnRGaW5nZXJwcmludDogdGhpcy5maW5nZXJwcmludCxcbiAgICAgIGluZGV4OiBlXG4gICAgfTtcbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMucHJpdmF0ZUtleSkge1xuICAgICAgICBjb25zdCBhID0gSih0aGlzLnByaXZLZXkgKyBpLCB1ZS5DVVJWRS5uKTtcbiAgICAgICAgaWYgKCF1ZS51dGlscy5pc1ZhbGlkUHJpdmF0ZUtleShhKSlcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgdHdlYWsgd2FzIG91dCBvZiByYW5nZSBvciB0aGUgcmVzdWx0ZWQgcHJpdmF0ZSBrZXkgaXMgaW52YWxpZFwiKTtcbiAgICAgICAgby5wcml2YXRlS2V5ID0gYTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGEgPSBici5mcm9tSGV4KHRoaXMucHViS2V5KS5hZGQoYnIuZnJvbVByaXZhdGVLZXkoaSkpO1xuICAgICAgICBpZiAoYS5lcXVhbHMoYnIuWkVSTykpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHR3ZWFrIHdhcyBlcXVhbCB0byBuZWdhdGl2ZSBQLCB3aGljaCBtYWRlIHRoZSByZXN1bHQga2V5IGludmFsaWRcIik7XG4gICAgICAgIG8ucHVibGljS2V5ID0gYS50b1Jhd0J5dGVzKCEwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgY3Qobyk7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gdGhpcy5kZXJpdmVDaGlsZChlICsgMSk7XG4gICAgfVxuICB9XG4gIHNpZ24oZSkge1xuICAgIGlmICghdGhpcy5wcml2YXRlS2V5KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gcHJpdmF0ZUtleSBzZXQhXCIpO1xuICAgIHJldHVybiBZZShlLCAzMiksIHVlLnNpZ24oZSwgdGhpcy5wcml2S2V5KS50b0NvbXBhY3RSYXdCeXRlcygpO1xuICB9XG4gIHZlcmlmeShlLCByKSB7XG4gICAgaWYgKFllKGUsIDMyKSwgWWUociwgNjQpLCAhdGhpcy5wdWJsaWNLZXkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBwdWJsaWNLZXkgc2V0IVwiKTtcbiAgICBsZXQgbjtcbiAgICB0cnkge1xuICAgICAgbiA9IHVlLlNpZ25hdHVyZS5mcm9tQ29tcGFjdChyKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gICAgcmV0dXJuIHVlLnZlcmlmeShuLCBlLCB0aGlzLnB1YmxpY0tleSk7XG4gIH1cbiAgd2lwZVByaXZhdGVEYXRhKCkge1xuICAgIHJldHVybiB0aGlzLnByaXZLZXkgPSB2b2lkIDAsIHRoaXMucHJpdktleUJ5dGVzICYmICh0aGlzLnByaXZLZXlCeXRlcy5maWxsKDApLCB0aGlzLnByaXZLZXlCeXRlcyA9IHZvaWQgMCksIHRoaXM7XG4gIH1cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICB4cHJpdjogdGhpcy5wcml2YXRlRXh0ZW5kZWRLZXksXG4gICAgICB4cHViOiB0aGlzLnB1YmxpY0V4dGVuZGVkS2V5XG4gICAgfTtcbiAgfVxuICBzZXJpYWxpemUoZSwgcikge1xuICAgIGlmICghdGhpcy5jaGFpbkNvZGUpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBjaGFpbkNvZGUgc2V0XCIpO1xuICAgIHJldHVybiBZZShyLCAzMyksIGVyKHZyKGUpLCBuZXcgVWludDhBcnJheShbdGhpcy5kZXB0aF0pLCB2cih0aGlzLnBhcmVudEZpbmdlcnByaW50KSwgdnIodGhpcy5pbmRleCksIHRoaXMuY2hhaW5Db2RlLCByKTtcbiAgfVxufVxudmFyIHBmID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LCBpZSA9ICh0LCBlKSA9PiB7XG4gIGZvciAodmFyIHIgaW4gZSlcbiAgICBwZih0LCByLCB7IGdldDogZVtyXSwgZW51bWVyYWJsZTogITAgfSk7XG59O1xuZnVuY3Rpb24geWYoKSB7XG4gIHJldHVybiB2ZShTdC51dGlscy5yYW5kb21Qcml2YXRlS2V5KCkpO1xufVxuZnVuY3Rpb24gbGkodCkge1xuICByZXR1cm4gdmUoU3QuZ2V0UHVibGljS2V5KHQpKTtcbn1cbnZhciBnZiA9IHt9O1xuaWUoZ2YsIHtcbiAgTWVzc2FnZU5vZGU6ICgpID0+IGZhLFxuICBNZXNzYWdlUXVldWU6ICgpID0+IGhhLFxuICBpbnNlcnRFdmVudEludG9Bc2NlbmRpbmdMaXN0OiAoKSA9PiB3ZixcbiAgaW5zZXJ0RXZlbnRJbnRvRGVzY2VuZGluZ0xpc3Q6ICgpID0+IHZmLFxuICBub3JtYWxpemVVUkw6ICgpID0+IGJmLFxuICB1dGY4RGVjb2RlcjogKCkgPT4gSmUsXG4gIHV0ZjhFbmNvZGVyOiAoKSA9PiBJZVxufSk7XG52YXIgSmUgPSBuZXcgVGV4dERlY29kZXIoXCJ1dGYtOFwiKSwgSWUgPSBuZXcgVGV4dEVuY29kZXIoKTtcbmZ1bmN0aW9uIGJmKHQpIHtcbiAgbGV0IGUgPSBuZXcgVVJMKHQpO1xuICByZXR1cm4gZS5wYXRobmFtZSA9IGUucGF0aG5hbWUucmVwbGFjZSgvXFwvKy9nLCBcIi9cIiksIGUucGF0aG5hbWUuZW5kc1dpdGgoXCIvXCIpICYmIChlLnBhdGhuYW1lID0gZS5wYXRobmFtZS5zbGljZSgwLCAtMSkpLCAoZS5wb3J0ID09PSBcIjgwXCIgJiYgZS5wcm90b2NvbCA9PT0gXCJ3czpcIiB8fCBlLnBvcnQgPT09IFwiNDQzXCIgJiYgZS5wcm90b2NvbCA9PT0gXCJ3c3M6XCIpICYmIChlLnBvcnQgPSBcIlwiKSwgZS5zZWFyY2hQYXJhbXMuc29ydCgpLCBlLmhhc2ggPSBcIlwiLCBlLnRvU3RyaW5nKCk7XG59XG5mdW5jdGlvbiB2Zih0LCBlKSB7XG4gIHZhciBvO1xuICBsZXQgciA9IDAsIG4gPSB0Lmxlbmd0aCAtIDEsIGksIHMgPSByO1xuICBpZiAobiA8IDApXG4gICAgcyA9IDA7XG4gIGVsc2UgaWYgKGUuY3JlYXRlZF9hdCA8IHRbbl0uY3JlYXRlZF9hdClcbiAgICBzID0gbiArIDE7XG4gIGVsc2UgaWYgKGUuY3JlYXRlZF9hdCA+PSB0W3JdLmNyZWF0ZWRfYXQpXG4gICAgcyA9IHI7XG4gIGVsc2VcbiAgICBmb3IgKDsgOyApIHtcbiAgICAgIGlmIChuIDw9IHIgKyAxKSB7XG4gICAgICAgIHMgPSBuO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChpID0gTWF0aC5mbG9vcihyICsgKG4gLSByKSAvIDIpLCB0W2ldLmNyZWF0ZWRfYXQgPiBlLmNyZWF0ZWRfYXQpXG4gICAgICAgIHIgPSBpO1xuICAgICAgZWxzZSBpZiAodFtpXS5jcmVhdGVkX2F0IDwgZS5jcmVhdGVkX2F0KVxuICAgICAgICBuID0gaTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBzID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICByZXR1cm4gKChvID0gdFtzXSkgPT0gbnVsbCA/IHZvaWQgMCA6IG8uaWQpICE9PSBlLmlkID8gW1xuICAgIC4uLnQuc2xpY2UoMCwgcyksXG4gICAgZSxcbiAgICAuLi50LnNsaWNlKHMpXG4gIF0gOiB0O1xufVxuZnVuY3Rpb24gd2YodCwgZSkge1xuICB2YXIgbztcbiAgbGV0IHIgPSAwLCBuID0gdC5sZW5ndGggLSAxLCBpLCBzID0gcjtcbiAgaWYgKG4gPCAwKVxuICAgIHMgPSAwO1xuICBlbHNlIGlmIChlLmNyZWF0ZWRfYXQgPiB0W25dLmNyZWF0ZWRfYXQpXG4gICAgcyA9IG4gKyAxO1xuICBlbHNlIGlmIChlLmNyZWF0ZWRfYXQgPD0gdFtyXS5jcmVhdGVkX2F0KVxuICAgIHMgPSByO1xuICBlbHNlXG4gICAgZm9yICg7IDsgKSB7XG4gICAgICBpZiAobiA8PSByICsgMSkge1xuICAgICAgICBzID0gbjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoaSA9IE1hdGguZmxvb3IociArIChuIC0gcikgLyAyKSwgdFtpXS5jcmVhdGVkX2F0IDwgZS5jcmVhdGVkX2F0KVxuICAgICAgICByID0gaTtcbiAgICAgIGVsc2UgaWYgKHRbaV0uY3JlYXRlZF9hdCA+IGUuY3JlYXRlZF9hdClcbiAgICAgICAgbiA9IGk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgcyA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgcmV0dXJuICgobyA9IHRbc10pID09IG51bGwgPyB2b2lkIDAgOiBvLmlkKSAhPT0gZS5pZCA/IFtcbiAgICAuLi50LnNsaWNlKDAsIHMpLFxuICAgIGUsXG4gICAgLi4udC5zbGljZShzKVxuICBdIDogdDtcbn1cbnZhciBmYSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IodCkge1xuICAgIEkodGhpcywgXCJfdmFsdWVcIik7XG4gICAgSSh0aGlzLCBcIl9uZXh0XCIpO1xuICAgIHRoaXMuX3ZhbHVlID0gdCwgdGhpcy5fbmV4dCA9IG51bGw7XG4gIH1cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgfVxuICBzZXQgdmFsdWUodCkge1xuICAgIHRoaXMuX3ZhbHVlID0gdDtcbiAgfVxuICBnZXQgbmV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbmV4dDtcbiAgfVxuICBzZXQgbmV4dCh0KSB7XG4gICAgdGhpcy5fbmV4dCA9IHQ7XG4gIH1cbn0sIGhhID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBJKHRoaXMsIFwiX2ZpcnN0XCIpO1xuICAgIEkodGhpcywgXCJfbGFzdFwiKTtcbiAgICBJKHRoaXMsIFwiX3NpemVcIik7XG4gICAgdGhpcy5fZmlyc3QgPSBudWxsLCB0aGlzLl9sYXN0ID0gbnVsbCwgdGhpcy5fc2l6ZSA9IDA7XG4gIH1cbiAgZ2V0IGZpcnN0KCkge1xuICAgIHJldHVybiB0aGlzLl9maXJzdDtcbiAgfVxuICBzZXQgZmlyc3QodCkge1xuICAgIHRoaXMuX2ZpcnN0ID0gdDtcbiAgfVxuICBnZXQgbGFzdCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbGFzdDtcbiAgfVxuICBzZXQgbGFzdCh0KSB7XG4gICAgdGhpcy5fbGFzdCA9IHQ7XG4gIH1cbiAgZ2V0IHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NpemU7XG4gIH1cbiAgc2V0IHNpemUodCkge1xuICAgIHRoaXMuX3NpemUgPSB0O1xuICB9XG4gIGVucXVldWUodCkge1xuICAgIGNvbnN0IGUgPSBuZXcgZmEodCk7XG4gICAgcmV0dXJuIHRoaXMuX3NpemUgPT09IDAgfHwgIXRoaXMuX2xhc3QgPyAodGhpcy5fZmlyc3QgPSBlLCB0aGlzLl9sYXN0ID0gZSkgOiAodGhpcy5fbGFzdC5uZXh0ID0gZSwgdGhpcy5fbGFzdCA9IGUpLCB0aGlzLl9zaXplKyssICEwO1xuICB9XG4gIGRlcXVldWUoKSB7XG4gICAgaWYgKHRoaXMuX3NpemUgPT09IDAgfHwgIXRoaXMuX2ZpcnN0KVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHQgPSB0aGlzLl9maXJzdDtcbiAgICByZXR1cm4gdGhpcy5fZmlyc3QgPSB0Lm5leHQsIHQubmV4dCA9IG51bGwsIHRoaXMuX3NpemUtLSwgdC52YWx1ZTtcbiAgfVxufTtcbmZ1bmN0aW9uIGRhKHQsIGUpIHtcbiAgbGV0IHIgPSB0O1xuICByZXR1cm4gci5wdWJrZXkgPSBsaShlKSwgci5pZCA9IEhyKHIpLCByLnNpZyA9IHBhKHIsIGUpLCByO1xufVxuZnVuY3Rpb24gX2YodCkge1xuICBpZiAoIWZpKHQpKVxuICAgIHRocm93IG5ldyBFcnJvcihcImNhbid0IHNlcmlhbGl6ZSBldmVudCB3aXRoIHdyb25nIG9yIG1pc3NpbmcgcHJvcGVydGllc1wiKTtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KFtcbiAgICAwLFxuICAgIHQucHVia2V5LFxuICAgIHQuY3JlYXRlZF9hdCxcbiAgICB0LmtpbmQsXG4gICAgdC50YWdzLFxuICAgIHQuY29udGVudFxuICBdKTtcbn1cbmZ1bmN0aW9uIEhyKHQpIHtcbiAgbGV0IGUgPSBZbihJZS5lbmNvZGUoX2YodCkpKTtcbiAgcmV0dXJuIHZlKGUpO1xufVxudmFyIG1mID0gKHQpID0+IHQgaW5zdGFuY2VvZiBPYmplY3Q7XG5mdW5jdGlvbiBmaSh0KSB7XG4gIGlmICghbWYodCkgfHwgdHlwZW9mIHQua2luZCAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiB0LmNvbnRlbnQgIT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdC5jcmVhdGVkX2F0ICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIHQucHVia2V5ICE9IFwic3RyaW5nXCIgfHwgIXQucHVia2V5Lm1hdGNoKC9eW2EtZjAtOV17NjR9JC8pIHx8ICFBcnJheS5pc0FycmF5KHQudGFncykpXG4gICAgcmV0dXJuICExO1xuICBmb3IgKGxldCBlID0gMDsgZSA8IHQudGFncy5sZW5ndGg7IGUrKykge1xuICAgIGxldCByID0gdC50YWdzW2VdO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShyKSlcbiAgICAgIHJldHVybiAhMTtcbiAgICBmb3IgKGxldCBuID0gMDsgbiA8IHIubGVuZ3RoOyBuKyspXG4gICAgICBpZiAodHlwZW9mIHJbbl0gPT0gXCJvYmplY3RcIilcbiAgICAgICAgcmV0dXJuICExO1xuICB9XG4gIHJldHVybiAhMDtcbn1cbmZ1bmN0aW9uIGhpKHQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gU3QudmVyaWZ5KHQuc2lnLCBIcih0KSwgdC5wdWJrZXkpO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gITE7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhKHQsIGUpIHtcbiAgcmV0dXJuIHZlKFN0LnNpZ24oSHIodCksIGUpKTtcbn1cbmZ1bmN0aW9uIHlhKHQsIGUpIHtcbiAgaWYgKHQuaWRzICYmIHQuaWRzLmluZGV4T2YoZS5pZCkgPT09IC0xICYmICF0Lmlkcy5zb21lKChyKSA9PiBlLmlkLnN0YXJ0c1dpdGgocikpIHx8IHQua2luZHMgJiYgdC5raW5kcy5pbmRleE9mKGUua2luZCkgPT09IC0xIHx8IHQuYXV0aG9ycyAmJiB0LmF1dGhvcnMuaW5kZXhPZihlLnB1YmtleSkgPT09IC0xICYmICF0LmF1dGhvcnMuc29tZSgocikgPT4gZS5wdWJrZXkuc3RhcnRzV2l0aChyKSkpXG4gICAgcmV0dXJuICExO1xuICBmb3IgKGxldCByIGluIHQpXG4gICAgaWYgKHJbMF0gPT09IFwiI1wiKSB7XG4gICAgICBsZXQgbiA9IHIuc2xpY2UoMSksIGkgPSB0W2AjJHtufWBdO1xuICAgICAgaWYgKGkgJiYgIWUudGFncy5maW5kKFxuICAgICAgICAoW3MsIG9dKSA9PiBzID09PSByLnNsaWNlKDEpICYmIGkuaW5kZXhPZihvKSAhPT0gLTFcbiAgICAgICkpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gIHJldHVybiAhKHQuc2luY2UgJiYgZS5jcmVhdGVkX2F0IDwgdC5zaW5jZSB8fCB0LnVudGlsICYmIGUuY3JlYXRlZF9hdCA+PSB0LnVudGlsKTtcbn1cbmZ1bmN0aW9uIHhmKHQsIGUpIHtcbiAgZm9yIChsZXQgciA9IDA7IHIgPCB0Lmxlbmd0aDsgcisrKVxuICAgIGlmICh5YSh0W3JdLCBlKSlcbiAgICAgIHJldHVybiAhMDtcbiAgcmV0dXJuICExO1xufVxudmFyIEVmID0ge307XG5pZShFZiwge1xuICBnZXRIZXg2NDogKCkgPT4gTXIsXG4gIGdldEludDogKCkgPT4gZ2EsXG4gIGdldFN1YnNjcmlwdGlvbklkOiAoKSA9PiBiYSxcbiAgbWF0Y2hFdmVudElkOiAoKSA9PiBrZixcbiAgbWF0Y2hFdmVudEtpbmQ6ICgpID0+IE9mLFxuICBtYXRjaEV2ZW50UHVia2V5OiAoKSA9PiBTZlxufSk7XG5mdW5jdGlvbiBNcih0LCBlKSB7XG4gIGxldCByID0gZS5sZW5ndGggKyAzLCBuID0gdC5pbmRleE9mKGBcIiR7ZX1cIjpgKSArIHIsIGkgPSB0LnNsaWNlKG4pLmluZGV4T2YoJ1wiJykgKyBuICsgMTtcbiAgcmV0dXJuIHQuc2xpY2UoaSwgaSArIDY0KTtcbn1cbmZ1bmN0aW9uIGdhKHQsIGUpIHtcbiAgbGV0IHIgPSBlLmxlbmd0aCwgbiA9IHQuaW5kZXhPZihgXCIke2V9XCI6YCkgKyByICsgMywgaSA9IHQuc2xpY2UobiksIHMgPSBNYXRoLm1pbihpLmluZGV4T2YoXCIsXCIpLCBpLmluZGV4T2YoXCJ9XCIpKTtcbiAgcmV0dXJuIHBhcnNlSW50KGkuc2xpY2UoMCwgcyksIDEwKTtcbn1cbmZ1bmN0aW9uIGJhKHQpIHtcbiAgbGV0IGUgPSB0LnNsaWNlKDAsIDIyKS5pbmRleE9mKCdcIkVWRU5UXCInKTtcbiAgaWYgKGUgPT09IC0xKVxuICAgIHJldHVybiBudWxsO1xuICBsZXQgciA9IHQuc2xpY2UoZSArIDcgKyAxKS5pbmRleE9mKCdcIicpO1xuICBpZiAociA9PT0gLTEpXG4gICAgcmV0dXJuIG51bGw7XG4gIGxldCBuID0gZSArIDcgKyAxICsgciwgaSA9IHQuc2xpY2UobiArIDEsIDgwKS5pbmRleE9mKCdcIicpO1xuICBpZiAoaSA9PT0gLTEpXG4gICAgcmV0dXJuIG51bGw7XG4gIGxldCBzID0gbiArIDEgKyBpO1xuICByZXR1cm4gdC5zbGljZShuICsgMSwgcyk7XG59XG5mdW5jdGlvbiBrZih0LCBlKSB7XG4gIHJldHVybiBlID09PSBNcih0LCBcImlkXCIpO1xufVxuZnVuY3Rpb24gU2YodCwgZSkge1xuICByZXR1cm4gZSA9PT0gTXIodCwgXCJwdWJrZXlcIik7XG59XG5mdW5jdGlvbiBPZih0LCBlKSB7XG4gIHJldHVybiBlID09PSBnYSh0LCBcImtpbmRcIik7XG59XG52YXIgSmkgPSAoKSA9PiAoe1xuICBjb25uZWN0OiBbXSxcbiAgZGlzY29ubmVjdDogW10sXG4gIGVycm9yOiBbXSxcbiAgbm90aWNlOiBbXSxcbiAgYXV0aDogW11cbn0pO1xuZnVuY3Rpb24gQWYodCwgZSA9IHt9KSB7XG4gIGxldCB7IGxpc3RUaW1lb3V0OiByID0gM2UzLCBnZXRUaW1lb3V0OiBuID0gM2UzLCBjb3VudFRpbWVvdXQ6IGkgPSAzZTMgfSA9IGU7XG4gIHZhciBzLCBvID0ge30sIGEgPSBKaSgpLCBjID0ge30sIGwgPSB7fSwgZjtcbiAgYXN5bmMgZnVuY3Rpb24gdSgpIHtcbiAgICByZXR1cm4gZiB8fCAoZiA9IG5ldyBQcm9taXNlKCh2LCBfKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBzID0gbmV3IFdlYlNvY2tldCh0KTtcbiAgICAgIH0gY2F0Y2ggKHcpIHtcbiAgICAgICAgXyh3KTtcbiAgICAgIH1cbiAgICAgIHMub25vcGVuID0gKCkgPT4ge1xuICAgICAgICBhLmNvbm5lY3QuZm9yRWFjaCgodykgPT4gdygpKSwgdigpO1xuICAgICAgfSwgcy5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgICBmID0gdm9pZCAwLCBhLmVycm9yLmZvckVhY2goKHcpID0+IHcoKSksIF8oKTtcbiAgICAgIH0sIHMub25jbG9zZSA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgZiA9IHZvaWQgMCwgYS5kaXNjb25uZWN0LmZvckVhY2goKHcpID0+IHcoKSk7XG4gICAgICB9O1xuICAgICAgbGV0IG0gPSBuZXcgaGEoKSwgQztcbiAgICAgIHMub25tZXNzYWdlID0gKHcpID0+IHtcbiAgICAgICAgbS5lbnF1ZXVlKHcuZGF0YSksIEMgfHwgKEMgPSBzZXRJbnRlcnZhbChPLCAwKSk7XG4gICAgICB9O1xuICAgICAgZnVuY3Rpb24gTygpIHtcbiAgICAgICAgdmFyIEEsIEIsIEw7XG4gICAgICAgIGlmIChtLnNpemUgPT09IDApIHtcbiAgICAgICAgICBjbGVhckludGVydmFsKEMpLCBDID0gbnVsbDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHcgPSBtLmRlcXVldWUoKTtcbiAgICAgICAgaWYgKCF3KVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IHggPSBiYSh3KTtcbiAgICAgICAgaWYgKHgpIHtcbiAgICAgICAgICBsZXQgUCA9IG9beF07XG4gICAgICAgICAgaWYgKFAgJiYgUC5hbHJlYWR5SGF2ZUV2ZW50ICYmIFAuYWxyZWFkeUhhdmVFdmVudChNcih3LCBcImlkXCIpLCB0KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGxldCBQID0gSlNPTi5wYXJzZSh3KTtcbiAgICAgICAgICBzd2l0Y2ggKFBbMF0pIHtcbiAgICAgICAgICAgIGNhc2UgXCJFVkVOVFwiOiB7XG4gICAgICAgICAgICAgIGxldCBFID0gUFsxXSwgUiA9IFBbMl07XG4gICAgICAgICAgICAgIGZpKFIpICYmIG9bRV0gJiYgKG9bRV0uc2tpcFZlcmlmaWNhdGlvbiB8fCBoaShSKSkgJiYgeGYob1tFXS5maWx0ZXJzLCBSKSAmJiAob1tFXSwgKCgoQSA9IGNbRV0pID09IG51bGwgPyB2b2lkIDAgOiBBLmV2ZW50KSB8fCBbXSkuZm9yRWFjaCgocSkgPT4gcShSKSkpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiQ09VTlRcIjpcbiAgICAgICAgICAgICAgbGV0IEYgPSBQWzFdLCB6ID0gUFsyXTtcbiAgICAgICAgICAgICAgb1tGXSAmJiAoKChCID0gY1tGXSkgPT0gbnVsbCA/IHZvaWQgMCA6IEIuY291bnQpIHx8IFtdKS5mb3JFYWNoKChFKSA9PiBFKHopKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSBcIkVPU0VcIjoge1xuICAgICAgICAgICAgICBsZXQgRSA9IFBbMV07XG4gICAgICAgICAgICAgIEUgaW4gYyAmJiAoY1tFXS5lb3NlLmZvckVhY2goKFIpID0+IFIoKSksIGNbRV0uZW9zZSA9IFtdKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcIk9LXCI6IHtcbiAgICAgICAgICAgICAgbGV0IEUgPSBQWzFdLCBSID0gUFsyXSwgcSA9IFBbM10gfHwgXCJcIjtcbiAgICAgICAgICAgICAgRSBpbiBsICYmIChSID8gbFtFXS5vay5mb3JFYWNoKChIKSA9PiBIKCkpIDogbFtFXS5mYWlsZWQuZm9yRWFjaCgoSCkgPT4gSChxKSksIGxbRV0ub2sgPSBbXSwgbFtFXS5mYWlsZWQgPSBbXSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJOT1RJQ0VcIjpcbiAgICAgICAgICAgICAgbGV0IEcgPSBQWzFdO1xuICAgICAgICAgICAgICBhLm5vdGljZS5mb3JFYWNoKChFKSA9PiBFKEcpKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSBcIkFVVEhcIjoge1xuICAgICAgICAgICAgICBsZXQgRSA9IFBbMV07XG4gICAgICAgICAgICAgIChMID0gYS5hdXRoKSA9PSBudWxsIHx8IEwuZm9yRWFjaCgoUikgPT4gUihFKSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pLCBmKTtcbiAgfVxuICBmdW5jdGlvbiBoKCkge1xuICAgIHJldHVybiAocyA9PSBudWxsID8gdm9pZCAwIDogcy5yZWFkeVN0YXRlKSA9PT0gMTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBkKCkge1xuICAgIGgoKSB8fCBhd2FpdCB1KCk7XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gcCh2KSB7XG4gICAgbGV0IF8gPSBKU09OLnN0cmluZ2lmeSh2KTtcbiAgICBpZiAoISghaCgpICYmIChhd2FpdCBuZXcgUHJvbWlzZSgobSkgPT4gc2V0VGltZW91dChtLCAxZTMpKSwgIWgoKSkpKVxuICAgICAgdHJ5IHtcbiAgICAgICAgcy5zZW5kKF8pO1xuICAgICAgfSBjYXRjaCAobSkge1xuICAgICAgICBjb25zb2xlLmxvZyhtKTtcbiAgICAgIH1cbiAgfVxuICBjb25zdCB5ID0gKHYsIHtcbiAgICB2ZXJiOiBfID0gXCJSRVFcIixcbiAgICBza2lwVmVyaWZpY2F0aW9uOiBtID0gITEsXG4gICAgYWxyZWFkeUhhdmVFdmVudDogQyA9IG51bGwsXG4gICAgaWQ6IE8gPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKCkuc2xpY2UoMilcbiAgfSA9IHt9KSA9PiB7XG4gICAgbGV0IHcgPSBPO1xuICAgIHJldHVybiBvW3ddID0ge1xuICAgICAgaWQ6IHcsXG4gICAgICBmaWx0ZXJzOiB2LFxuICAgICAgc2tpcFZlcmlmaWNhdGlvbjogbSxcbiAgICAgIGFscmVhZHlIYXZlRXZlbnQ6IENcbiAgICB9LCBwKFtfLCB3LCAuLi52XSksIHtcbiAgICAgIHN1YjogKHgsIEEgPSB7fSkgPT4geSh4IHx8IHYsIHtcbiAgICAgICAgc2tpcFZlcmlmaWNhdGlvbjogQS5za2lwVmVyaWZpY2F0aW9uIHx8IG0sXG4gICAgICAgIGFscmVhZHlIYXZlRXZlbnQ6IEEuYWxyZWFkeUhhdmVFdmVudCB8fCBDLFxuICAgICAgICBpZDogd1xuICAgICAgfSksXG4gICAgICB1bnN1YjogKCkgPT4ge1xuICAgICAgICBkZWxldGUgb1t3XSwgZGVsZXRlIGNbd10sIHAoW1wiQ0xPU0VcIiwgd10pO1xuICAgICAgfSxcbiAgICAgIG9uOiAoeCwgQSkgPT4ge1xuICAgICAgICBjW3ddID0gY1t3XSB8fCB7XG4gICAgICAgICAgZXZlbnQ6IFtdLFxuICAgICAgICAgIGNvdW50OiBbXSxcbiAgICAgICAgICBlb3NlOiBbXVxuICAgICAgICB9LCBjW3ddW3hdLnB1c2goQSk7XG4gICAgICB9LFxuICAgICAgb2ZmOiAoeCwgQSkgPT4ge1xuICAgICAgICBsZXQgQiA9IGNbd10sIEwgPSBCW3hdLmluZGV4T2YoQSk7XG4gICAgICAgIEwgPj0gMCAmJiBCW3hdLnNwbGljZShMLCAxKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuICBmdW5jdGlvbiBnKHYsIF8pIHtcbiAgICBpZiAoIXYuaWQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGV2ZW50ICR7dn0gaGFzIG5vIGlkYCk7XG4gICAgbGV0IG0gPSB2LmlkO1xuICAgIHJldHVybiBwKFtfLCB2XSksIHtcbiAgICAgIG9uOiAoQywgTykgPT4ge1xuICAgICAgICBsW21dID0gbFttXSB8fCB7XG4gICAgICAgICAgb2s6IFtdLFxuICAgICAgICAgIGZhaWxlZDogW11cbiAgICAgICAgfSwgbFttXVtDXS5wdXNoKE8pO1xuICAgICAgfSxcbiAgICAgIG9mZjogKEMsIE8pID0+IHtcbiAgICAgICAgbGV0IHcgPSBsW21dO1xuICAgICAgICBpZiAoIXcpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgeCA9IHdbQ10uaW5kZXhPZihPKTtcbiAgICAgICAgeCA+PSAwICYmIHdbQ10uc3BsaWNlKHgsIDEpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB1cmw6IHQsXG4gICAgc3ViOiB5LFxuICAgIG9uOiAodiwgXykgPT4ge1xuICAgICAgYVt2XS5wdXNoKF8pLCB2ID09PSBcImNvbm5lY3RcIiAmJiAocyA9PSBudWxsID8gdm9pZCAwIDogcy5yZWFkeVN0YXRlKSA9PT0gMSAmJiBfKCk7XG4gICAgfSxcbiAgICBvZmY6ICh2LCBfKSA9PiB7XG4gICAgICBsZXQgbSA9IGFbdl0uaW5kZXhPZihfKTtcbiAgICAgIG0gIT09IC0xICYmIGFbdl0uc3BsaWNlKG0sIDEpO1xuICAgIH0sXG4gICAgbGlzdDogKHYsIF8pID0+IG5ldyBQcm9taXNlKChtKSA9PiB7XG4gICAgICBsZXQgQyA9IHkodiwgXyksIE8gPSBbXSwgdyA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBDLnVuc3ViKCksIG0oTyk7XG4gICAgICB9LCByKTtcbiAgICAgIEMub24oXCJlb3NlXCIsICgpID0+IHtcbiAgICAgICAgQy51bnN1YigpLCBjbGVhclRpbWVvdXQodyksIG0oTyk7XG4gICAgICB9KSwgQy5vbihcImV2ZW50XCIsICh4KSA9PiB7XG4gICAgICAgIE8ucHVzaCh4KTtcbiAgICAgIH0pO1xuICAgIH0pLFxuICAgIGdldDogKHYsIF8pID0+IG5ldyBQcm9taXNlKChtKSA9PiB7XG4gICAgICBsZXQgQyA9IHkoW3ZdLCBfKSwgTyA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBDLnVuc3ViKCksIG0obnVsbCk7XG4gICAgICB9LCBuKTtcbiAgICAgIEMub24oXCJldmVudFwiLCAodykgPT4ge1xuICAgICAgICBDLnVuc3ViKCksIGNsZWFyVGltZW91dChPKSwgbSh3KTtcbiAgICAgIH0pO1xuICAgIH0pLFxuICAgIGNvdW50OiAodikgPT4gbmV3IFByb21pc2UoKF8pID0+IHtcbiAgICAgIGxldCBtID0geSh2LCB7IC4uLnksIHZlcmI6IFwiQ09VTlRcIiB9KSwgQyA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBtLnVuc3ViKCksIF8obnVsbCk7XG4gICAgICB9LCBpKTtcbiAgICAgIG0ub24oXCJjb3VudFwiLCAoTykgPT4ge1xuICAgICAgICBtLnVuc3ViKCksIGNsZWFyVGltZW91dChDKSwgXyhPKTtcbiAgICAgIH0pO1xuICAgIH0pLFxuICAgIHB1Ymxpc2godikge1xuICAgICAgcmV0dXJuIGcodiwgXCJFVkVOVFwiKTtcbiAgICB9LFxuICAgIGF1dGgodikge1xuICAgICAgcmV0dXJuIGcodiwgXCJBVVRIXCIpO1xuICAgIH0sXG4gICAgY29ubmVjdDogZCxcbiAgICBjbG9zZSgpIHtcbiAgICAgIGEgPSBKaSgpLCBjID0ge30sIGwgPSB7fSwgcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuT1BFTiAmJiAocyA9PSBudWxsIHx8IHMuY2xvc2UoKSk7XG4gICAgfSxcbiAgICBnZXQgc3RhdHVzKCkge1xuICAgICAgdmFyIHY7XG4gICAgICByZXR1cm4gKHYgPSBzID09IG51bGwgPyB2b2lkIDAgOiBzLnJlYWR5U3RhdGUpICE9IG51bGwgPyB2IDogMztcbiAgICB9XG4gIH07XG59XG52YXIgd2UgPSB7fTtcbmllKHdlLCB7XG4gIEJFQ0gzMl9SRUdFWDogKCkgPT4gdmEsXG4gIGRlY29kZTogKCkgPT4gRHIsXG4gIG5hZGRyRW5jb2RlOiAoKSA9PiBCZixcbiAgbmV2ZW50RW5jb2RlOiAoKSA9PiBQZixcbiAgbm90ZUVuY29kZTogKCkgPT4gUmYsXG4gIG5wcm9maWxlRW5jb2RlOiAoKSA9PiBUZixcbiAgbnB1YkVuY29kZTogKCkgPT4gSWYsXG4gIG5yZWxheUVuY29kZTogKCkgPT4gTGYsXG4gIG5zZWNFbmNvZGU6ICgpID0+IENmXG59KTtcbnZhciBBdCA9IDVlMywgdmEgPSAvW1xceDIxLVxceDdFXXsxLDgzfTFbMDIzNDU2Nzg5YWNkZWZnaGprbG1ucHFyc3R1dnd4eXpdezYsfS87XG5mdW5jdGlvbiBEcih0KSB7XG4gIHZhciBpLCBzLCBvLCBhLCBjLCBsLCBmO1xuICBsZXQgeyBwcmVmaXg6IGUsIHdvcmRzOiByIH0gPSB0ZS5kZWNvZGUodCwgQXQpLCBuID0gbmV3IFVpbnQ4QXJyYXkodGUuZnJvbVdvcmRzKHIpKTtcbiAgc3dpdGNoIChlKSB7XG4gICAgY2FzZSBcIm5wcm9maWxlXCI6IHtcbiAgICAgIGxldCB1ID0gd3Iobik7XG4gICAgICBpZiAoISgoaSA9IHVbMF0pICE9IG51bGwgJiYgaVswXSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgVExWIDAgZm9yIG5wcm9maWxlXCIpO1xuICAgICAgaWYgKHVbMF1bMF0ubGVuZ3RoICE9PSAzMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVExWIDAgc2hvdWxkIGJlIDMyIGJ5dGVzXCIpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJucHJvZmlsZVwiLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgcHVia2V5OiB2ZSh1WzBdWzBdKSxcbiAgICAgICAgICByZWxheXM6IHVbMV0gPyB1WzFdLm1hcCgoaCkgPT4gSmUuZGVjb2RlKGgpKSA6IFtdXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgXCJuZXZlbnRcIjoge1xuICAgICAgbGV0IHUgPSB3cihuKTtcbiAgICAgIGlmICghKChzID0gdVswXSkgIT0gbnVsbCAmJiBzWzBdKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBUTFYgMCBmb3IgbmV2ZW50XCIpO1xuICAgICAgaWYgKHVbMF1bMF0ubGVuZ3RoICE9PSAzMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVExWIDAgc2hvdWxkIGJlIDMyIGJ5dGVzXCIpO1xuICAgICAgaWYgKHVbMl0gJiYgdVsyXVswXS5sZW5ndGggIT09IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUTFYgMiBzaG91bGQgYmUgMzIgYnl0ZXNcIik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIm5ldmVudFwiLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgaWQ6IHZlKHVbMF1bMF0pLFxuICAgICAgICAgIHJlbGF5czogdVsxXSA/IHVbMV0ubWFwKChoKSA9PiBKZS5kZWNvZGUoaCkpIDogW10sXG4gICAgICAgICAgYXV0aG9yOiAobyA9IHVbMl0pICE9IG51bGwgJiYgb1swXSA/IHZlKHVbMl1bMF0pIDogdm9pZCAwXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgXCJuYWRkclwiOiB7XG4gICAgICBsZXQgdSA9IHdyKG4pO1xuICAgICAgaWYgKCEoKGEgPSB1WzBdKSAhPSBudWxsICYmIGFbMF0pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIFRMViAwIGZvciBuYWRkclwiKTtcbiAgICAgIGlmICghKChjID0gdVsyXSkgIT0gbnVsbCAmJiBjWzBdKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBUTFYgMiBmb3IgbmFkZHJcIik7XG4gICAgICBpZiAodVsyXVswXS5sZW5ndGggIT09IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUTFYgMiBzaG91bGQgYmUgMzIgYnl0ZXNcIik7XG4gICAgICBpZiAoISgobCA9IHVbM10pICE9IG51bGwgJiYgbFswXSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgVExWIDMgZm9yIG5hZGRyXCIpO1xuICAgICAgaWYgKHVbM11bMF0ubGVuZ3RoICE9PSA0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUTFYgMyBzaG91bGQgYmUgNCBieXRlc1wiKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwibmFkZHJcIixcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGlkZW50aWZpZXI6IEplLmRlY29kZSh1WzBdWzBdKSxcbiAgICAgICAgICBwdWJrZXk6IHZlKHVbMl1bMF0pLFxuICAgICAgICAgIGtpbmQ6IHBhcnNlSW50KHZlKHVbM11bMF0pLCAxNiksXG4gICAgICAgICAgcmVsYXlzOiB1WzFdID8gdVsxXS5tYXAoKGgpID0+IEplLmRlY29kZShoKSkgOiBbXVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFwibnJlbGF5XCI6IHtcbiAgICAgIGxldCB1ID0gd3Iobik7XG4gICAgICBpZiAoISgoZiA9IHVbMF0pICE9IG51bGwgJiYgZlswXSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgVExWIDAgZm9yIG5yZWxheVwiKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwibnJlbGF5XCIsXG4gICAgICAgIGRhdGE6IEplLmRlY29kZSh1WzBdWzBdKVxuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBcIm5zZWNcIjpcbiAgICBjYXNlIFwibnB1YlwiOlxuICAgIGNhc2UgXCJub3RlXCI6XG4gICAgICByZXR1cm4geyB0eXBlOiBlLCBkYXRhOiB2ZShuKSB9O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gcHJlZml4ICR7ZX1gKTtcbiAgfVxufVxuZnVuY3Rpb24gd3IodCkge1xuICBsZXQgZSA9IHt9LCByID0gdDtcbiAgZm9yICg7IHIubGVuZ3RoID4gMDsgKSB7XG4gICAgbGV0IG4gPSByWzBdLCBpID0gclsxXTtcbiAgICBpZiAoIWkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYG1hbGZvcm1lZCBUTFYgJHtufWApO1xuICAgIGxldCBzID0gci5zbGljZSgyLCAyICsgaSk7XG4gICAgaWYgKHIgPSByLnNsaWNlKDIgKyBpKSwgcy5sZW5ndGggPCBpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBub3QgZW5vdWdoIGRhdGEgdG8gcmVhZCBvbiBUTFYgJHtufWApO1xuICAgIGVbbl0gPSBlW25dIHx8IFtdLCBlW25dLnB1c2gocyk7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBDZih0KSB7XG4gIHJldHVybiBkaShcIm5zZWNcIiwgdCk7XG59XG5mdW5jdGlvbiBJZih0KSB7XG4gIHJldHVybiBkaShcIm5wdWJcIiwgdCk7XG59XG5mdW5jdGlvbiBSZih0KSB7XG4gIHJldHVybiBkaShcIm5vdGVcIiwgdCk7XG59XG5mdW5jdGlvbiBkaSh0LCBlKSB7XG4gIGxldCByID0gX3QoZSksIG4gPSB0ZS50b1dvcmRzKHIpO1xuICByZXR1cm4gdGUuZW5jb2RlKHQsIG4sIEF0KTtcbn1cbmZ1bmN0aW9uIFRmKHQpIHtcbiAgbGV0IGUgPSB6cih7XG4gICAgMDogW190KHQucHVia2V5KV0sXG4gICAgMTogKHQucmVsYXlzIHx8IFtdKS5tYXAoKG4pID0+IEllLmVuY29kZShuKSlcbiAgfSksIHIgPSB0ZS50b1dvcmRzKGUpO1xuICByZXR1cm4gdGUuZW5jb2RlKFwibnByb2ZpbGVcIiwgciwgQXQpO1xufVxuZnVuY3Rpb24gUGYodCkge1xuICBsZXQgZSA9IHpyKHtcbiAgICAwOiBbX3QodC5pZCldLFxuICAgIDE6ICh0LnJlbGF5cyB8fCBbXSkubWFwKChuKSA9PiBJZS5lbmNvZGUobikpLFxuICAgIDI6IHQuYXV0aG9yID8gW190KHQuYXV0aG9yKV0gOiBbXVxuICB9KSwgciA9IHRlLnRvV29yZHMoZSk7XG4gIHJldHVybiB0ZS5lbmNvZGUoXCJuZXZlbnRcIiwgciwgQXQpO1xufVxuZnVuY3Rpb24gQmYodCkge1xuICBsZXQgZSA9IG5ldyBBcnJheUJ1ZmZlcig0KTtcbiAgbmV3IERhdGFWaWV3KGUpLnNldFVpbnQzMigwLCB0LmtpbmQsICExKTtcbiAgbGV0IHIgPSB6cih7XG4gICAgMDogW0llLmVuY29kZSh0LmlkZW50aWZpZXIpXSxcbiAgICAxOiAodC5yZWxheXMgfHwgW10pLm1hcCgoaSkgPT4gSWUuZW5jb2RlKGkpKSxcbiAgICAyOiBbX3QodC5wdWJrZXkpXSxcbiAgICAzOiBbbmV3IFVpbnQ4QXJyYXkoZSldXG4gIH0pLCBuID0gdGUudG9Xb3JkcyhyKTtcbiAgcmV0dXJuIHRlLmVuY29kZShcIm5hZGRyXCIsIG4sIEF0KTtcbn1cbmZ1bmN0aW9uIExmKHQpIHtcbiAgbGV0IGUgPSB6cih7XG4gICAgMDogW0llLmVuY29kZSh0KV1cbiAgfSksIHIgPSB0ZS50b1dvcmRzKGUpO1xuICByZXR1cm4gdGUuZW5jb2RlKFwibnJlbGF5XCIsIHIsIEF0KTtcbn1cbmZ1bmN0aW9uIHpyKHQpIHtcbiAgbGV0IGUgPSBbXTtcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHQpLmZvckVhY2goKFtyLCBuXSkgPT4ge1xuICAgIG4uZm9yRWFjaCgoaSkgPT4ge1xuICAgICAgbGV0IHMgPSBuZXcgVWludDhBcnJheShpLmxlbmd0aCArIDIpO1xuICAgICAgcy5zZXQoW3BhcnNlSW50KHIpXSwgMCksIHMuc2V0KFtpLmxlbmd0aF0sIDEpLCBzLnNldChpLCAyKSwgZS5wdXNoKHMpO1xuICAgIH0pO1xuICB9KSwgX3UoLi4uZSk7XG59XG52YXIgVW4gPSB7fTtcbmllKFVuLCB7XG4gIGRlY3J5cHQ6ICgpID0+IHFmLFxuICBlbmNyeXB0OiAoKSA9PiAkZlxufSk7XG50eXBlb2YgY3J5cHRvIDwgXCJ1XCIgJiYgIWNyeXB0by5zdWJ0bGUgJiYgY3J5cHRvLndlYmNyeXB0byAmJiAoY3J5cHRvLnN1YnRsZSA9IGNyeXB0by53ZWJjcnlwdG8uc3VidGxlKTtcbmFzeW5jIGZ1bmN0aW9uICRmKHQsIGUsIHIpIHtcbiAgY29uc3QgbiA9IHVlLmdldFNoYXJlZFNlY3JldCh0LCBcIjAyXCIgKyBlKSwgaSA9IHdhKG4pO1xuICBsZXQgcyA9IFVpbnQ4QXJyYXkuZnJvbSh4dSgxNikpLCBvID0gSWUuZW5jb2RlKHIpLCBhID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoXG4gICAgXCJyYXdcIixcbiAgICBpLFxuICAgIHsgbmFtZTogXCJBRVMtQ0JDXCIgfSxcbiAgICAhMSxcbiAgICBbXCJlbmNyeXB0XCJdXG4gICksIGMgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmVuY3J5cHQoXG4gICAgeyBuYW1lOiBcIkFFUy1DQkNcIiwgaXY6IHMgfSxcbiAgICBhLFxuICAgIG9cbiAgKSwgbCA9IG10LmVuY29kZShuZXcgVWludDhBcnJheShjKSksIGYgPSBtdC5lbmNvZGUobmV3IFVpbnQ4QXJyYXkocy5idWZmZXIpKTtcbiAgcmV0dXJuIGAke2x9P2l2PSR7Zn1gO1xufVxuYXN5bmMgZnVuY3Rpb24gcWYodCwgZSwgcikge1xuICBsZXQgW24sIGldID0gci5zcGxpdChcIj9pdj1cIiksIHMgPSB1ZS5nZXRTaGFyZWRTZWNyZXQodCwgXCIwMlwiICsgZSksIG8gPSB3YShzKSwgYSA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KFxuICAgIFwicmF3XCIsXG4gICAgbyxcbiAgICB7IG5hbWU6IFwiQUVTLUNCQ1wiIH0sXG4gICAgITEsXG4gICAgW1wiZGVjcnlwdFwiXVxuICApLCBjID0gbXQuZGVjb2RlKG4pLCBsID0gbXQuZGVjb2RlKGkpLCBmID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5kZWNyeXB0KFxuICAgIHsgbmFtZTogXCJBRVMtQ0JDXCIsIGl2OiBsIH0sXG4gICAgYSxcbiAgICBjXG4gICk7XG4gIHJldHVybiBKZS5kZWNvZGUoZik7XG59XG5mdW5jdGlvbiB3YSh0KSB7XG4gIHJldHVybiB0LnNsaWNlKDEsIDMzKTtcbn1cbnZhciBfYSA9IHt9O1xuaWUoX2EsIHtcbiAgTklQMDVfUkVHRVg6ICgpID0+IG1hLFxuICBxdWVyeVByb2ZpbGU6ICgpID0+IGpmLFxuICBzZWFyY2hEb21haW46ICgpID0+IFVmLFxuICB1c2VGZXRjaEltcGxlbWVudGF0aW9uOiAoKSA9PiBOZlxufSk7XG52YXIgbWEgPSAvXig/OihbXFx3ListXSspQCk/KFtcXHcuLV0rKSQvLCBGcjtcbnRyeSB7XG4gIEZyID0gZmV0Y2g7XG59IGNhdGNoIHtcbn1cbmZ1bmN0aW9uIE5mKHQpIHtcbiAgRnIgPSB0O1xufVxuYXN5bmMgZnVuY3Rpb24gVWYodCwgZSA9IFwiXCIpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gKGF3YWl0IChhd2FpdCBGcihgaHR0cHM6Ly8ke3R9Ly53ZWxsLWtub3duL25vc3RyLmpzb24/bmFtZT0ke2V9YCkpLmpzb24oKSkubmFtZXM7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiB7fTtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gamYodCkge1xuICBjb25zdCBlID0gdC5tYXRjaChtYSk7XG4gIGlmICghZSlcbiAgICByZXR1cm4gbnVsbDtcbiAgY29uc3QgW3IsIG4gPSBcIl9cIiwgaV0gPSBlO1xuICB0cnkge1xuICAgIGNvbnN0IHMgPSBhd2FpdCBGcihgaHR0cHM6Ly8ke2l9Ly53ZWxsLWtub3duL25vc3RyLmpzb24/bmFtZT0ke259YCksIHsgbmFtZXM6IG8sIHJlbGF5czogYSB9ID0gSGYoYXdhaXQgcy5qc29uKCkpLCBjID0gb1tuXTtcbiAgICByZXR1cm4gYyA/IHsgcHVia2V5OiBjLCByZWxheXM6IGEgPT0gbnVsbCA/IHZvaWQgMCA6IGFbY10gfSA6IG51bGw7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5mdW5jdGlvbiBIZih0KSB7XG4gIGNvbnN0IGUgPSB7XG4gICAgbmFtZXM6IHt9XG4gIH07XG4gIGZvciAoY29uc3QgW3IsIG5dIG9mIE9iamVjdC5lbnRyaWVzKHQubmFtZXMpKVxuICAgIHR5cGVvZiByID09IFwic3RyaW5nXCIgJiYgdHlwZW9mIG4gPT0gXCJzdHJpbmdcIiAmJiAoZS5uYW1lc1tyXSA9IG4pO1xuICBpZiAodC5yZWxheXMpIHtcbiAgICBlLnJlbGF5cyA9IHt9O1xuICAgIGZvciAoY29uc3QgW3IsIG5dIG9mIE9iamVjdC5lbnRyaWVzKHQucmVsYXlzKSlcbiAgICAgIHR5cGVvZiByID09IFwic3RyaW5nXCIgJiYgQXJyYXkuaXNBcnJheShuKSAmJiAoZS5yZWxheXNbcl0gPSBuLmZpbHRlcigoaSkgPT4gdHlwZW9mIGkgPT0gXCJzdHJpbmdcIikpO1xuICB9XG4gIHJldHVybiBlO1xufVxudmFyIE1mID0ge307XG5pZShNZiwge1xuICBnZW5lcmF0ZVNlZWRXb3JkczogKCkgPT4gemYsXG4gIHByaXZhdGVLZXlGcm9tU2VlZFdvcmRzOiAoKSA9PiBEZixcbiAgdmFsaWRhdGVXb3JkczogKCkgPT4gRmZcbn0pO1xuZnVuY3Rpb24gRGYodCwgZSkge1xuICBsZXQgbiA9IGN0LmZyb21NYXN0ZXJTZWVkKFlzKHQsIGUpKS5kZXJpdmUoXCJtLzQ0Jy8xMjM3Jy8wJy8wLzBcIikucHJpdmF0ZUtleTtcbiAgaWYgKCFuKVxuICAgIHRocm93IG5ldyBFcnJvcihcImNvdWxkIG5vdCBkZXJpdmUgcHJpdmF0ZSBrZXlcIik7XG4gIHJldHVybiB2ZShuKTtcbn1cbmZ1bmN0aW9uIHpmKCkge1xuICByZXR1cm4gcmEoUW4pO1xufVxuZnVuY3Rpb24gRmYodCkge1xuICByZXR1cm4gc2EodCwgUW4pO1xufVxudmFyIEtmID0ge307XG5pZShLZiwge1xuICBwYXJzZTogKCkgPT4gV2Zcbn0pO1xuZnVuY3Rpb24gV2YodCkge1xuICBjb25zdCBlID0ge1xuICAgIHJlcGx5OiB2b2lkIDAsXG4gICAgcm9vdDogdm9pZCAwLFxuICAgIG1lbnRpb25zOiBbXSxcbiAgICBwcm9maWxlczogW11cbiAgfSwgciA9IFtdO1xuICBmb3IgKGNvbnN0IG4gb2YgdC50YWdzKVxuICAgIG5bMF0gPT09IFwiZVwiICYmIG5bMV0gJiYgci5wdXNoKG4pLCBuWzBdID09PSBcInBcIiAmJiBuWzFdICYmIGUucHJvZmlsZXMucHVzaCh7XG4gICAgICBwdWJrZXk6IG5bMV0sXG4gICAgICByZWxheXM6IG5bMl0gPyBbblsyXV0gOiBbXVxuICAgIH0pO1xuICBmb3IgKGxldCBuID0gMDsgbiA8IHIubGVuZ3RoOyBuKyspIHtcbiAgICBjb25zdCBpID0gcltuXSwgW3MsIG8sIGEsIGNdID0gaSwgbCA9IHtcbiAgICAgIGlkOiBvLFxuICAgICAgcmVsYXlzOiBhID8gW2FdIDogW11cbiAgICB9LCBmID0gbiA9PT0gMCwgdSA9IG4gPT09IHIubGVuZ3RoIC0gMTtcbiAgICBpZiAoYyA9PT0gXCJyb290XCIpIHtcbiAgICAgIGUucm9vdCA9IGw7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGMgPT09IFwicmVwbHlcIikge1xuICAgICAgZS5yZXBseSA9IGw7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGMgPT09IFwibWVudGlvblwiKSB7XG4gICAgICBlLm1lbnRpb25zLnB1c2gobCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGYpIHtcbiAgICAgIGUucm9vdCA9IGw7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHUpIHtcbiAgICAgIGUucmVwbHkgPSBsO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGUubWVudGlvbnMucHVzaChsKTtcbiAgfVxuICByZXR1cm4gZTtcbn1cbnZhciBWZiA9IHt9O1xuaWUoVmYsIHtcbiAgZ2V0UG93OiAoKSA9PiBHZlxufSk7XG5mdW5jdGlvbiBHZih0KSB7XG4gIHJldHVybiBaZihfdCh0KSk7XG59XG5mdW5jdGlvbiBaZih0KSB7XG4gIGxldCBlLCByLCBuO1xuICBmb3IgKHIgPSAwLCBlID0gMDsgciA8IHQubGVuZ3RoICYmIChuID0gWWYodFtyXSksIGUgKz0gbiwgbiA9PT0gOCk7IHIrKylcbiAgICA7XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gWWYodCkge1xuICBsZXQgZSA9IDA7XG4gIGlmICh0ID09PSAwKVxuICAgIHJldHVybiA4O1xuICBmb3IgKDsgdCA+Pj0gMTsgKVxuICAgIGUrKztcbiAgcmV0dXJuIDcgLSBlO1xufVxudmFyIEpmID0ge307XG5pZShKZiwge1xuICBmaW5pc2hSZXBvc3RFdmVudDogKCkgPT4gWGYsXG4gIGdldFJlcG9zdGVkRXZlbnQ6ICgpID0+IFFmLFxuICBnZXRSZXBvc3RlZEV2ZW50UG9pbnRlcjogKCkgPT4geGFcbn0pO1xuZnVuY3Rpb24gWGYodCwgZSwgciwgbikge1xuICB2YXIgaTtcbiAgcmV0dXJuIGRhKHtcbiAgICBraW5kOiA2LFxuICAgIHRhZ3M6IFtcbiAgICAgIC4uLihpID0gdC50YWdzKSAhPSBudWxsID8gaSA6IFtdLFxuICAgICAgW1wiZVwiLCBlLmlkLCByXSxcbiAgICAgIFtcInBcIiwgZS5wdWJrZXldXG4gICAgXSxcbiAgICBjb250ZW50OiB0LmNvbnRlbnQgPT09IFwiXCIgPyBcIlwiIDogSlNPTi5zdHJpbmdpZnkoZSksXG4gICAgY3JlYXRlZF9hdDogdC5jcmVhdGVkX2F0XG4gIH0sIG4pO1xufVxuZnVuY3Rpb24geGEodCkge1xuICBpZiAodC5raW5kICE9PSA2KVxuICAgIHJldHVybjtcbiAgbGV0IGUsIHI7XG4gIGZvciAobGV0IG4gPSB0LnRhZ3MubGVuZ3RoIC0gMTsgbiA+PSAwICYmIChlID09PSB2b2lkIDAgfHwgciA9PT0gdm9pZCAwKTsgbi0tKSB7XG4gICAgY29uc3QgaSA9IHQudGFnc1tuXTtcbiAgICBpLmxlbmd0aCA+PSAyICYmIChpWzBdID09PSBcImVcIiAmJiBlID09PSB2b2lkIDAgPyBlID0gaSA6IGlbMF0gPT09IFwicFwiICYmIHIgPT09IHZvaWQgMCAmJiAociA9IGkpKTtcbiAgfVxuICBpZiAoZSAhPT0gdm9pZCAwKVxuICAgIHJldHVybiB7XG4gICAgICBpZDogZVsxXSxcbiAgICAgIHJlbGF5czogW2VbMl0sIHIgPT0gbnVsbCA/IHZvaWQgMCA6IHJbMl1dLmZpbHRlcigobikgPT4gdHlwZW9mIG4gPT0gXCJzdHJpbmdcIiksXG4gICAgICBhdXRob3I6IHIgPT0gbnVsbCA/IHZvaWQgMCA6IHJbMV1cbiAgICB9O1xufVxuZnVuY3Rpb24gUWYodCwgeyBza2lwVmVyaWZpY2F0aW9uOiBlIH0gPSB7fSkge1xuICBjb25zdCByID0geGEodCk7XG4gIGlmIChyID09PSB2b2lkIDAgfHwgdC5jb250ZW50ID09PSBcIlwiKVxuICAgIHJldHVybjtcbiAgbGV0IG47XG4gIHRyeSB7XG4gICAgbiA9IEpTT04ucGFyc2UodC5jb250ZW50KTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChuLmlkID09PSByLmlkICYmICEoIWUgJiYgIWhpKG4pKSlcbiAgICByZXR1cm4gbjtcbn1cbnZhciBlaCA9IHt9O1xuaWUoZWgsIHtcbiAgTk9TVFJfVVJJX1JFR0VYOiAoKSA9PiBLcixcbiAgcGFyc2U6ICgpID0+IHJoLFxuICB0ZXN0OiAoKSA9PiB0aFxufSk7XG52YXIgS3IgPSBuZXcgUmVnRXhwKGBub3N0cjooJHt2YS5zb3VyY2V9KWApO1xuZnVuY3Rpb24gdGgodCkge1xuICByZXR1cm4gdHlwZW9mIHQgPT0gXCJzdHJpbmdcIiAmJiBuZXcgUmVnRXhwKGBeJHtLci5zb3VyY2V9JGApLnRlc3QodCk7XG59XG5mdW5jdGlvbiByaCh0KSB7XG4gIGNvbnN0IGUgPSB0Lm1hdGNoKG5ldyBSZWdFeHAoYF4ke0tyLnNvdXJjZX0kYCkpO1xuICBpZiAoIWUpXG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIE5vc3RyIFVSSTogJHt0fWApO1xuICByZXR1cm4ge1xuICAgIHVyaTogZVswXSxcbiAgICB2YWx1ZTogZVsxXSxcbiAgICBkZWNvZGVkOiBEcihlWzFdKVxuICB9O1xufVxudmFyIG5oID0ge307XG5pZShuaCwge1xuICBmaW5pc2hSZWFjdGlvbkV2ZW50OiAoKSA9PiBpaCxcbiAgZ2V0UmVhY3RlZEV2ZW50UG9pbnRlcjogKCkgPT4gb2hcbn0pO1xuZnVuY3Rpb24gaWgodCwgZSwgcikge1xuICB2YXIgaSwgcztcbiAgY29uc3QgbiA9IGUudGFncy5maWx0ZXIoXG4gICAgKG8pID0+IG8ubGVuZ3RoID49IDIgJiYgKG9bMF0gPT09IFwiZVwiIHx8IG9bMF0gPT09IFwicFwiKVxuICApO1xuICByZXR1cm4gZGEoe1xuICAgIC4uLnQsXG4gICAga2luZDogNyxcbiAgICB0YWdzOiBbXG4gICAgICAuLi4oaSA9IHQudGFncykgIT0gbnVsbCA/IGkgOiBbXSxcbiAgICAgIC4uLm4sXG4gICAgICBbXCJlXCIsIGUuaWRdLFxuICAgICAgW1wicFwiLCBlLnB1YmtleV1cbiAgICBdLFxuICAgIGNvbnRlbnQ6IChzID0gdC5jb250ZW50KSAhPSBudWxsID8gcyA6IFwiK1wiXG4gIH0sIHIpO1xufVxuZnVuY3Rpb24gb2godCkge1xuICBpZiAodC5raW5kICE9PSA3KVxuICAgIHJldHVybjtcbiAgbGV0IGUsIHI7XG4gIGZvciAobGV0IG4gPSB0LnRhZ3MubGVuZ3RoIC0gMTsgbiA+PSAwICYmIChlID09PSB2b2lkIDAgfHwgciA9PT0gdm9pZCAwKTsgbi0tKSB7XG4gICAgY29uc3QgaSA9IHQudGFnc1tuXTtcbiAgICBpLmxlbmd0aCA+PSAyICYmIChpWzBdID09PSBcImVcIiAmJiBlID09PSB2b2lkIDAgPyBlID0gaSA6IGlbMF0gPT09IFwicFwiICYmIHIgPT09IHZvaWQgMCAmJiAociA9IGkpKTtcbiAgfVxuICBpZiAoIShlID09PSB2b2lkIDAgfHwgciA9PT0gdm9pZCAwKSlcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IGVbMV0sXG4gICAgICByZWxheXM6IFtlWzJdLCByWzJdXS5maWx0ZXIoKG4pID0+IG4gIT09IHZvaWQgMCksXG4gICAgICBhdXRob3I6IHJbMV1cbiAgICB9O1xufVxudmFyIHNoID0ge307XG5pZShzaCwge1xuICBjcmVhdGVEZWxlZ2F0aW9uOiAoKSA9PiBhaCxcbiAgZ2V0RGVsZWdhdG9yOiAoKSA9PiBjaFxufSk7XG5mdW5jdGlvbiBhaCh0LCBlKSB7XG4gIGxldCByID0gW107XG4gIChlLmtpbmQgfHwgLTEpID49IDAgJiYgci5wdXNoKGBraW5kPSR7ZS5raW5kfWApLCBlLnVudGlsICYmIHIucHVzaChgY3JlYXRlZF9hdDwke2UudW50aWx9YCksIGUuc2luY2UgJiYgci5wdXNoKGBjcmVhdGVkX2F0PiR7ZS5zaW5jZX1gKTtcbiAgbGV0IG4gPSByLmpvaW4oXCImXCIpO1xuICBpZiAobiA9PT0gXCJcIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZWZ1c2luZyB0byBjcmVhdGUgYSBkZWxlZ2F0aW9uIHdpdGhvdXQgYW55IGNvbmRpdGlvbnNcIik7XG4gIGxldCBpID0gWW4oXG4gICAgSWUuZW5jb2RlKGBub3N0cjpkZWxlZ2F0aW9uOiR7ZS5wdWJrZXl9OiR7bn1gKVxuICApLCBzID0gdmUoXG4gICAgU3Quc2lnbihpLCB0KVxuICApO1xuICByZXR1cm4ge1xuICAgIGZyb206IGxpKHQpLFxuICAgIHRvOiBlLnB1YmtleSxcbiAgICBjb25kOiBuLFxuICAgIHNpZzogc1xuICB9O1xufVxuZnVuY3Rpb24gY2godCkge1xuICBsZXQgZSA9IHQudGFncy5maW5kKChhKSA9PiBhWzBdID09PSBcImRlbGVnYXRpb25cIiAmJiBhLmxlbmd0aCA+PSA0KTtcbiAgaWYgKCFlKVxuICAgIHJldHVybiBudWxsO1xuICBsZXQgciA9IGVbMV0sIG4gPSBlWzJdLCBpID0gZVszXSwgcyA9IG4uc3BsaXQoXCImXCIpO1xuICBmb3IgKGxldCBhID0gMDsgYSA8IHMubGVuZ3RoOyBhKyspIHtcbiAgICBsZXQgW2MsIGwsIGZdID0gc1thXS5zcGxpdCgvXFxiLyk7XG4gICAgaWYgKCEoYyA9PT0gXCJraW5kXCIgJiYgbCA9PT0gXCI9XCIgJiYgdC5raW5kID09PSBwYXJzZUludChmKSkpIHtcbiAgICAgIGlmIChjID09PSBcImNyZWF0ZWRfYXRcIiAmJiBsID09PSBcIjxcIiAmJiB0LmNyZWF0ZWRfYXQgPCBwYXJzZUludChmKSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBpZiAoYyA9PT0gXCJjcmVhdGVkX2F0XCIgJiYgbCA9PT0gXCI+XCIgJiYgdC5jcmVhdGVkX2F0ID4gcGFyc2VJbnQoZikpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIGxldCBvID0gWW4oXG4gICAgSWUuZW5jb2RlKGBub3N0cjpkZWxlZ2F0aW9uOiR7dC5wdWJrZXl9OiR7bn1gKVxuICApO1xuICByZXR1cm4gU3QudmVyaWZ5KGksIG8sIHIpID8gciA6IG51bGw7XG59XG52YXIgdWggPSB7fTtcbmllKHVoLCB7XG4gIG1hdGNoQWxsOiAoKSA9PiBsaCxcbiAgcmVnZXg6ICgpID0+IHBpLFxuICByZXBsYWNlQWxsOiAoKSA9PiBmaFxufSk7XG52YXIgcGkgPSAoKSA9PiBuZXcgUmVnRXhwKGBcXFxcYiR7S3Iuc291cmNlfVxcXFxiYCwgXCJnXCIpO1xuZnVuY3Rpb24qIGxoKHQpIHtcbiAgY29uc3QgZSA9IHQubWF0Y2hBbGwocGkoKSk7XG4gIGZvciAoY29uc3QgciBvZiBlKSB7XG4gICAgY29uc3QgW24sIGldID0gcjtcbiAgICB5aWVsZCB7XG4gICAgICB1cmk6IG4sXG4gICAgICB2YWx1ZTogaSxcbiAgICAgIGRlY29kZWQ6IERyKGkpLFxuICAgICAgc3RhcnQ6IHIuaW5kZXgsXG4gICAgICBlbmQ6IHIuaW5kZXggKyBuLmxlbmd0aFxuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIGZoKHQsIGUpIHtcbiAgcmV0dXJuIHQucmVwbGFjZUFsbChwaSgpLCAociwgbikgPT4gZSh7XG4gICAgdXJpOiByLFxuICAgIHZhbHVlOiBuLFxuICAgIGRlY29kZWQ6IERyKG4pXG4gIH0pKTtcbn1cbnZhciBoaCA9IHt9O1xuaWUoaGgsIHtcbiAgdXNlRmV0Y2hJbXBsZW1lbnRhdGlvbjogKCkgPT4gZGgsXG4gIHZhbGlkYXRlR2l0aHViOiAoKSA9PiBwaFxufSk7XG52YXIgeWk7XG50cnkge1xuICB5aSA9IGZldGNoO1xufSBjYXRjaCB7XG59XG5mdW5jdGlvbiBkaCh0KSB7XG4gIHlpID0gdDtcbn1cbmFzeW5jIGZ1bmN0aW9uIHBoKHQsIGUsIHIpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgKGF3YWl0IHlpKGBodHRwczovL2dpc3QuZ2l0aHViLmNvbS8ke2V9LyR7cn0vcmF3YCkpLnRleHQoKSA9PT0gYFZlcmlmeWluZyB0aGF0IEkgY29udHJvbCB0aGUgZm9sbG93aW5nIE5vc3RyIHB1YmxpYyBrZXk6ICR7dH1gO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gITE7XG4gIH1cbn1cbnZhciB5aCA9IHt9O1xuaWUoeWgsIHtcbiAgYXV0aGVudGljYXRlOiAoKSA9PiBnaFxufSk7XG52YXIgZ2ggPSBhc3luYyAoe1xuICBjaGFsbGVuZ2U6IHQsXG4gIHJlbGF5OiBlLFxuICBzaWduOiByXG59KSA9PiB7XG4gIGNvbnN0IG4gPSB7XG4gICAga2luZDogMjIyNDIsXG4gICAgY3JlYXRlZF9hdDogTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMWUzKSxcbiAgICB0YWdzOiBbXG4gICAgICBbXCJyZWxheVwiLCBlLnVybF0sXG4gICAgICBbXCJjaGFsbGVuZ2VcIiwgdF1cbiAgICBdLFxuICAgIGNvbnRlbnQ6IFwiXCJcbiAgfSwgaSA9IGUuYXV0aChhd2FpdCByKG4pKTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChzLCBvKSA9PiB7XG4gICAgaS5vbihcIm9rXCIsIGZ1bmN0aW9uIGEoKSB7XG4gICAgICBpLm9mZihcIm9rXCIsIGEpLCBzKCk7XG4gICAgfSksIGkub24oXCJmYWlsZWRcIiwgZnVuY3Rpb24gYShjKSB7XG4gICAgICBpLm9mZihcImZhaWxlZFwiLCBhKSwgbyhjKTtcbiAgICB9KTtcbiAgfSk7XG59LCBFYSA9IHt9O1xuaWUoRWEsIHtcbiAgZ2V0WmFwRW5kcG9pbnQ6ICgpID0+IHZoLFxuICBtYWtlWmFwUmVjZWlwdDogKCkgPT4gbWgsXG4gIG1ha2VaYXBSZXF1ZXN0OiAoKSA9PiB3aCxcbiAgdXNlRmV0Y2hJbXBsZW1lbnRhdGlvbjogKCkgPT4gYmgsXG4gIHZhbGlkYXRlWmFwUmVxdWVzdDogKCkgPT4gX2hcbn0pO1xudmFyIGdpO1xudHJ5IHtcbiAgZ2kgPSBmZXRjaDtcbn0gY2F0Y2gge1xufVxuZnVuY3Rpb24gYmgodCkge1xuICBnaSA9IHQ7XG59XG5hc3luYyBmdW5jdGlvbiB2aCh0KSB7XG4gIHRyeSB7XG4gICAgbGV0IGUgPSBcIlwiLCB7IGx1ZDA2OiByLCBsdWQxNjogbiB9ID0gSlNPTi5wYXJzZSh0LmNvbnRlbnQpO1xuICAgIGlmIChyKSB7XG4gICAgICBsZXQgeyB3b3JkczogbyB9ID0gdGUuZGVjb2RlKHIsIDFlMyksIGEgPSB0ZS5mcm9tV29yZHMobyk7XG4gICAgICBlID0gSmUuZGVjb2RlKGEpO1xuICAgIH0gZWxzZSBpZiAobikge1xuICAgICAgbGV0IFtvLCBhXSA9IG4uc3BsaXQoXCJAXCIpO1xuICAgICAgZSA9IGBodHRwczovLyR7YX0vLndlbGwta25vd24vbG51cmxwLyR7b31gO1xuICAgIH0gZWxzZVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHMgPSBhd2FpdCAoYXdhaXQgZ2koZSkpLmpzb24oKTtcbiAgICBpZiAocy5hbGxvd3NOb3N0ciAmJiBzLm5vc3RyUHVia2V5KVxuICAgICAgcmV0dXJuIHMuY2FsbGJhY2s7XG4gIH0gY2F0Y2gge1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gd2goe1xuICBwcm9maWxlOiB0LFxuICBldmVudDogZSxcbiAgYW1vdW50OiByLFxuICByZWxheXM6IG4sXG4gIGNvbW1lbnQ6IGkgPSBcIlwiXG59KSB7XG4gIGlmICghcilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJhbW91bnQgbm90IGdpdmVuXCIpO1xuICBpZiAoIXQpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwicHJvZmlsZSBub3QgZ2l2ZW5cIik7XG4gIGxldCBzID0ge1xuICAgIGtpbmQ6IDk3MzQsXG4gICAgY3JlYXRlZF9hdDogTWF0aC5yb3VuZChEYXRlLm5vdygpIC8gMWUzKSxcbiAgICBjb250ZW50OiBpLFxuICAgIHRhZ3M6IFtcbiAgICAgIFtcInBcIiwgdF0sXG4gICAgICBbXCJhbW91bnRcIiwgci50b1N0cmluZygpXSxcbiAgICAgIFtcInJlbGF5c1wiLCAuLi5uXVxuICAgIF1cbiAgfTtcbiAgcmV0dXJuIGUgJiYgcy50YWdzLnB1c2goW1wiZVwiLCBlXSksIHM7XG59XG5mdW5jdGlvbiBfaCh0KSB7XG4gIGxldCBlO1xuICB0cnkge1xuICAgIGUgPSBKU09OLnBhcnNlKHQpO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gXCJJbnZhbGlkIHphcCByZXF1ZXN0IEpTT04uXCI7XG4gIH1cbiAgaWYgKCFmaShlKSlcbiAgICByZXR1cm4gXCJaYXAgcmVxdWVzdCBpcyBub3QgYSB2YWxpZCBOb3N0ciBldmVudC5cIjtcbiAgaWYgKCFoaShlKSlcbiAgICByZXR1cm4gXCJJbnZhbGlkIHNpZ25hdHVyZSBvbiB6YXAgcmVxdWVzdC5cIjtcbiAgbGV0IHIgPSBlLnRhZ3MuZmluZCgoW3MsIG9dKSA9PiBzID09PSBcInBcIiAmJiBvKTtcbiAgaWYgKCFyKVxuICAgIHJldHVybiBcIlphcCByZXF1ZXN0IGRvZXNuJ3QgaGF2ZSBhICdwJyB0YWcuXCI7XG4gIGlmICghclsxXS5tYXRjaCgvXlthLWYwLTldezY0fSQvKSlcbiAgICByZXR1cm4gXCJaYXAgcmVxdWVzdCAncCcgdGFnIGlzIG5vdCB2YWxpZCBoZXguXCI7XG4gIGxldCBuID0gZS50YWdzLmZpbmQoKFtzLCBvXSkgPT4gcyA9PT0gXCJlXCIgJiYgbyk7XG4gIHJldHVybiBuICYmICFuWzFdLm1hdGNoKC9eW2EtZjAtOV17NjR9JC8pID8gXCJaYXAgcmVxdWVzdCAnZScgdGFnIGlzIG5vdCB2YWxpZCBoZXguXCIgOiBlLnRhZ3MuZmluZCgoW3MsIG9dKSA9PiBzID09PSBcInJlbGF5c1wiICYmIG8pID8gbnVsbCA6IFwiWmFwIHJlcXVlc3QgZG9lc24ndCBoYXZlIGEgJ3JlbGF5cycgdGFnLlwiO1xufVxuZnVuY3Rpb24gbWgoe1xuICB6YXBSZXF1ZXN0OiB0LFxuICBwcmVpbWFnZTogZSxcbiAgYm9sdDExOiByLFxuICBwYWlkQXQ6IG5cbn0pIHtcbiAgbGV0IHMgPSBKU09OLnBhcnNlKHQpLnRhZ3MuZmlsdGVyKFxuICAgIChbYV0pID0+IGEgPT09IFwiZVwiIHx8IGEgPT09IFwicFwiIHx8IGEgPT09IFwiYVwiXG4gICksIG8gPSB7XG4gICAga2luZDogOTczNSxcbiAgICBjcmVhdGVkX2F0OiBNYXRoLnJvdW5kKG4uZ2V0VGltZSgpIC8gMWUzKSxcbiAgICBjb250ZW50OiBcIlwiLFxuICAgIHRhZ3M6IFtcbiAgICAgIC4uLnMsXG4gICAgICBbXCJib2x0MTFcIiwgcl0sXG4gICAgICBbXCJkZXNjcmlwdGlvblwiLCB0XVxuICAgIF1cbiAgfTtcbiAgcmV0dXJuIGUgJiYgby50YWdzLnB1c2goW1wicHJlaW1hZ2VcIiwgZV0pLCBvO1xufVxudmFyIGNyID0ge307XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoY3IsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbmNyLmlzX25vZGUgPSB2b2lkIDA7XG52YXIgZG4gPSBudWxsO1xuZnVuY3Rpb24geGgoKSB7XG4gIHJldHVybiBkbiA9PT0gbnVsbCAmJiAoZG4gPSB0eXBlb2YgUyA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBTLnByb2Nlc3MgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUy5wcm9jZXNzLnZlcnNpb25zID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFMucHJvY2Vzcy52ZXJzaW9ucy5ub2RlIDwgXCJ1XCIpLCBkbjtcbn1cbmNyLmlzX25vZGUgPSB4aDtcbnZhciBwbiA9IHt9LCB5biwgWGk7XG5mdW5jdGlvbiBFaCgpIHtcbiAgaWYgKFhpKVxuICAgIHJldHVybiB5bjtcbiAgWGkgPSAxO1xuICB2YXIgdCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0eXBlb2Ygc2VsZiA9PSBcIm9iamVjdFwiICYmIHNlbGYpXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PSBcIm9iamVjdFwiICYmIHdpbmRvdylcbiAgICAgIHJldHVybiB3aW5kb3c7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIHJlc29sdmUgZ2xvYmFsIGB0aGlzYFwiKTtcbiAgfTtcbiAgcmV0dXJuIHluID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMpXG4gICAgICByZXR1cm4gdGhpcztcbiAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT0gXCJvYmplY3RcIiAmJiBnbG9iYWxUaGlzKVxuICAgICAgcmV0dXJuIGdsb2JhbFRoaXM7XG4gICAgdHJ5IHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3QucHJvdG90eXBlLCBcIl9fZ2xvYmFsX19cIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiB0KCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gX19nbG9iYWxfXyB8fCB0KCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGRlbGV0ZSBPYmplY3QucHJvdG90eXBlLl9fZ2xvYmFsX187XG4gICAgfVxuICB9KCksIHluO1xufVxuY29uc3Qga2ggPSBcIndlYnNvY2tldFwiLCBTaCA9IFwiV2Vic29ja2V0IENsaWVudCAmIFNlcnZlciBMaWJyYXJ5IGltcGxlbWVudGluZyB0aGUgV2ViU29ja2V0IHByb3RvY29sIGFzIHNwZWNpZmllZCBpbiBSRkMgNjQ1NS5cIiwgT2ggPSBbXG4gIFwid2Vic29ja2V0XCIsXG4gIFwid2Vic29ja2V0c1wiLFxuICBcInNvY2tldFwiLFxuICBcIm5ldHdvcmtpbmdcIixcbiAgXCJjb21ldFwiLFxuICBcInB1c2hcIixcbiAgXCJSRkMtNjQ1NVwiLFxuICBcInJlYWx0aW1lXCIsXG4gIFwic2VydmVyXCIsXG4gIFwiY2xpZW50XCJcbl0sIEFoID0gXCJCcmlhbiBNY0tlbHZleSA8dGhldHVydGxlMzJAZ21haWwuY29tPiAoaHR0cHM6Ly9naXRodWIuY29tL3RoZXR1cnRsZTMyKVwiLCBDaCA9IFtcbiAgXCJJXFx4RjFha2kgQmF6IENhc3RpbGxvIDxpYmNAYWxpYXgubmV0PiAoaHR0cDovL2Rldi5zaXBkb2MubmV0KVwiXG5dLCBJaCA9IFwiMS4wLjM0XCIsIFJoID0ge1xuICB0eXBlOiBcImdpdFwiLFxuICB1cmw6IFwiaHR0cHM6Ly9naXRodWIuY29tL3RoZXR1cnRsZTMyL1dlYlNvY2tldC1Ob2RlLmdpdFwiXG59LCBUaCA9IFwiaHR0cHM6Ly9naXRodWIuY29tL3RoZXR1cnRsZTMyL1dlYlNvY2tldC1Ob2RlXCIsIFBoID0ge1xuICBub2RlOiBcIj49NC4wLjBcIlxufSwgQmggPSB7XG4gIGJ1ZmZlcnV0aWw6IFwiXjQuMC4xXCIsXG4gIGRlYnVnOiBcIl4yLjIuMFwiLFxuICBcImVzNS1leHRcIjogXCJeMC4xMC41MFwiLFxuICBcInR5cGVkYXJyYXktdG8tYnVmZmVyXCI6IFwiXjMuMS41XCIsXG4gIFwidXRmLTgtdmFsaWRhdGVcIjogXCJeNS4wLjJcIixcbiAgeWFldGk6IFwiXjAuMC42XCJcbn0sIExoID0ge1xuICBcImJ1ZmZlci1lcXVhbFwiOiBcIl4xLjAuMFwiLFxuICBndWxwOiBcIl40LjAuMlwiLFxuICBcImd1bHAtanNoaW50XCI6IFwiXjIuMC40XCIsXG4gIFwianNoaW50LXN0eWxpc2hcIjogXCJeMi4yLjFcIixcbiAganNoaW50OiBcIl4yLjAuMFwiLFxuICB0YXBlOiBcIl40LjkuMVwiXG59LCAkaCA9IHtcbiAgdmVyYm9zZTogITFcbn0sIHFoID0ge1xuICB0ZXN0OiBcInRhcGUgdGVzdC91bml0LyouanNcIixcbiAgZ3VscDogXCJndWxwXCJcbn0sIE5oID0gXCJpbmRleFwiLCBVaCA9IHtcbiAgbGliOiBcIi4vbGliXCJcbn0sIGpoID0gXCJsaWIvYnJvd3Nlci5qc1wiLCBIaCA9IFwiQXBhY2hlLTIuMFwiLCBNaCA9IHtcbiAgbmFtZToga2gsXG4gIGRlc2NyaXB0aW9uOiBTaCxcbiAga2V5d29yZHM6IE9oLFxuICBhdXRob3I6IEFoLFxuICBjb250cmlidXRvcnM6IENoLFxuICB2ZXJzaW9uOiBJaCxcbiAgcmVwb3NpdG9yeTogUmgsXG4gIGhvbWVwYWdlOiBUaCxcbiAgZW5naW5lczogUGgsXG4gIGRlcGVuZGVuY2llczogQmgsXG4gIGRldkRlcGVuZGVuY2llczogTGgsXG4gIGNvbmZpZzogJGgsXG4gIHNjcmlwdHM6IHFoLFxuICBtYWluOiBOaCxcbiAgZGlyZWN0b3JpZXM6IFVoLFxuICBicm93c2VyOiBqaCxcbiAgbGljZW5zZTogSGhcbn07XG52YXIgZ24sIFFpO1xuZnVuY3Rpb24gRGgoKSB7XG4gIHJldHVybiBRaSB8fCAoUWkgPSAxLCBnbiA9IE1oLnZlcnNpb24pLCBnbjtcbn1cbnZhciBibiwgZW87XG5mdW5jdGlvbiB6aCgpIHtcbiAgaWYgKGVvKVxuICAgIHJldHVybiBibjtcbiAgZW8gPSAxO1xuICB2YXIgdDtcbiAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzID09IFwib2JqZWN0XCIpXG4gICAgdCA9IGdsb2JhbFRoaXM7XG4gIGVsc2VcbiAgICB0cnkge1xuICAgICAgdCA9IEVoKCk7XG4gICAgfSBjYXRjaCB7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmICghdCAmJiB0eXBlb2Ygd2luZG93IDwgXCJ1XCIgJiYgKHQgPSB3aW5kb3cpLCAhdClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGRldGVybWluZSBnbG9iYWwgdGhpc1wiKTtcbiAgICB9XG4gIHZhciBlID0gdC5XZWJTb2NrZXQgfHwgdC5Nb3pXZWJTb2NrZXQsIHIgPSBEaCgpO1xuICBmdW5jdGlvbiBuKGksIHMpIHtcbiAgICB2YXIgbztcbiAgICByZXR1cm4gcyA/IG8gPSBuZXcgZShpLCBzKSA6IG8gPSBuZXcgZShpKSwgbztcbiAgfVxuICByZXR1cm4gZSAmJiBbXCJDT05ORUNUSU5HXCIsIFwiT1BFTlwiLCBcIkNMT1NJTkdcIiwgXCJDTE9TRURcIl0uZm9yRWFjaChmdW5jdGlvbihpKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIGksIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBlW2ldO1xuICAgICAgfVxuICAgIH0pO1xuICB9KSwgYm4gPSB7XG4gICAgdzNjd2Vic29ja2V0OiBlID8gbiA6IG51bGwsXG4gICAgdmVyc2lvbjogclxuICB9LCBibjtcbn1cbnZhciBfciA9IHt9LCB2biA9IHt9LCBSdCA9IHt9LCBUdCA9IHt9LCBQdCA9IHt9LCBCdCA9IHt9LCB0bztcbmZ1bmN0aW9uIEZoKCkge1xuICBpZiAodG8pXG4gICAgcmV0dXJuIEJ0O1xuICB0byA9IDEsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBCdC5Gb3JPZkFkYXB0b3IgPSB2b2lkIDA7XG4gIHZhciB0ID0gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gZShyLCBuKSB7XG4gICAgICB0aGlzLml0XyA9IHIsIHRoaXMubGFzdF8gPSBuO1xuICAgIH1cbiAgICByZXR1cm4gZS5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuaXRfLmVxdWFscyh0aGlzLmxhc3RfKSlcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkb25lOiAhMCxcbiAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH07XG4gICAgICB2YXIgciA9IHRoaXMuaXRfO1xuICAgICAgcmV0dXJuIHRoaXMuaXRfID0gdGhpcy5pdF8ubmV4dCgpLCB7XG4gICAgICAgIGRvbmU6ICExLFxuICAgICAgICB2YWx1ZTogci52YWx1ZVxuICAgICAgfTtcbiAgICB9LCBlLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LCBlO1xuICB9KCk7XG4gIHJldHVybiBCdC5Gb3JPZkFkYXB0b3IgPSB0LCBCdDtcbn1cbnZhciBybztcbmZ1bmN0aW9uIGJpKCkge1xuICBpZiAocm8pXG4gICAgcmV0dXJuIFB0O1xuICBybyA9IDE7XG4gIHZhciB0ID0gUyAmJiBTLl9fdmFsdWVzIHx8IGZ1bmN0aW9uKG4pIHtcbiAgICB2YXIgaSA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgcyA9IGkgJiYgbltpXSwgbyA9IDA7XG4gICAgaWYgKHMpXG4gICAgICByZXR1cm4gcy5jYWxsKG4pO1xuICAgIGlmIChuICYmIHR5cGVvZiBuLmxlbmd0aCA9PSBcIm51bWJlclwiKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIG4gJiYgbyA+PSBuLmxlbmd0aCAmJiAobiA9IHZvaWQgMCksIHsgdmFsdWU6IG4gJiYgbltvKytdLCBkb25lOiAhbiB9O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoaSA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFB0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIFB0LkNvbnRhaW5lciA9IHZvaWQgMDtcbiAgdmFyIGUgPSBGaCgpLCByID0gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gbigpIHtcbiAgICB9XG4gICAgcmV0dXJuIG4ucHJvdG90eXBlLmVtcHR5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5zaXplKCkgPT09IDA7XG4gICAgfSwgbi5wcm90b3R5cGUucmJlZ2luID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmQoKS5yZXZlcnNlKCk7XG4gICAgfSwgbi5wcm90b3R5cGUucmVuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYmVnaW4oKS5yZXZlcnNlKCk7XG4gICAgfSwgbi5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBlLkZvck9mQWRhcHRvcih0aGlzLmJlZ2luKCksIHRoaXMuZW5kKCkpO1xuICAgIH0sIG4ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGksIHMsIG8gPSBbXTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIGEgPSB0KHRoaXMpLCBjID0gYS5uZXh0KCk7ICFjLmRvbmU7IGMgPSBhLm5leHQoKSkge1xuICAgICAgICAgIHZhciBsID0gYy52YWx1ZTtcbiAgICAgICAgICBvLnB1c2gobCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGYpIHtcbiAgICAgICAgaSA9IHsgZXJyb3I6IGYgfTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYyAmJiAhYy5kb25lICYmIChzID0gYS5yZXR1cm4pICYmIHMuY2FsbChhKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoaSlcbiAgICAgICAgICAgIHRocm93IGkuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvO1xuICAgIH0sIG47XG4gIH0oKTtcbiAgcmV0dXJuIFB0LkNvbnRhaW5lciA9IHIsIFB0O1xufVxudmFyIEx0ID0ge30sIG5vO1xuZnVuY3Rpb24gdmkoKSB7XG4gIGlmIChubylcbiAgICByZXR1cm4gTHQ7XG4gIG5vID0gMTtcbiAgdmFyIHQgPSBTICYmIFMuX19yZWFkIHx8IGZ1bmN0aW9uKHIsIG4pIHtcbiAgICB2YXIgaSA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIHJbU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIWkpXG4gICAgICByZXR1cm4gcjtcbiAgICB2YXIgcyA9IGkuY2FsbChyKSwgbywgYSA9IFtdLCBjO1xuICAgIHRyeSB7XG4gICAgICBmb3IgKDsgKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKG8gPSBzLm5leHQoKSkuZG9uZTsgKVxuICAgICAgICBhLnB1c2goby52YWx1ZSk7XG4gICAgfSBjYXRjaCAobCkge1xuICAgICAgYyA9IHsgZXJyb3I6IGwgfTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbyAmJiAhby5kb25lICYmIChpID0gcy5yZXR1cm4pICYmIGkuY2FsbChzKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChjKVxuICAgICAgICAgIHRocm93IGMuZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTHQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgTHQuTmF0aXZlQXJyYXlJdGVyYXRvciA9IHZvaWQgMDtcbiAgdmFyIGUgPSBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiByKG4sIGkpIHtcbiAgICAgIHRoaXMuZGF0YV8gPSBuLCB0aGlzLmluZGV4XyA9IGk7XG4gICAgfVxuICAgIHJldHVybiByLnByb3RvdHlwZS5pbmRleCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW5kZXhfO1xuICAgIH0sIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhX1t0aGlzLmluZGV4X107XG4gICAgICB9LFxuICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgfSksIHIucHJvdG90eXBlLnByZXYgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAtLXRoaXMuaW5kZXhfLCB0aGlzO1xuICAgIH0sIHIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiArK3RoaXMuaW5kZXhfLCB0aGlzO1xuICAgIH0sIHIucHJvdG90eXBlLmFkdmFuY2UgPSBmdW5jdGlvbihuKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbmRleF8gKz0gbiwgdGhpcztcbiAgICB9LCByLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbihuKSB7XG4gICAgICByZXR1cm4gdGhpcy5kYXRhXyA9PT0gbi5kYXRhXyAmJiB0aGlzLmluZGV4XyA9PT0gbi5pbmRleF87XG4gICAgfSwgci5wcm90b3R5cGUuc3dhcCA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgIHZhciBpLCBzO1xuICAgICAgaSA9IHQoW24uZGF0YV8sIHRoaXMuZGF0YV9dLCAyKSwgdGhpcy5kYXRhXyA9IGlbMF0sIG4uZGF0YV8gPSBpWzFdLCBzID0gdChbbi5pbmRleF8sIHRoaXMuaW5kZXhfXSwgMiksIHRoaXMuaW5kZXhfID0gc1swXSwgbi5pbmRleF8gPSBzWzFdO1xuICAgIH0sIHI7XG4gIH0oKTtcbiAgcmV0dXJuIEx0Lk5hdGl2ZUFycmF5SXRlcmF0b3IgPSBlLCBMdDtcbn1cbnZhciBpbztcbmZ1bmN0aW9uIEtoKCkge1xuICBpZiAoaW8pXG4gICAgcmV0dXJuIFR0O1xuICBpbyA9IDE7XG4gIHZhciB0ID0gUyAmJiBTLl9fZXh0ZW5kcyB8fCBmdW5jdGlvbigpIHtcbiAgICB2YXIgaSA9IGZ1bmN0aW9uKHMsIG8pIHtcbiAgICAgIHJldHVybiBpID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24oYSwgYykge1xuICAgICAgICBhLl9fcHJvdG9fXyA9IGM7XG4gICAgICB9IHx8IGZ1bmN0aW9uKGEsIGMpIHtcbiAgICAgICAgZm9yICh2YXIgbCBpbiBjKVxuICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjLCBsKSAmJiAoYVtsXSA9IGNbbF0pO1xuICAgICAgfSwgaShzLCBvKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbihzLCBvKSB7XG4gICAgICBpZiAodHlwZW9mIG8gIT0gXCJmdW5jdGlvblwiICYmIG8gIT09IG51bGwpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKG8pICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgIGkocywgbyk7XG4gICAgICBmdW5jdGlvbiBhKCkge1xuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yID0gcztcbiAgICAgIH1cbiAgICAgIHMucHJvdG90eXBlID0gbyA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUobykgOiAoYS5wcm90b3R5cGUgPSBvLnByb3RvdHlwZSwgbmV3IGEoKSk7XG4gICAgfTtcbiAgfSgpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVHQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgVHQuU2V0Q29udGFpbmVyID0gdm9pZCAwO1xuICB2YXIgZSA9IGJpKCksIHIgPSB2aSgpLCBuID0gZnVuY3Rpb24oaSkge1xuICAgIHQocywgaSk7XG4gICAgZnVuY3Rpb24gcyhvKSB7XG4gICAgICB2YXIgYSA9IGkuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgcmV0dXJuIGEuZGF0YV8gPSBvKGEpLCBhO1xuICAgIH1cbiAgICByZXR1cm4gcy5wcm90b3R5cGUuYXNzaWduID0gZnVuY3Rpb24obywgYSkge1xuICAgICAgdGhpcy5jbGVhcigpLCB0aGlzLmluc2VydChvLCBhKTtcbiAgICB9LCBzLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kYXRhXy5jbGVhcigpO1xuICAgIH0sIHMucHJvdG90eXBlLmJlZ2luID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5kYXRhXy5iZWdpbigpO1xuICAgIH0sIHMucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGF0YV8uZW5kKCk7XG4gICAgfSwgcy5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24obykge1xuICAgICAgcmV0dXJuICF0aGlzLmZpbmQobykuZXF1YWxzKHRoaXMuZW5kKCkpO1xuICAgIH0sIHMucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmRhdGFfLnNpemUoKTtcbiAgICB9LCBzLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oKSB7XG4gICAgICBmb3IgKHZhciBvID0gW10sIGEgPSAwOyBhIDwgYXJndW1lbnRzLmxlbmd0aDsgYSsrKVxuICAgICAgICBvW2FdID0gYXJndW1lbnRzW2FdO1xuICAgICAgaWYgKG8ubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gdGhpcy5zaXplKCk7XG4gICAgICB2YXIgYyA9IG5ldyByLk5hdGl2ZUFycmF5SXRlcmF0b3IobywgMCksIGwgPSBuZXcgci5OYXRpdmVBcnJheUl0ZXJhdG9yKG8sIG8ubGVuZ3RoKTtcbiAgICAgIHJldHVybiB0aGlzLl9JbnNlcnRfYnlfcmFuZ2UoYywgbCksIHRoaXMuc2l6ZSgpO1xuICAgIH0sIHMucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgZm9yICh2YXIgbyA9IFtdLCBhID0gMDsgYSA8IGFyZ3VtZW50cy5sZW5ndGg7IGErKylcbiAgICAgICAgb1thXSA9IGFyZ3VtZW50c1thXTtcbiAgICAgIHJldHVybiBvLmxlbmd0aCA9PT0gMSA/IHRoaXMuX0luc2VydF9ieV9rZXkob1swXSkgOiBvWzBdLm5leHQgaW5zdGFuY2VvZiBGdW5jdGlvbiAmJiBvWzFdLm5leHQgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IHRoaXMuX0luc2VydF9ieV9yYW5nZShvWzBdLCBvWzFdKSA6IHRoaXMuX0luc2VydF9ieV9oaW50KG9bMF0sIG9bMV0pO1xuICAgIH0sIHMucHJvdG90eXBlLmVyYXNlID0gZnVuY3Rpb24oKSB7XG4gICAgICBmb3IgKHZhciBvID0gW10sIGEgPSAwOyBhIDwgYXJndW1lbnRzLmxlbmd0aDsgYSsrKVxuICAgICAgICBvW2FdID0gYXJndW1lbnRzW2FdO1xuICAgICAgcmV0dXJuIG8ubGVuZ3RoID09PSAxICYmICEob1swXSBpbnN0YW5jZW9mIHRoaXMuZW5kKCkuY29uc3RydWN0b3IgJiYgb1swXS5zb3VyY2UoKSA9PT0gdGhpcykgPyB0aGlzLl9FcmFzZV9ieV92YWwob1swXSkgOiBvLmxlbmd0aCA9PT0gMSA/IHRoaXMuX0VyYXNlX2J5X3JhbmdlKG9bMF0pIDogdGhpcy5fRXJhc2VfYnlfcmFuZ2Uob1swXSwgb1sxXSk7XG4gICAgfSwgcy5wcm90b3R5cGUuX0VyYXNlX2J5X3JhbmdlID0gZnVuY3Rpb24obywgYSkge1xuICAgICAgYSA9PT0gdm9pZCAwICYmIChhID0gby5uZXh0KCkpO1xuICAgICAgdmFyIGMgPSB0aGlzLmRhdGFfLmVyYXNlKG8sIGEpO1xuICAgICAgcmV0dXJuIHRoaXMuX0hhbmRsZV9lcmFzZShvLCBhKSwgYztcbiAgICB9LCBzO1xuICB9KGUuQ29udGFpbmVyKTtcbiAgcmV0dXJuIFR0LlNldENvbnRhaW5lciA9IG4sIFR0O1xufVxudmFyIHduID0ge30sICR0ID0ge30sIHF0ID0ge30sIE50ID0ge30sIG9vO1xuZnVuY3Rpb24gV2goKSB7XG4gIGlmIChvbylcbiAgICByZXR1cm4gTnQ7XG4gIG9vID0gMTtcbiAgdmFyIHQgPSBTICYmIFMuX19leHRlbmRzIHx8IGZ1bmN0aW9uKCkge1xuICAgIHZhciByID0gZnVuY3Rpb24obiwgaSkge1xuICAgICAgcmV0dXJuIHIgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbihzLCBvKSB7XG4gICAgICAgIHMuX19wcm90b19fID0gbztcbiAgICAgIH0gfHwgZnVuY3Rpb24ocywgbykge1xuICAgICAgICBmb3IgKHZhciBhIGluIG8pXG4gICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIGEpICYmIChzW2FdID0gb1thXSk7XG4gICAgICB9LCByKG4sIGkpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG4sIGkpIHtcbiAgICAgIGlmICh0eXBlb2YgaSAhPSBcImZ1bmN0aW9uXCIgJiYgaSAhPT0gbnVsbClcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoaSkgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgcihuLCBpKTtcbiAgICAgIGZ1bmN0aW9uIHMoKSB7XG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IgPSBuO1xuICAgICAgfVxuICAgICAgbi5wcm90b3R5cGUgPSBpID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShpKSA6IChzLnByb3RvdHlwZSA9IGkucHJvdG90eXBlLCBuZXcgcygpKTtcbiAgICB9O1xuICB9KCk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShOdCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBOdC5FeGNlcHRpb24gPSB2b2lkIDA7XG4gIHZhciBlID0gZnVuY3Rpb24ocikge1xuICAgIHQobiwgcik7XG4gICAgZnVuY3Rpb24gbihpKSB7XG4gICAgICB2YXIgcyA9IHRoaXMuY29uc3RydWN0b3IsIG8gPSByLmNhbGwodGhpcywgaSkgfHwgdGhpcywgYSA9IHMucHJvdG90eXBlO1xuICAgICAgcmV0dXJuIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihvLCBhKSA6IG8uX19wcm90b19fID0gYSwgbztcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICB9LFxuICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgfSksIG4ucHJvdG90eXBlLndoYXQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2U7XG4gICAgfSwgbi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgICAgc3RhY2s6IHRoaXMuc3RhY2tcbiAgICAgIH07XG4gICAgfSwgbjtcbiAgfShFcnJvcik7XG4gIHJldHVybiBOdC5FeGNlcHRpb24gPSBlLCBOdDtcbn1cbnZhciBzbztcbmZ1bmN0aW9uIGthKCkge1xuICBpZiAoc28pXG4gICAgcmV0dXJuIHF0O1xuICBzbyA9IDE7XG4gIHZhciB0ID0gUyAmJiBTLl9fZXh0ZW5kcyB8fCBmdW5jdGlvbigpIHtcbiAgICB2YXIgbiA9IGZ1bmN0aW9uKGksIHMpIHtcbiAgICAgIHJldHVybiBuID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24obywgYSkge1xuICAgICAgICBvLl9fcHJvdG9fXyA9IGE7XG4gICAgICB9IHx8IGZ1bmN0aW9uKG8sIGEpIHtcbiAgICAgICAgZm9yICh2YXIgYyBpbiBhKVxuICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhLCBjKSAmJiAob1tjXSA9IGFbY10pO1xuICAgICAgfSwgbihpLCBzKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbihpLCBzKSB7XG4gICAgICBpZiAodHlwZW9mIHMgIT0gXCJmdW5jdGlvblwiICYmIHMgIT09IG51bGwpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKHMpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgIG4oaSwgcyk7XG4gICAgICBmdW5jdGlvbiBvKCkge1xuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yID0gaTtcbiAgICAgIH1cbiAgICAgIGkucHJvdG90eXBlID0gcyA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUocykgOiAoby5wcm90b3R5cGUgPSBzLnByb3RvdHlwZSwgbmV3IG8oKSk7XG4gICAgfTtcbiAgfSgpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocXQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgcXQuTG9naWNFcnJvciA9IHZvaWQgMDtcbiAgdmFyIGUgPSBXaCgpLCByID0gZnVuY3Rpb24obikge1xuICAgIHQoaSwgbik7XG4gICAgZnVuY3Rpb24gaShzKSB7XG4gICAgICByZXR1cm4gbi5jYWxsKHRoaXMsIHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBpO1xuICB9KGUuRXhjZXB0aW9uKTtcbiAgcmV0dXJuIHF0LkxvZ2ljRXJyb3IgPSByLCBxdDtcbn1cbnZhciBhbztcbmZ1bmN0aW9uIFNhKCkge1xuICBpZiAoYW8pXG4gICAgcmV0dXJuICR0O1xuICBhbyA9IDE7XG4gIHZhciB0ID0gUyAmJiBTLl9fZXh0ZW5kcyB8fCBmdW5jdGlvbigpIHtcbiAgICB2YXIgbiA9IGZ1bmN0aW9uKGksIHMpIHtcbiAgICAgIHJldHVybiBuID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24obywgYSkge1xuICAgICAgICBvLl9fcHJvdG9fXyA9IGE7XG4gICAgICB9IHx8IGZ1bmN0aW9uKG8sIGEpIHtcbiAgICAgICAgZm9yICh2YXIgYyBpbiBhKVxuICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhLCBjKSAmJiAob1tjXSA9IGFbY10pO1xuICAgICAgfSwgbihpLCBzKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbihpLCBzKSB7XG4gICAgICBpZiAodHlwZW9mIHMgIT0gXCJmdW5jdGlvblwiICYmIHMgIT09IG51bGwpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKHMpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgIG4oaSwgcyk7XG4gICAgICBmdW5jdGlvbiBvKCkge1xuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yID0gaTtcbiAgICAgIH1cbiAgICAgIGkucHJvdG90eXBlID0gcyA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUocykgOiAoby5wcm90b3R5cGUgPSBzLnByb3RvdHlwZSwgbmV3IG8oKSk7XG4gICAgfTtcbiAgfSgpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoJHQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgJHQuSW52YWxpZEFyZ3VtZW50ID0gdm9pZCAwO1xuICB2YXIgZSA9IGthKCksIHIgPSBmdW5jdGlvbihuKSB7XG4gICAgdChpLCBuKTtcbiAgICBmdW5jdGlvbiBpKHMpIHtcbiAgICAgIHJldHVybiBuLmNhbGwodGhpcywgcykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIGk7XG4gIH0oZS5Mb2dpY0Vycm9yKTtcbiAgcmV0dXJuICR0LkludmFsaWRBcmd1bWVudCA9IHIsICR0O1xufVxudmFyIFV0ID0ge30sIGNvO1xuZnVuY3Rpb24gVmgoKSB7XG4gIGlmIChjbylcbiAgICByZXR1cm4gVXQ7XG4gIGNvID0gMTtcbiAgdmFyIHQgPSBTICYmIFMuX19leHRlbmRzIHx8IGZ1bmN0aW9uKCkge1xuICAgIHZhciBuID0gZnVuY3Rpb24oaSwgcykge1xuICAgICAgcmV0dXJuIG4gPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbihvLCBhKSB7XG4gICAgICAgIG8uX19wcm90b19fID0gYTtcbiAgICAgIH0gfHwgZnVuY3Rpb24obywgYSkge1xuICAgICAgICBmb3IgKHZhciBjIGluIGEpXG4gICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGEsIGMpICYmIChvW2NdID0gYVtjXSk7XG4gICAgICB9LCBuKGksIHMpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGksIHMpIHtcbiAgICAgIGlmICh0eXBlb2YgcyAhPSBcImZ1bmN0aW9uXCIgJiYgcyAhPT0gbnVsbClcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcocykgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgbihpLCBzKTtcbiAgICAgIGZ1bmN0aW9uIG8oKSB7XG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IgPSBpO1xuICAgICAgfVxuICAgICAgaS5wcm90b3R5cGUgPSBzID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShzKSA6IChvLnByb3RvdHlwZSA9IHMucHJvdG90eXBlLCBuZXcgbygpKTtcbiAgICB9O1xuICB9KCk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVdCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBVdC5PdXRPZlJhbmdlID0gdm9pZCAwO1xuICB2YXIgZSA9IGthKCksIHIgPSBmdW5jdGlvbihuKSB7XG4gICAgdChpLCBuKTtcbiAgICBmdW5jdGlvbiBpKHMpIHtcbiAgICAgIHJldHVybiBuLmNhbGwodGhpcywgcykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIGk7XG4gIH0oZS5Mb2dpY0Vycm9yKTtcbiAgcmV0dXJuIFV0Lk91dE9mUmFuZ2UgPSByLCBVdDtcbn1cbnZhciB1bztcbmZ1bmN0aW9uIFdyKCkge1xuICByZXR1cm4gdW8gfHwgKHVvID0gMSwgZnVuY3Rpb24odCkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIHQuRXJyb3JHZW5lcmF0b3IgPSB2b2lkIDA7XG4gICAgdmFyIGUgPSBTYSgpLCByID0gVmgoKTtcbiAgICAoZnVuY3Rpb24obikge1xuICAgICAgZnVuY3Rpb24gaShkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZCA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICB2YXIgcCA9IGQuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgcmV0dXJuIGQuY29uc3RydWN0b3IuX19NT0RVTEUgJiYgKHAgPSBcIlwiLmNvbmNhdChkLmNvbnN0cnVjdG9yLl9fTU9EVUxFLCBcIi5cIikuY29uY2F0KHApKSwgXCJzdGQuXCIuY29uY2F0KHApO1xuICAgICAgfVxuICAgICAgbi5nZXRfY2xhc3NfbmFtZSA9IGk7XG4gICAgICBmdW5jdGlvbiBzKGQsIHApIHtcbiAgICAgICAgcmV0dXJuIG5ldyByLk91dE9mUmFuZ2UoXCJFcnJvciBvbiBcIi5jb25jYXQoaShkKSwgXCIuXCIpLmNvbmNhdChwLCBcIigpOiBpdCdzIGVtcHR5IGNvbnRhaW5lci5cIikpO1xuICAgICAgfVxuICAgICAgbi5lbXB0eSA9IHM7XG4gICAgICBmdW5jdGlvbiBvKGQsIHAsIHkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyByLk91dE9mUmFuZ2UoXCJFcnJvciBvbiBcIi5jb25jYXQoaShkKSwgXCIuXCIpLmNvbmNhdChwLCBcIigpOiBwYXJhbWV0cmljIGluZGV4IGlzIG5lZ2F0aXZlIC0+IChpbmRleCA9IFwiKS5jb25jYXQoeSwgXCIpLlwiKSk7XG4gICAgICB9XG4gICAgICBuLm5lZ2F0aXZlX2luZGV4ID0gbztcbiAgICAgIGZ1bmN0aW9uIGEoZCwgcCwgeSwgZykge1xuICAgICAgICByZXR1cm4gbmV3IHIuT3V0T2ZSYW5nZShcIkVycm9yIG9uIFwiLmNvbmNhdChpKGQpLCBcIi5cIikuY29uY2F0KHAsIFwiKCk6IHBhcmFtZXRyaWMgaW5kZXggaXMgZXF1YWwgb3IgZ3JlYXRlciB0aGFuIHNpemUgLT4gKGluZGV4ID0gXCIpLmNvbmNhdCh5LCBcIiwgc2l6ZTogXCIpLmNvbmNhdChnLCBcIikuXCIpKTtcbiAgICAgIH1cbiAgICAgIG4uZXhjZXNzaXZlX2luZGV4ID0gYTtcbiAgICAgIGZ1bmN0aW9uIGMoZCwgcCkge1xuICAgICAgICByZXR1cm4gbmV3IGUuSW52YWxpZEFyZ3VtZW50KFwiRXJyb3Igb24gXCIuY29uY2F0KGkoZCksIFwiLlwiKS5jb25jYXQocCwgXCIoKTogcGFyYW1ldHJpYyBpdGVyYXRvciBpcyBub3QgdGhpcyBjb250YWluZXIncyBvd24uXCIpKTtcbiAgICAgIH1cbiAgICAgIG4ubm90X215X2l0ZXJhdG9yID0gYztcbiAgICAgIGZ1bmN0aW9uIGwoZCwgcCkge1xuICAgICAgICByZXR1cm4gbmV3IGUuSW52YWxpZEFyZ3VtZW50KFwiRXJyb3Igb24gXCIuY29uY2F0KGkoZCksIFwiLlwiKS5jb25jYXQocCwgXCIoKTogcGFyYW1ldHJpYyBpdGVyYXRvciwgaXQgYWxyZWFkeSBoYXMgYmVlbiBlcmFzZWQuXCIpKTtcbiAgICAgIH1cbiAgICAgIG4uZXJhc2VkX2l0ZXJhdG9yID0gbDtcbiAgICAgIGZ1bmN0aW9uIGYoZCwgcCwgeSkge1xuICAgICAgICByZXR1cm4gbmV3IHIuT3V0T2ZSYW5nZShcIkVycm9yIG9uIFwiLmNvbmNhdChpKGQpLCBcIi5cIikuY29uY2F0KHAsIFwiKCk6IHBhcmFtZXRyaWMgaXRlcmF0b3IgaXMgZGlyZWN0aW5nIG5lZ2F0aXZlIHBvc2l0aW9uIC0+IChpbmRleCA9IFwiKS5jb25jYXQoeSwgXCIpLlwiKSk7XG4gICAgICB9XG4gICAgICBuLm5lZ2F0aXZlX2l0ZXJhdG9yID0gZjtcbiAgICAgIGZ1bmN0aW9uIHUoZCwgcCkge1xuICAgICAgICBwID09PSB2b2lkIDAgJiYgKHAgPSBcImVuZFwiKTtcbiAgICAgICAgdmFyIHkgPSBpKGQpO1xuICAgICAgICByZXR1cm4gbmV3IHIuT3V0T2ZSYW5nZShcIkVycm9yIG9uIFwiLmNvbmNhdCh5LCBcIi5JdGVyYXRvci52YWx1ZTogY2Fubm90IGFjY2VzcyB0byB0aGUgXCIpLmNvbmNhdCh5LCBcIi5cIikuY29uY2F0KHAsIFwiKCkudmFsdWUuXCIpKTtcbiAgICAgIH1cbiAgICAgIG4uaXRlcmF0b3JfZW5kX3ZhbHVlID0gdTtcbiAgICAgIGZ1bmN0aW9uIGgoZCwgcCwgeSkge1xuICAgICAgICB0aHJvdyBuZXcgci5PdXRPZlJhbmdlKFwiRXJyb3Igb24gXCIuY29uY2F0KGkoZCksIFwiLlwiKS5jb25jYXQocCwgXCIoKTogdW5hYmxlIHRvIGZpbmQgdGhlIG1hdGNoZWQga2V5IC0+IFwiKS5jb25jYXQoeSkpO1xuICAgICAgfVxuICAgICAgbi5rZXlfbm91dF9mb3VuZCA9IGg7XG4gICAgfSkodC5FcnJvckdlbmVyYXRvciB8fCAodC5FcnJvckdlbmVyYXRvciA9IHt9KSk7XG4gIH0od24pKSwgd247XG59XG52YXIgbG87XG5mdW5jdGlvbiBHaCgpIHtcbiAgaWYgKGxvKVxuICAgIHJldHVybiBSdDtcbiAgbG8gPSAxO1xuICB2YXIgdCA9IFMgJiYgUy5fX2V4dGVuZHMgfHwgZnVuY3Rpb24oKSB7XG4gICAgdmFyIG8gPSBmdW5jdGlvbihhLCBjKSB7XG4gICAgICByZXR1cm4gbyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uKGwsIGYpIHtcbiAgICAgICAgbC5fX3Byb3RvX18gPSBmO1xuICAgICAgfSB8fCBmdW5jdGlvbihsLCBmKSB7XG4gICAgICAgIGZvciAodmFyIHUgaW4gZilcbiAgICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZiwgdSkgJiYgKGxbdV0gPSBmW3VdKTtcbiAgICAgIH0sIG8oYSwgYyk7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24oYSwgYykge1xuICAgICAgaWYgKHR5cGVvZiBjICE9IFwiZnVuY3Rpb25cIiAmJiBjICE9PSBudWxsKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhjKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICBvKGEsIGMpO1xuICAgICAgZnVuY3Rpb24gbCgpIHtcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IGE7XG4gICAgICB9XG4gICAgICBhLnByb3RvdHlwZSA9IGMgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGMpIDogKGwucHJvdG90eXBlID0gYy5wcm90b3R5cGUsIG5ldyBsKCkpO1xuICAgIH07XG4gIH0oKSwgZSA9IFMgJiYgUy5fX3JlYWQgfHwgZnVuY3Rpb24obywgYSkge1xuICAgIHZhciBjID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghYylcbiAgICAgIHJldHVybiBvO1xuICAgIHZhciBsID0gYy5jYWxsKG8pLCBmLCB1ID0gW10sIGg7XG4gICAgdHJ5IHtcbiAgICAgIGZvciAoOyAoYSA9PT0gdm9pZCAwIHx8IGEtLSA+IDApICYmICEoZiA9IGwubmV4dCgpKS5kb25lOyApXG4gICAgICAgIHUucHVzaChmLnZhbHVlKTtcbiAgICB9IGNhdGNoIChkKSB7XG4gICAgICBoID0geyBlcnJvcjogZCB9O1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBmICYmICFmLmRvbmUgJiYgKGMgPSBsLnJldHVybikgJiYgYy5jYWxsKGwpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGgpXG4gICAgICAgICAgdGhyb3cgaC5lcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHU7XG4gIH0sIHIgPSBTICYmIFMuX19zcHJlYWRBcnJheSB8fCBmdW5jdGlvbihvLCBhLCBjKSB7XG4gICAgaWYgKGMgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMilcbiAgICAgIGZvciAodmFyIGwgPSAwLCBmID0gYS5sZW5ndGgsIHU7IGwgPCBmOyBsKyspXG4gICAgICAgICh1IHx8ICEobCBpbiBhKSkgJiYgKHUgfHwgKHUgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhLCAwLCBsKSksIHVbbF0gPSBhW2xdKTtcbiAgICByZXR1cm4gby5jb25jYXQodSB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhKSk7XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSdCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBSdC5VbmlxdWVTZXQgPSB2b2lkIDA7XG4gIHZhciBuID0gS2goKSwgaSA9IFdyKCksIHMgPSBmdW5jdGlvbihvKSB7XG4gICAgdChhLCBvKTtcbiAgICBmdW5jdGlvbiBhKCkge1xuICAgICAgcmV0dXJuIG8gIT09IG51bGwgJiYgby5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBhLnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbmQoYykuZXF1YWxzKHRoaXMuZW5kKCkpID8gMCA6IDE7XG4gICAgfSwgYS5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICBmb3IgKHZhciBjID0gW10sIGwgPSAwOyBsIDwgYXJndW1lbnRzLmxlbmd0aDsgbCsrKVxuICAgICAgICBjW2xdID0gYXJndW1lbnRzW2xdO1xuICAgICAgcmV0dXJuIG8ucHJvdG90eXBlLmluc2VydC5hcHBseSh0aGlzLCByKFtdLCBlKGMpLCAhMSkpO1xuICAgIH0sIGEucHJvdG90eXBlLl9JbnNlcnRfYnlfcmFuZ2UgPSBmdW5jdGlvbihjLCBsKSB7XG4gICAgICBmb3IgKDsgIWMuZXF1YWxzKGwpOyBjID0gYy5uZXh0KCkpXG4gICAgICAgIHRoaXMuX0luc2VydF9ieV9rZXkoYy52YWx1ZSk7XG4gICAgfSwgYS5wcm90b3R5cGUuZXh0cmFjdCA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgIHJldHVybiBjIGluc3RhbmNlb2YgdGhpcy5lbmQoKS5jb25zdHJ1Y3RvciA/IHRoaXMuX0V4dHJhY3RfYnlfaXRlcmF0b3IoYykgOiB0aGlzLl9FeHRyYWN0X2J5X3ZhbChjKTtcbiAgICB9LCBhLnByb3RvdHlwZS5fRXh0cmFjdF9ieV92YWwgPSBmdW5jdGlvbihjKSB7XG4gICAgICB2YXIgbCA9IHRoaXMuZmluZChjKTtcbiAgICAgIGlmIChsLmVxdWFscyh0aGlzLmVuZCgpKSA9PT0gITApXG4gICAgICAgIHRocm93IGkuRXJyb3JHZW5lcmF0b3Iua2V5X25vdXRfZm91bmQodGhpcywgXCJleHRyYWN0XCIsIGMpO1xuICAgICAgcmV0dXJuIHRoaXMuX0VyYXNlX2J5X3JhbmdlKGwpLCBjO1xuICAgIH0sIGEucHJvdG90eXBlLl9FeHRyYWN0X2J5X2l0ZXJhdG9yID0gZnVuY3Rpb24oYykge1xuICAgICAgcmV0dXJuIGMuZXF1YWxzKHRoaXMuZW5kKCkpID09PSAhMCB8fCB0aGlzLmhhcyhjLnZhbHVlKSA9PT0gITEgPyB0aGlzLmVuZCgpIDogKHRoaXMuX0VyYXNlX2J5X3JhbmdlKGMpLCBjKTtcbiAgICB9LCBhLnByb3RvdHlwZS5fRXJhc2VfYnlfdmFsID0gZnVuY3Rpb24oYykge1xuICAgICAgdmFyIGwgPSB0aGlzLmZpbmQoYyk7XG4gICAgICByZXR1cm4gbC5lcXVhbHModGhpcy5lbmQoKSkgPT09ICEwID8gMCA6ICh0aGlzLl9FcmFzZV9ieV9yYW5nZShsKSwgMSk7XG4gICAgfSwgYS5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbihjKSB7XG4gICAgICBmb3IgKHZhciBsID0gYy5iZWdpbigpOyAhbC5lcXVhbHMoYy5lbmQoKSk7IClcbiAgICAgICAgdGhpcy5oYXMobC52YWx1ZSkgPT09ICExID8gKHRoaXMuaW5zZXJ0KGwudmFsdWUpLCBsID0gYy5lcmFzZShsKSkgOiBsID0gbC5uZXh0KCk7XG4gICAgfSwgYTtcbiAgfShuLlNldENvbnRhaW5lcik7XG4gIHJldHVybiBSdC5VbmlxdWVTZXQgPSBzLCBSdDtcbn1cbnZhciBfbiA9IHt9LCBtbiA9IHt9LCBmbztcbmZ1bmN0aW9uIFpoKCkge1xuICByZXR1cm4gZm8gfHwgKGZvID0gMSwgZnVuY3Rpb24odCkge1xuICAgIHZhciBlID0gUyAmJiBTLl9fcmVhZCB8fCBmdW5jdGlvbihuLCBpKSB7XG4gICAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIG5bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICAgIGlmICghcylcbiAgICAgICAgcmV0dXJuIG47XG4gICAgICB2YXIgbyA9IHMuY2FsbChuKSwgYSwgYyA9IFtdLCBsO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICg7IChpID09PSB2b2lkIDAgfHwgaS0tID4gMCkgJiYgIShhID0gby5uZXh0KCkpLmRvbmU7IClcbiAgICAgICAgICBjLnB1c2goYS52YWx1ZSk7XG4gICAgICB9IGNhdGNoIChmKSB7XG4gICAgICAgIGwgPSB7IGVycm9yOiBmIH07XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGEgJiYgIWEuZG9uZSAmJiAocyA9IG8ucmV0dXJuKSAmJiBzLmNhbGwobyk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKGwpXG4gICAgICAgICAgICB0aHJvdyBsLmVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYztcbiAgICB9LCByID0gUyAmJiBTLl9fc3ByZWFkQXJyYXkgfHwgZnVuY3Rpb24obiwgaSwgcykge1xuICAgICAgaWYgKHMgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMilcbiAgICAgICAgZm9yICh2YXIgbyA9IDAsIGEgPSBpLmxlbmd0aCwgYzsgbyA8IGE7IG8rKylcbiAgICAgICAgICAoYyB8fCAhKG8gaW4gaSkpICYmIChjIHx8IChjID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoaSwgMCwgbykpLCBjW29dID0gaVtvXSk7XG4gICAgICByZXR1cm4gbi5jb25jYXQoYyB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChpKSk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCB0LklBc3NvY2lhdGl2ZUNvbnRhaW5lciA9IHZvaWQgMCwgZnVuY3Rpb24obikge1xuICAgICAgZnVuY3Rpb24gaShzKSB7XG4gICAgICAgIGZvciAodmFyIG8gPSBbXSwgYSA9IDE7IGEgPCBhcmd1bWVudHMubGVuZ3RoOyBhKyspXG4gICAgICAgICAgb1thIC0gMV0gPSBhcmd1bWVudHNbYV07XG4gICAgICAgIHZhciBjLCBsO1xuICAgICAgICByZXR1cm4gby5sZW5ndGggPj0gMSAmJiBvWzBdIGluc3RhbmNlb2YgQXJyYXkgPyAoYyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBmID0gb1swXTtcbiAgICAgICAgICBzLnB1c2guYXBwbHkocywgcihbXSwgZShmKSwgITEpKTtcbiAgICAgICAgfSwgbCA9IG8uc2xpY2UoMSkpIDogby5sZW5ndGggPj0gMiAmJiBvWzBdLm5leHQgaW5zdGFuY2VvZiBGdW5jdGlvbiAmJiBvWzFdLm5leHQgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IChjID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGYgPSBvWzBdLCB1ID0gb1sxXTtcbiAgICAgICAgICBzLmFzc2lnbihmLCB1KTtcbiAgICAgICAgfSwgbCA9IG8uc2xpY2UoMikpIDogKGMgPSBudWxsLCBsID0gbyksIHsgcmFtZGE6IGMsIHRhaWw6IGwgfTtcbiAgICAgIH1cbiAgICAgIG4uY29uc3RydWN0ID0gaTtcbiAgICB9KHQuSUFzc29jaWF0aXZlQ29udGFpbmVyIHx8ICh0LklBc3NvY2lhdGl2ZUNvbnRhaW5lciA9IHt9KSk7XG4gIH0obW4pKSwgbW47XG59XG52YXIganQgPSB7fSwgSHQgPSB7fSwgTXQgPSB7fSwgaG87XG5mdW5jdGlvbiBZaCgpIHtcbiAgaWYgKGhvKVxuICAgIHJldHVybiBNdDtcbiAgaG8gPSAxLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoTXQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgTXQuX0dldF9yb290ID0gdm9pZCAwO1xuICB2YXIgdCA9IGNyO1xuICBmdW5jdGlvbiBlKCkge1xuICAgIHJldHVybiByID09PSBudWxsICYmIChyID0gKDAsIHQuaXNfbm9kZSkoKSA/IFMgOiBzZWxmLCByLl9fc19pVUlEID09PSB2b2lkIDAgJiYgKHIuX19zX2lVSUQgPSAwKSksIHI7XG4gIH1cbiAgTXQuX0dldF9yb290ID0gZTtcbiAgdmFyIHIgPSBudWxsO1xuICByZXR1cm4gTXQ7XG59XG52YXIgcG87XG5mdW5jdGlvbiBPYSgpIHtcbiAgaWYgKHBvKVxuICAgIHJldHVybiBIdDtcbiAgcG8gPSAxLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoSHQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgSHQuZ2V0X3VpZCA9IHZvaWQgMDtcbiAgdmFyIHQgPSBZaCgpO1xuICBmdW5jdGlvbiBlKHIpIHtcbiAgICBpZiAociBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgaWYgKHIuaGFzT3duUHJvcGVydHkoXCJfX2dldF9tX2lVSURcIikgPT09ICExKSB7XG4gICAgICAgIHZhciBuID0gKysoMCwgdC5fR2V0X3Jvb3QpKCkuX19zX2lVSUQ7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLCBcIl9fZ2V0X21faVVJRFwiLCB7XG4gICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByLl9fZ2V0X21faVVJRCgpO1xuICAgIH0gZWxzZVxuICAgICAgcmV0dXJuIHIgPT09IHZvaWQgMCA/IC0xIDogMDtcbiAgfVxuICByZXR1cm4gSHQuZ2V0X3VpZCA9IGUsIEh0O1xufVxudmFyIHlvO1xuZnVuY3Rpb24gd2koKSB7XG4gIGlmICh5bylcbiAgICByZXR1cm4ganQ7XG4gIHlvID0gMTtcbiAgdmFyIHQgPSBTICYmIFMuX192YWx1ZXMgfHwgZnVuY3Rpb24oYykge1xuICAgIHZhciBsID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBmID0gbCAmJiBjW2xdLCB1ID0gMDtcbiAgICBpZiAoZilcbiAgICAgIHJldHVybiBmLmNhbGwoYyk7XG4gICAgaWYgKGMgJiYgdHlwZW9mIGMubGVuZ3RoID09IFwibnVtYmVyXCIpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gYyAmJiB1ID49IGMubGVuZ3RoICYmIChjID0gdm9pZCAwKSwgeyB2YWx1ZTogYyAmJiBjW3UrK10sIGRvbmU6ICFjIH07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihsID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoanQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwganQuaGFzaCA9IHZvaWQgMDtcbiAgdmFyIGUgPSBPYSgpO1xuICBmdW5jdGlvbiByKCkge1xuICAgIGZvciAodmFyIGMsIGwsIGYgPSBbXSwgdSA9IDA7IHUgPCBhcmd1bWVudHMubGVuZ3RoOyB1KyspXG4gICAgICBmW3VdID0gYXJndW1lbnRzW3VdO1xuICAgIHZhciBoID0gbztcbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgZCA9IHQoZiksIHAgPSBkLm5leHQoKTsgIXAuZG9uZTsgcCA9IGQubmV4dCgpKSB7XG4gICAgICAgIHZhciB5ID0gcC52YWx1ZTtcbiAgICAgICAgeSA9IHkgJiYgeS52YWx1ZU9mKCk7XG4gICAgICAgIHZhciBnID0gdHlwZW9mIHk7XG4gICAgICAgIGlmIChnID09PSBcImJvb2xlYW5cIilcbiAgICAgICAgICBoID0gbih5LCBoKTtcbiAgICAgICAgZWxzZSBpZiAoZyA9PT0gXCJudW1iZXJcIiB8fCBnID09PSBcImJpZ2ludFwiKVxuICAgICAgICAgIGggPSBpKHksIGgpO1xuICAgICAgICBlbHNlIGlmIChnID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgIGggPSBzKHksIGgpO1xuICAgICAgICBlbHNlIGlmICh5IGluc3RhbmNlb2YgT2JqZWN0ICYmIHkuaGFzaENvZGUgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgIHZhciB2ID0geS5oYXNoQ29kZSgpO1xuICAgICAgICAgIGlmIChmLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgIGggPSBoIF4gdiwgaCAqPSBhO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICBoID0gaSgoMCwgZS5nZXRfdWlkKSh5KSwgaCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgYyA9IHsgZXJyb3I6IF8gfTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcCAmJiAhcC5kb25lICYmIChsID0gZC5yZXR1cm4pICYmIGwuY2FsbChkKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChjKVxuICAgICAgICAgIHRocm93IGMuZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBNYXRoLmFicyhoKTtcbiAgfVxuICBqdC5oYXNoID0gcjtcbiAgZnVuY3Rpb24gbihjLCBsKSB7XG4gICAgcmV0dXJuIGwgXj0gYyA/IDEgOiAwLCBsICo9IGEsIGw7XG4gIH1cbiAgZnVuY3Rpb24gaShjLCBsKSB7XG4gICAgcmV0dXJuIHMoYy50b1N0cmluZygpLCBsKTtcbiAgfVxuICBmdW5jdGlvbiBzKGMsIGwpIHtcbiAgICBmb3IgKHZhciBmID0gMDsgZiA8IGMubGVuZ3RoOyArK2YpXG4gICAgICBsIF49IGMuY2hhckNvZGVBdChmKSwgbCAqPSBhO1xuICAgIHJldHVybiBNYXRoLmFicyhsKTtcbiAgfVxuICB2YXIgbyA9IDIxNjYxMzYyNjEsIGEgPSAxNjc3NzYxOTtcbiAgcmV0dXJuIGp0O1xufVxudmFyIGFlID0ge30sIGdvO1xuZnVuY3Rpb24gX2koKSB7XG4gIGlmIChnbylcbiAgICByZXR1cm4gYWU7XG4gIGdvID0gMSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFlLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIGFlLmdyZWF0ZXJfZXF1YWwgPSBhZS5ncmVhdGVyID0gYWUubGVzc19lcXVhbCA9IGFlLmxlc3MgPSBhZS5ub3RfZXF1YWxfdG8gPSBhZS5lcXVhbF90byA9IHZvaWQgMDtcbiAgdmFyIHQgPSBPYSgpO1xuICBmdW5jdGlvbiBlKGEsIGMpIHtcbiAgICByZXR1cm4gYSA9IGEgJiYgYS52YWx1ZU9mKCksIGMgPSBjICYmIGMudmFsdWVPZigpLCBhIGluc3RhbmNlb2YgT2JqZWN0ICYmIGEuZXF1YWxzIGluc3RhbmNlb2YgRnVuY3Rpb24gPyBhLmVxdWFscyhjKSA6IGEgPT09IGM7XG4gIH1cbiAgYWUuZXF1YWxfdG8gPSBlO1xuICBmdW5jdGlvbiByKGEsIGMpIHtcbiAgICByZXR1cm4gIWUoYSwgYyk7XG4gIH1cbiAgYWUubm90X2VxdWFsX3RvID0gcjtcbiAgZnVuY3Rpb24gbihhLCBjKSB7XG4gICAgcmV0dXJuIGEgPSBhLnZhbHVlT2YoKSwgYyA9IGMudmFsdWVPZigpLCBhIGluc3RhbmNlb2YgT2JqZWN0ID8gYS5sZXNzIGluc3RhbmNlb2YgRnVuY3Rpb24gPyBhLmxlc3MoYykgOiAoMCwgdC5nZXRfdWlkKShhKSA8ICgwLCB0LmdldF91aWQpKGMpIDogYSA8IGM7XG4gIH1cbiAgYWUubGVzcyA9IG47XG4gIGZ1bmN0aW9uIGkoYSwgYykge1xuICAgIHJldHVybiBuKGEsIGMpIHx8IGUoYSwgYyk7XG4gIH1cbiAgYWUubGVzc19lcXVhbCA9IGk7XG4gIGZ1bmN0aW9uIHMoYSwgYykge1xuICAgIHJldHVybiAhaShhLCBjKTtcbiAgfVxuICBhZS5ncmVhdGVyID0gcztcbiAgZnVuY3Rpb24gbyhhLCBjKSB7XG4gICAgcmV0dXJuICFuKGEsIGMpO1xuICB9XG4gIHJldHVybiBhZS5ncmVhdGVyX2VxdWFsID0gbywgYWU7XG59XG52YXIgYm87XG5mdW5jdGlvbiBBYSgpIHtcbiAgcmV0dXJuIGJvIHx8IChibyA9IDEsIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSA9IFMgJiYgUy5fX3JlYWQgfHwgZnVuY3Rpb24obywgYSkge1xuICAgICAgdmFyIGMgPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgICBpZiAoIWMpXG4gICAgICAgIHJldHVybiBvO1xuICAgICAgdmFyIGwgPSBjLmNhbGwobyksIGYsIHUgPSBbXSwgaDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoOyAoYSA9PT0gdm9pZCAwIHx8IGEtLSA+IDApICYmICEoZiA9IGwubmV4dCgpKS5kb25lOyApXG4gICAgICAgICAgdS5wdXNoKGYudmFsdWUpO1xuICAgICAgfSBjYXRjaCAoZCkge1xuICAgICAgICBoID0geyBlcnJvcjogZCB9O1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmICYmICFmLmRvbmUgJiYgKGMgPSBsLnJldHVybikgJiYgYy5jYWxsKGwpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChoKVxuICAgICAgICAgICAgdGhyb3cgaC5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHU7XG4gICAgfSwgciA9IFMgJiYgUy5fX3NwcmVhZEFycmF5IHx8IGZ1bmN0aW9uKG8sIGEsIGMpIHtcbiAgICAgIGlmIChjIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpXG4gICAgICAgIGZvciAodmFyIGwgPSAwLCBmID0gYS5sZW5ndGgsIHU7IGwgPCBmOyBsKyspXG4gICAgICAgICAgKHUgfHwgIShsIGluIGEpKSAmJiAodSB8fCAodSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGEsIDAsIGwpKSwgdVtsXSA9IGFbbF0pO1xuICAgICAgcmV0dXJuIG8uY29uY2F0KHUgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYSkpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgdC5JSGFzaENvbnRhaW5lciA9IHZvaWQgMDtcbiAgICB2YXIgbiA9IFpoKCksIGkgPSB3aSgpLCBzID0gX2koKTtcbiAgICAoZnVuY3Rpb24obykge1xuICAgICAgZnVuY3Rpb24gYShjLCBsLCBmKSB7XG4gICAgICAgIGZvciAodmFyIHUgPSBbXSwgaCA9IDM7IGggPCBhcmd1bWVudHMubGVuZ3RoOyBoKyspXG4gICAgICAgICAgdVtoIC0gM10gPSBhcmd1bWVudHNbaF07XG4gICAgICAgIHZhciBkID0gbnVsbCwgcCA9IGkuaGFzaCwgeSA9IHMuZXF1YWxfdG87XG4gICAgICAgIGlmICh1Lmxlbmd0aCA9PT0gMSAmJiB1WzBdIGluc3RhbmNlb2YgbCkge1xuICAgICAgICAgIHZhciBnID0gdVswXTtcbiAgICAgICAgICBwID0gZy5oYXNoX2Z1bmN0aW9uKCksIHkgPSBnLmtleV9lcSgpLCBkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgXyA9IGcuYmVnaW4oKSwgbSA9IGcuZW5kKCk7XG4gICAgICAgICAgICBjLmFzc2lnbihfLCBtKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB2ID0gbi5JQXNzb2NpYXRpdmVDb250YWluZXIuY29uc3RydWN0LmFwcGx5KG4uSUFzc29jaWF0aXZlQ29udGFpbmVyLCByKFtjXSwgZSh1KSwgITEpKTtcbiAgICAgICAgICBkID0gdi5yYW1kYSwgdi50YWlsLmxlbmd0aCA+PSAxICYmIChwID0gdi50YWlsWzBdKSwgdi50YWlsLmxlbmd0aCA+PSAyICYmICh5ID0gdi50YWlsWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBmKHAsIHkpLCBkICE9PSBudWxsICYmIGQoKTtcbiAgICAgIH1cbiAgICAgIG8uY29uc3RydWN0ID0gYTtcbiAgICB9KSh0LklIYXNoQ29udGFpbmVyIHx8ICh0LklIYXNoQ29udGFpbmVyID0ge30pKTtcbiAgfShfbikpLCBfbjtcbn1cbnZhciB4biA9IHt9LCBEdCA9IHt9LCB6dCA9IHt9LCB2bztcbmZ1bmN0aW9uIG1pKCkge1xuICBpZiAodm8pXG4gICAgcmV0dXJuIHp0O1xuICB2byA9IDEsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh6dCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCB6dC5MaXN0SXRlcmF0b3IgPSB2b2lkIDA7XG4gIHZhciB0ID0gV3IoKSwgZSA9IGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIHIobiwgaSwgcykge1xuICAgICAgdGhpcy5wcmV2XyA9IG4sIHRoaXMubmV4dF8gPSBpLCB0aGlzLnZhbHVlXyA9IHM7XG4gICAgfVxuICAgIHJldHVybiByLl9TZXRfcHJldiA9IGZ1bmN0aW9uKG4sIGkpIHtcbiAgICAgIG4ucHJldl8gPSBpO1xuICAgIH0sIHIuX1NldF9uZXh0ID0gZnVuY3Rpb24obiwgaSkge1xuICAgICAgbi5uZXh0XyA9IGk7XG4gICAgfSwgci5wcm90b3R5cGUucHJldiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMucHJldl87XG4gICAgfSwgci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubmV4dF87XG4gICAgfSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHIucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9UcnlfdmFsdWUoKSwgdGhpcy52YWx1ZV87XG4gICAgICB9LFxuICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgfSksIHIucHJvdG90eXBlLl9UcnlfdmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnZhbHVlXyA9PT0gdm9pZCAwICYmIHRoaXMuZXF1YWxzKHRoaXMuc291cmNlKCkuZW5kKCkpID09PSAhMClcbiAgICAgICAgdGhyb3cgdC5FcnJvckdlbmVyYXRvci5pdGVyYXRvcl9lbmRfdmFsdWUodGhpcy5zb3VyY2UoKSk7XG4gICAgfSwgci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24obikge1xuICAgICAgcmV0dXJuIHRoaXMgPT09IG47XG4gICAgfSwgcjtcbiAgfSgpO1xuICByZXR1cm4genQuTGlzdEl0ZXJhdG9yID0gZSwgenQ7XG59XG52YXIgRnQgPSB7fSwgd287XG5mdW5jdGlvbiBKaCgpIHtcbiAgaWYgKHdvKVxuICAgIHJldHVybiBGdDtcbiAgd28gPSAxLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoRnQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgRnQuUmVwZWF0ZXIgPSB2b2lkIDA7XG4gIHZhciB0ID0gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gZShyLCBuKSB7XG4gICAgICB0aGlzLmluZGV4XyA9IHIsIHRoaXMudmFsdWVfID0gbjtcbiAgICB9XG4gICAgcmV0dXJuIGUucHJvdG90eXBlLmluZGV4ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbmRleF87XG4gICAgfSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlXztcbiAgICAgIH0sXG4gICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICB9KSwgZS5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICsrdGhpcy5pbmRleF8sIHRoaXM7XG4gICAgfSwgZS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24ocikge1xuICAgICAgcmV0dXJuIHRoaXMuaW5kZXhfID09PSByLmluZGV4XztcbiAgICB9LCBlO1xuICB9KCk7XG4gIHJldHVybiBGdC5SZXBlYXRlciA9IHQsIEZ0O1xufVxudmFyIGNlID0ge30sIF9vO1xuZnVuY3Rpb24gWGgoKSB7XG4gIGlmIChfbylcbiAgICByZXR1cm4gY2U7XG4gIF9vID0gMSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNlLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIGNlLm5leHQgPSBjZS5wcmV2ID0gY2UuYWR2YW5jZSA9IGNlLmRpc3RhbmNlID0gY2Uuc2l6ZSA9IGNlLmVtcHR5ID0gdm9pZCAwO1xuICB2YXIgdCA9IFNhKCk7XG4gIGZ1bmN0aW9uIGUoYykge1xuICAgIHJldHVybiBjIGluc3RhbmNlb2YgQXJyYXkgPyBjLmxlbmd0aCAhPT0gMCA6IGMuZW1wdHkoKTtcbiAgfVxuICBjZS5lbXB0eSA9IGU7XG4gIGZ1bmN0aW9uIHIoYykge1xuICAgIHJldHVybiBjIGluc3RhbmNlb2YgQXJyYXkgPyBjLmxlbmd0aCA6IGMuc2l6ZSgpO1xuICB9XG4gIGNlLnNpemUgPSByO1xuICBmdW5jdGlvbiBuKGMsIGwpIHtcbiAgICBpZiAoYy5pbmRleCBpbnN0YW5jZW9mIEZ1bmN0aW9uKVxuICAgICAgcmV0dXJuIGkoYywgbCk7XG4gICAgZm9yICh2YXIgZiA9IDA7ICFjLmVxdWFscyhsKTsgYyA9IGMubmV4dCgpKVxuICAgICAgKytmO1xuICAgIHJldHVybiBmO1xuICB9XG4gIGNlLmRpc3RhbmNlID0gbjtcbiAgZnVuY3Rpb24gaShjLCBsKSB7XG4gICAgdmFyIGYgPSBjLmluZGV4KCksIHUgPSBsLmluZGV4KCk7XG4gICAgcmV0dXJuIGMuYmFzZSBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gZiAtIHUgOiB1IC0gZjtcbiAgfVxuICBmdW5jdGlvbiBzKGMsIGwpIHtcbiAgICBpZiAobCA9PT0gMClcbiAgICAgIHJldHVybiBjO1xuICAgIGlmIChjLmFkdmFuY2UgaW5zdGFuY2VvZiBGdW5jdGlvbilcbiAgICAgIHJldHVybiBjLmFkdmFuY2UobCk7XG4gICAgdmFyIGY7XG4gICAgaWYgKGwgPCAwKSB7XG4gICAgICBpZiAoIShjLnByZXYgaW5zdGFuY2VvZiBGdW5jdGlvbikpXG4gICAgICAgIHRocm93IG5ldyB0LkludmFsaWRBcmd1bWVudChcIkVycm9yIG9uIHN0ZC5hZHZhbmNlKCk6IHBhcmFtZXRyaWMgaXRlcmF0b3IgaXMgbm90IGEgYmktZGlyZWN0aW9uYWwgaXRlcmF0b3IsIHRodXMgYWR2YW5jaW5nIHRvIG5lZ2F0aXZlIGRpcmVjdGlvbiBpcyBub3QgcG9zc2libGUuXCIpO1xuICAgICAgZiA9IGZ1bmN0aW9uKHUpIHtcbiAgICAgICAgcmV0dXJuIHUucHJldigpO1xuICAgICAgfSwgbCA9IC1sO1xuICAgIH0gZWxzZVxuICAgICAgZiA9IGZ1bmN0aW9uKHUpIHtcbiAgICAgICAgcmV0dXJuIHUubmV4dCgpO1xuICAgICAgfTtcbiAgICBmb3IgKDsgbC0tID4gMDsgKVxuICAgICAgYyA9IGYoYyk7XG4gICAgcmV0dXJuIGM7XG4gIH1cbiAgY2UuYWR2YW5jZSA9IHM7XG4gIGZ1bmN0aW9uIG8oYywgbCkge1xuICAgIHJldHVybiBsID09PSB2b2lkIDAgJiYgKGwgPSAxKSwgbCA9PT0gMSA/IGMucHJldigpIDogcyhjLCAtbCk7XG4gIH1cbiAgY2UucHJldiA9IG87XG4gIGZ1bmN0aW9uIGEoYywgbCkge1xuICAgIHJldHVybiBsID09PSB2b2lkIDAgJiYgKGwgPSAxKSwgbCA9PT0gMSA/IGMubmV4dCgpIDogcyhjLCBsKTtcbiAgfVxuICByZXR1cm4gY2UubmV4dCA9IGEsIGNlO1xufVxudmFyIG1vO1xuZnVuY3Rpb24gQ2EoKSB7XG4gIGlmIChtbylcbiAgICByZXR1cm4gRHQ7XG4gIG1vID0gMTtcbiAgdmFyIHQgPSBTICYmIFMuX19leHRlbmRzIHx8IGZ1bmN0aW9uKCkge1xuICAgIHZhciBsID0gZnVuY3Rpb24oZiwgdSkge1xuICAgICAgcmV0dXJuIGwgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbihoLCBkKSB7XG4gICAgICAgIGguX19wcm90b19fID0gZDtcbiAgICAgIH0gfHwgZnVuY3Rpb24oaCwgZCkge1xuICAgICAgICBmb3IgKHZhciBwIGluIGQpXG4gICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGQsIHApICYmIChoW3BdID0gZFtwXSk7XG4gICAgICB9LCBsKGYsIHUpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGYsIHUpIHtcbiAgICAgIGlmICh0eXBlb2YgdSAhPSBcImZ1bmN0aW9uXCIgJiYgdSAhPT0gbnVsbClcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcodSkgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgbChmLCB1KTtcbiAgICAgIGZ1bmN0aW9uIGgoKSB7XG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IgPSBmO1xuICAgICAgfVxuICAgICAgZi5wcm90b3R5cGUgPSB1ID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZSh1KSA6IChoLnByb3RvdHlwZSA9IHUucHJvdG90eXBlLCBuZXcgaCgpKTtcbiAgICB9O1xuICB9KCksIGUgPSBTICYmIFMuX19yZWFkIHx8IGZ1bmN0aW9uKGwsIGYpIHtcbiAgICB2YXIgdSA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIGxbU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIXUpXG4gICAgICByZXR1cm4gbDtcbiAgICB2YXIgaCA9IHUuY2FsbChsKSwgZCwgcCA9IFtdLCB5O1xuICAgIHRyeSB7XG4gICAgICBmb3IgKDsgKGYgPT09IHZvaWQgMCB8fCBmLS0gPiAwKSAmJiAhKGQgPSBoLm5leHQoKSkuZG9uZTsgKVxuICAgICAgICBwLnB1c2goZC52YWx1ZSk7XG4gICAgfSBjYXRjaCAoZykge1xuICAgICAgeSA9IHsgZXJyb3I6IGcgfTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZCAmJiAhZC5kb25lICYmICh1ID0gaC5yZXR1cm4pICYmIHUuY2FsbChoKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmICh5KVxuICAgICAgICAgIHRocm93IHkuZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRHQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgRHQuTGlzdENvbnRhaW5lciA9IHZvaWQgMDtcbiAgdmFyIHIgPSBiaSgpLCBuID0gbWkoKSwgaSA9IEpoKCksIHMgPSB2aSgpLCBvID0gWGgoKSwgYSA9IFdyKCksIGMgPSBmdW5jdGlvbihsKSB7XG4gICAgdChmLCBsKTtcbiAgICBmdW5jdGlvbiBmKCkge1xuICAgICAgdmFyIHUgPSBsLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgIHJldHVybiB1LmVuZF8gPSB1Ll9DcmVhdGVfaXRlcmF0b3IobnVsbCwgbnVsbCksIHUuY2xlYXIoKSwgdTtcbiAgICB9XG4gICAgcmV0dXJuIGYucHJvdG90eXBlLmFzc2lnbiA9IGZ1bmN0aW9uKHUsIGgpIHtcbiAgICAgIHRoaXMuY2xlYXIoKSwgdGhpcy5pbnNlcnQodGhpcy5lbmQoKSwgdSwgaCk7XG4gICAgfSwgZi5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIG4uTGlzdEl0ZXJhdG9yLl9TZXRfcHJldih0aGlzLmVuZF8sIHRoaXMuZW5kXyksIG4uTGlzdEl0ZXJhdG9yLl9TZXRfbmV4dCh0aGlzLmVuZF8sIHRoaXMuZW5kXyksIHRoaXMuYmVnaW5fID0gdGhpcy5lbmRfLCB0aGlzLnNpemVfID0gMDtcbiAgICB9LCBmLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbih1KSB7XG4gICAgICB2YXIgaCA9IHUgLSB0aGlzLnNpemUoKTtcbiAgICAgIGggPiAwID8gdGhpcy5pbnNlcnQodGhpcy5lbmQoKSwgaCwgdm9pZCAwKSA6IGggPCAwICYmIHRoaXMuZXJhc2UoKDAsIG8uYWR2YW5jZSkodGhpcy5lbmQoKSwgLWgpLCB0aGlzLmVuZCgpKTtcbiAgICB9LCBmLnByb3RvdHlwZS5iZWdpbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYmVnaW5fO1xuICAgIH0sIGYucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZW5kXztcbiAgICB9LCBmLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5zaXplXztcbiAgICB9LCBmLnByb3RvdHlwZS5wdXNoX2Zyb250ID0gZnVuY3Rpb24odSkge1xuICAgICAgdGhpcy5pbnNlcnQodGhpcy5iZWdpbl8sIHUpO1xuICAgIH0sIGYucHJvdG90eXBlLnB1c2hfYmFjayA9IGZ1bmN0aW9uKHUpIHtcbiAgICAgIHRoaXMuaW5zZXJ0KHRoaXMuZW5kXywgdSk7XG4gICAgfSwgZi5wcm90b3R5cGUucG9wX2Zyb250ID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5lbXB0eSgpID09PSAhMClcbiAgICAgICAgdGhyb3cgYS5FcnJvckdlbmVyYXRvci5lbXB0eSh0aGlzLmVuZF8uc291cmNlKCkuY29uc3RydWN0b3IubmFtZSwgXCJwb3BfZnJvbnRcIik7XG4gICAgICB0aGlzLmVyYXNlKHRoaXMuYmVnaW5fKTtcbiAgICB9LCBmLnByb3RvdHlwZS5wb3BfYmFjayA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuZW1wdHkoKSA9PT0gITApXG4gICAgICAgIHRocm93IGEuRXJyb3JHZW5lcmF0b3IuZW1wdHkodGhpcy5lbmRfLnNvdXJjZSgpLmNvbnN0cnVjdG9yLm5hbWUsIFwicG9wX2JhY2tcIik7XG4gICAgICB0aGlzLmVyYXNlKHRoaXMuZW5kXy5wcmV2KCkpO1xuICAgIH0sIGYucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbigpIHtcbiAgICAgIGZvciAodmFyIHUgPSBbXSwgaCA9IDA7IGggPCBhcmd1bWVudHMubGVuZ3RoOyBoKyspXG4gICAgICAgIHVbaF0gPSBhcmd1bWVudHNbaF07XG4gICAgICBpZiAodS5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiB0aGlzLnNpemUoKTtcbiAgICAgIHZhciBkID0gbmV3IHMuTmF0aXZlQXJyYXlJdGVyYXRvcih1LCAwKSwgcCA9IG5ldyBzLk5hdGl2ZUFycmF5SXRlcmF0b3IodSwgdS5sZW5ndGgpO1xuICAgICAgcmV0dXJuIHRoaXMuX0luc2VydF9ieV9yYW5nZSh0aGlzLmVuZCgpLCBkLCBwKSwgdGhpcy5zaXplKCk7XG4gICAgfSwgZi5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24odSkge1xuICAgICAgZm9yICh2YXIgaCA9IFtdLCBkID0gMTsgZCA8IGFyZ3VtZW50cy5sZW5ndGg7IGQrKylcbiAgICAgICAgaFtkIC0gMV0gPSBhcmd1bWVudHNbZF07XG4gICAgICBpZiAodS5zb3VyY2UoKSAhPT0gdGhpcy5lbmRfLnNvdXJjZSgpKVxuICAgICAgICB0aHJvdyBhLkVycm9yR2VuZXJhdG9yLm5vdF9teV9pdGVyYXRvcih0aGlzLmVuZF8uc291cmNlKCksIFwiaW5zZXJ0XCIpO1xuICAgICAgaWYgKHUuZXJhc2VkXyA9PT0gITApXG4gICAgICAgIHRocm93IGEuRXJyb3JHZW5lcmF0b3IuZXJhc2VkX2l0ZXJhdG9yKHRoaXMuZW5kXy5zb3VyY2UoKSwgXCJpbnNlcnRcIik7XG4gICAgICByZXR1cm4gaC5sZW5ndGggPT09IDEgPyB0aGlzLl9JbnNlcnRfYnlfcmVwZWF0aW5nX3ZhbCh1LCAxLCBoWzBdKSA6IGgubGVuZ3RoID09PSAyICYmIHR5cGVvZiBoWzBdID09IFwibnVtYmVyXCIgPyB0aGlzLl9JbnNlcnRfYnlfcmVwZWF0aW5nX3ZhbCh1LCBoWzBdLCBoWzFdKSA6IHRoaXMuX0luc2VydF9ieV9yYW5nZSh1LCBoWzBdLCBoWzFdKTtcbiAgICB9LCBmLnByb3RvdHlwZS5fSW5zZXJ0X2J5X3JlcGVhdGluZ192YWwgPSBmdW5jdGlvbih1LCBoLCBkKSB7XG4gICAgICB2YXIgcCA9IG5ldyBpLlJlcGVhdGVyKDAsIGQpLCB5ID0gbmV3IGkuUmVwZWF0ZXIoaCk7XG4gICAgICByZXR1cm4gdGhpcy5fSW5zZXJ0X2J5X3JhbmdlKHUsIHAsIHkpO1xuICAgIH0sIGYucHJvdG90eXBlLl9JbnNlcnRfYnlfcmFuZ2UgPSBmdW5jdGlvbih1LCBoLCBkKSB7XG4gICAgICBmb3IgKHZhciBwID0gdS5wcmV2KCksIHkgPSBudWxsLCBnID0gMCwgdiA9IGg7IHYuZXF1YWxzKGQpID09PSAhMTsgdiA9IHYubmV4dCgpKSB7XG4gICAgICAgIHZhciBfID0gdGhpcy5fQ3JlYXRlX2l0ZXJhdG9yKHAsIG51bGwsIHYudmFsdWUpO1xuICAgICAgICBnID09PSAwICYmICh5ID0gXyksIG4uTGlzdEl0ZXJhdG9yLl9TZXRfbmV4dChwLCBfKSwgcCA9IF8sICsrZztcbiAgICAgIH1cbiAgICAgIHJldHVybiB1LmVxdWFscyh0aGlzLmJlZ2luKCkpID09PSAhMCAmJiAodGhpcy5iZWdpbl8gPSB5KSwgbi5MaXN0SXRlcmF0b3IuX1NldF9uZXh0KHAsIHUpLCBuLkxpc3RJdGVyYXRvci5fU2V0X3ByZXYodSwgcCksIHRoaXMuc2l6ZV8gKz0gZywgeTtcbiAgICB9LCBmLnByb3RvdHlwZS5lcmFzZSA9IGZ1bmN0aW9uKHUsIGgpIHtcbiAgICAgIHJldHVybiBoID09PSB2b2lkIDAgJiYgKGggPSB1Lm5leHQoKSksIHRoaXMuX0VyYXNlX2J5X3JhbmdlKHUsIGgpO1xuICAgIH0sIGYucHJvdG90eXBlLl9FcmFzZV9ieV9yYW5nZSA9IGZ1bmN0aW9uKHUsIGgpIHtcbiAgICAgIGlmICh1LnNvdXJjZSgpICE9PSB0aGlzLmVuZF8uc291cmNlKCkpXG4gICAgICAgIHRocm93IGEuRXJyb3JHZW5lcmF0b3Iubm90X215X2l0ZXJhdG9yKHRoaXMuZW5kXy5zb3VyY2UoKSwgXCJpbnNlcnRcIik7XG4gICAgICBpZiAodS5lcmFzZWRfID09PSAhMClcbiAgICAgICAgdGhyb3cgYS5FcnJvckdlbmVyYXRvci5lcmFzZWRfaXRlcmF0b3IodGhpcy5lbmRfLnNvdXJjZSgpLCBcImluc2VydFwiKTtcbiAgICAgIGlmICh1LmVxdWFscyh0aGlzLmVuZF8pKVxuICAgICAgICByZXR1cm4gdGhpcy5lbmRfO1xuICAgICAgdmFyIGQgPSB1LnByZXYoKTtcbiAgICAgIG4uTGlzdEl0ZXJhdG9yLl9TZXRfbmV4dChkLCBoKSwgbi5MaXN0SXRlcmF0b3IuX1NldF9wcmV2KGgsIGQpO1xuICAgICAgZm9yICh2YXIgcCA9IHU7ICFwLmVxdWFscyhoKTsgcCA9IHAubmV4dCgpKVxuICAgICAgICBwLmVyYXNlZF8gPSAhMCwgLS10aGlzLnNpemVfO1xuICAgICAgcmV0dXJuIHUuZXF1YWxzKHRoaXMuYmVnaW5fKSAmJiAodGhpcy5iZWdpbl8gPSBoKSwgaDtcbiAgICB9LCBmLnByb3RvdHlwZS5zd2FwID0gZnVuY3Rpb24odSkge1xuICAgICAgdmFyIGgsIGQsIHA7XG4gICAgICBoID0gZShbdS5iZWdpbl8sIHRoaXMuYmVnaW5fXSwgMiksIHRoaXMuYmVnaW5fID0gaFswXSwgdS5iZWdpbl8gPSBoWzFdLCBkID0gZShbdS5lbmRfLCB0aGlzLmVuZF9dLCAyKSwgdGhpcy5lbmRfID0gZFswXSwgdS5lbmRfID0gZFsxXSwgcCA9IGUoW3Uuc2l6ZV8sIHRoaXMuc2l6ZV9dLCAyKSwgdGhpcy5zaXplXyA9IHBbMF0sIHUuc2l6ZV8gPSBwWzFdO1xuICAgIH0sIGY7XG4gIH0oci5Db250YWluZXIpO1xuICByZXR1cm4gRHQuTGlzdENvbnRhaW5lciA9IGMsIER0O1xufVxudmFyIEt0ID0ge30sIHhvO1xuZnVuY3Rpb24gSWEoKSB7XG4gIGlmICh4bylcbiAgICByZXR1cm4gS3Q7XG4gIHhvID0gMSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KEt0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIEt0LlJldmVyc2VJdGVyYXRvciA9IHZvaWQgMDtcbiAgdmFyIHQgPSBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBlKHIpIHtcbiAgICAgIHRoaXMuYmFzZV8gPSByLnByZXYoKTtcbiAgICB9XG4gICAgcmV0dXJuIGUucHJvdG90eXBlLnNvdXJjZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYmFzZV8uc291cmNlKCk7XG4gICAgfSwgZS5wcm90b3R5cGUuYmFzZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYmFzZV8ubmV4dCgpO1xuICAgIH0sIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iYXNlXy52YWx1ZTtcbiAgICAgIH0sXG4gICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICB9KSwgZS5wcm90b3R5cGUucHJldiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX0NyZWF0ZV9uZWlnaGJvcih0aGlzLmJhc2UoKS5uZXh0KCkpO1xuICAgIH0sIGUucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9DcmVhdGVfbmVpZ2hib3IodGhpcy5iYXNlXyk7XG4gICAgfSwgZS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24ocikge1xuICAgICAgcmV0dXJuIHRoaXMuYmFzZV8uZXF1YWxzKHIuYmFzZV8pO1xuICAgIH0sIGU7XG4gIH0oKTtcbiAgcmV0dXJuIEt0LlJldmVyc2VJdGVyYXRvciA9IHQsIEt0O1xufVxudmFyIEVvO1xuZnVuY3Rpb24gUWgoKSB7XG4gIHJldHVybiBFbyB8fCAoRW8gPSAxLCBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGUgPSBTICYmIFMuX19leHRlbmRzIHx8IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGEgPSBmdW5jdGlvbihjLCBsKSB7XG4gICAgICAgIHJldHVybiBhID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24oZiwgdSkge1xuICAgICAgICAgIGYuX19wcm90b19fID0gdTtcbiAgICAgICAgfSB8fCBmdW5jdGlvbihmLCB1KSB7XG4gICAgICAgICAgZm9yICh2YXIgaCBpbiB1KVxuICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHUsIGgpICYmIChmW2hdID0gdVtoXSk7XG4gICAgICAgIH0sIGEoYywgbCk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGMsIGwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBsICE9IFwiZnVuY3Rpb25cIiAmJiBsICE9PSBudWxsKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGwpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgYShjLCBsKTtcbiAgICAgICAgZnVuY3Rpb24gZigpIHtcbiAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yID0gYztcbiAgICAgICAgfVxuICAgICAgICBjLnByb3RvdHlwZSA9IGwgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGwpIDogKGYucHJvdG90eXBlID0gbC5wcm90b3R5cGUsIG5ldyBmKCkpO1xuICAgICAgfTtcbiAgICB9KCksIHIgPSBTICYmIFMuX19yZWFkIHx8IGZ1bmN0aW9uKGEsIGMpIHtcbiAgICAgIHZhciBsID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgYVtTeW1ib2wuaXRlcmF0b3JdO1xuICAgICAgaWYgKCFsKVxuICAgICAgICByZXR1cm4gYTtcbiAgICAgIHZhciBmID0gbC5jYWxsKGEpLCB1LCBoID0gW10sIGQ7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKDsgKGMgPT09IHZvaWQgMCB8fCBjLS0gPiAwKSAmJiAhKHUgPSBmLm5leHQoKSkuZG9uZTsgKVxuICAgICAgICAgIGgucHVzaCh1LnZhbHVlKTtcbiAgICAgIH0gY2F0Y2ggKHApIHtcbiAgICAgICAgZCA9IHsgZXJyb3I6IHAgfTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdSAmJiAhdS5kb25lICYmIChsID0gZi5yZXR1cm4pICYmIGwuY2FsbChmKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoZClcbiAgICAgICAgICAgIHRocm93IGQuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBoO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgdC5TZXRFbGVtZW50TGlzdCA9IHZvaWQgMDtcbiAgICB2YXIgbiA9IENhKCksIGkgPSBtaSgpLCBzID0gSWEoKSwgbyA9IGZ1bmN0aW9uKGEpIHtcbiAgICAgIGUoYywgYSk7XG4gICAgICBmdW5jdGlvbiBjKGwpIHtcbiAgICAgICAgdmFyIGYgPSBhLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgcmV0dXJuIGYuYXNzb2NpYXRpdmVfID0gbCwgZjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjLnByb3RvdHlwZS5fQ3JlYXRlX2l0ZXJhdG9yID0gZnVuY3Rpb24obCwgZiwgdSkge1xuICAgICAgICByZXR1cm4gYy5JdGVyYXRvci5jcmVhdGUodGhpcywgbCwgZiwgdSk7XG4gICAgICB9LCBjLl9Td2FwX2Fzc29jaWF0aXZlID0gZnVuY3Rpb24obCwgZikge1xuICAgICAgICB2YXIgdTtcbiAgICAgICAgdSA9IHIoW2YuYXNzb2NpYXRpdmVfLCBsLmFzc29jaWF0aXZlX10sIDIpLCBsLmFzc29jaWF0aXZlXyA9IHVbMF0sIGYuYXNzb2NpYXRpdmVfID0gdVsxXTtcbiAgICAgIH0sIGMucHJvdG90eXBlLmFzc29jaWF0aXZlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFzc29jaWF0aXZlXztcbiAgICAgIH0sIGM7XG4gICAgfShuLkxpc3RDb250YWluZXIpO1xuICAgIHQuU2V0RWxlbWVudExpc3QgPSBvLCBmdW5jdGlvbihhKSB7XG4gICAgICB2YXIgYyA9IGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgZSh1LCBmKTtcbiAgICAgICAgZnVuY3Rpb24gdShoLCBkLCBwLCB5KSB7XG4gICAgICAgICAgdmFyIGcgPSBmLmNhbGwodGhpcywgZCwgcCwgeSkgfHwgdGhpcztcbiAgICAgICAgICByZXR1cm4gZy5zb3VyY2VfID0gaCwgZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdS5jcmVhdGUgPSBmdW5jdGlvbihoLCBkLCBwLCB5KSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyB1KGgsIGQsIHAsIHkpO1xuICAgICAgICB9LCB1LnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBsKHRoaXMpO1xuICAgICAgICB9LCB1LnByb3RvdHlwZS5zb3VyY2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VfLmFzc29jaWF0aXZlKCk7XG4gICAgICAgIH0sIHU7XG4gICAgICB9KGkuTGlzdEl0ZXJhdG9yKTtcbiAgICAgIGEuSXRlcmF0b3IgPSBjO1xuICAgICAgdmFyIGwgPSBmdW5jdGlvbihmKSB7XG4gICAgICAgIGUodSwgZik7XG4gICAgICAgIGZ1bmN0aW9uIHUoKSB7XG4gICAgICAgICAgcmV0dXJuIGYgIT09IG51bGwgJiYgZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHUucHJvdG90eXBlLl9DcmVhdGVfbmVpZ2hib3IgPSBmdW5jdGlvbihoKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyB1KGgpO1xuICAgICAgICB9LCB1O1xuICAgICAgfShzLlJldmVyc2VJdGVyYXRvcik7XG4gICAgICBhLlJldmVyc2VJdGVyYXRvciA9IGw7XG4gICAgfShvID0gdC5TZXRFbGVtZW50TGlzdCB8fCAodC5TZXRFbGVtZW50TGlzdCA9IHt9KSksIHQuU2V0RWxlbWVudExpc3QgPSBvO1xuICB9KHhuKSksIHhuO1xufVxudmFyIFd0ID0ge30sIFZ0ID0ge30sIGtvO1xuZnVuY3Rpb24gUmEoKSB7XG4gIGlmIChrbylcbiAgICByZXR1cm4gVnQ7XG4gIGtvID0gMTtcbiAgdmFyIHQgPSBTICYmIFMuX192YWx1ZXMgfHwgZnVuY3Rpb24oaSkge1xuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBvID0gcyAmJiBpW3NdLCBhID0gMDtcbiAgICBpZiAobylcbiAgICAgIHJldHVybiBvLmNhbGwoaSk7XG4gICAgaWYgKGkgJiYgdHlwZW9mIGkubGVuZ3RoID09IFwibnVtYmVyXCIpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gaSAmJiBhID49IGkubGVuZ3RoICYmIChpID0gdm9pZCAwKSwgeyB2YWx1ZTogaSAmJiBpW2ErK10sIGRvbmU6ICFpIH07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgVnQuSGFzaEJ1Y2tldHMgPSB2b2lkIDA7XG4gIHZhciBlID0gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gaShzLCBvKSB7XG4gICAgICB0aGlzLmZldGNoZXJfID0gcywgdGhpcy5oYXNoZXJfID0gbywgdGhpcy5tYXhfbG9hZF9mYWN0b3JfID0gbiwgdGhpcy5kYXRhXyA9IFtdLCB0aGlzLnNpemVfID0gMCwgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgfVxuICAgIHJldHVybiBpLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kYXRhXyA9IFtdLCB0aGlzLnNpemVfID0gMCwgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgfSwgaS5wcm90b3R5cGUucmVoYXNoID0gZnVuY3Rpb24ocykge1xuICAgICAgdmFyIG8sIGEsIGMsIGw7XG4gICAgICBzID0gTWF0aC5tYXgocywgcik7XG4gICAgICBmb3IgKHZhciBmID0gW10sIHUgPSAwOyB1IDwgczsgKyt1KVxuICAgICAgICBmLnB1c2goW10pO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgaCA9IHQodGhpcy5kYXRhXyksIGQgPSBoLm5leHQoKTsgIWQuZG9uZTsgZCA9IGgubmV4dCgpKSB7XG4gICAgICAgICAgdmFyIHAgPSBkLnZhbHVlO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciB5ID0gKGMgPSB2b2lkIDAsIHQocCkpLCBnID0geS5uZXh0KCk7ICFnLmRvbmU7IGcgPSB5Lm5leHQoKSkge1xuICAgICAgICAgICAgICB2YXIgdiA9IGcudmFsdWUsIF8gPSB0aGlzLmhhc2hlcl8odGhpcy5mZXRjaGVyXyh2KSkgJSBmLmxlbmd0aDtcbiAgICAgICAgICAgICAgZltfXS5wdXNoKHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKG0pIHtcbiAgICAgICAgICAgIGMgPSB7IGVycm9yOiBtIH07XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGcgJiYgIWcuZG9uZSAmJiAobCA9IHkucmV0dXJuKSAmJiBsLmNhbGwoeSk7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICBpZiAoYylcbiAgICAgICAgICAgICAgICB0aHJvdyBjLmVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAobSkge1xuICAgICAgICBvID0geyBlcnJvcjogbSB9O1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBkICYmICFkLmRvbmUgJiYgKGEgPSBoLnJldHVybikgJiYgYS5jYWxsKGgpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChvKVxuICAgICAgICAgICAgdGhyb3cgby5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5kYXRhXyA9IGY7XG4gICAgfSwgaS5wcm90b3R5cGUucmVzZXJ2ZSA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgIHMgPiB0aGlzLmNhcGFjaXR5KCkgJiYgKHMgPSBNYXRoLmZsb29yKHMgLyB0aGlzLm1heF9sb2FkX2ZhY3Rvcl8pLCB0aGlzLnJlaGFzaChzKSk7XG4gICAgfSwgaS5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgZm9yICh2YXIgcyA9IDA7IHMgPCByOyArK3MpXG4gICAgICAgIHRoaXMuZGF0YV8ucHVzaChbXSk7XG4gICAgfSwgaS5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5kYXRhXy5sZW5ndGg7XG4gICAgfSwgaS5wcm90b3R5cGUuY2FwYWNpdHkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmRhdGFfLmxlbmd0aCAqIHRoaXMubWF4X2xvYWRfZmFjdG9yXztcbiAgICB9LCBpLnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgIHJldHVybiB0aGlzLmRhdGFfW3NdO1xuICAgIH0sIGkucHJvdG90eXBlLmxvYWRfZmFjdG9yID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5zaXplXyAvIHRoaXMubGVuZ3RoKCk7XG4gICAgfSwgaS5wcm90b3R5cGUubWF4X2xvYWRfZmFjdG9yID0gZnVuY3Rpb24ocykge1xuICAgICAgaWYgKHMgPT09IHZvaWQgMCAmJiAocyA9IG51bGwpLCBzID09PSBudWxsKVxuICAgICAgICByZXR1cm4gdGhpcy5tYXhfbG9hZF9mYWN0b3JfO1xuICAgICAgdGhpcy5tYXhfbG9hZF9mYWN0b3JfID0gcztcbiAgICB9LCBpLnByb3RvdHlwZS5oYXNoX2Z1bmN0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYXNoZXJfO1xuICAgIH0sIGkucHJvdG90eXBlLmluZGV4ID0gZnVuY3Rpb24ocykge1xuICAgICAgcmV0dXJuIHRoaXMuaGFzaGVyXyh0aGlzLmZldGNoZXJfKHMpKSAlIHRoaXMubGVuZ3RoKCk7XG4gICAgfSwgaS5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24ocykge1xuICAgICAgdmFyIG8gPSB0aGlzLmNhcGFjaXR5KCk7XG4gICAgICArK3RoaXMuc2l6ZV8gPiBvICYmIHRoaXMucmVzZXJ2ZShvICogMik7XG4gICAgICB2YXIgYSA9IHRoaXMuaW5kZXgocyk7XG4gICAgICB0aGlzLmRhdGFfW2FdLnB1c2gocyk7XG4gICAgfSwgaS5wcm90b3R5cGUuZXJhc2UgPSBmdW5jdGlvbihzKSB7XG4gICAgICBmb3IgKHZhciBvID0gdGhpcy5pbmRleChzKSwgYSA9IHRoaXMuZGF0YV9bb10sIGMgPSAwOyBjIDwgYS5sZW5ndGg7ICsrYylcbiAgICAgICAgaWYgKGFbY10gPT09IHMpIHtcbiAgICAgICAgICBhLnNwbGljZShjLCAxKSwgLS10aGlzLnNpemVfO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfSwgaTtcbiAgfSgpO1xuICBWdC5IYXNoQnVja2V0cyA9IGU7XG4gIHZhciByID0gMTAsIG4gPSAxO1xuICByZXR1cm4gVnQ7XG59XG52YXIgU287XG5mdW5jdGlvbiBlZCgpIHtcbiAgaWYgKFNvKVxuICAgIHJldHVybiBXdDtcbiAgU28gPSAxO1xuICB2YXIgdCA9IFMgJiYgUy5fX2V4dGVuZHMgfHwgZnVuY3Rpb24oKSB7XG4gICAgdmFyIG8gPSBmdW5jdGlvbihhLCBjKSB7XG4gICAgICByZXR1cm4gbyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uKGwsIGYpIHtcbiAgICAgICAgbC5fX3Byb3RvX18gPSBmO1xuICAgICAgfSB8fCBmdW5jdGlvbihsLCBmKSB7XG4gICAgICAgIGZvciAodmFyIHUgaW4gZilcbiAgICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZiwgdSkgJiYgKGxbdV0gPSBmW3VdKTtcbiAgICAgIH0sIG8oYSwgYyk7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24oYSwgYykge1xuICAgICAgaWYgKHR5cGVvZiBjICE9IFwiZnVuY3Rpb25cIiAmJiBjICE9PSBudWxsKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhjKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICBvKGEsIGMpO1xuICAgICAgZnVuY3Rpb24gbCgpIHtcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IGE7XG4gICAgICB9XG4gICAgICBhLnByb3RvdHlwZSA9IGMgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGMpIDogKGwucHJvdG90eXBlID0gYy5wcm90b3R5cGUsIG5ldyBsKCkpO1xuICAgIH07XG4gIH0oKSwgZSA9IFMgJiYgUy5fX3JlYWQgfHwgZnVuY3Rpb24obywgYSkge1xuICAgIHZhciBjID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghYylcbiAgICAgIHJldHVybiBvO1xuICAgIHZhciBsID0gYy5jYWxsKG8pLCBmLCB1ID0gW10sIGg7XG4gICAgdHJ5IHtcbiAgICAgIGZvciAoOyAoYSA9PT0gdm9pZCAwIHx8IGEtLSA+IDApICYmICEoZiA9IGwubmV4dCgpKS5kb25lOyApXG4gICAgICAgIHUucHVzaChmLnZhbHVlKTtcbiAgICB9IGNhdGNoIChkKSB7XG4gICAgICBoID0geyBlcnJvcjogZCB9O1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBmICYmICFmLmRvbmUgJiYgKGMgPSBsLnJldHVybikgJiYgYy5jYWxsKGwpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGgpXG4gICAgICAgICAgdGhyb3cgaC5lcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHU7XG4gIH0sIHIgPSBTICYmIFMuX192YWx1ZXMgfHwgZnVuY3Rpb24obykge1xuICAgIHZhciBhID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBjID0gYSAmJiBvW2FdLCBsID0gMDtcbiAgICBpZiAoYylcbiAgICAgIHJldHVybiBjLmNhbGwobyk7XG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09IFwibnVtYmVyXCIpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gbyAmJiBsID49IG8ubGVuZ3RoICYmIChvID0gdm9pZCAwKSwgeyB2YWx1ZTogbyAmJiBvW2wrK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihhID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3QsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgV3QuU2V0SGFzaEJ1Y2tldHMgPSB2b2lkIDA7XG4gIHZhciBuID0gUmEoKSwgaSA9IGZ1bmN0aW9uKG8pIHtcbiAgICB0KGEsIG8pO1xuICAgIGZ1bmN0aW9uIGEoYywgbCwgZikge1xuICAgICAgdmFyIHUgPSBvLmNhbGwodGhpcywgcywgbCkgfHwgdGhpcztcbiAgICAgIHJldHVybiB1LnNvdXJjZV8gPSBjLCB1LmtleV9lcV8gPSBmLCB1O1xuICAgIH1cbiAgICByZXR1cm4gYS5fU3dhcF9zb3VyY2UgPSBmdW5jdGlvbihjLCBsKSB7XG4gICAgICB2YXIgZjtcbiAgICAgIGYgPSBlKFtsLnNvdXJjZV8sIGMuc291cmNlX10sIDIpLCBjLnNvdXJjZV8gPSBmWzBdLCBsLnNvdXJjZV8gPSBmWzFdO1xuICAgIH0sIGEucHJvdG90eXBlLmtleV9lcSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMua2V5X2VxXztcbiAgICB9LCBhLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24oYykge1xuICAgICAgdmFyIGwsIGYsIHUgPSB0aGlzLmhhc2hfZnVuY3Rpb24oKShjKSAlIHRoaXMubGVuZ3RoKCksIGggPSB0aGlzLmF0KHUpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgZCA9IHIoaCksIHAgPSBkLm5leHQoKTsgIXAuZG9uZTsgcCA9IGQubmV4dCgpKSB7XG4gICAgICAgICAgdmFyIHkgPSBwLnZhbHVlO1xuICAgICAgICAgIGlmICh0aGlzLmtleV9lcV8oeS52YWx1ZSwgYykpXG4gICAgICAgICAgICByZXR1cm4geTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZykge1xuICAgICAgICBsID0geyBlcnJvcjogZyB9O1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBwICYmICFwLmRvbmUgJiYgKGYgPSBkLnJldHVybikgJiYgZi5jYWxsKGQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChsKVxuICAgICAgICAgICAgdGhyb3cgbC5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuc291cmNlXy5lbmQoKTtcbiAgICB9LCBhO1xuICB9KG4uSGFzaEJ1Y2tldHMpO1xuICBXdC5TZXRIYXNoQnVja2V0cyA9IGk7XG4gIGZ1bmN0aW9uIHMobykge1xuICAgIHJldHVybiBvLnZhbHVlO1xuICB9XG4gIHJldHVybiBXdDtcbn1cbnZhciBzdCA9IHt9LCBPbztcbmZ1bmN0aW9uIFRhKCkge1xuICBpZiAoT28pXG4gICAgcmV0dXJuIHN0O1xuICBPbyA9IDEsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBzdC5tYWtlX3BhaXIgPSBzdC5QYWlyID0gdm9pZCAwO1xuICB2YXIgdCA9IHdpKCksIGUgPSBfaSgpLCByID0gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gaShzLCBvKSB7XG4gICAgICB0aGlzLmZpcnN0ID0gcywgdGhpcy5zZWNvbmQgPSBvO1xuICAgIH1cbiAgICByZXR1cm4gaS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24ocykge1xuICAgICAgcmV0dXJuICgwLCBlLmVxdWFsX3RvKSh0aGlzLmZpcnN0LCBzLmZpcnN0KSAmJiAoMCwgZS5lcXVhbF90bykodGhpcy5zZWNvbmQsIHMuc2Vjb25kKTtcbiAgICB9LCBpLnByb3RvdHlwZS5sZXNzID0gZnVuY3Rpb24ocykge1xuICAgICAgcmV0dXJuICgwLCBlLmVxdWFsX3RvKSh0aGlzLmZpcnN0LCBzLmZpcnN0KSA9PT0gITEgPyAoMCwgZS5sZXNzKSh0aGlzLmZpcnN0LCBzLmZpcnN0KSA6ICgwLCBlLmxlc3MpKHRoaXMuc2Vjb25kLCBzLnNlY29uZCk7XG4gICAgfSwgaS5wcm90b3R5cGUuaGFzaENvZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAoMCwgdC5oYXNoKSh0aGlzLmZpcnN0LCB0aGlzLnNlY29uZCk7XG4gICAgfSwgaTtcbiAgfSgpO1xuICBzdC5QYWlyID0gcjtcbiAgZnVuY3Rpb24gbihpLCBzKSB7XG4gICAgcmV0dXJuIG5ldyByKGksIHMpO1xuICB9XG4gIHJldHVybiBzdC5tYWtlX3BhaXIgPSBuLCBzdDtcbn1cbnZhciBBbztcbmZ1bmN0aW9uIHRkKCkge1xuICByZXR1cm4gQW8gfHwgKEFvID0gMSwgZnVuY3Rpb24odCkge1xuICAgIHZhciBlID0gUyAmJiBTLl9fZXh0ZW5kcyB8fCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBmID0gZnVuY3Rpb24odSwgaCkge1xuICAgICAgICByZXR1cm4gZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uKGQsIHApIHtcbiAgICAgICAgICBkLl9fcHJvdG9fXyA9IHA7XG4gICAgICAgIH0gfHwgZnVuY3Rpb24oZCwgcCkge1xuICAgICAgICAgIGZvciAodmFyIHkgaW4gcClcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwLCB5KSAmJiAoZFt5XSA9IHBbeV0pO1xuICAgICAgICB9LCBmKHUsIGgpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBmdW5jdGlvbih1LCBoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaCAhPSBcImZ1bmN0aW9uXCIgJiYgaCAhPT0gbnVsbClcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhoKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGYodSwgaCk7XG4gICAgICAgIGZ1bmN0aW9uIGQoKSB7XG4gICAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IHU7XG4gICAgICAgIH1cbiAgICAgICAgdS5wcm90b3R5cGUgPSBoID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShoKSA6IChkLnByb3RvdHlwZSA9IGgucHJvdG90eXBlLCBuZXcgZCgpKTtcbiAgICAgIH07XG4gICAgfSgpLCByID0gUyAmJiBTLl9fcmVhZCB8fCBmdW5jdGlvbihmLCB1KSB7XG4gICAgICB2YXIgaCA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIGZbU3ltYm9sLml0ZXJhdG9yXTtcbiAgICAgIGlmICghaClcbiAgICAgICAgcmV0dXJuIGY7XG4gICAgICB2YXIgZCA9IGguY2FsbChmKSwgcCwgeSA9IFtdLCBnO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICg7ICh1ID09PSB2b2lkIDAgfHwgdS0tID4gMCkgJiYgIShwID0gZC5uZXh0KCkpLmRvbmU7IClcbiAgICAgICAgICB5LnB1c2gocC52YWx1ZSk7XG4gICAgICB9IGNhdGNoICh2KSB7XG4gICAgICAgIGcgPSB7IGVycm9yOiB2IH07XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHAgJiYgIXAuZG9uZSAmJiAoaCA9IGQucmV0dXJuKSAmJiBoLmNhbGwoZCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKGcpXG4gICAgICAgICAgICB0aHJvdyBnLmVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4geTtcbiAgICB9LCBuID0gUyAmJiBTLl9fc3ByZWFkQXJyYXkgfHwgZnVuY3Rpb24oZiwgdSwgaCkge1xuICAgICAgaWYgKGggfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMilcbiAgICAgICAgZm9yICh2YXIgZCA9IDAsIHAgPSB1Lmxlbmd0aCwgeTsgZCA8IHA7IGQrKylcbiAgICAgICAgICAoeSB8fCAhKGQgaW4gdSkpICYmICh5IHx8ICh5ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodSwgMCwgZCkpLCB5W2RdID0gdVtkXSk7XG4gICAgICByZXR1cm4gZi5jb25jYXQoeSB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh1KSk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCB0Lkhhc2hTZXQgPSB2b2lkIDA7XG4gICAgdmFyIGkgPSBHaCgpLCBzID0gQWEoKSwgbyA9IFFoKCksIGEgPSBlZCgpLCBjID0gVGEoKSwgbCA9IGZ1bmN0aW9uKGYpIHtcbiAgICAgIGUodSwgZik7XG4gICAgICBmdW5jdGlvbiB1KCkge1xuICAgICAgICBmb3IgKHZhciBoID0gW10sIGQgPSAwOyBkIDwgYXJndW1lbnRzLmxlbmd0aDsgZCsrKVxuICAgICAgICAgIGhbZF0gPSBhcmd1bWVudHNbZF07XG4gICAgICAgIHZhciBwID0gZi5jYWxsKHRoaXMsIGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IG8uU2V0RWxlbWVudExpc3QoeSk7XG4gICAgICAgIH0pIHx8IHRoaXM7XG4gICAgICAgIHJldHVybiBzLklIYXNoQ29udGFpbmVyLmNvbnN0cnVjdC5hcHBseShzLklIYXNoQ29udGFpbmVyLCBuKFtcbiAgICAgICAgICBwLFxuICAgICAgICAgIHUsXG4gICAgICAgICAgZnVuY3Rpb24oeSwgZykge1xuICAgICAgICAgICAgcC5idWNrZXRzXyA9IG5ldyBhLlNldEhhc2hCdWNrZXRzKHAsIHksIGcpO1xuICAgICAgICAgIH1cbiAgICAgICAgXSwgcihoKSwgITEpKSwgcDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmJ1Y2tldHNfLmNsZWFyKCksIGYucHJvdG90eXBlLmNsZWFyLmNhbGwodGhpcyk7XG4gICAgICB9LCB1LnByb3RvdHlwZS5zd2FwID0gZnVuY3Rpb24oaCkge1xuICAgICAgICB2YXIgZCwgcDtcbiAgICAgICAgZCA9IHIoW2guZGF0YV8sIHRoaXMuZGF0YV9dLCAyKSwgdGhpcy5kYXRhXyA9IGRbMF0sIGguZGF0YV8gPSBkWzFdLCBvLlNldEVsZW1lbnRMaXN0Ll9Td2FwX2Fzc29jaWF0aXZlKHRoaXMuZGF0YV8sIGguZGF0YV8pLCBhLlNldEhhc2hCdWNrZXRzLl9Td2FwX3NvdXJjZSh0aGlzLmJ1Y2tldHNfLCBoLmJ1Y2tldHNfKSwgcCA9IHIoW2guYnVja2V0c18sIHRoaXMuYnVja2V0c19dLCAyKSwgdGhpcy5idWNrZXRzXyA9IHBbMF0sIGguYnVja2V0c18gPSBwWzFdO1xuICAgICAgfSwgdS5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVja2V0c18uZmluZChoKTtcbiAgICAgIH0sIHUucHJvdG90eXBlLmJlZ2luID0gZnVuY3Rpb24oaCkge1xuICAgICAgICByZXR1cm4gaCA9PT0gdm9pZCAwICYmIChoID0gbnVsbCksIGggPT09IG51bGwgPyBmLnByb3RvdHlwZS5iZWdpbi5jYWxsKHRoaXMpIDogdGhpcy5idWNrZXRzXy5hdChoKVswXTtcbiAgICAgIH0sIHUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgaWYgKGggPT09IHZvaWQgMCAmJiAoaCA9IG51bGwpLCBoID09PSBudWxsKVxuICAgICAgICAgIHJldHVybiBmLnByb3RvdHlwZS5lbmQuY2FsbCh0aGlzKTtcbiAgICAgICAgdmFyIGQgPSB0aGlzLmJ1Y2tldHNfLmF0KGgpO1xuICAgICAgICByZXR1cm4gZFtkLmxlbmd0aCAtIDFdLm5leHQoKTtcbiAgICAgIH0sIHUucHJvdG90eXBlLnJiZWdpbiA9IGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgcmV0dXJuIGggPT09IHZvaWQgMCAmJiAoaCA9IG51bGwpLCB0aGlzLmVuZChoKS5yZXZlcnNlKCk7XG4gICAgICB9LCB1LnByb3RvdHlwZS5yZW5kID0gZnVuY3Rpb24oaCkge1xuICAgICAgICByZXR1cm4gaCA9PT0gdm9pZCAwICYmIChoID0gbnVsbCksIHRoaXMuYmVnaW4oaCkucmV2ZXJzZSgpO1xuICAgICAgfSwgdS5wcm90b3R5cGUuYnVja2V0X2NvdW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1Y2tldHNfLmxlbmd0aCgpO1xuICAgICAgfSwgdS5wcm90b3R5cGUuYnVja2V0X3NpemUgPSBmdW5jdGlvbihoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1Y2tldHNfLmF0KGgpLmxlbmd0aDtcbiAgICAgIH0sIHUucHJvdG90eXBlLmxvYWRfZmFjdG9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1Y2tldHNfLmxvYWRfZmFjdG9yKCk7XG4gICAgICB9LCB1LnByb3RvdHlwZS5oYXNoX2Z1bmN0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1Y2tldHNfLmhhc2hfZnVuY3Rpb24oKTtcbiAgICAgIH0sIHUucHJvdG90eXBlLmtleV9lcSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWNrZXRzXy5rZXlfZXEoKTtcbiAgICAgIH0sIHUucHJvdG90eXBlLmJ1Y2tldCA9IGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzaF9mdW5jdGlvbigpKGgpICUgdGhpcy5idWNrZXRzXy5sZW5ndGgoKTtcbiAgICAgIH0sIHUucHJvdG90eXBlLm1heF9sb2FkX2ZhY3RvciA9IGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgcmV0dXJuIGggPT09IHZvaWQgMCAmJiAoaCA9IG51bGwpLCB0aGlzLmJ1Y2tldHNfLm1heF9sb2FkX2ZhY3RvcihoKTtcbiAgICAgIH0sIHUucHJvdG90eXBlLnJlc2VydmUgPSBmdW5jdGlvbihoKSB7XG4gICAgICAgIHRoaXMuYnVja2V0c18ucmVzZXJ2ZShoKTtcbiAgICAgIH0sIHUucHJvdG90eXBlLnJlaGFzaCA9IGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgdGhpcy5idWNrZXRzXy5yZWhhc2goaCk7XG4gICAgICB9LCB1LnByb3RvdHlwZS5fSW5zZXJ0X2J5X2tleSA9IGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgdmFyIGQgPSB0aGlzLmZpbmQoaCk7XG4gICAgICAgIHJldHVybiBkLmVxdWFscyh0aGlzLmVuZCgpKSA9PT0gITEgPyBuZXcgYy5QYWlyKGQsICExKSA6ICh0aGlzLmRhdGFfLnB1c2goaCksIGQgPSBkLnByZXYoKSwgdGhpcy5fSGFuZGxlX2luc2VydChkLCBkLm5leHQoKSksIG5ldyBjLlBhaXIoZCwgITApKTtcbiAgICAgIH0sIHUucHJvdG90eXBlLl9JbnNlcnRfYnlfaGludCA9IGZ1bmN0aW9uKGgsIGQpIHtcbiAgICAgICAgdmFyIHAgPSB0aGlzLmZpbmQoZCk7XG4gICAgICAgIHJldHVybiBwLmVxdWFscyh0aGlzLmVuZCgpKSA9PT0gITAgJiYgKHAgPSB0aGlzLmRhdGFfLmluc2VydChoLCBkKSwgdGhpcy5fSGFuZGxlX2luc2VydChwLCBwLm5leHQoKSkpLCBwO1xuICAgICAgfSwgdS5wcm90b3R5cGUuX0hhbmRsZV9pbnNlcnQgPSBmdW5jdGlvbihoLCBkKSB7XG4gICAgICAgIGZvciAoOyAhaC5lcXVhbHMoZCk7IGggPSBoLm5leHQoKSlcbiAgICAgICAgICB0aGlzLmJ1Y2tldHNfLmluc2VydChoKTtcbiAgICAgIH0sIHUucHJvdG90eXBlLl9IYW5kbGVfZXJhc2UgPSBmdW5jdGlvbihoLCBkKSB7XG4gICAgICAgIGZvciAoOyAhaC5lcXVhbHMoZCk7IGggPSBoLm5leHQoKSlcbiAgICAgICAgICB0aGlzLmJ1Y2tldHNfLmVyYXNlKGgpO1xuICAgICAgfSwgdTtcbiAgICB9KGkuVW5pcXVlU2V0KTtcbiAgICB0Lkhhc2hTZXQgPSBsLCBmdW5jdGlvbihmKSB7XG4gICAgICBmLkl0ZXJhdG9yID0gby5TZXRFbGVtZW50TGlzdC5JdGVyYXRvciwgZi5SZXZlcnNlSXRlcmF0b3IgPSBvLlNldEVsZW1lbnRMaXN0LlJldmVyc2VJdGVyYXRvcjtcbiAgICB9KGwgPSB0Lkhhc2hTZXQgfHwgKHQuSGFzaFNldCA9IHt9KSksIHQuSGFzaFNldCA9IGw7XG4gIH0odm4pKSwgdm47XG59XG52YXIgRW4gPSB7fSwgR3QgPSB7fSwgWnQgPSB7fSwgQ287XG5mdW5jdGlvbiByZCgpIHtcbiAgaWYgKENvKVxuICAgIHJldHVybiBadDtcbiAgQ28gPSAxO1xuICB2YXIgdCA9IFMgJiYgUy5fX2V4dGVuZHMgfHwgZnVuY3Rpb24oKSB7XG4gICAgdmFyIGkgPSBmdW5jdGlvbihzLCBvKSB7XG4gICAgICByZXR1cm4gaSA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uKGEsIGMpIHtcbiAgICAgICAgYS5fX3Byb3RvX18gPSBjO1xuICAgICAgfSB8fCBmdW5jdGlvbihhLCBjKSB7XG4gICAgICAgIGZvciAodmFyIGwgaW4gYylcbiAgICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYywgbCkgJiYgKGFbbF0gPSBjW2xdKTtcbiAgICAgIH0sIGkocywgbyk7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24ocywgbykge1xuICAgICAgaWYgKHR5cGVvZiBvICE9IFwiZnVuY3Rpb25cIiAmJiBvICE9PSBudWxsKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhvKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICBpKHMsIG8pO1xuICAgICAgZnVuY3Rpb24gYSgpIHtcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IHM7XG4gICAgICB9XG4gICAgICBzLnByb3RvdHlwZSA9IG8gPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKG8pIDogKGEucHJvdG90eXBlID0gby5wcm90b3R5cGUsIG5ldyBhKCkpO1xuICAgIH07XG4gIH0oKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFp0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIFp0Lk1hcENvbnRhaW5lciA9IHZvaWQgMDtcbiAgdmFyIGUgPSBiaSgpLCByID0gdmkoKSwgbiA9IGZ1bmN0aW9uKGkpIHtcbiAgICB0KHMsIGkpO1xuICAgIGZ1bmN0aW9uIHMobykge1xuICAgICAgdmFyIGEgPSBpLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgIHJldHVybiBhLmRhdGFfID0gbyhhKSwgYTtcbiAgICB9XG4gICAgcmV0dXJuIHMucHJvdG90eXBlLmFzc2lnbiA9IGZ1bmN0aW9uKG8sIGEpIHtcbiAgICAgIHRoaXMuY2xlYXIoKSwgdGhpcy5pbnNlcnQobywgYSk7XG4gICAgfSwgcy5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZGF0YV8uY2xlYXIoKTtcbiAgICB9LCBzLnByb3RvdHlwZS5iZWdpbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGF0YV8uYmVnaW4oKTtcbiAgICB9LCBzLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmRhdGFfLmVuZCgpO1xuICAgIH0sIHMucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgIHJldHVybiAhdGhpcy5maW5kKG8pLmVxdWFscyh0aGlzLmVuZCgpKTtcbiAgICB9LCBzLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5kYXRhXy5zaXplKCk7XG4gICAgfSwgcy5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgZm9yICh2YXIgbyA9IFtdLCBhID0gMDsgYSA8IGFyZ3VtZW50cy5sZW5ndGg7IGErKylcbiAgICAgICAgb1thXSA9IGFyZ3VtZW50c1thXTtcbiAgICAgIHZhciBjID0gbmV3IHIuTmF0aXZlQXJyYXlJdGVyYXRvcihvLCAwKSwgbCA9IG5ldyByLk5hdGl2ZUFycmF5SXRlcmF0b3Iobywgby5sZW5ndGgpO1xuICAgICAgcmV0dXJuIHRoaXMuaW5zZXJ0KGMsIGwpLCB0aGlzLnNpemUoKTtcbiAgICB9LCBzLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGZvciAodmFyIG8gPSBbXSwgYSA9IDA7IGEgPCBhcmd1bWVudHMubGVuZ3RoOyBhKyspXG4gICAgICAgIG9bYV0gPSBhcmd1bWVudHNbYV07XG4gICAgICByZXR1cm4gby5sZW5ndGggPT09IDEgPyB0aGlzLmVtcGxhY2Uob1swXS5maXJzdCwgb1swXS5zZWNvbmQpIDogb1swXS5uZXh0IGluc3RhbmNlb2YgRnVuY3Rpb24gJiYgb1sxXS5uZXh0IGluc3RhbmNlb2YgRnVuY3Rpb24gPyB0aGlzLl9JbnNlcnRfYnlfcmFuZ2Uob1swXSwgb1sxXSkgOiB0aGlzLmVtcGxhY2VfaGludChvWzBdLCBvWzFdLmZpcnN0LCBvWzFdLnNlY29uZCk7XG4gICAgfSwgcy5wcm90b3R5cGUuZXJhc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIGZvciAodmFyIG8gPSBbXSwgYSA9IDA7IGEgPCBhcmd1bWVudHMubGVuZ3RoOyBhKyspXG4gICAgICAgIG9bYV0gPSBhcmd1bWVudHNbYV07XG4gICAgICByZXR1cm4gby5sZW5ndGggPT09IDEgJiYgKCEob1swXSBpbnN0YW5jZW9mIHRoaXMuZW5kKCkuY29uc3RydWN0b3IpIHx8IG9bMF0uc291cmNlKCkgIT09IHRoaXMpID8gdGhpcy5fRXJhc2VfYnlfa2V5KG9bMF0pIDogby5sZW5ndGggPT09IDEgPyB0aGlzLl9FcmFzZV9ieV9yYW5nZShvWzBdKSA6IHRoaXMuX0VyYXNlX2J5X3JhbmdlKG9bMF0sIG9bMV0pO1xuICAgIH0sIHMucHJvdG90eXBlLl9FcmFzZV9ieV9yYW5nZSA9IGZ1bmN0aW9uKG8sIGEpIHtcbiAgICAgIGEgPT09IHZvaWQgMCAmJiAoYSA9IG8ubmV4dCgpKTtcbiAgICAgIHZhciBjID0gdGhpcy5kYXRhXy5lcmFzZShvLCBhKTtcbiAgICAgIHJldHVybiB0aGlzLl9IYW5kbGVfZXJhc2UobywgYSksIGM7XG4gICAgfSwgcztcbiAgfShlLkNvbnRhaW5lcik7XG4gIHJldHVybiBadC5NYXBDb250YWluZXIgPSBuLCBadDtcbn1cbnZhciBJbztcbmZ1bmN0aW9uIG5kKCkge1xuICBpZiAoSW8pXG4gICAgcmV0dXJuIEd0O1xuICBJbyA9IDE7XG4gIHZhciB0ID0gUyAmJiBTLl9fZXh0ZW5kcyB8fCBmdW5jdGlvbigpIHtcbiAgICB2YXIgbyA9IGZ1bmN0aW9uKGEsIGMpIHtcbiAgICAgIHJldHVybiBvID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24obCwgZikge1xuICAgICAgICBsLl9fcHJvdG9fXyA9IGY7XG4gICAgICB9IHx8IGZ1bmN0aW9uKGwsIGYpIHtcbiAgICAgICAgZm9yICh2YXIgdSBpbiBmKVxuICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChmLCB1KSAmJiAobFt1XSA9IGZbdV0pO1xuICAgICAgfSwgbyhhLCBjKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbihhLCBjKSB7XG4gICAgICBpZiAodHlwZW9mIGMgIT0gXCJmdW5jdGlvblwiICYmIGMgIT09IG51bGwpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGMpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgIG8oYSwgYyk7XG4gICAgICBmdW5jdGlvbiBsKCkge1xuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yID0gYTtcbiAgICAgIH1cbiAgICAgIGEucHJvdG90eXBlID0gYyA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYykgOiAobC5wcm90b3R5cGUgPSBjLnByb3RvdHlwZSwgbmV3IGwoKSk7XG4gICAgfTtcbiAgfSgpLCBlID0gUyAmJiBTLl9fcmVhZCB8fCBmdW5jdGlvbihvLCBhKSB7XG4gICAgdmFyIGMgPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFjKVxuICAgICAgcmV0dXJuIG87XG4gICAgdmFyIGwgPSBjLmNhbGwobyksIGYsIHUgPSBbXSwgaDtcbiAgICB0cnkge1xuICAgICAgZm9yICg7IChhID09PSB2b2lkIDAgfHwgYS0tID4gMCkgJiYgIShmID0gbC5uZXh0KCkpLmRvbmU7IClcbiAgICAgICAgdS5wdXNoKGYudmFsdWUpO1xuICAgIH0gY2F0Y2ggKGQpIHtcbiAgICAgIGggPSB7IGVycm9yOiBkIH07XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGYgJiYgIWYuZG9uZSAmJiAoYyA9IGwucmV0dXJuKSAmJiBjLmNhbGwobCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoaClcbiAgICAgICAgICB0aHJvdyBoLmVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdTtcbiAgfSwgciA9IFMgJiYgUy5fX3NwcmVhZEFycmF5IHx8IGZ1bmN0aW9uKG8sIGEsIGMpIHtcbiAgICBpZiAoYyB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKVxuICAgICAgZm9yICh2YXIgbCA9IDAsIGYgPSBhLmxlbmd0aCwgdTsgbCA8IGY7IGwrKylcbiAgICAgICAgKHUgfHwgIShsIGluIGEpKSAmJiAodSB8fCAodSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGEsIDAsIGwpKSwgdVtsXSA9IGFbbF0pO1xuICAgIHJldHVybiBvLmNvbmNhdCh1IHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGEpKTtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEd0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIEd0LlVuaXF1ZU1hcCA9IHZvaWQgMDtcbiAgdmFyIG4gPSByZCgpLCBpID0gV3IoKSwgcyA9IGZ1bmN0aW9uKG8pIHtcbiAgICB0KGEsIG8pO1xuICAgIGZ1bmN0aW9uIGEoKSB7XG4gICAgICByZXR1cm4gbyAhPT0gbnVsbCAmJiBvLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIGEucHJvdG90eXBlLmNvdW50ID0gZnVuY3Rpb24oYykge1xuICAgICAgcmV0dXJuIHRoaXMuZmluZChjKS5lcXVhbHModGhpcy5lbmQoKSkgPyAwIDogMTtcbiAgICB9LCBhLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihjKSB7XG4gICAgICB2YXIgbCA9IHRoaXMuZmluZChjKTtcbiAgICAgIGlmIChsLmVxdWFscyh0aGlzLmVuZCgpKSA9PT0gITApXG4gICAgICAgIHRocm93IGkuRXJyb3JHZW5lcmF0b3Iua2V5X25vdXRfZm91bmQodGhpcywgXCJnZXRcIiwgYyk7XG4gICAgICByZXR1cm4gbC5zZWNvbmQ7XG4gICAgfSwgYS5wcm90b3R5cGUudGFrZSA9IGZ1bmN0aW9uKGMsIGwpIHtcbiAgICAgIHZhciBmID0gdGhpcy5maW5kKGMpO1xuICAgICAgcmV0dXJuIGYuZXF1YWxzKHRoaXMuZW5kKCkpID8gdGhpcy5lbXBsYWNlKGMsIGwoKSkuZmlyc3Quc2Vjb25kIDogZi5zZWNvbmQ7XG4gICAgfSwgYS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oYywgbCkge1xuICAgICAgdGhpcy5pbnNlcnRfb3JfYXNzaWduKGMsIGwpO1xuICAgIH0sIGEucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgZm9yICh2YXIgYyA9IFtdLCBsID0gMDsgbCA8IGFyZ3VtZW50cy5sZW5ndGg7IGwrKylcbiAgICAgICAgY1tsXSA9IGFyZ3VtZW50c1tsXTtcbiAgICAgIHJldHVybiBvLnByb3RvdHlwZS5pbnNlcnQuYXBwbHkodGhpcywgcihbXSwgZShjKSwgITEpKTtcbiAgICB9LCBhLnByb3RvdHlwZS5fSW5zZXJ0X2J5X3JhbmdlID0gZnVuY3Rpb24oYywgbCkge1xuICAgICAgZm9yICh2YXIgZiA9IGM7ICFmLmVxdWFscyhsKTsgZiA9IGYubmV4dCgpKVxuICAgICAgICB0aGlzLmVtcGxhY2UoZi52YWx1ZS5maXJzdCwgZi52YWx1ZS5zZWNvbmQpO1xuICAgIH0sIGEucHJvdG90eXBlLmluc2VydF9vcl9hc3NpZ24gPSBmdW5jdGlvbigpIHtcbiAgICAgIGZvciAodmFyIGMgPSBbXSwgbCA9IDA7IGwgPCBhcmd1bWVudHMubGVuZ3RoOyBsKyspXG4gICAgICAgIGNbbF0gPSBhcmd1bWVudHNbbF07XG4gICAgICBpZiAoYy5sZW5ndGggPT09IDIpXG4gICAgICAgIHJldHVybiB0aGlzLl9JbnNlcnRfb3JfYXNzaWduX3dpdGhfa2V5X3ZhbHVlKGNbMF0sIGNbMV0pO1xuICAgICAgaWYgKGMubGVuZ3RoID09PSAzKVxuICAgICAgICByZXR1cm4gdGhpcy5fSW5zZXJ0X29yX2Fzc2lnbl93aXRoX2hpbnQoY1swXSwgY1sxXSwgY1syXSk7XG4gICAgfSwgYS5wcm90b3R5cGUuX0luc2VydF9vcl9hc3NpZ25fd2l0aF9rZXlfdmFsdWUgPSBmdW5jdGlvbihjLCBsKSB7XG4gICAgICB2YXIgZiA9IHRoaXMuZW1wbGFjZShjLCBsKTtcbiAgICAgIHJldHVybiBmLnNlY29uZCA9PT0gITEgJiYgKGYuZmlyc3Quc2Vjb25kID0gbCksIGY7XG4gICAgfSwgYS5wcm90b3R5cGUuX0luc2VydF9vcl9hc3NpZ25fd2l0aF9oaW50ID0gZnVuY3Rpb24oYywgbCwgZikge1xuICAgICAgdmFyIHUgPSB0aGlzLmVtcGxhY2VfaGludChjLCBsLCBmKTtcbiAgICAgIHJldHVybiB1LnNlY29uZCAhPT0gZiAmJiAodS5zZWNvbmQgPSBmKSwgdTtcbiAgICB9LCBhLnByb3RvdHlwZS5leHRyYWN0ID0gZnVuY3Rpb24oYykge1xuICAgICAgcmV0dXJuIGMgaW5zdGFuY2VvZiB0aGlzLmVuZCgpLmNvbnN0cnVjdG9yID8gdGhpcy5fRXh0cmFjdF9ieV9pdGVyYXRvcihjKSA6IHRoaXMuX0V4dHJhY3RfYnlfa2V5KGMpO1xuICAgIH0sIGEucHJvdG90eXBlLl9FeHRyYWN0X2J5X2tleSA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgIHZhciBsID0gdGhpcy5maW5kKGMpO1xuICAgICAgaWYgKGwuZXF1YWxzKHRoaXMuZW5kKCkpID09PSAhMClcbiAgICAgICAgdGhyb3cgaS5FcnJvckdlbmVyYXRvci5rZXlfbm91dF9mb3VuZCh0aGlzLCBcImV4dHJhY3RcIiwgYyk7XG4gICAgICB2YXIgZiA9IGwudmFsdWU7XG4gICAgICByZXR1cm4gdGhpcy5fRXJhc2VfYnlfcmFuZ2UobCksIGY7XG4gICAgfSwgYS5wcm90b3R5cGUuX0V4dHJhY3RfYnlfaXRlcmF0b3IgPSBmdW5jdGlvbihjKSB7XG4gICAgICByZXR1cm4gYy5lcXVhbHModGhpcy5lbmQoKSkgPT09ICEwID8gdGhpcy5lbmQoKSA6ICh0aGlzLl9FcmFzZV9ieV9yYW5nZShjKSwgYyk7XG4gICAgfSwgYS5wcm90b3R5cGUuX0VyYXNlX2J5X2tleSA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgIHZhciBsID0gdGhpcy5maW5kKGMpO1xuICAgICAgcmV0dXJuIGwuZXF1YWxzKHRoaXMuZW5kKCkpID09PSAhMCA/IDAgOiAodGhpcy5fRXJhc2VfYnlfcmFuZ2UobCksIDEpO1xuICAgIH0sIGEucHJvdG90eXBlLm1lcmdlID0gZnVuY3Rpb24oYykge1xuICAgICAgZm9yICh2YXIgbCA9IGMuYmVnaW4oKTsgIWwuZXF1YWxzKGMuZW5kKCkpOyApXG4gICAgICAgIHRoaXMuaGFzKGwuZmlyc3QpID09PSAhMSA/ICh0aGlzLmluc2VydChsLnZhbHVlKSwgbCA9IGMuZXJhc2UobCkpIDogbCA9IGwubmV4dCgpO1xuICAgIH0sIGE7XG4gIH0obi5NYXBDb250YWluZXIpO1xuICByZXR1cm4gR3QuVW5pcXVlTWFwID0gcywgR3Q7XG59XG52YXIga24gPSB7fSwgUm87XG5mdW5jdGlvbiBpZCgpIHtcbiAgcmV0dXJuIFJvIHx8IChSbyA9IDEsIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSA9IFMgJiYgUy5fX2V4dGVuZHMgfHwgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYSA9IGZ1bmN0aW9uKGMsIGwpIHtcbiAgICAgICAgcmV0dXJuIGEgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbihmLCB1KSB7XG4gICAgICAgICAgZi5fX3Byb3RvX18gPSB1O1xuICAgICAgICB9IHx8IGZ1bmN0aW9uKGYsIHUpIHtcbiAgICAgICAgICBmb3IgKHZhciBoIGluIHUpXG4gICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodSwgaCkgJiYgKGZbaF0gPSB1W2hdKTtcbiAgICAgICAgfSwgYShjLCBsKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gZnVuY3Rpb24oYywgbCkge1xuICAgICAgICBpZiAodHlwZW9mIGwgIT0gXCJmdW5jdGlvblwiICYmIGwgIT09IG51bGwpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcobCkgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBhKGMsIGwpO1xuICAgICAgICBmdW5jdGlvbiBmKCkge1xuICAgICAgICAgIHRoaXMuY29uc3RydWN0b3IgPSBjO1xuICAgICAgICB9XG4gICAgICAgIGMucHJvdG90eXBlID0gbCA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUobCkgOiAoZi5wcm90b3R5cGUgPSBsLnByb3RvdHlwZSwgbmV3IGYoKSk7XG4gICAgICB9O1xuICAgIH0oKSwgciA9IFMgJiYgUy5fX3JlYWQgfHwgZnVuY3Rpb24oYSwgYykge1xuICAgICAgdmFyIGwgPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBhW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgICBpZiAoIWwpXG4gICAgICAgIHJldHVybiBhO1xuICAgICAgdmFyIGYgPSBsLmNhbGwoYSksIHUsIGggPSBbXSwgZDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoOyAoYyA9PT0gdm9pZCAwIHx8IGMtLSA+IDApICYmICEodSA9IGYubmV4dCgpKS5kb25lOyApXG4gICAgICAgICAgaC5wdXNoKHUudmFsdWUpO1xuICAgICAgfSBjYXRjaCAocCkge1xuICAgICAgICBkID0geyBlcnJvcjogcCB9O1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB1ICYmICF1LmRvbmUgJiYgKGwgPSBmLnJldHVybikgJiYgbC5jYWxsKGYpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChkKVxuICAgICAgICAgICAgdGhyb3cgZC5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGg7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCB0Lk1hcEVsZW1lbnRMaXN0ID0gdm9pZCAwO1xuICAgIHZhciBuID0gQ2EoKSwgaSA9IG1pKCksIHMgPSBJYSgpLCBvID0gZnVuY3Rpb24oYSkge1xuICAgICAgZShjLCBhKTtcbiAgICAgIGZ1bmN0aW9uIGMobCkge1xuICAgICAgICB2YXIgZiA9IGEuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICByZXR1cm4gZi5hc3NvY2lhdGl2ZV8gPSBsLCBmO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGMucHJvdG90eXBlLl9DcmVhdGVfaXRlcmF0b3IgPSBmdW5jdGlvbihsLCBmLCB1KSB7XG4gICAgICAgIHJldHVybiBjLkl0ZXJhdG9yLmNyZWF0ZSh0aGlzLCBsLCBmLCB1KTtcbiAgICAgIH0sIGMuX1N3YXBfYXNzb2NpYXRpdmUgPSBmdW5jdGlvbihsLCBmKSB7XG4gICAgICAgIHZhciB1O1xuICAgICAgICB1ID0gcihbZi5hc3NvY2lhdGl2ZV8sIGwuYXNzb2NpYXRpdmVfXSwgMiksIGwuYXNzb2NpYXRpdmVfID0gdVswXSwgZi5hc3NvY2lhdGl2ZV8gPSB1WzFdO1xuICAgICAgfSwgYy5wcm90b3R5cGUuYXNzb2NpYXRpdmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXNzb2NpYXRpdmVfO1xuICAgICAgfSwgYztcbiAgICB9KG4uTGlzdENvbnRhaW5lcik7XG4gICAgdC5NYXBFbGVtZW50TGlzdCA9IG8sIGZ1bmN0aW9uKGEpIHtcbiAgICAgIHZhciBjID0gZnVuY3Rpb24oZikge1xuICAgICAgICBlKHUsIGYpO1xuICAgICAgICBmdW5jdGlvbiB1KGgsIGQsIHAsIHkpIHtcbiAgICAgICAgICB2YXIgZyA9IGYuY2FsbCh0aGlzLCBkLCBwLCB5KSB8fCB0aGlzO1xuICAgICAgICAgIHJldHVybiBnLmxpc3RfID0gaCwgZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdS5jcmVhdGUgPSBmdW5jdGlvbihoLCBkLCBwLCB5KSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyB1KGgsIGQsIHAsIHkpO1xuICAgICAgICB9LCB1LnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBsKHRoaXMpO1xuICAgICAgICB9LCB1LnByb3RvdHlwZS5zb3VyY2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5saXN0Xy5hc3NvY2lhdGl2ZSgpO1xuICAgICAgICB9LCBPYmplY3QuZGVmaW5lUHJvcGVydHkodS5wcm90b3R5cGUsIFwiZmlyc3RcIiwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZS5maXJzdDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh1LnByb3RvdHlwZSwgXCJzZWNvbmRcIiwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZS5zZWNvbmQ7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUuc2Vjb25kID0gaDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSksIHU7XG4gICAgICB9KGkuTGlzdEl0ZXJhdG9yKTtcbiAgICAgIGEuSXRlcmF0b3IgPSBjO1xuICAgICAgdmFyIGwgPSBmdW5jdGlvbihmKSB7XG4gICAgICAgIGUodSwgZik7XG4gICAgICAgIGZ1bmN0aW9uIHUoKSB7XG4gICAgICAgICAgcmV0dXJuIGYgIT09IG51bGwgJiYgZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHUucHJvdG90eXBlLl9DcmVhdGVfbmVpZ2hib3IgPSBmdW5jdGlvbihoKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyB1KGgpO1xuICAgICAgICB9LCBPYmplY3QuZGVmaW5lUHJvcGVydHkodS5wcm90b3R5cGUsIFwiZmlyc3RcIiwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iYXNlXy5maXJzdDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh1LnByb3RvdHlwZSwgXCJzZWNvbmRcIiwge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iYXNlXy5zZWNvbmQ7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZV8uc2Vjb25kID0gaDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSksIHU7XG4gICAgICB9KHMuUmV2ZXJzZUl0ZXJhdG9yKTtcbiAgICAgIGEuUmV2ZXJzZUl0ZXJhdG9yID0gbDtcbiAgICB9KG8gPSB0Lk1hcEVsZW1lbnRMaXN0IHx8ICh0Lk1hcEVsZW1lbnRMaXN0ID0ge30pKSwgdC5NYXBFbGVtZW50TGlzdCA9IG87XG4gIH0oa24pKSwga247XG59XG52YXIgWXQgPSB7fSwgVG87XG5mdW5jdGlvbiBvZCgpIHtcbiAgaWYgKFRvKVxuICAgIHJldHVybiBZdDtcbiAgVG8gPSAxO1xuICB2YXIgdCA9IFMgJiYgUy5fX2V4dGVuZHMgfHwgZnVuY3Rpb24oKSB7XG4gICAgdmFyIG8gPSBmdW5jdGlvbihhLCBjKSB7XG4gICAgICByZXR1cm4gbyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uKGwsIGYpIHtcbiAgICAgICAgbC5fX3Byb3RvX18gPSBmO1xuICAgICAgfSB8fCBmdW5jdGlvbihsLCBmKSB7XG4gICAgICAgIGZvciAodmFyIHUgaW4gZilcbiAgICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZiwgdSkgJiYgKGxbdV0gPSBmW3VdKTtcbiAgICAgIH0sIG8oYSwgYyk7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24oYSwgYykge1xuICAgICAgaWYgKHR5cGVvZiBjICE9IFwiZnVuY3Rpb25cIiAmJiBjICE9PSBudWxsKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhjKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICBvKGEsIGMpO1xuICAgICAgZnVuY3Rpb24gbCgpIHtcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IGE7XG4gICAgICB9XG4gICAgICBhLnByb3RvdHlwZSA9IGMgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGMpIDogKGwucHJvdG90eXBlID0gYy5wcm90b3R5cGUsIG5ldyBsKCkpO1xuICAgIH07XG4gIH0oKSwgZSA9IFMgJiYgUy5fX3JlYWQgfHwgZnVuY3Rpb24obywgYSkge1xuICAgIHZhciBjID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghYylcbiAgICAgIHJldHVybiBvO1xuICAgIHZhciBsID0gYy5jYWxsKG8pLCBmLCB1ID0gW10sIGg7XG4gICAgdHJ5IHtcbiAgICAgIGZvciAoOyAoYSA9PT0gdm9pZCAwIHx8IGEtLSA+IDApICYmICEoZiA9IGwubmV4dCgpKS5kb25lOyApXG4gICAgICAgIHUucHVzaChmLnZhbHVlKTtcbiAgICB9IGNhdGNoIChkKSB7XG4gICAgICBoID0geyBlcnJvcjogZCB9O1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBmICYmICFmLmRvbmUgJiYgKGMgPSBsLnJldHVybikgJiYgYy5jYWxsKGwpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGgpXG4gICAgICAgICAgdGhyb3cgaC5lcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHU7XG4gIH0sIHIgPSBTICYmIFMuX192YWx1ZXMgfHwgZnVuY3Rpb24obykge1xuICAgIHZhciBhID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBjID0gYSAmJiBvW2FdLCBsID0gMDtcbiAgICBpZiAoYylcbiAgICAgIHJldHVybiBjLmNhbGwobyk7XG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09IFwibnVtYmVyXCIpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gbyAmJiBsID49IG8ubGVuZ3RoICYmIChvID0gdm9pZCAwKSwgeyB2YWx1ZTogbyAmJiBvW2wrK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihhID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoWXQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgWXQuTWFwSGFzaEJ1Y2tldHMgPSB2b2lkIDA7XG4gIHZhciBuID0gUmEoKSwgaSA9IGZ1bmN0aW9uKG8pIHtcbiAgICB0KGEsIG8pO1xuICAgIGZ1bmN0aW9uIGEoYywgbCwgZikge1xuICAgICAgdmFyIHUgPSBvLmNhbGwodGhpcywgcywgbCkgfHwgdGhpcztcbiAgICAgIHJldHVybiB1LnNvdXJjZV8gPSBjLCB1LmtleV9lcV8gPSBmLCB1O1xuICAgIH1cbiAgICByZXR1cm4gYS5fU3dhcF9zb3VyY2UgPSBmdW5jdGlvbihjLCBsKSB7XG4gICAgICB2YXIgZjtcbiAgICAgIGYgPSBlKFtsLnNvdXJjZV8sIGMuc291cmNlX10sIDIpLCBjLnNvdXJjZV8gPSBmWzBdLCBsLnNvdXJjZV8gPSBmWzFdO1xuICAgIH0sIGEucHJvdG90eXBlLmtleV9lcSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMua2V5X2VxXztcbiAgICB9LCBhLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24oYykge1xuICAgICAgdmFyIGwsIGYsIHUgPSB0aGlzLmhhc2hfZnVuY3Rpb24oKShjKSAlIHRoaXMubGVuZ3RoKCksIGggPSB0aGlzLmF0KHUpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgZCA9IHIoaCksIHAgPSBkLm5leHQoKTsgIXAuZG9uZTsgcCA9IGQubmV4dCgpKSB7XG4gICAgICAgICAgdmFyIHkgPSBwLnZhbHVlO1xuICAgICAgICAgIGlmICh0aGlzLmtleV9lcV8oeS5maXJzdCwgYykpXG4gICAgICAgICAgICByZXR1cm4geTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZykge1xuICAgICAgICBsID0geyBlcnJvcjogZyB9O1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBwICYmICFwLmRvbmUgJiYgKGYgPSBkLnJldHVybikgJiYgZi5jYWxsKGQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChsKVxuICAgICAgICAgICAgdGhyb3cgbC5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuc291cmNlXy5lbmQoKTtcbiAgICB9LCBhO1xuICB9KG4uSGFzaEJ1Y2tldHMpO1xuICBZdC5NYXBIYXNoQnVja2V0cyA9IGk7XG4gIGZ1bmN0aW9uIHMobykge1xuICAgIHJldHVybiBvLmZpcnN0O1xuICB9XG4gIHJldHVybiBZdDtcbn1cbnZhciBKdCA9IHt9LCBQbztcbmZ1bmN0aW9uIHNkKCkge1xuICBpZiAoUG8pXG4gICAgcmV0dXJuIEp0O1xuICBQbyA9IDEsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShKdCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pLCBKdC5FbnRyeSA9IHZvaWQgMDtcbiAgdmFyIHQgPSB3aSgpLCBlID0gX2koKSwgciA9IGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIG4oaSwgcykge1xuICAgICAgdGhpcy5maXJzdCA9IGksIHRoaXMuc2Vjb25kID0gcztcbiAgICB9XG4gICAgcmV0dXJuIG4ucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiAoMCwgZS5lcXVhbF90bykodGhpcy5maXJzdCwgaS5maXJzdCk7XG4gICAgfSwgbi5wcm90b3R5cGUubGVzcyA9IGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiAoMCwgZS5sZXNzKSh0aGlzLmZpcnN0LCBpLmZpcnN0KTtcbiAgICB9LCBuLnByb3RvdHlwZS5oYXNoQ29kZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICgwLCB0Lmhhc2gpKHRoaXMuZmlyc3QpO1xuICAgIH0sIG47XG4gIH0oKTtcbiAgcmV0dXJuIEp0LkVudHJ5ID0gciwgSnQ7XG59XG52YXIgQm87XG5mdW5jdGlvbiBhZCgpIHtcbiAgcmV0dXJuIEJvIHx8IChCbyA9IDEsIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSA9IFMgJiYgUy5fX2V4dGVuZHMgfHwgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdSA9IGZ1bmN0aW9uKGgsIGQpIHtcbiAgICAgICAgcmV0dXJuIHUgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbihwLCB5KSB7XG4gICAgICAgICAgcC5fX3Byb3RvX18gPSB5O1xuICAgICAgICB9IHx8IGZ1bmN0aW9uKHAsIHkpIHtcbiAgICAgICAgICBmb3IgKHZhciBnIGluIHkpXG4gICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeSwgZykgJiYgKHBbZ10gPSB5W2ddKTtcbiAgICAgICAgfSwgdShoLCBkKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gZnVuY3Rpb24oaCwgZCkge1xuICAgICAgICBpZiAodHlwZW9mIGQgIT0gXCJmdW5jdGlvblwiICYmIGQgIT09IG51bGwpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoZCkgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICB1KGgsIGQpO1xuICAgICAgICBmdW5jdGlvbiBwKCkge1xuICAgICAgICAgIHRoaXMuY29uc3RydWN0b3IgPSBoO1xuICAgICAgICB9XG4gICAgICAgIGgucHJvdG90eXBlID0gZCA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoZCkgOiAocC5wcm90b3R5cGUgPSBkLnByb3RvdHlwZSwgbmV3IHAoKSk7XG4gICAgICB9O1xuICAgIH0oKSwgciA9IFMgJiYgUy5fX3JlYWQgfHwgZnVuY3Rpb24odSwgaCkge1xuICAgICAgdmFyIGQgPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiB1W1N5bWJvbC5pdGVyYXRvcl07XG4gICAgICBpZiAoIWQpXG4gICAgICAgIHJldHVybiB1O1xuICAgICAgdmFyIHAgPSBkLmNhbGwodSksIHksIGcgPSBbXSwgdjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoOyAoaCA9PT0gdm9pZCAwIHx8IGgtLSA+IDApICYmICEoeSA9IHAubmV4dCgpKS5kb25lOyApXG4gICAgICAgICAgZy5wdXNoKHkudmFsdWUpO1xuICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICB2ID0geyBlcnJvcjogXyB9O1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB5ICYmICF5LmRvbmUgJiYgKGQgPSBwLnJldHVybikgJiYgZC5jYWxsKHApO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmICh2KVxuICAgICAgICAgICAgdGhyb3cgdi5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGc7XG4gICAgfSwgbiA9IFMgJiYgUy5fX3NwcmVhZEFycmF5IHx8IGZ1bmN0aW9uKHUsIGgsIGQpIHtcbiAgICAgIGlmIChkIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpXG4gICAgICAgIGZvciAodmFyIHAgPSAwLCB5ID0gaC5sZW5ndGgsIGc7IHAgPCB5OyBwKyspXG4gICAgICAgICAgKGcgfHwgIShwIGluIGgpKSAmJiAoZyB8fCAoZyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGgsIDAsIHApKSwgZ1twXSA9IGhbcF0pO1xuICAgICAgcmV0dXJuIHUuY29uY2F0KGcgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoaCkpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgdC5IYXNoTWFwID0gdm9pZCAwO1xuICAgIHZhciBpID0gbmQoKSwgcyA9IEFhKCksIG8gPSBpZCgpLCBhID0gb2QoKSwgYyA9IHNkKCksIGwgPSBUYSgpLCBmID0gZnVuY3Rpb24odSkge1xuICAgICAgZShoLCB1KTtcbiAgICAgIGZ1bmN0aW9uIGgoKSB7XG4gICAgICAgIGZvciAodmFyIGQgPSBbXSwgcCA9IDA7IHAgPCBhcmd1bWVudHMubGVuZ3RoOyBwKyspXG4gICAgICAgICAgZFtwXSA9IGFyZ3VtZW50c1twXTtcbiAgICAgICAgdmFyIHkgPSB1LmNhbGwodGhpcywgZnVuY3Rpb24oZykge1xuICAgICAgICAgIHJldHVybiBuZXcgby5NYXBFbGVtZW50TGlzdChnKTtcbiAgICAgICAgfSkgfHwgdGhpcztcbiAgICAgICAgcmV0dXJuIHMuSUhhc2hDb250YWluZXIuY29uc3RydWN0LmFwcGx5KHMuSUhhc2hDb250YWluZXIsIG4oW1xuICAgICAgICAgIHksXG4gICAgICAgICAgaCxcbiAgICAgICAgICBmdW5jdGlvbihnLCB2KSB7XG4gICAgICAgICAgICB5LmJ1Y2tldHNfID0gbmV3IGEuTWFwSGFzaEJ1Y2tldHMoeSwgZywgdik7XG4gICAgICAgICAgfVxuICAgICAgICBdLCByKGQpLCAhMSkpLCB5O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGgucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuYnVja2V0c18uY2xlYXIoKSwgdS5wcm90b3R5cGUuY2xlYXIuY2FsbCh0aGlzKTtcbiAgICAgIH0sIGgucHJvdG90eXBlLnN3YXAgPSBmdW5jdGlvbihkKSB7XG4gICAgICAgIHZhciBwLCB5O1xuICAgICAgICBwID0gcihbZC5kYXRhXywgdGhpcy5kYXRhX10sIDIpLCB0aGlzLmRhdGFfID0gcFswXSwgZC5kYXRhXyA9IHBbMV0sIG8uTWFwRWxlbWVudExpc3QuX1N3YXBfYXNzb2NpYXRpdmUodGhpcy5kYXRhXywgZC5kYXRhXyksIGEuTWFwSGFzaEJ1Y2tldHMuX1N3YXBfc291cmNlKHRoaXMuYnVja2V0c18sIGQuYnVja2V0c18pLCB5ID0gcihbZC5idWNrZXRzXywgdGhpcy5idWNrZXRzX10sIDIpLCB0aGlzLmJ1Y2tldHNfID0geVswXSwgZC5idWNrZXRzXyA9IHlbMV07XG4gICAgICB9LCBoLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWNrZXRzXy5maW5kKGQpO1xuICAgICAgfSwgaC5wcm90b3R5cGUuYmVnaW4gPSBmdW5jdGlvbihkKSB7XG4gICAgICAgIHJldHVybiBkID09PSB2b2lkIDAgJiYgKGQgPSBudWxsKSwgZCA9PT0gbnVsbCA/IHUucHJvdG90eXBlLmJlZ2luLmNhbGwodGhpcykgOiB0aGlzLmJ1Y2tldHNfLmF0KGQpWzBdO1xuICAgICAgfSwgaC5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oZCkge1xuICAgICAgICBpZiAoZCA9PT0gdm9pZCAwICYmIChkID0gbnVsbCksIGQgPT09IG51bGwpXG4gICAgICAgICAgcmV0dXJuIHUucHJvdG90eXBlLmVuZC5jYWxsKHRoaXMpO1xuICAgICAgICB2YXIgcCA9IHRoaXMuYnVja2V0c18uYXQoZCk7XG4gICAgICAgIHJldHVybiBwW3AubGVuZ3RoIC0gMV0ubmV4dCgpO1xuICAgICAgfSwgaC5wcm90b3R5cGUucmJlZ2luID0gZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4gZCA9PT0gdm9pZCAwICYmIChkID0gbnVsbCksIHRoaXMuZW5kKGQpLnJldmVyc2UoKTtcbiAgICAgIH0sIGgucHJvdG90eXBlLnJlbmQgPSBmdW5jdGlvbihkKSB7XG4gICAgICAgIHJldHVybiBkID09PSB2b2lkIDAgJiYgKGQgPSBudWxsKSwgdGhpcy5iZWdpbihkKS5yZXZlcnNlKCk7XG4gICAgICB9LCBoLnByb3RvdHlwZS5idWNrZXRfY291bnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVja2V0c18ubGVuZ3RoKCk7XG4gICAgICB9LCBoLnByb3RvdHlwZS5idWNrZXRfc2l6ZSA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVja2V0c18uYXQoZCkubGVuZ3RoO1xuICAgICAgfSwgaC5wcm90b3R5cGUubG9hZF9mYWN0b3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVja2V0c18ubG9hZF9mYWN0b3IoKTtcbiAgICAgIH0sIGgucHJvdG90eXBlLmhhc2hfZnVuY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVja2V0c18uaGFzaF9mdW5jdGlvbigpO1xuICAgICAgfSwgaC5wcm90b3R5cGUua2V5X2VxID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1Y2tldHNfLmtleV9lcSgpO1xuICAgICAgfSwgaC5wcm90b3R5cGUuYnVja2V0ID0gZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNoX2Z1bmN0aW9uKCkoZCkgJSB0aGlzLmJ1Y2tldHNfLmxlbmd0aCgpO1xuICAgICAgfSwgaC5wcm90b3R5cGUubWF4X2xvYWRfZmFjdG9yID0gZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4gZCA9PT0gdm9pZCAwICYmIChkID0gbnVsbCksIHRoaXMuYnVja2V0c18ubWF4X2xvYWRfZmFjdG9yKGQpO1xuICAgICAgfSwgaC5wcm90b3R5cGUucmVzZXJ2ZSA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgdGhpcy5idWNrZXRzXy5yZXNlcnZlKGQpO1xuICAgICAgfSwgaC5wcm90b3R5cGUucmVoYXNoID0gZnVuY3Rpb24oZCkge1xuICAgICAgICB0aGlzLmJ1Y2tldHNfLnJlaGFzaChkKTtcbiAgICAgIH0sIGgucHJvdG90eXBlLmVtcGxhY2UgPSBmdW5jdGlvbihkLCBwKSB7XG4gICAgICAgIHZhciB5ID0gdGhpcy5maW5kKGQpO1xuICAgICAgICByZXR1cm4geS5lcXVhbHModGhpcy5lbmQoKSkgPT09ICExID8gbmV3IGwuUGFpcih5LCAhMSkgOiAodGhpcy5kYXRhXy5wdXNoKG5ldyBjLkVudHJ5KGQsIHApKSwgeSA9IHkucHJldigpLCB0aGlzLl9IYW5kbGVfaW5zZXJ0KHksIHkubmV4dCgpKSwgbmV3IGwuUGFpcih5LCAhMCkpO1xuICAgICAgfSwgaC5wcm90b3R5cGUuZW1wbGFjZV9oaW50ID0gZnVuY3Rpb24oZCwgcCwgeSkge1xuICAgICAgICB2YXIgZyA9IHRoaXMuZmluZChwKTtcbiAgICAgICAgcmV0dXJuIGcuZXF1YWxzKHRoaXMuZW5kKCkpID09PSAhMCAmJiAoZyA9IHRoaXMuZGF0YV8uaW5zZXJ0KGQsIG5ldyBjLkVudHJ5KHAsIHkpKSwgdGhpcy5fSGFuZGxlX2luc2VydChnLCBnLm5leHQoKSkpLCBnO1xuICAgICAgfSwgaC5wcm90b3R5cGUuX0hhbmRsZV9pbnNlcnQgPSBmdW5jdGlvbihkLCBwKSB7XG4gICAgICAgIGZvciAoOyAhZC5lcXVhbHMocCk7IGQgPSBkLm5leHQoKSlcbiAgICAgICAgICB0aGlzLmJ1Y2tldHNfLmluc2VydChkKTtcbiAgICAgIH0sIGgucHJvdG90eXBlLl9IYW5kbGVfZXJhc2UgPSBmdW5jdGlvbihkLCBwKSB7XG4gICAgICAgIGZvciAoOyAhZC5lcXVhbHMocCk7IGQgPSBkLm5leHQoKSlcbiAgICAgICAgICB0aGlzLmJ1Y2tldHNfLmVyYXNlKGQpO1xuICAgICAgfSwgaDtcbiAgICB9KGkuVW5pcXVlTWFwKTtcbiAgICB0Lkhhc2hNYXAgPSBmLCBmdW5jdGlvbih1KSB7XG4gICAgICB1Lkl0ZXJhdG9yID0gby5NYXBFbGVtZW50TGlzdC5JdGVyYXRvciwgdS5SZXZlcnNlSXRlcmF0b3IgPSBvLk1hcEVsZW1lbnRMaXN0LlJldmVyc2VJdGVyYXRvcjtcbiAgICB9KGYgPSB0Lkhhc2hNYXAgfHwgKHQuSGFzaE1hcCA9IHt9KSksIHQuSGFzaE1hcCA9IGY7XG4gIH0oRW4pKSwgRW47XG59XG52YXIgTG87XG5mdW5jdGlvbiBjZCgpIHtcbiAgaWYgKExvKVxuICAgIHJldHVybiBfcjtcbiAgTG8gPSAxO1xuICB2YXIgdCA9IFMgJiYgUy5fX3ZhbHVlcyB8fCBmdW5jdGlvbihpKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBpW1N5bWJvbC5pdGVyYXRvcl0sIG8gPSAwO1xuICAgIHJldHVybiBzID8gcy5jYWxsKGkpIDoge1xuICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBpICYmIG8gPj0gaS5sZW5ndGggJiYgKGkgPSB2b2lkIDApLCB7IHZhbHVlOiBpICYmIGlbbysrXSwgZG9uZTogIWkgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3IsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbiAgdmFyIGUgPSB0ZCgpLCByID0gYWQoKSwgbiA9IGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIGkoKSB7XG4gICAgICB0aGlzLmxpc3RlbmVyc18gPSBuZXcgci5IYXNoTWFwKCksIHRoaXMuY3JlYXRlZF9hdF8gPSBuZXcgRGF0ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gaS5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgIHZhciBvLCBhLCBjID0gdGhpcy5saXN0ZW5lcnNfLmZpbmQocy50eXBlKTtcbiAgICAgIGlmICghYy5lcXVhbHModGhpcy5saXN0ZW5lcnNfLmVuZCgpKSkge1xuICAgICAgICBzLnRhcmdldCA9IHRoaXMsIHMudGltZVN0YW1wID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSB0aGlzLmNyZWF0ZWRfYXRfLmdldFRpbWUoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKHZhciBsID0gdChjLnNlY29uZCksIGYgPSBsLm5leHQoKTsgIWYuZG9uZTsgZiA9IGwubmV4dCgpKSB7XG4gICAgICAgICAgICB2YXIgdSA9IGYudmFsdWU7XG4gICAgICAgICAgICB1KHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoaCkge1xuICAgICAgICAgIG8gPSB7IGVycm9yOiBoIH07XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGYgJiYgIWYuZG9uZSAmJiAoYSA9IGwucmV0dXJuKSAmJiBhLmNhbGwobCk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChvKVxuICAgICAgICAgICAgICB0aHJvdyBvLmVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIGkucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihzLCBvKSB7XG4gICAgICB2YXIgYSA9IHRoaXMubGlzdGVuZXJzXy5maW5kKHMpO1xuICAgICAgYS5lcXVhbHModGhpcy5saXN0ZW5lcnNfLmVuZCgpKSAmJiAoYSA9IHRoaXMubGlzdGVuZXJzXy5lbXBsYWNlKHMsIG5ldyBlLkhhc2hTZXQoKSkuZmlyc3QpLCBhLnNlY29uZC5pbnNlcnQobyk7XG4gICAgfSwgaS5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKHMsIG8pIHtcbiAgICAgIHZhciBhID0gdGhpcy5saXN0ZW5lcnNfLmZpbmQocyk7XG4gICAgICBhLmVxdWFscyh0aGlzLmxpc3RlbmVyc18uZW5kKCkpIHx8IChhLnNlY29uZC5lcmFzZShvKSwgYS5zZWNvbmQuZW1wdHkoKSAmJiB0aGlzLmxpc3RlbmVyc18uZXJhc2UoYSkpO1xuICAgIH0sIGk7XG4gIH0oKTtcbiAgcmV0dXJuIF9yLkV2ZW50VGFyZ2V0ID0gbiwgX3I7XG59XG52YXIgbXIgPSB7fSwgJG87XG5mdW5jdGlvbiBWcigpIHtcbiAgaWYgKCRvKVxuICAgIHJldHVybiBtcjtcbiAgJG8gPSAxLCBPYmplY3QuZGVmaW5lUHJvcGVydHkobXIsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbiAgdmFyIHQgPSBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBlKHIsIG4pIHtcbiAgICAgIHRoaXMudHlwZSA9IHIsIG4gJiYgT2JqZWN0LmFzc2lnbih0aGlzLCBuKTtcbiAgICB9XG4gICAgcmV0dXJuIGU7XG4gIH0oKTtcbiAgcmV0dXJuIG1yLkV2ZW50ID0gdCwgbXI7XG59XG52YXIgeHIgPSB7fSwgcW87XG5mdW5jdGlvbiB1ZCgpIHtcbiAgaWYgKHFvKVxuICAgIHJldHVybiB4cjtcbiAgcW8gPSAxO1xuICB2YXIgdCA9IFMgJiYgUy5fX2V4dGVuZHMgfHwgZnVuY3Rpb24oKSB7XG4gICAgdmFyIG4gPSBmdW5jdGlvbihpLCBzKSB7XG4gICAgICByZXR1cm4gbiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uKG8sIGEpIHtcbiAgICAgICAgby5fX3Byb3RvX18gPSBhO1xuICAgICAgfSB8fCBmdW5jdGlvbihvLCBhKSB7XG4gICAgICAgIGZvciAodmFyIGMgaW4gYSlcbiAgICAgICAgICBhLmhhc093blByb3BlcnR5KGMpICYmIChvW2NdID0gYVtjXSk7XG4gICAgICB9LCBuKGksIHMpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGksIHMpIHtcbiAgICAgIG4oaSwgcyk7XG4gICAgICBmdW5jdGlvbiBvKCkge1xuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yID0gaTtcbiAgICAgIH1cbiAgICAgIGkucHJvdG90eXBlID0gcyA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUocykgOiAoby5wcm90b3R5cGUgPSBzLnByb3RvdHlwZSwgbmV3IG8oKSk7XG4gICAgfTtcbiAgfSgpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoeHIsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbiAgdmFyIGUgPSBWcigpLCByID0gZnVuY3Rpb24obikge1xuICAgIHQoaSwgbik7XG4gICAgZnVuY3Rpb24gaShzLCBvKSB7XG4gICAgICByZXR1cm4gbi5jYWxsKHRoaXMsIHMsIG8pIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBpO1xuICB9KGUuRXZlbnQpO1xuICByZXR1cm4geHIuQ2xvc2VFdmVudCA9IHIsIHhyO1xufVxudmFyIEVyID0ge30sIE5vO1xuZnVuY3Rpb24gbGQoKSB7XG4gIGlmIChObylcbiAgICByZXR1cm4gRXI7XG4gIE5vID0gMTtcbiAgdmFyIHQgPSBTICYmIFMuX19leHRlbmRzIHx8IGZ1bmN0aW9uKCkge1xuICAgIHZhciBuID0gZnVuY3Rpb24oaSwgcykge1xuICAgICAgcmV0dXJuIG4gPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbihvLCBhKSB7XG4gICAgICAgIG8uX19wcm90b19fID0gYTtcbiAgICAgIH0gfHwgZnVuY3Rpb24obywgYSkge1xuICAgICAgICBmb3IgKHZhciBjIGluIGEpXG4gICAgICAgICAgYS5oYXNPd25Qcm9wZXJ0eShjKSAmJiAob1tjXSA9IGFbY10pO1xuICAgICAgfSwgbihpLCBzKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbihpLCBzKSB7XG4gICAgICBuKGksIHMpO1xuICAgICAgZnVuY3Rpb24gbygpIHtcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IGk7XG4gICAgICB9XG4gICAgICBpLnByb3RvdHlwZSA9IHMgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKHMpIDogKG8ucHJvdG90eXBlID0gcy5wcm90b3R5cGUsIG5ldyBvKCkpO1xuICAgIH07XG4gIH0oKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEVyLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG4gIHZhciBlID0gVnIoKSwgciA9IGZ1bmN0aW9uKG4pIHtcbiAgICB0KGksIG4pO1xuICAgIGZ1bmN0aW9uIGkocywgbykge1xuICAgICAgcmV0dXJuIG4uY2FsbCh0aGlzLCBzLCBvKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gaTtcbiAgfShlLkV2ZW50KTtcbiAgcmV0dXJuIEVyLk1lc3NhZ2VFdmVudCA9IHIsIEVyO1xufVxudmFyIGtyID0ge30sIFVvO1xuZnVuY3Rpb24gZmQoKSB7XG4gIGlmIChVbylcbiAgICByZXR1cm4ga3I7XG4gIFVvID0gMTtcbiAgdmFyIHQgPSBTICYmIFMuX19leHRlbmRzIHx8IGZ1bmN0aW9uKCkge1xuICAgIHZhciBuID0gZnVuY3Rpb24oaSwgcykge1xuICAgICAgcmV0dXJuIG4gPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbihvLCBhKSB7XG4gICAgICAgIG8uX19wcm90b19fID0gYTtcbiAgICAgIH0gfHwgZnVuY3Rpb24obywgYSkge1xuICAgICAgICBmb3IgKHZhciBjIGluIGEpXG4gICAgICAgICAgYS5oYXNPd25Qcm9wZXJ0eShjKSAmJiAob1tjXSA9IGFbY10pO1xuICAgICAgfSwgbihpLCBzKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbihpLCBzKSB7XG4gICAgICBuKGksIHMpO1xuICAgICAgZnVuY3Rpb24gbygpIHtcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IGk7XG4gICAgICB9XG4gICAgICBpLnByb3RvdHlwZSA9IHMgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKHMpIDogKG8ucHJvdG90eXBlID0gcy5wcm90b3R5cGUsIG5ldyBvKCkpO1xuICAgIH07XG4gIH0oKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGtyLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG4gIHZhciBlID0gVnIoKSwgciA9IGZ1bmN0aW9uKG4pIHtcbiAgICB0KGksIG4pO1xuICAgIGZ1bmN0aW9uIGkocywgbykge1xuICAgICAgcmV0dXJuIG4uY2FsbCh0aGlzLCBzLCBvKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gaTtcbiAgfShlLkV2ZW50KTtcbiAgcmV0dXJuIGtyLkVycm9yRXZlbnQgPSByLCBrcjtcbn1cbnZhciBqbztcbmZ1bmN0aW9uIGhkKCkge1xuICByZXR1cm4gam8gfHwgKGpvID0gMSwgZnVuY3Rpb24odCkge1xuICAgIHZhciBlID0gUyAmJiBTLl9fZXh0ZW5kcyB8fCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB1ID0gZnVuY3Rpb24oaCwgZCkge1xuICAgICAgICByZXR1cm4gdSA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uKHAsIHkpIHtcbiAgICAgICAgICBwLl9fcHJvdG9fXyA9IHk7XG4gICAgICAgIH0gfHwgZnVuY3Rpb24ocCwgeSkge1xuICAgICAgICAgIGZvciAodmFyIGcgaW4geSlcbiAgICAgICAgICAgIHkuaGFzT3duUHJvcGVydHkoZykgJiYgKHBbZ10gPSB5W2ddKTtcbiAgICAgICAgfSwgdShoLCBkKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gZnVuY3Rpb24oaCwgZCkge1xuICAgICAgICB1KGgsIGQpO1xuICAgICAgICBmdW5jdGlvbiBwKCkge1xuICAgICAgICAgIHRoaXMuY29uc3RydWN0b3IgPSBoO1xuICAgICAgICB9XG4gICAgICAgIGgucHJvdG90eXBlID0gZCA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoZCkgOiAocC5wcm90b3R5cGUgPSBkLnByb3RvdHlwZSwgbmV3IHAoKSk7XG4gICAgICB9O1xuICAgIH0oKSwgciA9IFMgJiYgUy5fX2Fzc2lnbiB8fCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiByID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih1KSB7XG4gICAgICAgIGZvciAodmFyIGgsIGQgPSAxLCBwID0gYXJndW1lbnRzLmxlbmd0aDsgZCA8IHA7IGQrKykge1xuICAgICAgICAgIGggPSBhcmd1bWVudHNbZF07XG4gICAgICAgICAgZm9yICh2YXIgeSBpbiBoKVxuICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGgsIHkpICYmICh1W3ldID0gaFt5XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHU7XG4gICAgICB9LCByLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuICAgIHZhciBuID0gemgoKSwgaSA9IGNkKCksIHMgPSBWcigpLCBvID0gdWQoKSwgYSA9IGxkKCksIGMgPSBmZCgpLCBsID0gZnVuY3Rpb24odSkge1xuICAgICAgZShoLCB1KTtcbiAgICAgIGZ1bmN0aW9uIGgoZCwgcCkge1xuICAgICAgICB2YXIgeSA9IHUuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICByZXR1cm4geS5vbl8gPSB7fSwgeS5zdGF0ZV8gPSBoLkNPTk5FQ1RJTkcsIHkuY2xpZW50XyA9IG5ldyBuLmNsaWVudCgpLCB5LmNsaWVudF8ub24oXCJjb25uZWN0XCIsIHkuX0hhbmRsZV9jb25uZWN0LmJpbmQoeSkpLCB5LmNsaWVudF8ub24oXCJjb25uZWN0RmFpbGVkXCIsIHkuX0hhbmRsZV9lcnJvci5iaW5kKHkpKSwgdHlwZW9mIHAgPT0gXCJzdHJpbmdcIiAmJiAocCA9IFtwXSksIHkuY2xpZW50Xy5jb25uZWN0KGQsIHApLCB5O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGgucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oZCwgcCkge1xuICAgICAgICB0aGlzLnN0YXRlXyA9IGguQ0xPU0lORywgZCA9PT0gdm9pZCAwID8gdGhpcy5jb25uZWN0aW9uXy5zZW5kQ2xvc2VGcmFtZSgpIDogdGhpcy5jb25uZWN0aW9uXy5zZW5kQ2xvc2VGcmFtZShkLCBwLCAhMCk7XG4gICAgICB9LCBoLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24oZCkge1xuICAgICAgICBpZiAodHlwZW9mIGQudmFsdWVPZigpID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgdGhpcy5jb25uZWN0aW9uXy5zZW5kVVRGKGQpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgcCA9IHZvaWQgMDtcbiAgICAgICAgICBkIGluc3RhbmNlb2YgQnVmZmVyID8gcCA9IGQgOiBkIGluc3RhbmNlb2YgQmxvYiA/IHAgPSBuZXcgQnVmZmVyKGQsIFwiYmxvYlwiKSA6IGQuYnVmZmVyID8gcCA9IG5ldyBCdWZmZXIoZC5idWZmZXIpIDogcCA9IG5ldyBCdWZmZXIoZCksIHRoaXMuY29ubmVjdGlvbl8uc2VuZEJ5dGVzKHApO1xuICAgICAgICB9XG4gICAgICB9LCBPYmplY3QuZGVmaW5lUHJvcGVydHkoaC5wcm90b3R5cGUsIFwidXJsXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jbGllbnRfLnVybC5ocmVmO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShoLnByb3RvdHlwZSwgXCJwcm90b2NvbFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50Xy5wcm90b2NvbHMgPyB0aGlzLmNsaWVudF8ucHJvdG9jb2xzWzBdIDogXCJcIjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoaC5wcm90b3R5cGUsIFwiZXh0ZW5zaW9uc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbl8gJiYgdGhpcy5jb25uZWN0aW9uXy5leHRlbnNpb25zID8gdGhpcy5jb25uZWN0aW9uXy5leHRlbnNpb25zWzBdLm5hbWUgOiBcIlwiO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShoLnByb3RvdHlwZSwgXCJyZWFkeVN0YXRlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZV87XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGgucHJvdG90eXBlLCBcImJ1ZmZlcmVkQW1vdW50XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uXy5ieXRlc1dhaXRpbmdUb0ZsdXNoO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShoLnByb3RvdHlwZSwgXCJiaW5hcnlUeXBlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gXCJhcnJheWJ1ZmZlclwiO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShoLnByb3RvdHlwZSwgXCJvbm9wZW5cIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLm9uXy5vcGVuO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICB0aGlzLl9TZXRfb24oXCJvcGVuXCIsIGQpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShoLnByb3RvdHlwZSwgXCJvbmNsb3NlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5vbl8uY2xvc2U7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24oZCkge1xuICAgICAgICAgIHRoaXMuX1NldF9vbihcImNsb3NlXCIsIGQpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShoLnByb3RvdHlwZSwgXCJvbm1lc3NhZ2VcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLm9uXy5tZXNzYWdlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICB0aGlzLl9TZXRfb24oXCJtZXNzYWdlXCIsIGQpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShoLnByb3RvdHlwZSwgXCJvbmVycm9yXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5vbl8uZXJyb3I7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24oZCkge1xuICAgICAgICAgIHRoaXMuX1NldF9vbihcImVycm9yXCIsIGQpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgfSksIGgucHJvdG90eXBlLl9TZXRfb24gPSBmdW5jdGlvbihkLCBwKSB7XG4gICAgICAgIHRoaXMub25fW2RdICYmIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihkLCB0aGlzLm9uX1tkXSksIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihkLCBwKSwgdGhpcy5vbl9bZF0gPSBwO1xuICAgICAgfSwgaC5wcm90b3R5cGUuX0hhbmRsZV9jb25uZWN0ID0gZnVuY3Rpb24oZCkge1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25fID0gZCwgdGhpcy5zdGF0ZV8gPSBoLk9QRU4sIHRoaXMuY29ubmVjdGlvbl8ub24oXCJtZXNzYWdlXCIsIHRoaXMuX0hhbmRsZV9tZXNzYWdlLmJpbmQodGhpcykpLCB0aGlzLmNvbm5lY3Rpb25fLm9uKFwiZXJyb3JcIiwgdGhpcy5fSGFuZGxlX2Vycm9yLmJpbmQodGhpcykpLCB0aGlzLmNvbm5lY3Rpb25fLm9uKFwiY2xvc2VcIiwgdGhpcy5fSGFuZGxlX2Nsb3NlLmJpbmQodGhpcykpO1xuICAgICAgICB2YXIgcCA9IG5ldyBzLkV2ZW50KFwib3BlblwiLCBmKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHApO1xuICAgICAgfSwgaC5wcm90b3R5cGUuX0hhbmRsZV9jbG9zZSA9IGZ1bmN0aW9uKGQsIHApIHtcbiAgICAgICAgdmFyIHkgPSBuZXcgby5DbG9zZUV2ZW50KFwiY2xvc2VcIiwgcih7fSwgZiwgeyBjb2RlOiBkLCByZWFzb246IHAgfSkpO1xuICAgICAgICB0aGlzLnN0YXRlXyA9IGguQ0xPU0VELCB0aGlzLmRpc3BhdGNoRXZlbnQoeSk7XG4gICAgICB9LCBoLnByb3RvdHlwZS5fSGFuZGxlX21lc3NhZ2UgPSBmdW5jdGlvbihkKSB7XG4gICAgICAgIHZhciBwID0gbmV3IGEuTWVzc2FnZUV2ZW50KFwibWVzc2FnZVwiLCByKHt9LCBmLCB7IGRhdGE6IGQuYmluYXJ5RGF0YSA/IGQuYmluYXJ5RGF0YSA6IGQudXRmOERhdGEgfSkpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQocCk7XG4gICAgICB9LCBoLnByb3RvdHlwZS5fSGFuZGxlX2Vycm9yID0gZnVuY3Rpb24oZCkge1xuICAgICAgICB2YXIgcCA9IG5ldyBjLkVycm9yRXZlbnQoXCJlcnJvclwiLCByKHt9LCBmLCB7IGVycm9yOiBkLCBtZXNzYWdlOiBkLm1lc3NhZ2UgfSkpO1xuICAgICAgICB0aGlzLnN0YXRlXyA9PT0gaC5DT05ORUNUSU5HICYmICh0aGlzLnN0YXRlXyA9IGguQ0xPU0VEKSwgdGhpcy5kaXNwYXRjaEV2ZW50KHApO1xuICAgICAgfSwgaDtcbiAgICB9KGkuRXZlbnRUYXJnZXQpO1xuICAgIHQuV2ViU29ja2V0ID0gbCwgZnVuY3Rpb24odSkge1xuICAgICAgdS5DT05ORUNUSU5HID0gMCwgdS5PUEVOID0gMSwgdS5DTE9TSU5HID0gMiwgdS5DTE9TRUQgPSAzO1xuICAgIH0obCA9IHQuV2ViU29ja2V0IHx8ICh0LldlYlNvY2tldCA9IHt9KSksIHQuV2ViU29ja2V0ID0gbDtcbiAgICB2YXIgZiA9IHtcbiAgICAgIGJ1YmJsZXM6ICExLFxuICAgICAgY2FuY2VsYWJsZTogITFcbiAgICB9O1xuICB9KHBuKSksIHBuO1xufVxudmFyIGRkID0gY3I7XG5kZC5pc19ub2RlKCkgJiYgKFMuV2ViU29ja2V0ID0gaGQoKS5XZWJTb2NrZXQpO1xuQmlnSW50KDFlMyksIEJpZ0ludCgxZTYpLCBCaWdJbnQoMWU5KSwgQmlnSW50KDFlMTIpO1xuQmlnSW50KFwiMjEwMDAwMDAwMDAwMDAwMDAwMFwiKTtcbkJpZ0ludCgxZTExKTtcbmNvbnN0IEhvID0ge1xuICBwYXltZW50X2hhc2g6IDEsXG4gIHBheW1lbnRfc2VjcmV0OiAxNixcbiAgZGVzY3JpcHRpb246IDEzLFxuICBwYXllZTogMTksXG4gIGRlc2NyaXB0aW9uX2hhc2g6IDIzLFxuICBleHBpcnk6IDYsXG4gIG1pbl9maW5hbF9jbHR2X2V4cGlyeTogMjQsXG4gIGZhbGxiYWNrX2FkZHJlc3M6IDksXG4gIHJvdXRlX2hpbnQ6IDMsXG4gIGZlYXR1cmVfYml0czogNSxcbiAgbWV0YWRhdGE6IDI3XG59O1xuZm9yIChsZXQgdCA9IDAsIGUgPSBPYmplY3Qua2V5cyhIbyk7IHQgPCBlLmxlbmd0aDsgdCsrKVxuICBlW3RdLCBIb1tlW3RdXS50b1N0cmluZygpO1xuZnVuY3Rpb24gcGQodCwgZSkge1xuICByZXR1cm4gdC5jcmVhdGVkX2F0ID4gZS5jcmVhdGVkX2F0ID8gdCA6IGU7XG59XG52YXIgeWQgPSBbXG4gIFwid3NzOi8vbm9zLmxvbFwiLFxuICBcIndzczovL3JlbGF5Lm5vc3RyLmJhbmRcIixcbiAgXCJ3c3M6Ly9yZWxheS5mN3ouaW9cIixcbiAgXCJ3c3M6Ly9yZWxheS5kYW11cy5pb1wiLFxuICBcIndzczovL25vc3RyLm1vbVwiLFxuICBcIndzczovL25vLnN0ci5jclwiXG5dLCBnZCA9IGNsYXNzIGV4dGVuZHMgZHQge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgc3VwZXIoKTtcbiAgICBJKHRoaXMsIFwibmRrXCIpO1xuICAgIEkodGhpcywgXCJ6YXBwZWRFdmVudFwiKTtcbiAgICBJKHRoaXMsIFwiemFwcGVkVXNlclwiKTtcbiAgICB0aGlzLm5kayA9IGUubmRrLCB0aGlzLnphcHBlZEV2ZW50ID0gZS56YXBwZWRFdmVudCwgdGhpcy56YXBwZWRVc2VyID0gZS56YXBwZWRVc2VyIHx8IHRoaXMubmRrLmdldFVzZXIoeyBoZXhwdWJrZXk6IHRoaXMuemFwcGVkRXZlbnQucHVia2V5IH0pO1xuICB9XG4gIGFzeW5jIGdldFphcEVuZHBvaW50KCkge1xuICAgIGxldCBlLCByLCBuLCBpO1xuICAgIGlmICh0aGlzLnphcHBlZEV2ZW50KSB7XG4gICAgICBjb25zdCBhID0gKGF3YWl0IHRoaXMuemFwcGVkRXZlbnQuZ2V0TWF0Y2hpbmdUYWdzKFwiemFwXCIpKVswXTtcbiAgICAgIGlmIChhKVxuICAgICAgICBzd2l0Y2ggKGFbMl0pIHtcbiAgICAgICAgICBjYXNlIFwibHVkMDZcIjpcbiAgICAgICAgICAgIGUgPSBhWzFdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImx1ZDE2XCI6XG4gICAgICAgICAgICByID0gYVsxXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gemFwIHRhZyAke2F9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuemFwcGVkVXNlciAmJiAhZSAmJiAhciAmJiAodGhpcy56YXBwZWRVc2VyLnByb2ZpbGUgfHwgYXdhaXQgdGhpcy56YXBwZWRVc2VyLmZldGNoUHJvZmlsZSgpLCBlID0gKHRoaXMuemFwcGVkVXNlci5wcm9maWxlIHx8IHt9KS5sdWQwNiwgciA9ICh0aGlzLnphcHBlZFVzZXIucHJvZmlsZSB8fCB7fSkubHVkMTYpLCByKSB7XG4gICAgICBjb25zdCBbYSwgY10gPSByLnNwbGl0KFwiQFwiKTtcbiAgICAgIG4gPSBgaHR0cHM6Ly8ke2N9Ly53ZWxsLWtub3duL2xudXJscC8ke2F9YDtcbiAgICB9IGVsc2UgaWYgKGUpIHtcbiAgICAgIGNvbnN0IHsgd29yZHM6IGEgfSA9IHRlLmRlY29kZShlLCAxZTMpLCBjID0gdGUuZnJvbVdvcmRzKGEpO1xuICAgICAgbiA9IG5ldyBUZXh0RGVjb2RlcihcInV0Zi04XCIpLmRlY29kZShjKTtcbiAgICB9XG4gICAgaWYgKCFuKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gemFwIGVuZHBvaW50IGZvdW5kXCIpO1xuICAgIGNvbnN0IG8gPSBhd2FpdCAoYXdhaXQgZmV0Y2gobikpLmpzb24oKTtcbiAgICByZXR1cm4gKG8gPT0gbnVsbCA/IHZvaWQgMCA6IG8uYWxsb3dzTm9zdHIpICYmICgobyA9PSBudWxsID8gdm9pZCAwIDogby5ub3N0clB1YmtleSkgfHwgKG8gPT0gbnVsbCA/IHZvaWQgMCA6IG8ubm9zdHJQdWJLZXkpKSAmJiAoaSA9IG8uY2FsbGJhY2spLCBpO1xuICB9XG4gIGFzeW5jIGNyZWF0ZVphcFJlcXVlc3QoZSwgciwgbiwgaSkge1xuICAgIGNvbnN0IHMgPSBhd2FpdCB0aGlzLmdldFphcEVuZHBvaW50KCk7XG4gICAgaWYgKCFzKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gemFwIGVuZHBvaW50IGZvdW5kXCIpO1xuICAgIGlmICghdGhpcy56YXBwZWRFdmVudClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHphcHBlZCBldmVudCBmb3VuZFwiKTtcbiAgICBjb25zdCBvID0gRWEubWFrZVphcFJlcXVlc3Qoe1xuICAgICAgcHJvZmlsZTogdGhpcy56YXBwZWRVc2VyLmhleHB1YmtleSgpLFxuICAgICAgZXZlbnQ6IG51bGwsXG4gICAgICBhbW91bnQ6IGUsXG4gICAgICBjb21tZW50OiByIHx8IFwiXCIsXG4gICAgICByZWxheXM6IGkgIT0gbnVsbCA/IGkgOiB0aGlzLnJlbGF5cygpXG4gICAgfSk7XG4gICAgaWYgKHRoaXMuemFwcGVkRXZlbnQpIHtcbiAgICAgIGNvbnN0IHUgPSB0aGlzLnphcHBlZEV2ZW50LnRhZ1JlZmVyZW5jZSgpO1xuICAgICAgdSAmJiBvLnRhZ3MucHVzaCh1KTtcbiAgICB9XG4gICAgby50YWdzLnB1c2goW1wibG51cmxcIiwgc10pO1xuICAgIGNvbnN0IGEgPSBuZXcgcWUodGhpcy5uZGssIG8pO1xuICAgIG4gJiYgKGEudGFncyA9IGEudGFncy5jb25jYXQobikpLCBhd2FpdCBhLnNpZ24oKTtcbiAgICBjb25zdCBjID0gYXdhaXQgYS50b05vc3RyRXZlbnQoKTtcbiAgICByZXR1cm4gKGF3YWl0IChhd2FpdCBmZXRjaChcbiAgICAgIGAke3N9P2AgKyBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgYW1vdW50OiBlLnRvU3RyaW5nKCksXG4gICAgICAgIG5vc3RyOiBKU09OLnN0cmluZ2lmeShjKVxuICAgICAgfSlcbiAgICApKS5qc29uKCkpLnByO1xuICB9XG4gIHJlbGF5cygpIHtcbiAgICB2YXIgciwgbjtcbiAgICBsZXQgZSA9IFtdO1xuICAgIHJldHVybiAobiA9IChyID0gdGhpcy5uZGspID09IG51bGwgPyB2b2lkIDAgOiByLnBvb2wpICE9IG51bGwgJiYgbi5yZWxheXMgJiYgKGUgPSB0aGlzLm5kay5wb29sLnVybHMoKSksIGUubGVuZ3RoIHx8IChlID0geWQpLCBlO1xuICB9XG59O1xuZnVuY3Rpb24gYmQodCwgZSA9IFtdKSB7XG4gIGNvbnN0IHIgPSAvKEB8bm9zdHI6KShucHVifG5wcm9maWxlfG5vdGV8bmV2ZW50KVthLXpBLVowLTldKy9nO1xuICByZXR1cm4gdCA9IHQucmVwbGFjZShyLCAobikgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBpID0gbi5zcGxpdCgvKEB8bm9zdHI6KS8pWzJdLCB7IHR5cGU6IHMsIGRhdGE6IG8gfSA9IHdlLmRlY29kZShpKTtcbiAgICAgIGxldCBhO1xuICAgICAgc3dpdGNoIChzKSB7XG4gICAgICAgIGNhc2UgXCJucHViXCI6XG4gICAgICAgICAgYSA9IFtcInBcIiwgb107XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJucHJvZmlsZVwiOlxuICAgICAgICAgIGEgPSBbXCJwXCIsIG8ucHVia2V5XTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm5ldmVudFwiOlxuICAgICAgICAgIGEgPSBbXCJlXCIsIG8uaWRdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibm90ZVwiOlxuICAgICAgICAgIGEgPSBbXCJlXCIsIG9dO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGUuZmluZCgoYykgPT4gY1swXSA9PT0gYVswXSAmJiBjWzFdID09PSBhWzFdKSB8fCBlLnB1c2goYSksIGBub3N0cjoke2l9YDtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBuO1xuICAgIH1cbiAgfSksIHsgY29udGVudDogdCwgdGFnczogZSB9O1xufVxuZnVuY3Rpb24gdmQoKSB7XG4gIGlmICh0aGlzLmtpbmQgPT09IHZvaWQgMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJLaW5kIG5vdCBzZXRcIik7XG4gIHJldHVybiB0aGlzLmtpbmQgPj0gMWU0ICYmIHRoaXMua2luZCA8IDJlNDtcbn1cbmZ1bmN0aW9uIHdkKCkge1xuICBpZiAodGhpcy5raW5kID09PSB2b2lkIDApXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiS2luZCBub3Qgc2V0XCIpO1xuICByZXR1cm4gdGhpcy5raW5kID49IDNlNCAmJiB0aGlzLmtpbmQgPCA0ZTQ7XG59XG5hc3luYyBmdW5jdGlvbiBfZCgpIHtcbiAgaWYgKCF0aGlzLm5kaylcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJOREsgbm90IHNldFwiKTtcbiAgY29uc3QgdCA9IGF3YWl0IHRoaXMubmRrLmZldGNoRXZlbnRzKHtcbiAgICBraW5kczogWzNdLFxuICAgIGF1dGhvcnM6IFt0aGlzLmhleHB1YmtleSgpXVxuICB9KTtcbiAgaWYgKHQpIHtcbiAgICBjb25zdCBlID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICByZXR1cm4gdC5mb3JFYWNoKChyKSA9PiB7XG4gICAgICByLnRhZ3MuZm9yRWFjaCgobikgPT4ge1xuICAgICAgICBpZiAoblswXSA9PT0gXCJwXCIpXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGkgPSB3ZS5ucHViRW5jb2RlKG5bMV0pO1xuICAgICAgICAgICAgZS5hZGQoaSk7XG4gICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSksIFsuLi5lXS5yZWR1Y2UoKHIsIG4pID0+IHtcbiAgICAgIGNvbnN0IGkgPSBuZXcgcGUoeyBucHViOiBuIH0pO1xuICAgICAgcmV0dXJuIGkubmRrID0gdGhpcy5uZGssIHIuYWRkKGkpLCByO1xuICAgIH0sIC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xufVxuZnVuY3Rpb24gbWQodCwgZSkge1xuICBjb25zdCByID0gSlNPTi5wYXJzZSh0LmNvbnRlbnQpO1xuICByZXR1cm4gT2JqZWN0LmtleXMocikuZm9yRWFjaCgobikgPT4ge1xuICAgIHN3aXRjaCAobikge1xuICAgICAgY2FzZSBcIm5hbWVcIjpcbiAgICAgICAgZS5uYW1lID0gci5uYW1lO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJkaXNwbGF5X25hbWVcIjpcbiAgICAgIGNhc2UgXCJkaXNwbGF5TmFtZVwiOlxuICAgICAgICBlLmRpc3BsYXlOYW1lID0gci5kaXNwbGF5TmFtZSB8fCByLmRpc3BsYXlfbmFtZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiaW1hZ2VcIjpcbiAgICAgIGNhc2UgXCJwaWN0dXJlXCI6XG4gICAgICAgIGUuaW1hZ2UgPSByLmltYWdlIHx8IHIucGljdHVyZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYmFubmVyXCI6XG4gICAgICAgIGUuYmFubmVyID0gci5iYW5uZXI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImJpb1wiOlxuICAgICAgICBlLmJpbyA9IHIuYmlvO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJuaXAwNVwiOlxuICAgICAgICBlLm5pcDA1ID0gci5uaXAwNTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibHVkMDZcIjpcbiAgICAgICAgZS5sdWQwNiA9IHIubHVkMDY7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImx1ZDE2XCI6XG4gICAgICAgIGUubHVkMTYgPSByLmx1ZDE2O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJhYm91dFwiOlxuICAgICAgICBlLmFib3V0ID0gci5hYm91dDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiemFwU2VydmljZVwiOlxuICAgICAgICBlLnphcFNlcnZpY2UgPSByLnphcFNlcnZpY2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIndlYnNpdGVcIjpcbiAgICAgICAgZS53ZWJzaXRlID0gci53ZWJzaXRlO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGVbbl0gPSByW25dO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0pLCBlO1xufVxudmFyIHBlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgSSh0aGlzLCBcIm5ka1wiKTtcbiAgICBJKHRoaXMsIFwicHJvZmlsZVwiKTtcbiAgICBJKHRoaXMsIFwibnB1YlwiLCBcIlwiKTtcbiAgICBJKHRoaXMsIFwicmVsYXlVcmxzXCIsIFtdKTtcbiAgICBJKHRoaXMsIFwiZm9sbG93c1wiLCBfZC5iaW5kKHRoaXMpKTtcbiAgICB0Lm5wdWIgJiYgKHRoaXMubnB1YiA9IHQubnB1YiksIHQuaGV4cHVia2V5ICYmICh0aGlzLm5wdWIgPSB3ZS5ucHViRW5jb2RlKHQuaGV4cHVia2V5KSksIHQucmVsYXlVcmxzICYmICh0aGlzLnJlbGF5VXJscyA9IHQucmVsYXlVcmxzKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZnJvbU5pcDA1KHQpIHtcbiAgICBjb25zdCBlID0gYXdhaXQgX2EucXVlcnlQcm9maWxlKHQpO1xuICAgIGlmIChlKVxuICAgICAgcmV0dXJuIG5ldyBwZSh7XG4gICAgICAgIGhleHB1YmtleTogZS5wdWJrZXksXG4gICAgICAgIHJlbGF5VXJsczogZS5yZWxheXNcbiAgICAgIH0pO1xuICB9XG4gIGhleHB1YmtleSgpIHtcbiAgICByZXR1cm4gd2UuZGVjb2RlKHRoaXMubnB1YikuZGF0YTtcbiAgfVxuICBhc3luYyBmZXRjaFByb2ZpbGUodCkge1xuICAgIGlmICghdGhpcy5uZGspXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOREsgbm90IHNldFwiKTtcbiAgICB0aGlzLnByb2ZpbGUgfHwgKHRoaXMucHJvZmlsZSA9IHt9KTtcbiAgICBjb25zdCBlID0gYXdhaXQgdGhpcy5uZGsuZmV0Y2hFdmVudHMoXG4gICAgICB7XG4gICAgICAgIGtpbmRzOiBbMF0sXG4gICAgICAgIGF1dGhvcnM6IFt0aGlzLmhleHB1YmtleSgpXVxuICAgICAgfSxcbiAgICAgIHRcbiAgICApO1xuICAgIHJldHVybiBlICYmIEFycmF5LmZyb20oZSkuc29ydChcbiAgICAgIChuLCBpKSA9PiBuLmNyZWF0ZWRfYXQgLSBpLmNyZWF0ZWRfYXRcbiAgICApLmZvckVhY2goKG4pID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMucHJvZmlsZSA9IG1kKG4sIHRoaXMucHJvZmlsZSk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgIH1cbiAgICB9KSwgZTtcbiAgfVxuICBhc3luYyByZWxheUxpc3QoKSB7XG4gICAgaWYgKCF0aGlzLm5kaylcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5ESyBub3Qgc2V0XCIpO1xuICAgIGNvbnN0IHQgPSBhd2FpdCB0aGlzLm5kay5mZXRjaEV2ZW50cyh7XG4gICAgICBraW5kczogWzEwMDAyXSxcbiAgICAgIGF1dGhvcnM6IFt0aGlzLmhleHB1YmtleSgpXVxuICAgIH0pO1xuICAgIHJldHVybiB0IHx8IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIH1cbiAgdGFnUmVmZXJlbmNlKCkge1xuICAgIHJldHVybiBbXCJwXCIsIHRoaXMuaGV4cHVia2V5KCldO1xuICB9XG4gIGFzeW5jIHB1Ymxpc2goKSB7XG4gICAgaWYgKCF0aGlzLm5kaylcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIE5ESyBpbnN0YW5jZSBmb3VuZFwiKTtcbiAgICB0aGlzLm5kay5hc3NlcnRTaWduZXIoKSwgYXdhaXQgbmV3IHFlKHRoaXMubmRrLCB7XG4gICAgICBraW5kOiAwLFxuICAgICAgY29udGVudDogSlNPTi5zdHJpbmdpZnkodGhpcy5wcm9maWxlKVxuICAgIH0pLnB1Ymxpc2goKTtcbiAgfVxuICBhc3luYyBmb2xsb3codCwgZSkge1xuICAgIGlmICghdGhpcy5uZGspXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBOREsgaW5zdGFuY2UgZm91bmRcIik7XG4gICAgaWYgKHRoaXMubmRrLmFzc2VydFNpZ25lcigpLCBlIHx8IChlID0gYXdhaXQgdGhpcy5mb2xsb3dzKCkpLCBlLmhhcyh0KSlcbiAgICAgIHJldHVybiAhMTtcbiAgICBlLmFkZCh0KTtcbiAgICBjb25zdCByID0gbmV3IHFlKHRoaXMubmRrLCB7IGtpbmQ6IDMgfSk7XG4gICAgZm9yIChjb25zdCBuIG9mIGUpXG4gICAgICByLnRhZyhuKTtcbiAgICByZXR1cm4gYXdhaXQgci5wdWJsaXNoKCksICEwO1xuICB9XG59O1xuYXN5bmMgZnVuY3Rpb24geGQodCwgZSkge1xuICBpZiAoIWUpIHtcbiAgICBpZiAoIXRoaXMubmRrKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc2lnbmVyIGF2YWlsYWJsZVwiKTtcbiAgICBhd2FpdCB0aGlzLm5kay5hc3NlcnRTaWduZXIoKSwgZSA9IHRoaXMubmRrLnNpZ25lcjtcbiAgfVxuICBpZiAoIXQpIHtcbiAgICBjb25zdCByID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJwXCIpO1xuICAgIGlmIChyLmxlbmd0aCAhPT0gMSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHJlY2lwaWVudCBjb3VsZCBiZSBkZXRlcm1pbmVkIGFuZCBubyBleHBsaWNpdCByZWNpcGllbnQgd2FzIHByb3ZpZGVkXCIpO1xuICAgIHQgPSBuZXcgcGUoeyBoZXhwdWJrZXk6IHJbMF1bMV0gfSksIHQubmRrID0gdGhpcy5uZGs7XG4gIH1cbiAgdGhpcy5jb250ZW50ID0gYXdhaXQgZS5lbmNyeXB0KHQsIHRoaXMuY29udGVudCk7XG59XG5hc3luYyBmdW5jdGlvbiBFZCh0LCBlKSB7XG4gIGlmICghZSkge1xuICAgIGlmICghdGhpcy5uZGspXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBzaWduZXIgYXZhaWxhYmxlXCIpO1xuICAgIGF3YWl0IHRoaXMubmRrLmFzc2VydFNpZ25lcigpLCBlID0gdGhpcy5uZGsuc2lnbmVyO1xuICB9XG4gIHQgfHwgKHQgPSB0aGlzLmF1dGhvciksIHRoaXMuY29udGVudCA9IGF3YWl0IGUuZGVjcnlwdCh0LCB0aGlzLmNvbnRlbnQpO1xufVxuZnVuY3Rpb24ga2QoKSB7XG4gIHJldHVybiB0aGlzLmlzUGFyYW1SZXBsYWNlYWJsZSgpID8gd2UubmFkZHJFbmNvZGUoe1xuICAgIGtpbmQ6IHRoaXMua2luZCxcbiAgICBwdWJrZXk6IHRoaXMucHVia2V5LFxuICAgIGlkZW50aWZpZXI6IHRoaXMucmVwbGFjZWFibGVEVGFnKClcbiAgfSkgOiB3ZS5ub3RlRW5jb2RlKHRoaXMudGFnSWQoKSk7XG59XG5hc3luYyBmdW5jdGlvbiBTZCh0ID0gITAsIGUpIHtcbiAgaWYgKCFlKSB7XG4gICAgaWYgKCF0aGlzLm5kaylcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIE5ESyBpbnN0YW5jZSBmb3VuZFwiKTtcbiAgICB0aGlzLm5kay5hc3NlcnRTaWduZXIoKSwgZSA9IHRoaXMubmRrLnNpZ25lcjtcbiAgfVxuICBpZiAoIWUpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc2lnbmVyIGF2YWlsYWJsZVwiKTtcbiAgY29uc3QgciA9IGF3YWl0IGUudXNlcigpLCBuID0gbmV3IHFlKHRoaXMubmRrLCB7XG4gICAga2luZDogT2QodGhpcyksXG4gICAgY29udGVudDogXCJcIixcbiAgICBwdWJrZXk6IHIuaGV4cHVia2V5KClcbiAgfSk7XG4gIHJldHVybiBuLnRhZyh0aGlzKSwgbi5raW5kID09PSAxNiAmJiBuLnRhZ3MucHVzaChbXCJrXCIsIGAke3RoaXMua2luZH1gXSksIGF3YWl0IG4uc2lnbihlKSwgdCAmJiBhd2FpdCBuLnB1Ymxpc2goKSwgbjtcbn1cbmZ1bmN0aW9uIE9kKHQpIHtcbiAgcmV0dXJuIHQua2luZCA9PT0gMSA/IDYgOiAxNjtcbn1cbnZhciBxZSA9IGNsYXNzIGV4dGVuZHMgZHQge1xuICBjb25zdHJ1Y3RvcihlLCByKSB7XG4gICAgc3VwZXIoKTtcbiAgICBJKHRoaXMsIFwibmRrXCIpO1xuICAgIEkodGhpcywgXCJjcmVhdGVkX2F0XCIpO1xuICAgIEkodGhpcywgXCJjb250ZW50XCIsIFwiXCIpO1xuICAgIEkodGhpcywgXCJ0YWdzXCIsIFtdKTtcbiAgICBJKHRoaXMsIFwia2luZFwiKTtcbiAgICBJKHRoaXMsIFwiaWRcIiwgXCJcIik7XG4gICAgSSh0aGlzLCBcInNpZ1wiKTtcbiAgICBJKHRoaXMsIFwicHVia2V5XCIsIFwiXCIpO1xuICAgIEkodGhpcywgXCJyZWxheVwiKTtcbiAgICBJKHRoaXMsIFwiaXNSZXBsYWNlYWJsZVwiLCB2ZC5iaW5kKHRoaXMpKTtcbiAgICBJKHRoaXMsIFwiaXNQYXJhbVJlcGxhY2VhYmxlXCIsIHdkLmJpbmQodGhpcykpO1xuICAgIEkodGhpcywgXCJlbmNvZGVcIiwga2QuYmluZCh0aGlzKSk7XG4gICAgSSh0aGlzLCBcImVuY3J5cHRcIiwgeGQuYmluZCh0aGlzKSk7XG4gICAgSSh0aGlzLCBcImRlY3J5cHRcIiwgRWQuYmluZCh0aGlzKSk7XG4gICAgSSh0aGlzLCBcInJlcG9zdFwiLCBTZC5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLm5kayA9IGUsIHRoaXMuY3JlYXRlZF9hdCA9IHIgPT0gbnVsbCA/IHZvaWQgMCA6IHIuY3JlYXRlZF9hdCwgdGhpcy5jb250ZW50ID0gKHIgPT0gbnVsbCA/IHZvaWQgMCA6IHIuY29udGVudCkgfHwgXCJcIiwgdGhpcy50YWdzID0gKHIgPT0gbnVsbCA/IHZvaWQgMCA6IHIudGFncykgfHwgW10sIHRoaXMuaWQgPSAociA9PSBudWxsID8gdm9pZCAwIDogci5pZCkgfHwgXCJcIiwgdGhpcy5zaWcgPSByID09IG51bGwgPyB2b2lkIDAgOiByLnNpZywgdGhpcy5wdWJrZXkgPSAociA9PSBudWxsID8gdm9pZCAwIDogci5wdWJrZXkpIHx8IFwiXCIsIHRoaXMua2luZCA9IHIgPT0gbnVsbCA/IHZvaWQgMCA6IHIua2luZDtcbiAgfVxuICByYXdFdmVudCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY3JlYXRlZF9hdDogdGhpcy5jcmVhdGVkX2F0LFxuICAgICAgY29udGVudDogdGhpcy5jb250ZW50LFxuICAgICAgdGFnczogdGhpcy50YWdzLFxuICAgICAga2luZDogdGhpcy5raW5kLFxuICAgICAgcHVia2V5OiB0aGlzLnB1YmtleSxcbiAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgc2lnOiB0aGlzLnNpZ1xuICAgIH07XG4gIH1cbiAgc2V0IGF1dGhvcihlKSB7XG4gICAgdGhpcy5wdWJrZXkgPSBlLmhleHB1YmtleSgpO1xuICB9XG4gIGdldCBhdXRob3IoKSB7XG4gICAgY29uc3QgZSA9IG5ldyBwZSh7IGhleHB1YmtleTogdGhpcy5wdWJrZXkgfSk7XG4gICAgcmV0dXJuIGUubmRrID0gdGhpcy5uZGssIGU7XG4gIH1cbiAgdGFnKGUsIHIpIHtcbiAgICBjb25zdCBuID0gZS50YWdSZWZlcmVuY2UoKTtcbiAgICBpZiAociAmJiBuLnB1c2gociksIHRoaXMudGFncy5wdXNoKG4pLCBlIGluc3RhbmNlb2YgcWUpIHtcbiAgICAgIGNvbnN0IGkgPSBlLmF1dGhvcjtcbiAgICAgIGkgJiYgdGhpcy5wdWJrZXkgIT09IGkuaGV4cHVia2V5KCkgJiYgdGhpcy50YWcoaSk7XG4gICAgICBmb3IgKGNvbnN0IHMgb2YgZS5nZXRNYXRjaGluZ1RhZ3MoXCJwXCIpKVxuICAgICAgICBzWzFdICE9PSB0aGlzLnB1YmtleSAmJiAodGhpcy50YWdzLmZpbmQoKG8pID0+IG9bMF0gPT09IFwicFwiICYmIG9bMV0gPT09IHNbMV0pIHx8IHRoaXMudGFncy5wdXNoKFtcInBcIiwgc1sxXV0pKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgdG9Ob3N0ckV2ZW50KGUpIHtcbiAgICB2YXIgcywgbztcbiAgICBpZiAoIWUgJiYgdGhpcy5wdWJrZXkgPT09IFwiXCIpIHtcbiAgICAgIGNvbnN0IGEgPSBhd2FpdCAoKG8gPSAocyA9IHRoaXMubmRrKSA9PSBudWxsID8gdm9pZCAwIDogcy5zaWduZXIpID09IG51bGwgPyB2b2lkIDAgOiBvLnVzZXIoKSk7XG4gICAgICB0aGlzLnB1YmtleSA9IChhID09IG51bGwgPyB2b2lkIDAgOiBhLmhleHB1YmtleSgpKSB8fCBcIlwiO1xuICAgIH1cbiAgICB0aGlzLmNyZWF0ZWRfYXQgfHwgKHRoaXMuY3JlYXRlZF9hdCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDFlMykpO1xuICAgIGNvbnN0IHIgPSB0aGlzLnJhd0V2ZW50KCksIHsgY29udGVudDogbiwgdGFnczogaSB9ID0gdGhpcy5nZW5lcmF0ZVRhZ3MoKTtcbiAgICByLmNvbnRlbnQgPSBuIHx8IFwiXCIsIHIudGFncyA9IGk7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuaWQgPSBIcihyKTtcbiAgICB9IGNhdGNoIHtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaWQgJiYgKHIuaWQgPSB0aGlzLmlkKSwgdGhpcy5zaWcgJiYgKHIuc2lnID0gdGhpcy5zaWcpLCByO1xuICB9XG4gIGdldE1hdGNoaW5nVGFncyhlKSB7XG4gICAgcmV0dXJuIHRoaXMudGFncy5maWx0ZXIoKHIpID0+IHJbMF0gPT09IGUpO1xuICB9XG4gIHRhZ1ZhbHVlKGUpIHtcbiAgICBjb25zdCByID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoZSk7XG4gICAgaWYgKHIubGVuZ3RoICE9PSAwKVxuICAgICAgcmV0dXJuIHJbMF1bMV07XG4gIH1cbiAgcmVtb3ZlVGFnKGUpIHtcbiAgICB0aGlzLnRhZ3MgPSB0aGlzLnRhZ3MuZmlsdGVyKChyKSA9PiByWzBdICE9PSBlKTtcbiAgfVxuICBhc3luYyBzaWduKGUpIHtcbiAgICB2YXIgbjtcbiAgICBlIHx8ICgobiA9IHRoaXMubmRrKSA9PSBudWxsIHx8IG4uYXNzZXJ0U2lnbmVyKCksIGUgPSB0aGlzLm5kay5zaWduZXIpLCBhd2FpdCB0aGlzLmdlbmVyYXRlVGFncygpLCB0aGlzLmlzUmVwbGFjZWFibGUoKSAmJiAodGhpcy5jcmVhdGVkX2F0ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMWUzKSk7XG4gICAgY29uc3QgciA9IGF3YWl0IHRoaXMudG9Ob3N0ckV2ZW50KCk7XG4gICAgcmV0dXJuIHRoaXMuc2lnID0gYXdhaXQgZS5zaWduKHIpLCB0aGlzLnNpZztcbiAgfVxuICBhc3luYyBwdWJsaXNoKGUsIHIpIHtcbiAgICBpZiAodGhpcy5zaWcgfHwgYXdhaXQgdGhpcy5zaWduKCksICF0aGlzLm5kaylcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5ES0V2ZW50IG11c3QgYmUgYXNzb2NpYXRlZCB3aXRoIGFuIE5ESyBpbnN0YW5jZSB0byBwdWJsaXNoXCIpO1xuICAgIHJldHVybiB0aGlzLm5kay5wdWJsaXNoKHRoaXMsIGUsIHIpO1xuICB9XG4gIGdlbmVyYXRlVGFncygpIHtcbiAgICBsZXQgZSA9IFtdO1xuICAgIGNvbnN0IHIgPSBiZCh0aGlzLmNvbnRlbnQsIHRoaXMudGFncyksIG4gPSByLmNvbnRlbnQ7XG4gICAgaWYgKGUgPSByLnRhZ3MsIHRoaXMua2luZCAmJiB0aGlzLmtpbmQgPj0gM2U0ICYmIHRoaXMua2luZCA8PSA0ZTQgJiYgIXRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwiZFwiKVswXSkge1xuICAgICAgY29uc3QgcyA9IFsuLi5BcnJheSgxNildLm1hcCgoKSA9PiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KVsyXSkuam9pbihcIlwiKTtcbiAgICAgIGUucHVzaChbXCJkXCIsIHNdKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgY29udGVudDogbiB8fCBcIlwiLCB0YWdzOiBlIH07XG4gIH1cbiAgcmVwbGFjZWFibGVEVGFnKCkge1xuICAgIGlmICh0aGlzLmtpbmQgJiYgdGhpcy5raW5kID49IDNlNCAmJiB0aGlzLmtpbmQgPD0gNGU0KSB7XG4gICAgICBjb25zdCBlID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJkXCIpWzBdO1xuICAgICAgcmV0dXJuIGUgPyBlWzFdIDogXCJcIjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnQgaXMgbm90IGEgcGFyYW1ldGVyaXplZCByZXBsYWNlYWJsZSBldmVudFwiKTtcbiAgfVxuICB0YWdJZCgpIHtcbiAgICBpZiAodGhpcy5raW5kICYmIHRoaXMua2luZCA+PSAzZTQgJiYgdGhpcy5raW5kIDw9IDRlNCkge1xuICAgICAgY29uc3QgZSA9IHRoaXMucmVwbGFjZWFibGVEVGFnKCk7XG4gICAgICByZXR1cm4gYCR7dGhpcy5raW5kfToke3RoaXMucHVia2V5fToke2V9YDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaWQ7XG4gIH1cbiAgdGFnUmVmZXJlbmNlKCkge1xuICAgIHJldHVybiB0aGlzLmlzUGFyYW1SZXBsYWNlYWJsZSgpID8gW1wiYVwiLCB0aGlzLnRhZ0lkKCldIDogW1wiZVwiLCB0aGlzLnRhZ0lkKCldO1xuICB9XG4gIGZpbHRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1BhcmFtUmVwbGFjZWFibGUoKSA/IHsgXCIjYVwiOiBbdGhpcy50YWdJZCgpXSB9IDogeyBcIiNlXCI6IFt0aGlzLnRhZ0lkKCldIH07XG4gIH1cbiAgYXN5bmMgemFwKGUsIHIsIG4pIHtcbiAgICBpZiAoIXRoaXMubmRrKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gTkRLIGluc3RhbmNlIGZvdW5kXCIpO1xuICAgIHJldHVybiB0aGlzLm5kay5hc3NlcnRTaWduZXIoKSwgYXdhaXQgbmV3IGdkKHtcbiAgICAgIG5kazogdGhpcy5uZGssXG4gICAgICB6YXBwZWRFdmVudDogdGhpc1xuICAgIH0pLmNyZWF0ZVphcFJlcXVlc3QoZSwgciwgbik7XG4gIH1cbiAgYXN5bmMgZGVsZXRlKGUpIHtcbiAgICBpZiAoIXRoaXMubmRrKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gTkRLIGluc3RhbmNlIGZvdW5kXCIpO1xuICAgIHRoaXMubmRrLmFzc2VydFNpZ25lcigpO1xuICAgIGNvbnN0IHIgPSBuZXcgcWUodGhpcy5uZGssIHtcbiAgICAgIGtpbmQ6IDUsXG4gICAgICBjb250ZW50OiBlIHx8IFwiXCJcbiAgICB9KTtcbiAgICByZXR1cm4gci50YWcodGhpcyksIGF3YWl0IHIucHVibGlzaCgpLCByO1xuICB9XG59LCBBZCA9IGNsYXNzIGV4dGVuZHMgZHQge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgc3VwZXIoKTtcbiAgICBJKHRoaXMsIFwidXJsXCIpO1xuICAgIEkodGhpcywgXCJzY29yZXNcIik7XG4gICAgSSh0aGlzLCBcInJlbGF5XCIpO1xuICAgIEkodGhpcywgXCJfc3RhdHVzXCIpO1xuICAgIEkodGhpcywgXCJjb25uZWN0ZWRBdFwiKTtcbiAgICBJKHRoaXMsIFwiX2Nvbm5lY3Rpb25TdGF0c1wiLCB7IGF0dGVtcHRzOiAwLCBzdWNjZXNzOiAwLCBkdXJhdGlvbnM6IFtdIH0pO1xuICAgIEkodGhpcywgXCJjb21wbGFpbmluZ1wiLCAhMSk7XG4gICAgSSh0aGlzLCBcImRlYnVnXCIpO1xuICAgIEkodGhpcywgXCJhY3RpdmVTdWJzY3JpcHRpb25zXCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpO1xuICAgIEkodGhpcywgXCJ1cGRhdGVDb25uZWN0aW9uU3RhdHNcIiwge1xuICAgICAgY29ubmVjdGVkOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3Rpb25TdGF0cy5zdWNjZXNzKyssIHRoaXMuX2Nvbm5lY3Rpb25TdGF0cy5jb25uZWN0ZWRBdCA9IERhdGUubm93KCk7XG4gICAgICB9LFxuICAgICAgZGlzY29ubmVjdGVkOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3Rpb25TdGF0cy5jb25uZWN0ZWRBdCAmJiAodGhpcy5fY29ubmVjdGlvblN0YXRzLmR1cmF0aW9ucy5wdXNoKFxuICAgICAgICAgIERhdGUubm93KCkgLSB0aGlzLl9jb25uZWN0aW9uU3RhdHMuY29ubmVjdGVkQXRcbiAgICAgICAgKSwgdGhpcy5fY29ubmVjdGlvblN0YXRzLmR1cmF0aW9ucy5sZW5ndGggPiAxMDAgJiYgdGhpcy5fY29ubmVjdGlvblN0YXRzLmR1cmF0aW9ucy5zaGlmdCgpKSwgdGhpcy5fY29ubmVjdGlvblN0YXRzLmNvbm5lY3RlZEF0ID0gdm9pZCAwO1xuICAgICAgfSxcbiAgICAgIGF0dGVtcHQ6ICgpID0+IHtcbiAgICAgICAgdGhpcy5fY29ubmVjdGlvblN0YXRzLmF0dGVtcHRzKys7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy51cmwgPSBlLCB0aGlzLnJlbGF5ID0gQWYoZSksIHRoaXMuc2NvcmVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgdGhpcy5fc3RhdHVzID0gMywgdGhpcy5kZWJ1ZyA9IE1uKGBuZGs6cmVsYXk6JHtlfWApLCB0aGlzLnJlbGF5Lm9uKFwiY29ubmVjdFwiLCAoKSA9PiB7XG4gICAgICB0aGlzLnVwZGF0ZUNvbm5lY3Rpb25TdGF0cy5jb25uZWN0ZWQoKSwgdGhpcy5fc3RhdHVzID0gMSwgdGhpcy5lbWl0KFwiY29ubmVjdFwiKTtcbiAgICB9KSwgdGhpcy5yZWxheS5vbihcImRpc2Nvbm5lY3RcIiwgKCkgPT4ge1xuICAgICAgdGhpcy51cGRhdGVDb25uZWN0aW9uU3RhdHMuZGlzY29ubmVjdGVkKCksIHRoaXMuX3N0YXR1cyA9PT0gMSAmJiAodGhpcy5fc3RhdHVzID0gMywgdGhpcy5oYW5kbGVSZWNvbm5lY3Rpb24oKSksIHRoaXMuZW1pdChcImRpc2Nvbm5lY3RcIik7XG4gICAgfSksIHRoaXMucmVsYXkub24oXCJub3RpY2VcIiwgKHIpID0+IHRoaXMuaGFuZGxlTm90aWNlKHIpKTtcbiAgfVxuICBpc0ZsYXBwaW5nKCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLl9jb25uZWN0aW9uU3RhdHMuZHVyYXRpb25zO1xuICAgIGlmIChlLmxlbmd0aCA8IDEwKVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IG4gPSBlLnJlZHVjZSgoYSwgYykgPT4gYSArIGMsIDApIC8gZS5sZW5ndGgsIGkgPSBlLm1hcCgoYSkgPT4gTWF0aC5wb3coYSAtIG4sIDIpKS5yZWR1Y2UoKGEsIGMpID0+IGEgKyBjLCAwKSAvIGUubGVuZ3RoO1xuICAgIHJldHVybiBNYXRoLnNxcnQoaSkgPCAxZTM7XG4gIH1cbiAgaGFuZGxlUmVjb25uZWN0aW9uKCkge1xuICAgIHRoaXMuaXNGbGFwcGluZygpICYmICh0aGlzLmVtaXQoXCJmbGFwcGluZ1wiLCB0aGlzLCB0aGlzLl9jb25uZWN0aW9uU3RhdHMpLCB0aGlzLl9zdGF0dXMgPSA1KSwgdGhpcy5jb25uZWN0ZWRBdCAmJiBEYXRlLm5vdygpIC0gdGhpcy5jb25uZWN0ZWRBdCA8IDVlMyA/IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5jb25uZWN0KCksIDZlNCkgOiB0aGlzLmNvbm5lY3QoKTtcbiAgfVxuICBnZXQgc3RhdHVzKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0dXM7XG4gIH1cbiAgYXN5bmMgY29ubmVjdCgpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy51cGRhdGVDb25uZWN0aW9uU3RhdHMuYXR0ZW1wdCgpLCB0aGlzLl9zdGF0dXMgPSAwLCBhd2FpdCB0aGlzLnJlbGF5LmNvbm5lY3QoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyB0aGlzLmRlYnVnKFwiRmFpbGVkIHRvIGNvbm5lY3RcIiwgZSksIHRoaXMuX3N0YXR1cyA9IDMsIGU7XG4gICAgfVxuICB9XG4gIGRpc2Nvbm5lY3QoKSB7XG4gICAgdGhpcy5fc3RhdHVzID0gMiwgdGhpcy5yZWxheS5jbG9zZSgpO1xuICB9XG4gIGFzeW5jIGhhbmRsZU5vdGljZShlKSB7XG4gICAgKGUuaW5jbHVkZXMoXCJvbyBtYW55XCIpIHx8IGUuaW5jbHVkZXMoXCJheGltdW1cIikpICYmICh0aGlzLmRpc2Nvbm5lY3QoKSwgc2V0VGltZW91dCgoKSA9PiB0aGlzLmNvbm5lY3QoKSwgMmUzKSwgdGhpcy5kZWJ1Zyh0aGlzLnJlbGF5LnVybCwgXCJSZWxheSBjb21wbGFpbmluZz9cIiwgZSkpLCB0aGlzLmVtaXQoXCJub3RpY2VcIiwgdGhpcywgZSk7XG4gIH1cbiAgc3Vic2NyaWJlKGUpIHtcbiAgICBjb25zdCB7IGZpbHRlcjogciB9ID0gZSwgbiA9IHRoaXMucmVsYXkuc3ViKFtyXSwge1xuICAgICAgaWQ6IGUuc3ViSWRcbiAgICB9KTtcbiAgICB0aGlzLmRlYnVnKGBTdWJzY3JpYmVkIHRvICR7SlNPTi5zdHJpbmdpZnkocil9YCksIG4ub24oXCJldmVudFwiLCAocykgPT4ge1xuICAgICAgY29uc3QgbyA9IG5ldyBxZSh2b2lkIDAsIHMpO1xuICAgICAgby5yZWxheSA9IHRoaXMsIGUuZXZlbnRSZWNlaXZlZChvLCB0aGlzKTtcbiAgICB9KSwgbi5vbihcImVvc2VcIiwgKCkgPT4ge1xuICAgICAgZS5lb3NlUmVjZWl2ZWQodGhpcyk7XG4gICAgfSk7XG4gICAgY29uc3QgaSA9IG4udW5zdWI7XG4gICAgcmV0dXJuIG4udW5zdWIgPSAoKSA9PiB7XG4gICAgICB0aGlzLmRlYnVnKGBVbnN1YnNjcmliaW5nIGZyb20gJHtKU09OLnN0cmluZ2lmeShyKX1gKSwgdGhpcy5hY3RpdmVTdWJzY3JpcHRpb25zLmRlbGV0ZShlKSwgaSgpO1xuICAgIH0sIHRoaXMuYWN0aXZlU3Vic2NyaXB0aW9ucy5hZGQoZSksIGUub24oXCJjbG9zZVwiLCAoKSA9PiB7XG4gICAgICB0aGlzLmFjdGl2ZVN1YnNjcmlwdGlvbnMuZGVsZXRlKGUpO1xuICAgIH0pLCBuO1xuICB9XG4gIGFzeW5jIHB1Ymxpc2goZSwgciA9IDI1MDApIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09IDEgPyB0aGlzLnB1Ymxpc2hFdmVudChlLCByKSA6ICh0aGlzLm9uY2UoXCJjb25uZWN0XCIsICgpID0+IHtcbiAgICAgIHRoaXMucHVibGlzaEV2ZW50KGUsIHIpO1xuICAgIH0pLCAhMCk7XG4gIH1cbiAgYXN5bmMgcHVibGlzaEV2ZW50KGUsIHIpIHtcbiAgICBjb25zdCBuID0gYXdhaXQgZS50b05vc3RyRXZlbnQoKSwgaSA9IHRoaXMucmVsYXkucHVibGlzaChuKTtcbiAgICBsZXQgcztcbiAgICBjb25zdCBvID0gbmV3IFByb21pc2UoKGMsIGwpID0+IHtcbiAgICAgIGkub24oXCJmYWlsZWRcIiwgKGYpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHMpLCB0aGlzLmRlYnVnKFwiUHVibGlzaCBmYWlsZWRcIiwgZiwgZS5pZCksIHRoaXMuZW1pdChcInB1Ymxpc2g6ZmFpbGVkXCIsIGUsIGYpLCBsKGYpO1xuICAgICAgfSksIGkub24oXCJva1wiLCAoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dChzKSwgdGhpcy5lbWl0KFwicHVibGlzaGVkXCIsIGUpLCBjKCEwKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmICghcilcbiAgICAgIHJldHVybiBvO1xuICAgIGNvbnN0IGEgPSBuZXcgUHJvbWlzZSgoYywgbCkgPT4ge1xuICAgICAgcyA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLmRlYnVnKFwiUHVibGlzaCB0aW1lZCBvdXRcIiwgZS5yYXdFdmVudCgpKSwgdGhpcy5lbWl0KFwicHVibGlzaDpmYWlsZWRcIiwgZSwgXCJUaW1lb3V0XCIpLCBsKG5ldyBFcnJvcihcIlB1Ymxpc2ggb3BlcmF0aW9uIHRpbWVkIG91dFwiKSk7XG4gICAgICB9LCByKTtcbiAgICB9KTtcbiAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtvLCBhXSk7XG4gIH1cbiAgc2NvcmVTbG93ZXJFdmVudChlKSB7XG4gIH1cbiAgZ2V0IGNvbm5lY3Rpb25TdGF0cygpIHtcbiAgICByZXR1cm4gdGhpcy5fY29ubmVjdGlvblN0YXRzO1xuICB9XG4gIHRhZ1JlZmVyZW5jZShlKSB7XG4gICAgY29uc3QgciA9IFtcInJcIiwgdGhpcy5yZWxheS51cmxdO1xuICAgIHJldHVybiBlICYmIHIucHVzaChlKSwgcjtcbiAgfVxufSwgQ2QgPSBjbGFzcyBleHRlbmRzIGR0IHtcbiAgY29uc3RydWN0b3IoZSA9IFtdLCByKSB7XG4gICAgc3VwZXIoKTtcbiAgICBJKHRoaXMsIFwicmVsYXlzXCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICAgIEkodGhpcywgXCJkZWJ1Z1wiKTtcbiAgICB0aGlzLmRlYnVnID0gci5kZWJ1Zy5leHRlbmQoXCJwb29sXCIpO1xuICAgIGZvciAoY29uc3QgbiBvZiBlKSB7XG4gICAgICBjb25zdCBpID0gbmV3IEFkKG4pO1xuICAgICAgaS5vbihcIm5vdGljZVwiLCAocywgbykgPT4gdGhpcy5lbWl0KFwibm90aWNlXCIsIHMsIG8pKSwgaS5vbihcImNvbm5lY3RcIiwgKCkgPT4gdGhpcy5oYW5kbGVSZWxheUNvbm5lY3QobikpLCBpLm9uKFwiZGlzY29ubmVjdFwiLCAoKSA9PiB0aGlzLmVtaXQoXCJyZWxheTpkaXNjb25uZWN0XCIsIGkpKSwgaS5vbihcImZsYXBwaW5nXCIsICgpID0+IHRoaXMuaGFuZGxlRmxhcHBpbmcoaSkpLCB0aGlzLnJlbGF5cy5zZXQobiwgaSk7XG4gICAgfVxuICB9XG4gIGhhbmRsZVJlbGF5Q29ubmVjdChlKSB7XG4gICAgdGhpcy5kZWJ1ZyhgUmVsYXkgJHtlfSBjb25uZWN0ZWRgKSwgdGhpcy5lbWl0KFwicmVsYXk6Y29ubmVjdFwiLCB0aGlzLnJlbGF5cy5nZXQoZSkpLCB0aGlzLnN0YXRzKCkuY29ubmVjdGVkID09PSB0aGlzLnJlbGF5cy5zaXplICYmIHRoaXMuZW1pdChcImNvbm5lY3RcIik7XG4gIH1cbiAgYXN5bmMgY29ubmVjdChlKSB7XG4gICAgY29uc3QgciA9IFtdO1xuICAgIHRoaXMuZGVidWcoXG4gICAgICBgQ29ubmVjdGluZyB0byAke3RoaXMucmVsYXlzLnNpemV9IHJlbGF5cyR7ZSA/IGAsIHRpbWVvdXQgJHtlfS4uLmAgOiBcIlwifWBcbiAgICApO1xuICAgIGZvciAoY29uc3QgbiBvZiB0aGlzLnJlbGF5cy52YWx1ZXMoKSlcbiAgICAgIGlmIChlKSB7XG4gICAgICAgIGNvbnN0IGkgPSBuZXcgUHJvbWlzZSgocywgbykgPT4ge1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gbyhgVGltZWQgb3V0IGFmdGVyICR7ZX1tc2ApLCBlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHIucHVzaChcbiAgICAgICAgICBQcm9taXNlLnJhY2UoW24uY29ubmVjdCgpLCBpXSkuY2F0Y2goKHMpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGVidWcoYEZhaWxlZCB0byBjb25uZWN0IHRvIHJlbGF5ICR7bi51cmx9OiAke3N9YCk7XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICByLnB1c2gobi5jb25uZWN0KCkpO1xuICAgIGUgJiYgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBjb25zdCBuID0gdGhpcy5zdGF0cygpLmNvbm5lY3RlZCA9PT0gdGhpcy5yZWxheXMuc2l6ZSwgaSA9IHRoaXMuc3RhdHMoKS5jb25uZWN0ZWQgPiAwO1xuICAgICAgIW4gJiYgaSAmJiB0aGlzLmVtaXQoXCJjb25uZWN0XCIpO1xuICAgIH0sIGUpLCBhd2FpdCBQcm9taXNlLmFsbChyKTtcbiAgfVxuICBoYW5kbGVGbGFwcGluZyhlKSB7XG4gICAgdGhpcy5kZWJ1ZyhgUmVsYXkgJHtlLnVybH0gaXMgZmxhcHBpbmdgKSwgdGhpcy5yZWxheXMuZGVsZXRlKGUudXJsKSwgdGhpcy5lbWl0KFwiZmxhcHBpbmdcIiwgZSk7XG4gIH1cbiAgc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWxheXMuc2l6ZTtcbiAgfVxuICBzdGF0cygpIHtcbiAgICBjb25zdCBlID0ge1xuICAgICAgdG90YWw6IDAsXG4gICAgICBjb25uZWN0ZWQ6IDAsXG4gICAgICBkaXNjb25uZWN0ZWQ6IDAsXG4gICAgICBjb25uZWN0aW5nOiAwXG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IHIgb2YgdGhpcy5yZWxheXMudmFsdWVzKCkpXG4gICAgICBlLnRvdGFsKyssIHIuc3RhdHVzID09PSAxID8gZS5jb25uZWN0ZWQrKyA6IHIuc3RhdHVzID09PSAzID8gZS5kaXNjb25uZWN0ZWQrKyA6IHIuc3RhdHVzID09PSAwICYmIGUuY29ubmVjdGluZysrO1xuICAgIHJldHVybiBlO1xuICB9XG4gIHVybHMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5yZWxheXMua2V5cygpKTtcbiAgfVxufTtcbmZ1bmN0aW9uIElkKHQpIHtcbiAgcmV0dXJuICEhKFJkKHQuZmlsdGVyKSAmJiBUZCh0KSk7XG59XG5mdW5jdGlvbiBSZCh0KSB7XG4gIHJldHVybiAhIXQuaWRzO1xufVxuZnVuY3Rpb24gVGQodCkge1xuICBjb25zdCBlID0gdC5maWx0ZXIuaWRzO1xuICByZXR1cm4gISFlICYmIGUubGVuZ3RoID09PSB0LmV2ZW50Rmlyc3RTZWVuLnNpemU7XG59XG52YXIgUGQgPSB7XG4gIGNsb3NlT25Fb3NlOiAhMCxcbiAgY2FjaGVVc2FnZTogXCJDQUNIRV9GSVJTVFwiLFxuICBncm91cGFibGU6ICEwLFxuICBncm91cGFibGVEZWxheTogMTAwXG59LCBQYSA9IGNsYXNzIGV4dGVuZHMgZHQge1xuICBjb25zdHJ1Y3RvcihlLCByLCBuLCBpLCBzKSB7XG4gICAgc3VwZXIoKTtcbiAgICBJKHRoaXMsIFwic3ViSWRcIik7XG4gICAgSSh0aGlzLCBcImZpbHRlclwiKTtcbiAgICBJKHRoaXMsIFwib3B0c1wiKTtcbiAgICBJKHRoaXMsIFwicmVsYXlTZXRcIik7XG4gICAgSSh0aGlzLCBcIm5ka1wiKTtcbiAgICBJKHRoaXMsIFwicmVsYXlTdWJzY3JpcHRpb25zXCIpO1xuICAgIEkodGhpcywgXCJkZWJ1Z1wiKTtcbiAgICBJKHRoaXMsIFwiZXZlbnRGaXJzdFNlZW5cIiwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gICAgSSh0aGlzLCBcImVvc2VzU2VlblwiLCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKTtcbiAgICBJKHRoaXMsIFwiZXZlbnRzUGVyUmVsYXlcIiwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gICAgSSh0aGlzLCBcImVvc2VUaW1lb3V0XCIpO1xuICAgIGlmICh0aGlzLm5kayA9IGUsIHRoaXMub3B0cyA9IHsgLi4uUGQsIC4uLm4gfHwge30gfSwgdGhpcy5zdWJJZCA9IHMgfHwgKG4gPT0gbnVsbCA/IHZvaWQgMCA6IG4uc3ViSWQpIHx8IHFkKHIpLCB0aGlzLmZpbHRlciA9IHIsIHRoaXMucmVsYXlTZXQgPSBpLCB0aGlzLnJlbGF5U3Vic2NyaXB0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIHRoaXMuZGVidWcgPSBlLmRlYnVnLmV4dGVuZChgc3Vic2NyaXB0aW9uOiR7dGhpcy5zdWJJZH1gKSwgdGhpcy5vcHRzLmNhY2hlVXNhZ2UgPT09IFwiT05MWV9DQUNIRVwiICYmICF0aGlzLm9wdHMuY2xvc2VPbkVvc2UpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgdXNlIGNhY2hlLW9ubHkgb3B0aW9ucyB3aXRoIGEgcGVyc2lzdGVudCBzdWJzY3JpcHRpb25cIik7XG4gIH1cbiAgZ3JvdXBhYmxlSWQoKSB7XG4gICAgdmFyIGksIHM7XG4gICAgaWYgKCEoKGkgPSB0aGlzLm9wdHMpICE9IG51bGwgJiYgaS5ncm91cGFibGUpKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgZSA9ICgoKHMgPSB0aGlzLmZpbHRlci5raW5kcykgPT0gbnVsbCA/IHZvaWQgMCA6IHMubGVuZ3RoKSB8fCAwKSA+IDAsIHIgPSAhdGhpcy5maWx0ZXIuc2luY2UgJiYgIXRoaXMuZmlsdGVyLnVudGlsLCBuID0gIXRoaXMuZmlsdGVyLmxpbWl0O1xuICAgIGlmIChlICYmIHIgJiYgbikge1xuICAgICAgbGV0IG8gPSB0aGlzLmZpbHRlci5raW5kcy5qb2luKFwiLFwiKTtcbiAgICAgIGNvbnN0IGEgPSBPYmplY3Qua2V5cyh0aGlzLmZpbHRlciB8fCB7fSkuc29ydCgpLmpvaW4oXCItXCIpO1xuICAgICAgcmV0dXJuIG8gKz0gYC0ke2F9YCwgbztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgc2hvdWxkUXVlcnlDYWNoZSgpIHtcbiAgICB2YXIgZTtcbiAgICByZXR1cm4gKChlID0gdGhpcy5vcHRzKSA9PSBudWxsID8gdm9pZCAwIDogZS5jYWNoZVVzYWdlKSAhPT0gXCJPTkxZX1JFTEFZXCI7XG4gIH1cbiAgc2hvdWxkUXVlcnlSZWxheXMoKSB7XG4gICAgdmFyIGU7XG4gICAgcmV0dXJuICgoZSA9IHRoaXMub3B0cykgPT0gbnVsbCA/IHZvaWQgMCA6IGUuY2FjaGVVc2FnZSkgIT09IFwiT05MWV9DQUNIRVwiO1xuICB9XG4gIHNob3VsZFdhaXRGb3JDYWNoZSgpIHtcbiAgICB2YXIgZTtcbiAgICByZXR1cm4gdGhpcy5vcHRzLmNsb3NlT25Fb3NlICYmICEhKChlID0gdGhpcy5uZGsuY2FjaGVBZGFwdGVyKSAhPSBudWxsICYmIGUubG9ja2luZykgJiYgdGhpcy5zaG91bGRRdWVyeVJlbGF5cygpICYmIHRoaXMub3B0cy5jYWNoZVVzYWdlICE9PSBcIlBBUkFMTEVMXCI7XG4gIH1cbiAgYXN5bmMgc3RhcnQoKSB7XG4gICAgbGV0IGU7XG4gICAgaWYgKHRoaXMuc2hvdWxkUXVlcnlDYWNoZSgpICYmIChlID0gdGhpcy5zdGFydFdpdGhDYWNoZSgpLCB0aGlzLnNob3VsZFdhaXRGb3JDYWNoZSgpICYmIChhd2FpdCBlLCBJZCh0aGlzKSkpKSB7XG4gICAgICB0aGlzLmRlYnVnKFwiY2FjaGUgaGl0LCBmdWxseSBmaWxsZWQ6IHNraXBwaW5nIHJlbGF5IHF1ZXJ5XCIpLCB0aGlzLmVtaXQoXCJlb3NlXCIsIHRoaXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNob3VsZFF1ZXJ5UmVsYXlzKCkgJiYgdGhpcy5zdGFydFdpdGhSZWxheVNldCgpO1xuICB9XG4gIHN0b3AoKSB7XG4gICAgdGhpcy5yZWxheVN1YnNjcmlwdGlvbnMuZm9yRWFjaCgoZSkgPT4gZS51bnN1YigpKSwgdGhpcy5yZWxheVN1YnNjcmlwdGlvbnMuY2xlYXIoKSwgdGhpcy5lbWl0KFwiY2xvc2VcIiwgdGhpcyk7XG4gIH1cbiAgYXN5bmMgc3RhcnRXaXRoQ2FjaGUoKSB7XG4gICAgdmFyIGU7XG4gICAgaWYgKChlID0gdGhpcy5uZGsuY2FjaGVBZGFwdGVyKSAhPSBudWxsICYmIGUucXVlcnkpIHtcbiAgICAgIGNvbnN0IHIgPSB0aGlzLm5kay5jYWNoZUFkYXB0ZXIucXVlcnkodGhpcyk7XG4gICAgICB0aGlzLm5kay5jYWNoZUFkYXB0ZXIubG9ja2luZyAmJiBhd2FpdCByO1xuICAgIH1cbiAgfVxuICBzdGFydFdpdGhSZWxheVNldCgpIHtcbiAgICB0aGlzLnJlbGF5U2V0IHx8ICh0aGlzLnJlbGF5U2V0ID0gVWQodGhpcy5uZGssIHRoaXMuZmlsdGVyKSksIHRoaXMucmVsYXlTZXQgJiYgdGhpcy5yZWxheVNldC5zdWJzY3JpYmUodGhpcyk7XG4gIH1cbiAgZXZlbnRSZWNlaXZlZChlLCByLCBuID0gITEpIHtcbiAgICBpZiAoIW4gJiYgcikge1xuICAgICAgbGV0IGkgPSB0aGlzLmV2ZW50c1BlclJlbGF5LmdldChyKTtcbiAgICAgIGlmIChpIHx8IChpID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSwgdGhpcy5ldmVudHNQZXJSZWxheS5zZXQociwgaSkpLCBpLmFkZChlLmlkKSwgdGhpcy5ldmVudEZpcnN0U2Vlbi5oYXMoZS5pZCkpIHtcbiAgICAgICAgY29uc3QgbyA9IERhdGUubm93KCkgLSAodGhpcy5ldmVudEZpcnN0U2Vlbi5nZXQoZS5pZCkgfHwgMCk7XG4gICAgICAgIHIuc2NvcmVTbG93ZXJFdmVudChvKSwgdGhpcy5lbWl0KFwiZXZlbnQ6ZHVwXCIsIGUsIHIsIG8sIHRoaXMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLm5kay5jYWNoZUFkYXB0ZXIgJiYgdGhpcy5uZGsuY2FjaGVBZGFwdGVyLnNldEV2ZW50KGUsIHRoaXMuZmlsdGVyKSwgdGhpcy5ldmVudEZpcnN0U2Vlbi5zZXQoYCR7ZS5pZH1gLCBEYXRlLm5vdygpKTtcbiAgICB9IGVsc2VcbiAgICAgIHRoaXMuZXZlbnRGaXJzdFNlZW4uc2V0KGAke2UuaWR9YCwgMCk7XG4gICAgdGhpcy5lbWl0KFwiZXZlbnRcIiwgZSwgciwgdGhpcyk7XG4gIH1cbiAgZW9zZVJlY2VpdmVkKGUpIHtcbiAgICB2YXIgbiwgaSwgcztcbiAgICAobiA9IHRoaXMub3B0cykgIT0gbnVsbCAmJiBuLmNsb3NlT25Fb3NlICYmICgoaSA9IHRoaXMucmVsYXlTdWJzY3JpcHRpb25zLmdldChlKSkgPT0gbnVsbCB8fCBpLnVuc3ViKCksIHRoaXMucmVsYXlTdWJzY3JpcHRpb25zLmRlbGV0ZShlKSwgdGhpcy5yZWxheVN1YnNjcmlwdGlvbnMuc2l6ZSA9PT0gMCAmJiB0aGlzLmVtaXQoXCJjbG9zZVwiLCB0aGlzKSksIHRoaXMuZW9zZXNTZWVuLmFkZChlKSwgdGhpcy5lb3Nlc1NlZW4uc2l6ZSA9PT0gKChzID0gdGhpcy5yZWxheVNldCkgPT0gbnVsbCA/IHZvaWQgMCA6IHMuc2l6ZSgpKSA/IHRoaXMuZW1pdChcImVvc2VcIikgOiAodGhpcy5lb3NlVGltZW91dCAmJiBjbGVhclRpbWVvdXQodGhpcy5lb3NlVGltZW91dCksIHRoaXMuZW9zZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuZW1pdChcImVvc2VcIik7XG4gICAgfSwgNTAwKSk7XG4gIH1cbn0sIEJkID0gY2xhc3MgZXh0ZW5kcyBQYSB7XG4gIGNvbnN0cnVjdG9yKGUsIHIpIHtcbiAgICBjb25zdCBuID0gZS5kZWJ1Zy5leHRlbmQoXCJzdWJzY3JpcHRpb24tZ3JvdXBcIiksIGkgPSBMZChyLm1hcCgocykgPT4gcy5maWx0ZXIpKTtcbiAgICBzdXBlcihcbiAgICAgIGUsXG4gICAgICBpLFxuICAgICAgclswXS5vcHRzLFxuICAgICAgclswXS5yZWxheVNldFxuICAgICk7XG4gICAgSSh0aGlzLCBcInN1YnNjcmlwdGlvbnNcIik7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zID0gciwgbihcIm1lcmdlZCBmaWx0ZXJzXCIsIHtcbiAgICAgIGNvdW50OiByLmxlbmd0aCxcbiAgICAgIG1lcmdlZEZpbHRlcnM6IHRoaXMuZmlsdGVyXG4gICAgfSksIHRoaXMub24oXCJldmVudFwiLCB0aGlzLmZvcndhcmRFdmVudCksIHRoaXMub24oXCJldmVudDpkdXBcIiwgdGhpcy5mb3J3YXJkRXZlbnREdXApLCB0aGlzLm9uKFwiZW9zZVwiLCB0aGlzLmZvcndhcmRFb3NlKSwgdGhpcy5vbihcImNsb3NlXCIsIHRoaXMuZm9yd2FyZENsb3NlKTtcbiAgfVxuICBpc0V2ZW50Rm9yU3Vic2NyaXB0aW9uKGUsIHIpIHtcbiAgICBjb25zdCB7IGZpbHRlcjogbiB9ID0gcjtcbiAgICByZXR1cm4gbiA/IHlhKG4sIGUucmF3RXZlbnQoKSkgOiAhMTtcbiAgfVxuICBmb3J3YXJkRXZlbnQoZSwgcikge1xuICAgIGZvciAoY29uc3QgbiBvZiB0aGlzLnN1YnNjcmlwdGlvbnMpXG4gICAgICAhdGhpcy5pc0V2ZW50Rm9yU3Vic2NyaXB0aW9uKGUsIG4pIHx8IG4uZW1pdChcImV2ZW50XCIsIGUsIHIsIG4pO1xuICB9XG4gIGZvcndhcmRFdmVudER1cChlLCByLCBuKSB7XG4gICAgZm9yIChjb25zdCBpIG9mIHRoaXMuc3Vic2NyaXB0aW9ucylcbiAgICAgICF0aGlzLmlzRXZlbnRGb3JTdWJzY3JpcHRpb24oZSwgaSkgfHwgaS5lbWl0KFwiZXZlbnQ6ZHVwXCIsIGUsIHIsIG4sIGkpO1xuICB9XG4gIGZvcndhcmRFb3NlKCkge1xuICAgIGZvciAoY29uc3QgZSBvZiB0aGlzLnN1YnNjcmlwdGlvbnMpXG4gICAgICBlLmVtaXQoXCJlb3NlXCIsIGUpO1xuICB9XG4gIGZvcndhcmRDbG9zZSgpIHtcbiAgICBmb3IgKGNvbnN0IGUgb2YgdGhpcy5zdWJzY3JpcHRpb25zKVxuICAgICAgZS5lbWl0KFwiY2xvc2VcIiwgZSk7XG4gIH1cbn07XG5mdW5jdGlvbiBMZCh0KSB7XG4gIGNvbnN0IGUgPSB7fTtcbiAgcmV0dXJuIHQuZm9yRWFjaCgocikgPT4ge1xuICAgIE9iamVjdC5lbnRyaWVzKHIpLmZvckVhY2goKFtuLCBpXSkgPT4ge1xuICAgICAgQXJyYXkuaXNBcnJheShpKSA/IGVbbl0gPT09IHZvaWQgMCA/IGVbbl0gPSBbLi4uaV0gOiBlW25dID0gQXJyYXkuZnJvbSgvKiBAX19QVVJFX18gKi8gbmV3IFNldChbLi4uZVtuXSwgLi4uaV0pKSA6IGVbbl0gPSBpO1xuICAgIH0pO1xuICB9KSwgZTtcbn1cbmZ1bmN0aW9uICRkKHQpIHtcbiAgbGV0IGU7XG4gIHRyeSB7XG4gICAgc3dpdGNoIChlID0gd2UuZGVjb2RlKHQpLCBlLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJuZXZlbnRcIjpcbiAgICAgICAgcmV0dXJuIHsgaWRzOiBbZS5kYXRhLmlkXSB9O1xuICAgICAgY2FzZSBcIm5vdGVcIjpcbiAgICAgICAgcmV0dXJuIHsgaWRzOiBbZS5kYXRhXSB9O1xuICAgICAgY2FzZSBcIm5hZGRyXCI6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYXV0aG9yczogW2UuZGF0YS5wdWJrZXldLFxuICAgICAgICAgIFwiI2RcIjogW2UuZGF0YS5pZGVudGlmaWVyXSxcbiAgICAgICAgICBraW5kczogW2UuZGF0YS5raW5kXVxuICAgICAgICB9O1xuICAgIH1cbiAgfSBjYXRjaCB7XG4gIH1cbiAgcmV0dXJuIHsgaWRzOiBbdF0gfTtcbn1cbmZ1bmN0aW9uIHFkKHQpIHtcbiAgY29uc3QgZSA9IE9iamVjdC5rZXlzKHQpIHx8IFtdLCByID0gW107XG4gIGZvciAoY29uc3QgbiBvZiBlKVxuICAgIGlmIChuID09PSBcImtpbmRzXCIpIHtcbiAgICAgIGNvbnN0IGkgPSBbbiwgdC5raW5kcy5qb2luKFwiLFwiKV07XG4gICAgICByLnB1c2goaS5qb2luKFwiOlwiKSk7XG4gICAgfSBlbHNlXG4gICAgICByLnB1c2gobik7XG4gIHJldHVybiByLnB1c2goTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogOTk5OTk5OTk5KS50b1N0cmluZygpKSwgci5qb2luKFwiLVwiKTtcbn1cbnZhciBHciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IodCwgZSkge1xuICAgIEkodGhpcywgXCJyZWxheXNcIik7XG4gICAgSSh0aGlzLCBcImRlYnVnXCIpO1xuICAgIEkodGhpcywgXCJuZGtcIik7XG4gICAgdGhpcy5yZWxheXMgPSB0LCB0aGlzLm5kayA9IGUsIHRoaXMuZGVidWcgPSBlLmRlYnVnLmV4dGVuZChcInJlbGF5c2V0XCIpO1xuICB9XG4gIHN0YXRpYyBmcm9tUmVsYXlVcmxzKHQsIGUpIHtcbiAgICBjb25zdCByID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBmb3IgKGNvbnN0IG4gb2YgdCkge1xuICAgICAgY29uc3QgaSA9IGUucG9vbC5yZWxheXMuZ2V0KG4pO1xuICAgICAgaSAmJiByLmFkZChpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBHcihuZXcgU2V0KHIpLCBlKTtcbiAgfVxuICBzdWJzY3JpYmVPblJlbGF5KHQsIGUpIHtcbiAgICBjb25zdCByID0gdC5zdWJzY3JpYmUoZSk7XG4gICAgZS5yZWxheVN1YnNjcmlwdGlvbnMuc2V0KHQsIHIpO1xuICB9XG4gIGdldElkKCkge1xuICAgIGNvbnN0IGUgPSBBcnJheS5mcm9tKHRoaXMucmVsYXlzKS5tYXAoKHIpID0+IHIudXJsKS5zb3J0KCkuam9pbihcIixcIik7XG4gICAgcmV0dXJuIG5pKGpyKGUpKTtcbiAgfVxuICBzdWJzY3JpYmUodCkge1xuICAgIGNvbnN0IGUgPSB0Lmdyb3VwYWJsZUlkKCksIHIgPSBgJHt0aGlzLmdldElkKCl9OiR7ZX1gO1xuICAgIGlmICghZSlcbiAgICAgIHJldHVybiB0aGlzLmV4ZWN1dGVTdWJzY3JpcHRpb24odCksIHQ7XG4gICAgY29uc3QgbiA9IHRoaXMubmRrLmRlbGF5ZWRTdWJzY3JpcHRpb25zLmdldChyKTtcbiAgICByZXR1cm4gbiA/IG4ucHVzaCh0KSA6IChzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuZXhlY3V0ZURlbGF5ZWRTdWJzY3JpcHRpb24ocik7XG4gICAgfSwgdC5vcHRzLmdyb3VwYWJsZURlbGF5KSwgdGhpcy5uZGsuZGVsYXllZFN1YnNjcmlwdGlvbnMuc2V0KHIsIFt0XSkpLCB0O1xuICB9XG4gIGV4ZWN1dGVEZWxheWVkU3Vic2NyaXB0aW9uKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5uZGsuZGVsYXllZFN1YnNjcmlwdGlvbnMuZ2V0KHQpO1xuICAgIHRoaXMubmRrLmRlbGF5ZWRTdWJzY3JpcHRpb25zLmRlbGV0ZSh0KSwgZSAmJiAoZS5sZW5ndGggPiAxID8gdGhpcy5leGVjdXRlU3Vic2NyaXB0aW9ucyhlKSA6IHRoaXMuZXhlY3V0ZVN1YnNjcmlwdGlvbihlWzBdKSk7XG4gIH1cbiAgZXhlY3V0ZVN1YnNjcmlwdGlvbnModCkge1xuICAgIGNvbnN0IGUgPSB0WzBdLm5kaywgciA9IG5ldyBCZChlLCB0KTtcbiAgICB0aGlzLmV4ZWN1dGVTdWJzY3JpcHRpb24ocik7XG4gIH1cbiAgZXhlY3V0ZVN1YnNjcmlwdGlvbih0KSB7XG4gICAgdGhpcy5kZWJ1ZyhcInN1YnNjcmliaW5nXCIsIHsgZmlsdGVyOiB0LmZpbHRlciB9KTtcbiAgICBmb3IgKGNvbnN0IGUgb2YgdGhpcy5yZWxheXMpXG4gICAgICBpZiAoZS5zdGF0dXMgPT09IDEpXG4gICAgICAgIHRoaXMuc3Vic2NyaWJlT25SZWxheShlLCB0KTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBjb25zdCByID0gKCkgPT4ge1xuICAgICAgICAgIHRoaXMuZGVidWcoXCJuZXcgcmVsYXkgY29taW5nIG9ubGluZSBmb3IgYWN0aXZlIHN1YnNjcmlwdGlvblwiLCB7XG4gICAgICAgICAgICByZWxheTogZS51cmwsXG4gICAgICAgICAgICBmaWx0ZXI6IHQuZmlsdGVyXG4gICAgICAgICAgfSksIHRoaXMuc3Vic2NyaWJlT25SZWxheShlLCB0KTtcbiAgICAgICAgfTtcbiAgICAgICAgZS5vbmNlKFwiY29ubmVjdFwiLCByKSwgdC5vbmNlKFwiY2xvc2VcIiwgKCkgPT4ge1xuICAgICAgICAgIGUucmVtb3ZlTGlzdGVuZXIoXCJjb25uZWN0XCIsIHIpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICByZXR1cm4gdDtcbiAgfVxuICBhc3luYyBwdWJsaXNoKHQsIGUpIHtcbiAgICBjb25zdCByID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSwgbiA9IEFycmF5LmZyb20odGhpcy5yZWxheXMpLm1hcCgoaSkgPT4gbmV3IFByb21pc2UoKHMpID0+IHtcbiAgICAgIGkucHVibGlzaCh0LCBlKS50aGVuKCgpID0+IHtcbiAgICAgICAgci5hZGQoaSksIHMoKTtcbiAgICAgIH0pLmNhdGNoKChvKSA9PiB7XG4gICAgICAgIHRoaXMuZGVidWcoXCJlcnJvciBwdWJsaXNoaW5nIHRvIHJlbGF5XCIsIHsgcmVsYXk6IGkudXJsLCBlcnI6IG8gfSksIHMoKTtcbiAgICAgIH0pO1xuICAgIH0pKTtcbiAgICBpZiAoYXdhaXQgUHJvbWlzZS5hbGwobiksIHIuc2l6ZSA9PT0gMClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHJlbGF5IHdhcyBhYmxlIHRvIHJlY2VpdmUgdGhlIGV2ZW50XCIpO1xuICAgIHJldHVybiByO1xuICB9XG4gIHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVsYXlzLnNpemU7XG4gIH1cbn07XG5mdW5jdGlvbiBOZCh0LCBlKSB7XG4gIHZhciBuO1xuICBjb25zdCByID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgcmV0dXJuIChuID0gdC5wb29sKSA9PSBudWxsIHx8IG4ucmVsYXlzLmZvckVhY2goKGkpID0+IHIuYWRkKGkpKSwgbmV3IEdyKHIsIHQpO1xufVxuZnVuY3Rpb24gVWQodCwgZSkge1xuICB2YXIgbjtcbiAgY29uc3QgciA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIHJldHVybiAobiA9IHQucG9vbCkgPT0gbnVsbCB8fCBuLnJlbGF5cy5mb3JFYWNoKChpKSA9PiB7XG4gICAgaS5jb21wbGFpbmluZyA/IHQuZGVidWcoYFJlbGF5ICR7aS51cmx9IGlzIGNvbXBsYWluaW5nLCBub3QgYWRkaW5nIHRvIHNldGApIDogci5hZGQoaSk7XG4gIH0pLCBuZXcgR3IociwgdCk7XG59XG52YXIgamQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIEkodGhpcywgXCJfdXNlclByb21pc2VcIik7XG4gICAgSSh0aGlzLCBcIm5pcDA0UXVldWVcIiwgW10pO1xuICAgIEkodGhpcywgXCJuaXAwNFByb2Nlc3NpbmdcIiwgITEpO1xuICAgIEkodGhpcywgXCJkZWJ1Z1wiKTtcbiAgICBpZiAoIXdpbmRvdy5ub3N0cilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5JUC0wNyBleHRlbnNpb24gbm90IGF2YWlsYWJsZVwiKTtcbiAgICB0aGlzLmRlYnVnID0gTW4oXCJuZGs6bmlwMDdcIik7XG4gIH1cbiAgYXN5bmMgYmxvY2tVbnRpbFJlYWR5KCkge1xuICAgIHZhciBlO1xuICAgIGNvbnN0IHQgPSBhd2FpdCAoKGUgPSB3aW5kb3cubm9zdHIpID09IG51bGwgPyB2b2lkIDAgOiBlLmdldFB1YmxpY0tleSgpKTtcbiAgICBpZiAoIXQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVc2VyIHJlamVjdGVkIGFjY2Vzc1wiKTtcbiAgICByZXR1cm4gbmV3IHBlKHsgaGV4cHVia2V5OiB0IH0pO1xuICB9XG4gIGFzeW5jIHVzZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VzZXJQcm9taXNlIHx8ICh0aGlzLl91c2VyUHJvbWlzZSA9IHRoaXMuYmxvY2tVbnRpbFJlYWR5KCkpLCB0aGlzLl91c2VyUHJvbWlzZTtcbiAgfVxuICBhc3luYyBzaWduKHQpIHtcbiAgICBpZiAoIXdpbmRvdy5ub3N0cilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5JUC0wNyBleHRlbnNpb24gbm90IGF2YWlsYWJsZVwiKTtcbiAgICByZXR1cm4gKGF3YWl0IHdpbmRvdy5ub3N0ci5zaWduRXZlbnQodCkpLnNpZztcbiAgfVxuICBhc3luYyBlbmNyeXB0KHQsIGUpIHtcbiAgICBpZiAoIXdpbmRvdy5ub3N0cilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5JUC0wNyBleHRlbnNpb24gbm90IGF2YWlsYWJsZVwiKTtcbiAgICBjb25zdCByID0gdC5oZXhwdWJrZXkoKTtcbiAgICByZXR1cm4gdGhpcy5xdWV1ZU5pcDA0KFwiZW5jcnlwdFwiLCByLCBlKTtcbiAgfVxuICBhc3luYyBkZWNyeXB0KHQsIGUpIHtcbiAgICBpZiAoIXdpbmRvdy5ub3N0cilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5JUC0wNyBleHRlbnNpb24gbm90IGF2YWlsYWJsZVwiKTtcbiAgICBjb25zdCByID0gdC5oZXhwdWJrZXkoKTtcbiAgICByZXR1cm4gdGhpcy5xdWV1ZU5pcDA0KFwiZGVjcnlwdFwiLCByLCBlKTtcbiAgfVxuICBhc3luYyBxdWV1ZU5pcDA0KHQsIGUsIHIpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKG4sIGkpID0+IHtcbiAgICAgIHRoaXMubmlwMDRRdWV1ZS5wdXNoKHsgdHlwZTogdCwgY291bnRlcnBhcnR5SGV4cHVia2V5OiBlLCB2YWx1ZTogciwgcmVzb2x2ZTogbiwgcmVqZWN0OiBpIH0pLCB0aGlzLm5pcDA0UHJvY2Vzc2luZyB8fCB0aGlzLnByb2Nlc3NOaXAwNFF1ZXVlKCk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgcHJvY2Vzc05pcDA0UXVldWUodCwgZSA9IDApIHtcbiAgICBpZiAoIXQgJiYgdGhpcy5uaXAwNFF1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5uaXAwNFByb2Nlc3NpbmcgPSAhMTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5uaXAwNFByb2Nlc3NpbmcgPSAhMDtcbiAgICBjb25zdCB7IHR5cGU6IHIsIGNvdW50ZXJwYXJ0eUhleHB1YmtleTogbiwgdmFsdWU6IGksIHJlc29sdmU6IHMsIHJlamVjdDogbyB9ID0gdCB8fCB0aGlzLm5pcDA0UXVldWUuc2hpZnQoKTtcbiAgICB0aGlzLmRlYnVnKFwiUHJvY2Vzc2luZyBlbmNyeXB0aW9uIHF1ZXVlIGl0ZW1cIiwgeyB0eXBlOiByLCBjb3VudGVycGFydHlIZXhwdWJrZXk6IG4sIHZhbHVlOiBpIH0pO1xuICAgIHRyeSB7XG4gICAgICBsZXQgYTtcbiAgICAgIHIgPT09IFwiZW5jcnlwdFwiID8gYSA9IGF3YWl0IHdpbmRvdy5ub3N0ci5uaXAwNC5lbmNyeXB0KG4sIGkpIDogYSA9IGF3YWl0IHdpbmRvdy5ub3N0ci5uaXAwNC5kZWNyeXB0KG4sIGkpLCBzKGEpO1xuICAgIH0gY2F0Y2ggKGEpIHtcbiAgICAgIGlmIChhLm1lc3NhZ2UgJiYgYS5tZXNzYWdlLmluY2x1ZGVzKFwiY2FsbCBhbHJlYWR5IGV4ZWN1dGluZ1wiKSAmJiBlIDwgNSkge1xuICAgICAgICB0aGlzLmRlYnVnKFwiUmV0cnlpbmcgZW5jcnlwdGlvbiBxdWV1ZSBpdGVtXCIsIHsgdHlwZTogciwgY291bnRlcnBhcnR5SGV4cHVia2V5OiBuLCB2YWx1ZTogaSwgcmV0cmllczogZSB9KSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5wcm9jZXNzTmlwMDRRdWV1ZSh0LCBlICsgMSk7XG4gICAgICAgIH0sIDUwICogZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG8oYSk7XG4gICAgfVxuICAgIHRoaXMucHJvY2Vzc05pcDA0UXVldWUoKTtcbiAgfVxufSwgSGQgPSBjbGFzcyBleHRlbmRzIGR0IHtcbiAgY29uc3RydWN0b3IoZSwgciwgbikge1xuICAgIHN1cGVyKCk7XG4gICAgSSh0aGlzLCBcIm5ka1wiKTtcbiAgICBJKHRoaXMsIFwic2lnbmVyXCIpO1xuICAgIEkodGhpcywgXCJkZWJ1Z1wiKTtcbiAgICB0aGlzLm5kayA9IGUsIHRoaXMuc2lnbmVyID0gciwgdGhpcy5kZWJ1ZyA9IG4uZXh0ZW5kKFwicnBjXCIpO1xuICB9XG4gIGFzeW5jIHN1YnNjcmliZShlKSB7XG4gICAgY29uc3QgciA9IHRoaXMubmRrLnN1YnNjcmliZShlLCB7IGNsb3NlT25Fb3NlOiAhMSB9KTtcbiAgICByZXR1cm4gci5vbihcImV2ZW50XCIsIGFzeW5jIChuKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBpID0gYXdhaXQgdGhpcy5wYXJzZUV2ZW50KG4pO1xuICAgICAgICBpLm1ldGhvZCA/IHRoaXMuZW1pdChcInJlcXVlc3RcIiwgaSkgOiB0aGlzLmVtaXQoYHJlc3BvbnNlLSR7aS5pZH1gLCBpKTtcbiAgICAgIH0gY2F0Y2ggKGkpIHtcbiAgICAgICAgdGhpcy5kZWJ1ZyhcImVycm9yIHBhcnNpbmcgZXZlbnRcIiwgaSwgbik7XG4gICAgICB9XG4gICAgfSksIG5ldyBQcm9taXNlKChuLCBpKSA9PiB7XG4gICAgICByLm9uKFwiZW9zZVwiLCAoKSA9PiBuKHIpKTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBwYXJzZUV2ZW50KGUpIHtcbiAgICBjb25zdCByID0gdGhpcy5uZGsuZ2V0VXNlcih7IGhleHB1YmtleTogZS5wdWJrZXkgfSk7XG4gICAgci5uZGsgPSB0aGlzLm5kaztcbiAgICBjb25zdCBuID0gYXdhaXQgdGhpcy5zaWduZXIuZGVjcnlwdChyLCBlLmNvbnRlbnQpLCBpID0gSlNPTi5wYXJzZShuKSwgeyBpZDogcywgbWV0aG9kOiBvLCBwYXJhbXM6IGEsIHJlc3VsdDogYywgZXJyb3I6IGwgfSA9IGk7XG4gICAgcmV0dXJuIG8gPyB7IGlkOiBzLCBwdWJrZXk6IGUucHVia2V5LCBtZXRob2Q6IG8sIHBhcmFtczogYSwgZXZlbnQ6IGUgfSA6IHsgaWQ6IHMsIHJlc3VsdDogYywgZXJyb3I6IGwsIGV2ZW50OiBlIH07XG4gIH1cbiAgYXN5bmMgc2VuZFJlc3BvbnNlKGUsIHIsIG4sIGkgPSAyNDEzMywgcykge1xuICAgIGNvbnN0IG8gPSB7IGlkOiBlLCByZXN1bHQ6IG4gfTtcbiAgICBzICYmIChvLmVycm9yID0gcyk7XG4gICAgY29uc3QgYSA9IGF3YWl0IHRoaXMuc2lnbmVyLnVzZXIoKSwgYyA9IHRoaXMubmRrLmdldFVzZXIoeyBoZXhwdWJrZXk6IHIgfSksIGwgPSBuZXcgcWUodGhpcy5uZGssIHtcbiAgICAgIGtpbmQ6IGksXG4gICAgICBjb250ZW50OiBKU09OLnN0cmluZ2lmeShvKSxcbiAgICAgIHRhZ3M6IFtbXCJwXCIsIHJdXSxcbiAgICAgIHB1YmtleTogYS5oZXhwdWJrZXkoKVxuICAgIH0pO1xuICAgIGwuY29udGVudCA9IGF3YWl0IHRoaXMuc2lnbmVyLmVuY3J5cHQoYywgbC5jb250ZW50KSwgYXdhaXQgbC5zaWduKHRoaXMuc2lnbmVyKSwgYXdhaXQgdGhpcy5uZGsucHVibGlzaChsKTtcbiAgfVxuICBhc3luYyBzZW5kUmVxdWVzdChlLCByLCBuID0gW10sIGkgPSAyNDEzMywgcykge1xuICAgIGNvbnN0IG8gPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoNyksIGEgPSBhd2FpdCB0aGlzLnNpZ25lci51c2VyKCksIGMgPSB0aGlzLm5kay5nZXRVc2VyKHsgaGV4cHVia2V5OiBlIH0pLCBsID0geyBpZDogbywgbWV0aG9kOiByLCBwYXJhbXM6IG4gfSwgZiA9IG5ldyBQcm9taXNlKChoKSA9PiB7XG4gICAgICBzICYmIHRoaXMub25jZShgcmVzcG9uc2UtJHtvfWAsIHMpO1xuICAgIH0pLCB1ID0gbmV3IHFlKHRoaXMubmRrLCB7XG4gICAgICBraW5kOiBpLFxuICAgICAgY29udGVudDogSlNPTi5zdHJpbmdpZnkobCksXG4gICAgICB0YWdzOiBbW1wicFwiLCBlXV0sXG4gICAgICBwdWJrZXk6IGEuaGV4cHVia2V5KClcbiAgICB9KTtcbiAgICByZXR1cm4gdS5jb250ZW50ID0gYXdhaXQgdGhpcy5zaWduZXIuZW5jcnlwdChjLCB1LmNvbnRlbnQpLCBhd2FpdCB1LnNpZ24odGhpcy5zaWduZXIpLCB0aGlzLmRlYnVnKFwic2VuZGluZyByZXF1ZXN0IHRvXCIsIGUpLCBhd2FpdCB0aGlzLm5kay5wdWJsaXNoKHUpLCBmO1xuICB9XG59LCBNZCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IodCwgZSwgcikge1xuICAgIEkodGhpcywgXCJuZGtcIik7XG4gICAgSSh0aGlzLCBcInJlbW90ZVVzZXJcIik7XG4gICAgSSh0aGlzLCBcInJlbW90ZVB1YmtleVwiKTtcbiAgICBJKHRoaXMsIFwidG9rZW5cIik7XG4gICAgSSh0aGlzLCBcImxvY2FsU2lnbmVyXCIpO1xuICAgIEkodGhpcywgXCJycGNcIik7XG4gICAgSSh0aGlzLCBcImRlYnVnXCIpO1xuICAgIGxldCBuLCBpO1xuICAgIGlmIChlLmluY2x1ZGVzKFwiI1wiKSkge1xuICAgICAgY29uc3QgcyA9IGUuc3BsaXQoXCIjXCIpO1xuICAgICAgbiA9IG5ldyBwZSh7IG5wdWI6IHNbMF0gfSkuaGV4cHVia2V5KCksIGkgPSBzWzFdO1xuICAgIH0gZWxzZVxuICAgICAgZS5zdGFydHNXaXRoKFwibnB1YlwiKSA/IG4gPSBuZXcgcGUoeyBucHViOiBlIH0pLmhleHB1YmtleSgpIDogbiA9IGU7XG4gICAgdGhpcy5uZGsgPSB0LCB0aGlzLnJlbW90ZVB1YmtleSA9IG4sIHRoaXMudG9rZW4gPSBpLCB0aGlzLmRlYnVnID0gdC5kZWJ1Zy5leHRlbmQoXCJuaXA0NjpzaWduZXJcIiksIHRoaXMucmVtb3RlVXNlciA9IG5ldyBwZSh7IGhleHB1YmtleTogbiB9KSwgciA/IHRoaXMubG9jYWxTaWduZXIgPSByIDogdGhpcy5sb2NhbFNpZ25lciA9IG9yLmdlbmVyYXRlKCksIHRoaXMucnBjID0gbmV3IEhkKHQsIHRoaXMubG9jYWxTaWduZXIsIHRoaXMuZGVidWcpO1xuICB9XG4gIGFzeW5jIHVzZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVtb3RlVXNlcjtcbiAgfVxuICBhc3luYyBibG9ja1VudGlsUmVhZHkoKSB7XG4gICAgY29uc3QgdCA9IGF3YWl0IHRoaXMubG9jYWxTaWduZXIudXNlcigpLCBlID0gdGhpcy5uZGsuZ2V0VXNlcih7IG5wdWI6IHQubnB1YiB9KTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5ycGMuc3Vic2NyaWJlKHtcbiAgICAgIGtpbmRzOiBbMjQxMzNdLFxuICAgICAgXCIjcFwiOiBbdC5oZXhwdWJrZXkoKV1cbiAgICB9KSwgbmV3IFByb21pc2UoKHIsIG4pID0+IHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjb25zdCBpID0gW3QuaGV4cHVia2V5KCldO1xuICAgICAgICB0aGlzLnRva2VuICYmIGkucHVzaCh0aGlzLnRva2VuKSwgdGhpcy5ycGMuc2VuZFJlcXVlc3QoXG4gICAgICAgICAgdGhpcy5yZW1vdGVQdWJrZXksXG4gICAgICAgICAgXCJjb25uZWN0XCIsXG4gICAgICAgICAgaSxcbiAgICAgICAgICAyNDEzMyxcbiAgICAgICAgICAocykgPT4ge1xuICAgICAgICAgICAgcy5yZXN1bHQgPT09IFwiYWNrXCIgPyByKGUpIDogbihzLmVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICB9LCAxMDApO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGVuY3J5cHQodCwgZSkge1xuICAgIHJldHVybiB0aGlzLmRlYnVnKFwiYXNraW5nIGZvciBlbmNyeXB0aW9uXCIpLCBuZXcgUHJvbWlzZSgobiwgaSkgPT4ge1xuICAgICAgdGhpcy5ycGMuc2VuZFJlcXVlc3QoXG4gICAgICAgIHRoaXMucmVtb3RlUHVia2V5LFxuICAgICAgICBcIm5pcDA0X2VuY3J5cHRcIixcbiAgICAgICAgW3QuaGV4cHVia2V5KCksIGVdLFxuICAgICAgICAyNDEzMyxcbiAgICAgICAgKHMpID0+IHtcbiAgICAgICAgICBzLmVycm9yID8gaShzLmVycm9yKSA6IG4ocy5yZXN1bHQpO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGRlY3J5cHQodCwgZSkge1xuICAgIHJldHVybiB0aGlzLmRlYnVnKFwiYXNraW5nIGZvciBkZWNyeXB0aW9uXCIpLCBuZXcgUHJvbWlzZSgobiwgaSkgPT4ge1xuICAgICAgdGhpcy5ycGMuc2VuZFJlcXVlc3QoXG4gICAgICAgIHRoaXMucmVtb3RlUHVia2V5LFxuICAgICAgICBcIm5pcDA0X2RlY3J5cHRcIixcbiAgICAgICAgW3QuaGV4cHVia2V5KCksIGVdLFxuICAgICAgICAyNDEzMyxcbiAgICAgICAgKHMpID0+IHtcbiAgICAgICAgICBpZiAocy5lcnJvcilcbiAgICAgICAgICAgIGkocy5lcnJvcik7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBvID0gSlNPTi5wYXJzZShzLnJlc3VsdCk7XG4gICAgICAgICAgICBuKG9bMF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBzaWduKHQpIHtcbiAgICByZXR1cm4gdGhpcy5kZWJ1ZyhcImFza2luZyBmb3IgYSBzaWduYXR1cmVcIiksIG5ldyBQcm9taXNlKChyLCBuKSA9PiB7XG4gICAgICB0aGlzLnJwYy5zZW5kUmVxdWVzdChcbiAgICAgICAgdGhpcy5yZW1vdGVQdWJrZXksXG4gICAgICAgIFwic2lnbl9ldmVudFwiLFxuICAgICAgICBbSlNPTi5zdHJpbmdpZnkodCldLFxuICAgICAgICAyNDEzMyxcbiAgICAgICAgKGkpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5kZWJ1ZyhcImdvdCBhIHJlc3BvbnNlXCIsIGkpLCBpLmVycm9yKVxuICAgICAgICAgICAgbihpLmVycm9yKTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHMgPSBKU09OLnBhcnNlKGkucmVzdWx0KTtcbiAgICAgICAgICAgIHIocy5zaWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxufSwgb3IgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHQpIHtcbiAgICBJKHRoaXMsIFwiX3VzZXJcIik7XG4gICAgSSh0aGlzLCBcInByaXZhdGVLZXlcIik7XG4gICAgdCAmJiAodGhpcy5wcml2YXRlS2V5ID0gdCwgdGhpcy5fdXNlciA9IG5ldyBwZSh7IGhleHB1YmtleTogbGkodGhpcy5wcml2YXRlS2V5KSB9KSk7XG4gIH1cbiAgc3RhdGljIGdlbmVyYXRlKCkge1xuICAgIGNvbnN0IHQgPSB5ZigpO1xuICAgIHJldHVybiBuZXcgb3IodCk7XG4gIH1cbiAgYXN5bmMgYmxvY2tVbnRpbFJlYWR5KCkge1xuICAgIGlmICghdGhpcy5fdXNlcilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5ES1VzZXIgbm90IGluaXRpYWxpemVkXCIpO1xuICAgIHJldHVybiB0aGlzLl91c2VyO1xuICB9XG4gIGFzeW5jIHVzZXIoKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuYmxvY2tVbnRpbFJlYWR5KCksIHRoaXMuX3VzZXI7XG4gIH1cbiAgYXN5bmMgc2lnbih0KSB7XG4gICAgaWYgKCF0aGlzLnByaXZhdGVLZXkpXG4gICAgICB0aHJvdyBFcnJvcihcIkF0dGVtcHRlZCB0byBzaWduIHdpdGhvdXQgYSBwcml2YXRlIGtleVwiKTtcbiAgICByZXR1cm4gcGEodCwgdGhpcy5wcml2YXRlS2V5KTtcbiAgfVxuICBhc3luYyBlbmNyeXB0KHQsIGUpIHtcbiAgICBpZiAoIXRoaXMucHJpdmF0ZUtleSlcbiAgICAgIHRocm93IEVycm9yKFwiQXR0ZW1wdGVkIHRvIGVuY3J5cHQgd2l0aG91dCBhIHByaXZhdGUga2V5XCIpO1xuICAgIGNvbnN0IHIgPSB0LmhleHB1YmtleSgpO1xuICAgIHJldHVybiBhd2FpdCBVbi5lbmNyeXB0KHRoaXMucHJpdmF0ZUtleSwgciwgZSk7XG4gIH1cbiAgYXN5bmMgZGVjcnlwdCh0LCBlKSB7XG4gICAgaWYgKCF0aGlzLnByaXZhdGVLZXkpXG4gICAgICB0aHJvdyBFcnJvcihcIkF0dGVtcHRlZCB0byBkZWNyeXB0IHdpdGhvdXQgYSBwcml2YXRlIGtleVwiKTtcbiAgICBjb25zdCByID0gdC5oZXhwdWJrZXkoKTtcbiAgICByZXR1cm4gYXdhaXQgVW4uZGVjcnlwdCh0aGlzLnByaXZhdGVLZXksIHIsIGUpO1xuICB9XG59LCBEZCA9IGNsYXNzIGV4dGVuZHMgZHQge1xuICBjb25zdHJ1Y3RvcihlID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIEkodGhpcywgXCJwb29sXCIpO1xuICAgIEkodGhpcywgXCJzaWduZXJcIik7XG4gICAgSSh0aGlzLCBcImNhY2hlQWRhcHRlclwiKTtcbiAgICBJKHRoaXMsIFwiZGVidWdcIik7XG4gICAgSSh0aGlzLCBcImRldldyaXRlUmVsYXlTZXRcIik7XG4gICAgSSh0aGlzLCBcImRlbGF5ZWRTdWJzY3JpcHRpb25zXCIpO1xuICAgIHRoaXMuZGVidWcgPSBlLmRlYnVnIHx8IE1uKFwibmRrXCIpLCB0aGlzLnBvb2wgPSBuZXcgQ2QoZS5leHBsaWNpdFJlbGF5VXJscyB8fCBbXSwgdGhpcyksIHRoaXMuc2lnbmVyID0gZS5zaWduZXIsIHRoaXMuY2FjaGVBZGFwdGVyID0gZS5jYWNoZUFkYXB0ZXIsIHRoaXMuZGVsYXllZFN1YnNjcmlwdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCBlLmRldldyaXRlUmVsYXlVcmxzICYmICh0aGlzLmRldldyaXRlUmVsYXlTZXQgPSBHci5mcm9tUmVsYXlVcmxzKGUuZGV2V3JpdGVSZWxheVVybHMsIHRoaXMpKTtcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHsgcmVsYXlDb3VudDogdGhpcy5wb29sLnJlbGF5cy5zaXplIH0udG9TdHJpbmcoKTtcbiAgfVxuICBhc3luYyBjb25uZWN0KGUpIHtcbiAgICByZXR1cm4gdGhpcy5kZWJ1ZyhcIkNvbm5lY3RpbmcgdG8gcmVsYXlzXCIsIHsgdGltZW91dE1zOiBlIH0pLCB0aGlzLnBvb2wuY29ubmVjdChlKTtcbiAgfVxuICBnZXRVc2VyKGUpIHtcbiAgICBjb25zdCByID0gbmV3IHBlKGUpO1xuICAgIHJldHVybiByLm5kayA9IHRoaXMsIHI7XG4gIH1cbiAgc3Vic2NyaWJlKGUsIHIsIG4sIGkgPSAhMCkge1xuICAgIGNvbnN0IHMgPSBuZXcgUGEodGhpcywgZSwgciwgbik7XG4gICAgcmV0dXJuIGkgJiYgcy5zdGFydCgpLCBzO1xuICB9XG4gIGFzeW5jIHB1Ymxpc2goZSwgciwgbikge1xuICAgIHJldHVybiByIHx8IChyID0gdGhpcy5kZXZXcml0ZVJlbGF5U2V0IHx8IE5kKHRoaXMpKSwgci5wdWJsaXNoKGUsIG4pO1xuICB9XG4gIGFzeW5jIGZldGNoRXZlbnQoZSwgciA9IHt9LCBuKSB7XG4gICAgbGV0IGk7XG4gICAgaWYgKHR5cGVvZiBlID09IFwic3RyaW5nXCIgPyBpID0gJGQoZSkgOiBpID0gZSwgIWkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZmlsdGVyOiAke0pTT04uc3RyaW5naWZ5KGUpfWApO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocykgPT4ge1xuICAgICAgY29uc3QgbyA9IHRoaXMuc3Vic2NyaWJlKGksIHsgLi4uciwgY2xvc2VPbkVvc2U6ICEwIH0sIG4sICExKTtcbiAgICAgIG8ub24oXCJldmVudFwiLCAoYSkgPT4ge1xuICAgICAgICBhLm5kayA9IHRoaXMsIHMoYSk7XG4gICAgICB9KSwgby5vbihcImVvc2VcIiwgKCkgPT4ge1xuICAgICAgICBzKG51bGwpO1xuICAgICAgfSksIG8uc3RhcnQoKTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBmZXRjaEV2ZW50cyhlLCByID0ge30sIG4pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKGkpID0+IHtcbiAgICAgIGNvbnN0IHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCBvID0gdGhpcy5zdWJzY3JpYmUoZSwgeyAuLi5yLCBjbG9zZU9uRW9zZTogITAgfSwgbiwgITEpO1xuICAgICAgby5vbihcImV2ZW50XCIsIChhKSA9PiB7XG4gICAgICAgIGNvbnN0IGMgPSBzLmdldChhLnRhZ0lkKCkpO1xuICAgICAgICBjICYmIChhID0gcGQoYywgYSkpLCBhLm5kayA9IHRoaXMsIHMuc2V0KGEudGFnSWQoKSwgYSk7XG4gICAgICB9KSwgby5vbihcImVvc2VcIiwgKCkgPT4ge1xuICAgICAgICBpKG5ldyBTZXQocy52YWx1ZXMoKSkpO1xuICAgICAgfSksIG8uc3RhcnQoKTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBhc3NlcnRTaWduZXIoKSB7XG4gICAgaWYgKCF0aGlzLnNpZ25lcilcbiAgICAgIHRocm93IHRoaXMuZW1pdChcInNpZ25lclJlcXVpcmVkXCIpLCBuZXcgRXJyb3IoXCJTaWduZXIgcmVxdWlyZWRcIik7XG4gIH1cbn07XG5mdW5jdGlvbiB6ZCh0KSB7XG4gIGNvbnN0IGUgPSBHbyghMSksIFtyLCBuXSA9IFNuKHZvaWQgMCksIFtpLCBzXSA9IFNuKHZvaWQgMCk7XG4gIHVjKCgpID0+IHtcbiAgICBhc3luYyBmdW5jdGlvbiBmKCkge1xuICAgICAgciA9PT0gdm9pZCAwICYmIGUuY3VycmVudCA9PT0gITEgJiYgKGUuY3VycmVudCA9ICEwLCBhd2FpdCBvKHQpKTtcbiAgICB9XG4gICAgZigpO1xuICB9LCBbXSk7XG4gIGFzeW5jIGZ1bmN0aW9uIG8oZiwgdSkge1xuICAgIGNvbnN0IGggPSBuZXcgRGQoeyBleHBsaWNpdFJlbGF5VXJsczogZiwgc2lnbmVyOiB1IH0pO1xuICAgIHUgJiYgcyh1KTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgaC5jb25uZWN0KCksIG4oaCk7XG4gICAgfSBjYXRjaCAoZCkge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVSUk9SIGxvYWRpbmcgTkRLIE5ES0luc3RhbmNlXCIsIGQpO1xuICAgIH1cbiAgfVxuICBhc3luYyBmdW5jdGlvbiBhKGYpIHtcbiAgICBvKHQsIGYpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGMoZikge1xuICAgIHJldHVybiByID09PSB2b2lkIDAgPyBbXSA6IG5ldyBQcm9taXNlKCh1KSA9PiB7XG4gICAgICBjb25zdCBoID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgZCA9IHIuc3Vic2NyaWJlKGYsIHtcbiAgICAgICAgY2xvc2VPbkVvc2U6ICEwXG4gICAgICB9KTtcbiAgICAgIGQub24oXCJldmVudFwiLCAocCkgPT4ge1xuICAgICAgICBwLm5kayA9IHIsIGguc2V0KHAudGFnSWQoKSwgcCk7XG4gICAgICB9KSwgZC5vbihcImVvc2VcIiwgKCkgPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHUoQXJyYXkuZnJvbShuZXcgU2V0KGgudmFsdWVzKCkpKSksIDNlMyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBsKGYsIHUgPSB7XG4gICAgcmVwb3N0OiAhMSxcbiAgICBwdWJsaXNoOiAhMFxuICB9KSB7XG4gICAgaWYgKHIgIT09IHZvaWQgMClcbiAgICAgIHJldHVybiBmLm5kayA9IHIsIHUucmVwb3N0ID8gYXdhaXQgZi5yZXBvc3QoKSA6IGF3YWl0IGYuc2lnbigpLCB1LnB1Ymxpc2ggJiYgYXdhaXQgZi5wdWJsaXNoKCksIGY7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuZGs6IHIsXG4gICAgc2lnbmVyOiBpLFxuICAgIGxvYWROZGs6IG8sXG4gICAgc2V0U2lnbmVyOiBhLFxuICAgIGZldGNoRXZlbnRzOiBjLFxuICAgIHNpZ25QdWJsaXNoRXZlbnQ6IGxcbiAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIEZkKHQpIHtcbiAgdHJ5IHtcbiAgICBsZXQgZSA9IHQ7XG4gICAgZS5zdWJzdHJpbmcoMCwgNCkgPT09IFwibnNlY1wiICYmIChlID0gd2UuZGVjb2RlKGUpLmRhdGEpO1xuICAgIGNvbnN0IHIgPSBuZXcgb3IoZSk7XG4gICAgcmV0dXJuIHIudXNlcigpLnRoZW4oYXN5bmMgKG4pID0+IHtcbiAgICAgIGlmIChuLm5wdWIpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdXNlcjogbixcbiAgICAgICAgICBucHViOiBuLm5wdWIsXG4gICAgICAgICAgc2s6IGUsXG4gICAgICAgICAgc2lnbmVyOiByXG4gICAgICAgIH07XG4gICAgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBlO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBLZCh0LCBlLCByKSB7XG4gIHRyeSB7XG4gICAgbGV0IG4gPSBvci5nZW5lcmF0ZSgpO1xuICAgIHIgJiYgKG4gPSBuZXcgb3IocikpO1xuICAgIGNvbnN0IGkgPSBuZXcgTWQodCwgZSwgbik7XG4gICAgcmV0dXJuIGkudXNlcigpLnRoZW4oYXN5bmMgKHMpID0+IHtcbiAgICAgIGlmIChzLm5wdWIpXG4gICAgICAgIHJldHVybiBhd2FpdCBpLmJsb2NrVW50aWxSZWFkeSgpLCB7XG4gICAgICAgICAgdXNlcjogcyxcbiAgICAgICAgICBucHViOiAoYXdhaXQgaS51c2VyKCkpLm5wdWIsXG4gICAgICAgICAgc2s6IG4ucHJpdmF0ZUtleSxcbiAgICAgICAgICB0b2tlbjogZSxcbiAgICAgICAgICByZW1vdGVTaWduZXI6IGksXG4gICAgICAgICAgbG9jYWxTaWduZXI6IG5cbiAgICAgICAgfTtcbiAgICB9KTtcbiAgfSBjYXRjaCAobikge1xuICAgIHRocm93IG47XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIFdkKCkge1xuICB0cnkge1xuICAgIGNvbnN0IHQgPSBuZXcgamQoKTtcbiAgICByZXR1cm4gdC51c2VyKCkudGhlbihhc3luYyAoZSkgPT4ge1xuICAgICAgaWYgKGUubnB1YilcbiAgICAgICAgcmV0dXJuIHsgdXNlcjogZSwgbnB1YjogZS5ucHViLCBzaWduZXI6IHQgfTtcbiAgICB9KTtcbiAgfSBjYXRjaCAodCkge1xuICAgIHRocm93IHQ7XG4gIH1cbn1cbmNvbnN0IFZkID0gKHQpID0+IHtcbiAgY29uc3QgW2UsIHJdID0gU24oe30pLCBuID0gR28oe30pO1xuICBhc3luYyBmdW5jdGlvbiBpKGEpIHtcbiAgICBpZiAodCA9PSBudWxsIHx8IG4uY3VycmVudFthXSlcbiAgICAgIHJldHVybjtcbiAgICBuLmN1cnJlbnQgPSB7XG4gICAgICAuLi5uLmN1cnJlbnQsXG4gICAgICBbYV06IHBlLnByb3RvdHlwZVxuICAgIH07XG4gICAgbGV0IGM7XG4gICAgYS5zdGFydHNXaXRoKFwibnB1YlwiKSA/IGMgPSB0LmdldFVzZXIoe1xuICAgICAgbnB1YjogYVxuICAgIH0pIDogYyA9IHQuZ2V0VXNlcih7XG4gICAgICBoZXhwdWJrZXk6IGFcbiAgICB9KSwgYXdhaXQgYy5mZXRjaFByb2ZpbGUoKSwgYy5wcm9maWxlICYmIChuLmN1cnJlbnQgPSB7XG4gICAgICAuLi5uLmN1cnJlbnQsXG4gICAgICBbYV06IGNcbiAgICB9LCByKG4uY3VycmVudCkpO1xuICB9XG4gIGZ1bmN0aW9uIHMoYSkge1xuICAgIHJldHVybiBlW2FdID8gZVthXSA6IChpKGEpLCBwZS5wcm90b3R5cGUpO1xuICB9XG4gIGZ1bmN0aW9uIG8oYSkge1xuICAgIHJldHVybiBlW2FdID8gZVthXS5wcm9maWxlIDogKGkoYSksIHt9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGdldFVzZXI6IHMsXG4gICAgZ2V0UHJvZmlsZTogb1xuICB9O1xufTtcbnZhciBCYSA9IHsgZXhwb3J0czoge30gfSwgWHQgPSB7fTtcbi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbnZhciBNbztcbmZ1bmN0aW9uIEdkKCkge1xuICBpZiAoTW8pXG4gICAgcmV0dXJuIFh0O1xuICBNbyA9IDE7XG4gIHZhciB0ID0gVm8sIGUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZWxlbWVudFwiKSwgciA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSwgbiA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksIGkgPSB0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVELlJlYWN0Q3VycmVudE93bmVyLCBzID0geyBrZXk6ICEwLCByZWY6ICEwLCBfX3NlbGY6ICEwLCBfX3NvdXJjZTogITAgfTtcbiAgZnVuY3Rpb24gbyhhLCBjLCBsKSB7XG4gICAgdmFyIGYsIHUgPSB7fSwgaCA9IG51bGwsIGQgPSBudWxsO1xuICAgIGwgIT09IHZvaWQgMCAmJiAoaCA9IFwiXCIgKyBsKSwgYy5rZXkgIT09IHZvaWQgMCAmJiAoaCA9IFwiXCIgKyBjLmtleSksIGMucmVmICE9PSB2b2lkIDAgJiYgKGQgPSBjLnJlZik7XG4gICAgZm9yIChmIGluIGMpXG4gICAgICBuLmNhbGwoYywgZikgJiYgIXMuaGFzT3duUHJvcGVydHkoZikgJiYgKHVbZl0gPSBjW2ZdKTtcbiAgICBpZiAoYSAmJiBhLmRlZmF1bHRQcm9wcylcbiAgICAgIGZvciAoZiBpbiBjID0gYS5kZWZhdWx0UHJvcHMsIGMpXG4gICAgICAgIHVbZl0gPT09IHZvaWQgMCAmJiAodVtmXSA9IGNbZl0pO1xuICAgIHJldHVybiB7ICQkdHlwZW9mOiBlLCB0eXBlOiBhLCBrZXk6IGgsIHJlZjogZCwgcHJvcHM6IHUsIF9vd25lcjogaS5jdXJyZW50IH07XG4gIH1cbiAgcmV0dXJuIFh0LkZyYWdtZW50ID0gciwgWHQuanN4ID0gbywgWHQuanN4cyA9IG8sIFh0O1xufVxudmFyIFF0ID0ge307XG4vKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG52YXIgRG87XG5mdW5jdGlvbiBaZCgpIHtcbiAgcmV0dXJuIERvIHx8IChEbyA9IDEsIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdCA9IFZvLCBlID0gU3ltYm9sLmZvcihcInJlYWN0LmVsZW1lbnRcIiksIHIgPSBTeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpLCBuID0gU3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpLCBpID0gU3ltYm9sLmZvcihcInJlYWN0LnN0cmljdF9tb2RlXCIpLCBzID0gU3ltYm9sLmZvcihcInJlYWN0LnByb2ZpbGVyXCIpLCBvID0gU3ltYm9sLmZvcihcInJlYWN0LnByb3ZpZGVyXCIpLCBhID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnRleHRcIiksIGMgPSBTeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIiksIGwgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIiksIGYgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VfbGlzdFwiKSwgdSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vXCIpLCBoID0gU3ltYm9sLmZvcihcInJlYWN0LmxhenlcIiksIGQgPSBTeW1ib2wuZm9yKFwicmVhY3Qub2Zmc2NyZWVuXCIpLCBwID0gU3ltYm9sLml0ZXJhdG9yLCB5ID0gXCJAQGl0ZXJhdG9yXCI7XG4gICAgZnVuY3Rpb24gZyhiKSB7XG4gICAgICBpZiAoYiA9PT0gbnVsbCB8fCB0eXBlb2YgYiAhPSBcIm9iamVjdFwiKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBrID0gcCAmJiBiW3BdIHx8IGJbeV07XG4gICAgICByZXR1cm4gdHlwZW9mIGsgPT0gXCJmdW5jdGlvblwiID8gayA6IG51bGw7XG4gICAgfVxuICAgIHZhciB2ID0gdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcbiAgICBmdW5jdGlvbiBfKGIpIHtcbiAgICAgIHtcbiAgICAgICAgZm9yICh2YXIgayA9IGFyZ3VtZW50cy5sZW5ndGgsIFQgPSBuZXcgQXJyYXkoayA+IDEgPyBrIC0gMSA6IDApLCAkID0gMTsgJCA8IGs7ICQrKylcbiAgICAgICAgICBUWyQgLSAxXSA9IGFyZ3VtZW50c1skXTtcbiAgICAgICAgbShcImVycm9yXCIsIGIsIFQpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBtKGIsIGssIFQpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyICQgPSB2LlJlYWN0RGVidWdDdXJyZW50RnJhbWUsIE0gPSAkLmdldFN0YWNrQWRkZW5kdW0oKTtcbiAgICAgICAgTSAhPT0gXCJcIiAmJiAoayArPSBcIiVzXCIsIFQgPSBULmNvbmNhdChbTV0pKTtcbiAgICAgICAgdmFyIEsgPSBULm1hcChmdW5jdGlvbihqKSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyhqKTtcbiAgICAgICAgfSk7XG4gICAgICAgIEsudW5zaGlmdChcIldhcm5pbmc6IFwiICsgayksIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbYl0sIGNvbnNvbGUsIEspO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgQyA9ICExLCBPID0gITEsIHcgPSAhMSwgeCA9ICExLCBBID0gITEsIEI7XG4gICAgQiA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tb2R1bGUucmVmZXJlbmNlXCIpO1xuICAgIGZ1bmN0aW9uIEwoYikge1xuICAgICAgcmV0dXJuICEhKHR5cGVvZiBiID09IFwic3RyaW5nXCIgfHwgdHlwZW9mIGIgPT0gXCJmdW5jdGlvblwiIHx8IGIgPT09IG4gfHwgYiA9PT0gcyB8fCBBIHx8IGIgPT09IGkgfHwgYiA9PT0gbCB8fCBiID09PSBmIHx8IHggfHwgYiA9PT0gZCB8fCBDIHx8IE8gfHwgdyB8fCB0eXBlb2YgYiA9PSBcIm9iamVjdFwiICYmIGIgIT09IG51bGwgJiYgKGIuJCR0eXBlb2YgPT09IGggfHwgYi4kJHR5cGVvZiA9PT0gdSB8fCBiLiQkdHlwZW9mID09PSBvIHx8IGIuJCR0eXBlb2YgPT09IGEgfHwgYi4kJHR5cGVvZiA9PT0gYyB8fCBiLiQkdHlwZW9mID09PSBCIHx8IGIuZ2V0TW9kdWxlSWQgIT09IHZvaWQgMCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBQKGIsIGssIFQpIHtcbiAgICAgIHZhciAkID0gYi5kaXNwbGF5TmFtZTtcbiAgICAgIGlmICgkKVxuICAgICAgICByZXR1cm4gJDtcbiAgICAgIHZhciBNID0gay5kaXNwbGF5TmFtZSB8fCBrLm5hbWUgfHwgXCJcIjtcbiAgICAgIHJldHVybiBNICE9PSBcIlwiID8gVCArIFwiKFwiICsgTSArIFwiKVwiIDogVDtcbiAgICB9XG4gICAgZnVuY3Rpb24gRihiKSB7XG4gICAgICByZXR1cm4gYi5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24geihiKSB7XG4gICAgICBpZiAoYiA9PSBudWxsKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGlmICh0eXBlb2YgYi50YWcgPT0gXCJudW1iZXJcIiAmJiBfKFwiUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiksIHR5cGVvZiBiID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgcmV0dXJuIGIuZGlzcGxheU5hbWUgfHwgYi5uYW1lIHx8IG51bGw7XG4gICAgICBpZiAodHlwZW9mIGIgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgICBzd2l0Y2ggKGIpIHtcbiAgICAgICAgY2FzZSBuOlxuICAgICAgICAgIHJldHVybiBcIkZyYWdtZW50XCI7XG4gICAgICAgIGNhc2UgcjpcbiAgICAgICAgICByZXR1cm4gXCJQb3J0YWxcIjtcbiAgICAgICAgY2FzZSBzOlxuICAgICAgICAgIHJldHVybiBcIlByb2ZpbGVyXCI7XG4gICAgICAgIGNhc2UgaTpcbiAgICAgICAgICByZXR1cm4gXCJTdHJpY3RNb2RlXCI7XG4gICAgICAgIGNhc2UgbDpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZVwiO1xuICAgICAgICBjYXNlIGY6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VMaXN0XCI7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGIgPT0gXCJvYmplY3RcIilcbiAgICAgICAgc3dpdGNoIChiLiQkdHlwZW9mKSB7XG4gICAgICAgICAgY2FzZSBhOlxuICAgICAgICAgICAgdmFyIGsgPSBiO1xuICAgICAgICAgICAgcmV0dXJuIEYoaykgKyBcIi5Db25zdW1lclwiO1xuICAgICAgICAgIGNhc2UgbzpcbiAgICAgICAgICAgIHZhciBUID0gYjtcbiAgICAgICAgICAgIHJldHVybiBGKFQuX2NvbnRleHQpICsgXCIuUHJvdmlkZXJcIjtcbiAgICAgICAgICBjYXNlIGM6XG4gICAgICAgICAgICByZXR1cm4gUChiLCBiLnJlbmRlciwgXCJGb3J3YXJkUmVmXCIpO1xuICAgICAgICAgIGNhc2UgdTpcbiAgICAgICAgICAgIHZhciAkID0gYi5kaXNwbGF5TmFtZSB8fCBudWxsO1xuICAgICAgICAgICAgcmV0dXJuICQgIT09IG51bGwgPyAkIDogeihiLnR5cGUpIHx8IFwiTWVtb1wiO1xuICAgICAgICAgIGNhc2UgaDoge1xuICAgICAgICAgICAgdmFyIE0gPSBiLCBLID0gTS5fcGF5bG9hZCwgaiA9IE0uX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4geihqKEspKTtcbiAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgRyA9IE9iamVjdC5hc3NpZ24sIEUgPSAwLCBSLCBxLCBILCBELCBYLCBvZSwgcmU7XG4gICAgZnVuY3Rpb24gX2UoKSB7XG4gICAgfVxuICAgIF9lLl9fcmVhY3REaXNhYmxlZExvZyA9ICEwO1xuICAgIGZ1bmN0aW9uIE9lKCkge1xuICAgICAge1xuICAgICAgICBpZiAoRSA9PT0gMCkge1xuICAgICAgICAgIFIgPSBjb25zb2xlLmxvZywgcSA9IGNvbnNvbGUuaW5mbywgSCA9IGNvbnNvbGUud2FybiwgRCA9IGNvbnNvbGUuZXJyb3IsIFggPSBjb25zb2xlLmdyb3VwLCBvZSA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQsIHJlID0gY29uc29sZS5ncm91cEVuZDtcbiAgICAgICAgICB2YXIgYiA9IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgIHZhbHVlOiBfZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiAhMFxuICAgICAgICAgIH07XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICAgICAgaW5mbzogYixcbiAgICAgICAgICAgIGxvZzogYixcbiAgICAgICAgICAgIHdhcm46IGIsXG4gICAgICAgICAgICBlcnJvcjogYixcbiAgICAgICAgICAgIGdyb3VwOiBiLFxuICAgICAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IGIsXG4gICAgICAgICAgICBncm91cEVuZDogYlxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIEUrKztcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gVWUoKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChFLS0sIEUgPT09IDApIHtcbiAgICAgICAgICB2YXIgYiA9IHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgICAgICAgIHdyaXRhYmxlOiAhMFxuICAgICAgICAgIH07XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICAgICAgbG9nOiBHKHt9LCBiLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBSXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGluZm86IEcoe30sIGIsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IHFcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgd2FybjogRyh7fSwgYiwge1xuICAgICAgICAgICAgICB2YWx1ZTogSFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBlcnJvcjogRyh7fSwgYiwge1xuICAgICAgICAgICAgICB2YWx1ZTogRFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBncm91cDogRyh7fSwgYiwge1xuICAgICAgICAgICAgICB2YWx1ZTogWFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBncm91cENvbGxhcHNlZDogRyh7fSwgYiwge1xuICAgICAgICAgICAgICB2YWx1ZTogb2VcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZ3JvdXBFbmQ6IEcoe30sIGIsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IHJlXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIEUgPCAwICYmIF8oXCJkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgUGUgPSB2LlJlYWN0Q3VycmVudERpc3BhdGNoZXIsIHllO1xuICAgIGZ1bmN0aW9uIGplKGIsIGssIFQpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKHllID09PSB2b2lkIDApXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfSBjYXRjaCAoTSkge1xuICAgICAgICAgICAgdmFyICQgPSBNLnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICAgICAgeWUgPSAkICYmICRbMV0gfHwgXCJcIjtcbiAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBgXG5gICsgeWUgKyBiO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgbWUgPSAhMSwgeGU7XG4gICAge1xuICAgICAgdmFyIGxyID0gdHlwZW9mIFdlYWtNYXAgPT0gXCJmdW5jdGlvblwiID8gV2Vha01hcCA6IE1hcDtcbiAgICAgIHhlID0gbmV3IGxyKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEJlKGIsIGspIHtcbiAgICAgIGlmICghYiB8fCBtZSlcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB7XG4gICAgICAgIHZhciBUID0geGUuZ2V0KGIpO1xuICAgICAgICBpZiAoVCAhPT0gdm9pZCAwKVxuICAgICAgICAgIHJldHVybiBUO1xuICAgICAgfVxuICAgICAgdmFyICQ7XG4gICAgICBtZSA9ICEwO1xuICAgICAgdmFyIE0gPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTtcbiAgICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdm9pZCAwO1xuICAgICAgdmFyIEs7XG4gICAgICBLID0gUGUuY3VycmVudCwgUGUuY3VycmVudCA9IG51bGwsIE9lKCk7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoaykge1xuICAgICAgICAgIHZhciBqID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eShqLnByb3RvdHlwZSwgXCJwcm9wc1wiLCB7XG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLCB0eXBlb2YgUmVmbGVjdCA9PSBcIm9iamVjdFwiICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChqLCBbXSk7XG4gICAgICAgICAgICB9IGNhdGNoIChMZSkge1xuICAgICAgICAgICAgICAkID0gTGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChiLCBbXSwgaik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGouY2FsbCgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoTGUpIHtcbiAgICAgICAgICAgICAgJCA9IExlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYi5jYWxsKGoucHJvdG90eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfSBjYXRjaCAoTGUpIHtcbiAgICAgICAgICAgICQgPSBMZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYigpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChMZSkge1xuICAgICAgICBpZiAoTGUgJiYgJCAmJiB0eXBlb2YgTGUuc3RhY2sgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGZvciAodmFyIFUgPSBMZS5zdGFjay5zcGxpdChgXG5gKSwgc2UgPSAkLnN0YWNrLnNwbGl0KGBcbmApLCBXID0gVS5sZW5ndGggLSAxLCBaID0gc2UubGVuZ3RoIC0gMTsgVyA+PSAxICYmIFogPj0gMCAmJiBVW1ddICE9PSBzZVtaXTsgKVxuICAgICAgICAgICAgWi0tO1xuICAgICAgICAgIGZvciAoOyBXID49IDEgJiYgWiA+PSAwOyBXLS0sIFotLSlcbiAgICAgICAgICAgIGlmIChVW1ddICE9PSBzZVtaXSkge1xuICAgICAgICAgICAgICBpZiAoVyAhPT0gMSB8fCBaICE9PSAxKVxuICAgICAgICAgICAgICAgIGRvXG4gICAgICAgICAgICAgICAgICBpZiAoVy0tLCBaLS0sIFogPCAwIHx8IFVbV10gIT09IHNlW1pdKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBnZSA9IGBcbmAgKyBVW1ddLnJlcGxhY2UoXCIgYXQgbmV3IFwiLCBcIiBhdCBcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiLmRpc3BsYXlOYW1lICYmIGdlLmluY2x1ZGVzKFwiPGFub255bW91cz5cIikgJiYgKGdlID0gZ2UucmVwbGFjZShcIjxhbm9ueW1vdXM+XCIsIGIuZGlzcGxheU5hbWUpKSwgdHlwZW9mIGIgPT0gXCJmdW5jdGlvblwiICYmIHhlLnNldChiLCBnZSksIGdlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChXID49IDEgJiYgWiA+PSAwKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIG1lID0gITEsIFBlLmN1cnJlbnQgPSBLLCBVZSgpLCBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IE07XG4gICAgICB9XG4gICAgICB2YXIgeXQgPSBiID8gYi5kaXNwbGF5TmFtZSB8fCBiLm5hbWUgOiBcIlwiLCAkaSA9IHl0ID8gamUoeXQpIDogXCJcIjtcbiAgICAgIHJldHVybiB0eXBlb2YgYiA9PSBcImZ1bmN0aW9uXCIgJiYgeGUuc2V0KGIsICRpKSwgJGk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZlKGIsIGssIFQpIHtcbiAgICAgIHJldHVybiBCZShiLCAhMSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEhlKGIpIHtcbiAgICAgIHZhciBrID0gYi5wcm90b3R5cGU7XG4gICAgICByZXR1cm4gISEoayAmJiBrLmlzUmVhY3RDb21wb25lbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpdChiLCBrLCBUKSB7XG4gICAgICBpZiAoYiA9PSBudWxsKVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIGlmICh0eXBlb2YgYiA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHJldHVybiBCZShiLCBIZShiKSk7XG4gICAgICBpZiAodHlwZW9mIGIgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmV0dXJuIGplKGIpO1xuICAgICAgc3dpdGNoIChiKSB7XG4gICAgICAgIGNhc2UgbDpcbiAgICAgICAgICByZXR1cm4gamUoXCJTdXNwZW5zZVwiKTtcbiAgICAgICAgY2FzZSBmOlxuICAgICAgICAgIHJldHVybiBqZShcIlN1c3BlbnNlTGlzdFwiKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgYiA9PSBcIm9iamVjdFwiKVxuICAgICAgICBzd2l0Y2ggKGIuJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIGM6XG4gICAgICAgICAgICByZXR1cm4gZmUoYi5yZW5kZXIpO1xuICAgICAgICAgIGNhc2UgdTpcbiAgICAgICAgICAgIHJldHVybiBpdChiLnR5cGUsIGssIFQpO1xuICAgICAgICAgIGNhc2UgaDoge1xuICAgICAgICAgICAgdmFyICQgPSBiLCBNID0gJC5fcGF5bG9hZCwgSyA9ICQuX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gaXQoSyhNKSwgaywgVCk7XG4gICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICB2YXIgb3QgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LCBFaSA9IHt9LCBraSA9IHYuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICBmdW5jdGlvbiBmcihiKSB7XG4gICAgICBpZiAoYikge1xuICAgICAgICB2YXIgayA9IGIuX293bmVyLCBUID0gaXQoYi50eXBlLCBiLl9zb3VyY2UsIGsgPyBrLnR5cGUgOiBudWxsKTtcbiAgICAgICAga2kuc2V0RXh0cmFTdGFja0ZyYW1lKFQpO1xuICAgICAgfSBlbHNlXG4gICAgICAgIGtpLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gTWEoYiwgaywgVCwgJCwgTSkge1xuICAgICAge1xuICAgICAgICB2YXIgSyA9IEZ1bmN0aW9uLmNhbGwuYmluZChvdCk7XG4gICAgICAgIGZvciAodmFyIGogaW4gYilcbiAgICAgICAgICBpZiAoSyhiLCBqKSkge1xuICAgICAgICAgICAgdmFyIFUgPSB2b2lkIDA7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGJbal0gIT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlID0gRXJyb3IoKCQgfHwgXCJSZWFjdCBjbGFzc1wiKSArIFwiOiBcIiArIFQgKyBcIiB0eXBlIGBcIiArIGogKyBcImAgaXMgaW52YWxpZDsgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYFwiICsgdHlwZW9mIGJbal0gKyBcImAuVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuXCIpO1xuICAgICAgICAgICAgICAgIHRocm93IHNlLm5hbWUgPSBcIkludmFyaWFudCBWaW9sYXRpb25cIiwgc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgVSA9IGJbal0oaywgaiwgJCwgVCwgbnVsbCwgXCJTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRFwiKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKFcpIHtcbiAgICAgICAgICAgICAgVSA9IFc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBVICYmICEoVSBpbnN0YW5jZW9mIEVycm9yKSAmJiAoZnIoTSksIF8oXCIlczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciBmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCBzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuXCIsICQgfHwgXCJSZWFjdCBjbGFzc1wiLCBULCBqLCB0eXBlb2YgVSksIGZyKG51bGwpKSwgVSBpbnN0YW5jZW9mIEVycm9yICYmICEoVS5tZXNzYWdlIGluIEVpKSAmJiAoRWlbVS5tZXNzYWdlXSA9ICEwLCBmcihNKSwgXyhcIkZhaWxlZCAlcyB0eXBlOiAlc1wiLCBULCBVLm1lc3NhZ2UpLCBmcihudWxsKSk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgRGEgPSBBcnJheS5pc0FycmF5O1xuICAgIGZ1bmN0aW9uIFpyKGIpIHtcbiAgICAgIHJldHVybiBEYShiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gemEoYikge1xuICAgICAge1xuICAgICAgICB2YXIgayA9IHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC50b1N0cmluZ1RhZywgVCA9IGsgJiYgYltTeW1ib2wudG9TdHJpbmdUYWddIHx8IGIuY29uc3RydWN0b3IubmFtZSB8fCBcIk9iamVjdFwiO1xuICAgICAgICByZXR1cm4gVDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gRmEoYikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIFNpKGIpLCAhMTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICByZXR1cm4gITA7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFNpKGIpIHtcbiAgICAgIHJldHVybiBcIlwiICsgYjtcbiAgICB9XG4gICAgZnVuY3Rpb24gT2koYikge1xuICAgICAgaWYgKEZhKGIpKVxuICAgICAgICByZXR1cm4gXyhcIlRoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4gVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIGJlZm9yZSB1c2luZyBpdCBoZXJlLlwiLCB6YShiKSksIFNpKGIpO1xuICAgIH1cbiAgICB2YXIgQ3QgPSB2LlJlYWN0Q3VycmVudE93bmVyLCBLYSA9IHtcbiAgICAgIGtleTogITAsXG4gICAgICByZWY6ICEwLFxuICAgICAgX19zZWxmOiAhMCxcbiAgICAgIF9fc291cmNlOiAhMFxuICAgIH0sIEFpLCBDaSwgWXI7XG4gICAgWXIgPSB7fTtcbiAgICBmdW5jdGlvbiBXYShiKSB7XG4gICAgICBpZiAob3QuY2FsbChiLCBcInJlZlwiKSkge1xuICAgICAgICB2YXIgayA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYiwgXCJyZWZcIikuZ2V0O1xuICAgICAgICBpZiAoayAmJiBrLmlzUmVhY3RXYXJuaW5nKVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiLnJlZiAhPT0gdm9pZCAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBWYShiKSB7XG4gICAgICBpZiAob3QuY2FsbChiLCBcImtleVwiKSkge1xuICAgICAgICB2YXIgayA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYiwgXCJrZXlcIikuZ2V0O1xuICAgICAgICBpZiAoayAmJiBrLmlzUmVhY3RXYXJuaW5nKVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiLmtleSAhPT0gdm9pZCAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBHYShiLCBrKSB7XG4gICAgICBpZiAodHlwZW9mIGIucmVmID09IFwic3RyaW5nXCIgJiYgQ3QuY3VycmVudCAmJiBrICYmIEN0LmN1cnJlbnQuc3RhdGVOb2RlICE9PSBrKSB7XG4gICAgICAgIHZhciBUID0geihDdC5jdXJyZW50LnR5cGUpO1xuICAgICAgICBZcltUXSB8fCAoXygnQ29tcG9uZW50IFwiJXNcIiBjb250YWlucyB0aGUgc3RyaW5nIHJlZiBcIiVzXCIuIFN1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiBXZSBhc2sgeW91IHRvIG1hbnVhbGx5IGZpeCB0aGlzIGNhc2UgYnkgdXNpbmcgdXNlUmVmKCkgb3IgY3JlYXRlUmVmKCkgaW5zdGVhZC4gTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIHooQ3QuY3VycmVudC50eXBlKSwgYi5yZWYpLCBZcltUXSA9ICEwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gWmEoYiwgaykge1xuICAgICAge1xuICAgICAgICB2YXIgVCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIEFpIHx8IChBaSA9ICEwLCBfKFwiJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSB2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50IHByb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcylcIiwgaykpO1xuICAgICAgICB9O1xuICAgICAgICBULmlzUmVhY3RXYXJuaW5nID0gITAsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiLCBcImtleVwiLCB7XG4gICAgICAgICAgZ2V0OiBULFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFlhKGIsIGspIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIFQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBDaSB8fCAoQ2kgPSAhMCwgXyhcIiVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgdmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCBwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpXCIsIGspKTtcbiAgICAgICAgfTtcbiAgICAgICAgVC5pc1JlYWN0V2FybmluZyA9ICEwLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoYiwgXCJyZWZcIiwge1xuICAgICAgICAgIGdldDogVCxcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgSmEgPSBmdW5jdGlvbihiLCBrLCBULCAkLCBNLCBLLCBqKSB7XG4gICAgICB2YXIgVSA9IHtcbiAgICAgICAgJCR0eXBlb2Y6IGUsXG4gICAgICAgIHR5cGU6IGIsXG4gICAgICAgIGtleTogayxcbiAgICAgICAgcmVmOiBULFxuICAgICAgICBwcm9wczogaixcbiAgICAgICAgX293bmVyOiBLXG4gICAgICB9O1xuICAgICAgcmV0dXJuIFUuX3N0b3JlID0ge30sIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShVLl9zdG9yZSwgXCJ2YWxpZGF0ZWRcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICB2YWx1ZTogITFcbiAgICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoVSwgXCJfc2VsZlwiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITEsXG4gICAgICAgIHZhbHVlOiAkXG4gICAgICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KFUsIFwiX3NvdXJjZVwiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITEsXG4gICAgICAgIHZhbHVlOiBNXG4gICAgICB9KSwgT2JqZWN0LmZyZWV6ZSAmJiAoT2JqZWN0LmZyZWV6ZShVLnByb3BzKSwgT2JqZWN0LmZyZWV6ZShVKSksIFU7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBYYShiLCBrLCBULCAkLCBNKSB7XG4gICAgICB7XG4gICAgICAgIHZhciBLLCBqID0ge30sIFUgPSBudWxsLCBzZSA9IG51bGw7XG4gICAgICAgIFQgIT09IHZvaWQgMCAmJiAoT2koVCksIFUgPSBcIlwiICsgVCksIFZhKGspICYmIChPaShrLmtleSksIFUgPSBcIlwiICsgay5rZXkpLCBXYShrKSAmJiAoc2UgPSBrLnJlZiwgR2EoaywgTSkpO1xuICAgICAgICBmb3IgKEsgaW4gaylcbiAgICAgICAgICBvdC5jYWxsKGssIEspICYmICFLYS5oYXNPd25Qcm9wZXJ0eShLKSAmJiAoaltLXSA9IGtbS10pO1xuICAgICAgICBpZiAoYiAmJiBiLmRlZmF1bHRQcm9wcykge1xuICAgICAgICAgIHZhciBXID0gYi5kZWZhdWx0UHJvcHM7XG4gICAgICAgICAgZm9yIChLIGluIFcpXG4gICAgICAgICAgICBqW0tdID09PSB2b2lkIDAgJiYgKGpbS10gPSBXW0tdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoVSB8fCBzZSkge1xuICAgICAgICAgIHZhciBaID0gdHlwZW9mIGIgPT0gXCJmdW5jdGlvblwiID8gYi5kaXNwbGF5TmFtZSB8fCBiLm5hbWUgfHwgXCJVbmtub3duXCIgOiBiO1xuICAgICAgICAgIFUgJiYgWmEoaiwgWiksIHNlICYmIFlhKGosIFopO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBKYShiLCBVLCBzZSwgTSwgJCwgQ3QuY3VycmVudCwgaik7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBKciA9IHYuUmVhY3RDdXJyZW50T3duZXIsIElpID0gdi5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIGZ1bmN0aW9uIHB0KGIpIHtcbiAgICAgIGlmIChiKSB7XG4gICAgICAgIHZhciBrID0gYi5fb3duZXIsIFQgPSBpdChiLnR5cGUsIGIuX3NvdXJjZSwgayA/IGsudHlwZSA6IG51bGwpO1xuICAgICAgICBJaS5zZXRFeHRyYVN0YWNrRnJhbWUoVCk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgSWkuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgICB2YXIgWHI7XG4gICAgWHIgPSAhMTtcbiAgICBmdW5jdGlvbiBRcihiKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIGIgPT0gXCJvYmplY3RcIiAmJiBiICE9PSBudWxsICYmIGIuJCR0eXBlb2YgPT09IGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJpKCkge1xuICAgICAge1xuICAgICAgICBpZiAoSnIuY3VycmVudCkge1xuICAgICAgICAgIHZhciBiID0geihKci5jdXJyZW50LnR5cGUpO1xuICAgICAgICAgIGlmIChiKVxuICAgICAgICAgICAgcmV0dXJuIGBcblxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgXFxgYCArIGIgKyBcImAuXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFFhKGIpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKGIgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHZhciBrID0gYi5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCBcIlwiKSwgVCA9IGIubGluZU51bWJlcjtcbiAgICAgICAgICByZXR1cm4gYFxuXG5DaGVjayB5b3VyIGNvZGUgYXQgYCArIGsgKyBcIjpcIiArIFQgKyBcIi5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIFRpID0ge307XG4gICAgZnVuY3Rpb24gZWMoYikge1xuICAgICAge1xuICAgICAgICB2YXIgayA9IFJpKCk7XG4gICAgICAgIGlmICghaykge1xuICAgICAgICAgIHZhciBUID0gdHlwZW9mIGIgPT0gXCJzdHJpbmdcIiA/IGIgOiBiLmRpc3BsYXlOYW1lIHx8IGIubmFtZTtcbiAgICAgICAgICBUICYmIChrID0gYFxuXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxgICsgVCArIFwiPi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGs7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFBpKGIsIGspIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKCFiLl9zdG9yZSB8fCBiLl9zdG9yZS52YWxpZGF0ZWQgfHwgYi5rZXkgIT0gbnVsbClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGIuX3N0b3JlLnZhbGlkYXRlZCA9ICEwO1xuICAgICAgICB2YXIgVCA9IGVjKGspO1xuICAgICAgICBpZiAoVGlbVF0pXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBUaVtUXSA9ICEwO1xuICAgICAgICB2YXIgJCA9IFwiXCI7XG4gICAgICAgIGIgJiYgYi5fb3duZXIgJiYgYi5fb3duZXIgIT09IEpyLmN1cnJlbnQgJiYgKCQgPSBcIiBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSBcIiArIHooYi5fb3duZXIudHlwZSkgKyBcIi5cIiksIHB0KGIpLCBfKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3dhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCBULCAkKSwgcHQobnVsbCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIEJpKGIsIGspIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9IFwib2JqZWN0XCIpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoWnIoYikpXG4gICAgICAgICAgZm9yICh2YXIgVCA9IDA7IFQgPCBiLmxlbmd0aDsgVCsrKSB7XG4gICAgICAgICAgICB2YXIgJCA9IGJbVF07XG4gICAgICAgICAgICBRcigkKSAmJiBQaSgkLCBrKTtcbiAgICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFFyKGIpKVxuICAgICAgICAgIGIuX3N0b3JlICYmIChiLl9zdG9yZS52YWxpZGF0ZWQgPSAhMCk7XG4gICAgICAgIGVsc2UgaWYgKGIpIHtcbiAgICAgICAgICB2YXIgTSA9IGcoYik7XG4gICAgICAgICAgaWYgKHR5cGVvZiBNID09IFwiZnVuY3Rpb25cIiAmJiBNICE9PSBiLmVudHJpZXMpXG4gICAgICAgICAgICBmb3IgKHZhciBLID0gTS5jYWxsKGIpLCBqOyAhKGogPSBLLm5leHQoKSkuZG9uZTsgKVxuICAgICAgICAgICAgICBRcihqLnZhbHVlKSAmJiBQaShqLnZhbHVlLCBrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0YyhiKSB7XG4gICAgICB7XG4gICAgICAgIHZhciBrID0gYi50eXBlO1xuICAgICAgICBpZiAoayA9PSBudWxsIHx8IHR5cGVvZiBrID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgVDtcbiAgICAgICAgaWYgKHR5cGVvZiBrID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICBUID0gay5wcm9wVHlwZXM7XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBrID09IFwib2JqZWN0XCIgJiYgKGsuJCR0eXBlb2YgPT09IGMgfHwgay4kJHR5cGVvZiA9PT0gdSkpXG4gICAgICAgICAgVCA9IGsucHJvcFR5cGVzO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoVCkge1xuICAgICAgICAgIHZhciAkID0geihrKTtcbiAgICAgICAgICBNYShULCBiLnByb3BzLCBcInByb3BcIiwgJCwgYik7XG4gICAgICAgIH0gZWxzZSBpZiAoay5Qcm9wVHlwZXMgIT09IHZvaWQgMCAmJiAhWHIpIHtcbiAgICAgICAgICBYciA9ICEwO1xuICAgICAgICAgIHZhciBNID0geihrKTtcbiAgICAgICAgICBfKFwiQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/XCIsIE0gfHwgXCJVbmtub3duXCIpO1xuICAgICAgICB9XG4gICAgICAgIHR5cGVvZiBrLmdldERlZmF1bHRQcm9wcyA9PSBcImZ1bmN0aW9uXCIgJiYgIWsuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkICYmIF8oXCJnZXREZWZhdWx0UHJvcHMgaXMgb25seSB1c2VkIG9uIGNsYXNzaWMgUmVhY3QuY3JlYXRlQ2xhc3MgZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLlwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmMoYikge1xuICAgICAge1xuICAgICAgICBmb3IgKHZhciBrID0gT2JqZWN0LmtleXMoYi5wcm9wcyksIFQgPSAwOyBUIDwgay5sZW5ndGg7IFQrKykge1xuICAgICAgICAgIHZhciAkID0ga1tUXTtcbiAgICAgICAgICBpZiAoJCAhPT0gXCJjaGlsZHJlblwiICYmICQgIT09IFwia2V5XCIpIHtcbiAgICAgICAgICAgIHB0KGIpLCBfKFwiSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gUmVhY3QuRnJhZ21lbnQgY2FuIG9ubHkgaGF2ZSBga2V5YCBhbmQgYGNoaWxkcmVuYCBwcm9wcy5cIiwgJCksIHB0KG51bGwpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGIucmVmICE9PSBudWxsICYmIChwdChiKSwgXyhcIkludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuXCIpLCBwdChudWxsKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIExpKGIsIGssIFQsICQsIE0sIEspIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIGogPSBMKGIpO1xuICAgICAgICBpZiAoIWopIHtcbiAgICAgICAgICB2YXIgVSA9IFwiXCI7XG4gICAgICAgICAgKGIgPT09IHZvaWQgMCB8fCB0eXBlb2YgYiA9PSBcIm9iamVjdFwiICYmIGIgIT09IG51bGwgJiYgT2JqZWN0LmtleXMoYikubGVuZ3RoID09PSAwKSAmJiAoVSArPSBcIiBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSBpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCIpO1xuICAgICAgICAgIHZhciBzZSA9IFFhKE0pO1xuICAgICAgICAgIHNlID8gVSArPSBzZSA6IFUgKz0gUmkoKTtcbiAgICAgICAgICB2YXIgVztcbiAgICAgICAgICBiID09PSBudWxsID8gVyA9IFwibnVsbFwiIDogWnIoYikgPyBXID0gXCJhcnJheVwiIDogYiAhPT0gdm9pZCAwICYmIGIuJCR0eXBlb2YgPT09IGUgPyAoVyA9IFwiPFwiICsgKHooYi50eXBlKSB8fCBcIlVua25vd25cIikgKyBcIiAvPlwiLCBVID0gXCIgRGlkIHlvdSBhY2NpZGVudGFsbHkgZXhwb3J0IGEgSlNYIGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNvbXBvbmVudD9cIikgOiBXID0gdHlwZW9mIGIsIF8oXCJSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yIGJ1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXNcIiwgVywgVSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIFogPSBYYShiLCBrLCBULCBNLCBLKTtcbiAgICAgICAgaWYgKFogPT0gbnVsbClcbiAgICAgICAgICByZXR1cm4gWjtcbiAgICAgICAgaWYgKGopIHtcbiAgICAgICAgICB2YXIgZ2UgPSBrLmNoaWxkcmVuO1xuICAgICAgICAgIGlmIChnZSAhPT0gdm9pZCAwKVxuICAgICAgICAgICAgaWYgKCQpXG4gICAgICAgICAgICAgIGlmIChacihnZSkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB5dCA9IDA7IHl0IDwgZ2UubGVuZ3RoOyB5dCsrKVxuICAgICAgICAgICAgICAgICAgQmkoZ2VbeXRdLCBiKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuZnJlZXplICYmIE9iamVjdC5mcmVlemUoZ2UpO1xuICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICBfKFwiUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiBVc2UgdGhlIEJhYmVsIHRyYW5zZm9ybSBpbnN0ZWFkLlwiKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgQmkoZ2UsIGIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiID09PSBuID8gcmMoWikgOiB0YyhaKSwgWjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbmMoYiwgaywgVCkge1xuICAgICAgcmV0dXJuIExpKGIsIGssIFQsICEwKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaWMoYiwgaywgVCkge1xuICAgICAgcmV0dXJuIExpKGIsIGssIFQsICExKTtcbiAgICB9XG4gICAgdmFyIG9jID0gaWMsIHNjID0gbmM7XG4gICAgUXQuRnJhZ21lbnQgPSBuLCBRdC5qc3ggPSBvYywgUXQuanN4cyA9IHNjO1xuICB9KCkpLCBRdDtcbn1cbihmdW5jdGlvbih0KSB7XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IHQuZXhwb3J0cyA9IEdkKCkgOiB0LmV4cG9ydHMgPSBaZCgpO1xufSkoQmEpO1xuY29uc3QgWWQgPSBCYS5leHBvcnRzLmpzeCwgTGEgPSBsYyh7XG4gIG5kazogdm9pZCAwLFxuICBzaWduZXI6IHZvaWQgMCxcbiAgZmV0Y2hFdmVudHM6ICh0KSA9PiBQcm9taXNlLnJlc29sdmUoW10pLFxuICBsb2dpbldpdGhOaXA0NjogKHQsIGUpID0+IFByb21pc2UucmVzb2x2ZSh2b2lkIDApLFxuICBsb2dpbldpdGhTZWNyZXQ6ICh0KSA9PiBQcm9taXNlLnJlc29sdmUodm9pZCAwKSxcbiAgbG9naW5XaXRoTmlwMDc6ICgpID0+IFByb21pc2UucmVzb2x2ZSh2b2lkIDApLFxuICBzaWduUHVibGlzaEV2ZW50OiAodCwgZSkgPT4gUHJvbWlzZS5yZXNvbHZlKHZvaWQgMCksXG4gIGdldFVzZXI6ICh0KSA9PiBwZS5wcm90b3R5cGUsXG4gIGdldFByb2ZpbGU6ICh0KSA9PiAoe30pXG59KSwgUHAgPSAoe1xuICBjaGlsZHJlbjogdCxcbiAgcmVsYXlVcmxzOiBlXG59KSA9PiB7XG4gIGNvbnN0IHtcbiAgICBuZGs6IHIsXG4gICAgc2lnbmVyOiBuLFxuICAgIHNldFNpZ25lcjogaSxcbiAgICBmZXRjaEV2ZW50czogcyxcbiAgICBzaWduUHVibGlzaEV2ZW50OiBvXG4gIH0gPSB6ZChlKSwge1xuICAgIGdldFVzZXI6IGEsXG4gICAgZ2V0UHJvZmlsZTogY1xuICB9ID0gVmQocik7XG4gIGFzeW5jIGZ1bmN0aW9uIGwoaCwgZCkge1xuICAgIGlmIChyID09PSB2b2lkIDApXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgcCA9IGF3YWl0IEtkKHIsIGgsIGQpO1xuICAgIGlmIChwKVxuICAgICAgcmV0dXJuIGF3YWl0IGkocC5yZW1vdGVTaWduZXIpLCBwO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIGYoaCkge1xuICAgIGNvbnN0IGQgPSBhd2FpdCBGZChoKTtcbiAgICBpZiAoZCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzaWduZXI6IHBcbiAgICAgIH0gPSBkO1xuICAgICAgcmV0dXJuIGF3YWl0IGkocCksIGQ7XG4gICAgfVxuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHUoKSB7XG4gICAgY29uc3QgaCA9IGF3YWl0IFdkKCk7XG4gICAgaWYgKGgpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc2lnbmVyOiBkXG4gICAgICB9ID0gaDtcbiAgICAgIHJldHVybiBhd2FpdCBpKGQpLCBoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFlkKExhLlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHtcbiAgICAgIG5kazogcixcbiAgICAgIHNpZ25lcjogbixcbiAgICAgIGZldGNoRXZlbnRzOiBzLFxuICAgICAgbG9naW5XaXRoTmlwMDc6IHUsXG4gICAgICBsb2dpbldpdGhOaXA0NjogbCxcbiAgICAgIGxvZ2luV2l0aFNlY3JldDogZixcbiAgICAgIHNpZ25QdWJsaXNoRXZlbnQ6IG8sXG4gICAgICBnZXRVc2VyOiBhLFxuICAgICAgZ2V0UHJvZmlsZTogY1xuICAgIH0sXG4gICAgY2hpbGRyZW46IHRcbiAgfSk7XG59LCBCcCA9ICgpID0+IHtcbiAgY29uc3QgdCA9IGZjKExhKTtcbiAgaWYgKHQgPT09IHZvaWQgMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbXBvcnQgTkRLUHJvdmlkZXIgdG8gdXNlIHVzZU5ES1wiKTtcbiAgcmV0dXJuIHQ7XG59O1xuZnVuY3Rpb24gWGUodCkge1xuICByZXR1cm4gdCAhPSBudWxsICYmIHR5cGVvZiB0ID09IFwib2JqZWN0XCIgJiYgdFtcIkBAZnVuY3Rpb25hbC9wbGFjZWhvbGRlclwiXSA9PT0gITA7XG59XG5mdW5jdGlvbiBodCh0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBlKHIpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMCB8fCBYZShyKSA/IGUgOiB0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5mdW5jdGlvbiB1cih0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBlKHIsIG4pIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiBYZShyKSA/IGUgOiBodChmdW5jdGlvbihpKSB7XG4gICAgICAgICAgcmV0dXJuIHQociwgaSk7XG4gICAgICAgIH0pO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFhlKHIpICYmIFhlKG4pID8gZSA6IFhlKHIpID8gaHQoZnVuY3Rpb24oaSkge1xuICAgICAgICAgIHJldHVybiB0KGksIG4pO1xuICAgICAgICB9KSA6IFhlKG4pID8gaHQoZnVuY3Rpb24oaSkge1xuICAgICAgICAgIHJldHVybiB0KHIsIGkpO1xuICAgICAgICB9KSA6IHQociwgbik7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gJGEodCwgZSkge1xuICBzd2l0Y2ggKHQpIHtcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiBmdW5jdGlvbihyKSB7XG4gICAgICAgIHJldHVybiBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiBmdW5jdGlvbihyLCBuKSB7XG4gICAgICAgIHJldHVybiBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiBmdW5jdGlvbihyLCBuLCBpKSB7XG4gICAgICAgIHJldHVybiBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIGNhc2UgNDpcbiAgICAgIHJldHVybiBmdW5jdGlvbihyLCBuLCBpLCBzKSB7XG4gICAgICAgIHJldHVybiBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIGNhc2UgNTpcbiAgICAgIHJldHVybiBmdW5jdGlvbihyLCBuLCBpLCBzLCBvKSB7XG4gICAgICAgIHJldHVybiBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIGNhc2UgNjpcbiAgICAgIHJldHVybiBmdW5jdGlvbihyLCBuLCBpLCBzLCBvLCBhKSB7XG4gICAgICAgIHJldHVybiBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIGNhc2UgNzpcbiAgICAgIHJldHVybiBmdW5jdGlvbihyLCBuLCBpLCBzLCBvLCBhLCBjKSB7XG4gICAgICAgIHJldHVybiBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIGNhc2UgODpcbiAgICAgIHJldHVybiBmdW5jdGlvbihyLCBuLCBpLCBzLCBvLCBhLCBjLCBsKSB7XG4gICAgICAgIHJldHVybiBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIGNhc2UgOTpcbiAgICAgIHJldHVybiBmdW5jdGlvbihyLCBuLCBpLCBzLCBvLCBhLCBjLCBsLCBmKSB7XG4gICAgICAgIHJldHVybiBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIGNhc2UgMTA6XG4gICAgICByZXR1cm4gZnVuY3Rpb24ociwgbiwgaSwgcywgbywgYSwgYywgbCwgZiwgdSkge1xuICAgICAgICByZXR1cm4gZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmlyc3QgYXJndW1lbnQgdG8gX2FyaXR5IG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlciBubyBncmVhdGVyIHRoYW4gdGVuXCIpO1xuICB9XG59XG5mdW5jdGlvbiBxYSh0LCBlLCByKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBuID0gW10sIGkgPSAwLCBzID0gdCwgbyA9IDA7IG8gPCBlLmxlbmd0aCB8fCBpIDwgYXJndW1lbnRzLmxlbmd0aDsgKSB7XG4gICAgICB2YXIgYTtcbiAgICAgIG8gPCBlLmxlbmd0aCAmJiAoIVhlKGVbb10pIHx8IGkgPj0gYXJndW1lbnRzLmxlbmd0aCkgPyBhID0gZVtvXSA6IChhID0gYXJndW1lbnRzW2ldLCBpICs9IDEpLCBuW29dID0gYSwgWGUoYSkgfHwgKHMgLT0gMSksIG8gKz0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHMgPD0gMCA/IHIuYXBwbHkodGhpcywgbikgOiAkYShzLCBxYSh0LCBuLCByKSk7XG4gIH07XG59XG52YXIgSmQgPSAvKiBAX19QVVJFX18gKi8gdXIoZnVuY3Rpb24oZSwgcikge1xuICByZXR1cm4gZSA9PT0gMSA/IGh0KHIpIDogJGEoZSwgcWEoZSwgW10sIHIpKTtcbn0pO1xuY29uc3QgWGQgPSBKZCwgUWQgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uKGUpIHtcbiAgcmV0dXJuIGUgIT0gbnVsbCAmJiBlLmxlbmd0aCA+PSAwICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiO1xufTtcbmZ1bmN0aW9uIGVwKHQpIHtcbiAgcmV0dXJuIHQgIT0gbnVsbCAmJiB0eXBlb2YgdFtcIkBAdHJhbnNkdWNlci9zdGVwXCJdID09IFwiZnVuY3Rpb25cIjtcbn1cbmZ1bmN0aW9uIHRwKHQsIGUsIHIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIHIoKTtcbiAgICB2YXIgbiA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV07XG4gICAgaWYgKCFRZChuKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0Lmxlbmd0aDsgKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygblt0W2ldXSA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgcmV0dXJuIG5bdFtpXV0uYXBwbHkobiwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwLCAtMSkpO1xuICAgICAgICBpICs9IDE7XG4gICAgICB9XG4gICAgICBpZiAoZXAobikpIHtcbiAgICAgICAgdmFyIHMgPSBlLmFwcGx5KG51bGwsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCwgLTEpKTtcbiAgICAgICAgcmV0dXJuIHMobik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5jb25zdCB6byA9IHtcbiAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMueGZbXCJAQHRyYW5zZHVjZXIvaW5pdFwiXSgpO1xuICB9LFxuICByZXN1bHQ6IGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdGhpcy54ZltcIkBAdHJhbnNkdWNlci9yZXN1bHRcIl0odCk7XG4gIH1cbn07XG5mdW5jdGlvbiBqbih0LCBlKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSwgdCk7XG59XG52YXIgRm8gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLCBycCA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIEZvLmNhbGwoYXJndW1lbnRzKSA9PT0gXCJbb2JqZWN0IEFyZ3VtZW50c11cIiA/IGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gRm8uY2FsbChlKSA9PT0gXCJbb2JqZWN0IEFyZ3VtZW50c11cIjtcbiAgfSA6IGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gam4oXCJjYWxsZWVcIiwgZSk7XG4gIH07XG59KCk7XG5jb25zdCBucCA9IHJwO1xudmFyIGlwID0gIS8qIEBfX1BVUkVfXyAqLyB7XG4gIHRvU3RyaW5nOiBudWxsXG59LnByb3BlcnR5SXNFbnVtZXJhYmxlKFwidG9TdHJpbmdcIiksIEtvID0gW1wiY29uc3RydWN0b3JcIiwgXCJ2YWx1ZU9mXCIsIFwiaXNQcm90b3R5cGVPZlwiLCBcInRvU3RyaW5nXCIsIFwicHJvcGVydHlJc0VudW1lcmFibGVcIiwgXCJoYXNPd25Qcm9wZXJ0eVwiLCBcInRvTG9jYWxlU3RyaW5nXCJdLCBXbyA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5wcm9wZXJ0eUlzRW51bWVyYWJsZShcImxlbmd0aFwiKTtcbn0oKSwgb3AgPSBmdW5jdGlvbihlLCByKSB7XG4gIGZvciAodmFyIG4gPSAwOyBuIDwgZS5sZW5ndGg7ICkge1xuICAgIGlmIChlW25dID09PSByKVxuICAgICAgcmV0dXJuICEwO1xuICAgIG4gKz0gMTtcbiAgfVxuICByZXR1cm4gITE7XG59LCBzcCA9IC8qIEBfX1BVUkVfXyAqLyBodCh0eXBlb2YgT2JqZWN0LmtleXMgPT0gXCJmdW5jdGlvblwiICYmICFXbyA/IGZ1bmN0aW9uKGUpIHtcbiAgcmV0dXJuIE9iamVjdChlKSAhPT0gZSA/IFtdIDogT2JqZWN0LmtleXMoZSk7XG59IDogZnVuY3Rpb24oZSkge1xuICBpZiAoT2JqZWN0KGUpICE9PSBlKVxuICAgIHJldHVybiBbXTtcbiAgdmFyIHIsIG4sIGkgPSBbXSwgcyA9IFdvICYmIG5wKGUpO1xuICBmb3IgKHIgaW4gZSlcbiAgICBqbihyLCBlKSAmJiAoIXMgfHwgciAhPT0gXCJsZW5ndGhcIikgJiYgKGlbaS5sZW5ndGhdID0gcik7XG4gIGlmIChpcClcbiAgICBmb3IgKG4gPSBLby5sZW5ndGggLSAxOyBuID49IDA7IClcbiAgICAgIHIgPSBLb1tuXSwgam4ociwgZSkgJiYgIW9wKGksIHIpICYmIChpW2kubGVuZ3RoXSA9IHIpLCBuIC09IDE7XG4gIHJldHVybiBpO1xufSk7XG5jb25zdCBhcCA9IHNwO1xuZnVuY3Rpb24gY3AodCwgZSkge1xuICBmb3IgKHZhciByID0gMCwgbiA9IGUubGVuZ3RoLCBpID0gQXJyYXkobik7IHIgPCBuOyApXG4gICAgaVtyXSA9IHQoZVtyXSksIHIgKz0gMTtcbiAgcmV0dXJuIGk7XG59XG5mdW5jdGlvbiB1cCh0LCBlLCByKSB7XG4gIGZvciAodmFyIG4gPSAwLCBpID0gci5sZW5ndGg7IG4gPCBpOyApXG4gICAgZSA9IHQoZSwgcltuXSksIG4gKz0gMTtcbiAgcmV0dXJuIGU7XG59XG52YXIgbHAgPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIHQoZSwgcikge1xuICAgIHRoaXMueGYgPSByLCB0aGlzLmYgPSBlO1xuICB9XG4gIHJldHVybiB0LnByb3RvdHlwZVtcIkBAdHJhbnNkdWNlci9pbml0XCJdID0gem8uaW5pdCwgdC5wcm90b3R5cGVbXCJAQHRyYW5zZHVjZXIvcmVzdWx0XCJdID0gem8ucmVzdWx0LCB0LnByb3RvdHlwZVtcIkBAdHJhbnNkdWNlci9zdGVwXCJdID0gZnVuY3Rpb24oZSwgcikge1xuICAgIHJldHVybiB0aGlzLnhmW1wiQEB0cmFuc2R1Y2VyL3N0ZXBcIl0oZSwgdGhpcy5mKHIpKTtcbiAgfSwgdDtcbn0oKSwgZnAgPSBmdW5jdGlvbihlKSB7XG4gIHJldHVybiBmdW5jdGlvbihyKSB7XG4gICAgcmV0dXJuIG5ldyBscChlLCByKTtcbiAgfTtcbn07XG5jb25zdCBocCA9IGZwO1xudmFyIGRwID0gLyogQF9fUFVSRV9fICovIHVyKFxuICAvKiBAX19QVVJFX18gKi8gdHAoW1wiZmFudGFzeS1sYW5kL21hcFwiLCBcIm1hcFwiXSwgaHAsIGZ1bmN0aW9uKGUsIHIpIHtcbiAgICBzd2l0Y2ggKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChyKSkge1xuICAgICAgY2FzZSBcIltvYmplY3QgRnVuY3Rpb25dXCI6XG4gICAgICAgIHJldHVybiBYZChyLmxlbmd0aCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGUuY2FsbCh0aGlzLCByLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICAgICB9KTtcbiAgICAgIGNhc2UgXCJbb2JqZWN0IE9iamVjdF1cIjpcbiAgICAgICAgcmV0dXJuIHVwKGZ1bmN0aW9uKG4sIGkpIHtcbiAgICAgICAgICByZXR1cm4gbltpXSA9IGUocltpXSksIG47XG4gICAgICAgIH0sIHt9LCBhcChyKSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gY3AoZSwgcik7XG4gICAgfVxuICB9KVxuKTtcbmNvbnN0IHBwID0gZHAsIHlwID0gTnVtYmVyLmlzSW50ZWdlciB8fCBmdW5jdGlvbihlKSB7XG4gIHJldHVybiBlIDw8IDAgPT09IGU7XG59O1xuZnVuY3Rpb24gZ3AodCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQpID09PSBcIltvYmplY3QgU3RyaW5nXVwiO1xufVxudmFyIGJwID0gLyogQF9fUFVSRV9fICovIHVyKGZ1bmN0aW9uKGUsIHIpIHtcbiAgdmFyIG4gPSBlIDwgMCA/IHIubGVuZ3RoICsgZSA6IGU7XG4gIHJldHVybiBncChyKSA/IHIuY2hhckF0KG4pIDogcltuXTtcbn0pO1xuY29uc3QgTmEgPSBicDtcbnZhciB2cCA9IC8qIEBfX1BVUkVfXyAqLyB1cihmdW5jdGlvbihlLCByKSB7XG4gIGlmIChyICE9IG51bGwpXG4gICAgcmV0dXJuIHlwKGUpID8gTmEoZSwgcikgOiByW2VdO1xufSk7XG5jb25zdCB3cCA9IHZwO1xudmFyIF9wID0gLyogQF9fUFVSRV9fICovIHVyKGZ1bmN0aW9uKGUsIHIpIHtcbiAgcmV0dXJuIHBwKHdwKGUpLCByKTtcbn0pO1xuY29uc3QgbXAgPSBfcDtcbmZ1bmN0aW9uIHhwKHQpIHtcbiAgcmV0dXJuIHQ7XG59XG52YXIgRXAgPSAvKiBAX19QVVJFX18gKi8gaHQoeHApO1xuY29uc3Qga3AgPSBFcDtcbnZhciBTcCA9IC8qIEBfX1BVUkVfXyAqLyBOYSgtMSk7XG5jb25zdCBVYSA9IFNwLCBPcCA9IFwibmV3bGluZVwiLCBIbiA9IFwidGV4dFwiLCBqYSA9IFwidG9waWNcIiwgeGkgPSBcImxpbmtcIiwgSGEgPSBcImludm9pY2VcIiwgTHAgPSBcIm5vc3RyOm5vdGVcIiwgJHAgPSBcIm5vc3RyOm5ldmVudFwiLCBxcCA9IFwibm9zdHI6bnB1YlwiLCBOcCA9IFwibm9zdHI6bnByb2ZpbGVcIiwgVXAgPSBcIm5vc3RyOm5hZGRyXCI7XG5mdW5jdGlvbiBndCh0KSB7XG4gIHJldHVybiB0ID8gdFswXSA6IHZvaWQgMDtcbn1cbmNvbnN0IEFwID0gKHQpID0+IHQucmVwbGFjZSgvXltcXHdcXCtdKzpcXC8/XFwvPy8sIFwiXCIpLCBDcCA9ICh0KSA9PiAhdC5tYXRjaCgvXFwuKGFwa3xkb2N4fHhsc3h8Y3N2fGRtZykvKSAmJiBVYSh0LnNwbGl0KFwiOi8vXCIpKS5pbmNsdWRlcyhcIi9cIiksIGpwID0gKHtcbiAgY29udGVudDogdCxcbiAgdGFnczogZSA9IFtdXG59KSA9PiB7XG4gIGNvbnN0IHIgPSBbXTtcbiAgbGV0IG4gPSB0LnRyaW0oKSwgaSA9IFwiXCI7XG4gIGNvbnN0IHMgPSAoKSA9PiB7XG4gICAgY29uc3QgdSA9IGd0KG4ubWF0Y2goL15cXG4rLykpO1xuICAgIGlmICh1KVxuICAgICAgcmV0dXJuIFtPcCwgdSwgdV07XG4gIH0sIG8gPSAoKSA9PiB7XG4gICAgY29uc3QgdSA9IG4ubWF0Y2goL14jXFxbKFxcZCspXFxdL2kpO1xuICAgIGlmICh1KSB7XG4gICAgICBjb25zdCBoID0gcGFyc2VJbnQodVsxXSk7XG4gICAgICBpZiAoZVtoXSkge1xuICAgICAgICBjb25zdCBbZCwgcCwgeV0gPSBlW2hdLCBnID0gW3ldLmZpbHRlcihrcCk7XG4gICAgICAgIGxldCB2LCBfLCBtO1xuICAgICAgICByZXR1cm4gZCA9PT0gXCJwXCIgPyAodiA9IFwibnByb2ZpbGVcIiwgXyA9IHsgcHVia2V5OiBwLCByZWxheXM6IGcgfSwgbSA9IHdlLm5wcm9maWxlRW5jb2RlKF8pKSA6ICh2ID0gXCJuZXZlbnRcIiwgXyA9IHsgaWQ6IHAsIHJlbGF5czogZywgcHVia2V5OiBudWxsIH0sIG0gPSB3ZS5uZXZlbnRFbmNvZGUoXykpLCBbYG5vc3RyOiR7dn1gLCB1WzBdLCB7IC4uLl8sIGVudGl0eTogbSB9XTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIGEgPSAoKSA9PiB7XG4gICAgY29uc3QgdSA9IGd0KG4ubWF0Y2goL14jXFx3Ky9pKSk7XG4gICAgaWYgKHUgJiYgIXUubWF0Y2goL14jXFxkKyQvKSlcbiAgICAgIHJldHVybiBbamEsIHUsIHUuc2xpY2UoMSldO1xuICB9LCBjID0gKCkgPT4ge1xuICAgIGNvbnN0IHUgPSBndChcbiAgICAgIG4ubWF0Y2goXG4gICAgICAgIC9eKHdlYlxcKyk/KG5vc3RyOik/XFwvP1xcLz9uKGV2ZW50fG90ZXxwcm9maWxlfHB1YnxhZGRyKTFbXFxkXFx3XSsvaVxuICAgICAgKVxuICAgICk7XG4gICAgaWYgKHUpXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBoID0gQXAodSksIHsgdHlwZTogZCwgZGF0YTogcCB9ID0gd2UuZGVjb2RlKGgpO1xuICAgICAgICBsZXQgeSA9IHA7XG4gICAgICAgIHJldHVybiBkID09PSBcIm5vdGVcIiA/IHkgPSB7IGlkOiBwIH0gOiBkID09PSBcIm5wdWJcIiAmJiAoeSA9IHsgcHVia2V5OiBwIH0pLCBbYG5vc3RyOiR7ZH1gLCB1LCB7IC4uLnksIGVudGl0eTogaCB9XTtcbiAgICAgIH0gY2F0Y2ggKGgpIHtcbiAgICAgICAgY29uc29sZS5sb2coaCk7XG4gICAgICB9XG4gIH0sIGwgPSAoKSA9PiB7XG4gICAgY29uc3QgdSA9IGd0KG4ubWF0Y2goL15sbihiY3x1cmwpW1xcZFxcd117NTAsMTAwMH0vaSkpO1xuICAgIGlmICh1KVxuICAgICAgcmV0dXJuIFtIYSwgdSwgdV07XG4gIH0sIGYgPSAoKSA9PiB7XG4gICAgY29uc3QgdSA9IGd0KFxuICAgICAgbi5tYXRjaCgvXihbYS16XFwrOl17MiwzMH06XFwvXFwvKT9bXlxcc10rXFwuW2Etel17Miw2fVteXFxzXSpbXlxcLiE/LDpcXHNdL2dpKVxuICAgICk7XG4gICAgaWYgKHUpIHtcbiAgICAgIGNvbnN0IGggPSBVYShyKTtcbiAgICAgIGlmICgoaCA9PSBudWxsID8gdm9pZCAwIDogaC50eXBlKSA9PT0gXCJ0ZXh0XCIgJiYgaC52YWx1ZS5lbmRzV2l0aChcIi9cIikpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGxldCBkID0gdTtcbiAgICAgIHJldHVybiBkLm1hdGNoKC9cXC5cXC4vKSA/IHZvaWQgMCA6IChkLm1hdGNoKFwiOi8vXCIpIHx8IChkID0gXCJodHRwczovL1wiICsgZCksIFt4aSwgdSwgeyB1cmw6IGQsIGlzTWVkaWE6IENwKGQpIH1dKTtcbiAgICB9XG4gIH07XG4gIGZvciAoOyBuOyApIHtcbiAgICBjb25zdCB1ID0gcygpIHx8IG8oKSB8fCBhKCkgfHwgYygpIHx8IGYoKSB8fCBsKCk7XG4gICAgaWYgKHUpIHtcbiAgICAgIGkgJiYgKHIucHVzaCh7IHR5cGU6IFwidGV4dFwiLCB2YWx1ZTogaSB9KSwgaSA9IFwiXCIpO1xuICAgICAgY29uc3QgW2gsIGQsIHBdID0gdTtcbiAgICAgIHIucHVzaCh7IHR5cGU6IGgsIHZhbHVlOiBwIH0pLCBuID0gbi5zbGljZShkLmxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGggPSBndChuLm1hdGNoKC9eW1xcd1xcZF0rID8vaSkpIHx8IG5bMF07XG4gICAgICBpICs9IGgsIG4gPSBuLnNsaWNlKGgubGVuZ3RoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGkgJiYgci5wdXNoKHsgdHlwZTogSG4sIHZhbHVlOiBpIH0pLCByO1xufSwgSHAgPSAodCwgeyBzaG93RW50aXJlOiBlLCBtYXhMZW5ndGg6IHIsIHNob3dNZWRpYTogbiA9ICExIH0pID0+IHtcbiAgaWYgKGUpXG4gICAgcmV0dXJuIHQ7XG4gIGxldCBpID0gMDtcbiAgY29uc3QgcyA9IFtdLCBvID0gciAqIDAuNjtcbiAgcmV0dXJuIHQuZXZlcnkoKGEsIGMpID0+IHtcbiAgICBjb25zdCBsID0gW2phLCBIbl0uaW5jbHVkZXMoYS50eXBlKSB8fCBhLnR5cGUgPT09IHhpICYmICFhLnZhbHVlLmlzTWVkaWEsIGYgPSBhLnR5cGUgPT09IEhhIHx8IGEudHlwZS5zdGFydHNXaXRoKFwibm9zdHI6XCIpIHx8IGEudmFsdWUuaXNNZWRpYTtcbiAgICByZXR1cm4gbCAmJiAoaSArPSBhLnZhbHVlLmxlbmd0aCksIGYgJiYgKGkgKz0gbiA/IHIgLyAzIDogYS52YWx1ZS5sZW5ndGgpLCBzLnB1c2goYSksIGkgPiBvICYmIGMgPCB0Lmxlbmd0aCAtIDEgPyAoKGwgfHwgZiAmJiAhbikgJiYgcy5wdXNoKHsgdHlwZTogSG4sIHZhbHVlOiBcIi4uLlwiIH0pLCAhMSkgOiAhMDtcbiAgfSksIHM7XG59LCBNcCA9ICh0KSA9PiBtcChcbiAgXCJ2YWx1ZVwiLFxuICB0LmZpbHRlcigoZSkgPT4gZS50eXBlID09PSB4aSAmJiBlLmlzTWVkaWEpXG4pO1xuZXhwb3J0IHtcbiAgSGEgYXMgSU5WT0lDRSxcbiAgeGkgYXMgTElOSyxcbiAgUHAgYXMgTkRLUHJvdmlkZXIsXG4gIE9wIGFzIE5FV0xJTkUsXG4gIFVwIGFzIE5PU1RSX05BRERSLFxuICAkcCBhcyBOT1NUUl9ORVZFTlQsXG4gIExwIGFzIE5PU1RSX05PVEUsXG4gIE5wIGFzIE5PU1RSX05QUk9GSUxFLFxuICBxcCBhcyBOT1NUUl9OUFVCLFxuICBIbiBhcyBURVhULFxuICBqYSBhcyBUT1BJQyxcbiAgQXAgYXMgZnJvbU5vc3RyVVJJLFxuICBNcCBhcyBnZXRMaW5rcyxcbiAganAgYXMgcGFyc2VDb250ZW50LFxuICBIcCBhcyB0cnVuY2F0ZUNvbnRlbnQsXG4gIENwIGFzIHVybElzTWVkaWEsXG4gIEJwIGFzIHVzZU5ES1xufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk-react/dist/ndk-react.es.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk/dist/index.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/dist/index.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BECH32_REGEX: () => (/* binding */ BECH32_REGEX),\n/* harmony export */   NDKAppHandlerEvent: () => (/* binding */ NDKAppHandlerEvent),\n/* harmony export */   NDKAppSettings: () => (/* binding */ NDKAppSettings),\n/* harmony export */   NDKArticle: () => (/* binding */ NDKArticle),\n/* harmony export */   NDKCashuMintList: () => (/* binding */ NDKCashuMintList),\n/* harmony export */   NDKCashuToken: () => (/* binding */ NDKCashuToken),\n/* harmony export */   NDKCashuWalletTx: () => (/* binding */ NDKCashuWalletTx),\n/* harmony export */   NDKClassified: () => (/* binding */ NDKClassified),\n/* harmony export */   NDKDVMJobFeedback: () => (/* binding */ NDKDVMJobFeedback),\n/* harmony export */   NDKDVMJobResult: () => (/* binding */ NDKDVMJobResult),\n/* harmony export */   NDKDVMRequest: () => (/* binding */ NDKDVMRequest),\n/* harmony export */   NDKDraft: () => (/* binding */ NDKDraft),\n/* harmony export */   NDKDvmJobFeedbackStatus: () => (/* binding */ NDKDvmJobFeedbackStatus),\n/* harmony export */   NDKEvent: () => (/* binding */ NDKEvent),\n/* harmony export */   NDKHighlight: () => (/* binding */ NDKHighlight),\n/* harmony export */   NDKImage: () => (/* binding */ NDKImage),\n/* harmony export */   NDKKind: () => (/* binding */ NDKKind),\n/* harmony export */   NDKList: () => (/* binding */ NDKList),\n/* harmony export */   NDKListKinds: () => (/* binding */ NDKListKinds),\n/* harmony export */   NDKNip07Signer: () => (/* binding */ NDKNip07Signer),\n/* harmony export */   NDKNip46Backend: () => (/* binding */ NDKNip46Backend),\n/* harmony export */   NDKNip46Signer: () => (/* binding */ NDKNip46Signer),\n/* harmony export */   NDKNostrRpc: () => (/* binding */ NDKNostrRpc),\n/* harmony export */   NDKNutzap: () => (/* binding */ NDKNutzap),\n/* harmony export */   NDKPool: () => (/* binding */ NDKPool),\n/* harmony export */   NDKPrivateKeySigner: () => (/* binding */ NDKPrivateKeySigner),\n/* harmony export */   NDKPublishError: () => (/* binding */ NDKPublishError),\n/* harmony export */   NDKRelay: () => (/* binding */ NDKRelay),\n/* harmony export */   NDKRelayAuthPolicies: () => (/* binding */ NDKRelayAuthPolicies),\n/* harmony export */   NDKRelayList: () => (/* binding */ NDKRelayList),\n/* harmony export */   NDKRelaySet: () => (/* binding */ NDKRelaySet),\n/* harmony export */   NDKRelayStatus: () => (/* binding */ NDKRelayStatus),\n/* harmony export */   NDKRepost: () => (/* binding */ NDKRepost),\n/* harmony export */   NDKSimpleGroup: () => (/* binding */ NDKSimpleGroup),\n/* harmony export */   NDKSimpleGroupMemberList: () => (/* binding */ NDKSimpleGroupMemberList),\n/* harmony export */   NDKSimpleGroupMetadata: () => (/* binding */ NDKSimpleGroupMetadata),\n/* harmony export */   NDKSubscription: () => (/* binding */ NDKSubscription),\n/* harmony export */   NDKSubscriptionCacheUsage: () => (/* binding */ NDKSubscriptionCacheUsage),\n/* harmony export */   NDKSubscriptionReceipt: () => (/* binding */ NDKSubscriptionReceipt),\n/* harmony export */   NDKSubscriptionStart: () => (/* binding */ NDKSubscriptionStart),\n/* harmony export */   NDKSubscriptionTier: () => (/* binding */ NDKSubscriptionTier),\n/* harmony export */   NDKTranscriptionDVM: () => (/* binding */ NDKTranscriptionDVM),\n/* harmony export */   NDKUser: () => (/* binding */ NDKUser),\n/* harmony export */   NDKVideo: () => (/* binding */ NDKVideo),\n/* harmony export */   NDKWiki: () => (/* binding */ NDKWiki),\n/* harmony export */   NDKZapper: () => (/* binding */ NDKZapper),\n/* harmony export */   NIP33_A_REGEX: () => (/* binding */ NIP33_A_REGEX),\n/* harmony export */   calculateRelaySetFromEvent: () => (/* binding */ calculateRelaySetFromEvent),\n/* harmony export */   calculateTermDurationInSeconds: () => (/* binding */ calculateTermDurationInSeconds),\n/* harmony export */   compareFilter: () => (/* binding */ compareFilter),\n/* harmony export */   \"default\": () => (/* binding */ NDK),\n/* harmony export */   defaultOpts: () => (/* binding */ defaultOpts),\n/* harmony export */   deserialize: () => (/* binding */ deserialize),\n/* harmony export */   dvmSchedule: () => (/* binding */ dvmSchedule),\n/* harmony export */   eventHasETagMarkers: () => (/* binding */ eventHasETagMarkers),\n/* harmony export */   eventIsPartOfThread: () => (/* binding */ eventIsPartOfThread),\n/* harmony export */   eventIsReply: () => (/* binding */ eventIsReply),\n/* harmony export */   eventReplies: () => (/* binding */ eventReplies),\n/* harmony export */   eventThreadIds: () => (/* binding */ eventThreadIds),\n/* harmony export */   eventThreads: () => (/* binding */ eventThreads),\n/* harmony export */   eventsBySameAuthor: () => (/* binding */ eventsBySameAuthor),\n/* harmony export */   filterAndRelaySetFromBech32: () => (/* binding */ filterAndRelaySetFromBech32),\n/* harmony export */   filterFingerprint: () => (/* binding */ filterFingerprint),\n/* harmony export */   filterForEventsTaggingId: () => (/* binding */ filterForEventsTaggingId),\n/* harmony export */   filterFromId: () => (/* binding */ filterFromId),\n/* harmony export */   generateContentTags: () => (/* binding */ generateContentTags),\n/* harmony export */   generateHashtags: () => (/* binding */ generateHashtags),\n/* harmony export */   generateSubId: () => (/* binding */ generateSubId),\n/* harmony export */   generateZapRequest: () => (/* binding */ generateZapRequest),\n/* harmony export */   getEventReplyId: () => (/* binding */ getEventReplyId),\n/* harmony export */   getNip57ZapSpecFromLud: () => (/* binding */ getNip57ZapSpecFromLud),\n/* harmony export */   getRelayListForUser: () => (/* binding */ getRelayListForUser),\n/* harmony export */   getRelayListForUsers: () => (/* binding */ getRelayListForUsers),\n/* harmony export */   getReplyTag: () => (/* binding */ getReplyTag),\n/* harmony export */   getRootEventId: () => (/* binding */ getRootEventId),\n/* harmony export */   getRootTag: () => (/* binding */ getRootTag),\n/* harmony export */   imetaTagToTag: () => (/* binding */ imetaTagToTag),\n/* harmony export */   isEventOriginalPost: () => (/* binding */ isEventOriginalPost),\n/* harmony export */   isNip33AValue: () => (/* binding */ isNip33AValue),\n/* harmony export */   mapImetaTag: () => (/* binding */ mapImetaTag),\n/* harmony export */   matchFilter: () => (/* binding */ matchFilter),\n/* harmony export */   mergeFilters: () => (/* binding */ mergeFilters),\n/* harmony export */   mergeTags: () => (/* binding */ mergeTags),\n/* harmony export */   newAmount: () => (/* binding */ newAmount),\n/* harmony export */   normalize: () => (/* binding */ normalize),\n/* harmony export */   normalizeRelayUrl: () => (/* binding */ normalizeRelayUrl),\n/* harmony export */   normalizeUrl: () => (/* binding */ normalizeUrl),\n/* harmony export */   parseTagToSubscriptionAmount: () => (/* binding */ parseTagToSubscriptionAmount),\n/* harmony export */   pinEvent: () => (/* binding */ pinEvent),\n/* harmony export */   possibleIntervalFrequencies: () => (/* binding */ possibleIntervalFrequencies),\n/* harmony export */   profileFromEvent: () => (/* binding */ profileFromEvent),\n/* harmony export */   proofP2pk: () => (/* binding */ proofP2pk),\n/* harmony export */   proofP2pkNostr: () => (/* binding */ proofP2pkNostr),\n/* harmony export */   proofsTotalBalance: () => (/* binding */ proofsTotalBalance),\n/* harmony export */   queryFullyFilled: () => (/* binding */ queryFullyFilled),\n/* harmony export */   relayListFromKind3: () => (/* binding */ relayListFromKind3),\n/* harmony export */   relaysFromBech32: () => (/* binding */ relaysFromBech32),\n/* harmony export */   serialize: () => (/* binding */ serialize),\n/* harmony export */   serializeProfile: () => (/* binding */ serializeProfile),\n/* harmony export */   tryNormalizeRelayUrl: () => (/* binding */ tryNormalizeRelayUrl),\n/* harmony export */   uniqueTag: () => (/* binding */ uniqueTag),\n/* harmony export */   wrapEvent: () => (/* binding */ wrapEvent),\n/* harmony export */   zapInvoiceFromEvent: () => (/* binding */ zapInvoiceFromEvent)\n/* harmony export */ });\n/* harmony import */ var tseep__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tseep */ \"(ssr)/./node_modules/tseep/lib/index.js\");\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! debug */ \"(ssr)/./node_modules/debug/src/index.js\");\n/* harmony import */ var nostr_tools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! nostr-tools */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/lib/esm/index.js\");\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(ssr)/./node_modules/@noble/curves/esm/secp256k1.js\");\n/* harmony import */ var typescript_lru_cache__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! typescript-lru-cache */ \"(ssr)/./node_modules/typescript-lru-cache/dist/index.js\");\n/* harmony import */ var light_bolt11_decoder__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! light-bolt11-decoder */ \"(ssr)/./node_modules/light-bolt11-decoder/bolt11.js\");\n/* harmony import */ var _scure_base__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @scure/base */ \"(ssr)/./node_modules/@scure/base/lib/esm/index.js\");\n// src/events/kinds/index.ts\nvar NDKKind = /* @__PURE__ */ ((NDKKind2) => {\n  NDKKind2[NDKKind2[\"Metadata\"] = 0] = \"Metadata\";\n  NDKKind2[NDKKind2[\"Text\"] = 1] = \"Text\";\n  NDKKind2[NDKKind2[\"RecommendRelay\"] = 2] = \"RecommendRelay\";\n  NDKKind2[NDKKind2[\"Contacts\"] = 3] = \"Contacts\";\n  NDKKind2[NDKKind2[\"EncryptedDirectMessage\"] = 4] = \"EncryptedDirectMessage\";\n  NDKKind2[NDKKind2[\"EventDeletion\"] = 5] = \"EventDeletion\";\n  NDKKind2[NDKKind2[\"Repost\"] = 6] = \"Repost\";\n  NDKKind2[NDKKind2[\"Reaction\"] = 7] = \"Reaction\";\n  NDKKind2[NDKKind2[\"BadgeAward\"] = 8] = \"BadgeAward\";\n  NDKKind2[NDKKind2[\"GroupChat\"] = 9] = \"GroupChat\";\n  NDKKind2[NDKKind2[\"GroupNote\"] = 11] = \"GroupNote\";\n  NDKKind2[NDKKind2[\"GroupReply\"] = 12] = \"GroupReply\";\n  NDKKind2[NDKKind2[\"GiftWrapSeal\"] = 13] = \"GiftWrapSeal\";\n  NDKKind2[NDKKind2[\"PrivateDirectMessage\"] = 14] = \"PrivateDirectMessage\";\n  NDKKind2[NDKKind2[\"Image\"] = 20] = \"Image\";\n  NDKKind2[NDKKind2[\"Vanish\"] = 62] = \"Vanish\";\n  NDKKind2[NDKKind2[\"GiftWrap\"] = 1059] = \"GiftWrap\";\n  NDKKind2[NDKKind2[\"GenericRepost\"] = 16] = \"GenericRepost\";\n  NDKKind2[NDKKind2[\"ChannelCreation\"] = 40] = \"ChannelCreation\";\n  NDKKind2[NDKKind2[\"ChannelMetadata\"] = 41] = \"ChannelMetadata\";\n  NDKKind2[NDKKind2[\"ChannelMessage\"] = 42] = \"ChannelMessage\";\n  NDKKind2[NDKKind2[\"ChannelHideMessage\"] = 43] = \"ChannelHideMessage\";\n  NDKKind2[NDKKind2[\"ChannelMuteUser\"] = 44] = \"ChannelMuteUser\";\n  NDKKind2[NDKKind2[\"GenericReply\"] = 1111] = \"GenericReply\";\n  NDKKind2[NDKKind2[\"Media\"] = 1063] = \"Media\";\n  NDKKind2[NDKKind2[\"Report\"] = 1984] = \"Report\";\n  NDKKind2[NDKKind2[\"Label\"] = 1985] = \"Label\";\n  NDKKind2[NDKKind2[\"DVMReqTextExtraction\"] = 5e3] = \"DVMReqTextExtraction\";\n  NDKKind2[NDKKind2[\"DVMReqTextSummarization\"] = 5001] = \"DVMReqTextSummarization\";\n  NDKKind2[NDKKind2[\"DVMReqTextTranslation\"] = 5002] = \"DVMReqTextTranslation\";\n  NDKKind2[NDKKind2[\"DVMReqTextGeneration\"] = 5050] = \"DVMReqTextGeneration\";\n  NDKKind2[NDKKind2[\"DVMReqImageGeneration\"] = 5100] = \"DVMReqImageGeneration\";\n  NDKKind2[NDKKind2[\"DVMReqTextToSpeech\"] = 5250] = \"DVMReqTextToSpeech\";\n  NDKKind2[NDKKind2[\"DVMReqDiscoveryNostrContent\"] = 5300] = \"DVMReqDiscoveryNostrContent\";\n  NDKKind2[NDKKind2[\"DVMReqDiscoveryNostrPeople\"] = 5301] = \"DVMReqDiscoveryNostrPeople\";\n  NDKKind2[NDKKind2[\"DVMReqTimestamping\"] = 5900] = \"DVMReqTimestamping\";\n  NDKKind2[NDKKind2[\"DVMEventSchedule\"] = 5905] = \"DVMEventSchedule\";\n  NDKKind2[NDKKind2[\"DVMJobFeedback\"] = 7e3] = \"DVMJobFeedback\";\n  NDKKind2[NDKKind2[\"Subscribe\"] = 7001] = \"Subscribe\";\n  NDKKind2[NDKKind2[\"Unsubscribe\"] = 7002] = \"Unsubscribe\";\n  NDKKind2[NDKKind2[\"SubscriptionReceipt\"] = 7003] = \"SubscriptionReceipt\";\n  NDKKind2[NDKKind2[\"CashuReserve\"] = 7373] = \"CashuReserve\";\n  NDKKind2[NDKKind2[\"CashuQuote\"] = 7374] = \"CashuQuote\";\n  NDKKind2[NDKKind2[\"CashuToken\"] = 7375] = \"CashuToken\";\n  NDKKind2[NDKKind2[\"CashuWalletTx\"] = 7376] = \"CashuWalletTx\";\n  NDKKind2[NDKKind2[\"GroupAdminAddUser\"] = 9e3] = \"GroupAdminAddUser\";\n  NDKKind2[NDKKind2[\"GroupAdminRemoveUser\"] = 9001] = \"GroupAdminRemoveUser\";\n  NDKKind2[NDKKind2[\"GroupAdminEditMetadata\"] = 9002] = \"GroupAdminEditMetadata\";\n  NDKKind2[NDKKind2[\"GroupAdminEditStatus\"] = 9006] = \"GroupAdminEditStatus\";\n  NDKKind2[NDKKind2[\"GroupAdminCreateGroup\"] = 9007] = \"GroupAdminCreateGroup\";\n  NDKKind2[NDKKind2[\"GroupAdminRequestJoin\"] = 9021] = \"GroupAdminRequestJoin\";\n  NDKKind2[NDKKind2[\"MuteList\"] = 1e4] = \"MuteList\";\n  NDKKind2[NDKKind2[\"PinList\"] = 10001] = \"PinList\";\n  NDKKind2[NDKKind2[\"RelayList\"] = 10002] = \"RelayList\";\n  NDKKind2[NDKKind2[\"BookmarkList\"] = 10003] = \"BookmarkList\";\n  NDKKind2[NDKKind2[\"CommunityList\"] = 10004] = \"CommunityList\";\n  NDKKind2[NDKKind2[\"PublicChatList\"] = 10005] = \"PublicChatList\";\n  NDKKind2[NDKKind2[\"BlockRelayList\"] = 10006] = \"BlockRelayList\";\n  NDKKind2[NDKKind2[\"SearchRelayList\"] = 10007] = \"SearchRelayList\";\n  NDKKind2[NDKKind2[\"SimpleGroupList\"] = 10009] = \"SimpleGroupList\";\n  NDKKind2[NDKKind2[\"InterestList\"] = 10015] = \"InterestList\";\n  NDKKind2[NDKKind2[\"CashuMintList\"] = 10019] = \"CashuMintList\";\n  NDKKind2[NDKKind2[\"EmojiList\"] = 10030] = \"EmojiList\";\n  NDKKind2[NDKKind2[\"DirectMessageReceiveRelayList\"] = 10050] = \"DirectMessageReceiveRelayList\";\n  NDKKind2[NDKKind2[\"BlossomList\"] = 10063] = \"BlossomList\";\n  NDKKind2[NDKKind2[\"NostrWaletConnectInfo\"] = 13194] = \"NostrWaletConnectInfo\";\n  NDKKind2[NDKKind2[\"TierList\"] = 17e3] = \"TierList\";\n  NDKKind2[NDKKind2[\"CashuWallet\"] = 17375] = \"CashuWallet\";\n  NDKKind2[NDKKind2[\"FollowSet\"] = 3e4] = \"FollowSet\";\n  NDKKind2[NDKKind2[\"CategorizedPeopleList\"] = 3e4 /* FollowSet */] = \"CategorizedPeopleList\";\n  NDKKind2[NDKKind2[\"CategorizedBookmarkList\"] = 30001] = \"CategorizedBookmarkList\";\n  NDKKind2[NDKKind2[\"RelaySet\"] = 30002] = \"RelaySet\";\n  NDKKind2[NDKKind2[\"CategorizedRelayList\"] = 30002 /* RelaySet */] = \"CategorizedRelayList\";\n  NDKKind2[NDKKind2[\"BookmarkSet\"] = 30003] = \"BookmarkSet\";\n  NDKKind2[NDKKind2[\"CurationSet\"] = 30004] = \"CurationSet\";\n  NDKKind2[NDKKind2[\"ArticleCurationSet\"] = 30004] = \"ArticleCurationSet\";\n  NDKKind2[NDKKind2[\"VideoCurationSet\"] = 30005] = \"VideoCurationSet\";\n  NDKKind2[NDKKind2[\"ImageCurationSet\"] = 30006] = \"ImageCurationSet\";\n  NDKKind2[NDKKind2[\"InterestSet\"] = 30015] = \"InterestSet\";\n  NDKKind2[NDKKind2[\"InterestsList\"] = 30015 /* InterestSet */] = \"InterestsList\";\n  NDKKind2[NDKKind2[\"EmojiSet\"] = 30030] = \"EmojiSet\";\n  NDKKind2[NDKKind2[\"ModularArticle\"] = 30040] = \"ModularArticle\";\n  NDKKind2[NDKKind2[\"ModularArticleItem\"] = 30041] = \"ModularArticleItem\";\n  NDKKind2[NDKKind2[\"Wiki\"] = 30818] = \"Wiki\";\n  NDKKind2[NDKKind2[\"Draft\"] = 31234] = \"Draft\";\n  NDKKind2[NDKKind2[\"SubscriptionTier\"] = 37001] = \"SubscriptionTier\";\n  NDKKind2[NDKKind2[\"EcashMintRecommendation\"] = 38e3] = \"EcashMintRecommendation\";\n  NDKKind2[NDKKind2[\"HighlightSet\"] = 39802] = \"HighlightSet\";\n  NDKKind2[NDKKind2[\"CategorizedHighlightList\"] = 39802 /* HighlightSet */] = \"CategorizedHighlightList\";\n  NDKKind2[NDKKind2[\"Nutzap\"] = 9321] = \"Nutzap\";\n  NDKKind2[NDKKind2[\"ZapRequest\"] = 9734] = \"ZapRequest\";\n  NDKKind2[NDKKind2[\"Zap\"] = 9735] = \"Zap\";\n  NDKKind2[NDKKind2[\"Highlight\"] = 9802] = \"Highlight\";\n  NDKKind2[NDKKind2[\"ClientAuth\"] = 22242] = \"ClientAuth\";\n  NDKKind2[NDKKind2[\"NostrWalletConnectReq\"] = 23194] = \"NostrWalletConnectReq\";\n  NDKKind2[NDKKind2[\"NostrWalletConnectRes\"] = 23195] = \"NostrWalletConnectRes\";\n  NDKKind2[NDKKind2[\"NostrConnect\"] = 24133] = \"NostrConnect\";\n  NDKKind2[NDKKind2[\"BlossomUpload\"] = 24242] = \"BlossomUpload\";\n  NDKKind2[NDKKind2[\"HttpAuth\"] = 27235] = \"HttpAuth\";\n  NDKKind2[NDKKind2[\"ProfileBadge\"] = 30008] = \"ProfileBadge\";\n  NDKKind2[NDKKind2[\"BadgeDefinition\"] = 30009] = \"BadgeDefinition\";\n  NDKKind2[NDKKind2[\"MarketStall\"] = 30017] = \"MarketStall\";\n  NDKKind2[NDKKind2[\"MarketProduct\"] = 30018] = \"MarketProduct\";\n  NDKKind2[NDKKind2[\"Article\"] = 30023] = \"Article\";\n  NDKKind2[NDKKind2[\"AppSpecificData\"] = 30078] = \"AppSpecificData\";\n  NDKKind2[NDKKind2[\"Classified\"] = 30402] = \"Classified\";\n  NDKKind2[NDKKind2[\"HorizontalVideo\"] = 34235] = \"HorizontalVideo\";\n  NDKKind2[NDKKind2[\"VerticalVideo\"] = 34236] = \"VerticalVideo\";\n  NDKKind2[NDKKind2[\"LegacyCashuWallet\"] = 37375] = \"LegacyCashuWallet\";\n  NDKKind2[NDKKind2[\"GroupMetadata\"] = 39e3] = \"GroupMetadata\";\n  NDKKind2[NDKKind2[\"GroupAdmins\"] = 39001] = \"GroupAdmins\";\n  NDKKind2[NDKKind2[\"GroupMembers\"] = 39002] = \"GroupMembers\";\n  NDKKind2[NDKKind2[\"AppRecommendation\"] = 31989] = \"AppRecommendation\";\n  NDKKind2[NDKKind2[\"AppHandler\"] = 31990] = \"AppHandler\";\n  return NDKKind2;\n})(NDKKind || {});\nvar NDKListKinds = [\n  1e4 /* MuteList */,\n  10001 /* PinList */,\n  10002 /* RelayList */,\n  10003 /* BookmarkList */,\n  10004 /* CommunityList */,\n  10005 /* PublicChatList */,\n  10006 /* BlockRelayList */,\n  10007 /* SearchRelayList */,\n  10015 /* InterestList */,\n  10030 /* EmojiList */,\n  10050 /* DirectMessageReceiveRelayList */,\n  3e4 /* FollowSet */,\n  30003 /* BookmarkSet */,\n  30001 /* CategorizedBookmarkList */,\n  // Backwards compatibility\n  30002 /* RelaySet */,\n  30004 /* ArticleCurationSet */,\n  30005 /* VideoCurationSet */,\n  30015 /* InterestSet */,\n  30030 /* EmojiSet */,\n  39802 /* HighlightSet */\n];\n\n// src/events/index.ts\n\n\n// src/outbox/write.ts\nfunction getRelaysForSync(ndk, author, type = \"write\") {\n  if (!ndk.outboxTracker) return void 0;\n  const item = ndk.outboxTracker.data.get(author);\n  if (!item) return void 0;\n  if (type === \"write\") {\n    return item.writeRelays;\n  } else {\n    return item.readRelays;\n  }\n}\nasync function getWriteRelaysFor(ndk, author, type = \"write\") {\n  if (!ndk.outboxTracker) return void 0;\n  if (!ndk.outboxTracker.data.has(author)) {\n    await ndk.outboxTracker.trackUsers([author]);\n  }\n  return getRelaysForSync(ndk, author, type);\n}\n\n// src/outbox/relay-ranking.ts\nfunction getTopRelaysForAuthors(ndk, authors) {\n  const relaysWithCount = /* @__PURE__ */ new Map();\n  authors.forEach((author) => {\n    const writeRelays = getRelaysForSync(ndk, author);\n    if (writeRelays) {\n      writeRelays.forEach((relay) => {\n        const count = relaysWithCount.get(relay) || 0;\n        relaysWithCount.set(relay, count + 1);\n      });\n    }\n  });\n  const sortedRelays = Array.from(relaysWithCount.entries()).sort((a, b) => b[1] - a[1]);\n  return sortedRelays.map((entry) => entry[0]);\n}\n\n// src/outbox/index.ts\nfunction getAllRelaysForAllPubkeys(ndk, pubkeys, type = \"read\") {\n  const pubkeysToRelays = /* @__PURE__ */ new Map();\n  const authorsMissingRelays = /* @__PURE__ */ new Set();\n  pubkeys.forEach((pubkey) => {\n    const relays = getRelaysForSync(ndk, pubkey, type);\n    if (relays && relays.size > 0) {\n      relays.forEach((relay) => {\n        const pubkeysInRelay = pubkeysToRelays.get(relay) || /* @__PURE__ */ new Set();\n        pubkeysInRelay.add(pubkey);\n      });\n      pubkeysToRelays.set(pubkey, relays);\n    } else {\n      authorsMissingRelays.add(pubkey);\n    }\n  });\n  return { pubkeysToRelays, authorsMissingRelays };\n}\nfunction chooseRelayCombinationForPubkeys(ndk, pubkeys, type, { count, preferredRelays } = {}) {\n  count ??= 2;\n  preferredRelays ??= /* @__PURE__ */ new Set();\n  const pool = ndk.pool;\n  const connectedRelays = pool.connectedRelays();\n  connectedRelays.forEach((relay) => {\n    preferredRelays.add(relay.url);\n  });\n  const relayToAuthorsMap = /* @__PURE__ */ new Map();\n  const { pubkeysToRelays, authorsMissingRelays } = getAllRelaysForAllPubkeys(ndk, pubkeys, type);\n  const sortedRelays = getTopRelaysForAuthors(ndk, pubkeys);\n  const addAuthorToRelay = (author, relay) => {\n    const authorsInRelay = relayToAuthorsMap.get(relay) || [];\n    authorsInRelay.push(author);\n    relayToAuthorsMap.set(relay, authorsInRelay);\n  };\n  for (const [author, authorRelays] of pubkeysToRelays.entries()) {\n    let missingRelayCount = count;\n    for (const relay of connectedRelays) {\n      if (authorRelays.has(relay.url)) {\n        addAuthorToRelay(author, relay.url);\n        missingRelayCount--;\n      }\n    }\n    for (const authorRelay of authorRelays) {\n      if (relayToAuthorsMap.has(authorRelay)) {\n        addAuthorToRelay(author, authorRelay);\n        missingRelayCount--;\n      }\n    }\n    if (missingRelayCount <= 0) continue;\n    for (const relay of sortedRelays) {\n      if (missingRelayCount <= 0) break;\n      if (authorRelays.has(relay)) {\n        addAuthorToRelay(author, relay);\n        missingRelayCount--;\n      }\n    }\n  }\n  for (const author of authorsMissingRelays) {\n    pool.permanentAndConnectedRelays().forEach((relay) => {\n      const authorsInRelay = relayToAuthorsMap.get(relay.url) || [];\n      authorsInRelay.push(author);\n      relayToAuthorsMap.set(relay.url, authorsInRelay);\n    });\n  }\n  return relayToAuthorsMap;\n}\n\n// src/outbox/read/with-authors.ts\nfunction getRelaysForFilterWithAuthors(ndk, authors, relayGoalPerAuthor = 2) {\n  return chooseRelayCombinationForPubkeys(ndk, authors, \"write\", { count: relayGoalPerAuthor });\n}\n\n// src/utils/normalize-url.ts\nfunction tryNormalizeRelayUrl(url) {\n  try {\n    return normalizeRelayUrl(url);\n  } catch {\n    return void 0;\n  }\n}\nfunction normalizeRelayUrl(url) {\n  let r = normalizeUrl(url, {\n    stripAuthentication: false,\n    stripWWW: false,\n    stripHash: true\n  });\n  if (!r.endsWith(\"/\")) {\n    r += \"/\";\n  }\n  return r;\n}\nfunction normalize(urls) {\n  const normalized = /* @__PURE__ */ new Set();\n  for (const url of urls) {\n    try {\n      normalized.add(normalizeRelayUrl(url));\n    } catch {\n    }\n  }\n  return Array.from(normalized);\n}\nvar DATA_URL_DEFAULT_MIME_TYPE = \"text/plain\";\nvar DATA_URL_DEFAULT_CHARSET = \"us-ascii\";\nvar testParameter = (name, filters) => filters.some((filter) => filter instanceof RegExp ? filter.test(name) : filter === name);\nvar supportedProtocols = /* @__PURE__ */ new Set([\"https:\", \"http:\", \"file:\"]);\nvar hasCustomProtocol = (urlString) => {\n  try {\n    const { protocol } = new URL(urlString);\n    return protocol.endsWith(\":\") && !protocol.includes(\".\") && !supportedProtocols.has(protocol);\n  } catch {\n    return false;\n  }\n};\nvar normalizeDataURL = (urlString, { stripHash }) => {\n  const match = /^data:(?<type>[^,]*?),(?<data>[^#]*?)(?:#(?<hash>.*))?$/.exec(urlString);\n  if (!match) {\n    throw new Error(`Invalid URL: ${urlString}`);\n  }\n  let type = match.groups?.type ?? \"\";\n  let data = match.groups?.data ?? \"\";\n  let hash = match.groups?.hash ?? \"\";\n  const mediaType = type.split(\";\");\n  hash = stripHash ? \"\" : hash;\n  let isBase64 = false;\n  if (mediaType[mediaType.length - 1] === \"base64\") {\n    mediaType.pop();\n    isBase64 = true;\n  }\n  const mimeType = mediaType.shift()?.toLowerCase() ?? \"\";\n  const attributes = mediaType.map((attribute) => {\n    let [key, value = \"\"] = attribute.split(\"=\").map((string) => string.trim());\n    if (key === \"charset\") {\n      value = value.toLowerCase();\n      if (value === DATA_URL_DEFAULT_CHARSET) {\n        return \"\";\n      }\n    }\n    return `${key}${value ? `=${value}` : \"\"}`;\n  }).filter(Boolean);\n  const normalizedMediaType = [...attributes];\n  if (isBase64) {\n    normalizedMediaType.push(\"base64\");\n  }\n  if (normalizedMediaType.length > 0 || mimeType && mimeType !== DATA_URL_DEFAULT_MIME_TYPE) {\n    normalizedMediaType.unshift(mimeType);\n  }\n  return `data:${normalizedMediaType.join(\";\")},${isBase64 ? data.trim() : data}${hash ? `#${hash}` : \"\"}`;\n};\nfunction normalizeUrl(urlString, options = {}) {\n  options = {\n    defaultProtocol: \"http\",\n    normalizeProtocol: true,\n    forceHttp: false,\n    forceHttps: false,\n    stripAuthentication: true,\n    stripHash: false,\n    stripTextFragment: true,\n    stripWWW: true,\n    removeQueryParameters: [/^utm_\\w+/i],\n    removeTrailingSlash: true,\n    removeSingleSlash: true,\n    removeDirectoryIndex: false,\n    removeExplicitPort: false,\n    sortQueryParameters: true,\n    ...options\n  };\n  if (typeof options.defaultProtocol === \"string\" && !options.defaultProtocol.endsWith(\":\")) {\n    options.defaultProtocol = `${options.defaultProtocol}:`;\n  }\n  urlString = urlString.trim();\n  if (/^data:/i.test(urlString)) {\n    return normalizeDataURL(urlString, options);\n  }\n  if (hasCustomProtocol(urlString)) {\n    return urlString;\n  }\n  const hasRelativeProtocol = urlString.startsWith(\"//\");\n  const isRelativeUrl = !hasRelativeProtocol && /^\\.*\\//.test(urlString);\n  if (!isRelativeUrl) {\n    urlString = urlString.replace(/^(?!(?:\\w+:)?\\/\\/)|^\\/\\//, options.defaultProtocol);\n  }\n  const urlObject = new URL(urlString);\n  urlObject.hostname = urlObject.hostname.toLowerCase();\n  if (options.forceHttp && options.forceHttps) {\n    throw new Error(\"The `forceHttp` and `forceHttps` options cannot be used together\");\n  }\n  if (options.forceHttp && urlObject.protocol === \"https:\") {\n    urlObject.protocol = \"http:\";\n  }\n  if (options.forceHttps && urlObject.protocol === \"http:\") {\n    urlObject.protocol = \"https:\";\n  }\n  if (options.stripAuthentication) {\n    urlObject.username = \"\";\n    urlObject.password = \"\";\n  }\n  if (options.stripHash) {\n    urlObject.hash = \"\";\n  } else if (options.stripTextFragment) {\n    urlObject.hash = urlObject.hash.replace(/#?:~:text.*?$/i, \"\");\n  }\n  if (urlObject.pathname) {\n    const protocolRegex = /\\b[a-z][a-z\\d+\\-.]{1,50}:\\/\\//g;\n    let lastIndex = 0;\n    let result = \"\";\n    for (; ; ) {\n      const match = protocolRegex.exec(urlObject.pathname);\n      if (!match) {\n        break;\n      }\n      const protocol = match[0];\n      const protocolAtIndex = match.index;\n      const intermediate = urlObject.pathname.slice(lastIndex, protocolAtIndex);\n      result += intermediate.replace(/\\/{2,}/g, \"/\");\n      result += protocol;\n      lastIndex = protocolAtIndex + protocol.length;\n    }\n    const remnant = urlObject.pathname.slice(lastIndex, urlObject.pathname.length);\n    result += remnant.replace(/\\/{2,}/g, \"/\");\n    urlObject.pathname = result;\n  }\n  if (urlObject.pathname) {\n    try {\n      urlObject.pathname = decodeURI(urlObject.pathname);\n    } catch {\n    }\n  }\n  if (options.removeDirectoryIndex === true) {\n    options.removeDirectoryIndex = [/^index\\.[a-z]+$/];\n  }\n  if (Array.isArray(options.removeDirectoryIndex) && options.removeDirectoryIndex.length > 0) {\n    let pathComponents = urlObject.pathname.split(\"/\");\n    const lastComponent = pathComponents[pathComponents.length - 1];\n    if (testParameter(lastComponent, options.removeDirectoryIndex)) {\n      pathComponents = pathComponents.slice(0, -1);\n      urlObject.pathname = pathComponents.slice(1).join(\"/\") + \"/\";\n    }\n  }\n  if (urlObject.hostname) {\n    urlObject.hostname = urlObject.hostname.replace(/\\.$/, \"\");\n    if (options.stripWWW && /^www\\.(?!www\\.)[a-z\\-\\d]{1,63}\\.[a-z.\\-\\d]{2,63}$/.test(urlObject.hostname)) {\n      urlObject.hostname = urlObject.hostname.replace(/^www\\./, \"\");\n    }\n  }\n  if (Array.isArray(options.removeQueryParameters)) {\n    for (const key of [...urlObject.searchParams.keys()]) {\n      if (testParameter(key, options.removeQueryParameters)) {\n        urlObject.searchParams.delete(key);\n      }\n    }\n  }\n  if (!Array.isArray(options.keepQueryParameters) && options.removeQueryParameters === true) {\n    urlObject.search = \"\";\n  }\n  if (Array.isArray(options.keepQueryParameters) && options.keepQueryParameters.length > 0) {\n    for (const key of [...urlObject.searchParams.keys()]) {\n      if (!testParameter(key, options.keepQueryParameters)) {\n        urlObject.searchParams.delete(key);\n      }\n    }\n  }\n  if (options.sortQueryParameters) {\n    urlObject.searchParams.sort();\n    try {\n      urlObject.search = decodeURIComponent(urlObject.search);\n    } catch {\n    }\n  }\n  if (options.removeTrailingSlash) {\n    urlObject.pathname = urlObject.pathname.replace(/\\/$/, \"\");\n  }\n  if (options.removeExplicitPort && urlObject.port) {\n    urlObject.port = \"\";\n  }\n  const oldUrlString = urlString;\n  urlString = urlObject.toString();\n  if (!options.removeSingleSlash && urlObject.pathname === \"/\" && !oldUrlString.endsWith(\"/\") && urlObject.hash === \"\") {\n    urlString = urlString.replace(/\\/$/, \"\");\n  }\n  if ((options.removeTrailingSlash || urlObject.pathname === \"/\") && urlObject.hash === \"\" && options.removeSingleSlash) {\n    urlString = urlString.replace(/\\/$/, \"\");\n  }\n  if (hasRelativeProtocol && !options.normalizeProtocol) {\n    urlString = urlString.replace(/^http:\\/\\//, \"//\");\n  }\n  if (options.stripProtocol) {\n    urlString = urlString.replace(/^(?:https?:)?\\/\\//, \"\");\n  }\n  return urlString;\n}\n\n// src/relay/index.ts\n\n\n\n// src/relay/connectivity.ts\nvar MAX_RECONNECT_ATTEMPTS = 5;\nvar FLAPPING_THRESHOLD_MS = 1e3;\nvar NDKRelayConnectivity = class {\n  ndkRelay;\n  ws;\n  _status;\n  timeoutMs;\n  connectedAt;\n  _connectionStats = {\n    attempts: 0,\n    success: 0,\n    durations: []\n  };\n  debug;\n  netDebug;\n  connectTimeout;\n  reconnectTimeout;\n  ndk;\n  openSubs = /* @__PURE__ */ new Map();\n  openCountRequests = /* @__PURE__ */ new Map();\n  openEventPublishes = /* @__PURE__ */ new Map();\n  serial = 0;\n  baseEoseTimeout = 4400;\n  constructor(ndkRelay, ndk) {\n    this.ndkRelay = ndkRelay;\n    this._status = 1 /* DISCONNECTED */;\n    const rand = Math.floor(Math.random() * 1e3);\n    this.debug = this.ndkRelay.debug.extend(\"connectivity\" + rand);\n    this.ndk = ndk;\n  }\n  /**\n   * Connects to the NDK relay and handles the connection lifecycle.\n   *\n   * This method attempts to establish a WebSocket connection to the NDK relay specified in the `ndkRelay` object.\n   * If the connection is successful, it updates the connection statistics, sets the connection status to `CONNECTED`,\n   * and emits `connect` and `ready` events on the `ndkRelay` object.\n   *\n   * If the connection attempt fails, it handles the error by either initiating a reconnection attempt or emitting a\n   * `delayed-connect` event on the `ndkRelay` object, depending on the `reconnect` parameter.\n   *\n   * @param timeoutMs - The timeout in milliseconds for the connection attempt. If not provided, the default timeout from the `ndkRelay` object is used.\n   * @param reconnect - Indicates whether a reconnection should be attempted if the connection fails. Defaults to `true`.\n   * @returns A Promise that resolves when the connection is established, or rejects if the connection fails.\n   */\n  async connect(timeoutMs, reconnect = true) {\n    if (this._status !== 2 /* RECONNECTING */ && this._status !== 1 /* DISCONNECTED */ || this.reconnectTimeout) {\n      this.debug(\n        \"Relay requested to be connected but was in state %s or it had a reconnect timeout\",\n        this._status\n      );\n      return;\n    }\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = void 0;\n    }\n    if (this.connectTimeout) {\n      clearTimeout(this.connectTimeout);\n      this.connectTimeout = void 0;\n    }\n    timeoutMs ??= this.timeoutMs;\n    if (!this.timeoutMs && timeoutMs) this.timeoutMs = timeoutMs;\n    if (this.timeoutMs)\n      this.connectTimeout = setTimeout(\n        () => this.onConnectionError(reconnect),\n        this.timeoutMs\n      );\n    try {\n      this.updateConnectionStats.attempt();\n      if (this._status === 1 /* DISCONNECTED */)\n        this._status = 4 /* CONNECTING */;\n      else this._status = 2 /* RECONNECTING */;\n      this.ws = new WebSocket(this.ndkRelay.url);\n      this.ws.onopen = this.onConnect.bind(this);\n      this.ws.onclose = this.onDisconnect.bind(this);\n      this.ws.onmessage = this.onMessage.bind(this);\n      this.ws.onerror = this.onError.bind(this);\n    } catch (e) {\n      this.debug(`Failed to connect to ${this.ndkRelay.url}`, e);\n      this._status = 1 /* DISCONNECTED */;\n      if (reconnect) this.handleReconnection();\n      else this.ndkRelay.emit(\"delayed-connect\", 2 * 24 * 60 * 60 * 1e3);\n      throw e;\n    }\n  }\n  /**\n   * Disconnects the WebSocket connection to the NDK relay.\n   * This method sets the connection status to `NDKRelayStatus.DISCONNECTING`,\n   * attempts to close the WebSocket connection, and sets the status to\n   * `NDKRelayStatus.DISCONNECTED` if the disconnect operation fails.\n   */\n  disconnect() {\n    this._status = 0 /* DISCONNECTING */;\n    try {\n      this.ws?.close();\n    } catch (e) {\n      this.debug(\"Failed to disconnect\", e);\n      this._status = 1 /* DISCONNECTED */;\n    }\n  }\n  /**\n   * Handles the error that occurred when attempting to connect to the NDK relay.\n   * If `reconnect` is `true`, this method will initiate a reconnection attempt.\n   * Otherwise, it will emit a `delayed-connect` event on the `ndkRelay` object,\n   * indicating that a reconnection should be attempted after a delay.\n   *\n   * @param reconnect - Indicates whether a reconnection should be attempted.\n   */\n  onConnectionError(reconnect) {\n    this.debug(`Error connecting to ${this.ndkRelay.url}`, this.timeoutMs);\n    if (reconnect && !this.reconnectTimeout) {\n      this.handleReconnection();\n    }\n  }\n  /**\n   * Handles the connection event when the WebSocket connection is established.\n   * This method is called when the WebSocket connection is successfully opened.\n   * It clears any existing connection and reconnection timeouts, updates the connection statistics,\n   * sets the connection status to `CONNECTED`, and emits `connect` and `ready` events on the `ndkRelay` object.\n   */\n  onConnect() {\n    this.netDebug?.(\"connected\", this.ndkRelay);\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = void 0;\n    }\n    if (this.connectTimeout) {\n      clearTimeout(this.connectTimeout);\n      this.connectTimeout = void 0;\n    }\n    this.updateConnectionStats.connected();\n    this._status = 5 /* CONNECTED */;\n    this.ndkRelay.emit(\"connect\");\n    this.ndkRelay.emit(\"ready\");\n  }\n  /**\n   * Handles the disconnection event when the WebSocket connection is closed.\n   * This method is called when the WebSocket connection is successfully closed.\n   * It updates the connection statistics, sets the connection status to `DISCONNECTED`,\n   * initiates a reconnection attempt if we didn't disconnect ourselves,\n   * and emits a `disconnect` event on the `ndkRelay` object.\n   */\n  onDisconnect() {\n    this.netDebug?.(\"disconnected\", this.ndkRelay);\n    this.updateConnectionStats.disconnected();\n    if (this._status === 5 /* CONNECTED */) {\n      this.handleReconnection();\n    }\n    this._status = 1 /* DISCONNECTED */;\n    this.ndkRelay.emit(\"disconnect\");\n  }\n  /**\n   * Handles incoming messages from the NDK relay WebSocket connection.\n   * This method is called whenever a message is received from the relay.\n   * It parses the message data and dispatches the appropriate handling logic based on the message type.\n   *\n   * @param event - The MessageEvent containing the received message data.\n   */\n  onMessage(event) {\n    this.netDebug?.(event.data, this.ndkRelay, \"recv\");\n    try {\n      const data = JSON.parse(event.data);\n      const [cmd, id, ...rest] = data;\n      switch (cmd) {\n        case \"EVENT\": {\n          const so = this.openSubs.get(id);\n          const event2 = data[2];\n          if (!so) {\n            this.debug(`Received event for unknown subscription ${id}`);\n            return;\n          }\n          so.onevent(event2);\n          return;\n        }\n        case \"COUNT\": {\n          const payload = data[2];\n          const cr = this.openCountRequests.get(id);\n          if (cr) {\n            cr.resolve(payload.count);\n            this.openCountRequests.delete(id);\n          }\n          return;\n        }\n        case \"EOSE\": {\n          const so = this.openSubs.get(id);\n          if (!so) return;\n          so.oneose(id);\n          return;\n        }\n        case \"OK\": {\n          const ok = data[2];\n          const reason = data[3];\n          const ep = this.openEventPublishes.get(id);\n          const firstEp = ep?.pop();\n          if (!ep || !firstEp) {\n            this.debug(\"Received OK for unknown event publish\", id);\n            return;\n          }\n          if (ok) firstEp.resolve(reason);\n          else firstEp.reject(new Error(reason));\n          if (ep.length === 0) {\n            this.openEventPublishes.delete(id);\n          } else {\n            this.openEventPublishes.set(id, ep);\n          }\n          return;\n        }\n        case \"CLOSED\": {\n          const so = this.openSubs.get(id);\n          if (!so) return;\n          so.onclosed(data[2]);\n          return;\n        }\n        case \"NOTICE\":\n          this.onNotice(data[1]);\n          return;\n        case \"AUTH\": {\n          this.onAuthRequested(data[1]);\n          return;\n        }\n      }\n    } catch (error) {\n      this.debug(\n        `Error parsing message from ${this.ndkRelay.url}: ${error.message}`,\n        error?.stack\n      );\n      return;\n    }\n  }\n  /**\n   * Handles an authentication request from the NDK relay.\n   *\n   * If an authentication policy is configured, it will be used to authenticate the connection.\n   * Otherwise, the `auth` event will be emitted to allow the application to handle the authentication.\n   *\n   * @param challenge - The authentication challenge provided by the NDK relay.\n   */\n  async onAuthRequested(challenge) {\n    const authPolicy = this.ndkRelay.authPolicy ?? this.ndk?.relayAuthDefaultPolicy;\n    this.debug(\"Relay requested authentication\", {\n      havePolicy: !!authPolicy\n    });\n    if (this._status === 7 /* AUTHENTICATING */) {\n      this.debug(\"Already authenticating, ignoring\");\n      return;\n    }\n    this._status = 6 /* AUTH_REQUESTED */;\n    if (authPolicy) {\n      if (this._status >= 5 /* CONNECTED */) {\n        this._status = 7 /* AUTHENTICATING */;\n        let res;\n        try {\n          res = await authPolicy(this.ndkRelay, challenge);\n        } catch (e) {\n          this.debug(\"Authentication policy threw an error\", e);\n          res = false;\n        }\n        this.debug(\"Authentication policy returned\", !!res);\n        if (res instanceof NDKEvent || res === true) {\n          if (res instanceof NDKEvent) {\n            await this.auth(res);\n          }\n          const authenticate = async () => {\n            if (this._status >= 5 /* CONNECTED */ && this._status < 8 /* AUTHENTICATED */) {\n              const event = new NDKEvent(this.ndk);\n              event.kind = 22242 /* ClientAuth */;\n              event.tags = [\n                [\"relay\", this.ndkRelay.url],\n                [\"challenge\", challenge]\n              ];\n              await event.sign();\n              this.auth(event).then(() => {\n                this._status = 8 /* AUTHENTICATED */;\n                this.ndkRelay.emit(\"authed\");\n                this.debug(\"Authentication successful\");\n              }).catch((e) => {\n                this._status = 6 /* AUTH_REQUESTED */;\n                this.ndkRelay.emit(\"auth:failed\", e);\n                this.debug(\"Authentication failed\", e);\n              });\n            } else {\n              this.debug(\n                \"Authentication failed, it changed status, status is %d\",\n                this._status\n              );\n            }\n          };\n          if (res === true) {\n            if (!this.ndk?.signer) {\n              this.debug(\"No signer available for authentication localhost\");\n              this.ndk?.once(\"signer:ready\", authenticate);\n            } else {\n              authenticate().catch((e) => {\n                console.error(\"Error authenticating\", e);\n              });\n            }\n          }\n          this._status = 5 /* CONNECTED */;\n          this.ndkRelay.emit(\"authed\");\n        }\n      }\n    } else {\n      this.ndkRelay.emit(\"auth\", challenge);\n    }\n  }\n  /**\n   * Handles errors that occur on the WebSocket connection to the relay.\n   * @param error - The error or event that occurred.\n   */\n  onError(error) {\n    this.debug(`WebSocket error on ${this.ndkRelay.url}:`, error);\n  }\n  /**\n   * Gets the current status of the NDK relay connection.\n   * @returns {NDKRelayStatus} The current status of the NDK relay connection.\n   */\n  get status() {\n    return this._status;\n  }\n  /**\n   * Checks if the NDK relay connection is currently available.\n   * @returns {boolean} `true` if the relay connection is in the `CONNECTED` status, `false` otherwise.\n   */\n  isAvailable() {\n    return this._status === 5 /* CONNECTED */;\n  }\n  /**\n   * Checks if the NDK relay connection is flapping, which means the connection is rapidly\n   * disconnecting and reconnecting. This is determined by analyzing the durations of the\n   * last three connection attempts. If the standard deviation of the durations is less\n   * than 1000 milliseconds, the connection is considered to be flapping.\n   *\n   * @returns {boolean} `true` if the connection is flapping, `false` otherwise.\n   */\n  isFlapping() {\n    const durations = this._connectionStats.durations;\n    if (durations.length % 3 !== 0) return false;\n    const sum = durations.reduce((a, b) => a + b, 0);\n    const avg = sum / durations.length;\n    const variance = durations.map((x) => Math.pow(x - avg, 2)).reduce((a, b) => a + b, 0) / durations.length;\n    const stdDev = Math.sqrt(variance);\n    const isFlapping = stdDev < FLAPPING_THRESHOLD_MS;\n    return isFlapping;\n  }\n  /**\n   * Handles a notice received from the NDK relay.\n   * If the notice indicates the relay is complaining (e.g. \"too many\" or \"maximum\"),\n   * the method disconnects from the relay and attempts to reconnect after a 2-second delay.\n   * A debug message is logged with the relay URL and the notice text.\n   * The \"notice\" event is emitted on the ndkRelay instance with the notice text.\n   *\n   * @param notice - The notice text received from the NDK relay.\n   */\n  async onNotice(notice) {\n    this.ndkRelay.emit(\"notice\", notice);\n  }\n  /**\n   * Attempts to reconnect to the NDK relay after a connection is lost.\n   * This function is called recursively to handle multiple reconnection attempts.\n   * It checks if the relay is flapping and emits a \"flapping\" event if so.\n   * It then calculates a delay before the next reconnection attempt based on the number of previous attempts.\n   * The function sets a timeout to execute the next reconnection attempt after the calculated delay.\n   * If the maximum number of reconnection attempts is reached, a debug message is logged.\n   *\n   * @param attempt - The current attempt number (default is 0).\n   */\n  handleReconnection(attempt = 0) {\n    if (this.reconnectTimeout) return;\n    if (this.isFlapping()) {\n      this.ndkRelay.emit(\"flapping\", this._connectionStats);\n      this._status = 3 /* FLAPPING */;\n      return;\n    }\n    const reconnectDelay = this.connectedAt ? Math.max(0, 6e4 - (Date.now() - this.connectedAt)) : 5e3 * (this._connectionStats.attempts + 1);\n    this.reconnectTimeout = setTimeout(() => {\n      this.reconnectTimeout = void 0;\n      this._status = 2 /* RECONNECTING */;\n      this.connect().catch((err) => {\n        if (attempt < MAX_RECONNECT_ATTEMPTS) {\n          setTimeout(\n            () => {\n              this.handleReconnection(attempt + 1);\n            },\n            1e3 * (attempt + 1) ^ 4\n          );\n        } else {\n          this.debug(\"Reconnect failed\");\n        }\n      });\n    }, reconnectDelay);\n    this.ndkRelay.emit(\"delayed-connect\", reconnectDelay);\n    this.debug(\"Reconnecting in\", reconnectDelay);\n    this._connectionStats.nextReconnectAt = Date.now() + reconnectDelay;\n  }\n  /**\n   * Sends a message to the NDK relay if the connection is in the CONNECTED state and the WebSocket is open.\n   * If the connection is not in the CONNECTED state or the WebSocket is not open, logs a debug message and throws an error.\n   *\n   * @param message - The message to send to the NDK relay.\n   * @throws {Error} If attempting to send on a closed relay connection.\n   */\n  async send(message) {\n    if (this._status >= 5 /* CONNECTED */ && this.ws?.readyState === WebSocket.OPEN) {\n      this.ws?.send(message);\n      this.netDebug?.(message, this.ndkRelay, \"send\");\n    } else {\n      this.debug(\n        `Not connected to ${this.ndkRelay.url} (%d), not sending message ${message}`,\n        this._status\n      );\n    }\n  }\n  /**\n   * Authenticates the NDK event by sending it to the NDK relay and returning a promise that resolves with the result.\n   *\n   * @param event - The NDK event to authenticate.\n   * @returns A promise that resolves with the authentication result.\n   */\n  async auth(event) {\n    const ret = new Promise((resolve, reject) => {\n      const val = this.openEventPublishes.get(event.id) ?? [];\n      val.push({ resolve, reject });\n      this.openEventPublishes.set(event.id, val);\n    });\n    this.send('[\"AUTH\",' + JSON.stringify(event.rawEvent()) + \"]\");\n    return ret;\n  }\n  /**\n   * Publishes an NDK event to the relay and returns a promise that resolves with the result.\n   *\n   * @param event - The NDK event to publish.\n   * @returns A promise that resolves with the result of the event publication.\n   * @throws {Error} If attempting to publish on a closed relay connection.\n   */\n  async publish(event) {\n    const ret = new Promise((resolve, reject) => {\n      const val = this.openEventPublishes.get(event.id) ?? [];\n      if (val.length > 0) {\n        console.warn(\n          \"Duplicate event publishing detected, you are publishing event \" + event.id + \" twice\"\n        );\n      }\n      val.push({ resolve, reject });\n      this.openEventPublishes.set(event.id, val);\n    });\n    this.send('[\"EVENT\",' + JSON.stringify(event) + \"]\");\n    return ret;\n  }\n  /**\n   * Counts the number of events that match the provided filters.\n   *\n   * @param filters - The filters to apply to the count request.\n   * @param params - An optional object containing a custom id for the count request.\n   * @returns A promise that resolves with the number of matching events.\n   * @throws {Error} If attempting to send the count request on a closed relay connection.\n   */\n  async count(filters, params) {\n    this.serial++;\n    const id = params?.id || \"count:\" + this.serial;\n    const ret = new Promise((resolve, reject) => {\n      this.openCountRequests.set(id, { resolve, reject });\n    });\n    this.send('[\"COUNT\",\"' + id + '\",' + JSON.stringify(filters).substring(1));\n    return ret;\n  }\n  close(subId, reason) {\n    this.send('[\"CLOSE\",\"' + subId + '\"]');\n    const sub = this.openSubs.get(subId);\n    this.openSubs.delete(subId);\n    if (sub) sub.onclose(reason);\n  }\n  /**\n   * Subscribes to the NDK relay with the provided filters and parameters.\n   *\n   * @param filters - The filters to apply to the subscription.\n   * @param params - The subscription parameters, including an optional custom id.\n   * @returns A new NDKRelaySubscription instance.\n   */\n  req(relaySub) {\n    this.send(\n      '[\"REQ\",\"' + relaySub.subId + '\",' + JSON.stringify(relaySub.executeFilters).substring(1)\n    ) + \"]\";\n    this.openSubs.set(relaySub.subId, relaySub);\n  }\n  /**\n   * Utility functions to update the connection stats.\n   */\n  updateConnectionStats = {\n    connected: () => {\n      this._connectionStats.success++;\n      this._connectionStats.connectedAt = Date.now();\n    },\n    disconnected: () => {\n      if (this._connectionStats.connectedAt) {\n        this._connectionStats.durations.push(\n          Date.now() - this._connectionStats.connectedAt\n        );\n        if (this._connectionStats.durations.length > 100) {\n          this._connectionStats.durations.shift();\n        }\n      }\n      this._connectionStats.connectedAt = void 0;\n    },\n    attempt: () => {\n      this._connectionStats.attempts++;\n      this._connectionStats.connectedAt = Date.now();\n    }\n  };\n  /** Returns the connection stats. */\n  get connectionStats() {\n    return this._connectionStats;\n  }\n  /** Returns the relay URL */\n  get url() {\n    return this.ndkRelay.url;\n  }\n  get connected() {\n    return this._status >= 5 /* CONNECTED */ && this.ws?.readyState === WebSocket.OPEN;\n  }\n};\n\n// src/relay/publisher.ts\nvar NDKRelayPublisher = class {\n  ndkRelay;\n  debug;\n  constructor(ndkRelay) {\n    this.ndkRelay = ndkRelay;\n    this.debug = ndkRelay.debug.extend(\"publisher\");\n  }\n  /**\n   * Published an event to the relay; if the relay is not connected, it will\n   * wait for the relay to connect before publishing the event.\n   *\n   * If the relay does not connect within the timeout, the publish operation\n   * will fail.\n   * @param event  The event to publish\n   * @param timeoutMs  The timeout for the publish operation in milliseconds\n   * @returns A promise that resolves when the event has been published or rejects if the operation times out\n   */\n  async publish(event, timeoutMs = 2500) {\n    let timeout;\n    const publishConnected = () => {\n      return new Promise((resolve, reject) => {\n        try {\n          this.publishEvent(event).then((result) => {\n            this.ndkRelay.emit(\"published\", event);\n            event.emit(\"relay:published\", this.ndkRelay);\n            resolve(true);\n          }).catch(reject);\n        } catch (err) {\n          reject(err);\n        }\n      });\n    };\n    const timeoutPromise = new Promise((_, reject) => {\n      timeout = setTimeout(() => {\n        timeout = void 0;\n        reject(new Error(\"Timeout: \" + timeoutMs + \"ms\"));\n      }, timeoutMs);\n    });\n    const onConnectHandler = () => {\n      publishConnected().then((result) => connectResolve(result)).catch((err) => connectReject(err));\n    };\n    let connectResolve;\n    let connectReject;\n    const onError = (err) => {\n      this.ndkRelay.debug(\"Publish failed\", err, event.id);\n      this.ndkRelay.emit(\"publish:failed\", event, err);\n      event.emit(\"relay:publish:failed\", this.ndkRelay, err);\n      throw err;\n    };\n    const onFinally = () => {\n      if (timeout) clearTimeout(timeout);\n      this.ndkRelay.removeListener(\"connect\", onConnectHandler);\n    };\n    if (this.ndkRelay.status >= 5 /* CONNECTED */) {\n      return Promise.race([publishConnected(), timeoutPromise]).catch(onError).finally(onFinally);\n    } else {\n      if (this.ndkRelay.status <= 1 /* DISCONNECTED */) {\n        console.warn(\n          \"Relay is disconnected, trying to connect to publish an event\",\n          this.ndkRelay.url\n        );\n        this.ndkRelay.connect();\n      } else {\n        console.warn(\n          \"Relay not connected, waiting for connection to publish an event\",\n          this.ndkRelay.url\n        );\n      }\n      return Promise.race([\n        new Promise((resolve, reject) => {\n          connectResolve = resolve;\n          connectReject = reject;\n          this.ndkRelay.once(\"connect\", onConnectHandler);\n        }),\n        timeoutPromise\n      ]).catch(onError).finally(onFinally);\n    }\n  }\n  async publishEvent(event) {\n    return this.ndkRelay.connectivity.publish(event.rawEvent());\n  }\n};\n\n// src/subscription/grouping.ts\nfunction filterFingerprint(filters, closeOnEose) {\n  const elements = [];\n  for (const filter of filters) {\n    const keys = Object.entries(filter || {}).map(([key, values]) => {\n      if ([\"since\", \"until\"].includes(key)) {\n        return key + \":\" + values;\n      } else {\n        return key;\n      }\n    }).sort().join(\"-\");\n    elements.push(keys);\n  }\n  let id = closeOnEose ? \"+\" : \"\";\n  id += elements.join(\"|\");\n  return id;\n}\nfunction mergeFilters(filters) {\n  const result = [];\n  const lastResult = {};\n  filters.filter((f) => !!f.limit).forEach((filterWithLimit) => result.push(filterWithLimit));\n  filters = filters.filter((f) => !f.limit);\n  if (filters.length === 0) return result;\n  filters.forEach((filter) => {\n    Object.entries(filter).forEach(([key, value]) => {\n      if (Array.isArray(value)) {\n        if (lastResult[key] === void 0) {\n          lastResult[key] = [...value];\n        } else {\n          lastResult[key] = Array.from(/* @__PURE__ */ new Set([...lastResult[key], ...value]));\n        }\n      } else {\n        lastResult[key] = value;\n      }\n    });\n  });\n  return [...result, lastResult];\n}\n\n// src/relay/subscription.ts\nvar NDKRelaySubscription = class {\n  fingerprint;\n  items = /* @__PURE__ */ new Map();\n  topSubManager;\n  debug;\n  /**\n   * Tracks the status of this REQ.\n   */\n  status = 0 /* INITIAL */;\n  onClose;\n  relay;\n  /**\n   * Whether this subscription has reached EOSE.\n   */\n  eosed = false;\n  /**\n   * Timeout at which this subscription will\n   * start executing.\n   */\n  executionTimer;\n  /**\n   * Track the time at which this subscription will fire.\n   */\n  fireTime;\n  /**\n   * The delay type that the current fireTime was calculated with.\n   */\n  delayType;\n  /**\n   * The filters that have been executed.\n   */\n  executeFilters;\n  id = Math.random().toString(36).substring(7);\n  /**\n   *\n   * @param fingerprint The fingerprint of this subscription.\n   */\n  constructor(relay, fingerprint, topSubManager) {\n    this.relay = relay;\n    this.topSubManager = topSubManager;\n    this.debug = relay.debug.extend(\"subscription-\" + this.id);\n    this.fingerprint = fingerprint || Math.random().toString(36).substring(7);\n  }\n  _subId;\n  get subId() {\n    if (this._subId) return this._subId;\n    this._subId = this.fingerprint.slice(0, 15);\n    return this._subId;\n  }\n  subIdParts = /* @__PURE__ */ new Set();\n  addSubIdPart(part) {\n    this.subIdParts.add(part);\n  }\n  addItem(subscription, filters) {\n    this.debug(\"Adding item\", { filters, internalId: subscription.internalId, status: this.status, fingerprint: this.fingerprint, id: this.subId, items: this.items, itemsSize: this.items.size });\n    if (this.items.has(subscription.internalId)) return;\n    subscription.on(\"close\", this.removeItem.bind(this, subscription));\n    this.items.set(subscription.internalId, { subscription, filters });\n    if (this.status !== 3 /* RUNNING */) {\n      if (subscription.subId && (!this._subId || this._subId.length < 48)) {\n        if (this.status === 0 /* INITIAL */ || this.status === 1 /* PENDING */) {\n          this.addSubIdPart(subscription.subId);\n        }\n      }\n    }\n    switch (this.status) {\n      case 0 /* INITIAL */:\n        this.evaluateExecutionPlan(subscription);\n        break;\n      case 3 /* RUNNING */:\n        console.log(\n          \"BUG: This should not happen: This subscription needs to catch up with a subscription that was already running\",\n          filters\n        );\n        break;\n      case 1 /* PENDING */:\n        this.evaluateExecutionPlan(subscription);\n        break;\n      case 4 /* CLOSED */:\n        this.debug(\n          \"Subscription is closed, cannot add new items %o (%o)\",\n          subscription,\n          filters\n        );\n        throw new Error(\"Cannot add new items to a closed subscription\");\n    }\n  }\n  /**\n   * A subscription has been closed, remove it from the list of items.\n   * @param subscription\n   */\n  removeItem(subscription) {\n    this.items.delete(subscription.internalId);\n    if (this.items.size === 0) {\n      if (!this.eosed) return;\n      this.close();\n      this.cleanup();\n    }\n  }\n  close() {\n    if (this.status === 4 /* CLOSED */) return;\n    const prevStatus = this.status;\n    this.status = 4 /* CLOSED */;\n    if (prevStatus === 3 /* RUNNING */) {\n      try {\n        this.relay.close(this.subId);\n      } catch (e) {\n        this.debug(\"Error closing subscription\", e, this);\n      }\n    } else {\n      this.debug(\"Subscription wanted to close but it wasn't running, this is probably ok\", {\n        subId: this.subId,\n        prevStatus,\n        sub: this\n      });\n    }\n    this.cleanup();\n  }\n  cleanup() {\n    if (this.executionTimer) clearTimeout(this.executionTimer);\n    this.relay.off(\"ready\", this.executeOnRelayReady);\n    this.relay.off(\"authed\", this.reExecuteAfterAuth);\n    if (this.onClose) this.onClose(this);\n  }\n  evaluateExecutionPlan(subscription) {\n    if (!subscription.isGroupable()) {\n      this.status = 1 /* PENDING */;\n      this.execute();\n      return;\n    }\n    if (subscription.filters.find((filter) => !!filter.limit)) {\n      this.executeFilters = this.compileFilters();\n      if (this.executeFilters.length >= 10) {\n        this.status = 1 /* PENDING */;\n        this.execute();\n        return;\n      }\n    }\n    const delay = subscription.groupableDelay;\n    const delayType = subscription.groupableDelayType;\n    if (!delay) throw new Error(\"Cannot group a subscription without a delay\");\n    if (this.status === 0 /* INITIAL */) {\n      this.schedule(delay, delayType);\n    } else {\n      const existingDelayType = this.delayType;\n      const timeUntilFire = this.fireTime - Date.now();\n      if (existingDelayType === \"at-least\" && delayType === \"at-least\") {\n        if (timeUntilFire < delay) {\n          if (this.executionTimer) clearTimeout(this.executionTimer);\n          this.schedule(delay, delayType);\n        }\n      } else if (existingDelayType === \"at-least\" && delayType === \"at-most\") {\n        if (timeUntilFire > delay) {\n          if (this.executionTimer) clearTimeout(this.executionTimer);\n          this.schedule(delay, delayType);\n        }\n      } else if (existingDelayType === \"at-most\" && delayType === \"at-most\") {\n        if (timeUntilFire > delay) {\n          if (this.executionTimer) clearTimeout(this.executionTimer);\n          this.schedule(delay, delayType);\n        }\n      } else if (existingDelayType === \"at-most\" && delayType === \"at-least\") {\n        if (timeUntilFire > delay) {\n          if (this.executionTimer) clearTimeout(this.executionTimer);\n          this.schedule(delay, delayType);\n        }\n      } else {\n        throw new Error(\n          \"Unknown delay type combination \" + existingDelayType + \" \" + delayType\n        );\n      }\n    }\n  }\n  schedule(delay, delayType) {\n    this.status = 1 /* PENDING */;\n    const currentTime = Date.now();\n    this.fireTime = currentTime + delay;\n    this.delayType = delayType;\n    const timer = setTimeout(this.execute.bind(this), delay);\n    if (delayType === \"at-least\") {\n      this.executionTimer = timer;\n    }\n  }\n  executeOnRelayReady = () => {\n    if (this.status !== 2 /* WAITING */) return;\n    if (this.items.size === 0) {\n      this.debug(\"No items to execute; this relay was probably too slow to respond and the caller gave up\", { status: this.status, fingerprint: this.fingerprint, items: this.items, itemsSize: this.items.size, id: this.id, subId: this.subId });\n      this.cleanup();\n      return;\n    }\n    this.debug(\"Executing on relay ready\", { status: this.status, fingerprint: this.fingerprint, items: this.items, itemsSize: this.items.size });\n    this.status = 1 /* PENDING */;\n    this.execute();\n  };\n  finalizeSubId() {\n    if (this.subIdParts.size > 0) {\n      this._subId = Array.from(this.subIdParts).join(\"-\");\n    } else {\n      this._subId = this.fingerprint.slice(0, 15);\n    }\n    this._subId += \"-\" + Math.random().toString(36).substring(2, 7);\n  }\n  // we do it this way so that we can remove the listener\n  reExecuteAfterAuth = (() => {\n    const oldSubId = this.subId;\n    this.debug(\"Re-executing after auth\", this.items.size);\n    if (this.eosed) {\n      this.relay.close(this.subId);\n    } else {\n      this.debug(\n        \"We are abandoning an opened subscription, once it EOSE's, the handler will close it\",\n        { oldSubId }\n      );\n    }\n    this._subId = void 0;\n    this.status = 1 /* PENDING */;\n    this.execute();\n    this.debug(\"Re-executed after auth %s \\u{1F449} %s\", oldSubId, this.subId);\n  }).bind(this);\n  execute() {\n    if (this.status !== 1 /* PENDING */) {\n      return;\n    }\n    if (!this.relay.connected) {\n      this.status = 2 /* WAITING */;\n      this.debug(\"Waiting for relay to be ready\", { status: this.status, id: this.subId, fingerprint: this.fingerprint, items: this.items, itemsSize: this.items.size });\n      this.relay.once(\"ready\", this.executeOnRelayReady);\n      return;\n    } else if (this.relay.status < 8 /* AUTHENTICATED */) {\n      this.relay.once(\"authed\", this.reExecuteAfterAuth);\n    }\n    this.status = 3 /* RUNNING */;\n    this.finalizeSubId();\n    this.executeFilters = this.compileFilters();\n    this.relay.req(this);\n  }\n  onstart() {\n  }\n  onevent(event) {\n    this.topSubManager.dispatchEvent(event, this.relay);\n  }\n  oneose(subId) {\n    this.eosed = true;\n    if (subId !== this.subId) {\n      this.debug(\"Received EOSE for an abandoned subscription\", subId, this.subId);\n      this.relay.close(subId);\n      return;\n    }\n    if (this.items.size === 0) {\n      this.close();\n    }\n    for (const { subscription } of this.items.values()) {\n      subscription.eoseReceived(this.relay);\n      if (subscription.closeOnEose) {\n        this.debug(\"Removing item because of EOSE\", { filters: subscription.filters, internalId: subscription.internalId, status: this.status, fingerprint: this.fingerprint, items: this.items, itemsSize: this.items.size });\n        this.removeItem(subscription);\n      }\n    }\n  }\n  onclose(reason) {\n    this.status = 4 /* CLOSED */;\n  }\n  onclosed(reason) {\n    if (!reason) return;\n    for (const { subscription } of this.items.values()) {\n      subscription.closedReceived(this.relay, reason);\n    }\n  }\n  /**\n   * Grabs the filters from all the subscriptions\n   * and merges them into a single filter.\n   */\n  compileFilters() {\n    const mergedFilters = [];\n    const filters = Array.from(this.items.values()).map((item) => item.filters);\n    if (!filters[0]) {\n      this.debug(\"\\u{1F440} No filters to merge\", this.items);\n      console.error(\"BUG: No filters to merge!\", this.items);\n      return [];\n    }\n    const filterCount = filters[0].length;\n    for (let i = 0; i < filterCount; i++) {\n      const allFiltersAtIndex = filters.map((filter) => filter[i]);\n      mergedFilters.push(...mergeFilters(allFiltersAtIndex));\n    }\n    return mergedFilters;\n  }\n};\n\n// src/relay/sub-manager.ts\nvar NDKRelaySubscriptionManager = class {\n  relay;\n  subscriptions;\n  generalSubManager;\n  /**\n   * @param relay - The relay instance.\n   * @param generalSubManager - The subscription manager instance.\n   */\n  constructor(relay, generalSubManager) {\n    this.relay = relay;\n    this.subscriptions = /* @__PURE__ */ new Map();\n    this.generalSubManager = generalSubManager;\n  }\n  /**\n   * Adds a subscription to the manager.\n   */\n  addSubscription(sub, filters) {\n    let relaySub;\n    if (!sub.isGroupable()) {\n      relaySub = this.createSubscription(sub, filters);\n    } else {\n      const filterFp = filterFingerprint(filters, sub.closeOnEose);\n      if (filterFp) {\n        const existingSubs = this.subscriptions.get(filterFp);\n        relaySub = (existingSubs || []).find(\n          (sub2) => sub2.status < 3 /* RUNNING */\n        );\n      }\n      relaySub ??= this.createSubscription(sub, filters, filterFp);\n    }\n    relaySub.addItem(sub, filters);\n  }\n  createSubscription(sub, filters, fingerprint) {\n    const relaySub = new NDKRelaySubscription(this.relay, fingerprint || null, this.generalSubManager);\n    relaySub.onClose = this.onRelaySubscriptionClose.bind(this);\n    const currentVal = this.subscriptions.get(relaySub.fingerprint) ?? [];\n    this.subscriptions.set(relaySub.fingerprint, [...currentVal, relaySub]);\n    return relaySub;\n  }\n  onRelaySubscriptionClose(sub) {\n    let currentVal = this.subscriptions.get(sub.fingerprint) ?? [];\n    if (!currentVal) {\n      console.warn(\n        \"Unexpectedly did not find a subscription with fingerprint\",\n        sub.fingerprint\n      );\n    } else if (currentVal.length === 1) {\n      this.subscriptions.delete(sub.fingerprint);\n    } else {\n      currentVal = currentVal.filter((s) => s.id !== sub.id);\n      this.subscriptions.set(sub.fingerprint, currentVal);\n    }\n  }\n};\n\n// src/relay/index.ts\nvar NDKRelayStatus = /* @__PURE__ */ ((NDKRelayStatus2) => {\n  NDKRelayStatus2[NDKRelayStatus2[\"DISCONNECTING\"] = 0] = \"DISCONNECTING\";\n  NDKRelayStatus2[NDKRelayStatus2[\"DISCONNECTED\"] = 1] = \"DISCONNECTED\";\n  NDKRelayStatus2[NDKRelayStatus2[\"RECONNECTING\"] = 2] = \"RECONNECTING\";\n  NDKRelayStatus2[NDKRelayStatus2[\"FLAPPING\"] = 3] = \"FLAPPING\";\n  NDKRelayStatus2[NDKRelayStatus2[\"CONNECTING\"] = 4] = \"CONNECTING\";\n  NDKRelayStatus2[NDKRelayStatus2[\"CONNECTED\"] = 5] = \"CONNECTED\";\n  NDKRelayStatus2[NDKRelayStatus2[\"AUTH_REQUESTED\"] = 6] = \"AUTH_REQUESTED\";\n  NDKRelayStatus2[NDKRelayStatus2[\"AUTHENTICATING\"] = 7] = \"AUTHENTICATING\";\n  NDKRelayStatus2[NDKRelayStatus2[\"AUTHENTICATED\"] = 8] = \"AUTHENTICATED\";\n  return NDKRelayStatus2;\n})(NDKRelayStatus || {});\nvar NDKRelay = class _NDKRelay extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  url;\n  scores;\n  connectivity;\n  subs;\n  publisher;\n  authPolicy;\n  /**\n   * The lowest validation ratio this relay can reach.\n   */\n  lowestValidationRatio;\n  /**\n   * Current validation ratio this relay is targeting.\n   */\n  targetValidationRatio;\n  validationRatioFn;\n  /**\n   * This tracks events that have been seen by this relay\n   * with a valid signature.\n   */\n  validatedEventCount = 0;\n  /**\n   * This tracks events that have been seen by this relay\n   * but have not been validated.\n   */\n  nonValidatedEventCount = 0;\n  /**\n   * Whether this relay is trusted.\n   *\n   * Trusted relay's events do not get their signature verified.\n   */\n  trusted = false;\n  complaining = false;\n  debug;\n  static defaultValidationRatioUpdateFn = (relay, validatedCount, nonValidatedCount) => {\n    if (relay.lowestValidationRatio === void 0 || relay.targetValidationRatio === void 0)\n      return 1;\n    let newRatio = relay.validationRatio;\n    if (relay.validationRatio > relay.targetValidationRatio) {\n      const factor = validatedCount / 100;\n      newRatio = Math.max(relay.lowestValidationRatio, relay.validationRatio - factor);\n    }\n    if (newRatio < relay.validationRatio) {\n      return newRatio;\n    }\n    return relay.validationRatio;\n  };\n  constructor(url, authPolicy, ndk) {\n    super();\n    this.url = normalizeRelayUrl(url);\n    this.scores = /* @__PURE__ */ new Map();\n    this.debug = debug__WEBPACK_IMPORTED_MODULE_1__(`ndk:relay:${url}`);\n    this.connectivity = new NDKRelayConnectivity(this, ndk);\n    this.connectivity.netDebug = ndk?.netDebug;\n    this.req = this.connectivity.req.bind(this.connectivity);\n    this.close = this.connectivity.close.bind(this.connectivity);\n    this.subs = new NDKRelaySubscriptionManager(this, ndk.subManager);\n    this.publisher = new NDKRelayPublisher(this);\n    this.authPolicy = authPolicy;\n    this.targetValidationRatio = ndk?.initialValidationRatio;\n    this.lowestValidationRatio = ndk?.lowestValidationRatio;\n    this.validationRatioFn = (ndk?.validationRatioFn ?? _NDKRelay.defaultValidationRatioUpdateFn).bind(this);\n    this.updateValidationRatio();\n    if (!ndk) {\n      console.trace(\"relay created without ndk\");\n    }\n  }\n  updateValidationRatio() {\n    setTimeout(() => {\n      this.updateValidationRatio();\n    }, 3e4);\n  }\n  get status() {\n    return this.connectivity.status;\n  }\n  get connectionStats() {\n    return this.connectivity.connectionStats;\n  }\n  /**\n   * Connects to the relay.\n   */\n  async connect(timeoutMs, reconnect = true) {\n    return this.connectivity.connect(timeoutMs, reconnect);\n  }\n  /**\n   * Disconnects from the relay.\n   */\n  disconnect() {\n    if (this.status === 1 /* DISCONNECTED */) {\n      return;\n    }\n    this.connectivity.disconnect();\n  }\n  /**\n   * Queues or executes the subscription of a specific set of filters\n   * within this relay.\n   *\n   * @param subscription NDKSubscription this filters belong to.\n   * @param filters Filters to execute\n   */\n  subscribe(subscription, filters) {\n    this.subs.addSubscription(subscription, filters);\n  }\n  /**\n   * Publishes an event to the relay with an optional timeout.\n   *\n   * If the relay is not connected, the event will be published when the relay connects,\n   * unless the timeout is reached before the relay connects.\n   *\n   * @param event The event to publish\n   * @param timeoutMs The timeout for the publish operation in milliseconds\n   * @returns A promise that resolves when the event has been published or rejects if the operation times out\n   */\n  async publish(event, timeoutMs = 2500) {\n    return this.publisher.publish(event, timeoutMs);\n  }\n  referenceTags() {\n    return [[\"r\", this.url]];\n  }\n  addValidatedEvent() {\n    this.validatedEventCount++;\n  }\n  addNonValidatedEvent() {\n    this.nonValidatedEventCount++;\n  }\n  /**\n   * The current validation ratio this relay has achieved.\n   */\n  get validationRatio() {\n    if (this.nonValidatedEventCount === 0) {\n      return 1;\n    }\n    return this.validatedEventCount / (this.validatedEventCount + this.nonValidatedEventCount);\n  }\n  shouldValidateEvent() {\n    if (this.trusted) {\n      return false;\n    }\n    if (this.targetValidationRatio === void 0) {\n      return true;\n    }\n    return this.validationRatio < this.targetValidationRatio;\n  }\n  get connected() {\n    return this.connectivity.connected;\n  }\n  req;\n  close;\n};\n\n// src/relay/sets/index.ts\nvar NDKPublishError = class extends Error {\n  errors;\n  publishedToRelays;\n  /**\n   * Intended relay set where the publishing was intended to happen.\n   */\n  intendedRelaySet;\n  constructor(message, errors, publishedToRelays, intendedRelaySet) {\n    super(message);\n    this.errors = errors;\n    this.publishedToRelays = publishedToRelays;\n    this.intendedRelaySet = intendedRelaySet;\n  }\n  get relayErrors() {\n    const errors = [];\n    for (const [relay, err] of this.errors) {\n      errors.push(`${relay.url}: ${err}`);\n    }\n    return errors.join(\"\\n\");\n  }\n};\nvar NDKRelaySet = class _NDKRelaySet {\n  relays;\n  debug;\n  ndk;\n  pool;\n  constructor(relays, ndk, pool) {\n    this.relays = relays;\n    this.ndk = ndk;\n    this.pool = pool ?? ndk.pool;\n    this.debug = ndk.debug.extend(\"relayset\");\n  }\n  /**\n   * Adds a relay to this set.\n   */\n  addRelay(relay) {\n    this.relays.add(relay);\n  }\n  get relayUrls() {\n    return Array.from(this.relays).map((r) => r.url);\n  }\n  /**\n   * Creates a relay set from a list of relay URLs.\n   *\n   * If no connection to the relay is found in the pool it will temporarily\n   * connect to it.\n   *\n   * @param relayUrls - list of relay URLs to include in this set\n   * @param ndk\n   * @param connect - whether to connect to the relay immediately if it was already in the pool but not connected\n   * @returns NDKRelaySet\n   */\n  static fromRelayUrls(relayUrls, ndk, connect = true, pool) {\n    pool = pool ?? ndk.pool;\n    if (!pool) throw new Error(\"No pool provided\");\n    const relays = /* @__PURE__ */ new Set();\n    for (const url of relayUrls) {\n      const relay = pool.relays.get(normalizeRelayUrl(url));\n      if (relay) {\n        if (relay.status < 5 /* CONNECTED */ && connect) {\n          relay.connect();\n        }\n        relays.add(relay);\n      } else {\n        const temporaryRelay = new NDKRelay(\n          normalizeRelayUrl(url),\n          ndk?.relayAuthDefaultPolicy,\n          ndk\n        );\n        pool.useTemporaryRelay(\n          temporaryRelay,\n          void 0,\n          \"requested from fromRelayUrls \" + relayUrls\n        );\n        relays.add(temporaryRelay);\n      }\n    }\n    return new _NDKRelaySet(new Set(relays), ndk, pool);\n  }\n  /**\n   * Publish an event to all relays in this set. Returns the number of relays that have received the event.\n   * @param event\n   * @param timeoutMs - timeout in milliseconds for each publish operation and connection operation\n   * @returns A set where the event was successfully published to\n   * @throws NDKPublishError if no relay was able to receive the event\n   * @example\n   * ```typescript\n   * const event = new NDKEvent(ndk, {kinds: [NDKKind.Message], \"#d\": [\"123\"]});\n   * try {\n   *    const publishedToRelays = await relaySet.publish(event);\n   *    console.log(`published to ${publishedToRelays.size} relays`)\n   * } catch (error) {\n   *   console.error(\"error publishing to relays\", error);\n   *\n   *   if (error instanceof NDKPublishError) {\n   *      for (const [relay, err] of error.errors) {\n   *         console.error(`error publishing to relay ${relay.url}`, err);\n   *       }\n   *   }\n   * }\n   * ```\n   */\n  async publish(event, timeoutMs, requiredRelayCount = 1) {\n    const publishedToRelays = /* @__PURE__ */ new Set();\n    const errors = /* @__PURE__ */ new Map();\n    const isEphemeral2 = event.isEphemeral();\n    event.publishStatus = \"pending\";\n    const promises = Array.from(this.relays).map((relay) => {\n      return new Promise((resolve) => {\n        relay.publish(event, timeoutMs).then((e) => {\n          publishedToRelays.add(relay);\n          resolve();\n        }).catch((err) => {\n          if (!isEphemeral2) {\n            errors.set(relay, err);\n          }\n          resolve();\n        });\n      });\n    });\n    await Promise.all(promises);\n    if (publishedToRelays.size < requiredRelayCount) {\n      if (!isEphemeral2) {\n        const error = new NDKPublishError(\n          \"Not enough relays received the event\",\n          errors,\n          publishedToRelays,\n          this\n        );\n        event.publishStatus = \"error\";\n        event.publishError = error;\n        this.ndk.emit(\"event:publish-failed\", event, error, this.relayUrls);\n        throw error;\n      }\n    } else {\n      event.emit(\"published\", { relaySet: this, publishedToRelays });\n    }\n    return publishedToRelays;\n  }\n  get size() {\n    return this.relays.size;\n  }\n};\n\n// src/relay/sets/calculate.ts\n\nvar d = debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:outbox:calculate\");\nasync function calculateRelaySetFromEvent(ndk, event) {\n  const relays = /* @__PURE__ */ new Set();\n  const authorWriteRelays = await getWriteRelaysFor(ndk, event.pubkey);\n  if (authorWriteRelays) {\n    authorWriteRelays.forEach((relayUrl) => {\n      const relay = ndk.pool?.getRelay(relayUrl);\n      if (relay) relays.add(relay);\n    });\n  }\n  let relayHints = event.tags.filter((tag) => [\"a\", \"e\"].includes(tag[0])).map((tag) => tag[2]).filter((url) => url && url.startsWith(\"wss://\")).filter((url) => {\n    try {\n      new URL(url);\n      return true;\n    } catch {\n      return false;\n    }\n  }).map((url) => normalizeRelayUrl(url));\n  relayHints = Array.from(new Set(relayHints)).slice(0, 5);\n  relayHints.forEach((relayUrl) => {\n    const relay = ndk.pool?.getRelay(relayUrl, true, true);\n    if (relay) {\n      d(\"Adding relay hint %s\", relayUrl);\n      relays.add(relay);\n    }\n  });\n  const pTags = event.getMatchingTags(\"p\").map((tag) => tag[1]);\n  if (pTags.length < 5) {\n    const pTaggedRelays = Array.from(\n      chooseRelayCombinationForPubkeys(ndk, pTags, \"read\", {\n        preferredRelays: new Set(authorWriteRelays)\n      }).keys()\n    );\n    pTaggedRelays.forEach((relayUrl) => {\n      const relay = ndk.pool?.getRelay(relayUrl, false, true);\n      if (relay) {\n        d(\"Adding p-tagged relay %s\", relayUrl);\n        relays.add(relay);\n      }\n    });\n  } else {\n    d(\"Too many p-tags to consider %d\", pTags.length);\n  }\n  ndk.pool?.permanentAndConnectedRelays().forEach((relay) => relays.add(relay));\n  return new NDKRelaySet(relays, ndk);\n}\nfunction calculateRelaySetsFromFilter(ndk, filters, pool) {\n  const result = /* @__PURE__ */ new Map();\n  const authors = /* @__PURE__ */ new Set();\n  filters.forEach((filter) => {\n    if (filter.authors) {\n      filter.authors.forEach((author) => authors.add(author));\n    }\n  });\n  if (authors.size > 0) {\n    const authorToRelaysMap = getRelaysForFilterWithAuthors(ndk, Array.from(authors));\n    for (const relayUrl of authorToRelaysMap.keys()) {\n      result.set(relayUrl, []);\n    }\n    for (const filter of filters) {\n      if (filter.authors) {\n        for (const [relayUrl, authors2] of authorToRelaysMap.entries()) {\n          const authorFilterAndRelayPubkeyIntersection = filter.authors.filter(\n            (author) => authors2.includes(author)\n          );\n          result.set(relayUrl, [\n            ...result.get(relayUrl),\n            {\n              ...filter,\n              // Overwrite authors sent to this relay with the authors that were\n              // present in the filter and are also present in the relay\n              authors: authorFilterAndRelayPubkeyIntersection\n            }\n          ]);\n        }\n      } else {\n        for (const relayUrl of authorToRelaysMap.keys()) {\n          result.set(relayUrl, [...result.get(relayUrl), filter]);\n        }\n      }\n    }\n  } else {\n    if (ndk.explicitRelayUrls) {\n      ndk.explicitRelayUrls.forEach((relayUrl) => {\n        result.set(relayUrl, filters);\n      });\n    }\n  }\n  if (result.size === 0) {\n    pool.permanentAndConnectedRelays().slice(0, 5).forEach((relay) => {\n      result.set(relay.url, filters);\n    });\n  }\n  return result;\n}\nfunction calculateRelaySetsFromFilters(ndk, filters, pool) {\n  const a = calculateRelaySetsFromFilter(ndk, filters, pool);\n  return a;\n}\n\n// src/events/content-tagger.ts\n\nfunction mergeTags(tags1, tags2) {\n  const tagMap = /* @__PURE__ */ new Map();\n  const generateKey = (tag) => tag.join(\",\");\n  const isContained = (smaller, larger) => {\n    return smaller.every((value, index) => value === larger[index]);\n  };\n  const processTag = (tag) => {\n    for (const [key, existingTag] of tagMap) {\n      if (isContained(existingTag, tag) || isContained(tag, existingTag)) {\n        if (tag.length >= existingTag.length) {\n          tagMap.set(key, tag);\n        }\n        return;\n      }\n    }\n    tagMap.set(generateKey(tag), tag);\n  };\n  tags1.concat(tags2).forEach(processTag);\n  return Array.from(tagMap.values());\n}\nfunction uniqueTag(a, b) {\n  const aLength = a.length;\n  const bLength = b.length;\n  const sameLength = aLength === bLength;\n  if (sameLength) {\n    if (a.every((v, i) => v === b[i])) {\n      return [a];\n    } else {\n      return [a, b];\n    }\n  } else if (aLength > bLength && a.every((v, i) => v === b[i])) {\n    return [a];\n  } else if (bLength > aLength && b.every((v, i) => v === a[i])) {\n    return [b];\n  }\n  return [a, b];\n}\nvar hashtagRegex = /(?<=\\s|^)(#[^\\s!@#$%^&*()=+./,[{\\]};:'\"?><]+)/g;\nfunction generateHashtags(content) {\n  const hashtags = content.match(hashtagRegex);\n  const tagIds = /* @__PURE__ */ new Set();\n  const tag = /* @__PURE__ */ new Set();\n  if (hashtags) {\n    for (const hashtag of hashtags) {\n      if (tagIds.has(hashtag.slice(1))) continue;\n      tag.add(hashtag.slice(1));\n      tagIds.add(hashtag.slice(1));\n    }\n  }\n  return Array.from(tag);\n}\nasync function generateContentTags(content, tags = []) {\n  const tagRegex = /(@|nostr:)(npub|nprofile|note|nevent|naddr)[a-zA-Z0-9]+/g;\n  const promises = [];\n  const addTagIfNew = (t) => {\n    if (!tags.find((t2) => [\"q\", t[0]].includes(t2[0]) && t2[1] === t[1])) {\n      tags.push(t);\n    }\n  };\n  content = content.replace(tagRegex, (tag) => {\n    try {\n      const entity = tag.split(/(@|nostr:)/)[2];\n      const { type, data } = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.decode(entity);\n      let t;\n      switch (type) {\n        case \"npub\":\n          t = [\"p\", data];\n          break;\n        case \"nprofile\":\n          t = [\"p\", data.pubkey];\n          break;\n        case \"note\":\n          promises.push(\n            new Promise(async (resolve) => {\n              addTagIfNew([\n                \"q\",\n                data,\n                await maybeGetEventRelayUrl(entity)\n              ]);\n              resolve();\n            })\n          );\n          break;\n        case \"nevent\":\n          promises.push(\n            new Promise(async (resolve) => {\n              const { id, author } = data;\n              let { relays } = data;\n              if (!relays || relays.length === 0) {\n                relays = [await maybeGetEventRelayUrl(entity)];\n              }\n              addTagIfNew([\"q\", id, relays[0]]);\n              if (author) addTagIfNew([\"p\", author]);\n              resolve();\n            })\n          );\n          break;\n        case \"naddr\":\n          promises.push(\n            new Promise(async (resolve) => {\n              const id = [data.kind, data.pubkey, data.identifier].join(\":\");\n              let relays = data.relays ?? [];\n              if (relays.length === 0) {\n                relays = [await maybeGetEventRelayUrl(entity)];\n              }\n              addTagIfNew([\"q\", id, relays[0]]);\n              addTagIfNew([\"p\", data.pubkey]);\n              resolve();\n            })\n          );\n          break;\n        default:\n          return tag;\n      }\n      if (t) addTagIfNew(t);\n      return `nostr:${entity}`;\n    } catch (error) {\n      return tag;\n    }\n  });\n  await Promise.all(promises);\n  const newTags = generateHashtags(content).map((hashtag) => [\"t\", hashtag]);\n  tags = mergeTags(tags, newTags);\n  return { content, tags };\n}\nasync function maybeGetEventRelayUrl(nip19Id) {\n  return \"\";\n}\n\n// src/events/kind.ts\nfunction isReplaceable() {\n  if (this.kind === void 0) throw new Error(\"Kind not set\");\n  return [0, 3].includes(this.kind) || this.kind >= 1e4 && this.kind < 2e4 || this.kind >= 3e4 && this.kind < 4e4;\n}\nfunction isEphemeral() {\n  if (this.kind === void 0) throw new Error(\"Kind not set\");\n  return this.kind >= 2e4 && this.kind < 3e4;\n}\nfunction isParamReplaceable() {\n  if (this.kind === void 0) throw new Error(\"Kind not set\");\n  return this.kind >= 3e4 && this.kind < 4e4;\n}\n\n// src/events/encryption.ts\nasync function encrypt(recipient, signer, scheme = \"nip44\") {\n  let encrypted;\n  if (!this.ndk) throw new Error(\"No NDK instance found!\");\n  if (!signer) {\n    this.ndk.assertSigner();\n    signer = this.ndk.signer;\n  }\n  if (!recipient) {\n    const pTags = this.getMatchingTags(\"p\");\n    if (pTags.length !== 1) {\n      throw new Error(\n        \"No recipient could be determined and no explicit recipient was provided\"\n      );\n    }\n    recipient = this.ndk.getUser({ pubkey: pTags[0][1] });\n  }\n  if (scheme === \"nip44\" && await isEncryptionEnabled(signer, \"nip44\")) {\n    encrypted = await signer?.encrypt(recipient, this.content, \"nip44\");\n  }\n  if ((!encrypted || scheme === \"nip04\") && await isEncryptionEnabled(signer, \"nip04\")) {\n    encrypted = await signer.encrypt(recipient, this.content, \"nip04\");\n  }\n  if (!encrypted) throw new Error(\"Failed to encrypt event.\");\n  this.content = encrypted;\n}\nasync function decrypt(sender, signer, scheme) {\n  let decrypted;\n  if (!this.ndk) throw new Error(\"No NDK instance found!\");\n  if (!signer) {\n    this.ndk.assertSigner();\n    signer = this.ndk.signer;\n  }\n  if (!signer) throw new Error(\"no NDK signer\");\n  if (!sender) {\n    sender = this.author;\n  }\n  if (!scheme) scheme = this.content.match(/\\\\?iv=/) ? \"nip04\" : \"nip44\";\n  if ((scheme === \"nip04\" || this.kind === 4) && await isEncryptionEnabled(signer, \"nip04\") && this.content.search(\"\\\\?iv=\")) {\n    decrypted = await signer.decrypt(sender, this.content, \"nip04\");\n  }\n  if (!decrypted && scheme === \"nip44\" && await isEncryptionEnabled(signer, \"nip44\")) {\n    decrypted = await signer.decrypt(sender, this.content, \"nip44\");\n  }\n  if (!decrypted) throw new Error(\"Failed to decrypt event.\");\n  this.content = decrypted;\n}\nasync function isEncryptionEnabled(signer, scheme) {\n  if (!signer.encryptionEnabled) return false;\n  if (!scheme) return true;\n  return Boolean(await signer.encryptionEnabled(scheme));\n}\n\n// src/events/nip19.ts\n\nvar DEFAULT_RELAY_COUNT = 2;\nfunction encode(maxRelayCount = DEFAULT_RELAY_COUNT) {\n  let relays = [];\n  if (this.onRelays.length > 0) {\n    relays = this.onRelays.map((relay) => relay.url);\n  } else if (this.relay) {\n    relays = [this.relay.url];\n  }\n  if (relays.length > maxRelayCount) {\n    relays = relays.slice(0, maxRelayCount);\n  }\n  if (this.isParamReplaceable()) {\n    return nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.naddrEncode({\n      kind: this.kind,\n      pubkey: this.pubkey,\n      identifier: this.replaceableDTag(),\n      relays\n    });\n  } else if (relays.length > 0) {\n    return nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.neventEncode({\n      id: this.tagId(),\n      relays,\n      author: this.pubkey\n    });\n  } else {\n    return nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.noteEncode(this.tagId());\n  }\n}\n\n// src/events/repost.ts\nasync function repost(publish = true, signer) {\n  if (!signer && publish) {\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    this.ndk.assertSigner();\n    signer = this.ndk.signer;\n  }\n  const e = new NDKEvent(this.ndk, {\n    kind: getKind(this)\n  });\n  if (!this.isProtected)\n    e.content = JSON.stringify(this.rawEvent());\n  e.tag(this);\n  if (this.kind !== 1 /* Text */) {\n    e.tags.push([\"k\", `${this.kind}`]);\n  }\n  if (signer) await e.sign(signer);\n  if (publish) await e.publish();\n  return e;\n}\nfunction getKind(event) {\n  if (event.kind === 1) {\n    return 6 /* Repost */;\n  }\n  return 16 /* GenericRepost */;\n}\n\n// src/thread/index.ts\nfunction eventsBySameAuthor(op, events) {\n  const eventsByAuthor = /* @__PURE__ */ new Map();\n  eventsByAuthor.set(op.id, op);\n  events.forEach((event) => {\n    if (event.pubkey === op.pubkey) {\n      eventsByAuthor.set(event.id, event);\n    }\n  });\n  return eventsByAuthor;\n}\nvar hasMarkers = (event, tagType) => {\n  return event.getMatchingTags(tagType).some((tag) => tag[3] && tag[3] !== \"\");\n};\nfunction eventIsReply(op, event, threadIds = /* @__PURE__ */ new Set(), tagType) {\n  tagType ??= op.tagType();\n  const tags = event.getMatchingTags(tagType);\n  threadIds.add(op.tagId());\n  if (threadIds.has(event.tagId())) return false;\n  const heedExplicitReplyMarker = () => {\n    let eventIsTagged = false;\n    for (const tag of tags) {\n      if (tag[3] === \"reply\") return threadIds.has(tag[1]);\n      const markerIsEmpty = tag[3] === \"\" || tag[3] === void 0;\n      const markerIsRoot = tag[3] === \"root\";\n      if (tag[1] === op.tagId() && (markerIsEmpty || markerIsRoot)) {\n        eventIsTagged = markerIsRoot ? \"root\" : true;\n      }\n    }\n    if (!eventIsTagged) return false;\n    if (eventIsTagged === \"root\") return true;\n  };\n  const explicitReplyMarker = heedExplicitReplyMarker();\n  if (explicitReplyMarker !== void 0) return explicitReplyMarker;\n  if (hasMarkers(event, tagType)) return false;\n  const expectedTags = op.getMatchingTags(\"e\").map((tag) => tag[1]);\n  expectedTags.push(op.id);\n  return event.getMatchingTags(\"e\").every((tag) => expectedTags.includes(tag[1]));\n}\nfunction eventThreads(op, events) {\n  const eventsByAuthor = eventsBySameAuthor(op, events);\n  const threadEvents = events.filter((event) => eventIsPartOfThread(op, event, eventsByAuthor));\n  return threadEvents.sort((a, b) => a.created_at - b.created_at);\n}\nfunction getEventReplyId(event) {\n  const replyTag = getReplyTag(event);\n  if (replyTag) return replyTag[1];\n  const rootTag = getRootTag(event);\n  if (rootTag) return rootTag[1];\n}\nfunction isEventOriginalPost(event) {\n  return getEventReplyId(event) === void 0;\n}\nfunction eventThreadIds(op, events) {\n  const threadIds = /* @__PURE__ */ new Map();\n  const threadEvents = eventThreads(op, events);\n  threadEvents.forEach((event) => threadIds.set(event.id, event));\n  return threadIds;\n}\nfunction eventReplies(op, events, threadEventIds) {\n  threadEventIds ??= new Set(eventThreadIds(op, events).keys());\n  return events.filter((event) => eventIsReply(op, event, threadEventIds));\n}\nfunction eventIsPartOfThread(op, event, eventsByAuthor) {\n  if (op.pubkey !== event.pubkey) return false;\n  const taggedEventIds = event.getMatchingTags(\"e\").map((tag) => tag[1]);\n  const allTaggedEventsAreByOriginalAuthor = taggedEventIds.every((id) => eventsByAuthor.has(id));\n  return allTaggedEventsAreByOriginalAuthor;\n}\nfunction eventHasETagMarkers(event) {\n  for (const tag of event.tags) {\n    if (tag[0] === \"e\" && (tag[3] ?? \"\").length > 0) return true;\n  }\n  return false;\n}\nfunction getRootEventId(event, searchTag) {\n  searchTag ??= event.tagType();\n  const rootEventTag = getRootTag(event, searchTag);\n  if (rootEventTag) return rootEventTag[1];\n  const replyTag = getReplyTag(event, searchTag);\n  return replyTag?.[1];\n}\nfunction getRootTag(event, searchTag) {\n  searchTag ??= event.tagType();\n  const rootEventTag = event.tags.find(isTagRootTag);\n  if (!rootEventTag) {\n    if (eventHasETagMarkers(event)) return;\n    const matchingTags = event.getMatchingTags(searchTag);\n    if (matchingTags.length < 3) return matchingTags[0];\n  }\n  return rootEventTag;\n}\nvar nip22RootTags = /* @__PURE__ */ new Set([\"A\", \"E\", \"I\"]);\nvar nip22ReplyTags = /* @__PURE__ */ new Set([\"a\", \"e\", \"i\"]);\nfunction getReplyTag(event, searchTag) {\n  if (event.kind === 1111 /* GenericReply */) {\n    let replyTag2;\n    for (const tag of event.tags) {\n      if (nip22RootTags.has(tag[0])) replyTag2 = tag;\n      else if (nip22ReplyTags.has(tag[0])) {\n        replyTag2 = tag;\n        break;\n      }\n    }\n    return replyTag2;\n  }\n  searchTag ??= event.tagType();\n  let hasMarkers2 = false;\n  let replyTag;\n  for (const tag of event.tags) {\n    if (tag[0] !== searchTag) continue;\n    if ((tag[3] ?? \"\").length > 0) hasMarkers2 = true;\n    if (hasMarkers2 && tag[3] === \"reply\") return tag;\n    if (hasMarkers2 && tag[3] === \"root\") replyTag = tag;\n    if (!hasMarkers2) replyTag = tag;\n  }\n  return replyTag;\n}\nfunction isTagRootTag(tag) {\n  return tag[0] === \"E\" || tag[3] === \"root\";\n}\n\n// src/events/fetch-tagged-event.ts\nasync function fetchTaggedEvent(tag, marker) {\n  if (!this.ndk) throw new Error(\"NDK instance not found\");\n  const t = this.getMatchingTags(tag, marker);\n  if (t.length === 0) return void 0;\n  const [_, id, hint] = t[0];\n  let relay;\n  const event = await this.ndk.fetchEvent(id, {}, relay);\n  return event;\n}\nasync function fetchRootEvent(subOpts) {\n  if (!this.ndk) throw new Error(\"NDK instance not found\");\n  const rootTag = getRootTag(this);\n  if (!rootTag) return void 0;\n  return this.ndk.fetchEventFromTag(rootTag, this, subOpts);\n}\nasync function fetchReplyEvent(subOpts) {\n  if (!this.ndk) throw new Error(\"NDK instance not found\");\n  const replyTag = getReplyTag(this);\n  if (!replyTag) return void 0;\n  return this.ndk.fetchEventFromTag(replyTag, this, subOpts);\n}\n\n// src/events/serializer.ts\nfunction serialize(includeSig = false, includeId = false) {\n  const payload = [0, this.pubkey, this.created_at, this.kind, this.tags, this.content];\n  if (includeSig) payload.push(this.sig);\n  if (includeId) payload.push(this.id);\n  return JSON.stringify(payload);\n}\nfunction deserialize(serializedEvent) {\n  const eventArray = JSON.parse(serializedEvent);\n  const ret = {\n    pubkey: eventArray[1],\n    created_at: eventArray[2],\n    kind: eventArray[3],\n    tags: eventArray[4],\n    content: eventArray[5]\n  };\n  if (eventArray.length >= 7) ret.sig = eventArray[6];\n  if (eventArray.length >= 8) ret.id = eventArray[7];\n  return ret;\n}\n\n// src/events/validation.ts\n\n\n\n\n// src/events/signature.ts\nvar worker;\nvar processingQueue = {};\nfunction signatureVerificationInit(w) {\n  worker = w;\n  worker.onmessage = (msg) => {\n    const [eventId, result] = msg.data;\n    const record = processingQueue[eventId];\n    if (!record) {\n      console.error(\"No record found for event\", eventId);\n      return;\n    }\n    delete processingQueue[eventId];\n    for (const resolve of record.resolves) {\n      resolve(result);\n    }\n  };\n}\nasync function verifySignatureAsync(event, persist) {\n  const promise = new Promise((resolve) => {\n    const serialized = event.serialize();\n    let enqueue = false;\n    if (!processingQueue[event.id]) {\n      processingQueue[event.id] = { event, resolves: [] };\n      enqueue = true;\n    }\n    processingQueue[event.id].resolves.push(resolve);\n    if (!enqueue) return;\n    worker.postMessage({\n      serialized,\n      id: event.id,\n      sig: event.sig,\n      pubkey: event.pubkey\n    });\n  });\n  return promise;\n}\n\n// src/events/validation.ts\n\nvar PUBKEY_REGEX = /^[a-f0-9]{64}$/;\nfunction validate() {\n  if (typeof this.kind !== \"number\") return false;\n  if (typeof this.content !== \"string\") return false;\n  if (typeof this.created_at !== \"number\") return false;\n  if (typeof this.pubkey !== \"string\") return false;\n  if (!this.pubkey.match(PUBKEY_REGEX)) return false;\n  if (!Array.isArray(this.tags)) return false;\n  for (let i = 0; i < this.tags.length; i++) {\n    const tag = this.tags[i];\n    if (!Array.isArray(tag)) return false;\n    for (let j = 0; j < tag.length; j++) {\n      if (typeof tag[j] === \"object\") return false;\n    }\n  }\n  return true;\n}\nvar verifiedSignatures = new typescript_lru_cache__WEBPACK_IMPORTED_MODULE_3__.LRUCache({\n  maxSize: 1e3,\n  entryExpirationTimeInMS: 6e4\n});\nfunction verifySignature(persist) {\n  if (typeof this.signatureVerified === \"boolean\") return this.signatureVerified;\n  const prevVerification = verifiedSignatures.get(this.id);\n  if (prevVerification !== null) {\n    return this.signatureVerified = !!prevVerification;\n  }\n  try {\n    if (this.ndk?.asyncSigVerification) {\n      verifySignatureAsync(this, persist).then((result) => {\n        if (persist) {\n          this.signatureVerified = result;\n          if (result) verifiedSignatures.set(this.id, this.sig);\n        }\n        if (!result) {\n          this.ndk.emit(\"event:invalid-sig\", this);\n          verifiedSignatures.set(this.id, false);\n        }\n      });\n    } else {\n      const hash = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__.sha256)(new TextEncoder().encode(this.serialize()));\n      const res = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_5__.schnorr.verify(this.sig, hash, this.pubkey);\n      if (res) verifiedSignatures.set(this.id, this.sig);\n      else verifiedSignatures.set(this.id, false);\n      return this.signatureVerified = res;\n    }\n  } catch (err) {\n    return this.signatureVerified = false;\n  }\n}\nfunction getEventHash() {\n  return getEventHashFromSerializedEvent(this.serialize());\n}\nfunction getEventHashFromSerializedEvent(serializedEvent) {\n  const eventHash = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__.sha256)(new TextEncoder().encode(serializedEvent));\n  return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_6__.bytesToHex)(eventHash);\n}\n\n// src/events/index.ts\nvar skipClientTagOnKinds = /* @__PURE__ */ new Set([\n  0 /* Metadata */,\n  4 /* EncryptedDirectMessage */,\n  1059 /* GiftWrap */,\n  13 /* GiftWrapSeal */,\n  3 /* Contacts */,\n  9734 /* ZapRequest */,\n  5 /* EventDeletion */\n]);\nvar NDKEvent = class _NDKEvent extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  ndk;\n  created_at;\n  content = \"\";\n  tags = [];\n  kind;\n  id = \"\";\n  sig;\n  pubkey = \"\";\n  signatureVerified;\n  _author = void 0;\n  /**\n   * The relay that this event was first received from.\n   */\n  relay;\n  /**\n   * The relays that this event was received from and/or successfully published to.\n   */\n  get onRelays() {\n    let res = [];\n    if (!this.ndk) {\n      if (this.relay) res.push(this.relay);\n    } else {\n      res = this.ndk.subManager.seenEvents.get(this.id) || [];\n    }\n    return res;\n  }\n  /**\n   * The status of the publish operation.\n   */\n  publishStatus = \"success\";\n  publishError;\n  constructor(ndk, event) {\n    super();\n    this.ndk = ndk;\n    this.created_at = event?.created_at;\n    this.content = event?.content || \"\";\n    this.tags = event?.tags || [];\n    this.id = event?.id || \"\";\n    this.sig = event?.sig;\n    this.pubkey = event?.pubkey || \"\";\n    this.kind = event?.kind;\n    if (event instanceof _NDKEvent) {\n      if (this.relay) {\n        this.relay = event.relay;\n        this.ndk?.subManager.seenEvent(event.id, this.relay);\n      }\n      this.publishStatus = event.publishStatus;\n      this.publishError = event.publishError;\n    }\n  }\n  /**\n   * Deserialize an NDKEvent from a serialized payload.\n   * @param ndk\n   * @param event\n   * @returns\n   */\n  static deserialize(ndk, event) {\n    return new _NDKEvent(ndk, deserialize(event));\n  }\n  /**\n   * Returns the event as is.\n   */\n  rawEvent() {\n    return {\n      created_at: this.created_at,\n      content: this.content,\n      tags: this.tags,\n      kind: this.kind,\n      pubkey: this.pubkey,\n      id: this.id,\n      sig: this.sig\n    };\n  }\n  set author(user) {\n    this.pubkey = user.pubkey;\n    this._author = user;\n    this._author.ndk ??= this.ndk;\n  }\n  /**\n   * Returns an NDKUser for the author of the event.\n   */\n  get author() {\n    if (this._author) return this._author;\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    const user = this.ndk.getUser({ pubkey: this.pubkey });\n    this._author = user;\n    return user;\n  }\n  /**\n   * NIP-73 tagging of external entities\n   * @param entity to be tagged\n   * @param type of the entity\n   * @param markerUrl to be used as the marker URL\n   *\n   * @example\n   * ```typescript\n   * event.tagExternal(\"https://example.com/article/123#nostr\", \"url\");\n   * event.tags => [[\"i\", \"https://example.com/123\"], [\"k\", \"https://example.com\"]]\n   * ```\n   *\n   * @example tag a podcast:item:guid\n   * ```typescript\n   * event.tagExternal(\"e32b4890-b9ea-4aef-a0bf-54b787833dc5\", \"podcast:item:guid\");\n   * event.tags => [[\"i\", \"podcast:item:guid:e32b4890-b9ea-4aef-a0bf-54b787833dc5\"], [\"k\", \"podcast:item:guid\"]]\n   * ```\n   *\n   * @see https://github.com/nostr-protocol/nips/blob/master/73.md\n   */\n  tagExternal(entity, type, markerUrl) {\n    let iTag = [\"i\"];\n    let kTag = [\"k\"];\n    switch (type) {\n      case \"url\":\n        const url = new URL(entity);\n        url.hash = \"\";\n        iTag.push(url.toString());\n        kTag.push(`${url.protocol}//${url.host}`);\n        break;\n      case \"hashtag\":\n        iTag.push(`#${entity.toLowerCase()}`);\n        kTag.push(\"#\");\n        break;\n      case \"geohash\":\n        iTag.push(`geo:${entity.toLowerCase()}`);\n        kTag.push(\"geo\");\n        break;\n      case \"isbn\":\n        iTag.push(`isbn:${entity.replace(/-/g, \"\")}`);\n        kTag.push(\"isbn\");\n        break;\n      case \"podcast:guid\":\n        iTag.push(`podcast:guid:${entity}`);\n        kTag.push(\"podcast:guid\");\n        break;\n      case \"podcast:item:guid\":\n        iTag.push(`podcast:item:guid:${entity}`);\n        kTag.push(\"podcast:item:guid\");\n        break;\n      case \"podcast:publisher:guid\":\n        iTag.push(`podcast:publisher:guid:${entity}`);\n        kTag.push(\"podcast:publisher:guid\");\n        break;\n      case \"isan\":\n        iTag.push(`isan:${entity.split(\"-\").slice(0, 4).join(\"-\")}`);\n        kTag.push(\"isan\");\n        break;\n      case \"doi\":\n        iTag.push(`doi:${entity.toLowerCase()}`);\n        kTag.push(\"doi\");\n        break;\n      default:\n        throw new Error(`Unsupported NIP-73 entity type: ${type}`);\n    }\n    if (markerUrl) {\n      iTag.push(markerUrl);\n    }\n    this.tags.push(iTag);\n    this.tags.push(kTag);\n  }\n  /**\n   * Tag a user with an optional marker.\n   * @param target What is to be tagged. Can be an NDKUser, NDKEvent, or an NDKTag.\n   * @param marker The marker to use in the tag.\n   * @param skipAuthorTag Whether to explicitly skip adding the author tag of the event.\n   * @param forceTag Force a specific tag to be used instead of the default \"e\" or \"a\" tag.\n   * @example\n   * ```typescript\n   * reply.tag(opEvent, \"reply\");\n   * // reply.tags => [[\"e\", <id>, <relay>, \"reply\"]]\n   * ```\n   */\n  tag(target, marker, skipAuthorTag, forceTag) {\n    let tags = [];\n    const isNDKUser = target.fetchProfile !== void 0;\n    if (isNDKUser) {\n      forceTag ??= \"p\";\n      const tag = [forceTag, target.pubkey];\n      if (marker) tag.push(...[\"\", marker]);\n      tags.push(tag);\n    } else if (target instanceof _NDKEvent) {\n      const event = target;\n      skipAuthorTag ??= event?.pubkey === this.pubkey;\n      tags = event.referenceTags(marker, skipAuthorTag, forceTag);\n      for (const pTag of event.getMatchingTags(\"p\")) {\n        if (pTag[1] === this.pubkey) continue;\n        if (this.tags.find((t) => t[0] === \"p\" && t[1] === pTag[1])) continue;\n        this.tags.push([\"p\", pTag[1]]);\n      }\n    } else if (Array.isArray(target)) {\n      tags = [target];\n    } else {\n      throw new Error(\"Invalid argument\", target);\n    }\n    this.tags = mergeTags(this.tags, tags);\n  }\n  /**\n   * Return a NostrEvent object, trying to fill in missing fields\n   * when possible, adding tags when necessary.\n   * @param pubkey {string} The pubkey of the user who the event belongs to.\n   * @returns {Promise<NostrEvent>} A promise that resolves to a NostrEvent.\n   */\n  async toNostrEvent(pubkey) {\n    if (!pubkey && this.pubkey === \"\") {\n      const user = await this.ndk?.signer?.user();\n      this.pubkey = user?.pubkey || \"\";\n    }\n    if (!this.created_at) {\n      this.created_at = Math.floor(Date.now() / 1e3);\n    }\n    const { content, tags } = await this.generateTags();\n    this.content = content || \"\";\n    this.tags = tags;\n    try {\n      this.id = this.getEventHash();\n    } catch (e) {\n    }\n    return this.rawEvent();\n  }\n  serialize = serialize.bind(this);\n  getEventHash = getEventHash.bind(this);\n  validate = validate.bind(this);\n  verifySignature = verifySignature.bind(this);\n  /**\n   * Is this event replaceable (whether parameterized or not)?\n   *\n   * This will return true for kind 0, 3, 10k-20k and 30k-40k\n   */\n  isReplaceable = isReplaceable.bind(this);\n  isEphemeral = isEphemeral.bind(this);\n  isDvm = () => this.kind && this.kind >= 5e3 && this.kind <= 7e3;\n  /**\n   * Is this event parameterized replaceable?\n   *\n   * This will return true for kind 30k-40k\n   */\n  isParamReplaceable = isParamReplaceable.bind(this);\n  /**\n   * Encodes a bech32 id.\n   *\n   * @param relays {string[]} The relays to encode in the id\n   * @returns {string} - Encoded naddr, note or nevent.\n   */\n  encode = encode.bind(this);\n  encrypt = encrypt.bind(this);\n  decrypt = decrypt.bind(this);\n  /**\n   * Get all tags with the given name\n   * @param tagName {string} The name of the tag to search for\n   * @returns {NDKTag[]} An array of the matching tags\n   */\n  getMatchingTags(tagName, marker) {\n    const t = this.tags.filter((tag) => tag[0] === tagName);\n    if (marker === void 0) return t;\n    return t.filter((tag) => tag[3] === marker);\n  }\n  /**\n   * Check if the event has a tag with the given name\n   * @param tagName\n   * @param marker\n   * @returns\n   */\n  hasTag(tagName, marker) {\n    return this.tags.some((tag) => tag[0] === tagName && (!marker || tag[3] === marker));\n  }\n  /**\n   * Get the first tag with the given name\n   * @param tagName Tag name to search for\n   * @returns The value of the first tag with the given name, or undefined if no such tag exists\n   */\n  tagValue(tagName) {\n    const tags = this.getMatchingTags(tagName);\n    if (tags.length === 0) return void 0;\n    return tags[0][1];\n  }\n  /**\n   * Gets the NIP-31 \"alt\" tag of the event.\n   */\n  get alt() {\n    return this.tagValue(\"alt\");\n  }\n  /**\n   * Sets the NIP-31 \"alt\" tag of the event. Use this to set an alt tag so\n   * clients that don't handle a particular event kind can display something\n   * useful for users.\n   */\n  set alt(alt) {\n    this.removeTag(\"alt\");\n    if (alt) this.tags.push([\"alt\", alt]);\n  }\n  /**\n   * Gets the NIP-33 \"d\" tag of the event.\n   */\n  get dTag() {\n    return this.tagValue(\"d\");\n  }\n  /**\n   * Sets the NIP-33 \"d\" tag of the event.\n   */\n  set dTag(value) {\n    this.removeTag(\"d\");\n    if (value) this.tags.push([\"d\", value]);\n  }\n  /**\n   * Remove all tags with the given name (e.g. \"d\", \"a\", \"p\")\n   * @param tagName Tag name(s) to search for and remove\n   * @returns {void}\n   */\n  removeTag(tagName) {\n    const tagNames = Array.isArray(tagName) ? tagName : [tagName];\n    this.tags = this.tags.filter((tag) => !tagNames.includes(tag[0]));\n  }\n  /**\n   * Sign the event if a signer is present.\n   *\n   * It will generate tags.\n   * Repleacable events will have their created_at field set to the current time.\n   * @param signer {NDKSigner} The NDKSigner to use to sign the event\n   * @returns {Promise<string>} A Promise that resolves to the signature of the signed event.\n   */\n  async sign(signer) {\n    if (!signer) {\n      this.ndk?.assertSigner();\n      signer = this.ndk.signer;\n    } else {\n      this.author = await signer.user();\n    }\n    const nostrEvent = await this.toNostrEvent();\n    this.sig = await signer.sign(nostrEvent);\n    return this.sig;\n  }\n  /**\n   *\n   * @param relaySet\n   * @param timeoutMs\n   * @param requiredRelayCount\n   * @returns\n   */\n  async publishReplaceable(relaySet, timeoutMs, requiredRelayCount) {\n    this.id = \"\";\n    this.created_at = Math.floor(Date.now() / 1e3);\n    this.sig = \"\";\n    return this.publish(relaySet, timeoutMs, requiredRelayCount);\n  }\n  /**\n   * Attempt to sign and then publish an NDKEvent to a given relaySet.\n   * If no relaySet is provided, the relaySet will be calculated by NDK.\n   * @param relaySet {NDKRelaySet} The relaySet to publish the even to.\n   * @param timeoutM {number} The timeout for the publish operation in milliseconds.\n   * @param requiredRelayCount The number of relays that must receive the event for the publish to be considered successful.\n   * @returns A promise that resolves to the relays the event was published to.\n   */\n  async publish(relaySet, timeoutMs, requiredRelayCount) {\n    if (!this.sig) await this.sign();\n    if (!this.ndk)\n      throw new Error(\"NDKEvent must be associated with an NDK instance to publish\");\n    if (!relaySet) {\n      relaySet = this.ndk.devWriteRelaySet || await calculateRelaySetFromEvent(this.ndk, this);\n    }\n    if (this.kind === 5 /* EventDeletion */ && this.ndk.cacheAdapter?.deleteEventIds) {\n      const eTags = this.getMatchingTags(\"e\").map((tag) => tag[1]);\n      this.ndk.cacheAdapter.deleteEventIds(eTags);\n    }\n    const rawEvent = this.rawEvent();\n    if (this.ndk.cacheAdapter?.addUnpublishedEvent && shouldTrackUnpublishedEvent(this)) {\n      try {\n        this.ndk.cacheAdapter.addUnpublishedEvent(this, relaySet.relayUrls);\n      } catch (e) {\n        console.error(\"Error adding unpublished event to cache\", e);\n      }\n    }\n    if (this.kind === 5 /* EventDeletion */ && this.ndk.cacheAdapter?.deleteEventIds) {\n      this.ndk.cacheAdapter.deleteEventIds(this.getMatchingTags(\"e\").map((tag) => tag[1]));\n    }\n    this.ndk.subManager.dispatchEvent(rawEvent, void 0, true);\n    const relays = await relaySet.publish(this, timeoutMs, requiredRelayCount);\n    relays.forEach((relay) => this.ndk?.subManager.seenEvent(this.id, relay));\n    return relays;\n  }\n  /**\n   * Generates tags for users, notes, and other events tagged in content.\n   * Will also generate random \"d\" tag for parameterized replaceable events where needed.\n   * @returns {ContentTag} The tags and content of the event.\n   */\n  async generateTags() {\n    let tags = [];\n    const g = await generateContentTags(this.content, this.tags);\n    const content = g.content;\n    tags = g.tags;\n    if (this.kind && this.isParamReplaceable()) {\n      const dTag = this.getMatchingTags(\"d\")[0];\n      if (!dTag) {\n        const title = this.tagValue(\"title\");\n        const randLength = title ? 6 : 16;\n        let str = [...Array(randLength)].map(() => Math.random().toString(36)[2]).join(\"\");\n        if (title && title.length > 0) {\n          str = title.replace(/[^a-z0-9]+/gi, \"-\").replace(/^-|-$/g, \"\") + \"-\" + str;\n        }\n        tags.push([\"d\", str]);\n      }\n    }\n    if (this.shouldAddClientTag) {\n      const clientTag = [\"client\", this.ndk.clientName ?? \"\"];\n      if (this.ndk.clientNip89) clientTag.push(this.ndk.clientNip89);\n      tags.push(clientTag);\n    } else if (this.shouldStripClientTag) {\n      tags = tags.filter((tag) => tag[0] !== \"client\");\n    }\n    return { content: content || \"\", tags };\n  }\n  get shouldAddClientTag() {\n    if (!this.ndk?.clientName && !this.ndk?.clientNip89) return false;\n    if (skipClientTagOnKinds.has(this.kind)) return false;\n    if (this.isEphemeral() || this.isReplaceable()) return false;\n    if (this.isDvm()) return false;\n    if (this.hasTag(\"client\")) return false;\n    return true;\n  }\n  get shouldStripClientTag() {\n    return skipClientTagOnKinds.has(this.kind);\n  }\n  muted() {\n    const authorMutedEntry = this.ndk?.mutedIds.get(this.pubkey);\n    if (authorMutedEntry && authorMutedEntry === \"p\") return \"author\";\n    const eventTagReference = this.tagReference();\n    const eventMutedEntry = this.ndk?.mutedIds.get(eventTagReference[1]);\n    if (eventMutedEntry && eventMutedEntry === eventTagReference[0]) return \"event\";\n    return null;\n  }\n  /**\n   * Returns the \"d\" tag of a parameterized replaceable event or throws an error if the event isn't\n   * a parameterized replaceable event.\n   * @returns {string} the \"d\" tag of the event.\n   * \n   * @deprecated Use `dTag` instead.\n   */\n  replaceableDTag() {\n    if (this.kind && this.kind >= 3e4 && this.kind <= 4e4) {\n      const dTag = this.getMatchingTags(\"d\")[0];\n      const dTagId = dTag ? dTag[1] : \"\";\n      return dTagId;\n    }\n    throw new Error(\"Event is not a parameterized replaceable event\");\n  }\n  /**\n   * Provides a deduplication key for the event.\n   *\n   * For kinds 0, 3, 10k-20k this will be the event <kind>:<pubkey>\n   * For kinds 30k-40k this will be the event <kind>:<pubkey>:<d-tag>\n   * For all other kinds this will be the event id\n   */\n  deduplicationKey() {\n    if (this.kind === 0 || this.kind === 3 || this.kind && this.kind >= 1e4 && this.kind < 2e4) {\n      return `${this.kind}:${this.pubkey}`;\n    } else {\n      return this.tagId();\n    }\n  }\n  /**\n   * Returns the id of the event or, if it's a parameterized event, the generated id of the event using \"d\" tag, pubkey, and kind.\n   * @returns {string} The id\n   */\n  tagId() {\n    if (this.isParamReplaceable()) {\n      return this.tagAddress();\n    }\n    return this.id;\n  }\n  /**\n   * Returns a stable reference value for a replaceable event.\n   * \n   * Param replaceable events are returned in the expected format of `<kind>:<pubkey>:<d-tag>`.\n   * Kind-replaceable events are returned in the format of `<kind>:<pubkey>:`.\n   * \n   * @returns {string} A stable reference value for replaceable events\n   */\n  tagAddress() {\n    if (this.isParamReplaceable()) {\n      const dTagId = this.dTag ?? \"\";\n      return `${this.kind}:${this.pubkey}:${dTagId}`;\n    } else if (this.isReplaceable()) {\n      return `${this.kind}:${this.pubkey}:`;\n    }\n    throw new Error(\"Event is not a replaceable event\");\n  }\n  /**\n   * Determines the type of tag that can be used to reference this event from another event.\n   * @returns {string} The tag type\n   * @example\n   * event = new NDKEvent(ndk, { kind: 30000, pubkey: 'pubkey', tags: [ [\"d\", \"d-code\"] ] });\n   * event.tagType(); // \"a\"\n   */\n  tagType() {\n    return this.isParamReplaceable() ? \"a\" : \"e\";\n  }\n  /**\n   * Get the tag that can be used to reference this event from another event.\n   *\n   * Consider using referenceTags() instead (unless you have a good reason to use this)\n   *\n   * @example\n   *     event = new NDKEvent(ndk, { kind: 30000, pubkey: 'pubkey', tags: [ [\"d\", \"d-code\"] ] });\n   *     event.tagReference(); // [\"a\", \"30000:pubkey:d-code\"]\n   *\n   *     event = new NDKEvent(ndk, { kind: 1, pubkey: 'pubkey', id: \"eventid\" });\n   *     event.tagReference(); // [\"e\", \"eventid\"]\n   * @returns {NDKTag} The NDKTag object referencing this event\n   */\n  tagReference(marker) {\n    let tag;\n    if (this.isParamReplaceable()) {\n      tag = [\"a\", this.tagAddress()];\n    } else {\n      tag = [\"e\", this.tagId()];\n    }\n    if (this.relay) {\n      tag.push(this.relay.url);\n    } else {\n      tag.push(\"\");\n    }\n    tag.push(marker ?? \"\");\n    if (!this.isParamReplaceable()) {\n      tag.push(this.pubkey);\n    }\n    return tag;\n  }\n  /**\n   * Get the tags that can be used to reference this event from another event\n   * @param marker The marker to use in the tag\n   * @param skipAuthorTag Whether to explicitly skip adding the author tag of the event\n   * @param forceTag Force a specific tag to be used instead of the default \"e\" or \"a\" tag\n   * @example\n   *     event = new NDKEvent(ndk, { kind: 30000, pubkey: 'pubkey', tags: [ [\"d\", \"d-code\"] ] });\n   *     event.referenceTags(); // [[\"a\", \"30000:pubkey:d-code\"], [\"e\", \"parent-id\"]]\n   *\n   *     event = new NDKEvent(ndk, { kind: 1, pubkey: 'pubkey', id: \"eventid\" });\n   *     event.referenceTags(); // [[\"e\", \"parent-id\"]]\n   * @returns {NDKTag} The NDKTag object referencing this event\n   */\n  referenceTags(marker, skipAuthorTag, forceTag) {\n    let tags = [];\n    if (this.isParamReplaceable()) {\n      tags = [\n        [forceTag ?? \"a\", this.tagAddress()],\n        [forceTag ?? \"e\", this.id]\n      ];\n    } else {\n      tags = [[forceTag ?? \"e\", this.id]];\n    }\n    tags = tags.map((tag) => {\n      if (tag[0] === \"e\" || marker) {\n        tag.push(this.relay?.url ?? \"\");\n      } else if (this.relay?.url) {\n        tag.push(this.relay?.url);\n      }\n      return tag;\n    });\n    tags.forEach((tag) => {\n      if (tag[0] === \"e\") {\n        tag.push(marker ?? \"\");\n        tag.push(this.pubkey);\n      } else if (marker) {\n        tag.push(marker);\n      }\n    });\n    tags = [...tags, ...this.getMatchingTags(\"h\")];\n    if (!skipAuthorTag) tags.push(...this.author.referenceTags());\n    return tags;\n  }\n  /**\n   * Provides the filter that will return matching events for this event.\n   *\n   * @example\n   *    event = new NDKEvent(ndk, { kind: 30000, pubkey: 'pubkey', tags: [ [\"d\", \"d-code\"] ] });\n   *    event.filter(); // { \"#a\": [\"30000:pubkey:d-code\"] }\n   * @example\n   *    event = new NDKEvent(ndk, { kind: 1, pubkey: 'pubkey', id: \"eventid\" });\n   *    event.filter(); // { \"#e\": [\"eventid\"] }\n   *\n   * @returns The filter that will return matching events for this event\n   */\n  filter() {\n    if (this.isParamReplaceable()) {\n      return { \"#a\": [this.tagId()] };\n    } else {\n      return { \"#e\": [this.tagId()] };\n    }\n  }\n  nip22Filter() {\n    if (this.isParamReplaceable()) {\n      return { \"#A\": [this.tagId()] };\n    } else {\n      return { \"#E\": [this.tagId()] };\n    }\n  }\n  /**\n   * Generates a deletion event of the current event\n   *\n   * @param reason The reason for the deletion\n   * @param publish Whether to publish the deletion event automatically\n   * @returns The deletion event\n   */\n  async delete(reason, publish = true) {\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    this.ndk.assertSigner();\n    const e = new _NDKEvent(this.ndk, {\n      kind: 5 /* EventDeletion */,\n      content: reason || \"\"\n    });\n    e.tag(this, void 0, true);\n    e.tags.push([\"k\", this.kind.toString()]);\n    if (publish) {\n      this.emit(\"deleted\");\n      await e.publish();\n    }\n    return e;\n  }\n  /**\n   * Establishes whether this is a NIP-70-protectede event.\n   * @@satisfies NIP-70\n   */\n  set isProtected(val) {\n    this.removeTag(\"-\");\n    if (val) this.tags.push([\"-\"]);\n  }\n  /**\n   * Whether this is a NIP-70-protectede event.\n   * @@satisfies NIP-70\n   */\n  get isProtected() {\n    return this.hasTag(\"-\");\n  }\n  /**\n   * Fetch an event tagged with the given tag following relay hints if provided.\n   * @param tag The tag to search for\n   * @param marker The marker to use in the tag (e.g. \"root\")\n   * @returns The fetched event or null if no event was found, undefined if no matching tag was found in the event\n   * * @example\n   * const replyEvent = await ndk.fetchEvent(\"nevent1qqs8x8vnycyha73grv380gmvlury4wtmx0nr9a5ds2dngqwgu87wn6gpzemhxue69uhhyetvv9ujuurjd9kkzmpwdejhgq3ql2vyh47mk2p0qlsku7hg0vn29faehy9hy34ygaclpn66ukqp3afqz4cwjd\")\n   * const originalEvent = await replyEvent.fetchTaggedEvent(\"e\", \"reply\");\n   * console.log(replyEvent.encode() + \" is a reply to event \" + originalEvent?.encode());\n   */\n  fetchTaggedEvent = fetchTaggedEvent.bind(this);\n  /**\n   * Fetch the root event of the current event.\n   * @returns The fetched root event or null if no event was found\n   * @example\n   * const replyEvent = await ndk.fetchEvent(\"nevent1qqs8x8vnycyha73grv380gmvlury4wtmx0nr9a5ds2dngqwgu87wn6gpzemhxue69uhhyetvv9ujuurjd9kkzmpwdejhgq3ql2vyh47mk2p0qlsku7hg0vn29faehy9hy34ygaclpn66ukqp3afqz4cwjd\")\n   * const rootEvent = await replyEvent.fetchRootEvent();\n   * console.log(replyEvent.encode() + \" is a reply in the thread \" + rootEvent?.encode());\n   */\n  fetchRootEvent = fetchRootEvent.bind(this);\n  /**\n   * Fetch the event the current event is replying to.\n   * @returns The fetched reply event or null if no event was found\n   */\n  fetchReplyEvent = fetchReplyEvent.bind(this);\n  /**\n   * NIP-18 reposting event.\n   *\n   * @param publish Whether to publish the reposted event automatically @default true\n   * @param signer The signer to use for signing the reposted event\n   * @returns The reposted event\n   *\n   * @function\n   */\n  repost = repost.bind(this);\n  /**\n   * React to an existing event\n   *\n   * @param content The content of the reaction\n   */\n  async react(content, publish = true) {\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    this.ndk.assertSigner();\n    const e = new _NDKEvent(this.ndk, {\n      kind: 7 /* Reaction */,\n      content\n    });\n    e.tag(this);\n    if (publish) await e.publish();\n    return e;\n  }\n  /**\n   * Checks whether the event is valid per underlying NIPs.\n   *\n   * This method is meant to be overridden by subclasses that implement specific NIPs\n   * to allow the enforcement of NIP-specific validation rules.\n   *\n   * Otherwise, it will only check for basic event properties.\n   *\n   */\n  get isValid() {\n    return this.validate();\n  }\n  /**\n   * Creates a reply event for the current event.\n   * \n   * This function will use NIP-22 when appropriate (i.e. replies to non-kind:1 events).\n   * This function does not have side-effects; it will just return an event with the appropriate tags\n   * to generate the reply event; the caller is responsible for publishing the event.\n   */\n  reply() {\n    const reply = new _NDKEvent(this.ndk);\n    if (this.kind === 1) {\n      reply.kind = 1;\n      const opHasETag = this.hasTag(\"e\");\n      if (opHasETag) {\n        reply.tags = [\n          ...reply.tags,\n          ...this.getMatchingTags(\"e\"),\n          ...this.getMatchingTags(\"p\"),\n          ...this.getMatchingTags(\"a\"),\n          ...this.referenceTags(\"reply\")\n        ];\n      } else {\n        reply.tag(this, \"root\");\n      }\n    } else {\n      reply.kind = 1111 /* GenericReply */;\n      const carryOverTags = [\"A\", \"E\", \"I\", \"P\"];\n      const rootTags = this.tags.filter((tag) => carryOverTags.includes(tag[0]));\n      if (rootTags.length > 0) {\n        const rootKind = this.tagValue(\"K\");\n        reply.tags.push(...rootTags);\n        if (rootKind) reply.tags.push([\"K\", rootKind]);\n        const [type, id, _, ...extra] = this.tagReference();\n        const tag = [type, id, ...extra];\n        reply.tags.push(tag);\n      } else {\n        const [type, id, _, relayHint] = this.tagReference();\n        const tag = [type, id, relayHint ?? \"\"];\n        if (type === \"e\") tag.push(this.pubkey);\n        reply.tags.push(tag);\n        const uppercaseTag = [...tag];\n        uppercaseTag[0] = uppercaseTag[0].toUpperCase();\n        reply.tags.push(uppercaseTag);\n        reply.tags.push([\"K\", this.kind.toString()]);\n        reply.tags.push([\"P\", this.pubkey]);\n      }\n      reply.tags.push([\"k\", this.kind.toString()]);\n      reply.tags.push(...this.getMatchingTags(\"p\"));\n      reply.tags.push([\"p\", this.pubkey]);\n    }\n    return reply;\n  }\n};\nvar untrackedUnpublishedEvents = /* @__PURE__ */ new Set([\n  24133 /* NostrConnect */,\n  13194 /* NostrWaletConnectInfo */,\n  23194 /* NostrWalletConnectReq */,\n  23195 /* NostrWalletConnectRes */\n]);\nfunction shouldTrackUnpublishedEvent(event) {\n  return !untrackedUnpublishedEvents.has(event.kind);\n}\n\n// src/relay/pool/index.ts\n\nvar NDKPool = class extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  // TODO: This should probably be an LRU cache\n  _relays = /* @__PURE__ */ new Map();\n  status = \"idle\";\n  autoConnectRelays = /* @__PURE__ */ new Set();\n  poolBlacklistRelayUrls = /* @__PURE__ */ new Set();\n  debug;\n  temporaryRelayTimers = /* @__PURE__ */ new Map();\n  flappingRelays = /* @__PURE__ */ new Set();\n  // A map to store timeouts for each flapping relay.\n  backoffTimes = /* @__PURE__ */ new Map();\n  ndk;\n  get blacklistRelayUrls() {\n    const val = new Set(this.ndk.blacklistRelayUrls);\n    this.poolBlacklistRelayUrls.forEach((url) => val.add(url));\n    return val;\n  }\n  /**\n   * @param relayUrls - The URLs of the relays to connect to.\n   * @param blacklistedRelayUrls - URLs to blacklist for this pool IN ADDITION to those blacklisted at the ndk-level\n   * @param ndk - The NDK instance.\n   * @param opts - Options for the pool.\n   */\n  constructor(relayUrls = [], blacklistedRelayUrls = [], ndk, { debug: debug8, name } = {}) {\n    super();\n    this.debug = debug8 ?? ndk.debug.extend(\"pool\");\n    if (name) this._name = name;\n    this.ndk = ndk;\n    this.relayUrls = relayUrls;\n    this.poolBlacklistRelayUrls = new Set(blacklistedRelayUrls);\n    this.ndk.pools.push(this);\n  }\n  get relays() {\n    return this._relays;\n  }\n  set relayUrls(urls) {\n    this._relays.clear();\n    for (const relayUrl of urls) {\n      const relay = new NDKRelay(relayUrl, void 0, this.ndk);\n      relay.connectivity.netDebug = this.ndk.netDebug;\n      this.addRelay(relay);\n    }\n  }\n  _name = \"unnamed\";\n  get name() {\n    return this._name;\n  }\n  set name(name) {\n    this._name = name;\n    this.debug = this.debug.extend(name);\n  }\n  /**\n   * Adds a relay to the pool, and sets a timer to remove it if it is not used within the specified time.\n   * @param relay - The relay to add to the pool.\n   * @param removeIfUnusedAfter - The time in milliseconds to wait before removing the relay from the pool after it is no longer used.\n   */\n  useTemporaryRelay(relay, removeIfUnusedAfter = 3e4, filters) {\n    const relayAlreadyInPool = this.relays.has(relay.url);\n    if (!relayAlreadyInPool) {\n      this.addRelay(relay);\n      this.debug(\"Adding temporary relay %s for filters %o\", relay.url, filters);\n    }\n    const existingTimer = this.temporaryRelayTimers.get(relay.url);\n    if (existingTimer) {\n      clearTimeout(existingTimer);\n    }\n    if (!relayAlreadyInPool || existingTimer) {\n      const timer = setTimeout(() => {\n        if (this.ndk.explicitRelayUrls?.includes(relay.url)) return;\n        this.removeRelay(relay.url);\n      }, removeIfUnusedAfter);\n      this.temporaryRelayTimers.set(relay.url, timer);\n    }\n  }\n  /**\n   * Adds a relay to the pool.\n   *\n   * @param relay - The relay to add to the pool.\n   * @param connect - Whether or not to connect to the relay.\n   */\n  addRelay(relay, connect = true) {\n    const isAlreadyInPool = this.relays.has(relay.url);\n    const isBlacklisted = this.blacklistRelayUrls?.has(relay.url);\n    const isCustomRelayUrl = relay.url.includes(\"/npub1\");\n    let reconnect = true;\n    const relayUrl = relay.url;\n    if (isAlreadyInPool) return;\n    if (isBlacklisted) {\n      this.debug(`Refusing to add relay ${relayUrl}: blacklisted`);\n      return;\n    }\n    if (isCustomRelayUrl) {\n      this.debug(`Refusing to add relay ${relayUrl}: is a filter relay`);\n      return;\n    }\n    if (this.ndk.cacheAdapter?.getRelayStatus) {\n      const info = this.ndk.cacheAdapter.getRelayStatus(relayUrl);\n      if (info && info.dontConnectBefore) {\n        if (info.dontConnectBefore > Date.now()) {\n          const delay = info.dontConnectBefore - Date.now();\n          this.debug(`Refusing to add relay ${relayUrl}: delayed connect for ${delay}ms`);\n          setTimeout(() => {\n            this.addRelay(relay, connect);\n          }, delay);\n          return;\n        } else {\n          reconnect = false;\n        }\n      }\n    }\n    const noticeHandler = (notice) => this.emit(\"notice\", relay, notice);\n    const connectHandler = () => this.handleRelayConnect(relayUrl);\n    const readyHandler = () => this.handleRelayReady(relay);\n    const disconnectHandler = () => this.emit(\"relay:disconnect\", relay);\n    const flappingHandler = () => this.handleFlapping(relay);\n    const authHandler = (challenge) => this.emit(\"relay:auth\", relay, challenge);\n    const authedHandler = () => this.emit(\"relay:authed\", relay);\n    relay.off(\"notice\", noticeHandler);\n    relay.off(\"connect\", connectHandler);\n    relay.off(\"ready\", readyHandler);\n    relay.off(\"disconnect\", disconnectHandler);\n    relay.off(\"flapping\", flappingHandler);\n    relay.off(\"auth\", authHandler);\n    relay.off(\"authed\", authedHandler);\n    relay.on(\"notice\", noticeHandler);\n    relay.on(\"connect\", connectHandler);\n    relay.on(\"ready\", readyHandler);\n    relay.on(\"disconnect\", disconnectHandler);\n    relay.on(\"flapping\", flappingHandler);\n    relay.on(\"auth\", authHandler);\n    relay.on(\"authed\", authedHandler);\n    relay.on(\"delayed-connect\", (delay) => {\n      if (this.ndk.cacheAdapter?.updateRelayStatus) {\n        this.ndk.cacheAdapter.updateRelayStatus(relay.url, {\n          dontConnectBefore: Date.now() + delay\n        });\n      }\n    });\n    this._relays.set(relayUrl, relay);\n    if (connect) this.autoConnectRelays.add(relayUrl);\n    if (connect && this.status === \"active\") {\n      this.emit(\"relay:connecting\", relay);\n      relay.connect(void 0, reconnect).catch((e) => {\n        this.debug(`Failed to connect to relay ${relayUrl}`, e);\n      });\n    }\n  }\n  /**\n   * Removes a relay from the pool.\n   * @param relayUrl - The URL of the relay to remove.\n   * @returns {boolean} True if the relay was removed, false if it was not found.\n   */\n  removeRelay(relayUrl) {\n    const relay = this.relays.get(relayUrl);\n    if (relay) {\n      relay.disconnect();\n      this.relays.delete(relayUrl);\n      this.autoConnectRelays.delete(relayUrl);\n      this.emit(\"relay:disconnect\", relay);\n      return true;\n    }\n    const existingTimer = this.temporaryRelayTimers.get(relayUrl);\n    if (existingTimer) {\n      clearTimeout(existingTimer);\n      this.temporaryRelayTimers.delete(relayUrl);\n    }\n    return false;\n  }\n  /**\n   * Checks whether a relay is already connected in the pool.\n   */\n  isRelayConnected(url) {\n    const normalizedUrl = normalizeRelayUrl(url);\n    const relay = this.relays.get(normalizedUrl);\n    if (!relay) return false;\n    return relay.status === 5 /* CONNECTED */;\n  }\n  /**\n   * Fetches a relay from the pool, or creates a new one if it does not exist.\n   *\n   * New relays will be attempted to be connected.\n   */\n  getRelay(url, connect = true, temporary = false, filters) {\n    let relay = this.relays.get(normalizeRelayUrl(url));\n    if (!relay) {\n      relay = new NDKRelay(url, void 0, this.ndk);\n      relay.connectivity.netDebug = this.ndk.netDebug;\n      if (temporary) {\n        this.useTemporaryRelay(relay, 3e4, filters);\n      } else {\n        this.addRelay(relay, connect);\n      }\n    }\n    return relay;\n  }\n  handleRelayConnect(relayUrl) {\n    const relay = this.relays.get(relayUrl);\n    if (!relay) {\n      console.error(\"NDK BUG: relay not found in pool\", { relayUrl });\n      return;\n    }\n    this.emit(\"relay:connect\", relay);\n    if (this.stats().connected === this.relays.size) {\n      this.emit(\"connect\");\n    }\n  }\n  handleRelayReady(relay) {\n    this.emit(\"relay:ready\", relay);\n  }\n  /**\n   * Attempts to establish a connection to each relay in the pool.\n   *\n   * @async\n   * @param {number} [timeoutMs] - Optional timeout in milliseconds for each connection attempt.\n   * @returns {Promise<void>} A promise that resolves when all connection attempts have completed.\n   * @throws {Error} If any of the connection attempts result in an error or timeout.\n   */\n  async connect(timeoutMs) {\n    const promises = [];\n    this.status = \"active\";\n    this.debug(\n      `Connecting to ${this.relays.size} relays${timeoutMs ? `, timeout ${timeoutMs}...` : \"\"}`\n    );\n    const relaysToConnect = new Set(this.autoConnectRelays.keys());\n    for (const relayUrl of relaysToConnect) {\n      const relay = this.relays.get(relayUrl);\n      if (!relay) {\n        console.log(`Relay ${relayUrl} not found in pool ${this.name}`);\n        continue;\n      }\n      const connectPromise = new Promise((resolve, reject) => {\n        this.emit(\"relay:connecting\", relay);\n        return relay.connect(timeoutMs).then(resolve).catch(reject);\n      });\n      if (timeoutMs) {\n        const timeoutPromise = new Promise((_, reject) => {\n          setTimeout(() => reject(`Timed out after ${timeoutMs}ms`), timeoutMs);\n        });\n        promises.push(\n          Promise.race([connectPromise, timeoutPromise]).catch((e) => {\n            this.debug(\n              `Failed to connect to relay ${relay.url}: ${e ?? \"No reason specified\"}`\n            );\n          })\n        );\n      } else {\n        promises.push(connectPromise);\n      }\n    }\n    const maybeEmitConnect = () => {\n      const allConnected = this.stats().connected === this.relays.size;\n      const someConnected = this.stats().connected > 0;\n      if (!allConnected && someConnected) {\n        this.emit(\"connect\");\n      }\n    };\n    if (timeoutMs)\n      setTimeout(maybeEmitConnect, timeoutMs);\n    await Promise.all(promises);\n    maybeEmitConnect();\n  }\n  checkOnFlappingRelays() {\n    const flappingRelaysCount = this.flappingRelays.size;\n    const totalRelays = this.relays.size;\n    if (flappingRelaysCount / totalRelays >= 0.8) {\n      for (const relayUrl of this.flappingRelays) {\n        this.backoffTimes.set(relayUrl, 0);\n      }\n    }\n  }\n  handleFlapping(relay) {\n    this.debug(`Relay ${relay.url} is flapping`);\n    let currentBackoff = this.backoffTimes.get(relay.url) || 5e3;\n    currentBackoff = currentBackoff * 2;\n    this.backoffTimes.set(relay.url, currentBackoff);\n    this.debug(`Backoff time for ${relay.url} is ${currentBackoff}ms`);\n    setTimeout(() => {\n      this.debug(`Attempting to reconnect to ${relay.url}`);\n      this.emit(\"relay:connecting\", relay);\n      relay.connect();\n      this.checkOnFlappingRelays();\n    }, currentBackoff);\n    relay.disconnect();\n    this.emit(\"flapping\", relay);\n  }\n  size() {\n    return this.relays.size;\n  }\n  /**\n   * Returns the status of each relay in the pool.\n   * @returns {NDKPoolStats} An object containing the number of relays in each status.\n   */\n  stats() {\n    const stats = {\n      total: 0,\n      connected: 0,\n      disconnected: 0,\n      connecting: 0\n    };\n    for (const relay of this.relays.values()) {\n      stats.total++;\n      if (relay.status === 5 /* CONNECTED */) {\n        stats.connected++;\n      } else if (relay.status === 1 /* DISCONNECTED */) {\n        stats.disconnected++;\n      } else if (relay.status === 4 /* CONNECTING */) {\n        stats.connecting++;\n      }\n    }\n    return stats;\n  }\n  connectedRelays() {\n    return Array.from(this.relays.values()).filter(\n      (relay) => relay.status >= 5 /* CONNECTED */\n    );\n  }\n  permanentAndConnectedRelays() {\n    return Array.from(this.relays.values()).filter(\n      (relay) => relay.status >= 5 /* CONNECTED */ && !this.temporaryRelayTimers.has(relay.url)\n    );\n  }\n  /**\n   * Get a list of all relay urls in the pool.\n   */\n  urls() {\n    return Array.from(this.relays.keys());\n  }\n};\n\n// src/user/index.ts\n\n\n// src/subscription/index.ts\n\n\n// src/subscription/utils.ts\n\nvar MAX_SUBID_LENGTH = 20;\nfunction queryFullyFilled(subscription) {\n  if (filterIncludesIds(subscription.filter)) {\n    if (resultHasAllRequestedIds(subscription)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction compareFilter(filter1, filter2) {\n  if (Object.keys(filter1).length !== Object.keys(filter2).length) return false;\n  for (const [key, value] of Object.entries(filter1)) {\n    const valuesInFilter2 = filter2[key];\n    if (!valuesInFilter2) return false;\n    if (Array.isArray(value) && Array.isArray(valuesInFilter2)) {\n      const v = value;\n      for (const valueInFilter2 of valuesInFilter2) {\n        const val = valueInFilter2;\n        if (!v.includes(val)) {\n          return false;\n        }\n      }\n    } else {\n      if (valuesInFilter2 !== value) return false;\n    }\n  }\n  return true;\n}\nfunction filterIncludesIds(filter) {\n  return !!filter[\"ids\"];\n}\nfunction resultHasAllRequestedIds(subscription) {\n  const ids = subscription.filter[\"ids\"];\n  return !!ids && ids.length === subscription.eventFirstSeen.size;\n}\nfunction generateSubId(subscriptions, filters) {\n  const subIds = subscriptions.map((sub) => sub.subId).filter(Boolean);\n  const subIdParts = [];\n  const filterNonKindKeys = /* @__PURE__ */ new Set();\n  const filterKinds = /* @__PURE__ */ new Set();\n  if (subIds.length > 0) {\n    subIdParts.push(Array.from(new Set(subIds)).join(\",\"));\n  } else {\n    for (const filter of filters) {\n      for (const key of Object.keys(filter)) {\n        if (key === \"kinds\") {\n          filter.kinds?.forEach((k) => filterKinds.add(k));\n        } else {\n          filterNonKindKeys.add(key);\n        }\n      }\n    }\n    if (filterKinds.size > 0) {\n      subIdParts.push(\"kinds:\" + Array.from(filterKinds).join(\",\"));\n    }\n    if (filterNonKindKeys.size > 0) {\n      subIdParts.push(Array.from(filterNonKindKeys).join(\",\"));\n    }\n  }\n  let subId = subIdParts.join(\"-\");\n  if (subId.length > MAX_SUBID_LENGTH) subId = subId.substring(0, MAX_SUBID_LENGTH);\n  subId += \"-\" + Math.floor(Math.random() * 999).toString();\n  return subId;\n}\nfunction filterForEventsTaggingId(id) {\n  try {\n    const decoded = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.decode(id);\n    switch (decoded.type) {\n      case \"naddr\":\n        return {\n          \"#a\": [\n            `${decoded.data.kind}:${decoded.data.pubkey}:${decoded.data.identifier}`\n          ]\n        };\n      case \"nevent\":\n        return { \"#e\": [decoded.data.id] };\n      case \"note\":\n        return { \"#e\": [decoded.data] };\n      case \"nprofile\":\n        return { \"#p\": [decoded.data.pubkey] };\n      case \"npub\":\n        return { \"#p\": [decoded.data] };\n    }\n  } catch {\n  }\n}\nfunction filterAndRelaySetFromBech32(beche2, ndk) {\n  const filter = filterFromId(beche2);\n  const relays = relaysFromBech32(beche2, ndk);\n  if (relays.length === 0) return { filter };\n  return {\n    filter,\n    relaySet: new NDKRelaySet(new Set(relays), ndk)\n  };\n}\nfunction filterFromId(id) {\n  let decoded;\n  if (id.match(NIP33_A_REGEX)) {\n    const [kind, pubkey, identifier] = id.split(\":\");\n    const filter = {\n      authors: [pubkey],\n      kinds: [parseInt(kind)]\n    };\n    if (identifier) {\n      filter[\"#d\"] = [identifier];\n    }\n    return filter;\n  }\n  if (id.match(BECH32_REGEX)) {\n    try {\n      decoded = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.decode(id);\n      switch (decoded.type) {\n        case \"nevent\": {\n          const filter2 = { ids: [decoded.data.id] };\n          if (decoded.data.author) filter2.authors = [decoded.data.author];\n          if (decoded.data.kind) filter2.kinds = [decoded.data.kind];\n          return filter2;\n        }\n        case \"note\":\n          return { ids: [decoded.data] };\n        case \"naddr\":\n          const filter = {\n            authors: [decoded.data.pubkey],\n            kinds: [decoded.data.kind]\n          };\n          if (decoded.data.identifier) filter[\"#d\"] = [decoded.data.identifier];\n          return filter;\n      }\n    } catch (e) {\n      console.error(\"Error decoding\", id, e);\n    }\n  }\n  return { ids: [id] };\n}\nfunction isNip33AValue(value) {\n  return value.match(NIP33_A_REGEX) !== null;\n}\nvar NIP33_A_REGEX = /^(\\d+):([0-9A-Fa-f]+)(?::(.*))?$/;\nvar BECH32_REGEX = /^n(event|ote|profile|pub|addr)1[\\d\\w]+$/;\nfunction relaysFromBech32(bech322, ndk) {\n  try {\n    const decoded = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.decode(bech322);\n    if ([\"naddr\", \"nevent\"].includes(decoded?.type)) {\n      const data = decoded.data;\n      if (data?.relays) {\n        return data.relays.map(\n          (r) => new NDKRelay(r, ndk.relayAuthDefaultPolicy, ndk)\n        );\n      }\n    }\n  } catch (e) {\n  }\n  return [];\n}\n\n// src/events/kinds/article.ts\nvar NDKArticle = class _NDKArticle extends NDKEvent {\n  static kind = 30023 /* Article */;\n  static kinds = [30023 /* Article */];\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 30023 /* Article */;\n  }\n  /**\n   * Creates a NDKArticle from an existing NDKEvent.\n   *\n   * @param event NDKEvent to create the NDKArticle from.\n   * @returns NDKArticle\n   */\n  static from(event) {\n    return new _NDKArticle(event.ndk, event);\n  }\n  /**\n   * Getter for the article title.\n   *\n   * @returns {string | undefined} - The article title if available, otherwise undefined.\n   */\n  get title() {\n    return this.tagValue(\"title\");\n  }\n  /**\n   * Setter for the article title.\n   *\n   * @param {string | undefined} title - The title to set for the article.\n   */\n  set title(title) {\n    this.removeTag(\"title\");\n    if (title) this.tags.push([\"title\", title]);\n  }\n  /**\n   * Getter for the article image.\n   *\n   * @returns {string | undefined} - The article image if available, otherwise undefined.\n   */\n  get image() {\n    return this.tagValue(\"image\");\n  }\n  /**\n   * Setter for the article image.\n   *\n   * @param {string | undefined} image - The image to set for the article.\n   */\n  set image(image) {\n    this.removeTag(\"image\");\n    if (image) this.tags.push([\"image\", image]);\n  }\n  get summary() {\n    return this.tagValue(\"summary\");\n  }\n  set summary(summary) {\n    this.removeTag(\"summary\");\n    if (summary) this.tags.push([\"summary\", summary]);\n  }\n  /**\n   * Getter for the article's publication timestamp.\n   *\n   * @returns {number | undefined} - The Unix timestamp of when the article was published or undefined.\n   */\n  get published_at() {\n    const tag = this.tagValue(\"published_at\");\n    if (tag) {\n      let val = parseInt(tag);\n      if (val > 1e12) {\n        val = Math.floor(val / 1e3);\n      }\n      return val;\n    }\n    return void 0;\n  }\n  /**\n   * Setter for the article's publication timestamp.\n   *\n   * @param {number | undefined} timestamp - The Unix timestamp to set for the article's publication date.\n   */\n  set published_at(timestamp) {\n    this.removeTag(\"published_at\");\n    if (timestamp !== void 0) {\n      this.tags.push([\"published_at\", timestamp.toString()]);\n    }\n  }\n  /**\n   * Generates content tags for the article.\n   *\n   * This method first checks and sets the publication date if not available,\n   * and then generates content tags based on the base NDKEvent class.\n   *\n   * @returns {ContentTag} - The generated content tags.\n   */\n  async generateTags() {\n    super.generateTags();\n    if (!this.published_at) {\n      this.published_at = this.created_at;\n    }\n    return super.generateTags();\n  }\n  /**\n   * Getter for the article's URL.\n   *\n   * @returns {string | undefined} - The article's URL if available, otherwise undefined.\n   */\n  get url() {\n    return this.tagValue(\"url\");\n  }\n  /**\n   * Setter for the article's URL.\n   *\n   * @param {string | undefined} url - The URL to set for the article.\n   */\n  set url(url) {\n    if (url) {\n      this.tags.push([\"url\", url]);\n    } else {\n      this.removeTag(\"url\");\n    }\n  }\n};\n\n// src/events/kinds/cashu/token.ts\nfunction proofsTotalBalance(proofs) {\n  return proofs.reduce((acc, proof) => {\n    if (proof.amount < 0) {\n      throw new Error(\"proof amount is negative\");\n    }\n    return acc + proof.amount;\n  }, 0);\n}\nvar NDKCashuToken = class _NDKCashuToken extends NDKEvent {\n  _proofs = [];\n  _mint;\n  static kind = 7375 /* CashuToken */;\n  static kinds = [7375 /* CashuToken */];\n  /**\n   * Tokens that this token superseeds\n   */\n  _deletes = [];\n  original;\n  constructor(ndk, event) {\n    super(ndk, event);\n    this.kind ??= 7375 /* CashuToken */;\n  }\n  static async from(event) {\n    const token = new _NDKCashuToken(event.ndk, event);\n    token.original = event;\n    try {\n      await token.decrypt();\n    } catch {\n      token.content = token.original.content;\n    }\n    try {\n      const content = JSON.parse(token.content);\n      token.proofs = content.proofs;\n      token.mint = content.mint ?? token.tagValue(\"mint\");\n      token.deletedTokens = content.del ?? [];\n      if (!Array.isArray(token.proofs)) return;\n    } catch (e) {\n      return;\n    }\n    return token;\n  }\n  get proofs() {\n    return this._proofs;\n  }\n  set proofs(proofs) {\n    const cs = /* @__PURE__ */ new Set();\n    this._proofs = proofs.filter((proof) => {\n      if (cs.has(proof.C)) {\n        console.warn(\"Passed in proofs had duplicates, ignoring\", proof.C);\n        return false;\n      }\n      if (proof.amount < 0) {\n        console.warn(\"Invalid proof with negative amount\", proof);\n        return false;\n      }\n      cs.add(proof.C);\n      return true;\n    }).map(this.cleanProof);\n  }\n  /**\n   * Returns a minimal proof object with only essential properties\n   */\n  cleanProof(proof) {\n    return {\n      id: proof.id,\n      amount: proof.amount,\n      C: proof.C,\n      secret: proof.secret\n    };\n  }\n  async toNostrEvent(pubkey) {\n    const payload = {\n      proofs: this.proofs.map(this.cleanProof),\n      mint: this.mint,\n      del: this.deletedTokens ?? []\n    };\n    this.content = JSON.stringify(payload);\n    const user = await this.ndk.signer.user();\n    await this.encrypt(user, void 0, \"nip44\");\n    return super.toNostrEvent(pubkey);\n  }\n  set mint(mint) {\n    this._mint = mint;\n  }\n  get mint() {\n    return this._mint;\n  }\n  /**\n   * Tokens that were deleted by the creation of this token.\n   */\n  get deletedTokens() {\n    return this._deletes;\n  }\n  /**\n   * Marks tokens that were deleted by the creation of this token.\n   */\n  set deletedTokens(tokenIds) {\n    this._deletes = tokenIds;\n  }\n  get amount() {\n    return proofsTotalBalance(this.proofs);\n  }\n  async publish(relaySet, timeoutMs, requiredRelayCount) {\n    if (this.original) {\n      return this.original.publish(relaySet, timeoutMs, requiredRelayCount);\n    } else {\n      return super.publish(relaySet, timeoutMs, requiredRelayCount);\n    }\n  }\n};\n\n// src/events/kinds/highlight.ts\n\nvar NDKHighlight = class _NDKHighlight extends NDKEvent {\n  _article;\n  static kind = 9802 /* Highlight */;\n  static kinds = [9802 /* Highlight */];\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 9802 /* Highlight */;\n  }\n  static from(event) {\n    return new _NDKHighlight(event.ndk, event);\n  }\n  get url() {\n    return this.tagValue(\"r\");\n  }\n  /**\n   * Context tag.\n   */\n  set context(context) {\n    if (context === void 0) {\n      this.tags = this.tags.filter(([tag, value]) => tag !== \"context\");\n    } else {\n      this.tags = this.tags.filter(([tag, value]) => tag !== \"context\");\n      this.tags.push([\"context\", context]);\n    }\n  }\n  get context() {\n    return this.tags.find(([tag, value]) => tag === \"context\")?.[1] ?? void 0;\n  }\n  /**\n   * Will return the article URL or NDKEvent if they have already been\n   * set (it won't attempt to load remote events)\n   */\n  get article() {\n    return this._article;\n  }\n  /**\n   * Article the highlight is coming from.\n   *\n   * @param article Article URL or NDKEvent.\n   */\n  set article(article) {\n    this._article = article;\n    if (typeof article === \"string\") {\n      this.tags.push([\"r\", article]);\n    } else {\n      this.tag(article);\n    }\n  }\n  getArticleTag() {\n    return this.getMatchingTags(\"a\")[0] || this.getMatchingTags(\"e\")[0] || this.getMatchingTags(\"r\")[0];\n  }\n  async getArticle() {\n    if (this._article !== void 0) return this._article;\n    let taggedBech32;\n    const articleTag = this.getArticleTag();\n    if (!articleTag) return void 0;\n    switch (articleTag[0]) {\n      case \"a\":\n        const [kind, pubkey, identifier] = articleTag[1].split(\":\");\n        taggedBech32 = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.naddrEncode({ kind: parseInt(kind), pubkey, identifier });\n        break;\n      case \"e\":\n        taggedBech32 = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.noteEncode(articleTag[1]);\n        break;\n      case \"r\":\n        this._article = articleTag[1];\n        break;\n    }\n    if (taggedBech32) {\n      let a = await this.ndk?.fetchEvent(taggedBech32);\n      if (a) {\n        if (a.kind === 30023 /* Article */) {\n          a = NDKArticle.from(a);\n        }\n        this._article = a;\n      }\n    }\n    return this._article;\n  }\n};\n\n// src/utils/imeta.ts\nfunction mapImetaTag(tag) {\n  const data = {};\n  if (tag.length === 2) {\n    const parts = tag[1].split(\" \");\n    for (let i = 0; i < parts.length; i += 2) {\n      const key = parts[i];\n      const value = parts[i + 1];\n      if (key === \"fallback\") {\n        if (!data.fallback) data.fallback = [];\n        data.fallback.push(value);\n      } else {\n        data[key] = value;\n      }\n    }\n  }\n  for (const val of tag) {\n    const parts = val.split(\" \");\n    const key = parts[0];\n    const value = parts.slice(1).join(\" \");\n    if (key === \"fallback\") {\n      if (!data.fallback) data.fallback = [];\n      data.fallback.push(value);\n    } else {\n      data[key] = value;\n    }\n  }\n  return data;\n}\nfunction imetaTagToTag(imeta) {\n  const tag = [\"imeta\"];\n  for (const [key, value] of Object.entries(imeta)) {\n    if (Array.isArray(value)) {\n      for (const v of value) {\n        tag.push(key, v);\n      }\n    } else if (value) {\n      tag.push(key, value);\n    }\n  }\n  return tag;\n}\n\n// src/events/kinds/image.ts\nvar NDKImage = class _NDKImage extends NDKEvent {\n  static kind = 20 /* Image */;\n  static kinds = [20 /* Image */];\n  _imetas;\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 20 /* Image */;\n  }\n  /**\n   * Creates a NDKImage from an existing NDKEvent.\n   *\n   * @param event NDKEvent to create the NDKImage from.\n   * @returns NDKImage\n   */\n  static from(event) {\n    return new _NDKImage(event.ndk, event.rawEvent());\n  }\n  get isValid() {\n    return this.imetas.length > 0;\n  }\n  get imetas() {\n    if (this._imetas) return this._imetas;\n    this._imetas = this.tags.filter((tag) => tag[0] === \"imeta\").map(mapImetaTag).filter((imeta) => !!imeta.url);\n    return this._imetas;\n  }\n  set imetas(tags) {\n    this._imetas = tags;\n    this.tags = this.tags.filter((tag) => tag[0] !== \"imeta\");\n    this.tags.push(...tags.map(imetaTagToTag));\n  }\n};\n\n// src/events/kinds/lists/index.ts\nvar NDKList = class _NDKList extends NDKEvent {\n  _encryptedTags;\n  static kinds = [\n    10063 /* BlossomList */,\n    30001 /* CategorizedBookmarkList */,\n    10004 /* CommunityList */,\n    10050 /* DirectMessageReceiveRelayList */,\n    10030 /* EmojiList */,\n    10015 /* InterestList */,\n    10001 /* PinList */,\n    10002 /* RelayList */,\n    10007 /* SearchRelayList */,\n    10006 /* BlockRelayList */,\n    10003 /* BookmarkList */\n  ];\n  /**\n   * Stores the number of bytes the content was before decryption\n   * to expire the cache when the content changes.\n   */\n  encryptedTagsLength;\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 30001 /* CategorizedBookmarkList */;\n  }\n  /**\n   * Wrap a NDKEvent into a NDKList\n   */\n  static from(ndkEvent) {\n    return new _NDKList(ndkEvent.ndk, ndkEvent);\n  }\n  /**\n   * Returns the title of the list. Falls back on fetching the name tag value.\n   */\n  get title() {\n    const titleTag = this.tagValue(\"title\") || this.tagValue(\"name\");\n    if (titleTag) return titleTag;\n    if (this.kind === 3 /* Contacts */) {\n      return \"Contacts\";\n    } else if (this.kind === 1e4 /* MuteList */) {\n      return \"Mute\";\n    } else if (this.kind === 10001 /* PinList */) {\n      return \"Pinned Notes\";\n    } else if (this.kind === 10002 /* RelayList */) {\n      return \"Relay Metadata\";\n    } else if (this.kind === 10003 /* BookmarkList */) {\n      return \"Bookmarks\";\n    } else if (this.kind === 10004 /* CommunityList */) {\n      return \"Communities\";\n    } else if (this.kind === 10005 /* PublicChatList */) {\n      return \"Public Chats\";\n    } else if (this.kind === 10006 /* BlockRelayList */) {\n      return \"Blocked Relays\";\n    } else if (this.kind === 10007 /* SearchRelayList */) {\n      return \"Search Relays\";\n    } else if (this.kind === 10050 /* DirectMessageReceiveRelayList */) {\n      return \"Direct Message Receive Relays\";\n    } else if (this.kind === 10015 /* InterestList */) {\n      return \"Interests\";\n    } else if (this.kind === 10030 /* EmojiList */) {\n      return \"Emojis\";\n    } else {\n      return this.tagValue(\"d\");\n    }\n  }\n  /**\n   * Sets the title of the list.\n   */\n  set title(title) {\n    this.removeTag([\"title\", \"name\"]);\n    if (title) this.tags.push([\"title\", title]);\n  }\n  /**\n   * Returns the name of the list.\n   * @deprecated Please use \"title\" instead.\n   */\n  get name() {\n    return this.title;\n  }\n  /**\n   * Sets the name of the list.\n   * @deprecated Please use \"title\" instead. This method will use the `title` tag instead.\n   */\n  set name(name) {\n    this.title = name;\n  }\n  /**\n   * Returns the description of the list.\n   */\n  get description() {\n    return this.tagValue(\"description\");\n  }\n  /**\n   * Sets the description of the list.\n   */\n  set description(name) {\n    this.removeTag(\"description\");\n    if (name) this.tags.push([\"description\", name]);\n  }\n  /**\n   * Returns the image of the list.\n   */\n  get image() {\n    return this.tagValue(\"image\");\n  }\n  /**\n   * Sets the image of the list.\n   */\n  set image(name) {\n    this.removeTag(\"image\");\n    if (name) this.tags.push([\"image\", name]);\n  }\n  isEncryptedTagsCacheValid() {\n    return !!(this._encryptedTags && this.encryptedTagsLength === this.content.length);\n  }\n  /**\n   * Returns the decrypted content of the list.\n   */\n  async encryptedTags(useCache = true) {\n    if (useCache && this.isEncryptedTagsCacheValid()) return this._encryptedTags;\n    if (!this.ndk) throw new Error(\"NDK instance not set\");\n    if (!this.ndk.signer) throw new Error(\"NDK signer not set\");\n    const user = await this.ndk.signer.user();\n    try {\n      if (this.content.length > 0) {\n        try {\n          const decryptedContent = await this.ndk.signer.decrypt(user, this.content);\n          const a = JSON.parse(decryptedContent);\n          if (a && a[0]) {\n            this.encryptedTagsLength = this.content.length;\n            return this._encryptedTags = a;\n          }\n          this.encryptedTagsLength = this.content.length;\n          return this._encryptedTags = [];\n        } catch (e) {\n          console.log(`error decrypting ${this.content}`);\n        }\n      }\n    } catch (e) {\n    }\n    return [];\n  }\n  /**\n   * This method can be overriden to validate that a tag is valid for this list.\n   *\n   * (i.e. the NDKPersonList can validate that items are NDKUser instances)\n   */\n  validateTag(tagValue) {\n    return true;\n  }\n  getItems(type) {\n    return this.tags.filter((tag) => tag[0] === type);\n  }\n  /**\n   * Returns the unecrypted items in this list.\n   */\n  get items() {\n    return this.tags.filter((t) => {\n      return ![\n        \"d\",\n        \"L\",\n        \"l\",\n        \"title\",\n        \"name\",\n        \"description\",\n        \"published_at\",\n        \"summary\",\n        \"image\",\n        \"thumb\",\n        \"alt\",\n        \"expiration\",\n        \"subject\",\n        \"client\"\n      ].includes(t[0]);\n    });\n  }\n  /**\n   * Adds a new item to the list.\n   * @param relay Relay to add\n   * @param mark Optional mark to add to the item\n   * @param encrypted Whether to encrypt the item\n   * @param position Where to add the item in the list (top or bottom)\n   */\n  async addItem(item, mark = void 0, encrypted = false, position = \"bottom\") {\n    if (!this.ndk) throw new Error(\"NDK instance not set\");\n    if (!this.ndk.signer) throw new Error(\"NDK signer not set\");\n    let tags;\n    if (item instanceof NDKEvent) {\n      tags = [item.tagReference(mark)];\n    } else if (item instanceof NDKUser) {\n      tags = item.referenceTags();\n    } else if (item instanceof NDKRelay) {\n      tags = item.referenceTags();\n    } else if (Array.isArray(item)) {\n      tags = [item];\n    } else {\n      throw new Error(\"Invalid object type\");\n    }\n    if (mark) tags[0].push(mark);\n    if (encrypted) {\n      const user = await this.ndk.signer.user();\n      const currentList = await this.encryptedTags();\n      if (position === \"top\") currentList.unshift(...tags);\n      else currentList.push(...tags);\n      this._encryptedTags = currentList;\n      this.encryptedTagsLength = this.content.length;\n      this.content = JSON.stringify(currentList);\n      await this.encrypt(user);\n    } else {\n      if (position === \"top\") this.tags.unshift(...tags);\n      else this.tags.push(...tags);\n    }\n    this.created_at = Math.floor(Date.now() / 1e3);\n    this.emit(\"change\");\n  }\n  /**\n   * Removes an item from the list from both the encrypted and unencrypted lists.\n   * @param value value of item to remove from the list\n   * @param publish whether to publish the change\n   * @returns\n   */\n  async removeItemByValue(value, publish = true) {\n    if (!this.ndk) throw new Error(\"NDK instance not set\");\n    if (!this.ndk.signer) throw new Error(\"NDK signer not set\");\n    const index = this.tags.findIndex((tag) => tag[1] === value);\n    if (index >= 0) {\n      this.tags.splice(index, 1);\n    }\n    const user = await this.ndk.signer.user();\n    const encryptedTags = await this.encryptedTags();\n    const encryptedIndex = encryptedTags.findIndex((tag) => tag[1] === value);\n    if (encryptedIndex >= 0) {\n      encryptedTags.splice(encryptedIndex, 1);\n      this._encryptedTags = encryptedTags;\n      this.encryptedTagsLength = this.content.length;\n      this.content = JSON.stringify(encryptedTags);\n      await this.encrypt(user);\n    }\n    if (publish) {\n      return this.publishReplaceable();\n    } else {\n      this.created_at = Math.floor(Date.now() / 1e3);\n    }\n    this.emit(\"change\");\n  }\n  /**\n   * Removes an item from the list.\n   *\n   * @param index The index of the item to remove.\n   * @param encrypted Whether to remove from the encrypted list or not.\n   */\n  async removeItem(index, encrypted) {\n    if (!this.ndk) throw new Error(\"NDK instance not set\");\n    if (!this.ndk.signer) throw new Error(\"NDK signer not set\");\n    if (encrypted) {\n      const user = await this.ndk.signer.user();\n      const currentList = await this.encryptedTags();\n      currentList.splice(index, 1);\n      this._encryptedTags = currentList;\n      this.encryptedTagsLength = this.content.length;\n      this.content = JSON.stringify(currentList);\n      await this.encrypt(user);\n    } else {\n      this.tags.splice(index, 1);\n    }\n    this.created_at = Math.floor(Date.now() / 1e3);\n    this.emit(\"change\");\n    return this;\n  }\n  has(item) {\n    return this.items.some((tag) => tag[1] === item);\n  }\n  /**\n   * Creates a filter that will result in fetching\n   * the items of this list\n   * @example\n   * const list = new NDKList(...);\n   * const filters = list.filterForItems();\n   * const events = await ndk.fetchEvents(filters);\n   */\n  filterForItems() {\n    const ids = /* @__PURE__ */ new Set();\n    const nip33Queries = /* @__PURE__ */ new Map();\n    const filters = [];\n    for (const tag of this.items) {\n      if (tag[0] === \"e\" && tag[1]) {\n        ids.add(tag[1]);\n      } else if (tag[0] === \"a\" && tag[1]) {\n        const [kind, pubkey, dTag] = tag[1].split(\":\");\n        if (!kind || !pubkey) continue;\n        const key = `${kind}:${pubkey}`;\n        const item = nip33Queries.get(key) || [];\n        item.push(dTag || \"\");\n        nip33Queries.set(key, item);\n      }\n    }\n    if (ids.size > 0) {\n      filters.push({ ids: Array.from(ids) });\n    }\n    if (nip33Queries.size > 0) {\n      for (const [key, values] of nip33Queries.entries()) {\n        const [kind, pubkey] = key.split(\":\");\n        filters.push({\n          kinds: [parseInt(kind)],\n          authors: [pubkey],\n          \"#d\": values\n        });\n      }\n    }\n    return filters;\n  }\n};\nvar lists_default = NDKList;\n\n// src/events/kinds/nutzap/index.ts\n\nvar NDKNutzap = class _NDKNutzap extends NDKEvent {\n  debug;\n  _proofs = [];\n  static kind = 9321 /* Nutzap */;\n  static kinds = [_NDKNutzap.kind];\n  constructor(ndk, event) {\n    super(ndk, event);\n    this.kind ??= 9321 /* Nutzap */;\n    this.debug = ndk?.debug.extend(\"nutzap\") ?? debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:nutzap\");\n    if (!this.alt) this.alt = \"This is a nutzap\";\n  }\n  static from(event) {\n    const e = new this(event.ndk, event);\n    try {\n      const proofTags = e.getMatchingTags(\"proof\");\n      if (proofTags.length) {\n        e._proofs = proofTags.map((tag) => JSON.parse(tag[1]));\n      } else {\n        e._proofs = JSON.parse(e.content);\n      }\n    } catch {\n      return;\n    }\n    if (!e._proofs || !e._proofs.length) return;\n    return e;\n  }\n  set comment(comment) {\n    this.content = comment ?? \"\";\n  }\n  get comment() {\n    const c = this.tagValue(\"comment\");\n    if (c) return c;\n    return this.content;\n  }\n  set proofs(proofs) {\n    this._proofs = proofs;\n    this.tags = this.tags.filter((tag) => tag[0] !== \"proof\");\n    for (const proof of proofs) {\n      this.tags.push([\"proof\", JSON.stringify(proof)]);\n    }\n  }\n  get proofs() {\n    return this._proofs;\n  }\n  /**\n   * Gets the p2pk pubkey that is embedded in the first proof\n   */\n  get p2pk() {\n    const firstProof = this.proofs[0];\n    try {\n      const secret = JSON.parse(firstProof.secret);\n      let payload = {};\n      if (typeof secret === \"string\") {\n        payload = JSON.parse(secret);\n        this.debug(\"stringified payload\", firstProof.secret);\n      } else if (typeof secret === \"object\") {\n        payload = secret;\n      }\n      const isP2PKLocked = payload[0] === \"P2PK\" && payload[1]?.data;\n      if (isP2PKLocked) {\n        const paddedp2pk = payload[1].data;\n        const p2pk = paddedp2pk.slice(2);\n        if (p2pk) return p2pk;\n      }\n    } catch (e) {\n      this.debug(\"error parsing p2pk pubkey\", e, this.proofs[0]);\n    }\n  }\n  /**\n   * Get the mint where this nutzap proofs exist\n   */\n  get mint() {\n    return this.tagValue(\"u\");\n  }\n  set mint(value) {\n    this.removeTag(\"u\");\n    this.tag([\"u\", value]);\n  }\n  get unit() {\n    return this.tagValue(\"unit\") ?? \"sat\";\n  }\n  set unit(value) {\n    this.removeTag(\"unit\");\n    if (value) this.tag([\"unit\", value]);\n  }\n  get amount() {\n    const amount = this.proofs.reduce((total, proof) => total + proof.amount, 0);\n    if (this.unit === \"msat\") return amount * 1e3;\n    return amount;\n  }\n  sender = this.author;\n  /**\n   * Set the target of the nutzap\n   * @param target The target of the nutzap (a user or an event)\n   */\n  set target(target) {\n    this.tags = this.tags.filter((t) => t[0] !== \"p\");\n    if (target instanceof NDKEvent) {\n      this.tags.push(target.tagReference());\n    }\n  }\n  set recipientPubkey(pubkey) {\n    this.removeTag(\"p\");\n    this.tag([\"p\", pubkey]);\n  }\n  get recipientPubkey() {\n    return this.tagValue(\"p\");\n  }\n  get recipient() {\n    const pubkey = this.recipientPubkey;\n    if (this.ndk) return this.ndk.getUser({ pubkey });\n    return new NDKUser({ pubkey });\n  }\n  async toNostrEvent() {\n    if (this.unit === \"msat\") {\n      this.unit = \"sat\";\n    }\n    this.removeTag(\"amount\");\n    this.tags.push([\"amount\", this.amount.toString()]);\n    const event = await super.toNostrEvent();\n    event.content = this.comment;\n    return event;\n  }\n  /**\n   * Validates that the nutzap conforms to NIP-61\n   */\n  get isValid() {\n    let eTagCount = 0;\n    let pTagCount = 0;\n    let mintTagCount = 0;\n    for (const tag of this.tags) {\n      if (tag[0] === \"e\") eTagCount++;\n      if (tag[0] === \"p\") pTagCount++;\n      if (tag[0] === \"u\") mintTagCount++;\n    }\n    return (\n      // exactly one recipient and mint\n      pTagCount === 1 && mintTagCount === 1 && // must have at most one e tag\n      eTagCount <= 1 && // must have at least one proof\n      this.proofs.length > 0\n    );\n  }\n};\nfunction proofP2pk(proof) {\n  try {\n    const secret = JSON.parse(proof.secret);\n    let payload = {};\n    if (typeof secret === \"string\") {\n      payload = JSON.parse(secret);\n    } else if (typeof secret === \"object\") {\n      payload = secret;\n    }\n    const isP2PKLocked = payload[0] === \"P2PK\" && payload[1]?.data;\n    if (isP2PKLocked) {\n      return payload[1].data;\n    }\n  } catch (e) {\n    console.error(\"error parsing p2pk pubkey\", e, proof);\n  }\n}\nfunction proofP2pkNostr(proof) {\n  const p2pk = proofP2pk(proof);\n  if (!p2pk) return;\n  if (p2pk.startsWith(\"02\") && p2pk.length === 66) return p2pk.slice(2);\n  return p2pk;\n}\n\n// src/events/kinds/nutzap/mint-list.ts\nvar NDKCashuMintList = class _NDKCashuMintList extends NDKEvent {\n  static kind = 10019 /* CashuMintList */;\n  static kinds = [10019 /* CashuMintList */];\n  _p2pk;\n  constructor(ndk, event) {\n    super(ndk, event);\n    this.kind ??= 10019 /* CashuMintList */;\n  }\n  static from(event) {\n    return new _NDKCashuMintList(event.ndk, event);\n  }\n  set relays(urls) {\n    this.tags = this.tags.filter((t) => t[0] !== \"relay\");\n    for (const url of urls) {\n      this.tags.push([\"relay\", url]);\n    }\n  }\n  get relays() {\n    const r = [];\n    for (const tag of this.tags) {\n      if (tag[0] === \"relay\") {\n        r.push(tag[1]);\n      }\n    }\n    return r;\n  }\n  set mints(urls) {\n    this.tags = this.tags.filter((t) => t[0] !== \"mint\");\n    for (const url of urls) {\n      this.tags.push([\"mint\", url]);\n    }\n  }\n  get mints() {\n    const r = [];\n    for (const tag of this.tags) {\n      if (tag[0] === \"mint\") {\n        r.push(tag[1]);\n      }\n    }\n    return Array.from(new Set(r));\n  }\n  get p2pk() {\n    if (this._p2pk) {\n      return this._p2pk;\n    }\n    this._p2pk = this.tagValue(\"pubkey\") ?? this.pubkey;\n    return this._p2pk;\n  }\n  set p2pk(pubkey) {\n    this._p2pk = pubkey;\n    this.removeTag(\"pubkey\");\n    if (pubkey) {\n      this.tags.push([\"pubkey\", pubkey]);\n    }\n  }\n  get relaySet() {\n    return NDKRelaySet.fromRelayUrls(this.relays, this.ndk);\n  }\n};\n\n// src/events/kinds/simple-group/member-list.ts\nvar NDKSimpleGroupMemberList = class _NDKSimpleGroupMemberList extends NDKEvent {\n  relaySet;\n  memberSet = /* @__PURE__ */ new Set();\n  static kind = 39002 /* GroupMembers */;\n  static kinds = [39002 /* GroupMembers */];\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 39002 /* GroupMembers */;\n    this.memberSet = new Set(this.members);\n  }\n  static from(event) {\n    return new _NDKSimpleGroupMemberList(event.ndk, event);\n  }\n  get members() {\n    return this.getMatchingTags(\"p\").map((tag) => tag[1]);\n  }\n  hasMember(member) {\n    return this.memberSet.has(member);\n  }\n  async publish(relaySet, timeoutMs, requiredRelayCount) {\n    relaySet ??= this.relaySet;\n    return super.publishReplaceable(relaySet, timeoutMs, requiredRelayCount);\n  }\n};\n\n// src/events/kinds/simple-group/metadata.ts\nvar NDKSimpleGroupMetadata = class _NDKSimpleGroupMetadata extends NDKEvent {\n  static kind = 39e3 /* GroupMetadata */;\n  static kinds = [39e3 /* GroupMetadata */];\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 39e3 /* GroupMetadata */;\n  }\n  static from(event) {\n    return new _NDKSimpleGroupMetadata(event.ndk, event);\n  }\n  get name() {\n    return this.tagValue(\"name\");\n  }\n  get picture() {\n    return this.tagValue(\"picture\");\n  }\n  get about() {\n    return this.tagValue(\"about\");\n  }\n  get scope() {\n    if (this.getMatchingTags(\"public\").length > 0) return \"public\";\n    if (this.getMatchingTags(\"public\").length > 0) return \"private\";\n  }\n  set scope(scope) {\n    this.removeTag(\"public\");\n    this.removeTag(\"private\");\n    if (scope === \"public\") {\n      this.tags.push([\"public\", \"\"]);\n    } else if (scope === \"private\") {\n      this.tags.push([\"private\", \"\"]);\n    }\n  }\n  get access() {\n    if (this.getMatchingTags(\"open\").length > 0) return \"open\";\n    if (this.getMatchingTags(\"closed\").length > 0) return \"closed\";\n  }\n  set access(access) {\n    this.removeTag(\"open\");\n    this.removeTag(\"closed\");\n    if (access === \"open\") {\n      this.tags.push([\"open\", \"\"]);\n    } else if (access === \"closed\") {\n      this.tags.push([\"closed\", \"\"]);\n    }\n  }\n};\n\n// src/events/kinds/subscriptions/amount.ts\nvar possibleIntervalFrequencies = [\n  \"daily\",\n  \"weekly\",\n  \"monthly\",\n  \"quarterly\",\n  \"yearly\"\n];\nfunction calculateTermDurationInSeconds(term) {\n  switch (term) {\n    case \"daily\":\n      return 24 * 60 * 60;\n    case \"weekly\":\n      return 7 * 24 * 60 * 60;\n    case \"monthly\":\n      return 30 * 24 * 60 * 60;\n    case \"quarterly\":\n      return 3 * 30 * 24 * 60 * 60;\n    case \"yearly\":\n      return 365 * 24 * 60 * 60;\n  }\n}\nfunction newAmount(amount, currency, term) {\n  return [\"amount\", amount.toString(), currency, term];\n}\nfunction parseTagToSubscriptionAmount(tag) {\n  const amount = parseInt(tag[1]);\n  if (isNaN(amount) || amount === void 0 || amount === null || amount <= 0) return void 0;\n  const currency = tag[2];\n  if (currency === void 0 || currency === \"\") return void 0;\n  const term = tag[3];\n  if (term === void 0) return void 0;\n  if (!possibleIntervalFrequencies.includes(term)) return void 0;\n  return {\n    amount,\n    currency,\n    term\n  };\n}\n\n// src/events/kinds/subscriptions/tier.ts\nvar NDKSubscriptionTier = class _NDKSubscriptionTier extends NDKArticle {\n  static kind = 37001 /* SubscriptionTier */;\n  static kinds = [37001 /* SubscriptionTier */];\n  constructor(ndk, rawEvent) {\n    const k = rawEvent?.kind ?? 37001 /* SubscriptionTier */;\n    super(ndk, rawEvent);\n    this.kind = k;\n  }\n  /**\n   * Creates a new NDKSubscriptionTier from an event\n   * @param event\n   * @returns NDKSubscriptionTier\n   */\n  static from(event) {\n    return new _NDKSubscriptionTier(event.ndk, event);\n  }\n  /**\n   * Returns perks for this tier\n   */\n  get perks() {\n    return this.getMatchingTags(\"perk\").map((tag) => tag[1]).filter((perk) => perk !== void 0);\n  }\n  /**\n   * Adds a perk to this tier\n   */\n  addPerk(perk) {\n    this.tags.push([\"perk\", perk]);\n  }\n  /**\n   * Returns the amount for this tier\n   */\n  get amounts() {\n    return this.getMatchingTags(\"amount\").map((tag) => parseTagToSubscriptionAmount(tag)).filter((a) => a !== void 0);\n  }\n  /**\n   * Adds an amount to this tier\n   * @param amount Amount in the smallest unit of the currency (e.g. cents, msats)\n   * @param currency Currency code. Use msat for millisatoshis\n   * @param term One of daily, weekly, monthly, quarterly, yearly\n   */\n  addAmount(amount, currency, term) {\n    this.tags.push(newAmount(amount, currency, term));\n  }\n  /**\n   * Sets a relay where content related to this tier can be found\n   * @param relayUrl URL of the relay\n   */\n  set relayUrl(relayUrl) {\n    this.tags.push([\"r\", relayUrl]);\n  }\n  /**\n   * Returns the relay URLs for this tier\n   */\n  get relayUrls() {\n    return this.getMatchingTags(\"r\").map((tag) => tag[1]).filter((relay) => relay !== void 0);\n  }\n  /**\n   * Gets the verifier pubkey for this tier. This is the pubkey that will generate\n   * subscription payment receipts\n   */\n  get verifierPubkey() {\n    return this.tagValue(\"p\");\n  }\n  /**\n   * Sets the verifier pubkey for this tier.\n   */\n  set verifierPubkey(pubkey) {\n    this.removeTag(\"p\");\n    if (pubkey) this.tags.push([\"p\", pubkey]);\n  }\n  /**\n   * Checks if this tier is valid\n   */\n  get isValid() {\n    return this.title !== void 0 && // Must have a title\n    this.amounts.length > 0;\n  }\n};\n\n// src/events/kinds/video.ts\nvar NDKVideo = class _NDKVideo extends NDKEvent {\n  static kind = 34235 /* HorizontalVideo */;\n  static kinds = [34235 /* HorizontalVideo */, 34236 /* VerticalVideo */];\n  _imetas;\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 34235 /* HorizontalVideo */;\n  }\n  /**\n   * Creates a NDKArticle from an existing NDKEvent.\n   *\n   * @param event NDKEvent to create the NDKArticle from.\n   * @returns NDKArticle\n   */\n  static from(event) {\n    return new _NDKVideo(event.ndk, event.rawEvent());\n  }\n  /**\n   * Getter for the article title.\n   *\n   * @returns {string | undefined} - The article title if available, otherwise undefined.\n   */\n  get title() {\n    return this.tagValue(\"title\");\n  }\n  /**\n   * Setter for the article title.\n   *\n   * @param {string | undefined} title - The title to set for the article.\n   */\n  set title(title) {\n    this.removeTag(\"title\");\n    if (title) this.tags.push([\"title\", title]);\n  }\n  /**\n   * Getter for the article thumbnail.\n   *\n   * @returns {string | undefined} - The article thumbnail if available, otherwise undefined.\n   */\n  get thumbnail() {\n    let thumbnail;\n    if (this.imetas && this.imetas.length > 0) {\n      thumbnail = this.imetas[0].image?.[0];\n    }\n    return thumbnail ?? this.tagValue(\"thumb\");\n  }\n  get imetas() {\n    if (this._imetas) return this._imetas;\n    this._imetas = this.tags.filter((tag) => tag[0] === \"imeta\").map(mapImetaTag);\n    return this._imetas;\n  }\n  set imetas(tags) {\n    this._imetas = tags;\n    this.tags = this.tags.filter((tag) => tag[0] !== \"imeta\");\n    this.tags.push(...tags.map(imetaTagToTag));\n  }\n  get url() {\n    if (this.imetas && this.imetas.length > 0) {\n      return this.imetas[0].url;\n    }\n    return this.tagValue(\"url\");\n  }\n  /**\n   * Getter for the article's publication timestamp.\n   *\n   * @returns {number | undefined} - The Unix timestamp of when the article was published or undefined.\n   */\n  get published_at() {\n    const tag = this.tagValue(\"published_at\");\n    if (tag) {\n      return parseInt(tag);\n    }\n    return void 0;\n  }\n  /**\n   * Setter for the article's publication timestamp.\n   *\n   * @param {number | undefined} timestamp - The Unix timestamp to set for the article's publication date.\n   */\n  set published_at(timestamp) {\n    this.removeTag(\"published_at\");\n    if (timestamp !== void 0) {\n      this.tags.push([\"published_at\", timestamp.toString()]);\n    }\n  }\n  /**\n   * Generates content tags for the article.\n   *\n   * This method first checks and sets the publication date if not available,\n   * and then generates content tags based on the base NDKEvent class.\n   *\n   * @returns {ContentTag} - The generated content tags.\n   */\n  async generateTags() {\n    super.generateTags();\n    if (!this.published_at) {\n      this.published_at = this.created_at;\n    }\n    return super.generateTags();\n  }\n  get duration() {\n    const tag = this.tagValue(\"duration\");\n    if (tag) {\n      return parseInt(tag);\n    }\n    return void 0;\n  }\n  /**\n   * Setter for the video's duration\n   *\n   * @param {number | undefined} duration - The duration to set for the video (in seconds)\n   */\n  set duration(dur) {\n    this.removeTag(\"duration\");\n    if (dur !== void 0) {\n      this.tags.push([\"duration\", Math.floor(dur).toString()]);\n    }\n  }\n};\n\n// src/events/kinds/wiki.ts\nvar NDKWiki = class extends NDKArticle {\n  static kind = 30818 /* Wiki */;\n  static kinds = [30818 /* Wiki */];\n};\n\n// src/events/wrap.ts\nfunction wrapEvent(event) {\n  const eventWrappingMap = /* @__PURE__ */ new Map();\n  [\n    NDKImage,\n    NDKVideo,\n    NDKCashuMintList,\n    NDKArticle,\n    NDKHighlight,\n    NDKWiki,\n    NDKNutzap,\n    NDKSimpleGroupMemberList,\n    NDKSimpleGroupMetadata,\n    NDKSubscriptionTier,\n    NDKCashuToken,\n    NDKList\n  ].forEach((klass2) => {\n    klass2.kinds.forEach((kind) => {\n      eventWrappingMap.set(kind, klass2);\n    });\n  });\n  const klass = eventWrappingMap.get(event.kind);\n  if (klass) return klass.from(event);\n  return event;\n}\n\n// src/subscription/index.ts\nvar NDKSubscriptionCacheUsage = /* @__PURE__ */ ((NDKSubscriptionCacheUsage2) => {\n  NDKSubscriptionCacheUsage2[\"ONLY_CACHE\"] = \"ONLY_CACHE\";\n  NDKSubscriptionCacheUsage2[\"CACHE_FIRST\"] = \"CACHE_FIRST\";\n  NDKSubscriptionCacheUsage2[\"PARALLEL\"] = \"PARALLEL\";\n  NDKSubscriptionCacheUsage2[\"ONLY_RELAY\"] = \"ONLY_RELAY\";\n  return NDKSubscriptionCacheUsage2;\n})(NDKSubscriptionCacheUsage || {});\nvar defaultOpts = {\n  closeOnEose: false,\n  cacheUsage: \"CACHE_FIRST\" /* CACHE_FIRST */,\n  dontSaveToCache: false,\n  groupable: true,\n  groupableDelay: 100,\n  groupableDelayType: \"at-most\",\n  cacheUnconstrainFilter: [\"limit\", \"since\", \"until\"]\n};\nvar NDKSubscription = class extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  subId;\n  filters;\n  opts;\n  pool;\n  skipVerification = false;\n  skipValidation = false;\n  /**\n   * Tracks the filters as they are executed on each relay\n   */\n  relayFilters;\n  relaySet;\n  ndk;\n  debug;\n  /**\n   * Events that have been seen by the subscription, with the time they were first seen.\n   */\n  eventFirstSeen = /* @__PURE__ */ new Map();\n  /**\n   * Relays that have sent an EOSE.\n   */\n  eosesSeen = /* @__PURE__ */ new Set();\n  /**\n   * The time the last event was received by the subscription.\n   * This is used to calculate when EOSE should be emitted.\n   */\n  lastEventReceivedAt;\n  internalId;\n  /**\n   * Whether the subscription should close when all relays have reached the end of the event stream.\n   */\n  closeOnEose;\n  /**\n   * Pool monitor callback\n   */\n  poolMonitor;\n  skipOptimisticPublishEvent = false;\n  /**\n   * Filters to remove when querying the cache.\n   */\n  cacheUnconstrainFilter;\n  constructor(ndk, filters, opts, relaySet, subId) {\n    super();\n    this.ndk = ndk;\n    this.pool = opts?.pool || ndk.pool;\n    this.opts = { ...defaultOpts, ...opts || {} };\n    this.filters = filters instanceof Array ? filters : [filters];\n    this.subId = subId || this.opts.subId;\n    this.internalId = Math.random().toString(36).substring(7);\n    this.relaySet = relaySet;\n    this.debug = ndk.debug.extend(`subscription[${this.opts.subId ?? this.internalId}]`);\n    this.skipVerification = this.opts.skipVerification || false;\n    this.skipValidation = this.opts.skipValidation || false;\n    this.closeOnEose = this.opts.closeOnEose || false;\n    this.skipOptimisticPublishEvent = this.opts.skipOptimisticPublishEvent || false;\n    this.cacheUnconstrainFilter = this.opts.cacheUnconstrainFilter;\n  }\n  /**\n   * Returns the relays that have not yet sent an EOSE.\n   */\n  relaysMissingEose() {\n    if (!this.relayFilters) return [];\n    const relaysMissingEose = Array.from(this.relayFilters.keys()).filter(\n      (url) => !this.eosesSeen.has(this.pool.getRelay(url, false, false))\n    );\n    return relaysMissingEose;\n  }\n  /**\n   * Provides access to the first filter of the subscription for\n   * backwards compatibility.\n   */\n  get filter() {\n    return this.filters[0];\n  }\n  get groupableDelay() {\n    if (!this.isGroupable()) return void 0;\n    return this.opts?.groupableDelay;\n  }\n  get groupableDelayType() {\n    return this.opts?.groupableDelayType || \"at-most\";\n  }\n  isGroupable() {\n    return this.opts?.groupable || false;\n  }\n  shouldQueryCache() {\n    if (this.opts?.cacheUsage === \"ONLY_RELAY\" /* ONLY_RELAY */) return false;\n    const hasNonEphemeralKind = this.filters.some((f) => f.kinds?.some((k) => kindIsEphemeral(k)));\n    if (hasNonEphemeralKind) return true;\n    return true;\n  }\n  shouldQueryRelays() {\n    return this.opts?.cacheUsage !== \"ONLY_CACHE\" /* ONLY_CACHE */;\n  }\n  shouldWaitForCache() {\n    return (\n      // Must want to close on EOSE; subscriptions\n      // that want to receive further updates must\n      // always hit the relay\n      this.opts.closeOnEose && // Cache adapter must claim to be fast\n      !!this.ndk.cacheAdapter?.locking && // If explicitly told to run in parallel, then\n      // we should not wait for the cache\n      this.opts.cacheUsage !== \"PARALLEL\" /* PARALLEL */\n    );\n  }\n  /**\n   * Start the subscription. This is the main method that should be called\n   * after creating a subscription.\n   * \n   * @param emitCachedEvents - Whether to emit events coming from a synchronous cache\n   * \n   * When using a synchronous cache, the events will be returned immediately\n   * by this function. If you will use those returned events, you should\n   * set emitCachedEvents to false to prevent seeing them as duplicate events.\n   */\n  start(emitCachedEvents = true) {\n    let cacheResult;\n    const updateStateFromCacheResults = (events) => {\n      if (emitCachedEvents) {\n        for (const event of events) {\n          this.eventReceived(event, void 0, true, false);\n        }\n      } else {\n        cacheResult = [];\n        events.forEach((event) => {\n          event.ndk = this.ndk;\n          const e = this.opts.wrap ? wrapEvent(event) : event;\n          if (!e) return;\n          if (e instanceof Promise) {\n            e.then((wrappedEvent) => {\n              this.emitEvent(false, wrappedEvent, void 0, true, false);\n            });\n            return;\n          }\n          this.eventFirstSeen.set(e.id, Date.now());\n          cacheResult.push(e);\n        });\n      }\n    };\n    const loadFromRelays = () => {\n      if (this.shouldQueryRelays()) {\n        this.startWithRelays();\n        this.startPoolMonitor();\n      } else {\n        this.emit(\"eose\", this);\n      }\n    };\n    if (this.shouldQueryCache()) {\n      cacheResult = this.startWithCache();\n      if (cacheResult instanceof Promise) {\n        if (this.shouldWaitForCache()) {\n          cacheResult.then((events) => {\n            updateStateFromCacheResults(events);\n            if (queryFullyFilled(this)) {\n              this.emit(\"eose\", this);\n              return;\n            } else {\n              loadFromRelays();\n            }\n          });\n          return null;\n        } else {\n          cacheResult.then((events) => {\n            updateStateFromCacheResults(events);\n          });\n        }\n        return null;\n      } else {\n        updateStateFromCacheResults(cacheResult);\n        if (queryFullyFilled(this)) {\n          this.emit(\"eose\", this);\n        } else {\n          loadFromRelays();\n        }\n        return cacheResult;\n      }\n    } else {\n      loadFromRelays();\n      return null;\n    }\n  }\n  /**\n   * We want to monitor for new relays that are coming online, in case\n   * they should be part of this subscription.\n   */\n  startPoolMonitor() {\n    const d4 = this.debug.extend(\"pool-monitor\");\n    this.poolMonitor = (relay) => {\n      if (this.relayFilters?.has(relay.url)) return;\n      const calc = calculateRelaySetsFromFilters(this.ndk, this.filters, this.pool);\n      if (calc.get(relay.url)) {\n        this.relayFilters?.set(relay.url, this.filters);\n        relay.subscribe(this, this.filters);\n      }\n    };\n    this.pool.on(\"relay:connect\", this.poolMonitor);\n  }\n  onStopped;\n  stop() {\n    this.emit(\"close\", this);\n    this.poolMonitor && this.pool.off(\"relay:connect\", this.poolMonitor);\n    this.removeAllListeners();\n    this.onStopped?.();\n  }\n  /**\n   * @returns Whether the subscription has an authors filter.\n   */\n  hasAuthorsFilter() {\n    return this.filters.some((f) => f.authors?.length);\n  }\n  startWithCache() {\n    if (this.ndk.cacheAdapter?.query) {\n      return this.ndk.cacheAdapter.query(this);\n    } else {\n      return [];\n    }\n  }\n  /**\n   * Send REQ to relays\n   */\n  startWithRelays() {\n    if (!this.relaySet || this.relaySet.relays.size === 0) {\n      this.relayFilters = calculateRelaySetsFromFilters(this.ndk, this.filters, this.pool);\n    } else {\n      this.relayFilters = /* @__PURE__ */ new Map();\n      for (const relay of this.relaySet.relays) {\n        this.relayFilters.set(relay.url, this.filters);\n      }\n    }\n    if (!this.relayFilters || this.relayFilters.size === 0) return;\n    for (const [relayUrl, filters] of this.relayFilters) {\n      const relay = this.pool.getRelay(relayUrl, true, true, filters);\n      relay.subscribe(this, filters);\n    }\n  }\n  // EVENT handling\n  /**\n   * Called when an event is received from a relay or the cache\n   * @param event\n   * @param relay\n   * @param fromCache Whether the event was received from the cache\n   * @param optimisticPublish Whether this event is coming from an optimistic publish\n   */\n  eventReceived(event, relay, fromCache = false, optimisticPublish = false) {\n    const eventId = event.id;\n    const eventAlreadySeen = this.eventFirstSeen.has(eventId);\n    let ndkEvent;\n    if (event instanceof NDKEvent) ndkEvent = event;\n    if (!eventAlreadySeen) {\n      ndkEvent ??= new NDKEvent(this.ndk, event);\n      ndkEvent.ndk = this.ndk;\n      ndkEvent.relay = relay;\n      if (!fromCache && !optimisticPublish) {\n        if (!this.skipValidation) {\n          if (!ndkEvent.isValid) {\n            this.debug(`Event failed validation %s from relay %s`, eventId, relay?.url);\n            return;\n          }\n        }\n        if (relay) {\n          if (relay?.shouldValidateEvent() !== false) {\n            if (!this.skipVerification) {\n              if (!ndkEvent.verifySignature(true) && !this.ndk.asyncSigVerification) {\n                this.debug(`Event failed signature validation`, event);\n                return;\n              } else if (relay) {\n                relay.addValidatedEvent();\n              }\n            }\n          } else {\n            relay.addNonValidatedEvent();\n          }\n        }\n        if (this.ndk.cacheAdapter && !this.opts.dontSaveToCache) {\n          this.ndk.cacheAdapter.setEvent(ndkEvent, this.filters, relay);\n        }\n      }\n      if (!optimisticPublish || this.skipOptimisticPublishEvent !== true) {\n        this.emitEvent(this.opts?.wrap, ndkEvent, relay, fromCache, optimisticPublish);\n        this.eventFirstSeen.set(eventId, Date.now());\n      }\n    } else {\n      const timeSinceFirstSeen = Date.now() - (this.eventFirstSeen.get(eventId) || 0);\n      this.emit(\"event:dup\", event, relay, timeSinceFirstSeen, this, fromCache, optimisticPublish);\n      if (relay) {\n        const signature = verifiedSignatures.get(eventId);\n        if (signature && typeof signature === \"string\") {\n          if (event.sig === signature) {\n            relay.addValidatedEvent();\n          }\n        }\n      }\n    }\n    this.lastEventReceivedAt = Date.now();\n  }\n  /**\n   * Optionally wraps, sync or async, and emits the event (if one comes back from the wrapper)\n   */\n  emitEvent(wrap = false, evt, relay, fromCache, optimisticPublish) {\n    const wrapped = wrap ? wrapEvent(evt) : evt;\n    if (wrapped instanceof Promise) {\n      wrapped.then((e) => this.emitEvent(false, e, relay, fromCache, optimisticPublish));\n    } else if (wrapped) {\n      this.emit(\"event\", wrapped, relay, this, fromCache, optimisticPublish);\n    }\n  }\n  closedReceived(relay, reason) {\n    this.emit(\"closed\", relay, reason);\n  }\n  // EOSE handling\n  eoseTimeout;\n  eosed = false;\n  eoseReceived(relay) {\n    this.debug(\"EOSE received from %s\", relay.url);\n    this.eosesSeen.add(relay);\n    let lastEventSeen = this.lastEventReceivedAt ? Date.now() - this.lastEventReceivedAt : void 0;\n    const hasSeenAllEoses = this.eosesSeen.size === this.relayFilters?.size;\n    const queryFilled = queryFullyFilled(this);\n    const performEose = (reason) => {\n      this.debug(\"Performing EOSE: %s %d\", reason, this.eosed);\n      if (this.eosed) return;\n      if (this.eoseTimeout) clearTimeout(this.eoseTimeout);\n      this.emit(\"eose\", this);\n      this.eosed = true;\n    };\n    if (queryFilled || hasSeenAllEoses) {\n      performEose(\"query filled or seen all\");\n    } else if (this.relayFilters) {\n      let timeToWaitForNextEose = 1e3;\n      const connectedRelays = new Set(this.pool.connectedRelays().map((r) => r.url));\n      const connectedRelaysWithFilters = Array.from(this.relayFilters.keys()).filter(\n        (url) => connectedRelays.has(url)\n      );\n      if (connectedRelaysWithFilters.length === 0) {\n        return;\n      }\n      const percentageOfRelaysThatHaveSentEose = this.eosesSeen.size / connectedRelaysWithFilters.length;\n      this.debug(\"Percentage of relays that have sent EOSE\", { subId: this.subId, percentageOfRelaysThatHaveSentEose, seen: this.eosesSeen.size, total: connectedRelaysWithFilters.length });\n      if (this.eosesSeen.size >= 2 && percentageOfRelaysThatHaveSentEose >= 0.5) {\n        timeToWaitForNextEose = timeToWaitForNextEose * (1 - percentageOfRelaysThatHaveSentEose);\n        if (timeToWaitForNextEose === 0) {\n          performEose(\"time to wait was 0\");\n          return;\n        }\n        if (this.eoseTimeout) clearTimeout(this.eoseTimeout);\n        const sendEoseTimeout = () => {\n          lastEventSeen = this.lastEventReceivedAt ? Date.now() - this.lastEventReceivedAt : void 0;\n          if (lastEventSeen !== void 0 && lastEventSeen < 20) {\n            this.eoseTimeout = setTimeout(sendEoseTimeout, timeToWaitForNextEose);\n          } else {\n            performEose(\"send eose timeout: \" + timeToWaitForNextEose);\n          }\n        };\n        this.eoseTimeout = setTimeout(sendEoseTimeout, timeToWaitForNextEose);\n      }\n    }\n  }\n};\nvar kindIsEphemeral = (kind) => kind >= 2e4 && kind < 3e4;\n\n// src/user/follows.ts\nasync function follows(opts, outbox, kind = 3 /* Contacts */) {\n  if (!this.ndk) throw new Error(\"NDK not set\");\n  const contactListEvent = await this.ndk.fetchEvent(\n    { kinds: [kind], authors: [this.pubkey] },\n    opts || { groupable: false }\n  );\n  if (contactListEvent) {\n    const pubkeys = /* @__PURE__ */ new Set();\n    contactListEvent.tags.forEach((tag) => {\n      if (tag[0] === \"p\") pubkeys.add(tag[1]);\n    });\n    if (outbox) {\n      this.ndk?.outboxTracker?.trackUsers(Array.from(pubkeys));\n    }\n    return [...pubkeys].reduce((acc, pubkey) => {\n      const user = new NDKUser({ pubkey });\n      user.ndk = this.ndk;\n      acc.add(user);\n      return acc;\n    }, /* @__PURE__ */ new Set());\n  }\n  return /* @__PURE__ */ new Set();\n}\n\n// src/user/profile.ts\nfunction profileFromEvent(event) {\n  const profile = {};\n  let payload;\n  try {\n    payload = JSON.parse(event.content);\n  } catch (error) {\n    throw new Error(`Failed to parse profile event: ${error}`);\n  }\n  profile.created_at = event.created_at;\n  profile.profileEvent = JSON.stringify(event.rawEvent());\n  Object.keys(payload).forEach((key) => {\n    switch (key) {\n      case \"name\":\n        profile.name = payload.name;\n        break;\n      case \"display_name\":\n        profile.displayName = payload.display_name;\n        break;\n      case \"image\":\n      case \"picture\":\n        profile.picture = payload.picture || payload.image;\n        profile.image = profile.picture;\n        break;\n      case \"banner\":\n        profile.banner = payload.banner;\n        break;\n      case \"bio\":\n        profile.bio = payload.bio;\n        break;\n      case \"nip05\":\n        profile.nip05 = payload.nip05;\n        break;\n      case \"lud06\":\n        profile.lud06 = payload.lud06;\n        break;\n      case \"lud16\":\n        profile.lud16 = payload.lud16;\n        break;\n      case \"about\":\n        profile.about = payload.about;\n        break;\n      case \"website\":\n        profile.website = payload.website;\n        break;\n      default:\n        profile[key] = payload[key];\n        break;\n    }\n  });\n  return profile;\n}\nfunction serializeProfile(profile) {\n  const payload = {};\n  for (const [key, val] of Object.entries(profile)) {\n    switch (key) {\n      case \"username\":\n      case \"name\":\n        payload.name = val;\n        break;\n      case \"displayName\":\n        payload.display_name = val;\n        break;\n      case \"image\":\n      case \"picture\":\n        payload.picture = val;\n        break;\n      case \"bio\":\n      case \"about\":\n        payload.about = val;\n        break;\n      default:\n        payload[key] = val;\n        break;\n    }\n  }\n  return JSON.stringify(payload);\n}\n\n// src/user/nip05.ts\nvar NIP05_REGEX = /^(?:([\\w.+-]+)@)?([\\w.-]+)$/;\nasync function getNip05For(ndk, fullname, _fetch = fetch, fetchOpts = {}) {\n  return await ndk.queuesNip05.add({\n    id: fullname,\n    func: async () => {\n      if (ndk.cacheAdapter && ndk.cacheAdapter.loadNip05) {\n        const profile = await ndk.cacheAdapter.loadNip05(fullname);\n        if (profile !== \"missing\") {\n          if (profile) {\n            const user = new NDKUser({\n              pubkey: profile.pubkey,\n              relayUrls: profile.relays,\n              nip46Urls: profile.nip46\n            });\n            user.ndk = ndk;\n            return user;\n          } else if (fetchOpts.cache !== \"no-cache\") {\n            return null;\n          }\n        }\n      }\n      const match = fullname.match(NIP05_REGEX);\n      if (!match) return null;\n      const [_, name = \"_\", domain] = match;\n      try {\n        const res = await _fetch(\n          `https://${domain}/.well-known/nostr.json?name=${name}`,\n          fetchOpts\n        );\n        const { names, relays, nip46 } = parseNIP05Result(await res.json());\n        const pubkey = names[name.toLowerCase()];\n        let profile = null;\n        if (pubkey) {\n          profile = { pubkey, relays: relays?.[pubkey], nip46: nip46?.[pubkey] };\n        }\n        if (ndk?.cacheAdapter && ndk.cacheAdapter.saveNip05) {\n          ndk.cacheAdapter.saveNip05(fullname, profile);\n        }\n        return profile;\n      } catch (_e) {\n        if (ndk?.cacheAdapter && ndk.cacheAdapter.saveNip05) {\n          ndk?.cacheAdapter.saveNip05(fullname, null);\n        }\n        console.error(\"Failed to fetch NIP05 for\", fullname, _e);\n        return null;\n      }\n    }\n  });\n}\nfunction parseNIP05Result(json) {\n  const result = {\n    names: {}\n  };\n  for (const [name, pubkey] of Object.entries(json.names)) {\n    if (typeof name === \"string\" && typeof pubkey === \"string\") {\n      result.names[name.toLowerCase()] = pubkey;\n    }\n  }\n  if (json.relays) {\n    result.relays = {};\n    for (const [pubkey, relays] of Object.entries(json.relays)) {\n      if (typeof pubkey === \"string\" && Array.isArray(relays)) {\n        result.relays[pubkey] = relays.filter(\n          (relay) => typeof relay === \"string\"\n        );\n      }\n    }\n  }\n  if (json.nip46) {\n    result.nip46 = {};\n    for (const [pubkey, nip46] of Object.entries(json.nip46)) {\n      if (typeof pubkey === \"string\" && Array.isArray(nip46)) {\n        result.nip46[pubkey] = nip46.filter((relay) => typeof relay === \"string\");\n      }\n    }\n  }\n  return result;\n}\n\n// src/user/index.ts\nvar NDKUser = class _NDKUser {\n  ndk;\n  profile;\n  profileEvent;\n  _npub;\n  _pubkey;\n  relayUrls = [];\n  nip46Urls = [];\n  constructor(opts) {\n    if (opts.npub) this._npub = opts.npub;\n    if (opts.hexpubkey) this._pubkey = opts.hexpubkey;\n    if (opts.pubkey) this._pubkey = opts.pubkey;\n    if (opts.relayUrls) this.relayUrls = opts.relayUrls;\n    if (opts.nip46Urls) this.nip46Urls = opts.nip46Urls;\n  }\n  get npub() {\n    if (!this._npub) {\n      if (!this._pubkey) throw new Error(\"pubkey not set\");\n      this._npub = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.npubEncode(this.pubkey);\n    }\n    return this._npub;\n  }\n  get nprofile() {\n    const relays = this.profileEvent?.onRelays?.map((r) => r.url);\n    return nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.nprofileEncode({\n      pubkey: this.pubkey,\n      relays\n    });\n  }\n  set npub(npub) {\n    this._npub = npub;\n  }\n  /**\n   * Get the user's pubkey\n   * @returns {string} The user's pubkey\n   */\n  get pubkey() {\n    if (!this._pubkey) {\n      if (!this._npub) throw new Error(\"npub not set\");\n      this._pubkey = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.decode(this.npub).data;\n    }\n    return this._pubkey;\n  }\n  /**\n   * Set the user's pubkey\n   * @param pubkey {string} The user's pubkey\n   */\n  set pubkey(pubkey) {\n    this._pubkey = pubkey;\n  }\n  /**\n   * Equivalent to NDKEvent.filters().\n   * @returns {NDKFilter}\n   */\n  filter() {\n    return { \"#p\": [this.pubkey] };\n  }\n  /**\n   * Gets NIP-57 and NIP-61 information that this user has signaled\n   *\n   * @param getAll {boolean} Whether to get all zap info or just the first one\n   */\n  async getZapInfo(timeoutMs) {\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    const promiseWithTimeout = async (promise) => {\n      if (!timeoutMs) return promise;\n      try {\n        return await Promise.race([\n          promise,\n          new Promise((_, reject) => setTimeout(() => reject(), timeoutMs))\n        ]);\n      } catch {\n        return void 0;\n      }\n    };\n    const [userProfile, mintListEvent] = await Promise.all([\n      promiseWithTimeout(this.fetchProfile()),\n      promiseWithTimeout(this.ndk.fetchEvent({ kinds: [10019 /* CashuMintList */], authors: [this.pubkey] }))\n    ]);\n    const res = /* @__PURE__ */ new Map();\n    if (mintListEvent) {\n      const mintList = NDKCashuMintList.from(mintListEvent);\n      if (mintList.mints.length > 0) {\n        res.set(\"nip61\", {\n          mints: mintList.mints,\n          relays: mintList.relays,\n          p2pk: mintList.p2pk\n        });\n      }\n    }\n    if (userProfile) {\n      const { lud06, lud16 } = userProfile;\n      res.set(\"nip57\", { lud06, lud16 });\n    }\n    return res;\n  }\n  /**\n   * Instantiate an NDKUser from a NIP-05 string\n   * @param nip05Id {string} The user's NIP-05\n   * @param ndk {NDK} An NDK instance\n   * @param skipCache {boolean} Whether to skip the cache or not\n   * @returns {NDKUser | undefined} An NDKUser if one is found for the given NIP-05, undefined otherwise.\n   */\n  static async fromNip05(nip05Id, ndk, skipCache = false) {\n    if (!ndk) throw new Error(\"No NDK instance found\");\n    const opts = {};\n    if (skipCache) opts.cache = \"no-cache\";\n    const profile = await getNip05For(ndk, nip05Id, ndk?.httpFetch, opts);\n    if (profile) {\n      const user = new _NDKUser({\n        pubkey: profile.pubkey,\n        relayUrls: profile.relays,\n        nip46Urls: profile.nip46\n      });\n      user.ndk = ndk;\n      return user;\n    }\n  }\n  /**\n   * Fetch a user's profile\n   * @param opts {NDKSubscriptionOptions} A set of NDKSubscriptionOptions\n   * @param storeProfileEvent {boolean} Whether to store the profile event or not\n   * @returns User Profile\n   */\n  async fetchProfile(opts, storeProfileEvent = false) {\n    if (!this.ndk) throw new Error(\"NDK not set\");\n    if (!this.profile) this.profile = {};\n    let setMetadataEvent = null;\n    if (this.ndk.cacheAdapter && this.ndk.cacheAdapter.fetchProfile && opts?.cacheUsage !== \"ONLY_RELAY\" /* ONLY_RELAY */) {\n      const profile = await this.ndk.cacheAdapter.fetchProfile(this.pubkey);\n      if (profile) {\n        this.profile = profile;\n        return profile;\n      }\n    }\n    if (!opts && // if no options have been set\n    this.ndk.cacheAdapter && // and we have a cache\n    this.ndk.cacheAdapter.locking) {\n      setMetadataEvent = await this.ndk.fetchEvent(\n        {\n          kinds: [0],\n          authors: [this.pubkey]\n        },\n        {\n          cacheUsage: \"ONLY_CACHE\" /* ONLY_CACHE */,\n          closeOnEose: true,\n          groupable: false\n        }\n      );\n      opts = {\n        cacheUsage: \"ONLY_RELAY\" /* ONLY_RELAY */,\n        closeOnEose: true,\n        groupable: true,\n        groupableDelay: 250\n      };\n    }\n    if (!setMetadataEvent) {\n      setMetadataEvent = await this.ndk.fetchEvent(\n        {\n          kinds: [0],\n          authors: [this.pubkey]\n        },\n        opts\n      );\n    }\n    if (!setMetadataEvent) return null;\n    this.profile = profileFromEvent(setMetadataEvent);\n    if (storeProfileEvent) {\n      this.profile.profileEvent = JSON.stringify(setMetadataEvent);\n    }\n    if (this.profile && this.ndk.cacheAdapter && this.ndk.cacheAdapter.saveProfile) {\n      this.ndk.cacheAdapter.saveProfile(this.pubkey, this.profile);\n    }\n    return this.profile;\n  }\n  /**\n   * Returns a set of users that this user follows.\n   * \n   * @deprecated Use followSet instead\n   */\n  follows = follows.bind(this);\n  /**\n   * Returns a set of pubkeys that this user follows.\n   * \n   * @param opts - NDKSubscriptionOptions\n   * @param outbox - boolean\n   * @param kind - number\n   */\n  async followSet(opts, outbox, kind = 3 /* Contacts */) {\n    const follows2 = await this.follows(opts, outbox, kind);\n    return new Set(Array.from(follows2).map((f) => f.pubkey));\n  }\n  /** @deprecated Use referenceTags instead. */\n  /**\n   * Get the tag that can be used to reference this user in an event\n   * @returns {NDKTag} an NDKTag\n   */\n  tagReference() {\n    return [\"p\", this.pubkey];\n  }\n  /**\n   * Get the tags that can be used to reference this user in an event\n   * @returns {NDKTag[]} an array of NDKTag\n   */\n  referenceTags(marker) {\n    const tag = [[\"p\", this.pubkey]];\n    if (!marker) return tag;\n    tag[0].push(\"\", marker);\n    return tag;\n  }\n  /**\n   * Publishes the current profile.\n   */\n  async publish() {\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    if (!this.profile) throw new Error(\"No profile available\");\n    this.ndk.assertSigner();\n    const event = new NDKEvent(this.ndk, {\n      kind: 0,\n      content: serializeProfile(this.profile)\n    });\n    await event.publish();\n  }\n  /**\n   * Add a follow to this user's contact list\n   *\n   * @param newFollow {NDKUser} The user to follow\n   * @param currentFollowList {Set<NDKUser>} The current follow list\n   * @param kind {NDKKind} The kind to use for this contact list (defaults to `3`)\n   * @returns {Promise<boolean>} True if the follow was added, false if the follow already exists\n   */\n  async follow(newFollow, currentFollowList, kind = 3 /* Contacts */) {\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    this.ndk.assertSigner();\n    if (!currentFollowList) {\n      currentFollowList = await this.follows(void 0, void 0, kind);\n    }\n    if (currentFollowList.has(newFollow)) {\n      return false;\n    }\n    currentFollowList.add(newFollow);\n    const event = new NDKEvent(this.ndk, { kind });\n    for (const follow of currentFollowList) {\n      event.tag(follow);\n    }\n    await event.publish();\n    return true;\n  }\n  /**\n   * Remove a follow from this user's contact list\n   *\n   * @param user {NDKUser} The user to unfollow\n   * @param currentFollowList {Set<NDKUser>} The current follow list\n   * @param kind {NDKKind} The kind to use for this contact list (defaults to `3`)\n   * @returns The relays were the follow list was published or false if the user wasn't found\n   */\n  async unfollow(user, currentFollowList, kind = 3 /* Contacts */) {\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    this.ndk.assertSigner();\n    if (!currentFollowList) {\n      currentFollowList = await this.follows(void 0, void 0, kind);\n    }\n    const newUserFollowList = /* @__PURE__ */ new Set();\n    let foundUser = false;\n    for (const follow of currentFollowList) {\n      if (follow.pubkey !== user.pubkey) {\n        newUserFollowList.add(follow);\n      } else {\n        foundUser = true;\n      }\n    }\n    if (!foundUser) return false;\n    const event = new NDKEvent(this.ndk, { kind });\n    for (const follow of newUserFollowList) {\n      event.tag(follow);\n    }\n    return await event.publish();\n  }\n  /**\n   * Validate a user's NIP-05 identifier (usually fetched from their kind:0 profile data)\n   *\n   * @param nip05Id The NIP-05 string to validate\n   * @returns {Promise<boolean | null>} True if the NIP-05 is found and matches this user's pubkey,\n   * False if the NIP-05 is found but doesn't match this user's pubkey,\n   * null if the NIP-05 isn't found on the domain or we're unable to verify (because of network issues, etc.)\n   */\n  async validateNip05(nip05Id) {\n    if (!this.ndk) throw new Error(\"No NDK instance found\");\n    const profilePointer = await getNip05For(this.ndk, nip05Id);\n    if (profilePointer === null) return null;\n    return profilePointer.pubkey === this.pubkey;\n  }\n};\n\n// src/user/pin.ts\nasync function pinEvent(user, event, pinEvent2, publish) {\n  const kind = 10001 /* PinList */;\n  if (!user.ndk) throw new Error(\"No NDK instance found\");\n  user.ndk.assertSigner();\n  if (!pinEvent2) {\n    const events = await user.ndk.fetchEvents(\n      { kinds: [kind], authors: [user.pubkey] },\n      { cacheUsage: \"ONLY_RELAY\" /* ONLY_RELAY */ }\n    );\n    if (events.size > 0) {\n      pinEvent2 = lists_default.from(Array.from(events)[0]);\n    } else {\n      pinEvent2 = new NDKEvent(user.ndk, {\n        kind\n      });\n    }\n  }\n  pinEvent2.tag(event);\n  if (publish) {\n    await pinEvent2.publish();\n  }\n  return pinEvent2;\n}\n\n// src/events/kinds/classified.ts\nvar NDKClassified = class _NDKClassified extends NDKEvent {\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 30402 /* Classified */;\n  }\n  /**\n   * Creates a NDKClassified from an existing NDKEvent.\n   *\n   * @param event NDKEvent to create the NDKClassified from.\n   * @returns NDKClassified\n   */\n  static from(event) {\n    return new _NDKClassified(event.ndk, event);\n  }\n  /**\n   * Getter for the classified title.\n   *\n   * @returns {string | undefined} - The classified title if available, otherwise undefined.\n   */\n  get title() {\n    return this.tagValue(\"title\");\n  }\n  /**\n   * Setter for the classified title.\n   *\n   * @param {string | undefined} title - The title to set for the classified.\n   */\n  set title(title) {\n    this.removeTag(\"title\");\n    if (title) this.tags.push([\"title\", title]);\n  }\n  /**\n   * Getter for the classified summary.\n   *\n   * @returns {string | undefined} - The classified summary if available, otherwise undefined.\n   */\n  get summary() {\n    return this.tagValue(\"summary\");\n  }\n  /**\n   * Setter for the classified summary.\n   *\n   * @param {string | undefined} summary - The summary to set for the classified.\n   */\n  set summary(summary) {\n    this.removeTag(\"summary\");\n    if (summary) this.tags.push([\"summary\", summary]);\n  }\n  /**\n   * Getter for the classified's publication timestamp.\n   *\n   * @returns {number | undefined} - The Unix timestamp of when the classified was published or undefined.\n   */\n  get published_at() {\n    const tag = this.tagValue(\"published_at\");\n    if (tag) {\n      return parseInt(tag);\n    }\n    return void 0;\n  }\n  /**\n   * Setter for the classified's publication timestamp.\n   *\n   * @param {number | undefined} timestamp - The Unix timestamp to set for the classified's publication date.\n   */\n  set published_at(timestamp) {\n    this.removeTag(\"published_at\");\n    if (timestamp !== void 0) {\n      this.tags.push([\"published_at\", timestamp.toString()]);\n    }\n  }\n  /**\n   * Getter for the classified location.\n   *\n   * @returns {string | undefined} - The classified location if available, otherwise undefined.\n   */\n  get location() {\n    return this.tagValue(\"location\");\n  }\n  /**\n   * Setter for the classified location.\n   *\n   * @param {string | undefined} location - The location to set for the classified.\n   */\n  set location(location) {\n    this.removeTag(\"location\");\n    if (location) this.tags.push([\"location\", location]);\n  }\n  /**\n   * Getter for the classified price.\n   *\n   * @returns {NDKClassifiedPriceTag | undefined} - The classified price if available, otherwise undefined.\n   */\n  get price() {\n    const priceTag = this.tags.find((tag) => tag[0] === \"price\");\n    if (priceTag) {\n      return {\n        amount: parseFloat(priceTag[1]),\n        currency: priceTag[2],\n        frequency: priceTag[3]\n      };\n    } else {\n      return void 0;\n    }\n  }\n  /**\n   * Setter for the classified price.\n   *\n   * @param price - The price to set for the classified.\n   */\n  set price(priceTag) {\n    if (typeof priceTag === \"string\") {\n      priceTag = {\n        amount: parseFloat(priceTag)\n      };\n    }\n    if (priceTag?.amount) {\n      const tag = [\"price\", priceTag.amount.toString()];\n      if (priceTag.currency) tag.push(priceTag.currency);\n      if (priceTag.frequency) tag.push(priceTag.frequency);\n      this.tags.push(tag);\n    } else {\n      this.removeTag(\"price\");\n    }\n  }\n  /**\n   * Generates content tags for the classified.\n   *\n   * This method first checks and sets the publication date if not available,\n   * and then generates content tags based on the base NDKEvent class.\n   *\n   * @returns {ContentTag} - The generated content tags.\n   */\n  async generateTags() {\n    super.generateTags();\n    if (!this.published_at) {\n      this.published_at = this.created_at;\n    }\n    return super.generateTags();\n  }\n};\n\n// src/events/kinds/drafts.ts\nvar NDKDraft = class _NDKDraft extends NDKEvent {\n  _event;\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 31234 /* Draft */;\n  }\n  static from(event) {\n    return new _NDKDraft(event.ndk, event);\n  }\n  /**\n   * Sets an identifier (i.e. d-tag)\n   */\n  set identifier(id) {\n    this.removeTag(\"d\");\n    this.tags.push([\"d\", id]);\n  }\n  get identifier() {\n    return this.dTag;\n  }\n  /**\n   * Event that is to be saved.\n   */\n  set event(e) {\n    if (e instanceof NDKEvent) this._event = e.rawEvent();\n    else this._event = e;\n    this.prepareEvent();\n  }\n  /**\n   * Gets the event.\n   * @param param0\n   * @returns NDKEvent of the draft event or null if the draft event has been deleted (emptied).\n   */\n  async getEvent(signer) {\n    if (this._event) return new NDKEvent(this.ndk, this._event);\n    signer ??= this.ndk?.signer;\n    if (!signer) throw new Error(\"No signer available\");\n    const user = await signer.user();\n    if (this.content && this.content.length > 0) {\n      try {\n        await this.decrypt(user, signer);\n        const payload = JSON.parse(this.content);\n        this._event = payload;\n        return new NDKEvent(this.ndk, payload);\n      } catch (e) {\n        console.error(e);\n        return void 0;\n      }\n    } else {\n      return null;\n    }\n  }\n  prepareEvent() {\n    if (!this._event) throw new Error(\"No event has been provided\");\n    this.removeTag(\"k\");\n    if (this._event.kind) this.tags.push([\"k\", this._event.kind.toString()]);\n    this.content = JSON.stringify(this._event);\n  }\n  /**\n   * Generates draft event.\n   *\n   * @param signer: Optional signer to encrypt with\n   * @param publish: Whether to publish, optionally specifying relaySet to publish to\n   */\n  async save({\n    signer,\n    publish,\n    relaySet\n  }) {\n    signer ??= this.ndk?.signer;\n    if (!signer) throw new Error(\"No signer available\");\n    const user = await signer.user();\n    await this.encrypt(user, signer);\n    if (publish === false) return;\n    return this.publish(relaySet);\n  }\n};\n\n// src/events/kinds/dvm/feedback.ts\nvar NDKDvmJobFeedbackStatus = /* @__PURE__ */ ((NDKDvmJobFeedbackStatus2) => {\n  NDKDvmJobFeedbackStatus2[\"Processing\"] = \"processing\";\n  NDKDvmJobFeedbackStatus2[\"Success\"] = \"success\";\n  NDKDvmJobFeedbackStatus2[\"Scheduled\"] = \"scheduled\";\n  NDKDvmJobFeedbackStatus2[\"PayReq\"] = \"payment_required\";\n  return NDKDvmJobFeedbackStatus2;\n})(NDKDvmJobFeedbackStatus || {});\nvar NDKDVMJobFeedback = class _NDKDVMJobFeedback extends NDKEvent {\n  constructor(ndk, event) {\n    super(ndk, event);\n    this.kind ??= 7e3 /* DVMJobFeedback */;\n  }\n  static async from(event) {\n    const e = new _NDKDVMJobFeedback(event.ndk, event.rawEvent());\n    if (e.encrypted) await e.dvmDecrypt();\n    return e;\n  }\n  get status() {\n    return this.tagValue(\"status\");\n  }\n  set status(status) {\n    this.removeTag(\"status\");\n    if (status !== void 0) {\n      this.tags.push([\"status\", status]);\n    }\n  }\n  get encrypted() {\n    return !!this.getMatchingTags(\"encrypted\")[0];\n  }\n  async dvmDecrypt() {\n    await this.decrypt();\n    const decryptedContent = JSON.parse(this.content);\n    this.tags.push(...decryptedContent);\n  }\n};\n\n// src/events/kinds/dvm/request.ts\nvar NDKDVMRequest = class _NDKDVMRequest extends NDKEvent {\n  constructor(ndk, event) {\n    super(ndk, event);\n  }\n  static from(event) {\n    return new _NDKDVMRequest(event.ndk, event.rawEvent());\n  }\n  set bid(msatAmount) {\n    if (msatAmount === void 0) {\n      this.removeTag(\"bid\");\n    } else {\n      this.tags.push([\"bid\", msatAmount.toString()]);\n    }\n  }\n  get bid() {\n    const v = this.tagValue(\"bid\");\n    if (v === void 0) return void 0;\n    return parseInt(v);\n  }\n  /**\n   * Adds a new input to the job\n   * @param args The arguments to the input\n   */\n  addInput(...args) {\n    this.tags.push([\"i\", ...args]);\n  }\n  /**\n   * Adds a new parameter to the job\n   */\n  addParam(...args) {\n    this.tags.push([\"param\", ...args]);\n  }\n  set output(output) {\n    if (output === void 0) {\n      this.removeTag(\"output\");\n    } else {\n      if (typeof output === \"string\") output = [output];\n      this.tags.push([\"output\", ...output]);\n    }\n  }\n  get output() {\n    const outputTag = this.getMatchingTags(\"output\")[0];\n    return outputTag ? outputTag.slice(1) : void 0;\n  }\n  get params() {\n    const paramTags = this.getMatchingTags(\"param\");\n    return paramTags.map((t) => t.slice(1));\n  }\n  getParam(name) {\n    const paramTag = this.getMatchingTags(\"param\").find((t) => t[1] === name);\n    return paramTag ? paramTag[2] : void 0;\n  }\n  createFeedback(status) {\n    const feedback = new NDKDVMJobFeedback(this.ndk);\n    feedback.tag(this, \"job\");\n    feedback.status = status;\n    return feedback;\n  }\n  /**\n   * Enables job encryption for this event\n   * @param dvm DVM that will receive the event\n   * @param signer Signer to use for encryption\n   */\n  async encryption(dvm, signer) {\n    const dvmTags = [\"i\", \"param\", \"output\", \"relays\", \"bid\"];\n    const tags = this.tags.filter((t) => dvmTags.includes(t[0]));\n    this.tags = this.tags.filter((t) => !dvmTags.includes(t[0]));\n    this.content = JSON.stringify(tags);\n    this.tag(dvm);\n    this.tags.push([\"encrypted\"]);\n    await this.encrypt(dvm, signer);\n  }\n  /**\n   * Sets the DVM that will receive the event\n   */\n  set dvm(dvm) {\n    this.removeTag(\"p\");\n    if (dvm) this.tag(dvm);\n  }\n};\n\n// src/events/kinds/dvm/NDKTranscriptionDVM.ts\nvar NDKTranscriptionDVM = class _NDKTranscriptionDVM extends NDKDVMRequest {\n  constructor(ndk, event) {\n    super(ndk, event);\n    this.kind = 5e3 /* DVMReqTextExtraction */;\n  }\n  static from(event) {\n    return new _NDKTranscriptionDVM(event.ndk, event.rawEvent());\n  }\n  /**\n   * Returns the original source of the transcription\n   */\n  get url() {\n    const inputTags = this.getMatchingTags(\"i\");\n    if (inputTags.length !== 1) {\n      return void 0;\n    }\n    return inputTags[0][1];\n  }\n  /**\n   * Getter for the title tag\n   */\n  get title() {\n    return this.tagValue(\"title\");\n  }\n  /**\n   * Setter for the title tag\n   */\n  set title(value) {\n    this.removeTag(\"title\");\n    if (value) {\n      this.tags.push([\"title\", value]);\n    }\n  }\n  /**\n   * Getter for the image tag\n   */\n  get image() {\n    return this.tagValue(\"image\");\n  }\n  /**\n   * Setter for the image tag\n   */\n  set image(value) {\n    this.removeTag(\"image\");\n    if (value) {\n      this.tags.push([\"image\", value]);\n    }\n  }\n};\n\n// src/events/kinds/dvm/result.ts\nvar NDKDVMJobResult = class _NDKDVMJobResult extends NDKEvent {\n  constructor(ndk, event) {\n    super(ndk, event);\n  }\n  static from(event) {\n    return new _NDKDVMJobResult(event.ndk, event.rawEvent());\n  }\n  setAmount(msat, invoice) {\n    this.removeTag(\"amount\");\n    const tag = [\"amount\", msat.toString()];\n    if (invoice) tag.push(invoice);\n    this.tags.push(tag);\n  }\n  set result(result) {\n    if (result === void 0) {\n      this.content = \"\";\n    } else {\n      this.content = result;\n    }\n  }\n  get result() {\n    if (this.content === \"\") {\n      return void 0;\n    }\n    return this.content;\n  }\n  set status(status) {\n    this.removeTag(\"status\");\n    if (status !== void 0) {\n      this.tags.push([\"status\", status]);\n    }\n  }\n  get status() {\n    return this.tagValue(\"status\");\n  }\n  get jobRequestId() {\n    for (const eTag of this.getMatchingTags(\"e\")) {\n      if (eTag[2] === \"job\") return eTag[1];\n    }\n    if (this.jobRequest) return this.jobRequest.id;\n    return this.tagValue(\"e\");\n  }\n  set jobRequest(event) {\n    this.removeTag(\"request\");\n    if (event) {\n      this.kind = event.kind + 1e3;\n      this.tags.push([\"request\", JSON.stringify(event.rawEvent())]);\n      this.tag(event);\n    }\n  }\n  get jobRequest() {\n    const tag = this.tagValue(\"request\");\n    if (tag === void 0) {\n      return void 0;\n    }\n    return new NDKEvent(this.ndk, JSON.parse(tag));\n  }\n};\n\n// src/events/kinds/cashu/tx.ts\nvar MARKERS = {\n  REDEEMED: \"redeemed\",\n  CREATED: \"created\",\n  DESTROYED: \"destroyed\",\n  RESERVED: \"reserved\"\n};\nvar NDKCashuWalletTx = class _NDKCashuWalletTx extends NDKEvent {\n  static MARKERS = MARKERS;\n  static kind = 7376 /* CashuWalletTx */;\n  static kinds = [7376 /* CashuWalletTx */];\n  constructor(ndk, event) {\n    super(ndk, event);\n    this.kind ??= 7376 /* CashuWalletTx */;\n  }\n  static async from(event) {\n    const walletChange = new _NDKCashuWalletTx(event.ndk, event);\n    const prevContent = walletChange.content;\n    try {\n      await walletChange.decrypt();\n    } catch (e) {\n      walletChange.content ??= prevContent;\n    }\n    try {\n      const contentTags = JSON.parse(walletChange.content);\n      walletChange.tags = [...contentTags, ...walletChange.tags];\n    } catch (e) {\n      return;\n    }\n    return walletChange;\n  }\n  set direction(direction) {\n    this.removeTag(\"direction\");\n    if (direction) this.tags.push([\"direction\", direction]);\n  }\n  get direction() {\n    return this.tagValue(\"direction\");\n  }\n  set amount(amount) {\n    this.removeTag(\"amount\");\n    this.tags.push([\"amount\", amount.toString()]);\n  }\n  get amount() {\n    return this.tagValue(\"amount\");\n  }\n  set fee(fee) {\n    this.removeTag(\"fee\");\n    this.tags.push([\"fee\", fee.toString()]);\n  }\n  get fee() {\n    return this.tagValue(\"fee\");\n  }\n  set unit(unit) {\n    this.removeTag(\"unit\");\n    if (unit) this.tags.push([\"unit\", unit.toString()]);\n  }\n  get unit() {\n    return this.tagValue(\"unit\");\n  }\n  set description(description) {\n    this.removeTag(\"description\");\n    if (description) this.tags.push([\"description\", description.toString()]);\n  }\n  get description() {\n    return this.tagValue(\"description\");\n  }\n  set mint(mint) {\n    this.removeTag(\"mint\");\n    if (mint) this.tags.push([\"mint\", mint.toString()]);\n  }\n  get mint() {\n    return this.tagValue(\"mint\");\n  }\n  /**\n   * Tags tokens that were created in this history event\n   */\n  set destroyedTokens(events) {\n    for (const event of events) {\n      this.tags.push(event.tagReference(MARKERS.DESTROYED));\n    }\n  }\n  set destroyedTokenIds(ids) {\n    for (const id of ids) {\n      this.tags.push([\"e\", id, \"\", MARKERS.DESTROYED]);\n    }\n  }\n  /**\n   * Tags tokens that were created in this history event\n   */\n  set createdTokens(events) {\n    for (const event of events) {\n      this.tags.push(event.tagReference(MARKERS.CREATED));\n    }\n  }\n  set reservedTokens(events) {\n    for (const event of events) {\n      this.tags.push(event.tagReference(MARKERS.RESERVED));\n    }\n  }\n  addRedeemedNutzap(event) {\n    this.tag(event, MARKERS.REDEEMED);\n  }\n  async toNostrEvent(pubkey) {\n    const encryptedTags = [];\n    const unencryptedTags = [];\n    for (const tag of this.tags) {\n      if (!this.shouldEncryptTag(tag)) {\n        unencryptedTags.push(tag);\n      } else {\n        encryptedTags.push(tag);\n      }\n    }\n    this.tags = unencryptedTags.filter((t) => t[0] !== \"client\");\n    this.content = JSON.stringify(encryptedTags);\n    const user = await this.ndk.signer.user();\n    await this.encrypt(user, void 0, \"nip44\");\n    return super.toNostrEvent(pubkey);\n  }\n  /**\n   * Whether this entry includes a redemption of a Nutzap\n   */\n  get hasNutzapRedemption() {\n    return this.getMatchingTags(\"e\", MARKERS.REDEEMED).length > 0;\n  }\n  shouldEncryptTag(tag) {\n    const unencryptedTagNames = [\"client\"];\n    if (unencryptedTagNames.includes(tag[0])) {\n      return false;\n    }\n    if (tag[0] === \"e\" && tag[3] === MARKERS.REDEEMED) {\n      return false;\n    }\n    if (tag[0] === \"p\") return false;\n    return true;\n  }\n};\n\n// src/events/kinds/NDKRelayList.ts\nvar READ_MARKER = \"read\";\nvar WRITE_MARKER = \"write\";\nvar NDKRelayList = class _NDKRelayList extends NDKEvent {\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 10002 /* RelayList */;\n  }\n  static from(ndkEvent) {\n    return new _NDKRelayList(ndkEvent.ndk, ndkEvent.rawEvent());\n  }\n  get readRelayUrls() {\n    return this.tags.filter((tag) => tag[0] === \"r\" || tag[0] === \"relay\").filter((tag) => !tag[2] || tag[2] && tag[2] === READ_MARKER).map((tag) => tryNormalizeRelayUrl(tag[1])).filter((url) => !!url);\n  }\n  set readRelayUrls(relays) {\n    for (const relay of relays) {\n      this.tags.push([\"r\", relay, READ_MARKER]);\n    }\n  }\n  get writeRelayUrls() {\n    return this.tags.filter((tag) => tag[0] === \"r\" || tag[0] === \"relay\").filter((tag) => !tag[2] || tag[2] && tag[2] === WRITE_MARKER).map((tag) => tryNormalizeRelayUrl(tag[1])).filter((url) => !!url);\n  }\n  set writeRelayUrls(relays) {\n    for (const relay of relays) {\n      this.tags.push([\"r\", relay, WRITE_MARKER]);\n    }\n  }\n  get bothRelayUrls() {\n    return this.tags.filter((tag) => tag[0] === \"r\" || tag[0] === \"relay\").filter((tag) => !tag[2]).map((tag) => tag[1]);\n  }\n  set bothRelayUrls(relays) {\n    for (const relay of relays) {\n      this.tags.push([\"r\", relay]);\n    }\n  }\n  get relays() {\n    return this.tags.filter((tag) => tag[0] === \"r\" || tag[0] === \"relay\").map((tag) => tag[1]);\n  }\n  /**\n   * Provides a relaySet for the relays in this list.\n   */\n  get relaySet() {\n    if (!this.ndk) throw new Error(\"NDKRelayList has no NDK instance\");\n    return new NDKRelaySet(\n      new Set(this.relays.map((u) => this.ndk.pool.getRelay(u))),\n      this.ndk\n    );\n  }\n};\nfunction relayListFromKind3(ndk, contactList) {\n  try {\n    const content = JSON.parse(contactList.content);\n    const relayList = new NDKRelayList(ndk);\n    const readRelays = /* @__PURE__ */ new Set();\n    const writeRelays = /* @__PURE__ */ new Set();\n    for (let [key, config] of Object.entries(content)) {\n      try {\n        key = normalizeRelayUrl(key);\n      } catch {\n        continue;\n      }\n      if (!config) {\n        readRelays.add(key);\n        writeRelays.add(key);\n      } else {\n        const relayConfig = config;\n        if (relayConfig.write) writeRelays.add(key);\n        if (relayConfig.read) readRelays.add(key);\n      }\n    }\n    relayList.readRelayUrls = Array.from(readRelays);\n    relayList.writeRelayUrls = Array.from(writeRelays);\n    return relayList;\n  } catch {\n  }\n  return void 0;\n}\n\n// src/events/kinds/nip89/NDKAppHandler.ts\nvar NDKAppHandlerEvent = class _NDKAppHandlerEvent extends NDKEvent {\n  profile;\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 31990 /* AppHandler */;\n  }\n  static from(ndkEvent) {\n    return new _NDKAppHandlerEvent(ndkEvent.ndk, ndkEvent.rawEvent());\n  }\n  /**\n   * Fetches app handler information\n   * If no app information is available on the kind:31990,\n   * we fetch the event's author's profile and return that instead.\n   */\n  async fetchProfile() {\n    if (this.profile === void 0 && this.content.length > 0) {\n      try {\n        const profile = JSON.parse(this.content);\n        if (profile && profile.name) {\n          return profile;\n        } else {\n          this.profile = null;\n        }\n      } catch (e) {\n        this.profile = null;\n      }\n    }\n    return new Promise((resolve, reject) => {\n      const author = this.author;\n      author.fetchProfile().then(() => {\n        resolve(author.profile);\n      }).catch(reject);\n    });\n  }\n};\n\n// src/events/kinds/repost.ts\nvar NDKRepost = class _NDKRepost extends NDKEvent {\n  _repostedEvents;\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n  }\n  static from(event) {\n    return new _NDKRepost(event.ndk, event.rawEvent());\n  }\n  /**\n   * Returns all reposted events by the current event.\n   *\n   * @param klass Optional class to convert the events to.\n   * @returns\n   */\n  async repostedEvents(klass, opts) {\n    const items = [];\n    if (!this.ndk) throw new Error(\"NDK instance not set\");\n    if (this._repostedEvents !== void 0) return this._repostedEvents;\n    for (const eventId of this.repostedEventIds()) {\n      const filter = filterForId(eventId);\n      const event = await this.ndk.fetchEvent(filter, opts);\n      if (event) {\n        items.push(klass ? klass.from(event) : event);\n      }\n    }\n    return items;\n  }\n  /**\n   * Returns the reposted event IDs.\n   */\n  repostedEventIds() {\n    return this.tags.filter((t) => t[0] === \"e\" || t[0] === \"a\").map((t) => t[1]);\n  }\n};\nfunction filterForId(id) {\n  if (id.match(/:/)) {\n    const [kind, pubkey, identifier] = id.split(\":\");\n    return {\n      kinds: [parseInt(kind)],\n      authors: [pubkey],\n      \"#d\": [identifier]\n    };\n  } else {\n    return { ids: [id] };\n  }\n}\n\n// src/events/kinds/subscriptions/receipt.ts\n\nvar NDKSubscriptionReceipt = class _NDKSubscriptionReceipt extends NDKEvent {\n  debug;\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 7003 /* SubscriptionReceipt */;\n    this.debug = ndk?.debug.extend(\"subscription-start\") ?? debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:subscription-start\");\n  }\n  static from(event) {\n    return new _NDKSubscriptionReceipt(event.ndk, event.rawEvent());\n  }\n  /**\n   * This is the person being subscribed to\n   */\n  get recipient() {\n    const pTag = this.getMatchingTags(\"p\")?.[0];\n    if (!pTag) return void 0;\n    const user = new NDKUser({ pubkey: pTag[1] });\n    return user;\n  }\n  set recipient(user) {\n    this.removeTag(\"p\");\n    if (!user) return;\n    this.tags.push([\"p\", user.pubkey]);\n  }\n  /**\n   * This is the person subscribing\n   */\n  get subscriber() {\n    const PTag = this.getMatchingTags(\"P\")?.[0];\n    if (!PTag) return void 0;\n    const user = new NDKUser({ pubkey: PTag[1] });\n    return user;\n  }\n  set subscriber(user) {\n    this.removeTag(\"P\");\n    if (!user) return;\n    this.tags.push([\"P\", user.pubkey]);\n  }\n  set subscriptionStart(event) {\n    this.debug(`before setting subscription start: ${this.rawEvent}`);\n    this.removeTag(\"e\");\n    this.tag(event, \"subscription\", true);\n    this.debug(`after setting subscription start: ${this.rawEvent}`);\n  }\n  get tierName() {\n    const tag = this.getMatchingTags(\"tier\")?.[0];\n    return tag?.[1];\n  }\n  get isValid() {\n    const period = this.validPeriod;\n    if (!period) {\n      return false;\n    }\n    if (period.start > period.end) {\n      return false;\n    }\n    const pTags = this.getMatchingTags(\"p\");\n    const PTags = this.getMatchingTags(\"P\");\n    if (pTags.length !== 1 || PTags.length !== 1) {\n      return false;\n    }\n    return true;\n  }\n  get validPeriod() {\n    const tag = this.getMatchingTags(\"valid\")?.[0];\n    if (!tag) return void 0;\n    try {\n      return {\n        start: new Date(parseInt(tag[1]) * 1e3),\n        end: new Date(parseInt(tag[2]) * 1e3)\n      };\n    } catch {\n      return void 0;\n    }\n  }\n  set validPeriod(period) {\n    this.removeTag(\"valid\");\n    if (!period) return;\n    this.tags.push([\n      \"valid\",\n      Math.floor(period.start.getTime() / 1e3).toString(),\n      Math.floor(period.end.getTime() / 1e3).toString()\n    ]);\n  }\n  get startPeriod() {\n    return this.validPeriod?.start;\n  }\n  get endPeriod() {\n    return this.validPeriod?.end;\n  }\n  /**\n   * Whether the subscription is currently active\n   */\n  isActive(time) {\n    time ??= /* @__PURE__ */ new Date();\n    const period = this.validPeriod;\n    if (!period) return false;\n    if (time < period.start) return false;\n    if (time > period.end) return false;\n    return true;\n  }\n};\n\n// src/events/kinds/subscriptions/subscription-start.ts\n\nvar NDKSubscriptionStart = class _NDKSubscriptionStart extends NDKEvent {\n  debug;\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 7001 /* Subscribe */;\n    this.debug = ndk?.debug.extend(\"subscription-start\") ?? debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:subscription-start\");\n  }\n  static from(event) {\n    return new _NDKSubscriptionStart(event.ndk, event.rawEvent());\n  }\n  /**\n   * Recipient of the subscription. I.e. The author of this event subscribes to this user.\n   */\n  get recipient() {\n    const pTag = this.getMatchingTags(\"p\")?.[0];\n    if (!pTag) return void 0;\n    const user = new NDKUser({ pubkey: pTag[1] });\n    return user;\n  }\n  set recipient(user) {\n    this.removeTag(\"p\");\n    if (!user) return;\n    this.tags.push([\"p\", user.pubkey]);\n  }\n  /**\n   * The amount of the subscription.\n   */\n  get amount() {\n    const amountTag = this.getMatchingTags(\"amount\")?.[0];\n    if (!amountTag) return void 0;\n    return parseTagToSubscriptionAmount(amountTag);\n  }\n  set amount(amount) {\n    this.removeTag(\"amount\");\n    if (!amount) return;\n    this.tags.push(newAmount(amount.amount, amount.currency, amount.term));\n  }\n  /**\n   * The event id or NIP-33 tag id of the tier that the user is subscribing to.\n   */\n  get tierId() {\n    const eTag = this.getMatchingTags(\"e\")?.[0];\n    const aTag = this.getMatchingTags(\"a\")?.[0];\n    if (!eTag || !aTag) return void 0;\n    return eTag[1] ?? aTag[1];\n  }\n  set tier(tier) {\n    this.removeTag(\"e\");\n    this.removeTag(\"a\");\n    this.removeTag(\"event\");\n    if (!tier) return;\n    this.tag(tier);\n    this.removeTag(\"p\");\n    this.tags.push([\"p\", tier.pubkey]);\n    this.tags.push([\"event\", JSON.stringify(tier.rawEvent())]);\n  }\n  /**\n   * Fetches the tier that the user is subscribing to.\n   */\n  async fetchTier() {\n    const eventTag = this.tagValue(\"event\");\n    if (eventTag) {\n      try {\n        const parsedEvent = JSON.parse(eventTag);\n        return new NDKSubscriptionTier(this.ndk, parsedEvent);\n      } catch {\n        this.debug(\"Failed to parse event tag\");\n      }\n    }\n    const tierId = this.tierId;\n    if (!tierId) return void 0;\n    const e = await this.ndk?.fetchEvent(tierId);\n    if (!e) return void 0;\n    return NDKSubscriptionTier.from(e);\n  }\n  get isValid() {\n    if (this.getMatchingTags(\"amount\").length !== 1) {\n      this.debug(\"Invalid # of amount tag\");\n      return false;\n    }\n    if (!this.amount) {\n      this.debug(\"Invalid amount tag\");\n      return false;\n    }\n    if (this.getMatchingTags(\"p\").length !== 1) {\n      this.debug(\"Invalid # of p tag\");\n      return false;\n    }\n    if (!this.recipient) {\n      this.debug(\"Invalid p tag\");\n      return false;\n    }\n    return true;\n  }\n};\n\n// src/events/kinds/simple-group/index.ts\nvar NDKSimpleGroup = class _NDKSimpleGroup {\n  ndk;\n  groupId;\n  relaySet;\n  fetchingMetadata;\n  metadata;\n  memberList;\n  adminList;\n  constructor(ndk, relaySet, groupId) {\n    this.ndk = ndk;\n    this.groupId = groupId ?? randomId(24);\n    this.relaySet = relaySet;\n  }\n  get id() {\n    return this.groupId;\n  }\n  relayUrls() {\n    return this.relaySet.relayUrls;\n  }\n  get name() {\n    return this.metadata?.name;\n  }\n  get about() {\n    return this.metadata?.about;\n  }\n  get picture() {\n    return this.metadata?.picture;\n  }\n  get members() {\n    return this.memberList?.members ?? [];\n  }\n  get admins() {\n    return this.adminList?.members ?? [];\n  }\n  async getMetadata() {\n    await this.ensureMetadataEvent();\n    return this.metadata;\n  }\n  /**\n   * Creates the group by publishing a kind:9007 event.\n   * @param signer\n   * @returns\n   */\n  async createGroup(signer) {\n    signer ??= this.ndk.signer;\n    if (!signer) throw new Error(\"No signer available\");\n    const user = await signer.user();\n    if (!user) throw new Error(\"No user available\");\n    const event = new NDKEvent(this.ndk);\n    event.kind = 9007 /* GroupAdminCreateGroup */;\n    event.tags.push([\"h\", this.groupId]);\n    await event.sign(signer);\n    return event.publish(this.relaySet);\n  }\n  async setMetadata({\n    name,\n    about,\n    picture\n  }) {\n    const event = new NDKEvent(this.ndk);\n    event.kind = 9002 /* GroupAdminEditMetadata */;\n    event.tags.push([\"h\", this.groupId]);\n    if (name) event.tags.push([\"name\", name]);\n    if (about) event.tags.push([\"about\", about]);\n    if (picture) event.tags.push([\"picture\", picture]);\n    await event.sign();\n    return event.publish(this.relaySet);\n  }\n  /**\n   * Adds a user to the group using a kind:9000 event\n   * @param user user to add\n   * @param opts options\n   */\n  async addUser(user) {\n    const addUserEvent = _NDKSimpleGroup.generateAddUserEvent(user.pubkey, this.groupId);\n    addUserEvent.ndk = this.ndk;\n    return addUserEvent;\n  }\n  async getMemberListEvent() {\n    const memberList = await this.ndk.fetchEvent(\n      {\n        kinds: [39002 /* GroupMembers */],\n        \"#d\": [this.groupId]\n      },\n      void 0,\n      this.relaySet\n    );\n    if (!memberList) return null;\n    return NDKSimpleGroupMemberList.from(memberList);\n  }\n  /**\n   * Gets a list of users that belong to this group\n   */\n  async getMembers() {\n    const members = [];\n    const memberPubkeys = /* @__PURE__ */ new Set();\n    const memberListEvent = await this.getMemberListEvent();\n    if (!memberListEvent) return [];\n    for (const pTag of memberListEvent.getMatchingTags(\"p\")) {\n      const pubkey = pTag[1];\n      if (memberPubkeys.has(pubkey)) continue;\n      memberPubkeys.add(pubkey);\n      try {\n        members.push(this.ndk.getUser({ pubkey }));\n      } catch {\n      }\n    }\n    return members;\n  }\n  /**\n   * Generates an event that lists the members of a group.\n   * @param groupId\n   * @returns\n   */\n  static generateUserListEvent(groupId) {\n    const event = new NDKEvent(void 0, {\n      kind: 39002 /* GroupMembers */,\n      tags: [\n        [\"h\", groupId],\n        [\"alt\", \"Group Member List\"]\n      ]\n    });\n    return event;\n  }\n  /**\n   * Generates an event that adds a user to a group.\n   * @param userPubkey pubkey of the user to add\n   * @param groupId group to add the user to\n   * @returns\n   */\n  static generateAddUserEvent(userPubkey, groupId) {\n    const event = new NDKEvent(void 0, {\n      kind: 9e3 /* GroupAdminAddUser */,\n      tags: [[\"h\", groupId]]\n    });\n    event.tags.push([\"p\", userPubkey]);\n    return event;\n  }\n  async requestToJoin(pubkey, content) {\n    const event = new NDKEvent(this.ndk, {\n      kind: 9021 /* GroupAdminRequestJoin */,\n      content: content ?? \"\",\n      tags: [[\"h\", this.groupId]]\n    });\n    return event.publish(this.relaySet);\n  }\n  /**\n   * Makes sure that a metadata event exists locally\n   */\n  async ensureMetadataEvent() {\n    if (this.metadata) return;\n    if (this.fetchingMetadata) return this.fetchingMetadata;\n    this.fetchingMetadata = this.ndk.fetchEvent(\n      {\n        kinds: [39e3 /* GroupMetadata */],\n        \"#d\": [this.groupId]\n      },\n      void 0,\n      this.relaySet\n    ).then((event) => {\n      if (event) {\n        this.metadata = NDKSimpleGroupMetadata.from(event);\n      } else {\n        this.metadata = new NDKSimpleGroupMetadata(this.ndk);\n        this.metadata.dTag = this.groupId;\n      }\n    }).finally(() => {\n      this.fetchingMetadata = void 0;\n    }).catch(() => {\n      throw new Error(\"Failed to fetch metadata for group \" + this.groupId);\n    });\n    return this.fetchingMetadata;\n  }\n};\nfunction randomId(length) {\n  const chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n  const charsLength = chars.length;\n  let result = \"\";\n  for (let i = 0; i < length; i++) {\n    result += chars.charAt(Math.floor(Math.random() * charsLength));\n  }\n  return result;\n}\n\n// src/app-settings/index.ts\nvar NDKAppSettings = class _NDKAppSettings extends NDKEvent {\n  appName;\n  settings = {};\n  constructor(ndk, rawEvent) {\n    super(ndk, rawEvent);\n    this.kind ??= 30078 /* AppSpecificData */;\n    this.dTag ??= this.appName;\n    if (this.content.length > 0) {\n      try {\n        this.settings = JSON.parse(this.content);\n      } catch (error) {\n        console.error(\"Error parsing app settings\", error);\n      }\n    }\n  }\n  static from(event) {\n    return new _NDKAppSettings(event.ndk, event);\n  }\n  /**\n   * Set a value for a given key.\n   *\n   * @param key\n   * @param value\n   */\n  set(key, value) {\n    this.settings[key] = value;\n  }\n  /**\n   * Get a value for a given key.\n   *\n   * @param key\n   * @returns\n   */\n  get(key) {\n    return this.settings[key];\n  }\n  async publishReplaceable(relaySet, timeoutMs, requiredRelayCount) {\n    this.content = JSON.stringify(this.settings);\n    return super.publishReplaceable(relaySet, timeoutMs, requiredRelayCount);\n  }\n};\n\n// src/relay/auth-policies.ts\n\nfunction disconnect(pool, debug8) {\n  debug8 ??= debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:relay:auth-policies:disconnect\");\n  return async (relay) => {\n    debug8(`Relay ${relay.url} requested authentication, disconnecting`);\n    pool.removeRelay(relay.url);\n  };\n}\nasync function signAndAuth(event, relay, signer, debug8, resolve, reject) {\n  try {\n    await event.sign(signer);\n    resolve(event);\n  } catch (e) {\n    debug8(`Failed to publish auth event to relay ${relay.url}`, e);\n    reject(event);\n  }\n}\nfunction signIn({ ndk, signer, debug: debug8 } = {}) {\n  debug8 ??= debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:auth-policies:signIn\");\n  return async (relay, challenge) => {\n    debug8(`Relay ${relay.url} requested authentication, signing in`);\n    const event = new NDKEvent(ndk);\n    event.kind = 22242 /* ClientAuth */;\n    event.tags = [\n      [\"relay\", relay.url],\n      [\"challenge\", challenge]\n    ];\n    signer ??= ndk?.signer;\n    return new Promise(async (resolve, reject) => {\n      if (signer) {\n        await signAndAuth(event, relay, signer, debug8, resolve, reject);\n      } else {\n        ndk?.once(\"signer:ready\", async (signer2) => {\n          await signAndAuth(event, relay, signer2, debug8, resolve, reject);\n        });\n      }\n    });\n  };\n}\nvar NDKRelayAuthPolicies = {\n  disconnect,\n  signIn\n};\n\n// src/signers/nip07/index.ts\n\nvar NDKNip07Signer = class {\n  _userPromise;\n  encryptionQueue = [];\n  encryptionProcessing = false;\n  debug;\n  waitTimeout;\n  /**\n   * @param waitTimeout - The timeout in milliseconds to wait for the NIP-07 to become available\n   */\n  constructor(waitTimeout = 1e3) {\n    this.debug = debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:nip07\");\n    this.waitTimeout = waitTimeout;\n  }\n  async blockUntilReady() {\n    await this.waitForExtension();\n    const pubkey = await window.nostr.getPublicKey();\n    if (!pubkey) {\n      throw new Error(\"User rejected access\");\n    }\n    return new NDKUser({ pubkey });\n  }\n  /**\n   * Getter for the user property.\n   * @returns The NDKUser instance.\n   */\n  async user() {\n    if (!this._userPromise) {\n      this._userPromise = this.blockUntilReady();\n    }\n    return this._userPromise;\n  }\n  /**\n   * Signs the given Nostr event.\n   * @param event - The Nostr event to be signed.\n   * @returns The signature of the signed event.\n   * @throws Error if the NIP-07 is not available on the window object.\n   */\n  async sign(event) {\n    await this.waitForExtension();\n    const signedEvent = await window.nostr.signEvent(event);\n    return signedEvent.sig;\n  }\n  async relays(ndk) {\n    await this.waitForExtension();\n    const relays = await window.nostr.getRelays?.() || {};\n    const activeRelays = [];\n    for (const url of Object.keys(relays)) {\n      if (relays[url].read && relays[url].write) {\n        activeRelays.push(url);\n      }\n    }\n    return activeRelays.map((url) => new NDKRelay(url, ndk?.relayAuthDefaultPolicy, ndk));\n  }\n  async encryptionEnabled(nip) {\n    let enabled = [];\n    if ((!nip || nip == \"nip04\") && Boolean(window.nostr.nip04)) enabled.push(\"nip04\");\n    if ((!nip || nip == \"nip44\") && Boolean(window.nostr.nip44)) enabled.push(\"nip44\");\n    return enabled;\n  }\n  async encrypt(recipient, value, nip = \"nip04\") {\n    if (!await this.encryptionEnabled(nip)) throw new Error(nip + \"encryption is not available from your browser extension\");\n    await this.waitForExtension();\n    const recipientHexPubKey = recipient.pubkey;\n    return this.queueEncryption(nip, \"encrypt\", recipientHexPubKey, value);\n  }\n  async decrypt(sender, value, nip = \"nip04\") {\n    if (!await this.encryptionEnabled(nip)) throw new Error(nip + \"encryption is not available from your browser extension\");\n    await this.waitForExtension();\n    const senderHexPubKey = sender.pubkey;\n    return this.queueEncryption(nip, \"decrypt\", senderHexPubKey, value);\n  }\n  async queueEncryption(scheme, method, counterpartyHexpubkey, value) {\n    return new Promise((resolve, reject) => {\n      this.encryptionQueue.push({\n        scheme,\n        method,\n        counterpartyHexpubkey,\n        value,\n        resolve,\n        reject\n      });\n      if (!this.encryptionProcessing) {\n        this.processEncryptionQueue();\n      }\n    });\n  }\n  async processEncryptionQueue(item, retries = 0) {\n    if (!item && this.encryptionQueue.length === 0) {\n      this.encryptionProcessing = false;\n      return;\n    }\n    this.encryptionProcessing = true;\n    const { scheme, method, counterpartyHexpubkey, value, resolve, reject } = item || this.encryptionQueue.shift();\n    this.debug(\"Processing encryption queue item\", {\n      method,\n      counterpartyHexpubkey,\n      value\n    });\n    try {\n      let result = await window.nostr[scheme][method](counterpartyHexpubkey, value);\n      resolve(result);\n    } catch (error) {\n      if (error.message && error.message.includes(\"call already executing\")) {\n        if (retries < 5) {\n          this.debug(\"Retrying encryption queue item\", {\n            method,\n            counterpartyHexpubkey,\n            value,\n            retries\n          });\n          setTimeout(() => {\n            this.processEncryptionQueue(item, retries + 1);\n          }, 50 * retries);\n          return;\n        }\n      }\n      reject(error);\n    }\n    this.processEncryptionQueue();\n  }\n  waitForExtension() {\n    return new Promise((resolve, reject) => {\n      if (window.nostr) {\n        resolve();\n        return;\n      }\n      let timerId;\n      const intervalId = setInterval(() => {\n        if (window.nostr) {\n          clearTimeout(timerId);\n          clearInterval(intervalId);\n          resolve();\n        }\n      }, 100);\n      timerId = setTimeout(() => {\n        clearInterval(intervalId);\n        reject(new Error(\"NIP-07 extension not available\"));\n      }, this.waitTimeout);\n    });\n  }\n};\n\n// src/signers/private-key/index.ts\n\n\n\nvar NDKPrivateKeySigner = class _NDKPrivateKeySigner {\n  _user;\n  _privateKey;\n  constructor(privateKey) {\n    if (privateKey) {\n      if (typeof privateKey === \"string\") {\n        if (privateKey.startsWith(\"nsec1\")) {\n          const { type, data } = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip19.decode(privateKey);\n          if (type === \"nsec\") this._privateKey = data;\n        } else if (privateKey.length === 64) {\n          this._privateKey = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_6__.hexToBytes)(privateKey);\n        } else {\n          throw new Error(\"Invalid private key provided.\");\n        }\n      } else {\n        this._privateKey = privateKey;\n      }\n      if (this._privateKey) {\n        this._user = new NDKUser({\n          pubkey: (0,nostr_tools__WEBPACK_IMPORTED_MODULE_2__.getPublicKey)(this._privateKey)\n        });\n      }\n    }\n  }\n  get privateKey() {\n    if (!this._privateKey) return void 0;\n    return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_6__.bytesToHex)(this._privateKey);\n  }\n  static generate() {\n    const privateKey = (0,nostr_tools__WEBPACK_IMPORTED_MODULE_2__.generateSecretKey)();\n    return new _NDKPrivateKeySigner(privateKey);\n  }\n  async blockUntilReady() {\n    if (!this._user) {\n      throw new Error(\"NDKUser not initialized\");\n    }\n    return this._user;\n  }\n  async user() {\n    await this.blockUntilReady();\n    return this._user;\n  }\n  async sign(event) {\n    if (!this._privateKey) {\n      throw Error(\"Attempted to sign without a private key\");\n    }\n    return (0,nostr_tools__WEBPACK_IMPORTED_MODULE_2__.finalizeEvent)(event, this._privateKey).sig;\n  }\n  async encryptionEnabled(scheme) {\n    let enabled = [];\n    if (!scheme || scheme == \"nip04\") enabled.push(\"nip04\");\n    if (!scheme || scheme == \"nip44\") enabled.push(\"nip44\");\n    return enabled;\n  }\n  async encrypt(recipient, value, scheme) {\n    if (!this._privateKey || !this.privateKey) {\n      throw Error(\"Attempted to encrypt without a private key\");\n    }\n    const recipientHexPubKey = recipient.pubkey;\n    if (scheme == \"nip44\") {\n      let conversationKey = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip44.v2.utils.getConversationKey(this._privateKey, recipientHexPubKey);\n      return await nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip44.v2.encrypt(value, conversationKey);\n    }\n    return await nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip04.encrypt(this._privateKey, recipientHexPubKey, value);\n  }\n  async decrypt(sender, value, scheme) {\n    if (!this._privateKey || !this.privateKey) {\n      throw Error(\"Attempted to decrypt without a private key\");\n    }\n    const senderHexPubKey = sender.pubkey;\n    if (scheme == \"nip44\") {\n      let conversationKey = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip44.v2.utils.getConversationKey(this._privateKey, senderHexPubKey);\n      return await nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip44.v2.decrypt(value, conversationKey);\n    }\n    return await nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip04.decrypt(this._privateKey, senderHexPubKey, value);\n  }\n};\n\n// src/signers/nip46/rpc.ts\n\nvar NDKNostrRpc = class extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  ndk;\n  signer;\n  relaySet;\n  debug;\n  encryptionType = \"nip04\";\n  pool;\n  constructor(ndk, signer, debug8, relayUrls) {\n    super();\n    this.ndk = ndk;\n    this.signer = signer;\n    if (relayUrls) {\n      this.pool = new NDKPool(\n        relayUrls,\n        [],\n        ndk,\n        {\n          debug: debug8.extend(\"rpc-pool\"),\n          name: \"Nostr RPC\"\n        }\n      );\n      this.relaySet = new NDKRelaySet(/* @__PURE__ */ new Set(), ndk, this.pool);\n      for (const url of relayUrls) {\n        const relay = this.pool.getRelay(url, false, false);\n        relay.authPolicy = NDKRelayAuthPolicies.signIn({ ndk, signer, debug: debug8 });\n        this.relaySet.addRelay(relay);\n        relay.connect();\n      }\n    }\n    this.debug = debug8.extend(\"rpc\");\n  }\n  /**\n   * Subscribe to a filter. This function will resolve once the subscription is ready.\n   */\n  subscribe(filter) {\n    const sub = this.ndk.subscribe(\n      filter,\n      {\n        closeOnEose: false,\n        groupable: false,\n        cacheUsage: \"ONLY_RELAY\" /* ONLY_RELAY */,\n        pool: this.pool\n      },\n      this.relaySet,\n      false\n    );\n    sub.on(\"event\", async (event) => {\n      try {\n        const parsedEvent = await this.parseEvent(event);\n        if (parsedEvent.method) {\n          this.emit(\"request\", parsedEvent);\n        } else {\n          this.emit(`response-${parsedEvent.id}`, parsedEvent);\n        }\n      } catch (e) {\n        this.debug(\"error parsing event\", e, event.rawEvent());\n      }\n    });\n    return new Promise((resolve) => {\n      sub.on(\"eose\", () => {\n        this.debug(\"eosed\");\n        resolve(sub);\n      });\n      sub.start();\n    });\n  }\n  async parseEvent(event) {\n    if (this.encryptionType === \"nip44\" && event.content.includes(\"?iv=\")) {\n      this.encryptionType = \"nip04\";\n    } else if (this.encryptionType === \"nip04\" && !event.content.includes(\"?iv=\")) {\n      this.encryptionType = \"nip44\";\n    }\n    const remoteUser = this.ndk.getUser({ pubkey: event.pubkey });\n    remoteUser.ndk = this.ndk;\n    let decryptedContent;\n    try {\n      decryptedContent = await this.signer.decrypt(\n        remoteUser,\n        event.content,\n        this.encryptionType\n      );\n    } catch (e) {\n      const otherEncryptionType = this.encryptionType === \"nip04\" ? \"nip44\" : \"nip04\";\n      decryptedContent = await this.signer.decrypt(remoteUser, event.content, otherEncryptionType);\n      this.encryptionType = otherEncryptionType;\n    }\n    const parsedContent = JSON.parse(decryptedContent);\n    const { id, method, params, result, error } = parsedContent;\n    if (method) {\n      return { id, pubkey: event.pubkey, method, params, event };\n    } else {\n      return { id, result, error, event };\n    }\n  }\n  async sendResponse(id, remotePubkey, result, kind = 24133 /* NostrConnect */, error) {\n    const res = { id, result };\n    if (error) {\n      res.error = error;\n    }\n    const localUser = await this.signer.user();\n    const remoteUser = this.ndk.getUser({ pubkey: remotePubkey });\n    const event = new NDKEvent(this.ndk, {\n      kind,\n      content: JSON.stringify(res),\n      tags: [[\"p\", remotePubkey]],\n      pubkey: localUser.pubkey\n    });\n    event.content = await this.signer.encrypt(remoteUser, event.content, this.encryptionType);\n    await event.sign(this.signer);\n    await event.publish(this.relaySet);\n  }\n  /**\n   * Sends a request.\n   * @param remotePubkey\n   * @param method\n   * @param params\n   * @param kind\n   * @param id\n   */\n  async sendRequest(remotePubkey, method, params = [], kind = 24133, cb) {\n    const id = Math.random().toString(36).substring(7);\n    const localUser = await this.signer.user();\n    const remoteUser = this.ndk.getUser({ pubkey: remotePubkey });\n    const request = { id, method, params };\n    const promise = new Promise(() => {\n      const responseHandler = (response) => {\n        if (response.result === \"auth_url\") {\n          this.once(`response-${id}`, responseHandler);\n          this.emit(\"authUrl\", response.error);\n        } else if (cb) {\n          cb(response);\n        }\n      };\n      this.once(`response-${id}`, responseHandler);\n    });\n    const event = new NDKEvent(this.ndk, {\n      kind,\n      content: JSON.stringify(request),\n      tags: [[\"p\", remotePubkey]],\n      pubkey: localUser.pubkey\n    });\n    event.content = await this.signer.encrypt(remoteUser, event.content, this.encryptionType);\n    await event.sign(this.signer);\n    await event.publish(this.relaySet);\n    return promise;\n  }\n};\n\n// src/signers/nip46/backend/ping.ts\nvar PingEventHandlingStrategy = class {\n  async handle(backend, id, remotePubkey, params) {\n    const debug8 = backend.debug.extend(\"ping\");\n    debug8(`ping request from ${remotePubkey}`);\n    if (await backend.pubkeyAllowed({ id, pubkey: remotePubkey, method: \"ping\" })) {\n      debug8(`connection request from ${remotePubkey} allowed`);\n      return \"pong\";\n    } else {\n      debug8(`connection request from ${remotePubkey} rejected`);\n    }\n    return void 0;\n  }\n};\n\n// src/signers/nip46/backend/connect.ts\nvar ConnectEventHandlingStrategy = class {\n  async handle(backend, id, remotePubkey, params) {\n    const [_, token] = params;\n    const debug8 = backend.debug.extend(\"connect\");\n    debug8(`connection request from ${remotePubkey}`);\n    if (token && backend.applyToken) {\n      debug8(`applying token`);\n      await backend.applyToken(remotePubkey, token);\n    }\n    if (await backend.pubkeyAllowed({\n      id,\n      pubkey: remotePubkey,\n      method: \"connect\",\n      params: token\n    })) {\n      debug8(`connection request from ${remotePubkey} allowed`);\n      return \"ack\";\n    } else {\n      debug8(`connection request from ${remotePubkey} rejected`);\n    }\n    return void 0;\n  }\n};\n\n// src/signers/nip46/backend/get-public-key.ts\nvar GetPublicKeyHandlingStrategy = class {\n  async handle(backend, id, remotePubkey, params) {\n    return backend.localUser?.pubkey;\n  }\n};\n\n// src/signers/nip46/backend/nip04-decrypt.ts\nvar Nip04DecryptHandlingStrategy = class {\n  async handle(backend, id, remotePubkey, params) {\n    const [senderPubkey, payload] = params;\n    const senderUser = new NDKUser({ pubkey: senderPubkey });\n    const decryptedPayload = await decrypt2(backend, id, remotePubkey, senderUser, payload);\n    return decryptedPayload;\n  }\n};\nasync function decrypt2(backend, id, remotePubkey, senderUser, payload) {\n  if (!await backend.pubkeyAllowed({\n    id,\n    pubkey: remotePubkey,\n    method: \"nip04_decrypt\",\n    params: payload\n  })) {\n    backend.debug(`decrypt request from ${remotePubkey} rejected`);\n    return void 0;\n  }\n  return await backend.signer.decrypt(senderUser, payload, \"nip04\");\n}\n\n// src/signers/nip46/backend/nip04-encrypt.ts\nvar Nip04EncryptHandlingStrategy = class {\n  async handle(backend, id, remotePubkey, params) {\n    const [recipientPubkey, payload] = params;\n    const recipientUser = new NDKUser({ pubkey: recipientPubkey });\n    const encryptedPayload = await encrypt2(backend, id, remotePubkey, recipientUser, payload);\n    return encryptedPayload;\n  }\n};\nasync function encrypt2(backend, id, remotePubkey, recipientUser, payload) {\n  if (!await backend.pubkeyAllowed({\n    id,\n    pubkey: remotePubkey,\n    method: \"nip04_encrypt\",\n    params: payload\n  })) {\n    backend.debug(`encrypt request from ${remotePubkey} rejected`);\n    return void 0;\n  }\n  return await backend.signer.encrypt(recipientUser, payload, \"nip04\");\n}\n\n// src/signers/nip46/backend/sign-event.ts\nvar SignEventHandlingStrategy = class {\n  async handle(backend, id, remotePubkey, params) {\n    const event = await signEvent(backend, id, remotePubkey, params);\n    if (!event) return void 0;\n    return JSON.stringify(await event.toNostrEvent());\n  }\n};\nasync function signEvent(backend, id, remotePubkey, params) {\n  const [eventString] = params;\n  backend.debug(`sign event request from ${remotePubkey}`);\n  const event = new NDKEvent(backend.ndk, JSON.parse(eventString));\n  backend.debug(\"event to sign\", event.rawEvent());\n  if (!await backend.pubkeyAllowed({\n    id,\n    pubkey: remotePubkey,\n    method: \"sign_event\",\n    params: event\n  })) {\n    backend.debug(`sign event request from ${remotePubkey} rejected`);\n    return void 0;\n  }\n  backend.debug(`sign event request from ${remotePubkey} allowed`);\n  await event.sign(backend.signer);\n  return event;\n}\n\n// src/signers/nip46/backend/nip44-encrypt.ts\nvar Nip04EncryptHandlingStrategy2 = class {\n  async handle(backend, id, remotePubkey, params) {\n    const [recipientPubkey, payload] = params;\n    const recipientUser = new NDKUser({ pubkey: recipientPubkey });\n    const encryptedPayload = await encrypt3(backend, id, remotePubkey, recipientUser, payload);\n    return encryptedPayload;\n  }\n};\nasync function encrypt3(backend, id, remotePubkey, recipientUser, payload) {\n  if (!await backend.pubkeyAllowed({\n    id,\n    pubkey: remotePubkey,\n    method: \"nip44_encrypt\",\n    params: payload\n  })) {\n    backend.debug(`encrypt request from ${remotePubkey} rejected`);\n    return void 0;\n  }\n  return await backend.signer.encrypt(recipientUser, payload, \"nip44\");\n}\n\n// src/signers/nip46/backend/nip44-decrypt.ts\nvar Nip04DecryptHandlingStrategy2 = class {\n  async handle(backend, id, remotePubkey, params) {\n    const [senderPubkey, payload] = params;\n    const senderUser = new NDKUser({ pubkey: senderPubkey });\n    const decryptedPayload = await decrypt3(backend, id, remotePubkey, senderUser, payload);\n    return decryptedPayload;\n  }\n};\nasync function decrypt3(backend, id, remotePubkey, senderUser, payload) {\n  if (!await backend.pubkeyAllowed({\n    id,\n    pubkey: remotePubkey,\n    method: \"nip44_decrypt\",\n    params: payload\n  })) {\n    backend.debug(`decrypt request from ${remotePubkey} rejected`);\n    return void 0;\n  }\n  return await backend.signer.decrypt(senderUser, payload, \"nip44\");\n}\n\n// src/signers/nip46/backend/index.ts\n\nvar NDKNip46Backend = class {\n  ndk;\n  signer;\n  localUser;\n  debug;\n  rpc;\n  permitCallback;\n  relayUrls;\n  /**\n   * @param ndk The NDK instance to use\n   * @param privateKeyOrSigner The private key or signer of the npub that wants to be published as\n   * @param permitCallback Callback executed when permission is requested\n   */\n  constructor(ndk, privateKeyOrSigner, permitCallback, relayUrls) {\n    this.ndk = ndk;\n    if (privateKeyOrSigner instanceof Uint8Array) {\n      this.signer = new NDKPrivateKeySigner(privateKeyOrSigner);\n    } else if (privateKeyOrSigner instanceof String) {\n      this.signer = new NDKPrivateKeySigner((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_6__.hexToBytes)(privateKeyOrSigner));\n    } else if (privateKeyOrSigner instanceof NDKPrivateKeySigner) {\n      this.signer = privateKeyOrSigner;\n    } else {\n      throw new Error(\"Invalid signer\");\n    }\n    this.debug = ndk.debug.extend(\"nip46:backend\");\n    this.relayUrls = relayUrls ?? Array.from(ndk.pool.relays.keys());\n    this.rpc = new NDKNostrRpc(ndk, this.signer, this.debug, this.relayUrls);\n    this.permitCallback = permitCallback;\n  }\n  /**\n   * This method starts the backend, which will start listening for incoming\n   * requests.\n   */\n  async start() {\n    this.localUser = await this.signer.user();\n    const sub = this.ndk.subscribe(\n      {\n        kinds: [24133],\n        \"#p\": [this.localUser.pubkey]\n      },\n      { closeOnEose: false }\n    );\n    sub.on(\"event\", (e) => this.handleIncomingEvent(e));\n  }\n  handlers = {\n    connect: new ConnectEventHandlingStrategy(),\n    sign_event: new SignEventHandlingStrategy(),\n    nip04_encrypt: new Nip04EncryptHandlingStrategy(),\n    nip04_decrypt: new Nip04DecryptHandlingStrategy(),\n    nip44_encrypt: new Nip04EncryptHandlingStrategy2(),\n    nip44_decrypt: new Nip04DecryptHandlingStrategy2(),\n    get_public_key: new GetPublicKeyHandlingStrategy(),\n    ping: new PingEventHandlingStrategy()\n  };\n  /**\n   * Enables the user to set a custom strategy for handling incoming events.\n   * @param method - The method to set the strategy for\n   * @param strategy - The strategy to set\n   */\n  setStrategy(method, strategy) {\n    this.handlers[method] = strategy;\n  }\n  /**\n   * Overload this method to apply tokens, which can\n   * wrap permission sets to be applied to a pubkey.\n   * @param pubkey public key to apply token to\n   * @param token token to apply\n   */\n  async applyToken(pubkey, token) {\n    throw new Error(\"connection token not supported\");\n  }\n  async handleIncomingEvent(event) {\n    const { id, method, params } = await this.rpc.parseEvent(event);\n    const remotePubkey = event.pubkey;\n    let response;\n    this.debug(\"incoming event\", { id, method, params });\n    if (!event.verifySignature(false)) {\n      this.debug(\"invalid signature\", event.rawEvent());\n      return;\n    }\n    const strategy = this.handlers[method];\n    if (strategy) {\n      try {\n        response = await strategy.handle(this, id, remotePubkey, params);\n      } catch (e) {\n        this.debug(\"error handling event\", e, { id, method, params });\n        this.rpc.sendResponse(id, remotePubkey, \"error\", void 0, e.message);\n      }\n    } else {\n      this.debug(\"unsupported method\", { method, params });\n    }\n    if (response) {\n      this.debug(`sending response to ${remotePubkey}`, response);\n      this.rpc.sendResponse(id, remotePubkey, response);\n    } else {\n      this.rpc.sendResponse(id, remotePubkey, \"error\", void 0, \"Not authorized\");\n    }\n  }\n  /**\n   * This method should be overriden by the user to allow or reject incoming\n   * connections.\n   */\n  async pubkeyAllowed(params) {\n    return this.permitCallback(params);\n  }\n};\n\n// src/signers/nip46/index.ts\n\nvar NDKNip46Signer = class extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  ndk;\n  _user;\n  /**\n   * The pubkey of the bunker that will be providing signatures\n   */\n  bunkerPubkey;\n  /**\n   * The pubkey of the user that events will be published as\n   */\n  userPubkey;\n  /**\n   * An optional secret value provided to connect to the bunker\n   */\n  secret;\n  localSigner;\n  nip05;\n  rpc;\n  debug;\n  relayUrls;\n  subscription;\n  /**\n   * @param ndk - The NDK instance to use\n   * @param userOrConnectionToken - The public key, or a connection token, of the npub that wants to be published as\n   * @param localSigner - The signer that will be used to request events to be signed\n   */\n  constructor(ndk, userOrConnectionToken, localSigner) {\n    super();\n    this.ndk = ndk;\n    this.debug = ndk.debug.extend(\"nip46:signer\");\n    if (userOrConnectionToken.startsWith(\"bunker://\")) {\n      this.connectionTokenInit(userOrConnectionToken);\n    } else {\n      this.nip05Init(userOrConnectionToken);\n    }\n    if (!localSigner) {\n      this.localSigner = NDKPrivateKeySigner.generate();\n    } else {\n      this.localSigner = localSigner;\n    }\n    this.rpc = new NDKNostrRpc(this.ndk, this.localSigner, this.debug, this.relayUrls);\n  }\n  connectionTokenInit(connectionToken) {\n    const bunkerUrl = new URL(connectionToken);\n    const bunkerPubkey = bunkerUrl.hostname || bunkerUrl.pathname.replace(/^\\/\\//, \"\");\n    const userPubkey = bunkerUrl.searchParams.get(\"pubkey\");\n    const relayUrls = bunkerUrl.searchParams.getAll(\"relay\");\n    const secret = bunkerUrl.searchParams.get(\"secret\");\n    this.bunkerPubkey = bunkerPubkey;\n    this.userPubkey = userPubkey;\n    this.relayUrls = relayUrls;\n    this.secret = secret;\n  }\n  nip05Init(nip05) {\n    this.nip05 = nip05;\n  }\n  /**\n   * @deprecated Use userPubkey instead\n   */\n  get remotePubkey() {\n    return this.userPubkey;\n  }\n  /**\n   * We start listening for events from the bunker\n   */\n  async startListening() {\n    if (this.subscription) return;\n    const localUser = await this.localSigner.user();\n    if (!localUser) throw new Error(\"Local signer not ready\");\n    this.subscription = await this.rpc.subscribe({\n      kinds: [24133 /* NostrConnect */],\n      \"#p\": [localUser.pubkey]\n    });\n  }\n  /**\n   * Get the user that is being published as\n   */\n  async user() {\n    if (!this._user && !this.userPubkey) throw new Error(\"Remote user not ready\");\n    this._user ??= new NDKUser({ pubkey: this.userPubkey });\n    return this._user;\n  }\n  async blockUntilReady() {\n    if (this.nip05 && !this.userPubkey) {\n      const user = await NDKUser.fromNip05(this.nip05, this.ndk);\n      if (user) {\n        this._user = user;\n        this.userPubkey = user.pubkey;\n        this.relayUrls = user.nip46Urls;\n        this.rpc = new NDKNostrRpc(this.ndk, this.localSigner, this.debug, this.relayUrls);\n      }\n    }\n    if (!this.bunkerPubkey && this.userPubkey) {\n      this.bunkerPubkey = this.userPubkey;\n    } else if (!this.bunkerPubkey) {\n      throw new Error(\"Bunker pubkey not set\");\n    }\n    await this.startListening();\n    this.rpc.on(\"authUrl\", (...props) => {\n      this.emit(\"authUrl\", ...props);\n    });\n    return new Promise((resolve, reject) => {\n      const connectParams = [this.userPubkey ?? \"\"];\n      if (this.secret) connectParams.push(this.secret);\n      if (!this.bunkerPubkey) throw new Error(\"Bunker pubkey not set\");\n      this.rpc.sendRequest(\n        this.bunkerPubkey,\n        \"connect\",\n        connectParams,\n        24133,\n        (response) => {\n          if (response.result === \"ack\") {\n            this.getPublicKey().then((pubkey) => {\n              this.userPubkey = pubkey;\n              this._user = new NDKUser({ pubkey });\n              resolve(this._user);\n            });\n          } else {\n            reject(response.error);\n          }\n        }\n      );\n    });\n  }\n  async getPublicKey() {\n    if (this.userPubkey) return this.userPubkey;\n    return new Promise((resolve, reject) => {\n      if (!this.bunkerPubkey) throw new Error(\"Bunker pubkey not set\");\n      this.rpc.sendRequest(\n        this.bunkerPubkey,\n        \"get_public_key\",\n        [],\n        24133,\n        (response) => {\n          resolve(response.result);\n        }\n      );\n    });\n  }\n  async encryptionEnabled(scheme) {\n    if (scheme) return [scheme];\n    return Promise.resolve([\"nip04\", \"nip44\"]);\n  }\n  async encrypt(recipient, value, scheme = \"nip04\") {\n    return this.encryption(recipient, value, scheme, \"encrypt\");\n  }\n  async decrypt(sender, value, scheme = \"nip04\") {\n    return this.encryption(sender, value, scheme, \"decrypt\");\n  }\n  async encryption(peer, value, scheme, method) {\n    const promise = new Promise((resolve, reject) => {\n      if (!this.bunkerPubkey) throw new Error(\"Bunker pubkey not set\");\n      this.rpc.sendRequest(\n        this.bunkerPubkey,\n        `${scheme}_${method}`,\n        [peer.pubkey, value],\n        24133,\n        (response) => {\n          if (!response.error) {\n            resolve(response.result);\n          } else {\n            reject(response.error);\n          }\n        }\n      );\n    });\n    return promise;\n  }\n  async sign(event) {\n    const promise = new Promise((resolve, reject) => {\n      if (!this.bunkerPubkey) throw new Error(\"Bunker pubkey not set\");\n      this.rpc.sendRequest(\n        this.bunkerPubkey,\n        \"sign_event\",\n        [JSON.stringify(event)],\n        24133,\n        (response) => {\n          if (!response.error) {\n            const json = JSON.parse(response.result);\n            resolve(json.sig);\n          } else {\n            reject(response.error);\n          }\n        }\n      );\n    });\n    return promise;\n  }\n  /**\n   * Allows creating a new account on the remote server.\n   * @param username Desired username for the NIP-05\n   * @param domain Desired domain for the NIP-05\n   * @param email Email address to associate with this account -- Remote servers may use this for recovery\n   * @returns The public key of the newly created account\n   */\n  async createAccount(username, domain, email) {\n    await this.startListening();\n    const req = [];\n    if (username) req.push(username);\n    if (domain) req.push(domain);\n    if (email) req.push(email);\n    return new Promise((resolve, reject) => {\n      if (!this.bunkerPubkey) throw new Error(\"Bunker pubkey not set\");\n      this.rpc.sendRequest(\n        this.bunkerPubkey,\n        \"create_account\",\n        req,\n        24133 /* NostrConnect */,\n        (response) => {\n          if (!response.error) {\n            const pubkey = response.result;\n            resolve(pubkey);\n          } else {\n            reject(response.error);\n          }\n        }\n      );\n    });\n  }\n};\n\n// src/dvm/schedule.ts\nfunction addRelays(event, relays) {\n  const tags = [];\n  if (!relays || relays.length === 0) {\n    const poolRelays = event.ndk?.pool.relays;\n    relays = poolRelays ? Object.keys(poolRelays) : void 0;\n  }\n  if (relays && relays.length > 0) tags.push([\"relays\", ...relays]);\n  return tags;\n}\nasync function dvmSchedule(events, dvm, relays, encrypted = true, waitForConfirmationForMs) {\n  if (!(events instanceof Array)) {\n    events = [events];\n  }\n  const ndk = events[0].ndk;\n  if (!ndk) throw new Error(\"NDK not set\");\n  for (const event of events) {\n    if (!event.sig) throw new Error(\"Event not signed\");\n    if (!event.created_at) throw new Error(\"Event has no date\");\n    if (!dvm) throw new Error(\"No DVM specified\");\n    if (event.created_at <= Date.now() / 1e3)\n      throw new Error(\"Event needs to be in the future\");\n  }\n  const scheduleEvent = new NDKDVMRequest(ndk, {\n    kind: 5905 /* DVMEventSchedule */\n  });\n  for (const event of events) {\n    scheduleEvent.addInput(JSON.stringify(event.rawEvent()), \"text\");\n  }\n  scheduleEvent.tags.push(...addRelays(events[0], relays));\n  if (encrypted) {\n    await scheduleEvent.encryption(dvm);\n  } else {\n    scheduleEvent.dvm = dvm;\n  }\n  await scheduleEvent.sign();\n  let res;\n  if (waitForConfirmationForMs) {\n    res = ndk.subscribe(\n      {\n        kinds: [5905 /* DVMEventSchedule */ + 1e3, 7e3 /* DVMJobFeedback */],\n        ...scheduleEvent.filter()\n      },\n      { groupable: false, closeOnEose: false }\n    );\n  }\n  const timeoutPromise = new Promise((reject) => {\n    setTimeout(() => {\n      res?.stop();\n      reject(\"Timeout waiting for an answer from the DVM\");\n    }, waitForConfirmationForMs);\n  });\n  const schedulePromise = new Promise(\n    (resolve, reject) => {\n      if (waitForConfirmationForMs) {\n        res?.on(\"event\", async (e) => {\n          res?.stop();\n          if (e.kind === 7e3 /* DVMJobFeedback */) {\n            const feedback = await NDKDVMJobFeedback.from(e);\n            if (feedback.status === \"error\") {\n              const statusTag = feedback.getMatchingTags(\"status\");\n              reject(statusTag?.[2] ?? feedback);\n            } else {\n              resolve(feedback);\n            }\n          }\n          resolve(e);\n        });\n      }\n      scheduleEvent.publish().then(() => {\n        if (!waitForConfirmationForMs) resolve();\n      });\n    }\n  );\n  return new Promise((resolve, reject) => {\n    if (waitForConfirmationForMs) {\n      Promise.race([timeoutPromise, schedulePromise]).then((e) => {\n        resolve(e);\n      }).catch(reject);\n    } else {\n      schedulePromise.then(resolve);\n    }\n  });\n}\n\n// src/ndk/index.ts\n\n\n\n// src/events/dedup.ts\nfunction dedup(event1, event2) {\n  if (event1.created_at > event2.created_at) {\n    return event1;\n  }\n  return event2;\n}\n\n// src/outbox/tracker.ts\n\n\n\n// src/utils/get-users-relay-list.ts\nasync function getRelayListForUser(pubkey, ndk) {\n  const list = await getRelayListForUsers([pubkey], ndk);\n  return list.get(pubkey);\n}\nasync function getRelayListForUsers(pubkeys, ndk, skipCache = false, timeout = 1e3) {\n  const pool = ndk.outboxPool || ndk.pool;\n  const set = /* @__PURE__ */ new Set();\n  for (const relay of pool.relays.values()) set.add(relay);\n  const relayLists = /* @__PURE__ */ new Map();\n  const fromContactList = /* @__PURE__ */ new Map();\n  const relaySet = new NDKRelaySet(set, ndk);\n  if (ndk.cacheAdapter?.locking && !skipCache) {\n    const cachedList = await ndk.fetchEvents(\n      { kinds: [3, 10002], authors: Array.from(new Set(pubkeys)) },\n      { cacheUsage: \"ONLY_CACHE\" /* ONLY_CACHE */, subId: \"ndk-relay-list-fetch\" }\n    );\n    for (const relayList of cachedList) {\n      if (relayList.kind === 10002)\n        relayLists.set(relayList.pubkey, NDKRelayList.from(relayList));\n    }\n    for (const relayList of cachedList) {\n      if (relayList.kind === 3) {\n        if (relayLists.has(relayList.pubkey)) continue;\n        const list = relayListFromKind3(ndk, relayList);\n        if (list) fromContactList.set(relayList.pubkey, list);\n      }\n    }\n    pubkeys = pubkeys.filter(\n      (pubkey) => !relayLists.has(pubkey) && !fromContactList.has(pubkey)\n    );\n  }\n  if (pubkeys.length === 0) return relayLists;\n  const relayListEvents = /* @__PURE__ */ new Map();\n  const contactListEvents = /* @__PURE__ */ new Map();\n  return new Promise(async (resolve) => {\n    const sub = ndk.subscribe(\n      { kinds: [3, 10002], authors: pubkeys },\n      {\n        closeOnEose: true,\n        pool,\n        groupable: true,\n        cacheUsage: \"ONLY_RELAY\" /* ONLY_RELAY */,\n        subId: \"ndk-relay-list-fetch\"\n      },\n      relaySet,\n      false\n    );\n    sub.on(\"event\", (event) => {\n      if (event.kind === 10002 /* RelayList */) {\n        const existingEvent = relayListEvents.get(event.pubkey);\n        if (existingEvent && existingEvent.created_at > event.created_at) return;\n        relayListEvents.set(event.pubkey, event);\n      } else if (event.kind === 3 /* Contacts */) {\n        const existingEvent = contactListEvents.get(event.pubkey);\n        if (existingEvent && existingEvent.created_at > event.created_at) return;\n        contactListEvents.set(event.pubkey, event);\n      }\n    });\n    sub.on(\"eose\", () => {\n      for (const event of relayListEvents.values()) {\n        relayLists.set(event.pubkey, NDKRelayList.from(event));\n      }\n      for (const pubkey of pubkeys) {\n        if (relayLists.has(pubkey)) continue;\n        const contactList = contactListEvents.get(pubkey);\n        if (!contactList) continue;\n        const list = relayListFromKind3(ndk, contactList);\n        if (list) relayLists.set(pubkey, list);\n      }\n      resolve(relayLists);\n    });\n    setTimeout(() => {\n      resolve(relayLists);\n    }, timeout);\n    sub.start();\n  });\n}\n\n// src/outbox/tracker.ts\nvar OutboxItem = class {\n  /**\n   * Type of item\n   */\n  type;\n  /**\n   * The relay URLs that are of interest to this item\n   */\n  relayUrlScores;\n  readRelays;\n  writeRelays;\n  constructor(type) {\n    this.type = type;\n    this.relayUrlScores = /* @__PURE__ */ new Map();\n    this.readRelays = /* @__PURE__ */ new Set();\n    this.writeRelays = /* @__PURE__ */ new Set();\n  }\n};\nvar OutboxTracker = class extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  data;\n  ndk;\n  debug;\n  constructor(ndk) {\n    super();\n    this.ndk = ndk;\n    this.debug = ndk.debug.extend(\"outbox-tracker\");\n    this.data = new typescript_lru_cache__WEBPACK_IMPORTED_MODULE_3__.LRUCache({\n      maxSize: 1e5,\n      entryExpirationTimeInMS: 2 * 60 * 1e3\n    });\n  }\n  /**\n   * Adds a list of users to the tracker.\n   * @param items\n   * @param skipCache\n   */\n  async trackUsers(items, skipCache = false) {\n    const promises = [];\n    for (let i = 0; i < items.length; i += 400) {\n      const slice = items.slice(i, i + 400);\n      const pubkeys = slice.map((item) => getKeyFromItem(item)).filter((pubkey) => !this.data.has(pubkey));\n      if (pubkeys.length === 0) continue;\n      for (const pubkey of pubkeys) {\n        this.data.set(pubkey, new OutboxItem(\"user\"));\n      }\n      promises.push(\n        new Promise((resolve) => {\n          getRelayListForUsers(pubkeys, this.ndk, skipCache).then((relayLists) => {\n            for (const [pubkey, relayList] of relayLists) {\n              let outboxItem = this.data.get(pubkey);\n              outboxItem ??= new OutboxItem(\"user\");\n              if (relayList) {\n                outboxItem.readRelays = new Set(\n                  normalize(relayList.readRelayUrls)\n                );\n                outboxItem.writeRelays = new Set(\n                  normalize(relayList.writeRelayUrls)\n                );\n                for (const relayUrl of outboxItem.readRelays) {\n                  if (this.ndk.pool.blacklistRelayUrls.has(relayUrl)) {\n                    outboxItem.readRelays.delete(relayUrl);\n                  }\n                }\n                for (const relayUrl of outboxItem.writeRelays) {\n                  if (this.ndk.pool.blacklistRelayUrls.has(relayUrl)) {\n                    outboxItem.writeRelays.delete(relayUrl);\n                  }\n                }\n                this.data.set(pubkey, outboxItem);\n              }\n            }\n          }).finally(resolve);\n        })\n      );\n    }\n    return Promise.all(promises);\n  }\n  /**\n   *\n   * @param key\n   * @param score\n   */\n  track(item, type, skipCache = true) {\n    const key = getKeyFromItem(item);\n    type ??= getTypeFromItem(item);\n    let outboxItem = this.data.get(key);\n    if (!outboxItem) {\n      outboxItem = new OutboxItem(type);\n      if (item instanceof NDKUser) {\n        this.trackUsers([item]);\n      }\n    }\n    return outboxItem;\n  }\n};\nfunction getKeyFromItem(item) {\n  if (item instanceof NDKUser) {\n    return item.pubkey;\n  } else {\n    return item;\n  }\n}\nfunction getTypeFromItem(item) {\n  if (item instanceof NDKUser) {\n    return \"user\";\n  } else {\n    return \"kind\";\n  }\n}\n\n// src/relay/sets/utils.ts\nfunction correctRelaySet(relaySet, pool) {\n  const connectedRelays = pool.connectedRelays();\n  const includesConnectedRelay = Array.from(relaySet.relays).some((relay) => {\n    return connectedRelays.map((r) => r.url).includes(relay.url);\n  });\n  if (!includesConnectedRelay) {\n    for (const relay of connectedRelays) {\n      relaySet.addRelay(relay);\n    }\n  }\n  if (connectedRelays.length === 0) {\n    for (const relay of pool.relays.values()) {\n      relaySet.addRelay(relay);\n    }\n  }\n  return relaySet;\n}\n\n// src/ndk/fetch-event-from-tag.ts\nfunction isValidHint(hint) {\n  if (!hint || hint === \"\") return false;\n  try {\n    new URL(hint);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nasync function fetchEventFromTag(tag, originalEvent, subOpts, fallback = {\n  type: \"timeout\"\n}) {\n  const d4 = this.debug.extend(\"fetch-event-from-tag\");\n  const [_, id, hint] = tag;\n  subOpts = {};\n  d4(\"fetching event from tag\", tag, subOpts, fallback);\n  const authorRelays = getRelaysForSync(this, originalEvent.pubkey);\n  if (authorRelays && authorRelays.size > 0) {\n    d4(\"fetching event from author relays %o\", Array.from(authorRelays));\n    const relaySet2 = NDKRelaySet.fromRelayUrls(Array.from(authorRelays), this);\n    const event2 = await this.fetchEvent(id, subOpts, relaySet2);\n    if (event2) return event2;\n  } else {\n    d4(\"no author relays found for %s\", originalEvent.pubkey, originalEvent);\n  }\n  const relaySet = calculateRelaySetsFromFilters(this, [{ ids: [id] }], this.pool);\n  d4(\"fetching event without relay hint\", relaySet);\n  const event = await this.fetchEvent(id, subOpts);\n  if (event) return event;\n  if (hint && hint !== \"\") {\n    const event2 = await this.fetchEvent(\n      id,\n      subOpts,\n      this.pool.getRelay(hint, true, true, [{ ids: [id] }])\n    );\n    if (event2) return event2;\n  }\n  let result = void 0;\n  const relay = isValidHint(hint) ? this.pool.getRelay(hint, false, true, [{ ids: [id] }]) : void 0;\n  const fetchMaybeWithRelayHint = new Promise((resolve) => {\n    this.fetchEvent(id, subOpts, relay).then(resolve);\n  });\n  if (!isValidHint(hint) || fallback.type === \"none\") {\n    return fetchMaybeWithRelayHint;\n  }\n  const fallbackFetchPromise = new Promise(async (resolve) => {\n    const fallbackRelaySet = fallback.relaySet;\n    const timeout = fallback.timeout ?? 1500;\n    const timeoutPromise = new Promise((resolve2) => setTimeout(resolve2, timeout));\n    if (fallback.type === \"timeout\") await timeoutPromise;\n    if (result) {\n      resolve(result);\n    } else {\n      d4(\"fallback fetch triggered\");\n      const fallbackEvent = await this.fetchEvent(id, subOpts, fallbackRelaySet);\n      resolve(fallbackEvent);\n    }\n  });\n  switch (fallback.type) {\n    case \"timeout\":\n      return Promise.race([fetchMaybeWithRelayHint, fallbackFetchPromise]);\n    case \"eose\":\n      result = await fetchMaybeWithRelayHint;\n      if (result) return result;\n      return fallbackFetchPromise;\n  }\n}\n\n// src/media/index.ts\nvar SPEC_PATH = \"/.well-known/nostr/nip96.json\";\nvar Nip96 = class {\n  ndk;\n  spec;\n  url;\n  nip98Required = false;\n  /**\n   * @param domain domain of the NIP96 service\n   */\n  constructor(domain, ndk) {\n    this.url = `https://${domain}${SPEC_PATH}`;\n    this.ndk = ndk;\n  }\n  async prepareUpload(blob, httpVerb = \"POST\") {\n    this.validateHttpFetch();\n    if (!this.spec) await this.fetchSpec();\n    if (!this.spec) throw new Error(\"Failed to fetch NIP96 spec\");\n    let headers = {};\n    if (this.nip98Required) {\n      const authorizationHeader = await this.generateNip98Header(\n        this.spec.api_url,\n        httpVerb,\n        blob\n      );\n      headers = { Authorization: authorizationHeader };\n    }\n    return {\n      url: this.spec.api_url,\n      headers\n    };\n  }\n  /**\n   * Provides an XMLHttpRequest-based upload method for browsers.\n   * @example\n   * const xhr = new XMLHttpRequest();\n   * xhr.upload.addEventListener(\"progress\", function(e) {\n   *    const percentComplete = e.loaded / e.total;\n   *    console.log(percentComplete);\n   * });\n   * const nip96 = ndk.getNip96(\"nostrcheck.me\");\n   * const blob = new Blob([\"Hello, world!\"], { type: \"text/plain\" });\n   * const response = await nip96.xhrUpload(xhr, blob);\n   * console.log(response);\n   * @returns Promise that resolves to the upload response\n   */\n  async xhrUpload(xhr, blob) {\n    const httpVerb = \"POST\";\n    const { url, headers } = await this.prepareUpload(blob, httpVerb);\n    xhr.open(httpVerb, url, true);\n    if (headers[\"Authorization\"]) {\n      xhr.setRequestHeader(\"Authorization\", headers[\"Authorization\"]);\n    }\n    const formData = new FormData();\n    formData.append(\"file\", blob);\n    return new Promise((resolve, reject) => {\n      xhr.onload = function() {\n        if (xhr.status >= 200 && xhr.status < 300) {\n          resolve(JSON.parse(xhr.responseText));\n        } else {\n          reject(new Error(xhr.statusText));\n        }\n      };\n      xhr.onerror = function() {\n        reject(new Error(\"Network Error\"));\n      };\n      xhr.send(formData);\n    });\n  }\n  /**\n   * Fetch-based upload method. Note that this will use NDK's httpFetch\n   * @param blob\n   * @returns Promise that resolves to the upload response\n   *\n   * @example\n   * const nip96 = ndk.getNip96(\"nostrcheck.me\");\n   * const blob = new Blob([\"Hello, world!\"], { type: \"text/plain\" });\n   * const response = await nip96.upload(blob);\n   * console.log(response);\n   */\n  async upload(blob) {\n    const httpVerb = \"POST\";\n    const { url, headers } = await this.prepareUpload(blob, httpVerb);\n    const formData = new FormData();\n    formData.append(\"file\", blob);\n    const res = await this.ndk.httpFetch(this.spec.api_url, {\n      method: httpVerb,\n      headers,\n      body: formData\n    });\n    if (res.status !== 200) throw new Error(`Failed to upload file to ${url}`);\n    const json = await res.json();\n    if (json.status !== \"success\") throw new Error(json.message);\n    return json;\n  }\n  validateHttpFetch() {\n    if (!this.ndk) throw new Error(\"NDK is required to fetch NIP96 spec\");\n    if (!this.ndk.httpFetch)\n      throw new Error(\"NDK must have an httpFetch method to fetch NIP96 spec\");\n  }\n  async fetchSpec() {\n    this.validateHttpFetch();\n    const res = await this.ndk.httpFetch(this.url);\n    if (res.status !== 200) throw new Error(`Failed to fetch NIP96 spec from ${this.url}`);\n    const spec = await res.json();\n    if (!spec) throw new Error(`Failed to parse NIP96 spec from ${this.url}`);\n    this.spec = spec;\n    this.nip98Required = this.spec.plans.free.is_nip98_required;\n  }\n  async generateNip98Header(requestUrl, httpMethod, blob) {\n    const event = new NDKEvent(this.ndk, {\n      kind: 27235 /* HttpAuth */,\n      tags: [\n        [\"u\", requestUrl],\n        [\"method\", httpMethod]\n      ]\n    });\n    if ([\"POST\", \"PUT\", \"PATCH\"].includes(httpMethod)) {\n      const sha256Hash = await this.calculateSha256(blob);\n      event.tags.push([\"payload\", sha256Hash]);\n    }\n    await event.sign();\n    const encodedEvent = btoa(JSON.stringify(event.rawEvent()));\n    return `Nostr ${encodedEvent}`;\n  }\n  async calculateSha256(blob) {\n    const buffer = await blob.arrayBuffer();\n    const hashBuffer = await crypto.subtle.digest(\"SHA-256\", buffer);\n    const hashArray = Array.from(new Uint8Array(hashBuffer));\n    const hashHex = hashArray.map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n    return hashHex;\n  }\n};\n\n// src/ndk/queue/index.ts\nvar Queue = class {\n  queue = [];\n  maxConcurrency;\n  processing = /* @__PURE__ */ new Set();\n  promises = /* @__PURE__ */ new Map();\n  constructor(name, maxConcurrency) {\n    this.maxConcurrency = maxConcurrency;\n  }\n  add(item) {\n    if (this.promises.has(item.id)) {\n      return this.promises.get(item.id);\n    } else {\n    }\n    const promise = new Promise((resolve, reject) => {\n      this.queue.push({\n        ...item,\n        func: () => item.func().then(\n          (result) => {\n            resolve(result);\n            return result;\n          },\n          (error) => {\n            reject(error);\n            throw error;\n          }\n        )\n      });\n      this.process();\n    });\n    this.promises.set(item.id, promise);\n    promise.finally(() => {\n      this.promises.delete(item.id);\n      this.processing.delete(item.id);\n      this.process();\n    });\n    return promise;\n  }\n  process() {\n    if (this.processing.size >= this.maxConcurrency || this.queue.length === 0) {\n      return;\n    }\n    const item = this.queue.shift();\n    if (!item || this.processing.has(item.id)) {\n      return;\n    }\n    this.processing.add(item.id);\n    item.func();\n  }\n  clear() {\n    this.queue = [];\n  }\n  clearProcessing() {\n    this.processing.clear();\n  }\n  clearAll() {\n    this.clear();\n    this.clearProcessing();\n  }\n  length() {\n    return this.queue.length;\n  }\n};\n\n// src/subscription/manager.ts\n\nvar NDKSubscriptionManager = class {\n  subscriptions;\n  seenEvents = /* @__PURE__ */ new Map();\n  constructor() {\n    this.subscriptions = /* @__PURE__ */ new Map();\n  }\n  add(sub) {\n    this.subscriptions.set(sub.internalId, sub);\n    if (sub.onStopped) {\n      console.log(\"SUB-MANAGER BUG: Subscription already had onStopped! \\u{1F914}\", sub.internalId);\n    }\n    sub.onStopped = () => {\n      this.subscriptions.delete(sub.internalId);\n    };\n    sub.on(\"close\", () => {\n      this.subscriptions.delete(sub.internalId);\n    });\n  }\n  seenEvent(eventId, relay) {\n    const current = this.seenEvents.get(eventId) || [];\n    current.push(relay);\n    this.seenEvents.set(eventId, current);\n  }\n  /**\n   * Whenever an event comes in, this function is called.\n   * This function matches the received event against all the\n   * known (i.e. active) NDKSubscriptions, and if it matches,\n   * it sends the event to the subscription.\n   * \n   * This is the single place in the codebase that matches\n   * incoming events with parties interested in the event.\n   * \n   * This is also what allows for reactivity in NDK apps, such that\n   * whenever an active subscription receives an event that some\n   * other active subscription would want to receive, both receive it.\n   * \n   * TODO This also allows for subscriptions that overlap in meaning\n   * to be collapsed into one.\n   * \n   * I.e. if a subscription with filter: kinds: [1], authors: [alice]\n   * is created and EOSEs, and then a subsequent subscription with\n   * kinds: [1], authors: [alice] is created, once the second subscription\n   * EOSEs we can safely close it, increment its refCount and close it,\n   * and when the first subscription receives a new event from Alice this\n   * code will make the second subscription receive the event even though\n   * it has no active subscription on a relay.\n   * @param event Raw event received from a relay\n   * @param relay Relay that sent the event\n   * @param optimisticPublish Whether the event is coming from an optimistic publish\n   */\n  dispatchEvent(event, relay, optimisticPublish = false) {\n    if (relay) this.seenEvent(event.id, relay);\n    const subscriptions = this.subscriptions.values();\n    const matchingSubs = [];\n    for (const sub of subscriptions) {\n      if ((0,nostr_tools__WEBPACK_IMPORTED_MODULE_2__.matchFilters)(sub.filters, event)) {\n        matchingSubs.push(sub);\n      }\n    }\n    for (const sub of matchingSubs) {\n      sub.eventReceived(event, relay, false, optimisticPublish);\n    }\n  }\n};\n\n// src/ndk/active-user.ts\n\nvar debug6 = debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:active-user\");\nasync function getUserRelayList(user) {\n  if (!this.autoConnectUserRelays) return;\n  const userRelays = await getRelayListForUser(user.pubkey, this);\n  if (!userRelays) return;\n  for (const url of userRelays.relays) {\n    let relay = this.pool.relays.get(url);\n    if (!relay) {\n      relay = new NDKRelay(url, this.relayAuthDefaultPolicy, this);\n      this.pool.addRelay(relay);\n    }\n  }\n  return userRelays;\n}\nasync function setActiveUser(user) {\n  const pool = this.outboxPool || this.pool;\n  if (pool.connectedRelays.length > 0) {\n    setActiveUserConnected.call(this, user);\n  } else {\n    pool.once(\"connect\", () => {\n      setActiveUserConnected.call(this, user);\n    });\n  }\n}\nasync function setActiveUserConnected(user) {\n  const userRelays = await getUserRelayList.call(this, user);\n  const filters = [\n    {\n      kinds: [10006 /* BlockRelayList */],\n      authors: [user.pubkey]\n    }\n  ];\n  if (this.autoFetchUserMutelist) {\n    filters[0].kinds.push(1e4 /* MuteList */);\n  }\n  const relaySet = userRelays ? userRelays.relaySet : void 0;\n  const sub = this.subscribe(\n    filters,\n    { subId: \"active-user-settings\", closeOnEose: true },\n    relaySet,\n    false\n  );\n  const events = /* @__PURE__ */ new Map();\n  sub.on(\"event\", (event) => {\n    const prevEvent = events.get(event.kind);\n    if (prevEvent && prevEvent.created_at >= event.created_at) return;\n    events.set(event.kind, event);\n  });\n  sub.on(\"eose\", () => {\n    for (const event of events.values()) {\n      processEvent.call(this, event);\n    }\n  });\n  sub.start();\n}\nasync function processEvent(event) {\n  if (event.kind === 10006 /* BlockRelayList */) {\n    processBlockRelayList.call(this, event);\n  } else if (event.kind === 1e4 /* MuteList */) {\n    processMuteList.call(this, event);\n  }\n}\nfunction processBlockRelayList(event) {\n  const list = lists_default.from(event);\n  for (const item of list.items) {\n    this.pool.blacklistRelayUrls.add(item[0]);\n  }\n  debug6(\"Added %d relays to relay blacklist\", list.items.length);\n}\nfunction processMuteList(muteList) {\n  const list = lists_default.from(muteList);\n  for (const item of list.items) {\n    this.mutedIds.set(item[1], item[0]);\n  }\n  debug6(\"Added %d users to mute list\", list.items.length);\n}\n\n// src/ndk/index.ts\nvar DEFAULT_OUTBOX_RELAYS = [\"wss://purplepag.es/\", \"wss://nos.lol/\"];\nvar DEFAULT_BLACKLISTED_RELAYS = [\n  \"wss://brb.io/\",\n  // BRB\n  \"wss://nostr.mutinywallet.com/\"\n  // Don't try to read from this relay since it's a write-only relay\n  // \"wss://purplepag.es/\", // This is a hack, since this is a mostly read-only relay, but not fully. Once we have relay routing this can be removed so it only receives the supported kinds\n];\nvar NDK = class extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  _explicitRelayUrls;\n  blacklistRelayUrls;\n  pool;\n  outboxPool;\n  _signer;\n  _activeUser;\n  cacheAdapter;\n  debug;\n  devWriteRelaySet;\n  outboxTracker;\n  mutedIds;\n  clientName;\n  clientNip89;\n  queuesZapConfig;\n  queuesNip05;\n  asyncSigVerification = false;\n  initialValidationRatio = 1;\n  lowestValidationRatio = 1;\n  validationRatioFn;\n  subManager;\n  publishingFailureHandled = false;\n  pools = [];\n  /**\n   * Default relay-auth policy that will be used when a relay requests authentication,\n   * if no other policy is specified for that relay.\n   *\n   * @example Disconnect from relays that request authentication:\n   * ```typescript\n   * ndk.relayAuthDefaultPolicy = NDKAuthPolicies.disconnect(ndk.pool);\n   * ```\n   *\n   * @example Sign in to relays that request authentication:\n   * ```typescript\n   * ndk.relayAuthDefaultPolicy = NDKAuthPolicies.signIn({ndk})\n   * ```\n   *\n   * @example Sign in to relays that request authentication, asking the user for confirmation:\n   * ```typescript\n   * ndk.relayAuthDefaultPolicy = (relay: NDKRelay) => {\n   *     const signIn = NDKAuthPolicies.signIn({ndk});\n   *     if (confirm(`Relay ${relay.url} is requesting authentication, do you want to sign in?`)) {\n   *        signIn(relay);\n   *     }\n   * }\n   * ```\n   */\n  relayAuthDefaultPolicy;\n  /**\n   * Fetch function to use for HTTP requests.\n   *\n   * @example\n   * ```typescript\n   * import fetch from \"node-fetch\";\n   *\n   * ndk.httpFetch = fetch;\n   * ```\n   */\n  httpFetch;\n  /**\n   * Provide a caller function to receive all networking traffic from relays\n   */\n  netDebug;\n  autoConnectUserRelays = true;\n  autoFetchUserMutelist = true;\n  walletConfig;\n  constructor(opts = {}) {\n    super();\n    this.debug = opts.debug || debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk\");\n    this.netDebug = opts.netDebug;\n    this._explicitRelayUrls = opts.explicitRelayUrls || [];\n    this.blacklistRelayUrls = opts.blacklistRelayUrls || DEFAULT_BLACKLISTED_RELAYS;\n    this.subManager = new NDKSubscriptionManager();\n    this.pool = new NDKPool(\n      opts.explicitRelayUrls || [],\n      [],\n      this\n    );\n    this.pool.name = \"Main\";\n    this.pool.on(\"relay:auth\", async (relay, challenge) => {\n      if (this.relayAuthDefaultPolicy) {\n        await this.relayAuthDefaultPolicy(relay, challenge);\n      }\n    });\n    this.autoConnectUserRelays = opts.autoConnectUserRelays ?? true;\n    this.autoFetchUserMutelist = opts.autoFetchUserMutelist ?? true;\n    this.clientName = opts.clientName;\n    this.clientNip89 = opts.clientNip89;\n    this.relayAuthDefaultPolicy = opts.relayAuthDefaultPolicy;\n    if (opts.enableOutboxModel) {\n      this.outboxPool = new NDKPool(\n        opts.outboxRelayUrls || DEFAULT_OUTBOX_RELAYS,\n        [],\n        this,\n        {\n          debug: this.debug.extend(\"outbox-pool\"),\n          name: \"Outbox Pool\"\n        }\n      );\n      this.outboxTracker = new OutboxTracker(this);\n    }\n    this.signer = opts.signer;\n    this.cacheAdapter = opts.cacheAdapter;\n    this.mutedIds = opts.mutedIds || /* @__PURE__ */ new Map();\n    if (opts.devWriteRelayUrls) {\n      this.devWriteRelaySet = NDKRelaySet.fromRelayUrls(opts.devWriteRelayUrls, this);\n    }\n    this.queuesZapConfig = new Queue(\"zaps\", 3);\n    this.queuesNip05 = new Queue(\"nip05\", 10);\n    this.signatureVerificationWorker = opts.signatureVerificationWorker;\n    this.initialValidationRatio = opts.initialValidationRatio || 1;\n    this.lowestValidationRatio = opts.lowestValidationRatio || 1;\n    try {\n      this.httpFetch = fetch;\n    } catch {\n    }\n  }\n  set explicitRelayUrls(urls) {\n    this._explicitRelayUrls = urls;\n    this.pool.relayUrls = urls;\n  }\n  get explicitRelayUrls() {\n    return this._explicitRelayUrls || [];\n  }\n  set signatureVerificationWorker(worker2) {\n    this.asyncSigVerification = !!worker2;\n    if (worker2) {\n      signatureVerificationInit(worker2);\n    }\n  }\n  /**\n   * Adds an explicit relay to the pool.\n   * @param url\n   * @param relayAuthPolicy Authentication policy to use if different from the default\n   * @param connect Whether to connect to the relay automatically\n   * @returns\n   */\n  addExplicitRelay(urlOrRelay, relayAuthPolicy, connect = true) {\n    let relay;\n    if (typeof urlOrRelay === \"string\") {\n      relay = new NDKRelay(urlOrRelay, relayAuthPolicy, this);\n    } else {\n      relay = urlOrRelay;\n    }\n    this.pool.addRelay(relay, connect);\n    this.explicitRelayUrls.push(relay.url);\n    return relay;\n  }\n  toJSON() {\n    return { relayCount: this.pool.relays.size }.toString();\n  }\n  get activeUser() {\n    return this._activeUser;\n  }\n  /**\n   * Sets the active user for this NDK instance, typically this will be\n   * called when assigning a signer to the NDK instance.\n   *\n   * This function will automatically connect to the user's relays if\n   * `autoConnectUserRelays` is set to true.\n   *\n   * It will also fetch the user's mutelist if `autoFetchUserMutelist` is set to true.\n   */\n  set activeUser(user) {\n    const differentUser = this._activeUser?.pubkey !== user?.pubkey;\n    this._activeUser = user;\n    if (user && differentUser) {\n      setActiveUser.call(this, user);\n    } else if (!user) {\n      this.mutedIds = /* @__PURE__ */ new Map();\n    }\n  }\n  get signer() {\n    return this._signer;\n  }\n  set signer(newSigner) {\n    this._signer = newSigner;\n    if (newSigner) this.emit(\"signer:ready\", newSigner);\n    newSigner?.user().then((user) => {\n      user.ndk = this;\n      this.activeUser = user;\n    });\n  }\n  /**\n   * Connect to relays with optional timeout.\n   * If the timeout is reached, the connection will be continued to be established in the background.\n   */\n  async connect(timeoutMs) {\n    if (this._signer && this.autoConnectUserRelays) {\n      this.debug(\n        \"Attempting to connect to user relays specified by signer %o\",\n        await this._signer.relays?.(this)\n      );\n      if (this._signer.relays) {\n        const relays = await this._signer.relays(this);\n        relays.forEach((relay) => this.pool.addRelay(relay));\n      }\n    }\n    const connections = [this.pool.connect(timeoutMs)];\n    if (this.outboxPool) {\n      connections.push(this.outboxPool.connect(timeoutMs));\n    }\n    this.debug(\"Connecting to relays %o\", { timeoutMs });\n    return Promise.allSettled(connections).then(() => {\n    });\n  }\n  /**\n   * Get a NDKUser object\n   *\n   * @param opts\n   * @returns\n   */\n  getUser(opts) {\n    const user = new NDKUser(opts);\n    user.ndk = this;\n    return user;\n  }\n  /**\n   * Get a NDKUser from a NIP05\n   * @param nip05 NIP-05 ID\n   * @param skipCache Skip cache\n   * @returns\n   */\n  async getUserFromNip05(nip05, skipCache = false) {\n    return NDKUser.fromNip05(nip05, this, skipCache);\n  }\n  /**\n   * Create a new subscription. Subscriptions automatically start, you can make them automatically close when all relays send back an EOSE by setting `opts.closeOnEose` to `true`)\n   *\n   * @param filters\n   * @param opts\n   * @param relaySet explicit relay set to use\n   * @param autoStart automatically start the subscription -- this can be a boolean or an object with `onEvent` and `onEose` handlers\n   * @returns NDKSubscription\n   */\n  subscribe(filters, opts, relaySet, autoStart = true) {\n    const subscription = new NDKSubscription(this, filters, opts, relaySet);\n    this.subManager.add(subscription);\n    const pool = opts?.pool ?? this.pool;\n    if (relaySet) {\n      for (const relay of relaySet.relays) {\n        pool.useTemporaryRelay(relay, void 0, subscription.filters);\n      }\n    }\n    if (this.outboxPool && subscription.hasAuthorsFilter()) {\n      const authors = subscription.filters.filter((filter) => filter.authors && filter.authors?.length > 0).map((filter) => filter.authors).flat();\n      this.outboxTracker?.trackUsers(authors);\n    }\n    if (autoStart) {\n      let eventsHandler;\n      if (typeof autoStart === \"object\") {\n        if (autoStart.onEvent) subscription.on(\"event\", autoStart.onEvent);\n        if (autoStart.onEose) subscription.on(\"eose\", autoStart.onEose);\n        if (autoStart.onEvents) eventsHandler = autoStart.onEvents;\n      }\n      setTimeout(() => {\n        const cachedEvents = subscription.start(!eventsHandler);\n        if (cachedEvents && !!eventsHandler) eventsHandler(cachedEvents);\n      }, 0);\n    }\n    return subscription;\n  }\n  /**\n   * Publish an event to a relay\n   * @param event event to publish\n   * @param relaySet explicit relay set to use\n   * @param timeoutMs timeout in milliseconds to wait for the event to be published\n   * @returns The relays the event was published to\n   *\n   * @deprecated Use `event.publish()` instead\n   */\n  async publish(event, relaySet, timeoutMs) {\n    this.debug(\"Deprecated: Use `event.publish()` instead\");\n    return event.publish(relaySet, timeoutMs);\n  }\n  /**\n   * Attempts to fetch an event from a tag, following relay hints and\n   * other best practices.\n   * @param tag Tag to fetch the event from\n   * @param originalEvent Event where the tag came from\n   * @param subOpts Subscription options to use when fetching the event\n   * @param fallback Fallback options to use when the hint relay doesn't respond\n   * @returns\n   */\n  fetchEventFromTag = fetchEventFromTag.bind(this);\n  /**\n   * Fetch an event from the cache synchronously.\n   * @param idOrFilter event id in bech32 format or filter\n   * @returns events from the cache or null if the cache is empty\n   */\n  fetchEventSync(idOrFilter) {\n    if (!this.cacheAdapter) throw new Error(\"Cache adapter not set\");\n    let filters;\n    if (typeof idOrFilter === \"string\") filters = [filterFromId(idOrFilter)];\n    else filters = idOrFilter;\n    const sub = new NDKSubscription(this, filters);\n    const events = this.cacheAdapter.query(sub);\n    if (events instanceof Promise) throw new Error(\"Cache adapter is async\");\n    return events.map((e) => {\n      e.ndk = this;\n      return e;\n    });\n  }\n  /**\n   * Fetch a single event.\n   *\n   * @param idOrFilter event id in bech32 format or filter\n   * @param opts subscription options\n   * @param relaySetOrRelay explicit relay set to use\n   */\n  async fetchEvent(idOrFilter, opts, relaySetOrRelay) {\n    let filters;\n    let relaySet;\n    if (relaySetOrRelay instanceof NDKRelay) {\n      relaySet = new NDKRelaySet(/* @__PURE__ */ new Set([relaySetOrRelay]), this);\n    } else if (relaySetOrRelay instanceof NDKRelaySet) {\n      relaySet = relaySetOrRelay;\n    }\n    if (!relaySetOrRelay && typeof idOrFilter === \"string\") {\n      if (!isNip33AValue(idOrFilter)) {\n        const relays = relaysFromBech32(idOrFilter, this);\n        if (relays.length > 0) {\n          relaySet = new NDKRelaySet(new Set(relays), this);\n          relaySet = correctRelaySet(relaySet, this.pool);\n        }\n      }\n    }\n    if (typeof idOrFilter === \"string\") {\n      filters = [filterFromId(idOrFilter)];\n    } else if (Array.isArray(idOrFilter)) {\n      filters = idOrFilter;\n    } else {\n      filters = [idOrFilter];\n    }\n    if (filters.length === 0) {\n      throw new Error(`Invalid filter: ${JSON.stringify(idOrFilter)}`);\n    }\n    return new Promise((resolve) => {\n      let fetchedEvent = null;\n      const s = this.subscribe(\n        filters,\n        { ...opts || {}, closeOnEose: true },\n        relaySet,\n        false\n      );\n      const t2 = setTimeout(() => {\n        s.stop();\n        resolve(fetchedEvent);\n      }, 1e4);\n      s.on(\"event\", (event) => {\n        event.ndk = this;\n        if (!event.isReplaceable()) {\n          clearTimeout(t2);\n          resolve(event);\n        } else if (!fetchedEvent || fetchedEvent.created_at < event.created_at) {\n          fetchedEvent = event;\n        }\n      });\n      s.on(\"eose\", () => {\n        clearTimeout(t2);\n        resolve(fetchedEvent);\n      });\n      s.start();\n    });\n  }\n  /**\n   * Fetch events\n   */\n  async fetchEvents(filters, opts, relaySet) {\n    return new Promise((resolve) => {\n      const events = /* @__PURE__ */ new Map();\n      const relaySetSubscription = this.subscribe(\n        filters,\n        { ...opts || {}, closeOnEose: true },\n        relaySet,\n        false\n      );\n      const onEvent = (event) => {\n        if (!(event instanceof NDKEvent)) event = new NDKEvent(void 0, event);\n        const dedupKey = event.deduplicationKey();\n        const existingEvent = events.get(dedupKey);\n        if (existingEvent) {\n          event = dedup(existingEvent, event);\n        }\n        event.ndk = this;\n        events.set(dedupKey, event);\n      };\n      relaySetSubscription.on(\"event\", onEvent);\n      relaySetSubscription.on(\"eose\", () => {\n        resolve(new Set(events.values()));\n      });\n      relaySetSubscription.start();\n    });\n  }\n  /**\n   * Ensures that a signer is available to sign an event.\n   */\n  assertSigner() {\n    if (!this.signer) {\n      this.emit(\"signer:required\");\n      throw new Error(\"Signer required\");\n    }\n  }\n  /**\n   * Creates a new Nip96 instance for the given domain.\n   * @param domain Domain to use for nip96 uploads\n   * @example Upload a file to a NIP-96 enabled domain:\n   *\n   * ```typescript\n   * const blob = new Blob([\"Hello, world!\"], { type: \"text/plain\" });\n   * const nip96 = ndk.getNip96(\"nostrcheck.me\");\n   * await nip96.upload(blob);\n   * ```\n   */\n  getNip96(domain) {\n    return new Nip96(domain, this);\n  }\n  set wallet(wallet) {\n    if (!wallet) {\n      this.walletConfig = void 0;\n      return;\n    }\n    this.walletConfig ??= {};\n    this.walletConfig.lnPay = wallet?.lnPay?.bind(wallet);\n    this.walletConfig.cashuPay = wallet?.cashuPay?.bind(wallet);\n  }\n};\n\n// src/zap/invoice.ts\n\nfunction zapInvoiceFromEvent(event) {\n  const description = event.getMatchingTags(\"description\")[0];\n  const bolt11 = event.getMatchingTags(\"bolt11\")[0];\n  let decodedInvoice;\n  let zapRequest;\n  if (!description || !bolt11 || !bolt11[1]) {\n    return null;\n  }\n  try {\n    let zapRequestPayload = description[1];\n    if (zapRequestPayload.startsWith(\"%\")) {\n      zapRequestPayload = decodeURIComponent(zapRequestPayload);\n    }\n    if (zapRequestPayload === \"\") {\n      return null;\n    }\n    zapRequest = JSON.parse(zapRequestPayload);\n    decodedInvoice = (0,light_bolt11_decoder__WEBPACK_IMPORTED_MODULE_7__.decode)(bolt11[1]);\n  } catch (e) {\n    return null;\n  }\n  const amountSection = decodedInvoice.sections.find((s) => s.name === \"amount\");\n  if (!amountSection) {\n    return null;\n  }\n  const amount = parseInt(amountSection.value);\n  if (!amount) {\n    return null;\n  }\n  const content = zapRequest.content;\n  const sender = zapRequest.pubkey;\n  const recipientTag = event.getMatchingTags(\"p\")[0];\n  const recipient = recipientTag[1];\n  let zappedEvent = event.getMatchingTags(\"e\")[0];\n  if (!zappedEvent) {\n    zappedEvent = event.getMatchingTags(\"a\")[0];\n  }\n  const zappedEventId = zappedEvent ? zappedEvent[1] : void 0;\n  const zapInvoice = {\n    id: event.id,\n    zapper: event.pubkey,\n    zappee: sender,\n    zapped: recipient,\n    zappedEvent: zappedEventId,\n    amount,\n    comment: content\n  };\n  return zapInvoice;\n}\n\n// src/zapper/index.ts\n\n\n\n// src/zapper/nip57.ts\n\nasync function generateZapRequest(target, ndk, data, pubkey, amount, relays, comment, tags, signer) {\n  const zapEndpoint = data.callback;\n  const zapRequest = nostr_tools__WEBPACK_IMPORTED_MODULE_2__.nip57.makeZapRequest({\n    profile: pubkey,\n    // set the event to null since nostr-tools doesn't support nip-33 zaps\n    event: null,\n    amount,\n    comment: comment || \"\",\n    relays: relays.slice(0, 4)\n  });\n  if (target instanceof NDKEvent) {\n    const tags2 = target.referenceTags();\n    const nonPTags = tags2.filter((tag) => tag[0] !== \"p\");\n    zapRequest.tags.push(...nonPTags);\n  }\n  zapRequest.tags.push([\"lnurl\", zapEndpoint]);\n  const event = new NDKEvent(ndk, zapRequest);\n  if (tags) {\n    event.tags = event.tags.concat(tags);\n  }\n  if (event.hasTag(\"a\")) {\n    event.tags = event.tags.filter((tag) => tag[0] !== \"e\");\n  }\n  event.tags = event.tags.filter((tag) => tag[0] !== \"p\");\n  event.tags.push([\"p\", pubkey]);\n  await event.sign(signer);\n  return event;\n}\n\n// src/zapper/ln.ts\n\n\nvar d2 = debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:zapper:ln\");\nasync function getNip57ZapSpecFromLud({ lud06, lud16 }, ndk) {\n  let zapEndpoint;\n  if (lud16 && !lud16.startsWith(\"LNURL\")) {\n    const [name, domain] = lud16.split(\"@\");\n    zapEndpoint = `https://${domain}/.well-known/lnurlp/${name}`;\n  } else if (lud06) {\n    const { words } = _scure_base__WEBPACK_IMPORTED_MODULE_8__.bech32.decode(lud06, 1e3);\n    const data = _scure_base__WEBPACK_IMPORTED_MODULE_8__.bech32.fromWords(words);\n    const utf8Decoder = new TextDecoder(\"utf-8\");\n    zapEndpoint = utf8Decoder.decode(data);\n  }\n  if (!zapEndpoint) {\n    d2(\"No zap endpoint found %o\", { lud06, lud16 });\n    throw new Error(\"No zap endpoint found\");\n  }\n  try {\n    const _fetch = ndk.httpFetch || fetch;\n    const response = await _fetch(zapEndpoint);\n    if (response.status !== 200) {\n      const text = await response.text();\n      throw new Error(`Unable to fetch zap endpoint ${zapEndpoint}: ${text}`);\n    }\n    return await response.json();\n  } catch (e) {\n    throw new Error(`Unable to fetch zap endpoint ${zapEndpoint}: ${e}`);\n  }\n}\n\n// src/zapper/index.ts\nvar d3 = debug__WEBPACK_IMPORTED_MODULE_1__(\"ndk:zapper\");\nvar NDKZapper = class extends tseep__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  target;\n  ndk;\n  comment;\n  amount;\n  unit;\n  tags;\n  signer;\n  zapMethod;\n  nutzapAsFallback;\n  lnPay;\n  /**\n   * Called when a cashu payment is to be made.\n   * This function should swap/mint proofs for the required amount, in the required unit,\n   * in any of the provided mints and return the proofs and mint used.\n   */\n  cashuPay;\n  onComplete;\n  maxRelays = 3;\n  /**\n   * \n   * @param target The target of the zap\n   * @param amount The amount to send indicated in the unit\n   * @param unit The unit of the amount\n   * @param opts Options for the zap\n   */\n  constructor(target, amount, unit = \"msat\", opts = {}) {\n    super();\n    this.target = target;\n    this.ndk = opts.ndk || target.ndk;\n    if (!this.ndk) {\n      throw new Error(\"No NDK instance provided\");\n    }\n    this.amount = amount;\n    this.comment = opts.comment;\n    this.unit = unit;\n    this.tags = opts.tags;\n    this.signer = opts.signer;\n    this.nutzapAsFallback = opts.nutzapAsFallback ?? false;\n    this.lnPay = opts.lnPay || this.ndk.walletConfig?.lnPay;\n    this.cashuPay = opts.cashuPay || this.ndk.walletConfig?.cashuPay;\n    this.onComplete = opts.onComplete || this.ndk.walletConfig?.onPaymentComplete;\n  }\n  /**\n   * Initiate zapping process\n   * \n   * This function will calculate the splits for this zap and initiate each zap split.\n   */\n  async zap(methods) {\n    const splits = this.getZapSplits();\n    const results = /* @__PURE__ */ new Map();\n    await Promise.all(\n      splits.map(async (split) => {\n        let result;\n        try {\n          result = await this.zapSplit(split, methods);\n        } catch (e) {\n          result = new Error(e.message);\n        }\n        this.emit(\"split:complete\", split, result);\n        results.set(split, result);\n      })\n    );\n    this.emit(\"complete\", results);\n    if (this.onComplete) this.onComplete(results);\n    return results;\n  }\n  async zapNip57(split, data) {\n    if (!this.lnPay) throw new Error(\"No lnPay function available\");\n    const zapSpec = await getNip57ZapSpecFromLud(data, this.ndk);\n    if (!zapSpec) throw new Error(\"No zap spec available for recipient\");\n    const relays = await this.relays(split.pubkey);\n    const zapRequest = await generateZapRequest(\n      this.target,\n      this.ndk,\n      zapSpec,\n      split.pubkey,\n      split.amount,\n      relays,\n      this.comment,\n      this.tags,\n      this.signer\n    );\n    if (!zapRequest) {\n      d3(\"Unable to generate zap request\");\n      throw new Error(\"Unable to generate zap request\");\n    }\n    const pr = await this.getLnInvoice(zapRequest, split.amount, zapSpec);\n    if (!pr) {\n      d3(\"Unable to get payment request\");\n      throw new Error(\"Unable to get payment request\");\n    }\n    this.emit(\"ln_invoice\", {\n      amount: split.amount,\n      recipientPubkey: split.pubkey,\n      unit: this.unit,\n      nip57ZapRequest: zapRequest,\n      pr,\n      type: \"nip57\"\n    });\n    const res = await this.lnPay(\n      {\n        target: this.target,\n        recipientPubkey: split.pubkey,\n        paymentDescription: \"NIP-57 Zap\",\n        pr,\n        amount: split.amount,\n        unit: this.unit,\n        nip57ZapRequest: zapRequest\n      }\n    );\n    if (res?.preimage) {\n      this.emit(\"ln_payment\", {\n        preimage: res.preimage,\n        amount: split.amount,\n        recipientPubkey: split.pubkey,\n        pr,\n        unit: this.unit,\n        nip57ZapRequest: zapRequest,\n        type: \"nip57\"\n      });\n    }\n    return res;\n  }\n  /**\n   * Fetches information about a NIP-61 zap and asks the caller to create cashu proofs for the zap.\n   * \n   * (note that the cashuPay function can use any method to create the proofs, including using lightning\n   * to mint proofs in the specified mint, the responsibility of minting the proofs is delegated to the caller (e.g. ndk-wallet))\n   */\n  async zapNip61(split, data) {\n    if (!this.cashuPay) throw new Error(\"No cashuPay function available\");\n    let ret;\n    ret = await this.cashuPay({\n      target: this.target,\n      recipientPubkey: split.pubkey,\n      paymentDescription: \"NIP-61 Zap\",\n      amount: split.amount,\n      unit: this.unit,\n      ...data ?? {}\n    }, (pr) => {\n      this.emit(\"ln_invoice\", {\n        pr,\n        amount: split.amount,\n        recipientPubkey: split.pubkey,\n        unit: this.unit,\n        type: \"nip61\"\n      });\n    });\n    d3(\"NIP-61 Zap result: %o\", ret);\n    if (ret instanceof Error) {\n      return ret;\n    } else if (ret) {\n      const { proofs, mint } = ret;\n      if (!proofs || !mint)\n        throw new Error(\n          \"Invalid zap confirmation: missing proofs or mint: \" + ret\n        );\n      const relays = await this.relays(split.pubkey);\n      const relaySet = NDKRelaySet.fromRelayUrls(relays, this.ndk);\n      const nutzap = new NDKNutzap(this.ndk);\n      nutzap.tags = [...nutzap.tags, ...this.tags || []];\n      nutzap.proofs = proofs;\n      nutzap.mint = mint;\n      nutzap.target = this.target;\n      nutzap.comment = this.comment;\n      nutzap.unit = this.unit;\n      nutzap.recipientPubkey = split.pubkey;\n      await nutzap.sign(this.signer);\n      nutzap.publish(relaySet);\n      return nutzap;\n    }\n  }\n  /**\n   * Get the zap methods available for the recipient and initiates the zap\n   * in the desired method.\n   * @param split \n   * @param methods - The methods to try, if not provided, all methods will be tried.\n   * @returns \n   */\n  async zapSplit(split, methods) {\n    const recipient = this.ndk.getUser({ pubkey: split.pubkey });\n    let zapMethods = await recipient.getZapInfo(2500);\n    let retVal;\n    const canFallbackToNip61 = this.nutzapAsFallback && this.cashuPay;\n    if (zapMethods.size === 0 && !canFallbackToNip61) throw new Error(\"No zap method available for recipient and NIP-61 fallback is disabled\");\n    const nip61Fallback = async () => {\n      if (!this.nutzapAsFallback) return;\n      const relayLists = await getRelayListForUsers([split.pubkey], this.ndk);\n      let relayUrls = relayLists.get(split.pubkey)?.readRelayUrls;\n      relayUrls = this.ndk.pool.connectedRelays().map((r) => r.url);\n      return await this.zapNip61(split, {\n        // use the user's relay list\n        relays: relayUrls,\n        // lock to the user's actual pubkey\n        p2pk: split.pubkey,\n        // allow intramint fallback\n        allowIntramintFallback: !!canFallbackToNip61\n      });\n    };\n    const canUseNip61 = !methods || methods.includes(\"nip61\");\n    const canUseNip57 = !methods || methods.includes(\"nip57\");\n    const nip61Method = zapMethods.get(\"nip61\");\n    if (nip61Method && canUseNip61) {\n      try {\n        retVal = await this.zapNip61(split, nip61Method);\n        if (retVal instanceof NDKNutzap) return retVal;\n      } catch (e) {\n        this.emit(\"notice\", `NIP-61 attempt failed: ${e.message}`);\n      }\n    }\n    const nip57Method = zapMethods.get(\"nip57\");\n    if (nip57Method && canUseNip57) {\n      try {\n        retVal = await this.zapNip57(split, nip57Method);\n        if (!(retVal instanceof Error)) return retVal;\n      } catch (e) {\n        this.emit(\"notice\", `NIP-57 attempt failed: ${e.message}`);\n      }\n    }\n    if (canFallbackToNip61) {\n      retVal = await nip61Fallback();\n      if (retVal instanceof Error) throw retVal;\n      return retVal;\n    } else {\n      this.emit(\"notice\", \"Zap methods exhausted and there was no fallback to NIP-61\");\n    }\n    if (retVal instanceof Error) throw retVal;\n    return retVal;\n  }\n  /**\n   * Gets a bolt11 for a nip57 zap\n   * @param event\n   * @param amount\n   * @param zapEndpoint\n   * @returns\n   */\n  async getLnInvoice(zapRequest, amount, data) {\n    const zapEndpoint = data.callback;\n    const eventPayload = JSON.stringify(zapRequest.rawEvent());\n    d3(\n      `Fetching invoice from ${zapEndpoint}?` + new URLSearchParams({\n        amount: amount.toString(),\n        nostr: eventPayload\n      })\n    );\n    const url = new URL(zapEndpoint);\n    url.searchParams.append(\"amount\", amount.toString());\n    url.searchParams.append(\"nostr\", eventPayload);\n    d3(`Fetching invoice from ${url.toString()}`);\n    const response = await fetch(url.toString());\n    d3(`Got response from zap endpoint: ${zapEndpoint}`, { status: response.status });\n    if (response.status !== 200) {\n      d3(`Received non-200 status from zap endpoint: ${zapEndpoint}`, {\n        status: response.status,\n        amount,\n        nostr: eventPayload\n      });\n      const text = await response.text();\n      throw new Error(`Unable to fetch zap endpoint ${zapEndpoint}: ${text}`);\n    }\n    const body = await response.json();\n    return body.pr;\n  }\n  getZapSplits() {\n    if (this.target instanceof NDKUser) {\n      return [\n        {\n          pubkey: this.target.pubkey,\n          amount: this.amount\n        }\n      ];\n    }\n    const zapTags = this.target.getMatchingTags(\"zap\");\n    if (zapTags.length === 0) {\n      return [\n        {\n          pubkey: this.target.pubkey,\n          amount: this.amount\n        }\n      ];\n    }\n    const splits = [];\n    const total = zapTags.reduce((acc, tag) => acc + parseInt(tag[2]), 0);\n    for (const tag of zapTags) {\n      const pubkey = tag[1];\n      const amount = Math.floor(parseInt(tag[2]) / total * this.amount);\n      splits.push({ pubkey, amount });\n    }\n    return splits;\n  }\n  /**\n   * Gets the zap method that should be used to zap a pubbkey\n   * @param ndk\n   * @param pubkey\n   * @returns\n   */\n  async getZapMethods(ndk, recipient, timeout = 2500) {\n    const user = ndk.getUser({ pubkey: recipient });\n    return await user.getZapInfo(timeout);\n  }\n  /**\n   * @returns the relays to use for the zap request\n   */\n  async relays(pubkey) {\n    let r = [];\n    if (this.ndk?.activeUser) {\n      const relayLists = await getRelayListForUsers(\n        [this.ndk.activeUser.pubkey, pubkey],\n        this.ndk\n      );\n      const relayScores = /* @__PURE__ */ new Map();\n      for (const relayList of relayLists.values()) {\n        for (const url of relayList.readRelayUrls) {\n          const score = relayScores.get(url) || 0;\n          relayScores.set(url, score + 1);\n        }\n      }\n      r = Array.from(relayScores.entries()).sort((a, b) => b[1] - a[1]).map(([url]) => url).slice(0, this.maxRelays);\n    }\n    if (this.ndk?.pool?.permanentAndConnectedRelays().length) {\n      r = this.ndk.pool.permanentAndConnectedRelays().map((relay) => relay.url);\n    }\n    if (!r.length) {\n      r = [];\n    }\n    return r;\n  }\n};\n\n// src/utils/filter.ts\nfunction matchFilter(filter, event) {\n  if (filter.ids && filter.ids.indexOf(event.id) === -1) {\n    return false;\n  }\n  if (filter.kinds && filter.kinds.indexOf(event.kind) === -1) {\n    return false;\n  }\n  if (filter.authors && filter.authors.indexOf(event.pubkey) === -1) {\n    return false;\n  }\n  for (let f in filter) {\n    if (f[0] === \"#\") {\n      let tagName = f.slice(1);\n      if (tagName === \"t\") {\n        let values = filter[`#${tagName}`]?.map((v) => v.toLowerCase());\n        if (values && !event.tags.find(([t, v]) => t === tagName && values.indexOf(v.toLowerCase()) !== -1)) return false;\n      } else {\n        let values = filter[`#${tagName}`];\n        if (values && !event.tags.find(([t, v]) => t === tagName && values.indexOf(v) !== -1)) return false;\n      }\n    }\n  }\n  if (filter.since && event.created_at < filter.since) return false;\n  if (filter.until && event.created_at > filter.until) return false;\n  return true;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGVBQWU7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUMwQjtBQUNXOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04seUNBQXlDLGtCQUFrQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxrQkFBa0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsR0FBRztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0Esc0NBQXNDLGtCQUFrQixJQUFJLGNBQWM7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNk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QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGlLQUFpSztBQUNqTTtBQUNBO0FBQ0EsOENBQThDLHVCQUF1QjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFVBQVUsSUFBSSxJQUFJO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msd0NBQXdDO0FBQzlFO0FBQ0E7QUFDQSxvQ0FBb0Msd0JBQXdCO0FBQzVE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QUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTixtQkFBbUIsNERBQU07QUFDekIsa0JBQWtCLDREQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDREQUFNO0FBQzFCLFNBQVMsK0RBQVU7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsK0NBQWE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MscUJBQXFCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGFBQWEsSUFBSSxTQUFTO0FBQy9DO0FBQ0E7QUFDQSxzQkFBc0IscUJBQXFCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixxQkFBcUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHlCQUF5QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsd0NBQXdDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixxQkFBcUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELEtBQUs7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QixlQUFlLHFCQUFxQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0IsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQixlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGFBQWE7QUFDbkMsc0JBQXNCLFFBQVE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViwwQ0FBMEMsYUFBYTtBQUN2RDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsdUJBQXVCLEtBQUssR0FBRyxPQUFPO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxrQ0FBTTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRCx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9CQUFvQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGlDQUFpQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsK0NBQWE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxtQ0FBbUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsNEhBQTRIO0FBQzNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSx1Q0FBdUM7QUFDN0MsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsUUFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLCtCQUErQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxrQ0FBTTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixpQkFBaUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsaUJBQWlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsY0FBYztBQUNuRTtBQUNBO0FBQ0Esb0RBQW9ELGNBQWM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQzJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsa0NBQU07QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsaUJBQWlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1DQUFtQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsV0FBVztBQUN2RDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsMkJBQTJCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGFBQWEscUJBQXFCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsYUFBYSxxQkFBcUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Qsb0JBQW9CO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw0REFBTTtBQUMzQixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ2lDO0FBQ3FCOztBQUV0RDtBQUNvQztBQUNwQztBQUNBO0FBQ0EscUJBQXFCLDhDQUFLO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDcUM7QUFDSjtBQUNqQyxTQUFTLGtDQUFZO0FBQ3JCLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixPQUFPLHNCQUFzQixLQUFLO0FBQy9ELElBQUk7QUFDSixZQUFZLFFBQVEsRUFBRSwrQ0FBTTtBQUM1QixpQkFBaUIsK0NBQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsY0FBYztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxZQUFZLElBQUksS0FBSztBQUMzRTtBQUNBO0FBQ0EsSUFBSTtBQUNKLG9EQUFvRCxZQUFZLElBQUksRUFBRTtBQUN0RTtBQUNBOztBQUVBO0FBQ0EsU0FBUyxrQ0FBWTtBQUNyQiw4QkFBOEIsK0NBQWE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGNBQWMsZUFBZTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsc0JBQXNCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1Isc0RBQXNELFVBQVU7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1Isc0RBQXNELFVBQVU7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFlBQVk7QUFDM0M7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxlQUFlO0FBQy9DO0FBQ0EsMENBQTBDLFlBQVksS0FBSyx5QkFBeUI7QUFDcEY7QUFDQSx1REFBdUQsWUFBWTtBQUNuRTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxzREFBc0QsWUFBWSxJQUFJLEtBQUs7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixtQkFBbUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxRQUFRO0FBQ3hDO0FBQ0EsUUFBUTtBQUNSLGdDQUFnQyxRQUFRO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF5R0UiLCJzb3VyY2VzIjpbIi9ob21lL2xmZy9HaXQvTWFkdHJpcHMvbm9kZV9tb2R1bGVzL0Bub3N0ci1kZXYta2l0L25kay9kaXN0L2luZGV4Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvZXZlbnRzL2tpbmRzL2luZGV4LnRzXG52YXIgTkRLS2luZCA9IC8qIEBfX1BVUkVfXyAqLyAoKE5ES0tpbmQyKSA9PiB7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiTWV0YWRhdGFcIl0gPSAwXSA9IFwiTWV0YWRhdGFcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJUZXh0XCJdID0gMV0gPSBcIlRleHRcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJSZWNvbW1lbmRSZWxheVwiXSA9IDJdID0gXCJSZWNvbW1lbmRSZWxheVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkNvbnRhY3RzXCJdID0gM10gPSBcIkNvbnRhY3RzXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiRW5jcnlwdGVkRGlyZWN0TWVzc2FnZVwiXSA9IDRdID0gXCJFbmNyeXB0ZWREaXJlY3RNZXNzYWdlXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiRXZlbnREZWxldGlvblwiXSA9IDVdID0gXCJFdmVudERlbGV0aW9uXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiUmVwb3N0XCJdID0gNl0gPSBcIlJlcG9zdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIlJlYWN0aW9uXCJdID0gN10gPSBcIlJlYWN0aW9uXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQmFkZ2VBd2FyZFwiXSA9IDhdID0gXCJCYWRnZUF3YXJkXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiR3JvdXBDaGF0XCJdID0gOV0gPSBcIkdyb3VwQ2hhdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkdyb3VwTm90ZVwiXSA9IDExXSA9IFwiR3JvdXBOb3RlXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiR3JvdXBSZXBseVwiXSA9IDEyXSA9IFwiR3JvdXBSZXBseVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkdpZnRXcmFwU2VhbFwiXSA9IDEzXSA9IFwiR2lmdFdyYXBTZWFsXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiUHJpdmF0ZURpcmVjdE1lc3NhZ2VcIl0gPSAxNF0gPSBcIlByaXZhdGVEaXJlY3RNZXNzYWdlXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiSW1hZ2VcIl0gPSAyMF0gPSBcIkltYWdlXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiVmFuaXNoXCJdID0gNjJdID0gXCJWYW5pc2hcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJHaWZ0V3JhcFwiXSA9IDEwNTldID0gXCJHaWZ0V3JhcFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkdlbmVyaWNSZXBvc3RcIl0gPSAxNl0gPSBcIkdlbmVyaWNSZXBvc3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJDaGFubmVsQ3JlYXRpb25cIl0gPSA0MF0gPSBcIkNoYW5uZWxDcmVhdGlvblwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkNoYW5uZWxNZXRhZGF0YVwiXSA9IDQxXSA9IFwiQ2hhbm5lbE1ldGFkYXRhXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQ2hhbm5lbE1lc3NhZ2VcIl0gPSA0Ml0gPSBcIkNoYW5uZWxNZXNzYWdlXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQ2hhbm5lbEhpZGVNZXNzYWdlXCJdID0gNDNdID0gXCJDaGFubmVsSGlkZU1lc3NhZ2VcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJDaGFubmVsTXV0ZVVzZXJcIl0gPSA0NF0gPSBcIkNoYW5uZWxNdXRlVXNlclwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkdlbmVyaWNSZXBseVwiXSA9IDExMTFdID0gXCJHZW5lcmljUmVwbHlcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJNZWRpYVwiXSA9IDEwNjNdID0gXCJNZWRpYVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIlJlcG9ydFwiXSA9IDE5ODRdID0gXCJSZXBvcnRcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJMYWJlbFwiXSA9IDE5ODVdID0gXCJMYWJlbFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkRWTVJlcVRleHRFeHRyYWN0aW9uXCJdID0gNWUzXSA9IFwiRFZNUmVxVGV4dEV4dHJhY3Rpb25cIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJEVk1SZXFUZXh0U3VtbWFyaXphdGlvblwiXSA9IDUwMDFdID0gXCJEVk1SZXFUZXh0U3VtbWFyaXphdGlvblwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkRWTVJlcVRleHRUcmFuc2xhdGlvblwiXSA9IDUwMDJdID0gXCJEVk1SZXFUZXh0VHJhbnNsYXRpb25cIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJEVk1SZXFUZXh0R2VuZXJhdGlvblwiXSA9IDUwNTBdID0gXCJEVk1SZXFUZXh0R2VuZXJhdGlvblwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkRWTVJlcUltYWdlR2VuZXJhdGlvblwiXSA9IDUxMDBdID0gXCJEVk1SZXFJbWFnZUdlbmVyYXRpb25cIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJEVk1SZXFUZXh0VG9TcGVlY2hcIl0gPSA1MjUwXSA9IFwiRFZNUmVxVGV4dFRvU3BlZWNoXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiRFZNUmVxRGlzY292ZXJ5Tm9zdHJDb250ZW50XCJdID0gNTMwMF0gPSBcIkRWTVJlcURpc2NvdmVyeU5vc3RyQ29udGVudFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkRWTVJlcURpc2NvdmVyeU5vc3RyUGVvcGxlXCJdID0gNTMwMV0gPSBcIkRWTVJlcURpc2NvdmVyeU5vc3RyUGVvcGxlXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiRFZNUmVxVGltZXN0YW1waW5nXCJdID0gNTkwMF0gPSBcIkRWTVJlcVRpbWVzdGFtcGluZ1wiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkRWTUV2ZW50U2NoZWR1bGVcIl0gPSA1OTA1XSA9IFwiRFZNRXZlbnRTY2hlZHVsZVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkRWTUpvYkZlZWRiYWNrXCJdID0gN2UzXSA9IFwiRFZNSm9iRmVlZGJhY2tcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJTdWJzY3JpYmVcIl0gPSA3MDAxXSA9IFwiU3Vic2NyaWJlXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiVW5zdWJzY3JpYmVcIl0gPSA3MDAyXSA9IFwiVW5zdWJzY3JpYmVcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJTdWJzY3JpcHRpb25SZWNlaXB0XCJdID0gNzAwM10gPSBcIlN1YnNjcmlwdGlvblJlY2VpcHRcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJDYXNodVJlc2VydmVcIl0gPSA3MzczXSA9IFwiQ2FzaHVSZXNlcnZlXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQ2FzaHVRdW90ZVwiXSA9IDczNzRdID0gXCJDYXNodVF1b3RlXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQ2FzaHVUb2tlblwiXSA9IDczNzVdID0gXCJDYXNodVRva2VuXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQ2FzaHVXYWxsZXRUeFwiXSA9IDczNzZdID0gXCJDYXNodVdhbGxldFR4XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiR3JvdXBBZG1pbkFkZFVzZXJcIl0gPSA5ZTNdID0gXCJHcm91cEFkbWluQWRkVXNlclwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkdyb3VwQWRtaW5SZW1vdmVVc2VyXCJdID0gOTAwMV0gPSBcIkdyb3VwQWRtaW5SZW1vdmVVc2VyXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiR3JvdXBBZG1pbkVkaXRNZXRhZGF0YVwiXSA9IDkwMDJdID0gXCJHcm91cEFkbWluRWRpdE1ldGFkYXRhXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiR3JvdXBBZG1pbkVkaXRTdGF0dXNcIl0gPSA5MDA2XSA9IFwiR3JvdXBBZG1pbkVkaXRTdGF0dXNcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJHcm91cEFkbWluQ3JlYXRlR3JvdXBcIl0gPSA5MDA3XSA9IFwiR3JvdXBBZG1pbkNyZWF0ZUdyb3VwXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiR3JvdXBBZG1pblJlcXVlc3RKb2luXCJdID0gOTAyMV0gPSBcIkdyb3VwQWRtaW5SZXF1ZXN0Sm9pblwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIk11dGVMaXN0XCJdID0gMWU0XSA9IFwiTXV0ZUxpc3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJQaW5MaXN0XCJdID0gMTAwMDFdID0gXCJQaW5MaXN0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiUmVsYXlMaXN0XCJdID0gMTAwMDJdID0gXCJSZWxheUxpc3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJCb29rbWFya0xpc3RcIl0gPSAxMDAwM10gPSBcIkJvb2ttYXJrTGlzdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkNvbW11bml0eUxpc3RcIl0gPSAxMDAwNF0gPSBcIkNvbW11bml0eUxpc3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJQdWJsaWNDaGF0TGlzdFwiXSA9IDEwMDA1XSA9IFwiUHVibGljQ2hhdExpc3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJCbG9ja1JlbGF5TGlzdFwiXSA9IDEwMDA2XSA9IFwiQmxvY2tSZWxheUxpc3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJTZWFyY2hSZWxheUxpc3RcIl0gPSAxMDAwN10gPSBcIlNlYXJjaFJlbGF5TGlzdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIlNpbXBsZUdyb3VwTGlzdFwiXSA9IDEwMDA5XSA9IFwiU2ltcGxlR3JvdXBMaXN0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiSW50ZXJlc3RMaXN0XCJdID0gMTAwMTVdID0gXCJJbnRlcmVzdExpc3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJDYXNodU1pbnRMaXN0XCJdID0gMTAwMTldID0gXCJDYXNodU1pbnRMaXN0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiRW1vamlMaXN0XCJdID0gMTAwMzBdID0gXCJFbW9qaUxpc3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJEaXJlY3RNZXNzYWdlUmVjZWl2ZVJlbGF5TGlzdFwiXSA9IDEwMDUwXSA9IFwiRGlyZWN0TWVzc2FnZVJlY2VpdmVSZWxheUxpc3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJCbG9zc29tTGlzdFwiXSA9IDEwMDYzXSA9IFwiQmxvc3NvbUxpc3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJOb3N0cldhbGV0Q29ubmVjdEluZm9cIl0gPSAxMzE5NF0gPSBcIk5vc3RyV2FsZXRDb25uZWN0SW5mb1wiO1xuICBOREtLaW5kMltOREtLaW5kMltcIlRpZXJMaXN0XCJdID0gMTdlM10gPSBcIlRpZXJMaXN0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQ2FzaHVXYWxsZXRcIl0gPSAxNzM3NV0gPSBcIkNhc2h1V2FsbGV0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiRm9sbG93U2V0XCJdID0gM2U0XSA9IFwiRm9sbG93U2V0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQ2F0ZWdvcml6ZWRQZW9wbGVMaXN0XCJdID0gM2U0IC8qIEZvbGxvd1NldCAqL10gPSBcIkNhdGVnb3JpemVkUGVvcGxlTGlzdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkNhdGVnb3JpemVkQm9va21hcmtMaXN0XCJdID0gMzAwMDFdID0gXCJDYXRlZ29yaXplZEJvb2ttYXJrTGlzdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIlJlbGF5U2V0XCJdID0gMzAwMDJdID0gXCJSZWxheVNldFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkNhdGVnb3JpemVkUmVsYXlMaXN0XCJdID0gMzAwMDIgLyogUmVsYXlTZXQgKi9dID0gXCJDYXRlZ29yaXplZFJlbGF5TGlzdFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkJvb2ttYXJrU2V0XCJdID0gMzAwMDNdID0gXCJCb29rbWFya1NldFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkN1cmF0aW9uU2V0XCJdID0gMzAwMDRdID0gXCJDdXJhdGlvblNldFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkFydGljbGVDdXJhdGlvblNldFwiXSA9IDMwMDA0XSA9IFwiQXJ0aWNsZUN1cmF0aW9uU2V0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiVmlkZW9DdXJhdGlvblNldFwiXSA9IDMwMDA1XSA9IFwiVmlkZW9DdXJhdGlvblNldFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkltYWdlQ3VyYXRpb25TZXRcIl0gPSAzMDAwNl0gPSBcIkltYWdlQ3VyYXRpb25TZXRcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJJbnRlcmVzdFNldFwiXSA9IDMwMDE1XSA9IFwiSW50ZXJlc3RTZXRcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJJbnRlcmVzdHNMaXN0XCJdID0gMzAwMTUgLyogSW50ZXJlc3RTZXQgKi9dID0gXCJJbnRlcmVzdHNMaXN0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiRW1vamlTZXRcIl0gPSAzMDAzMF0gPSBcIkVtb2ppU2V0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiTW9kdWxhckFydGljbGVcIl0gPSAzMDA0MF0gPSBcIk1vZHVsYXJBcnRpY2xlXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiTW9kdWxhckFydGljbGVJdGVtXCJdID0gMzAwNDFdID0gXCJNb2R1bGFyQXJ0aWNsZUl0ZW1cIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJXaWtpXCJdID0gMzA4MThdID0gXCJXaWtpXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiRHJhZnRcIl0gPSAzMTIzNF0gPSBcIkRyYWZ0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiU3Vic2NyaXB0aW9uVGllclwiXSA9IDM3MDAxXSA9IFwiU3Vic2NyaXB0aW9uVGllclwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkVjYXNoTWludFJlY29tbWVuZGF0aW9uXCJdID0gMzhlM10gPSBcIkVjYXNoTWludFJlY29tbWVuZGF0aW9uXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiSGlnaGxpZ2h0U2V0XCJdID0gMzk4MDJdID0gXCJIaWdobGlnaHRTZXRcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJDYXRlZ29yaXplZEhpZ2hsaWdodExpc3RcIl0gPSAzOTgwMiAvKiBIaWdobGlnaHRTZXQgKi9dID0gXCJDYXRlZ29yaXplZEhpZ2hsaWdodExpc3RcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJOdXR6YXBcIl0gPSA5MzIxXSA9IFwiTnV0emFwXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiWmFwUmVxdWVzdFwiXSA9IDk3MzRdID0gXCJaYXBSZXF1ZXN0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiWmFwXCJdID0gOTczNV0gPSBcIlphcFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkhpZ2hsaWdodFwiXSA9IDk4MDJdID0gXCJIaWdobGlnaHRcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJDbGllbnRBdXRoXCJdID0gMjIyNDJdID0gXCJDbGllbnRBdXRoXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiTm9zdHJXYWxsZXRDb25uZWN0UmVxXCJdID0gMjMxOTRdID0gXCJOb3N0cldhbGxldENvbm5lY3RSZXFcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJOb3N0cldhbGxldENvbm5lY3RSZXNcIl0gPSAyMzE5NV0gPSBcIk5vc3RyV2FsbGV0Q29ubmVjdFJlc1wiO1xuICBOREtLaW5kMltOREtLaW5kMltcIk5vc3RyQ29ubmVjdFwiXSA9IDI0MTMzXSA9IFwiTm9zdHJDb25uZWN0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQmxvc3NvbVVwbG9hZFwiXSA9IDI0MjQyXSA9IFwiQmxvc3NvbVVwbG9hZFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkh0dHBBdXRoXCJdID0gMjcyMzVdID0gXCJIdHRwQXV0aFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIlByb2ZpbGVCYWRnZVwiXSA9IDMwMDA4XSA9IFwiUHJvZmlsZUJhZGdlXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQmFkZ2VEZWZpbml0aW9uXCJdID0gMzAwMDldID0gXCJCYWRnZURlZmluaXRpb25cIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJNYXJrZXRTdGFsbFwiXSA9IDMwMDE3XSA9IFwiTWFya2V0U3RhbGxcIjtcbiAgTkRLS2luZDJbTkRLS2luZDJbXCJNYXJrZXRQcm9kdWN0XCJdID0gMzAwMThdID0gXCJNYXJrZXRQcm9kdWN0XCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQXJ0aWNsZVwiXSA9IDMwMDIzXSA9IFwiQXJ0aWNsZVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkFwcFNwZWNpZmljRGF0YVwiXSA9IDMwMDc4XSA9IFwiQXBwU3BlY2lmaWNEYXRhXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQ2xhc3NpZmllZFwiXSA9IDMwNDAyXSA9IFwiQ2xhc3NpZmllZFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkhvcml6b250YWxWaWRlb1wiXSA9IDM0MjM1XSA9IFwiSG9yaXpvbnRhbFZpZGVvXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiVmVydGljYWxWaWRlb1wiXSA9IDM0MjM2XSA9IFwiVmVydGljYWxWaWRlb1wiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkxlZ2FjeUNhc2h1V2FsbGV0XCJdID0gMzczNzVdID0gXCJMZWdhY3lDYXNodVdhbGxldFwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkdyb3VwTWV0YWRhdGFcIl0gPSAzOWUzXSA9IFwiR3JvdXBNZXRhZGF0YVwiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkdyb3VwQWRtaW5zXCJdID0gMzkwMDFdID0gXCJHcm91cEFkbWluc1wiO1xuICBOREtLaW5kMltOREtLaW5kMltcIkdyb3VwTWVtYmVyc1wiXSA9IDM5MDAyXSA9IFwiR3JvdXBNZW1iZXJzXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQXBwUmVjb21tZW5kYXRpb25cIl0gPSAzMTk4OV0gPSBcIkFwcFJlY29tbWVuZGF0aW9uXCI7XG4gIE5ES0tpbmQyW05ES0tpbmQyW1wiQXBwSGFuZGxlclwiXSA9IDMxOTkwXSA9IFwiQXBwSGFuZGxlclwiO1xuICByZXR1cm4gTkRLS2luZDI7XG59KShOREtLaW5kIHx8IHt9KTtcbnZhciBOREtMaXN0S2luZHMgPSBbXG4gIDFlNCAvKiBNdXRlTGlzdCAqLyxcbiAgMTAwMDEgLyogUGluTGlzdCAqLyxcbiAgMTAwMDIgLyogUmVsYXlMaXN0ICovLFxuICAxMDAwMyAvKiBCb29rbWFya0xpc3QgKi8sXG4gIDEwMDA0IC8qIENvbW11bml0eUxpc3QgKi8sXG4gIDEwMDA1IC8qIFB1YmxpY0NoYXRMaXN0ICovLFxuICAxMDAwNiAvKiBCbG9ja1JlbGF5TGlzdCAqLyxcbiAgMTAwMDcgLyogU2VhcmNoUmVsYXlMaXN0ICovLFxuICAxMDAxNSAvKiBJbnRlcmVzdExpc3QgKi8sXG4gIDEwMDMwIC8qIEVtb2ppTGlzdCAqLyxcbiAgMTAwNTAgLyogRGlyZWN0TWVzc2FnZVJlY2VpdmVSZWxheUxpc3QgKi8sXG4gIDNlNCAvKiBGb2xsb3dTZXQgKi8sXG4gIDMwMDAzIC8qIEJvb2ttYXJrU2V0ICovLFxuICAzMDAwMSAvKiBDYXRlZ29yaXplZEJvb2ttYXJrTGlzdCAqLyxcbiAgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgMzAwMDIgLyogUmVsYXlTZXQgKi8sXG4gIDMwMDA0IC8qIEFydGljbGVDdXJhdGlvblNldCAqLyxcbiAgMzAwMDUgLyogVmlkZW9DdXJhdGlvblNldCAqLyxcbiAgMzAwMTUgLyogSW50ZXJlc3RTZXQgKi8sXG4gIDMwMDMwIC8qIEVtb2ppU2V0ICovLFxuICAzOTgwMiAvKiBIaWdobGlnaHRTZXQgKi9cbl07XG5cbi8vIHNyYy9ldmVudHMvaW5kZXgudHNcbmltcG9ydCB7IEV2ZW50RW1pdHRlciBhcyBFdmVudEVtaXR0ZXIyIH0gZnJvbSBcInRzZWVwXCI7XG5cbi8vIHNyYy9vdXRib3gvd3JpdGUudHNcbmZ1bmN0aW9uIGdldFJlbGF5c0ZvclN5bmMobmRrLCBhdXRob3IsIHR5cGUgPSBcIndyaXRlXCIpIHtcbiAgaWYgKCFuZGsub3V0Ym94VHJhY2tlcikgcmV0dXJuIHZvaWQgMDtcbiAgY29uc3QgaXRlbSA9IG5kay5vdXRib3hUcmFja2VyLmRhdGEuZ2V0KGF1dGhvcik7XG4gIGlmICghaXRlbSkgcmV0dXJuIHZvaWQgMDtcbiAgaWYgKHR5cGUgPT09IFwid3JpdGVcIikge1xuICAgIHJldHVybiBpdGVtLndyaXRlUmVsYXlzO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBpdGVtLnJlYWRSZWxheXM7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGdldFdyaXRlUmVsYXlzRm9yKG5kaywgYXV0aG9yLCB0eXBlID0gXCJ3cml0ZVwiKSB7XG4gIGlmICghbmRrLm91dGJveFRyYWNrZXIpIHJldHVybiB2b2lkIDA7XG4gIGlmICghbmRrLm91dGJveFRyYWNrZXIuZGF0YS5oYXMoYXV0aG9yKSkge1xuICAgIGF3YWl0IG5kay5vdXRib3hUcmFja2VyLnRyYWNrVXNlcnMoW2F1dGhvcl0pO1xuICB9XG4gIHJldHVybiBnZXRSZWxheXNGb3JTeW5jKG5kaywgYXV0aG9yLCB0eXBlKTtcbn1cblxuLy8gc3JjL291dGJveC9yZWxheS1yYW5raW5nLnRzXG5mdW5jdGlvbiBnZXRUb3BSZWxheXNGb3JBdXRob3JzKG5kaywgYXV0aG9ycykge1xuICBjb25zdCByZWxheXNXaXRoQ291bnQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBhdXRob3JzLmZvckVhY2goKGF1dGhvcikgPT4ge1xuICAgIGNvbnN0IHdyaXRlUmVsYXlzID0gZ2V0UmVsYXlzRm9yU3luYyhuZGssIGF1dGhvcik7XG4gICAgaWYgKHdyaXRlUmVsYXlzKSB7XG4gICAgICB3cml0ZVJlbGF5cy5mb3JFYWNoKChyZWxheSkgPT4ge1xuICAgICAgICBjb25zdCBjb3VudCA9IHJlbGF5c1dpdGhDb3VudC5nZXQocmVsYXkpIHx8IDA7XG4gICAgICAgIHJlbGF5c1dpdGhDb3VudC5zZXQocmVsYXksIGNvdW50ICsgMSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBzb3J0ZWRSZWxheXMgPSBBcnJheS5mcm9tKHJlbGF5c1dpdGhDb3VudC5lbnRyaWVzKCkpLnNvcnQoKGEsIGIpID0+IGJbMV0gLSBhWzFdKTtcbiAgcmV0dXJuIHNvcnRlZFJlbGF5cy5tYXAoKGVudHJ5KSA9PiBlbnRyeVswXSk7XG59XG5cbi8vIHNyYy9vdXRib3gvaW5kZXgudHNcbmZ1bmN0aW9uIGdldEFsbFJlbGF5c0ZvckFsbFB1YmtleXMobmRrLCBwdWJrZXlzLCB0eXBlID0gXCJyZWFkXCIpIHtcbiAgY29uc3QgcHVia2V5c1RvUmVsYXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgYXV0aG9yc01pc3NpbmdSZWxheXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBwdWJrZXlzLmZvckVhY2goKHB1YmtleSkgPT4ge1xuICAgIGNvbnN0IHJlbGF5cyA9IGdldFJlbGF5c0ZvclN5bmMobmRrLCBwdWJrZXksIHR5cGUpO1xuICAgIGlmIChyZWxheXMgJiYgcmVsYXlzLnNpemUgPiAwKSB7XG4gICAgICByZWxheXMuZm9yRWFjaCgocmVsYXkpID0+IHtcbiAgICAgICAgY29uc3QgcHVia2V5c0luUmVsYXkgPSBwdWJrZXlzVG9SZWxheXMuZ2V0KHJlbGF5KSB8fCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgICBwdWJrZXlzSW5SZWxheS5hZGQocHVia2V5KTtcbiAgICAgIH0pO1xuICAgICAgcHVia2V5c1RvUmVsYXlzLnNldChwdWJrZXksIHJlbGF5cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF1dGhvcnNNaXNzaW5nUmVsYXlzLmFkZChwdWJrZXkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB7IHB1YmtleXNUb1JlbGF5cywgYXV0aG9yc01pc3NpbmdSZWxheXMgfTtcbn1cbmZ1bmN0aW9uIGNob29zZVJlbGF5Q29tYmluYXRpb25Gb3JQdWJrZXlzKG5kaywgcHVia2V5cywgdHlwZSwgeyBjb3VudCwgcHJlZmVycmVkUmVsYXlzIH0gPSB7fSkge1xuICBjb3VudCA/Pz0gMjtcbiAgcHJlZmVycmVkUmVsYXlzID8/PSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBjb25zdCBwb29sID0gbmRrLnBvb2w7XG4gIGNvbnN0IGNvbm5lY3RlZFJlbGF5cyA9IHBvb2wuY29ubmVjdGVkUmVsYXlzKCk7XG4gIGNvbm5lY3RlZFJlbGF5cy5mb3JFYWNoKChyZWxheSkgPT4ge1xuICAgIHByZWZlcnJlZFJlbGF5cy5hZGQocmVsYXkudXJsKTtcbiAgfSk7XG4gIGNvbnN0IHJlbGF5VG9BdXRob3JzTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgeyBwdWJrZXlzVG9SZWxheXMsIGF1dGhvcnNNaXNzaW5nUmVsYXlzIH0gPSBnZXRBbGxSZWxheXNGb3JBbGxQdWJrZXlzKG5kaywgcHVia2V5cywgdHlwZSk7XG4gIGNvbnN0IHNvcnRlZFJlbGF5cyA9IGdldFRvcFJlbGF5c0ZvckF1dGhvcnMobmRrLCBwdWJrZXlzKTtcbiAgY29uc3QgYWRkQXV0aG9yVG9SZWxheSA9IChhdXRob3IsIHJlbGF5KSA9PiB7XG4gICAgY29uc3QgYXV0aG9yc0luUmVsYXkgPSByZWxheVRvQXV0aG9yc01hcC5nZXQocmVsYXkpIHx8IFtdO1xuICAgIGF1dGhvcnNJblJlbGF5LnB1c2goYXV0aG9yKTtcbiAgICByZWxheVRvQXV0aG9yc01hcC5zZXQocmVsYXksIGF1dGhvcnNJblJlbGF5KTtcbiAgfTtcbiAgZm9yIChjb25zdCBbYXV0aG9yLCBhdXRob3JSZWxheXNdIG9mIHB1YmtleXNUb1JlbGF5cy5lbnRyaWVzKCkpIHtcbiAgICBsZXQgbWlzc2luZ1JlbGF5Q291bnQgPSBjb3VudDtcbiAgICBmb3IgKGNvbnN0IHJlbGF5IG9mIGNvbm5lY3RlZFJlbGF5cykge1xuICAgICAgaWYgKGF1dGhvclJlbGF5cy5oYXMocmVsYXkudXJsKSkge1xuICAgICAgICBhZGRBdXRob3JUb1JlbGF5KGF1dGhvciwgcmVsYXkudXJsKTtcbiAgICAgICAgbWlzc2luZ1JlbGF5Q291bnQtLTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBhdXRob3JSZWxheSBvZiBhdXRob3JSZWxheXMpIHtcbiAgICAgIGlmIChyZWxheVRvQXV0aG9yc01hcC5oYXMoYXV0aG9yUmVsYXkpKSB7XG4gICAgICAgIGFkZEF1dGhvclRvUmVsYXkoYXV0aG9yLCBhdXRob3JSZWxheSk7XG4gICAgICAgIG1pc3NpbmdSZWxheUNvdW50LS07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtaXNzaW5nUmVsYXlDb3VudCA8PSAwKSBjb250aW51ZTtcbiAgICBmb3IgKGNvbnN0IHJlbGF5IG9mIHNvcnRlZFJlbGF5cykge1xuICAgICAgaWYgKG1pc3NpbmdSZWxheUNvdW50IDw9IDApIGJyZWFrO1xuICAgICAgaWYgKGF1dGhvclJlbGF5cy5oYXMocmVsYXkpKSB7XG4gICAgICAgIGFkZEF1dGhvclRvUmVsYXkoYXV0aG9yLCByZWxheSk7XG4gICAgICAgIG1pc3NpbmdSZWxheUNvdW50LS07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3QgYXV0aG9yIG9mIGF1dGhvcnNNaXNzaW5nUmVsYXlzKSB7XG4gICAgcG9vbC5wZXJtYW5lbnRBbmRDb25uZWN0ZWRSZWxheXMoKS5mb3JFYWNoKChyZWxheSkgPT4ge1xuICAgICAgY29uc3QgYXV0aG9yc0luUmVsYXkgPSByZWxheVRvQXV0aG9yc01hcC5nZXQocmVsYXkudXJsKSB8fCBbXTtcbiAgICAgIGF1dGhvcnNJblJlbGF5LnB1c2goYXV0aG9yKTtcbiAgICAgIHJlbGF5VG9BdXRob3JzTWFwLnNldChyZWxheS51cmwsIGF1dGhvcnNJblJlbGF5KTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVsYXlUb0F1dGhvcnNNYXA7XG59XG5cbi8vIHNyYy9vdXRib3gvcmVhZC93aXRoLWF1dGhvcnMudHNcbmZ1bmN0aW9uIGdldFJlbGF5c0ZvckZpbHRlcldpdGhBdXRob3JzKG5kaywgYXV0aG9ycywgcmVsYXlHb2FsUGVyQXV0aG9yID0gMikge1xuICByZXR1cm4gY2hvb3NlUmVsYXlDb21iaW5hdGlvbkZvclB1YmtleXMobmRrLCBhdXRob3JzLCBcIndyaXRlXCIsIHsgY291bnQ6IHJlbGF5R29hbFBlckF1dGhvciB9KTtcbn1cblxuLy8gc3JjL3V0aWxzL25vcm1hbGl6ZS11cmwudHNcbmZ1bmN0aW9uIHRyeU5vcm1hbGl6ZVJlbGF5VXJsKHVybCkge1xuICB0cnkge1xuICAgIHJldHVybiBub3JtYWxpemVSZWxheVVybCh1cmwpO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG59XG5mdW5jdGlvbiBub3JtYWxpemVSZWxheVVybCh1cmwpIHtcbiAgbGV0IHIgPSBub3JtYWxpemVVcmwodXJsLCB7XG4gICAgc3RyaXBBdXRoZW50aWNhdGlvbjogZmFsc2UsXG4gICAgc3RyaXBXV1c6IGZhbHNlLFxuICAgIHN0cmlwSGFzaDogdHJ1ZVxuICB9KTtcbiAgaWYgKCFyLmVuZHNXaXRoKFwiL1wiKSkge1xuICAgIHIgKz0gXCIvXCI7XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiBub3JtYWxpemUodXJscykge1xuICBjb25zdCBub3JtYWxpemVkID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgZm9yIChjb25zdCB1cmwgb2YgdXJscykge1xuICAgIHRyeSB7XG4gICAgICBub3JtYWxpemVkLmFkZChub3JtYWxpemVSZWxheVVybCh1cmwpKTtcbiAgICB9IGNhdGNoIHtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIEFycmF5LmZyb20obm9ybWFsaXplZCk7XG59XG52YXIgREFUQV9VUkxfREVGQVVMVF9NSU1FX1RZUEUgPSBcInRleHQvcGxhaW5cIjtcbnZhciBEQVRBX1VSTF9ERUZBVUxUX0NIQVJTRVQgPSBcInVzLWFzY2lpXCI7XG52YXIgdGVzdFBhcmFtZXRlciA9IChuYW1lLCBmaWx0ZXJzKSA9PiBmaWx0ZXJzLnNvbWUoKGZpbHRlcikgPT4gZmlsdGVyIGluc3RhbmNlb2YgUmVnRXhwID8gZmlsdGVyLnRlc3QobmFtZSkgOiBmaWx0ZXIgPT09IG5hbWUpO1xudmFyIHN1cHBvcnRlZFByb3RvY29scyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcImh0dHBzOlwiLCBcImh0dHA6XCIsIFwiZmlsZTpcIl0pO1xudmFyIGhhc0N1c3RvbVByb3RvY29sID0gKHVybFN0cmluZykgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHsgcHJvdG9jb2wgfSA9IG5ldyBVUkwodXJsU3RyaW5nKTtcbiAgICByZXR1cm4gcHJvdG9jb2wuZW5kc1dpdGgoXCI6XCIpICYmICFwcm90b2NvbC5pbmNsdWRlcyhcIi5cIikgJiYgIXN1cHBvcnRlZFByb3RvY29scy5oYXMocHJvdG9jb2wpO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG52YXIgbm9ybWFsaXplRGF0YVVSTCA9ICh1cmxTdHJpbmcsIHsgc3RyaXBIYXNoIH0pID0+IHtcbiAgY29uc3QgbWF0Y2ggPSAvXmRhdGE6KD88dHlwZT5bXixdKj8pLCg/PGRhdGE+W14jXSo/KSg/OiMoPzxoYXNoPi4qKSk/JC8uZXhlYyh1cmxTdHJpbmcpO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIFVSTDogJHt1cmxTdHJpbmd9YCk7XG4gIH1cbiAgbGV0IHR5cGUgPSBtYXRjaC5ncm91cHM/LnR5cGUgPz8gXCJcIjtcbiAgbGV0IGRhdGEgPSBtYXRjaC5ncm91cHM/LmRhdGEgPz8gXCJcIjtcbiAgbGV0IGhhc2ggPSBtYXRjaC5ncm91cHM/Lmhhc2ggPz8gXCJcIjtcbiAgY29uc3QgbWVkaWFUeXBlID0gdHlwZS5zcGxpdChcIjtcIik7XG4gIGhhc2ggPSBzdHJpcEhhc2ggPyBcIlwiIDogaGFzaDtcbiAgbGV0IGlzQmFzZTY0ID0gZmFsc2U7XG4gIGlmIChtZWRpYVR5cGVbbWVkaWFUeXBlLmxlbmd0aCAtIDFdID09PSBcImJhc2U2NFwiKSB7XG4gICAgbWVkaWFUeXBlLnBvcCgpO1xuICAgIGlzQmFzZTY0ID0gdHJ1ZTtcbiAgfVxuICBjb25zdCBtaW1lVHlwZSA9IG1lZGlhVHlwZS5zaGlmdCgpPy50b0xvd2VyQ2FzZSgpID8/IFwiXCI7XG4gIGNvbnN0IGF0dHJpYnV0ZXMgPSBtZWRpYVR5cGUubWFwKChhdHRyaWJ1dGUpID0+IHtcbiAgICBsZXQgW2tleSwgdmFsdWUgPSBcIlwiXSA9IGF0dHJpYnV0ZS5zcGxpdChcIj1cIikubWFwKChzdHJpbmcpID0+IHN0cmluZy50cmltKCkpO1xuICAgIGlmIChrZXkgPT09IFwiY2hhcnNldFwiKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAodmFsdWUgPT09IERBVEFfVVJMX0RFRkFVTFRfQ0hBUlNFVCkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGAke2tleX0ke3ZhbHVlID8gYD0ke3ZhbHVlfWAgOiBcIlwifWA7XG4gIH0pLmZpbHRlcihCb29sZWFuKTtcbiAgY29uc3Qgbm9ybWFsaXplZE1lZGlhVHlwZSA9IFsuLi5hdHRyaWJ1dGVzXTtcbiAgaWYgKGlzQmFzZTY0KSB7XG4gICAgbm9ybWFsaXplZE1lZGlhVHlwZS5wdXNoKFwiYmFzZTY0XCIpO1xuICB9XG4gIGlmIChub3JtYWxpemVkTWVkaWFUeXBlLmxlbmd0aCA+IDAgfHwgbWltZVR5cGUgJiYgbWltZVR5cGUgIT09IERBVEFfVVJMX0RFRkFVTFRfTUlNRV9UWVBFKSB7XG4gICAgbm9ybWFsaXplZE1lZGlhVHlwZS51bnNoaWZ0KG1pbWVUeXBlKTtcbiAgfVxuICByZXR1cm4gYGRhdGE6JHtub3JtYWxpemVkTWVkaWFUeXBlLmpvaW4oXCI7XCIpfSwke2lzQmFzZTY0ID8gZGF0YS50cmltKCkgOiBkYXRhfSR7aGFzaCA/IGAjJHtoYXNofWAgOiBcIlwifWA7XG59O1xuZnVuY3Rpb24gbm9ybWFsaXplVXJsKHVybFN0cmluZywgb3B0aW9ucyA9IHt9KSB7XG4gIG9wdGlvbnMgPSB7XG4gICAgZGVmYXVsdFByb3RvY29sOiBcImh0dHBcIixcbiAgICBub3JtYWxpemVQcm90b2NvbDogdHJ1ZSxcbiAgICBmb3JjZUh0dHA6IGZhbHNlLFxuICAgIGZvcmNlSHR0cHM6IGZhbHNlLFxuICAgIHN0cmlwQXV0aGVudGljYXRpb246IHRydWUsXG4gICAgc3RyaXBIYXNoOiBmYWxzZSxcbiAgICBzdHJpcFRleHRGcmFnbWVudDogdHJ1ZSxcbiAgICBzdHJpcFdXVzogdHJ1ZSxcbiAgICByZW1vdmVRdWVyeVBhcmFtZXRlcnM6IFsvXnV0bV9cXHcrL2ldLFxuICAgIHJlbW92ZVRyYWlsaW5nU2xhc2g6IHRydWUsXG4gICAgcmVtb3ZlU2luZ2xlU2xhc2g6IHRydWUsXG4gICAgcmVtb3ZlRGlyZWN0b3J5SW5kZXg6IGZhbHNlLFxuICAgIHJlbW92ZUV4cGxpY2l0UG9ydDogZmFsc2UsXG4gICAgc29ydFF1ZXJ5UGFyYW1ldGVyczogdHJ1ZSxcbiAgICAuLi5vcHRpb25zXG4gIH07XG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5kZWZhdWx0UHJvdG9jb2wgPT09IFwic3RyaW5nXCIgJiYgIW9wdGlvbnMuZGVmYXVsdFByb3RvY29sLmVuZHNXaXRoKFwiOlwiKSkge1xuICAgIG9wdGlvbnMuZGVmYXVsdFByb3RvY29sID0gYCR7b3B0aW9ucy5kZWZhdWx0UHJvdG9jb2x9OmA7XG4gIH1cbiAgdXJsU3RyaW5nID0gdXJsU3RyaW5nLnRyaW0oKTtcbiAgaWYgKC9eZGF0YTovaS50ZXN0KHVybFN0cmluZykpIHtcbiAgICByZXR1cm4gbm9ybWFsaXplRGF0YVVSTCh1cmxTdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIGlmIChoYXNDdXN0b21Qcm90b2NvbCh1cmxTdHJpbmcpKSB7XG4gICAgcmV0dXJuIHVybFN0cmluZztcbiAgfVxuICBjb25zdCBoYXNSZWxhdGl2ZVByb3RvY29sID0gdXJsU3RyaW5nLnN0YXJ0c1dpdGgoXCIvL1wiKTtcbiAgY29uc3QgaXNSZWxhdGl2ZVVybCA9ICFoYXNSZWxhdGl2ZVByb3RvY29sICYmIC9eXFwuKlxcLy8udGVzdCh1cmxTdHJpbmcpO1xuICBpZiAoIWlzUmVsYXRpdmVVcmwpIHtcbiAgICB1cmxTdHJpbmcgPSB1cmxTdHJpbmcucmVwbGFjZSgvXig/ISg/Olxcdys6KT9cXC9cXC8pfF5cXC9cXC8vLCBvcHRpb25zLmRlZmF1bHRQcm90b2NvbCk7XG4gIH1cbiAgY29uc3QgdXJsT2JqZWN0ID0gbmV3IFVSTCh1cmxTdHJpbmcpO1xuICB1cmxPYmplY3QuaG9zdG5hbWUgPSB1cmxPYmplY3QuaG9zdG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgaWYgKG9wdGlvbnMuZm9yY2VIdHRwICYmIG9wdGlvbnMuZm9yY2VIdHRwcykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBgZm9yY2VIdHRwYCBhbmQgYGZvcmNlSHR0cHNgIG9wdGlvbnMgY2Fubm90IGJlIHVzZWQgdG9nZXRoZXJcIik7XG4gIH1cbiAgaWYgKG9wdGlvbnMuZm9yY2VIdHRwICYmIHVybE9iamVjdC5wcm90b2NvbCA9PT0gXCJodHRwczpcIikge1xuICAgIHVybE9iamVjdC5wcm90b2NvbCA9IFwiaHR0cDpcIjtcbiAgfVxuICBpZiAob3B0aW9ucy5mb3JjZUh0dHBzICYmIHVybE9iamVjdC5wcm90b2NvbCA9PT0gXCJodHRwOlwiKSB7XG4gICAgdXJsT2JqZWN0LnByb3RvY29sID0gXCJodHRwczpcIjtcbiAgfVxuICBpZiAob3B0aW9ucy5zdHJpcEF1dGhlbnRpY2F0aW9uKSB7XG4gICAgdXJsT2JqZWN0LnVzZXJuYW1lID0gXCJcIjtcbiAgICB1cmxPYmplY3QucGFzc3dvcmQgPSBcIlwiO1xuICB9XG4gIGlmIChvcHRpb25zLnN0cmlwSGFzaCkge1xuICAgIHVybE9iamVjdC5oYXNoID0gXCJcIjtcbiAgfSBlbHNlIGlmIChvcHRpb25zLnN0cmlwVGV4dEZyYWdtZW50KSB7XG4gICAgdXJsT2JqZWN0Lmhhc2ggPSB1cmxPYmplY3QuaGFzaC5yZXBsYWNlKC8jPzp+OnRleHQuKj8kL2ksIFwiXCIpO1xuICB9XG4gIGlmICh1cmxPYmplY3QucGF0aG5hbWUpIHtcbiAgICBjb25zdCBwcm90b2NvbFJlZ2V4ID0gL1xcYlthLXpdW2EtelxcZCtcXC0uXXsxLDUwfTpcXC9cXC8vZztcbiAgICBsZXQgbGFzdEluZGV4ID0gMDtcbiAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICBmb3IgKDsgOyApIHtcbiAgICAgIGNvbnN0IG1hdGNoID0gcHJvdG9jb2xSZWdleC5leGVjKHVybE9iamVjdC5wYXRobmFtZSk7XG4gICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY29uc3QgcHJvdG9jb2wgPSBtYXRjaFswXTtcbiAgICAgIGNvbnN0IHByb3RvY29sQXRJbmRleCA9IG1hdGNoLmluZGV4O1xuICAgICAgY29uc3QgaW50ZXJtZWRpYXRlID0gdXJsT2JqZWN0LnBhdGhuYW1lLnNsaWNlKGxhc3RJbmRleCwgcHJvdG9jb2xBdEluZGV4KTtcbiAgICAgIHJlc3VsdCArPSBpbnRlcm1lZGlhdGUucmVwbGFjZSgvXFwvezIsfS9nLCBcIi9cIik7XG4gICAgICByZXN1bHQgKz0gcHJvdG9jb2w7XG4gICAgICBsYXN0SW5kZXggPSBwcm90b2NvbEF0SW5kZXggKyBwcm90b2NvbC5sZW5ndGg7XG4gICAgfVxuICAgIGNvbnN0IHJlbW5hbnQgPSB1cmxPYmplY3QucGF0aG5hbWUuc2xpY2UobGFzdEluZGV4LCB1cmxPYmplY3QucGF0aG5hbWUubGVuZ3RoKTtcbiAgICByZXN1bHQgKz0gcmVtbmFudC5yZXBsYWNlKC9cXC97Mix9L2csIFwiL1wiKTtcbiAgICB1cmxPYmplY3QucGF0aG5hbWUgPSByZXN1bHQ7XG4gIH1cbiAgaWYgKHVybE9iamVjdC5wYXRobmFtZSkge1xuICAgIHRyeSB7XG4gICAgICB1cmxPYmplY3QucGF0aG5hbWUgPSBkZWNvZGVVUkkodXJsT2JqZWN0LnBhdGhuYW1lKTtcbiAgICB9IGNhdGNoIHtcbiAgICB9XG4gIH1cbiAgaWYgKG9wdGlvbnMucmVtb3ZlRGlyZWN0b3J5SW5kZXggPT09IHRydWUpIHtcbiAgICBvcHRpb25zLnJlbW92ZURpcmVjdG9yeUluZGV4ID0gWy9eaW5kZXhcXC5bYS16XSskL107XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5yZW1vdmVEaXJlY3RvcnlJbmRleCkgJiYgb3B0aW9ucy5yZW1vdmVEaXJlY3RvcnlJbmRleC5sZW5ndGggPiAwKSB7XG4gICAgbGV0IHBhdGhDb21wb25lbnRzID0gdXJsT2JqZWN0LnBhdGhuYW1lLnNwbGl0KFwiL1wiKTtcbiAgICBjb25zdCBsYXN0Q29tcG9uZW50ID0gcGF0aENvbXBvbmVudHNbcGF0aENvbXBvbmVudHMubGVuZ3RoIC0gMV07XG4gICAgaWYgKHRlc3RQYXJhbWV0ZXIobGFzdENvbXBvbmVudCwgb3B0aW9ucy5yZW1vdmVEaXJlY3RvcnlJbmRleCkpIHtcbiAgICAgIHBhdGhDb21wb25lbnRzID0gcGF0aENvbXBvbmVudHMuc2xpY2UoMCwgLTEpO1xuICAgICAgdXJsT2JqZWN0LnBhdGhuYW1lID0gcGF0aENvbXBvbmVudHMuc2xpY2UoMSkuam9pbihcIi9cIikgKyBcIi9cIjtcbiAgICB9XG4gIH1cbiAgaWYgKHVybE9iamVjdC5ob3N0bmFtZSkge1xuICAgIHVybE9iamVjdC5ob3N0bmFtZSA9IHVybE9iamVjdC5ob3N0bmFtZS5yZXBsYWNlKC9cXC4kLywgXCJcIik7XG4gICAgaWYgKG9wdGlvbnMuc3RyaXBXV1cgJiYgL153d3dcXC4oPyF3d3dcXC4pW2EtelxcLVxcZF17MSw2M31cXC5bYS16LlxcLVxcZF17Miw2M30kLy50ZXN0KHVybE9iamVjdC5ob3N0bmFtZSkpIHtcbiAgICAgIHVybE9iamVjdC5ob3N0bmFtZSA9IHVybE9iamVjdC5ob3N0bmFtZS5yZXBsYWNlKC9ed3d3XFwuLywgXCJcIik7XG4gICAgfVxuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMucmVtb3ZlUXVlcnlQYXJhbWV0ZXJzKSkge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIFsuLi51cmxPYmplY3Quc2VhcmNoUGFyYW1zLmtleXMoKV0pIHtcbiAgICAgIGlmICh0ZXN0UGFyYW1ldGVyKGtleSwgb3B0aW9ucy5yZW1vdmVRdWVyeVBhcmFtZXRlcnMpKSB7XG4gICAgICAgIHVybE9iamVjdC5zZWFyY2hQYXJhbXMuZGVsZXRlKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghQXJyYXkuaXNBcnJheShvcHRpb25zLmtlZXBRdWVyeVBhcmFtZXRlcnMpICYmIG9wdGlvbnMucmVtb3ZlUXVlcnlQYXJhbWV0ZXJzID09PSB0cnVlKSB7XG4gICAgdXJsT2JqZWN0LnNlYXJjaCA9IFwiXCI7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5rZWVwUXVlcnlQYXJhbWV0ZXJzKSAmJiBvcHRpb25zLmtlZXBRdWVyeVBhcmFtZXRlcnMubGVuZ3RoID4gMCkge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIFsuLi51cmxPYmplY3Quc2VhcmNoUGFyYW1zLmtleXMoKV0pIHtcbiAgICAgIGlmICghdGVzdFBhcmFtZXRlcihrZXksIG9wdGlvbnMua2VlcFF1ZXJ5UGFyYW1ldGVycykpIHtcbiAgICAgICAgdXJsT2JqZWN0LnNlYXJjaFBhcmFtcy5kZWxldGUoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKG9wdGlvbnMuc29ydFF1ZXJ5UGFyYW1ldGVycykge1xuICAgIHVybE9iamVjdC5zZWFyY2hQYXJhbXMuc29ydCgpO1xuICAgIHRyeSB7XG4gICAgICB1cmxPYmplY3Quc2VhcmNoID0gZGVjb2RlVVJJQ29tcG9uZW50KHVybE9iamVjdC5zZWFyY2gpO1xuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgfVxuICBpZiAob3B0aW9ucy5yZW1vdmVUcmFpbGluZ1NsYXNoKSB7XG4gICAgdXJsT2JqZWN0LnBhdGhuYW1lID0gdXJsT2JqZWN0LnBhdGhuYW1lLnJlcGxhY2UoL1xcLyQvLCBcIlwiKTtcbiAgfVxuICBpZiAob3B0aW9ucy5yZW1vdmVFeHBsaWNpdFBvcnQgJiYgdXJsT2JqZWN0LnBvcnQpIHtcbiAgICB1cmxPYmplY3QucG9ydCA9IFwiXCI7XG4gIH1cbiAgY29uc3Qgb2xkVXJsU3RyaW5nID0gdXJsU3RyaW5nO1xuICB1cmxTdHJpbmcgPSB1cmxPYmplY3QudG9TdHJpbmcoKTtcbiAgaWYgKCFvcHRpb25zLnJlbW92ZVNpbmdsZVNsYXNoICYmIHVybE9iamVjdC5wYXRobmFtZSA9PT0gXCIvXCIgJiYgIW9sZFVybFN0cmluZy5lbmRzV2l0aChcIi9cIikgJiYgdXJsT2JqZWN0Lmhhc2ggPT09IFwiXCIpIHtcbiAgICB1cmxTdHJpbmcgPSB1cmxTdHJpbmcucmVwbGFjZSgvXFwvJC8sIFwiXCIpO1xuICB9XG4gIGlmICgob3B0aW9ucy5yZW1vdmVUcmFpbGluZ1NsYXNoIHx8IHVybE9iamVjdC5wYXRobmFtZSA9PT0gXCIvXCIpICYmIHVybE9iamVjdC5oYXNoID09PSBcIlwiICYmIG9wdGlvbnMucmVtb3ZlU2luZ2xlU2xhc2gpIHtcbiAgICB1cmxTdHJpbmcgPSB1cmxTdHJpbmcucmVwbGFjZSgvXFwvJC8sIFwiXCIpO1xuICB9XG4gIGlmIChoYXNSZWxhdGl2ZVByb3RvY29sICYmICFvcHRpb25zLm5vcm1hbGl6ZVByb3RvY29sKSB7XG4gICAgdXJsU3RyaW5nID0gdXJsU3RyaW5nLnJlcGxhY2UoL15odHRwOlxcL1xcLy8sIFwiLy9cIik7XG4gIH1cbiAgaWYgKG9wdGlvbnMuc3RyaXBQcm90b2NvbCkge1xuICAgIHVybFN0cmluZyA9IHVybFN0cmluZy5yZXBsYWNlKC9eKD86aHR0cHM/Oik/XFwvXFwvLywgXCJcIik7XG4gIH1cbiAgcmV0dXJuIHVybFN0cmluZztcbn1cblxuLy8gc3JjL3JlbGF5L2luZGV4LnRzXG5pbXBvcnQgZGVidWcgZnJvbSBcImRlYnVnXCI7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tIFwidHNlZXBcIjtcblxuLy8gc3JjL3JlbGF5L2Nvbm5lY3Rpdml0eS50c1xudmFyIE1BWF9SRUNPTk5FQ1RfQVRURU1QVFMgPSA1O1xudmFyIEZMQVBQSU5HX1RIUkVTSE9MRF9NUyA9IDFlMztcbnZhciBOREtSZWxheUNvbm5lY3Rpdml0eSA9IGNsYXNzIHtcbiAgbmRrUmVsYXk7XG4gIHdzO1xuICBfc3RhdHVzO1xuICB0aW1lb3V0TXM7XG4gIGNvbm5lY3RlZEF0O1xuICBfY29ubmVjdGlvblN0YXRzID0ge1xuICAgIGF0dGVtcHRzOiAwLFxuICAgIHN1Y2Nlc3M6IDAsXG4gICAgZHVyYXRpb25zOiBbXVxuICB9O1xuICBkZWJ1ZztcbiAgbmV0RGVidWc7XG4gIGNvbm5lY3RUaW1lb3V0O1xuICByZWNvbm5lY3RUaW1lb3V0O1xuICBuZGs7XG4gIG9wZW5TdWJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgb3BlbkNvdW50UmVxdWVzdHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBvcGVuRXZlbnRQdWJsaXNoZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBzZXJpYWwgPSAwO1xuICBiYXNlRW9zZVRpbWVvdXQgPSA0NDAwO1xuICBjb25zdHJ1Y3RvcihuZGtSZWxheSwgbmRrKSB7XG4gICAgdGhpcy5uZGtSZWxheSA9IG5ka1JlbGF5O1xuICAgIHRoaXMuX3N0YXR1cyA9IDEgLyogRElTQ09OTkVDVEVEICovO1xuICAgIGNvbnN0IHJhbmQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxZTMpO1xuICAgIHRoaXMuZGVidWcgPSB0aGlzLm5ka1JlbGF5LmRlYnVnLmV4dGVuZChcImNvbm5lY3Rpdml0eVwiICsgcmFuZCk7XG4gICAgdGhpcy5uZGsgPSBuZGs7XG4gIH1cbiAgLyoqXG4gICAqIENvbm5lY3RzIHRvIHRoZSBOREsgcmVsYXkgYW5kIGhhbmRsZXMgdGhlIGNvbm5lY3Rpb24gbGlmZWN5Y2xlLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBhdHRlbXB0cyB0byBlc3RhYmxpc2ggYSBXZWJTb2NrZXQgY29ubmVjdGlvbiB0byB0aGUgTkRLIHJlbGF5IHNwZWNpZmllZCBpbiB0aGUgYG5ka1JlbGF5YCBvYmplY3QuXG4gICAqIElmIHRoZSBjb25uZWN0aW9uIGlzIHN1Y2Nlc3NmdWwsIGl0IHVwZGF0ZXMgdGhlIGNvbm5lY3Rpb24gc3RhdGlzdGljcywgc2V0cyB0aGUgY29ubmVjdGlvbiBzdGF0dXMgdG8gYENPTk5FQ1RFRGAsXG4gICAqIGFuZCBlbWl0cyBgY29ubmVjdGAgYW5kIGByZWFkeWAgZXZlbnRzIG9uIHRoZSBgbmRrUmVsYXlgIG9iamVjdC5cbiAgICpcbiAgICogSWYgdGhlIGNvbm5lY3Rpb24gYXR0ZW1wdCBmYWlscywgaXQgaGFuZGxlcyB0aGUgZXJyb3IgYnkgZWl0aGVyIGluaXRpYXRpbmcgYSByZWNvbm5lY3Rpb24gYXR0ZW1wdCBvciBlbWl0dGluZyBhXG4gICAqIGBkZWxheWVkLWNvbm5lY3RgIGV2ZW50IG9uIHRoZSBgbmRrUmVsYXlgIG9iamVjdCwgZGVwZW5kaW5nIG9uIHRoZSBgcmVjb25uZWN0YCBwYXJhbWV0ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB0aW1lb3V0TXMgLSBUaGUgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgZm9yIHRoZSBjb25uZWN0aW9uIGF0dGVtcHQuIElmIG5vdCBwcm92aWRlZCwgdGhlIGRlZmF1bHQgdGltZW91dCBmcm9tIHRoZSBgbmRrUmVsYXlgIG9iamVjdCBpcyB1c2VkLlxuICAgKiBAcGFyYW0gcmVjb25uZWN0IC0gSW5kaWNhdGVzIHdoZXRoZXIgYSByZWNvbm5lY3Rpb24gc2hvdWxkIGJlIGF0dGVtcHRlZCBpZiB0aGUgY29ubmVjdGlvbiBmYWlscy4gRGVmYXVsdHMgdG8gYHRydWVgLlxuICAgKiBAcmV0dXJucyBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBjb25uZWN0aW9uIGlzIGVzdGFibGlzaGVkLCBvciByZWplY3RzIGlmIHRoZSBjb25uZWN0aW9uIGZhaWxzLlxuICAgKi9cbiAgYXN5bmMgY29ubmVjdCh0aW1lb3V0TXMsIHJlY29ubmVjdCA9IHRydWUpIHtcbiAgICBpZiAodGhpcy5fc3RhdHVzICE9PSAyIC8qIFJFQ09OTkVDVElORyAqLyAmJiB0aGlzLl9zdGF0dXMgIT09IDEgLyogRElTQ09OTkVDVEVEICovIHx8IHRoaXMucmVjb25uZWN0VGltZW91dCkge1xuICAgICAgdGhpcy5kZWJ1ZyhcbiAgICAgICAgXCJSZWxheSByZXF1ZXN0ZWQgdG8gYmUgY29ubmVjdGVkIGJ1dCB3YXMgaW4gc3RhdGUgJXMgb3IgaXQgaGFkIGEgcmVjb25uZWN0IHRpbWVvdXRcIixcbiAgICAgICAgdGhpcy5fc3RhdHVzXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5yZWNvbm5lY3RUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5yZWNvbm5lY3RUaW1lb3V0KTtcbiAgICAgIHRoaXMucmVjb25uZWN0VGltZW91dCA9IHZvaWQgMDtcbiAgICB9XG4gICAgaWYgKHRoaXMuY29ubmVjdFRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNvbm5lY3RUaW1lb3V0KTtcbiAgICAgIHRoaXMuY29ubmVjdFRpbWVvdXQgPSB2b2lkIDA7XG4gICAgfVxuICAgIHRpbWVvdXRNcyA/Pz0gdGhpcy50aW1lb3V0TXM7XG4gICAgaWYgKCF0aGlzLnRpbWVvdXRNcyAmJiB0aW1lb3V0TXMpIHRoaXMudGltZW91dE1zID0gdGltZW91dE1zO1xuICAgIGlmICh0aGlzLnRpbWVvdXRNcylcbiAgICAgIHRoaXMuY29ubmVjdFRpbWVvdXQgPSBzZXRUaW1lb3V0KFxuICAgICAgICAoKSA9PiB0aGlzLm9uQ29ubmVjdGlvbkVycm9yKHJlY29ubmVjdCksXG4gICAgICAgIHRoaXMudGltZW91dE1zXG4gICAgICApO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnVwZGF0ZUNvbm5lY3Rpb25TdGF0cy5hdHRlbXB0KCk7XG4gICAgICBpZiAodGhpcy5fc3RhdHVzID09PSAxIC8qIERJU0NPTk5FQ1RFRCAqLylcbiAgICAgICAgdGhpcy5fc3RhdHVzID0gNCAvKiBDT05ORUNUSU5HICovO1xuICAgICAgZWxzZSB0aGlzLl9zdGF0dXMgPSAyIC8qIFJFQ09OTkVDVElORyAqLztcbiAgICAgIHRoaXMud3MgPSBuZXcgV2ViU29ja2V0KHRoaXMubmRrUmVsYXkudXJsKTtcbiAgICAgIHRoaXMud3Mub25vcGVuID0gdGhpcy5vbkNvbm5lY3QuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMud3Mub25jbG9zZSA9IHRoaXMub25EaXNjb25uZWN0LmJpbmQodGhpcyk7XG4gICAgICB0aGlzLndzLm9ubWVzc2FnZSA9IHRoaXMub25NZXNzYWdlLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLndzLm9uZXJyb3IgPSB0aGlzLm9uRXJyb3IuYmluZCh0aGlzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aGlzLmRlYnVnKGBGYWlsZWQgdG8gY29ubmVjdCB0byAke3RoaXMubmRrUmVsYXkudXJsfWAsIGUpO1xuICAgICAgdGhpcy5fc3RhdHVzID0gMSAvKiBESVNDT05ORUNURUQgKi87XG4gICAgICBpZiAocmVjb25uZWN0KSB0aGlzLmhhbmRsZVJlY29ubmVjdGlvbigpO1xuICAgICAgZWxzZSB0aGlzLm5ka1JlbGF5LmVtaXQoXCJkZWxheWVkLWNvbm5lY3RcIiwgMiAqIDI0ICogNjAgKiA2MCAqIDFlMyk7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRGlzY29ubmVjdHMgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIHRvIHRoZSBOREsgcmVsYXkuXG4gICAqIFRoaXMgbWV0aG9kIHNldHMgdGhlIGNvbm5lY3Rpb24gc3RhdHVzIHRvIGBOREtSZWxheVN0YXR1cy5ESVNDT05ORUNUSU5HYCxcbiAgICogYXR0ZW1wdHMgdG8gY2xvc2UgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uLCBhbmQgc2V0cyB0aGUgc3RhdHVzIHRvXG4gICAqIGBOREtSZWxheVN0YXR1cy5ESVNDT05ORUNURURgIGlmIHRoZSBkaXNjb25uZWN0IG9wZXJhdGlvbiBmYWlscy5cbiAgICovXG4gIGRpc2Nvbm5lY3QoKSB7XG4gICAgdGhpcy5fc3RhdHVzID0gMCAvKiBESVNDT05ORUNUSU5HICovO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLndzPy5jbG9zZSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXMuZGVidWcoXCJGYWlsZWQgdG8gZGlzY29ubmVjdFwiLCBlKTtcbiAgICAgIHRoaXMuX3N0YXR1cyA9IDEgLyogRElTQ09OTkVDVEVEICovO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogSGFuZGxlcyB0aGUgZXJyb3IgdGhhdCBvY2N1cnJlZCB3aGVuIGF0dGVtcHRpbmcgdG8gY29ubmVjdCB0byB0aGUgTkRLIHJlbGF5LlxuICAgKiBJZiBgcmVjb25uZWN0YCBpcyBgdHJ1ZWAsIHRoaXMgbWV0aG9kIHdpbGwgaW5pdGlhdGUgYSByZWNvbm5lY3Rpb24gYXR0ZW1wdC5cbiAgICogT3RoZXJ3aXNlLCBpdCB3aWxsIGVtaXQgYSBgZGVsYXllZC1jb25uZWN0YCBldmVudCBvbiB0aGUgYG5ka1JlbGF5YCBvYmplY3QsXG4gICAqIGluZGljYXRpbmcgdGhhdCBhIHJlY29ubmVjdGlvbiBzaG91bGQgYmUgYXR0ZW1wdGVkIGFmdGVyIGEgZGVsYXkuXG4gICAqXG4gICAqIEBwYXJhbSByZWNvbm5lY3QgLSBJbmRpY2F0ZXMgd2hldGhlciBhIHJlY29ubmVjdGlvbiBzaG91bGQgYmUgYXR0ZW1wdGVkLlxuICAgKi9cbiAgb25Db25uZWN0aW9uRXJyb3IocmVjb25uZWN0KSB7XG4gICAgdGhpcy5kZWJ1ZyhgRXJyb3IgY29ubmVjdGluZyB0byAke3RoaXMubmRrUmVsYXkudXJsfWAsIHRoaXMudGltZW91dE1zKTtcbiAgICBpZiAocmVjb25uZWN0ICYmICF0aGlzLnJlY29ubmVjdFRpbWVvdXQpIHtcbiAgICAgIHRoaXMuaGFuZGxlUmVjb25uZWN0aW9uKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSBjb25uZWN0aW9uIGV2ZW50IHdoZW4gdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIGlzIGVzdGFibGlzaGVkLlxuICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgd2hlbiB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gaXMgc3VjY2Vzc2Z1bGx5IG9wZW5lZC5cbiAgICogSXQgY2xlYXJzIGFueSBleGlzdGluZyBjb25uZWN0aW9uIGFuZCByZWNvbm5lY3Rpb24gdGltZW91dHMsIHVwZGF0ZXMgdGhlIGNvbm5lY3Rpb24gc3RhdGlzdGljcyxcbiAgICogc2V0cyB0aGUgY29ubmVjdGlvbiBzdGF0dXMgdG8gYENPTk5FQ1RFRGAsIGFuZCBlbWl0cyBgY29ubmVjdGAgYW5kIGByZWFkeWAgZXZlbnRzIG9uIHRoZSBgbmRrUmVsYXlgIG9iamVjdC5cbiAgICovXG4gIG9uQ29ubmVjdCgpIHtcbiAgICB0aGlzLm5ldERlYnVnPy4oXCJjb25uZWN0ZWRcIiwgdGhpcy5uZGtSZWxheSk7XG4gICAgaWYgKHRoaXMucmVjb25uZWN0VGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVjb25uZWN0VGltZW91dCk7XG4gICAgICB0aGlzLnJlY29ubmVjdFRpbWVvdXQgPSB2b2lkIDA7XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbm5lY3RUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5jb25uZWN0VGltZW91dCk7XG4gICAgICB0aGlzLmNvbm5lY3RUaW1lb3V0ID0gdm9pZCAwO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZUNvbm5lY3Rpb25TdGF0cy5jb25uZWN0ZWQoKTtcbiAgICB0aGlzLl9zdGF0dXMgPSA1IC8qIENPTk5FQ1RFRCAqLztcbiAgICB0aGlzLm5ka1JlbGF5LmVtaXQoXCJjb25uZWN0XCIpO1xuICAgIHRoaXMubmRrUmVsYXkuZW1pdChcInJlYWR5XCIpO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSBkaXNjb25uZWN0aW9uIGV2ZW50IHdoZW4gdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIGlzIGNsb3NlZC5cbiAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIHdoZW4gdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIGlzIHN1Y2Nlc3NmdWxseSBjbG9zZWQuXG4gICAqIEl0IHVwZGF0ZXMgdGhlIGNvbm5lY3Rpb24gc3RhdGlzdGljcywgc2V0cyB0aGUgY29ubmVjdGlvbiBzdGF0dXMgdG8gYERJU0NPTk5FQ1RFRGAsXG4gICAqIGluaXRpYXRlcyBhIHJlY29ubmVjdGlvbiBhdHRlbXB0IGlmIHdlIGRpZG4ndCBkaXNjb25uZWN0IG91cnNlbHZlcyxcbiAgICogYW5kIGVtaXRzIGEgYGRpc2Nvbm5lY3RgIGV2ZW50IG9uIHRoZSBgbmRrUmVsYXlgIG9iamVjdC5cbiAgICovXG4gIG9uRGlzY29ubmVjdCgpIHtcbiAgICB0aGlzLm5ldERlYnVnPy4oXCJkaXNjb25uZWN0ZWRcIiwgdGhpcy5uZGtSZWxheSk7XG4gICAgdGhpcy51cGRhdGVDb25uZWN0aW9uU3RhdHMuZGlzY29ubmVjdGVkKCk7XG4gICAgaWYgKHRoaXMuX3N0YXR1cyA9PT0gNSAvKiBDT05ORUNURUQgKi8pIHtcbiAgICAgIHRoaXMuaGFuZGxlUmVjb25uZWN0aW9uKCk7XG4gICAgfVxuICAgIHRoaXMuX3N0YXR1cyA9IDEgLyogRElTQ09OTkVDVEVEICovO1xuICAgIHRoaXMubmRrUmVsYXkuZW1pdChcImRpc2Nvbm5lY3RcIik7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZXMgaW5jb21pbmcgbWVzc2FnZXMgZnJvbSB0aGUgTkRLIHJlbGF5IFdlYlNvY2tldCBjb25uZWN0aW9uLlxuICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgd2hlbmV2ZXIgYSBtZXNzYWdlIGlzIHJlY2VpdmVkIGZyb20gdGhlIHJlbGF5LlxuICAgKiBJdCBwYXJzZXMgdGhlIG1lc3NhZ2UgZGF0YSBhbmQgZGlzcGF0Y2hlcyB0aGUgYXBwcm9wcmlhdGUgaGFuZGxpbmcgbG9naWMgYmFzZWQgb24gdGhlIG1lc3NhZ2UgdHlwZS5cbiAgICpcbiAgICogQHBhcmFtIGV2ZW50IC0gVGhlIE1lc3NhZ2VFdmVudCBjb250YWluaW5nIHRoZSByZWNlaXZlZCBtZXNzYWdlIGRhdGEuXG4gICAqL1xuICBvbk1lc3NhZ2UoZXZlbnQpIHtcbiAgICB0aGlzLm5ldERlYnVnPy4oZXZlbnQuZGF0YSwgdGhpcy5uZGtSZWxheSwgXCJyZWN2XCIpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShldmVudC5kYXRhKTtcbiAgICAgIGNvbnN0IFtjbWQsIGlkLCAuLi5yZXN0XSA9IGRhdGE7XG4gICAgICBzd2l0Y2ggKGNtZCkge1xuICAgICAgICBjYXNlIFwiRVZFTlRcIjoge1xuICAgICAgICAgIGNvbnN0IHNvID0gdGhpcy5vcGVuU3Vicy5nZXQoaWQpO1xuICAgICAgICAgIGNvbnN0IGV2ZW50MiA9IGRhdGFbMl07XG4gICAgICAgICAgaWYgKCFzbykge1xuICAgICAgICAgICAgdGhpcy5kZWJ1ZyhgUmVjZWl2ZWQgZXZlbnQgZm9yIHVua25vd24gc3Vic2NyaXB0aW9uICR7aWR9YCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHNvLm9uZXZlbnQoZXZlbnQyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIkNPVU5UXCI6IHtcbiAgICAgICAgICBjb25zdCBwYXlsb2FkID0gZGF0YVsyXTtcbiAgICAgICAgICBjb25zdCBjciA9IHRoaXMub3BlbkNvdW50UmVxdWVzdHMuZ2V0KGlkKTtcbiAgICAgICAgICBpZiAoY3IpIHtcbiAgICAgICAgICAgIGNyLnJlc29sdmUocGF5bG9hZC5jb3VudCk7XG4gICAgICAgICAgICB0aGlzLm9wZW5Db3VudFJlcXVlc3RzLmRlbGV0ZShpZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiRU9TRVwiOiB7XG4gICAgICAgICAgY29uc3Qgc28gPSB0aGlzLm9wZW5TdWJzLmdldChpZCk7XG4gICAgICAgICAgaWYgKCFzbykgcmV0dXJuO1xuICAgICAgICAgIHNvLm9uZW9zZShpZCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJPS1wiOiB7XG4gICAgICAgICAgY29uc3Qgb2sgPSBkYXRhWzJdO1xuICAgICAgICAgIGNvbnN0IHJlYXNvbiA9IGRhdGFbM107XG4gICAgICAgICAgY29uc3QgZXAgPSB0aGlzLm9wZW5FdmVudFB1Ymxpc2hlcy5nZXQoaWQpO1xuICAgICAgICAgIGNvbnN0IGZpcnN0RXAgPSBlcD8ucG9wKCk7XG4gICAgICAgICAgaWYgKCFlcCB8fCAhZmlyc3RFcCkge1xuICAgICAgICAgICAgdGhpcy5kZWJ1ZyhcIlJlY2VpdmVkIE9LIGZvciB1bmtub3duIGV2ZW50IHB1Ymxpc2hcIiwgaWQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob2spIGZpcnN0RXAucmVzb2x2ZShyZWFzb24pO1xuICAgICAgICAgIGVsc2UgZmlyc3RFcC5yZWplY3QobmV3IEVycm9yKHJlYXNvbikpO1xuICAgICAgICAgIGlmIChlcC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMub3BlbkV2ZW50UHVibGlzaGVzLmRlbGV0ZShpZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub3BlbkV2ZW50UHVibGlzaGVzLnNldChpZCwgZXApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIkNMT1NFRFwiOiB7XG4gICAgICAgICAgY29uc3Qgc28gPSB0aGlzLm9wZW5TdWJzLmdldChpZCk7XG4gICAgICAgICAgaWYgKCFzbykgcmV0dXJuO1xuICAgICAgICAgIHNvLm9uY2xvc2VkKGRhdGFbMl0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiTk9USUNFXCI6XG4gICAgICAgICAgdGhpcy5vbk5vdGljZShkYXRhWzFdKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgXCJBVVRIXCI6IHtcbiAgICAgICAgICB0aGlzLm9uQXV0aFJlcXVlc3RlZChkYXRhWzFdKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5kZWJ1ZyhcbiAgICAgICAgYEVycm9yIHBhcnNpbmcgbWVzc2FnZSBmcm9tICR7dGhpcy5uZGtSZWxheS51cmx9OiAke2Vycm9yLm1lc3NhZ2V9YCxcbiAgICAgICAgZXJyb3I/LnN0YWNrXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogSGFuZGxlcyBhbiBhdXRoZW50aWNhdGlvbiByZXF1ZXN0IGZyb20gdGhlIE5ESyByZWxheS5cbiAgICpcbiAgICogSWYgYW4gYXV0aGVudGljYXRpb24gcG9saWN5IGlzIGNvbmZpZ3VyZWQsIGl0IHdpbGwgYmUgdXNlZCB0byBhdXRoZW50aWNhdGUgdGhlIGNvbm5lY3Rpb24uXG4gICAqIE90aGVyd2lzZSwgdGhlIGBhdXRoYCBldmVudCB3aWxsIGJlIGVtaXR0ZWQgdG8gYWxsb3cgdGhlIGFwcGxpY2F0aW9uIHRvIGhhbmRsZSB0aGUgYXV0aGVudGljYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSBjaGFsbGVuZ2UgLSBUaGUgYXV0aGVudGljYXRpb24gY2hhbGxlbmdlIHByb3ZpZGVkIGJ5IHRoZSBOREsgcmVsYXkuXG4gICAqL1xuICBhc3luYyBvbkF1dGhSZXF1ZXN0ZWQoY2hhbGxlbmdlKSB7XG4gICAgY29uc3QgYXV0aFBvbGljeSA9IHRoaXMubmRrUmVsYXkuYXV0aFBvbGljeSA/PyB0aGlzLm5kaz8ucmVsYXlBdXRoRGVmYXVsdFBvbGljeTtcbiAgICB0aGlzLmRlYnVnKFwiUmVsYXkgcmVxdWVzdGVkIGF1dGhlbnRpY2F0aW9uXCIsIHtcbiAgICAgIGhhdmVQb2xpY3k6ICEhYXV0aFBvbGljeVxuICAgIH0pO1xuICAgIGlmICh0aGlzLl9zdGF0dXMgPT09IDcgLyogQVVUSEVOVElDQVRJTkcgKi8pIHtcbiAgICAgIHRoaXMuZGVidWcoXCJBbHJlYWR5IGF1dGhlbnRpY2F0aW5nLCBpZ25vcmluZ1wiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fc3RhdHVzID0gNiAvKiBBVVRIX1JFUVVFU1RFRCAqLztcbiAgICBpZiAoYXV0aFBvbGljeSkge1xuICAgICAgaWYgKHRoaXMuX3N0YXR1cyA+PSA1IC8qIENPTk5FQ1RFRCAqLykge1xuICAgICAgICB0aGlzLl9zdGF0dXMgPSA3IC8qIEFVVEhFTlRJQ0FUSU5HICovO1xuICAgICAgICBsZXQgcmVzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlcyA9IGF3YWl0IGF1dGhQb2xpY3kodGhpcy5uZGtSZWxheSwgY2hhbGxlbmdlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRoaXMuZGVidWcoXCJBdXRoZW50aWNhdGlvbiBwb2xpY3kgdGhyZXcgYW4gZXJyb3JcIiwgZSk7XG4gICAgICAgICAgcmVzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZWJ1ZyhcIkF1dGhlbnRpY2F0aW9uIHBvbGljeSByZXR1cm5lZFwiLCAhIXJlcyk7XG4gICAgICAgIGlmIChyZXMgaW5zdGFuY2VvZiBOREtFdmVudCB8fCByZXMgPT09IHRydWUpIHtcbiAgICAgICAgICBpZiAocmVzIGluc3RhbmNlb2YgTkRLRXZlbnQpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYXV0aChyZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBhdXRoZW50aWNhdGUgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhdHVzID49IDUgLyogQ09OTkVDVEVEICovICYmIHRoaXMuX3N0YXR1cyA8IDggLyogQVVUSEVOVElDQVRFRCAqLykge1xuICAgICAgICAgICAgICBjb25zdCBldmVudCA9IG5ldyBOREtFdmVudCh0aGlzLm5kayk7XG4gICAgICAgICAgICAgIGV2ZW50LmtpbmQgPSAyMjI0MiAvKiBDbGllbnRBdXRoICovO1xuICAgICAgICAgICAgICBldmVudC50YWdzID0gW1xuICAgICAgICAgICAgICAgIFtcInJlbGF5XCIsIHRoaXMubmRrUmVsYXkudXJsXSxcbiAgICAgICAgICAgICAgICBbXCJjaGFsbGVuZ2VcIiwgY2hhbGxlbmdlXVxuICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICBhd2FpdCBldmVudC5zaWduKCk7XG4gICAgICAgICAgICAgIHRoaXMuYXV0aChldmVudCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdHVzID0gOCAvKiBBVVRIRU5USUNBVEVEICovO1xuICAgICAgICAgICAgICAgIHRoaXMubmRrUmVsYXkuZW1pdChcImF1dGhlZFwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlYnVnKFwiQXV0aGVudGljYXRpb24gc3VjY2Vzc2Z1bFwiKTtcbiAgICAgICAgICAgICAgfSkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0dXMgPSA2IC8qIEFVVEhfUkVRVUVTVEVEICovO1xuICAgICAgICAgICAgICAgIHRoaXMubmRrUmVsYXkuZW1pdChcImF1dGg6ZmFpbGVkXCIsIGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVidWcoXCJBdXRoZW50aWNhdGlvbiBmYWlsZWRcIiwgZSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5kZWJ1ZyhcbiAgICAgICAgICAgICAgICBcIkF1dGhlbnRpY2F0aW9uIGZhaWxlZCwgaXQgY2hhbmdlZCBzdGF0dXMsIHN0YXR1cyBpcyAlZFwiLFxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXR1c1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKHJlcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLm5kaz8uc2lnbmVyKSB7XG4gICAgICAgICAgICAgIHRoaXMuZGVidWcoXCJObyBzaWduZXIgYXZhaWxhYmxlIGZvciBhdXRoZW50aWNhdGlvbiBsb2NhbGhvc3RcIik7XG4gICAgICAgICAgICAgIHRoaXMubmRrPy5vbmNlKFwic2lnbmVyOnJlYWR5XCIsIGF1dGhlbnRpY2F0ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhdXRoZW50aWNhdGUoKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBhdXRoZW50aWNhdGluZ1wiLCBlKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3N0YXR1cyA9IDUgLyogQ09OTkVDVEVEICovO1xuICAgICAgICAgIHRoaXMubmRrUmVsYXkuZW1pdChcImF1dGhlZFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm5ka1JlbGF5LmVtaXQoXCJhdXRoXCIsIGNoYWxsZW5nZSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBIYW5kbGVzIGVycm9ycyB0aGF0IG9jY3VyIG9uIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiB0byB0aGUgcmVsYXkuXG4gICAqIEBwYXJhbSBlcnJvciAtIFRoZSBlcnJvciBvciBldmVudCB0aGF0IG9jY3VycmVkLlxuICAgKi9cbiAgb25FcnJvcihlcnJvcikge1xuICAgIHRoaXMuZGVidWcoYFdlYlNvY2tldCBlcnJvciBvbiAke3RoaXMubmRrUmVsYXkudXJsfTpgLCBlcnJvcik7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgc3RhdHVzIG9mIHRoZSBOREsgcmVsYXkgY29ubmVjdGlvbi5cbiAgICogQHJldHVybnMge05ES1JlbGF5U3RhdHVzfSBUaGUgY3VycmVudCBzdGF0dXMgb2YgdGhlIE5ESyByZWxheSBjb25uZWN0aW9uLlxuICAgKi9cbiAgZ2V0IHN0YXR1cygpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdHVzO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIE5ESyByZWxheSBjb25uZWN0aW9uIGlzIGN1cnJlbnRseSBhdmFpbGFibGUuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHJlbGF5IGNvbm5lY3Rpb24gaXMgaW4gdGhlIGBDT05ORUNURURgIHN0YXR1cywgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAqL1xuICBpc0F2YWlsYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdHVzID09PSA1IC8qIENPTk5FQ1RFRCAqLztcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBOREsgcmVsYXkgY29ubmVjdGlvbiBpcyBmbGFwcGluZywgd2hpY2ggbWVhbnMgdGhlIGNvbm5lY3Rpb24gaXMgcmFwaWRseVxuICAgKiBkaXNjb25uZWN0aW5nIGFuZCByZWNvbm5lY3RpbmcuIFRoaXMgaXMgZGV0ZXJtaW5lZCBieSBhbmFseXppbmcgdGhlIGR1cmF0aW9ucyBvZiB0aGVcbiAgICogbGFzdCB0aHJlZSBjb25uZWN0aW9uIGF0dGVtcHRzLiBJZiB0aGUgc3RhbmRhcmQgZGV2aWF0aW9uIG9mIHRoZSBkdXJhdGlvbnMgaXMgbGVzc1xuICAgKiB0aGFuIDEwMDAgbWlsbGlzZWNvbmRzLCB0aGUgY29ubmVjdGlvbiBpcyBjb25zaWRlcmVkIHRvIGJlIGZsYXBwaW5nLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSBjb25uZWN0aW9uIGlzIGZsYXBwaW5nLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICovXG4gIGlzRmxhcHBpbmcoKSB7XG4gICAgY29uc3QgZHVyYXRpb25zID0gdGhpcy5fY29ubmVjdGlvblN0YXRzLmR1cmF0aW9ucztcbiAgICBpZiAoZHVyYXRpb25zLmxlbmd0aCAlIDMgIT09IDApIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBzdW0gPSBkdXJhdGlvbnMucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCk7XG4gICAgY29uc3QgYXZnID0gc3VtIC8gZHVyYXRpb25zLmxlbmd0aDtcbiAgICBjb25zdCB2YXJpYW5jZSA9IGR1cmF0aW9ucy5tYXAoKHgpID0+IE1hdGgucG93KHggLSBhdmcsIDIpKS5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKSAvIGR1cmF0aW9ucy5sZW5ndGg7XG4gICAgY29uc3Qgc3RkRGV2ID0gTWF0aC5zcXJ0KHZhcmlhbmNlKTtcbiAgICBjb25zdCBpc0ZsYXBwaW5nID0gc3RkRGV2IDwgRkxBUFBJTkdfVEhSRVNIT0xEX01TO1xuICAgIHJldHVybiBpc0ZsYXBwaW5nO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGVzIGEgbm90aWNlIHJlY2VpdmVkIGZyb20gdGhlIE5ESyByZWxheS5cbiAgICogSWYgdGhlIG5vdGljZSBpbmRpY2F0ZXMgdGhlIHJlbGF5IGlzIGNvbXBsYWluaW5nIChlLmcuIFwidG9vIG1hbnlcIiBvciBcIm1heGltdW1cIiksXG4gICAqIHRoZSBtZXRob2QgZGlzY29ubmVjdHMgZnJvbSB0aGUgcmVsYXkgYW5kIGF0dGVtcHRzIHRvIHJlY29ubmVjdCBhZnRlciBhIDItc2Vjb25kIGRlbGF5LlxuICAgKiBBIGRlYnVnIG1lc3NhZ2UgaXMgbG9nZ2VkIHdpdGggdGhlIHJlbGF5IFVSTCBhbmQgdGhlIG5vdGljZSB0ZXh0LlxuICAgKiBUaGUgXCJub3RpY2VcIiBldmVudCBpcyBlbWl0dGVkIG9uIHRoZSBuZGtSZWxheSBpbnN0YW5jZSB3aXRoIHRoZSBub3RpY2UgdGV4dC5cbiAgICpcbiAgICogQHBhcmFtIG5vdGljZSAtIFRoZSBub3RpY2UgdGV4dCByZWNlaXZlZCBmcm9tIHRoZSBOREsgcmVsYXkuXG4gICAqL1xuICBhc3luYyBvbk5vdGljZShub3RpY2UpIHtcbiAgICB0aGlzLm5ka1JlbGF5LmVtaXQoXCJub3RpY2VcIiwgbm90aWNlKTtcbiAgfVxuICAvKipcbiAgICogQXR0ZW1wdHMgdG8gcmVjb25uZWN0IHRvIHRoZSBOREsgcmVsYXkgYWZ0ZXIgYSBjb25uZWN0aW9uIGlzIGxvc3QuXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHJlY3Vyc2l2ZWx5IHRvIGhhbmRsZSBtdWx0aXBsZSByZWNvbm5lY3Rpb24gYXR0ZW1wdHMuXG4gICAqIEl0IGNoZWNrcyBpZiB0aGUgcmVsYXkgaXMgZmxhcHBpbmcgYW5kIGVtaXRzIGEgXCJmbGFwcGluZ1wiIGV2ZW50IGlmIHNvLlxuICAgKiBJdCB0aGVuIGNhbGN1bGF0ZXMgYSBkZWxheSBiZWZvcmUgdGhlIG5leHQgcmVjb25uZWN0aW9uIGF0dGVtcHQgYmFzZWQgb24gdGhlIG51bWJlciBvZiBwcmV2aW91cyBhdHRlbXB0cy5cbiAgICogVGhlIGZ1bmN0aW9uIHNldHMgYSB0aW1lb3V0IHRvIGV4ZWN1dGUgdGhlIG5leHQgcmVjb25uZWN0aW9uIGF0dGVtcHQgYWZ0ZXIgdGhlIGNhbGN1bGF0ZWQgZGVsYXkuXG4gICAqIElmIHRoZSBtYXhpbXVtIG51bWJlciBvZiByZWNvbm5lY3Rpb24gYXR0ZW1wdHMgaXMgcmVhY2hlZCwgYSBkZWJ1ZyBtZXNzYWdlIGlzIGxvZ2dlZC5cbiAgICpcbiAgICogQHBhcmFtIGF0dGVtcHQgLSBUaGUgY3VycmVudCBhdHRlbXB0IG51bWJlciAoZGVmYXVsdCBpcyAwKS5cbiAgICovXG4gIGhhbmRsZVJlY29ubmVjdGlvbihhdHRlbXB0ID0gMCkge1xuICAgIGlmICh0aGlzLnJlY29ubmVjdFRpbWVvdXQpIHJldHVybjtcbiAgICBpZiAodGhpcy5pc0ZsYXBwaW5nKCkpIHtcbiAgICAgIHRoaXMubmRrUmVsYXkuZW1pdChcImZsYXBwaW5nXCIsIHRoaXMuX2Nvbm5lY3Rpb25TdGF0cyk7XG4gICAgICB0aGlzLl9zdGF0dXMgPSAzIC8qIEZMQVBQSU5HICovO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZWNvbm5lY3REZWxheSA9IHRoaXMuY29ubmVjdGVkQXQgPyBNYXRoLm1heCgwLCA2ZTQgLSAoRGF0ZS5ub3coKSAtIHRoaXMuY29ubmVjdGVkQXQpKSA6IDVlMyAqICh0aGlzLl9jb25uZWN0aW9uU3RhdHMuYXR0ZW1wdHMgKyAxKTtcbiAgICB0aGlzLnJlY29ubmVjdFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMucmVjb25uZWN0VGltZW91dCA9IHZvaWQgMDtcbiAgICAgIHRoaXMuX3N0YXR1cyA9IDIgLyogUkVDT05ORUNUSU5HICovO1xuICAgICAgdGhpcy5jb25uZWN0KCkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICBpZiAoYXR0ZW1wdCA8IE1BWF9SRUNPTk5FQ1RfQVRURU1QVFMpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KFxuICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLmhhbmRsZVJlY29ubmVjdGlvbihhdHRlbXB0ICsgMSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgMWUzICogKGF0dGVtcHQgKyAxKSBeIDRcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZGVidWcoXCJSZWNvbm5lY3QgZmFpbGVkXCIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LCByZWNvbm5lY3REZWxheSk7XG4gICAgdGhpcy5uZGtSZWxheS5lbWl0KFwiZGVsYXllZC1jb25uZWN0XCIsIHJlY29ubmVjdERlbGF5KTtcbiAgICB0aGlzLmRlYnVnKFwiUmVjb25uZWN0aW5nIGluXCIsIHJlY29ubmVjdERlbGF5KTtcbiAgICB0aGlzLl9jb25uZWN0aW9uU3RhdHMubmV4dFJlY29ubmVjdEF0ID0gRGF0ZS5ub3coKSArIHJlY29ubmVjdERlbGF5O1xuICB9XG4gIC8qKlxuICAgKiBTZW5kcyBhIG1lc3NhZ2UgdG8gdGhlIE5ESyByZWxheSBpZiB0aGUgY29ubmVjdGlvbiBpcyBpbiB0aGUgQ09OTkVDVEVEIHN0YXRlIGFuZCB0aGUgV2ViU29ja2V0IGlzIG9wZW4uXG4gICAqIElmIHRoZSBjb25uZWN0aW9uIGlzIG5vdCBpbiB0aGUgQ09OTkVDVEVEIHN0YXRlIG9yIHRoZSBXZWJTb2NrZXQgaXMgbm90IG9wZW4sIGxvZ3MgYSBkZWJ1ZyBtZXNzYWdlIGFuZCB0aHJvd3MgYW4gZXJyb3IuXG4gICAqXG4gICAqIEBwYXJhbSBtZXNzYWdlIC0gVGhlIG1lc3NhZ2UgdG8gc2VuZCB0byB0aGUgTkRLIHJlbGF5LlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgYXR0ZW1wdGluZyB0byBzZW5kIG9uIGEgY2xvc2VkIHJlbGF5IGNvbm5lY3Rpb24uXG4gICAqL1xuICBhc3luYyBzZW5kKG1lc3NhZ2UpIHtcbiAgICBpZiAodGhpcy5fc3RhdHVzID49IDUgLyogQ09OTkVDVEVEICovICYmIHRoaXMud3M/LnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5PUEVOKSB7XG4gICAgICB0aGlzLndzPy5zZW5kKG1lc3NhZ2UpO1xuICAgICAgdGhpcy5uZXREZWJ1Zz8uKG1lc3NhZ2UsIHRoaXMubmRrUmVsYXksIFwic2VuZFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kZWJ1ZyhcbiAgICAgICAgYE5vdCBjb25uZWN0ZWQgdG8gJHt0aGlzLm5ka1JlbGF5LnVybH0gKCVkKSwgbm90IHNlbmRpbmcgbWVzc2FnZSAke21lc3NhZ2V9YCxcbiAgICAgICAgdGhpcy5fc3RhdHVzXG4gICAgICApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQXV0aGVudGljYXRlcyB0aGUgTkRLIGV2ZW50IGJ5IHNlbmRpbmcgaXQgdG8gdGhlIE5ESyByZWxheSBhbmQgcmV0dXJuaW5nIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIHJlc3VsdC5cbiAgICpcbiAgICogQHBhcmFtIGV2ZW50IC0gVGhlIE5ESyBldmVudCB0byBhdXRoZW50aWNhdGUuXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGF1dGhlbnRpY2F0aW9uIHJlc3VsdC5cbiAgICovXG4gIGFzeW5jIGF1dGgoZXZlbnQpIHtcbiAgICBjb25zdCByZXQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCB2YWwgPSB0aGlzLm9wZW5FdmVudFB1Ymxpc2hlcy5nZXQoZXZlbnQuaWQpID8/IFtdO1xuICAgICAgdmFsLnB1c2goeyByZXNvbHZlLCByZWplY3QgfSk7XG4gICAgICB0aGlzLm9wZW5FdmVudFB1Ymxpc2hlcy5zZXQoZXZlbnQuaWQsIHZhbCk7XG4gICAgfSk7XG4gICAgdGhpcy5zZW5kKCdbXCJBVVRIXCIsJyArIEpTT04uc3RyaW5naWZ5KGV2ZW50LnJhd0V2ZW50KCkpICsgXCJdXCIpO1xuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgLyoqXG4gICAqIFB1Ymxpc2hlcyBhbiBOREsgZXZlbnQgdG8gdGhlIHJlbGF5IGFuZCByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIHJlc3VsdC5cbiAgICpcbiAgICogQHBhcmFtIGV2ZW50IC0gVGhlIE5ESyBldmVudCB0byBwdWJsaXNoLlxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSByZXN1bHQgb2YgdGhlIGV2ZW50IHB1YmxpY2F0aW9uLlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgYXR0ZW1wdGluZyB0byBwdWJsaXNoIG9uIGEgY2xvc2VkIHJlbGF5IGNvbm5lY3Rpb24uXG4gICAqL1xuICBhc3luYyBwdWJsaXNoKGV2ZW50KSB7XG4gICAgY29uc3QgcmV0ID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgdmFsID0gdGhpcy5vcGVuRXZlbnRQdWJsaXNoZXMuZ2V0KGV2ZW50LmlkKSA/PyBbXTtcbiAgICAgIGlmICh2YWwubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgXCJEdXBsaWNhdGUgZXZlbnQgcHVibGlzaGluZyBkZXRlY3RlZCwgeW91IGFyZSBwdWJsaXNoaW5nIGV2ZW50IFwiICsgZXZlbnQuaWQgKyBcIiB0d2ljZVwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB2YWwucHVzaCh7IHJlc29sdmUsIHJlamVjdCB9KTtcbiAgICAgIHRoaXMub3BlbkV2ZW50UHVibGlzaGVzLnNldChldmVudC5pZCwgdmFsKTtcbiAgICB9KTtcbiAgICB0aGlzLnNlbmQoJ1tcIkVWRU5UXCIsJyArIEpTT04uc3RyaW5naWZ5KGV2ZW50KSArIFwiXVwiKTtcbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIC8qKlxuICAgKiBDb3VudHMgdGhlIG51bWJlciBvZiBldmVudHMgdGhhdCBtYXRjaCB0aGUgcHJvdmlkZWQgZmlsdGVycy5cbiAgICpcbiAgICogQHBhcmFtIGZpbHRlcnMgLSBUaGUgZmlsdGVycyB0byBhcHBseSB0byB0aGUgY291bnQgcmVxdWVzdC5cbiAgICogQHBhcmFtIHBhcmFtcyAtIEFuIG9wdGlvbmFsIG9iamVjdCBjb250YWluaW5nIGEgY3VzdG9tIGlkIGZvciB0aGUgY291bnQgcmVxdWVzdC5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgbnVtYmVyIG9mIG1hdGNoaW5nIGV2ZW50cy5cbiAgICogQHRocm93cyB7RXJyb3J9IElmIGF0dGVtcHRpbmcgdG8gc2VuZCB0aGUgY291bnQgcmVxdWVzdCBvbiBhIGNsb3NlZCByZWxheSBjb25uZWN0aW9uLlxuICAgKi9cbiAgYXN5bmMgY291bnQoZmlsdGVycywgcGFyYW1zKSB7XG4gICAgdGhpcy5zZXJpYWwrKztcbiAgICBjb25zdCBpZCA9IHBhcmFtcz8uaWQgfHwgXCJjb3VudDpcIiArIHRoaXMuc2VyaWFsO1xuICAgIGNvbnN0IHJldCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMub3BlbkNvdW50UmVxdWVzdHMuc2V0KGlkLCB7IHJlc29sdmUsIHJlamVjdCB9KTtcbiAgICB9KTtcbiAgICB0aGlzLnNlbmQoJ1tcIkNPVU5UXCIsXCInICsgaWQgKyAnXCIsJyArIEpTT04uc3RyaW5naWZ5KGZpbHRlcnMpLnN1YnN0cmluZygxKSk7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBjbG9zZShzdWJJZCwgcmVhc29uKSB7XG4gICAgdGhpcy5zZW5kKCdbXCJDTE9TRVwiLFwiJyArIHN1YklkICsgJ1wiXScpO1xuICAgIGNvbnN0IHN1YiA9IHRoaXMub3BlblN1YnMuZ2V0KHN1YklkKTtcbiAgICB0aGlzLm9wZW5TdWJzLmRlbGV0ZShzdWJJZCk7XG4gICAgaWYgKHN1Yikgc3ViLm9uY2xvc2UocmVhc29uKTtcbiAgfVxuICAvKipcbiAgICogU3Vic2NyaWJlcyB0byB0aGUgTkRLIHJlbGF5IHdpdGggdGhlIHByb3ZpZGVkIGZpbHRlcnMgYW5kIHBhcmFtZXRlcnMuXG4gICAqXG4gICAqIEBwYXJhbSBmaWx0ZXJzIC0gVGhlIGZpbHRlcnMgdG8gYXBwbHkgdG8gdGhlIHN1YnNjcmlwdGlvbi5cbiAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBzdWJzY3JpcHRpb24gcGFyYW1ldGVycywgaW5jbHVkaW5nIGFuIG9wdGlvbmFsIGN1c3RvbSBpZC5cbiAgICogQHJldHVybnMgQSBuZXcgTkRLUmVsYXlTdWJzY3JpcHRpb24gaW5zdGFuY2UuXG4gICAqL1xuICByZXEocmVsYXlTdWIpIHtcbiAgICB0aGlzLnNlbmQoXG4gICAgICAnW1wiUkVRXCIsXCInICsgcmVsYXlTdWIuc3ViSWQgKyAnXCIsJyArIEpTT04uc3RyaW5naWZ5KHJlbGF5U3ViLmV4ZWN1dGVGaWx0ZXJzKS5zdWJzdHJpbmcoMSlcbiAgICApICsgXCJdXCI7XG4gICAgdGhpcy5vcGVuU3Vicy5zZXQocmVsYXlTdWIuc3ViSWQsIHJlbGF5U3ViKTtcbiAgfVxuICAvKipcbiAgICogVXRpbGl0eSBmdW5jdGlvbnMgdG8gdXBkYXRlIHRoZSBjb25uZWN0aW9uIHN0YXRzLlxuICAgKi9cbiAgdXBkYXRlQ29ubmVjdGlvblN0YXRzID0ge1xuICAgIGNvbm5lY3RlZDogKCkgPT4ge1xuICAgICAgdGhpcy5fY29ubmVjdGlvblN0YXRzLnN1Y2Nlc3MrKztcbiAgICAgIHRoaXMuX2Nvbm5lY3Rpb25TdGF0cy5jb25uZWN0ZWRBdCA9IERhdGUubm93KCk7XG4gICAgfSxcbiAgICBkaXNjb25uZWN0ZWQ6ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLl9jb25uZWN0aW9uU3RhdHMuY29ubmVjdGVkQXQpIHtcbiAgICAgICAgdGhpcy5fY29ubmVjdGlvblN0YXRzLmR1cmF0aW9ucy5wdXNoKFxuICAgICAgICAgIERhdGUubm93KCkgLSB0aGlzLl9jb25uZWN0aW9uU3RhdHMuY29ubmVjdGVkQXRcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHRoaXMuX2Nvbm5lY3Rpb25TdGF0cy5kdXJhdGlvbnMubGVuZ3RoID4gMTAwKSB7XG4gICAgICAgICAgdGhpcy5fY29ubmVjdGlvblN0YXRzLmR1cmF0aW9ucy5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9jb25uZWN0aW9uU3RhdHMuY29ubmVjdGVkQXQgPSB2b2lkIDA7XG4gICAgfSxcbiAgICBhdHRlbXB0OiAoKSA9PiB7XG4gICAgICB0aGlzLl9jb25uZWN0aW9uU3RhdHMuYXR0ZW1wdHMrKztcbiAgICAgIHRoaXMuX2Nvbm5lY3Rpb25TdGF0cy5jb25uZWN0ZWRBdCA9IERhdGUubm93KCk7XG4gICAgfVxuICB9O1xuICAvKiogUmV0dXJucyB0aGUgY29ubmVjdGlvbiBzdGF0cy4gKi9cbiAgZ2V0IGNvbm5lY3Rpb25TdGF0cygpIHtcbiAgICByZXR1cm4gdGhpcy5fY29ubmVjdGlvblN0YXRzO1xuICB9XG4gIC8qKiBSZXR1cm5zIHRoZSByZWxheSBVUkwgKi9cbiAgZ2V0IHVybCgpIHtcbiAgICByZXR1cm4gdGhpcy5uZGtSZWxheS51cmw7XG4gIH1cbiAgZ2V0IGNvbm5lY3RlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdHVzID49IDUgLyogQ09OTkVDVEVEICovICYmIHRoaXMud3M/LnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5PUEVOO1xuICB9XG59O1xuXG4vLyBzcmMvcmVsYXkvcHVibGlzaGVyLnRzXG52YXIgTkRLUmVsYXlQdWJsaXNoZXIgPSBjbGFzcyB7XG4gIG5ka1JlbGF5O1xuICBkZWJ1ZztcbiAgY29uc3RydWN0b3IobmRrUmVsYXkpIHtcbiAgICB0aGlzLm5ka1JlbGF5ID0gbmRrUmVsYXk7XG4gICAgdGhpcy5kZWJ1ZyA9IG5ka1JlbGF5LmRlYnVnLmV4dGVuZChcInB1Ymxpc2hlclwiKTtcbiAgfVxuICAvKipcbiAgICogUHVibGlzaGVkIGFuIGV2ZW50IHRvIHRoZSByZWxheTsgaWYgdGhlIHJlbGF5IGlzIG5vdCBjb25uZWN0ZWQsIGl0IHdpbGxcbiAgICogd2FpdCBmb3IgdGhlIHJlbGF5IHRvIGNvbm5lY3QgYmVmb3JlIHB1Ymxpc2hpbmcgdGhlIGV2ZW50LlxuICAgKlxuICAgKiBJZiB0aGUgcmVsYXkgZG9lcyBub3QgY29ubmVjdCB3aXRoaW4gdGhlIHRpbWVvdXQsIHRoZSBwdWJsaXNoIG9wZXJhdGlvblxuICAgKiB3aWxsIGZhaWwuXG4gICAqIEBwYXJhbSBldmVudCAgVGhlIGV2ZW50IHRvIHB1Ymxpc2hcbiAgICogQHBhcmFtIHRpbWVvdXRNcyAgVGhlIHRpbWVvdXQgZm9yIHRoZSBwdWJsaXNoIG9wZXJhdGlvbiBpbiBtaWxsaXNlY29uZHNcbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgZXZlbnQgaGFzIGJlZW4gcHVibGlzaGVkIG9yIHJlamVjdHMgaWYgdGhlIG9wZXJhdGlvbiB0aW1lcyBvdXRcbiAgICovXG4gIGFzeW5jIHB1Ymxpc2goZXZlbnQsIHRpbWVvdXRNcyA9IDI1MDApIHtcbiAgICBsZXQgdGltZW91dDtcbiAgICBjb25zdCBwdWJsaXNoQ29ubmVjdGVkID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLnB1Ymxpc2hFdmVudChldmVudCkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLm5ka1JlbGF5LmVtaXQoXCJwdWJsaXNoZWRcIiwgZXZlbnQpO1xuICAgICAgICAgICAgZXZlbnQuZW1pdChcInJlbGF5OnB1Ymxpc2hlZFwiLCB0aGlzLm5ka1JlbGF5KTtcbiAgICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgfSkuY2F0Y2gocmVqZWN0KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgdGltZW91dFByb21pc2UgPSBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiB7XG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRpbWVvdXQgPSB2b2lkIDA7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJUaW1lb3V0OiBcIiArIHRpbWVvdXRNcyArIFwibXNcIikpO1xuICAgICAgfSwgdGltZW91dE1zKTtcbiAgICB9KTtcbiAgICBjb25zdCBvbkNvbm5lY3RIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgcHVibGlzaENvbm5lY3RlZCgpLnRoZW4oKHJlc3VsdCkgPT4gY29ubmVjdFJlc29sdmUocmVzdWx0KSkuY2F0Y2goKGVycikgPT4gY29ubmVjdFJlamVjdChlcnIpKTtcbiAgICB9O1xuICAgIGxldCBjb25uZWN0UmVzb2x2ZTtcbiAgICBsZXQgY29ubmVjdFJlamVjdDtcbiAgICBjb25zdCBvbkVycm9yID0gKGVycikgPT4ge1xuICAgICAgdGhpcy5uZGtSZWxheS5kZWJ1ZyhcIlB1Ymxpc2ggZmFpbGVkXCIsIGVyciwgZXZlbnQuaWQpO1xuICAgICAgdGhpcy5uZGtSZWxheS5lbWl0KFwicHVibGlzaDpmYWlsZWRcIiwgZXZlbnQsIGVycik7XG4gICAgICBldmVudC5lbWl0KFwicmVsYXk6cHVibGlzaDpmYWlsZWRcIiwgdGhpcy5uZGtSZWxheSwgZXJyKTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9O1xuICAgIGNvbnN0IG9uRmluYWxseSA9ICgpID0+IHtcbiAgICAgIGlmICh0aW1lb3V0KSBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICB0aGlzLm5ka1JlbGF5LnJlbW92ZUxpc3RlbmVyKFwiY29ubmVjdFwiLCBvbkNvbm5lY3RIYW5kbGVyKTtcbiAgICB9O1xuICAgIGlmICh0aGlzLm5ka1JlbGF5LnN0YXR1cyA+PSA1IC8qIENPTk5FQ1RFRCAqLykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmFjZShbcHVibGlzaENvbm5lY3RlZCgpLCB0aW1lb3V0UHJvbWlzZV0pLmNhdGNoKG9uRXJyb3IpLmZpbmFsbHkob25GaW5hbGx5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMubmRrUmVsYXkuc3RhdHVzIDw9IDEgLyogRElTQ09OTkVDVEVEICovKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBcIlJlbGF5IGlzIGRpc2Nvbm5lY3RlZCwgdHJ5aW5nIHRvIGNvbm5lY3QgdG8gcHVibGlzaCBhbiBldmVudFwiLFxuICAgICAgICAgIHRoaXMubmRrUmVsYXkudXJsXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMubmRrUmVsYXkuY29ubmVjdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIFwiUmVsYXkgbm90IGNvbm5lY3RlZCwgd2FpdGluZyBmb3IgY29ubmVjdGlvbiB0byBwdWJsaXNoIGFuIGV2ZW50XCIsXG4gICAgICAgICAgdGhpcy5uZGtSZWxheS51cmxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm9taXNlLnJhY2UoW1xuICAgICAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgY29ubmVjdFJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgIGNvbm5lY3RSZWplY3QgPSByZWplY3Q7XG4gICAgICAgICAgdGhpcy5uZGtSZWxheS5vbmNlKFwiY29ubmVjdFwiLCBvbkNvbm5lY3RIYW5kbGVyKTtcbiAgICAgICAgfSksXG4gICAgICAgIHRpbWVvdXRQcm9taXNlXG4gICAgICBdKS5jYXRjaChvbkVycm9yKS5maW5hbGx5KG9uRmluYWxseSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIHB1Ymxpc2hFdmVudChldmVudCkge1xuICAgIHJldHVybiB0aGlzLm5ka1JlbGF5LmNvbm5lY3Rpdml0eS5wdWJsaXNoKGV2ZW50LnJhd0V2ZW50KCkpO1xuICB9XG59O1xuXG4vLyBzcmMvc3Vic2NyaXB0aW9uL2dyb3VwaW5nLnRzXG5mdW5jdGlvbiBmaWx0ZXJGaW5nZXJwcmludChmaWx0ZXJzLCBjbG9zZU9uRW9zZSkge1xuICBjb25zdCBlbGVtZW50cyA9IFtdO1xuICBmb3IgKGNvbnN0IGZpbHRlciBvZiBmaWx0ZXJzKSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5lbnRyaWVzKGZpbHRlciB8fCB7fSkubWFwKChba2V5LCB2YWx1ZXNdKSA9PiB7XG4gICAgICBpZiAoW1wic2luY2VcIiwgXCJ1bnRpbFwiXS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgIHJldHVybiBrZXkgKyBcIjpcIiArIHZhbHVlcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgICB9XG4gICAgfSkuc29ydCgpLmpvaW4oXCItXCIpO1xuICAgIGVsZW1lbnRzLnB1c2goa2V5cyk7XG4gIH1cbiAgbGV0IGlkID0gY2xvc2VPbkVvc2UgPyBcIitcIiA6IFwiXCI7XG4gIGlkICs9IGVsZW1lbnRzLmpvaW4oXCJ8XCIpO1xuICByZXR1cm4gaWQ7XG59XG5mdW5jdGlvbiBtZXJnZUZpbHRlcnMoZmlsdGVycykge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgY29uc3QgbGFzdFJlc3VsdCA9IHt9O1xuICBmaWx0ZXJzLmZpbHRlcigoZikgPT4gISFmLmxpbWl0KS5mb3JFYWNoKChmaWx0ZXJXaXRoTGltaXQpID0+IHJlc3VsdC5wdXNoKGZpbHRlcldpdGhMaW1pdCkpO1xuICBmaWx0ZXJzID0gZmlsdGVycy5maWx0ZXIoKGYpID0+ICFmLmxpbWl0KTtcbiAgaWYgKGZpbHRlcnMubGVuZ3RoID09PSAwKSByZXR1cm4gcmVzdWx0O1xuICBmaWx0ZXJzLmZvckVhY2goKGZpbHRlcikgPT4ge1xuICAgIE9iamVjdC5lbnRyaWVzKGZpbHRlcikuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKGxhc3RSZXN1bHRba2V5XSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgbGFzdFJlc3VsdFtrZXldID0gWy4uLnZhbHVlXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsYXN0UmVzdWx0W2tleV0gPSBBcnJheS5mcm9tKC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFsuLi5sYXN0UmVzdWx0W2tleV0sIC4uLnZhbHVlXSkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYXN0UmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBbLi4ucmVzdWx0LCBsYXN0UmVzdWx0XTtcbn1cblxuLy8gc3JjL3JlbGF5L3N1YnNjcmlwdGlvbi50c1xudmFyIE5ES1JlbGF5U3Vic2NyaXB0aW9uID0gY2xhc3Mge1xuICBmaW5nZXJwcmludDtcbiAgaXRlbXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB0b3BTdWJNYW5hZ2VyO1xuICBkZWJ1ZztcbiAgLyoqXG4gICAqIFRyYWNrcyB0aGUgc3RhdHVzIG9mIHRoaXMgUkVRLlxuICAgKi9cbiAgc3RhdHVzID0gMCAvKiBJTklUSUFMICovO1xuICBvbkNsb3NlO1xuICByZWxheTtcbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhpcyBzdWJzY3JpcHRpb24gaGFzIHJlYWNoZWQgRU9TRS5cbiAgICovXG4gIGVvc2VkID0gZmFsc2U7XG4gIC8qKlxuICAgKiBUaW1lb3V0IGF0IHdoaWNoIHRoaXMgc3Vic2NyaXB0aW9uIHdpbGxcbiAgICogc3RhcnQgZXhlY3V0aW5nLlxuICAgKi9cbiAgZXhlY3V0aW9uVGltZXI7XG4gIC8qKlxuICAgKiBUcmFjayB0aGUgdGltZSBhdCB3aGljaCB0aGlzIHN1YnNjcmlwdGlvbiB3aWxsIGZpcmUuXG4gICAqL1xuICBmaXJlVGltZTtcbiAgLyoqXG4gICAqIFRoZSBkZWxheSB0eXBlIHRoYXQgdGhlIGN1cnJlbnQgZmlyZVRpbWUgd2FzIGNhbGN1bGF0ZWQgd2l0aC5cbiAgICovXG4gIGRlbGF5VHlwZTtcbiAgLyoqXG4gICAqIFRoZSBmaWx0ZXJzIHRoYXQgaGF2ZSBiZWVuIGV4ZWN1dGVkLlxuICAgKi9cbiAgZXhlY3V0ZUZpbHRlcnM7XG4gIGlkID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDcpO1xuICAvKipcbiAgICpcbiAgICogQHBhcmFtIGZpbmdlcnByaW50IFRoZSBmaW5nZXJwcmludCBvZiB0aGlzIHN1YnNjcmlwdGlvbi5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHJlbGF5LCBmaW5nZXJwcmludCwgdG9wU3ViTWFuYWdlcikge1xuICAgIHRoaXMucmVsYXkgPSByZWxheTtcbiAgICB0aGlzLnRvcFN1Yk1hbmFnZXIgPSB0b3BTdWJNYW5hZ2VyO1xuICAgIHRoaXMuZGVidWcgPSByZWxheS5kZWJ1Zy5leHRlbmQoXCJzdWJzY3JpcHRpb24tXCIgKyB0aGlzLmlkKTtcbiAgICB0aGlzLmZpbmdlcnByaW50ID0gZmluZ2VycHJpbnQgfHwgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDcpO1xuICB9XG4gIF9zdWJJZDtcbiAgZ2V0IHN1YklkKCkge1xuICAgIGlmICh0aGlzLl9zdWJJZCkgcmV0dXJuIHRoaXMuX3N1YklkO1xuICAgIHRoaXMuX3N1YklkID0gdGhpcy5maW5nZXJwcmludC5zbGljZSgwLCAxNSk7XG4gICAgcmV0dXJuIHRoaXMuX3N1YklkO1xuICB9XG4gIHN1YklkUGFydHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBhZGRTdWJJZFBhcnQocGFydCkge1xuICAgIHRoaXMuc3ViSWRQYXJ0cy5hZGQocGFydCk7XG4gIH1cbiAgYWRkSXRlbShzdWJzY3JpcHRpb24sIGZpbHRlcnMpIHtcbiAgICB0aGlzLmRlYnVnKFwiQWRkaW5nIGl0ZW1cIiwgeyBmaWx0ZXJzLCBpbnRlcm5hbElkOiBzdWJzY3JpcHRpb24uaW50ZXJuYWxJZCwgc3RhdHVzOiB0aGlzLnN0YXR1cywgZmluZ2VycHJpbnQ6IHRoaXMuZmluZ2VycHJpbnQsIGlkOiB0aGlzLnN1YklkLCBpdGVtczogdGhpcy5pdGVtcywgaXRlbXNTaXplOiB0aGlzLml0ZW1zLnNpemUgfSk7XG4gICAgaWYgKHRoaXMuaXRlbXMuaGFzKHN1YnNjcmlwdGlvbi5pbnRlcm5hbElkKSkgcmV0dXJuO1xuICAgIHN1YnNjcmlwdGlvbi5vbihcImNsb3NlXCIsIHRoaXMucmVtb3ZlSXRlbS5iaW5kKHRoaXMsIHN1YnNjcmlwdGlvbikpO1xuICAgIHRoaXMuaXRlbXMuc2V0KHN1YnNjcmlwdGlvbi5pbnRlcm5hbElkLCB7IHN1YnNjcmlwdGlvbiwgZmlsdGVycyB9KTtcbiAgICBpZiAodGhpcy5zdGF0dXMgIT09IDMgLyogUlVOTklORyAqLykge1xuICAgICAgaWYgKHN1YnNjcmlwdGlvbi5zdWJJZCAmJiAoIXRoaXMuX3N1YklkIHx8IHRoaXMuX3N1YklkLmxlbmd0aCA8IDQ4KSkge1xuICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IDAgLyogSU5JVElBTCAqLyB8fCB0aGlzLnN0YXR1cyA9PT0gMSAvKiBQRU5ESU5HICovKSB7XG4gICAgICAgICAgdGhpcy5hZGRTdWJJZFBhcnQoc3Vic2NyaXB0aW9uLnN1YklkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBzd2l0Y2ggKHRoaXMuc3RhdHVzKSB7XG4gICAgICBjYXNlIDAgLyogSU5JVElBTCAqLzpcbiAgICAgICAgdGhpcy5ldmFsdWF0ZUV4ZWN1dGlvblBsYW4oc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDMgLyogUlVOTklORyAqLzpcbiAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgXCJCVUc6IFRoaXMgc2hvdWxkIG5vdCBoYXBwZW46IFRoaXMgc3Vic2NyaXB0aW9uIG5lZWRzIHRvIGNhdGNoIHVwIHdpdGggYSBzdWJzY3JpcHRpb24gdGhhdCB3YXMgYWxyZWFkeSBydW5uaW5nXCIsXG4gICAgICAgICAgZmlsdGVyc1xuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMSAvKiBQRU5ESU5HICovOlxuICAgICAgICB0aGlzLmV2YWx1YXRlRXhlY3V0aW9uUGxhbihzdWJzY3JpcHRpb24pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNCAvKiBDTE9TRUQgKi86XG4gICAgICAgIHRoaXMuZGVidWcoXG4gICAgICAgICAgXCJTdWJzY3JpcHRpb24gaXMgY2xvc2VkLCBjYW5ub3QgYWRkIG5ldyBpdGVtcyAlbyAoJW8pXCIsXG4gICAgICAgICAgc3Vic2NyaXB0aW9uLFxuICAgICAgICAgIGZpbHRlcnNcbiAgICAgICAgKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGFkZCBuZXcgaXRlbXMgdG8gYSBjbG9zZWQgc3Vic2NyaXB0aW9uXCIpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQSBzdWJzY3JpcHRpb24gaGFzIGJlZW4gY2xvc2VkLCByZW1vdmUgaXQgZnJvbSB0aGUgbGlzdCBvZiBpdGVtcy5cbiAgICogQHBhcmFtIHN1YnNjcmlwdGlvblxuICAgKi9cbiAgcmVtb3ZlSXRlbShzdWJzY3JpcHRpb24pIHtcbiAgICB0aGlzLml0ZW1zLmRlbGV0ZShzdWJzY3JpcHRpb24uaW50ZXJuYWxJZCk7XG4gICAgaWYgKHRoaXMuaXRlbXMuc2l6ZSA9PT0gMCkge1xuICAgICAgaWYgKCF0aGlzLmVvc2VkKSByZXR1cm47XG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICB0aGlzLmNsZWFudXAoKTtcbiAgICB9XG4gIH1cbiAgY2xvc2UoKSB7XG4gICAgaWYgKHRoaXMuc3RhdHVzID09PSA0IC8qIENMT1NFRCAqLykgcmV0dXJuO1xuICAgIGNvbnN0IHByZXZTdGF0dXMgPSB0aGlzLnN0YXR1cztcbiAgICB0aGlzLnN0YXR1cyA9IDQgLyogQ0xPU0VEICovO1xuICAgIGlmIChwcmV2U3RhdHVzID09PSAzIC8qIFJVTk5JTkcgKi8pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMucmVsYXkuY2xvc2UodGhpcy5zdWJJZCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRoaXMuZGVidWcoXCJFcnJvciBjbG9zaW5nIHN1YnNjcmlwdGlvblwiLCBlLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kZWJ1ZyhcIlN1YnNjcmlwdGlvbiB3YW50ZWQgdG8gY2xvc2UgYnV0IGl0IHdhc24ndCBydW5uaW5nLCB0aGlzIGlzIHByb2JhYmx5IG9rXCIsIHtcbiAgICAgICAgc3ViSWQ6IHRoaXMuc3ViSWQsXG4gICAgICAgIHByZXZTdGF0dXMsXG4gICAgICAgIHN1YjogdGhpc1xuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuY2xlYW51cCgpO1xuICB9XG4gIGNsZWFudXAoKSB7XG4gICAgaWYgKHRoaXMuZXhlY3V0aW9uVGltZXIpIGNsZWFyVGltZW91dCh0aGlzLmV4ZWN1dGlvblRpbWVyKTtcbiAgICB0aGlzLnJlbGF5Lm9mZihcInJlYWR5XCIsIHRoaXMuZXhlY3V0ZU9uUmVsYXlSZWFkeSk7XG4gICAgdGhpcy5yZWxheS5vZmYoXCJhdXRoZWRcIiwgdGhpcy5yZUV4ZWN1dGVBZnRlckF1dGgpO1xuICAgIGlmICh0aGlzLm9uQ2xvc2UpIHRoaXMub25DbG9zZSh0aGlzKTtcbiAgfVxuICBldmFsdWF0ZUV4ZWN1dGlvblBsYW4oc3Vic2NyaXB0aW9uKSB7XG4gICAgaWYgKCFzdWJzY3JpcHRpb24uaXNHcm91cGFibGUoKSkge1xuICAgICAgdGhpcy5zdGF0dXMgPSAxIC8qIFBFTkRJTkcgKi87XG4gICAgICB0aGlzLmV4ZWN1dGUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHN1YnNjcmlwdGlvbi5maWx0ZXJzLmZpbmQoKGZpbHRlcikgPT4gISFmaWx0ZXIubGltaXQpKSB7XG4gICAgICB0aGlzLmV4ZWN1dGVGaWx0ZXJzID0gdGhpcy5jb21waWxlRmlsdGVycygpO1xuICAgICAgaWYgKHRoaXMuZXhlY3V0ZUZpbHRlcnMubGVuZ3RoID49IDEwKSB7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gMSAvKiBQRU5ESU5HICovO1xuICAgICAgICB0aGlzLmV4ZWN1dGUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBkZWxheSA9IHN1YnNjcmlwdGlvbi5ncm91cGFibGVEZWxheTtcbiAgICBjb25zdCBkZWxheVR5cGUgPSBzdWJzY3JpcHRpb24uZ3JvdXBhYmxlRGVsYXlUeXBlO1xuICAgIGlmICghZGVsYXkpIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBncm91cCBhIHN1YnNjcmlwdGlvbiB3aXRob3V0IGEgZGVsYXlcIik7XG4gICAgaWYgKHRoaXMuc3RhdHVzID09PSAwIC8qIElOSVRJQUwgKi8pIHtcbiAgICAgIHRoaXMuc2NoZWR1bGUoZGVsYXksIGRlbGF5VHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nRGVsYXlUeXBlID0gdGhpcy5kZWxheVR5cGU7XG4gICAgICBjb25zdCB0aW1lVW50aWxGaXJlID0gdGhpcy5maXJlVGltZSAtIERhdGUubm93KCk7XG4gICAgICBpZiAoZXhpc3RpbmdEZWxheVR5cGUgPT09IFwiYXQtbGVhc3RcIiAmJiBkZWxheVR5cGUgPT09IFwiYXQtbGVhc3RcIikge1xuICAgICAgICBpZiAodGltZVVudGlsRmlyZSA8IGRlbGF5KSB7XG4gICAgICAgICAgaWYgKHRoaXMuZXhlY3V0aW9uVGltZXIpIGNsZWFyVGltZW91dCh0aGlzLmV4ZWN1dGlvblRpbWVyKTtcbiAgICAgICAgICB0aGlzLnNjaGVkdWxlKGRlbGF5LCBkZWxheVR5cGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGV4aXN0aW5nRGVsYXlUeXBlID09PSBcImF0LWxlYXN0XCIgJiYgZGVsYXlUeXBlID09PSBcImF0LW1vc3RcIikge1xuICAgICAgICBpZiAodGltZVVudGlsRmlyZSA+IGRlbGF5KSB7XG4gICAgICAgICAgaWYgKHRoaXMuZXhlY3V0aW9uVGltZXIpIGNsZWFyVGltZW91dCh0aGlzLmV4ZWN1dGlvblRpbWVyKTtcbiAgICAgICAgICB0aGlzLnNjaGVkdWxlKGRlbGF5LCBkZWxheVR5cGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGV4aXN0aW5nRGVsYXlUeXBlID09PSBcImF0LW1vc3RcIiAmJiBkZWxheVR5cGUgPT09IFwiYXQtbW9zdFwiKSB7XG4gICAgICAgIGlmICh0aW1lVW50aWxGaXJlID4gZGVsYXkpIHtcbiAgICAgICAgICBpZiAodGhpcy5leGVjdXRpb25UaW1lcikgY2xlYXJUaW1lb3V0KHRoaXMuZXhlY3V0aW9uVGltZXIpO1xuICAgICAgICAgIHRoaXMuc2NoZWR1bGUoZGVsYXksIGRlbGF5VHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZXhpc3RpbmdEZWxheVR5cGUgPT09IFwiYXQtbW9zdFwiICYmIGRlbGF5VHlwZSA9PT0gXCJhdC1sZWFzdFwiKSB7XG4gICAgICAgIGlmICh0aW1lVW50aWxGaXJlID4gZGVsYXkpIHtcbiAgICAgICAgICBpZiAodGhpcy5leGVjdXRpb25UaW1lcikgY2xlYXJUaW1lb3V0KHRoaXMuZXhlY3V0aW9uVGltZXIpO1xuICAgICAgICAgIHRoaXMuc2NoZWR1bGUoZGVsYXksIGRlbGF5VHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIlVua25vd24gZGVsYXkgdHlwZSBjb21iaW5hdGlvbiBcIiArIGV4aXN0aW5nRGVsYXlUeXBlICsgXCIgXCIgKyBkZWxheVR5cGVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc2NoZWR1bGUoZGVsYXksIGRlbGF5VHlwZSkge1xuICAgIHRoaXMuc3RhdHVzID0gMSAvKiBQRU5ESU5HICovO1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICB0aGlzLmZpcmVUaW1lID0gY3VycmVudFRpbWUgKyBkZWxheTtcbiAgICB0aGlzLmRlbGF5VHlwZSA9IGRlbGF5VHlwZTtcbiAgICBjb25zdCB0aW1lciA9IHNldFRpbWVvdXQodGhpcy5leGVjdXRlLmJpbmQodGhpcyksIGRlbGF5KTtcbiAgICBpZiAoZGVsYXlUeXBlID09PSBcImF0LWxlYXN0XCIpIHtcbiAgICAgIHRoaXMuZXhlY3V0aW9uVGltZXIgPSB0aW1lcjtcbiAgICB9XG4gIH1cbiAgZXhlY3V0ZU9uUmVsYXlSZWFkeSA9ICgpID0+IHtcbiAgICBpZiAodGhpcy5zdGF0dXMgIT09IDIgLyogV0FJVElORyAqLykgcmV0dXJuO1xuICAgIGlmICh0aGlzLml0ZW1zLnNpemUgPT09IDApIHtcbiAgICAgIHRoaXMuZGVidWcoXCJObyBpdGVtcyB0byBleGVjdXRlOyB0aGlzIHJlbGF5IHdhcyBwcm9iYWJseSB0b28gc2xvdyB0byByZXNwb25kIGFuZCB0aGUgY2FsbGVyIGdhdmUgdXBcIiwgeyBzdGF0dXM6IHRoaXMuc3RhdHVzLCBmaW5nZXJwcmludDogdGhpcy5maW5nZXJwcmludCwgaXRlbXM6IHRoaXMuaXRlbXMsIGl0ZW1zU2l6ZTogdGhpcy5pdGVtcy5zaXplLCBpZDogdGhpcy5pZCwgc3ViSWQ6IHRoaXMuc3ViSWQgfSk7XG4gICAgICB0aGlzLmNsZWFudXAoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5kZWJ1ZyhcIkV4ZWN1dGluZyBvbiByZWxheSByZWFkeVwiLCB7IHN0YXR1czogdGhpcy5zdGF0dXMsIGZpbmdlcnByaW50OiB0aGlzLmZpbmdlcnByaW50LCBpdGVtczogdGhpcy5pdGVtcywgaXRlbXNTaXplOiB0aGlzLml0ZW1zLnNpemUgfSk7XG4gICAgdGhpcy5zdGF0dXMgPSAxIC8qIFBFTkRJTkcgKi87XG4gICAgdGhpcy5leGVjdXRlKCk7XG4gIH07XG4gIGZpbmFsaXplU3ViSWQoKSB7XG4gICAgaWYgKHRoaXMuc3ViSWRQYXJ0cy5zaXplID4gMCkge1xuICAgICAgdGhpcy5fc3ViSWQgPSBBcnJheS5mcm9tKHRoaXMuc3ViSWRQYXJ0cykuam9pbihcIi1cIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3N1YklkID0gdGhpcy5maW5nZXJwcmludC5zbGljZSgwLCAxNSk7XG4gICAgfVxuICAgIHRoaXMuX3N1YklkICs9IFwiLVwiICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDcpO1xuICB9XG4gIC8vIHdlIGRvIGl0IHRoaXMgd2F5IHNvIHRoYXQgd2UgY2FuIHJlbW92ZSB0aGUgbGlzdGVuZXJcbiAgcmVFeGVjdXRlQWZ0ZXJBdXRoID0gKCgpID0+IHtcbiAgICBjb25zdCBvbGRTdWJJZCA9IHRoaXMuc3ViSWQ7XG4gICAgdGhpcy5kZWJ1ZyhcIlJlLWV4ZWN1dGluZyBhZnRlciBhdXRoXCIsIHRoaXMuaXRlbXMuc2l6ZSk7XG4gICAgaWYgKHRoaXMuZW9zZWQpIHtcbiAgICAgIHRoaXMucmVsYXkuY2xvc2UodGhpcy5zdWJJZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVidWcoXG4gICAgICAgIFwiV2UgYXJlIGFiYW5kb25pbmcgYW4gb3BlbmVkIHN1YnNjcmlwdGlvbiwgb25jZSBpdCBFT1NFJ3MsIHRoZSBoYW5kbGVyIHdpbGwgY2xvc2UgaXRcIixcbiAgICAgICAgeyBvbGRTdWJJZCB9XG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLl9zdWJJZCA9IHZvaWQgMDtcbiAgICB0aGlzLnN0YXR1cyA9IDEgLyogUEVORElORyAqLztcbiAgICB0aGlzLmV4ZWN1dGUoKTtcbiAgICB0aGlzLmRlYnVnKFwiUmUtZXhlY3V0ZWQgYWZ0ZXIgYXV0aCAlcyBcXHV7MUY0NDl9ICVzXCIsIG9sZFN1YklkLCB0aGlzLnN1YklkKTtcbiAgfSkuYmluZCh0aGlzKTtcbiAgZXhlY3V0ZSgpIHtcbiAgICBpZiAodGhpcy5zdGF0dXMgIT09IDEgLyogUEVORElORyAqLykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMucmVsYXkuY29ubmVjdGVkKSB7XG4gICAgICB0aGlzLnN0YXR1cyA9IDIgLyogV0FJVElORyAqLztcbiAgICAgIHRoaXMuZGVidWcoXCJXYWl0aW5nIGZvciByZWxheSB0byBiZSByZWFkeVwiLCB7IHN0YXR1czogdGhpcy5zdGF0dXMsIGlkOiB0aGlzLnN1YklkLCBmaW5nZXJwcmludDogdGhpcy5maW5nZXJwcmludCwgaXRlbXM6IHRoaXMuaXRlbXMsIGl0ZW1zU2l6ZTogdGhpcy5pdGVtcy5zaXplIH0pO1xuICAgICAgdGhpcy5yZWxheS5vbmNlKFwicmVhZHlcIiwgdGhpcy5leGVjdXRlT25SZWxheVJlYWR5KTtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKHRoaXMucmVsYXkuc3RhdHVzIDwgOCAvKiBBVVRIRU5USUNBVEVEICovKSB7XG4gICAgICB0aGlzLnJlbGF5Lm9uY2UoXCJhdXRoZWRcIiwgdGhpcy5yZUV4ZWN1dGVBZnRlckF1dGgpO1xuICAgIH1cbiAgICB0aGlzLnN0YXR1cyA9IDMgLyogUlVOTklORyAqLztcbiAgICB0aGlzLmZpbmFsaXplU3ViSWQoKTtcbiAgICB0aGlzLmV4ZWN1dGVGaWx0ZXJzID0gdGhpcy5jb21waWxlRmlsdGVycygpO1xuICAgIHRoaXMucmVsYXkucmVxKHRoaXMpO1xuICB9XG4gIG9uc3RhcnQoKSB7XG4gIH1cbiAgb25ldmVudChldmVudCkge1xuICAgIHRoaXMudG9wU3ViTWFuYWdlci5kaXNwYXRjaEV2ZW50KGV2ZW50LCB0aGlzLnJlbGF5KTtcbiAgfVxuICBvbmVvc2Uoc3ViSWQpIHtcbiAgICB0aGlzLmVvc2VkID0gdHJ1ZTtcbiAgICBpZiAoc3ViSWQgIT09IHRoaXMuc3ViSWQpIHtcbiAgICAgIHRoaXMuZGVidWcoXCJSZWNlaXZlZCBFT1NFIGZvciBhbiBhYmFuZG9uZWQgc3Vic2NyaXB0aW9uXCIsIHN1YklkLCB0aGlzLnN1YklkKTtcbiAgICAgIHRoaXMucmVsYXkuY2xvc2Uoc3ViSWQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5pdGVtcy5zaXplID09PSAwKSB7XG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgeyBzdWJzY3JpcHRpb24gfSBvZiB0aGlzLml0ZW1zLnZhbHVlcygpKSB7XG4gICAgICBzdWJzY3JpcHRpb24uZW9zZVJlY2VpdmVkKHRoaXMucmVsYXkpO1xuICAgICAgaWYgKHN1YnNjcmlwdGlvbi5jbG9zZU9uRW9zZSkge1xuICAgICAgICB0aGlzLmRlYnVnKFwiUmVtb3ZpbmcgaXRlbSBiZWNhdXNlIG9mIEVPU0VcIiwgeyBmaWx0ZXJzOiBzdWJzY3JpcHRpb24uZmlsdGVycywgaW50ZXJuYWxJZDogc3Vic2NyaXB0aW9uLmludGVybmFsSWQsIHN0YXR1czogdGhpcy5zdGF0dXMsIGZpbmdlcnByaW50OiB0aGlzLmZpbmdlcnByaW50LCBpdGVtczogdGhpcy5pdGVtcywgaXRlbXNTaXplOiB0aGlzLml0ZW1zLnNpemUgfSk7XG4gICAgICAgIHRoaXMucmVtb3ZlSXRlbShzdWJzY3JpcHRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBvbmNsb3NlKHJlYXNvbikge1xuICAgIHRoaXMuc3RhdHVzID0gNCAvKiBDTE9TRUQgKi87XG4gIH1cbiAgb25jbG9zZWQocmVhc29uKSB7XG4gICAgaWYgKCFyZWFzb24pIHJldHVybjtcbiAgICBmb3IgKGNvbnN0IHsgc3Vic2NyaXB0aW9uIH0gb2YgdGhpcy5pdGVtcy52YWx1ZXMoKSkge1xuICAgICAgc3Vic2NyaXB0aW9uLmNsb3NlZFJlY2VpdmVkKHRoaXMucmVsYXksIHJlYXNvbik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBHcmFicyB0aGUgZmlsdGVycyBmcm9tIGFsbCB0aGUgc3Vic2NyaXB0aW9uc1xuICAgKiBhbmQgbWVyZ2VzIHRoZW0gaW50byBhIHNpbmdsZSBmaWx0ZXIuXG4gICAqL1xuICBjb21waWxlRmlsdGVycygpIHtcbiAgICBjb25zdCBtZXJnZWRGaWx0ZXJzID0gW107XG4gICAgY29uc3QgZmlsdGVycyA9IEFycmF5LmZyb20odGhpcy5pdGVtcy52YWx1ZXMoKSkubWFwKChpdGVtKSA9PiBpdGVtLmZpbHRlcnMpO1xuICAgIGlmICghZmlsdGVyc1swXSkge1xuICAgICAgdGhpcy5kZWJ1ZyhcIlxcdXsxRjQ0MH0gTm8gZmlsdGVycyB0byBtZXJnZVwiLCB0aGlzLml0ZW1zKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJCVUc6IE5vIGZpbHRlcnMgdG8gbWVyZ2UhXCIsIHRoaXMuaXRlbXMpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCBmaWx0ZXJDb3VudCA9IGZpbHRlcnNbMF0ubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlsdGVyQ291bnQ7IGkrKykge1xuICAgICAgY29uc3QgYWxsRmlsdGVyc0F0SW5kZXggPSBmaWx0ZXJzLm1hcCgoZmlsdGVyKSA9PiBmaWx0ZXJbaV0pO1xuICAgICAgbWVyZ2VkRmlsdGVycy5wdXNoKC4uLm1lcmdlRmlsdGVycyhhbGxGaWx0ZXJzQXRJbmRleCkpO1xuICAgIH1cbiAgICByZXR1cm4gbWVyZ2VkRmlsdGVycztcbiAgfVxufTtcblxuLy8gc3JjL3JlbGF5L3N1Yi1tYW5hZ2VyLnRzXG52YXIgTkRLUmVsYXlTdWJzY3JpcHRpb25NYW5hZ2VyID0gY2xhc3Mge1xuICByZWxheTtcbiAgc3Vic2NyaXB0aW9ucztcbiAgZ2VuZXJhbFN1Yk1hbmFnZXI7XG4gIC8qKlxuICAgKiBAcGFyYW0gcmVsYXkgLSBUaGUgcmVsYXkgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSBnZW5lcmFsU3ViTWFuYWdlciAtIFRoZSBzdWJzY3JpcHRpb24gbWFuYWdlciBpbnN0YW5jZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHJlbGF5LCBnZW5lcmFsU3ViTWFuYWdlcikge1xuICAgIHRoaXMucmVsYXkgPSByZWxheTtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuZ2VuZXJhbFN1Yk1hbmFnZXIgPSBnZW5lcmFsU3ViTWFuYWdlcjtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIHN1YnNjcmlwdGlvbiB0byB0aGUgbWFuYWdlci5cbiAgICovXG4gIGFkZFN1YnNjcmlwdGlvbihzdWIsIGZpbHRlcnMpIHtcbiAgICBsZXQgcmVsYXlTdWI7XG4gICAgaWYgKCFzdWIuaXNHcm91cGFibGUoKSkge1xuICAgICAgcmVsYXlTdWIgPSB0aGlzLmNyZWF0ZVN1YnNjcmlwdGlvbihzdWIsIGZpbHRlcnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBmaWx0ZXJGcCA9IGZpbHRlckZpbmdlcnByaW50KGZpbHRlcnMsIHN1Yi5jbG9zZU9uRW9zZSk7XG4gICAgICBpZiAoZmlsdGVyRnApIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdTdWJzID0gdGhpcy5zdWJzY3JpcHRpb25zLmdldChmaWx0ZXJGcCk7XG4gICAgICAgIHJlbGF5U3ViID0gKGV4aXN0aW5nU3VicyB8fCBbXSkuZmluZChcbiAgICAgICAgICAoc3ViMikgPT4gc3ViMi5zdGF0dXMgPCAzIC8qIFJVTk5JTkcgKi9cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJlbGF5U3ViID8/PSB0aGlzLmNyZWF0ZVN1YnNjcmlwdGlvbihzdWIsIGZpbHRlcnMsIGZpbHRlckZwKTtcbiAgICB9XG4gICAgcmVsYXlTdWIuYWRkSXRlbShzdWIsIGZpbHRlcnMpO1xuICB9XG4gIGNyZWF0ZVN1YnNjcmlwdGlvbihzdWIsIGZpbHRlcnMsIGZpbmdlcnByaW50KSB7XG4gICAgY29uc3QgcmVsYXlTdWIgPSBuZXcgTkRLUmVsYXlTdWJzY3JpcHRpb24odGhpcy5yZWxheSwgZmluZ2VycHJpbnQgfHwgbnVsbCwgdGhpcy5nZW5lcmFsU3ViTWFuYWdlcik7XG4gICAgcmVsYXlTdWIub25DbG9zZSA9IHRoaXMub25SZWxheVN1YnNjcmlwdGlvbkNsb3NlLmJpbmQodGhpcyk7XG4gICAgY29uc3QgY3VycmVudFZhbCA9IHRoaXMuc3Vic2NyaXB0aW9ucy5nZXQocmVsYXlTdWIuZmluZ2VycHJpbnQpID8/IFtdO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5zZXQocmVsYXlTdWIuZmluZ2VycHJpbnQsIFsuLi5jdXJyZW50VmFsLCByZWxheVN1Yl0pO1xuICAgIHJldHVybiByZWxheVN1YjtcbiAgfVxuICBvblJlbGF5U3Vic2NyaXB0aW9uQ2xvc2Uoc3ViKSB7XG4gICAgbGV0IGN1cnJlbnRWYWwgPSB0aGlzLnN1YnNjcmlwdGlvbnMuZ2V0KHN1Yi5maW5nZXJwcmludCkgPz8gW107XG4gICAgaWYgKCFjdXJyZW50VmFsKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIFwiVW5leHBlY3RlZGx5IGRpZCBub3QgZmluZCBhIHN1YnNjcmlwdGlvbiB3aXRoIGZpbmdlcnByaW50XCIsXG4gICAgICAgIHN1Yi5maW5nZXJwcmludFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnRWYWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZGVsZXRlKHN1Yi5maW5nZXJwcmludCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnRWYWwgPSBjdXJyZW50VmFsLmZpbHRlcigocykgPT4gcy5pZCAhPT0gc3ViLmlkKTtcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5zZXQoc3ViLmZpbmdlcnByaW50LCBjdXJyZW50VmFsKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9yZWxheS9pbmRleC50c1xudmFyIE5ES1JlbGF5U3RhdHVzID0gLyogQF9fUFVSRV9fICovICgoTkRLUmVsYXlTdGF0dXMyKSA9PiB7XG4gIE5ES1JlbGF5U3RhdHVzMltOREtSZWxheVN0YXR1czJbXCJESVNDT05ORUNUSU5HXCJdID0gMF0gPSBcIkRJU0NPTk5FQ1RJTkdcIjtcbiAgTkRLUmVsYXlTdGF0dXMyW05ES1JlbGF5U3RhdHVzMltcIkRJU0NPTk5FQ1RFRFwiXSA9IDFdID0gXCJESVNDT05ORUNURURcIjtcbiAgTkRLUmVsYXlTdGF0dXMyW05ES1JlbGF5U3RhdHVzMltcIlJFQ09OTkVDVElOR1wiXSA9IDJdID0gXCJSRUNPTk5FQ1RJTkdcIjtcbiAgTkRLUmVsYXlTdGF0dXMyW05ES1JlbGF5U3RhdHVzMltcIkZMQVBQSU5HXCJdID0gM10gPSBcIkZMQVBQSU5HXCI7XG4gIE5ES1JlbGF5U3RhdHVzMltOREtSZWxheVN0YXR1czJbXCJDT05ORUNUSU5HXCJdID0gNF0gPSBcIkNPTk5FQ1RJTkdcIjtcbiAgTkRLUmVsYXlTdGF0dXMyW05ES1JlbGF5U3RhdHVzMltcIkNPTk5FQ1RFRFwiXSA9IDVdID0gXCJDT05ORUNURURcIjtcbiAgTkRLUmVsYXlTdGF0dXMyW05ES1JlbGF5U3RhdHVzMltcIkFVVEhfUkVRVUVTVEVEXCJdID0gNl0gPSBcIkFVVEhfUkVRVUVTVEVEXCI7XG4gIE5ES1JlbGF5U3RhdHVzMltOREtSZWxheVN0YXR1czJbXCJBVVRIRU5USUNBVElOR1wiXSA9IDddID0gXCJBVVRIRU5USUNBVElOR1wiO1xuICBOREtSZWxheVN0YXR1czJbTkRLUmVsYXlTdGF0dXMyW1wiQVVUSEVOVElDQVRFRFwiXSA9IDhdID0gXCJBVVRIRU5USUNBVEVEXCI7XG4gIHJldHVybiBOREtSZWxheVN0YXR1czI7XG59KShOREtSZWxheVN0YXR1cyB8fCB7fSk7XG52YXIgTkRLUmVsYXkgPSBjbGFzcyBfTkRLUmVsYXkgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICB1cmw7XG4gIHNjb3JlcztcbiAgY29ubmVjdGl2aXR5O1xuICBzdWJzO1xuICBwdWJsaXNoZXI7XG4gIGF1dGhQb2xpY3k7XG4gIC8qKlxuICAgKiBUaGUgbG93ZXN0IHZhbGlkYXRpb24gcmF0aW8gdGhpcyByZWxheSBjYW4gcmVhY2guXG4gICAqL1xuICBsb3dlc3RWYWxpZGF0aW9uUmF0aW87XG4gIC8qKlxuICAgKiBDdXJyZW50IHZhbGlkYXRpb24gcmF0aW8gdGhpcyByZWxheSBpcyB0YXJnZXRpbmcuXG4gICAqL1xuICB0YXJnZXRWYWxpZGF0aW9uUmF0aW87XG4gIHZhbGlkYXRpb25SYXRpb0ZuO1xuICAvKipcbiAgICogVGhpcyB0cmFja3MgZXZlbnRzIHRoYXQgaGF2ZSBiZWVuIHNlZW4gYnkgdGhpcyByZWxheVxuICAgKiB3aXRoIGEgdmFsaWQgc2lnbmF0dXJlLlxuICAgKi9cbiAgdmFsaWRhdGVkRXZlbnRDb3VudCA9IDA7XG4gIC8qKlxuICAgKiBUaGlzIHRyYWNrcyBldmVudHMgdGhhdCBoYXZlIGJlZW4gc2VlbiBieSB0aGlzIHJlbGF5XG4gICAqIGJ1dCBoYXZlIG5vdCBiZWVuIHZhbGlkYXRlZC5cbiAgICovXG4gIG5vblZhbGlkYXRlZEV2ZW50Q291bnQgPSAwO1xuICAvKipcbiAgICogV2hldGhlciB0aGlzIHJlbGF5IGlzIHRydXN0ZWQuXG4gICAqXG4gICAqIFRydXN0ZWQgcmVsYXkncyBldmVudHMgZG8gbm90IGdldCB0aGVpciBzaWduYXR1cmUgdmVyaWZpZWQuXG4gICAqL1xuICB0cnVzdGVkID0gZmFsc2U7XG4gIGNvbXBsYWluaW5nID0gZmFsc2U7XG4gIGRlYnVnO1xuICBzdGF0aWMgZGVmYXVsdFZhbGlkYXRpb25SYXRpb1VwZGF0ZUZuID0gKHJlbGF5LCB2YWxpZGF0ZWRDb3VudCwgbm9uVmFsaWRhdGVkQ291bnQpID0+IHtcbiAgICBpZiAocmVsYXkubG93ZXN0VmFsaWRhdGlvblJhdGlvID09PSB2b2lkIDAgfHwgcmVsYXkudGFyZ2V0VmFsaWRhdGlvblJhdGlvID09PSB2b2lkIDApXG4gICAgICByZXR1cm4gMTtcbiAgICBsZXQgbmV3UmF0aW8gPSByZWxheS52YWxpZGF0aW9uUmF0aW87XG4gICAgaWYgKHJlbGF5LnZhbGlkYXRpb25SYXRpbyA+IHJlbGF5LnRhcmdldFZhbGlkYXRpb25SYXRpbykge1xuICAgICAgY29uc3QgZmFjdG9yID0gdmFsaWRhdGVkQ291bnQgLyAxMDA7XG4gICAgICBuZXdSYXRpbyA9IE1hdGgubWF4KHJlbGF5Lmxvd2VzdFZhbGlkYXRpb25SYXRpbywgcmVsYXkudmFsaWRhdGlvblJhdGlvIC0gZmFjdG9yKTtcbiAgICB9XG4gICAgaWYgKG5ld1JhdGlvIDwgcmVsYXkudmFsaWRhdGlvblJhdGlvKSB7XG4gICAgICByZXR1cm4gbmV3UmF0aW87XG4gICAgfVxuICAgIHJldHVybiByZWxheS52YWxpZGF0aW9uUmF0aW87XG4gIH07XG4gIGNvbnN0cnVjdG9yKHVybCwgYXV0aFBvbGljeSwgbmRrKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnVybCA9IG5vcm1hbGl6ZVJlbGF5VXJsKHVybCk7XG4gICAgdGhpcy5zY29yZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuZGVidWcgPSBkZWJ1ZyhgbmRrOnJlbGF5OiR7dXJsfWApO1xuICAgIHRoaXMuY29ubmVjdGl2aXR5ID0gbmV3IE5ES1JlbGF5Q29ubmVjdGl2aXR5KHRoaXMsIG5kayk7XG4gICAgdGhpcy5jb25uZWN0aXZpdHkubmV0RGVidWcgPSBuZGs/Lm5ldERlYnVnO1xuICAgIHRoaXMucmVxID0gdGhpcy5jb25uZWN0aXZpdHkucmVxLmJpbmQodGhpcy5jb25uZWN0aXZpdHkpO1xuICAgIHRoaXMuY2xvc2UgPSB0aGlzLmNvbm5lY3Rpdml0eS5jbG9zZS5iaW5kKHRoaXMuY29ubmVjdGl2aXR5KTtcbiAgICB0aGlzLnN1YnMgPSBuZXcgTkRLUmVsYXlTdWJzY3JpcHRpb25NYW5hZ2VyKHRoaXMsIG5kay5zdWJNYW5hZ2VyKTtcbiAgICB0aGlzLnB1Ymxpc2hlciA9IG5ldyBOREtSZWxheVB1Ymxpc2hlcih0aGlzKTtcbiAgICB0aGlzLmF1dGhQb2xpY3kgPSBhdXRoUG9saWN5O1xuICAgIHRoaXMudGFyZ2V0VmFsaWRhdGlvblJhdGlvID0gbmRrPy5pbml0aWFsVmFsaWRhdGlvblJhdGlvO1xuICAgIHRoaXMubG93ZXN0VmFsaWRhdGlvblJhdGlvID0gbmRrPy5sb3dlc3RWYWxpZGF0aW9uUmF0aW87XG4gICAgdGhpcy52YWxpZGF0aW9uUmF0aW9GbiA9IChuZGs/LnZhbGlkYXRpb25SYXRpb0ZuID8/IF9OREtSZWxheS5kZWZhdWx0VmFsaWRhdGlvblJhdGlvVXBkYXRlRm4pLmJpbmQodGhpcyk7XG4gICAgdGhpcy51cGRhdGVWYWxpZGF0aW9uUmF0aW8oKTtcbiAgICBpZiAoIW5kaykge1xuICAgICAgY29uc29sZS50cmFjZShcInJlbGF5IGNyZWF0ZWQgd2l0aG91dCBuZGtcIik7XG4gICAgfVxuICB9XG4gIHVwZGF0ZVZhbGlkYXRpb25SYXRpbygpIHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMudXBkYXRlVmFsaWRhdGlvblJhdGlvKCk7XG4gICAgfSwgM2U0KTtcbiAgfVxuICBnZXQgc3RhdHVzKCkge1xuICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpdml0eS5zdGF0dXM7XG4gIH1cbiAgZ2V0IGNvbm5lY3Rpb25TdGF0cygpIHtcbiAgICByZXR1cm4gdGhpcy5jb25uZWN0aXZpdHkuY29ubmVjdGlvblN0YXRzO1xuICB9XG4gIC8qKlxuICAgKiBDb25uZWN0cyB0byB0aGUgcmVsYXkuXG4gICAqL1xuICBhc3luYyBjb25uZWN0KHRpbWVvdXRNcywgcmVjb25uZWN0ID0gdHJ1ZSkge1xuICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpdml0eS5jb25uZWN0KHRpbWVvdXRNcywgcmVjb25uZWN0KTtcbiAgfVxuICAvKipcbiAgICogRGlzY29ubmVjdHMgZnJvbSB0aGUgcmVsYXkuXG4gICAqL1xuICBkaXNjb25uZWN0KCkge1xuICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gMSAvKiBESVNDT05ORUNURUQgKi8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jb25uZWN0aXZpdHkuZGlzY29ubmVjdCgpO1xuICB9XG4gIC8qKlxuICAgKiBRdWV1ZXMgb3IgZXhlY3V0ZXMgdGhlIHN1YnNjcmlwdGlvbiBvZiBhIHNwZWNpZmljIHNldCBvZiBmaWx0ZXJzXG4gICAqIHdpdGhpbiB0aGlzIHJlbGF5LlxuICAgKlxuICAgKiBAcGFyYW0gc3Vic2NyaXB0aW9uIE5ES1N1YnNjcmlwdGlvbiB0aGlzIGZpbHRlcnMgYmVsb25nIHRvLlxuICAgKiBAcGFyYW0gZmlsdGVycyBGaWx0ZXJzIHRvIGV4ZWN1dGVcbiAgICovXG4gIHN1YnNjcmliZShzdWJzY3JpcHRpb24sIGZpbHRlcnMpIHtcbiAgICB0aGlzLnN1YnMuYWRkU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbiwgZmlsdGVycyk7XG4gIH1cbiAgLyoqXG4gICAqIFB1Ymxpc2hlcyBhbiBldmVudCB0byB0aGUgcmVsYXkgd2l0aCBhbiBvcHRpb25hbCB0aW1lb3V0LlxuICAgKlxuICAgKiBJZiB0aGUgcmVsYXkgaXMgbm90IGNvbm5lY3RlZCwgdGhlIGV2ZW50IHdpbGwgYmUgcHVibGlzaGVkIHdoZW4gdGhlIHJlbGF5IGNvbm5lY3RzLFxuICAgKiB1bmxlc3MgdGhlIHRpbWVvdXQgaXMgcmVhY2hlZCBiZWZvcmUgdGhlIHJlbGF5IGNvbm5lY3RzLlxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQgVGhlIGV2ZW50IHRvIHB1Ymxpc2hcbiAgICogQHBhcmFtIHRpbWVvdXRNcyBUaGUgdGltZW91dCBmb3IgdGhlIHB1Ymxpc2ggb3BlcmF0aW9uIGluIG1pbGxpc2Vjb25kc1xuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBldmVudCBoYXMgYmVlbiBwdWJsaXNoZWQgb3IgcmVqZWN0cyBpZiB0aGUgb3BlcmF0aW9uIHRpbWVzIG91dFxuICAgKi9cbiAgYXN5bmMgcHVibGlzaChldmVudCwgdGltZW91dE1zID0gMjUwMCkge1xuICAgIHJldHVybiB0aGlzLnB1Ymxpc2hlci5wdWJsaXNoKGV2ZW50LCB0aW1lb3V0TXMpO1xuICB9XG4gIHJlZmVyZW5jZVRhZ3MoKSB7XG4gICAgcmV0dXJuIFtbXCJyXCIsIHRoaXMudXJsXV07XG4gIH1cbiAgYWRkVmFsaWRhdGVkRXZlbnQoKSB7XG4gICAgdGhpcy52YWxpZGF0ZWRFdmVudENvdW50Kys7XG4gIH1cbiAgYWRkTm9uVmFsaWRhdGVkRXZlbnQoKSB7XG4gICAgdGhpcy5ub25WYWxpZGF0ZWRFdmVudENvdW50Kys7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHZhbGlkYXRpb24gcmF0aW8gdGhpcyByZWxheSBoYXMgYWNoaWV2ZWQuXG4gICAqL1xuICBnZXQgdmFsaWRhdGlvblJhdGlvKCkge1xuICAgIGlmICh0aGlzLm5vblZhbGlkYXRlZEV2ZW50Q291bnQgPT09IDApIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy52YWxpZGF0ZWRFdmVudENvdW50IC8gKHRoaXMudmFsaWRhdGVkRXZlbnRDb3VudCArIHRoaXMubm9uVmFsaWRhdGVkRXZlbnRDb3VudCk7XG4gIH1cbiAgc2hvdWxkVmFsaWRhdGVFdmVudCgpIHtcbiAgICBpZiAodGhpcy50cnVzdGVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0aGlzLnRhcmdldFZhbGlkYXRpb25SYXRpbyA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudmFsaWRhdGlvblJhdGlvIDwgdGhpcy50YXJnZXRWYWxpZGF0aW9uUmF0aW87XG4gIH1cbiAgZ2V0IGNvbm5lY3RlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25uZWN0aXZpdHkuY29ubmVjdGVkO1xuICB9XG4gIHJlcTtcbiAgY2xvc2U7XG59O1xuXG4vLyBzcmMvcmVsYXkvc2V0cy9pbmRleC50c1xudmFyIE5ES1B1Ymxpc2hFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBlcnJvcnM7XG4gIHB1Ymxpc2hlZFRvUmVsYXlzO1xuICAvKipcbiAgICogSW50ZW5kZWQgcmVsYXkgc2V0IHdoZXJlIHRoZSBwdWJsaXNoaW5nIHdhcyBpbnRlbmRlZCB0byBoYXBwZW4uXG4gICAqL1xuICBpbnRlbmRlZFJlbGF5U2V0O1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBlcnJvcnMsIHB1Ymxpc2hlZFRvUmVsYXlzLCBpbnRlbmRlZFJlbGF5U2V0KSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgdGhpcy5wdWJsaXNoZWRUb1JlbGF5cyA9IHB1Ymxpc2hlZFRvUmVsYXlzO1xuICAgIHRoaXMuaW50ZW5kZWRSZWxheVNldCA9IGludGVuZGVkUmVsYXlTZXQ7XG4gIH1cbiAgZ2V0IHJlbGF5RXJyb3JzKCkge1xuICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgIGZvciAoY29uc3QgW3JlbGF5LCBlcnJdIG9mIHRoaXMuZXJyb3JzKSB7XG4gICAgICBlcnJvcnMucHVzaChgJHtyZWxheS51cmx9OiAke2Vycn1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9ycy5qb2luKFwiXFxuXCIpO1xuICB9XG59O1xudmFyIE5ES1JlbGF5U2V0ID0gY2xhc3MgX05ES1JlbGF5U2V0IHtcbiAgcmVsYXlzO1xuICBkZWJ1ZztcbiAgbmRrO1xuICBwb29sO1xuICBjb25zdHJ1Y3RvcihyZWxheXMsIG5kaywgcG9vbCkge1xuICAgIHRoaXMucmVsYXlzID0gcmVsYXlzO1xuICAgIHRoaXMubmRrID0gbmRrO1xuICAgIHRoaXMucG9vbCA9IHBvb2wgPz8gbmRrLnBvb2w7XG4gICAgdGhpcy5kZWJ1ZyA9IG5kay5kZWJ1Zy5leHRlbmQoXCJyZWxheXNldFwiKTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIHJlbGF5IHRvIHRoaXMgc2V0LlxuICAgKi9cbiAgYWRkUmVsYXkocmVsYXkpIHtcbiAgICB0aGlzLnJlbGF5cy5hZGQocmVsYXkpO1xuICB9XG4gIGdldCByZWxheVVybHMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5yZWxheXMpLm1hcCgocikgPT4gci51cmwpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgcmVsYXkgc2V0IGZyb20gYSBsaXN0IG9mIHJlbGF5IFVSTHMuXG4gICAqXG4gICAqIElmIG5vIGNvbm5lY3Rpb24gdG8gdGhlIHJlbGF5IGlzIGZvdW5kIGluIHRoZSBwb29sIGl0IHdpbGwgdGVtcG9yYXJpbHlcbiAgICogY29ubmVjdCB0byBpdC5cbiAgICpcbiAgICogQHBhcmFtIHJlbGF5VXJscyAtIGxpc3Qgb2YgcmVsYXkgVVJMcyB0byBpbmNsdWRlIGluIHRoaXMgc2V0XG4gICAqIEBwYXJhbSBuZGtcbiAgICogQHBhcmFtIGNvbm5lY3QgLSB3aGV0aGVyIHRvIGNvbm5lY3QgdG8gdGhlIHJlbGF5IGltbWVkaWF0ZWx5IGlmIGl0IHdhcyBhbHJlYWR5IGluIHRoZSBwb29sIGJ1dCBub3QgY29ubmVjdGVkXG4gICAqIEByZXR1cm5zIE5ES1JlbGF5U2V0XG4gICAqL1xuICBzdGF0aWMgZnJvbVJlbGF5VXJscyhyZWxheVVybHMsIG5kaywgY29ubmVjdCA9IHRydWUsIHBvb2wpIHtcbiAgICBwb29sID0gcG9vbCA/PyBuZGsucG9vbDtcbiAgICBpZiAoIXBvb2wpIHRocm93IG5ldyBFcnJvcihcIk5vIHBvb2wgcHJvdmlkZWRcIik7XG4gICAgY29uc3QgcmVsYXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBmb3IgKGNvbnN0IHVybCBvZiByZWxheVVybHMpIHtcbiAgICAgIGNvbnN0IHJlbGF5ID0gcG9vbC5yZWxheXMuZ2V0KG5vcm1hbGl6ZVJlbGF5VXJsKHVybCkpO1xuICAgICAgaWYgKHJlbGF5KSB7XG4gICAgICAgIGlmIChyZWxheS5zdGF0dXMgPCA1IC8qIENPTk5FQ1RFRCAqLyAmJiBjb25uZWN0KSB7XG4gICAgICAgICAgcmVsYXkuY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJlbGF5cy5hZGQocmVsYXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdGVtcG9yYXJ5UmVsYXkgPSBuZXcgTkRLUmVsYXkoXG4gICAgICAgICAgbm9ybWFsaXplUmVsYXlVcmwodXJsKSxcbiAgICAgICAgICBuZGs/LnJlbGF5QXV0aERlZmF1bHRQb2xpY3ksXG4gICAgICAgICAgbmRrXG4gICAgICAgICk7XG4gICAgICAgIHBvb2wudXNlVGVtcG9yYXJ5UmVsYXkoXG4gICAgICAgICAgdGVtcG9yYXJ5UmVsYXksXG4gICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgIFwicmVxdWVzdGVkIGZyb20gZnJvbVJlbGF5VXJscyBcIiArIHJlbGF5VXJsc1xuICAgICAgICApO1xuICAgICAgICByZWxheXMuYWRkKHRlbXBvcmFyeVJlbGF5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBfTkRLUmVsYXlTZXQobmV3IFNldChyZWxheXMpLCBuZGssIHBvb2wpO1xuICB9XG4gIC8qKlxuICAgKiBQdWJsaXNoIGFuIGV2ZW50IHRvIGFsbCByZWxheXMgaW4gdGhpcyBzZXQuIFJldHVybnMgdGhlIG51bWJlciBvZiByZWxheXMgdGhhdCBoYXZlIHJlY2VpdmVkIHRoZSBldmVudC5cbiAgICogQHBhcmFtIGV2ZW50XG4gICAqIEBwYXJhbSB0aW1lb3V0TXMgLSB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyBmb3IgZWFjaCBwdWJsaXNoIG9wZXJhdGlvbiBhbmQgY29ubmVjdGlvbiBvcGVyYXRpb25cbiAgICogQHJldHVybnMgQSBzZXQgd2hlcmUgdGhlIGV2ZW50IHdhcyBzdWNjZXNzZnVsbHkgcHVibGlzaGVkIHRvXG4gICAqIEB0aHJvd3MgTkRLUHVibGlzaEVycm9yIGlmIG5vIHJlbGF5IHdhcyBhYmxlIHRvIHJlY2VpdmUgdGhlIGV2ZW50XG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgZXZlbnQgPSBuZXcgTkRLRXZlbnQobmRrLCB7a2luZHM6IFtOREtLaW5kLk1lc3NhZ2VdLCBcIiNkXCI6IFtcIjEyM1wiXX0pO1xuICAgKiB0cnkge1xuICAgKiAgICBjb25zdCBwdWJsaXNoZWRUb1JlbGF5cyA9IGF3YWl0IHJlbGF5U2V0LnB1Ymxpc2goZXZlbnQpO1xuICAgKiAgICBjb25zb2xlLmxvZyhgcHVibGlzaGVkIHRvICR7cHVibGlzaGVkVG9SZWxheXMuc2l6ZX0gcmVsYXlzYClcbiAgICogfSBjYXRjaCAoZXJyb3IpIHtcbiAgICogICBjb25zb2xlLmVycm9yKFwiZXJyb3IgcHVibGlzaGluZyB0byByZWxheXNcIiwgZXJyb3IpO1xuICAgKlxuICAgKiAgIGlmIChlcnJvciBpbnN0YW5jZW9mIE5ES1B1Ymxpc2hFcnJvcikge1xuICAgKiAgICAgIGZvciAoY29uc3QgW3JlbGF5LCBlcnJdIG9mIGVycm9yLmVycm9ycykge1xuICAgKiAgICAgICAgIGNvbnNvbGUuZXJyb3IoYGVycm9yIHB1Ymxpc2hpbmcgdG8gcmVsYXkgJHtyZWxheS51cmx9YCwgZXJyKTtcbiAgICogICAgICAgfVxuICAgKiAgIH1cbiAgICogfVxuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIHB1Ymxpc2goZXZlbnQsIHRpbWVvdXRNcywgcmVxdWlyZWRSZWxheUNvdW50ID0gMSkge1xuICAgIGNvbnN0IHB1Ymxpc2hlZFRvUmVsYXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBjb25zdCBlcnJvcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGlzRXBoZW1lcmFsMiA9IGV2ZW50LmlzRXBoZW1lcmFsKCk7XG4gICAgZXZlbnQucHVibGlzaFN0YXR1cyA9IFwicGVuZGluZ1wiO1xuICAgIGNvbnN0IHByb21pc2VzID0gQXJyYXkuZnJvbSh0aGlzLnJlbGF5cykubWFwKChyZWxheSkgPT4ge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIHJlbGF5LnB1Ymxpc2goZXZlbnQsIHRpbWVvdXRNcykudGhlbigoZSkgPT4ge1xuICAgICAgICAgIHB1Ymxpc2hlZFRvUmVsYXlzLmFkZChyZWxheSk7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgaWYgKCFpc0VwaGVtZXJhbDIpIHtcbiAgICAgICAgICAgIGVycm9ycy5zZXQocmVsYXksIGVycik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgaWYgKHB1Ymxpc2hlZFRvUmVsYXlzLnNpemUgPCByZXF1aXJlZFJlbGF5Q291bnQpIHtcbiAgICAgIGlmICghaXNFcGhlbWVyYWwyKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IE5ES1B1Ymxpc2hFcnJvcihcbiAgICAgICAgICBcIk5vdCBlbm91Z2ggcmVsYXlzIHJlY2VpdmVkIHRoZSBldmVudFwiLFxuICAgICAgICAgIGVycm9ycyxcbiAgICAgICAgICBwdWJsaXNoZWRUb1JlbGF5cyxcbiAgICAgICAgICB0aGlzXG4gICAgICAgICk7XG4gICAgICAgIGV2ZW50LnB1Ymxpc2hTdGF0dXMgPSBcImVycm9yXCI7XG4gICAgICAgIGV2ZW50LnB1Ymxpc2hFcnJvciA9IGVycm9yO1xuICAgICAgICB0aGlzLm5kay5lbWl0KFwiZXZlbnQ6cHVibGlzaC1mYWlsZWRcIiwgZXZlbnQsIGVycm9yLCB0aGlzLnJlbGF5VXJscyk7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBldmVudC5lbWl0KFwicHVibGlzaGVkXCIsIHsgcmVsYXlTZXQ6IHRoaXMsIHB1Ymxpc2hlZFRvUmVsYXlzIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcHVibGlzaGVkVG9SZWxheXM7XG4gIH1cbiAgZ2V0IHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVsYXlzLnNpemU7XG4gIH1cbn07XG5cbi8vIHNyYy9yZWxheS9zZXRzL2NhbGN1bGF0ZS50c1xuaW1wb3J0IGNyZWF0ZURlYnVnIGZyb20gXCJkZWJ1Z1wiO1xudmFyIGQgPSBjcmVhdGVEZWJ1ZyhcIm5kazpvdXRib3g6Y2FsY3VsYXRlXCIpO1xuYXN5bmMgZnVuY3Rpb24gY2FsY3VsYXRlUmVsYXlTZXRGcm9tRXZlbnQobmRrLCBldmVudCkge1xuICBjb25zdCByZWxheXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBjb25zdCBhdXRob3JXcml0ZVJlbGF5cyA9IGF3YWl0IGdldFdyaXRlUmVsYXlzRm9yKG5kaywgZXZlbnQucHVia2V5KTtcbiAgaWYgKGF1dGhvcldyaXRlUmVsYXlzKSB7XG4gICAgYXV0aG9yV3JpdGVSZWxheXMuZm9yRWFjaCgocmVsYXlVcmwpID0+IHtcbiAgICAgIGNvbnN0IHJlbGF5ID0gbmRrLnBvb2w/LmdldFJlbGF5KHJlbGF5VXJsKTtcbiAgICAgIGlmIChyZWxheSkgcmVsYXlzLmFkZChyZWxheSk7XG4gICAgfSk7XG4gIH1cbiAgbGV0IHJlbGF5SGludHMgPSBldmVudC50YWdzLmZpbHRlcigodGFnKSA9PiBbXCJhXCIsIFwiZVwiXS5pbmNsdWRlcyh0YWdbMF0pKS5tYXAoKHRhZykgPT4gdGFnWzJdKS5maWx0ZXIoKHVybCkgPT4gdXJsICYmIHVybC5zdGFydHNXaXRoKFwid3NzOi8vXCIpKS5maWx0ZXIoKHVybCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBuZXcgVVJMKHVybCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pLm1hcCgodXJsKSA9PiBub3JtYWxpemVSZWxheVVybCh1cmwpKTtcbiAgcmVsYXlIaW50cyA9IEFycmF5LmZyb20obmV3IFNldChyZWxheUhpbnRzKSkuc2xpY2UoMCwgNSk7XG4gIHJlbGF5SGludHMuZm9yRWFjaCgocmVsYXlVcmwpID0+IHtcbiAgICBjb25zdCByZWxheSA9IG5kay5wb29sPy5nZXRSZWxheShyZWxheVVybCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgaWYgKHJlbGF5KSB7XG4gICAgICBkKFwiQWRkaW5nIHJlbGF5IGhpbnQgJXNcIiwgcmVsYXlVcmwpO1xuICAgICAgcmVsYXlzLmFkZChyZWxheSk7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgcFRhZ3MgPSBldmVudC5nZXRNYXRjaGluZ1RhZ3MoXCJwXCIpLm1hcCgodGFnKSA9PiB0YWdbMV0pO1xuICBpZiAocFRhZ3MubGVuZ3RoIDwgNSkge1xuICAgIGNvbnN0IHBUYWdnZWRSZWxheXMgPSBBcnJheS5mcm9tKFxuICAgICAgY2hvb3NlUmVsYXlDb21iaW5hdGlvbkZvclB1YmtleXMobmRrLCBwVGFncywgXCJyZWFkXCIsIHtcbiAgICAgICAgcHJlZmVycmVkUmVsYXlzOiBuZXcgU2V0KGF1dGhvcldyaXRlUmVsYXlzKVxuICAgICAgfSkua2V5cygpXG4gICAgKTtcbiAgICBwVGFnZ2VkUmVsYXlzLmZvckVhY2goKHJlbGF5VXJsKSA9PiB7XG4gICAgICBjb25zdCByZWxheSA9IG5kay5wb29sPy5nZXRSZWxheShyZWxheVVybCwgZmFsc2UsIHRydWUpO1xuICAgICAgaWYgKHJlbGF5KSB7XG4gICAgICAgIGQoXCJBZGRpbmcgcC10YWdnZWQgcmVsYXkgJXNcIiwgcmVsYXlVcmwpO1xuICAgICAgICByZWxheXMuYWRkKHJlbGF5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBkKFwiVG9vIG1hbnkgcC10YWdzIHRvIGNvbnNpZGVyICVkXCIsIHBUYWdzLmxlbmd0aCk7XG4gIH1cbiAgbmRrLnBvb2w/LnBlcm1hbmVudEFuZENvbm5lY3RlZFJlbGF5cygpLmZvckVhY2goKHJlbGF5KSA9PiByZWxheXMuYWRkKHJlbGF5KSk7XG4gIHJldHVybiBuZXcgTkRLUmVsYXlTZXQocmVsYXlzLCBuZGspO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlUmVsYXlTZXRzRnJvbUZpbHRlcihuZGssIGZpbHRlcnMsIHBvb2wpIHtcbiAgY29uc3QgcmVzdWx0ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgYXV0aG9ycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGZpbHRlcnMuZm9yRWFjaCgoZmlsdGVyKSA9PiB7XG4gICAgaWYgKGZpbHRlci5hdXRob3JzKSB7XG4gICAgICBmaWx0ZXIuYXV0aG9ycy5mb3JFYWNoKChhdXRob3IpID0+IGF1dGhvcnMuYWRkKGF1dGhvcikpO1xuICAgIH1cbiAgfSk7XG4gIGlmIChhdXRob3JzLnNpemUgPiAwKSB7XG4gICAgY29uc3QgYXV0aG9yVG9SZWxheXNNYXAgPSBnZXRSZWxheXNGb3JGaWx0ZXJXaXRoQXV0aG9ycyhuZGssIEFycmF5LmZyb20oYXV0aG9ycykpO1xuICAgIGZvciAoY29uc3QgcmVsYXlVcmwgb2YgYXV0aG9yVG9SZWxheXNNYXAua2V5cygpKSB7XG4gICAgICByZXN1bHQuc2V0KHJlbGF5VXJsLCBbXSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZmlsdGVyIG9mIGZpbHRlcnMpIHtcbiAgICAgIGlmIChmaWx0ZXIuYXV0aG9ycykge1xuICAgICAgICBmb3IgKGNvbnN0IFtyZWxheVVybCwgYXV0aG9yczJdIG9mIGF1dGhvclRvUmVsYXlzTWFwLmVudHJpZXMoKSkge1xuICAgICAgICAgIGNvbnN0IGF1dGhvckZpbHRlckFuZFJlbGF5UHVia2V5SW50ZXJzZWN0aW9uID0gZmlsdGVyLmF1dGhvcnMuZmlsdGVyKFxuICAgICAgICAgICAgKGF1dGhvcikgPT4gYXV0aG9yczIuaW5jbHVkZXMoYXV0aG9yKVxuICAgICAgICAgICk7XG4gICAgICAgICAgcmVzdWx0LnNldChyZWxheVVybCwgW1xuICAgICAgICAgICAgLi4ucmVzdWx0LmdldChyZWxheVVybCksXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIC4uLmZpbHRlcixcbiAgICAgICAgICAgICAgLy8gT3ZlcndyaXRlIGF1dGhvcnMgc2VudCB0byB0aGlzIHJlbGF5IHdpdGggdGhlIGF1dGhvcnMgdGhhdCB3ZXJlXG4gICAgICAgICAgICAgIC8vIHByZXNlbnQgaW4gdGhlIGZpbHRlciBhbmQgYXJlIGFsc28gcHJlc2VudCBpbiB0aGUgcmVsYXlcbiAgICAgICAgICAgICAgYXV0aG9yczogYXV0aG9yRmlsdGVyQW5kUmVsYXlQdWJrZXlJbnRlcnNlY3Rpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChjb25zdCByZWxheVVybCBvZiBhdXRob3JUb1JlbGF5c01hcC5rZXlzKCkpIHtcbiAgICAgICAgICByZXN1bHQuc2V0KHJlbGF5VXJsLCBbLi4ucmVzdWx0LmdldChyZWxheVVybCksIGZpbHRlcl0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChuZGsuZXhwbGljaXRSZWxheVVybHMpIHtcbiAgICAgIG5kay5leHBsaWNpdFJlbGF5VXJscy5mb3JFYWNoKChyZWxheVVybCkgPT4ge1xuICAgICAgICByZXN1bHQuc2V0KHJlbGF5VXJsLCBmaWx0ZXJzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAocmVzdWx0LnNpemUgPT09IDApIHtcbiAgICBwb29sLnBlcm1hbmVudEFuZENvbm5lY3RlZFJlbGF5cygpLnNsaWNlKDAsIDUpLmZvckVhY2goKHJlbGF5KSA9PiB7XG4gICAgICByZXN1bHQuc2V0KHJlbGF5LnVybCwgZmlsdGVycyk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZVJlbGF5U2V0c0Zyb21GaWx0ZXJzKG5kaywgZmlsdGVycywgcG9vbCkge1xuICBjb25zdCBhID0gY2FsY3VsYXRlUmVsYXlTZXRzRnJvbUZpbHRlcihuZGssIGZpbHRlcnMsIHBvb2wpO1xuICByZXR1cm4gYTtcbn1cblxuLy8gc3JjL2V2ZW50cy9jb250ZW50LXRhZ2dlci50c1xuaW1wb3J0IHsgbmlwMTkgfSBmcm9tIFwibm9zdHItdG9vbHNcIjtcbmZ1bmN0aW9uIG1lcmdlVGFncyh0YWdzMSwgdGFnczIpIHtcbiAgY29uc3QgdGFnTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgZ2VuZXJhdGVLZXkgPSAodGFnKSA9PiB0YWcuam9pbihcIixcIik7XG4gIGNvbnN0IGlzQ29udGFpbmVkID0gKHNtYWxsZXIsIGxhcmdlcikgPT4ge1xuICAgIHJldHVybiBzbWFsbGVyLmV2ZXJ5KCh2YWx1ZSwgaW5kZXgpID0+IHZhbHVlID09PSBsYXJnZXJbaW5kZXhdKTtcbiAgfTtcbiAgY29uc3QgcHJvY2Vzc1RhZyA9ICh0YWcpID0+IHtcbiAgICBmb3IgKGNvbnN0IFtrZXksIGV4aXN0aW5nVGFnXSBvZiB0YWdNYXApIHtcbiAgICAgIGlmIChpc0NvbnRhaW5lZChleGlzdGluZ1RhZywgdGFnKSB8fCBpc0NvbnRhaW5lZCh0YWcsIGV4aXN0aW5nVGFnKSkge1xuICAgICAgICBpZiAodGFnLmxlbmd0aCA+PSBleGlzdGluZ1RhZy5sZW5ndGgpIHtcbiAgICAgICAgICB0YWdNYXAuc2V0KGtleSwgdGFnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRhZ01hcC5zZXQoZ2VuZXJhdGVLZXkodGFnKSwgdGFnKTtcbiAgfTtcbiAgdGFnczEuY29uY2F0KHRhZ3MyKS5mb3JFYWNoKHByb2Nlc3NUYWcpO1xuICByZXR1cm4gQXJyYXkuZnJvbSh0YWdNYXAudmFsdWVzKCkpO1xufVxuZnVuY3Rpb24gdW5pcXVlVGFnKGEsIGIpIHtcbiAgY29uc3QgYUxlbmd0aCA9IGEubGVuZ3RoO1xuICBjb25zdCBiTGVuZ3RoID0gYi5sZW5ndGg7XG4gIGNvbnN0IHNhbWVMZW5ndGggPSBhTGVuZ3RoID09PSBiTGVuZ3RoO1xuICBpZiAoc2FtZUxlbmd0aCkge1xuICAgIGlmIChhLmV2ZXJ5KCh2LCBpKSA9PiB2ID09PSBiW2ldKSkge1xuICAgICAgcmV0dXJuIFthXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFthLCBiXTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYUxlbmd0aCA+IGJMZW5ndGggJiYgYS5ldmVyeSgodiwgaSkgPT4gdiA9PT0gYltpXSkpIHtcbiAgICByZXR1cm4gW2FdO1xuICB9IGVsc2UgaWYgKGJMZW5ndGggPiBhTGVuZ3RoICYmIGIuZXZlcnkoKHYsIGkpID0+IHYgPT09IGFbaV0pKSB7XG4gICAgcmV0dXJuIFtiXTtcbiAgfVxuICByZXR1cm4gW2EsIGJdO1xufVxudmFyIGhhc2h0YWdSZWdleCA9IC8oPzw9XFxzfF4pKCNbXlxccyFAIyQlXiYqKCk9Ky4vLFt7XFxdfTs6J1wiPz48XSspL2c7XG5mdW5jdGlvbiBnZW5lcmF0ZUhhc2h0YWdzKGNvbnRlbnQpIHtcbiAgY29uc3QgaGFzaHRhZ3MgPSBjb250ZW50Lm1hdGNoKGhhc2h0YWdSZWdleCk7XG4gIGNvbnN0IHRhZ0lkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0IHRhZyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGlmIChoYXNodGFncykge1xuICAgIGZvciAoY29uc3QgaGFzaHRhZyBvZiBoYXNodGFncykge1xuICAgICAgaWYgKHRhZ0lkcy5oYXMoaGFzaHRhZy5zbGljZSgxKSkpIGNvbnRpbnVlO1xuICAgICAgdGFnLmFkZChoYXNodGFnLnNsaWNlKDEpKTtcbiAgICAgIHRhZ0lkcy5hZGQoaGFzaHRhZy5zbGljZSgxKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBBcnJheS5mcm9tKHRhZyk7XG59XG5hc3luYyBmdW5jdGlvbiBnZW5lcmF0ZUNvbnRlbnRUYWdzKGNvbnRlbnQsIHRhZ3MgPSBbXSkge1xuICBjb25zdCB0YWdSZWdleCA9IC8oQHxub3N0cjopKG5wdWJ8bnByb2ZpbGV8bm90ZXxuZXZlbnR8bmFkZHIpW2EtekEtWjAtOV0rL2c7XG4gIGNvbnN0IHByb21pc2VzID0gW107XG4gIGNvbnN0IGFkZFRhZ0lmTmV3ID0gKHQpID0+IHtcbiAgICBpZiAoIXRhZ3MuZmluZCgodDIpID0+IFtcInFcIiwgdFswXV0uaW5jbHVkZXModDJbMF0pICYmIHQyWzFdID09PSB0WzFdKSkge1xuICAgICAgdGFncy5wdXNoKHQpO1xuICAgIH1cbiAgfTtcbiAgY29udGVudCA9IGNvbnRlbnQucmVwbGFjZSh0YWdSZWdleCwgKHRhZykgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBlbnRpdHkgPSB0YWcuc3BsaXQoLyhAfG5vc3RyOikvKVsyXTtcbiAgICAgIGNvbnN0IHsgdHlwZSwgZGF0YSB9ID0gbmlwMTkuZGVjb2RlKGVudGl0eSk7XG4gICAgICBsZXQgdDtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwibnB1YlwiOlxuICAgICAgICAgIHQgPSBbXCJwXCIsIGRhdGFdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibnByb2ZpbGVcIjpcbiAgICAgICAgICB0ID0gW1wicFwiLCBkYXRhLnB1YmtleV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJub3RlXCI6XG4gICAgICAgICAgcHJvbWlzZXMucHVzaChcbiAgICAgICAgICAgIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgIGFkZFRhZ0lmTmV3KFtcbiAgICAgICAgICAgICAgICBcInFcIixcbiAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgIGF3YWl0IG1heWJlR2V0RXZlbnRSZWxheVVybChlbnRpdHkpXG4gICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJuZXZlbnRcIjpcbiAgICAgICAgICBwcm9taXNlcy5wdXNoKFxuICAgICAgICAgICAgbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgeyBpZCwgYXV0aG9yIH0gPSBkYXRhO1xuICAgICAgICAgICAgICBsZXQgeyByZWxheXMgfSA9IGRhdGE7XG4gICAgICAgICAgICAgIGlmICghcmVsYXlzIHx8IHJlbGF5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZWxheXMgPSBbYXdhaXQgbWF5YmVHZXRFdmVudFJlbGF5VXJsKGVudGl0eSldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGFkZFRhZ0lmTmV3KFtcInFcIiwgaWQsIHJlbGF5c1swXV0pO1xuICAgICAgICAgICAgICBpZiAoYXV0aG9yKSBhZGRUYWdJZk5ldyhbXCJwXCIsIGF1dGhvcl0pO1xuICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJuYWRkclwiOlxuICAgICAgICAgIHByb21pc2VzLnB1c2goXG4gICAgICAgICAgICBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBpZCA9IFtkYXRhLmtpbmQsIGRhdGEucHVia2V5LCBkYXRhLmlkZW50aWZpZXJdLmpvaW4oXCI6XCIpO1xuICAgICAgICAgICAgICBsZXQgcmVsYXlzID0gZGF0YS5yZWxheXMgPz8gW107XG4gICAgICAgICAgICAgIGlmIChyZWxheXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmVsYXlzID0gW2F3YWl0IG1heWJlR2V0RXZlbnRSZWxheVVybChlbnRpdHkpXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhZGRUYWdJZk5ldyhbXCJxXCIsIGlkLCByZWxheXNbMF1dKTtcbiAgICAgICAgICAgICAgYWRkVGFnSWZOZXcoW1wicFwiLCBkYXRhLnB1YmtleV0pO1xuICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHRhZztcbiAgICAgIH1cbiAgICAgIGlmICh0KSBhZGRUYWdJZk5ldyh0KTtcbiAgICAgIHJldHVybiBgbm9zdHI6JHtlbnRpdHl9YDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIHRhZztcbiAgICB9XG4gIH0pO1xuICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gIGNvbnN0IG5ld1RhZ3MgPSBnZW5lcmF0ZUhhc2h0YWdzKGNvbnRlbnQpLm1hcCgoaGFzaHRhZykgPT4gW1widFwiLCBoYXNodGFnXSk7XG4gIHRhZ3MgPSBtZXJnZVRhZ3ModGFncywgbmV3VGFncyk7XG4gIHJldHVybiB7IGNvbnRlbnQsIHRhZ3MgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIG1heWJlR2V0RXZlbnRSZWxheVVybChuaXAxOUlkKSB7XG4gIHJldHVybiBcIlwiO1xufVxuXG4vLyBzcmMvZXZlbnRzL2tpbmQudHNcbmZ1bmN0aW9uIGlzUmVwbGFjZWFibGUoKSB7XG4gIGlmICh0aGlzLmtpbmQgPT09IHZvaWQgMCkgdGhyb3cgbmV3IEVycm9yKFwiS2luZCBub3Qgc2V0XCIpO1xuICByZXR1cm4gWzAsIDNdLmluY2x1ZGVzKHRoaXMua2luZCkgfHwgdGhpcy5raW5kID49IDFlNCAmJiB0aGlzLmtpbmQgPCAyZTQgfHwgdGhpcy5raW5kID49IDNlNCAmJiB0aGlzLmtpbmQgPCA0ZTQ7XG59XG5mdW5jdGlvbiBpc0VwaGVtZXJhbCgpIHtcbiAgaWYgKHRoaXMua2luZCA9PT0gdm9pZCAwKSB0aHJvdyBuZXcgRXJyb3IoXCJLaW5kIG5vdCBzZXRcIik7XG4gIHJldHVybiB0aGlzLmtpbmQgPj0gMmU0ICYmIHRoaXMua2luZCA8IDNlNDtcbn1cbmZ1bmN0aW9uIGlzUGFyYW1SZXBsYWNlYWJsZSgpIHtcbiAgaWYgKHRoaXMua2luZCA9PT0gdm9pZCAwKSB0aHJvdyBuZXcgRXJyb3IoXCJLaW5kIG5vdCBzZXRcIik7XG4gIHJldHVybiB0aGlzLmtpbmQgPj0gM2U0ICYmIHRoaXMua2luZCA8IDRlNDtcbn1cblxuLy8gc3JjL2V2ZW50cy9lbmNyeXB0aW9uLnRzXG5hc3luYyBmdW5jdGlvbiBlbmNyeXB0KHJlY2lwaWVudCwgc2lnbmVyLCBzY2hlbWUgPSBcIm5pcDQ0XCIpIHtcbiAgbGV0IGVuY3J5cHRlZDtcbiAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTm8gTkRLIGluc3RhbmNlIGZvdW5kIVwiKTtcbiAgaWYgKCFzaWduZXIpIHtcbiAgICB0aGlzLm5kay5hc3NlcnRTaWduZXIoKTtcbiAgICBzaWduZXIgPSB0aGlzLm5kay5zaWduZXI7XG4gIH1cbiAgaWYgKCFyZWNpcGllbnQpIHtcbiAgICBjb25zdCBwVGFncyA9IHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwicFwiKTtcbiAgICBpZiAocFRhZ3MubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiTm8gcmVjaXBpZW50IGNvdWxkIGJlIGRldGVybWluZWQgYW5kIG5vIGV4cGxpY2l0IHJlY2lwaWVudCB3YXMgcHJvdmlkZWRcIlxuICAgICAgKTtcbiAgICB9XG4gICAgcmVjaXBpZW50ID0gdGhpcy5uZGsuZ2V0VXNlcih7IHB1YmtleTogcFRhZ3NbMF1bMV0gfSk7XG4gIH1cbiAgaWYgKHNjaGVtZSA9PT0gXCJuaXA0NFwiICYmIGF3YWl0IGlzRW5jcnlwdGlvbkVuYWJsZWQoc2lnbmVyLCBcIm5pcDQ0XCIpKSB7XG4gICAgZW5jcnlwdGVkID0gYXdhaXQgc2lnbmVyPy5lbmNyeXB0KHJlY2lwaWVudCwgdGhpcy5jb250ZW50LCBcIm5pcDQ0XCIpO1xuICB9XG4gIGlmICgoIWVuY3J5cHRlZCB8fCBzY2hlbWUgPT09IFwibmlwMDRcIikgJiYgYXdhaXQgaXNFbmNyeXB0aW9uRW5hYmxlZChzaWduZXIsIFwibmlwMDRcIikpIHtcbiAgICBlbmNyeXB0ZWQgPSBhd2FpdCBzaWduZXIuZW5jcnlwdChyZWNpcGllbnQsIHRoaXMuY29udGVudCwgXCJuaXAwNFwiKTtcbiAgfVxuICBpZiAoIWVuY3J5cHRlZCkgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGVuY3J5cHQgZXZlbnQuXCIpO1xuICB0aGlzLmNvbnRlbnQgPSBlbmNyeXB0ZWQ7XG59XG5hc3luYyBmdW5jdGlvbiBkZWNyeXB0KHNlbmRlciwgc2lnbmVyLCBzY2hlbWUpIHtcbiAgbGV0IGRlY3J5cHRlZDtcbiAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTm8gTkRLIGluc3RhbmNlIGZvdW5kIVwiKTtcbiAgaWYgKCFzaWduZXIpIHtcbiAgICB0aGlzLm5kay5hc3NlcnRTaWduZXIoKTtcbiAgICBzaWduZXIgPSB0aGlzLm5kay5zaWduZXI7XG4gIH1cbiAgaWYgKCFzaWduZXIpIHRocm93IG5ldyBFcnJvcihcIm5vIE5ESyBzaWduZXJcIik7XG4gIGlmICghc2VuZGVyKSB7XG4gICAgc2VuZGVyID0gdGhpcy5hdXRob3I7XG4gIH1cbiAgaWYgKCFzY2hlbWUpIHNjaGVtZSA9IHRoaXMuY29udGVudC5tYXRjaCgvXFxcXD9pdj0vKSA/IFwibmlwMDRcIiA6IFwibmlwNDRcIjtcbiAgaWYgKChzY2hlbWUgPT09IFwibmlwMDRcIiB8fCB0aGlzLmtpbmQgPT09IDQpICYmIGF3YWl0IGlzRW5jcnlwdGlvbkVuYWJsZWQoc2lnbmVyLCBcIm5pcDA0XCIpICYmIHRoaXMuY29udGVudC5zZWFyY2goXCJcXFxcP2l2PVwiKSkge1xuICAgIGRlY3J5cHRlZCA9IGF3YWl0IHNpZ25lci5kZWNyeXB0KHNlbmRlciwgdGhpcy5jb250ZW50LCBcIm5pcDA0XCIpO1xuICB9XG4gIGlmICghZGVjcnlwdGVkICYmIHNjaGVtZSA9PT0gXCJuaXA0NFwiICYmIGF3YWl0IGlzRW5jcnlwdGlvbkVuYWJsZWQoc2lnbmVyLCBcIm5pcDQ0XCIpKSB7XG4gICAgZGVjcnlwdGVkID0gYXdhaXQgc2lnbmVyLmRlY3J5cHQoc2VuZGVyLCB0aGlzLmNvbnRlbnQsIFwibmlwNDRcIik7XG4gIH1cbiAgaWYgKCFkZWNyeXB0ZWQpIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBkZWNyeXB0IGV2ZW50LlwiKTtcbiAgdGhpcy5jb250ZW50ID0gZGVjcnlwdGVkO1xufVxuYXN5bmMgZnVuY3Rpb24gaXNFbmNyeXB0aW9uRW5hYmxlZChzaWduZXIsIHNjaGVtZSkge1xuICBpZiAoIXNpZ25lci5lbmNyeXB0aW9uRW5hYmxlZCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoIXNjaGVtZSkgcmV0dXJuIHRydWU7XG4gIHJldHVybiBCb29sZWFuKGF3YWl0IHNpZ25lci5lbmNyeXB0aW9uRW5hYmxlZChzY2hlbWUpKTtcbn1cblxuLy8gc3JjL2V2ZW50cy9uaXAxOS50c1xuaW1wb3J0IHsgbmlwMTkgYXMgbmlwMTkyIH0gZnJvbSBcIm5vc3RyLXRvb2xzXCI7XG52YXIgREVGQVVMVF9SRUxBWV9DT1VOVCA9IDI7XG5mdW5jdGlvbiBlbmNvZGUobWF4UmVsYXlDb3VudCA9IERFRkFVTFRfUkVMQVlfQ09VTlQpIHtcbiAgbGV0IHJlbGF5cyA9IFtdO1xuICBpZiAodGhpcy5vblJlbGF5cy5sZW5ndGggPiAwKSB7XG4gICAgcmVsYXlzID0gdGhpcy5vblJlbGF5cy5tYXAoKHJlbGF5KSA9PiByZWxheS51cmwpO1xuICB9IGVsc2UgaWYgKHRoaXMucmVsYXkpIHtcbiAgICByZWxheXMgPSBbdGhpcy5yZWxheS51cmxdO1xuICB9XG4gIGlmIChyZWxheXMubGVuZ3RoID4gbWF4UmVsYXlDb3VudCkge1xuICAgIHJlbGF5cyA9IHJlbGF5cy5zbGljZSgwLCBtYXhSZWxheUNvdW50KTtcbiAgfVxuICBpZiAodGhpcy5pc1BhcmFtUmVwbGFjZWFibGUoKSkge1xuICAgIHJldHVybiBuaXAxOTIubmFkZHJFbmNvZGUoe1xuICAgICAga2luZDogdGhpcy5raW5kLFxuICAgICAgcHVia2V5OiB0aGlzLnB1YmtleSxcbiAgICAgIGlkZW50aWZpZXI6IHRoaXMucmVwbGFjZWFibGVEVGFnKCksXG4gICAgICByZWxheXNcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChyZWxheXMubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBuaXAxOTIubmV2ZW50RW5jb2RlKHtcbiAgICAgIGlkOiB0aGlzLnRhZ0lkKCksXG4gICAgICByZWxheXMsXG4gICAgICBhdXRob3I6IHRoaXMucHVia2V5XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5pcDE5Mi5ub3RlRW5jb2RlKHRoaXMudGFnSWQoKSk7XG4gIH1cbn1cblxuLy8gc3JjL2V2ZW50cy9yZXBvc3QudHNcbmFzeW5jIGZ1bmN0aW9uIHJlcG9zdChwdWJsaXNoID0gdHJ1ZSwgc2lnbmVyKSB7XG4gIGlmICghc2lnbmVyICYmIHB1Ymxpc2gpIHtcbiAgICBpZiAoIXRoaXMubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBOREsgaW5zdGFuY2UgZm91bmRcIik7XG4gICAgdGhpcy5uZGsuYXNzZXJ0U2lnbmVyKCk7XG4gICAgc2lnbmVyID0gdGhpcy5uZGsuc2lnbmVyO1xuICB9XG4gIGNvbnN0IGUgPSBuZXcgTkRLRXZlbnQodGhpcy5uZGssIHtcbiAgICBraW5kOiBnZXRLaW5kKHRoaXMpXG4gIH0pO1xuICBpZiAoIXRoaXMuaXNQcm90ZWN0ZWQpXG4gICAgZS5jb250ZW50ID0gSlNPTi5zdHJpbmdpZnkodGhpcy5yYXdFdmVudCgpKTtcbiAgZS50YWcodGhpcyk7XG4gIGlmICh0aGlzLmtpbmQgIT09IDEgLyogVGV4dCAqLykge1xuICAgIGUudGFncy5wdXNoKFtcImtcIiwgYCR7dGhpcy5raW5kfWBdKTtcbiAgfVxuICBpZiAoc2lnbmVyKSBhd2FpdCBlLnNpZ24oc2lnbmVyKTtcbiAgaWYgKHB1Ymxpc2gpIGF3YWl0IGUucHVibGlzaCgpO1xuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIGdldEtpbmQoZXZlbnQpIHtcbiAgaWYgKGV2ZW50LmtpbmQgPT09IDEpIHtcbiAgICByZXR1cm4gNiAvKiBSZXBvc3QgKi87XG4gIH1cbiAgcmV0dXJuIDE2IC8qIEdlbmVyaWNSZXBvc3QgKi87XG59XG5cbi8vIHNyYy90aHJlYWQvaW5kZXgudHNcbmZ1bmN0aW9uIGV2ZW50c0J5U2FtZUF1dGhvcihvcCwgZXZlbnRzKSB7XG4gIGNvbnN0IGV2ZW50c0J5QXV0aG9yID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgZXZlbnRzQnlBdXRob3Iuc2V0KG9wLmlkLCBvcCk7XG4gIGV2ZW50cy5mb3JFYWNoKChldmVudCkgPT4ge1xuICAgIGlmIChldmVudC5wdWJrZXkgPT09IG9wLnB1YmtleSkge1xuICAgICAgZXZlbnRzQnlBdXRob3Iuc2V0KGV2ZW50LmlkLCBldmVudCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGV2ZW50c0J5QXV0aG9yO1xufVxudmFyIGhhc01hcmtlcnMgPSAoZXZlbnQsIHRhZ1R5cGUpID0+IHtcbiAgcmV0dXJuIGV2ZW50LmdldE1hdGNoaW5nVGFncyh0YWdUeXBlKS5zb21lKCh0YWcpID0+IHRhZ1szXSAmJiB0YWdbM10gIT09IFwiXCIpO1xufTtcbmZ1bmN0aW9uIGV2ZW50SXNSZXBseShvcCwgZXZlbnQsIHRocmVhZElkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksIHRhZ1R5cGUpIHtcbiAgdGFnVHlwZSA/Pz0gb3AudGFnVHlwZSgpO1xuICBjb25zdCB0YWdzID0gZXZlbnQuZ2V0TWF0Y2hpbmdUYWdzKHRhZ1R5cGUpO1xuICB0aHJlYWRJZHMuYWRkKG9wLnRhZ0lkKCkpO1xuICBpZiAodGhyZWFkSWRzLmhhcyhldmVudC50YWdJZCgpKSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBoZWVkRXhwbGljaXRSZXBseU1hcmtlciA9ICgpID0+IHtcbiAgICBsZXQgZXZlbnRJc1RhZ2dlZCA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgdGFnIG9mIHRhZ3MpIHtcbiAgICAgIGlmICh0YWdbM10gPT09IFwicmVwbHlcIikgcmV0dXJuIHRocmVhZElkcy5oYXModGFnWzFdKTtcbiAgICAgIGNvbnN0IG1hcmtlcklzRW1wdHkgPSB0YWdbM10gPT09IFwiXCIgfHwgdGFnWzNdID09PSB2b2lkIDA7XG4gICAgICBjb25zdCBtYXJrZXJJc1Jvb3QgPSB0YWdbM10gPT09IFwicm9vdFwiO1xuICAgICAgaWYgKHRhZ1sxXSA9PT0gb3AudGFnSWQoKSAmJiAobWFya2VySXNFbXB0eSB8fCBtYXJrZXJJc1Jvb3QpKSB7XG4gICAgICAgIGV2ZW50SXNUYWdnZWQgPSBtYXJrZXJJc1Jvb3QgPyBcInJvb3RcIiA6IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghZXZlbnRJc1RhZ2dlZCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChldmVudElzVGFnZ2VkID09PSBcInJvb3RcIikgcmV0dXJuIHRydWU7XG4gIH07XG4gIGNvbnN0IGV4cGxpY2l0UmVwbHlNYXJrZXIgPSBoZWVkRXhwbGljaXRSZXBseU1hcmtlcigpO1xuICBpZiAoZXhwbGljaXRSZXBseU1hcmtlciAhPT0gdm9pZCAwKSByZXR1cm4gZXhwbGljaXRSZXBseU1hcmtlcjtcbiAgaWYgKGhhc01hcmtlcnMoZXZlbnQsIHRhZ1R5cGUpKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IGV4cGVjdGVkVGFncyA9IG9wLmdldE1hdGNoaW5nVGFncyhcImVcIikubWFwKCh0YWcpID0+IHRhZ1sxXSk7XG4gIGV4cGVjdGVkVGFncy5wdXNoKG9wLmlkKTtcbiAgcmV0dXJuIGV2ZW50LmdldE1hdGNoaW5nVGFncyhcImVcIikuZXZlcnkoKHRhZykgPT4gZXhwZWN0ZWRUYWdzLmluY2x1ZGVzKHRhZ1sxXSkpO1xufVxuZnVuY3Rpb24gZXZlbnRUaHJlYWRzKG9wLCBldmVudHMpIHtcbiAgY29uc3QgZXZlbnRzQnlBdXRob3IgPSBldmVudHNCeVNhbWVBdXRob3Iob3AsIGV2ZW50cyk7XG4gIGNvbnN0IHRocmVhZEV2ZW50cyA9IGV2ZW50cy5maWx0ZXIoKGV2ZW50KSA9PiBldmVudElzUGFydE9mVGhyZWFkKG9wLCBldmVudCwgZXZlbnRzQnlBdXRob3IpKTtcbiAgcmV0dXJuIHRocmVhZEV2ZW50cy5zb3J0KChhLCBiKSA9PiBhLmNyZWF0ZWRfYXQgLSBiLmNyZWF0ZWRfYXQpO1xufVxuZnVuY3Rpb24gZ2V0RXZlbnRSZXBseUlkKGV2ZW50KSB7XG4gIGNvbnN0IHJlcGx5VGFnID0gZ2V0UmVwbHlUYWcoZXZlbnQpO1xuICBpZiAocmVwbHlUYWcpIHJldHVybiByZXBseVRhZ1sxXTtcbiAgY29uc3Qgcm9vdFRhZyA9IGdldFJvb3RUYWcoZXZlbnQpO1xuICBpZiAocm9vdFRhZykgcmV0dXJuIHJvb3RUYWdbMV07XG59XG5mdW5jdGlvbiBpc0V2ZW50T3JpZ2luYWxQb3N0KGV2ZW50KSB7XG4gIHJldHVybiBnZXRFdmVudFJlcGx5SWQoZXZlbnQpID09PSB2b2lkIDA7XG59XG5mdW5jdGlvbiBldmVudFRocmVhZElkcyhvcCwgZXZlbnRzKSB7XG4gIGNvbnN0IHRocmVhZElkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IHRocmVhZEV2ZW50cyA9IGV2ZW50VGhyZWFkcyhvcCwgZXZlbnRzKTtcbiAgdGhyZWFkRXZlbnRzLmZvckVhY2goKGV2ZW50KSA9PiB0aHJlYWRJZHMuc2V0KGV2ZW50LmlkLCBldmVudCkpO1xuICByZXR1cm4gdGhyZWFkSWRzO1xufVxuZnVuY3Rpb24gZXZlbnRSZXBsaWVzKG9wLCBldmVudHMsIHRocmVhZEV2ZW50SWRzKSB7XG4gIHRocmVhZEV2ZW50SWRzID8/PSBuZXcgU2V0KGV2ZW50VGhyZWFkSWRzKG9wLCBldmVudHMpLmtleXMoKSk7XG4gIHJldHVybiBldmVudHMuZmlsdGVyKChldmVudCkgPT4gZXZlbnRJc1JlcGx5KG9wLCBldmVudCwgdGhyZWFkRXZlbnRJZHMpKTtcbn1cbmZ1bmN0aW9uIGV2ZW50SXNQYXJ0T2ZUaHJlYWQob3AsIGV2ZW50LCBldmVudHNCeUF1dGhvcikge1xuICBpZiAob3AucHVia2V5ICE9PSBldmVudC5wdWJrZXkpIHJldHVybiBmYWxzZTtcbiAgY29uc3QgdGFnZ2VkRXZlbnRJZHMgPSBldmVudC5nZXRNYXRjaGluZ1RhZ3MoXCJlXCIpLm1hcCgodGFnKSA9PiB0YWdbMV0pO1xuICBjb25zdCBhbGxUYWdnZWRFdmVudHNBcmVCeU9yaWdpbmFsQXV0aG9yID0gdGFnZ2VkRXZlbnRJZHMuZXZlcnkoKGlkKSA9PiBldmVudHNCeUF1dGhvci5oYXMoaWQpKTtcbiAgcmV0dXJuIGFsbFRhZ2dlZEV2ZW50c0FyZUJ5T3JpZ2luYWxBdXRob3I7XG59XG5mdW5jdGlvbiBldmVudEhhc0VUYWdNYXJrZXJzKGV2ZW50KSB7XG4gIGZvciAoY29uc3QgdGFnIG9mIGV2ZW50LnRhZ3MpIHtcbiAgICBpZiAodGFnWzBdID09PSBcImVcIiAmJiAodGFnWzNdID8/IFwiXCIpLmxlbmd0aCA+IDApIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldFJvb3RFdmVudElkKGV2ZW50LCBzZWFyY2hUYWcpIHtcbiAgc2VhcmNoVGFnID8/PSBldmVudC50YWdUeXBlKCk7XG4gIGNvbnN0IHJvb3RFdmVudFRhZyA9IGdldFJvb3RUYWcoZXZlbnQsIHNlYXJjaFRhZyk7XG4gIGlmIChyb290RXZlbnRUYWcpIHJldHVybiByb290RXZlbnRUYWdbMV07XG4gIGNvbnN0IHJlcGx5VGFnID0gZ2V0UmVwbHlUYWcoZXZlbnQsIHNlYXJjaFRhZyk7XG4gIHJldHVybiByZXBseVRhZz8uWzFdO1xufVxuZnVuY3Rpb24gZ2V0Um9vdFRhZyhldmVudCwgc2VhcmNoVGFnKSB7XG4gIHNlYXJjaFRhZyA/Pz0gZXZlbnQudGFnVHlwZSgpO1xuICBjb25zdCByb290RXZlbnRUYWcgPSBldmVudC50YWdzLmZpbmQoaXNUYWdSb290VGFnKTtcbiAgaWYgKCFyb290RXZlbnRUYWcpIHtcbiAgICBpZiAoZXZlbnRIYXNFVGFnTWFya2VycyhldmVudCkpIHJldHVybjtcbiAgICBjb25zdCBtYXRjaGluZ1RhZ3MgPSBldmVudC5nZXRNYXRjaGluZ1RhZ3Moc2VhcmNoVGFnKTtcbiAgICBpZiAobWF0Y2hpbmdUYWdzLmxlbmd0aCA8IDMpIHJldHVybiBtYXRjaGluZ1RhZ3NbMF07XG4gIH1cbiAgcmV0dXJuIHJvb3RFdmVudFRhZztcbn1cbnZhciBuaXAyMlJvb3RUYWdzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wiQVwiLCBcIkVcIiwgXCJJXCJdKTtcbnZhciBuaXAyMlJlcGx5VGFncyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcImFcIiwgXCJlXCIsIFwiaVwiXSk7XG5mdW5jdGlvbiBnZXRSZXBseVRhZyhldmVudCwgc2VhcmNoVGFnKSB7XG4gIGlmIChldmVudC5raW5kID09PSAxMTExIC8qIEdlbmVyaWNSZXBseSAqLykge1xuICAgIGxldCByZXBseVRhZzI7XG4gICAgZm9yIChjb25zdCB0YWcgb2YgZXZlbnQudGFncykge1xuICAgICAgaWYgKG5pcDIyUm9vdFRhZ3MuaGFzKHRhZ1swXSkpIHJlcGx5VGFnMiA9IHRhZztcbiAgICAgIGVsc2UgaWYgKG5pcDIyUmVwbHlUYWdzLmhhcyh0YWdbMF0pKSB7XG4gICAgICAgIHJlcGx5VGFnMiA9IHRhZztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXBseVRhZzI7XG4gIH1cbiAgc2VhcmNoVGFnID8/PSBldmVudC50YWdUeXBlKCk7XG4gIGxldCBoYXNNYXJrZXJzMiA9IGZhbHNlO1xuICBsZXQgcmVwbHlUYWc7XG4gIGZvciAoY29uc3QgdGFnIG9mIGV2ZW50LnRhZ3MpIHtcbiAgICBpZiAodGFnWzBdICE9PSBzZWFyY2hUYWcpIGNvbnRpbnVlO1xuICAgIGlmICgodGFnWzNdID8/IFwiXCIpLmxlbmd0aCA+IDApIGhhc01hcmtlcnMyID0gdHJ1ZTtcbiAgICBpZiAoaGFzTWFya2VyczIgJiYgdGFnWzNdID09PSBcInJlcGx5XCIpIHJldHVybiB0YWc7XG4gICAgaWYgKGhhc01hcmtlcnMyICYmIHRhZ1szXSA9PT0gXCJyb290XCIpIHJlcGx5VGFnID0gdGFnO1xuICAgIGlmICghaGFzTWFya2VyczIpIHJlcGx5VGFnID0gdGFnO1xuICB9XG4gIHJldHVybiByZXBseVRhZztcbn1cbmZ1bmN0aW9uIGlzVGFnUm9vdFRhZyh0YWcpIHtcbiAgcmV0dXJuIHRhZ1swXSA9PT0gXCJFXCIgfHwgdGFnWzNdID09PSBcInJvb3RcIjtcbn1cblxuLy8gc3JjL2V2ZW50cy9mZXRjaC10YWdnZWQtZXZlbnQudHNcbmFzeW5jIGZ1bmN0aW9uIGZldGNoVGFnZ2VkRXZlbnQodGFnLCBtYXJrZXIpIHtcbiAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTkRLIGluc3RhbmNlIG5vdCBmb3VuZFwiKTtcbiAgY29uc3QgdCA9IHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKHRhZywgbWFya2VyKTtcbiAgaWYgKHQubGVuZ3RoID09PSAwKSByZXR1cm4gdm9pZCAwO1xuICBjb25zdCBbXywgaWQsIGhpbnRdID0gdFswXTtcbiAgbGV0IHJlbGF5O1xuICBjb25zdCBldmVudCA9IGF3YWl0IHRoaXMubmRrLmZldGNoRXZlbnQoaWQsIHt9LCByZWxheSk7XG4gIHJldHVybiBldmVudDtcbn1cbmFzeW5jIGZ1bmN0aW9uIGZldGNoUm9vdEV2ZW50KHN1Yk9wdHMpIHtcbiAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTkRLIGluc3RhbmNlIG5vdCBmb3VuZFwiKTtcbiAgY29uc3Qgcm9vdFRhZyA9IGdldFJvb3RUYWcodGhpcyk7XG4gIGlmICghcm9vdFRhZykgcmV0dXJuIHZvaWQgMDtcbiAgcmV0dXJuIHRoaXMubmRrLmZldGNoRXZlbnRGcm9tVGFnKHJvb3RUYWcsIHRoaXMsIHN1Yk9wdHMpO1xufVxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hSZXBseUV2ZW50KHN1Yk9wdHMpIHtcbiAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTkRLIGluc3RhbmNlIG5vdCBmb3VuZFwiKTtcbiAgY29uc3QgcmVwbHlUYWcgPSBnZXRSZXBseVRhZyh0aGlzKTtcbiAgaWYgKCFyZXBseVRhZykgcmV0dXJuIHZvaWQgMDtcbiAgcmV0dXJuIHRoaXMubmRrLmZldGNoRXZlbnRGcm9tVGFnKHJlcGx5VGFnLCB0aGlzLCBzdWJPcHRzKTtcbn1cblxuLy8gc3JjL2V2ZW50cy9zZXJpYWxpemVyLnRzXG5mdW5jdGlvbiBzZXJpYWxpemUoaW5jbHVkZVNpZyA9IGZhbHNlLCBpbmNsdWRlSWQgPSBmYWxzZSkge1xuICBjb25zdCBwYXlsb2FkID0gWzAsIHRoaXMucHVia2V5LCB0aGlzLmNyZWF0ZWRfYXQsIHRoaXMua2luZCwgdGhpcy50YWdzLCB0aGlzLmNvbnRlbnRdO1xuICBpZiAoaW5jbHVkZVNpZykgcGF5bG9hZC5wdXNoKHRoaXMuc2lnKTtcbiAgaWYgKGluY2x1ZGVJZCkgcGF5bG9hZC5wdXNoKHRoaXMuaWQpO1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocGF5bG9hZCk7XG59XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZShzZXJpYWxpemVkRXZlbnQpIHtcbiAgY29uc3QgZXZlbnRBcnJheSA9IEpTT04ucGFyc2Uoc2VyaWFsaXplZEV2ZW50KTtcbiAgY29uc3QgcmV0ID0ge1xuICAgIHB1YmtleTogZXZlbnRBcnJheVsxXSxcbiAgICBjcmVhdGVkX2F0OiBldmVudEFycmF5WzJdLFxuICAgIGtpbmQ6IGV2ZW50QXJyYXlbM10sXG4gICAgdGFnczogZXZlbnRBcnJheVs0XSxcbiAgICBjb250ZW50OiBldmVudEFycmF5WzVdXG4gIH07XG4gIGlmIChldmVudEFycmF5Lmxlbmd0aCA+PSA3KSByZXQuc2lnID0gZXZlbnRBcnJheVs2XTtcbiAgaWYgKGV2ZW50QXJyYXkubGVuZ3RoID49IDgpIHJldC5pZCA9IGV2ZW50QXJyYXlbN107XG4gIHJldHVybiByZXQ7XG59XG5cbi8vIHNyYy9ldmVudHMvdmFsaWRhdGlvbi50c1xuaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvc2hhMjU2XCI7XG5pbXBvcnQgeyBieXRlc1RvSGV4IH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvdXRpbHNcIjtcbmltcG9ydCB7IHNjaG5vcnIgfSBmcm9tIFwiQG5vYmxlL2N1cnZlcy9zZWNwMjU2azFcIjtcblxuLy8gc3JjL2V2ZW50cy9zaWduYXR1cmUudHNcbnZhciB3b3JrZXI7XG52YXIgcHJvY2Vzc2luZ1F1ZXVlID0ge307XG5mdW5jdGlvbiBzaWduYXR1cmVWZXJpZmljYXRpb25Jbml0KHcpIHtcbiAgd29ya2VyID0gdztcbiAgd29ya2VyLm9ubWVzc2FnZSA9IChtc2cpID0+IHtcbiAgICBjb25zdCBbZXZlbnRJZCwgcmVzdWx0XSA9IG1zZy5kYXRhO1xuICAgIGNvbnN0IHJlY29yZCA9IHByb2Nlc3NpbmdRdWV1ZVtldmVudElkXTtcbiAgICBpZiAoIXJlY29yZCkge1xuICAgICAgY29uc29sZS5lcnJvcihcIk5vIHJlY29yZCBmb3VuZCBmb3IgZXZlbnRcIiwgZXZlbnRJZCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRlbGV0ZSBwcm9jZXNzaW5nUXVldWVbZXZlbnRJZF07XG4gICAgZm9yIChjb25zdCByZXNvbHZlIG9mIHJlY29yZC5yZXNvbHZlcykge1xuICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgIH1cbiAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHZlcmlmeVNpZ25hdHVyZUFzeW5jKGV2ZW50LCBwZXJzaXN0KSB7XG4gIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBldmVudC5zZXJpYWxpemUoKTtcbiAgICBsZXQgZW5xdWV1ZSA9IGZhbHNlO1xuICAgIGlmICghcHJvY2Vzc2luZ1F1ZXVlW2V2ZW50LmlkXSkge1xuICAgICAgcHJvY2Vzc2luZ1F1ZXVlW2V2ZW50LmlkXSA9IHsgZXZlbnQsIHJlc29sdmVzOiBbXSB9O1xuICAgICAgZW5xdWV1ZSA9IHRydWU7XG4gICAgfVxuICAgIHByb2Nlc3NpbmdRdWV1ZVtldmVudC5pZF0ucmVzb2x2ZXMucHVzaChyZXNvbHZlKTtcbiAgICBpZiAoIWVucXVldWUpIHJldHVybjtcbiAgICB3b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgc2VyaWFsaXplZCxcbiAgICAgIGlkOiBldmVudC5pZCxcbiAgICAgIHNpZzogZXZlbnQuc2lnLFxuICAgICAgcHVia2V5OiBldmVudC5wdWJrZXlcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBwcm9taXNlO1xufVxuXG4vLyBzcmMvZXZlbnRzL3ZhbGlkYXRpb24udHNcbmltcG9ydCB7IExSVUNhY2hlIH0gZnJvbSBcInR5cGVzY3JpcHQtbHJ1LWNhY2hlXCI7XG52YXIgUFVCS0VZX1JFR0VYID0gL15bYS1mMC05XXs2NH0kLztcbmZ1bmN0aW9uIHZhbGlkYXRlKCkge1xuICBpZiAodHlwZW9mIHRoaXMua2luZCAhPT0gXCJudW1iZXJcIikgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIHRoaXMuY29udGVudCAhPT0gXCJzdHJpbmdcIikgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIHRoaXMuY3JlYXRlZF9hdCAhPT0gXCJudW1iZXJcIikgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIHRoaXMucHVia2V5ICE9PSBcInN0cmluZ1wiKSByZXR1cm4gZmFsc2U7XG4gIGlmICghdGhpcy5wdWJrZXkubWF0Y2goUFVCS0VZX1JFR0VYKSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoIUFycmF5LmlzQXJyYXkodGhpcy50YWdzKSkgcmV0dXJuIGZhbHNlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudGFncy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHRhZyA9IHRoaXMudGFnc1tpXTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodGFnKSkgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGFnLmxlbmd0aDsgaisrKSB7XG4gICAgICBpZiAodHlwZW9mIHRhZ1tqXSA9PT0gXCJvYmplY3RcIikgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbnZhciB2ZXJpZmllZFNpZ25hdHVyZXMgPSBuZXcgTFJVQ2FjaGUoe1xuICBtYXhTaXplOiAxZTMsXG4gIGVudHJ5RXhwaXJhdGlvblRpbWVJbk1TOiA2ZTRcbn0pO1xuZnVuY3Rpb24gdmVyaWZ5U2lnbmF0dXJlKHBlcnNpc3QpIHtcbiAgaWYgKHR5cGVvZiB0aGlzLnNpZ25hdHVyZVZlcmlmaWVkID09PSBcImJvb2xlYW5cIikgcmV0dXJuIHRoaXMuc2lnbmF0dXJlVmVyaWZpZWQ7XG4gIGNvbnN0IHByZXZWZXJpZmljYXRpb24gPSB2ZXJpZmllZFNpZ25hdHVyZXMuZ2V0KHRoaXMuaWQpO1xuICBpZiAocHJldlZlcmlmaWNhdGlvbiAhPT0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLnNpZ25hdHVyZVZlcmlmaWVkID0gISFwcmV2VmVyaWZpY2F0aW9uO1xuICB9XG4gIHRyeSB7XG4gICAgaWYgKHRoaXMubmRrPy5hc3luY1NpZ1ZlcmlmaWNhdGlvbikge1xuICAgICAgdmVyaWZ5U2lnbmF0dXJlQXN5bmModGhpcywgcGVyc2lzdCkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgIGlmIChwZXJzaXN0KSB7XG4gICAgICAgICAgdGhpcy5zaWduYXR1cmVWZXJpZmllZCA9IHJlc3VsdDtcbiAgICAgICAgICBpZiAocmVzdWx0KSB2ZXJpZmllZFNpZ25hdHVyZXMuc2V0KHRoaXMuaWQsIHRoaXMuc2lnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgIHRoaXMubmRrLmVtaXQoXCJldmVudDppbnZhbGlkLXNpZ1wiLCB0aGlzKTtcbiAgICAgICAgICB2ZXJpZmllZFNpZ25hdHVyZXMuc2V0KHRoaXMuaWQsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGhhc2ggPSBzaGEyNTYobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHRoaXMuc2VyaWFsaXplKCkpKTtcbiAgICAgIGNvbnN0IHJlcyA9IHNjaG5vcnIudmVyaWZ5KHRoaXMuc2lnLCBoYXNoLCB0aGlzLnB1YmtleSk7XG4gICAgICBpZiAocmVzKSB2ZXJpZmllZFNpZ25hdHVyZXMuc2V0KHRoaXMuaWQsIHRoaXMuc2lnKTtcbiAgICAgIGVsc2UgdmVyaWZpZWRTaWduYXR1cmVzLnNldCh0aGlzLmlkLCBmYWxzZSk7XG4gICAgICByZXR1cm4gdGhpcy5zaWduYXR1cmVWZXJpZmllZCA9IHJlcztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiB0aGlzLnNpZ25hdHVyZVZlcmlmaWVkID0gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEV2ZW50SGFzaCgpIHtcbiAgcmV0dXJuIGdldEV2ZW50SGFzaEZyb21TZXJpYWxpemVkRXZlbnQodGhpcy5zZXJpYWxpemUoKSk7XG59XG5mdW5jdGlvbiBnZXRFdmVudEhhc2hGcm9tU2VyaWFsaXplZEV2ZW50KHNlcmlhbGl6ZWRFdmVudCkge1xuICBjb25zdCBldmVudEhhc2ggPSBzaGEyNTYobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHNlcmlhbGl6ZWRFdmVudCkpO1xuICByZXR1cm4gYnl0ZXNUb0hleChldmVudEhhc2gpO1xufVxuXG4vLyBzcmMvZXZlbnRzL2luZGV4LnRzXG52YXIgc2tpcENsaWVudFRhZ09uS2luZHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIDAgLyogTWV0YWRhdGEgKi8sXG4gIDQgLyogRW5jcnlwdGVkRGlyZWN0TWVzc2FnZSAqLyxcbiAgMTA1OSAvKiBHaWZ0V3JhcCAqLyxcbiAgMTMgLyogR2lmdFdyYXBTZWFsICovLFxuICAzIC8qIENvbnRhY3RzICovLFxuICA5NzM0IC8qIFphcFJlcXVlc3QgKi8sXG4gIDUgLyogRXZlbnREZWxldGlvbiAqL1xuXSk7XG52YXIgTkRLRXZlbnQgPSBjbGFzcyBfTkRLRXZlbnQgZXh0ZW5kcyBFdmVudEVtaXR0ZXIyIHtcbiAgbmRrO1xuICBjcmVhdGVkX2F0O1xuICBjb250ZW50ID0gXCJcIjtcbiAgdGFncyA9IFtdO1xuICBraW5kO1xuICBpZCA9IFwiXCI7XG4gIHNpZztcbiAgcHVia2V5ID0gXCJcIjtcbiAgc2lnbmF0dXJlVmVyaWZpZWQ7XG4gIF9hdXRob3IgPSB2b2lkIDA7XG4gIC8qKlxuICAgKiBUaGUgcmVsYXkgdGhhdCB0aGlzIGV2ZW50IHdhcyBmaXJzdCByZWNlaXZlZCBmcm9tLlxuICAgKi9cbiAgcmVsYXk7XG4gIC8qKlxuICAgKiBUaGUgcmVsYXlzIHRoYXQgdGhpcyBldmVudCB3YXMgcmVjZWl2ZWQgZnJvbSBhbmQvb3Igc3VjY2Vzc2Z1bGx5IHB1Ymxpc2hlZCB0by5cbiAgICovXG4gIGdldCBvblJlbGF5cygpIHtcbiAgICBsZXQgcmVzID0gW107XG4gICAgaWYgKCF0aGlzLm5kaykge1xuICAgICAgaWYgKHRoaXMucmVsYXkpIHJlcy5wdXNoKHRoaXMucmVsYXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXMgPSB0aGlzLm5kay5zdWJNYW5hZ2VyLnNlZW5FdmVudHMuZ2V0KHRoaXMuaWQpIHx8IFtdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgc3RhdHVzIG9mIHRoZSBwdWJsaXNoIG9wZXJhdGlvbi5cbiAgICovXG4gIHB1Ymxpc2hTdGF0dXMgPSBcInN1Y2Nlc3NcIjtcbiAgcHVibGlzaEVycm9yO1xuICBjb25zdHJ1Y3RvcihuZGssIGV2ZW50KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm5kayA9IG5kaztcbiAgICB0aGlzLmNyZWF0ZWRfYXQgPSBldmVudD8uY3JlYXRlZF9hdDtcbiAgICB0aGlzLmNvbnRlbnQgPSBldmVudD8uY29udGVudCB8fCBcIlwiO1xuICAgIHRoaXMudGFncyA9IGV2ZW50Py50YWdzIHx8IFtdO1xuICAgIHRoaXMuaWQgPSBldmVudD8uaWQgfHwgXCJcIjtcbiAgICB0aGlzLnNpZyA9IGV2ZW50Py5zaWc7XG4gICAgdGhpcy5wdWJrZXkgPSBldmVudD8ucHVia2V5IHx8IFwiXCI7XG4gICAgdGhpcy5raW5kID0gZXZlbnQ/LmtpbmQ7XG4gICAgaWYgKGV2ZW50IGluc3RhbmNlb2YgX05ES0V2ZW50KSB7XG4gICAgICBpZiAodGhpcy5yZWxheSkge1xuICAgICAgICB0aGlzLnJlbGF5ID0gZXZlbnQucmVsYXk7XG4gICAgICAgIHRoaXMubmRrPy5zdWJNYW5hZ2VyLnNlZW5FdmVudChldmVudC5pZCwgdGhpcy5yZWxheSk7XG4gICAgICB9XG4gICAgICB0aGlzLnB1Ymxpc2hTdGF0dXMgPSBldmVudC5wdWJsaXNoU3RhdHVzO1xuICAgICAgdGhpcy5wdWJsaXNoRXJyb3IgPSBldmVudC5wdWJsaXNoRXJyb3I7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBEZXNlcmlhbGl6ZSBhbiBOREtFdmVudCBmcm9tIGEgc2VyaWFsaXplZCBwYXlsb2FkLlxuICAgKiBAcGFyYW0gbmRrXG4gICAqIEBwYXJhbSBldmVudFxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgc3RhdGljIGRlc2VyaWFsaXplKG5kaywgZXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtFdmVudChuZGssIGRlc2VyaWFsaXplKGV2ZW50KSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGV2ZW50IGFzIGlzLlxuICAgKi9cbiAgcmF3RXZlbnQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNyZWF0ZWRfYXQ6IHRoaXMuY3JlYXRlZF9hdCxcbiAgICAgIGNvbnRlbnQ6IHRoaXMuY29udGVudCxcbiAgICAgIHRhZ3M6IHRoaXMudGFncyxcbiAgICAgIGtpbmQ6IHRoaXMua2luZCxcbiAgICAgIHB1YmtleTogdGhpcy5wdWJrZXksXG4gICAgICBpZDogdGhpcy5pZCxcbiAgICAgIHNpZzogdGhpcy5zaWdcbiAgICB9O1xuICB9XG4gIHNldCBhdXRob3IodXNlcikge1xuICAgIHRoaXMucHVia2V5ID0gdXNlci5wdWJrZXk7XG4gICAgdGhpcy5fYXV0aG9yID0gdXNlcjtcbiAgICB0aGlzLl9hdXRob3IubmRrID8/PSB0aGlzLm5kaztcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhbiBOREtVc2VyIGZvciB0aGUgYXV0aG9yIG9mIHRoZSBldmVudC5cbiAgICovXG4gIGdldCBhdXRob3IoKSB7XG4gICAgaWYgKHRoaXMuX2F1dGhvcikgcmV0dXJuIHRoaXMuX2F1dGhvcjtcbiAgICBpZiAoIXRoaXMubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBOREsgaW5zdGFuY2UgZm91bmRcIik7XG4gICAgY29uc3QgdXNlciA9IHRoaXMubmRrLmdldFVzZXIoeyBwdWJrZXk6IHRoaXMucHVia2V5IH0pO1xuICAgIHRoaXMuX2F1dGhvciA9IHVzZXI7XG4gICAgcmV0dXJuIHVzZXI7XG4gIH1cbiAgLyoqXG4gICAqIE5JUC03MyB0YWdnaW5nIG9mIGV4dGVybmFsIGVudGl0aWVzXG4gICAqIEBwYXJhbSBlbnRpdHkgdG8gYmUgdGFnZ2VkXG4gICAqIEBwYXJhbSB0eXBlIG9mIHRoZSBlbnRpdHlcbiAgICogQHBhcmFtIG1hcmtlclVybCB0byBiZSB1c2VkIGFzIHRoZSBtYXJrZXIgVVJMXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogZXZlbnQudGFnRXh0ZXJuYWwoXCJodHRwczovL2V4YW1wbGUuY29tL2FydGljbGUvMTIzI25vc3RyXCIsIFwidXJsXCIpO1xuICAgKiBldmVudC50YWdzID0+IFtbXCJpXCIsIFwiaHR0cHM6Ly9leGFtcGxlLmNvbS8xMjNcIl0sIFtcImtcIiwgXCJodHRwczovL2V4YW1wbGUuY29tXCJdXVxuICAgKiBgYGBcbiAgICpcbiAgICogQGV4YW1wbGUgdGFnIGEgcG9kY2FzdDppdGVtOmd1aWRcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBldmVudC50YWdFeHRlcm5hbChcImUzMmI0ODkwLWI5ZWEtNGFlZi1hMGJmLTU0Yjc4NzgzM2RjNVwiLCBcInBvZGNhc3Q6aXRlbTpndWlkXCIpO1xuICAgKiBldmVudC50YWdzID0+IFtbXCJpXCIsIFwicG9kY2FzdDppdGVtOmd1aWQ6ZTMyYjQ4OTAtYjllYS00YWVmLWEwYmYtNTRiNzg3ODMzZGM1XCJdLCBbXCJrXCIsIFwicG9kY2FzdDppdGVtOmd1aWRcIl1dXG4gICAqIGBgYFxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ub3N0ci1wcm90b2NvbC9uaXBzL2Jsb2IvbWFzdGVyLzczLm1kXG4gICAqL1xuICB0YWdFeHRlcm5hbChlbnRpdHksIHR5cGUsIG1hcmtlclVybCkge1xuICAgIGxldCBpVGFnID0gW1wiaVwiXTtcbiAgICBsZXQga1RhZyA9IFtcImtcIl07XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFwidXJsXCI6XG4gICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoZW50aXR5KTtcbiAgICAgICAgdXJsLmhhc2ggPSBcIlwiO1xuICAgICAgICBpVGFnLnB1c2godXJsLnRvU3RyaW5nKCkpO1xuICAgICAgICBrVGFnLnB1c2goYCR7dXJsLnByb3RvY29sfS8vJHt1cmwuaG9zdH1gKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiaGFzaHRhZ1wiOlxuICAgICAgICBpVGFnLnB1c2goYCMke2VudGl0eS50b0xvd2VyQ2FzZSgpfWApO1xuICAgICAgICBrVGFnLnB1c2goXCIjXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJnZW9oYXNoXCI6XG4gICAgICAgIGlUYWcucHVzaChgZ2VvOiR7ZW50aXR5LnRvTG93ZXJDYXNlKCl9YCk7XG4gICAgICAgIGtUYWcucHVzaChcImdlb1wiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiaXNiblwiOlxuICAgICAgICBpVGFnLnB1c2goYGlzYm46JHtlbnRpdHkucmVwbGFjZSgvLS9nLCBcIlwiKX1gKTtcbiAgICAgICAga1RhZy5wdXNoKFwiaXNiblwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwicG9kY2FzdDpndWlkXCI6XG4gICAgICAgIGlUYWcucHVzaChgcG9kY2FzdDpndWlkOiR7ZW50aXR5fWApO1xuICAgICAgICBrVGFnLnB1c2goXCJwb2RjYXN0Omd1aWRcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInBvZGNhc3Q6aXRlbTpndWlkXCI6XG4gICAgICAgIGlUYWcucHVzaChgcG9kY2FzdDppdGVtOmd1aWQ6JHtlbnRpdHl9YCk7XG4gICAgICAgIGtUYWcucHVzaChcInBvZGNhc3Q6aXRlbTpndWlkXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJwb2RjYXN0OnB1Ymxpc2hlcjpndWlkXCI6XG4gICAgICAgIGlUYWcucHVzaChgcG9kY2FzdDpwdWJsaXNoZXI6Z3VpZDoke2VudGl0eX1gKTtcbiAgICAgICAga1RhZy5wdXNoKFwicG9kY2FzdDpwdWJsaXNoZXI6Z3VpZFwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiaXNhblwiOlxuICAgICAgICBpVGFnLnB1c2goYGlzYW46JHtlbnRpdHkuc3BsaXQoXCItXCIpLnNsaWNlKDAsIDQpLmpvaW4oXCItXCIpfWApO1xuICAgICAgICBrVGFnLnB1c2goXCJpc2FuXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJkb2lcIjpcbiAgICAgICAgaVRhZy5wdXNoKGBkb2k6JHtlbnRpdHkudG9Mb3dlckNhc2UoKX1gKTtcbiAgICAgICAga1RhZy5wdXNoKFwiZG9pXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgTklQLTczIGVudGl0eSB0eXBlOiAke3R5cGV9YCk7XG4gICAgfVxuICAgIGlmIChtYXJrZXJVcmwpIHtcbiAgICAgIGlUYWcucHVzaChtYXJrZXJVcmwpO1xuICAgIH1cbiAgICB0aGlzLnRhZ3MucHVzaChpVGFnKTtcbiAgICB0aGlzLnRhZ3MucHVzaChrVGFnKTtcbiAgfVxuICAvKipcbiAgICogVGFnIGEgdXNlciB3aXRoIGFuIG9wdGlvbmFsIG1hcmtlci5cbiAgICogQHBhcmFtIHRhcmdldCBXaGF0IGlzIHRvIGJlIHRhZ2dlZC4gQ2FuIGJlIGFuIE5ES1VzZXIsIE5ES0V2ZW50LCBvciBhbiBOREtUYWcuXG4gICAqIEBwYXJhbSBtYXJrZXIgVGhlIG1hcmtlciB0byB1c2UgaW4gdGhlIHRhZy5cbiAgICogQHBhcmFtIHNraXBBdXRob3JUYWcgV2hldGhlciB0byBleHBsaWNpdGx5IHNraXAgYWRkaW5nIHRoZSBhdXRob3IgdGFnIG9mIHRoZSBldmVudC5cbiAgICogQHBhcmFtIGZvcmNlVGFnIEZvcmNlIGEgc3BlY2lmaWMgdGFnIHRvIGJlIHVzZWQgaW5zdGVhZCBvZiB0aGUgZGVmYXVsdCBcImVcIiBvciBcImFcIiB0YWcuXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogcmVwbHkudGFnKG9wRXZlbnQsIFwicmVwbHlcIik7XG4gICAqIC8vIHJlcGx5LnRhZ3MgPT4gW1tcImVcIiwgPGlkPiwgPHJlbGF5PiwgXCJyZXBseVwiXV1cbiAgICogYGBgXG4gICAqL1xuICB0YWcodGFyZ2V0LCBtYXJrZXIsIHNraXBBdXRob3JUYWcsIGZvcmNlVGFnKSB7XG4gICAgbGV0IHRhZ3MgPSBbXTtcbiAgICBjb25zdCBpc05ES1VzZXIgPSB0YXJnZXQuZmV0Y2hQcm9maWxlICE9PSB2b2lkIDA7XG4gICAgaWYgKGlzTkRLVXNlcikge1xuICAgICAgZm9yY2VUYWcgPz89IFwicFwiO1xuICAgICAgY29uc3QgdGFnID0gW2ZvcmNlVGFnLCB0YXJnZXQucHVia2V5XTtcbiAgICAgIGlmIChtYXJrZXIpIHRhZy5wdXNoKC4uLltcIlwiLCBtYXJrZXJdKTtcbiAgICAgIHRhZ3MucHVzaCh0YWcpO1xuICAgIH0gZWxzZSBpZiAodGFyZ2V0IGluc3RhbmNlb2YgX05ES0V2ZW50KSB7XG4gICAgICBjb25zdCBldmVudCA9IHRhcmdldDtcbiAgICAgIHNraXBBdXRob3JUYWcgPz89IGV2ZW50Py5wdWJrZXkgPT09IHRoaXMucHVia2V5O1xuICAgICAgdGFncyA9IGV2ZW50LnJlZmVyZW5jZVRhZ3MobWFya2VyLCBza2lwQXV0aG9yVGFnLCBmb3JjZVRhZyk7XG4gICAgICBmb3IgKGNvbnN0IHBUYWcgb2YgZXZlbnQuZ2V0TWF0Y2hpbmdUYWdzKFwicFwiKSkge1xuICAgICAgICBpZiAocFRhZ1sxXSA9PT0gdGhpcy5wdWJrZXkpIGNvbnRpbnVlO1xuICAgICAgICBpZiAodGhpcy50YWdzLmZpbmQoKHQpID0+IHRbMF0gPT09IFwicFwiICYmIHRbMV0gPT09IHBUYWdbMV0pKSBjb250aW51ZTtcbiAgICAgICAgdGhpcy50YWdzLnB1c2goW1wicFwiLCBwVGFnWzFdXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkpIHtcbiAgICAgIHRhZ3MgPSBbdGFyZ2V0XTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhcmd1bWVudFwiLCB0YXJnZXQpO1xuICAgIH1cbiAgICB0aGlzLnRhZ3MgPSBtZXJnZVRhZ3ModGhpcy50YWdzLCB0YWdzKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGEgTm9zdHJFdmVudCBvYmplY3QsIHRyeWluZyB0byBmaWxsIGluIG1pc3NpbmcgZmllbGRzXG4gICAqIHdoZW4gcG9zc2libGUsIGFkZGluZyB0YWdzIHdoZW4gbmVjZXNzYXJ5LlxuICAgKiBAcGFyYW0gcHVia2V5IHtzdHJpbmd9IFRoZSBwdWJrZXkgb2YgdGhlIHVzZXIgd2hvIHRoZSBldmVudCBiZWxvbmdzIHRvLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxOb3N0ckV2ZW50Pn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBOb3N0ckV2ZW50LlxuICAgKi9cbiAgYXN5bmMgdG9Ob3N0ckV2ZW50KHB1YmtleSkge1xuICAgIGlmICghcHVia2V5ICYmIHRoaXMucHVia2V5ID09PSBcIlwiKSB7XG4gICAgICBjb25zdCB1c2VyID0gYXdhaXQgdGhpcy5uZGs/LnNpZ25lcj8udXNlcigpO1xuICAgICAgdGhpcy5wdWJrZXkgPSB1c2VyPy5wdWJrZXkgfHwgXCJcIjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmNyZWF0ZWRfYXQpIHtcbiAgICAgIHRoaXMuY3JlYXRlZF9hdCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDFlMyk7XG4gICAgfVxuICAgIGNvbnN0IHsgY29udGVudCwgdGFncyB9ID0gYXdhaXQgdGhpcy5nZW5lcmF0ZVRhZ3MoKTtcbiAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50IHx8IFwiXCI7XG4gICAgdGhpcy50YWdzID0gdGFncztcbiAgICB0cnkge1xuICAgICAgdGhpcy5pZCA9IHRoaXMuZ2V0RXZlbnRIYXNoKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yYXdFdmVudCgpO1xuICB9XG4gIHNlcmlhbGl6ZSA9IHNlcmlhbGl6ZS5iaW5kKHRoaXMpO1xuICBnZXRFdmVudEhhc2ggPSBnZXRFdmVudEhhc2guYmluZCh0aGlzKTtcbiAgdmFsaWRhdGUgPSB2YWxpZGF0ZS5iaW5kKHRoaXMpO1xuICB2ZXJpZnlTaWduYXR1cmUgPSB2ZXJpZnlTaWduYXR1cmUuYmluZCh0aGlzKTtcbiAgLyoqXG4gICAqIElzIHRoaXMgZXZlbnQgcmVwbGFjZWFibGUgKHdoZXRoZXIgcGFyYW1ldGVyaXplZCBvciBub3QpP1xuICAgKlxuICAgKiBUaGlzIHdpbGwgcmV0dXJuIHRydWUgZm9yIGtpbmQgMCwgMywgMTBrLTIwayBhbmQgMzBrLTQwa1xuICAgKi9cbiAgaXNSZXBsYWNlYWJsZSA9IGlzUmVwbGFjZWFibGUuYmluZCh0aGlzKTtcbiAgaXNFcGhlbWVyYWwgPSBpc0VwaGVtZXJhbC5iaW5kKHRoaXMpO1xuICBpc0R2bSA9ICgpID0+IHRoaXMua2luZCAmJiB0aGlzLmtpbmQgPj0gNWUzICYmIHRoaXMua2luZCA8PSA3ZTM7XG4gIC8qKlxuICAgKiBJcyB0aGlzIGV2ZW50IHBhcmFtZXRlcml6ZWQgcmVwbGFjZWFibGU/XG4gICAqXG4gICAqIFRoaXMgd2lsbCByZXR1cm4gdHJ1ZSBmb3Iga2luZCAzMGstNDBrXG4gICAqL1xuICBpc1BhcmFtUmVwbGFjZWFibGUgPSBpc1BhcmFtUmVwbGFjZWFibGUuYmluZCh0aGlzKTtcbiAgLyoqXG4gICAqIEVuY29kZXMgYSBiZWNoMzIgaWQuXG4gICAqXG4gICAqIEBwYXJhbSByZWxheXMge3N0cmluZ1tdfSBUaGUgcmVsYXlzIHRvIGVuY29kZSBpbiB0aGUgaWRcbiAgICogQHJldHVybnMge3N0cmluZ30gLSBFbmNvZGVkIG5hZGRyLCBub3RlIG9yIG5ldmVudC5cbiAgICovXG4gIGVuY29kZSA9IGVuY29kZS5iaW5kKHRoaXMpO1xuICBlbmNyeXB0ID0gZW5jcnlwdC5iaW5kKHRoaXMpO1xuICBkZWNyeXB0ID0gZGVjcnlwdC5iaW5kKHRoaXMpO1xuICAvKipcbiAgICogR2V0IGFsbCB0YWdzIHdpdGggdGhlIGdpdmVuIG5hbWVcbiAgICogQHBhcmFtIHRhZ05hbWUge3N0cmluZ30gVGhlIG5hbWUgb2YgdGhlIHRhZyB0byBzZWFyY2ggZm9yXG4gICAqIEByZXR1cm5zIHtOREtUYWdbXX0gQW4gYXJyYXkgb2YgdGhlIG1hdGNoaW5nIHRhZ3NcbiAgICovXG4gIGdldE1hdGNoaW5nVGFncyh0YWdOYW1lLCBtYXJrZXIpIHtcbiAgICBjb25zdCB0ID0gdGhpcy50YWdzLmZpbHRlcigodGFnKSA9PiB0YWdbMF0gPT09IHRhZ05hbWUpO1xuICAgIGlmIChtYXJrZXIgPT09IHZvaWQgMCkgcmV0dXJuIHQ7XG4gICAgcmV0dXJuIHQuZmlsdGVyKCh0YWcpID0+IHRhZ1szXSA9PT0gbWFya2VyKTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIGV2ZW50IGhhcyBhIHRhZyB3aXRoIHRoZSBnaXZlbiBuYW1lXG4gICAqIEBwYXJhbSB0YWdOYW1lXG4gICAqIEBwYXJhbSBtYXJrZXJcbiAgICogQHJldHVybnNcbiAgICovXG4gIGhhc1RhZyh0YWdOYW1lLCBtYXJrZXIpIHtcbiAgICByZXR1cm4gdGhpcy50YWdzLnNvbWUoKHRhZykgPT4gdGFnWzBdID09PSB0YWdOYW1lICYmICghbWFya2VyIHx8IHRhZ1szXSA9PT0gbWFya2VyKSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgZmlyc3QgdGFnIHdpdGggdGhlIGdpdmVuIG5hbWVcbiAgICogQHBhcmFtIHRhZ05hbWUgVGFnIG5hbWUgdG8gc2VhcmNoIGZvclxuICAgKiBAcmV0dXJucyBUaGUgdmFsdWUgb2YgdGhlIGZpcnN0IHRhZyB3aXRoIHRoZSBnaXZlbiBuYW1lLCBvciB1bmRlZmluZWQgaWYgbm8gc3VjaCB0YWcgZXhpc3RzXG4gICAqL1xuICB0YWdWYWx1ZSh0YWdOYW1lKSB7XG4gICAgY29uc3QgdGFncyA9IHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKHRhZ05hbWUpO1xuICAgIGlmICh0YWdzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHZvaWQgMDtcbiAgICByZXR1cm4gdGFnc1swXVsxXTtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgTklQLTMxIFwiYWx0XCIgdGFnIG9mIHRoZSBldmVudC5cbiAgICovXG4gIGdldCBhbHQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJhbHRcIik7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIE5JUC0zMSBcImFsdFwiIHRhZyBvZiB0aGUgZXZlbnQuIFVzZSB0aGlzIHRvIHNldCBhbiBhbHQgdGFnIHNvXG4gICAqIGNsaWVudHMgdGhhdCBkb24ndCBoYW5kbGUgYSBwYXJ0aWN1bGFyIGV2ZW50IGtpbmQgY2FuIGRpc3BsYXkgc29tZXRoaW5nXG4gICAqIHVzZWZ1bCBmb3IgdXNlcnMuXG4gICAqL1xuICBzZXQgYWx0KGFsdCkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwiYWx0XCIpO1xuICAgIGlmIChhbHQpIHRoaXMudGFncy5wdXNoKFtcImFsdFwiLCBhbHRdKTtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgTklQLTMzIFwiZFwiIHRhZyBvZiB0aGUgZXZlbnQuXG4gICAqL1xuICBnZXQgZFRhZygpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcImRcIik7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIE5JUC0zMyBcImRcIiB0YWcgb2YgdGhlIGV2ZW50LlxuICAgKi9cbiAgc2V0IGRUYWcodmFsdWUpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImRcIik7XG4gICAgaWYgKHZhbHVlKSB0aGlzLnRhZ3MucHVzaChbXCJkXCIsIHZhbHVlXSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSBhbGwgdGFncyB3aXRoIHRoZSBnaXZlbiBuYW1lIChlLmcuIFwiZFwiLCBcImFcIiwgXCJwXCIpXG4gICAqIEBwYXJhbSB0YWdOYW1lIFRhZyBuYW1lKHMpIHRvIHNlYXJjaCBmb3IgYW5kIHJlbW92ZVxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIHJlbW92ZVRhZyh0YWdOYW1lKSB7XG4gICAgY29uc3QgdGFnTmFtZXMgPSBBcnJheS5pc0FycmF5KHRhZ05hbWUpID8gdGFnTmFtZSA6IFt0YWdOYW1lXTtcbiAgICB0aGlzLnRhZ3MgPSB0aGlzLnRhZ3MuZmlsdGVyKCh0YWcpID0+ICF0YWdOYW1lcy5pbmNsdWRlcyh0YWdbMF0pKTtcbiAgfVxuICAvKipcbiAgICogU2lnbiB0aGUgZXZlbnQgaWYgYSBzaWduZXIgaXMgcHJlc2VudC5cbiAgICpcbiAgICogSXQgd2lsbCBnZW5lcmF0ZSB0YWdzLlxuICAgKiBSZXBsZWFjYWJsZSBldmVudHMgd2lsbCBoYXZlIHRoZWlyIGNyZWF0ZWRfYXQgZmllbGQgc2V0IHRvIHRoZSBjdXJyZW50IHRpbWUuXG4gICAqIEBwYXJhbSBzaWduZXIge05ES1NpZ25lcn0gVGhlIE5ES1NpZ25lciB0byB1c2UgdG8gc2lnbiB0aGUgZXZlbnRcbiAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHNpZ25hdHVyZSBvZiB0aGUgc2lnbmVkIGV2ZW50LlxuICAgKi9cbiAgYXN5bmMgc2lnbihzaWduZXIpIHtcbiAgICBpZiAoIXNpZ25lcikge1xuICAgICAgdGhpcy5uZGs/LmFzc2VydFNpZ25lcigpO1xuICAgICAgc2lnbmVyID0gdGhpcy5uZGsuc2lnbmVyO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmF1dGhvciA9IGF3YWl0IHNpZ25lci51c2VyKCk7XG4gICAgfVxuICAgIGNvbnN0IG5vc3RyRXZlbnQgPSBhd2FpdCB0aGlzLnRvTm9zdHJFdmVudCgpO1xuICAgIHRoaXMuc2lnID0gYXdhaXQgc2lnbmVyLnNpZ24obm9zdHJFdmVudCk7XG4gICAgcmV0dXJuIHRoaXMuc2lnO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0gcmVsYXlTZXRcbiAgICogQHBhcmFtIHRpbWVvdXRNc1xuICAgKiBAcGFyYW0gcmVxdWlyZWRSZWxheUNvdW50XG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBhc3luYyBwdWJsaXNoUmVwbGFjZWFibGUocmVsYXlTZXQsIHRpbWVvdXRNcywgcmVxdWlyZWRSZWxheUNvdW50KSB7XG4gICAgdGhpcy5pZCA9IFwiXCI7XG4gICAgdGhpcy5jcmVhdGVkX2F0ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMWUzKTtcbiAgICB0aGlzLnNpZyA9IFwiXCI7XG4gICAgcmV0dXJuIHRoaXMucHVibGlzaChyZWxheVNldCwgdGltZW91dE1zLCByZXF1aXJlZFJlbGF5Q291bnQpO1xuICB9XG4gIC8qKlxuICAgKiBBdHRlbXB0IHRvIHNpZ24gYW5kIHRoZW4gcHVibGlzaCBhbiBOREtFdmVudCB0byBhIGdpdmVuIHJlbGF5U2V0LlxuICAgKiBJZiBubyByZWxheVNldCBpcyBwcm92aWRlZCwgdGhlIHJlbGF5U2V0IHdpbGwgYmUgY2FsY3VsYXRlZCBieSBOREsuXG4gICAqIEBwYXJhbSByZWxheVNldCB7TkRLUmVsYXlTZXR9IFRoZSByZWxheVNldCB0byBwdWJsaXNoIHRoZSBldmVuIHRvLlxuICAgKiBAcGFyYW0gdGltZW91dE0ge251bWJlcn0gVGhlIHRpbWVvdXQgZm9yIHRoZSBwdWJsaXNoIG9wZXJhdGlvbiBpbiBtaWxsaXNlY29uZHMuXG4gICAqIEBwYXJhbSByZXF1aXJlZFJlbGF5Q291bnQgVGhlIG51bWJlciBvZiByZWxheXMgdGhhdCBtdXN0IHJlY2VpdmUgdGhlIGV2ZW50IGZvciB0aGUgcHVibGlzaCB0byBiZSBjb25zaWRlcmVkIHN1Y2Nlc3NmdWwuXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSByZWxheXMgdGhlIGV2ZW50IHdhcyBwdWJsaXNoZWQgdG8uXG4gICAqL1xuICBhc3luYyBwdWJsaXNoKHJlbGF5U2V0LCB0aW1lb3V0TXMsIHJlcXVpcmVkUmVsYXlDb3VudCkge1xuICAgIGlmICghdGhpcy5zaWcpIGF3YWl0IHRoaXMuc2lnbigpO1xuICAgIGlmICghdGhpcy5uZGspXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOREtFdmVudCBtdXN0IGJlIGFzc29jaWF0ZWQgd2l0aCBhbiBOREsgaW5zdGFuY2UgdG8gcHVibGlzaFwiKTtcbiAgICBpZiAoIXJlbGF5U2V0KSB7XG4gICAgICByZWxheVNldCA9IHRoaXMubmRrLmRldldyaXRlUmVsYXlTZXQgfHwgYXdhaXQgY2FsY3VsYXRlUmVsYXlTZXRGcm9tRXZlbnQodGhpcy5uZGssIHRoaXMpO1xuICAgIH1cbiAgICBpZiAodGhpcy5raW5kID09PSA1IC8qIEV2ZW50RGVsZXRpb24gKi8gJiYgdGhpcy5uZGsuY2FjaGVBZGFwdGVyPy5kZWxldGVFdmVudElkcykge1xuICAgICAgY29uc3QgZVRhZ3MgPSB0aGlzLmdldE1hdGNoaW5nVGFncyhcImVcIikubWFwKCh0YWcpID0+IHRhZ1sxXSk7XG4gICAgICB0aGlzLm5kay5jYWNoZUFkYXB0ZXIuZGVsZXRlRXZlbnRJZHMoZVRhZ3MpO1xuICAgIH1cbiAgICBjb25zdCByYXdFdmVudCA9IHRoaXMucmF3RXZlbnQoKTtcbiAgICBpZiAodGhpcy5uZGsuY2FjaGVBZGFwdGVyPy5hZGRVbnB1Ymxpc2hlZEV2ZW50ICYmIHNob3VsZFRyYWNrVW5wdWJsaXNoZWRFdmVudCh0aGlzKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5uZGsuY2FjaGVBZGFwdGVyLmFkZFVucHVibGlzaGVkRXZlbnQodGhpcywgcmVsYXlTZXQucmVsYXlVcmxzKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGFkZGluZyB1bnB1Ymxpc2hlZCBldmVudCB0byBjYWNoZVwiLCBlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMua2luZCA9PT0gNSAvKiBFdmVudERlbGV0aW9uICovICYmIHRoaXMubmRrLmNhY2hlQWRhcHRlcj8uZGVsZXRlRXZlbnRJZHMpIHtcbiAgICAgIHRoaXMubmRrLmNhY2hlQWRhcHRlci5kZWxldGVFdmVudElkcyh0aGlzLmdldE1hdGNoaW5nVGFncyhcImVcIikubWFwKCh0YWcpID0+IHRhZ1sxXSkpO1xuICAgIH1cbiAgICB0aGlzLm5kay5zdWJNYW5hZ2VyLmRpc3BhdGNoRXZlbnQocmF3RXZlbnQsIHZvaWQgMCwgdHJ1ZSk7XG4gICAgY29uc3QgcmVsYXlzID0gYXdhaXQgcmVsYXlTZXQucHVibGlzaCh0aGlzLCB0aW1lb3V0TXMsIHJlcXVpcmVkUmVsYXlDb3VudCk7XG4gICAgcmVsYXlzLmZvckVhY2goKHJlbGF5KSA9PiB0aGlzLm5kaz8uc3ViTWFuYWdlci5zZWVuRXZlbnQodGhpcy5pZCwgcmVsYXkpKTtcbiAgICByZXR1cm4gcmVsYXlzO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgdGFncyBmb3IgdXNlcnMsIG5vdGVzLCBhbmQgb3RoZXIgZXZlbnRzIHRhZ2dlZCBpbiBjb250ZW50LlxuICAgKiBXaWxsIGFsc28gZ2VuZXJhdGUgcmFuZG9tIFwiZFwiIHRhZyBmb3IgcGFyYW1ldGVyaXplZCByZXBsYWNlYWJsZSBldmVudHMgd2hlcmUgbmVlZGVkLlxuICAgKiBAcmV0dXJucyB7Q29udGVudFRhZ30gVGhlIHRhZ3MgYW5kIGNvbnRlbnQgb2YgdGhlIGV2ZW50LlxuICAgKi9cbiAgYXN5bmMgZ2VuZXJhdGVUYWdzKCkge1xuICAgIGxldCB0YWdzID0gW107XG4gICAgY29uc3QgZyA9IGF3YWl0IGdlbmVyYXRlQ29udGVudFRhZ3ModGhpcy5jb250ZW50LCB0aGlzLnRhZ3MpO1xuICAgIGNvbnN0IGNvbnRlbnQgPSBnLmNvbnRlbnQ7XG4gICAgdGFncyA9IGcudGFncztcbiAgICBpZiAodGhpcy5raW5kICYmIHRoaXMuaXNQYXJhbVJlcGxhY2VhYmxlKCkpIHtcbiAgICAgIGNvbnN0IGRUYWcgPSB0aGlzLmdldE1hdGNoaW5nVGFncyhcImRcIilbMF07XG4gICAgICBpZiAoIWRUYWcpIHtcbiAgICAgICAgY29uc3QgdGl0bGUgPSB0aGlzLnRhZ1ZhbHVlKFwidGl0bGVcIik7XG4gICAgICAgIGNvbnN0IHJhbmRMZW5ndGggPSB0aXRsZSA/IDYgOiAxNjtcbiAgICAgICAgbGV0IHN0ciA9IFsuLi5BcnJheShyYW5kTGVuZ3RoKV0ubWFwKCgpID0+IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpWzJdKS5qb2luKFwiXCIpO1xuICAgICAgICBpZiAodGl0bGUgJiYgdGl0bGUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHN0ciA9IHRpdGxlLnJlcGxhY2UoL1teYS16MC05XSsvZ2ksIFwiLVwiKS5yZXBsYWNlKC9eLXwtJC9nLCBcIlwiKSArIFwiLVwiICsgc3RyO1xuICAgICAgICB9XG4gICAgICAgIHRhZ3MucHVzaChbXCJkXCIsIHN0cl0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5zaG91bGRBZGRDbGllbnRUYWcpIHtcbiAgICAgIGNvbnN0IGNsaWVudFRhZyA9IFtcImNsaWVudFwiLCB0aGlzLm5kay5jbGllbnROYW1lID8/IFwiXCJdO1xuICAgICAgaWYgKHRoaXMubmRrLmNsaWVudE5pcDg5KSBjbGllbnRUYWcucHVzaCh0aGlzLm5kay5jbGllbnROaXA4OSk7XG4gICAgICB0YWdzLnB1c2goY2xpZW50VGFnKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc2hvdWxkU3RyaXBDbGllbnRUYWcpIHtcbiAgICAgIHRhZ3MgPSB0YWdzLmZpbHRlcigodGFnKSA9PiB0YWdbMF0gIT09IFwiY2xpZW50XCIpO1xuICAgIH1cbiAgICByZXR1cm4geyBjb250ZW50OiBjb250ZW50IHx8IFwiXCIsIHRhZ3MgfTtcbiAgfVxuICBnZXQgc2hvdWxkQWRkQ2xpZW50VGFnKCkge1xuICAgIGlmICghdGhpcy5uZGs/LmNsaWVudE5hbWUgJiYgIXRoaXMubmRrPy5jbGllbnROaXA4OSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChza2lwQ2xpZW50VGFnT25LaW5kcy5oYXModGhpcy5raW5kKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0aGlzLmlzRXBoZW1lcmFsKCkgfHwgdGhpcy5pc1JlcGxhY2VhYmxlKCkpIHJldHVybiBmYWxzZTtcbiAgICBpZiAodGhpcy5pc0R2bSgpKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHRoaXMuaGFzVGFnKFwiY2xpZW50XCIpKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZ2V0IHNob3VsZFN0cmlwQ2xpZW50VGFnKCkge1xuICAgIHJldHVybiBza2lwQ2xpZW50VGFnT25LaW5kcy5oYXModGhpcy5raW5kKTtcbiAgfVxuICBtdXRlZCgpIHtcbiAgICBjb25zdCBhdXRob3JNdXRlZEVudHJ5ID0gdGhpcy5uZGs/Lm11dGVkSWRzLmdldCh0aGlzLnB1YmtleSk7XG4gICAgaWYgKGF1dGhvck11dGVkRW50cnkgJiYgYXV0aG9yTXV0ZWRFbnRyeSA9PT0gXCJwXCIpIHJldHVybiBcImF1dGhvclwiO1xuICAgIGNvbnN0IGV2ZW50VGFnUmVmZXJlbmNlID0gdGhpcy50YWdSZWZlcmVuY2UoKTtcbiAgICBjb25zdCBldmVudE11dGVkRW50cnkgPSB0aGlzLm5kaz8ubXV0ZWRJZHMuZ2V0KGV2ZW50VGFnUmVmZXJlbmNlWzFdKTtcbiAgICBpZiAoZXZlbnRNdXRlZEVudHJ5ICYmIGV2ZW50TXV0ZWRFbnRyeSA9PT0gZXZlbnRUYWdSZWZlcmVuY2VbMF0pIHJldHVybiBcImV2ZW50XCI7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIFwiZFwiIHRhZyBvZiBhIHBhcmFtZXRlcml6ZWQgcmVwbGFjZWFibGUgZXZlbnQgb3IgdGhyb3dzIGFuIGVycm9yIGlmIHRoZSBldmVudCBpc24ndFxuICAgKiBhIHBhcmFtZXRlcml6ZWQgcmVwbGFjZWFibGUgZXZlbnQuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBcImRcIiB0YWcgb2YgdGhlIGV2ZW50LlxuICAgKiBcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGBkVGFnYCBpbnN0ZWFkLlxuICAgKi9cbiAgcmVwbGFjZWFibGVEVGFnKCkge1xuICAgIGlmICh0aGlzLmtpbmQgJiYgdGhpcy5raW5kID49IDNlNCAmJiB0aGlzLmtpbmQgPD0gNGU0KSB7XG4gICAgICBjb25zdCBkVGFnID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJkXCIpWzBdO1xuICAgICAgY29uc3QgZFRhZ0lkID0gZFRhZyA/IGRUYWdbMV0gOiBcIlwiO1xuICAgICAgcmV0dXJuIGRUYWdJZDtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnQgaXMgbm90IGEgcGFyYW1ldGVyaXplZCByZXBsYWNlYWJsZSBldmVudFwiKTtcbiAgfVxuICAvKipcbiAgICogUHJvdmlkZXMgYSBkZWR1cGxpY2F0aW9uIGtleSBmb3IgdGhlIGV2ZW50LlxuICAgKlxuICAgKiBGb3Iga2luZHMgMCwgMywgMTBrLTIwayB0aGlzIHdpbGwgYmUgdGhlIGV2ZW50IDxraW5kPjo8cHVia2V5PlxuICAgKiBGb3Iga2luZHMgMzBrLTQwayB0aGlzIHdpbGwgYmUgdGhlIGV2ZW50IDxraW5kPjo8cHVia2V5Pjo8ZC10YWc+XG4gICAqIEZvciBhbGwgb3RoZXIga2luZHMgdGhpcyB3aWxsIGJlIHRoZSBldmVudCBpZFxuICAgKi9cbiAgZGVkdXBsaWNhdGlvbktleSgpIHtcbiAgICBpZiAodGhpcy5raW5kID09PSAwIHx8IHRoaXMua2luZCA9PT0gMyB8fCB0aGlzLmtpbmQgJiYgdGhpcy5raW5kID49IDFlNCAmJiB0aGlzLmtpbmQgPCAyZTQpIHtcbiAgICAgIHJldHVybiBgJHt0aGlzLmtpbmR9OiR7dGhpcy5wdWJrZXl9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMudGFnSWQoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGlkIG9mIHRoZSBldmVudCBvciwgaWYgaXQncyBhIHBhcmFtZXRlcml6ZWQgZXZlbnQsIHRoZSBnZW5lcmF0ZWQgaWQgb2YgdGhlIGV2ZW50IHVzaW5nIFwiZFwiIHRhZywgcHVia2V5LCBhbmQga2luZC5cbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGlkXG4gICAqL1xuICB0YWdJZCgpIHtcbiAgICBpZiAodGhpcy5pc1BhcmFtUmVwbGFjZWFibGUoKSkge1xuICAgICAgcmV0dXJuIHRoaXMudGFnQWRkcmVzcygpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5pZDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIHN0YWJsZSByZWZlcmVuY2UgdmFsdWUgZm9yIGEgcmVwbGFjZWFibGUgZXZlbnQuXG4gICAqIFxuICAgKiBQYXJhbSByZXBsYWNlYWJsZSBldmVudHMgYXJlIHJldHVybmVkIGluIHRoZSBleHBlY3RlZCBmb3JtYXQgb2YgYDxraW5kPjo8cHVia2V5Pjo8ZC10YWc+YC5cbiAgICogS2luZC1yZXBsYWNlYWJsZSBldmVudHMgYXJlIHJldHVybmVkIGluIHRoZSBmb3JtYXQgb2YgYDxraW5kPjo8cHVia2V5PjpgLlxuICAgKiBcbiAgICogQHJldHVybnMge3N0cmluZ30gQSBzdGFibGUgcmVmZXJlbmNlIHZhbHVlIGZvciByZXBsYWNlYWJsZSBldmVudHNcbiAgICovXG4gIHRhZ0FkZHJlc3MoKSB7XG4gICAgaWYgKHRoaXMuaXNQYXJhbVJlcGxhY2VhYmxlKCkpIHtcbiAgICAgIGNvbnN0IGRUYWdJZCA9IHRoaXMuZFRhZyA/PyBcIlwiO1xuICAgICAgcmV0dXJuIGAke3RoaXMua2luZH06JHt0aGlzLnB1YmtleX06JHtkVGFnSWR9YDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNSZXBsYWNlYWJsZSgpKSB7XG4gICAgICByZXR1cm4gYCR7dGhpcy5raW5kfToke3RoaXMucHVia2V5fTpgO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFdmVudCBpcyBub3QgYSByZXBsYWNlYWJsZSBldmVudFwiKTtcbiAgfVxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB0aGUgdHlwZSBvZiB0YWcgdGhhdCBjYW4gYmUgdXNlZCB0byByZWZlcmVuY2UgdGhpcyBldmVudCBmcm9tIGFub3RoZXIgZXZlbnQuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSB0YWcgdHlwZVxuICAgKiBAZXhhbXBsZVxuICAgKiBldmVudCA9IG5ldyBOREtFdmVudChuZGssIHsga2luZDogMzAwMDAsIHB1YmtleTogJ3B1YmtleScsIHRhZ3M6IFsgW1wiZFwiLCBcImQtY29kZVwiXSBdIH0pO1xuICAgKiBldmVudC50YWdUeXBlKCk7IC8vIFwiYVwiXG4gICAqL1xuICB0YWdUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLmlzUGFyYW1SZXBsYWNlYWJsZSgpID8gXCJhXCIgOiBcImVcIjtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSB0YWcgdGhhdCBjYW4gYmUgdXNlZCB0byByZWZlcmVuY2UgdGhpcyBldmVudCBmcm9tIGFub3RoZXIgZXZlbnQuXG4gICAqXG4gICAqIENvbnNpZGVyIHVzaW5nIHJlZmVyZW5jZVRhZ3MoKSBpbnN0ZWFkICh1bmxlc3MgeW91IGhhdmUgYSBnb29kIHJlYXNvbiB0byB1c2UgdGhpcylcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogICAgIGV2ZW50ID0gbmV3IE5ES0V2ZW50KG5kaywgeyBraW5kOiAzMDAwMCwgcHVia2V5OiAncHVia2V5JywgdGFnczogWyBbXCJkXCIsIFwiZC1jb2RlXCJdIF0gfSk7XG4gICAqICAgICBldmVudC50YWdSZWZlcmVuY2UoKTsgLy8gW1wiYVwiLCBcIjMwMDAwOnB1YmtleTpkLWNvZGVcIl1cbiAgICpcbiAgICogICAgIGV2ZW50ID0gbmV3IE5ES0V2ZW50KG5kaywgeyBraW5kOiAxLCBwdWJrZXk6ICdwdWJrZXknLCBpZDogXCJldmVudGlkXCIgfSk7XG4gICAqICAgICBldmVudC50YWdSZWZlcmVuY2UoKTsgLy8gW1wiZVwiLCBcImV2ZW50aWRcIl1cbiAgICogQHJldHVybnMge05ES1RhZ30gVGhlIE5ES1RhZyBvYmplY3QgcmVmZXJlbmNpbmcgdGhpcyBldmVudFxuICAgKi9cbiAgdGFnUmVmZXJlbmNlKG1hcmtlcikge1xuICAgIGxldCB0YWc7XG4gICAgaWYgKHRoaXMuaXNQYXJhbVJlcGxhY2VhYmxlKCkpIHtcbiAgICAgIHRhZyA9IFtcImFcIiwgdGhpcy50YWdBZGRyZXNzKCldO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YWcgPSBbXCJlXCIsIHRoaXMudGFnSWQoKV07XG4gICAgfVxuICAgIGlmICh0aGlzLnJlbGF5KSB7XG4gICAgICB0YWcucHVzaCh0aGlzLnJlbGF5LnVybCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhZy5wdXNoKFwiXCIpO1xuICAgIH1cbiAgICB0YWcucHVzaChtYXJrZXIgPz8gXCJcIik7XG4gICAgaWYgKCF0aGlzLmlzUGFyYW1SZXBsYWNlYWJsZSgpKSB7XG4gICAgICB0YWcucHVzaCh0aGlzLnB1YmtleSk7XG4gICAgfVxuICAgIHJldHVybiB0YWc7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgdGFncyB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlZmVyZW5jZSB0aGlzIGV2ZW50IGZyb20gYW5vdGhlciBldmVudFxuICAgKiBAcGFyYW0gbWFya2VyIFRoZSBtYXJrZXIgdG8gdXNlIGluIHRoZSB0YWdcbiAgICogQHBhcmFtIHNraXBBdXRob3JUYWcgV2hldGhlciB0byBleHBsaWNpdGx5IHNraXAgYWRkaW5nIHRoZSBhdXRob3IgdGFnIG9mIHRoZSBldmVudFxuICAgKiBAcGFyYW0gZm9yY2VUYWcgRm9yY2UgYSBzcGVjaWZpYyB0YWcgdG8gYmUgdXNlZCBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IFwiZVwiIG9yIFwiYVwiIHRhZ1xuICAgKiBAZXhhbXBsZVxuICAgKiAgICAgZXZlbnQgPSBuZXcgTkRLRXZlbnQobmRrLCB7IGtpbmQ6IDMwMDAwLCBwdWJrZXk6ICdwdWJrZXknLCB0YWdzOiBbIFtcImRcIiwgXCJkLWNvZGVcIl0gXSB9KTtcbiAgICogICAgIGV2ZW50LnJlZmVyZW5jZVRhZ3MoKTsgLy8gW1tcImFcIiwgXCIzMDAwMDpwdWJrZXk6ZC1jb2RlXCJdLCBbXCJlXCIsIFwicGFyZW50LWlkXCJdXVxuICAgKlxuICAgKiAgICAgZXZlbnQgPSBuZXcgTkRLRXZlbnQobmRrLCB7IGtpbmQ6IDEsIHB1YmtleTogJ3B1YmtleScsIGlkOiBcImV2ZW50aWRcIiB9KTtcbiAgICogICAgIGV2ZW50LnJlZmVyZW5jZVRhZ3MoKTsgLy8gW1tcImVcIiwgXCJwYXJlbnQtaWRcIl1dXG4gICAqIEByZXR1cm5zIHtOREtUYWd9IFRoZSBOREtUYWcgb2JqZWN0IHJlZmVyZW5jaW5nIHRoaXMgZXZlbnRcbiAgICovXG4gIHJlZmVyZW5jZVRhZ3MobWFya2VyLCBza2lwQXV0aG9yVGFnLCBmb3JjZVRhZykge1xuICAgIGxldCB0YWdzID0gW107XG4gICAgaWYgKHRoaXMuaXNQYXJhbVJlcGxhY2VhYmxlKCkpIHtcbiAgICAgIHRhZ3MgPSBbXG4gICAgICAgIFtmb3JjZVRhZyA/PyBcImFcIiwgdGhpcy50YWdBZGRyZXNzKCldLFxuICAgICAgICBbZm9yY2VUYWcgPz8gXCJlXCIsIHRoaXMuaWRdXG4gICAgICBdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YWdzID0gW1tmb3JjZVRhZyA/PyBcImVcIiwgdGhpcy5pZF1dO1xuICAgIH1cbiAgICB0YWdzID0gdGFncy5tYXAoKHRhZykgPT4ge1xuICAgICAgaWYgKHRhZ1swXSA9PT0gXCJlXCIgfHwgbWFya2VyKSB7XG4gICAgICAgIHRhZy5wdXNoKHRoaXMucmVsYXk/LnVybCA/PyBcIlwiKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5yZWxheT8udXJsKSB7XG4gICAgICAgIHRhZy5wdXNoKHRoaXMucmVsYXk/LnVybCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFnO1xuICAgIH0pO1xuICAgIHRhZ3MuZm9yRWFjaCgodGFnKSA9PiB7XG4gICAgICBpZiAodGFnWzBdID09PSBcImVcIikge1xuICAgICAgICB0YWcucHVzaChtYXJrZXIgPz8gXCJcIik7XG4gICAgICAgIHRhZy5wdXNoKHRoaXMucHVia2V5KTtcbiAgICAgIH0gZWxzZSBpZiAobWFya2VyKSB7XG4gICAgICAgIHRhZy5wdXNoKG1hcmtlcik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGFncyA9IFsuLi50YWdzLCAuLi50aGlzLmdldE1hdGNoaW5nVGFncyhcImhcIildO1xuICAgIGlmICghc2tpcEF1dGhvclRhZykgdGFncy5wdXNoKC4uLnRoaXMuYXV0aG9yLnJlZmVyZW5jZVRhZ3MoKSk7XG4gICAgcmV0dXJuIHRhZ3M7XG4gIH1cbiAgLyoqXG4gICAqIFByb3ZpZGVzIHRoZSBmaWx0ZXIgdGhhdCB3aWxsIHJldHVybiBtYXRjaGluZyBldmVudHMgZm9yIHRoaXMgZXZlbnQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICAgIGV2ZW50ID0gbmV3IE5ES0V2ZW50KG5kaywgeyBraW5kOiAzMDAwMCwgcHVia2V5OiAncHVia2V5JywgdGFnczogWyBbXCJkXCIsIFwiZC1jb2RlXCJdIF0gfSk7XG4gICAqICAgIGV2ZW50LmZpbHRlcigpOyAvLyB7IFwiI2FcIjogW1wiMzAwMDA6cHVia2V5OmQtY29kZVwiXSB9XG4gICAqIEBleGFtcGxlXG4gICAqICAgIGV2ZW50ID0gbmV3IE5ES0V2ZW50KG5kaywgeyBraW5kOiAxLCBwdWJrZXk6ICdwdWJrZXknLCBpZDogXCJldmVudGlkXCIgfSk7XG4gICAqICAgIGV2ZW50LmZpbHRlcigpOyAvLyB7IFwiI2VcIjogW1wiZXZlbnRpZFwiXSB9XG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSBmaWx0ZXIgdGhhdCB3aWxsIHJldHVybiBtYXRjaGluZyBldmVudHMgZm9yIHRoaXMgZXZlbnRcbiAgICovXG4gIGZpbHRlcigpIHtcbiAgICBpZiAodGhpcy5pc1BhcmFtUmVwbGFjZWFibGUoKSkge1xuICAgICAgcmV0dXJuIHsgXCIjYVwiOiBbdGhpcy50YWdJZCgpXSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4geyBcIiNlXCI6IFt0aGlzLnRhZ0lkKCldIH07XG4gICAgfVxuICB9XG4gIG5pcDIyRmlsdGVyKCkge1xuICAgIGlmICh0aGlzLmlzUGFyYW1SZXBsYWNlYWJsZSgpKSB7XG4gICAgICByZXR1cm4geyBcIiNBXCI6IFt0aGlzLnRhZ0lkKCldIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7IFwiI0VcIjogW3RoaXMudGFnSWQoKV0gfTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIGRlbGV0aW9uIGV2ZW50IG9mIHRoZSBjdXJyZW50IGV2ZW50XG4gICAqXG4gICAqIEBwYXJhbSByZWFzb24gVGhlIHJlYXNvbiBmb3IgdGhlIGRlbGV0aW9uXG4gICAqIEBwYXJhbSBwdWJsaXNoIFdoZXRoZXIgdG8gcHVibGlzaCB0aGUgZGVsZXRpb24gZXZlbnQgYXV0b21hdGljYWxseVxuICAgKiBAcmV0dXJucyBUaGUgZGVsZXRpb24gZXZlbnRcbiAgICovXG4gIGFzeW5jIGRlbGV0ZShyZWFzb24sIHB1Ymxpc2ggPSB0cnVlKSB7XG4gICAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTm8gTkRLIGluc3RhbmNlIGZvdW5kXCIpO1xuICAgIHRoaXMubmRrLmFzc2VydFNpZ25lcigpO1xuICAgIGNvbnN0IGUgPSBuZXcgX05ES0V2ZW50KHRoaXMubmRrLCB7XG4gICAgICBraW5kOiA1IC8qIEV2ZW50RGVsZXRpb24gKi8sXG4gICAgICBjb250ZW50OiByZWFzb24gfHwgXCJcIlxuICAgIH0pO1xuICAgIGUudGFnKHRoaXMsIHZvaWQgMCwgdHJ1ZSk7XG4gICAgZS50YWdzLnB1c2goW1wia1wiLCB0aGlzLmtpbmQudG9TdHJpbmcoKV0pO1xuICAgIGlmIChwdWJsaXNoKSB7XG4gICAgICB0aGlzLmVtaXQoXCJkZWxldGVkXCIpO1xuICAgICAgYXdhaXQgZS5wdWJsaXNoKCk7XG4gICAgfVxuICAgIHJldHVybiBlO1xuICB9XG4gIC8qKlxuICAgKiBFc3RhYmxpc2hlcyB3aGV0aGVyIHRoaXMgaXMgYSBOSVAtNzAtcHJvdGVjdGVkZSBldmVudC5cbiAgICogQEBzYXRpc2ZpZXMgTklQLTcwXG4gICAqL1xuICBzZXQgaXNQcm90ZWN0ZWQodmFsKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCItXCIpO1xuICAgIGlmICh2YWwpIHRoaXMudGFncy5wdXNoKFtcIi1cIl0pO1xuICB9XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoaXMgaXMgYSBOSVAtNzAtcHJvdGVjdGVkZSBldmVudC5cbiAgICogQEBzYXRpc2ZpZXMgTklQLTcwXG4gICAqL1xuICBnZXQgaXNQcm90ZWN0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzVGFnKFwiLVwiKTtcbiAgfVxuICAvKipcbiAgICogRmV0Y2ggYW4gZXZlbnQgdGFnZ2VkIHdpdGggdGhlIGdpdmVuIHRhZyBmb2xsb3dpbmcgcmVsYXkgaGludHMgaWYgcHJvdmlkZWQuXG4gICAqIEBwYXJhbSB0YWcgVGhlIHRhZyB0byBzZWFyY2ggZm9yXG4gICAqIEBwYXJhbSBtYXJrZXIgVGhlIG1hcmtlciB0byB1c2UgaW4gdGhlIHRhZyAoZS5nLiBcInJvb3RcIilcbiAgICogQHJldHVybnMgVGhlIGZldGNoZWQgZXZlbnQgb3IgbnVsbCBpZiBubyBldmVudCB3YXMgZm91bmQsIHVuZGVmaW5lZCBpZiBubyBtYXRjaGluZyB0YWcgd2FzIGZvdW5kIGluIHRoZSBldmVudFxuICAgKiAqIEBleGFtcGxlXG4gICAqIGNvbnN0IHJlcGx5RXZlbnQgPSBhd2FpdCBuZGsuZmV0Y2hFdmVudChcIm5ldmVudDFxcXM4eDh2bnljeWhhNzNncnYzODBnbXZsdXJ5NHd0bXgwbnI5YTVkczJkbmdxd2d1ODd3bjZncHplbWh4dWU2OXVoaHlldHZ2OXVqdXVyamQ5a2t6bXB3ZGVqaGdxM3FsMnZ5aDQ3bWsycDBxbHNrdTdoZzB2bjI5ZmFlaHk5aHkzNHlnYWNscG42NnVrcXAzYWZxejRjd2pkXCIpXG4gICAqIGNvbnN0IG9yaWdpbmFsRXZlbnQgPSBhd2FpdCByZXBseUV2ZW50LmZldGNoVGFnZ2VkRXZlbnQoXCJlXCIsIFwicmVwbHlcIik7XG4gICAqIGNvbnNvbGUubG9nKHJlcGx5RXZlbnQuZW5jb2RlKCkgKyBcIiBpcyBhIHJlcGx5IHRvIGV2ZW50IFwiICsgb3JpZ2luYWxFdmVudD8uZW5jb2RlKCkpO1xuICAgKi9cbiAgZmV0Y2hUYWdnZWRFdmVudCA9IGZldGNoVGFnZ2VkRXZlbnQuYmluZCh0aGlzKTtcbiAgLyoqXG4gICAqIEZldGNoIHRoZSByb290IGV2ZW50IG9mIHRoZSBjdXJyZW50IGV2ZW50LlxuICAgKiBAcmV0dXJucyBUaGUgZmV0Y2hlZCByb290IGV2ZW50IG9yIG51bGwgaWYgbm8gZXZlbnQgd2FzIGZvdW5kXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IHJlcGx5RXZlbnQgPSBhd2FpdCBuZGsuZmV0Y2hFdmVudChcIm5ldmVudDFxcXM4eDh2bnljeWhhNzNncnYzODBnbXZsdXJ5NHd0bXgwbnI5YTVkczJkbmdxd2d1ODd3bjZncHplbWh4dWU2OXVoaHlldHZ2OXVqdXVyamQ5a2t6bXB3ZGVqaGdxM3FsMnZ5aDQ3bWsycDBxbHNrdTdoZzB2bjI5ZmFlaHk5aHkzNHlnYWNscG42NnVrcXAzYWZxejRjd2pkXCIpXG4gICAqIGNvbnN0IHJvb3RFdmVudCA9IGF3YWl0IHJlcGx5RXZlbnQuZmV0Y2hSb290RXZlbnQoKTtcbiAgICogY29uc29sZS5sb2cocmVwbHlFdmVudC5lbmNvZGUoKSArIFwiIGlzIGEgcmVwbHkgaW4gdGhlIHRocmVhZCBcIiArIHJvb3RFdmVudD8uZW5jb2RlKCkpO1xuICAgKi9cbiAgZmV0Y2hSb290RXZlbnQgPSBmZXRjaFJvb3RFdmVudC5iaW5kKHRoaXMpO1xuICAvKipcbiAgICogRmV0Y2ggdGhlIGV2ZW50IHRoZSBjdXJyZW50IGV2ZW50IGlzIHJlcGx5aW5nIHRvLlxuICAgKiBAcmV0dXJucyBUaGUgZmV0Y2hlZCByZXBseSBldmVudCBvciBudWxsIGlmIG5vIGV2ZW50IHdhcyBmb3VuZFxuICAgKi9cbiAgZmV0Y2hSZXBseUV2ZW50ID0gZmV0Y2hSZXBseUV2ZW50LmJpbmQodGhpcyk7XG4gIC8qKlxuICAgKiBOSVAtMTggcmVwb3N0aW5nIGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0gcHVibGlzaCBXaGV0aGVyIHRvIHB1Ymxpc2ggdGhlIHJlcG9zdGVkIGV2ZW50IGF1dG9tYXRpY2FsbHkgQGRlZmF1bHQgdHJ1ZVxuICAgKiBAcGFyYW0gc2lnbmVyIFRoZSBzaWduZXIgdG8gdXNlIGZvciBzaWduaW5nIHRoZSByZXBvc3RlZCBldmVudFxuICAgKiBAcmV0dXJucyBUaGUgcmVwb3N0ZWQgZXZlbnRcbiAgICpcbiAgICogQGZ1bmN0aW9uXG4gICAqL1xuICByZXBvc3QgPSByZXBvc3QuYmluZCh0aGlzKTtcbiAgLyoqXG4gICAqIFJlYWN0IHRvIGFuIGV4aXN0aW5nIGV2ZW50XG4gICAqXG4gICAqIEBwYXJhbSBjb250ZW50IFRoZSBjb250ZW50IG9mIHRoZSByZWFjdGlvblxuICAgKi9cbiAgYXN5bmMgcmVhY3QoY29udGVudCwgcHVibGlzaCA9IHRydWUpIHtcbiAgICBpZiAoIXRoaXMubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBOREsgaW5zdGFuY2UgZm91bmRcIik7XG4gICAgdGhpcy5uZGsuYXNzZXJ0U2lnbmVyKCk7XG4gICAgY29uc3QgZSA9IG5ldyBfTkRLRXZlbnQodGhpcy5uZGssIHtcbiAgICAgIGtpbmQ6IDcgLyogUmVhY3Rpb24gKi8sXG4gICAgICBjb250ZW50XG4gICAgfSk7XG4gICAgZS50YWcodGhpcyk7XG4gICAgaWYgKHB1Ymxpc2gpIGF3YWl0IGUucHVibGlzaCgpO1xuICAgIHJldHVybiBlO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZXZlbnQgaXMgdmFsaWQgcGVyIHVuZGVybHlpbmcgTklQcy5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgbWVhbnQgdG8gYmUgb3ZlcnJpZGRlbiBieSBzdWJjbGFzc2VzIHRoYXQgaW1wbGVtZW50IHNwZWNpZmljIE5JUHNcbiAgICogdG8gYWxsb3cgdGhlIGVuZm9yY2VtZW50IG9mIE5JUC1zcGVjaWZpYyB2YWxpZGF0aW9uIHJ1bGVzLlxuICAgKlxuICAgKiBPdGhlcndpc2UsIGl0IHdpbGwgb25seSBjaGVjayBmb3IgYmFzaWMgZXZlbnQgcHJvcGVydGllcy5cbiAgICpcbiAgICovXG4gIGdldCBpc1ZhbGlkKCkge1xuICAgIHJldHVybiB0aGlzLnZhbGlkYXRlKCk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSByZXBseSBldmVudCBmb3IgdGhlIGN1cnJlbnQgZXZlbnQuXG4gICAqIFxuICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgdXNlIE5JUC0yMiB3aGVuIGFwcHJvcHJpYXRlIChpLmUuIHJlcGxpZXMgdG8gbm9uLWtpbmQ6MSBldmVudHMpLlxuICAgKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IGhhdmUgc2lkZS1lZmZlY3RzOyBpdCB3aWxsIGp1c3QgcmV0dXJuIGFuIGV2ZW50IHdpdGggdGhlIGFwcHJvcHJpYXRlIHRhZ3NcbiAgICogdG8gZ2VuZXJhdGUgdGhlIHJlcGx5IGV2ZW50OyB0aGUgY2FsbGVyIGlzIHJlc3BvbnNpYmxlIGZvciBwdWJsaXNoaW5nIHRoZSBldmVudC5cbiAgICovXG4gIHJlcGx5KCkge1xuICAgIGNvbnN0IHJlcGx5ID0gbmV3IF9OREtFdmVudCh0aGlzLm5kayk7XG4gICAgaWYgKHRoaXMua2luZCA9PT0gMSkge1xuICAgICAgcmVwbHkua2luZCA9IDE7XG4gICAgICBjb25zdCBvcEhhc0VUYWcgPSB0aGlzLmhhc1RhZyhcImVcIik7XG4gICAgICBpZiAob3BIYXNFVGFnKSB7XG4gICAgICAgIHJlcGx5LnRhZ3MgPSBbXG4gICAgICAgICAgLi4ucmVwbHkudGFncyxcbiAgICAgICAgICAuLi50aGlzLmdldE1hdGNoaW5nVGFncyhcImVcIiksXG4gICAgICAgICAgLi4udGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJwXCIpLFxuICAgICAgICAgIC4uLnRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwiYVwiKSxcbiAgICAgICAgICAuLi50aGlzLnJlZmVyZW5jZVRhZ3MoXCJyZXBseVwiKVxuICAgICAgICBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVwbHkudGFnKHRoaXMsIFwicm9vdFwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVwbHkua2luZCA9IDExMTEgLyogR2VuZXJpY1JlcGx5ICovO1xuICAgICAgY29uc3QgY2FycnlPdmVyVGFncyA9IFtcIkFcIiwgXCJFXCIsIFwiSVwiLCBcIlBcIl07XG4gICAgICBjb25zdCByb290VGFncyA9IHRoaXMudGFncy5maWx0ZXIoKHRhZykgPT4gY2FycnlPdmVyVGFncy5pbmNsdWRlcyh0YWdbMF0pKTtcbiAgICAgIGlmIChyb290VGFncy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHJvb3RLaW5kID0gdGhpcy50YWdWYWx1ZShcIktcIik7XG4gICAgICAgIHJlcGx5LnRhZ3MucHVzaCguLi5yb290VGFncyk7XG4gICAgICAgIGlmIChyb290S2luZCkgcmVwbHkudGFncy5wdXNoKFtcIktcIiwgcm9vdEtpbmRdKTtcbiAgICAgICAgY29uc3QgW3R5cGUsIGlkLCBfLCAuLi5leHRyYV0gPSB0aGlzLnRhZ1JlZmVyZW5jZSgpO1xuICAgICAgICBjb25zdCB0YWcgPSBbdHlwZSwgaWQsIC4uLmV4dHJhXTtcbiAgICAgICAgcmVwbHkudGFncy5wdXNoKHRhZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBbdHlwZSwgaWQsIF8sIHJlbGF5SGludF0gPSB0aGlzLnRhZ1JlZmVyZW5jZSgpO1xuICAgICAgICBjb25zdCB0YWcgPSBbdHlwZSwgaWQsIHJlbGF5SGludCA/PyBcIlwiXTtcbiAgICAgICAgaWYgKHR5cGUgPT09IFwiZVwiKSB0YWcucHVzaCh0aGlzLnB1YmtleSk7XG4gICAgICAgIHJlcGx5LnRhZ3MucHVzaCh0YWcpO1xuICAgICAgICBjb25zdCB1cHBlcmNhc2VUYWcgPSBbLi4udGFnXTtcbiAgICAgICAgdXBwZXJjYXNlVGFnWzBdID0gdXBwZXJjYXNlVGFnWzBdLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIHJlcGx5LnRhZ3MucHVzaCh1cHBlcmNhc2VUYWcpO1xuICAgICAgICByZXBseS50YWdzLnB1c2goW1wiS1wiLCB0aGlzLmtpbmQudG9TdHJpbmcoKV0pO1xuICAgICAgICByZXBseS50YWdzLnB1c2goW1wiUFwiLCB0aGlzLnB1YmtleV0pO1xuICAgICAgfVxuICAgICAgcmVwbHkudGFncy5wdXNoKFtcImtcIiwgdGhpcy5raW5kLnRvU3RyaW5nKCldKTtcbiAgICAgIHJlcGx5LnRhZ3MucHVzaCguLi50aGlzLmdldE1hdGNoaW5nVGFncyhcInBcIikpO1xuICAgICAgcmVwbHkudGFncy5wdXNoKFtcInBcIiwgdGhpcy5wdWJrZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcGx5O1xuICB9XG59O1xudmFyIHVudHJhY2tlZFVucHVibGlzaGVkRXZlbnRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICAyNDEzMyAvKiBOb3N0ckNvbm5lY3QgKi8sXG4gIDEzMTk0IC8qIE5vc3RyV2FsZXRDb25uZWN0SW5mbyAqLyxcbiAgMjMxOTQgLyogTm9zdHJXYWxsZXRDb25uZWN0UmVxICovLFxuICAyMzE5NSAvKiBOb3N0cldhbGxldENvbm5lY3RSZXMgKi9cbl0pO1xuZnVuY3Rpb24gc2hvdWxkVHJhY2tVbnB1Ymxpc2hlZEV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiAhdW50cmFja2VkVW5wdWJsaXNoZWRFdmVudHMuaGFzKGV2ZW50LmtpbmQpO1xufVxuXG4vLyBzcmMvcmVsYXkvcG9vbC9pbmRleC50c1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIGFzIEV2ZW50RW1pdHRlcjMgfSBmcm9tIFwidHNlZXBcIjtcbnZhciBOREtQb29sID0gY2xhc3MgZXh0ZW5kcyBFdmVudEVtaXR0ZXIzIHtcbiAgLy8gVE9ETzogVGhpcyBzaG91bGQgcHJvYmFibHkgYmUgYW4gTFJVIGNhY2hlXG4gIF9yZWxheXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBzdGF0dXMgPSBcImlkbGVcIjtcbiAgYXV0b0Nvbm5lY3RSZWxheXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBwb29sQmxhY2tsaXN0UmVsYXlVcmxzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgZGVidWc7XG4gIHRlbXBvcmFyeVJlbGF5VGltZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgZmxhcHBpbmdSZWxheXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAvLyBBIG1hcCB0byBzdG9yZSB0aW1lb3V0cyBmb3IgZWFjaCBmbGFwcGluZyByZWxheS5cbiAgYmFja29mZlRpbWVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgbmRrO1xuICBnZXQgYmxhY2tsaXN0UmVsYXlVcmxzKCkge1xuICAgIGNvbnN0IHZhbCA9IG5ldyBTZXQodGhpcy5uZGsuYmxhY2tsaXN0UmVsYXlVcmxzKTtcbiAgICB0aGlzLnBvb2xCbGFja2xpc3RSZWxheVVybHMuZm9yRWFjaCgodXJsKSA9PiB2YWwuYWRkKHVybCkpO1xuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSByZWxheVVybHMgLSBUaGUgVVJMcyBvZiB0aGUgcmVsYXlzIHRvIGNvbm5lY3QgdG8uXG4gICAqIEBwYXJhbSBibGFja2xpc3RlZFJlbGF5VXJscyAtIFVSTHMgdG8gYmxhY2tsaXN0IGZvciB0aGlzIHBvb2wgSU4gQURESVRJT04gdG8gdGhvc2UgYmxhY2tsaXN0ZWQgYXQgdGhlIG5kay1sZXZlbFxuICAgKiBAcGFyYW0gbmRrIC0gVGhlIE5ESyBpbnN0YW5jZS5cbiAgICogQHBhcmFtIG9wdHMgLSBPcHRpb25zIGZvciB0aGUgcG9vbC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHJlbGF5VXJscyA9IFtdLCBibGFja2xpc3RlZFJlbGF5VXJscyA9IFtdLCBuZGssIHsgZGVidWc6IGRlYnVnOCwgbmFtZSB9ID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZGVidWcgPSBkZWJ1ZzggPz8gbmRrLmRlYnVnLmV4dGVuZChcInBvb2xcIik7XG4gICAgaWYgKG5hbWUpIHRoaXMuX25hbWUgPSBuYW1lO1xuICAgIHRoaXMubmRrID0gbmRrO1xuICAgIHRoaXMucmVsYXlVcmxzID0gcmVsYXlVcmxzO1xuICAgIHRoaXMucG9vbEJsYWNrbGlzdFJlbGF5VXJscyA9IG5ldyBTZXQoYmxhY2tsaXN0ZWRSZWxheVVybHMpO1xuICAgIHRoaXMubmRrLnBvb2xzLnB1c2godGhpcyk7XG4gIH1cbiAgZ2V0IHJlbGF5cygpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVsYXlzO1xuICB9XG4gIHNldCByZWxheVVybHModXJscykge1xuICAgIHRoaXMuX3JlbGF5cy5jbGVhcigpO1xuICAgIGZvciAoY29uc3QgcmVsYXlVcmwgb2YgdXJscykge1xuICAgICAgY29uc3QgcmVsYXkgPSBuZXcgTkRLUmVsYXkocmVsYXlVcmwsIHZvaWQgMCwgdGhpcy5uZGspO1xuICAgICAgcmVsYXkuY29ubmVjdGl2aXR5Lm5ldERlYnVnID0gdGhpcy5uZGsubmV0RGVidWc7XG4gICAgICB0aGlzLmFkZFJlbGF5KHJlbGF5KTtcbiAgICB9XG4gIH1cbiAgX25hbWUgPSBcInVubmFtZWRcIjtcbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gIH1cbiAgc2V0IG5hbWUobmFtZSkge1xuICAgIHRoaXMuX25hbWUgPSBuYW1lO1xuICAgIHRoaXMuZGVidWcgPSB0aGlzLmRlYnVnLmV4dGVuZChuYW1lKTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIHJlbGF5IHRvIHRoZSBwb29sLCBhbmQgc2V0cyBhIHRpbWVyIHRvIHJlbW92ZSBpdCBpZiBpdCBpcyBub3QgdXNlZCB3aXRoaW4gdGhlIHNwZWNpZmllZCB0aW1lLlxuICAgKiBAcGFyYW0gcmVsYXkgLSBUaGUgcmVsYXkgdG8gYWRkIHRvIHRoZSBwb29sLlxuICAgKiBAcGFyYW0gcmVtb3ZlSWZVbnVzZWRBZnRlciAtIFRoZSB0aW1lIGluIG1pbGxpc2Vjb25kcyB0byB3YWl0IGJlZm9yZSByZW1vdmluZyB0aGUgcmVsYXkgZnJvbSB0aGUgcG9vbCBhZnRlciBpdCBpcyBubyBsb25nZXIgdXNlZC5cbiAgICovXG4gIHVzZVRlbXBvcmFyeVJlbGF5KHJlbGF5LCByZW1vdmVJZlVudXNlZEFmdGVyID0gM2U0LCBmaWx0ZXJzKSB7XG4gICAgY29uc3QgcmVsYXlBbHJlYWR5SW5Qb29sID0gdGhpcy5yZWxheXMuaGFzKHJlbGF5LnVybCk7XG4gICAgaWYgKCFyZWxheUFscmVhZHlJblBvb2wpIHtcbiAgICAgIHRoaXMuYWRkUmVsYXkocmVsYXkpO1xuICAgICAgdGhpcy5kZWJ1ZyhcIkFkZGluZyB0ZW1wb3JhcnkgcmVsYXkgJXMgZm9yIGZpbHRlcnMgJW9cIiwgcmVsYXkudXJsLCBmaWx0ZXJzKTtcbiAgICB9XG4gICAgY29uc3QgZXhpc3RpbmdUaW1lciA9IHRoaXMudGVtcG9yYXJ5UmVsYXlUaW1lcnMuZ2V0KHJlbGF5LnVybCk7XG4gICAgaWYgKGV4aXN0aW5nVGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dChleGlzdGluZ1RpbWVyKTtcbiAgICB9XG4gICAgaWYgKCFyZWxheUFscmVhZHlJblBvb2wgfHwgZXhpc3RpbmdUaW1lcikge1xuICAgICAgY29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMubmRrLmV4cGxpY2l0UmVsYXlVcmxzPy5pbmNsdWRlcyhyZWxheS51cmwpKSByZXR1cm47XG4gICAgICAgIHRoaXMucmVtb3ZlUmVsYXkocmVsYXkudXJsKTtcbiAgICAgIH0sIHJlbW92ZUlmVW51c2VkQWZ0ZXIpO1xuICAgICAgdGhpcy50ZW1wb3JhcnlSZWxheVRpbWVycy5zZXQocmVsYXkudXJsLCB0aW1lcik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBBZGRzIGEgcmVsYXkgdG8gdGhlIHBvb2wuXG4gICAqXG4gICAqIEBwYXJhbSByZWxheSAtIFRoZSByZWxheSB0byBhZGQgdG8gdGhlIHBvb2wuXG4gICAqIEBwYXJhbSBjb25uZWN0IC0gV2hldGhlciBvciBub3QgdG8gY29ubmVjdCB0byB0aGUgcmVsYXkuXG4gICAqL1xuICBhZGRSZWxheShyZWxheSwgY29ubmVjdCA9IHRydWUpIHtcbiAgICBjb25zdCBpc0FscmVhZHlJblBvb2wgPSB0aGlzLnJlbGF5cy5oYXMocmVsYXkudXJsKTtcbiAgICBjb25zdCBpc0JsYWNrbGlzdGVkID0gdGhpcy5ibGFja2xpc3RSZWxheVVybHM/LmhhcyhyZWxheS51cmwpO1xuICAgIGNvbnN0IGlzQ3VzdG9tUmVsYXlVcmwgPSByZWxheS51cmwuaW5jbHVkZXMoXCIvbnB1YjFcIik7XG4gICAgbGV0IHJlY29ubmVjdCA9IHRydWU7XG4gICAgY29uc3QgcmVsYXlVcmwgPSByZWxheS51cmw7XG4gICAgaWYgKGlzQWxyZWFkeUluUG9vbCkgcmV0dXJuO1xuICAgIGlmIChpc0JsYWNrbGlzdGVkKSB7XG4gICAgICB0aGlzLmRlYnVnKGBSZWZ1c2luZyB0byBhZGQgcmVsYXkgJHtyZWxheVVybH06IGJsYWNrbGlzdGVkYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpc0N1c3RvbVJlbGF5VXJsKSB7XG4gICAgICB0aGlzLmRlYnVnKGBSZWZ1c2luZyB0byBhZGQgcmVsYXkgJHtyZWxheVVybH06IGlzIGEgZmlsdGVyIHJlbGF5YCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLm5kay5jYWNoZUFkYXB0ZXI/LmdldFJlbGF5U3RhdHVzKSB7XG4gICAgICBjb25zdCBpbmZvID0gdGhpcy5uZGsuY2FjaGVBZGFwdGVyLmdldFJlbGF5U3RhdHVzKHJlbGF5VXJsKTtcbiAgICAgIGlmIChpbmZvICYmIGluZm8uZG9udENvbm5lY3RCZWZvcmUpIHtcbiAgICAgICAgaWYgKGluZm8uZG9udENvbm5lY3RCZWZvcmUgPiBEYXRlLm5vdygpKSB7XG4gICAgICAgICAgY29uc3QgZGVsYXkgPSBpbmZvLmRvbnRDb25uZWN0QmVmb3JlIC0gRGF0ZS5ub3coKTtcbiAgICAgICAgICB0aGlzLmRlYnVnKGBSZWZ1c2luZyB0byBhZGQgcmVsYXkgJHtyZWxheVVybH06IGRlbGF5ZWQgY29ubmVjdCBmb3IgJHtkZWxheX1tc2ApO1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hZGRSZWxheShyZWxheSwgY29ubmVjdCk7XG4gICAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWNvbm5lY3QgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBub3RpY2VIYW5kbGVyID0gKG5vdGljZSkgPT4gdGhpcy5lbWl0KFwibm90aWNlXCIsIHJlbGF5LCBub3RpY2UpO1xuICAgIGNvbnN0IGNvbm5lY3RIYW5kbGVyID0gKCkgPT4gdGhpcy5oYW5kbGVSZWxheUNvbm5lY3QocmVsYXlVcmwpO1xuICAgIGNvbnN0IHJlYWR5SGFuZGxlciA9ICgpID0+IHRoaXMuaGFuZGxlUmVsYXlSZWFkeShyZWxheSk7XG4gICAgY29uc3QgZGlzY29ubmVjdEhhbmRsZXIgPSAoKSA9PiB0aGlzLmVtaXQoXCJyZWxheTpkaXNjb25uZWN0XCIsIHJlbGF5KTtcbiAgICBjb25zdCBmbGFwcGluZ0hhbmRsZXIgPSAoKSA9PiB0aGlzLmhhbmRsZUZsYXBwaW5nKHJlbGF5KTtcbiAgICBjb25zdCBhdXRoSGFuZGxlciA9IChjaGFsbGVuZ2UpID0+IHRoaXMuZW1pdChcInJlbGF5OmF1dGhcIiwgcmVsYXksIGNoYWxsZW5nZSk7XG4gICAgY29uc3QgYXV0aGVkSGFuZGxlciA9ICgpID0+IHRoaXMuZW1pdChcInJlbGF5OmF1dGhlZFwiLCByZWxheSk7XG4gICAgcmVsYXkub2ZmKFwibm90aWNlXCIsIG5vdGljZUhhbmRsZXIpO1xuICAgIHJlbGF5Lm9mZihcImNvbm5lY3RcIiwgY29ubmVjdEhhbmRsZXIpO1xuICAgIHJlbGF5Lm9mZihcInJlYWR5XCIsIHJlYWR5SGFuZGxlcik7XG4gICAgcmVsYXkub2ZmKFwiZGlzY29ubmVjdFwiLCBkaXNjb25uZWN0SGFuZGxlcik7XG4gICAgcmVsYXkub2ZmKFwiZmxhcHBpbmdcIiwgZmxhcHBpbmdIYW5kbGVyKTtcbiAgICByZWxheS5vZmYoXCJhdXRoXCIsIGF1dGhIYW5kbGVyKTtcbiAgICByZWxheS5vZmYoXCJhdXRoZWRcIiwgYXV0aGVkSGFuZGxlcik7XG4gICAgcmVsYXkub24oXCJub3RpY2VcIiwgbm90aWNlSGFuZGxlcik7XG4gICAgcmVsYXkub24oXCJjb25uZWN0XCIsIGNvbm5lY3RIYW5kbGVyKTtcbiAgICByZWxheS5vbihcInJlYWR5XCIsIHJlYWR5SGFuZGxlcik7XG4gICAgcmVsYXkub24oXCJkaXNjb25uZWN0XCIsIGRpc2Nvbm5lY3RIYW5kbGVyKTtcbiAgICByZWxheS5vbihcImZsYXBwaW5nXCIsIGZsYXBwaW5nSGFuZGxlcik7XG4gICAgcmVsYXkub24oXCJhdXRoXCIsIGF1dGhIYW5kbGVyKTtcbiAgICByZWxheS5vbihcImF1dGhlZFwiLCBhdXRoZWRIYW5kbGVyKTtcbiAgICByZWxheS5vbihcImRlbGF5ZWQtY29ubmVjdFwiLCAoZGVsYXkpID0+IHtcbiAgICAgIGlmICh0aGlzLm5kay5jYWNoZUFkYXB0ZXI/LnVwZGF0ZVJlbGF5U3RhdHVzKSB7XG4gICAgICAgIHRoaXMubmRrLmNhY2hlQWRhcHRlci51cGRhdGVSZWxheVN0YXR1cyhyZWxheS51cmwsIHtcbiAgICAgICAgICBkb250Q29ubmVjdEJlZm9yZTogRGF0ZS5ub3coKSArIGRlbGF5XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuX3JlbGF5cy5zZXQocmVsYXlVcmwsIHJlbGF5KTtcbiAgICBpZiAoY29ubmVjdCkgdGhpcy5hdXRvQ29ubmVjdFJlbGF5cy5hZGQocmVsYXlVcmwpO1xuICAgIGlmIChjb25uZWN0ICYmIHRoaXMuc3RhdHVzID09PSBcImFjdGl2ZVwiKSB7XG4gICAgICB0aGlzLmVtaXQoXCJyZWxheTpjb25uZWN0aW5nXCIsIHJlbGF5KTtcbiAgICAgIHJlbGF5LmNvbm5lY3Qodm9pZCAwLCByZWNvbm5lY3QpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgIHRoaXMuZGVidWcoYEZhaWxlZCB0byBjb25uZWN0IHRvIHJlbGF5ICR7cmVsYXlVcmx9YCwgZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSByZWxheSBmcm9tIHRoZSBwb29sLlxuICAgKiBAcGFyYW0gcmVsYXlVcmwgLSBUaGUgVVJMIG9mIHRoZSByZWxheSB0byByZW1vdmUuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSByZWxheSB3YXMgcmVtb3ZlZCwgZmFsc2UgaWYgaXQgd2FzIG5vdCBmb3VuZC5cbiAgICovXG4gIHJlbW92ZVJlbGF5KHJlbGF5VXJsKSB7XG4gICAgY29uc3QgcmVsYXkgPSB0aGlzLnJlbGF5cy5nZXQocmVsYXlVcmwpO1xuICAgIGlmIChyZWxheSkge1xuICAgICAgcmVsYXkuZGlzY29ubmVjdCgpO1xuICAgICAgdGhpcy5yZWxheXMuZGVsZXRlKHJlbGF5VXJsKTtcbiAgICAgIHRoaXMuYXV0b0Nvbm5lY3RSZWxheXMuZGVsZXRlKHJlbGF5VXJsKTtcbiAgICAgIHRoaXMuZW1pdChcInJlbGF5OmRpc2Nvbm5lY3RcIiwgcmVsYXkpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGV4aXN0aW5nVGltZXIgPSB0aGlzLnRlbXBvcmFyeVJlbGF5VGltZXJzLmdldChyZWxheVVybCk7XG4gICAgaWYgKGV4aXN0aW5nVGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dChleGlzdGluZ1RpbWVyKTtcbiAgICAgIHRoaXMudGVtcG9yYXJ5UmVsYXlUaW1lcnMuZGVsZXRlKHJlbGF5VXJsKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBhIHJlbGF5IGlzIGFscmVhZHkgY29ubmVjdGVkIGluIHRoZSBwb29sLlxuICAgKi9cbiAgaXNSZWxheUNvbm5lY3RlZCh1cmwpIHtcbiAgICBjb25zdCBub3JtYWxpemVkVXJsID0gbm9ybWFsaXplUmVsYXlVcmwodXJsKTtcbiAgICBjb25zdCByZWxheSA9IHRoaXMucmVsYXlzLmdldChub3JtYWxpemVkVXJsKTtcbiAgICBpZiAoIXJlbGF5KSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHJlbGF5LnN0YXR1cyA9PT0gNSAvKiBDT05ORUNURUQgKi87XG4gIH1cbiAgLyoqXG4gICAqIEZldGNoZXMgYSByZWxheSBmcm9tIHRoZSBwb29sLCBvciBjcmVhdGVzIGEgbmV3IG9uZSBpZiBpdCBkb2VzIG5vdCBleGlzdC5cbiAgICpcbiAgICogTmV3IHJlbGF5cyB3aWxsIGJlIGF0dGVtcHRlZCB0byBiZSBjb25uZWN0ZWQuXG4gICAqL1xuICBnZXRSZWxheSh1cmwsIGNvbm5lY3QgPSB0cnVlLCB0ZW1wb3JhcnkgPSBmYWxzZSwgZmlsdGVycykge1xuICAgIGxldCByZWxheSA9IHRoaXMucmVsYXlzLmdldChub3JtYWxpemVSZWxheVVybCh1cmwpKTtcbiAgICBpZiAoIXJlbGF5KSB7XG4gICAgICByZWxheSA9IG5ldyBOREtSZWxheSh1cmwsIHZvaWQgMCwgdGhpcy5uZGspO1xuICAgICAgcmVsYXkuY29ubmVjdGl2aXR5Lm5ldERlYnVnID0gdGhpcy5uZGsubmV0RGVidWc7XG4gICAgICBpZiAodGVtcG9yYXJ5KSB7XG4gICAgICAgIHRoaXMudXNlVGVtcG9yYXJ5UmVsYXkocmVsYXksIDNlNCwgZmlsdGVycyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFkZFJlbGF5KHJlbGF5LCBjb25uZWN0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlbGF5O1xuICB9XG4gIGhhbmRsZVJlbGF5Q29ubmVjdChyZWxheVVybCkge1xuICAgIGNvbnN0IHJlbGF5ID0gdGhpcy5yZWxheXMuZ2V0KHJlbGF5VXJsKTtcbiAgICBpZiAoIXJlbGF5KSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiTkRLIEJVRzogcmVsYXkgbm90IGZvdW5kIGluIHBvb2xcIiwgeyByZWxheVVybCB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lbWl0KFwicmVsYXk6Y29ubmVjdFwiLCByZWxheSk7XG4gICAgaWYgKHRoaXMuc3RhdHMoKS5jb25uZWN0ZWQgPT09IHRoaXMucmVsYXlzLnNpemUpIHtcbiAgICAgIHRoaXMuZW1pdChcImNvbm5lY3RcIik7XG4gICAgfVxuICB9XG4gIGhhbmRsZVJlbGF5UmVhZHkocmVsYXkpIHtcbiAgICB0aGlzLmVtaXQoXCJyZWxheTpyZWFkeVwiLCByZWxheSk7XG4gIH1cbiAgLyoqXG4gICAqIEF0dGVtcHRzIHRvIGVzdGFibGlzaCBhIGNvbm5lY3Rpb24gdG8gZWFjaCByZWxheSBpbiB0aGUgcG9vbC5cbiAgICpcbiAgICogQGFzeW5jXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbdGltZW91dE1zXSAtIE9wdGlvbmFsIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIGZvciBlYWNoIGNvbm5lY3Rpb24gYXR0ZW1wdC5cbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gYWxsIGNvbm5lY3Rpb24gYXR0ZW1wdHMgaGF2ZSBjb21wbGV0ZWQuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBhbnkgb2YgdGhlIGNvbm5lY3Rpb24gYXR0ZW1wdHMgcmVzdWx0IGluIGFuIGVycm9yIG9yIHRpbWVvdXQuXG4gICAqL1xuICBhc3luYyBjb25uZWN0KHRpbWVvdXRNcykge1xuICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgdGhpcy5zdGF0dXMgPSBcImFjdGl2ZVwiO1xuICAgIHRoaXMuZGVidWcoXG4gICAgICBgQ29ubmVjdGluZyB0byAke3RoaXMucmVsYXlzLnNpemV9IHJlbGF5cyR7dGltZW91dE1zID8gYCwgdGltZW91dCAke3RpbWVvdXRNc30uLi5gIDogXCJcIn1gXG4gICAgKTtcbiAgICBjb25zdCByZWxheXNUb0Nvbm5lY3QgPSBuZXcgU2V0KHRoaXMuYXV0b0Nvbm5lY3RSZWxheXMua2V5cygpKTtcbiAgICBmb3IgKGNvbnN0IHJlbGF5VXJsIG9mIHJlbGF5c1RvQ29ubmVjdCkge1xuICAgICAgY29uc3QgcmVsYXkgPSB0aGlzLnJlbGF5cy5nZXQocmVsYXlVcmwpO1xuICAgICAgaWYgKCFyZWxheSkge1xuICAgICAgICBjb25zb2xlLmxvZyhgUmVsYXkgJHtyZWxheVVybH0gbm90IGZvdW5kIGluIHBvb2wgJHt0aGlzLm5hbWV9YCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgY29ubmVjdFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRoaXMuZW1pdChcInJlbGF5OmNvbm5lY3RpbmdcIiwgcmVsYXkpO1xuICAgICAgICByZXR1cm4gcmVsYXkuY29ubmVjdCh0aW1lb3V0TXMpLnRoZW4ocmVzb2x2ZSkuY2F0Y2gocmVqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHRpbWVvdXRNcykge1xuICAgICAgICBjb25zdCB0aW1lb3V0UHJvbWlzZSA9IG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHJlamVjdChgVGltZWQgb3V0IGFmdGVyICR7dGltZW91dE1zfW1zYCksIHRpbWVvdXRNcyk7XG4gICAgICAgIH0pO1xuICAgICAgICBwcm9taXNlcy5wdXNoKFxuICAgICAgICAgIFByb21pc2UucmFjZShbY29ubmVjdFByb21pc2UsIHRpbWVvdXRQcm9taXNlXSkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGVidWcoXG4gICAgICAgICAgICAgIGBGYWlsZWQgdG8gY29ubmVjdCB0byByZWxheSAke3JlbGF5LnVybH06ICR7ZSA/PyBcIk5vIHJlYXNvbiBzcGVjaWZpZWRcIn1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9taXNlcy5wdXNoKGNvbm5lY3RQcm9taXNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbWF5YmVFbWl0Q29ubmVjdCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGFsbENvbm5lY3RlZCA9IHRoaXMuc3RhdHMoKS5jb25uZWN0ZWQgPT09IHRoaXMucmVsYXlzLnNpemU7XG4gICAgICBjb25zdCBzb21lQ29ubmVjdGVkID0gdGhpcy5zdGF0cygpLmNvbm5lY3RlZCA+IDA7XG4gICAgICBpZiAoIWFsbENvbm5lY3RlZCAmJiBzb21lQ29ubmVjdGVkKSB7XG4gICAgICAgIHRoaXMuZW1pdChcImNvbm5lY3RcIik7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAodGltZW91dE1zKVxuICAgICAgc2V0VGltZW91dChtYXliZUVtaXRDb25uZWN0LCB0aW1lb3V0TXMpO1xuICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICBtYXliZUVtaXRDb25uZWN0KCk7XG4gIH1cbiAgY2hlY2tPbkZsYXBwaW5nUmVsYXlzKCkge1xuICAgIGNvbnN0IGZsYXBwaW5nUmVsYXlzQ291bnQgPSB0aGlzLmZsYXBwaW5nUmVsYXlzLnNpemU7XG4gICAgY29uc3QgdG90YWxSZWxheXMgPSB0aGlzLnJlbGF5cy5zaXplO1xuICAgIGlmIChmbGFwcGluZ1JlbGF5c0NvdW50IC8gdG90YWxSZWxheXMgPj0gMC44KSB7XG4gICAgICBmb3IgKGNvbnN0IHJlbGF5VXJsIG9mIHRoaXMuZmxhcHBpbmdSZWxheXMpIHtcbiAgICAgICAgdGhpcy5iYWNrb2ZmVGltZXMuc2V0KHJlbGF5VXJsLCAwKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaGFuZGxlRmxhcHBpbmcocmVsYXkpIHtcbiAgICB0aGlzLmRlYnVnKGBSZWxheSAke3JlbGF5LnVybH0gaXMgZmxhcHBpbmdgKTtcbiAgICBsZXQgY3VycmVudEJhY2tvZmYgPSB0aGlzLmJhY2tvZmZUaW1lcy5nZXQocmVsYXkudXJsKSB8fCA1ZTM7XG4gICAgY3VycmVudEJhY2tvZmYgPSBjdXJyZW50QmFja29mZiAqIDI7XG4gICAgdGhpcy5iYWNrb2ZmVGltZXMuc2V0KHJlbGF5LnVybCwgY3VycmVudEJhY2tvZmYpO1xuICAgIHRoaXMuZGVidWcoYEJhY2tvZmYgdGltZSBmb3IgJHtyZWxheS51cmx9IGlzICR7Y3VycmVudEJhY2tvZmZ9bXNgKTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuZGVidWcoYEF0dGVtcHRpbmcgdG8gcmVjb25uZWN0IHRvICR7cmVsYXkudXJsfWApO1xuICAgICAgdGhpcy5lbWl0KFwicmVsYXk6Y29ubmVjdGluZ1wiLCByZWxheSk7XG4gICAgICByZWxheS5jb25uZWN0KCk7XG4gICAgICB0aGlzLmNoZWNrT25GbGFwcGluZ1JlbGF5cygpO1xuICAgIH0sIGN1cnJlbnRCYWNrb2ZmKTtcbiAgICByZWxheS5kaXNjb25uZWN0KCk7XG4gICAgdGhpcy5lbWl0KFwiZmxhcHBpbmdcIiwgcmVsYXkpO1xuICB9XG4gIHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVsYXlzLnNpemU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHN0YXR1cyBvZiBlYWNoIHJlbGF5IGluIHRoZSBwb29sLlxuICAgKiBAcmV0dXJucyB7TkRLUG9vbFN0YXRzfSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgbnVtYmVyIG9mIHJlbGF5cyBpbiBlYWNoIHN0YXR1cy5cbiAgICovXG4gIHN0YXRzKCkge1xuICAgIGNvbnN0IHN0YXRzID0ge1xuICAgICAgdG90YWw6IDAsXG4gICAgICBjb25uZWN0ZWQ6IDAsXG4gICAgICBkaXNjb25uZWN0ZWQ6IDAsXG4gICAgICBjb25uZWN0aW5nOiAwXG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IHJlbGF5IG9mIHRoaXMucmVsYXlzLnZhbHVlcygpKSB7XG4gICAgICBzdGF0cy50b3RhbCsrO1xuICAgICAgaWYgKHJlbGF5LnN0YXR1cyA9PT0gNSAvKiBDT05ORUNURUQgKi8pIHtcbiAgICAgICAgc3RhdHMuY29ubmVjdGVkKys7XG4gICAgICB9IGVsc2UgaWYgKHJlbGF5LnN0YXR1cyA9PT0gMSAvKiBESVNDT05ORUNURUQgKi8pIHtcbiAgICAgICAgc3RhdHMuZGlzY29ubmVjdGVkKys7XG4gICAgICB9IGVsc2UgaWYgKHJlbGF5LnN0YXR1cyA9PT0gNCAvKiBDT05ORUNUSU5HICovKSB7XG4gICAgICAgIHN0YXRzLmNvbm5lY3RpbmcrKztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0YXRzO1xuICB9XG4gIGNvbm5lY3RlZFJlbGF5cygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnJlbGF5cy52YWx1ZXMoKSkuZmlsdGVyKFxuICAgICAgKHJlbGF5KSA9PiByZWxheS5zdGF0dXMgPj0gNSAvKiBDT05ORUNURUQgKi9cbiAgICApO1xuICB9XG4gIHBlcm1hbmVudEFuZENvbm5lY3RlZFJlbGF5cygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnJlbGF5cy52YWx1ZXMoKSkuZmlsdGVyKFxuICAgICAgKHJlbGF5KSA9PiByZWxheS5zdGF0dXMgPj0gNSAvKiBDT05ORUNURUQgKi8gJiYgIXRoaXMudGVtcG9yYXJ5UmVsYXlUaW1lcnMuaGFzKHJlbGF5LnVybClcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSBsaXN0IG9mIGFsbCByZWxheSB1cmxzIGluIHRoZSBwb29sLlxuICAgKi9cbiAgdXJscygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnJlbGF5cy5rZXlzKCkpO1xuICB9XG59O1xuXG4vLyBzcmMvdXNlci9pbmRleC50c1xuaW1wb3J0IHsgbmlwMTkgYXMgbmlwMTk1IH0gZnJvbSBcIm5vc3RyLXRvb2xzXCI7XG5cbi8vIHNyYy9zdWJzY3JpcHRpb24vaW5kZXgudHNcbmltcG9ydCB7IEV2ZW50RW1pdHRlciBhcyBFdmVudEVtaXR0ZXI0IH0gZnJvbSBcInRzZWVwXCI7XG5cbi8vIHNyYy9zdWJzY3JpcHRpb24vdXRpbHMudHNcbmltcG9ydCB7IG5pcDE5IGFzIG5pcDE5MyB9IGZyb20gXCJub3N0ci10b29sc1wiO1xudmFyIE1BWF9TVUJJRF9MRU5HVEggPSAyMDtcbmZ1bmN0aW9uIHF1ZXJ5RnVsbHlGaWxsZWQoc3Vic2NyaXB0aW9uKSB7XG4gIGlmIChmaWx0ZXJJbmNsdWRlc0lkcyhzdWJzY3JpcHRpb24uZmlsdGVyKSkge1xuICAgIGlmIChyZXN1bHRIYXNBbGxSZXF1ZXN0ZWRJZHMoc3Vic2NyaXB0aW9uKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVGaWx0ZXIoZmlsdGVyMSwgZmlsdGVyMikge1xuICBpZiAoT2JqZWN0LmtleXMoZmlsdGVyMSkubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhmaWx0ZXIyKS5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoZmlsdGVyMSkpIHtcbiAgICBjb25zdCB2YWx1ZXNJbkZpbHRlcjIgPSBmaWx0ZXIyW2tleV07XG4gICAgaWYgKCF2YWx1ZXNJbkZpbHRlcjIpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZXNJbkZpbHRlcjIpKSB7XG4gICAgICBjb25zdCB2ID0gdmFsdWU7XG4gICAgICBmb3IgKGNvbnN0IHZhbHVlSW5GaWx0ZXIyIG9mIHZhbHVlc0luRmlsdGVyMikge1xuICAgICAgICBjb25zdCB2YWwgPSB2YWx1ZUluRmlsdGVyMjtcbiAgICAgICAgaWYgKCF2LmluY2x1ZGVzKHZhbCkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHZhbHVlc0luRmlsdGVyMiAhPT0gdmFsdWUpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBmaWx0ZXJJbmNsdWRlc0lkcyhmaWx0ZXIpIHtcbiAgcmV0dXJuICEhZmlsdGVyW1wiaWRzXCJdO1xufVxuZnVuY3Rpb24gcmVzdWx0SGFzQWxsUmVxdWVzdGVkSWRzKHN1YnNjcmlwdGlvbikge1xuICBjb25zdCBpZHMgPSBzdWJzY3JpcHRpb24uZmlsdGVyW1wiaWRzXCJdO1xuICByZXR1cm4gISFpZHMgJiYgaWRzLmxlbmd0aCA9PT0gc3Vic2NyaXB0aW9uLmV2ZW50Rmlyc3RTZWVuLnNpemU7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVN1YklkKHN1YnNjcmlwdGlvbnMsIGZpbHRlcnMpIHtcbiAgY29uc3Qgc3ViSWRzID0gc3Vic2NyaXB0aW9ucy5tYXAoKHN1YikgPT4gc3ViLnN1YklkKS5maWx0ZXIoQm9vbGVhbik7XG4gIGNvbnN0IHN1YklkUGFydHMgPSBbXTtcbiAgY29uc3QgZmlsdGVyTm9uS2luZEtleXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBjb25zdCBmaWx0ZXJLaW5kcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGlmIChzdWJJZHMubGVuZ3RoID4gMCkge1xuICAgIHN1YklkUGFydHMucHVzaChBcnJheS5mcm9tKG5ldyBTZXQoc3ViSWRzKSkuam9pbihcIixcIikpO1xuICB9IGVsc2Uge1xuICAgIGZvciAoY29uc3QgZmlsdGVyIG9mIGZpbHRlcnMpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGZpbHRlcikpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gXCJraW5kc1wiKSB7XG4gICAgICAgICAgZmlsdGVyLmtpbmRzPy5mb3JFYWNoKChrKSA9PiBmaWx0ZXJLaW5kcy5hZGQoaykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZpbHRlck5vbktpbmRLZXlzLmFkZChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChmaWx0ZXJLaW5kcy5zaXplID4gMCkge1xuICAgICAgc3ViSWRQYXJ0cy5wdXNoKFwia2luZHM6XCIgKyBBcnJheS5mcm9tKGZpbHRlcktpbmRzKS5qb2luKFwiLFwiKSk7XG4gICAgfVxuICAgIGlmIChmaWx0ZXJOb25LaW5kS2V5cy5zaXplID4gMCkge1xuICAgICAgc3ViSWRQYXJ0cy5wdXNoKEFycmF5LmZyb20oZmlsdGVyTm9uS2luZEtleXMpLmpvaW4oXCIsXCIpKTtcbiAgICB9XG4gIH1cbiAgbGV0IHN1YklkID0gc3ViSWRQYXJ0cy5qb2luKFwiLVwiKTtcbiAgaWYgKHN1YklkLmxlbmd0aCA+IE1BWF9TVUJJRF9MRU5HVEgpIHN1YklkID0gc3ViSWQuc3Vic3RyaW5nKDAsIE1BWF9TVUJJRF9MRU5HVEgpO1xuICBzdWJJZCArPSBcIi1cIiArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDk5OSkudG9TdHJpbmcoKTtcbiAgcmV0dXJuIHN1YklkO1xufVxuZnVuY3Rpb24gZmlsdGVyRm9yRXZlbnRzVGFnZ2luZ0lkKGlkKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgZGVjb2RlZCA9IG5pcDE5My5kZWNvZGUoaWQpO1xuICAgIHN3aXRjaCAoZGVjb2RlZC50eXBlKSB7XG4gICAgICBjYXNlIFwibmFkZHJcIjpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBcIiNhXCI6IFtcbiAgICAgICAgICAgIGAke2RlY29kZWQuZGF0YS5raW5kfToke2RlY29kZWQuZGF0YS5wdWJrZXl9OiR7ZGVjb2RlZC5kYXRhLmlkZW50aWZpZXJ9YFxuICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgIGNhc2UgXCJuZXZlbnRcIjpcbiAgICAgICAgcmV0dXJuIHsgXCIjZVwiOiBbZGVjb2RlZC5kYXRhLmlkXSB9O1xuICAgICAgY2FzZSBcIm5vdGVcIjpcbiAgICAgICAgcmV0dXJuIHsgXCIjZVwiOiBbZGVjb2RlZC5kYXRhXSB9O1xuICAgICAgY2FzZSBcIm5wcm9maWxlXCI6XG4gICAgICAgIHJldHVybiB7IFwiI3BcIjogW2RlY29kZWQuZGF0YS5wdWJrZXldIH07XG4gICAgICBjYXNlIFwibnB1YlwiOlxuICAgICAgICByZXR1cm4geyBcIiNwXCI6IFtkZWNvZGVkLmRhdGFdIH07XG4gICAgfVxuICB9IGNhdGNoIHtcbiAgfVxufVxuZnVuY3Rpb24gZmlsdGVyQW5kUmVsYXlTZXRGcm9tQmVjaDMyKGJlY2hlMiwgbmRrKSB7XG4gIGNvbnN0IGZpbHRlciA9IGZpbHRlckZyb21JZChiZWNoZTIpO1xuICBjb25zdCByZWxheXMgPSByZWxheXNGcm9tQmVjaDMyKGJlY2hlMiwgbmRrKTtcbiAgaWYgKHJlbGF5cy5sZW5ndGggPT09IDApIHJldHVybiB7IGZpbHRlciB9O1xuICByZXR1cm4ge1xuICAgIGZpbHRlcixcbiAgICByZWxheVNldDogbmV3IE5ES1JlbGF5U2V0KG5ldyBTZXQocmVsYXlzKSwgbmRrKVxuICB9O1xufVxuZnVuY3Rpb24gZmlsdGVyRnJvbUlkKGlkKSB7XG4gIGxldCBkZWNvZGVkO1xuICBpZiAoaWQubWF0Y2goTklQMzNfQV9SRUdFWCkpIHtcbiAgICBjb25zdCBba2luZCwgcHVia2V5LCBpZGVudGlmaWVyXSA9IGlkLnNwbGl0KFwiOlwiKTtcbiAgICBjb25zdCBmaWx0ZXIgPSB7XG4gICAgICBhdXRob3JzOiBbcHVia2V5XSxcbiAgICAgIGtpbmRzOiBbcGFyc2VJbnQoa2luZCldXG4gICAgfTtcbiAgICBpZiAoaWRlbnRpZmllcikge1xuICAgICAgZmlsdGVyW1wiI2RcIl0gPSBbaWRlbnRpZmllcl07XG4gICAgfVxuICAgIHJldHVybiBmaWx0ZXI7XG4gIH1cbiAgaWYgKGlkLm1hdGNoKEJFQ0gzMl9SRUdFWCkpIHtcbiAgICB0cnkge1xuICAgICAgZGVjb2RlZCA9IG5pcDE5My5kZWNvZGUoaWQpO1xuICAgICAgc3dpdGNoIChkZWNvZGVkLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcIm5ldmVudFwiOiB7XG4gICAgICAgICAgY29uc3QgZmlsdGVyMiA9IHsgaWRzOiBbZGVjb2RlZC5kYXRhLmlkXSB9O1xuICAgICAgICAgIGlmIChkZWNvZGVkLmRhdGEuYXV0aG9yKSBmaWx0ZXIyLmF1dGhvcnMgPSBbZGVjb2RlZC5kYXRhLmF1dGhvcl07XG4gICAgICAgICAgaWYgKGRlY29kZWQuZGF0YS5raW5kKSBmaWx0ZXIyLmtpbmRzID0gW2RlY29kZWQuZGF0YS5raW5kXTtcbiAgICAgICAgICByZXR1cm4gZmlsdGVyMjtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwibm90ZVwiOlxuICAgICAgICAgIHJldHVybiB7IGlkczogW2RlY29kZWQuZGF0YV0gfTtcbiAgICAgICAgY2FzZSBcIm5hZGRyXCI6XG4gICAgICAgICAgY29uc3QgZmlsdGVyID0ge1xuICAgICAgICAgICAgYXV0aG9yczogW2RlY29kZWQuZGF0YS5wdWJrZXldLFxuICAgICAgICAgICAga2luZHM6IFtkZWNvZGVkLmRhdGEua2luZF1cbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChkZWNvZGVkLmRhdGEuaWRlbnRpZmllcikgZmlsdGVyW1wiI2RcIl0gPSBbZGVjb2RlZC5kYXRhLmlkZW50aWZpZXJdO1xuICAgICAgICAgIHJldHVybiBmaWx0ZXI7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGRlY29kaW5nXCIsIGlkLCBlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgaWRzOiBbaWRdIH07XG59XG5mdW5jdGlvbiBpc05pcDMzQVZhbHVlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5tYXRjaChOSVAzM19BX1JFR0VYKSAhPT0gbnVsbDtcbn1cbnZhciBOSVAzM19BX1JFR0VYID0gL14oXFxkKyk6KFswLTlBLUZhLWZdKykoPzo6KC4qKSk/JC87XG52YXIgQkVDSDMyX1JFR0VYID0gL15uKGV2ZW50fG90ZXxwcm9maWxlfHB1YnxhZGRyKTFbXFxkXFx3XSskLztcbmZ1bmN0aW9uIHJlbGF5c0Zyb21CZWNoMzIoYmVjaDMyMiwgbmRrKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgZGVjb2RlZCA9IG5pcDE5My5kZWNvZGUoYmVjaDMyMik7XG4gICAgaWYgKFtcIm5hZGRyXCIsIFwibmV2ZW50XCJdLmluY2x1ZGVzKGRlY29kZWQ/LnR5cGUpKSB7XG4gICAgICBjb25zdCBkYXRhID0gZGVjb2RlZC5kYXRhO1xuICAgICAgaWYgKGRhdGE/LnJlbGF5cykge1xuICAgICAgICByZXR1cm4gZGF0YS5yZWxheXMubWFwKFxuICAgICAgICAgIChyKSA9PiBuZXcgTkRLUmVsYXkociwgbmRrLnJlbGF5QXV0aERlZmF1bHRQb2xpY3ksIG5kaylcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgfVxuICByZXR1cm4gW107XG59XG5cbi8vIHNyYy9ldmVudHMva2luZHMvYXJ0aWNsZS50c1xudmFyIE5ES0FydGljbGUgPSBjbGFzcyBfTkRLQXJ0aWNsZSBleHRlbmRzIE5ES0V2ZW50IHtcbiAgc3RhdGljIGtpbmQgPSAzMDAyMyAvKiBBcnRpY2xlICovO1xuICBzdGF0aWMga2luZHMgPSBbMzAwMjMgLyogQXJ0aWNsZSAqL107XG4gIGNvbnN0cnVjdG9yKG5kaywgcmF3RXZlbnQpIHtcbiAgICBzdXBlcihuZGssIHJhd0V2ZW50KTtcbiAgICB0aGlzLmtpbmQgPz89IDMwMDIzIC8qIEFydGljbGUgKi87XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBOREtBcnRpY2xlIGZyb20gYW4gZXhpc3RpbmcgTkRLRXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSBldmVudCBOREtFdmVudCB0byBjcmVhdGUgdGhlIE5ES0FydGljbGUgZnJvbS5cbiAgICogQHJldHVybnMgTkRLQXJ0aWNsZVxuICAgKi9cbiAgc3RhdGljIGZyb20oZXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtBcnRpY2xlKGV2ZW50Lm5kaywgZXZlbnQpO1xuICB9XG4gIC8qKlxuICAgKiBHZXR0ZXIgZm9yIHRoZSBhcnRpY2xlIHRpdGxlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nIHwgdW5kZWZpbmVkfSAtIFRoZSBhcnRpY2xlIHRpdGxlIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIHVuZGVmaW5lZC5cbiAgICovXG4gIGdldCB0aXRsZSgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcInRpdGxlXCIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXR0ZXIgZm9yIHRoZSBhcnRpY2xlIHRpdGxlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gdGl0bGUgLSBUaGUgdGl0bGUgdG8gc2V0IGZvciB0aGUgYXJ0aWNsZS5cbiAgICovXG4gIHNldCB0aXRsZSh0aXRsZSkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwidGl0bGVcIik7XG4gICAgaWYgKHRpdGxlKSB0aGlzLnRhZ3MucHVzaChbXCJ0aXRsZVwiLCB0aXRsZV0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXR0ZXIgZm9yIHRoZSBhcnRpY2xlIGltYWdlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nIHwgdW5kZWZpbmVkfSAtIFRoZSBhcnRpY2xlIGltYWdlIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIHVuZGVmaW5lZC5cbiAgICovXG4gIGdldCBpbWFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcImltYWdlXCIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXR0ZXIgZm9yIHRoZSBhcnRpY2xlIGltYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gaW1hZ2UgLSBUaGUgaW1hZ2UgdG8gc2V0IGZvciB0aGUgYXJ0aWNsZS5cbiAgICovXG4gIHNldCBpbWFnZShpbWFnZSkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwiaW1hZ2VcIik7XG4gICAgaWYgKGltYWdlKSB0aGlzLnRhZ3MucHVzaChbXCJpbWFnZVwiLCBpbWFnZV0pO1xuICB9XG4gIGdldCBzdW1tYXJ5KCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwic3VtbWFyeVwiKTtcbiAgfVxuICBzZXQgc3VtbWFyeShzdW1tYXJ5KSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJzdW1tYXJ5XCIpO1xuICAgIGlmIChzdW1tYXJ5KSB0aGlzLnRhZ3MucHVzaChbXCJzdW1tYXJ5XCIsIHN1bW1hcnldKTtcbiAgfVxuICAvKipcbiAgICogR2V0dGVyIGZvciB0aGUgYXJ0aWNsZSdzIHB1YmxpY2F0aW9uIHRpbWVzdGFtcC5cbiAgICpcbiAgICogQHJldHVybnMge251bWJlciB8IHVuZGVmaW5lZH0gLSBUaGUgVW5peCB0aW1lc3RhbXAgb2Ygd2hlbiB0aGUgYXJ0aWNsZSB3YXMgcHVibGlzaGVkIG9yIHVuZGVmaW5lZC5cbiAgICovXG4gIGdldCBwdWJsaXNoZWRfYXQoKSB7XG4gICAgY29uc3QgdGFnID0gdGhpcy50YWdWYWx1ZShcInB1Ymxpc2hlZF9hdFwiKTtcbiAgICBpZiAodGFnKSB7XG4gICAgICBsZXQgdmFsID0gcGFyc2VJbnQodGFnKTtcbiAgICAgIGlmICh2YWwgPiAxZTEyKSB7XG4gICAgICAgIHZhbCA9IE1hdGguZmxvb3IodmFsIC8gMWUzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgLyoqXG4gICAqIFNldHRlciBmb3IgdGhlIGFydGljbGUncyBwdWJsaWNhdGlvbiB0aW1lc3RhbXAuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgdW5kZWZpbmVkfSB0aW1lc3RhbXAgLSBUaGUgVW5peCB0aW1lc3RhbXAgdG8gc2V0IGZvciB0aGUgYXJ0aWNsZSdzIHB1YmxpY2F0aW9uIGRhdGUuXG4gICAqL1xuICBzZXQgcHVibGlzaGVkX2F0KHRpbWVzdGFtcCkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwicHVibGlzaGVkX2F0XCIpO1xuICAgIGlmICh0aW1lc3RhbXAgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wicHVibGlzaGVkX2F0XCIsIHRpbWVzdGFtcC50b1N0cmluZygpXSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgY29udGVudCB0YWdzIGZvciB0aGUgYXJ0aWNsZS5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgZmlyc3QgY2hlY2tzIGFuZCBzZXRzIHRoZSBwdWJsaWNhdGlvbiBkYXRlIGlmIG5vdCBhdmFpbGFibGUsXG4gICAqIGFuZCB0aGVuIGdlbmVyYXRlcyBjb250ZW50IHRhZ3MgYmFzZWQgb24gdGhlIGJhc2UgTkRLRXZlbnQgY2xhc3MuXG4gICAqXG4gICAqIEByZXR1cm5zIHtDb250ZW50VGFnfSAtIFRoZSBnZW5lcmF0ZWQgY29udGVudCB0YWdzLlxuICAgKi9cbiAgYXN5bmMgZ2VuZXJhdGVUYWdzKCkge1xuICAgIHN1cGVyLmdlbmVyYXRlVGFncygpO1xuICAgIGlmICghdGhpcy5wdWJsaXNoZWRfYXQpIHtcbiAgICAgIHRoaXMucHVibGlzaGVkX2F0ID0gdGhpcy5jcmVhdGVkX2F0O1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuZ2VuZXJhdGVUYWdzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHRlciBmb3IgdGhlIGFydGljbGUncyBVUkwuXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmcgfCB1bmRlZmluZWR9IC0gVGhlIGFydGljbGUncyBVUkwgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgdW5kZWZpbmVkLlxuICAgKi9cbiAgZ2V0IHVybCgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcInVybFwiKTtcbiAgfVxuICAvKipcbiAgICogU2V0dGVyIGZvciB0aGUgYXJ0aWNsZSdzIFVSTC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IHVybCAtIFRoZSBVUkwgdG8gc2V0IGZvciB0aGUgYXJ0aWNsZS5cbiAgICovXG4gIHNldCB1cmwodXJsKSB7XG4gICAgaWYgKHVybCkge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1widXJsXCIsIHVybF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbW92ZVRhZyhcInVybFwiKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9ldmVudHMva2luZHMvY2FzaHUvdG9rZW4udHNcbmZ1bmN0aW9uIHByb29mc1RvdGFsQmFsYW5jZShwcm9vZnMpIHtcbiAgcmV0dXJuIHByb29mcy5yZWR1Y2UoKGFjYywgcHJvb2YpID0+IHtcbiAgICBpZiAocHJvb2YuYW1vdW50IDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwicHJvb2YgYW1vdW50IGlzIG5lZ2F0aXZlXCIpO1xuICAgIH1cbiAgICByZXR1cm4gYWNjICsgcHJvb2YuYW1vdW50O1xuICB9LCAwKTtcbn1cbnZhciBOREtDYXNodVRva2VuID0gY2xhc3MgX05ES0Nhc2h1VG9rZW4gZXh0ZW5kcyBOREtFdmVudCB7XG4gIF9wcm9vZnMgPSBbXTtcbiAgX21pbnQ7XG4gIHN0YXRpYyBraW5kID0gNzM3NSAvKiBDYXNodVRva2VuICovO1xuICBzdGF0aWMga2luZHMgPSBbNzM3NSAvKiBDYXNodVRva2VuICovXTtcbiAgLyoqXG4gICAqIFRva2VucyB0aGF0IHRoaXMgdG9rZW4gc3VwZXJzZWVkc1xuICAgKi9cbiAgX2RlbGV0ZXMgPSBbXTtcbiAgb3JpZ2luYWw7XG4gIGNvbnN0cnVjdG9yKG5kaywgZXZlbnQpIHtcbiAgICBzdXBlcihuZGssIGV2ZW50KTtcbiAgICB0aGlzLmtpbmQgPz89IDczNzUgLyogQ2FzaHVUb2tlbiAqLztcbiAgfVxuICBzdGF0aWMgYXN5bmMgZnJvbShldmVudCkge1xuICAgIGNvbnN0IHRva2VuID0gbmV3IF9OREtDYXNodVRva2VuKGV2ZW50Lm5kaywgZXZlbnQpO1xuICAgIHRva2VuLm9yaWdpbmFsID0gZXZlbnQ7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRva2VuLmRlY3J5cHQoKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHRva2VuLmNvbnRlbnQgPSB0b2tlbi5vcmlnaW5hbC5jb250ZW50O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgY29udGVudCA9IEpTT04ucGFyc2UodG9rZW4uY29udGVudCk7XG4gICAgICB0b2tlbi5wcm9vZnMgPSBjb250ZW50LnByb29mcztcbiAgICAgIHRva2VuLm1pbnQgPSBjb250ZW50Lm1pbnQgPz8gdG9rZW4udGFnVmFsdWUoXCJtaW50XCIpO1xuICAgICAgdG9rZW4uZGVsZXRlZFRva2VucyA9IGNvbnRlbnQuZGVsID8/IFtdO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRva2VuLnByb29mcykpIHJldHVybjtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiB0b2tlbjtcbiAgfVxuICBnZXQgcHJvb2ZzKCkge1xuICAgIHJldHVybiB0aGlzLl9wcm9vZnM7XG4gIH1cbiAgc2V0IHByb29mcyhwcm9vZnMpIHtcbiAgICBjb25zdCBjcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgdGhpcy5fcHJvb2ZzID0gcHJvb2ZzLmZpbHRlcigocHJvb2YpID0+IHtcbiAgICAgIGlmIChjcy5oYXMocHJvb2YuQykpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiUGFzc2VkIGluIHByb29mcyBoYWQgZHVwbGljYXRlcywgaWdub3JpbmdcIiwgcHJvb2YuQyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9vZi5hbW91bnQgPCAwKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIkludmFsaWQgcHJvb2Ygd2l0aCBuZWdhdGl2ZSBhbW91bnRcIiwgcHJvb2YpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjcy5hZGQocHJvb2YuQyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KS5tYXAodGhpcy5jbGVhblByb29mKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIG1pbmltYWwgcHJvb2Ygb2JqZWN0IHdpdGggb25seSBlc3NlbnRpYWwgcHJvcGVydGllc1xuICAgKi9cbiAgY2xlYW5Qcm9vZihwcm9vZikge1xuICAgIHJldHVybiB7XG4gICAgICBpZDogcHJvb2YuaWQsXG4gICAgICBhbW91bnQ6IHByb29mLmFtb3VudCxcbiAgICAgIEM6IHByb29mLkMsXG4gICAgICBzZWNyZXQ6IHByb29mLnNlY3JldFxuICAgIH07XG4gIH1cbiAgYXN5bmMgdG9Ob3N0ckV2ZW50KHB1YmtleSkge1xuICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICBwcm9vZnM6IHRoaXMucHJvb2ZzLm1hcCh0aGlzLmNsZWFuUHJvb2YpLFxuICAgICAgbWludDogdGhpcy5taW50LFxuICAgICAgZGVsOiB0aGlzLmRlbGV0ZWRUb2tlbnMgPz8gW11cbiAgICB9O1xuICAgIHRoaXMuY29udGVudCA9IEpTT04uc3RyaW5naWZ5KHBheWxvYWQpO1xuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLm5kay5zaWduZXIudXNlcigpO1xuICAgIGF3YWl0IHRoaXMuZW5jcnlwdCh1c2VyLCB2b2lkIDAsIFwibmlwNDRcIik7XG4gICAgcmV0dXJuIHN1cGVyLnRvTm9zdHJFdmVudChwdWJrZXkpO1xuICB9XG4gIHNldCBtaW50KG1pbnQpIHtcbiAgICB0aGlzLl9taW50ID0gbWludDtcbiAgfVxuICBnZXQgbWludCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWludDtcbiAgfVxuICAvKipcbiAgICogVG9rZW5zIHRoYXQgd2VyZSBkZWxldGVkIGJ5IHRoZSBjcmVhdGlvbiBvZiB0aGlzIHRva2VuLlxuICAgKi9cbiAgZ2V0IGRlbGV0ZWRUb2tlbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlbGV0ZXM7XG4gIH1cbiAgLyoqXG4gICAqIE1hcmtzIHRva2VucyB0aGF0IHdlcmUgZGVsZXRlZCBieSB0aGUgY3JlYXRpb24gb2YgdGhpcyB0b2tlbi5cbiAgICovXG4gIHNldCBkZWxldGVkVG9rZW5zKHRva2VuSWRzKSB7XG4gICAgdGhpcy5fZGVsZXRlcyA9IHRva2VuSWRzO1xuICB9XG4gIGdldCBhbW91bnQoKSB7XG4gICAgcmV0dXJuIHByb29mc1RvdGFsQmFsYW5jZSh0aGlzLnByb29mcyk7XG4gIH1cbiAgYXN5bmMgcHVibGlzaChyZWxheVNldCwgdGltZW91dE1zLCByZXF1aXJlZFJlbGF5Q291bnQpIHtcbiAgICBpZiAodGhpcy5vcmlnaW5hbCkge1xuICAgICAgcmV0dXJuIHRoaXMub3JpZ2luYWwucHVibGlzaChyZWxheVNldCwgdGltZW91dE1zLCByZXF1aXJlZFJlbGF5Q291bnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3VwZXIucHVibGlzaChyZWxheVNldCwgdGltZW91dE1zLCByZXF1aXJlZFJlbGF5Q291bnQpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2V2ZW50cy9raW5kcy9oaWdobGlnaHQudHNcbmltcG9ydCB7IG5pcDE5IGFzIG5pcDE5NCB9IGZyb20gXCJub3N0ci10b29sc1wiO1xudmFyIE5ES0hpZ2hsaWdodCA9IGNsYXNzIF9OREtIaWdobGlnaHQgZXh0ZW5kcyBOREtFdmVudCB7XG4gIF9hcnRpY2xlO1xuICBzdGF0aWMga2luZCA9IDk4MDIgLyogSGlnaGxpZ2h0ICovO1xuICBzdGF0aWMga2luZHMgPSBbOTgwMiAvKiBIaWdobGlnaHQgKi9dO1xuICBjb25zdHJ1Y3RvcihuZGssIHJhd0V2ZW50KSB7XG4gICAgc3VwZXIobmRrLCByYXdFdmVudCk7XG4gICAgdGhpcy5raW5kID8/PSA5ODAyIC8qIEhpZ2hsaWdodCAqLztcbiAgfVxuICBzdGF0aWMgZnJvbShldmVudCkge1xuICAgIHJldHVybiBuZXcgX05ES0hpZ2hsaWdodChldmVudC5uZGssIGV2ZW50KTtcbiAgfVxuICBnZXQgdXJsKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwiclwiKTtcbiAgfVxuICAvKipcbiAgICogQ29udGV4dCB0YWcuXG4gICAqL1xuICBzZXQgY29udGV4dChjb250ZXh0KSB7XG4gICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkge1xuICAgICAgdGhpcy50YWdzID0gdGhpcy50YWdzLmZpbHRlcigoW3RhZywgdmFsdWVdKSA9PiB0YWcgIT09IFwiY29udGV4dFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50YWdzID0gdGhpcy50YWdzLmZpbHRlcigoW3RhZywgdmFsdWVdKSA9PiB0YWcgIT09IFwiY29udGV4dFwiKTtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcImNvbnRleHRcIiwgY29udGV4dF0pO1xuICAgIH1cbiAgfVxuICBnZXQgY29udGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdzLmZpbmQoKFt0YWcsIHZhbHVlXSkgPT4gdGFnID09PSBcImNvbnRleHRcIik/LlsxXSA/PyB2b2lkIDA7XG4gIH1cbiAgLyoqXG4gICAqIFdpbGwgcmV0dXJuIHRoZSBhcnRpY2xlIFVSTCBvciBOREtFdmVudCBpZiB0aGV5IGhhdmUgYWxyZWFkeSBiZWVuXG4gICAqIHNldCAoaXQgd29uJ3QgYXR0ZW1wdCB0byBsb2FkIHJlbW90ZSBldmVudHMpXG4gICAqL1xuICBnZXQgYXJ0aWNsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYXJ0aWNsZTtcbiAgfVxuICAvKipcbiAgICogQXJ0aWNsZSB0aGUgaGlnaGxpZ2h0IGlzIGNvbWluZyBmcm9tLlxuICAgKlxuICAgKiBAcGFyYW0gYXJ0aWNsZSBBcnRpY2xlIFVSTCBvciBOREtFdmVudC5cbiAgICovXG4gIHNldCBhcnRpY2xlKGFydGljbGUpIHtcbiAgICB0aGlzLl9hcnRpY2xlID0gYXJ0aWNsZTtcbiAgICBpZiAodHlwZW9mIGFydGljbGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcInJcIiwgYXJ0aWNsZV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRhZyhhcnRpY2xlKTtcbiAgICB9XG4gIH1cbiAgZ2V0QXJ0aWNsZVRhZygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJhXCIpWzBdIHx8IHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwiZVwiKVswXSB8fCB0aGlzLmdldE1hdGNoaW5nVGFncyhcInJcIilbMF07XG4gIH1cbiAgYXN5bmMgZ2V0QXJ0aWNsZSgpIHtcbiAgICBpZiAodGhpcy5fYXJ0aWNsZSAhPT0gdm9pZCAwKSByZXR1cm4gdGhpcy5fYXJ0aWNsZTtcbiAgICBsZXQgdGFnZ2VkQmVjaDMyO1xuICAgIGNvbnN0IGFydGljbGVUYWcgPSB0aGlzLmdldEFydGljbGVUYWcoKTtcbiAgICBpZiAoIWFydGljbGVUYWcpIHJldHVybiB2b2lkIDA7XG4gICAgc3dpdGNoIChhcnRpY2xlVGFnWzBdKSB7XG4gICAgICBjYXNlIFwiYVwiOlxuICAgICAgICBjb25zdCBba2luZCwgcHVia2V5LCBpZGVudGlmaWVyXSA9IGFydGljbGVUYWdbMV0uc3BsaXQoXCI6XCIpO1xuICAgICAgICB0YWdnZWRCZWNoMzIgPSBuaXAxOTQubmFkZHJFbmNvZGUoeyBraW5kOiBwYXJzZUludChraW5kKSwgcHVia2V5LCBpZGVudGlmaWVyIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJlXCI6XG4gICAgICAgIHRhZ2dlZEJlY2gzMiA9IG5pcDE5NC5ub3RlRW5jb2RlKGFydGljbGVUYWdbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJyXCI6XG4gICAgICAgIHRoaXMuX2FydGljbGUgPSBhcnRpY2xlVGFnWzFdO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKHRhZ2dlZEJlY2gzMikge1xuICAgICAgbGV0IGEgPSBhd2FpdCB0aGlzLm5kaz8uZmV0Y2hFdmVudCh0YWdnZWRCZWNoMzIpO1xuICAgICAgaWYgKGEpIHtcbiAgICAgICAgaWYgKGEua2luZCA9PT0gMzAwMjMgLyogQXJ0aWNsZSAqLykge1xuICAgICAgICAgIGEgPSBOREtBcnRpY2xlLmZyb20oYSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYXJ0aWNsZSA9IGE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9hcnRpY2xlO1xuICB9XG59O1xuXG4vLyBzcmMvdXRpbHMvaW1ldGEudHNcbmZ1bmN0aW9uIG1hcEltZXRhVGFnKHRhZykge1xuICBjb25zdCBkYXRhID0ge307XG4gIGlmICh0YWcubGVuZ3RoID09PSAyKSB7XG4gICAgY29uc3QgcGFydHMgPSB0YWdbMV0uc3BsaXQoXCIgXCIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIGNvbnN0IGtleSA9IHBhcnRzW2ldO1xuICAgICAgY29uc3QgdmFsdWUgPSBwYXJ0c1tpICsgMV07XG4gICAgICBpZiAoa2V5ID09PSBcImZhbGxiYWNrXCIpIHtcbiAgICAgICAgaWYgKCFkYXRhLmZhbGxiYWNrKSBkYXRhLmZhbGxiYWNrID0gW107XG4gICAgICAgIGRhdGEuZmFsbGJhY2sucHVzaCh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCB2YWwgb2YgdGFnKSB7XG4gICAgY29uc3QgcGFydHMgPSB2YWwuc3BsaXQoXCIgXCIpO1xuICAgIGNvbnN0IGtleSA9IHBhcnRzWzBdO1xuICAgIGNvbnN0IHZhbHVlID0gcGFydHMuc2xpY2UoMSkuam9pbihcIiBcIik7XG4gICAgaWYgKGtleSA9PT0gXCJmYWxsYmFja1wiKSB7XG4gICAgICBpZiAoIWRhdGEuZmFsbGJhY2spIGRhdGEuZmFsbGJhY2sgPSBbXTtcbiAgICAgIGRhdGEuZmFsbGJhY2sucHVzaCh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGFba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cbmZ1bmN0aW9uIGltZXRhVGFnVG9UYWcoaW1ldGEpIHtcbiAgY29uc3QgdGFnID0gW1wiaW1ldGFcIl07XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGltZXRhKSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgZm9yIChjb25zdCB2IG9mIHZhbHVlKSB7XG4gICAgICAgIHRhZy5wdXNoKGtleSwgdik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgdGFnLnB1c2goa2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0YWc7XG59XG5cbi8vIHNyYy9ldmVudHMva2luZHMvaW1hZ2UudHNcbnZhciBOREtJbWFnZSA9IGNsYXNzIF9OREtJbWFnZSBleHRlbmRzIE5ES0V2ZW50IHtcbiAgc3RhdGljIGtpbmQgPSAyMCAvKiBJbWFnZSAqLztcbiAgc3RhdGljIGtpbmRzID0gWzIwIC8qIEltYWdlICovXTtcbiAgX2ltZXRhcztcbiAgY29uc3RydWN0b3IobmRrLCByYXdFdmVudCkge1xuICAgIHN1cGVyKG5kaywgcmF3RXZlbnQpO1xuICAgIHRoaXMua2luZCA/Pz0gMjAgLyogSW1hZ2UgKi87XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBOREtJbWFnZSBmcm9tIGFuIGV4aXN0aW5nIE5ES0V2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQgTkRLRXZlbnQgdG8gY3JlYXRlIHRoZSBOREtJbWFnZSBmcm9tLlxuICAgKiBAcmV0dXJucyBOREtJbWFnZVxuICAgKi9cbiAgc3RhdGljIGZyb20oZXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtJbWFnZShldmVudC5uZGssIGV2ZW50LnJhd0V2ZW50KCkpO1xuICB9XG4gIGdldCBpc1ZhbGlkKCkge1xuICAgIHJldHVybiB0aGlzLmltZXRhcy5sZW5ndGggPiAwO1xuICB9XG4gIGdldCBpbWV0YXMoKSB7XG4gICAgaWYgKHRoaXMuX2ltZXRhcykgcmV0dXJuIHRoaXMuX2ltZXRhcztcbiAgICB0aGlzLl9pbWV0YXMgPSB0aGlzLnRhZ3MuZmlsdGVyKCh0YWcpID0+IHRhZ1swXSA9PT0gXCJpbWV0YVwiKS5tYXAobWFwSW1ldGFUYWcpLmZpbHRlcigoaW1ldGEpID0+ICEhaW1ldGEudXJsKTtcbiAgICByZXR1cm4gdGhpcy5faW1ldGFzO1xuICB9XG4gIHNldCBpbWV0YXModGFncykge1xuICAgIHRoaXMuX2ltZXRhcyA9IHRhZ3M7XG4gICAgdGhpcy50YWdzID0gdGhpcy50YWdzLmZpbHRlcigodGFnKSA9PiB0YWdbMF0gIT09IFwiaW1ldGFcIik7XG4gICAgdGhpcy50YWdzLnB1c2goLi4udGFncy5tYXAoaW1ldGFUYWdUb1RhZykpO1xuICB9XG59O1xuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL2xpc3RzL2luZGV4LnRzXG52YXIgTkRLTGlzdCA9IGNsYXNzIF9OREtMaXN0IGV4dGVuZHMgTkRLRXZlbnQge1xuICBfZW5jcnlwdGVkVGFncztcbiAgc3RhdGljIGtpbmRzID0gW1xuICAgIDEwMDYzIC8qIEJsb3Nzb21MaXN0ICovLFxuICAgIDMwMDAxIC8qIENhdGVnb3JpemVkQm9va21hcmtMaXN0ICovLFxuICAgIDEwMDA0IC8qIENvbW11bml0eUxpc3QgKi8sXG4gICAgMTAwNTAgLyogRGlyZWN0TWVzc2FnZVJlY2VpdmVSZWxheUxpc3QgKi8sXG4gICAgMTAwMzAgLyogRW1vamlMaXN0ICovLFxuICAgIDEwMDE1IC8qIEludGVyZXN0TGlzdCAqLyxcbiAgICAxMDAwMSAvKiBQaW5MaXN0ICovLFxuICAgIDEwMDAyIC8qIFJlbGF5TGlzdCAqLyxcbiAgICAxMDAwNyAvKiBTZWFyY2hSZWxheUxpc3QgKi8sXG4gICAgMTAwMDYgLyogQmxvY2tSZWxheUxpc3QgKi8sXG4gICAgMTAwMDMgLyogQm9va21hcmtMaXN0ICovXG4gIF07XG4gIC8qKlxuICAgKiBTdG9yZXMgdGhlIG51bWJlciBvZiBieXRlcyB0aGUgY29udGVudCB3YXMgYmVmb3JlIGRlY3J5cHRpb25cbiAgICogdG8gZXhwaXJlIHRoZSBjYWNoZSB3aGVuIHRoZSBjb250ZW50IGNoYW5nZXMuXG4gICAqL1xuICBlbmNyeXB0ZWRUYWdzTGVuZ3RoO1xuICBjb25zdHJ1Y3RvcihuZGssIHJhd0V2ZW50KSB7XG4gICAgc3VwZXIobmRrLCByYXdFdmVudCk7XG4gICAgdGhpcy5raW5kID8/PSAzMDAwMSAvKiBDYXRlZ29yaXplZEJvb2ttYXJrTGlzdCAqLztcbiAgfVxuICAvKipcbiAgICogV3JhcCBhIE5ES0V2ZW50IGludG8gYSBOREtMaXN0XG4gICAqL1xuICBzdGF0aWMgZnJvbShuZGtFdmVudCkge1xuICAgIHJldHVybiBuZXcgX05ES0xpc3QobmRrRXZlbnQubmRrLCBuZGtFdmVudCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHRpdGxlIG9mIHRoZSBsaXN0LiBGYWxscyBiYWNrIG9uIGZldGNoaW5nIHRoZSBuYW1lIHRhZyB2YWx1ZS5cbiAgICovXG4gIGdldCB0aXRsZSgpIHtcbiAgICBjb25zdCB0aXRsZVRhZyA9IHRoaXMudGFnVmFsdWUoXCJ0aXRsZVwiKSB8fCB0aGlzLnRhZ1ZhbHVlKFwibmFtZVwiKTtcbiAgICBpZiAodGl0bGVUYWcpIHJldHVybiB0aXRsZVRhZztcbiAgICBpZiAodGhpcy5raW5kID09PSAzIC8qIENvbnRhY3RzICovKSB7XG4gICAgICByZXR1cm4gXCJDb250YWN0c1wiO1xuICAgIH0gZWxzZSBpZiAodGhpcy5raW5kID09PSAxZTQgLyogTXV0ZUxpc3QgKi8pIHtcbiAgICAgIHJldHVybiBcIk11dGVcIjtcbiAgICB9IGVsc2UgaWYgKHRoaXMua2luZCA9PT0gMTAwMDEgLyogUGluTGlzdCAqLykge1xuICAgICAgcmV0dXJuIFwiUGlubmVkIE5vdGVzXCI7XG4gICAgfSBlbHNlIGlmICh0aGlzLmtpbmQgPT09IDEwMDAyIC8qIFJlbGF5TGlzdCAqLykge1xuICAgICAgcmV0dXJuIFwiUmVsYXkgTWV0YWRhdGFcIjtcbiAgICB9IGVsc2UgaWYgKHRoaXMua2luZCA9PT0gMTAwMDMgLyogQm9va21hcmtMaXN0ICovKSB7XG4gICAgICByZXR1cm4gXCJCb29rbWFya3NcIjtcbiAgICB9IGVsc2UgaWYgKHRoaXMua2luZCA9PT0gMTAwMDQgLyogQ29tbXVuaXR5TGlzdCAqLykge1xuICAgICAgcmV0dXJuIFwiQ29tbXVuaXRpZXNcIjtcbiAgICB9IGVsc2UgaWYgKHRoaXMua2luZCA9PT0gMTAwMDUgLyogUHVibGljQ2hhdExpc3QgKi8pIHtcbiAgICAgIHJldHVybiBcIlB1YmxpYyBDaGF0c1wiO1xuICAgIH0gZWxzZSBpZiAodGhpcy5raW5kID09PSAxMDAwNiAvKiBCbG9ja1JlbGF5TGlzdCAqLykge1xuICAgICAgcmV0dXJuIFwiQmxvY2tlZCBSZWxheXNcIjtcbiAgICB9IGVsc2UgaWYgKHRoaXMua2luZCA9PT0gMTAwMDcgLyogU2VhcmNoUmVsYXlMaXN0ICovKSB7XG4gICAgICByZXR1cm4gXCJTZWFyY2ggUmVsYXlzXCI7XG4gICAgfSBlbHNlIGlmICh0aGlzLmtpbmQgPT09IDEwMDUwIC8qIERpcmVjdE1lc3NhZ2VSZWNlaXZlUmVsYXlMaXN0ICovKSB7XG4gICAgICByZXR1cm4gXCJEaXJlY3QgTWVzc2FnZSBSZWNlaXZlIFJlbGF5c1wiO1xuICAgIH0gZWxzZSBpZiAodGhpcy5raW5kID09PSAxMDAxNSAvKiBJbnRlcmVzdExpc3QgKi8pIHtcbiAgICAgIHJldHVybiBcIkludGVyZXN0c1wiO1xuICAgIH0gZWxzZSBpZiAodGhpcy5raW5kID09PSAxMDAzMCAvKiBFbW9qaUxpc3QgKi8pIHtcbiAgICAgIHJldHVybiBcIkVtb2ppc1wiO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcImRcIik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSB0aXRsZSBvZiB0aGUgbGlzdC5cbiAgICovXG4gIHNldCB0aXRsZSh0aXRsZSkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFtcInRpdGxlXCIsIFwibmFtZVwiXSk7XG4gICAgaWYgKHRpdGxlKSB0aGlzLnRhZ3MucHVzaChbXCJ0aXRsZVwiLCB0aXRsZV0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBsaXN0LlxuICAgKiBAZGVwcmVjYXRlZCBQbGVhc2UgdXNlIFwidGl0bGVcIiBpbnN0ZWFkLlxuICAgKi9cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMudGl0bGU7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIG5hbWUgb2YgdGhlIGxpc3QuXG4gICAqIEBkZXByZWNhdGVkIFBsZWFzZSB1c2UgXCJ0aXRsZVwiIGluc3RlYWQuIFRoaXMgbWV0aG9kIHdpbGwgdXNlIHRoZSBgdGl0bGVgIHRhZyBpbnN0ZWFkLlxuICAgKi9cbiAgc2V0IG5hbWUobmFtZSkge1xuICAgIHRoaXMudGl0bGUgPSBuYW1lO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgbGlzdC5cbiAgICovXG4gIGdldCBkZXNjcmlwdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcImRlc2NyaXB0aW9uXCIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgbGlzdC5cbiAgICovXG4gIHNldCBkZXNjcmlwdGlvbihuYW1lKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJkZXNjcmlwdGlvblwiKTtcbiAgICBpZiAobmFtZSkgdGhpcy50YWdzLnB1c2goW1wiZGVzY3JpcHRpb25cIiwgbmFtZV0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbWFnZSBvZiB0aGUgbGlzdC5cbiAgICovXG4gIGdldCBpbWFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcImltYWdlXCIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBpbWFnZSBvZiB0aGUgbGlzdC5cbiAgICovXG4gIHNldCBpbWFnZShuYW1lKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJpbWFnZVwiKTtcbiAgICBpZiAobmFtZSkgdGhpcy50YWdzLnB1c2goW1wiaW1hZ2VcIiwgbmFtZV0pO1xuICB9XG4gIGlzRW5jcnlwdGVkVGFnc0NhY2hlVmFsaWQoKSB7XG4gICAgcmV0dXJuICEhKHRoaXMuX2VuY3J5cHRlZFRhZ3MgJiYgdGhpcy5lbmNyeXB0ZWRUYWdzTGVuZ3RoID09PSB0aGlzLmNvbnRlbnQubGVuZ3RoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGVjcnlwdGVkIGNvbnRlbnQgb2YgdGhlIGxpc3QuXG4gICAqL1xuICBhc3luYyBlbmNyeXB0ZWRUYWdzKHVzZUNhY2hlID0gdHJ1ZSkge1xuICAgIGlmICh1c2VDYWNoZSAmJiB0aGlzLmlzRW5jcnlwdGVkVGFnc0NhY2hlVmFsaWQoKSkgcmV0dXJuIHRoaXMuX2VuY3J5cHRlZFRhZ3M7XG4gICAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTkRLIGluc3RhbmNlIG5vdCBzZXRcIik7XG4gICAgaWYgKCF0aGlzLm5kay5zaWduZXIpIHRocm93IG5ldyBFcnJvcihcIk5ESyBzaWduZXIgbm90IHNldFwiKTtcbiAgICBjb25zdCB1c2VyID0gYXdhaXQgdGhpcy5uZGsuc2lnbmVyLnVzZXIoKTtcbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMuY29udGVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgZGVjcnlwdGVkQ29udGVudCA9IGF3YWl0IHRoaXMubmRrLnNpZ25lci5kZWNyeXB0KHVzZXIsIHRoaXMuY29udGVudCk7XG4gICAgICAgICAgY29uc3QgYSA9IEpTT04ucGFyc2UoZGVjcnlwdGVkQ29udGVudCk7XG4gICAgICAgICAgaWYgKGEgJiYgYVswXSkge1xuICAgICAgICAgICAgdGhpcy5lbmNyeXB0ZWRUYWdzTGVuZ3RoID0gdGhpcy5jb250ZW50Lmxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9lbmNyeXB0ZWRUYWdzID0gYTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5lbmNyeXB0ZWRUYWdzTGVuZ3RoID0gdGhpcy5jb250ZW50Lmxlbmd0aDtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZW5jcnlwdGVkVGFncyA9IFtdO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYGVycm9yIGRlY3J5cHRpbmcgJHt0aGlzLmNvbnRlbnR9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfVxuICAvKipcbiAgICogVGhpcyBtZXRob2QgY2FuIGJlIG92ZXJyaWRlbiB0byB2YWxpZGF0ZSB0aGF0IGEgdGFnIGlzIHZhbGlkIGZvciB0aGlzIGxpc3QuXG4gICAqXG4gICAqIChpLmUuIHRoZSBOREtQZXJzb25MaXN0IGNhbiB2YWxpZGF0ZSB0aGF0IGl0ZW1zIGFyZSBOREtVc2VyIGluc3RhbmNlcylcbiAgICovXG4gIHZhbGlkYXRlVGFnKHRhZ1ZhbHVlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZ2V0SXRlbXModHlwZSkge1xuICAgIHJldHVybiB0aGlzLnRhZ3MuZmlsdGVyKCh0YWcpID0+IHRhZ1swXSA9PT0gdHlwZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHVuZWNyeXB0ZWQgaXRlbXMgaW4gdGhpcyBsaXN0LlxuICAgKi9cbiAgZ2V0IGl0ZW1zKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ3MuZmlsdGVyKCh0KSA9PiB7XG4gICAgICByZXR1cm4gIVtcbiAgICAgICAgXCJkXCIsXG4gICAgICAgIFwiTFwiLFxuICAgICAgICBcImxcIixcbiAgICAgICAgXCJ0aXRsZVwiLFxuICAgICAgICBcIm5hbWVcIixcbiAgICAgICAgXCJkZXNjcmlwdGlvblwiLFxuICAgICAgICBcInB1Ymxpc2hlZF9hdFwiLFxuICAgICAgICBcInN1bW1hcnlcIixcbiAgICAgICAgXCJpbWFnZVwiLFxuICAgICAgICBcInRodW1iXCIsXG4gICAgICAgIFwiYWx0XCIsXG4gICAgICAgIFwiZXhwaXJhdGlvblwiLFxuICAgICAgICBcInN1YmplY3RcIixcbiAgICAgICAgXCJjbGllbnRcIlxuICAgICAgXS5pbmNsdWRlcyh0WzBdKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIG5ldyBpdGVtIHRvIHRoZSBsaXN0LlxuICAgKiBAcGFyYW0gcmVsYXkgUmVsYXkgdG8gYWRkXG4gICAqIEBwYXJhbSBtYXJrIE9wdGlvbmFsIG1hcmsgdG8gYWRkIHRvIHRoZSBpdGVtXG4gICAqIEBwYXJhbSBlbmNyeXB0ZWQgV2hldGhlciB0byBlbmNyeXB0IHRoZSBpdGVtXG4gICAqIEBwYXJhbSBwb3NpdGlvbiBXaGVyZSB0byBhZGQgdGhlIGl0ZW0gaW4gdGhlIGxpc3QgKHRvcCBvciBib3R0b20pXG4gICAqL1xuICBhc3luYyBhZGRJdGVtKGl0ZW0sIG1hcmsgPSB2b2lkIDAsIGVuY3J5cHRlZCA9IGZhbHNlLCBwb3NpdGlvbiA9IFwiYm90dG9tXCIpIHtcbiAgICBpZiAoIXRoaXMubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJOREsgaW5zdGFuY2Ugbm90IHNldFwiKTtcbiAgICBpZiAoIXRoaXMubmRrLnNpZ25lcikgdGhyb3cgbmV3IEVycm9yKFwiTkRLIHNpZ25lciBub3Qgc2V0XCIpO1xuICAgIGxldCB0YWdzO1xuICAgIGlmIChpdGVtIGluc3RhbmNlb2YgTkRLRXZlbnQpIHtcbiAgICAgIHRhZ3MgPSBbaXRlbS50YWdSZWZlcmVuY2UobWFyayldO1xuICAgIH0gZWxzZSBpZiAoaXRlbSBpbnN0YW5jZW9mIE5ES1VzZXIpIHtcbiAgICAgIHRhZ3MgPSBpdGVtLnJlZmVyZW5jZVRhZ3MoKTtcbiAgICB9IGVsc2UgaWYgKGl0ZW0gaW5zdGFuY2VvZiBOREtSZWxheSkge1xuICAgICAgdGFncyA9IGl0ZW0ucmVmZXJlbmNlVGFncygpO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgICAgdGFncyA9IFtpdGVtXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBvYmplY3QgdHlwZVwiKTtcbiAgICB9XG4gICAgaWYgKG1hcmspIHRhZ3NbMF0ucHVzaChtYXJrKTtcbiAgICBpZiAoZW5jcnlwdGVkKSB7XG4gICAgICBjb25zdCB1c2VyID0gYXdhaXQgdGhpcy5uZGsuc2lnbmVyLnVzZXIoKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRMaXN0ID0gYXdhaXQgdGhpcy5lbmNyeXB0ZWRUYWdzKCk7XG4gICAgICBpZiAocG9zaXRpb24gPT09IFwidG9wXCIpIGN1cnJlbnRMaXN0LnVuc2hpZnQoLi4udGFncyk7XG4gICAgICBlbHNlIGN1cnJlbnRMaXN0LnB1c2goLi4udGFncyk7XG4gICAgICB0aGlzLl9lbmNyeXB0ZWRUYWdzID0gY3VycmVudExpc3Q7XG4gICAgICB0aGlzLmVuY3J5cHRlZFRhZ3NMZW5ndGggPSB0aGlzLmNvbnRlbnQubGVuZ3RoO1xuICAgICAgdGhpcy5jb250ZW50ID0gSlNPTi5zdHJpbmdpZnkoY3VycmVudExpc3QpO1xuICAgICAgYXdhaXQgdGhpcy5lbmNyeXB0KHVzZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocG9zaXRpb24gPT09IFwidG9wXCIpIHRoaXMudGFncy51bnNoaWZ0KC4uLnRhZ3MpO1xuICAgICAgZWxzZSB0aGlzLnRhZ3MucHVzaCguLi50YWdzKTtcbiAgICB9XG4gICAgdGhpcy5jcmVhdGVkX2F0ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMWUzKTtcbiAgICB0aGlzLmVtaXQoXCJjaGFuZ2VcIik7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZXMgYW4gaXRlbSBmcm9tIHRoZSBsaXN0IGZyb20gYm90aCB0aGUgZW5jcnlwdGVkIGFuZCB1bmVuY3J5cHRlZCBsaXN0cy5cbiAgICogQHBhcmFtIHZhbHVlIHZhbHVlIG9mIGl0ZW0gdG8gcmVtb3ZlIGZyb20gdGhlIGxpc3RcbiAgICogQHBhcmFtIHB1Ymxpc2ggd2hldGhlciB0byBwdWJsaXNoIHRoZSBjaGFuZ2VcbiAgICogQHJldHVybnNcbiAgICovXG4gIGFzeW5jIHJlbW92ZUl0ZW1CeVZhbHVlKHZhbHVlLCBwdWJsaXNoID0gdHJ1ZSkge1xuICAgIGlmICghdGhpcy5uZGspIHRocm93IG5ldyBFcnJvcihcIk5ESyBpbnN0YW5jZSBub3Qgc2V0XCIpO1xuICAgIGlmICghdGhpcy5uZGsuc2lnbmVyKSB0aHJvdyBuZXcgRXJyb3IoXCJOREsgc2lnbmVyIG5vdCBzZXRcIik7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLnRhZ3MuZmluZEluZGV4KCh0YWcpID0+IHRhZ1sxXSA9PT0gdmFsdWUpO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB0aGlzLnRhZ3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gICAgY29uc3QgdXNlciA9IGF3YWl0IHRoaXMubmRrLnNpZ25lci51c2VyKCk7XG4gICAgY29uc3QgZW5jcnlwdGVkVGFncyA9IGF3YWl0IHRoaXMuZW5jcnlwdGVkVGFncygpO1xuICAgIGNvbnN0IGVuY3J5cHRlZEluZGV4ID0gZW5jcnlwdGVkVGFncy5maW5kSW5kZXgoKHRhZykgPT4gdGFnWzFdID09PSB2YWx1ZSk7XG4gICAgaWYgKGVuY3J5cHRlZEluZGV4ID49IDApIHtcbiAgICAgIGVuY3J5cHRlZFRhZ3Muc3BsaWNlKGVuY3J5cHRlZEluZGV4LCAxKTtcbiAgICAgIHRoaXMuX2VuY3J5cHRlZFRhZ3MgPSBlbmNyeXB0ZWRUYWdzO1xuICAgICAgdGhpcy5lbmNyeXB0ZWRUYWdzTGVuZ3RoID0gdGhpcy5jb250ZW50Lmxlbmd0aDtcbiAgICAgIHRoaXMuY29udGVudCA9IEpTT04uc3RyaW5naWZ5KGVuY3J5cHRlZFRhZ3MpO1xuICAgICAgYXdhaXQgdGhpcy5lbmNyeXB0KHVzZXIpO1xuICAgIH1cbiAgICBpZiAocHVibGlzaCkge1xuICAgICAgcmV0dXJuIHRoaXMucHVibGlzaFJlcGxhY2VhYmxlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY3JlYXRlZF9hdCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDFlMyk7XG4gICAgfVxuICAgIHRoaXMuZW1pdChcImNoYW5nZVwiKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlcyBhbiBpdGVtIGZyb20gdGhlIGxpc3QuXG4gICAqXG4gICAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIGl0ZW0gdG8gcmVtb3ZlLlxuICAgKiBAcGFyYW0gZW5jcnlwdGVkIFdoZXRoZXIgdG8gcmVtb3ZlIGZyb20gdGhlIGVuY3J5cHRlZCBsaXN0IG9yIG5vdC5cbiAgICovXG4gIGFzeW5jIHJlbW92ZUl0ZW0oaW5kZXgsIGVuY3J5cHRlZCkge1xuICAgIGlmICghdGhpcy5uZGspIHRocm93IG5ldyBFcnJvcihcIk5ESyBpbnN0YW5jZSBub3Qgc2V0XCIpO1xuICAgIGlmICghdGhpcy5uZGsuc2lnbmVyKSB0aHJvdyBuZXcgRXJyb3IoXCJOREsgc2lnbmVyIG5vdCBzZXRcIik7XG4gICAgaWYgKGVuY3J5cHRlZCkge1xuICAgICAgY29uc3QgdXNlciA9IGF3YWl0IHRoaXMubmRrLnNpZ25lci51c2VyKCk7XG4gICAgICBjb25zdCBjdXJyZW50TGlzdCA9IGF3YWl0IHRoaXMuZW5jcnlwdGVkVGFncygpO1xuICAgICAgY3VycmVudExpc3Quc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIHRoaXMuX2VuY3J5cHRlZFRhZ3MgPSBjdXJyZW50TGlzdDtcbiAgICAgIHRoaXMuZW5jcnlwdGVkVGFnc0xlbmd0aCA9IHRoaXMuY29udGVudC5sZW5ndGg7XG4gICAgICB0aGlzLmNvbnRlbnQgPSBKU09OLnN0cmluZ2lmeShjdXJyZW50TGlzdCk7XG4gICAgICBhd2FpdCB0aGlzLmVuY3J5cHQodXNlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudGFncy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgICB0aGlzLmNyZWF0ZWRfYXQgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxZTMpO1xuICAgIHRoaXMuZW1pdChcImNoYW5nZVwiKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBoYXMoaXRlbSkge1xuICAgIHJldHVybiB0aGlzLml0ZW1zLnNvbWUoKHRhZykgPT4gdGFnWzFdID09PSBpdGVtKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIGZpbHRlciB0aGF0IHdpbGwgcmVzdWx0IGluIGZldGNoaW5nXG4gICAqIHRoZSBpdGVtcyBvZiB0aGlzIGxpc3RcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3QgbGlzdCA9IG5ldyBOREtMaXN0KC4uLik7XG4gICAqIGNvbnN0IGZpbHRlcnMgPSBsaXN0LmZpbHRlckZvckl0ZW1zKCk7XG4gICAqIGNvbnN0IGV2ZW50cyA9IGF3YWl0IG5kay5mZXRjaEV2ZW50cyhmaWx0ZXJzKTtcbiAgICovXG4gIGZpbHRlckZvckl0ZW1zKCkge1xuICAgIGNvbnN0IGlkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgY29uc3QgbmlwMzNRdWVyaWVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBjb25zdCBmaWx0ZXJzID0gW107XG4gICAgZm9yIChjb25zdCB0YWcgb2YgdGhpcy5pdGVtcykge1xuICAgICAgaWYgKHRhZ1swXSA9PT0gXCJlXCIgJiYgdGFnWzFdKSB7XG4gICAgICAgIGlkcy5hZGQodGFnWzFdKTtcbiAgICAgIH0gZWxzZSBpZiAodGFnWzBdID09PSBcImFcIiAmJiB0YWdbMV0pIHtcbiAgICAgICAgY29uc3QgW2tpbmQsIHB1YmtleSwgZFRhZ10gPSB0YWdbMV0uc3BsaXQoXCI6XCIpO1xuICAgICAgICBpZiAoIWtpbmQgfHwgIXB1YmtleSkgY29udGludWU7XG4gICAgICAgIGNvbnN0IGtleSA9IGAke2tpbmR9OiR7cHVia2V5fWA7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBuaXAzM1F1ZXJpZXMuZ2V0KGtleSkgfHwgW107XG4gICAgICAgIGl0ZW0ucHVzaChkVGFnIHx8IFwiXCIpO1xuICAgICAgICBuaXAzM1F1ZXJpZXMuc2V0KGtleSwgaXRlbSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpZHMuc2l6ZSA+IDApIHtcbiAgICAgIGZpbHRlcnMucHVzaCh7IGlkczogQXJyYXkuZnJvbShpZHMpIH0pO1xuICAgIH1cbiAgICBpZiAobmlwMzNRdWVyaWVzLnNpemUgPiAwKSB7XG4gICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlc10gb2YgbmlwMzNRdWVyaWVzLmVudHJpZXMoKSkge1xuICAgICAgICBjb25zdCBba2luZCwgcHVia2V5XSA9IGtleS5zcGxpdChcIjpcIik7XG4gICAgICAgIGZpbHRlcnMucHVzaCh7XG4gICAgICAgICAga2luZHM6IFtwYXJzZUludChraW5kKV0sXG4gICAgICAgICAgYXV0aG9yczogW3B1YmtleV0sXG4gICAgICAgICAgXCIjZFwiOiB2YWx1ZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmaWx0ZXJzO1xuICB9XG59O1xudmFyIGxpc3RzX2RlZmF1bHQgPSBOREtMaXN0O1xuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL251dHphcC9pbmRleC50c1xuaW1wb3J0IGRlYnVnMiBmcm9tIFwiZGVidWdcIjtcbnZhciBOREtOdXR6YXAgPSBjbGFzcyBfTkRLTnV0emFwIGV4dGVuZHMgTkRLRXZlbnQge1xuICBkZWJ1ZztcbiAgX3Byb29mcyA9IFtdO1xuICBzdGF0aWMga2luZCA9IDkzMjEgLyogTnV0emFwICovO1xuICBzdGF0aWMga2luZHMgPSBbX05ES051dHphcC5raW5kXTtcbiAgY29uc3RydWN0b3IobmRrLCBldmVudCkge1xuICAgIHN1cGVyKG5kaywgZXZlbnQpO1xuICAgIHRoaXMua2luZCA/Pz0gOTMyMSAvKiBOdXR6YXAgKi87XG4gICAgdGhpcy5kZWJ1ZyA9IG5kaz8uZGVidWcuZXh0ZW5kKFwibnV0emFwXCIpID8/IGRlYnVnMihcIm5kazpudXR6YXBcIik7XG4gICAgaWYgKCF0aGlzLmFsdCkgdGhpcy5hbHQgPSBcIlRoaXMgaXMgYSBudXR6YXBcIjtcbiAgfVxuICBzdGF0aWMgZnJvbShldmVudCkge1xuICAgIGNvbnN0IGUgPSBuZXcgdGhpcyhldmVudC5uZGssIGV2ZW50KTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcHJvb2ZUYWdzID0gZS5nZXRNYXRjaGluZ1RhZ3MoXCJwcm9vZlwiKTtcbiAgICAgIGlmIChwcm9vZlRhZ3MubGVuZ3RoKSB7XG4gICAgICAgIGUuX3Byb29mcyA9IHByb29mVGFncy5tYXAoKHRhZykgPT4gSlNPTi5wYXJzZSh0YWdbMV0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGUuX3Byb29mcyA9IEpTT04ucGFyc2UoZS5jb250ZW50KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFlLl9wcm9vZnMgfHwgIWUuX3Byb29mcy5sZW5ndGgpIHJldHVybjtcbiAgICByZXR1cm4gZTtcbiAgfVxuICBzZXQgY29tbWVudChjb21tZW50KSB7XG4gICAgdGhpcy5jb250ZW50ID0gY29tbWVudCA/PyBcIlwiO1xuICB9XG4gIGdldCBjb21tZW50KCkge1xuICAgIGNvbnN0IGMgPSB0aGlzLnRhZ1ZhbHVlKFwiY29tbWVudFwiKTtcbiAgICBpZiAoYykgcmV0dXJuIGM7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudDtcbiAgfVxuICBzZXQgcHJvb2ZzKHByb29mcykge1xuICAgIHRoaXMuX3Byb29mcyA9IHByb29mcztcbiAgICB0aGlzLnRhZ3MgPSB0aGlzLnRhZ3MuZmlsdGVyKCh0YWcpID0+IHRhZ1swXSAhPT0gXCJwcm9vZlwiKTtcbiAgICBmb3IgKGNvbnN0IHByb29mIG9mIHByb29mcykge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wicHJvb2ZcIiwgSlNPTi5zdHJpbmdpZnkocHJvb2YpXSk7XG4gICAgfVxuICB9XG4gIGdldCBwcm9vZnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Byb29mcztcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgcDJwayBwdWJrZXkgdGhhdCBpcyBlbWJlZGRlZCBpbiB0aGUgZmlyc3QgcHJvb2ZcbiAgICovXG4gIGdldCBwMnBrKCkge1xuICAgIGNvbnN0IGZpcnN0UHJvb2YgPSB0aGlzLnByb29mc1swXTtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc2VjcmV0ID0gSlNPTi5wYXJzZShmaXJzdFByb29mLnNlY3JldCk7XG4gICAgICBsZXQgcGF5bG9hZCA9IHt9O1xuICAgICAgaWYgKHR5cGVvZiBzZWNyZXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcGF5bG9hZCA9IEpTT04ucGFyc2Uoc2VjcmV0KTtcbiAgICAgICAgdGhpcy5kZWJ1ZyhcInN0cmluZ2lmaWVkIHBheWxvYWRcIiwgZmlyc3RQcm9vZi5zZWNyZXQpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc2VjcmV0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHBheWxvYWQgPSBzZWNyZXQ7XG4gICAgICB9XG4gICAgICBjb25zdCBpc1AyUEtMb2NrZWQgPSBwYXlsb2FkWzBdID09PSBcIlAyUEtcIiAmJiBwYXlsb2FkWzFdPy5kYXRhO1xuICAgICAgaWYgKGlzUDJQS0xvY2tlZCkge1xuICAgICAgICBjb25zdCBwYWRkZWRwMnBrID0gcGF5bG9hZFsxXS5kYXRhO1xuICAgICAgICBjb25zdCBwMnBrID0gcGFkZGVkcDJway5zbGljZSgyKTtcbiAgICAgICAgaWYgKHAycGspIHJldHVybiBwMnBrO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXMuZGVidWcoXCJlcnJvciBwYXJzaW5nIHAycGsgcHVia2V5XCIsIGUsIHRoaXMucHJvb2ZzWzBdKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgbWludCB3aGVyZSB0aGlzIG51dHphcCBwcm9vZnMgZXhpc3RcbiAgICovXG4gIGdldCBtaW50KCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwidVwiKTtcbiAgfVxuICBzZXQgbWludCh2YWx1ZSkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwidVwiKTtcbiAgICB0aGlzLnRhZyhbXCJ1XCIsIHZhbHVlXSk7XG4gIH1cbiAgZ2V0IHVuaXQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJ1bml0XCIpID8/IFwic2F0XCI7XG4gIH1cbiAgc2V0IHVuaXQodmFsdWUpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInVuaXRcIik7XG4gICAgaWYgKHZhbHVlKSB0aGlzLnRhZyhbXCJ1bml0XCIsIHZhbHVlXSk7XG4gIH1cbiAgZ2V0IGFtb3VudCgpIHtcbiAgICBjb25zdCBhbW91bnQgPSB0aGlzLnByb29mcy5yZWR1Y2UoKHRvdGFsLCBwcm9vZikgPT4gdG90YWwgKyBwcm9vZi5hbW91bnQsIDApO1xuICAgIGlmICh0aGlzLnVuaXQgPT09IFwibXNhdFwiKSByZXR1cm4gYW1vdW50ICogMWUzO1xuICAgIHJldHVybiBhbW91bnQ7XG4gIH1cbiAgc2VuZGVyID0gdGhpcy5hdXRob3I7XG4gIC8qKlxuICAgKiBTZXQgdGhlIHRhcmdldCBvZiB0aGUgbnV0emFwXG4gICAqIEBwYXJhbSB0YXJnZXQgVGhlIHRhcmdldCBvZiB0aGUgbnV0emFwIChhIHVzZXIgb3IgYW4gZXZlbnQpXG4gICAqL1xuICBzZXQgdGFyZ2V0KHRhcmdldCkge1xuICAgIHRoaXMudGFncyA9IHRoaXMudGFncy5maWx0ZXIoKHQpID0+IHRbMF0gIT09IFwicFwiKTtcbiAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgTkRLRXZlbnQpIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKHRhcmdldC50YWdSZWZlcmVuY2UoKSk7XG4gICAgfVxuICB9XG4gIHNldCByZWNpcGllbnRQdWJrZXkocHVia2V5KSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJwXCIpO1xuICAgIHRoaXMudGFnKFtcInBcIiwgcHVia2V5XSk7XG4gIH1cbiAgZ2V0IHJlY2lwaWVudFB1YmtleSgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcInBcIik7XG4gIH1cbiAgZ2V0IHJlY2lwaWVudCgpIHtcbiAgICBjb25zdCBwdWJrZXkgPSB0aGlzLnJlY2lwaWVudFB1YmtleTtcbiAgICBpZiAodGhpcy5uZGspIHJldHVybiB0aGlzLm5kay5nZXRVc2VyKHsgcHVia2V5IH0pO1xuICAgIHJldHVybiBuZXcgTkRLVXNlcih7IHB1YmtleSB9KTtcbiAgfVxuICBhc3luYyB0b05vc3RyRXZlbnQoKSB7XG4gICAgaWYgKHRoaXMudW5pdCA9PT0gXCJtc2F0XCIpIHtcbiAgICAgIHRoaXMudW5pdCA9IFwic2F0XCI7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlVGFnKFwiYW1vdW50XCIpO1xuICAgIHRoaXMudGFncy5wdXNoKFtcImFtb3VudFwiLCB0aGlzLmFtb3VudC50b1N0cmluZygpXSk7XG4gICAgY29uc3QgZXZlbnQgPSBhd2FpdCBzdXBlci50b05vc3RyRXZlbnQoKTtcbiAgICBldmVudC5jb250ZW50ID0gdGhpcy5jb21tZW50O1xuICAgIHJldHVybiBldmVudDtcbiAgfVxuICAvKipcbiAgICogVmFsaWRhdGVzIHRoYXQgdGhlIG51dHphcCBjb25mb3JtcyB0byBOSVAtNjFcbiAgICovXG4gIGdldCBpc1ZhbGlkKCkge1xuICAgIGxldCBlVGFnQ291bnQgPSAwO1xuICAgIGxldCBwVGFnQ291bnQgPSAwO1xuICAgIGxldCBtaW50VGFnQ291bnQgPSAwO1xuICAgIGZvciAoY29uc3QgdGFnIG9mIHRoaXMudGFncykge1xuICAgICAgaWYgKHRhZ1swXSA9PT0gXCJlXCIpIGVUYWdDb3VudCsrO1xuICAgICAgaWYgKHRhZ1swXSA9PT0gXCJwXCIpIHBUYWdDb3VudCsrO1xuICAgICAgaWYgKHRhZ1swXSA9PT0gXCJ1XCIpIG1pbnRUYWdDb3VudCsrO1xuICAgIH1cbiAgICByZXR1cm4gKFxuICAgICAgLy8gZXhhY3RseSBvbmUgcmVjaXBpZW50IGFuZCBtaW50XG4gICAgICBwVGFnQ291bnQgPT09IDEgJiYgbWludFRhZ0NvdW50ID09PSAxICYmIC8vIG11c3QgaGF2ZSBhdCBtb3N0IG9uZSBlIHRhZ1xuICAgICAgZVRhZ0NvdW50IDw9IDEgJiYgLy8gbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBwcm9vZlxuICAgICAgdGhpcy5wcm9vZnMubGVuZ3RoID4gMFxuICAgICk7XG4gIH1cbn07XG5mdW5jdGlvbiBwcm9vZlAycGsocHJvb2YpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBzZWNyZXQgPSBKU09OLnBhcnNlKHByb29mLnNlY3JldCk7XG4gICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICBpZiAodHlwZW9mIHNlY3JldCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcGF5bG9hZCA9IEpTT04ucGFyc2Uoc2VjcmV0KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZWNyZXQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHBheWxvYWQgPSBzZWNyZXQ7XG4gICAgfVxuICAgIGNvbnN0IGlzUDJQS0xvY2tlZCA9IHBheWxvYWRbMF0gPT09IFwiUDJQS1wiICYmIHBheWxvYWRbMV0/LmRhdGE7XG4gICAgaWYgKGlzUDJQS0xvY2tlZCkge1xuICAgICAgcmV0dXJuIHBheWxvYWRbMV0uZGF0YTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiZXJyb3IgcGFyc2luZyBwMnBrIHB1YmtleVwiLCBlLCBwcm9vZik7XG4gIH1cbn1cbmZ1bmN0aW9uIHByb29mUDJwa05vc3RyKHByb29mKSB7XG4gIGNvbnN0IHAycGsgPSBwcm9vZlAycGsocHJvb2YpO1xuICBpZiAoIXAycGspIHJldHVybjtcbiAgaWYgKHAycGsuc3RhcnRzV2l0aChcIjAyXCIpICYmIHAycGsubGVuZ3RoID09PSA2NikgcmV0dXJuIHAycGsuc2xpY2UoMik7XG4gIHJldHVybiBwMnBrO1xufVxuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL251dHphcC9taW50LWxpc3QudHNcbnZhciBOREtDYXNodU1pbnRMaXN0ID0gY2xhc3MgX05ES0Nhc2h1TWludExpc3QgZXh0ZW5kcyBOREtFdmVudCB7XG4gIHN0YXRpYyBraW5kID0gMTAwMTkgLyogQ2FzaHVNaW50TGlzdCAqLztcbiAgc3RhdGljIGtpbmRzID0gWzEwMDE5IC8qIENhc2h1TWludExpc3QgKi9dO1xuICBfcDJwaztcbiAgY29uc3RydWN0b3IobmRrLCBldmVudCkge1xuICAgIHN1cGVyKG5kaywgZXZlbnQpO1xuICAgIHRoaXMua2luZCA/Pz0gMTAwMTkgLyogQ2FzaHVNaW50TGlzdCAqLztcbiAgfVxuICBzdGF0aWMgZnJvbShldmVudCkge1xuICAgIHJldHVybiBuZXcgX05ES0Nhc2h1TWludExpc3QoZXZlbnQubmRrLCBldmVudCk7XG4gIH1cbiAgc2V0IHJlbGF5cyh1cmxzKSB7XG4gICAgdGhpcy50YWdzID0gdGhpcy50YWdzLmZpbHRlcigodCkgPT4gdFswXSAhPT0gXCJyZWxheVwiKTtcbiAgICBmb3IgKGNvbnN0IHVybCBvZiB1cmxzKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJyZWxheVwiLCB1cmxdKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHJlbGF5cygpIHtcbiAgICBjb25zdCByID0gW107XG4gICAgZm9yIChjb25zdCB0YWcgb2YgdGhpcy50YWdzKSB7XG4gICAgICBpZiAodGFnWzBdID09PSBcInJlbGF5XCIpIHtcbiAgICAgICAgci5wdXNoKHRhZ1sxXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG4gIHNldCBtaW50cyh1cmxzKSB7XG4gICAgdGhpcy50YWdzID0gdGhpcy50YWdzLmZpbHRlcigodCkgPT4gdFswXSAhPT0gXCJtaW50XCIpO1xuICAgIGZvciAoY29uc3QgdXJsIG9mIHVybHMpIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcIm1pbnRcIiwgdXJsXSk7XG4gICAgfVxuICB9XG4gIGdldCBtaW50cygpIHtcbiAgICBjb25zdCByID0gW107XG4gICAgZm9yIChjb25zdCB0YWcgb2YgdGhpcy50YWdzKSB7XG4gICAgICBpZiAodGFnWzBdID09PSBcIm1pbnRcIikge1xuICAgICAgICByLnB1c2godGFnWzFdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEFycmF5LmZyb20obmV3IFNldChyKSk7XG4gIH1cbiAgZ2V0IHAycGsoKSB7XG4gICAgaWYgKHRoaXMuX3AycGspIHtcbiAgICAgIHJldHVybiB0aGlzLl9wMnBrO1xuICAgIH1cbiAgICB0aGlzLl9wMnBrID0gdGhpcy50YWdWYWx1ZShcInB1YmtleVwiKSA/PyB0aGlzLnB1YmtleTtcbiAgICByZXR1cm4gdGhpcy5fcDJwaztcbiAgfVxuICBzZXQgcDJwayhwdWJrZXkpIHtcbiAgICB0aGlzLl9wMnBrID0gcHVia2V5O1xuICAgIHRoaXMucmVtb3ZlVGFnKFwicHVia2V5XCIpO1xuICAgIGlmIChwdWJrZXkpIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcInB1YmtleVwiLCBwdWJrZXldKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHJlbGF5U2V0KCkge1xuICAgIHJldHVybiBOREtSZWxheVNldC5mcm9tUmVsYXlVcmxzKHRoaXMucmVsYXlzLCB0aGlzLm5kayk7XG4gIH1cbn07XG5cbi8vIHNyYy9ldmVudHMva2luZHMvc2ltcGxlLWdyb3VwL21lbWJlci1saXN0LnRzXG52YXIgTkRLU2ltcGxlR3JvdXBNZW1iZXJMaXN0ID0gY2xhc3MgX05ES1NpbXBsZUdyb3VwTWVtYmVyTGlzdCBleHRlbmRzIE5ES0V2ZW50IHtcbiAgcmVsYXlTZXQ7XG4gIG1lbWJlclNldCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIHN0YXRpYyBraW5kID0gMzkwMDIgLyogR3JvdXBNZW1iZXJzICovO1xuICBzdGF0aWMga2luZHMgPSBbMzkwMDIgLyogR3JvdXBNZW1iZXJzICovXTtcbiAgY29uc3RydWN0b3IobmRrLCByYXdFdmVudCkge1xuICAgIHN1cGVyKG5kaywgcmF3RXZlbnQpO1xuICAgIHRoaXMua2luZCA/Pz0gMzkwMDIgLyogR3JvdXBNZW1iZXJzICovO1xuICAgIHRoaXMubWVtYmVyU2V0ID0gbmV3IFNldCh0aGlzLm1lbWJlcnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tKGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLU2ltcGxlR3JvdXBNZW1iZXJMaXN0KGV2ZW50Lm5kaywgZXZlbnQpO1xuICB9XG4gIGdldCBtZW1iZXJzKCkge1xuICAgIHJldHVybiB0aGlzLmdldE1hdGNoaW5nVGFncyhcInBcIikubWFwKCh0YWcpID0+IHRhZ1sxXSk7XG4gIH1cbiAgaGFzTWVtYmVyKG1lbWJlcikge1xuICAgIHJldHVybiB0aGlzLm1lbWJlclNldC5oYXMobWVtYmVyKTtcbiAgfVxuICBhc3luYyBwdWJsaXNoKHJlbGF5U2V0LCB0aW1lb3V0TXMsIHJlcXVpcmVkUmVsYXlDb3VudCkge1xuICAgIHJlbGF5U2V0ID8/PSB0aGlzLnJlbGF5U2V0O1xuICAgIHJldHVybiBzdXBlci5wdWJsaXNoUmVwbGFjZWFibGUocmVsYXlTZXQsIHRpbWVvdXRNcywgcmVxdWlyZWRSZWxheUNvdW50KTtcbiAgfVxufTtcblxuLy8gc3JjL2V2ZW50cy9raW5kcy9zaW1wbGUtZ3JvdXAvbWV0YWRhdGEudHNcbnZhciBOREtTaW1wbGVHcm91cE1ldGFkYXRhID0gY2xhc3MgX05ES1NpbXBsZUdyb3VwTWV0YWRhdGEgZXh0ZW5kcyBOREtFdmVudCB7XG4gIHN0YXRpYyBraW5kID0gMzllMyAvKiBHcm91cE1ldGFkYXRhICovO1xuICBzdGF0aWMga2luZHMgPSBbMzllMyAvKiBHcm91cE1ldGFkYXRhICovXTtcbiAgY29uc3RydWN0b3IobmRrLCByYXdFdmVudCkge1xuICAgIHN1cGVyKG5kaywgcmF3RXZlbnQpO1xuICAgIHRoaXMua2luZCA/Pz0gMzllMyAvKiBHcm91cE1ldGFkYXRhICovO1xuICB9XG4gIHN0YXRpYyBmcm9tKGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLU2ltcGxlR3JvdXBNZXRhZGF0YShldmVudC5uZGssIGV2ZW50KTtcbiAgfVxuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcIm5hbWVcIik7XG4gIH1cbiAgZ2V0IHBpY3R1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJwaWN0dXJlXCIpO1xuICB9XG4gIGdldCBhYm91dCgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcImFib3V0XCIpO1xuICB9XG4gIGdldCBzY29wZSgpIHtcbiAgICBpZiAodGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJwdWJsaWNcIikubGVuZ3RoID4gMCkgcmV0dXJuIFwicHVibGljXCI7XG4gICAgaWYgKHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwicHVibGljXCIpLmxlbmd0aCA+IDApIHJldHVybiBcInByaXZhdGVcIjtcbiAgfVxuICBzZXQgc2NvcGUoc2NvcGUpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInB1YmxpY1wiKTtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInByaXZhdGVcIik7XG4gICAgaWYgKHNjb3BlID09PSBcInB1YmxpY1wiKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJwdWJsaWNcIiwgXCJcIl0pO1xuICAgIH0gZWxzZSBpZiAoc2NvcGUgPT09IFwicHJpdmF0ZVwiKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJwcml2YXRlXCIsIFwiXCJdKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGFjY2VzcygpIHtcbiAgICBpZiAodGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJvcGVuXCIpLmxlbmd0aCA+IDApIHJldHVybiBcIm9wZW5cIjtcbiAgICBpZiAodGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJjbG9zZWRcIikubGVuZ3RoID4gMCkgcmV0dXJuIFwiY2xvc2VkXCI7XG4gIH1cbiAgc2V0IGFjY2VzcyhhY2Nlc3MpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcIm9wZW5cIik7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJjbG9zZWRcIik7XG4gICAgaWYgKGFjY2VzcyA9PT0gXCJvcGVuXCIpIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcIm9wZW5cIiwgXCJcIl0pO1xuICAgIH0gZWxzZSBpZiAoYWNjZXNzID09PSBcImNsb3NlZFwiKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJjbG9zZWRcIiwgXCJcIl0pO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2V2ZW50cy9raW5kcy9zdWJzY3JpcHRpb25zL2Ftb3VudC50c1xudmFyIHBvc3NpYmxlSW50ZXJ2YWxGcmVxdWVuY2llcyA9IFtcbiAgXCJkYWlseVwiLFxuICBcIndlZWtseVwiLFxuICBcIm1vbnRobHlcIixcbiAgXCJxdWFydGVybHlcIixcbiAgXCJ5ZWFybHlcIlxuXTtcbmZ1bmN0aW9uIGNhbGN1bGF0ZVRlcm1EdXJhdGlvbkluU2Vjb25kcyh0ZXJtKSB7XG4gIHN3aXRjaCAodGVybSkge1xuICAgIGNhc2UgXCJkYWlseVwiOlxuICAgICAgcmV0dXJuIDI0ICogNjAgKiA2MDtcbiAgICBjYXNlIFwid2Vla2x5XCI6XG4gICAgICByZXR1cm4gNyAqIDI0ICogNjAgKiA2MDtcbiAgICBjYXNlIFwibW9udGhseVwiOlxuICAgICAgcmV0dXJuIDMwICogMjQgKiA2MCAqIDYwO1xuICAgIGNhc2UgXCJxdWFydGVybHlcIjpcbiAgICAgIHJldHVybiAzICogMzAgKiAyNCAqIDYwICogNjA7XG4gICAgY2FzZSBcInllYXJseVwiOlxuICAgICAgcmV0dXJuIDM2NSAqIDI0ICogNjAgKiA2MDtcbiAgfVxufVxuZnVuY3Rpb24gbmV3QW1vdW50KGFtb3VudCwgY3VycmVuY3ksIHRlcm0pIHtcbiAgcmV0dXJuIFtcImFtb3VudFwiLCBhbW91bnQudG9TdHJpbmcoKSwgY3VycmVuY3ksIHRlcm1dO1xufVxuZnVuY3Rpb24gcGFyc2VUYWdUb1N1YnNjcmlwdGlvbkFtb3VudCh0YWcpIHtcbiAgY29uc3QgYW1vdW50ID0gcGFyc2VJbnQodGFnWzFdKTtcbiAgaWYgKGlzTmFOKGFtb3VudCkgfHwgYW1vdW50ID09PSB2b2lkIDAgfHwgYW1vdW50ID09PSBudWxsIHx8IGFtb3VudCA8PSAwKSByZXR1cm4gdm9pZCAwO1xuICBjb25zdCBjdXJyZW5jeSA9IHRhZ1syXTtcbiAgaWYgKGN1cnJlbmN5ID09PSB2b2lkIDAgfHwgY3VycmVuY3kgPT09IFwiXCIpIHJldHVybiB2b2lkIDA7XG4gIGNvbnN0IHRlcm0gPSB0YWdbM107XG4gIGlmICh0ZXJtID09PSB2b2lkIDApIHJldHVybiB2b2lkIDA7XG4gIGlmICghcG9zc2libGVJbnRlcnZhbEZyZXF1ZW5jaWVzLmluY2x1ZGVzKHRlcm0pKSByZXR1cm4gdm9pZCAwO1xuICByZXR1cm4ge1xuICAgIGFtb3VudCxcbiAgICBjdXJyZW5jeSxcbiAgICB0ZXJtXG4gIH07XG59XG5cbi8vIHNyYy9ldmVudHMva2luZHMvc3Vic2NyaXB0aW9ucy90aWVyLnRzXG52YXIgTkRLU3Vic2NyaXB0aW9uVGllciA9IGNsYXNzIF9OREtTdWJzY3JpcHRpb25UaWVyIGV4dGVuZHMgTkRLQXJ0aWNsZSB7XG4gIHN0YXRpYyBraW5kID0gMzcwMDEgLyogU3Vic2NyaXB0aW9uVGllciAqLztcbiAgc3RhdGljIGtpbmRzID0gWzM3MDAxIC8qIFN1YnNjcmlwdGlvblRpZXIgKi9dO1xuICBjb25zdHJ1Y3RvcihuZGssIHJhd0V2ZW50KSB7XG4gICAgY29uc3QgayA9IHJhd0V2ZW50Py5raW5kID8/IDM3MDAxIC8qIFN1YnNjcmlwdGlvblRpZXIgKi87XG4gICAgc3VwZXIobmRrLCByYXdFdmVudCk7XG4gICAgdGhpcy5raW5kID0gaztcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBOREtTdWJzY3JpcHRpb25UaWVyIGZyb20gYW4gZXZlbnRcbiAgICogQHBhcmFtIGV2ZW50XG4gICAqIEByZXR1cm5zIE5ES1N1YnNjcmlwdGlvblRpZXJcbiAgICovXG4gIHN0YXRpYyBmcm9tKGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLU3Vic2NyaXB0aW9uVGllcihldmVudC5uZGssIGV2ZW50KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBwZXJrcyBmb3IgdGhpcyB0aWVyXG4gICAqL1xuICBnZXQgcGVya3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwicGVya1wiKS5tYXAoKHRhZykgPT4gdGFnWzFdKS5maWx0ZXIoKHBlcmspID0+IHBlcmsgIT09IHZvaWQgMCk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYSBwZXJrIHRvIHRoaXMgdGllclxuICAgKi9cbiAgYWRkUGVyayhwZXJrKSB7XG4gICAgdGhpcy50YWdzLnB1c2goW1wicGVya1wiLCBwZXJrXSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFtb3VudCBmb3IgdGhpcyB0aWVyXG4gICAqL1xuICBnZXQgYW1vdW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJhbW91bnRcIikubWFwKCh0YWcpID0+IHBhcnNlVGFnVG9TdWJzY3JpcHRpb25BbW91bnQodGFnKSkuZmlsdGVyKChhKSA9PiBhICE9PSB2b2lkIDApO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGFuIGFtb3VudCB0byB0aGlzIHRpZXJcbiAgICogQHBhcmFtIGFtb3VudCBBbW91bnQgaW4gdGhlIHNtYWxsZXN0IHVuaXQgb2YgdGhlIGN1cnJlbmN5IChlLmcuIGNlbnRzLCBtc2F0cylcbiAgICogQHBhcmFtIGN1cnJlbmN5IEN1cnJlbmN5IGNvZGUuIFVzZSBtc2F0IGZvciBtaWxsaXNhdG9zaGlzXG4gICAqIEBwYXJhbSB0ZXJtIE9uZSBvZiBkYWlseSwgd2Vla2x5LCBtb250aGx5LCBxdWFydGVybHksIHllYXJseVxuICAgKi9cbiAgYWRkQW1vdW50KGFtb3VudCwgY3VycmVuY3ksIHRlcm0pIHtcbiAgICB0aGlzLnRhZ3MucHVzaChuZXdBbW91bnQoYW1vdW50LCBjdXJyZW5jeSwgdGVybSkpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIGEgcmVsYXkgd2hlcmUgY29udGVudCByZWxhdGVkIHRvIHRoaXMgdGllciBjYW4gYmUgZm91bmRcbiAgICogQHBhcmFtIHJlbGF5VXJsIFVSTCBvZiB0aGUgcmVsYXlcbiAgICovXG4gIHNldCByZWxheVVybChyZWxheVVybCkge1xuICAgIHRoaXMudGFncy5wdXNoKFtcInJcIiwgcmVsYXlVcmxdKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVsYXkgVVJMcyBmb3IgdGhpcyB0aWVyXG4gICAqL1xuICBnZXQgcmVsYXlVcmxzKCkge1xuICAgIHJldHVybiB0aGlzLmdldE1hdGNoaW5nVGFncyhcInJcIikubWFwKCh0YWcpID0+IHRhZ1sxXSkuZmlsdGVyKChyZWxheSkgPT4gcmVsYXkgIT09IHZvaWQgMCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIHZlcmlmaWVyIHB1YmtleSBmb3IgdGhpcyB0aWVyLiBUaGlzIGlzIHRoZSBwdWJrZXkgdGhhdCB3aWxsIGdlbmVyYXRlXG4gICAqIHN1YnNjcmlwdGlvbiBwYXltZW50IHJlY2VpcHRzXG4gICAqL1xuICBnZXQgdmVyaWZpZXJQdWJrZXkoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJwXCIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSB2ZXJpZmllciBwdWJrZXkgZm9yIHRoaXMgdGllci5cbiAgICovXG4gIHNldCB2ZXJpZmllclB1YmtleShwdWJrZXkpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInBcIik7XG4gICAgaWYgKHB1YmtleSkgdGhpcy50YWdzLnB1c2goW1wicFwiLCBwdWJrZXldKTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoaXMgdGllciBpcyB2YWxpZFxuICAgKi9cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGl0bGUgIT09IHZvaWQgMCAmJiAvLyBNdXN0IGhhdmUgYSB0aXRsZVxuICAgIHRoaXMuYW1vdW50cy5sZW5ndGggPiAwO1xuICB9XG59O1xuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL3ZpZGVvLnRzXG52YXIgTkRLVmlkZW8gPSBjbGFzcyBfTkRLVmlkZW8gZXh0ZW5kcyBOREtFdmVudCB7XG4gIHN0YXRpYyBraW5kID0gMzQyMzUgLyogSG9yaXpvbnRhbFZpZGVvICovO1xuICBzdGF0aWMga2luZHMgPSBbMzQyMzUgLyogSG9yaXpvbnRhbFZpZGVvICovLCAzNDIzNiAvKiBWZXJ0aWNhbFZpZGVvICovXTtcbiAgX2ltZXRhcztcbiAgY29uc3RydWN0b3IobmRrLCByYXdFdmVudCkge1xuICAgIHN1cGVyKG5kaywgcmF3RXZlbnQpO1xuICAgIHRoaXMua2luZCA/Pz0gMzQyMzUgLyogSG9yaXpvbnRhbFZpZGVvICovO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgTkRLQXJ0aWNsZSBmcm9tIGFuIGV4aXN0aW5nIE5ES0V2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQgTkRLRXZlbnQgdG8gY3JlYXRlIHRoZSBOREtBcnRpY2xlIGZyb20uXG4gICAqIEByZXR1cm5zIE5ES0FydGljbGVcbiAgICovXG4gIHN0YXRpYyBmcm9tKGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLVmlkZW8oZXZlbnQubmRrLCBldmVudC5yYXdFdmVudCgpKTtcbiAgfVxuICAvKipcbiAgICogR2V0dGVyIGZvciB0aGUgYXJ0aWNsZSB0aXRsZS5cbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZyB8IHVuZGVmaW5lZH0gLSBUaGUgYXJ0aWNsZSB0aXRsZSBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSB1bmRlZmluZWQuXG4gICAqL1xuICBnZXQgdGl0bGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJ0aXRsZVwiKTtcbiAgfVxuICAvKipcbiAgICogU2V0dGVyIGZvciB0aGUgYXJ0aWNsZSB0aXRsZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IHRpdGxlIC0gVGhlIHRpdGxlIHRvIHNldCBmb3IgdGhlIGFydGljbGUuXG4gICAqL1xuICBzZXQgdGl0bGUodGl0bGUpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInRpdGxlXCIpO1xuICAgIGlmICh0aXRsZSkgdGhpcy50YWdzLnB1c2goW1widGl0bGVcIiwgdGl0bGVdKTtcbiAgfVxuICAvKipcbiAgICogR2V0dGVyIGZvciB0aGUgYXJ0aWNsZSB0aHVtYm5haWwuXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmcgfCB1bmRlZmluZWR9IC0gVGhlIGFydGljbGUgdGh1bWJuYWlsIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIHVuZGVmaW5lZC5cbiAgICovXG4gIGdldCB0aHVtYm5haWwoKSB7XG4gICAgbGV0IHRodW1ibmFpbDtcbiAgICBpZiAodGhpcy5pbWV0YXMgJiYgdGhpcy5pbWV0YXMubGVuZ3RoID4gMCkge1xuICAgICAgdGh1bWJuYWlsID0gdGhpcy5pbWV0YXNbMF0uaW1hZ2U/LlswXTtcbiAgICB9XG4gICAgcmV0dXJuIHRodW1ibmFpbCA/PyB0aGlzLnRhZ1ZhbHVlKFwidGh1bWJcIik7XG4gIH1cbiAgZ2V0IGltZXRhcygpIHtcbiAgICBpZiAodGhpcy5faW1ldGFzKSByZXR1cm4gdGhpcy5faW1ldGFzO1xuICAgIHRoaXMuX2ltZXRhcyA9IHRoaXMudGFncy5maWx0ZXIoKHRhZykgPT4gdGFnWzBdID09PSBcImltZXRhXCIpLm1hcChtYXBJbWV0YVRhZyk7XG4gICAgcmV0dXJuIHRoaXMuX2ltZXRhcztcbiAgfVxuICBzZXQgaW1ldGFzKHRhZ3MpIHtcbiAgICB0aGlzLl9pbWV0YXMgPSB0YWdzO1xuICAgIHRoaXMudGFncyA9IHRoaXMudGFncy5maWx0ZXIoKHRhZykgPT4gdGFnWzBdICE9PSBcImltZXRhXCIpO1xuICAgIHRoaXMudGFncy5wdXNoKC4uLnRhZ3MubWFwKGltZXRhVGFnVG9UYWcpKTtcbiAgfVxuICBnZXQgdXJsKCkge1xuICAgIGlmICh0aGlzLmltZXRhcyAmJiB0aGlzLmltZXRhcy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbWV0YXNbMF0udXJsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcInVybFwiKTtcbiAgfVxuICAvKipcbiAgICogR2V0dGVyIGZvciB0aGUgYXJ0aWNsZSdzIHB1YmxpY2F0aW9uIHRpbWVzdGFtcC5cbiAgICpcbiAgICogQHJldHVybnMge251bWJlciB8IHVuZGVmaW5lZH0gLSBUaGUgVW5peCB0aW1lc3RhbXAgb2Ygd2hlbiB0aGUgYXJ0aWNsZSB3YXMgcHVibGlzaGVkIG9yIHVuZGVmaW5lZC5cbiAgICovXG4gIGdldCBwdWJsaXNoZWRfYXQoKSB7XG4gICAgY29uc3QgdGFnID0gdGhpcy50YWdWYWx1ZShcInB1Ymxpc2hlZF9hdFwiKTtcbiAgICBpZiAodGFnKSB7XG4gICAgICByZXR1cm4gcGFyc2VJbnQodGFnKTtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICAvKipcbiAgICogU2V0dGVyIGZvciB0aGUgYXJ0aWNsZSdzIHB1YmxpY2F0aW9uIHRpbWVzdGFtcC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXIgfCB1bmRlZmluZWR9IHRpbWVzdGFtcCAtIFRoZSBVbml4IHRpbWVzdGFtcCB0byBzZXQgZm9yIHRoZSBhcnRpY2xlJ3MgcHVibGljYXRpb24gZGF0ZS5cbiAgICovXG4gIHNldCBwdWJsaXNoZWRfYXQodGltZXN0YW1wKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJwdWJsaXNoZWRfYXRcIik7XG4gICAgaWYgKHRpbWVzdGFtcCAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJwdWJsaXNoZWRfYXRcIiwgdGltZXN0YW1wLnRvU3RyaW5nKCldKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBjb250ZW50IHRhZ3MgZm9yIHRoZSBhcnRpY2xlLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBmaXJzdCBjaGVja3MgYW5kIHNldHMgdGhlIHB1YmxpY2F0aW9uIGRhdGUgaWYgbm90IGF2YWlsYWJsZSxcbiAgICogYW5kIHRoZW4gZ2VuZXJhdGVzIGNvbnRlbnQgdGFncyBiYXNlZCBvbiB0aGUgYmFzZSBOREtFdmVudCBjbGFzcy5cbiAgICpcbiAgICogQHJldHVybnMge0NvbnRlbnRUYWd9IC0gVGhlIGdlbmVyYXRlZCBjb250ZW50IHRhZ3MuXG4gICAqL1xuICBhc3luYyBnZW5lcmF0ZVRhZ3MoKSB7XG4gICAgc3VwZXIuZ2VuZXJhdGVUYWdzKCk7XG4gICAgaWYgKCF0aGlzLnB1Ymxpc2hlZF9hdCkge1xuICAgICAgdGhpcy5wdWJsaXNoZWRfYXQgPSB0aGlzLmNyZWF0ZWRfYXQ7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5nZW5lcmF0ZVRhZ3MoKTtcbiAgfVxuICBnZXQgZHVyYXRpb24oKSB7XG4gICAgY29uc3QgdGFnID0gdGhpcy50YWdWYWx1ZShcImR1cmF0aW9uXCIpO1xuICAgIGlmICh0YWcpIHtcbiAgICAgIHJldHVybiBwYXJzZUludCh0YWcpO1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIC8qKlxuICAgKiBTZXR0ZXIgZm9yIHRoZSB2aWRlbydzIGR1cmF0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgdW5kZWZpbmVkfSBkdXJhdGlvbiAtIFRoZSBkdXJhdGlvbiB0byBzZXQgZm9yIHRoZSB2aWRlbyAoaW4gc2Vjb25kcylcbiAgICovXG4gIHNldCBkdXJhdGlvbihkdXIpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImR1cmF0aW9uXCIpO1xuICAgIGlmIChkdXIgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wiZHVyYXRpb25cIiwgTWF0aC5mbG9vcihkdXIpLnRvU3RyaW5nKCldKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9ldmVudHMva2luZHMvd2lraS50c1xudmFyIE5ES1dpa2kgPSBjbGFzcyBleHRlbmRzIE5ES0FydGljbGUge1xuICBzdGF0aWMga2luZCA9IDMwODE4IC8qIFdpa2kgKi87XG4gIHN0YXRpYyBraW5kcyA9IFszMDgxOCAvKiBXaWtpICovXTtcbn07XG5cbi8vIHNyYy9ldmVudHMvd3JhcC50c1xuZnVuY3Rpb24gd3JhcEV2ZW50KGV2ZW50KSB7XG4gIGNvbnN0IGV2ZW50V3JhcHBpbmdNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBbXG4gICAgTkRLSW1hZ2UsXG4gICAgTkRLVmlkZW8sXG4gICAgTkRLQ2FzaHVNaW50TGlzdCxcbiAgICBOREtBcnRpY2xlLFxuICAgIE5ES0hpZ2hsaWdodCxcbiAgICBOREtXaWtpLFxuICAgIE5ES051dHphcCxcbiAgICBOREtTaW1wbGVHcm91cE1lbWJlckxpc3QsXG4gICAgTkRLU2ltcGxlR3JvdXBNZXRhZGF0YSxcbiAgICBOREtTdWJzY3JpcHRpb25UaWVyLFxuICAgIE5ES0Nhc2h1VG9rZW4sXG4gICAgTkRLTGlzdFxuICBdLmZvckVhY2goKGtsYXNzMikgPT4ge1xuICAgIGtsYXNzMi5raW5kcy5mb3JFYWNoKChraW5kKSA9PiB7XG4gICAgICBldmVudFdyYXBwaW5nTWFwLnNldChraW5kLCBrbGFzczIpO1xuICAgIH0pO1xuICB9KTtcbiAgY29uc3Qga2xhc3MgPSBldmVudFdyYXBwaW5nTWFwLmdldChldmVudC5raW5kKTtcbiAgaWYgKGtsYXNzKSByZXR1cm4ga2xhc3MuZnJvbShldmVudCk7XG4gIHJldHVybiBldmVudDtcbn1cblxuLy8gc3JjL3N1YnNjcmlwdGlvbi9pbmRleC50c1xudmFyIE5ES1N1YnNjcmlwdGlvbkNhY2hlVXNhZ2UgPSAvKiBAX19QVVJFX18gKi8gKChOREtTdWJzY3JpcHRpb25DYWNoZVVzYWdlMikgPT4ge1xuICBOREtTdWJzY3JpcHRpb25DYWNoZVVzYWdlMltcIk9OTFlfQ0FDSEVcIl0gPSBcIk9OTFlfQ0FDSEVcIjtcbiAgTkRLU3Vic2NyaXB0aW9uQ2FjaGVVc2FnZTJbXCJDQUNIRV9GSVJTVFwiXSA9IFwiQ0FDSEVfRklSU1RcIjtcbiAgTkRLU3Vic2NyaXB0aW9uQ2FjaGVVc2FnZTJbXCJQQVJBTExFTFwiXSA9IFwiUEFSQUxMRUxcIjtcbiAgTkRLU3Vic2NyaXB0aW9uQ2FjaGVVc2FnZTJbXCJPTkxZX1JFTEFZXCJdID0gXCJPTkxZX1JFTEFZXCI7XG4gIHJldHVybiBOREtTdWJzY3JpcHRpb25DYWNoZVVzYWdlMjtcbn0pKE5ES1N1YnNjcmlwdGlvbkNhY2hlVXNhZ2UgfHwge30pO1xudmFyIGRlZmF1bHRPcHRzID0ge1xuICBjbG9zZU9uRW9zZTogZmFsc2UsXG4gIGNhY2hlVXNhZ2U6IFwiQ0FDSEVfRklSU1RcIiAvKiBDQUNIRV9GSVJTVCAqLyxcbiAgZG9udFNhdmVUb0NhY2hlOiBmYWxzZSxcbiAgZ3JvdXBhYmxlOiB0cnVlLFxuICBncm91cGFibGVEZWxheTogMTAwLFxuICBncm91cGFibGVEZWxheVR5cGU6IFwiYXQtbW9zdFwiLFxuICBjYWNoZVVuY29uc3RyYWluRmlsdGVyOiBbXCJsaW1pdFwiLCBcInNpbmNlXCIsIFwidW50aWxcIl1cbn07XG52YXIgTkRLU3Vic2NyaXB0aW9uID0gY2xhc3MgZXh0ZW5kcyBFdmVudEVtaXR0ZXI0IHtcbiAgc3ViSWQ7XG4gIGZpbHRlcnM7XG4gIG9wdHM7XG4gIHBvb2w7XG4gIHNraXBWZXJpZmljYXRpb24gPSBmYWxzZTtcbiAgc2tpcFZhbGlkYXRpb24gPSBmYWxzZTtcbiAgLyoqXG4gICAqIFRyYWNrcyB0aGUgZmlsdGVycyBhcyB0aGV5IGFyZSBleGVjdXRlZCBvbiBlYWNoIHJlbGF5XG4gICAqL1xuICByZWxheUZpbHRlcnM7XG4gIHJlbGF5U2V0O1xuICBuZGs7XG4gIGRlYnVnO1xuICAvKipcbiAgICogRXZlbnRzIHRoYXQgaGF2ZSBiZWVuIHNlZW4gYnkgdGhlIHN1YnNjcmlwdGlvbiwgd2l0aCB0aGUgdGltZSB0aGV5IHdlcmUgZmlyc3Qgc2Vlbi5cbiAgICovXG4gIGV2ZW50Rmlyc3RTZWVuID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgLyoqXG4gICAqIFJlbGF5cyB0aGF0IGhhdmUgc2VudCBhbiBFT1NFLlxuICAgKi9cbiAgZW9zZXNTZWVuID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgLyoqXG4gICAqIFRoZSB0aW1lIHRoZSBsYXN0IGV2ZW50IHdhcyByZWNlaXZlZCBieSB0aGUgc3Vic2NyaXB0aW9uLlxuICAgKiBUaGlzIGlzIHVzZWQgdG8gY2FsY3VsYXRlIHdoZW4gRU9TRSBzaG91bGQgYmUgZW1pdHRlZC5cbiAgICovXG4gIGxhc3RFdmVudFJlY2VpdmVkQXQ7XG4gIGludGVybmFsSWQ7XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBzdWJzY3JpcHRpb24gc2hvdWxkIGNsb3NlIHdoZW4gYWxsIHJlbGF5cyBoYXZlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgZXZlbnQgc3RyZWFtLlxuICAgKi9cbiAgY2xvc2VPbkVvc2U7XG4gIC8qKlxuICAgKiBQb29sIG1vbml0b3IgY2FsbGJhY2tcbiAgICovXG4gIHBvb2xNb25pdG9yO1xuICBza2lwT3B0aW1pc3RpY1B1Ymxpc2hFdmVudCA9IGZhbHNlO1xuICAvKipcbiAgICogRmlsdGVycyB0byByZW1vdmUgd2hlbiBxdWVyeWluZyB0aGUgY2FjaGUuXG4gICAqL1xuICBjYWNoZVVuY29uc3RyYWluRmlsdGVyO1xuICBjb25zdHJ1Y3RvcihuZGssIGZpbHRlcnMsIG9wdHMsIHJlbGF5U2V0LCBzdWJJZCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5uZGsgPSBuZGs7XG4gICAgdGhpcy5wb29sID0gb3B0cz8ucG9vbCB8fCBuZGsucG9vbDtcbiAgICB0aGlzLm9wdHMgPSB7IC4uLmRlZmF1bHRPcHRzLCAuLi5vcHRzIHx8IHt9IH07XG4gICAgdGhpcy5maWx0ZXJzID0gZmlsdGVycyBpbnN0YW5jZW9mIEFycmF5ID8gZmlsdGVycyA6IFtmaWx0ZXJzXTtcbiAgICB0aGlzLnN1YklkID0gc3ViSWQgfHwgdGhpcy5vcHRzLnN1YklkO1xuICAgIHRoaXMuaW50ZXJuYWxJZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZyg3KTtcbiAgICB0aGlzLnJlbGF5U2V0ID0gcmVsYXlTZXQ7XG4gICAgdGhpcy5kZWJ1ZyA9IG5kay5kZWJ1Zy5leHRlbmQoYHN1YnNjcmlwdGlvblske3RoaXMub3B0cy5zdWJJZCA/PyB0aGlzLmludGVybmFsSWR9XWApO1xuICAgIHRoaXMuc2tpcFZlcmlmaWNhdGlvbiA9IHRoaXMub3B0cy5za2lwVmVyaWZpY2F0aW9uIHx8IGZhbHNlO1xuICAgIHRoaXMuc2tpcFZhbGlkYXRpb24gPSB0aGlzLm9wdHMuc2tpcFZhbGlkYXRpb24gfHwgZmFsc2U7XG4gICAgdGhpcy5jbG9zZU9uRW9zZSA9IHRoaXMub3B0cy5jbG9zZU9uRW9zZSB8fCBmYWxzZTtcbiAgICB0aGlzLnNraXBPcHRpbWlzdGljUHVibGlzaEV2ZW50ID0gdGhpcy5vcHRzLnNraXBPcHRpbWlzdGljUHVibGlzaEV2ZW50IHx8IGZhbHNlO1xuICAgIHRoaXMuY2FjaGVVbmNvbnN0cmFpbkZpbHRlciA9IHRoaXMub3B0cy5jYWNoZVVuY29uc3RyYWluRmlsdGVyO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByZWxheXMgdGhhdCBoYXZlIG5vdCB5ZXQgc2VudCBhbiBFT1NFLlxuICAgKi9cbiAgcmVsYXlzTWlzc2luZ0Vvc2UoKSB7XG4gICAgaWYgKCF0aGlzLnJlbGF5RmlsdGVycykgcmV0dXJuIFtdO1xuICAgIGNvbnN0IHJlbGF5c01pc3NpbmdFb3NlID0gQXJyYXkuZnJvbSh0aGlzLnJlbGF5RmlsdGVycy5rZXlzKCkpLmZpbHRlcihcbiAgICAgICh1cmwpID0+ICF0aGlzLmVvc2VzU2Vlbi5oYXModGhpcy5wb29sLmdldFJlbGF5KHVybCwgZmFsc2UsIGZhbHNlKSlcbiAgICApO1xuICAgIHJldHVybiByZWxheXNNaXNzaW5nRW9zZTtcbiAgfVxuICAvKipcbiAgICogUHJvdmlkZXMgYWNjZXNzIHRvIHRoZSBmaXJzdCBmaWx0ZXIgb2YgdGhlIHN1YnNjcmlwdGlvbiBmb3JcbiAgICogYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gICAqL1xuICBnZXQgZmlsdGVyKCkge1xuICAgIHJldHVybiB0aGlzLmZpbHRlcnNbMF07XG4gIH1cbiAgZ2V0IGdyb3VwYWJsZURlbGF5KCkge1xuICAgIGlmICghdGhpcy5pc0dyb3VwYWJsZSgpKSByZXR1cm4gdm9pZCAwO1xuICAgIHJldHVybiB0aGlzLm9wdHM/Lmdyb3VwYWJsZURlbGF5O1xuICB9XG4gIGdldCBncm91cGFibGVEZWxheVR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0cz8uZ3JvdXBhYmxlRGVsYXlUeXBlIHx8IFwiYXQtbW9zdFwiO1xuICB9XG4gIGlzR3JvdXBhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLm9wdHM/Lmdyb3VwYWJsZSB8fCBmYWxzZTtcbiAgfVxuICBzaG91bGRRdWVyeUNhY2hlKCkge1xuICAgIGlmICh0aGlzLm9wdHM/LmNhY2hlVXNhZ2UgPT09IFwiT05MWV9SRUxBWVwiIC8qIE9OTFlfUkVMQVkgKi8pIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBoYXNOb25FcGhlbWVyYWxLaW5kID0gdGhpcy5maWx0ZXJzLnNvbWUoKGYpID0+IGYua2luZHM/LnNvbWUoKGspID0+IGtpbmRJc0VwaGVtZXJhbChrKSkpO1xuICAgIGlmIChoYXNOb25FcGhlbWVyYWxLaW5kKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBzaG91bGRRdWVyeVJlbGF5cygpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRzPy5jYWNoZVVzYWdlICE9PSBcIk9OTFlfQ0FDSEVcIiAvKiBPTkxZX0NBQ0hFICovO1xuICB9XG4gIHNob3VsZFdhaXRGb3JDYWNoZSgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgLy8gTXVzdCB3YW50IHRvIGNsb3NlIG9uIEVPU0U7IHN1YnNjcmlwdGlvbnNcbiAgICAgIC8vIHRoYXQgd2FudCB0byByZWNlaXZlIGZ1cnRoZXIgdXBkYXRlcyBtdXN0XG4gICAgICAvLyBhbHdheXMgaGl0IHRoZSByZWxheVxuICAgICAgdGhpcy5vcHRzLmNsb3NlT25Fb3NlICYmIC8vIENhY2hlIGFkYXB0ZXIgbXVzdCBjbGFpbSB0byBiZSBmYXN0XG4gICAgICAhIXRoaXMubmRrLmNhY2hlQWRhcHRlcj8ubG9ja2luZyAmJiAvLyBJZiBleHBsaWNpdGx5IHRvbGQgdG8gcnVuIGluIHBhcmFsbGVsLCB0aGVuXG4gICAgICAvLyB3ZSBzaG91bGQgbm90IHdhaXQgZm9yIHRoZSBjYWNoZVxuICAgICAgdGhpcy5vcHRzLmNhY2hlVXNhZ2UgIT09IFwiUEFSQUxMRUxcIiAvKiBQQVJBTExFTCAqL1xuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIFN0YXJ0IHRoZSBzdWJzY3JpcHRpb24uIFRoaXMgaXMgdGhlIG1haW4gbWV0aG9kIHRoYXQgc2hvdWxkIGJlIGNhbGxlZFxuICAgKiBhZnRlciBjcmVhdGluZyBhIHN1YnNjcmlwdGlvbi5cbiAgICogXG4gICAqIEBwYXJhbSBlbWl0Q2FjaGVkRXZlbnRzIC0gV2hldGhlciB0byBlbWl0IGV2ZW50cyBjb21pbmcgZnJvbSBhIHN5bmNocm9ub3VzIGNhY2hlXG4gICAqIFxuICAgKiBXaGVuIHVzaW5nIGEgc3luY2hyb25vdXMgY2FjaGUsIHRoZSBldmVudHMgd2lsbCBiZSByZXR1cm5lZCBpbW1lZGlhdGVseVxuICAgKiBieSB0aGlzIGZ1bmN0aW9uLiBJZiB5b3Ugd2lsbCB1c2UgdGhvc2UgcmV0dXJuZWQgZXZlbnRzLCB5b3Ugc2hvdWxkXG4gICAqIHNldCBlbWl0Q2FjaGVkRXZlbnRzIHRvIGZhbHNlIHRvIHByZXZlbnQgc2VlaW5nIHRoZW0gYXMgZHVwbGljYXRlIGV2ZW50cy5cbiAgICovXG4gIHN0YXJ0KGVtaXRDYWNoZWRFdmVudHMgPSB0cnVlKSB7XG4gICAgbGV0IGNhY2hlUmVzdWx0O1xuICAgIGNvbnN0IHVwZGF0ZVN0YXRlRnJvbUNhY2hlUmVzdWx0cyA9IChldmVudHMpID0+IHtcbiAgICAgIGlmIChlbWl0Q2FjaGVkRXZlbnRzKSB7XG4gICAgICAgIGZvciAoY29uc3QgZXZlbnQgb2YgZXZlbnRzKSB7XG4gICAgICAgICAgdGhpcy5ldmVudFJlY2VpdmVkKGV2ZW50LCB2b2lkIDAsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FjaGVSZXN1bHQgPSBbXTtcbiAgICAgICAgZXZlbnRzLmZvckVhY2goKGV2ZW50KSA9PiB7XG4gICAgICAgICAgZXZlbnQubmRrID0gdGhpcy5uZGs7XG4gICAgICAgICAgY29uc3QgZSA9IHRoaXMub3B0cy53cmFwID8gd3JhcEV2ZW50KGV2ZW50KSA6IGV2ZW50O1xuICAgICAgICAgIGlmICghZSkgcmV0dXJuO1xuICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgZS50aGVuKCh3cmFwcGVkRXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5lbWl0RXZlbnQoZmFsc2UsIHdyYXBwZWRFdmVudCwgdm9pZCAwLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5ldmVudEZpcnN0U2Vlbi5zZXQoZS5pZCwgRGF0ZS5ub3coKSk7XG4gICAgICAgICAgY2FjaGVSZXN1bHQucHVzaChlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBsb2FkRnJvbVJlbGF5cyA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLnNob3VsZFF1ZXJ5UmVsYXlzKCkpIHtcbiAgICAgICAgdGhpcy5zdGFydFdpdGhSZWxheXMoKTtcbiAgICAgICAgdGhpcy5zdGFydFBvb2xNb25pdG9yKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVtaXQoXCJlb3NlXCIsIHRoaXMpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKHRoaXMuc2hvdWxkUXVlcnlDYWNoZSgpKSB7XG4gICAgICBjYWNoZVJlc3VsdCA9IHRoaXMuc3RhcnRXaXRoQ2FjaGUoKTtcbiAgICAgIGlmIChjYWNoZVJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkV2FpdEZvckNhY2hlKCkpIHtcbiAgICAgICAgICBjYWNoZVJlc3VsdC50aGVuKChldmVudHMpID0+IHtcbiAgICAgICAgICAgIHVwZGF0ZVN0YXRlRnJvbUNhY2hlUmVzdWx0cyhldmVudHMpO1xuICAgICAgICAgICAgaWYgKHF1ZXJ5RnVsbHlGaWxsZWQodGhpcykpIHtcbiAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZW9zZVwiLCB0aGlzKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbG9hZEZyb21SZWxheXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWNoZVJlc3VsdC50aGVuKChldmVudHMpID0+IHtcbiAgICAgICAgICAgIHVwZGF0ZVN0YXRlRnJvbUNhY2hlUmVzdWx0cyhldmVudHMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXBkYXRlU3RhdGVGcm9tQ2FjaGVSZXN1bHRzKGNhY2hlUmVzdWx0KTtcbiAgICAgICAgaWYgKHF1ZXJ5RnVsbHlGaWxsZWQodGhpcykpIHtcbiAgICAgICAgICB0aGlzLmVtaXQoXCJlb3NlXCIsIHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvYWRGcm9tUmVsYXlzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhY2hlUmVzdWx0O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsb2FkRnJvbVJlbGF5cygpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBXZSB3YW50IHRvIG1vbml0b3IgZm9yIG5ldyByZWxheXMgdGhhdCBhcmUgY29taW5nIG9ubGluZSwgaW4gY2FzZVxuICAgKiB0aGV5IHNob3VsZCBiZSBwYXJ0IG9mIHRoaXMgc3Vic2NyaXB0aW9uLlxuICAgKi9cbiAgc3RhcnRQb29sTW9uaXRvcigpIHtcbiAgICBjb25zdCBkNCA9IHRoaXMuZGVidWcuZXh0ZW5kKFwicG9vbC1tb25pdG9yXCIpO1xuICAgIHRoaXMucG9vbE1vbml0b3IgPSAocmVsYXkpID0+IHtcbiAgICAgIGlmICh0aGlzLnJlbGF5RmlsdGVycz8uaGFzKHJlbGF5LnVybCkpIHJldHVybjtcbiAgICAgIGNvbnN0IGNhbGMgPSBjYWxjdWxhdGVSZWxheVNldHNGcm9tRmlsdGVycyh0aGlzLm5kaywgdGhpcy5maWx0ZXJzLCB0aGlzLnBvb2wpO1xuICAgICAgaWYgKGNhbGMuZ2V0KHJlbGF5LnVybCkpIHtcbiAgICAgICAgdGhpcy5yZWxheUZpbHRlcnM/LnNldChyZWxheS51cmwsIHRoaXMuZmlsdGVycyk7XG4gICAgICAgIHJlbGF5LnN1YnNjcmliZSh0aGlzLCB0aGlzLmZpbHRlcnMpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5wb29sLm9uKFwicmVsYXk6Y29ubmVjdFwiLCB0aGlzLnBvb2xNb25pdG9yKTtcbiAgfVxuICBvblN0b3BwZWQ7XG4gIHN0b3AoKSB7XG4gICAgdGhpcy5lbWl0KFwiY2xvc2VcIiwgdGhpcyk7XG4gICAgdGhpcy5wb29sTW9uaXRvciAmJiB0aGlzLnBvb2wub2ZmKFwicmVsYXk6Y29ubmVjdFwiLCB0aGlzLnBvb2xNb25pdG9yKTtcbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgIHRoaXMub25TdG9wcGVkPy4oKTtcbiAgfVxuICAvKipcbiAgICogQHJldHVybnMgV2hldGhlciB0aGUgc3Vic2NyaXB0aW9uIGhhcyBhbiBhdXRob3JzIGZpbHRlci5cbiAgICovXG4gIGhhc0F1dGhvcnNGaWx0ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsdGVycy5zb21lKChmKSA9PiBmLmF1dGhvcnM/Lmxlbmd0aCk7XG4gIH1cbiAgc3RhcnRXaXRoQ2FjaGUoKSB7XG4gICAgaWYgKHRoaXMubmRrLmNhY2hlQWRhcHRlcj8ucXVlcnkpIHtcbiAgICAgIHJldHVybiB0aGlzLm5kay5jYWNoZUFkYXB0ZXIucXVlcnkodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFNlbmQgUkVRIHRvIHJlbGF5c1xuICAgKi9cbiAgc3RhcnRXaXRoUmVsYXlzKCkge1xuICAgIGlmICghdGhpcy5yZWxheVNldCB8fCB0aGlzLnJlbGF5U2V0LnJlbGF5cy5zaXplID09PSAwKSB7XG4gICAgICB0aGlzLnJlbGF5RmlsdGVycyA9IGNhbGN1bGF0ZVJlbGF5U2V0c0Zyb21GaWx0ZXJzKHRoaXMubmRrLCB0aGlzLmZpbHRlcnMsIHRoaXMucG9vbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVsYXlGaWx0ZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIGZvciAoY29uc3QgcmVsYXkgb2YgdGhpcy5yZWxheVNldC5yZWxheXMpIHtcbiAgICAgICAgdGhpcy5yZWxheUZpbHRlcnMuc2V0KHJlbGF5LnVybCwgdGhpcy5maWx0ZXJzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0aGlzLnJlbGF5RmlsdGVycyB8fCB0aGlzLnJlbGF5RmlsdGVycy5zaXplID09PSAwKSByZXR1cm47XG4gICAgZm9yIChjb25zdCBbcmVsYXlVcmwsIGZpbHRlcnNdIG9mIHRoaXMucmVsYXlGaWx0ZXJzKSB7XG4gICAgICBjb25zdCByZWxheSA9IHRoaXMucG9vbC5nZXRSZWxheShyZWxheVVybCwgdHJ1ZSwgdHJ1ZSwgZmlsdGVycyk7XG4gICAgICByZWxheS5zdWJzY3JpYmUodGhpcywgZmlsdGVycyk7XG4gICAgfVxuICB9XG4gIC8vIEVWRU5UIGhhbmRsaW5nXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBhbiBldmVudCBpcyByZWNlaXZlZCBmcm9tIGEgcmVsYXkgb3IgdGhlIGNhY2hlXG4gICAqIEBwYXJhbSBldmVudFxuICAgKiBAcGFyYW0gcmVsYXlcbiAgICogQHBhcmFtIGZyb21DYWNoZSBXaGV0aGVyIHRoZSBldmVudCB3YXMgcmVjZWl2ZWQgZnJvbSB0aGUgY2FjaGVcbiAgICogQHBhcmFtIG9wdGltaXN0aWNQdWJsaXNoIFdoZXRoZXIgdGhpcyBldmVudCBpcyBjb21pbmcgZnJvbSBhbiBvcHRpbWlzdGljIHB1Ymxpc2hcbiAgICovXG4gIGV2ZW50UmVjZWl2ZWQoZXZlbnQsIHJlbGF5LCBmcm9tQ2FjaGUgPSBmYWxzZSwgb3B0aW1pc3RpY1B1Ymxpc2ggPSBmYWxzZSkge1xuICAgIGNvbnN0IGV2ZW50SWQgPSBldmVudC5pZDtcbiAgICBjb25zdCBldmVudEFscmVhZHlTZWVuID0gdGhpcy5ldmVudEZpcnN0U2Vlbi5oYXMoZXZlbnRJZCk7XG4gICAgbGV0IG5ka0V2ZW50O1xuICAgIGlmIChldmVudCBpbnN0YW5jZW9mIE5ES0V2ZW50KSBuZGtFdmVudCA9IGV2ZW50O1xuICAgIGlmICghZXZlbnRBbHJlYWR5U2Vlbikge1xuICAgICAgbmRrRXZlbnQgPz89IG5ldyBOREtFdmVudCh0aGlzLm5kaywgZXZlbnQpO1xuICAgICAgbmRrRXZlbnQubmRrID0gdGhpcy5uZGs7XG4gICAgICBuZGtFdmVudC5yZWxheSA9IHJlbGF5O1xuICAgICAgaWYgKCFmcm9tQ2FjaGUgJiYgIW9wdGltaXN0aWNQdWJsaXNoKSB7XG4gICAgICAgIGlmICghdGhpcy5za2lwVmFsaWRhdGlvbikge1xuICAgICAgICAgIGlmICghbmRrRXZlbnQuaXNWYWxpZCkge1xuICAgICAgICAgICAgdGhpcy5kZWJ1ZyhgRXZlbnQgZmFpbGVkIHZhbGlkYXRpb24gJXMgZnJvbSByZWxheSAlc2AsIGV2ZW50SWQsIHJlbGF5Py51cmwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVsYXkpIHtcbiAgICAgICAgICBpZiAocmVsYXk/LnNob3VsZFZhbGlkYXRlRXZlbnQoKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5za2lwVmVyaWZpY2F0aW9uKSB7XG4gICAgICAgICAgICAgIGlmICghbmRrRXZlbnQudmVyaWZ5U2lnbmF0dXJlKHRydWUpICYmICF0aGlzLm5kay5hc3luY1NpZ1ZlcmlmaWNhdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVidWcoYEV2ZW50IGZhaWxlZCBzaWduYXR1cmUgdmFsaWRhdGlvbmAsIGV2ZW50KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVsYXkpIHtcbiAgICAgICAgICAgICAgICByZWxheS5hZGRWYWxpZGF0ZWRFdmVudCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbGF5LmFkZE5vblZhbGlkYXRlZEV2ZW50KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm5kay5jYWNoZUFkYXB0ZXIgJiYgIXRoaXMub3B0cy5kb250U2F2ZVRvQ2FjaGUpIHtcbiAgICAgICAgICB0aGlzLm5kay5jYWNoZUFkYXB0ZXIuc2V0RXZlbnQobmRrRXZlbnQsIHRoaXMuZmlsdGVycywgcmVsYXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIW9wdGltaXN0aWNQdWJsaXNoIHx8IHRoaXMuc2tpcE9wdGltaXN0aWNQdWJsaXNoRXZlbnQgIT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5lbWl0RXZlbnQodGhpcy5vcHRzPy53cmFwLCBuZGtFdmVudCwgcmVsYXksIGZyb21DYWNoZSwgb3B0aW1pc3RpY1B1Ymxpc2gpO1xuICAgICAgICB0aGlzLmV2ZW50Rmlyc3RTZWVuLnNldChldmVudElkLCBEYXRlLm5vdygpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdGltZVNpbmNlRmlyc3RTZWVuID0gRGF0ZS5ub3coKSAtICh0aGlzLmV2ZW50Rmlyc3RTZWVuLmdldChldmVudElkKSB8fCAwKTtcbiAgICAgIHRoaXMuZW1pdChcImV2ZW50OmR1cFwiLCBldmVudCwgcmVsYXksIHRpbWVTaW5jZUZpcnN0U2VlbiwgdGhpcywgZnJvbUNhY2hlLCBvcHRpbWlzdGljUHVibGlzaCk7XG4gICAgICBpZiAocmVsYXkpIHtcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gdmVyaWZpZWRTaWduYXR1cmVzLmdldChldmVudElkKTtcbiAgICAgICAgaWYgKHNpZ25hdHVyZSAmJiB0eXBlb2Ygc2lnbmF0dXJlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgaWYgKGV2ZW50LnNpZyA9PT0gc2lnbmF0dXJlKSB7XG4gICAgICAgICAgICByZWxheS5hZGRWYWxpZGF0ZWRFdmVudCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmxhc3RFdmVudFJlY2VpdmVkQXQgPSBEYXRlLm5vdygpO1xuICB9XG4gIC8qKlxuICAgKiBPcHRpb25hbGx5IHdyYXBzLCBzeW5jIG9yIGFzeW5jLCBhbmQgZW1pdHMgdGhlIGV2ZW50IChpZiBvbmUgY29tZXMgYmFjayBmcm9tIHRoZSB3cmFwcGVyKVxuICAgKi9cbiAgZW1pdEV2ZW50KHdyYXAgPSBmYWxzZSwgZXZ0LCByZWxheSwgZnJvbUNhY2hlLCBvcHRpbWlzdGljUHVibGlzaCkge1xuICAgIGNvbnN0IHdyYXBwZWQgPSB3cmFwID8gd3JhcEV2ZW50KGV2dCkgOiBldnQ7XG4gICAgaWYgKHdyYXBwZWQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICB3cmFwcGVkLnRoZW4oKGUpID0+IHRoaXMuZW1pdEV2ZW50KGZhbHNlLCBlLCByZWxheSwgZnJvbUNhY2hlLCBvcHRpbWlzdGljUHVibGlzaCkpO1xuICAgIH0gZWxzZSBpZiAod3JhcHBlZCkge1xuICAgICAgdGhpcy5lbWl0KFwiZXZlbnRcIiwgd3JhcHBlZCwgcmVsYXksIHRoaXMsIGZyb21DYWNoZSwgb3B0aW1pc3RpY1B1Ymxpc2gpO1xuICAgIH1cbiAgfVxuICBjbG9zZWRSZWNlaXZlZChyZWxheSwgcmVhc29uKSB7XG4gICAgdGhpcy5lbWl0KFwiY2xvc2VkXCIsIHJlbGF5LCByZWFzb24pO1xuICB9XG4gIC8vIEVPU0UgaGFuZGxpbmdcbiAgZW9zZVRpbWVvdXQ7XG4gIGVvc2VkID0gZmFsc2U7XG4gIGVvc2VSZWNlaXZlZChyZWxheSkge1xuICAgIHRoaXMuZGVidWcoXCJFT1NFIHJlY2VpdmVkIGZyb20gJXNcIiwgcmVsYXkudXJsKTtcbiAgICB0aGlzLmVvc2VzU2Vlbi5hZGQocmVsYXkpO1xuICAgIGxldCBsYXN0RXZlbnRTZWVuID0gdGhpcy5sYXN0RXZlbnRSZWNlaXZlZEF0ID8gRGF0ZS5ub3coKSAtIHRoaXMubGFzdEV2ZW50UmVjZWl2ZWRBdCA6IHZvaWQgMDtcbiAgICBjb25zdCBoYXNTZWVuQWxsRW9zZXMgPSB0aGlzLmVvc2VzU2Vlbi5zaXplID09PSB0aGlzLnJlbGF5RmlsdGVycz8uc2l6ZTtcbiAgICBjb25zdCBxdWVyeUZpbGxlZCA9IHF1ZXJ5RnVsbHlGaWxsZWQodGhpcyk7XG4gICAgY29uc3QgcGVyZm9ybUVvc2UgPSAocmVhc29uKSA9PiB7XG4gICAgICB0aGlzLmRlYnVnKFwiUGVyZm9ybWluZyBFT1NFOiAlcyAlZFwiLCByZWFzb24sIHRoaXMuZW9zZWQpO1xuICAgICAgaWYgKHRoaXMuZW9zZWQpIHJldHVybjtcbiAgICAgIGlmICh0aGlzLmVvc2VUaW1lb3V0KSBjbGVhclRpbWVvdXQodGhpcy5lb3NlVGltZW91dCk7XG4gICAgICB0aGlzLmVtaXQoXCJlb3NlXCIsIHRoaXMpO1xuICAgICAgdGhpcy5lb3NlZCA9IHRydWU7XG4gICAgfTtcbiAgICBpZiAocXVlcnlGaWxsZWQgfHwgaGFzU2VlbkFsbEVvc2VzKSB7XG4gICAgICBwZXJmb3JtRW9zZShcInF1ZXJ5IGZpbGxlZCBvciBzZWVuIGFsbFwiKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMucmVsYXlGaWx0ZXJzKSB7XG4gICAgICBsZXQgdGltZVRvV2FpdEZvck5leHRFb3NlID0gMWUzO1xuICAgICAgY29uc3QgY29ubmVjdGVkUmVsYXlzID0gbmV3IFNldCh0aGlzLnBvb2wuY29ubmVjdGVkUmVsYXlzKCkubWFwKChyKSA9PiByLnVybCkpO1xuICAgICAgY29uc3QgY29ubmVjdGVkUmVsYXlzV2l0aEZpbHRlcnMgPSBBcnJheS5mcm9tKHRoaXMucmVsYXlGaWx0ZXJzLmtleXMoKSkuZmlsdGVyKFxuICAgICAgICAodXJsKSA9PiBjb25uZWN0ZWRSZWxheXMuaGFzKHVybClcbiAgICAgICk7XG4gICAgICBpZiAoY29ubmVjdGVkUmVsYXlzV2l0aEZpbHRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBlcmNlbnRhZ2VPZlJlbGF5c1RoYXRIYXZlU2VudEVvc2UgPSB0aGlzLmVvc2VzU2Vlbi5zaXplIC8gY29ubmVjdGVkUmVsYXlzV2l0aEZpbHRlcnMubGVuZ3RoO1xuICAgICAgdGhpcy5kZWJ1ZyhcIlBlcmNlbnRhZ2Ugb2YgcmVsYXlzIHRoYXQgaGF2ZSBzZW50IEVPU0VcIiwgeyBzdWJJZDogdGhpcy5zdWJJZCwgcGVyY2VudGFnZU9mUmVsYXlzVGhhdEhhdmVTZW50RW9zZSwgc2VlbjogdGhpcy5lb3Nlc1NlZW4uc2l6ZSwgdG90YWw6IGNvbm5lY3RlZFJlbGF5c1dpdGhGaWx0ZXJzLmxlbmd0aCB9KTtcbiAgICAgIGlmICh0aGlzLmVvc2VzU2Vlbi5zaXplID49IDIgJiYgcGVyY2VudGFnZU9mUmVsYXlzVGhhdEhhdmVTZW50RW9zZSA+PSAwLjUpIHtcbiAgICAgICAgdGltZVRvV2FpdEZvck5leHRFb3NlID0gdGltZVRvV2FpdEZvck5leHRFb3NlICogKDEgLSBwZXJjZW50YWdlT2ZSZWxheXNUaGF0SGF2ZVNlbnRFb3NlKTtcbiAgICAgICAgaWYgKHRpbWVUb1dhaXRGb3JOZXh0RW9zZSA9PT0gMCkge1xuICAgICAgICAgIHBlcmZvcm1Fb3NlKFwidGltZSB0byB3YWl0IHdhcyAwXCIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5lb3NlVGltZW91dCkgY2xlYXJUaW1lb3V0KHRoaXMuZW9zZVRpbWVvdXQpO1xuICAgICAgICBjb25zdCBzZW5kRW9zZVRpbWVvdXQgPSAoKSA9PiB7XG4gICAgICAgICAgbGFzdEV2ZW50U2VlbiA9IHRoaXMubGFzdEV2ZW50UmVjZWl2ZWRBdCA/IERhdGUubm93KCkgLSB0aGlzLmxhc3RFdmVudFJlY2VpdmVkQXQgOiB2b2lkIDA7XG4gICAgICAgICAgaWYgKGxhc3RFdmVudFNlZW4gIT09IHZvaWQgMCAmJiBsYXN0RXZlbnRTZWVuIDwgMjApIHtcbiAgICAgICAgICAgIHRoaXMuZW9zZVRpbWVvdXQgPSBzZXRUaW1lb3V0KHNlbmRFb3NlVGltZW91dCwgdGltZVRvV2FpdEZvck5leHRFb3NlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVyZm9ybUVvc2UoXCJzZW5kIGVvc2UgdGltZW91dDogXCIgKyB0aW1lVG9XYWl0Rm9yTmV4dEVvc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5lb3NlVGltZW91dCA9IHNldFRpbWVvdXQoc2VuZEVvc2VUaW1lb3V0LCB0aW1lVG9XYWl0Rm9yTmV4dEVvc2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbnZhciBraW5kSXNFcGhlbWVyYWwgPSAoa2luZCkgPT4ga2luZCA+PSAyZTQgJiYga2luZCA8IDNlNDtcblxuLy8gc3JjL3VzZXIvZm9sbG93cy50c1xuYXN5bmMgZnVuY3Rpb24gZm9sbG93cyhvcHRzLCBvdXRib3gsIGtpbmQgPSAzIC8qIENvbnRhY3RzICovKSB7XG4gIGlmICghdGhpcy5uZGspIHRocm93IG5ldyBFcnJvcihcIk5ESyBub3Qgc2V0XCIpO1xuICBjb25zdCBjb250YWN0TGlzdEV2ZW50ID0gYXdhaXQgdGhpcy5uZGsuZmV0Y2hFdmVudChcbiAgICB7IGtpbmRzOiBba2luZF0sIGF1dGhvcnM6IFt0aGlzLnB1YmtleV0gfSxcbiAgICBvcHRzIHx8IHsgZ3JvdXBhYmxlOiBmYWxzZSB9XG4gICk7XG4gIGlmIChjb250YWN0TGlzdEV2ZW50KSB7XG4gICAgY29uc3QgcHVia2V5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgY29udGFjdExpc3RFdmVudC50YWdzLmZvckVhY2goKHRhZykgPT4ge1xuICAgICAgaWYgKHRhZ1swXSA9PT0gXCJwXCIpIHB1YmtleXMuYWRkKHRhZ1sxXSk7XG4gICAgfSk7XG4gICAgaWYgKG91dGJveCkge1xuICAgICAgdGhpcy5uZGs/Lm91dGJveFRyYWNrZXI/LnRyYWNrVXNlcnMoQXJyYXkuZnJvbShwdWJrZXlzKSk7XG4gICAgfVxuICAgIHJldHVybiBbLi4ucHVia2V5c10ucmVkdWNlKChhY2MsIHB1YmtleSkgPT4ge1xuICAgICAgY29uc3QgdXNlciA9IG5ldyBOREtVc2VyKHsgcHVia2V5IH0pO1xuICAgICAgdXNlci5uZGsgPSB0aGlzLm5kaztcbiAgICAgIGFjYy5hZGQodXNlcik7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xufVxuXG4vLyBzcmMvdXNlci9wcm9maWxlLnRzXG5mdW5jdGlvbiBwcm9maWxlRnJvbUV2ZW50KGV2ZW50KSB7XG4gIGNvbnN0IHByb2ZpbGUgPSB7fTtcbiAgbGV0IHBheWxvYWQ7XG4gIHRyeSB7XG4gICAgcGF5bG9hZCA9IEpTT04ucGFyc2UoZXZlbnQuY29udGVudCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcGFyc2UgcHJvZmlsZSBldmVudDogJHtlcnJvcn1gKTtcbiAgfVxuICBwcm9maWxlLmNyZWF0ZWRfYXQgPSBldmVudC5jcmVhdGVkX2F0O1xuICBwcm9maWxlLnByb2ZpbGVFdmVudCA9IEpTT04uc3RyaW5naWZ5KGV2ZW50LnJhd0V2ZW50KCkpO1xuICBPYmplY3Qua2V5cyhwYXlsb2FkKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgY2FzZSBcIm5hbWVcIjpcbiAgICAgICAgcHJvZmlsZS5uYW1lID0gcGF5bG9hZC5uYW1lO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJkaXNwbGF5X25hbWVcIjpcbiAgICAgICAgcHJvZmlsZS5kaXNwbGF5TmFtZSA9IHBheWxvYWQuZGlzcGxheV9uYW1lO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJpbWFnZVwiOlxuICAgICAgY2FzZSBcInBpY3R1cmVcIjpcbiAgICAgICAgcHJvZmlsZS5waWN0dXJlID0gcGF5bG9hZC5waWN0dXJlIHx8IHBheWxvYWQuaW1hZ2U7XG4gICAgICAgIHByb2ZpbGUuaW1hZ2UgPSBwcm9maWxlLnBpY3R1cmU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImJhbm5lclwiOlxuICAgICAgICBwcm9maWxlLmJhbm5lciA9IHBheWxvYWQuYmFubmVyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJiaW9cIjpcbiAgICAgICAgcHJvZmlsZS5iaW8gPSBwYXlsb2FkLmJpbztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibmlwMDVcIjpcbiAgICAgICAgcHJvZmlsZS5uaXAwNSA9IHBheWxvYWQubmlwMDU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImx1ZDA2XCI6XG4gICAgICAgIHByb2ZpbGUubHVkMDYgPSBwYXlsb2FkLmx1ZDA2O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJsdWQxNlwiOlxuICAgICAgICBwcm9maWxlLmx1ZDE2ID0gcGF5bG9hZC5sdWQxNjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYWJvdXRcIjpcbiAgICAgICAgcHJvZmlsZS5hYm91dCA9IHBheWxvYWQuYWJvdXQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIndlYnNpdGVcIjpcbiAgICAgICAgcHJvZmlsZS53ZWJzaXRlID0gcGF5bG9hZC53ZWJzaXRlO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHByb2ZpbGVba2V5XSA9IHBheWxvYWRba2V5XTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHByb2ZpbGU7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVQcm9maWxlKHByb2ZpbGUpIHtcbiAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgT2JqZWN0LmVudHJpZXMocHJvZmlsZSkpIHtcbiAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgY2FzZSBcInVzZXJuYW1lXCI6XG4gICAgICBjYXNlIFwibmFtZVwiOlxuICAgICAgICBwYXlsb2FkLm5hbWUgPSB2YWw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImRpc3BsYXlOYW1lXCI6XG4gICAgICAgIHBheWxvYWQuZGlzcGxheV9uYW1lID0gdmFsO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJpbWFnZVwiOlxuICAgICAgY2FzZSBcInBpY3R1cmVcIjpcbiAgICAgICAgcGF5bG9hZC5waWN0dXJlID0gdmFsO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJiaW9cIjpcbiAgICAgIGNhc2UgXCJhYm91dFwiOlxuICAgICAgICBwYXlsb2FkLmFib3V0ID0gdmFsO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHBheWxvYWRba2V5XSA9IHZhbDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShwYXlsb2FkKTtcbn1cblxuLy8gc3JjL3VzZXIvbmlwMDUudHNcbnZhciBOSVAwNV9SRUdFWCA9IC9eKD86KFtcXHcuKy1dKylAKT8oW1xcdy4tXSspJC87XG5hc3luYyBmdW5jdGlvbiBnZXROaXAwNUZvcihuZGssIGZ1bGxuYW1lLCBfZmV0Y2ggPSBmZXRjaCwgZmV0Y2hPcHRzID0ge30pIHtcbiAgcmV0dXJuIGF3YWl0IG5kay5xdWV1ZXNOaXAwNS5hZGQoe1xuICAgIGlkOiBmdWxsbmFtZSxcbiAgICBmdW5jOiBhc3luYyAoKSA9PiB7XG4gICAgICBpZiAobmRrLmNhY2hlQWRhcHRlciAmJiBuZGsuY2FjaGVBZGFwdGVyLmxvYWROaXAwNSkge1xuICAgICAgICBjb25zdCBwcm9maWxlID0gYXdhaXQgbmRrLmNhY2hlQWRhcHRlci5sb2FkTmlwMDUoZnVsbG5hbWUpO1xuICAgICAgICBpZiAocHJvZmlsZSAhPT0gXCJtaXNzaW5nXCIpIHtcbiAgICAgICAgICBpZiAocHJvZmlsZSkge1xuICAgICAgICAgICAgY29uc3QgdXNlciA9IG5ldyBOREtVc2VyKHtcbiAgICAgICAgICAgICAgcHVia2V5OiBwcm9maWxlLnB1YmtleSxcbiAgICAgICAgICAgICAgcmVsYXlVcmxzOiBwcm9maWxlLnJlbGF5cyxcbiAgICAgICAgICAgICAgbmlwNDZVcmxzOiBwcm9maWxlLm5pcDQ2XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHVzZXIubmRrID0gbmRrO1xuICAgICAgICAgICAgcmV0dXJuIHVzZXI7XG4gICAgICAgICAgfSBlbHNlIGlmIChmZXRjaE9wdHMuY2FjaGUgIT09IFwibm8tY2FjaGVcIikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBtYXRjaCA9IGZ1bGxuYW1lLm1hdGNoKE5JUDA1X1JFR0VYKTtcbiAgICAgIGlmICghbWF0Y2gpIHJldHVybiBudWxsO1xuICAgICAgY29uc3QgW18sIG5hbWUgPSBcIl9cIiwgZG9tYWluXSA9IG1hdGNoO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgX2ZldGNoKFxuICAgICAgICAgIGBodHRwczovLyR7ZG9tYWlufS8ud2VsbC1rbm93bi9ub3N0ci5qc29uP25hbWU9JHtuYW1lfWAsXG4gICAgICAgICAgZmV0Y2hPcHRzXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IHsgbmFtZXMsIHJlbGF5cywgbmlwNDYgfSA9IHBhcnNlTklQMDVSZXN1bHQoYXdhaXQgcmVzLmpzb24oKSk7XG4gICAgICAgIGNvbnN0IHB1YmtleSA9IG5hbWVzW25hbWUudG9Mb3dlckNhc2UoKV07XG4gICAgICAgIGxldCBwcm9maWxlID0gbnVsbDtcbiAgICAgICAgaWYgKHB1YmtleSkge1xuICAgICAgICAgIHByb2ZpbGUgPSB7IHB1YmtleSwgcmVsYXlzOiByZWxheXM/LltwdWJrZXldLCBuaXA0NjogbmlwNDY/LltwdWJrZXldIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5kaz8uY2FjaGVBZGFwdGVyICYmIG5kay5jYWNoZUFkYXB0ZXIuc2F2ZU5pcDA1KSB7XG4gICAgICAgICAgbmRrLmNhY2hlQWRhcHRlci5zYXZlTmlwMDUoZnVsbG5hbWUsIHByb2ZpbGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9maWxlO1xuICAgICAgfSBjYXRjaCAoX2UpIHtcbiAgICAgICAgaWYgKG5kaz8uY2FjaGVBZGFwdGVyICYmIG5kay5jYWNoZUFkYXB0ZXIuc2F2ZU5pcDA1KSB7XG4gICAgICAgICAgbmRrPy5jYWNoZUFkYXB0ZXIuc2F2ZU5pcDA1KGZ1bGxuYW1lLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGZldGNoIE5JUDA1IGZvclwiLCBmdWxsbmFtZSwgX2UpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gcGFyc2VOSVAwNVJlc3VsdChqc29uKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICBuYW1lczoge31cbiAgfTtcbiAgZm9yIChjb25zdCBbbmFtZSwgcHVia2V5XSBvZiBPYmplY3QuZW50cmllcyhqc29uLm5hbWVzKSkge1xuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgcHVia2V5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXN1bHQubmFtZXNbbmFtZS50b0xvd2VyQ2FzZSgpXSA9IHB1YmtleTtcbiAgICB9XG4gIH1cbiAgaWYgKGpzb24ucmVsYXlzKSB7XG4gICAgcmVzdWx0LnJlbGF5cyA9IHt9O1xuICAgIGZvciAoY29uc3QgW3B1YmtleSwgcmVsYXlzXSBvZiBPYmplY3QuZW50cmllcyhqc29uLnJlbGF5cykpIHtcbiAgICAgIGlmICh0eXBlb2YgcHVia2V5ID09PSBcInN0cmluZ1wiICYmIEFycmF5LmlzQXJyYXkocmVsYXlzKSkge1xuICAgICAgICByZXN1bHQucmVsYXlzW3B1YmtleV0gPSByZWxheXMuZmlsdGVyKFxuICAgICAgICAgIChyZWxheSkgPT4gdHlwZW9mIHJlbGF5ID09PSBcInN0cmluZ1wiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChqc29uLm5pcDQ2KSB7XG4gICAgcmVzdWx0Lm5pcDQ2ID0ge307XG4gICAgZm9yIChjb25zdCBbcHVia2V5LCBuaXA0Nl0gb2YgT2JqZWN0LmVudHJpZXMoanNvbi5uaXA0NikpIHtcbiAgICAgIGlmICh0eXBlb2YgcHVia2V5ID09PSBcInN0cmluZ1wiICYmIEFycmF5LmlzQXJyYXkobmlwNDYpKSB7XG4gICAgICAgIHJlc3VsdC5uaXA0NltwdWJrZXldID0gbmlwNDYuZmlsdGVyKChyZWxheSkgPT4gdHlwZW9mIHJlbGF5ID09PSBcInN0cmluZ1wiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gc3JjL3VzZXIvaW5kZXgudHNcbnZhciBOREtVc2VyID0gY2xhc3MgX05ES1VzZXIge1xuICBuZGs7XG4gIHByb2ZpbGU7XG4gIHByb2ZpbGVFdmVudDtcbiAgX25wdWI7XG4gIF9wdWJrZXk7XG4gIHJlbGF5VXJscyA9IFtdO1xuICBuaXA0NlVybHMgPSBbXTtcbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIGlmIChvcHRzLm5wdWIpIHRoaXMuX25wdWIgPSBvcHRzLm5wdWI7XG4gICAgaWYgKG9wdHMuaGV4cHVia2V5KSB0aGlzLl9wdWJrZXkgPSBvcHRzLmhleHB1YmtleTtcbiAgICBpZiAob3B0cy5wdWJrZXkpIHRoaXMuX3B1YmtleSA9IG9wdHMucHVia2V5O1xuICAgIGlmIChvcHRzLnJlbGF5VXJscykgdGhpcy5yZWxheVVybHMgPSBvcHRzLnJlbGF5VXJscztcbiAgICBpZiAob3B0cy5uaXA0NlVybHMpIHRoaXMubmlwNDZVcmxzID0gb3B0cy5uaXA0NlVybHM7XG4gIH1cbiAgZ2V0IG5wdWIoKSB7XG4gICAgaWYgKCF0aGlzLl9ucHViKSB7XG4gICAgICBpZiAoIXRoaXMuX3B1YmtleSkgdGhyb3cgbmV3IEVycm9yKFwicHVia2V5IG5vdCBzZXRcIik7XG4gICAgICB0aGlzLl9ucHViID0gbmlwMTk1Lm5wdWJFbmNvZGUodGhpcy5wdWJrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fbnB1YjtcbiAgfVxuICBnZXQgbnByb2ZpbGUoKSB7XG4gICAgY29uc3QgcmVsYXlzID0gdGhpcy5wcm9maWxlRXZlbnQ/Lm9uUmVsYXlzPy5tYXAoKHIpID0+IHIudXJsKTtcbiAgICByZXR1cm4gbmlwMTk1Lm5wcm9maWxlRW5jb2RlKHtcbiAgICAgIHB1YmtleTogdGhpcy5wdWJrZXksXG4gICAgICByZWxheXNcbiAgICB9KTtcbiAgfVxuICBzZXQgbnB1YihucHViKSB7XG4gICAgdGhpcy5fbnB1YiA9IG5wdWI7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgdXNlcidzIHB1YmtleVxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgdXNlcidzIHB1YmtleVxuICAgKi9cbiAgZ2V0IHB1YmtleSgpIHtcbiAgICBpZiAoIXRoaXMuX3B1YmtleSkge1xuICAgICAgaWYgKCF0aGlzLl9ucHViKSB0aHJvdyBuZXcgRXJyb3IoXCJucHViIG5vdCBzZXRcIik7XG4gICAgICB0aGlzLl9wdWJrZXkgPSBuaXAxOTUuZGVjb2RlKHRoaXMubnB1YikuZGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3B1YmtleTtcbiAgfVxuICAvKipcbiAgICogU2V0IHRoZSB1c2VyJ3MgcHVia2V5XG4gICAqIEBwYXJhbSBwdWJrZXkge3N0cmluZ30gVGhlIHVzZXIncyBwdWJrZXlcbiAgICovXG4gIHNldCBwdWJrZXkocHVia2V5KSB7XG4gICAgdGhpcy5fcHVia2V5ID0gcHVia2V5O1xuICB9XG4gIC8qKlxuICAgKiBFcXVpdmFsZW50IHRvIE5ES0V2ZW50LmZpbHRlcnMoKS5cbiAgICogQHJldHVybnMge05ES0ZpbHRlcn1cbiAgICovXG4gIGZpbHRlcigpIHtcbiAgICByZXR1cm4geyBcIiNwXCI6IFt0aGlzLnB1YmtleV0gfTtcbiAgfVxuICAvKipcbiAgICogR2V0cyBOSVAtNTcgYW5kIE5JUC02MSBpbmZvcm1hdGlvbiB0aGF0IHRoaXMgdXNlciBoYXMgc2lnbmFsZWRcbiAgICpcbiAgICogQHBhcmFtIGdldEFsbCB7Ym9vbGVhbn0gV2hldGhlciB0byBnZXQgYWxsIHphcCBpbmZvIG9yIGp1c3QgdGhlIGZpcnN0IG9uZVxuICAgKi9cbiAgYXN5bmMgZ2V0WmFwSW5mbyh0aW1lb3V0TXMpIHtcbiAgICBpZiAoIXRoaXMubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBOREsgaW5zdGFuY2UgZm91bmRcIik7XG4gICAgY29uc3QgcHJvbWlzZVdpdGhUaW1lb3V0ID0gYXN5bmMgKHByb21pc2UpID0+IHtcbiAgICAgIGlmICghdGltZW91dE1zKSByZXR1cm4gcHJvbWlzZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBQcm9taXNlLnJhY2UoW1xuICAgICAgICAgIHByb21pc2UsXG4gICAgICAgICAgbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4gc2V0VGltZW91dCgoKSA9PiByZWplY3QoKSwgdGltZW91dE1zKSlcbiAgICAgICAgXSk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IFt1c2VyUHJvZmlsZSwgbWludExpc3RFdmVudF0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICBwcm9taXNlV2l0aFRpbWVvdXQodGhpcy5mZXRjaFByb2ZpbGUoKSksXG4gICAgICBwcm9taXNlV2l0aFRpbWVvdXQodGhpcy5uZGsuZmV0Y2hFdmVudCh7IGtpbmRzOiBbMTAwMTkgLyogQ2FzaHVNaW50TGlzdCAqL10sIGF1dGhvcnM6IFt0aGlzLnB1YmtleV0gfSkpXG4gICAgXSk7XG4gICAgY29uc3QgcmVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBpZiAobWludExpc3RFdmVudCkge1xuICAgICAgY29uc3QgbWludExpc3QgPSBOREtDYXNodU1pbnRMaXN0LmZyb20obWludExpc3RFdmVudCk7XG4gICAgICBpZiAobWludExpc3QubWludHMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXMuc2V0KFwibmlwNjFcIiwge1xuICAgICAgICAgIG1pbnRzOiBtaW50TGlzdC5taW50cyxcbiAgICAgICAgICByZWxheXM6IG1pbnRMaXN0LnJlbGF5cyxcbiAgICAgICAgICBwMnBrOiBtaW50TGlzdC5wMnBrXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodXNlclByb2ZpbGUpIHtcbiAgICAgIGNvbnN0IHsgbHVkMDYsIGx1ZDE2IH0gPSB1c2VyUHJvZmlsZTtcbiAgICAgIHJlcy5zZXQoXCJuaXA1N1wiLCB7IGx1ZDA2LCBsdWQxNiB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICAvKipcbiAgICogSW5zdGFudGlhdGUgYW4gTkRLVXNlciBmcm9tIGEgTklQLTA1IHN0cmluZ1xuICAgKiBAcGFyYW0gbmlwMDVJZCB7c3RyaW5nfSBUaGUgdXNlcidzIE5JUC0wNVxuICAgKiBAcGFyYW0gbmRrIHtOREt9IEFuIE5ESyBpbnN0YW5jZVxuICAgKiBAcGFyYW0gc2tpcENhY2hlIHtib29sZWFufSBXaGV0aGVyIHRvIHNraXAgdGhlIGNhY2hlIG9yIG5vdFxuICAgKiBAcmV0dXJucyB7TkRLVXNlciB8IHVuZGVmaW5lZH0gQW4gTkRLVXNlciBpZiBvbmUgaXMgZm91bmQgZm9yIHRoZSBnaXZlbiBOSVAtMDUsIHVuZGVmaW5lZCBvdGhlcndpc2UuXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZnJvbU5pcDA1KG5pcDA1SWQsIG5kaywgc2tpcENhY2hlID0gZmFsc2UpIHtcbiAgICBpZiAoIW5kaykgdGhyb3cgbmV3IEVycm9yKFwiTm8gTkRLIGluc3RhbmNlIGZvdW5kXCIpO1xuICAgIGNvbnN0IG9wdHMgPSB7fTtcbiAgICBpZiAoc2tpcENhY2hlKSBvcHRzLmNhY2hlID0gXCJuby1jYWNoZVwiO1xuICAgIGNvbnN0IHByb2ZpbGUgPSBhd2FpdCBnZXROaXAwNUZvcihuZGssIG5pcDA1SWQsIG5kaz8uaHR0cEZldGNoLCBvcHRzKTtcbiAgICBpZiAocHJvZmlsZSkge1xuICAgICAgY29uc3QgdXNlciA9IG5ldyBfTkRLVXNlcih7XG4gICAgICAgIHB1YmtleTogcHJvZmlsZS5wdWJrZXksXG4gICAgICAgIHJlbGF5VXJsczogcHJvZmlsZS5yZWxheXMsXG4gICAgICAgIG5pcDQ2VXJsczogcHJvZmlsZS5uaXA0NlxuICAgICAgfSk7XG4gICAgICB1c2VyLm5kayA9IG5kaztcbiAgICAgIHJldHVybiB1c2VyO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRmV0Y2ggYSB1c2VyJ3MgcHJvZmlsZVxuICAgKiBAcGFyYW0gb3B0cyB7TkRLU3Vic2NyaXB0aW9uT3B0aW9uc30gQSBzZXQgb2YgTkRLU3Vic2NyaXB0aW9uT3B0aW9uc1xuICAgKiBAcGFyYW0gc3RvcmVQcm9maWxlRXZlbnQge2Jvb2xlYW59IFdoZXRoZXIgdG8gc3RvcmUgdGhlIHByb2ZpbGUgZXZlbnQgb3Igbm90XG4gICAqIEByZXR1cm5zIFVzZXIgUHJvZmlsZVxuICAgKi9cbiAgYXN5bmMgZmV0Y2hQcm9maWxlKG9wdHMsIHN0b3JlUHJvZmlsZUV2ZW50ID0gZmFsc2UpIHtcbiAgICBpZiAoIXRoaXMubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJOREsgbm90IHNldFwiKTtcbiAgICBpZiAoIXRoaXMucHJvZmlsZSkgdGhpcy5wcm9maWxlID0ge307XG4gICAgbGV0IHNldE1ldGFkYXRhRXZlbnQgPSBudWxsO1xuICAgIGlmICh0aGlzLm5kay5jYWNoZUFkYXB0ZXIgJiYgdGhpcy5uZGsuY2FjaGVBZGFwdGVyLmZldGNoUHJvZmlsZSAmJiBvcHRzPy5jYWNoZVVzYWdlICE9PSBcIk9OTFlfUkVMQVlcIiAvKiBPTkxZX1JFTEFZICovKSB7XG4gICAgICBjb25zdCBwcm9maWxlID0gYXdhaXQgdGhpcy5uZGsuY2FjaGVBZGFwdGVyLmZldGNoUHJvZmlsZSh0aGlzLnB1YmtleSk7XG4gICAgICBpZiAocHJvZmlsZSkge1xuICAgICAgICB0aGlzLnByb2ZpbGUgPSBwcm9maWxlO1xuICAgICAgICByZXR1cm4gcHJvZmlsZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFvcHRzICYmIC8vIGlmIG5vIG9wdGlvbnMgaGF2ZSBiZWVuIHNldFxuICAgIHRoaXMubmRrLmNhY2hlQWRhcHRlciAmJiAvLyBhbmQgd2UgaGF2ZSBhIGNhY2hlXG4gICAgdGhpcy5uZGsuY2FjaGVBZGFwdGVyLmxvY2tpbmcpIHtcbiAgICAgIHNldE1ldGFkYXRhRXZlbnQgPSBhd2FpdCB0aGlzLm5kay5mZXRjaEV2ZW50KFxuICAgICAgICB7XG4gICAgICAgICAga2luZHM6IFswXSxcbiAgICAgICAgICBhdXRob3JzOiBbdGhpcy5wdWJrZXldXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBjYWNoZVVzYWdlOiBcIk9OTFlfQ0FDSEVcIiAvKiBPTkxZX0NBQ0hFICovLFxuICAgICAgICAgIGNsb3NlT25Fb3NlOiB0cnVlLFxuICAgICAgICAgIGdyb3VwYWJsZTogZmFsc2VcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIG9wdHMgPSB7XG4gICAgICAgIGNhY2hlVXNhZ2U6IFwiT05MWV9SRUxBWVwiIC8qIE9OTFlfUkVMQVkgKi8sXG4gICAgICAgIGNsb3NlT25Fb3NlOiB0cnVlLFxuICAgICAgICBncm91cGFibGU6IHRydWUsXG4gICAgICAgIGdyb3VwYWJsZURlbGF5OiAyNTBcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICghc2V0TWV0YWRhdGFFdmVudCkge1xuICAgICAgc2V0TWV0YWRhdGFFdmVudCA9IGF3YWl0IHRoaXMubmRrLmZldGNoRXZlbnQoXG4gICAgICAgIHtcbiAgICAgICAgICBraW5kczogWzBdLFxuICAgICAgICAgIGF1dGhvcnM6IFt0aGlzLnB1YmtleV1cbiAgICAgICAgfSxcbiAgICAgICAgb3B0c1xuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKCFzZXRNZXRhZGF0YUV2ZW50KSByZXR1cm4gbnVsbDtcbiAgICB0aGlzLnByb2ZpbGUgPSBwcm9maWxlRnJvbUV2ZW50KHNldE1ldGFkYXRhRXZlbnQpO1xuICAgIGlmIChzdG9yZVByb2ZpbGVFdmVudCkge1xuICAgICAgdGhpcy5wcm9maWxlLnByb2ZpbGVFdmVudCA9IEpTT04uc3RyaW5naWZ5KHNldE1ldGFkYXRhRXZlbnQpO1xuICAgIH1cbiAgICBpZiAodGhpcy5wcm9maWxlICYmIHRoaXMubmRrLmNhY2hlQWRhcHRlciAmJiB0aGlzLm5kay5jYWNoZUFkYXB0ZXIuc2F2ZVByb2ZpbGUpIHtcbiAgICAgIHRoaXMubmRrLmNhY2hlQWRhcHRlci5zYXZlUHJvZmlsZSh0aGlzLnB1YmtleSwgdGhpcy5wcm9maWxlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucHJvZmlsZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIHNldCBvZiB1c2VycyB0aGF0IHRoaXMgdXNlciBmb2xsb3dzLlxuICAgKiBcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGZvbGxvd1NldCBpbnN0ZWFkXG4gICAqL1xuICBmb2xsb3dzID0gZm9sbG93cy5iaW5kKHRoaXMpO1xuICAvKipcbiAgICogUmV0dXJucyBhIHNldCBvZiBwdWJrZXlzIHRoYXQgdGhpcyB1c2VyIGZvbGxvd3MuXG4gICAqIFxuICAgKiBAcGFyYW0gb3B0cyAtIE5ES1N1YnNjcmlwdGlvbk9wdGlvbnNcbiAgICogQHBhcmFtIG91dGJveCAtIGJvb2xlYW5cbiAgICogQHBhcmFtIGtpbmQgLSBudW1iZXJcbiAgICovXG4gIGFzeW5jIGZvbGxvd1NldChvcHRzLCBvdXRib3gsIGtpbmQgPSAzIC8qIENvbnRhY3RzICovKSB7XG4gICAgY29uc3QgZm9sbG93czIgPSBhd2FpdCB0aGlzLmZvbGxvd3Mob3B0cywgb3V0Ym94LCBraW5kKTtcbiAgICByZXR1cm4gbmV3IFNldChBcnJheS5mcm9tKGZvbGxvd3MyKS5tYXAoKGYpID0+IGYucHVia2V5KSk7XG4gIH1cbiAgLyoqIEBkZXByZWNhdGVkIFVzZSByZWZlcmVuY2VUYWdzIGluc3RlYWQuICovXG4gIC8qKlxuICAgKiBHZXQgdGhlIHRhZyB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlZmVyZW5jZSB0aGlzIHVzZXIgaW4gYW4gZXZlbnRcbiAgICogQHJldHVybnMge05ES1RhZ30gYW4gTkRLVGFnXG4gICAqL1xuICB0YWdSZWZlcmVuY2UoKSB7XG4gICAgcmV0dXJuIFtcInBcIiwgdGhpcy5wdWJrZXldO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHRhZ3MgdGhhdCBjYW4gYmUgdXNlZCB0byByZWZlcmVuY2UgdGhpcyB1c2VyIGluIGFuIGV2ZW50XG4gICAqIEByZXR1cm5zIHtOREtUYWdbXX0gYW4gYXJyYXkgb2YgTkRLVGFnXG4gICAqL1xuICByZWZlcmVuY2VUYWdzKG1hcmtlcikge1xuICAgIGNvbnN0IHRhZyA9IFtbXCJwXCIsIHRoaXMucHVia2V5XV07XG4gICAgaWYgKCFtYXJrZXIpIHJldHVybiB0YWc7XG4gICAgdGFnWzBdLnB1c2goXCJcIiwgbWFya2VyKTtcbiAgICByZXR1cm4gdGFnO1xuICB9XG4gIC8qKlxuICAgKiBQdWJsaXNoZXMgdGhlIGN1cnJlbnQgcHJvZmlsZS5cbiAgICovXG4gIGFzeW5jIHB1Ymxpc2goKSB7XG4gICAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTm8gTkRLIGluc3RhbmNlIGZvdW5kXCIpO1xuICAgIGlmICghdGhpcy5wcm9maWxlKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBwcm9maWxlIGF2YWlsYWJsZVwiKTtcbiAgICB0aGlzLm5kay5hc3NlcnRTaWduZXIoKTtcbiAgICBjb25zdCBldmVudCA9IG5ldyBOREtFdmVudCh0aGlzLm5kaywge1xuICAgICAga2luZDogMCxcbiAgICAgIGNvbnRlbnQ6IHNlcmlhbGl6ZVByb2ZpbGUodGhpcy5wcm9maWxlKVxuICAgIH0pO1xuICAgIGF3YWl0IGV2ZW50LnB1Ymxpc2goKTtcbiAgfVxuICAvKipcbiAgICogQWRkIGEgZm9sbG93IHRvIHRoaXMgdXNlcidzIGNvbnRhY3QgbGlzdFxuICAgKlxuICAgKiBAcGFyYW0gbmV3Rm9sbG93IHtOREtVc2VyfSBUaGUgdXNlciB0byBmb2xsb3dcbiAgICogQHBhcmFtIGN1cnJlbnRGb2xsb3dMaXN0IHtTZXQ8TkRLVXNlcj59IFRoZSBjdXJyZW50IGZvbGxvdyBsaXN0XG4gICAqIEBwYXJhbSBraW5kIHtOREtLaW5kfSBUaGUga2luZCB0byB1c2UgZm9yIHRoaXMgY29udGFjdCBsaXN0IChkZWZhdWx0cyB0byBgM2ApXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fSBUcnVlIGlmIHRoZSBmb2xsb3cgd2FzIGFkZGVkLCBmYWxzZSBpZiB0aGUgZm9sbG93IGFscmVhZHkgZXhpc3RzXG4gICAqL1xuICBhc3luYyBmb2xsb3cobmV3Rm9sbG93LCBjdXJyZW50Rm9sbG93TGlzdCwga2luZCA9IDMgLyogQ29udGFjdHMgKi8pIHtcbiAgICBpZiAoIXRoaXMubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBOREsgaW5zdGFuY2UgZm91bmRcIik7XG4gICAgdGhpcy5uZGsuYXNzZXJ0U2lnbmVyKCk7XG4gICAgaWYgKCFjdXJyZW50Rm9sbG93TGlzdCkge1xuICAgICAgY3VycmVudEZvbGxvd0xpc3QgPSBhd2FpdCB0aGlzLmZvbGxvd3Modm9pZCAwLCB2b2lkIDAsIGtpbmQpO1xuICAgIH1cbiAgICBpZiAoY3VycmVudEZvbGxvd0xpc3QuaGFzKG5ld0ZvbGxvdykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY3VycmVudEZvbGxvd0xpc3QuYWRkKG5ld0ZvbGxvdyk7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgTkRLRXZlbnQodGhpcy5uZGssIHsga2luZCB9KTtcbiAgICBmb3IgKGNvbnN0IGZvbGxvdyBvZiBjdXJyZW50Rm9sbG93TGlzdCkge1xuICAgICAgZXZlbnQudGFnKGZvbGxvdyk7XG4gICAgfVxuICAgIGF3YWl0IGV2ZW50LnB1Ymxpc2goKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIGEgZm9sbG93IGZyb20gdGhpcyB1c2VyJ3MgY29udGFjdCBsaXN0XG4gICAqXG4gICAqIEBwYXJhbSB1c2VyIHtOREtVc2VyfSBUaGUgdXNlciB0byB1bmZvbGxvd1xuICAgKiBAcGFyYW0gY3VycmVudEZvbGxvd0xpc3Qge1NldDxOREtVc2VyPn0gVGhlIGN1cnJlbnQgZm9sbG93IGxpc3RcbiAgICogQHBhcmFtIGtpbmQge05ES0tpbmR9IFRoZSBraW5kIHRvIHVzZSBmb3IgdGhpcyBjb250YWN0IGxpc3QgKGRlZmF1bHRzIHRvIGAzYClcbiAgICogQHJldHVybnMgVGhlIHJlbGF5cyB3ZXJlIHRoZSBmb2xsb3cgbGlzdCB3YXMgcHVibGlzaGVkIG9yIGZhbHNlIGlmIHRoZSB1c2VyIHdhc24ndCBmb3VuZFxuICAgKi9cbiAgYXN5bmMgdW5mb2xsb3codXNlciwgY3VycmVudEZvbGxvd0xpc3QsIGtpbmQgPSAzIC8qIENvbnRhY3RzICovKSB7XG4gICAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTm8gTkRLIGluc3RhbmNlIGZvdW5kXCIpO1xuICAgIHRoaXMubmRrLmFzc2VydFNpZ25lcigpO1xuICAgIGlmICghY3VycmVudEZvbGxvd0xpc3QpIHtcbiAgICAgIGN1cnJlbnRGb2xsb3dMaXN0ID0gYXdhaXQgdGhpcy5mb2xsb3dzKHZvaWQgMCwgdm9pZCAwLCBraW5kKTtcbiAgICB9XG4gICAgY29uc3QgbmV3VXNlckZvbGxvd0xpc3QgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGxldCBmb3VuZFVzZXIgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IGZvbGxvdyBvZiBjdXJyZW50Rm9sbG93TGlzdCkge1xuICAgICAgaWYgKGZvbGxvdy5wdWJrZXkgIT09IHVzZXIucHVia2V5KSB7XG4gICAgICAgIG5ld1VzZXJGb2xsb3dMaXN0LmFkZChmb2xsb3cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm91bmRVc2VyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFmb3VuZFVzZXIpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBldmVudCA9IG5ldyBOREtFdmVudCh0aGlzLm5kaywgeyBraW5kIH0pO1xuICAgIGZvciAoY29uc3QgZm9sbG93IG9mIG5ld1VzZXJGb2xsb3dMaXN0KSB7XG4gICAgICBldmVudC50YWcoZm9sbG93KTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IGV2ZW50LnB1Ymxpc2goKTtcbiAgfVxuICAvKipcbiAgICogVmFsaWRhdGUgYSB1c2VyJ3MgTklQLTA1IGlkZW50aWZpZXIgKHVzdWFsbHkgZmV0Y2hlZCBmcm9tIHRoZWlyIGtpbmQ6MCBwcm9maWxlIGRhdGEpXG4gICAqXG4gICAqIEBwYXJhbSBuaXAwNUlkIFRoZSBOSVAtMDUgc3RyaW5nIHRvIHZhbGlkYXRlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4gfCBudWxsPn0gVHJ1ZSBpZiB0aGUgTklQLTA1IGlzIGZvdW5kIGFuZCBtYXRjaGVzIHRoaXMgdXNlcidzIHB1YmtleSxcbiAgICogRmFsc2UgaWYgdGhlIE5JUC0wNSBpcyBmb3VuZCBidXQgZG9lc24ndCBtYXRjaCB0aGlzIHVzZXIncyBwdWJrZXksXG4gICAqIG51bGwgaWYgdGhlIE5JUC0wNSBpc24ndCBmb3VuZCBvbiB0aGUgZG9tYWluIG9yIHdlJ3JlIHVuYWJsZSB0byB2ZXJpZnkgKGJlY2F1c2Ugb2YgbmV0d29yayBpc3N1ZXMsIGV0Yy4pXG4gICAqL1xuICBhc3luYyB2YWxpZGF0ZU5pcDA1KG5pcDA1SWQpIHtcbiAgICBpZiAoIXRoaXMubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBOREsgaW5zdGFuY2UgZm91bmRcIik7XG4gICAgY29uc3QgcHJvZmlsZVBvaW50ZXIgPSBhd2FpdCBnZXROaXAwNUZvcih0aGlzLm5kaywgbmlwMDVJZCk7XG4gICAgaWYgKHByb2ZpbGVQb2ludGVyID09PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gcHJvZmlsZVBvaW50ZXIucHVia2V5ID09PSB0aGlzLnB1YmtleTtcbiAgfVxufTtcblxuLy8gc3JjL3VzZXIvcGluLnRzXG5hc3luYyBmdW5jdGlvbiBwaW5FdmVudCh1c2VyLCBldmVudCwgcGluRXZlbnQyLCBwdWJsaXNoKSB7XG4gIGNvbnN0IGtpbmQgPSAxMDAwMSAvKiBQaW5MaXN0ICovO1xuICBpZiAoIXVzZXIubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBOREsgaW5zdGFuY2UgZm91bmRcIik7XG4gIHVzZXIubmRrLmFzc2VydFNpZ25lcigpO1xuICBpZiAoIXBpbkV2ZW50Mikge1xuICAgIGNvbnN0IGV2ZW50cyA9IGF3YWl0IHVzZXIubmRrLmZldGNoRXZlbnRzKFxuICAgICAgeyBraW5kczogW2tpbmRdLCBhdXRob3JzOiBbdXNlci5wdWJrZXldIH0sXG4gICAgICB7IGNhY2hlVXNhZ2U6IFwiT05MWV9SRUxBWVwiIC8qIE9OTFlfUkVMQVkgKi8gfVxuICAgICk7XG4gICAgaWYgKGV2ZW50cy5zaXplID4gMCkge1xuICAgICAgcGluRXZlbnQyID0gbGlzdHNfZGVmYXVsdC5mcm9tKEFycmF5LmZyb20oZXZlbnRzKVswXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBpbkV2ZW50MiA9IG5ldyBOREtFdmVudCh1c2VyLm5kaywge1xuICAgICAgICBraW5kXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcGluRXZlbnQyLnRhZyhldmVudCk7XG4gIGlmIChwdWJsaXNoKSB7XG4gICAgYXdhaXQgcGluRXZlbnQyLnB1Ymxpc2goKTtcbiAgfVxuICByZXR1cm4gcGluRXZlbnQyO1xufVxuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL2NsYXNzaWZpZWQudHNcbnZhciBOREtDbGFzc2lmaWVkID0gY2xhc3MgX05ES0NsYXNzaWZpZWQgZXh0ZW5kcyBOREtFdmVudCB7XG4gIGNvbnN0cnVjdG9yKG5kaywgcmF3RXZlbnQpIHtcbiAgICBzdXBlcihuZGssIHJhd0V2ZW50KTtcbiAgICB0aGlzLmtpbmQgPz89IDMwNDAyIC8qIENsYXNzaWZpZWQgKi87XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBOREtDbGFzc2lmaWVkIGZyb20gYW4gZXhpc3RpbmcgTkRLRXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSBldmVudCBOREtFdmVudCB0byBjcmVhdGUgdGhlIE5ES0NsYXNzaWZpZWQgZnJvbS5cbiAgICogQHJldHVybnMgTkRLQ2xhc3NpZmllZFxuICAgKi9cbiAgc3RhdGljIGZyb20oZXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtDbGFzc2lmaWVkKGV2ZW50Lm5kaywgZXZlbnQpO1xuICB9XG4gIC8qKlxuICAgKiBHZXR0ZXIgZm9yIHRoZSBjbGFzc2lmaWVkIHRpdGxlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nIHwgdW5kZWZpbmVkfSAtIFRoZSBjbGFzc2lmaWVkIHRpdGxlIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIHVuZGVmaW5lZC5cbiAgICovXG4gIGdldCB0aXRsZSgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcInRpdGxlXCIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXR0ZXIgZm9yIHRoZSBjbGFzc2lmaWVkIHRpdGxlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gdGl0bGUgLSBUaGUgdGl0bGUgdG8gc2V0IGZvciB0aGUgY2xhc3NpZmllZC5cbiAgICovXG4gIHNldCB0aXRsZSh0aXRsZSkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwidGl0bGVcIik7XG4gICAgaWYgKHRpdGxlKSB0aGlzLnRhZ3MucHVzaChbXCJ0aXRsZVwiLCB0aXRsZV0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXR0ZXIgZm9yIHRoZSBjbGFzc2lmaWVkIHN1bW1hcnkuXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmcgfCB1bmRlZmluZWR9IC0gVGhlIGNsYXNzaWZpZWQgc3VtbWFyeSBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSB1bmRlZmluZWQuXG4gICAqL1xuICBnZXQgc3VtbWFyeSgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcInN1bW1hcnlcIik7XG4gIH1cbiAgLyoqXG4gICAqIFNldHRlciBmb3IgdGhlIGNsYXNzaWZpZWQgc3VtbWFyeS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IHN1bW1hcnkgLSBUaGUgc3VtbWFyeSB0byBzZXQgZm9yIHRoZSBjbGFzc2lmaWVkLlxuICAgKi9cbiAgc2V0IHN1bW1hcnkoc3VtbWFyeSkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwic3VtbWFyeVwiKTtcbiAgICBpZiAoc3VtbWFyeSkgdGhpcy50YWdzLnB1c2goW1wic3VtbWFyeVwiLCBzdW1tYXJ5XSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHRlciBmb3IgdGhlIGNsYXNzaWZpZWQncyBwdWJsaWNhdGlvbiB0aW1lc3RhbXAuXG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXIgfCB1bmRlZmluZWR9IC0gVGhlIFVuaXggdGltZXN0YW1wIG9mIHdoZW4gdGhlIGNsYXNzaWZpZWQgd2FzIHB1Ymxpc2hlZCBvciB1bmRlZmluZWQuXG4gICAqL1xuICBnZXQgcHVibGlzaGVkX2F0KCkge1xuICAgIGNvbnN0IHRhZyA9IHRoaXMudGFnVmFsdWUoXCJwdWJsaXNoZWRfYXRcIik7XG4gICAgaWYgKHRhZykge1xuICAgICAgcmV0dXJuIHBhcnNlSW50KHRhZyk7XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgLyoqXG4gICAqIFNldHRlciBmb3IgdGhlIGNsYXNzaWZpZWQncyBwdWJsaWNhdGlvbiB0aW1lc3RhbXAuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgdW5kZWZpbmVkfSB0aW1lc3RhbXAgLSBUaGUgVW5peCB0aW1lc3RhbXAgdG8gc2V0IGZvciB0aGUgY2xhc3NpZmllZCdzIHB1YmxpY2F0aW9uIGRhdGUuXG4gICAqL1xuICBzZXQgcHVibGlzaGVkX2F0KHRpbWVzdGFtcCkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwicHVibGlzaGVkX2F0XCIpO1xuICAgIGlmICh0aW1lc3RhbXAgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wicHVibGlzaGVkX2F0XCIsIHRpbWVzdGFtcC50b1N0cmluZygpXSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBHZXR0ZXIgZm9yIHRoZSBjbGFzc2lmaWVkIGxvY2F0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nIHwgdW5kZWZpbmVkfSAtIFRoZSBjbGFzc2lmaWVkIGxvY2F0aW9uIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIHVuZGVmaW5lZC5cbiAgICovXG4gIGdldCBsb2NhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcImxvY2F0aW9uXCIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXR0ZXIgZm9yIHRoZSBjbGFzc2lmaWVkIGxvY2F0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gbG9jYXRpb24gLSBUaGUgbG9jYXRpb24gdG8gc2V0IGZvciB0aGUgY2xhc3NpZmllZC5cbiAgICovXG4gIHNldCBsb2NhdGlvbihsb2NhdGlvbikge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwibG9jYXRpb25cIik7XG4gICAgaWYgKGxvY2F0aW9uKSB0aGlzLnRhZ3MucHVzaChbXCJsb2NhdGlvblwiLCBsb2NhdGlvbl0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXR0ZXIgZm9yIHRoZSBjbGFzc2lmaWVkIHByaWNlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7TkRLQ2xhc3NpZmllZFByaWNlVGFnIHwgdW5kZWZpbmVkfSAtIFRoZSBjbGFzc2lmaWVkIHByaWNlIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIHVuZGVmaW5lZC5cbiAgICovXG4gIGdldCBwcmljZSgpIHtcbiAgICBjb25zdCBwcmljZVRhZyA9IHRoaXMudGFncy5maW5kKCh0YWcpID0+IHRhZ1swXSA9PT0gXCJwcmljZVwiKTtcbiAgICBpZiAocHJpY2VUYWcpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFtb3VudDogcGFyc2VGbG9hdChwcmljZVRhZ1sxXSksXG4gICAgICAgIGN1cnJlbmN5OiBwcmljZVRhZ1syXSxcbiAgICAgICAgZnJlcXVlbmN5OiBwcmljZVRhZ1szXVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFNldHRlciBmb3IgdGhlIGNsYXNzaWZpZWQgcHJpY2UuXG4gICAqXG4gICAqIEBwYXJhbSBwcmljZSAtIFRoZSBwcmljZSB0byBzZXQgZm9yIHRoZSBjbGFzc2lmaWVkLlxuICAgKi9cbiAgc2V0IHByaWNlKHByaWNlVGFnKSB7XG4gICAgaWYgKHR5cGVvZiBwcmljZVRhZyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcHJpY2VUYWcgPSB7XG4gICAgICAgIGFtb3VudDogcGFyc2VGbG9hdChwcmljZVRhZylcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChwcmljZVRhZz8uYW1vdW50KSB7XG4gICAgICBjb25zdCB0YWcgPSBbXCJwcmljZVwiLCBwcmljZVRhZy5hbW91bnQudG9TdHJpbmcoKV07XG4gICAgICBpZiAocHJpY2VUYWcuY3VycmVuY3kpIHRhZy5wdXNoKHByaWNlVGFnLmN1cnJlbmN5KTtcbiAgICAgIGlmIChwcmljZVRhZy5mcmVxdWVuY3kpIHRhZy5wdXNoKHByaWNlVGFnLmZyZXF1ZW5jeSk7XG4gICAgICB0aGlzLnRhZ3MucHVzaCh0YWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbW92ZVRhZyhcInByaWNlXCIpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGNvbnRlbnQgdGFncyBmb3IgdGhlIGNsYXNzaWZpZWQuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGZpcnN0IGNoZWNrcyBhbmQgc2V0cyB0aGUgcHVibGljYXRpb24gZGF0ZSBpZiBub3QgYXZhaWxhYmxlLFxuICAgKiBhbmQgdGhlbiBnZW5lcmF0ZXMgY29udGVudCB0YWdzIGJhc2VkIG9uIHRoZSBiYXNlIE5ES0V2ZW50IGNsYXNzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Q29udGVudFRhZ30gLSBUaGUgZ2VuZXJhdGVkIGNvbnRlbnQgdGFncy5cbiAgICovXG4gIGFzeW5jIGdlbmVyYXRlVGFncygpIHtcbiAgICBzdXBlci5nZW5lcmF0ZVRhZ3MoKTtcbiAgICBpZiAoIXRoaXMucHVibGlzaGVkX2F0KSB7XG4gICAgICB0aGlzLnB1Ymxpc2hlZF9hdCA9IHRoaXMuY3JlYXRlZF9hdDtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmdlbmVyYXRlVGFncygpO1xuICB9XG59O1xuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL2RyYWZ0cy50c1xudmFyIE5ES0RyYWZ0ID0gY2xhc3MgX05ES0RyYWZ0IGV4dGVuZHMgTkRLRXZlbnQge1xuICBfZXZlbnQ7XG4gIGNvbnN0cnVjdG9yKG5kaywgcmF3RXZlbnQpIHtcbiAgICBzdXBlcihuZGssIHJhd0V2ZW50KTtcbiAgICB0aGlzLmtpbmQgPz89IDMxMjM0IC8qIERyYWZ0ICovO1xuICB9XG4gIHN0YXRpYyBmcm9tKGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLRHJhZnQoZXZlbnQubmRrLCBldmVudCk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgYW4gaWRlbnRpZmllciAoaS5lLiBkLXRhZylcbiAgICovXG4gIHNldCBpZGVudGlmaWVyKGlkKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJkXCIpO1xuICAgIHRoaXMudGFncy5wdXNoKFtcImRcIiwgaWRdKTtcbiAgfVxuICBnZXQgaWRlbnRpZmllcigpIHtcbiAgICByZXR1cm4gdGhpcy5kVGFnO1xuICB9XG4gIC8qKlxuICAgKiBFdmVudCB0aGF0IGlzIHRvIGJlIHNhdmVkLlxuICAgKi9cbiAgc2V0IGV2ZW50KGUpIHtcbiAgICBpZiAoZSBpbnN0YW5jZW9mIE5ES0V2ZW50KSB0aGlzLl9ldmVudCA9IGUucmF3RXZlbnQoKTtcbiAgICBlbHNlIHRoaXMuX2V2ZW50ID0gZTtcbiAgICB0aGlzLnByZXBhcmVFdmVudCgpO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBldmVudC5cbiAgICogQHBhcmFtIHBhcmFtMFxuICAgKiBAcmV0dXJucyBOREtFdmVudCBvZiB0aGUgZHJhZnQgZXZlbnQgb3IgbnVsbCBpZiB0aGUgZHJhZnQgZXZlbnQgaGFzIGJlZW4gZGVsZXRlZCAoZW1wdGllZCkuXG4gICAqL1xuICBhc3luYyBnZXRFdmVudChzaWduZXIpIHtcbiAgICBpZiAodGhpcy5fZXZlbnQpIHJldHVybiBuZXcgTkRLRXZlbnQodGhpcy5uZGssIHRoaXMuX2V2ZW50KTtcbiAgICBzaWduZXIgPz89IHRoaXMubmRrPy5zaWduZXI7XG4gICAgaWYgKCFzaWduZXIpIHRocm93IG5ldyBFcnJvcihcIk5vIHNpZ25lciBhdmFpbGFibGVcIik7XG4gICAgY29uc3QgdXNlciA9IGF3YWl0IHNpZ25lci51c2VyKCk7XG4gICAgaWYgKHRoaXMuY29udGVudCAmJiB0aGlzLmNvbnRlbnQubGVuZ3RoID4gMCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5kZWNyeXB0KHVzZXIsIHNpZ25lcik7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSBKU09OLnBhcnNlKHRoaXMuY29udGVudCk7XG4gICAgICAgIHRoaXMuX2V2ZW50ID0gcGF5bG9hZDtcbiAgICAgICAgcmV0dXJuIG5ldyBOREtFdmVudCh0aGlzLm5kaywgcGF5bG9hZCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBwcmVwYXJlRXZlbnQoKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudCkgdGhyb3cgbmV3IEVycm9yKFwiTm8gZXZlbnQgaGFzIGJlZW4gcHJvdmlkZWRcIik7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJrXCIpO1xuICAgIGlmICh0aGlzLl9ldmVudC5raW5kKSB0aGlzLnRhZ3MucHVzaChbXCJrXCIsIHRoaXMuX2V2ZW50LmtpbmQudG9TdHJpbmcoKV0pO1xuICAgIHRoaXMuY29udGVudCA9IEpTT04uc3RyaW5naWZ5KHRoaXMuX2V2ZW50KTtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGRyYWZ0IGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0gc2lnbmVyOiBPcHRpb25hbCBzaWduZXIgdG8gZW5jcnlwdCB3aXRoXG4gICAqIEBwYXJhbSBwdWJsaXNoOiBXaGV0aGVyIHRvIHB1Ymxpc2gsIG9wdGlvbmFsbHkgc3BlY2lmeWluZyByZWxheVNldCB0byBwdWJsaXNoIHRvXG4gICAqL1xuICBhc3luYyBzYXZlKHtcbiAgICBzaWduZXIsXG4gICAgcHVibGlzaCxcbiAgICByZWxheVNldFxuICB9KSB7XG4gICAgc2lnbmVyID8/PSB0aGlzLm5kaz8uc2lnbmVyO1xuICAgIGlmICghc2lnbmVyKSB0aHJvdyBuZXcgRXJyb3IoXCJObyBzaWduZXIgYXZhaWxhYmxlXCIpO1xuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCBzaWduZXIudXNlcigpO1xuICAgIGF3YWl0IHRoaXMuZW5jcnlwdCh1c2VyLCBzaWduZXIpO1xuICAgIGlmIChwdWJsaXNoID09PSBmYWxzZSkgcmV0dXJuO1xuICAgIHJldHVybiB0aGlzLnB1Ymxpc2gocmVsYXlTZXQpO1xuICB9XG59O1xuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL2R2bS9mZWVkYmFjay50c1xudmFyIE5ES0R2bUpvYkZlZWRiYWNrU3RhdHVzID0gLyogQF9fUFVSRV9fICovICgoTkRLRHZtSm9iRmVlZGJhY2tTdGF0dXMyKSA9PiB7XG4gIE5ES0R2bUpvYkZlZWRiYWNrU3RhdHVzMltcIlByb2Nlc3NpbmdcIl0gPSBcInByb2Nlc3NpbmdcIjtcbiAgTkRLRHZtSm9iRmVlZGJhY2tTdGF0dXMyW1wiU3VjY2Vzc1wiXSA9IFwic3VjY2Vzc1wiO1xuICBOREtEdm1Kb2JGZWVkYmFja1N0YXR1czJbXCJTY2hlZHVsZWRcIl0gPSBcInNjaGVkdWxlZFwiO1xuICBOREtEdm1Kb2JGZWVkYmFja1N0YXR1czJbXCJQYXlSZXFcIl0gPSBcInBheW1lbnRfcmVxdWlyZWRcIjtcbiAgcmV0dXJuIE5ES0R2bUpvYkZlZWRiYWNrU3RhdHVzMjtcbn0pKE5ES0R2bUpvYkZlZWRiYWNrU3RhdHVzIHx8IHt9KTtcbnZhciBOREtEVk1Kb2JGZWVkYmFjayA9IGNsYXNzIF9OREtEVk1Kb2JGZWVkYmFjayBleHRlbmRzIE5ES0V2ZW50IHtcbiAgY29uc3RydWN0b3IobmRrLCBldmVudCkge1xuICAgIHN1cGVyKG5kaywgZXZlbnQpO1xuICAgIHRoaXMua2luZCA/Pz0gN2UzIC8qIERWTUpvYkZlZWRiYWNrICovO1xuICB9XG4gIHN0YXRpYyBhc3luYyBmcm9tKGV2ZW50KSB7XG4gICAgY29uc3QgZSA9IG5ldyBfTkRLRFZNSm9iRmVlZGJhY2soZXZlbnQubmRrLCBldmVudC5yYXdFdmVudCgpKTtcbiAgICBpZiAoZS5lbmNyeXB0ZWQpIGF3YWl0IGUuZHZtRGVjcnlwdCgpO1xuICAgIHJldHVybiBlO1xuICB9XG4gIGdldCBzdGF0dXMoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJzdGF0dXNcIik7XG4gIH1cbiAgc2V0IHN0YXR1cyhzdGF0dXMpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInN0YXR1c1wiKTtcbiAgICBpZiAoc3RhdHVzICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcInN0YXR1c1wiLCBzdGF0dXNdKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGVuY3J5cHRlZCgpIHtcbiAgICByZXR1cm4gISF0aGlzLmdldE1hdGNoaW5nVGFncyhcImVuY3J5cHRlZFwiKVswXTtcbiAgfVxuICBhc3luYyBkdm1EZWNyeXB0KCkge1xuICAgIGF3YWl0IHRoaXMuZGVjcnlwdCgpO1xuICAgIGNvbnN0IGRlY3J5cHRlZENvbnRlbnQgPSBKU09OLnBhcnNlKHRoaXMuY29udGVudCk7XG4gICAgdGhpcy50YWdzLnB1c2goLi4uZGVjcnlwdGVkQ29udGVudCk7XG4gIH1cbn07XG5cbi8vIHNyYy9ldmVudHMva2luZHMvZHZtL3JlcXVlc3QudHNcbnZhciBOREtEVk1SZXF1ZXN0ID0gY2xhc3MgX05ES0RWTVJlcXVlc3QgZXh0ZW5kcyBOREtFdmVudCB7XG4gIGNvbnN0cnVjdG9yKG5kaywgZXZlbnQpIHtcbiAgICBzdXBlcihuZGssIGV2ZW50KTtcbiAgfVxuICBzdGF0aWMgZnJvbShldmVudCkge1xuICAgIHJldHVybiBuZXcgX05ES0RWTVJlcXVlc3QoZXZlbnQubmRrLCBldmVudC5yYXdFdmVudCgpKTtcbiAgfVxuICBzZXQgYmlkKG1zYXRBbW91bnQpIHtcbiAgICBpZiAobXNhdEFtb3VudCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnJlbW92ZVRhZyhcImJpZFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wiYmlkXCIsIG1zYXRBbW91bnQudG9TdHJpbmcoKV0pO1xuICAgIH1cbiAgfVxuICBnZXQgYmlkKCkge1xuICAgIGNvbnN0IHYgPSB0aGlzLnRhZ1ZhbHVlKFwiYmlkXCIpO1xuICAgIGlmICh2ID09PSB2b2lkIDApIHJldHVybiB2b2lkIDA7XG4gICAgcmV0dXJuIHBhcnNlSW50KHYpO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGEgbmV3IGlucHV0IHRvIHRoZSBqb2JcbiAgICogQHBhcmFtIGFyZ3MgVGhlIGFyZ3VtZW50cyB0byB0aGUgaW5wdXRcbiAgICovXG4gIGFkZElucHV0KC4uLmFyZ3MpIHtcbiAgICB0aGlzLnRhZ3MucHVzaChbXCJpXCIsIC4uLmFyZ3NdKTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIG5ldyBwYXJhbWV0ZXIgdG8gdGhlIGpvYlxuICAgKi9cbiAgYWRkUGFyYW0oLi4uYXJncykge1xuICAgIHRoaXMudGFncy5wdXNoKFtcInBhcmFtXCIsIC4uLmFyZ3NdKTtcbiAgfVxuICBzZXQgb3V0cHV0KG91dHB1dCkge1xuICAgIGlmIChvdXRwdXQgPT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5yZW1vdmVUYWcoXCJvdXRwdXRcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2Ygb3V0cHV0ID09PSBcInN0cmluZ1wiKSBvdXRwdXQgPSBbb3V0cHV0XTtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcIm91dHB1dFwiLCAuLi5vdXRwdXRdKTtcbiAgICB9XG4gIH1cbiAgZ2V0IG91dHB1dCgpIHtcbiAgICBjb25zdCBvdXRwdXRUYWcgPSB0aGlzLmdldE1hdGNoaW5nVGFncyhcIm91dHB1dFwiKVswXTtcbiAgICByZXR1cm4gb3V0cHV0VGFnID8gb3V0cHV0VGFnLnNsaWNlKDEpIDogdm9pZCAwO1xuICB9XG4gIGdldCBwYXJhbXMoKSB7XG4gICAgY29uc3QgcGFyYW1UYWdzID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJwYXJhbVwiKTtcbiAgICByZXR1cm4gcGFyYW1UYWdzLm1hcCgodCkgPT4gdC5zbGljZSgxKSk7XG4gIH1cbiAgZ2V0UGFyYW0obmFtZSkge1xuICAgIGNvbnN0IHBhcmFtVGFnID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJwYXJhbVwiKS5maW5kKCh0KSA9PiB0WzFdID09PSBuYW1lKTtcbiAgICByZXR1cm4gcGFyYW1UYWcgPyBwYXJhbVRhZ1syXSA6IHZvaWQgMDtcbiAgfVxuICBjcmVhdGVGZWVkYmFjayhzdGF0dXMpIHtcbiAgICBjb25zdCBmZWVkYmFjayA9IG5ldyBOREtEVk1Kb2JGZWVkYmFjayh0aGlzLm5kayk7XG4gICAgZmVlZGJhY2sudGFnKHRoaXMsIFwiam9iXCIpO1xuICAgIGZlZWRiYWNrLnN0YXR1cyA9IHN0YXR1cztcbiAgICByZXR1cm4gZmVlZGJhY2s7XG4gIH1cbiAgLyoqXG4gICAqIEVuYWJsZXMgam9iIGVuY3J5cHRpb24gZm9yIHRoaXMgZXZlbnRcbiAgICogQHBhcmFtIGR2bSBEVk0gdGhhdCB3aWxsIHJlY2VpdmUgdGhlIGV2ZW50XG4gICAqIEBwYXJhbSBzaWduZXIgU2lnbmVyIHRvIHVzZSBmb3IgZW5jcnlwdGlvblxuICAgKi9cbiAgYXN5bmMgZW5jcnlwdGlvbihkdm0sIHNpZ25lcikge1xuICAgIGNvbnN0IGR2bVRhZ3MgPSBbXCJpXCIsIFwicGFyYW1cIiwgXCJvdXRwdXRcIiwgXCJyZWxheXNcIiwgXCJiaWRcIl07XG4gICAgY29uc3QgdGFncyA9IHRoaXMudGFncy5maWx0ZXIoKHQpID0+IGR2bVRhZ3MuaW5jbHVkZXModFswXSkpO1xuICAgIHRoaXMudGFncyA9IHRoaXMudGFncy5maWx0ZXIoKHQpID0+ICFkdm1UYWdzLmluY2x1ZGVzKHRbMF0pKTtcbiAgICB0aGlzLmNvbnRlbnQgPSBKU09OLnN0cmluZ2lmeSh0YWdzKTtcbiAgICB0aGlzLnRhZyhkdm0pO1xuICAgIHRoaXMudGFncy5wdXNoKFtcImVuY3J5cHRlZFwiXSk7XG4gICAgYXdhaXQgdGhpcy5lbmNyeXB0KGR2bSwgc2lnbmVyKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgRFZNIHRoYXQgd2lsbCByZWNlaXZlIHRoZSBldmVudFxuICAgKi9cbiAgc2V0IGR2bShkdm0pIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInBcIik7XG4gICAgaWYgKGR2bSkgdGhpcy50YWcoZHZtKTtcbiAgfVxufTtcblxuLy8gc3JjL2V2ZW50cy9raW5kcy9kdm0vTkRLVHJhbnNjcmlwdGlvbkRWTS50c1xudmFyIE5ES1RyYW5zY3JpcHRpb25EVk0gPSBjbGFzcyBfTkRLVHJhbnNjcmlwdGlvbkRWTSBleHRlbmRzIE5ES0RWTVJlcXVlc3Qge1xuICBjb25zdHJ1Y3RvcihuZGssIGV2ZW50KSB7XG4gICAgc3VwZXIobmRrLCBldmVudCk7XG4gICAgdGhpcy5raW5kID0gNWUzIC8qIERWTVJlcVRleHRFeHRyYWN0aW9uICovO1xuICB9XG4gIHN0YXRpYyBmcm9tKGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLVHJhbnNjcmlwdGlvbkRWTShldmVudC5uZGssIGV2ZW50LnJhd0V2ZW50KCkpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2Ugb2YgdGhlIHRyYW5zY3JpcHRpb25cbiAgICovXG4gIGdldCB1cmwoKSB7XG4gICAgY29uc3QgaW5wdXRUYWdzID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJpXCIpO1xuICAgIGlmIChpbnB1dFRhZ3MubGVuZ3RoICE9PSAxKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gaW5wdXRUYWdzWzBdWzFdO1xuICB9XG4gIC8qKlxuICAgKiBHZXR0ZXIgZm9yIHRoZSB0aXRsZSB0YWdcbiAgICovXG4gIGdldCB0aXRsZSgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcInRpdGxlXCIpO1xuICB9XG4gIC8qKlxuICAgKiBTZXR0ZXIgZm9yIHRoZSB0aXRsZSB0YWdcbiAgICovXG4gIHNldCB0aXRsZSh2YWx1ZSkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwidGl0bGVcIik7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJ0aXRsZVwiLCB2YWx1ZV0pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogR2V0dGVyIGZvciB0aGUgaW1hZ2UgdGFnXG4gICAqL1xuICBnZXQgaW1hZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJpbWFnZVwiKTtcbiAgfVxuICAvKipcbiAgICogU2V0dGVyIGZvciB0aGUgaW1hZ2UgdGFnXG4gICAqL1xuICBzZXQgaW1hZ2UodmFsdWUpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImltYWdlXCIpO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wiaW1hZ2VcIiwgdmFsdWVdKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9ldmVudHMva2luZHMvZHZtL3Jlc3VsdC50c1xudmFyIE5ES0RWTUpvYlJlc3VsdCA9IGNsYXNzIF9OREtEVk1Kb2JSZXN1bHQgZXh0ZW5kcyBOREtFdmVudCB7XG4gIGNvbnN0cnVjdG9yKG5kaywgZXZlbnQpIHtcbiAgICBzdXBlcihuZGssIGV2ZW50KTtcbiAgfVxuICBzdGF0aWMgZnJvbShldmVudCkge1xuICAgIHJldHVybiBuZXcgX05ES0RWTUpvYlJlc3VsdChldmVudC5uZGssIGV2ZW50LnJhd0V2ZW50KCkpO1xuICB9XG4gIHNldEFtb3VudChtc2F0LCBpbnZvaWNlKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJhbW91bnRcIik7XG4gICAgY29uc3QgdGFnID0gW1wiYW1vdW50XCIsIG1zYXQudG9TdHJpbmcoKV07XG4gICAgaWYgKGludm9pY2UpIHRhZy5wdXNoKGludm9pY2UpO1xuICAgIHRoaXMudGFncy5wdXNoKHRhZyk7XG4gIH1cbiAgc2V0IHJlc3VsdChyZXN1bHQpIHtcbiAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIHtcbiAgICAgIHRoaXMuY29udGVudCA9IFwiXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29udGVudCA9IHJlc3VsdDtcbiAgICB9XG4gIH1cbiAgZ2V0IHJlc3VsdCgpIHtcbiAgICBpZiAodGhpcy5jb250ZW50ID09PSBcIlwiKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250ZW50O1xuICB9XG4gIHNldCBzdGF0dXMoc3RhdHVzKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJzdGF0dXNcIik7XG4gICAgaWYgKHN0YXR1cyAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJzdGF0dXNcIiwgc3RhdHVzXSk7XG4gICAgfVxuICB9XG4gIGdldCBzdGF0dXMoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJzdGF0dXNcIik7XG4gIH1cbiAgZ2V0IGpvYlJlcXVlc3RJZCgpIHtcbiAgICBmb3IgKGNvbnN0IGVUYWcgb2YgdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJlXCIpKSB7XG4gICAgICBpZiAoZVRhZ1syXSA9PT0gXCJqb2JcIikgcmV0dXJuIGVUYWdbMV07XG4gICAgfVxuICAgIGlmICh0aGlzLmpvYlJlcXVlc3QpIHJldHVybiB0aGlzLmpvYlJlcXVlc3QuaWQ7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJlXCIpO1xuICB9XG4gIHNldCBqb2JSZXF1ZXN0KGV2ZW50KSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJyZXF1ZXN0XCIpO1xuICAgIGlmIChldmVudCkge1xuICAgICAgdGhpcy5raW5kID0gZXZlbnQua2luZCArIDFlMztcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcInJlcXVlc3RcIiwgSlNPTi5zdHJpbmdpZnkoZXZlbnQucmF3RXZlbnQoKSldKTtcbiAgICAgIHRoaXMudGFnKGV2ZW50KTtcbiAgICB9XG4gIH1cbiAgZ2V0IGpvYlJlcXVlc3QoKSB7XG4gICAgY29uc3QgdGFnID0gdGhpcy50YWdWYWx1ZShcInJlcXVlc3RcIik7XG4gICAgaWYgKHRhZyA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE5ES0V2ZW50KHRoaXMubmRrLCBKU09OLnBhcnNlKHRhZykpO1xuICB9XG59O1xuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL2Nhc2h1L3R4LnRzXG52YXIgTUFSS0VSUyA9IHtcbiAgUkVERUVNRUQ6IFwicmVkZWVtZWRcIixcbiAgQ1JFQVRFRDogXCJjcmVhdGVkXCIsXG4gIERFU1RST1lFRDogXCJkZXN0cm95ZWRcIixcbiAgUkVTRVJWRUQ6IFwicmVzZXJ2ZWRcIlxufTtcbnZhciBOREtDYXNodVdhbGxldFR4ID0gY2xhc3MgX05ES0Nhc2h1V2FsbGV0VHggZXh0ZW5kcyBOREtFdmVudCB7XG4gIHN0YXRpYyBNQVJLRVJTID0gTUFSS0VSUztcbiAgc3RhdGljIGtpbmQgPSA3Mzc2IC8qIENhc2h1V2FsbGV0VHggKi87XG4gIHN0YXRpYyBraW5kcyA9IFs3Mzc2IC8qIENhc2h1V2FsbGV0VHggKi9dO1xuICBjb25zdHJ1Y3RvcihuZGssIGV2ZW50KSB7XG4gICAgc3VwZXIobmRrLCBldmVudCk7XG4gICAgdGhpcy5raW5kID8/PSA3Mzc2IC8qIENhc2h1V2FsbGV0VHggKi87XG4gIH1cbiAgc3RhdGljIGFzeW5jIGZyb20oZXZlbnQpIHtcbiAgICBjb25zdCB3YWxsZXRDaGFuZ2UgPSBuZXcgX05ES0Nhc2h1V2FsbGV0VHgoZXZlbnQubmRrLCBldmVudCk7XG4gICAgY29uc3QgcHJldkNvbnRlbnQgPSB3YWxsZXRDaGFuZ2UuY29udGVudDtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgd2FsbGV0Q2hhbmdlLmRlY3J5cHQoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB3YWxsZXRDaGFuZ2UuY29udGVudCA/Pz0gcHJldkNvbnRlbnQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBjb250ZW50VGFncyA9IEpTT04ucGFyc2Uod2FsbGV0Q2hhbmdlLmNvbnRlbnQpO1xuICAgICAgd2FsbGV0Q2hhbmdlLnRhZ3MgPSBbLi4uY29udGVudFRhZ3MsIC4uLndhbGxldENoYW5nZS50YWdzXTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiB3YWxsZXRDaGFuZ2U7XG4gIH1cbiAgc2V0IGRpcmVjdGlvbihkaXJlY3Rpb24pIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImRpcmVjdGlvblwiKTtcbiAgICBpZiAoZGlyZWN0aW9uKSB0aGlzLnRhZ3MucHVzaChbXCJkaXJlY3Rpb25cIiwgZGlyZWN0aW9uXSk7XG4gIH1cbiAgZ2V0IGRpcmVjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcImRpcmVjdGlvblwiKTtcbiAgfVxuICBzZXQgYW1vdW50KGFtb3VudCkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwiYW1vdW50XCIpO1xuICAgIHRoaXMudGFncy5wdXNoKFtcImFtb3VudFwiLCBhbW91bnQudG9TdHJpbmcoKV0pO1xuICB9XG4gIGdldCBhbW91bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJhbW91bnRcIik7XG4gIH1cbiAgc2V0IGZlZShmZWUpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImZlZVwiKTtcbiAgICB0aGlzLnRhZ3MucHVzaChbXCJmZWVcIiwgZmVlLnRvU3RyaW5nKCldKTtcbiAgfVxuICBnZXQgZmVlKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwiZmVlXCIpO1xuICB9XG4gIHNldCB1bml0KHVuaXQpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInVuaXRcIik7XG4gICAgaWYgKHVuaXQpIHRoaXMudGFncy5wdXNoKFtcInVuaXRcIiwgdW5pdC50b1N0cmluZygpXSk7XG4gIH1cbiAgZ2V0IHVuaXQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnVmFsdWUoXCJ1bml0XCIpO1xuICB9XG4gIHNldCBkZXNjcmlwdGlvbihkZXNjcmlwdGlvbikge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwiZGVzY3JpcHRpb25cIik7XG4gICAgaWYgKGRlc2NyaXB0aW9uKSB0aGlzLnRhZ3MucHVzaChbXCJkZXNjcmlwdGlvblwiLCBkZXNjcmlwdGlvbi50b1N0cmluZygpXSk7XG4gIH1cbiAgZ2V0IGRlc2NyaXB0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlKFwiZGVzY3JpcHRpb25cIik7XG4gIH1cbiAgc2V0IG1pbnQobWludCkge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwibWludFwiKTtcbiAgICBpZiAobWludCkgdGhpcy50YWdzLnB1c2goW1wibWludFwiLCBtaW50LnRvU3RyaW5nKCldKTtcbiAgfVxuICBnZXQgbWludCgpIHtcbiAgICByZXR1cm4gdGhpcy50YWdWYWx1ZShcIm1pbnRcIik7XG4gIH1cbiAgLyoqXG4gICAqIFRhZ3MgdG9rZW5zIHRoYXQgd2VyZSBjcmVhdGVkIGluIHRoaXMgaGlzdG9yeSBldmVudFxuICAgKi9cbiAgc2V0IGRlc3Ryb3llZFRva2VucyhldmVudHMpIHtcbiAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIGV2ZW50cykge1xuICAgICAgdGhpcy50YWdzLnB1c2goZXZlbnQudGFnUmVmZXJlbmNlKE1BUktFUlMuREVTVFJPWUVEKSk7XG4gICAgfVxuICB9XG4gIHNldCBkZXN0cm95ZWRUb2tlbklkcyhpZHMpIHtcbiAgICBmb3IgKGNvbnN0IGlkIG9mIGlkcykge1xuICAgICAgdGhpcy50YWdzLnB1c2goW1wiZVwiLCBpZCwgXCJcIiwgTUFSS0VSUy5ERVNUUk9ZRURdKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFRhZ3MgdG9rZW5zIHRoYXQgd2VyZSBjcmVhdGVkIGluIHRoaXMgaGlzdG9yeSBldmVudFxuICAgKi9cbiAgc2V0IGNyZWF0ZWRUb2tlbnMoZXZlbnRzKSB7XG4gICAgZm9yIChjb25zdCBldmVudCBvZiBldmVudHMpIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKGV2ZW50LnRhZ1JlZmVyZW5jZShNQVJLRVJTLkNSRUFURUQpKTtcbiAgICB9XG4gIH1cbiAgc2V0IHJlc2VydmVkVG9rZW5zKGV2ZW50cykge1xuICAgIGZvciAoY29uc3QgZXZlbnQgb2YgZXZlbnRzKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChldmVudC50YWdSZWZlcmVuY2UoTUFSS0VSUy5SRVNFUlZFRCkpO1xuICAgIH1cbiAgfVxuICBhZGRSZWRlZW1lZE51dHphcChldmVudCkge1xuICAgIHRoaXMudGFnKGV2ZW50LCBNQVJLRVJTLlJFREVFTUVEKTtcbiAgfVxuICBhc3luYyB0b05vc3RyRXZlbnQocHVia2V5KSB7XG4gICAgY29uc3QgZW5jcnlwdGVkVGFncyA9IFtdO1xuICAgIGNvbnN0IHVuZW5jcnlwdGVkVGFncyA9IFtdO1xuICAgIGZvciAoY29uc3QgdGFnIG9mIHRoaXMudGFncykge1xuICAgICAgaWYgKCF0aGlzLnNob3VsZEVuY3J5cHRUYWcodGFnKSkge1xuICAgICAgICB1bmVuY3J5cHRlZFRhZ3MucHVzaCh0YWcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5jcnlwdGVkVGFncy5wdXNoKHRhZyk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudGFncyA9IHVuZW5jcnlwdGVkVGFncy5maWx0ZXIoKHQpID0+IHRbMF0gIT09IFwiY2xpZW50XCIpO1xuICAgIHRoaXMuY29udGVudCA9IEpTT04uc3RyaW5naWZ5KGVuY3J5cHRlZFRhZ3MpO1xuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLm5kay5zaWduZXIudXNlcigpO1xuICAgIGF3YWl0IHRoaXMuZW5jcnlwdCh1c2VyLCB2b2lkIDAsIFwibmlwNDRcIik7XG4gICAgcmV0dXJuIHN1cGVyLnRvTm9zdHJFdmVudChwdWJrZXkpO1xuICB9XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoaXMgZW50cnkgaW5jbHVkZXMgYSByZWRlbXB0aW9uIG9mIGEgTnV0emFwXG4gICAqL1xuICBnZXQgaGFzTnV0emFwUmVkZW1wdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJlXCIsIE1BUktFUlMuUkVERUVNRUQpLmxlbmd0aCA+IDA7XG4gIH1cbiAgc2hvdWxkRW5jcnlwdFRhZyh0YWcpIHtcbiAgICBjb25zdCB1bmVuY3J5cHRlZFRhZ05hbWVzID0gW1wiY2xpZW50XCJdO1xuICAgIGlmICh1bmVuY3J5cHRlZFRhZ05hbWVzLmluY2x1ZGVzKHRhZ1swXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRhZ1swXSA9PT0gXCJlXCIgJiYgdGFnWzNdID09PSBNQVJLRVJTLlJFREVFTUVEKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0YWdbMF0gPT09IFwicFwiKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cbi8vIHNyYy9ldmVudHMva2luZHMvTkRLUmVsYXlMaXN0LnRzXG52YXIgUkVBRF9NQVJLRVIgPSBcInJlYWRcIjtcbnZhciBXUklURV9NQVJLRVIgPSBcIndyaXRlXCI7XG52YXIgTkRLUmVsYXlMaXN0ID0gY2xhc3MgX05ES1JlbGF5TGlzdCBleHRlbmRzIE5ES0V2ZW50IHtcbiAgY29uc3RydWN0b3IobmRrLCByYXdFdmVudCkge1xuICAgIHN1cGVyKG5kaywgcmF3RXZlbnQpO1xuICAgIHRoaXMua2luZCA/Pz0gMTAwMDIgLyogUmVsYXlMaXN0ICovO1xuICB9XG4gIHN0YXRpYyBmcm9tKG5ka0V2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLUmVsYXlMaXN0KG5ka0V2ZW50Lm5kaywgbmRrRXZlbnQucmF3RXZlbnQoKSk7XG4gIH1cbiAgZ2V0IHJlYWRSZWxheVVybHMoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFncy5maWx0ZXIoKHRhZykgPT4gdGFnWzBdID09PSBcInJcIiB8fCB0YWdbMF0gPT09IFwicmVsYXlcIikuZmlsdGVyKCh0YWcpID0+ICF0YWdbMl0gfHwgdGFnWzJdICYmIHRhZ1syXSA9PT0gUkVBRF9NQVJLRVIpLm1hcCgodGFnKSA9PiB0cnlOb3JtYWxpemVSZWxheVVybCh0YWdbMV0pKS5maWx0ZXIoKHVybCkgPT4gISF1cmwpO1xuICB9XG4gIHNldCByZWFkUmVsYXlVcmxzKHJlbGF5cykge1xuICAgIGZvciAoY29uc3QgcmVsYXkgb2YgcmVsYXlzKSB7XG4gICAgICB0aGlzLnRhZ3MucHVzaChbXCJyXCIsIHJlbGF5LCBSRUFEX01BUktFUl0pO1xuICAgIH1cbiAgfVxuICBnZXQgd3JpdGVSZWxheVVybHMoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFncy5maWx0ZXIoKHRhZykgPT4gdGFnWzBdID09PSBcInJcIiB8fCB0YWdbMF0gPT09IFwicmVsYXlcIikuZmlsdGVyKCh0YWcpID0+ICF0YWdbMl0gfHwgdGFnWzJdICYmIHRhZ1syXSA9PT0gV1JJVEVfTUFSS0VSKS5tYXAoKHRhZykgPT4gdHJ5Tm9ybWFsaXplUmVsYXlVcmwodGFnWzFdKSkuZmlsdGVyKCh1cmwpID0+ICEhdXJsKTtcbiAgfVxuICBzZXQgd3JpdGVSZWxheVVybHMocmVsYXlzKSB7XG4gICAgZm9yIChjb25zdCByZWxheSBvZiByZWxheXMpIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcInJcIiwgcmVsYXksIFdSSVRFX01BUktFUl0pO1xuICAgIH1cbiAgfVxuICBnZXQgYm90aFJlbGF5VXJscygpIHtcbiAgICByZXR1cm4gdGhpcy50YWdzLmZpbHRlcigodGFnKSA9PiB0YWdbMF0gPT09IFwiclwiIHx8IHRhZ1swXSA9PT0gXCJyZWxheVwiKS5maWx0ZXIoKHRhZykgPT4gIXRhZ1syXSkubWFwKCh0YWcpID0+IHRhZ1sxXSk7XG4gIH1cbiAgc2V0IGJvdGhSZWxheVVybHMocmVsYXlzKSB7XG4gICAgZm9yIChjb25zdCByZWxheSBvZiByZWxheXMpIHtcbiAgICAgIHRoaXMudGFncy5wdXNoKFtcInJcIiwgcmVsYXldKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHJlbGF5cygpIHtcbiAgICByZXR1cm4gdGhpcy50YWdzLmZpbHRlcigodGFnKSA9PiB0YWdbMF0gPT09IFwiclwiIHx8IHRhZ1swXSA9PT0gXCJyZWxheVwiKS5tYXAoKHRhZykgPT4gdGFnWzFdKTtcbiAgfVxuICAvKipcbiAgICogUHJvdmlkZXMgYSByZWxheVNldCBmb3IgdGhlIHJlbGF5cyBpbiB0aGlzIGxpc3QuXG4gICAqL1xuICBnZXQgcmVsYXlTZXQoKSB7XG4gICAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTkRLUmVsYXlMaXN0IGhhcyBubyBOREsgaW5zdGFuY2VcIik7XG4gICAgcmV0dXJuIG5ldyBOREtSZWxheVNldChcbiAgICAgIG5ldyBTZXQodGhpcy5yZWxheXMubWFwKCh1KSA9PiB0aGlzLm5kay5wb29sLmdldFJlbGF5KHUpKSksXG4gICAgICB0aGlzLm5ka1xuICAgICk7XG4gIH1cbn07XG5mdW5jdGlvbiByZWxheUxpc3RGcm9tS2luZDMobmRrLCBjb250YWN0TGlzdCkge1xuICB0cnkge1xuICAgIGNvbnN0IGNvbnRlbnQgPSBKU09OLnBhcnNlKGNvbnRhY3RMaXN0LmNvbnRlbnQpO1xuICAgIGNvbnN0IHJlbGF5TGlzdCA9IG5ldyBOREtSZWxheUxpc3QobmRrKTtcbiAgICBjb25zdCByZWFkUmVsYXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBjb25zdCB3cml0ZVJlbGF5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgZm9yIChsZXQgW2tleSwgY29uZmlnXSBvZiBPYmplY3QuZW50cmllcyhjb250ZW50KSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAga2V5ID0gbm9ybWFsaXplUmVsYXlVcmwoa2V5KTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICghY29uZmlnKSB7XG4gICAgICAgIHJlYWRSZWxheXMuYWRkKGtleSk7XG4gICAgICAgIHdyaXRlUmVsYXlzLmFkZChrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcmVsYXlDb25maWcgPSBjb25maWc7XG4gICAgICAgIGlmIChyZWxheUNvbmZpZy53cml0ZSkgd3JpdGVSZWxheXMuYWRkKGtleSk7XG4gICAgICAgIGlmIChyZWxheUNvbmZpZy5yZWFkKSByZWFkUmVsYXlzLmFkZChrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZWxheUxpc3QucmVhZFJlbGF5VXJscyA9IEFycmF5LmZyb20ocmVhZFJlbGF5cyk7XG4gICAgcmVsYXlMaXN0LndyaXRlUmVsYXlVcmxzID0gQXJyYXkuZnJvbSh3cml0ZVJlbGF5cyk7XG4gICAgcmV0dXJuIHJlbGF5TGlzdDtcbiAgfSBjYXRjaCB7XG4gIH1cbiAgcmV0dXJuIHZvaWQgMDtcbn1cblxuLy8gc3JjL2V2ZW50cy9raW5kcy9uaXA4OS9OREtBcHBIYW5kbGVyLnRzXG52YXIgTkRLQXBwSGFuZGxlckV2ZW50ID0gY2xhc3MgX05ES0FwcEhhbmRsZXJFdmVudCBleHRlbmRzIE5ES0V2ZW50IHtcbiAgcHJvZmlsZTtcbiAgY29uc3RydWN0b3IobmRrLCByYXdFdmVudCkge1xuICAgIHN1cGVyKG5kaywgcmF3RXZlbnQpO1xuICAgIHRoaXMua2luZCA/Pz0gMzE5OTAgLyogQXBwSGFuZGxlciAqLztcbiAgfVxuICBzdGF0aWMgZnJvbShuZGtFdmVudCkge1xuICAgIHJldHVybiBuZXcgX05ES0FwcEhhbmRsZXJFdmVudChuZGtFdmVudC5uZGssIG5ka0V2ZW50LnJhd0V2ZW50KCkpO1xuICB9XG4gIC8qKlxuICAgKiBGZXRjaGVzIGFwcCBoYW5kbGVyIGluZm9ybWF0aW9uXG4gICAqIElmIG5vIGFwcCBpbmZvcm1hdGlvbiBpcyBhdmFpbGFibGUgb24gdGhlIGtpbmQ6MzE5OTAsXG4gICAqIHdlIGZldGNoIHRoZSBldmVudCdzIGF1dGhvcidzIHByb2ZpbGUgYW5kIHJldHVybiB0aGF0IGluc3RlYWQuXG4gICAqL1xuICBhc3luYyBmZXRjaFByb2ZpbGUoKSB7XG4gICAgaWYgKHRoaXMucHJvZmlsZSA9PT0gdm9pZCAwICYmIHRoaXMuY29udGVudC5sZW5ndGggPiAwKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBwcm9maWxlID0gSlNPTi5wYXJzZSh0aGlzLmNvbnRlbnQpO1xuICAgICAgICBpZiAocHJvZmlsZSAmJiBwcm9maWxlLm5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gcHJvZmlsZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnByb2ZpbGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRoaXMucHJvZmlsZSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBhdXRob3IgPSB0aGlzLmF1dGhvcjtcbiAgICAgIGF1dGhvci5mZXRjaFByb2ZpbGUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgcmVzb2x2ZShhdXRob3IucHJvZmlsZSk7XG4gICAgICB9KS5jYXRjaChyZWplY3QpO1xuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL3JlcG9zdC50c1xudmFyIE5ES1JlcG9zdCA9IGNsYXNzIF9OREtSZXBvc3QgZXh0ZW5kcyBOREtFdmVudCB7XG4gIF9yZXBvc3RlZEV2ZW50cztcbiAgY29uc3RydWN0b3IobmRrLCByYXdFdmVudCkge1xuICAgIHN1cGVyKG5kaywgcmF3RXZlbnQpO1xuICB9XG4gIHN0YXRpYyBmcm9tKGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLUmVwb3N0KGV2ZW50Lm5kaywgZXZlbnQucmF3RXZlbnQoKSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIHJlcG9zdGVkIGV2ZW50cyBieSB0aGUgY3VycmVudCBldmVudC5cbiAgICpcbiAgICogQHBhcmFtIGtsYXNzIE9wdGlvbmFsIGNsYXNzIHRvIGNvbnZlcnQgdGhlIGV2ZW50cyB0by5cbiAgICogQHJldHVybnNcbiAgICovXG4gIGFzeW5jIHJlcG9zdGVkRXZlbnRzKGtsYXNzLCBvcHRzKSB7XG4gICAgY29uc3QgaXRlbXMgPSBbXTtcbiAgICBpZiAoIXRoaXMubmRrKSB0aHJvdyBuZXcgRXJyb3IoXCJOREsgaW5zdGFuY2Ugbm90IHNldFwiKTtcbiAgICBpZiAodGhpcy5fcmVwb3N0ZWRFdmVudHMgIT09IHZvaWQgMCkgcmV0dXJuIHRoaXMuX3JlcG9zdGVkRXZlbnRzO1xuICAgIGZvciAoY29uc3QgZXZlbnRJZCBvZiB0aGlzLnJlcG9zdGVkRXZlbnRJZHMoKSkge1xuICAgICAgY29uc3QgZmlsdGVyID0gZmlsdGVyRm9ySWQoZXZlbnRJZCk7XG4gICAgICBjb25zdCBldmVudCA9IGF3YWl0IHRoaXMubmRrLmZldGNoRXZlbnQoZmlsdGVyLCBvcHRzKTtcbiAgICAgIGlmIChldmVudCkge1xuICAgICAgICBpdGVtcy5wdXNoKGtsYXNzID8ga2xhc3MuZnJvbShldmVudCkgOiBldmVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpdGVtcztcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVwb3N0ZWQgZXZlbnQgSURzLlxuICAgKi9cbiAgcmVwb3N0ZWRFdmVudElkcygpIHtcbiAgICByZXR1cm4gdGhpcy50YWdzLmZpbHRlcigodCkgPT4gdFswXSA9PT0gXCJlXCIgfHwgdFswXSA9PT0gXCJhXCIpLm1hcCgodCkgPT4gdFsxXSk7XG4gIH1cbn07XG5mdW5jdGlvbiBmaWx0ZXJGb3JJZChpZCkge1xuICBpZiAoaWQubWF0Y2goLzovKSkge1xuICAgIGNvbnN0IFtraW5kLCBwdWJrZXksIGlkZW50aWZpZXJdID0gaWQuc3BsaXQoXCI6XCIpO1xuICAgIHJldHVybiB7XG4gICAgICBraW5kczogW3BhcnNlSW50KGtpbmQpXSxcbiAgICAgIGF1dGhvcnM6IFtwdWJrZXldLFxuICAgICAgXCIjZFwiOiBbaWRlbnRpZmllcl1cbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7IGlkczogW2lkXSB9O1xuICB9XG59XG5cbi8vIHNyYy9ldmVudHMva2luZHMvc3Vic2NyaXB0aW9ucy9yZWNlaXB0LnRzXG5pbXBvcnQgZGVidWczIGZyb20gXCJkZWJ1Z1wiO1xudmFyIE5ES1N1YnNjcmlwdGlvblJlY2VpcHQgPSBjbGFzcyBfTkRLU3Vic2NyaXB0aW9uUmVjZWlwdCBleHRlbmRzIE5ES0V2ZW50IHtcbiAgZGVidWc7XG4gIGNvbnN0cnVjdG9yKG5kaywgcmF3RXZlbnQpIHtcbiAgICBzdXBlcihuZGssIHJhd0V2ZW50KTtcbiAgICB0aGlzLmtpbmQgPz89IDcwMDMgLyogU3Vic2NyaXB0aW9uUmVjZWlwdCAqLztcbiAgICB0aGlzLmRlYnVnID0gbmRrPy5kZWJ1Zy5leHRlbmQoXCJzdWJzY3JpcHRpb24tc3RhcnRcIikgPz8gZGVidWczKFwibmRrOnN1YnNjcmlwdGlvbi1zdGFydFwiKTtcbiAgfVxuICBzdGF0aWMgZnJvbShldmVudCkge1xuICAgIHJldHVybiBuZXcgX05ES1N1YnNjcmlwdGlvblJlY2VpcHQoZXZlbnQubmRrLCBldmVudC5yYXdFdmVudCgpKTtcbiAgfVxuICAvKipcbiAgICogVGhpcyBpcyB0aGUgcGVyc29uIGJlaW5nIHN1YnNjcmliZWQgdG9cbiAgICovXG4gIGdldCByZWNpcGllbnQoKSB7XG4gICAgY29uc3QgcFRhZyA9IHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwicFwiKT8uWzBdO1xuICAgIGlmICghcFRhZykgcmV0dXJuIHZvaWQgMDtcbiAgICBjb25zdCB1c2VyID0gbmV3IE5ES1VzZXIoeyBwdWJrZXk6IHBUYWdbMV0gfSk7XG4gICAgcmV0dXJuIHVzZXI7XG4gIH1cbiAgc2V0IHJlY2lwaWVudCh1c2VyKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJwXCIpO1xuICAgIGlmICghdXNlcikgcmV0dXJuO1xuICAgIHRoaXMudGFncy5wdXNoKFtcInBcIiwgdXNlci5wdWJrZXldKTtcbiAgfVxuICAvKipcbiAgICogVGhpcyBpcyB0aGUgcGVyc29uIHN1YnNjcmliaW5nXG4gICAqL1xuICBnZXQgc3Vic2NyaWJlcigpIHtcbiAgICBjb25zdCBQVGFnID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJQXCIpPy5bMF07XG4gICAgaWYgKCFQVGFnKSByZXR1cm4gdm9pZCAwO1xuICAgIGNvbnN0IHVzZXIgPSBuZXcgTkRLVXNlcih7IHB1YmtleTogUFRhZ1sxXSB9KTtcbiAgICByZXR1cm4gdXNlcjtcbiAgfVxuICBzZXQgc3Vic2NyaWJlcih1c2VyKSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJQXCIpO1xuICAgIGlmICghdXNlcikgcmV0dXJuO1xuICAgIHRoaXMudGFncy5wdXNoKFtcIlBcIiwgdXNlci5wdWJrZXldKTtcbiAgfVxuICBzZXQgc3Vic2NyaXB0aW9uU3RhcnQoZXZlbnQpIHtcbiAgICB0aGlzLmRlYnVnKGBiZWZvcmUgc2V0dGluZyBzdWJzY3JpcHRpb24gc3RhcnQ6ICR7dGhpcy5yYXdFdmVudH1gKTtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImVcIik7XG4gICAgdGhpcy50YWcoZXZlbnQsIFwic3Vic2NyaXB0aW9uXCIsIHRydWUpO1xuICAgIHRoaXMuZGVidWcoYGFmdGVyIHNldHRpbmcgc3Vic2NyaXB0aW9uIHN0YXJ0OiAke3RoaXMucmF3RXZlbnR9YCk7XG4gIH1cbiAgZ2V0IHRpZXJOYW1lKCkge1xuICAgIGNvbnN0IHRhZyA9IHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwidGllclwiKT8uWzBdO1xuICAgIHJldHVybiB0YWc/LlsxXTtcbiAgfVxuICBnZXQgaXNWYWxpZCgpIHtcbiAgICBjb25zdCBwZXJpb2QgPSB0aGlzLnZhbGlkUGVyaW9kO1xuICAgIGlmICghcGVyaW9kKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChwZXJpb2Quc3RhcnQgPiBwZXJpb2QuZW5kKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHBUYWdzID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJwXCIpO1xuICAgIGNvbnN0IFBUYWdzID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJQXCIpO1xuICAgIGlmIChwVGFncy5sZW5ndGggIT09IDEgfHwgUFRhZ3MubGVuZ3RoICE9PSAxKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGdldCB2YWxpZFBlcmlvZCgpIHtcbiAgICBjb25zdCB0YWcgPSB0aGlzLmdldE1hdGNoaW5nVGFncyhcInZhbGlkXCIpPy5bMF07XG4gICAgaWYgKCF0YWcpIHJldHVybiB2b2lkIDA7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiBuZXcgRGF0ZShwYXJzZUludCh0YWdbMV0pICogMWUzKSxcbiAgICAgICAgZW5kOiBuZXcgRGF0ZShwYXJzZUludCh0YWdbMl0pICogMWUzKVxuICAgICAgfTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICB9XG4gIHNldCB2YWxpZFBlcmlvZChwZXJpb2QpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcInZhbGlkXCIpO1xuICAgIGlmICghcGVyaW9kKSByZXR1cm47XG4gICAgdGhpcy50YWdzLnB1c2goW1xuICAgICAgXCJ2YWxpZFwiLFxuICAgICAgTWF0aC5mbG9vcihwZXJpb2Quc3RhcnQuZ2V0VGltZSgpIC8gMWUzKS50b1N0cmluZygpLFxuICAgICAgTWF0aC5mbG9vcihwZXJpb2QuZW5kLmdldFRpbWUoKSAvIDFlMykudG9TdHJpbmcoKVxuICAgIF0pO1xuICB9XG4gIGdldCBzdGFydFBlcmlvZCgpIHtcbiAgICByZXR1cm4gdGhpcy52YWxpZFBlcmlvZD8uc3RhcnQ7XG4gIH1cbiAgZ2V0IGVuZFBlcmlvZCgpIHtcbiAgICByZXR1cm4gdGhpcy52YWxpZFBlcmlvZD8uZW5kO1xuICB9XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBzdWJzY3JpcHRpb24gaXMgY3VycmVudGx5IGFjdGl2ZVxuICAgKi9cbiAgaXNBY3RpdmUodGltZSkge1xuICAgIHRpbWUgPz89IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICAgIGNvbnN0IHBlcmlvZCA9IHRoaXMudmFsaWRQZXJpb2Q7XG4gICAgaWYgKCFwZXJpb2QpIHJldHVybiBmYWxzZTtcbiAgICBpZiAodGltZSA8IHBlcmlvZC5zdGFydCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0aW1lID4gcGVyaW9kLmVuZCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG4vLyBzcmMvZXZlbnRzL2tpbmRzL3N1YnNjcmlwdGlvbnMvc3Vic2NyaXB0aW9uLXN0YXJ0LnRzXG5pbXBvcnQgZGVidWc0IGZyb20gXCJkZWJ1Z1wiO1xudmFyIE5ES1N1YnNjcmlwdGlvblN0YXJ0ID0gY2xhc3MgX05ES1N1YnNjcmlwdGlvblN0YXJ0IGV4dGVuZHMgTkRLRXZlbnQge1xuICBkZWJ1ZztcbiAgY29uc3RydWN0b3IobmRrLCByYXdFdmVudCkge1xuICAgIHN1cGVyKG5kaywgcmF3RXZlbnQpO1xuICAgIHRoaXMua2luZCA/Pz0gNzAwMSAvKiBTdWJzY3JpYmUgKi87XG4gICAgdGhpcy5kZWJ1ZyA9IG5kaz8uZGVidWcuZXh0ZW5kKFwic3Vic2NyaXB0aW9uLXN0YXJ0XCIpID8/IGRlYnVnNChcIm5kazpzdWJzY3JpcHRpb24tc3RhcnRcIik7XG4gIH1cbiAgc3RhdGljIGZyb20oZXZlbnQpIHtcbiAgICByZXR1cm4gbmV3IF9OREtTdWJzY3JpcHRpb25TdGFydChldmVudC5uZGssIGV2ZW50LnJhd0V2ZW50KCkpO1xuICB9XG4gIC8qKlxuICAgKiBSZWNpcGllbnQgb2YgdGhlIHN1YnNjcmlwdGlvbi4gSS5lLiBUaGUgYXV0aG9yIG9mIHRoaXMgZXZlbnQgc3Vic2NyaWJlcyB0byB0aGlzIHVzZXIuXG4gICAqL1xuICBnZXQgcmVjaXBpZW50KCkge1xuICAgIGNvbnN0IHBUYWcgPSB0aGlzLmdldE1hdGNoaW5nVGFncyhcInBcIik/LlswXTtcbiAgICBpZiAoIXBUYWcpIHJldHVybiB2b2lkIDA7XG4gICAgY29uc3QgdXNlciA9IG5ldyBOREtVc2VyKHsgcHVia2V5OiBwVGFnWzFdIH0pO1xuICAgIHJldHVybiB1c2VyO1xuICB9XG4gIHNldCByZWNpcGllbnQodXNlcikge1xuICAgIHRoaXMucmVtb3ZlVGFnKFwicFwiKTtcbiAgICBpZiAoIXVzZXIpIHJldHVybjtcbiAgICB0aGlzLnRhZ3MucHVzaChbXCJwXCIsIHVzZXIucHVia2V5XSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBhbW91bnQgb2YgdGhlIHN1YnNjcmlwdGlvbi5cbiAgICovXG4gIGdldCBhbW91bnQoKSB7XG4gICAgY29uc3QgYW1vdW50VGFnID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJhbW91bnRcIik/LlswXTtcbiAgICBpZiAoIWFtb3VudFRhZykgcmV0dXJuIHZvaWQgMDtcbiAgICByZXR1cm4gcGFyc2VUYWdUb1N1YnNjcmlwdGlvbkFtb3VudChhbW91bnRUYWcpO1xuICB9XG4gIHNldCBhbW91bnQoYW1vdW50KSB7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJhbW91bnRcIik7XG4gICAgaWYgKCFhbW91bnQpIHJldHVybjtcbiAgICB0aGlzLnRhZ3MucHVzaChuZXdBbW91bnQoYW1vdW50LmFtb3VudCwgYW1vdW50LmN1cnJlbmN5LCBhbW91bnQudGVybSkpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZXZlbnQgaWQgb3IgTklQLTMzIHRhZyBpZCBvZiB0aGUgdGllciB0aGF0IHRoZSB1c2VyIGlzIHN1YnNjcmliaW5nIHRvLlxuICAgKi9cbiAgZ2V0IHRpZXJJZCgpIHtcbiAgICBjb25zdCBlVGFnID0gdGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJlXCIpPy5bMF07XG4gICAgY29uc3QgYVRhZyA9IHRoaXMuZ2V0TWF0Y2hpbmdUYWdzKFwiYVwiKT8uWzBdO1xuICAgIGlmICghZVRhZyB8fCAhYVRhZykgcmV0dXJuIHZvaWQgMDtcbiAgICByZXR1cm4gZVRhZ1sxXSA/PyBhVGFnWzFdO1xuICB9XG4gIHNldCB0aWVyKHRpZXIpIHtcbiAgICB0aGlzLnJlbW92ZVRhZyhcImVcIik7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJhXCIpO1xuICAgIHRoaXMucmVtb3ZlVGFnKFwiZXZlbnRcIik7XG4gICAgaWYgKCF0aWVyKSByZXR1cm47XG4gICAgdGhpcy50YWcodGllcik7XG4gICAgdGhpcy5yZW1vdmVUYWcoXCJwXCIpO1xuICAgIHRoaXMudGFncy5wdXNoKFtcInBcIiwgdGllci5wdWJrZXldKTtcbiAgICB0aGlzLnRhZ3MucHVzaChbXCJldmVudFwiLCBKU09OLnN0cmluZ2lmeSh0aWVyLnJhd0V2ZW50KCkpXSk7XG4gIH1cbiAgLyoqXG4gICAqIEZldGNoZXMgdGhlIHRpZXIgdGhhdCB0aGUgdXNlciBpcyBzdWJzY3JpYmluZyB0by5cbiAgICovXG4gIGFzeW5jIGZldGNoVGllcigpIHtcbiAgICBjb25zdCBldmVudFRhZyA9IHRoaXMudGFnVmFsdWUoXCJldmVudFwiKTtcbiAgICBpZiAoZXZlbnRUYWcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZEV2ZW50ID0gSlNPTi5wYXJzZShldmVudFRhZyk7XG4gICAgICAgIHJldHVybiBuZXcgTkRLU3Vic2NyaXB0aW9uVGllcih0aGlzLm5kaywgcGFyc2VkRXZlbnQpO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIHRoaXMuZGVidWcoXCJGYWlsZWQgdG8gcGFyc2UgZXZlbnQgdGFnXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0aWVySWQgPSB0aGlzLnRpZXJJZDtcbiAgICBpZiAoIXRpZXJJZCkgcmV0dXJuIHZvaWQgMDtcbiAgICBjb25zdCBlID0gYXdhaXQgdGhpcy5uZGs/LmZldGNoRXZlbnQodGllcklkKTtcbiAgICBpZiAoIWUpIHJldHVybiB2b2lkIDA7XG4gICAgcmV0dXJuIE5ES1N1YnNjcmlwdGlvblRpZXIuZnJvbShlKTtcbiAgfVxuICBnZXQgaXNWYWxpZCgpIHtcbiAgICBpZiAodGhpcy5nZXRNYXRjaGluZ1RhZ3MoXCJhbW91bnRcIikubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aGlzLmRlYnVnKFwiSW52YWxpZCAjIG9mIGFtb3VudCB0YWdcIik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghdGhpcy5hbW91bnQpIHtcbiAgICAgIHRoaXMuZGVidWcoXCJJbnZhbGlkIGFtb3VudCB0YWdcIik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0aGlzLmdldE1hdGNoaW5nVGFncyhcInBcIikubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aGlzLmRlYnVnKFwiSW52YWxpZCAjIG9mIHAgdGFnXCIpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIXRoaXMucmVjaXBpZW50KSB7XG4gICAgICB0aGlzLmRlYnVnKFwiSW52YWxpZCBwIHRhZ1wiKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cbi8vIHNyYy9ldmVudHMva2luZHMvc2ltcGxlLWdyb3VwL2luZGV4LnRzXG52YXIgTkRLU2ltcGxlR3JvdXAgPSBjbGFzcyBfTkRLU2ltcGxlR3JvdXAge1xuICBuZGs7XG4gIGdyb3VwSWQ7XG4gIHJlbGF5U2V0O1xuICBmZXRjaGluZ01ldGFkYXRhO1xuICBtZXRhZGF0YTtcbiAgbWVtYmVyTGlzdDtcbiAgYWRtaW5MaXN0O1xuICBjb25zdHJ1Y3RvcihuZGssIHJlbGF5U2V0LCBncm91cElkKSB7XG4gICAgdGhpcy5uZGsgPSBuZGs7XG4gICAgdGhpcy5ncm91cElkID0gZ3JvdXBJZCA/PyByYW5kb21JZCgyNCk7XG4gICAgdGhpcy5yZWxheVNldCA9IHJlbGF5U2V0O1xuICB9XG4gIGdldCBpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5ncm91cElkO1xuICB9XG4gIHJlbGF5VXJscygpIHtcbiAgICByZXR1cm4gdGhpcy5yZWxheVNldC5yZWxheVVybHM7XG4gIH1cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMubWV0YWRhdGE/Lm5hbWU7XG4gIH1cbiAgZ2V0IGFib3V0KCkge1xuICAgIHJldHVybiB0aGlzLm1ldGFkYXRhPy5hYm91dDtcbiAgfVxuICBnZXQgcGljdHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXRhZGF0YT8ucGljdHVyZTtcbiAgfVxuICBnZXQgbWVtYmVycygpIHtcbiAgICByZXR1cm4gdGhpcy5tZW1iZXJMaXN0Py5tZW1iZXJzID8/IFtdO1xuICB9XG4gIGdldCBhZG1pbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRtaW5MaXN0Py5tZW1iZXJzID8/IFtdO1xuICB9XG4gIGFzeW5jIGdldE1ldGFkYXRhKCkge1xuICAgIGF3YWl0IHRoaXMuZW5zdXJlTWV0YWRhdGFFdmVudCgpO1xuICAgIHJldHVybiB0aGlzLm1ldGFkYXRhO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIHRoZSBncm91cCBieSBwdWJsaXNoaW5nIGEga2luZDo5MDA3IGV2ZW50LlxuICAgKiBAcGFyYW0gc2lnbmVyXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBhc3luYyBjcmVhdGVHcm91cChzaWduZXIpIHtcbiAgICBzaWduZXIgPz89IHRoaXMubmRrLnNpZ25lcjtcbiAgICBpZiAoIXNpZ25lcikgdGhyb3cgbmV3IEVycm9yKFwiTm8gc2lnbmVyIGF2YWlsYWJsZVwiKTtcbiAgICBjb25zdCB1c2VyID0gYXdhaXQgc2lnbmVyLnVzZXIoKTtcbiAgICBpZiAoIXVzZXIpIHRocm93IG5ldyBFcnJvcihcIk5vIHVzZXIgYXZhaWxhYmxlXCIpO1xuICAgIGNvbnN0IGV2ZW50ID0gbmV3IE5ES0V2ZW50KHRoaXMubmRrKTtcbiAgICBldmVudC5raW5kID0gOTAwNyAvKiBHcm91cEFkbWluQ3JlYXRlR3JvdXAgKi87XG4gICAgZXZlbnQudGFncy5wdXNoKFtcImhcIiwgdGhpcy5ncm91cElkXSk7XG4gICAgYXdhaXQgZXZlbnQuc2lnbihzaWduZXIpO1xuICAgIHJldHVybiBldmVudC5wdWJsaXNoKHRoaXMucmVsYXlTZXQpO1xuICB9XG4gIGFzeW5jIHNldE1ldGFkYXRhKHtcbiAgICBuYW1lLFxuICAgIGFib3V0LFxuICAgIHBpY3R1cmVcbiAgfSkge1xuICAgIGNvbnN0IGV2ZW50ID0gbmV3IE5ES0V2ZW50KHRoaXMubmRrKTtcbiAgICBldmVudC5raW5kID0gOTAwMiAvKiBHcm91cEFkbWluRWRpdE1ldGFkYXRhICovO1xuICAgIGV2ZW50LnRhZ3MucHVzaChbXCJoXCIsIHRoaXMuZ3JvdXBJZF0pO1xuICAgIGlmIChuYW1lKSBldmVudC50YWdzLnB1c2goW1wibmFtZVwiLCBuYW1lXSk7XG4gICAgaWYgKGFib3V0KSBldmVudC50YWdzLnB1c2goW1wiYWJvdXRcIiwgYWJvdXRdKTtcbiAgICBpZiAocGljdHVyZSkgZXZlbnQudGFncy5wdXNoKFtcInBpY3R1cmVcIiwgcGljdHVyZV0pO1xuICAgIGF3YWl0IGV2ZW50LnNpZ24oKTtcbiAgICByZXR1cm4gZXZlbnQucHVibGlzaCh0aGlzLnJlbGF5U2V0KTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIHVzZXIgdG8gdGhlIGdyb3VwIHVzaW5nIGEga2luZDo5MDAwIGV2ZW50XG4gICAqIEBwYXJhbSB1c2VyIHVzZXIgdG8gYWRkXG4gICAqIEBwYXJhbSBvcHRzIG9wdGlvbnNcbiAgICovXG4gIGFzeW5jIGFkZFVzZXIodXNlcikge1xuICAgIGNvbnN0IGFkZFVzZXJFdmVudCA9IF9OREtTaW1wbGVHcm91cC5nZW5lcmF0ZUFkZFVzZXJFdmVudCh1c2VyLnB1YmtleSwgdGhpcy5ncm91cElkKTtcbiAgICBhZGRVc2VyRXZlbnQubmRrID0gdGhpcy5uZGs7XG4gICAgcmV0dXJuIGFkZFVzZXJFdmVudDtcbiAgfVxuICBhc3luYyBnZXRNZW1iZXJMaXN0RXZlbnQoKSB7XG4gICAgY29uc3QgbWVtYmVyTGlzdCA9IGF3YWl0IHRoaXMubmRrLmZldGNoRXZlbnQoXG4gICAgICB7XG4gICAgICAgIGtpbmRzOiBbMzkwMDIgLyogR3JvdXBNZW1iZXJzICovXSxcbiAgICAgICAgXCIjZFwiOiBbdGhpcy5ncm91cElkXVxuICAgICAgfSxcbiAgICAgIHZvaWQgMCxcbiAgICAgIHRoaXMucmVsYXlTZXRcbiAgICApO1xuICAgIGlmICghbWVtYmVyTGlzdCkgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIE5ES1NpbXBsZUdyb3VwTWVtYmVyTGlzdC5mcm9tKG1lbWJlckxpc3QpO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIGEgbGlzdCBvZiB1c2VycyB0aGF0IGJlbG9uZyB0byB0aGlzIGdyb3VwXG4gICAqL1xuICBhc3luYyBnZXRNZW1iZXJzKCkge1xuICAgIGNvbnN0IG1lbWJlcnMgPSBbXTtcbiAgICBjb25zdCBtZW1iZXJQdWJrZXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBjb25zdCBtZW1iZXJMaXN0RXZlbnQgPSBhd2FpdCB0aGlzLmdldE1lbWJlckxpc3RFdmVudCgpO1xuICAgIGlmICghbWVtYmVyTGlzdEV2ZW50KSByZXR1cm4gW107XG4gICAgZm9yIChjb25zdCBwVGFnIG9mIG1lbWJlckxpc3RFdmVudC5nZXRNYXRjaGluZ1RhZ3MoXCJwXCIpKSB7XG4gICAgICBjb25zdCBwdWJrZXkgPSBwVGFnWzFdO1xuICAgICAgaWYgKG1lbWJlclB1YmtleXMuaGFzKHB1YmtleSkpIGNvbnRpbnVlO1xuICAgICAgbWVtYmVyUHVia2V5cy5hZGQocHVia2V5KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIG1lbWJlcnMucHVzaCh0aGlzLm5kay5nZXRVc2VyKHsgcHVia2V5IH0pKTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWVtYmVycztcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGFuIGV2ZW50IHRoYXQgbGlzdHMgdGhlIG1lbWJlcnMgb2YgYSBncm91cC5cbiAgICogQHBhcmFtIGdyb3VwSWRcbiAgICogQHJldHVybnNcbiAgICovXG4gIHN0YXRpYyBnZW5lcmF0ZVVzZXJMaXN0RXZlbnQoZ3JvdXBJZCkge1xuICAgIGNvbnN0IGV2ZW50ID0gbmV3IE5ES0V2ZW50KHZvaWQgMCwge1xuICAgICAga2luZDogMzkwMDIgLyogR3JvdXBNZW1iZXJzICovLFxuICAgICAgdGFnczogW1xuICAgICAgICBbXCJoXCIsIGdyb3VwSWRdLFxuICAgICAgICBbXCJhbHRcIiwgXCJHcm91cCBNZW1iZXIgTGlzdFwiXVxuICAgICAgXVxuICAgIH0pO1xuICAgIHJldHVybiBldmVudDtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGFuIGV2ZW50IHRoYXQgYWRkcyBhIHVzZXIgdG8gYSBncm91cC5cbiAgICogQHBhcmFtIHVzZXJQdWJrZXkgcHVia2V5IG9mIHRoZSB1c2VyIHRvIGFkZFxuICAgKiBAcGFyYW0gZ3JvdXBJZCBncm91cCB0byBhZGQgdGhlIHVzZXIgdG9cbiAgICogQHJldHVybnNcbiAgICovXG4gIHN0YXRpYyBnZW5lcmF0ZUFkZFVzZXJFdmVudCh1c2VyUHVia2V5LCBncm91cElkKSB7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgTkRLRXZlbnQodm9pZCAwLCB7XG4gICAgICBraW5kOiA5ZTMgLyogR3JvdXBBZG1pbkFkZFVzZXIgKi8sXG4gICAgICB0YWdzOiBbW1wiaFwiLCBncm91cElkXV1cbiAgICB9KTtcbiAgICBldmVudC50YWdzLnB1c2goW1wicFwiLCB1c2VyUHVia2V5XSk7XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9XG4gIGFzeW5jIHJlcXVlc3RUb0pvaW4ocHVia2V5LCBjb250ZW50KSB7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgTkRLRXZlbnQodGhpcy5uZGssIHtcbiAgICAgIGtpbmQ6IDkwMjEgLyogR3JvdXBBZG1pblJlcXVlc3RKb2luICovLFxuICAgICAgY29udGVudDogY29udGVudCA/PyBcIlwiLFxuICAgICAgdGFnczogW1tcImhcIiwgdGhpcy5ncm91cElkXV1cbiAgICB9KTtcbiAgICByZXR1cm4gZXZlbnQucHVibGlzaCh0aGlzLnJlbGF5U2V0KTtcbiAgfVxuICAvKipcbiAgICogTWFrZXMgc3VyZSB0aGF0IGEgbWV0YWRhdGEgZXZlbnQgZXhpc3RzIGxvY2FsbHlcbiAgICovXG4gIGFzeW5jIGVuc3VyZU1ldGFkYXRhRXZlbnQoKSB7XG4gICAgaWYgKHRoaXMubWV0YWRhdGEpIHJldHVybjtcbiAgICBpZiAodGhpcy5mZXRjaGluZ01ldGFkYXRhKSByZXR1cm4gdGhpcy5mZXRjaGluZ01ldGFkYXRhO1xuICAgIHRoaXMuZmV0Y2hpbmdNZXRhZGF0YSA9IHRoaXMubmRrLmZldGNoRXZlbnQoXG4gICAgICB7XG4gICAgICAgIGtpbmRzOiBbMzllMyAvKiBHcm91cE1ldGFkYXRhICovXSxcbiAgICAgICAgXCIjZFwiOiBbdGhpcy5ncm91cElkXVxuICAgICAgfSxcbiAgICAgIHZvaWQgMCxcbiAgICAgIHRoaXMucmVsYXlTZXRcbiAgICApLnRoZW4oKGV2ZW50KSA9PiB7XG4gICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IE5ES1NpbXBsZUdyb3VwTWV0YWRhdGEuZnJvbShldmVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbmV3IE5ES1NpbXBsZUdyb3VwTWV0YWRhdGEodGhpcy5uZGspO1xuICAgICAgICB0aGlzLm1ldGFkYXRhLmRUYWcgPSB0aGlzLmdyb3VwSWQ7XG4gICAgICB9XG4gICAgfSkuZmluYWxseSgoKSA9PiB7XG4gICAgICB0aGlzLmZldGNoaW5nTWV0YWRhdGEgPSB2b2lkIDA7XG4gICAgfSkuY2F0Y2goKCkgPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGZldGNoIG1ldGFkYXRhIGZvciBncm91cCBcIiArIHRoaXMuZ3JvdXBJZCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hpbmdNZXRhZGF0YTtcbiAgfVxufTtcbmZ1bmN0aW9uIHJhbmRvbUlkKGxlbmd0aCkge1xuICBjb25zdCBjaGFycyA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODlcIjtcbiAgY29uc3QgY2hhcnNMZW5ndGggPSBjaGFycy5sZW5ndGg7XG4gIGxldCByZXN1bHQgPSBcIlwiO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgcmVzdWx0ICs9IGNoYXJzLmNoYXJBdChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjaGFyc0xlbmd0aCkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIHNyYy9hcHAtc2V0dGluZ3MvaW5kZXgudHNcbnZhciBOREtBcHBTZXR0aW5ncyA9IGNsYXNzIF9OREtBcHBTZXR0aW5ncyBleHRlbmRzIE5ES0V2ZW50IHtcbiAgYXBwTmFtZTtcbiAgc2V0dGluZ3MgPSB7fTtcbiAgY29uc3RydWN0b3IobmRrLCByYXdFdmVudCkge1xuICAgIHN1cGVyKG5kaywgcmF3RXZlbnQpO1xuICAgIHRoaXMua2luZCA/Pz0gMzAwNzggLyogQXBwU3BlY2lmaWNEYXRhICovO1xuICAgIHRoaXMuZFRhZyA/Pz0gdGhpcy5hcHBOYW1lO1xuICAgIGlmICh0aGlzLmNvbnRlbnQubGVuZ3RoID4gMCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9IEpTT04ucGFyc2UodGhpcy5jb250ZW50KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBwYXJzaW5nIGFwcCBzZXR0aW5nc1wiLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHN0YXRpYyBmcm9tKGV2ZW50KSB7XG4gICAgcmV0dXJuIG5ldyBfTkRLQXBwU2V0dGluZ3MoZXZlbnQubmRrLCBldmVudCk7XG4gIH1cbiAgLyoqXG4gICAqIFNldCBhIHZhbHVlIGZvciBhIGdpdmVuIGtleS5cbiAgICpcbiAgICogQHBhcmFtIGtleVxuICAgKiBAcGFyYW0gdmFsdWVcbiAgICovXG4gIHNldChrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5zZXR0aW5nc1trZXldID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhIHZhbHVlIGZvciBhIGdpdmVuIGtleS5cbiAgICpcbiAgICogQHBhcmFtIGtleVxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgZ2V0KGtleSkge1xuICAgIHJldHVybiB0aGlzLnNldHRpbmdzW2tleV07XG4gIH1cbiAgYXN5bmMgcHVibGlzaFJlcGxhY2VhYmxlKHJlbGF5U2V0LCB0aW1lb3V0TXMsIHJlcXVpcmVkUmVsYXlDb3VudCkge1xuICAgIHRoaXMuY29udGVudCA9IEpTT04uc3RyaW5naWZ5KHRoaXMuc2V0dGluZ3MpO1xuICAgIHJldHVybiBzdXBlci5wdWJsaXNoUmVwbGFjZWFibGUocmVsYXlTZXQsIHRpbWVvdXRNcywgcmVxdWlyZWRSZWxheUNvdW50KTtcbiAgfVxufTtcblxuLy8gc3JjL3JlbGF5L2F1dGgtcG9saWNpZXMudHNcbmltcG9ydCBjcmVhdGVEZWJ1ZzIgZnJvbSBcImRlYnVnXCI7XG5mdW5jdGlvbiBkaXNjb25uZWN0KHBvb2wsIGRlYnVnOCkge1xuICBkZWJ1ZzggPz89IGNyZWF0ZURlYnVnMihcIm5kazpyZWxheTphdXRoLXBvbGljaWVzOmRpc2Nvbm5lY3RcIik7XG4gIHJldHVybiBhc3luYyAocmVsYXkpID0+IHtcbiAgICBkZWJ1ZzgoYFJlbGF5ICR7cmVsYXkudXJsfSByZXF1ZXN0ZWQgYXV0aGVudGljYXRpb24sIGRpc2Nvbm5lY3RpbmdgKTtcbiAgICBwb29sLnJlbW92ZVJlbGF5KHJlbGF5LnVybCk7XG4gIH07XG59XG5hc3luYyBmdW5jdGlvbiBzaWduQW5kQXV0aChldmVudCwgcmVsYXksIHNpZ25lciwgZGVidWc4LCByZXNvbHZlLCByZWplY3QpIHtcbiAgdHJ5IHtcbiAgICBhd2FpdCBldmVudC5zaWduKHNpZ25lcik7XG4gICAgcmVzb2x2ZShldmVudCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBkZWJ1ZzgoYEZhaWxlZCB0byBwdWJsaXNoIGF1dGggZXZlbnQgdG8gcmVsYXkgJHtyZWxheS51cmx9YCwgZSk7XG4gICAgcmVqZWN0KGV2ZW50KTtcbiAgfVxufVxuZnVuY3Rpb24gc2lnbkluKHsgbmRrLCBzaWduZXIsIGRlYnVnOiBkZWJ1ZzggfSA9IHt9KSB7XG4gIGRlYnVnOCA/Pz0gY3JlYXRlRGVidWcyKFwibmRrOmF1dGgtcG9saWNpZXM6c2lnbkluXCIpO1xuICByZXR1cm4gYXN5bmMgKHJlbGF5LCBjaGFsbGVuZ2UpID0+IHtcbiAgICBkZWJ1ZzgoYFJlbGF5ICR7cmVsYXkudXJsfSByZXF1ZXN0ZWQgYXV0aGVudGljYXRpb24sIHNpZ25pbmcgaW5gKTtcbiAgICBjb25zdCBldmVudCA9IG5ldyBOREtFdmVudChuZGspO1xuICAgIGV2ZW50LmtpbmQgPSAyMjI0MiAvKiBDbGllbnRBdXRoICovO1xuICAgIGV2ZW50LnRhZ3MgPSBbXG4gICAgICBbXCJyZWxheVwiLCByZWxheS51cmxdLFxuICAgICAgW1wiY2hhbGxlbmdlXCIsIGNoYWxsZW5nZV1cbiAgICBdO1xuICAgIHNpZ25lciA/Pz0gbmRrPy5zaWduZXI7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmIChzaWduZXIpIHtcbiAgICAgICAgYXdhaXQgc2lnbkFuZEF1dGgoZXZlbnQsIHJlbGF5LCBzaWduZXIsIGRlYnVnOCwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5kaz8ub25jZShcInNpZ25lcjpyZWFkeVwiLCBhc3luYyAoc2lnbmVyMikgPT4ge1xuICAgICAgICAgIGF3YWl0IHNpZ25BbmRBdXRoKGV2ZW50LCByZWxheSwgc2lnbmVyMiwgZGVidWc4LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn1cbnZhciBOREtSZWxheUF1dGhQb2xpY2llcyA9IHtcbiAgZGlzY29ubmVjdCxcbiAgc2lnbkluXG59O1xuXG4vLyBzcmMvc2lnbmVycy9uaXAwNy9pbmRleC50c1xuaW1wb3J0IGRlYnVnNSBmcm9tIFwiZGVidWdcIjtcbnZhciBOREtOaXAwN1NpZ25lciA9IGNsYXNzIHtcbiAgX3VzZXJQcm9taXNlO1xuICBlbmNyeXB0aW9uUXVldWUgPSBbXTtcbiAgZW5jcnlwdGlvblByb2Nlc3NpbmcgPSBmYWxzZTtcbiAgZGVidWc7XG4gIHdhaXRUaW1lb3V0O1xuICAvKipcbiAgICogQHBhcmFtIHdhaXRUaW1lb3V0IC0gVGhlIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIHRvIHdhaXQgZm9yIHRoZSBOSVAtMDcgdG8gYmVjb21lIGF2YWlsYWJsZVxuICAgKi9cbiAgY29uc3RydWN0b3Iod2FpdFRpbWVvdXQgPSAxZTMpIHtcbiAgICB0aGlzLmRlYnVnID0gZGVidWc1KFwibmRrOm5pcDA3XCIpO1xuICAgIHRoaXMud2FpdFRpbWVvdXQgPSB3YWl0VGltZW91dDtcbiAgfVxuICBhc3luYyBibG9ja1VudGlsUmVhZHkoKSB7XG4gICAgYXdhaXQgdGhpcy53YWl0Rm9yRXh0ZW5zaW9uKCk7XG4gICAgY29uc3QgcHVia2V5ID0gYXdhaXQgd2luZG93Lm5vc3RyLmdldFB1YmxpY0tleSgpO1xuICAgIGlmICghcHVia2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVc2VyIHJlamVjdGVkIGFjY2Vzc1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBOREtVc2VyKHsgcHVia2V5IH0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXR0ZXIgZm9yIHRoZSB1c2VyIHByb3BlcnR5LlxuICAgKiBAcmV0dXJucyBUaGUgTkRLVXNlciBpbnN0YW5jZS5cbiAgICovXG4gIGFzeW5jIHVzZXIoKSB7XG4gICAgaWYgKCF0aGlzLl91c2VyUHJvbWlzZSkge1xuICAgICAgdGhpcy5fdXNlclByb21pc2UgPSB0aGlzLmJsb2NrVW50aWxSZWFkeSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdXNlclByb21pc2U7XG4gIH1cbiAgLyoqXG4gICAqIFNpZ25zIHRoZSBnaXZlbiBOb3N0ciBldmVudC5cbiAgICogQHBhcmFtIGV2ZW50IC0gVGhlIE5vc3RyIGV2ZW50IHRvIGJlIHNpZ25lZC5cbiAgICogQHJldHVybnMgVGhlIHNpZ25hdHVyZSBvZiB0aGUgc2lnbmVkIGV2ZW50LlxuICAgKiBAdGhyb3dzIEVycm9yIGlmIHRoZSBOSVAtMDcgaXMgbm90IGF2YWlsYWJsZSBvbiB0aGUgd2luZG93IG9iamVjdC5cbiAgICovXG4gIGFzeW5jIHNpZ24oZXZlbnQpIHtcbiAgICBhd2FpdCB0aGlzLndhaXRGb3JFeHRlbnNpb24oKTtcbiAgICBjb25zdCBzaWduZWRFdmVudCA9IGF3YWl0IHdpbmRvdy5ub3N0ci5zaWduRXZlbnQoZXZlbnQpO1xuICAgIHJldHVybiBzaWduZWRFdmVudC5zaWc7XG4gIH1cbiAgYXN5bmMgcmVsYXlzKG5kaykge1xuICAgIGF3YWl0IHRoaXMud2FpdEZvckV4dGVuc2lvbigpO1xuICAgIGNvbnN0IHJlbGF5cyA9IGF3YWl0IHdpbmRvdy5ub3N0ci5nZXRSZWxheXM/LigpIHx8IHt9O1xuICAgIGNvbnN0IGFjdGl2ZVJlbGF5cyA9IFtdO1xuICAgIGZvciAoY29uc3QgdXJsIG9mIE9iamVjdC5rZXlzKHJlbGF5cykpIHtcbiAgICAgIGlmIChyZWxheXNbdXJsXS5yZWFkICYmIHJlbGF5c1t1cmxdLndyaXRlKSB7XG4gICAgICAgIGFjdGl2ZVJlbGF5cy5wdXNoKHVybCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhY3RpdmVSZWxheXMubWFwKCh1cmwpID0+IG5ldyBOREtSZWxheSh1cmwsIG5kaz8ucmVsYXlBdXRoRGVmYXVsdFBvbGljeSwgbmRrKSk7XG4gIH1cbiAgYXN5bmMgZW5jcnlwdGlvbkVuYWJsZWQobmlwKSB7XG4gICAgbGV0IGVuYWJsZWQgPSBbXTtcbiAgICBpZiAoKCFuaXAgfHwgbmlwID09IFwibmlwMDRcIikgJiYgQm9vbGVhbih3aW5kb3cubm9zdHIubmlwMDQpKSBlbmFibGVkLnB1c2goXCJuaXAwNFwiKTtcbiAgICBpZiAoKCFuaXAgfHwgbmlwID09IFwibmlwNDRcIikgJiYgQm9vbGVhbih3aW5kb3cubm9zdHIubmlwNDQpKSBlbmFibGVkLnB1c2goXCJuaXA0NFwiKTtcbiAgICByZXR1cm4gZW5hYmxlZDtcbiAgfVxuICBhc3luYyBlbmNyeXB0KHJlY2lwaWVudCwgdmFsdWUsIG5pcCA9IFwibmlwMDRcIikge1xuICAgIGlmICghYXdhaXQgdGhpcy5lbmNyeXB0aW9uRW5hYmxlZChuaXApKSB0aHJvdyBuZXcgRXJyb3IobmlwICsgXCJlbmNyeXB0aW9uIGlzIG5vdCBhdmFpbGFibGUgZnJvbSB5b3VyIGJyb3dzZXIgZXh0ZW5zaW9uXCIpO1xuICAgIGF3YWl0IHRoaXMud2FpdEZvckV4dGVuc2lvbigpO1xuICAgIGNvbnN0IHJlY2lwaWVudEhleFB1YktleSA9IHJlY2lwaWVudC5wdWJrZXk7XG4gICAgcmV0dXJuIHRoaXMucXVldWVFbmNyeXB0aW9uKG5pcCwgXCJlbmNyeXB0XCIsIHJlY2lwaWVudEhleFB1YktleSwgdmFsdWUpO1xuICB9XG4gIGFzeW5jIGRlY3J5cHQoc2VuZGVyLCB2YWx1ZSwgbmlwID0gXCJuaXAwNFwiKSB7XG4gICAgaWYgKCFhd2FpdCB0aGlzLmVuY3J5cHRpb25FbmFibGVkKG5pcCkpIHRocm93IG5ldyBFcnJvcihuaXAgKyBcImVuY3J5cHRpb24gaXMgbm90IGF2YWlsYWJsZSBmcm9tIHlvdXIgYnJvd3NlciBleHRlbnNpb25cIik7XG4gICAgYXdhaXQgdGhpcy53YWl0Rm9yRXh0ZW5zaW9uKCk7XG4gICAgY29uc3Qgc2VuZGVySGV4UHViS2V5ID0gc2VuZGVyLnB1YmtleTtcbiAgICByZXR1cm4gdGhpcy5xdWV1ZUVuY3J5cHRpb24obmlwLCBcImRlY3J5cHRcIiwgc2VuZGVySGV4UHViS2V5LCB2YWx1ZSk7XG4gIH1cbiAgYXN5bmMgcXVldWVFbmNyeXB0aW9uKHNjaGVtZSwgbWV0aG9kLCBjb3VudGVycGFydHlIZXhwdWJrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuZW5jcnlwdGlvblF1ZXVlLnB1c2goe1xuICAgICAgICBzY2hlbWUsXG4gICAgICAgIG1ldGhvZCxcbiAgICAgICAgY291bnRlcnBhcnR5SGV4cHVia2V5LFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgcmVzb2x2ZSxcbiAgICAgICAgcmVqZWN0XG4gICAgICB9KTtcbiAgICAgIGlmICghdGhpcy5lbmNyeXB0aW9uUHJvY2Vzc2luZykge1xuICAgICAgICB0aGlzLnByb2Nlc3NFbmNyeXB0aW9uUXVldWUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBhc3luYyBwcm9jZXNzRW5jcnlwdGlvblF1ZXVlKGl0ZW0sIHJldHJpZXMgPSAwKSB7XG4gICAgaWYgKCFpdGVtICYmIHRoaXMuZW5jcnlwdGlvblF1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5lbmNyeXB0aW9uUHJvY2Vzc2luZyA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmVuY3J5cHRpb25Qcm9jZXNzaW5nID0gdHJ1ZTtcbiAgICBjb25zdCB7IHNjaGVtZSwgbWV0aG9kLCBjb3VudGVycGFydHlIZXhwdWJrZXksIHZhbHVlLCByZXNvbHZlLCByZWplY3QgfSA9IGl0ZW0gfHwgdGhpcy5lbmNyeXB0aW9uUXVldWUuc2hpZnQoKTtcbiAgICB0aGlzLmRlYnVnKFwiUHJvY2Vzc2luZyBlbmNyeXB0aW9uIHF1ZXVlIGl0ZW1cIiwge1xuICAgICAgbWV0aG9kLFxuICAgICAgY291bnRlcnBhcnR5SGV4cHVia2V5LFxuICAgICAgdmFsdWVcbiAgICB9KTtcbiAgICB0cnkge1xuICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IHdpbmRvdy5ub3N0cltzY2hlbWVdW21ldGhvZF0oY291bnRlcnBhcnR5SGV4cHVia2V5LCB2YWx1ZSk7XG4gICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvci5tZXNzYWdlICYmIGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoXCJjYWxsIGFscmVhZHkgZXhlY3V0aW5nXCIpKSB7XG4gICAgICAgIGlmIChyZXRyaWVzIDwgNSkge1xuICAgICAgICAgIHRoaXMuZGVidWcoXCJSZXRyeWluZyBlbmNyeXB0aW9uIHF1ZXVlIGl0ZW1cIiwge1xuICAgICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgICAgY291bnRlcnBhcnR5SGV4cHVia2V5LFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICByZXRyaWVzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NFbmNyeXB0aW9uUXVldWUoaXRlbSwgcmV0cmllcyArIDEpO1xuICAgICAgICAgIH0sIDUwICogcmV0cmllcyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZWplY3QoZXJyb3IpO1xuICAgIH1cbiAgICB0aGlzLnByb2Nlc3NFbmNyeXB0aW9uUXVldWUoKTtcbiAgfVxuICB3YWl0Rm9yRXh0ZW5zaW9uKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAod2luZG93Lm5vc3RyKSB7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IHRpbWVySWQ7XG4gICAgICBjb25zdCBpbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICBpZiAod2luZG93Lm5vc3RyKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxJZCk7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICB9LCAxMDApO1xuICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsSWQpO1xuICAgICAgICByZWplY3QobmV3IEVycm9yKFwiTklQLTA3IGV4dGVuc2lvbiBub3QgYXZhaWxhYmxlXCIpKTtcbiAgICAgIH0sIHRoaXMud2FpdFRpbWVvdXQpO1xuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvc2lnbmVycy9wcml2YXRlLWtleS9pbmRleC50c1xuaW1wb3J0IHsgZ2VuZXJhdGVTZWNyZXRLZXksIGdldFB1YmxpY0tleSwgZmluYWxpemVFdmVudCwgbmlwMDQsIG5pcDQ0IH0gZnJvbSBcIm5vc3RyLXRvb2xzXCI7XG5pbXBvcnQgeyBieXRlc1RvSGV4IGFzIGJ5dGVzVG9IZXgyLCBoZXhUb0J5dGVzIH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvdXRpbHNcIjtcbmltcG9ydCB7IG5pcDE5IGFzIG5pcDE5NiB9IGZyb20gXCJub3N0ci10b29sc1wiO1xudmFyIE5ES1ByaXZhdGVLZXlTaWduZXIgPSBjbGFzcyBfTkRLUHJpdmF0ZUtleVNpZ25lciB7XG4gIF91c2VyO1xuICBfcHJpdmF0ZUtleTtcbiAgY29uc3RydWN0b3IocHJpdmF0ZUtleSkge1xuICAgIGlmIChwcml2YXRlS2V5KSB7XG4gICAgICBpZiAodHlwZW9mIHByaXZhdGVLZXkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKHByaXZhdGVLZXkuc3RhcnRzV2l0aChcIm5zZWMxXCIpKSB7XG4gICAgICAgICAgY29uc3QgeyB0eXBlLCBkYXRhIH0gPSBuaXAxOTYuZGVjb2RlKHByaXZhdGVLZXkpO1xuICAgICAgICAgIGlmICh0eXBlID09PSBcIm5zZWNcIikgdGhpcy5fcHJpdmF0ZUtleSA9IGRhdGE7XG4gICAgICAgIH0gZWxzZSBpZiAocHJpdmF0ZUtleS5sZW5ndGggPT09IDY0KSB7XG4gICAgICAgICAgdGhpcy5fcHJpdmF0ZUtleSA9IGhleFRvQnl0ZXMocHJpdmF0ZUtleSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwcml2YXRlIGtleSBwcm92aWRlZC5cIik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGVLZXkgPSBwcml2YXRlS2V5O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3ByaXZhdGVLZXkpIHtcbiAgICAgICAgdGhpcy5fdXNlciA9IG5ldyBOREtVc2VyKHtcbiAgICAgICAgICBwdWJrZXk6IGdldFB1YmxpY0tleSh0aGlzLl9wcml2YXRlS2V5KVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0IHByaXZhdGVLZXkoKSB7XG4gICAgaWYgKCF0aGlzLl9wcml2YXRlS2V5KSByZXR1cm4gdm9pZCAwO1xuICAgIHJldHVybiBieXRlc1RvSGV4Mih0aGlzLl9wcml2YXRlS2V5KTtcbiAgfVxuICBzdGF0aWMgZ2VuZXJhdGUoKSB7XG4gICAgY29uc3QgcHJpdmF0ZUtleSA9IGdlbmVyYXRlU2VjcmV0S2V5KCk7XG4gICAgcmV0dXJuIG5ldyBfTkRLUHJpdmF0ZUtleVNpZ25lcihwcml2YXRlS2V5KTtcbiAgfVxuICBhc3luYyBibG9ja1VudGlsUmVhZHkoKSB7XG4gICAgaWYgKCF0aGlzLl91c2VyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOREtVc2VyIG5vdCBpbml0aWFsaXplZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3VzZXI7XG4gIH1cbiAgYXN5bmMgdXNlcigpIHtcbiAgICBhd2FpdCB0aGlzLmJsb2NrVW50aWxSZWFkeSgpO1xuICAgIHJldHVybiB0aGlzLl91c2VyO1xuICB9XG4gIGFzeW5jIHNpZ24oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuX3ByaXZhdGVLZXkpIHtcbiAgICAgIHRocm93IEVycm9yKFwiQXR0ZW1wdGVkIHRvIHNpZ24gd2l0aG91dCBhIHByaXZhdGUga2V5XCIpO1xuICAgIH1cbiAgICByZXR1cm4gZmluYWxpemVFdmVudChldmVudCwgdGhpcy5fcHJpdmF0ZUtleSkuc2lnO1xuICB9XG4gIGFzeW5jIGVuY3J5cHRpb25FbmFibGVkKHNjaGVtZSkge1xuICAgIGxldCBlbmFibGVkID0gW107XG4gICAgaWYgKCFzY2hlbWUgfHwgc2NoZW1lID09IFwibmlwMDRcIikgZW5hYmxlZC5wdXNoKFwibmlwMDRcIik7XG4gICAgaWYgKCFzY2hlbWUgfHwgc2NoZW1lID09IFwibmlwNDRcIikgZW5hYmxlZC5wdXNoKFwibmlwNDRcIik7XG4gICAgcmV0dXJuIGVuYWJsZWQ7XG4gIH1cbiAgYXN5bmMgZW5jcnlwdChyZWNpcGllbnQsIHZhbHVlLCBzY2hlbWUpIHtcbiAgICBpZiAoIXRoaXMuX3ByaXZhdGVLZXkgfHwgIXRoaXMucHJpdmF0ZUtleSkge1xuICAgICAgdGhyb3cgRXJyb3IoXCJBdHRlbXB0ZWQgdG8gZW5jcnlwdCB3aXRob3V0IGEgcHJpdmF0ZSBrZXlcIik7XG4gICAgfVxuICAgIGNvbnN0IHJlY2lwaWVudEhleFB1YktleSA9IHJlY2lwaWVudC5wdWJrZXk7XG4gICAgaWYgKHNjaGVtZSA9PSBcIm5pcDQ0XCIpIHtcbiAgICAgIGxldCBjb252ZXJzYXRpb25LZXkgPSBuaXA0NC52Mi51dGlscy5nZXRDb252ZXJzYXRpb25LZXkodGhpcy5fcHJpdmF0ZUtleSwgcmVjaXBpZW50SGV4UHViS2V5KTtcbiAgICAgIHJldHVybiBhd2FpdCBuaXA0NC52Mi5lbmNyeXB0KHZhbHVlLCBjb252ZXJzYXRpb25LZXkpO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgbmlwMDQuZW5jcnlwdCh0aGlzLl9wcml2YXRlS2V5LCByZWNpcGllbnRIZXhQdWJLZXksIHZhbHVlKTtcbiAgfVxuICBhc3luYyBkZWNyeXB0KHNlbmRlciwgdmFsdWUsIHNjaGVtZSkge1xuICAgIGlmICghdGhpcy5fcHJpdmF0ZUtleSB8fCAhdGhpcy5wcml2YXRlS2V5KSB7XG4gICAgICB0aHJvdyBFcnJvcihcIkF0dGVtcHRlZCB0byBkZWNyeXB0IHdpdGhvdXQgYSBwcml2YXRlIGtleVwiKTtcbiAgICB9XG4gICAgY29uc3Qgc2VuZGVySGV4UHViS2V5ID0gc2VuZGVyLnB1YmtleTtcbiAgICBpZiAoc2NoZW1lID09IFwibmlwNDRcIikge1xuICAgICAgbGV0IGNvbnZlcnNhdGlvbktleSA9IG5pcDQ0LnYyLnV0aWxzLmdldENvbnZlcnNhdGlvbktleSh0aGlzLl9wcml2YXRlS2V5LCBzZW5kZXJIZXhQdWJLZXkpO1xuICAgICAgcmV0dXJuIGF3YWl0IG5pcDQ0LnYyLmRlY3J5cHQodmFsdWUsIGNvbnZlcnNhdGlvbktleSk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCBuaXAwNC5kZWNyeXB0KHRoaXMuX3ByaXZhdGVLZXksIHNlbmRlckhleFB1YktleSwgdmFsdWUpO1xuICB9XG59O1xuXG4vLyBzcmMvc2lnbmVycy9uaXA0Ni9ycGMudHNcbmltcG9ydCB7IEV2ZW50RW1pdHRlciBhcyBFdmVudEVtaXR0ZXI1IH0gZnJvbSBcInRzZWVwXCI7XG52YXIgTkRLTm9zdHJScGMgPSBjbGFzcyBleHRlbmRzIEV2ZW50RW1pdHRlcjUge1xuICBuZGs7XG4gIHNpZ25lcjtcbiAgcmVsYXlTZXQ7XG4gIGRlYnVnO1xuICBlbmNyeXB0aW9uVHlwZSA9IFwibmlwMDRcIjtcbiAgcG9vbDtcbiAgY29uc3RydWN0b3IobmRrLCBzaWduZXIsIGRlYnVnOCwgcmVsYXlVcmxzKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm5kayA9IG5kaztcbiAgICB0aGlzLnNpZ25lciA9IHNpZ25lcjtcbiAgICBpZiAocmVsYXlVcmxzKSB7XG4gICAgICB0aGlzLnBvb2wgPSBuZXcgTkRLUG9vbChcbiAgICAgICAgcmVsYXlVcmxzLFxuICAgICAgICBbXSxcbiAgICAgICAgbmRrLFxuICAgICAgICB7XG4gICAgICAgICAgZGVidWc6IGRlYnVnOC5leHRlbmQoXCJycGMtcG9vbFwiKSxcbiAgICAgICAgICBuYW1lOiBcIk5vc3RyIFJQQ1wiXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICB0aGlzLnJlbGF5U2V0ID0gbmV3IE5ES1JlbGF5U2V0KC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksIG5kaywgdGhpcy5wb29sKTtcbiAgICAgIGZvciAoY29uc3QgdXJsIG9mIHJlbGF5VXJscykge1xuICAgICAgICBjb25zdCByZWxheSA9IHRoaXMucG9vbC5nZXRSZWxheSh1cmwsIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgIHJlbGF5LmF1dGhQb2xpY3kgPSBOREtSZWxheUF1dGhQb2xpY2llcy5zaWduSW4oeyBuZGssIHNpZ25lciwgZGVidWc6IGRlYnVnOCB9KTtcbiAgICAgICAgdGhpcy5yZWxheVNldC5hZGRSZWxheShyZWxheSk7XG4gICAgICAgIHJlbGF5LmNvbm5lY3QoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5kZWJ1ZyA9IGRlYnVnOC5leHRlbmQoXCJycGNcIik7XG4gIH1cbiAgLyoqXG4gICAqIFN1YnNjcmliZSB0byBhIGZpbHRlci4gVGhpcyBmdW5jdGlvbiB3aWxsIHJlc29sdmUgb25jZSB0aGUgc3Vic2NyaXB0aW9uIGlzIHJlYWR5LlxuICAgKi9cbiAgc3Vic2NyaWJlKGZpbHRlcikge1xuICAgIGNvbnN0IHN1YiA9IHRoaXMubmRrLnN1YnNjcmliZShcbiAgICAgIGZpbHRlcixcbiAgICAgIHtcbiAgICAgICAgY2xvc2VPbkVvc2U6IGZhbHNlLFxuICAgICAgICBncm91cGFibGU6IGZhbHNlLFxuICAgICAgICBjYWNoZVVzYWdlOiBcIk9OTFlfUkVMQVlcIiAvKiBPTkxZX1JFTEFZICovLFxuICAgICAgICBwb29sOiB0aGlzLnBvb2xcbiAgICAgIH0sXG4gICAgICB0aGlzLnJlbGF5U2V0LFxuICAgICAgZmFsc2VcbiAgICApO1xuICAgIHN1Yi5vbihcImV2ZW50XCIsIGFzeW5jIChldmVudCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcGFyc2VkRXZlbnQgPSBhd2FpdCB0aGlzLnBhcnNlRXZlbnQoZXZlbnQpO1xuICAgICAgICBpZiAocGFyc2VkRXZlbnQubWV0aG9kKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KFwicmVxdWVzdFwiLCBwYXJzZWRFdmVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5lbWl0KGByZXNwb25zZS0ke3BhcnNlZEV2ZW50LmlkfWAsIHBhcnNlZEV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLmRlYnVnKFwiZXJyb3IgcGFyc2luZyBldmVudFwiLCBlLCBldmVudC5yYXdFdmVudCgpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIHN1Yi5vbihcImVvc2VcIiwgKCkgPT4ge1xuICAgICAgICB0aGlzLmRlYnVnKFwiZW9zZWRcIik7XG4gICAgICAgIHJlc29sdmUoc3ViKTtcbiAgICAgIH0pO1xuICAgICAgc3ViLnN0YXJ0KCk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgcGFyc2VFdmVudChldmVudCkge1xuICAgIGlmICh0aGlzLmVuY3J5cHRpb25UeXBlID09PSBcIm5pcDQ0XCIgJiYgZXZlbnQuY29udGVudC5pbmNsdWRlcyhcIj9pdj1cIikpIHtcbiAgICAgIHRoaXMuZW5jcnlwdGlvblR5cGUgPSBcIm5pcDA0XCI7XG4gICAgfSBlbHNlIGlmICh0aGlzLmVuY3J5cHRpb25UeXBlID09PSBcIm5pcDA0XCIgJiYgIWV2ZW50LmNvbnRlbnQuaW5jbHVkZXMoXCI/aXY9XCIpKSB7XG4gICAgICB0aGlzLmVuY3J5cHRpb25UeXBlID0gXCJuaXA0NFwiO1xuICAgIH1cbiAgICBjb25zdCByZW1vdGVVc2VyID0gdGhpcy5uZGsuZ2V0VXNlcih7IHB1YmtleTogZXZlbnQucHVia2V5IH0pO1xuICAgIHJlbW90ZVVzZXIubmRrID0gdGhpcy5uZGs7XG4gICAgbGV0IGRlY3J5cHRlZENvbnRlbnQ7XG4gICAgdHJ5IHtcbiAgICAgIGRlY3J5cHRlZENvbnRlbnQgPSBhd2FpdCB0aGlzLnNpZ25lci5kZWNyeXB0KFxuICAgICAgICByZW1vdGVVc2VyLFxuICAgICAgICBldmVudC5jb250ZW50LFxuICAgICAgICB0aGlzLmVuY3J5cHRpb25UeXBlXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnN0IG90aGVyRW5jcnlwdGlvblR5cGUgPSB0aGlzLmVuY3J5cHRpb25UeXBlID09PSBcIm5pcDA0XCIgPyBcIm5pcDQ0XCIgOiBcIm5pcDA0XCI7XG4gICAgICBkZWNyeXB0ZWRDb250ZW50ID0gYXdhaXQgdGhpcy5zaWduZXIuZGVjcnlwdChyZW1vdGVVc2VyLCBldmVudC5jb250ZW50LCBvdGhlckVuY3J5cHRpb25UeXBlKTtcbiAgICAgIHRoaXMuZW5jcnlwdGlvblR5cGUgPSBvdGhlckVuY3J5cHRpb25UeXBlO1xuICAgIH1cbiAgICBjb25zdCBwYXJzZWRDb250ZW50ID0gSlNPTi5wYXJzZShkZWNyeXB0ZWRDb250ZW50KTtcbiAgICBjb25zdCB7IGlkLCBtZXRob2QsIHBhcmFtcywgcmVzdWx0LCBlcnJvciB9ID0gcGFyc2VkQ29udGVudDtcbiAgICBpZiAobWV0aG9kKSB7XG4gICAgICByZXR1cm4geyBpZCwgcHVia2V5OiBldmVudC5wdWJrZXksIG1ldGhvZCwgcGFyYW1zLCBldmVudCB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4geyBpZCwgcmVzdWx0LCBlcnJvciwgZXZlbnQgfTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgc2VuZFJlc3BvbnNlKGlkLCByZW1vdGVQdWJrZXksIHJlc3VsdCwga2luZCA9IDI0MTMzIC8qIE5vc3RyQ29ubmVjdCAqLywgZXJyb3IpIHtcbiAgICBjb25zdCByZXMgPSB7IGlkLCByZXN1bHQgfTtcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIHJlcy5lcnJvciA9IGVycm9yO1xuICAgIH1cbiAgICBjb25zdCBsb2NhbFVzZXIgPSBhd2FpdCB0aGlzLnNpZ25lci51c2VyKCk7XG4gICAgY29uc3QgcmVtb3RlVXNlciA9IHRoaXMubmRrLmdldFVzZXIoeyBwdWJrZXk6IHJlbW90ZVB1YmtleSB9KTtcbiAgICBjb25zdCBldmVudCA9IG5ldyBOREtFdmVudCh0aGlzLm5kaywge1xuICAgICAga2luZCxcbiAgICAgIGNvbnRlbnQ6IEpTT04uc3RyaW5naWZ5KHJlcyksXG4gICAgICB0YWdzOiBbW1wicFwiLCByZW1vdGVQdWJrZXldXSxcbiAgICAgIHB1YmtleTogbG9jYWxVc2VyLnB1YmtleVxuICAgIH0pO1xuICAgIGV2ZW50LmNvbnRlbnQgPSBhd2FpdCB0aGlzLnNpZ25lci5lbmNyeXB0KHJlbW90ZVVzZXIsIGV2ZW50LmNvbnRlbnQsIHRoaXMuZW5jcnlwdGlvblR5cGUpO1xuICAgIGF3YWl0IGV2ZW50LnNpZ24odGhpcy5zaWduZXIpO1xuICAgIGF3YWl0IGV2ZW50LnB1Ymxpc2godGhpcy5yZWxheVNldCk7XG4gIH1cbiAgLyoqXG4gICAqIFNlbmRzIGEgcmVxdWVzdC5cbiAgICogQHBhcmFtIHJlbW90ZVB1YmtleVxuICAgKiBAcGFyYW0gbWV0aG9kXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICogQHBhcmFtIGtpbmRcbiAgICogQHBhcmFtIGlkXG4gICAqL1xuICBhc3luYyBzZW5kUmVxdWVzdChyZW1vdGVQdWJrZXksIG1ldGhvZCwgcGFyYW1zID0gW10sIGtpbmQgPSAyNDEzMywgY2IpIHtcbiAgICBjb25zdCBpZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZyg3KTtcbiAgICBjb25zdCBsb2NhbFVzZXIgPSBhd2FpdCB0aGlzLnNpZ25lci51c2VyKCk7XG4gICAgY29uc3QgcmVtb3RlVXNlciA9IHRoaXMubmRrLmdldFVzZXIoeyBwdWJrZXk6IHJlbW90ZVB1YmtleSB9KTtcbiAgICBjb25zdCByZXF1ZXN0ID0geyBpZCwgbWV0aG9kLCBwYXJhbXMgfTtcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKCkgPT4ge1xuICAgICAgY29uc3QgcmVzcG9uc2VIYW5kbGVyID0gKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgIGlmIChyZXNwb25zZS5yZXN1bHQgPT09IFwiYXV0aF91cmxcIikge1xuICAgICAgICAgIHRoaXMub25jZShgcmVzcG9uc2UtJHtpZH1gLCByZXNwb25zZUhhbmRsZXIpO1xuICAgICAgICAgIHRoaXMuZW1pdChcImF1dGhVcmxcIiwgcmVzcG9uc2UuZXJyb3IpO1xuICAgICAgICB9IGVsc2UgaWYgKGNiKSB7XG4gICAgICAgICAgY2IocmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy5vbmNlKGByZXNwb25zZS0ke2lkfWAsIHJlc3BvbnNlSGFuZGxlcik7XG4gICAgfSk7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgTkRLRXZlbnQodGhpcy5uZGssIHtcbiAgICAgIGtpbmQsXG4gICAgICBjb250ZW50OiBKU09OLnN0cmluZ2lmeShyZXF1ZXN0KSxcbiAgICAgIHRhZ3M6IFtbXCJwXCIsIHJlbW90ZVB1YmtleV1dLFxuICAgICAgcHVia2V5OiBsb2NhbFVzZXIucHVia2V5XG4gICAgfSk7XG4gICAgZXZlbnQuY29udGVudCA9IGF3YWl0IHRoaXMuc2lnbmVyLmVuY3J5cHQocmVtb3RlVXNlciwgZXZlbnQuY29udGVudCwgdGhpcy5lbmNyeXB0aW9uVHlwZSk7XG4gICAgYXdhaXQgZXZlbnQuc2lnbih0aGlzLnNpZ25lcik7XG4gICAgYXdhaXQgZXZlbnQucHVibGlzaCh0aGlzLnJlbGF5U2V0KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxufTtcblxuLy8gc3JjL3NpZ25lcnMvbmlwNDYvYmFja2VuZC9waW5nLnRzXG52YXIgUGluZ0V2ZW50SGFuZGxpbmdTdHJhdGVneSA9IGNsYXNzIHtcbiAgYXN5bmMgaGFuZGxlKGJhY2tlbmQsIGlkLCByZW1vdGVQdWJrZXksIHBhcmFtcykge1xuICAgIGNvbnN0IGRlYnVnOCA9IGJhY2tlbmQuZGVidWcuZXh0ZW5kKFwicGluZ1wiKTtcbiAgICBkZWJ1ZzgoYHBpbmcgcmVxdWVzdCBmcm9tICR7cmVtb3RlUHVia2V5fWApO1xuICAgIGlmIChhd2FpdCBiYWNrZW5kLnB1YmtleUFsbG93ZWQoeyBpZCwgcHVia2V5OiByZW1vdGVQdWJrZXksIG1ldGhvZDogXCJwaW5nXCIgfSkpIHtcbiAgICAgIGRlYnVnOChgY29ubmVjdGlvbiByZXF1ZXN0IGZyb20gJHtyZW1vdGVQdWJrZXl9IGFsbG93ZWRgKTtcbiAgICAgIHJldHVybiBcInBvbmdcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWc4KGBjb25uZWN0aW9uIHJlcXVlc3QgZnJvbSAke3JlbW90ZVB1YmtleX0gcmVqZWN0ZWRgKTtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxufTtcblxuLy8gc3JjL3NpZ25lcnMvbmlwNDYvYmFja2VuZC9jb25uZWN0LnRzXG52YXIgQ29ubmVjdEV2ZW50SGFuZGxpbmdTdHJhdGVneSA9IGNsYXNzIHtcbiAgYXN5bmMgaGFuZGxlKGJhY2tlbmQsIGlkLCByZW1vdGVQdWJrZXksIHBhcmFtcykge1xuICAgIGNvbnN0IFtfLCB0b2tlbl0gPSBwYXJhbXM7XG4gICAgY29uc3QgZGVidWc4ID0gYmFja2VuZC5kZWJ1Zy5leHRlbmQoXCJjb25uZWN0XCIpO1xuICAgIGRlYnVnOChgY29ubmVjdGlvbiByZXF1ZXN0IGZyb20gJHtyZW1vdGVQdWJrZXl9YCk7XG4gICAgaWYgKHRva2VuICYmIGJhY2tlbmQuYXBwbHlUb2tlbikge1xuICAgICAgZGVidWc4KGBhcHBseWluZyB0b2tlbmApO1xuICAgICAgYXdhaXQgYmFja2VuZC5hcHBseVRva2VuKHJlbW90ZVB1YmtleSwgdG9rZW4pO1xuICAgIH1cbiAgICBpZiAoYXdhaXQgYmFja2VuZC5wdWJrZXlBbGxvd2VkKHtcbiAgICAgIGlkLFxuICAgICAgcHVia2V5OiByZW1vdGVQdWJrZXksXG4gICAgICBtZXRob2Q6IFwiY29ubmVjdFwiLFxuICAgICAgcGFyYW1zOiB0b2tlblxuICAgIH0pKSB7XG4gICAgICBkZWJ1ZzgoYGNvbm5lY3Rpb24gcmVxdWVzdCBmcm9tICR7cmVtb3RlUHVia2V5fSBhbGxvd2VkYCk7XG4gICAgICByZXR1cm4gXCJhY2tcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWc4KGBjb25uZWN0aW9uIHJlcXVlc3QgZnJvbSAke3JlbW90ZVB1YmtleX0gcmVqZWN0ZWRgKTtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxufTtcblxuLy8gc3JjL3NpZ25lcnMvbmlwNDYvYmFja2VuZC9nZXQtcHVibGljLWtleS50c1xudmFyIEdldFB1YmxpY0tleUhhbmRsaW5nU3RyYXRlZ3kgPSBjbGFzcyB7XG4gIGFzeW5jIGhhbmRsZShiYWNrZW5kLCBpZCwgcmVtb3RlUHVia2V5LCBwYXJhbXMpIHtcbiAgICByZXR1cm4gYmFja2VuZC5sb2NhbFVzZXI/LnB1YmtleTtcbiAgfVxufTtcblxuLy8gc3JjL3NpZ25lcnMvbmlwNDYvYmFja2VuZC9uaXAwNC1kZWNyeXB0LnRzXG52YXIgTmlwMDREZWNyeXB0SGFuZGxpbmdTdHJhdGVneSA9IGNsYXNzIHtcbiAgYXN5bmMgaGFuZGxlKGJhY2tlbmQsIGlkLCByZW1vdGVQdWJrZXksIHBhcmFtcykge1xuICAgIGNvbnN0IFtzZW5kZXJQdWJrZXksIHBheWxvYWRdID0gcGFyYW1zO1xuICAgIGNvbnN0IHNlbmRlclVzZXIgPSBuZXcgTkRLVXNlcih7IHB1YmtleTogc2VuZGVyUHVia2V5IH0pO1xuICAgIGNvbnN0IGRlY3J5cHRlZFBheWxvYWQgPSBhd2FpdCBkZWNyeXB0MihiYWNrZW5kLCBpZCwgcmVtb3RlUHVia2V5LCBzZW5kZXJVc2VyLCBwYXlsb2FkKTtcbiAgICByZXR1cm4gZGVjcnlwdGVkUGF5bG9hZDtcbiAgfVxufTtcbmFzeW5jIGZ1bmN0aW9uIGRlY3J5cHQyKGJhY2tlbmQsIGlkLCByZW1vdGVQdWJrZXksIHNlbmRlclVzZXIsIHBheWxvYWQpIHtcbiAgaWYgKCFhd2FpdCBiYWNrZW5kLnB1YmtleUFsbG93ZWQoe1xuICAgIGlkLFxuICAgIHB1YmtleTogcmVtb3RlUHVia2V5LFxuICAgIG1ldGhvZDogXCJuaXAwNF9kZWNyeXB0XCIsXG4gICAgcGFyYW1zOiBwYXlsb2FkXG4gIH0pKSB7XG4gICAgYmFja2VuZC5kZWJ1ZyhgZGVjcnlwdCByZXF1ZXN0IGZyb20gJHtyZW1vdGVQdWJrZXl9IHJlamVjdGVkYCk7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4gYXdhaXQgYmFja2VuZC5zaWduZXIuZGVjcnlwdChzZW5kZXJVc2VyLCBwYXlsb2FkLCBcIm5pcDA0XCIpO1xufVxuXG4vLyBzcmMvc2lnbmVycy9uaXA0Ni9iYWNrZW5kL25pcDA0LWVuY3J5cHQudHNcbnZhciBOaXAwNEVuY3J5cHRIYW5kbGluZ1N0cmF0ZWd5ID0gY2xhc3Mge1xuICBhc3luYyBoYW5kbGUoYmFja2VuZCwgaWQsIHJlbW90ZVB1YmtleSwgcGFyYW1zKSB7XG4gICAgY29uc3QgW3JlY2lwaWVudFB1YmtleSwgcGF5bG9hZF0gPSBwYXJhbXM7XG4gICAgY29uc3QgcmVjaXBpZW50VXNlciA9IG5ldyBOREtVc2VyKHsgcHVia2V5OiByZWNpcGllbnRQdWJrZXkgfSk7XG4gICAgY29uc3QgZW5jcnlwdGVkUGF5bG9hZCA9IGF3YWl0IGVuY3J5cHQyKGJhY2tlbmQsIGlkLCByZW1vdGVQdWJrZXksIHJlY2lwaWVudFVzZXIsIHBheWxvYWQpO1xuICAgIHJldHVybiBlbmNyeXB0ZWRQYXlsb2FkO1xuICB9XG59O1xuYXN5bmMgZnVuY3Rpb24gZW5jcnlwdDIoYmFja2VuZCwgaWQsIHJlbW90ZVB1YmtleSwgcmVjaXBpZW50VXNlciwgcGF5bG9hZCkge1xuICBpZiAoIWF3YWl0IGJhY2tlbmQucHVia2V5QWxsb3dlZCh7XG4gICAgaWQsXG4gICAgcHVia2V5OiByZW1vdGVQdWJrZXksXG4gICAgbWV0aG9kOiBcIm5pcDA0X2VuY3J5cHRcIixcbiAgICBwYXJhbXM6IHBheWxvYWRcbiAgfSkpIHtcbiAgICBiYWNrZW5kLmRlYnVnKGBlbmNyeXB0IHJlcXVlc3QgZnJvbSAke3JlbW90ZVB1YmtleX0gcmVqZWN0ZWRgKTtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHJldHVybiBhd2FpdCBiYWNrZW5kLnNpZ25lci5lbmNyeXB0KHJlY2lwaWVudFVzZXIsIHBheWxvYWQsIFwibmlwMDRcIik7XG59XG5cbi8vIHNyYy9zaWduZXJzL25pcDQ2L2JhY2tlbmQvc2lnbi1ldmVudC50c1xudmFyIFNpZ25FdmVudEhhbmRsaW5nU3RyYXRlZ3kgPSBjbGFzcyB7XG4gIGFzeW5jIGhhbmRsZShiYWNrZW5kLCBpZCwgcmVtb3RlUHVia2V5LCBwYXJhbXMpIHtcbiAgICBjb25zdCBldmVudCA9IGF3YWl0IHNpZ25FdmVudChiYWNrZW5kLCBpZCwgcmVtb3RlUHVia2V5LCBwYXJhbXMpO1xuICAgIGlmICghZXZlbnQpIHJldHVybiB2b2lkIDA7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGF3YWl0IGV2ZW50LnRvTm9zdHJFdmVudCgpKTtcbiAgfVxufTtcbmFzeW5jIGZ1bmN0aW9uIHNpZ25FdmVudChiYWNrZW5kLCBpZCwgcmVtb3RlUHVia2V5LCBwYXJhbXMpIHtcbiAgY29uc3QgW2V2ZW50U3RyaW5nXSA9IHBhcmFtcztcbiAgYmFja2VuZC5kZWJ1Zyhgc2lnbiBldmVudCByZXF1ZXN0IGZyb20gJHtyZW1vdGVQdWJrZXl9YCk7XG4gIGNvbnN0IGV2ZW50ID0gbmV3IE5ES0V2ZW50KGJhY2tlbmQubmRrLCBKU09OLnBhcnNlKGV2ZW50U3RyaW5nKSk7XG4gIGJhY2tlbmQuZGVidWcoXCJldmVudCB0byBzaWduXCIsIGV2ZW50LnJhd0V2ZW50KCkpO1xuICBpZiAoIWF3YWl0IGJhY2tlbmQucHVia2V5QWxsb3dlZCh7XG4gICAgaWQsXG4gICAgcHVia2V5OiByZW1vdGVQdWJrZXksXG4gICAgbWV0aG9kOiBcInNpZ25fZXZlbnRcIixcbiAgICBwYXJhbXM6IGV2ZW50XG4gIH0pKSB7XG4gICAgYmFja2VuZC5kZWJ1Zyhgc2lnbiBldmVudCByZXF1ZXN0IGZyb20gJHtyZW1vdGVQdWJrZXl9IHJlamVjdGVkYCk7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBiYWNrZW5kLmRlYnVnKGBzaWduIGV2ZW50IHJlcXVlc3QgZnJvbSAke3JlbW90ZVB1YmtleX0gYWxsb3dlZGApO1xuICBhd2FpdCBldmVudC5zaWduKGJhY2tlbmQuc2lnbmVyKTtcbiAgcmV0dXJuIGV2ZW50O1xufVxuXG4vLyBzcmMvc2lnbmVycy9uaXA0Ni9iYWNrZW5kL25pcDQ0LWVuY3J5cHQudHNcbnZhciBOaXAwNEVuY3J5cHRIYW5kbGluZ1N0cmF0ZWd5MiA9IGNsYXNzIHtcbiAgYXN5bmMgaGFuZGxlKGJhY2tlbmQsIGlkLCByZW1vdGVQdWJrZXksIHBhcmFtcykge1xuICAgIGNvbnN0IFtyZWNpcGllbnRQdWJrZXksIHBheWxvYWRdID0gcGFyYW1zO1xuICAgIGNvbnN0IHJlY2lwaWVudFVzZXIgPSBuZXcgTkRLVXNlcih7IHB1YmtleTogcmVjaXBpZW50UHVia2V5IH0pO1xuICAgIGNvbnN0IGVuY3J5cHRlZFBheWxvYWQgPSBhd2FpdCBlbmNyeXB0MyhiYWNrZW5kLCBpZCwgcmVtb3RlUHVia2V5LCByZWNpcGllbnRVc2VyLCBwYXlsb2FkKTtcbiAgICByZXR1cm4gZW5jcnlwdGVkUGF5bG9hZDtcbiAgfVxufTtcbmFzeW5jIGZ1bmN0aW9uIGVuY3J5cHQzKGJhY2tlbmQsIGlkLCByZW1vdGVQdWJrZXksIHJlY2lwaWVudFVzZXIsIHBheWxvYWQpIHtcbiAgaWYgKCFhd2FpdCBiYWNrZW5kLnB1YmtleUFsbG93ZWQoe1xuICAgIGlkLFxuICAgIHB1YmtleTogcmVtb3RlUHVia2V5LFxuICAgIG1ldGhvZDogXCJuaXA0NF9lbmNyeXB0XCIsXG4gICAgcGFyYW1zOiBwYXlsb2FkXG4gIH0pKSB7XG4gICAgYmFja2VuZC5kZWJ1ZyhgZW5jcnlwdCByZXF1ZXN0IGZyb20gJHtyZW1vdGVQdWJrZXl9IHJlamVjdGVkYCk7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4gYXdhaXQgYmFja2VuZC5zaWduZXIuZW5jcnlwdChyZWNpcGllbnRVc2VyLCBwYXlsb2FkLCBcIm5pcDQ0XCIpO1xufVxuXG4vLyBzcmMvc2lnbmVycy9uaXA0Ni9iYWNrZW5kL25pcDQ0LWRlY3J5cHQudHNcbnZhciBOaXAwNERlY3J5cHRIYW5kbGluZ1N0cmF0ZWd5MiA9IGNsYXNzIHtcbiAgYXN5bmMgaGFuZGxlKGJhY2tlbmQsIGlkLCByZW1vdGVQdWJrZXksIHBhcmFtcykge1xuICAgIGNvbnN0IFtzZW5kZXJQdWJrZXksIHBheWxvYWRdID0gcGFyYW1zO1xuICAgIGNvbnN0IHNlbmRlclVzZXIgPSBuZXcgTkRLVXNlcih7IHB1YmtleTogc2VuZGVyUHVia2V5IH0pO1xuICAgIGNvbnN0IGRlY3J5cHRlZFBheWxvYWQgPSBhd2FpdCBkZWNyeXB0MyhiYWNrZW5kLCBpZCwgcmVtb3RlUHVia2V5LCBzZW5kZXJVc2VyLCBwYXlsb2FkKTtcbiAgICByZXR1cm4gZGVjcnlwdGVkUGF5bG9hZDtcbiAgfVxufTtcbmFzeW5jIGZ1bmN0aW9uIGRlY3J5cHQzKGJhY2tlbmQsIGlkLCByZW1vdGVQdWJrZXksIHNlbmRlclVzZXIsIHBheWxvYWQpIHtcbiAgaWYgKCFhd2FpdCBiYWNrZW5kLnB1YmtleUFsbG93ZWQoe1xuICAgIGlkLFxuICAgIHB1YmtleTogcmVtb3RlUHVia2V5LFxuICAgIG1ldGhvZDogXCJuaXA0NF9kZWNyeXB0XCIsXG4gICAgcGFyYW1zOiBwYXlsb2FkXG4gIH0pKSB7XG4gICAgYmFja2VuZC5kZWJ1ZyhgZGVjcnlwdCByZXF1ZXN0IGZyb20gJHtyZW1vdGVQdWJrZXl9IHJlamVjdGVkYCk7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4gYXdhaXQgYmFja2VuZC5zaWduZXIuZGVjcnlwdChzZW5kZXJVc2VyLCBwYXlsb2FkLCBcIm5pcDQ0XCIpO1xufVxuXG4vLyBzcmMvc2lnbmVycy9uaXA0Ni9iYWNrZW5kL2luZGV4LnRzXG5pbXBvcnQgeyBoZXhUb0J5dGVzIGFzIGhleFRvQnl0ZXMyIH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvdXRpbHNcIjtcbnZhciBOREtOaXA0NkJhY2tlbmQgPSBjbGFzcyB7XG4gIG5kaztcbiAgc2lnbmVyO1xuICBsb2NhbFVzZXI7XG4gIGRlYnVnO1xuICBycGM7XG4gIHBlcm1pdENhbGxiYWNrO1xuICByZWxheVVybHM7XG4gIC8qKlxuICAgKiBAcGFyYW0gbmRrIFRoZSBOREsgaW5zdGFuY2UgdG8gdXNlXG4gICAqIEBwYXJhbSBwcml2YXRlS2V5T3JTaWduZXIgVGhlIHByaXZhdGUga2V5IG9yIHNpZ25lciBvZiB0aGUgbnB1YiB0aGF0IHdhbnRzIHRvIGJlIHB1Ymxpc2hlZCBhc1xuICAgKiBAcGFyYW0gcGVybWl0Q2FsbGJhY2sgQ2FsbGJhY2sgZXhlY3V0ZWQgd2hlbiBwZXJtaXNzaW9uIGlzIHJlcXVlc3RlZFxuICAgKi9cbiAgY29uc3RydWN0b3IobmRrLCBwcml2YXRlS2V5T3JTaWduZXIsIHBlcm1pdENhbGxiYWNrLCByZWxheVVybHMpIHtcbiAgICB0aGlzLm5kayA9IG5kaztcbiAgICBpZiAocHJpdmF0ZUtleU9yU2lnbmVyIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgdGhpcy5zaWduZXIgPSBuZXcgTkRLUHJpdmF0ZUtleVNpZ25lcihwcml2YXRlS2V5T3JTaWduZXIpO1xuICAgIH0gZWxzZSBpZiAocHJpdmF0ZUtleU9yU2lnbmVyIGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgICB0aGlzLnNpZ25lciA9IG5ldyBOREtQcml2YXRlS2V5U2lnbmVyKGhleFRvQnl0ZXMyKHByaXZhdGVLZXlPclNpZ25lcikpO1xuICAgIH0gZWxzZSBpZiAocHJpdmF0ZUtleU9yU2lnbmVyIGluc3RhbmNlb2YgTkRLUHJpdmF0ZUtleVNpZ25lcikge1xuICAgICAgdGhpcy5zaWduZXIgPSBwcml2YXRlS2V5T3JTaWduZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2lnbmVyXCIpO1xuICAgIH1cbiAgICB0aGlzLmRlYnVnID0gbmRrLmRlYnVnLmV4dGVuZChcIm5pcDQ2OmJhY2tlbmRcIik7XG4gICAgdGhpcy5yZWxheVVybHMgPSByZWxheVVybHMgPz8gQXJyYXkuZnJvbShuZGsucG9vbC5yZWxheXMua2V5cygpKTtcbiAgICB0aGlzLnJwYyA9IG5ldyBOREtOb3N0clJwYyhuZGssIHRoaXMuc2lnbmVyLCB0aGlzLmRlYnVnLCB0aGlzLnJlbGF5VXJscyk7XG4gICAgdGhpcy5wZXJtaXRDYWxsYmFjayA9IHBlcm1pdENhbGxiYWNrO1xuICB9XG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBzdGFydHMgdGhlIGJhY2tlbmQsIHdoaWNoIHdpbGwgc3RhcnQgbGlzdGVuaW5nIGZvciBpbmNvbWluZ1xuICAgKiByZXF1ZXN0cy5cbiAgICovXG4gIGFzeW5jIHN0YXJ0KCkge1xuICAgIHRoaXMubG9jYWxVc2VyID0gYXdhaXQgdGhpcy5zaWduZXIudXNlcigpO1xuICAgIGNvbnN0IHN1YiA9IHRoaXMubmRrLnN1YnNjcmliZShcbiAgICAgIHtcbiAgICAgICAga2luZHM6IFsyNDEzM10sXG4gICAgICAgIFwiI3BcIjogW3RoaXMubG9jYWxVc2VyLnB1YmtleV1cbiAgICAgIH0sXG4gICAgICB7IGNsb3NlT25Fb3NlOiBmYWxzZSB9XG4gICAgKTtcbiAgICBzdWIub24oXCJldmVudFwiLCAoZSkgPT4gdGhpcy5oYW5kbGVJbmNvbWluZ0V2ZW50KGUpKTtcbiAgfVxuICBoYW5kbGVycyA9IHtcbiAgICBjb25uZWN0OiBuZXcgQ29ubmVjdEV2ZW50SGFuZGxpbmdTdHJhdGVneSgpLFxuICAgIHNpZ25fZXZlbnQ6IG5ldyBTaWduRXZlbnRIYW5kbGluZ1N0cmF0ZWd5KCksXG4gICAgbmlwMDRfZW5jcnlwdDogbmV3IE5pcDA0RW5jcnlwdEhhbmRsaW5nU3RyYXRlZ3koKSxcbiAgICBuaXAwNF9kZWNyeXB0OiBuZXcgTmlwMDREZWNyeXB0SGFuZGxpbmdTdHJhdGVneSgpLFxuICAgIG5pcDQ0X2VuY3J5cHQ6IG5ldyBOaXAwNEVuY3J5cHRIYW5kbGluZ1N0cmF0ZWd5MigpLFxuICAgIG5pcDQ0X2RlY3J5cHQ6IG5ldyBOaXAwNERlY3J5cHRIYW5kbGluZ1N0cmF0ZWd5MigpLFxuICAgIGdldF9wdWJsaWNfa2V5OiBuZXcgR2V0UHVibGljS2V5SGFuZGxpbmdTdHJhdGVneSgpLFxuICAgIHBpbmc6IG5ldyBQaW5nRXZlbnRIYW5kbGluZ1N0cmF0ZWd5KClcbiAgfTtcbiAgLyoqXG4gICAqIEVuYWJsZXMgdGhlIHVzZXIgdG8gc2V0IGEgY3VzdG9tIHN0cmF0ZWd5IGZvciBoYW5kbGluZyBpbmNvbWluZyBldmVudHMuXG4gICAqIEBwYXJhbSBtZXRob2QgLSBUaGUgbWV0aG9kIHRvIHNldCB0aGUgc3RyYXRlZ3kgZm9yXG4gICAqIEBwYXJhbSBzdHJhdGVneSAtIFRoZSBzdHJhdGVneSB0byBzZXRcbiAgICovXG4gIHNldFN0cmF0ZWd5KG1ldGhvZCwgc3RyYXRlZ3kpIHtcbiAgICB0aGlzLmhhbmRsZXJzW21ldGhvZF0gPSBzdHJhdGVneTtcbiAgfVxuICAvKipcbiAgICogT3ZlcmxvYWQgdGhpcyBtZXRob2QgdG8gYXBwbHkgdG9rZW5zLCB3aGljaCBjYW5cbiAgICogd3JhcCBwZXJtaXNzaW9uIHNldHMgdG8gYmUgYXBwbGllZCB0byBhIHB1YmtleS5cbiAgICogQHBhcmFtIHB1YmtleSBwdWJsaWMga2V5IHRvIGFwcGx5IHRva2VuIHRvXG4gICAqIEBwYXJhbSB0b2tlbiB0b2tlbiB0byBhcHBseVxuICAgKi9cbiAgYXN5bmMgYXBwbHlUb2tlbihwdWJrZXksIHRva2VuKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY29ubmVjdGlvbiB0b2tlbiBub3Qgc3VwcG9ydGVkXCIpO1xuICB9XG4gIGFzeW5jIGhhbmRsZUluY29taW5nRXZlbnQoZXZlbnQpIHtcbiAgICBjb25zdCB7IGlkLCBtZXRob2QsIHBhcmFtcyB9ID0gYXdhaXQgdGhpcy5ycGMucGFyc2VFdmVudChldmVudCk7XG4gICAgY29uc3QgcmVtb3RlUHVia2V5ID0gZXZlbnQucHVia2V5O1xuICAgIGxldCByZXNwb25zZTtcbiAgICB0aGlzLmRlYnVnKFwiaW5jb21pbmcgZXZlbnRcIiwgeyBpZCwgbWV0aG9kLCBwYXJhbXMgfSk7XG4gICAgaWYgKCFldmVudC52ZXJpZnlTaWduYXR1cmUoZmFsc2UpKSB7XG4gICAgICB0aGlzLmRlYnVnKFwiaW52YWxpZCBzaWduYXR1cmVcIiwgZXZlbnQucmF3RXZlbnQoKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0cmF0ZWd5ID0gdGhpcy5oYW5kbGVyc1ttZXRob2RdO1xuICAgIGlmIChzdHJhdGVneSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCBzdHJhdGVneS5oYW5kbGUodGhpcywgaWQsIHJlbW90ZVB1YmtleSwgcGFyYW1zKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhpcy5kZWJ1ZyhcImVycm9yIGhhbmRsaW5nIGV2ZW50XCIsIGUsIHsgaWQsIG1ldGhvZCwgcGFyYW1zIH0pO1xuICAgICAgICB0aGlzLnJwYy5zZW5kUmVzcG9uc2UoaWQsIHJlbW90ZVB1YmtleSwgXCJlcnJvclwiLCB2b2lkIDAsIGUubWVzc2FnZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVidWcoXCJ1bnN1cHBvcnRlZCBtZXRob2RcIiwgeyBtZXRob2QsIHBhcmFtcyB9KTtcbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICB0aGlzLmRlYnVnKGBzZW5kaW5nIHJlc3BvbnNlIHRvICR7cmVtb3RlUHVia2V5fWAsIHJlc3BvbnNlKTtcbiAgICAgIHRoaXMucnBjLnNlbmRSZXNwb25zZShpZCwgcmVtb3RlUHVia2V5LCByZXNwb25zZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucnBjLnNlbmRSZXNwb25zZShpZCwgcmVtb3RlUHVia2V5LCBcImVycm9yXCIsIHZvaWQgMCwgXCJOb3QgYXV0aG9yaXplZFwiKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBvdmVycmlkZW4gYnkgdGhlIHVzZXIgdG8gYWxsb3cgb3IgcmVqZWN0IGluY29taW5nXG4gICAqIGNvbm5lY3Rpb25zLlxuICAgKi9cbiAgYXN5bmMgcHVia2V5QWxsb3dlZChwYXJhbXMpIHtcbiAgICByZXR1cm4gdGhpcy5wZXJtaXRDYWxsYmFjayhwYXJhbXMpO1xuICB9XG59O1xuXG4vLyBzcmMvc2lnbmVycy9uaXA0Ni9pbmRleC50c1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIGFzIEV2ZW50RW1pdHRlcjYgfSBmcm9tIFwidHNlZXBcIjtcbnZhciBOREtOaXA0NlNpZ25lciA9IGNsYXNzIGV4dGVuZHMgRXZlbnRFbWl0dGVyNiB7XG4gIG5kaztcbiAgX3VzZXI7XG4gIC8qKlxuICAgKiBUaGUgcHVia2V5IG9mIHRoZSBidW5rZXIgdGhhdCB3aWxsIGJlIHByb3ZpZGluZyBzaWduYXR1cmVzXG4gICAqL1xuICBidW5rZXJQdWJrZXk7XG4gIC8qKlxuICAgKiBUaGUgcHVia2V5IG9mIHRoZSB1c2VyIHRoYXQgZXZlbnRzIHdpbGwgYmUgcHVibGlzaGVkIGFzXG4gICAqL1xuICB1c2VyUHVia2V5O1xuICAvKipcbiAgICogQW4gb3B0aW9uYWwgc2VjcmV0IHZhbHVlIHByb3ZpZGVkIHRvIGNvbm5lY3QgdG8gdGhlIGJ1bmtlclxuICAgKi9cbiAgc2VjcmV0O1xuICBsb2NhbFNpZ25lcjtcbiAgbmlwMDU7XG4gIHJwYztcbiAgZGVidWc7XG4gIHJlbGF5VXJscztcbiAgc3Vic2NyaXB0aW9uO1xuICAvKipcbiAgICogQHBhcmFtIG5kayAtIFRoZSBOREsgaW5zdGFuY2UgdG8gdXNlXG4gICAqIEBwYXJhbSB1c2VyT3JDb25uZWN0aW9uVG9rZW4gLSBUaGUgcHVibGljIGtleSwgb3IgYSBjb25uZWN0aW9uIHRva2VuLCBvZiB0aGUgbnB1YiB0aGF0IHdhbnRzIHRvIGJlIHB1Ymxpc2hlZCBhc1xuICAgKiBAcGFyYW0gbG9jYWxTaWduZXIgLSBUaGUgc2lnbmVyIHRoYXQgd2lsbCBiZSB1c2VkIHRvIHJlcXVlc3QgZXZlbnRzIHRvIGJlIHNpZ25lZFxuICAgKi9cbiAgY29uc3RydWN0b3IobmRrLCB1c2VyT3JDb25uZWN0aW9uVG9rZW4sIGxvY2FsU2lnbmVyKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm5kayA9IG5kaztcbiAgICB0aGlzLmRlYnVnID0gbmRrLmRlYnVnLmV4dGVuZChcIm5pcDQ2OnNpZ25lclwiKTtcbiAgICBpZiAodXNlck9yQ29ubmVjdGlvblRva2VuLnN0YXJ0c1dpdGgoXCJidW5rZXI6Ly9cIikpIHtcbiAgICAgIHRoaXMuY29ubmVjdGlvblRva2VuSW5pdCh1c2VyT3JDb25uZWN0aW9uVG9rZW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm5pcDA1SW5pdCh1c2VyT3JDb25uZWN0aW9uVG9rZW4pO1xuICAgIH1cbiAgICBpZiAoIWxvY2FsU2lnbmVyKSB7XG4gICAgICB0aGlzLmxvY2FsU2lnbmVyID0gTkRLUHJpdmF0ZUtleVNpZ25lci5nZW5lcmF0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxvY2FsU2lnbmVyID0gbG9jYWxTaWduZXI7XG4gICAgfVxuICAgIHRoaXMucnBjID0gbmV3IE5ES05vc3RyUnBjKHRoaXMubmRrLCB0aGlzLmxvY2FsU2lnbmVyLCB0aGlzLmRlYnVnLCB0aGlzLnJlbGF5VXJscyk7XG4gIH1cbiAgY29ubmVjdGlvblRva2VuSW5pdChjb25uZWN0aW9uVG9rZW4pIHtcbiAgICBjb25zdCBidW5rZXJVcmwgPSBuZXcgVVJMKGNvbm5lY3Rpb25Ub2tlbik7XG4gICAgY29uc3QgYnVua2VyUHVia2V5ID0gYnVua2VyVXJsLmhvc3RuYW1lIHx8IGJ1bmtlclVybC5wYXRobmFtZS5yZXBsYWNlKC9eXFwvXFwvLywgXCJcIik7XG4gICAgY29uc3QgdXNlclB1YmtleSA9IGJ1bmtlclVybC5zZWFyY2hQYXJhbXMuZ2V0KFwicHVia2V5XCIpO1xuICAgIGNvbnN0IHJlbGF5VXJscyA9IGJ1bmtlclVybC5zZWFyY2hQYXJhbXMuZ2V0QWxsKFwicmVsYXlcIik7XG4gICAgY29uc3Qgc2VjcmV0ID0gYnVua2VyVXJsLnNlYXJjaFBhcmFtcy5nZXQoXCJzZWNyZXRcIik7XG4gICAgdGhpcy5idW5rZXJQdWJrZXkgPSBidW5rZXJQdWJrZXk7XG4gICAgdGhpcy51c2VyUHVia2V5ID0gdXNlclB1YmtleTtcbiAgICB0aGlzLnJlbGF5VXJscyA9IHJlbGF5VXJscztcbiAgICB0aGlzLnNlY3JldCA9IHNlY3JldDtcbiAgfVxuICBuaXAwNUluaXQobmlwMDUpIHtcbiAgICB0aGlzLm5pcDA1ID0gbmlwMDU7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSB1c2VyUHVia2V5IGluc3RlYWRcbiAgICovXG4gIGdldCByZW1vdGVQdWJrZXkoKSB7XG4gICAgcmV0dXJuIHRoaXMudXNlclB1YmtleTtcbiAgfVxuICAvKipcbiAgICogV2Ugc3RhcnQgbGlzdGVuaW5nIGZvciBldmVudHMgZnJvbSB0aGUgYnVua2VyXG4gICAqL1xuICBhc3luYyBzdGFydExpc3RlbmluZygpIHtcbiAgICBpZiAodGhpcy5zdWJzY3JpcHRpb24pIHJldHVybjtcbiAgICBjb25zdCBsb2NhbFVzZXIgPSBhd2FpdCB0aGlzLmxvY2FsU2lnbmVyLnVzZXIoKTtcbiAgICBpZiAoIWxvY2FsVXNlcikgdGhyb3cgbmV3IEVycm9yKFwiTG9jYWwgc2lnbmVyIG5vdCByZWFkeVwiKTtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IGF3YWl0IHRoaXMucnBjLnN1YnNjcmliZSh7XG4gICAgICBraW5kczogWzI0MTMzIC8qIE5vc3RyQ29ubmVjdCAqL10sXG4gICAgICBcIiNwXCI6IFtsb2NhbFVzZXIucHVia2V5XVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIHVzZXIgdGhhdCBpcyBiZWluZyBwdWJsaXNoZWQgYXNcbiAgICovXG4gIGFzeW5jIHVzZXIoKSB7XG4gICAgaWYgKCF0aGlzLl91c2VyICYmICF0aGlzLnVzZXJQdWJrZXkpIHRocm93IG5ldyBFcnJvcihcIlJlbW90ZSB1c2VyIG5vdCByZWFkeVwiKTtcbiAgICB0aGlzLl91c2VyID8/PSBuZXcgTkRLVXNlcih7IHB1YmtleTogdGhpcy51c2VyUHVia2V5IH0pO1xuICAgIHJldHVybiB0aGlzLl91c2VyO1xuICB9XG4gIGFzeW5jIGJsb2NrVW50aWxSZWFkeSgpIHtcbiAgICBpZiAodGhpcy5uaXAwNSAmJiAhdGhpcy51c2VyUHVia2V5KSB7XG4gICAgICBjb25zdCB1c2VyID0gYXdhaXQgTkRLVXNlci5mcm9tTmlwMDUodGhpcy5uaXAwNSwgdGhpcy5uZGspO1xuICAgICAgaWYgKHVzZXIpIHtcbiAgICAgICAgdGhpcy5fdXNlciA9IHVzZXI7XG4gICAgICAgIHRoaXMudXNlclB1YmtleSA9IHVzZXIucHVia2V5O1xuICAgICAgICB0aGlzLnJlbGF5VXJscyA9IHVzZXIubmlwNDZVcmxzO1xuICAgICAgICB0aGlzLnJwYyA9IG5ldyBOREtOb3N0clJwYyh0aGlzLm5kaywgdGhpcy5sb2NhbFNpZ25lciwgdGhpcy5kZWJ1ZywgdGhpcy5yZWxheVVybHMpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRoaXMuYnVua2VyUHVia2V5ICYmIHRoaXMudXNlclB1YmtleSkge1xuICAgICAgdGhpcy5idW5rZXJQdWJrZXkgPSB0aGlzLnVzZXJQdWJrZXk7XG4gICAgfSBlbHNlIGlmICghdGhpcy5idW5rZXJQdWJrZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkJ1bmtlciBwdWJrZXkgbm90IHNldFwiKTtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5zdGFydExpc3RlbmluZygpO1xuICAgIHRoaXMucnBjLm9uKFwiYXV0aFVybFwiLCAoLi4ucHJvcHMpID0+IHtcbiAgICAgIHRoaXMuZW1pdChcImF1dGhVcmxcIiwgLi4ucHJvcHMpO1xuICAgIH0pO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBjb25uZWN0UGFyYW1zID0gW3RoaXMudXNlclB1YmtleSA/PyBcIlwiXTtcbiAgICAgIGlmICh0aGlzLnNlY3JldCkgY29ubmVjdFBhcmFtcy5wdXNoKHRoaXMuc2VjcmV0KTtcbiAgICAgIGlmICghdGhpcy5idW5rZXJQdWJrZXkpIHRocm93IG5ldyBFcnJvcihcIkJ1bmtlciBwdWJrZXkgbm90IHNldFwiKTtcbiAgICAgIHRoaXMucnBjLnNlbmRSZXF1ZXN0KFxuICAgICAgICB0aGlzLmJ1bmtlclB1YmtleSxcbiAgICAgICAgXCJjb25uZWN0XCIsXG4gICAgICAgIGNvbm5lY3RQYXJhbXMsXG4gICAgICAgIDI0MTMzLFxuICAgICAgICAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICBpZiAocmVzcG9uc2UucmVzdWx0ID09PSBcImFja1wiKSB7XG4gICAgICAgICAgICB0aGlzLmdldFB1YmxpY0tleSgpLnRoZW4oKHB1YmtleSkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLnVzZXJQdWJrZXkgPSBwdWJrZXk7XG4gICAgICAgICAgICAgIHRoaXMuX3VzZXIgPSBuZXcgTkRLVXNlcih7IHB1YmtleSB9KTtcbiAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLl91c2VyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWplY3QocmVzcG9uc2UuZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBnZXRQdWJsaWNLZXkoKSB7XG4gICAgaWYgKHRoaXMudXNlclB1YmtleSkgcmV0dXJuIHRoaXMudXNlclB1YmtleTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLmJ1bmtlclB1YmtleSkgdGhyb3cgbmV3IEVycm9yKFwiQnVua2VyIHB1YmtleSBub3Qgc2V0XCIpO1xuICAgICAgdGhpcy5ycGMuc2VuZFJlcXVlc3QoXG4gICAgICAgIHRoaXMuYnVua2VyUHVia2V5LFxuICAgICAgICBcImdldF9wdWJsaWNfa2V5XCIsXG4gICAgICAgIFtdLFxuICAgICAgICAyNDEzMyxcbiAgICAgICAgKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgcmVzb2x2ZShyZXNwb25zZS5yZXN1bHQpO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGVuY3J5cHRpb25FbmFibGVkKHNjaGVtZSkge1xuICAgIGlmIChzY2hlbWUpIHJldHVybiBbc2NoZW1lXTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFtcIm5pcDA0XCIsIFwibmlwNDRcIl0pO1xuICB9XG4gIGFzeW5jIGVuY3J5cHQocmVjaXBpZW50LCB2YWx1ZSwgc2NoZW1lID0gXCJuaXAwNFwiKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5jcnlwdGlvbihyZWNpcGllbnQsIHZhbHVlLCBzY2hlbWUsIFwiZW5jcnlwdFwiKTtcbiAgfVxuICBhc3luYyBkZWNyeXB0KHNlbmRlciwgdmFsdWUsIHNjaGVtZSA9IFwibmlwMDRcIikge1xuICAgIHJldHVybiB0aGlzLmVuY3J5cHRpb24oc2VuZGVyLCB2YWx1ZSwgc2NoZW1lLCBcImRlY3J5cHRcIik7XG4gIH1cbiAgYXN5bmMgZW5jcnlwdGlvbihwZWVyLCB2YWx1ZSwgc2NoZW1lLCBtZXRob2QpIHtcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLmJ1bmtlclB1YmtleSkgdGhyb3cgbmV3IEVycm9yKFwiQnVua2VyIHB1YmtleSBub3Qgc2V0XCIpO1xuICAgICAgdGhpcy5ycGMuc2VuZFJlcXVlc3QoXG4gICAgICAgIHRoaXMuYnVua2VyUHVia2V5LFxuICAgICAgICBgJHtzY2hlbWV9XyR7bWV0aG9kfWAsXG4gICAgICAgIFtwZWVyLnB1YmtleSwgdmFsdWVdLFxuICAgICAgICAyNDEzMyxcbiAgICAgICAgKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgaWYgKCFyZXNwb25zZS5lcnJvcikge1xuICAgICAgICAgICAgcmVzb2x2ZShyZXNwb25zZS5yZXN1bHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWplY3QocmVzcG9uc2UuZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuICBhc3luYyBzaWduKGV2ZW50KSB7XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmICghdGhpcy5idW5rZXJQdWJrZXkpIHRocm93IG5ldyBFcnJvcihcIkJ1bmtlciBwdWJrZXkgbm90IHNldFwiKTtcbiAgICAgIHRoaXMucnBjLnNlbmRSZXF1ZXN0KFxuICAgICAgICB0aGlzLmJ1bmtlclB1YmtleSxcbiAgICAgICAgXCJzaWduX2V2ZW50XCIsXG4gICAgICAgIFtKU09OLnN0cmluZ2lmeShldmVudCldLFxuICAgICAgICAyNDEzMyxcbiAgICAgICAgKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgaWYgKCFyZXNwb25zZS5lcnJvcikge1xuICAgICAgICAgICAgY29uc3QganNvbiA9IEpTT04ucGFyc2UocmVzcG9uc2UucmVzdWx0KTtcbiAgICAgICAgICAgIHJlc29sdmUoanNvbi5zaWcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWplY3QocmVzcG9uc2UuZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuICAvKipcbiAgICogQWxsb3dzIGNyZWF0aW5nIGEgbmV3IGFjY291bnQgb24gdGhlIHJlbW90ZSBzZXJ2ZXIuXG4gICAqIEBwYXJhbSB1c2VybmFtZSBEZXNpcmVkIHVzZXJuYW1lIGZvciB0aGUgTklQLTA1XG4gICAqIEBwYXJhbSBkb21haW4gRGVzaXJlZCBkb21haW4gZm9yIHRoZSBOSVAtMDVcbiAgICogQHBhcmFtIGVtYWlsIEVtYWlsIGFkZHJlc3MgdG8gYXNzb2NpYXRlIHdpdGggdGhpcyBhY2NvdW50IC0tIFJlbW90ZSBzZXJ2ZXJzIG1heSB1c2UgdGhpcyBmb3IgcmVjb3ZlcnlcbiAgICogQHJldHVybnMgVGhlIHB1YmxpYyBrZXkgb2YgdGhlIG5ld2x5IGNyZWF0ZWQgYWNjb3VudFxuICAgKi9cbiAgYXN5bmMgY3JlYXRlQWNjb3VudCh1c2VybmFtZSwgZG9tYWluLCBlbWFpbCkge1xuICAgIGF3YWl0IHRoaXMuc3RhcnRMaXN0ZW5pbmcoKTtcbiAgICBjb25zdCByZXEgPSBbXTtcbiAgICBpZiAodXNlcm5hbWUpIHJlcS5wdXNoKHVzZXJuYW1lKTtcbiAgICBpZiAoZG9tYWluKSByZXEucHVzaChkb21haW4pO1xuICAgIGlmIChlbWFpbCkgcmVxLnB1c2goZW1haWwpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAoIXRoaXMuYnVua2VyUHVia2V5KSB0aHJvdyBuZXcgRXJyb3IoXCJCdW5rZXIgcHVia2V5IG5vdCBzZXRcIik7XG4gICAgICB0aGlzLnJwYy5zZW5kUmVxdWVzdChcbiAgICAgICAgdGhpcy5idW5rZXJQdWJrZXksXG4gICAgICAgIFwiY3JlYXRlX2FjY291bnRcIixcbiAgICAgICAgcmVxLFxuICAgICAgICAyNDEzMyAvKiBOb3N0ckNvbm5lY3QgKi8sXG4gICAgICAgIChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgIGlmICghcmVzcG9uc2UuZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IHB1YmtleSA9IHJlc3BvbnNlLnJlc3VsdDtcbiAgICAgICAgICAgIHJlc29sdmUocHVia2V5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KHJlc3BvbnNlLmVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIHNyYy9kdm0vc2NoZWR1bGUudHNcbmZ1bmN0aW9uIGFkZFJlbGF5cyhldmVudCwgcmVsYXlzKSB7XG4gIGNvbnN0IHRhZ3MgPSBbXTtcbiAgaWYgKCFyZWxheXMgfHwgcmVsYXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGNvbnN0IHBvb2xSZWxheXMgPSBldmVudC5uZGs/LnBvb2wucmVsYXlzO1xuICAgIHJlbGF5cyA9IHBvb2xSZWxheXMgPyBPYmplY3Qua2V5cyhwb29sUmVsYXlzKSA6IHZvaWQgMDtcbiAgfVxuICBpZiAocmVsYXlzICYmIHJlbGF5cy5sZW5ndGggPiAwKSB0YWdzLnB1c2goW1wicmVsYXlzXCIsIC4uLnJlbGF5c10pO1xuICByZXR1cm4gdGFncztcbn1cbmFzeW5jIGZ1bmN0aW9uIGR2bVNjaGVkdWxlKGV2ZW50cywgZHZtLCByZWxheXMsIGVuY3J5cHRlZCA9IHRydWUsIHdhaXRGb3JDb25maXJtYXRpb25Gb3JNcykge1xuICBpZiAoIShldmVudHMgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICBldmVudHMgPSBbZXZlbnRzXTtcbiAgfVxuICBjb25zdCBuZGsgPSBldmVudHNbMF0ubmRrO1xuICBpZiAoIW5kaykgdGhyb3cgbmV3IEVycm9yKFwiTkRLIG5vdCBzZXRcIik7XG4gIGZvciAoY29uc3QgZXZlbnQgb2YgZXZlbnRzKSB7XG4gICAgaWYgKCFldmVudC5zaWcpIHRocm93IG5ldyBFcnJvcihcIkV2ZW50IG5vdCBzaWduZWRcIik7XG4gICAgaWYgKCFldmVudC5jcmVhdGVkX2F0KSB0aHJvdyBuZXcgRXJyb3IoXCJFdmVudCBoYXMgbm8gZGF0ZVwiKTtcbiAgICBpZiAoIWR2bSkgdGhyb3cgbmV3IEVycm9yKFwiTm8gRFZNIHNwZWNpZmllZFwiKTtcbiAgICBpZiAoZXZlbnQuY3JlYXRlZF9hdCA8PSBEYXRlLm5vdygpIC8gMWUzKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnQgbmVlZHMgdG8gYmUgaW4gdGhlIGZ1dHVyZVwiKTtcbiAgfVxuICBjb25zdCBzY2hlZHVsZUV2ZW50ID0gbmV3IE5ES0RWTVJlcXVlc3QobmRrLCB7XG4gICAga2luZDogNTkwNSAvKiBEVk1FdmVudFNjaGVkdWxlICovXG4gIH0pO1xuICBmb3IgKGNvbnN0IGV2ZW50IG9mIGV2ZW50cykge1xuICAgIHNjaGVkdWxlRXZlbnQuYWRkSW5wdXQoSlNPTi5zdHJpbmdpZnkoZXZlbnQucmF3RXZlbnQoKSksIFwidGV4dFwiKTtcbiAgfVxuICBzY2hlZHVsZUV2ZW50LnRhZ3MucHVzaCguLi5hZGRSZWxheXMoZXZlbnRzWzBdLCByZWxheXMpKTtcbiAgaWYgKGVuY3J5cHRlZCkge1xuICAgIGF3YWl0IHNjaGVkdWxlRXZlbnQuZW5jcnlwdGlvbihkdm0pO1xuICB9IGVsc2Uge1xuICAgIHNjaGVkdWxlRXZlbnQuZHZtID0gZHZtO1xuICB9XG4gIGF3YWl0IHNjaGVkdWxlRXZlbnQuc2lnbigpO1xuICBsZXQgcmVzO1xuICBpZiAod2FpdEZvckNvbmZpcm1hdGlvbkZvck1zKSB7XG4gICAgcmVzID0gbmRrLnN1YnNjcmliZShcbiAgICAgIHtcbiAgICAgICAga2luZHM6IFs1OTA1IC8qIERWTUV2ZW50U2NoZWR1bGUgKi8gKyAxZTMsIDdlMyAvKiBEVk1Kb2JGZWVkYmFjayAqL10sXG4gICAgICAgIC4uLnNjaGVkdWxlRXZlbnQuZmlsdGVyKClcbiAgICAgIH0sXG4gICAgICB7IGdyb3VwYWJsZTogZmFsc2UsIGNsb3NlT25Fb3NlOiBmYWxzZSB9XG4gICAgKTtcbiAgfVxuICBjb25zdCB0aW1lb3V0UHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZWplY3QpID0+IHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHJlcz8uc3RvcCgpO1xuICAgICAgcmVqZWN0KFwiVGltZW91dCB3YWl0aW5nIGZvciBhbiBhbnN3ZXIgZnJvbSB0aGUgRFZNXCIpO1xuICAgIH0sIHdhaXRGb3JDb25maXJtYXRpb25Gb3JNcyk7XG4gIH0pO1xuICBjb25zdCBzY2hlZHVsZVByb21pc2UgPSBuZXcgUHJvbWlzZShcbiAgICAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAod2FpdEZvckNvbmZpcm1hdGlvbkZvck1zKSB7XG4gICAgICAgIHJlcz8ub24oXCJldmVudFwiLCBhc3luYyAoZSkgPT4ge1xuICAgICAgICAgIHJlcz8uc3RvcCgpO1xuICAgICAgICAgIGlmIChlLmtpbmQgPT09IDdlMyAvKiBEVk1Kb2JGZWVkYmFjayAqLykge1xuICAgICAgICAgICAgY29uc3QgZmVlZGJhY2sgPSBhd2FpdCBOREtEVk1Kb2JGZWVkYmFjay5mcm9tKGUpO1xuICAgICAgICAgICAgaWYgKGZlZWRiYWNrLnN0YXR1cyA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHN0YXR1c1RhZyA9IGZlZWRiYWNrLmdldE1hdGNoaW5nVGFncyhcInN0YXR1c1wiKTtcbiAgICAgICAgICAgICAgcmVqZWN0KHN0YXR1c1RhZz8uWzJdID8/IGZlZWRiYWNrKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc29sdmUoZmVlZGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXNvbHZlKGUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHNjaGVkdWxlRXZlbnQucHVibGlzaCgpLnRoZW4oKCkgPT4ge1xuICAgICAgICBpZiAoIXdhaXRGb3JDb25maXJtYXRpb25Gb3JNcykgcmVzb2x2ZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICApO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGlmICh3YWl0Rm9yQ29uZmlybWF0aW9uRm9yTXMpIHtcbiAgICAgIFByb21pc2UucmFjZShbdGltZW91dFByb21pc2UsIHNjaGVkdWxlUHJvbWlzZV0pLnRoZW4oKGUpID0+IHtcbiAgICAgICAgcmVzb2x2ZShlKTtcbiAgICAgIH0pLmNhdGNoKHJlamVjdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjaGVkdWxlUHJvbWlzZS50aGVuKHJlc29sdmUpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIHNyYy9uZGsvaW5kZXgudHNcbmltcG9ydCBkZWJ1ZzcgZnJvbSBcImRlYnVnXCI7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgYXMgRXZlbnRFbWl0dGVyOCB9IGZyb20gXCJ0c2VlcFwiO1xuXG4vLyBzcmMvZXZlbnRzL2RlZHVwLnRzXG5mdW5jdGlvbiBkZWR1cChldmVudDEsIGV2ZW50Mikge1xuICBpZiAoZXZlbnQxLmNyZWF0ZWRfYXQgPiBldmVudDIuY3JlYXRlZF9hdCkge1xuICAgIHJldHVybiBldmVudDE7XG4gIH1cbiAgcmV0dXJuIGV2ZW50Mjtcbn1cblxuLy8gc3JjL291dGJveC90cmFja2VyLnRzXG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgYXMgRXZlbnRFbWl0dGVyNyB9IGZyb20gXCJ0c2VlcFwiO1xuaW1wb3J0IHsgTFJVQ2FjaGUgYXMgTFJVQ2FjaGUyIH0gZnJvbSBcInR5cGVzY3JpcHQtbHJ1LWNhY2hlXCI7XG5cbi8vIHNyYy91dGlscy9nZXQtdXNlcnMtcmVsYXktbGlzdC50c1xuYXN5bmMgZnVuY3Rpb24gZ2V0UmVsYXlMaXN0Rm9yVXNlcihwdWJrZXksIG5kaykge1xuICBjb25zdCBsaXN0ID0gYXdhaXQgZ2V0UmVsYXlMaXN0Rm9yVXNlcnMoW3B1YmtleV0sIG5kayk7XG4gIHJldHVybiBsaXN0LmdldChwdWJrZXkpO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0UmVsYXlMaXN0Rm9yVXNlcnMocHVia2V5cywgbmRrLCBza2lwQ2FjaGUgPSBmYWxzZSwgdGltZW91dCA9IDFlMykge1xuICBjb25zdCBwb29sID0gbmRrLm91dGJveFBvb2wgfHwgbmRrLnBvb2w7XG4gIGNvbnN0IHNldCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGZvciAoY29uc3QgcmVsYXkgb2YgcG9vbC5yZWxheXMudmFsdWVzKCkpIHNldC5hZGQocmVsYXkpO1xuICBjb25zdCByZWxheUxpc3RzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgZnJvbUNvbnRhY3RMaXN0ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgcmVsYXlTZXQgPSBuZXcgTkRLUmVsYXlTZXQoc2V0LCBuZGspO1xuICBpZiAobmRrLmNhY2hlQWRhcHRlcj8ubG9ja2luZyAmJiAhc2tpcENhY2hlKSB7XG4gICAgY29uc3QgY2FjaGVkTGlzdCA9IGF3YWl0IG5kay5mZXRjaEV2ZW50cyhcbiAgICAgIHsga2luZHM6IFszLCAxMDAwMl0sIGF1dGhvcnM6IEFycmF5LmZyb20obmV3IFNldChwdWJrZXlzKSkgfSxcbiAgICAgIHsgY2FjaGVVc2FnZTogXCJPTkxZX0NBQ0hFXCIgLyogT05MWV9DQUNIRSAqLywgc3ViSWQ6IFwibmRrLXJlbGF5LWxpc3QtZmV0Y2hcIiB9XG4gICAgKTtcbiAgICBmb3IgKGNvbnN0IHJlbGF5TGlzdCBvZiBjYWNoZWRMaXN0KSB7XG4gICAgICBpZiAocmVsYXlMaXN0LmtpbmQgPT09IDEwMDAyKVxuICAgICAgICByZWxheUxpc3RzLnNldChyZWxheUxpc3QucHVia2V5LCBOREtSZWxheUxpc3QuZnJvbShyZWxheUxpc3QpKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCByZWxheUxpc3Qgb2YgY2FjaGVkTGlzdCkge1xuICAgICAgaWYgKHJlbGF5TGlzdC5raW5kID09PSAzKSB7XG4gICAgICAgIGlmIChyZWxheUxpc3RzLmhhcyhyZWxheUxpc3QucHVia2V5KSkgY29udGludWU7XG4gICAgICAgIGNvbnN0IGxpc3QgPSByZWxheUxpc3RGcm9tS2luZDMobmRrLCByZWxheUxpc3QpO1xuICAgICAgICBpZiAobGlzdCkgZnJvbUNvbnRhY3RMaXN0LnNldChyZWxheUxpc3QucHVia2V5LCBsaXN0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcHVia2V5cyA9IHB1YmtleXMuZmlsdGVyKFxuICAgICAgKHB1YmtleSkgPT4gIXJlbGF5TGlzdHMuaGFzKHB1YmtleSkgJiYgIWZyb21Db250YWN0TGlzdC5oYXMocHVia2V5KVxuICAgICk7XG4gIH1cbiAgaWYgKHB1YmtleXMubGVuZ3RoID09PSAwKSByZXR1cm4gcmVsYXlMaXN0cztcbiAgY29uc3QgcmVsYXlMaXN0RXZlbnRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgY29udGFjdExpc3RFdmVudHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUpID0+IHtcbiAgICBjb25zdCBzdWIgPSBuZGsuc3Vic2NyaWJlKFxuICAgICAgeyBraW5kczogWzMsIDEwMDAyXSwgYXV0aG9yczogcHVia2V5cyB9LFxuICAgICAge1xuICAgICAgICBjbG9zZU9uRW9zZTogdHJ1ZSxcbiAgICAgICAgcG9vbCxcbiAgICAgICAgZ3JvdXBhYmxlOiB0cnVlLFxuICAgICAgICBjYWNoZVVzYWdlOiBcIk9OTFlfUkVMQVlcIiAvKiBPTkxZX1JFTEFZICovLFxuICAgICAgICBzdWJJZDogXCJuZGstcmVsYXktbGlzdC1mZXRjaFwiXG4gICAgICB9LFxuICAgICAgcmVsYXlTZXQsXG4gICAgICBmYWxzZVxuICAgICk7XG4gICAgc3ViLm9uKFwiZXZlbnRcIiwgKGV2ZW50KSA9PiB7XG4gICAgICBpZiAoZXZlbnQua2luZCA9PT0gMTAwMDIgLyogUmVsYXlMaXN0ICovKSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nRXZlbnQgPSByZWxheUxpc3RFdmVudHMuZ2V0KGV2ZW50LnB1YmtleSk7XG4gICAgICAgIGlmIChleGlzdGluZ0V2ZW50ICYmIGV4aXN0aW5nRXZlbnQuY3JlYXRlZF9hdCA+IGV2ZW50LmNyZWF0ZWRfYXQpIHJldHVybjtcbiAgICAgICAgcmVsYXlMaXN0RXZlbnRzLnNldChldmVudC5wdWJrZXksIGV2ZW50KTtcbiAgICAgIH0gZWxzZSBpZiAoZXZlbnQua2luZCA9PT0gMyAvKiBDb250YWN0cyAqLykge1xuICAgICAgICBjb25zdCBleGlzdGluZ0V2ZW50ID0gY29udGFjdExpc3RFdmVudHMuZ2V0KGV2ZW50LnB1YmtleSk7XG4gICAgICAgIGlmIChleGlzdGluZ0V2ZW50ICYmIGV4aXN0aW5nRXZlbnQuY3JlYXRlZF9hdCA+IGV2ZW50LmNyZWF0ZWRfYXQpIHJldHVybjtcbiAgICAgICAgY29udGFjdExpc3RFdmVudHMuc2V0KGV2ZW50LnB1YmtleSwgZXZlbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHN1Yi5vbihcImVvc2VcIiwgKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBldmVudCBvZiByZWxheUxpc3RFdmVudHMudmFsdWVzKCkpIHtcbiAgICAgICAgcmVsYXlMaXN0cy5zZXQoZXZlbnQucHVia2V5LCBOREtSZWxheUxpc3QuZnJvbShldmVudCkpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBwdWJrZXkgb2YgcHVia2V5cykge1xuICAgICAgICBpZiAocmVsYXlMaXN0cy5oYXMocHVia2V5KSkgY29udGludWU7XG4gICAgICAgIGNvbnN0IGNvbnRhY3RMaXN0ID0gY29udGFjdExpc3RFdmVudHMuZ2V0KHB1YmtleSk7XG4gICAgICAgIGlmICghY29udGFjdExpc3QpIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBsaXN0ID0gcmVsYXlMaXN0RnJvbUtpbmQzKG5kaywgY29udGFjdExpc3QpO1xuICAgICAgICBpZiAobGlzdCkgcmVsYXlMaXN0cy5zZXQocHVia2V5LCBsaXN0KTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUocmVsYXlMaXN0cyk7XG4gICAgfSk7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICByZXNvbHZlKHJlbGF5TGlzdHMpO1xuICAgIH0sIHRpbWVvdXQpO1xuICAgIHN1Yi5zdGFydCgpO1xuICB9KTtcbn1cblxuLy8gc3JjL291dGJveC90cmFja2VyLnRzXG52YXIgT3V0Ym94SXRlbSA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIFR5cGUgb2YgaXRlbVxuICAgKi9cbiAgdHlwZTtcbiAgLyoqXG4gICAqIFRoZSByZWxheSBVUkxzIHRoYXQgYXJlIG9mIGludGVyZXN0IHRvIHRoaXMgaXRlbVxuICAgKi9cbiAgcmVsYXlVcmxTY29yZXM7XG4gIHJlYWRSZWxheXM7XG4gIHdyaXRlUmVsYXlzO1xuICBjb25zdHJ1Y3Rvcih0eXBlKSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnJlbGF5VXJsU2NvcmVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLnJlYWRSZWxheXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMud3JpdGVSZWxheXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICB9XG59O1xudmFyIE91dGJveFRyYWNrZXIgPSBjbGFzcyBleHRlbmRzIEV2ZW50RW1pdHRlcjcge1xuICBkYXRhO1xuICBuZGs7XG4gIGRlYnVnO1xuICBjb25zdHJ1Y3RvcihuZGspIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubmRrID0gbmRrO1xuICAgIHRoaXMuZGVidWcgPSBuZGsuZGVidWcuZXh0ZW5kKFwib3V0Ym94LXRyYWNrZXJcIik7XG4gICAgdGhpcy5kYXRhID0gbmV3IExSVUNhY2hlMih7XG4gICAgICBtYXhTaXplOiAxZTUsXG4gICAgICBlbnRyeUV4cGlyYXRpb25UaW1lSW5NUzogMiAqIDYwICogMWUzXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYSBsaXN0IG9mIHVzZXJzIHRvIHRoZSB0cmFja2VyLlxuICAgKiBAcGFyYW0gaXRlbXNcbiAgICogQHBhcmFtIHNraXBDYWNoZVxuICAgKi9cbiAgYXN5bmMgdHJhY2tVc2VycyhpdGVtcywgc2tpcENhY2hlID0gZmFsc2UpIHtcbiAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpICs9IDQwMCkge1xuICAgICAgY29uc3Qgc2xpY2UgPSBpdGVtcy5zbGljZShpLCBpICsgNDAwKTtcbiAgICAgIGNvbnN0IHB1YmtleXMgPSBzbGljZS5tYXAoKGl0ZW0pID0+IGdldEtleUZyb21JdGVtKGl0ZW0pKS5maWx0ZXIoKHB1YmtleSkgPT4gIXRoaXMuZGF0YS5oYXMocHVia2V5KSk7XG4gICAgICBpZiAocHVia2V5cy5sZW5ndGggPT09IDApIGNvbnRpbnVlO1xuICAgICAgZm9yIChjb25zdCBwdWJrZXkgb2YgcHVia2V5cykge1xuICAgICAgICB0aGlzLmRhdGEuc2V0KHB1YmtleSwgbmV3IE91dGJveEl0ZW0oXCJ1c2VyXCIpKTtcbiAgICAgIH1cbiAgICAgIHByb21pc2VzLnB1c2goXG4gICAgICAgIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgZ2V0UmVsYXlMaXN0Rm9yVXNlcnMocHVia2V5cywgdGhpcy5uZGssIHNraXBDYWNoZSkudGhlbigocmVsYXlMaXN0cykgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbcHVia2V5LCByZWxheUxpc3RdIG9mIHJlbGF5TGlzdHMpIHtcbiAgICAgICAgICAgICAgbGV0IG91dGJveEl0ZW0gPSB0aGlzLmRhdGEuZ2V0KHB1YmtleSk7XG4gICAgICAgICAgICAgIG91dGJveEl0ZW0gPz89IG5ldyBPdXRib3hJdGVtKFwidXNlclwiKTtcbiAgICAgICAgICAgICAgaWYgKHJlbGF5TGlzdCkge1xuICAgICAgICAgICAgICAgIG91dGJveEl0ZW0ucmVhZFJlbGF5cyA9IG5ldyBTZXQoXG4gICAgICAgICAgICAgICAgICBub3JtYWxpemUocmVsYXlMaXN0LnJlYWRSZWxheVVybHMpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBvdXRib3hJdGVtLndyaXRlUmVsYXlzID0gbmV3IFNldChcbiAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZShyZWxheUxpc3Qud3JpdGVSZWxheVVybHMpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJlbGF5VXJsIG9mIG91dGJveEl0ZW0ucmVhZFJlbGF5cykge1xuICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubmRrLnBvb2wuYmxhY2tsaXN0UmVsYXlVcmxzLmhhcyhyZWxheVVybCkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0Ym94SXRlbS5yZWFkUmVsYXlzLmRlbGV0ZShyZWxheVVybCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcmVsYXlVcmwgb2Ygb3V0Ym94SXRlbS53cml0ZVJlbGF5cykge1xuICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubmRrLnBvb2wuYmxhY2tsaXN0UmVsYXlVcmxzLmhhcyhyZWxheVVybCkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0Ym94SXRlbS53cml0ZVJlbGF5cy5kZWxldGUocmVsYXlVcmwpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEuc2V0KHB1YmtleSwgb3V0Ym94SXRlbSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KS5maW5hbGx5KHJlc29sdmUpO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgfVxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIGtleVxuICAgKiBAcGFyYW0gc2NvcmVcbiAgICovXG4gIHRyYWNrKGl0ZW0sIHR5cGUsIHNraXBDYWNoZSA9IHRydWUpIHtcbiAgICBjb25zdCBrZXkgPSBnZXRLZXlGcm9tSXRlbShpdGVtKTtcbiAgICB0eXBlID8/PSBnZXRUeXBlRnJvbUl0ZW0oaXRlbSk7XG4gICAgbGV0IG91dGJveEl0ZW0gPSB0aGlzLmRhdGEuZ2V0KGtleSk7XG4gICAgaWYgKCFvdXRib3hJdGVtKSB7XG4gICAgICBvdXRib3hJdGVtID0gbmV3IE91dGJveEl0ZW0odHlwZSk7XG4gICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIE5ES1VzZXIpIHtcbiAgICAgICAgdGhpcy50cmFja1VzZXJzKFtpdGVtXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXRib3hJdGVtO1xuICB9XG59O1xuZnVuY3Rpb24gZ2V0S2V5RnJvbUl0ZW0oaXRlbSkge1xuICBpZiAoaXRlbSBpbnN0YW5jZW9mIE5ES1VzZXIpIHtcbiAgICByZXR1cm4gaXRlbS5wdWJrZXk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGl0ZW07XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFR5cGVGcm9tSXRlbShpdGVtKSB7XG4gIGlmIChpdGVtIGluc3RhbmNlb2YgTkRLVXNlcikge1xuICAgIHJldHVybiBcInVzZXJcIjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJraW5kXCI7XG4gIH1cbn1cblxuLy8gc3JjL3JlbGF5L3NldHMvdXRpbHMudHNcbmZ1bmN0aW9uIGNvcnJlY3RSZWxheVNldChyZWxheVNldCwgcG9vbCkge1xuICBjb25zdCBjb25uZWN0ZWRSZWxheXMgPSBwb29sLmNvbm5lY3RlZFJlbGF5cygpO1xuICBjb25zdCBpbmNsdWRlc0Nvbm5lY3RlZFJlbGF5ID0gQXJyYXkuZnJvbShyZWxheVNldC5yZWxheXMpLnNvbWUoKHJlbGF5KSA9PiB7XG4gICAgcmV0dXJuIGNvbm5lY3RlZFJlbGF5cy5tYXAoKHIpID0+IHIudXJsKS5pbmNsdWRlcyhyZWxheS51cmwpO1xuICB9KTtcbiAgaWYgKCFpbmNsdWRlc0Nvbm5lY3RlZFJlbGF5KSB7XG4gICAgZm9yIChjb25zdCByZWxheSBvZiBjb25uZWN0ZWRSZWxheXMpIHtcbiAgICAgIHJlbGF5U2V0LmFkZFJlbGF5KHJlbGF5KTtcbiAgICB9XG4gIH1cbiAgaWYgKGNvbm5lY3RlZFJlbGF5cy5sZW5ndGggPT09IDApIHtcbiAgICBmb3IgKGNvbnN0IHJlbGF5IG9mIHBvb2wucmVsYXlzLnZhbHVlcygpKSB7XG4gICAgICByZWxheVNldC5hZGRSZWxheShyZWxheSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZWxheVNldDtcbn1cblxuLy8gc3JjL25kay9mZXRjaC1ldmVudC1mcm9tLXRhZy50c1xuZnVuY3Rpb24gaXNWYWxpZEhpbnQoaGludCkge1xuICBpZiAoIWhpbnQgfHwgaGludCA9PT0gXCJcIikgcmV0dXJuIGZhbHNlO1xuICB0cnkge1xuICAgIG5ldyBVUkwoaGludCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGZldGNoRXZlbnRGcm9tVGFnKHRhZywgb3JpZ2luYWxFdmVudCwgc3ViT3B0cywgZmFsbGJhY2sgPSB7XG4gIHR5cGU6IFwidGltZW91dFwiXG59KSB7XG4gIGNvbnN0IGQ0ID0gdGhpcy5kZWJ1Zy5leHRlbmQoXCJmZXRjaC1ldmVudC1mcm9tLXRhZ1wiKTtcbiAgY29uc3QgW18sIGlkLCBoaW50XSA9IHRhZztcbiAgc3ViT3B0cyA9IHt9O1xuICBkNChcImZldGNoaW5nIGV2ZW50IGZyb20gdGFnXCIsIHRhZywgc3ViT3B0cywgZmFsbGJhY2spO1xuICBjb25zdCBhdXRob3JSZWxheXMgPSBnZXRSZWxheXNGb3JTeW5jKHRoaXMsIG9yaWdpbmFsRXZlbnQucHVia2V5KTtcbiAgaWYgKGF1dGhvclJlbGF5cyAmJiBhdXRob3JSZWxheXMuc2l6ZSA+IDApIHtcbiAgICBkNChcImZldGNoaW5nIGV2ZW50IGZyb20gYXV0aG9yIHJlbGF5cyAlb1wiLCBBcnJheS5mcm9tKGF1dGhvclJlbGF5cykpO1xuICAgIGNvbnN0IHJlbGF5U2V0MiA9IE5ES1JlbGF5U2V0LmZyb21SZWxheVVybHMoQXJyYXkuZnJvbShhdXRob3JSZWxheXMpLCB0aGlzKTtcbiAgICBjb25zdCBldmVudDIgPSBhd2FpdCB0aGlzLmZldGNoRXZlbnQoaWQsIHN1Yk9wdHMsIHJlbGF5U2V0Mik7XG4gICAgaWYgKGV2ZW50MikgcmV0dXJuIGV2ZW50MjtcbiAgfSBlbHNlIHtcbiAgICBkNChcIm5vIGF1dGhvciByZWxheXMgZm91bmQgZm9yICVzXCIsIG9yaWdpbmFsRXZlbnQucHVia2V5LCBvcmlnaW5hbEV2ZW50KTtcbiAgfVxuICBjb25zdCByZWxheVNldCA9IGNhbGN1bGF0ZVJlbGF5U2V0c0Zyb21GaWx0ZXJzKHRoaXMsIFt7IGlkczogW2lkXSB9XSwgdGhpcy5wb29sKTtcbiAgZDQoXCJmZXRjaGluZyBldmVudCB3aXRob3V0IHJlbGF5IGhpbnRcIiwgcmVsYXlTZXQpO1xuICBjb25zdCBldmVudCA9IGF3YWl0IHRoaXMuZmV0Y2hFdmVudChpZCwgc3ViT3B0cyk7XG4gIGlmIChldmVudCkgcmV0dXJuIGV2ZW50O1xuICBpZiAoaGludCAmJiBoaW50ICE9PSBcIlwiKSB7XG4gICAgY29uc3QgZXZlbnQyID0gYXdhaXQgdGhpcy5mZXRjaEV2ZW50KFxuICAgICAgaWQsXG4gICAgICBzdWJPcHRzLFxuICAgICAgdGhpcy5wb29sLmdldFJlbGF5KGhpbnQsIHRydWUsIHRydWUsIFt7IGlkczogW2lkXSB9XSlcbiAgICApO1xuICAgIGlmIChldmVudDIpIHJldHVybiBldmVudDI7XG4gIH1cbiAgbGV0IHJlc3VsdCA9IHZvaWQgMDtcbiAgY29uc3QgcmVsYXkgPSBpc1ZhbGlkSGludChoaW50KSA/IHRoaXMucG9vbC5nZXRSZWxheShoaW50LCBmYWxzZSwgdHJ1ZSwgW3sgaWRzOiBbaWRdIH1dKSA6IHZvaWQgMDtcbiAgY29uc3QgZmV0Y2hNYXliZVdpdGhSZWxheUhpbnQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIHRoaXMuZmV0Y2hFdmVudChpZCwgc3ViT3B0cywgcmVsYXkpLnRoZW4ocmVzb2x2ZSk7XG4gIH0pO1xuICBpZiAoIWlzVmFsaWRIaW50KGhpbnQpIHx8IGZhbGxiYWNrLnR5cGUgPT09IFwibm9uZVwiKSB7XG4gICAgcmV0dXJuIGZldGNoTWF5YmVXaXRoUmVsYXlIaW50O1xuICB9XG4gIGNvbnN0IGZhbGxiYWNrRmV0Y2hQcm9taXNlID0gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUpID0+IHtcbiAgICBjb25zdCBmYWxsYmFja1JlbGF5U2V0ID0gZmFsbGJhY2sucmVsYXlTZXQ7XG4gICAgY29uc3QgdGltZW91dCA9IGZhbGxiYWNrLnRpbWVvdXQgPz8gMTUwMDtcbiAgICBjb25zdCB0aW1lb3V0UHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlMikgPT4gc2V0VGltZW91dChyZXNvbHZlMiwgdGltZW91dCkpO1xuICAgIGlmIChmYWxsYmFjay50eXBlID09PSBcInRpbWVvdXRcIikgYXdhaXQgdGltZW91dFByb21pc2U7XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkNChcImZhbGxiYWNrIGZldGNoIHRyaWdnZXJlZFwiKTtcbiAgICAgIGNvbnN0IGZhbGxiYWNrRXZlbnQgPSBhd2FpdCB0aGlzLmZldGNoRXZlbnQoaWQsIHN1Yk9wdHMsIGZhbGxiYWNrUmVsYXlTZXQpO1xuICAgICAgcmVzb2x2ZShmYWxsYmFja0V2ZW50KTtcbiAgICB9XG4gIH0pO1xuICBzd2l0Y2ggKGZhbGxiYWNrLnR5cGUpIHtcbiAgICBjYXNlIFwidGltZW91dFwiOlxuICAgICAgcmV0dXJuIFByb21pc2UucmFjZShbZmV0Y2hNYXliZVdpdGhSZWxheUhpbnQsIGZhbGxiYWNrRmV0Y2hQcm9taXNlXSk7XG4gICAgY2FzZSBcImVvc2VcIjpcbiAgICAgIHJlc3VsdCA9IGF3YWl0IGZldGNoTWF5YmVXaXRoUmVsYXlIaW50O1xuICAgICAgaWYgKHJlc3VsdCkgcmV0dXJuIHJlc3VsdDtcbiAgICAgIHJldHVybiBmYWxsYmFja0ZldGNoUHJvbWlzZTtcbiAgfVxufVxuXG4vLyBzcmMvbWVkaWEvaW5kZXgudHNcbnZhciBTUEVDX1BBVEggPSBcIi8ud2VsbC1rbm93bi9ub3N0ci9uaXA5Ni5qc29uXCI7XG52YXIgTmlwOTYgPSBjbGFzcyB7XG4gIG5kaztcbiAgc3BlYztcbiAgdXJsO1xuICBuaXA5OFJlcXVpcmVkID0gZmFsc2U7XG4gIC8qKlxuICAgKiBAcGFyYW0gZG9tYWluIGRvbWFpbiBvZiB0aGUgTklQOTYgc2VydmljZVxuICAgKi9cbiAgY29uc3RydWN0b3IoZG9tYWluLCBuZGspIHtcbiAgICB0aGlzLnVybCA9IGBodHRwczovLyR7ZG9tYWlufSR7U1BFQ19QQVRIfWA7XG4gICAgdGhpcy5uZGsgPSBuZGs7XG4gIH1cbiAgYXN5bmMgcHJlcGFyZVVwbG9hZChibG9iLCBodHRwVmVyYiA9IFwiUE9TVFwiKSB7XG4gICAgdGhpcy52YWxpZGF0ZUh0dHBGZXRjaCgpO1xuICAgIGlmICghdGhpcy5zcGVjKSBhd2FpdCB0aGlzLmZldGNoU3BlYygpO1xuICAgIGlmICghdGhpcy5zcGVjKSB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZmV0Y2ggTklQOTYgc3BlY1wiKTtcbiAgICBsZXQgaGVhZGVycyA9IHt9O1xuICAgIGlmICh0aGlzLm5pcDk4UmVxdWlyZWQpIHtcbiAgICAgIGNvbnN0IGF1dGhvcml6YXRpb25IZWFkZXIgPSBhd2FpdCB0aGlzLmdlbmVyYXRlTmlwOThIZWFkZXIoXG4gICAgICAgIHRoaXMuc3BlYy5hcGlfdXJsLFxuICAgICAgICBodHRwVmVyYixcbiAgICAgICAgYmxvYlxuICAgICAgKTtcbiAgICAgIGhlYWRlcnMgPSB7IEF1dGhvcml6YXRpb246IGF1dGhvcml6YXRpb25IZWFkZXIgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHVybDogdGhpcy5zcGVjLmFwaV91cmwsXG4gICAgICBoZWFkZXJzXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUHJvdmlkZXMgYW4gWE1MSHR0cFJlcXVlc3QtYmFzZWQgdXBsb2FkIG1ldGhvZCBmb3IgYnJvd3NlcnMuXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgKiB4aHIudXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoXCJwcm9ncmVzc1wiLCBmdW5jdGlvbihlKSB7XG4gICAqICAgIGNvbnN0IHBlcmNlbnRDb21wbGV0ZSA9IGUubG9hZGVkIC8gZS50b3RhbDtcbiAgICogICAgY29uc29sZS5sb2cocGVyY2VudENvbXBsZXRlKTtcbiAgICogfSk7XG4gICAqIGNvbnN0IG5pcDk2ID0gbmRrLmdldE5pcDk2KFwibm9zdHJjaGVjay5tZVwiKTtcbiAgICogY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtcIkhlbGxvLCB3b3JsZCFcIl0sIHsgdHlwZTogXCJ0ZXh0L3BsYWluXCIgfSk7XG4gICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgbmlwOTYueGhyVXBsb2FkKHhociwgYmxvYik7XG4gICAqIGNvbnNvbGUubG9nKHJlc3BvbnNlKTtcbiAgICogQHJldHVybnMgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSB1cGxvYWQgcmVzcG9uc2VcbiAgICovXG4gIGFzeW5jIHhoclVwbG9hZCh4aHIsIGJsb2IpIHtcbiAgICBjb25zdCBodHRwVmVyYiA9IFwiUE9TVFwiO1xuICAgIGNvbnN0IHsgdXJsLCBoZWFkZXJzIH0gPSBhd2FpdCB0aGlzLnByZXBhcmVVcGxvYWQoYmxvYiwgaHR0cFZlcmIpO1xuICAgIHhoci5vcGVuKGh0dHBWZXJiLCB1cmwsIHRydWUpO1xuICAgIGlmIChoZWFkZXJzW1wiQXV0aG9yaXphdGlvblwiXSkge1xuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoXCJBdXRob3JpemF0aW9uXCIsIGhlYWRlcnNbXCJBdXRob3JpemF0aW9uXCJdKTtcbiAgICB9XG4gICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICBmb3JtRGF0YS5hcHBlbmQoXCJmaWxlXCIsIGJsb2IpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDwgMzAwKSB7XG4gICAgICAgICAgcmVzb2x2ZShKU09OLnBhcnNlKHhoci5yZXNwb25zZVRleHQpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKHhoci5zdGF0dXNUZXh0KSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QobmV3IEVycm9yKFwiTmV0d29yayBFcnJvclwiKSk7XG4gICAgICB9O1xuICAgICAgeGhyLnNlbmQoZm9ybURhdGEpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBGZXRjaC1iYXNlZCB1cGxvYWQgbWV0aG9kLiBOb3RlIHRoYXQgdGhpcyB3aWxsIHVzZSBOREsncyBodHRwRmV0Y2hcbiAgICogQHBhcmFtIGJsb2JcbiAgICogQHJldHVybnMgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSB1cGxvYWQgcmVzcG9uc2VcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3QgbmlwOTYgPSBuZGsuZ2V0TmlwOTYoXCJub3N0cmNoZWNrLm1lXCIpO1xuICAgKiBjb25zdCBibG9iID0gbmV3IEJsb2IoW1wiSGVsbG8sIHdvcmxkIVwiXSwgeyB0eXBlOiBcInRleHQvcGxhaW5cIiB9KTtcbiAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBuaXA5Ni51cGxvYWQoYmxvYik7XG4gICAqIGNvbnNvbGUubG9nKHJlc3BvbnNlKTtcbiAgICovXG4gIGFzeW5jIHVwbG9hZChibG9iKSB7XG4gICAgY29uc3QgaHR0cFZlcmIgPSBcIlBPU1RcIjtcbiAgICBjb25zdCB7IHVybCwgaGVhZGVycyB9ID0gYXdhaXQgdGhpcy5wcmVwYXJlVXBsb2FkKGJsb2IsIGh0dHBWZXJiKTtcbiAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgIGZvcm1EYXRhLmFwcGVuZChcImZpbGVcIiwgYmxvYik7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5uZGsuaHR0cEZldGNoKHRoaXMuc3BlYy5hcGlfdXJsLCB7XG4gICAgICBtZXRob2Q6IGh0dHBWZXJiLFxuICAgICAgaGVhZGVycyxcbiAgICAgIGJvZHk6IGZvcm1EYXRhXG4gICAgfSk7XG4gICAgaWYgKHJlcy5zdGF0dXMgIT09IDIwMCkgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gdXBsb2FkIGZpbGUgdG8gJHt1cmx9YCk7XG4gICAgY29uc3QganNvbiA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgaWYgKGpzb24uc3RhdHVzICE9PSBcInN1Y2Nlc3NcIikgdGhyb3cgbmV3IEVycm9yKGpzb24ubWVzc2FnZSk7XG4gICAgcmV0dXJuIGpzb247XG4gIH1cbiAgdmFsaWRhdGVIdHRwRmV0Y2goKSB7XG4gICAgaWYgKCF0aGlzLm5kaykgdGhyb3cgbmV3IEVycm9yKFwiTkRLIGlzIHJlcXVpcmVkIHRvIGZldGNoIE5JUDk2IHNwZWNcIik7XG4gICAgaWYgKCF0aGlzLm5kay5odHRwRmV0Y2gpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOREsgbXVzdCBoYXZlIGFuIGh0dHBGZXRjaCBtZXRob2QgdG8gZmV0Y2ggTklQOTYgc3BlY1wiKTtcbiAgfVxuICBhc3luYyBmZXRjaFNwZWMoKSB7XG4gICAgdGhpcy52YWxpZGF0ZUh0dHBGZXRjaCgpO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMubmRrLmh0dHBGZXRjaCh0aGlzLnVybCk7XG4gICAgaWYgKHJlcy5zdGF0dXMgIT09IDIwMCkgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggTklQOTYgc3BlYyBmcm9tICR7dGhpcy51cmx9YCk7XG4gICAgY29uc3Qgc3BlYyA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgaWYgKCFzcGVjKSB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwYXJzZSBOSVA5NiBzcGVjIGZyb20gJHt0aGlzLnVybH1gKTtcbiAgICB0aGlzLnNwZWMgPSBzcGVjO1xuICAgIHRoaXMubmlwOThSZXF1aXJlZCA9IHRoaXMuc3BlYy5wbGFucy5mcmVlLmlzX25pcDk4X3JlcXVpcmVkO1xuICB9XG4gIGFzeW5jIGdlbmVyYXRlTmlwOThIZWFkZXIocmVxdWVzdFVybCwgaHR0cE1ldGhvZCwgYmxvYikge1xuICAgIGNvbnN0IGV2ZW50ID0gbmV3IE5ES0V2ZW50KHRoaXMubmRrLCB7XG4gICAgICBraW5kOiAyNzIzNSAvKiBIdHRwQXV0aCAqLyxcbiAgICAgIHRhZ3M6IFtcbiAgICAgICAgW1widVwiLCByZXF1ZXN0VXJsXSxcbiAgICAgICAgW1wibWV0aG9kXCIsIGh0dHBNZXRob2RdXG4gICAgICBdXG4gICAgfSk7XG4gICAgaWYgKFtcIlBPU1RcIiwgXCJQVVRcIiwgXCJQQVRDSFwiXS5pbmNsdWRlcyhodHRwTWV0aG9kKSkge1xuICAgICAgY29uc3Qgc2hhMjU2SGFzaCA9IGF3YWl0IHRoaXMuY2FsY3VsYXRlU2hhMjU2KGJsb2IpO1xuICAgICAgZXZlbnQudGFncy5wdXNoKFtcInBheWxvYWRcIiwgc2hhMjU2SGFzaF0pO1xuICAgIH1cbiAgICBhd2FpdCBldmVudC5zaWduKCk7XG4gICAgY29uc3QgZW5jb2RlZEV2ZW50ID0gYnRvYShKU09OLnN0cmluZ2lmeShldmVudC5yYXdFdmVudCgpKSk7XG4gICAgcmV0dXJuIGBOb3N0ciAke2VuY29kZWRFdmVudH1gO1xuICB9XG4gIGFzeW5jIGNhbGN1bGF0ZVNoYTI1NihibG9iKSB7XG4gICAgY29uc3QgYnVmZmVyID0gYXdhaXQgYmxvYi5hcnJheUJ1ZmZlcigpO1xuICAgIGNvbnN0IGhhc2hCdWZmZXIgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmRpZ2VzdChcIlNIQS0yNTZcIiwgYnVmZmVyKTtcbiAgICBjb25zdCBoYXNoQXJyYXkgPSBBcnJheS5mcm9tKG5ldyBVaW50OEFycmF5KGhhc2hCdWZmZXIpKTtcbiAgICBjb25zdCBoYXNoSGV4ID0gaGFzaEFycmF5Lm1hcCgoYikgPT4gYi50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpKS5qb2luKFwiXCIpO1xuICAgIHJldHVybiBoYXNoSGV4O1xuICB9XG59O1xuXG4vLyBzcmMvbmRrL3F1ZXVlL2luZGV4LnRzXG52YXIgUXVldWUgPSBjbGFzcyB7XG4gIHF1ZXVlID0gW107XG4gIG1heENvbmN1cnJlbmN5O1xuICBwcm9jZXNzaW5nID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgcHJvbWlzZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdHJ1Y3RvcihuYW1lLCBtYXhDb25jdXJyZW5jeSkge1xuICAgIHRoaXMubWF4Q29uY3VycmVuY3kgPSBtYXhDb25jdXJyZW5jeTtcbiAgfVxuICBhZGQoaXRlbSkge1xuICAgIGlmICh0aGlzLnByb21pc2VzLmhhcyhpdGVtLmlkKSkge1xuICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZXMuZ2V0KGl0ZW0uaWQpO1xuICAgIH0gZWxzZSB7XG4gICAgfVxuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLnF1ZXVlLnB1c2goe1xuICAgICAgICAuLi5pdGVtLFxuICAgICAgICBmdW5jOiAoKSA9PiBpdGVtLmZ1bmMoKS50aGVuKFxuICAgICAgICAgIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfSxcbiAgICAgICAgICAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgIH0pO1xuICAgICAgdGhpcy5wcm9jZXNzKCk7XG4gICAgfSk7XG4gICAgdGhpcy5wcm9taXNlcy5zZXQoaXRlbS5pZCwgcHJvbWlzZSk7XG4gICAgcHJvbWlzZS5maW5hbGx5KCgpID0+IHtcbiAgICAgIHRoaXMucHJvbWlzZXMuZGVsZXRlKGl0ZW0uaWQpO1xuICAgICAgdGhpcy5wcm9jZXNzaW5nLmRlbGV0ZShpdGVtLmlkKTtcbiAgICAgIHRoaXMucHJvY2VzcygpO1xuICAgIH0pO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG4gIHByb2Nlc3MoKSB7XG4gICAgaWYgKHRoaXMucHJvY2Vzc2luZy5zaXplID49IHRoaXMubWF4Q29uY3VycmVuY3kgfHwgdGhpcy5xdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaXRlbSA9IHRoaXMucXVldWUuc2hpZnQoKTtcbiAgICBpZiAoIWl0ZW0gfHwgdGhpcy5wcm9jZXNzaW5nLmhhcyhpdGVtLmlkKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnByb2Nlc3NpbmcuYWRkKGl0ZW0uaWQpO1xuICAgIGl0ZW0uZnVuYygpO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMucXVldWUgPSBbXTtcbiAgfVxuICBjbGVhclByb2Nlc3NpbmcoKSB7XG4gICAgdGhpcy5wcm9jZXNzaW5nLmNsZWFyKCk7XG4gIH1cbiAgY2xlYXJBbGwoKSB7XG4gICAgdGhpcy5jbGVhcigpO1xuICAgIHRoaXMuY2xlYXJQcm9jZXNzaW5nKCk7XG4gIH1cbiAgbGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXVlLmxlbmd0aDtcbiAgfVxufTtcblxuLy8gc3JjL3N1YnNjcmlwdGlvbi9tYW5hZ2VyLnRzXG5pbXBvcnQgeyBtYXRjaEZpbHRlcnMgfSBmcm9tIFwibm9zdHItdG9vbHNcIjtcbnZhciBOREtTdWJzY3JpcHRpb25NYW5hZ2VyID0gY2xhc3Mge1xuICBzdWJzY3JpcHRpb25zO1xuICBzZWVuRXZlbnRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICBhZGQoc3ViKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnNldChzdWIuaW50ZXJuYWxJZCwgc3ViKTtcbiAgICBpZiAoc3ViLm9uU3RvcHBlZCkge1xuICAgICAgY29uc29sZS5sb2coXCJTVUItTUFOQUdFUiBCVUc6IFN1YnNjcmlwdGlvbiBhbHJlYWR5IGhhZCBvblN0b3BwZWQhIFxcdXsxRjkxNH1cIiwgc3ViLmludGVybmFsSWQpO1xuICAgIH1cbiAgICBzdWIub25TdG9wcGVkID0gKCkgPT4ge1xuICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmRlbGV0ZShzdWIuaW50ZXJuYWxJZCk7XG4gICAgfTtcbiAgICBzdWIub24oXCJjbG9zZVwiLCAoKSA9PiB7XG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZGVsZXRlKHN1Yi5pbnRlcm5hbElkKTtcbiAgICB9KTtcbiAgfVxuICBzZWVuRXZlbnQoZXZlbnRJZCwgcmVsYXkpIHtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5zZWVuRXZlbnRzLmdldChldmVudElkKSB8fCBbXTtcbiAgICBjdXJyZW50LnB1c2gocmVsYXkpO1xuICAgIHRoaXMuc2VlbkV2ZW50cy5zZXQoZXZlbnRJZCwgY3VycmVudCk7XG4gIH1cbiAgLyoqXG4gICAqIFdoZW5ldmVyIGFuIGV2ZW50IGNvbWVzIGluLCB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZC5cbiAgICogVGhpcyBmdW5jdGlvbiBtYXRjaGVzIHRoZSByZWNlaXZlZCBldmVudCBhZ2FpbnN0IGFsbCB0aGVcbiAgICoga25vd24gKGkuZS4gYWN0aXZlKSBOREtTdWJzY3JpcHRpb25zLCBhbmQgaWYgaXQgbWF0Y2hlcyxcbiAgICogaXQgc2VuZHMgdGhlIGV2ZW50IHRvIHRoZSBzdWJzY3JpcHRpb24uXG4gICAqIFxuICAgKiBUaGlzIGlzIHRoZSBzaW5nbGUgcGxhY2UgaW4gdGhlIGNvZGViYXNlIHRoYXQgbWF0Y2hlc1xuICAgKiBpbmNvbWluZyBldmVudHMgd2l0aCBwYXJ0aWVzIGludGVyZXN0ZWQgaW4gdGhlIGV2ZW50LlxuICAgKiBcbiAgICogVGhpcyBpcyBhbHNvIHdoYXQgYWxsb3dzIGZvciByZWFjdGl2aXR5IGluIE5ESyBhcHBzLCBzdWNoIHRoYXRcbiAgICogd2hlbmV2ZXIgYW4gYWN0aXZlIHN1YnNjcmlwdGlvbiByZWNlaXZlcyBhbiBldmVudCB0aGF0IHNvbWVcbiAgICogb3RoZXIgYWN0aXZlIHN1YnNjcmlwdGlvbiB3b3VsZCB3YW50IHRvIHJlY2VpdmUsIGJvdGggcmVjZWl2ZSBpdC5cbiAgICogXG4gICAqIFRPRE8gVGhpcyBhbHNvIGFsbG93cyBmb3Igc3Vic2NyaXB0aW9ucyB0aGF0IG92ZXJsYXAgaW4gbWVhbmluZ1xuICAgKiB0byBiZSBjb2xsYXBzZWQgaW50byBvbmUuXG4gICAqIFxuICAgKiBJLmUuIGlmIGEgc3Vic2NyaXB0aW9uIHdpdGggZmlsdGVyOiBraW5kczogWzFdLCBhdXRob3JzOiBbYWxpY2VdXG4gICAqIGlzIGNyZWF0ZWQgYW5kIEVPU0VzLCBhbmQgdGhlbiBhIHN1YnNlcXVlbnQgc3Vic2NyaXB0aW9uIHdpdGhcbiAgICoga2luZHM6IFsxXSwgYXV0aG9yczogW2FsaWNlXSBpcyBjcmVhdGVkLCBvbmNlIHRoZSBzZWNvbmQgc3Vic2NyaXB0aW9uXG4gICAqIEVPU0VzIHdlIGNhbiBzYWZlbHkgY2xvc2UgaXQsIGluY3JlbWVudCBpdHMgcmVmQ291bnQgYW5kIGNsb3NlIGl0LFxuICAgKiBhbmQgd2hlbiB0aGUgZmlyc3Qgc3Vic2NyaXB0aW9uIHJlY2VpdmVzIGEgbmV3IGV2ZW50IGZyb20gQWxpY2UgdGhpc1xuICAgKiBjb2RlIHdpbGwgbWFrZSB0aGUgc2Vjb25kIHN1YnNjcmlwdGlvbiByZWNlaXZlIHRoZSBldmVudCBldmVuIHRob3VnaFxuICAgKiBpdCBoYXMgbm8gYWN0aXZlIHN1YnNjcmlwdGlvbiBvbiBhIHJlbGF5LlxuICAgKiBAcGFyYW0gZXZlbnQgUmF3IGV2ZW50IHJlY2VpdmVkIGZyb20gYSByZWxheVxuICAgKiBAcGFyYW0gcmVsYXkgUmVsYXkgdGhhdCBzZW50IHRoZSBldmVudFxuICAgKiBAcGFyYW0gb3B0aW1pc3RpY1B1Ymxpc2ggV2hldGhlciB0aGUgZXZlbnQgaXMgY29taW5nIGZyb20gYW4gb3B0aW1pc3RpYyBwdWJsaXNoXG4gICAqL1xuICBkaXNwYXRjaEV2ZW50KGV2ZW50LCByZWxheSwgb3B0aW1pc3RpY1B1Ymxpc2ggPSBmYWxzZSkge1xuICAgIGlmIChyZWxheSkgdGhpcy5zZWVuRXZlbnQoZXZlbnQuaWQsIHJlbGF5KTtcbiAgICBjb25zdCBzdWJzY3JpcHRpb25zID0gdGhpcy5zdWJzY3JpcHRpb25zLnZhbHVlcygpO1xuICAgIGNvbnN0IG1hdGNoaW5nU3VicyA9IFtdO1xuICAgIGZvciAoY29uc3Qgc3ViIG9mIHN1YnNjcmlwdGlvbnMpIHtcbiAgICAgIGlmIChtYXRjaEZpbHRlcnMoc3ViLmZpbHRlcnMsIGV2ZW50KSkge1xuICAgICAgICBtYXRjaGluZ1N1YnMucHVzaChzdWIpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IHN1YiBvZiBtYXRjaGluZ1N1YnMpIHtcbiAgICAgIHN1Yi5ldmVudFJlY2VpdmVkKGV2ZW50LCByZWxheSwgZmFsc2UsIG9wdGltaXN0aWNQdWJsaXNoKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9uZGsvYWN0aXZlLXVzZXIudHNcbmltcG9ydCBjcmVhdGVEZWJ1ZzMgZnJvbSBcImRlYnVnXCI7XG52YXIgZGVidWc2ID0gY3JlYXRlRGVidWczKFwibmRrOmFjdGl2ZS11c2VyXCIpO1xuYXN5bmMgZnVuY3Rpb24gZ2V0VXNlclJlbGF5TGlzdCh1c2VyKSB7XG4gIGlmICghdGhpcy5hdXRvQ29ubmVjdFVzZXJSZWxheXMpIHJldHVybjtcbiAgY29uc3QgdXNlclJlbGF5cyA9IGF3YWl0IGdldFJlbGF5TGlzdEZvclVzZXIodXNlci5wdWJrZXksIHRoaXMpO1xuICBpZiAoIXVzZXJSZWxheXMpIHJldHVybjtcbiAgZm9yIChjb25zdCB1cmwgb2YgdXNlclJlbGF5cy5yZWxheXMpIHtcbiAgICBsZXQgcmVsYXkgPSB0aGlzLnBvb2wucmVsYXlzLmdldCh1cmwpO1xuICAgIGlmICghcmVsYXkpIHtcbiAgICAgIHJlbGF5ID0gbmV3IE5ES1JlbGF5KHVybCwgdGhpcy5yZWxheUF1dGhEZWZhdWx0UG9saWN5LCB0aGlzKTtcbiAgICAgIHRoaXMucG9vbC5hZGRSZWxheShyZWxheSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB1c2VyUmVsYXlzO1xufVxuYXN5bmMgZnVuY3Rpb24gc2V0QWN0aXZlVXNlcih1c2VyKSB7XG4gIGNvbnN0IHBvb2wgPSB0aGlzLm91dGJveFBvb2wgfHwgdGhpcy5wb29sO1xuICBpZiAocG9vbC5jb25uZWN0ZWRSZWxheXMubGVuZ3RoID4gMCkge1xuICAgIHNldEFjdGl2ZVVzZXJDb25uZWN0ZWQuY2FsbCh0aGlzLCB1c2VyKTtcbiAgfSBlbHNlIHtcbiAgICBwb29sLm9uY2UoXCJjb25uZWN0XCIsICgpID0+IHtcbiAgICAgIHNldEFjdGl2ZVVzZXJDb25uZWN0ZWQuY2FsbCh0aGlzLCB1c2VyKTtcbiAgICB9KTtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gc2V0QWN0aXZlVXNlckNvbm5lY3RlZCh1c2VyKSB7XG4gIGNvbnN0IHVzZXJSZWxheXMgPSBhd2FpdCBnZXRVc2VyUmVsYXlMaXN0LmNhbGwodGhpcywgdXNlcik7XG4gIGNvbnN0IGZpbHRlcnMgPSBbXG4gICAge1xuICAgICAga2luZHM6IFsxMDAwNiAvKiBCbG9ja1JlbGF5TGlzdCAqL10sXG4gICAgICBhdXRob3JzOiBbdXNlci5wdWJrZXldXG4gICAgfVxuICBdO1xuICBpZiAodGhpcy5hdXRvRmV0Y2hVc2VyTXV0ZWxpc3QpIHtcbiAgICBmaWx0ZXJzWzBdLmtpbmRzLnB1c2goMWU0IC8qIE11dGVMaXN0ICovKTtcbiAgfVxuICBjb25zdCByZWxheVNldCA9IHVzZXJSZWxheXMgPyB1c2VyUmVsYXlzLnJlbGF5U2V0IDogdm9pZCAwO1xuICBjb25zdCBzdWIgPSB0aGlzLnN1YnNjcmliZShcbiAgICBmaWx0ZXJzLFxuICAgIHsgc3ViSWQ6IFwiYWN0aXZlLXVzZXItc2V0dGluZ3NcIiwgY2xvc2VPbkVvc2U6IHRydWUgfSxcbiAgICByZWxheVNldCxcbiAgICBmYWxzZVxuICApO1xuICBjb25zdCBldmVudHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBzdWIub24oXCJldmVudFwiLCAoZXZlbnQpID0+IHtcbiAgICBjb25zdCBwcmV2RXZlbnQgPSBldmVudHMuZ2V0KGV2ZW50LmtpbmQpO1xuICAgIGlmIChwcmV2RXZlbnQgJiYgcHJldkV2ZW50LmNyZWF0ZWRfYXQgPj0gZXZlbnQuY3JlYXRlZF9hdCkgcmV0dXJuO1xuICAgIGV2ZW50cy5zZXQoZXZlbnQua2luZCwgZXZlbnQpO1xuICB9KTtcbiAgc3ViLm9uKFwiZW9zZVwiLCAoKSA9PiB7XG4gICAgZm9yIChjb25zdCBldmVudCBvZiBldmVudHMudmFsdWVzKCkpIHtcbiAgICAgIHByb2Nlc3NFdmVudC5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICB9XG4gIH0pO1xuICBzdWIuc3RhcnQoKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NFdmVudChldmVudCkge1xuICBpZiAoZXZlbnQua2luZCA9PT0gMTAwMDYgLyogQmxvY2tSZWxheUxpc3QgKi8pIHtcbiAgICBwcm9jZXNzQmxvY2tSZWxheUxpc3QuY2FsbCh0aGlzLCBldmVudCk7XG4gIH0gZWxzZSBpZiAoZXZlbnQua2luZCA9PT0gMWU0IC8qIE11dGVMaXN0ICovKSB7XG4gICAgcHJvY2Vzc011dGVMaXN0LmNhbGwodGhpcywgZXZlbnQpO1xuICB9XG59XG5mdW5jdGlvbiBwcm9jZXNzQmxvY2tSZWxheUxpc3QoZXZlbnQpIHtcbiAgY29uc3QgbGlzdCA9IGxpc3RzX2RlZmF1bHQuZnJvbShldmVudCk7XG4gIGZvciAoY29uc3QgaXRlbSBvZiBsaXN0Lml0ZW1zKSB7XG4gICAgdGhpcy5wb29sLmJsYWNrbGlzdFJlbGF5VXJscy5hZGQoaXRlbVswXSk7XG4gIH1cbiAgZGVidWc2KFwiQWRkZWQgJWQgcmVsYXlzIHRvIHJlbGF5IGJsYWNrbGlzdFwiLCBsaXN0Lml0ZW1zLmxlbmd0aCk7XG59XG5mdW5jdGlvbiBwcm9jZXNzTXV0ZUxpc3QobXV0ZUxpc3QpIHtcbiAgY29uc3QgbGlzdCA9IGxpc3RzX2RlZmF1bHQuZnJvbShtdXRlTGlzdCk7XG4gIGZvciAoY29uc3QgaXRlbSBvZiBsaXN0Lml0ZW1zKSB7XG4gICAgdGhpcy5tdXRlZElkcy5zZXQoaXRlbVsxXSwgaXRlbVswXSk7XG4gIH1cbiAgZGVidWc2KFwiQWRkZWQgJWQgdXNlcnMgdG8gbXV0ZSBsaXN0XCIsIGxpc3QuaXRlbXMubGVuZ3RoKTtcbn1cblxuLy8gc3JjL25kay9pbmRleC50c1xudmFyIERFRkFVTFRfT1VUQk9YX1JFTEFZUyA9IFtcIndzczovL3B1cnBsZXBhZy5lcy9cIiwgXCJ3c3M6Ly9ub3MubG9sL1wiXTtcbnZhciBERUZBVUxUX0JMQUNLTElTVEVEX1JFTEFZUyA9IFtcbiAgXCJ3c3M6Ly9icmIuaW8vXCIsXG4gIC8vIEJSQlxuICBcIndzczovL25vc3RyLm11dGlueXdhbGxldC5jb20vXCJcbiAgLy8gRG9uJ3QgdHJ5IHRvIHJlYWQgZnJvbSB0aGlzIHJlbGF5IHNpbmNlIGl0J3MgYSB3cml0ZS1vbmx5IHJlbGF5XG4gIC8vIFwid3NzOi8vcHVycGxlcGFnLmVzL1wiLCAvLyBUaGlzIGlzIGEgaGFjaywgc2luY2UgdGhpcyBpcyBhIG1vc3RseSByZWFkLW9ubHkgcmVsYXksIGJ1dCBub3QgZnVsbHkuIE9uY2Ugd2UgaGF2ZSByZWxheSByb3V0aW5nIHRoaXMgY2FuIGJlIHJlbW92ZWQgc28gaXQgb25seSByZWNlaXZlcyB0aGUgc3VwcG9ydGVkIGtpbmRzXG5dO1xudmFyIE5ESyA9IGNsYXNzIGV4dGVuZHMgRXZlbnRFbWl0dGVyOCB7XG4gIF9leHBsaWNpdFJlbGF5VXJscztcbiAgYmxhY2tsaXN0UmVsYXlVcmxzO1xuICBwb29sO1xuICBvdXRib3hQb29sO1xuICBfc2lnbmVyO1xuICBfYWN0aXZlVXNlcjtcbiAgY2FjaGVBZGFwdGVyO1xuICBkZWJ1ZztcbiAgZGV2V3JpdGVSZWxheVNldDtcbiAgb3V0Ym94VHJhY2tlcjtcbiAgbXV0ZWRJZHM7XG4gIGNsaWVudE5hbWU7XG4gIGNsaWVudE5pcDg5O1xuICBxdWV1ZXNaYXBDb25maWc7XG4gIHF1ZXVlc05pcDA1O1xuICBhc3luY1NpZ1ZlcmlmaWNhdGlvbiA9IGZhbHNlO1xuICBpbml0aWFsVmFsaWRhdGlvblJhdGlvID0gMTtcbiAgbG93ZXN0VmFsaWRhdGlvblJhdGlvID0gMTtcbiAgdmFsaWRhdGlvblJhdGlvRm47XG4gIHN1Yk1hbmFnZXI7XG4gIHB1Ymxpc2hpbmdGYWlsdXJlSGFuZGxlZCA9IGZhbHNlO1xuICBwb29scyA9IFtdO1xuICAvKipcbiAgICogRGVmYXVsdCByZWxheS1hdXRoIHBvbGljeSB0aGF0IHdpbGwgYmUgdXNlZCB3aGVuIGEgcmVsYXkgcmVxdWVzdHMgYXV0aGVudGljYXRpb24sXG4gICAqIGlmIG5vIG90aGVyIHBvbGljeSBpcyBzcGVjaWZpZWQgZm9yIHRoYXQgcmVsYXkuXG4gICAqXG4gICAqIEBleGFtcGxlIERpc2Nvbm5lY3QgZnJvbSByZWxheXMgdGhhdCByZXF1ZXN0IGF1dGhlbnRpY2F0aW9uOlxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIG5kay5yZWxheUF1dGhEZWZhdWx0UG9saWN5ID0gTkRLQXV0aFBvbGljaWVzLmRpc2Nvbm5lY3QobmRrLnBvb2wpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQGV4YW1wbGUgU2lnbiBpbiB0byByZWxheXMgdGhhdCByZXF1ZXN0IGF1dGhlbnRpY2F0aW9uOlxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIG5kay5yZWxheUF1dGhEZWZhdWx0UG9saWN5ID0gTkRLQXV0aFBvbGljaWVzLnNpZ25Jbih7bmRrfSlcbiAgICogYGBgXG4gICAqXG4gICAqIEBleGFtcGxlIFNpZ24gaW4gdG8gcmVsYXlzIHRoYXQgcmVxdWVzdCBhdXRoZW50aWNhdGlvbiwgYXNraW5nIHRoZSB1c2VyIGZvciBjb25maXJtYXRpb246XG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogbmRrLnJlbGF5QXV0aERlZmF1bHRQb2xpY3kgPSAocmVsYXk6IE5ES1JlbGF5KSA9PiB7XG4gICAqICAgICBjb25zdCBzaWduSW4gPSBOREtBdXRoUG9saWNpZXMuc2lnbkluKHtuZGt9KTtcbiAgICogICAgIGlmIChjb25maXJtKGBSZWxheSAke3JlbGF5LnVybH0gaXMgcmVxdWVzdGluZyBhdXRoZW50aWNhdGlvbiwgZG8geW91IHdhbnQgdG8gc2lnbiBpbj9gKSkge1xuICAgKiAgICAgICAgc2lnbkluKHJlbGF5KTtcbiAgICogICAgIH1cbiAgICogfVxuICAgKiBgYGBcbiAgICovXG4gIHJlbGF5QXV0aERlZmF1bHRQb2xpY3k7XG4gIC8qKlxuICAgKiBGZXRjaCBmdW5jdGlvbiB0byB1c2UgZm9yIEhUVFAgcmVxdWVzdHMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogaW1wb3J0IGZldGNoIGZyb20gXCJub2RlLWZldGNoXCI7XG4gICAqXG4gICAqIG5kay5odHRwRmV0Y2ggPSBmZXRjaDtcbiAgICogYGBgXG4gICAqL1xuICBodHRwRmV0Y2g7XG4gIC8qKlxuICAgKiBQcm92aWRlIGEgY2FsbGVyIGZ1bmN0aW9uIHRvIHJlY2VpdmUgYWxsIG5ldHdvcmtpbmcgdHJhZmZpYyBmcm9tIHJlbGF5c1xuICAgKi9cbiAgbmV0RGVidWc7XG4gIGF1dG9Db25uZWN0VXNlclJlbGF5cyA9IHRydWU7XG4gIGF1dG9GZXRjaFVzZXJNdXRlbGlzdCA9IHRydWU7XG4gIHdhbGxldENvbmZpZztcbiAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmRlYnVnID0gb3B0cy5kZWJ1ZyB8fCBkZWJ1ZzcoXCJuZGtcIik7XG4gICAgdGhpcy5uZXREZWJ1ZyA9IG9wdHMubmV0RGVidWc7XG4gICAgdGhpcy5fZXhwbGljaXRSZWxheVVybHMgPSBvcHRzLmV4cGxpY2l0UmVsYXlVcmxzIHx8IFtdO1xuICAgIHRoaXMuYmxhY2tsaXN0UmVsYXlVcmxzID0gb3B0cy5ibGFja2xpc3RSZWxheVVybHMgfHwgREVGQVVMVF9CTEFDS0xJU1RFRF9SRUxBWVM7XG4gICAgdGhpcy5zdWJNYW5hZ2VyID0gbmV3IE5ES1N1YnNjcmlwdGlvbk1hbmFnZXIoKTtcbiAgICB0aGlzLnBvb2wgPSBuZXcgTkRLUG9vbChcbiAgICAgIG9wdHMuZXhwbGljaXRSZWxheVVybHMgfHwgW10sXG4gICAgICBbXSxcbiAgICAgIHRoaXNcbiAgICApO1xuICAgIHRoaXMucG9vbC5uYW1lID0gXCJNYWluXCI7XG4gICAgdGhpcy5wb29sLm9uKFwicmVsYXk6YXV0aFwiLCBhc3luYyAocmVsYXksIGNoYWxsZW5nZSkgPT4ge1xuICAgICAgaWYgKHRoaXMucmVsYXlBdXRoRGVmYXVsdFBvbGljeSkge1xuICAgICAgICBhd2FpdCB0aGlzLnJlbGF5QXV0aERlZmF1bHRQb2xpY3kocmVsYXksIGNoYWxsZW5nZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5hdXRvQ29ubmVjdFVzZXJSZWxheXMgPSBvcHRzLmF1dG9Db25uZWN0VXNlclJlbGF5cyA/PyB0cnVlO1xuICAgIHRoaXMuYXV0b0ZldGNoVXNlck11dGVsaXN0ID0gb3B0cy5hdXRvRmV0Y2hVc2VyTXV0ZWxpc3QgPz8gdHJ1ZTtcbiAgICB0aGlzLmNsaWVudE5hbWUgPSBvcHRzLmNsaWVudE5hbWU7XG4gICAgdGhpcy5jbGllbnROaXA4OSA9IG9wdHMuY2xpZW50TmlwODk7XG4gICAgdGhpcy5yZWxheUF1dGhEZWZhdWx0UG9saWN5ID0gb3B0cy5yZWxheUF1dGhEZWZhdWx0UG9saWN5O1xuICAgIGlmIChvcHRzLmVuYWJsZU91dGJveE1vZGVsKSB7XG4gICAgICB0aGlzLm91dGJveFBvb2wgPSBuZXcgTkRLUG9vbChcbiAgICAgICAgb3B0cy5vdXRib3hSZWxheVVybHMgfHwgREVGQVVMVF9PVVRCT1hfUkVMQVlTLFxuICAgICAgICBbXSxcbiAgICAgICAgdGhpcyxcbiAgICAgICAge1xuICAgICAgICAgIGRlYnVnOiB0aGlzLmRlYnVnLmV4dGVuZChcIm91dGJveC1wb29sXCIpLFxuICAgICAgICAgIG5hbWU6IFwiT3V0Ym94IFBvb2xcIlxuICAgICAgICB9XG4gICAgICApO1xuICAgICAgdGhpcy5vdXRib3hUcmFja2VyID0gbmV3IE91dGJveFRyYWNrZXIodGhpcyk7XG4gICAgfVxuICAgIHRoaXMuc2lnbmVyID0gb3B0cy5zaWduZXI7XG4gICAgdGhpcy5jYWNoZUFkYXB0ZXIgPSBvcHRzLmNhY2hlQWRhcHRlcjtcbiAgICB0aGlzLm11dGVkSWRzID0gb3B0cy5tdXRlZElkcyB8fCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGlmIChvcHRzLmRldldyaXRlUmVsYXlVcmxzKSB7XG4gICAgICB0aGlzLmRldldyaXRlUmVsYXlTZXQgPSBOREtSZWxheVNldC5mcm9tUmVsYXlVcmxzKG9wdHMuZGV2V3JpdGVSZWxheVVybHMsIHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLnF1ZXVlc1phcENvbmZpZyA9IG5ldyBRdWV1ZShcInphcHNcIiwgMyk7XG4gICAgdGhpcy5xdWV1ZXNOaXAwNSA9IG5ldyBRdWV1ZShcIm5pcDA1XCIsIDEwKTtcbiAgICB0aGlzLnNpZ25hdHVyZVZlcmlmaWNhdGlvbldvcmtlciA9IG9wdHMuc2lnbmF0dXJlVmVyaWZpY2F0aW9uV29ya2VyO1xuICAgIHRoaXMuaW5pdGlhbFZhbGlkYXRpb25SYXRpbyA9IG9wdHMuaW5pdGlhbFZhbGlkYXRpb25SYXRpbyB8fCAxO1xuICAgIHRoaXMubG93ZXN0VmFsaWRhdGlvblJhdGlvID0gb3B0cy5sb3dlc3RWYWxpZGF0aW9uUmF0aW8gfHwgMTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5odHRwRmV0Y2ggPSBmZXRjaDtcbiAgICB9IGNhdGNoIHtcbiAgICB9XG4gIH1cbiAgc2V0IGV4cGxpY2l0UmVsYXlVcmxzKHVybHMpIHtcbiAgICB0aGlzLl9leHBsaWNpdFJlbGF5VXJscyA9IHVybHM7XG4gICAgdGhpcy5wb29sLnJlbGF5VXJscyA9IHVybHM7XG4gIH1cbiAgZ2V0IGV4cGxpY2l0UmVsYXlVcmxzKCkge1xuICAgIHJldHVybiB0aGlzLl9leHBsaWNpdFJlbGF5VXJscyB8fCBbXTtcbiAgfVxuICBzZXQgc2lnbmF0dXJlVmVyaWZpY2F0aW9uV29ya2VyKHdvcmtlcjIpIHtcbiAgICB0aGlzLmFzeW5jU2lnVmVyaWZpY2F0aW9uID0gISF3b3JrZXIyO1xuICAgIGlmICh3b3JrZXIyKSB7XG4gICAgICBzaWduYXR1cmVWZXJpZmljYXRpb25Jbml0KHdvcmtlcjIpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQWRkcyBhbiBleHBsaWNpdCByZWxheSB0byB0aGUgcG9vbC5cbiAgICogQHBhcmFtIHVybFxuICAgKiBAcGFyYW0gcmVsYXlBdXRoUG9saWN5IEF1dGhlbnRpY2F0aW9uIHBvbGljeSB0byB1c2UgaWYgZGlmZmVyZW50IGZyb20gdGhlIGRlZmF1bHRcbiAgICogQHBhcmFtIGNvbm5lY3QgV2hldGhlciB0byBjb25uZWN0IHRvIHRoZSByZWxheSBhdXRvbWF0aWNhbGx5XG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBhZGRFeHBsaWNpdFJlbGF5KHVybE9yUmVsYXksIHJlbGF5QXV0aFBvbGljeSwgY29ubmVjdCA9IHRydWUpIHtcbiAgICBsZXQgcmVsYXk7XG4gICAgaWYgKHR5cGVvZiB1cmxPclJlbGF5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZWxheSA9IG5ldyBOREtSZWxheSh1cmxPclJlbGF5LCByZWxheUF1dGhQb2xpY3ksIHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWxheSA9IHVybE9yUmVsYXk7XG4gICAgfVxuICAgIHRoaXMucG9vbC5hZGRSZWxheShyZWxheSwgY29ubmVjdCk7XG4gICAgdGhpcy5leHBsaWNpdFJlbGF5VXJscy5wdXNoKHJlbGF5LnVybCk7XG4gICAgcmV0dXJuIHJlbGF5O1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4geyByZWxheUNvdW50OiB0aGlzLnBvb2wucmVsYXlzLnNpemUgfS50b1N0cmluZygpO1xuICB9XG4gIGdldCBhY3RpdmVVc2VyKCkge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmVVc2VyO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBhY3RpdmUgdXNlciBmb3IgdGhpcyBOREsgaW5zdGFuY2UsIHR5cGljYWxseSB0aGlzIHdpbGwgYmVcbiAgICogY2FsbGVkIHdoZW4gYXNzaWduaW5nIGEgc2lnbmVyIHRvIHRoZSBOREsgaW5zdGFuY2UuXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gd2lsbCBhdXRvbWF0aWNhbGx5IGNvbm5lY3QgdG8gdGhlIHVzZXIncyByZWxheXMgaWZcbiAgICogYGF1dG9Db25uZWN0VXNlclJlbGF5c2AgaXMgc2V0IHRvIHRydWUuXG4gICAqXG4gICAqIEl0IHdpbGwgYWxzbyBmZXRjaCB0aGUgdXNlcidzIG11dGVsaXN0IGlmIGBhdXRvRmV0Y2hVc2VyTXV0ZWxpc3RgIGlzIHNldCB0byB0cnVlLlxuICAgKi9cbiAgc2V0IGFjdGl2ZVVzZXIodXNlcikge1xuICAgIGNvbnN0IGRpZmZlcmVudFVzZXIgPSB0aGlzLl9hY3RpdmVVc2VyPy5wdWJrZXkgIT09IHVzZXI/LnB1YmtleTtcbiAgICB0aGlzLl9hY3RpdmVVc2VyID0gdXNlcjtcbiAgICBpZiAodXNlciAmJiBkaWZmZXJlbnRVc2VyKSB7XG4gICAgICBzZXRBY3RpdmVVc2VyLmNhbGwodGhpcywgdXNlcik7XG4gICAgfSBlbHNlIGlmICghdXNlcikge1xuICAgICAgdGhpcy5tdXRlZElkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgfVxuICB9XG4gIGdldCBzaWduZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NpZ25lcjtcbiAgfVxuICBzZXQgc2lnbmVyKG5ld1NpZ25lcikge1xuICAgIHRoaXMuX3NpZ25lciA9IG5ld1NpZ25lcjtcbiAgICBpZiAobmV3U2lnbmVyKSB0aGlzLmVtaXQoXCJzaWduZXI6cmVhZHlcIiwgbmV3U2lnbmVyKTtcbiAgICBuZXdTaWduZXI/LnVzZXIoKS50aGVuKCh1c2VyKSA9PiB7XG4gICAgICB1c2VyLm5kayA9IHRoaXM7XG4gICAgICB0aGlzLmFjdGl2ZVVzZXIgPSB1c2VyO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDb25uZWN0IHRvIHJlbGF5cyB3aXRoIG9wdGlvbmFsIHRpbWVvdXQuXG4gICAqIElmIHRoZSB0aW1lb3V0IGlzIHJlYWNoZWQsIHRoZSBjb25uZWN0aW9uIHdpbGwgYmUgY29udGludWVkIHRvIGJlIGVzdGFibGlzaGVkIGluIHRoZSBiYWNrZ3JvdW5kLlxuICAgKi9cbiAgYXN5bmMgY29ubmVjdCh0aW1lb3V0TXMpIHtcbiAgICBpZiAodGhpcy5fc2lnbmVyICYmIHRoaXMuYXV0b0Nvbm5lY3RVc2VyUmVsYXlzKSB7XG4gICAgICB0aGlzLmRlYnVnKFxuICAgICAgICBcIkF0dGVtcHRpbmcgdG8gY29ubmVjdCB0byB1c2VyIHJlbGF5cyBzcGVjaWZpZWQgYnkgc2lnbmVyICVvXCIsXG4gICAgICAgIGF3YWl0IHRoaXMuX3NpZ25lci5yZWxheXM/Lih0aGlzKVxuICAgICAgKTtcbiAgICAgIGlmICh0aGlzLl9zaWduZXIucmVsYXlzKSB7XG4gICAgICAgIGNvbnN0IHJlbGF5cyA9IGF3YWl0IHRoaXMuX3NpZ25lci5yZWxheXModGhpcyk7XG4gICAgICAgIHJlbGF5cy5mb3JFYWNoKChyZWxheSkgPT4gdGhpcy5wb29sLmFkZFJlbGF5KHJlbGF5KSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGNvbm5lY3Rpb25zID0gW3RoaXMucG9vbC5jb25uZWN0KHRpbWVvdXRNcyldO1xuICAgIGlmICh0aGlzLm91dGJveFBvb2wpIHtcbiAgICAgIGNvbm5lY3Rpb25zLnB1c2godGhpcy5vdXRib3hQb29sLmNvbm5lY3QodGltZW91dE1zKSk7XG4gICAgfVxuICAgIHRoaXMuZGVidWcoXCJDb25uZWN0aW5nIHRvIHJlbGF5cyAlb1wiLCB7IHRpbWVvdXRNcyB9KTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGxTZXR0bGVkKGNvbm5lY3Rpb25zKS50aGVuKCgpID0+IHtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogR2V0IGEgTkRLVXNlciBvYmplY3RcbiAgICpcbiAgICogQHBhcmFtIG9wdHNcbiAgICogQHJldHVybnNcbiAgICovXG4gIGdldFVzZXIob3B0cykge1xuICAgIGNvbnN0IHVzZXIgPSBuZXcgTkRLVXNlcihvcHRzKTtcbiAgICB1c2VyLm5kayA9IHRoaXM7XG4gICAgcmV0dXJuIHVzZXI7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhIE5ES1VzZXIgZnJvbSBhIE5JUDA1XG4gICAqIEBwYXJhbSBuaXAwNSBOSVAtMDUgSURcbiAgICogQHBhcmFtIHNraXBDYWNoZSBTa2lwIGNhY2hlXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBhc3luYyBnZXRVc2VyRnJvbU5pcDA1KG5pcDA1LCBza2lwQ2FjaGUgPSBmYWxzZSkge1xuICAgIHJldHVybiBOREtVc2VyLmZyb21OaXAwNShuaXAwNSwgdGhpcywgc2tpcENhY2hlKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IHN1YnNjcmlwdGlvbi4gU3Vic2NyaXB0aW9ucyBhdXRvbWF0aWNhbGx5IHN0YXJ0LCB5b3UgY2FuIG1ha2UgdGhlbSBhdXRvbWF0aWNhbGx5IGNsb3NlIHdoZW4gYWxsIHJlbGF5cyBzZW5kIGJhY2sgYW4gRU9TRSBieSBzZXR0aW5nIGBvcHRzLmNsb3NlT25Fb3NlYCB0byBgdHJ1ZWApXG4gICAqXG4gICAqIEBwYXJhbSBmaWx0ZXJzXG4gICAqIEBwYXJhbSBvcHRzXG4gICAqIEBwYXJhbSByZWxheVNldCBleHBsaWNpdCByZWxheSBzZXQgdG8gdXNlXG4gICAqIEBwYXJhbSBhdXRvU3RhcnQgYXV0b21hdGljYWxseSBzdGFydCB0aGUgc3Vic2NyaXB0aW9uIC0tIHRoaXMgY2FuIGJlIGEgYm9vbGVhbiBvciBhbiBvYmplY3Qgd2l0aCBgb25FdmVudGAgYW5kIGBvbkVvc2VgIGhhbmRsZXJzXG4gICAqIEByZXR1cm5zIE5ES1N1YnNjcmlwdGlvblxuICAgKi9cbiAgc3Vic2NyaWJlKGZpbHRlcnMsIG9wdHMsIHJlbGF5U2V0LCBhdXRvU3RhcnQgPSB0cnVlKSB7XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gbmV3IE5ES1N1YnNjcmlwdGlvbih0aGlzLCBmaWx0ZXJzLCBvcHRzLCByZWxheVNldCk7XG4gICAgdGhpcy5zdWJNYW5hZ2VyLmFkZChzdWJzY3JpcHRpb24pO1xuICAgIGNvbnN0IHBvb2wgPSBvcHRzPy5wb29sID8/IHRoaXMucG9vbDtcbiAgICBpZiAocmVsYXlTZXQpIHtcbiAgICAgIGZvciAoY29uc3QgcmVsYXkgb2YgcmVsYXlTZXQucmVsYXlzKSB7XG4gICAgICAgIHBvb2wudXNlVGVtcG9yYXJ5UmVsYXkocmVsYXksIHZvaWQgMCwgc3Vic2NyaXB0aW9uLmZpbHRlcnMpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5vdXRib3hQb29sICYmIHN1YnNjcmlwdGlvbi5oYXNBdXRob3JzRmlsdGVyKCkpIHtcbiAgICAgIGNvbnN0IGF1dGhvcnMgPSBzdWJzY3JpcHRpb24uZmlsdGVycy5maWx0ZXIoKGZpbHRlcikgPT4gZmlsdGVyLmF1dGhvcnMgJiYgZmlsdGVyLmF1dGhvcnM/Lmxlbmd0aCA+IDApLm1hcCgoZmlsdGVyKSA9PiBmaWx0ZXIuYXV0aG9ycykuZmxhdCgpO1xuICAgICAgdGhpcy5vdXRib3hUcmFja2VyPy50cmFja1VzZXJzKGF1dGhvcnMpO1xuICAgIH1cbiAgICBpZiAoYXV0b1N0YXJ0KSB7XG4gICAgICBsZXQgZXZlbnRzSGFuZGxlcjtcbiAgICAgIGlmICh0eXBlb2YgYXV0b1N0YXJ0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGlmIChhdXRvU3RhcnQub25FdmVudCkgc3Vic2NyaXB0aW9uLm9uKFwiZXZlbnRcIiwgYXV0b1N0YXJ0Lm9uRXZlbnQpO1xuICAgICAgICBpZiAoYXV0b1N0YXJ0Lm9uRW9zZSkgc3Vic2NyaXB0aW9uLm9uKFwiZW9zZVwiLCBhdXRvU3RhcnQub25Fb3NlKTtcbiAgICAgICAgaWYgKGF1dG9TdGFydC5vbkV2ZW50cykgZXZlbnRzSGFuZGxlciA9IGF1dG9TdGFydC5vbkV2ZW50cztcbiAgICAgIH1cbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjb25zdCBjYWNoZWRFdmVudHMgPSBzdWJzY3JpcHRpb24uc3RhcnQoIWV2ZW50c0hhbmRsZXIpO1xuICAgICAgICBpZiAoY2FjaGVkRXZlbnRzICYmICEhZXZlbnRzSGFuZGxlcikgZXZlbnRzSGFuZGxlcihjYWNoZWRFdmVudHMpO1xuICAgICAgfSwgMCk7XG4gICAgfVxuICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gIH1cbiAgLyoqXG4gICAqIFB1Ymxpc2ggYW4gZXZlbnQgdG8gYSByZWxheVxuICAgKiBAcGFyYW0gZXZlbnQgZXZlbnQgdG8gcHVibGlzaFxuICAgKiBAcGFyYW0gcmVsYXlTZXQgZXhwbGljaXQgcmVsYXkgc2V0IHRvIHVzZVxuICAgKiBAcGFyYW0gdGltZW91dE1zIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIHRvIHdhaXQgZm9yIHRoZSBldmVudCB0byBiZSBwdWJsaXNoZWRcbiAgICogQHJldHVybnMgVGhlIHJlbGF5cyB0aGUgZXZlbnQgd2FzIHB1Ymxpc2hlZCB0b1xuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYGV2ZW50LnB1Ymxpc2goKWAgaW5zdGVhZFxuICAgKi9cbiAgYXN5bmMgcHVibGlzaChldmVudCwgcmVsYXlTZXQsIHRpbWVvdXRNcykge1xuICAgIHRoaXMuZGVidWcoXCJEZXByZWNhdGVkOiBVc2UgYGV2ZW50LnB1Ymxpc2goKWAgaW5zdGVhZFwiKTtcbiAgICByZXR1cm4gZXZlbnQucHVibGlzaChyZWxheVNldCwgdGltZW91dE1zKTtcbiAgfVxuICAvKipcbiAgICogQXR0ZW1wdHMgdG8gZmV0Y2ggYW4gZXZlbnQgZnJvbSBhIHRhZywgZm9sbG93aW5nIHJlbGF5IGhpbnRzIGFuZFxuICAgKiBvdGhlciBiZXN0IHByYWN0aWNlcy5cbiAgICogQHBhcmFtIHRhZyBUYWcgdG8gZmV0Y2ggdGhlIGV2ZW50IGZyb21cbiAgICogQHBhcmFtIG9yaWdpbmFsRXZlbnQgRXZlbnQgd2hlcmUgdGhlIHRhZyBjYW1lIGZyb21cbiAgICogQHBhcmFtIHN1Yk9wdHMgU3Vic2NyaXB0aW9uIG9wdGlvbnMgdG8gdXNlIHdoZW4gZmV0Y2hpbmcgdGhlIGV2ZW50XG4gICAqIEBwYXJhbSBmYWxsYmFjayBGYWxsYmFjayBvcHRpb25zIHRvIHVzZSB3aGVuIHRoZSBoaW50IHJlbGF5IGRvZXNuJ3QgcmVzcG9uZFxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgZmV0Y2hFdmVudEZyb21UYWcgPSBmZXRjaEV2ZW50RnJvbVRhZy5iaW5kKHRoaXMpO1xuICAvKipcbiAgICogRmV0Y2ggYW4gZXZlbnQgZnJvbSB0aGUgY2FjaGUgc3luY2hyb25vdXNseS5cbiAgICogQHBhcmFtIGlkT3JGaWx0ZXIgZXZlbnQgaWQgaW4gYmVjaDMyIGZvcm1hdCBvciBmaWx0ZXJcbiAgICogQHJldHVybnMgZXZlbnRzIGZyb20gdGhlIGNhY2hlIG9yIG51bGwgaWYgdGhlIGNhY2hlIGlzIGVtcHR5XG4gICAqL1xuICBmZXRjaEV2ZW50U3luYyhpZE9yRmlsdGVyKSB7XG4gICAgaWYgKCF0aGlzLmNhY2hlQWRhcHRlcikgdGhyb3cgbmV3IEVycm9yKFwiQ2FjaGUgYWRhcHRlciBub3Qgc2V0XCIpO1xuICAgIGxldCBmaWx0ZXJzO1xuICAgIGlmICh0eXBlb2YgaWRPckZpbHRlciA9PT0gXCJzdHJpbmdcIikgZmlsdGVycyA9IFtmaWx0ZXJGcm9tSWQoaWRPckZpbHRlcildO1xuICAgIGVsc2UgZmlsdGVycyA9IGlkT3JGaWx0ZXI7XG4gICAgY29uc3Qgc3ViID0gbmV3IE5ES1N1YnNjcmlwdGlvbih0aGlzLCBmaWx0ZXJzKTtcbiAgICBjb25zdCBldmVudHMgPSB0aGlzLmNhY2hlQWRhcHRlci5xdWVyeShzdWIpO1xuICAgIGlmIChldmVudHMgaW5zdGFuY2VvZiBQcm9taXNlKSB0aHJvdyBuZXcgRXJyb3IoXCJDYWNoZSBhZGFwdGVyIGlzIGFzeW5jXCIpO1xuICAgIHJldHVybiBldmVudHMubWFwKChlKSA9PiB7XG4gICAgICBlLm5kayA9IHRoaXM7XG4gICAgICByZXR1cm4gZTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRmV0Y2ggYSBzaW5nbGUgZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSBpZE9yRmlsdGVyIGV2ZW50IGlkIGluIGJlY2gzMiBmb3JtYXQgb3IgZmlsdGVyXG4gICAqIEBwYXJhbSBvcHRzIHN1YnNjcmlwdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSByZWxheVNldE9yUmVsYXkgZXhwbGljaXQgcmVsYXkgc2V0IHRvIHVzZVxuICAgKi9cbiAgYXN5bmMgZmV0Y2hFdmVudChpZE9yRmlsdGVyLCBvcHRzLCByZWxheVNldE9yUmVsYXkpIHtcbiAgICBsZXQgZmlsdGVycztcbiAgICBsZXQgcmVsYXlTZXQ7XG4gICAgaWYgKHJlbGF5U2V0T3JSZWxheSBpbnN0YW5jZW9mIE5ES1JlbGF5KSB7XG4gICAgICByZWxheVNldCA9IG5ldyBOREtSZWxheVNldCgvKiBAX19QVVJFX18gKi8gbmV3IFNldChbcmVsYXlTZXRPclJlbGF5XSksIHRoaXMpO1xuICAgIH0gZWxzZSBpZiAocmVsYXlTZXRPclJlbGF5IGluc3RhbmNlb2YgTkRLUmVsYXlTZXQpIHtcbiAgICAgIHJlbGF5U2V0ID0gcmVsYXlTZXRPclJlbGF5O1xuICAgIH1cbiAgICBpZiAoIXJlbGF5U2V0T3JSZWxheSAmJiB0eXBlb2YgaWRPckZpbHRlciA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKCFpc05pcDMzQVZhbHVlKGlkT3JGaWx0ZXIpKSB7XG4gICAgICAgIGNvbnN0IHJlbGF5cyA9IHJlbGF5c0Zyb21CZWNoMzIoaWRPckZpbHRlciwgdGhpcyk7XG4gICAgICAgIGlmIChyZWxheXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHJlbGF5U2V0ID0gbmV3IE5ES1JlbGF5U2V0KG5ldyBTZXQocmVsYXlzKSwgdGhpcyk7XG4gICAgICAgICAgcmVsYXlTZXQgPSBjb3JyZWN0UmVsYXlTZXQocmVsYXlTZXQsIHRoaXMucG9vbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpZE9yRmlsdGVyID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBmaWx0ZXJzID0gW2ZpbHRlckZyb21JZChpZE9yRmlsdGVyKV07XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGlkT3JGaWx0ZXIpKSB7XG4gICAgICBmaWx0ZXJzID0gaWRPckZpbHRlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgZmlsdGVycyA9IFtpZE9yRmlsdGVyXTtcbiAgICB9XG4gICAgaWYgKGZpbHRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZmlsdGVyOiAke0pTT04uc3RyaW5naWZ5KGlkT3JGaWx0ZXIpfWApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGxldCBmZXRjaGVkRXZlbnQgPSBudWxsO1xuICAgICAgY29uc3QgcyA9IHRoaXMuc3Vic2NyaWJlKFxuICAgICAgICBmaWx0ZXJzLFxuICAgICAgICB7IC4uLm9wdHMgfHwge30sIGNsb3NlT25Fb3NlOiB0cnVlIH0sXG4gICAgICAgIHJlbGF5U2V0LFxuICAgICAgICBmYWxzZVxuICAgICAgKTtcbiAgICAgIGNvbnN0IHQyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHMuc3RvcCgpO1xuICAgICAgICByZXNvbHZlKGZldGNoZWRFdmVudCk7XG4gICAgICB9LCAxZTQpO1xuICAgICAgcy5vbihcImV2ZW50XCIsIChldmVudCkgPT4ge1xuICAgICAgICBldmVudC5uZGsgPSB0aGlzO1xuICAgICAgICBpZiAoIWV2ZW50LmlzUmVwbGFjZWFibGUoKSkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0Mik7XG4gICAgICAgICAgcmVzb2x2ZShldmVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWZldGNoZWRFdmVudCB8fCBmZXRjaGVkRXZlbnQuY3JlYXRlZF9hdCA8IGV2ZW50LmNyZWF0ZWRfYXQpIHtcbiAgICAgICAgICBmZXRjaGVkRXZlbnQgPSBldmVudDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBzLm9uKFwiZW9zZVwiLCAoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0Mik7XG4gICAgICAgIHJlc29sdmUoZmV0Y2hlZEV2ZW50KTtcbiAgICAgIH0pO1xuICAgICAgcy5zdGFydCgpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBGZXRjaCBldmVudHNcbiAgICovXG4gIGFzeW5jIGZldGNoRXZlbnRzKGZpbHRlcnMsIG9wdHMsIHJlbGF5U2V0KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBjb25zdCBldmVudHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgY29uc3QgcmVsYXlTZXRTdWJzY3JpcHRpb24gPSB0aGlzLnN1YnNjcmliZShcbiAgICAgICAgZmlsdGVycyxcbiAgICAgICAgeyAuLi5vcHRzIHx8IHt9LCBjbG9zZU9uRW9zZTogdHJ1ZSB9LFxuICAgICAgICByZWxheVNldCxcbiAgICAgICAgZmFsc2VcbiAgICAgICk7XG4gICAgICBjb25zdCBvbkV2ZW50ID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmICghKGV2ZW50IGluc3RhbmNlb2YgTkRLRXZlbnQpKSBldmVudCA9IG5ldyBOREtFdmVudCh2b2lkIDAsIGV2ZW50KTtcbiAgICAgICAgY29uc3QgZGVkdXBLZXkgPSBldmVudC5kZWR1cGxpY2F0aW9uS2V5KCk7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nRXZlbnQgPSBldmVudHMuZ2V0KGRlZHVwS2V5KTtcbiAgICAgICAgaWYgKGV4aXN0aW5nRXZlbnQpIHtcbiAgICAgICAgICBldmVudCA9IGRlZHVwKGV4aXN0aW5nRXZlbnQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBldmVudC5uZGsgPSB0aGlzO1xuICAgICAgICBldmVudHMuc2V0KGRlZHVwS2V5LCBldmVudCk7XG4gICAgICB9O1xuICAgICAgcmVsYXlTZXRTdWJzY3JpcHRpb24ub24oXCJldmVudFwiLCBvbkV2ZW50KTtcbiAgICAgIHJlbGF5U2V0U3Vic2NyaXB0aW9uLm9uKFwiZW9zZVwiLCAoKSA9PiB7XG4gICAgICAgIHJlc29sdmUobmV3IFNldChldmVudHMudmFsdWVzKCkpKTtcbiAgICAgIH0pO1xuICAgICAgcmVsYXlTZXRTdWJzY3JpcHRpb24uc3RhcnQoKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogRW5zdXJlcyB0aGF0IGEgc2lnbmVyIGlzIGF2YWlsYWJsZSB0byBzaWduIGFuIGV2ZW50LlxuICAgKi9cbiAgYXNzZXJ0U2lnbmVyKCkge1xuICAgIGlmICghdGhpcy5zaWduZXIpIHtcbiAgICAgIHRoaXMuZW1pdChcInNpZ25lcjpyZXF1aXJlZFwiKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlNpZ25lciByZXF1aXJlZFwiKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgTmlwOTYgaW5zdGFuY2UgZm9yIHRoZSBnaXZlbiBkb21haW4uXG4gICAqIEBwYXJhbSBkb21haW4gRG9tYWluIHRvIHVzZSBmb3IgbmlwOTYgdXBsb2Fkc1xuICAgKiBAZXhhbXBsZSBVcGxvYWQgYSBmaWxlIHRvIGEgTklQLTk2IGVuYWJsZWQgZG9tYWluOlxuICAgKlxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbXCJIZWxsbywgd29ybGQhXCJdLCB7IHR5cGU6IFwidGV4dC9wbGFpblwiIH0pO1xuICAgKiBjb25zdCBuaXA5NiA9IG5kay5nZXROaXA5NihcIm5vc3RyY2hlY2subWVcIik7XG4gICAqIGF3YWl0IG5pcDk2LnVwbG9hZChibG9iKTtcbiAgICogYGBgXG4gICAqL1xuICBnZXROaXA5Nihkb21haW4pIHtcbiAgICByZXR1cm4gbmV3IE5pcDk2KGRvbWFpbiwgdGhpcyk7XG4gIH1cbiAgc2V0IHdhbGxldCh3YWxsZXQpIHtcbiAgICBpZiAoIXdhbGxldCkge1xuICAgICAgdGhpcy53YWxsZXRDb25maWcgPSB2b2lkIDA7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMud2FsbGV0Q29uZmlnID8/PSB7fTtcbiAgICB0aGlzLndhbGxldENvbmZpZy5sblBheSA9IHdhbGxldD8ubG5QYXk/LmJpbmQod2FsbGV0KTtcbiAgICB0aGlzLndhbGxldENvbmZpZy5jYXNodVBheSA9IHdhbGxldD8uY2FzaHVQYXk/LmJpbmQod2FsbGV0KTtcbiAgfVxufTtcblxuLy8gc3JjL3phcC9pbnZvaWNlLnRzXG5pbXBvcnQgeyBkZWNvZGUgfSBmcm9tIFwibGlnaHQtYm9sdDExLWRlY29kZXJcIjtcbmZ1bmN0aW9uIHphcEludm9pY2VGcm9tRXZlbnQoZXZlbnQpIHtcbiAgY29uc3QgZGVzY3JpcHRpb24gPSBldmVudC5nZXRNYXRjaGluZ1RhZ3MoXCJkZXNjcmlwdGlvblwiKVswXTtcbiAgY29uc3QgYm9sdDExID0gZXZlbnQuZ2V0TWF0Y2hpbmdUYWdzKFwiYm9sdDExXCIpWzBdO1xuICBsZXQgZGVjb2RlZEludm9pY2U7XG4gIGxldCB6YXBSZXF1ZXN0O1xuICBpZiAoIWRlc2NyaXB0aW9uIHx8ICFib2x0MTEgfHwgIWJvbHQxMVsxXSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHRyeSB7XG4gICAgbGV0IHphcFJlcXVlc3RQYXlsb2FkID0gZGVzY3JpcHRpb25bMV07XG4gICAgaWYgKHphcFJlcXVlc3RQYXlsb2FkLnN0YXJ0c1dpdGgoXCIlXCIpKSB7XG4gICAgICB6YXBSZXF1ZXN0UGF5bG9hZCA9IGRlY29kZVVSSUNvbXBvbmVudCh6YXBSZXF1ZXN0UGF5bG9hZCk7XG4gICAgfVxuICAgIGlmICh6YXBSZXF1ZXN0UGF5bG9hZCA9PT0gXCJcIikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHphcFJlcXVlc3QgPSBKU09OLnBhcnNlKHphcFJlcXVlc3RQYXlsb2FkKTtcbiAgICBkZWNvZGVkSW52b2ljZSA9IGRlY29kZShib2x0MTFbMV0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgYW1vdW50U2VjdGlvbiA9IGRlY29kZWRJbnZvaWNlLnNlY3Rpb25zLmZpbmQoKHMpID0+IHMubmFtZSA9PT0gXCJhbW91bnRcIik7XG4gIGlmICghYW1vdW50U2VjdGlvbikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGFtb3VudCA9IHBhcnNlSW50KGFtb3VudFNlY3Rpb24udmFsdWUpO1xuICBpZiAoIWFtb3VudCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGNvbnRlbnQgPSB6YXBSZXF1ZXN0LmNvbnRlbnQ7XG4gIGNvbnN0IHNlbmRlciA9IHphcFJlcXVlc3QucHVia2V5O1xuICBjb25zdCByZWNpcGllbnRUYWcgPSBldmVudC5nZXRNYXRjaGluZ1RhZ3MoXCJwXCIpWzBdO1xuICBjb25zdCByZWNpcGllbnQgPSByZWNpcGllbnRUYWdbMV07XG4gIGxldCB6YXBwZWRFdmVudCA9IGV2ZW50LmdldE1hdGNoaW5nVGFncyhcImVcIilbMF07XG4gIGlmICghemFwcGVkRXZlbnQpIHtcbiAgICB6YXBwZWRFdmVudCA9IGV2ZW50LmdldE1hdGNoaW5nVGFncyhcImFcIilbMF07XG4gIH1cbiAgY29uc3QgemFwcGVkRXZlbnRJZCA9IHphcHBlZEV2ZW50ID8gemFwcGVkRXZlbnRbMV0gOiB2b2lkIDA7XG4gIGNvbnN0IHphcEludm9pY2UgPSB7XG4gICAgaWQ6IGV2ZW50LmlkLFxuICAgIHphcHBlcjogZXZlbnQucHVia2V5LFxuICAgIHphcHBlZTogc2VuZGVyLFxuICAgIHphcHBlZDogcmVjaXBpZW50LFxuICAgIHphcHBlZEV2ZW50OiB6YXBwZWRFdmVudElkLFxuICAgIGFtb3VudCxcbiAgICBjb21tZW50OiBjb250ZW50XG4gIH07XG4gIHJldHVybiB6YXBJbnZvaWNlO1xufVxuXG4vLyBzcmMvemFwcGVyL2luZGV4LnRzXG5pbXBvcnQgY3JlYXRlRGVidWc1IGZyb20gXCJkZWJ1Z1wiO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIGFzIEV2ZW50RW1pdHRlcjkgfSBmcm9tIFwidHNlZXBcIjtcblxuLy8gc3JjL3phcHBlci9uaXA1Ny50c1xuaW1wb3J0IHsgbmlwNTcgfSBmcm9tIFwibm9zdHItdG9vbHNcIjtcbmFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlWmFwUmVxdWVzdCh0YXJnZXQsIG5kaywgZGF0YSwgcHVia2V5LCBhbW91bnQsIHJlbGF5cywgY29tbWVudCwgdGFncywgc2lnbmVyKSB7XG4gIGNvbnN0IHphcEVuZHBvaW50ID0gZGF0YS5jYWxsYmFjaztcbiAgY29uc3QgemFwUmVxdWVzdCA9IG5pcDU3Lm1ha2VaYXBSZXF1ZXN0KHtcbiAgICBwcm9maWxlOiBwdWJrZXksXG4gICAgLy8gc2V0IHRoZSBldmVudCB0byBudWxsIHNpbmNlIG5vc3RyLXRvb2xzIGRvZXNuJ3Qgc3VwcG9ydCBuaXAtMzMgemFwc1xuICAgIGV2ZW50OiBudWxsLFxuICAgIGFtb3VudCxcbiAgICBjb21tZW50OiBjb21tZW50IHx8IFwiXCIsXG4gICAgcmVsYXlzOiByZWxheXMuc2xpY2UoMCwgNClcbiAgfSk7XG4gIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBOREtFdmVudCkge1xuICAgIGNvbnN0IHRhZ3MyID0gdGFyZ2V0LnJlZmVyZW5jZVRhZ3MoKTtcbiAgICBjb25zdCBub25QVGFncyA9IHRhZ3MyLmZpbHRlcigodGFnKSA9PiB0YWdbMF0gIT09IFwicFwiKTtcbiAgICB6YXBSZXF1ZXN0LnRhZ3MucHVzaCguLi5ub25QVGFncyk7XG4gIH1cbiAgemFwUmVxdWVzdC50YWdzLnB1c2goW1wibG51cmxcIiwgemFwRW5kcG9pbnRdKTtcbiAgY29uc3QgZXZlbnQgPSBuZXcgTkRLRXZlbnQobmRrLCB6YXBSZXF1ZXN0KTtcbiAgaWYgKHRhZ3MpIHtcbiAgICBldmVudC50YWdzID0gZXZlbnQudGFncy5jb25jYXQodGFncyk7XG4gIH1cbiAgaWYgKGV2ZW50Lmhhc1RhZyhcImFcIikpIHtcbiAgICBldmVudC50YWdzID0gZXZlbnQudGFncy5maWx0ZXIoKHRhZykgPT4gdGFnWzBdICE9PSBcImVcIik7XG4gIH1cbiAgZXZlbnQudGFncyA9IGV2ZW50LnRhZ3MuZmlsdGVyKCh0YWcpID0+IHRhZ1swXSAhPT0gXCJwXCIpO1xuICBldmVudC50YWdzLnB1c2goW1wicFwiLCBwdWJrZXldKTtcbiAgYXdhaXQgZXZlbnQuc2lnbihzaWduZXIpO1xuICByZXR1cm4gZXZlbnQ7XG59XG5cbi8vIHNyYy96YXBwZXIvbG4udHNcbmltcG9ydCB7IGJlY2gzMiB9IGZyb20gXCJAc2N1cmUvYmFzZVwiO1xuaW1wb3J0IGNyZWF0ZURlYnVnNCBmcm9tIFwiZGVidWdcIjtcbnZhciBkMiA9IGNyZWF0ZURlYnVnNChcIm5kazp6YXBwZXI6bG5cIik7XG5hc3luYyBmdW5jdGlvbiBnZXROaXA1N1phcFNwZWNGcm9tTHVkKHsgbHVkMDYsIGx1ZDE2IH0sIG5kaykge1xuICBsZXQgemFwRW5kcG9pbnQ7XG4gIGlmIChsdWQxNiAmJiAhbHVkMTYuc3RhcnRzV2l0aChcIkxOVVJMXCIpKSB7XG4gICAgY29uc3QgW25hbWUsIGRvbWFpbl0gPSBsdWQxNi5zcGxpdChcIkBcIik7XG4gICAgemFwRW5kcG9pbnQgPSBgaHR0cHM6Ly8ke2RvbWFpbn0vLndlbGwta25vd24vbG51cmxwLyR7bmFtZX1gO1xuICB9IGVsc2UgaWYgKGx1ZDA2KSB7XG4gICAgY29uc3QgeyB3b3JkcyB9ID0gYmVjaDMyLmRlY29kZShsdWQwNiwgMWUzKTtcbiAgICBjb25zdCBkYXRhID0gYmVjaDMyLmZyb21Xb3Jkcyh3b3Jkcyk7XG4gICAgY29uc3QgdXRmOERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoXCJ1dGYtOFwiKTtcbiAgICB6YXBFbmRwb2ludCA9IHV0ZjhEZWNvZGVyLmRlY29kZShkYXRhKTtcbiAgfVxuICBpZiAoIXphcEVuZHBvaW50KSB7XG4gICAgZDIoXCJObyB6YXAgZW5kcG9pbnQgZm91bmQgJW9cIiwgeyBsdWQwNiwgbHVkMTYgfSk7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gemFwIGVuZHBvaW50IGZvdW5kXCIpO1xuICB9XG4gIHRyeSB7XG4gICAgY29uc3QgX2ZldGNoID0gbmRrLmh0dHBGZXRjaCB8fCBmZXRjaDtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IF9mZXRjaCh6YXBFbmRwb2ludCk7XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gZmV0Y2ggemFwIGVuZHBvaW50ICR7emFwRW5kcG9pbnR9OiAke3RleHR9YCk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBmZXRjaCB6YXAgZW5kcG9pbnQgJHt6YXBFbmRwb2ludH06ICR7ZX1gKTtcbiAgfVxufVxuXG4vLyBzcmMvemFwcGVyL2luZGV4LnRzXG52YXIgZDMgPSBjcmVhdGVEZWJ1ZzUoXCJuZGs6emFwcGVyXCIpO1xudmFyIE5ES1phcHBlciA9IGNsYXNzIGV4dGVuZHMgRXZlbnRFbWl0dGVyOSB7XG4gIHRhcmdldDtcbiAgbmRrO1xuICBjb21tZW50O1xuICBhbW91bnQ7XG4gIHVuaXQ7XG4gIHRhZ3M7XG4gIHNpZ25lcjtcbiAgemFwTWV0aG9kO1xuICBudXR6YXBBc0ZhbGxiYWNrO1xuICBsblBheTtcbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIGEgY2FzaHUgcGF5bWVudCBpcyB0byBiZSBtYWRlLlxuICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBzd2FwL21pbnQgcHJvb2ZzIGZvciB0aGUgcmVxdWlyZWQgYW1vdW50LCBpbiB0aGUgcmVxdWlyZWQgdW5pdCxcbiAgICogaW4gYW55IG9mIHRoZSBwcm92aWRlZCBtaW50cyBhbmQgcmV0dXJuIHRoZSBwcm9vZnMgYW5kIG1pbnQgdXNlZC5cbiAgICovXG4gIGNhc2h1UGF5O1xuICBvbkNvbXBsZXRlO1xuICBtYXhSZWxheXMgPSAzO1xuICAvKipcbiAgICogXG4gICAqIEBwYXJhbSB0YXJnZXQgVGhlIHRhcmdldCBvZiB0aGUgemFwXG4gICAqIEBwYXJhbSBhbW91bnQgVGhlIGFtb3VudCB0byBzZW5kIGluZGljYXRlZCBpbiB0aGUgdW5pdFxuICAgKiBAcGFyYW0gdW5pdCBUaGUgdW5pdCBvZiB0aGUgYW1vdW50XG4gICAqIEBwYXJhbSBvcHRzIE9wdGlvbnMgZm9yIHRoZSB6YXBcbiAgICovXG4gIGNvbnN0cnVjdG9yKHRhcmdldCwgYW1vdW50LCB1bml0ID0gXCJtc2F0XCIsIG9wdHMgPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgdGhpcy5uZGsgPSBvcHRzLm5kayB8fCB0YXJnZXQubmRrO1xuICAgIGlmICghdGhpcy5uZGspIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIE5ESyBpbnN0YW5jZSBwcm92aWRlZFwiKTtcbiAgICB9XG4gICAgdGhpcy5hbW91bnQgPSBhbW91bnQ7XG4gICAgdGhpcy5jb21tZW50ID0gb3B0cy5jb21tZW50O1xuICAgIHRoaXMudW5pdCA9IHVuaXQ7XG4gICAgdGhpcy50YWdzID0gb3B0cy50YWdzO1xuICAgIHRoaXMuc2lnbmVyID0gb3B0cy5zaWduZXI7XG4gICAgdGhpcy5udXR6YXBBc0ZhbGxiYWNrID0gb3B0cy5udXR6YXBBc0ZhbGxiYWNrID8/IGZhbHNlO1xuICAgIHRoaXMubG5QYXkgPSBvcHRzLmxuUGF5IHx8IHRoaXMubmRrLndhbGxldENvbmZpZz8ubG5QYXk7XG4gICAgdGhpcy5jYXNodVBheSA9IG9wdHMuY2FzaHVQYXkgfHwgdGhpcy5uZGsud2FsbGV0Q29uZmlnPy5jYXNodVBheTtcbiAgICB0aGlzLm9uQ29tcGxldGUgPSBvcHRzLm9uQ29tcGxldGUgfHwgdGhpcy5uZGsud2FsbGV0Q29uZmlnPy5vblBheW1lbnRDb21wbGV0ZTtcbiAgfVxuICAvKipcbiAgICogSW5pdGlhdGUgemFwcGluZyBwcm9jZXNzXG4gICAqIFxuICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgY2FsY3VsYXRlIHRoZSBzcGxpdHMgZm9yIHRoaXMgemFwIGFuZCBpbml0aWF0ZSBlYWNoIHphcCBzcGxpdC5cbiAgICovXG4gIGFzeW5jIHphcChtZXRob2RzKSB7XG4gICAgY29uc3Qgc3BsaXRzID0gdGhpcy5nZXRaYXBTcGxpdHMoKTtcbiAgICBjb25zdCByZXN1bHRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIHNwbGl0cy5tYXAoYXN5bmMgKHNwbGl0KSA9PiB7XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVzdWx0ID0gYXdhaXQgdGhpcy56YXBTcGxpdChzcGxpdCwgbWV0aG9kcyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXN1bHQgPSBuZXcgRXJyb3IoZS5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoXCJzcGxpdDpjb21wbGV0ZVwiLCBzcGxpdCwgcmVzdWx0KTtcbiAgICAgICAgcmVzdWx0cy5zZXQoc3BsaXQsIHJlc3VsdCk7XG4gICAgICB9KVxuICAgICk7XG4gICAgdGhpcy5lbWl0KFwiY29tcGxldGVcIiwgcmVzdWx0cyk7XG4gICAgaWYgKHRoaXMub25Db21wbGV0ZSkgdGhpcy5vbkNvbXBsZXRlKHJlc3VsdHMpO1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG4gIGFzeW5jIHphcE5pcDU3KHNwbGl0LCBkYXRhKSB7XG4gICAgaWYgKCF0aGlzLmxuUGF5KSB0aHJvdyBuZXcgRXJyb3IoXCJObyBsblBheSBmdW5jdGlvbiBhdmFpbGFibGVcIik7XG4gICAgY29uc3QgemFwU3BlYyA9IGF3YWl0IGdldE5pcDU3WmFwU3BlY0Zyb21MdWQoZGF0YSwgdGhpcy5uZGspO1xuICAgIGlmICghemFwU3BlYykgdGhyb3cgbmV3IEVycm9yKFwiTm8gemFwIHNwZWMgYXZhaWxhYmxlIGZvciByZWNpcGllbnRcIik7XG4gICAgY29uc3QgcmVsYXlzID0gYXdhaXQgdGhpcy5yZWxheXMoc3BsaXQucHVia2V5KTtcbiAgICBjb25zdCB6YXBSZXF1ZXN0ID0gYXdhaXQgZ2VuZXJhdGVaYXBSZXF1ZXN0KFxuICAgICAgdGhpcy50YXJnZXQsXG4gICAgICB0aGlzLm5kayxcbiAgICAgIHphcFNwZWMsXG4gICAgICBzcGxpdC5wdWJrZXksXG4gICAgICBzcGxpdC5hbW91bnQsXG4gICAgICByZWxheXMsXG4gICAgICB0aGlzLmNvbW1lbnQsXG4gICAgICB0aGlzLnRhZ3MsXG4gICAgICB0aGlzLnNpZ25lclxuICAgICk7XG4gICAgaWYgKCF6YXBSZXF1ZXN0KSB7XG4gICAgICBkMyhcIlVuYWJsZSB0byBnZW5lcmF0ZSB6YXAgcmVxdWVzdFwiKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBnZW5lcmF0ZSB6YXAgcmVxdWVzdFwiKTtcbiAgICB9XG4gICAgY29uc3QgcHIgPSBhd2FpdCB0aGlzLmdldExuSW52b2ljZSh6YXBSZXF1ZXN0LCBzcGxpdC5hbW91bnQsIHphcFNwZWMpO1xuICAgIGlmICghcHIpIHtcbiAgICAgIGQzKFwiVW5hYmxlIHRvIGdldCBwYXltZW50IHJlcXVlc3RcIik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gZ2V0IHBheW1lbnQgcmVxdWVzdFwiKTtcbiAgICB9XG4gICAgdGhpcy5lbWl0KFwibG5faW52b2ljZVwiLCB7XG4gICAgICBhbW91bnQ6IHNwbGl0LmFtb3VudCxcbiAgICAgIHJlY2lwaWVudFB1YmtleTogc3BsaXQucHVia2V5LFxuICAgICAgdW5pdDogdGhpcy51bml0LFxuICAgICAgbmlwNTdaYXBSZXF1ZXN0OiB6YXBSZXF1ZXN0LFxuICAgICAgcHIsXG4gICAgICB0eXBlOiBcIm5pcDU3XCJcbiAgICB9KTtcbiAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmxuUGF5KFxuICAgICAge1xuICAgICAgICB0YXJnZXQ6IHRoaXMudGFyZ2V0LFxuICAgICAgICByZWNpcGllbnRQdWJrZXk6IHNwbGl0LnB1YmtleSxcbiAgICAgICAgcGF5bWVudERlc2NyaXB0aW9uOiBcIk5JUC01NyBaYXBcIixcbiAgICAgICAgcHIsXG4gICAgICAgIGFtb3VudDogc3BsaXQuYW1vdW50LFxuICAgICAgICB1bml0OiB0aGlzLnVuaXQsXG4gICAgICAgIG5pcDU3WmFwUmVxdWVzdDogemFwUmVxdWVzdFxuICAgICAgfVxuICAgICk7XG4gICAgaWYgKHJlcz8ucHJlaW1hZ2UpIHtcbiAgICAgIHRoaXMuZW1pdChcImxuX3BheW1lbnRcIiwge1xuICAgICAgICBwcmVpbWFnZTogcmVzLnByZWltYWdlLFxuICAgICAgICBhbW91bnQ6IHNwbGl0LmFtb3VudCxcbiAgICAgICAgcmVjaXBpZW50UHVia2V5OiBzcGxpdC5wdWJrZXksXG4gICAgICAgIHByLFxuICAgICAgICB1bml0OiB0aGlzLnVuaXQsXG4gICAgICAgIG5pcDU3WmFwUmVxdWVzdDogemFwUmVxdWVzdCxcbiAgICAgICAgdHlwZTogXCJuaXA1N1wiXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICAvKipcbiAgICogRmV0Y2hlcyBpbmZvcm1hdGlvbiBhYm91dCBhIE5JUC02MSB6YXAgYW5kIGFza3MgdGhlIGNhbGxlciB0byBjcmVhdGUgY2FzaHUgcHJvb2ZzIGZvciB0aGUgemFwLlxuICAgKiBcbiAgICogKG5vdGUgdGhhdCB0aGUgY2FzaHVQYXkgZnVuY3Rpb24gY2FuIHVzZSBhbnkgbWV0aG9kIHRvIGNyZWF0ZSB0aGUgcHJvb2ZzLCBpbmNsdWRpbmcgdXNpbmcgbGlnaHRuaW5nXG4gICAqIHRvIG1pbnQgcHJvb2ZzIGluIHRoZSBzcGVjaWZpZWQgbWludCwgdGhlIHJlc3BvbnNpYmlsaXR5IG9mIG1pbnRpbmcgdGhlIHByb29mcyBpcyBkZWxlZ2F0ZWQgdG8gdGhlIGNhbGxlciAoZS5nLiBuZGstd2FsbGV0KSlcbiAgICovXG4gIGFzeW5jIHphcE5pcDYxKHNwbGl0LCBkYXRhKSB7XG4gICAgaWYgKCF0aGlzLmNhc2h1UGF5KSB0aHJvdyBuZXcgRXJyb3IoXCJObyBjYXNodVBheSBmdW5jdGlvbiBhdmFpbGFibGVcIik7XG4gICAgbGV0IHJldDtcbiAgICByZXQgPSBhd2FpdCB0aGlzLmNhc2h1UGF5KHtcbiAgICAgIHRhcmdldDogdGhpcy50YXJnZXQsXG4gICAgICByZWNpcGllbnRQdWJrZXk6IHNwbGl0LnB1YmtleSxcbiAgICAgIHBheW1lbnREZXNjcmlwdGlvbjogXCJOSVAtNjEgWmFwXCIsXG4gICAgICBhbW91bnQ6IHNwbGl0LmFtb3VudCxcbiAgICAgIHVuaXQ6IHRoaXMudW5pdCxcbiAgICAgIC4uLmRhdGEgPz8ge31cbiAgICB9LCAocHIpID0+IHtcbiAgICAgIHRoaXMuZW1pdChcImxuX2ludm9pY2VcIiwge1xuICAgICAgICBwcixcbiAgICAgICAgYW1vdW50OiBzcGxpdC5hbW91bnQsXG4gICAgICAgIHJlY2lwaWVudFB1YmtleTogc3BsaXQucHVia2V5LFxuICAgICAgICB1bml0OiB0aGlzLnVuaXQsXG4gICAgICAgIHR5cGU6IFwibmlwNjFcIlxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgZDMoXCJOSVAtNjEgWmFwIHJlc3VsdDogJW9cIiwgcmV0KTtcbiAgICBpZiAocmV0IGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSBlbHNlIGlmIChyZXQpIHtcbiAgICAgIGNvbnN0IHsgcHJvb2ZzLCBtaW50IH0gPSByZXQ7XG4gICAgICBpZiAoIXByb29mcyB8fCAhbWludClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiSW52YWxpZCB6YXAgY29uZmlybWF0aW9uOiBtaXNzaW5nIHByb29mcyBvciBtaW50OiBcIiArIHJldFxuICAgICAgICApO1xuICAgICAgY29uc3QgcmVsYXlzID0gYXdhaXQgdGhpcy5yZWxheXMoc3BsaXQucHVia2V5KTtcbiAgICAgIGNvbnN0IHJlbGF5U2V0ID0gTkRLUmVsYXlTZXQuZnJvbVJlbGF5VXJscyhyZWxheXMsIHRoaXMubmRrKTtcbiAgICAgIGNvbnN0IG51dHphcCA9IG5ldyBOREtOdXR6YXAodGhpcy5uZGspO1xuICAgICAgbnV0emFwLnRhZ3MgPSBbLi4ubnV0emFwLnRhZ3MsIC4uLnRoaXMudGFncyB8fCBbXV07XG4gICAgICBudXR6YXAucHJvb2ZzID0gcHJvb2ZzO1xuICAgICAgbnV0emFwLm1pbnQgPSBtaW50O1xuICAgICAgbnV0emFwLnRhcmdldCA9IHRoaXMudGFyZ2V0O1xuICAgICAgbnV0emFwLmNvbW1lbnQgPSB0aGlzLmNvbW1lbnQ7XG4gICAgICBudXR6YXAudW5pdCA9IHRoaXMudW5pdDtcbiAgICAgIG51dHphcC5yZWNpcGllbnRQdWJrZXkgPSBzcGxpdC5wdWJrZXk7XG4gICAgICBhd2FpdCBudXR6YXAuc2lnbih0aGlzLnNpZ25lcik7XG4gICAgICBudXR6YXAucHVibGlzaChyZWxheVNldCk7XG4gICAgICByZXR1cm4gbnV0emFwO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSB6YXAgbWV0aG9kcyBhdmFpbGFibGUgZm9yIHRoZSByZWNpcGllbnQgYW5kIGluaXRpYXRlcyB0aGUgemFwXG4gICAqIGluIHRoZSBkZXNpcmVkIG1ldGhvZC5cbiAgICogQHBhcmFtIHNwbGl0IFxuICAgKiBAcGFyYW0gbWV0aG9kcyAtIFRoZSBtZXRob2RzIHRvIHRyeSwgaWYgbm90IHByb3ZpZGVkLCBhbGwgbWV0aG9kcyB3aWxsIGJlIHRyaWVkLlxuICAgKiBAcmV0dXJucyBcbiAgICovXG4gIGFzeW5jIHphcFNwbGl0KHNwbGl0LCBtZXRob2RzKSB7XG4gICAgY29uc3QgcmVjaXBpZW50ID0gdGhpcy5uZGsuZ2V0VXNlcih7IHB1YmtleTogc3BsaXQucHVia2V5IH0pO1xuICAgIGxldCB6YXBNZXRob2RzID0gYXdhaXQgcmVjaXBpZW50LmdldFphcEluZm8oMjUwMCk7XG4gICAgbGV0IHJldFZhbDtcbiAgICBjb25zdCBjYW5GYWxsYmFja1RvTmlwNjEgPSB0aGlzLm51dHphcEFzRmFsbGJhY2sgJiYgdGhpcy5jYXNodVBheTtcbiAgICBpZiAoemFwTWV0aG9kcy5zaXplID09PSAwICYmICFjYW5GYWxsYmFja1RvTmlwNjEpIHRocm93IG5ldyBFcnJvcihcIk5vIHphcCBtZXRob2QgYXZhaWxhYmxlIGZvciByZWNpcGllbnQgYW5kIE5JUC02MSBmYWxsYmFjayBpcyBkaXNhYmxlZFwiKTtcbiAgICBjb25zdCBuaXA2MUZhbGxiYWNrID0gYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLm51dHphcEFzRmFsbGJhY2spIHJldHVybjtcbiAgICAgIGNvbnN0IHJlbGF5TGlzdHMgPSBhd2FpdCBnZXRSZWxheUxpc3RGb3JVc2Vycyhbc3BsaXQucHVia2V5XSwgdGhpcy5uZGspO1xuICAgICAgbGV0IHJlbGF5VXJscyA9IHJlbGF5TGlzdHMuZ2V0KHNwbGl0LnB1YmtleSk/LnJlYWRSZWxheVVybHM7XG4gICAgICByZWxheVVybHMgPSB0aGlzLm5kay5wb29sLmNvbm5lY3RlZFJlbGF5cygpLm1hcCgocikgPT4gci51cmwpO1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuemFwTmlwNjEoc3BsaXQsIHtcbiAgICAgICAgLy8gdXNlIHRoZSB1c2VyJ3MgcmVsYXkgbGlzdFxuICAgICAgICByZWxheXM6IHJlbGF5VXJscyxcbiAgICAgICAgLy8gbG9jayB0byB0aGUgdXNlcidzIGFjdHVhbCBwdWJrZXlcbiAgICAgICAgcDJwazogc3BsaXQucHVia2V5LFxuICAgICAgICAvLyBhbGxvdyBpbnRyYW1pbnQgZmFsbGJhY2tcbiAgICAgICAgYWxsb3dJbnRyYW1pbnRGYWxsYmFjazogISFjYW5GYWxsYmFja1RvTmlwNjFcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgY2FuVXNlTmlwNjEgPSAhbWV0aG9kcyB8fCBtZXRob2RzLmluY2x1ZGVzKFwibmlwNjFcIik7XG4gICAgY29uc3QgY2FuVXNlTmlwNTcgPSAhbWV0aG9kcyB8fCBtZXRob2RzLmluY2x1ZGVzKFwibmlwNTdcIik7XG4gICAgY29uc3QgbmlwNjFNZXRob2QgPSB6YXBNZXRob2RzLmdldChcIm5pcDYxXCIpO1xuICAgIGlmIChuaXA2MU1ldGhvZCAmJiBjYW5Vc2VOaXA2MSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0VmFsID0gYXdhaXQgdGhpcy56YXBOaXA2MShzcGxpdCwgbmlwNjFNZXRob2QpO1xuICAgICAgICBpZiAocmV0VmFsIGluc3RhbmNlb2YgTkRLTnV0emFwKSByZXR1cm4gcmV0VmFsO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLmVtaXQoXCJub3RpY2VcIiwgYE5JUC02MSBhdHRlbXB0IGZhaWxlZDogJHtlLm1lc3NhZ2V9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG5pcDU3TWV0aG9kID0gemFwTWV0aG9kcy5nZXQoXCJuaXA1N1wiKTtcbiAgICBpZiAobmlwNTdNZXRob2QgJiYgY2FuVXNlTmlwNTcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldFZhbCA9IGF3YWl0IHRoaXMuemFwTmlwNTcoc3BsaXQsIG5pcDU3TWV0aG9kKTtcbiAgICAgICAgaWYgKCEocmV0VmFsIGluc3RhbmNlb2YgRXJyb3IpKSByZXR1cm4gcmV0VmFsO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLmVtaXQoXCJub3RpY2VcIiwgYE5JUC01NyBhdHRlbXB0IGZhaWxlZDogJHtlLm1lc3NhZ2V9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjYW5GYWxsYmFja1RvTmlwNjEpIHtcbiAgICAgIHJldFZhbCA9IGF3YWl0IG5pcDYxRmFsbGJhY2soKTtcbiAgICAgIGlmIChyZXRWYWwgaW5zdGFuY2VvZiBFcnJvcikgdGhyb3cgcmV0VmFsO1xuICAgICAgcmV0dXJuIHJldFZhbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbWl0KFwibm90aWNlXCIsIFwiWmFwIG1ldGhvZHMgZXhoYXVzdGVkIGFuZCB0aGVyZSB3YXMgbm8gZmFsbGJhY2sgdG8gTklQLTYxXCIpO1xuICAgIH1cbiAgICBpZiAocmV0VmFsIGluc3RhbmNlb2YgRXJyb3IpIHRocm93IHJldFZhbDtcbiAgICByZXR1cm4gcmV0VmFsO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIGEgYm9sdDExIGZvciBhIG5pcDU3IHphcFxuICAgKiBAcGFyYW0gZXZlbnRcbiAgICogQHBhcmFtIGFtb3VudFxuICAgKiBAcGFyYW0gemFwRW5kcG9pbnRcbiAgICogQHJldHVybnNcbiAgICovXG4gIGFzeW5jIGdldExuSW52b2ljZSh6YXBSZXF1ZXN0LCBhbW91bnQsIGRhdGEpIHtcbiAgICBjb25zdCB6YXBFbmRwb2ludCA9IGRhdGEuY2FsbGJhY2s7XG4gICAgY29uc3QgZXZlbnRQYXlsb2FkID0gSlNPTi5zdHJpbmdpZnkoemFwUmVxdWVzdC5yYXdFdmVudCgpKTtcbiAgICBkMyhcbiAgICAgIGBGZXRjaGluZyBpbnZvaWNlIGZyb20gJHt6YXBFbmRwb2ludH0/YCArIG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgICAgICBhbW91bnQ6IGFtb3VudC50b1N0cmluZygpLFxuICAgICAgICBub3N0cjogZXZlbnRQYXlsb2FkXG4gICAgICB9KVxuICAgICk7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTCh6YXBFbmRwb2ludCk7XG4gICAgdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoXCJhbW91bnRcIiwgYW1vdW50LnRvU3RyaW5nKCkpO1xuICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKFwibm9zdHJcIiwgZXZlbnRQYXlsb2FkKTtcbiAgICBkMyhgRmV0Y2hpbmcgaW52b2ljZSBmcm9tICR7dXJsLnRvU3RyaW5nKCl9YCk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwudG9TdHJpbmcoKSk7XG4gICAgZDMoYEdvdCByZXNwb25zZSBmcm9tIHphcCBlbmRwb2ludDogJHt6YXBFbmRwb2ludH1gLCB7IHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzIH0pO1xuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgZDMoYFJlY2VpdmVkIG5vbi0yMDAgc3RhdHVzIGZyb20gemFwIGVuZHBvaW50OiAke3phcEVuZHBvaW50fWAsIHtcbiAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIGFtb3VudCxcbiAgICAgICAgbm9zdHI6IGV2ZW50UGF5bG9hZFxuICAgICAgfSk7XG4gICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gZmV0Y2ggemFwIGVuZHBvaW50ICR7emFwRW5kcG9pbnR9OiAke3RleHR9YCk7XG4gICAgfVxuICAgIGNvbnN0IGJvZHkgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgcmV0dXJuIGJvZHkucHI7XG4gIH1cbiAgZ2V0WmFwU3BsaXRzKCkge1xuICAgIGlmICh0aGlzLnRhcmdldCBpbnN0YW5jZW9mIE5ES1VzZXIpIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHtcbiAgICAgICAgICBwdWJrZXk6IHRoaXMudGFyZ2V0LnB1YmtleSxcbiAgICAgICAgICBhbW91bnQ6IHRoaXMuYW1vdW50XG4gICAgICAgIH1cbiAgICAgIF07XG4gICAgfVxuICAgIGNvbnN0IHphcFRhZ3MgPSB0aGlzLnRhcmdldC5nZXRNYXRjaGluZ1RhZ3MoXCJ6YXBcIik7XG4gICAgaWYgKHphcFRhZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICB7XG4gICAgICAgICAgcHVia2V5OiB0aGlzLnRhcmdldC5wdWJrZXksXG4gICAgICAgICAgYW1vdW50OiB0aGlzLmFtb3VudFxuICAgICAgICB9XG4gICAgICBdO1xuICAgIH1cbiAgICBjb25zdCBzcGxpdHMgPSBbXTtcbiAgICBjb25zdCB0b3RhbCA9IHphcFRhZ3MucmVkdWNlKChhY2MsIHRhZykgPT4gYWNjICsgcGFyc2VJbnQodGFnWzJdKSwgMCk7XG4gICAgZm9yIChjb25zdCB0YWcgb2YgemFwVGFncykge1xuICAgICAgY29uc3QgcHVia2V5ID0gdGFnWzFdO1xuICAgICAgY29uc3QgYW1vdW50ID0gTWF0aC5mbG9vcihwYXJzZUludCh0YWdbMl0pIC8gdG90YWwgKiB0aGlzLmFtb3VudCk7XG4gICAgICBzcGxpdHMucHVzaCh7IHB1YmtleSwgYW1vdW50IH0pO1xuICAgIH1cbiAgICByZXR1cm4gc3BsaXRzO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSB6YXAgbWV0aG9kIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gemFwIGEgcHViYmtleVxuICAgKiBAcGFyYW0gbmRrXG4gICAqIEBwYXJhbSBwdWJrZXlcbiAgICogQHJldHVybnNcbiAgICovXG4gIGFzeW5jIGdldFphcE1ldGhvZHMobmRrLCByZWNpcGllbnQsIHRpbWVvdXQgPSAyNTAwKSB7XG4gICAgY29uc3QgdXNlciA9IG5kay5nZXRVc2VyKHsgcHVia2V5OiByZWNpcGllbnQgfSk7XG4gICAgcmV0dXJuIGF3YWl0IHVzZXIuZ2V0WmFwSW5mbyh0aW1lb3V0KTtcbiAgfVxuICAvKipcbiAgICogQHJldHVybnMgdGhlIHJlbGF5cyB0byB1c2UgZm9yIHRoZSB6YXAgcmVxdWVzdFxuICAgKi9cbiAgYXN5bmMgcmVsYXlzKHB1YmtleSkge1xuICAgIGxldCByID0gW107XG4gICAgaWYgKHRoaXMubmRrPy5hY3RpdmVVc2VyKSB7XG4gICAgICBjb25zdCByZWxheUxpc3RzID0gYXdhaXQgZ2V0UmVsYXlMaXN0Rm9yVXNlcnMoXG4gICAgICAgIFt0aGlzLm5kay5hY3RpdmVVc2VyLnB1YmtleSwgcHVia2V5XSxcbiAgICAgICAgdGhpcy5uZGtcbiAgICAgICk7XG4gICAgICBjb25zdCByZWxheVNjb3JlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBmb3IgKGNvbnN0IHJlbGF5TGlzdCBvZiByZWxheUxpc3RzLnZhbHVlcygpKSB7XG4gICAgICAgIGZvciAoY29uc3QgdXJsIG9mIHJlbGF5TGlzdC5yZWFkUmVsYXlVcmxzKSB7XG4gICAgICAgICAgY29uc3Qgc2NvcmUgPSByZWxheVNjb3Jlcy5nZXQodXJsKSB8fCAwO1xuICAgICAgICAgIHJlbGF5U2NvcmVzLnNldCh1cmwsIHNjb3JlICsgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHIgPSBBcnJheS5mcm9tKHJlbGF5U2NvcmVzLmVudHJpZXMoKSkuc29ydCgoYSwgYikgPT4gYlsxXSAtIGFbMV0pLm1hcCgoW3VybF0pID0+IHVybCkuc2xpY2UoMCwgdGhpcy5tYXhSZWxheXMpO1xuICAgIH1cbiAgICBpZiAodGhpcy5uZGs/LnBvb2w/LnBlcm1hbmVudEFuZENvbm5lY3RlZFJlbGF5cygpLmxlbmd0aCkge1xuICAgICAgciA9IHRoaXMubmRrLnBvb2wucGVybWFuZW50QW5kQ29ubmVjdGVkUmVsYXlzKCkubWFwKChyZWxheSkgPT4gcmVsYXkudXJsKTtcbiAgICB9XG4gICAgaWYgKCFyLmxlbmd0aCkge1xuICAgICAgciA9IFtdO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzL2ZpbHRlci50c1xuZnVuY3Rpb24gbWF0Y2hGaWx0ZXIoZmlsdGVyLCBldmVudCkge1xuICBpZiAoZmlsdGVyLmlkcyAmJiBmaWx0ZXIuaWRzLmluZGV4T2YoZXZlbnQuaWQpID09PSAtMSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZmlsdGVyLmtpbmRzICYmIGZpbHRlci5raW5kcy5pbmRleE9mKGV2ZW50LmtpbmQpID09PSAtMSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZmlsdGVyLmF1dGhvcnMgJiYgZmlsdGVyLmF1dGhvcnMuaW5kZXhPZihldmVudC5wdWJrZXkpID09PSAtMSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBmIGluIGZpbHRlcikge1xuICAgIGlmIChmWzBdID09PSBcIiNcIikge1xuICAgICAgbGV0IHRhZ05hbWUgPSBmLnNsaWNlKDEpO1xuICAgICAgaWYgKHRhZ05hbWUgPT09IFwidFwiKSB7XG4gICAgICAgIGxldCB2YWx1ZXMgPSBmaWx0ZXJbYCMke3RhZ05hbWV9YF0/Lm1hcCgodikgPT4gdi50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgaWYgKHZhbHVlcyAmJiAhZXZlbnQudGFncy5maW5kKChbdCwgdl0pID0+IHQgPT09IHRhZ05hbWUgJiYgdmFsdWVzLmluZGV4T2Yodi50b0xvd2VyQ2FzZSgpKSAhPT0gLTEpKSByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgdmFsdWVzID0gZmlsdGVyW2AjJHt0YWdOYW1lfWBdO1xuICAgICAgICBpZiAodmFsdWVzICYmICFldmVudC50YWdzLmZpbmQoKFt0LCB2XSkgPT4gdCA9PT0gdGFnTmFtZSAmJiB2YWx1ZXMuaW5kZXhPZih2KSAhPT0gLTEpKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChmaWx0ZXIuc2luY2UgJiYgZXZlbnQuY3JlYXRlZF9hdCA8IGZpbHRlci5zaW5jZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoZmlsdGVyLnVudGlsICYmIGV2ZW50LmNyZWF0ZWRfYXQgPiBmaWx0ZXIudW50aWwpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHRydWU7XG59XG5leHBvcnQge1xuICBCRUNIMzJfUkVHRVgsXG4gIE5ES0FwcEhhbmRsZXJFdmVudCxcbiAgTkRLQXBwU2V0dGluZ3MsXG4gIE5ES0FydGljbGUsXG4gIE5ES0Nhc2h1TWludExpc3QsXG4gIE5ES0Nhc2h1VG9rZW4sXG4gIE5ES0Nhc2h1V2FsbGV0VHgsXG4gIE5ES0NsYXNzaWZpZWQsXG4gIE5ES0RWTUpvYkZlZWRiYWNrLFxuICBOREtEVk1Kb2JSZXN1bHQsXG4gIE5ES0RWTVJlcXVlc3QsXG4gIE5ES0RyYWZ0LFxuICBOREtEdm1Kb2JGZWVkYmFja1N0YXR1cyxcbiAgTkRLRXZlbnQsXG4gIE5ES0hpZ2hsaWdodCxcbiAgTkRLSW1hZ2UsXG4gIE5ES0tpbmQsXG4gIE5ES0xpc3QsXG4gIE5ES0xpc3RLaW5kcyxcbiAgTkRLTmlwMDdTaWduZXIsXG4gIE5ES05pcDQ2QmFja2VuZCxcbiAgTkRLTmlwNDZTaWduZXIsXG4gIE5ES05vc3RyUnBjLFxuICBOREtOdXR6YXAsXG4gIE5ES1Bvb2wsXG4gIE5ES1ByaXZhdGVLZXlTaWduZXIsXG4gIE5ES1B1Ymxpc2hFcnJvcixcbiAgTkRLUmVsYXksXG4gIE5ES1JlbGF5QXV0aFBvbGljaWVzLFxuICBOREtSZWxheUxpc3QsXG4gIE5ES1JlbGF5U2V0LFxuICBOREtSZWxheVN0YXR1cyxcbiAgTkRLUmVwb3N0LFxuICBOREtTaW1wbGVHcm91cCxcbiAgTkRLU2ltcGxlR3JvdXBNZW1iZXJMaXN0LFxuICBOREtTaW1wbGVHcm91cE1ldGFkYXRhLFxuICBOREtTdWJzY3JpcHRpb24sXG4gIE5ES1N1YnNjcmlwdGlvbkNhY2hlVXNhZ2UsXG4gIE5ES1N1YnNjcmlwdGlvblJlY2VpcHQsXG4gIE5ES1N1YnNjcmlwdGlvblN0YXJ0LFxuICBOREtTdWJzY3JpcHRpb25UaWVyLFxuICBOREtUcmFuc2NyaXB0aW9uRFZNLFxuICBOREtVc2VyLFxuICBOREtWaWRlbyxcbiAgTkRLV2lraSxcbiAgTkRLWmFwcGVyLFxuICBOSVAzM19BX1JFR0VYLFxuICBjYWxjdWxhdGVSZWxheVNldEZyb21FdmVudCxcbiAgY2FsY3VsYXRlVGVybUR1cmF0aW9uSW5TZWNvbmRzLFxuICBjb21wYXJlRmlsdGVyLFxuICBOREsgYXMgZGVmYXVsdCxcbiAgZGVmYXVsdE9wdHMsXG4gIGRlc2VyaWFsaXplLFxuICBkdm1TY2hlZHVsZSxcbiAgZXZlbnRIYXNFVGFnTWFya2VycyxcbiAgZXZlbnRJc1BhcnRPZlRocmVhZCxcbiAgZXZlbnRJc1JlcGx5LFxuICBldmVudFJlcGxpZXMsXG4gIGV2ZW50VGhyZWFkSWRzLFxuICBldmVudFRocmVhZHMsXG4gIGV2ZW50c0J5U2FtZUF1dGhvcixcbiAgZmlsdGVyQW5kUmVsYXlTZXRGcm9tQmVjaDMyLFxuICBmaWx0ZXJGaW5nZXJwcmludCxcbiAgZmlsdGVyRm9yRXZlbnRzVGFnZ2luZ0lkLFxuICBmaWx0ZXJGcm9tSWQsXG4gIGdlbmVyYXRlQ29udGVudFRhZ3MsXG4gIGdlbmVyYXRlSGFzaHRhZ3MsXG4gIGdlbmVyYXRlU3ViSWQsXG4gIGdlbmVyYXRlWmFwUmVxdWVzdCxcbiAgZ2V0RXZlbnRSZXBseUlkLFxuICBnZXROaXA1N1phcFNwZWNGcm9tTHVkLFxuICBnZXRSZWxheUxpc3RGb3JVc2VyLFxuICBnZXRSZWxheUxpc3RGb3JVc2VycyxcbiAgZ2V0UmVwbHlUYWcsXG4gIGdldFJvb3RFdmVudElkLFxuICBnZXRSb290VGFnLFxuICBpbWV0YVRhZ1RvVGFnLFxuICBpc0V2ZW50T3JpZ2luYWxQb3N0LFxuICBpc05pcDMzQVZhbHVlLFxuICBtYXBJbWV0YVRhZyxcbiAgbWF0Y2hGaWx0ZXIsXG4gIG1lcmdlRmlsdGVycyxcbiAgbWVyZ2VUYWdzLFxuICBuZXdBbW91bnQsXG4gIG5vcm1hbGl6ZSxcbiAgbm9ybWFsaXplUmVsYXlVcmwsXG4gIG5vcm1hbGl6ZVVybCxcbiAgcGFyc2VUYWdUb1N1YnNjcmlwdGlvbkFtb3VudCxcbiAgcGluRXZlbnQsXG4gIHBvc3NpYmxlSW50ZXJ2YWxGcmVxdWVuY2llcyxcbiAgcHJvZmlsZUZyb21FdmVudCxcbiAgcHJvb2ZQMnBrLFxuICBwcm9vZlAycGtOb3N0cixcbiAgcHJvb2ZzVG90YWxCYWxhbmNlLFxuICBxdWVyeUZ1bGx5RmlsbGVkLFxuICByZWxheUxpc3RGcm9tS2luZDMsXG4gIHJlbGF5c0Zyb21CZWNoMzIsXG4gIHNlcmlhbGl6ZSxcbiAgc2VyaWFsaXplUHJvZmlsZSxcbiAgdHJ5Tm9ybWFsaXplUmVsYXlVcmwsXG4gIHVuaXF1ZVRhZyxcbiAgd3JhcEV2ZW50LFxuICB6YXBJbnZvaWNlRnJvbUV2ZW50XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/lib/esm/index.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/lib/esm/index.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Relay: () => (/* binding */ Relay),\n/* harmony export */   SimplePool: () => (/* binding */ SimplePool),\n/* harmony export */   finalizeEvent: () => (/* binding */ finalizeEvent),\n/* harmony export */   fj: () => (/* binding */ fakejson_exports),\n/* harmony export */   generateSecretKey: () => (/* binding */ generateSecretKey),\n/* harmony export */   getEventHash: () => (/* binding */ getEventHash),\n/* harmony export */   getFilterLimit: () => (/* binding */ getFilterLimit),\n/* harmony export */   getPublicKey: () => (/* binding */ getPublicKey),\n/* harmony export */   kinds: () => (/* binding */ kinds_exports),\n/* harmony export */   matchFilter: () => (/* binding */ matchFilter),\n/* harmony export */   matchFilters: () => (/* binding */ matchFilters),\n/* harmony export */   mergeFilters: () => (/* binding */ mergeFilters),\n/* harmony export */   nip04: () => (/* binding */ nip04_exports),\n/* harmony export */   nip05: () => (/* binding */ nip05_exports),\n/* harmony export */   nip10: () => (/* binding */ nip10_exports),\n/* harmony export */   nip11: () => (/* binding */ nip11_exports),\n/* harmony export */   nip13: () => (/* binding */ nip13_exports),\n/* harmony export */   nip18: () => (/* binding */ nip18_exports),\n/* harmony export */   nip19: () => (/* binding */ nip19_exports),\n/* harmony export */   nip21: () => (/* binding */ nip21_exports),\n/* harmony export */   nip25: () => (/* binding */ nip25_exports),\n/* harmony export */   nip27: () => (/* binding */ nip27_exports),\n/* harmony export */   nip28: () => (/* binding */ nip28_exports),\n/* harmony export */   nip30: () => (/* binding */ nip30_exports),\n/* harmony export */   nip39: () => (/* binding */ nip39_exports),\n/* harmony export */   nip42: () => (/* binding */ nip42_exports),\n/* harmony export */   nip44: () => (/* binding */ nip44_exports),\n/* harmony export */   nip47: () => (/* binding */ nip47_exports),\n/* harmony export */   nip57: () => (/* binding */ nip57_exports),\n/* harmony export */   nip59: () => (/* binding */ nip59_exports),\n/* harmony export */   nip98: () => (/* binding */ nip98_exports),\n/* harmony export */   parseReferences: () => (/* binding */ parseReferences),\n/* harmony export */   serializeEvent: () => (/* binding */ serializeEvent),\n/* harmony export */   sortEvents: () => (/* binding */ sortEvents),\n/* harmony export */   utils: () => (/* binding */ utils_exports),\n/* harmony export */   validateEvent: () => (/* binding */ validateEvent),\n/* harmony export */   verifiedSymbol: () => (/* binding */ verifiedSymbol),\n/* harmony export */   verifyEvent: () => (/* binding */ verifyEvent)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/secp256k1.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _scure_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @scure/base */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@scure/base/lib/esm/index.js\");\n/* harmony import */ var _noble_ciphers_aes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/ciphers/aes */ \"(ssr)/./node_modules/@noble/ciphers/esm/aes.js\");\n/* harmony import */ var _noble_ciphers_chacha__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @noble/ciphers/chacha */ \"(ssr)/./node_modules/@noble/ciphers/esm/chacha.js\");\n/* harmony import */ var _noble_ciphers_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @noble/ciphers/utils */ \"(ssr)/./node_modules/@noble/ciphers/esm/utils.js\");\n/* harmony import */ var _noble_hashes_hkdf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @noble/hashes/hkdf */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/hkdf.js\");\n/* harmony import */ var _noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @noble/hashes/hmac */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/hmac.js\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// pure.ts\n\n\n\n// core.ts\nvar verifiedSymbol = Symbol(\"verified\");\nvar isRecord = (obj) => obj instanceof Object;\nfunction validateEvent(event) {\n  if (!isRecord(event))\n    return false;\n  if (typeof event.kind !== \"number\")\n    return false;\n  if (typeof event.content !== \"string\")\n    return false;\n  if (typeof event.created_at !== \"number\")\n    return false;\n  if (typeof event.pubkey !== \"string\")\n    return false;\n  if (!event.pubkey.match(/^[a-f0-9]{64}$/))\n    return false;\n  if (!Array.isArray(event.tags))\n    return false;\n  for (let i2 = 0; i2 < event.tags.length; i2++) {\n    let tag = event.tags[i2];\n    if (!Array.isArray(tag))\n      return false;\n    for (let j = 0; j < tag.length; j++) {\n      if (typeof tag[j] === \"object\")\n        return false;\n    }\n  }\n  return true;\n}\nfunction sortEvents(events) {\n  return events.sort((a, b) => {\n    if (a.created_at !== b.created_at) {\n      return b.created_at - a.created_at;\n    }\n    return a.id.localeCompare(b.id);\n  });\n}\n\n// pure.ts\n\n\n// utils.ts\nvar utils_exports = {};\n__export(utils_exports, {\n  Queue: () => Queue,\n  QueueNode: () => QueueNode,\n  binarySearch: () => binarySearch,\n  insertEventIntoAscendingList: () => insertEventIntoAscendingList,\n  insertEventIntoDescendingList: () => insertEventIntoDescendingList,\n  normalizeURL: () => normalizeURL,\n  utf8Decoder: () => utf8Decoder,\n  utf8Encoder: () => utf8Encoder\n});\nvar utf8Decoder = new TextDecoder(\"utf-8\");\nvar utf8Encoder = new TextEncoder();\nfunction normalizeURL(url) {\n  if (url.indexOf(\"://\") === -1)\n    url = \"wss://\" + url;\n  let p = new URL(url);\n  p.pathname = p.pathname.replace(/\\/+/g, \"/\");\n  if (p.pathname.endsWith(\"/\"))\n    p.pathname = p.pathname.slice(0, -1);\n  if (p.port === \"80\" && p.protocol === \"ws:\" || p.port === \"443\" && p.protocol === \"wss:\")\n    p.port = \"\";\n  p.searchParams.sort();\n  p.hash = \"\";\n  return p.toString();\n}\nfunction insertEventIntoDescendingList(sortedArray, event) {\n  const [idx, found] = binarySearch(sortedArray, (b) => {\n    if (event.id === b.id)\n      return 0;\n    if (event.created_at === b.created_at)\n      return -1;\n    return b.created_at - event.created_at;\n  });\n  if (!found) {\n    sortedArray.splice(idx, 0, event);\n  }\n  return sortedArray;\n}\nfunction insertEventIntoAscendingList(sortedArray, event) {\n  const [idx, found] = binarySearch(sortedArray, (b) => {\n    if (event.id === b.id)\n      return 0;\n    if (event.created_at === b.created_at)\n      return -1;\n    return event.created_at - b.created_at;\n  });\n  if (!found) {\n    sortedArray.splice(idx, 0, event);\n  }\n  return sortedArray;\n}\nfunction binarySearch(arr, compare) {\n  let start = 0;\n  let end = arr.length - 1;\n  while (start <= end) {\n    const mid = Math.floor((start + end) / 2);\n    const cmp = compare(arr[mid]);\n    if (cmp === 0) {\n      return [mid, true];\n    }\n    if (cmp < 0) {\n      end = mid - 1;\n    } else {\n      start = mid + 1;\n    }\n  }\n  return [start, false];\n}\nvar QueueNode = class {\n  value;\n  next = null;\n  prev = null;\n  constructor(message) {\n    this.value = message;\n  }\n};\nvar Queue = class {\n  first;\n  last;\n  constructor() {\n    this.first = null;\n    this.last = null;\n  }\n  enqueue(value) {\n    const newNode = new QueueNode(value);\n    if (!this.last) {\n      this.first = newNode;\n      this.last = newNode;\n    } else if (this.last === this.first) {\n      this.last = newNode;\n      this.last.prev = this.first;\n      this.first.next = newNode;\n    } else {\n      newNode.prev = this.last;\n      this.last.next = newNode;\n      this.last = newNode;\n    }\n    return true;\n  }\n  dequeue() {\n    if (!this.first)\n      return null;\n    if (this.first === this.last) {\n      const target2 = this.first;\n      this.first = null;\n      this.last = null;\n      return target2.value;\n    }\n    const target = this.first;\n    this.first = target.next;\n    return target.value;\n  }\n};\n\n// pure.ts\nvar JS = class {\n  generateSecretKey() {\n    return _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.schnorr.utils.randomPrivateKey();\n  }\n  getPublicKey(secretKey) {\n    return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.schnorr.getPublicKey(secretKey));\n  }\n  finalizeEvent(t, secretKey) {\n    const event = t;\n    event.pubkey = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.schnorr.getPublicKey(secretKey));\n    event.id = getEventHash(event);\n    event.sig = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.schnorr.sign(getEventHash(event), secretKey));\n    event[verifiedSymbol] = true;\n    return event;\n  }\n  verifyEvent(event) {\n    if (typeof event[verifiedSymbol] === \"boolean\")\n      return event[verifiedSymbol];\n    const hash = getEventHash(event);\n    if (hash !== event.id) {\n      event[verifiedSymbol] = false;\n      return false;\n    }\n    try {\n      const valid = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.schnorr.verify(event.sig, hash, event.pubkey);\n      event[verifiedSymbol] = valid;\n      return valid;\n    } catch (err) {\n      event[verifiedSymbol] = false;\n      return false;\n    }\n  }\n};\nfunction serializeEvent(evt) {\n  if (!validateEvent(evt))\n    throw new Error(\"can't serialize event with wrong or missing properties\");\n  return JSON.stringify([0, evt.pubkey, evt.created_at, evt.kind, evt.tags, evt.content]);\n}\nfunction getEventHash(event) {\n  let eventHash = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_1__.sha256)(utf8Encoder.encode(serializeEvent(event)));\n  return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(eventHash);\n}\nvar i = new JS();\nvar generateSecretKey = i.generateSecretKey;\nvar getPublicKey = i.getPublicKey;\nvar finalizeEvent = i.finalizeEvent;\nvar verifyEvent = i.verifyEvent;\n\n// kinds.ts\nvar kinds_exports = {};\n__export(kinds_exports, {\n  Application: () => Application,\n  BadgeAward: () => BadgeAward,\n  BadgeDefinition: () => BadgeDefinition,\n  BlockedRelaysList: () => BlockedRelaysList,\n  BookmarkList: () => BookmarkList,\n  Bookmarksets: () => Bookmarksets,\n  Calendar: () => Calendar,\n  CalendarEventRSVP: () => CalendarEventRSVP,\n  ChannelCreation: () => ChannelCreation,\n  ChannelHideMessage: () => ChannelHideMessage,\n  ChannelMessage: () => ChannelMessage,\n  ChannelMetadata: () => ChannelMetadata,\n  ChannelMuteUser: () => ChannelMuteUser,\n  ClassifiedListing: () => ClassifiedListing,\n  ClientAuth: () => ClientAuth,\n  CommunitiesList: () => CommunitiesList,\n  CommunityDefinition: () => CommunityDefinition,\n  CommunityPostApproval: () => CommunityPostApproval,\n  Contacts: () => Contacts,\n  CreateOrUpdateProduct: () => CreateOrUpdateProduct,\n  CreateOrUpdateStall: () => CreateOrUpdateStall,\n  Curationsets: () => Curationsets,\n  Date: () => Date2,\n  DirectMessageRelaysList: () => DirectMessageRelaysList,\n  DraftClassifiedListing: () => DraftClassifiedListing,\n  DraftLong: () => DraftLong,\n  Emojisets: () => Emojisets,\n  EncryptedDirectMessage: () => EncryptedDirectMessage,\n  EventDeletion: () => EventDeletion,\n  FileMetadata: () => FileMetadata,\n  FileServerPreference: () => FileServerPreference,\n  Followsets: () => Followsets,\n  GenericRepost: () => GenericRepost,\n  Genericlists: () => Genericlists,\n  GiftWrap: () => GiftWrap,\n  HTTPAuth: () => HTTPAuth,\n  Handlerinformation: () => Handlerinformation,\n  Handlerrecommendation: () => Handlerrecommendation,\n  Highlights: () => Highlights,\n  InterestsList: () => InterestsList,\n  Interestsets: () => Interestsets,\n  JobFeedback: () => JobFeedback,\n  JobRequest: () => JobRequest,\n  JobResult: () => JobResult,\n  Label: () => Label,\n  LightningPubRPC: () => LightningPubRPC,\n  LiveChatMessage: () => LiveChatMessage,\n  LiveEvent: () => LiveEvent,\n  LongFormArticle: () => LongFormArticle,\n  Metadata: () => Metadata,\n  Mutelist: () => Mutelist,\n  NWCWalletInfo: () => NWCWalletInfo,\n  NWCWalletRequest: () => NWCWalletRequest,\n  NWCWalletResponse: () => NWCWalletResponse,\n  NostrConnect: () => NostrConnect,\n  OpenTimestamps: () => OpenTimestamps,\n  Pinlist: () => Pinlist,\n  PrivateDirectMessage: () => PrivateDirectMessage,\n  ProblemTracker: () => ProblemTracker,\n  ProfileBadges: () => ProfileBadges,\n  PublicChatsList: () => PublicChatsList,\n  Reaction: () => Reaction,\n  RecommendRelay: () => RecommendRelay,\n  RelayList: () => RelayList,\n  Relaysets: () => Relaysets,\n  Report: () => Report,\n  Reporting: () => Reporting,\n  Repost: () => Repost,\n  Seal: () => Seal,\n  SearchRelaysList: () => SearchRelaysList,\n  ShortTextNote: () => ShortTextNote,\n  Time: () => Time,\n  UserEmojiList: () => UserEmojiList,\n  UserStatuses: () => UserStatuses,\n  Zap: () => Zap,\n  ZapGoal: () => ZapGoal,\n  ZapRequest: () => ZapRequest,\n  classifyKind: () => classifyKind,\n  isEphemeralKind: () => isEphemeralKind,\n  isKind: () => isKind,\n  isParameterizedReplaceableKind: () => isParameterizedReplaceableKind,\n  isRegularKind: () => isRegularKind,\n  isReplaceableKind: () => isReplaceableKind\n});\nfunction isRegularKind(kind) {\n  return 1e3 <= kind && kind < 1e4 || [1, 2, 4, 5, 6, 7, 8, 16, 40, 41, 42, 43, 44].includes(kind);\n}\nfunction isReplaceableKind(kind) {\n  return [0, 3].includes(kind) || 1e4 <= kind && kind < 2e4;\n}\nfunction isEphemeralKind(kind) {\n  return 2e4 <= kind && kind < 3e4;\n}\nfunction isParameterizedReplaceableKind(kind) {\n  return 3e4 <= kind && kind < 4e4;\n}\nfunction classifyKind(kind) {\n  if (isRegularKind(kind))\n    return \"regular\";\n  if (isReplaceableKind(kind))\n    return \"replaceable\";\n  if (isEphemeralKind(kind))\n    return \"ephemeral\";\n  if (isParameterizedReplaceableKind(kind))\n    return \"parameterized\";\n  return \"unknown\";\n}\nfunction isKind(event, kind) {\n  const kindAsArray = kind instanceof Array ? kind : [kind];\n  return validateEvent(event) && kindAsArray.includes(event.kind) || false;\n}\nvar Metadata = 0;\nvar ShortTextNote = 1;\nvar RecommendRelay = 2;\nvar Contacts = 3;\nvar EncryptedDirectMessage = 4;\nvar EventDeletion = 5;\nvar Repost = 6;\nvar Reaction = 7;\nvar BadgeAward = 8;\nvar Seal = 13;\nvar PrivateDirectMessage = 14;\nvar GenericRepost = 16;\nvar ChannelCreation = 40;\nvar ChannelMetadata = 41;\nvar ChannelMessage = 42;\nvar ChannelHideMessage = 43;\nvar ChannelMuteUser = 44;\nvar OpenTimestamps = 1040;\nvar GiftWrap = 1059;\nvar FileMetadata = 1063;\nvar LiveChatMessage = 1311;\nvar ProblemTracker = 1971;\nvar Report = 1984;\nvar Reporting = 1984;\nvar Label = 1985;\nvar CommunityPostApproval = 4550;\nvar JobRequest = 5999;\nvar JobResult = 6999;\nvar JobFeedback = 7e3;\nvar ZapGoal = 9041;\nvar ZapRequest = 9734;\nvar Zap = 9735;\nvar Highlights = 9802;\nvar Mutelist = 1e4;\nvar Pinlist = 10001;\nvar RelayList = 10002;\nvar BookmarkList = 10003;\nvar CommunitiesList = 10004;\nvar PublicChatsList = 10005;\nvar BlockedRelaysList = 10006;\nvar SearchRelaysList = 10007;\nvar InterestsList = 10015;\nvar UserEmojiList = 10030;\nvar DirectMessageRelaysList = 10050;\nvar FileServerPreference = 10096;\nvar NWCWalletInfo = 13194;\nvar LightningPubRPC = 21e3;\nvar ClientAuth = 22242;\nvar NWCWalletRequest = 23194;\nvar NWCWalletResponse = 23195;\nvar NostrConnect = 24133;\nvar HTTPAuth = 27235;\nvar Followsets = 3e4;\nvar Genericlists = 30001;\nvar Relaysets = 30002;\nvar Bookmarksets = 30003;\nvar Curationsets = 30004;\nvar ProfileBadges = 30008;\nvar BadgeDefinition = 30009;\nvar Interestsets = 30015;\nvar CreateOrUpdateStall = 30017;\nvar CreateOrUpdateProduct = 30018;\nvar LongFormArticle = 30023;\nvar DraftLong = 30024;\nvar Emojisets = 30030;\nvar Application = 30078;\nvar LiveEvent = 30311;\nvar UserStatuses = 30315;\nvar ClassifiedListing = 30402;\nvar DraftClassifiedListing = 30403;\nvar Date2 = 31922;\nvar Time = 31923;\nvar Calendar = 31924;\nvar CalendarEventRSVP = 31925;\nvar Handlerrecommendation = 31989;\nvar Handlerinformation = 31990;\nvar CommunityDefinition = 34550;\n\n// filter.ts\nfunction matchFilter(filter, event) {\n  if (filter.ids && filter.ids.indexOf(event.id) === -1) {\n    return false;\n  }\n  if (filter.kinds && filter.kinds.indexOf(event.kind) === -1) {\n    return false;\n  }\n  if (filter.authors && filter.authors.indexOf(event.pubkey) === -1) {\n    return false;\n  }\n  for (let f in filter) {\n    if (f[0] === \"#\") {\n      let tagName = f.slice(1);\n      let values = filter[`#${tagName}`];\n      if (values && !event.tags.find(([t, v]) => t === f.slice(1) && values.indexOf(v) !== -1))\n        return false;\n    }\n  }\n  if (filter.since && event.created_at < filter.since)\n    return false;\n  if (filter.until && event.created_at > filter.until)\n    return false;\n  return true;\n}\nfunction matchFilters(filters, event) {\n  for (let i2 = 0; i2 < filters.length; i2++) {\n    if (matchFilter(filters[i2], event)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction mergeFilters(...filters) {\n  let result = {};\n  for (let i2 = 0; i2 < filters.length; i2++) {\n    let filter = filters[i2];\n    Object.entries(filter).forEach(([property, values]) => {\n      if (property === \"kinds\" || property === \"ids\" || property === \"authors\" || property[0] === \"#\") {\n        result[property] = result[property] || [];\n        for (let v = 0; v < values.length; v++) {\n          let value = values[v];\n          if (!result[property].includes(value))\n            result[property].push(value);\n        }\n      }\n    });\n    if (filter.limit && (!result.limit || filter.limit > result.limit))\n      result.limit = filter.limit;\n    if (filter.until && (!result.until || filter.until > result.until))\n      result.until = filter.until;\n    if (filter.since && (!result.since || filter.since < result.since))\n      result.since = filter.since;\n  }\n  return result;\n}\nfunction getFilterLimit(filter) {\n  if (filter.ids && !filter.ids.length)\n    return 0;\n  if (filter.kinds && !filter.kinds.length)\n    return 0;\n  if (filter.authors && !filter.authors.length)\n    return 0;\n  for (const [key, value] of Object.entries(filter)) {\n    if (key[0] === \"#\" && Array.isArray(value) && !value.length)\n      return 0;\n  }\n  return Math.min(\n    Math.max(0, filter.limit ?? Infinity),\n    filter.ids?.length ?? Infinity,\n    filter.authors?.length && filter.kinds?.every((kind) => isReplaceableKind(kind)) ? filter.authors.length * filter.kinds.length : Infinity,\n    filter.authors?.length && filter.kinds?.every((kind) => isParameterizedReplaceableKind(kind)) && filter[\"#d\"]?.length ? filter.authors.length * filter.kinds.length * filter[\"#d\"].length : Infinity\n  );\n}\n\n// fakejson.ts\nvar fakejson_exports = {};\n__export(fakejson_exports, {\n  getHex64: () => getHex64,\n  getInt: () => getInt,\n  getSubscriptionId: () => getSubscriptionId,\n  matchEventId: () => matchEventId,\n  matchEventKind: () => matchEventKind,\n  matchEventPubkey: () => matchEventPubkey\n});\nfunction getHex64(json, field) {\n  let len = field.length + 3;\n  let idx = json.indexOf(`\"${field}\":`) + len;\n  let s = json.slice(idx).indexOf(`\"`) + idx + 1;\n  return json.slice(s, s + 64);\n}\nfunction getInt(json, field) {\n  let len = field.length;\n  let idx = json.indexOf(`\"${field}\":`) + len + 3;\n  let sliced = json.slice(idx);\n  let end = Math.min(sliced.indexOf(\",\"), sliced.indexOf(\"}\"));\n  return parseInt(sliced.slice(0, end), 10);\n}\nfunction getSubscriptionId(json) {\n  let idx = json.slice(0, 22).indexOf(`\"EVENT\"`);\n  if (idx === -1)\n    return null;\n  let pstart = json.slice(idx + 7 + 1).indexOf(`\"`);\n  if (pstart === -1)\n    return null;\n  let start = idx + 7 + 1 + pstart;\n  let pend = json.slice(start + 1, 80).indexOf(`\"`);\n  if (pend === -1)\n    return null;\n  let end = start + 1 + pend;\n  return json.slice(start + 1, end);\n}\nfunction matchEventId(json, id) {\n  return id === getHex64(json, \"id\");\n}\nfunction matchEventPubkey(json, pubkey) {\n  return pubkey === getHex64(json, \"pubkey\");\n}\nfunction matchEventKind(json, kind) {\n  return kind === getInt(json, \"kind\");\n}\n\n// nip42.ts\nvar nip42_exports = {};\n__export(nip42_exports, {\n  makeAuthEvent: () => makeAuthEvent\n});\nfunction makeAuthEvent(relayURL, challenge) {\n  return {\n    kind: ClientAuth,\n    created_at: Math.floor(Date.now() / 1e3),\n    tags: [\n      [\"relay\", relayURL],\n      [\"challenge\", challenge]\n    ],\n    content: \"\"\n  };\n}\n\n// helpers.ts\nasync function yieldThread() {\n  return new Promise((resolve) => {\n    const ch = new MessageChannel();\n    const handler = () => {\n      ch.port1.removeEventListener(\"message\", handler);\n      resolve();\n    };\n    ch.port1.addEventListener(\"message\", handler);\n    ch.port2.postMessage(0);\n    ch.port1.start();\n  });\n}\nvar alwaysTrue = (t) => {\n  t[verifiedSymbol] = true;\n  return true;\n};\n\n// abstract-relay.ts\nvar AbstractRelay = class {\n  url;\n  _connected = false;\n  onclose = null;\n  onnotice = (msg) => console.debug(`NOTICE from ${this.url}: ${msg}`);\n  _onauth = null;\n  baseEoseTimeout = 4400;\n  connectionTimeout = 4400;\n  publishTimeout = 4400;\n  openSubs = /* @__PURE__ */ new Map();\n  connectionTimeoutHandle;\n  connectionPromise;\n  openCountRequests = /* @__PURE__ */ new Map();\n  openEventPublishes = /* @__PURE__ */ new Map();\n  ws;\n  incomingMessageQueue = new Queue();\n  queueRunning = false;\n  challenge;\n  serial = 0;\n  verifyEvent;\n  _WebSocket;\n  constructor(url, opts) {\n    this.url = normalizeURL(url);\n    this.verifyEvent = opts.verifyEvent;\n    this._WebSocket = opts.websocketImplementation || WebSocket;\n  }\n  static async connect(url, opts) {\n    const relay = new AbstractRelay(url, opts);\n    await relay.connect();\n    return relay;\n  }\n  closeAllSubscriptions(reason) {\n    for (let [_, sub] of this.openSubs) {\n      sub.close(reason);\n    }\n    this.openSubs.clear();\n    for (let [_, ep] of this.openEventPublishes) {\n      ep.reject(new Error(reason));\n    }\n    this.openEventPublishes.clear();\n    for (let [_, cr] of this.openCountRequests) {\n      cr.reject(new Error(reason));\n    }\n    this.openCountRequests.clear();\n  }\n  get connected() {\n    return this._connected;\n  }\n  async connect() {\n    if (this.connectionPromise)\n      return this.connectionPromise;\n    this.challenge = void 0;\n    this.connectionPromise = new Promise((resolve, reject) => {\n      this.connectionTimeoutHandle = setTimeout(() => {\n        reject(\"connection timed out\");\n        this.connectionPromise = void 0;\n        this.onclose?.();\n        this.closeAllSubscriptions(\"relay connection timed out\");\n      }, this.connectionTimeout);\n      try {\n        this.ws = new this._WebSocket(this.url);\n      } catch (err) {\n        reject(err);\n        return;\n      }\n      this.ws.onopen = () => {\n        clearTimeout(this.connectionTimeoutHandle);\n        this._connected = true;\n        resolve();\n      };\n      this.ws.onerror = (ev) => {\n        reject(ev.message || \"websocket error\");\n        if (this._connected) {\n          this._connected = false;\n          this.connectionPromise = void 0;\n          this.onclose?.();\n          this.closeAllSubscriptions(\"relay connection errored\");\n        }\n      };\n      this.ws.onclose = async () => {\n        if (this._connected) {\n          this._connected = false;\n          this.connectionPromise = void 0;\n          this.onclose?.();\n          this.closeAllSubscriptions(\"relay connection closed\");\n        }\n      };\n      this.ws.onmessage = this._onmessage.bind(this);\n    });\n    return this.connectionPromise;\n  }\n  async runQueue() {\n    this.queueRunning = true;\n    while (true) {\n      if (false === this.handleNext()) {\n        break;\n      }\n      await yieldThread();\n    }\n    this.queueRunning = false;\n  }\n  handleNext() {\n    const json = this.incomingMessageQueue.dequeue();\n    if (!json) {\n      return false;\n    }\n    const subid = getSubscriptionId(json);\n    if (subid) {\n      const so = this.openSubs.get(subid);\n      if (!so) {\n        return;\n      }\n      const id = getHex64(json, \"id\");\n      const alreadyHave = so.alreadyHaveEvent?.(id);\n      so.receivedEvent?.(this, id);\n      if (alreadyHave) {\n        return;\n      }\n    }\n    try {\n      let data = JSON.parse(json);\n      switch (data[0]) {\n        case \"EVENT\": {\n          const so = this.openSubs.get(data[1]);\n          const event = data[2];\n          if (this.verifyEvent(event) && matchFilters(so.filters, event)) {\n            so.onevent(event);\n          }\n          return;\n        }\n        case \"COUNT\": {\n          const id = data[1];\n          const payload = data[2];\n          const cr = this.openCountRequests.get(id);\n          if (cr) {\n            cr.resolve(payload.count);\n            this.openCountRequests.delete(id);\n          }\n          return;\n        }\n        case \"EOSE\": {\n          const so = this.openSubs.get(data[1]);\n          if (!so)\n            return;\n          so.receivedEose();\n          return;\n        }\n        case \"OK\": {\n          const id = data[1];\n          const ok = data[2];\n          const reason = data[3];\n          const ep = this.openEventPublishes.get(id);\n          if (ep) {\n            if (ok)\n              ep.resolve(reason);\n            else\n              ep.reject(new Error(reason));\n            this.openEventPublishes.delete(id);\n          }\n          return;\n        }\n        case \"CLOSED\": {\n          const id = data[1];\n          const so = this.openSubs.get(id);\n          if (!so)\n            return;\n          so.closed = true;\n          so.close(data[2]);\n          return;\n        }\n        case \"NOTICE\":\n          this.onnotice(data[1]);\n          return;\n        case \"AUTH\": {\n          this.challenge = data[1];\n          this._onauth?.(data[1]);\n          return;\n        }\n      }\n    } catch (err) {\n      return;\n    }\n  }\n  async send(message) {\n    if (!this.connectionPromise)\n      throw new Error(\"sending on closed connection\");\n    this.connectionPromise.then(() => {\n      this.ws?.send(message);\n    });\n  }\n  async auth(signAuthEvent) {\n    if (!this.challenge)\n      throw new Error(\"can't perform auth, no challenge was received\");\n    const evt = await signAuthEvent(makeAuthEvent(this.url, this.challenge));\n    const ret = new Promise((resolve, reject) => {\n      this.openEventPublishes.set(evt.id, { resolve, reject });\n    });\n    this.send('[\"AUTH\",' + JSON.stringify(evt) + \"]\");\n    return ret;\n  }\n  async publish(event) {\n    const ret = new Promise((resolve, reject) => {\n      this.openEventPublishes.set(event.id, { resolve, reject });\n    });\n    this.send('[\"EVENT\",' + JSON.stringify(event) + \"]\");\n    setTimeout(() => {\n      const ep = this.openEventPublishes.get(event.id);\n      if (ep) {\n        ep.reject(new Error(\"publish timed out\"));\n        this.openEventPublishes.delete(event.id);\n      }\n    }, this.publishTimeout);\n    return ret;\n  }\n  async count(filters, params) {\n    this.serial++;\n    const id = params?.id || \"count:\" + this.serial;\n    const ret = new Promise((resolve, reject) => {\n      this.openCountRequests.set(id, { resolve, reject });\n    });\n    this.send('[\"COUNT\",\"' + id + '\",' + JSON.stringify(filters).substring(1));\n    return ret;\n  }\n  subscribe(filters, params) {\n    const subscription = this.prepareSubscription(filters, params);\n    subscription.fire();\n    return subscription;\n  }\n  prepareSubscription(filters, params) {\n    this.serial++;\n    const id = params.id || \"sub:\" + this.serial;\n    const subscription = new Subscription(this, id, filters, params);\n    this.openSubs.set(id, subscription);\n    return subscription;\n  }\n  close() {\n    this.closeAllSubscriptions(\"relay connection closed by us\");\n    this._connected = false;\n    this.ws?.close();\n  }\n  _onmessage(ev) {\n    this.incomingMessageQueue.enqueue(ev.data);\n    if (!this.queueRunning) {\n      this.runQueue();\n    }\n  }\n};\nvar Subscription = class {\n  relay;\n  id;\n  closed = false;\n  eosed = false;\n  filters;\n  alreadyHaveEvent;\n  receivedEvent;\n  onevent;\n  oneose;\n  onclose;\n  eoseTimeout;\n  eoseTimeoutHandle;\n  constructor(relay, id, filters, params) {\n    this.relay = relay;\n    this.filters = filters;\n    this.id = id;\n    this.alreadyHaveEvent = params.alreadyHaveEvent;\n    this.receivedEvent = params.receivedEvent;\n    this.eoseTimeout = params.eoseTimeout || relay.baseEoseTimeout;\n    this.oneose = params.oneose;\n    this.onclose = params.onclose;\n    this.onevent = params.onevent || ((event) => {\n      console.warn(\n        `onevent() callback not defined for subscription '${this.id}' in relay ${this.relay.url}. event received:`,\n        event\n      );\n    });\n  }\n  fire() {\n    this.relay.send('[\"REQ\",\"' + this.id + '\",' + JSON.stringify(this.filters).substring(1));\n    this.eoseTimeoutHandle = setTimeout(this.receivedEose.bind(this), this.eoseTimeout);\n  }\n  receivedEose() {\n    if (this.eosed)\n      return;\n    clearTimeout(this.eoseTimeoutHandle);\n    this.eosed = true;\n    this.oneose?.();\n  }\n  close(reason = \"closed by caller\") {\n    if (!this.closed && this.relay.connected) {\n      this.relay.send('[\"CLOSE\",' + JSON.stringify(this.id) + \"]\");\n      this.closed = true;\n    }\n    this.relay.openSubs.delete(this.id);\n    this.onclose?.(reason);\n  }\n};\n\n// relay.ts\nvar _WebSocket;\ntry {\n  _WebSocket = WebSocket;\n} catch {\n}\nvar Relay = class extends AbstractRelay {\n  constructor(url) {\n    super(url, { verifyEvent, websocketImplementation: _WebSocket });\n  }\n  static async connect(url) {\n    const relay = new Relay(url);\n    await relay.connect();\n    return relay;\n  }\n};\n\n// abstract-pool.ts\nvar AbstractSimplePool = class {\n  relays = /* @__PURE__ */ new Map();\n  seenOn = /* @__PURE__ */ new Map();\n  trackRelays = false;\n  verifyEvent;\n  trustedRelayURLs = /* @__PURE__ */ new Set();\n  _WebSocket;\n  constructor(opts) {\n    this.verifyEvent = opts.verifyEvent;\n    this._WebSocket = opts.websocketImplementation;\n  }\n  async ensureRelay(url, params) {\n    url = normalizeURL(url);\n    let relay = this.relays.get(url);\n    if (!relay) {\n      relay = new AbstractRelay(url, {\n        verifyEvent: this.trustedRelayURLs.has(url) ? alwaysTrue : this.verifyEvent,\n        websocketImplementation: this._WebSocket\n      });\n      if (params?.connectionTimeout)\n        relay.connectionTimeout = params.connectionTimeout;\n      this.relays.set(url, relay);\n    }\n    await relay.connect();\n    return relay;\n  }\n  close(relays) {\n    relays.map(normalizeURL).forEach((url) => {\n      this.relays.get(url)?.close();\n    });\n  }\n  subscribeMany(relays, filters, params) {\n    return this.subscribeManyMap(Object.fromEntries(relays.map((url) => [url, filters])), params);\n  }\n  subscribeManyMap(requests, params) {\n    if (this.trackRelays) {\n      params.receivedEvent = (relay, id) => {\n        let set = this.seenOn.get(id);\n        if (!set) {\n          set = /* @__PURE__ */ new Set();\n          this.seenOn.set(id, set);\n        }\n        set.add(relay);\n      };\n    }\n    const _knownIds = /* @__PURE__ */ new Set();\n    const subs = [];\n    const relaysLength = Object.keys(requests).length;\n    const eosesReceived = [];\n    let handleEose = (i2) => {\n      eosesReceived[i2] = true;\n      if (eosesReceived.filter((a) => a).length === relaysLength) {\n        params.oneose?.();\n        handleEose = () => {\n        };\n      }\n    };\n    const closesReceived = [];\n    let handleClose = (i2, reason) => {\n      handleEose(i2);\n      closesReceived[i2] = reason;\n      if (closesReceived.filter((a) => a).length === relaysLength) {\n        params.onclose?.(closesReceived);\n        handleClose = () => {\n        };\n      }\n    };\n    const localAlreadyHaveEventHandler = (id) => {\n      if (params.alreadyHaveEvent?.(id)) {\n        return true;\n      }\n      const have = _knownIds.has(id);\n      _knownIds.add(id);\n      return have;\n    };\n    const allOpened = Promise.all(\n      Object.entries(requests).map(async (req, i2, arr) => {\n        if (arr.indexOf(req) !== i2) {\n          handleClose(i2, \"duplicate url\");\n          return;\n        }\n        let [url, filters] = req;\n        url = normalizeURL(url);\n        let relay;\n        try {\n          relay = await this.ensureRelay(url, {\n            connectionTimeout: params.maxWait ? Math.max(params.maxWait * 0.8, params.maxWait - 1e3) : void 0\n          });\n        } catch (err) {\n          handleClose(i2, err?.message || String(err));\n          return;\n        }\n        let subscription = relay.subscribe(filters, {\n          ...params,\n          oneose: () => handleEose(i2),\n          onclose: (reason) => handleClose(i2, reason),\n          alreadyHaveEvent: localAlreadyHaveEventHandler,\n          eoseTimeout: params.maxWait\n        });\n        subs.push(subscription);\n      })\n    );\n    return {\n      async close() {\n        await allOpened;\n        subs.forEach((sub) => {\n          sub.close();\n        });\n      }\n    };\n  }\n  subscribeManyEose(relays, filters, params) {\n    const subcloser = this.subscribeMany(relays, filters, {\n      ...params,\n      oneose() {\n        subcloser.close();\n      }\n    });\n    return subcloser;\n  }\n  async querySync(relays, filter, params) {\n    return new Promise(async (resolve) => {\n      const events = [];\n      this.subscribeManyEose(relays, [filter], {\n        ...params,\n        onevent(event) {\n          events.push(event);\n        },\n        onclose(_) {\n          resolve(events);\n        }\n      });\n    });\n  }\n  async get(relays, filter, params) {\n    filter.limit = 1;\n    const events = await this.querySync(relays, filter, params);\n    events.sort((a, b) => b.created_at - a.created_at);\n    return events[0] || null;\n  }\n  publish(relays, event) {\n    return relays.map(normalizeURL).map(async (url, i2, arr) => {\n      if (arr.indexOf(url) !== i2) {\n        return Promise.reject(\"duplicate url\");\n      }\n      let r = await this.ensureRelay(url);\n      return r.publish(event).then((reason) => {\n        if (this.trackRelays) {\n          let set = this.seenOn.get(event.id);\n          if (!set) {\n            set = /* @__PURE__ */ new Set();\n            this.seenOn.set(event.id, set);\n          }\n          set.add(r);\n        }\n        return reason;\n      });\n    });\n  }\n  listConnectionStatus() {\n    const map = /* @__PURE__ */ new Map();\n    this.relays.forEach((relay, url) => map.set(url, relay.connected));\n    return map;\n  }\n  destroy() {\n    this.relays.forEach((conn) => conn.close());\n    this.relays = /* @__PURE__ */ new Map();\n  }\n};\n\n// pool.ts\nvar _WebSocket2;\ntry {\n  _WebSocket2 = WebSocket;\n} catch {\n}\nvar SimplePool = class extends AbstractSimplePool {\n  constructor() {\n    super({ verifyEvent, websocketImplementation: _WebSocket2 });\n  }\n};\n\n// nip19.ts\nvar nip19_exports = {};\n__export(nip19_exports, {\n  BECH32_REGEX: () => BECH32_REGEX,\n  Bech32MaxSize: () => Bech32MaxSize,\n  NostrTypeGuard: () => NostrTypeGuard,\n  decode: () => decode,\n  encodeBytes: () => encodeBytes,\n  naddrEncode: () => naddrEncode,\n  neventEncode: () => neventEncode,\n  noteEncode: () => noteEncode,\n  nprofileEncode: () => nprofileEncode,\n  npubEncode: () => npubEncode,\n  nsecEncode: () => nsecEncode\n});\n\n\nvar NostrTypeGuard = {\n  isNProfile: (value) => /^nprofile1[a-z\\d]+$/.test(value || \"\"),\n  isNEvent: (value) => /^nevent1[a-z\\d]+$/.test(value || \"\"),\n  isNAddr: (value) => /^naddr1[a-z\\d]+$/.test(value || \"\"),\n  isNSec: (value) => /^nsec1[a-z\\d]{58}$/.test(value || \"\"),\n  isNPub: (value) => /^npub1[a-z\\d]{58}$/.test(value || \"\"),\n  isNote: (value) => /^note1[a-z\\d]+$/.test(value || \"\"),\n  isNcryptsec: (value) => /^ncryptsec1[a-z\\d]+$/.test(value || \"\")\n};\nvar Bech32MaxSize = 5e3;\nvar BECH32_REGEX = /[\\x21-\\x7E]{1,83}1[023456789acdefghjklmnpqrstuvwxyz]{6,}/;\nfunction integerToUint8Array(number) {\n  const uint8Array = new Uint8Array(4);\n  uint8Array[0] = number >> 24 & 255;\n  uint8Array[1] = number >> 16 & 255;\n  uint8Array[2] = number >> 8 & 255;\n  uint8Array[3] = number & 255;\n  return uint8Array;\n}\nfunction decode(nip19) {\n  let { prefix, words } = _scure_base__WEBPACK_IMPORTED_MODULE_3__.bech32.decode(nip19, Bech32MaxSize);\n  let data = new Uint8Array(_scure_base__WEBPACK_IMPORTED_MODULE_3__.bech32.fromWords(words));\n  switch (prefix) {\n    case \"nprofile\": {\n      let tlv = parseTLV(data);\n      if (!tlv[0]?.[0])\n        throw new Error(\"missing TLV 0 for nprofile\");\n      if (tlv[0][0].length !== 32)\n        throw new Error(\"TLV 0 should be 32 bytes\");\n      return {\n        type: \"nprofile\",\n        data: {\n          pubkey: (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(tlv[0][0]),\n          relays: tlv[1] ? tlv[1].map((d) => utf8Decoder.decode(d)) : []\n        }\n      };\n    }\n    case \"nevent\": {\n      let tlv = parseTLV(data);\n      if (!tlv[0]?.[0])\n        throw new Error(\"missing TLV 0 for nevent\");\n      if (tlv[0][0].length !== 32)\n        throw new Error(\"TLV 0 should be 32 bytes\");\n      if (tlv[2] && tlv[2][0].length !== 32)\n        throw new Error(\"TLV 2 should be 32 bytes\");\n      if (tlv[3] && tlv[3][0].length !== 4)\n        throw new Error(\"TLV 3 should be 4 bytes\");\n      return {\n        type: \"nevent\",\n        data: {\n          id: (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(tlv[0][0]),\n          relays: tlv[1] ? tlv[1].map((d) => utf8Decoder.decode(d)) : [],\n          author: tlv[2]?.[0] ? (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(tlv[2][0]) : void 0,\n          kind: tlv[3]?.[0] ? parseInt((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(tlv[3][0]), 16) : void 0\n        }\n      };\n    }\n    case \"naddr\": {\n      let tlv = parseTLV(data);\n      if (!tlv[0]?.[0])\n        throw new Error(\"missing TLV 0 for naddr\");\n      if (!tlv[2]?.[0])\n        throw new Error(\"missing TLV 2 for naddr\");\n      if (tlv[2][0].length !== 32)\n        throw new Error(\"TLV 2 should be 32 bytes\");\n      if (!tlv[3]?.[0])\n        throw new Error(\"missing TLV 3 for naddr\");\n      if (tlv[3][0].length !== 4)\n        throw new Error(\"TLV 3 should be 4 bytes\");\n      return {\n        type: \"naddr\",\n        data: {\n          identifier: utf8Decoder.decode(tlv[0][0]),\n          pubkey: (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(tlv[2][0]),\n          kind: parseInt((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(tlv[3][0]), 16),\n          relays: tlv[1] ? tlv[1].map((d) => utf8Decoder.decode(d)) : []\n        }\n      };\n    }\n    case \"nsec\":\n      return { type: prefix, data };\n    case \"npub\":\n    case \"note\":\n      return { type: prefix, data: (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(data) };\n    default:\n      throw new Error(`unknown prefix ${prefix}`);\n  }\n}\nfunction parseTLV(data) {\n  let result = {};\n  let rest = data;\n  while (rest.length > 0) {\n    let t = rest[0];\n    let l = rest[1];\n    let v = rest.slice(2, 2 + l);\n    rest = rest.slice(2 + l);\n    if (v.length < l)\n      throw new Error(`not enough data to read on TLV ${t}`);\n    result[t] = result[t] || [];\n    result[t].push(v);\n  }\n  return result;\n}\nfunction nsecEncode(key) {\n  return encodeBytes(\"nsec\", key);\n}\nfunction npubEncode(hex) {\n  return encodeBytes(\"npub\", (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.hexToBytes)(hex));\n}\nfunction noteEncode(hex) {\n  return encodeBytes(\"note\", (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.hexToBytes)(hex));\n}\nfunction encodeBech32(prefix, data) {\n  let words = _scure_base__WEBPACK_IMPORTED_MODULE_3__.bech32.toWords(data);\n  return _scure_base__WEBPACK_IMPORTED_MODULE_3__.bech32.encode(prefix, words, Bech32MaxSize);\n}\nfunction encodeBytes(prefix, bytes) {\n  return encodeBech32(prefix, bytes);\n}\nfunction nprofileEncode(profile) {\n  let data = encodeTLV({\n    0: [(0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.hexToBytes)(profile.pubkey)],\n    1: (profile.relays || []).map((url) => utf8Encoder.encode(url))\n  });\n  return encodeBech32(\"nprofile\", data);\n}\nfunction neventEncode(event) {\n  let kindArray;\n  if (event.kind !== void 0) {\n    kindArray = integerToUint8Array(event.kind);\n  }\n  let data = encodeTLV({\n    0: [(0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.hexToBytes)(event.id)],\n    1: (event.relays || []).map((url) => utf8Encoder.encode(url)),\n    2: event.author ? [(0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.hexToBytes)(event.author)] : [],\n    3: kindArray ? [new Uint8Array(kindArray)] : []\n  });\n  return encodeBech32(\"nevent\", data);\n}\nfunction naddrEncode(addr) {\n  let kind = new ArrayBuffer(4);\n  new DataView(kind).setUint32(0, addr.kind, false);\n  let data = encodeTLV({\n    0: [utf8Encoder.encode(addr.identifier)],\n    1: (addr.relays || []).map((url) => utf8Encoder.encode(url)),\n    2: [(0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.hexToBytes)(addr.pubkey)],\n    3: [new Uint8Array(kind)]\n  });\n  return encodeBech32(\"naddr\", data);\n}\nfunction encodeTLV(tlv) {\n  let entries = [];\n  Object.entries(tlv).reverse().forEach(([t, vs]) => {\n    vs.forEach((v) => {\n      let entry = new Uint8Array(v.length + 2);\n      entry.set([parseInt(t)], 0);\n      entry.set([v.length], 1);\n      entry.set(v, 2);\n      entries.push(entry);\n    });\n  });\n  return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...entries);\n}\n\n// references.ts\nvar mentionRegex = /\\bnostr:((note|npub|naddr|nevent|nprofile)1\\w+)\\b|#\\[(\\d+)\\]/g;\nfunction parseReferences(evt) {\n  let references = [];\n  for (let ref of evt.content.matchAll(mentionRegex)) {\n    if (ref[2]) {\n      try {\n        let { type, data } = decode(ref[1]);\n        switch (type) {\n          case \"npub\": {\n            references.push({\n              text: ref[0],\n              profile: { pubkey: data, relays: [] }\n            });\n            break;\n          }\n          case \"nprofile\": {\n            references.push({\n              text: ref[0],\n              profile: data\n            });\n            break;\n          }\n          case \"note\": {\n            references.push({\n              text: ref[0],\n              event: { id: data, relays: [] }\n            });\n            break;\n          }\n          case \"nevent\": {\n            references.push({\n              text: ref[0],\n              event: data\n            });\n            break;\n          }\n          case \"naddr\": {\n            references.push({\n              text: ref[0],\n              address: data\n            });\n            break;\n          }\n        }\n      } catch (err) {\n      }\n    } else if (ref[3]) {\n      let idx = parseInt(ref[3], 10);\n      let tag = evt.tags[idx];\n      if (!tag)\n        continue;\n      switch (tag[0]) {\n        case \"p\": {\n          references.push({\n            text: ref[0],\n            profile: { pubkey: tag[1], relays: tag[2] ? [tag[2]] : [] }\n          });\n          break;\n        }\n        case \"e\": {\n          references.push({\n            text: ref[0],\n            event: { id: tag[1], relays: tag[2] ? [tag[2]] : [] }\n          });\n          break;\n        }\n        case \"a\": {\n          try {\n            let [kind, pubkey, identifier] = tag[1].split(\":\");\n            references.push({\n              text: ref[0],\n              address: {\n                identifier,\n                pubkey,\n                kind: parseInt(kind, 10),\n                relays: tag[2] ? [tag[2]] : []\n              }\n            });\n          } catch (err) {\n          }\n          break;\n        }\n      }\n    }\n  }\n  return references;\n}\n\n// nip04.ts\nvar nip04_exports = {};\n__export(nip04_exports, {\n  decrypt: () => decrypt,\n  encrypt: () => encrypt\n});\n\n\n\n\nasync function encrypt(secretKey, pubkey, text) {\n  const privkey = secretKey instanceof Uint8Array ? (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(secretKey) : secretKey;\n  const key = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.getSharedSecret(privkey, \"02\" + pubkey);\n  const normalizedKey = getNormalizedX(key);\n  let iv = Uint8Array.from((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.randomBytes)(16));\n  let plaintext = utf8Encoder.encode(text);\n  let ciphertext = (0,_noble_ciphers_aes__WEBPACK_IMPORTED_MODULE_4__.cbc)(normalizedKey, iv).encrypt(plaintext);\n  let ctb64 = _scure_base__WEBPACK_IMPORTED_MODULE_3__.base64.encode(new Uint8Array(ciphertext));\n  let ivb64 = _scure_base__WEBPACK_IMPORTED_MODULE_3__.base64.encode(new Uint8Array(iv.buffer));\n  return `${ctb64}?iv=${ivb64}`;\n}\nasync function decrypt(secretKey, pubkey, data) {\n  const privkey = secretKey instanceof Uint8Array ? (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(secretKey) : secretKey;\n  let [ctb64, ivb64] = data.split(\"?iv=\");\n  let key = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.getSharedSecret(privkey, \"02\" + pubkey);\n  let normalizedKey = getNormalizedX(key);\n  let iv = _scure_base__WEBPACK_IMPORTED_MODULE_3__.base64.decode(ivb64);\n  let ciphertext = _scure_base__WEBPACK_IMPORTED_MODULE_3__.base64.decode(ctb64);\n  let plaintext = (0,_noble_ciphers_aes__WEBPACK_IMPORTED_MODULE_4__.cbc)(normalizedKey, iv).decrypt(ciphertext);\n  return utf8Decoder.decode(plaintext);\n}\nfunction getNormalizedX(key) {\n  return key.slice(1, 33);\n}\n\n// nip05.ts\nvar nip05_exports = {};\n__export(nip05_exports, {\n  NIP05_REGEX: () => NIP05_REGEX,\n  isNip05: () => isNip05,\n  isValid: () => isValid,\n  queryProfile: () => queryProfile,\n  searchDomain: () => searchDomain,\n  useFetchImplementation: () => useFetchImplementation\n});\nvar NIP05_REGEX = /^(?:([\\w.+-]+)@)?([\\w_-]+(\\.[\\w_-]+)+)$/;\nvar isNip05 = (value) => NIP05_REGEX.test(value || \"\");\nvar _fetch;\ntry {\n  _fetch = fetch;\n} catch (_) {\n  null;\n}\nfunction useFetchImplementation(fetchImplementation) {\n  _fetch = fetchImplementation;\n}\nasync function searchDomain(domain, query = \"\") {\n  try {\n    const url = `https://${domain}/.well-known/nostr.json?name=${query}`;\n    const res = await _fetch(url, { redirect: \"manual\" });\n    if (res.status !== 200) {\n      throw Error(\"Wrong response code\");\n    }\n    const json = await res.json();\n    return json.names;\n  } catch (_) {\n    return {};\n  }\n}\nasync function queryProfile(fullname) {\n  const match = fullname.match(NIP05_REGEX);\n  if (!match)\n    return null;\n  const [, name = \"_\", domain] = match;\n  try {\n    const url = `https://${domain}/.well-known/nostr.json?name=${name}`;\n    const res = await _fetch(url, { redirect: \"manual\" });\n    if (res.status !== 200) {\n      throw Error(\"Wrong response code\");\n    }\n    const json = await res.json();\n    const pubkey = json.names[name];\n    return pubkey ? { pubkey, relays: json.relays?.[pubkey] } : null;\n  } catch (_e) {\n    return null;\n  }\n}\nasync function isValid(pubkey, nip05) {\n  const res = await queryProfile(nip05);\n  return res ? res.pubkey === pubkey : false;\n}\n\n// nip10.ts\nvar nip10_exports = {};\n__export(nip10_exports, {\n  parse: () => parse\n});\nfunction parse(event) {\n  const result = {\n    reply: void 0,\n    root: void 0,\n    mentions: [],\n    profiles: [],\n    quotes: []\n  };\n  let maybeParent;\n  let maybeRoot;\n  for (let i2 = event.tags.length - 1; i2 >= 0; i2--) {\n    const tag = event.tags[i2];\n    if (tag[0] === \"e\" && tag[1]) {\n      const [_, eTagEventId, eTagRelayUrl, eTagMarker, eTagAuthor] = tag;\n      const eventPointer = {\n        id: eTagEventId,\n        relays: eTagRelayUrl ? [eTagRelayUrl] : [],\n        author: eTagAuthor\n      };\n      if (eTagMarker === \"root\") {\n        result.root = eventPointer;\n        continue;\n      }\n      if (eTagMarker === \"reply\") {\n        result.reply = eventPointer;\n        continue;\n      }\n      if (eTagMarker === \"mention\") {\n        result.mentions.push(eventPointer);\n        continue;\n      }\n      if (!maybeParent) {\n        maybeParent = eventPointer;\n      } else {\n        maybeRoot = eventPointer;\n      }\n      result.mentions.push(eventPointer);\n      continue;\n    }\n    if (tag[0] === \"q\" && tag[1]) {\n      const [_, eTagEventId, eTagRelayUrl] = tag;\n      result.quotes.push({\n        id: eTagEventId,\n        relays: eTagRelayUrl ? [eTagRelayUrl] : []\n      });\n    }\n    if (tag[0] === \"p\" && tag[1]) {\n      result.profiles.push({\n        pubkey: tag[1],\n        relays: tag[2] ? [tag[2]] : []\n      });\n      continue;\n    }\n  }\n  if (!result.root) {\n    result.root = maybeRoot || maybeParent || result.reply;\n  }\n  if (!result.reply) {\n    result.reply = maybeParent || result.root;\n  }\n  ;\n  [result.reply, result.root].forEach((ref) => {\n    if (!ref)\n      return;\n    let idx = result.mentions.indexOf(ref);\n    if (idx !== -1) {\n      result.mentions.splice(idx, 1);\n    }\n    if (ref.author) {\n      let author = result.profiles.find((p) => p.pubkey === ref.author);\n      if (author && author.relays) {\n        if (!ref.relays) {\n          ref.relays = [];\n        }\n        author.relays.forEach((url) => {\n          if (ref.relays?.indexOf(url) === -1)\n            ref.relays.push(url);\n        });\n        author.relays = ref.relays;\n      }\n    }\n  });\n  result.mentions.forEach((ref) => {\n    if (ref.author) {\n      let author = result.profiles.find((p) => p.pubkey === ref.author);\n      if (author && author.relays) {\n        if (!ref.relays) {\n          ref.relays = [];\n        }\n        author.relays.forEach((url) => {\n          if (ref.relays.indexOf(url) === -1)\n            ref.relays.push(url);\n        });\n        author.relays = ref.relays;\n      }\n    }\n  });\n  return result;\n}\n\n// nip11.ts\nvar nip11_exports = {};\n__export(nip11_exports, {\n  fetchRelayInformation: () => fetchRelayInformation,\n  useFetchImplementation: () => useFetchImplementation2\n});\nvar _fetch2;\ntry {\n  _fetch2 = fetch;\n} catch {\n}\nfunction useFetchImplementation2(fetchImplementation) {\n  _fetch2 = fetchImplementation;\n}\nasync function fetchRelayInformation(url) {\n  return await (await fetch(url.replace(\"ws://\", \"http://\").replace(\"wss://\", \"https://\"), {\n    headers: { Accept: \"application/nostr+json\" }\n  })).json();\n}\n\n// nip13.ts\nvar nip13_exports = {};\n__export(nip13_exports, {\n  fastEventHash: () => fastEventHash,\n  getPow: () => getPow,\n  minePow: () => minePow\n});\n\n\nfunction getPow(hex) {\n  let count = 0;\n  for (let i2 = 0; i2 < 64; i2 += 8) {\n    const nibble = parseInt(hex.substring(i2, i2 + 8), 16);\n    if (nibble === 0) {\n      count += 32;\n    } else {\n      count += Math.clz32(nibble);\n      break;\n    }\n  }\n  return count;\n}\nfunction minePow(unsigned, difficulty) {\n  let count = 0;\n  const event = unsigned;\n  const tag = [\"nonce\", count.toString(), difficulty.toString()];\n  event.tags.push(tag);\n  while (true) {\n    const now2 = Math.floor(new Date().getTime() / 1e3);\n    if (now2 !== event.created_at) {\n      count = 0;\n      event.created_at = now2;\n    }\n    tag[1] = (++count).toString();\n    event.id = fastEventHash(event);\n    if (getPow(event.id) >= difficulty) {\n      break;\n    }\n  }\n  return event;\n}\nfunction fastEventHash(evt) {\n  return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(\n    (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_1__.sha256)(utf8Encoder.encode(JSON.stringify([0, evt.pubkey, evt.created_at, evt.kind, evt.tags, evt.content])))\n  );\n}\n\n// nip18.ts\nvar nip18_exports = {};\n__export(nip18_exports, {\n  finishRepostEvent: () => finishRepostEvent,\n  getRepostedEvent: () => getRepostedEvent,\n  getRepostedEventPointer: () => getRepostedEventPointer\n});\nfunction finishRepostEvent(t, reposted, relayUrl, privateKey) {\n  return finalizeEvent(\n    {\n      kind: Repost,\n      tags: [...t.tags ?? [], [\"e\", reposted.id, relayUrl], [\"p\", reposted.pubkey]],\n      content: t.content === \"\" ? \"\" : JSON.stringify(reposted),\n      created_at: t.created_at\n    },\n    privateKey\n  );\n}\nfunction getRepostedEventPointer(event) {\n  if (event.kind !== Repost) {\n    return void 0;\n  }\n  let lastETag;\n  let lastPTag;\n  for (let i2 = event.tags.length - 1; i2 >= 0 && (lastETag === void 0 || lastPTag === void 0); i2--) {\n    const tag = event.tags[i2];\n    if (tag.length >= 2) {\n      if (tag[0] === \"e\" && lastETag === void 0) {\n        lastETag = tag;\n      } else if (tag[0] === \"p\" && lastPTag === void 0) {\n        lastPTag = tag;\n      }\n    }\n  }\n  if (lastETag === void 0) {\n    return void 0;\n  }\n  return {\n    id: lastETag[1],\n    relays: [lastETag[2], lastPTag?.[2]].filter((x) => typeof x === \"string\"),\n    author: lastPTag?.[1]\n  };\n}\nfunction getRepostedEvent(event, { skipVerification } = {}) {\n  const pointer = getRepostedEventPointer(event);\n  if (pointer === void 0 || event.content === \"\") {\n    return void 0;\n  }\n  let repostedEvent;\n  try {\n    repostedEvent = JSON.parse(event.content);\n  } catch (error) {\n    return void 0;\n  }\n  if (repostedEvent.id !== pointer.id) {\n    return void 0;\n  }\n  if (!skipVerification && !verifyEvent(repostedEvent)) {\n    return void 0;\n  }\n  return repostedEvent;\n}\n\n// nip21.ts\nvar nip21_exports = {};\n__export(nip21_exports, {\n  NOSTR_URI_REGEX: () => NOSTR_URI_REGEX,\n  parse: () => parse2,\n  test: () => test\n});\nvar NOSTR_URI_REGEX = new RegExp(`nostr:(${BECH32_REGEX.source})`);\nfunction test(value) {\n  return typeof value === \"string\" && new RegExp(`^${NOSTR_URI_REGEX.source}$`).test(value);\n}\nfunction parse2(uri) {\n  const match = uri.match(new RegExp(`^${NOSTR_URI_REGEX.source}$`));\n  if (!match)\n    throw new Error(`Invalid Nostr URI: ${uri}`);\n  return {\n    uri: match[0],\n    value: match[1],\n    decoded: decode(match[1])\n  };\n}\n\n// nip25.ts\nvar nip25_exports = {};\n__export(nip25_exports, {\n  finishReactionEvent: () => finishReactionEvent,\n  getReactedEventPointer: () => getReactedEventPointer\n});\nfunction finishReactionEvent(t, reacted, privateKey) {\n  const inheritedTags = reacted.tags.filter((tag) => tag.length >= 2 && (tag[0] === \"e\" || tag[0] === \"p\"));\n  return finalizeEvent(\n    {\n      ...t,\n      kind: Reaction,\n      tags: [...t.tags ?? [], ...inheritedTags, [\"e\", reacted.id], [\"p\", reacted.pubkey]],\n      content: t.content ?? \"+\"\n    },\n    privateKey\n  );\n}\nfunction getReactedEventPointer(event) {\n  if (event.kind !== Reaction) {\n    return void 0;\n  }\n  let lastETag;\n  let lastPTag;\n  for (let i2 = event.tags.length - 1; i2 >= 0 && (lastETag === void 0 || lastPTag === void 0); i2--) {\n    const tag = event.tags[i2];\n    if (tag.length >= 2) {\n      if (tag[0] === \"e\" && lastETag === void 0) {\n        lastETag = tag;\n      } else if (tag[0] === \"p\" && lastPTag === void 0) {\n        lastPTag = tag;\n      }\n    }\n  }\n  if (lastETag === void 0 || lastPTag === void 0) {\n    return void 0;\n  }\n  return {\n    id: lastETag[1],\n    relays: [lastETag[2], lastPTag[2]].filter((x) => x !== void 0),\n    author: lastPTag[1]\n  };\n}\n\n// nip27.ts\nvar nip27_exports = {};\n__export(nip27_exports, {\n  matchAll: () => matchAll,\n  regex: () => regex,\n  replaceAll: () => replaceAll\n});\nvar regex = () => new RegExp(`\\\\b${NOSTR_URI_REGEX.source}\\\\b`, \"g\");\nfunction* matchAll(content) {\n  const matches = content.matchAll(regex());\n  for (const match of matches) {\n    try {\n      const [uri, value] = match;\n      yield {\n        uri,\n        value,\n        decoded: decode(value),\n        start: match.index,\n        end: match.index + uri.length\n      };\n    } catch (_e) {\n    }\n  }\n}\nfunction replaceAll(content, replacer) {\n  return content.replaceAll(regex(), (uri, value) => {\n    return replacer({\n      uri,\n      value,\n      decoded: decode(value)\n    });\n  });\n}\n\n// nip28.ts\nvar nip28_exports = {};\n__export(nip28_exports, {\n  channelCreateEvent: () => channelCreateEvent,\n  channelHideMessageEvent: () => channelHideMessageEvent,\n  channelMessageEvent: () => channelMessageEvent,\n  channelMetadataEvent: () => channelMetadataEvent,\n  channelMuteUserEvent: () => channelMuteUserEvent\n});\nvar channelCreateEvent = (t, privateKey) => {\n  let content;\n  if (typeof t.content === \"object\") {\n    content = JSON.stringify(t.content);\n  } else if (typeof t.content === \"string\") {\n    content = t.content;\n  } else {\n    return void 0;\n  }\n  return finalizeEvent(\n    {\n      kind: ChannelCreation,\n      tags: [...t.tags ?? []],\n      content,\n      created_at: t.created_at\n    },\n    privateKey\n  );\n};\nvar channelMetadataEvent = (t, privateKey) => {\n  let content;\n  if (typeof t.content === \"object\") {\n    content = JSON.stringify(t.content);\n  } else if (typeof t.content === \"string\") {\n    content = t.content;\n  } else {\n    return void 0;\n  }\n  return finalizeEvent(\n    {\n      kind: ChannelMetadata,\n      tags: [[\"e\", t.channel_create_event_id], ...t.tags ?? []],\n      content,\n      created_at: t.created_at\n    },\n    privateKey\n  );\n};\nvar channelMessageEvent = (t, privateKey) => {\n  const tags = [[\"e\", t.channel_create_event_id, t.relay_url, \"root\"]];\n  if (t.reply_to_channel_message_event_id) {\n    tags.push([\"e\", t.reply_to_channel_message_event_id, t.relay_url, \"reply\"]);\n  }\n  return finalizeEvent(\n    {\n      kind: ChannelMessage,\n      tags: [...tags, ...t.tags ?? []],\n      content: t.content,\n      created_at: t.created_at\n    },\n    privateKey\n  );\n};\nvar channelHideMessageEvent = (t, privateKey) => {\n  let content;\n  if (typeof t.content === \"object\") {\n    content = JSON.stringify(t.content);\n  } else if (typeof t.content === \"string\") {\n    content = t.content;\n  } else {\n    return void 0;\n  }\n  return finalizeEvent(\n    {\n      kind: ChannelHideMessage,\n      tags: [[\"e\", t.channel_message_event_id], ...t.tags ?? []],\n      content,\n      created_at: t.created_at\n    },\n    privateKey\n  );\n};\nvar channelMuteUserEvent = (t, privateKey) => {\n  let content;\n  if (typeof t.content === \"object\") {\n    content = JSON.stringify(t.content);\n  } else if (typeof t.content === \"string\") {\n    content = t.content;\n  } else {\n    return void 0;\n  }\n  return finalizeEvent(\n    {\n      kind: ChannelMuteUser,\n      tags: [[\"p\", t.pubkey_to_mute], ...t.tags ?? []],\n      content,\n      created_at: t.created_at\n    },\n    privateKey\n  );\n};\n\n// nip30.ts\nvar nip30_exports = {};\n__export(nip30_exports, {\n  EMOJI_SHORTCODE_REGEX: () => EMOJI_SHORTCODE_REGEX,\n  matchAll: () => matchAll2,\n  regex: () => regex2,\n  replaceAll: () => replaceAll2\n});\nvar EMOJI_SHORTCODE_REGEX = /:(\\w+):/;\nvar regex2 = () => new RegExp(`\\\\B${EMOJI_SHORTCODE_REGEX.source}\\\\B`, \"g\");\nfunction* matchAll2(content) {\n  const matches = content.matchAll(regex2());\n  for (const match of matches) {\n    try {\n      const [shortcode, name] = match;\n      yield {\n        shortcode,\n        name,\n        start: match.index,\n        end: match.index + shortcode.length\n      };\n    } catch (_e) {\n    }\n  }\n}\nfunction replaceAll2(content, replacer) {\n  return content.replaceAll(regex2(), (shortcode, name) => {\n    return replacer({\n      shortcode,\n      name\n    });\n  });\n}\n\n// nip39.ts\nvar nip39_exports = {};\n__export(nip39_exports, {\n  useFetchImplementation: () => useFetchImplementation3,\n  validateGithub: () => validateGithub\n});\nvar _fetch3;\ntry {\n  _fetch3 = fetch;\n} catch {\n}\nfunction useFetchImplementation3(fetchImplementation) {\n  _fetch3 = fetchImplementation;\n}\nasync function validateGithub(pubkey, username, proof) {\n  try {\n    let res = await (await _fetch3(`https://gist.github.com/${username}/${proof}/raw`)).text();\n    return res === `Verifying that I control the following Nostr public key: ${pubkey}`;\n  } catch (_) {\n    return false;\n  }\n}\n\n// nip44.ts\nvar nip44_exports = {};\n__export(nip44_exports, {\n  decrypt: () => decrypt2,\n  encrypt: () => encrypt2,\n  getConversationKey: () => getConversationKey,\n  v2: () => v2\n});\n\n\n\n\n\n\n\n\nvar minPlaintextSize = 1;\nvar maxPlaintextSize = 65535;\nfunction getConversationKey(privkeyA, pubkeyB) {\n  const sharedX = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.getSharedSecret(privkeyA, \"02\" + pubkeyB).subarray(1, 33);\n  return (0,_noble_hashes_hkdf__WEBPACK_IMPORTED_MODULE_5__.extract)(_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_1__.sha256, sharedX, \"nip44-v2\");\n}\nfunction getMessageKeys(conversationKey, nonce) {\n  const keys = (0,_noble_hashes_hkdf__WEBPACK_IMPORTED_MODULE_5__.expand)(_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_1__.sha256, conversationKey, nonce, 76);\n  return {\n    chacha_key: keys.subarray(0, 32),\n    chacha_nonce: keys.subarray(32, 44),\n    hmac_key: keys.subarray(44, 76)\n  };\n}\nfunction calcPaddedLen(len) {\n  if (!Number.isSafeInteger(len) || len < 1)\n    throw new Error(\"expected positive integer\");\n  if (len <= 32)\n    return 32;\n  const nextPower = 1 << Math.floor(Math.log2(len - 1)) + 1;\n  const chunk = nextPower <= 256 ? 32 : nextPower / 8;\n  return chunk * (Math.floor((len - 1) / chunk) + 1);\n}\nfunction writeU16BE(num) {\n  if (!Number.isSafeInteger(num) || num < minPlaintextSize || num > maxPlaintextSize)\n    throw new Error(\"invalid plaintext size: must be between 1 and 65535 bytes\");\n  const arr = new Uint8Array(2);\n  new DataView(arr.buffer).setUint16(0, num, false);\n  return arr;\n}\nfunction pad(plaintext) {\n  const unpadded = utf8Encoder.encode(plaintext);\n  const unpaddedLen = unpadded.length;\n  const prefix = writeU16BE(unpaddedLen);\n  const suffix = new Uint8Array(calcPaddedLen(unpaddedLen) - unpaddedLen);\n  return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(prefix, unpadded, suffix);\n}\nfunction unpad(padded) {\n  const unpaddedLen = new DataView(padded.buffer).getUint16(0);\n  const unpadded = padded.subarray(2, 2 + unpaddedLen);\n  if (unpaddedLen < minPlaintextSize || unpaddedLen > maxPlaintextSize || unpadded.length !== unpaddedLen || padded.length !== 2 + calcPaddedLen(unpaddedLen))\n    throw new Error(\"invalid padding\");\n  return utf8Decoder.decode(unpadded);\n}\nfunction hmacAad(key, message, aad) {\n  if (aad.length !== 32)\n    throw new Error(\"AAD associated data must be 32 bytes\");\n  const combined = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(aad, message);\n  return (0,_noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_6__.hmac)(_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_1__.sha256, key, combined);\n}\nfunction decodePayload(payload) {\n  if (typeof payload !== \"string\")\n    throw new Error(\"payload must be a valid string\");\n  const plen = payload.length;\n  if (plen < 132 || plen > 87472)\n    throw new Error(\"invalid payload length: \" + plen);\n  if (payload[0] === \"#\")\n    throw new Error(\"unknown encryption version\");\n  let data;\n  try {\n    data = _scure_base__WEBPACK_IMPORTED_MODULE_3__.base64.decode(payload);\n  } catch (error) {\n    throw new Error(\"invalid base64: \" + error.message);\n  }\n  const dlen = data.length;\n  if (dlen < 99 || dlen > 65603)\n    throw new Error(\"invalid data length: \" + dlen);\n  const vers = data[0];\n  if (vers !== 2)\n    throw new Error(\"unknown encryption version \" + vers);\n  return {\n    nonce: data.subarray(1, 33),\n    ciphertext: data.subarray(33, -32),\n    mac: data.subarray(-32)\n  };\n}\nfunction encrypt2(plaintext, conversationKey, nonce = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.randomBytes)(32)) {\n  const { chacha_key, chacha_nonce, hmac_key } = getMessageKeys(conversationKey, nonce);\n  const padded = pad(plaintext);\n  const ciphertext = (0,_noble_ciphers_chacha__WEBPACK_IMPORTED_MODULE_7__.chacha20)(chacha_key, chacha_nonce, padded);\n  const mac = hmacAad(hmac_key, ciphertext, nonce);\n  return _scure_base__WEBPACK_IMPORTED_MODULE_3__.base64.encode((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(new Uint8Array([2]), nonce, ciphertext, mac));\n}\nfunction decrypt2(payload, conversationKey) {\n  const { nonce, ciphertext, mac } = decodePayload(payload);\n  const { chacha_key, chacha_nonce, hmac_key } = getMessageKeys(conversationKey, nonce);\n  const calculatedMac = hmacAad(hmac_key, ciphertext, nonce);\n  if (!(0,_noble_ciphers_utils__WEBPACK_IMPORTED_MODULE_8__.equalBytes)(calculatedMac, mac))\n    throw new Error(\"invalid MAC\");\n  const padded = (0,_noble_ciphers_chacha__WEBPACK_IMPORTED_MODULE_7__.chacha20)(chacha_key, chacha_nonce, ciphertext);\n  return unpad(padded);\n}\nvar v2 = {\n  utils: {\n    getConversationKey,\n    calcPaddedLen\n  },\n  encrypt: encrypt2,\n  decrypt: decrypt2\n};\n\n// nip47.ts\nvar nip47_exports = {};\n__export(nip47_exports, {\n  makeNwcRequestEvent: () => makeNwcRequestEvent,\n  parseConnectionString: () => parseConnectionString\n});\nfunction parseConnectionString(connectionString) {\n  const { pathname, searchParams } = new URL(connectionString);\n  const pubkey = pathname;\n  const relay = searchParams.get(\"relay\");\n  const secret = searchParams.get(\"secret\");\n  if (!pubkey || !relay || !secret) {\n    throw new Error(\"invalid connection string\");\n  }\n  return { pubkey, relay, secret };\n}\nasync function makeNwcRequestEvent(pubkey, secretKey, invoice) {\n  const content = {\n    method: \"pay_invoice\",\n    params: {\n      invoice\n    }\n  };\n  const encryptedContent = await encrypt(secretKey, pubkey, JSON.stringify(content));\n  const eventTemplate = {\n    kind: NWCWalletRequest,\n    created_at: Math.round(Date.now() / 1e3),\n    content: encryptedContent,\n    tags: [[\"p\", pubkey]]\n  };\n  return finalizeEvent(eventTemplate, secretKey);\n}\n\n// nip57.ts\nvar nip57_exports = {};\n__export(nip57_exports, {\n  getZapEndpoint: () => getZapEndpoint,\n  makeZapReceipt: () => makeZapReceipt,\n  makeZapRequest: () => makeZapRequest,\n  useFetchImplementation: () => useFetchImplementation4,\n  validateZapRequest: () => validateZapRequest\n});\n\nvar _fetch4;\ntry {\n  _fetch4 = fetch;\n} catch {\n}\nfunction useFetchImplementation4(fetchImplementation) {\n  _fetch4 = fetchImplementation;\n}\nasync function getZapEndpoint(metadata) {\n  try {\n    let lnurl = \"\";\n    let { lud06, lud16 } = JSON.parse(metadata.content);\n    if (lud06) {\n      let { words } = _scure_base__WEBPACK_IMPORTED_MODULE_3__.bech32.decode(lud06, 1e3);\n      let data = _scure_base__WEBPACK_IMPORTED_MODULE_3__.bech32.fromWords(words);\n      lnurl = utf8Decoder.decode(data);\n    } else if (lud16) {\n      let [name, domain] = lud16.split(\"@\");\n      lnurl = new URL(`/.well-known/lnurlp/${name}`, `https://${domain}`).toString();\n    } else {\n      return null;\n    }\n    let res = await _fetch4(lnurl);\n    let body = await res.json();\n    if (body.allowsNostr && body.nostrPubkey) {\n      return body.callback;\n    }\n  } catch (err) {\n  }\n  return null;\n}\nfunction makeZapRequest({\n  profile,\n  event,\n  amount,\n  relays,\n  comment = \"\"\n}) {\n  if (!amount)\n    throw new Error(\"amount not given\");\n  if (!profile)\n    throw new Error(\"profile not given\");\n  let zr = {\n    kind: 9734,\n    created_at: Math.round(Date.now() / 1e3),\n    content: comment,\n    tags: [\n      [\"p\", profile],\n      [\"amount\", amount.toString()],\n      [\"relays\", ...relays]\n    ]\n  };\n  if (event) {\n    zr.tags.push([\"e\", event]);\n  }\n  return zr;\n}\nfunction validateZapRequest(zapRequestString) {\n  let zapRequest;\n  try {\n    zapRequest = JSON.parse(zapRequestString);\n  } catch (err) {\n    return \"Invalid zap request JSON.\";\n  }\n  if (!validateEvent(zapRequest))\n    return \"Zap request is not a valid Nostr event.\";\n  if (!verifyEvent(zapRequest))\n    return \"Invalid signature on zap request.\";\n  let p = zapRequest.tags.find(([t, v]) => t === \"p\" && v);\n  if (!p)\n    return \"Zap request doesn't have a 'p' tag.\";\n  if (!p[1].match(/^[a-f0-9]{64}$/))\n    return \"Zap request 'p' tag is not valid hex.\";\n  let e = zapRequest.tags.find(([t, v]) => t === \"e\" && v);\n  if (e && !e[1].match(/^[a-f0-9]{64}$/))\n    return \"Zap request 'e' tag is not valid hex.\";\n  let relays = zapRequest.tags.find(([t, v]) => t === \"relays\" && v);\n  if (!relays)\n    return \"Zap request doesn't have a 'relays' tag.\";\n  return null;\n}\nfunction makeZapReceipt({\n  zapRequest,\n  preimage,\n  bolt11,\n  paidAt\n}) {\n  let zr = JSON.parse(zapRequest);\n  let tagsFromZapRequest = zr.tags.filter(([t]) => t === \"e\" || t === \"p\" || t === \"a\");\n  let zap = {\n    kind: 9735,\n    created_at: Math.round(paidAt.getTime() / 1e3),\n    content: \"\",\n    tags: [...tagsFromZapRequest, [\"P\", zr.pubkey], [\"bolt11\", bolt11], [\"description\", zapRequest]]\n  };\n  if (preimage) {\n    zap.tags.push([\"preimage\", preimage]);\n  }\n  return zap;\n}\n\n// nip59.ts\nvar nip59_exports = {};\n__export(nip59_exports, {\n  createRumor: () => createRumor,\n  createSeal: () => createSeal,\n  createWrap: () => createWrap,\n  unwrapEvent: () => unwrapEvent,\n  unwrapManyEvents: () => unwrapManyEvents,\n  wrapEvent: () => wrapEvent,\n  wrapManyEvents: () => wrapManyEvents\n});\nvar TWO_DAYS = 2 * 24 * 60 * 60;\nvar now = () => Math.round(Date.now() / 1e3);\nvar randomNow = () => Math.round(now() - Math.random() * TWO_DAYS);\nvar nip44ConversationKey = (privateKey, publicKey) => getConversationKey(privateKey, publicKey);\nvar nip44Encrypt = (data, privateKey, publicKey) => encrypt2(JSON.stringify(data), nip44ConversationKey(privateKey, publicKey));\nvar nip44Decrypt = (data, privateKey) => JSON.parse(decrypt2(data.content, nip44ConversationKey(privateKey, data.pubkey)));\nfunction createRumor(event, privateKey) {\n  const rumor = {\n    created_at: now(),\n    content: \"\",\n    tags: [],\n    ...event,\n    pubkey: getPublicKey(privateKey)\n  };\n  rumor.id = getEventHash(rumor);\n  return rumor;\n}\nfunction createSeal(rumor, privateKey, recipientPublicKey) {\n  return finalizeEvent(\n    {\n      kind: Seal,\n      content: nip44Encrypt(rumor, privateKey, recipientPublicKey),\n      created_at: randomNow(),\n      tags: []\n    },\n    privateKey\n  );\n}\nfunction createWrap(seal, recipientPublicKey) {\n  const randomKey = generateSecretKey();\n  return finalizeEvent(\n    {\n      kind: GiftWrap,\n      content: nip44Encrypt(seal, randomKey, recipientPublicKey),\n      created_at: randomNow(),\n      tags: [[\"p\", recipientPublicKey]]\n    },\n    randomKey\n  );\n}\nfunction wrapEvent(event, senderPrivateKey, recipientPublicKey) {\n  const rumor = createRumor(event, senderPrivateKey);\n  const seal = createSeal(rumor, senderPrivateKey, recipientPublicKey);\n  return createWrap(seal, recipientPublicKey);\n}\nfunction wrapManyEvents(event, senderPrivateKey, recipientsPublicKeys) {\n  if (!recipientsPublicKeys || recipientsPublicKeys.length === 0) {\n    throw new Error(\"At least one recipient is required.\");\n  }\n  const senderPublicKey = getPublicKey(senderPrivateKey);\n  const wrappeds = [wrapEvent(event, senderPrivateKey, senderPublicKey)];\n  recipientsPublicKeys.forEach((recipientPublicKey) => {\n    wrappeds.push(wrapEvent(event, senderPrivateKey, recipientPublicKey));\n  });\n  return wrappeds;\n}\nfunction unwrapEvent(wrap, recipientPrivateKey) {\n  const unwrappedSeal = nip44Decrypt(wrap, recipientPrivateKey);\n  return nip44Decrypt(unwrappedSeal, recipientPrivateKey);\n}\nfunction unwrapManyEvents(wrappedEvents, recipientPrivateKey) {\n  let unwrappedEvents = [];\n  wrappedEvents.forEach((e) => {\n    unwrappedEvents.push(unwrapEvent(e, recipientPrivateKey));\n  });\n  unwrappedEvents.sort((a, b) => a.created_at - b.created_at);\n  return unwrappedEvents;\n}\n\n// nip98.ts\nvar nip98_exports = {};\n__export(nip98_exports, {\n  getToken: () => getToken,\n  hashPayload: () => hashPayload,\n  unpackEventFromToken: () => unpackEventFromToken,\n  validateEvent: () => validateEvent2,\n  validateEventKind: () => validateEventKind,\n  validateEventMethodTag: () => validateEventMethodTag,\n  validateEventPayloadTag: () => validateEventPayloadTag,\n  validateEventTimestamp: () => validateEventTimestamp,\n  validateEventUrlTag: () => validateEventUrlTag,\n  validateToken: () => validateToken\n});\n\n\n\nvar _authorizationScheme = \"Nostr \";\nasync function getToken(loginUrl, httpMethod, sign, includeAuthorizationScheme = false, payload) {\n  const event = {\n    kind: HTTPAuth,\n    tags: [\n      [\"u\", loginUrl],\n      [\"method\", httpMethod]\n    ],\n    created_at: Math.round(new Date().getTime() / 1e3),\n    content: \"\"\n  };\n  if (payload) {\n    event.tags.push([\"payload\", hashPayload(payload)]);\n  }\n  const signedEvent = await sign(event);\n  const authorizationScheme = includeAuthorizationScheme ? _authorizationScheme : \"\";\n  return authorizationScheme + _scure_base__WEBPACK_IMPORTED_MODULE_3__.base64.encode(utf8Encoder.encode(JSON.stringify(signedEvent)));\n}\nasync function validateToken(token, url, method) {\n  const event = await unpackEventFromToken(token).catch((error) => {\n    throw error;\n  });\n  const valid = await validateEvent2(event, url, method).catch((error) => {\n    throw error;\n  });\n  return valid;\n}\nasync function unpackEventFromToken(token) {\n  if (!token) {\n    throw new Error(\"Missing token\");\n  }\n  token = token.replace(_authorizationScheme, \"\");\n  const eventB64 = utf8Decoder.decode(_scure_base__WEBPACK_IMPORTED_MODULE_3__.base64.decode(token));\n  if (!eventB64 || eventB64.length === 0 || !eventB64.startsWith(\"{\")) {\n    throw new Error(\"Invalid token\");\n  }\n  const event = JSON.parse(eventB64);\n  return event;\n}\nfunction validateEventTimestamp(event) {\n  if (!event.created_at) {\n    return false;\n  }\n  return Math.round(new Date().getTime() / 1e3) - event.created_at < 60;\n}\nfunction validateEventKind(event) {\n  return event.kind === HTTPAuth;\n}\nfunction validateEventUrlTag(event, url) {\n  const urlTag = event.tags.find((t) => t[0] === \"u\");\n  if (!urlTag) {\n    return false;\n  }\n  return urlTag.length > 0 && urlTag[1] === url;\n}\nfunction validateEventMethodTag(event, method) {\n  const methodTag = event.tags.find((t) => t[0] === \"method\");\n  if (!methodTag) {\n    return false;\n  }\n  return methodTag.length > 0 && methodTag[1].toLowerCase() === method.toLowerCase();\n}\nfunction hashPayload(payload) {\n  const hash = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_1__.sha256)(utf8Encoder.encode(JSON.stringify(payload)));\n  return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(hash);\n}\nfunction validateEventPayloadTag(event, payload) {\n  const payloadTag = event.tags.find((t) => t[0] === \"payload\");\n  if (!payloadTag) {\n    return false;\n  }\n  const payloadHash = hashPayload(payload);\n  return payloadTag.length > 0 && payloadTag[1] === payloadHash;\n}\nasync function validateEvent2(event, url, method, body) {\n  if (!verifyEvent(event)) {\n    throw new Error(\"Invalid nostr event, signature invalid\");\n  }\n  if (!validateEventKind(event)) {\n    throw new Error(\"Invalid nostr event, kind invalid\");\n  }\n  if (!validateEventTimestamp(event)) {\n    throw new Error(\"Invalid nostr event, created_at timestamp invalid\");\n  }\n  if (!validateEventUrlTag(event, url)) {\n    throw new Error(\"Invalid nostr event, url tag invalid\");\n  }\n  if (!validateEventMethodTag(event, method)) {\n    throw new Error(\"Invalid nostr event, method tag invalid\");\n  }\n  if (Boolean(body) && typeof body === \"object\" && Object.keys(body).length > 0) {\n    if (!validateEventPayloadTag(event, body)) {\n      throw new Error(\"Invalid nostr event, payload tag does not match request body hash\");\n    }\n  }\n  return true;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9saWIvZXNtL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTs7QUFFQTtBQUNrRDtBQUNEOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLEdBQUc7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHdCQUF3QjtBQUMzQztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUM4Qzs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyw0REFBTztBQUNsQjtBQUNBO0FBQ0EsV0FBVywrREFBVSxDQUFDLDREQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwrREFBVSxDQUFDLDREQUFPO0FBQ3JDO0FBQ0EsZ0JBQWdCLCtEQUFVLENBQUMsNERBQU87QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDREQUFPO0FBQzNCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw0REFBTTtBQUN4QixTQUFTLCtEQUFVO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixRQUFRO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLDZCQUE2QixNQUFNO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsTUFBTTtBQUNuQztBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFNBQVMsSUFBSSxJQUFJO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxpQkFBaUI7QUFDN0QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsaUJBQWlCO0FBQy9ELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsaUJBQWlCO0FBQ3hELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsUUFBUSxhQUFhLGVBQWU7QUFDaEc7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtEQUFrRDtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDd0Q7QUFDTztBQUNoQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwrQ0FBTztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLCtDQUFPO0FBQzdDLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw0REFBTztBQUN0QixTQUFTLCtEQUFXO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF3Q0UiLCJzb3VyY2VzIjpbIi9ob21lL2xmZy9HaXQvTWFkdHJpcHMvbm9kZV9tb2R1bGVzL0Bub3N0ci1kZXYta2l0L25kay9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbGliL2VzbS9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xuXG4vLyBwdXJlLnRzXG5pbXBvcnQgeyBzY2hub3JyIH0gZnJvbSBcIkBub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxXCI7XG5pbXBvcnQgeyBieXRlc1RvSGV4IH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvdXRpbHNcIjtcblxuLy8gY29yZS50c1xudmFyIHZlcmlmaWVkU3ltYm9sID0gU3ltYm9sKFwidmVyaWZpZWRcIik7XG52YXIgaXNSZWNvcmQgPSAob2JqKSA9PiBvYmogaW5zdGFuY2VvZiBPYmplY3Q7XG5mdW5jdGlvbiB2YWxpZGF0ZUV2ZW50KGV2ZW50KSB7XG4gIGlmICghaXNSZWNvcmQoZXZlbnQpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiBldmVudC5raW5kICE9PSBcIm51bWJlclwiKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiBldmVudC5jb250ZW50ICE9PSBcInN0cmluZ1wiKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiBldmVudC5jcmVhdGVkX2F0ICE9PSBcIm51bWJlclwiKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiBldmVudC5wdWJrZXkgIT09IFwic3RyaW5nXCIpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoIWV2ZW50LnB1YmtleS5tYXRjaCgvXlthLWYwLTldezY0fSQvKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmICghQXJyYXkuaXNBcnJheShldmVudC50YWdzKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGZvciAobGV0IGkyID0gMDsgaTIgPCBldmVudC50YWdzLmxlbmd0aDsgaTIrKykge1xuICAgIGxldCB0YWcgPSBldmVudC50YWdzW2kyXTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodGFnKSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRhZy5sZW5ndGg7IGorKykge1xuICAgICAgaWYgKHR5cGVvZiB0YWdbal0gPT09IFwib2JqZWN0XCIpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBzb3J0RXZlbnRzKGV2ZW50cykge1xuICByZXR1cm4gZXZlbnRzLnNvcnQoKGEsIGIpID0+IHtcbiAgICBpZiAoYS5jcmVhdGVkX2F0ICE9PSBiLmNyZWF0ZWRfYXQpIHtcbiAgICAgIHJldHVybiBiLmNyZWF0ZWRfYXQgLSBhLmNyZWF0ZWRfYXQ7XG4gICAgfVxuICAgIHJldHVybiBhLmlkLmxvY2FsZUNvbXBhcmUoYi5pZCk7XG4gIH0pO1xufVxuXG4vLyBwdXJlLnRzXG5pbXBvcnQgeyBzaGEyNTYgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy9zaGEyNTZcIjtcblxuLy8gdXRpbHMudHNcbnZhciB1dGlsc19leHBvcnRzID0ge307XG5fX2V4cG9ydCh1dGlsc19leHBvcnRzLCB7XG4gIFF1ZXVlOiAoKSA9PiBRdWV1ZSxcbiAgUXVldWVOb2RlOiAoKSA9PiBRdWV1ZU5vZGUsXG4gIGJpbmFyeVNlYXJjaDogKCkgPT4gYmluYXJ5U2VhcmNoLFxuICBpbnNlcnRFdmVudEludG9Bc2NlbmRpbmdMaXN0OiAoKSA9PiBpbnNlcnRFdmVudEludG9Bc2NlbmRpbmdMaXN0LFxuICBpbnNlcnRFdmVudEludG9EZXNjZW5kaW5nTGlzdDogKCkgPT4gaW5zZXJ0RXZlbnRJbnRvRGVzY2VuZGluZ0xpc3QsXG4gIG5vcm1hbGl6ZVVSTDogKCkgPT4gbm9ybWFsaXplVVJMLFxuICB1dGY4RGVjb2RlcjogKCkgPT4gdXRmOERlY29kZXIsXG4gIHV0ZjhFbmNvZGVyOiAoKSA9PiB1dGY4RW5jb2RlclxufSk7XG52YXIgdXRmOERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoXCJ1dGYtOFwiKTtcbnZhciB1dGY4RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuZnVuY3Rpb24gbm9ybWFsaXplVVJMKHVybCkge1xuICBpZiAodXJsLmluZGV4T2YoXCI6Ly9cIikgPT09IC0xKVxuICAgIHVybCA9IFwid3NzOi8vXCIgKyB1cmw7XG4gIGxldCBwID0gbmV3IFVSTCh1cmwpO1xuICBwLnBhdGhuYW1lID0gcC5wYXRobmFtZS5yZXBsYWNlKC9cXC8rL2csIFwiL1wiKTtcbiAgaWYgKHAucGF0aG5hbWUuZW5kc1dpdGgoXCIvXCIpKVxuICAgIHAucGF0aG5hbWUgPSBwLnBhdGhuYW1lLnNsaWNlKDAsIC0xKTtcbiAgaWYgKHAucG9ydCA9PT0gXCI4MFwiICYmIHAucHJvdG9jb2wgPT09IFwid3M6XCIgfHwgcC5wb3J0ID09PSBcIjQ0M1wiICYmIHAucHJvdG9jb2wgPT09IFwid3NzOlwiKVxuICAgIHAucG9ydCA9IFwiXCI7XG4gIHAuc2VhcmNoUGFyYW1zLnNvcnQoKTtcbiAgcC5oYXNoID0gXCJcIjtcbiAgcmV0dXJuIHAudG9TdHJpbmcoKTtcbn1cbmZ1bmN0aW9uIGluc2VydEV2ZW50SW50b0Rlc2NlbmRpbmdMaXN0KHNvcnRlZEFycmF5LCBldmVudCkge1xuICBjb25zdCBbaWR4LCBmb3VuZF0gPSBiaW5hcnlTZWFyY2goc29ydGVkQXJyYXksIChiKSA9PiB7XG4gICAgaWYgKGV2ZW50LmlkID09PSBiLmlkKVxuICAgICAgcmV0dXJuIDA7XG4gICAgaWYgKGV2ZW50LmNyZWF0ZWRfYXQgPT09IGIuY3JlYXRlZF9hdClcbiAgICAgIHJldHVybiAtMTtcbiAgICByZXR1cm4gYi5jcmVhdGVkX2F0IC0gZXZlbnQuY3JlYXRlZF9hdDtcbiAgfSk7XG4gIGlmICghZm91bmQpIHtcbiAgICBzb3J0ZWRBcnJheS5zcGxpY2UoaWR4LCAwLCBldmVudCk7XG4gIH1cbiAgcmV0dXJuIHNvcnRlZEFycmF5O1xufVxuZnVuY3Rpb24gaW5zZXJ0RXZlbnRJbnRvQXNjZW5kaW5nTGlzdChzb3J0ZWRBcnJheSwgZXZlbnQpIHtcbiAgY29uc3QgW2lkeCwgZm91bmRdID0gYmluYXJ5U2VhcmNoKHNvcnRlZEFycmF5LCAoYikgPT4ge1xuICAgIGlmIChldmVudC5pZCA9PT0gYi5pZClcbiAgICAgIHJldHVybiAwO1xuICAgIGlmIChldmVudC5jcmVhdGVkX2F0ID09PSBiLmNyZWF0ZWRfYXQpXG4gICAgICByZXR1cm4gLTE7XG4gICAgcmV0dXJuIGV2ZW50LmNyZWF0ZWRfYXQgLSBiLmNyZWF0ZWRfYXQ7XG4gIH0pO1xuICBpZiAoIWZvdW5kKSB7XG4gICAgc29ydGVkQXJyYXkuc3BsaWNlKGlkeCwgMCwgZXZlbnQpO1xuICB9XG4gIHJldHVybiBzb3J0ZWRBcnJheTtcbn1cbmZ1bmN0aW9uIGJpbmFyeVNlYXJjaChhcnIsIGNvbXBhcmUpIHtcbiAgbGV0IHN0YXJ0ID0gMDtcbiAgbGV0IGVuZCA9IGFyci5sZW5ndGggLSAxO1xuICB3aGlsZSAoc3RhcnQgPD0gZW5kKSB7XG4gICAgY29uc3QgbWlkID0gTWF0aC5mbG9vcigoc3RhcnQgKyBlbmQpIC8gMik7XG4gICAgY29uc3QgY21wID0gY29tcGFyZShhcnJbbWlkXSk7XG4gICAgaWYgKGNtcCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFttaWQsIHRydWVdO1xuICAgIH1cbiAgICBpZiAoY21wIDwgMCkge1xuICAgICAgZW5kID0gbWlkIC0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnQgPSBtaWQgKyAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gW3N0YXJ0LCBmYWxzZV07XG59XG52YXIgUXVldWVOb2RlID0gY2xhc3Mge1xuICB2YWx1ZTtcbiAgbmV4dCA9IG51bGw7XG4gIHByZXYgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgdGhpcy52YWx1ZSA9IG1lc3NhZ2U7XG4gIH1cbn07XG52YXIgUXVldWUgPSBjbGFzcyB7XG4gIGZpcnN0O1xuICBsYXN0O1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmZpcnN0ID0gbnVsbDtcbiAgICB0aGlzLmxhc3QgPSBudWxsO1xuICB9XG4gIGVucXVldWUodmFsdWUpIHtcbiAgICBjb25zdCBuZXdOb2RlID0gbmV3IFF1ZXVlTm9kZSh2YWx1ZSk7XG4gICAgaWYgKCF0aGlzLmxhc3QpIHtcbiAgICAgIHRoaXMuZmlyc3QgPSBuZXdOb2RlO1xuICAgICAgdGhpcy5sYXN0ID0gbmV3Tm9kZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubGFzdCA9PT0gdGhpcy5maXJzdCkge1xuICAgICAgdGhpcy5sYXN0ID0gbmV3Tm9kZTtcbiAgICAgIHRoaXMubGFzdC5wcmV2ID0gdGhpcy5maXJzdDtcbiAgICAgIHRoaXMuZmlyc3QubmV4dCA9IG5ld05vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld05vZGUucHJldiA9IHRoaXMubGFzdDtcbiAgICAgIHRoaXMubGFzdC5uZXh0ID0gbmV3Tm9kZTtcbiAgICAgIHRoaXMubGFzdCA9IG5ld05vZGU7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGRlcXVldWUoKSB7XG4gICAgaWYgKCF0aGlzLmZpcnN0KVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgaWYgKHRoaXMuZmlyc3QgPT09IHRoaXMubGFzdCkge1xuICAgICAgY29uc3QgdGFyZ2V0MiA9IHRoaXMuZmlyc3Q7XG4gICAgICB0aGlzLmZpcnN0ID0gbnVsbDtcbiAgICAgIHRoaXMubGFzdCA9IG51bGw7XG4gICAgICByZXR1cm4gdGFyZ2V0Mi52YWx1ZTtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5maXJzdDtcbiAgICB0aGlzLmZpcnN0ID0gdGFyZ2V0Lm5leHQ7XG4gICAgcmV0dXJuIHRhcmdldC52YWx1ZTtcbiAgfVxufTtcblxuLy8gcHVyZS50c1xudmFyIEpTID0gY2xhc3Mge1xuICBnZW5lcmF0ZVNlY3JldEtleSgpIHtcbiAgICByZXR1cm4gc2Nobm9yci51dGlscy5yYW5kb21Qcml2YXRlS2V5KCk7XG4gIH1cbiAgZ2V0UHVibGljS2V5KHNlY3JldEtleSkge1xuICAgIHJldHVybiBieXRlc1RvSGV4KHNjaG5vcnIuZ2V0UHVibGljS2V5KHNlY3JldEtleSkpO1xuICB9XG4gIGZpbmFsaXplRXZlbnQodCwgc2VjcmV0S2V5KSB7XG4gICAgY29uc3QgZXZlbnQgPSB0O1xuICAgIGV2ZW50LnB1YmtleSA9IGJ5dGVzVG9IZXgoc2Nobm9yci5nZXRQdWJsaWNLZXkoc2VjcmV0S2V5KSk7XG4gICAgZXZlbnQuaWQgPSBnZXRFdmVudEhhc2goZXZlbnQpO1xuICAgIGV2ZW50LnNpZyA9IGJ5dGVzVG9IZXgoc2Nobm9yci5zaWduKGdldEV2ZW50SGFzaChldmVudCksIHNlY3JldEtleSkpO1xuICAgIGV2ZW50W3ZlcmlmaWVkU3ltYm9sXSA9IHRydWU7XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9XG4gIHZlcmlmeUV2ZW50KGV2ZW50KSB7XG4gICAgaWYgKHR5cGVvZiBldmVudFt2ZXJpZmllZFN5bWJvbF0gPT09IFwiYm9vbGVhblwiKVxuICAgICAgcmV0dXJuIGV2ZW50W3ZlcmlmaWVkU3ltYm9sXTtcbiAgICBjb25zdCBoYXNoID0gZ2V0RXZlbnRIYXNoKGV2ZW50KTtcbiAgICBpZiAoaGFzaCAhPT0gZXZlbnQuaWQpIHtcbiAgICAgIGV2ZW50W3ZlcmlmaWVkU3ltYm9sXSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgdmFsaWQgPSBzY2hub3JyLnZlcmlmeShldmVudC5zaWcsIGhhc2gsIGV2ZW50LnB1YmtleSk7XG4gICAgICBldmVudFt2ZXJpZmllZFN5bWJvbF0gPSB2YWxpZDtcbiAgICAgIHJldHVybiB2YWxpZDtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGV2ZW50W3ZlcmlmaWVkU3ltYm9sXSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufTtcbmZ1bmN0aW9uIHNlcmlhbGl6ZUV2ZW50KGV2dCkge1xuICBpZiAoIXZhbGlkYXRlRXZlbnQoZXZ0KSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW4ndCBzZXJpYWxpemUgZXZlbnQgd2l0aCB3cm9uZyBvciBtaXNzaW5nIHByb3BlcnRpZXNcIik7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShbMCwgZXZ0LnB1YmtleSwgZXZ0LmNyZWF0ZWRfYXQsIGV2dC5raW5kLCBldnQudGFncywgZXZ0LmNvbnRlbnRdKTtcbn1cbmZ1bmN0aW9uIGdldEV2ZW50SGFzaChldmVudCkge1xuICBsZXQgZXZlbnRIYXNoID0gc2hhMjU2KHV0ZjhFbmNvZGVyLmVuY29kZShzZXJpYWxpemVFdmVudChldmVudCkpKTtcbiAgcmV0dXJuIGJ5dGVzVG9IZXgoZXZlbnRIYXNoKTtcbn1cbnZhciBpID0gbmV3IEpTKCk7XG52YXIgZ2VuZXJhdGVTZWNyZXRLZXkgPSBpLmdlbmVyYXRlU2VjcmV0S2V5O1xudmFyIGdldFB1YmxpY0tleSA9IGkuZ2V0UHVibGljS2V5O1xudmFyIGZpbmFsaXplRXZlbnQgPSBpLmZpbmFsaXplRXZlbnQ7XG52YXIgdmVyaWZ5RXZlbnQgPSBpLnZlcmlmeUV2ZW50O1xuXG4vLyBraW5kcy50c1xudmFyIGtpbmRzX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGtpbmRzX2V4cG9ydHMsIHtcbiAgQXBwbGljYXRpb246ICgpID0+IEFwcGxpY2F0aW9uLFxuICBCYWRnZUF3YXJkOiAoKSA9PiBCYWRnZUF3YXJkLFxuICBCYWRnZURlZmluaXRpb246ICgpID0+IEJhZGdlRGVmaW5pdGlvbixcbiAgQmxvY2tlZFJlbGF5c0xpc3Q6ICgpID0+IEJsb2NrZWRSZWxheXNMaXN0LFxuICBCb29rbWFya0xpc3Q6ICgpID0+IEJvb2ttYXJrTGlzdCxcbiAgQm9va21hcmtzZXRzOiAoKSA9PiBCb29rbWFya3NldHMsXG4gIENhbGVuZGFyOiAoKSA9PiBDYWxlbmRhcixcbiAgQ2FsZW5kYXJFdmVudFJTVlA6ICgpID0+IENhbGVuZGFyRXZlbnRSU1ZQLFxuICBDaGFubmVsQ3JlYXRpb246ICgpID0+IENoYW5uZWxDcmVhdGlvbixcbiAgQ2hhbm5lbEhpZGVNZXNzYWdlOiAoKSA9PiBDaGFubmVsSGlkZU1lc3NhZ2UsXG4gIENoYW5uZWxNZXNzYWdlOiAoKSA9PiBDaGFubmVsTWVzc2FnZSxcbiAgQ2hhbm5lbE1ldGFkYXRhOiAoKSA9PiBDaGFubmVsTWV0YWRhdGEsXG4gIENoYW5uZWxNdXRlVXNlcjogKCkgPT4gQ2hhbm5lbE11dGVVc2VyLFxuICBDbGFzc2lmaWVkTGlzdGluZzogKCkgPT4gQ2xhc3NpZmllZExpc3RpbmcsXG4gIENsaWVudEF1dGg6ICgpID0+IENsaWVudEF1dGgsXG4gIENvbW11bml0aWVzTGlzdDogKCkgPT4gQ29tbXVuaXRpZXNMaXN0LFxuICBDb21tdW5pdHlEZWZpbml0aW9uOiAoKSA9PiBDb21tdW5pdHlEZWZpbml0aW9uLFxuICBDb21tdW5pdHlQb3N0QXBwcm92YWw6ICgpID0+IENvbW11bml0eVBvc3RBcHByb3ZhbCxcbiAgQ29udGFjdHM6ICgpID0+IENvbnRhY3RzLFxuICBDcmVhdGVPclVwZGF0ZVByb2R1Y3Q6ICgpID0+IENyZWF0ZU9yVXBkYXRlUHJvZHVjdCxcbiAgQ3JlYXRlT3JVcGRhdGVTdGFsbDogKCkgPT4gQ3JlYXRlT3JVcGRhdGVTdGFsbCxcbiAgQ3VyYXRpb25zZXRzOiAoKSA9PiBDdXJhdGlvbnNldHMsXG4gIERhdGU6ICgpID0+IERhdGUyLFxuICBEaXJlY3RNZXNzYWdlUmVsYXlzTGlzdDogKCkgPT4gRGlyZWN0TWVzc2FnZVJlbGF5c0xpc3QsXG4gIERyYWZ0Q2xhc3NpZmllZExpc3Rpbmc6ICgpID0+IERyYWZ0Q2xhc3NpZmllZExpc3RpbmcsXG4gIERyYWZ0TG9uZzogKCkgPT4gRHJhZnRMb25nLFxuICBFbW9qaXNldHM6ICgpID0+IEVtb2ppc2V0cyxcbiAgRW5jcnlwdGVkRGlyZWN0TWVzc2FnZTogKCkgPT4gRW5jcnlwdGVkRGlyZWN0TWVzc2FnZSxcbiAgRXZlbnREZWxldGlvbjogKCkgPT4gRXZlbnREZWxldGlvbixcbiAgRmlsZU1ldGFkYXRhOiAoKSA9PiBGaWxlTWV0YWRhdGEsXG4gIEZpbGVTZXJ2ZXJQcmVmZXJlbmNlOiAoKSA9PiBGaWxlU2VydmVyUHJlZmVyZW5jZSxcbiAgRm9sbG93c2V0czogKCkgPT4gRm9sbG93c2V0cyxcbiAgR2VuZXJpY1JlcG9zdDogKCkgPT4gR2VuZXJpY1JlcG9zdCxcbiAgR2VuZXJpY2xpc3RzOiAoKSA9PiBHZW5lcmljbGlzdHMsXG4gIEdpZnRXcmFwOiAoKSA9PiBHaWZ0V3JhcCxcbiAgSFRUUEF1dGg6ICgpID0+IEhUVFBBdXRoLFxuICBIYW5kbGVyaW5mb3JtYXRpb246ICgpID0+IEhhbmRsZXJpbmZvcm1hdGlvbixcbiAgSGFuZGxlcnJlY29tbWVuZGF0aW9uOiAoKSA9PiBIYW5kbGVycmVjb21tZW5kYXRpb24sXG4gIEhpZ2hsaWdodHM6ICgpID0+IEhpZ2hsaWdodHMsXG4gIEludGVyZXN0c0xpc3Q6ICgpID0+IEludGVyZXN0c0xpc3QsXG4gIEludGVyZXN0c2V0czogKCkgPT4gSW50ZXJlc3RzZXRzLFxuICBKb2JGZWVkYmFjazogKCkgPT4gSm9iRmVlZGJhY2ssXG4gIEpvYlJlcXVlc3Q6ICgpID0+IEpvYlJlcXVlc3QsXG4gIEpvYlJlc3VsdDogKCkgPT4gSm9iUmVzdWx0LFxuICBMYWJlbDogKCkgPT4gTGFiZWwsXG4gIExpZ2h0bmluZ1B1YlJQQzogKCkgPT4gTGlnaHRuaW5nUHViUlBDLFxuICBMaXZlQ2hhdE1lc3NhZ2U6ICgpID0+IExpdmVDaGF0TWVzc2FnZSxcbiAgTGl2ZUV2ZW50OiAoKSA9PiBMaXZlRXZlbnQsXG4gIExvbmdGb3JtQXJ0aWNsZTogKCkgPT4gTG9uZ0Zvcm1BcnRpY2xlLFxuICBNZXRhZGF0YTogKCkgPT4gTWV0YWRhdGEsXG4gIE11dGVsaXN0OiAoKSA9PiBNdXRlbGlzdCxcbiAgTldDV2FsbGV0SW5mbzogKCkgPT4gTldDV2FsbGV0SW5mbyxcbiAgTldDV2FsbGV0UmVxdWVzdDogKCkgPT4gTldDV2FsbGV0UmVxdWVzdCxcbiAgTldDV2FsbGV0UmVzcG9uc2U6ICgpID0+IE5XQ1dhbGxldFJlc3BvbnNlLFxuICBOb3N0ckNvbm5lY3Q6ICgpID0+IE5vc3RyQ29ubmVjdCxcbiAgT3BlblRpbWVzdGFtcHM6ICgpID0+IE9wZW5UaW1lc3RhbXBzLFxuICBQaW5saXN0OiAoKSA9PiBQaW5saXN0LFxuICBQcml2YXRlRGlyZWN0TWVzc2FnZTogKCkgPT4gUHJpdmF0ZURpcmVjdE1lc3NhZ2UsXG4gIFByb2JsZW1UcmFja2VyOiAoKSA9PiBQcm9ibGVtVHJhY2tlcixcbiAgUHJvZmlsZUJhZGdlczogKCkgPT4gUHJvZmlsZUJhZGdlcyxcbiAgUHVibGljQ2hhdHNMaXN0OiAoKSA9PiBQdWJsaWNDaGF0c0xpc3QsXG4gIFJlYWN0aW9uOiAoKSA9PiBSZWFjdGlvbixcbiAgUmVjb21tZW5kUmVsYXk6ICgpID0+IFJlY29tbWVuZFJlbGF5LFxuICBSZWxheUxpc3Q6ICgpID0+IFJlbGF5TGlzdCxcbiAgUmVsYXlzZXRzOiAoKSA9PiBSZWxheXNldHMsXG4gIFJlcG9ydDogKCkgPT4gUmVwb3J0LFxuICBSZXBvcnRpbmc6ICgpID0+IFJlcG9ydGluZyxcbiAgUmVwb3N0OiAoKSA9PiBSZXBvc3QsXG4gIFNlYWw6ICgpID0+IFNlYWwsXG4gIFNlYXJjaFJlbGF5c0xpc3Q6ICgpID0+IFNlYXJjaFJlbGF5c0xpc3QsXG4gIFNob3J0VGV4dE5vdGU6ICgpID0+IFNob3J0VGV4dE5vdGUsXG4gIFRpbWU6ICgpID0+IFRpbWUsXG4gIFVzZXJFbW9qaUxpc3Q6ICgpID0+IFVzZXJFbW9qaUxpc3QsXG4gIFVzZXJTdGF0dXNlczogKCkgPT4gVXNlclN0YXR1c2VzLFxuICBaYXA6ICgpID0+IFphcCxcbiAgWmFwR29hbDogKCkgPT4gWmFwR29hbCxcbiAgWmFwUmVxdWVzdDogKCkgPT4gWmFwUmVxdWVzdCxcbiAgY2xhc3NpZnlLaW5kOiAoKSA9PiBjbGFzc2lmeUtpbmQsXG4gIGlzRXBoZW1lcmFsS2luZDogKCkgPT4gaXNFcGhlbWVyYWxLaW5kLFxuICBpc0tpbmQ6ICgpID0+IGlzS2luZCxcbiAgaXNQYXJhbWV0ZXJpemVkUmVwbGFjZWFibGVLaW5kOiAoKSA9PiBpc1BhcmFtZXRlcml6ZWRSZXBsYWNlYWJsZUtpbmQsXG4gIGlzUmVndWxhcktpbmQ6ICgpID0+IGlzUmVndWxhcktpbmQsXG4gIGlzUmVwbGFjZWFibGVLaW5kOiAoKSA9PiBpc1JlcGxhY2VhYmxlS2luZFxufSk7XG5mdW5jdGlvbiBpc1JlZ3VsYXJLaW5kKGtpbmQpIHtcbiAgcmV0dXJuIDFlMyA8PSBraW5kICYmIGtpbmQgPCAxZTQgfHwgWzEsIDIsIDQsIDUsIDYsIDcsIDgsIDE2LCA0MCwgNDEsIDQyLCA0MywgNDRdLmluY2x1ZGVzKGtpbmQpO1xufVxuZnVuY3Rpb24gaXNSZXBsYWNlYWJsZUtpbmQoa2luZCkge1xuICByZXR1cm4gWzAsIDNdLmluY2x1ZGVzKGtpbmQpIHx8IDFlNCA8PSBraW5kICYmIGtpbmQgPCAyZTQ7XG59XG5mdW5jdGlvbiBpc0VwaGVtZXJhbEtpbmQoa2luZCkge1xuICByZXR1cm4gMmU0IDw9IGtpbmQgJiYga2luZCA8IDNlNDtcbn1cbmZ1bmN0aW9uIGlzUGFyYW1ldGVyaXplZFJlcGxhY2VhYmxlS2luZChraW5kKSB7XG4gIHJldHVybiAzZTQgPD0ga2luZCAmJiBraW5kIDwgNGU0O1xufVxuZnVuY3Rpb24gY2xhc3NpZnlLaW5kKGtpbmQpIHtcbiAgaWYgKGlzUmVndWxhcktpbmQoa2luZCkpXG4gICAgcmV0dXJuIFwicmVndWxhclwiO1xuICBpZiAoaXNSZXBsYWNlYWJsZUtpbmQoa2luZCkpXG4gICAgcmV0dXJuIFwicmVwbGFjZWFibGVcIjtcbiAgaWYgKGlzRXBoZW1lcmFsS2luZChraW5kKSlcbiAgICByZXR1cm4gXCJlcGhlbWVyYWxcIjtcbiAgaWYgKGlzUGFyYW1ldGVyaXplZFJlcGxhY2VhYmxlS2luZChraW5kKSlcbiAgICByZXR1cm4gXCJwYXJhbWV0ZXJpemVkXCI7XG4gIHJldHVybiBcInVua25vd25cIjtcbn1cbmZ1bmN0aW9uIGlzS2luZChldmVudCwga2luZCkge1xuICBjb25zdCBraW5kQXNBcnJheSA9IGtpbmQgaW5zdGFuY2VvZiBBcnJheSA/IGtpbmQgOiBba2luZF07XG4gIHJldHVybiB2YWxpZGF0ZUV2ZW50KGV2ZW50KSAmJiBraW5kQXNBcnJheS5pbmNsdWRlcyhldmVudC5raW5kKSB8fCBmYWxzZTtcbn1cbnZhciBNZXRhZGF0YSA9IDA7XG52YXIgU2hvcnRUZXh0Tm90ZSA9IDE7XG52YXIgUmVjb21tZW5kUmVsYXkgPSAyO1xudmFyIENvbnRhY3RzID0gMztcbnZhciBFbmNyeXB0ZWREaXJlY3RNZXNzYWdlID0gNDtcbnZhciBFdmVudERlbGV0aW9uID0gNTtcbnZhciBSZXBvc3QgPSA2O1xudmFyIFJlYWN0aW9uID0gNztcbnZhciBCYWRnZUF3YXJkID0gODtcbnZhciBTZWFsID0gMTM7XG52YXIgUHJpdmF0ZURpcmVjdE1lc3NhZ2UgPSAxNDtcbnZhciBHZW5lcmljUmVwb3N0ID0gMTY7XG52YXIgQ2hhbm5lbENyZWF0aW9uID0gNDA7XG52YXIgQ2hhbm5lbE1ldGFkYXRhID0gNDE7XG52YXIgQ2hhbm5lbE1lc3NhZ2UgPSA0MjtcbnZhciBDaGFubmVsSGlkZU1lc3NhZ2UgPSA0MztcbnZhciBDaGFubmVsTXV0ZVVzZXIgPSA0NDtcbnZhciBPcGVuVGltZXN0YW1wcyA9IDEwNDA7XG52YXIgR2lmdFdyYXAgPSAxMDU5O1xudmFyIEZpbGVNZXRhZGF0YSA9IDEwNjM7XG52YXIgTGl2ZUNoYXRNZXNzYWdlID0gMTMxMTtcbnZhciBQcm9ibGVtVHJhY2tlciA9IDE5NzE7XG52YXIgUmVwb3J0ID0gMTk4NDtcbnZhciBSZXBvcnRpbmcgPSAxOTg0O1xudmFyIExhYmVsID0gMTk4NTtcbnZhciBDb21tdW5pdHlQb3N0QXBwcm92YWwgPSA0NTUwO1xudmFyIEpvYlJlcXVlc3QgPSA1OTk5O1xudmFyIEpvYlJlc3VsdCA9IDY5OTk7XG52YXIgSm9iRmVlZGJhY2sgPSA3ZTM7XG52YXIgWmFwR29hbCA9IDkwNDE7XG52YXIgWmFwUmVxdWVzdCA9IDk3MzQ7XG52YXIgWmFwID0gOTczNTtcbnZhciBIaWdobGlnaHRzID0gOTgwMjtcbnZhciBNdXRlbGlzdCA9IDFlNDtcbnZhciBQaW5saXN0ID0gMTAwMDE7XG52YXIgUmVsYXlMaXN0ID0gMTAwMDI7XG52YXIgQm9va21hcmtMaXN0ID0gMTAwMDM7XG52YXIgQ29tbXVuaXRpZXNMaXN0ID0gMTAwMDQ7XG52YXIgUHVibGljQ2hhdHNMaXN0ID0gMTAwMDU7XG52YXIgQmxvY2tlZFJlbGF5c0xpc3QgPSAxMDAwNjtcbnZhciBTZWFyY2hSZWxheXNMaXN0ID0gMTAwMDc7XG52YXIgSW50ZXJlc3RzTGlzdCA9IDEwMDE1O1xudmFyIFVzZXJFbW9qaUxpc3QgPSAxMDAzMDtcbnZhciBEaXJlY3RNZXNzYWdlUmVsYXlzTGlzdCA9IDEwMDUwO1xudmFyIEZpbGVTZXJ2ZXJQcmVmZXJlbmNlID0gMTAwOTY7XG52YXIgTldDV2FsbGV0SW5mbyA9IDEzMTk0O1xudmFyIExpZ2h0bmluZ1B1YlJQQyA9IDIxZTM7XG52YXIgQ2xpZW50QXV0aCA9IDIyMjQyO1xudmFyIE5XQ1dhbGxldFJlcXVlc3QgPSAyMzE5NDtcbnZhciBOV0NXYWxsZXRSZXNwb25zZSA9IDIzMTk1O1xudmFyIE5vc3RyQ29ubmVjdCA9IDI0MTMzO1xudmFyIEhUVFBBdXRoID0gMjcyMzU7XG52YXIgRm9sbG93c2V0cyA9IDNlNDtcbnZhciBHZW5lcmljbGlzdHMgPSAzMDAwMTtcbnZhciBSZWxheXNldHMgPSAzMDAwMjtcbnZhciBCb29rbWFya3NldHMgPSAzMDAwMztcbnZhciBDdXJhdGlvbnNldHMgPSAzMDAwNDtcbnZhciBQcm9maWxlQmFkZ2VzID0gMzAwMDg7XG52YXIgQmFkZ2VEZWZpbml0aW9uID0gMzAwMDk7XG52YXIgSW50ZXJlc3RzZXRzID0gMzAwMTU7XG52YXIgQ3JlYXRlT3JVcGRhdGVTdGFsbCA9IDMwMDE3O1xudmFyIENyZWF0ZU9yVXBkYXRlUHJvZHVjdCA9IDMwMDE4O1xudmFyIExvbmdGb3JtQXJ0aWNsZSA9IDMwMDIzO1xudmFyIERyYWZ0TG9uZyA9IDMwMDI0O1xudmFyIEVtb2ppc2V0cyA9IDMwMDMwO1xudmFyIEFwcGxpY2F0aW9uID0gMzAwNzg7XG52YXIgTGl2ZUV2ZW50ID0gMzAzMTE7XG52YXIgVXNlclN0YXR1c2VzID0gMzAzMTU7XG52YXIgQ2xhc3NpZmllZExpc3RpbmcgPSAzMDQwMjtcbnZhciBEcmFmdENsYXNzaWZpZWRMaXN0aW5nID0gMzA0MDM7XG52YXIgRGF0ZTIgPSAzMTkyMjtcbnZhciBUaW1lID0gMzE5MjM7XG52YXIgQ2FsZW5kYXIgPSAzMTkyNDtcbnZhciBDYWxlbmRhckV2ZW50UlNWUCA9IDMxOTI1O1xudmFyIEhhbmRsZXJyZWNvbW1lbmRhdGlvbiA9IDMxOTg5O1xudmFyIEhhbmRsZXJpbmZvcm1hdGlvbiA9IDMxOTkwO1xudmFyIENvbW11bml0eURlZmluaXRpb24gPSAzNDU1MDtcblxuLy8gZmlsdGVyLnRzXG5mdW5jdGlvbiBtYXRjaEZpbHRlcihmaWx0ZXIsIGV2ZW50KSB7XG4gIGlmIChmaWx0ZXIuaWRzICYmIGZpbHRlci5pZHMuaW5kZXhPZihldmVudC5pZCkgPT09IC0xKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChmaWx0ZXIua2luZHMgJiYgZmlsdGVyLmtpbmRzLmluZGV4T2YoZXZlbnQua2luZCkgPT09IC0xKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChmaWx0ZXIuYXV0aG9ycyAmJiBmaWx0ZXIuYXV0aG9ycy5pbmRleE9mKGV2ZW50LnB1YmtleSkgPT09IC0xKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAobGV0IGYgaW4gZmlsdGVyKSB7XG4gICAgaWYgKGZbMF0gPT09IFwiI1wiKSB7XG4gICAgICBsZXQgdGFnTmFtZSA9IGYuc2xpY2UoMSk7XG4gICAgICBsZXQgdmFsdWVzID0gZmlsdGVyW2AjJHt0YWdOYW1lfWBdO1xuICAgICAgaWYgKHZhbHVlcyAmJiAhZXZlbnQudGFncy5maW5kKChbdCwgdl0pID0+IHQgPT09IGYuc2xpY2UoMSkgJiYgdmFsdWVzLmluZGV4T2YodikgIT09IC0xKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAoZmlsdGVyLnNpbmNlICYmIGV2ZW50LmNyZWF0ZWRfYXQgPCBmaWx0ZXIuc2luY2UpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoZmlsdGVyLnVudGlsICYmIGV2ZW50LmNyZWF0ZWRfYXQgPiBmaWx0ZXIudW50aWwpXG4gICAgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIG1hdGNoRmlsdGVycyhmaWx0ZXJzLCBldmVudCkge1xuICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgZmlsdGVycy5sZW5ndGg7IGkyKyspIHtcbiAgICBpZiAobWF0Y2hGaWx0ZXIoZmlsdGVyc1tpMl0sIGV2ZW50KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIG1lcmdlRmlsdGVycyguLi5maWx0ZXJzKSB7XG4gIGxldCByZXN1bHQgPSB7fTtcbiAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IGZpbHRlcnMubGVuZ3RoOyBpMisrKSB7XG4gICAgbGV0IGZpbHRlciA9IGZpbHRlcnNbaTJdO1xuICAgIE9iamVjdC5lbnRyaWVzKGZpbHRlcikuZm9yRWFjaCgoW3Byb3BlcnR5LCB2YWx1ZXNdKSA9PiB7XG4gICAgICBpZiAocHJvcGVydHkgPT09IFwia2luZHNcIiB8fCBwcm9wZXJ0eSA9PT0gXCJpZHNcIiB8fCBwcm9wZXJ0eSA9PT0gXCJhdXRob3JzXCIgfHwgcHJvcGVydHlbMF0gPT09IFwiI1wiKSB7XG4gICAgICAgIHJlc3VsdFtwcm9wZXJ0eV0gPSByZXN1bHRbcHJvcGVydHldIHx8IFtdO1xuICAgICAgICBmb3IgKGxldCB2ID0gMDsgdiA8IHZhbHVlcy5sZW5ndGg7IHYrKykge1xuICAgICAgICAgIGxldCB2YWx1ZSA9IHZhbHVlc1t2XTtcbiAgICAgICAgICBpZiAoIXJlc3VsdFtwcm9wZXJ0eV0uaW5jbHVkZXModmFsdWUpKVxuICAgICAgICAgICAgcmVzdWx0W3Byb3BlcnR5XS5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChmaWx0ZXIubGltaXQgJiYgKCFyZXN1bHQubGltaXQgfHwgZmlsdGVyLmxpbWl0ID4gcmVzdWx0LmxpbWl0KSlcbiAgICAgIHJlc3VsdC5saW1pdCA9IGZpbHRlci5saW1pdDtcbiAgICBpZiAoZmlsdGVyLnVudGlsICYmICghcmVzdWx0LnVudGlsIHx8IGZpbHRlci51bnRpbCA+IHJlc3VsdC51bnRpbCkpXG4gICAgICByZXN1bHQudW50aWwgPSBmaWx0ZXIudW50aWw7XG4gICAgaWYgKGZpbHRlci5zaW5jZSAmJiAoIXJlc3VsdC5zaW5jZSB8fCBmaWx0ZXIuc2luY2UgPCByZXN1bHQuc2luY2UpKVxuICAgICAgcmVzdWx0LnNpbmNlID0gZmlsdGVyLnNpbmNlO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXRGaWx0ZXJMaW1pdChmaWx0ZXIpIHtcbiAgaWYgKGZpbHRlci5pZHMgJiYgIWZpbHRlci5pZHMubGVuZ3RoKVxuICAgIHJldHVybiAwO1xuICBpZiAoZmlsdGVyLmtpbmRzICYmICFmaWx0ZXIua2luZHMubGVuZ3RoKVxuICAgIHJldHVybiAwO1xuICBpZiAoZmlsdGVyLmF1dGhvcnMgJiYgIWZpbHRlci5hdXRob3JzLmxlbmd0aClcbiAgICByZXR1cm4gMDtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoZmlsdGVyKSkge1xuICAgIGlmIChrZXlbMF0gPT09IFwiI1wiICYmIEFycmF5LmlzQXJyYXkodmFsdWUpICYmICF2YWx1ZS5sZW5ndGgpXG4gICAgICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4gTWF0aC5taW4oXG4gICAgTWF0aC5tYXgoMCwgZmlsdGVyLmxpbWl0ID8/IEluZmluaXR5KSxcbiAgICBmaWx0ZXIuaWRzPy5sZW5ndGggPz8gSW5maW5pdHksXG4gICAgZmlsdGVyLmF1dGhvcnM/Lmxlbmd0aCAmJiBmaWx0ZXIua2luZHM/LmV2ZXJ5KChraW5kKSA9PiBpc1JlcGxhY2VhYmxlS2luZChraW5kKSkgPyBmaWx0ZXIuYXV0aG9ycy5sZW5ndGggKiBmaWx0ZXIua2luZHMubGVuZ3RoIDogSW5maW5pdHksXG4gICAgZmlsdGVyLmF1dGhvcnM/Lmxlbmd0aCAmJiBmaWx0ZXIua2luZHM/LmV2ZXJ5KChraW5kKSA9PiBpc1BhcmFtZXRlcml6ZWRSZXBsYWNlYWJsZUtpbmQoa2luZCkpICYmIGZpbHRlcltcIiNkXCJdPy5sZW5ndGggPyBmaWx0ZXIuYXV0aG9ycy5sZW5ndGggKiBmaWx0ZXIua2luZHMubGVuZ3RoICogZmlsdGVyW1wiI2RcIl0ubGVuZ3RoIDogSW5maW5pdHlcbiAgKTtcbn1cblxuLy8gZmFrZWpzb24udHNcbnZhciBmYWtlanNvbl9leHBvcnRzID0ge307XG5fX2V4cG9ydChmYWtlanNvbl9leHBvcnRzLCB7XG4gIGdldEhleDY0OiAoKSA9PiBnZXRIZXg2NCxcbiAgZ2V0SW50OiAoKSA9PiBnZXRJbnQsXG4gIGdldFN1YnNjcmlwdGlvbklkOiAoKSA9PiBnZXRTdWJzY3JpcHRpb25JZCxcbiAgbWF0Y2hFdmVudElkOiAoKSA9PiBtYXRjaEV2ZW50SWQsXG4gIG1hdGNoRXZlbnRLaW5kOiAoKSA9PiBtYXRjaEV2ZW50S2luZCxcbiAgbWF0Y2hFdmVudFB1YmtleTogKCkgPT4gbWF0Y2hFdmVudFB1YmtleVxufSk7XG5mdW5jdGlvbiBnZXRIZXg2NChqc29uLCBmaWVsZCkge1xuICBsZXQgbGVuID0gZmllbGQubGVuZ3RoICsgMztcbiAgbGV0IGlkeCA9IGpzb24uaW5kZXhPZihgXCIke2ZpZWxkfVwiOmApICsgbGVuO1xuICBsZXQgcyA9IGpzb24uc2xpY2UoaWR4KS5pbmRleE9mKGBcImApICsgaWR4ICsgMTtcbiAgcmV0dXJuIGpzb24uc2xpY2UocywgcyArIDY0KTtcbn1cbmZ1bmN0aW9uIGdldEludChqc29uLCBmaWVsZCkge1xuICBsZXQgbGVuID0gZmllbGQubGVuZ3RoO1xuICBsZXQgaWR4ID0ganNvbi5pbmRleE9mKGBcIiR7ZmllbGR9XCI6YCkgKyBsZW4gKyAzO1xuICBsZXQgc2xpY2VkID0ganNvbi5zbGljZShpZHgpO1xuICBsZXQgZW5kID0gTWF0aC5taW4oc2xpY2VkLmluZGV4T2YoXCIsXCIpLCBzbGljZWQuaW5kZXhPZihcIn1cIikpO1xuICByZXR1cm4gcGFyc2VJbnQoc2xpY2VkLnNsaWNlKDAsIGVuZCksIDEwKTtcbn1cbmZ1bmN0aW9uIGdldFN1YnNjcmlwdGlvbklkKGpzb24pIHtcbiAgbGV0IGlkeCA9IGpzb24uc2xpY2UoMCwgMjIpLmluZGV4T2YoYFwiRVZFTlRcImApO1xuICBpZiAoaWR4ID09PSAtMSlcbiAgICByZXR1cm4gbnVsbDtcbiAgbGV0IHBzdGFydCA9IGpzb24uc2xpY2UoaWR4ICsgNyArIDEpLmluZGV4T2YoYFwiYCk7XG4gIGlmIChwc3RhcnQgPT09IC0xKVxuICAgIHJldHVybiBudWxsO1xuICBsZXQgc3RhcnQgPSBpZHggKyA3ICsgMSArIHBzdGFydDtcbiAgbGV0IHBlbmQgPSBqc29uLnNsaWNlKHN0YXJ0ICsgMSwgODApLmluZGV4T2YoYFwiYCk7XG4gIGlmIChwZW5kID09PSAtMSlcbiAgICByZXR1cm4gbnVsbDtcbiAgbGV0IGVuZCA9IHN0YXJ0ICsgMSArIHBlbmQ7XG4gIHJldHVybiBqc29uLnNsaWNlKHN0YXJ0ICsgMSwgZW5kKTtcbn1cbmZ1bmN0aW9uIG1hdGNoRXZlbnRJZChqc29uLCBpZCkge1xuICByZXR1cm4gaWQgPT09IGdldEhleDY0KGpzb24sIFwiaWRcIik7XG59XG5mdW5jdGlvbiBtYXRjaEV2ZW50UHVia2V5KGpzb24sIHB1YmtleSkge1xuICByZXR1cm4gcHVia2V5ID09PSBnZXRIZXg2NChqc29uLCBcInB1YmtleVwiKTtcbn1cbmZ1bmN0aW9uIG1hdGNoRXZlbnRLaW5kKGpzb24sIGtpbmQpIHtcbiAgcmV0dXJuIGtpbmQgPT09IGdldEludChqc29uLCBcImtpbmRcIik7XG59XG5cbi8vIG5pcDQyLnRzXG52YXIgbmlwNDJfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobmlwNDJfZXhwb3J0cywge1xuICBtYWtlQXV0aEV2ZW50OiAoKSA9PiBtYWtlQXV0aEV2ZW50XG59KTtcbmZ1bmN0aW9uIG1ha2VBdXRoRXZlbnQocmVsYXlVUkwsIGNoYWxsZW5nZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IENsaWVudEF1dGgsXG4gICAgY3JlYXRlZF9hdDogTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMWUzKSxcbiAgICB0YWdzOiBbXG4gICAgICBbXCJyZWxheVwiLCByZWxheVVSTF0sXG4gICAgICBbXCJjaGFsbGVuZ2VcIiwgY2hhbGxlbmdlXVxuICAgIF0sXG4gICAgY29udGVudDogXCJcIlxuICB9O1xufVxuXG4vLyBoZWxwZXJzLnRzXG5hc3luYyBmdW5jdGlvbiB5aWVsZFRocmVhZCgpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgY29uc3QgY2ggPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICBjb25zdCBoYW5kbGVyID0gKCkgPT4ge1xuICAgICAgY2gucG9ydDEucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgaGFuZGxlcik7XG4gICAgICByZXNvbHZlKCk7XG4gICAgfTtcbiAgICBjaC5wb3J0MS5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBoYW5kbGVyKTtcbiAgICBjaC5wb3J0Mi5wb3N0TWVzc2FnZSgwKTtcbiAgICBjaC5wb3J0MS5zdGFydCgpO1xuICB9KTtcbn1cbnZhciBhbHdheXNUcnVlID0gKHQpID0+IHtcbiAgdFt2ZXJpZmllZFN5bWJvbF0gPSB0cnVlO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIGFic3RyYWN0LXJlbGF5LnRzXG52YXIgQWJzdHJhY3RSZWxheSA9IGNsYXNzIHtcbiAgdXJsO1xuICBfY29ubmVjdGVkID0gZmFsc2U7XG4gIG9uY2xvc2UgPSBudWxsO1xuICBvbm5vdGljZSA9IChtc2cpID0+IGNvbnNvbGUuZGVidWcoYE5PVElDRSBmcm9tICR7dGhpcy51cmx9OiAke21zZ31gKTtcbiAgX29uYXV0aCA9IG51bGw7XG4gIGJhc2VFb3NlVGltZW91dCA9IDQ0MDA7XG4gIGNvbm5lY3Rpb25UaW1lb3V0ID0gNDQwMDtcbiAgcHVibGlzaFRpbWVvdXQgPSA0NDAwO1xuICBvcGVuU3VicyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbm5lY3Rpb25UaW1lb3V0SGFuZGxlO1xuICBjb25uZWN0aW9uUHJvbWlzZTtcbiAgb3BlbkNvdW50UmVxdWVzdHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBvcGVuRXZlbnRQdWJsaXNoZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB3cztcbiAgaW5jb21pbmdNZXNzYWdlUXVldWUgPSBuZXcgUXVldWUoKTtcbiAgcXVldWVSdW5uaW5nID0gZmFsc2U7XG4gIGNoYWxsZW5nZTtcbiAgc2VyaWFsID0gMDtcbiAgdmVyaWZ5RXZlbnQ7XG4gIF9XZWJTb2NrZXQ7XG4gIGNvbnN0cnVjdG9yKHVybCwgb3B0cykge1xuICAgIHRoaXMudXJsID0gbm9ybWFsaXplVVJMKHVybCk7XG4gICAgdGhpcy52ZXJpZnlFdmVudCA9IG9wdHMudmVyaWZ5RXZlbnQ7XG4gICAgdGhpcy5fV2ViU29ja2V0ID0gb3B0cy53ZWJzb2NrZXRJbXBsZW1lbnRhdGlvbiB8fCBXZWJTb2NrZXQ7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGNvbm5lY3QodXJsLCBvcHRzKSB7XG4gICAgY29uc3QgcmVsYXkgPSBuZXcgQWJzdHJhY3RSZWxheSh1cmwsIG9wdHMpO1xuICAgIGF3YWl0IHJlbGF5LmNvbm5lY3QoKTtcbiAgICByZXR1cm4gcmVsYXk7XG4gIH1cbiAgY2xvc2VBbGxTdWJzY3JpcHRpb25zKHJlYXNvbikge1xuICAgIGZvciAobGV0IFtfLCBzdWJdIG9mIHRoaXMub3BlblN1YnMpIHtcbiAgICAgIHN1Yi5jbG9zZShyZWFzb24pO1xuICAgIH1cbiAgICB0aGlzLm9wZW5TdWJzLmNsZWFyKCk7XG4gICAgZm9yIChsZXQgW18sIGVwXSBvZiB0aGlzLm9wZW5FdmVudFB1Ymxpc2hlcykge1xuICAgICAgZXAucmVqZWN0KG5ldyBFcnJvcihyZWFzb24pKTtcbiAgICB9XG4gICAgdGhpcy5vcGVuRXZlbnRQdWJsaXNoZXMuY2xlYXIoKTtcbiAgICBmb3IgKGxldCBbXywgY3JdIG9mIHRoaXMub3BlbkNvdW50UmVxdWVzdHMpIHtcbiAgICAgIGNyLnJlamVjdChuZXcgRXJyb3IocmVhc29uKSk7XG4gICAgfVxuICAgIHRoaXMub3BlbkNvdW50UmVxdWVzdHMuY2xlYXIoKTtcbiAgfVxuICBnZXQgY29ubmVjdGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25uZWN0ZWQ7XG4gIH1cbiAgYXN5bmMgY29ubmVjdCgpIHtcbiAgICBpZiAodGhpcy5jb25uZWN0aW9uUHJvbWlzZSlcbiAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb25Qcm9taXNlO1xuICAgIHRoaXMuY2hhbGxlbmdlID0gdm9pZCAwO1xuICAgIHRoaXMuY29ubmVjdGlvblByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLmNvbm5lY3Rpb25UaW1lb3V0SGFuZGxlID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHJlamVjdChcImNvbm5lY3Rpb24gdGltZWQgb3V0XCIpO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25Qcm9taXNlID0gdm9pZCAwO1xuICAgICAgICB0aGlzLm9uY2xvc2U/LigpO1xuICAgICAgICB0aGlzLmNsb3NlQWxsU3Vic2NyaXB0aW9ucyhcInJlbGF5IGNvbm5lY3Rpb24gdGltZWQgb3V0XCIpO1xuICAgICAgfSwgdGhpcy5jb25uZWN0aW9uVGltZW91dCk7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLndzID0gbmV3IHRoaXMuX1dlYlNvY2tldCh0aGlzLnVybCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMud3Mub25vcGVuID0gKCkgPT4ge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5jb25uZWN0aW9uVGltZW91dEhhbmRsZSk7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH07XG4gICAgICB0aGlzLndzLm9uZXJyb3IgPSAoZXYpID0+IHtcbiAgICAgICAgcmVqZWN0KGV2Lm1lc3NhZ2UgfHwgXCJ3ZWJzb2NrZXQgZXJyb3JcIik7XG4gICAgICAgIGlmICh0aGlzLl9jb25uZWN0ZWQpIHtcbiAgICAgICAgICB0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25Qcm9taXNlID0gdm9pZCAwO1xuICAgICAgICAgIHRoaXMub25jbG9zZT8uKCk7XG4gICAgICAgICAgdGhpcy5jbG9zZUFsbFN1YnNjcmlwdGlvbnMoXCJyZWxheSBjb25uZWN0aW9uIGVycm9yZWRcIik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLndzLm9uY2xvc2UgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLl9jb25uZWN0ZWQpIHtcbiAgICAgICAgICB0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25Qcm9taXNlID0gdm9pZCAwO1xuICAgICAgICAgIHRoaXMub25jbG9zZT8uKCk7XG4gICAgICAgICAgdGhpcy5jbG9zZUFsbFN1YnNjcmlwdGlvbnMoXCJyZWxheSBjb25uZWN0aW9uIGNsb3NlZFwiKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHRoaXMud3Mub25tZXNzYWdlID0gdGhpcy5fb25tZXNzYWdlLmJpbmQodGhpcyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvblByb21pc2U7XG4gIH1cbiAgYXN5bmMgcnVuUXVldWUoKSB7XG4gICAgdGhpcy5xdWV1ZVJ1bm5pbmcgPSB0cnVlO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAoZmFsc2UgPT09IHRoaXMuaGFuZGxlTmV4dCgpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgYXdhaXQgeWllbGRUaHJlYWQoKTtcbiAgICB9XG4gICAgdGhpcy5xdWV1ZVJ1bm5pbmcgPSBmYWxzZTtcbiAgfVxuICBoYW5kbGVOZXh0KCkge1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLmluY29taW5nTWVzc2FnZVF1ZXVlLmRlcXVldWUoKTtcbiAgICBpZiAoIWpzb24pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qgc3ViaWQgPSBnZXRTdWJzY3JpcHRpb25JZChqc29uKTtcbiAgICBpZiAoc3ViaWQpIHtcbiAgICAgIGNvbnN0IHNvID0gdGhpcy5vcGVuU3Vicy5nZXQoc3ViaWQpO1xuICAgICAgaWYgKCFzbykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBpZCA9IGdldEhleDY0KGpzb24sIFwiaWRcIik7XG4gICAgICBjb25zdCBhbHJlYWR5SGF2ZSA9IHNvLmFscmVhZHlIYXZlRXZlbnQ/LihpZCk7XG4gICAgICBzby5yZWNlaXZlZEV2ZW50Py4odGhpcywgaWQpO1xuICAgICAgaWYgKGFscmVhZHlIYXZlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGxldCBkYXRhID0gSlNPTi5wYXJzZShqc29uKTtcbiAgICAgIHN3aXRjaCAoZGF0YVswXSkge1xuICAgICAgICBjYXNlIFwiRVZFTlRcIjoge1xuICAgICAgICAgIGNvbnN0IHNvID0gdGhpcy5vcGVuU3Vicy5nZXQoZGF0YVsxXSk7XG4gICAgICAgICAgY29uc3QgZXZlbnQgPSBkYXRhWzJdO1xuICAgICAgICAgIGlmICh0aGlzLnZlcmlmeUV2ZW50KGV2ZW50KSAmJiBtYXRjaEZpbHRlcnMoc28uZmlsdGVycywgZXZlbnQpKSB7XG4gICAgICAgICAgICBzby5vbmV2ZW50KGV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJDT1VOVFwiOiB7XG4gICAgICAgICAgY29uc3QgaWQgPSBkYXRhWzFdO1xuICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBkYXRhWzJdO1xuICAgICAgICAgIGNvbnN0IGNyID0gdGhpcy5vcGVuQ291bnRSZXF1ZXN0cy5nZXQoaWQpO1xuICAgICAgICAgIGlmIChjcikge1xuICAgICAgICAgICAgY3IucmVzb2x2ZShwYXlsb2FkLmNvdW50KTtcbiAgICAgICAgICAgIHRoaXMub3BlbkNvdW50UmVxdWVzdHMuZGVsZXRlKGlkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJFT1NFXCI6IHtcbiAgICAgICAgICBjb25zdCBzbyA9IHRoaXMub3BlblN1YnMuZ2V0KGRhdGFbMV0pO1xuICAgICAgICAgIGlmICghc28pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgc28ucmVjZWl2ZWRFb3NlKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJPS1wiOiB7XG4gICAgICAgICAgY29uc3QgaWQgPSBkYXRhWzFdO1xuICAgICAgICAgIGNvbnN0IG9rID0gZGF0YVsyXTtcbiAgICAgICAgICBjb25zdCByZWFzb24gPSBkYXRhWzNdO1xuICAgICAgICAgIGNvbnN0IGVwID0gdGhpcy5vcGVuRXZlbnRQdWJsaXNoZXMuZ2V0KGlkKTtcbiAgICAgICAgICBpZiAoZXApIHtcbiAgICAgICAgICAgIGlmIChvaylcbiAgICAgICAgICAgICAgZXAucmVzb2x2ZShyZWFzb24pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBlcC5yZWplY3QobmV3IEVycm9yKHJlYXNvbikpO1xuICAgICAgICAgICAgdGhpcy5vcGVuRXZlbnRQdWJsaXNoZXMuZGVsZXRlKGlkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJDTE9TRURcIjoge1xuICAgICAgICAgIGNvbnN0IGlkID0gZGF0YVsxXTtcbiAgICAgICAgICBjb25zdCBzbyA9IHRoaXMub3BlblN1YnMuZ2V0KGlkKTtcbiAgICAgICAgICBpZiAoIXNvKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIHNvLmNsb3NlZCA9IHRydWU7XG4gICAgICAgICAgc28uY2xvc2UoZGF0YVsyXSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJOT1RJQ0VcIjpcbiAgICAgICAgICB0aGlzLm9ubm90aWNlKGRhdGFbMV0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSBcIkFVVEhcIjoge1xuICAgICAgICAgIHRoaXMuY2hhbGxlbmdlID0gZGF0YVsxXTtcbiAgICAgICAgICB0aGlzLl9vbmF1dGg/LihkYXRhWzFdKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgYXN5bmMgc2VuZChtZXNzYWdlKSB7XG4gICAgaWYgKCF0aGlzLmNvbm5lY3Rpb25Qcm9taXNlKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2VuZGluZyBvbiBjbG9zZWQgY29ubmVjdGlvblwiKTtcbiAgICB0aGlzLmNvbm5lY3Rpb25Qcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgdGhpcy53cz8uc2VuZChtZXNzYWdlKTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBhdXRoKHNpZ25BdXRoRXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuY2hhbGxlbmdlKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2FuJ3QgcGVyZm9ybSBhdXRoLCBubyBjaGFsbGVuZ2Ugd2FzIHJlY2VpdmVkXCIpO1xuICAgIGNvbnN0IGV2dCA9IGF3YWl0IHNpZ25BdXRoRXZlbnQobWFrZUF1dGhFdmVudCh0aGlzLnVybCwgdGhpcy5jaGFsbGVuZ2UpKTtcbiAgICBjb25zdCByZXQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLm9wZW5FdmVudFB1Ymxpc2hlcy5zZXQoZXZ0LmlkLCB7IHJlc29sdmUsIHJlamVjdCB9KTtcbiAgICB9KTtcbiAgICB0aGlzLnNlbmQoJ1tcIkFVVEhcIiwnICsgSlNPTi5zdHJpbmdpZnkoZXZ0KSArIFwiXVwiKTtcbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGFzeW5jIHB1Ymxpc2goZXZlbnQpIHtcbiAgICBjb25zdCByZXQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLm9wZW5FdmVudFB1Ymxpc2hlcy5zZXQoZXZlbnQuaWQsIHsgcmVzb2x2ZSwgcmVqZWN0IH0pO1xuICAgIH0pO1xuICAgIHRoaXMuc2VuZCgnW1wiRVZFTlRcIiwnICsgSlNPTi5zdHJpbmdpZnkoZXZlbnQpICsgXCJdXCIpO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgY29uc3QgZXAgPSB0aGlzLm9wZW5FdmVudFB1Ymxpc2hlcy5nZXQoZXZlbnQuaWQpO1xuICAgICAgaWYgKGVwKSB7XG4gICAgICAgIGVwLnJlamVjdChuZXcgRXJyb3IoXCJwdWJsaXNoIHRpbWVkIG91dFwiKSk7XG4gICAgICAgIHRoaXMub3BlbkV2ZW50UHVibGlzaGVzLmRlbGV0ZShldmVudC5pZCk7XG4gICAgICB9XG4gICAgfSwgdGhpcy5wdWJsaXNoVGltZW91dCk7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBhc3luYyBjb3VudChmaWx0ZXJzLCBwYXJhbXMpIHtcbiAgICB0aGlzLnNlcmlhbCsrO1xuICAgIGNvbnN0IGlkID0gcGFyYW1zPy5pZCB8fCBcImNvdW50OlwiICsgdGhpcy5zZXJpYWw7XG4gICAgY29uc3QgcmV0ID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5vcGVuQ291bnRSZXF1ZXN0cy5zZXQoaWQsIHsgcmVzb2x2ZSwgcmVqZWN0IH0pO1xuICAgIH0pO1xuICAgIHRoaXMuc2VuZCgnW1wiQ09VTlRcIixcIicgKyBpZCArICdcIiwnICsgSlNPTi5zdHJpbmdpZnkoZmlsdGVycykuc3Vic3RyaW5nKDEpKTtcbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIHN1YnNjcmliZShmaWx0ZXJzLCBwYXJhbXMpIHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSB0aGlzLnByZXBhcmVTdWJzY3JpcHRpb24oZmlsdGVycywgcGFyYW1zKTtcbiAgICBzdWJzY3JpcHRpb24uZmlyZSgpO1xuICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gIH1cbiAgcHJlcGFyZVN1YnNjcmlwdGlvbihmaWx0ZXJzLCBwYXJhbXMpIHtcbiAgICB0aGlzLnNlcmlhbCsrO1xuICAgIGNvbnN0IGlkID0gcGFyYW1zLmlkIHx8IFwic3ViOlwiICsgdGhpcy5zZXJpYWw7XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbih0aGlzLCBpZCwgZmlsdGVycywgcGFyYW1zKTtcbiAgICB0aGlzLm9wZW5TdWJzLnNldChpZCwgc3Vic2NyaXB0aW9uKTtcbiAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xuICB9XG4gIGNsb3NlKCkge1xuICAgIHRoaXMuY2xvc2VBbGxTdWJzY3JpcHRpb25zKFwicmVsYXkgY29ubmVjdGlvbiBjbG9zZWQgYnkgdXNcIik7XG4gICAgdGhpcy5fY29ubmVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy53cz8uY2xvc2UoKTtcbiAgfVxuICBfb25tZXNzYWdlKGV2KSB7XG4gICAgdGhpcy5pbmNvbWluZ01lc3NhZ2VRdWV1ZS5lbnF1ZXVlKGV2LmRhdGEpO1xuICAgIGlmICghdGhpcy5xdWV1ZVJ1bm5pbmcpIHtcbiAgICAgIHRoaXMucnVuUXVldWUoKTtcbiAgICB9XG4gIH1cbn07XG52YXIgU3Vic2NyaXB0aW9uID0gY2xhc3Mge1xuICByZWxheTtcbiAgaWQ7XG4gIGNsb3NlZCA9IGZhbHNlO1xuICBlb3NlZCA9IGZhbHNlO1xuICBmaWx0ZXJzO1xuICBhbHJlYWR5SGF2ZUV2ZW50O1xuICByZWNlaXZlZEV2ZW50O1xuICBvbmV2ZW50O1xuICBvbmVvc2U7XG4gIG9uY2xvc2U7XG4gIGVvc2VUaW1lb3V0O1xuICBlb3NlVGltZW91dEhhbmRsZTtcbiAgY29uc3RydWN0b3IocmVsYXksIGlkLCBmaWx0ZXJzLCBwYXJhbXMpIHtcbiAgICB0aGlzLnJlbGF5ID0gcmVsYXk7XG4gICAgdGhpcy5maWx0ZXJzID0gZmlsdGVycztcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5hbHJlYWR5SGF2ZUV2ZW50ID0gcGFyYW1zLmFscmVhZHlIYXZlRXZlbnQ7XG4gICAgdGhpcy5yZWNlaXZlZEV2ZW50ID0gcGFyYW1zLnJlY2VpdmVkRXZlbnQ7XG4gICAgdGhpcy5lb3NlVGltZW91dCA9IHBhcmFtcy5lb3NlVGltZW91dCB8fCByZWxheS5iYXNlRW9zZVRpbWVvdXQ7XG4gICAgdGhpcy5vbmVvc2UgPSBwYXJhbXMub25lb3NlO1xuICAgIHRoaXMub25jbG9zZSA9IHBhcmFtcy5vbmNsb3NlO1xuICAgIHRoaXMub25ldmVudCA9IHBhcmFtcy5vbmV2ZW50IHx8ICgoZXZlbnQpID0+IHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYG9uZXZlbnQoKSBjYWxsYmFjayBub3QgZGVmaW5lZCBmb3Igc3Vic2NyaXB0aW9uICcke3RoaXMuaWR9JyBpbiByZWxheSAke3RoaXMucmVsYXkudXJsfS4gZXZlbnQgcmVjZWl2ZWQ6YCxcbiAgICAgICAgZXZlbnRcbiAgICAgICk7XG4gICAgfSk7XG4gIH1cbiAgZmlyZSgpIHtcbiAgICB0aGlzLnJlbGF5LnNlbmQoJ1tcIlJFUVwiLFwiJyArIHRoaXMuaWQgKyAnXCIsJyArIEpTT04uc3RyaW5naWZ5KHRoaXMuZmlsdGVycykuc3Vic3RyaW5nKDEpKTtcbiAgICB0aGlzLmVvc2VUaW1lb3V0SGFuZGxlID0gc2V0VGltZW91dCh0aGlzLnJlY2VpdmVkRW9zZS5iaW5kKHRoaXMpLCB0aGlzLmVvc2VUaW1lb3V0KTtcbiAgfVxuICByZWNlaXZlZEVvc2UoKSB7XG4gICAgaWYgKHRoaXMuZW9zZWQpXG4gICAgICByZXR1cm47XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuZW9zZVRpbWVvdXRIYW5kbGUpO1xuICAgIHRoaXMuZW9zZWQgPSB0cnVlO1xuICAgIHRoaXMub25lb3NlPy4oKTtcbiAgfVxuICBjbG9zZShyZWFzb24gPSBcImNsb3NlZCBieSBjYWxsZXJcIikge1xuICAgIGlmICghdGhpcy5jbG9zZWQgJiYgdGhpcy5yZWxheS5jb25uZWN0ZWQpIHtcbiAgICAgIHRoaXMucmVsYXkuc2VuZCgnW1wiQ0xPU0VcIiwnICsgSlNPTi5zdHJpbmdpZnkodGhpcy5pZCkgKyBcIl1cIik7XG4gICAgICB0aGlzLmNsb3NlZCA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMucmVsYXkub3BlblN1YnMuZGVsZXRlKHRoaXMuaWQpO1xuICAgIHRoaXMub25jbG9zZT8uKHJlYXNvbik7XG4gIH1cbn07XG5cbi8vIHJlbGF5LnRzXG52YXIgX1dlYlNvY2tldDtcbnRyeSB7XG4gIF9XZWJTb2NrZXQgPSBXZWJTb2NrZXQ7XG59IGNhdGNoIHtcbn1cbnZhciBSZWxheSA9IGNsYXNzIGV4dGVuZHMgQWJzdHJhY3RSZWxheSB7XG4gIGNvbnN0cnVjdG9yKHVybCkge1xuICAgIHN1cGVyKHVybCwgeyB2ZXJpZnlFdmVudCwgd2Vic29ja2V0SW1wbGVtZW50YXRpb246IF9XZWJTb2NrZXQgfSk7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGNvbm5lY3QodXJsKSB7XG4gICAgY29uc3QgcmVsYXkgPSBuZXcgUmVsYXkodXJsKTtcbiAgICBhd2FpdCByZWxheS5jb25uZWN0KCk7XG4gICAgcmV0dXJuIHJlbGF5O1xuICB9XG59O1xuXG4vLyBhYnN0cmFjdC1wb29sLnRzXG52YXIgQWJzdHJhY3RTaW1wbGVQb29sID0gY2xhc3Mge1xuICByZWxheXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBzZWVuT24gPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB0cmFja1JlbGF5cyA9IGZhbHNlO1xuICB2ZXJpZnlFdmVudDtcbiAgdHJ1c3RlZFJlbGF5VVJMcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIF9XZWJTb2NrZXQ7XG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICB0aGlzLnZlcmlmeUV2ZW50ID0gb3B0cy52ZXJpZnlFdmVudDtcbiAgICB0aGlzLl9XZWJTb2NrZXQgPSBvcHRzLndlYnNvY2tldEltcGxlbWVudGF0aW9uO1xuICB9XG4gIGFzeW5jIGVuc3VyZVJlbGF5KHVybCwgcGFyYW1zKSB7XG4gICAgdXJsID0gbm9ybWFsaXplVVJMKHVybCk7XG4gICAgbGV0IHJlbGF5ID0gdGhpcy5yZWxheXMuZ2V0KHVybCk7XG4gICAgaWYgKCFyZWxheSkge1xuICAgICAgcmVsYXkgPSBuZXcgQWJzdHJhY3RSZWxheSh1cmwsIHtcbiAgICAgICAgdmVyaWZ5RXZlbnQ6IHRoaXMudHJ1c3RlZFJlbGF5VVJMcy5oYXModXJsKSA/IGFsd2F5c1RydWUgOiB0aGlzLnZlcmlmeUV2ZW50LFxuICAgICAgICB3ZWJzb2NrZXRJbXBsZW1lbnRhdGlvbjogdGhpcy5fV2ViU29ja2V0XG4gICAgICB9KTtcbiAgICAgIGlmIChwYXJhbXM/LmNvbm5lY3Rpb25UaW1lb3V0KVxuICAgICAgICByZWxheS5jb25uZWN0aW9uVGltZW91dCA9IHBhcmFtcy5jb25uZWN0aW9uVGltZW91dDtcbiAgICAgIHRoaXMucmVsYXlzLnNldCh1cmwsIHJlbGF5KTtcbiAgICB9XG4gICAgYXdhaXQgcmVsYXkuY29ubmVjdCgpO1xuICAgIHJldHVybiByZWxheTtcbiAgfVxuICBjbG9zZShyZWxheXMpIHtcbiAgICByZWxheXMubWFwKG5vcm1hbGl6ZVVSTCkuZm9yRWFjaCgodXJsKSA9PiB7XG4gICAgICB0aGlzLnJlbGF5cy5nZXQodXJsKT8uY2xvc2UoKTtcbiAgICB9KTtcbiAgfVxuICBzdWJzY3JpYmVNYW55KHJlbGF5cywgZmlsdGVycywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIHRoaXMuc3Vic2NyaWJlTWFueU1hcChPYmplY3QuZnJvbUVudHJpZXMocmVsYXlzLm1hcCgodXJsKSA9PiBbdXJsLCBmaWx0ZXJzXSkpLCBwYXJhbXMpO1xuICB9XG4gIHN1YnNjcmliZU1hbnlNYXAocmVxdWVzdHMsIHBhcmFtcykge1xuICAgIGlmICh0aGlzLnRyYWNrUmVsYXlzKSB7XG4gICAgICBwYXJhbXMucmVjZWl2ZWRFdmVudCA9IChyZWxheSwgaWQpID0+IHtcbiAgICAgICAgbGV0IHNldCA9IHRoaXMuc2Vlbk9uLmdldChpZCk7XG4gICAgICAgIGlmICghc2V0KSB7XG4gICAgICAgICAgc2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgICAgICB0aGlzLnNlZW5Pbi5zZXQoaWQsIHNldCk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0LmFkZChyZWxheSk7XG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBfa25vd25JZHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGNvbnN0IHN1YnMgPSBbXTtcbiAgICBjb25zdCByZWxheXNMZW5ndGggPSBPYmplY3Qua2V5cyhyZXF1ZXN0cykubGVuZ3RoO1xuICAgIGNvbnN0IGVvc2VzUmVjZWl2ZWQgPSBbXTtcbiAgICBsZXQgaGFuZGxlRW9zZSA9IChpMikgPT4ge1xuICAgICAgZW9zZXNSZWNlaXZlZFtpMl0gPSB0cnVlO1xuICAgICAgaWYgKGVvc2VzUmVjZWl2ZWQuZmlsdGVyKChhKSA9PiBhKS5sZW5ndGggPT09IHJlbGF5c0xlbmd0aCkge1xuICAgICAgICBwYXJhbXMub25lb3NlPy4oKTtcbiAgICAgICAgaGFuZGxlRW9zZSA9ICgpID0+IHtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGNsb3Nlc1JlY2VpdmVkID0gW107XG4gICAgbGV0IGhhbmRsZUNsb3NlID0gKGkyLCByZWFzb24pID0+IHtcbiAgICAgIGhhbmRsZUVvc2UoaTIpO1xuICAgICAgY2xvc2VzUmVjZWl2ZWRbaTJdID0gcmVhc29uO1xuICAgICAgaWYgKGNsb3Nlc1JlY2VpdmVkLmZpbHRlcigoYSkgPT4gYSkubGVuZ3RoID09PSByZWxheXNMZW5ndGgpIHtcbiAgICAgICAgcGFyYW1zLm9uY2xvc2U/LihjbG9zZXNSZWNlaXZlZCk7XG4gICAgICAgIGhhbmRsZUNsb3NlID0gKCkgPT4ge1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgbG9jYWxBbHJlYWR5SGF2ZUV2ZW50SGFuZGxlciA9IChpZCkgPT4ge1xuICAgICAgaWYgKHBhcmFtcy5hbHJlYWR5SGF2ZUV2ZW50Py4oaWQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgaGF2ZSA9IF9rbm93bklkcy5oYXMoaWQpO1xuICAgICAgX2tub3duSWRzLmFkZChpZCk7XG4gICAgICByZXR1cm4gaGF2ZTtcbiAgICB9O1xuICAgIGNvbnN0IGFsbE9wZW5lZCA9IFByb21pc2UuYWxsKFxuICAgICAgT2JqZWN0LmVudHJpZXMocmVxdWVzdHMpLm1hcChhc3luYyAocmVxLCBpMiwgYXJyKSA9PiB7XG4gICAgICAgIGlmIChhcnIuaW5kZXhPZihyZXEpICE9PSBpMikge1xuICAgICAgICAgIGhhbmRsZUNsb3NlKGkyLCBcImR1cGxpY2F0ZSB1cmxcIik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBbdXJsLCBmaWx0ZXJzXSA9IHJlcTtcbiAgICAgICAgdXJsID0gbm9ybWFsaXplVVJMKHVybCk7XG4gICAgICAgIGxldCByZWxheTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZWxheSA9IGF3YWl0IHRoaXMuZW5zdXJlUmVsYXkodXJsLCB7XG4gICAgICAgICAgICBjb25uZWN0aW9uVGltZW91dDogcGFyYW1zLm1heFdhaXQgPyBNYXRoLm1heChwYXJhbXMubWF4V2FpdCAqIDAuOCwgcGFyYW1zLm1heFdhaXQgLSAxZTMpIDogdm9pZCAwXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGhhbmRsZUNsb3NlKGkyLCBlcnI/Lm1lc3NhZ2UgfHwgU3RyaW5nKGVycikpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3Vic2NyaXB0aW9uID0gcmVsYXkuc3Vic2NyaWJlKGZpbHRlcnMsIHtcbiAgICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgICAgb25lb3NlOiAoKSA9PiBoYW5kbGVFb3NlKGkyKSxcbiAgICAgICAgICBvbmNsb3NlOiAocmVhc29uKSA9PiBoYW5kbGVDbG9zZShpMiwgcmVhc29uKSxcbiAgICAgICAgICBhbHJlYWR5SGF2ZUV2ZW50OiBsb2NhbEFscmVhZHlIYXZlRXZlbnRIYW5kbGVyLFxuICAgICAgICAgIGVvc2VUaW1lb3V0OiBwYXJhbXMubWF4V2FpdFxuICAgICAgICB9KTtcbiAgICAgICAgc3Vicy5wdXNoKHN1YnNjcmlwdGlvbik7XG4gICAgICB9KVxuICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFzeW5jIGNsb3NlKCkge1xuICAgICAgICBhd2FpdCBhbGxPcGVuZWQ7XG4gICAgICAgIHN1YnMuZm9yRWFjaCgoc3ViKSA9PiB7XG4gICAgICAgICAgc3ViLmNsb3NlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgc3Vic2NyaWJlTWFueUVvc2UocmVsYXlzLCBmaWx0ZXJzLCBwYXJhbXMpIHtcbiAgICBjb25zdCBzdWJjbG9zZXIgPSB0aGlzLnN1YnNjcmliZU1hbnkocmVsYXlzLCBmaWx0ZXJzLCB7XG4gICAgICAuLi5wYXJhbXMsXG4gICAgICBvbmVvc2UoKSB7XG4gICAgICAgIHN1YmNsb3Nlci5jbG9zZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzdWJjbG9zZXI7XG4gIH1cbiAgYXN5bmMgcXVlcnlTeW5jKHJlbGF5cywgZmlsdGVyLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUpID0+IHtcbiAgICAgIGNvbnN0IGV2ZW50cyA9IFtdO1xuICAgICAgdGhpcy5zdWJzY3JpYmVNYW55RW9zZShyZWxheXMsIFtmaWx0ZXJdLCB7XG4gICAgICAgIC4uLnBhcmFtcyxcbiAgICAgICAgb25ldmVudChldmVudCkge1xuICAgICAgICAgIGV2ZW50cy5wdXNoKGV2ZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25jbG9zZShfKSB7XG4gICAgICAgICAgcmVzb2x2ZShldmVudHMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBnZXQocmVsYXlzLCBmaWx0ZXIsIHBhcmFtcykge1xuICAgIGZpbHRlci5saW1pdCA9IDE7XG4gICAgY29uc3QgZXZlbnRzID0gYXdhaXQgdGhpcy5xdWVyeVN5bmMocmVsYXlzLCBmaWx0ZXIsIHBhcmFtcyk7XG4gICAgZXZlbnRzLnNvcnQoKGEsIGIpID0+IGIuY3JlYXRlZF9hdCAtIGEuY3JlYXRlZF9hdCk7XG4gICAgcmV0dXJuIGV2ZW50c1swXSB8fCBudWxsO1xuICB9XG4gIHB1Ymxpc2gocmVsYXlzLCBldmVudCkge1xuICAgIHJldHVybiByZWxheXMubWFwKG5vcm1hbGl6ZVVSTCkubWFwKGFzeW5jICh1cmwsIGkyLCBhcnIpID0+IHtcbiAgICAgIGlmIChhcnIuaW5kZXhPZih1cmwpICE9PSBpMikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXCJkdXBsaWNhdGUgdXJsXCIpO1xuICAgICAgfVxuICAgICAgbGV0IHIgPSBhd2FpdCB0aGlzLmVuc3VyZVJlbGF5KHVybCk7XG4gICAgICByZXR1cm4gci5wdWJsaXNoKGV2ZW50KS50aGVuKChyZWFzb24pID0+IHtcbiAgICAgICAgaWYgKHRoaXMudHJhY2tSZWxheXMpIHtcbiAgICAgICAgICBsZXQgc2V0ID0gdGhpcy5zZWVuT24uZ2V0KGV2ZW50LmlkKTtcbiAgICAgICAgICBpZiAoIXNldCkge1xuICAgICAgICAgICAgc2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgICAgICAgIHRoaXMuc2Vlbk9uLnNldChldmVudC5pZCwgc2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2V0LmFkZChyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVhc29uO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgbGlzdENvbm5lY3Rpb25TdGF0dXMoKSB7XG4gICAgY29uc3QgbWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLnJlbGF5cy5mb3JFYWNoKChyZWxheSwgdXJsKSA9PiBtYXAuc2V0KHVybCwgcmVsYXkuY29ubmVjdGVkKSk7XG4gICAgcmV0dXJuIG1hcDtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMucmVsYXlzLmZvckVhY2goKGNvbm4pID0+IGNvbm4uY2xvc2UoKSk7XG4gICAgdGhpcy5yZWxheXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG59O1xuXG4vLyBwb29sLnRzXG52YXIgX1dlYlNvY2tldDI7XG50cnkge1xuICBfV2ViU29ja2V0MiA9IFdlYlNvY2tldDtcbn0gY2F0Y2gge1xufVxudmFyIFNpbXBsZVBvb2wgPSBjbGFzcyBleHRlbmRzIEFic3RyYWN0U2ltcGxlUG9vbCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKHsgdmVyaWZ5RXZlbnQsIHdlYnNvY2tldEltcGxlbWVudGF0aW9uOiBfV2ViU29ja2V0MiB9KTtcbiAgfVxufTtcblxuLy8gbmlwMTkudHNcbnZhciBuaXAxOV9leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXAxOV9leHBvcnRzLCB7XG4gIEJFQ0gzMl9SRUdFWDogKCkgPT4gQkVDSDMyX1JFR0VYLFxuICBCZWNoMzJNYXhTaXplOiAoKSA9PiBCZWNoMzJNYXhTaXplLFxuICBOb3N0clR5cGVHdWFyZDogKCkgPT4gTm9zdHJUeXBlR3VhcmQsXG4gIGRlY29kZTogKCkgPT4gZGVjb2RlLFxuICBlbmNvZGVCeXRlczogKCkgPT4gZW5jb2RlQnl0ZXMsXG4gIG5hZGRyRW5jb2RlOiAoKSA9PiBuYWRkckVuY29kZSxcbiAgbmV2ZW50RW5jb2RlOiAoKSA9PiBuZXZlbnRFbmNvZGUsXG4gIG5vdGVFbmNvZGU6ICgpID0+IG5vdGVFbmNvZGUsXG4gIG5wcm9maWxlRW5jb2RlOiAoKSA9PiBucHJvZmlsZUVuY29kZSxcbiAgbnB1YkVuY29kZTogKCkgPT4gbnB1YkVuY29kZSxcbiAgbnNlY0VuY29kZTogKCkgPT4gbnNlY0VuY29kZVxufSk7XG5pbXBvcnQgeyBieXRlc1RvSGV4IGFzIGJ5dGVzVG9IZXgyLCBjb25jYXRCeXRlcywgaGV4VG9CeXRlcyB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3V0aWxzXCI7XG5pbXBvcnQgeyBiZWNoMzIgfSBmcm9tIFwiQHNjdXJlL2Jhc2VcIjtcbnZhciBOb3N0clR5cGVHdWFyZCA9IHtcbiAgaXNOUHJvZmlsZTogKHZhbHVlKSA9PiAvXm5wcm9maWxlMVthLXpcXGRdKyQvLnRlc3QodmFsdWUgfHwgXCJcIiksXG4gIGlzTkV2ZW50OiAodmFsdWUpID0+IC9ebmV2ZW50MVthLXpcXGRdKyQvLnRlc3QodmFsdWUgfHwgXCJcIiksXG4gIGlzTkFkZHI6ICh2YWx1ZSkgPT4gL15uYWRkcjFbYS16XFxkXSskLy50ZXN0KHZhbHVlIHx8IFwiXCIpLFxuICBpc05TZWM6ICh2YWx1ZSkgPT4gL15uc2VjMVthLXpcXGRdezU4fSQvLnRlc3QodmFsdWUgfHwgXCJcIiksXG4gIGlzTlB1YjogKHZhbHVlKSA9PiAvXm5wdWIxW2EtelxcZF17NTh9JC8udGVzdCh2YWx1ZSB8fCBcIlwiKSxcbiAgaXNOb3RlOiAodmFsdWUpID0+IC9ebm90ZTFbYS16XFxkXSskLy50ZXN0KHZhbHVlIHx8IFwiXCIpLFxuICBpc05jcnlwdHNlYzogKHZhbHVlKSA9PiAvXm5jcnlwdHNlYzFbYS16XFxkXSskLy50ZXN0KHZhbHVlIHx8IFwiXCIpXG59O1xudmFyIEJlY2gzMk1heFNpemUgPSA1ZTM7XG52YXIgQkVDSDMyX1JFR0VYID0gL1tcXHgyMS1cXHg3RV17MSw4M30xWzAyMzQ1Njc4OWFjZGVmZ2hqa2xtbnBxcnN0dXZ3eHl6XXs2LH0vO1xuZnVuY3Rpb24gaW50ZWdlclRvVWludDhBcnJheShudW1iZXIpIHtcbiAgY29uc3QgdWludDhBcnJheSA9IG5ldyBVaW50OEFycmF5KDQpO1xuICB1aW50OEFycmF5WzBdID0gbnVtYmVyID4+IDI0ICYgMjU1O1xuICB1aW50OEFycmF5WzFdID0gbnVtYmVyID4+IDE2ICYgMjU1O1xuICB1aW50OEFycmF5WzJdID0gbnVtYmVyID4+IDggJiAyNTU7XG4gIHVpbnQ4QXJyYXlbM10gPSBudW1iZXIgJiAyNTU7XG4gIHJldHVybiB1aW50OEFycmF5O1xufVxuZnVuY3Rpb24gZGVjb2RlKG5pcDE5KSB7XG4gIGxldCB7IHByZWZpeCwgd29yZHMgfSA9IGJlY2gzMi5kZWNvZGUobmlwMTksIEJlY2gzMk1heFNpemUpO1xuICBsZXQgZGF0YSA9IG5ldyBVaW50OEFycmF5KGJlY2gzMi5mcm9tV29yZHMod29yZHMpKTtcbiAgc3dpdGNoIChwcmVmaXgpIHtcbiAgICBjYXNlIFwibnByb2ZpbGVcIjoge1xuICAgICAgbGV0IHRsdiA9IHBhcnNlVExWKGRhdGEpO1xuICAgICAgaWYgKCF0bHZbMF0/LlswXSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBUTFYgMCBmb3IgbnByb2ZpbGVcIik7XG4gICAgICBpZiAodGx2WzBdWzBdLmxlbmd0aCAhPT0gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRMViAwIHNob3VsZCBiZSAzMiBieXRlc1wiKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwibnByb2ZpbGVcIixcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHB1YmtleTogYnl0ZXNUb0hleDIodGx2WzBdWzBdKSxcbiAgICAgICAgICByZWxheXM6IHRsdlsxXSA/IHRsdlsxXS5tYXAoKGQpID0+IHV0ZjhEZWNvZGVyLmRlY29kZShkKSkgOiBbXVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFwibmV2ZW50XCI6IHtcbiAgICAgIGxldCB0bHYgPSBwYXJzZVRMVihkYXRhKTtcbiAgICAgIGlmICghdGx2WzBdPy5bMF0pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgVExWIDAgZm9yIG5ldmVudFwiKTtcbiAgICAgIGlmICh0bHZbMF1bMF0ubGVuZ3RoICE9PSAzMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVExWIDAgc2hvdWxkIGJlIDMyIGJ5dGVzXCIpO1xuICAgICAgaWYgKHRsdlsyXSAmJiB0bHZbMl1bMF0ubGVuZ3RoICE9PSAzMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVExWIDIgc2hvdWxkIGJlIDMyIGJ5dGVzXCIpO1xuICAgICAgaWYgKHRsdlszXSAmJiB0bHZbM11bMF0ubGVuZ3RoICE9PSA0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUTFYgMyBzaG91bGQgYmUgNCBieXRlc1wiKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwibmV2ZW50XCIsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBpZDogYnl0ZXNUb0hleDIodGx2WzBdWzBdKSxcbiAgICAgICAgICByZWxheXM6IHRsdlsxXSA/IHRsdlsxXS5tYXAoKGQpID0+IHV0ZjhEZWNvZGVyLmRlY29kZShkKSkgOiBbXSxcbiAgICAgICAgICBhdXRob3I6IHRsdlsyXT8uWzBdID8gYnl0ZXNUb0hleDIodGx2WzJdWzBdKSA6IHZvaWQgMCxcbiAgICAgICAgICBraW5kOiB0bHZbM10/LlswXSA/IHBhcnNlSW50KGJ5dGVzVG9IZXgyKHRsdlszXVswXSksIDE2KSA6IHZvaWQgMFxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFwibmFkZHJcIjoge1xuICAgICAgbGV0IHRsdiA9IHBhcnNlVExWKGRhdGEpO1xuICAgICAgaWYgKCF0bHZbMF0/LlswXSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBUTFYgMCBmb3IgbmFkZHJcIik7XG4gICAgICBpZiAoIXRsdlsyXT8uWzBdKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIFRMViAyIGZvciBuYWRkclwiKTtcbiAgICAgIGlmICh0bHZbMl1bMF0ubGVuZ3RoICE9PSAzMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVExWIDIgc2hvdWxkIGJlIDMyIGJ5dGVzXCIpO1xuICAgICAgaWYgKCF0bHZbM10/LlswXSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBUTFYgMyBmb3IgbmFkZHJcIik7XG4gICAgICBpZiAodGx2WzNdWzBdLmxlbmd0aCAhPT0gNClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVExWIDMgc2hvdWxkIGJlIDQgYnl0ZXNcIik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIm5hZGRyXCIsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBpZGVudGlmaWVyOiB1dGY4RGVjb2Rlci5kZWNvZGUodGx2WzBdWzBdKSxcbiAgICAgICAgICBwdWJrZXk6IGJ5dGVzVG9IZXgyKHRsdlsyXVswXSksXG4gICAgICAgICAga2luZDogcGFyc2VJbnQoYnl0ZXNUb0hleDIodGx2WzNdWzBdKSwgMTYpLFxuICAgICAgICAgIHJlbGF5czogdGx2WzFdID8gdGx2WzFdLm1hcCgoZCkgPT4gdXRmOERlY29kZXIuZGVjb2RlKGQpKSA6IFtdXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgXCJuc2VjXCI6XG4gICAgICByZXR1cm4geyB0eXBlOiBwcmVmaXgsIGRhdGEgfTtcbiAgICBjYXNlIFwibnB1YlwiOlxuICAgIGNhc2UgXCJub3RlXCI6XG4gICAgICByZXR1cm4geyB0eXBlOiBwcmVmaXgsIGRhdGE6IGJ5dGVzVG9IZXgyKGRhdGEpIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5rbm93biBwcmVmaXggJHtwcmVmaXh9YCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnNlVExWKGRhdGEpIHtcbiAgbGV0IHJlc3VsdCA9IHt9O1xuICBsZXQgcmVzdCA9IGRhdGE7XG4gIHdoaWxlIChyZXN0Lmxlbmd0aCA+IDApIHtcbiAgICBsZXQgdCA9IHJlc3RbMF07XG4gICAgbGV0IGwgPSByZXN0WzFdO1xuICAgIGxldCB2ID0gcmVzdC5zbGljZSgyLCAyICsgbCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMiArIGwpO1xuICAgIGlmICh2Lmxlbmd0aCA8IGwpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYG5vdCBlbm91Z2ggZGF0YSB0byByZWFkIG9uIFRMViAke3R9YCk7XG4gICAgcmVzdWx0W3RdID0gcmVzdWx0W3RdIHx8IFtdO1xuICAgIHJlc3VsdFt0XS5wdXNoKHYpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBuc2VjRW5jb2RlKGtleSkge1xuICByZXR1cm4gZW5jb2RlQnl0ZXMoXCJuc2VjXCIsIGtleSk7XG59XG5mdW5jdGlvbiBucHViRW5jb2RlKGhleCkge1xuICByZXR1cm4gZW5jb2RlQnl0ZXMoXCJucHViXCIsIGhleFRvQnl0ZXMoaGV4KSk7XG59XG5mdW5jdGlvbiBub3RlRW5jb2RlKGhleCkge1xuICByZXR1cm4gZW5jb2RlQnl0ZXMoXCJub3RlXCIsIGhleFRvQnl0ZXMoaGV4KSk7XG59XG5mdW5jdGlvbiBlbmNvZGVCZWNoMzIocHJlZml4LCBkYXRhKSB7XG4gIGxldCB3b3JkcyA9IGJlY2gzMi50b1dvcmRzKGRhdGEpO1xuICByZXR1cm4gYmVjaDMyLmVuY29kZShwcmVmaXgsIHdvcmRzLCBCZWNoMzJNYXhTaXplKTtcbn1cbmZ1bmN0aW9uIGVuY29kZUJ5dGVzKHByZWZpeCwgYnl0ZXMpIHtcbiAgcmV0dXJuIGVuY29kZUJlY2gzMihwcmVmaXgsIGJ5dGVzKTtcbn1cbmZ1bmN0aW9uIG5wcm9maWxlRW5jb2RlKHByb2ZpbGUpIHtcbiAgbGV0IGRhdGEgPSBlbmNvZGVUTFYoe1xuICAgIDA6IFtoZXhUb0J5dGVzKHByb2ZpbGUucHVia2V5KV0sXG4gICAgMTogKHByb2ZpbGUucmVsYXlzIHx8IFtdKS5tYXAoKHVybCkgPT4gdXRmOEVuY29kZXIuZW5jb2RlKHVybCkpXG4gIH0pO1xuICByZXR1cm4gZW5jb2RlQmVjaDMyKFwibnByb2ZpbGVcIiwgZGF0YSk7XG59XG5mdW5jdGlvbiBuZXZlbnRFbmNvZGUoZXZlbnQpIHtcbiAgbGV0IGtpbmRBcnJheTtcbiAgaWYgKGV2ZW50LmtpbmQgIT09IHZvaWQgMCkge1xuICAgIGtpbmRBcnJheSA9IGludGVnZXJUb1VpbnQ4QXJyYXkoZXZlbnQua2luZCk7XG4gIH1cbiAgbGV0IGRhdGEgPSBlbmNvZGVUTFYoe1xuICAgIDA6IFtoZXhUb0J5dGVzKGV2ZW50LmlkKV0sXG4gICAgMTogKGV2ZW50LnJlbGF5cyB8fCBbXSkubWFwKCh1cmwpID0+IHV0ZjhFbmNvZGVyLmVuY29kZSh1cmwpKSxcbiAgICAyOiBldmVudC5hdXRob3IgPyBbaGV4VG9CeXRlcyhldmVudC5hdXRob3IpXSA6IFtdLFxuICAgIDM6IGtpbmRBcnJheSA/IFtuZXcgVWludDhBcnJheShraW5kQXJyYXkpXSA6IFtdXG4gIH0pO1xuICByZXR1cm4gZW5jb2RlQmVjaDMyKFwibmV2ZW50XCIsIGRhdGEpO1xufVxuZnVuY3Rpb24gbmFkZHJFbmNvZGUoYWRkcikge1xuICBsZXQga2luZCA9IG5ldyBBcnJheUJ1ZmZlcig0KTtcbiAgbmV3IERhdGFWaWV3KGtpbmQpLnNldFVpbnQzMigwLCBhZGRyLmtpbmQsIGZhbHNlKTtcbiAgbGV0IGRhdGEgPSBlbmNvZGVUTFYoe1xuICAgIDA6IFt1dGY4RW5jb2Rlci5lbmNvZGUoYWRkci5pZGVudGlmaWVyKV0sXG4gICAgMTogKGFkZHIucmVsYXlzIHx8IFtdKS5tYXAoKHVybCkgPT4gdXRmOEVuY29kZXIuZW5jb2RlKHVybCkpLFxuICAgIDI6IFtoZXhUb0J5dGVzKGFkZHIucHVia2V5KV0sXG4gICAgMzogW25ldyBVaW50OEFycmF5KGtpbmQpXVxuICB9KTtcbiAgcmV0dXJuIGVuY29kZUJlY2gzMihcIm5hZGRyXCIsIGRhdGEpO1xufVxuZnVuY3Rpb24gZW5jb2RlVExWKHRsdikge1xuICBsZXQgZW50cmllcyA9IFtdO1xuICBPYmplY3QuZW50cmllcyh0bHYpLnJldmVyc2UoKS5mb3JFYWNoKChbdCwgdnNdKSA9PiB7XG4gICAgdnMuZm9yRWFjaCgodikgPT4ge1xuICAgICAgbGV0IGVudHJ5ID0gbmV3IFVpbnQ4QXJyYXkodi5sZW5ndGggKyAyKTtcbiAgICAgIGVudHJ5LnNldChbcGFyc2VJbnQodCldLCAwKTtcbiAgICAgIGVudHJ5LnNldChbdi5sZW5ndGhdLCAxKTtcbiAgICAgIGVudHJ5LnNldCh2LCAyKTtcbiAgICAgIGVudHJpZXMucHVzaChlbnRyeSk7XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gY29uY2F0Qnl0ZXMoLi4uZW50cmllcyk7XG59XG5cbi8vIHJlZmVyZW5jZXMudHNcbnZhciBtZW50aW9uUmVnZXggPSAvXFxibm9zdHI6KChub3RlfG5wdWJ8bmFkZHJ8bmV2ZW50fG5wcm9maWxlKTFcXHcrKVxcYnwjXFxbKFxcZCspXFxdL2c7XG5mdW5jdGlvbiBwYXJzZVJlZmVyZW5jZXMoZXZ0KSB7XG4gIGxldCByZWZlcmVuY2VzID0gW107XG4gIGZvciAobGV0IHJlZiBvZiBldnQuY29udGVudC5tYXRjaEFsbChtZW50aW9uUmVnZXgpKSB7XG4gICAgaWYgKHJlZlsyXSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IHsgdHlwZSwgZGF0YSB9ID0gZGVjb2RlKHJlZlsxXSk7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgXCJucHViXCI6IHtcbiAgICAgICAgICAgIHJlZmVyZW5jZXMucHVzaCh7XG4gICAgICAgICAgICAgIHRleHQ6IHJlZlswXSxcbiAgICAgICAgICAgICAgcHJvZmlsZTogeyBwdWJrZXk6IGRhdGEsIHJlbGF5czogW10gfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIm5wcm9maWxlXCI6IHtcbiAgICAgICAgICAgIHJlZmVyZW5jZXMucHVzaCh7XG4gICAgICAgICAgICAgIHRleHQ6IHJlZlswXSxcbiAgICAgICAgICAgICAgcHJvZmlsZTogZGF0YVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIm5vdGVcIjoge1xuICAgICAgICAgICAgcmVmZXJlbmNlcy5wdXNoKHtcbiAgICAgICAgICAgICAgdGV4dDogcmVmWzBdLFxuICAgICAgICAgICAgICBldmVudDogeyBpZDogZGF0YSwgcmVsYXlzOiBbXSB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwibmV2ZW50XCI6IHtcbiAgICAgICAgICAgIHJlZmVyZW5jZXMucHVzaCh7XG4gICAgICAgICAgICAgIHRleHQ6IHJlZlswXSxcbiAgICAgICAgICAgICAgZXZlbnQ6IGRhdGFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJuYWRkclwiOiB7XG4gICAgICAgICAgICByZWZlcmVuY2VzLnB1c2goe1xuICAgICAgICAgICAgICB0ZXh0OiByZWZbMF0sXG4gICAgICAgICAgICAgIGFkZHJlc3M6IGRhdGFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJlZlszXSkge1xuICAgICAgbGV0IGlkeCA9IHBhcnNlSW50KHJlZlszXSwgMTApO1xuICAgICAgbGV0IHRhZyA9IGV2dC50YWdzW2lkeF07XG4gICAgICBpZiAoIXRhZylcbiAgICAgICAgY29udGludWU7XG4gICAgICBzd2l0Y2ggKHRhZ1swXSkge1xuICAgICAgICBjYXNlIFwicFwiOiB7XG4gICAgICAgICAgcmVmZXJlbmNlcy5wdXNoKHtcbiAgICAgICAgICAgIHRleHQ6IHJlZlswXSxcbiAgICAgICAgICAgIHByb2ZpbGU6IHsgcHVia2V5OiB0YWdbMV0sIHJlbGF5czogdGFnWzJdID8gW3RhZ1syXV0gOiBbXSB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImVcIjoge1xuICAgICAgICAgIHJlZmVyZW5jZXMucHVzaCh7XG4gICAgICAgICAgICB0ZXh0OiByZWZbMF0sXG4gICAgICAgICAgICBldmVudDogeyBpZDogdGFnWzFdLCByZWxheXM6IHRhZ1syXSA/IFt0YWdbMl1dIDogW10gfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJhXCI6IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IFtraW5kLCBwdWJrZXksIGlkZW50aWZpZXJdID0gdGFnWzFdLnNwbGl0KFwiOlwiKTtcbiAgICAgICAgICAgIHJlZmVyZW5jZXMucHVzaCh7XG4gICAgICAgICAgICAgIHRleHQ6IHJlZlswXSxcbiAgICAgICAgICAgICAgYWRkcmVzczoge1xuICAgICAgICAgICAgICAgIGlkZW50aWZpZXIsXG4gICAgICAgICAgICAgICAgcHVia2V5LFxuICAgICAgICAgICAgICAgIGtpbmQ6IHBhcnNlSW50KGtpbmQsIDEwKSxcbiAgICAgICAgICAgICAgICByZWxheXM6IHRhZ1syXSA/IFt0YWdbMl1dIDogW11cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZWZlcmVuY2VzO1xufVxuXG4vLyBuaXAwNC50c1xudmFyIG5pcDA0X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDA0X2V4cG9ydHMsIHtcbiAgZGVjcnlwdDogKCkgPT4gZGVjcnlwdCxcbiAgZW5jcnlwdDogKCkgPT4gZW5jcnlwdFxufSk7XG5pbXBvcnQgeyBieXRlc1RvSGV4IGFzIGJ5dGVzVG9IZXgzLCByYW5kb21CeXRlcyB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3V0aWxzXCI7XG5pbXBvcnQgeyBzZWNwMjU2azEgfSBmcm9tIFwiQG5vYmxlL2N1cnZlcy9zZWNwMjU2azFcIjtcbmltcG9ydCB7IGNiYyB9IGZyb20gXCJAbm9ibGUvY2lwaGVycy9hZXNcIjtcbmltcG9ydCB7IGJhc2U2NCB9IGZyb20gXCJAc2N1cmUvYmFzZVwiO1xuYXN5bmMgZnVuY3Rpb24gZW5jcnlwdChzZWNyZXRLZXksIHB1YmtleSwgdGV4dCkge1xuICBjb25zdCBwcml2a2V5ID0gc2VjcmV0S2V5IGluc3RhbmNlb2YgVWludDhBcnJheSA/IGJ5dGVzVG9IZXgzKHNlY3JldEtleSkgOiBzZWNyZXRLZXk7XG4gIGNvbnN0IGtleSA9IHNlY3AyNTZrMS5nZXRTaGFyZWRTZWNyZXQocHJpdmtleSwgXCIwMlwiICsgcHVia2V5KTtcbiAgY29uc3Qgbm9ybWFsaXplZEtleSA9IGdldE5vcm1hbGl6ZWRYKGtleSk7XG4gIGxldCBpdiA9IFVpbnQ4QXJyYXkuZnJvbShyYW5kb21CeXRlcygxNikpO1xuICBsZXQgcGxhaW50ZXh0ID0gdXRmOEVuY29kZXIuZW5jb2RlKHRleHQpO1xuICBsZXQgY2lwaGVydGV4dCA9IGNiYyhub3JtYWxpemVkS2V5LCBpdikuZW5jcnlwdChwbGFpbnRleHQpO1xuICBsZXQgY3RiNjQgPSBiYXNlNjQuZW5jb2RlKG5ldyBVaW50OEFycmF5KGNpcGhlcnRleHQpKTtcbiAgbGV0IGl2YjY0ID0gYmFzZTY0LmVuY29kZShuZXcgVWludDhBcnJheShpdi5idWZmZXIpKTtcbiAgcmV0dXJuIGAke2N0YjY0fT9pdj0ke2l2YjY0fWA7XG59XG5hc3luYyBmdW5jdGlvbiBkZWNyeXB0KHNlY3JldEtleSwgcHVia2V5LCBkYXRhKSB7XG4gIGNvbnN0IHByaXZrZXkgPSBzZWNyZXRLZXkgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gYnl0ZXNUb0hleDMoc2VjcmV0S2V5KSA6IHNlY3JldEtleTtcbiAgbGV0IFtjdGI2NCwgaXZiNjRdID0gZGF0YS5zcGxpdChcIj9pdj1cIik7XG4gIGxldCBrZXkgPSBzZWNwMjU2azEuZ2V0U2hhcmVkU2VjcmV0KHByaXZrZXksIFwiMDJcIiArIHB1YmtleSk7XG4gIGxldCBub3JtYWxpemVkS2V5ID0gZ2V0Tm9ybWFsaXplZFgoa2V5KTtcbiAgbGV0IGl2ID0gYmFzZTY0LmRlY29kZShpdmI2NCk7XG4gIGxldCBjaXBoZXJ0ZXh0ID0gYmFzZTY0LmRlY29kZShjdGI2NCk7XG4gIGxldCBwbGFpbnRleHQgPSBjYmMobm9ybWFsaXplZEtleSwgaXYpLmRlY3J5cHQoY2lwaGVydGV4dCk7XG4gIHJldHVybiB1dGY4RGVjb2Rlci5kZWNvZGUocGxhaW50ZXh0KTtcbn1cbmZ1bmN0aW9uIGdldE5vcm1hbGl6ZWRYKGtleSkge1xuICByZXR1cm4ga2V5LnNsaWNlKDEsIDMzKTtcbn1cblxuLy8gbmlwMDUudHNcbnZhciBuaXAwNV9leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXAwNV9leHBvcnRzLCB7XG4gIE5JUDA1X1JFR0VYOiAoKSA9PiBOSVAwNV9SRUdFWCxcbiAgaXNOaXAwNTogKCkgPT4gaXNOaXAwNSxcbiAgaXNWYWxpZDogKCkgPT4gaXNWYWxpZCxcbiAgcXVlcnlQcm9maWxlOiAoKSA9PiBxdWVyeVByb2ZpbGUsXG4gIHNlYXJjaERvbWFpbjogKCkgPT4gc2VhcmNoRG9tYWluLFxuICB1c2VGZXRjaEltcGxlbWVudGF0aW9uOiAoKSA9PiB1c2VGZXRjaEltcGxlbWVudGF0aW9uXG59KTtcbnZhciBOSVAwNV9SRUdFWCA9IC9eKD86KFtcXHcuKy1dKylAKT8oW1xcd18tXSsoXFwuW1xcd18tXSspKykkLztcbnZhciBpc05pcDA1ID0gKHZhbHVlKSA9PiBOSVAwNV9SRUdFWC50ZXN0KHZhbHVlIHx8IFwiXCIpO1xudmFyIF9mZXRjaDtcbnRyeSB7XG4gIF9mZXRjaCA9IGZldGNoO1xufSBjYXRjaCAoXykge1xuICBudWxsO1xufVxuZnVuY3Rpb24gdXNlRmV0Y2hJbXBsZW1lbnRhdGlvbihmZXRjaEltcGxlbWVudGF0aW9uKSB7XG4gIF9mZXRjaCA9IGZldGNoSW1wbGVtZW50YXRpb247XG59XG5hc3luYyBmdW5jdGlvbiBzZWFyY2hEb21haW4oZG9tYWluLCBxdWVyeSA9IFwiXCIpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCB1cmwgPSBgaHR0cHM6Ly8ke2RvbWFpbn0vLndlbGwta25vd24vbm9zdHIuanNvbj9uYW1lPSR7cXVlcnl9YDtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBfZmV0Y2godXJsLCB7IHJlZGlyZWN0OiBcIm1hbnVhbFwiIH0pO1xuICAgIGlmIChyZXMuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgIHRocm93IEVycm9yKFwiV3JvbmcgcmVzcG9uc2UgY29kZVwiKTtcbiAgICB9XG4gICAgY29uc3QganNvbiA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgcmV0dXJuIGpzb24ubmFtZXM7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4ge307XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHF1ZXJ5UHJvZmlsZShmdWxsbmFtZSkge1xuICBjb25zdCBtYXRjaCA9IGZ1bGxuYW1lLm1hdGNoKE5JUDA1X1JFR0VYKTtcbiAgaWYgKCFtYXRjaClcbiAgICByZXR1cm4gbnVsbDtcbiAgY29uc3QgWywgbmFtZSA9IFwiX1wiLCBkb21haW5dID0gbWF0Y2g7XG4gIHRyeSB7XG4gICAgY29uc3QgdXJsID0gYGh0dHBzOi8vJHtkb21haW59Ly53ZWxsLWtub3duL25vc3RyLmpzb24/bmFtZT0ke25hbWV9YDtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBfZmV0Y2godXJsLCB7IHJlZGlyZWN0OiBcIm1hbnVhbFwiIH0pO1xuICAgIGlmIChyZXMuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgIHRocm93IEVycm9yKFwiV3JvbmcgcmVzcG9uc2UgY29kZVwiKTtcbiAgICB9XG4gICAgY29uc3QganNvbiA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgY29uc3QgcHVia2V5ID0ganNvbi5uYW1lc1tuYW1lXTtcbiAgICByZXR1cm4gcHVia2V5ID8geyBwdWJrZXksIHJlbGF5czoganNvbi5yZWxheXM/LltwdWJrZXldIH0gOiBudWxsO1xuICB9IGNhdGNoIChfZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBpc1ZhbGlkKHB1YmtleSwgbmlwMDUpIHtcbiAgY29uc3QgcmVzID0gYXdhaXQgcXVlcnlQcm9maWxlKG5pcDA1KTtcbiAgcmV0dXJuIHJlcyA/IHJlcy5wdWJrZXkgPT09IHB1YmtleSA6IGZhbHNlO1xufVxuXG4vLyBuaXAxMC50c1xudmFyIG5pcDEwX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDEwX2V4cG9ydHMsIHtcbiAgcGFyc2U6ICgpID0+IHBhcnNlXG59KTtcbmZ1bmN0aW9uIHBhcnNlKGV2ZW50KSB7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICByZXBseTogdm9pZCAwLFxuICAgIHJvb3Q6IHZvaWQgMCxcbiAgICBtZW50aW9uczogW10sXG4gICAgcHJvZmlsZXM6IFtdLFxuICAgIHF1b3RlczogW11cbiAgfTtcbiAgbGV0IG1heWJlUGFyZW50O1xuICBsZXQgbWF5YmVSb290O1xuICBmb3IgKGxldCBpMiA9IGV2ZW50LnRhZ3MubGVuZ3RoIC0gMTsgaTIgPj0gMDsgaTItLSkge1xuICAgIGNvbnN0IHRhZyA9IGV2ZW50LnRhZ3NbaTJdO1xuICAgIGlmICh0YWdbMF0gPT09IFwiZVwiICYmIHRhZ1sxXSkge1xuICAgICAgY29uc3QgW18sIGVUYWdFdmVudElkLCBlVGFnUmVsYXlVcmwsIGVUYWdNYXJrZXIsIGVUYWdBdXRob3JdID0gdGFnO1xuICAgICAgY29uc3QgZXZlbnRQb2ludGVyID0ge1xuICAgICAgICBpZDogZVRhZ0V2ZW50SWQsXG4gICAgICAgIHJlbGF5czogZVRhZ1JlbGF5VXJsID8gW2VUYWdSZWxheVVybF0gOiBbXSxcbiAgICAgICAgYXV0aG9yOiBlVGFnQXV0aG9yXG4gICAgICB9O1xuICAgICAgaWYgKGVUYWdNYXJrZXIgPT09IFwicm9vdFwiKSB7XG4gICAgICAgIHJlc3VsdC5yb290ID0gZXZlbnRQb2ludGVyO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChlVGFnTWFya2VyID09PSBcInJlcGx5XCIpIHtcbiAgICAgICAgcmVzdWx0LnJlcGx5ID0gZXZlbnRQb2ludGVyO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChlVGFnTWFya2VyID09PSBcIm1lbnRpb25cIikge1xuICAgICAgICByZXN1bHQubWVudGlvbnMucHVzaChldmVudFBvaW50ZXIpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICghbWF5YmVQYXJlbnQpIHtcbiAgICAgICAgbWF5YmVQYXJlbnQgPSBldmVudFBvaW50ZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXliZVJvb3QgPSBldmVudFBvaW50ZXI7XG4gICAgICB9XG4gICAgICByZXN1bHQubWVudGlvbnMucHVzaChldmVudFBvaW50ZXIpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICh0YWdbMF0gPT09IFwicVwiICYmIHRhZ1sxXSkge1xuICAgICAgY29uc3QgW18sIGVUYWdFdmVudElkLCBlVGFnUmVsYXlVcmxdID0gdGFnO1xuICAgICAgcmVzdWx0LnF1b3Rlcy5wdXNoKHtcbiAgICAgICAgaWQ6IGVUYWdFdmVudElkLFxuICAgICAgICByZWxheXM6IGVUYWdSZWxheVVybCA/IFtlVGFnUmVsYXlVcmxdIDogW11cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodGFnWzBdID09PSBcInBcIiAmJiB0YWdbMV0pIHtcbiAgICAgIHJlc3VsdC5wcm9maWxlcy5wdXNoKHtcbiAgICAgICAgcHVia2V5OiB0YWdbMV0sXG4gICAgICAgIHJlbGF5czogdGFnWzJdID8gW3RhZ1syXV0gOiBbXVxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gIH1cbiAgaWYgKCFyZXN1bHQucm9vdCkge1xuICAgIHJlc3VsdC5yb290ID0gbWF5YmVSb290IHx8IG1heWJlUGFyZW50IHx8IHJlc3VsdC5yZXBseTtcbiAgfVxuICBpZiAoIXJlc3VsdC5yZXBseSkge1xuICAgIHJlc3VsdC5yZXBseSA9IG1heWJlUGFyZW50IHx8IHJlc3VsdC5yb290O1xuICB9XG4gIDtcbiAgW3Jlc3VsdC5yZXBseSwgcmVzdWx0LnJvb3RdLmZvckVhY2goKHJlZikgPT4ge1xuICAgIGlmICghcmVmKVxuICAgICAgcmV0dXJuO1xuICAgIGxldCBpZHggPSByZXN1bHQubWVudGlvbnMuaW5kZXhPZihyZWYpO1xuICAgIGlmIChpZHggIT09IC0xKSB7XG4gICAgICByZXN1bHQubWVudGlvbnMuc3BsaWNlKGlkeCwgMSk7XG4gICAgfVxuICAgIGlmIChyZWYuYXV0aG9yKSB7XG4gICAgICBsZXQgYXV0aG9yID0gcmVzdWx0LnByb2ZpbGVzLmZpbmQoKHApID0+IHAucHVia2V5ID09PSByZWYuYXV0aG9yKTtcbiAgICAgIGlmIChhdXRob3IgJiYgYXV0aG9yLnJlbGF5cykge1xuICAgICAgICBpZiAoIXJlZi5yZWxheXMpIHtcbiAgICAgICAgICByZWYucmVsYXlzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgYXV0aG9yLnJlbGF5cy5mb3JFYWNoKCh1cmwpID0+IHtcbiAgICAgICAgICBpZiAocmVmLnJlbGF5cz8uaW5kZXhPZih1cmwpID09PSAtMSlcbiAgICAgICAgICAgIHJlZi5yZWxheXMucHVzaCh1cmwpO1xuICAgICAgICB9KTtcbiAgICAgICAgYXV0aG9yLnJlbGF5cyA9IHJlZi5yZWxheXM7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmVzdWx0Lm1lbnRpb25zLmZvckVhY2goKHJlZikgPT4ge1xuICAgIGlmIChyZWYuYXV0aG9yKSB7XG4gICAgICBsZXQgYXV0aG9yID0gcmVzdWx0LnByb2ZpbGVzLmZpbmQoKHApID0+IHAucHVia2V5ID09PSByZWYuYXV0aG9yKTtcbiAgICAgIGlmIChhdXRob3IgJiYgYXV0aG9yLnJlbGF5cykge1xuICAgICAgICBpZiAoIXJlZi5yZWxheXMpIHtcbiAgICAgICAgICByZWYucmVsYXlzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgYXV0aG9yLnJlbGF5cy5mb3JFYWNoKCh1cmwpID0+IHtcbiAgICAgICAgICBpZiAocmVmLnJlbGF5cy5pbmRleE9mKHVybCkgPT09IC0xKVxuICAgICAgICAgICAgcmVmLnJlbGF5cy5wdXNoKHVybCk7XG4gICAgICAgIH0pO1xuICAgICAgICBhdXRob3IucmVsYXlzID0gcmVmLnJlbGF5cztcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBuaXAxMS50c1xudmFyIG5pcDExX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDExX2V4cG9ydHMsIHtcbiAgZmV0Y2hSZWxheUluZm9ybWF0aW9uOiAoKSA9PiBmZXRjaFJlbGF5SW5mb3JtYXRpb24sXG4gIHVzZUZldGNoSW1wbGVtZW50YXRpb246ICgpID0+IHVzZUZldGNoSW1wbGVtZW50YXRpb24yXG59KTtcbnZhciBfZmV0Y2gyO1xudHJ5IHtcbiAgX2ZldGNoMiA9IGZldGNoO1xufSBjYXRjaCB7XG59XG5mdW5jdGlvbiB1c2VGZXRjaEltcGxlbWVudGF0aW9uMihmZXRjaEltcGxlbWVudGF0aW9uKSB7XG4gIF9mZXRjaDIgPSBmZXRjaEltcGxlbWVudGF0aW9uO1xufVxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hSZWxheUluZm9ybWF0aW9uKHVybCkge1xuICByZXR1cm4gYXdhaXQgKGF3YWl0IGZldGNoKHVybC5yZXBsYWNlKFwid3M6Ly9cIiwgXCJodHRwOi8vXCIpLnJlcGxhY2UoXCJ3c3M6Ly9cIiwgXCJodHRwczovL1wiKSwge1xuICAgIGhlYWRlcnM6IHsgQWNjZXB0OiBcImFwcGxpY2F0aW9uL25vc3RyK2pzb25cIiB9XG4gIH0pKS5qc29uKCk7XG59XG5cbi8vIG5pcDEzLnRzXG52YXIgbmlwMTNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobmlwMTNfZXhwb3J0cywge1xuICBmYXN0RXZlbnRIYXNoOiAoKSA9PiBmYXN0RXZlbnRIYXNoLFxuICBnZXRQb3c6ICgpID0+IGdldFBvdyxcbiAgbWluZVBvdzogKCkgPT4gbWluZVBvd1xufSk7XG5pbXBvcnQgeyBieXRlc1RvSGV4IGFzIGJ5dGVzVG9IZXg0IH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvdXRpbHNcIjtcbmltcG9ydCB7IHNoYTI1NiBhcyBzaGEyNTYyIH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvc2hhMjU2XCI7XG5mdW5jdGlvbiBnZXRQb3coaGV4KSB7XG4gIGxldCBjb3VudCA9IDA7XG4gIGZvciAobGV0IGkyID0gMDsgaTIgPCA2NDsgaTIgKz0gOCkge1xuICAgIGNvbnN0IG5pYmJsZSA9IHBhcnNlSW50KGhleC5zdWJzdHJpbmcoaTIsIGkyICsgOCksIDE2KTtcbiAgICBpZiAobmliYmxlID09PSAwKSB7XG4gICAgICBjb3VudCArPSAzMjtcbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQgKz0gTWF0aC5jbHozMihuaWJibGUpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBjb3VudDtcbn1cbmZ1bmN0aW9uIG1pbmVQb3codW5zaWduZWQsIGRpZmZpY3VsdHkpIHtcbiAgbGV0IGNvdW50ID0gMDtcbiAgY29uc3QgZXZlbnQgPSB1bnNpZ25lZDtcbiAgY29uc3QgdGFnID0gW1wibm9uY2VcIiwgY291bnQudG9TdHJpbmcoKSwgZGlmZmljdWx0eS50b1N0cmluZygpXTtcbiAgZXZlbnQudGFncy5wdXNoKHRhZyk7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3Qgbm93MiA9IE1hdGguZmxvb3IobmV3IERhdGUoKS5nZXRUaW1lKCkgLyAxZTMpO1xuICAgIGlmIChub3cyICE9PSBldmVudC5jcmVhdGVkX2F0KSB7XG4gICAgICBjb3VudCA9IDA7XG4gICAgICBldmVudC5jcmVhdGVkX2F0ID0gbm93MjtcbiAgICB9XG4gICAgdGFnWzFdID0gKCsrY291bnQpLnRvU3RyaW5nKCk7XG4gICAgZXZlbnQuaWQgPSBmYXN0RXZlbnRIYXNoKGV2ZW50KTtcbiAgICBpZiAoZ2V0UG93KGV2ZW50LmlkKSA+PSBkaWZmaWN1bHR5KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGV2ZW50O1xufVxuZnVuY3Rpb24gZmFzdEV2ZW50SGFzaChldnQpIHtcbiAgcmV0dXJuIGJ5dGVzVG9IZXg0KFxuICAgIHNoYTI1NjIodXRmOEVuY29kZXIuZW5jb2RlKEpTT04uc3RyaW5naWZ5KFswLCBldnQucHVia2V5LCBldnQuY3JlYXRlZF9hdCwgZXZ0LmtpbmQsIGV2dC50YWdzLCBldnQuY29udGVudF0pKSlcbiAgKTtcbn1cblxuLy8gbmlwMTgudHNcbnZhciBuaXAxOF9leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXAxOF9leHBvcnRzLCB7XG4gIGZpbmlzaFJlcG9zdEV2ZW50OiAoKSA9PiBmaW5pc2hSZXBvc3RFdmVudCxcbiAgZ2V0UmVwb3N0ZWRFdmVudDogKCkgPT4gZ2V0UmVwb3N0ZWRFdmVudCxcbiAgZ2V0UmVwb3N0ZWRFdmVudFBvaW50ZXI6ICgpID0+IGdldFJlcG9zdGVkRXZlbnRQb2ludGVyXG59KTtcbmZ1bmN0aW9uIGZpbmlzaFJlcG9zdEV2ZW50KHQsIHJlcG9zdGVkLCByZWxheVVybCwgcHJpdmF0ZUtleSkge1xuICByZXR1cm4gZmluYWxpemVFdmVudChcbiAgICB7XG4gICAgICBraW5kOiBSZXBvc3QsXG4gICAgICB0YWdzOiBbLi4udC50YWdzID8/IFtdLCBbXCJlXCIsIHJlcG9zdGVkLmlkLCByZWxheVVybF0sIFtcInBcIiwgcmVwb3N0ZWQucHVia2V5XV0sXG4gICAgICBjb250ZW50OiB0LmNvbnRlbnQgPT09IFwiXCIgPyBcIlwiIDogSlNPTi5zdHJpbmdpZnkocmVwb3N0ZWQpLFxuICAgICAgY3JlYXRlZF9hdDogdC5jcmVhdGVkX2F0XG4gICAgfSxcbiAgICBwcml2YXRlS2V5XG4gICk7XG59XG5mdW5jdGlvbiBnZXRSZXBvc3RlZEV2ZW50UG9pbnRlcihldmVudCkge1xuICBpZiAoZXZlbnQua2luZCAhPT0gUmVwb3N0KSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBsZXQgbGFzdEVUYWc7XG4gIGxldCBsYXN0UFRhZztcbiAgZm9yIChsZXQgaTIgPSBldmVudC50YWdzLmxlbmd0aCAtIDE7IGkyID49IDAgJiYgKGxhc3RFVGFnID09PSB2b2lkIDAgfHwgbGFzdFBUYWcgPT09IHZvaWQgMCk7IGkyLS0pIHtcbiAgICBjb25zdCB0YWcgPSBldmVudC50YWdzW2kyXTtcbiAgICBpZiAodGFnLmxlbmd0aCA+PSAyKSB7XG4gICAgICBpZiAodGFnWzBdID09PSBcImVcIiAmJiBsYXN0RVRhZyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGxhc3RFVGFnID0gdGFnO1xuICAgICAgfSBlbHNlIGlmICh0YWdbMF0gPT09IFwicFwiICYmIGxhc3RQVGFnID09PSB2b2lkIDApIHtcbiAgICAgICAgbGFzdFBUYWcgPSB0YWc7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChsYXN0RVRhZyA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4ge1xuICAgIGlkOiBsYXN0RVRhZ1sxXSxcbiAgICByZWxheXM6IFtsYXN0RVRhZ1syXSwgbGFzdFBUYWc/LlsyXV0uZmlsdGVyKCh4KSA9PiB0eXBlb2YgeCA9PT0gXCJzdHJpbmdcIiksXG4gICAgYXV0aG9yOiBsYXN0UFRhZz8uWzFdXG4gIH07XG59XG5mdW5jdGlvbiBnZXRSZXBvc3RlZEV2ZW50KGV2ZW50LCB7IHNraXBWZXJpZmljYXRpb24gfSA9IHt9KSB7XG4gIGNvbnN0IHBvaW50ZXIgPSBnZXRSZXBvc3RlZEV2ZW50UG9pbnRlcihldmVudCk7XG4gIGlmIChwb2ludGVyID09PSB2b2lkIDAgfHwgZXZlbnQuY29udGVudCA9PT0gXCJcIikge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgbGV0IHJlcG9zdGVkRXZlbnQ7XG4gIHRyeSB7XG4gICAgcmVwb3N0ZWRFdmVudCA9IEpTT04ucGFyc2UoZXZlbnQuY29udGVudCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBpZiAocmVwb3N0ZWRFdmVudC5pZCAhPT0gcG9pbnRlci5pZCkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgaWYgKCFza2lwVmVyaWZpY2F0aW9uICYmICF2ZXJpZnlFdmVudChyZXBvc3RlZEV2ZW50KSkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIHJlcG9zdGVkRXZlbnQ7XG59XG5cbi8vIG5pcDIxLnRzXG52YXIgbmlwMjFfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobmlwMjFfZXhwb3J0cywge1xuICBOT1NUUl9VUklfUkVHRVg6ICgpID0+IE5PU1RSX1VSSV9SRUdFWCxcbiAgcGFyc2U6ICgpID0+IHBhcnNlMixcbiAgdGVzdDogKCkgPT4gdGVzdFxufSk7XG52YXIgTk9TVFJfVVJJX1JFR0VYID0gbmV3IFJlZ0V4cChgbm9zdHI6KCR7QkVDSDMyX1JFR0VYLnNvdXJjZX0pYCk7XG5mdW5jdGlvbiB0ZXN0KHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgbmV3IFJlZ0V4cChgXiR7Tk9TVFJfVVJJX1JFR0VYLnNvdXJjZX0kYCkudGVzdCh2YWx1ZSk7XG59XG5mdW5jdGlvbiBwYXJzZTIodXJpKSB7XG4gIGNvbnN0IG1hdGNoID0gdXJpLm1hdGNoKG5ldyBSZWdFeHAoYF4ke05PU1RSX1VSSV9SRUdFWC5zb3VyY2V9JGApKTtcbiAgaWYgKCFtYXRjaClcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgTm9zdHIgVVJJOiAke3VyaX1gKTtcbiAgcmV0dXJuIHtcbiAgICB1cmk6IG1hdGNoWzBdLFxuICAgIHZhbHVlOiBtYXRjaFsxXSxcbiAgICBkZWNvZGVkOiBkZWNvZGUobWF0Y2hbMV0pXG4gIH07XG59XG5cbi8vIG5pcDI1LnRzXG52YXIgbmlwMjVfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobmlwMjVfZXhwb3J0cywge1xuICBmaW5pc2hSZWFjdGlvbkV2ZW50OiAoKSA9PiBmaW5pc2hSZWFjdGlvbkV2ZW50LFxuICBnZXRSZWFjdGVkRXZlbnRQb2ludGVyOiAoKSA9PiBnZXRSZWFjdGVkRXZlbnRQb2ludGVyXG59KTtcbmZ1bmN0aW9uIGZpbmlzaFJlYWN0aW9uRXZlbnQodCwgcmVhY3RlZCwgcHJpdmF0ZUtleSkge1xuICBjb25zdCBpbmhlcml0ZWRUYWdzID0gcmVhY3RlZC50YWdzLmZpbHRlcigodGFnKSA9PiB0YWcubGVuZ3RoID49IDIgJiYgKHRhZ1swXSA9PT0gXCJlXCIgfHwgdGFnWzBdID09PSBcInBcIikpO1xuICByZXR1cm4gZmluYWxpemVFdmVudChcbiAgICB7XG4gICAgICAuLi50LFxuICAgICAga2luZDogUmVhY3Rpb24sXG4gICAgICB0YWdzOiBbLi4udC50YWdzID8/IFtdLCAuLi5pbmhlcml0ZWRUYWdzLCBbXCJlXCIsIHJlYWN0ZWQuaWRdLCBbXCJwXCIsIHJlYWN0ZWQucHVia2V5XV0sXG4gICAgICBjb250ZW50OiB0LmNvbnRlbnQgPz8gXCIrXCJcbiAgICB9LFxuICAgIHByaXZhdGVLZXlcbiAgKTtcbn1cbmZ1bmN0aW9uIGdldFJlYWN0ZWRFdmVudFBvaW50ZXIoZXZlbnQpIHtcbiAgaWYgKGV2ZW50LmtpbmQgIT09IFJlYWN0aW9uKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBsZXQgbGFzdEVUYWc7XG4gIGxldCBsYXN0UFRhZztcbiAgZm9yIChsZXQgaTIgPSBldmVudC50YWdzLmxlbmd0aCAtIDE7IGkyID49IDAgJiYgKGxhc3RFVGFnID09PSB2b2lkIDAgfHwgbGFzdFBUYWcgPT09IHZvaWQgMCk7IGkyLS0pIHtcbiAgICBjb25zdCB0YWcgPSBldmVudC50YWdzW2kyXTtcbiAgICBpZiAodGFnLmxlbmd0aCA+PSAyKSB7XG4gICAgICBpZiAodGFnWzBdID09PSBcImVcIiAmJiBsYXN0RVRhZyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGxhc3RFVGFnID0gdGFnO1xuICAgICAgfSBlbHNlIGlmICh0YWdbMF0gPT09IFwicFwiICYmIGxhc3RQVGFnID09PSB2b2lkIDApIHtcbiAgICAgICAgbGFzdFBUYWcgPSB0YWc7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChsYXN0RVRhZyA9PT0gdm9pZCAwIHx8IGxhc3RQVGFnID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHJldHVybiB7XG4gICAgaWQ6IGxhc3RFVGFnWzFdLFxuICAgIHJlbGF5czogW2xhc3RFVGFnWzJdLCBsYXN0UFRhZ1syXV0uZmlsdGVyKCh4KSA9PiB4ICE9PSB2b2lkIDApLFxuICAgIGF1dGhvcjogbGFzdFBUYWdbMV1cbiAgfTtcbn1cblxuLy8gbmlwMjcudHNcbnZhciBuaXAyN19leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXAyN19leHBvcnRzLCB7XG4gIG1hdGNoQWxsOiAoKSA9PiBtYXRjaEFsbCxcbiAgcmVnZXg6ICgpID0+IHJlZ2V4LFxuICByZXBsYWNlQWxsOiAoKSA9PiByZXBsYWNlQWxsXG59KTtcbnZhciByZWdleCA9ICgpID0+IG5ldyBSZWdFeHAoYFxcXFxiJHtOT1NUUl9VUklfUkVHRVguc291cmNlfVxcXFxiYCwgXCJnXCIpO1xuZnVuY3Rpb24qIG1hdGNoQWxsKGNvbnRlbnQpIHtcbiAgY29uc3QgbWF0Y2hlcyA9IGNvbnRlbnQubWF0Y2hBbGwocmVnZXgoKSk7XG4gIGZvciAoY29uc3QgbWF0Y2ggb2YgbWF0Y2hlcykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBbdXJpLCB2YWx1ZV0gPSBtYXRjaDtcbiAgICAgIHlpZWxkIHtcbiAgICAgICAgdXJpLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgZGVjb2RlZDogZGVjb2RlKHZhbHVlKSxcbiAgICAgICAgc3RhcnQ6IG1hdGNoLmluZGV4LFxuICAgICAgICBlbmQ6IG1hdGNoLmluZGV4ICsgdXJpLmxlbmd0aFxuICAgICAgfTtcbiAgICB9IGNhdGNoIChfZSkge1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcmVwbGFjZUFsbChjb250ZW50LCByZXBsYWNlcikge1xuICByZXR1cm4gY29udGVudC5yZXBsYWNlQWxsKHJlZ2V4KCksICh1cmksIHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIHJlcGxhY2VyKHtcbiAgICAgIHVyaSxcbiAgICAgIHZhbHVlLFxuICAgICAgZGVjb2RlZDogZGVjb2RlKHZhbHVlKVxuICAgIH0pO1xuICB9KTtcbn1cblxuLy8gbmlwMjgudHNcbnZhciBuaXAyOF9leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXAyOF9leHBvcnRzLCB7XG4gIGNoYW5uZWxDcmVhdGVFdmVudDogKCkgPT4gY2hhbm5lbENyZWF0ZUV2ZW50LFxuICBjaGFubmVsSGlkZU1lc3NhZ2VFdmVudDogKCkgPT4gY2hhbm5lbEhpZGVNZXNzYWdlRXZlbnQsXG4gIGNoYW5uZWxNZXNzYWdlRXZlbnQ6ICgpID0+IGNoYW5uZWxNZXNzYWdlRXZlbnQsXG4gIGNoYW5uZWxNZXRhZGF0YUV2ZW50OiAoKSA9PiBjaGFubmVsTWV0YWRhdGFFdmVudCxcbiAgY2hhbm5lbE11dGVVc2VyRXZlbnQ6ICgpID0+IGNoYW5uZWxNdXRlVXNlckV2ZW50XG59KTtcbnZhciBjaGFubmVsQ3JlYXRlRXZlbnQgPSAodCwgcHJpdmF0ZUtleSkgPT4ge1xuICBsZXQgY29udGVudDtcbiAgaWYgKHR5cGVvZiB0LmNvbnRlbnQgPT09IFwib2JqZWN0XCIpIHtcbiAgICBjb250ZW50ID0gSlNPTi5zdHJpbmdpZnkodC5jb250ZW50KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdC5jb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgY29udGVudCA9IHQuY29udGVudDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHJldHVybiBmaW5hbGl6ZUV2ZW50KFxuICAgIHtcbiAgICAgIGtpbmQ6IENoYW5uZWxDcmVhdGlvbixcbiAgICAgIHRhZ3M6IFsuLi50LnRhZ3MgPz8gW11dLFxuICAgICAgY29udGVudCxcbiAgICAgIGNyZWF0ZWRfYXQ6IHQuY3JlYXRlZF9hdFxuICAgIH0sXG4gICAgcHJpdmF0ZUtleVxuICApO1xufTtcbnZhciBjaGFubmVsTWV0YWRhdGFFdmVudCA9ICh0LCBwcml2YXRlS2V5KSA9PiB7XG4gIGxldCBjb250ZW50O1xuICBpZiAodHlwZW9mIHQuY29udGVudCA9PT0gXCJvYmplY3RcIikge1xuICAgIGNvbnRlbnQgPSBKU09OLnN0cmluZ2lmeSh0LmNvbnRlbnQpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB0LmNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICBjb250ZW50ID0gdC5jb250ZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIGZpbmFsaXplRXZlbnQoXG4gICAge1xuICAgICAga2luZDogQ2hhbm5lbE1ldGFkYXRhLFxuICAgICAgdGFnczogW1tcImVcIiwgdC5jaGFubmVsX2NyZWF0ZV9ldmVudF9pZF0sIC4uLnQudGFncyA/PyBbXV0sXG4gICAgICBjb250ZW50LFxuICAgICAgY3JlYXRlZF9hdDogdC5jcmVhdGVkX2F0XG4gICAgfSxcbiAgICBwcml2YXRlS2V5XG4gICk7XG59O1xudmFyIGNoYW5uZWxNZXNzYWdlRXZlbnQgPSAodCwgcHJpdmF0ZUtleSkgPT4ge1xuICBjb25zdCB0YWdzID0gW1tcImVcIiwgdC5jaGFubmVsX2NyZWF0ZV9ldmVudF9pZCwgdC5yZWxheV91cmwsIFwicm9vdFwiXV07XG4gIGlmICh0LnJlcGx5X3RvX2NoYW5uZWxfbWVzc2FnZV9ldmVudF9pZCkge1xuICAgIHRhZ3MucHVzaChbXCJlXCIsIHQucmVwbHlfdG9fY2hhbm5lbF9tZXNzYWdlX2V2ZW50X2lkLCB0LnJlbGF5X3VybCwgXCJyZXBseVwiXSk7XG4gIH1cbiAgcmV0dXJuIGZpbmFsaXplRXZlbnQoXG4gICAge1xuICAgICAga2luZDogQ2hhbm5lbE1lc3NhZ2UsXG4gICAgICB0YWdzOiBbLi4udGFncywgLi4udC50YWdzID8/IFtdXSxcbiAgICAgIGNvbnRlbnQ6IHQuY29udGVudCxcbiAgICAgIGNyZWF0ZWRfYXQ6IHQuY3JlYXRlZF9hdFxuICAgIH0sXG4gICAgcHJpdmF0ZUtleVxuICApO1xufTtcbnZhciBjaGFubmVsSGlkZU1lc3NhZ2VFdmVudCA9ICh0LCBwcml2YXRlS2V5KSA9PiB7XG4gIGxldCBjb250ZW50O1xuICBpZiAodHlwZW9mIHQuY29udGVudCA9PT0gXCJvYmplY3RcIikge1xuICAgIGNvbnRlbnQgPSBKU09OLnN0cmluZ2lmeSh0LmNvbnRlbnQpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB0LmNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICBjb250ZW50ID0gdC5jb250ZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIGZpbmFsaXplRXZlbnQoXG4gICAge1xuICAgICAga2luZDogQ2hhbm5lbEhpZGVNZXNzYWdlLFxuICAgICAgdGFnczogW1tcImVcIiwgdC5jaGFubmVsX21lc3NhZ2VfZXZlbnRfaWRdLCAuLi50LnRhZ3MgPz8gW11dLFxuICAgICAgY29udGVudCxcbiAgICAgIGNyZWF0ZWRfYXQ6IHQuY3JlYXRlZF9hdFxuICAgIH0sXG4gICAgcHJpdmF0ZUtleVxuICApO1xufTtcbnZhciBjaGFubmVsTXV0ZVVzZXJFdmVudCA9ICh0LCBwcml2YXRlS2V5KSA9PiB7XG4gIGxldCBjb250ZW50O1xuICBpZiAodHlwZW9mIHQuY29udGVudCA9PT0gXCJvYmplY3RcIikge1xuICAgIGNvbnRlbnQgPSBKU09OLnN0cmluZ2lmeSh0LmNvbnRlbnQpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB0LmNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICBjb250ZW50ID0gdC5jb250ZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIGZpbmFsaXplRXZlbnQoXG4gICAge1xuICAgICAga2luZDogQ2hhbm5lbE11dGVVc2VyLFxuICAgICAgdGFnczogW1tcInBcIiwgdC5wdWJrZXlfdG9fbXV0ZV0sIC4uLnQudGFncyA/PyBbXV0sXG4gICAgICBjb250ZW50LFxuICAgICAgY3JlYXRlZF9hdDogdC5jcmVhdGVkX2F0XG4gICAgfSxcbiAgICBwcml2YXRlS2V5XG4gICk7XG59O1xuXG4vLyBuaXAzMC50c1xudmFyIG5pcDMwX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDMwX2V4cG9ydHMsIHtcbiAgRU1PSklfU0hPUlRDT0RFX1JFR0VYOiAoKSA9PiBFTU9KSV9TSE9SVENPREVfUkVHRVgsXG4gIG1hdGNoQWxsOiAoKSA9PiBtYXRjaEFsbDIsXG4gIHJlZ2V4OiAoKSA9PiByZWdleDIsXG4gIHJlcGxhY2VBbGw6ICgpID0+IHJlcGxhY2VBbGwyXG59KTtcbnZhciBFTU9KSV9TSE9SVENPREVfUkVHRVggPSAvOihcXHcrKTovO1xudmFyIHJlZ2V4MiA9ICgpID0+IG5ldyBSZWdFeHAoYFxcXFxCJHtFTU9KSV9TSE9SVENPREVfUkVHRVguc291cmNlfVxcXFxCYCwgXCJnXCIpO1xuZnVuY3Rpb24qIG1hdGNoQWxsMihjb250ZW50KSB7XG4gIGNvbnN0IG1hdGNoZXMgPSBjb250ZW50Lm1hdGNoQWxsKHJlZ2V4MigpKTtcbiAgZm9yIChjb25zdCBtYXRjaCBvZiBtYXRjaGVzKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IFtzaG9ydGNvZGUsIG5hbWVdID0gbWF0Y2g7XG4gICAgICB5aWVsZCB7XG4gICAgICAgIHNob3J0Y29kZSxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgc3RhcnQ6IG1hdGNoLmluZGV4LFxuICAgICAgICBlbmQ6IG1hdGNoLmluZGV4ICsgc2hvcnRjb2RlLmxlbmd0aFxuICAgICAgfTtcbiAgICB9IGNhdGNoIChfZSkge1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcmVwbGFjZUFsbDIoY29udGVudCwgcmVwbGFjZXIpIHtcbiAgcmV0dXJuIGNvbnRlbnQucmVwbGFjZUFsbChyZWdleDIoKSwgKHNob3J0Y29kZSwgbmFtZSkgPT4ge1xuICAgIHJldHVybiByZXBsYWNlcih7XG4gICAgICBzaG9ydGNvZGUsXG4gICAgICBuYW1lXG4gICAgfSk7XG4gIH0pO1xufVxuXG4vLyBuaXAzOS50c1xudmFyIG5pcDM5X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDM5X2V4cG9ydHMsIHtcbiAgdXNlRmV0Y2hJbXBsZW1lbnRhdGlvbjogKCkgPT4gdXNlRmV0Y2hJbXBsZW1lbnRhdGlvbjMsXG4gIHZhbGlkYXRlR2l0aHViOiAoKSA9PiB2YWxpZGF0ZUdpdGh1YlxufSk7XG52YXIgX2ZldGNoMztcbnRyeSB7XG4gIF9mZXRjaDMgPSBmZXRjaDtcbn0gY2F0Y2gge1xufVxuZnVuY3Rpb24gdXNlRmV0Y2hJbXBsZW1lbnRhdGlvbjMoZmV0Y2hJbXBsZW1lbnRhdGlvbikge1xuICBfZmV0Y2gzID0gZmV0Y2hJbXBsZW1lbnRhdGlvbjtcbn1cbmFzeW5jIGZ1bmN0aW9uIHZhbGlkYXRlR2l0aHViKHB1YmtleSwgdXNlcm5hbWUsIHByb29mKSB7XG4gIHRyeSB7XG4gICAgbGV0IHJlcyA9IGF3YWl0IChhd2FpdCBfZmV0Y2gzKGBodHRwczovL2dpc3QuZ2l0aHViLmNvbS8ke3VzZXJuYW1lfS8ke3Byb29mfS9yYXdgKSkudGV4dCgpO1xuICAgIHJldHVybiByZXMgPT09IGBWZXJpZnlpbmcgdGhhdCBJIGNvbnRyb2wgdGhlIGZvbGxvd2luZyBOb3N0ciBwdWJsaWMga2V5OiAke3B1YmtleX1gO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8vIG5pcDQ0LnRzXG52YXIgbmlwNDRfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobmlwNDRfZXhwb3J0cywge1xuICBkZWNyeXB0OiAoKSA9PiBkZWNyeXB0MixcbiAgZW5jcnlwdDogKCkgPT4gZW5jcnlwdDIsXG4gIGdldENvbnZlcnNhdGlvbktleTogKCkgPT4gZ2V0Q29udmVyc2F0aW9uS2V5LFxuICB2MjogKCkgPT4gdjJcbn0pO1xuaW1wb3J0IHsgY2hhY2hhMjAgfSBmcm9tIFwiQG5vYmxlL2NpcGhlcnMvY2hhY2hhXCI7XG5pbXBvcnQgeyBlcXVhbEJ5dGVzIH0gZnJvbSBcIkBub2JsZS9jaXBoZXJzL3V0aWxzXCI7XG5pbXBvcnQgeyBzZWNwMjU2azEgYXMgc2VjcDI1NmsxMiB9IGZyb20gXCJAbm9ibGUvY3VydmVzL3NlY3AyNTZrMVwiO1xuaW1wb3J0IHsgZXh0cmFjdCBhcyBoa2RmX2V4dHJhY3QsIGV4cGFuZCBhcyBoa2RmX2V4cGFuZCB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL2hrZGZcIjtcbmltcG9ydCB7IGhtYWMgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy9obWFjXCI7XG5pbXBvcnQgeyBzaGEyNTYgYXMgc2hhMjU2MyB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3NoYTI1NlwiO1xuaW1wb3J0IHsgY29uY2F0Qnl0ZXMgYXMgY29uY2F0Qnl0ZXMyLCByYW5kb21CeXRlcyBhcyByYW5kb21CeXRlczIgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy91dGlsc1wiO1xuaW1wb3J0IHsgYmFzZTY0IGFzIGJhc2U2NDIgfSBmcm9tIFwiQHNjdXJlL2Jhc2VcIjtcbnZhciBtaW5QbGFpbnRleHRTaXplID0gMTtcbnZhciBtYXhQbGFpbnRleHRTaXplID0gNjU1MzU7XG5mdW5jdGlvbiBnZXRDb252ZXJzYXRpb25LZXkocHJpdmtleUEsIHB1YmtleUIpIHtcbiAgY29uc3Qgc2hhcmVkWCA9IHNlY3AyNTZrMTIuZ2V0U2hhcmVkU2VjcmV0KHByaXZrZXlBLCBcIjAyXCIgKyBwdWJrZXlCKS5zdWJhcnJheSgxLCAzMyk7XG4gIHJldHVybiBoa2RmX2V4dHJhY3Qoc2hhMjU2Mywgc2hhcmVkWCwgXCJuaXA0NC12MlwiKTtcbn1cbmZ1bmN0aW9uIGdldE1lc3NhZ2VLZXlzKGNvbnZlcnNhdGlvbktleSwgbm9uY2UpIHtcbiAgY29uc3Qga2V5cyA9IGhrZGZfZXhwYW5kKHNoYTI1NjMsIGNvbnZlcnNhdGlvbktleSwgbm9uY2UsIDc2KTtcbiAgcmV0dXJuIHtcbiAgICBjaGFjaGFfa2V5OiBrZXlzLnN1YmFycmF5KDAsIDMyKSxcbiAgICBjaGFjaGFfbm9uY2U6IGtleXMuc3ViYXJyYXkoMzIsIDQ0KSxcbiAgICBobWFjX2tleToga2V5cy5zdWJhcnJheSg0NCwgNzYpXG4gIH07XG59XG5mdW5jdGlvbiBjYWxjUGFkZGVkTGVuKGxlbikge1xuICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGxlbikgfHwgbGVuIDwgMSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJleHBlY3RlZCBwb3NpdGl2ZSBpbnRlZ2VyXCIpO1xuICBpZiAobGVuIDw9IDMyKVxuICAgIHJldHVybiAzMjtcbiAgY29uc3QgbmV4dFBvd2VyID0gMSA8PCBNYXRoLmZsb29yKE1hdGgubG9nMihsZW4gLSAxKSkgKyAxO1xuICBjb25zdCBjaHVuayA9IG5leHRQb3dlciA8PSAyNTYgPyAzMiA6IG5leHRQb3dlciAvIDg7XG4gIHJldHVybiBjaHVuayAqIChNYXRoLmZsb29yKChsZW4gLSAxKSAvIGNodW5rKSArIDEpO1xufVxuZnVuY3Rpb24gd3JpdGVVMTZCRShudW0pIHtcbiAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihudW0pIHx8IG51bSA8IG1pblBsYWludGV4dFNpemUgfHwgbnVtID4gbWF4UGxhaW50ZXh0U2l6ZSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBsYWludGV4dCBzaXplOiBtdXN0IGJlIGJldHdlZW4gMSBhbmQgNjU1MzUgYnl0ZXNcIik7XG4gIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KDIpO1xuICBuZXcgRGF0YVZpZXcoYXJyLmJ1ZmZlcikuc2V0VWludDE2KDAsIG51bSwgZmFsc2UpO1xuICByZXR1cm4gYXJyO1xufVxuZnVuY3Rpb24gcGFkKHBsYWludGV4dCkge1xuICBjb25zdCB1bnBhZGRlZCA9IHV0ZjhFbmNvZGVyLmVuY29kZShwbGFpbnRleHQpO1xuICBjb25zdCB1bnBhZGRlZExlbiA9IHVucGFkZGVkLmxlbmd0aDtcbiAgY29uc3QgcHJlZml4ID0gd3JpdGVVMTZCRSh1bnBhZGRlZExlbik7XG4gIGNvbnN0IHN1ZmZpeCA9IG5ldyBVaW50OEFycmF5KGNhbGNQYWRkZWRMZW4odW5wYWRkZWRMZW4pIC0gdW5wYWRkZWRMZW4pO1xuICByZXR1cm4gY29uY2F0Qnl0ZXMyKHByZWZpeCwgdW5wYWRkZWQsIHN1ZmZpeCk7XG59XG5mdW5jdGlvbiB1bnBhZChwYWRkZWQpIHtcbiAgY29uc3QgdW5wYWRkZWRMZW4gPSBuZXcgRGF0YVZpZXcocGFkZGVkLmJ1ZmZlcikuZ2V0VWludDE2KDApO1xuICBjb25zdCB1bnBhZGRlZCA9IHBhZGRlZC5zdWJhcnJheSgyLCAyICsgdW5wYWRkZWRMZW4pO1xuICBpZiAodW5wYWRkZWRMZW4gPCBtaW5QbGFpbnRleHRTaXplIHx8IHVucGFkZGVkTGVuID4gbWF4UGxhaW50ZXh0U2l6ZSB8fCB1bnBhZGRlZC5sZW5ndGggIT09IHVucGFkZGVkTGVuIHx8IHBhZGRlZC5sZW5ndGggIT09IDIgKyBjYWxjUGFkZGVkTGVuKHVucGFkZGVkTGVuKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBhZGRpbmdcIik7XG4gIHJldHVybiB1dGY4RGVjb2Rlci5kZWNvZGUodW5wYWRkZWQpO1xufVxuZnVuY3Rpb24gaG1hY0FhZChrZXksIG1lc3NhZ2UsIGFhZCkge1xuICBpZiAoYWFkLmxlbmd0aCAhPT0gMzIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQUFEIGFzc29jaWF0ZWQgZGF0YSBtdXN0IGJlIDMyIGJ5dGVzXCIpO1xuICBjb25zdCBjb21iaW5lZCA9IGNvbmNhdEJ5dGVzMihhYWQsIG1lc3NhZ2UpO1xuICByZXR1cm4gaG1hYyhzaGEyNTYzLCBrZXksIGNvbWJpbmVkKTtcbn1cbmZ1bmN0aW9uIGRlY29kZVBheWxvYWQocGF5bG9hZCkge1xuICBpZiAodHlwZW9mIHBheWxvYWQgIT09IFwic3RyaW5nXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwicGF5bG9hZCBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nXCIpO1xuICBjb25zdCBwbGVuID0gcGF5bG9hZC5sZW5ndGg7XG4gIGlmIChwbGVuIDwgMTMyIHx8IHBsZW4gPiA4NzQ3MilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBheWxvYWQgbGVuZ3RoOiBcIiArIHBsZW4pO1xuICBpZiAocGF5bG9hZFswXSA9PT0gXCIjXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biBlbmNyeXB0aW9uIHZlcnNpb25cIik7XG4gIGxldCBkYXRhO1xuICB0cnkge1xuICAgIGRhdGEgPSBiYXNlNjQyLmRlY29kZShwYXlsb2FkKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGJhc2U2NDogXCIgKyBlcnJvci5tZXNzYWdlKTtcbiAgfVxuICBjb25zdCBkbGVuID0gZGF0YS5sZW5ndGg7XG4gIGlmIChkbGVuIDwgOTkgfHwgZGxlbiA+IDY1NjAzKVxuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZGF0YSBsZW5ndGg6IFwiICsgZGxlbik7XG4gIGNvbnN0IHZlcnMgPSBkYXRhWzBdO1xuICBpZiAodmVycyAhPT0gMilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIGVuY3J5cHRpb24gdmVyc2lvbiBcIiArIHZlcnMpO1xuICByZXR1cm4ge1xuICAgIG5vbmNlOiBkYXRhLnN1YmFycmF5KDEsIDMzKSxcbiAgICBjaXBoZXJ0ZXh0OiBkYXRhLnN1YmFycmF5KDMzLCAtMzIpLFxuICAgIG1hYzogZGF0YS5zdWJhcnJheSgtMzIpXG4gIH07XG59XG5mdW5jdGlvbiBlbmNyeXB0MihwbGFpbnRleHQsIGNvbnZlcnNhdGlvbktleSwgbm9uY2UgPSByYW5kb21CeXRlczIoMzIpKSB7XG4gIGNvbnN0IHsgY2hhY2hhX2tleSwgY2hhY2hhX25vbmNlLCBobWFjX2tleSB9ID0gZ2V0TWVzc2FnZUtleXMoY29udmVyc2F0aW9uS2V5LCBub25jZSk7XG4gIGNvbnN0IHBhZGRlZCA9IHBhZChwbGFpbnRleHQpO1xuICBjb25zdCBjaXBoZXJ0ZXh0ID0gY2hhY2hhMjAoY2hhY2hhX2tleSwgY2hhY2hhX25vbmNlLCBwYWRkZWQpO1xuICBjb25zdCBtYWMgPSBobWFjQWFkKGhtYWNfa2V5LCBjaXBoZXJ0ZXh0LCBub25jZSk7XG4gIHJldHVybiBiYXNlNjQyLmVuY29kZShjb25jYXRCeXRlczIobmV3IFVpbnQ4QXJyYXkoWzJdKSwgbm9uY2UsIGNpcGhlcnRleHQsIG1hYykpO1xufVxuZnVuY3Rpb24gZGVjcnlwdDIocGF5bG9hZCwgY29udmVyc2F0aW9uS2V5KSB7XG4gIGNvbnN0IHsgbm9uY2UsIGNpcGhlcnRleHQsIG1hYyB9ID0gZGVjb2RlUGF5bG9hZChwYXlsb2FkKTtcbiAgY29uc3QgeyBjaGFjaGFfa2V5LCBjaGFjaGFfbm9uY2UsIGhtYWNfa2V5IH0gPSBnZXRNZXNzYWdlS2V5cyhjb252ZXJzYXRpb25LZXksIG5vbmNlKTtcbiAgY29uc3QgY2FsY3VsYXRlZE1hYyA9IGhtYWNBYWQoaG1hY19rZXksIGNpcGhlcnRleHQsIG5vbmNlKTtcbiAgaWYgKCFlcXVhbEJ5dGVzKGNhbGN1bGF0ZWRNYWMsIG1hYykpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBNQUNcIik7XG4gIGNvbnN0IHBhZGRlZCA9IGNoYWNoYTIwKGNoYWNoYV9rZXksIGNoYWNoYV9ub25jZSwgY2lwaGVydGV4dCk7XG4gIHJldHVybiB1bnBhZChwYWRkZWQpO1xufVxudmFyIHYyID0ge1xuICB1dGlsczoge1xuICAgIGdldENvbnZlcnNhdGlvbktleSxcbiAgICBjYWxjUGFkZGVkTGVuXG4gIH0sXG4gIGVuY3J5cHQ6IGVuY3J5cHQyLFxuICBkZWNyeXB0OiBkZWNyeXB0MlxufTtcblxuLy8gbmlwNDcudHNcbnZhciBuaXA0N19leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXA0N19leHBvcnRzLCB7XG4gIG1ha2VOd2NSZXF1ZXN0RXZlbnQ6ICgpID0+IG1ha2VOd2NSZXF1ZXN0RXZlbnQsXG4gIHBhcnNlQ29ubmVjdGlvblN0cmluZzogKCkgPT4gcGFyc2VDb25uZWN0aW9uU3RyaW5nXG59KTtcbmZ1bmN0aW9uIHBhcnNlQ29ubmVjdGlvblN0cmluZyhjb25uZWN0aW9uU3RyaW5nKSB7XG4gIGNvbnN0IHsgcGF0aG5hbWUsIHNlYXJjaFBhcmFtcyB9ID0gbmV3IFVSTChjb25uZWN0aW9uU3RyaW5nKTtcbiAgY29uc3QgcHVia2V5ID0gcGF0aG5hbWU7XG4gIGNvbnN0IHJlbGF5ID0gc2VhcmNoUGFyYW1zLmdldChcInJlbGF5XCIpO1xuICBjb25zdCBzZWNyZXQgPSBzZWFyY2hQYXJhbXMuZ2V0KFwic2VjcmV0XCIpO1xuICBpZiAoIXB1YmtleSB8fCAhcmVsYXkgfHwgIXNlY3JldCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgY29ubmVjdGlvbiBzdHJpbmdcIik7XG4gIH1cbiAgcmV0dXJuIHsgcHVia2V5LCByZWxheSwgc2VjcmV0IH07XG59XG5hc3luYyBmdW5jdGlvbiBtYWtlTndjUmVxdWVzdEV2ZW50KHB1YmtleSwgc2VjcmV0S2V5LCBpbnZvaWNlKSB7XG4gIGNvbnN0IGNvbnRlbnQgPSB7XG4gICAgbWV0aG9kOiBcInBheV9pbnZvaWNlXCIsXG4gICAgcGFyYW1zOiB7XG4gICAgICBpbnZvaWNlXG4gICAgfVxuICB9O1xuICBjb25zdCBlbmNyeXB0ZWRDb250ZW50ID0gYXdhaXQgZW5jcnlwdChzZWNyZXRLZXksIHB1YmtleSwgSlNPTi5zdHJpbmdpZnkoY29udGVudCkpO1xuICBjb25zdCBldmVudFRlbXBsYXRlID0ge1xuICAgIGtpbmQ6IE5XQ1dhbGxldFJlcXVlc3QsXG4gICAgY3JlYXRlZF9hdDogTWF0aC5yb3VuZChEYXRlLm5vdygpIC8gMWUzKSxcbiAgICBjb250ZW50OiBlbmNyeXB0ZWRDb250ZW50LFxuICAgIHRhZ3M6IFtbXCJwXCIsIHB1YmtleV1dXG4gIH07XG4gIHJldHVybiBmaW5hbGl6ZUV2ZW50KGV2ZW50VGVtcGxhdGUsIHNlY3JldEtleSk7XG59XG5cbi8vIG5pcDU3LnRzXG52YXIgbmlwNTdfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobmlwNTdfZXhwb3J0cywge1xuICBnZXRaYXBFbmRwb2ludDogKCkgPT4gZ2V0WmFwRW5kcG9pbnQsXG4gIG1ha2VaYXBSZWNlaXB0OiAoKSA9PiBtYWtlWmFwUmVjZWlwdCxcbiAgbWFrZVphcFJlcXVlc3Q6ICgpID0+IG1ha2VaYXBSZXF1ZXN0LFxuICB1c2VGZXRjaEltcGxlbWVudGF0aW9uOiAoKSA9PiB1c2VGZXRjaEltcGxlbWVudGF0aW9uNCxcbiAgdmFsaWRhdGVaYXBSZXF1ZXN0OiAoKSA9PiB2YWxpZGF0ZVphcFJlcXVlc3Rcbn0pO1xuaW1wb3J0IHsgYmVjaDMyIGFzIGJlY2gzMjIgfSBmcm9tIFwiQHNjdXJlL2Jhc2VcIjtcbnZhciBfZmV0Y2g0O1xudHJ5IHtcbiAgX2ZldGNoNCA9IGZldGNoO1xufSBjYXRjaCB7XG59XG5mdW5jdGlvbiB1c2VGZXRjaEltcGxlbWVudGF0aW9uNChmZXRjaEltcGxlbWVudGF0aW9uKSB7XG4gIF9mZXRjaDQgPSBmZXRjaEltcGxlbWVudGF0aW9uO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0WmFwRW5kcG9pbnQobWV0YWRhdGEpIHtcbiAgdHJ5IHtcbiAgICBsZXQgbG51cmwgPSBcIlwiO1xuICAgIGxldCB7IGx1ZDA2LCBsdWQxNiB9ID0gSlNPTi5wYXJzZShtZXRhZGF0YS5jb250ZW50KTtcbiAgICBpZiAobHVkMDYpIHtcbiAgICAgIGxldCB7IHdvcmRzIH0gPSBiZWNoMzIyLmRlY29kZShsdWQwNiwgMWUzKTtcbiAgICAgIGxldCBkYXRhID0gYmVjaDMyMi5mcm9tV29yZHMod29yZHMpO1xuICAgICAgbG51cmwgPSB1dGY4RGVjb2Rlci5kZWNvZGUoZGF0YSk7XG4gICAgfSBlbHNlIGlmIChsdWQxNikge1xuICAgICAgbGV0IFtuYW1lLCBkb21haW5dID0gbHVkMTYuc3BsaXQoXCJAXCIpO1xuICAgICAgbG51cmwgPSBuZXcgVVJMKGAvLndlbGwta25vd24vbG51cmxwLyR7bmFtZX1gLCBgaHR0cHM6Ly8ke2RvbWFpbn1gKS50b1N0cmluZygpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgbGV0IHJlcyA9IGF3YWl0IF9mZXRjaDQobG51cmwpO1xuICAgIGxldCBib2R5ID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICBpZiAoYm9keS5hbGxvd3NOb3N0ciAmJiBib2R5Lm5vc3RyUHVia2V5KSB7XG4gICAgICByZXR1cm4gYm9keS5jYWxsYmFjaztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gbWFrZVphcFJlcXVlc3Qoe1xuICBwcm9maWxlLFxuICBldmVudCxcbiAgYW1vdW50LFxuICByZWxheXMsXG4gIGNvbW1lbnQgPSBcIlwiXG59KSB7XG4gIGlmICghYW1vdW50KVxuICAgIHRocm93IG5ldyBFcnJvcihcImFtb3VudCBub3QgZ2l2ZW5cIik7XG4gIGlmICghcHJvZmlsZSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJwcm9maWxlIG5vdCBnaXZlblwiKTtcbiAgbGV0IHpyID0ge1xuICAgIGtpbmQ6IDk3MzQsXG4gICAgY3JlYXRlZF9hdDogTWF0aC5yb3VuZChEYXRlLm5vdygpIC8gMWUzKSxcbiAgICBjb250ZW50OiBjb21tZW50LFxuICAgIHRhZ3M6IFtcbiAgICAgIFtcInBcIiwgcHJvZmlsZV0sXG4gICAgICBbXCJhbW91bnRcIiwgYW1vdW50LnRvU3RyaW5nKCldLFxuICAgICAgW1wicmVsYXlzXCIsIC4uLnJlbGF5c11cbiAgICBdXG4gIH07XG4gIGlmIChldmVudCkge1xuICAgIHpyLnRhZ3MucHVzaChbXCJlXCIsIGV2ZW50XSk7XG4gIH1cbiAgcmV0dXJuIHpyO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVaYXBSZXF1ZXN0KHphcFJlcXVlc3RTdHJpbmcpIHtcbiAgbGV0IHphcFJlcXVlc3Q7XG4gIHRyeSB7XG4gICAgemFwUmVxdWVzdCA9IEpTT04ucGFyc2UoemFwUmVxdWVzdFN0cmluZyk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBcIkludmFsaWQgemFwIHJlcXVlc3QgSlNPTi5cIjtcbiAgfVxuICBpZiAoIXZhbGlkYXRlRXZlbnQoemFwUmVxdWVzdCkpXG4gICAgcmV0dXJuIFwiWmFwIHJlcXVlc3QgaXMgbm90IGEgdmFsaWQgTm9zdHIgZXZlbnQuXCI7XG4gIGlmICghdmVyaWZ5RXZlbnQoemFwUmVxdWVzdCkpXG4gICAgcmV0dXJuIFwiSW52YWxpZCBzaWduYXR1cmUgb24gemFwIHJlcXVlc3QuXCI7XG4gIGxldCBwID0gemFwUmVxdWVzdC50YWdzLmZpbmQoKFt0LCB2XSkgPT4gdCA9PT0gXCJwXCIgJiYgdik7XG4gIGlmICghcClcbiAgICByZXR1cm4gXCJaYXAgcmVxdWVzdCBkb2Vzbid0IGhhdmUgYSAncCcgdGFnLlwiO1xuICBpZiAoIXBbMV0ubWF0Y2goL15bYS1mMC05XXs2NH0kLykpXG4gICAgcmV0dXJuIFwiWmFwIHJlcXVlc3QgJ3AnIHRhZyBpcyBub3QgdmFsaWQgaGV4LlwiO1xuICBsZXQgZSA9IHphcFJlcXVlc3QudGFncy5maW5kKChbdCwgdl0pID0+IHQgPT09IFwiZVwiICYmIHYpO1xuICBpZiAoZSAmJiAhZVsxXS5tYXRjaCgvXlthLWYwLTldezY0fSQvKSlcbiAgICByZXR1cm4gXCJaYXAgcmVxdWVzdCAnZScgdGFnIGlzIG5vdCB2YWxpZCBoZXguXCI7XG4gIGxldCByZWxheXMgPSB6YXBSZXF1ZXN0LnRhZ3MuZmluZCgoW3QsIHZdKSA9PiB0ID09PSBcInJlbGF5c1wiICYmIHYpO1xuICBpZiAoIXJlbGF5cylcbiAgICByZXR1cm4gXCJaYXAgcmVxdWVzdCBkb2Vzbid0IGhhdmUgYSAncmVsYXlzJyB0YWcuXCI7XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gbWFrZVphcFJlY2VpcHQoe1xuICB6YXBSZXF1ZXN0LFxuICBwcmVpbWFnZSxcbiAgYm9sdDExLFxuICBwYWlkQXRcbn0pIHtcbiAgbGV0IHpyID0gSlNPTi5wYXJzZSh6YXBSZXF1ZXN0KTtcbiAgbGV0IHRhZ3NGcm9tWmFwUmVxdWVzdCA9IHpyLnRhZ3MuZmlsdGVyKChbdF0pID0+IHQgPT09IFwiZVwiIHx8IHQgPT09IFwicFwiIHx8IHQgPT09IFwiYVwiKTtcbiAgbGV0IHphcCA9IHtcbiAgICBraW5kOiA5NzM1LFxuICAgIGNyZWF0ZWRfYXQ6IE1hdGgucm91bmQocGFpZEF0LmdldFRpbWUoKSAvIDFlMyksXG4gICAgY29udGVudDogXCJcIixcbiAgICB0YWdzOiBbLi4udGFnc0Zyb21aYXBSZXF1ZXN0LCBbXCJQXCIsIHpyLnB1YmtleV0sIFtcImJvbHQxMVwiLCBib2x0MTFdLCBbXCJkZXNjcmlwdGlvblwiLCB6YXBSZXF1ZXN0XV1cbiAgfTtcbiAgaWYgKHByZWltYWdlKSB7XG4gICAgemFwLnRhZ3MucHVzaChbXCJwcmVpbWFnZVwiLCBwcmVpbWFnZV0pO1xuICB9XG4gIHJldHVybiB6YXA7XG59XG5cbi8vIG5pcDU5LnRzXG52YXIgbmlwNTlfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobmlwNTlfZXhwb3J0cywge1xuICBjcmVhdGVSdW1vcjogKCkgPT4gY3JlYXRlUnVtb3IsXG4gIGNyZWF0ZVNlYWw6ICgpID0+IGNyZWF0ZVNlYWwsXG4gIGNyZWF0ZVdyYXA6ICgpID0+IGNyZWF0ZVdyYXAsXG4gIHVud3JhcEV2ZW50OiAoKSA9PiB1bndyYXBFdmVudCxcbiAgdW53cmFwTWFueUV2ZW50czogKCkgPT4gdW53cmFwTWFueUV2ZW50cyxcbiAgd3JhcEV2ZW50OiAoKSA9PiB3cmFwRXZlbnQsXG4gIHdyYXBNYW55RXZlbnRzOiAoKSA9PiB3cmFwTWFueUV2ZW50c1xufSk7XG52YXIgVFdPX0RBWVMgPSAyICogMjQgKiA2MCAqIDYwO1xudmFyIG5vdyA9ICgpID0+IE1hdGgucm91bmQoRGF0ZS5ub3coKSAvIDFlMyk7XG52YXIgcmFuZG9tTm93ID0gKCkgPT4gTWF0aC5yb3VuZChub3coKSAtIE1hdGgucmFuZG9tKCkgKiBUV09fREFZUyk7XG52YXIgbmlwNDRDb252ZXJzYXRpb25LZXkgPSAocHJpdmF0ZUtleSwgcHVibGljS2V5KSA9PiBnZXRDb252ZXJzYXRpb25LZXkocHJpdmF0ZUtleSwgcHVibGljS2V5KTtcbnZhciBuaXA0NEVuY3J5cHQgPSAoZGF0YSwgcHJpdmF0ZUtleSwgcHVibGljS2V5KSA9PiBlbmNyeXB0MihKU09OLnN0cmluZ2lmeShkYXRhKSwgbmlwNDRDb252ZXJzYXRpb25LZXkocHJpdmF0ZUtleSwgcHVibGljS2V5KSk7XG52YXIgbmlwNDREZWNyeXB0ID0gKGRhdGEsIHByaXZhdGVLZXkpID0+IEpTT04ucGFyc2UoZGVjcnlwdDIoZGF0YS5jb250ZW50LCBuaXA0NENvbnZlcnNhdGlvbktleShwcml2YXRlS2V5LCBkYXRhLnB1YmtleSkpKTtcbmZ1bmN0aW9uIGNyZWF0ZVJ1bW9yKGV2ZW50LCBwcml2YXRlS2V5KSB7XG4gIGNvbnN0IHJ1bW9yID0ge1xuICAgIGNyZWF0ZWRfYXQ6IG5vdygpLFxuICAgIGNvbnRlbnQ6IFwiXCIsXG4gICAgdGFnczogW10sXG4gICAgLi4uZXZlbnQsXG4gICAgcHVia2V5OiBnZXRQdWJsaWNLZXkocHJpdmF0ZUtleSlcbiAgfTtcbiAgcnVtb3IuaWQgPSBnZXRFdmVudEhhc2gocnVtb3IpO1xuICByZXR1cm4gcnVtb3I7XG59XG5mdW5jdGlvbiBjcmVhdGVTZWFsKHJ1bW9yLCBwcml2YXRlS2V5LCByZWNpcGllbnRQdWJsaWNLZXkpIHtcbiAgcmV0dXJuIGZpbmFsaXplRXZlbnQoXG4gICAge1xuICAgICAga2luZDogU2VhbCxcbiAgICAgIGNvbnRlbnQ6IG5pcDQ0RW5jcnlwdChydW1vciwgcHJpdmF0ZUtleSwgcmVjaXBpZW50UHVibGljS2V5KSxcbiAgICAgIGNyZWF0ZWRfYXQ6IHJhbmRvbU5vdygpLFxuICAgICAgdGFnczogW11cbiAgICB9LFxuICAgIHByaXZhdGVLZXlcbiAgKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVdyYXAoc2VhbCwgcmVjaXBpZW50UHVibGljS2V5KSB7XG4gIGNvbnN0IHJhbmRvbUtleSA9IGdlbmVyYXRlU2VjcmV0S2V5KCk7XG4gIHJldHVybiBmaW5hbGl6ZUV2ZW50KFxuICAgIHtcbiAgICAgIGtpbmQ6IEdpZnRXcmFwLFxuICAgICAgY29udGVudDogbmlwNDRFbmNyeXB0KHNlYWwsIHJhbmRvbUtleSwgcmVjaXBpZW50UHVibGljS2V5KSxcbiAgICAgIGNyZWF0ZWRfYXQ6IHJhbmRvbU5vdygpLFxuICAgICAgdGFnczogW1tcInBcIiwgcmVjaXBpZW50UHVibGljS2V5XV1cbiAgICB9LFxuICAgIHJhbmRvbUtleVxuICApO1xufVxuZnVuY3Rpb24gd3JhcEV2ZW50KGV2ZW50LCBzZW5kZXJQcml2YXRlS2V5LCByZWNpcGllbnRQdWJsaWNLZXkpIHtcbiAgY29uc3QgcnVtb3IgPSBjcmVhdGVSdW1vcihldmVudCwgc2VuZGVyUHJpdmF0ZUtleSk7XG4gIGNvbnN0IHNlYWwgPSBjcmVhdGVTZWFsKHJ1bW9yLCBzZW5kZXJQcml2YXRlS2V5LCByZWNpcGllbnRQdWJsaWNLZXkpO1xuICByZXR1cm4gY3JlYXRlV3JhcChzZWFsLCByZWNpcGllbnRQdWJsaWNLZXkpO1xufVxuZnVuY3Rpb24gd3JhcE1hbnlFdmVudHMoZXZlbnQsIHNlbmRlclByaXZhdGVLZXksIHJlY2lwaWVudHNQdWJsaWNLZXlzKSB7XG4gIGlmICghcmVjaXBpZW50c1B1YmxpY0tleXMgfHwgcmVjaXBpZW50c1B1YmxpY0tleXMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQXQgbGVhc3Qgb25lIHJlY2lwaWVudCBpcyByZXF1aXJlZC5cIik7XG4gIH1cbiAgY29uc3Qgc2VuZGVyUHVibGljS2V5ID0gZ2V0UHVibGljS2V5KHNlbmRlclByaXZhdGVLZXkpO1xuICBjb25zdCB3cmFwcGVkcyA9IFt3cmFwRXZlbnQoZXZlbnQsIHNlbmRlclByaXZhdGVLZXksIHNlbmRlclB1YmxpY0tleSldO1xuICByZWNpcGllbnRzUHVibGljS2V5cy5mb3JFYWNoKChyZWNpcGllbnRQdWJsaWNLZXkpID0+IHtcbiAgICB3cmFwcGVkcy5wdXNoKHdyYXBFdmVudChldmVudCwgc2VuZGVyUHJpdmF0ZUtleSwgcmVjaXBpZW50UHVibGljS2V5KSk7XG4gIH0pO1xuICByZXR1cm4gd3JhcHBlZHM7XG59XG5mdW5jdGlvbiB1bndyYXBFdmVudCh3cmFwLCByZWNpcGllbnRQcml2YXRlS2V5KSB7XG4gIGNvbnN0IHVud3JhcHBlZFNlYWwgPSBuaXA0NERlY3J5cHQod3JhcCwgcmVjaXBpZW50UHJpdmF0ZUtleSk7XG4gIHJldHVybiBuaXA0NERlY3J5cHQodW53cmFwcGVkU2VhbCwgcmVjaXBpZW50UHJpdmF0ZUtleSk7XG59XG5mdW5jdGlvbiB1bndyYXBNYW55RXZlbnRzKHdyYXBwZWRFdmVudHMsIHJlY2lwaWVudFByaXZhdGVLZXkpIHtcbiAgbGV0IHVud3JhcHBlZEV2ZW50cyA9IFtdO1xuICB3cmFwcGVkRXZlbnRzLmZvckVhY2goKGUpID0+IHtcbiAgICB1bndyYXBwZWRFdmVudHMucHVzaCh1bndyYXBFdmVudChlLCByZWNpcGllbnRQcml2YXRlS2V5KSk7XG4gIH0pO1xuICB1bndyYXBwZWRFdmVudHMuc29ydCgoYSwgYikgPT4gYS5jcmVhdGVkX2F0IC0gYi5jcmVhdGVkX2F0KTtcbiAgcmV0dXJuIHVud3JhcHBlZEV2ZW50cztcbn1cblxuLy8gbmlwOTgudHNcbnZhciBuaXA5OF9leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXA5OF9leHBvcnRzLCB7XG4gIGdldFRva2VuOiAoKSA9PiBnZXRUb2tlbixcbiAgaGFzaFBheWxvYWQ6ICgpID0+IGhhc2hQYXlsb2FkLFxuICB1bnBhY2tFdmVudEZyb21Ub2tlbjogKCkgPT4gdW5wYWNrRXZlbnRGcm9tVG9rZW4sXG4gIHZhbGlkYXRlRXZlbnQ6ICgpID0+IHZhbGlkYXRlRXZlbnQyLFxuICB2YWxpZGF0ZUV2ZW50S2luZDogKCkgPT4gdmFsaWRhdGVFdmVudEtpbmQsXG4gIHZhbGlkYXRlRXZlbnRNZXRob2RUYWc6ICgpID0+IHZhbGlkYXRlRXZlbnRNZXRob2RUYWcsXG4gIHZhbGlkYXRlRXZlbnRQYXlsb2FkVGFnOiAoKSA9PiB2YWxpZGF0ZUV2ZW50UGF5bG9hZFRhZyxcbiAgdmFsaWRhdGVFdmVudFRpbWVzdGFtcDogKCkgPT4gdmFsaWRhdGVFdmVudFRpbWVzdGFtcCxcbiAgdmFsaWRhdGVFdmVudFVybFRhZzogKCkgPT4gdmFsaWRhdGVFdmVudFVybFRhZyxcbiAgdmFsaWRhdGVUb2tlbjogKCkgPT4gdmFsaWRhdGVUb2tlblxufSk7XG5pbXBvcnQgeyBzaGEyNTYgYXMgc2hhMjU2NCB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3NoYTI1NlwiO1xuaW1wb3J0IHsgYnl0ZXNUb0hleCBhcyBieXRlc1RvSGV4NSB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3V0aWxzXCI7XG5pbXBvcnQgeyBiYXNlNjQgYXMgYmFzZTY0MyB9IGZyb20gXCJAc2N1cmUvYmFzZVwiO1xudmFyIF9hdXRob3JpemF0aW9uU2NoZW1lID0gXCJOb3N0ciBcIjtcbmFzeW5jIGZ1bmN0aW9uIGdldFRva2VuKGxvZ2luVXJsLCBodHRwTWV0aG9kLCBzaWduLCBpbmNsdWRlQXV0aG9yaXphdGlvblNjaGVtZSA9IGZhbHNlLCBwYXlsb2FkKSB7XG4gIGNvbnN0IGV2ZW50ID0ge1xuICAgIGtpbmQ6IEhUVFBBdXRoLFxuICAgIHRhZ3M6IFtcbiAgICAgIFtcInVcIiwgbG9naW5VcmxdLFxuICAgICAgW1wibWV0aG9kXCIsIGh0dHBNZXRob2RdXG4gICAgXSxcbiAgICBjcmVhdGVkX2F0OiBNYXRoLnJvdW5kKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMWUzKSxcbiAgICBjb250ZW50OiBcIlwiXG4gIH07XG4gIGlmIChwYXlsb2FkKSB7XG4gICAgZXZlbnQudGFncy5wdXNoKFtcInBheWxvYWRcIiwgaGFzaFBheWxvYWQocGF5bG9hZCldKTtcbiAgfVxuICBjb25zdCBzaWduZWRFdmVudCA9IGF3YWl0IHNpZ24oZXZlbnQpO1xuICBjb25zdCBhdXRob3JpemF0aW9uU2NoZW1lID0gaW5jbHVkZUF1dGhvcml6YXRpb25TY2hlbWUgPyBfYXV0aG9yaXphdGlvblNjaGVtZSA6IFwiXCI7XG4gIHJldHVybiBhdXRob3JpemF0aW9uU2NoZW1lICsgYmFzZTY0My5lbmNvZGUodXRmOEVuY29kZXIuZW5jb2RlKEpTT04uc3RyaW5naWZ5KHNpZ25lZEV2ZW50KSkpO1xufVxuYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVUb2tlbih0b2tlbiwgdXJsLCBtZXRob2QpIHtcbiAgY29uc3QgZXZlbnQgPSBhd2FpdCB1bnBhY2tFdmVudEZyb21Ub2tlbih0b2tlbikuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH0pO1xuICBjb25zdCB2YWxpZCA9IGF3YWl0IHZhbGlkYXRlRXZlbnQyKGV2ZW50LCB1cmwsIG1ldGhvZCkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH0pO1xuICByZXR1cm4gdmFsaWQ7XG59XG5hc3luYyBmdW5jdGlvbiB1bnBhY2tFdmVudEZyb21Ub2tlbih0b2tlbikge1xuICBpZiAoIXRva2VuKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB0b2tlblwiKTtcbiAgfVxuICB0b2tlbiA9IHRva2VuLnJlcGxhY2UoX2F1dGhvcml6YXRpb25TY2hlbWUsIFwiXCIpO1xuICBjb25zdCBldmVudEI2NCA9IHV0ZjhEZWNvZGVyLmRlY29kZShiYXNlNjQzLmRlY29kZSh0b2tlbikpO1xuICBpZiAoIWV2ZW50QjY0IHx8IGV2ZW50QjY0Lmxlbmd0aCA9PT0gMCB8fCAhZXZlbnRCNjQuc3RhcnRzV2l0aChcIntcIikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHRva2VuXCIpO1xuICB9XG4gIGNvbnN0IGV2ZW50ID0gSlNPTi5wYXJzZShldmVudEI2NCk7XG4gIHJldHVybiBldmVudDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlRXZlbnRUaW1lc3RhbXAoZXZlbnQpIHtcbiAgaWYgKCFldmVudC5jcmVhdGVkX2F0KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBNYXRoLnJvdW5kKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMWUzKSAtIGV2ZW50LmNyZWF0ZWRfYXQgPCA2MDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlRXZlbnRLaW5kKGV2ZW50KSB7XG4gIHJldHVybiBldmVudC5raW5kID09PSBIVFRQQXV0aDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlRXZlbnRVcmxUYWcoZXZlbnQsIHVybCkge1xuICBjb25zdCB1cmxUYWcgPSBldmVudC50YWdzLmZpbmQoKHQpID0+IHRbMF0gPT09IFwidVwiKTtcbiAgaWYgKCF1cmxUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHVybFRhZy5sZW5ndGggPiAwICYmIHVybFRhZ1sxXSA9PT0gdXJsO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVFdmVudE1ldGhvZFRhZyhldmVudCwgbWV0aG9kKSB7XG4gIGNvbnN0IG1ldGhvZFRhZyA9IGV2ZW50LnRhZ3MuZmluZCgodCkgPT4gdFswXSA9PT0gXCJtZXRob2RcIik7XG4gIGlmICghbWV0aG9kVGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBtZXRob2RUYWcubGVuZ3RoID4gMCAmJiBtZXRob2RUYWdbMV0udG9Mb3dlckNhc2UoKSA9PT0gbWV0aG9kLnRvTG93ZXJDYXNlKCk7XG59XG5mdW5jdGlvbiBoYXNoUGF5bG9hZChwYXlsb2FkKSB7XG4gIGNvbnN0IGhhc2ggPSBzaGEyNTY0KHV0ZjhFbmNvZGVyLmVuY29kZShKU09OLnN0cmluZ2lmeShwYXlsb2FkKSkpO1xuICByZXR1cm4gYnl0ZXNUb0hleDUoaGFzaCk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUV2ZW50UGF5bG9hZFRhZyhldmVudCwgcGF5bG9hZCkge1xuICBjb25zdCBwYXlsb2FkVGFnID0gZXZlbnQudGFncy5maW5kKCh0KSA9PiB0WzBdID09PSBcInBheWxvYWRcIik7XG4gIGlmICghcGF5bG9hZFRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBwYXlsb2FkSGFzaCA9IGhhc2hQYXlsb2FkKHBheWxvYWQpO1xuICByZXR1cm4gcGF5bG9hZFRhZy5sZW5ndGggPiAwICYmIHBheWxvYWRUYWdbMV0gPT09IHBheWxvYWRIYXNoO1xufVxuYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVFdmVudDIoZXZlbnQsIHVybCwgbWV0aG9kLCBib2R5KSB7XG4gIGlmICghdmVyaWZ5RXZlbnQoZXZlbnQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBub3N0ciBldmVudCwgc2lnbmF0dXJlIGludmFsaWRcIik7XG4gIH1cbiAgaWYgKCF2YWxpZGF0ZUV2ZW50S2luZChldmVudCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG5vc3RyIGV2ZW50LCBraW5kIGludmFsaWRcIik7XG4gIH1cbiAgaWYgKCF2YWxpZGF0ZUV2ZW50VGltZXN0YW1wKGV2ZW50KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbm9zdHIgZXZlbnQsIGNyZWF0ZWRfYXQgdGltZXN0YW1wIGludmFsaWRcIik7XG4gIH1cbiAgaWYgKCF2YWxpZGF0ZUV2ZW50VXJsVGFnKGV2ZW50LCB1cmwpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBub3N0ciBldmVudCwgdXJsIHRhZyBpbnZhbGlkXCIpO1xuICB9XG4gIGlmICghdmFsaWRhdGVFdmVudE1ldGhvZFRhZyhldmVudCwgbWV0aG9kKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbm9zdHIgZXZlbnQsIG1ldGhvZCB0YWcgaW52YWxpZFwiKTtcbiAgfVxuICBpZiAoQm9vbGVhbihib2R5KSAmJiB0eXBlb2YgYm9keSA9PT0gXCJvYmplY3RcIiAmJiBPYmplY3Qua2V5cyhib2R5KS5sZW5ndGggPiAwKSB7XG4gICAgaWYgKCF2YWxpZGF0ZUV2ZW50UGF5bG9hZFRhZyhldmVudCwgYm9keSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbm9zdHIgZXZlbnQsIHBheWxvYWQgdGFnIGRvZXMgbm90IG1hdGNoIHJlcXVlc3QgYm9keSBoYXNoXCIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydCB7XG4gIFJlbGF5LFxuICBTaW1wbGVQb29sLFxuICBmaW5hbGl6ZUV2ZW50LFxuICBmYWtlanNvbl9leHBvcnRzIGFzIGZqLFxuICBnZW5lcmF0ZVNlY3JldEtleSxcbiAgZ2V0RXZlbnRIYXNoLFxuICBnZXRGaWx0ZXJMaW1pdCxcbiAgZ2V0UHVibGljS2V5LFxuICBraW5kc19leHBvcnRzIGFzIGtpbmRzLFxuICBtYXRjaEZpbHRlcixcbiAgbWF0Y2hGaWx0ZXJzLFxuICBtZXJnZUZpbHRlcnMsXG4gIG5pcDA0X2V4cG9ydHMgYXMgbmlwMDQsXG4gIG5pcDA1X2V4cG9ydHMgYXMgbmlwMDUsXG4gIG5pcDEwX2V4cG9ydHMgYXMgbmlwMTAsXG4gIG5pcDExX2V4cG9ydHMgYXMgbmlwMTEsXG4gIG5pcDEzX2V4cG9ydHMgYXMgbmlwMTMsXG4gIG5pcDE4X2V4cG9ydHMgYXMgbmlwMTgsXG4gIG5pcDE5X2V4cG9ydHMgYXMgbmlwMTksXG4gIG5pcDIxX2V4cG9ydHMgYXMgbmlwMjEsXG4gIG5pcDI1X2V4cG9ydHMgYXMgbmlwMjUsXG4gIG5pcDI3X2V4cG9ydHMgYXMgbmlwMjcsXG4gIG5pcDI4X2V4cG9ydHMgYXMgbmlwMjgsXG4gIG5pcDMwX2V4cG9ydHMgYXMgbmlwMzAsXG4gIG5pcDM5X2V4cG9ydHMgYXMgbmlwMzksXG4gIG5pcDQyX2V4cG9ydHMgYXMgbmlwNDIsXG4gIG5pcDQ0X2V4cG9ydHMgYXMgbmlwNDQsXG4gIG5pcDQ3X2V4cG9ydHMgYXMgbmlwNDcsXG4gIG5pcDU3X2V4cG9ydHMgYXMgbmlwNTcsXG4gIG5pcDU5X2V4cG9ydHMgYXMgbmlwNTksXG4gIG5pcDk4X2V4cG9ydHMgYXMgbmlwOTgsXG4gIHBhcnNlUmVmZXJlbmNlcyxcbiAgc2VyaWFsaXplRXZlbnQsXG4gIHNvcnRFdmVudHMsXG4gIHV0aWxzX2V4cG9ydHMgYXMgdXRpbHMsXG4gIHZhbGlkYXRlRXZlbnQsXG4gIHZlcmlmaWVkU3ltYm9sLFxuICB2ZXJpZnlFdmVudFxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/lib/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/_shortw_utils.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/_shortw_utils.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createCurve: () => (/* binding */ createCurve),\n/* harmony export */   getHash: () => (/* binding */ getHash)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/hmac */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/hmac.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\n\n// connects noble-curves to noble-hashes\nfunction getHash(hash) {\n    return {\n        hash,\n        hmac: (key, ...msgs) => (0,_noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__.hmac)(hash, key, (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(...msgs)),\n        randomBytes: _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.randomBytes,\n    };\n}\nfunction createCurve(curveDef, defHash) {\n    const create = (hash) => (0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__.weierstrass)({ ...curveDef, ...getHash(hash) });\n    return Object.freeze({ ...create(defHash), create });\n}\n//# sourceMappingURL=_shortw_utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vX3Nob3J0d191dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQzBDO0FBQ3FCO0FBQ1A7QUFDeEQ7QUFDTztBQUNQO0FBQ0E7QUFDQSxnQ0FBZ0Msd0RBQUksWUFBWSxnRUFBVztBQUMzRCxtQkFBbUI7QUFDbkI7QUFDQTtBQUNPO0FBQ1AsNkJBQTZCLHFFQUFXLEdBQUcsK0JBQStCO0FBQzFFLDJCQUEyQiw0QkFBNEI7QUFDdkQ7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbGZnL0dpdC9NYWR0cmlwcy9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vX3Nob3J0d191dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5pbXBvcnQgeyBobWFjIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9obWFjJztcbmltcG9ydCB7IGNvbmNhdEJ5dGVzLCByYW5kb21CeXRlcyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvdXRpbHMnO1xuaW1wb3J0IHsgd2VpZXJzdHJhc3MgfSBmcm9tICcuL2Fic3RyYWN0L3dlaWVyc3RyYXNzLmpzJztcbi8vIGNvbm5lY3RzIG5vYmxlLWN1cnZlcyB0byBub2JsZS1oYXNoZXNcbmV4cG9ydCBmdW5jdGlvbiBnZXRIYXNoKGhhc2gpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBoYXNoLFxuICAgICAgICBobWFjOiAoa2V5LCAuLi5tc2dzKSA9PiBobWFjKGhhc2gsIGtleSwgY29uY2F0Qnl0ZXMoLi4ubXNncykpLFxuICAgICAgICByYW5kb21CeXRlcyxcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUN1cnZlKGN1cnZlRGVmLCBkZWZIYXNoKSB7XG4gICAgY29uc3QgY3JlYXRlID0gKGhhc2gpID0+IHdlaWVyc3RyYXNzKHsgLi4uY3VydmVEZWYsIC4uLmdldEhhc2goaGFzaCkgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyAuLi5jcmVhdGUoZGVmSGFzaCksIGNyZWF0ZSB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9zaG9ydHdfdXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/_shortw_utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/curve.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/curve.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   validateBasic: () => (/* binding */ validateBasic),\n/* harmony export */   wNAF: () => (/* binding */ wNAF)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Abelian group utilities\n\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n// Elliptic curve multiplication of Point by scalar. Fragile.\n// Scalars should always be less than curve order: this should be checked inside of a curve itself.\n// Creates precomputation tables for fast multiplication:\n// - private scalar is split by fixed size windows of W bits\n// - every window point is collected from window's table & added to accumulator\n// - since windows are different, same point inside tables won't be accessed more than once per calc\n// - each multiplication is 'Math.ceil(CURVE_ORDER / 𝑊) + 1' point additions (fixed for any scalar)\n// - +1 window is neccessary for wNAF\n// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow\n// windows to be in different memory locations\nfunction wNAF(c, bits) {\n    const constTimeNegate = (condition, item) => {\n        const neg = item.negate();\n        return condition ? neg : item;\n    };\n    const opts = (W) => {\n        const windows = Math.ceil(bits / W) + 1; // +1, because\n        const windowSize = 2 ** (W - 1); // -1 because we skip zero\n        return { windows, windowSize };\n    };\n    return {\n        constTimeNegate,\n        // non-const time multiplication ladder\n        unsafeLadder(elm, n) {\n            let p = c.ZERO;\n            let d = elm;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:\n         * - 𝑊 is the window size\n         * - 𝑛 is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @returns precomputed point tables flattened to a single array\n         */\n        precomputeWindow(elm, W) {\n            const { windows, windowSize } = opts(W);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for (let window = 0; window < windows; window++) {\n                base = p;\n                points.push(base);\n                // =1, because we skip zero\n                for (let i = 1; i < windowSize; i++) {\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */\n        wNAF(W, precomputes, n) {\n            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n            // But need to carefully remove other checks before wNAF. ORDER == bits here\n            const { windows, windowSize } = opts(W);\n            let p = c.ZERO;\n            let f = c.BASE;\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for (let window = 0; window < windows; window++) {\n                const offset = window * windowSize;\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n                // there is negate now: it is possible that negated element from low value\n                // would be the same as high element, which will create carry into next window.\n                // It's not obvious how this can fail, but still worth investigating later.\n                // Check if we're onto Zero point.\n                // Add random point inside current window to f.\n                const offset1 = offset;\n                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n                const cond1 = window % 2 !== 0;\n                const cond2 = wbits < 0;\n                if (wbits === 0) {\n                    // The most important part for const-time getPublicKey\n                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n                }\n                else {\n                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n                }\n            }\n            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n            // Even if the variable is still unused, there are some checks which will\n            // throw an exception, so compiler needs to prove they won't happen, which is hard.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return { p, f };\n        },\n        wNAFCached(P, precomputesMap, n, transform) {\n            // @ts-ignore\n            const W = P._WINDOW_SIZE || 1;\n            // Calculate precomputes on a first run, reuse them after\n            let comp = precomputesMap.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1) {\n                    precomputesMap.set(P, transform(comp));\n                }\n            }\n            return this.wNAF(W, comp, n);\n        },\n    };\n}\nfunction validateBasic(curve) {\n    (0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.validateField)(curve.Fp);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject)(curve, {\n        n: 'bigint',\n        h: 'bigint',\n        Gx: 'field',\n        Gy: 'field',\n    }, {\n        nBitLength: 'isSafeInteger',\n        nByteLength: 'isSafeInteger',\n    });\n    // Set defaults\n    return Object.freeze({\n        ...(0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.nLength)(curve.n, curve.nBitLength),\n        ...curve,\n        ...{ p: curve.Fp.ORDER },\n    });\n}\n//# sourceMappingURL=curve.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvY3VydmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDc0Q7QUFDVjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCx5Q0FBeUM7QUFDekMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtCQUFrQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0JBQWdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0EsaUNBQWlDLGtCQUFrQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ087QUFDUCxJQUFJLDBEQUFhO0FBQ2pCLElBQUkseURBQWM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsV0FBVyxvREFBTztBQUNsQjtBQUNBLGFBQWEsbUJBQW1CO0FBQ2hDLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9sZmcvR2l0L01hZHRyaXBzL25vZGVfbW9kdWxlcy9Abm9zdHItZGV2LWtpdC9uZGsvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9jdXJ2ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBBYmVsaWFuIGdyb3VwIHV0aWxpdGllc1xuaW1wb3J0IHsgdmFsaWRhdGVGaWVsZCwgbkxlbmd0aCB9IGZyb20gJy4vbW9kdWxhci5qcyc7XG5pbXBvcnQgeyB2YWxpZGF0ZU9iamVjdCB9IGZyb20gJy4vdXRpbHMuanMnO1xuY29uc3QgXzBuID0gQmlnSW50KDApO1xuY29uc3QgXzFuID0gQmlnSW50KDEpO1xuLy8gRWxsaXB0aWMgY3VydmUgbXVsdGlwbGljYXRpb24gb2YgUG9pbnQgYnkgc2NhbGFyLiBGcmFnaWxlLlxuLy8gU2NhbGFycyBzaG91bGQgYWx3YXlzIGJlIGxlc3MgdGhhbiBjdXJ2ZSBvcmRlcjogdGhpcyBzaG91bGQgYmUgY2hlY2tlZCBpbnNpZGUgb2YgYSBjdXJ2ZSBpdHNlbGYuXG4vLyBDcmVhdGVzIHByZWNvbXB1dGF0aW9uIHRhYmxlcyBmb3IgZmFzdCBtdWx0aXBsaWNhdGlvbjpcbi8vIC0gcHJpdmF0ZSBzY2FsYXIgaXMgc3BsaXQgYnkgZml4ZWQgc2l6ZSB3aW5kb3dzIG9mIFcgYml0c1xuLy8gLSBldmVyeSB3aW5kb3cgcG9pbnQgaXMgY29sbGVjdGVkIGZyb20gd2luZG93J3MgdGFibGUgJiBhZGRlZCB0byBhY2N1bXVsYXRvclxuLy8gLSBzaW5jZSB3aW5kb3dzIGFyZSBkaWZmZXJlbnQsIHNhbWUgcG9pbnQgaW5zaWRlIHRhYmxlcyB3b24ndCBiZSBhY2Nlc3NlZCBtb3JlIHRoYW4gb25jZSBwZXIgY2FsY1xuLy8gLSBlYWNoIG11bHRpcGxpY2F0aW9uIGlzICdNYXRoLmNlaWwoQ1VSVkVfT1JERVIgLyDwnZGKKSArIDEnIHBvaW50IGFkZGl0aW9ucyAoZml4ZWQgZm9yIGFueSBzY2FsYXIpXG4vLyAtICsxIHdpbmRvdyBpcyBuZWNjZXNzYXJ5IGZvciB3TkFGXG4vLyAtIHdOQUYgcmVkdWNlcyB0YWJsZSBzaXplOiAyeCBsZXNzIG1lbW9yeSArIDJ4IGZhc3RlciBnZW5lcmF0aW9uLCBidXQgMTAlIHNsb3dlciBtdWx0aXBsaWNhdGlvblxuLy8gVE9ETzogUmVzZWFyY2ggcmV0dXJuaW5nIDJkIEpTIGFycmF5IG9mIHdpbmRvd3MsIGluc3RlYWQgb2YgYSBzaW5nbGUgd2luZG93LiBUaGlzIHdvdWxkIGFsbG93XG4vLyB3aW5kb3dzIHRvIGJlIGluIGRpZmZlcmVudCBtZW1vcnkgbG9jYXRpb25zXG5leHBvcnQgZnVuY3Rpb24gd05BRihjLCBiaXRzKSB7XG4gICAgY29uc3QgY29uc3RUaW1lTmVnYXRlID0gKGNvbmRpdGlvbiwgaXRlbSkgPT4ge1xuICAgICAgICBjb25zdCBuZWcgPSBpdGVtLm5lZ2F0ZSgpO1xuICAgICAgICByZXR1cm4gY29uZGl0aW9uID8gbmVnIDogaXRlbTtcbiAgICB9O1xuICAgIGNvbnN0IG9wdHMgPSAoVykgPT4ge1xuICAgICAgICBjb25zdCB3aW5kb3dzID0gTWF0aC5jZWlsKGJpdHMgLyBXKSArIDE7IC8vICsxLCBiZWNhdXNlXG4gICAgICAgIGNvbnN0IHdpbmRvd1NpemUgPSAyICoqIChXIC0gMSk7IC8vIC0xIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG4gICAgICAgIHJldHVybiB7IHdpbmRvd3MsIHdpbmRvd1NpemUgfTtcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbnN0VGltZU5lZ2F0ZSxcbiAgICAgICAgLy8gbm9uLWNvbnN0IHRpbWUgbXVsdGlwbGljYXRpb24gbGFkZGVyXG4gICAgICAgIHVuc2FmZUxhZGRlcihlbG0sIG4pIHtcbiAgICAgICAgICAgIGxldCBwID0gYy5aRVJPO1xuICAgICAgICAgICAgbGV0IGQgPSBlbG07XG4gICAgICAgICAgICB3aGlsZSAobiA+IF8wbikge1xuICAgICAgICAgICAgICAgIGlmIChuICYgXzFuKVxuICAgICAgICAgICAgICAgICAgICBwID0gcC5hZGQoZCk7XG4gICAgICAgICAgICAgICAgZCA9IGQuZG91YmxlKCk7XG4gICAgICAgICAgICAgICAgbiA+Pj0gXzFuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgd05BRiBwcmVjb21wdXRhdGlvbiB3aW5kb3cuIFVzZWQgZm9yIGNhY2hpbmcuXG4gICAgICAgICAqIERlZmF1bHQgd2luZG93IHNpemUgaXMgc2V0IGJ5IGB1dGlscy5wcmVjb21wdXRlKClgIGFuZCBpcyBlcXVhbCB0byA4LlxuICAgICAgICAgKiBOdW1iZXIgb2YgcHJlY29tcHV0ZWQgcG9pbnRzIGRlcGVuZHMgb24gdGhlIGN1cnZlIHNpemU6XG4gICAgICAgICAqIDJeKPCdkYriiJIxKSAqIChNYXRoLmNlaWwo8J2RmyAvIPCdkYopICsgMSksIHdoZXJlOlxuICAgICAgICAgKiAtIPCdkYogaXMgdGhlIHdpbmRvdyBzaXplXG4gICAgICAgICAqIC0g8J2RmyBpcyB0aGUgYml0bGVuZ3RoIG9mIHRoZSBjdXJ2ZSBvcmRlci5cbiAgICAgICAgICogRm9yIGEgMjU2LWJpdCBjdXJ2ZSBhbmQgd2luZG93IHNpemUgOCwgdGhlIG51bWJlciBvZiBwcmVjb21wdXRlZCBwb2ludHMgaXMgMTI4ICogMzMgPSA0MjI0LlxuICAgICAgICAgKiBAcmV0dXJucyBwcmVjb21wdXRlZCBwb2ludCB0YWJsZXMgZmxhdHRlbmVkIHRvIGEgc2luZ2xlIGFycmF5XG4gICAgICAgICAqL1xuICAgICAgICBwcmVjb21wdXRlV2luZG93KGVsbSwgVykge1xuICAgICAgICAgICAgY29uc3QgeyB3aW5kb3dzLCB3aW5kb3dTaXplIH0gPSBvcHRzKFcpO1xuICAgICAgICAgICAgY29uc3QgcG9pbnRzID0gW107XG4gICAgICAgICAgICBsZXQgcCA9IGVsbTtcbiAgICAgICAgICAgIGxldCBiYXNlID0gcDtcbiAgICAgICAgICAgIGZvciAobGV0IHdpbmRvdyA9IDA7IHdpbmRvdyA8IHdpbmRvd3M7IHdpbmRvdysrKSB7XG4gICAgICAgICAgICAgICAgYmFzZSA9IHA7XG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goYmFzZSk7XG4gICAgICAgICAgICAgICAgLy8gPTEsIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB3aW5kb3dTaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYmFzZSA9IGJhc2UuYWRkKHApO1xuICAgICAgICAgICAgICAgICAgICBwb2ludHMucHVzaChiYXNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcCA9IGJhc2UuZG91YmxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcG9pbnRzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogSW1wbGVtZW50cyBlYyBtdWx0aXBsaWNhdGlvbiB1c2luZyBwcmVjb21wdXRlZCB0YWJsZXMgYW5kIHctYXJ5IG5vbi1hZGphY2VudCBmb3JtLlxuICAgICAgICAgKiBAcGFyYW0gVyB3aW5kb3cgc2l6ZVxuICAgICAgICAgKiBAcGFyYW0gcHJlY29tcHV0ZXMgcHJlY29tcHV0ZWQgdGFibGVzXG4gICAgICAgICAqIEBwYXJhbSBuIHNjYWxhciAod2UgZG9uJ3QgY2hlY2sgaGVyZSwgYnV0IHNob3VsZCBiZSBsZXNzIHRoYW4gY3VydmUgb3JkZXIpXG4gICAgICAgICAqIEByZXR1cm5zIHJlYWwgYW5kIGZha2UgKGZvciBjb25zdC10aW1lKSBwb2ludHNcbiAgICAgICAgICovXG4gICAgICAgIHdOQUYoVywgcHJlY29tcHV0ZXMsIG4pIHtcbiAgICAgICAgICAgIC8vIFRPRE86IG1heWJlIGNoZWNrIHRoYXQgc2NhbGFyIGlzIGxlc3MgdGhhbiBncm91cCBvcmRlcj8gd05BRiBiZWhhdmlvdXMgaXMgdW5kZWZpbmVkIG90aGVyd2lzZVxuICAgICAgICAgICAgLy8gQnV0IG5lZWQgdG8gY2FyZWZ1bGx5IHJlbW92ZSBvdGhlciBjaGVja3MgYmVmb3JlIHdOQUYuIE9SREVSID09IGJpdHMgaGVyZVxuICAgICAgICAgICAgY29uc3QgeyB3aW5kb3dzLCB3aW5kb3dTaXplIH0gPSBvcHRzKFcpO1xuICAgICAgICAgICAgbGV0IHAgPSBjLlpFUk87XG4gICAgICAgICAgICBsZXQgZiA9IGMuQkFTRTtcbiAgICAgICAgICAgIGNvbnN0IG1hc2sgPSBCaWdJbnQoMiAqKiBXIC0gMSk7IC8vIENyZWF0ZSBtYXNrIHdpdGggVyBvbmVzOiAwYjExMTEgZm9yIFc9NCBldGMuXG4gICAgICAgICAgICBjb25zdCBtYXhOdW1iZXIgPSAyICoqIFc7XG4gICAgICAgICAgICBjb25zdCBzaGlmdEJ5ID0gQmlnSW50KFcpO1xuICAgICAgICAgICAgZm9yIChsZXQgd2luZG93ID0gMDsgd2luZG93IDwgd2luZG93czsgd2luZG93KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB3aW5kb3cgKiB3aW5kb3dTaXplO1xuICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgVyBiaXRzLlxuICAgICAgICAgICAgICAgIGxldCB3Yml0cyA9IE51bWJlcihuICYgbWFzayk7XG4gICAgICAgICAgICAgICAgLy8gU2hpZnQgbnVtYmVyIGJ5IFcgYml0cy5cbiAgICAgICAgICAgICAgICBuID4+PSBzaGlmdEJ5O1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBiaXRzIGFyZSBiaWdnZXIgdGhhbiBtYXggc2l6ZSwgd2UnbGwgc3BsaXQgdGhvc2UuXG4gICAgICAgICAgICAgICAgLy8gKzIyNCA9PiAyNTYgLSAzMlxuICAgICAgICAgICAgICAgIGlmICh3Yml0cyA+IHdpbmRvd1NpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgd2JpdHMgLT0gbWF4TnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICBuICs9IF8xbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBjb2RlIHdhcyBmaXJzdCB3cml0dGVuIHdpdGggYXNzdW1wdGlvbiB0aGF0ICdmJyBhbmQgJ3AnIHdpbGwgbmV2ZXIgYmUgaW5maW5pdHkgcG9pbnQ6XG4gICAgICAgICAgICAgICAgLy8gc2luY2UgZWFjaCBhZGRpdGlvbiBpcyBtdWx0aXBsaWVkIGJ5IDIgKiogVywgaXQgY2Fubm90IGNhbmNlbCBlYWNoIG90aGVyLiBIb3dldmVyLFxuICAgICAgICAgICAgICAgIC8vIHRoZXJlIGlzIG5lZ2F0ZSBub3c6IGl0IGlzIHBvc3NpYmxlIHRoYXQgbmVnYXRlZCBlbGVtZW50IGZyb20gbG93IHZhbHVlXG4gICAgICAgICAgICAgICAgLy8gd291bGQgYmUgdGhlIHNhbWUgYXMgaGlnaCBlbGVtZW50LCB3aGljaCB3aWxsIGNyZWF0ZSBjYXJyeSBpbnRvIG5leHQgd2luZG93LlxuICAgICAgICAgICAgICAgIC8vIEl0J3Mgbm90IG9idmlvdXMgaG93IHRoaXMgY2FuIGZhaWwsIGJ1dCBzdGlsbCB3b3J0aCBpbnZlc3RpZ2F0aW5nIGxhdGVyLlxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlJ3JlIG9udG8gWmVybyBwb2ludC5cbiAgICAgICAgICAgICAgICAvLyBBZGQgcmFuZG9tIHBvaW50IGluc2lkZSBjdXJyZW50IHdpbmRvdyB0byBmLlxuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldDEgPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0MiA9IG9mZnNldCArIE1hdGguYWJzKHdiaXRzKSAtIDE7IC8vIC0xIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG4gICAgICAgICAgICAgICAgY29uc3QgY29uZDEgPSB3aW5kb3cgJSAyICE9PSAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbmQyID0gd2JpdHMgPCAwO1xuICAgICAgICAgICAgICAgIGlmICh3Yml0cyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbW9zdCBpbXBvcnRhbnQgcGFydCBmb3IgY29uc3QtdGltZSBnZXRQdWJsaWNLZXlcbiAgICAgICAgICAgICAgICAgICAgZiA9IGYuYWRkKGNvbnN0VGltZU5lZ2F0ZShjb25kMSwgcHJlY29tcHV0ZXNbb2Zmc2V0MV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBwLmFkZChjb25zdFRpbWVOZWdhdGUoY29uZDIsIHByZWNvbXB1dGVzW29mZnNldDJdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSklULWNvbXBpbGVyIHNob3VsZCBub3QgZWxpbWluYXRlIGYgaGVyZSwgc2luY2UgaXQgd2lsbCBsYXRlciBiZSB1c2VkIGluIG5vcm1hbGl6ZVooKVxuICAgICAgICAgICAgLy8gRXZlbiBpZiB0aGUgdmFyaWFibGUgaXMgc3RpbGwgdW51c2VkLCB0aGVyZSBhcmUgc29tZSBjaGVja3Mgd2hpY2ggd2lsbFxuICAgICAgICAgICAgLy8gdGhyb3cgYW4gZXhjZXB0aW9uLCBzbyBjb21waWxlciBuZWVkcyB0byBwcm92ZSB0aGV5IHdvbid0IGhhcHBlbiwgd2hpY2ggaXMgaGFyZC5cbiAgICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQgdGhlcmUgaXMgYSB3YXkgdG8gRiBiZSBpbmZpbml0eS1wb2ludCBldmVuIGlmIHAgaXMgbm90LFxuICAgICAgICAgICAgLy8gd2hpY2ggbWFrZXMgaXQgbGVzcyBjb25zdC10aW1lOiBhcm91bmQgMSBiaWdpbnQgbXVsdGlwbHkuXG4gICAgICAgICAgICByZXR1cm4geyBwLCBmIH07XG4gICAgICAgIH0sXG4gICAgICAgIHdOQUZDYWNoZWQoUCwgcHJlY29tcHV0ZXNNYXAsIG4sIHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgVyA9IFAuX1dJTkRPV19TSVpFIHx8IDE7XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgcHJlY29tcHV0ZXMgb24gYSBmaXJzdCBydW4sIHJldXNlIHRoZW0gYWZ0ZXJcbiAgICAgICAgICAgIGxldCBjb21wID0gcHJlY29tcHV0ZXNNYXAuZ2V0KFApO1xuICAgICAgICAgICAgaWYgKCFjb21wKSB7XG4gICAgICAgICAgICAgICAgY29tcCA9IHRoaXMucHJlY29tcHV0ZVdpbmRvdyhQLCBXKTtcbiAgICAgICAgICAgICAgICBpZiAoVyAhPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBwcmVjb21wdXRlc01hcC5zZXQoUCwgdHJhbnNmb3JtKGNvbXApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53TkFGKFcsIGNvbXAsIG4pO1xuICAgICAgICB9LFxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVCYXNpYyhjdXJ2ZSkge1xuICAgIHZhbGlkYXRlRmllbGQoY3VydmUuRnApO1xuICAgIHZhbGlkYXRlT2JqZWN0KGN1cnZlLCB7XG4gICAgICAgIG46ICdiaWdpbnQnLFxuICAgICAgICBoOiAnYmlnaW50JyxcbiAgICAgICAgR3g6ICdmaWVsZCcsXG4gICAgICAgIEd5OiAnZmllbGQnLFxuICAgIH0sIHtcbiAgICAgICAgbkJpdExlbmd0aDogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBuQnl0ZUxlbmd0aDogJ2lzU2FmZUludGVnZXInLFxuICAgIH0pO1xuICAgIC8vIFNldCBkZWZhdWx0c1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgLi4ubkxlbmd0aChjdXJ2ZS5uLCBjdXJ2ZS5uQml0TGVuZ3RoKSxcbiAgICAgICAgLi4uY3VydmUsXG4gICAgICAgIC4uLnsgcDogY3VydmUuRnAuT1JERVIgfSxcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWN1cnZlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/curve.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/hash-to-curve.js":
/*!***************************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/hash-to-curve.js ***!
  \***************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createHasher: () => (/* binding */ createHasher),\n/* harmony export */   expand_message_xmd: () => (/* binding */ expand_message_xmd),\n/* harmony export */   expand_message_xof: () => (/* binding */ expand_message_xof),\n/* harmony export */   hash_to_field: () => (/* binding */ hash_to_field),\n/* harmony export */   isogenyMap: () => (/* binding */ isogenyMap)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/utils.js\");\n\n\nfunction validateDST(dst) {\n    if (dst instanceof Uint8Array)\n        return dst;\n    if (typeof dst === 'string')\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)(dst);\n    throw new Error('DST must be Uint8Array or string');\n}\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE;\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value, length) {\n    if (value < 0 || value >= 1 << (8 * length)) {\n        throw new Error(`bad I2OSP call: value=${value} length=${length}`);\n    }\n    const res = Array.from({ length }).fill(0);\n    for (let i = length - 1; i >= 0; i--) {\n        res[i] = value & 0xff;\n        value >>>= 8;\n    }\n    return new Uint8Array(res);\n}\nfunction strxor(a, b) {\n    const arr = new Uint8Array(a.length);\n    for (let i = 0; i < a.length; i++) {\n        arr[i] = a[i] ^ b[i];\n    }\n    return arr;\n}\nfunction isBytes(item) {\n    if (!(item instanceof Uint8Array))\n        throw new Error('Uint8Array expected');\n}\nfunction isNum(item) {\n    if (!Number.isSafeInteger(item))\n        throw new Error('number expected');\n}\n// Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1\nfunction expand_message_xmd(msg, DST, lenInBytes, H) {\n    isBytes(msg);\n    isBytes(DST);\n    isNum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    if (DST.length > 255)\n        DST = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)('H2C-OVERSIZE-DST-'), DST));\n    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n    const ell = Math.ceil(lenInBytes / b_in_bytes);\n    if (ell > 255)\n        throw new Error('Invalid xmd length');\n    const DST_prime = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(DST, i2osp(DST.length, 1));\n    const Z_pad = i2osp(0, r_in_bytes);\n    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n    const b = new Array(ell);\n    const b_0 = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n    b[0] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(b_0, i2osp(1, 1), DST_prime));\n    for (let i = 1; i <= ell; i++) {\n        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];\n        b[i] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...args));\n    }\n    const pseudo_random_bytes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...b);\n    return pseudo_random_bytes.slice(0, lenInBytes);\n}\n// Produces a uniformly random byte string using an extendable-output function (XOF) H.\n// 1. The collision resistance of H MUST be at least k bits.\n// 2. H MUST be an XOF that has been proved indifferentiable from\n//    a random oracle under a reasonable cryptographic assumption.\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2\nfunction expand_message_xof(msg, DST, lenInBytes, k, H) {\n    isBytes(msg);\n    isBytes(DST);\n    isNum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n    if (DST.length > 255) {\n        const dkLen = Math.ceil((2 * k) / 8);\n        DST = H.create({ dkLen }).update((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)('H2C-OVERSIZE-DST-')).update(DST).digest();\n    }\n    if (lenInBytes > 65535 || DST.length > 255)\n        throw new Error('expand_message_xof: invalid lenInBytes');\n    return (H.create({ dkLen: lenInBytes })\n        .update(msg)\n        .update(i2osp(lenInBytes, 2))\n        // 2. DST_prime = DST || I2OSP(len(DST), 1)\n        .update(DST)\n        .update(i2osp(DST.length, 1))\n        .digest());\n}\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F\n * https://www.rfc-editor.org/rfc/rfc9380#section-5.2\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */\nfunction hash_to_field(msg, count, options) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(options, {\n        DST: 'stringOrUint8Array',\n        p: 'bigint',\n        m: 'isSafeInteger',\n        k: 'isSafeInteger',\n        hash: 'hash',\n    });\n    const { p, k, m, hash, expand, DST: _DST } = options;\n    isBytes(msg);\n    isNum(count);\n    const DST = validateDST(_DST);\n    const log2p = p.toString(2).length;\n    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n    const len_in_bytes = count * m * L;\n    let prb; // pseudo_random_bytes\n    if (expand === 'xmd') {\n        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n    }\n    else if (expand === 'xof') {\n        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n    }\n    else if (expand === '_internal_pass') {\n        // for internal tests only\n        prb = msg;\n    }\n    else {\n        throw new Error('expand must be \"xmd\" or \"xof\"');\n    }\n    const u = new Array(count);\n    for (let i = 0; i < count; i++) {\n        const e = new Array(m);\n        for (let j = 0; j < m; j++) {\n            const elm_offset = L * (j + i * m);\n            const tv = prb.subarray(elm_offset, elm_offset + L);\n            e[j] = (0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.mod)(os2ip(tv), p);\n        }\n        u[i] = e;\n    }\n    return u;\n}\nfunction isogenyMap(field, map) {\n    // Make same order as in spec\n    const COEFF = map.map((i) => Array.from(i).reverse());\n    return (x, y) => {\n        const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));\n        x = field.div(xNum, xDen); // xNum / xDen\n        y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)\n        return { x, y };\n    };\n}\nfunction createHasher(Point, mapToCurve, def) {\n    if (typeof mapToCurve !== 'function')\n        throw new Error('mapToCurve() must be defined');\n    return {\n        // Encodes byte string to elliptic curve.\n        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        hashToCurve(msg, options) {\n            const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });\n            const u0 = Point.fromAffine(mapToCurve(u[0]));\n            const u1 = Point.fromAffine(mapToCurve(u[1]));\n            const P = u0.add(u1).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n        // Encodes byte string to elliptic curve.\n        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        encodeToCurve(msg, options) {\n            const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });\n            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n    };\n}\n//# sourceMappingURL=hash-to-curve.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvaGFzaC10by1jdXJ2ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQW1DO0FBQ29EO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxzREFBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxjQUFjLHNEQUFlO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxPQUFPLFNBQVMsT0FBTztBQUN4RTtBQUNBLDZCQUE2QixRQUFRO0FBQ3JDLDZCQUE2QixRQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzREFBVyxDQUFDLHNEQUFXO0FBQ3ZDLFlBQVksOENBQThDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzREFBVztBQUNqQztBQUNBLDRDQUE0QztBQUM1QztBQUNBLGtCQUFrQixzREFBVztBQUM3QixhQUFhLHNEQUFXO0FBQ3hCLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0EsaUJBQWlCLHNEQUFXO0FBQzVCO0FBQ0EsZ0NBQWdDLHNEQUFXO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixPQUFPLFNBQVMsc0RBQVc7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkVBQTZFO0FBQ2pHO0FBQ0E7QUFDTztBQUNQLElBQUkseURBQWM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxZQUFZLG1DQUFtQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0EsbUJBQW1CLGdEQUFHO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLGlEQUFpRDtBQUNqRCxpQkFBaUI7QUFDakI7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGtDQUFrQztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx3Q0FBd0M7QUFDdEY7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbGZnL0dpdC9NYWR0cmlwcy9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvaGFzaC10by1jdXJ2ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBtb2QgfSBmcm9tICcuL21vZHVsYXIuanMnO1xuaW1wb3J0IHsgYnl0ZXNUb051bWJlckJFLCBjb25jYXRCeXRlcywgdXRmOFRvQnl0ZXMsIHZhbGlkYXRlT2JqZWN0IH0gZnJvbSAnLi91dGlscy5qcyc7XG5mdW5jdGlvbiB2YWxpZGF0ZURTVChkc3QpIHtcbiAgICBpZiAoZHN0IGluc3RhbmNlb2YgVWludDhBcnJheSlcbiAgICAgICAgcmV0dXJuIGRzdDtcbiAgICBpZiAodHlwZW9mIGRzdCA9PT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhkc3QpO1xuICAgIHRocm93IG5ldyBFcnJvcignRFNUIG11c3QgYmUgVWludDhBcnJheSBvciBzdHJpbmcnKTtcbn1cbi8vIE9jdGV0IFN0cmVhbSB0byBJbnRlZ2VyLiBcInNwZWNcIiBpbXBsZW1lbnRhdGlvbiBvZiBvczJpcCBpcyAyLjV4IHNsb3dlciB2cyBieXRlc1RvTnVtYmVyQkUuXG5jb25zdCBvczJpcCA9IGJ5dGVzVG9OdW1iZXJCRTtcbi8vIEludGVnZXIgdG8gT2N0ZXQgU3RyZWFtIChudW1iZXJUb0J5dGVzQkUpXG5mdW5jdGlvbiBpMm9zcCh2YWx1ZSwgbGVuZ3RoKSB7XG4gICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+PSAxIDw8ICg4ICogbGVuZ3RoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJhZCBJMk9TUCBjYWxsOiB2YWx1ZT0ke3ZhbHVlfSBsZW5ndGg9JHtsZW5ndGh9YCk7XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IEFycmF5LmZyb20oeyBsZW5ndGggfSkuZmlsbCgwKTtcbiAgICBmb3IgKGxldCBpID0gbGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgcmVzW2ldID0gdmFsdWUgJiAweGZmO1xuICAgICAgICB2YWx1ZSA+Pj49IDg7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShyZXMpO1xufVxuZnVuY3Rpb24gc3RyeG9yKGEsIGIpIHtcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheShhLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycltpXSA9IGFbaV0gXiBiW2ldO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufVxuZnVuY3Rpb24gaXNCeXRlcyhpdGVtKSB7XG4gICAgaWYgKCEoaXRlbSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbn1cbmZ1bmN0aW9uIGlzTnVtKGl0ZW0pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGl0ZW0pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ251bWJlciBleHBlY3RlZCcpO1xufVxuLy8gUHJvZHVjZXMgYSB1bmlmb3JtbHkgcmFuZG9tIGJ5dGUgc3RyaW5nIHVzaW5nIGEgY3J5cHRvZ3JhcGhpYyBoYXNoIGZ1bmN0aW9uIEggdGhhdCBvdXRwdXRzIGIgYml0c1xuLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjMuMVxuZXhwb3J0IGZ1bmN0aW9uIGV4cGFuZF9tZXNzYWdlX3htZChtc2csIERTVCwgbGVuSW5CeXRlcywgSCkge1xuICAgIGlzQnl0ZXMobXNnKTtcbiAgICBpc0J5dGVzKERTVCk7XG4gICAgaXNOdW0obGVuSW5CeXRlcyk7XG4gICAgLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjMuM1xuICAgIGlmIChEU1QubGVuZ3RoID4gMjU1KVxuICAgICAgICBEU1QgPSBIKGNvbmNhdEJ5dGVzKHV0ZjhUb0J5dGVzKCdIMkMtT1ZFUlNJWkUtRFNULScpLCBEU1QpKTtcbiAgICBjb25zdCB7IG91dHB1dExlbjogYl9pbl9ieXRlcywgYmxvY2tMZW46IHJfaW5fYnl0ZXMgfSA9IEg7XG4gICAgY29uc3QgZWxsID0gTWF0aC5jZWlsKGxlbkluQnl0ZXMgLyBiX2luX2J5dGVzKTtcbiAgICBpZiAoZWxsID4gMjU1KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgeG1kIGxlbmd0aCcpO1xuICAgIGNvbnN0IERTVF9wcmltZSA9IGNvbmNhdEJ5dGVzKERTVCwgaTJvc3AoRFNULmxlbmd0aCwgMSkpO1xuICAgIGNvbnN0IFpfcGFkID0gaTJvc3AoMCwgcl9pbl9ieXRlcyk7XG4gICAgY29uc3QgbF9pX2Jfc3RyID0gaTJvc3AobGVuSW5CeXRlcywgMik7IC8vIGxlbl9pbl9ieXRlc19zdHJcbiAgICBjb25zdCBiID0gbmV3IEFycmF5KGVsbCk7XG4gICAgY29uc3QgYl8wID0gSChjb25jYXRCeXRlcyhaX3BhZCwgbXNnLCBsX2lfYl9zdHIsIGkyb3NwKDAsIDEpLCBEU1RfcHJpbWUpKTtcbiAgICBiWzBdID0gSChjb25jYXRCeXRlcyhiXzAsIGkyb3NwKDEsIDEpLCBEU1RfcHJpbWUpKTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBlbGw7IGkrKykge1xuICAgICAgICBjb25zdCBhcmdzID0gW3N0cnhvcihiXzAsIGJbaSAtIDFdKSwgaTJvc3AoaSArIDEsIDEpLCBEU1RfcHJpbWVdO1xuICAgICAgICBiW2ldID0gSChjb25jYXRCeXRlcyguLi5hcmdzKSk7XG4gICAgfVxuICAgIGNvbnN0IHBzZXVkb19yYW5kb21fYnl0ZXMgPSBjb25jYXRCeXRlcyguLi5iKTtcbiAgICByZXR1cm4gcHNldWRvX3JhbmRvbV9ieXRlcy5zbGljZSgwLCBsZW5JbkJ5dGVzKTtcbn1cbi8vIFByb2R1Y2VzIGEgdW5pZm9ybWx5IHJhbmRvbSBieXRlIHN0cmluZyB1c2luZyBhbiBleHRlbmRhYmxlLW91dHB1dCBmdW5jdGlvbiAoWE9GKSBILlxuLy8gMS4gVGhlIGNvbGxpc2lvbiByZXNpc3RhbmNlIG9mIEggTVVTVCBiZSBhdCBsZWFzdCBrIGJpdHMuXG4vLyAyLiBIIE1VU1QgYmUgYW4gWE9GIHRoYXQgaGFzIGJlZW4gcHJvdmVkIGluZGlmZmVyZW50aWFibGUgZnJvbVxuLy8gICAgYSByYW5kb20gb3JhY2xlIHVuZGVyIGEgcmVhc29uYWJsZSBjcnlwdG9ncmFwaGljIGFzc3VtcHRpb24uXG4vLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMy4yXG5leHBvcnQgZnVuY3Rpb24gZXhwYW5kX21lc3NhZ2VfeG9mKG1zZywgRFNULCBsZW5JbkJ5dGVzLCBrLCBIKSB7XG4gICAgaXNCeXRlcyhtc2cpO1xuICAgIGlzQnl0ZXMoRFNUKTtcbiAgICBpc051bShsZW5JbkJ5dGVzKTtcbiAgICAvLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMy4zXG4gICAgLy8gRFNUID0gSCgnSDJDLU9WRVJTSVpFLURTVC0nIHx8IGFfdmVyeV9sb25nX0RTVCwgTWF0aC5jZWlsKChsZW5JbkJ5dGVzICogaykgLyA4KSk7XG4gICAgaWYgKERTVC5sZW5ndGggPiAyNTUpIHtcbiAgICAgICAgY29uc3QgZGtMZW4gPSBNYXRoLmNlaWwoKDIgKiBrKSAvIDgpO1xuICAgICAgICBEU1QgPSBILmNyZWF0ZSh7IGRrTGVuIH0pLnVwZGF0ZSh1dGY4VG9CeXRlcygnSDJDLU9WRVJTSVpFLURTVC0nKSkudXBkYXRlKERTVCkuZGlnZXN0KCk7XG4gICAgfVxuICAgIGlmIChsZW5JbkJ5dGVzID4gNjU1MzUgfHwgRFNULmxlbmd0aCA+IDI1NSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBhbmRfbWVzc2FnZV94b2Y6IGludmFsaWQgbGVuSW5CeXRlcycpO1xuICAgIHJldHVybiAoSC5jcmVhdGUoeyBka0xlbjogbGVuSW5CeXRlcyB9KVxuICAgICAgICAudXBkYXRlKG1zZylcbiAgICAgICAgLnVwZGF0ZShpMm9zcChsZW5JbkJ5dGVzLCAyKSlcbiAgICAgICAgLy8gMi4gRFNUX3ByaW1lID0gRFNUIHx8IEkyT1NQKGxlbihEU1QpLCAxKVxuICAgICAgICAudXBkYXRlKERTVClcbiAgICAgICAgLnVwZGF0ZShpMm9zcChEU1QubGVuZ3RoLCAxKSlcbiAgICAgICAgLmRpZ2VzdCgpKTtcbn1cbi8qKlxuICogSGFzaGVzIGFyYml0cmFyeS1sZW5ndGggYnl0ZSBzdHJpbmdzIHRvIGEgbGlzdCBvZiBvbmUgb3IgbW9yZSBlbGVtZW50cyBvZiBhIGZpbml0ZSBmaWVsZCBGXG4gKiBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMlxuICogQHBhcmFtIG1zZyBhIGJ5dGUgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIG1lc3NhZ2UgdG8gaGFzaFxuICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgZWxlbWVudHMgb2YgRiB0byBvdXRwdXRcbiAqIEBwYXJhbSBvcHRpb25zIGB7RFNUOiBzdHJpbmcsIHA6IGJpZ2ludCwgbTogbnVtYmVyLCBrOiBudW1iZXIsIGV4cGFuZDogJ3htZCcgfCAneG9mJywgaGFzaDogSH1gLCBzZWUgYWJvdmVcbiAqIEByZXR1cm5zIFt1XzAsIC4uLiwgdV8oY291bnQgLSAxKV0sIGEgbGlzdCBvZiBmaWVsZCBlbGVtZW50cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc2hfdG9fZmllbGQobXNnLCBjb3VudCwgb3B0aW9ucykge1xuICAgIHZhbGlkYXRlT2JqZWN0KG9wdGlvbnMsIHtcbiAgICAgICAgRFNUOiAnc3RyaW5nT3JVaW50OEFycmF5JyxcbiAgICAgICAgcDogJ2JpZ2ludCcsXG4gICAgICAgIG06ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgazogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBoYXNoOiAnaGFzaCcsXG4gICAgfSk7XG4gICAgY29uc3QgeyBwLCBrLCBtLCBoYXNoLCBleHBhbmQsIERTVDogX0RTVCB9ID0gb3B0aW9ucztcbiAgICBpc0J5dGVzKG1zZyk7XG4gICAgaXNOdW0oY291bnQpO1xuICAgIGNvbnN0IERTVCA9IHZhbGlkYXRlRFNUKF9EU1QpO1xuICAgIGNvbnN0IGxvZzJwID0gcC50b1N0cmluZygyKS5sZW5ndGg7XG4gICAgY29uc3QgTCA9IE1hdGguY2VpbCgobG9nMnAgKyBrKSAvIDgpOyAvLyBzZWN0aW9uIDUuMSBvZiBpZXRmIGRyYWZ0IGxpbmsgYWJvdmVcbiAgICBjb25zdCBsZW5faW5fYnl0ZXMgPSBjb3VudCAqIG0gKiBMO1xuICAgIGxldCBwcmI7IC8vIHBzZXVkb19yYW5kb21fYnl0ZXNcbiAgICBpZiAoZXhwYW5kID09PSAneG1kJykge1xuICAgICAgICBwcmIgPSBleHBhbmRfbWVzc2FnZV94bWQobXNnLCBEU1QsIGxlbl9pbl9ieXRlcywgaGFzaCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV4cGFuZCA9PT0gJ3hvZicpIHtcbiAgICAgICAgcHJiID0gZXhwYW5kX21lc3NhZ2VfeG9mKG1zZywgRFNULCBsZW5faW5fYnl0ZXMsIGssIGhhc2gpO1xuICAgIH1cbiAgICBlbHNlIGlmIChleHBhbmQgPT09ICdfaW50ZXJuYWxfcGFzcycpIHtcbiAgICAgICAgLy8gZm9yIGludGVybmFsIHRlc3RzIG9ubHlcbiAgICAgICAgcHJiID0gbXNnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBhbmQgbXVzdCBiZSBcInhtZFwiIG9yIFwieG9mXCInKTtcbiAgICB9XG4gICAgY29uc3QgdSA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGUgPSBuZXcgQXJyYXkobSk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbTsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCBlbG1fb2Zmc2V0ID0gTCAqIChqICsgaSAqIG0pO1xuICAgICAgICAgICAgY29uc3QgdHYgPSBwcmIuc3ViYXJyYXkoZWxtX29mZnNldCwgZWxtX29mZnNldCArIEwpO1xuICAgICAgICAgICAgZVtqXSA9IG1vZChvczJpcCh0diksIHApO1xuICAgICAgICB9XG4gICAgICAgIHVbaV0gPSBlO1xuICAgIH1cbiAgICByZXR1cm4gdTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc29nZW55TWFwKGZpZWxkLCBtYXApIHtcbiAgICAvLyBNYWtlIHNhbWUgb3JkZXIgYXMgaW4gc3BlY1xuICAgIGNvbnN0IENPRUZGID0gbWFwLm1hcCgoaSkgPT4gQXJyYXkuZnJvbShpKS5yZXZlcnNlKCkpO1xuICAgIHJldHVybiAoeCwgeSkgPT4ge1xuICAgICAgICBjb25zdCBbeE51bSwgeERlbiwgeU51bSwgeURlbl0gPSBDT0VGRi5tYXAoKHZhbCkgPT4gdmFsLnJlZHVjZSgoYWNjLCBpKSA9PiBmaWVsZC5hZGQoZmllbGQubXVsKGFjYywgeCksIGkpKSk7XG4gICAgICAgIHggPSBmaWVsZC5kaXYoeE51bSwgeERlbik7IC8vIHhOdW0gLyB4RGVuXG4gICAgICAgIHkgPSBmaWVsZC5tdWwoeSwgZmllbGQuZGl2KHlOdW0sIHlEZW4pKTsgLy8geSAqICh5TnVtIC8geURldilcbiAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSGFzaGVyKFBvaW50LCBtYXBUb0N1cnZlLCBkZWYpIHtcbiAgICBpZiAodHlwZW9mIG1hcFRvQ3VydmUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWFwVG9DdXJ2ZSgpIG11c3QgYmUgZGVmaW5lZCcpO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8vIEVuY29kZXMgYnl0ZSBzdHJpbmcgdG8gZWxsaXB0aWMgY3VydmUuXG4gICAgICAgIC8vIGhhc2hfdG9fY3VydmUgZnJvbSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTNcbiAgICAgICAgaGFzaFRvQ3VydmUobXNnLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCB1ID0gaGFzaF90b19maWVsZChtc2csIDIsIHsgLi4uZGVmLCBEU1Q6IGRlZi5EU1QsIC4uLm9wdGlvbnMgfSk7XG4gICAgICAgICAgICBjb25zdCB1MCA9IFBvaW50LmZyb21BZmZpbmUobWFwVG9DdXJ2ZSh1WzBdKSk7XG4gICAgICAgICAgICBjb25zdCB1MSA9IFBvaW50LmZyb21BZmZpbmUobWFwVG9DdXJ2ZSh1WzFdKSk7XG4gICAgICAgICAgICBjb25zdCBQID0gdTAuYWRkKHUxKS5jbGVhckNvZmFjdG9yKCk7XG4gICAgICAgICAgICBQLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUDtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gRW5jb2RlcyBieXRlIHN0cmluZyB0byBlbGxpcHRpYyBjdXJ2ZS5cbiAgICAgICAgLy8gZW5jb2RlX3RvX2N1cnZlIGZyb20gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi0zXG4gICAgICAgIGVuY29kZVRvQ3VydmUobXNnLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCB1ID0gaGFzaF90b19maWVsZChtc2csIDEsIHsgLi4uZGVmLCBEU1Q6IGRlZi5lbmNvZGVEU1QsIC4uLm9wdGlvbnMgfSk7XG4gICAgICAgICAgICBjb25zdCBQID0gUG9pbnQuZnJvbUFmZmluZShtYXBUb0N1cnZlKHVbMF0pKS5jbGVhckNvZmFjdG9yKCk7XG4gICAgICAgICAgICBQLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUDtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFzaC10by1jdXJ2ZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/hash-to-curve.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/modular.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/modular.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Field: () => (/* binding */ Field),\n/* harmony export */   FpDiv: () => (/* binding */ FpDiv),\n/* harmony export */   FpInvertBatch: () => (/* binding */ FpInvertBatch),\n/* harmony export */   FpIsSquare: () => (/* binding */ FpIsSquare),\n/* harmony export */   FpPow: () => (/* binding */ FpPow),\n/* harmony export */   FpSqrt: () => (/* binding */ FpSqrt),\n/* harmony export */   FpSqrtEven: () => (/* binding */ FpSqrtEven),\n/* harmony export */   FpSqrtOdd: () => (/* binding */ FpSqrtOdd),\n/* harmony export */   getFieldBytesLength: () => (/* binding */ getFieldBytesLength),\n/* harmony export */   getMinHashLength: () => (/* binding */ getMinHashLength),\n/* harmony export */   hashToPrivateScalar: () => (/* binding */ hashToPrivateScalar),\n/* harmony export */   invert: () => (/* binding */ invert),\n/* harmony export */   isNegativeLE: () => (/* binding */ isNegativeLE),\n/* harmony export */   mapHashToField: () => (/* binding */ mapHashToField),\n/* harmony export */   mod: () => (/* binding */ mod),\n/* harmony export */   nLength: () => (/* binding */ nLength),\n/* harmony export */   pow: () => (/* binding */ pow),\n/* harmony export */   pow2: () => (/* binding */ pow2),\n/* harmony export */   tonelliShanks: () => (/* binding */ tonelliShanks),\n/* harmony export */   validateField: () => (/* binding */ validateField)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Utilities for modular arithmetics and finite fields\n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);\n// prettier-ignore\nconst _9n = BigInt(9), _16n = BigInt(16);\n// Calculates a modulo b\nfunction mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\n// TODO: use field version && remove\nfunction pow(num, power, modulo) {\n    if (modulo <= _0n || power < _0n)\n        throw new Error('Expected power/modulo > 0');\n    if (modulo === _1n)\n        return _0n;\n    let res = _1n;\n    while (power > _0n) {\n        if (power & _1n)\n            res = (res * num) % modulo;\n        num = (num * num) % modulo;\n        power >>= _1n;\n    }\n    return res;\n}\n// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)\nfunction pow2(x, power, modulo) {\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n// Inverses number over modulo\nfunction invert(number, modulo) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * Will start an infinite loop if field order P is not prime.\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nfunction tonelliShanks(P) {\n    // Legendre constant: used to calculate Legendre symbol (a | p),\n    // which denotes the value of a^((p-1)/2) (mod p).\n    // (a | p) ≡ 1    if a is a square (mod p)\n    // (a | p) ≡ -1   if a is not a square (mod p)\n    // (a | p) ≡ 0    if a ≡ 0 (mod p)\n    const legendreC = (P - _1n) / _2n;\n    let Q, S, Z;\n    // Step 1: By factoring out powers of 2 from p - 1,\n    // find q and s such that p - 1 = q*(2^s) with q odd\n    for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)\n        ;\n    // Step 2: Select a non-square z such that (z | p) ≡ -1 and set c ≡ zq\n    for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++)\n        ;\n    // Fast-path\n    if (S === 1) {\n        const p1div4 = (P + _1n) / _4n;\n        return function tonelliFast(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Slow-path\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        // Step 0: Check that n is indeed a square: (n | p) should not be ≡ -1\n        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))\n            throw new Error('Cannot find square root');\n        let r = S;\n        // TODO: will fail at Fp2/etc\n        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n        let x = Fp.pow(n, Q1div2); // first guess at the square root\n        let b = Fp.pow(n, Q); // first guess at the fudge factor\n        while (!Fp.eql(b, Fp.ONE)) {\n            if (Fp.eql(b, Fp.ZERO))\n                return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n            // Find m such b^(2^m)==1\n            let m = 1;\n            for (let t2 = Fp.sqr(b); m < r; m++) {\n                if (Fp.eql(t2, Fp.ONE))\n                    break;\n                t2 = Fp.sqr(t2); // t2 *= t2\n            }\n            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n            g = Fp.sqr(ge); // g = ge * ge\n            x = Fp.mul(x, ge); // x *= ge\n            b = Fp.mul(b, g); // b *= g\n            r = m;\n        }\n        return x;\n    };\n}\nfunction FpSqrt(P) {\n    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.\n    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n    // P ≡ 3 (mod 4)\n    // √n = n^((P+1)/4)\n    if (P % _4n === _3n) {\n        // Not all roots possible!\n        // const ORDER =\n        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n        // const NUM = 72057594037927816n;\n        const p1div4 = (P + _1n) / _4n;\n        return function sqrt3mod4(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            // Throw if root**2 != n\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Atkin algorithm for q ≡ 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n    if (P % _8n === _5n) {\n        const c1 = (P - _5n) / _8n;\n        return function sqrt5mod8(Fp, n) {\n            const n2 = Fp.mul(n, _2n);\n            const v = Fp.pow(n2, c1);\n            const nv = Fp.mul(n, v);\n            const i = Fp.mul(Fp.mul(nv, _2n), v);\n            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // P ≡ 9 (mod 16)\n    if (P % _16n === _9n) {\n        // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n        // Means we cannot use sqrt for constants at all!\n        //\n        // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n        // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n        // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n        // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n        // sqrt = (x) => {\n        //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n        //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n        //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n        //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n        //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n        //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n        //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n        //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n        //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n        //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n        // }\n    }\n    // Other cases: Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nconst isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n    'eql', 'add', 'sub', 'mul', 'pow', 'div',\n    'addN', 'subN', 'mulN', 'sqrN'\n];\nfunction validateField(field) {\n    const initial = {\n        ORDER: 'bigint',\n        MASK: 'bigint',\n        BYTES: 'isSafeInteger',\n        BITS: 'isSafeInteger',\n    };\n    const opts = FIELD_FIELDS.reduce((map, val) => {\n        map[val] = 'function';\n        return map;\n    }, initial);\n    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(field, opts);\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nfunction FpPow(f, num, power) {\n    // Should have same speed as pow for bigints\n    // TODO: benchmark!\n    if (power < _0n)\n        throw new Error('Expected power > 0');\n    if (power === _0n)\n        return f.ONE;\n    if (power === _1n)\n        return num;\n    let p = f.ONE;\n    let d = num;\n    while (power > _0n) {\n        if (power & _1n)\n            p = f.mul(p, d);\n        d = f.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * `inv(0)` will return `undefined` here: make sure to throw an error.\n */\nfunction FpInvertBatch(f, nums) {\n    const tmp = new Array(nums.length);\n    // Walk from first to last, multiply them by each other MOD p\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = acc;\n        return f.mul(acc, num);\n    }, f.ONE);\n    // Invert last element\n    const inverted = f.inv(lastMultiplied);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = f.mul(acc, tmp[i]);\n        return f.mul(acc, num);\n    }, inverted);\n    return tmp;\n}\nfunction FpDiv(f, lhs, rhs) {\n    return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\n// This function returns True whenever the value x is a square in the field F.\nfunction FpIsSquare(f) {\n    const legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic\n    return (x) => {\n        const p = f.pow(x, legendreConst);\n        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n    };\n}\n// CURVE.n lengths\nfunction nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return { nBitLength: _nBitLength, nByteLength };\n}\n/**\n * Initializes a finite field over prime. **Non-primes are not supported.**\n * Do not init in loop: slow. Very fragile: always run a benchmark on a change.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nfunction Field(ORDER, bitLen, isLE = false, redef = {}) {\n    if (ORDER <= _0n)\n        throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n    if (BYTES > 2048)\n        throw new Error('Field lengths over 2048 bytes are not supported');\n    const sqrtP = FpSqrt(ORDER);\n    const f = Object.freeze({\n        ORDER,\n        BITS,\n        BYTES,\n        MASK: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        create: (num) => mod(num, ORDER),\n        isValid: (num) => {\n            if (typeof num !== 'bigint')\n                throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num) => num === _0n,\n        isOdd: (num) => (num & _1n) === _1n,\n        neg: (num) => mod(-num, ORDER),\n        eql: (lhs, rhs) => lhs === rhs,\n        sqr: (num) => mod(num * num, ORDER),\n        add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n        pow: (num, power) => FpPow(f, num, power),\n        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num) => num * num,\n        addN: (lhs, rhs) => lhs + rhs,\n        subN: (lhs, rhs) => lhs - rhs,\n        mulN: (lhs, rhs) => lhs * rhs,\n        inv: (num) => invert(num, ORDER),\n        sqrt: redef.sqrt || ((n) => sqrtP(f, n)),\n        invertBatch: (lst) => FpInvertBatch(f, lst),\n        // TODO: do we really need constant cmov?\n        // We don't have const-time bigints anyway, so probably will be not very useful\n        cmov: (a, b, c) => (c ? b : a),\n        toBytes: (num) => (isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(num, BYTES) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(num, BYTES)),\n        fromBytes: (bytes) => {\n            if (bytes.length !== BYTES)\n                throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);\n            return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(bytes) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(bytes);\n        },\n    });\n    return Object.freeze(f);\n}\nfunction FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nfunction FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use mapKeyToField instead\n */\nfunction hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('privateHash', hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n        throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(hash) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nfunction getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== 'bigint')\n        throw new Error('field order must be bigint');\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nfunction getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nfunction mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024)\n        throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(key) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(reduced, fieldLen) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(reduced, fieldLen);\n}\n//# sourceMappingURL=modular.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvbW9kdWxhci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ3VJO0FBQ3ZJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxxRUFBcUUsUUFBUSxNQUFNLE9BQU87QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsaUJBQWlCO0FBQzlDO0FBQ0E7QUFDQSxrQkFBa0IsMkNBQTJDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDLG1DQUFtQztBQUNuQyw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBLGlDQUFpQztB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O0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTyw0QkFBNEIsSUFBSTtBQUMzRSx1QkFBdUIsMERBQWUsUUFBUSwwREFBZTtBQUM3RDtBQUNBO0FBQ0Esa0JBQWtCLDBEQUFlLHNCQUFzQiwwREFBZTtBQUN0RTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9sZmcvR2l0L01hZHRyaXBzL25vZGVfbW9kdWxlcy9Abm9zdHItZGV2LWtpdC9uZGsvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9tb2R1bGFyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIFV0aWxpdGllcyBmb3IgbW9kdWxhciBhcml0aG1ldGljcyBhbmQgZmluaXRlIGZpZWxkc1xuaW1wb3J0IHsgYml0TWFzaywgbnVtYmVyVG9CeXRlc0JFLCBudW1iZXJUb0J5dGVzTEUsIGJ5dGVzVG9OdW1iZXJCRSwgYnl0ZXNUb051bWJlckxFLCBlbnN1cmVCeXRlcywgdmFsaWRhdGVPYmplY3QsIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKSwgXzFuID0gQmlnSW50KDEpLCBfMm4gPSBCaWdJbnQoMiksIF8zbiA9IEJpZ0ludCgzKTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzRuID0gQmlnSW50KDQpLCBfNW4gPSBCaWdJbnQoNSksIF84biA9IEJpZ0ludCg4KTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzluID0gQmlnSW50KDkpLCBfMTZuID0gQmlnSW50KDE2KTtcbi8vIENhbGN1bGF0ZXMgYSBtb2R1bG8gYlxuZXhwb3J0IGZ1bmN0aW9uIG1vZChhLCBiKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYSAlIGI7XG4gICAgcmV0dXJuIHJlc3VsdCA+PSBfMG4gPyByZXN1bHQgOiBiICsgcmVzdWx0O1xufVxuLyoqXG4gKiBFZmZpY2llbnRseSByYWlzZSBudW0gdG8gcG93ZXIgYW5kIGRvIG1vZHVsYXIgZGl2aXNpb24uXG4gKiBVbnNhZmUgaW4gc29tZSBjb250ZXh0czogdXNlcyBsYWRkZXIsIHNvIGNhbiBleHBvc2UgYmlnaW50IGJpdHMuXG4gKiBAZXhhbXBsZVxuICogcG93KDJuLCA2biwgMTFuKSAvLyA2NG4gJSAxMW4gPT0gOW5cbiAqL1xuLy8gVE9ETzogdXNlIGZpZWxkIHZlcnNpb24gJiYgcmVtb3ZlXG5leHBvcnQgZnVuY3Rpb24gcG93KG51bSwgcG93ZXIsIG1vZHVsbykge1xuICAgIGlmIChtb2R1bG8gPD0gXzBuIHx8IHBvd2VyIDwgXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHBvd2VyL21vZHVsbyA+IDAnKTtcbiAgICBpZiAobW9kdWxvID09PSBfMW4pXG4gICAgICAgIHJldHVybiBfMG47XG4gICAgbGV0IHJlcyA9IF8xbjtcbiAgICB3aGlsZSAocG93ZXIgPiBfMG4pIHtcbiAgICAgICAgaWYgKHBvd2VyICYgXzFuKVxuICAgICAgICAgICAgcmVzID0gKHJlcyAqIG51bSkgJSBtb2R1bG87XG4gICAgICAgIG51bSA9IChudW0gKiBudW0pICUgbW9kdWxvO1xuICAgICAgICBwb3dlciA+Pj0gXzFuO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLy8gRG9lcyB4IF4gKDIgXiBwb3dlcikgbW9kIHAuIHBvdzIoMzAsIDQpID09IDMwIF4gKDIgXiA0KVxuZXhwb3J0IGZ1bmN0aW9uIHBvdzIoeCwgcG93ZXIsIG1vZHVsbykge1xuICAgIGxldCByZXMgPSB4O1xuICAgIHdoaWxlIChwb3dlci0tID4gXzBuKSB7XG4gICAgICAgIHJlcyAqPSByZXM7XG4gICAgICAgIHJlcyAlPSBtb2R1bG87XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vLyBJbnZlcnNlcyBudW1iZXIgb3ZlciBtb2R1bG9cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnQobnVtYmVyLCBtb2R1bG8pIHtcbiAgICBpZiAobnVtYmVyID09PSBfMG4gfHwgbW9kdWxvIDw9IF8wbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmVydDogZXhwZWN0ZWQgcG9zaXRpdmUgaW50ZWdlcnMsIGdvdCBuPSR7bnVtYmVyfSBtb2Q9JHttb2R1bG99YCk7XG4gICAgfVxuICAgIC8vIEV1Y2xpZGVhbiBHQ0QgaHR0cHM6Ly9icmlsbGlhbnQub3JnL3dpa2kvZXh0ZW5kZWQtZXVjbGlkZWFuLWFsZ29yaXRobS9cbiAgICAvLyBGZXJtYXQncyBsaXR0bGUgdGhlb3JlbSBcIkNULWxpa2VcIiB2ZXJzaW9uIGludihuKSA9IG5eKG0tMikgbW9kIG0gaXMgMzB4IHNsb3dlci5cbiAgICBsZXQgYSA9IG1vZChudW1iZXIsIG1vZHVsbyk7XG4gICAgbGV0IGIgPSBtb2R1bG87XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgbGV0IHggPSBfMG4sIHkgPSBfMW4sIHUgPSBfMW4sIHYgPSBfMG47XG4gICAgd2hpbGUgKGEgIT09IF8wbikge1xuICAgICAgICAvLyBKSVQgYXBwbGllcyBvcHRpbWl6YXRpb24gaWYgdGhvc2UgdHdvIGxpbmVzIGZvbGxvdyBlYWNoIG90aGVyXG4gICAgICAgIGNvbnN0IHEgPSBiIC8gYTtcbiAgICAgICAgY29uc3QgciA9IGIgJSBhO1xuICAgICAgICBjb25zdCBtID0geCAtIHUgKiBxO1xuICAgICAgICBjb25zdCBuID0geSAtIHYgKiBxO1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgYiA9IGEsIGEgPSByLCB4ID0gdSwgeSA9IHYsIHUgPSBtLCB2ID0gbjtcbiAgICB9XG4gICAgY29uc3QgZ2NkID0gYjtcbiAgICBpZiAoZ2NkICE9PSBfMW4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52ZXJ0OiBkb2VzIG5vdCBleGlzdCcpO1xuICAgIHJldHVybiBtb2QoeCwgbW9kdWxvKTtcbn1cbi8qKlxuICogVG9uZWxsaS1TaGFua3Mgc3F1YXJlIHJvb3Qgc2VhcmNoIGFsZ29yaXRobS5cbiAqIDEuIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTIvNjg1LnBkZiAocGFnZSAxMilcbiAqIDIuIFNxdWFyZSBSb290cyBmcm9tIDE7IDI0LCA1MSwgMTAgdG8gRGFuIFNoYW5rc1xuICogV2lsbCBzdGFydCBhbiBpbmZpbml0ZSBsb29wIGlmIGZpZWxkIG9yZGVyIFAgaXMgbm90IHByaW1lLlxuICogQHBhcmFtIFAgZmllbGQgb3JkZXJcbiAqIEByZXR1cm5zIGZ1bmN0aW9uIHRoYXQgdGFrZXMgZmllbGQgRnAgKGNyZWF0ZWQgZnJvbSBQKSBhbmQgbnVtYmVyIG5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvbmVsbGlTaGFua3MoUCkge1xuICAgIC8vIExlZ2VuZHJlIGNvbnN0YW50OiB1c2VkIHRvIGNhbGN1bGF0ZSBMZWdlbmRyZSBzeW1ib2wgKGEgfCBwKSxcbiAgICAvLyB3aGljaCBkZW5vdGVzIHRoZSB2YWx1ZSBvZiBhXigocC0xKS8yKSAobW9kIHApLlxuICAgIC8vIChhIHwgcCkg4omhIDEgICAgaWYgYSBpcyBhIHNxdWFyZSAobW9kIHApXG4gICAgLy8gKGEgfCBwKSDiiaEgLTEgICBpZiBhIGlzIG5vdCBhIHNxdWFyZSAobW9kIHApXG4gICAgLy8gKGEgfCBwKSDiiaEgMCAgICBpZiBhIOKJoSAwIChtb2QgcClcbiAgICBjb25zdCBsZWdlbmRyZUMgPSAoUCAtIF8xbikgLyBfMm47XG4gICAgbGV0IFEsIFMsIFo7XG4gICAgLy8gU3RlcCAxOiBCeSBmYWN0b3Jpbmcgb3V0IHBvd2VycyBvZiAyIGZyb20gcCAtIDEsXG4gICAgLy8gZmluZCBxIGFuZCBzIHN1Y2ggdGhhdCBwIC0gMSA9IHEqKDJecykgd2l0aCBxIG9kZFxuICAgIGZvciAoUSA9IFAgLSBfMW4sIFMgPSAwOyBRICUgXzJuID09PSBfMG47IFEgLz0gXzJuLCBTKyspXG4gICAgICAgIDtcbiAgICAvLyBTdGVwIDI6IFNlbGVjdCBhIG5vbi1zcXVhcmUgeiBzdWNoIHRoYXQgKHogfCBwKSDiiaEgLTEgYW5kIHNldCBjIOKJoSB6cVxuICAgIGZvciAoWiA9IF8ybjsgWiA8IFAgJiYgcG93KFosIGxlZ2VuZHJlQywgUCkgIT09IFAgLSBfMW47IForKylcbiAgICAgICAgO1xuICAgIC8vIEZhc3QtcGF0aFxuICAgIGlmIChTID09PSAxKSB7XG4gICAgICAgIGNvbnN0IHAxZGl2NCA9IChQICsgXzFuKSAvIF80bjtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHRvbmVsbGlGYXN0KEZwLCBuKSB7XG4gICAgICAgICAgICBjb25zdCByb290ID0gRnAucG93KG4sIHAxZGl2NCk7XG4gICAgICAgICAgICBpZiAoIUZwLmVxbChGcC5zcXIocm9vdCksIG4pKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICAgICAgICAgIHJldHVybiByb290O1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBTbG93LXBhdGhcbiAgICBjb25zdCBRMWRpdjIgPSAoUSArIF8xbikgLyBfMm47XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHRvbmVsbGlTbG93KEZwLCBuKSB7XG4gICAgICAgIC8vIFN0ZXAgMDogQ2hlY2sgdGhhdCBuIGlzIGluZGVlZCBhIHNxdWFyZTogKG4gfCBwKSBzaG91bGQgbm90IGJlIOKJoSAtMVxuICAgICAgICBpZiAoRnAucG93KG4sIGxlZ2VuZHJlQykgPT09IEZwLm5lZyhGcC5PTkUpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICBsZXQgciA9IFM7XG4gICAgICAgIC8vIFRPRE86IHdpbGwgZmFpbCBhdCBGcDIvZXRjXG4gICAgICAgIGxldCBnID0gRnAucG93KEZwLm11bChGcC5PTkUsIFopLCBRKTsgLy8gd2lsbCB1cGRhdGUgYm90aCB4IGFuZCBiXG4gICAgICAgIGxldCB4ID0gRnAucG93KG4sIFExZGl2Mik7IC8vIGZpcnN0IGd1ZXNzIGF0IHRoZSBzcXVhcmUgcm9vdFxuICAgICAgICBsZXQgYiA9IEZwLnBvdyhuLCBRKTsgLy8gZmlyc3QgZ3Vlc3MgYXQgdGhlIGZ1ZGdlIGZhY3RvclxuICAgICAgICB3aGlsZSAoIUZwLmVxbChiLCBGcC5PTkUpKSB7XG4gICAgICAgICAgICBpZiAoRnAuZXFsKGIsIEZwLlpFUk8pKVxuICAgICAgICAgICAgICAgIHJldHVybiBGcC5aRVJPOyAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Ub25lbGxpJUUyJTgwJTkzU2hhbmtzX2FsZ29yaXRobSAoNC4gSWYgdCA9IDAsIHJldHVybiByID0gMClcbiAgICAgICAgICAgIC8vIEZpbmQgbSBzdWNoIGJeKDJebSk9PTFcbiAgICAgICAgICAgIGxldCBtID0gMTtcbiAgICAgICAgICAgIGZvciAobGV0IHQyID0gRnAuc3FyKGIpOyBtIDwgcjsgbSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKEZwLmVxbCh0MiwgRnAuT05FKSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgdDIgPSBGcC5zcXIodDIpOyAvLyB0MiAqPSB0MlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTk9URTogci1tLTEgY2FuIGJlIGJpZ2dlciB0aGFuIDMyLCBuZWVkIHRvIGNvbnZlcnQgdG8gYmlnaW50IGJlZm9yZSBzaGlmdCwgb3RoZXJ3aXNlIHRoZXJlIHdpbGwgYmUgb3ZlcmZsb3dcbiAgICAgICAgICAgIGNvbnN0IGdlID0gRnAucG93KGcsIF8xbiA8PCBCaWdJbnQociAtIG0gLSAxKSk7IC8vIGdlID0gMl4oci1tLTEpXG4gICAgICAgICAgICBnID0gRnAuc3FyKGdlKTsgLy8gZyA9IGdlICogZ2VcbiAgICAgICAgICAgIHggPSBGcC5tdWwoeCwgZ2UpOyAvLyB4ICo9IGdlXG4gICAgICAgICAgICBiID0gRnAubXVsKGIsIGcpOyAvLyBiICo9IGdcbiAgICAgICAgICAgIHIgPSBtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4O1xuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gRnBTcXJ0KFApIHtcbiAgICAvLyBOT1RFOiBkaWZmZXJlbnQgYWxnb3JpdGhtcyBjYW4gZ2l2ZSBkaWZmZXJlbnQgcm9vdHMsIGl0IGlzIHVwIHRvIHVzZXIgdG8gZGVjaWRlIHdoaWNoIG9uZSB0aGV5IHdhbnQuXG4gICAgLy8gRm9yIGV4YW1wbGUgdGhlcmUgaXMgRnBTcXJ0T2RkL0ZwU3FydEV2ZW4gdG8gY2hvaWNlIHJvb3QgYmFzZWQgb24gb2RkbmVzcyAodXNlZCBmb3IgaGFzaC10by1jdXJ2ZSkuXG4gICAgLy8gUCDiiaEgMyAobW9kIDQpXG4gICAgLy8g4oiabiA9IG5eKChQKzEpLzQpXG4gICAgaWYgKFAgJSBfNG4gPT09IF8zbikge1xuICAgICAgICAvLyBOb3QgYWxsIHJvb3RzIHBvc3NpYmxlIVxuICAgICAgICAvLyBjb25zdCBPUkRFUiA9XG4gICAgICAgIC8vICAgMHgxYTAxMTFlYTM5N2ZlNjlhNGIxYmE3YjY0MzRiYWNkNzY0Nzc0Yjg0ZjM4NTEyYmY2NzMwZDJhMGY2YjBmNjI0MWVhYmZmZmViMTUzZmZmZmI5ZmVmZmZmZmZmZmFhYWJuO1xuICAgICAgICAvLyBjb25zdCBOVU0gPSA3MjA1NzU5NDAzNzkyNzgxNm47XG4gICAgICAgIGNvbnN0IHAxZGl2NCA9IChQICsgXzFuKSAvIF80bjtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNxcnQzbW9kNChGcCwgbikge1xuICAgICAgICAgICAgY29uc3Qgcm9vdCA9IEZwLnBvdyhuLCBwMWRpdjQpO1xuICAgICAgICAgICAgLy8gVGhyb3cgaWYgcm9vdCoqMiAhPSBuXG4gICAgICAgICAgICBpZiAoIUZwLmVxbChGcC5zcXIocm9vdCksIG4pKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICAgICAgICAgIHJldHVybiByb290O1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBBdGtpbiBhbGdvcml0aG0gZm9yIHEg4omhIDUgKG1vZCA4KSwgaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxMi82ODUucGRmIChwYWdlIDEwKVxuICAgIGlmIChQICUgXzhuID09PSBfNW4pIHtcbiAgICAgICAgY29uc3QgYzEgPSAoUCAtIF81bikgLyBfOG47XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBzcXJ0NW1vZDgoRnAsIG4pIHtcbiAgICAgICAgICAgIGNvbnN0IG4yID0gRnAubXVsKG4sIF8ybik7XG4gICAgICAgICAgICBjb25zdCB2ID0gRnAucG93KG4yLCBjMSk7XG4gICAgICAgICAgICBjb25zdCBudiA9IEZwLm11bChuLCB2KTtcbiAgICAgICAgICAgIGNvbnN0IGkgPSBGcC5tdWwoRnAubXVsKG52LCBfMm4pLCB2KTtcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSBGcC5tdWwobnYsIEZwLnN1YihpLCBGcC5PTkUpKTtcbiAgICAgICAgICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgbikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIFAg4omhIDkgKG1vZCAxNilcbiAgICBpZiAoUCAlIF8xNm4gPT09IF85bikge1xuICAgICAgICAvLyBOT1RFOiB0b25lbGxpIGlzIHRvbyBzbG93IGZvciBibHMtRnAyIGNhbGN1bGF0aW9ucyBldmVuIG9uIHN0YXJ0XG4gICAgICAgIC8vIE1lYW5zIHdlIGNhbm5vdCB1c2Ugc3FydCBmb3IgY29uc3RhbnRzIGF0IGFsbCFcbiAgICAgICAgLy9cbiAgICAgICAgLy8gY29uc3QgYzEgPSBGcC5zcXJ0KEZwLm5lZ2F0ZShGcC5PTkUpKTsgLy8gIDEuIGMxID0gc3FydCgtMSkgaW4gRiwgaS5lLiwgKGMxXjIpID09IC0xIGluIEZcbiAgICAgICAgLy8gY29uc3QgYzIgPSBGcC5zcXJ0KGMxKTsgICAgICAgICAgICAgICAgLy8gIDIuIGMyID0gc3FydChjMSkgaW4gRiwgaS5lLiwgKGMyXjIpID09IGMxIGluIEZcbiAgICAgICAgLy8gY29uc3QgYzMgPSBGcC5zcXJ0KEZwLm5lZ2F0ZShjMSkpOyAgICAgLy8gIDMuIGMzID0gc3FydCgtYzEpIGluIEYsIGkuZS4sIChjM14yKSA9PSAtYzEgaW4gRlxuICAgICAgICAvLyBjb25zdCBjNCA9IChQICsgXzduKSAvIF8xNm47ICAgICAgICAgICAvLyAgNC4gYzQgPSAocSArIDcpIC8gMTYgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgICAgIC8vIHNxcnQgPSAoeCkgPT4ge1xuICAgICAgICAvLyAgIGxldCB0djEgPSBGcC5wb3coeCwgYzQpOyAgICAgICAgICAgICAvLyAgMS4gdHYxID0geF5jNFxuICAgICAgICAvLyAgIGxldCB0djIgPSBGcC5tdWwoYzEsIHR2MSk7ICAgICAgICAgICAvLyAgMi4gdHYyID0gYzEgKiB0djFcbiAgICAgICAgLy8gICBjb25zdCB0djMgPSBGcC5tdWwoYzIsIHR2MSk7ICAgICAgICAgLy8gIDMuIHR2MyA9IGMyICogdHYxXG4gICAgICAgIC8vICAgbGV0IHR2NCA9IEZwLm11bChjMywgdHYxKTsgICAgICAgICAgIC8vICA0LiB0djQgPSBjMyAqIHR2MVxuICAgICAgICAvLyAgIGNvbnN0IGUxID0gRnAuZXF1YWxzKEZwLnNxdWFyZSh0djIpLCB4KTsgLy8gIDUuICBlMSA9ICh0djJeMikgPT0geFxuICAgICAgICAvLyAgIGNvbnN0IGUyID0gRnAuZXF1YWxzKEZwLnNxdWFyZSh0djMpLCB4KTsgLy8gIDYuICBlMiA9ICh0djNeMikgPT0geFxuICAgICAgICAvLyAgIHR2MSA9IEZwLmNtb3YodHYxLCB0djIsIGUxKTsgLy8gIDcuIHR2MSA9IENNT1YodHYxLCB0djIsIGUxKSAgIyBTZWxlY3QgdHYyIGlmICh0djJeMikgPT0geFxuICAgICAgICAvLyAgIHR2MiA9IEZwLmNtb3YodHY0LCB0djMsIGUyKTsgLy8gIDguIHR2MiA9IENNT1YodHY0LCB0djMsIGUyKSAgIyBTZWxlY3QgdHYzIGlmICh0djNeMikgPT0geFxuICAgICAgICAvLyAgIGNvbnN0IGUzID0gRnAuZXF1YWxzKEZwLnNxdWFyZSh0djIpLCB4KTsgLy8gIDkuICBlMyA9ICh0djJeMikgPT0geFxuICAgICAgICAvLyAgIHJldHVybiBGcC5jbW92KHR2MSwgdHYyLCBlMyk7IC8vICAxMC4gIHogPSBDTU9WKHR2MSwgdHYyLCBlMykgICMgU2VsZWN0IHRoZSBzcXJ0IGZyb20gdHYxIGFuZCB0djJcbiAgICAgICAgLy8gfVxuICAgIH1cbiAgICAvLyBPdGhlciBjYXNlczogVG9uZWxsaS1TaGFua3MgYWxnb3JpdGhtXG4gICAgcmV0dXJuIHRvbmVsbGlTaGFua3MoUCk7XG59XG4vLyBMaXR0bGUtZW5kaWFuIGNoZWNrIGZvciBmaXJzdCBMRSBiaXQgKGxhc3QgQkUgYml0KTtcbmV4cG9ydCBjb25zdCBpc05lZ2F0aXZlTEUgPSAobnVtLCBtb2R1bG8pID0+IChtb2QobnVtLCBtb2R1bG8pICYgXzFuKSA9PT0gXzFuO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBGSUVMRF9GSUVMRFMgPSBbXG4gICAgJ2NyZWF0ZScsICdpc1ZhbGlkJywgJ2lzMCcsICduZWcnLCAnaW52JywgJ3NxcnQnLCAnc3FyJyxcbiAgICAnZXFsJywgJ2FkZCcsICdzdWInLCAnbXVsJywgJ3BvdycsICdkaXYnLFxuICAgICdhZGROJywgJ3N1Yk4nLCAnbXVsTicsICdzcXJOJ1xuXTtcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUZpZWxkKGZpZWxkKSB7XG4gICAgY29uc3QgaW5pdGlhbCA9IHtcbiAgICAgICAgT1JERVI6ICdiaWdpbnQnLFxuICAgICAgICBNQVNLOiAnYmlnaW50JyxcbiAgICAgICAgQllURVM6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgQklUUzogJ2lzU2FmZUludGVnZXInLFxuICAgIH07XG4gICAgY29uc3Qgb3B0cyA9IEZJRUxEX0ZJRUxEUy5yZWR1Y2UoKG1hcCwgdmFsKSA9PiB7XG4gICAgICAgIG1hcFt2YWxdID0gJ2Z1bmN0aW9uJztcbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICB9LCBpbml0aWFsKTtcbiAgICByZXR1cm4gdmFsaWRhdGVPYmplY3QoZmllbGQsIG9wdHMpO1xufVxuLy8gR2VuZXJpYyBmaWVsZCBmdW5jdGlvbnNcbi8qKlxuICogU2FtZSBhcyBgcG93YCBidXQgZm9yIEZwOiBub24tY29uc3RhbnQtdGltZS5cbiAqIFVuc2FmZSBpbiBzb21lIGNvbnRleHRzOiB1c2VzIGxhZGRlciwgc28gY2FuIGV4cG9zZSBiaWdpbnQgYml0cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEZwUG93KGYsIG51bSwgcG93ZXIpIHtcbiAgICAvLyBTaG91bGQgaGF2ZSBzYW1lIHNwZWVkIGFzIHBvdyBmb3IgYmlnaW50c1xuICAgIC8vIFRPRE86IGJlbmNobWFyayFcbiAgICBpZiAocG93ZXIgPCBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcG93ZXIgPiAwJyk7XG4gICAgaWYgKHBvd2VyID09PSBfMG4pXG4gICAgICAgIHJldHVybiBmLk9ORTtcbiAgICBpZiAocG93ZXIgPT09IF8xbilcbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICBsZXQgcCA9IGYuT05FO1xuICAgIGxldCBkID0gbnVtO1xuICAgIHdoaWxlIChwb3dlciA+IF8wbikge1xuICAgICAgICBpZiAocG93ZXIgJiBfMW4pXG4gICAgICAgICAgICBwID0gZi5tdWwocCwgZCk7XG4gICAgICAgIGQgPSBmLnNxcihkKTtcbiAgICAgICAgcG93ZXIgPj49IF8xbjtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG59XG4vKipcbiAqIEVmZmljaWVudGx5IGludmVydCBhbiBhcnJheSBvZiBGaWVsZCBlbGVtZW50cy5cbiAqIGBpbnYoMClgIHdpbGwgcmV0dXJuIGB1bmRlZmluZWRgIGhlcmU6IG1ha2Ugc3VyZSB0byB0aHJvdyBhbiBlcnJvci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEZwSW52ZXJ0QmF0Y2goZiwgbnVtcykge1xuICAgIGNvbnN0IHRtcCA9IG5ldyBBcnJheShudW1zLmxlbmd0aCk7XG4gICAgLy8gV2FsayBmcm9tIGZpcnN0IHRvIGxhc3QsIG11bHRpcGx5IHRoZW0gYnkgZWFjaCBvdGhlciBNT0QgcFxuICAgIGNvbnN0IGxhc3RNdWx0aXBsaWVkID0gbnVtcy5yZWR1Y2UoKGFjYywgbnVtLCBpKSA9PiB7XG4gICAgICAgIGlmIChmLmlzMChudW0pKVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgdG1wW2ldID0gYWNjO1xuICAgICAgICByZXR1cm4gZi5tdWwoYWNjLCBudW0pO1xuICAgIH0sIGYuT05FKTtcbiAgICAvLyBJbnZlcnQgbGFzdCBlbGVtZW50XG4gICAgY29uc3QgaW52ZXJ0ZWQgPSBmLmludihsYXN0TXVsdGlwbGllZCk7XG4gICAgLy8gV2FsayBmcm9tIGxhc3QgdG8gZmlyc3QsIG11bHRpcGx5IHRoZW0gYnkgaW52ZXJ0ZWQgZWFjaCBvdGhlciBNT0QgcFxuICAgIG51bXMucmVkdWNlUmlnaHQoKGFjYywgbnVtLCBpKSA9PiB7XG4gICAgICAgIGlmIChmLmlzMChudW0pKVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgdG1wW2ldID0gZi5tdWwoYWNjLCB0bXBbaV0pO1xuICAgICAgICByZXR1cm4gZi5tdWwoYWNjLCBudW0pO1xuICAgIH0sIGludmVydGVkKTtcbiAgICByZXR1cm4gdG1wO1xufVxuZXhwb3J0IGZ1bmN0aW9uIEZwRGl2KGYsIGxocywgcmhzKSB7XG4gICAgcmV0dXJuIGYubXVsKGxocywgdHlwZW9mIHJocyA9PT0gJ2JpZ2ludCcgPyBpbnZlcnQocmhzLCBmLk9SREVSKSA6IGYuaW52KHJocykpO1xufVxuLy8gVGhpcyBmdW5jdGlvbiByZXR1cm5zIFRydWUgd2hlbmV2ZXIgdGhlIHZhbHVlIHggaXMgYSBzcXVhcmUgaW4gdGhlIGZpZWxkIEYuXG5leHBvcnQgZnVuY3Rpb24gRnBJc1NxdWFyZShmKSB7XG4gICAgY29uc3QgbGVnZW5kcmVDb25zdCA9IChmLk9SREVSIC0gXzFuKSAvIF8ybjsgLy8gSW50ZWdlciBhcml0aG1ldGljXG4gICAgcmV0dXJuICh4KSA9PiB7XG4gICAgICAgIGNvbnN0IHAgPSBmLnBvdyh4LCBsZWdlbmRyZUNvbnN0KTtcbiAgICAgICAgcmV0dXJuIGYuZXFsKHAsIGYuWkVSTykgfHwgZi5lcWwocCwgZi5PTkUpO1xuICAgIH07XG59XG4vLyBDVVJWRS5uIGxlbmd0aHNcbmV4cG9ydCBmdW5jdGlvbiBuTGVuZ3RoKG4sIG5CaXRMZW5ndGgpIHtcbiAgICAvLyBCaXQgc2l6ZSwgYnl0ZSBzaXplIG9mIENVUlZFLm5cbiAgICBjb25zdCBfbkJpdExlbmd0aCA9IG5CaXRMZW5ndGggIT09IHVuZGVmaW5lZCA/IG5CaXRMZW5ndGggOiBuLnRvU3RyaW5nKDIpLmxlbmd0aDtcbiAgICBjb25zdCBuQnl0ZUxlbmd0aCA9IE1hdGguY2VpbChfbkJpdExlbmd0aCAvIDgpO1xuICAgIHJldHVybiB7IG5CaXRMZW5ndGg6IF9uQml0TGVuZ3RoLCBuQnl0ZUxlbmd0aCB9O1xufVxuLyoqXG4gKiBJbml0aWFsaXplcyBhIGZpbml0ZSBmaWVsZCBvdmVyIHByaW1lLiAqKk5vbi1wcmltZXMgYXJlIG5vdCBzdXBwb3J0ZWQuKipcbiAqIERvIG5vdCBpbml0IGluIGxvb3A6IHNsb3cuIFZlcnkgZnJhZ2lsZTogYWx3YXlzIHJ1biBhIGJlbmNobWFyayBvbiBhIGNoYW5nZS5cbiAqIE1ham9yIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbnM6XG4gKiAqIGEpIGRlbm9ybWFsaXplZCBvcGVyYXRpb25zIGxpa2UgbXVsTiBpbnN0ZWFkIG9mIG11bFxuICogKiBiKSBzYW1lIG9iamVjdCBzaGFwZTogbmV2ZXIgYWRkIG9yIHJlbW92ZSBrZXlzXG4gKiAqIGMpIE9iamVjdC5mcmVlemVcbiAqIEBwYXJhbSBPUkRFUiBwcmltZSBwb3NpdGl2ZSBiaWdpbnRcbiAqIEBwYXJhbSBiaXRMZW4gaG93IG1hbnkgYml0cyB0aGUgZmllbGQgY29uc3VtZXNcbiAqIEBwYXJhbSBpc0xFIChkZWY6IGZhbHNlKSBpZiBlbmNvZGluZyAvIGRlY29kaW5nIHNob3VsZCBiZSBpbiBsaXR0bGUtZW5kaWFuXG4gKiBAcGFyYW0gcmVkZWYgb3B0aW9uYWwgZmFzdGVyIHJlZGVmaW5pdGlvbnMgb2Ygc3FydCBhbmQgb3RoZXIgbWV0aG9kc1xuICovXG5leHBvcnQgZnVuY3Rpb24gRmllbGQoT1JERVIsIGJpdExlbiwgaXNMRSA9IGZhbHNlLCByZWRlZiA9IHt9KSB7XG4gICAgaWYgKE9SREVSIDw9IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBGaWVsZCBPUkRFUiA+IDAsIGdvdCAke09SREVSfWApO1xuICAgIGNvbnN0IHsgbkJpdExlbmd0aDogQklUUywgbkJ5dGVMZW5ndGg6IEJZVEVTIH0gPSBuTGVuZ3RoKE9SREVSLCBiaXRMZW4pO1xuICAgIGlmIChCWVRFUyA+IDIwNDgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmllbGQgbGVuZ3RocyBvdmVyIDIwNDggYnl0ZXMgYXJlIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICBjb25zdCBzcXJ0UCA9IEZwU3FydChPUkRFUik7XG4gICAgY29uc3QgZiA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBPUkRFUixcbiAgICAgICAgQklUUyxcbiAgICAgICAgQllURVMsXG4gICAgICAgIE1BU0s6IGJpdE1hc2soQklUUyksXG4gICAgICAgIFpFUk86IF8wbixcbiAgICAgICAgT05FOiBfMW4sXG4gICAgICAgIGNyZWF0ZTogKG51bSkgPT4gbW9kKG51bSwgT1JERVIpLFxuICAgICAgICBpc1ZhbGlkOiAobnVtKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG51bSAhPT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGZpZWxkIGVsZW1lbnQ6IGV4cGVjdGVkIGJpZ2ludCwgZ290ICR7dHlwZW9mIG51bX1gKTtcbiAgICAgICAgICAgIHJldHVybiBfMG4gPD0gbnVtICYmIG51bSA8IE9SREVSOyAvLyAwIGlzIHZhbGlkIGVsZW1lbnQsIGJ1dCBpdCdzIG5vdCBpbnZlcnRpYmxlXG4gICAgICAgIH0sXG4gICAgICAgIGlzMDogKG51bSkgPT4gbnVtID09PSBfMG4sXG4gICAgICAgIGlzT2RkOiAobnVtKSA9PiAobnVtICYgXzFuKSA9PT0gXzFuLFxuICAgICAgICBuZWc6IChudW0pID0+IG1vZCgtbnVtLCBPUkRFUiksXG4gICAgICAgIGVxbDogKGxocywgcmhzKSA9PiBsaHMgPT09IHJocyxcbiAgICAgICAgc3FyOiAobnVtKSA9PiBtb2QobnVtICogbnVtLCBPUkRFUiksXG4gICAgICAgIGFkZDogKGxocywgcmhzKSA9PiBtb2QobGhzICsgcmhzLCBPUkRFUiksXG4gICAgICAgIHN1YjogKGxocywgcmhzKSA9PiBtb2QobGhzIC0gcmhzLCBPUkRFUiksXG4gICAgICAgIG11bDogKGxocywgcmhzKSA9PiBtb2QobGhzICogcmhzLCBPUkRFUiksXG4gICAgICAgIHBvdzogKG51bSwgcG93ZXIpID0+IEZwUG93KGYsIG51bSwgcG93ZXIpLFxuICAgICAgICBkaXY6IChsaHMsIHJocykgPT4gbW9kKGxocyAqIGludmVydChyaHMsIE9SREVSKSwgT1JERVIpLFxuICAgICAgICAvLyBTYW1lIGFzIGFib3ZlLCBidXQgZG9lc24ndCBub3JtYWxpemVcbiAgICAgICAgc3FyTjogKG51bSkgPT4gbnVtICogbnVtLFxuICAgICAgICBhZGROOiAobGhzLCByaHMpID0+IGxocyArIHJocyxcbiAgICAgICAgc3ViTjogKGxocywgcmhzKSA9PiBsaHMgLSByaHMsXG4gICAgICAgIG11bE46IChsaHMsIHJocykgPT4gbGhzICogcmhzLFxuICAgICAgICBpbnY6IChudW0pID0+IGludmVydChudW0sIE9SREVSKSxcbiAgICAgICAgc3FydDogcmVkZWYuc3FydCB8fCAoKG4pID0+IHNxcnRQKGYsIG4pKSxcbiAgICAgICAgaW52ZXJ0QmF0Y2g6IChsc3QpID0+IEZwSW52ZXJ0QmF0Y2goZiwgbHN0KSxcbiAgICAgICAgLy8gVE9ETzogZG8gd2UgcmVhbGx5IG5lZWQgY29uc3RhbnQgY21vdj9cbiAgICAgICAgLy8gV2UgZG9uJ3QgaGF2ZSBjb25zdC10aW1lIGJpZ2ludHMgYW55d2F5LCBzbyBwcm9iYWJseSB3aWxsIGJlIG5vdCB2ZXJ5IHVzZWZ1bFxuICAgICAgICBjbW92OiAoYSwgYiwgYykgPT4gKGMgPyBiIDogYSksXG4gICAgICAgIHRvQnl0ZXM6IChudW0pID0+IChpc0xFID8gbnVtYmVyVG9CeXRlc0xFKG51bSwgQllURVMpIDogbnVtYmVyVG9CeXRlc0JFKG51bSwgQllURVMpKSxcbiAgICAgICAgZnJvbUJ5dGVzOiAoYnl0ZXMpID0+IHtcbiAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggIT09IEJZVEVTKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRnAuZnJvbUJ5dGVzOiBleHBlY3RlZCAke0JZVEVTfSwgZ290ICR7Ynl0ZXMubGVuZ3RofWApO1xuICAgICAgICAgICAgcmV0dXJuIGlzTEUgPyBieXRlc1RvTnVtYmVyTEUoYnl0ZXMpIDogYnl0ZXNUb051bWJlckJFKGJ5dGVzKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShmKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBGcFNxcnRPZGQoRnAsIGVsbSkge1xuICAgIGlmICghRnAuaXNPZGQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmllbGQgZG9lc24ndCBoYXZlIGlzT2RkYCk7XG4gICAgY29uc3Qgcm9vdCA9IEZwLnNxcnQoZWxtKTtcbiAgICByZXR1cm4gRnAuaXNPZGQocm9vdCkgPyByb290IDogRnAubmVnKHJvb3QpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIEZwU3FydEV2ZW4oRnAsIGVsbSkge1xuICAgIGlmICghRnAuaXNPZGQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmllbGQgZG9lc24ndCBoYXZlIGlzT2RkYCk7XG4gICAgY29uc3Qgcm9vdCA9IEZwLnNxcnQoZWxtKTtcbiAgICByZXR1cm4gRnAuaXNPZGQocm9vdCkgPyBGcC5uZWcocm9vdCkgOiByb290O1xufVxuLyoqXG4gKiBcIkNvbnN0YW50LXRpbWVcIiBwcml2YXRlIGtleSBnZW5lcmF0aW9uIHV0aWxpdHkuXG4gKiBTYW1lIGFzIG1hcEtleVRvRmllbGQsIGJ1dCBhY2NlcHRzIGxlc3MgYnl0ZXMgKDQwIGluc3RlYWQgb2YgNDggZm9yIDMyLWJ5dGUgZmllbGQpLlxuICogV2hpY2ggbWFrZXMgaXQgc2xpZ2h0bHkgbW9yZSBiaWFzZWQsIGxlc3Mgc2VjdXJlLlxuICogQGRlcHJlY2F0ZWQgdXNlIG1hcEtleVRvRmllbGQgaW5zdGVhZFxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzaFRvUHJpdmF0ZVNjYWxhcihoYXNoLCBncm91cE9yZGVyLCBpc0xFID0gZmFsc2UpIHtcbiAgICBoYXNoID0gZW5zdXJlQnl0ZXMoJ3ByaXZhdGVIYXNoJywgaGFzaCk7XG4gICAgY29uc3QgaGFzaExlbiA9IGhhc2gubGVuZ3RoO1xuICAgIGNvbnN0IG1pbkxlbiA9IG5MZW5ndGgoZ3JvdXBPcmRlcikubkJ5dGVMZW5ndGggKyA4O1xuICAgIGlmIChtaW5MZW4gPCAyNCB8fCBoYXNoTGVuIDwgbWluTGVuIHx8IGhhc2hMZW4gPiAxMDI0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGhhc2hUb1ByaXZhdGVTY2FsYXI6IGV4cGVjdGVkICR7bWluTGVufS0xMDI0IGJ5dGVzIG9mIGlucHV0LCBnb3QgJHtoYXNoTGVufWApO1xuICAgIGNvbnN0IG51bSA9IGlzTEUgPyBieXRlc1RvTnVtYmVyTEUoaGFzaCkgOiBieXRlc1RvTnVtYmVyQkUoaGFzaCk7XG4gICAgcmV0dXJuIG1vZChudW0sIGdyb3VwT3JkZXIgLSBfMW4pICsgXzFuO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRvdGFsIG51bWJlciBvZiBieXRlcyBjb25zdW1lZCBieSB0aGUgZmllbGQgZWxlbWVudC5cbiAqIEZvciBleGFtcGxlLCAzMiBieXRlcyBmb3IgdXN1YWwgMjU2LWJpdCB3ZWllcnN0cmFzcyBjdXJ2ZS5cbiAqIEBwYXJhbSBmaWVsZE9yZGVyIG51bWJlciBvZiBmaWVsZCBlbGVtZW50cywgdXN1YWxseSBDVVJWRS5uXG4gKiBAcmV0dXJucyBieXRlIGxlbmd0aCBvZiBmaWVsZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmllbGRCeXRlc0xlbmd0aChmaWVsZE9yZGVyKSB7XG4gICAgaWYgKHR5cGVvZiBmaWVsZE9yZGVyICE9PSAnYmlnaW50JylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaWVsZCBvcmRlciBtdXN0IGJlIGJpZ2ludCcpO1xuICAgIGNvbnN0IGJpdExlbmd0aCA9IGZpZWxkT3JkZXIudG9TdHJpbmcoMikubGVuZ3RoO1xuICAgIHJldHVybiBNYXRoLmNlaWwoYml0TGVuZ3RoIC8gOCk7XG59XG4vKipcbiAqIFJldHVybnMgbWluaW1hbCBhbW91bnQgb2YgYnl0ZXMgdGhhdCBjYW4gYmUgc2FmZWx5IHJlZHVjZWRcbiAqIGJ5IGZpZWxkIG9yZGVyLlxuICogU2hvdWxkIGJlIDJeLTEyOCBmb3IgMTI4LWJpdCBjdXJ2ZSBzdWNoIGFzIFAyNTYuXG4gKiBAcGFyYW0gZmllbGRPcmRlciBudW1iZXIgb2YgZmllbGQgZWxlbWVudHMsIHVzdWFsbHkgQ1VSVkUublxuICogQHJldHVybnMgYnl0ZSBsZW5ndGggb2YgdGFyZ2V0IGhhc2hcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE1pbkhhc2hMZW5ndGgoZmllbGRPcmRlcikge1xuICAgIGNvbnN0IGxlbmd0aCA9IGdldEZpZWxkQnl0ZXNMZW5ndGgoZmllbGRPcmRlcik7XG4gICAgcmV0dXJuIGxlbmd0aCArIE1hdGguY2VpbChsZW5ndGggLyAyKTtcbn1cbi8qKlxuICogXCJDb25zdGFudC10aW1lXCIgcHJpdmF0ZSBrZXkgZ2VuZXJhdGlvbiB1dGlsaXR5LlxuICogQ2FuIHRha2UgKG4gKyBuLzIpIG9yIG1vcmUgYnl0ZXMgb2YgdW5pZm9ybSBpbnB1dCBlLmcuIGZyb20gQ1NQUk5HIG9yIEtERlxuICogYW5kIGNvbnZlcnQgdGhlbSBpbnRvIHByaXZhdGUgc2NhbGFyLCB3aXRoIHRoZSBtb2R1bG8gYmlhcyBiZWluZyBuZWdsaWdpYmxlLlxuICogTmVlZHMgYXQgbGVhc3QgNDggYnl0ZXMgb2YgaW5wdXQgZm9yIDMyLWJ5dGUgcHJpdmF0ZSBrZXkuXG4gKiBodHRwczovL3Jlc2VhcmNoLmt1ZGVsc2tpc2VjdXJpdHkuY29tLzIwMjAvMDcvMjgvdGhlLWRlZmluaXRpdmUtZ3VpZGUtdG8tbW9kdWxvLWJpYXMtYW5kLWhvdy10by1hdm9pZC1pdC9cbiAqIEZJUFMgMTg2LTUsIEEuMiBodHRwczovL2NzcmMubmlzdC5nb3YvcHVibGljYXRpb25zL2RldGFpbC9maXBzLzE4Ni81L2ZpbmFsXG4gKiBSRkMgOTM4MCwgaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01XG4gKiBAcGFyYW0gaGFzaCBoYXNoIG91dHB1dCBmcm9tIFNIQTMgb3IgYSBzaW1pbGFyIGZ1bmN0aW9uXG4gKiBAcGFyYW0gZ3JvdXBPcmRlciBzaXplIG9mIHN1Ymdyb3VwIC0gKGUuZy4gc2VjcDI1NmsxLkNVUlZFLm4pXG4gKiBAcGFyYW0gaXNMRSBpbnRlcnByZXQgaGFzaCBieXRlcyBhcyBMRSBudW1cbiAqIEByZXR1cm5zIHZhbGlkIHByaXZhdGUgc2NhbGFyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBIYXNoVG9GaWVsZChrZXksIGZpZWxkT3JkZXIsIGlzTEUgPSBmYWxzZSkge1xuICAgIGNvbnN0IGxlbiA9IGtleS5sZW5ndGg7XG4gICAgY29uc3QgZmllbGRMZW4gPSBnZXRGaWVsZEJ5dGVzTGVuZ3RoKGZpZWxkT3JkZXIpO1xuICAgIGNvbnN0IG1pbkxlbiA9IGdldE1pbkhhc2hMZW5ndGgoZmllbGRPcmRlcik7XG4gICAgLy8gTm8gc21hbGwgbnVtYmVyczogbmVlZCB0byB1bmRlcnN0YW5kIGJpYXMgc3RvcnkuIE5vIGh1Z2UgbnVtYmVyczogZWFzaWVyIHRvIGRldGVjdCBKUyB0aW1pbmdzLlxuICAgIGlmIChsZW4gPCAxNiB8fCBsZW4gPCBtaW5MZW4gfHwgbGVuID4gMTAyNClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCAke21pbkxlbn0tMTAyNCBieXRlcyBvZiBpbnB1dCwgZ290ICR7bGVufWApO1xuICAgIGNvbnN0IG51bSA9IGlzTEUgPyBieXRlc1RvTnVtYmVyQkUoa2V5KSA6IGJ5dGVzVG9OdW1iZXJMRShrZXkpO1xuICAgIC8vIGBtb2QoeCwgMTEpYCBjYW4gc29tZXRpbWVzIHByb2R1Y2UgMC4gYG1vZCh4LCAxMCkgKyAxYCBpcyB0aGUgc2FtZSwgYnV0IG5vIDBcbiAgICBjb25zdCByZWR1Y2VkID0gbW9kKG51bSwgZmllbGRPcmRlciAtIF8xbikgKyBfMW47XG4gICAgcmV0dXJuIGlzTEUgPyBudW1iZXJUb0J5dGVzTEUocmVkdWNlZCwgZmllbGRMZW4pIDogbnVtYmVyVG9CeXRlc0JFKHJlZHVjZWQsIGZpZWxkTGVuKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsYXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/modular.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/utils.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/utils.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bitGet: () => (/* binding */ bitGet),\n/* harmony export */   bitLen: () => (/* binding */ bitLen),\n/* harmony export */   bitMask: () => (/* binding */ bitMask),\n/* harmony export */   bitSet: () => (/* binding */ bitSet),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   bytesToNumberBE: () => (/* binding */ bytesToNumberBE),\n/* harmony export */   bytesToNumberLE: () => (/* binding */ bytesToNumberLE),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createHmacDrbg: () => (/* binding */ createHmacDrbg),\n/* harmony export */   ensureBytes: () => (/* binding */ ensureBytes),\n/* harmony export */   equalBytes: () => (/* binding */ equalBytes),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   hexToNumber: () => (/* binding */ hexToNumber),\n/* harmony export */   numberToBytesBE: () => (/* binding */ numberToBytesBE),\n/* harmony export */   numberToBytesLE: () => (/* binding */ numberToBytesLE),\n/* harmony export */   numberToHexUnpadded: () => (/* binding */ numberToHexUnpadded),\n/* harmony export */   numberToVarBytesBE: () => (/* binding */ numberToVarBytesBE),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   validateObject: () => (/* binding */ validateObject)\n/* harmony export */ });\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst u8a = (a) => a instanceof Uint8Array;\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    if (!u8a(bytes))\n        throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // Big Endian\n    return BigInt(hex === '' ? '0' : `0x${hex}`);\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const len = hex.length;\n    if (len % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n    const array = new Uint8Array(len / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction bytesToNumberLE(bytes) {\n    if (!u8a(bytes))\n        throw new Error('Uint8Array expected');\n    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nfunction numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nfunction numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nfunction numberToVarBytesBE(n) {\n    return hexToBytes(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nfunction ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === 'string') {\n        try {\n            res = hexToBytes(hex);\n        }\n        catch (e) {\n            throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`);\n        }\n    }\n    else if (u8a(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    }\n    else {\n        throw new Error(`${title} must be hex string or Uint8Array`);\n    }\n    const len = res.length;\n    if (typeof expectedLength === 'number' && len !== expectedLength)\n        throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);\n    return res;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n    let pad = 0; // walk through each item, ensure they have proper type\n    arrays.forEach((a) => {\n        if (!u8a(a))\n            throw new Error('Uint8Array expected');\n        r.set(a, pad);\n        pad += a.length;\n    });\n    return r;\n}\nfunction equalBytes(b1, b2) {\n    // We don't care about timing attacks here\n    if (b1.length !== b2.length)\n        return false;\n    for (let i = 0; i < b1.length; i++)\n        if (b1[i] !== b2[i])\n            return false;\n    return true;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */\nfunction bitLen(n) {\n    let len;\n    for (len = 0; n > _0n; n >>= _1n, len += 1)\n        ;\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nfunction bitGet(n, pos) {\n    return (n >> BigInt(pos)) & _1n;\n}\n/**\n * Sets single bit at position.\n */\nconst bitSet = (n, pos, value) => {\n    return n | ((value ? _1n : _0n) << BigInt(pos));\n};\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nconst bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;\n// DRBG\nconst u8n = (data) => new Uint8Array(data); // creates Uint8Array\nconst u8fr = (arr) => Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nfunction createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== 'number' || hashLen < 2)\n        throw new Error('hashLen must be a number');\n    if (typeof qByteLen !== 'number' || qByteLen < 2)\n        throw new Error('qByteLen must be a number');\n    if (typeof hmacFn !== 'function')\n        throw new Error('hmacFn must be a function');\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = () => {\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n()) => {\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0)\n            return;\n        k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = () => {\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000)\n            throw new Error('drbg: tried 1000 values');\n        let len = 0;\n        const out = [];\n        while (len < qByteLen) {\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes(...out);\n    };\n    const genUntil = (seed, pred) => {\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while (!(res = pred(gen())))\n            reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val) => typeof val === 'bigint',\n    function: (val) => typeof val === 'function',\n    boolean: (val) => typeof val === 'boolean',\n    string: (val) => typeof val === 'string',\n    stringOrUint8Array: (val) => typeof val === 'string' || val instanceof Uint8Array,\n    isSafeInteger: (val) => Number.isSafeInteger(val),\n    array: (val) => Array.isArray(val),\n    field: (val, object) => object.Fp.isValid(val),\n    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nfunction validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional) => {\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== 'function')\n            throw new Error(`Invalid validator \"${type}\", expected function`);\n        const val = object[fieldName];\n        if (isOptional && val === undefined)\n            return;\n        if (!checkVal(val, object)) {\n            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))\n        checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))\n        checkField(fieldName, type, true);\n    return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxhQUFhO0FBQ3hEO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsSUFBSTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE9BQU8saUNBQWlDLElBQUksWUFBWSxFQUFFO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTyxXQUFXLGdCQUFnQixhQUFhLElBQUk7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSw0REFBNEQsV0FBVztBQUN2RSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDRCQUE0QjtBQUNuRDtBQUNPO0FBQ1A7QUFDQSw0Q0FBNEM7QUFDNUMsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUNuRCw4REFBOEQ7QUFDckU7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELEtBQUs7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsa0JBQWtCLEdBQUcsS0FBSyxHQUFHLFdBQVcsY0FBYyxLQUFLO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsV0FBVyxXQUFXLFlBQVksSUFBSTtBQUNwRCxrQ0FBa0Msb0JBQW9CLElBQUksYUFBYSxHQUFHO0FBQzFFO0FBQ0Esa0NBQWtDLFVBQVUsSUFBSSxTQUFTO0FBQ3pELGtDQUFrQyxvQkFBb0IsSUFBSSxTQUFTO0FBQ25FLGtDQUFrQywyQkFBMkI7QUFDN0Qsa0NBQWtDLHdCQUF3QjtBQUMxRCIsInNvdXJjZXMiOlsiL2hvbWUvbGZnL0dpdC9NYWR0cmlwcy9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvdXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gMTAwIGxpbmVzIG9mIGNvZGUgaW4gdGhlIGZpbGUgYXJlIGR1cGxpY2F0ZWQgZnJvbSBub2JsZS1oYXNoZXMgKHV0aWxzKS5cbi8vIFRoaXMgaXMgT0s6IGBhYnN0cmFjdGAgZGlyZWN0b3J5IGRvZXMgbm90IHVzZSBub2JsZS1oYXNoZXMuXG4vLyBVc2VyIG1heSBvcHQtaW4gaW50byB1c2luZyBkaWZmZXJlbnQgaGFzaGluZyBsaWJyYXJ5LiBUaGlzIHdheSwgbm9ibGUtaGFzaGVzXG4vLyB3b24ndCBiZSBpbmNsdWRlZCBpbnRvIHRoZWlyIGJ1bmRsZS5cbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbmNvbnN0IF8ybiA9IEJpZ0ludCgyKTtcbmNvbnN0IHU4YSA9IChhKSA9PiBhIGluc3RhbmNlb2YgVWludDhBcnJheTtcbmNvbnN0IGhleGVzID0gLyogQF9fUFVSRV9fICovIEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoXywgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG4vKipcbiAqIEBleGFtcGxlIGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSkpIC8vICdjYWZlMDEyMydcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9IZXgoYnl0ZXMpIHtcbiAgICBpZiAoIXU4YShieXRlcykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgIC8vIHByZS1jYWNoaW5nIGltcHJvdmVzIHRoZSBzcGVlZCA2eFxuICAgIGxldCBoZXggPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhleCArPSBoZXhlc1tieXRlc1tpXV07XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59XG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9IZXhVbnBhZGRlZChudW0pIHtcbiAgICBjb25zdCBoZXggPSBudW0udG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBoZXgubGVuZ3RoICYgMSA/IGAwJHtoZXh9YCA6IGhleDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb051bWJlcihoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICAvLyBCaWcgRW5kaWFuXG4gICAgcmV0dXJuIEJpZ0ludChoZXggPT09ICcnID8gJzAnIDogYDB4JHtoZXh9YCk7XG59XG4vKipcbiAqIEBleGFtcGxlIGhleFRvQnl0ZXMoJ2NhZmUwMTIzJykgLy8gVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgY29uc3QgbGVuID0gaGV4Lmxlbmd0aDtcbiAgICBpZiAobGVuICUgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkZWQgaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IHVucGFkZGVkIGhleCBvZiBsZW5ndGggJyArIGxlbik7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShsZW4gLyAyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGogPSBpICogMjtcbiAgICAgICAgY29uc3QgaGV4Qnl0ZSA9IGhleC5zbGljZShqLCBqICsgMik7XG4gICAgICAgIGNvbnN0IGJ5dGUgPSBOdW1iZXIucGFyc2VJbnQoaGV4Qnl0ZSwgMTYpO1xuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKGJ5dGUpIHx8IGJ5dGUgPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJ5dGUgc2VxdWVuY2UnKTtcbiAgICAgICAgYXJyYXlbaV0gPSBieXRlO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG4vLyBCRTogQmlnIEVuZGlhbiwgTEU6IExpdHRsZSBFbmRpYW5cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvTnVtYmVyQkUoYnl0ZXMpIHtcbiAgICByZXR1cm4gaGV4VG9OdW1iZXIoYnl0ZXNUb0hleChieXRlcykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9OdW1iZXJMRShieXRlcykge1xuICAgIGlmICghdThhKGJ5dGVzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgcmV0dXJuIGhleFRvTnVtYmVyKGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKGJ5dGVzKS5yZXZlcnNlKCkpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb0J5dGVzQkUobiwgbGVuKSB7XG4gICAgcmV0dXJuIGhleFRvQnl0ZXMobi50b1N0cmluZygxNikucGFkU3RhcnQobGVuICogMiwgJzAnKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9CeXRlc0xFKG4sIGxlbikge1xuICAgIHJldHVybiBudW1iZXJUb0J5dGVzQkUobiwgbGVuKS5yZXZlcnNlKCk7XG59XG4vLyBVbnBhZGRlZCwgcmFyZWx5IHVzZWRcbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb1ZhckJ5dGVzQkUobikge1xuICAgIHJldHVybiBoZXhUb0J5dGVzKG51bWJlclRvSGV4VW5wYWRkZWQobikpO1xufVxuLyoqXG4gKiBUYWtlcyBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXksIGNvbnZlcnRzIHRvIFVpbnQ4QXJyYXkuXG4gKiBWYWxpZGF0ZXMgb3V0cHV0IGxlbmd0aC5cbiAqIFdpbGwgdGhyb3cgZXJyb3IgZm9yIG90aGVyIHR5cGVzLlxuICogQHBhcmFtIHRpdGxlIGRlc2NyaXB0aXZlIHRpdGxlIGZvciBhbiBlcnJvciBlLmcuICdwcml2YXRlIGtleSdcbiAqIEBwYXJhbSBoZXggaGV4IHN0cmluZyBvciBVaW50OEFycmF5XG4gKiBAcGFyYW0gZXhwZWN0ZWRMZW5ndGggb3B0aW9uYWwsIHdpbGwgY29tcGFyZSB0byByZXN1bHQgYXJyYXkncyBsZW5ndGhcbiAqIEByZXR1cm5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVCeXRlcyh0aXRsZSwgaGV4LCBleHBlY3RlZExlbmd0aCkge1xuICAgIGxldCByZXM7XG4gICAgaWYgKHR5cGVvZiBoZXggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXMgPSBoZXhUb0J5dGVzKGhleCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aXRsZX0gbXVzdCBiZSB2YWxpZCBoZXggc3RyaW5nLCBnb3QgXCIke2hleH1cIi4gQ2F1c2U6ICR7ZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh1OGEoaGV4KSkge1xuICAgICAgICAvLyBVaW50OEFycmF5LmZyb20oKSBpbnN0ZWFkIG9mIGhhc2guc2xpY2UoKSBiZWNhdXNlIG5vZGUuanMgQnVmZmVyXG4gICAgICAgIC8vIGlzIGluc3RhbmNlIG9mIFVpbnQ4QXJyYXksIGFuZCBpdHMgc2xpY2UoKSBjcmVhdGVzICoqbXV0YWJsZSoqIGNvcHlcbiAgICAgICAgcmVzID0gVWludDhBcnJheS5mcm9tKGhleCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGl0bGV9IG11c3QgYmUgaGV4IHN0cmluZyBvciBVaW50OEFycmF5YCk7XG4gICAgfVxuICAgIGNvbnN0IGxlbiA9IHJlcy5sZW5ndGg7XG4gICAgaWYgKHR5cGVvZiBleHBlY3RlZExlbmd0aCA9PT0gJ251bWJlcicgJiYgbGVuICE9PSBleHBlY3RlZExlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RpdGxlfSBleHBlY3RlZCAke2V4cGVjdGVkTGVuZ3RofSBieXRlcywgZ290ICR7bGVufWApO1xuICAgIHJldHVybiByZXM7XG59XG4vKipcbiAqIENvcGllcyBzZXZlcmFsIFVpbnQ4QXJyYXlzIGludG8gb25lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0Qnl0ZXMoLi4uYXJyYXlzKSB7XG4gICAgY29uc3QgciA9IG5ldyBVaW50OEFycmF5KGFycmF5cy5yZWR1Y2UoKHN1bSwgYSkgPT4gc3VtICsgYS5sZW5ndGgsIDApKTtcbiAgICBsZXQgcGFkID0gMDsgLy8gd2FsayB0aHJvdWdoIGVhY2ggaXRlbSwgZW5zdXJlIHRoZXkgaGF2ZSBwcm9wZXIgdHlwZVxuICAgIGFycmF5cy5mb3JFYWNoKChhKSA9PiB7XG4gICAgICAgIGlmICghdThhKGEpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgICAgIHIuc2V0KGEsIHBhZCk7XG4gICAgICAgIHBhZCArPSBhLmxlbmd0aDtcbiAgICB9KTtcbiAgICByZXR1cm4gcjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbEJ5dGVzKGIxLCBiMikge1xuICAgIC8vIFdlIGRvbid0IGNhcmUgYWJvdXQgdGltaW5nIGF0dGFja3MgaGVyZVxuICAgIGlmIChiMS5sZW5ndGggIT09IGIyLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYjEubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmIChiMVtpXSAhPT0gYjJbaV0pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIEBleGFtcGxlIHV0ZjhUb0J5dGVzKCdhYmMnKSAvLyBuZXcgVWludDhBcnJheShbOTcsIDk4LCA5OV0pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdXRmOFRvQnl0ZXMgZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygc3RyfWApO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSk7IC8vIGh0dHBzOi8vYnVnemlsLmxhLzE2ODE4MDlcbn1cbi8vIEJpdCBvcGVyYXRpb25zXG4vKipcbiAqIENhbGN1bGF0ZXMgYW1vdW50IG9mIGJpdHMgaW4gYSBiaWdpbnQuXG4gKiBTYW1lIGFzIGBuLnRvU3RyaW5nKDIpLmxlbmd0aGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpdExlbihuKSB7XG4gICAgbGV0IGxlbjtcbiAgICBmb3IgKGxlbiA9IDA7IG4gPiBfMG47IG4gPj49IF8xbiwgbGVuICs9IDEpXG4gICAgICAgIDtcbiAgICByZXR1cm4gbGVuO1xufVxuLyoqXG4gKiBHZXRzIHNpbmdsZSBiaXQgYXQgcG9zaXRpb24uXG4gKiBOT1RFOiBmaXJzdCBiaXQgcG9zaXRpb24gaXMgMCAoc2FtZSBhcyBhcnJheXMpXG4gKiBTYW1lIGFzIGAhIStBcnJheS5mcm9tKG4udG9TdHJpbmcoMikpLnJldmVyc2UoKVtwb3NdYFxuICovXG5leHBvcnQgZnVuY3Rpb24gYml0R2V0KG4sIHBvcykge1xuICAgIHJldHVybiAobiA+PiBCaWdJbnQocG9zKSkgJiBfMW47XG59XG4vKipcbiAqIFNldHMgc2luZ2xlIGJpdCBhdCBwb3NpdGlvbi5cbiAqL1xuZXhwb3J0IGNvbnN0IGJpdFNldCA9IChuLCBwb3MsIHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIG4gfCAoKHZhbHVlID8gXzFuIDogXzBuKSA8PCBCaWdJbnQocG9zKSk7XG59O1xuLyoqXG4gKiBDYWxjdWxhdGUgbWFzayBmb3IgTiBiaXRzLiBOb3QgdXNpbmcgKiogb3BlcmF0b3Igd2l0aCBiaWdpbnRzIGJlY2F1c2Ugb2Ygb2xkIGVuZ2luZXMuXG4gKiBTYW1lIGFzIEJpZ0ludChgMGIke0FycmF5KGkpLmZpbGwoJzEnKS5qb2luKCcnKX1gKVxuICovXG5leHBvcnQgY29uc3QgYml0TWFzayA9IChuKSA9PiAoXzJuIDw8IEJpZ0ludChuIC0gMSkpIC0gXzFuO1xuLy8gRFJCR1xuY29uc3QgdThuID0gKGRhdGEpID0+IG5ldyBVaW50OEFycmF5KGRhdGEpOyAvLyBjcmVhdGVzIFVpbnQ4QXJyYXlcbmNvbnN0IHU4ZnIgPSAoYXJyKSA9PiBVaW50OEFycmF5LmZyb20oYXJyKTsgLy8gYW5vdGhlciBzaG9ydGN1dFxuLyoqXG4gKiBNaW5pbWFsIEhNQUMtRFJCRyBmcm9tIE5JU1QgODAwLTkwIGZvciBSRkM2OTc5IHNpZ3MuXG4gKiBAcmV0dXJucyBmdW5jdGlvbiB0aGF0IHdpbGwgY2FsbCBEUkJHIHVudGlsIDJuZCBhcmcgcmV0dXJucyBzb21ldGhpbmcgbWVhbmluZ2Z1bFxuICogQGV4YW1wbGVcbiAqICAgY29uc3QgZHJiZyA9IGNyZWF0ZUhtYWNEUkJHPEtleT4oMzIsIDMyLCBobWFjKTtcbiAqICAgZHJiZyhzZWVkLCBieXRlc1RvS2V5KTsgLy8gYnl0ZXNUb0tleSBtdXN0IHJldHVybiBLZXkgb3IgdW5kZWZpbmVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVIbWFjRHJiZyhoYXNoTGVuLCBxQnl0ZUxlbiwgaG1hY0ZuKSB7XG4gICAgaWYgKHR5cGVvZiBoYXNoTGVuICE9PSAnbnVtYmVyJyB8fCBoYXNoTGVuIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoYXNoTGVuIG11c3QgYmUgYSBudW1iZXInKTtcbiAgICBpZiAodHlwZW9mIHFCeXRlTGVuICE9PSAnbnVtYmVyJyB8fCBxQnl0ZUxlbiA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncUJ5dGVMZW4gbXVzdCBiZSBhIG51bWJlcicpO1xuICAgIGlmICh0eXBlb2YgaG1hY0ZuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2htYWNGbiBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAvLyBTdGVwIEIsIFN0ZXAgQzogc2V0IGhhc2hMZW4gdG8gOCpjZWlsKGhsZW4vOClcbiAgICBsZXQgdiA9IHU4bihoYXNoTGVuKTsgLy8gTWluaW1hbCBub24tZnVsbC1zcGVjIEhNQUMtRFJCRyBmcm9tIE5JU1QgODAwLTkwIGZvciBSRkM2OTc5IHNpZ3MuXG4gICAgbGV0IGsgPSB1OG4oaGFzaExlbik7IC8vIFN0ZXBzIEIgYW5kIEMgb2YgUkZDNjk3OSAzLjI6IHNldCBoYXNoTGVuLCBpbiBvdXIgY2FzZSBhbHdheXMgc2FtZVxuICAgIGxldCBpID0gMDsgLy8gSXRlcmF0aW9ucyBjb3VudGVyLCB3aWxsIHRocm93IHdoZW4gb3ZlciAxMDAwXG4gICAgY29uc3QgcmVzZXQgPSAoKSA9PiB7XG4gICAgICAgIHYuZmlsbCgxKTtcbiAgICAgICAgay5maWxsKDApO1xuICAgICAgICBpID0gMDtcbiAgICB9O1xuICAgIGNvbnN0IGggPSAoLi4uYikgPT4gaG1hY0ZuKGssIHYsIC4uLmIpOyAvLyBobWFjKGspKHYsIC4uLnZhbHVlcylcbiAgICBjb25zdCByZXNlZWQgPSAoc2VlZCA9IHU4bigpKSA9PiB7XG4gICAgICAgIC8vIEhNQUMtRFJCRyByZXNlZWQoKSBmdW5jdGlvbi4gU3RlcHMgRC1HXG4gICAgICAgIGsgPSBoKHU4ZnIoWzB4MDBdKSwgc2VlZCk7IC8vIGsgPSBobWFjKGsgfHwgdiB8fCAweDAwIHx8IHNlZWQpXG4gICAgICAgIHYgPSBoKCk7IC8vIHYgPSBobWFjKGsgfHwgdilcbiAgICAgICAgaWYgKHNlZWQubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBrID0gaCh1OGZyKFsweDAxXSksIHNlZWQpOyAvLyBrID0gaG1hYyhrIHx8IHYgfHwgMHgwMSB8fCBzZWVkKVxuICAgICAgICB2ID0gaCgpOyAvLyB2ID0gaG1hYyhrIHx8IHYpXG4gICAgfTtcbiAgICBjb25zdCBnZW4gPSAoKSA9PiB7XG4gICAgICAgIC8vIEhNQUMtRFJCRyBnZW5lcmF0ZSgpIGZ1bmN0aW9uXG4gICAgICAgIGlmIChpKysgPj0gMTAwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZHJiZzogdHJpZWQgMTAwMCB2YWx1ZXMnKTtcbiAgICAgICAgbGV0IGxlbiA9IDA7XG4gICAgICAgIGNvbnN0IG91dCA9IFtdO1xuICAgICAgICB3aGlsZSAobGVuIDwgcUJ5dGVMZW4pIHtcbiAgICAgICAgICAgIHYgPSBoKCk7XG4gICAgICAgICAgICBjb25zdCBzbCA9IHYuc2xpY2UoKTtcbiAgICAgICAgICAgIG91dC5wdXNoKHNsKTtcbiAgICAgICAgICAgIGxlbiArPSB2Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uY2F0Qnl0ZXMoLi4ub3V0KTtcbiAgICB9O1xuICAgIGNvbnN0IGdlblVudGlsID0gKHNlZWQsIHByZWQpID0+IHtcbiAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgcmVzZWVkKHNlZWQpOyAvLyBTdGVwcyBELUdcbiAgICAgICAgbGV0IHJlcyA9IHVuZGVmaW5lZDsgLy8gU3RlcCBIOiBncmluZCB1bnRpbCBrIGlzIGluIFsxLi5uLTFdXG4gICAgICAgIHdoaWxlICghKHJlcyA9IHByZWQoZ2VuKCkpKSlcbiAgICAgICAgICAgIHJlc2VlZCgpO1xuICAgICAgICByZXNldCgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgcmV0dXJuIGdlblVudGlsO1xufVxuLy8gVmFsaWRhdGluZyBjdXJ2ZXMgYW5kIGZpZWxkc1xuY29uc3QgdmFsaWRhdG9yRm5zID0ge1xuICAgIGJpZ2ludDogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2JpZ2ludCcsXG4gICAgZnVuY3Rpb246ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicsXG4gICAgYm9vbGVhbjogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nLFxuICAgIHN0cmluZzogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycsXG4gICAgc3RyaW5nT3JVaW50OEFycmF5OiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyB8fCB2YWwgaW5zdGFuY2VvZiBVaW50OEFycmF5LFxuICAgIGlzU2FmZUludGVnZXI6ICh2YWwpID0+IE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbCksXG4gICAgYXJyYXk6ICh2YWwpID0+IEFycmF5LmlzQXJyYXkodmFsKSxcbiAgICBmaWVsZDogKHZhbCwgb2JqZWN0KSA9PiBvYmplY3QuRnAuaXNWYWxpZCh2YWwpLFxuICAgIGhhc2g6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicgJiYgTnVtYmVyLmlzU2FmZUludGVnZXIodmFsLm91dHB1dExlbiksXG59O1xuLy8gdHlwZSBSZWNvcmQ8SyBleHRlbmRzIHN0cmluZyB8IG51bWJlciB8IHN5bWJvbCwgVD4gPSB7IFtQIGluIEtdOiBUOyB9XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVPYmplY3Qob2JqZWN0LCB2YWxpZGF0b3JzLCBvcHRWYWxpZGF0b3JzID0ge30pIHtcbiAgICBjb25zdCBjaGVja0ZpZWxkID0gKGZpZWxkTmFtZSwgdHlwZSwgaXNPcHRpb25hbCkgPT4ge1xuICAgICAgICBjb25zdCBjaGVja1ZhbCA9IHZhbGlkYXRvckZuc1t0eXBlXTtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGVja1ZhbCAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB2YWxpZGF0b3IgXCIke3R5cGV9XCIsIGV4cGVjdGVkIGZ1bmN0aW9uYCk7XG4gICAgICAgIGNvbnN0IHZhbCA9IG9iamVjdFtmaWVsZE5hbWVdO1xuICAgICAgICBpZiAoaXNPcHRpb25hbCAmJiB2YWwgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCFjaGVja1ZhbCh2YWwsIG9iamVjdCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwYXJhbSAke1N0cmluZyhmaWVsZE5hbWUpfT0ke3ZhbH0gKCR7dHlwZW9mIHZhbH0pLCBleHBlY3RlZCAke3R5cGV9YCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZvciAoY29uc3QgW2ZpZWxkTmFtZSwgdHlwZV0gb2YgT2JqZWN0LmVudHJpZXModmFsaWRhdG9ycykpXG4gICAgICAgIGNoZWNrRmllbGQoZmllbGROYW1lLCB0eXBlLCBmYWxzZSk7XG4gICAgZm9yIChjb25zdCBbZmllbGROYW1lLCB0eXBlXSBvZiBPYmplY3QuZW50cmllcyhvcHRWYWxpZGF0b3JzKSlcbiAgICAgICAgY2hlY2tGaWVsZChmaWVsZE5hbWUsIHR5cGUsIHRydWUpO1xuICAgIHJldHVybiBvYmplY3Q7XG59XG4vLyB2YWxpZGF0ZSB0eXBlIHRlc3RzXG4vLyBjb25zdCBvOiB7IGE6IG51bWJlcjsgYjogbnVtYmVyOyBjOiBudW1iZXIgfSA9IHsgYTogMSwgYjogNSwgYzogNiB9O1xuLy8gY29uc3QgejAgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICdpc1NhZmVJbnRlZ2VyJyB9LCB7IGM6ICdiaWdpbnQnIH0pOyAvLyBPayFcbi8vIC8vIFNob3VsZCBmYWlsIHR5cGUtY2hlY2tcbi8vIGNvbnN0IHoxID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAndG1wJyB9LCB7IGM6ICd6eicgfSk7XG4vLyBjb25zdCB6MiA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ2lzU2FmZUludGVnZXInIH0sIHsgYzogJ3p6JyB9KTtcbi8vIGNvbnN0IHozID0gdmFsaWRhdGVPYmplY3QobywgeyB0ZXN0OiAnYm9vbGVhbicsIHo6ICdidWcnIH0pO1xuLy8gY29uc3QgejQgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICdib29sZWFuJywgejogJ2J1ZycgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/weierstrass.js":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/weierstrass.js ***!
  \*************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DER: () => (/* binding */ DER),\n/* harmony export */   SWUFpSqrtRatio: () => (/* binding */ SWUFpSqrtRatio),\n/* harmony export */   mapToCurveSimpleSWU: () => (/* binding */ mapToCurveSimpleSWU),\n/* harmony export */   weierstrass: () => (/* binding */ weierstrass),\n/* harmony export */   weierstrassPoints: () => (/* binding */ weierstrassPoints)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _curve_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curve.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/curve.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Short Weierstrass curve. The formula is: y² = x³ + ax + b\n\n\n\n\nfunction validatePointOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject(opts, {\n        a: 'field',\n        b: 'field',\n    }, {\n        allowedPrivateKeyLengths: 'array',\n        wrapPrivateKey: 'boolean',\n        isTorsionFree: 'function',\n        clearCofactor: 'function',\n        allowInfinityPoint: 'boolean',\n        fromBytes: 'function',\n        toBytes: 'function',\n    });\n    const { endo, Fp, a } = opts;\n    if (endo) {\n        if (!Fp.eql(a, Fp.ZERO)) {\n            throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');\n        }\n        if (typeof endo !== 'object' ||\n            typeof endo.beta !== 'bigint' ||\n            typeof endo.splitScalar !== 'function') {\n            throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');\n        }\n    }\n    return Object.freeze({ ...opts });\n}\n// ASN.1 DER encoding utilities\nconst { bytesToNumberBE: b2n, hexToBytes: h2b } = _utils_js__WEBPACK_IMPORTED_MODULE_1__;\nconst DER = {\n    // asn.1 DER encoding utils\n    Err: class DERErr extends Error {\n        constructor(m = '') {\n            super(m);\n        }\n    },\n    _parseInt(data) {\n        const { Err: E } = DER;\n        if (data.length < 2 || data[0] !== 0x02)\n            throw new E('Invalid signature integer tag');\n        const len = data[1];\n        const res = data.subarray(2, len + 2);\n        if (!len || res.length !== len)\n            throw new E('Invalid signature integer: wrong length');\n        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n        // since we always use positive integers here. It must always be empty:\n        // - add zero byte if exists\n        // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n        if (res[0] & 0b10000000)\n            throw new E('Invalid signature integer: negative');\n        if (res[0] === 0x00 && !(res[1] & 0b10000000))\n            throw new E('Invalid signature integer: unnecessary leading zero');\n        return { d: b2n(res), l: data.subarray(len + 2) }; // d is data, l is left\n    },\n    toSig(hex) {\n        // parse DER signature\n        const { Err: E } = DER;\n        const data = typeof hex === 'string' ? h2b(hex) : hex;\n        if (!(data instanceof Uint8Array))\n            throw new Error('ui8a expected');\n        let l = data.length;\n        if (l < 2 || data[0] != 0x30)\n            throw new E('Invalid signature tag');\n        if (data[1] !== l - 2)\n            throw new E('Invalid signature: incorrect length');\n        const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));\n        const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);\n        if (rBytesLeft.length)\n            throw new E('Invalid signature: left bytes after parsing');\n        return { r, s };\n    },\n    hexFromSig(sig) {\n        // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'\n        const slice = (s) => (Number.parseInt(s[0], 16) & 0b1000 ? '00' + s : s);\n        const h = (num) => {\n            const hex = num.toString(16);\n            return hex.length & 1 ? `0${hex}` : hex;\n        };\n        const s = slice(h(sig.s));\n        const r = slice(h(sig.r));\n        const shl = s.length / 2;\n        const rhl = r.length / 2;\n        const sl = h(shl);\n        const rl = h(rhl);\n        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;\n    },\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nfunction weierstrassPoints(opts) {\n    const CURVE = validatePointOpts(opts);\n    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n    const toBytes = CURVE.toBytes ||\n        ((_c, point, _isCompressed) => {\n            const a = point.toAffine();\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n        });\n    const fromBytes = CURVE.fromBytes ||\n        ((bytes) => {\n            // const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n            return { x, y };\n        });\n    /**\n     * y² = x³ + ax + b: Short weierstrass curve formula\n     * @returns y²\n     */\n    function weierstrassEquation(x) {\n        const { a, b } = CURVE;\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x2 * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n    }\n    // Validate whether the passed curve params are valid.\n    // We check if curve equation works for generator point.\n    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\n    // ProjectivePoint class has not been initialized yet.\n    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))\n        throw new Error('bad generator point: equation left != right');\n    // Valid group elements reside in range 1..n-1\n    function isWithinCurveOrder(num) {\n        return typeof num === 'bigint' && _0n < num && num < CURVE.n;\n    }\n    function assertGE(num) {\n        if (!isWithinCurveOrder(num))\n            throw new Error('Expected valid bigint: 0 < bigint < curve.n');\n    }\n    // Validates if priv key is valid and converts it to bigint.\n    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n    function normPrivateKeyToScalar(key) {\n        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;\n        if (lengths && typeof key !== 'bigint') {\n            if (key instanceof Uint8Array)\n                key = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(key);\n            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n            if (typeof key !== 'string' || !lengths.includes(key.length))\n                throw new Error('Invalid key');\n            key = key.padStart(nByteLength * 2, '0');\n        }\n        let num;\n        try {\n            num =\n                typeof key === 'bigint'\n                    ? key\n                    : _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('private key', key, nByteLength));\n        }\n        catch (error) {\n            throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);\n        }\n        if (wrapPrivateKey)\n            num = _modular_js__WEBPACK_IMPORTED_MODULE_2__.mod(num, n); // disabled by default, enabled for BLS\n        assertGE(num); // num in range [1..N-1]\n        return num;\n    }\n    const pointPrecomputes = new Map();\n    function assertPrjPoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('ProjectivePoint expected');\n    }\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z) ∋ (x=x/z, y=y/z)\n     * Default Point works in 2d / affine coordinates: (x, y)\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */\n    class Point {\n        constructor(px, py, pz) {\n            this.px = px;\n            this.py = py;\n            this.pz = pz;\n            if (px == null || !Fp.isValid(px))\n                throw new Error('x required');\n            if (py == null || !Fp.isValid(py))\n                throw new Error('y required');\n            if (pz == null || !Fp.isValid(pz))\n                throw new Error('z required');\n        }\n        // Does not validate if the point is on-curve.\n        // Use fromHex instead, or call assertValidity() later.\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('invalid affine point');\n            if (p instanceof Point)\n                throw new Error('projective point not allowed');\n            const is0 = (i) => Fp.eql(i, Fp.ZERO);\n            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n            if (is0(x) && is0(y))\n                return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         * Takes a bunch of Projective Points but executes only one\n         * inversion on all of them. Inversion is very slow operation,\n         * so this improves performance massively.\n         * Optimization: converts a list of projective points to a list of identical points with Z=1.\n         */\n        static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p) => p.pz));\n            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        /**\n         * Converts hash string or Uint8Array to Point.\n         * @param hex short/long ECDSA hex\n         */\n        static fromHex(hex) {\n            const P = Point.fromAffine(fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('pointHex', hex)));\n            P.assertValidity();\n            return P;\n        }\n        // Multiplies generator point by privateKey.\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            this._WINDOW_SIZE = windowSize;\n            pointPrecomputes.delete(this);\n        }\n        // A point on curve is valid if it conforms to equation.\n        assertValidity() {\n            if (this.is0()) {\n                // (0, 1, 0) aka ZERO is invalid in most contexts.\n                // In BLS, ZERO can be serialized, so we allow it.\n                // (0, 0, 0) is wrong representation of ZERO and is always invalid.\n                if (CURVE.allowInfinityPoint && !Fp.is0(this.py))\n                    return;\n                throw new Error('bad point: ZERO');\n            }\n            // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n            const { x, y } = this.toAffine();\n            // Check if x, y are valid field elements\n            if (!Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('bad point: x or y not FE');\n            const left = Fp.sqr(y); // y²\n            const right = weierstrassEquation(x); // x³ + ax + b\n            if (!Fp.eql(left, right))\n                throw new Error('bad point: equation left != right');\n            if (!this.isTorsionFree())\n                throw new Error('bad point: not in prime-order subgroup');\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (Fp.isOdd)\n                return !Fp.isOdd(y);\n            throw new Error(\"Field doesn't support isOdd\");\n        }\n        /**\n         * Compare one point to another.\n         */\n        equals(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /**\n         * Flips point to one corresponding to (x, -y) in Affine coordinates.\n         */\n        negate() {\n            return new Point(this.px, Fp.neg(this.py), this.pz);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {\n                const toInv = Fp.invertBatch(comp.map((p) => p.pz));\n                return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n            });\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed private key e.g. sig verification, which works over *public* keys.\n         */\n        multiplyUnsafe(n) {\n            const I = Point.ZERO;\n            if (n === _0n)\n                return I;\n            assertGE(n); // Will throw on 0\n            if (n === _1n)\n                return this;\n            const { endo } = CURVE;\n            if (!endo)\n                return wnaf.unsafeLadder(this, n);\n            // Apply endomorphism\n            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n            let k1p = I;\n            let k2p = I;\n            let d = this;\n            while (k1 > _0n || k2 > _0n) {\n                if (k1 & _1n)\n                    k1p = k1p.add(d);\n                if (k2 & _1n)\n                    k2p = k2p.add(d);\n                d = d.double();\n                k1 >>= _1n;\n                k2 >>= _1n;\n            }\n            if (k1neg)\n                k1p = k1p.negate();\n            if (k2neg)\n                k2p = k2p.negate();\n            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n            return k1p.add(k2p);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */\n        multiply(scalar) {\n            assertGE(scalar);\n            let n = scalar;\n            let point, fake; // Fake point is used to const-time mult\n            const { endo } = CURVE;\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n                let { p: k1p, f: f1p } = this.wNAF(k1);\n                let { p: k2p, f: f2p } = this.wNAF(k2);\n                k1p = wnaf.constTimeNegate(k1neg, k1p);\n                k2p = wnaf.constTimeNegate(k2neg, k2p);\n                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n                point = k1p.add(k2p);\n                fake = f1p.add(f2p);\n            }\n            else {\n                const { p, f } = this.wNAF(n);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return Point.normalizeZ([point, fake])[0];\n        }\n        /**\n         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n         * Not using Strauss-Shamir trick: precomputation tables are faster.\n         * The trick could be useful if both P and Q are not G (not in our case).\n         * @returns non-zero affine point\n         */\n        multiplyAndAddUnsafe(Q, a, b) {\n            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n            const mul = (P, a // Select faster multiply() method\n            ) => (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));\n            const sum = mul(this, a).add(mul(Q, b));\n            return sum.is0() ? undefined : sum;\n        }\n        // Converts Projective point to affine (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        // (x, y, z) ∋ (x=x/z, y=y/z)\n        toAffine(iz) {\n            const { px: x, py: y, pz: z } = this;\n            const is0 = this.is0();\n            // If invZ was 0, we return zero point. However we still want to execute\n            // all operations, so we replace invZ with a random number, 1.\n            if (iz == null)\n                iz = is0 ? Fp.ONE : Fp.inv(z);\n            const ax = Fp.mul(x, iz);\n            const ay = Fp.mul(y, iz);\n            const zz = Fp.mul(z, iz);\n            if (is0)\n                return { x: Fp.ZERO, y: Fp.ZERO };\n            if (!Fp.eql(zz, Fp.ONE))\n                throw new Error('invZ was invalid');\n            return { x: ax, y: ay };\n        }\n        isTorsionFree() {\n            const { h: cofactor, isTorsionFree } = CURVE;\n            if (cofactor === _1n)\n                return true; // No subgroups, always torsion-free\n            if (isTorsionFree)\n                return isTorsionFree(Point, this);\n            throw new Error('isTorsionFree() has not been declared for the elliptic curve');\n        }\n        clearCofactor() {\n            const { h: cofactor, clearCofactor } = CURVE;\n            if (cofactor === _1n)\n                return this; // Fast-path\n            if (clearCofactor)\n                return clearCofactor(Point, this);\n            return this.multiplyUnsafe(CURVE.h);\n        }\n        toRawBytes(isCompressed = true) {\n            this.assertValidity();\n            return toBytes(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(this.toRawBytes(isCompressed));\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n    const _bits = CURVE.nBitLength;\n    const wnaf = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n    // Validate if generator point is on curve\n    return {\n        CURVE,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar,\n        weierstrassEquation,\n        isWithinCurveOrder,\n    };\n}\nfunction validateOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject(opts, {\n        hash: 'hash',\n        hmac: 'function',\n        randomBytes: 'function',\n    }, {\n        bits2int: 'function',\n        bits2int_modN: 'function',\n        lowS: 'boolean',\n    });\n    return Object.freeze({ lowS: true, ...opts });\n}\nfunction weierstrass(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER } = CURVE;\n    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n    function isValidFieldElement(num) {\n        return _0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE\n    }\n    function modN(a) {\n        return _modular_js__WEBPACK_IMPORTED_MODULE_2__.mod(a, CURVE_ORDER);\n    }\n    function invN(a) {\n        return _modular_js__WEBPACK_IMPORTED_MODULE_2__.invert(a, CURVE_ORDER);\n    }\n    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder, } = weierstrassPoints({\n        ...CURVE,\n        toBytes(_c, point, isCompressed) {\n            const a = point.toAffine();\n            const x = Fp.toBytes(a.x);\n            const cat = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes;\n            if (isCompressed) {\n                return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);\n            }\n            else {\n                return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));\n            }\n        },\n        fromBytes(bytes) {\n            const len = bytes.length;\n            const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // this.assertValidity() is done inside of fromHex\n            if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n                const x = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(tail);\n                if (!isValidFieldElement(x))\n                    throw new Error('Point is not on curve');\n                const y2 = weierstrassEquation(x); // y² = x³ + ax + b\n                let y = Fp.sqrt(y2); // y = y² ^ (p+1)/4\n                const isYOdd = (y & _1n) === _1n;\n                // ECDSA\n                const isHeadOdd = (head & 1) === 1;\n                if (isHeadOdd !== isYOdd)\n                    y = Fp.neg(y);\n                return { x, y };\n            }\n            else if (len === uncompressedLen && head === 0x04) {\n                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n                return { x, y };\n            }\n            else {\n                throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);\n            }\n        },\n    });\n    const numToNByteStr = (num) => _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(_utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE(num, CURVE.nByteLength));\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function normalizeS(s) {\n        return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n    }\n    // slice bytes num\n    const slcNum = (b, from, to) => _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(b.slice(from, to));\n    /**\n     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n     */\n    class Signature {\n        constructor(r, s, recovery) {\n            this.r = r;\n            this.s = s;\n            this.recovery = recovery;\n            this.assertValidity();\n        }\n        // pair (bytes of r, bytes of s)\n        static fromCompact(hex) {\n            const l = CURVE.nByteLength;\n            hex = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('compactSignature', hex, l * 2);\n            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n        }\n        // DER encoded ECDSA signature\n        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n        static fromDER(hex) {\n            const { r, s } = DER.toSig((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('DER', hex));\n            return new Signature(r, s);\n        }\n        assertValidity() {\n            // can use assertGE here\n            if (!isWithinCurveOrder(this.r))\n                throw new Error('r must be 0 < r < CURVE.n');\n            if (!isWithinCurveOrder(this.s))\n                throw new Error('s must be 0 < s < CURVE.n');\n        }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(msgHash) {\n            const { r, s, recovery: rec } = this;\n            const h = bits2int_modN((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('msgHash', msgHash)); // Truncate hash\n            if (rec == null || ![0, 1, 2, 3].includes(rec))\n                throw new Error('recovery id invalid');\n            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n            if (radj >= Fp.ORDER)\n                throw new Error('recovery id 2 or 3 invalid');\n            const prefix = (rec & 1) === 0 ? '02' : '03';\n            const R = Point.fromHex(prefix + numToNByteStr(radj));\n            const ir = invN(radj); // r^-1\n            const u1 = modN(-h * ir); // -hr^-1\n            const u2 = modN(s * ir); // sr^-1\n            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n            if (!Q)\n                throw new Error('point at infinify'); // unsafe is fine: no priv data leaked\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n        }\n        // DER-encoded\n        toDERRawBytes() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.hexToBytes(this.toDERHex());\n        }\n        toDERHex() {\n            return DER.hexFromSig({ r: this.r, s: this.s });\n        }\n        // padded bytes of r, then padded bytes of s\n        toCompactRawBytes() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.hexToBytes(this.toCompactHex());\n        }\n        toCompactHex() {\n            return numToNByteStr(this.r) + numToNByteStr(this.s);\n        }\n    }\n    const utils = {\n        isValidPrivateKey(privateKey) {\n            try {\n                normPrivateKeyToScalar(privateKey);\n                return true;\n            }\n            catch (error) {\n                return false;\n            }\n        },\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\n        /**\n         * Produces cryptographically secure private key from random of size\n         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n         */\n        randomPrivateKey: () => {\n            const length = _modular_js__WEBPACK_IMPORTED_MODULE_2__.getMinHashLength(CURVE.n);\n            return _modular_js__WEBPACK_IMPORTED_MODULE_2__.mapHashToField(CURVE.randomBytes(length), CURVE.n);\n        },\n        /**\n         * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n         * Allows to massively speed-up `point.multiply(scalar)`.\n         * @returns cached point\n         * @example\n         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n         * fast.multiply(privKey); // much faster ECDH now\n         */\n        precompute(windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n            return point;\n        },\n    };\n    /**\n     * Computes public key for a private key. Checks for validity of the private key.\n     * @param privateKey private key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */\n    function getPublicKey(privateKey, isCompressed = true) {\n        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */\n    function isProbPub(item) {\n        const arr = item instanceof Uint8Array;\n        const str = typeof item === 'string';\n        const len = (arr || str) && item.length;\n        if (arr)\n            return len === compressedLen || len === uncompressedLen;\n        if (str)\n            return len === 2 * compressedLen || len === 2 * uncompressedLen;\n        if (item instanceof Point)\n            return true;\n        return false;\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from private key and public key.\n     * Checks: 1) private key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param privateA private key\n     * @param publicB different public key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */\n    function getSharedSecret(privateA, publicB, isCompressed = true) {\n        if (isProbPub(privateA))\n            throw new Error('first arg must be private key');\n        if (!isProbPub(publicB))\n            throw new Error('second arg must be public key');\n        const b = Point.fromHex(publicB); // check for being on-curve\n        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = CURVE.bits2int ||\n        function (bytes) {\n            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n            // for some cases, since bytes.length * 8 is not actual bitLength.\n            const num = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(bytes); // check for == u8 done here\n            const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n            return delta > 0 ? num >> BigInt(delta) : num;\n        };\n    const bits2int_modN = CURVE.bits2int_modN ||\n        function (bytes) {\n            return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n        };\n    // NOTE: pads output with zero as per spec\n    const ORDER_MASK = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bitMask(CURVE.nBitLength);\n    /**\n     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n     */\n    function int2octets(num) {\n        if (typeof num !== 'bigint')\n            throw new Error('bigint expected');\n        if (!(_0n <= num && num < ORDER_MASK))\n            throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);\n        // works with order, can have different size than numToField!\n        return _utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE(num, CURVE.nByteLength);\n    }\n    // Steps A, D of RFC6979 3.2\n    // Creates RFC6979 seed; converts msg/privKey to numbers.\n    // Used only in sign, not in verify.\n    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.\n    // Also it can be bigger for P224 + SHA256\n    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n        if (['recovered', 'canonical'].some((k) => k in opts))\n            throw new Error('sign() legacy options not supported');\n        const { hash, randomBytes } = CURVE;\n        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n        if (lowS == null)\n            lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('msgHash', msgHash);\n        if (prehash)\n            msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('prehashed msgHash', hash(msgHash));\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(msgHash);\n        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n        const seedArgs = [int2octets(d), int2octets(h1int)];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (ent != null) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n            seedArgs.push((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('extraEntropy', e)); // check for being bytes\n        }\n        const seed = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n            if (!isWithinCurveOrder(k))\n                return; // Important: all mod() calls here must be done over N\n            const ik = invN(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n            const r = modN(q.x); // r = q.x mod n\n            if (r === _0n)\n                return;\n            // Can use scalar blinding b^-1(bm + bdr) where b ∈ [1,q−1] according to\n            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n            const s = modN(ik * modN(m + r * d)); // Not using blinding here\n            if (s === _0n)\n                return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = normalizeS(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return { seed, k2sig };\n    }\n    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };\n    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };\n    /**\n     * Signs message hash with a private key.\n     * ```\n     * sign(m, d, k) where\n     *   (x, y) = G × k\n     *   r = x mod n\n     *   s = (m + dr)/k mod n\n     * ```\n     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n     * @param privKey private key\n     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n     * @returns signature with recovery param\n     */\n    function sign(msgHash, privKey, opts = defaultSigOpts) {\n        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n        const C = CURVE;\n        const drbg = _utils_js__WEBPACK_IMPORTED_MODULE_1__.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);\n        return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    }\n    // Enable precomputes. Slows down first publicKey computation by 20ms.\n    Point.BASE._setWindowSize(8);\n    // utils.precompute(8, ProjectivePoint.BASE)\n    /**\n     * Verifies a signature against message hash and public key.\n     * Rejects lowS signatures by default: to override,\n     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   U1 = hs^-1 mod n\n     *   U2 = rs^-1 mod n\n     *   R = U1⋅G - U2⋅P\n     *   mod(R.x, n) == r\n     * ```\n     */\n    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n        const sg = signature;\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('msgHash', msgHash);\n        publicKey = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('publicKey', publicKey);\n        if ('strict' in opts)\n            throw new Error('options.strict was renamed to lowS');\n        const { lowS, prehash } = opts;\n        let _sig = undefined;\n        let P;\n        try {\n            if (typeof sg === 'string' || sg instanceof Uint8Array) {\n                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n                // Since DER can also be 2*nByteLength bytes, we check for it first.\n                try {\n                    _sig = Signature.fromDER(sg);\n                }\n                catch (derError) {\n                    if (!(derError instanceof DER.Err))\n                        throw derError;\n                    _sig = Signature.fromCompact(sg);\n                }\n            }\n            else if (typeof sg === 'object' && typeof sg.r === 'bigint' && typeof sg.s === 'bigint') {\n                const { r, s } = sg;\n                _sig = new Signature(r, s);\n            }\n            else {\n                throw new Error('PARSE');\n            }\n            P = Point.fromHex(publicKey);\n        }\n        catch (error) {\n            if (error.message === 'PARSE')\n                throw new Error(`signature must be Signature instance, Uint8Array or hex string`);\n            return false;\n        }\n        if (lowS && _sig.hasHighS())\n            return false;\n        if (prehash)\n            msgHash = CURVE.hash(msgHash);\n        const { r, s } = _sig;\n        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n        const is = invN(s); // s^-1\n        const u1 = modN(h * is); // u1 = hs^-1 mod n\n        const u2 = modN(r * is); // u2 = rs^-1 mod n\n        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1⋅G + u2⋅P\n        if (!R)\n            return false;\n        const v = modN(R.x);\n        return v === r;\n    }\n    return {\n        CURVE,\n        getPublicKey,\n        getSharedSecret,\n        sign,\n        verify,\n        ProjectivePoint: Point,\n        Signature,\n        utils,\n    };\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nfunction SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for (let o = q - _1n; o % _2n === _0n; o /= _2n)\n        l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v) => {\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for (let i = c1; i > _1n; i--) {\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return { isValid: isQR, value: tv3 };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v) => {\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */\nfunction mapToCurveSimpleSWU(Fp, opts) {\n    _modular_js__WEBPACK_IMPORTED_MODULE_2__.validateField(Fp);\n    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))\n        throw new Error('mapToCurveSimpleSWU: invalid opts');\n    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n    if (!Fp.isOdd)\n        throw new Error('Fp.isOdd is not implemented!');\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u) => {\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        x = Fp.div(x, tv4); // 25.   x = x / tv4\n        return { x, y };\n    };\n}\n//# sourceMappingURL=weierstrass.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ29DO0FBQ0g7QUFDUTtBQUNRO0FBQ2pEO0FBQ0EsaUJBQWlCLHdEQUFhO0FBQzlCLElBQUkscURBQWlCO0FBQ3JCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBLFFBQVEsd0NBQXdDLEVBQUUsc0NBQUU7QUFDN0M7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwwQ0FBMEM7QUFDM0QsS0FBSztBQUNMO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQyxnQkFBZ0Isc0JBQXNCO0FBQ3RDO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsSUFBSTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUIsSUFBSSxHQUFHLEVBQUUsRUFBRSxJQUFJLEdBQUcsRUFBRSxFQUFFO0FBQzNELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtB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OlsiL2hvbWUvbGZnL0dpdC9NYWR0cmlwcy9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gU2hvcnQgV2VpZXJzdHJhc3MgY3VydmUuIFRoZSBmb3JtdWxhIGlzOiB5wrIgPSB4wrMgKyBheCArIGJcbmltcG9ydCAqIGFzIG1vZCBmcm9tICcuL21vZHVsYXIuanMnO1xuaW1wb3J0ICogYXMgdXQgZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgeyBlbnN1cmVCeXRlcyB9IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgd05BRiwgdmFsaWRhdGVCYXNpYyB9IGZyb20gJy4vY3VydmUuanMnO1xuZnVuY3Rpb24gdmFsaWRhdGVQb2ludE9wdHMoY3VydmUpIHtcbiAgICBjb25zdCBvcHRzID0gdmFsaWRhdGVCYXNpYyhjdXJ2ZSk7XG4gICAgdXQudmFsaWRhdGVPYmplY3Qob3B0cywge1xuICAgICAgICBhOiAnZmllbGQnLFxuICAgICAgICBiOiAnZmllbGQnLFxuICAgIH0sIHtcbiAgICAgICAgYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzOiAnYXJyYXknLFxuICAgICAgICB3cmFwUHJpdmF0ZUtleTogJ2Jvb2xlYW4nLFxuICAgICAgICBpc1RvcnNpb25GcmVlOiAnZnVuY3Rpb24nLFxuICAgICAgICBjbGVhckNvZmFjdG9yOiAnZnVuY3Rpb24nLFxuICAgICAgICBhbGxvd0luZmluaXR5UG9pbnQ6ICdib29sZWFuJyxcbiAgICAgICAgZnJvbUJ5dGVzOiAnZnVuY3Rpb24nLFxuICAgICAgICB0b0J5dGVzOiAnZnVuY3Rpb24nLFxuICAgIH0pO1xuICAgIGNvbnN0IHsgZW5kbywgRnAsIGEgfSA9IG9wdHM7XG4gICAgaWYgKGVuZG8pIHtcbiAgICAgICAgaWYgKCFGcC5lcWwoYSwgRnAuWkVSTykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRW5kb21vcnBoaXNtIGNhbiBvbmx5IGJlIGRlZmluZWQgZm9yIEtvYmxpdHogY3VydmVzIHRoYXQgaGF2ZSBhPTAnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGVuZG8gIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgICB0eXBlb2YgZW5kby5iZXRhICE9PSAnYmlnaW50JyB8fFxuICAgICAgICAgICAgdHlwZW9mIGVuZG8uc3BsaXRTY2FsYXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgZW5kb21vcnBoaXNtIHdpdGggYmV0YTogYmlnaW50IGFuZCBzcGxpdFNjYWxhcjogZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IC4uLm9wdHMgfSk7XG59XG4vLyBBU04uMSBERVIgZW5jb2RpbmcgdXRpbGl0aWVzXG5jb25zdCB7IGJ5dGVzVG9OdW1iZXJCRTogYjJuLCBoZXhUb0J5dGVzOiBoMmIgfSA9IHV0O1xuZXhwb3J0IGNvbnN0IERFUiA9IHtcbiAgICAvLyBhc24uMSBERVIgZW5jb2RpbmcgdXRpbHNcbiAgICBFcnI6IGNsYXNzIERFUkVyciBleHRlbmRzIEVycm9yIHtcbiAgICAgICAgY29uc3RydWN0b3IobSA9ICcnKSB7XG4gICAgICAgICAgICBzdXBlcihtKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgX3BhcnNlSW50KGRhdGEpIHtcbiAgICAgICAgY29uc3QgeyBFcnI6IEUgfSA9IERFUjtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoIDwgMiB8fCBkYXRhWzBdICE9PSAweDAyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlIGludGVnZXIgdGFnJyk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGFbMV07XG4gICAgICAgIGNvbnN0IHJlcyA9IGRhdGEuc3ViYXJyYXkoMiwgbGVuICsgMik7XG4gICAgICAgIGlmICghbGVuIHx8IHJlcy5sZW5ndGggIT09IGxlbilcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiB3cm9uZyBsZW5ndGgnKTtcbiAgICAgICAgLy8gaHR0cHM6Ly9jcnlwdG8uc3RhY2tleGNoYW5nZS5jb20vYS81NzczNCBMZWZ0bW9zdCBiaXQgb2YgZmlyc3QgYnl0ZSBpcyAnbmVnYXRpdmUnIGZsYWcsXG4gICAgICAgIC8vIHNpbmNlIHdlIGFsd2F5cyB1c2UgcG9zaXRpdmUgaW50ZWdlcnMgaGVyZS4gSXQgbXVzdCBhbHdheXMgYmUgZW1wdHk6XG4gICAgICAgIC8vIC0gYWRkIHplcm8gYnl0ZSBpZiBleGlzdHNcbiAgICAgICAgLy8gLSBpZiBuZXh0IGJ5dGUgZG9lc24ndCBoYXZlIGEgZmxhZywgbGVhZGluZyB6ZXJvIGlzIG5vdCBhbGxvd2VkIChtaW5pbWFsIGVuY29kaW5nKVxuICAgICAgICBpZiAocmVzWzBdICYgMGIxMDAwMDAwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiBuZWdhdGl2ZScpO1xuICAgICAgICBpZiAocmVzWzBdID09PSAweDAwICYmICEocmVzWzFdICYgMGIxMDAwMDAwMCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmUgaW50ZWdlcjogdW5uZWNlc3NhcnkgbGVhZGluZyB6ZXJvJyk7XG4gICAgICAgIHJldHVybiB7IGQ6IGIybihyZXMpLCBsOiBkYXRhLnN1YmFycmF5KGxlbiArIDIpIH07IC8vIGQgaXMgZGF0YSwgbCBpcyBsZWZ0XG4gICAgfSxcbiAgICB0b1NpZyhoZXgpIHtcbiAgICAgICAgLy8gcGFyc2UgREVSIHNpZ25hdHVyZVxuICAgICAgICBjb25zdCB7IEVycjogRSB9ID0gREVSO1xuICAgICAgICBjb25zdCBkYXRhID0gdHlwZW9mIGhleCA9PT0gJ3N0cmluZycgPyBoMmIoaGV4KSA6IGhleDtcbiAgICAgICAgaWYgKCEoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1aThhIGV4cGVjdGVkJyk7XG4gICAgICAgIGxldCBsID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGlmIChsIDwgMiB8fCBkYXRhWzBdICE9IDB4MzApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmUgdGFnJyk7XG4gICAgICAgIGlmIChkYXRhWzFdICE9PSBsIC0gMilcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZTogaW5jb3JyZWN0IGxlbmd0aCcpO1xuICAgICAgICBjb25zdCB7IGQ6IHIsIGw6IHNCeXRlcyB9ID0gREVSLl9wYXJzZUludChkYXRhLnN1YmFycmF5KDIpKTtcbiAgICAgICAgY29uc3QgeyBkOiBzLCBsOiByQnl0ZXNMZWZ0IH0gPSBERVIuX3BhcnNlSW50KHNCeXRlcyk7XG4gICAgICAgIGlmIChyQnl0ZXNMZWZ0Lmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZTogbGVmdCBieXRlcyBhZnRlciBwYXJzaW5nJyk7XG4gICAgICAgIHJldHVybiB7IHIsIHMgfTtcbiAgICB9LFxuICAgIGhleEZyb21TaWcoc2lnKSB7XG4gICAgICAgIC8vIEFkZCBsZWFkaW5nIHplcm8gaWYgZmlyc3QgYnl0ZSBoYXMgbmVnYXRpdmUgYml0IGVuYWJsZWQuIE1vcmUgZGV0YWlscyBpbiAnX3BhcnNlSW50J1xuICAgICAgICBjb25zdCBzbGljZSA9IChzKSA9PiAoTnVtYmVyLnBhcnNlSW50KHNbMF0sIDE2KSAmIDBiMTAwMCA/ICcwMCcgKyBzIDogcyk7XG4gICAgICAgIGNvbnN0IGggPSAobnVtKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBoZXggPSBudW0udG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgcmV0dXJuIGhleC5sZW5ndGggJiAxID8gYDAke2hleH1gIDogaGV4O1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzID0gc2xpY2UoaChzaWcucykpO1xuICAgICAgICBjb25zdCByID0gc2xpY2UoaChzaWcucikpO1xuICAgICAgICBjb25zdCBzaGwgPSBzLmxlbmd0aCAvIDI7XG4gICAgICAgIGNvbnN0IHJobCA9IHIubGVuZ3RoIC8gMjtcbiAgICAgICAgY29uc3Qgc2wgPSBoKHNobCk7XG4gICAgICAgIGNvbnN0IHJsID0gaChyaGwpO1xuICAgICAgICByZXR1cm4gYDMwJHtoKHJobCArIHNobCArIDQpfTAyJHtybH0ke3J9MDIke3NsfSR7c31gO1xuICAgIH0sXG59O1xuLy8gQmUgZnJpZW5kbHkgdG8gYmFkIEVDTUFTY3JpcHQgcGFyc2VycyBieSBub3QgdXNpbmcgYmlnaW50IGxpdGVyYWxzXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKSwgXzFuID0gQmlnSW50KDEpLCBfMm4gPSBCaWdJbnQoMiksIF8zbiA9IEJpZ0ludCgzKSwgXzRuID0gQmlnSW50KDQpO1xuZXhwb3J0IGZ1bmN0aW9uIHdlaWVyc3RyYXNzUG9pbnRzKG9wdHMpIHtcbiAgICBjb25zdCBDVVJWRSA9IHZhbGlkYXRlUG9pbnRPcHRzKG9wdHMpO1xuICAgIGNvbnN0IHsgRnAgfSA9IENVUlZFOyAvLyBBbGwgY3VydmVzIGhhcyBzYW1lIGZpZWxkIC8gZ3JvdXAgbGVuZ3RoIGFzIGZvciBub3csIGJ1dCB0aGV5IGNhbiBkaWZmZXJcbiAgICBjb25zdCB0b0J5dGVzID0gQ1VSVkUudG9CeXRlcyB8fFxuICAgICAgICAoKF9jLCBwb2ludCwgX2lzQ29tcHJlc3NlZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYSA9IHBvaW50LnRvQWZmaW5lKCk7XG4gICAgICAgICAgICByZXR1cm4gdXQuY29uY2F0Qnl0ZXMoVWludDhBcnJheS5mcm9tKFsweDA0XSksIEZwLnRvQnl0ZXMoYS54KSwgRnAudG9CeXRlcyhhLnkpKTtcbiAgICAgICAgfSk7XG4gICAgY29uc3QgZnJvbUJ5dGVzID0gQ1VSVkUuZnJvbUJ5dGVzIHx8XG4gICAgICAgICgoYnl0ZXMpID0+IHtcbiAgICAgICAgICAgIC8vIGNvbnN0IGhlYWQgPSBieXRlc1swXTtcbiAgICAgICAgICAgIGNvbnN0IHRhaWwgPSBieXRlcy5zdWJhcnJheSgxKTtcbiAgICAgICAgICAgIC8vIGlmIChoZWFkICE9PSAweDA0KSB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgbm9uLWNvbXByZXNzZWQgZW5jb2RpbmcgaXMgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICBjb25zdCB4ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoMCwgRnAuQllURVMpKTtcbiAgICAgICAgICAgIGNvbnN0IHkgPSBGcC5mcm9tQnl0ZXModGFpbC5zdWJhcnJheShGcC5CWVRFUywgMiAqIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgIH0pO1xuICAgIC8qKlxuICAgICAqIHnCsiA9IHjCsyArIGF4ICsgYjogU2hvcnQgd2VpZXJzdHJhc3MgY3VydmUgZm9ybXVsYVxuICAgICAqIEByZXR1cm5zIHnCslxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdlaWVyc3RyYXNzRXF1YXRpb24oeCkge1xuICAgICAgICBjb25zdCB7IGEsIGIgfSA9IENVUlZFO1xuICAgICAgICBjb25zdCB4MiA9IEZwLnNxcih4KTsgLy8geCAqIHhcbiAgICAgICAgY29uc3QgeDMgPSBGcC5tdWwoeDIsIHgpOyAvLyB4MiAqIHhcbiAgICAgICAgcmV0dXJuIEZwLmFkZChGcC5hZGQoeDMsIEZwLm11bCh4LCBhKSksIGIpOyAvLyB4MyArIGEgKiB4ICsgYlxuICAgIH1cbiAgICAvLyBWYWxpZGF0ZSB3aGV0aGVyIHRoZSBwYXNzZWQgY3VydmUgcGFyYW1zIGFyZSB2YWxpZC5cbiAgICAvLyBXZSBjaGVjayBpZiBjdXJ2ZSBlcXVhdGlvbiB3b3JrcyBmb3IgZ2VuZXJhdG9yIHBvaW50LlxuICAgIC8vIGBhc3NlcnRWYWxpZGl0eSgpYCB3b24ndCB3b3JrOiBgaXNUb3JzaW9uRnJlZSgpYCBpcyBub3QgYXZhaWxhYmxlIGF0IHRoaXMgcG9pbnQgaW4gYmxzMTItMzgxLlxuICAgIC8vIFByb2plY3RpdmVQb2ludCBjbGFzcyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0LlxuICAgIGlmICghRnAuZXFsKEZwLnNxcihDVVJWRS5HeSksIHdlaWVyc3RyYXNzRXF1YXRpb24oQ1VSVkUuR3gpKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgZ2VuZXJhdG9yIHBvaW50OiBlcXVhdGlvbiBsZWZ0ICE9IHJpZ2h0Jyk7XG4gICAgLy8gVmFsaWQgZ3JvdXAgZWxlbWVudHMgcmVzaWRlIGluIHJhbmdlIDEuLm4tMVxuICAgIGZ1bmN0aW9uIGlzV2l0aGluQ3VydmVPcmRlcihudW0pIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBudW0gPT09ICdiaWdpbnQnICYmIF8wbiA8IG51bSAmJiBudW0gPCBDVVJWRS5uO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhc3NlcnRHRShudW0pIHtcbiAgICAgICAgaWYgKCFpc1dpdGhpbkN1cnZlT3JkZXIobnVtKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdmFsaWQgYmlnaW50OiAwIDwgYmlnaW50IDwgY3VydmUubicpO1xuICAgIH1cbiAgICAvLyBWYWxpZGF0ZXMgaWYgcHJpdiBrZXkgaXMgdmFsaWQgYW5kIGNvbnZlcnRzIGl0IHRvIGJpZ2ludC5cbiAgICAvLyBTdXBwb3J0cyBvcHRpb25zIGFsbG93ZWRQcml2YXRlS2V5TGVuZ3RocyBhbmQgd3JhcFByaXZhdGVLZXkuXG4gICAgZnVuY3Rpb24gbm9ybVByaXZhdGVLZXlUb1NjYWxhcihrZXkpIHtcbiAgICAgICAgY29uc3QgeyBhbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHM6IGxlbmd0aHMsIG5CeXRlTGVuZ3RoLCB3cmFwUHJpdmF0ZUtleSwgbiB9ID0gQ1VSVkU7XG4gICAgICAgIGlmIChsZW5ndGhzICYmIHR5cGVvZiBrZXkgIT09ICdiaWdpbnQnKSB7XG4gICAgICAgICAgICBpZiAoa2V5IGluc3RhbmNlb2YgVWludDhBcnJheSlcbiAgICAgICAgICAgICAgICBrZXkgPSB1dC5ieXRlc1RvSGV4KGtleSk7XG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgdG8gaGV4IHN0cmluZywgcGFkLiBFLmcuIFA1MjEgd291bGQgbm9ybSAxMzAtMTMyIGNoYXIgaGV4IHRvIDEzMi1jaGFyIGJ5dGVzXG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycgfHwgIWxlbmd0aHMuaW5jbHVkZXMoa2V5Lmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGtleScpO1xuICAgICAgICAgICAga2V5ID0ga2V5LnBhZFN0YXJ0KG5CeXRlTGVuZ3RoICogMiwgJzAnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbnVtO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbnVtID1cbiAgICAgICAgICAgICAgICB0eXBlb2Yga2V5ID09PSAnYmlnaW50J1xuICAgICAgICAgICAgICAgICAgICA/IGtleVxuICAgICAgICAgICAgICAgICAgICA6IHV0LmJ5dGVzVG9OdW1iZXJCRShlbnN1cmVCeXRlcygncHJpdmF0ZSBrZXknLCBrZXksIG5CeXRlTGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHByaXZhdGUga2V5IG11c3QgYmUgJHtuQnl0ZUxlbmd0aH0gYnl0ZXMsIGhleCBvciBiaWdpbnQsIG5vdCAke3R5cGVvZiBrZXl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdyYXBQcml2YXRlS2V5KVxuICAgICAgICAgICAgbnVtID0gbW9kLm1vZChudW0sIG4pOyAvLyBkaXNhYmxlZCBieSBkZWZhdWx0LCBlbmFibGVkIGZvciBCTFNcbiAgICAgICAgYXNzZXJ0R0UobnVtKTsgLy8gbnVtIGluIHJhbmdlIFsxLi5OLTFdXG4gICAgICAgIHJldHVybiBudW07XG4gICAgfVxuICAgIGNvbnN0IHBvaW50UHJlY29tcHV0ZXMgPSBuZXcgTWFwKCk7XG4gICAgZnVuY3Rpb24gYXNzZXJ0UHJqUG9pbnQob3RoZXIpIHtcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBQb2ludCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb2plY3RpdmVQb2ludCBleHBlY3RlZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9qZWN0aXZlIFBvaW50IHdvcmtzIGluIDNkIC8gcHJvamVjdGl2ZSAoaG9tb2dlbmVvdXMpIGNvb3JkaW5hdGVzOiAoeCwgeSwgeikg4oiLICh4PXgveiwgeT15L3opXG4gICAgICogRGVmYXVsdCBQb2ludCB3b3JrcyBpbiAyZCAvIGFmZmluZSBjb29yZGluYXRlczogKHgsIHkpXG4gICAgICogV2UncmUgZG9pbmcgY2FsY3VsYXRpb25zIGluIHByb2plY3RpdmUsIGJlY2F1c2UgaXRzIG9wZXJhdGlvbnMgZG9uJ3QgcmVxdWlyZSBjb3N0bHkgaW52ZXJzaW9uLlxuICAgICAqL1xuICAgIGNsYXNzIFBvaW50IHtcbiAgICAgICAgY29uc3RydWN0b3IocHgsIHB5LCBweikge1xuICAgICAgICAgICAgdGhpcy5weCA9IHB4O1xuICAgICAgICAgICAgdGhpcy5weSA9IHB5O1xuICAgICAgICAgICAgdGhpcy5weiA9IHB6O1xuICAgICAgICAgICAgaWYgKHB4ID09IG51bGwgfHwgIUZwLmlzVmFsaWQocHgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneCByZXF1aXJlZCcpO1xuICAgICAgICAgICAgaWYgKHB5ID09IG51bGwgfHwgIUZwLmlzVmFsaWQocHkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneSByZXF1aXJlZCcpO1xuICAgICAgICAgICAgaWYgKHB6ID09IG51bGwgfHwgIUZwLmlzVmFsaWQocHopKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneiByZXF1aXJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvZXMgbm90IHZhbGlkYXRlIGlmIHRoZSBwb2ludCBpcyBvbi1jdXJ2ZS5cbiAgICAgICAgLy8gVXNlIGZyb21IZXggaW5zdGVhZCwgb3IgY2FsbCBhc3NlcnRWYWxpZGl0eSgpIGxhdGVyLlxuICAgICAgICBzdGF0aWMgZnJvbUFmZmluZShwKSB7XG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHAgfHwge307XG4gICAgICAgICAgICBpZiAoIXAgfHwgIUZwLmlzVmFsaWQoeCkgfHwgIUZwLmlzVmFsaWQoeSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFmZmluZSBwb2ludCcpO1xuICAgICAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBQb2ludClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2plY3RpdmUgcG9pbnQgbm90IGFsbG93ZWQnKTtcbiAgICAgICAgICAgIGNvbnN0IGlzMCA9IChpKSA9PiBGcC5lcWwoaSwgRnAuWkVSTyk7XG4gICAgICAgICAgICAvLyBmcm9tQWZmaW5lKHg6MCwgeTowKSB3b3VsZCBwcm9kdWNlICh4OjAsIHk6MCwgejoxKSwgYnV0IHdlIG5lZWQgKHg6MCwgeToxLCB6OjApXG4gICAgICAgICAgICBpZiAoaXMwKHgpICYmIGlzMCh5KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gUG9pbnQuWkVSTztcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoeCwgeSwgRnAuT05FKTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgeCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgeSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGFrZXMgYSBidW5jaCBvZiBQcm9qZWN0aXZlIFBvaW50cyBidXQgZXhlY3V0ZXMgb25seSBvbmVcbiAgICAgICAgICogaW52ZXJzaW9uIG9uIGFsbCBvZiB0aGVtLiBJbnZlcnNpb24gaXMgdmVyeSBzbG93IG9wZXJhdGlvbixcbiAgICAgICAgICogc28gdGhpcyBpbXByb3ZlcyBwZXJmb3JtYW5jZSBtYXNzaXZlbHkuXG4gICAgICAgICAqIE9wdGltaXphdGlvbjogY29udmVydHMgYSBsaXN0IG9mIHByb2plY3RpdmUgcG9pbnRzIHRvIGEgbGlzdCBvZiBpZGVudGljYWwgcG9pbnRzIHdpdGggWj0xLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIG5vcm1hbGl6ZVoocG9pbnRzKSB7XG4gICAgICAgICAgICBjb25zdCB0b0ludiA9IEZwLmludmVydEJhdGNoKHBvaW50cy5tYXAoKHApID0+IHAucHopKTtcbiAgICAgICAgICAgIHJldHVybiBwb2ludHMubWFwKChwLCBpKSA9PiBwLnRvQWZmaW5lKHRvSW52W2ldKSkubWFwKFBvaW50LmZyb21BZmZpbmUpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyBoYXNoIHN0cmluZyBvciBVaW50OEFycmF5IHRvIFBvaW50LlxuICAgICAgICAgKiBAcGFyYW0gaGV4IHNob3J0L2xvbmcgRUNEU0EgaGV4XG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZnJvbUhleChoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IFAgPSBQb2ludC5mcm9tQWZmaW5lKGZyb21CeXRlcyhlbnN1cmVCeXRlcygncG9pbnRIZXgnLCBoZXgpKSk7XG4gICAgICAgICAgICBQLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUDtcbiAgICAgICAgfVxuICAgICAgICAvLyBNdWx0aXBsaWVzIGdlbmVyYXRvciBwb2ludCBieSBwcml2YXRlS2V5LlxuICAgICAgICBzdGF0aWMgZnJvbVByaXZhdGVLZXkocHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgcmV0dXJuIFBvaW50LkJBU0UubXVsdGlwbHkobm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlS2V5KSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gXCJQcml2YXRlIG1ldGhvZFwiLCBkb24ndCB1c2UgaXQgZGlyZWN0bHlcbiAgICAgICAgX3NldFdpbmRvd1NpemUod2luZG93U2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5fV0lORE9XX1NJWkUgPSB3aW5kb3dTaXplO1xuICAgICAgICAgICAgcG9pbnRQcmVjb21wdXRlcy5kZWxldGUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQSBwb2ludCBvbiBjdXJ2ZSBpcyB2YWxpZCBpZiBpdCBjb25mb3JtcyB0byBlcXVhdGlvbi5cbiAgICAgICAgYXNzZXJ0VmFsaWRpdHkoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pczAoKSkge1xuICAgICAgICAgICAgICAgIC8vICgwLCAxLCAwKSBha2EgWkVSTyBpcyBpbnZhbGlkIGluIG1vc3QgY29udGV4dHMuXG4gICAgICAgICAgICAgICAgLy8gSW4gQkxTLCBaRVJPIGNhbiBiZSBzZXJpYWxpemVkLCBzbyB3ZSBhbGxvdyBpdC5cbiAgICAgICAgICAgICAgICAvLyAoMCwgMCwgMCkgaXMgd3JvbmcgcmVwcmVzZW50YXRpb24gb2YgWkVSTyBhbmQgaXMgYWx3YXlzIGludmFsaWQuXG4gICAgICAgICAgICAgICAgaWYgKENVUlZFLmFsbG93SW5maW5pdHlQb2ludCAmJiAhRnAuaXMwKHRoaXMucHkpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IFpFUk8nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNvbWUgM3JkLXBhcnR5IHRlc3QgdmVjdG9ycyByZXF1aXJlIGRpZmZlcmVudCB3b3JkaW5nIGJldHdlZW4gaGVyZSAmIGBmcm9tQ29tcHJlc3NlZEhleGBcbiAgICAgICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gdGhpcy50b0FmZmluZSgpO1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgeCwgeSBhcmUgdmFsaWQgZmllbGQgZWxlbWVudHNcbiAgICAgICAgICAgIGlmICghRnAuaXNWYWxpZCh4KSB8fCAhRnAuaXNWYWxpZCh5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogeCBvciB5IG5vdCBGRScpO1xuICAgICAgICAgICAgY29uc3QgbGVmdCA9IEZwLnNxcih5KTsgLy8gecKyXG4gICAgICAgICAgICBjb25zdCByaWdodCA9IHdlaWVyc3RyYXNzRXF1YXRpb24oeCk7IC8vIHjCsyArIGF4ICsgYlxuICAgICAgICAgICAgaWYgKCFGcC5lcWwobGVmdCwgcmlnaHQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBlcXVhdGlvbiBsZWZ0ICE9IHJpZ2h0Jyk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNUb3JzaW9uRnJlZSgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBub3QgaW4gcHJpbWUtb3JkZXIgc3ViZ3JvdXAnKTtcbiAgICAgICAgfVxuICAgICAgICBoYXNFdmVuWSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgeSB9ID0gdGhpcy50b0FmZmluZSgpO1xuICAgICAgICAgICAgaWYgKEZwLmlzT2RkKVxuICAgICAgICAgICAgICAgIHJldHVybiAhRnAuaXNPZGQoeSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaWVsZCBkb2Vzbid0IHN1cHBvcnQgaXNPZGRcIik7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbXBhcmUgb25lIHBvaW50IHRvIGFub3RoZXIuXG4gICAgICAgICAqL1xuICAgICAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgICAgIGFzc2VydFByalBvaW50KG90aGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgyLCBweTogWTIsIHB6OiBaMiB9ID0gb3RoZXI7XG4gICAgICAgICAgICBjb25zdCBVMSA9IEZwLmVxbChGcC5tdWwoWDEsIFoyKSwgRnAubXVsKFgyLCBaMSkpO1xuICAgICAgICAgICAgY29uc3QgVTIgPSBGcC5lcWwoRnAubXVsKFkxLCBaMiksIEZwLm11bChZMiwgWjEpKTtcbiAgICAgICAgICAgIHJldHVybiBVMSAmJiBVMjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRmxpcHMgcG9pbnQgdG8gb25lIGNvcnJlc3BvbmRpbmcgdG8gKHgsIC15KSBpbiBBZmZpbmUgY29vcmRpbmF0ZXMuXG4gICAgICAgICAqL1xuICAgICAgICBuZWdhdGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMucHgsIEZwLm5lZyh0aGlzLnB5KSwgdGhpcy5weik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVuZXMtQ29zdGVsbG8tQmF0aW5hIGV4Y2VwdGlvbi1mcmVlIGRvdWJsaW5nIGZvcm11bGEuXG4gICAgICAgIC8vIFRoZXJlIGlzIDMwJSBmYXN0ZXIgSmFjb2JpYW4gZm9ybXVsYSwgYnV0IGl0IGlzIG5vdCBjb21wbGV0ZS5cbiAgICAgICAgLy8gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxNS8xMDYwLCBhbGdvcml0aG0gM1xuICAgICAgICAvLyBDb3N0OiA4TSArIDNTICsgMyphICsgMipiMyArIDE1YWRkLlxuICAgICAgICBkb3VibGUoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGEsIGIgfSA9IENVUlZFO1xuICAgICAgICAgICAgY29uc3QgYjMgPSBGcC5tdWwoYiwgXzNuKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGxldCBYMyA9IEZwLlpFUk8sIFkzID0gRnAuWkVSTywgWjMgPSBGcC5aRVJPOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGxldCB0MCA9IEZwLm11bChYMSwgWDEpOyAvLyBzdGVwIDFcbiAgICAgICAgICAgIGxldCB0MSA9IEZwLm11bChZMSwgWTEpO1xuICAgICAgICAgICAgbGV0IHQyID0gRnAubXVsKFoxLCBaMSk7XG4gICAgICAgICAgICBsZXQgdDMgPSBGcC5tdWwoWDEsIFkxKTtcbiAgICAgICAgICAgIHQzID0gRnAuYWRkKHQzLCB0Myk7IC8vIHN0ZXAgNVxuICAgICAgICAgICAgWjMgPSBGcC5tdWwoWDEsIFoxKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCBaMyk7XG4gICAgICAgICAgICBYMyA9IEZwLm11bChhLCBaMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChiMywgdDIpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWDMsIFkzKTsgLy8gc3RlcCAxMFxuICAgICAgICAgICAgWDMgPSBGcC5zdWIodDEsIFkzKTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKHQxLCBZMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChYMywgWTMpO1xuICAgICAgICAgICAgWDMgPSBGcC5tdWwodDMsIFgzKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKGIzLCBaMyk7IC8vIHN0ZXAgMTVcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQzID0gRnAuc3ViKHQwLCB0Mik7XG4gICAgICAgICAgICB0MyA9IEZwLm11bChhLCB0Myk7XG4gICAgICAgICAgICB0MyA9IEZwLmFkZCh0MywgWjMpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQodDAsIHQwKTsgLy8gc3RlcCAyMFxuICAgICAgICAgICAgdDAgPSBGcC5hZGQoWjMsIHQwKTtcbiAgICAgICAgICAgIHQwID0gRnAuYWRkKHQwLCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MCwgdDMpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWTMsIHQwKTtcbiAgICAgICAgICAgIHQyID0gRnAubXVsKFkxLCBaMSk7IC8vIHN0ZXAgMjVcbiAgICAgICAgICAgIHQyID0gRnAuYWRkKHQyLCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MiwgdDMpO1xuICAgICAgICAgICAgWDMgPSBGcC5zdWIoWDMsIHQwKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKHQyLCB0MSk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpOyAvLyBzdGVwIDMwXG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChYMywgWTMsIFozKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW5lcy1Db3N0ZWxsby1CYXRpbmEgZXhjZXB0aW9uLWZyZWUgYWRkaXRpb24gZm9ybXVsYS5cbiAgICAgICAgLy8gVGhlcmUgaXMgMzAlIGZhc3RlciBKYWNvYmlhbiBmb3JtdWxhLCBidXQgaXQgaXMgbm90IGNvbXBsZXRlLlxuICAgICAgICAvLyBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDE1LzEwNjAsIGFsZ29yaXRobSAxXG4gICAgICAgIC8vIENvc3Q6IDEyTSArIDBTICsgMyphICsgMypiMyArIDIzYWRkLlxuICAgICAgICBhZGQob3RoZXIpIHtcbiAgICAgICAgICAgIGFzc2VydFByalBvaW50KG90aGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgyLCBweTogWTIsIHB6OiBaMiB9ID0gb3RoZXI7XG4gICAgICAgICAgICBsZXQgWDMgPSBGcC5aRVJPLCBZMyA9IEZwLlpFUk8sIFozID0gRnAuWkVSTzsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBjb25zdCBhID0gQ1VSVkUuYTtcbiAgICAgICAgICAgIGNvbnN0IGIzID0gRnAubXVsKENVUlZFLmIsIF8zbik7XG4gICAgICAgICAgICBsZXQgdDAgPSBGcC5tdWwoWDEsIFgyKTsgLy8gc3RlcCAxXG4gICAgICAgICAgICBsZXQgdDEgPSBGcC5tdWwoWTEsIFkyKTtcbiAgICAgICAgICAgIGxldCB0MiA9IEZwLm11bChaMSwgWjIpO1xuICAgICAgICAgICAgbGV0IHQzID0gRnAuYWRkKFgxLCBZMSk7XG4gICAgICAgICAgICBsZXQgdDQgPSBGcC5hZGQoWDIsIFkyKTsgLy8gc3RlcCA1XG4gICAgICAgICAgICB0MyA9IEZwLm11bCh0MywgdDQpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQodDAsIHQxKTtcbiAgICAgICAgICAgIHQzID0gRnAuc3ViKHQzLCB0NCk7XG4gICAgICAgICAgICB0NCA9IEZwLmFkZChYMSwgWjEpO1xuICAgICAgICAgICAgbGV0IHQ1ID0gRnAuYWRkKFgyLCBaMik7IC8vIHN0ZXAgMTBcbiAgICAgICAgICAgIHQ0ID0gRnAubXVsKHQ0LCB0NSk7XG4gICAgICAgICAgICB0NSA9IEZwLmFkZCh0MCwgdDIpO1xuICAgICAgICAgICAgdDQgPSBGcC5zdWIodDQsIHQ1KTtcbiAgICAgICAgICAgIHQ1ID0gRnAuYWRkKFkxLCBaMSk7XG4gICAgICAgICAgICBYMyA9IEZwLmFkZChZMiwgWjIpOyAvLyBzdGVwIDE1XG4gICAgICAgICAgICB0NSA9IEZwLm11bCh0NSwgWDMpO1xuICAgICAgICAgICAgWDMgPSBGcC5hZGQodDEsIHQyKTtcbiAgICAgICAgICAgIHQ1ID0gRnAuc3ViKHQ1LCBYMyk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bChhLCB0NCk7XG4gICAgICAgICAgICBYMyA9IEZwLm11bChiMywgdDIpOyAvLyBzdGVwIDIwXG4gICAgICAgICAgICBaMyA9IEZwLmFkZChYMywgWjMpO1xuICAgICAgICAgICAgWDMgPSBGcC5zdWIodDEsIFozKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKHQxLCBaMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChYMywgWjMpO1xuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDAsIHQwKTsgLy8gc3RlcCAyNVxuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDEsIHQwKTtcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQ0ID0gRnAubXVsKGIzLCB0NCk7XG4gICAgICAgICAgICB0MSA9IEZwLmFkZCh0MSwgdDIpO1xuICAgICAgICAgICAgdDIgPSBGcC5zdWIodDAsIHQyKTsgLy8gc3RlcCAzMFxuICAgICAgICAgICAgdDIgPSBGcC5tdWwoYSwgdDIpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQodDQsIHQyKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQxLCB0NCk7XG4gICAgICAgICAgICBZMyA9IEZwLmFkZChZMywgdDApO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDUsIHQ0KTsgLy8gc3RlcCAzNVxuICAgICAgICAgICAgWDMgPSBGcC5tdWwodDMsIFgzKTtcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKFgzLCB0MCk7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MywgdDEpO1xuICAgICAgICAgICAgWjMgPSBGcC5tdWwodDUsIFozKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCB0MCk7IC8vIHN0ZXAgNDBcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoWDMsIFkzLCBaMyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VidHJhY3Qob3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChvdGhlci5uZWdhdGUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaXMwKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXF1YWxzKFBvaW50LlpFUk8pO1xuICAgICAgICB9XG4gICAgICAgIHdOQUYobikge1xuICAgICAgICAgICAgcmV0dXJuIHduYWYud05BRkNhY2hlZCh0aGlzLCBwb2ludFByZWNvbXB1dGVzLCBuLCAoY29tcCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvSW52ID0gRnAuaW52ZXJ0QmF0Y2goY29tcC5tYXAoKHApID0+IHAucHopKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcC5tYXAoKHAsIGkpID0+IHAudG9BZmZpbmUodG9JbnZbaV0pKS5tYXAoUG9pbnQuZnJvbUFmZmluZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogTm9uLWNvbnN0YW50LXRpbWUgbXVsdGlwbGljYXRpb24uIFVzZXMgZG91YmxlLWFuZC1hZGQgYWxnb3JpdGhtLlxuICAgICAgICAgKiBJdCdzIGZhc3RlciwgYnV0IHNob3VsZCBvbmx5IGJlIHVzZWQgd2hlbiB5b3UgZG9uJ3QgY2FyZSBhYm91dFxuICAgICAgICAgKiBhbiBleHBvc2VkIHByaXZhdGUga2V5IGUuZy4gc2lnIHZlcmlmaWNhdGlvbiwgd2hpY2ggd29ya3Mgb3ZlciAqcHVibGljKiBrZXlzLlxuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGlwbHlVbnNhZmUobikge1xuICAgICAgICAgICAgY29uc3QgSSA9IFBvaW50LlpFUk87XG4gICAgICAgICAgICBpZiAobiA9PT0gXzBuKVxuICAgICAgICAgICAgICAgIHJldHVybiBJO1xuICAgICAgICAgICAgYXNzZXJ0R0Uobik7IC8vIFdpbGwgdGhyb3cgb24gMFxuICAgICAgICAgICAgaWYgKG4gPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgZW5kbyB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoIWVuZG8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHduYWYudW5zYWZlTGFkZGVyKHRoaXMsIG4pO1xuICAgICAgICAgICAgLy8gQXBwbHkgZW5kb21vcnBoaXNtXG4gICAgICAgICAgICBsZXQgeyBrMW5lZywgazEsIGsybmVnLCBrMiB9ID0gZW5kby5zcGxpdFNjYWxhcihuKTtcbiAgICAgICAgICAgIGxldCBrMXAgPSBJO1xuICAgICAgICAgICAgbGV0IGsycCA9IEk7XG4gICAgICAgICAgICBsZXQgZCA9IHRoaXM7XG4gICAgICAgICAgICB3aGlsZSAoazEgPiBfMG4gfHwgazIgPiBfMG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoazEgJiBfMW4pXG4gICAgICAgICAgICAgICAgICAgIGsxcCA9IGsxcC5hZGQoZCk7XG4gICAgICAgICAgICAgICAgaWYgKGsyICYgXzFuKVxuICAgICAgICAgICAgICAgICAgICBrMnAgPSBrMnAuYWRkKGQpO1xuICAgICAgICAgICAgICAgIGQgPSBkLmRvdWJsZSgpO1xuICAgICAgICAgICAgICAgIGsxID4+PSBfMW47XG4gICAgICAgICAgICAgICAgazIgPj49IF8xbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrMW5lZylcbiAgICAgICAgICAgICAgICBrMXAgPSBrMXAubmVnYXRlKCk7XG4gICAgICAgICAgICBpZiAoazJuZWcpXG4gICAgICAgICAgICAgICAgazJwID0gazJwLm5lZ2F0ZSgpO1xuICAgICAgICAgICAgazJwID0gbmV3IFBvaW50KEZwLm11bChrMnAucHgsIGVuZG8uYmV0YSksIGsycC5weSwgazJwLnB6KTtcbiAgICAgICAgICAgIHJldHVybiBrMXAuYWRkKGsycCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0YW50IHRpbWUgbXVsdGlwbGljYXRpb24uXG4gICAgICAgICAqIFVzZXMgd05BRiBtZXRob2QuIFdpbmRvd2VkIG1ldGhvZCBtYXkgYmUgMTAlIGZhc3RlcixcbiAgICAgICAgICogYnV0IHRha2VzIDJ4IGxvbmdlciB0byBnZW5lcmF0ZSBhbmQgY29uc3VtZXMgMnggbWVtb3J5LlxuICAgICAgICAgKiBVc2VzIHByZWNvbXB1dGVzIHdoZW4gYXZhaWxhYmxlLlxuICAgICAgICAgKiBVc2VzIGVuZG9tb3JwaGlzbSBmb3IgS29ibGl0eiBjdXJ2ZXMuXG4gICAgICAgICAqIEBwYXJhbSBzY2FsYXIgYnkgd2hpY2ggdGhlIHBvaW50IHdvdWxkIGJlIG11bHRpcGxpZWRcbiAgICAgICAgICogQHJldHVybnMgTmV3IHBvaW50XG4gICAgICAgICAqL1xuICAgICAgICBtdWx0aXBseShzY2FsYXIpIHtcbiAgICAgICAgICAgIGFzc2VydEdFKHNjYWxhcik7XG4gICAgICAgICAgICBsZXQgbiA9IHNjYWxhcjtcbiAgICAgICAgICAgIGxldCBwb2ludCwgZmFrZTsgLy8gRmFrZSBwb2ludCBpcyB1c2VkIHRvIGNvbnN0LXRpbWUgbXVsdFxuICAgICAgICAgICAgY29uc3QgeyBlbmRvIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGlmIChlbmRvKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBrMW5lZywgazEsIGsybmVnLCBrMiB9ID0gZW5kby5zcGxpdFNjYWxhcihuKTtcbiAgICAgICAgICAgICAgICBsZXQgeyBwOiBrMXAsIGY6IGYxcCB9ID0gdGhpcy53TkFGKGsxKTtcbiAgICAgICAgICAgICAgICBsZXQgeyBwOiBrMnAsIGY6IGYycCB9ID0gdGhpcy53TkFGKGsyKTtcbiAgICAgICAgICAgICAgICBrMXAgPSB3bmFmLmNvbnN0VGltZU5lZ2F0ZShrMW5lZywgazFwKTtcbiAgICAgICAgICAgICAgICBrMnAgPSB3bmFmLmNvbnN0VGltZU5lZ2F0ZShrMm5lZywgazJwKTtcbiAgICAgICAgICAgICAgICBrMnAgPSBuZXcgUG9pbnQoRnAubXVsKGsycC5weCwgZW5kby5iZXRhKSwgazJwLnB5LCBrMnAucHopO1xuICAgICAgICAgICAgICAgIHBvaW50ID0gazFwLmFkZChrMnApO1xuICAgICAgICAgICAgICAgIGZha2UgPSBmMXAuYWRkKGYycCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHAsIGYgfSA9IHRoaXMud05BRihuKTtcbiAgICAgICAgICAgICAgICBwb2ludCA9IHA7XG4gICAgICAgICAgICAgICAgZmFrZSA9IGY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgYHpgIGZvciBib3RoIHBvaW50cywgYnV0IHJldHVybiBvbmx5IHJlYWwgb25lXG4gICAgICAgICAgICByZXR1cm4gUG9pbnQubm9ybWFsaXplWihbcG9pbnQsIGZha2VdKVswXTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRWZmaWNpZW50bHkgY2FsY3VsYXRlIGBhUCArIGJRYC4gVW5zYWZlLCBjYW4gZXhwb3NlIHByaXZhdGUga2V5LCBpZiB1c2VkIGluY29ycmVjdGx5LlxuICAgICAgICAgKiBOb3QgdXNpbmcgU3RyYXVzcy1TaGFtaXIgdHJpY2s6IHByZWNvbXB1dGF0aW9uIHRhYmxlcyBhcmUgZmFzdGVyLlxuICAgICAgICAgKiBUaGUgdHJpY2sgY291bGQgYmUgdXNlZnVsIGlmIGJvdGggUCBhbmQgUSBhcmUgbm90IEcgKG5vdCBpbiBvdXIgY2FzZSkuXG4gICAgICAgICAqIEByZXR1cm5zIG5vbi16ZXJvIGFmZmluZSBwb2ludFxuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGlwbHlBbmRBZGRVbnNhZmUoUSwgYSwgYikge1xuICAgICAgICAgICAgY29uc3QgRyA9IFBvaW50LkJBU0U7IC8vIE5vIFN0cmF1c3MtU2hhbWlyIHRyaWNrOiB3ZSBoYXZlIDEwJSBmYXN0ZXIgRyBwcmVjb21wdXRlc1xuICAgICAgICAgICAgY29uc3QgbXVsID0gKFAsIGEgLy8gU2VsZWN0IGZhc3RlciBtdWx0aXBseSgpIG1ldGhvZFxuICAgICAgICAgICAgKSA9PiAoYSA9PT0gXzBuIHx8IGEgPT09IF8xbiB8fCAhUC5lcXVhbHMoRykgPyBQLm11bHRpcGx5VW5zYWZlKGEpIDogUC5tdWx0aXBseShhKSk7XG4gICAgICAgICAgICBjb25zdCBzdW0gPSBtdWwodGhpcywgYSkuYWRkKG11bChRLCBiKSk7XG4gICAgICAgICAgICByZXR1cm4gc3VtLmlzMCgpID8gdW5kZWZpbmVkIDogc3VtO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbnZlcnRzIFByb2plY3RpdmUgcG9pbnQgdG8gYWZmaW5lICh4LCB5KSBjb29yZGluYXRlcy5cbiAgICAgICAgLy8gQ2FuIGFjY2VwdCBwcmVjb21wdXRlZCBaXi0xIC0gZm9yIGV4YW1wbGUsIGZyb20gaW52ZXJ0QmF0Y2guXG4gICAgICAgIC8vICh4LCB5LCB6KSDiiIsgKHg9eC96LCB5PXkveilcbiAgICAgICAgdG9BZmZpbmUoaXopIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IHgsIHB5OiB5LCBwejogeiB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IGlzMCA9IHRoaXMuaXMwKCk7XG4gICAgICAgICAgICAvLyBJZiBpbnZaIHdhcyAwLCB3ZSByZXR1cm4gemVybyBwb2ludC4gSG93ZXZlciB3ZSBzdGlsbCB3YW50IHRvIGV4ZWN1dGVcbiAgICAgICAgICAgIC8vIGFsbCBvcGVyYXRpb25zLCBzbyB3ZSByZXBsYWNlIGludlogd2l0aCBhIHJhbmRvbSBudW1iZXIsIDEuXG4gICAgICAgICAgICBpZiAoaXogPT0gbnVsbClcbiAgICAgICAgICAgICAgICBpeiA9IGlzMCA/IEZwLk9ORSA6IEZwLmludih6KTtcbiAgICAgICAgICAgIGNvbnN0IGF4ID0gRnAubXVsKHgsIGl6KTtcbiAgICAgICAgICAgIGNvbnN0IGF5ID0gRnAubXVsKHksIGl6KTtcbiAgICAgICAgICAgIGNvbnN0IHp6ID0gRnAubXVsKHosIGl6KTtcbiAgICAgICAgICAgIGlmIChpczApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgeDogRnAuWkVSTywgeTogRnAuWkVSTyB9O1xuICAgICAgICAgICAgaWYgKCFGcC5lcWwoenosIEZwLk9ORSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZaIHdhcyBpbnZhbGlkJyk7XG4gICAgICAgICAgICByZXR1cm4geyB4OiBheCwgeTogYXkgfTtcbiAgICAgICAgfVxuICAgICAgICBpc1RvcnNpb25GcmVlKCkge1xuICAgICAgICAgICAgY29uc3QgeyBoOiBjb2ZhY3RvciwgaXNUb3JzaW9uRnJlZSB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoY29mYWN0b3IgPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gTm8gc3ViZ3JvdXBzLCBhbHdheXMgdG9yc2lvbi1mcmVlXG4gICAgICAgICAgICBpZiAoaXNUb3JzaW9uRnJlZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNUb3JzaW9uRnJlZShQb2ludCwgdGhpcyk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lzVG9yc2lvbkZyZWUoKSBoYXMgbm90IGJlZW4gZGVjbGFyZWQgZm9yIHRoZSBlbGxpcHRpYyBjdXJ2ZScpO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFyQ29mYWN0b3IoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGg6IGNvZmFjdG9yLCBjbGVhckNvZmFjdG9yIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGlmIChjb2ZhY3RvciA9PT0gXzFuKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzOyAvLyBGYXN0LXBhdGhcbiAgICAgICAgICAgIGlmIChjbGVhckNvZmFjdG9yKVxuICAgICAgICAgICAgICAgIHJldHVybiBjbGVhckNvZmFjdG9yKFBvaW50LCB0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5VW5zYWZlKENVUlZFLmgpO1xuICAgICAgICB9XG4gICAgICAgIHRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRvQnl0ZXMoUG9pbnQsIHRoaXMsIGlzQ29tcHJlc3NlZCk7XG4gICAgICAgIH1cbiAgICAgICAgdG9IZXgoaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHV0LmJ5dGVzVG9IZXgodGhpcy50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFBvaW50LkJBU0UgPSBuZXcgUG9pbnQoQ1VSVkUuR3gsIENVUlZFLkd5LCBGcC5PTkUpO1xuICAgIFBvaW50LlpFUk8gPSBuZXcgUG9pbnQoRnAuWkVSTywgRnAuT05FLCBGcC5aRVJPKTtcbiAgICBjb25zdCBfYml0cyA9IENVUlZFLm5CaXRMZW5ndGg7XG4gICAgY29uc3Qgd25hZiA9IHdOQUYoUG9pbnQsIENVUlZFLmVuZG8gPyBNYXRoLmNlaWwoX2JpdHMgLyAyKSA6IF9iaXRzKTtcbiAgICAvLyBWYWxpZGF0ZSBpZiBnZW5lcmF0b3IgcG9pbnQgaXMgb24gY3VydmVcbiAgICByZXR1cm4ge1xuICAgICAgICBDVVJWRSxcbiAgICAgICAgUHJvamVjdGl2ZVBvaW50OiBQb2ludCxcbiAgICAgICAgbm9ybVByaXZhdGVLZXlUb1NjYWxhcixcbiAgICAgICAgd2VpZXJzdHJhc3NFcXVhdGlvbixcbiAgICAgICAgaXNXaXRoaW5DdXJ2ZU9yZGVyLFxuICAgIH07XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU9wdHMoY3VydmUpIHtcbiAgICBjb25zdCBvcHRzID0gdmFsaWRhdGVCYXNpYyhjdXJ2ZSk7XG4gICAgdXQudmFsaWRhdGVPYmplY3Qob3B0cywge1xuICAgICAgICBoYXNoOiAnaGFzaCcsXG4gICAgICAgIGhtYWM6ICdmdW5jdGlvbicsXG4gICAgICAgIHJhbmRvbUJ5dGVzOiAnZnVuY3Rpb24nLFxuICAgIH0sIHtcbiAgICAgICAgYml0czJpbnQ6ICdmdW5jdGlvbicsXG4gICAgICAgIGJpdHMyaW50X21vZE46ICdmdW5jdGlvbicsXG4gICAgICAgIGxvd1M6ICdib29sZWFuJyxcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IGxvd1M6IHRydWUsIC4uLm9wdHMgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gd2VpZXJzdHJhc3MoY3VydmVEZWYpIHtcbiAgICBjb25zdCBDVVJWRSA9IHZhbGlkYXRlT3B0cyhjdXJ2ZURlZik7XG4gICAgY29uc3QgeyBGcCwgbjogQ1VSVkVfT1JERVIgfSA9IENVUlZFO1xuICAgIGNvbnN0IGNvbXByZXNzZWRMZW4gPSBGcC5CWVRFUyArIDE7IC8vIGUuZy4gMzMgZm9yIDMyXG4gICAgY29uc3QgdW5jb21wcmVzc2VkTGVuID0gMiAqIEZwLkJZVEVTICsgMTsgLy8gZS5nLiA2NSBmb3IgMzJcbiAgICBmdW5jdGlvbiBpc1ZhbGlkRmllbGRFbGVtZW50KG51bSkge1xuICAgICAgICByZXR1cm4gXzBuIDwgbnVtICYmIG51bSA8IEZwLk9SREVSOyAvLyAwIGlzIGJhbm5lZCBzaW5jZSBpdCdzIG5vdCBpbnZlcnRpYmxlIEZFXG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vZE4oYSkge1xuICAgICAgICByZXR1cm4gbW9kLm1vZChhLCBDVVJWRV9PUkRFUik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludk4oYSkge1xuICAgICAgICByZXR1cm4gbW9kLmludmVydChhLCBDVVJWRV9PUkRFUik7XG4gICAgfVxuICAgIGNvbnN0IHsgUHJvamVjdGl2ZVBvaW50OiBQb2ludCwgbm9ybVByaXZhdGVLZXlUb1NjYWxhciwgd2VpZXJzdHJhc3NFcXVhdGlvbiwgaXNXaXRoaW5DdXJ2ZU9yZGVyLCB9ID0gd2VpZXJzdHJhc3NQb2ludHMoe1xuICAgICAgICAuLi5DVVJWRSxcbiAgICAgICAgdG9CeXRlcyhfYywgcG9pbnQsIGlzQ29tcHJlc3NlZCkge1xuICAgICAgICAgICAgY29uc3QgYSA9IHBvaW50LnRvQWZmaW5lKCk7XG4gICAgICAgICAgICBjb25zdCB4ID0gRnAudG9CeXRlcyhhLngpO1xuICAgICAgICAgICAgY29uc3QgY2F0ID0gdXQuY29uY2F0Qnl0ZXM7XG4gICAgICAgICAgICBpZiAoaXNDb21wcmVzc2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhdChVaW50OEFycmF5LmZyb20oW3BvaW50Lmhhc0V2ZW5ZKCkgPyAweDAyIDogMHgwM10pLCB4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYXQoVWludDhBcnJheS5mcm9tKFsweDA0XSksIHgsIEZwLnRvQnl0ZXMoYS55KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZyb21CeXRlcyhieXRlcykge1xuICAgICAgICAgICAgY29uc3QgbGVuID0gYnl0ZXMubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgaGVhZCA9IGJ5dGVzWzBdO1xuICAgICAgICAgICAgY29uc3QgdGFpbCA9IGJ5dGVzLnN1YmFycmF5KDEpO1xuICAgICAgICAgICAgLy8gdGhpcy5hc3NlcnRWYWxpZGl0eSgpIGlzIGRvbmUgaW5zaWRlIG9mIGZyb21IZXhcbiAgICAgICAgICAgIGlmIChsZW4gPT09IGNvbXByZXNzZWRMZW4gJiYgKGhlYWQgPT09IDB4MDIgfHwgaGVhZCA9PT0gMHgwMykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gdXQuYnl0ZXNUb051bWJlckJFKHRhaWwpO1xuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZEZpZWxkRWxlbWVudCh4KSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb2ludCBpcyBub3Qgb24gY3VydmUnKTtcbiAgICAgICAgICAgICAgICBjb25zdCB5MiA9IHdlaWVyc3RyYXNzRXF1YXRpb24oeCk7IC8vIHnCsiA9IHjCsyArIGF4ICsgYlxuICAgICAgICAgICAgICAgIGxldCB5ID0gRnAuc3FydCh5Mik7IC8vIHkgPSB5wrIgXiAocCsxKS80XG4gICAgICAgICAgICAgICAgY29uc3QgaXNZT2RkID0gKHkgJiBfMW4pID09PSBfMW47XG4gICAgICAgICAgICAgICAgLy8gRUNEU0FcbiAgICAgICAgICAgICAgICBjb25zdCBpc0hlYWRPZGQgPSAoaGVhZCAmIDEpID09PSAxO1xuICAgICAgICAgICAgICAgIGlmIChpc0hlYWRPZGQgIT09IGlzWU9kZClcbiAgICAgICAgICAgICAgICAgICAgeSA9IEZwLm5lZyh5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsZW4gPT09IHVuY29tcHJlc3NlZExlbiAmJiBoZWFkID09PSAweDA0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KDAsIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KEZwLkJZVEVTLCAyICogRnAuQllURVMpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvaW50IG9mIGxlbmd0aCAke2xlbn0gd2FzIGludmFsaWQuIEV4cGVjdGVkICR7Y29tcHJlc3NlZExlbn0gY29tcHJlc3NlZCBieXRlcyBvciAke3VuY29tcHJlc3NlZExlbn0gdW5jb21wcmVzc2VkIGJ5dGVzYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgY29uc3QgbnVtVG9OQnl0ZVN0ciA9IChudW0pID0+IHV0LmJ5dGVzVG9IZXgodXQubnVtYmVyVG9CeXRlc0JFKG51bSwgQ1VSVkUubkJ5dGVMZW5ndGgpKTtcbiAgICBmdW5jdGlvbiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIobnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IEhBTEYgPSBDVVJWRV9PUkRFUiA+PiBfMW47XG4gICAgICAgIHJldHVybiBudW1iZXIgPiBIQUxGO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub3JtYWxpemVTKHMpIHtcbiAgICAgICAgcmV0dXJuIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihzKSA/IG1vZE4oLXMpIDogcztcbiAgICB9XG4gICAgLy8gc2xpY2UgYnl0ZXMgbnVtXG4gICAgY29uc3Qgc2xjTnVtID0gKGIsIGZyb20sIHRvKSA9PiB1dC5ieXRlc1RvTnVtYmVyQkUoYi5zbGljZShmcm9tLCB0bykpO1xuICAgIC8qKlxuICAgICAqIEVDRFNBIHNpZ25hdHVyZSB3aXRoIGl0cyAociwgcykgcHJvcGVydGllcy4gU3VwcG9ydHMgREVSICYgY29tcGFjdCByZXByZXNlbnRhdGlvbnMuXG4gICAgICovXG4gICAgY2xhc3MgU2lnbmF0dXJlIHtcbiAgICAgICAgY29uc3RydWN0b3IociwgcywgcmVjb3ZlcnkpIHtcbiAgICAgICAgICAgIHRoaXMuciA9IHI7XG4gICAgICAgICAgICB0aGlzLnMgPSBzO1xuICAgICAgICAgICAgdGhpcy5yZWNvdmVyeSA9IHJlY292ZXJ5O1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhaXIgKGJ5dGVzIG9mIHIsIGJ5dGVzIG9mIHMpXG4gICAgICAgIHN0YXRpYyBmcm9tQ29tcGFjdChoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IGwgPSBDVVJWRS5uQnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIGhleCA9IGVuc3VyZUJ5dGVzKCdjb21wYWN0U2lnbmF0dXJlJywgaGV4LCBsICogMik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShzbGNOdW0oaGV4LCAwLCBsKSwgc2xjTnVtKGhleCwgbCwgMiAqIGwpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBERVIgZW5jb2RlZCBFQ0RTQSBzaWduYXR1cmVcbiAgICAgICAgLy8gaHR0cHM6Ly9iaXRjb2luLnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy81NzY0NC93aGF0LWFyZS10aGUtcGFydHMtb2YtYS1iaXRjb2luLXRyYW5zYWN0aW9uLWlucHV0LXNjcmlwdFxuICAgICAgICBzdGF0aWMgZnJvbURFUihoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgciwgcyB9ID0gREVSLnRvU2lnKGVuc3VyZUJ5dGVzKCdERVInLCBoZXgpKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHIsIHMpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydFZhbGlkaXR5KCkge1xuICAgICAgICAgICAgLy8gY2FuIHVzZSBhc3NlcnRHRSBoZXJlXG4gICAgICAgICAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcih0aGlzLnIpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignciBtdXN0IGJlIDAgPCByIDwgQ1VSVkUubicpO1xuICAgICAgICAgICAgaWYgKCFpc1dpdGhpbkN1cnZlT3JkZXIodGhpcy5zKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3MgbXVzdCBiZSAwIDwgcyA8IENVUlZFLm4nKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRSZWNvdmVyeUJpdChyZWNvdmVyeSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUodGhpcy5yLCB0aGlzLnMsIHJlY292ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICByZWNvdmVyUHVibGljS2V5KG1zZ0hhc2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgciwgcywgcmVjb3Zlcnk6IHJlYyB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IGggPSBiaXRzMmludF9tb2ROKGVuc3VyZUJ5dGVzKCdtc2dIYXNoJywgbXNnSGFzaCkpOyAvLyBUcnVuY2F0ZSBoYXNoXG4gICAgICAgICAgICBpZiAocmVjID09IG51bGwgfHwgIVswLCAxLCAyLCAzXS5pbmNsdWRlcyhyZWMpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVjb3ZlcnkgaWQgaW52YWxpZCcpO1xuICAgICAgICAgICAgY29uc3QgcmFkaiA9IHJlYyA9PT0gMiB8fCByZWMgPT09IDMgPyByICsgQ1VSVkUubiA6IHI7XG4gICAgICAgICAgICBpZiAocmFkaiA+PSBGcC5PUkRFUilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlY292ZXJ5IGlkIDIgb3IgMyBpbnZhbGlkJyk7XG4gICAgICAgICAgICBjb25zdCBwcmVmaXggPSAocmVjICYgMSkgPT09IDAgPyAnMDInIDogJzAzJztcbiAgICAgICAgICAgIGNvbnN0IFIgPSBQb2ludC5mcm9tSGV4KHByZWZpeCArIG51bVRvTkJ5dGVTdHIocmFkaikpO1xuICAgICAgICAgICAgY29uc3QgaXIgPSBpbnZOKHJhZGopOyAvLyByXi0xXG4gICAgICAgICAgICBjb25zdCB1MSA9IG1vZE4oLWggKiBpcik7IC8vIC1ocl4tMVxuICAgICAgICAgICAgY29uc3QgdTIgPSBtb2ROKHMgKiBpcik7IC8vIHNyXi0xXG4gICAgICAgICAgICBjb25zdCBRID0gUG9pbnQuQkFTRS5tdWx0aXBseUFuZEFkZFVuc2FmZShSLCB1MSwgdTIpOyAvLyAoc3JeLTEpUi0oaHJeLTEpRyA9IC0oaHJeLTEpRyArIChzcl4tMSlcbiAgICAgICAgICAgIGlmICghUSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BvaW50IGF0IGluZmluaWZ5Jyk7IC8vIHVuc2FmZSBpcyBmaW5lOiBubyBwcml2IGRhdGEgbGVha2VkXG4gICAgICAgICAgICBRLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaWduYXR1cmVzIHNob3VsZCBiZSBsb3ctcywgdG8gcHJldmVudCBtYWxsZWFiaWxpdHkuXG4gICAgICAgIGhhc0hpZ2hTKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcih0aGlzLnMpO1xuICAgICAgICB9XG4gICAgICAgIG5vcm1hbGl6ZVMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYXNIaWdoUygpID8gbmV3IFNpZ25hdHVyZSh0aGlzLnIsIG1vZE4oLXRoaXMucyksIHRoaXMucmVjb3ZlcnkpIDogdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBERVItZW5jb2RlZFxuICAgICAgICB0b0RFUlJhd0J5dGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHV0LmhleFRvQnl0ZXModGhpcy50b0RFUkhleCgpKTtcbiAgICAgICAgfVxuICAgICAgICB0b0RFUkhleCgpIHtcbiAgICAgICAgICAgIHJldHVybiBERVIuaGV4RnJvbVNpZyh7IHI6IHRoaXMuciwgczogdGhpcy5zIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhZGRlZCBieXRlcyBvZiByLCB0aGVuIHBhZGRlZCBieXRlcyBvZiBzXG4gICAgICAgIHRvQ29tcGFjdFJhd0J5dGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHV0LmhleFRvQnl0ZXModGhpcy50b0NvbXBhY3RIZXgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9Db21wYWN0SGV4KCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bVRvTkJ5dGVTdHIodGhpcy5yKSArIG51bVRvTkJ5dGVTdHIodGhpcy5zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB1dGlscyA9IHtcbiAgICAgICAgaXNWYWxpZFByaXZhdGVLZXkocHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVLZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyOiBub3JtUHJpdmF0ZUtleVRvU2NhbGFyLFxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZHVjZXMgY3J5cHRvZ3JhcGhpY2FsbHkgc2VjdXJlIHByaXZhdGUga2V5IGZyb20gcmFuZG9tIG9mIHNpemVcbiAgICAgICAgICogKGdyb3VwTGVuICsgY2VpbChncm91cExlbiAvIDIpKSB3aXRoIG1vZHVsbyBiaWFzIGJlaW5nIG5lZ2xpZ2libGUuXG4gICAgICAgICAqL1xuICAgICAgICByYW5kb21Qcml2YXRlS2V5OiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBtb2QuZ2V0TWluSGFzaExlbmd0aChDVVJWRS5uKTtcbiAgICAgICAgICAgIHJldHVybiBtb2QubWFwSGFzaFRvRmllbGQoQ1VSVkUucmFuZG9tQnl0ZXMobGVuZ3RoKSwgQ1VSVkUubik7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIHByZWNvbXB1dGUgdGFibGUgZm9yIGFuIGFyYml0cmFyeSBFQyBwb2ludC4gTWFrZXMgcG9pbnQgXCJjYWNoZWRcIi5cbiAgICAgICAgICogQWxsb3dzIHRvIG1hc3NpdmVseSBzcGVlZC11cCBgcG9pbnQubXVsdGlwbHkoc2NhbGFyKWAuXG4gICAgICAgICAqIEByZXR1cm5zIGNhY2hlZCBwb2ludFxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBjb25zdCBmYXN0ID0gdXRpbHMucHJlY29tcHV0ZSg4LCBQcm9qZWN0aXZlUG9pbnQuZnJvbUhleChzb21lb25lc1B1YktleSkpO1xuICAgICAgICAgKiBmYXN0Lm11bHRpcGx5KHByaXZLZXkpOyAvLyBtdWNoIGZhc3RlciBFQ0RIIG5vd1xuICAgICAgICAgKi9cbiAgICAgICAgcHJlY29tcHV0ZSh3aW5kb3dTaXplID0gOCwgcG9pbnQgPSBQb2ludC5CQVNFKSB7XG4gICAgICAgICAgICBwb2ludC5fc2V0V2luZG93U2l6ZSh3aW5kb3dTaXplKTtcbiAgICAgICAgICAgIHBvaW50Lm11bHRpcGx5KEJpZ0ludCgzKSk7IC8vIDMgaXMgYXJiaXRyYXJ5LCBqdXN0IG5lZWQgYW55IG51bWJlciBoZXJlXG4gICAgICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBwdWJsaWMga2V5IGZvciBhIHByaXZhdGUga2V5LiBDaGVja3MgZm9yIHZhbGlkaXR5IG9mIHRoZSBwcml2YXRlIGtleS5cbiAgICAgKiBAcGFyYW0gcHJpdmF0ZUtleSBwcml2YXRlIGtleVxuICAgICAqIEBwYXJhbSBpc0NvbXByZXNzZWQgd2hldGhlciB0byByZXR1cm4gY29tcGFjdCAoZGVmYXVsdCksIG9yIGZ1bGwga2V5XG4gICAgICogQHJldHVybnMgUHVibGljIGtleSwgZnVsbCB3aGVuIGlzQ29tcHJlc3NlZD1mYWxzZTsgc2hvcnQgd2hlbiBpc0NvbXByZXNzZWQ9dHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFB1YmxpY0tleShwcml2YXRlS2V5LCBpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBQb2ludC5mcm9tUHJpdmF0ZUtleShwcml2YXRlS2V5KS50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1aWNrIGFuZCBkaXJ0eSBjaGVjayBmb3IgaXRlbSBiZWluZyBwdWJsaWMga2V5LiBEb2VzIG5vdCB2YWxpZGF0ZSBoZXgsIG9yIGJlaW5nIG9uLWN1cnZlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUHJvYlB1YihpdGVtKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IGl0ZW0gaW5zdGFuY2VvZiBVaW50OEFycmF5O1xuICAgICAgICBjb25zdCBzdHIgPSB0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZyc7XG4gICAgICAgIGNvbnN0IGxlbiA9IChhcnIgfHwgc3RyKSAmJiBpdGVtLmxlbmd0aDtcbiAgICAgICAgaWYgKGFycilcbiAgICAgICAgICAgIHJldHVybiBsZW4gPT09IGNvbXByZXNzZWRMZW4gfHwgbGVuID09PSB1bmNvbXByZXNzZWRMZW47XG4gICAgICAgIGlmIChzdHIpXG4gICAgICAgICAgICByZXR1cm4gbGVuID09PSAyICogY29tcHJlc3NlZExlbiB8fCBsZW4gPT09IDIgKiB1bmNvbXByZXNzZWRMZW47XG4gICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgUG9pbnQpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFQ0RIIChFbGxpcHRpYyBDdXJ2ZSBEaWZmaWUgSGVsbG1hbikuXG4gICAgICogQ29tcHV0ZXMgc2hhcmVkIHB1YmxpYyBrZXkgZnJvbSBwcml2YXRlIGtleSBhbmQgcHVibGljIGtleS5cbiAgICAgKiBDaGVja3M6IDEpIHByaXZhdGUga2V5IHZhbGlkaXR5IDIpIHNoYXJlZCBrZXkgaXMgb24tY3VydmUuXG4gICAgICogRG9lcyBOT1QgaGFzaCB0aGUgcmVzdWx0LlxuICAgICAqIEBwYXJhbSBwcml2YXRlQSBwcml2YXRlIGtleVxuICAgICAqIEBwYXJhbSBwdWJsaWNCIGRpZmZlcmVudCBwdWJsaWMga2V5XG4gICAgICogQHBhcmFtIGlzQ29tcHJlc3NlZCB3aGV0aGVyIHRvIHJldHVybiBjb21wYWN0IChkZWZhdWx0KSwgb3IgZnVsbCBrZXlcbiAgICAgKiBAcmV0dXJucyBzaGFyZWQgcHVibGljIGtleVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFNoYXJlZFNlY3JldChwcml2YXRlQSwgcHVibGljQiwgaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICBpZiAoaXNQcm9iUHViKHByaXZhdGVBKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZmlyc3QgYXJnIG11c3QgYmUgcHJpdmF0ZSBrZXknKTtcbiAgICAgICAgaWYgKCFpc1Byb2JQdWIocHVibGljQikpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NlY29uZCBhcmcgbXVzdCBiZSBwdWJsaWMga2V5Jyk7XG4gICAgICAgIGNvbnN0IGIgPSBQb2ludC5mcm9tSGV4KHB1YmxpY0IpOyAvLyBjaGVjayBmb3IgYmVpbmcgb24tY3VydmVcbiAgICAgICAgcmV0dXJuIGIubXVsdGlwbHkobm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlQSkpLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKTtcbiAgICB9XG4gICAgLy8gUkZDNjk3OTogZW5zdXJlIEVDRFNBIG1zZyBpcyBYIGJ5dGVzIGFuZCA8IE4uIFJGQyBzdWdnZXN0cyBvcHRpb25hbCB0cnVuY2F0aW5nIHZpYSBiaXRzMm9jdGV0cy5cbiAgICAvLyBGSVBTIDE4Ni00IDQuNiBzdWdnZXN0cyB0aGUgbGVmdG1vc3QgbWluKG5CaXRMZW4sIG91dExlbikgYml0cywgd2hpY2ggbWF0Y2hlcyBiaXRzMmludC5cbiAgICAvLyBiaXRzMmludCBjYW4gcHJvZHVjZSByZXM+Tiwgd2UgY2FuIGRvIG1vZChyZXMsIE4pIHNpbmNlIHRoZSBiaXRMZW4gaXMgdGhlIHNhbWUuXG4gICAgLy8gaW50Mm9jdGV0cyBjYW4ndCBiZSB1c2VkOyBwYWRzIHNtYWxsIG1zZ3Mgd2l0aCAwOiB1bmFjY2VwdGF0YmxlIGZvciB0cnVuYyBhcyBwZXIgUkZDIHZlY3RvcnNcbiAgICBjb25zdCBiaXRzMmludCA9IENVUlZFLmJpdHMyaW50IHx8XG4gICAgICAgIGZ1bmN0aW9uIChieXRlcykge1xuICAgICAgICAgICAgLy8gRm9yIGN1cnZlcyB3aXRoIG5CaXRMZW5ndGggJSA4ICE9PSAwOiBiaXRzMm9jdGV0cyhiaXRzMm9jdGV0cyhtKSkgIT09IGJpdHMyb2N0ZXRzKG0pXG4gICAgICAgICAgICAvLyBmb3Igc29tZSBjYXNlcywgc2luY2UgYnl0ZXMubGVuZ3RoICogOCBpcyBub3QgYWN0dWFsIGJpdExlbmd0aC5cbiAgICAgICAgICAgIGNvbnN0IG51bSA9IHV0LmJ5dGVzVG9OdW1iZXJCRShieXRlcyk7IC8vIGNoZWNrIGZvciA9PSB1OCBkb25lIGhlcmVcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gYnl0ZXMubGVuZ3RoICogOCAtIENVUlZFLm5CaXRMZW5ndGg7IC8vIHRydW5jYXRlIHRvIG5CaXRMZW5ndGggbGVmdG1vc3QgYml0c1xuICAgICAgICAgICAgcmV0dXJuIGRlbHRhID4gMCA/IG51bSA+PiBCaWdJbnQoZGVsdGEpIDogbnVtO1xuICAgICAgICB9O1xuICAgIGNvbnN0IGJpdHMyaW50X21vZE4gPSBDVVJWRS5iaXRzMmludF9tb2ROIHx8XG4gICAgICAgIGZ1bmN0aW9uIChieXRlcykge1xuICAgICAgICAgICAgcmV0dXJuIG1vZE4oYml0czJpbnQoYnl0ZXMpKTsgLy8gY2FuJ3QgdXNlIGJ5dGVzVG9OdW1iZXJCRSBoZXJlXG4gICAgICAgIH07XG4gICAgLy8gTk9URTogcGFkcyBvdXRwdXQgd2l0aCB6ZXJvIGFzIHBlciBzcGVjXG4gICAgY29uc3QgT1JERVJfTUFTSyA9IHV0LmJpdE1hc2soQ1VSVkUubkJpdExlbmd0aCk7XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdG8gYnl0ZXMuIENoZWNrcyBpZiBudW0gaW4gYFswLi5PUkRFUl9NQVNLLTFdYCBlLmcuOiBgWzAuLjJeMjU2LTFdYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnQyb2N0ZXRzKG51bSkge1xuICAgICAgICBpZiAodHlwZW9mIG51bSAhPT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JpZ2ludCBleHBlY3RlZCcpO1xuICAgICAgICBpZiAoIShfMG4gPD0gbnVtICYmIG51bSA8IE9SREVSX01BU0spKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBiaWdpbnQgZXhwZWN0ZWQgPCAyXiR7Q1VSVkUubkJpdExlbmd0aH1gKTtcbiAgICAgICAgLy8gd29ya3Mgd2l0aCBvcmRlciwgY2FuIGhhdmUgZGlmZmVyZW50IHNpemUgdGhhbiBudW1Ub0ZpZWxkIVxuICAgICAgICByZXR1cm4gdXQubnVtYmVyVG9CeXRlc0JFKG51bSwgQ1VSVkUubkJ5dGVMZW5ndGgpO1xuICAgIH1cbiAgICAvLyBTdGVwcyBBLCBEIG9mIFJGQzY5NzkgMy4yXG4gICAgLy8gQ3JlYXRlcyBSRkM2OTc5IHNlZWQ7IGNvbnZlcnRzIG1zZy9wcml2S2V5IHRvIG51bWJlcnMuXG4gICAgLy8gVXNlZCBvbmx5IGluIHNpZ24sIG5vdCBpbiB2ZXJpZnkuXG4gICAgLy8gTk9URTogd2UgY2Fubm90IGFzc3VtZSBoZXJlIHRoYXQgbXNnSGFzaCBoYXMgc2FtZSBhbW91bnQgb2YgYnl0ZXMgYXMgY3VydmUgb3JkZXIsIHRoaXMgd2lsbCBiZSB3cm9uZyBhdCBsZWFzdCBmb3IgUDUyMS5cbiAgICAvLyBBbHNvIGl0IGNhbiBiZSBiaWdnZXIgZm9yIFAyMjQgKyBTSEEyNTZcbiAgICBmdW5jdGlvbiBwcmVwU2lnKG1zZ0hhc2gsIHByaXZhdGVLZXksIG9wdHMgPSBkZWZhdWx0U2lnT3B0cykge1xuICAgICAgICBpZiAoWydyZWNvdmVyZWQnLCAnY2Fub25pY2FsJ10uc29tZSgoaykgPT4gayBpbiBvcHRzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbigpIGxlZ2FjeSBvcHRpb25zIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgY29uc3QgeyBoYXNoLCByYW5kb21CeXRlcyB9ID0gQ1VSVkU7XG4gICAgICAgIGxldCB7IGxvd1MsIHByZWhhc2gsIGV4dHJhRW50cm9weTogZW50IH0gPSBvcHRzOyAvLyBnZW5lcmF0ZXMgbG93LXMgc2lncyBieSBkZWZhdWx0XG4gICAgICAgIGlmIChsb3dTID09IG51bGwpXG4gICAgICAgICAgICBsb3dTID0gdHJ1ZTsgLy8gUkZDNjk3OSAzLjI6IHdlIHNraXAgc3RlcCBBLCBiZWNhdXNlIHdlIGFscmVhZHkgcHJvdmlkZSBoYXNoXG4gICAgICAgIG1zZ0hhc2ggPSBlbnN1cmVCeXRlcygnbXNnSGFzaCcsIG1zZ0hhc2gpO1xuICAgICAgICBpZiAocHJlaGFzaClcbiAgICAgICAgICAgIG1zZ0hhc2ggPSBlbnN1cmVCeXRlcygncHJlaGFzaGVkIG1zZ0hhc2gnLCBoYXNoKG1zZ0hhc2gpKTtcbiAgICAgICAgLy8gV2UgY2FuJ3QgbGF0ZXIgY2FsbCBiaXRzMm9jdGV0cywgc2luY2UgbmVzdGVkIGJpdHMyaW50IGlzIGJyb2tlbiBmb3IgY3VydmVzXG4gICAgICAgIC8vIHdpdGggbkJpdExlbmd0aCAlIDggIT09IDAuIEJlY2F1c2Ugb2YgdGhhdCwgd2UgdW53cmFwIGl0IGhlcmUgYXMgaW50Mm9jdGV0cyBjYWxsLlxuICAgICAgICAvLyBjb25zdCBiaXRzMm9jdGV0cyA9IChiaXRzKSA9PiBpbnQyb2N0ZXRzKGJpdHMyaW50X21vZE4oYml0cykpXG4gICAgICAgIGNvbnN0IGgxaW50ID0gYml0czJpbnRfbW9kTihtc2dIYXNoKTtcbiAgICAgICAgY29uc3QgZCA9IG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUtleSk7IC8vIHZhbGlkYXRlIHByaXZhdGUga2V5LCBjb252ZXJ0IHRvIGJpZ2ludFxuICAgICAgICBjb25zdCBzZWVkQXJncyA9IFtpbnQyb2N0ZXRzKGQpLCBpbnQyb2N0ZXRzKGgxaW50KV07XG4gICAgICAgIC8vIGV4dHJhRW50cm9weS4gUkZDNjk3OSAzLjY6IGFkZGl0aW9uYWwgaycgKG9wdGlvbmFsKS5cbiAgICAgICAgaWYgKGVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBLID0gSE1BQ19LKFYgfHwgMHgwMCB8fCBpbnQyb2N0ZXRzKHgpIHx8IGJpdHMyb2N0ZXRzKGgxKSB8fCBrJylcbiAgICAgICAgICAgIGNvbnN0IGUgPSBlbnQgPT09IHRydWUgPyByYW5kb21CeXRlcyhGcC5CWVRFUykgOiBlbnQ7IC8vIGdlbmVyYXRlIHJhbmRvbSBieXRlcyBPUiBwYXNzIGFzLWlzXG4gICAgICAgICAgICBzZWVkQXJncy5wdXNoKGVuc3VyZUJ5dGVzKCdleHRyYUVudHJvcHknLCBlKSk7IC8vIGNoZWNrIGZvciBiZWluZyBieXRlc1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlZWQgPSB1dC5jb25jYXRCeXRlcyguLi5zZWVkQXJncyk7IC8vIFN0ZXAgRCBvZiBSRkM2OTc5IDMuMlxuICAgICAgICBjb25zdCBtID0gaDFpbnQ7IC8vIE5PVEU6IG5vIG5lZWQgdG8gY2FsbCBiaXRzMmludCBzZWNvbmQgdGltZSBoZXJlLCBpdCBpcyBpbnNpZGUgdHJ1bmNhdGVIYXNoIVxuICAgICAgICAvLyBDb252ZXJ0cyBzaWduYXR1cmUgcGFyYW1zIGludG8gcG9pbnQgdyByL3MsIGNoZWNrcyByZXN1bHQgZm9yIHZhbGlkaXR5LlxuICAgICAgICBmdW5jdGlvbiBrMnNpZyhrQnl0ZXMpIHtcbiAgICAgICAgICAgIC8vIFJGQyA2OTc5IFNlY3Rpb24gMy4yLCBzdGVwIDM6IGsgPSBiaXRzMmludChUKVxuICAgICAgICAgICAgY29uc3QgayA9IGJpdHMyaW50KGtCeXRlcyk7IC8vIENhbm5vdCB1c2UgZmllbGRzIG1ldGhvZHMsIHNpbmNlIGl0IGlzIGdyb3VwIGVsZW1lbnRcbiAgICAgICAgICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKGspKVxuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gSW1wb3J0YW50OiBhbGwgbW9kKCkgY2FsbHMgaGVyZSBtdXN0IGJlIGRvbmUgb3ZlciBOXG4gICAgICAgICAgICBjb25zdCBpayA9IGludk4oayk7IC8vIGteLTEgbW9kIG5cbiAgICAgICAgICAgIGNvbnN0IHEgPSBQb2ludC5CQVNFLm11bHRpcGx5KGspLnRvQWZmaW5lKCk7IC8vIHEgPSBHa1xuICAgICAgICAgICAgY29uc3QgciA9IG1vZE4ocS54KTsgLy8gciA9IHEueCBtb2QgblxuICAgICAgICAgICAgaWYgKHIgPT09IF8wbilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBDYW4gdXNlIHNjYWxhciBibGluZGluZyBiXi0xKGJtICsgYmRyKSB3aGVyZSBiIOKIiCBbMSxx4oiSMV0gYWNjb3JkaW5nIHRvXG4gICAgICAgICAgICAvLyBodHRwczovL3RjaGVzLmlhY3Iub3JnL2luZGV4LnBocC9UQ0hFUy9hcnRpY2xlL3ZpZXcvNzMzNy82NTA5LiBXZSd2ZSBkZWNpZGVkIGFnYWluc3QgaXQ6XG4gICAgICAgICAgICAvLyBhKSBkZXBlbmRlbmN5IG9uIENTUFJORyBiKSAxNSUgc2xvd2Rvd24gYykgZG9lc24ndCByZWFsbHkgaGVscCBzaW5jZSBiaWdpbnRzIGFyZSBub3QgQ1RcbiAgICAgICAgICAgIGNvbnN0IHMgPSBtb2ROKGlrICogbW9kTihtICsgciAqIGQpKTsgLy8gTm90IHVzaW5nIGJsaW5kaW5nIGhlcmVcbiAgICAgICAgICAgIGlmIChzID09PSBfMG4pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHJlY292ZXJ5ID0gKHEueCA9PT0gciA/IDAgOiAyKSB8IE51bWJlcihxLnkgJiBfMW4pOyAvLyByZWNvdmVyeSBiaXQgKDIgb3IgMywgd2hlbiBxLnggPiBuKVxuICAgICAgICAgICAgbGV0IG5vcm1TID0gcztcbiAgICAgICAgICAgIGlmIChsb3dTICYmIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihzKSkge1xuICAgICAgICAgICAgICAgIG5vcm1TID0gbm9ybWFsaXplUyhzKTsgLy8gaWYgbG93UyB3YXMgcGFzc2VkLCBlbnN1cmUgcyBpcyBhbHdheXNcbiAgICAgICAgICAgICAgICByZWNvdmVyeSBePSAxOyAvLyAvLyBpbiB0aGUgYm90dG9tIGhhbGYgb2YgTlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUociwgbm9ybVMsIHJlY292ZXJ5KTsgLy8gdXNlIG5vcm1TLCBub3Qgc1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHNlZWQsIGsyc2lnIH07XG4gICAgfVxuICAgIGNvbnN0IGRlZmF1bHRTaWdPcHRzID0geyBsb3dTOiBDVVJWRS5sb3dTLCBwcmVoYXNoOiBmYWxzZSB9O1xuICAgIGNvbnN0IGRlZmF1bHRWZXJPcHRzID0geyBsb3dTOiBDVVJWRS5sb3dTLCBwcmVoYXNoOiBmYWxzZSB9O1xuICAgIC8qKlxuICAgICAqIFNpZ25zIG1lc3NhZ2UgaGFzaCB3aXRoIGEgcHJpdmF0ZSBrZXkuXG4gICAgICogYGBgXG4gICAgICogc2lnbihtLCBkLCBrKSB3aGVyZVxuICAgICAqICAgKHgsIHkpID0gRyDDlyBrXG4gICAgICogICByID0geCBtb2QgblxuICAgICAqICAgcyA9IChtICsgZHIpL2sgbW9kIG5cbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0gbXNnSGFzaCBOT1QgbWVzc2FnZS4gbXNnIG5lZWRzIHRvIGJlIGhhc2hlZCB0byBgbXNnSGFzaGAsIG9yIHVzZSBgcHJlaGFzaGAuXG4gICAgICogQHBhcmFtIHByaXZLZXkgcHJpdmF0ZSBrZXlcbiAgICAgKiBAcGFyYW0gb3B0cyBsb3dTIGZvciBub24tbWFsbGVhYmxlIHNpZ3MuIGV4dHJhRW50cm9weSBmb3IgbWl4aW5nIHJhbmRvbW5lc3MgaW50byBrLiBwcmVoYXNoIHdpbGwgaGFzaCBmaXJzdCBhcmcuXG4gICAgICogQHJldHVybnMgc2lnbmF0dXJlIHdpdGggcmVjb3ZlcnkgcGFyYW1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaWduKG1zZ0hhc2gsIHByaXZLZXksIG9wdHMgPSBkZWZhdWx0U2lnT3B0cykge1xuICAgICAgICBjb25zdCB7IHNlZWQsIGsyc2lnIH0gPSBwcmVwU2lnKG1zZ0hhc2gsIHByaXZLZXksIG9wdHMpOyAvLyBTdGVwcyBBLCBEIG9mIFJGQzY5NzkgMy4yLlxuICAgICAgICBjb25zdCBDID0gQ1VSVkU7XG4gICAgICAgIGNvbnN0IGRyYmcgPSB1dC5jcmVhdGVIbWFjRHJiZyhDLmhhc2gub3V0cHV0TGVuLCBDLm5CeXRlTGVuZ3RoLCBDLmhtYWMpO1xuICAgICAgICByZXR1cm4gZHJiZyhzZWVkLCBrMnNpZyk7IC8vIFN0ZXBzIEIsIEMsIEQsIEUsIEYsIEdcbiAgICB9XG4gICAgLy8gRW5hYmxlIHByZWNvbXB1dGVzLiBTbG93cyBkb3duIGZpcnN0IHB1YmxpY0tleSBjb21wdXRhdGlvbiBieSAyMG1zLlxuICAgIFBvaW50LkJBU0UuX3NldFdpbmRvd1NpemUoOCk7XG4gICAgLy8gdXRpbHMucHJlY29tcHV0ZSg4LCBQcm9qZWN0aXZlUG9pbnQuQkFTRSlcbiAgICAvKipcbiAgICAgKiBWZXJpZmllcyBhIHNpZ25hdHVyZSBhZ2FpbnN0IG1lc3NhZ2UgaGFzaCBhbmQgcHVibGljIGtleS5cbiAgICAgKiBSZWplY3RzIGxvd1Mgc2lnbmF0dXJlcyBieSBkZWZhdWx0OiB0byBvdmVycmlkZSxcbiAgICAgKiBzcGVjaWZ5IG9wdGlvbiBge2xvd1M6IGZhbHNlfWAuIEltcGxlbWVudHMgc2VjdGlvbiA0LjEuNCBmcm9tIGh0dHBzOi8vd3d3LnNlY2cub3JnL3NlYzEtdjIucGRmOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogdmVyaWZ5KHIsIHMsIGgsIFApIHdoZXJlXG4gICAgICogICBVMSA9IGhzXi0xIG1vZCBuXG4gICAgICogICBVMiA9IHJzXi0xIG1vZCBuXG4gICAgICogICBSID0gVTHii4VHIC0gVTLii4VQXG4gICAgICogICBtb2QoUi54LCBuKSA9PSByXG4gICAgICogYGBgXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmVyaWZ5KHNpZ25hdHVyZSwgbXNnSGFzaCwgcHVibGljS2V5LCBvcHRzID0gZGVmYXVsdFZlck9wdHMpIHtcbiAgICAgICAgY29uc3Qgc2cgPSBzaWduYXR1cmU7XG4gICAgICAgIG1zZ0hhc2ggPSBlbnN1cmVCeXRlcygnbXNnSGFzaCcsIG1zZ0hhc2gpO1xuICAgICAgICBwdWJsaWNLZXkgPSBlbnN1cmVCeXRlcygncHVibGljS2V5JywgcHVibGljS2V5KTtcbiAgICAgICAgaWYgKCdzdHJpY3QnIGluIG9wdHMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMuc3RyaWN0IHdhcyByZW5hbWVkIHRvIGxvd1MnKTtcbiAgICAgICAgY29uc3QgeyBsb3dTLCBwcmVoYXNoIH0gPSBvcHRzO1xuICAgICAgICBsZXQgX3NpZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IFA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNnID09PSAnc3RyaW5nJyB8fCBzZyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgICAgICAvLyBTaWduYXR1cmUgY2FuIGJlIHJlcHJlc2VudGVkIGluIDIgd2F5czogY29tcGFjdCAoMipuQnl0ZUxlbmd0aCkgJiBERVIgKHZhcmlhYmxlLWxlbmd0aCkuXG4gICAgICAgICAgICAgICAgLy8gU2luY2UgREVSIGNhbiBhbHNvIGJlIDIqbkJ5dGVMZW5ndGggYnl0ZXMsIHdlIGNoZWNrIGZvciBpdCBmaXJzdC5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBfc2lnID0gU2lnbmF0dXJlLmZyb21ERVIoc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZGVyRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoZGVyRXJyb3IgaW5zdGFuY2VvZiBERVIuRXJyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGRlckVycm9yO1xuICAgICAgICAgICAgICAgICAgICBfc2lnID0gU2lnbmF0dXJlLmZyb21Db21wYWN0KHNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc2cgPT09ICdvYmplY3QnICYmIHR5cGVvZiBzZy5yID09PSAnYmlnaW50JyAmJiB0eXBlb2Ygc2cucyA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHIsIHMgfSA9IHNnO1xuICAgICAgICAgICAgICAgIF9zaWcgPSBuZXcgU2lnbmF0dXJlKHIsIHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQQVJTRScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUCA9IFBvaW50LmZyb21IZXgocHVibGljS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlID09PSAnUEFSU0UnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgc2lnbmF0dXJlIG11c3QgYmUgU2lnbmF0dXJlIGluc3RhbmNlLCBVaW50OEFycmF5IG9yIGhleCBzdHJpbmdgKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG93UyAmJiBfc2lnLmhhc0hpZ2hTKCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChwcmVoYXNoKVxuICAgICAgICAgICAgbXNnSGFzaCA9IENVUlZFLmhhc2gobXNnSGFzaCk7XG4gICAgICAgIGNvbnN0IHsgciwgcyB9ID0gX3NpZztcbiAgICAgICAgY29uc3QgaCA9IGJpdHMyaW50X21vZE4obXNnSGFzaCk7IC8vIENhbm5vdCB1c2UgZmllbGRzIG1ldGhvZHMsIHNpbmNlIGl0IGlzIGdyb3VwIGVsZW1lbnRcbiAgICAgICAgY29uc3QgaXMgPSBpbnZOKHMpOyAvLyBzXi0xXG4gICAgICAgIGNvbnN0IHUxID0gbW9kTihoICogaXMpOyAvLyB1MSA9IGhzXi0xIG1vZCBuXG4gICAgICAgIGNvbnN0IHUyID0gbW9kTihyICogaXMpOyAvLyB1MiA9IHJzXi0xIG1vZCBuXG4gICAgICAgIGNvbnN0IFIgPSBQb2ludC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKFAsIHUxLCB1Mik/LnRvQWZmaW5lKCk7IC8vIFIgPSB1MeKLhUcgKyB1MuKLhVBcbiAgICAgICAgaWYgKCFSKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCB2ID0gbW9kTihSLngpO1xuICAgICAgICByZXR1cm4gdiA9PT0gcjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgQ1VSVkUsXG4gICAgICAgIGdldFB1YmxpY0tleSxcbiAgICAgICAgZ2V0U2hhcmVkU2VjcmV0LFxuICAgICAgICBzaWduLFxuICAgICAgICB2ZXJpZnksXG4gICAgICAgIFByb2plY3RpdmVQb2ludDogUG9pbnQsXG4gICAgICAgIFNpZ25hdHVyZSxcbiAgICAgICAgdXRpbHMsXG4gICAgfTtcbn1cbi8qKlxuICogSW1wbGVtZW50YXRpb24gb2YgdGhlIFNoYWxsdWUgYW5kIHZhbiBkZSBXb2VzdGlqbmUgbWV0aG9kIGZvciBhbnkgd2VpZXJzdHJhc3MgY3VydmUuXG4gKiBUT0RPOiBjaGVjayBpZiB0aGVyZSBpcyBhIHdheSB0byBtZXJnZSB0aGlzIHdpdGggdXZSYXRpbyBpbiBFZHdhcmRzOyBtb3ZlIHRvIG1vZHVsYXIuXG4gKiBiID0gVHJ1ZSBhbmQgeSA9IHNxcnQodSAvIHYpIGlmICh1IC8gdikgaXMgc3F1YXJlIGluIEYsIGFuZFxuICogYiA9IEZhbHNlIGFuZCB5ID0gc3FydChaICogKHUgLyB2KSkgb3RoZXJ3aXNlLlxuICogQHBhcmFtIEZwXG4gKiBAcGFyYW0gWlxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFNXVUZwU3FydFJhdGlvKEZwLCBaKSB7XG4gICAgLy8gR2VuZXJpYyBpbXBsZW1lbnRhdGlvblxuICAgIGNvbnN0IHEgPSBGcC5PUkRFUjtcbiAgICBsZXQgbCA9IF8wbjtcbiAgICBmb3IgKGxldCBvID0gcSAtIF8xbjsgbyAlIF8ybiA9PT0gXzBuOyBvIC89IF8ybilcbiAgICAgICAgbCArPSBfMW47XG4gICAgY29uc3QgYzEgPSBsOyAvLyAxLiBjMSwgdGhlIGxhcmdlc3QgaW50ZWdlciBzdWNoIHRoYXQgMl5jMSBkaXZpZGVzIHEgLSAxLlxuICAgIC8vIFdlIG5lZWQgMm4gKiogYzEgYW5kIDJuICoqIChjMS0xKS4gV2UgY2FuJ3QgdXNlICoqOyBidXQgd2UgY2FuIHVzZSA8PC5cbiAgICAvLyAybiAqKiBjMSA9PSAybiA8PCAoYzEtMSlcbiAgICBjb25zdCBfMm5fcG93X2MxXzEgPSBfMm4gPDwgKGMxIC0gXzFuIC0gXzFuKTtcbiAgICBjb25zdCBfMm5fcG93X2MxID0gXzJuX3Bvd19jMV8xICogXzJuO1xuICAgIGNvbnN0IGMyID0gKHEgLSBfMW4pIC8gXzJuX3Bvd19jMTsgLy8gMi4gYzIgPSAocSAtIDEpIC8gKDJeYzEpICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGMzID0gKGMyIC0gXzFuKSAvIF8ybjsgLy8gMy4gYzMgPSAoYzIgLSAxKSAvIDIgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM0ID0gXzJuX3Bvd19jMSAtIF8xbjsgLy8gNC4gYzQgPSAyXmMxIC0gMSAgICAgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM1ID0gXzJuX3Bvd19jMV8xOyAvLyA1LiBjNSA9IDJeKGMxIC0gMSkgICAgICAgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM2ID0gRnAucG93KFosIGMyKTsgLy8gNi4gYzYgPSBaXmMyXG4gICAgY29uc3QgYzcgPSBGcC5wb3coWiwgKGMyICsgXzFuKSAvIF8ybik7IC8vIDcuIGM3ID0gWl4oKGMyICsgMSkgLyAyKVxuICAgIGxldCBzcXJ0UmF0aW8gPSAodSwgdikgPT4ge1xuICAgICAgICBsZXQgdHYxID0gYzY7IC8vIDEuIHR2MSA9IGM2XG4gICAgICAgIGxldCB0djIgPSBGcC5wb3codiwgYzQpOyAvLyAyLiB0djIgPSB2XmM0XG4gICAgICAgIGxldCB0djMgPSBGcC5zcXIodHYyKTsgLy8gMy4gdHYzID0gdHYyXjJcbiAgICAgICAgdHYzID0gRnAubXVsKHR2Mywgdik7IC8vIDQuIHR2MyA9IHR2MyAqIHZcbiAgICAgICAgbGV0IHR2NSA9IEZwLm11bCh1LCB0djMpOyAvLyA1LiB0djUgPSB1ICogdHYzXG4gICAgICAgIHR2NSA9IEZwLnBvdyh0djUsIGMzKTsgLy8gNi4gdHY1ID0gdHY1XmMzXG4gICAgICAgIHR2NSA9IEZwLm11bCh0djUsIHR2Mik7IC8vIDcuIHR2NSA9IHR2NSAqIHR2MlxuICAgICAgICB0djIgPSBGcC5tdWwodHY1LCB2KTsgLy8gOC4gdHYyID0gdHY1ICogdlxuICAgICAgICB0djMgPSBGcC5tdWwodHY1LCB1KTsgLy8gOS4gdHYzID0gdHY1ICogdVxuICAgICAgICBsZXQgdHY0ID0gRnAubXVsKHR2MywgdHYyKTsgLy8gMTAuIHR2NCA9IHR2MyAqIHR2MlxuICAgICAgICB0djUgPSBGcC5wb3codHY0LCBjNSk7IC8vIDExLiB0djUgPSB0djReYzVcbiAgICAgICAgbGV0IGlzUVIgPSBGcC5lcWwodHY1LCBGcC5PTkUpOyAvLyAxMi4gaXNRUiA9IHR2NSA9PSAxXG4gICAgICAgIHR2MiA9IEZwLm11bCh0djMsIGM3KTsgLy8gMTMuIHR2MiA9IHR2MyAqIGM3XG4gICAgICAgIHR2NSA9IEZwLm11bCh0djQsIHR2MSk7IC8vIDE0LiB0djUgPSB0djQgKiB0djFcbiAgICAgICAgdHYzID0gRnAuY21vdih0djIsIHR2MywgaXNRUik7IC8vIDE1LiB0djMgPSBDTU9WKHR2MiwgdHYzLCBpc1FSKVxuICAgICAgICB0djQgPSBGcC5jbW92KHR2NSwgdHY0LCBpc1FSKTsgLy8gMTYuIHR2NCA9IENNT1YodHY1LCB0djQsIGlzUVIpXG4gICAgICAgIC8vIDE3LiBmb3IgaSBpbiAoYzEsIGMxIC0gMSwgLi4uLCAyKTpcbiAgICAgICAgZm9yIChsZXQgaSA9IGMxOyBpID4gXzFuOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCB0djUgPSBpIC0gXzJuOyAvLyAxOC4gICAgdHY1ID0gaSAtIDJcbiAgICAgICAgICAgIHR2NSA9IF8ybiA8PCAodHY1IC0gXzFuKTsgLy8gMTkuICAgIHR2NSA9IDJedHY1XG4gICAgICAgICAgICBsZXQgdHZ2NSA9IEZwLnBvdyh0djQsIHR2NSk7IC8vIDIwLiAgICB0djUgPSB0djRedHY1XG4gICAgICAgICAgICBjb25zdCBlMSA9IEZwLmVxbCh0dnY1LCBGcC5PTkUpOyAvLyAyMS4gICAgZTEgPSB0djUgPT0gMVxuICAgICAgICAgICAgdHYyID0gRnAubXVsKHR2MywgdHYxKTsgLy8gMjIuICAgIHR2MiA9IHR2MyAqIHR2MVxuICAgICAgICAgICAgdHYxID0gRnAubXVsKHR2MSwgdHYxKTsgLy8gMjMuICAgIHR2MSA9IHR2MSAqIHR2MVxuICAgICAgICAgICAgdHZ2NSA9IEZwLm11bCh0djQsIHR2MSk7IC8vIDI0LiAgICB0djUgPSB0djQgKiB0djFcbiAgICAgICAgICAgIHR2MyA9IEZwLmNtb3YodHYyLCB0djMsIGUxKTsgLy8gMjUuICAgIHR2MyA9IENNT1YodHYyLCB0djMsIGUxKVxuICAgICAgICAgICAgdHY0ID0gRnAuY21vdih0dnY1LCB0djQsIGUxKTsgLy8gMjYuICAgIHR2NCA9IENNT1YodHY1LCB0djQsIGUxKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGlzUVIsIHZhbHVlOiB0djMgfTtcbiAgICB9O1xuICAgIGlmIChGcC5PUkRFUiAlIF80biA9PT0gXzNuKSB7XG4gICAgICAgIC8vIHNxcnRfcmF0aW9fM21vZDQodSwgdilcbiAgICAgICAgY29uc3QgYzEgPSAoRnAuT1JERVIgLSBfM24pIC8gXzRuOyAvLyAxLiBjMSA9IChxIC0gMykgLyA0ICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgICAgICBjb25zdCBjMiA9IEZwLnNxcnQoRnAubmVnKFopKTsgLy8gMi4gYzIgPSBzcXJ0KC1aKVxuICAgICAgICBzcXJ0UmF0aW8gPSAodSwgdikgPT4ge1xuICAgICAgICAgICAgbGV0IHR2MSA9IEZwLnNxcih2KTsgLy8gMS4gdHYxID0gdl4yXG4gICAgICAgICAgICBjb25zdCB0djIgPSBGcC5tdWwodSwgdik7IC8vIDIuIHR2MiA9IHUgKiB2XG4gICAgICAgICAgICB0djEgPSBGcC5tdWwodHYxLCB0djIpOyAvLyAzLiB0djEgPSB0djEgKiB0djJcbiAgICAgICAgICAgIGxldCB5MSA9IEZwLnBvdyh0djEsIGMxKTsgLy8gNC4geTEgPSB0djFeYzFcbiAgICAgICAgICAgIHkxID0gRnAubXVsKHkxLCB0djIpOyAvLyA1LiB5MSA9IHkxICogdHYyXG4gICAgICAgICAgICBjb25zdCB5MiA9IEZwLm11bCh5MSwgYzIpOyAvLyA2LiB5MiA9IHkxICogYzJcbiAgICAgICAgICAgIGNvbnN0IHR2MyA9IEZwLm11bChGcC5zcXIoeTEpLCB2KTsgLy8gNy4gdHYzID0geTFeMjsgOC4gdHYzID0gdHYzICogdlxuICAgICAgICAgICAgY29uc3QgaXNRUiA9IEZwLmVxbCh0djMsIHUpOyAvLyA5LiBpc1FSID0gdHYzID09IHVcbiAgICAgICAgICAgIGxldCB5ID0gRnAuY21vdih5MiwgeTEsIGlzUVIpOyAvLyAxMC4geSA9IENNT1YoeTIsIHkxLCBpc1FSKVxuICAgICAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogaXNRUiwgdmFsdWU6IHkgfTsgLy8gMTEuIHJldHVybiAoaXNRUiwgeSkgaXNRUiA/IHkgOiB5KmMyXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIE5vIGN1cnZlcyB1c2VzIHRoYXRcbiAgICAvLyBpZiAoRnAuT1JERVIgJSBfOG4gPT09IF81bikgLy8gc3FydF9yYXRpb181bW9kOFxuICAgIHJldHVybiBzcXJ0UmF0aW87XG59XG4vKipcbiAqIFNpbXBsaWZpZWQgU2hhbGx1ZS12YW4gZGUgV29lc3Rpam5lLVVsYXMgTWV0aG9kXG4gKiBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTYuNi4yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBUb0N1cnZlU2ltcGxlU1dVKEZwLCBvcHRzKSB7XG4gICAgbW9kLnZhbGlkYXRlRmllbGQoRnApO1xuICAgIGlmICghRnAuaXNWYWxpZChvcHRzLkEpIHx8ICFGcC5pc1ZhbGlkKG9wdHMuQikgfHwgIUZwLmlzVmFsaWQob3B0cy5aKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXBUb0N1cnZlU2ltcGxlU1dVOiBpbnZhbGlkIG9wdHMnKTtcbiAgICBjb25zdCBzcXJ0UmF0aW8gPSBTV1VGcFNxcnRSYXRpbyhGcCwgb3B0cy5aKTtcbiAgICBpZiAoIUZwLmlzT2RkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZwLmlzT2RkIGlzIG5vdCBpbXBsZW1lbnRlZCEnKTtcbiAgICAvLyBJbnB1dDogdSwgYW4gZWxlbWVudCBvZiBGLlxuICAgIC8vIE91dHB1dDogKHgsIHkpLCBhIHBvaW50IG9uIEUuXG4gICAgcmV0dXJuICh1KSA9PiB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBsZXQgdHYxLCB0djIsIHR2MywgdHY0LCB0djUsIHR2NiwgeCwgeTtcbiAgICAgICAgdHYxID0gRnAuc3FyKHUpOyAvLyAxLiAgdHYxID0gdV4yXG4gICAgICAgIHR2MSA9IEZwLm11bCh0djEsIG9wdHMuWik7IC8vIDIuICB0djEgPSBaICogdHYxXG4gICAgICAgIHR2MiA9IEZwLnNxcih0djEpOyAvLyAzLiAgdHYyID0gdHYxXjJcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHYxKTsgLy8gNC4gIHR2MiA9IHR2MiArIHR2MVxuICAgICAgICB0djMgPSBGcC5hZGQodHYyLCBGcC5PTkUpOyAvLyA1LiAgdHYzID0gdHYyICsgMVxuICAgICAgICB0djMgPSBGcC5tdWwodHYzLCBvcHRzLkIpOyAvLyA2LiAgdHYzID0gQiAqIHR2M1xuICAgICAgICB0djQgPSBGcC5jbW92KG9wdHMuWiwgRnAubmVnKHR2MiksICFGcC5lcWwodHYyLCBGcC5aRVJPKSk7IC8vIDcuICB0djQgPSBDTU9WKFosIC10djIsIHR2MiAhPSAwKVxuICAgICAgICB0djQgPSBGcC5tdWwodHY0LCBvcHRzLkEpOyAvLyA4LiAgdHY0ID0gQSAqIHR2NFxuICAgICAgICB0djIgPSBGcC5zcXIodHYzKTsgLy8gOS4gIHR2MiA9IHR2M14yXG4gICAgICAgIHR2NiA9IEZwLnNxcih0djQpOyAvLyAxMC4gdHY2ID0gdHY0XjJcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2Niwgb3B0cy5BKTsgLy8gMTEuIHR2NSA9IEEgKiB0djZcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHY1KTsgLy8gMTIuIHR2MiA9IHR2MiArIHR2NVxuICAgICAgICB0djIgPSBGcC5tdWwodHYyLCB0djMpOyAvLyAxMy4gdHYyID0gdHYyICogdHYzXG4gICAgICAgIHR2NiA9IEZwLm11bCh0djYsIHR2NCk7IC8vIDE0LiB0djYgPSB0djYgKiB0djRcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2Niwgb3B0cy5CKTsgLy8gMTUuIHR2NSA9IEIgKiB0djZcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHY1KTsgLy8gMTYuIHR2MiA9IHR2MiArIHR2NVxuICAgICAgICB4ID0gRnAubXVsKHR2MSwgdHYzKTsgLy8gMTcuICAgeCA9IHR2MSAqIHR2M1xuICAgICAgICBjb25zdCB7IGlzVmFsaWQsIHZhbHVlIH0gPSBzcXJ0UmF0aW8odHYyLCB0djYpOyAvLyAxOC4gKGlzX2d4MV9zcXVhcmUsIHkxKSA9IHNxcnRfcmF0aW8odHYyLCB0djYpXG4gICAgICAgIHkgPSBGcC5tdWwodHYxLCB1KTsgLy8gMTkuICAgeSA9IHR2MSAqIHUgIC0+IFogKiB1XjMgKiB5MVxuICAgICAgICB5ID0gRnAubXVsKHksIHZhbHVlKTsgLy8gMjAuICAgeSA9IHkgKiB5MVxuICAgICAgICB4ID0gRnAuY21vdih4LCB0djMsIGlzVmFsaWQpOyAvLyAyMS4gICB4ID0gQ01PVih4LCB0djMsIGlzX2d4MV9zcXVhcmUpXG4gICAgICAgIHkgPSBGcC5jbW92KHksIHZhbHVlLCBpc1ZhbGlkKTsgLy8gMjIuICAgeSA9IENNT1YoeSwgeTEsIGlzX2d4MV9zcXVhcmUpXG4gICAgICAgIGNvbnN0IGUxID0gRnAuaXNPZGQodSkgPT09IEZwLmlzT2RkKHkpOyAvLyAyMy4gIGUxID0gc2duMCh1KSA9PSBzZ24wKHkpXG4gICAgICAgIHkgPSBGcC5jbW92KEZwLm5lZyh5KSwgeSwgZTEpOyAvLyAyNC4gICB5ID0gQ01PVigteSwgeSwgZTEpXG4gICAgICAgIHggPSBGcC5kaXYoeCwgdHY0KTsgLy8gMjUuICAgeCA9IHggLyB0djRcbiAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13ZWllcnN0cmFzcy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/weierstrass.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/secp256k1.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/secp256k1.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encodeToCurve: () => (/* binding */ encodeToCurve),\n/* harmony export */   hashToCurve: () => (/* binding */ hashToCurve),\n/* harmony export */   schnorr: () => (/* binding */ schnorr),\n/* harmony export */   secp256k1: () => (/* binding */ secp256k1)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract/modular.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/* harmony import */ var _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./abstract/utils.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./abstract/hash-to-curve.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/hash-to-curve.js\");\n/* harmony import */ var _shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_shortw_utils.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/_shortw_utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\n\n\n\n\n\nconst secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');\nconst secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst divNearest = (a, b) => (a + b / _2n) / b;\n/**\n * √n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */\nfunction sqrtMod(y) {\n    const P = secp256k1P;\n    // prettier-ignore\n    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n    // prettier-ignore\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n    const b2 = (y * y * y) % P; // x^3, 11\n    const b3 = (b2 * b2 * y) % P; // x^7\n    const b6 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b3, _3n, P) * b3) % P;\n    const b9 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b6, _3n, P) * b3) % P;\n    const b11 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b9, _2n, P) * b2) % P;\n    const b22 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b11, _11n, P) * b11) % P;\n    const b44 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b22, _22n, P) * b22) % P;\n    const b88 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b44, _44n, P) * b44) % P;\n    const b176 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b88, _88n, P) * b88) % P;\n    const b220 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b176, _44n, P) * b44) % P;\n    const b223 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b220, _3n, P) * b3) % P;\n    const t1 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b223, _23n, P) * b22) % P;\n    const t2 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(t1, _6n, P) * b2) % P;\n    const root = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(t2, _2n, P);\n    if (!Fp.eql(Fp.sqr(root), y))\n        throw new Error('Cannot find square root');\n    return root;\n}\nconst Fp = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field)(secp256k1P, undefined, undefined, { sqrt: sqrtMod });\nconst secp256k1 = (0,_shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__.createCurve)({\n    a: BigInt(0),\n    b: BigInt(7),\n    Fp,\n    n: secp256k1N,\n    // Base point (x, y) aka generator point\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    h: BigInt(1),\n    lowS: true,\n    /**\n     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066\n     */\n    endo: {\n        beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n        splitScalar: (k) => {\n            const n = secp256k1N;\n            const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n            const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n            const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n            const b2 = a1;\n            const POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)\n            const c1 = divNearest(b2 * k, n);\n            const c2 = divNearest(-b1 * k, n);\n            let k1 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(k - c1 * a1 - c2 * a2, n);\n            let k2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(-c1 * b1 - c2 * b2, n);\n            const k1neg = k1 > POW_2_128;\n            const k2neg = k2 > POW_2_128;\n            if (k1neg)\n                k1 = n - k1;\n            if (k2neg)\n                k2 = n - k2;\n            if (k1 > POW_2_128 || k2 > POW_2_128) {\n                throw new Error('splitScalar: Endomorphism failed, k=' + k);\n            }\n            return { k1neg, k1, k2neg, k2 };\n        },\n    },\n}, _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256);\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\nconst _0n = BigInt(0);\nconst fe = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1P;\nconst ge = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1N;\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\nconst TAGGED_HASH_PREFIXES = {};\nfunction taggedHash(tag, ...messages) {\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n        const tagH = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256)(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n        tagP = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(tagH, tagH);\n        TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    return (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256)((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(tagP, ...messages));\n}\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point) => point.toRawBytes(true).slice(1);\nconst numTo32b = (n) => (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.numberToBytesBE)(n, 32);\nconst modP = (x) => (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x, secp256k1P);\nconst modN = (x) => (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x, secp256k1N);\nconst Point = secp256k1.ProjectivePoint;\nconst GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv) {\n    let d_ = secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\n    let p = Point.fromPrivateKey(d_); // P = d'⋅G; 0 < d' < n check is done inside\n    const scalar = p.hasEvenY() ? d_ : modN(-d_);\n    return { scalar: scalar, bytes: pointToBytes(p) };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */\nfunction lift_x(x) {\n    if (!fe(x))\n        throw new Error('bad x: need 0 < x < p'); // Fail if x ≥ p.\n    const xx = modP(x * x);\n    const c = modP(xx * x + BigInt(7)); // Let c = x³ + 7 mod p.\n    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n    if (y % _2n !== _0n)\n        y = modP(-y); // Return the unique point P such that x(P) = x and\n    const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n    p.assertValidity();\n    return p;\n}\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */\nfunction challenge(...args) {\n    return modN((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(taggedHash('BIP0340/challenge', ...args)));\n}\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */\nfunction schnorrGetPublicKey(privateKey) {\n    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'≥n. Ret bytes(d'⋅G)\n}\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */\nfunction schnorrSign(message, privateKey, auxRand = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__.randomBytes)(32)) {\n    const m = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('message', message);\n    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\n    const a = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array\n    const t = numTo32b(d ^ (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n    const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n    const k_ = modN((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(rand)); // Let k' = int(rand) mod n\n    if (k_ === _0n)\n        throw new Error('sign failed: k is zero'); // Fail if k' = 0.\n    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'⋅G.\n    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n    sig.set(rx, 0);\n    sig.set(numTo32b(modN(k + e * d)), 32);\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n    if (!schnorrVerify(sig, m, px))\n        throw new Error('sign: Invalid signature produced');\n    return sig;\n}\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */\nfunction schnorrVerify(signature, message, publicKey) {\n    const sig = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('signature', signature, 64);\n    const m = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('message', message);\n    const pub = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('publicKey', publicKey, 32);\n    try {\n        const P = lift_x((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(pub)); // P = lift_x(int(pk)); fail if that fails\n        const r = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r ≥ p.\n        if (!fe(r))\n            return false;\n        const s = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s ≥ n.\n        if (!ge(s))\n            return false;\n        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n        const R = GmulAdd(P, s, modN(-e)); // R = s⋅G - e⋅P\n        if (!R || !R.hasEvenY() || R.toAffine().x !== r)\n            return false; // -eP == (n-e)P\n        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R) ≠ r.\n    }\n    catch (error) {\n        return false;\n    }\n}\nconst schnorr = /* @__PURE__ */ (() => ({\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n    utils: {\n        randomPrivateKey: secp256k1.utils.randomPrivateKey,\n        lift_x,\n        pointToBytes,\n        numberToBytesBE: _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.numberToBytesBE,\n        bytesToNumberBE: _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE,\n        taggedHash,\n        mod: _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod,\n    },\n}))();\nconst isoMap = /* @__PURE__ */ (() => (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.isogenyMap)(Fp, [\n    // xNum\n    [\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',\n        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',\n        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',\n    ],\n    // xDen\n    [\n        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',\n        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n    // yNum\n    [\n        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',\n        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',\n        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',\n        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',\n    ],\n    // yDen\n    [\n        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',\n        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',\n        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n].map((i) => i.map((j) => BigInt(j)))))();\nconst mapSWU = /* @__PURE__ */ (() => (0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_6__.mapToCurveSimpleSWU)(Fp, {\n    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),\n    B: BigInt('1771'),\n    Z: Fp.create(BigInt('-11')),\n}))();\nconst htf = /* @__PURE__ */ (() => (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.createHasher)(secp256k1.ProjectivePoint, (scalars) => {\n    const { x, y } = mapSWU(Fp.create(scalars[0]));\n    return isoMap(x, y);\n}, {\n    DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',\n    encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',\n    p: Fp.ORDER,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256,\n}))();\nconst hashToCurve = /* @__PURE__ */ (() => htf.hashToCurve)();\nconst encodeToCurve = /* @__PURE__ */ (() => htf.encodeToCurve)();\n//# sourceMappingURL=secp256k1.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vc2VjcDI1NmsxLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDOEM7QUFDSTtBQUNPO0FBQ087QUFDaUM7QUFDMUI7QUFDdEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLGtDQUFrQztBQUNsQyxnQkFBZ0IsMERBQUk7QUFDcEIsZ0JBQWdCLDBEQUFJO0FBQ3BCLGlCQUFpQiwwREFBSTtBQUNyQixpQkFBaUIsMERBQUk7QUFDckIsaUJBQWlCLDBEQUFJO0FBQ3JCLGlCQUFpQiwwREFBSTtBQUNyQixrQkFBa0IsMERBQUk7QUFDdEIsa0JBQWtCLDBEQUFJO0FBQ3RCLGtCQUFrQiwwREFBSTtBQUN0QixnQkFBZ0IsMERBQUk7QUFDcEIsZ0JBQWdCLDBEQUFJO0FBQ3BCLGlCQUFpQiwwREFBSTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMkRBQUsscUNBQXFDLGVBQWU7QUFDN0Qsa0JBQWtCLDZEQUFXO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBLHFCQUFxQix5REFBRztBQUN4QixxQkFBcUIseURBQUc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFNBQVM7QUFDVCxLQUFLO0FBQ0wsQ0FBQyxFQUFFLHdEQUFNO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNERBQU07QUFDM0IsZUFBZSwrREFBVztBQUMxQjtBQUNBO0FBQ0EsV0FBVyw0REFBTSxDQUFDLCtEQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtRUFBZTtBQUN2QyxvQkFBb0IseURBQUc7QUFDdkIsb0JBQW9CLHlEQUFHO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELHNDQUFzQyxhQUFhO0FBQ25EO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0Esd0NBQXdDO0FBQ3hDLHdCQUF3QjtBQUN4QjtBQUNBLHNCQUFzQjtBQUN0QixvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGdFQUFXO0FBQy9ELGNBQWMsK0RBQVc7QUFDekIsWUFBWSx1QkFBdUIsbUNBQW1DO0FBQ3RFLGNBQWMsK0RBQVcsMEJBQTBCO0FBQ25ELDJCQUEyQixtRUFBZSxpQ0FBaUM7QUFDM0Usd0RBQXdEO0FBQ3hELG9CQUFvQixtRUFBZSxTQUFTO0FBQzVDO0FBQ0EsbURBQW1EO0FBQ25ELFlBQVksdUJBQXVCLDJCQUEyQjtBQUM5RCxvQ0FBb0M7QUFDcEMsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrREFBVztBQUMzQixjQUFjLCtEQUFXO0FBQ3pCLGdCQUFnQiwrREFBVztBQUMzQjtBQUNBLHlCQUF5QixtRUFBZSxRQUFRLHdCQUF3QjtBQUN4RSxrQkFBa0IsbUVBQWUsdUJBQXVCLDJCQUEyQjtBQUNuRjtBQUNBO0FBQ0Esa0JBQWtCLG1FQUFlLHdCQUF3Qiw0QkFBNEI7QUFDckY7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RCwyQ0FBMkM7QUFDM0M7QUFDQSwwQkFBMEI7QUFDMUIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLHVCQUF1QjtBQUN2QjtBQUNBLFdBQVc7QUFDWCxLQUFLO0FBQ0wsQ0FBQztBQUNELHNDQUFzQyxzRUFBVTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyw2RUFBbUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG1DQUFtQyx3RUFBWTtBQUMvQyxZQUFZLE9BQU87QUFDbkI7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx3REFBTTtBQUNoQixDQUFDO0FBQ007QUFDQTtBQUNQIiwic291cmNlcyI6WyIvaG9tZS9sZmcvR2l0L01hZHRyaXBzL25vZGVfbW9kdWxlcy9Abm9zdHItZGV2LWtpdC9uZGsvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9zZWNwMjU2azEuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9zaGEyNTYnO1xuaW1wb3J0IHsgcmFuZG9tQnl0ZXMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3V0aWxzJztcbmltcG9ydCB7IEZpZWxkLCBtb2QsIHBvdzIgfSBmcm9tICcuL2Fic3RyYWN0L21vZHVsYXIuanMnO1xuaW1wb3J0IHsgbWFwVG9DdXJ2ZVNpbXBsZVNXVSB9IGZyb20gJy4vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanMnO1xuaW1wb3J0IHsgYnl0ZXNUb051bWJlckJFLCBjb25jYXRCeXRlcywgZW5zdXJlQnl0ZXMsIG51bWJlclRvQnl0ZXNCRSB9IGZyb20gJy4vYWJzdHJhY3QvdXRpbHMuanMnO1xuaW1wb3J0IHsgY3JlYXRlSGFzaGVyLCBpc29nZW55TWFwIH0gZnJvbSAnLi9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzJztcbmltcG9ydCB7IGNyZWF0ZUN1cnZlIH0gZnJvbSAnLi9fc2hvcnR3X3V0aWxzLmpzJztcbmNvbnN0IHNlY3AyNTZrMVAgPSBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmVmZmZmZmMyZicpO1xuY29uc3Qgc2VjcDI1NmsxTiA9IEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWJhYWVkY2U2YWY0OGEwM2JiZmQyNWU4Y2QwMzY0MTQxJyk7XG5jb25zdCBfMW4gPSBCaWdJbnQoMSk7XG5jb25zdCBfMm4gPSBCaWdJbnQoMik7XG5jb25zdCBkaXZOZWFyZXN0ID0gKGEsIGIpID0+IChhICsgYiAvIF8ybikgLyBiO1xuLyoqXG4gKiDiiJpuID0gbl4oKHArMSkvNCkgZm9yIGZpZWxkcyBwID0gMyBtb2QgNC4gV2UgdW53cmFwIHRoZSBsb29wIGFuZCBtdWx0aXBseSBiaXQtYnktYml0LlxuICogKFArMW4vNG4pLnRvU3RyaW5nKDIpIHdvdWxkIHByb2R1Y2UgYml0cyBbMjIzeCAxLCAwLCAyMnggMSwgNHggMCwgMTEsIDAwXVxuICovXG5mdW5jdGlvbiBzcXJ0TW9kKHkpIHtcbiAgICBjb25zdCBQID0gc2VjcDI1NmsxUDtcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBjb25zdCBfM24gPSBCaWdJbnQoMyksIF82biA9IEJpZ0ludCg2KSwgXzExbiA9IEJpZ0ludCgxMSksIF8yMm4gPSBCaWdJbnQoMjIpO1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGNvbnN0IF8yM24gPSBCaWdJbnQoMjMpLCBfNDRuID0gQmlnSW50KDQ0KSwgXzg4biA9IEJpZ0ludCg4OCk7XG4gICAgY29uc3QgYjIgPSAoeSAqIHkgKiB5KSAlIFA7IC8vIHheMywgMTFcbiAgICBjb25zdCBiMyA9IChiMiAqIGIyICogeSkgJSBQOyAvLyB4XjdcbiAgICBjb25zdCBiNiA9IChwb3cyKGIzLCBfM24sIFApICogYjMpICUgUDtcbiAgICBjb25zdCBiOSA9IChwb3cyKGI2LCBfM24sIFApICogYjMpICUgUDtcbiAgICBjb25zdCBiMTEgPSAocG93MihiOSwgXzJuLCBQKSAqIGIyKSAlIFA7XG4gICAgY29uc3QgYjIyID0gKHBvdzIoYjExLCBfMTFuLCBQKSAqIGIxMSkgJSBQO1xuICAgIGNvbnN0IGI0NCA9IChwb3cyKGIyMiwgXzIybiwgUCkgKiBiMjIpICUgUDtcbiAgICBjb25zdCBiODggPSAocG93MihiNDQsIF80NG4sIFApICogYjQ0KSAlIFA7XG4gICAgY29uc3QgYjE3NiA9IChwb3cyKGI4OCwgXzg4biwgUCkgKiBiODgpICUgUDtcbiAgICBjb25zdCBiMjIwID0gKHBvdzIoYjE3NiwgXzQ0biwgUCkgKiBiNDQpICUgUDtcbiAgICBjb25zdCBiMjIzID0gKHBvdzIoYjIyMCwgXzNuLCBQKSAqIGIzKSAlIFA7XG4gICAgY29uc3QgdDEgPSAocG93MihiMjIzLCBfMjNuLCBQKSAqIGIyMikgJSBQO1xuICAgIGNvbnN0IHQyID0gKHBvdzIodDEsIF82biwgUCkgKiBiMikgJSBQO1xuICAgIGNvbnN0IHJvb3QgPSBwb3cyKHQyLCBfMm4sIFApO1xuICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgeSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICByZXR1cm4gcm9vdDtcbn1cbmNvbnN0IEZwID0gRmllbGQoc2VjcDI1NmsxUCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHsgc3FydDogc3FydE1vZCB9KTtcbmV4cG9ydCBjb25zdCBzZWNwMjU2azEgPSBjcmVhdGVDdXJ2ZSh7XG4gICAgYTogQmlnSW50KDApLFxuICAgIGI6IEJpZ0ludCg3KSxcbiAgICBGcCxcbiAgICBuOiBzZWNwMjU2azFOLFxuICAgIC8vIEJhc2UgcG9pbnQgKHgsIHkpIGFrYSBnZW5lcmF0b3IgcG9pbnRcbiAgICBHeDogQmlnSW50KCc1NTA2NjI2MzAyMjI3NzM0MzY2OTU3ODcxODg5NTE2ODUzNDMyNjI1MDYwMzQ1Mzc3NzU5NDE3NTUwMDE4NzM2MDM4OTExNjcyOTI0MCcpLFxuICAgIEd5OiBCaWdJbnQoJzMyNjcwNTEwMDIwNzU4ODE2OTc4MDgzMDg1MTMwNTA3MDQzMTg0NDcxMjczMzgwNjU5MjQzMjc1OTM4OTA0MzM1NzU3MzM3NDgyNDI0JyksXG4gICAgaDogQmlnSW50KDEpLFxuICAgIGxvd1M6IHRydWUsXG4gICAgLyoqXG4gICAgICogc2VjcDI1NmsxIGJlbG9uZ3MgdG8gS29ibGl0eiBjdXJ2ZXM6IGl0IGhhcyBlZmZpY2llbnRseSBjb21wdXRhYmxlIGVuZG9tb3JwaGlzbS5cbiAgICAgKiBFbmRvbW9ycGhpc20gdXNlcyAyeCBsZXNzIFJBTSwgc3BlZWRzIHVwIHByZWNvbXB1dGF0aW9uIGJ5IDJ4IGFuZCBFQ0RIIC8ga2V5IHJlY292ZXJ5IGJ5IDIwJS5cbiAgICAgKiBGb3IgcHJlY29tcHV0ZWQgd05BRiBpdCB0cmFkZXMgb2ZmIDEvMiBpbml0IHRpbWUgJiAxLzMgcmFtIGZvciAyMCUgcGVyZiBoaXQuXG4gICAgICogRXhwbGFuYXRpb246IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3BhdWxtaWxsci9lYjY3MDgwNjc5M2U4NGRmNjI4YTdjNDM0YTg3MzA2NlxuICAgICAqL1xuICAgIGVuZG86IHtcbiAgICAgICAgYmV0YTogQmlnSW50KCcweDdhZTk2YTJiNjU3YzA3MTA2ZTY0NDc5ZWFjMzQzNGU5OWNmMDQ5NzUxMmY1ODk5NWMxMzk2YzI4NzE5NTAxZWUnKSxcbiAgICAgICAgc3BsaXRTY2FsYXI6IChrKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuID0gc2VjcDI1NmsxTjtcbiAgICAgICAgICAgIGNvbnN0IGExID0gQmlnSW50KCcweDMwODZkMjIxYTdkNDZiY2RlODZjOTBlNDkyODRlYjE1Jyk7XG4gICAgICAgICAgICBjb25zdCBiMSA9IC1fMW4gKiBCaWdJbnQoJzB4ZTQ0MzdlZDYwMTBlODgyODZmNTQ3ZmE5MGFiZmU0YzMnKTtcbiAgICAgICAgICAgIGNvbnN0IGEyID0gQmlnSW50KCcweDExNGNhNTBmN2E4ZTJmM2Y2NTdjMTEwOGQ5ZDQ0Y2ZkOCcpO1xuICAgICAgICAgICAgY29uc3QgYjIgPSBhMTtcbiAgICAgICAgICAgIGNvbnN0IFBPV18yXzEyOCA9IEJpZ0ludCgnMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnKTsgLy8gKDJuKioxMjhuKS50b1N0cmluZygxNilcbiAgICAgICAgICAgIGNvbnN0IGMxID0gZGl2TmVhcmVzdChiMiAqIGssIG4pO1xuICAgICAgICAgICAgY29uc3QgYzIgPSBkaXZOZWFyZXN0KC1iMSAqIGssIG4pO1xuICAgICAgICAgICAgbGV0IGsxID0gbW9kKGsgLSBjMSAqIGExIC0gYzIgKiBhMiwgbik7XG4gICAgICAgICAgICBsZXQgazIgPSBtb2QoLWMxICogYjEgLSBjMiAqIGIyLCBuKTtcbiAgICAgICAgICAgIGNvbnN0IGsxbmVnID0gazEgPiBQT1dfMl8xMjg7XG4gICAgICAgICAgICBjb25zdCBrMm5lZyA9IGsyID4gUE9XXzJfMTI4O1xuICAgICAgICAgICAgaWYgKGsxbmVnKVxuICAgICAgICAgICAgICAgIGsxID0gbiAtIGsxO1xuICAgICAgICAgICAgaWYgKGsybmVnKVxuICAgICAgICAgICAgICAgIGsyID0gbiAtIGsyO1xuICAgICAgICAgICAgaWYgKGsxID4gUE9XXzJfMTI4IHx8IGsyID4gUE9XXzJfMTI4KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzcGxpdFNjYWxhcjogRW5kb21vcnBoaXNtIGZhaWxlZCwgaz0nICsgayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBrMW5lZywgazEsIGsybmVnLCBrMiB9O1xuICAgICAgICB9LFxuICAgIH0sXG59LCBzaGEyNTYpO1xuLy8gU2Nobm9yciBzaWduYXR1cmVzIGFyZSBzdXBlcmlvciB0byBFQ0RTQSBmcm9tIGFib3ZlLiBCZWxvdyBpcyBTY2hub3JyLXNwZWNpZmljIEJJUDAzNDAgY29kZS5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpcHMvYmxvYi9tYXN0ZXIvYmlwLTAzNDAubWVkaWF3aWtpXG5jb25zdCBfMG4gPSBCaWdJbnQoMCk7XG5jb25zdCBmZSA9ICh4KSA9PiB0eXBlb2YgeCA9PT0gJ2JpZ2ludCcgJiYgXzBuIDwgeCAmJiB4IDwgc2VjcDI1NmsxUDtcbmNvbnN0IGdlID0gKHgpID0+IHR5cGVvZiB4ID09PSAnYmlnaW50JyAmJiBfMG4gPCB4ICYmIHggPCBzZWNwMjU2azFOO1xuLyoqIEFuIG9iamVjdCBtYXBwaW5nIHRhZ3MgdG8gdGhlaXIgdGFnZ2VkIGhhc2ggcHJlZml4IG9mIFtTSEEyNTYodGFnKSB8IFNIQTI1Nih0YWcpXSAqL1xuY29uc3QgVEFHR0VEX0hBU0hfUFJFRklYRVMgPSB7fTtcbmZ1bmN0aW9uIHRhZ2dlZEhhc2godGFnLCAuLi5tZXNzYWdlcykge1xuICAgIGxldCB0YWdQID0gVEFHR0VEX0hBU0hfUFJFRklYRVNbdGFnXTtcbiAgICBpZiAodGFnUCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHRhZ0ggPSBzaGEyNTYoVWludDhBcnJheS5mcm9tKHRhZywgKGMpID0+IGMuY2hhckNvZGVBdCgwKSkpO1xuICAgICAgICB0YWdQID0gY29uY2F0Qnl0ZXModGFnSCwgdGFnSCk7XG4gICAgICAgIFRBR0dFRF9IQVNIX1BSRUZJWEVTW3RhZ10gPSB0YWdQO1xuICAgIH1cbiAgICByZXR1cm4gc2hhMjU2KGNvbmNhdEJ5dGVzKHRhZ1AsIC4uLm1lc3NhZ2VzKSk7XG59XG4vLyBFQ0RTQSBjb21wYWN0IHBvaW50cyBhcmUgMzMtYnl0ZS4gU2Nobm9yciBpcyAzMjogd2Ugc3RyaXAgZmlyc3QgYnl0ZSAweDAyIG9yIDB4MDNcbmNvbnN0IHBvaW50VG9CeXRlcyA9IChwb2ludCkgPT4gcG9pbnQudG9SYXdCeXRlcyh0cnVlKS5zbGljZSgxKTtcbmNvbnN0IG51bVRvMzJiID0gKG4pID0+IG51bWJlclRvQnl0ZXNCRShuLCAzMik7XG5jb25zdCBtb2RQID0gKHgpID0+IG1vZCh4LCBzZWNwMjU2azFQKTtcbmNvbnN0IG1vZE4gPSAoeCkgPT4gbW9kKHgsIHNlY3AyNTZrMU4pO1xuY29uc3QgUG9pbnQgPSBzZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50O1xuY29uc3QgR211bEFkZCA9IChRLCBhLCBiKSA9PiBQb2ludC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKFEsIGEsIGIpO1xuLy8gQ2FsY3VsYXRlIHBvaW50LCBzY2FsYXIgYW5kIGJ5dGVzXG5mdW5jdGlvbiBzY2hub3JyR2V0RXh0UHViS2V5KHByaXYpIHtcbiAgICBsZXQgZF8gPSBzZWNwMjU2azEudXRpbHMubm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2KTsgLy8gc2FtZSBtZXRob2QgZXhlY3V0ZWQgaW4gZnJvbVByaXZhdGVLZXlcbiAgICBsZXQgcCA9IFBvaW50LmZyb21Qcml2YXRlS2V5KGRfKTsgLy8gUCA9IGQn4ouFRzsgMCA8IGQnIDwgbiBjaGVjayBpcyBkb25lIGluc2lkZVxuICAgIGNvbnN0IHNjYWxhciA9IHAuaGFzRXZlblkoKSA/IGRfIDogbW9kTigtZF8pO1xuICAgIHJldHVybiB7IHNjYWxhcjogc2NhbGFyLCBieXRlczogcG9pbnRUb0J5dGVzKHApIH07XG59XG4vKipcbiAqIGxpZnRfeCBmcm9tIEJJUDM0MC4gQ29udmVydCAzMi1ieXRlIHggY29vcmRpbmF0ZSB0byBlbGxpcHRpYyBjdXJ2ZSBwb2ludC5cbiAqIEByZXR1cm5zIHZhbGlkIHBvaW50IGNoZWNrZWQgZm9yIGJlaW5nIG9uLWN1cnZlXG4gKi9cbmZ1bmN0aW9uIGxpZnRfeCh4KSB7XG4gICAgaWYgKCFmZSh4KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgeDogbmVlZCAwIDwgeCA8IHAnKTsgLy8gRmFpbCBpZiB4IOKJpSBwLlxuICAgIGNvbnN0IHh4ID0gbW9kUCh4ICogeCk7XG4gICAgY29uc3QgYyA9IG1vZFAoeHggKiB4ICsgQmlnSW50KDcpKTsgLy8gTGV0IGMgPSB4wrMgKyA3IG1vZCBwLlxuICAgIGxldCB5ID0gc3FydE1vZChjKTsgLy8gTGV0IHkgPSBjXihwKzEpLzQgbW9kIHAuXG4gICAgaWYgKHkgJSBfMm4gIT09IF8wbilcbiAgICAgICAgeSA9IG1vZFAoLXkpOyAvLyBSZXR1cm4gdGhlIHVuaXF1ZSBwb2ludCBQIHN1Y2ggdGhhdCB4KFApID0geCBhbmRcbiAgICBjb25zdCBwID0gbmV3IFBvaW50KHgsIHksIF8xbik7IC8vIHkoUCkgPSB5IGlmIHkgbW9kIDIgPSAwIG9yIHkoUCkgPSBwLXkgb3RoZXJ3aXNlLlxuICAgIHAuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICByZXR1cm4gcDtcbn1cbi8qKlxuICogQ3JlYXRlIHRhZ2dlZCBoYXNoLCBjb252ZXJ0IGl0IHRvIGJpZ2ludCwgcmVkdWNlIG1vZHVsby1uLlxuICovXG5mdW5jdGlvbiBjaGFsbGVuZ2UoLi4uYXJncykge1xuICAgIHJldHVybiBtb2ROKGJ5dGVzVG9OdW1iZXJCRSh0YWdnZWRIYXNoKCdCSVAwMzQwL2NoYWxsZW5nZScsIC4uLmFyZ3MpKSk7XG59XG4vKipcbiAqIFNjaG5vcnIgcHVibGljIGtleSBpcyBqdXN0IGB4YCBjb29yZGluYXRlIG9mIFBvaW50IGFzIHBlciBCSVAzNDAuXG4gKi9cbmZ1bmN0aW9uIHNjaG5vcnJHZXRQdWJsaWNLZXkocHJpdmF0ZUtleSkge1xuICAgIHJldHVybiBzY2hub3JyR2V0RXh0UHViS2V5KHByaXZhdGVLZXkpLmJ5dGVzOyAvLyBkJz1pbnQoc2spLiBGYWlsIGlmIGQnPTAgb3IgZCfiiaVuLiBSZXQgYnl0ZXMoZCfii4VHKVxufVxuLyoqXG4gKiBDcmVhdGVzIFNjaG5vcnIgc2lnbmF0dXJlIGFzIHBlciBCSVAzNDAuIFZlcmlmaWVzIGl0c2VsZiBiZWZvcmUgcmV0dXJuaW5nIGFueXRoaW5nLlxuICogYXV4UmFuZCBpcyBvcHRpb25hbCBhbmQgaXMgbm90IHRoZSBzb2xlIHNvdXJjZSBvZiBrIGdlbmVyYXRpb246IGJhZCBDU1BSTkcgd29uJ3QgYmUgZGFuZ2Vyb3VzLlxuICovXG5mdW5jdGlvbiBzY2hub3JyU2lnbihtZXNzYWdlLCBwcml2YXRlS2V5LCBhdXhSYW5kID0gcmFuZG9tQnl0ZXMoMzIpKSB7XG4gICAgY29uc3QgbSA9IGVuc3VyZUJ5dGVzKCdtZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgY29uc3QgeyBieXRlczogcHgsIHNjYWxhcjogZCB9ID0gc2Nobm9yckdldEV4dFB1YktleShwcml2YXRlS2V5KTsgLy8gY2hlY2tzIGZvciBpc1dpdGhpbkN1cnZlT3JkZXJcbiAgICBjb25zdCBhID0gZW5zdXJlQnl0ZXMoJ2F1eFJhbmQnLCBhdXhSYW5kLCAzMik7IC8vIEF1eGlsaWFyeSByYW5kb20gZGF0YSBhOiBhIDMyLWJ5dGUgYXJyYXlcbiAgICBjb25zdCB0ID0gbnVtVG8zMmIoZCBeIGJ5dGVzVG9OdW1iZXJCRSh0YWdnZWRIYXNoKCdCSVAwMzQwL2F1eCcsIGEpKSk7IC8vIExldCB0IGJlIHRoZSBieXRlLXdpc2UgeG9yIG9mIGJ5dGVzKGQpIGFuZCBoYXNoL2F1eChhKVxuICAgIGNvbnN0IHJhbmQgPSB0YWdnZWRIYXNoKCdCSVAwMzQwL25vbmNlJywgdCwgcHgsIG0pOyAvLyBMZXQgcmFuZCA9IGhhc2gvbm9uY2UodCB8fCBieXRlcyhQKSB8fCBtKVxuICAgIGNvbnN0IGtfID0gbW9kTihieXRlc1RvTnVtYmVyQkUocmFuZCkpOyAvLyBMZXQgaycgPSBpbnQocmFuZCkgbW9kIG5cbiAgICBpZiAoa18gPT09IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduIGZhaWxlZDogayBpcyB6ZXJvJyk7IC8vIEZhaWwgaWYgaycgPSAwLlxuICAgIGNvbnN0IHsgYnl0ZXM6IHJ4LCBzY2FsYXI6IGsgfSA9IHNjaG5vcnJHZXRFeHRQdWJLZXkoa18pOyAvLyBMZXQgUiA9IGsn4ouFRy5cbiAgICBjb25zdCBlID0gY2hhbGxlbmdlKHJ4LCBweCwgbSk7IC8vIExldCBlID0gaW50KGhhc2gvY2hhbGxlbmdlKGJ5dGVzKFIpIHx8IGJ5dGVzKFApIHx8IG0pKSBtb2Qgbi5cbiAgICBjb25zdCBzaWcgPSBuZXcgVWludDhBcnJheSg2NCk7IC8vIExldCBzaWcgPSBieXRlcyhSKSB8fCBieXRlcygoayArIGVkKSBtb2QgbikuXG4gICAgc2lnLnNldChyeCwgMCk7XG4gICAgc2lnLnNldChudW1UbzMyYihtb2ROKGsgKyBlICogZCkpLCAzMik7XG4gICAgLy8gSWYgVmVyaWZ5KGJ5dGVzKFApLCBtLCBzaWcpIChzZWUgYmVsb3cpIHJldHVybnMgZmFpbHVyZSwgYWJvcnRcbiAgICBpZiAoIXNjaG5vcnJWZXJpZnkoc2lnLCBtLCBweCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbjogSW52YWxpZCBzaWduYXR1cmUgcHJvZHVjZWQnKTtcbiAgICByZXR1cm4gc2lnO1xufVxuLyoqXG4gKiBWZXJpZmllcyBTY2hub3JyIHNpZ25hdHVyZS5cbiAqIFdpbGwgc3dhbGxvdyBlcnJvcnMgJiByZXR1cm4gZmFsc2UgZXhjZXB0IGZvciBpbml0aWFsIHR5cGUgdmFsaWRhdGlvbiBvZiBhcmd1bWVudHMuXG4gKi9cbmZ1bmN0aW9uIHNjaG5vcnJWZXJpZnkoc2lnbmF0dXJlLCBtZXNzYWdlLCBwdWJsaWNLZXkpIHtcbiAgICBjb25zdCBzaWcgPSBlbnN1cmVCeXRlcygnc2lnbmF0dXJlJywgc2lnbmF0dXJlLCA2NCk7XG4gICAgY29uc3QgbSA9IGVuc3VyZUJ5dGVzKCdtZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgY29uc3QgcHViID0gZW5zdXJlQnl0ZXMoJ3B1YmxpY0tleScsIHB1YmxpY0tleSwgMzIpO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IFAgPSBsaWZ0X3goYnl0ZXNUb051bWJlckJFKHB1YikpOyAvLyBQID0gbGlmdF94KGludChwaykpOyBmYWlsIGlmIHRoYXQgZmFpbHNcbiAgICAgICAgY29uc3QgciA9IGJ5dGVzVG9OdW1iZXJCRShzaWcuc3ViYXJyYXkoMCwgMzIpKTsgLy8gTGV0IHIgPSBpbnQoc2lnWzA6MzJdKTsgZmFpbCBpZiByIOKJpSBwLlxuICAgICAgICBpZiAoIWZlKHIpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBzID0gYnl0ZXNUb051bWJlckJFKHNpZy5zdWJhcnJheSgzMiwgNjQpKTsgLy8gTGV0IHMgPSBpbnQoc2lnWzMyOjY0XSk7IGZhaWwgaWYgcyDiiaUgbi5cbiAgICAgICAgaWYgKCFnZShzKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgZSA9IGNoYWxsZW5nZShudW1UbzMyYihyKSwgcG9pbnRUb0J5dGVzKFApLCBtKTsgLy8gaW50KGNoYWxsZW5nZShieXRlcyhyKXx8Ynl0ZXMoUCl8fG0pKSVuXG4gICAgICAgIGNvbnN0IFIgPSBHbXVsQWRkKFAsIHMsIG1vZE4oLWUpKTsgLy8gUiA9IHPii4VHIC0gZeKLhVBcbiAgICAgICAgaWYgKCFSIHx8ICFSLmhhc0V2ZW5ZKCkgfHwgUi50b0FmZmluZSgpLnggIT09IHIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIC1lUCA9PSAobi1lKVBcbiAgICAgICAgcmV0dXJuIHRydWU7IC8vIEZhaWwgaWYgaXNfaW5maW5pdGUoUikgLyBub3QgaGFzX2V2ZW5feShSKSAvIHgoUikg4omgIHIuXG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IHNjaG5vcnIgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+ICh7XG4gICAgZ2V0UHVibGljS2V5OiBzY2hub3JyR2V0UHVibGljS2V5LFxuICAgIHNpZ246IHNjaG5vcnJTaWduLFxuICAgIHZlcmlmeTogc2Nobm9yclZlcmlmeSxcbiAgICB1dGlsczoge1xuICAgICAgICByYW5kb21Qcml2YXRlS2V5OiBzZWNwMjU2azEudXRpbHMucmFuZG9tUHJpdmF0ZUtleSxcbiAgICAgICAgbGlmdF94LFxuICAgICAgICBwb2ludFRvQnl0ZXMsXG4gICAgICAgIG51bWJlclRvQnl0ZXNCRSxcbiAgICAgICAgYnl0ZXNUb051bWJlckJFLFxuICAgICAgICB0YWdnZWRIYXNoLFxuICAgICAgICBtb2QsXG4gICAgfSxcbn0pKSgpO1xuY29uc3QgaXNvTWFwID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBpc29nZW55TWFwKEZwLCBbXG4gICAgLy8geE51bVxuICAgIFtcbiAgICAgICAgJzB4OGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGRhYWFhYThjNycsXG4gICAgICAgICcweDdkM2Q0YzgwYmMzMjFkNWI5ZjMxNWNlYTdmZDQ0YzVkNTk1ZDJmYzBiZjYzYjkyZGZmZjEwNDRmMTdjNjU4MScsXG4gICAgICAgICcweDUzNGMzMjhkMjNmMjM0ZTZlMmE0MTNkZWNhMjVjYWVjZTQ1MDYxNDQwMzdjNDAzMTRlY2JkMGI1M2Q5ZGQyNjInLFxuICAgICAgICAnMHg4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZGFhYWFhODhjJyxcbiAgICBdLFxuICAgIC8vIHhEZW5cbiAgICBbXG4gICAgICAgICcweGQzNTc3MTE5M2Q5NDkxOGE5Y2EzNGNjYmI3YjY0MGRkODZjZDQwOTU0MmY4NDg3ZDlmZTZiNzQ1NzgxZWI0OWInLFxuICAgICAgICAnMHhlZGFkYzZmNjQzODNkYzFkZjdjNGIyZDUxYjU0MjI1NDA2ZDM2YjY0MWY1ZTQxYmJjNTJhNTY2MTJhOGM2ZDE0JyxcbiAgICAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsIC8vIExBU1QgMVxuICAgIF0sXG4gICAgLy8geU51bVxuICAgIFtcbiAgICAgICAgJzB4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGI4ZTM4ZTIzYycsXG4gICAgICAgICcweGM3NWUwYzMyZDVjYjdjMGZhOWQwYTU0YjEyYTBhNmQ1NjQ3YWIwNDZkNjg2ZGE2ZmRmZmM5MGZjMjAxZDcxYTMnLFxuICAgICAgICAnMHgyOWE2MTk0NjkxZjkxYTczNzE1MjA5ZWY2NTEyZTU3NjcyMjgzMGEyMDFiZTIwMThhNzY1ZTg1YTllY2VlOTMxJyxcbiAgICAgICAgJzB4MmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmYzOGUzOGQ4NCcsXG4gICAgXSxcbiAgICAvLyB5RGVuXG4gICAgW1xuICAgICAgICAnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWZmZmZmOTNiJyxcbiAgICAgICAgJzB4N2EwNjUzNGJiOGJkYjQ5ZmQ1ZTllNjYzMjcyMmMyOTg5NDY3YzFiZmM4ZThkOTc4ZGZiNDI1ZDI2ODVjMjU3MycsXG4gICAgICAgICcweDY0ODRhYTcxNjU0NWNhMmNmM2E3MGMzZmE4ZmUzMzdlMGEzZDIxMTYyZjBkNjI5OWE3YmY4MTkyYmZkMmE3NmYnLFxuICAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJywgLy8gTEFTVCAxXG4gICAgXSxcbl0ubWFwKChpKSA9PiBpLm1hcCgoaikgPT4gQmlnSW50KGopKSkpKSgpO1xuY29uc3QgbWFwU1dVID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBtYXBUb0N1cnZlU2ltcGxlU1dVKEZwLCB7XG4gICAgQTogQmlnSW50KCcweDNmODczMWFiZGQ2NjFhZGNhMDhhNTU1OGYwZjVkMjcyZTk1M2QzNjNjYjZmMGU1ZDQwNTQ0N2MwMWE0NDQ1MzMnKSxcbiAgICBCOiBCaWdJbnQoJzE3NzEnKSxcbiAgICBaOiBGcC5jcmVhdGUoQmlnSW50KCctMTEnKSksXG59KSkoKTtcbmNvbnN0IGh0ZiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gY3JlYXRlSGFzaGVyKHNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQsIChzY2FsYXJzKSA9PiB7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBtYXBTV1UoRnAuY3JlYXRlKHNjYWxhcnNbMF0pKTtcbiAgICByZXR1cm4gaXNvTWFwKHgsIHkpO1xufSwge1xuICAgIERTVDogJ3NlY3AyNTZrMV9YTUQ6U0hBLTI1Nl9TU1dVX1JPXycsXG4gICAgZW5jb2RlRFNUOiAnc2VjcDI1NmsxX1hNRDpTSEEtMjU2X1NTV1VfTlVfJyxcbiAgICBwOiBGcC5PUkRFUixcbiAgICBtOiAxLFxuICAgIGs6IDEyOCxcbiAgICBleHBhbmQ6ICd4bWQnLFxuICAgIGhhc2g6IHNoYTI1Nixcbn0pKSgpO1xuZXhwb3J0IGNvbnN0IGhhc2hUb0N1cnZlID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBodGYuaGFzaFRvQ3VydmUpKCk7XG5leHBvcnQgY29uc3QgZW5jb2RlVG9DdXJ2ZSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gaHRmLmVuY29kZVRvQ3VydmUpKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZWNwMjU2azEuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/esm/secp256k1.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js":
/*!***************************************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js ***!
  \***************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bool: () => (/* binding */ bool),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   exists: () => (/* binding */ exists),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   output: () => (/* binding */ output)\n/* harmony export */ });\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`Wrong positive integer: ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`Expected boolean, not ${b}`);\n}\nfunction bytes(b, ...lengths) {\n    if (!(b instanceof Uint8Array))\n        throw new Error('Expected Uint8Array');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(hash) {\n    if (typeof hash !== 'function' || typeof hash.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(hash.outputLen);\n    number(hash.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\n\nconst assert = { number, bool, bytes, hash, exists, output };\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (assert);\n//# sourceMappingURL=_assert.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX2Fzc2VydC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBLG1EQUFtRCxFQUFFO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxFQUFFO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsUUFBUSxrQkFBa0IsU0FBUztBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLElBQUk7QUFDckY7QUFDQTtBQUNxRDtBQUNyRCxpQkFBaUI7QUFDakIsaUVBQWUsTUFBTSxFQUFDO0FBQ3RCIiwic291cmNlcyI6WyIvaG9tZS9sZmcvR2l0L01hZHRyaXBzL25vZGVfbW9kdWxlcy9Abm9zdHItZGV2LWtpdC9uZGsvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fYXNzZXJ0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIG51bWJlcihuKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSB8fCBuIDwgMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXcm9uZyBwb3NpdGl2ZSBpbnRlZ2VyOiAke259YCk7XG59XG5mdW5jdGlvbiBib29sKGIpIHtcbiAgICBpZiAodHlwZW9mIGIgIT09ICdib29sZWFuJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBib29sZWFuLCBub3QgJHtifWApO1xufVxuZnVuY3Rpb24gYnl0ZXMoYiwgLi4ubGVuZ3Rocykge1xuICAgIGlmICghKGIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBVaW50OEFycmF5Jyk7XG4gICAgaWYgKGxlbmd0aHMubGVuZ3RoID4gMCAmJiAhbGVuZ3Rocy5pbmNsdWRlcyhiLmxlbmd0aCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgVWludDhBcnJheSBvZiBsZW5ndGggJHtsZW5ndGhzfSwgbm90IG9mIGxlbmd0aD0ke2IubGVuZ3RofWApO1xufVxuZnVuY3Rpb24gaGFzaChoYXNoKSB7XG4gICAgaWYgKHR5cGVvZiBoYXNoICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBoYXNoLmNyZWF0ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIHNob3VsZCBiZSB3cmFwcGVkIGJ5IHV0aWxzLndyYXBDb25zdHJ1Y3RvcicpO1xuICAgIG51bWJlcihoYXNoLm91dHB1dExlbik7XG4gICAgbnVtYmVyKGhhc2guYmxvY2tMZW4pO1xufVxuZnVuY3Rpb24gZXhpc3RzKGluc3RhbmNlLCBjaGVja0ZpbmlzaGVkID0gdHJ1ZSkge1xuICAgIGlmIChpbnN0YW5jZS5kZXN0cm95ZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWQnKTtcbiAgICBpZiAoY2hlY2tGaW5pc2hlZCAmJiBpbnN0YW5jZS5maW5pc2hlZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoI2RpZ2VzdCgpIGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkJyk7XG59XG5mdW5jdGlvbiBvdXRwdXQob3V0LCBpbnN0YW5jZSkge1xuICAgIGJ5dGVzKG91dCk7XG4gICAgY29uc3QgbWluID0gaW5zdGFuY2Uub3V0cHV0TGVuO1xuICAgIGlmIChvdXQubGVuZ3RoIDwgbWluKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZGlnZXN0SW50bygpIGV4cGVjdHMgb3V0cHV0IGJ1ZmZlciBvZiBsZW5ndGggYXQgbGVhc3QgJHttaW59YCk7XG4gICAgfVxufVxuZXhwb3J0IHsgbnVtYmVyLCBib29sLCBieXRlcywgaGFzaCwgZXhpc3RzLCBvdXRwdXQgfTtcbmNvbnN0IGFzc2VydCA9IHsgbnVtYmVyLCBib29sLCBieXRlcywgaGFzaCwgZXhpc3RzLCBvdXRwdXQgfTtcbmV4cG9ydCBkZWZhdWx0IGFzc2VydDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9hc3NlcnQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/_sha2.js":
/*!*************************************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/_sha2.js ***!
  \*************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHA2: () => (/* binding */ SHA2)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nclass SHA2 extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(this.buffer);\n    }\n    update(data) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        const { view, buffer, blockLen } = this;\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.output)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n//# sourceMappingURL=_sha2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX3NoYTIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQThDO0FBQ1M7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLG1CQUFtQiwyQ0FBSTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFEQUFVO0FBQzlCO0FBQ0E7QUFDQSxRQUFRLGtEQUFNO0FBQ2QsZ0JBQWdCLHlCQUF5QjtBQUN6QyxlQUFlLGtEQUFPO0FBQ3RCO0FBQ0EsMEJBQTBCLFVBQVU7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHFEQUFVO0FBQzNDLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFNO0FBQ2QsUUFBUSxrREFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtCQUErQjtBQUMvQyxjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGNBQWM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFEQUFVO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscURBQXFEO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9sZmcvR2l0L01hZHRyaXBzL25vZGVfbW9kdWxlcy9Abm9zdHItZGV2LWtpdC9uZGsvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fc2hhMi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBleGlzdHMsIG91dHB1dCB9IGZyb20gJy4vX2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBIYXNoLCBjcmVhdGVWaWV3LCB0b0J5dGVzIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBQb2x5ZmlsbCBmb3IgU2FmYXJpIDE0XG5mdW5jdGlvbiBzZXRCaWdVaW50NjQodmlldywgYnl0ZU9mZnNldCwgdmFsdWUsIGlzTEUpIHtcbiAgICBpZiAodHlwZW9mIHZpZXcuc2V0QmlnVWludDY0ID09PSAnZnVuY3Rpb24nKVxuICAgICAgICByZXR1cm4gdmlldy5zZXRCaWdVaW50NjQoYnl0ZU9mZnNldCwgdmFsdWUsIGlzTEUpO1xuICAgIGNvbnN0IF8zMm4gPSBCaWdJbnQoMzIpO1xuICAgIGNvbnN0IF91MzJfbWF4ID0gQmlnSW50KDB4ZmZmZmZmZmYpO1xuICAgIGNvbnN0IHdoID0gTnVtYmVyKCh2YWx1ZSA+PiBfMzJuKSAmIF91MzJfbWF4KTtcbiAgICBjb25zdCB3bCA9IE51bWJlcih2YWx1ZSAmIF91MzJfbWF4KTtcbiAgICBjb25zdCBoID0gaXNMRSA/IDQgOiAwO1xuICAgIGNvbnN0IGwgPSBpc0xFID8gMCA6IDQ7XG4gICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGgsIHdoLCBpc0xFKTtcbiAgICB2aWV3LnNldFVpbnQzMihieXRlT2Zmc2V0ICsgbCwgd2wsIGlzTEUpO1xufVxuLy8gQmFzZSBTSEEyIGNsYXNzIChSRkMgNjIzNClcbmV4cG9ydCBjbGFzcyBTSEEyIGV4dGVuZHMgSGFzaCB7XG4gICAgY29uc3RydWN0b3IoYmxvY2tMZW4sIG91dHB1dExlbiwgcGFkT2Zmc2V0LCBpc0xFKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRoaXMucGFkT2Zmc2V0ID0gcGFkT2Zmc2V0O1xuICAgICAgICB0aGlzLmlzTEUgPSBpc0xFO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGJsb2NrTGVuKTtcbiAgICAgICAgdGhpcy52aWV3ID0gY3JlYXRlVmlldyh0aGlzLmJ1ZmZlcik7XG4gICAgfVxuICAgIHVwZGF0ZShkYXRhKSB7XG4gICAgICAgIGV4aXN0cyh0aGlzKTtcbiAgICAgICAgY29uc3QgeyB2aWV3LCBidWZmZXIsIGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICBkYXRhID0gdG9CeXRlcyhkYXRhKTtcbiAgICAgICAgY29uc3QgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDA7IHBvcyA8IGxlbjspIHtcbiAgICAgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihibG9ja0xlbiAtIHRoaXMucG9zLCBsZW4gLSBwb3MpO1xuICAgICAgICAgICAgLy8gRmFzdCBwYXRoOiB3ZSBoYXZlIGF0IGxlYXN0IG9uZSBibG9jayBpbiBpbnB1dCwgY2FzdCBpdCB0byB2aWV3IGFuZCBwcm9jZXNzXG4gICAgICAgICAgICBpZiAodGFrZSA9PT0gYmxvY2tMZW4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhVmlldyA9IGNyZWF0ZVZpZXcoZGF0YSk7XG4gICAgICAgICAgICAgICAgZm9yICg7IGJsb2NrTGVuIDw9IGxlbiAtIHBvczsgcG9zICs9IGJsb2NrTGVuKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3MoZGF0YVZpZXcsIHBvcyk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXIuc2V0KGRhdGEuc3ViYXJyYXkocG9zLCBwb3MgKyB0YWtlKSwgdGhpcy5wb3MpO1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gdGFrZTtcbiAgICAgICAgICAgIHBvcyArPSB0YWtlO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZW5ndGggKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgIHRoaXMucm91bmRDbGVhbigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgZXhpc3RzKHRoaXMpO1xuICAgICAgICBvdXRwdXQob3V0LCB0aGlzKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIC8vIFBhZGRpbmdcbiAgICAgICAgLy8gV2UgY2FuIGF2b2lkIGFsbG9jYXRpb24gb2YgYnVmZmVyIGZvciBwYWRkaW5nIGNvbXBsZXRlbHkgaWYgaXRcbiAgICAgICAgLy8gd2FzIHByZXZpb3VzbHkgbm90IGFsbG9jYXRlZCBoZXJlLiBCdXQgaXQgd29uJ3QgY2hhbmdlIHBlcmZvcm1hbmNlLlxuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgdmlldywgYmxvY2tMZW4sIGlzTEUgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IHBvcyB9ID0gdGhpcztcbiAgICAgICAgLy8gYXBwZW5kIHRoZSBiaXQgJzEnIHRvIHRoZSBtZXNzYWdlXG4gICAgICAgIGJ1ZmZlcltwb3MrK10gPSAwYjEwMDAwMDAwO1xuICAgICAgICB0aGlzLmJ1ZmZlci5zdWJhcnJheShwb3MpLmZpbGwoMCk7XG4gICAgICAgIC8vIHdlIGhhdmUgbGVzcyB0aGFuIHBhZE9mZnNldCBsZWZ0IGluIGJ1ZmZlciwgc28gd2UgY2Fubm90IHB1dCBsZW5ndGggaW4gY3VycmVudCBibG9jaywgbmVlZCBwcm9jZXNzIGl0IGFuZCBwYWQgYWdhaW5cbiAgICAgICAgaWYgKHRoaXMucGFkT2Zmc2V0ID4gYmxvY2tMZW4gLSBwb3MpIHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgICAgIHBvcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUGFkIHVudGlsIGZ1bGwgYmxvY2sgYnl0ZSB3aXRoIHplcm9zXG4gICAgICAgIGZvciAobGV0IGkgPSBwb3M7IGkgPCBibG9ja0xlbjsgaSsrKVxuICAgICAgICAgICAgYnVmZmVyW2ldID0gMDtcbiAgICAgICAgLy8gTm90ZTogc2hhNTEyIHJlcXVpcmVzIGxlbmd0aCB0byBiZSAxMjhiaXQgaW50ZWdlciwgYnV0IGxlbmd0aCBpbiBKUyB3aWxsIG92ZXJmbG93IGJlZm9yZSB0aGF0XG4gICAgICAgIC8vIFlvdSBuZWVkIHRvIHdyaXRlIGFyb3VuZCAyIGV4YWJ5dGVzICh1NjRfbWF4IC8gOCAvICgxMDI0Kio2KSkgZm9yIHRoaXMgdG8gaGFwcGVuLlxuICAgICAgICAvLyBTbyB3ZSBqdXN0IHdyaXRlIGxvd2VzdCA2NCBiaXRzIG9mIHRoYXQgdmFsdWUuXG4gICAgICAgIHNldEJpZ1VpbnQ2NCh2aWV3LCBibG9ja0xlbiAtIDgsIEJpZ0ludCh0aGlzLmxlbmd0aCAqIDgpLCBpc0xFKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICBjb25zdCBvdmlldyA9IGNyZWF0ZVZpZXcob3V0KTtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5vdXRwdXRMZW47XG4gICAgICAgIC8vIE5PVEU6IHdlIGRvIGRpdmlzaW9uIGJ5IDQgbGF0ZXIsIHdoaWNoIHNob3VsZCBiZSBmdXNlZCBpbiBzaW5nbGUgb3Agd2l0aCBtb2R1bG8gYnkgSklUXG4gICAgICAgIGlmIChsZW4gJSA0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfc2hhMjogb3V0cHV0TGVuIHNob3VsZCBiZSBhbGlnbmVkIHRvIDMyYml0Jyk7XG4gICAgICAgIGNvbnN0IG91dExlbiA9IGxlbiAvIDQ7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXQoKTtcbiAgICAgICAgaWYgKG91dExlbiA+IHN0YXRlLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX3NoYTI6IG91dHB1dExlbiBiaWdnZXIgdGhhbiBzdGF0ZScpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dExlbjsgaSsrKVxuICAgICAgICAgICAgb3ZpZXcuc2V0VWludDMyKDQgKiBpLCBzdGF0ZVtpXSwgaXNMRSk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3QgeyBidWZmZXIsIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5kaWdlc3RJbnRvKGJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IHJlcyA9IGJ1ZmZlci5zbGljZSgwLCBvdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICB0byB8fCAodG8gPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpKTtcbiAgICAgICAgdG8uc2V0KC4uLnRoaXMuZ2V0KCkpO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBidWZmZXIsIGxlbmd0aCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgcG9zIH0gPSB0aGlzO1xuICAgICAgICB0by5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRvLnBvcyA9IHBvcztcbiAgICAgICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gZGVzdHJveWVkO1xuICAgICAgICBpZiAobGVuZ3RoICUgYmxvY2tMZW4pXG4gICAgICAgICAgICB0by5idWZmZXIuc2V0KGJ1ZmZlcik7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fc2hhMi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/_sha2.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/cryptoNode.js":
/*!******************************************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/cryptoNode.js ***!
  \******************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   crypto: () => (/* binding */ crypto)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// See utils.ts for details.\n// The file will throw on node.js 14 and earlier.\n// @ts-ignore\n\nconst crypto = /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) && typeof /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) === 'object' && \"webcrypto\" in /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) ? node_crypto__WEBPACK_IMPORTED_MODULE_0__.webcrypto : undefined;\n//# sourceMappingURL=cryptoNode.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vY3J5cHRvTm9kZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNrQztBQUMzQixlQUFlLDJNQUFFLFdBQVcsMk1BQUUsaUJBQWlCLDBOQUFpQixHQUFHLGtEQUFZO0FBQ3RGIiwic291cmNlcyI6WyIvaG9tZS9sZmcvR2l0L01hZHRyaXBzL25vZGVfbW9kdWxlcy9Abm9zdHItZGV2LWtpdC9uZGsvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9jcnlwdG9Ob2RlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFdlIHVzZSBXZWJDcnlwdG8gYWthIGdsb2JhbFRoaXMuY3J5cHRvLCB3aGljaCBleGlzdHMgaW4gYnJvd3NlcnMgYW5kIG5vZGUuanMgMTYrLlxuLy8gU2VlIHV0aWxzLnRzIGZvciBkZXRhaWxzLlxuLy8gVGhlIGZpbGUgd2lsbCB0aHJvdyBvbiBub2RlLmpzIDE0IGFuZCBlYXJsaWVyLlxuLy8gQHRzLWlnbm9yZVxuaW1wb3J0ICogYXMgbmMgZnJvbSAnbm9kZTpjcnlwdG8nO1xuZXhwb3J0IGNvbnN0IGNyeXB0byA9IG5jICYmIHR5cGVvZiBuYyA9PT0gJ29iamVjdCcgJiYgJ3dlYmNyeXB0bycgaW4gbmMgPyBuYy53ZWJjcnlwdG8gOiB1bmRlZmluZWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcnlwdG9Ob2RlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/cryptoNode.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/hmac.js":
/*!************************************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/hmac.js ***!
  \************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HMAC: () => (/* binding */ HMAC),\n/* harmony export */   hmac: () => (/* binding */ hmac)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// HMAC (RFC 2104)\nclass HMAC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.hash)(hash);\n        const key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.bytes)(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */\nconst hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key) => new HMAC(hash, key);\n//# sourceMappingURL=hmac.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vaG1hYy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWdHO0FBQ3JEO0FBQzNDO0FBQ08sbUJBQW1CLDJDQUFJO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnREFBVTtBQUNsQixvQkFBb0Isa0RBQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBWTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQVk7QUFDcEIsUUFBUSxpREFBVztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRSxnQkFBZ0IseURBQXlEO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbGZnL0dpdC9NYWR0cmlwcy9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vaG1hYy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBoYXNoIGFzIGFzc2VydEhhc2gsIGJ5dGVzIGFzIGFzc2VydEJ5dGVzLCBleGlzdHMgYXMgYXNzZXJ0RXhpc3RzIH0gZnJvbSAnLi9fYXNzZXJ0LmpzJztcbmltcG9ydCB7IEhhc2gsIHRvQnl0ZXMgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIEhNQUMgKFJGQyAyMTA0KVxuZXhwb3J0IGNsYXNzIEhNQUMgZXh0ZW5kcyBIYXNoIHtcbiAgICBjb25zdHJ1Y3RvcihoYXNoLCBfa2V5KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgYXNzZXJ0SGFzaChoYXNoKTtcbiAgICAgICAgY29uc3Qga2V5ID0gdG9CeXRlcyhfa2V5KTtcbiAgICAgICAgdGhpcy5pSGFzaCA9IGhhc2guY3JlYXRlKCk7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5pSGFzaC51cGRhdGUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGluc3RhbmNlIG9mIGNsYXNzIHdoaWNoIGV4dGVuZHMgdXRpbHMuSGFzaCcpO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gdGhpcy5pSGFzaC5ibG9ja0xlbjtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSB0aGlzLmlIYXNoLm91dHB1dExlbjtcbiAgICAgICAgY29uc3QgYmxvY2tMZW4gPSB0aGlzLmJsb2NrTGVuO1xuICAgICAgICBjb25zdCBwYWQgPSBuZXcgVWludDhBcnJheShibG9ja0xlbik7XG4gICAgICAgIC8vIGJsb2NrTGVuIGNhbiBiZSBiaWdnZXIgdGhhbiBvdXRwdXRMZW5cbiAgICAgICAgcGFkLnNldChrZXkubGVuZ3RoID4gYmxvY2tMZW4gPyBoYXNoLmNyZWF0ZSgpLnVwZGF0ZShrZXkpLmRpZ2VzdCgpIDoga2V5KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBwYWRbaV0gXj0gMHgzNjtcbiAgICAgICAgdGhpcy5pSGFzaC51cGRhdGUocGFkKTtcbiAgICAgICAgLy8gQnkgZG9pbmcgdXBkYXRlIChwcm9jZXNzaW5nIG9mIGZpcnN0IGJsb2NrKSBvZiBvdXRlciBoYXNoIGhlcmUgd2UgY2FuIHJlLXVzZSBpdCBiZXR3ZWVuIG11bHRpcGxlIGNhbGxzIHZpYSBjbG9uZVxuICAgICAgICB0aGlzLm9IYXNoID0gaGFzaC5jcmVhdGUoKTtcbiAgICAgICAgLy8gVW5kbyBpbnRlcm5hbCBYT1IgJiYgYXBwbHkgb3V0ZXIgWE9SXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcGFkW2ldIF49IDB4MzYgXiAweDVjO1xuICAgICAgICB0aGlzLm9IYXNoLnVwZGF0ZShwYWQpO1xuICAgICAgICBwYWQuZmlsbCgwKTtcbiAgICB9XG4gICAgdXBkYXRlKGJ1Zikge1xuICAgICAgICBhc3NlcnRFeGlzdHModGhpcyk7XG4gICAgICAgIHRoaXMuaUhhc2gudXBkYXRlKGJ1Zik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBhc3NlcnRFeGlzdHModGhpcyk7XG4gICAgICAgIGFzc2VydEJ5dGVzKG91dCwgdGhpcy5vdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pSGFzaC5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHRoaXMub0hhc2gudXBkYXRlKG91dCk7XG4gICAgICAgIHRoaXMub0hhc2guZGlnZXN0SW50byhvdXQpO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICBjb25zdCBvdXQgPSBuZXcgVWludDhBcnJheSh0aGlzLm9IYXNoLm91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZGlnZXN0SW50byhvdXQpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIC8vIENyZWF0ZSBuZXcgaW5zdGFuY2Ugd2l0aG91dCBjYWxsaW5nIGNvbnN0cnVjdG9yIHNpbmNlIGtleSBhbHJlYWR5IGluIHN0YXRlIGFuZCB3ZSBkb24ndCBrbm93IGl0LlxuICAgICAgICB0byB8fCAodG8gPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSwge30pKTtcbiAgICAgICAgY29uc3QgeyBvSGFzaCwgaUhhc2gsIGZpbmlzaGVkLCBkZXN0cm95ZWQsIGJsb2NrTGVuLCBvdXRwdXRMZW4gfSA9IHRoaXM7XG4gICAgICAgIHRvID0gdG87XG4gICAgICAgIHRvLmZpbmlzaGVkID0gZmluaXNoZWQ7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IGRlc3Ryb3llZDtcbiAgICAgICAgdG8uYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdG8ub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0by5vSGFzaCA9IG9IYXNoLl9jbG9uZUludG8odG8ub0hhc2gpO1xuICAgICAgICB0by5pSGFzaCA9IGlIYXNoLl9jbG9uZUludG8odG8uaUhhc2gpO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vSGFzaC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuaUhhc2guZGVzdHJveSgpO1xuICAgIH1cbn1cbi8qKlxuICogSE1BQzogUkZDMjEwNCBtZXNzYWdlIGF1dGhlbnRpY2F0aW9uIGNvZGUuXG4gKiBAcGFyYW0gaGFzaCAtIGZ1bmN0aW9uIHRoYXQgd291bGQgYmUgdXNlZCBlLmcuIHNoYTI1NlxuICogQHBhcmFtIGtleSAtIG1lc3NhZ2Uga2V5XG4gKiBAcGFyYW0gbWVzc2FnZSAtIG1lc3NhZ2UgZGF0YVxuICovXG5leHBvcnQgY29uc3QgaG1hYyA9IChoYXNoLCBrZXksIG1lc3NhZ2UpID0+IG5ldyBITUFDKGhhc2gsIGtleSkudXBkYXRlKG1lc3NhZ2UpLmRpZ2VzdCgpO1xuaG1hYy5jcmVhdGUgPSAoaGFzaCwga2V5KSA9PiBuZXcgSE1BQyhoYXNoLCBrZXkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aG1hYy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/hmac.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/sha256.js":
/*!**************************************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/sha256.js ***!
  \**************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sha224: () => (/* binding */ sha224),\n/* harmony export */   sha256: () => (/* binding */ sha256)\n/* harmony export */ });\n/* harmony import */ var _sha2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_sha2.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/_sha2.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n// Choice: a ? b : c\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends _sha2_js__WEBPACK_IMPORTED_MODULE_0__.SHA2 {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = IV[0] | 0;\n        this.B = IV[1] | 0;\n        this.C = IV[2] | 0;\n        this.D = IV[3] | 0;\n        this.E = IV[4] | 0;\n        this.F = IV[5] | 0;\n        this.G = IV[6] | 0;\n        this.H = IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 7) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 18) ^ (W15 >>> 3);\n            const s1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 17) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 6) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 11) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 2) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 13) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nconst sha256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA256());\nconst sha224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA224());\n//# sourceMappingURL=sha256.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vc2hhMjU2LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBa0M7QUFDaUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDBDQUFJO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseUJBQXlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBLHVCQUF1QiwrQ0FBSSxXQUFXLCtDQUFJO0FBQzFDLHVCQUF1QiwrQ0FBSSxXQUFXLCtDQUFJO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLGNBQWMseUJBQXlCO0FBQ3ZDLHdCQUF3QixRQUFRO0FBQ2hDLDJCQUEyQiwrQ0FBSSxTQUFTLCtDQUFJLFVBQVUsK0NBQUk7QUFDMUQ7QUFDQSwyQkFBMkIsK0NBQUksU0FBUywrQ0FBSSxVQUFVLCtDQUFJO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLCtCQUErQiwwREFBZTtBQUM5QywrQkFBK0IsMERBQWU7QUFDckQiLCJzb3VyY2VzIjpbIi9ob21lL2xmZy9HaXQvTWFkdHJpcHMvbm9kZV9tb2R1bGVzL0Bub3N0ci1kZXYta2l0L25kay9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTI1Ni5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTSEEyIH0gZnJvbSAnLi9fc2hhMi5qcyc7XG5pbXBvcnQgeyByb3RyLCB3cmFwQ29uc3RydWN0b3IgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIFNIQTItMjU2IG5lZWQgdG8gdHJ5IDJeMTI4IGhhc2hlcyB0byBleGVjdXRlIGJpcnRoZGF5IGF0dGFjay5cbi8vIEJUQyBuZXR3b3JrIGlzIGRvaW5nIDJeNjcgaGFzaGVzL3NlYyBhcyBwZXIgZWFybHkgMjAyMy5cbi8vIENob2ljZTogYSA/IGIgOiBjXG5jb25zdCBDaGkgPSAoYSwgYiwgYykgPT4gKGEgJiBiKSBeICh+YSAmIGMpO1xuLy8gTWFqb3JpdHkgZnVuY3Rpb24sIHRydWUgaWYgYW55IHR3byBpbnB1c3QgaXMgdHJ1ZVxuY29uc3QgTWFqID0gKGEsIGIsIGMpID0+IChhICYgYikgXiAoYSAmIGMpIF4gKGIgJiBjKTtcbi8vIFJvdW5kIGNvbnN0YW50czpcbi8vIGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIGN1YmUgcm9vdHMgb2YgdGhlIGZpcnN0IDY0IHByaW1lcyAyLi4zMTEpXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IFNIQTI1Nl9LID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheShbXG4gICAgMHg0MjhhMmY5OCwgMHg3MTM3NDQ5MSwgMHhiNWMwZmJjZiwgMHhlOWI1ZGJhNSwgMHgzOTU2YzI1YiwgMHg1OWYxMTFmMSwgMHg5MjNmODJhNCwgMHhhYjFjNWVkNSxcbiAgICAweGQ4MDdhYTk4LCAweDEyODM1YjAxLCAweDI0MzE4NWJlLCAweDU1MGM3ZGMzLCAweDcyYmU1ZDc0LCAweDgwZGViMWZlLCAweDliZGMwNmE3LCAweGMxOWJmMTc0LFxuICAgIDB4ZTQ5YjY5YzEsIDB4ZWZiZTQ3ODYsIDB4MGZjMTlkYzYsIDB4MjQwY2ExY2MsIDB4MmRlOTJjNmYsIDB4NGE3NDg0YWEsIDB4NWNiMGE5ZGMsIDB4NzZmOTg4ZGEsXG4gICAgMHg5ODNlNTE1MiwgMHhhODMxYzY2ZCwgMHhiMDAzMjdjOCwgMHhiZjU5N2ZjNywgMHhjNmUwMGJmMywgMHhkNWE3OTE0NywgMHgwNmNhNjM1MSwgMHgxNDI5Mjk2NyxcbiAgICAweDI3YjcwYTg1LCAweDJlMWIyMTM4LCAweDRkMmM2ZGZjLCAweDUzMzgwZDEzLCAweDY1MGE3MzU0LCAweDc2NmEwYWJiLCAweDgxYzJjOTJlLCAweDkyNzIyYzg1LFxuICAgIDB4YTJiZmU4YTEsIDB4YTgxYTY2NGIsIDB4YzI0YjhiNzAsIDB4Yzc2YzUxYTMsIDB4ZDE5MmU4MTksIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsXG4gICAgMHgxOWE0YzExNiwgMHgxZTM3NmMwOCwgMHgyNzQ4Nzc0YywgMHgzNGIwYmNiNSwgMHgzOTFjMGNiMywgMHg0ZWQ4YWE0YSwgMHg1YjljY2E0ZiwgMHg2ODJlNmZmMyxcbiAgICAweDc0OGY4MmVlLCAweDc4YTU2MzZmLCAweDg0Yzg3ODE0LCAweDhjYzcwMjA4LCAweDkwYmVmZmZhLCAweGE0NTA2Y2ViLCAweGJlZjlhM2Y3LCAweGM2NzE3OGYyXG5dKTtcbi8vIEluaXRpYWwgc3RhdGUgKGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIHNxdWFyZSByb290cyBvZiB0aGUgZmlyc3QgOCBwcmltZXMgMi4uMTkpOlxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBJViA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoW1xuICAgIDB4NmEwOWU2NjcsIDB4YmI2N2FlODUsIDB4M2M2ZWYzNzIsIDB4YTU0ZmY1M2EsIDB4NTEwZTUyN2YsIDB4OWIwNTY4OGMsIDB4MWY4M2Q5YWIsIDB4NWJlMGNkMTlcbl0pO1xuLy8gVGVtcG9yYXJ5IGJ1ZmZlciwgbm90IHVzZWQgdG8gc3RvcmUgYW55dGhpbmcgYmV0d2VlbiBydW5zXG4vLyBOYW1lZCB0aGlzIHdheSBiZWNhdXNlIGl0IG1hdGNoZXMgc3BlY2lmaWNhdGlvbi5cbmNvbnN0IFNIQTI1Nl9XID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheSg2NCk7XG5jbGFzcyBTSEEyNTYgZXh0ZW5kcyBTSEEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoNjQsIDMyLCA4LCBmYWxzZSk7XG4gICAgICAgIC8vIFdlIGNhbm5vdCB1c2UgYXJyYXkgaGVyZSBzaW5jZSBhcnJheSBhbGxvd3MgaW5kZXhpbmcgYnkgdmFyaWFibGVcbiAgICAgICAgLy8gd2hpY2ggbWVhbnMgb3B0aW1pemVyL2NvbXBpbGVyIGNhbm5vdCB1c2UgcmVnaXN0ZXJzLlxuICAgICAgICB0aGlzLkEgPSBJVlswXSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IElWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5DID0gSVZbMl0gfCAwO1xuICAgICAgICB0aGlzLkQgPSBJVlszXSB8IDA7XG4gICAgICAgIHRoaXMuRSA9IElWWzRdIHwgMDtcbiAgICAgICAgdGhpcy5GID0gSVZbNV0gfCAwO1xuICAgICAgICB0aGlzLkcgPSBJVls2XSB8IDA7XG4gICAgICAgIHRoaXMuSCA9IElWWzddIHwgMDtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbQSwgQiwgQywgRCwgRSwgRiwgRywgSF07XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIHNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKSB7XG4gICAgICAgIHRoaXMuQSA9IEEgfCAwO1xuICAgICAgICB0aGlzLkIgPSBCIHwgMDtcbiAgICAgICAgdGhpcy5DID0gQyB8IDA7XG4gICAgICAgIHRoaXMuRCA9IEQgfCAwO1xuICAgICAgICB0aGlzLkUgPSBFIHwgMDtcbiAgICAgICAgdGhpcy5GID0gRiB8IDA7XG4gICAgICAgIHRoaXMuRyA9IEcgfCAwO1xuICAgICAgICB0aGlzLkggPSBIIHwgMDtcbiAgICB9XG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgLy8gRXh0ZW5kIHRoZSBmaXJzdCAxNiB3b3JkcyBpbnRvIHRoZSByZW1haW5pbmcgNDggd29yZHMgd1sxNi4uNjNdIG9mIHRoZSBtZXNzYWdlIHNjaGVkdWxlIGFycmF5XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpXG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCwgZmFsc2UpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA2NDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBXMTUgPSBTSEEyNTZfV1tpIC0gMTVdO1xuICAgICAgICAgICAgY29uc3QgVzIgPSBTSEEyNTZfV1tpIC0gMl07XG4gICAgICAgICAgICBjb25zdCBzMCA9IHJvdHIoVzE1LCA3KSBeIHJvdHIoVzE1LCAxOCkgXiAoVzE1ID4+PiAzKTtcbiAgICAgICAgICAgIGNvbnN0IHMxID0gcm90cihXMiwgMTcpIF4gcm90cihXMiwgMTkpIF4gKFcyID4+PiAxMCk7XG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IChzMSArIFNIQTI1Nl9XW2kgLSA3XSArIHMwICsgU0hBMjU2X1dbaSAtIDE2XSkgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXByZXNzaW9uIGZ1bmN0aW9uIG1haW4gbG9vcCwgNjQgcm91bmRzXG4gICAgICAgIGxldCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc2lnbWExID0gcm90cihFLCA2KSBeIHJvdHIoRSwgMTEpIF4gcm90cihFLCAyNSk7XG4gICAgICAgICAgICBjb25zdCBUMSA9IChIICsgc2lnbWExICsgQ2hpKEUsIEYsIEcpICsgU0hBMjU2X0tbaV0gKyBTSEEyNTZfV1tpXSkgfCAwO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWEwID0gcm90cihBLCAyKSBeIHJvdHIoQSwgMTMpIF4gcm90cihBLCAyMik7XG4gICAgICAgICAgICBjb25zdCBUMiA9IChzaWdtYTAgKyBNYWooQSwgQiwgQykpIHwgMDtcbiAgICAgICAgICAgIEggPSBHO1xuICAgICAgICAgICAgRyA9IEY7XG4gICAgICAgICAgICBGID0gRTtcbiAgICAgICAgICAgIEUgPSAoRCArIFQxKSB8IDA7XG4gICAgICAgICAgICBEID0gQztcbiAgICAgICAgICAgIEMgPSBCO1xuICAgICAgICAgICAgQiA9IEE7XG4gICAgICAgICAgICBBID0gKFQxICsgVDIpIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICBBID0gKEEgKyB0aGlzLkEpIHwgMDtcbiAgICAgICAgQiA9IChCICsgdGhpcy5CKSB8IDA7XG4gICAgICAgIEMgPSAoQyArIHRoaXMuQykgfCAwO1xuICAgICAgICBEID0gKEQgKyB0aGlzLkQpIHwgMDtcbiAgICAgICAgRSA9IChFICsgdGhpcy5FKSB8IDA7XG4gICAgICAgIEYgPSAoRiArIHRoaXMuRikgfCAwO1xuICAgICAgICBHID0gKEcgKyB0aGlzLkcpIHwgMDtcbiAgICAgICAgSCA9IChIICsgdGhpcy5IKSB8IDA7XG4gICAgICAgIHRoaXMuc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpO1xuICAgIH1cbiAgICByb3VuZENsZWFuKCkge1xuICAgICAgICBTSEEyNTZfVy5maWxsKDApO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICAgICAgdGhpcy5idWZmZXIuZmlsbCgwKTtcbiAgICB9XG59XG4vLyBDb25zdGFudHMgZnJvbSBodHRwczovL252bHB1YnMubmlzdC5nb3YvbmlzdHB1YnMvRklQUy9OSVNULkZJUFMuMTgwLTQucGRmXG5jbGFzcyBTSEEyMjQgZXh0ZW5kcyBTSEEyNTYge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLkEgPSAweGMxMDU5ZWQ4IHwgMDtcbiAgICAgICAgdGhpcy5CID0gMHgzNjdjZDUwNyB8IDA7XG4gICAgICAgIHRoaXMuQyA9IDB4MzA3MGRkMTcgfCAwO1xuICAgICAgICB0aGlzLkQgPSAweGY3MGU1OTM5IHwgMDtcbiAgICAgICAgdGhpcy5FID0gMHhmZmMwMGIzMSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IDB4Njg1ODE1MTEgfCAwO1xuICAgICAgICB0aGlzLkcgPSAweDY0Zjk4ZmE3IHwgMDtcbiAgICAgICAgdGhpcy5IID0gMHhiZWZhNGZhNCB8IDA7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gMjg7XG4gICAgfVxufVxuLyoqXG4gKiBTSEEyLTI1NiBoYXNoIGZ1bmN0aW9uXG4gKiBAcGFyYW0gbWVzc2FnZSAtIGRhdGEgdGhhdCB3b3VsZCBiZSBoYXNoZWRcbiAqL1xuZXhwb3J0IGNvbnN0IHNoYTI1NiA9IC8qIEBfX1BVUkVfXyAqLyB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTI1NigpKTtcbmV4cG9ydCBjb25zdCBzaGEyMjQgPSAvKiBAX19QVVJFX18gKi8gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBTSEEyMjQoKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGEyNTYuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/sha256.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js":
/*!*************************************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js ***!
  \*************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hash: () => (/* binding */ Hash),\n/* harmony export */   asyncLoop: () => (/* binding */ asyncLoop),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   checkOpts: () => (/* binding */ checkOpts),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createView: () => (/* binding */ createView),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   isLE: () => (/* binding */ isLE),\n/* harmony export */   nextTick: () => (/* binding */ nextTick),\n/* harmony export */   randomBytes: () => (/* binding */ randomBytes),\n/* harmony export */   rotr: () => (/* binding */ rotr),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   u32: () => (/* binding */ u32),\n/* harmony export */   u8: () => (/* binding */ u8),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   wrapConstructor: () => (/* binding */ wrapConstructor),\n/* harmony export */   wrapConstructorWithOpts: () => (/* binding */ wrapConstructorWithOpts),\n/* harmony export */   wrapXOFConstructorWithOpts: () => (/* binding */ wrapXOFConstructorWithOpts)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/crypto */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/cryptoNode.js\");\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated, we can just drop the import.\n\nconst u8a = (a) => a instanceof Uint8Array;\n// Cast array to different type\nconst u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nconst u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nconst createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\nconst isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE)\n    throw new Error('Non little-endian hardware is not supported');\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    if (!u8a(bytes))\n        throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const len = hex.length;\n    if (len % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n    const array = new Uint8Array(len / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    if (!u8a(data))\n        throw new Error(`expected Uint8Array, got ${typeof data}`);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n    let pad = 0; // walk through each item, ensure they have proper type\n    arrays.forEach((a) => {\n        if (!u8a(a))\n            throw new Error('Uint8Array expected');\n        r.set(a, pad);\n        pad += a.length;\n    });\n    return r;\n}\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nconst toStr = {}.toString;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nfunction wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nfunction randomBytes(bytesLength = 32) {\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues === 'function') {\n        return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzhDO0FBQzlDO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsMkNBQTJDLGFBQWE7QUFDeEQ7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsNERBQTRELFdBQVc7QUFDdkUsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFlBQVk7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDVDtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxRQUFRLHdEQUFNLFdBQVcsd0RBQU07QUFDL0IsZUFBZSx3REFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbGZnL0dpdC9NYWR0cmlwcy9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vdXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWhhc2hlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gV2UgdXNlIFdlYkNyeXB0byBha2EgZ2xvYmFsVGhpcy5jcnlwdG8sIHdoaWNoIGV4aXN0cyBpbiBicm93c2VycyBhbmQgbm9kZS5qcyAxNisuXG4vLyBub2RlLmpzIHZlcnNpb25zIGVhcmxpZXIgdGhhbiB2MTkgZG9uJ3QgZGVjbGFyZSBpdCBpbiBnbG9iYWwgc2NvcGUuXG4vLyBGb3Igbm9kZS5qcywgcGFja2FnZS5qc29uI2V4cG9ydHMgZmllbGQgbWFwcGluZyByZXdyaXRlcyBpbXBvcnRcbi8vIGZyb20gYGNyeXB0b2AgdG8gYGNyeXB0b05vZGVgLCB3aGljaCBpbXBvcnRzIG5hdGl2ZSBtb2R1bGUuXG4vLyBNYWtlcyB0aGUgdXRpbHMgdW4taW1wb3J0YWJsZSBpbiBicm93c2VycyB3aXRob3V0IGEgYnVuZGxlci5cbi8vIE9uY2Ugbm9kZS5qcyAxOCBpcyBkZXByZWNhdGVkLCB3ZSBjYW4ganVzdCBkcm9wIHRoZSBpbXBvcnQuXG5pbXBvcnQgeyBjcnlwdG8gfSBmcm9tICdAbm9ibGUvaGFzaGVzL2NyeXB0byc7XG5jb25zdCB1OGEgPSAoYSkgPT4gYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XG4vLyBDYXN0IGFycmF5IHRvIGRpZmZlcmVudCB0eXBlXG5leHBvcnQgY29uc3QgdTggPSAoYXJyKSA9PiBuZXcgVWludDhBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xuZXhwb3J0IGNvbnN0IHUzMiA9IChhcnIpID0+IG5ldyBVaW50MzJBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgTWF0aC5mbG9vcihhcnIuYnl0ZUxlbmd0aCAvIDQpKTtcbi8vIENhc3QgYXJyYXkgdG8gdmlld1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVZpZXcgPSAoYXJyKSA9PiBuZXcgRGF0YVZpZXcoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbi8vIFRoZSByb3RhdGUgcmlnaHQgKGNpcmN1bGFyIHJpZ2h0IHNoaWZ0KSBvcGVyYXRpb24gZm9yIHVpbnQzMlxuZXhwb3J0IGNvbnN0IHJvdHIgPSAod29yZCwgc2hpZnQpID0+ICh3b3JkIDw8ICgzMiAtIHNoaWZ0KSkgfCAod29yZCA+Pj4gc2hpZnQpO1xuLy8gYmlnLWVuZGlhbiBoYXJkd2FyZSBpcyByYXJlLiBKdXN0IGluIGNhc2Ugc29tZW9uZSBzdGlsbCBkZWNpZGVzIHRvIHJ1biBoYXNoZXM6XG4vLyBlYXJseS10aHJvdyBhbiBlcnJvciBiZWNhdXNlIHdlIGRvbid0IHN1cHBvcnQgQkUgeWV0LlxuZXhwb3J0IGNvbnN0IGlzTEUgPSBuZXcgVWludDhBcnJheShuZXcgVWludDMyQXJyYXkoWzB4MTEyMjMzNDRdKS5idWZmZXIpWzBdID09PSAweDQ0O1xuaWYgKCFpc0xFKVxuICAgIHRocm93IG5ldyBFcnJvcignTm9uIGxpdHRsZS1lbmRpYW4gaGFyZHdhcmUgaXMgbm90IHN1cHBvcnRlZCcpO1xuY29uc3QgaGV4ZXMgPSAvKiBAX19QVVJFX18gKi8gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sIChfLCBpKSA9PiBpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbi8qKlxuICogQGV4YW1wbGUgYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKSkgLy8gJ2NhZmUwMTIzJ1xuICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuICAgIGlmICghdThhKGJ5dGVzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgLy8gcHJlLWNhY2hpbmcgaW1wcm92ZXMgdGhlIHNwZWVkIDZ4XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IGhleGVzW2J5dGVzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbi8qKlxuICogQGV4YW1wbGUgaGV4VG9CeXRlcygnY2FmZTAxMjMnKSAvLyBVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGV4VG9CeXRlcyhoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICBjb25zdCBsZW4gPSBoZXgubGVuZ3RoO1xuICAgIGlmIChsZW4gJSAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRlZCBoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgdW5wYWRkZWQgaGV4IG9mIGxlbmd0aCAnICsgbGVuKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGxlbiAvIDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaiA9IGkgKiAyO1xuICAgICAgICBjb25zdCBoZXhCeXRlID0gaGV4LnNsaWNlKGosIGogKyAyKTtcbiAgICAgICAgY29uc3QgYnl0ZSA9IE51bWJlci5wYXJzZUludChoZXhCeXRlLCAxNik7XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4oYnl0ZSkgfHwgYnl0ZSA8IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYnl0ZSBzZXF1ZW5jZScpO1xuICAgICAgICBhcnJheVtpXSA9IGJ5dGU7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbi8vIFRoZXJlIGlzIG5vIHNldEltbWVkaWF0ZSBpbiBicm93c2VyIGFuZCBzZXRUaW1lb3V0IGlzIHNsb3cuXG4vLyBjYWxsIG9mIGFzeW5jIGZuIHdpbGwgcmV0dXJuIFByb21pc2UsIHdoaWNoIHdpbGwgYmUgZnVsbGZpbGVkIG9ubHkgb25cbi8vIG5leHQgc2NoZWR1bGVyIHF1ZXVlIHByb2Nlc3Npbmcgc3RlcCBhbmQgdGhpcyBpcyBleGFjdGx5IHdoYXQgd2UgbmVlZC5cbmV4cG9ydCBjb25zdCBuZXh0VGljayA9IGFzeW5jICgpID0+IHsgfTtcbi8vIFJldHVybnMgY29udHJvbCB0byB0aHJlYWQgZWFjaCAndGljaycgbXMgdG8gYXZvaWQgYmxvY2tpbmdcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhc3luY0xvb3AoaXRlcnMsIHRpY2ssIGNiKSB7XG4gICAgbGV0IHRzID0gRGF0ZS5ub3coKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJzOyBpKyspIHtcbiAgICAgICAgY2IoaSk7XG4gICAgICAgIC8vIERhdGUubm93KCkgaXMgbm90IG1vbm90b25pYywgc28gaW4gY2FzZSBpZiBjbG9jayBnb2VzIGJhY2t3YXJkcyB3ZSByZXR1cm4gcmV0dXJuIGNvbnRyb2wgdG9vXG4gICAgICAgIGNvbnN0IGRpZmYgPSBEYXRlLm5vdygpIC0gdHM7XG4gICAgICAgIGlmIChkaWZmID49IDAgJiYgZGlmZiA8IHRpY2spXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgYXdhaXQgbmV4dFRpY2soKTtcbiAgICAgICAgdHMgKz0gZGlmZjtcbiAgICB9XG59XG4vKipcbiAqIEBleGFtcGxlIHV0ZjhUb0J5dGVzKCdhYmMnKSAvLyBuZXcgVWludDhBcnJheShbOTcsIDk4LCA5OV0pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdXRmOFRvQnl0ZXMgZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygc3RyfWApO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSk7IC8vIGh0dHBzOi8vYnVnemlsLmxhLzE2ODE4MDlcbn1cbi8qKlxuICogTm9ybWFsaXplcyAobm9uLWhleCkgc3RyaW5nIG9yIFVpbnQ4QXJyYXkgdG8gVWludDhBcnJheS5cbiAqIFdhcm5pbmc6IHdoZW4gVWludDhBcnJheSBpcyBwYXNzZWQsIGl0IHdvdWxkIE5PVCBnZXQgY29waWVkLlxuICogS2VlcCBpbiBtaW5kIGZvciBmdXR1cmUgbXV0YWJsZSBvcGVyYXRpb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9CeXRlcyhkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJylcbiAgICAgICAgZGF0YSA9IHV0ZjhUb0J5dGVzKGRhdGEpO1xuICAgIGlmICghdThhKGRhdGEpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkIFVpbnQ4QXJyYXksIGdvdCAke3R5cGVvZiBkYXRhfWApO1xuICAgIHJldHVybiBkYXRhO1xufVxuLyoqXG4gKiBDb3BpZXMgc2V2ZXJhbCBVaW50OEFycmF5cyBpbnRvIG9uZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5cykge1xuICAgIGNvbnN0IHIgPSBuZXcgVWludDhBcnJheShhcnJheXMucmVkdWNlKChzdW0sIGEpID0+IHN1bSArIGEubGVuZ3RoLCAwKSk7XG4gICAgbGV0IHBhZCA9IDA7IC8vIHdhbGsgdGhyb3VnaCBlYWNoIGl0ZW0sIGVuc3VyZSB0aGV5IGhhdmUgcHJvcGVyIHR5cGVcbiAgICBhcnJheXMuZm9yRWFjaCgoYSkgPT4ge1xuICAgICAgICBpZiAoIXU4YShhKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgICAgICByLnNldChhLCBwYWQpO1xuICAgICAgICBwYWQgKz0gYS5sZW5ndGg7XG4gICAgfSk7XG4gICAgcmV0dXJuIHI7XG59XG4vLyBGb3IgcnVudGltZSBjaGVjayBpZiBjbGFzcyBpbXBsZW1lbnRzIGludGVyZmFjZVxuZXhwb3J0IGNsYXNzIEhhc2gge1xuICAgIC8vIFNhZmUgdmVyc2lvbiB0aGF0IGNsb25lcyBpbnRlcm5hbCBzdGF0ZVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvbmVJbnRvKCk7XG4gICAgfVxufVxuY29uc3QgdG9TdHIgPSB7fS50b1N0cmluZztcbmV4cG9ydCBmdW5jdGlvbiBjaGVja09wdHMoZGVmYXVsdHMsIG9wdHMpIHtcbiAgICBpZiAob3B0cyAhPT0gdW5kZWZpbmVkICYmIHRvU3RyLmNhbGwob3B0cykgIT09ICdbb2JqZWN0IE9iamVjdF0nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09wdGlvbnMgc2hvdWxkIGJlIG9iamVjdCBvciB1bmRlZmluZWQnKTtcbiAgICBjb25zdCBtZXJnZWQgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRzLCBvcHRzKTtcbiAgICByZXR1cm4gbWVyZ2VkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBDb25zdHJ1Y3RvcihoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZykgPT4gaGFzaENvbnMoKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucygpO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKCkgPT4gaGFzaENvbnMoKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnQgZnVuY3Rpb24gd3JhcENvbnN0cnVjdG9yV2l0aE9wdHMoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIG9wdHMpID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKHt9KTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9IChvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnQgZnVuY3Rpb24gd3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIG9wdHMpID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKHt9KTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9IChvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG4vKipcbiAqIFNlY3VyZSBQUk5HLiBVc2VzIGBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzYCwgd2hpY2ggZGVmZXJzIHRvIE9TLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tQnl0ZXMoYnl0ZXNMZW5ndGggPSAzMikge1xuICAgIGlmIChjcnlwdG8gJiYgdHlwZW9mIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoYnl0ZXNMZW5ndGgpKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIG11c3QgYmUgZGVmaW5lZCcpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/_assert.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/_assert.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bool: () => (/* binding */ bool),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   exists: () => (/* binding */ exists),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   output: () => (/* binding */ output)\n/* harmony export */ });\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`Wrong positive integer: ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`Expected boolean, not ${b}`);\n}\nfunction bytes(b, ...lengths) {\n    if (!(b instanceof Uint8Array))\n        throw new Error('Expected Uint8Array');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(hash) {\n    if (typeof hash !== 'function' || typeof hash.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(hash.outputLen);\n    number(hash.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\nconst assert = {\n    number,\n    bool,\n    bytes,\n    hash,\n    exists,\n    output,\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (assert);\n//# sourceMappingURL=_assert.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX2Fzc2VydC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQU87QUFDUDtBQUNBLG1EQUFtRCxFQUFFO0FBQ3JEO0FBQ087QUFDUDtBQUNBLGlEQUFpRCxFQUFFO0FBQ25EO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsUUFBUSxrQkFBa0IsU0FBUztBQUM1RjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLElBQUk7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBZSxNQUFNLEVBQUM7QUFDdEIiLCJzb3VyY2VzIjpbIi9ob21lL2xmZy9HaXQvTWFkdHJpcHMvbm9kZV9tb2R1bGVzL0Bub3N0ci1kZXYta2l0L25kay9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19hc3NlcnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIG51bWJlcihuKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSB8fCBuIDwgMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXcm9uZyBwb3NpdGl2ZSBpbnRlZ2VyOiAke259YCk7XG59XG5leHBvcnQgZnVuY3Rpb24gYm9vbChiKSB7XG4gICAgaWYgKHR5cGVvZiBiICE9PSAnYm9vbGVhbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYm9vbGVhbiwgbm90ICR7Yn1gKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBieXRlcyhiLCAuLi5sZW5ndGhzKSB7XG4gICAgaWYgKCEoYiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIFVpbnQ4QXJyYXknKTtcbiAgICBpZiAobGVuZ3Rocy5sZW5ndGggPiAwICYmICFsZW5ndGhzLmluY2x1ZGVzKGIubGVuZ3RoKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBVaW50OEFycmF5IG9mIGxlbmd0aCAke2xlbmd0aHN9LCBub3Qgb2YgbGVuZ3RoPSR7Yi5sZW5ndGh9YCk7XG59XG5leHBvcnQgZnVuY3Rpb24gaGFzaChoYXNoKSB7XG4gICAgaWYgKHR5cGVvZiBoYXNoICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBoYXNoLmNyZWF0ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIHNob3VsZCBiZSB3cmFwcGVkIGJ5IHV0aWxzLndyYXBDb25zdHJ1Y3RvcicpO1xuICAgIG51bWJlcihoYXNoLm91dHB1dExlbik7XG4gICAgbnVtYmVyKGhhc2guYmxvY2tMZW4pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGV4aXN0cyhpbnN0YW5jZSwgY2hlY2tGaW5pc2hlZCA9IHRydWUpIHtcbiAgICBpZiAoaW5zdGFuY2UuZGVzdHJveWVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkJyk7XG4gICAgaWYgKGNoZWNrRmluaXNoZWQgJiYgaW5zdGFuY2UuZmluaXNoZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCNkaWdlc3QoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZCcpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG91dHB1dChvdXQsIGluc3RhbmNlKSB7XG4gICAgYnl0ZXMob3V0KTtcbiAgICBjb25zdCBtaW4gPSBpbnN0YW5jZS5vdXRwdXRMZW47XG4gICAgaWYgKG91dC5sZW5ndGggPCBtaW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkaWdlc3RJbnRvKCkgZXhwZWN0cyBvdXRwdXQgYnVmZmVyIG9mIGxlbmd0aCBhdCBsZWFzdCAke21pbn1gKTtcbiAgICB9XG59XG5jb25zdCBhc3NlcnQgPSB7XG4gICAgbnVtYmVyLFxuICAgIGJvb2wsXG4gICAgYnl0ZXMsXG4gICAgaGFzaCxcbiAgICBleGlzdHMsXG4gICAgb3V0cHV0LFxufTtcbmV4cG9ydCBkZWZhdWx0IGFzc2VydDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9hc3NlcnQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/_assert.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/_sha2.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/_sha2.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHA2: () => (/* binding */ SHA2)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nclass SHA2 extends _utils_js__WEBPACK_IMPORTED_MODULE_1__.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createView)(this.buffer);\n    }\n    update(data) {\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].exists(this);\n        const { view, buffer, blockLen } = this;\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createView)(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].exists(this);\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].output(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n//# sourceMappingURL=_sha2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX3NoYTIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWtDO0FBQ3FCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxtQkFBbUIsMkNBQUk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxREFBVTtBQUM5QjtBQUNBO0FBQ0EsUUFBUSx5REFBYTtBQUNyQixnQkFBZ0IseUJBQXlCO0FBQ3pDLGVBQWUsa0RBQU87QUFDdEI7QUFDQSwwQkFBMEIsVUFBVTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMscURBQVU7QUFDM0MsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEseURBQWE7QUFDckIsUUFBUSx5REFBYTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQkFBK0I7QUFDL0MsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxREFBVTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFEQUFxRDtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL2hvbWUvbGZnL0dpdC9NYWR0cmlwcy9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX3NoYTIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGFzc2VydCBmcm9tICcuL19hc3NlcnQuanMnO1xuaW1wb3J0IHsgSGFzaCwgY3JlYXRlVmlldywgdG9CeXRlcyB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gUG9seWZpbGwgZm9yIFNhZmFyaSAxNFxuZnVuY3Rpb24gc2V0QmlnVWludDY0KHZpZXcsIGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKSB7XG4gICAgaWYgKHR5cGVvZiB2aWV3LnNldEJpZ1VpbnQ2NCA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgcmV0dXJuIHZpZXcuc2V0QmlnVWludDY0KGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKTtcbiAgICBjb25zdCBfMzJuID0gQmlnSW50KDMyKTtcbiAgICBjb25zdCBfdTMyX21heCA9IEJpZ0ludCgweGZmZmZmZmZmKTtcbiAgICBjb25zdCB3aCA9IE51bWJlcigodmFsdWUgPj4gXzMybikgJiBfdTMyX21heCk7XG4gICAgY29uc3Qgd2wgPSBOdW1iZXIodmFsdWUgJiBfdTMyX21heCk7XG4gICAgY29uc3QgaCA9IGlzTEUgPyA0IDogMDtcbiAgICBjb25zdCBsID0gaXNMRSA/IDAgOiA0O1xuICAgIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBoLCB3aCwgaXNMRSk7XG4gICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGwsIHdsLCBpc0xFKTtcbn1cbi8vIEJhc2UgU0hBMiBjbGFzcyAoUkZDIDYyMzQpXG5leHBvcnQgY2xhc3MgU0hBMiBleHRlbmRzIEhhc2gge1xuICAgIGNvbnN0cnVjdG9yKGJsb2NrTGVuLCBvdXRwdXRMZW4sIHBhZE9mZnNldCwgaXNMRSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0aGlzLnBhZE9mZnNldCA9IHBhZE9mZnNldDtcbiAgICAgICAgdGhpcy5pc0xFID0gaXNMRTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgVWludDhBcnJheShibG9ja0xlbik7XG4gICAgICAgIHRoaXMudmlldyA9IGNyZWF0ZVZpZXcodGhpcy5idWZmZXIpO1xuICAgIH1cbiAgICB1cGRhdGUoZGF0YSkge1xuICAgICAgICBhc3NlcnQuZXhpc3RzKHRoaXMpO1xuICAgICAgICBjb25zdCB7IHZpZXcsIGJ1ZmZlciwgYmxvY2tMZW4gfSA9IHRoaXM7XG4gICAgICAgIGRhdGEgPSB0b0J5dGVzKGRhdGEpO1xuICAgICAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3MsIGxlbiAtIHBvcyk7XG4gICAgICAgICAgICAvLyBGYXN0IHBhdGg6IHdlIGhhdmUgYXQgbGVhc3Qgb25lIGJsb2NrIGluIGlucHV0LCBjYXN0IGl0IHRvIHZpZXcgYW5kIHByb2Nlc3NcbiAgICAgICAgICAgIGlmICh0YWtlID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFWaWV3ID0gY3JlYXRlVmlldyhkYXRhKTtcbiAgICAgICAgICAgICAgICBmb3IgKDsgYmxvY2tMZW4gPD0gbGVuIC0gcG9zOyBwb3MgKz0gYmxvY2tMZW4pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2VzcyhkYXRhVmlldywgcG9zKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlci5zZXQoZGF0YS5zdWJhcnJheShwb3MsIHBvcyArIHRha2UpLCB0aGlzLnBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSB0YWtlO1xuICAgICAgICAgICAgcG9zICs9IHRha2U7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxlbmd0aCArPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgdGhpcy5yb3VuZENsZWFuKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBhc3NlcnQuZXhpc3RzKHRoaXMpO1xuICAgICAgICBhc3NlcnQub3V0cHV0KG91dCwgdGhpcyk7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAvLyBQYWRkaW5nXG4gICAgICAgIC8vIFdlIGNhbiBhdm9pZCBhbGxvY2F0aW9uIG9mIGJ1ZmZlciBmb3IgcGFkZGluZyBjb21wbGV0ZWx5IGlmIGl0XG4gICAgICAgIC8vIHdhcyBwcmV2aW91c2x5IG5vdCBhbGxvY2F0ZWQgaGVyZS4gQnV0IGl0IHdvbid0IGNoYW5nZSBwZXJmb3JtYW5jZS5cbiAgICAgICAgY29uc3QgeyBidWZmZXIsIHZpZXcsIGJsb2NrTGVuLCBpc0xFIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBwb3MgfSA9IHRoaXM7XG4gICAgICAgIC8vIGFwcGVuZCB0aGUgYml0ICcxJyB0byB0aGUgbWVzc2FnZVxuICAgICAgICBidWZmZXJbcG9zKytdID0gMGIxMDAwMDAwMDtcbiAgICAgICAgdGhpcy5idWZmZXIuc3ViYXJyYXkocG9zKS5maWxsKDApO1xuICAgICAgICAvLyB3ZSBoYXZlIGxlc3MgdGhhbiBwYWRPZmZzZXQgbGVmdCBpbiBidWZmZXIsIHNvIHdlIGNhbm5vdCBwdXQgbGVuZ3RoIGluIGN1cnJlbnQgYmxvY2ssIG5lZWQgcHJvY2VzcyBpdCBhbmQgcGFkIGFnYWluXG4gICAgICAgIGlmICh0aGlzLnBhZE9mZnNldCA+IGJsb2NrTGVuIC0gcG9zKSB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgICAgICBwb3MgPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBhZCB1bnRpbCBmdWxsIGJsb2NrIGJ5dGUgd2l0aCB6ZXJvc1xuICAgICAgICBmb3IgKGxldCBpID0gcG9zOyBpIDwgYmxvY2tMZW47IGkrKylcbiAgICAgICAgICAgIGJ1ZmZlcltpXSA9IDA7XG4gICAgICAgIC8vIE5vdGU6IHNoYTUxMiByZXF1aXJlcyBsZW5ndGggdG8gYmUgMTI4Yml0IGludGVnZXIsIGJ1dCBsZW5ndGggaW4gSlMgd2lsbCBvdmVyZmxvdyBiZWZvcmUgdGhhdFxuICAgICAgICAvLyBZb3UgbmVlZCB0byB3cml0ZSBhcm91bmQgMiBleGFieXRlcyAodTY0X21heCAvIDggLyAoMTAyNCoqNikpIGZvciB0aGlzIHRvIGhhcHBlbi5cbiAgICAgICAgLy8gU28gd2UganVzdCB3cml0ZSBsb3dlc3QgNjQgYml0cyBvZiB0aGF0IHZhbHVlLlxuICAgICAgICBzZXRCaWdVaW50NjQodmlldywgYmxvY2tMZW4gLSA4LCBCaWdJbnQodGhpcy5sZW5ndGggKiA4KSwgaXNMRSk7XG4gICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgY29uc3Qgb3ZpZXcgPSBjcmVhdGVWaWV3KG91dCk7XG4gICAgICAgIGNvbnN0IGxlbiA9IHRoaXMub3V0cHV0TGVuO1xuICAgICAgICAvLyBOT1RFOiB3ZSBkbyBkaXZpc2lvbiBieSA0IGxhdGVyLCB3aGljaCBzaG91bGQgYmUgZnVzZWQgaW4gc2luZ2xlIG9wIHdpdGggbW9kdWxvIGJ5IEpJVFxuICAgICAgICBpZiAobGVuICUgNClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX3NoYTI6IG91dHB1dExlbiBzaG91bGQgYmUgYWxpZ25lZCB0byAzMmJpdCcpO1xuICAgICAgICBjb25zdCBvdXRMZW4gPSBsZW4gLyA0O1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0KCk7XG4gICAgICAgIGlmIChvdXRMZW4gPiBzdGF0ZS5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ19zaGEyOiBvdXRwdXRMZW4gYmlnZ2VyIHRoYW4gc3RhdGUnKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRMZW47IGkrKylcbiAgICAgICAgICAgIG92aWV3LnNldFVpbnQzMig0ICogaSwgc3RhdGVbaV0sIGlzTEUpO1xuICAgIH1cbiAgICBkaWdlc3QoKSB7XG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCBvdXRwdXRMZW4gfSA9IHRoaXM7XG4gICAgICAgIHRoaXMuZGlnZXN0SW50byhidWZmZXIpO1xuICAgICAgICBjb25zdCByZXMgPSBidWZmZXIuc2xpY2UoMCwgb3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIF9jbG9uZUludG8odG8pIHtcbiAgICAgICAgdG8gfHwgKHRvID0gbmV3IHRoaXMuY29uc3RydWN0b3IoKSk7XG4gICAgICAgIHRvLnNldCguLi50aGlzLmdldCgpKTtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiwgYnVmZmVyLCBsZW5ndGgsIGZpbmlzaGVkLCBkZXN0cm95ZWQsIHBvcyB9ID0gdGhpcztcbiAgICAgICAgdG8ubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0by5wb3MgPSBwb3M7XG4gICAgICAgIHRvLmZpbmlzaGVkID0gZmluaXNoZWQ7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IGRlc3Ryb3llZDtcbiAgICAgICAgaWYgKGxlbmd0aCAlIGJsb2NrTGVuKVxuICAgICAgICAgICAgdG8uYnVmZmVyLnNldChidWZmZXIpO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3NoYTIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/_sha2.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/cryptoNode.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/cryptoNode.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   crypto: () => (/* binding */ crypto)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// See utils.ts for details.\n// The file will throw on node.js 14 and earlier.\n// @ts-ignore\n\nconst crypto = /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) && typeof /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) === 'object' && \"webcrypto\" in /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) ? node_crypto__WEBPACK_IMPORTED_MODULE_0__.webcrypto : undefined;\n//# sourceMappingURL=cryptoNode.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vY3J5cHRvTm9kZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNrQztBQUMzQixlQUFlLDJNQUFFLFdBQVcsMk1BQUUsaUJBQWlCLDBOQUFpQixHQUFHLGtEQUFZO0FBQ3RGIiwic291cmNlcyI6WyIvaG9tZS9sZmcvR2l0L01hZHRyaXBzL25vZGVfbW9kdWxlcy9Abm9zdHItZGV2LWtpdC9uZGsvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9jcnlwdG9Ob2RlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFdlIHVzZSBXZWJDcnlwdG8gYWthIGdsb2JhbFRoaXMuY3J5cHRvLCB3aGljaCBleGlzdHMgaW4gYnJvd3NlcnMgYW5kIG5vZGUuanMgMTYrLlxuLy8gU2VlIHV0aWxzLnRzIGZvciBkZXRhaWxzLlxuLy8gVGhlIGZpbGUgd2lsbCB0aHJvdyBvbiBub2RlLmpzIDE0IGFuZCBlYXJsaWVyLlxuLy8gQHRzLWlnbm9yZVxuaW1wb3J0ICogYXMgbmMgZnJvbSAnbm9kZTpjcnlwdG8nO1xuZXhwb3J0IGNvbnN0IGNyeXB0byA9IG5jICYmIHR5cGVvZiBuYyA9PT0gJ29iamVjdCcgJiYgJ3dlYmNyeXB0bycgaW4gbmMgPyBuYy53ZWJjcnlwdG8gOiB1bmRlZmluZWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcnlwdG9Ob2RlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/cryptoNode.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/hkdf.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/hkdf.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   expand: () => (/* binding */ expand),\n/* harmony export */   extract: () => (/* binding */ extract),\n/* harmony export */   hkdf: () => (/* binding */ hkdf)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _hmac_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./hmac.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/hmac.js\");\n\n\n\n// HKDF (RFC 5869)\n// https://soatok.blog/2021/11/17/understanding-hkdf/\n/**\n * HKDF-Extract(IKM, salt) -> PRK\n * Arguments position differs from spec (IKM is first one, since it is not optional)\n * @param hash\n * @param ikm\n * @param salt\n * @returns\n */\nfunction extract(hash, ikm, salt) {\n    _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].hash(hash);\n    // NOTE: some libraries treat zero-length array as 'not provided';\n    // we don't, since we have undefined as 'not provided'\n    // https://github.com/RustCrypto/KDFs/issues/15\n    if (salt === undefined)\n        salt = new Uint8Array(hash.outputLen); // if not provided, it is set to a string of HashLen zeros\n    return (0,_hmac_js__WEBPACK_IMPORTED_MODULE_2__.hmac)(hash, (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(salt), (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(ikm));\n}\n// HKDF-Expand(PRK, info, L) -> OKM\nconst HKDF_COUNTER = new Uint8Array([0]);\nconst EMPTY_BUFFER = new Uint8Array();\n/**\n * HKDF-expand from the spec.\n * @param prk - a pseudorandom key of at least HashLen octets (usually, the output from the extract step)\n * @param info - optional context and application specific information (can be a zero-length string)\n * @param length - length of output keying material in octets\n */\nfunction expand(hash, prk, info, length = 32) {\n    _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].hash(hash);\n    _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].number(length);\n    if (length > 255 * hash.outputLen)\n        throw new Error('Length should be <= 255*HashLen');\n    const blocks = Math.ceil(length / hash.outputLen);\n    if (info === undefined)\n        info = EMPTY_BUFFER;\n    // first L(ength) octets of T\n    const okm = new Uint8Array(blocks * hash.outputLen);\n    // Re-use HMAC instance between blocks\n    const HMAC = _hmac_js__WEBPACK_IMPORTED_MODULE_2__.hmac.create(hash, prk);\n    const HMACTmp = HMAC._cloneInto();\n    const T = new Uint8Array(HMAC.outputLen);\n    for (let counter = 0; counter < blocks; counter++) {\n        HKDF_COUNTER[0] = counter + 1;\n        // T(0) = empty string (zero length)\n        // T(N) = HMAC-Hash(PRK, T(N-1) | info | N)\n        HMACTmp.update(counter === 0 ? EMPTY_BUFFER : T)\n            .update(info)\n            .update(HKDF_COUNTER)\n            .digestInto(T);\n        okm.set(T, hash.outputLen * counter);\n        HMAC._cloneInto(HMACTmp);\n    }\n    HMAC.destroy();\n    HMACTmp.destroy();\n    T.fill(0);\n    HKDF_COUNTER.fill(0);\n    return okm.slice(0, length);\n}\n/**\n * HKDF (RFC 5869): extract + expand in one step.\n * @param hash - hash function that would be used (e.g. sha256)\n * @param ikm - input keying material, the initial key\n * @param salt - optional salt value (a non-secret random value)\n * @param info - optional context and application specific information\n * @param length - length of output keying material in octets\n */\nconst hkdf = (hash, ikm, salt, info, length) => expand(hash, extract(hash, ikm, salt), info, length);\n//# sourceMappingURL=hkdf.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vaGtkZi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBa0M7QUFDRztBQUNKO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxJQUFJLHVEQUFXO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0MsV0FBVyw4Q0FBSSxPQUFPLGtEQUFPLFFBQVEsa0RBQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLElBQUksdURBQVc7QUFDZixJQUFJLHlEQUFhO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMENBQUk7QUFDckI7QUFDQTtBQUNBLDBCQUEwQixrQkFBa0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCIsInNvdXJjZXMiOlsiL2hvbWUvbGZnL0dpdC9NYWR0cmlwcy9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vaGtkZi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYXNzZXJ0IGZyb20gJy4vX2Fzc2VydC5qcyc7XG5pbXBvcnQgeyB0b0J5dGVzIH0gZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgeyBobWFjIH0gZnJvbSAnLi9obWFjLmpzJztcbi8vIEhLREYgKFJGQyA1ODY5KVxuLy8gaHR0cHM6Ly9zb2F0b2suYmxvZy8yMDIxLzExLzE3L3VuZGVyc3RhbmRpbmctaGtkZi9cbi8qKlxuICogSEtERi1FeHRyYWN0KElLTSwgc2FsdCkgLT4gUFJLXG4gKiBBcmd1bWVudHMgcG9zaXRpb24gZGlmZmVycyBmcm9tIHNwZWMgKElLTSBpcyBmaXJzdCBvbmUsIHNpbmNlIGl0IGlzIG5vdCBvcHRpb25hbClcbiAqIEBwYXJhbSBoYXNoXG4gKiBAcGFyYW0gaWttXG4gKiBAcGFyYW0gc2FsdFxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3QoaGFzaCwgaWttLCBzYWx0KSB7XG4gICAgYXNzZXJ0Lmhhc2goaGFzaCk7XG4gICAgLy8gTk9URTogc29tZSBsaWJyYXJpZXMgdHJlYXQgemVyby1sZW5ndGggYXJyYXkgYXMgJ25vdCBwcm92aWRlZCc7XG4gICAgLy8gd2UgZG9uJ3QsIHNpbmNlIHdlIGhhdmUgdW5kZWZpbmVkIGFzICdub3QgcHJvdmlkZWQnXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL1J1c3RDcnlwdG8vS0RGcy9pc3N1ZXMvMTVcbiAgICBpZiAoc2FsdCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICBzYWx0ID0gbmV3IFVpbnQ4QXJyYXkoaGFzaC5vdXRwdXRMZW4pOyAvLyBpZiBub3QgcHJvdmlkZWQsIGl0IGlzIHNldCB0byBhIHN0cmluZyBvZiBIYXNoTGVuIHplcm9zXG4gICAgcmV0dXJuIGhtYWMoaGFzaCwgdG9CeXRlcyhzYWx0KSwgdG9CeXRlcyhpa20pKTtcbn1cbi8vIEhLREYtRXhwYW5kKFBSSywgaW5mbywgTCkgLT4gT0tNXG5jb25zdCBIS0RGX0NPVU5URVIgPSBuZXcgVWludDhBcnJheShbMF0pO1xuY29uc3QgRU1QVFlfQlVGRkVSID0gbmV3IFVpbnQ4QXJyYXkoKTtcbi8qKlxuICogSEtERi1leHBhbmQgZnJvbSB0aGUgc3BlYy5cbiAqIEBwYXJhbSBwcmsgLSBhIHBzZXVkb3JhbmRvbSBrZXkgb2YgYXQgbGVhc3QgSGFzaExlbiBvY3RldHMgKHVzdWFsbHksIHRoZSBvdXRwdXQgZnJvbSB0aGUgZXh0cmFjdCBzdGVwKVxuICogQHBhcmFtIGluZm8gLSBvcHRpb25hbCBjb250ZXh0IGFuZCBhcHBsaWNhdGlvbiBzcGVjaWZpYyBpbmZvcm1hdGlvbiAoY2FuIGJlIGEgemVyby1sZW5ndGggc3RyaW5nKVxuICogQHBhcmFtIGxlbmd0aCAtIGxlbmd0aCBvZiBvdXRwdXQga2V5aW5nIG1hdGVyaWFsIGluIG9jdGV0c1xuICovXG5leHBvcnQgZnVuY3Rpb24gZXhwYW5kKGhhc2gsIHByaywgaW5mbywgbGVuZ3RoID0gMzIpIHtcbiAgICBhc3NlcnQuaGFzaChoYXNoKTtcbiAgICBhc3NlcnQubnVtYmVyKGxlbmd0aCk7XG4gICAgaWYgKGxlbmd0aCA+IDI1NSAqIGhhc2gub3V0cHV0TGVuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xlbmd0aCBzaG91bGQgYmUgPD0gMjU1Kkhhc2hMZW4nKTtcbiAgICBjb25zdCBibG9ja3MgPSBNYXRoLmNlaWwobGVuZ3RoIC8gaGFzaC5vdXRwdXRMZW4pO1xuICAgIGlmIChpbmZvID09PSB1bmRlZmluZWQpXG4gICAgICAgIGluZm8gPSBFTVBUWV9CVUZGRVI7XG4gICAgLy8gZmlyc3QgTChlbmd0aCkgb2N0ZXRzIG9mIFRcbiAgICBjb25zdCBva20gPSBuZXcgVWludDhBcnJheShibG9ja3MgKiBoYXNoLm91dHB1dExlbik7XG4gICAgLy8gUmUtdXNlIEhNQUMgaW5zdGFuY2UgYmV0d2VlbiBibG9ja3NcbiAgICBjb25zdCBITUFDID0gaG1hYy5jcmVhdGUoaGFzaCwgcHJrKTtcbiAgICBjb25zdCBITUFDVG1wID0gSE1BQy5fY2xvbmVJbnRvKCk7XG4gICAgY29uc3QgVCA9IG5ldyBVaW50OEFycmF5KEhNQUMub3V0cHV0TGVuKTtcbiAgICBmb3IgKGxldCBjb3VudGVyID0gMDsgY291bnRlciA8IGJsb2NrczsgY291bnRlcisrKSB7XG4gICAgICAgIEhLREZfQ09VTlRFUlswXSA9IGNvdW50ZXIgKyAxO1xuICAgICAgICAvLyBUKDApID0gZW1wdHkgc3RyaW5nICh6ZXJvIGxlbmd0aClcbiAgICAgICAgLy8gVChOKSA9IEhNQUMtSGFzaChQUkssIFQoTi0xKSB8IGluZm8gfCBOKVxuICAgICAgICBITUFDVG1wLnVwZGF0ZShjb3VudGVyID09PSAwID8gRU1QVFlfQlVGRkVSIDogVClcbiAgICAgICAgICAgIC51cGRhdGUoaW5mbylcbiAgICAgICAgICAgIC51cGRhdGUoSEtERl9DT1VOVEVSKVxuICAgICAgICAgICAgLmRpZ2VzdEludG8oVCk7XG4gICAgICAgIG9rbS5zZXQoVCwgaGFzaC5vdXRwdXRMZW4gKiBjb3VudGVyKTtcbiAgICAgICAgSE1BQy5fY2xvbmVJbnRvKEhNQUNUbXApO1xuICAgIH1cbiAgICBITUFDLmRlc3Ryb3koKTtcbiAgICBITUFDVG1wLmRlc3Ryb3koKTtcbiAgICBULmZpbGwoMCk7XG4gICAgSEtERl9DT1VOVEVSLmZpbGwoMCk7XG4gICAgcmV0dXJuIG9rbS5zbGljZSgwLCBsZW5ndGgpO1xufVxuLyoqXG4gKiBIS0RGIChSRkMgNTg2OSk6IGV4dHJhY3QgKyBleHBhbmQgaW4gb25lIHN0ZXAuXG4gKiBAcGFyYW0gaGFzaCAtIGhhc2ggZnVuY3Rpb24gdGhhdCB3b3VsZCBiZSB1c2VkIChlLmcuIHNoYTI1NilcbiAqIEBwYXJhbSBpa20gLSBpbnB1dCBrZXlpbmcgbWF0ZXJpYWwsIHRoZSBpbml0aWFsIGtleVxuICogQHBhcmFtIHNhbHQgLSBvcHRpb25hbCBzYWx0IHZhbHVlIChhIG5vbi1zZWNyZXQgcmFuZG9tIHZhbHVlKVxuICogQHBhcmFtIGluZm8gLSBvcHRpb25hbCBjb250ZXh0IGFuZCBhcHBsaWNhdGlvbiBzcGVjaWZpYyBpbmZvcm1hdGlvblxuICogQHBhcmFtIGxlbmd0aCAtIGxlbmd0aCBvZiBvdXRwdXQga2V5aW5nIG1hdGVyaWFsIGluIG9jdGV0c1xuICovXG5leHBvcnQgY29uc3QgaGtkZiA9IChoYXNoLCBpa20sIHNhbHQsIGluZm8sIGxlbmd0aCkgPT4gZXhwYW5kKGhhc2gsIGV4dHJhY3QoaGFzaCwgaWttLCBzYWx0KSwgaW5mbywgbGVuZ3RoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhrZGYuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/hkdf.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/hmac.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/hmac.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HMAC: () => (/* binding */ HMAC),\n/* harmony export */   hmac: () => (/* binding */ hmac)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// HMAC (RFC 2104)\nclass HMAC extends _utils_js__WEBPACK_IMPORTED_MODULE_1__.Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].hash(hash);\n        const key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].exists(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].exists(this);\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].bytes(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */\nconst hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key) => new HMAC(hash, key);\n//# sourceMappingURL=hmac.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vaG1hYy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWtDO0FBQ1M7QUFDM0M7QUFDTyxtQkFBbUIsMkNBQUk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFXO0FBQ25CLG9CQUFvQixrREFBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlEQUFhO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx5REFBYTtBQUNyQixRQUFRLHdEQUFZO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFLGdCQUFnQix5REFBeUQ7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBIiwic291cmNlcyI6WyIvaG9tZS9sZmcvR2l0L01hZHRyaXBzL25vZGVfbW9kdWxlcy9Abm9zdHItZGV2LWtpdC9uZGsvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9obWFjLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBhc3NlcnQgZnJvbSAnLi9fYXNzZXJ0LmpzJztcbmltcG9ydCB7IEhhc2gsIHRvQnl0ZXMgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIEhNQUMgKFJGQyAyMTA0KVxuZXhwb3J0IGNsYXNzIEhNQUMgZXh0ZW5kcyBIYXNoIHtcbiAgICBjb25zdHJ1Y3RvcihoYXNoLCBfa2V5KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgYXNzZXJ0Lmhhc2goaGFzaCk7XG4gICAgICAgIGNvbnN0IGtleSA9IHRvQnl0ZXMoX2tleSk7XG4gICAgICAgIHRoaXMuaUhhc2ggPSBoYXNoLmNyZWF0ZSgpO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuaUhhc2gudXBkYXRlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBpbnN0YW5jZSBvZiBjbGFzcyB3aGljaCBleHRlbmRzIHV0aWxzLkhhc2gnKTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IHRoaXMuaUhhc2guYmxvY2tMZW47XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gdGhpcy5pSGFzaC5vdXRwdXRMZW47XG4gICAgICAgIGNvbnN0IGJsb2NrTGVuID0gdGhpcy5ibG9ja0xlbjtcbiAgICAgICAgY29uc3QgcGFkID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tMZW4pO1xuICAgICAgICAvLyBibG9ja0xlbiBjYW4gYmUgYmlnZ2VyIHRoYW4gb3V0cHV0TGVuXG4gICAgICAgIHBhZC5zZXQoa2V5Lmxlbmd0aCA+IGJsb2NrTGVuID8gaGFzaC5jcmVhdGUoKS51cGRhdGUoa2V5KS5kaWdlc3QoKSA6IGtleSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcGFkW2ldIF49IDB4MzY7XG4gICAgICAgIHRoaXMuaUhhc2gudXBkYXRlKHBhZCk7XG4gICAgICAgIC8vIEJ5IGRvaW5nIHVwZGF0ZSAocHJvY2Vzc2luZyBvZiBmaXJzdCBibG9jaykgb2Ygb3V0ZXIgaGFzaCBoZXJlIHdlIGNhbiByZS11c2UgaXQgYmV0d2VlbiBtdWx0aXBsZSBjYWxscyB2aWEgY2xvbmVcbiAgICAgICAgdGhpcy5vSGFzaCA9IGhhc2guY3JlYXRlKCk7XG4gICAgICAgIC8vIFVuZG8gaW50ZXJuYWwgWE9SICYmIGFwcGx5IG91dGVyIFhPUlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHBhZFtpXSBePSAweDM2IF4gMHg1YztcbiAgICAgICAgdGhpcy5vSGFzaC51cGRhdGUocGFkKTtcbiAgICAgICAgcGFkLmZpbGwoMCk7XG4gICAgfVxuICAgIHVwZGF0ZShidWYpIHtcbiAgICAgICAgYXNzZXJ0LmV4aXN0cyh0aGlzKTtcbiAgICAgICAgdGhpcy5pSGFzaC51cGRhdGUoYnVmKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgIGFzc2VydC5leGlzdHModGhpcyk7XG4gICAgICAgIGFzc2VydC5ieXRlcyhvdXQsIHRoaXMub3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuaUhhc2guZGlnZXN0SW50byhvdXQpO1xuICAgICAgICB0aGlzLm9IYXNoLnVwZGF0ZShvdXQpO1xuICAgICAgICB0aGlzLm9IYXNoLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3Qgb3V0ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5vSGFzaC5vdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICAvLyBDcmVhdGUgbmV3IGluc3RhbmNlIHdpdGhvdXQgY2FsbGluZyBjb25zdHJ1Y3RvciBzaW5jZSBrZXkgYWxyZWFkeSBpbiBzdGF0ZSBhbmQgd2UgZG9uJ3Qga25vdyBpdC5cbiAgICAgICAgdG8gfHwgKHRvID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyksIHt9KSk7XG4gICAgICAgIGNvbnN0IHsgb0hhc2gsIGlIYXNoLCBmaW5pc2hlZCwgZGVzdHJveWVkLCBibG9ja0xlbiwgb3V0cHV0TGVuIH0gPSB0aGlzO1xuICAgICAgICB0byA9IHRvO1xuICAgICAgICB0by5maW5pc2hlZCA9IGZpbmlzaGVkO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSBkZXN0cm95ZWQ7XG4gICAgICAgIHRvLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRvLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdG8ub0hhc2ggPSBvSGFzaC5fY2xvbmVJbnRvKHRvLm9IYXNoKTtcbiAgICAgICAgdG8uaUhhc2ggPSBpSGFzaC5fY2xvbmVJbnRvKHRvLmlIYXNoKTtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIHRoaXMub0hhc2guZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmlIYXNoLmRlc3Ryb3koKTtcbiAgICB9XG59XG4vKipcbiAqIEhNQUM6IFJGQzIxMDQgbWVzc2FnZSBhdXRoZW50aWNhdGlvbiBjb2RlLlxuICogQHBhcmFtIGhhc2ggLSBmdW5jdGlvbiB0aGF0IHdvdWxkIGJlIHVzZWQgZS5nLiBzaGEyNTZcbiAqIEBwYXJhbSBrZXkgLSBtZXNzYWdlIGtleVxuICogQHBhcmFtIG1lc3NhZ2UgLSBtZXNzYWdlIGRhdGFcbiAqL1xuZXhwb3J0IGNvbnN0IGhtYWMgPSAoaGFzaCwga2V5LCBtZXNzYWdlKSA9PiBuZXcgSE1BQyhoYXNoLCBrZXkpLnVwZGF0ZShtZXNzYWdlKS5kaWdlc3QoKTtcbmhtYWMuY3JlYXRlID0gKGhhc2gsIGtleSkgPT4gbmV3IEhNQUMoaGFzaCwga2V5KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhtYWMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/hmac.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/sha256.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/sha256.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sha224: () => (/* binding */ sha224),\n/* harmony export */   sha256: () => (/* binding */ sha256)\n/* harmony export */ });\n/* harmony import */ var _sha2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_sha2.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/_sha2.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// Choice: a ? b : c\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = new Uint32Array(64);\nclass SHA256 extends _sha2_js__WEBPACK_IMPORTED_MODULE_0__.SHA2 {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = IV[0] | 0;\n        this.B = IV[1] | 0;\n        this.C = IV[2] | 0;\n        this.D = IV[3] | 0;\n        this.E = IV[4] | 0;\n        this.F = IV[5] | 0;\n        this.G = IV[6] | 0;\n        this.H = IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 7) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 18) ^ (W15 >>> 3);\n            const s1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 17) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 6) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 11) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 2) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 13) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nconst sha256 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA256());\nconst sha224 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA224());\n//# sourceMappingURL=sha256.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vc2hhMjU2LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBa0M7QUFDaUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMENBQUk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5QkFBeUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0EsdUJBQXVCLCtDQUFJLFdBQVcsK0NBQUk7QUFDMUMsdUJBQXVCLCtDQUFJLFdBQVcsK0NBQUk7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsY0FBYyx5QkFBeUI7QUFDdkMsd0JBQXdCLFFBQVE7QUFDaEMsMkJBQTJCLCtDQUFJLFNBQVMsK0NBQUksVUFBVSwrQ0FBSTtBQUMxRDtBQUNBLDJCQUEyQiwrQ0FBSSxTQUFTLCtDQUFJLFVBQVUsK0NBQUk7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sZUFBZSwwREFBZTtBQUM5QixlQUFlLDBEQUFlO0FBQ3JDIiwic291cmNlcyI6WyIvaG9tZS9sZmcvR2l0L01hZHRyaXBzL25vZGVfbW9kdWxlcy9Abm9zdHItZGV2LWtpdC9uZGsvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGEyNTYuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU0hBMiB9IGZyb20gJy4vX3NoYTIuanMnO1xuaW1wb3J0IHsgcm90ciwgd3JhcENvbnN0cnVjdG9yIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBDaG9pY2U6IGEgPyBiIDogY1xuY29uc3QgQ2hpID0gKGEsIGIsIGMpID0+IChhICYgYikgXiAofmEgJiBjKTtcbi8vIE1ham9yaXR5IGZ1bmN0aW9uLCB0cnVlIGlmIGFueSB0d28gaW5wdXN0IGlzIHRydWVcbmNvbnN0IE1haiA9IChhLCBiLCBjKSA9PiAoYSAmIGIpIF4gKGEgJiBjKSBeIChiICYgYyk7XG4vLyBSb3VuZCBjb25zdGFudHM6XG4vLyBmaXJzdCAzMiBiaXRzIG9mIHRoZSBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBjdWJlIHJvb3RzIG9mIHRoZSBmaXJzdCA2NCBwcmltZXMgMi4uMzExKVxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBTSEEyNTZfSyA9IG5ldyBVaW50MzJBcnJheShbXG4gICAgMHg0MjhhMmY5OCwgMHg3MTM3NDQ5MSwgMHhiNWMwZmJjZiwgMHhlOWI1ZGJhNSwgMHgzOTU2YzI1YiwgMHg1OWYxMTFmMSwgMHg5MjNmODJhNCwgMHhhYjFjNWVkNSxcbiAgICAweGQ4MDdhYTk4LCAweDEyODM1YjAxLCAweDI0MzE4NWJlLCAweDU1MGM3ZGMzLCAweDcyYmU1ZDc0LCAweDgwZGViMWZlLCAweDliZGMwNmE3LCAweGMxOWJmMTc0LFxuICAgIDB4ZTQ5YjY5YzEsIDB4ZWZiZTQ3ODYsIDB4MGZjMTlkYzYsIDB4MjQwY2ExY2MsIDB4MmRlOTJjNmYsIDB4NGE3NDg0YWEsIDB4NWNiMGE5ZGMsIDB4NzZmOTg4ZGEsXG4gICAgMHg5ODNlNTE1MiwgMHhhODMxYzY2ZCwgMHhiMDAzMjdjOCwgMHhiZjU5N2ZjNywgMHhjNmUwMGJmMywgMHhkNWE3OTE0NywgMHgwNmNhNjM1MSwgMHgxNDI5Mjk2NyxcbiAgICAweDI3YjcwYTg1LCAweDJlMWIyMTM4LCAweDRkMmM2ZGZjLCAweDUzMzgwZDEzLCAweDY1MGE3MzU0LCAweDc2NmEwYWJiLCAweDgxYzJjOTJlLCAweDkyNzIyYzg1LFxuICAgIDB4YTJiZmU4YTEsIDB4YTgxYTY2NGIsIDB4YzI0YjhiNzAsIDB4Yzc2YzUxYTMsIDB4ZDE5MmU4MTksIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsXG4gICAgMHgxOWE0YzExNiwgMHgxZTM3NmMwOCwgMHgyNzQ4Nzc0YywgMHgzNGIwYmNiNSwgMHgzOTFjMGNiMywgMHg0ZWQ4YWE0YSwgMHg1YjljY2E0ZiwgMHg2ODJlNmZmMyxcbiAgICAweDc0OGY4MmVlLCAweDc4YTU2MzZmLCAweDg0Yzg3ODE0LCAweDhjYzcwMjA4LCAweDkwYmVmZmZhLCAweGE0NTA2Y2ViLCAweGJlZjlhM2Y3LCAweGM2NzE3OGYyXG5dKTtcbi8vIEluaXRpYWwgc3RhdGUgKGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIHNxdWFyZSByb290cyBvZiB0aGUgZmlyc3QgOCBwcmltZXMgMi4uMTkpOlxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBJViA9IG5ldyBVaW50MzJBcnJheShbXG4gICAgMHg2YTA5ZTY2NywgMHhiYjY3YWU4NSwgMHgzYzZlZjM3MiwgMHhhNTRmZjUzYSwgMHg1MTBlNTI3ZiwgMHg5YjA1Njg4YywgMHgxZjgzZDlhYiwgMHg1YmUwY2QxOVxuXSk7XG4vLyBUZW1wb3JhcnkgYnVmZmVyLCBub3QgdXNlZCB0byBzdG9yZSBhbnl0aGluZyBiZXR3ZWVuIHJ1bnNcbi8vIE5hbWVkIHRoaXMgd2F5IGJlY2F1c2UgaXQgbWF0Y2hlcyBzcGVjaWZpY2F0aW9uLlxuY29uc3QgU0hBMjU2X1cgPSBuZXcgVWludDMyQXJyYXkoNjQpO1xuY2xhc3MgU0hBMjU2IGV4dGVuZHMgU0hBMiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDY0LCAzMiwgOCwgZmFsc2UpO1xuICAgICAgICAvLyBXZSBjYW5ub3QgdXNlIGFycmF5IGhlcmUgc2luY2UgYXJyYXkgYWxsb3dzIGluZGV4aW5nIGJ5IHZhcmlhYmxlXG4gICAgICAgIC8vIHdoaWNoIG1lYW5zIG9wdGltaXplci9jb21waWxlciBjYW5ub3QgdXNlIHJlZ2lzdGVycy5cbiAgICAgICAgdGhpcy5BID0gSVZbMF0gfCAwO1xuICAgICAgICB0aGlzLkIgPSBJVlsxXSB8IDA7XG4gICAgICAgIHRoaXMuQyA9IElWWzJdIHwgMDtcbiAgICAgICAgdGhpcy5EID0gSVZbM10gfCAwO1xuICAgICAgICB0aGlzLkUgPSBJVls0XSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IElWWzVdIHwgMDtcbiAgICAgICAgdGhpcy5HID0gSVZbNl0gfCAwO1xuICAgICAgICB0aGlzLkggPSBJVls3XSB8IDA7XG4gICAgfVxuICAgIGdldCgpIHtcbiAgICAgICAgY29uc3QgeyBBLCBCLCBDLCBELCBFLCBGLCBHLCBIIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW0EsIEIsIEMsIEQsIEUsIEYsIEcsIEhdO1xuICAgIH1cbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBzZXQoQSwgQiwgQywgRCwgRSwgRiwgRywgSCkge1xuICAgICAgICB0aGlzLkEgPSBBIHwgMDtcbiAgICAgICAgdGhpcy5CID0gQiB8IDA7XG4gICAgICAgIHRoaXMuQyA9IEMgfCAwO1xuICAgICAgICB0aGlzLkQgPSBEIHwgMDtcbiAgICAgICAgdGhpcy5FID0gRSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IEYgfCAwO1xuICAgICAgICB0aGlzLkcgPSBHIHwgMDtcbiAgICAgICAgdGhpcy5IID0gSCB8IDA7XG4gICAgfVxuICAgIHByb2Nlc3Modmlldywgb2Zmc2V0KSB7XG4gICAgICAgIC8vIEV4dGVuZCB0aGUgZmlyc3QgMTYgd29yZHMgaW50byB0aGUgcmVtYWluaW5nIDQ4IHdvcmRzIHdbMTYuLjYzXSBvZiB0aGUgbWVzc2FnZSBzY2hlZHVsZSBhcnJheVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyssIG9mZnNldCArPSA0KVxuICAgICAgICAgICAgU0hBMjU2X1dbaV0gPSB2aWV3LmdldFVpbnQzMihvZmZzZXQsIGZhbHNlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE2OyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgVzE1ID0gU0hBMjU2X1dbaSAtIDE1XTtcbiAgICAgICAgICAgIGNvbnN0IFcyID0gU0hBMjU2X1dbaSAtIDJdO1xuICAgICAgICAgICAgY29uc3QgczAgPSByb3RyKFcxNSwgNykgXiByb3RyKFcxNSwgMTgpIF4gKFcxNSA+Pj4gMyk7XG4gICAgICAgICAgICBjb25zdCBzMSA9IHJvdHIoVzIsIDE3KSBeIHJvdHIoVzIsIDE5KSBeIChXMiA+Pj4gMTApO1xuICAgICAgICAgICAgU0hBMjU2X1dbaV0gPSAoczEgKyBTSEEyNTZfV1tpIC0gN10gKyBzMCArIFNIQTI1Nl9XW2kgLSAxNl0pIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wcmVzc2lvbiBmdW5jdGlvbiBtYWluIGxvb3AsIDY0IHJvdW5kc1xuICAgICAgICBsZXQgeyBBLCBCLCBDLCBELCBFLCBGLCBHLCBIIH0gPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY0OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMSA9IHJvdHIoRSwgNikgXiByb3RyKEUsIDExKSBeIHJvdHIoRSwgMjUpO1xuICAgICAgICAgICAgY29uc3QgVDEgPSAoSCArIHNpZ21hMSArIENoaShFLCBGLCBHKSArIFNIQTI1Nl9LW2ldICsgU0hBMjU2X1dbaV0pIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMCA9IHJvdHIoQSwgMikgXiByb3RyKEEsIDEzKSBeIHJvdHIoQSwgMjIpO1xuICAgICAgICAgICAgY29uc3QgVDIgPSAoc2lnbWEwICsgTWFqKEEsIEIsIEMpKSB8IDA7XG4gICAgICAgICAgICBIID0gRztcbiAgICAgICAgICAgIEcgPSBGO1xuICAgICAgICAgICAgRiA9IEU7XG4gICAgICAgICAgICBFID0gKEQgKyBUMSkgfCAwO1xuICAgICAgICAgICAgRCA9IEM7XG4gICAgICAgICAgICBDID0gQjtcbiAgICAgICAgICAgIEIgPSBBO1xuICAgICAgICAgICAgQSA9IChUMSArIFQyKSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBjb21wcmVzc2VkIGNodW5rIHRvIHRoZSBjdXJyZW50IGhhc2ggdmFsdWVcbiAgICAgICAgQSA9IChBICsgdGhpcy5BKSB8IDA7XG4gICAgICAgIEIgPSAoQiArIHRoaXMuQikgfCAwO1xuICAgICAgICBDID0gKEMgKyB0aGlzLkMpIHwgMDtcbiAgICAgICAgRCA9IChEICsgdGhpcy5EKSB8IDA7XG4gICAgICAgIEUgPSAoRSArIHRoaXMuRSkgfCAwO1xuICAgICAgICBGID0gKEYgKyB0aGlzLkYpIHwgMDtcbiAgICAgICAgRyA9IChHICsgdGhpcy5HKSB8IDA7XG4gICAgICAgIEggPSAoSCArIHRoaXMuSCkgfCAwO1xuICAgICAgICB0aGlzLnNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKTtcbiAgICB9XG4gICAgcm91bmRDbGVhbigpIHtcbiAgICAgICAgU0hBMjU2X1cuZmlsbCgwKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgICAgIHRoaXMuYnVmZmVyLmZpbGwoMCk7XG4gICAgfVxufVxuLy8gQ29uc3RhbnRzIGZyb20gaHR0cHM6Ly9udmxwdWJzLm5pc3QuZ292L25pc3RwdWJzL0ZJUFMvTklTVC5GSVBTLjE4MC00LnBkZlxuY2xhc3MgU0hBMjI0IGV4dGVuZHMgU0hBMjU2IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5BID0gMHhjMTA1OWVkOCB8IDA7XG4gICAgICAgIHRoaXMuQiA9IDB4MzY3Y2Q1MDcgfCAwO1xuICAgICAgICB0aGlzLkMgPSAweDMwNzBkZDE3IHwgMDtcbiAgICAgICAgdGhpcy5EID0gMHhmNzBlNTkzOSB8IDA7XG4gICAgICAgIHRoaXMuRSA9IDB4ZmZjMDBiMzEgfCAwO1xuICAgICAgICB0aGlzLkYgPSAweDY4NTgxNTExIHwgMDtcbiAgICAgICAgdGhpcy5HID0gMHg2NGY5OGZhNyB8IDA7XG4gICAgICAgIHRoaXMuSCA9IDB4YmVmYTRmYTQgfCAwO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IDI4O1xuICAgIH1cbn1cbi8qKlxuICogU0hBMi0yNTYgaGFzaCBmdW5jdGlvblxuICogQHBhcmFtIG1lc3NhZ2UgLSBkYXRhIHRoYXQgd291bGQgYmUgaGFzaGVkXG4gKi9cbmV4cG9ydCBjb25zdCBzaGEyNTYgPSB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTI1NigpKTtcbmV4cG9ydCBjb25zdCBzaGEyMjQgPSB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTIyNCgpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYTI1Ni5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/sha256.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/utils.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/utils.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hash: () => (/* binding */ Hash),\n/* harmony export */   asyncLoop: () => (/* binding */ asyncLoop),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   checkOpts: () => (/* binding */ checkOpts),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createView: () => (/* binding */ createView),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   isLE: () => (/* binding */ isLE),\n/* harmony export */   nextTick: () => (/* binding */ nextTick),\n/* harmony export */   randomBytes: () => (/* binding */ randomBytes),\n/* harmony export */   rotr: () => (/* binding */ rotr),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   u32: () => (/* binding */ u32),\n/* harmony export */   u8: () => (/* binding */ u8),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   wrapConstructor: () => (/* binding */ wrapConstructor),\n/* harmony export */   wrapConstructorWithOpts: () => (/* binding */ wrapConstructorWithOpts),\n/* harmony export */   wrapXOFConstructorWithOpts: () => (/* binding */ wrapXOFConstructorWithOpts)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/crypto */ \"(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/cryptoNode.js\");\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated, we can just drop the import.\n\nconst u8a = (a) => a instanceof Uint8Array;\n// Cast array to different type\nconst u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nconst u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nconst createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\nconst isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE)\n    throw new Error('Non little-endian hardware is not supported');\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    if (!u8a(bytes))\n        throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const len = hex.length;\n    if (len % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n    const array = new Uint8Array(len / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    if (!u8a(data))\n        throw new Error(`expected Uint8Array, got ${typeof data}`);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n    let pad = 0; // walk through each item, ensure they have proper type\n    arrays.forEach((a) => {\n        if (!u8a(a))\n            throw new Error('Uint8Array expected');\n        r.set(a, pad);\n        pad += a.length;\n    });\n    return r;\n}\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\n// Check if object doens't have custom constructor (like Uint8Array/Array)\nconst isPlainObject = (obj) => Object.prototype.toString.call(obj) === '[object Object]' && obj.constructor === Object;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && (typeof opts !== 'object' || !isPlainObject(opts)))\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nfunction wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nfunction randomBytes(bytesLength = 32) {\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues === 'function') {\n        return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzhDO0FBQzlDO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsNERBQTRELFdBQVc7QUFDdkUsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFlBQVk7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsUUFBUSx3REFBTSxXQUFXLHdEQUFNO0FBQy9CLGVBQWUsd0RBQU07QUFDckI7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9ob21lL2xmZy9HaXQvTWFkdHJpcHMvbm9kZV9tb2R1bGVzL0Bub3N0ci1kZXYta2l0L25kay9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3V0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1oYXNoZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIFdlIHVzZSBXZWJDcnlwdG8gYWthIGdsb2JhbFRoaXMuY3J5cHRvLCB3aGljaCBleGlzdHMgaW4gYnJvd3NlcnMgYW5kIG5vZGUuanMgMTYrLlxuLy8gbm9kZS5qcyB2ZXJzaW9ucyBlYXJsaWVyIHRoYW4gdjE5IGRvbid0IGRlY2xhcmUgaXQgaW4gZ2xvYmFsIHNjb3BlLlxuLy8gRm9yIG5vZGUuanMsIHBhY2thZ2UuanNvbiNleHBvcnRzIGZpZWxkIG1hcHBpbmcgcmV3cml0ZXMgaW1wb3J0XG4vLyBmcm9tIGBjcnlwdG9gIHRvIGBjcnlwdG9Ob2RlYCwgd2hpY2ggaW1wb3J0cyBuYXRpdmUgbW9kdWxlLlxuLy8gTWFrZXMgdGhlIHV0aWxzIHVuLWltcG9ydGFibGUgaW4gYnJvd3NlcnMgd2l0aG91dCBhIGJ1bmRsZXIuXG4vLyBPbmNlIG5vZGUuanMgMTggaXMgZGVwcmVjYXRlZCwgd2UgY2FuIGp1c3QgZHJvcCB0aGUgaW1wb3J0LlxuaW1wb3J0IHsgY3J5cHRvIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9jcnlwdG8nO1xuY29uc3QgdThhID0gKGEpID0+IGEgaW5zdGFuY2VvZiBVaW50OEFycmF5O1xuLy8gQ2FzdCBhcnJheSB0byBkaWZmZXJlbnQgdHlwZVxuZXhwb3J0IGNvbnN0IHU4ID0gKGFycikgPT4gbmV3IFVpbnQ4QXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbmV4cG9ydCBjb25zdCB1MzIgPSAoYXJyKSA9PiBuZXcgVWludDMyQXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIE1hdGguZmxvb3IoYXJyLmJ5dGVMZW5ndGggLyA0KSk7XG4vLyBDYXN0IGFycmF5IHRvIHZpZXdcbmV4cG9ydCBjb25zdCBjcmVhdGVWaWV3ID0gKGFycikgPT4gbmV3IERhdGFWaWV3KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG4vLyBUaGUgcm90YXRlIHJpZ2h0IChjaXJjdWxhciByaWdodCBzaGlmdCkgb3BlcmF0aW9uIGZvciB1aW50MzJcbmV4cG9ydCBjb25zdCByb3RyID0gKHdvcmQsIHNoaWZ0KSA9PiAod29yZCA8PCAoMzIgLSBzaGlmdCkpIHwgKHdvcmQgPj4+IHNoaWZ0KTtcbi8vIGJpZy1lbmRpYW4gaGFyZHdhcmUgaXMgcmFyZS4gSnVzdCBpbiBjYXNlIHNvbWVvbmUgc3RpbGwgZGVjaWRlcyB0byBydW4gaGFzaGVzOlxuLy8gZWFybHktdGhyb3cgYW4gZXJyb3IgYmVjYXVzZSB3ZSBkb24ndCBzdXBwb3J0IEJFIHlldC5cbmV4cG9ydCBjb25zdCBpc0xFID0gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQzMkFycmF5KFsweDExMjIzMzQ0XSkuYnVmZmVyKVswXSA9PT0gMHg0NDtcbmlmICghaXNMRSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbiBsaXR0bGUtZW5kaWFuIGhhcmR3YXJlIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbmNvbnN0IGhleGVzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sICh2LCBpKSA9PiBpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbi8qKlxuICogQGV4YW1wbGUgYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKSkgLy8gJ2NhZmUwMTIzJ1xuICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuICAgIGlmICghdThhKGJ5dGVzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgLy8gcHJlLWNhY2hpbmcgaW1wcm92ZXMgdGhlIHNwZWVkIDZ4XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IGhleGVzW2J5dGVzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbi8qKlxuICogQGV4YW1wbGUgaGV4VG9CeXRlcygnY2FmZTAxMjMnKSAvLyBVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGV4VG9CeXRlcyhoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICBjb25zdCBsZW4gPSBoZXgubGVuZ3RoO1xuICAgIGlmIChsZW4gJSAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRlZCBoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgdW5wYWRkZWQgaGV4IG9mIGxlbmd0aCAnICsgbGVuKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGxlbiAvIDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaiA9IGkgKiAyO1xuICAgICAgICBjb25zdCBoZXhCeXRlID0gaGV4LnNsaWNlKGosIGogKyAyKTtcbiAgICAgICAgY29uc3QgYnl0ZSA9IE51bWJlci5wYXJzZUludChoZXhCeXRlLCAxNik7XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4oYnl0ZSkgfHwgYnl0ZSA8IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYnl0ZSBzZXF1ZW5jZScpO1xuICAgICAgICBhcnJheVtpXSA9IGJ5dGU7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbi8vIFRoZXJlIGlzIG5vIHNldEltbWVkaWF0ZSBpbiBicm93c2VyIGFuZCBzZXRUaW1lb3V0IGlzIHNsb3cuXG4vLyBjYWxsIG9mIGFzeW5jIGZuIHdpbGwgcmV0dXJuIFByb21pc2UsIHdoaWNoIHdpbGwgYmUgZnVsbGZpbGVkIG9ubHkgb25cbi8vIG5leHQgc2NoZWR1bGVyIHF1ZXVlIHByb2Nlc3Npbmcgc3RlcCBhbmQgdGhpcyBpcyBleGFjdGx5IHdoYXQgd2UgbmVlZC5cbmV4cG9ydCBjb25zdCBuZXh0VGljayA9IGFzeW5jICgpID0+IHsgfTtcbi8vIFJldHVybnMgY29udHJvbCB0byB0aHJlYWQgZWFjaCAndGljaycgbXMgdG8gYXZvaWQgYmxvY2tpbmdcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhc3luY0xvb3AoaXRlcnMsIHRpY2ssIGNiKSB7XG4gICAgbGV0IHRzID0gRGF0ZS5ub3coKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJzOyBpKyspIHtcbiAgICAgICAgY2IoaSk7XG4gICAgICAgIC8vIERhdGUubm93KCkgaXMgbm90IG1vbm90b25pYywgc28gaW4gY2FzZSBpZiBjbG9jayBnb2VzIGJhY2t3YXJkcyB3ZSByZXR1cm4gcmV0dXJuIGNvbnRyb2wgdG9vXG4gICAgICAgIGNvbnN0IGRpZmYgPSBEYXRlLm5vdygpIC0gdHM7XG4gICAgICAgIGlmIChkaWZmID49IDAgJiYgZGlmZiA8IHRpY2spXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgYXdhaXQgbmV4dFRpY2soKTtcbiAgICAgICAgdHMgKz0gZGlmZjtcbiAgICB9XG59XG4vKipcbiAqIEBleGFtcGxlIHV0ZjhUb0J5dGVzKCdhYmMnKSAvLyBuZXcgVWludDhBcnJheShbOTcsIDk4LCA5OV0pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdXRmOFRvQnl0ZXMgZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygc3RyfWApO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSk7IC8vIGh0dHBzOi8vYnVnemlsLmxhLzE2ODE4MDlcbn1cbi8qKlxuICogTm9ybWFsaXplcyAobm9uLWhleCkgc3RyaW5nIG9yIFVpbnQ4QXJyYXkgdG8gVWludDhBcnJheS5cbiAqIFdhcm5pbmc6IHdoZW4gVWludDhBcnJheSBpcyBwYXNzZWQsIGl0IHdvdWxkIE5PVCBnZXQgY29waWVkLlxuICogS2VlcCBpbiBtaW5kIGZvciBmdXR1cmUgbXV0YWJsZSBvcGVyYXRpb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9CeXRlcyhkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJylcbiAgICAgICAgZGF0YSA9IHV0ZjhUb0J5dGVzKGRhdGEpO1xuICAgIGlmICghdThhKGRhdGEpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkIFVpbnQ4QXJyYXksIGdvdCAke3R5cGVvZiBkYXRhfWApO1xuICAgIHJldHVybiBkYXRhO1xufVxuLyoqXG4gKiBDb3BpZXMgc2V2ZXJhbCBVaW50OEFycmF5cyBpbnRvIG9uZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5cykge1xuICAgIGNvbnN0IHIgPSBuZXcgVWludDhBcnJheShhcnJheXMucmVkdWNlKChzdW0sIGEpID0+IHN1bSArIGEubGVuZ3RoLCAwKSk7XG4gICAgbGV0IHBhZCA9IDA7IC8vIHdhbGsgdGhyb3VnaCBlYWNoIGl0ZW0sIGVuc3VyZSB0aGV5IGhhdmUgcHJvcGVyIHR5cGVcbiAgICBhcnJheXMuZm9yRWFjaCgoYSkgPT4ge1xuICAgICAgICBpZiAoIXU4YShhKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgICAgICByLnNldChhLCBwYWQpO1xuICAgICAgICBwYWQgKz0gYS5sZW5ndGg7XG4gICAgfSk7XG4gICAgcmV0dXJuIHI7XG59XG4vLyBGb3IgcnVudGltZSBjaGVjayBpZiBjbGFzcyBpbXBsZW1lbnRzIGludGVyZmFjZVxuZXhwb3J0IGNsYXNzIEhhc2gge1xuICAgIC8vIFNhZmUgdmVyc2lvbiB0aGF0IGNsb25lcyBpbnRlcm5hbCBzdGF0ZVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvbmVJbnRvKCk7XG4gICAgfVxufVxuLy8gQ2hlY2sgaWYgb2JqZWN0IGRvZW5zJ3QgaGF2ZSBjdXN0b20gY29uc3RydWN0b3IgKGxpa2UgVWludDhBcnJheS9BcnJheSlcbmNvbnN0IGlzUGxhaW5PYmplY3QgPSAob2JqKSA9PiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG5leHBvcnQgZnVuY3Rpb24gY2hlY2tPcHRzKGRlZmF1bHRzLCBvcHRzKSB7XG4gICAgaWYgKG9wdHMgIT09IHVuZGVmaW5lZCAmJiAodHlwZW9mIG9wdHMgIT09ICdvYmplY3QnIHx8ICFpc1BsYWluT2JqZWN0KG9wdHMpKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcHRpb25zIHNob3VsZCBiZSBvYmplY3Qgb3IgdW5kZWZpbmVkJyk7XG4gICAgY29uc3QgbWVyZ2VkID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0cywgb3B0cyk7XG4gICAgcmV0dXJuIG1lcmdlZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiB3cmFwQ29uc3RydWN0b3IoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2cpID0+IGhhc2hDb25zKCkudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoKTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9ICgpID0+IGhhc2hDb25zKCk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBDb25zdHJ1Y3RvcldpdGhPcHRzKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnLCBvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucyh7fSk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAob3B0cykgPT4gaGFzaENvbnMob3B0cyk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnLCBvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucyh7fSk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAob3B0cykgPT4gaGFzaENvbnMob3B0cyk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuLyoqXG4gKiBTZWN1cmUgUFJORy4gVXNlcyBgY3J5cHRvLmdldFJhbmRvbVZhbHVlc2AsIHdoaWNoIGRlZmVycyB0byBPUy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbUJ5dGVzKGJ5dGVzTGVuZ3RoID0gMzIpIHtcbiAgICBpZiAoY3J5cHRvICYmIHR5cGVvZiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KGJ5dGVzTGVuZ3RoKSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignY3J5cHRvLmdldFJhbmRvbVZhbHVlcyBtdXN0IGJlIGRlZmluZWQnKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@noble/hashes/esm/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@scure/base/lib/esm/index.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@scure/base/lib/esm/index.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertNumber: () => (/* binding */ assertNumber),\n/* harmony export */   base16: () => (/* binding */ base16),\n/* harmony export */   base32: () => (/* binding */ base32),\n/* harmony export */   base32crockford: () => (/* binding */ base32crockford),\n/* harmony export */   base32hex: () => (/* binding */ base32hex),\n/* harmony export */   base58: () => (/* binding */ base58),\n/* harmony export */   base58check: () => (/* binding */ base58check),\n/* harmony export */   base58flickr: () => (/* binding */ base58flickr),\n/* harmony export */   base58xmr: () => (/* binding */ base58xmr),\n/* harmony export */   base58xrp: () => (/* binding */ base58xrp),\n/* harmony export */   base64: () => (/* binding */ base64),\n/* harmony export */   base64url: () => (/* binding */ base64url),\n/* harmony export */   bech32: () => (/* binding */ bech32),\n/* harmony export */   bech32m: () => (/* binding */ bech32m),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   bytesToString: () => (/* binding */ bytesToString),\n/* harmony export */   hex: () => (/* binding */ hex),\n/* harmony export */   str: () => (/* binding */ str),\n/* harmony export */   stringToBytes: () => (/* binding */ stringToBytes),\n/* harmony export */   utf8: () => (/* binding */ utf8),\n/* harmony export */   utils: () => (/* binding */ utils)\n/* harmony export */ });\n/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nfunction assertNumber(n) {\n    if (!Number.isSafeInteger(n))\n        throw new Error(`Wrong integer: ${n}`);\n}\nfunction chain(...args) {\n    const wrap = (a, b) => (c) => a(b(c));\n    const encode = Array.from(args)\n        .reverse()\n        .reduce((acc, i) => (acc ? wrap(acc, i.encode) : i.encode), undefined);\n    const decode = args.reduce((acc, i) => (acc ? wrap(acc, i.decode) : i.decode), undefined);\n    return { encode, decode };\n}\nfunction alphabet(alphabet) {\n    return {\n        encode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('alphabet.encode input should be an array of numbers');\n            return digits.map((i) => {\n                assertNumber(i);\n                if (i < 0 || i >= alphabet.length)\n                    throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet.length})`);\n                return alphabet[i];\n            });\n        },\n        decode: (input) => {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('alphabet.decode input should be array of strings');\n            return input.map((letter) => {\n                if (typeof letter !== 'string')\n                    throw new Error(`alphabet.decode: not string element=${letter}`);\n                const index = alphabet.indexOf(letter);\n                if (index === -1)\n                    throw new Error(`Unknown letter: \"${letter}\". Allowed: ${alphabet}`);\n                return index;\n            });\n        },\n    };\n}\nfunction join(separator = '') {\n    if (typeof separator !== 'string')\n        throw new Error('join separator should be string');\n    return {\n        encode: (from) => {\n            if (!Array.isArray(from) || (from.length && typeof from[0] !== 'string'))\n                throw new Error('join.encode input should be array of strings');\n            for (let i of from)\n                if (typeof i !== 'string')\n                    throw new Error(`join.encode: non-string input=${i}`);\n            return from.join(separator);\n        },\n        decode: (to) => {\n            if (typeof to !== 'string')\n                throw new Error('join.decode input should be string');\n            return to.split(separator);\n        },\n    };\n}\nfunction padding(bits, chr = '=') {\n    assertNumber(bits);\n    if (typeof chr !== 'string')\n        throw new Error('padding chr should be string');\n    return {\n        encode(data) {\n            if (!Array.isArray(data) || (data.length && typeof data[0] !== 'string'))\n                throw new Error('padding.encode input should be array of strings');\n            for (let i of data)\n                if (typeof i !== 'string')\n                    throw new Error(`padding.encode: non-string input=${i}`);\n            while ((data.length * bits) % 8)\n                data.push(chr);\n            return data;\n        },\n        decode(input) {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('padding.encode input should be array of strings');\n            for (let i of input)\n                if (typeof i !== 'string')\n                    throw new Error(`padding.decode: non-string input=${i}`);\n            let end = input.length;\n            if ((end * bits) % 8)\n                throw new Error('Invalid padding: string should have whole number of bytes');\n            for (; end > 0 && input[end - 1] === chr; end--) {\n                if (!(((end - 1) * bits) % 8))\n                    throw new Error('Invalid padding: string has too much padding');\n            }\n            return input.slice(0, end);\n        },\n    };\n}\nfunction normalize(fn) {\n    if (typeof fn !== 'function')\n        throw new Error('normalize fn should be function');\n    return { encode: (from) => from, decode: (to) => fn(to) };\n}\nfunction convertRadix(data, from, to) {\n    if (from < 2)\n        throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);\n    if (to < 2)\n        throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);\n    if (!Array.isArray(data))\n        throw new Error('convertRadix: data should be array');\n    if (!data.length)\n        return [];\n    let pos = 0;\n    const res = [];\n    const digits = Array.from(data);\n    digits.forEach((d) => {\n        assertNumber(d);\n        if (d < 0 || d >= from)\n            throw new Error(`Wrong integer: ${d}`);\n    });\n    while (true) {\n        let carry = 0;\n        let done = true;\n        for (let i = pos; i < digits.length; i++) {\n            const digit = digits[i];\n            const digitBase = from * carry + digit;\n            if (!Number.isSafeInteger(digitBase) ||\n                (from * carry) / from !== carry ||\n                digitBase - digit !== from * carry) {\n                throw new Error('convertRadix: carry overflow');\n            }\n            carry = digitBase % to;\n            digits[i] = Math.floor(digitBase / to);\n            if (!Number.isSafeInteger(digits[i]) || digits[i] * to + carry !== digitBase)\n                throw new Error('convertRadix: carry overflow');\n            if (!done)\n                continue;\n            else if (!digits[i])\n                pos = i;\n            else\n                done = false;\n        }\n        res.push(carry);\n        if (done)\n            break;\n    }\n    for (let i = 0; i < data.length - 1 && data[i] === 0; i++)\n        res.push(0);\n    return res.reverse();\n}\nconst gcd = (a, b) => (!b ? a : gcd(b, a % b));\nconst radix2carry = (from, to) => from + (to - gcd(from, to));\nfunction convertRadix2(data, from, to, padding) {\n    if (!Array.isArray(data))\n        throw new Error('convertRadix2: data should be array');\n    if (from <= 0 || from > 32)\n        throw new Error(`convertRadix2: wrong from=${from}`);\n    if (to <= 0 || to > 32)\n        throw new Error(`convertRadix2: wrong to=${to}`);\n    if (radix2carry(from, to) > 32) {\n        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);\n    }\n    let carry = 0;\n    let pos = 0;\n    const mask = 2 ** to - 1;\n    const res = [];\n    for (const n of data) {\n        assertNumber(n);\n        if (n >= 2 ** from)\n            throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n        carry = (carry << from) | n;\n        if (pos + from > 32)\n            throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n        pos += from;\n        for (; pos >= to; pos -= to)\n            res.push(((carry >> (pos - to)) & mask) >>> 0);\n        carry &= 2 ** pos - 1;\n    }\n    carry = (carry << (to - pos)) & mask;\n    if (!padding && pos >= from)\n        throw new Error('Excess padding');\n    if (!padding && carry)\n        throw new Error(`Non-zero padding: ${carry}`);\n    if (padding && pos > 0)\n        res.push(carry >>> 0);\n    return res;\n}\nfunction radix(num) {\n    assertNumber(num);\n    return {\n        encode: (bytes) => {\n            if (!(bytes instanceof Uint8Array))\n                throw new Error('radix.encode input should be Uint8Array');\n            return convertRadix(Array.from(bytes), 2 ** 8, num);\n        },\n        decode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('radix.decode input should be array of strings');\n            return Uint8Array.from(convertRadix(digits, num, 2 ** 8));\n        },\n    };\n}\nfunction radix2(bits, revPadding = false) {\n    assertNumber(bits);\n    if (bits <= 0 || bits > 32)\n        throw new Error('radix2: bits should be in (0..32]');\n    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)\n        throw new Error('radix2: carry overflow');\n    return {\n        encode: (bytes) => {\n            if (!(bytes instanceof Uint8Array))\n                throw new Error('radix2.encode input should be Uint8Array');\n            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n        },\n        decode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('radix2.decode input should be array of strings');\n            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n        },\n    };\n}\nfunction unsafeWrapper(fn) {\n    if (typeof fn !== 'function')\n        throw new Error('unsafeWrapper fn should be function');\n    return function (...args) {\n        try {\n            return fn.apply(null, args);\n        }\n        catch (e) { }\n    };\n}\nfunction checksum(len, fn) {\n    assertNumber(len);\n    if (typeof fn !== 'function')\n        throw new Error('checksum fn should be function');\n    return {\n        encode(data) {\n            if (!(data instanceof Uint8Array))\n                throw new Error('checksum.encode: input should be Uint8Array');\n            const checksum = fn(data).slice(0, len);\n            const res = new Uint8Array(data.length + len);\n            res.set(data);\n            res.set(checksum, data.length);\n            return res;\n        },\n        decode(data) {\n            if (!(data instanceof Uint8Array))\n                throw new Error('checksum.decode: input should be Uint8Array');\n            const payload = data.slice(0, -len);\n            const newChecksum = fn(payload).slice(0, len);\n            const oldChecksum = data.slice(-len);\n            for (let i = 0; i < len; i++)\n                if (newChecksum[i] !== oldChecksum[i])\n                    throw new Error('Invalid checksum');\n            return payload;\n        },\n    };\n}\nconst utils = { alphabet, chain, checksum, radix, radix2, join, padding };\nconst base16 = chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));\nconst base32 = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));\nconst base32hex = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));\nconst base32crockford = chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize((s) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')));\nconst base64 = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));\nconst base64url = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));\nconst genBase58 = (abc) => chain(radix(58), alphabet(abc), join(''));\nconst base58 = genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');\nconst base58flickr = genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');\nconst base58xrp = genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');\nconst XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\nconst base58xmr = {\n    encode(data) {\n        let res = '';\n        for (let i = 0; i < data.length; i += 8) {\n            const block = data.subarray(i, i + 8);\n            res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');\n        }\n        return res;\n    },\n    decode(str) {\n        let res = [];\n        for (let i = 0; i < str.length; i += 11) {\n            const slice = str.slice(i, i + 11);\n            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n            const block = base58.decode(slice);\n            for (let j = 0; j < block.length - blockLen; j++) {\n                if (block[j] !== 0)\n                    throw new Error('base58xmr: wrong padding');\n            }\n            res = res.concat(Array.from(block.slice(block.length - blockLen)));\n        }\n        return Uint8Array.from(res);\n    },\n};\nconst base58check = (sha256) => chain(checksum(4, (data) => sha256(sha256(data))), base58);\nconst BECH_ALPHABET = chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));\nconst POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\nfunction bech32Polymod(pre) {\n    const b = pre >> 25;\n    let chk = (pre & 0x1ffffff) << 5;\n    for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {\n        if (((b >> i) & 1) === 1)\n            chk ^= POLYMOD_GENERATORS[i];\n    }\n    return chk;\n}\nfunction bechChecksum(prefix, words, encodingConst = 1) {\n    const len = prefix.length;\n    let chk = 1;\n    for (let i = 0; i < len; i++) {\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126)\n            throw new Error(`Invalid prefix (${prefix})`);\n        chk = bech32Polymod(chk) ^ (c >> 5);\n    }\n    chk = bech32Polymod(chk);\n    for (let i = 0; i < len; i++)\n        chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);\n    for (let v of words)\n        chk = bech32Polymod(chk) ^ v;\n    for (let i = 0; i < 6; i++)\n        chk = bech32Polymod(chk);\n    chk ^= encodingConst;\n    return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));\n}\nfunction genBech32(encoding) {\n    const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n    const _words = radix2(5);\n    const fromWords = _words.decode;\n    const toWords = _words.encode;\n    const fromWordsUnsafe = unsafeWrapper(fromWords);\n    function encode(prefix, words, limit = 90) {\n        if (typeof prefix !== 'string')\n            throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);\n        if (!Array.isArray(words) || (words.length && typeof words[0] !== 'number'))\n            throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);\n        const actualLength = prefix.length + 7 + words.length;\n        if (limit !== false && actualLength > limit)\n            throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n        prefix = prefix.toLowerCase();\n        return `${prefix}1${BECH_ALPHABET.encode(words)}${bechChecksum(prefix, words, ENCODING_CONST)}`;\n    }\n    function decode(str, limit = 90) {\n        if (typeof str !== 'string')\n            throw new Error(`bech32.decode input should be string, not ${typeof str}`);\n        if (str.length < 8 || (limit !== false && str.length > limit))\n            throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);\n        const lowered = str.toLowerCase();\n        if (str !== lowered && str !== str.toUpperCase())\n            throw new Error(`String must be lowercase or uppercase`);\n        str = lowered;\n        const sepIndex = str.lastIndexOf('1');\n        if (sepIndex === 0 || sepIndex === -1)\n            throw new Error(`Letter \"1\" must be present between prefix and data only`);\n        const prefix = str.slice(0, sepIndex);\n        const _words = str.slice(sepIndex + 1);\n        if (_words.length < 6)\n            throw new Error('Data must be at least 6 characters long');\n        const words = BECH_ALPHABET.decode(_words).slice(0, -6);\n        const sum = bechChecksum(prefix, words, ENCODING_CONST);\n        if (!_words.endsWith(sum))\n            throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n        return { prefix, words };\n    }\n    const decodeUnsafe = unsafeWrapper(decode);\n    function decodeToBytes(str) {\n        const { prefix, words } = decode(str, false);\n        return { prefix, words, bytes: fromWords(words) };\n    }\n    return { encode, decode, decodeToBytes, decodeUnsafe, fromWords, fromWordsUnsafe, toWords };\n}\nconst bech32 = genBech32('bech32');\nconst bech32m = genBech32('bech32m');\nconst utf8 = {\n    encode: (data) => new TextDecoder().decode(data),\n    decode: (str) => new TextEncoder().encode(str),\n};\nconst hex = chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize((s) => {\n    if (typeof s !== 'string' || s.length % 2)\n        throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);\n    return s.toLowerCase();\n}));\nconst CODERS = {\n    utf8, hex, base16, base32, base64, base64url, base58, base58xmr\n};\nconst coderTypeError = `Invalid encoding type. Available types: ${Object.keys(CODERS).join(', ')}`;\nconst bytesToString = (type, bytes) => {\n    if (typeof type !== 'string' || !CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (!(bytes instanceof Uint8Array))\n        throw new TypeError('bytesToString() expects Uint8Array');\n    return CODERS[type].encode(bytes);\n};\nconst str = bytesToString;\nconst stringToBytes = (type, str) => {\n    if (!CODERS.hasOwnProperty(type))\n        throw new TypeError(coderTypeError);\n    if (typeof str !== 'string')\n        throw new TypeError('stringToBytes() expects string');\n    return CODERS[type].decode(str);\n};\nconst bytes = stringToBytes;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vc3RyLWRldi1raXQvbmRrL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9ub2RlX21vZHVsZXMvQHNjdXJlL2Jhc2UvbGliL2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNPO0FBQ1A7QUFDQSwwQ0FBMEMsRUFBRTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsR0FBRyxhQUFhLGdCQUFnQjtBQUNyRztBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxPQUFPO0FBQ2xGO0FBQ0E7QUFDQSx3REFBd0QsT0FBTyxjQUFjLFNBQVM7QUFDdEY7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsRUFBRTtBQUN2RTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsRUFBRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxFQUFFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQ0FBbUM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsS0FBSztBQUN6RDtBQUNBLGtEQUFrRCxHQUFHO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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aEMsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ087QUFDQTtBQUNBO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGdFQUFnRSxVQUFVLGNBQWMsU0FBUztBQUNqRztBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsK0JBQStCO0FBQzFGO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPIiwic291cmNlcyI6WyIvaG9tZS9sZmcvR2l0L01hZHRyaXBzL25vZGVfbW9kdWxlcy9Abm9zdHItZGV2LWtpdC9uZGsvbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL25vZGVfbW9kdWxlcy9Ac2N1cmUvYmFzZS9saWIvZXNtL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBzY3VyZS1iYXNlIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0TnVtYmVyKG4pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG4pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdyb25nIGludGVnZXI6ICR7bn1gKTtcbn1cbmZ1bmN0aW9uIGNoYWluKC4uLmFyZ3MpIHtcbiAgICBjb25zdCB3cmFwID0gKGEsIGIpID0+IChjKSA9PiBhKGIoYykpO1xuICAgIGNvbnN0IGVuY29kZSA9IEFycmF5LmZyb20oYXJncylcbiAgICAgICAgLnJldmVyc2UoKVxuICAgICAgICAucmVkdWNlKChhY2MsIGkpID0+IChhY2MgPyB3cmFwKGFjYywgaS5lbmNvZGUpIDogaS5lbmNvZGUpLCB1bmRlZmluZWQpO1xuICAgIGNvbnN0IGRlY29kZSA9IGFyZ3MucmVkdWNlKChhY2MsIGkpID0+IChhY2MgPyB3cmFwKGFjYywgaS5kZWNvZGUpIDogaS5kZWNvZGUpLCB1bmRlZmluZWQpO1xuICAgIHJldHVybiB7IGVuY29kZSwgZGVjb2RlIH07XG59XG5mdW5jdGlvbiBhbHBoYWJldChhbHBoYWJldCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZTogKGRpZ2l0cykgPT4ge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRpZ2l0cykgfHwgKGRpZ2l0cy5sZW5ndGggJiYgdHlwZW9mIGRpZ2l0c1swXSAhPT0gJ251bWJlcicpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYWxwaGFiZXQuZW5jb2RlIGlucHV0IHNob3VsZCBiZSBhbiBhcnJheSBvZiBudW1iZXJzJyk7XG4gICAgICAgICAgICByZXR1cm4gZGlnaXRzLm1hcCgoaSkgPT4ge1xuICAgICAgICAgICAgICAgIGFzc2VydE51bWJlcihpKTtcbiAgICAgICAgICAgICAgICBpZiAoaSA8IDAgfHwgaSA+PSBhbHBoYWJldC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRGlnaXQgaW5kZXggb3V0c2lkZSBhbHBoYWJldDogJHtpfSAoYWxwaGFiZXQ6ICR7YWxwaGFiZXQubGVuZ3RofSlgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWxwaGFiZXRbaV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlOiAoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkgfHwgKGlucHV0Lmxlbmd0aCAmJiB0eXBlb2YgaW5wdXRbMF0gIT09ICdzdHJpbmcnKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FscGhhYmV0LmRlY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2Ygc3RyaW5ncycpO1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0Lm1hcCgobGV0dGVyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsZXR0ZXIgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGFscGhhYmV0LmRlY29kZTogbm90IHN0cmluZyBlbGVtZW50PSR7bGV0dGVyfWApO1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gYWxwaGFiZXQuaW5kZXhPZihsZXR0ZXIpO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBsZXR0ZXI6IFwiJHtsZXR0ZXJ9XCIuIEFsbG93ZWQ6ICR7YWxwaGFiZXR9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGpvaW4oc2VwYXJhdG9yID0gJycpIHtcbiAgICBpZiAodHlwZW9mIHNlcGFyYXRvciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignam9pbiBzZXBhcmF0b3Igc2hvdWxkIGJlIHN0cmluZycpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZTogKGZyb20pID0+IHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShmcm9tKSB8fCAoZnJvbS5sZW5ndGggJiYgdHlwZW9mIGZyb21bMF0gIT09ICdzdHJpbmcnKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2pvaW4uZW5jb2RlIGlucHV0IHNob3VsZCBiZSBhcnJheSBvZiBzdHJpbmdzJyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpIG9mIGZyb20pXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBqb2luLmVuY29kZTogbm9uLXN0cmluZyBpbnB1dD0ke2l9YCk7XG4gICAgICAgICAgICByZXR1cm4gZnJvbS5qb2luKHNlcGFyYXRvcik7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZTogKHRvKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRvICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2pvaW4uZGVjb2RlIGlucHV0IHNob3VsZCBiZSBzdHJpbmcnKTtcbiAgICAgICAgICAgIHJldHVybiB0by5zcGxpdChzZXBhcmF0b3IpO1xuICAgICAgICB9LFxuICAgIH07XG59XG5mdW5jdGlvbiBwYWRkaW5nKGJpdHMsIGNociA9ICc9Jykge1xuICAgIGFzc2VydE51bWJlcihiaXRzKTtcbiAgICBpZiAodHlwZW9mIGNociAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGluZyBjaHIgc2hvdWxkIGJlIHN0cmluZycpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZShkYXRhKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkgfHwgKGRhdGEubGVuZ3RoICYmIHR5cGVvZiBkYXRhWzBdICE9PSAnc3RyaW5nJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkaW5nLmVuY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2Ygc3RyaW5ncycpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSBvZiBkYXRhKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaSAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcGFkZGluZy5lbmNvZGU6IG5vbi1zdHJpbmcgaW5wdXQ9JHtpfWApO1xuICAgICAgICAgICAgd2hpbGUgKChkYXRhLmxlbmd0aCAqIGJpdHMpICUgOClcbiAgICAgICAgICAgICAgICBkYXRhLnB1c2goY2hyKTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGUoaW5wdXQpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkgfHwgKGlucHV0Lmxlbmd0aCAmJiB0eXBlb2YgaW5wdXRbMF0gIT09ICdzdHJpbmcnKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRpbmcuZW5jb2RlIGlucHV0IHNob3VsZCBiZSBhcnJheSBvZiBzdHJpbmdzJyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpIG9mIGlucHV0KVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaSAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcGFkZGluZy5kZWNvZGU6IG5vbi1zdHJpbmcgaW5wdXQ9JHtpfWApO1xuICAgICAgICAgICAgbGV0IGVuZCA9IGlucHV0Lmxlbmd0aDtcbiAgICAgICAgICAgIGlmICgoZW5kICogYml0cykgJSA4KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwYWRkaW5nOiBzdHJpbmcgc2hvdWxkIGhhdmUgd2hvbGUgbnVtYmVyIG9mIGJ5dGVzJyk7XG4gICAgICAgICAgICBmb3IgKDsgZW5kID4gMCAmJiBpbnB1dFtlbmQgLSAxXSA9PT0gY2hyOyBlbmQtLSkge1xuICAgICAgICAgICAgICAgIGlmICghKCgoZW5kIC0gMSkgKiBiaXRzKSAlIDgpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcGFkZGluZzogc3RyaW5nIGhhcyB0b28gbXVjaCBwYWRkaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQuc2xpY2UoMCwgZW5kKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplKGZuKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3JtYWxpemUgZm4gc2hvdWxkIGJlIGZ1bmN0aW9uJyk7XG4gICAgcmV0dXJuIHsgZW5jb2RlOiAoZnJvbSkgPT4gZnJvbSwgZGVjb2RlOiAodG8pID0+IGZuKHRvKSB9O1xufVxuZnVuY3Rpb24gY29udmVydFJhZGl4KGRhdGEsIGZyb20sIHRvKSB7XG4gICAgaWYgKGZyb20gPCAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDogd3JvbmcgZnJvbT0ke2Zyb219LCBiYXNlIGNhbm5vdCBiZSBsZXNzIHRoYW4gMmApO1xuICAgIGlmICh0byA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4OiB3cm9uZyB0bz0ke3RvfSwgYmFzZSBjYW5ub3QgYmUgbGVzcyB0aGFuIDJgKTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY29udmVydFJhZGl4OiBkYXRhIHNob3VsZCBiZSBhcnJheScpO1xuICAgIGlmICghZGF0YS5sZW5ndGgpXG4gICAgICAgIHJldHVybiBbXTtcbiAgICBsZXQgcG9zID0gMDtcbiAgICBjb25zdCByZXMgPSBbXTtcbiAgICBjb25zdCBkaWdpdHMgPSBBcnJheS5mcm9tKGRhdGEpO1xuICAgIGRpZ2l0cy5mb3JFYWNoKChkKSA9PiB7XG4gICAgICAgIGFzc2VydE51bWJlcihkKTtcbiAgICAgICAgaWYgKGQgPCAwIHx8IGQgPj0gZnJvbSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgV3JvbmcgaW50ZWdlcjogJHtkfWApO1xuICAgIH0pO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGxldCBjYXJyeSA9IDA7XG4gICAgICAgIGxldCBkb25lID0gdHJ1ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHBvczsgaSA8IGRpZ2l0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZGlnaXQgPSBkaWdpdHNbaV07XG4gICAgICAgICAgICBjb25zdCBkaWdpdEJhc2UgPSBmcm9tICogY2FycnkgKyBkaWdpdDtcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoZGlnaXRCYXNlKSB8fFxuICAgICAgICAgICAgICAgIChmcm9tICogY2FycnkpIC8gZnJvbSAhPT0gY2FycnkgfHxcbiAgICAgICAgICAgICAgICBkaWdpdEJhc2UgLSBkaWdpdCAhPT0gZnJvbSAqIGNhcnJ5KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb252ZXJ0UmFkaXg6IGNhcnJ5IG92ZXJmbG93Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXJyeSA9IGRpZ2l0QmFzZSAlIHRvO1xuICAgICAgICAgICAgZGlnaXRzW2ldID0gTWF0aC5mbG9vcihkaWdpdEJhc2UgLyB0byk7XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGRpZ2l0c1tpXSkgfHwgZGlnaXRzW2ldICogdG8gKyBjYXJyeSAhPT0gZGlnaXRCYXNlKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY29udmVydFJhZGl4OiBjYXJyeSBvdmVyZmxvdycpO1xuICAgICAgICAgICAgaWYgKCFkb25lKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgZWxzZSBpZiAoIWRpZ2l0c1tpXSlcbiAgICAgICAgICAgICAgICBwb3MgPSBpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGRvbmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXMucHVzaChjYXJyeSk7XG4gICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGggLSAxICYmIGRhdGFbaV0gPT09IDA7IGkrKylcbiAgICAgICAgcmVzLnB1c2goMCk7XG4gICAgcmV0dXJuIHJlcy5yZXZlcnNlKCk7XG59XG5jb25zdCBnY2QgPSAoYSwgYikgPT4gKCFiID8gYSA6IGdjZChiLCBhICUgYikpO1xuY29uc3QgcmFkaXgyY2FycnkgPSAoZnJvbSwgdG8pID0+IGZyb20gKyAodG8gLSBnY2QoZnJvbSwgdG8pKTtcbmZ1bmN0aW9uIGNvbnZlcnRSYWRpeDIoZGF0YSwgZnJvbSwgdG8sIHBhZGRpbmcpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY29udmVydFJhZGl4MjogZGF0YSBzaG91bGQgYmUgYXJyYXknKTtcbiAgICBpZiAoZnJvbSA8PSAwIHx8IGZyb20gPiAzMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb252ZXJ0UmFkaXgyOiB3cm9uZyBmcm9tPSR7ZnJvbX1gKTtcbiAgICBpZiAodG8gPD0gMCB8fCB0byA+IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDI6IHdyb25nIHRvPSR7dG99YCk7XG4gICAgaWYgKHJhZGl4MmNhcnJ5KGZyb20sIHRvKSA+IDMyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4MjogY2Fycnkgb3ZlcmZsb3cgZnJvbT0ke2Zyb219IHRvPSR7dG99IGNhcnJ5Qml0cz0ke3JhZGl4MmNhcnJ5KGZyb20sIHRvKX1gKTtcbiAgICB9XG4gICAgbGV0IGNhcnJ5ID0gMDtcbiAgICBsZXQgcG9zID0gMDtcbiAgICBjb25zdCBtYXNrID0gMiAqKiB0byAtIDE7XG4gICAgY29uc3QgcmVzID0gW107XG4gICAgZm9yIChjb25zdCBuIG9mIGRhdGEpIHtcbiAgICAgICAgYXNzZXJ0TnVtYmVyKG4pO1xuICAgICAgICBpZiAobiA+PSAyICoqIGZyb20pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnZlcnRSYWRpeDI6IGludmFsaWQgZGF0YSB3b3JkPSR7bn0gZnJvbT0ke2Zyb219YCk7XG4gICAgICAgIGNhcnJ5ID0gKGNhcnJ5IDw8IGZyb20pIHwgbjtcbiAgICAgICAgaWYgKHBvcyArIGZyb20gPiAzMilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY29udmVydFJhZGl4MjogY2Fycnkgb3ZlcmZsb3cgcG9zPSR7cG9zfSBmcm9tPSR7ZnJvbX1gKTtcbiAgICAgICAgcG9zICs9IGZyb207XG4gICAgICAgIGZvciAoOyBwb3MgPj0gdG87IHBvcyAtPSB0bylcbiAgICAgICAgICAgIHJlcy5wdXNoKCgoY2FycnkgPj4gKHBvcyAtIHRvKSkgJiBtYXNrKSA+Pj4gMCk7XG4gICAgICAgIGNhcnJ5ICY9IDIgKiogcG9zIC0gMTtcbiAgICB9XG4gICAgY2FycnkgPSAoY2FycnkgPDwgKHRvIC0gcG9zKSkgJiBtYXNrO1xuICAgIGlmICghcGFkZGluZyAmJiBwb3MgPj0gZnJvbSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeGNlc3MgcGFkZGluZycpO1xuICAgIGlmICghcGFkZGluZyAmJiBjYXJyeSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb24temVybyBwYWRkaW5nOiAke2NhcnJ5fWApO1xuICAgIGlmIChwYWRkaW5nICYmIHBvcyA+IDApXG4gICAgICAgIHJlcy5wdXNoKGNhcnJ5ID4+PiAwKTtcbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gcmFkaXgobnVtKSB7XG4gICAgYXNzZXJ0TnVtYmVyKG51bSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlOiAoYnl0ZXMpID0+IHtcbiAgICAgICAgICAgIGlmICghKGJ5dGVzIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpeC5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIFVpbnQ4QXJyYXknKTtcbiAgICAgICAgICAgIHJldHVybiBjb252ZXJ0UmFkaXgoQXJyYXkuZnJvbShieXRlcyksIDIgKiogOCwgbnVtKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlOiAoZGlnaXRzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGlnaXRzKSB8fCAoZGlnaXRzLmxlbmd0aCAmJiB0eXBlb2YgZGlnaXRzWzBdICE9PSAnbnVtYmVyJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpeC5kZWNvZGUgaW5wdXQgc2hvdWxkIGJlIGFycmF5IG9mIHN0cmluZ3MnKTtcbiAgICAgICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oY29udmVydFJhZGl4KGRpZ2l0cywgbnVtLCAyICoqIDgpKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gcmFkaXgyKGJpdHMsIHJldlBhZGRpbmcgPSBmYWxzZSkge1xuICAgIGFzc2VydE51bWJlcihiaXRzKTtcbiAgICBpZiAoYml0cyA8PSAwIHx8IGJpdHMgPiAzMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYWRpeDI6IGJpdHMgc2hvdWxkIGJlIGluICgwLi4zMl0nKTtcbiAgICBpZiAocmFkaXgyY2FycnkoOCwgYml0cykgPiAzMiB8fCByYWRpeDJjYXJyeShiaXRzLCA4KSA+IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4MjogY2Fycnkgb3ZlcmZsb3cnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGU6IChieXRlcykgPT4ge1xuICAgICAgICAgICAgaWYgKCEoYnl0ZXMgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JhZGl4Mi5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIFVpbnQ4QXJyYXknKTtcbiAgICAgICAgICAgIHJldHVybiBjb252ZXJ0UmFkaXgyKEFycmF5LmZyb20oYnl0ZXMpLCA4LCBiaXRzLCAhcmV2UGFkZGluZyk7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZTogKGRpZ2l0cykgPT4ge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRpZ2l0cykgfHwgKGRpZ2l0cy5sZW5ndGggJiYgdHlwZW9mIGRpZ2l0c1swXSAhPT0gJ251bWJlcicpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmFkaXgyLmRlY29kZSBpbnB1dCBzaG91bGQgYmUgYXJyYXkgb2Ygc3RyaW5ncycpO1xuICAgICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShjb252ZXJ0UmFkaXgyKGRpZ2l0cywgYml0cywgOCwgcmV2UGFkZGluZykpO1xuICAgICAgICB9LFxuICAgIH07XG59XG5mdW5jdGlvbiB1bnNhZmVXcmFwcGVyKGZuKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnNhZmVXcmFwcGVyIGZuIHNob3VsZCBiZSBmdW5jdGlvbicpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICB9O1xufVxuZnVuY3Rpb24gY2hlY2tzdW0obGVuLCBmbikge1xuICAgIGFzc2VydE51bWJlcihsZW4pO1xuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY2hlY2tzdW0gZm4gc2hvdWxkIGJlIGZ1bmN0aW9uJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlKGRhdGEpIHtcbiAgICAgICAgICAgIGlmICghKGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NoZWNrc3VtLmVuY29kZTogaW5wdXQgc2hvdWxkIGJlIFVpbnQ4QXJyYXknKTtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrc3VtID0gZm4oZGF0YSkuc2xpY2UoMCwgbGVuKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KGRhdGEubGVuZ3RoICsgbGVuKTtcbiAgICAgICAgICAgIHJlcy5zZXQoZGF0YSk7XG4gICAgICAgICAgICByZXMuc2V0KGNoZWNrc3VtLCBkYXRhLmxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGUoZGF0YSkge1xuICAgICAgICAgICAgaWYgKCEoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2hlY2tzdW0uZGVjb2RlOiBpbnB1dCBzaG91bGQgYmUgVWludDhBcnJheScpO1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IGRhdGEuc2xpY2UoMCwgLWxlbik7XG4gICAgICAgICAgICBjb25zdCBuZXdDaGVja3N1bSA9IGZuKHBheWxvYWQpLnNsaWNlKDAsIGxlbik7XG4gICAgICAgICAgICBjb25zdCBvbGRDaGVja3N1bSA9IGRhdGEuc2xpY2UoLWxlbik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgICAgICAgICAgIGlmIChuZXdDaGVja3N1bVtpXSAhPT0gb2xkQ2hlY2tzdW1baV0pXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjaGVja3N1bScpO1xuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmV4cG9ydCBjb25zdCB1dGlscyA9IHsgYWxwaGFiZXQsIGNoYWluLCBjaGVja3N1bSwgcmFkaXgsIHJhZGl4Miwgam9pbiwgcGFkZGluZyB9O1xuZXhwb3J0IGNvbnN0IGJhc2UxNiA9IGNoYWluKHJhZGl4Mig0KSwgYWxwaGFiZXQoJzAxMjM0NTY3ODlBQkNERUYnKSwgam9pbignJykpO1xuZXhwb3J0IGNvbnN0IGJhc2UzMiA9IGNoYWluKHJhZGl4Mig1KSwgYWxwaGFiZXQoJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaMjM0NTY3JyksIHBhZGRpbmcoNSksIGpvaW4oJycpKTtcbmV4cG9ydCBjb25zdCBiYXNlMzJoZXggPSBjaGFpbihyYWRpeDIoNSksIGFscGhhYmV0KCcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVicpLCBwYWRkaW5nKDUpLCBqb2luKCcnKSk7XG5leHBvcnQgY29uc3QgYmFzZTMyY3JvY2tmb3JkID0gY2hhaW4ocmFkaXgyKDUpLCBhbHBoYWJldCgnMDEyMzQ1Njc4OUFCQ0RFRkdISktNTlBRUlNUVldYWVonKSwgam9pbignJyksIG5vcm1hbGl6ZSgocykgPT4gcy50b1VwcGVyQ2FzZSgpLnJlcGxhY2UoL08vZywgJzAnKS5yZXBsYWNlKC9bSUxdL2csICcxJykpKTtcbmV4cG9ydCBjb25zdCBiYXNlNjQgPSBjaGFpbihyYWRpeDIoNiksIGFscGhhYmV0KCdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJyksIHBhZGRpbmcoNiksIGpvaW4oJycpKTtcbmV4cG9ydCBjb25zdCBiYXNlNjR1cmwgPSBjaGFpbihyYWRpeDIoNiksIGFscGhhYmV0KCdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1fJyksIHBhZGRpbmcoNiksIGpvaW4oJycpKTtcbmNvbnN0IGdlbkJhc2U1OCA9IChhYmMpID0+IGNoYWluKHJhZGl4KDU4KSwgYWxwaGFiZXQoYWJjKSwgam9pbignJykpO1xuZXhwb3J0IGNvbnN0IGJhc2U1OCA9IGdlbkJhc2U1OCgnMTIzNDU2Nzg5QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaYWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5eicpO1xuZXhwb3J0IGNvbnN0IGJhc2U1OGZsaWNrciA9IGdlbkJhc2U1OCgnMTIzNDU2Nzg5YWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5ekFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWicpO1xuZXhwb3J0IGNvbnN0IGJhc2U1OHhycCA9IGdlbkJhc2U1OCgncnBzaG5hZjM5d0JVRE5FR0hKS0xNNFBRUlNUN1ZXWFlaMmJjZGVDZzY1amttOG9GcWkxdHV2QXh5eicpO1xuY29uc3QgWE1SX0JMT0NLX0xFTiA9IFswLCAyLCAzLCA1LCA2LCA3LCA5LCAxMCwgMTFdO1xuZXhwb3J0IGNvbnN0IGJhc2U1OHhtciA9IHtcbiAgICBlbmNvZGUoZGF0YSkge1xuICAgICAgICBsZXQgcmVzID0gJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gOCkge1xuICAgICAgICAgICAgY29uc3QgYmxvY2sgPSBkYXRhLnN1YmFycmF5KGksIGkgKyA4KTtcbiAgICAgICAgICAgIHJlcyArPSBiYXNlNTguZW5jb2RlKGJsb2NrKS5wYWRTdGFydChYTVJfQkxPQ0tfTEVOW2Jsb2NrLmxlbmd0aF0sICcxJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9LFxuICAgIGRlY29kZShzdHIpIHtcbiAgICAgICAgbGV0IHJlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkgKz0gMTEpIHtcbiAgICAgICAgICAgIGNvbnN0IHNsaWNlID0gc3RyLnNsaWNlKGksIGkgKyAxMSk7XG4gICAgICAgICAgICBjb25zdCBibG9ja0xlbiA9IFhNUl9CTE9DS19MRU4uaW5kZXhPZihzbGljZS5sZW5ndGgpO1xuICAgICAgICAgICAgY29uc3QgYmxvY2sgPSBiYXNlNTguZGVjb2RlKHNsaWNlKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYmxvY2subGVuZ3RoIC0gYmxvY2tMZW47IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChibG9ja1tqXSAhPT0gMClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYXNlNTh4bXI6IHdyb25nIHBhZGRpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcyA9IHJlcy5jb25jYXQoQXJyYXkuZnJvbShibG9jay5zbGljZShibG9jay5sZW5ndGggLSBibG9ja0xlbikpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKHJlcyk7XG4gICAgfSxcbn07XG5leHBvcnQgY29uc3QgYmFzZTU4Y2hlY2sgPSAoc2hhMjU2KSA9PiBjaGFpbihjaGVja3N1bSg0LCAoZGF0YSkgPT4gc2hhMjU2KHNoYTI1NihkYXRhKSkpLCBiYXNlNTgpO1xuY29uc3QgQkVDSF9BTFBIQUJFVCA9IGNoYWluKGFscGhhYmV0KCdxcHpyeTl4OGdmMnR2ZHcwczNqbjU0a2hjZTZtdWE3bCcpLCBqb2luKCcnKSk7XG5jb25zdCBQT0xZTU9EX0dFTkVSQVRPUlMgPSBbMHgzYjZhNTdiMiwgMHgyNjUwOGU2ZCwgMHgxZWExMTlmYSwgMHgzZDQyMzNkZCwgMHgyYTE0NjJiM107XG5mdW5jdGlvbiBiZWNoMzJQb2x5bW9kKHByZSkge1xuICAgIGNvbnN0IGIgPSBwcmUgPj4gMjU7XG4gICAgbGV0IGNoayA9IChwcmUgJiAweDFmZmZmZmYpIDw8IDU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBQT0xZTU9EX0dFTkVSQVRPUlMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCgoYiA+PiBpKSAmIDEpID09PSAxKVxuICAgICAgICAgICAgY2hrIF49IFBPTFlNT0RfR0VORVJBVE9SU1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIGNoaztcbn1cbmZ1bmN0aW9uIGJlY2hDaGVja3N1bShwcmVmaXgsIHdvcmRzLCBlbmNvZGluZ0NvbnN0ID0gMSkge1xuICAgIGNvbnN0IGxlbiA9IHByZWZpeC5sZW5ndGg7XG4gICAgbGV0IGNoayA9IDE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjb25zdCBjID0gcHJlZml4LmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjIDwgMzMgfHwgYyA+IDEyNilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwcmVmaXggKCR7cHJlZml4fSlgKTtcbiAgICAgICAgY2hrID0gYmVjaDMyUG9seW1vZChjaGspIF4gKGMgPj4gNSk7XG4gICAgfVxuICAgIGNoayA9IGJlY2gzMlBvbHltb2QoY2hrKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgICBjaGsgPSBiZWNoMzJQb2x5bW9kKGNoaykgXiAocHJlZml4LmNoYXJDb2RlQXQoaSkgJiAweDFmKTtcbiAgICBmb3IgKGxldCB2IG9mIHdvcmRzKVxuICAgICAgICBjaGsgPSBiZWNoMzJQb2x5bW9kKGNoaykgXiB2O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKVxuICAgICAgICBjaGsgPSBiZWNoMzJQb2x5bW9kKGNoayk7XG4gICAgY2hrIF49IGVuY29kaW5nQ29uc3Q7XG4gICAgcmV0dXJuIEJFQ0hfQUxQSEFCRVQuZW5jb2RlKGNvbnZlcnRSYWRpeDIoW2NoayAlIDIgKiogMzBdLCAzMCwgNSwgZmFsc2UpKTtcbn1cbmZ1bmN0aW9uIGdlbkJlY2gzMihlbmNvZGluZykge1xuICAgIGNvbnN0IEVOQ09ESU5HX0NPTlNUID0gZW5jb2RpbmcgPT09ICdiZWNoMzInID8gMSA6IDB4MmJjODMwYTM7XG4gICAgY29uc3QgX3dvcmRzID0gcmFkaXgyKDUpO1xuICAgIGNvbnN0IGZyb21Xb3JkcyA9IF93b3Jkcy5kZWNvZGU7XG4gICAgY29uc3QgdG9Xb3JkcyA9IF93b3Jkcy5lbmNvZGU7XG4gICAgY29uc3QgZnJvbVdvcmRzVW5zYWZlID0gdW5zYWZlV3JhcHBlcihmcm9tV29yZHMpO1xuICAgIGZ1bmN0aW9uIGVuY29kZShwcmVmaXgsIHdvcmRzLCBsaW1pdCA9IDkwKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcHJlZml4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYmVjaDMyLmVuY29kZSBwcmVmaXggc2hvdWxkIGJlIHN0cmluZywgbm90ICR7dHlwZW9mIHByZWZpeH1gKTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHdvcmRzKSB8fCAod29yZHMubGVuZ3RoICYmIHR5cGVvZiB3b3Jkc1swXSAhPT0gJ251bWJlcicpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBiZWNoMzIuZW5jb2RlIHdvcmRzIHNob3VsZCBiZSBhcnJheSBvZiBudW1iZXJzLCBub3QgJHt0eXBlb2Ygd29yZHN9YCk7XG4gICAgICAgIGNvbnN0IGFjdHVhbExlbmd0aCA9IHByZWZpeC5sZW5ndGggKyA3ICsgd29yZHMubGVuZ3RoO1xuICAgICAgICBpZiAobGltaXQgIT09IGZhbHNlICYmIGFjdHVhbExlbmd0aCA+IGxpbWl0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTGVuZ3RoICR7YWN0dWFsTGVuZ3RofSBleGNlZWRzIGxpbWl0ICR7bGltaXR9YCk7XG4gICAgICAgIHByZWZpeCA9IHByZWZpeC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXR1cm4gYCR7cHJlZml4fTEke0JFQ0hfQUxQSEFCRVQuZW5jb2RlKHdvcmRzKX0ke2JlY2hDaGVja3N1bShwcmVmaXgsIHdvcmRzLCBFTkNPRElOR19DT05TVCl9YDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVjb2RlKHN0ciwgbGltaXQgPSA5MCkge1xuICAgICAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJlY2gzMi5kZWNvZGUgaW5wdXQgc2hvdWxkIGJlIHN0cmluZywgbm90ICR7dHlwZW9mIHN0cn1gKTtcbiAgICAgICAgaWYgKHN0ci5sZW5ndGggPCA4IHx8IChsaW1pdCAhPT0gZmFsc2UgJiYgc3RyLmxlbmd0aCA+IGxpbWl0KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFdyb25nIHN0cmluZyBsZW5ndGg6ICR7c3RyLmxlbmd0aH0gKCR7c3RyfSkuIEV4cGVjdGVkICg4Li4ke2xpbWl0fSlgKTtcbiAgICAgICAgY29uc3QgbG93ZXJlZCA9IHN0ci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoc3RyICE9PSBsb3dlcmVkICYmIHN0ciAhPT0gc3RyLnRvVXBwZXJDYXNlKCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFN0cmluZyBtdXN0IGJlIGxvd2VyY2FzZSBvciB1cHBlcmNhc2VgKTtcbiAgICAgICAgc3RyID0gbG93ZXJlZDtcbiAgICAgICAgY29uc3Qgc2VwSW5kZXggPSBzdHIubGFzdEluZGV4T2YoJzEnKTtcbiAgICAgICAgaWYgKHNlcEluZGV4ID09PSAwIHx8IHNlcEluZGV4ID09PSAtMSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTGV0dGVyIFwiMVwiIG11c3QgYmUgcHJlc2VudCBiZXR3ZWVuIHByZWZpeCBhbmQgZGF0YSBvbmx5YCk7XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IHN0ci5zbGljZSgwLCBzZXBJbmRleCk7XG4gICAgICAgIGNvbnN0IF93b3JkcyA9IHN0ci5zbGljZShzZXBJbmRleCArIDEpO1xuICAgICAgICBpZiAoX3dvcmRzLmxlbmd0aCA8IDYpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgbXVzdCBiZSBhdCBsZWFzdCA2IGNoYXJhY3RlcnMgbG9uZycpO1xuICAgICAgICBjb25zdCB3b3JkcyA9IEJFQ0hfQUxQSEFCRVQuZGVjb2RlKF93b3Jkcykuc2xpY2UoMCwgLTYpO1xuICAgICAgICBjb25zdCBzdW0gPSBiZWNoQ2hlY2tzdW0ocHJlZml4LCB3b3JkcywgRU5DT0RJTkdfQ09OU1QpO1xuICAgICAgICBpZiAoIV93b3Jkcy5lbmRzV2l0aChzdW0pKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNoZWNrc3VtIGluICR7c3RyfTogZXhwZWN0ZWQgXCIke3N1bX1cImApO1xuICAgICAgICByZXR1cm4geyBwcmVmaXgsIHdvcmRzIH07XG4gICAgfVxuICAgIGNvbnN0IGRlY29kZVVuc2FmZSA9IHVuc2FmZVdyYXBwZXIoZGVjb2RlKTtcbiAgICBmdW5jdGlvbiBkZWNvZGVUb0J5dGVzKHN0cikge1xuICAgICAgICBjb25zdCB7IHByZWZpeCwgd29yZHMgfSA9IGRlY29kZShzdHIsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHsgcHJlZml4LCB3b3JkcywgYnl0ZXM6IGZyb21Xb3Jkcyh3b3JkcykgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgZW5jb2RlLCBkZWNvZGUsIGRlY29kZVRvQnl0ZXMsIGRlY29kZVVuc2FmZSwgZnJvbVdvcmRzLCBmcm9tV29yZHNVbnNhZmUsIHRvV29yZHMgfTtcbn1cbmV4cG9ydCBjb25zdCBiZWNoMzIgPSBnZW5CZWNoMzIoJ2JlY2gzMicpO1xuZXhwb3J0IGNvbnN0IGJlY2gzMm0gPSBnZW5CZWNoMzIoJ2JlY2gzMm0nKTtcbmV4cG9ydCBjb25zdCB1dGY4ID0ge1xuICAgIGVuY29kZTogKGRhdGEpID0+IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShkYXRhKSxcbiAgICBkZWNvZGU6IChzdHIpID0+IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpLFxufTtcbmV4cG9ydCBjb25zdCBoZXggPSBjaGFpbihyYWRpeDIoNCksIGFscGhhYmV0KCcwMTIzNDU2Nzg5YWJjZGVmJyksIGpvaW4oJycpLCBub3JtYWxpemUoKHMpID0+IHtcbiAgICBpZiAodHlwZW9mIHMgIT09ICdzdHJpbmcnIHx8IHMubGVuZ3RoICUgMilcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgaGV4LmRlY29kZTogZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygc30gd2l0aCBsZW5ndGggJHtzLmxlbmd0aH1gKTtcbiAgICByZXR1cm4gcy50b0xvd2VyQ2FzZSgpO1xufSkpO1xuY29uc3QgQ09ERVJTID0ge1xuICAgIHV0ZjgsIGhleCwgYmFzZTE2LCBiYXNlMzIsIGJhc2U2NCwgYmFzZTY0dXJsLCBiYXNlNTgsIGJhc2U1OHhtclxufTtcbmNvbnN0IGNvZGVyVHlwZUVycm9yID0gYEludmFsaWQgZW5jb2RpbmcgdHlwZS4gQXZhaWxhYmxlIHR5cGVzOiAke09iamVjdC5rZXlzKENPREVSUykuam9pbignLCAnKX1gO1xuZXhwb3J0IGNvbnN0IGJ5dGVzVG9TdHJpbmcgPSAodHlwZSwgYnl0ZXMpID0+IHtcbiAgICBpZiAodHlwZW9mIHR5cGUgIT09ICdzdHJpbmcnIHx8ICFDT0RFUlMuaGFzT3duUHJvcGVydHkodHlwZSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoY29kZXJUeXBlRXJyb3IpO1xuICAgIGlmICghKGJ5dGVzIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2J5dGVzVG9TdHJpbmcoKSBleHBlY3RzIFVpbnQ4QXJyYXknKTtcbiAgICByZXR1cm4gQ09ERVJTW3R5cGVdLmVuY29kZShieXRlcyk7XG59O1xuZXhwb3J0IGNvbnN0IHN0ciA9IGJ5dGVzVG9TdHJpbmc7XG5leHBvcnQgY29uc3Qgc3RyaW5nVG9CeXRlcyA9ICh0eXBlLCBzdHIpID0+IHtcbiAgICBpZiAoIUNPREVSUy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihjb2RlclR5cGVFcnJvcik7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzdHJpbmdUb0J5dGVzKCkgZXhwZWN0cyBzdHJpbmcnKTtcbiAgICByZXR1cm4gQ09ERVJTW3R5cGVdLmRlY29kZShzdHIpO1xufTtcbmV4cG9ydCBjb25zdCBieXRlcyA9IHN0cmluZ1RvQnl0ZXM7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@nostr-dev-kit/ndk/node_modules/nostr-tools/node_modules/@scure/base/lib/esm/index.js\n");

/***/ })

};
;